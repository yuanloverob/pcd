{
  "cve_id": "CVE-2017-6886",
  "cve_desc": "An error within the \"parse_tiff_ifd()\" function (internal/dcraw_common.cpp) in LibRaw versions before 0.18.2 can be exploited to corrupt memory.",
  "repo": "LibRaw/LibRaw",
  "patch_hash": "d7c3d2cb460be10a3ea7b32e9443a83c243b2251",
  "patch_info": {
    "commit_hash": "d7c3d2cb460be10a3ea7b32e9443a83c243b2251",
    "repo": "LibRaw/LibRaw",
    "commit_url": "https://github.com/LibRaw/LibRaw/commit/d7c3d2cb460be10a3ea7b32e9443a83c243b2251",
    "files": [
      "dcraw/dcraw.c",
      "internal/dcraw_common.cpp"
    ],
    "message": "Secunia SA75000 advisory: several buffer overruns",
    "before_after_code_files": [
      "dcraw/dcraw.c||dcraw/dcraw.c",
      "internal/dcraw_common.cpp||internal/dcraw_common.cpp"
    ]
  },
  "patch_diff": {
    "dcraw/dcraw.c||dcraw/dcraw.c": [
      "File: dcraw/dcraw.c -> dcraw/dcraw.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "12870:         load_raw = &CLASS sony_arw_load_raw;",
      "12871:         data_offset = get4() + base;",
      "12872:         ifd++;",
      "12873:         break;",
      "12874:       }",
      "12875: #ifdef LIBRAW_LIBRARY_BUILD",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "12873: #ifdef LIBRAW_LIBRARY_BUILD",
      "12874:  if (ifd >= sizeof tiff_ifd / sizeof tiff_ifd[0])",
      "12875:    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
      "12876: #endif",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "13177:       break;",
      "13179:     case 50455:",
      "13181:         break;",
      "13182: #ifndef LIBRAW_LIBRARY_BUILD",
      "13183:       fread(cbuf, 1, len, ifp);",
      "",
      "[Removed Lines]",
      "13180:       if (len > 2560000 || !(cbuf = (char *)malloc(len)))",
      "",
      "[Added Lines]",
      "13184:       if (len < 1 || len > 2560000 || !(cbuf = (char *)malloc(len)))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "14795:     }",
      "14796:     order = get2();",
      "14797:     hlen = get4();",
      "14799:     {",
      "14800: #ifdef LIBRAW_LIBRARY_BUILD",
      "14801:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "14802:     if (get4() == 0x48454150",
      "14803: #ifdef LIBRAW_LIBRARY_BUILD",
      "14804:  && (save+hlen) >= 0 && (save+hlen)<=ifp->size()",
      "14805: #endif",
      "",
      "---------------"
    ],
    "internal/dcraw_common.cpp||internal/dcraw_common.cpp": [
      "File: internal/dcraw_common.cpp -> internal/dcraw_common.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "11542:         load_raw = &CLASS sony_arw_load_raw;",
      "11543:         data_offset = get4() + base;",
      "11544:         ifd++;",
      "11545:         break;",
      "11546:       }",
      "11547: #ifdef LIBRAW_LIBRARY_BUILD",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "11545: #ifdef LIBRAW_LIBRARY_BUILD",
      "11546:  if (ifd >= sizeof tiff_ifd / sizeof tiff_ifd[0])",
      "11547:    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
      "11548: #endif",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "11849:       break;",
      "11851:     case 50455:",
      "11853:         break;",
      "11854: #ifndef LIBRAW_LIBRARY_BUILD",
      "11855:       fread(cbuf, 1, len, ifp);",
      "",
      "[Removed Lines]",
      "11852:       if (len > 2560000 || !(cbuf = (char *)malloc(len)))",
      "",
      "[Added Lines]",
      "11856:       if (len < 1 || len > 2560000 || !(cbuf = (char *)malloc(len)))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "13467:     }",
      "13468:     order = get2();",
      "13469:     hlen = get4();",
      "13471:     {",
      "13472: #ifdef LIBRAW_LIBRARY_BUILD",
      "13473:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "13474:     if (get4() == 0x48454150",
      "13475: #ifdef LIBRAW_LIBRARY_BUILD",
      "13476:  && (save+hlen) >= 0 && (save+hlen)<=ifp->size()",
      "13477: #endif",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "34373ae39d49494ebe0d4a9dfc3116da3ab1f19c",
      "candidate_info": {
        "commit_hash": "34373ae39d49494ebe0d4a9dfc3116da3ab1f19c",
        "repo": "LibRaw/LibRaw",
        "commit_url": "https://github.com/LibRaw/LibRaw/commit/34373ae39d49494ebe0d4a9dfc3116da3ab1f19c",
        "files": [
          "dcraw/dcraw.c",
          "internal/dcraw_common.cpp"
        ],
        "message": "Secunia SA75000 advisory: several buffer overruns",
        "before_after_code_files": [
          "dcraw/dcraw.c||dcraw/dcraw.c",
          "internal/dcraw_common.cpp||internal/dcraw_common.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_message": 1,
        "olp_code_files": {
          "patch": [
            "dcraw/dcraw.c||dcraw/dcraw.c",
            "internal/dcraw_common.cpp||internal/dcraw_common.cpp"
          ],
          "candidate": [
            "dcraw/dcraw.c||dcraw/dcraw.c",
            "internal/dcraw_common.cpp||internal/dcraw_common.cpp"
          ]
        }
      },
      "candidate_diff": {
        "dcraw/dcraw.c||dcraw/dcraw.c": [
          "File: dcraw/dcraw.c -> dcraw/dcraw.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "12886:         load_raw = &CLASS sony_arw_load_raw;",
          "12887:         data_offset = get4() + base;",
          "12888:         ifd++;",
          "12889:         break;",
          "12890:       }",
          "12891: #ifdef LIBRAW_LIBRARY_BUILD",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12889: #ifdef LIBRAW_LIBRARY_BUILD",
          "12890:  if (ifd >= sizeof tiff_ifd / sizeof tiff_ifd[0])",
          "12891:    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "12892: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "13193:       break;",
          "13195:     case 50455:",
          "13197:         break;",
          "13198: #ifndef LIBRAW_LIBRARY_BUILD",
          "13199:       fread(cbuf, 1, len, ifp);",
          "",
          "[Removed Lines]",
          "13196:       if (len > 2560000 || !(cbuf = (char *)malloc(len)))",
          "",
          "[Added Lines]",
          "13200:       if (len < 1 || len > 2560000 || !(cbuf = (char *)malloc(len)))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "14825:     }",
          "14826:     order = get2();",
          "14827:     hlen = get4();",
          "14829:     {",
          "14830: #ifdef LIBRAW_LIBRARY_BUILD",
          "14831:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14832:     if (get4() == 0x48454150",
          "14833: #ifdef LIBRAW_LIBRARY_BUILD",
          "14834:  && (save+hlen) >= 0 && (save+hlen)<=ifp->size()",
          "14835: #endif",
          "",
          "---------------"
        ],
        "internal/dcraw_common.cpp||internal/dcraw_common.cpp": [
          "File: internal/dcraw_common.cpp -> internal/dcraw_common.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "11558:         load_raw = &CLASS sony_arw_load_raw;",
          "11559:         data_offset = get4() + base;",
          "11560:         ifd++;",
          "11561:         break;",
          "11562:       }",
          "11563: #ifdef LIBRAW_LIBRARY_BUILD",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11561: #ifdef LIBRAW_LIBRARY_BUILD",
          "11562:  if (ifd >= sizeof tiff_ifd / sizeof tiff_ifd[0])",
          "11563:    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "11564: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "11865:       break;",
          "11867:     case 50455:",
          "11869:         break;",
          "11870: #ifndef LIBRAW_LIBRARY_BUILD",
          "11871:       fread(cbuf, 1, len, ifp);",
          "",
          "[Removed Lines]",
          "11868:       if (len > 2560000 || !(cbuf = (char *)malloc(len)))",
          "",
          "[Added Lines]",
          "11872:       if (len < 1 || len > 2560000 || !(cbuf = (char *)malloc(len)))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "13497:     }",
          "13498:     order = get2();",
          "13499:     hlen = get4();",
          "13501:     {",
          "13502: #ifdef LIBRAW_LIBRARY_BUILD",
          "13503:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13504:     if (get4() == 0x48454150",
          "13505: #ifdef LIBRAW_LIBRARY_BUILD",
          "13506:  && (save+hlen) >= 0 && (save+hlen)<=ifp->size()",
          "13507: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cfbebd722c604196513a354594941116d4ad2455",
      "candidate_info": {
        "commit_hash": "cfbebd722c604196513a354594941116d4ad2455",
        "repo": "LibRaw/LibRaw",
        "commit_url": "https://github.com/LibRaw/LibRaw/commit/cfbebd722c604196513a354594941116d4ad2455",
        "files": [
          "dcraw/dcraw.c",
          "internal/dcraw_common.cpp",
          "internal/defines.h",
          "libraw/libraw_types.h"
        ],
        "message": "divide by metadata",
        "before_after_code_files": [
          "dcraw/dcraw.c||dcraw/dcraw.c",
          "internal/dcraw_common.cpp||internal/dcraw_common.cpp",
          "internal/defines.h||internal/defines.h",
          "libraw/libraw_types.h||libraw/libraw_types.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "dcraw/dcraw.c||dcraw/dcraw.c",
            "internal/dcraw_common.cpp||internal/dcraw_common.cpp"
          ],
          "candidate": [
            "dcraw/dcraw.c||dcraw/dcraw.c",
            "internal/dcraw_common.cpp||internal/dcraw_common.cpp"
          ]
        }
      },
      "candidate_diff": {
        "dcraw/dcraw.c||dcraw/dcraw.c": [
          "File: dcraw/dcraw.c -> dcraw/dcraw.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "208: #define my_swap(type, i, j) {type t = i; i = j; j = t;}",
          "211:    In order to inline this calculation, I make the risky",
          "212:    assumption that all filter patterns can be described",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "210: static float fMAX(float a, float b)",
          "211: {",
          "212:   return MAX(a,b);",
          "213: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1584: {",
          "1585:   int row, col, yuv[4], rgb[3], b, c;",
          "1586:   UINT64 bitbuf=0;",
          "1588:   for (row=0; row < raw_height; row++)",
          "1589:   {",
          "1590: #ifdef LIBRAW_LIBRARY_BUILD",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1592:   float cmul[4];",
          "1593:   FORC4 { cmul[c] == cam_mul[c]>0.001f?cam_mul[c]:1.f; }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1600:       rgb[0] = yuv[b] + 1.370705*yuv[3];",
          "1601:       rgb[1] = yuv[b] - 0.337633*yuv[2] - 0.698001*yuv[3];",
          "1602:       rgb[2] = yuv[b] + 1.732446*yuv[2];",
          "1604:     }",
          "1605:   }",
          "1606: }",
          "",
          "[Removed Lines]",
          "1603:       FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,0xfff)] / cam_mul[c];",
          "",
          "[Added Lines]",
          "1609:       FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,0xfff)] / cmul[c];",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "7167:   imgdata.lens.makernotes.MaxFocal = get2();",
          "7168:   imgdata.lens.makernotes.MinFocal = get2();",
          "7169:   imgdata.lens.makernotes.CanonFocalUnits = get2();",
          "7171:     {",
          "7172:       imgdata.lens.makernotes.MaxFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "7173:       imgdata.lens.makernotes.MinFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "",
          "[Removed Lines]",
          "7170:   if (imgdata.lens.makernotes.CanonFocalUnits != 1)",
          "",
          "[Added Lines]",
          "7176:   if (imgdata.lens.makernotes.CanonFocalUnits > 1)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "7202:      {",
          "7203:   imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;",
          "7204:   fseek (ifp, 2, SEEK_CUR);",
          "7207:   imgdata.color.WBCT_Coeffs[i][0] = get2();",
          "7208:      }",
          "7209:  else if (WBCTversion == 1)",
          "7210:    for (int i=0; i<15; i++) // as shot R, as shot B, tint, C\u0421T",
          "7211:      {",
          "7212:   imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;",
          "7215:   fseek (ifp, 2, SEEK_CUR);",
          "7216:   imgdata.color.WBCT_Coeffs[i][0] = get2();",
          "7217:      }",
          "",
          "[Removed Lines]",
          "7205:   imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / (float)get2();",
          "7206:   imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / (float)get2();",
          "7213:   imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / (float)get2();",
          "7214:   imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / (float)get2();",
          "",
          "[Added Lines]",
          "7211:   imgdata.color.WBCT_Coeffs[i][1] = 1024.0f /fMAX(get2(),1.f) ;",
          "7212:   imgdata.color.WBCT_Coeffs[i][3] = 1024.0f /fMAX(get2(),1.f);",
          "7219:   imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(get2(),1.f);",
          "7220:   imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(get2(),1.f);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "7223:   fseek (ifp, 2, SEEK_CUR);",
          "7224:   fseek (ifp, 2, SEEK_CUR);",
          "7225:   imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;",
          "7228:   imgdata.color.WBCT_Coeffs[i][0] = get2();",
          "7229:      }",
          "7230:  else if ((WBCTversion == 2) &&",
          "",
          "[Removed Lines]",
          "7226:   imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / (float)get2();",
          "7227:   imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / (float)get2();",
          "",
          "[Added Lines]",
          "7232:   imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(1.f,get2());",
          "7233:   imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(1.f,get2());",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "8998:           {",
          "8999:             imgdata.lens.makernotes.FocalType = get2();",
          "9000:             imgdata.lens.makernotes.CurFocal = get2();",
          "9003:               {",
          "9004:                 imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "9005:               }",
          "",
          "[Removed Lines]",
          "9001:             if ((imgdata.lens.makernotes.CanonFocalUnits != 1) &&",
          "9002:                 imgdata.lens.makernotes.CanonFocalUnits)",
          "",
          "[Added Lines]",
          "9007:             if (imgdata.lens.makernotes.CanonFocalUnits > 1)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "10737:     if (tag == 1020) wbi = getint(type);",
          "10739:       fseek (ifp, 40, SEEK_CUR);",
          "10741:       wbi = -2;",
          "10742:     }",
          "",
          "[Removed Lines]",
          "10740:       FORC3 cam_mul[c] = 2048.0 / get2();",
          "",
          "[Added Lines]",
          "10745:       FORC3 cam_mul[c] = 2048.0 / fMAX(1.0f,get2());",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "10798:     if (tag == 1020) wbi = getint(type);",
          "10800:       fseek (ifp, 40, SEEK_CUR);",
          "10802:       wbi = -2;",
          "10803:     }",
          "10804:     if (tag == 2118) wbtemp = getint(type);",
          "10805:     if (tag == 2120 + wbi && wbi >= 0)",
          "10807:     if (tag == 2130 + wbi)",
          "10808:       FORC3 mul[c] = getreal(type);",
          "10809:     if (tag == 2140 + wbi && wbi >= 0)",
          "10810:       FORC3 {",
          "10811:  for (num=i=0; i < 4; i++)",
          "10812:    num += getreal(type) * pow (wbtemp/100.0, i);",
          "10814:       }",
          "10815:     if (tag == 2317) linear_table (len);",
          "10816:     if (tag == 6020) iso_speed = getint(type);",
          "",
          "[Removed Lines]",
          "10801:       FORC3 cam_mul[c] = 2048.0 / get2();",
          "10806:       FORC3 cam_mul[c] = 2048.0 / getreal(type);",
          "10813:  cam_mul[c] = 2048 / (num * mul[c]);",
          "",
          "[Added Lines]",
          "10806:       FORC3 cam_mul[c] = 2048.0 / fMAX(1.0,get2());",
          "10811:       FORC3 cam_mul[c] = 2048.0 / fMAX(1.0,getreal(type));",
          "10818:  cam_mul[c] = 2048 / fMAX(1.0,(num * mul[c]));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "11343:    if (!use_camera_wb) continue;",
          "11344:    num = 0;",
          "11345:    FORC4 num += rgb_cam[i][c];",
          "11347:  }",
          "11348:  break;",
          "",
          "[Removed Lines]",
          "11346:    FORC4 rgb_cam[i][c] /= num;",
          "",
          "[Added Lines]",
          "11351:    FORC4 rgb_cam[i][c] /= MAX(1,num);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "12389:       imgdata.lens.makernotes.FocalType = len & 0xffff;",
          "12390:       if (imgdata.lens.makernotes.FocalType == 2) {",
          "12391:         imgdata.lens.makernotes.CanonFocalUnits = 32;",
          "12393:       }",
          "12394:       focal_len = imgdata.lens.makernotes.CurFocal;",
          "12395: #else",
          "",
          "[Removed Lines]",
          "12392:         imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "",
          "[Added Lines]",
          "12397:  if(imgdata.lens.makernotes.CanonFocalUnits>1)",
          "12398:    imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "12677: #ifdef LIBRAW_LIBRARY_BUILD",
          "12678:     } else if (tag == 0x9650) {",
          "12680:     } else if (tag == 0x2100) {",
          "12681:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ 1] = get2();",
          "12682:     } else if (tag == 0x2200) {",
          "",
          "[Removed Lines]",
          "12679:       imgdata.makernotes.fuji.FujiExpoMidPointShift = ((short)get2()) / ((float)get2());",
          "",
          "[Added Lines]",
          "12685:       imgdata.makernotes.fuji.FujiExpoMidPointShift = ((short)get2()) / fMAX(1.0f,get2());",
          "",
          "---------------"
        ],
        "internal/dcraw_common.cpp||internal/dcraw_common.cpp": [
          "File: internal/dcraw_common.cpp -> internal/dcraw_common.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "1309: {",
          "1310:   int row, col, yuv[4], rgb[3], b, c;",
          "1311:   UINT64 bitbuf=0;",
          "1313:   for (row=0; row < raw_height; row++)",
          "1314:   {",
          "1315: #ifdef LIBRAW_LIBRARY_BUILD",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1312:   float cmul[4];",
          "1313:   FORC4 { cmul[c] == cam_mul[c]>0.001f?cam_mul[c]:1.f; }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1325:       rgb[0] = yuv[b] + 1.370705*yuv[3];",
          "1326:       rgb[1] = yuv[b] - 0.337633*yuv[2] - 0.698001*yuv[3];",
          "1327:       rgb[2] = yuv[b] + 1.732446*yuv[2];",
          "1329:     }",
          "1330:   }",
          "1331: }",
          "",
          "[Removed Lines]",
          "1328:       FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,0xfff)] / cam_mul[c];",
          "",
          "[Added Lines]",
          "1329:       FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,0xfff)] / cmul[c];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "5992:   imgdata.lens.makernotes.MaxFocal = get2();",
          "5993:   imgdata.lens.makernotes.MinFocal = get2();",
          "5994:   imgdata.lens.makernotes.CanonFocalUnits = get2();",
          "5996:     {",
          "5997:       imgdata.lens.makernotes.MaxFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "5998:       imgdata.lens.makernotes.MinFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "",
          "[Removed Lines]",
          "5995:   if (imgdata.lens.makernotes.CanonFocalUnits != 1)",
          "",
          "[Added Lines]",
          "5996:   if (imgdata.lens.makernotes.CanonFocalUnits > 1)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "6027:      {",
          "6028:   imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;",
          "6029:   fseek (ifp, 2, SEEK_CUR);",
          "6032:   imgdata.color.WBCT_Coeffs[i][0] = get2();",
          "6033:      }",
          "6034:  else if (WBCTversion == 1)",
          "6035:    for (int i=0; i<15; i++) // as shot R, as shot B, tint, C\u0421T",
          "6036:      {",
          "6037:   imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;",
          "6040:   fseek (ifp, 2, SEEK_CUR);",
          "6041:   imgdata.color.WBCT_Coeffs[i][0] = get2();",
          "6042:      }",
          "",
          "[Removed Lines]",
          "6030:   imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / (float)get2();",
          "6031:   imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / (float)get2();",
          "6038:   imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / (float)get2();",
          "6039:   imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / (float)get2();",
          "",
          "[Added Lines]",
          "6031:   imgdata.color.WBCT_Coeffs[i][1] = 1024.0f /fMAX(get2(),1.f) ;",
          "6032:   imgdata.color.WBCT_Coeffs[i][3] = 1024.0f /fMAX(get2(),1.f);",
          "6039:   imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(get2(),1.f);",
          "6040:   imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(get2(),1.f);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "6048:   fseek (ifp, 2, SEEK_CUR);",
          "6049:   fseek (ifp, 2, SEEK_CUR);",
          "6050:   imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;",
          "6053:   imgdata.color.WBCT_Coeffs[i][0] = get2();",
          "6054:      }",
          "6055:  else if ((WBCTversion == 2) &&",
          "",
          "[Removed Lines]",
          "6051:   imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / (float)get2();",
          "6052:   imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / (float)get2();",
          "",
          "[Added Lines]",
          "6052:   imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(1.f,get2());",
          "6053:   imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(1.f,get2());",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "7823:           {",
          "7824:             imgdata.lens.makernotes.FocalType = get2();",
          "7825:             imgdata.lens.makernotes.CurFocal = get2();",
          "7828:               {",
          "7829:                 imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "7830:               }",
          "",
          "[Removed Lines]",
          "7826:             if ((imgdata.lens.makernotes.CanonFocalUnits != 1) &&",
          "7827:                 imgdata.lens.makernotes.CanonFocalUnits)",
          "",
          "[Added Lines]",
          "7827:             if (imgdata.lens.makernotes.CanonFocalUnits > 1)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "9562:     if (tag == 1020) wbi = getint(type);",
          "9564:       fseek (ifp, 40, SEEK_CUR);",
          "9566:       wbi = -2;",
          "9567:     }",
          "",
          "[Removed Lines]",
          "9565:       FORC3 cam_mul[c] = 2048.0 / get2();",
          "",
          "[Added Lines]",
          "9565:       FORC3 cam_mul[c] = 2048.0 / fMAX(1.0f,get2());",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "9623:     if (tag == 1020) wbi = getint(type);",
          "9625:       fseek (ifp, 40, SEEK_CUR);",
          "9627:       wbi = -2;",
          "9628:     }",
          "9629:     if (tag == 2118) wbtemp = getint(type);",
          "9630:     if (tag == 2120 + wbi && wbi >= 0)",
          "9632:     if (tag == 2130 + wbi)",
          "9633:       FORC3 mul[c] = getreal(type);",
          "9634:     if (tag == 2140 + wbi && wbi >= 0)",
          "9635:       FORC3 {",
          "9636:  for (num=i=0; i < 4; i++)",
          "9637:    num += getreal(type) * pow (wbtemp/100.0, i);",
          "9639:       }",
          "9640:     if (tag == 2317) linear_table (len);",
          "9641:     if (tag == 6020) iso_speed = getint(type);",
          "",
          "[Removed Lines]",
          "9626:       FORC3 cam_mul[c] = 2048.0 / get2();",
          "9631:       FORC3 cam_mul[c] = 2048.0 / getreal(type);",
          "9638:  cam_mul[c] = 2048 / (num * mul[c]);",
          "",
          "[Added Lines]",
          "9626:       FORC3 cam_mul[c] = 2048.0 / fMAX(1.0,get2());",
          "9631:       FORC3 cam_mul[c] = 2048.0 / fMAX(1.0,getreal(type));",
          "9638:  cam_mul[c] = 2048 / fMAX(1.0,(num * mul[c]));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "10162:    if (!use_camera_wb) continue;",
          "10163:    num = 0;",
          "10164:    FORC4 num += rgb_cam[i][c];",
          "10166:  }",
          "10167:  break;",
          "",
          "[Removed Lines]",
          "10165:    FORC4 rgb_cam[i][c] /= num;",
          "",
          "[Added Lines]",
          "10165:    FORC4 rgb_cam[i][c] /= MAX(1,num);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "11208:       imgdata.lens.makernotes.FocalType = len & 0xffff;",
          "11209:       if (imgdata.lens.makernotes.FocalType == 2) {",
          "11210:         imgdata.lens.makernotes.CanonFocalUnits = 32;",
          "11212:       }",
          "11213:       focal_len = imgdata.lens.makernotes.CurFocal;",
          "11214: #else",
          "",
          "[Removed Lines]",
          "11211:         imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "",
          "[Added Lines]",
          "11211:  if(imgdata.lens.makernotes.CanonFocalUnits>1)",
          "11212:    imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "11496: #ifdef LIBRAW_LIBRARY_BUILD",
          "11497:     } else if (tag == 0x9650) {",
          "11499:     } else if (tag == 0x2100) {",
          "11500:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ 1] = get2();",
          "11501:     } else if (tag == 0x2200) {",
          "",
          "[Removed Lines]",
          "11498:       imgdata.makernotes.fuji.FujiExpoMidPointShift = ((short)get2()) / ((float)get2());",
          "",
          "[Added Lines]",
          "11499:       imgdata.makernotes.fuji.FujiExpoMidPointShift = ((short)get2()) / fMAX(1.0f,get2());",
          "",
          "---------------"
        ],
        "internal/defines.h||internal/defines.h": [
          "File: internal/defines.h -> internal/defines.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "113: #define my_swap(type, i, j) {type t = i; i = j; j = t;}",
          "116:    In order to inline this calculation, I make the risky",
          "117:    assumption that all filter patterns can be described",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "115: static float fMAX(float a, float b)",
          "116: {",
          "117:   return MAX(a,b);",
          "118: }",
          "",
          "---------------"
        ],
        "libraw/libraw_types.h||libraw/libraw_types.h": [
          "File: libraw/libraw_types.h -> libraw/libraw_types.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "538:   char         Adapter[128];",
          "539:   unsigned long long AttachmentID;",
          "540:   char         Attachment[128];",
          "542:   float        FocalLengthIn35mmFormat;",
          "543: } libraw_makernotes_lens_t;",
          "",
          "[Removed Lines]",
          "541:   short        CanonFocalUnits;",
          "",
          "[Added Lines]",
          "541:   ushort        CanonFocalUnits;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8d093558100bba26a2c3c16769d43e1279247b54",
      "candidate_info": {
        "commit_hash": "8d093558100bba26a2c3c16769d43e1279247b54",
        "repo": "LibRaw/LibRaw",
        "commit_url": "https://github.com/LibRaw/LibRaw/commit/8d093558100bba26a2c3c16769d43e1279247b54",
        "files": [
          "dcraw/dcraw.c",
          "internal/dcraw_common.cpp",
          "internal/defines.h"
        ],
        "message": "safety checks",
        "before_after_code_files": [
          "dcraw/dcraw.c||dcraw/dcraw.c",
          "internal/dcraw_common.cpp||internal/dcraw_common.cpp",
          "internal/defines.h||internal/defines.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "dcraw/dcraw.c||dcraw/dcraw.c",
            "internal/dcraw_common.cpp||internal/dcraw_common.cpp"
          ],
          "candidate": [
            "dcraw/dcraw.c||dcraw/dcraw.c",
            "internal/dcraw_common.cpp||internal/dcraw_common.cpp"
          ]
        }
      },
      "candidate_diff": {
        "dcraw/dcraw.c||dcraw/dcraw.c": [
          "File: dcraw/dcraw.c -> dcraw/dcraw.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "194: #define FORC(cnt) for (c=0; c < cnt; c++)",
          "195: #define FORC3 FORC(3)",
          "196: #define FORC4 FORC(4)",
          "199: #define SQR(x) ((x)*(x))",
          "200: #define ABS(x) (((int)(x) ^ ((int)(x) >> 31)) - ((int)(x) >> 31))",
          "",
          "[Removed Lines]",
          "197: #define FORCC FORC(colors)",
          "",
          "[Added Lines]",
          "197: #define FORCC for (c=0; c < colors && c < 4; c++)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "275: #include <math.h>",
          "276: #define CLASS LibRaw::",
          "277: #include \"libraw/libraw_types.h\"",
          "",
          "[Removed Lines]",
          "271: #ifdef ANDROID",
          "272: #include <libraw_swab.h>",
          "273: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "313:   const char *p = (const char *)memchr(s, 0, n);",
          "314:   return(p ? p-s : n);",
          "315: }",
          "317: #ifndef __GLIBC__",
          "318: char *my_memmem (char *haystack, size_t haystacklen,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "312: #ifdef LIBRAW_LIBRARY_BUILD",
          "313: static int stread(char *buf, size_t len, LibRaw_abstract_datastream *fp)",
          "314: {",
          "315:  int r = fp->read(buf,len,1);",
          "316:  buf[len-1] = 0;",
          "317:  return r;",
          "318: }",
          "319: #define stmread(buf,maxlen,fp) stread(buf,MIN(maxlen,sizeof(buf)),fp)",
          "320: #endif",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "7539: {",
          "7540:   int code [] = {3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 50, 100, 200, 400, 800, 1600, 3200, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278};",
          "7541:   double value []  = {50, 64, 80, 100, 125, 160, 200, 250, 320, 400, 500, 640, 800, 1000, 1250, 1600, 2000, 2500, 3200, 4000, 5000, 6400, 8000, 10000, 12800, 16000, 20000, 25600, 32000, 40000, 51200, 64000, 80000, 102400, 128000, 160000, 204800, 50, 100, 200, 400, 800, 1600, 3200, 50, 70, 100, 140, 200, 280, 400, 560, 800, 1100, 1600, 2200, 3200, 4500, 6400, 9000, 12800, 18000, 25600, 36000, 51200};",
          "7543:   int i;",
          "7544:   for (i = 0; i < numel; i++) {",
          "7545:     if (code[i] == c) {",
          "",
          "[Removed Lines]",
          "7542:   int numel = sizeof(code)/sizeof(code[0]);",
          "",
          "[Added Lines]",
          "7547: #define numel (sizeof(code)/sizeof(code[0]))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "7548:     }",
          "7549:   }",
          "7550:   if (i == numel) iso_speed = 65535.0f;",
          "7552: }",
          "7554: void CLASS PentaxLensInfo (unsigned id, unsigned len) // tag 0x0207",
          "7555: {",
          "",
          "[Removed Lines]",
          "7551:   return;",
          "",
          "[Added Lines]",
          "7557: #undef numel",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "8193:   short morder, sorder = order;",
          "8194:   char buf[10];",
          "8196:   fread(buf, 1, 10, ifp);",
          "8197:   if (!strcmp(buf, \"Nikon\")) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8200:   INT64 fsize = ifp->size();",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "8240:   while (entries--) {",
          "8241:     order = morder;",
          "8242:     tiff_get(base, &tag, &type, &len, &save);",
          "8243:     tag |= uptag << 16;",
          "8244:     if(len > 100*1024*1024) goto next; // 100Mb tag? No!",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8249:     INT64 pos = ifp->tell();",
          "8250:     if(len > 8 && pos+len > 2* fsize) continue;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "8273:             if (!aperture) aperture = imgdata.lens.makernotes.CurAp;",
          "8274:           }",
          "8277:           {",
          "8278:             CanonCameraInfo = (uchar*)malloc(len);",
          "8279:             fread(CanonCameraInfo, len, 1, ifp);",
          "",
          "[Removed Lines]",
          "8276:         else if (tag == 0x000d)   // camera info",
          "",
          "[Added Lines]",
          "8284:         else if (tag == 0x000d && len < 256000)   // camera info",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "8382:         }",
          "8383:         if ((tag == 0x0303) && (type != 4))",
          "8384:           {",
          "8386:           }",
          "8388:         if ((tag == 0x3405) ||",
          "",
          "[Removed Lines]",
          "8385:             fread(imgdata.lens.makernotes.Lens, MIN(len,127), 1, ifp);",
          "",
          "[Added Lines]",
          "8393:             stmread(imgdata.lens.makernotes.Lens, len,ifp);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "8454:           }",
          "8455:         else if (tag == 0x0082)    // lens attachment",
          "8456:           {",
          "8458:           }",
          "8459:         else if (tag == 0x0083)    // lens type",
          "8460:           {",
          "",
          "[Removed Lines]",
          "8457:             fread(imgdata.lens.makernotes.Attachment, MIN(len,127), 1, ifp);",
          "",
          "[Added Lines]",
          "8465:             stmread(imgdata.lens.makernotes.Attachment, len, ifp);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "8613:           imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type)/2);",
          "8614:           break;",
          "8615:         case 0x20100102:",
          "8617:         break;",
          "8618:         case 0x20100201:",
          "8619:           imgdata.lens.makernotes.LensID =",
          "",
          "[Removed Lines]",
          "8616:             fread(imgdata.shootinginfo.InternalBodySerial, MIN(len, sizeof(imgdata.shootinginfo.InternalBodySerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "8624:             stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "8631:           break;",
          "8632:         case 0x20100202:",
          "8633:           if ((!imgdata.lens.LensSerial[0]))",
          "8635:           break;",
          "8636:         case 0x20100203:",
          "8638:           break;",
          "8639:         case 0x20100205:",
          "8640:           imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "",
          "[Removed Lines]",
          "8634:               fread(imgdata.lens.LensSerial, MIN(len,sizeof(imgdata.lens.LensSerial)), 1, ifp);",
          "8637:           fread(imgdata.lens.makernotes.Lens, MIN(len,sizeof(imgdata.lens.makernotes.Lens)), 1, ifp);",
          "",
          "[Added Lines]",
          "8642:               stmread(imgdata.lens.LensSerial, len, ifp);",
          "8645:           stmread(imgdata.lens.makernotes.Lens,len, ifp);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "8660:             imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);",
          "8661:           break;",
          "8662:         case 0x20100303:",
          "8664:           break;",
          "8665:         case 0x20100403:",
          "8667:           break;",
          "8668:         case 0x20200401:",
          "8669:        imgdata.other.FlashEC = getreal(type);",
          "",
          "[Removed Lines]",
          "8663:           fread(imgdata.lens.makernotes.Teleconverter, MIN(len,127), 1, ifp);",
          "8666:           fread(imgdata.lens.makernotes.Attachment, MIN(len,127), 1, ifp);",
          "",
          "[Added Lines]",
          "8671:           stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);",
          "8674:           stmread(imgdata.lens.makernotes.Attachment,len, ifp);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "8711:            }",
          "8712:         else if (tag == 0x0207)",
          "8713:           {",
          "8715:           }",
          "8716:         else if (tag == 0x020d)",
          "8717:         {",
          "",
          "[Removed Lines]",
          "8714:             PentaxLensInfo(imgdata.lens.makernotes.CamID, len);",
          "",
          "[Added Lines]",
          "8722:      if(len < 65535) // Safety belt",
          "8723:                PentaxLensInfo(imgdata.lens.makernotes.CamID, len);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "8765:         }",
          "8766:         else if (tag == 0x0229)",
          "8767:         {",
          "8769:         }",
          "8770:         else if (tag == 0x022d)",
          "8771:         {",
          "",
          "[Removed Lines]",
          "8768:           fread(imgdata.shootinginfo.BodySerial, MIN(len, sizeof(imgdata.shootinginfo.BodySerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "8777:           stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "8792:           {",
          "8793:             char LensInfo [20];",
          "8794:             fseek (ifp, 12, SEEK_CUR);",
          "8796:             strcat(imgdata.lens.makernotes.Lens, \" \");",
          "8798:             strcat(imgdata.lens.makernotes.Lens, LensInfo);",
          "8799:           }",
          "8800:       }",
          "",
          "[Removed Lines]",
          "8795:             fread(imgdata.lens.makernotes.Lens, 30, 1, ifp);",
          "8797:             fread(LensInfo, 20, 1, ifp);",
          "",
          "[Added Lines]",
          "8804:             stread(imgdata.lens.makernotes.Lens, 30, ifp);",
          "8806:             stread(LensInfo, 20, ifp);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "8830:           }",
          "8831:         else if (tag == 0xa005)",
          "8832:           {",
          "8834:           }",
          "8835:         else if (tag == 0xa019)",
          "8836:           {",
          "",
          "[Removed Lines]",
          "8833:             fread(imgdata.lens.InternalLensSerial, MIN(len,sizeof(imgdata.lens.InternalLensSerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "8842:             stmread(imgdata.lens.InternalLensSerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "8945:             imgdata.lens.makernotes.TeleconverterID = get2();",
          "8946:           }",
          "8949:           {",
          "8950:             table_buf = (uchar*)malloc(len);",
          "8951:             fread(table_buf, len, 1, ifp);",
          "",
          "[Removed Lines]",
          "8948:         else if (tag == 0x0114)     // CameraSettings",
          "",
          "[Added Lines]",
          "8957:         else if (tag == 0x0114 && len < 65535)     // CameraSettings",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "8978:             free(table_buf);",
          "8979:           }",
          "8982:           {",
          "8983:             table_buf_0x9050 = (uchar*)malloc(len);",
          "8984:             table_buf_0x9050_present = 1;",
          "",
          "[Removed Lines]",
          "8981:         else if (tag == 0x9050)  // little endian",
          "",
          "[Added Lines]",
          "8990:         else if (tag == 0x9050 && len < 256000)  // little endian",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "8992:               }",
          "8993:           }",
          "8996:           {",
          "8997:             table_buf_0x940c = (uchar*)malloc(len);",
          "8998:             table_buf_0x940c_present = 1;",
          "",
          "[Removed Lines]",
          "8995:         else if (tag == 0x940c)",
          "",
          "[Added Lines]",
          "9004:         else if (tag == 0x940c && len < 256000)",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "9029:             if (tag == 0x010c) imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;",
          "9030:           }",
          "9033:           {",
          "9034:             table_buf = (uchar*)malloc(len);",
          "9035:             fread(table_buf, len, 1, ifp);",
          "",
          "[Removed Lines]",
          "9032:         else if (tag == 0xb02a)     // Sony LensSpec",
          "",
          "[Added Lines]",
          "9041:         else if (tag == 0xb02a && len < 256000) // Sony LensSpec",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "9090:   ushort table_buf_0x9050_present = 0;",
          "9091:   uchar *table_buf_0x940c;",
          "9092:   ushort table_buf_0x940c_present = 0;",
          "9093: #endif",
          "9095:    The MakerNote might have its own TIFF header (possibly with",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9103:   INT64 fsize = ifp->size();",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "9194:   entries = get2();",
          "9195:   if (entries > 1000) return;",
          "9196:   morder = order;",
          "9197:   while (entries--) {",
          "9198:     order = morder;",
          "9199:     tiff_get (base, &tag, &type, &len, &save);",
          "9200:     tag |= uptag << 16;",
          "9203: #ifdef LIBRAW_LIBRARY_BUILD",
          "9204:     INT64 _pos = ftell(ifp);",
          "9205:     if (!strncmp(make, \"Canon\",5))",
          "9206:       {",
          "9207:         if (tag == 0x0001) Canon_CameraSettings();",
          "",
          "[Removed Lines]",
          "9201:     if(len > 100*1024*1024) continue; // 100Mb tag? No!",
          "",
          "[Added Lines]",
          "9216:     if(len > 8 && _pos+len > 2* fsize) continue;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "9236:              sprintf(imgdata.shootinginfo.BodySerial, \"%d\", get4());",
          "9237:           }",
          "9240:           {",
          "9241:             CanonCameraInfo = (uchar*)malloc(len);",
          "9242:             fread(CanonCameraInfo, len, 1, ifp);",
          "",
          "[Removed Lines]",
          "9239:         else if (tag == 0x000d)   // camera info",
          "",
          "[Added Lines]",
          "9251:         else if (tag == 0x000d && len < 256000) // camera info",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "9305:          char yy[2], mm[3], dd[3], ystr[16], ynum[16];",
          "9306:          int year, nwords, ynum_len;",
          "9307:          unsigned c;",
          "9309:          nwords = getwords(FujiSerial, words, 4,sizeof(imgdata.shootinginfo.InternalBodySerial));",
          "9310:          for (int i = 0; i < nwords; i++) {",
          "9311:            mm[2] = dd[2] = 0;",
          "",
          "[Removed Lines]",
          "9308:          fread(FujiSerial, MIN(len, sizeof(FujiSerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "9320:          stmread(FujiSerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "9369:         if ((tag == 0x0303) && (type != 4))",
          "9370:           {",
          "9372:           }",
          "9374:         if ((tag == 0x3405) ||",
          "",
          "[Removed Lines]",
          "9371:             fread(imgdata.lens.makernotes.Lens, MIN(len,127), 1, ifp);",
          "",
          "[Added Lines]",
          "9383:             stmread(imgdata.lens.makernotes.Lens, len, ifp);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "9432:           }",
          "9433:         else if (tag == 0x0082)    // lens attachment",
          "9434:           {",
          "9436:           }",
          "9437:         else if (tag == 0x0083)    // lens type",
          "9438:           {",
          "",
          "[Removed Lines]",
          "9435:             fread(imgdata.lens.makernotes.Attachment, MIN(len,127), 1, ifp);",
          "",
          "[Added Lines]",
          "9447:             stmread(imgdata.lens.makernotes.Attachment, len, ifp);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "9500:           }",
          "9501:         else if (tag == 0x00a0)",
          "9502:           {",
          "9504:           }",
          "9505:         else if (tag == 0x00a8)  // contains flash data",
          "9506:           {",
          "",
          "[Removed Lines]",
          "9503:             fread(imgdata.shootinginfo.BodySerial, MIN(len, sizeof(imgdata.shootinginfo.BodySerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "9515:             stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "9518:         case 0x101a:",
          "9519:         case 0x20100101:",
          "9520:           if (!imgdata.shootinginfo.BodySerial[0])",
          "9522:         break;",
          "9523:         case 0x20100102:",
          "9524:           if (!imgdata.shootinginfo.InternalBodySerial[0])",
          "9526:         break;",
          "9527:         case 0x0207:",
          "9528:         case 0x20100100:",
          "",
          "[Removed Lines]",
          "9521:             fread(imgdata.shootinginfo.BodySerial, MIN(len, sizeof(imgdata.shootinginfo.BodySerial)), 1, ifp);",
          "9525:             fread(imgdata.shootinginfo.InternalBodySerial, MIN(len, sizeof(imgdata.shootinginfo.InternalBodySerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "9533:             stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "9537:             stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "9570:             }",
          "9571:           break;",
          "9572:         case 0x20100202:",
          "9574:           break;",
          "9575:         case 0x20100203:",
          "9577:           break;",
          "9578:         case 0x20100205:",
          "9579:           imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "",
          "[Removed Lines]",
          "9573:           fread(imgdata.lens.LensSerial, MIN(len,sizeof(imgdata.lens.LensSerial)), 1, ifp);",
          "9576:           fread(imgdata.lens.makernotes.Lens, MIN(len,sizeof(imgdata.lens.makernotes.Lens)), 1, ifp);",
          "",
          "[Added Lines]",
          "9585:           stmread(imgdata.lens.LensSerial, len, ifp);",
          "9588:           stmread(imgdata.lens.makernotes.Lens, len, ifp);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "9599:             imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);",
          "9600:           break;",
          "9601:         case 0x20100303:",
          "9603:           break;",
          "9604:         case 0x20100403:",
          "9606:           break;",
          "9607:         }",
          "9608:       }",
          "",
          "[Removed Lines]",
          "9602:           fread(imgdata.lens.makernotes.Teleconverter, MIN(len,127), 1, ifp);",
          "9605:           fread(imgdata.lens.makernotes.Attachment, MIN(len,127), 1, ifp);",
          "",
          "[Added Lines]",
          "9614:           stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);",
          "9617:           stmread(imgdata.lens.makernotes.Attachment, len, ifp);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "9699:               }",
          "9700:             fseek(ifp, 6, SEEK_CUR);",
          "9701:             fseek(ifp, get4()+20, SEEK_SET);",
          "9703:             get2();",
          "9704:             imgdata.lens.makernotes.LensID = getc(ifp) - '0';",
          "9705:             switch(imgdata.lens.makernotes.LensID) {",
          "",
          "[Removed Lines]",
          "9702:             fread(imgdata.shootinginfo.BodySerial, 12, 1, ifp);",
          "",
          "[Added Lines]",
          "9714:             stread(imgdata.shootinginfo.BodySerial, 12, ifp);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "9720:              imgdata.lens.makernotes.LensID = -1;",
          "9721:             }",
          "9722:             fseek(ifp, 17, SEEK_CUR);",
          "9724:           }",
          "9725:       }",
          "",
          "[Removed Lines]",
          "9723:             fread(imgdata.lens.LensSerial, 12, 1, ifp);",
          "",
          "[Added Lines]",
          "9735:             stread(imgdata.lens.LensSerial, 12, ifp);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "9764:            }",
          "9765:         else if (tag == 0x0207)",
          "9766:           {",
          "9768:           }",
          "9769:         else if (tag == 0x020d)",
          "9770:         {",
          "",
          "[Removed Lines]",
          "9767:             PentaxLensInfo(imgdata.lens.makernotes.CamID, len);",
          "",
          "[Added Lines]",
          "9779:      if(len < 65535) // Safety belt",
          "9780:              PentaxLensInfo(imgdata.lens.makernotes.CamID, len);",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "9818:         }",
          "9819:         else if (tag == 0x0229)",
          "9820:         {",
          "9822:         }",
          "9823:         else if (tag == 0x022d)",
          "9824:         {",
          "",
          "[Removed Lines]",
          "9821:           fread(imgdata.shootinginfo.BodySerial, MIN(len, sizeof(imgdata.shootinginfo.BodySerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "9834:           stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "9845:           {",
          "9846:             char LensInfo [20];",
          "9847:             fseek (ifp, 2, SEEK_CUR);",
          "9849:             strcat(imgdata.lens.makernotes.Lens, \" \");",
          "9851:             strcat(imgdata.lens.makernotes.Lens, LensInfo);",
          "9852:           }",
          "9853:       }",
          "",
          "[Removed Lines]",
          "9848:             fread(imgdata.lens.makernotes.Lens, 30, 1, ifp);",
          "9850:             fread(LensInfo, 20, 1, ifp);",
          "",
          "[Added Lines]",
          "9861:             stread(imgdata.lens.makernotes.Lens, 30, ifp);",
          "9863:             stread(LensInfo, 20, ifp);",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "9876:           }",
          "9877:          else if (tag == 0xa002)",
          "9878:           {",
          "9880:           }",
          "9881:         else if (tag == 0xa003)",
          "9882:           {",
          "",
          "[Removed Lines]",
          "9879:              fread(imgdata.shootinginfo.BodySerial, MIN(len, sizeof(imgdata.shootinginfo.BodySerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "9892:              stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "9886:           }",
          "9887:         else if (tag == 0xa005)",
          "9888:           {",
          "9890:           }",
          "9891:         else if (tag == 0xa019)",
          "9892:           {",
          "",
          "[Removed Lines]",
          "9889:             fread(imgdata.lens.InternalLensSerial, MIN(len,sizeof(imgdata.lens.InternalLensSerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "9902:             stmread(imgdata.lens.InternalLensSerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "9989:                  !strncasecmp(model, \"DSLR-A100\", 9))",
          "9990:    {",
          "9991:      fseek(ifp,0x49dc,SEEK_CUR);",
          "9993:    }",
          "9995:  else if (tag == 0x0104)",
          "",
          "[Removed Lines]",
          "9992:      fread(imgdata.shootinginfo.InternalBodySerial, MIN(12, sizeof(imgdata.shootinginfo.InternalBodySerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "10005:      stmread(imgdata.shootinginfo.InternalBodySerial, 12, ifp);",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "10002:             imgdata.lens.makernotes.TeleconverterID = get2();",
          "10003:           }",
          "10006:           {",
          "10007:             table_buf = (uchar*)malloc(len);",
          "10008:             fread(table_buf, len, 1, ifp);",
          "",
          "[Removed Lines]",
          "10005:         else if (tag == 0x0114)     // CameraSettings",
          "",
          "[Added Lines]",
          "10018:         else if (tag == 0x0114 && len < 256000)  // CameraSettings",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "10035:             free(table_buf);",
          "10036:           }",
          "10039:           {",
          "10040:             table_buf_0x9050 = (uchar*)malloc(len);",
          "10041:             table_buf_0x9050_present = 1;",
          "",
          "[Removed Lines]",
          "10038:         else if (tag == 0x9050)  // little endian",
          "",
          "[Added Lines]",
          "10051:         else if (tag == 0x9050 && len < 256000)  // little endian",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "10049:               }",
          "10050:           }",
          "10053:           {",
          "10054:             table_buf_0x940c = (uchar*)malloc(len);",
          "10055:             table_buf_0x940c_present = 1;",
          "",
          "[Removed Lines]",
          "10052:         else if (tag == 0x940c)",
          "",
          "[Added Lines]",
          "10065:         else if (tag == 0x940c && len <256000)",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "10086:             if (tag == 0x010c) imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;",
          "10087:           }",
          "10090:           {",
          "10091:             table_buf = (uchar*)malloc(len);",
          "10092:             fread(table_buf, len, 1, ifp);",
          "",
          "[Removed Lines]",
          "10089:         else if (tag == 0xb02a)     // Sony LensSpec",
          "",
          "[Added Lines]",
          "10102:         else if (tag == 0xb02a && len < 256000) // Sony LensSpec",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "10874:   kodak = !strncmp(make,\"EASTMAN\",7) && tiff_nifds < 3;",
          "10875:   entries = get2();",
          "10876:   if(!strncmp(make,\"Hasselblad\",10) && (tiff_nifds > 3) && (entries > 512)) return;",
          "10877:   while (entries--) {",
          "10878:     tiff_get (base, &tag, &type, &len, &save);",
          "10880: #ifdef LIBRAW_LIBRARY_BUILD",
          "10881:     if(callbacks.exif_cb)",
          "10882:       {",
          "10884:         callbacks.exif_cb(callbacks.exifparser_data,tag,type,len,order,ifp);",
          "10885:         fseek(ifp,savepos,SEEK_SET);",
          "10886:       }",
          "",
          "[Removed Lines]",
          "10883:         int savepos = ftell(ifp);",
          "",
          "[Added Lines]",
          "10890: #ifdef LIBRAW_LIBRARY_BUILD",
          "10891:   INT64 fsize = ifp->size();",
          "10892: #endif",
          "10897:     INT64 savepos = ftell(ifp);",
          "10898:     if(len > 8 && savepos + len > fsize*2) continue;",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "10891:       imgdata.lens.FocalLengthIn35mmFormat = get2();",
          "10892:       break;",
          "10893:     case 0xa431:  // BodySerialNumber",
          "10895:       break;",
          "10896:     case 0xa432:  // LensInfo, 42034dec, Lens Specification per EXIF standard",
          "10897:       imgdata.lens.MinFocal = getreal(type);",
          "",
          "[Removed Lines]",
          "10894:       fread(imgdata.shootinginfo.BodySerial, MIN(len, sizeof(imgdata.shootinginfo.BodySerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "10911:       stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "10900:       imgdata.lens.MaxAp4MaxFocal = getreal(type);",
          "10901:       break;",
          "10902:     case 0xa435:  // LensSerialNumber",
          "10904:       break;",
          "10905:     case 0xc630:  // DNG LensInfo, Lens Specification per EXIF standard",
          "10906:       imgdata.lens.dng.MinFocal = getreal(type);",
          "",
          "[Removed Lines]",
          "10903:       fread(imgdata.lens.LensSerial, MIN(len, sizeof(imgdata.lens.LensSerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "10920:       stmread(imgdata.lens.LensSerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "10909:       imgdata.lens.dng.MaxAp4MaxFocal = getreal(type);",
          "10910:       break;",
          "10911:     case 0xa433:  // LensMake",
          "10913:       break;",
          "10914:     case 0xa434:  // LensModel",
          "10916:       if (!strncmp(imgdata.lens.Lens, \"----\", 4))",
          "10917:         imgdata.lens.Lens[0] = 0;",
          "10918:       break;",
          "",
          "[Removed Lines]",
          "10912:       fread(imgdata.lens.LensMake, MIN(len,sizeof(imgdata.lens.LensMake)), 1, ifp);",
          "10915:       fread(imgdata.lens.Lens, MIN(len, sizeof(imgdata.lens.LensMake)), 1, ifp);",
          "",
          "[Added Lines]",
          "10929:       stmread(imgdata.lens.LensMake, len, ifp);",
          "10932:       stmread(imgdata.lens.Lens, len, ifp);",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "11003:     imgdata.other.parsed_gps.gpsparsed = 1;",
          "11004:   while (entries--) {",
          "11005:     tiff_get(base, &tag, &type, &len, &save);",
          "11006:     switch (tag) {",
          "11007:     case 1:  imgdata.other.parsed_gps.latref = getc(ifp); break;",
          "11008:     case 3:  imgdata.other.parsed_gps.longref = getc(ifp); break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11023:     if(len > 1024) continue; // no GPS tags are 1k or larger",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "11036:   entries = get2();",
          "11037:   while (entries--) {",
          "11038:     tiff_get (base, &tag, &type, &len, &save);",
          "11039:     switch (tag) {",
          "11040:       case 1: case 3: case 5:",
          "11041:  gpsdata[29+tag/2] = getc(ifp);   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11057:     if(len > 1024) continue; // no GPS tags are 1k or larger",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "11091: #ifdef LIBRAW_LIBRARY_BUILD",
          "11092:     if (!strcmp(data,\"CameraObj_camera_type\")) {",
          "11094:     }",
          "11095:     if (!strcmp(data,\"back_serial_number\")) {",
          "11096:        char buffer [sizeof(imgdata.shootinginfo.BodySerial)];",
          "11097:        char *words[4];",
          "11098:        int nwords;",
          "11100:        nwords = getwords(buffer, words, 4,sizeof(imgdata.shootinginfo.BodySerial));",
          "11101:        strcpy (imgdata.shootinginfo.BodySerial, words[0]);",
          "11102:     }",
          "",
          "[Removed Lines]",
          "11093:  fread(imgdata.lens.makernotes.body, MIN(skip,63), 1, ifp);",
          "11099:        fread(buffer, MIN(skip, sizeof(buffer)), 1, ifp);",
          "",
          "[Added Lines]",
          "11112:  stmread(imgdata.lens.makernotes.body, skip, ifp);",
          "11118:        stmread(buffer, skip, ifp);",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "11104:        char buffer [sizeof(imgdata.shootinginfo.InternalBodySerial)];",
          "11105:        char *words[4];",
          "11106:        int nwords;",
          "11108:        nwords = getwords(buffer, words, 4,sizeof(imgdata.shootinginfo.InternalBodySerial));",
          "11109:        strcpy (imgdata.shootinginfo.InternalBodySerial, words[0]);",
          "11110:     }",
          "",
          "[Removed Lines]",
          "11107:        fread(buffer, MIN(skip, sizeof(buffer)), 1, ifp);",
          "",
          "[Added Lines]",
          "11126:        stmread(buffer, skip, ifp);",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "11195:   entries = get2();",
          "11196:   if (entries > 1024) return;",
          "11197:   while (entries--) {",
          "11198:     tiff_get (base, &tag, &type, &len, &save);",
          "11199:     if(callbacks.exif_cb)",
          "11200:       {",
          "11202:         callbacks.exif_cb(callbacks.exifparser_data,tag | 0x20000,type,len,order,ifp);",
          "11203:         fseek(ifp,savepos,SEEK_SET);",
          "11204:       }",
          "",
          "[Removed Lines]",
          "11201:         int savepos = ftell(ifp);",
          "",
          "[Added Lines]",
          "11216:   INT64 fsize = ifp->size();",
          "11219:     INT64 savepos = ftell(ifp);",
          "11220:     if(len > 8 && len + savepos > 2*fsize) continue;",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "11218:                          imgdata.color.linear_max[1] =",
          "11219:                          imgdata.color.linear_max[2] =",
          "11220:                          imgdata.color.linear_max[3] = get2();",
          "11223:  if (tag == 0xfa27)",
          "11224:    {",
          "11225:                 FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get4();",
          "",
          "[Removed Lines]",
          "11221:         if (tag == 0x09ce) fread(imgdata.shootinginfo.InternalBodySerial, MIN(len, sizeof(imgdata.shootinginfo.InternalBodySerial)), 1, ifp);",
          "11222:         if (tag == 0xfa00) fread(imgdata.shootinginfo.BodySerial, MIN(len, sizeof(imgdata.shootinginfo.BodySerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "11242:         if (tag == 0x09ce)",
          "11243:   stmread(imgdata.shootinginfo.InternalBodySerial,len, ifp);",
          "11244:         if (tag == 0xfa00)",
          "11245:   stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "11328:       cc[j][i] = i == j;",
          "11329:   entries = get2();",
          "11330:   if (entries > 512) return 1;",
          "11331:   while (entries--) {",
          "11332:     tiff_get (base, &tag, &type, &len, &save);",
          "11333: #ifdef LIBRAW_LIBRARY_BUILD",
          "11334:     if(callbacks.exif_cb)",
          "11335:       {",
          "11337:         callbacks.exif_cb(callbacks.exifparser_data,tag|(pana_raw?0x30000:0),type,len,order,ifp);",
          "11338:         fseek(ifp,savepos,SEEK_SET);",
          "11339:       }",
          "",
          "[Removed Lines]",
          "11336:         int savepos = ftell(ifp);",
          "",
          "[Added Lines]",
          "11354: #ifdef LIBRAW_LIBRARY_BUILD",
          "11355:   INT64 fsize = ifp->size();",
          "11356: #endif",
          "11360:     INT64 savepos = ftell(ifp);",
          "11361:     if(len > 8 && len + savepos > fsize*2) continue; // skip tag pointing out of 2xfile",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "11697:         if((type == 1 || type == 2 || type == 6 || type == 7) && len > 1 && len < 5100000)",
          "11698:           {",
          "11699:             xmpdata = (char*)malloc(xmplen = len+1);",
          "11701:             xmpdata[len]=0;",
          "11702:           }",
          "11703:         break;",
          "",
          "[Removed Lines]",
          "11700:             fread(xmpdata,len,1,ifp);",
          "",
          "[Added Lines]",
          "11727:             stread(xmpdata,len,ifp);",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "11795:       break;",
          "11796:     case 0xa431:  // BodySerialNumber",
          "11797:     case 0xc62f:",
          "11799:       break;",
          "11800:     case 0xa432:  // LensInfo, 42034dec, Lens Specification per EXIF standard",
          "11801:       imgdata.lens.MinFocal = getreal(type);",
          "",
          "[Removed Lines]",
          "11798:       fread(imgdata.shootinginfo.BodySerial, MIN(len, sizeof(imgdata.shootinginfo.BodySerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "11825:       stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "11804:       imgdata.lens.MaxAp4MaxFocal = getreal(type);",
          "11805:       break;",
          "11806:     case 0xa435:  // LensSerialNumber",
          "11808:       break;",
          "11809:     case 0xc630:  // DNG LensInfo, Lens Specification per EXIF standard",
          "11810:       imgdata.lens.MinFocal = getreal(type);",
          "",
          "[Removed Lines]",
          "11807:       fread(imgdata.lens.LensSerial, MIN(len, sizeof(imgdata.lens.LensSerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "11834:       stmread(imgdata.lens.LensSerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "11813:       imgdata.lens.MaxAp4MaxFocal = getreal(type);",
          "11814:       break;",
          "11815:     case 0xa433:  // LensMake",
          "11817:       break;",
          "11818:     case 0xa434:  // LensModel",
          "11820:       if (!strncmp(imgdata.lens.Lens, \"----\", 4))",
          "11821:         imgdata.lens.Lens[0] = 0;",
          "11822:       break;",
          "",
          "[Removed Lines]",
          "11816:       fread(imgdata.lens.LensMake, MIN(len, sizeof(imgdata.lens.LensMake)), 1, ifp);",
          "11819:       fread(imgdata.lens.Lens, MIN(len, sizeof(imgdata.lens.Lens)), 1, ifp);",
          "",
          "[Added Lines]",
          "11843:       stmread(imgdata.lens.LensMake, len, ifp);",
          "11846:       stmread(imgdata.lens.Lens, len, ifp);",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "11934:  break;",
          "11936:       case 50455:",
          "11938: #ifndef LIBRAW_LIBRARY_BUILD",
          "11939:  fread (cbuf, 1, len, ifp);",
          "11940: #else",
          "11941:  if(fread (cbuf, 1, len, ifp) != len)",
          "11942:   throw LIBRAW_EXCEPTION_IO_CORRUPT; // cbuf to be free'ed in recycle",
          "11943: #endif",
          "11944:  for (cp = cbuf-1; cp && cp < cbuf+len; cp = strchr(cp,'\\n'))",
          "11945:    if (!strncmp (++cp,\"Neutral \",8))",
          "11946:      sscanf (cp+8, \"%f %f %f\", cam_mul, cam_mul+1, cam_mul+2);",
          "",
          "[Removed Lines]",
          "11937:  if (!(cbuf = (char *) malloc(len))) break;",
          "",
          "[Added Lines]",
          "11964:  if (len > 2560000 || !(cbuf = (char *) malloc(len))) break;",
          "11971:         cbuf[len-1] = 0;",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "11970:  break;",
          "11972: #ifdef LIBRAW_LIBRARY_BUILD",
          "11974:         imgdata.color.UniqueCameraModel[sizeof(imgdata.color.UniqueCameraModel)-1] = 0;",
          "11975: #endif",
          "11976:  if (model[0]) break;",
          "",
          "[Removed Lines]",
          "11973:         fread(imgdata.color.UniqueCameraModel, MIN(len, sizeof(imgdata.color.UniqueCameraModel)), 1, ifp);",
          "",
          "[Added Lines]",
          "12001:         stmread(imgdata.color.UniqueCameraModel, len, ifp);",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "12019:     imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];",
          "12020:     imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];",
          "12021:     imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];",
          "12023:     {",
          "12024:       long long f_save = ftell(ifp);",
          "12025:       int fj, found = 0;",
          "",
          "[Removed Lines]",
          "12022:     if ((fwb[3] == 17) && libraw_internal_data.unpacker_data.lenRAFData>3)",
          "",
          "[Added Lines]",
          "12050:     if ((fwb[3] == 17) && libraw_internal_data.unpacker_data.lenRAFData>3 && libraw_internal_data.unpacker_data.lenRAFData < 10240000)",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "12096: #ifdef LIBRAW_LIBRARY_BUILD",
          "12097:       case 50709:",
          "12100:       break;",
          "12101: #endif",
          "",
          "[Removed Lines]",
          "12098:         fread(imgdata.color.LocalizedCameraModel, MIN(len, sizeof(imgdata.color.LocalizedCameraModel)), 1, ifp);",
          "12099:         imgdata.color.LocalizedCameraModel[sizeof(imgdata.color.LocalizedCameraModel)-1] = 0;",
          "",
          "[Added Lines]",
          "12126:         stmread(imgdata.color.LocalizedCameraModel,len, ifp);",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "12303:     }",
          "12304:     fseek (ifp, save, SEEK_SET);",
          "12305:   }",
          "12307:     fseek (ifp, sony_offset, SEEK_SET);",
          "12308:     fread (buf, sony_length, 1, ifp);",
          "12309:     sony_decrypt (buf, sony_length/4, 1, sony_key);",
          "",
          "[Removed Lines]",
          "12306:   if (sony_length && (buf = (unsigned *) malloc(sony_length))) {",
          "",
          "[Added Lines]",
          "12333:   if (sony_length && sony_length < 10240000 && (buf = (unsigned *) malloc(sony_length))) {",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "13035: #ifdef LIBRAW_LIBRARY_BUILD",
          "13036:     case 0x0102:",
          "13038:       if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49)) {",
          "13039:         unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;",
          "13040:       } else {",
          "",
          "[Removed Lines]",
          "13037:       fread(imgdata.shootinginfo.BodySerial, MIN(len, sizeof(imgdata.shootinginfo.BodySerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "13064:       stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "13051:       else imgdata.lens.makernotes.CurFocal = getreal(type);",
          "13052:       break;",
          "13053:     case 0x0410:",
          "13055:       break;",
          "13056:     case 0x0412:",
          "13058:       break;",
          "13059:     case 0x0414:",
          "13060:       if (type == 4) {",
          "",
          "[Removed Lines]",
          "13054:       fread(imgdata.lens.makernotes.body, 1, len, ifp);",
          "13057:       fread(imgdata.lens.makernotes.Lens, 1, len, ifp);",
          "",
          "[Added Lines]",
          "13081:       stmread(imgdata.lens.makernotes.body, len, ifp);",
          "13084:       stmread(imgdata.lens.makernotes.Lens, len, ifp);",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "13149:       save = ftell(ifp);",
          "13150:       fseek (ifp, meta_offset+data, SEEK_SET);",
          "13151:       if (tag == 0x0407) {",
          "13153:         if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49)) {",
          "13154:           unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;",
          "13155:         } else {",
          "",
          "[Removed Lines]",
          "13152:         fread(imgdata.shootinginfo.BodySerial, MIN(len, sizeof(imgdata.shootinginfo.BodySerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "13179:         stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "15374:     fseek (ifp, 104, SEEK_SET);",
          "15375:     imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, ((float)get4())/16.0f);",
          "15376:     fseek (ifp, 124, SEEK_SET);",
          "15378:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Contax_N;",
          "15379:     if (imgdata.lens.makernotes.Lens[0])",
          "15380:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Contax_N;",
          "",
          "[Removed Lines]",
          "15377:     fread(imgdata.lens.makernotes.Lens, 32, 1, ifp);",
          "",
          "[Added Lines]",
          "15404:     stmread(imgdata.lens.makernotes.Lens, 32, ifp);",
          "",
          "---------------"
        ],
        "internal/dcraw_common.cpp||internal/dcraw_common.cpp": [
          "File: internal/dcraw_common.cpp -> internal/dcraw_common.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #include <math.h>",
          "30: #define CLASS LibRaw::",
          "31: #include \"libraw/libraw_types.h\"",
          "",
          "[Removed Lines]",
          "25: #ifdef ANDROID",
          "26: #include <libraw_swab.h>",
          "27: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64:   const char *p = (const char *)memchr(s, 0, n);",
          "65:   return(p ? p-s : n);",
          "66: }",
          "68: #ifndef __GLIBC__",
          "69: char *my_memmem (char *haystack, size_t haystacklen,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "63: #ifdef LIBRAW_LIBRARY_BUILD",
          "64: static int stread(char *buf, size_t len, LibRaw_abstract_datastream *fp)",
          "65: {",
          "66:  int r = fp->read(buf,len,1);",
          "67:  buf[len-1] = 0;",
          "68:  return r;",
          "69: }",
          "70: #define stmread(buf,maxlen,fp) stread(buf,MIN(maxlen,sizeof(buf)),fp)",
          "71: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "6359: {",
          "6360:   int code [] = {3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 50, 100, 200, 400, 800, 1600, 3200, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278};",
          "6361:   double value []  = {50, 64, 80, 100, 125, 160, 200, 250, 320, 400, 500, 640, 800, 1000, 1250, 1600, 2000, 2500, 3200, 4000, 5000, 6400, 8000, 10000, 12800, 16000, 20000, 25600, 32000, 40000, 51200, 64000, 80000, 102400, 128000, 160000, 204800, 50, 100, 200, 400, 800, 1600, 3200, 50, 70, 100, 140, 200, 280, 400, 560, 800, 1100, 1600, 2200, 3200, 4500, 6400, 9000, 12800, 18000, 25600, 36000, 51200};",
          "6363:   int i;",
          "6364:   for (i = 0; i < numel; i++) {",
          "6365:     if (code[i] == c) {",
          "",
          "[Removed Lines]",
          "6362:   int numel = sizeof(code)/sizeof(code[0]);",
          "",
          "[Added Lines]",
          "6367: #define numel (sizeof(code)/sizeof(code[0]))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "6368:     }",
          "6369:   }",
          "6370:   if (i == numel) iso_speed = 65535.0f;",
          "6372: }",
          "6374: void CLASS PentaxLensInfo (unsigned id, unsigned len) // tag 0x0207",
          "6375: {",
          "",
          "[Removed Lines]",
          "6371:   return;",
          "",
          "[Added Lines]",
          "6377: #undef numel",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "7013:   short morder, sorder = order;",
          "7014:   char buf[10];",
          "7016:   fread(buf, 1, 10, ifp);",
          "7017:   if (!strcmp(buf, \"Nikon\")) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7020:   INT64 fsize = ifp->size();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "7060:   while (entries--) {",
          "7061:     order = morder;",
          "7062:     tiff_get(base, &tag, &type, &len, &save);",
          "7063:     tag |= uptag << 16;",
          "7064:     if(len > 100*1024*1024) goto next; // 100Mb tag? No!",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7069:     INT64 pos = ifp->tell();",
          "7070:     if(len > 8 && pos+len > 2* fsize) continue;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "7093:             if (!aperture) aperture = imgdata.lens.makernotes.CurAp;",
          "7094:           }",
          "7097:           {",
          "7098:             CanonCameraInfo = (uchar*)malloc(len);",
          "7099:             fread(CanonCameraInfo, len, 1, ifp);",
          "",
          "[Removed Lines]",
          "7096:         else if (tag == 0x000d)   // camera info",
          "",
          "[Added Lines]",
          "7104:         else if (tag == 0x000d && len < 256000)   // camera info",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "7202:         }",
          "7203:         if ((tag == 0x0303) && (type != 4))",
          "7204:           {",
          "7206:           }",
          "7208:         if ((tag == 0x3405) ||",
          "",
          "[Removed Lines]",
          "7205:             fread(imgdata.lens.makernotes.Lens, MIN(len,127), 1, ifp);",
          "",
          "[Added Lines]",
          "7213:             stmread(imgdata.lens.makernotes.Lens, len,ifp);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "7274:           }",
          "7275:         else if (tag == 0x0082)    // lens attachment",
          "7276:           {",
          "7278:           }",
          "7279:         else if (tag == 0x0083)    // lens type",
          "7280:           {",
          "",
          "[Removed Lines]",
          "7277:             fread(imgdata.lens.makernotes.Attachment, MIN(len,127), 1, ifp);",
          "",
          "[Added Lines]",
          "7285:             stmread(imgdata.lens.makernotes.Attachment, len, ifp);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "7433:           imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type)/2);",
          "7434:           break;",
          "7435:         case 0x20100102:",
          "7437:         break;",
          "7438:         case 0x20100201:",
          "7439:           imgdata.lens.makernotes.LensID =",
          "",
          "[Removed Lines]",
          "7436:             fread(imgdata.shootinginfo.InternalBodySerial, MIN(len, sizeof(imgdata.shootinginfo.InternalBodySerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "7444:             stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "7451:           break;",
          "7452:         case 0x20100202:",
          "7453:           if ((!imgdata.lens.LensSerial[0]))",
          "7455:           break;",
          "7456:         case 0x20100203:",
          "7458:           break;",
          "7459:         case 0x20100205:",
          "7460:           imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "",
          "[Removed Lines]",
          "7454:               fread(imgdata.lens.LensSerial, MIN(len,sizeof(imgdata.lens.LensSerial)), 1, ifp);",
          "7457:           fread(imgdata.lens.makernotes.Lens, MIN(len,sizeof(imgdata.lens.makernotes.Lens)), 1, ifp);",
          "",
          "[Added Lines]",
          "7462:               stmread(imgdata.lens.LensSerial, len, ifp);",
          "7465:           stmread(imgdata.lens.makernotes.Lens,len, ifp);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "7480:             imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);",
          "7481:           break;",
          "7482:         case 0x20100303:",
          "7484:           break;",
          "7485:         case 0x20100403:",
          "7487:           break;",
          "7488:         case 0x20200401:",
          "7489:        imgdata.other.FlashEC = getreal(type);",
          "",
          "[Removed Lines]",
          "7483:           fread(imgdata.lens.makernotes.Teleconverter, MIN(len,127), 1, ifp);",
          "7486:           fread(imgdata.lens.makernotes.Attachment, MIN(len,127), 1, ifp);",
          "",
          "[Added Lines]",
          "7491:           stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);",
          "7494:           stmread(imgdata.lens.makernotes.Attachment,len, ifp);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "7531:            }",
          "7532:         else if (tag == 0x0207)",
          "7533:           {",
          "7535:           }",
          "7536:         else if (tag == 0x020d)",
          "7537:         {",
          "",
          "[Removed Lines]",
          "7534:             PentaxLensInfo(imgdata.lens.makernotes.CamID, len);",
          "",
          "[Added Lines]",
          "7542:      if(len < 65535) // Safety belt",
          "7543:                PentaxLensInfo(imgdata.lens.makernotes.CamID, len);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "7585:         }",
          "7586:         else if (tag == 0x0229)",
          "7587:         {",
          "7589:         }",
          "7590:         else if (tag == 0x022d)",
          "7591:         {",
          "",
          "[Removed Lines]",
          "7588:           fread(imgdata.shootinginfo.BodySerial, MIN(len, sizeof(imgdata.shootinginfo.BodySerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "7597:           stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "7612:           {",
          "7613:             char LensInfo [20];",
          "7614:             fseek (ifp, 12, SEEK_CUR);",
          "7616:             strcat(imgdata.lens.makernotes.Lens, \" \");",
          "7618:             strcat(imgdata.lens.makernotes.Lens, LensInfo);",
          "7619:           }",
          "7620:       }",
          "",
          "[Removed Lines]",
          "7615:             fread(imgdata.lens.makernotes.Lens, 30, 1, ifp);",
          "7617:             fread(LensInfo, 20, 1, ifp);",
          "",
          "[Added Lines]",
          "7624:             stread(imgdata.lens.makernotes.Lens, 30, ifp);",
          "7626:             stread(LensInfo, 20, ifp);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "7650:           }",
          "7651:         else if (tag == 0xa005)",
          "7652:           {",
          "7654:           }",
          "7655:         else if (tag == 0xa019)",
          "7656:           {",
          "",
          "[Removed Lines]",
          "7653:             fread(imgdata.lens.InternalLensSerial, MIN(len,sizeof(imgdata.lens.InternalLensSerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "7662:             stmread(imgdata.lens.InternalLensSerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "7765:             imgdata.lens.makernotes.TeleconverterID = get2();",
          "7766:           }",
          "7769:           {",
          "7770:             table_buf = (uchar*)malloc(len);",
          "7771:             fread(table_buf, len, 1, ifp);",
          "",
          "[Removed Lines]",
          "7768:         else if (tag == 0x0114)     // CameraSettings",
          "",
          "[Added Lines]",
          "7777:         else if (tag == 0x0114 && len < 65535)     // CameraSettings",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "7798:             free(table_buf);",
          "7799:           }",
          "7802:           {",
          "7803:             table_buf_0x9050 = (uchar*)malloc(len);",
          "7804:             table_buf_0x9050_present = 1;",
          "",
          "[Removed Lines]",
          "7801:         else if (tag == 0x9050)  // little endian",
          "",
          "[Added Lines]",
          "7810:         else if (tag == 0x9050 && len < 256000)  // little endian",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "7812:               }",
          "7813:           }",
          "7816:           {",
          "7817:             table_buf_0x940c = (uchar*)malloc(len);",
          "7818:             table_buf_0x940c_present = 1;",
          "",
          "[Removed Lines]",
          "7815:         else if (tag == 0x940c)",
          "",
          "[Added Lines]",
          "7824:         else if (tag == 0x940c && len < 256000)",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "7849:             if (tag == 0x010c) imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;",
          "7850:           }",
          "7853:           {",
          "7854:             table_buf = (uchar*)malloc(len);",
          "7855:             fread(table_buf, len, 1, ifp);",
          "",
          "[Removed Lines]",
          "7852:         else if (tag == 0xb02a)     // Sony LensSpec",
          "",
          "[Added Lines]",
          "7861:         else if (tag == 0xb02a && len < 256000) // Sony LensSpec",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "7910:   ushort table_buf_0x9050_present = 0;",
          "7911:   uchar *table_buf_0x940c;",
          "7912:   ushort table_buf_0x940c_present = 0;",
          "7913: #endif",
          "7915:    The MakerNote might have its own TIFF header (possibly with",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7923:   INT64 fsize = ifp->size();",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "8014:   entries = get2();",
          "8015:   if (entries > 1000) return;",
          "8016:   morder = order;",
          "8017:   while (entries--) {",
          "8018:     order = morder;",
          "8019:     tiff_get (base, &tag, &type, &len, &save);",
          "8020:     tag |= uptag << 16;",
          "8023: #ifdef LIBRAW_LIBRARY_BUILD",
          "8024:     INT64 _pos = ftell(ifp);",
          "8025:     if (!strncmp(make, \"Canon\",5))",
          "8026:       {",
          "8027:         if (tag == 0x0001) Canon_CameraSettings();",
          "",
          "[Removed Lines]",
          "8021:     if(len > 100*1024*1024) continue; // 100Mb tag? No!",
          "",
          "[Added Lines]",
          "8036:     if(len > 8 && _pos+len > 2* fsize) continue;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "8056:              sprintf(imgdata.shootinginfo.BodySerial, \"%d\", get4());",
          "8057:           }",
          "8060:           {",
          "8061:             CanonCameraInfo = (uchar*)malloc(len);",
          "8062:             fread(CanonCameraInfo, len, 1, ifp);",
          "",
          "[Removed Lines]",
          "8059:         else if (tag == 0x000d)   // camera info",
          "",
          "[Added Lines]",
          "8071:         else if (tag == 0x000d && len < 256000) // camera info",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "8125:          char yy[2], mm[3], dd[3], ystr[16], ynum[16];",
          "8126:          int year, nwords, ynum_len;",
          "8127:          unsigned c;",
          "8129:          nwords = getwords(FujiSerial, words, 4,sizeof(imgdata.shootinginfo.InternalBodySerial));",
          "8130:          for (int i = 0; i < nwords; i++) {",
          "8131:            mm[2] = dd[2] = 0;",
          "",
          "[Removed Lines]",
          "8128:          fread(FujiSerial, MIN(len, sizeof(FujiSerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "8140:          stmread(FujiSerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "8189:         if ((tag == 0x0303) && (type != 4))",
          "8190:           {",
          "8192:           }",
          "8194:         if ((tag == 0x3405) ||",
          "",
          "[Removed Lines]",
          "8191:             fread(imgdata.lens.makernotes.Lens, MIN(len,127), 1, ifp);",
          "",
          "[Added Lines]",
          "8203:             stmread(imgdata.lens.makernotes.Lens, len, ifp);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "8252:           }",
          "8253:         else if (tag == 0x0082)    // lens attachment",
          "8254:           {",
          "8256:           }",
          "8257:         else if (tag == 0x0083)    // lens type",
          "8258:           {",
          "",
          "[Removed Lines]",
          "8255:             fread(imgdata.lens.makernotes.Attachment, MIN(len,127), 1, ifp);",
          "",
          "[Added Lines]",
          "8267:             stmread(imgdata.lens.makernotes.Attachment, len, ifp);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "8320:           }",
          "8321:         else if (tag == 0x00a0)",
          "8322:           {",
          "8324:           }",
          "8325:         else if (tag == 0x00a8)  // contains flash data",
          "8326:           {",
          "",
          "[Removed Lines]",
          "8323:             fread(imgdata.shootinginfo.BodySerial, MIN(len, sizeof(imgdata.shootinginfo.BodySerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "8335:             stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "8338:         case 0x101a:",
          "8339:         case 0x20100101:",
          "8340:           if (!imgdata.shootinginfo.BodySerial[0])",
          "8342:         break;",
          "8343:         case 0x20100102:",
          "8344:           if (!imgdata.shootinginfo.InternalBodySerial[0])",
          "8346:         break;",
          "8347:         case 0x0207:",
          "8348:         case 0x20100100:",
          "",
          "[Removed Lines]",
          "8341:             fread(imgdata.shootinginfo.BodySerial, MIN(len, sizeof(imgdata.shootinginfo.BodySerial)), 1, ifp);",
          "8345:             fread(imgdata.shootinginfo.InternalBodySerial, MIN(len, sizeof(imgdata.shootinginfo.InternalBodySerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "8353:             stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "8357:             stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "8390:             }",
          "8391:           break;",
          "8392:         case 0x20100202:",
          "8394:           break;",
          "8395:         case 0x20100203:",
          "8397:           break;",
          "8398:         case 0x20100205:",
          "8399:           imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "",
          "[Removed Lines]",
          "8393:           fread(imgdata.lens.LensSerial, MIN(len,sizeof(imgdata.lens.LensSerial)), 1, ifp);",
          "8396:           fread(imgdata.lens.makernotes.Lens, MIN(len,sizeof(imgdata.lens.makernotes.Lens)), 1, ifp);",
          "",
          "[Added Lines]",
          "8405:           stmread(imgdata.lens.LensSerial, len, ifp);",
          "8408:           stmread(imgdata.lens.makernotes.Lens, len, ifp);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "8419:             imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);",
          "8420:           break;",
          "8421:         case 0x20100303:",
          "8423:           break;",
          "8424:         case 0x20100403:",
          "8426:           break;",
          "8427:         }",
          "8428:       }",
          "",
          "[Removed Lines]",
          "8422:           fread(imgdata.lens.makernotes.Teleconverter, MIN(len,127), 1, ifp);",
          "8425:           fread(imgdata.lens.makernotes.Attachment, MIN(len,127), 1, ifp);",
          "",
          "[Added Lines]",
          "8434:           stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);",
          "8437:           stmread(imgdata.lens.makernotes.Attachment, len, ifp);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "8519:               }",
          "8520:             fseek(ifp, 6, SEEK_CUR);",
          "8521:             fseek(ifp, get4()+20, SEEK_SET);",
          "8523:             get2();",
          "8524:             imgdata.lens.makernotes.LensID = getc(ifp) - '0';",
          "8525:             switch(imgdata.lens.makernotes.LensID) {",
          "",
          "[Removed Lines]",
          "8522:             fread(imgdata.shootinginfo.BodySerial, 12, 1, ifp);",
          "",
          "[Added Lines]",
          "8534:             stread(imgdata.shootinginfo.BodySerial, 12, ifp);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "8540:              imgdata.lens.makernotes.LensID = -1;",
          "8541:             }",
          "8542:             fseek(ifp, 17, SEEK_CUR);",
          "8544:           }",
          "8545:       }",
          "",
          "[Removed Lines]",
          "8543:             fread(imgdata.lens.LensSerial, 12, 1, ifp);",
          "",
          "[Added Lines]",
          "8555:             stread(imgdata.lens.LensSerial, 12, ifp);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "8584:            }",
          "8585:         else if (tag == 0x0207)",
          "8586:           {",
          "8588:           }",
          "8589:         else if (tag == 0x020d)",
          "8590:         {",
          "",
          "[Removed Lines]",
          "8587:             PentaxLensInfo(imgdata.lens.makernotes.CamID, len);",
          "",
          "[Added Lines]",
          "8599:      if(len < 65535) // Safety belt",
          "8600:              PentaxLensInfo(imgdata.lens.makernotes.CamID, len);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "8638:         }",
          "8639:         else if (tag == 0x0229)",
          "8640:         {",
          "8642:         }",
          "8643:         else if (tag == 0x022d)",
          "8644:         {",
          "",
          "[Removed Lines]",
          "8641:           fread(imgdata.shootinginfo.BodySerial, MIN(len, sizeof(imgdata.shootinginfo.BodySerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "8654:           stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "8665:           {",
          "8666:             char LensInfo [20];",
          "8667:             fseek (ifp, 2, SEEK_CUR);",
          "8669:             strcat(imgdata.lens.makernotes.Lens, \" \");",
          "8671:             strcat(imgdata.lens.makernotes.Lens, LensInfo);",
          "8672:           }",
          "8673:       }",
          "",
          "[Removed Lines]",
          "8668:             fread(imgdata.lens.makernotes.Lens, 30, 1, ifp);",
          "8670:             fread(LensInfo, 20, 1, ifp);",
          "",
          "[Added Lines]",
          "8681:             stread(imgdata.lens.makernotes.Lens, 30, ifp);",
          "8683:             stread(LensInfo, 20, ifp);",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "8696:           }",
          "8697:          else if (tag == 0xa002)",
          "8698:           {",
          "8700:           }",
          "8701:         else if (tag == 0xa003)",
          "8702:           {",
          "",
          "[Removed Lines]",
          "8699:              fread(imgdata.shootinginfo.BodySerial, MIN(len, sizeof(imgdata.shootinginfo.BodySerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "8712:              stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "8706:           }",
          "8707:         else if (tag == 0xa005)",
          "8708:           {",
          "8710:           }",
          "8711:         else if (tag == 0xa019)",
          "8712:           {",
          "",
          "[Removed Lines]",
          "8709:             fread(imgdata.lens.InternalLensSerial, MIN(len,sizeof(imgdata.lens.InternalLensSerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "8722:             stmread(imgdata.lens.InternalLensSerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "8809:                  !strncasecmp(model, \"DSLR-A100\", 9))",
          "8810:    {",
          "8811:      fseek(ifp,0x49dc,SEEK_CUR);",
          "8813:    }",
          "8815:  else if (tag == 0x0104)",
          "",
          "[Removed Lines]",
          "8812:      fread(imgdata.shootinginfo.InternalBodySerial, MIN(12, sizeof(imgdata.shootinginfo.InternalBodySerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "8825:      stmread(imgdata.shootinginfo.InternalBodySerial, 12, ifp);",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "8822:             imgdata.lens.makernotes.TeleconverterID = get2();",
          "8823:           }",
          "8826:           {",
          "8827:             table_buf = (uchar*)malloc(len);",
          "8828:             fread(table_buf, len, 1, ifp);",
          "",
          "[Removed Lines]",
          "8825:         else if (tag == 0x0114)     // CameraSettings",
          "",
          "[Added Lines]",
          "8838:         else if (tag == 0x0114 && len < 256000)  // CameraSettings",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "8855:             free(table_buf);",
          "8856:           }",
          "8859:           {",
          "8860:             table_buf_0x9050 = (uchar*)malloc(len);",
          "8861:             table_buf_0x9050_present = 1;",
          "",
          "[Removed Lines]",
          "8858:         else if (tag == 0x9050)  // little endian",
          "",
          "[Added Lines]",
          "8871:         else if (tag == 0x9050 && len < 256000)  // little endian",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "8869:               }",
          "8870:           }",
          "8873:           {",
          "8874:             table_buf_0x940c = (uchar*)malloc(len);",
          "8875:             table_buf_0x940c_present = 1;",
          "",
          "[Removed Lines]",
          "8872:         else if (tag == 0x940c)",
          "",
          "[Added Lines]",
          "8885:         else if (tag == 0x940c && len <256000)",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "8906:             if (tag == 0x010c) imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;",
          "8907:           }",
          "8910:           {",
          "8911:             table_buf = (uchar*)malloc(len);",
          "8912:             fread(table_buf, len, 1, ifp);",
          "",
          "[Removed Lines]",
          "8909:         else if (tag == 0xb02a)     // Sony LensSpec",
          "",
          "[Added Lines]",
          "8922:         else if (tag == 0xb02a && len < 256000) // Sony LensSpec",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "9694:   kodak = !strncmp(make,\"EASTMAN\",7) && tiff_nifds < 3;",
          "9695:   entries = get2();",
          "9696:   if(!strncmp(make,\"Hasselblad\",10) && (tiff_nifds > 3) && (entries > 512)) return;",
          "9697:   while (entries--) {",
          "9698:     tiff_get (base, &tag, &type, &len, &save);",
          "9700: #ifdef LIBRAW_LIBRARY_BUILD",
          "9701:     if(callbacks.exif_cb)",
          "9702:       {",
          "9704:         callbacks.exif_cb(callbacks.exifparser_data,tag,type,len,order,ifp);",
          "9705:         fseek(ifp,savepos,SEEK_SET);",
          "9706:       }",
          "",
          "[Removed Lines]",
          "9703:         int savepos = ftell(ifp);",
          "",
          "[Added Lines]",
          "9710: #ifdef LIBRAW_LIBRARY_BUILD",
          "9711:   INT64 fsize = ifp->size();",
          "9712: #endif",
          "9717:     INT64 savepos = ftell(ifp);",
          "9718:     if(len > 8 && savepos + len > fsize*2) continue;",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "9711:       imgdata.lens.FocalLengthIn35mmFormat = get2();",
          "9712:       break;",
          "9713:     case 0xa431:  // BodySerialNumber",
          "9715:       break;",
          "9716:     case 0xa432:  // LensInfo, 42034dec, Lens Specification per EXIF standard",
          "9717:       imgdata.lens.MinFocal = getreal(type);",
          "",
          "[Removed Lines]",
          "9714:       fread(imgdata.shootinginfo.BodySerial, MIN(len, sizeof(imgdata.shootinginfo.BodySerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "9731:       stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "9720:       imgdata.lens.MaxAp4MaxFocal = getreal(type);",
          "9721:       break;",
          "9722:     case 0xa435:  // LensSerialNumber",
          "9724:       break;",
          "9725:     case 0xc630:  // DNG LensInfo, Lens Specification per EXIF standard",
          "9726:       imgdata.lens.dng.MinFocal = getreal(type);",
          "",
          "[Removed Lines]",
          "9723:       fread(imgdata.lens.LensSerial, MIN(len, sizeof(imgdata.lens.LensSerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "9740:       stmread(imgdata.lens.LensSerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "9729:       imgdata.lens.dng.MaxAp4MaxFocal = getreal(type);",
          "9730:       break;",
          "9731:     case 0xa433:  // LensMake",
          "9733:       break;",
          "9734:     case 0xa434:  // LensModel",
          "9736:       if (!strncmp(imgdata.lens.Lens, \"----\", 4))",
          "9737:         imgdata.lens.Lens[0] = 0;",
          "9738:       break;",
          "",
          "[Removed Lines]",
          "9732:       fread(imgdata.lens.LensMake, MIN(len,sizeof(imgdata.lens.LensMake)), 1, ifp);",
          "9735:       fread(imgdata.lens.Lens, MIN(len, sizeof(imgdata.lens.LensMake)), 1, ifp);",
          "",
          "[Added Lines]",
          "9749:       stmread(imgdata.lens.LensMake, len, ifp);",
          "9752:       stmread(imgdata.lens.Lens, len, ifp);",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "9823:     imgdata.other.parsed_gps.gpsparsed = 1;",
          "9824:   while (entries--) {",
          "9825:     tiff_get(base, &tag, &type, &len, &save);",
          "9826:     switch (tag) {",
          "9827:     case 1:  imgdata.other.parsed_gps.latref = getc(ifp); break;",
          "9828:     case 3:  imgdata.other.parsed_gps.longref = getc(ifp); break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9843:     if(len > 1024) continue; // no GPS tags are 1k or larger",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "9856:   entries = get2();",
          "9857:   while (entries--) {",
          "9858:     tiff_get (base, &tag, &type, &len, &save);",
          "9859:     switch (tag) {",
          "9860:       case 1: case 3: case 5:",
          "9861:  gpsdata[29+tag/2] = getc(ifp);   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9877:     if(len > 1024) continue; // no GPS tags are 1k or larger",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "9911: #ifdef LIBRAW_LIBRARY_BUILD",
          "9912:     if (!strcmp(data,\"CameraObj_camera_type\")) {",
          "9914:     }",
          "9915:     if (!strcmp(data,\"back_serial_number\")) {",
          "9916:        char buffer [sizeof(imgdata.shootinginfo.BodySerial)];",
          "9917:        char *words[4];",
          "9918:        int nwords;",
          "9920:        nwords = getwords(buffer, words, 4,sizeof(imgdata.shootinginfo.BodySerial));",
          "9921:        strcpy (imgdata.shootinginfo.BodySerial, words[0]);",
          "9922:     }",
          "",
          "[Removed Lines]",
          "9913:  fread(imgdata.lens.makernotes.body, MIN(skip,63), 1, ifp);",
          "9919:        fread(buffer, MIN(skip, sizeof(buffer)), 1, ifp);",
          "",
          "[Added Lines]",
          "9932:  stmread(imgdata.lens.makernotes.body, skip, ifp);",
          "9938:        stmread(buffer, skip, ifp);",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "9924:        char buffer [sizeof(imgdata.shootinginfo.InternalBodySerial)];",
          "9925:        char *words[4];",
          "9926:        int nwords;",
          "9928:        nwords = getwords(buffer, words, 4,sizeof(imgdata.shootinginfo.InternalBodySerial));",
          "9929:        strcpy (imgdata.shootinginfo.InternalBodySerial, words[0]);",
          "9930:     }",
          "",
          "[Removed Lines]",
          "9927:        fread(buffer, MIN(skip, sizeof(buffer)), 1, ifp);",
          "",
          "[Added Lines]",
          "9946:        stmread(buffer, skip, ifp);",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "10015:   entries = get2();",
          "10016:   if (entries > 1024) return;",
          "10017:   while (entries--) {",
          "10018:     tiff_get (base, &tag, &type, &len, &save);",
          "10019:     if(callbacks.exif_cb)",
          "10020:       {",
          "10022:         callbacks.exif_cb(callbacks.exifparser_data,tag | 0x20000,type,len,order,ifp);",
          "10023:         fseek(ifp,savepos,SEEK_SET);",
          "10024:       }",
          "",
          "[Removed Lines]",
          "10021:         int savepos = ftell(ifp);",
          "",
          "[Added Lines]",
          "10036:   INT64 fsize = ifp->size();",
          "10039:     INT64 savepos = ftell(ifp);",
          "10040:     if(len > 8 && len + savepos > 2*fsize) continue;",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "10038:                          imgdata.color.linear_max[1] =",
          "10039:                          imgdata.color.linear_max[2] =",
          "10040:                          imgdata.color.linear_max[3] = get2();",
          "10043:  if (tag == 0xfa27)",
          "10044:    {",
          "10045:                 FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get4();",
          "",
          "[Removed Lines]",
          "10041:         if (tag == 0x09ce) fread(imgdata.shootinginfo.InternalBodySerial, MIN(len, sizeof(imgdata.shootinginfo.InternalBodySerial)), 1, ifp);",
          "10042:         if (tag == 0xfa00) fread(imgdata.shootinginfo.BodySerial, MIN(len, sizeof(imgdata.shootinginfo.BodySerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "10062:         if (tag == 0x09ce)",
          "10063:   stmread(imgdata.shootinginfo.InternalBodySerial,len, ifp);",
          "10064:         if (tag == 0xfa00)",
          "10065:   stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "10142:       cc[j][i] = i == j;",
          "10143:   entries = get2();",
          "10144:   if (entries > 512) return 1;",
          "10145:   while (entries--) {",
          "10146:     tiff_get (base, &tag, &type, &len, &save);",
          "10147: #ifdef LIBRAW_LIBRARY_BUILD",
          "10148:     if(callbacks.exif_cb)",
          "10149:       {",
          "10151:         callbacks.exif_cb(callbacks.exifparser_data,tag|(pana_raw?0x30000:0),type,len,order,ifp);",
          "10152:         fseek(ifp,savepos,SEEK_SET);",
          "10153:       }",
          "",
          "[Removed Lines]",
          "10150:         int savepos = ftell(ifp);",
          "",
          "[Added Lines]",
          "10168: #ifdef LIBRAW_LIBRARY_BUILD",
          "10169:   INT64 fsize = ifp->size();",
          "10170: #endif",
          "10174:     INT64 savepos = ftell(ifp);",
          "10175:     if(len > 8 && len + savepos > fsize*2) continue; // skip tag pointing out of 2xfile",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "10511:         if((type == 1 || type == 2 || type == 6 || type == 7) && len > 1 && len < 5100000)",
          "10512:           {",
          "10513:             xmpdata = (char*)malloc(xmplen = len+1);",
          "10515:             xmpdata[len]=0;",
          "10516:           }",
          "10517:         break;",
          "",
          "[Removed Lines]",
          "10514:             fread(xmpdata,len,1,ifp);",
          "",
          "[Added Lines]",
          "10541:             stread(xmpdata,len,ifp);",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "10609:       break;",
          "10610:     case 0xa431:  // BodySerialNumber",
          "10611:     case 0xc62f:",
          "10613:       break;",
          "10614:     case 0xa432:  // LensInfo, 42034dec, Lens Specification per EXIF standard",
          "10615:       imgdata.lens.MinFocal = getreal(type);",
          "",
          "[Removed Lines]",
          "10612:       fread(imgdata.shootinginfo.BodySerial, MIN(len, sizeof(imgdata.shootinginfo.BodySerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "10639:       stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "10618:       imgdata.lens.MaxAp4MaxFocal = getreal(type);",
          "10619:       break;",
          "10620:     case 0xa435:  // LensSerialNumber",
          "10622:       break;",
          "10623:     case 0xc630:  // DNG LensInfo, Lens Specification per EXIF standard",
          "10624:       imgdata.lens.MinFocal = getreal(type);",
          "",
          "[Removed Lines]",
          "10621:       fread(imgdata.lens.LensSerial, MIN(len, sizeof(imgdata.lens.LensSerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "10648:       stmread(imgdata.lens.LensSerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "10627:       imgdata.lens.MaxAp4MaxFocal = getreal(type);",
          "10628:       break;",
          "10629:     case 0xa433:  // LensMake",
          "10631:       break;",
          "10632:     case 0xa434:  // LensModel",
          "10634:       if (!strncmp(imgdata.lens.Lens, \"----\", 4))",
          "10635:         imgdata.lens.Lens[0] = 0;",
          "10636:       break;",
          "",
          "[Removed Lines]",
          "10630:       fread(imgdata.lens.LensMake, MIN(len, sizeof(imgdata.lens.LensMake)), 1, ifp);",
          "10633:       fread(imgdata.lens.Lens, MIN(len, sizeof(imgdata.lens.Lens)), 1, ifp);",
          "",
          "[Added Lines]",
          "10657:       stmread(imgdata.lens.LensMake, len, ifp);",
          "10660:       stmread(imgdata.lens.Lens, len, ifp);",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "10748:  break;",
          "10750:       case 50455:",
          "10752: #ifndef LIBRAW_LIBRARY_BUILD",
          "10753:  fread (cbuf, 1, len, ifp);",
          "10754: #else",
          "10755:  if(fread (cbuf, 1, len, ifp) != len)",
          "10756:   throw LIBRAW_EXCEPTION_IO_CORRUPT; // cbuf to be free'ed in recycle",
          "10757: #endif",
          "10758:  for (cp = cbuf-1; cp && cp < cbuf+len; cp = strchr(cp,'\\n'))",
          "10759:    if (!strncmp (++cp,\"Neutral \",8))",
          "10760:      sscanf (cp+8, \"%f %f %f\", cam_mul, cam_mul+1, cam_mul+2);",
          "",
          "[Removed Lines]",
          "10751:  if (!(cbuf = (char *) malloc(len))) break;",
          "",
          "[Added Lines]",
          "10778:  if (len > 2560000 || !(cbuf = (char *) malloc(len))) break;",
          "10785:         cbuf[len-1] = 0;",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "10784:  break;",
          "10786: #ifdef LIBRAW_LIBRARY_BUILD",
          "10788:         imgdata.color.UniqueCameraModel[sizeof(imgdata.color.UniqueCameraModel)-1] = 0;",
          "10789: #endif",
          "10790:  if (model[0]) break;",
          "",
          "[Removed Lines]",
          "10787:         fread(imgdata.color.UniqueCameraModel, MIN(len, sizeof(imgdata.color.UniqueCameraModel)), 1, ifp);",
          "",
          "[Added Lines]",
          "10815:         stmread(imgdata.color.UniqueCameraModel, len, ifp);",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "10833:     imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];",
          "10834:     imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];",
          "10835:     imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];",
          "10837:     {",
          "10838:       long long f_save = ftell(ifp);",
          "10839:       int fj, found = 0;",
          "",
          "[Removed Lines]",
          "10836:     if ((fwb[3] == 17) && libraw_internal_data.unpacker_data.lenRAFData>3)",
          "",
          "[Added Lines]",
          "10864:     if ((fwb[3] == 17) && libraw_internal_data.unpacker_data.lenRAFData>3 && libraw_internal_data.unpacker_data.lenRAFData < 10240000)",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "10910: #ifdef LIBRAW_LIBRARY_BUILD",
          "10911:       case 50709:",
          "10914:       break;",
          "10915: #endif",
          "",
          "[Removed Lines]",
          "10912:         fread(imgdata.color.LocalizedCameraModel, MIN(len, sizeof(imgdata.color.LocalizedCameraModel)), 1, ifp);",
          "10913:         imgdata.color.LocalizedCameraModel[sizeof(imgdata.color.LocalizedCameraModel)-1] = 0;",
          "",
          "[Added Lines]",
          "10940:         stmread(imgdata.color.LocalizedCameraModel,len, ifp);",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "11117:     }",
          "11118:     fseek (ifp, save, SEEK_SET);",
          "11119:   }",
          "11121:     fseek (ifp, sony_offset, SEEK_SET);",
          "11122:     fread (buf, sony_length, 1, ifp);",
          "11123:     sony_decrypt (buf, sony_length/4, 1, sony_key);",
          "",
          "[Removed Lines]",
          "11120:   if (sony_length && (buf = (unsigned *) malloc(sony_length))) {",
          "",
          "[Added Lines]",
          "11147:   if (sony_length && sony_length < 10240000 && (buf = (unsigned *) malloc(sony_length))) {",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "11849: #ifdef LIBRAW_LIBRARY_BUILD",
          "11850:     case 0x0102:",
          "11852:       if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49)) {",
          "11853:         unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;",
          "11854:       } else {",
          "",
          "[Removed Lines]",
          "11851:       fread(imgdata.shootinginfo.BodySerial, MIN(len, sizeof(imgdata.shootinginfo.BodySerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "11878:       stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "11865:       else imgdata.lens.makernotes.CurFocal = getreal(type);",
          "11866:       break;",
          "11867:     case 0x0410:",
          "11869:       break;",
          "11870:     case 0x0412:",
          "11872:       break;",
          "11873:     case 0x0414:",
          "11874:       if (type == 4) {",
          "",
          "[Removed Lines]",
          "11868:       fread(imgdata.lens.makernotes.body, 1, len, ifp);",
          "11871:       fread(imgdata.lens.makernotes.Lens, 1, len, ifp);",
          "",
          "[Added Lines]",
          "11895:       stmread(imgdata.lens.makernotes.body, len, ifp);",
          "11898:       stmread(imgdata.lens.makernotes.Lens, len, ifp);",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "11963:       save = ftell(ifp);",
          "11964:       fseek (ifp, meta_offset+data, SEEK_SET);",
          "11965:       if (tag == 0x0407) {",
          "11967:         if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49)) {",
          "11968:           unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;",
          "11969:         } else {",
          "",
          "[Removed Lines]",
          "11966:         fread(imgdata.shootinginfo.BodySerial, MIN(len, sizeof(imgdata.shootinginfo.BodySerial)), 1, ifp);",
          "",
          "[Added Lines]",
          "11993:         stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "14047:     fseek (ifp, 104, SEEK_SET);",
          "14048:     imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, ((float)get4())/16.0f);",
          "14049:     fseek (ifp, 124, SEEK_SET);",
          "14051:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Contax_N;",
          "14052:     if (imgdata.lens.makernotes.Lens[0])",
          "14053:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Contax_N;",
          "",
          "[Removed Lines]",
          "14050:     fread(imgdata.lens.makernotes.Lens, 32, 1, ifp);",
          "",
          "[Added Lines]",
          "14077:     stmread(imgdata.lens.makernotes.Lens, 32, ifp);",
          "",
          "---------------"
        ],
        "internal/defines.h||internal/defines.h": [
          "File: internal/defines.h -> internal/defines.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "99: #define FORC(cnt) for (c=0; c < cnt; c++)",
          "100: #define FORC3 FORC(3)",
          "101: #define FORC4 FORC(4)",
          "104: #define SQR(x) ((x)*(x))",
          "105: #define ABS(x) (((int)(x) ^ ((int)(x) >> 31)) - ((int)(x) >> 31))",
          "",
          "[Removed Lines]",
          "102: #define FORCC FORC(colors)",
          "",
          "[Added Lines]",
          "102: #define FORCC for (c=0; c < colors && c < 4; c++)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7ed16d4d5f039f009dd84e99f98ee5b7f2bdabc8",
      "candidate_info": {
        "commit_hash": "7ed16d4d5f039f009dd84e99f98ee5b7f2bdabc8",
        "repo": "LibRaw/LibRaw",
        "commit_url": "https://github.com/LibRaw/LibRaw/commit/7ed16d4d5f039f009dd84e99f98ee5b7f2bdabc8",
        "files": [
          ".clang-format",
          "Makefile.devel",
          "dcraw/dcraw.c",
          "internal/dcraw_common.cpp",
          "internal/dcraw_fileio.cpp",
          "internal/defines.h",
          "libraw/libraw.h",
          "libraw/libraw_alloc.h",
          "libraw/libraw_const.h",
          "libraw/libraw_datastream.h",
          "libraw/libraw_internal.h",
          "libraw/libraw_types.h",
          "libraw/libraw_version.h",
          "src/libraw_c_api.cpp",
          "src/libraw_cxx.cpp",
          "src/libraw_datastream.cpp",
          "src/libraw_xtrans_compressed.cpp"
        ],
        "message": "clang-format-ted",
        "before_after_code_files": [
          "Makefile.devel||Makefile.devel",
          "dcraw/dcraw.c||dcraw/dcraw.c",
          "internal/dcraw_common.cpp||internal/dcraw_common.cpp",
          "internal/dcraw_fileio.cpp||internal/dcraw_fileio.cpp",
          "internal/defines.h||internal/defines.h",
          "libraw/libraw.h||libraw/libraw.h",
          "libraw/libraw_alloc.h||libraw/libraw_alloc.h",
          "libraw/libraw_const.h||libraw/libraw_const.h",
          "libraw/libraw_datastream.h||libraw/libraw_datastream.h",
          "libraw/libraw_internal.h||libraw/libraw_internal.h",
          "libraw/libraw_types.h||libraw/libraw_types.h",
          "libraw/libraw_version.h||libraw/libraw_version.h",
          "src/libraw_c_api.cpp||src/libraw_c_api.cpp",
          "src/libraw_cxx.cpp||src/libraw_cxx.cpp",
          "src/libraw_datastream.cpp||src/libraw_datastream.cpp",
          "src/libraw_xtrans_compressed.cpp||src/libraw_xtrans_compressed.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "dcraw/dcraw.c||dcraw/dcraw.c",
            "internal/dcraw_common.cpp||internal/dcraw_common.cpp"
          ],
          "candidate": [
            "dcraw/dcraw.c||dcraw/dcraw.c",
            "internal/dcraw_common.cpp||internal/dcraw_common.cpp"
          ]
        }
      },
      "candidate_diff": {
        "Makefile.devel||Makefile.devel": [
          "File: Makefile.devel -> Makefile.devel",
          "--- Hunk 1 ---",
          "[Context before]",
          "63: sources: ${DCRAW_GEN} Makefile.devel ${PP}",
          "64: library: lib/libraw.a lib/libraw_r.a",
          "66: all_samples: bin/raw-identify bin/simple_dcraw  bin/dcraw_emu bin/dcraw_half bin/half_mt bin/mem_image \\",
          "67:         bin/unprocessed_raw bin/4channels bin/multirender_test bin/postprocessing_benchmark",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66: format:  dcraw/dcraw.c ${LR_INCLUDES} src/libraw_cxx.cpp",
          "67:  clang-format-devel -i -style=file src/*.cpp dcraw/dcraw.c libraw/*.h",
          "",
          "---------------"
        ],
        "dcraw/dcraw.c||dcraw/dcraw.c": [
          "File: dcraw/dcraw.c -> dcraw/dcraw.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "65: #ifdef __CYGWIN__",
          "66: #include <io.h>",
          "67: #endif",
          "69: #include <sys/utime.h>",
          "70: #include <winsock2.h>",
          "71: #pragma comment(lib, \"ws2_32.lib\")",
          "",
          "[Removed Lines]",
          "68: #if defined WIN32 || defined (__MINGW32__)",
          "",
          "[Added Lines]",
          "68: #if defined WIN32 || defined(__MINGW32__)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "115: #endif",
          "117: #ifndef LONG_BIT",
          "119: #endif",
          "",
          "[Removed Lines]",
          "118: #define LONG_BIT (8 * sizeof (long))",
          "",
          "[Added Lines]",
          "118: #define LONG_BIT (8 * sizeof(long))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "135: short order;",
          "136: const char *ifname;",
          "137: char *meta_data, xtrans[6][6], xtrans_abs[6][6];",
          "139: float flash_used, canon_ev, iso_speed, shutter, aperture, focal_len;",
          "140: time_t timestamp;",
          "141: off_t strip_offset, data_offset;",
          "142: off_t thumb_offset, meta_offset, profile_offset;",
          "143: unsigned shot_order, kodak_cbpp, exif_cfa, unique_id;",
          "144: unsigned thumb_length, meta_length, profile_length;",
          "146: unsigned tiff_nifds, tiff_samples, tiff_bps, tiff_compress;",
          "147: unsigned black, maximum, mix_green, raw_color, zero_is_bad;",
          "148: unsigned zero_after_ff, is_raw, dng_version, is_foveon, data_error;",
          "",
          "[Removed Lines]",
          "138: char cdesc[5], desc[512], make[64], model[64], model2[64], artist[64],software[64];",
          "145: unsigned thumb_misc, *oprof, fuji_layout, shot_select=0, multi_out=0;",
          "",
          "[Added Lines]",
          "138: char cdesc[5], desc[512], make[64], model[64], model2[64], artist[64], software[64];",
          "145: unsigned thumb_misc, *oprof, fuji_layout, shot_select = 0, multi_out = 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "152: ushort shrink, iheight, iwidth, fuji_width, thumb_width, thumb_height;",
          "153: ushort *raw_image, (*image)[4], cblack[4102];",
          "154: ushort white[8][8], curve[0x10000], cr2_slice[3], sraw_mul[4];",
          "157: int mask[8][4];",
          "163: float cam_mul[4], pre_mul[4], cmatrix[3][4], rgb_cam[3][4];",
          "169: int histogram[4][0x2000];",
          "170: void (*write_thumb)(), (*write_fun)();",
          "171: void (*load_raw)(), (*thumb_load_raw)();",
          "172: jmp_buf failure;",
          "175:   struct decode *branch[2];",
          "176:   int leaf;",
          "177: } first_decode[2048], *second_decode, *free_decode;",
          "180:   int t_width, t_height, bps, comp, phint, offset, t_flip, samples, bytes;",
          "182:   float t_shutter;",
          "183: } tiff_ifd[10];",
          "186:   int format, key_off, tag_21a;",
          "187:   int t_black, split_col, black_col, split_row, black_row;",
          "188:   float tag_210;",
          "",
          "[Removed Lines]",
          "155: double pixel_aspect, aber[4]={1,1,1,1}, gamm[6]={ 0.45,4.5,0,0,0,0 };",
          "156: float bright=1, user_mul[4]={0,0,0,0}, threshold=0;",
          "158: int half_size=0, four_color_rgb=0, document_mode=0, highlight=0;",
          "159: int verbose=0, use_auto_wb=0, use_camera_wb=0, use_camera_matrix=1;",
          "160: int output_color=1, output_bps=8, output_tiff=0, med_passes=0;",
          "161: int no_auto_bright=0;",
          "162: unsigned greybox[4] = { 0, 0, UINT_MAX, UINT_MAX };",
          "165:   { 0.412453, 0.357580, 0.180423 },",
          "166:   { 0.212671, 0.715160, 0.072169 },",
          "167:   { 0.019334, 0.119193, 0.950227 } };",
          "168: const float d65_white[3] = { 0.950456, 1, 1.088754 };",
          "174: struct decode {",
          "179: struct tiff_ifd {",
          "181:   int t_tile_width, t_tile_length,sample_format,predictor;",
          "185: struct ph1 {",
          "",
          "[Added Lines]",
          "155: double pixel_aspect, aber[4] = {1, 1, 1, 1}, gamm[6] = {0.45, 4.5, 0, 0, 0, 0};",
          "156: float bright = 1, user_mul[4] = {0, 0, 0, 0}, threshold = 0;",
          "158: int half_size = 0, four_color_rgb = 0, document_mode = 0, highlight = 0;",
          "159: int verbose = 0, use_auto_wb = 0, use_camera_wb = 0, use_camera_matrix = 1;",
          "160: int output_color = 1, output_bps = 8, output_tiff = 0, med_passes = 0;",
          "161: int no_auto_bright = 0;",
          "162: unsigned greybox[4] = {0, 0, UINT_MAX, UINT_MAX};",
          "165:                               {0.412453, 0.357580, 0.180423},",
          "166:                               {0.212671, 0.715160, 0.072169},",
          "167:                               {0.019334, 0.119193, 0.950227}};",
          "168: const float d65_white[3] = {0.950456, 1, 1.088754};",
          "174: struct decode",
          "175: {",
          "180: struct tiff_ifd",
          "181: {",
          "183:   int t_tile_width, t_tile_length, sample_format, predictor;",
          "187: struct ph1",
          "188: {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "191: #define CLASS",
          "195: #define FORC3 FORC(3)",
          "196: #define FORC4 FORC(4)",
          "200: #define ABS(x) (((int)(x) ^ ((int)(x) >> 31)) - ((int)(x) >> 31))",
          "216:    In order to inline this calculation, I make the risky",
          "",
          "[Removed Lines]",
          "194: #define FORC(cnt) for (c=0; c < cnt; c++)",
          "197: #define FORCC for (c=0; c < colors && c < 4; c++)",
          "199: #define SQR(x) ((x)*(x))",
          "201: #define MIN(a,b) ((a) < (b) ? (a) : (b))",
          "202: #define MAX(a,b) ((a) > (b) ? (a) : (b))",
          "203: #define LIM(x,min,max) MAX(min,MIN(x,max))",
          "204: #define ULIM(x,y,z) ((y) < (z) ? LIM(x,y,z) : LIM(x,z,y))",
          "205: #define CLIP(x) LIM((int)(x),0,65535)",
          "206: #define SWAP(a,b) { a=a+b; b=a-b; a=a-b; }",
          "208: #define my_swap(type, i, j) {type t = i; i = j; j = t;}",
          "210: static float fMAX(float a, float b)",
          "211: {",
          "212:   return MAX(a,b);",
          "213: }",
          "",
          "[Added Lines]",
          "197: #define FORC(cnt) for (c = 0; c < cnt; c++)",
          "200: #define FORCC for (c = 0; c < colors && c < 4; c++)",
          "202: #define SQR(x) ((x) * (x))",
          "204: #define MIN(a, b) ((a) < (b) ? (a) : (b))",
          "205: #define MAX(a, b) ((a) > (b) ? (a) : (b))",
          "206: #define LIM(x, min, max) MAX(min, MIN(x, max))",
          "207: #define ULIM(x, y, z) ((y) < (z) ? LIM(x, y, z) : LIM(x, z, y))",
          "208: #define CLIP(x) LIM((int)(x), 0, 65535)",
          "209: #define SWAP(a, b)                                                                                                     \\",
          "210:   {                                                                                                                    \\",
          "211:     a = a + b;                                                                                                         \\",
          "212:     b = a - b;                                                                                                         \\",
          "213:     a = a - b;                                                                                                         \\",
          "214:   }",
          "216: #define my_swap(type, i, j)                                                                                            \\",
          "217:   {                                                                                                                    \\",
          "218:     type t = i;                                                                                                        \\",
          "219:     i = j;                                                                                                             \\",
          "220:     j = t;                                                                                                             \\",
          "221:   }",
          "223: static float fMAX(float a, float b) { return MAX(a, b); }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "223:    Return values are either 0/1/2/3 = G/M/C/Y or 0/1/2/3 = R/G1/B/G2",
          "243:    All RGB cameras use one of these Bayer grids:",
          "",
          "[Removed Lines]",
          "225:  PowerShot 600 PowerShot A50 PowerShot Pro70 Pro90 & G1",
          "226:  0xe1e4e1e4: 0x1b4e4b1e: 0x1e4b4e1b: 0xb4b4b4b4:",
          "228:    0 1 2 3 4 5   0 1 2 3 4 5   0 1 2 3 4 5   0 1 2 3 4 5",
          "229:  0 G M G M G M 0 C Y C Y C Y 0 Y C Y C Y C 0 G M G M G M",
          "230:  1 C Y C Y C Y 1 M G M G M G 1 M G M G M G 1 Y C Y C Y C",
          "231:  2 M G M G M G 2 Y C Y C Y C 2 C Y C Y C Y",
          "232:  3 C Y C Y C Y 3 G M G M G M 3 G M G M G M",
          "233:    4 C Y C Y C Y 4 Y C Y C Y C",
          "234:  PowerShot A5 5 G M G M G M 5 G M G M G M",
          "235:  0x1e4e1e4e: 6 Y C Y C Y C 6 C Y C Y C Y",
          "236:    7 M G M G M G 7 M G M G M G",
          "237:    0 1 2 3 4 5",
          "238:  0 C Y C Y C Y",
          "239:  1 G M G M G M",
          "240:  2 C Y C Y C Y",
          "241:  3 M G M G M G",
          "245:  0x16161616: 0x61616161: 0x49494949: 0x94949494:",
          "247:    0 1 2 3 4 5   0 1 2 3 4 5   0 1 2 3 4 5   0 1 2 3 4 5",
          "248:  0 B G B G B G 0 G R G R G R 0 G B G B G B 0 R G R G R G",
          "249:  1 G R G R G R 1 B G B G B G 1 R G R G R G 1 G B G B G B",
          "250:  2 B G B G B G 2 G R G R G R 2 G B G B G B 2 R G R G R G",
          "251:  3 G R G R G R 3 B G B G B G 3 R G R G R G 3 G B G B G B",
          "254: #define RAW(row,col) \\",
          "255:  raw_image[(row)*raw_width+(col)]",
          "258: #define FC(row,col) \\",
          "259:  (filters >> ((((row) << 1 & 14) + ((col) & 1)) << 1) & 3)",
          "262: #define BAYER(row,col) \\",
          "263:  image[((row) >> shrink)*iwidth + ((col) >> shrink)][FC(row,col)]",
          "265: #define BAYER2(row,col) \\",
          "266:  image[((row) >> shrink)*iwidth + ((col) >> shrink)][fcol(row,col)]",
          "",
          "[Added Lines]",
          "235:         PowerShot 600 PowerShot A50 PowerShot Pro70 Pro90 & G1",
          "236:         0xe1e4e1e4: 0x1b4e4b1e: 0x1e4b4e1b: 0xb4b4b4b4:",
          "238:           0 1 2 3 4 5   0 1 2 3 4 5   0 1 2 3 4 5   0 1 2 3 4 5",
          "239:         0 G M G M G M 0 C Y C Y C Y 0 Y C Y C Y C 0 G M G M G M",
          "240:         1 C Y C Y C Y 1 M G M G M G 1 M G M G M G 1 Y C Y C Y C",
          "241:         2 M G M G M G 2 Y C Y C Y C 2 C Y C Y C Y",
          "242:         3 C Y C Y C Y 3 G M G M G M 3 G M G M G M",
          "243:                         4 C Y C Y C Y 4 Y C Y C Y C",
          "244:         PowerShot A5 5 G M G M G M 5 G M G M G M",
          "245:         0x1e4e1e4e: 6 Y C Y C Y C 6 C Y C Y C Y",
          "246:                         7 M G M G M G 7 M G M G M G",
          "247:           0 1 2 3 4 5",
          "248:         0 C Y C Y C Y",
          "249:         1 G M G M G M",
          "250:         2 C Y C Y C Y",
          "251:         3 M G M G M G",
          "255:         0x16161616: 0x61616161: 0x49494949: 0x94949494:",
          "257:           0 1 2 3 4 5   0 1 2 3 4 5   0 1 2 3 4 5   0 1 2 3 4 5",
          "258:         0 B G B G B G 0 G R G R G R 0 G B G B G B 0 R G R G R G",
          "259:         1 G R G R G R 1 B G B G B G 1 R G R G R G 1 G B G B G B",
          "260:         2 B G B G B G 2 G R G R G R 2 G B G B G B 2 R G R G R G",
          "261:         3 G R G R G R 3 B G B G B G 3 R G R G R G 3 G B G B G B",
          "264: #define RAW(row, col) raw_image[(row)*raw_width + (col)]",
          "267: #define FC(row, col) (filters >> ((((row) << 1 & 14) + ((col)&1)) << 1) & 3)",
          "270: #define BAYER(row, col) image[((row) >> shrink) * iwidth + ((col) >> shrink)][FC(row, col)]",
          "272: #define BAYER2(row, col) image[((row) >> shrink) * iwidth + ((col) >> shrink)][fcol(row, col)]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "283: {",
          "305: }",
          "306: static size_t local_strnlen(const char *s, size_t n)",
          "307: {",
          "308:   const char *p = (const char *)memchr(s, 0, n);",
          "310: }",
          "314: #ifdef LIBRAW_LIBRARY_BUILD",
          "315: static int stread(char *buf, size_t len, LibRaw_abstract_datastream *fp)",
          "316: {",
          "320: }",
          "322: #endif",
          "324: #ifndef __GLIBC__",
          "327: {",
          "328:   char *c;",
          "329:   for (c = haystack; c <= haystack + haystacklen - needlelen; c++)",
          "331:       return c;",
          "332:   return 0;",
          "333: }",
          "334: #define memmem my_memmem",
          "336: {",
          "337:   char *c;",
          "338:   for (c = haystack; *c; c++)",
          "",
          "[Removed Lines]",
          "282: int CLASS fcol (int row, int col)",
          "284:   static const char filter[16][16] =",
          "285:   { { 2,1,1,3,2,3,2,0,3,2,3,0,1,2,1,0 },",
          "286:     { 0,3,0,2,0,1,3,1,0,1,1,2,0,3,3,2 },",
          "287:     { 2,3,3,2,3,1,1,3,3,1,2,1,2,0,0,3 },",
          "288:     { 0,1,0,1,0,2,0,2,2,0,3,0,1,3,2,1 },",
          "289:     { 3,1,1,2,0,1,0,2,1,3,1,3,0,1,3,0 },",
          "290:     { 2,0,0,3,3,2,3,1,2,0,2,0,3,2,2,1 },",
          "291:     { 2,3,3,1,2,1,2,1,2,1,1,2,3,0,0,1 },",
          "292:     { 1,0,0,2,3,0,0,3,0,3,0,3,2,1,2,3 },",
          "293:     { 2,3,3,1,1,2,1,0,3,2,3,0,2,3,1,3 },",
          "294:     { 1,0,2,0,3,0,3,2,0,1,1,2,0,1,0,2 },",
          "295:     { 0,1,1,3,3,2,2,1,1,3,3,0,2,1,3,2 },",
          "296:     { 2,3,2,0,0,1,3,0,2,0,1,2,3,0,1,0 },",
          "297:     { 1,3,1,2,3,2,3,2,0,2,0,1,1,0,3,0 },",
          "298:     { 0,2,0,3,1,0,0,1,1,3,3,2,3,2,2,1 },",
          "299:     { 2,1,3,2,3,1,2,1,0,3,0,2,0,2,0,2 },",
          "300:     { 0,3,1,0,0,2,0,3,2,1,3,1,1,3,1,3 } };",
          "302:   if (filters == 1) return filter[(row+top_margin)&15][(col+left_margin)&15];",
          "303:   if (filters == 9) return xtrans[(row+6) % 6][(col+6) % 6];",
          "304:   return FC(row,col);",
          "309:   return(p ? p-s : n);",
          "312: #define strnlen(a,b) local_strnlen(a,b)",
          "317:  int r = fp->read(buf,len,1);",
          "318:  buf[len-1] = 0;",
          "319:  return r;",
          "321: #define stmread(buf,maxlen,fp) stread(buf,MIN(maxlen,sizeof(buf)),fp)",
          "325: char *my_memmem (char *haystack, size_t haystacklen,",
          "326:        char *needle, size_t needlelen)",
          "330:     if (!memcmp (c, needle, needlelen))",
          "335: char *my_strcasestr (char *haystack, const char *needle)",
          "",
          "[Added Lines]",
          "288: int CLASS fcol(int row, int col)",
          "290:   static const char filter[16][16] = {",
          "291:       {2, 1, 1, 3, 2, 3, 2, 0, 3, 2, 3, 0, 1, 2, 1, 0}, {0, 3, 0, 2, 0, 1, 3, 1, 0, 1, 1, 2, 0, 3, 3, 2},",
          "292:       {2, 3, 3, 2, 3, 1, 1, 3, 3, 1, 2, 1, 2, 0, 0, 3}, {0, 1, 0, 1, 0, 2, 0, 2, 2, 0, 3, 0, 1, 3, 2, 1},",
          "293:       {3, 1, 1, 2, 0, 1, 0, 2, 1, 3, 1, 3, 0, 1, 3, 0}, {2, 0, 0, 3, 3, 2, 3, 1, 2, 0, 2, 0, 3, 2, 2, 1},",
          "294:       {2, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 2, 3, 0, 0, 1}, {1, 0, 0, 2, 3, 0, 0, 3, 0, 3, 0, 3, 2, 1, 2, 3},",
          "295:       {2, 3, 3, 1, 1, 2, 1, 0, 3, 2, 3, 0, 2, 3, 1, 3}, {1, 0, 2, 0, 3, 0, 3, 2, 0, 1, 1, 2, 0, 1, 0, 2},",
          "296:       {0, 1, 1, 3, 3, 2, 2, 1, 1, 3, 3, 0, 2, 1, 3, 2}, {2, 3, 2, 0, 0, 1, 3, 0, 2, 0, 1, 2, 3, 0, 1, 0},",
          "297:       {1, 3, 1, 2, 3, 2, 3, 2, 0, 2, 0, 1, 1, 0, 3, 0}, {0, 2, 0, 3, 1, 0, 0, 1, 1, 3, 3, 2, 3, 2, 2, 1},",
          "298:       {2, 1, 3, 2, 3, 1, 2, 1, 0, 3, 0, 2, 0, 2, 0, 2}, {0, 3, 1, 0, 0, 2, 0, 3, 2, 1, 3, 1, 1, 3, 1, 3}};",
          "300:   if (filters == 1)",
          "301:     return filter[(row + top_margin) & 15][(col + left_margin) & 15];",
          "302:   if (filters == 9)",
          "303:     return xtrans[(row + 6) % 6][(col + 6) % 6];",
          "304:   return FC(row, col);",
          "309:   return (p ? p - s : n);",
          "312: #define strnlen(a, b) local_strnlen(a, b)",
          "317:   int r = fp->read(buf, len, 1);",
          "318:   buf[len - 1] = 0;",
          "319:   return r;",
          "321: #define stmread(buf, maxlen, fp) stread(buf, MIN(maxlen, sizeof(buf)), fp)",
          "325: char *my_memmem(char *haystack, size_t haystacklen, char *needle, size_t needlelen)",
          "329:     if (!memcmp(c, needle, needlelen))",
          "334: char *my_strcasestr(char *haystack, const char *needle)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "343: #define strcasestr my_strcasestr",
          "344: #endif",
          "352: {",
          "356: }",
          "358: void CLASS derror()",
          "359: {",
          "362:     if (feof(ifp))",
          "364:     else",
          "366:   }",
          "367:   data_error++;",
          "368: }",
          "372: {",
          "374:     return s[0] | s[1] << 8;",
          "376:     return s[0] << 8 | s[1];",
          "377: }",
          "383: #ifdef LIBRAW_LIBRARY_BUILD",
          "385: {",
          "387:   char *p = line;",
          "388:   int nwords = 0;",
          "391:   {",
          "394:     words[nwords++] = p;",
          "399:   }",
          "400: }",
          "416: }",
          "422: }",
          "427: {",
          "432: }",
          "433: #endif",
          "435: ushort CLASS get2()",
          "436: {",
          "439:   return sget2(str);",
          "440: }",
          "443: {",
          "444:   if (order == 0x4949)",
          "445:     return s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;",
          "",
          "[Removed Lines]",
          "346: #define strbuflen(buf) strnlen(buf,sizeof(buf)-1)",
          "351: void CLASS merror (void *ptr, const char *where)",
          "353:   if (ptr) return;",
          "354:   fprintf (stderr,_(\"%s: Out of memory in %s\\n\"), ifname, where);",
          "355:   longjmp (failure, 1);",
          "360:   if (!data_error) {",
          "361:     fprintf (stderr, \"%s: \", ifname);",
          "363:       fprintf (stderr,_(\"Unexpected end of file\\n\"));",
          "365:       fprintf (stderr,_(\"Corrupt data near 0x%llx\\n\"), (INT64) ftello(ifp));",
          "371: ushort CLASS sget2 (uchar *s)",
          "380: #define CameraDNG 1",
          "381: #define AdobeDNG 2",
          "384: static int getwords(char *line, char *words[], int maxwords,int maxlen)",
          "386:   line[maxlen-1] = 0;",
          "390:   while(1)",
          "392:     while(isspace(*p)) p++;",
          "393:     if(*p == '\\0') return nwords;",
          "395:     while(!isspace(*p) && *p != '\\0') p++;",
          "396:     if(*p == '\\0') return nwords;",
          "398:     if(nwords >= maxwords) return nwords;",
          "402: static ushort saneSonyCameraInfo(uchar a, uchar b, uchar c, uchar d, uchar e, uchar f){",
          "403:  if ((a >> 4) > 9) return 0;",
          "404:  else if ((a & 0x0f) > 9) return 0;",
          "405:  else if ((b >> 4) > 9) return 0;",
          "406:  else if ((b & 0x0f) > 9) return 0;",
          "407:  else if ((c >> 4) > 9) return 0;",
          "408:  else if ((c & 0x0f) > 9) return 0;",
          "409:  else if ((d >> 4) > 9) return 0;",
          "410:  else if ((d & 0x0f) > 9) return 0;",
          "411:  else if ((e >> 4) > 9) return 0;",
          "412:  else if ((e & 0x0f) > 9) return 0;",
          "413:  else if ((f >> 4) > 9) return 0;",
          "414:  else if ((f & 0x0f) > 9) return 0;",
          "415: return 1;",
          "418: static ushort bcd2dec(uchar data){",
          "419:  if ((data >> 4) > 9) return 0;",
          "420:  else if ((data & 0x0f) > 9) return 0;",
          "421:  else return (data >> 4) * 10 + (data & 0x0f);",
          "424: static uchar SonySubstitution[257] = \"\\x00\\x01\\x32\\xb1\\x0a\\x0e\\x87\\x28\\x02\\xcc\\xca\\xad\\x1b\\xdc\\x08\\xed\\x64\\x86\\xf0\\x4f\\x8c\\x6c\\xb8\\xcb\\x69\\xc4\\x2c\\x03\\x97\\xb6\\x93\\x7c\\x14\\xf3\\xe2\\x3e\\x30\\x8e\\xd7\\x60\\x1c\\xa1\\xab\\x37\\xec\\x75\\xbe\\x23\\x15\\x6a\\x59\\x3f\\xd0\\xb9\\x96\\xb5\\x50\\x27\\x88\\xe3\\x81\\x94\\xe0\\xc0\\x04\\x5c\\xc6\\xe8\\x5f\\x4b\\x70\\x38\\x9f\\x82\\x80\\x51\\x2b\\xc5\\x45\\x49\\x9b\\x21\\x52\\x53\\x54\\x85\\x0b\\x5d\\x61\\xda\\x7b\\x55\\x26\\x24\\x07\\x6e\\x36\\x5b\\x47\\xb7\\xd9\\x4a\\xa2\\xdf\\xbf\\x12\\x25\\xbc\\x1e\\x7f\\x56\\xea\\x10\\xe6\\xcf\\x67\\x4d\\x3c\\x91\\x83\\xe1\\x31\\xb3\\x6f\\xf4\\x05\\x8a\\x46\\xc8\\x18\\x76\\x68\\xbd\\xac\\x92\\x2a\\x13\\xe9\\x0f\\xa3\\x7a\\xdb\\x3d\\xd4\\xe7\\x3a\\x1a\\x57\\xaf\\x20\\x42\\xb2\\x9e\\xc3\\x8b\\xf2\\xd5\\xd3\\xa4\\x7e\\x1f\\x98\\x9c\\xee\\x74\\xa5\\xa6\\xa7\\xd8\\x5e\\xb0\\xb4\\x34\\xce\\xa8\\x79\\x77\\x5a\\xc1\\x89\\xae\\x9a\\x11\\x33\\x9d\\xf5\\x39\\x19\\x65\\x78\\x16\\x71\\xd2\\xa9\\x44\\x63\\x40\\x29\\xba\\xa0\\x8f\\xe4\\xd6\\x3b\\x84\\x0d\\xc2\\x4e\\x58\\xdd\\x99\\x22\\x6b\\xc9\\xbb\\x17\\x06\\xe5\\x7d\\x66\\x43\\x62\\xf6\\xcd\\x35\\x90\\x2e\\x41\\x8d\\x6d\\xaa\\x09\\x73\\x95\\x0c\\xf1\\x1d\\xde\\x4c\\x2f\\x2d\\xf7\\xd1\\x72\\xeb\\xef\\x48\\xc7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\";",
          "426: ushort CLASS sget2Rev(uchar *s) // specific to some Canon Makernotes fields, where they have endian in reverse",
          "429:   return s[0] | s[1] << 8;",
          "431:   return s[0] << 8 | s[1];",
          "437:   uchar str[2] = { 0xff,0xff };",
          "438:   fread (str, 1, 2, ifp);",
          "442: unsigned CLASS sget4 (uchar *s)",
          "",
          "[Added Lines]",
          "345: #define strbuflen(buf) strnlen(buf, sizeof(buf) - 1)",
          "349: void CLASS merror(void *ptr, const char *where)",
          "351:   if (ptr)",
          "352:     return;",
          "353:   fprintf(stderr, _(\"%s: Out of memory in %s\\n\"), ifname, where);",
          "354:   longjmp(failure, 1);",
          "359:   if (!data_error)",
          "360:   {",
          "361:     fprintf(stderr, \"%s: \", ifname);",
          "363:       fprintf(stderr, _(\"Unexpected end of file\\n\"));",
          "365:       fprintf(stderr, _(\"Corrupt data near 0x%llx\\n\"), (INT64)ftello(ifp));",
          "371: ushort CLASS sget2(uchar *s)",
          "380: #define CameraDNG 1",
          "381: #define AdobeDNG 2",
          "384: static int getwords(char *line, char *words[], int maxwords, int maxlen)",
          "386:   line[maxlen - 1] = 0;",
          "390:   while (1)",
          "392:     while (isspace(*p))",
          "393:       p++;",
          "394:     if (*p == '\\0')",
          "395:       return nwords;",
          "397:     while (!isspace(*p) && *p != '\\0')",
          "398:       p++;",
          "399:     if (*p == '\\0')",
          "400:       return nwords;",
          "402:     if (nwords >= maxwords)",
          "403:       return nwords;",
          "407: static ushort saneSonyCameraInfo(uchar a, uchar b, uchar c, uchar d, uchar e, uchar f)",
          "408: {",
          "409:   if ((a >> 4) > 9)",
          "410:     return 0;",
          "411:   else if ((a & 0x0f) > 9)",
          "412:     return 0;",
          "413:   else if ((b >> 4) > 9)",
          "414:     return 0;",
          "415:   else if ((b & 0x0f) > 9)",
          "416:     return 0;",
          "417:   else if ((c >> 4) > 9)",
          "418:     return 0;",
          "419:   else if ((c & 0x0f) > 9)",
          "420:     return 0;",
          "421:   else if ((d >> 4) > 9)",
          "422:     return 0;",
          "423:   else if ((d & 0x0f) > 9)",
          "424:     return 0;",
          "425:   else if ((e >> 4) > 9)",
          "426:     return 0;",
          "427:   else if ((e & 0x0f) > 9)",
          "428:     return 0;",
          "429:   else if ((f >> 4) > 9)",
          "430:     return 0;",
          "431:   else if ((f & 0x0f) > 9)",
          "432:     return 0;",
          "433:   return 1;",
          "436: static ushort bcd2dec(uchar data)",
          "437: {",
          "438:   if ((data >> 4) > 9)",
          "439:     return 0;",
          "440:   else if ((data & 0x0f) > 9)",
          "441:     return 0;",
          "442:   else",
          "443:     return (data >> 4) * 10 + (data & 0x0f);",
          "446: static uchar SonySubstitution[257] =",
          "447:     \"\\x00\\x01\\x32\\xb1\\x0a\\x0e\\x87\\x28\\x02\\xcc\\xca\\xad\\x1b\\xdc\\x08\\xed\\x64\\x86\\xf0\\x4f\\x8c\\x6c\\xb8\\xcb\\x69\\xc4\\x2c\\x03\"",
          "448:     \"\\x97\\xb6\\x93\\x7c\\x14\\xf3\\xe2\\x3e\\x30\\x8e\\xd7\\x60\\x1c\\xa1\\xab\\x37\\xec\\x75\\xbe\\x23\\x15\\x6a\\x59\\x3f\\xd0\\xb9\\x96\\xb5\"",
          "449:     \"\\x50\\x27\\x88\\xe3\\x81\\x94\\xe0\\xc0\\x04\\x5c\\xc6\\xe8\\x5f\\x4b\\x70\\x38\\x9f\\x82\\x80\\x51\\x2b\\xc5\\x45\\x49\\x9b\\x21\\x52\\x53\"",
          "450:     \"\\x54\\x85\\x0b\\x5d\\x61\\xda\\x7b\\x55\\x26\\x24\\x07\\x6e\\x36\\x5b\\x47\\xb7\\xd9\\x4a\\xa2\\xdf\\xbf\\x12\\x25\\xbc\\x1e\\x7f\\x56\\xea\"",
          "451:     \"\\x10\\xe6\\xcf\\x67\\x4d\\x3c\\x91\\x83\\xe1\\x31\\xb3\\x6f\\xf4\\x05\\x8a\\x46\\xc8\\x18\\x76\\x68\\xbd\\xac\\x92\\x2a\\x13\\xe9\\x0f\\xa3\"",
          "452:     \"\\x7a\\xdb\\x3d\\xd4\\xe7\\x3a\\x1a\\x57\\xaf\\x20\\x42\\xb2\\x9e\\xc3\\x8b\\xf2\\xd5\\xd3\\xa4\\x7e\\x1f\\x98\\x9c\\xee\\x74\\xa5\\xa6\\xa7\"",
          "453:     \"\\xd8\\x5e\\xb0\\xb4\\x34\\xce\\xa8\\x79\\x77\\x5a\\xc1\\x89\\xae\\x9a\\x11\\x33\\x9d\\xf5\\x39\\x19\\x65\\x78\\x16\\x71\\xd2\\xa9\\x44\\x63\"",
          "454:     \"\\x40\\x29\\xba\\xa0\\x8f\\xe4\\xd6\\x3b\\x84\\x0d\\xc2\\x4e\\x58\\xdd\\x99\\x22\\x6b\\xc9\\xbb\\x17\\x06\\xe5\\x7d\\x66\\x43\\x62\\xf6\\xcd\"",
          "455:     \"\\x35\\x90\\x2e\\x41\\x8d\\x6d\\xaa\\x09\\x73\\x95\\x0c\\xf1\\x1d\\xde\\x4c\\x2f\\x2d\\xf7\\xd1\\x72\\xeb\\xef\\x48\\xc7\\xf8\\xf9\\xfa\\xfb\"",
          "456:     \"\\xfc\\xfd\\xfe\\xff\";",
          "458: ushort CLASS sget2Rev(uchar *s) // specific to some Canon Makernotes fields, where they have endian in reverse",
          "461:     return s[0] | s[1] << 8;",
          "463:     return s[0] << 8 | s[1];",
          "469:   uchar str[2] = {0xff, 0xff};",
          "470:   fread(str, 1, 2, ifp);",
          "474: unsigned CLASS sget4(uchar *s)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "451: unsigned CLASS get4()",
          "452: {",
          "455:   return sget4(str);",
          "456: }",
          "464: {",
          "466:   u.i = i;",
          "467:   return u.f;",
          "468: }",
          "471: {",
          "473:   int i, rev;",
          "495:   }",
          "496: }",
          "499: {",
          "501:   if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))",
          "503: }",
          "506: {",
          "507:   float **A, *b, *c, *d, *x, *y;",
          "508:   int i, j;",
          "517:     x[i] = x_[i] / 65535.0;",
          "518:     y[i] = y_[i] / 65535.0;",
          "519:   }",
          "523:   }",
          "529:     }",
          "531:   }",
          "536:   }",
          "538:     float acc = 0;",
          "542:   }",
          "544:     float x_out = (float)(i / 65535.0);",
          "545:     float y_out = 0;",
          "552:       }",
          "553:     }",
          "556:   }",
          "558: }",
          "561: {",
          "562:   static const short mul[4][5] = {",
          "567:   int lo, hi, i;",
          "574:   if (lo != hi)",
          "578: }",
          "582: {",
          "586:     if (ratio[1] < -104)",
          "592:     if (ratio[1] < -50)",
          "594:     if (ratio[1] > 307)",
          "596:   }",
          "602:   miss = target - ratio[0];",
          "606:   ratio[0] = target - miss;",
          "607:   return 1;",
          "608: }",
          "610: void CLASS canon_600_auto_wb()",
          "611: {",
          "613:   int test[8], total[2][8], ratio[2][2], stat[2];",
          "616:   i = canon_ev + 0.5;",
          "642:       count[st]++;",
          "644:     }",
          "649:   }",
          "650: }",
          "652: void CLASS canon_600_coeff()",
          "653: {",
          "662:   float mc, yc;",
          "664:   mc = pre_mul[1] / pre_mul[2];",
          "665:   yc = pre_mul[3] / pre_mul[2];",
          "674: }",
          "676: void CLASS canon_600_load_raw()",
          "677: {",
          "679:   ushort *pix;",
          "680:   int irow, row;",
          "683: #ifdef LIBRAW_LIBRARY_BUILD",
          "684:     checkCancel();",
          "685: #endif",
          "690:       pix[1] = (dp[2] << 2) + (dp[1] >> 4 & 3);",
          "691:       pix[2] = (dp[3] << 2) + (dp[1] >> 2 & 3);",
          "694:       pix[5] = (dp[6] << 2) + (dp[9] >> 2 & 3);",
          "695:       pix[6] = (dp[7] << 2) + (dp[9] >> 4 & 3);",
          "697:     }",
          "699:   }",
          "700: }",
          "702: void CLASS canon_600_correct()",
          "703: {",
          "704:   int row, col, val;",
          "710: #ifdef LIBRAW_LIBRARY_BUILD",
          "711:     checkCancel();",
          "712: #endif",
          "715:       val = val * mul[row & 3][col & 1] >> 9;",
          "718:     }",
          "719:   canon_600_fixed_wb(1311);",
          "720:   canon_600_auto_wb();",
          "721:   canon_600_coeff();",
          "",
          "[Removed Lines]",
          "453:   uchar str[4] = { 0xff,0xff,0xff,0xff };",
          "454:   fread (str, 1, 4, ifp);",
          "458: unsigned CLASS getint (int type)",
          "459: {",
          "460:   return type == 3 ? get2() : get4();",
          "461: }",
          "463: float CLASS int_to_float (int i)",
          "465:   union { int i; float f; } u;",
          "470: double CLASS getreal (int type)",
          "472:   union { char c[8]; double d; } u,v;",
          "475:   switch (type) {",
          "476:     case 3: return (unsigned short) get2();",
          "477:     case 4: return (unsigned int) get4();",
          "478:     case 5:",
          "479:       u.d = (unsigned int) get4();",
          "480:       v.d = (unsigned int)get4();",
          "481:       return u.d / (v.d ? v.d : 1);",
          "482:     case 8: return (signed short) get2();",
          "483:     case 9: return (signed int) get4();",
          "484:     case 10:",
          "485:       u.d = (signed int) get4();",
          "486:       v.d = (signed int)get4();",
          "487:       return u.d / (v.d?v.d:1);",
          "488:     case 11: return int_to_float (get4());",
          "489:     case 12:",
          "490:       rev = 7 * ((order == 0x4949) == (ntohs(0x1234) == 0x1234));",
          "491:       for (i=0; i < 8; i++)",
          "492:  u.c[i ^ rev] = fgetc(ifp);",
          "493:       return u.d;",
          "494:     default: return fgetc(ifp);",
          "498: void CLASS read_shorts (ushort *pixel, int count)",
          "500:   if (fread (pixel, 2, count, ifp) < count) derror();",
          "502:     swab ((char*)pixel, (char*)pixel, count*2);",
          "505: void CLASS cubic_spline (const int *x_, const int *y_, const int len)",
          "510:   A = (float **) calloc (((2*len + 4)*sizeof **A + sizeof *A), 2*len);",
          "511:   if (!A) return;",
          "512:   A[0] = (float *) (A + 2*len);",
          "513:   for (i = 1; i < 2*len; i++)",
          "514:     A[i] = A[0] + 2*len*i;",
          "515:   y = len + (x = i + (d = i + (c = i + (b = A[0] + i*i))));",
          "516:   for (i = 0; i < len; i++) {",
          "520:   for (i = len-1; i > 0; i--) {",
          "521:     b[i] = (y[i] - y[i-1]) / (x[i] - x[i-1]);",
          "522:     d[i-1] = x[i] - x[i-1];",
          "524:   for (i = 1; i < len-1; i++) {",
          "525:     A[i][i] = 2 * (d[i-1] + d[i]);",
          "526:     if (i > 1) {",
          "527:       A[i][i-1] = d[i-1];",
          "528:       A[i-1][i] = d[i-1];",
          "530:     A[i][len-1] = 6 * (b[i+1] - b[i]);",
          "532:   for(i = 1; i < len-2; i++) {",
          "533:     float v = A[i+1][i] / A[i][i];",
          "534:     for(j = 1; j <= len-1; j++)",
          "535:       A[i+1][j] -= v * A[i][j];",
          "537:   for(i = len-2; i > 0; i--) {",
          "539:     for(j = i; j <= len-2; j++)",
          "540:       acc += A[i][j]*c[j];",
          "541:     c[i] = (A[i][len-1] - acc) / A[i][i];",
          "543:   for (i = 0; i < 0x10000; i++) {",
          "546:     for (j = 0; j < len-1; j++) {",
          "547:       if (x[j] <= x_out && x_out <= x[j+1]) {",
          "548:  float v = x_out - x[j];",
          "549:  y_out = y[j] +",
          "550:    ((y[j+1] - y[j]) / d[j] - (2 * d[j] * c[j] + c[j+1] * d[j])/6) * v",
          "551:     + (c[j] * 0.5) * v*v + ((c[j+1] - c[j]) / (6 * d[j])) * v*v*v;",
          "554:     curve[i] = y_out < 0.0 ? 0 : (y_out >= 1.0 ? 65535 :",
          "555:   (ushort)(y_out * 65535.0 + 0.5));",
          "557:   free (A);",
          "560: void CLASS canon_600_fixed_wb (int temp)",
          "563:     {  667, 358,397,565,452 },",
          "564:     {  731, 390,367,499,517 },",
          "565:     { 1119, 396,348,448,537 },",
          "566:     { 1399, 485,431,508,688 } };",
          "568:   float frac=0;",
          "570:   for (lo=4; --lo; )",
          "571:     if (*mul[lo] <= temp) break;",
          "572:   for (hi=0; hi < 3; hi++)",
          "573:     if (*mul[hi] >= temp) break;",
          "575:     frac = (float) (temp - *mul[lo]) / (*mul[hi] - *mul[lo]);",
          "576:   for (i=1; i < 5; i++)",
          "577:     pre_mul[i-1] = 1 / (frac * mul[hi][i] + (1-frac) * mul[lo][i]);",
          "581: int CLASS canon_600_color (int ratio[2], int mar)",
          "583:   int clipped=0, target, miss;",
          "585:   if (flash_used) {",
          "587:       { ratio[1] = -104; clipped = 1; }",
          "588:     if (ratio[1] >   12)",
          "589:       { ratio[1] =   12; clipped = 1; }",
          "590:   } else {",
          "591:     if (ratio[1] < -264 || ratio[1] > 461) return 2;",
          "593:       { ratio[1] = -50; clipped = 1; }",
          "595:       { ratio[1] = 307; clipped = 1; }",
          "597:   target = flash_used || ratio[1] < 197",
          "598:  ? -38 - (398 * ratio[1] >> 10)",
          "599:  : -123 + (48 * ratio[1] >> 10);",
          "600:   if (target - mar <= ratio[0] &&",
          "601:       target + 20  >= ratio[0] && !clipped) return 0;",
          "603:   if (abs(miss) >= mar*4) return 2;",
          "604:   if (miss < -20) miss = -20;",
          "605:   if (miss > mar) miss = mar;",
          "612:   int mar, row, col, i, j, st, count[] = { 0,0 };",
          "615:   memset (&total, 0, sizeof total);",
          "617:   if      (i < 10) mar = 150;",
          "618:   else if (i > 12) mar = 20;",
          "619:   else mar = 280 - 20 * i;",
          "620:   if (flash_used) mar = 80;",
          "621:   for (row=14; row < height-14; row+=4)",
          "622:     for (col=10; col < width; col+=2) {",
          "623:       for (i=0; i < 8; i++)",
          "624:  test[(i & 4) + FC(row+(i >> 1),col+(i & 1))] =",
          "625:       BAYER(row+(i >> 1),col+(i & 1));",
          "626:       for (i=0; i < 8; i++)",
          "627:  if (test[i] < 150 || test[i] > 1500) goto next;",
          "628:       for (i=0; i < 4; i++)",
          "629:  if (abs(test[i] - test[i+4]) > 50) goto next;",
          "630:       for (i=0; i < 2; i++) {",
          "631:  for (j=0; j < 4; j+=2)",
          "632:    ratio[i][j >> 1] = ((test[i*4+j+1]-test[i*4+j]) << 10) / test[i*4+j];",
          "633:  stat[i] = canon_600_color (ratio[i], mar);",
          "634:       }",
          "635:       if ((st = stat[0] | stat[1]) > 1) goto next;",
          "636:       for (i=0; i < 2; i++)",
          "637:  if (stat[i])",
          "638:    for (j=0; j < 2; j++)",
          "639:      test[i*4+j*2+1] = test[i*4+j*2] * (0x400 + ratio[i][j]) >> 10;",
          "640:       for (i=0; i < 8; i++)",
          "641:  total[st][i] += test[i];",
          "643: next: ;",
          "645:   if (count[0] | count[1]) {",
          "646:     st = count[0]*200 < count[1];",
          "647:     for (i=0; i < 4; i++)",
          "648:       pre_mul[i] = 1.0 / (total[st][i] + total[st][i+4]);",
          "654:   static const short table[6][12] = {",
          "655:     { -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },",
          "656:     { -1203,1715,-1136,1648, 1388,-876,267,245,  -1641,2153,3921,-3409 },",
          "657:     { -615,1127,-1563,2075,  1437,-925,509,3,     -756,1268,2519,-2007 },",
          "658:     { -190,702,-1886,2398,   2153,-1641,763,-251, -452,964,3040,-2528  },",
          "659:     { -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },",
          "660:     { -807,1319,-1785,2297,  1388,-876,769,-257,  -230,742,2067,-1555  } };",
          "661:   int t=0, i, c;",
          "666:   if (mc > 1 && mc <= 1.28 && yc < 0.8789) t=1;",
          "667:   if (mc > 1.28 && mc <= 2) {",
          "668:     if  (yc < 0.8789) t=3;",
          "669:     else if (yc <= 2) t=4;",
          "670:   }",
          "671:   if (flash_used) t=5;",
          "672:   for (raw_color = i=0; i < 3; i++)",
          "673:     FORCC rgb_cam[i][c] = table[t][i*4 + c] / 1024.0;",
          "678:   uchar  data[1120], *dp;",
          "682:   for (irow=row=0; irow < height; irow++) {",
          "686:     if (fread (data, 1, 1120, ifp) < 1120) derror();",
          "687:     pix = raw_image + row*raw_width;",
          "688:     for (dp=data; dp < data+1120;  dp+=10, pix+=8) {",
          "689:       pix[0] = (dp[0] << 2) + (dp[1] >> 6    );",
          "692:       pix[3] = (dp[4] << 2) + (dp[1]      & 3);",
          "693:       pix[4] = (dp[5] << 2) + (dp[9]      & 3);",
          "696:       pix[7] = (dp[8] << 2) + (dp[9] >> 6    );",
          "698:     if ((row+=2) > height) row = 1;",
          "705:   static const short mul[4][2] =",
          "706:   { { 1141,1145 }, { 1128,1109 }, { 1178,1149 }, { 1128,1109 } };",
          "708:   for (row=0; row < height; row++)",
          "709:     {",
          "713:     for (col=0; col < width; col++) {",
          "714:       if ((val = BAYER(row,col) - black) < 0) val = 0;",
          "716:       BAYER(row,col) = val;",
          "717:     }",
          "",
          "[Added Lines]",
          "485:   uchar str[4] = {0xff, 0xff, 0xff, 0xff};",
          "486:   fread(str, 1, 4, ifp);",
          "490: unsigned CLASS getint(int type) { return type == 3 ? get2() : get4(); }",
          "492: float CLASS int_to_float(int i)",
          "494:   union {",
          "495:     int i;",
          "496:     float f;",
          "497:   } u;",
          "502: double CLASS getreal(int type)",
          "504:   union {",
          "505:     char c[8];",
          "506:     double d;",
          "507:   } u, v;",
          "510:   switch (type)",
          "511:   {",
          "512:   case 3:",
          "513:     return (unsigned short)get2();",
          "514:   case 4:",
          "515:     return (unsigned int)get4();",
          "516:   case 5:",
          "517:     u.d = (unsigned int)get4();",
          "518:     v.d = (unsigned int)get4();",
          "519:     return u.d / (v.d ? v.d : 1);",
          "520:   case 8:",
          "521:     return (signed short)get2();",
          "522:   case 9:",
          "523:     return (signed int)get4();",
          "524:   case 10:",
          "525:     u.d = (signed int)get4();",
          "526:     v.d = (signed int)get4();",
          "527:     return u.d / (v.d ? v.d : 1);",
          "528:   case 11:",
          "529:     return int_to_float(get4());",
          "530:   case 12:",
          "531:     rev = 7 * ((order == 0x4949) == (ntohs(0x1234) == 0x1234));",
          "532:     for (i = 0; i < 8; i++)",
          "533:       u.c[i ^ rev] = fgetc(ifp);",
          "534:     return u.d;",
          "535:   default:",
          "536:     return fgetc(ifp);",
          "540: void CLASS read_shorts(ushort *pixel, int count)",
          "542:   if (fread(pixel, 2, count, ifp) < count)",
          "543:     derror();",
          "545:     swab((char *)pixel, (char *)pixel, count * 2);",
          "548: void CLASS cubic_spline(const int *x_, const int *y_, const int len)",
          "553:   A = (float **)calloc(((2 * len + 4) * sizeof **A + sizeof *A), 2 * len);",
          "554:   if (!A)",
          "555:     return;",
          "556:   A[0] = (float *)(A + 2 * len);",
          "557:   for (i = 1; i < 2 * len; i++)",
          "558:     A[i] = A[0] + 2 * len * i;",
          "559:   y = len + (x = i + (d = i + (c = i + (b = A[0] + i * i))));",
          "560:   for (i = 0; i < len; i++)",
          "561:   {",
          "565:   for (i = len - 1; i > 0; i--)",
          "566:   {",
          "567:     b[i] = (y[i] - y[i - 1]) / (x[i] - x[i - 1]);",
          "568:     d[i - 1] = x[i] - x[i - 1];",
          "570:   for (i = 1; i < len - 1; i++)",
          "571:   {",
          "572:     A[i][i] = 2 * (d[i - 1] + d[i]);",
          "573:     if (i > 1)",
          "574:     {",
          "575:       A[i][i - 1] = d[i - 1];",
          "576:       A[i - 1][i] = d[i - 1];",
          "578:     A[i][len - 1] = 6 * (b[i + 1] - b[i]);",
          "580:   for (i = 1; i < len - 2; i++)",
          "581:   {",
          "582:     float v = A[i + 1][i] / A[i][i];",
          "583:     for (j = 1; j <= len - 1; j++)",
          "584:       A[i + 1][j] -= v * A[i][j];",
          "586:   for (i = len - 2; i > 0; i--)",
          "587:   {",
          "589:     for (j = i; j <= len - 2; j++)",
          "590:       acc += A[i][j] * c[j];",
          "591:     c[i] = (A[i][len - 1] - acc) / A[i][i];",
          "593:   for (i = 0; i < 0x10000; i++)",
          "594:   {",
          "597:     for (j = 0; j < len - 1; j++)",
          "598:     {",
          "599:       if (x[j] <= x_out && x_out <= x[j + 1])",
          "600:       {",
          "601:         float v = x_out - x[j];",
          "602:         y_out = y[j] + ((y[j + 1] - y[j]) / d[j] - (2 * d[j] * c[j] + c[j + 1] * d[j]) / 6) * v + (c[j] * 0.5) * v * v +",
          "603:                 ((c[j + 1] - c[j]) / (6 * d[j])) * v * v * v;",
          "606:     curve[i] = y_out < 0.0 ? 0 : (y_out >= 1.0 ? 65535 : (ushort)(y_out * 65535.0 + 0.5));",
          "608:   free(A);",
          "611: void CLASS canon_600_fixed_wb(int temp)",
          "614:       {667, 358, 397, 565, 452}, {731, 390, 367, 499, 517}, {1119, 396, 348, 448, 537}, {1399, 485, 431, 508, 688}};",
          "616:   float frac = 0;",
          "618:   for (lo = 4; --lo;)",
          "619:     if (*mul[lo] <= temp)",
          "620:       break;",
          "621:   for (hi = 0; hi < 3; hi++)",
          "622:     if (*mul[hi] >= temp)",
          "623:       break;",
          "625:     frac = (float)(temp - *mul[lo]) / (*mul[hi] - *mul[lo]);",
          "626:   for (i = 1; i < 5; i++)",
          "627:     pre_mul[i - 1] = 1 / (frac * mul[hi][i] + (1 - frac) * mul[lo][i]);",
          "631: int CLASS canon_600_color(int ratio[2], int mar)",
          "633:   int clipped = 0, target, miss;",
          "635:   if (flash_used)",
          "636:   {",
          "638:     {",
          "639:       ratio[1] = -104;",
          "640:       clipped = 1;",
          "641:     }",
          "642:     if (ratio[1] > 12)",
          "643:     {",
          "644:       ratio[1] = 12;",
          "645:       clipped = 1;",
          "646:     }",
          "647:   }",
          "648:   else",
          "649:   {",
          "650:     if (ratio[1] < -264 || ratio[1] > 461)",
          "651:       return 2;",
          "653:     {",
          "654:       ratio[1] = -50;",
          "655:       clipped = 1;",
          "656:     }",
          "658:     {",
          "659:       ratio[1] = 307;",
          "660:       clipped = 1;",
          "661:     }",
          "663:   target = flash_used || ratio[1] < 197 ? -38 - (398 * ratio[1] >> 10) : -123 + (48 * ratio[1] >> 10);",
          "664:   if (target - mar <= ratio[0] && target + 20 >= ratio[0] && !clipped)",
          "665:     return 0;",
          "667:   if (abs(miss) >= mar * 4)",
          "668:     return 2;",
          "669:   if (miss < -20)",
          "670:     miss = -20;",
          "671:   if (miss > mar)",
          "672:     miss = mar;",
          "679:   int mar, row, col, i, j, st, count[] = {0, 0};",
          "682:   memset(&total, 0, sizeof total);",
          "684:   if (i < 10)",
          "685:     mar = 150;",
          "686:   else if (i > 12)",
          "687:     mar = 20;",
          "688:   else",
          "689:     mar = 280 - 20 * i;",
          "690:   if (flash_used)",
          "691:     mar = 80;",
          "692:   for (row = 14; row < height - 14; row += 4)",
          "693:     for (col = 10; col < width; col += 2)",
          "694:     {",
          "695:       for (i = 0; i < 8; i++)",
          "696:         test[(i & 4) + FC(row + (i >> 1), col + (i & 1))] = BAYER(row + (i >> 1), col + (i & 1));",
          "697:       for (i = 0; i < 8; i++)",
          "698:         if (test[i] < 150 || test[i] > 1500)",
          "699:           goto next;",
          "700:       for (i = 0; i < 4; i++)",
          "701:         if (abs(test[i] - test[i + 4]) > 50)",
          "702:           goto next;",
          "703:       for (i = 0; i < 2; i++)",
          "704:       {",
          "705:         for (j = 0; j < 4; j += 2)",
          "706:           ratio[i][j >> 1] = ((test[i * 4 + j + 1] - test[i * 4 + j]) << 10) / test[i * 4 + j];",
          "707:         stat[i] = canon_600_color(ratio[i], mar);",
          "708:       }",
          "709:       if ((st = stat[0] | stat[1]) > 1)",
          "710:         goto next;",
          "711:       for (i = 0; i < 2; i++)",
          "712:         if (stat[i])",
          "713:           for (j = 0; j < 2; j++)",
          "714:             test[i * 4 + j * 2 + 1] = test[i * 4 + j * 2] * (0x400 + ratio[i][j]) >> 10;",
          "715:       for (i = 0; i < 8; i++)",
          "716:         total[st][i] += test[i];",
          "718:     next:;",
          "720:   if (count[0] | count[1])",
          "721:   {",
          "722:     st = count[0] * 200 < count[1];",
          "723:     for (i = 0; i < 4; i++)",
          "724:       pre_mul[i] = 1.0 / (total[st][i] + total[st][i + 4]);",
          "730:   static const short table[6][12] = {{-190, 702, -1878, 2390, 1861, -1349, 905, -393, -432, 944, 2617, -2105},",
          "731:                                      {-1203, 1715, -1136, 1648, 1388, -876, 267, 245, -1641, 2153, 3921, -3409},",
          "732:                                      {-615, 1127, -1563, 2075, 1437, -925, 509, 3, -756, 1268, 2519, -2007},",
          "733:                                      {-190, 702, -1886, 2398, 2153, -1641, 763, -251, -452, 964, 3040, -2528},",
          "734:                                      {-190, 702, -1878, 2390, 1861, -1349, 905, -393, -432, 944, 2617, -2105},",
          "735:                                      {-807, 1319, -1785, 2297, 1388, -876, 769, -257, -230, 742, 2067, -1555}};",
          "736:   int t = 0, i, c;",
          "741:   if (mc > 1 && mc <= 1.28 && yc < 0.8789)",
          "742:     t = 1;",
          "743:   if (mc > 1.28 && mc <= 2)",
          "744:   {",
          "745:     if (yc < 0.8789)",
          "746:       t = 3;",
          "747:     else if (yc <= 2)",
          "748:       t = 4;",
          "749:   }",
          "750:   if (flash_used)",
          "751:     t = 5;",
          "752:   for (raw_color = i = 0; i < 3; i++)",
          "753:     FORCC rgb_cam[i][c] = table[t][i * 4 + c] / 1024.0;",
          "758:   uchar data[1120], *dp;",
          "762:   for (irow = row = 0; irow < height; irow++)",
          "763:   {",
          "767:     if (fread(data, 1, 1120, ifp) < 1120)",
          "768:       derror();",
          "769:     pix = raw_image + row * raw_width;",
          "770:     for (dp = data; dp < data + 1120; dp += 10, pix += 8)",
          "771:     {",
          "772:       pix[0] = (dp[0] << 2) + (dp[1] >> 6);",
          "775:       pix[3] = (dp[4] << 2) + (dp[1] & 3);",
          "776:       pix[4] = (dp[5] << 2) + (dp[9] & 3);",
          "779:       pix[7] = (dp[8] << 2) + (dp[9] >> 6);",
          "781:     if ((row += 2) > height)",
          "782:       row = 1;",
          "789:   static const short mul[4][2] = {{1141, 1145}, {1128, 1109}, {1178, 1149}, {1128, 1109}};",
          "791:   for (row = 0; row < height; row++)",
          "792:   {",
          "796:     for (col = 0; col < width; col++)",
          "797:     {",
          "798:       if ((val = BAYER(row, col) - black) < 0)",
          "799:         val = 0;",
          "801:       BAYER(row, col) = val;",
          "803:   }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "727: {",
          "728:   unsigned row;",
          "733:   }",
          "734:   return 0;",
          "735: }",
          "738: {",
          "739: #ifdef LIBRAW_NOTHREADS",
          "742: #else",
          "743: #define bitbuf tls->getbits.bitbuf",
          "746: #endif",
          "747:   unsigned c;",
          "750:   if (nbits < 0)",
          "751:     return bitbuf = vbits = reset = 0;",
          "756:     vbits += 8;",
          "757:   }",
          "760:     vbits -= huff[c] >> 8;",
          "763:     vbits -= nbits;",
          "765:   return c;",
          "766: #ifndef LIBRAW_NOTHREADS",
          "767: #undef bitbuf",
          "",
          "[Removed Lines]",
          "730:   for (row=0; row < 100; row++) {",
          "731:     fseek (ifp, row*3340 + 3284, SEEK_SET);",
          "732:     if (getc(ifp) > 15) return 1;",
          "737: unsigned CLASS getbithuff (int nbits, ushort *huff)",
          "740:   static unsigned bitbuf=0;",
          "741:   static int vbits=0, reset=0;",
          "744: #define vbits  tls->getbits.vbits",
          "745: #define reset  tls->getbits.reset",
          "749:   if (nbits > 25) return 0;",
          "752:   if (nbits == 0 || vbits < 0) return 0;",
          "753:   while (!reset && vbits < nbits && (c = fgetc(ifp)) != EOF &&",
          "754:     !(reset = zero_after_ff && c == 0xff && fgetc(ifp))) {",
          "755:     bitbuf = (bitbuf << 8) + (uchar) c;",
          "758:   c = bitbuf << (32-vbits) >> (32-nbits);",
          "759:   if (huff) {",
          "761:     c = (uchar) huff[c];",
          "762:   } else",
          "764:   if (vbits < 0) derror();",
          "",
          "[Added Lines]",
          "815:   for (row = 0; row < 100; row++)",
          "816:   {",
          "817:     fseek(ifp, row * 3340 + 3284, SEEK_SET);",
          "818:     if (getc(ifp) > 15)",
          "819:       return 1;",
          "824: unsigned CLASS getbithuff(int nbits, ushort *huff)",
          "827:   static unsigned bitbuf = 0;",
          "828:   static int vbits = 0, reset = 0;",
          "831: #define vbits tls->getbits.vbits",
          "832: #define reset tls->getbits.reset",
          "836:   if (nbits > 25)",
          "837:     return 0;",
          "840:   if (nbits == 0 || vbits < 0)",
          "841:     return 0;",
          "842:   while (!reset && vbits < nbits && (c = fgetc(ifp)) != EOF && !(reset = zero_after_ff && c == 0xff && fgetc(ifp)))",
          "843:   {",
          "844:     bitbuf = (bitbuf << 8) + (uchar)c;",
          "847:   c = bitbuf << (32 - vbits) >> (32 - nbits);",
          "848:   if (huff)",
          "849:   {",
          "851:     c = (uchar)huff[c];",
          "852:   }",
          "853:   else",
          "855:   if (vbits < 0)",
          "856:     derror();",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "770: #endif",
          "771: }",
          "777:    Construct a decode tree according the specification in *source.",
          "",
          "[Removed Lines]",
          "773: #define getbits(n) getbithuff(n,0)",
          "774: #define gethuff(h) getbithuff(*h,h+1)",
          "",
          "[Added Lines]",
          "865: #define getbits(n) getbithuff(n, 0)",
          "866: #define gethuff(h) getbithuff(*h, h + 1)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "786:    then the code is",
          "803: {",
          "804:   int max, len, h, i, j;",
          "805:   const uchar *count;",
          "806:   ushort *huff;",
          "808:   count = (*source += 16) - 17;",
          "812:   huff[0] = max;",
          "818:   return huff;",
          "819: }",
          "827: {",
          "828:   static const uchar first_tree[3][29] = {",
          "835:   };",
          "836:   static const uchar second_tree[3][180] = {",
          "886: }",
          "",
          "[Removed Lines]",
          "788:  00  0x04",
          "789:  010  0x03",
          "790:  011  0x05",
          "791:  100  0x06",
          "792:  101  0x02",
          "793:  1100  0x07",
          "794:  1101  0x01",
          "795:  11100  0x08",
          "796:  11101  0x09",
          "797:  11110  0x00",
          "798:  111110  0x0a",
          "799:  1111110  0x0b",
          "800:  1111111  0xff",
          "802: ushort * CLASS make_decoder_ref (const uchar **source)",
          "809:   for (max=16; max && !count[max]; max--);",
          "810:   huff = (ushort *) calloc (1 + (1 << max), sizeof *huff);",
          "811:   merror (huff, \"make_decoder()\");",
          "813:   for (h=len=1; len <= max; len++)",
          "814:     for (i=0; i < count[len]; i++, ++*source)",
          "815:       for (j=0; j < 1 << (max-len); j++)",
          "816:  if (h <= 1 << max)",
          "817:    huff[h++] = len << 8 | **source;",
          "821: ushort * CLASS make_decoder (const uchar *source)",
          "822: {",
          "823:   return make_decoder_ref (&source);",
          "824: }",
          "826: void CLASS crw_init_tables (unsigned table, ushort *huff[2])",
          "829:     { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,",
          "830:       0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },",
          "831:     { 0,2,2,3,1,1,1,1,2,0,0,0,0,0,0,0,",
          "832:       0x03,0x02,0x04,0x01,0x05,0x00,0x06,0x07,0x09,0x08,0x0a,0x0b,0xff  },",
          "833:     { 0,0,6,3,1,1,2,0,0,0,0,0,0,0,0,0,",
          "834:       0x06,0x05,0x07,0x04,0x08,0x03,0x09,0x02,0x00,0x0a,0x01,0x0b,0xff  },",
          "837:     { 0,2,2,2,1,4,2,1,2,5,1,1,0,0,0,139,",
          "838:       0x03,0x04,0x02,0x05,0x01,0x06,0x07,0x08,",
          "839:       0x12,0x13,0x11,0x14,0x09,0x15,0x22,0x00,0x21,0x16,0x0a,0xf0,",
          "840:       0x23,0x17,0x24,0x31,0x32,0x18,0x19,0x33,0x25,0x41,0x34,0x42,",
          "841:       0x35,0x51,0x36,0x37,0x38,0x29,0x79,0x26,0x1a,0x39,0x56,0x57,",
          "842:       0x28,0x27,0x52,0x55,0x58,0x43,0x76,0x59,0x77,0x54,0x61,0xf9,",
          "843:       0x71,0x78,0x75,0x96,0x97,0x49,0xb7,0x53,0xd7,0x74,0xb6,0x98,",
          "844:       0x47,0x48,0x95,0x69,0x99,0x91,0xfa,0xb8,0x68,0xb5,0xb9,0xd6,",
          "845:       0xf7,0xd8,0x67,0x46,0x45,0x94,0x89,0xf8,0x81,0xd5,0xf6,0xb4,",
          "846:       0x88,0xb1,0x2a,0x44,0x72,0xd9,0x87,0x66,0xd4,0xf5,0x3a,0xa7,",
          "847:       0x73,0xa9,0xa8,0x86,0x62,0xc7,0x65,0xc8,0xc9,0xa1,0xf4,0xd1,",
          "848:       0xe9,0x5a,0x92,0x85,0xa6,0xe7,0x93,0xe8,0xc1,0xc6,0x7a,0x64,",
          "849:       0xe1,0x4a,0x6a,0xe6,0xb3,0xf1,0xd3,0xa5,0x8a,0xb2,0x9a,0xba,",
          "850:       0x84,0xa4,0x63,0xe5,0xc5,0xf3,0xd2,0xc4,0x82,0xaa,0xda,0xe4,",
          "851:       0xf2,0xca,0x83,0xa3,0xa2,0xc3,0xea,0xc2,0xe2,0xe3,0xff,0xff  },",
          "852:     { 0,2,2,1,4,1,4,1,3,3,1,0,0,0,0,140,",
          "853:       0x02,0x03,0x01,0x04,0x05,0x12,0x11,0x06,",
          "854:       0x13,0x07,0x08,0x14,0x22,0x09,0x21,0x00,0x23,0x15,0x31,0x32,",
          "855:       0x0a,0x16,0xf0,0x24,0x33,0x41,0x42,0x19,0x17,0x25,0x18,0x51,",
          "856:       0x34,0x43,0x52,0x29,0x35,0x61,0x39,0x71,0x62,0x36,0x53,0x26,",
          "857:       0x38,0x1a,0x37,0x81,0x27,0x91,0x79,0x55,0x45,0x28,0x72,0x59,",
          "858:       0xa1,0xb1,0x44,0x69,0x54,0x58,0xd1,0xfa,0x57,0xe1,0xf1,0xb9,",
          "859:       0x49,0x47,0x63,0x6a,0xf9,0x56,0x46,0xa8,0x2a,0x4a,0x78,0x99,",
          "860:       0x3a,0x75,0x74,0x86,0x65,0xc1,0x76,0xb6,0x96,0xd6,0x89,0x85,",
          "861:       0xc9,0xf5,0x95,0xb4,0xc7,0xf7,0x8a,0x97,0xb8,0x73,0xb7,0xd8,",
          "862:       0xd9,0x87,0xa7,0x7a,0x48,0x82,0x84,0xea,0xf4,0xa6,0xc5,0x5a,",
          "863:       0x94,0xa4,0xc6,0x92,0xc3,0x68,0xb5,0xc8,0xe4,0xe5,0xe6,0xe9,",
          "864:       0xa2,0xa3,0xe3,0xc2,0x66,0x67,0x93,0xaa,0xd4,0xd5,0xe7,0xf8,",
          "865:       0x88,0x9a,0xd7,0x77,0xc4,0x64,0xe2,0x98,0xa5,0xca,0xda,0xe8,",
          "866:       0xf3,0xf6,0xa9,0xb2,0xb3,0xf2,0xd2,0x83,0xba,0xd3,0xff,0xff  },",
          "867:     { 0,0,6,2,1,3,3,2,5,1,2,2,8,10,0,117,",
          "868:       0x04,0x05,0x03,0x06,0x02,0x07,0x01,0x08,",
          "869:       0x09,0x12,0x13,0x14,0x11,0x15,0x0a,0x16,0x17,0xf0,0x00,0x22,",
          "870:       0x21,0x18,0x23,0x19,0x24,0x32,0x31,0x25,0x33,0x38,0x37,0x34,",
          "871:       0x35,0x36,0x39,0x79,0x57,0x58,0x59,0x28,0x56,0x78,0x27,0x41,",
          "872:       0x29,0x77,0x26,0x42,0x76,0x99,0x1a,0x55,0x98,0x97,0xf9,0x48,",
          "873:       0x54,0x96,0x89,0x47,0xb7,0x49,0xfa,0x75,0x68,0xb6,0x67,0x69,",
          "874:       0xb9,0xb8,0xd8,0x52,0xd7,0x88,0xb5,0x74,0x51,0x46,0xd9,0xf8,",
          "875:       0x3a,0xd6,0x87,0x45,0x7a,0x95,0xd5,0xf6,0x86,0xb4,0xa9,0x94,",
          "876:       0x53,0x2a,0xa8,0x43,0xf5,0xf7,0xd4,0x66,0xa7,0x5a,0x44,0x8a,",
          "877:       0xc9,0xe8,0xc8,0xe7,0x9a,0x6a,0x73,0x4a,0x61,0xc7,0xf4,0xc6,",
          "878:       0x65,0xe9,0x72,0xe6,0x71,0x91,0x93,0xa6,0xda,0x92,0x85,0x62,",
          "879:       0xf3,0xc5,0xb2,0xa4,0x84,0xba,0x64,0xa5,0xb3,0xd2,0x81,0xe5,",
          "880:       0xd3,0xaa,0xc4,0xca,0xf2,0xb1,0xe4,0xd1,0x83,0x63,0xea,0xc3,",
          "881:       0xe2,0x82,0xf1,0xa3,0xc2,0xa1,0xc1,0xe3,0xa2,0xe1,0xff,0xff  }",
          "882:   };",
          "883:   if (table > 2) table = 2;",
          "884:   huff[0] = make_decoder ( first_tree[table]);",
          "885:   huff[1] = make_decoder (second_tree[table]);",
          "",
          "[Added Lines]",
          "880:         00  0x04",
          "881:         010  0x03",
          "882:         011  0x05",
          "883:         100  0x06",
          "884:         101  0x02",
          "885:         1100  0x07",
          "886:         1101  0x01",
          "887:         11100  0x08",
          "888:         11101  0x09",
          "889:         11110  0x00",
          "890:         111110  0x0a",
          "891:         1111110  0x0b",
          "892:         1111111  0xff",
          "894: ushort *CLASS make_decoder_ref(const uchar **source)",
          "901:   for (max = 16; max && !count[max]; max--)",
          "902:     ;",
          "903:   huff = (ushort *)calloc(1 + (1 << max), sizeof *huff);",
          "904:   merror(huff, \"make_decoder()\");",
          "906:   for (h = len = 1; len <= max; len++)",
          "907:     for (i = 0; i < count[len]; i++, ++*source)",
          "908:       for (j = 0; j < 1 << (max - len); j++)",
          "909:         if (h <= 1 << max)",
          "910:           huff[h++] = len << 8 | **source;",
          "914: ushort *CLASS make_decoder(const uchar *source) { return make_decoder_ref(&source); }",
          "916: void CLASS crw_init_tables(unsigned table, ushort *huff[2])",
          "919:       {0, 1,    4,    2,    3,    1,    2,    0,    0,    0,    0,    0,    0,    0,   0,",
          "920:        0, 0x04, 0x03, 0x05, 0x06, 0x02, 0x07, 0x01, 0x08, 0x09, 0x00, 0x0a, 0x0b, 0xff},",
          "921:       {0, 2,    2,    3,    1,    1,    1,    1,    2,    0,    0,    0,    0,    0,   0,",
          "922:        0, 0x03, 0x02, 0x04, 0x01, 0x05, 0x00, 0x06, 0x07, 0x09, 0x08, 0x0a, 0x0b, 0xff},",
          "923:       {0, 0,    6,    3,    1,    1,    2,    0,    0,    0,    0,    0,    0,    0,   0,",
          "924:        0, 0x06, 0x05, 0x07, 0x04, 0x08, 0x03, 0x09, 0x02, 0x00, 0x0a, 0x01, 0x0b, 0xff},",
          "927:       {0,    2,    2,    2,    1,    4,    2,    1,    2,    5,    1,    1,    0,    0,    0,    139,  0x03, 0x04,",
          "928:        0x02, 0x05, 0x01, 0x06, 0x07, 0x08, 0x12, 0x13, 0x11, 0x14, 0x09, 0x15, 0x22, 0x00, 0x21, 0x16, 0x0a, 0xf0,",
          "929:        0x23, 0x17, 0x24, 0x31, 0x32, 0x18, 0x19, 0x33, 0x25, 0x41, 0x34, 0x42, 0x35, 0x51, 0x36, 0x37, 0x38, 0x29,",
          "930:        0x79, 0x26, 0x1a, 0x39, 0x56, 0x57, 0x28, 0x27, 0x52, 0x55, 0x58, 0x43, 0x76, 0x59, 0x77, 0x54, 0x61, 0xf9,",
          "931:        0x71, 0x78, 0x75, 0x96, 0x97, 0x49, 0xb7, 0x53, 0xd7, 0x74, 0xb6, 0x98, 0x47, 0x48, 0x95, 0x69, 0x99, 0x91,",
          "932:        0xfa, 0xb8, 0x68, 0xb5, 0xb9, 0xd6, 0xf7, 0xd8, 0x67, 0x46, 0x45, 0x94, 0x89, 0xf8, 0x81, 0xd5, 0xf6, 0xb4,",
          "933:        0x88, 0xb1, 0x2a, 0x44, 0x72, 0xd9, 0x87, 0x66, 0xd4, 0xf5, 0x3a, 0xa7, 0x73, 0xa9, 0xa8, 0x86, 0x62, 0xc7,",
          "934:        0x65, 0xc8, 0xc9, 0xa1, 0xf4, 0xd1, 0xe9, 0x5a, 0x92, 0x85, 0xa6, 0xe7, 0x93, 0xe8, 0xc1, 0xc6, 0x7a, 0x64,",
          "935:        0xe1, 0x4a, 0x6a, 0xe6, 0xb3, 0xf1, 0xd3, 0xa5, 0x8a, 0xb2, 0x9a, 0xba, 0x84, 0xa4, 0x63, 0xe5, 0xc5, 0xf3,",
          "936:        0xd2, 0xc4, 0x82, 0xaa, 0xda, 0xe4, 0xf2, 0xca, 0x83, 0xa3, 0xa2, 0xc3, 0xea, 0xc2, 0xe2, 0xe3, 0xff, 0xff},",
          "937:       {0,    2,    2,    1,    4,    1,    4,    1,    3,    3,    1,    0,    0,    0,    0,    140,  0x02, 0x03,",
          "938:        0x01, 0x04, 0x05, 0x12, 0x11, 0x06, 0x13, 0x07, 0x08, 0x14, 0x22, 0x09, 0x21, 0x00, 0x23, 0x15, 0x31, 0x32,",
          "939:        0x0a, 0x16, 0xf0, 0x24, 0x33, 0x41, 0x42, 0x19, 0x17, 0x25, 0x18, 0x51, 0x34, 0x43, 0x52, 0x29, 0x35, 0x61,",
          "940:        0x39, 0x71, 0x62, 0x36, 0x53, 0x26, 0x38, 0x1a, 0x37, 0x81, 0x27, 0x91, 0x79, 0x55, 0x45, 0x28, 0x72, 0x59,",
          "941:        0xa1, 0xb1, 0x44, 0x69, 0x54, 0x58, 0xd1, 0xfa, 0x57, 0xe1, 0xf1, 0xb9, 0x49, 0x47, 0x63, 0x6a, 0xf9, 0x56,",
          "942:        0x46, 0xa8, 0x2a, 0x4a, 0x78, 0x99, 0x3a, 0x75, 0x74, 0x86, 0x65, 0xc1, 0x76, 0xb6, 0x96, 0xd6, 0x89, 0x85,",
          "943:        0xc9, 0xf5, 0x95, 0xb4, 0xc7, 0xf7, 0x8a, 0x97, 0xb8, 0x73, 0xb7, 0xd8, 0xd9, 0x87, 0xa7, 0x7a, 0x48, 0x82,",
          "944:        0x84, 0xea, 0xf4, 0xa6, 0xc5, 0x5a, 0x94, 0xa4, 0xc6, 0x92, 0xc3, 0x68, 0xb5, 0xc8, 0xe4, 0xe5, 0xe6, 0xe9,",
          "945:        0xa2, 0xa3, 0xe3, 0xc2, 0x66, 0x67, 0x93, 0xaa, 0xd4, 0xd5, 0xe7, 0xf8, 0x88, 0x9a, 0xd7, 0x77, 0xc4, 0x64,",
          "946:        0xe2, 0x98, 0xa5, 0xca, 0xda, 0xe8, 0xf3, 0xf6, 0xa9, 0xb2, 0xb3, 0xf2, 0xd2, 0x83, 0xba, 0xd3, 0xff, 0xff},",
          "947:       {0,    0,    6,    2,    1,    3,    3,    2,    5,    1,    2,    2,    8,    10,   0,    117,  0x04, 0x05,",
          "948:        0x03, 0x06, 0x02, 0x07, 0x01, 0x08, 0x09, 0x12, 0x13, 0x14, 0x11, 0x15, 0x0a, 0x16, 0x17, 0xf0, 0x00, 0x22,",
          "949:        0x21, 0x18, 0x23, 0x19, 0x24, 0x32, 0x31, 0x25, 0x33, 0x38, 0x37, 0x34, 0x35, 0x36, 0x39, 0x79, 0x57, 0x58,",
          "950:        0x59, 0x28, 0x56, 0x78, 0x27, 0x41, 0x29, 0x77, 0x26, 0x42, 0x76, 0x99, 0x1a, 0x55, 0x98, 0x97, 0xf9, 0x48,",
          "951:        0x54, 0x96, 0x89, 0x47, 0xb7, 0x49, 0xfa, 0x75, 0x68, 0xb6, 0x67, 0x69, 0xb9, 0xb8, 0xd8, 0x52, 0xd7, 0x88,",
          "952:        0xb5, 0x74, 0x51, 0x46, 0xd9, 0xf8, 0x3a, 0xd6, 0x87, 0x45, 0x7a, 0x95, 0xd5, 0xf6, 0x86, 0xb4, 0xa9, 0x94,",
          "953:        0x53, 0x2a, 0xa8, 0x43, 0xf5, 0xf7, 0xd4, 0x66, 0xa7, 0x5a, 0x44, 0x8a, 0xc9, 0xe8, 0xc8, 0xe7, 0x9a, 0x6a,",
          "954:        0x73, 0x4a, 0x61, 0xc7, 0xf4, 0xc6, 0x65, 0xe9, 0x72, 0xe6, 0x71, 0x91, 0x93, 0xa6, 0xda, 0x92, 0x85, 0x62,",
          "955:        0xf3, 0xc5, 0xb2, 0xa4, 0x84, 0xba, 0x64, 0xa5, 0xb3, 0xd2, 0x81, 0xe5, 0xd3, 0xaa, 0xc4, 0xca, 0xf2, 0xb1,",
          "956:        0xe4, 0xd1, 0x83, 0x63, 0xea, 0xc3, 0xe2, 0x82, 0xf1, 0xa3, 0xc2, 0xa1, 0xc1, 0xe3, 0xa2, 0xe1, 0xff, 0xff}};",
          "957:   if (table > 2)",
          "958:     table = 2;",
          "959:   huff[0] = make_decoder(first_tree[table]);",
          "960:   huff[1] = make_decoder(second_tree[table]);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "894: int CLASS canon_has_lowbits()",
          "895: {",
          "896:   uchar test[0x4000];",
          "905:     }",
          "906:   return ret;",
          "907: }",
          "",
          "[Removed Lines]",
          "897:   int ret=1, i;",
          "899:   fseek (ifp, 0, SEEK_SET);",
          "900:   fread (test, 1, sizeof test, ifp);",
          "901:   for (i=540; i < sizeof test - 1; i++)",
          "902:     if (test[i] == 0xff) {",
          "903:       if (test[i+1]) return 1;",
          "904:       ret=0;",
          "",
          "[Added Lines]",
          "972:   int ret = 1, i;",
          "974:   fseek(ifp, 0, SEEK_SET);",
          "975:   fread(test, 1, sizeof test, ifp);",
          "976:   for (i = 540; i < sizeof test - 1; i++)",
          "977:     if (test[i] == 0xff)",
          "978:     {",
          "979:       if (test[i + 1])",
          "980:         return 1;",
          "981:       ret = 0;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "910: {",
          "911:   ushort *pixel, *prow, *huff[2];",
          "912:   int nblocks, lowbits, i, c, row, r, save, val;",
          "916:   lowbits = canon_has_lowbits();",
          "919:   zero_after_ff = 1;",
          "920:   getbits(-1);",
          "921: #ifdef LIBRAW_LIBRARY_BUILD",
          "923: #endif",
          "925: #ifdef LIBRAW_LIBRARY_BUILD",
          "927: #endif",
          "963:       }",
          "965:     }",
          "967: #ifdef LIBRAW_LIBRARY_BUILD",
          "970:     throw;",
          "971:   }",
          "972: #endif",
          "974: }",
          "978:   int algo, bits, high, wide, clrs, sraw, psv, restart, vpred[6];",
          "979:   ushort quant[64], idct[64], *huff[20], *free[20], *row;",
          "980: };",
          "985: {",
          "986:   ushort c, tag, len;",
          "987:   int cnt = 0;",
          "988:   uchar data[0x10000];",
          "989:   const uchar *dp;",
          "992:   jh->restart = INT_MAX;",
          "999:     len = (data[2] << 8 | data[3]) - 2;",
          "1028:     }",
          "1029:   } while (tag != 0xffda);",
          "1041:   return zero_after_ff = 1;",
          "1042: }",
          "1045: {",
          "1046:   int c;",
          "1049: }",
          "1052: {",
          "1053:   int len, diff;",
          "1055: #ifdef LIBRAW_LIBRARY_BUILD",
          "1056:     throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "1057: #else",
          "1059: #endif",
          "1062:   len = gethuff(huff);",
          "1063:   if (len == 16 && (!dng_version || dng_version >= 0x1010000))",
          "1064:     return -32768;",
          "1065:   diff = getbits(len);",
          "1067:     diff -= (1 << len) - 1;",
          "1068:   return diff;",
          "1069: }",
          "1072: {",
          "1081:       while (c != EOF && mark >> 4 != 0xffd);",
          "1082:     }",
          "1083:     getbits(-1);",
          "1084:   }",
          "1089:       if (jh->sraw && c <= jh->sraw && (col | c))",
          "1106:     }",
          "1107:   return row[2];",
          "1108: }",
          "1110: void CLASS lossless_jpeg_load_raw()",
          "1111: {",
          "1113:   struct jhead jh;",
          "1114:   ushort *rp;",
          "1119: #ifdef LIBRAW_LIBRARY_BUILD",
          "1120:     throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "1121: #else",
          "1123: #endif",
          "1124:   jwide = jh.wide * jh.clrs;",
          "1125:   jhigh = jh.high;",
          "1128: #ifdef LIBRAW_LIBRARY_BUILD",
          "1130: #endif",
          "1132: #ifdef LIBRAW_LIBRARY_BUILD",
          "1134: #endif",
          "1154: #else",
          "1156: #endif",
          "1160:     }",
          "1162: #ifdef LIBRAW_LIBRARY_BUILD",
          "1165:     throw;",
          "1166:   }",
          "1167: #endif",
          "1169: }",
          "1171: void CLASS canon_sraw_load_raw()",
          "1172: {",
          "1173:   struct jhead jh;",
          "1177: #ifdef LIBRAW_LIBRARY_BUILD",
          "1178:   int saved_w = width, saved_h = height;",
          "1179: #endif",
          "1180:   char *cp;",
          "1183:   jwide = (jh.wide >>= 1) * jh.clrs;",
          "1186: #ifdef LIBRAW_LIBRARY_BUILD",
          "1188:   {",
          "1191:   }",
          "1194: #endif",
          "1200: #ifdef LIBRAW_LIBRARY_BUILD",
          "1202: #endif",
          "1208: #ifdef LIBRAW_LIBRARY_BUILD",
          "1210:           {",
          "1218:           }",
          "1220:           {",
          "1225:           }",
          "1227: #endif",
          "1228:           {",
          "1233:           }",
          "1234:       }",
          "1235:     }",
          "1237: #ifdef LIBRAW_LIBRARY_BUILD",
          "1241:   }",
          "1242: #endif",
          "1244: #ifdef LIBRAW_LIBRARY_BUILD",
          "1253: #endif",
          "1255: #ifdef LIBRAW_LIBRARY_BUILD",
          "1257: #endif",
          "1267: #ifdef LIBRAW_LIBRARY_BUILD",
          "1269: #endif",
          "1278:           else",
          "1282:     }",
          "1289: #ifdef LIBRAW_LIBRARY_BUILD",
          "1291: #endif",
          "1293: #ifdef LIBRAW_LIBRARY_BUILD",
          "1295: #endif",
          "1318:   }",
          "1319:   height = saved_h;",
          "1320:   width = saved_w;",
          "1321: #endif",
          "1323:   maximum = 0x3fff;",
          "1324: }",
          "1327: {",
          "1328:   int c;",
          "1332:     if (row < raw_height && col < raw_width)",
          "1336:     if (row < height && col < width)",
          "1337:       FORC(tiff_samples)",
          "1340:   }",
          "1342: }",
          "1345: {",
          "1346:   int c, i, j, len, skip, coef;",
          "1347:   float work[3][8][8];",
          "1355:   if (!cs[0])",
          "1361:     i += skip = len >> 4;",
          "1363:     coef = getbits(len);",
          "1365:       coef -= (1 << len) - 1;",
          "1366:     ((float *)work)[zigzag[i]] = coef * jh->quant[i];",
          "1367:   }",
          "1368:   FORC(8) work[0][0][c] *= M_SQRT1_2;",
          "1369:   FORC(8) work[0][c][0] *= M_SQRT1_2;",
          "1378: }",
          "1380: void CLASS lossless_dng_load_raw()",
          "1381: {",
          "1383:   struct jhead jh;",
          "1384:   ushort *rp;",
          "1387: #ifdef LIBRAW_LIBRARY_BUILD",
          "1388:     checkCancel();",
          "1389: #endif",
          "1390:     save = ftell(ifp);",
          "1391:     if (tile_length < INT_MAX)",
          "1394:     jwide = jh.wide;",
          "1397: #ifdef LIBRAW_LIBRARY_BUILD",
          "1399: #endif",
          "1401:       case 0xc1:",
          "1419:       case 0xc3:",
          "1421: #ifdef LIBRAW_LIBRARY_BUILD",
          "1423: #endif",
          "1431:       }",
          "1432: #ifdef LIBRAW_LIBRARY_BUILD",
          "1436:     }",
          "1437: #endif",
          "1439:     if ((tcol += tile_width) >= raw_width)",
          "1440:       trow += tile_length + (tcol = 0);",
          "1442:   }",
          "1443: }",
          "",
          "[Removed Lines]",
          "913:   int block, diffbuf[64], leaf, len, diff, carry=0, pnum=0, base[2];",
          "915:   crw_init_tables (tiff_compress, huff);",
          "917:   if (!lowbits) maximum = 0x3ff;",
          "918:   fseek (ifp, 540 + lowbits*raw_height*raw_width/4, SEEK_SET);",
          "922:   try {",
          "924:   for (row=0; row < raw_height; row+=8) {",
          "926:     checkCancel();",
          "928:     pixel = raw_image + row*raw_width;",
          "929:     nblocks = MIN (8, raw_height-row) * raw_width >> 6;",
          "930:     for (block=0; block < nblocks; block++) {",
          "931:       memset (diffbuf, 0, sizeof diffbuf);",
          "932:       for (i=0; i < 64; i++ ) {",
          "933:  leaf = gethuff(huff[i > 0]);",
          "934:  if (leaf == 0 && i) break;",
          "935:  if (leaf == 0xff) continue;",
          "936:  i  += leaf >> 4;",
          "937:  len = leaf & 15;",
          "938:  if (len == 0) continue;",
          "939:  diff = getbits(len);",
          "940:  if ((diff & (1 << (len-1))) == 0)",
          "941:    diff -= (1 << len) - 1;",
          "942:  if (i < 64) diffbuf[i] = diff;",
          "943:       }",
          "944:       diffbuf[0] += carry;",
          "945:       carry = diffbuf[0];",
          "946:       for (i=0; i < 64; i++ ) {",
          "947:  if (pnum++ % raw_width == 0)",
          "948:    base[0] = base[1] = 512;",
          "949:  if ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)",
          "950:    derror();",
          "951:       }",
          "952:     }",
          "953:     if (lowbits) {",
          "954:       save = ftell(ifp);",
          "955:       fseek (ifp, 26 + row*raw_width/4, SEEK_SET);",
          "956:       for (prow=pixel, i=0; i < raw_width*2; i++) {",
          "957:  c = fgetc(ifp);",
          "958:  for (r=0; r < 8; r+=2, prow++) {",
          "959:    val = (*prow << 2) + ((c >> r) & 3);",
          "960:    if (raw_width == 2672 && val < 512) val += 2;",
          "962:  }",
          "964:       fseek (ifp, save, SEEK_SET);",
          "966:   }",
          "968:   } catch (...) {",
          "969:     FORC(2) free (huff[c]);",
          "973:   FORC(2) free (huff[c]);",
          "977: struct jhead {",
          "984: int CLASS ljpeg_start (struct jhead *jh, int info_only)",
          "991:   memset (jh, 0, sizeof *jh);",
          "993:   if ((fgetc(ifp),fgetc(ifp)) != 0xd8) return 0;",
          "994:   do {",
          "995:     if(feof(ifp)) return 0;",
          "996:     if(cnt++ > 1024) return 0; // 1024 tags limit",
          "997:     if (!fread (data, 2, 2, ifp)) return 0;",
          "998:     tag =  data[0] << 8 | data[1];",
          "1000:     if (tag <= 0xff00) return 0;",
          "1001:     fread (data, 1, len, ifp);",
          "1002:     switch (tag) {",
          "1003:       case 0xffc3:        // start of frame; lossless, Huffman",
          "1004:  jh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;",
          "1005:       case 0xffc1:",
          "1006:       case 0xffc0:",
          "1007:  jh->algo = tag & 0xff;",
          "1008:  jh->bits = data[0];",
          "1009:  jh->high = data[1] << 8 | data[2];",
          "1010:  jh->wide = data[3] << 8 | data[4];",
          "1011:  jh->clrs = data[5] + jh->sraw;",
          "1012:  if (len == 9 && !dng_version) getc(ifp);",
          "1013:  break;",
          "1014:       case 0xffc4:          // define Huffman tables",
          "1015:  if (info_only) break;",
          "1016:  for (dp = data; dp < data+len && !((c = *dp++) & -20); )",
          "1017:    jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);",
          "1018:  break;",
          "1019:       case 0xffda:          // start of scan",
          "1020:  jh->psv = data[1+data[0]*2];",
          "1021:  jh->bits -= data[3+data[0]*2] & 15;",
          "1022:  break;",
          "1023:       case 0xffdb:",
          "1024:  FORC(64) jh->quant[c] = data[c*2+1] << 8 | data[c*2+2];",
          "1025:  break;",
          "1026:       case 0xffdd:",
          "1027:  jh->restart = data[0] << 8 | data[1];",
          "1030:   if (jh->bits > 16 || jh->clrs > 6 ||",
          "1031:      !jh->bits || !jh->high || !jh->wide || !jh->clrs) return 0;",
          "1032:   if (info_only) return 1;",
          "1033:   if (!jh->huff[0]) return 0;",
          "1034:   FORC(19) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];",
          "1035:   if (jh->sraw) {",
          "1036:     FORC(4)        jh->huff[2+c] = jh->huff[1];",
          "1037:     FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];",
          "1038:   }",
          "1039:   jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);",
          "1040:   merror (jh->row, \"ljpeg_start()\");",
          "1044: void CLASS ljpeg_end (struct jhead *jh)",
          "1047:   FORC4 if (jh->free[c]) free (jh->free[c]);",
          "1048:   free (jh->row);",
          "1051: int CLASS ljpeg_diff (ushort *huff)",
          "1054:   if(!huff)",
          "1058:     longjmp (failure, 2);",
          "1066:   if ((diff & (1 << (len-1))) == 0)",
          "1071: ushort * CLASS ljpeg_row (int jrow, struct jhead *jh)",
          "1073:   int col, c, diff, pred, spred=0;",
          "1074:   ushort mark=0, *row[3];",
          "1076:   if (jrow * jh->wide % jh->restart == 0) {",
          "1077:     FORC(6) jh->vpred[c] = 1 << (jh->bits-1);",
          "1078:     if (jrow) {",
          "1079:       fseek (ifp, -2, SEEK_CUR);",
          "1080:       do mark = (mark << 8) + (c = fgetc(ifp));",
          "1085:   FORC3 row[c] = jh->row + jh->wide*jh->clrs*((jrow+c) & 1);",
          "1086:   for (col=0; col < jh->wide; col++)",
          "1087:     FORC(jh->clrs) {",
          "1088:       diff = ljpeg_diff (jh->huff[c]);",
          "1090:       pred = spred;",
          "1091:       else if (col) pred = row[0][-jh->clrs];",
          "1092:       else     pred = (jh->vpred[c] += diff) - diff;",
          "1093:       if (jrow && col) switch (jh->psv) {",
          "1094:  case 1: break;",
          "1095:  case 2: pred = row[1][0];     break;",
          "1096:  case 3: pred = row[1][-jh->clrs];    break;",
          "1097:  case 4: pred = pred +   row[1][0] - row[1][-jh->clrs];  break;",
          "1098:  case 5: pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1); break;",
          "1099:  case 6: pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1); break;",
          "1100:  case 7: pred = (pred + row[1][0]) >> 1;    break;",
          "1101:  default: pred = 0;",
          "1102:       }",
          "1103:       if ((**row = pred + diff) >> jh->bits) derror();",
          "1104:       if (c <= jh->sraw) spred = **row;",
          "1105:       row[0]++; row[1]++;",
          "1112:   int jwide, jhigh, jrow, jcol, val, jidx, i, j, row=0, col=0;",
          "1116:   if (!ljpeg_start (&jh, 0)) return;",
          "1118:   if(jh.wide<1 || jh.high<1 || jh.clrs<1 || jh.bits <1)",
          "1122:     longjmp (failure, 2);",
          "1126:   if(jh.clrs == 4 && jwide >= raw_width*2) jhigh *= 2;",
          "1129:   try {",
          "1131:   for (jrow=0; jrow < jh.high; jrow++) {",
          "1133:     checkCancel();",
          "1135:     rp = ljpeg_row (jrow, &jh);",
          "1136:     if (load_flags & 1)",
          "1137:       row = jrow & 1 ? height-1-jrow/2 : jrow/2;",
          "1138:     for (jcol=0; jcol < jwide; jcol++) {",
          "1139:       val = curve[*rp++];",
          "1140:       if (cr2_slice[0]) {",
          "1141:  jidx = jrow*jwide + jcol;",
          "1142:  i = jidx / (cr2_slice[1]*raw_height);",
          "1143:  if ((j = i >= cr2_slice[0]))",
          "1144:    i  = cr2_slice[0];",
          "1145:  jidx -= i * (cr2_slice[1]*raw_height);",
          "1146:  row = jidx / cr2_slice[1+j];",
          "1147:  col = jidx % cr2_slice[1+j] + i*cr2_slice[1];",
          "1148:       }",
          "1149:       if (raw_width == 3984 && (col -= 2) < 0)",
          "1150:  col += (row--,raw_width);",
          "1151:       if(row>raw_height)",
          "1152: #ifdef LIBRAW_LIBRARY_BUILD",
          "1153:         throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "1155:         longjmp (failure, 3);",
          "1157:       if ((unsigned) row < raw_height) RAW(row,col) = val;",
          "1158:       if (++col >= raw_width)",
          "1159:  col = (row++,0);",
          "1161:   }",
          "1163:   } catch (...) {",
          "1164:     ljpeg_end (&jh);",
          "1168:   ljpeg_end (&jh);",
          "1174:   short *rp=0, (*ip)[4];",
          "1175:   int jwide, slice, scol, ecol, row, col, jrow=0, jcol=0, pix[3], c;",
          "1176:   int v[3]={0,0,0}, ver, hue;",
          "1182:   if (!ljpeg_start (&jh, 0) || jh.clrs < 4) return;",
          "1187:   if(load_flags & 256)",
          "1189:  width = raw_width;",
          "1190:  height = raw_height;",
          "1193:   try {",
          "1195:   for (ecol=slice=0; slice <= cr2_slice[0]; slice++) {",
          "1196:     scol = ecol;",
          "1197:     ecol += cr2_slice[1] * 2 / jh.clrs;",
          "1198:     if (!cr2_slice[0] || ecol > raw_width-1) ecol = raw_width & -2;",
          "1199:     for (row=0; row < height; row += (jh.clrs >> 1) - 1) {",
          "1201:     checkCancel();",
          "1203:       ip = (short (*)[4]) image + row*width;",
          "1204:       for (col=scol; col < ecol; col+=2, jcol+=jh.clrs) {",
          "1205:  if ((jcol %= jwide) == 0)",
          "1206:    rp = (short *) ljpeg_row (jrow++, &jh);",
          "1207:  if (col >= width) continue;",
          "1209:         if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)",
          "1211:             FORC (jh.clrs-2)",
          "1212:               {",
          "1213:                 ip[col + (c >> 1)*width + (c & 1)][0] = rp[jcol+c];",
          "1214:                 ip[col + (c >> 1)*width + (c & 1)][1] = ip[col + (c >> 1)*width + (c & 1)][2] = 8192;",
          "1215:               }",
          "1216:             ip[col][1] = rp[jcol+jh.clrs-2] - 8192;",
          "1217:             ip[col][2] = rp[jcol+jh.clrs-1] - 8192;",
          "1219:         else if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB)",
          "1221:             FORC (jh.clrs-2)",
          "1222:                 ip[col + (c >> 1)*width + (c & 1)][0] = rp[jcol+c];",
          "1223:             ip[col][1] = rp[jcol+jh.clrs-2] - 8192;",
          "1224:             ip[col][2] = rp[jcol+jh.clrs-1] - 8192;",
          "1226:         else",
          "1229:             FORC (jh.clrs-2)",
          "1230:               ip[col + (c >> 1)*width + (c & 1)][0] = rp[jcol+c];",
          "1231:             ip[col][1] = rp[jcol+jh.clrs-2] - 16384;",
          "1232:             ip[col][2] = rp[jcol+jh.clrs-1] - 16384;",
          "1236:   }",
          "1238:   } catch (...) {",
          "1239:       ljpeg_end (&jh);",
          "1240:       throw ;",
          "1245:   if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)",
          "1246:     {",
          "1247:       ljpeg_end (&jh);",
          "1248:       maximum = 0x3fff;",
          "1249:       height = saved_h;",
          "1250:       width = saved_w;",
          "1251:       return;",
          "1252:     }",
          "1256:   try {",
          "1258:   for (cp=model2; *cp && !isdigit(*cp); cp++);",
          "1259:   sscanf (cp, \"%d.%d.%d\", v, v+1, v+2);",
          "1260:   ver = (v[0]*1000 + v[1])*1000 + v[2];",
          "1261:   hue = (jh.sraw+1) << 2;",
          "1262:   if (unique_id >= 0x80000281 || (unique_id == 0x80000218 && ver > 1000006))",
          "1263:     hue = jh.sraw << 1;",
          "1264:   ip = (short (*)[4]) image;",
          "1265:   rp = ip[0];",
          "1266:   for (row=0; row < height; row++, ip+=width) {",
          "1268:     checkCancel();",
          "1270:     if (row & (jh.sraw >> 1))",
          "1271:     {",
          "1272:       for (col=0; col < width; col+=2)",
          "1273:  for (c=1; c < 3; c++)",
          "1274:    if (row == height-1)",
          "1275:           {",
          "1276:         ip[col][c] =  ip[col-width][c];",
          "1277:           }",
          "1279:           {",
          "1280:               ip[col][c] = (ip[col-width][c] + ip[col+width][c] + 1) >> 1;",
          "1281:           }",
          "1283:     for (col=1; col < width; col+=2)",
          "1284:       for (c=1; c < 3; c++)",
          "1285:  if (col == width-1)",
          "1286:       ip[col][c] =  ip[col-1][c];",
          "1287:  else ip[col][c] = (ip[col-1][c] + ip[col+1][c] + 1) >> 1;",
          "1288:   }",
          "1290:   if(!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB) )",
          "1292:     for ( ; rp < ip[0]; rp+=4) {",
          "1294:     checkCancel();",
          "1296:       if (unique_id == 0x80000218 ||",
          "1297:           unique_id == 0x80000250 ||",
          "1298:           unique_id == 0x80000261 ||",
          "1299:           unique_id == 0x80000281 ||",
          "1300:           unique_id == 0x80000287) {",
          "1301:         rp[1] = (rp[1] << 2) + hue;",
          "1302:         rp[2] = (rp[2] << 2) + hue;",
          "1303:         pix[0] = rp[0] + ((   50*rp[1] + 22929*rp[2]) >> 14);",
          "1304:         pix[1] = rp[0] + ((-5640*rp[1] - 11751*rp[2]) >> 14);",
          "1305:         pix[2] = rp[0] + ((29040*rp[1] -   101*rp[2]) >> 14);",
          "1306:       } else {",
          "1307:         if (unique_id < 0x80000218) rp[0] -= 512;",
          "1308:         pix[0] = rp[0] + rp[2];",
          "1309:         pix[2] = rp[0] + rp[1];",
          "1310:         pix[1] = rp[0] + ((-778*rp[1] - (rp[2] << 11)) >> 12);",
          "1311:       }",
          "1312:       FORC3 rp[c] = CLIP(pix[c] * sraw_mul[c] >> 10);",
          "1313:     }",
          "1314: #ifdef LIBRAW_LIBRARY_BUILD",
          "1315:   } catch (...) {",
          "1316:       ljpeg_end (&jh);",
          "1317:       throw ;",
          "1322:   ljpeg_end (&jh);",
          "1326: void CLASS adobe_copy_pixel (unsigned row, unsigned col, ushort **rp)",
          "1330:   if (tiff_samples == 2 && shot_select) (*rp)++;",
          "1331:   if (raw_image) {",
          "1333:       RAW(row,col) = curve[**rp];",
          "1335:   } else {",
          "1338:  image[row*width+col][c] = curve[(*rp)[c]];",
          "1341:   if (tiff_samples == 2 && shot_select) (*rp)--;",
          "1344: void CLASS ljpeg_idct (struct jhead *jh)",
          "1348:   static float cs[106] = { 0 };",
          "1349:   static const uchar zigzag[80] =",
          "1350:   {  0, 1, 8,16, 9, 2, 3,10,17,24,32,25,18,11, 4, 5,12,19,26,33,",
          "1351:     40,48,41,34,27,20,13, 6, 7,14,21,28,35,42,49,56,57,50,43,36,",
          "1352:     29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,",
          "1353:     47,55,62,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63 };",
          "1356:     FORC(106) cs[c] = cos((c & 31)*M_PI/16)/2;",
          "1357:   memset (work, 0, sizeof work);",
          "1358:   work[0][0][0] = jh->vpred[0] += ljpeg_diff (jh->huff[0]) * jh->quant[0];",
          "1359:   for (i=1; i < 64; i++ ) {",
          "1360:     len = gethuff (jh->huff[16]);",
          "1362:     if (!(len &= 15) && skip < 15) break;",
          "1364:     if ((coef & (1 << (len-1))) == 0)",
          "1370:   for (i=0; i < 8; i++)",
          "1371:     for (j=0; j < 8; j++)",
          "1372:       FORC(8) work[1][i][j] += work[0][i][c] * cs[(j*2+1)*c];",
          "1373:   for (i=0; i < 8; i++)",
          "1374:     for (j=0; j < 8; j++)",
          "1375:       FORC(8) work[2][i][j] += work[1][c][j] * cs[(i*2+1)*c];",
          "1377:   FORC(64) jh->idct[c] = CLIP(((float *)work[2])[c]+0.5);",
          "1382:   unsigned save, trow=0, tcol=0, jwide, jrow, jcol, row, col, i, j;",
          "1386:   while (trow < raw_height) {",
          "1392:       fseek (ifp, get4(), SEEK_SET);",
          "1393:     if (!ljpeg_start (&jh, 0)) break;",
          "1395:     if (filters) jwide *= jh.clrs;",
          "1396:     jwide /= MIN (is_raw, tiff_samples);",
          "1398:     try {",
          "1400:       switch (jh.algo) {",
          "1402:  jh.vpred[0] = 16384;",
          "1403:  getbits(-1);",
          "1404:  for (jrow=0; jrow+7 < jh.high; jrow += 8) {",
          "1405: #ifdef LIBRAW_LIBRARY_BUILD",
          "1406:    checkCancel();",
          "1407: #endif",
          "1408:    for (jcol=0; jcol+7 < jh.wide; jcol += 8) {",
          "1409:      ljpeg_idct (&jh);",
          "1410:      rp = jh.idct;",
          "1411:      row = trow + jcol/tile_width + jrow*2;",
          "1412:      col = tcol + jcol%tile_width;",
          "1413:      for (i=0; i < 16; i+=2)",
          "1414:        for (j=0; j < 8; j++)",
          "1415:   adobe_copy_pixel (row+i, col+j, &rp);",
          "1416:    }",
          "1417:  }",
          "1418:  break;",
          "1420:  for (row=col=jrow=0; jrow < jh.high; jrow++) {",
          "1422:    checkCancel();",
          "1424:    rp = ljpeg_row (jrow, &jh);",
          "1425:    for (jcol=0; jcol < jwide; jcol++) {",
          "1426:      adobe_copy_pixel (trow+row, tcol+col, &rp);",
          "1427:      if (++col >= tile_width || col >= raw_width)",
          "1428:        row += 1 + (col = 0);",
          "1429:    }",
          "1430:  }",
          "1433:     } catch (...) {",
          "1434:       ljpeg_end (&jh);",
          "1435:       throw ;",
          "1438:     fseek (ifp, save+4, SEEK_SET);",
          "1441:     ljpeg_end (&jh);",
          "",
          "[Added Lines]",
          "990:   int block, diffbuf[64], leaf, len, diff, carry = 0, pnum = 0, base[2];",
          "992:   crw_init_tables(tiff_compress, huff);",
          "994:   if (!lowbits)",
          "995:     maximum = 0x3ff;",
          "996:   fseek(ifp, 540 + lowbits * raw_height * raw_width / 4, SEEK_SET);",
          "1000:   try",
          "1001:   {",
          "1003:     for (row = 0; row < raw_height; row += 8)",
          "1004:     {",
          "1006:       checkCancel();",
          "1008:       pixel = raw_image + row * raw_width;",
          "1009:       nblocks = MIN(8, raw_height - row) * raw_width >> 6;",
          "1010:       for (block = 0; block < nblocks; block++)",
          "1011:       {",
          "1012:         memset(diffbuf, 0, sizeof diffbuf);",
          "1013:         for (i = 0; i < 64; i++)",
          "1014:         {",
          "1015:           leaf = gethuff(huff[i > 0]);",
          "1016:           if (leaf == 0 && i)",
          "1017:             break;",
          "1018:           if (leaf == 0xff)",
          "1019:             continue;",
          "1020:           i += leaf >> 4;",
          "1021:           len = leaf & 15;",
          "1022:           if (len == 0)",
          "1023:             continue;",
          "1024:           diff = getbits(len);",
          "1025:           if ((diff & (1 << (len - 1))) == 0)",
          "1026:             diff -= (1 << len) - 1;",
          "1027:           if (i < 64)",
          "1028:             diffbuf[i] = diff;",
          "1029:         }",
          "1030:         diffbuf[0] += carry;",
          "1031:         carry = diffbuf[0];",
          "1032:         for (i = 0; i < 64; i++)",
          "1033:         {",
          "1034:           if (pnum++ % raw_width == 0)",
          "1035:             base[0] = base[1] = 512;",
          "1036:           if ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)",
          "1037:             derror();",
          "1038:         }",
          "1039:       }",
          "1040:       if (lowbits)",
          "1041:       {",
          "1042:         save = ftell(ifp);",
          "1043:         fseek(ifp, 26 + row * raw_width / 4, SEEK_SET);",
          "1044:         for (prow = pixel, i = 0; i < raw_width * 2; i++)",
          "1045:         {",
          "1046:           c = fgetc(ifp);",
          "1047:           for (r = 0; r < 8; r += 2, prow++)",
          "1048:           {",
          "1049:             val = (*prow << 2) + ((c >> r) & 3);",
          "1050:             if (raw_width == 2672 && val < 512)",
          "1051:               val += 2;",
          "1053:           }",
          "1054:         }",
          "1055:         fseek(ifp, save, SEEK_SET);",
          "1059:   }",
          "1060:   catch (...)",
          "1061:   {",
          "1062:     FORC(2) free(huff[c]);",
          "1066:   FORC(2) free(huff[c]);",
          "1070: struct jhead",
          "1071: {",
          "1078: int CLASS ljpeg_start(struct jhead *jh, int info_only)",
          "1085:   memset(jh, 0, sizeof *jh);",
          "1087:   if ((fgetc(ifp), fgetc(ifp)) != 0xd8)",
          "1088:     return 0;",
          "1089:   do",
          "1090:   {",
          "1091:     if (feof(ifp))",
          "1092:       return 0;",
          "1093:     if (cnt++ > 1024)",
          "1094:       return 0; // 1024 tags limit",
          "1095:     if (!fread(data, 2, 2, ifp))",
          "1096:       return 0;",
          "1097:     tag = data[0] << 8 | data[1];",
          "1099:     if (tag <= 0xff00)",
          "1100:       return 0;",
          "1101:     fread(data, 1, len, ifp);",
          "1102:     switch (tag)",
          "1103:     {",
          "1104:     case 0xffc3: // start of frame; lossless, Huffman",
          "1105:       jh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;",
          "1106:     case 0xffc1:",
          "1107:     case 0xffc0:",
          "1108:       jh->algo = tag & 0xff;",
          "1109:       jh->bits = data[0];",
          "1110:       jh->high = data[1] << 8 | data[2];",
          "1111:       jh->wide = data[3] << 8 | data[4];",
          "1112:       jh->clrs = data[5] + jh->sraw;",
          "1113:       if (len == 9 && !dng_version)",
          "1114:         getc(ifp);",
          "1115:       break;",
          "1116:     case 0xffc4: // define Huffman tables",
          "1117:       if (info_only)",
          "1118:         break;",
          "1119:       for (dp = data; dp < data + len && !((c = *dp++) & -20);)",
          "1120:         jh->free[c] = jh->huff[c] = make_decoder_ref(&dp);",
          "1121:       break;",
          "1122:     case 0xffda: // start of scan",
          "1123:       jh->psv = data[1 + data[0] * 2];",
          "1124:       jh->bits -= data[3 + data[0] * 2] & 15;",
          "1125:       break;",
          "1126:     case 0xffdb:",
          "1127:       FORC(64) jh->quant[c] = data[c * 2 + 1] << 8 | data[c * 2 + 2];",
          "1128:       break;",
          "1129:     case 0xffdd:",
          "1130:       jh->restart = data[0] << 8 | data[1];",
          "1133:   if (jh->bits > 16 || jh->clrs > 6 || !jh->bits || !jh->high || !jh->wide || !jh->clrs)",
          "1134:     return 0;",
          "1135:   if (info_only)",
          "1136:     return 1;",
          "1137:   if (!jh->huff[0])",
          "1138:     return 0;",
          "1139:   FORC(19) if (!jh->huff[c + 1]) jh->huff[c + 1] = jh->huff[c];",
          "1140:   if (jh->sraw)",
          "1141:   {",
          "1142:     FORC(4) jh->huff[2 + c] = jh->huff[1];",
          "1143:     FORC(jh->sraw) jh->huff[1 + c] = jh->huff[0];",
          "1144:   }",
          "1145:   jh->row = (ushort *)calloc(jh->wide * jh->clrs, 4);",
          "1146:   merror(jh->row, \"ljpeg_start()\");",
          "1150: void CLASS ljpeg_end(struct jhead *jh)",
          "1153:   FORC4 if (jh->free[c]) free(jh->free[c]);",
          "1154:   free(jh->row);",
          "1157: int CLASS ljpeg_diff(ushort *huff)",
          "1160:   if (!huff)",
          "1164:     longjmp(failure, 2);",
          "1171:   if ((diff & (1 << (len - 1))) == 0)",
          "1176: ushort *CLASS ljpeg_row(int jrow, struct jhead *jh)",
          "1178:   int col, c, diff, pred, spred = 0;",
          "1179:   ushort mark = 0, *row[3];",
          "1181:   if (jrow * jh->wide % jh->restart == 0)",
          "1182:   {",
          "1183:     FORC(6) jh->vpred[c] = 1 << (jh->bits - 1);",
          "1184:     if (jrow)",
          "1185:     {",
          "1186:       fseek(ifp, -2, SEEK_CUR);",
          "1187:       do",
          "1188:         mark = (mark << 8) + (c = fgetc(ifp));",
          "1193:   FORC3 row[c] = jh->row + jh->wide * jh->clrs * ((jrow + c) & 1);",
          "1194:   for (col = 0; col < jh->wide; col++)",
          "1195:     FORC(jh->clrs)",
          "1196:     {",
          "1197:       diff = ljpeg_diff(jh->huff[c]);",
          "1199:         pred = spred;",
          "1200:       else if (col)",
          "1201:         pred = row[0][-jh->clrs];",
          "1202:       else",
          "1203:         pred = (jh->vpred[c] += diff) - diff;",
          "1204:       if (jrow && col)",
          "1205:         switch (jh->psv)",
          "1206:         {",
          "1207:         case 1:",
          "1208:           break;",
          "1209:         case 2:",
          "1210:           pred = row[1][0];",
          "1211:           break;",
          "1212:         case 3:",
          "1213:           pred = row[1][-jh->clrs];",
          "1214:           break;",
          "1215:         case 4:",
          "1216:           pred = pred + row[1][0] - row[1][-jh->clrs];",
          "1217:           break;",
          "1218:         case 5:",
          "1219:           pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);",
          "1220:           break;",
          "1221:         case 6:",
          "1222:           pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);",
          "1223:           break;",
          "1224:         case 7:",
          "1225:           pred = (pred + row[1][0]) >> 1;",
          "1226:           break;",
          "1227:         default:",
          "1228:           pred = 0;",
          "1229:         }",
          "1230:       if ((**row = pred + diff) >> jh->bits)",
          "1231:         derror();",
          "1232:       if (c <= jh->sraw)",
          "1233:         spred = **row;",
          "1234:       row[0]++;",
          "1235:       row[1]++;",
          "1242:   int jwide, jhigh, jrow, jcol, val, jidx, i, j, row = 0, col = 0;",
          "1246:   if (!ljpeg_start(&jh, 0))",
          "1247:     return;",
          "1249:   if (jh.wide < 1 || jh.high < 1 || jh.clrs < 1 || jh.bits < 1)",
          "1253:     longjmp(failure, 2);",
          "1257:   if (jh.clrs == 4 && jwide >= raw_width * 2)",
          "1258:     jhigh *= 2;",
          "1261:   try",
          "1262:   {",
          "1264:     for (jrow = 0; jrow < jh.high; jrow++)",
          "1265:     {",
          "1267:       checkCancel();",
          "1269:       rp = ljpeg_row(jrow, &jh);",
          "1270:       if (load_flags & 1)",
          "1271:         row = jrow & 1 ? height - 1 - jrow / 2 : jrow / 2;",
          "1272:       for (jcol = 0; jcol < jwide; jcol++)",
          "1273:       {",
          "1274:         val = curve[*rp++];",
          "1275:         if (cr2_slice[0])",
          "1276:         {",
          "1277:           jidx = jrow * jwide + jcol;",
          "1278:           i = jidx / (cr2_slice[1] * raw_height);",
          "1279:           if ((j = i >= cr2_slice[0]))",
          "1280:             i = cr2_slice[0];",
          "1281:           jidx -= i * (cr2_slice[1] * raw_height);",
          "1282:           row = jidx / cr2_slice[1 + j];",
          "1283:           col = jidx % cr2_slice[1 + j] + i * cr2_slice[1];",
          "1284:         }",
          "1285:         if (raw_width == 3984 && (col -= 2) < 0)",
          "1286:           col += (row--, raw_width);",
          "1287:         if (row > raw_height)",
          "1288: #ifdef LIBRAW_LIBRARY_BUILD",
          "1289:           throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "1291:         longjmp(failure, 3);",
          "1293:         if ((unsigned)row < raw_height)",
          "1294:           RAW(row, col) = val;",
          "1295:         if (++col >= raw_width)",
          "1296:           col = (row++, 0);",
          "1297:       }",
          "1300:   }",
          "1301:   catch (...)",
          "1302:   {",
          "1303:     ljpeg_end(&jh);",
          "1307:   ljpeg_end(&jh);",
          "1313:   short *rp = 0, (*ip)[4];",
          "1314:   int jwide, slice, scol, ecol, row, col, jrow = 0, jcol = 0, pix[3], c;",
          "1315:   int v[3] = {0, 0, 0}, ver, hue;",
          "1321:   if (!ljpeg_start(&jh, 0) || jh.clrs < 4)",
          "1322:     return;",
          "1326:   if (load_flags & 256)",
          "1328:     width = raw_width;",
          "1329:     height = raw_height;",
          "1332:   try",
          "1333:   {",
          "1335:     for (ecol = slice = 0; slice <= cr2_slice[0]; slice++)",
          "1336:     {",
          "1337:       scol = ecol;",
          "1338:       ecol += cr2_slice[1] * 2 / jh.clrs;",
          "1339:       if (!cr2_slice[0] || ecol > raw_width - 1)",
          "1340:         ecol = raw_width & -2;",
          "1341:       for (row = 0; row < height; row += (jh.clrs >> 1) - 1)",
          "1342:       {",
          "1344:         checkCancel();",
          "1346:         ip = (short(*)[4])image + row * width;",
          "1347:         for (col = scol; col < ecol; col += 2, jcol += jh.clrs)",
          "1348:         {",
          "1349:           if ((jcol %= jwide) == 0)",
          "1350:             rp = (short *)ljpeg_row(jrow++, &jh);",
          "1351:           if (col >= width)",
          "1352:             continue;",
          "1354:           if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)",
          "1356:             FORC(jh.clrs - 2)",
          "1357:             {",
          "1358:               ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];",
          "1359:               ip[col + (c >> 1) * width + (c & 1)][1] = ip[col + (c >> 1) * width + (c & 1)][2] = 8192;",
          "1360:             }",
          "1361:             ip[col][1] = rp[jcol + jh.clrs - 2] - 8192;",
          "1362:             ip[col][2] = rp[jcol + jh.clrs - 1] - 8192;",
          "1364:           else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB)",
          "1366:             FORC(jh.clrs - 2)",
          "1367:             ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];",
          "1368:             ip[col][1] = rp[jcol + jh.clrs - 2] - 8192;",
          "1369:             ip[col][2] = rp[jcol + jh.clrs - 1] - 8192;",
          "1371:           else",
          "1374:             FORC(jh.clrs - 2)",
          "1375:             ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];",
          "1376:             ip[col][1] = rp[jcol + jh.clrs - 2] - 16384;",
          "1377:             ip[col][2] = rp[jcol + jh.clrs - 1] - 16384;",
          "1379:         }",
          "1383:   }",
          "1384:   catch (...)",
          "1385:   {",
          "1386:     ljpeg_end(&jh);",
          "1387:     throw;",
          "1392:   if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)",
          "1393:   {",
          "1394:     ljpeg_end(&jh);",
          "1395:     maximum = 0x3fff;",
          "1396:     height = saved_h;",
          "1397:     width = saved_w;",
          "1398:     return;",
          "1399:   }",
          "1403:   try",
          "1404:   {",
          "1406:     for (cp = model2; *cp && !isdigit(*cp); cp++)",
          "1407:       ;",
          "1408:     sscanf(cp, \"%d.%d.%d\", v, v + 1, v + 2);",
          "1409:     ver = (v[0] * 1000 + v[1]) * 1000 + v[2];",
          "1410:     hue = (jh.sraw + 1) << 2;",
          "1411:     if (unique_id >= 0x80000281 || (unique_id == 0x80000218 && ver > 1000006))",
          "1412:       hue = jh.sraw << 1;",
          "1413:     ip = (short(*)[4])image;",
          "1414:     rp = ip[0];",
          "1415:     for (row = 0; row < height; row++, ip += width)",
          "1416:     {",
          "1418:       checkCancel();",
          "1420:       if (row & (jh.sraw >> 1))",
          "1421:       {",
          "1422:         for (col = 0; col < width; col += 2)",
          "1423:           for (c = 1; c < 3; c++)",
          "1424:             if (row == height - 1)",
          "1425:             {",
          "1426:               ip[col][c] = ip[col - width][c];",
          "1427:             }",
          "1428:             else",
          "1429:             {",
          "1430:               ip[col][c] = (ip[col - width][c] + ip[col + width][c] + 1) >> 1;",
          "1431:             }",
          "1432:       }",
          "1433:       for (col = 1; col < width; col += 2)",
          "1434:         for (c = 1; c < 3; c++)",
          "1435:           if (col == width - 1)",
          "1436:             ip[col][c] = ip[col - 1][c];",
          "1438:             ip[col][c] = (ip[col - 1][c] + ip[col + 1][c] + 1) >> 1;",
          "1441:     if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB))",
          "1443:       for (; rp < ip[0]; rp += 4)",
          "1444:       {",
          "1446:         checkCancel();",
          "1448:         if (unique_id == 0x80000218 || unique_id == 0x80000250 || unique_id == 0x80000261 || unique_id == 0x80000281 ||",
          "1449:             unique_id == 0x80000287)",
          "1450:         {",
          "1451:           rp[1] = (rp[1] << 2) + hue;",
          "1452:           rp[2] = (rp[2] << 2) + hue;",
          "1453:           pix[0] = rp[0] + ((50 * rp[1] + 22929 * rp[2]) >> 14);",
          "1454:           pix[1] = rp[0] + ((-5640 * rp[1] - 11751 * rp[2]) >> 14);",
          "1455:           pix[2] = rp[0] + ((29040 * rp[1] - 101 * rp[2]) >> 14);",
          "1456:         }",
          "1457:         else",
          "1458:         {",
          "1459:           if (unique_id < 0x80000218)",
          "1460:             rp[0] -= 512;",
          "1461:           pix[0] = rp[0] + rp[2];",
          "1462:           pix[2] = rp[0] + rp[1];",
          "1463:           pix[1] = rp[0] + ((-778 * rp[1] - (rp[2] << 11)) >> 12);",
          "1464:         }",
          "1465:         FORC3 rp[c] = CLIP(pix[c] * sraw_mul[c] >> 10);",
          "1466:       }",
          "1467: #ifdef LIBRAW_LIBRARY_BUILD",
          "1468:   }",
          "1469:   catch (...)",
          "1470:   {",
          "1471:     ljpeg_end(&jh);",
          "1472:     throw;",
          "1477:   ljpeg_end(&jh);",
          "1481: void CLASS adobe_copy_pixel(unsigned row, unsigned col, ushort **rp)",
          "1485:   if (tiff_samples == 2 && shot_select)",
          "1486:     (*rp)++;",
          "1487:   if (raw_image)",
          "1488:   {",
          "1490:       RAW(row, col) = curve[**rp];",
          "1492:   }",
          "1493:   else",
          "1494:   {",
          "1497:     image[row * width + col][c] = curve[(*rp)[c]];",
          "1500:   if (tiff_samples == 2 && shot_select)",
          "1501:     (*rp)--;",
          "1504: void CLASS ljpeg_idct(struct jhead *jh)",
          "1508:   static float cs[106] = {0};",
          "1509:   static const uchar zigzag[80] = {0,  1,  8,  16, 9,  2,  3,  10, 17, 24, 32, 25, 18, 11, 4,  5,  12, 19, 26, 33,",
          "1510:                                    40, 48, 41, 34, 27, 20, 13, 6,  7,  14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36,",
          "1511:                                    29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54,",
          "1512:                                    47, 55, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63};",
          "1515:     FORC(106) cs[c] = cos((c & 31) * M_PI / 16) / 2;",
          "1516:   memset(work, 0, sizeof work);",
          "1517:   work[0][0][0] = jh->vpred[0] += ljpeg_diff(jh->huff[0]) * jh->quant[0];",
          "1518:   for (i = 1; i < 64; i++)",
          "1519:   {",
          "1520:     len = gethuff(jh->huff[16]);",
          "1522:     if (!(len &= 15) && skip < 15)",
          "1523:       break;",
          "1525:     if ((coef & (1 << (len - 1))) == 0)",
          "1531:   for (i = 0; i < 8; i++)",
          "1532:     for (j = 0; j < 8; j++)",
          "1533:       FORC(8) work[1][i][j] += work[0][i][c] * cs[(j * 2 + 1) * c];",
          "1534:   for (i = 0; i < 8; i++)",
          "1535:     for (j = 0; j < 8; j++)",
          "1536:       FORC(8) work[2][i][j] += work[1][c][j] * cs[(i * 2 + 1) * c];",
          "1538:   FORC(64) jh->idct[c] = CLIP(((float *)work[2])[c] + 0.5);",
          "1543:   unsigned save, trow = 0, tcol = 0, jwide, jrow, jcol, row, col, i, j;",
          "1547:   while (trow < raw_height)",
          "1548:   {",
          "1554:       fseek(ifp, get4(), SEEK_SET);",
          "1555:     if (!ljpeg_start(&jh, 0))",
          "1556:       break;",
          "1558:     if (filters)",
          "1559:       jwide *= jh.clrs;",
          "1560:     jwide /= MIN(is_raw, tiff_samples);",
          "1562:     try",
          "1563:     {",
          "1565:       switch (jh.algo)",
          "1566:       {",
          "1568:         jh.vpred[0] = 16384;",
          "1569:         getbits(-1);",
          "1570:         for (jrow = 0; jrow + 7 < jh.high; jrow += 8)",
          "1571:         {",
          "1572: #ifdef LIBRAW_LIBRARY_BUILD",
          "1573:           checkCancel();",
          "1574: #endif",
          "1575:           for (jcol = 0; jcol + 7 < jh.wide; jcol += 8)",
          "1576:           {",
          "1577:             ljpeg_idct(&jh);",
          "1578:             rp = jh.idct;",
          "1579:             row = trow + jcol / tile_width + jrow * 2;",
          "1580:             col = tcol + jcol % tile_width;",
          "1581:             for (i = 0; i < 16; i += 2)",
          "1582:               for (j = 0; j < 8; j++)",
          "1583:                 adobe_copy_pixel(row + i, col + j, &rp);",
          "1584:           }",
          "1585:         }",
          "1586:         break;",
          "1588:         for (row = col = jrow = 0; jrow < jh.high; jrow++)",
          "1589:         {",
          "1591:           checkCancel();",
          "1593:           rp = ljpeg_row(jrow, &jh);",
          "1594:           for (jcol = 0; jcol < jwide; jcol++)",
          "1595:           {",
          "1596:             adobe_copy_pixel(trow + row, tcol + col, &rp);",
          "1597:             if (++col >= tile_width || col >= raw_width)",
          "1598:               row += 1 + (col = 0);",
          "1599:           }",
          "1600:         }",
          "1603:     }",
          "1604:     catch (...)",
          "1605:     {",
          "1606:       ljpeg_end(&jh);",
          "1607:       throw;",
          "1610:     fseek(ifp, save + 4, SEEK_SET);",
          "1613:     ljpeg_end(&jh);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1447:   ushort *pixel, *rp;",
          "1448:   int row, col;",
          "1452: #ifdef LIBRAW_LIBRARY_BUILD",
          "1454: #endif",
          "1456: #ifdef LIBRAW_LIBRARY_BUILD",
          "1458: #endif",
          "1465:     }",
          "1469: #ifdef LIBRAW_LIBRARY_BUILD",
          "1473:   }",
          "1474: #endif",
          "1476: }",
          "1478: void CLASS pentax_load_raw()",
          "1479: {",
          "1480:   ushort bit[2][15], huff[4097];",
          "1481:   int dep, row, col, diff, c, i;",
          "1485:   dep = (get2() + 12) & 15;",
          "1487:   FORC(dep) bit[0][c] = get2();",
          "1488:   FORC(dep) bit[1][c] = fgetc(ifp);",
          "1489:   FORC(dep)",
          "1492:   huff[0] = 12;",
          "1494:   getbits(-1);",
          "1496:   {",
          "1497: #ifdef LIBRAW_LIBRARY_BUILD",
          "1498:     checkCancel();",
          "1499: #endif",
          "1506:     }",
          "1507:   }",
          "1508: }",
          "",
          "[Removed Lines]",
          "1450:   pixel = (ushort *) calloc (raw_width, tiff_samples*sizeof *pixel);",
          "1451:   merror (pixel, \"packed_dng_load_raw()\");",
          "1453:   try {",
          "1455:   for (row=0; row < raw_height; row++) {",
          "1457:     checkCancel();",
          "1459:     if (tiff_bps == 16)",
          "1460:       read_shorts (pixel, raw_width * tiff_samples);",
          "1461:     else {",
          "1462:       getbits(-1);",
          "1463:       for (col=0; col < raw_width * tiff_samples; col++)",
          "1464:  pixel[col] = getbits(tiff_bps);",
          "1466:     for (rp=pixel, col=0; col < raw_width; col++)",
          "1467:       adobe_copy_pixel (row, col, &rp);",
          "1468:   }",
          "1470:   } catch (...) {",
          "1471:     free (pixel);",
          "1472:     throw ;",
          "1475:   free (pixel);",
          "1482:   ushort vpred[2][2] = {{0,0},{0,0}}, hpred[2];",
          "1484:   fseek (ifp, meta_offset, SEEK_SET);",
          "1486:   fseek (ifp, 12, SEEK_CUR);",
          "1490:     for (i=bit[0][c]; i <= ((bit[0][c]+(4096 >> bit[1][c])-1) & 4095); )",
          "1491:       huff[++i] = bit[1][c] << 8 | c;",
          "1493:   fseek (ifp, data_offset, SEEK_SET);",
          "1495:   for (row=0; row < raw_height; row++)",
          "1500:     for (col=0; col < raw_width; col++) {",
          "1501:       diff = ljpeg_diff (huff);",
          "1502:       if (col < 2) hpred[col] = vpred[row & 1][col] += diff;",
          "1503:       else    hpred[col & 1] += diff;",
          "1504:       RAW(row,col) = hpred[col & 1];",
          "1505:       if (hpred[col & 1] >> tiff_bps) derror();",
          "",
          "[Added Lines]",
          "1622:   pixel = (ushort *)calloc(raw_width, tiff_samples * sizeof *pixel);",
          "1623:   merror(pixel, \"packed_dng_load_raw()\");",
          "1625:   try",
          "1626:   {",
          "1628:     for (row = 0; row < raw_height; row++)",
          "1629:     {",
          "1631:       checkCancel();",
          "1633:       if (tiff_bps == 16)",
          "1634:         read_shorts(pixel, raw_width * tiff_samples);",
          "1635:       else",
          "1636:       {",
          "1637:         getbits(-1);",
          "1638:         for (col = 0; col < raw_width * tiff_samples; col++)",
          "1639:           pixel[col] = getbits(tiff_bps);",
          "1640:       }",
          "1641:       for (rp = pixel, col = 0; col < raw_width; col++)",
          "1642:         adobe_copy_pixel(row, col, &rp);",
          "1645:   }",
          "1646:   catch (...)",
          "1647:   {",
          "1648:     free(pixel);",
          "1649:     throw;",
          "1652:   free(pixel);",
          "1659:   ushort vpred[2][2] = {{0, 0}, {0, 0}}, hpred[2];",
          "1661:   fseek(ifp, meta_offset, SEEK_SET);",
          "1663:   fseek(ifp, 12, SEEK_CUR);",
          "1667:   for (i = bit[0][c]; i <= ((bit[0][c] + (4096 >> bit[1][c]) - 1) & 4095);)",
          "1668:     huff[++i] = bit[1][c] << 8 | c;",
          "1670:   fseek(ifp, data_offset, SEEK_SET);",
          "1672:   for (row = 0; row < raw_height; row++)",
          "1677:     for (col = 0; col < raw_width; col++)",
          "1678:     {",
          "1679:       diff = ljpeg_diff(huff);",
          "1680:       if (col < 2)",
          "1681:         hpred[col] = vpred[row & 1][col] += diff;",
          "1682:       else",
          "1683:         hpred[col & 1] += diff;",
          "1684:       RAW(row, col) = hpred[col & 1];",
          "1685:       if (hpred[col & 1] >> tiff_bps)",
          "1686:         derror();",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1512: void CLASS nikon_coolscan_load_raw()",
          "1513: {",
          "1517:   else",
          "1521:   unsigned short *ubuf = (unsigned short *)buf;",
          "1544: }",
          "1545: #endif",
          "1547: void CLASS nikon_load_raw()",
          "1548: {",
          "1549:   static const uchar nikon_tree[][32] = {",
          "1562:   ushort *huff, ver0, ver1, vpred[2][2], hpred[2], csize;",
          "1566:   ver0 = fgetc(ifp);",
          "1567:   ver1 = fgetc(ifp);",
          "1568:   if (ver0 == 0x49 || ver1 == 0x58)",
          "1573:   max = 1 << tiff_bps & 0x7fff;",
          "1574:   if ((csize = get2()) > 1)",
          "1583:     split = get2();",
          "1589:   getbits(-1);",
          "1590: #ifdef LIBRAW_LIBRARY_BUILD",
          "1592: #endif",
          "1594: #ifdef LIBRAW_LIBRARY_BUILD",
          "1596: #endif",
          "1613:     }",
          "1615: #ifdef LIBRAW_LIBRARY_BUILD",
          "1618:     throw;",
          "1619:   }",
          "1620: #endif",
          "1622: }",
          "1624: void CLASS nikon_yuv_load_raw()",
          "1625: {",
          "1626:   int row, col, yuv[4], rgb[3], b, c;",
          "1628:   float cmul[4];",
          "1631:   {",
          "1632: #ifdef LIBRAW_LIBRARY_BUILD",
          "1633:     checkCancel();",
          "1634: #endif",
          "1641:       }",
          "1646:     }",
          "1647:   }",
          "1648: }",
          "",
          "[Removed Lines]",
          "1514:   int bufsize = width*3*tiff_bps/8;",
          "1515:   if(tiff_bps <= 8)",
          "1516:     gamma_curve(1.0/imgdata.params.coolscan_nef_gamma,0.,1,255);",
          "1518:     gamma_curve(1.0/imgdata.params.coolscan_nef_gamma,0.,1,65535);",
          "1519:   fseek (ifp, data_offset, SEEK_SET);",
          "1520:   unsigned char *buf = (unsigned char*)malloc(bufsize);",
          "1522:   for(int row = 0; row < raw_height; row++)",
          "1523:     {",
          "1524:       int red = fread (buf, 1, bufsize, ifp);",
          "1525:       unsigned short (*ip)[4] = (unsigned short (*)[4]) image + row*width;",
          "1526:       if(tiff_bps <= 8)",
          "1527:         for(int col=0; col<width;col++)",
          "1528:           {",
          "1529:             ip[col][0] = curve[buf[col*3]];",
          "1530:             ip[col][1] = curve[buf[col*3+1]];",
          "1531:             ip[col][2] = curve[buf[col*3+2]];",
          "1532:             ip[col][3]=0;",
          "1533:           }",
          "1534:       else",
          "1535:         for(int col=0; col<width;col++)",
          "1536:           {",
          "1537:             ip[col][0] = curve[ubuf[col*3]];",
          "1538:             ip[col][1] = curve[ubuf[col*3+1]];",
          "1539:             ip[col][2] = curve[ubuf[col*3+2]];",
          "1540:             ip[col][3]=0;",
          "1541:           }",
          "1542:     }",
          "1543:   free(buf);",
          "1551:       5,4,3,6,2,7,1,0,8,9,11,10,12 },",
          "1553:       0x39,0x5a,0x38,0x27,0x16,5,4,3,2,1,0,11,12,12 },",
          "1555:       5,4,6,3,7,2,8,1,9,0,10,11,12 },",
          "1557:       5,6,4,7,8,3,9,2,1,0,10,11,12,13,14 },",
          "1559:       8,0x5c,0x4b,0x3a,0x29,7,6,5,4,3,2,1,0,13,14 },",
          "1561:       7,6,8,5,9,4,10,3,11,12,2,0,1,13,14 } };",
          "1563:   int i, min, max, step=0, tree=0, split=0, row, col, len, shl, diff;",
          "1565:   fseek (ifp, meta_offset, SEEK_SET);",
          "1569:     fseek (ifp, 2110, SEEK_CUR);",
          "1570:   if (ver0 == 0x46) tree = 2;",
          "1571:   if (tiff_bps == 14) tree += 3;",
          "1572:   read_shorts (vpred[0], 4);",
          "1575:     step = max / (csize-1);",
          "1576:   if (ver0 == 0x44 && ver1 == 0x20 && step > 0) {",
          "1577:     for (i=0; i < csize; i++)",
          "1578:       curve[i*step] = get2();",
          "1579:     for (i=0; i < max; i++)",
          "1580:       curve[i] = ( curve[i-i%step]*(step-i%step) +",
          "1581:      curve[i-i%step+step]*(i%step) ) / step;",
          "1582:     fseek (ifp, meta_offset+562, SEEK_SET);",
          "1584:   } else if (ver0 != 0x46 && csize <= 0x4001)",
          "1585:     read_shorts (curve, max=csize);",
          "1586:   while (curve[max-2] == curve[max-1]) max--;",
          "1587:   huff = make_decoder (nikon_tree[tree]);",
          "1588:   fseek (ifp, data_offset, SEEK_SET);",
          "1591:   try {",
          "1593:   for (min=row=0; row < height; row++) {",
          "1595:     checkCancel();",
          "1597:     if (split && row == split) {",
          "1598:       free (huff);",
          "1599:       huff = make_decoder (nikon_tree[tree+1]);",
          "1600:       max += (min = 16) << 1;",
          "1601:     }",
          "1602:     for (col=0; col < raw_width; col++) {",
          "1603:       i = gethuff(huff);",
          "1604:       len = i & 15;",
          "1605:       shl = i >> 4;",
          "1606:       diff = ((getbits(len-shl) << 1) + 1) << shl >> 1;",
          "1607:       if ((diff & (1 << (len-1))) == 0)",
          "1608:  diff -= (1 << len) - !shl;",
          "1609:       if (col < 2) hpred[col] = vpred[row & 1][col] += diff;",
          "1610:       else    hpred[col & 1] += diff;",
          "1611:       if ((ushort)(hpred[col & 1] + min) >= max) derror();",
          "1612:       RAW(row,col) = curve[LIM((short)hpred[col & 1],0,0x3fff)];",
          "1614:   }",
          "1616:   } catch (...) {",
          "1617:     free (huff);",
          "1621:   free (huff);",
          "1627:   UINT64 bitbuf=0;",
          "1629:   FORC4 { cmul[c] = cam_mul[c]>0.001f?cam_mul[c]:1.f; }",
          "1630:   for (row=0; row < raw_height; row++)",
          "1636:     for (col=0; col < raw_width; col++) {",
          "1637:       if (!(b = col & 1)) {",
          "1638:  bitbuf = 0;",
          "1639:  FORC(6) bitbuf |= (UINT64) fgetc(ifp) << c*8;",
          "1640:  FORC(4) yuv[c] = (bitbuf >> c*12 & 0xfff) - (c >> 1 << 11);",
          "1642:       rgb[0] = yuv[b] + 1.370705*yuv[3];",
          "1643:       rgb[1] = yuv[b] - 0.337633*yuv[2] - 0.698001*yuv[3];",
          "1644:       rgb[2] = yuv[b] + 1.732446*yuv[2];",
          "1645:       FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,0xfff)] / cmul[c];",
          "",
          "[Added Lines]",
          "1695:   int bufsize = width * 3 * tiff_bps / 8;",
          "1696:   if (tiff_bps <= 8)",
          "1697:     gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 255);",
          "1699:     gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 65535);",
          "1700:   fseek(ifp, data_offset, SEEK_SET);",
          "1701:   unsigned char *buf = (unsigned char *)malloc(bufsize);",
          "1703:   for (int row = 0; row < raw_height; row++)",
          "1704:   {",
          "1705:     int red = fread(buf, 1, bufsize, ifp);",
          "1706:     unsigned short(*ip)[4] = (unsigned short(*)[4])image + row * width;",
          "1707:     if (tiff_bps <= 8)",
          "1708:       for (int col = 0; col < width; col++)",
          "1709:       {",
          "1710:         ip[col][0] = curve[buf[col * 3]];",
          "1711:         ip[col][1] = curve[buf[col * 3 + 1]];",
          "1712:         ip[col][2] = curve[buf[col * 3 + 2]];",
          "1713:         ip[col][3] = 0;",
          "1714:       }",
          "1715:     else",
          "1716:       for (int col = 0; col < width; col++)",
          "1717:       {",
          "1718:         ip[col][0] = curve[ubuf[col * 3]];",
          "1719:         ip[col][1] = curve[ubuf[col * 3 + 1]];",
          "1720:         ip[col][2] = curve[ubuf[col * 3 + 2]];",
          "1721:         ip[col][3] = 0;",
          "1722:       }",
          "1723:   }",
          "1724:   free(buf);",
          "1732:        5, 4, 3, 6, 2, 7, 1, 0, 8, 9, 11, 10, 12},",
          "1734:        0x39, 0x5a, 0x38, 0x27, 0x16, 5, 4, 3, 2, 1, 0, 11, 12, 12},",
          "1736:        5, 4, 6, 3, 7, 2, 8, 1, 9, 0, 10, 11, 12},",
          "1738:        5, 6, 4, 7, 8, 3, 9, 2, 1, 0, 10, 11, 12, 13, 14},",
          "1740:        8, 0x5c, 0x4b, 0x3a, 0x29, 7, 6, 5, 4, 3, 2, 1, 0, 13, 14},",
          "1742:        7, 6, 8, 5, 9, 4, 10, 3, 11, 12, 2, 0, 1, 13, 14}};",
          "1744:   int i, min, max, step = 0, tree = 0, split = 0, row, col, len, shl, diff;",
          "1746:   fseek(ifp, meta_offset, SEEK_SET);",
          "1750:     fseek(ifp, 2110, SEEK_CUR);",
          "1751:   if (ver0 == 0x46)",
          "1752:     tree = 2;",
          "1753:   if (tiff_bps == 14)",
          "1754:     tree += 3;",
          "1755:   read_shorts(vpred[0], 4);",
          "1758:     step = max / (csize - 1);",
          "1759:   if (ver0 == 0x44 && ver1 == 0x20 && step > 0)",
          "1760:   {",
          "1761:     for (i = 0; i < csize; i++)",
          "1762:       curve[i * step] = get2();",
          "1763:     for (i = 0; i < max; i++)",
          "1764:       curve[i] = (curve[i - i % step] * (step - i % step) + curve[i - i % step + step] * (i % step)) / step;",
          "1765:     fseek(ifp, meta_offset + 562, SEEK_SET);",
          "1767:   }",
          "1768:   else if (ver0 != 0x46 && csize <= 0x4001)",
          "1769:     read_shorts(curve, max = csize);",
          "1770:   while (curve[max - 2] == curve[max - 1])",
          "1771:     max--;",
          "1772:   huff = make_decoder(nikon_tree[tree]);",
          "1773:   fseek(ifp, data_offset, SEEK_SET);",
          "1776:   try",
          "1777:   {",
          "1779:     for (min = row = 0; row < height; row++)",
          "1780:     {",
          "1782:       checkCancel();",
          "1784:       if (split && row == split)",
          "1785:       {",
          "1786:         free(huff);",
          "1787:         huff = make_decoder(nikon_tree[tree + 1]);",
          "1788:         max += (min = 16) << 1;",
          "1789:       }",
          "1790:       for (col = 0; col < raw_width; col++)",
          "1791:       {",
          "1792:         i = gethuff(huff);",
          "1793:         len = i & 15;",
          "1794:         shl = i >> 4;",
          "1795:         diff = ((getbits(len - shl) << 1) + 1) << shl >> 1;",
          "1796:         if ((diff & (1 << (len - 1))) == 0)",
          "1797:           diff -= (1 << len) - !shl;",
          "1798:         if (col < 2)",
          "1799:           hpred[col] = vpred[row & 1][col] += diff;",
          "1800:         else",
          "1801:           hpred[col & 1] += diff;",
          "1802:         if ((ushort)(hpred[col & 1] + min) >= max)",
          "1803:           derror();",
          "1804:         RAW(row, col) = curve[LIM((short)hpred[col & 1], 0, 0x3fff)];",
          "1805:       }",
          "1808:   }",
          "1809:   catch (...)",
          "1810:   {",
          "1811:     free(huff);",
          "1815:   free(huff);",
          "1821:   UINT64 bitbuf = 0;",
          "1823:   FORC4 { cmul[c] = cam_mul[c] > 0.001f ? cam_mul[c] : 1.f; }",
          "1824:   for (row = 0; row < raw_height; row++)",
          "1830:     for (col = 0; col < raw_width; col++)",
          "1831:     {",
          "1832:       if (!(b = col & 1))",
          "1833:       {",
          "1834:         bitbuf = 0;",
          "1835:         FORC(6) bitbuf |= (UINT64)fgetc(ifp) << c * 8;",
          "1836:         FORC(4) yuv[c] = (bitbuf >> c * 12 & 0xfff) - (c >> 1 << 11);",
          "1838:       rgb[0] = yuv[b] + 1.370705 * yuv[3];",
          "1839:       rgb[1] = yuv[b] - 0.337633 * yuv[2] - 0.698001 * yuv[3];",
          "1840:       rgb[2] = yuv[b] + 1.732446 * yuv[2];",
          "1841:       FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 0xfff)] / cmul[c];",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1653: int CLASS nikon_e995()",
          "1654: {",
          "1655:   int i, histo[256];",
          "1661:     histo[fgetc(ifp)]++;",
          "1663:     if (histo[often[i]] < 200)",
          "1664:       return 0;",
          "1665:   return 1;",
          "",
          "[Removed Lines]",
          "1656:   const uchar often[] = { 0x00, 0x55, 0xaa, 0xff };",
          "1658:   memset (histo, 0, sizeof histo);",
          "1659:   fseek (ifp, -2000, SEEK_END);",
          "1660:   for (i=0; i < 2000; i++)",
          "1662:   for (i=0; i < 4; i++)",
          "",
          "[Added Lines]",
          "1852:   const uchar often[] = {0x00, 0x55, 0xaa, 0xff};",
          "1854:   memset(histo, 0, sizeof histo);",
          "1855:   fseek(ifp, -2000, SEEK_END);",
          "1856:   for (i = 0; i < 2000; i++)",
          "1858:   for (i = 0; i < 4; i++)",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1673:   uchar t[12];",
          "1674:   int i;",
          "1681:       return 0;",
          "1682:   }",
          "1683:   return 1;",
          "",
          "[Removed Lines]",
          "1676:   fseek (ifp, 0, SEEK_SET);",
          "1677:   for (i=0; i < 1024; i++) {",
          "1678:     fread (t, 1, 12, ifp);",
          "1679:     if (((t[2] & t[4] & t[7] & t[9]) >> 4",
          "1680:  & t[1] & t[6] & t[8] & t[11] & 3) != 3)",
          "",
          "[Added Lines]",
          "1872:   fseek(ifp, 0, SEEK_SET);",
          "1873:   for (i = 0; i < 1024; i++)",
          "1874:   {",
          "1875:     fread(t, 1, 12, ifp);",
          "1876:     if (((t[2] & t[4] & t[7] & t[9]) >> 4 & t[1] & t[6] & t[8] & t[11] & 3) != 3)",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1687: {",
          "1688:   int bits, i;",
          "1689:   uchar dp[24];",
          "1691:     int bits;",
          "1692:     char t_make[12], t_model[15];",
          "1693:   } table[] = {",
          "1701:   bits = (dp[8] & 3) << 4 | (dp[20] & 3);",
          "1706:     }",
          "1707: }",
          "",
          "[Removed Lines]",
          "1690:   static const struct {",
          "1694:     { 0x00, \"Pentax\",  \"Optio 33WR\" },",
          "1695:     { 0x03, \"Nikon\",   \"E3200\" },",
          "1696:     { 0x32, \"Nikon\",   \"E3700\" },",
          "1697:     { 0x33, \"Olympus\", \"C740UZ\" } };",
          "1699:   fseek (ifp, 3072, SEEK_SET);",
          "1700:   fread (dp, 1, 24, ifp);",
          "1702:   for (i=0; i < sizeof table / sizeof *table; i++)",
          "1703:     if (bits == table[i].bits) {",
          "1704:       strcpy (make,  table[i].t_make );",
          "1705:       strcpy (model, table[i].t_model);",
          "",
          "[Added Lines]",
          "1886:   static const struct",
          "1887:   {",
          "1891:       {0x00, \"Pentax\", \"Optio 33WR\"}, {0x03, \"Nikon\", \"E3200\"}, {0x32, \"Nikon\", \"E3700\"}, {0x33, \"Olympus\", \"C740UZ\"}};",
          "1893:   fseek(ifp, 3072, SEEK_SET);",
          "1894:   fread(dp, 1, 24, ifp);",
          "1896:   for (i = 0; i < sizeof table / sizeof *table; i++)",
          "1897:     if (bits == table[i].bits)",
          "1898:     {",
          "1899:       strcpy(make, table[i].t_make);",
          "1900:       strcpy(model, table[i].t_model);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1714:   int i, nz;",
          "1715:   char tail[424];",
          "1721:   return nz > 20;",
          "1722: }",
          "",
          "[Removed Lines]",
          "1717:   fseek (ifp, -sizeof tail, SEEK_END);",
          "1718:   fread (tail, 1, sizeof tail, ifp);",
          "1719:   for (nz=i=0; i < sizeof tail; i++)",
          "1720:     if (tail[i]) nz++;",
          "",
          "[Added Lines]",
          "1912:   fseek(ifp, -sizeof tail, SEEK_END);",
          "1913:   fread(tail, 1, sizeof tail, ifp);",
          "1914:   for (nz = i = 0; i < sizeof tail; i++)",
          "1915:     if (tail[i])",
          "1916:       nz++;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1728: void CLASS ppm_thumb()",
          "1729: {",
          "1730:   char *thumb;",
          "1738: }",
          "1740: void CLASS ppm16_thumb()",
          "1741: {",
          "1742:   int i;",
          "1743:   char *thumb;",
          "1753: }",
          "1755: void CLASS layer_thumb()",
          "1756: {",
          "1757:   int i, c;",
          "1760:   colors = thumb_misc >> 5 & 7;",
          "1770: }",
          "1772: void CLASS rollei_thumb()",
          "",
          "[Removed Lines]",
          "1731:   thumb_length = thumb_width*thumb_height*3;",
          "1732:   thumb = (char *) malloc (thumb_length);",
          "1733:   merror (thumb, \"ppm_thumb()\");",
          "1734:   fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);",
          "1735:   fread  (thumb, 1, thumb_length, ifp);",
          "1736:   fwrite (thumb, 1, thumb_length, ofp);",
          "1737:   free (thumb);",
          "1744:   thumb_length = thumb_width*thumb_height*3;",
          "1745:   thumb = (char *) calloc (thumb_length, 2);",
          "1746:   merror (thumb, \"ppm16_thumb()\");",
          "1747:   read_shorts ((ushort *) thumb, thumb_length);",
          "1748:   for (i=0; i < thumb_length; i++)",
          "1749:     thumb[i] = ((ushort *) thumb)[i] >> 8;",
          "1750:   fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);",
          "1751:   fwrite (thumb, 1, thumb_length, ofp);",
          "1752:   free (thumb);",
          "1758:   char *thumb, map[][4] = { \"012\",\"102\" };",
          "1761:   thumb_length = thumb_width*thumb_height;",
          "1762:   thumb = (char *) calloc (colors, thumb_length);",
          "1763:   merror (thumb, \"layer_thumb()\");",
          "1764:   fprintf (ofp, \"P%d\\n%d %d\\n255\\n\",",
          "1765:  5 + (colors >> 1), thumb_width, thumb_height);",
          "1766:   fread (thumb, thumb_length, colors, ifp);",
          "1767:   for (i=0; i < thumb_length; i++)",
          "1768:     FORCC putc (thumb[i+thumb_length*(map[thumb_misc >> 8][c]-'0')], ofp);",
          "1769:   free (thumb);",
          "",
          "[Added Lines]",
          "1927:   thumb_length = thumb_width * thumb_height * 3;",
          "1928:   thumb = (char *)malloc(thumb_length);",
          "1929:   merror(thumb, \"ppm_thumb()\");",
          "1930:   fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);",
          "1931:   fread(thumb, 1, thumb_length, ifp);",
          "1932:   fwrite(thumb, 1, thumb_length, ofp);",
          "1933:   free(thumb);",
          "1940:   thumb_length = thumb_width * thumb_height * 3;",
          "1941:   thumb = (char *)calloc(thumb_length, 2);",
          "1942:   merror(thumb, \"ppm16_thumb()\");",
          "1943:   read_shorts((ushort *)thumb, thumb_length);",
          "1944:   for (i = 0; i < thumb_length; i++)",
          "1945:     thumb[i] = ((ushort *)thumb)[i] >> 8;",
          "1946:   fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);",
          "1947:   fwrite(thumb, 1, thumb_length, ofp);",
          "1948:   free(thumb);",
          "1954:   char *thumb, map[][4] = {\"012\", \"102\"};",
          "1957:   thumb_length = thumb_width * thumb_height;",
          "1958:   thumb = (char *)calloc(colors, thumb_length);",
          "1959:   merror(thumb, \"layer_thumb()\");",
          "1960:   fprintf(ofp, \"P%d\\n%d %d\\n255\\n\", 5 + (colors >> 1), thumb_width, thumb_height);",
          "1961:   fread(thumb, thumb_length, colors, ifp);",
          "1962:   for (i = 0; i < thumb_length; i++)",
          "1963:     FORCC putc(thumb[i + thumb_length * (map[thumb_misc >> 8][c] - '0')], ofp);",
          "1964:   free(thumb);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1775:   ushort *thumb;",
          "1777:   thumb_length = thumb_width * thumb_height;",
          "1788: }",
          "1790: void CLASS rollei_load_raw()",
          "1791: {",
          "1792:   uchar pixel[10];",
          "1795:   isix = raw_width * raw_height * 5 / 8;",
          "1797: #ifdef LIBRAW_LIBRARY_BUILD",
          "1798:     checkCancel();",
          "1799: #endif",
          "1804:     }",
          "1808:     }",
          "1811:   }",
          "1812:   maximum = 0x3ff;",
          "1813: }",
          "1821: {",
          "1822:   ushort head[8];",
          "1823:   unsigned wide, high, y, x, c, rend, cend, row, col;",
          "1824:   float *mrow, num, mult[4];",
          "1828:   wide = head[2] / head[4] + (head[2] % head[4] != 0);",
          "1829:   high = head[3] / head[5] + (head[3] % head[5] != 0);",
          "1833: #ifdef LIBRAW_LIBRARY_BUILD",
          "1834:     checkCancel();",
          "1835: #endif",
          "1871: }",
          "1873: int CLASS phase_one_correct()",
          "1874: {",
          "1875:   unsigned entries, tag, data, save, col, row, type;",
          "1876:   int len, i, j, k, cip, val[4], dev[4], sum, max;",
          "1882:   ushort *xval[2];",
          "1883:   int qmult_applied = 0, qlin_applied = 0;",
          "1886: #ifdef DCRAW_VERBOSE",
          "1888: #endif",
          "1890:   order = get2();",
          "1895: #ifdef LIBRAW_LIBRARY_BUILD",
          "1897: #endif",
          "1899: #ifdef LIBRAW_LIBRARY_BUILD",
          "1901: #endif",
          "1925: #ifdef LIBRAW_LIBRARY_BUILD",
          "1927: #endif",
          "2002:           {",
          "2003: #ifdef LIBRAW_LIBRARY_BUILD",
          "2005: #endif",
          "2009:           }",
          "2025: #ifdef LIBRAW_LIBRARY_BUILD",
          "2027: #endif",
          "2055:           {",
          "2056: #ifdef LIBRAW_LIBRARY_BUILD",
          "2058: #endif",
          "2062:           }",
          "2063:         }",
          "2064:       }",
          "2067:     }",
          "2086:     {",
          "2087: #ifdef LIBRAW_LIBRARY_BUILD",
          "2089: #endif",
          "2103:       }",
          "2104:     }",
          "2107: #ifdef LIBRAW_LIBRARY_BUILD",
          "2108:   }",
          "2109:   catch (...)",
          "2110:   {",
          "2112:     return LIBRAW_CANCELLED_BY_CALLBACK;",
          "2113:   }",
          "2114: #endif",
          "",
          "[Removed Lines]",
          "1778:   thumb = (ushort *) calloc (thumb_length, 2);",
          "1779:   merror (thumb, \"rollei_thumb()\");",
          "1780:   fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);",
          "1781:   read_shorts (thumb, thumb_length);",
          "1782:   for (i=0; i < thumb_length; i++) {",
          "1783:     putc (thumb[i] << 3, ofp);",
          "1784:     putc (thumb[i] >> 5  << 2, ofp);",
          "1785:     putc (thumb[i] >> 11 << 3, ofp);",
          "1786:   }",
          "1787:   free (thumb);",
          "1793:   unsigned iten=0, isix, i, buffer=0, todo[16];",
          "1796:   while (fread (pixel, 1, 10, ifp) == 10) {",
          "1800:     for (i=0; i < 10; i+=2) {",
          "1801:       todo[i]   = iten++;",
          "1802:       todo[i+1] = pixel[i] << 8 | pixel[i+1];",
          "1803:       buffer    = pixel[i] >> 2 | buffer << 6;",
          "1805:     for (   ; i < 16; i+=2) {",
          "1806:       todo[i]   = isix++;",
          "1807:       todo[i+1] = buffer >> (14-i)*5;",
          "1809:     for (i=0; i < 16; i+=2)",
          "1810:       raw_image[todo[i]] = (todo[i+1] & 0x3ff);",
          "1815: int CLASS raw (unsigned row, unsigned col)",
          "1816: {",
          "1817:   return (row < raw_height && col < raw_width) ? RAW(row,col) : 0;",
          "1818: }",
          "1820: void CLASS phase_one_flat_field (int is_float, int nc)",
          "1826:   read_shorts (head, 8);",
          "1827:   if (head[2] * head[3] * head[4] * head[5] == 0) return;",
          "1830:   mrow = (float *) calloc (nc*wide, sizeof *mrow);",
          "1831:   merror (mrow, \"phase_one_flat_field()\");",
          "1832:   for (y=0; y < high; y++) {",
          "1836:     for (x=0; x < wide; x++)",
          "1837:       for (c=0; c < nc; c+=2) {",
          "1838:  num = is_float ? getreal(11) : get2()/32768.0;",
          "1839:  if (y==0) mrow[c*wide+x] = num;",
          "1840:  else mrow[(c+1)*wide+x] = (num - mrow[c*wide+x]) / head[5];",
          "1841:       }",
          "1842:     if (y==0) continue;",
          "1843:     rend = head[1] + y*head[5];",
          "1844:     for (row = rend-head[5];",
          "1845:   row < raw_height && row < rend &&",
          "1846:   row < head[1]+head[3]-head[5]; row++) {",
          "1847:       for (x=1; x < wide; x++) {",
          "1848:  for (c=0; c < nc; c+=2) {",
          "1849:    mult[c] = mrow[c*wide+x-1];",
          "1850:    mult[c+1] = (mrow[c*wide+x] - mult[c]) / head[4];",
          "1851:  }",
          "1852:  cend = head[0] + x*head[4];",
          "1853:  for (col = cend-head[4];",
          "1854:       col < raw_width &&",
          "1855:       col < cend && col < head[0]+head[2]-head[4]; col++) {",
          "1856:    c = nc > 2 ? FC(row-top_margin,col-left_margin) : 0;",
          "1857:    if (!(c & 1)) {",
          "1858:      c = RAW(row,col) * mult[c];",
          "1859:      RAW(row,col) = LIM(c,0,65535);",
          "1860:    }",
          "1861:    for (c=0; c < nc; c+=2)",
          "1862:      mult[c] += mult[c+1];",
          "1863:  }",
          "1864:       }",
          "1865:       for (x=0; x < wide; x++)",
          "1866:  for (c=0; c < nc; c+=2)",
          "1867:    mrow[c*wide+x] += mrow[(c+1)*wide+x];",
          "1868:     }",
          "1869:   }",
          "1870:   free (mrow);",
          "1877:   int head[9], diff, mindiff=INT_MAX, off_412=0;",
          "1879:     { {-1,-1}, {-1,1}, {1,-1}, {1,1}, {-2,0}, {0,-2}, {0,2}, {2,0},",
          "1880:       {-2,-2}, {-2,2}, {2,-2}, {2,2} };",
          "1881:   float poly[8], num, cfrac, frac, mult[2], *yval[2]={NULL,NULL};",
          "1885:   if (half_size || !meta_length) return 0;",
          "1887:   if (verbose) fprintf (stderr,_(\"Phase One correction...\\n\"));",
          "1889:   fseek (ifp, meta_offset, SEEK_SET);",
          "1891:   fseek (ifp, 6, SEEK_CUR);",
          "1892:   fseek (ifp, meta_offset+get4(), SEEK_SET);",
          "1893:   entries = get4();  get4();",
          "1896:   try {",
          "1898:   while (entries--) {",
          "1900:     checkCancel();",
          "1902:     tag  = get4();",
          "1903:     len  = get4();",
          "1904:     data = get4();",
          "1905:     save = ftell(ifp);",
          "1906:     fseek (ifp, meta_offset+data, SEEK_SET);",
          "1908:       for (get4(), i=0; i < 8; i++)",
          "1909:  poly[i] = getreal(11);",
          "1910:       poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;",
          "1911:       for (i=0; i < 0x10000; i++) {",
          "1912:  num = (poly[5]*i + poly[3])*i + poly[1];",
          "1913:  curve[i] = LIM(num,0,65535);",
          "1916:       for (i=0; i < 4; i++)",
          "1917:  poly[i] = getreal(11);",
          "1918:       for (i=0; i < 0x10000; i++) {",
          "1919:  for (num=0, j=4; j--; )",
          "1920:    num = num * i + poly[j];",
          "1921:  curve[i] = LIM(num+i,0,65535);",
          "1923:       for (row=0; row < raw_height; row++)",
          "1924:       {",
          "1926:         checkCancel();",
          "1928:  for (col = (tag & 1)*ph1.split_col; col < raw_width; col++)",
          "1929:    RAW(row,col) = curve[RAW(row,col)];",
          "1930:       }",
          "1932:       while ((len -= 8) >= 0) {",
          "1933:  col  = get2();",
          "1934:  row  = get2();",
          "1935:  type = get2(); get2();",
          "1936:  if (col >= raw_width) continue;",
          "1938:    for (row=0; row < raw_height; row++)",
          "1939:      if (FC(row-top_margin,col-left_margin) == 1) {",
          "1940:        for (sum=i=0; i < 4; i++)",
          "1941:   sum += val[i] = raw (row+dir[i][0], col+dir[i][1]);",
          "1942:        for (max=i=0; i < 4; i++) {",
          "1943:   dev[i] = abs((val[i] << 2) - sum);",
          "1944:   if (dev[max] < dev[i]) max = i;",
          "1945:        }",
          "1946:        RAW(row,col) = (sum - val[max])/3.0 + 0.5;",
          "1947:      } else {",
          "1948:        for (sum=0, i=8; i < 12; i++)",
          "1949:   sum += raw (row+dir[i][0], col+dir[i][1]);",
          "1950:        RAW(row,col) = 0.5 + sum * 0.0732233 +",
          "1951:   (raw(row,col-2) + raw(row,col+2)) * 0.3535534;",
          "1952:      }",
          "1954:    if (row >= raw_height) continue;",
          "1955:    j = (FC(row-top_margin,col-left_margin) != 1) * 4;",
          "1956:    for (sum=0, i=j; i < j+8; i++)",
          "1957:      sum += raw (row+dir[i][0], col+dir[i][1]);",
          "1958:    RAW(row,col) = (sum + 4) >> 3;",
          "1959:  }",
          "1960:       }",
          "1962:       phase_one_flat_field (1, 2);",
          "1963:     } else if (tag == 0x416 || tag == 0x410) {",
          "1964:       phase_one_flat_field (0, 2);",
          "1966:       phase_one_flat_field (0, 4);",
          "1967:     } else if (tag == 0x412) {",
          "1968:       fseek (ifp, 36, SEEK_CUR);",
          "1969:       diff = abs (get2() - ph1.tag_21a);",
          "1970:       if (mindiff > diff) {",
          "1971:  mindiff = diff;",
          "1972:  off_412 = ftell(ifp) - 38;",
          "1973:       }",
          "1975:       ushort lc[2][2][16], ref[16];",
          "1976:       int qr, qc;",
          "1977:       for (qr = 0; qr < 2; qr++)",
          "1978:  for (qc = 0; qc < 2; qc++)",
          "1979:    for (i = 0; i < 16; i++)",
          "1980:      lc[qr][qc][i] = get4();",
          "1981:       for (i = 0; i < 16; i++) {",
          "1982:  int v = 0;",
          "1983:  for (qr = 0; qr < 2; qr++)",
          "1984:    for (qc = 0; qc < 2; qc++)",
          "1985:      v += lc[qr][qc][i];",
          "1986:  ref[i] = (v + 2) >> 2;",
          "1987:       }",
          "1988:       for (qr = 0; qr < 2; qr++) {",
          "1989:  for (qc = 0; qc < 2; qc++) {",
          "1990:    int cx[19], cf[19];",
          "1991:    for (i = 0; i < 16; i++) {",
          "1992:      cx[1+i] = lc[qr][qc][i];",
          "1993:      cf[1+i] = ref[i];",
          "1994:    }",
          "1995:    cx[0] = cf[0] = 0;",
          "1996:    cx[17] = cf[17] = ((unsigned int)ref[15] * 65535) / lc[qr][qc][15];",
          "1997:           cf[18] = cx[18] = 65535;",
          "1998:    cubic_spline(cx, cf, 19);",
          "2000:    for (row = (qr ? ph1.split_row : 0);",
          "2001:         row < (qr ? raw_height : ph1.split_row); row++)",
          "2004:             checkCancel();",
          "2006:      for (col = (qc ? ph1.split_col : 0);",
          "2007:    col < (qc ? raw_width : ph1.split_col); col++)",
          "2008:        RAW(row,col) = curve[RAW(row,col)];",
          "2010:  }",
          "2011:       }",
          "2012:       qlin_applied = 1;",
          "2014:       float qmult[2][2] = { { 1, 1 }, { 1, 1 } };",
          "2015:       get4(); get4(); get4(); get4();",
          "2016:       qmult[0][0] = 1.0 + getreal(11);",
          "2017:       get4(); get4(); get4(); get4(); get4();",
          "2018:       qmult[0][1] = 1.0 + getreal(11);",
          "2019:       get4(); get4(); get4();",
          "2020:       qmult[1][0] = 1.0 + getreal(11);",
          "2021:       get4(); get4(); get4();",
          "2022:       qmult[1][1] = 1.0 + getreal(11);",
          "2023:       for (row=0; row < raw_height; row++)",
          "2024:       {",
          "2026:         checkCancel();",
          "2028:  for (col=0; col < raw_width; col++) {",
          "2029:    i = qmult[row >= ph1.split_row][col >= ph1.split_col] * RAW(row,col);",
          "2030:    RAW(row,col) = LIM(i,0,65535);",
          "2031:  }",
          "2032:       }",
          "2033:       qmult_applied = 1;",
          "2035:       ushort lc[2][2][7], ref[7];",
          "2036:       int qr, qc;",
          "2037:       for (i = 0; i < 7; i++)",
          "2038:  ref[i] = get4();",
          "2039:       for (qr = 0; qr < 2; qr++)",
          "2040:  for (qc = 0; qc < 2; qc++)",
          "2041:    for (i = 0; i < 7; i++)",
          "2042:      lc[qr][qc][i] = get4();",
          "2043:       for (qr = 0; qr < 2; qr++) {",
          "2044:  for (qc = 0; qc < 2; qc++) {",
          "2045:    int cx[9], cf[9];",
          "2046:    for (i = 0; i < 7; i++) {",
          "2047:      cx[1+i] = ref[i];",
          "2048:      cf[1+i] = ((unsigned) ref[i] * lc[qr][qc][i]) / 10000;",
          "2049:    }",
          "2050:    cx[0] = cf[0] = 0;",
          "2051:    cx[8] = cf[8] = 65535;",
          "2052:    cubic_spline(cx, cf, 9);",
          "2053:    for (row = (qr ? ph1.split_row : 0);",
          "2054:         row < (qr ? raw_height : ph1.split_row); row++)",
          "2057:             checkCancel();",
          "2059:      for (col = (qc ? ph1.split_col : 0);",
          "2060:    col < (qc ? raw_width : ph1.split_col); col++)",
          "2061:        RAW(row,col) = curve[RAW(row,col)];",
          "2065:       qmult_applied = 1;",
          "2066:       qlin_applied = 1;",
          "2068:     fseek (ifp, save, SEEK_SET);",
          "2069:   }",
          "2070:   if (off_412) {",
          "2071:     fseek (ifp, off_412, SEEK_SET);",
          "2072:     for (i=0; i < 9; i++) head[i] = get4() & 0x7fff;",
          "2073:     yval[0] = (float *) calloc (head[1]*head[3] + head[2]*head[4], 6);",
          "2074:     merror (yval[0], \"phase_one_correct()\");",
          "2075:     yval[1] = (float  *) (yval[0] + head[1]*head[3]);",
          "2076:     xval[0] = (ushort *) (yval[1] + head[2]*head[4]);",
          "2077:     xval[1] = (ushort *) (xval[0] + head[1]*head[3]);",
          "2078:     get2();",
          "2079:     for (i=0; i < 2; i++)",
          "2080:       for (j=0; j < head[i+1]*head[i+3]; j++)",
          "2081:  yval[i][j] = getreal(11);",
          "2082:     for (i=0; i < 2; i++)",
          "2083:       for (j=0; j < head[i+1]*head[i+3]; j++)",
          "2084:  xval[i][j] = get2();",
          "2085:     for (row=0; row < raw_height; row++)",
          "2088:       checkCancel();",
          "2090:       for (col=0; col < raw_width; col++) {",
          "2091:  cfrac = (float) col * head[3] / raw_width;",
          "2092:  cfrac -= cip = cfrac;",
          "2093:  num = RAW(row,col) * 0.5;",
          "2094:  for (i=cip; i < cip+2; i++) {",
          "2095:    for (k=j=0; j < head[1]; j++)",
          "2096:      if (num < xval[0][k = head[1]*i+j]) break;",
          "2097:    frac = (j == 0 || j == head[1]) ? 0 :",
          "2098:   (xval[0][k] - num) / (xval[0][k] - xval[0][k-1]);",
          "2099:    mult[i-cip] = yval[0][k-1] * frac + yval[0][k] * (1-frac);",
          "2100:  }",
          "2101:  i = ((mult[0] * (1-cfrac) + mult[1] * cfrac) * row + num) * 2;",
          "2102:  RAW(row,col) = LIM(i,0,65535);",
          "2105:     free (yval[0]);",
          "2106:   }",
          "2111:     if(yval[0]) free(yval[0]);",
          "",
          "[Added Lines]",
          "1973:   thumb = (ushort *)calloc(thumb_length, 2);",
          "1974:   merror(thumb, \"rollei_thumb()\");",
          "1975:   fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);",
          "1976:   read_shorts(thumb, thumb_length);",
          "1977:   for (i = 0; i < thumb_length; i++)",
          "1978:   {",
          "1979:     putc(thumb[i] << 3, ofp);",
          "1980:     putc(thumb[i] >> 5 << 2, ofp);",
          "1981:     putc(thumb[i] >> 11 << 3, ofp);",
          "1982:   }",
          "1983:   free(thumb);",
          "1989:   unsigned iten = 0, isix, i, buffer = 0, todo[16];",
          "1992:   while (fread(pixel, 1, 10, ifp) == 10)",
          "1993:   {",
          "1997:     for (i = 0; i < 10; i += 2)",
          "1998:     {",
          "1999:       todo[i] = iten++;",
          "2000:       todo[i + 1] = pixel[i] << 8 | pixel[i + 1];",
          "2001:       buffer = pixel[i] >> 2 | buffer << 6;",
          "2003:     for (; i < 16; i += 2)",
          "2004:     {",
          "2005:       todo[i] = isix++;",
          "2006:       todo[i + 1] = buffer >> (14 - i) * 5;",
          "2008:     for (i = 0; i < 16; i += 2)",
          "2009:       raw_image[todo[i]] = (todo[i + 1] & 0x3ff);",
          "2014: int CLASS raw(unsigned row, unsigned col) { return (row < raw_height && col < raw_width) ? RAW(row, col) : 0; }",
          "2016: void CLASS phase_one_flat_field(int is_float, int nc)",
          "2022:   read_shorts(head, 8);",
          "2023:   if (head[2] * head[3] * head[4] * head[5] == 0)",
          "2024:     return;",
          "2027:   mrow = (float *)calloc(nc * wide, sizeof *mrow);",
          "2028:   merror(mrow, \"phase_one_flat_field()\");",
          "2029:   for (y = 0; y < high; y++)",
          "2030:   {",
          "2034:     for (x = 0; x < wide; x++)",
          "2035:       for (c = 0; c < nc; c += 2)",
          "2036:       {",
          "2037:         num = is_float ? getreal(11) : get2() / 32768.0;",
          "2038:         if (y == 0)",
          "2039:           mrow[c * wide + x] = num;",
          "2040:         else",
          "2041:           mrow[(c + 1) * wide + x] = (num - mrow[c * wide + x]) / head[5];",
          "2042:       }",
          "2043:     if (y == 0)",
          "2044:       continue;",
          "2045:     rend = head[1] + y * head[5];",
          "2046:     for (row = rend - head[5]; row < raw_height && row < rend && row < head[1] + head[3] - head[5]; row++)",
          "2047:     {",
          "2048:       for (x = 1; x < wide; x++)",
          "2049:       {",
          "2050:         for (c = 0; c < nc; c += 2)",
          "2051:         {",
          "2052:           mult[c] = mrow[c * wide + x - 1];",
          "2053:           mult[c + 1] = (mrow[c * wide + x] - mult[c]) / head[4];",
          "2054:         }",
          "2055:         cend = head[0] + x * head[4];",
          "2056:         for (col = cend - head[4]; col < raw_width && col < cend && col < head[0] + head[2] - head[4]; col++)",
          "2057:         {",
          "2058:           c = nc > 2 ? FC(row - top_margin, col - left_margin) : 0;",
          "2059:           if (!(c & 1))",
          "2060:           {",
          "2061:             c = RAW(row, col) * mult[c];",
          "2062:             RAW(row, col) = LIM(c, 0, 65535);",
          "2063:           }",
          "2064:           for (c = 0; c < nc; c += 2)",
          "2065:             mult[c] += mult[c + 1];",
          "2066:         }",
          "2067:       }",
          "2068:       for (x = 0; x < wide; x++)",
          "2069:         for (c = 0; c < nc; c += 2)",
          "2070:           mrow[c * wide + x] += mrow[(c + 1) * wide + x];",
          "2071:     }",
          "2072:   }",
          "2073:   free(mrow);",
          "2080:   int head[9], diff, mindiff = INT_MAX, off_412 = 0;",
          "2082:                                                {0, 2},   {2, 0},  {-2, -2}, {-2, 2}, {2, -2}, {2, 2}};",
          "2083:   float poly[8], num, cfrac, frac, mult[2], *yval[2] = {NULL, NULL};",
          "2087:   if (half_size || !meta_length)",
          "2088:     return 0;",
          "2090:   if (verbose)",
          "2091:     fprintf(stderr, _(\"Phase One correction...\\n\"));",
          "2093:   fseek(ifp, meta_offset, SEEK_SET);",
          "2095:   fseek(ifp, 6, SEEK_CUR);",
          "2096:   fseek(ifp, meta_offset + get4(), SEEK_SET);",
          "2097:   entries = get4();",
          "2098:   get4();",
          "2101:   try",
          "2102:   {",
          "2104:     while (entries--)",
          "2105:     {",
          "2107:       checkCancel();",
          "2109:       tag = get4();",
          "2110:       len = get4();",
          "2111:       data = get4();",
          "2112:       save = ftell(ifp);",
          "2113:       fseek(ifp, meta_offset + data, SEEK_SET);",
          "2114:       if (tag == 0x419)",
          "2116:         for (get4(), i = 0; i < 8; i++)",
          "2117:           poly[i] = getreal(11);",
          "2118:         poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;",
          "2119:         for (i = 0; i < 0x10000; i++)",
          "2120:         {",
          "2121:           num = (poly[5] * i + poly[3]) * i + poly[1];",
          "2122:           curve[i] = LIM(num, 0, 65535);",
          "2123:         }",
          "2125:       }",
          "2126:       else if (tag == 0x41a)",
          "2128:         for (i = 0; i < 4; i++)",
          "2129:           poly[i] = getreal(11);",
          "2130:         for (i = 0; i < 0x10000; i++)",
          "2131:         {",
          "2132:           for (num = 0, j = 4; j--;)",
          "2133:             num = num * i + poly[j];",
          "2134:           curve[i] = LIM(num + i, 0, 65535);",
          "2135:         }",
          "2137:         for (row = 0; row < raw_height; row++)",
          "2138:         {",
          "2140:           checkCancel();",
          "2142:           for (col = (tag & 1) * ph1.split_col; col < raw_width; col++)",
          "2143:             RAW(row, col) = curve[RAW(row, col)];",
          "2144:         }",
          "2145:       }",
          "2146:       else if (tag == 0x400)",
          "2148:         while ((len -= 8) >= 0)",
          "2149:         {",
          "2150:           col = get2();",
          "2151:           row = get2();",
          "2152:           type = get2();",
          "2153:           get2();",
          "2154:           if (col >= raw_width)",
          "2155:             continue;",
          "2157:             for (row = 0; row < raw_height; row++)",
          "2158:               if (FC(row - top_margin, col - left_margin) == 1)",
          "2159:               {",
          "2160:                 for (sum = i = 0; i < 4; i++)",
          "2161:                   sum += val[i] = raw(row + dir[i][0], col + dir[i][1]);",
          "2162:                 for (max = i = 0; i < 4; i++)",
          "2163:                 {",
          "2164:                   dev[i] = abs((val[i] << 2) - sum);",
          "2165:                   if (dev[max] < dev[i])",
          "2166:                     max = i;",
          "2167:                 }",
          "2168:                 RAW(row, col) = (sum - val[max]) / 3.0 + 0.5;",
          "2169:               }",
          "2170:               else",
          "2171:               {",
          "2172:                 for (sum = 0, i = 8; i < 12; i++)",
          "2173:                   sum += raw(row + dir[i][0], col + dir[i][1]);",
          "2174:                 RAW(row, col) = 0.5 + sum * 0.0732233 + (raw(row, col - 2) + raw(row, col + 2)) * 0.3535534;",
          "2175:               }",
          "2176:           else if (type == 129)",
          "2178:             if (row >= raw_height)",
          "2179:               continue;",
          "2180:             j = (FC(row - top_margin, col - left_margin) != 1) * 4;",
          "2181:             for (sum = 0, i = j; i < j + 8; i++)",
          "2182:               sum += raw(row + dir[i][0], col + dir[i][1]);",
          "2183:             RAW(row, col) = (sum + 4) >> 3;",
          "2184:           }",
          "2185:         }",
          "2186:       }",
          "2187:       else if (tag == 0x401)",
          "2189:         phase_one_flat_field(1, 2);",
          "2190:       }",
          "2191:       else if (tag == 0x416 || tag == 0x410)",
          "2192:       {",
          "2193:         phase_one_flat_field(0, 2);",
          "2194:       }",
          "2195:       else if (tag == 0x40b)",
          "2197:         phase_one_flat_field(0, 4);",
          "2198:       }",
          "2199:       else if (tag == 0x412)",
          "2200:       {",
          "2201:         fseek(ifp, 36, SEEK_CUR);",
          "2202:         diff = abs(get2() - ph1.tag_21a);",
          "2203:         if (mindiff > diff)",
          "2204:         {",
          "2205:           mindiff = diff;",
          "2206:           off_412 = ftell(ifp) - 38;",
          "2207:         }",
          "2208:       }",
          "2209:       else if (tag == 0x41f && !qlin_applied)",
          "2211:         ushort lc[2][2][16], ref[16];",
          "2212:         int qr, qc;",
          "2213:         for (qr = 0; qr < 2; qr++)",
          "2214:           for (qc = 0; qc < 2; qc++)",
          "2215:             for (i = 0; i < 16; i++)",
          "2216:               lc[qr][qc][i] = get4();",
          "2217:         for (i = 0; i < 16; i++)",
          "2218:         {",
          "2219:           int v = 0;",
          "2220:           for (qr = 0; qr < 2; qr++)",
          "2221:             for (qc = 0; qc < 2; qc++)",
          "2222:               v += lc[qr][qc][i];",
          "2223:           ref[i] = (v + 2) >> 2;",
          "2224:         }",
          "2225:         for (qr = 0; qr < 2; qr++)",
          "2226:         {",
          "2227:           for (qc = 0; qc < 2; qc++)",
          "2229:             int cx[19], cf[19];",
          "2230:             for (i = 0; i < 16; i++)",
          "2231:             {",
          "2232:               cx[1 + i] = lc[qr][qc][i];",
          "2233:               cf[1 + i] = ref[i];",
          "2234:             }",
          "2235:             cx[0] = cf[0] = 0;",
          "2236:             cx[17] = cf[17] = ((unsigned int)ref[15] * 65535) / lc[qr][qc][15];",
          "2237:             cf[18] = cx[18] = 65535;",
          "2238:             cubic_spline(cx, cf, 19);",
          "2240:             for (row = (qr ? ph1.split_row : 0); row < (qr ? raw_height : ph1.split_row); row++)",
          "2241:             {",
          "2243:               checkCancel();",
          "2245:               for (col = (qc ? ph1.split_col : 0); col < (qc ? raw_width : ph1.split_col); col++)",
          "2246:                 RAW(row, col) = curve[RAW(row, col)];",
          "2247:             }",
          "2249:         }",
          "2250:         qlin_applied = 1;",
          "2251:       }",
          "2252:       else if (tag == 0x41e && !qmult_applied)",
          "2254:         float qmult[2][2] = {{1, 1}, {1, 1}};",
          "2255:         get4();",
          "2256:         get4();",
          "2257:         get4();",
          "2258:         get4();",
          "2259:         qmult[0][0] = 1.0 + getreal(11);",
          "2260:         get4();",
          "2261:         get4();",
          "2262:         get4();",
          "2263:         get4();",
          "2264:         get4();",
          "2265:         qmult[0][1] = 1.0 + getreal(11);",
          "2266:         get4();",
          "2267:         get4();",
          "2268:         get4();",
          "2269:         qmult[1][0] = 1.0 + getreal(11);",
          "2270:         get4();",
          "2271:         get4();",
          "2272:         get4();",
          "2273:         qmult[1][1] = 1.0 + getreal(11);",
          "2274:         for (row = 0; row < raw_height; row++)",
          "2275:         {",
          "2277:           checkCancel();",
          "2279:           for (col = 0; col < raw_width; col++)",
          "2280:           {",
          "2281:             i = qmult[row >= ph1.split_row][col >= ph1.split_col] * RAW(row, col);",
          "2282:             RAW(row, col) = LIM(i, 0, 65535);",
          "2283:           }",
          "2284:         }",
          "2285:         qmult_applied = 1;",
          "2286:       }",
          "2287:       else if (tag == 0x431 && !qmult_applied)",
          "2289:         ushort lc[2][2][7], ref[7];",
          "2290:         int qr, qc;",
          "2291:         for (i = 0; i < 7; i++)",
          "2292:           ref[i] = get4();",
          "2293:         for (qr = 0; qr < 2; qr++)",
          "2294:           for (qc = 0; qc < 2; qc++)",
          "2295:             for (i = 0; i < 7; i++)",
          "2296:               lc[qr][qc][i] = get4();",
          "2297:         for (qr = 0; qr < 2; qr++)",
          "2298:         {",
          "2299:           for (qc = 0; qc < 2; qc++)",
          "2301:             int cx[9], cf[9];",
          "2302:             for (i = 0; i < 7; i++)",
          "2303:             {",
          "2304:               cx[1 + i] = ref[i];",
          "2305:               cf[1 + i] = ((unsigned)ref[i] * lc[qr][qc][i]) / 10000;",
          "2306:             }",
          "2307:             cx[0] = cf[0] = 0;",
          "2308:             cx[8] = cf[8] = 65535;",
          "2309:             cubic_spline(cx, cf, 9);",
          "2310:             for (row = (qr ? ph1.split_row : 0); row < (qr ? raw_height : ph1.split_row); row++)",
          "2311:             {",
          "2313:               checkCancel();",
          "2315:               for (col = (qc ? ph1.split_col : 0); col < (qc ? raw_width : ph1.split_col); col++)",
          "2316:                 RAW(row, col) = curve[RAW(row, col)];",
          "2317:             }",
          "2320:         qmult_applied = 1;",
          "2321:         qlin_applied = 1;",
          "2323:       fseek(ifp, save, SEEK_SET);",
          "2325:     if (off_412)",
          "2327:       fseek(ifp, off_412, SEEK_SET);",
          "2328:       for (i = 0; i < 9; i++)",
          "2329:         head[i] = get4() & 0x7fff;",
          "2330:       yval[0] = (float *)calloc(head[1] * head[3] + head[2] * head[4], 6);",
          "2331:       merror(yval[0], \"phase_one_correct()\");",
          "2332:       yval[1] = (float *)(yval[0] + head[1] * head[3]);",
          "2333:       xval[0] = (ushort *)(yval[1] + head[2] * head[4]);",
          "2334:       xval[1] = (ushort *)(xval[0] + head[1] * head[3]);",
          "2335:       get2();",
          "2336:       for (i = 0; i < 2; i++)",
          "2337:         for (j = 0; j < head[i + 1] * head[i + 3]; j++)",
          "2338:           yval[i][j] = getreal(11);",
          "2339:       for (i = 0; i < 2; i++)",
          "2340:         for (j = 0; j < head[i + 1] * head[i + 3]; j++)",
          "2341:           xval[i][j] = get2();",
          "2342:       for (row = 0; row < raw_height; row++)",
          "2343:       {",
          "2345:         checkCancel();",
          "2347:         for (col = 0; col < raw_width; col++)",
          "2348:         {",
          "2349:           cfrac = (float)col * head[3] / raw_width;",
          "2350:           cfrac -= cip = cfrac;",
          "2351:           num = RAW(row, col) * 0.5;",
          "2352:           for (i = cip; i < cip + 2; i++)",
          "2353:           {",
          "2354:             for (k = j = 0; j < head[1]; j++)",
          "2355:               if (num < xval[0][k = head[1] * i + j])",
          "2356:                 break;",
          "2357:             frac = (j == 0 || j == head[1]) ? 0 : (xval[0][k] - num) / (xval[0][k] - xval[0][k - 1]);",
          "2358:             mult[i - cip] = yval[0][k - 1] * frac + yval[0][k] * (1 - frac);",
          "2359:           }",
          "2360:           i = ((mult[0] * (1 - cfrac) + mult[1] * cfrac) * row + num) * 2;",
          "2361:           RAW(row, col) = LIM(i, 0, 65535);",
          "2362:         }",
          "2364:       free(yval[0]);",
          "2370:     if (yval[0])",
          "2371:       free(yval[0]);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "2120:   int a, b, i;",
          "2121:   ushort akey, bkey, t_mask;",
          "2124:   akey = get2();",
          "2125:   bkey = get2();",
          "2127: #ifdef LIBRAW_LIBRARY_BUILD",
          "2129:     {",
          "2145: #endif",
          "2148:   if (ph1.format)",
          "2154:     }",
          "2155: }",
          "2158: {",
          "2159: #ifndef LIBRAW_NOTHREADS",
          "2160: #define bitbuf tls->ph1_bits.bitbuf",
          "2162: #else",
          "2165: #endif",
          "2166:   unsigned c;",
          "2168:   if (nbits == -1)",
          "2169:     return bitbuf = vbits = 0;",
          "2172:     bitbuf = bitbuf << 32 | get4();",
          "2173:     vbits += 32;",
          "2174:   }",
          "2177:     vbits -= huff[c] >> 8;",
          "2179:   }",
          "2180:   vbits -= nbits;",
          "2181:   return c;",
          "",
          "[Removed Lines]",
          "2123:   fseek (ifp, ph1.key_off, SEEK_SET);",
          "2126:   t_mask = ph1.format == 1 ? 0x5555:0x1354;",
          "2128:   if (ph1.black_col || ph1.black_row )",
          "2130:       imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height*2,sizeof(ushort));",
          "2131:       merror(imgdata.rawdata.ph1_cblack,\"phase_one_load_raw()\");",
          "2132:       imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width*2,sizeof(ushort));",
          "2133:       merror(imgdata.rawdata.ph1_rblack,\"phase_one_load_raw()\");",
          "2134:       if (ph1.black_col)",
          "2135:         {",
          "2136:           fseek (ifp, ph1.black_col, SEEK_SET);",
          "2137:           read_shorts ((ushort *)imgdata.rawdata.ph1_cblack[0], raw_height*2);",
          "2138:         }",
          "2139:       if (ph1.black_row)",
          "2140:         {",
          "2141:           fseek (ifp, ph1.black_row, SEEK_SET);",
          "2142:           read_shorts ((ushort *) imgdata.rawdata.ph1_rblack[0], raw_width*2);",
          "2143:         }",
          "2144:       }",
          "2146:   fseek (ifp, data_offset, SEEK_SET);",
          "2147:   read_shorts (raw_image, raw_width*raw_height);",
          "2149:     for (i=0; i < raw_width*raw_height; i+=2) {",
          "2150:       a = raw_image[i+0] ^ akey;",
          "2151:       b = raw_image[i+1] ^ bkey;",
          "2152:       raw_image[i+0] = (a & t_mask) | (b & ~t_mask);",
          "2153:       raw_image[i+1] = (b & t_mask) | (a & ~t_mask);",
          "2157: unsigned CLASS ph1_bithuff (int nbits, ushort *huff)",
          "2161: #define vbits  tls->ph1_bits.vbits",
          "2163:   static UINT64 bitbuf=0;",
          "2164:   static int vbits=0;",
          "2170:   if (nbits == 0) return 0;",
          "2171:   if (vbits < nbits) {",
          "2175:   c = bitbuf << (64-vbits) >> (64-nbits);",
          "2176:   if (huff) {",
          "2178:     return (uchar) huff[c];",
          "",
          "[Added Lines]",
          "2383:   fseek(ifp, ph1.key_off, SEEK_SET);",
          "2386:   t_mask = ph1.format == 1 ? 0x5555 : 0x1354;",
          "2388:   if (ph1.black_col || ph1.black_row)",
          "2389:   {",
          "2390:     imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height * 2, sizeof(ushort));",
          "2391:     merror(imgdata.rawdata.ph1_cblack, \"phase_one_load_raw()\");",
          "2392:     imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width * 2, sizeof(ushort));",
          "2393:     merror(imgdata.rawdata.ph1_rblack, \"phase_one_load_raw()\");",
          "2394:     if (ph1.black_col)",
          "2396:       fseek(ifp, ph1.black_col, SEEK_SET);",
          "2397:       read_shorts((ushort *)imgdata.rawdata.ph1_cblack[0], raw_height * 2);",
          "2398:     }",
          "2399:     if (ph1.black_row)",
          "2400:     {",
          "2401:       fseek(ifp, ph1.black_row, SEEK_SET);",
          "2402:       read_shorts((ushort *)imgdata.rawdata.ph1_rblack[0], raw_width * 2);",
          "2403:     }",
          "2404:   }",
          "2406:   fseek(ifp, data_offset, SEEK_SET);",
          "2407:   read_shorts(raw_image, raw_width * raw_height);",
          "2409:     for (i = 0; i < raw_width * raw_height; i += 2)",
          "2410:     {",
          "2411:       a = raw_image[i + 0] ^ akey;",
          "2412:       b = raw_image[i + 1] ^ bkey;",
          "2413:       raw_image[i + 0] = (a & t_mask) | (b & ~t_mask);",
          "2414:       raw_image[i + 1] = (b & t_mask) | (a & ~t_mask);",
          "2418: unsigned CLASS ph1_bithuff(int nbits, ushort *huff)",
          "2422: #define vbits tls->ph1_bits.vbits",
          "2424:   static UINT64 bitbuf = 0;",
          "2425:   static int vbits = 0;",
          "2431:   if (nbits == 0)",
          "2432:     return 0;",
          "2433:   if (vbits < nbits)",
          "2434:   {",
          "2438:   c = bitbuf << (64 - vbits) >> (64 - nbits);",
          "2439:   if (huff)",
          "2440:   {",
          "2442:     return (uchar)huff[c];",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "2184: #undef vbits",
          "2185: #endif",
          "2186: }",
          "2190: void CLASS phase_one_load_raw_c()",
          "2191: {",
          "2193:   int *offset, len[2], pred[2], row, col, i, j;",
          "2194:   ushort *pixel;",
          "2196: #ifdef LIBRAW_LIBRARY_BUILD",
          "2198:     throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "2199: #endif",
          "2206:     offset[row] = get4();",
          "2209:   if (ph1.black_col)",
          "2211:   r_black = c_black + raw_height;",
          "2213:   if (ph1.black_row)",
          "2216: #ifdef LIBRAW_LIBRARY_BUILD",
          "2227: #endif",
          "2231: #ifdef LIBRAW_LIBRARY_BUILD",
          "2233: #endif",
          "2235: #ifdef LIBRAW_LIBRARY_BUILD",
          "2237: #endif",
          "2257: #ifndef LIBRAW_LIBRARY_BUILD",
          "2265: #else",
          "2268:     else",
          "2271: #endif",
          "2273: #ifdef LIBRAW_LIBRARY_BUILD",
          "2276:     throw;",
          "2277:   }",
          "2278: #endif",
          "2280:   maximum = 0xfffc - ph1.t_black;",
          "2281: }",
          "",
          "[Removed Lines]",
          "2187: #define ph1_bits(n) ph1_bithuff(n,0)",
          "2188: #define ph1_huff(h) ph1_bithuff(*h,h+1)",
          "2192:   static const int length[] = { 8,7,6,9,11,10,5,12,14,13 };",
          "2195:   short (*c_black)[2], (*r_black)[2];",
          "2197:   if(ph1.format == 6)",
          "2201:   pixel = (ushort *) calloc (raw_width*3 + raw_height*4, 2);",
          "2202:   merror (pixel, \"phase_one_load_raw_c()\");",
          "2203:   offset = (int *) (pixel + raw_width);",
          "2204:   fseek (ifp, strip_offset, SEEK_SET);",
          "2205:   for (row=0; row < raw_height; row++)",
          "2207:   c_black = (short (*)[2]) (offset + raw_height);",
          "2208:   fseek (ifp, ph1.black_col, SEEK_SET);",
          "2210:       read_shorts ((ushort *) c_black[0], raw_height*2);",
          "2212:   fseek (ifp, ph1.black_row, SEEK_SET);",
          "2214:       read_shorts ((ushort *) r_black[0], raw_width*2);",
          "2218:   if (ph1.black_col || ph1.black_row )",
          "2219:     {",
          "2220:       imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height*2,sizeof(ushort));",
          "2221:       merror(imgdata.rawdata.ph1_cblack,\"phase_one_load_raw_c()\");",
          "2222:       memmove(imgdata.rawdata.ph1_cblack,(ushort*)c_black[0],raw_height*2*sizeof(ushort));",
          "2223:       imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width*2,sizeof(ushort));",
          "2224:       merror(imgdata.rawdata.ph1_rblack,\"phase_one_load_raw_c()\");",
          "2225:       memmove(imgdata.rawdata.ph1_rblack,(ushort*)r_black[0],raw_width*2*sizeof(ushort));",
          "2226:     }",
          "2229:   for (i=0; i < 256; i++)",
          "2230:     curve[i] = i*i / 3.969 + 0.5;",
          "2232:   try {",
          "2234:   for (row=0; row < raw_height; row++) {",
          "2236:     checkCancel();",
          "2238:     fseek (ifp, data_offset + offset[row], SEEK_SET);",
          "2239:     ph1_bits(-1);",
          "2240:     pred[0] = pred[1] = 0;",
          "2241:     for (col=0; col < raw_width; col++) {",
          "2242:       if (col >= (raw_width & -8))",
          "2243:  len[0] = len[1] = 14;",
          "2244:       else if ((col & 7) == 0)",
          "2245:  for (i=0; i < 2; i++) {",
          "2246:    for (j=0; j < 5 && !ph1_bits(1); j++);",
          "2247:    if (j--) len[i] = length[j*2 + ph1_bits(1)];",
          "2248:  }",
          "2249:       if ((i = len[col & 1]) == 14)",
          "2250:  pixel[col] = pred[col & 1] = ph1_bits(16);",
          "2251:       else",
          "2252:  pixel[col] = pred[col & 1] += ph1_bits(i) + 1 - (1 << (i - 1));",
          "2253:       if (pred[col & 1] >> 16) derror();",
          "2254:       if (ph1.format == 5 && pixel[col] < 256)",
          "2255:  pixel[col] = curve[pixel[col]];",
          "2256:     }",
          "2258:     for (col=0; col < raw_width; col++) {",
          "2259:       int shift = ph1.format == 8? 0: 2;",
          "2260:       i = (pixel[col] << shift) - ph1.t_black",
          "2261:  + c_black[row][col >= ph1.split_col]",
          "2262:  + r_black[col][row >= ph1.split_row];",
          "2263:       if (i > 0) RAW(row,col) = i;",
          "2264:     }",
          "2266:     if(ph1.format == 8)",
          "2267:       memmove(&RAW(row,0),&pixel[0],raw_width*2);",
          "2269:       for (col=0; col < raw_width; col++)",
          "2270:        RAW(row,col) = pixel[col] << 2;",
          "2272:   }",
          "2274:   } catch(...) {",
          "2275:     free (pixel);",
          "2279:   free (pixel);",
          "",
          "[Added Lines]",
          "2451: #define ph1_bits(n) ph1_bithuff(n, 0)",
          "2452: #define ph1_huff(h) ph1_bithuff(*h, h + 1)",
          "2456:   static const int length[] = {8, 7, 6, 9, 11, 10, 5, 12, 14, 13};",
          "2459:   short(*c_black)[2], (*r_black)[2];",
          "2461:   if (ph1.format == 6)",
          "2465:   pixel = (ushort *)calloc(raw_width * 3 + raw_height * 4, 2);",
          "2466:   merror(pixel, \"phase_one_load_raw_c()\");",
          "2467:   offset = (int *)(pixel + raw_width);",
          "2468:   fseek(ifp, strip_offset, SEEK_SET);",
          "2469:   for (row = 0; row < raw_height; row++)",
          "2471:   c_black = (short(*)[2])(offset + raw_height);",
          "2472:   fseek(ifp, ph1.black_col, SEEK_SET);",
          "2474:     read_shorts((ushort *)c_black[0], raw_height * 2);",
          "2476:   fseek(ifp, ph1.black_row, SEEK_SET);",
          "2478:     read_shorts((ushort *)r_black[0], raw_width * 2);",
          "2482:   if (ph1.black_col || ph1.black_row)",
          "2483:   {",
          "2484:     imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height * 2, sizeof(ushort));",
          "2485:     merror(imgdata.rawdata.ph1_cblack, \"phase_one_load_raw_c()\");",
          "2486:     memmove(imgdata.rawdata.ph1_cblack, (ushort *)c_black[0], raw_height * 2 * sizeof(ushort));",
          "2487:     imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width * 2, sizeof(ushort));",
          "2488:     merror(imgdata.rawdata.ph1_rblack, \"phase_one_load_raw_c()\");",
          "2489:     memmove(imgdata.rawdata.ph1_rblack, (ushort *)r_black[0], raw_width * 2 * sizeof(ushort));",
          "2490:   }",
          "2493:   for (i = 0; i < 256; i++)",
          "2494:     curve[i] = i * i / 3.969 + 0.5;",
          "2496:   try",
          "2497:   {",
          "2499:     for (row = 0; row < raw_height; row++)",
          "2500:     {",
          "2502:       checkCancel();",
          "2504:       fseek(ifp, data_offset + offset[row], SEEK_SET);",
          "2505:       ph1_bits(-1);",
          "2506:       pred[0] = pred[1] = 0;",
          "2507:       for (col = 0; col < raw_width; col++)",
          "2508:       {",
          "2509:         if (col >= (raw_width & -8))",
          "2510:           len[0] = len[1] = 14;",
          "2511:         else if ((col & 7) == 0)",
          "2512:           for (i = 0; i < 2; i++)",
          "2513:           {",
          "2514:             for (j = 0; j < 5 && !ph1_bits(1); j++)",
          "2515:               ;",
          "2516:             if (j--)",
          "2517:               len[i] = length[j * 2 + ph1_bits(1)];",
          "2518:           }",
          "2519:         if ((i = len[col & 1]) == 14)",
          "2520:           pixel[col] = pred[col & 1] = ph1_bits(16);",
          "2521:         else",
          "2522:           pixel[col] = pred[col & 1] += ph1_bits(i) + 1 - (1 << (i - 1));",
          "2523:         if (pred[col & 1] >> 16)",
          "2524:           derror();",
          "2525:         if (ph1.format == 5 && pixel[col] < 256)",
          "2526:           pixel[col] = curve[pixel[col]];",
          "2527:       }",
          "2529:       for (col = 0; col < raw_width; col++)",
          "2530:       {",
          "2531:         int shift = ph1.format == 8 ? 0 : 2;",
          "2532:         i = (pixel[col] << shift) - ph1.t_black + c_black[row][col >= ph1.split_col] +",
          "2533:             r_black[col][row >= ph1.split_row];",
          "2534:         if (i > 0)",
          "2535:           RAW(row, col) = i;",
          "2536:       }",
          "2538:     if (ph1.format == 8)",
          "2539:       memmove(&RAW(row, 0), &pixel[0], raw_width * 2);",
          "2541:       for (col = 0; col < raw_width; col++)",
          "2542:         RAW(row, col) = pixel[col] << 2;",
          "2544:     }",
          "2546:   }",
          "2547:   catch (...)",
          "2548:   {",
          "2549:     free(pixel);",
          "2553:   free(pixel);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "2287:   unsigned upix, urow, ucol;",
          "2288:   ushort *ip;",
          "2291:   order = 0x4949;",
          "2292:   ph1_bits(-1);",
          "2293: #ifdef LIBRAW_LIBRARY_BUILD",
          "2295: #endif",
          "2302: #ifdef LIBRAW_LIBRARY_BUILD",
          "2304: #endif",
          "2344:     throw;",
          "2345:   }",
          "2346: #endif",
          "2350: }",
          "2353: void CLASS leaf_hdr_load_raw()",
          "2354: {",
          "2361:   }",
          "2362: #ifdef LIBRAW_LIBRARY_BUILD",
          "2364: #endif",
          "2367: #ifdef LIBRAW_LIBRARY_BUILD",
          "2369: #endif",
          "2373:       }",
          "2377:       if (!filters && (row = r - top_margin) < height)",
          "2380:     }",
          "2381: #ifdef LIBRAW_LIBRARY_BUILD",
          "2384:     throw;",
          "2385:   }",
          "2386: #endif",
          "2388:     maximum = 0xffff;",
          "2389:     raw_color = 1;",
          "2391:   }",
          "2392: }",
          "2394: void CLASS unpacked_load_raw()",
          "2395: {",
          "2400:   {",
          "2401: #ifdef LIBRAW_LIBRARY_BUILD",
          "2402:     checkCancel();",
          "2403: #endif",
          "2408:   }",
          "2409: }",
          "2411: void CLASS unpacked_load_raw_reversed()",
          "2412: {",
          "2417: #ifdef LIBRAW_LIBRARY_BUILD",
          "2419: #endif",
          "2426: }",
          "2430: void CLASS sinar_4shot_load_raw()",
          "2431: {",
          "2432:   ushort *pixel;",
          "2433:   unsigned shot, row, col, r, c;",
          "2439:     unpacked_load_raw();",
          "2440:     return;",
          "2441:   }",
          "2444: #ifdef LIBRAW_LIBRARY_BUILD",
          "2446: #endif",
          "2448: #ifdef LIBRAW_LIBRARY_BUILD",
          "2450: #endif",
          "2459:       }",
          "2460:     }",
          "2462: #ifdef LIBRAW_LIBRARY_BUILD",
          "2464:     free(pixel);",
          "2465:     throw;",
          "2466:   }",
          "2467: #endif",
          "2469:   mix_green = 1;",
          "2470: }",
          "",
          "[Removed Lines]",
          "2290:   if (!ljpeg_start (&jh, 0)) return;",
          "2294:   try {",
          "2296:   back[4] = (int *) calloc (raw_width, 3*sizeof **back);",
          "2297:   merror (back[4], \"hasselblad_load_raw()\");",
          "2298:   FORC3 back[c] = back[4] + c*raw_width;",
          "2299:   cblack[6] >>= sh = tiff_samples > 1;",
          "2300:   shot = LIM(shot_select, 1, tiff_samples) - 1;",
          "2301:   for (row=0; row < raw_height; row++) {",
          "2303:     checkCancel();",
          "2305:     FORC4 back[(c+3) & 3] = back[c];",
          "2306:     for (col=0; col < raw_width; col+=2) {",
          "2307:       for (s=0; s < tiff_samples*2; s+=2) {",
          "2308:  FORC(2) len[c] = ph1_huff(jh.huff[0]);",
          "2309:  FORC(2) {",
          "2310:    diff[s+c] = ph1_bits(len[c]);",
          "2311:    if ((diff[s+c] & (1 << (len[c]-1))) == 0)",
          "2312:      diff[s+c] -= (1 << len[c]) - 1;",
          "2313:    if (diff[s+c] == 65535) diff[s+c] = -32768;",
          "2314:  }",
          "2315:       }",
          "2316:       for (s=col; s < col+2; s++) {",
          "2317:  pred = 0x8000 + load_flags;",
          "2318:  if (col) pred = back[2][s-2];",
          "2319:  if (col && row > 1) switch (jh.psv) {",
          "2320:    case 11: pred += back[0][s]/2 - back[0][s-2]/2;  break;",
          "2321:  }",
          "2322:  f = (row & 1)*3 ^ ((col+s) & 1);",
          "2323:  FORC (tiff_samples) {",
          "2324:    pred += diff[(s & 1)*tiff_samples+c];",
          "2325:    upix = pred >> sh & 0xffff;",
          "2326:    if (raw_image && c == shot)",
          "2327:      RAW(row,s) = upix;",
          "2328:    if (image) {",
          "2329:      urow = row-top_margin  + (c & 1);",
          "2330:      ucol = col-left_margin - ((c >> 1) & 1);",
          "2331:      ip = &image[urow*width+ucol][f];",
          "2332:      if (urow < height && ucol < width)",
          "2334:    }",
          "2335:  }",
          "2336:  back[2][s] = pred;",
          "2337:       }",
          "2338:     }",
          "2339:   }",
          "2340: #ifdef LIBRAW_LIBRARY_BUILD",
          "2341:   } catch (...){",
          "2342:     free (back[4]);",
          "2343:     ljpeg_end (&jh);",
          "2347:   free (back[4]);",
          "2348:   ljpeg_end (&jh);",
          "2349:   if (image) mix_green = 1;",
          "2355:   ushort *pixel=0;",
          "2356:   unsigned tile=0, r, c, row, col;",
          "2358:   if (!filters) {",
          "2359:     pixel = (ushort *) calloc (raw_width, sizeof *pixel);",
          "2360:     merror (pixel, \"leaf_hdr_load_raw()\");",
          "2363:   try {",
          "2365:   FORC(tiff_samples)",
          "2366:     for (r=0; r < raw_height; r++) {",
          "2368:     checkCancel();",
          "2370:       if (r % tile_length == 0) {",
          "2371:  fseek (ifp, data_offset + 4*tile++, SEEK_SET);",
          "2372:  fseek (ifp, get4(), SEEK_SET);",
          "2374:       if (filters && c != shot_select) continue;",
          "2375:       if (filters) pixel = raw_image + r*raw_width;",
          "2376:       read_shorts (pixel, raw_width);",
          "2378:  for (col=0; col < width; col++)",
          "2379:    image[row*width+col][c] = pixel[col+left_margin];",
          "2382:   } catch (...) {",
          "2383:     if(!filters) free(pixel);",
          "2387:   if (!filters) {",
          "2390:     free (pixel);",
          "2396:   int row, col, bits=0;",
          "2397:   while (1 << ++bits < maximum);",
          "2398:   read_shorts (raw_image, raw_width*raw_height);",
          "2399:   for (row=0; row < raw_height; row++)",
          "2404:     for (col=0; col < raw_width; col++)",
          "2405:       if ((RAW(row,col) >>= load_flags) >> bits",
          "2406:  && (unsigned) (row-top_margin) < height",
          "2407:  && (unsigned) (col-left_margin) < width) derror();",
          "2413:     int row, col, bits=0;",
          "2414:     while (1 << ++bits < maximum);",
          "2415:     for (row=raw_height-1; row >= 0; row--)",
          "2416:     {",
          "2418:  checkCancel();",
          "2420:  read_shorts (&raw_image[row*raw_width], raw_width);",
          "2421:  for (col=0; col < raw_width; col++)",
          "2422:   if ((RAW(row,col) >>= load_flags) >> bits",
          "2423:    && (unsigned) (row-top_margin) < height",
          "2424:    && (unsigned) (col-left_margin) < width) derror();",
          "2425:     }",
          "2435:   if (raw_image) {",
          "2436:     shot = LIM (shot_select, 1, 4) - 1;",
          "2437:     fseek (ifp, data_offset + shot*4, SEEK_SET);",
          "2438:     fseek (ifp, get4(), SEEK_SET);",
          "2442:   pixel = (ushort *) calloc (raw_width, sizeof *pixel);",
          "2443:   merror (pixel, \"sinar_4shot_load_raw()\");",
          "2445:   try {",
          "2447:   for (shot=0; shot < 4; shot++) {",
          "2449:     checkCancel();",
          "2451:     fseek (ifp, data_offset + shot*4, SEEK_SET);",
          "2452:     fseek (ifp, get4(), SEEK_SET);",
          "2453:     for (row=0; row < raw_height; row++) {",
          "2454:       read_shorts (pixel, raw_width);",
          "2455:       if ((r = row-top_margin - (shot >> 1 & 1)) >= height) continue;",
          "2456:       for (col=0; col < raw_width; col++) {",
          "2457:  if ((c = col-left_margin - (shot & 1)) >= width) continue;",
          "2458:  image[r*width+c][(row & 1)*3 ^ (~col & 1)] = pixel[col];",
          "2461:   }",
          "2463:   } catch (...) {",
          "2468:   free (pixel);",
          "",
          "[Added Lines]",
          "2564:   if (!ljpeg_start(&jh, 0))",
          "2565:     return;",
          "2569:   try",
          "2570:   {",
          "2572:     back[4] = (int *)calloc(raw_width, 3 * sizeof **back);",
          "2573:     merror(back[4], \"hasselblad_load_raw()\");",
          "2574:     FORC3 back[c] = back[4] + c * raw_width;",
          "2575:     cblack[6] >>= sh = tiff_samples > 1;",
          "2576:     shot = LIM(shot_select, 1, tiff_samples) - 1;",
          "2577:     for (row = 0; row < raw_height; row++)",
          "2578:     {",
          "2580:       checkCancel();",
          "2582:       FORC4 back[(c + 3) & 3] = back[c];",
          "2583:       for (col = 0; col < raw_width; col += 2)",
          "2584:       {",
          "2585:         for (s = 0; s < tiff_samples * 2; s += 2)",
          "2586:         {",
          "2587:           FORC(2) len[c] = ph1_huff(jh.huff[0]);",
          "2588:           FORC(2)",
          "2589:           {",
          "2590:             diff[s + c] = ph1_bits(len[c]);",
          "2591:             if ((diff[s + c] & (1 << (len[c] - 1))) == 0)",
          "2592:               diff[s + c] -= (1 << len[c]) - 1;",
          "2593:             if (diff[s + c] == 65535)",
          "2594:               diff[s + c] = -32768;",
          "2595:           }",
          "2596:         }",
          "2597:         for (s = col; s < col + 2; s++)",
          "2598:         {",
          "2599:           pred = 0x8000 + load_flags;",
          "2600:           if (col)",
          "2601:             pred = back[2][s - 2];",
          "2602:           if (col && row > 1)",
          "2603:             switch (jh.psv)",
          "2604:             {",
          "2605:             case 11:",
          "2606:               pred += back[0][s] / 2 - back[0][s - 2] / 2;",
          "2607:               break;",
          "2608:             }",
          "2609:           f = (row & 1) * 3 ^ ((col + s) & 1);",
          "2610:           FORC(tiff_samples)",
          "2611:           {",
          "2612:             pred += diff[(s & 1) * tiff_samples + c];",
          "2613:             upix = pred >> sh & 0xffff;",
          "2614:             if (raw_image && c == shot)",
          "2615:               RAW(row, s) = upix;",
          "2616:             if (image)",
          "2617:             {",
          "2618:               urow = row - top_margin + (c & 1);",
          "2619:               ucol = col - left_margin - ((c >> 1) & 1);",
          "2620:               ip = &image[urow * width + ucol][f];",
          "2621:               if (urow < height && ucol < width)",
          "2623:             }",
          "2624:           }",
          "2625:           back[2][s] = pred;",
          "2626:         }",
          "2627:       }",
          "2628:     }",
          "2629: #ifdef LIBRAW_LIBRARY_BUILD",
          "2630:   }",
          "2631:   catch (...)",
          "2632:   {",
          "2633:     free(back[4]);",
          "2634:     ljpeg_end(&jh);",
          "2638:   free(back[4]);",
          "2639:   ljpeg_end(&jh);",
          "2640:   if (image)",
          "2641:     mix_green = 1;",
          "2646:   ushort *pixel = 0;",
          "2647:   unsigned tile = 0, r, c, row, col;",
          "2649:   if (!filters)",
          "2650:   {",
          "2651:     pixel = (ushort *)calloc(raw_width, sizeof *pixel);",
          "2652:     merror(pixel, \"leaf_hdr_load_raw()\");",
          "2655:   try",
          "2656:   {",
          "2658:     FORC(tiff_samples)",
          "2659:     for (r = 0; r < raw_height; r++)",
          "2660:     {",
          "2662:       checkCancel();",
          "2664:       if (r % tile_length == 0)",
          "2665:       {",
          "2666:         fseek(ifp, data_offset + 4 * tile++, SEEK_SET);",
          "2667:         fseek(ifp, get4(), SEEK_SET);",
          "2669:       if (filters && c != shot_select)",
          "2670:         continue;",
          "2671:       if (filters)",
          "2672:         pixel = raw_image + r * raw_width;",
          "2673:       read_shorts(pixel, raw_width);",
          "2675:         for (col = 0; col < width; col++)",
          "2676:           image[row * width + col][c] = pixel[col + left_margin];",
          "2679:   }",
          "2680:   catch (...)",
          "2681:   {",
          "2682:     if (!filters)",
          "2683:       free(pixel);",
          "2687:   if (!filters)",
          "2688:   {",
          "2691:     free(pixel);",
          "2697:   int row, col, bits = 0;",
          "2698:   while (1 << ++bits < maximum)",
          "2699:     ;",
          "2700:   read_shorts(raw_image, raw_width * raw_height);",
          "2701:   for (row = 0; row < raw_height; row++)",
          "2706:     for (col = 0; col < raw_width; col++)",
          "2707:       if ((RAW(row, col) >>= load_flags) >> bits && (unsigned)(row - top_margin) < height &&",
          "2708:           (unsigned)(col - left_margin) < width)",
          "2709:         derror();",
          "2715:   int row, col, bits = 0;",
          "2716:   while (1 << ++bits < maximum)",
          "2717:     ;",
          "2718:   for (row = raw_height - 1; row >= 0; row--)",
          "2719:   {",
          "2721:     checkCancel();",
          "2723:     read_shorts(&raw_image[row * raw_width], raw_width);",
          "2724:     for (col = 0; col < raw_width; col++)",
          "2725:       if ((RAW(row, col) >>= load_flags) >> bits && (unsigned)(row - top_margin) < height &&",
          "2726:           (unsigned)(col - left_margin) < width)",
          "2727:         derror();",
          "2728:   }",
          "2736:   if (raw_image)",
          "2737:   {",
          "2738:     shot = LIM(shot_select, 1, 4) - 1;",
          "2739:     fseek(ifp, data_offset + shot * 4, SEEK_SET);",
          "2740:     fseek(ifp, get4(), SEEK_SET);",
          "2744:   pixel = (ushort *)calloc(raw_width, sizeof *pixel);",
          "2745:   merror(pixel, \"sinar_4shot_load_raw()\");",
          "2747:   try",
          "2748:   {",
          "2750:     for (shot = 0; shot < 4; shot++)",
          "2751:     {",
          "2753:       checkCancel();",
          "2755:       fseek(ifp, data_offset + shot * 4, SEEK_SET);",
          "2756:       fseek(ifp, get4(), SEEK_SET);",
          "2757:       for (row = 0; row < raw_height; row++)",
          "2758:       {",
          "2759:         read_shorts(pixel, raw_width);",
          "2760:         if ((r = row - top_margin - (shot >> 1 & 1)) >= height)",
          "2761:           continue;",
          "2762:         for (col = 0; col < raw_width; col++)",
          "2763:         {",
          "2764:           if ((c = col - left_margin - (shot & 1)) >= width)",
          "2765:             continue;",
          "2766:           image[r * width + c][(row & 1) * 3 ^ (~col & 1)] = pixel[col];",
          "2767:         }",
          "2771:   }",
          "2772:   catch (...)",
          "2773:   {",
          "2778:   free(pixel);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "2473: {",
          "2474:   int row, col;",
          "2478: #ifdef LIBRAW_LIBRARY_BUILD",
          "2481: #endif",
          "2484:   {",
          "2485: #ifdef LIBRAW_LIBRARY_BUILD",
          "2486:     checkCancel();",
          "2496: #else",
          "2499: #endif",
          "2500:   }",
          "2501: #ifdef LIBRAW_LIBRARY_BUILD",
          "",
          "[Removed Lines]",
          "2476:   if (!image) return;",
          "2479:   unsigned short *buf = (unsigned short *)malloc(width*3*sizeof(unsigned short));",
          "2480:   merror(buf,\"imacon_full_load_raw\");",
          "2483:   for (row=0; row < height; row++)",
          "2487:     read_shorts(buf,width*3);",
          "2488:     unsigned short (*rowp)[4] = &image[row*width];",
          "2489:     for (col=0; col < width; col++)",
          "2490:       {",
          "2491:         rowp[col][0]=buf[col*3];",
          "2492:         rowp[col][1]=buf[col*3+1];",
          "2493:         rowp[col][2]=buf[col*3+2];",
          "2494:         rowp[col][3]=0;",
          "2495:       }",
          "2497:     for (col=0; col < width; col++)",
          "2498:       read_shorts (image[row*width+col], 3);",
          "",
          "[Added Lines]",
          "2786:   if (!image)",
          "2787:     return;",
          "2790:   unsigned short *buf = (unsigned short *)malloc(width * 3 * sizeof(unsigned short));",
          "2791:   merror(buf, \"imacon_full_load_raw\");",
          "2794:   for (row = 0; row < height; row++)",
          "2798:     read_shorts(buf, width * 3);",
          "2799:     unsigned short(*rowp)[4] = &image[row * width];",
          "2800:     for (col = 0; col < width; col++)",
          "2801:     {",
          "2802:       rowp[col][0] = buf[col * 3];",
          "2803:       rowp[col][1] = buf[col * 3 + 1];",
          "2804:       rowp[col][2] = buf[col * 3 + 2];",
          "2805:       rowp[col][3] = 0;",
          "2806:     }",
          "2808:     for (col = 0; col < width; col++)",
          "2809:       read_shorts(image[row * width + col], 3);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "2506: void CLASS packed_load_raw()",
          "2507: {",
          "2511:   bwide = raw_width * tiff_bps / 8;",
          "2512:   bwide += bwide & load_flags >> 7;",
          "2513:   rbits = bwide * 8 - raw_width * tiff_bps;",
          "2515:   bite = 8 + (load_flags & 24);",
          "2518: #ifdef LIBRAW_LIBRARY_BUILD",
          "2519:     checkCancel();",
          "2520: #endif",
          "2521:     row = irow;",
          "2542:     }",
          "2543:     vbits -= rbits;",
          "2544:   }",
          "",
          "[Removed Lines]",
          "2508:   int vbits=0, bwide, rbits, bite, half, irow, row, col, val, i;",
          "2509:   UINT64 bitbuf=0;",
          "2514:   if (load_flags & 1) bwide = bwide * 16 / 15;",
          "2516:   half = (raw_height+1) >> 1;",
          "2517:   for (irow=0; irow < raw_height; irow++) {",
          "2522:     if (load_flags & 2 &&",
          "2523:  (row = irow % half * 2 + irow / half) == 1 &&",
          "2524:  load_flags & 4) {",
          "2525:       if (vbits=0, tiff_compress)",
          "2526:  fseek (ifp, data_offset - (-half*bwide & -2048), SEEK_SET);",
          "2527:       else {",
          "2528:  fseek (ifp, 0, SEEK_END);",
          "2529:  fseek (ifp, ftell(ifp) >> 3 << 2, SEEK_SET);",
          "2530:       }",
          "2531:     }",
          "2532:     for (col=0; col < raw_width; col++) {",
          "2533:       for (vbits -= tiff_bps; vbits < 0; vbits += bite) {",
          "2534:  bitbuf <<= bite;",
          "2535:  for (i=0; i < bite; i+=8)",
          "2536:    bitbuf |= (unsigned) (fgetc(ifp) << i);",
          "2537:       }",
          "2538:       val = bitbuf << (64-tiff_bps-vbits) >> (64-tiff_bps);",
          "2539:       RAW(row,col ^ (load_flags >> 6 & 1)) = val;",
          "2540:       if (load_flags & 1 && (col % 10) == 9 && fgetc(ifp) &&",
          "2541:  row < height+top_margin && col < width+left_margin) derror();",
          "",
          "[Added Lines]",
          "2819:   int vbits = 0, bwide, rbits, bite, half, irow, row, col, val, i;",
          "2820:   UINT64 bitbuf = 0;",
          "2825:   if (load_flags & 1)",
          "2826:     bwide = bwide * 16 / 15;",
          "2828:   half = (raw_height + 1) >> 1;",
          "2829:   for (irow = 0; irow < raw_height; irow++)",
          "2830:   {",
          "2835:     if (load_flags & 2 && (row = irow % half * 2 + irow / half) == 1 && load_flags & 4)",
          "2836:     {",
          "2837:       if (vbits = 0, tiff_compress)",
          "2838:         fseek(ifp, data_offset - (-half * bwide & -2048), SEEK_SET);",
          "2839:       else",
          "2840:       {",
          "2841:         fseek(ifp, 0, SEEK_END);",
          "2842:         fseek(ifp, ftell(ifp) >> 3 << 2, SEEK_SET);",
          "2843:       }",
          "2844:     }",
          "2845:     for (col = 0; col < raw_width; col++)",
          "2846:     {",
          "2847:       for (vbits -= tiff_bps; vbits < 0; vbits += bite)",
          "2848:       {",
          "2849:         bitbuf <<= bite;",
          "2850:         for (i = 0; i < bite; i += 8)",
          "2851:           bitbuf |= (unsigned)(fgetc(ifp) << i);",
          "2852:       }",
          "2853:       val = bitbuf << (64 - tiff_bps - vbits) >> (64 - tiff_bps);",
          "2854:       RAW(row, col ^ (load_flags >> 6 & 1)) = val;",
          "2855:       if (load_flags & 1 && (col % 10) == 9 && fgetc(ifp) && row < height + top_margin && col < width + left_margin)",
          "2856:         derror();",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "2549: ushort raw_stride;",
          "2555:     uint8_t umode[32];",
          "2556:     uint16_t uwidth;",
          "2557:     uint16_t uheight;",
          "",
          "[Removed Lines]",
          "2551: void CLASS parse_broadcom () {",
          "2554:   struct {",
          "",
          "[Added Lines]",
          "2866: void CLASS parse_broadcom()",
          "2867: {",
          "2870:   struct",
          "2871:   {",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "2565:   } header;",
          "2567:   header.bayer_order = 0;",
          "2571:   raw_width = width = header.uwidth;",
          "2572:   raw_height = height = header.uheight;",
          "2591:   int rev, row, col, c;",
          "2593:   rev = 3 * (order == 0x4949);",
          "2602:   }",
          "2604: }",
          "2605: #endif",
          "2607: void CLASS nokia_load_raw()",
          "2608: {",
          "2610:   int rev, dwide, row, col, c;",
          "2613:   rev = 3 * (order == 0x4949);",
          "2614:   dwide = (raw_width * 5 + 1) / 4;",
          "2617: #ifdef LIBRAW_LIBRARY_BUILD",
          "2619: #endif",
          "2621: #ifdef LIBRAW_LIBRARY_BUILD",
          "2623: #endif",
          "2629: #ifdef LIBRAW_LIBRARY_BUILD",
          "2632:     throw;",
          "2633:   }",
          "2634: #endif",
          "2636:   maximum = 0x3ff;",
          "2642:   }",
          "2644: }",
          "2646: void CLASS android_tight_load_raw()",
          "",
          "[Removed Lines]",
          "2568:   fseek (ifp, 0xb0 - 0x20, SEEK_CUR);",
          "2569:   fread (&header, 1, sizeof(header), ifp);",
          "2570:   raw_stride = ((((((header.uwidth + header.padding_right)*5)+3)>>2) + 0x1f)&(~0x1f));",
          "2575:   switch (header.bayer_order) {",
          "2577:       filters = 0x94949494;",
          "2578:       break;",
          "2580:       filters = 0x49494949;",
          "2581:       break;",
          "2583:       filters = 0x61616161;",
          "2584:       break;",
          "2585:   }",
          "2586: }",
          "2588: void CLASS broadcom_load_raw() {",
          "2590:   uchar *data, *dp;",
          "2594:   data = (uchar *) malloc (raw_stride*2);",
          "2595:   merror (data, \"broadcom_load_raw()\");",
          "2597:   for (row=0; row < raw_height; row++) {",
          "2598:     if (fread (data+raw_stride, 1, raw_stride, ifp) < raw_stride) derror();",
          "2599:     FORC(raw_stride) data[c] = data[raw_stride+(c ^ rev)];",
          "2600:     for (dp=data, col=0; col < raw_width; dp+=5, col+=4)",
          "2601:       FORC4 RAW(row,col+c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);",
          "2603:   free (data);",
          "2609:   uchar  *data,  *dp;",
          "2611:   double sum[]={0,0};",
          "2615:   data = (uchar *) malloc (dwide*2);",
          "2616:   merror (data, \"nokia_load_raw()\");",
          "2618:   try {",
          "2620:   for (row=0; row < raw_height; row++) {",
          "2622:     checkCancel();",
          "2624:     if (fread (data+dwide, 1, dwide, ifp) < dwide) derror();",
          "2625:     FORC(dwide) data[c] = data[dwide+(c ^ rev)];",
          "2626:     for (dp=data, col=0; col < raw_width; dp+=5, col+=4)",
          "2627:       FORC4 RAW(row,col+c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);",
          "2628:   }",
          "2630:   } catch (...){",
          "2631:     free (data);",
          "2635:   free (data);",
          "2637:   if (strncmp(make,\"OmniVision\",10)) return;",
          "2638:   row = raw_height/2;",
          "2639:   FORC(width-1) {",
          "2640:     sum[ c & 1] += SQR(RAW(row,c)-RAW(row+1,c+1));",
          "2641:     sum[~c & 1] += SQR(RAW(row+1,c)-RAW(row,c+1));",
          "2643:   if (sum[1] > sum[0]) filters = 0x4b4b4b4b;",
          "",
          "[Added Lines]",
          "2885:   fseek(ifp, 0xb0 - 0x20, SEEK_CUR);",
          "2886:   fread(&header, 1, sizeof(header), ifp);",
          "2887:   raw_stride = ((((((header.uwidth + header.padding_right) * 5) + 3) >> 2) + 0x1f) & (~0x1f));",
          "2892:   switch (header.bayer_order)",
          "2893:   {",
          "2895:     filters = 0x94949494;",
          "2896:     break;",
          "2898:     filters = 0x49494949;",
          "2899:     break;",
          "2901:     filters = 0x61616161;",
          "2902:     break;",
          "2903:   }",
          "2904: }",
          "2906: void CLASS broadcom_load_raw()",
          "2907: {",
          "2909:   uchar *data, *dp;",
          "2913:   data = (uchar *)malloc(raw_stride * 2);",
          "2914:   merror(data, \"broadcom_load_raw()\");",
          "2916:   for (row = 0; row < raw_height; row++)",
          "2917:   {",
          "2918:     if (fread(data + raw_stride, 1, raw_stride, ifp) < raw_stride)",
          "2919:       derror();",
          "2920:     FORC(raw_stride) data[c] = data[raw_stride + (c ^ rev)];",
          "2921:     for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)",
          "2922:       FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);",
          "2924:   free(data);",
          "2930:   uchar *data, *dp;",
          "2932:   double sum[] = {0, 0};",
          "2936:   data = (uchar *)malloc(dwide * 2);",
          "2937:   merror(data, \"nokia_load_raw()\");",
          "2939:   try",
          "2940:   {",
          "2942:     for (row = 0; row < raw_height; row++)",
          "2943:     {",
          "2945:       checkCancel();",
          "2947:       if (fread(data + dwide, 1, dwide, ifp) < dwide)",
          "2948:         derror();",
          "2949:       FORC(dwide) data[c] = data[dwide + (c ^ rev)];",
          "2950:       for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)",
          "2951:         FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);",
          "2952:     }",
          "2954:   }",
          "2955:   catch (...)",
          "2956:   {",
          "2957:     free(data);",
          "2961:   free(data);",
          "2963:   if (strncmp(make, \"OmniVision\", 10))",
          "2964:     return;",
          "2965:   row = raw_height / 2;",
          "2966:   FORC(width - 1)",
          "2967:   {",
          "2968:     sum[c & 1] += SQR(RAW(row, c) - RAW(row + 1, c + 1));",
          "2969:     sum[~c & 1] += SQR(RAW(row + 1, c) - RAW(row, c + 1));",
          "2971:   if (sum[1] > sum[0])",
          "2972:     filters = 0x4b4b4b4b;",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "2648:   uchar *data, *dp;",
          "2649:   int bwide, row, col, c;",
          "2660: }",
          "2662: void CLASS android_loose_load_raw()",
          "2663: {",
          "2664:   uchar *data, *dp;",
          "2665:   int bwide, row, col, c;",
          "2676:     }",
          "2677:   }",
          "2679: }",
          "2681: void CLASS canon_rmf_load_raw()",
          "",
          "[Removed Lines]",
          "2651:   bwide = -(-5*raw_width >> 5) << 3;",
          "2652:   data = (uchar *) malloc (bwide);",
          "2653:   merror (data, \"android_tight_load_raw()\");",
          "2654:   for (row=0; row < raw_height; row++) {",
          "2655:     if (fread (data, 1, bwide, ifp) < bwide) derror();",
          "2656:     for (dp=data, col=0; col < raw_width; dp+=5, col+=4)",
          "2657:       FORC4 RAW(row,col+c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);",
          "2658: }",
          "2659:   free (data);",
          "2666:   UINT64 bitbuf=0;",
          "2668:   bwide = (raw_width+5)/6 << 3;",
          "2669:   data = (uchar *) malloc (bwide);",
          "2670:   merror (data, \"android_loose_load_raw()\");",
          "2671:   for (row=0; row < raw_height; row++) {",
          "2672:     if (fread (data, 1, bwide, ifp) < bwide) derror();",
          "2673:     for (dp=data, col=0; col < raw_width; dp+=8, col+=6) {",
          "2674:       FORC(8) bitbuf = (bitbuf << 8) | dp[c^7];",
          "2675:       FORC(6) RAW(row,col+c) = (bitbuf >> c*10) & 0x3ff;",
          "2678:   free (data);",
          "",
          "[Added Lines]",
          "2980:   bwide = -(-5 * raw_width >> 5) << 3;",
          "2981:   data = (uchar *)malloc(bwide);",
          "2982:   merror(data, \"android_tight_load_raw()\");",
          "2983:   for (row = 0; row < raw_height; row++)",
          "2984:   {",
          "2985:     if (fread(data, 1, bwide, ifp) < bwide)",
          "2986:       derror();",
          "2987:     for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)",
          "2988:       FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);",
          "2989:   }",
          "2990:   free(data);",
          "2997:   UINT64 bitbuf = 0;",
          "2999:   bwide = (raw_width + 5) / 6 << 3;",
          "3000:   data = (uchar *)malloc(bwide);",
          "3001:   merror(data, \"android_loose_load_raw()\");",
          "3002:   for (row = 0; row < raw_height; row++)",
          "3003:   {",
          "3004:     if (fread(data, 1, bwide, ifp) < bwide)",
          "3005:       derror();",
          "3006:     for (dp = data, col = 0; col < raw_width; dp += 8, col += 6)",
          "3007:     {",
          "3008:       FORC(8) bitbuf = (bitbuf << 8) | dp[c ^ 7];",
          "3009:       FORC(6) RAW(row, col + c) = (bitbuf >> c * 10) & 0x3ff;",
          "3012:   free(data);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "2683:   int row, col, bits, orow, ocol, c;",
          "2685: #ifdef LIBRAW_LIBRARY_BUILD",
          "2688: #endif",
          "2690:   {",
          "2691: #ifdef LIBRAW_LIBRARY_BUILD",
          "2692:     checkCancel();",
          "2695:       {",
          "2706:         }",
          "2707:       }",
          "2708: #else",
          "2710:       bits = get4();",
          "2719:       }",
          "2720:     }",
          "2721: #endif",
          "",
          "[Removed Lines]",
          "2686:   int *words = (int*)malloc(sizeof(int)*(raw_width/3+1));",
          "2687:   merror(words,\"canon_rmf_load_raw\");",
          "2689:   for (row=0; row < raw_height; row++)",
          "2693:     fread(words,sizeof(int),raw_width/3,ifp);",
          "2694:     for (col=0; col < raw_width-2; col+=3)",
          "2696:         bits = words[col/3];",
          "2697:         FORC3 {",
          "2698:           orow = row;",
          "2699:           if ((ocol = col+c-4) < 0)",
          "2700:             {",
          "2701:               ocol += raw_width;",
          "2702:               if ((orow -= 2) < 0)",
          "2703:                 orow += raw_height;",
          "2704:             }",
          "2705:           RAW(orow,ocol) = curve[bits >> (10*c+2) & 0x3ff];",
          "2709:     for (col=0; col < raw_width-2; col+=3) {",
          "2711:       FORC3 {",
          "2712:  orow = row;",
          "2713:  if ((ocol = col+c-4) < 0) {",
          "2714:    ocol += raw_width;",
          "2715:    if ((orow -= 2) < 0)",
          "2716:      orow += raw_height;",
          "2717:  }",
          "2718:  RAW(orow,ocol) = curve[bits >> (10*c+2) & 0x3ff];",
          "",
          "[Added Lines]",
          "3020:   int *words = (int *)malloc(sizeof(int) * (raw_width / 3 + 1));",
          "3021:   merror(words, \"canon_rmf_load_raw\");",
          "3023:   for (row = 0; row < raw_height; row++)",
          "3027:     fread(words, sizeof(int), raw_width / 3, ifp);",
          "3028:     for (col = 0; col < raw_width - 2; col += 3)",
          "3029:     {",
          "3030:       bits = words[col / 3];",
          "3031:       FORC3",
          "3033:         orow = row;",
          "3034:         if ((ocol = col + c - 4) < 0)",
          "3035:         {",
          "3036:           ocol += raw_width;",
          "3037:           if ((orow -= 2) < 0)",
          "3038:             orow += raw_height;",
          "3040:         RAW(orow, ocol) = curve[bits >> (10 * c + 2) & 0x3ff];",
          "3042:     }",
          "3044:     for (col = 0; col < raw_width - 2; col += 3)",
          "3045:     {",
          "3047:       FORC3",
          "3048:       {",
          "3049:         orow = row;",
          "3050:         if ((ocol = col + c - 4) < 0)",
          "3051:         {",
          "3052:           ocol += raw_width;",
          "3053:           if ((orow -= 2) < 0)",
          "3054:             orow += raw_height;",
          "3055:         }",
          "3056:         RAW(orow, ocol) = curve[bits >> (10 * c + 2) & 0x3ff];",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "2726:   maximum = curve[0x3ff];",
          "2727: }",
          "2730: {",
          "2731: #ifndef LIBRAW_NOTHREADS",
          "2732: #define buf tls->pana_bits.buf",
          "",
          "[Removed Lines]",
          "2729: unsigned CLASS pana_bits (int nbits)",
          "",
          "[Added Lines]",
          "3067: unsigned CLASS pana_bits(int nbits)",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "2737: #endif",
          "2738:   int byte;",
          "2744:   }",
          "2745:   vbits = (vbits - nbits) & 0x1ffff;",
          "2746:   byte = vbits >> 3 ^ 0x3ff0;",
          "2748: #ifndef LIBRAW_NOTHREADS",
          "2749: #undef buf",
          "2750: #undef vbits",
          "",
          "[Removed Lines]",
          "2740:   if (!nbits) return vbits=0;",
          "2741:   if (!vbits) {",
          "2742:     fread (buf+load_flags, 1, 0x4000-load_flags, ifp);",
          "2743:     fread (buf, 1, load_flags, ifp);",
          "2747:   return (buf[byte] | buf[byte+1] << 8) >> (vbits & 7) & ~((~0u) << nbits);",
          "",
          "[Added Lines]",
          "3078:   if (!nbits)",
          "3079:     return vbits = 0;",
          "3080:   if (!vbits)",
          "3081:   {",
          "3082:     fread(buf + load_flags, 1, 0x4000 - load_flags, ifp);",
          "3083:     fread(buf, 1, load_flags, ifp);",
          "3087:   return (buf[byte] | buf[byte + 1] << 8) >> (vbits & 7) & ~((~0u) << nbits);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "2754: void CLASS panasonic_load_raw()",
          "2755: {",
          "2758:   pana_bits(0);",
          "2760:   {",
          "2761: #ifdef LIBRAW_LIBRARY_BUILD",
          "2762:     checkCancel();",
          "2763: #endif",
          "2765:       if ((i = col % 14) == 0)",
          "2771:             pred[i & 1] &= ~((~0u) << sh);",
          "2777:     }",
          "2778:   }",
          "2779: }",
          "",
          "[Removed Lines]",
          "2756:   int row, col, i, j, sh=0, pred[2], nonz[2];",
          "2759:   for (row=0; row < height; row++)",
          "2764:     for (col=0; col < raw_width; col++) {",
          "2766:  pred[0] = pred[1] = nonz[0] = nonz[1] = 0;",
          "2767:       if (i % 3 == 2) sh = 4 >> (3 - pana_bits(2));",
          "2768:       if (nonz[i & 1]) {",
          "2769:  if ((j = pana_bits(8))) {",
          "2770:    if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)",
          "2772:    pred[i & 1] += j << sh;",
          "2773:  }",
          "2774:       } else if ((nonz[i & 1] = pana_bits(8)) || i > 11)",
          "2775:  pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);",
          "2776:       if ((RAW(row,col) = pred[col & 1]) > 4098 && col < width) derror();",
          "",
          "[Added Lines]",
          "3096:   int row, col, i, j, sh = 0, pred[2], nonz[2];",
          "3099:   for (row = 0; row < height; row++)",
          "3104:     for (col = 0; col < raw_width; col++)",
          "3105:     {",
          "3107:         pred[0] = pred[1] = nonz[0] = nonz[1] = 0;",
          "3108:       if (i % 3 == 2)",
          "3109:         sh = 4 >> (3 - pana_bits(2));",
          "3110:       if (nonz[i & 1])",
          "3111:       {",
          "3112:         if ((j = pana_bits(8)))",
          "3113:         {",
          "3114:           if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)",
          "3116:           pred[i & 1] += j << sh;",
          "3117:         }",
          "3118:       }",
          "3119:       else if ((nonz[i & 1] = pana_bits(8)) || i > 11)",
          "3120:         pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);",
          "3121:       if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)",
          "3122:         derror();",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "2784:   int row, col, nbits, sign, low, high, i, c, w, n, nw;",
          "2785:   int acarry[2][3], *carry, pred, diff;",
          "2791:   getbits(-1);",
          "2793: #ifdef LIBRAW_LIBRARY_BUILD",
          "2794:     checkCancel();",
          "2795: #endif",
          "2798:       carry = acarry[col & 1];",
          "2799:       i = 2 * (carry[2] < 3);",
          "2801:       low = (sign = getbits(3)) & 3;",
          "2802:       sign = sign << 29 >> 31;",
          "2805:       carry[0] = (high << nbits) | getbits(nbits);",
          "2806:       diff = (carry[0] ^ sign) + carry[1];",
          "2824:     }",
          "2825:   }",
          "2826: }",
          "",
          "[Removed Lines]",
          "2787:   huff[n=0] = 0xc0c;",
          "2788:   for (i=12; i--; )",
          "2789:     FORC(2048 >> i) huff[++n] = (i+1) << 8 | i;",
          "2790:   fseek (ifp, 7, SEEK_CUR);",
          "2792:   for (row=0; row < height; row++) {",
          "2796:     memset (acarry, 0, sizeof acarry);",
          "2797:     for (col=0; col < raw_width; col++) {",
          "2800:       for (nbits=2+i; (ushort) carry[0] >> (nbits+i); nbits++);",
          "2803:       if ((high = getbithuff(12,huff)) == 12)",
          "2804:  high = getbits(16-nbits) >> 1;",
          "2807:       carry[1] = (diff*3 + carry[1]) >> 5;",
          "2808:       carry[2] = carry[0] > 16 ? 0 : carry[2]+1;",
          "2809:       if (col >= width) continue;",
          "2810:       if (row < 2 && col < 2) pred = 0;",
          "2811:       else if (row < 2) pred = RAW(row,col-2);",
          "2812:       else if (col < 2) pred = RAW(row-2,col);",
          "2813:       else {",
          "2814:  w  = RAW(row,col-2);",
          "2815:  n  = RAW(row-2,col);",
          "2816:  nw = RAW(row-2,col-2);",
          "2817:  if ((w < nw && nw < n) || (n < nw && nw < w)) {",
          "2818:    if (ABS(w-nw) > 32 || ABS(n-nw) > 32)",
          "2819:      pred = w + n - nw;",
          "2820:    else pred = (w + n) >> 1;",
          "2821:  } else pred = ABS(w-nw) > ABS(n-nw) ? w : n;",
          "2822:       }",
          "2823:       if ((RAW(row,col) = pred + ((diff << 2) | low)) >> 12) derror();",
          "",
          "[Added Lines]",
          "3133:   huff[n = 0] = 0xc0c;",
          "3134:   for (i = 12; i--;)",
          "3135:     FORC(2048 >> i) huff[++n] = (i + 1) << 8 | i;",
          "3136:   fseek(ifp, 7, SEEK_CUR);",
          "3138:   for (row = 0; row < height; row++)",
          "3139:   {",
          "3143:     memset(acarry, 0, sizeof acarry);",
          "3144:     for (col = 0; col < raw_width; col++)",
          "3145:     {",
          "3148:       for (nbits = 2 + i; (ushort)carry[0] >> (nbits + i); nbits++)",
          "3149:         ;",
          "3152:       if ((high = getbithuff(12, huff)) == 12)",
          "3153:         high = getbits(16 - nbits) >> 1;",
          "3156:       carry[1] = (diff * 3 + carry[1]) >> 5;",
          "3157:       carry[2] = carry[0] > 16 ? 0 : carry[2] + 1;",
          "3158:       if (col >= width)",
          "3159:         continue;",
          "3160:       if (row < 2 && col < 2)",
          "3161:         pred = 0;",
          "3162:       else if (row < 2)",
          "3163:         pred = RAW(row, col - 2);",
          "3164:       else if (col < 2)",
          "3165:         pred = RAW(row - 2, col);",
          "3166:       else",
          "3167:       {",
          "3168:         w = RAW(row, col - 2);",
          "3169:         n = RAW(row - 2, col);",
          "3170:         nw = RAW(row - 2, col - 2);",
          "3171:         if ((w < nw && nw < n) || (n < nw && nw < w))",
          "3172:         {",
          "3173:           if (ABS(w - nw) > 32 || ABS(n - nw) > 32)",
          "3174:             pred = w + n - nw;",
          "3175:           else",
          "3176:             pred = (w + n) >> 1;",
          "3177:         }",
          "3178:         else",
          "3179:           pred = ABS(w - nw) > ABS(n - nw) ? w : n;",
          "3180:       }",
          "3181:       if ((RAW(row, col) = pred + ((diff << 2) | low)) >> 12)",
          "3182:         derror();",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "2830:   uchar pixel[768];",
          "2831:   unsigned irow, box, row, col;",
          "2834: #ifdef LIBRAW_LIBRARY_BUILD",
          "2835:     checkCancel();",
          "2836: #endif",
          "2838:     box = irow / 82;",
          "2855:   }",
          "2856:   maximum = 0xff << 1;",
          "2857: }",
          "",
          "[Removed Lines]",
          "2833:   for (irow=0; irow < 1481; irow++) {",
          "2837:     if (fread (pixel, 1, 768, ifp) < 768) derror();",
          "2839:     row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box-12)*2);",
          "2840:     switch (irow) {",
          "2841:       case 1477: case 1479: continue;",
          "2842:       case 1476: row = 984; break;",
          "2843:       case 1480: row = 985; break;",
          "2844:       case 1478: row = 985; box = 1;",
          "2845:     }",
          "2846:     if ((box < 12) && (box & 1)) {",
          "2847:       for (col=0; col < 1533; col++, row ^= 1)",
          "2848:  if (col != 1) RAW(row,col) = (col+1) & 2 ?",
          "2849:      pixel[col/2-1] + pixel[col/2+1] : pixel[col/2] << 1;",
          "2850:       RAW(row,1)    = pixel[1]   << 1;",
          "2851:       RAW(row,1533) = pixel[765] << 1;",
          "2852:     } else",
          "2853:       for (col=row & 1; col < 1534; col+=2)",
          "2854:  RAW(row,col) = pixel[col/2] << 1;",
          "",
          "[Added Lines]",
          "3192:   for (irow = 0; irow < 1481; irow++)",
          "3193:   {",
          "3197:     if (fread(pixel, 1, 768, ifp) < 768)",
          "3198:       derror();",
          "3200:     row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box - 12) * 2);",
          "3201:     switch (irow)",
          "3202:     {",
          "3203:     case 1477:",
          "3204:     case 1479:",
          "3205:       continue;",
          "3206:     case 1476:",
          "3207:       row = 984;",
          "3208:       break;",
          "3209:     case 1480:",
          "3210:       row = 985;",
          "3211:       break;",
          "3212:     case 1478:",
          "3213:       row = 985;",
          "3214:       box = 1;",
          "3215:     }",
          "3216:     if ((box < 12) && (box & 1))",
          "3217:     {",
          "3218:       for (col = 0; col < 1533; col++, row ^= 1)",
          "3219:         if (col != 1)",
          "3220:           RAW(row, col) = (col + 1) & 2 ? pixel[col / 2 - 1] + pixel[col / 2 + 1] : pixel[col / 2] << 1;",
          "3221:       RAW(row, 1) = pixel[1] << 1;",
          "3222:       RAW(row, 1533) = pixel[765] << 1;",
          "3223:     }",
          "3224:     else",
          "3225:       for (col = row & 1; col < 1534; col += 2)",
          "3226:         RAW(row, col) = pixel[col / 2] << 1;",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "2859: void CLASS quicktake_100_load_raw()",
          "2860: {",
          "2861:   uchar pixel[484][644];",
          "2883:   getbits(-1);",
          "2886: #ifdef LIBRAW_LIBRARY_BUILD",
          "2887:     checkCancel();",
          "2888: #endif",
          "2893:       if (col < 4)",
          "2895:       if (row == 2)",
          "2897:     }",
          "2898:     pixel[row][col] = val;",
          "2899:   }",
          "2902:     {",
          "2903: #ifdef LIBRAW_LIBRARY_BUILD",
          "2905: #endif",
          "2920:       }",
          "2921:     }",
          "2923:   {",
          "2924: #ifdef LIBRAW_LIBRARY_BUILD",
          "2925:     checkCancel();",
          "2926: #endif",
          "2931:     }",
          "2932:   }",
          "2934:   {",
          "2935: #ifdef LIBRAW_LIBRARY_BUILD",
          "2936:     checkCancel();",
          "2937: #endif",
          "2940:   }",
          "2941:   maximum = 0x3ff;",
          "2942: }",
          "2951: #ifdef __GNUC__",
          "2955: #endif",
          "2957: void CLASS kodak_radc_load_raw()",
          "2958: {",
          "2959:   static const signed char src[] = {",
          "2979:   ushort huff[19][256];",
          "2980:   int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;",
          "2990:     FORC(256 >> src[i])",
          "2992:   s = kodak_cbpp == 243 ? 2 : 3;",
          "2994:   getbits(-1);",
          "2996:     ((short *)buf)[i] = 2048;",
          "2998: #ifdef LIBRAW_LIBRARY_BUILD",
          "2999:     checkCancel();",
          "3000: #endif",
          "3001:     FORC3 mul[c] = getbits(6);",
          "3009:       last[c] = mul[c];",
          "3053:     raw_image[i] = curve[raw_image[i]];",
          "3054:   maximum = 0x3fff;",
          "3055: }",
          "",
          "[Removed Lines]",
          "2862:   static const short gstep[16] =",
          "2863:   { -89,-60,-44,-32,-22,-15,-8,-2,2,8,15,22,32,44,60,89 };",
          "2864:   static const short rstep[6][4] =",
          "2865:   { {  -3,-1,1,3  }, {  -5,-1,1,5  }, {  -8,-2,2,8  },",
          "2866:     { -13,-3,3,13 }, { -19,-4,4,19 }, { -28,-6,6,28 } };",
          "2867:   static const short t_curve[256] =",
          "2868:   { 0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,",
          "2869:     28,29,30,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,",
          "2870:     54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,74,75,76,77,78,",
          "2871:     79,80,81,82,83,84,86,88,90,92,94,97,99,101,103,105,107,110,112,114,116,",
          "2872:     118,120,123,125,127,129,131,134,136,138,140,142,144,147,149,151,153,155,",
          "2873:     158,160,162,164,166,168,171,173,175,177,179,181,184,186,188,190,192,195,",
          "2874:     197,199,201,203,205,208,210,212,214,216,218,221,223,226,230,235,239,244,",
          "2875:     248,252,257,261,265,270,274,278,283,287,291,296,300,305,309,313,318,322,",
          "2876:     326,331,335,339,344,348,352,357,361,365,370,374,379,383,387,392,396,400,",
          "2877:     405,409,413,418,422,426,431,435,440,444,448,453,457,461,466,470,474,479,",
          "2878:     483,487,492,496,500,508,519,531,542,553,564,575,587,598,609,620,631,643,",
          "2879:     654,665,676,687,698,710,721,732,743,754,766,777,788,799,810,822,833,844,",
          "2880:     855,866,878,889,900,911,922,933,945,956,967,978,989,1001,1012,1023 };",
          "2881:   int rb, row, col, sharp, val=0;",
          "2884:   memset (pixel, 0x80, sizeof pixel);",
          "2885:   for (row=2; row < height+2; row++) {",
          "2889:     for (col=2+(row & 1); col < width+2; col+=2) {",
          "2890:       val = ((pixel[row-1][col-1] + 2*pixel[row-1][col+1] +",
          "2891:   pixel[row][col-2]) >> 2) + gstep[getbits(4)];",
          "2892:       pixel[row][col] = val = LIM(val,0,255);",
          "2894:  pixel[row][col-2] = pixel[row+1][~row & 1] = val;",
          "2896:  pixel[row-1][col+1] = pixel[row-1][col+3] = val;",
          "2900:   for (rb=0; rb < 2; rb++)",
          "2901:     for (row=2+rb; row < height+2; row+=2)",
          "2904:     checkCancel();",
          "2906:       for (col=3-(row & 1); col < width+2; col+=2) {",
          "2907:  if (row < 4 || col < 4) sharp = 2;",
          "2908:  else {",
          "2909:    val = ABS(pixel[row-2][col] - pixel[row][col-2])",
          "2910:        + ABS(pixel[row-2][col] - pixel[row-2][col-2])",
          "2911:        + ABS(pixel[row][col-2] - pixel[row-2][col-2]);",
          "2912:    sharp = val <  4 ? 0 : val <  8 ? 1 : val < 16 ? 2 :",
          "2913:     val < 32 ? 3 : val < 48 ? 4 : 5;",
          "2914:  }",
          "2915:  val = ((pixel[row-2][col] + pixel[row][col-2]) >> 1)",
          "2916:        + rstep[sharp][getbits(2)];",
          "2917:  pixel[row][col] = val = LIM(val,0,255);",
          "2918:  if (row < 4) pixel[row-2][col+2] = val;",
          "2919:  if (col < 4) pixel[row+2][col-2] = val;",
          "2922:   for (row=2; row < height+2; row++)",
          "2927:     for (col=3-(row & 1); col < width+2; col+=2) {",
          "2928:       val = ((pixel[row][col-1] + (pixel[row][col] << 2) +",
          "2929:        pixel[row][col+1]) >> 1) - 0x100;",
          "2930:       pixel[row][col] = LIM(val,0,255);",
          "2933:   for (row=0; row < height; row++)",
          "2938:     for (col=0; col < width; col++)",
          "2939:       RAW(row,col) = t_curve[pixel[row+2][col+2]];",
          "2944: #define radc_token(tree) ((signed char) getbithuff(8,huff[tree]))",
          "2946: #define FORYX for (y=1; y < 3; y++) for (x=col+1; x >= col; x--)",
          "2948: #define PREDICTOR (c ? (buf[c][y-1][x] + buf[c][y][x+1]) / 2 \\",
          "2949: : (buf[c][y-1][x+1] + 2*buf[c][y-1][x] + buf[c][y][x+1]) / 4)",
          "2952: # if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)",
          "2953: # pragma GCC optimize(\"no-aggressive-loop-optimizations\")",
          "2954: # endif",
          "2960:     1,1, 2,3, 3,4, 4,2, 5,7, 6,5, 7,6, 7,8,",
          "2961:     1,0, 2,1, 3,3, 4,4, 5,2, 6,7, 7,6, 8,5, 8,8,",
          "2962:     2,1, 2,3, 3,0, 3,2, 3,4, 4,6, 5,5, 6,7, 6,8,",
          "2963:     2,0, 2,1, 2,3, 3,2, 4,4, 5,6, 6,7, 7,5, 7,8,",
          "2964:     2,1, 2,4, 3,0, 3,2, 3,3, 4,7, 5,5, 6,6, 6,8,",
          "2965:     2,3, 3,1, 3,2, 3,4, 3,5, 3,6, 4,7, 5,0, 5,8,",
          "2966:     2,3, 2,6, 3,0, 3,1, 4,4, 4,5, 4,7, 5,2, 5,8,",
          "2967:     2,4, 2,7, 3,3, 3,6, 4,1, 4,2, 4,5, 5,0, 5,8,",
          "2968:     2,6, 3,1, 3,3, 3,5, 3,7, 3,8, 4,0, 5,2, 5,4,",
          "2969:     2,0, 2,1, 3,2, 3,3, 4,4, 4,5, 5,6, 5,7, 4,8,",
          "2970:     1,0, 2,2, 2,-2,",
          "2971:     1,-3, 1,3,",
          "2972:     2,-17, 2,-5, 2,5, 2,17,",
          "2973:     2,-7, 2,2, 2,9, 2,18,",
          "2974:     2,-18, 2,-9, 2,-2, 2,7,",
          "2975:     2,-28, 2,28, 3,-49, 3,-9, 3,9, 4,49, 5,-79, 5,79,",
          "2976:     2,-1, 2,13, 2,26, 3,39, 4,-16, 5,55, 6,-37, 6,76,",
          "2977:     2,-26, 2,-13, 2,1, 3,-39, 4,16, 5,-55, 6,-76, 6,37",
          "2978:   };",
          "2981:   short last[3] = { 16,16,16 }, mul[3], buf[3][3][386];",
          "2982:   static const ushort pt[] =",
          "2983:     { 0,0, 1280,1344, 2320,3616, 3328,8000, 4095,16383, 65535,16383 };",
          "2985:   for (i=2; i < 12; i+=2)",
          "2986:     for (c=pt[i-2]; c <= pt[i]; c++)",
          "2987:       curve[c] = (float)",
          "2988:  (c-pt[i-2]) / (pt[i]-pt[i-2]) * (pt[i+1]-pt[i-1]) + pt[i-1] + 0.5;",
          "2989:   for (s=i=0; i < sizeof src; i+=2)",
          "2991:       ((ushort *)huff)[s++] = src[i] << 8 | (uchar) src[i+1];",
          "2993:   FORC(256) huff[18][c] = (8-s) << 8 | c >> s << s | 1 << (s-1);",
          "2995:   for (i=0; i < sizeof(buf)/sizeof(short); i++)",
          "2997:   for (row=0; row < height; row+=4) {",
          "3002:     FORC3 {",
          "3003:       val = ((0x1000000/last[c] + 0x7ff) >> 12) * mul[c];",
          "3004:       s = val > 65564 ? 10:12;",
          "3005:       x = ~((~0u) << (s-1));",
          "3006:       val <<= 12-s;",
          "3007:       for (i=0; i < sizeof(buf[0])/sizeof(short); i++)",
          "3008:  ((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;",
          "3010:       for (r=0; r <= !c; r++) {",
          "3011:  buf[c][1][width/2] = buf[c][2][width/2] = mul[c] << 7;",
          "3012:  for (tree=1, col=width/2; col > 0; ) {",
          "3013:    if ((tree = radc_token(tree))) {",
          "3014:      col -= 2;",
          "3015:      if (tree == 8)",
          "3016:        FORYX buf[c][y][x] = (uchar) radc_token(18) * mul[c];",
          "3017:      else",
          "3018:        FORYX buf[c][y][x] = radc_token(tree+10) * 16 + PREDICTOR;",
          "3019:    } else",
          "3020:      do {",
          "3021:        nreps = (col > 2) ? radc_token(9) + 1 : 1;",
          "3022:        for (rep=0; rep < 8 && rep < nreps && col > 0; rep++) {",
          "3023:   col -= 2;",
          "3024:   FORYX buf[c][y][x] = PREDICTOR;",
          "3025:   if (rep & 1) {",
          "3026:     step = radc_token(10) << 4;",
          "3027:     FORYX buf[c][y][x] += step;",
          "3028:   }",
          "3029:        }",
          "3030:      } while (nreps == 9);",
          "3031:  }",
          "3032:  for (y=0; y < 2; y++)",
          "3033:    for (x=0; x < width/2; x++) {",
          "3034:      val = (buf[c][y+1][x] << 4) / mul[c];",
          "3035:      if (val < 0) val = 0;",
          "3036:      if (c) RAW(row+y*2+c-1,x*2+2-c) = val;",
          "3037:      else   RAW(row+r*2+y,x*2+y) = val;",
          "3038:    }",
          "3039:  memcpy (buf[c][0]+!c, buf[c][2], sizeof buf[c][0]-2*!c);",
          "3040:       }",
          "3041:     }",
          "3042:     for (y=row; y < row+4; y++)",
          "3043:       for (x=0; x < width; x++)",
          "3044:  if ((x+y) & 1) {",
          "3045:    r = x ? x-1 : x+1;",
          "3046:    s = x+1 < width ? x+1 : x-1;",
          "3047:    val = (RAW(y,x)-2048)*2 + (RAW(y,r)+RAW(y,s))/2;",
          "3048:    if (val < 0) val = 0;",
          "3049:    RAW(y,x) = val;",
          "3050:  }",
          "3051:   }",
          "3052:   for (i=0; i < height*width; i++)",
          "",
          "[Added Lines]",
          "3234:   static const short gstep[16] = {-89, -60, -44, -32, -22, -15, -8, -2, 2, 8, 15, 22, 32, 44, 60, 89};",
          "3235:   static const short rstep[6][4] = {{-3, -1, 1, 3},   {-5, -1, 1, 5},   {-8, -2, 2, 8},",
          "3236:                                     {-13, -3, 3, 13}, {-19, -4, 4, 19}, {-28, -6, 6, 28}};",
          "3237:   static const short t_curve[256] = {",
          "3238:       0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   11,  12,   13,   14,  15,  16,  17,  18,  19,  20,  21,  22,",
          "3239:       23,  24,  25,  26,  27,  28,  29,  30,  32,  33,  34,  35,   36,   37,  38,  39,  40,  41,  42,  43,  44,  45,",
          "3240:       46,  47,  48,  49,  50,  51,  53,  54,  55,  56,  57,  58,   59,   60,  61,  62,  63,  64,  65,  66,  67,  68,",
          "3241:       69,  70,  71,  72,  74,  75,  76,  77,  78,  79,  80,  81,   82,   83,  84,  86,  88,  90,  92,  94,  97,  99,",
          "3242:       101, 103, 105, 107, 110, 112, 114, 116, 118, 120, 123, 125,  127,  129, 131, 134, 136, 138, 140, 142, 144, 147,",
          "3243:       149, 151, 153, 155, 158, 160, 162, 164, 166, 168, 171, 173,  175,  177, 179, 181, 184, 186, 188, 190, 192, 195,",
          "3244:       197, 199, 201, 203, 205, 208, 210, 212, 214, 216, 218, 221,  223,  226, 230, 235, 239, 244, 248, 252, 257, 261,",
          "3245:       265, 270, 274, 278, 283, 287, 291, 296, 300, 305, 309, 313,  318,  322, 326, 331, 335, 339, 344, 348, 352, 357,",
          "3246:       361, 365, 370, 374, 379, 383, 387, 392, 396, 400, 405, 409,  413,  418, 422, 426, 431, 435, 440, 444, 448, 453,",
          "3247:       457, 461, 466, 470, 474, 479, 483, 487, 492, 496, 500, 508,  519,  531, 542, 553, 564, 575, 587, 598, 609, 620,",
          "3248:       631, 643, 654, 665, 676, 687, 698, 710, 721, 732, 743, 754,  766,  777, 788, 799, 810, 822, 833, 844, 855, 866,",
          "3249:       878, 889, 900, 911, 922, 933, 945, 956, 967, 978, 989, 1001, 1012, 1023};",
          "3250:   int rb, row, col, sharp, val = 0;",
          "3253:   memset(pixel, 0x80, sizeof pixel);",
          "3254:   for (row = 2; row < height + 2; row++)",
          "3255:   {",
          "3259:     for (col = 2 + (row & 1); col < width + 2; col += 2)",
          "3260:     {",
          "3261:       val = ((pixel[row - 1][col - 1] + 2 * pixel[row - 1][col + 1] + pixel[row][col - 2]) >> 2) + gstep[getbits(4)];",
          "3262:       pixel[row][col] = val = LIM(val, 0, 255);",
          "3264:         pixel[row][col - 2] = pixel[row + 1][~row & 1] = val;",
          "3266:         pixel[row - 1][col + 1] = pixel[row - 1][col + 3] = val;",
          "3270:   for (rb = 0; rb < 2; rb++)",
          "3271:     for (row = 2 + rb; row < height + 2; row += 2)",
          "3274:       checkCancel();",
          "3276:       for (col = 3 - (row & 1); col < width + 2; col += 2)",
          "3277:       {",
          "3278:         if (row < 4 || col < 4)",
          "3279:           sharp = 2;",
          "3280:         else",
          "3281:         {",
          "3282:           val = ABS(pixel[row - 2][col] - pixel[row][col - 2]) + ABS(pixel[row - 2][col] - pixel[row - 2][col - 2]) +",
          "3283:                 ABS(pixel[row][col - 2] - pixel[row - 2][col - 2]);",
          "3284:           sharp = val < 4 ? 0 : val < 8 ? 1 : val < 16 ? 2 : val < 32 ? 3 : val < 48 ? 4 : 5;",
          "3285:         }",
          "3286:         val = ((pixel[row - 2][col] + pixel[row][col - 2]) >> 1) + rstep[sharp][getbits(2)];",
          "3287:         pixel[row][col] = val = LIM(val, 0, 255);",
          "3288:         if (row < 4)",
          "3289:           pixel[row - 2][col + 2] = val;",
          "3290:         if (col < 4)",
          "3291:           pixel[row + 2][col - 2] = val;",
          "3294:   for (row = 2; row < height + 2; row++)",
          "3299:     for (col = 3 - (row & 1); col < width + 2; col += 2)",
          "3300:     {",
          "3301:       val = ((pixel[row][col - 1] + (pixel[row][col] << 2) + pixel[row][col + 1]) >> 1) - 0x100;",
          "3302:       pixel[row][col] = LIM(val, 0, 255);",
          "3305:   for (row = 0; row < height; row++)",
          "3310:     for (col = 0; col < width; col++)",
          "3311:       RAW(row, col) = t_curve[pixel[row + 2][col + 2]];",
          "3316: #define radc_token(tree) ((signed char)getbithuff(8, huff[tree]))",
          "3318: #define FORYX                                                                                                          \\",
          "3319:   for (y = 1; y < 3; y++)                                                                                              \\",
          "3320:     for (x = col + 1; x >= col; x--)",
          "3322: #define PREDICTOR                                                                                                      \\",
          "3323:   (c ? (buf[c][y - 1][x] + buf[c][y][x + 1]) / 2 : (buf[c][y - 1][x + 1] + 2 * buf[c][y - 1][x] + buf[c][y][x + 1]) / 4)",
          "3326: #if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)",
          "3327: #pragma GCC optimize(\"no-aggressive-loop-optimizations\")",
          "3328: #endif",
          "3334:       1, 1,   2, 3,   3, 4,   4, 2,   5, 7,   6, 5,   7, 6,  7, 8,   1, 0,   2, 1,  3, 3,  4, 4,  5, 2,   6, 7,   7, 6,",
          "3335:       8, 5,   8, 8,   2, 1,   2, 3,   3, 0,   3, 2,   3, 4,  4, 6,   5, 5,   6, 7,  6, 8,  2, 0,  2, 1,   2, 3,   3, 2,",
          "3336:       4, 4,   5, 6,   6, 7,   7, 5,   7, 8,   2, 1,   2, 4,  3, 0,   3, 2,   3, 3,  4, 7,  5, 5,  6, 6,   6, 8,   2, 3,",
          "3337:       3, 1,   3, 2,   3, 4,   3, 5,   3, 6,   4, 7,   5, 0,  5, 8,   2, 3,   2, 6,  3, 0,  3, 1,  4, 4,   4, 5,   4, 7,",
          "3338:       5, 2,   5, 8,   2, 4,   2, 7,   3, 3,   3, 6,   4, 1,  4, 2,   4, 5,   5, 0,  5, 8,  2, 6,  3, 1,   3, 3,   3, 5,",
          "3339:       3, 7,   3, 8,   4, 0,   5, 2,   5, 4,   2, 0,   2, 1,  3, 2,   3, 3,   4, 4,  4, 5,  5, 6,  5, 7,   4, 8,   1, 0,",
          "3340:       2, 2,   2, -2,  1, -3,  1, 3,   2, -17, 2, -5,  2, 5,  2, 17,  2, -7,  2, 2,  2, 9,  2, 18, 2, -18, 2, -9,  2, -2,",
          "3341:       2, 7,   2, -28, 2, 28,  3, -49, 3, -9,  3, 9,   4, 49, 5, -79, 5, 79,  2, -1, 2, 13, 2, 26, 3, 39,  4, -16, 5, 55,",
          "3342:       6, -37, 6, 76,  2, -26, 2, -13, 2, 1,   3, -39, 4, 16, 5, -55, 6, -76, 6, 37};",
          "3345:   short last[3] = {16, 16, 16}, mul[3], buf[3][3][386];",
          "3346:   static const ushort pt[] = {0, 0, 1280, 1344, 2320, 3616, 3328, 8000, 4095, 16383, 65535, 16383};",
          "3348:   for (i = 2; i < 12; i += 2)",
          "3349:     for (c = pt[i - 2]; c <= pt[i]; c++)",
          "3350:       curve[c] = (float)(c - pt[i - 2]) / (pt[i] - pt[i - 2]) * (pt[i + 1] - pt[i - 1]) + pt[i - 1] + 0.5;",
          "3351:   for (s = i = 0; i < sizeof src; i += 2)",
          "3353:   ((ushort *)huff)[s++] = src[i] << 8 | (uchar)src[i + 1];",
          "3355:   FORC(256) huff[18][c] = (8 - s) << 8 | c >> s << s | 1 << (s - 1);",
          "3357:   for (i = 0; i < sizeof(buf) / sizeof(short); i++)",
          "3359:   for (row = 0; row < height; row += 4)",
          "3360:   {",
          "3365:     FORC3",
          "3366:     {",
          "3367:       val = ((0x1000000 / last[c] + 0x7ff) >> 12) * mul[c];",
          "3368:       s = val > 65564 ? 10 : 12;",
          "3369:       x = ~((~0u) << (s - 1));",
          "3370:       val <<= 12 - s;",
          "3371:       for (i = 0; i < sizeof(buf[0]) / sizeof(short); i++)",
          "3372:         ((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;",
          "3374:       for (r = 0; r <= !c; r++)",
          "3375:       {",
          "3376:         buf[c][1][width / 2] = buf[c][2][width / 2] = mul[c] << 7;",
          "3377:         for (tree = 1, col = width / 2; col > 0;)",
          "3378:         {",
          "3379:           if ((tree = radc_token(tree)))",
          "3380:           {",
          "3381:             col -= 2;",
          "3382:             if (tree == 8)",
          "3383:               FORYX buf[c][y][x] = (uchar)radc_token(18) * mul[c];",
          "3384:             else",
          "3385:               FORYX buf[c][y][x] = radc_token(tree + 10) * 16 + PREDICTOR;",
          "3386:           }",
          "3387:           else",
          "3388:             do",
          "3389:             {",
          "3390:               nreps = (col > 2) ? radc_token(9) + 1 : 1;",
          "3391:               for (rep = 0; rep < 8 && rep < nreps && col > 0; rep++)",
          "3392:               {",
          "3393:                 col -= 2;",
          "3394:                 FORYX buf[c][y][x] = PREDICTOR;",
          "3395:                 if (rep & 1)",
          "3396:                 {",
          "3397:                   step = radc_token(10) << 4;",
          "3398:                   FORYX buf[c][y][x] += step;",
          "3399:                 }",
          "3400:               }",
          "3401:             } while (nreps == 9);",
          "3402:         }",
          "3403:         for (y = 0; y < 2; y++)",
          "3404:           for (x = 0; x < width / 2; x++)",
          "3405:           {",
          "3406:             val = (buf[c][y + 1][x] << 4) / mul[c];",
          "3407:             if (val < 0)",
          "3408:               val = 0;",
          "3409:             if (c)",
          "3410:               RAW(row + y * 2 + c - 1, x * 2 + 2 - c) = val;",
          "3411:             else",
          "3412:               RAW(row + r * 2 + y, x * 2 + y) = val;",
          "3413:           }",
          "3414:         memcpy(buf[c][0] + !c, buf[c][2], sizeof buf[c][0] - 2 * !c);",
          "3415:       }",
          "3416:     }",
          "3417:     for (y = row; y < row + 4; y++)",
          "3418:       for (x = 0; x < width; x++)",
          "3419:         if ((x + y) & 1)",
          "3420:         {",
          "3421:           r = x ? x - 1 : x + 1;",
          "3422:           s = x + 1 < width ? x + 1 : x - 1;",
          "3423:           val = (RAW(y, x) - 2048) * 2 + (RAW(y, r) + RAW(y, s)) / 2;",
          "3424:           if (val < 0)",
          "3425:             val = 0;",
          "3426:           RAW(y, x) = val;",
          "3427:         }",
          "3428:   }",
          "3429:   for (i = 0; i < height * width; i++)",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "3062: void CLASS lossy_dng_load_raw() {}",
          "3063: #else",
          "3066: #ifndef LIBRAW_LIBRARY_BUILD",
          "3067: METHODDEF(boolean)",
          "3069: {",
          "3070:   static uchar jpeg_buffer[4096];",
          "3071:   size_t nbytes;",
          "3075:   cinfo->src->next_input_byte = jpeg_buffer;",
          "3076:   cinfo->src->bytes_in_buffer = nbytes;",
          "3077:   return TRUE;",
          "",
          "[Removed Lines]",
          "3068: fill_input_buffer (j_decompress_ptr cinfo)",
          "3073:   nbytes = fread (jpeg_buffer, 1, 4096, ifp);",
          "3074:   swab (jpeg_buffer, jpeg_buffer, nbytes);",
          "",
          "[Added Lines]",
          "3444: fill_input_buffer(j_decompress_ptr cinfo)",
          "3449:   nbytes = fread(jpeg_buffer, 1, 4096, ifp);",
          "3450:   swab(jpeg_buffer, jpeg_buffer, nbytes);",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "3081:   struct jpeg_decompress_struct cinfo;",
          "3082:   struct jpeg_error_mgr jerr;",
          "3083:   JSAMPARRAY buf;",
          "3085:   int row, col;",
          "3090:   cinfo.src->fill_input_buffer = fill_input_buffer;",
          "3104:     row = cinfo.output_scanline * 2;",
          "3112:     }",
          "3113:   }",
          "3116:   maximum = 0xff << 1;",
          "3117: }",
          "3118: #else",
          "3121:   struct jpeg_error_mgr pub;",
          "3122: };",
          "3125: {",
          "3127:   throw LIBRAW_EXCEPTION_DECODE_JPEG;",
          "3128: }",
          "3132: void CLASS kodak_jpeg_load_raw()",
          "3133: {",
          "3135:     throw LIBRAW_EXCEPTION_DECODE_JPEG;",
          "3137:   int row, col;",
          "",
          "[Removed Lines]",
          "3084:   JSAMPLE (*pixel)[3];",
          "3087:   cinfo.err = jpeg_std_error (&jerr);",
          "3088:   jpeg_create_decompress (&cinfo);",
          "3089:   jpeg_stdio_src (&cinfo, ifp);",
          "3091:   jpeg_read_header (&cinfo, TRUE);",
          "3092:   jpeg_start_decompress (&cinfo);",
          "3093:   if ((cinfo.output_width      != width  ) ||",
          "3094:       (cinfo.output_height*2   != height ) ||",
          "3095:       (cinfo.output_components != 3      )) {",
          "3096:     fprintf (stderr,_(\"%s: incorrect JPEG dimensions\\n\"), ifname);",
          "3097:     jpeg_destroy_decompress (&cinfo);",
          "3098:     longjmp (failure, 3);",
          "3099:   }",
          "3100:   buf = (*cinfo.mem->alloc_sarray)",
          "3101:     ((j_common_ptr) &cinfo, JPOOL_IMAGE, width*3, 1);",
          "3103:   while (cinfo.output_scanline < cinfo.output_height) {",
          "3105:     jpeg_read_scanlines (&cinfo, buf, 1);",
          "3106:     pixel = (JSAMPLE (*)[3]) buf[0];",
          "3107:     for (col=0; col < width; col+=2) {",
          "3108:       RAW(row+0,col+0) = pixel[col+0][1] << 1;",
          "3109:       RAW(row+1,col+1) = pixel[col+1][1] << 1;",
          "3110:       RAW(row+0,col+1) = pixel[col][0] + pixel[col+1][0];",
          "3111:       RAW(row+1,col+0) = pixel[col][2] + pixel[col+1][2];",
          "3114:   jpeg_finish_decompress (&cinfo);",
          "3115:   jpeg_destroy_decompress (&cinfo);",
          "3120: struct jpegErrorManager {",
          "3124: static void jpegErrorExit (j_common_ptr cinfo)",
          "3126:   jpegErrorManager* myerr = (jpegErrorManager*) cinfo->err;",
          "3134:   if(data_size < 1)",
          "",
          "[Added Lines]",
          "3460:   JSAMPLE(*pixel)[3];",
          "3463:   cinfo.err = jpeg_std_error(&jerr);",
          "3464:   jpeg_create_decompress(&cinfo);",
          "3465:   jpeg_stdio_src(&cinfo, ifp);",
          "3467:   jpeg_read_header(&cinfo, TRUE);",
          "3468:   jpeg_start_decompress(&cinfo);",
          "3469:   if ((cinfo.output_width != width) || (cinfo.output_height * 2 != height) || (cinfo.output_components != 3))",
          "3470:   {",
          "3471:     fprintf(stderr, _(\"%s: incorrect JPEG dimensions\\n\"), ifname);",
          "3472:     jpeg_destroy_decompress(&cinfo);",
          "3473:     longjmp(failure, 3);",
          "3474:   }",
          "3475:   buf = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, width * 3, 1);",
          "3477:   while (cinfo.output_scanline < cinfo.output_height)",
          "3478:   {",
          "3480:     jpeg_read_scanlines(&cinfo, buf, 1);",
          "3481:     pixel = (JSAMPLE(*)[3])buf[0];",
          "3482:     for (col = 0; col < width; col += 2)",
          "3483:     {",
          "3484:       RAW(row + 0, col + 0) = pixel[col + 0][1] << 1;",
          "3485:       RAW(row + 1, col + 1) = pixel[col + 1][1] << 1;",
          "3486:       RAW(row + 0, col + 1) = pixel[col][0] + pixel[col + 1][0];",
          "3487:       RAW(row + 1, col + 0) = pixel[col][2] + pixel[col + 1][2];",
          "3490:   jpeg_finish_decompress(&cinfo);",
          "3491:   jpeg_destroy_decompress(&cinfo);",
          "3496: struct jpegErrorManager",
          "3497: {",
          "3501: static void jpegErrorExit(j_common_ptr cinfo)",
          "3503:   jpegErrorManager *myerr = (jpegErrorManager *)cinfo->err;",
          "3510:   if (data_size < 1)",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "3142:   jerr.pub.error_exit = jpegErrorExit;",
          "3144:   unsigned char *jpg_buf = (unsigned char *)malloc(data_size);",
          "3152:   try",
          "3183:     }",
          "3184:   catch (...)",
          "3194:   free(jpg_buf);",
          "3195:   free(pixel_buf);",
          "3196:   maximum = 0xff << 1;",
          "",
          "[Removed Lines]",
          "3145:   merror(jpg_buf,\"kodak_jpeg_load_raw\");",
          "3146:   unsigned char *pixel_buf = (unsigned char*) malloc(width*3);",
          "3147:   jpeg_create_decompress (&cinfo);",
          "3148:   merror(pixel_buf,\"kodak_jpeg_load_raw\");",
          "3150:   fread(jpg_buf,data_size,1,ifp);",
          "3151:   swab ((char*)jpg_buf, (char*)jpg_buf, data_size);",
          "3153:     {",
          "3154:       jpeg_mem_src(&cinfo, jpg_buf, data_size);",
          "3155:       int rc = jpeg_read_header(&cinfo, TRUE);",
          "3156:       if(rc!=1)",
          "3157:         throw LIBRAW_EXCEPTION_DECODE_JPEG;",
          "3159:       jpeg_start_decompress (&cinfo);",
          "3160:       if ((cinfo.output_width      != width  ) ||",
          "3161:           (cinfo.output_height*2   != height ) ||",
          "3162:           (cinfo.output_components != 3      ))",
          "3163:         {",
          "3164:           throw LIBRAW_EXCEPTION_DECODE_JPEG;",
          "3165:         }",
          "3167:       unsigned char *buf[1];",
          "3168:       buf[0] = pixel_buf;",
          "3170:       while (cinfo.output_scanline < cinfo.output_height)",
          "3171:         {",
          "3172:           checkCancel();",
          "3173:           row = cinfo.output_scanline * 2;",
          "3174:           jpeg_read_scanlines (&cinfo, buf, 1);",
          "3175:           unsigned char (*pixel)[3] = (unsigned char (*)[3]) buf[0];",
          "3176:           for (col=0; col < width; col+=2) {",
          "3177:             RAW(row+0,col+0) = pixel[col+0][1] << 1;",
          "3178:             RAW(row+1,col+1) = pixel[col+1][1] << 1;",
          "3179:             RAW(row+0,col+1) = pixel[col][0] + pixel[col+1][0];",
          "3180:             RAW(row+1,col+0) = pixel[col][2] + pixel[col+1][2];",
          "3181:           }",
          "3182:         }",
          "3185:         {",
          "3186:           jpeg_finish_decompress (&cinfo);",
          "3187:           jpeg_destroy_decompress (&cinfo);",
          "3188:           free(jpg_buf);",
          "3189:           free(pixel_buf);",
          "3190:           throw;",
          "3191:         }",
          "3192:   jpeg_finish_decompress (&cinfo);",
          "3193:   jpeg_destroy_decompress (&cinfo);",
          "",
          "[Added Lines]",
          "3521:   merror(jpg_buf, \"kodak_jpeg_load_raw\");",
          "3522:   unsigned char *pixel_buf = (unsigned char *)malloc(width * 3);",
          "3523:   jpeg_create_decompress(&cinfo);",
          "3524:   merror(pixel_buf, \"kodak_jpeg_load_raw\");",
          "3526:   fread(jpg_buf, data_size, 1, ifp);",
          "3527:   swab((char *)jpg_buf, (char *)jpg_buf, data_size);",
          "3529:   {",
          "3530:     jpeg_mem_src(&cinfo, jpg_buf, data_size);",
          "3531:     int rc = jpeg_read_header(&cinfo, TRUE);",
          "3532:     if (rc != 1)",
          "3533:       throw LIBRAW_EXCEPTION_DECODE_JPEG;",
          "3535:     jpeg_start_decompress(&cinfo);",
          "3536:     if ((cinfo.output_width != width) || (cinfo.output_height * 2 != height) || (cinfo.output_components != 3))",
          "3537:     {",
          "3538:       throw LIBRAW_EXCEPTION_DECODE_JPEG;",
          "3539:     }",
          "3541:     unsigned char *buf[1];",
          "3542:     buf[0] = pixel_buf;",
          "3544:     while (cinfo.output_scanline < cinfo.output_height)",
          "3545:     {",
          "3546:       checkCancel();",
          "3547:       row = cinfo.output_scanline * 2;",
          "3548:       jpeg_read_scanlines(&cinfo, buf, 1);",
          "3549:       unsigned char(*pixel)[3] = (unsigned char(*)[3])buf[0];",
          "3550:       for (col = 0; col < width; col += 2)",
          "3551:       {",
          "3552:         RAW(row + 0, col + 0) = pixel[col + 0][1] << 1;",
          "3553:         RAW(row + 1, col + 1) = pixel[col + 1][1] << 1;",
          "3554:         RAW(row + 0, col + 1) = pixel[col][0] + pixel[col + 1][0];",
          "3555:         RAW(row + 1, col + 0) = pixel[col][2] + pixel[col + 1][2];",
          "3556:       }",
          "3558:   }",
          "3560:   {",
          "3561:     jpeg_finish_decompress(&cinfo);",
          "3562:     jpeg_destroy_decompress(&cinfo);",
          "3563:     free(jpg_buf);",
          "3564:     free(pixel_buf);",
          "3565:     throw;",
          "3566:   }",
          "3567:   jpeg_finish_decompress(&cinfo);",
          "3568:   jpeg_destroy_decompress(&cinfo);",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "3198: #endif",
          "3200: #ifndef LIBRAW_LIBRARY_BUILD",
          "3202: #endif",
          "3204: void CLASS lossy_dng_load_raw()",
          "",
          "[Removed Lines]",
          "3201: void CLASS gamma_curve (double pwr, double ts, int mode, int imax);",
          "",
          "[Added Lines]",
          "3576: void CLASS gamma_curve(double pwr, double ts, int mode, int imax);",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "3206:   struct jpeg_decompress_struct cinfo;",
          "3207:   struct jpeg_error_mgr jerr;",
          "3208:   JSAMPARRAY buf;",
          "3212:   ushort cur[3][256];",
          "3213:   double coeff[9], tot;",
          "3217:     order = 0x4d4d;",
          "3218:     ntags = get4();",
          "3221:       if (opcode != 8)",
          "3233:       }",
          "3234:     }",
          "3235:     order = sorder;",
          "3244:     if (tile_length < INT_MAX)",
          "3246: #ifdef LIBRAW_LIBRARY_BUILD",
          "3252: #else",
          "3254: #endif",
          "3259: #ifdef LIBRAW_LIBRARY_BUILD",
          "3261: #endif",
          "3264: #ifdef LIBRAW_LIBRARY_BUILD",
          "3266: #endif",
          "3271:       }",
          "3273: #ifdef LIBRAW_LIBRARY_BUILD",
          "3278: #endif",
          "3280:     if ((tcol += tile_width) >= raw_width)",
          "3281:       trow += tile_length + (tcol = 0);",
          "3282:   }",
          "3284:   maximum = 0xffff;",
          "3285: }",
          "3286: #endif",
          "3288: void CLASS kodak_dc120_load_raw()",
          "3289: {",
          "3292:   uchar pixel[848];",
          "3293:   int row, shift, col;",
          "3296: #ifdef LIBRAW_LIBRARY_BUILD",
          "3297:     checkCancel();",
          "3298: #endif",
          "3300:     shift = row * mul[row & 3] + add[row & 3];",
          "3303:   }",
          "3304:   maximum = 0xff;",
          "3305: }",
          "",
          "[Removed Lines]",
          "3209:   JSAMPLE (*pixel)[3];",
          "3210:   unsigned sorder=order, ntags, opcode, deg, i, j, c;",
          "3211:   unsigned save=data_offset-4, trow=0, tcol=0, row, col;",
          "3215:   if (meta_offset) {",
          "3216:     fseek (ifp, meta_offset, SEEK_SET);",
          "3219:     while (ntags--) {",
          "3220:       opcode = get4(); get4(); get4();",
          "3222:       { fseek (ifp, get4(), SEEK_CUR); continue; }",
          "3223:       fseek (ifp, 20, SEEK_CUR);",
          "3224:       if ((c = get4()) > 2) break;",
          "3225:       fseek (ifp, 12, SEEK_CUR);",
          "3226:       if ((deg = get4()) > 8) break;",
          "3227:       for (i=0; i <= deg && i < 9; i++)",
          "3228:  coeff[i] = getreal(12);",
          "3229:       for (i=0; i < 256; i++) {",
          "3230:  for (tot=j=0; j <= deg; j++)",
          "3231:    tot += coeff[j] * pow(i/255.0, (int)j);",
          "3232:  cur[c][i] = tot*0xffff;",
          "3236:   } else {",
          "3237:     gamma_curve (1/2.4, 12.92, 1, 255);",
          "3238:     FORC3 memcpy (cur[c], curve, sizeof cur[0]);",
          "3239:   }",
          "3240:   cinfo.err = jpeg_std_error (&jerr);",
          "3241:   jpeg_create_decompress (&cinfo);",
          "3242:   while (trow < raw_height) {",
          "3243:     fseek (ifp, save+=4, SEEK_SET);",
          "3245:       fseek (ifp, get4(), SEEK_SET);",
          "3247:     if(libraw_internal_data.internal_data.input->jpeg_src(&cinfo) == -1)",
          "3248:       {",
          "3249:         jpeg_destroy_decompress(&cinfo);",
          "3250:         throw LIBRAW_EXCEPTION_DECODE_JPEG;",
          "3251:       }",
          "3253:     jpeg_stdio_src (&cinfo, ifp);",
          "3255:     jpeg_read_header (&cinfo, TRUE);",
          "3256:     jpeg_start_decompress (&cinfo);",
          "3257:     buf = (*cinfo.mem->alloc_sarray)",
          "3258:  ((j_common_ptr) &cinfo, JPOOL_IMAGE, cinfo.output_width*3, 1);",
          "3260:   try {",
          "3262:     while (cinfo.output_scanline < cinfo.output_height &&",
          "3263:  (row = trow + cinfo.output_scanline) < height) {",
          "3265:     checkCancel();",
          "3267:       jpeg_read_scanlines (&cinfo, buf, 1);",
          "3268:       pixel = (JSAMPLE (*)[3]) buf[0];",
          "3269:       for (col=0; col < cinfo.output_width && tcol+col < width; col++) {",
          "3270:  FORC3 image[row*width+tcol+col][c] = cur[c][pixel[col][c]];",
          "3272:     }",
          "3274:   } catch(...) {",
          "3275:     jpeg_destroy_decompress (&cinfo);",
          "3276:     throw;",
          "3277:   }",
          "3279:     jpeg_abort_decompress (&cinfo);",
          "3283:   jpeg_destroy_decompress (&cinfo);",
          "3290:   static const int mul[4] = { 162, 192, 187,  92 };",
          "3291:   static const int add[4] = {   0, 636, 424, 212 };",
          "3295:   for (row=0; row < height; row++) {",
          "3299:     if (fread (pixel, 1, 848, ifp) < 848) derror();",
          "3301:     for (col=0; col < width; col++)",
          "3302:       RAW(row,col) = (ushort) pixel[(col + shift) % 848];",
          "",
          "[Added Lines]",
          "3584:   JSAMPLE(*pixel)[3];",
          "3585:   unsigned sorder = order, ntags, opcode, deg, i, j, c;",
          "3586:   unsigned save = data_offset - 4, trow = 0, tcol = 0, row, col;",
          "3590:   if (meta_offset)",
          "3591:   {",
          "3592:     fseek(ifp, meta_offset, SEEK_SET);",
          "3595:     while (ntags--)",
          "3596:     {",
          "3597:       opcode = get4();",
          "3598:       get4();",
          "3599:       get4();",
          "3601:       {",
          "3602:         fseek(ifp, get4(), SEEK_CUR);",
          "3603:         continue;",
          "3604:       }",
          "3605:       fseek(ifp, 20, SEEK_CUR);",
          "3606:       if ((c = get4()) > 2)",
          "3607:         break;",
          "3608:       fseek(ifp, 12, SEEK_CUR);",
          "3609:       if ((deg = get4()) > 8)",
          "3610:         break;",
          "3611:       for (i = 0; i <= deg && i < 9; i++)",
          "3612:         coeff[i] = getreal(12);",
          "3613:       for (i = 0; i < 256; i++)",
          "3614:       {",
          "3615:         for (tot = j = 0; j <= deg; j++)",
          "3616:           tot += coeff[j] * pow(i / 255.0, (int)j);",
          "3617:         cur[c][i] = tot * 0xffff;",
          "3621:   }",
          "3622:   else",
          "3623:   {",
          "3624:     gamma_curve(1 / 2.4, 12.92, 1, 255);",
          "3625:     FORC3 memcpy(cur[c], curve, sizeof cur[0]);",
          "3626:   }",
          "3627:   cinfo.err = jpeg_std_error(&jerr);",
          "3628:   jpeg_create_decompress(&cinfo);",
          "3629:   while (trow < raw_height)",
          "3630:   {",
          "3631:     fseek(ifp, save += 4, SEEK_SET);",
          "3633:       fseek(ifp, get4(), SEEK_SET);",
          "3635:     if (libraw_internal_data.internal_data.input->jpeg_src(&cinfo) == -1)",
          "3636:     {",
          "3637:       jpeg_destroy_decompress(&cinfo);",
          "3638:       throw LIBRAW_EXCEPTION_DECODE_JPEG;",
          "3639:     }",
          "3641:     jpeg_stdio_src(&cinfo, ifp);",
          "3643:     jpeg_read_header(&cinfo, TRUE);",
          "3644:     jpeg_start_decompress(&cinfo);",
          "3645:     buf = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, cinfo.output_width * 3, 1);",
          "3647:     try",
          "3648:     {",
          "3650:       while (cinfo.output_scanline < cinfo.output_height && (row = trow + cinfo.output_scanline) < height)",
          "3651:       {",
          "3653:         checkCancel();",
          "3655:         jpeg_read_scanlines(&cinfo, buf, 1);",
          "3656:         pixel = (JSAMPLE(*)[3])buf[0];",
          "3657:         for (col = 0; col < cinfo.output_width && tcol + col < width; col++)",
          "3658:         {",
          "3659:           FORC3 image[row * width + tcol + col][c] = cur[c][pixel[col][c]];",
          "3660:         }",
          "3663:     }",
          "3664:     catch (...)",
          "3665:     {",
          "3666:       jpeg_destroy_decompress(&cinfo);",
          "3667:       throw;",
          "3668:     }",
          "3670:     jpeg_abort_decompress(&cinfo);",
          "3674:   jpeg_destroy_decompress(&cinfo);",
          "3681:   static const int mul[4] = {162, 192, 187, 92};",
          "3682:   static const int add[4] = {0, 636, 424, 212};",
          "3686:   for (row = 0; row < height; row++)",
          "3687:   {",
          "3691:     if (fread(pixel, 1, 848, ifp) < 848)",
          "3692:       derror();",
          "3694:     for (col = 0; col < width; col++)",
          "3695:       RAW(row, col) = (ushort)pixel[(col + shift) % 848];",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "3309:   uchar *pixel;",
          "3310:   unsigned row, col;",
          "3314: #ifdef LIBRAW_LIBRARY_BUILD",
          "3316: #endif",
          "3318: #ifdef LIBRAW_LIBRARY_BUILD",
          "3320: #endif",
          "3325: #ifdef LIBRAW_LIBRARY_BUILD",
          "3328:     throw;",
          "3329:   }",
          "3330: #endif",
          "3332:   maximum = curve[0xff];",
          "3333: }",
          "",
          "[Removed Lines]",
          "3312:   pixel = (uchar *) calloc (raw_width, sizeof *pixel);",
          "3313:   merror (pixel, \"eight_bit_load_raw()\");",
          "3315:   try {",
          "3317:   for (row=0; row < raw_height; row++) {",
          "3319:     checkCancel();",
          "3321:     if (fread (pixel, 1, raw_width, ifp) < raw_width) derror();",
          "3322:     for (col=0; col < raw_width; col++)",
          "3323:       RAW(row,col) = curve[pixel[col]];",
          "3324:   }",
          "3326:   } catch(...) {",
          "3327:     free (pixel);",
          "3331:   free (pixel);",
          "",
          "[Added Lines]",
          "3705:   pixel = (uchar *)calloc(raw_width, sizeof *pixel);",
          "3706:   merror(pixel, \"eight_bit_load_raw()\");",
          "3708:   try",
          "3709:   {",
          "3711:     for (row = 0; row < raw_height; row++)",
          "3712:     {",
          "3714:       checkCancel();",
          "3716:       if (fread(pixel, 1, raw_width, ifp) < raw_width)",
          "3717:         derror();",
          "3718:       for (col = 0; col < raw_width; col++)",
          "3719:         RAW(row, col) = curve[pixel[col]];",
          "3720:     }",
          "3722:   }",
          "3723:   catch (...)",
          "3724:   {",
          "3725:     free(pixel);",
          "3729:   free(pixel);",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "3337:   uchar *pixel;",
          "3338:   int row, col, y, cb, cr, rgb[3], c;",
          "3342: #ifdef LIBRAW_LIBRARY_BUILD",
          "3344: #endif",
          "3346: #ifdef LIBRAW_LIBRARY_BUILD",
          "3348: #endif",
          "3360:     }",
          "3362: #ifdef LIBRAW_LIBRARY_BUILD",
          "3365:     throw;",
          "3366:   }",
          "3367: #endif",
          "3369:   maximum = curve[0xff];",
          "3370: }",
          "",
          "[Removed Lines]",
          "3340:   pixel = (uchar *) calloc (raw_width, 2*sizeof *pixel);",
          "3341:   merror (pixel, \"kodak_c330_load_raw()\");",
          "3343:   try {",
          "3345:   for (row=0; row < height; row++) {",
          "3347:     checkCancel();",
          "3349:     if (fread (pixel, raw_width, 2, ifp) < 2) derror();",
          "3350:     if (load_flags && (row & 31) == 31)",
          "3351:       fseek (ifp, raw_width*32, SEEK_CUR);",
          "3352:     for (col=0; col < width; col++) {",
          "3353:       y  = pixel[col*2];",
          "3354:       cb = pixel[(col*2 & -4) | 1] - 128;",
          "3355:       cr = pixel[(col*2 & -4) | 3] - 128;",
          "3356:       rgb[1] = y - ((cb + cr + 2) >> 2);",
          "3357:       rgb[2] = rgb[1] + cb;",
          "3358:       rgb[0] = rgb[1] + cr;",
          "3359:       FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];",
          "3361:   }",
          "3363:   } catch(...) {",
          "3364:     free (pixel);",
          "3368:   free (pixel);",
          "",
          "[Added Lines]",
          "3738:   pixel = (uchar *)calloc(raw_width, 2 * sizeof *pixel);",
          "3739:   merror(pixel, \"kodak_c330_load_raw()\");",
          "3741:   try",
          "3742:   {",
          "3744:     for (row = 0; row < height; row++)",
          "3745:     {",
          "3747:       checkCancel();",
          "3749:       if (fread(pixel, raw_width, 2, ifp) < 2)",
          "3750:         derror();",
          "3751:       if (load_flags && (row & 31) == 31)",
          "3752:         fseek(ifp, raw_width * 32, SEEK_CUR);",
          "3753:       for (col = 0; col < width; col++)",
          "3754:       {",
          "3755:         y = pixel[col * 2];",
          "3756:         cb = pixel[(col * 2 & -4) | 1] - 128;",
          "3757:         cr = pixel[(col * 2 & -4) | 3] - 128;",
          "3758:         rgb[1] = y - ((cb + cr + 2) >> 2);",
          "3759:         rgb[2] = rgb[1] + cb;",
          "3760:         rgb[0] = rgb[1] + cr;",
          "3761:         FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];",
          "3762:       }",
          "3765:   }",
          "3766:   catch (...)",
          "3767:   {",
          "3768:     free(pixel);",
          "3772:   free(pixel);",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "3374:   uchar *pixel;",
          "3375:   int row, col, y, cb, cr, rgb[3], c;",
          "3379: #ifdef LIBRAW_LIBRARY_BUILD",
          "3381: #endif",
          "3383: #ifdef LIBRAW_LIBRARY_BUILD",
          "3385: #endif",
          "3396:     }",
          "3398: #ifdef LIBRAW_LIBRARY_BUILD",
          "3401:     throw;",
          "3402:   }",
          "3403: #endif",
          "3405:   maximum = curve[0xff];",
          "3406: }",
          "3408: void CLASS kodak_262_load_raw()",
          "3409: {",
          "3413:   ushort *huff[2];",
          "3414:   uchar *pixel;",
          "3422:   order = 0x4d4d;",
          "3423:   FORC(ns) strip[c] = get4();",
          "3424: #ifdef LIBRAW_LIBRARY_BUILD",
          "3426: #endif",
          "3428: #ifdef LIBRAW_LIBRARY_BUILD",
          "3430: #endif",
          "3454:     throw;",
          "3455:   }",
          "3456: #endif",
          "3459: }",
          "3462: {",
          "3463:   uchar c, blen[768];",
          "3464:   ushort raw[6];",
          "3468:   save = ftell(ifp);",
          "3469:   bsize = (bsize + 3) & -4;",
          "3471:     c = fgetc(ifp);",
          "3481:       }",
          "3482:       return 1;",
          "3483:     }",
          "3484:   }",
          "3487:     bitbuf += fgetc(ifp);",
          "3488:     bits = 16;",
          "3489:   }",
          "3491:     len = blen[i];",
          "3495:       bits += 32;",
          "3496:     }",
          "3498:     bitbuf >>= len;",
          "3499:     bits -= len;",
          "3501:       diff -= (1 << len) - 1;",
          "3502:     out[i] = diff;",
          "3503:   }",
          "",
          "[Removed Lines]",
          "3377:   pixel = (uchar *) calloc (raw_width, 3*sizeof *pixel);",
          "3378:   merror (pixel, \"kodak_c603_load_raw()\");",
          "3380:   try {",
          "3382:   for (row=0; row < height; row++) {",
          "3384:     checkCancel();",
          "3386:     if (~row & 1)",
          "3387:       if (fread (pixel, raw_width, 3, ifp) < 3) derror();",
          "3388:     for (col=0; col < width; col++) {",
          "3389:       y  = pixel[width*2*(row & 1) + col];",
          "3390:       cb = pixel[width + (col & -2)]   - 128;",
          "3391:       cr = pixel[width + (col & -2)+1] - 128;",
          "3392:       rgb[1] = y - ((cb + cr + 2) >> 2);",
          "3393:       rgb[2] = rgb[1] + cb;",
          "3394:       rgb[0] = rgb[1] + cr;",
          "3395:       FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];",
          "3397:   }",
          "3399:   } catch(...) {",
          "3400:     free (pixel);",
          "3404:   free (pixel);",
          "3410:   static const uchar kodak_tree[2][26] =",
          "3411:   { { 0,1,5,1,1,2,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 },",
          "3412:     { 0,3,1,1,1,1,1,2,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 } };",
          "3415:   int *strip, ns, c, row, col, chess, pi=0, pi1, pi2, pred, val;",
          "3417:   FORC(2) huff[c] = make_decoder (kodak_tree[c]);",
          "3418:   ns = (raw_height+63) >> 5;",
          "3419:   pixel = (uchar *) malloc (raw_width*32 + ns*4);",
          "3420:   merror (pixel, \"kodak_262_load_raw()\");",
          "3421:   strip = (int *) (pixel + raw_width*32);",
          "3425:   try {",
          "3427:   for (row=0; row < raw_height; row++) {",
          "3429:     checkCancel();",
          "3431:     if ((row & 31) == 0) {",
          "3432:       fseek (ifp, strip[row >> 5], SEEK_SET);",
          "3433:       getbits(-1);",
          "3434:       pi = 0;",
          "3435:     }",
          "3436:     for (col=0; col < raw_width; col++) {",
          "3437:       chess = (row + col) & 1;",
          "3438:       pi1 = chess ? pi-2           : pi-raw_width-1;",
          "3439:       pi2 = chess ? pi-2*raw_width : pi-raw_width+1;",
          "3440:       if (col <= chess) pi1 = -1;",
          "3441:       if (pi1 < 0) pi1 = pi2;",
          "3442:       if (pi2 < 0) pi2 = pi1;",
          "3443:       if (pi1 < 0 && col > 1) pi1 = pi2 = pi-2;",
          "3444:       pred = (pi1 < 0) ? 0 : (pixel[pi1] + pixel[pi2]) >> 1;",
          "3445:       pixel[pi] = val = pred + ljpeg_diff (huff[chess]);",
          "3446:       if (val >> 8) derror();",
          "3447:       val = curve[pixel[pi++]];",
          "3448:       RAW(row,col) = val;",
          "3449:     }",
          "3450:   }",
          "3451: #ifdef LIBRAW_LIBRARY_BUILD",
          "3452:   } catch(...) {",
          "3453:     free (pixel);",
          "3457:   free (pixel);",
          "3458:   FORC(2) free (huff[c]);",
          "3461: int CLASS kodak_65000_decode (short *out, int bsize)",
          "3465:   INT64 bitbuf=0;",
          "3466:   int save, bits=0, i, j, len, diff;",
          "3470:   for (i=0; i < bsize; i+=2) {",
          "3472:     if ((blen[i  ] = c & 15) > 12 ||",
          "3473:  (blen[i+1] = c >> 4) > 12 ) {",
          "3474:       fseek (ifp, save, SEEK_SET);",
          "3475:       for (i=0; i < bsize; i+=8) {",
          "3476:  read_shorts (raw, 6);",
          "3477:  out[i  ] = raw[0] >> 12 << 8 | raw[2] >> 12 << 4 | raw[4] >> 12;",
          "3478:  out[i+1] = raw[1] >> 12 << 8 | raw[3] >> 12 << 4 | raw[5] >> 12;",
          "3479:  for (j=0; j < 6; j++)",
          "3480:    out[i+2+j] = raw[j] & 0xfff;",
          "3485:   if ((bsize & 7) == 4) {",
          "3486:     bitbuf  = fgetc(ifp) << 8;",
          "3490:   for (i=0; i < bsize; i++) {",
          "3492:     if (bits < len) {",
          "3493:       for (j=0; j < 32; j+=8)",
          "3494:  bitbuf += (INT64) fgetc(ifp) << (bits+(j^8));",
          "3497:     diff = bitbuf & (0xffff >> (16-len));",
          "3500:     if ((diff & (1 << (len-1))) == 0)",
          "",
          "[Added Lines]",
          "3781:   pixel = (uchar *)calloc(raw_width, 3 * sizeof *pixel);",
          "3782:   merror(pixel, \"kodak_c603_load_raw()\");",
          "3784:   try",
          "3785:   {",
          "3787:     for (row = 0; row < height; row++)",
          "3788:     {",
          "3790:       checkCancel();",
          "3792:       if (~row & 1)",
          "3793:         if (fread(pixel, raw_width, 3, ifp) < 3)",
          "3794:           derror();",
          "3795:       for (col = 0; col < width; col++)",
          "3796:       {",
          "3797:         y = pixel[width * 2 * (row & 1) + col];",
          "3798:         cb = pixel[width + (col & -2)] - 128;",
          "3799:         cr = pixel[width + (col & -2) + 1] - 128;",
          "3800:         rgb[1] = y - ((cb + cr + 2) >> 2);",
          "3801:         rgb[2] = rgb[1] + cb;",
          "3802:         rgb[0] = rgb[1] + cr;",
          "3803:         FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];",
          "3804:       }",
          "3807:   }",
          "3808:   catch (...)",
          "3809:   {",
          "3810:     free(pixel);",
          "3814:   free(pixel);",
          "3820:   static const uchar kodak_tree[2][26] = {",
          "3821:       {0, 1, 5, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9},",
          "3822:       {0, 3, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9}};",
          "3825:   int *strip, ns, c, row, col, chess, pi = 0, pi1, pi2, pred, val;",
          "3827:   FORC(2) huff[c] = make_decoder(kodak_tree[c]);",
          "3828:   ns = (raw_height + 63) >> 5;",
          "3829:   pixel = (uchar *)malloc(raw_width * 32 + ns * 4);",
          "3830:   merror(pixel, \"kodak_262_load_raw()\");",
          "3831:   strip = (int *)(pixel + raw_width * 32);",
          "3835:   try",
          "3836:   {",
          "3838:     for (row = 0; row < raw_height; row++)",
          "3839:     {",
          "3841:       checkCancel();",
          "3843:       if ((row & 31) == 0)",
          "3844:       {",
          "3845:         fseek(ifp, strip[row >> 5], SEEK_SET);",
          "3846:         getbits(-1);",
          "3847:         pi = 0;",
          "3848:       }",
          "3849:       for (col = 0; col < raw_width; col++)",
          "3850:       {",
          "3851:         chess = (row + col) & 1;",
          "3852:         pi1 = chess ? pi - 2 : pi - raw_width - 1;",
          "3853:         pi2 = chess ? pi - 2 * raw_width : pi - raw_width + 1;",
          "3854:         if (col <= chess)",
          "3855:           pi1 = -1;",
          "3856:         if (pi1 < 0)",
          "3857:           pi1 = pi2;",
          "3858:         if (pi2 < 0)",
          "3859:           pi2 = pi1;",
          "3860:         if (pi1 < 0 && col > 1)",
          "3861:           pi1 = pi2 = pi - 2;",
          "3862:         pred = (pi1 < 0) ? 0 : (pixel[pi1] + pixel[pi2]) >> 1;",
          "3863:         pixel[pi] = val = pred + ljpeg_diff(huff[chess]);",
          "3864:         if (val >> 8)",
          "3865:           derror();",
          "3866:         val = curve[pixel[pi++]];",
          "3867:         RAW(row, col) = val;",
          "3868:       }",
          "3869:     }",
          "3870: #ifdef LIBRAW_LIBRARY_BUILD",
          "3871:   }",
          "3872:   catch (...)",
          "3873:   {",
          "3874:     free(pixel);",
          "3878:   free(pixel);",
          "3879:   FORC(2) free(huff[c]);",
          "3882: int CLASS kodak_65000_decode(short *out, int bsize)",
          "3886:   INT64 bitbuf = 0;",
          "3887:   int save, bits = 0, i, j, len, diff;",
          "3891:   for (i = 0; i < bsize; i += 2)",
          "3892:   {",
          "3894:     if ((blen[i] = c & 15) > 12 || (blen[i + 1] = c >> 4) > 12)",
          "3895:     {",
          "3896:       fseek(ifp, save, SEEK_SET);",
          "3897:       for (i = 0; i < bsize; i += 8)",
          "3898:       {",
          "3899:         read_shorts(raw, 6);",
          "3900:         out[i] = raw[0] >> 12 << 8 | raw[2] >> 12 << 4 | raw[4] >> 12;",
          "3901:         out[i + 1] = raw[1] >> 12 << 8 | raw[3] >> 12 << 4 | raw[5] >> 12;",
          "3902:         for (j = 0; j < 6; j++)",
          "3903:           out[i + 2 + j] = raw[j] & 0xfff;",
          "3908:   if ((bsize & 7) == 4)",
          "3909:   {",
          "3910:     bitbuf = fgetc(ifp) << 8;",
          "3914:   for (i = 0; i < bsize; i++)",
          "3915:   {",
          "3917:     if (bits < len)",
          "3918:     {",
          "3919:       for (j = 0; j < 32; j += 8)",
          "3920:         bitbuf += (INT64)fgetc(ifp) << (bits + (j ^ 8));",
          "3923:     diff = bitbuf & (0xffff >> (16 - len));",
          "3926:     if ((diff & (1 << (len - 1))) == 0)",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "3509:   short buf[256];",
          "3510:   int row, col, len, pred[2], ret, i;",
          "3513:   {",
          "3514: #ifdef LIBRAW_LIBRARY_BUILD",
          "3515:     checkCancel();",
          "3516: #endif",
          "3518:       pred[0] = pred[1] = 0;",
          "3524:     }",
          "3525:   }",
          "3526: }",
          "",
          "[Removed Lines]",
          "3512:   for (row=0; row < height; row++)",
          "3517:     for (col=0; col < width; col+=256) {",
          "3519:       len = MIN (256, width-col);",
          "3520:       ret = kodak_65000_decode (buf, len);",
          "3521:       for (i=0; i < len; i++)",
          "3522:  if ((RAW(row,col+i) = curve[ret ? buf[i] :",
          "3523:   (pred[i & 1] += buf[i])]) >> 12) derror();",
          "",
          "[Added Lines]",
          "3938:   for (row = 0; row < height; row++)",
          "3943:     for (col = 0; col < width; col += 256)",
          "3944:     {",
          "3946:       len = MIN(256, width - col);",
          "3947:       ret = kodak_65000_decode(buf, len);",
          "3948:       for (i = 0; i < len; i++)",
          "3949:         if ((RAW(row, col + i) = curve[ret ? buf[i] : (pred[i & 1] += buf[i])]) >> 12)",
          "3950:           derror();",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "3531:   int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];",
          "3532:   ushort *ip;",
          "3537:   {",
          "3538: #ifdef LIBRAW_LIBRARY_BUILD",
          "3539:     checkCancel();",
          "3540: #endif",
          "3544:       y[0][1] = y[1][1] = cb = cr = 0;",
          "3557:       }",
          "3558:     }",
          "3559:   }",
          "",
          "[Removed Lines]",
          "3534:   if (!image) return;",
          "3535:   unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17)?load_flags:10;",
          "3536:   for (row=0; row < height; row+=2)",
          "3541:     for (col=0; col < width; col+=128) {",
          "3542:       len = MIN (128, width-col);",
          "3543:       kodak_65000_decode (buf, len*3);",
          "3545:       for (bp=buf, i=0; i < len; i+=2, bp+=2) {",
          "3546:  cb += bp[4];",
          "3547:  cr += bp[5];",
          "3548:  rgb[1] = -((cb + cr + 2) >> 2);",
          "3549:  rgb[2] = rgb[1] + cb;",
          "3550:  rgb[0] = rgb[1] + cr;",
          "3551:  for (j=0; j < 2; j++)",
          "3552:    for (k=0; k < 2; k++) {",
          "3553:      if ((y[j][k] = y[j][k^1] + *bp++) >> bits) derror();",
          "3554:      ip = image[(row+j)*width + col+i+k];",
          "3555:      FORC3 ip[c] = curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];",
          "3556:    }",
          "",
          "[Added Lines]",
          "3961:   if (!image)",
          "3962:     return;",
          "3963:   unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17) ? load_flags : 10;",
          "3964:   for (row = 0; row < height; row += 2)",
          "3969:     for (col = 0; col < width; col += 128)",
          "3970:     {",
          "3971:       len = MIN(128, width - col);",
          "3972:       kodak_65000_decode(buf, len * 3);",
          "3974:       for (bp = buf, i = 0; i < len; i += 2, bp += 2)",
          "3975:       {",
          "3976:         cb += bp[4];",
          "3977:         cr += bp[5];",
          "3978:         rgb[1] = -((cb + cr + 2) >> 2);",
          "3979:         rgb[2] = rgb[1] + cb;",
          "3980:         rgb[0] = rgb[1] + cr;",
          "3981:         for (j = 0; j < 2; j++)",
          "3982:           for (k = 0; k < 2; k++)",
          "3983:           {",
          "3984:             if ((y[j][k] = y[j][k ^ 1] + *bp++) >> bits)",
          "3985:               derror();",
          "3986:             ip = image[(row + j) * width + col + i + k];",
          "3987:             FORC3 ip[c] = curve[LIM(y[j][k] + rgb[c], 0, 0xfff)];",
          "3988:           }",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "3562: void CLASS kodak_rgb_load_raw()",
          "3563: {",
          "3564:   short buf[768], *bp;",
          "3569:   {",
          "3570: #ifdef LIBRAW_LIBRARY_BUILD",
          "3571:     checkCancel();",
          "3572: #endif",
          "3578: #ifdef LIBRAW_LIBRARY_BUILD",
          "3583:         else",
          "3584: #endif",
          "3585:           FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();",
          "",
          "[Removed Lines]",
          "3565:   int row, col, len, c, i, rgb[3],ret;",
          "3566:   ushort *ip=image[0];",
          "3568:   for (row=0; row < height; row++)",
          "3573:     for (col=0; col < width; col+=256) {",
          "3574:       len = MIN (256, width-col);",
          "3575:       ret = kodak_65000_decode (buf, len*3);",
          "3576:       memset (rgb, 0, sizeof rgb);",
          "3577:       for (bp=buf, i=0; i < len; i++, ip+=4)",
          "3579:         if(load_flags == 12)",
          "3580:           {",
          "3581:             FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);",
          "3582:           }",
          "",
          "[Added Lines]",
          "3997:   int row, col, len, c, i, rgb[3], ret;",
          "3998:   ushort *ip = image[0];",
          "4000:   for (row = 0; row < height; row++)",
          "4005:     for (col = 0; col < width; col += 256)",
          "4006:     {",
          "4007:       len = MIN(256, width - col);",
          "4008:       ret = kodak_65000_decode(buf, len * 3);",
          "4009:       memset(rgb, 0, sizeof rgb);",
          "4010:       for (bp = buf, i = 0; i < len; i++, ip += 4)",
          "4012:         if (load_flags == 12)",
          "4013:         {",
          "4014:           FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);",
          "4015:         }",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "3591: {",
          "3592:   int row, col;",
          "3593:   colors = thumb_misc >> 5;",
          "3597:   maximum = (1 << (thumb_misc & 31)) - 1;",
          "3598: }",
          "3601: {",
          "3602: #ifndef LIBRAW_NOTHREADS",
          "3603: #define pad tls->sony_decrypt.pad",
          "3605: #else",
          "3606:   static unsigned pad[128], p;",
          "3607: #endif",
          "3610:       pad[p] = key = key * 48828125 + 1;",
          "3615:       pad[p] = htonl(pad[p]);",
          "3616:   }",
          "3617:   while (len--)",
          "3622: #ifndef LIBRAW_NOTHREADS",
          "3623: #undef pad",
          "3624: #undef p",
          "",
          "[Removed Lines]",
          "3594:   for (row=0; row < height; row++)",
          "3595:     for (col=0; col < width; col++)",
          "3596:       read_shorts (image[row*width+col], colors);",
          "3600: void CLASS sony_decrypt (unsigned *data, int len, int start, int key)",
          "3604: #define p   tls->sony_decrypt.p",
          "3608:   if (start) {",
          "3609:     for (p=0; p < 4; p++)",
          "3611:     pad[3] = pad[3] << 1 | (pad[0]^pad[2]) >> 31;",
          "3612:     for (p=4; p < 127; p++)",
          "3613:       pad[p] = (pad[p-4]^pad[p-2]) << 1 | (pad[p-3]^pad[p-1]) >> 31;",
          "3614:     for (p=0; p < 127; p++)",
          "3618:     {",
          "3620:       p++;",
          "3621:     }",
          "",
          "[Added Lines]",
          "4027:   for (row = 0; row < height; row++)",
          "4028:     for (col = 0; col < width; col++)",
          "4029:       read_shorts(image[row * width + col], colors);",
          "4033: void CLASS sony_decrypt(unsigned *data, int len, int start, int key)",
          "4037: #define p tls->sony_decrypt.p",
          "4041:   if (start)",
          "4042:   {",
          "4043:     for (p = 0; p < 4; p++)",
          "4045:     pad[3] = pad[3] << 1 | (pad[0] ^ pad[2]) >> 31;",
          "4046:     for (p = 4; p < 127; p++)",
          "4047:       pad[p] = (pad[p - 4] ^ pad[p - 2]) << 1 | (pad[p - 3] ^ pad[p - 1]) >> 31;",
          "4048:     for (p = 0; p < 127; p++)",
          "4052:   {",
          "4054:     p++;",
          "4055:   }",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "3631:   ushort *pixel;",
          "3632:   unsigned i, key, row, col;",
          "3636:   order = 0x4d4d;",
          "3637:   key = get4();",
          "3642:     key = key << 8 | head[i];",
          "3645: #ifdef LIBRAW_LIBRARY_BUILD",
          "3646:     checkCancel();",
          "3647: #endif",
          "3653:   }",
          "3654:   maximum = 0x3ff0;",
          "3655: }",
          "",
          "[Removed Lines]",
          "3634:   fseek (ifp, 200896, SEEK_SET);",
          "3635:   fseek (ifp, (unsigned) fgetc(ifp)*4 - 1, SEEK_CUR);",
          "3638:   fseek (ifp, 164600, SEEK_SET);",
          "3639:   fread (head, 1, 40, ifp);",
          "3640:   sony_decrypt ((unsigned *) head, 10, 1, key);",
          "3641:   for (i=26; i-- > 22; )",
          "3643:   fseek (ifp, data_offset, SEEK_SET);",
          "3644:   for (row=0; row < raw_height; row++) {",
          "3648:     pixel = raw_image + row*raw_width;",
          "3649:     if (fread (pixel, 2, raw_width, ifp) < raw_width) derror();",
          "3650:     sony_decrypt ((unsigned *) pixel, raw_width/2, !row, key);",
          "3651:     for (col=0; col < raw_width; col++)",
          "3652:       if ((pixel[col] = ntohs(pixel[col])) >> 14) derror();",
          "",
          "[Added Lines]",
          "4068:   fseek(ifp, 200896, SEEK_SET);",
          "4069:   fseek(ifp, (unsigned)fgetc(ifp) * 4 - 1, SEEK_CUR);",
          "4072:   fseek(ifp, 164600, SEEK_SET);",
          "4073:   fread(head, 1, 40, ifp);",
          "4074:   sony_decrypt((unsigned *)head, 10, 1, key);",
          "4075:   for (i = 26; i-- > 22;)",
          "4077:   fseek(ifp, data_offset, SEEK_SET);",
          "4078:   for (row = 0; row < raw_height; row++)",
          "4079:   {",
          "4083:     pixel = raw_image + row * raw_width;",
          "4084:     if (fread(pixel, 2, raw_width, ifp) < raw_width)",
          "4085:       derror();",
          "4086:     sony_decrypt((unsigned *)pixel, raw_width / 2, !row, key);",
          "4087:     for (col = 0; col < raw_width; col++)",
          "4088:       if ((pixel[col] = ntohs(pixel[col])) >> 14)",
          "4089:         derror();",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "3657: void CLASS sony_arw_load_raw()",
          "3658: {",
          "3659:   ushort huff[32770];",
          "3665:   huff[0] = 15;",
          "3667:     FORC(32768 >> (tab[i] >> 8)) huff[++n] = tab[i];",
          "3668:   getbits(-1);",
          "3670:   {",
          "3671: #ifdef LIBRAW_LIBRARY_BUILD",
          "3672:     checkCancel();",
          "3673: #endif",
          "3678:     }",
          "3679:   }",
          "3680: }",
          "",
          "[Removed Lines]",
          "3660:   static const ushort tab[18] =",
          "3661:   { 0xf11,0xf10,0xe0f,0xd0e,0xc0d,0xb0c,0xa0b,0x90a,0x809,",
          "3662:     0x708,0x607,0x506,0x405,0x304,0x303,0x300,0x202,0x201 };",
          "3663:   int i, c, n, col, row, sum=0;",
          "3666:   for (n=i=0; i < 18; i++)",
          "3669:   for (col = raw_width; col--; )",
          "3674:     for (row=0; row < raw_height+1; row+=2) {",
          "3675:       if (row == raw_height) row = 1;",
          "3676:       if ((sum += ljpeg_diff(huff)) >> 12) derror();",
          "3677:       if (row < height) RAW(row,col) = sum;",
          "",
          "[Added Lines]",
          "4097:   static const ushort tab[18] = {0xf11, 0xf10, 0xe0f, 0xd0e, 0xc0d, 0xb0c, 0xa0b, 0x90a, 0x809,",
          "4098:                                  0x708, 0x607, 0x506, 0x405, 0x304, 0x303, 0x300, 0x202, 0x201};",
          "4099:   int i, c, n, col, row, sum = 0;",
          "4102:   for (n = i = 0; i < 18; i++)",
          "4105:   for (col = raw_width; col--;)",
          "4110:     for (row = 0; row < raw_height + 1; row += 2)",
          "4111:     {",
          "4112:       if (row == raw_height)",
          "4113:         row = 1;",
          "4114:       if ((sum += ljpeg_diff(huff)) >> 12)",
          "4115:         derror();",
          "4116:       if (row < height)",
          "4117:         RAW(row, col) = sum;",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "3685:   ushort pix[16];",
          "3686:   int row, col, val, max, min, imax, imin, sh, bit, i;",
          "3690: #ifdef LIBRAW_LIBRARY_BUILD",
          "3692: #endif",
          "3694: #ifdef LIBRAW_LIBRARY_BUILD",
          "3696: #endif",
          "3709:         {",
          "3716:               bit += 7;",
          "3717:             }",
          "3718:         }",
          "3720:         {",
          "3725:         }",
          "3727:         {",
          "3734:               bit += 7;",
          "3735:             }",
          "3736:         }",
          "3738:         {",
          "3745:               bit += 7;",
          "3746:             }",
          "3747:         }",
          "3748: #else",
          "3758: #endif",
          "3760: #ifdef LIBRAW_LIBRARY_BUILD",
          "3762:         {",
          "3770:         }",
          "3772:         {",
          "3775:         }",
          "3776: #else",
          "3779: #endif",
          "3781:     }",
          "3783: #ifdef LIBRAW_LIBRARY_BUILD",
          "3786:     throw;",
          "3787:   }",
          "3790: #endif",
          "3792: }",
          "3794: void CLASS samsung_load_raw()",
          "",
          "[Removed Lines]",
          "3688:   data = (uchar *) malloc (raw_width+1);",
          "3689:   merror (data, \"sony_arw2_load_raw()\");",
          "3691:   try {",
          "3693:   for (row=0; row < height; row++) {",
          "3695:     checkCancel();",
          "3697:     fread (data, 1, raw_width, ifp);",
          "3698:     for (dp=data, col=0; col < raw_width-30; dp+=16) {",
          "3699:       max = 0x7ff & (val = sget4(dp));",
          "3700:       min = 0x7ff & val >> 11;",
          "3701:       imax = 0x0f & val >> 22;",
          "3702:       imin = 0x0f & val >> 26;",
          "3703:       for (sh=0; sh < 4 && 0x80 << sh <= max-min; sh++);",
          "3704: #ifdef LIBRAW_LIBRARY_BUILD",
          "3706:       if(! (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_ALLFLAGS) // no flag set",
          "3707:          || (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)",
          "3708:          )",
          "3710:           for (bit=30, i=0; i < 16; i++)",
          "3711:             if      (i == imax) pix[i] = max;",
          "3712:             else if (i == imin) pix[i] = min;",
          "3713:             else {",
          "3714:               pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;",
          "3715:               if (pix[i] > 0x7ff) pix[i] = 0x7ff;",
          "3719:       else if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_BASEONLY)",
          "3721:           for (bit=30, i=0; i < 16; i++)",
          "3722:             if      (i == imax) pix[i] = max;",
          "3723:             else if (i == imin) pix[i] = min;",
          "3724:             else pix[i]=0;",
          "3726:       else if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAONLY)",
          "3728:           for (bit=30, i=0; i < 16; i++)",
          "3729:             if      (i == imax) pix[i] = 0;",
          "3730:             else if (i == imin) pix[i] = 0;",
          "3731:             else {",
          "3732:               pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;",
          "3733:               if (pix[i] > 0x7ff) pix[i] = 0x7ff;",
          "3737:       else if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE)",
          "3739:           for (bit=30, i=0; i < 16; i++)",
          "3740:             if      (i == imax) pix[i] = 0;",
          "3741:             else if (i == imin) pix[i] = 0;",
          "3742:             else {",
          "3743:               pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh);",
          "3744:               if (pix[i] > 0x7ff) pix[i] = 0x7ff;",
          "3750:       for (bit=30, i=0; i < 16; i++)",
          "3751:  if      (i == imax) pix[i] = max;",
          "3752:  else if (i == imin) pix[i] = min;",
          "3753:  else {",
          "3754:    pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;",
          "3755:    if (pix[i] > 0x7ff) pix[i] = 0x7ff;",
          "3756:    bit += 7;",
          "3757:  }",
          "3761:       if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)",
          "3763:           for (i=0; i < 16; i++, col+=2)",
          "3764:             {",
          "3765:               unsigned slope = pix[i] < 1001? 2 : curve[pix[i]<<1]-curve[(pix[i]<<1)-2];",
          "3766:               unsigned step = 1 << sh;",
          "3767:               RAW(row,col)=curve[pix[i]<<1]>black+imgdata.params.sony_arw2_posterization_thr?",
          "3768:                 LIM(((slope*step*1000)/(curve[pix[i]<<1]-black)),0,10000):0;",
          "3769:             }",
          "3771:       else",
          "3773:           for (i=0; i < 16; i++, col+=2)",
          "3774:             RAW(row,col) = curve[pix[i] << 1];",
          "3777:       for (i=0; i < 16; i++, col+=2)",
          "3778:  RAW(row,col) = curve[pix[i] << 1] >> 2;",
          "3780:       col -= col & 1 ? 1:31;",
          "3782:   }",
          "3784:   } catch(...) {",
          "3785:     free (data);",
          "3788:   if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)",
          "3789:     maximum=10000;",
          "3791:   free (data);",
          "",
          "[Added Lines]",
          "4128:   data = (uchar *)malloc(raw_width + 1);",
          "4129:   merror(data, \"sony_arw2_load_raw()\");",
          "4131:   try",
          "4132:   {",
          "4134:     for (row = 0; row < height; row++)",
          "4135:     {",
          "4137:       checkCancel();",
          "4139:       fread(data, 1, raw_width, ifp);",
          "4140:       for (dp = data, col = 0; col < raw_width - 30; dp += 16)",
          "4141:       {",
          "4142:         max = 0x7ff & (val = sget4(dp));",
          "4143:         min = 0x7ff & val >> 11;",
          "4144:         imax = 0x0f & val >> 22;",
          "4145:         imin = 0x0f & val >> 26;",
          "4146:         for (sh = 0; sh < 4 && 0x80 << sh <= max - min; sh++)",
          "4147:           ;",
          "4148: #ifdef LIBRAW_LIBRARY_BUILD",
          "4150:         if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_ALLFLAGS) // no flag set",
          "4151:             || (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE))",
          "4153:           for (bit = 30, i = 0; i < 16; i++)",
          "4154:             if (i == imax)",
          "4155:               pix[i] = max;",
          "4156:             else if (i == imin)",
          "4157:               pix[i] = min;",
          "4158:             else",
          "4159:             {",
          "4160:               pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;",
          "4161:               if (pix[i] > 0x7ff)",
          "4162:                 pix[i] = 0x7ff;",
          "4166:         else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_BASEONLY)",
          "4168:           for (bit = 30, i = 0; i < 16; i++)",
          "4169:             if (i == imax)",
          "4170:               pix[i] = max;",
          "4171:             else if (i == imin)",
          "4172:               pix[i] = min;",
          "4173:             else",
          "4174:               pix[i] = 0;",
          "4176:         else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAONLY)",
          "4178:           for (bit = 30, i = 0; i < 16; i++)",
          "4179:             if (i == imax)",
          "4180:               pix[i] = 0;",
          "4181:             else if (i == imin)",
          "4182:               pix[i] = 0;",
          "4183:             else",
          "4184:             {",
          "4185:               pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;",
          "4186:               if (pix[i] > 0x7ff)",
          "4187:                 pix[i] = 0x7ff;",
          "4191:         else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE)",
          "4193:           for (bit = 30, i = 0; i < 16; i++)",
          "4194:             if (i == imax)",
          "4195:               pix[i] = 0;",
          "4196:             else if (i == imin)",
          "4197:               pix[i] = 0;",
          "4198:             else",
          "4199:             {",
          "4200:               pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh);",
          "4201:               if (pix[i] > 0x7ff)",
          "4202:                 pix[i] = 0x7ff;",
          "4208:       for (bit = 30, i = 0; i < 16; i++)",
          "4209:         if (i == imax)",
          "4210:           pix[i] = max;",
          "4211:         else if (i == imin)",
          "4212:           pix[i] = min;",
          "4213:         else",
          "4214:         {",
          "4215:           pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;",
          "4216:           if (pix[i] > 0x7ff)",
          "4217:             pix[i] = 0x7ff;",
          "4218:           bit += 7;",
          "4219:         }",
          "4223:         if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)",
          "4225:           for (i = 0; i < 16; i++, col += 2)",
          "4226:           {",
          "4227:             unsigned slope = pix[i] < 1001 ? 2 : curve[pix[i] << 1] - curve[(pix[i] << 1) - 2];",
          "4228:             unsigned step = 1 << sh;",
          "4229:             RAW(row, col) = curve[pix[i] << 1] > black + imgdata.params.sony_arw2_posterization_thr",
          "4230:                                 ? LIM(((slope * step * 1000) / (curve[pix[i] << 1] - black)), 0, 10000)",
          "4231:                                 : 0;",
          "4232:           }",
          "4234:         else",
          "4236:           for (i = 0; i < 16; i++, col += 2)",
          "4237:             RAW(row, col) = curve[pix[i] << 1];",
          "4240:       for (i = 0; i < 16; i++, col += 2)",
          "4241:         RAW(row, col) = curve[pix[i] << 1] >> 2;",
          "4243:         col -= col & 1 ? 1 : 31;",
          "4244:       }",
          "4247:   }",
          "4248:   catch (...)",
          "4249:   {",
          "4250:     free(data);",
          "4253:   if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)",
          "4254:     maximum = 10000;",
          "4256:   free(data);",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "3796:   int row, col, c, i, dir, op[4], len[4];",
          "3798:   order = 0x4949;",
          "3800: #ifdef LIBRAW_LIBRARY_BUILD",
          "3801:     checkCancel();",
          "3802: #endif",
          "3805:     ph1_bits(-1);",
          "3808:       dir = ph1_bits(1);",
          "3809:       FORC4 op[c] = ph1_bits(2);",
          "3814:       }",
          "3820:       }",
          "3821:     }",
          "3822:   }",
          "3826: }",
          "3828: void CLASS samsung2_load_raw()",
          "3829: {",
          "3834:   int i, c, n, row, col, diff;",
          "3836:   huff[0] = 10;",
          "3838:     FORC(1024 >> (tab[i] >> 8)) huff[++n] = tab[i];",
          "3839:   getbits(-1);",
          "3841:   {",
          "3842: #ifdef LIBRAW_LIBRARY_BUILD",
          "3843:     checkCancel();",
          "3844: #endif",
          "3851:     }",
          "3852:   }",
          "3853: }",
          "",
          "[Removed Lines]",
          "3799:   for (row=0; row < raw_height; row++) {",
          "3803:     fseek (ifp, strip_offset+row*4, SEEK_SET);",
          "3804:     fseek (ifp, data_offset+get4(), SEEK_SET);",
          "3806:     FORC4 len[c] = row < 2 ? 7:4;",
          "3807:     for (col=0; col < raw_width; col+=16) {",
          "3810:       FORC4 switch (op[c]) {",
          "3811:  case 3: len[c] = ph1_bits(4); break;",
          "3812:  case 2: len[c]--;  break;",
          "3813:  case 1: len[c]++;",
          "3815:       for (c=0; c < 16; c+=2) {",
          "3816:  i = len[((c & 1) << 1) | (c >> 3)];",
          "3817:         RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +",
          "3818:    (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);",
          "3819:  if (c == 14) c = -1;",
          "3823:   for (row=0; row < raw_height-1; row+=2)",
          "3824:     for (col=0; col < raw_width-1; col+=2)",
          "3825:       SWAP (RAW(row,col+1), RAW(row+1,col));",
          "3830:   static const ushort tab[14] =",
          "3831:   { 0x304,0x307,0x206,0x205,0x403,0x600,0x709,",
          "3832:     0x80a,0x90b,0xa0c,0xa0d,0x501,0x408,0x402 };",
          "3833:   ushort huff[1026], vpred[2][2] = {{0,0},{0,0}}, hpred[2];",
          "3837:   for (n=i=0; i < 14; i++)",
          "3840:   for (row=0; row < raw_height; row++)",
          "3845:     for (col=0; col < raw_width; col++) {",
          "3846:       diff = ljpeg_diff (huff);",
          "3847:       if (col < 2) hpred[col] = vpred[row & 1][col] += diff;",
          "3848:       else    hpred[col & 1] += diff;",
          "3849:       RAW(row,col) = hpred[col & 1];",
          "3850:       if (hpred[col & 1] >> tiff_bps) derror();",
          "",
          "[Added Lines]",
          "4264:   for (row = 0; row < raw_height; row++)",
          "4265:   {",
          "4269:     fseek(ifp, strip_offset + row * 4, SEEK_SET);",
          "4270:     fseek(ifp, data_offset + get4(), SEEK_SET);",
          "4272:     FORC4 len[c] = row < 2 ? 7 : 4;",
          "4273:     for (col = 0; col < raw_width; col += 16)",
          "4274:     {",
          "4277:       FORC4 switch (op[c])",
          "4278:       {",
          "4279:       case 3:",
          "4280:         len[c] = ph1_bits(4);",
          "4281:         break;",
          "4282:       case 2:",
          "4283:         len[c]--;",
          "4284:         break;",
          "4285:       case 1:",
          "4286:         len[c]++;",
          "4288:       for (c = 0; c < 16; c += 2)",
          "4289:       {",
          "4290:         i = len[((c & 1) << 1) | (c >> 3)];",
          "4291:         RAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) +",
          "4292:                             (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);",
          "4293:         if (c == 14)",
          "4294:           c = -1;",
          "4298:   for (row = 0; row < raw_height - 1; row += 2)",
          "4299:     for (col = 0; col < raw_width - 1; col += 2)",
          "4300:       SWAP(RAW(row, col + 1), RAW(row + 1, col));",
          "4305:   static const ushort tab[14] = {0x304, 0x307, 0x206, 0x205, 0x403, 0x600, 0x709,",
          "4306:                                  0x80a, 0x90b, 0xa0c, 0xa0d, 0x501, 0x408, 0x402};",
          "4307:   ushort huff[1026], vpred[2][2] = {{0, 0}, {0, 0}}, hpred[2];",
          "4311:   for (n = i = 0; i < 14; i++)",
          "4314:   for (row = 0; row < raw_height; row++)",
          "4319:     for (col = 0; col < raw_width; col++)",
          "4320:     {",
          "4321:       diff = ljpeg_diff(huff);",
          "4322:       if (col < 2)",
          "4323:         hpred[col] = vpred[row & 1][col] += diff;",
          "4324:       else",
          "4325:         hpred[col & 1] += diff;",
          "4326:       RAW(row, col) = hpred[col & 1];",
          "4327:       if (hpred[col & 1] >> tiff_bps)",
          "4328:         derror();",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "3858:   ushort lent[3][2], len[4], *prow[2];",
          "3860:   order = 0x4949;",
          "3862:   opt = fgetc(ifp);",
          "3865: #ifdef LIBRAW_LIBRARY_BUILD",
          "3866:     checkCancel();",
          "3867: #endif",
          "3869:     ph1_bits(-1);",
          "3878:       }",
          "3879:       if (opt & 2)",
          "3881:       else if (!ph1_bits(1))",
          "3902:       }",
          "3903:     }",
          "3904:   }",
          "3905: }",
          "3911: {",
          "3917:   int pix, s, count, bin, next, i, sym[3];",
          "3922:   getbits(-1);",
          "3927:       data = data << nbits | getbits(nbits);",
          "3928:       if (carry < 0)",
          "3930:       while (--nbits >= 0)",
          "3932:       if (nbits > 0)",
          "3943:       high -= low;",
          "3946:       high <<= nbits;",
          "3947:       next = hist[s][1];",
          "3952:       }",
          "3958:       }",
          "3959:       hist[s][1] = next;",
          "3960:       sym[s] = bin;",
          "",
          "[Removed Lines]",
          "3861:   fseek (ifp, 9, SEEK_CUR);",
          "3863:   init = (get2(),get2());",
          "3864:   for (row=0; row < raw_height; row++) {",
          "3868:     fseek (ifp, (data_offset-ftell(ifp)) & 15, SEEK_CUR);",
          "3870:     mag = 0; pmode = 7;",
          "3871:     FORC(6) ((ushort *)lent)[c] = row < 2 ? 7:4;",
          "3872:     prow[ row & 1] = &RAW(row-1,1-((row & 1) << 1)); // green",
          "3873:     prow[~row & 1] = &RAW(row-2,0);   // red and blue",
          "3874:     for (tab=0; tab+15 < raw_width; tab+=16) {",
          "3875:       if (~opt & 4 && !(tab & 63)) {",
          "3876:  i = ph1_bits(2);",
          "3877:  mag = i < 3 ? mag-'2'+\"204\"[i] : ph1_bits(12);",
          "3880:  pmode = 7 - 4*ph1_bits(1);",
          "3882:  pmode = ph1_bits(3);",
          "3883:       if (opt & 1 || !ph1_bits(1)) {",
          "3884:  FORC4 len[c] = ph1_bits(2);",
          "3885:  FORC4 {",
          "3886:    i = ((row & 1) << 1 | (c & 1)) % 3;",
          "3887:    len[c] = len[c] < 3 ? lent[i][0]-'1'+\"120\"[len[c]] : ph1_bits(4);",
          "3888:    lent[i][0] = lent[i][1];",
          "3889:    lent[i][1] = len[c];",
          "3890:  }",
          "3891:       }",
          "3892:       FORC(16) {",
          "3893:  col = tab + (((c & 7) << 1)^(c >> 3)^(row & 1));",
          "3894:  pred = (pmode == 7 || row < 2)",
          "3895:       ? (tab ? RAW(row,tab-2+(col & 1)) : init)",
          "3896:       : (prow[col & 1][col-'4'+\"0224468\"[pmode]] +",
          "3897:   prow[col & 1][col-'4'+\"0244668\"[pmode]] + 1) >> 1;",
          "3898:  diff = ph1_bits (i = len[c >> 2]);",
          "3899:  if (diff >> (i-1)) diff -= 1 << i;",
          "3900:  diff = diff * (mag*2+1) + mag;",
          "3901:  RAW(row,col) = pred + diff;",
          "3907: #define HOLE(row) ((holes >> (((row) - raw_height) & 7)) & 1)",
          "3910: void CLASS smal_decode_segment (unsigned seg[2][2], int holes)",
          "3912:   uchar hist[3][13] = {",
          "3913:     { 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },",
          "3914:     { 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },",
          "3915:     { 3, 3, 0, 0, 63,     47,     31,     15,    0 } };",
          "3916:   int low, high=0xff, carry=0, nbits=8;",
          "3918:   uchar diff, pred[]={0,0};",
          "3919:   ushort data=0, range=0;",
          "3921:   fseek (ifp, seg[0][1]+1, SEEK_SET);",
          "3923:   if (seg[1][0] > raw_width*raw_height)",
          "3924:        seg[1][0] = raw_width*raw_height;",
          "3925:   for (pix=seg[0][0]; pix < seg[1][0]; pix++) {",
          "3926:     for (s=0; s < 3; s++) {",
          "3929:  carry = (nbits += carry+1) < 1 ? nbits-1 : 0;",
          "3931:  if ((data >> nbits & 0xff) == 0xff) break;",
          "3933:    data = ((data & ((1 << (nbits-1)) - 1)) << 1) |",
          "3934:             ((data + (((data & (1 << (nbits-1)))) << 1)) & ((~0u) << nbits));",
          "3935:       if (nbits >= 0) {",
          "3936:  data += getbits(1);",
          "3937:  carry = nbits - 8;",
          "3938:       }",
          "3939:       count = ((((data-range+1) & 0xffff) << 2) - 1) / (high >> 4);",
          "3940:       for (bin=0; hist[s][bin+5] > count; bin++);",
          "3941:   low = hist[s][bin+5] * (high >> 4) >> 2;",
          "3942:       if (bin) high = hist[s][bin+4] * (high >> 4) >> 2;",
          "3944:       for (nbits=0; high << nbits < 128; nbits++);",
          "3945:       range = (range+low) << nbits;",
          "3948:       if (++hist[s][2] > hist[s][3]) {",
          "3949:  next = (next+1) & hist[s][0];",
          "3950:  hist[s][3] = (hist[s][next+4] - hist[s][next+5]) >> 2;",
          "3951:  hist[s][2] = 1;",
          "3953:       if (hist[s][hist[s][1]+4] - hist[s][hist[s][1]+5] > 1) {",
          "3954:  if (bin < hist[s][1])",
          "3955:    for (i=bin; i < hist[s][1]; i++) hist[s][i+5]--;",
          "3956:  else if (next <= bin)",
          "3957:    for (i=hist[s][1]; i < bin; i++) hist[s][i+5]++;",
          "",
          "[Added Lines]",
          "4339:   fseek(ifp, 9, SEEK_CUR);",
          "4341:   init = (get2(), get2());",
          "4342:   for (row = 0; row < raw_height; row++)",
          "4343:   {",
          "4347:     fseek(ifp, (data_offset - ftell(ifp)) & 15, SEEK_CUR);",
          "4349:     mag = 0;",
          "4350:     pmode = 7;",
          "4351:     FORC(6)((ushort *)lent)[c] = row < 2 ? 7 : 4;",
          "4352:     prow[row & 1] = &RAW(row - 1, 1 - ((row & 1) << 1)); // green",
          "4353:     prow[~row & 1] = &RAW(row - 2, 0);                   // red and blue",
          "4354:     for (tab = 0; tab + 15 < raw_width; tab += 16)",
          "4355:     {",
          "4356:       if (~opt & 4 && !(tab & 63))",
          "4357:       {",
          "4358:         i = ph1_bits(2);",
          "4359:         mag = i < 3 ? mag - '2' + \"204\"[i] : ph1_bits(12);",
          "4362:         pmode = 7 - 4 * ph1_bits(1);",
          "4364:         pmode = ph1_bits(3);",
          "4365:       if (opt & 1 || !ph1_bits(1))",
          "4366:       {",
          "4367:         FORC4 len[c] = ph1_bits(2);",
          "4368:         FORC4",
          "4369:         {",
          "4370:           i = ((row & 1) << 1 | (c & 1)) % 3;",
          "4371:           len[c] = len[c] < 3 ? lent[i][0] - '1' + \"120\"[len[c]] : ph1_bits(4);",
          "4372:           lent[i][0] = lent[i][1];",
          "4373:           lent[i][1] = len[c];",
          "4374:         }",
          "4375:       }",
          "4376:       FORC(16)",
          "4377:       {",
          "4378:         col = tab + (((c & 7) << 1) ^ (c >> 3) ^ (row & 1));",
          "4379:         pred =",
          "4380:             (pmode == 7 || row < 2)",
          "4381:                 ? (tab ? RAW(row, tab - 2 + (col & 1)) : init)",
          "4382:                 : (prow[col & 1][col - '4' + \"0224468\"[pmode]] + prow[col & 1][col - '4' + \"0244668\"[pmode]] + 1) >> 1;",
          "4383:         diff = ph1_bits(i = len[c >> 2]);",
          "4384:         if (diff >> (i - 1))",
          "4385:           diff -= 1 << i;",
          "4386:         diff = diff * (mag * 2 + 1) + mag;",
          "4387:         RAW(row, col) = pred + diff;",
          "4393: #define HOLE(row) ((holes >> (((row)-raw_height) & 7)) & 1)",
          "4396: void CLASS smal_decode_segment(unsigned seg[2][2], int holes)",
          "4398:   uchar hist[3][13] = {{7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0},",
          "4399:                        {7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0},",
          "4400:                        {3, 3, 0, 0, 63, 47, 31, 15, 0}};",
          "4401:   int low, high = 0xff, carry = 0, nbits = 8;",
          "4403:   uchar diff, pred[] = {0, 0};",
          "4404:   ushort data = 0, range = 0;",
          "4406:   fseek(ifp, seg[0][1] + 1, SEEK_SET);",
          "4408:   if (seg[1][0] > raw_width * raw_height)",
          "4409:     seg[1][0] = raw_width * raw_height;",
          "4410:   for (pix = seg[0][0]; pix < seg[1][0]; pix++)",
          "4411:   {",
          "4412:     for (s = 0; s < 3; s++)",
          "4413:     {",
          "4416:         carry = (nbits += carry + 1) < 1 ? nbits - 1 : 0;",
          "4418:         if ((data >> nbits & 0xff) == 0xff)",
          "4419:           break;",
          "4421:         data = ((data & ((1 << (nbits - 1)) - 1)) << 1) |",
          "4422:                ((data + (((data & (1 << (nbits - 1)))) << 1)) & ((~0u) << nbits));",
          "4423:       if (nbits >= 0)",
          "4424:       {",
          "4425:         data += getbits(1);",
          "4426:         carry = nbits - 8;",
          "4427:       }",
          "4428:       count = ((((data - range + 1) & 0xffff) << 2) - 1) / (high >> 4);",
          "4429:       for (bin = 0; hist[s][bin + 5] > count; bin++)",
          "4430:         ;",
          "4431:       low = hist[s][bin + 5] * (high >> 4) >> 2;",
          "4432:       if (bin)",
          "4433:         high = hist[s][bin + 4] * (high >> 4) >> 2;",
          "4435:       for (nbits = 0; high << nbits < 128; nbits++)",
          "4436:         ;",
          "4437:       range = (range + low) << nbits;",
          "4440:       if (++hist[s][2] > hist[s][3])",
          "4441:       {",
          "4442:         next = (next + 1) & hist[s][0];",
          "4443:         hist[s][3] = (hist[s][next + 4] - hist[s][next + 5]) >> 2;",
          "4444:         hist[s][2] = 1;",
          "4446:       if (hist[s][hist[s][1] + 4] - hist[s][hist[s][1] + 5] > 1)",
          "4447:       {",
          "4448:         if (bin < hist[s][1])",
          "4449:           for (i = bin; i < hist[s][1]; i++)",
          "4450:             hist[s][i + 5]--;",
          "4451:         else if (next <= bin)",
          "4452:           for (i = hist[s][1]; i < bin; i++)",
          "4453:             hist[s][i + 5]++;",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "3965:     if (ftell(ifp) + 12 >= seg[1][1])",
          "3966:       diff = 0;",
          "3967: #ifdef LIBRAW_LIBRARY_BUILD",
          "3969:       throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "3970: #endif",
          "3971:     raw_image[pix] = pred[pix & 1] += diff;",
          "3973:   }",
          "3974:   maximum = 0xff;",
          "3975: }",
          "",
          "[Removed Lines]",
          "3968:     if(pix>=raw_width*raw_height)",
          "3972:     if (!(pix & 1) && HOLE(pix / raw_width)) pix += 2;",
          "",
          "[Added Lines]",
          "4464:     if (pix >= raw_width * raw_height)",
          "4468:     if (!(pix & 1) && HOLE(pix / raw_width))",
          "4469:       pix += 2;",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "3978: {",
          "3979:   unsigned seg[2][2];",
          "3982:   seg[0][0] = 0;",
          "3983:   seg[0][1] = get2();",
          "3984:   seg[1][0] = raw_width * raw_height;",
          "3985:   seg[1][1] = INT_MAX;",
          "3987: }",
          "3990: {",
          "3991:   int min, max, sum, i;",
          "3993:   min = max = sum = p[0];",
          "3995:     sum += p[i];",
          "3998:   }",
          "3999:   return (sum - min - max) >> 1;",
          "4000: }",
          "4003: {",
          "4004:   int row, col, val[4];",
          "4024:       }",
          "4025:   }",
          "4026: }",
          "",
          "[Removed Lines]",
          "3981:   fseek (ifp, 16, SEEK_SET);",
          "3986:   smal_decode_segment (seg, 0);",
          "3989: int CLASS median4 (int *p)",
          "3994:   for (i=1; i < 4; i++) {",
          "3996:     if (min > p[i]) min = p[i];",
          "3997:     if (max < p[i]) max = p[i];",
          "4002: void CLASS fill_holes (int holes)",
          "4006:   for (row=2; row < height-2; row++) {",
          "4007:     if (!HOLE(row)) continue;",
          "4008:     for (col=1; col < width-1; col+=4) {",
          "4009:       val[0] = RAW(row-1,col-1);",
          "4010:       val[1] = RAW(row-1,col+1);",
          "4011:       val[2] = RAW(row+1,col-1);",
          "4012:       val[3] = RAW(row+1,col+1);",
          "4013:       RAW(row,col) = median4(val);",
          "4014:     }",
          "4015:     for (col=2; col < width-2; col+=4)",
          "4016:       if (HOLE(row-2) || HOLE(row+2))",
          "4017:  RAW(row,col) = (RAW(row,col-2) + RAW(row,col+2)) >> 1;",
          "4018:       else {",
          "4019:  val[0] = RAW(row,col-2);",
          "4020:  val[1] = RAW(row,col+2);",
          "4021:  val[2] = RAW(row-2,col);",
          "4022:  val[3] = RAW(row+2,col);",
          "4023:  RAW(row,col) = median4(val);",
          "",
          "[Added Lines]",
          "4478:   fseek(ifp, 16, SEEK_SET);",
          "4483:   smal_decode_segment(seg, 0);",
          "4486: int CLASS median4(int *p)",
          "4491:   for (i = 1; i < 4; i++)",
          "4492:   {",
          "4494:     if (min > p[i])",
          "4495:       min = p[i];",
          "4496:     if (max < p[i])",
          "4497:       max = p[i];",
          "4502: void CLASS fill_holes(int holes)",
          "4506:   for (row = 2; row < height - 2; row++)",
          "4507:   {",
          "4508:     if (!HOLE(row))",
          "4509:       continue;",
          "4510:     for (col = 1; col < width - 1; col += 4)",
          "4511:     {",
          "4512:       val[0] = RAW(row - 1, col - 1);",
          "4513:       val[1] = RAW(row - 1, col + 1);",
          "4514:       val[2] = RAW(row + 1, col - 1);",
          "4515:       val[3] = RAW(row + 1, col + 1);",
          "4516:       RAW(row, col) = median4(val);",
          "4517:     }",
          "4518:     for (col = 2; col < width - 2; col += 4)",
          "4519:       if (HOLE(row - 2) || HOLE(row + 2))",
          "4520:         RAW(row, col) = (RAW(row, col - 2) + RAW(row, col + 2)) >> 1;",
          "4521:       else",
          "4522:       {",
          "4523:         val[0] = RAW(row, col - 2);",
          "4524:         val[1] = RAW(row, col + 2);",
          "4525:         val[2] = RAW(row - 2, col);",
          "4526:         val[3] = RAW(row + 2, col);",
          "4527:         RAW(row, col) = median4(val);",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "4029: {",
          "4030:   unsigned seg[256][2], offset, nseg, holes, i;",
          "4033:   offset = get4();",
          "4039:   holes = fgetc(ifp);",
          "4041:   seg[nseg][0] = raw_height * raw_width;",
          "4042:   seg[nseg][1] = get4() + data_offset;",
          "4046: }",
          "4048: void CLASS redcine_load_raw()",
          "",
          "[Removed Lines]",
          "4032:   fseek (ifp, 67, SEEK_SET);",
          "4034:   nseg = (uchar) fgetc(ifp);",
          "4035:   fseek (ifp, offset, SEEK_SET);",
          "4036:   for (i=0; i < nseg*2; i++)",
          "4037:     ((unsigned *)seg)[i] = get4() + data_offset*(i & 1);",
          "4038:   fseek (ifp, 78, SEEK_SET);",
          "4040:   fseek (ifp, 88, SEEK_SET);",
          "4043:   for (i=0; i < nseg; i++)",
          "4044:     smal_decode_segment (seg+i, holes);",
          "4045:   if (holes) fill_holes (holes);",
          "",
          "[Added Lines]",
          "4536:   fseek(ifp, 67, SEEK_SET);",
          "4538:   nseg = (uchar)fgetc(ifp);",
          "4539:   fseek(ifp, offset, SEEK_SET);",
          "4540:   for (i = 0; i < nseg * 2; i++)",
          "4541:     ((unsigned *)seg)[i] = get4() + data_offset * (i & 1);",
          "4542:   fseek(ifp, 78, SEEK_SET);",
          "4544:   fseek(ifp, 88, SEEK_SET);",
          "4547:   for (i = 0; i < nseg; i++)",
          "4548:     smal_decode_segment(seg + i, holes);",
          "4549:   if (holes)",
          "4550:     fill_holes(holes);",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "4058:   jas_init();",
          "4059: #ifndef LIBRAW_LIBRARY_BUILD",
          "4061: #else",
          "4065: #endif",
          "4068: #ifndef LIBRAW_LIBRARY_BUILD",
          "4070: #else",
          "4076: #endif",
          "4081: #ifdef LIBRAW_LIBRARY_BUILD",
          "4082:   bool fastexitflag = false;",
          "4084: #endif",
          "4086: #ifdef LIBRAW_LIBRARY_BUILD",
          "4088: #endif",
          "4104: #ifdef LIBRAW_LIBRARY_BUILD",
          "4106: #endif",
          "4112:     }",
          "4116: #ifdef LIBRAW_LIBRARY_BUILD",
          "4118: #endif",
          "4122: #ifdef LIBRAW_LIBRARY_BUILD",
          "4125:   }",
          "4126: #endif",
          "4131: #ifdef LIBRAW_LIBRARY_BUILD",
          "4133:     throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;",
          "4134: #endif",
          "4135: #endif",
          "",
          "[Removed Lines]",
          "4060:   in = jas_stream_fopen (ifname, \"rb\");",
          "4062:   in = (jas_stream_t*)ifp->make_jas_stream();",
          "4063:   if(!in)",
          "4064:           throw LIBRAW_EXCEPTION_DECODE_JPEG2000;",
          "4066:   jas_stream_seek (in, data_offset+20, SEEK_SET);",
          "4067:   jimg = jas_image_decode (in, -1, 0);",
          "4069:   if (!jimg) longjmp (failure, 3);",
          "4071:   if(!jimg)",
          "4072:     {",
          "4073:       jas_stream_close (in);",
          "4074:       throw LIBRAW_EXCEPTION_DECODE_JPEG2000;",
          "4075:     }",
          "4077:   jmat = jas_matrix_create (height/2, width/2);",
          "4078:   merror (jmat, \"redcine_load_raw()\");",
          "4079:   img = (ushort *) calloc ((height+2), (width+2)*2);",
          "4080:   merror (img, \"redcine_load_raw()\");",
          "4083:   try {",
          "4085:   FORC4 {",
          "4087:     checkCancel();",
          "4089:     jas_image_readcmpt (jimg, c, 0, 0, width/2, height/2, jmat);",
          "4090:     data = jas_matrix_getref (jmat, 0, 0);",
          "4091:     for (row = c >> 1; row < height; row+=2)",
          "4092:       for (col = c & 1; col < width; col+=2)",
          "4093:  img[(row+1)*(width+2)+col+1] = data[(row/2)*(width/2)+col/2];",
          "4094:   }",
          "4095:   for (col=1; col <= width; col++) {",
          "4096:     img[col] = img[2*(width+2)+col];",
          "4097:     img[(height+1)*(width+2)+col] = img[(height-1)*(width+2)+col];",
          "4098:   }",
          "4099:   for (row=0; row < height+2; row++) {",
          "4100:     img[row*(width+2)] = img[row*(width+2)+2];",
          "4101:     img[(row+1)*(width+2)-1] = img[(row+1)*(width+2)-3];",
          "4102:   }",
          "4103:   for (row=1; row <= height; row++) {",
          "4105:     checkCancel();",
          "4107:     pix = img + row*(width+2) + (col = 1 + (FC(row,1) & 1));",
          "4108:     for (   ; col <= width; col+=2, pix+=2) {",
          "4109:       c = (((pix[0] - 0x800) << 3) +",
          "4110:  pix[-(width+2)] + pix[width+2] + pix[-1] + pix[1]) >> 2;",
          "4111:       pix[0] = LIM(c,0,4095);",
          "4113:   }",
          "4114:   for (row=0; row < height; row++)",
          "4115:   {",
          "4117:     checkCancel();",
          "4119:     for (col=0; col < width; col++)",
          "4120:       RAW(row,col) = curve[img[(row+1)*(width+2)+col+1]];",
          "4121:   }",
          "4123:   } catch (...) {",
          "4124:     fastexitflag=true;",
          "4127:   free (img);",
          "4128:   jas_matrix_destroy (jmat);",
          "4129:   jas_image_destroy (jimg);",
          "4130:   jas_stream_close (in);",
          "4132:   if(fastexitflag)",
          "",
          "[Added Lines]",
          "4565:   in = jas_stream_fopen(ifname, \"rb\");",
          "4567:   in = (jas_stream_t *)ifp->make_jas_stream();",
          "4568:   if (!in)",
          "4569:     throw LIBRAW_EXCEPTION_DECODE_JPEG2000;",
          "4571:   jas_stream_seek(in, data_offset + 20, SEEK_SET);",
          "4572:   jimg = jas_image_decode(in, -1, 0);",
          "4574:   if (!jimg)",
          "4575:     longjmp(failure, 3);",
          "4577:   if (!jimg)",
          "4578:   {",
          "4579:     jas_stream_close(in);",
          "4580:     throw LIBRAW_EXCEPTION_DECODE_JPEG2000;",
          "4581:   }",
          "4583:   jmat = jas_matrix_create(height / 2, width / 2);",
          "4584:   merror(jmat, \"redcine_load_raw()\");",
          "4585:   img = (ushort *)calloc((height + 2), (width + 2) * 2);",
          "4586:   merror(img, \"redcine_load_raw()\");",
          "4589:   try",
          "4590:   {",
          "4592:     FORC4",
          "4593:     {",
          "4595:       checkCancel();",
          "4597:       jas_image_readcmpt(jimg, c, 0, 0, width / 2, height / 2, jmat);",
          "4598:       data = jas_matrix_getref(jmat, 0, 0);",
          "4599:       for (row = c >> 1; row < height; row += 2)",
          "4600:         for (col = c & 1; col < width; col += 2)",
          "4601:           img[(row + 1) * (width + 2) + col + 1] = data[(row / 2) * (width / 2) + col / 2];",
          "4602:     }",
          "4603:     for (col = 1; col <= width; col++)",
          "4604:     {",
          "4605:       img[col] = img[2 * (width + 2) + col];",
          "4606:       img[(height + 1) * (width + 2) + col] = img[(height - 1) * (width + 2) + col];",
          "4607:     }",
          "4608:     for (row = 0; row < height + 2; row++)",
          "4609:     {",
          "4610:       img[row * (width + 2)] = img[row * (width + 2) + 2];",
          "4611:       img[(row + 1) * (width + 2) - 1] = img[(row + 1) * (width + 2) - 3];",
          "4612:     }",
          "4613:     for (row = 1; row <= height; row++)",
          "4614:     {",
          "4616:       checkCancel();",
          "4618:       pix = img + row * (width + 2) + (col = 1 + (FC(row, 1) & 1));",
          "4619:       for (; col <= width; col += 2, pix += 2)",
          "4620:       {",
          "4621:         c = (((pix[0] - 0x800) << 3) + pix[-(width + 2)] + pix[width + 2] + pix[-1] + pix[1]) >> 2;",
          "4622:         pix[0] = LIM(c, 0, 4095);",
          "4623:       }",
          "4625:     for (row = 0; row < height; row++)",
          "4626:     {",
          "4628:       checkCancel();",
          "4630:       for (col = 0; col < width; col++)",
          "4631:         RAW(row, col) = curve[img[(row + 1) * (width + 2) + col + 1]];",
          "4632:     }",
          "4634:   }",
          "4635:   catch (...)",
          "4636:   {",
          "4637:     fastexitflag = true;",
          "4640:   free(img);",
          "4641:   jas_matrix_destroy(jmat);",
          "4642:   jas_image_destroy(jimg);",
          "4643:   jas_stream_close(in);",
          "4645:   if (fastexitflag)",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "4142: {",
          "4143:   static unsigned huff[1024];",
          "4144:   struct decode *cur;",
          "4145:   int i, len;",
          "4149:       huff[i] = get4();",
          "4151:     free_decode = first_decode;",
          "4152:   }",
          "4153:   cur = free_decode++;",
          "4157:   }",
          "4158:   if (code)",
          "4163:       }",
          "4167:   cur->branch[0] = free_decode;",
          "4169:   cur->branch[1] = free_decode;",
          "4171: }",
          "4173: void CLASS foveon_thumb()",
          "4174: {",
          "4176:   char *buf;",
          "4177:   struct decode *dindex;",
          "4178:   short pred[3];",
          "4180:   bwide = get4();",
          "4191:     return;",
          "4192:   }",
          "4208:       }",
          "4209:   }",
          "4210: }",
          "",
          "[Removed Lines]",
          "4141: void CLASS foveon_decoder (unsigned size, unsigned code)",
          "4147:   if (!code) {",
          "4148:     for (i=0; i < size; i++)",
          "4150:     memset (first_decode, 0, sizeof first_decode);",
          "4154:   if (free_decode > first_decode+2048) {",
          "4155:     fprintf (stderr,_(\"%s: decoder table overflow\\n\"), ifname);",
          "4156:     longjmp (failure, 2);",
          "4159:     for (i=0; i < size; i++)",
          "4160:       if (huff[i] == code) {",
          "4161:  cur->leaf = i;",
          "4162:  return;",
          "4164:   if ((len = code >> 27) > 26) return;",
          "4165:   code = (len+1) << 27 | (code & 0x3ffffff) << 1;",
          "4168:   foveon_decoder (size, code);",
          "4170:   foveon_decoder (size, code+1);",
          "4175:   unsigned bwide, row, col, bitbuf=0, bit=1, c, i;",
          "4181:   fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);",
          "4182:   if (bwide > 0) {",
          "4183:     if (bwide < thumb_width*3) return;",
          "4184:     buf = (char *) malloc (bwide);",
          "4185:     merror (buf, \"foveon_thumb()\");",
          "4186:     for (row=0; row < thumb_height; row++) {",
          "4187:       fread  (buf, 1, bwide, ifp);",
          "4188:       fwrite (buf, 3, thumb_width, ofp);",
          "4189:     }",
          "4190:     free (buf);",
          "4193:   foveon_decoder (256, 0);",
          "4195:   for (row=0; row < thumb_height; row++) {",
          "4196:     memset (pred, 0, sizeof pred);",
          "4197:     if (!bit) get4();",
          "4198:     for (bit=col=0; col < thumb_width; col++)",
          "4199:       FORC3 {",
          "4200:  for (dindex=first_decode; dindex->branch[0]; ) {",
          "4201:    if ((bit = (bit-1) & 31) == 31)",
          "4202:      for (i=0; i < 4; i++)",
          "4203:        bitbuf = (bitbuf << 8) + fgetc(ifp);",
          "4204:    dindex = dindex->branch[bitbuf >> bit & 1];",
          "4205:  }",
          "4206:  pred[c] += dindex->leaf;",
          "4207:  fputc (pred[c], ofp);",
          "",
          "[Added Lines]",
          "4654: void CLASS foveon_decoder(unsigned size, unsigned code)",
          "4660:   if (!code)",
          "4661:   {",
          "4662:     for (i = 0; i < size; i++)",
          "4664:     memset(first_decode, 0, sizeof first_decode);",
          "4668:   if (free_decode > first_decode + 2048)",
          "4669:   {",
          "4670:     fprintf(stderr, _(\"%s: decoder table overflow\\n\"), ifname);",
          "4671:     longjmp(failure, 2);",
          "4674:     for (i = 0; i < size; i++)",
          "4675:       if (huff[i] == code)",
          "4676:       {",
          "4677:         cur->leaf = i;",
          "4678:         return;",
          "4680:   if ((len = code >> 27) > 26)",
          "4681:     return;",
          "4682:   code = (len + 1) << 27 | (code & 0x3ffffff) << 1;",
          "4685:   foveon_decoder(size, code);",
          "4687:   foveon_decoder(size, code + 1);",
          "4692:   unsigned bwide, row, col, bitbuf = 0, bit = 1, c, i;",
          "4698:   fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);",
          "4699:   if (bwide > 0)",
          "4700:   {",
          "4701:     if (bwide < thumb_width * 3)",
          "4702:       return;",
          "4703:     buf = (char *)malloc(bwide);",
          "4704:     merror(buf, \"foveon_thumb()\");",
          "4705:     for (row = 0; row < thumb_height; row++)",
          "4706:     {",
          "4707:       fread(buf, 1, bwide, ifp);",
          "4708:       fwrite(buf, 3, thumb_width, ofp);",
          "4709:     }",
          "4710:     free(buf);",
          "4713:   foveon_decoder(256, 0);",
          "4715:   for (row = 0; row < thumb_height; row++)",
          "4716:   {",
          "4717:     memset(pred, 0, sizeof pred);",
          "4718:     if (!bit)",
          "4719:       get4();",
          "4720:     for (bit = col = 0; col < thumb_width; col++)",
          "4721:       FORC3",
          "4722:       {",
          "4723:         for (dindex = first_decode; dindex->branch[0];)",
          "4724:         {",
          "4725:           if ((bit = (bit - 1) & 31) == 31)",
          "4726:             for (i = 0; i < 4; i++)",
          "4727:               bitbuf = (bitbuf << 8) + fgetc(ifp);",
          "4728:           dindex = dindex->branch[bitbuf >> bit & 1];",
          "4729:         }",
          "4730:         pred[c] += dindex->leaf;",
          "4731:         fputc(pred[c], ofp);",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "4213: {",
          "4214:   struct decode *dindex;",
          "4215:   short diff[1024];",
          "4223: #ifdef LIBRAW_LIBRARY_BUILD",
          "4224:     checkCancel();",
          "4225: #endif",
          "4242:       }",
          "4244:     }",
          "4245:   }",
          "4246: }",
          "4249: {",
          "4250:   int i, j, clen, code;",
          "4252:   huff[0] = 8;",
          "4254:     clen = getc(ifp);",
          "4255:     code = getc(ifp);",
          "4258:   }",
          "4259:   get2();",
          "4260: }",
          "",
          "[Removed Lines]",
          "4216:   unsigned bitbuf=0;",
          "4217:   int pred[3], row, col, bit=-1, c, i;",
          "4219:   read_shorts ((ushort *) diff, 1024);",
          "4220:   if (!load_flags) foveon_decoder (1024, 0);",
          "4222:   for (row=0; row < height; row++) {",
          "4226:     memset (pred, 0, sizeof pred);",
          "4227:     if (!bit && !load_flags && atoi(model+2) < 14) get4();",
          "4228:     for (col=bit=0; col < width; col++) {",
          "4229:       if (load_flags) {",
          "4230:  bitbuf = get4();",
          "4231:  FORC3 pred[2-c] += diff[bitbuf >> c*10 & 0x3ff];",
          "4232:       }",
          "4233:       else FORC3 {",
          "4234:  for (dindex=first_decode; dindex->branch[0]; ) {",
          "4235:    if ((bit = (bit-1) & 31) == 31)",
          "4236:      for (i=0; i < 4; i++)",
          "4237:        bitbuf = (bitbuf << 8) + fgetc(ifp);",
          "4238:    dindex = dindex->branch[bitbuf >> bit & 1];",
          "4239:  }",
          "4240:  pred[c] += diff[dindex->leaf];",
          "4241:  if (pred[c] >> 16 && ~pred[c] >> 16) derror();",
          "4243:       FORC3 image[row*width+col][c] = pred[c];",
          "4248: void CLASS foveon_huff (ushort *huff)",
          "4253:   for (i=0; i < 13; i++) {",
          "4256:     for (j=0; j < 256 >> clen; )",
          "4257:       huff[code+ ++j] = clen << 8 | i;",
          "",
          "[Added Lines]",
          "4740:   unsigned bitbuf = 0;",
          "4741:   int pred[3], row, col, bit = -1, c, i;",
          "4743:   read_shorts((ushort *)diff, 1024);",
          "4744:   if (!load_flags)",
          "4745:     foveon_decoder(1024, 0);",
          "4747:   for (row = 0; row < height; row++)",
          "4748:   {",
          "4752:     memset(pred, 0, sizeof pred);",
          "4753:     if (!bit && !load_flags && atoi(model + 2) < 14)",
          "4754:       get4();",
          "4755:     for (col = bit = 0; col < width; col++)",
          "4756:     {",
          "4757:       if (load_flags)",
          "4758:       {",
          "4759:         bitbuf = get4();",
          "4760:         FORC3 pred[2 - c] += diff[bitbuf >> c * 10 & 0x3ff];",
          "4762:       else",
          "4763:         FORC3",
          "4764:         {",
          "4765:           for (dindex = first_decode; dindex->branch[0];)",
          "4766:           {",
          "4767:             if ((bit = (bit - 1) & 31) == 31)",
          "4768:               for (i = 0; i < 4; i++)",
          "4769:                 bitbuf = (bitbuf << 8) + fgetc(ifp);",
          "4770:             dindex = dindex->branch[bitbuf >> bit & 1];",
          "4771:           }",
          "4772:           pred[c] += diff[dindex->leaf];",
          "4773:           if (pred[c] >> 16 && ~pred[c] >> 16)",
          "4774:             derror();",
          "4775:         }",
          "4776:       FORC3 image[row * width + col][c] = pred[c];",
          "4781: void CLASS foveon_huff(ushort *huff)",
          "4786:   for (i = 0; i < 13; i++)",
          "4787:   {",
          "4790:     for (j = 0; j<256>> clen;)",
          "4791:       huff[code + ++j] = clen << 8 | i;",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "4264:   unsigned c, roff[4], row, col, diff;",
          "4265:   ushort huff[512], vpred[2][2], hpred[2];",
          "4269:   roff[0] = 48;",
          "4273:     getbits(-1);",
          "4274:     vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;",
          "4276: #ifdef LIBRAW_LIBRARY_BUILD",
          "4278: #endif",
          "4284:       }",
          "4285:     }",
          "4286:   }",
          "4287: }",
          "4290: void CLASS foveon_load_camf()",
          "4291: {",
          "4292:   unsigned type, wide, high, i, j, row, col, diff;",
          "4297:   wide = get4();",
          "4298:   high = get4();",
          "4302:       high = (high * 1597 + 51749) % 244944;",
          "4304:       meta_data[i] ^= ((((high << 8) - wide) >> 1) + wide) >> 17;",
          "4305:     }",
          "4311:     get4();",
          "4312:     getbits(-1);",
          "4323:       }",
          "4324:     }",
          "4325:   }",
          "4326: #ifdef DCRAW_VERBOSE",
          "4329: #endif",
          "4330: }",
          "4333: {",
          "4334:   unsigned idx, num;",
          "4335:   char *pos, *cp, *dp;",
          "4338:     pos = meta_data + idx;",
          "4343:     num = sget4(cp);",
          "4346:       cp += 8;",
          "4349:     }",
          "4350:   }",
          "4351:   return 0;",
          "4352: }",
          "4355: {",
          "4356:   unsigned i, idx, type, ndim, size, *mat;",
          "4357:   char *pos, *cp, *dp;",
          "4358:   double dsize;",
          "4361:     pos = meta_data + idx;",
          "4365:     dim[0] = dim[1] = dim[2] = 1;",
          "4367:     type = sget4(cp);",
          "4371:       cp += 12;",
          "4372:       dim[i] = sget4(cp);",
          "4373:     }",
          "4378:       if (type && type != 6)",
          "4380:       else",
          "4382:     return mat;",
          "4383:   }",
          "4384: #ifdef DCRAW_VERBOSE",
          "4386: #endif",
          "4387:   return 0;",
          "4388: }",
          "4391: {",
          "4392:   void *dp;",
          "4393:   unsigned dim[3];",
          "4400:   return 1;",
          "4401: }",
          "4404: {",
          "4405:   int i;",
          "4414:   return (sum - min - max) / (range[1] - range[0] - 1);",
          "4415: }",
          "4418: {",
          "4419:   short *curve;",
          "4420:   unsigned i, size;",
          "4421:   double x;",
          "4428:   curve[0] = size;",
          "4432:   }",
          "4433:   return curve;",
          "4434: }",
          "4438: {",
          "4440:   int c;",
          "4443:   FORC3 if (max < mul[c]) max = mul[c];",
          "4445: }",
          "4448: {",
          "4451: }",
          "4455: void CLASS foveon_interpolate()",
          "4456: {",
          "4458:   short *pix, prev[3], *curve[8], (*shrink)[3];",
          "4460:   float cam_xyz[3][3], correct[3][3], last[3][3], trans[3][3];",
          "4461:   float chroma_dq[3], color_dq[3], diag[3][3], div[3];",
          "4463:   float fsum[3], val, frow, num;",
          "4464:   int row, col, c, i, j, diff, sgx, irow, sum, min, max, limit;",
          "4465:   int dscr[2][2], dstb[4], (*smrow[7])[3], total[4], ipix[3];",
          "4467:   int satlev[3], keep[4], active[4];",
          "4468:   unsigned dim[3], *badpix;",
          "4470:   char str[128];",
          "4473: #ifdef DCRAW_VERBOSE",
          "4474:   if (verbose)",
          "4476: #endif",
          "4478:   foveon_load_camf();",
          "4496:       for (row = dstb[1]; row <= dstb[3]; row++)",
          "4500:     }",
          "4503:   {",
          "4504: #ifdef DCRAW_VERBOSE",
          "4514:       FORC3 last[i][j] += correct[i][c] * cam_xyz[c][j];",
          "4524:   num = 0;",
          "4525:   FORC3 if (num < div[c]) num = div[c];",
          "4526:   FORC3 div[c] /= num;",
          "4531:       FORC3 trans[i][j] += rgb_cam[i][c] * last[c][j] * div[j];",
          "4532:   FORC3 trsum[c] = trans[c][0] + trans[c][1] + trans[c][2];",
          "4535:     FORC3 last[i][c] = trans[i][c] * dsum / trsum[i];",
          "4542:   FORC3 chroma_dq[c] /= 3;",
          "4544:   FORC3 dsum += chroma_dq[c] / div[c];",
          "4586:   FORC3 fsum[c] /= height;",
          "4595:       total[3]++;",
          "4596:     }",
          "4608:     frow -= irow;",
          "4634:       }",
          "4635:       pix += 4;",
          "4636:     }",
          "4637:   }",
          "4644:       col = (badpix[i] >> 8 & 0xfff) - keep[0];",
          "4656:     }",
          "4658:   }",
          "4683:       if (col == 2)",
          "4687:       pix[0] = i;",
          "4688:       smred_p = smred;",
          "4689:       pix += 4;",
          "",
          "[Removed Lines]",
          "4267:   fseek (ifp, 8, SEEK_CUR);",
          "4268:   foveon_huff (huff);",
          "4270:   FORC3 roff[c+1] = -(-(roff[c] + get4()) & -16);",
          "4271:   FORC3 {",
          "4272:     fseek (ifp, data_offset+roff[c], SEEK_SET);",
          "4275:     for (row=0; row < height; row++) {",
          "4277:     checkCancel();",
          "4279:       for (col=0; col < width; col++) {",
          "4280:        diff = ljpeg_diff(huff);",
          "4281:        if (col < 2) hpred[col] = vpred[row & 1][col] += diff;",
          "4282:        else hpred[col & 1] += diff;",
          "4283:        image[row*width+col][c] = hpred[col & 1];",
          "4293:   ushort huff[258], vpred[2][2] = {{512,512},{512,512}}, hpred[2];",
          "4295:   fseek (ifp, meta_offset, SEEK_SET);",
          "4296:   type = get4();  get4();  get4();",
          "4299:   if (type == 2) {",
          "4300:     fread (meta_data, 1, meta_length, ifp);",
          "4301:     for (i=0; i < meta_length; i++) {",
          "4303:       wide = high * (INT64) 301593171 >> 24;",
          "4306:   } else if (type == 4) {",
          "4307:     free (meta_data);",
          "4308:     meta_data = (char *) malloc (meta_length = wide*high*3/2);",
          "4309:     merror (meta_data, \"foveon_load_camf()\");",
          "4310:     foveon_huff (huff);",
          "4313:     for (j=row=0; row < high; row++) {",
          "4314:       for (col=0; col < wide; col++) {",
          "4315:  diff = ljpeg_diff(huff);",
          "4316:  if (col < 2) hpred[col] = vpred[row & 1][col] += diff;",
          "4317:  else         hpred[col & 1] += diff;",
          "4318:  if (col & 1) {",
          "4319:    meta_data[j++] = hpred[0] >> 4;",
          "4320:    meta_data[j++] = hpred[0] << 4 | hpred[1] >> 8;",
          "4321:    meta_data[j++] = hpred[1];",
          "4322:  }",
          "4327:    else",
          "4328:     fprintf (stderr,_(\"%s has unknown CAMF type %d.\\n\"), ifname, type);",
          "4332: const char * CLASS foveon_camf_param (const char *block, const char *param)",
          "4337:   for (idx=0; idx < meta_length; idx += sget4(pos+8)) {",
          "4339:     if (strncmp (pos, \"CMb\", 3)) break;",
          "4340:     if (pos[3] != 'P') continue;",
          "4341:     if (strcmp (block, pos+sget4(pos+12))) continue;",
          "4342:     cp = pos + sget4(pos+16);",
          "4344:     dp = pos + sget4(cp+4);",
          "4345:     while (num--) {",
          "4347:       if (!strcmp (param, dp+sget4(cp)))",
          "4348:  return dp+sget4(cp+4);",
          "4354: void * CLASS foveon_camf_matrix (unsigned dim[3], const char *name)",
          "4360:   for (idx=0; idx < meta_length; idx += sget4(pos+8)) {",
          "4362:     if (strncmp (pos, \"CMb\", 3)) break;",
          "4363:     if (pos[3] != 'M') continue;",
          "4364:     if (strcmp (name, pos+sget4(pos+12))) continue;",
          "4366:     cp = pos + sget4(pos+16);",
          "4368:     if ((ndim = sget4(cp+4)) > 3) break;",
          "4369:     dp = pos + sget4(cp+8);",
          "4370:     for (i=ndim; i--; ) {",
          "4374:     if ((dsize = (double) dim[0]*dim[1]*dim[2]) > meta_length/4) break;",
          "4375:     mat = (unsigned *) malloc ((size = dsize) * 4);",
          "4376:     merror (mat, \"foveon_camf_matrix()\");",
          "4377:     for (i=0; i < size; i++)",
          "4379:  mat[i] = sget4(dp + i*4);",
          "4381:  mat[i] = sget4(dp + i*2) & 0xffff;",
          "4385:   fprintf (stderr,_(\"%s: \\\"%s\\\" matrix not found!\\n\"), ifname, name);",
          "4390: int CLASS foveon_fixed (void *ptr, int size, const char *name)",
          "4395:   if (!name) return 0;",
          "4396:   dp = foveon_camf_matrix (dim, name);",
          "4397:   if (!dp) return 0;",
          "4398:   memcpy (ptr, dp, size*4);",
          "4399:   free (dp);",
          "4403: float CLASS foveon_avg (short *pix, int range[2], float cfilt)",
          "4406:   float val, min=FLT_MAX, max=-FLT_MAX, sum=0;",
          "4408:   for (i=range[0]; i <= range[1]; i++) {",
          "4409:     sum += val = pix[i*4] + (pix[i*4]-pix[(i-1)*4]) * cfilt;",
          "4410:     if (min > val) min = val;",
          "4411:     if (max < val) max = val;",
          "4412:   }",
          "4413:   if (range[1] - range[0] == 1) return sum/2;",
          "4417: short * CLASS foveon_make_curve (double max, double mul, double filt)",
          "4423:   if (!filt) filt = 0.8;",
          "4424:   size = 4*M_PI*max / filt;",
          "4425:   if (size == UINT_MAX) size--;",
          "4426:   curve = (short *) calloc (size+1, sizeof *curve);",
          "4427:   merror (curve, \"foveon_make_curve()\");",
          "4429:   for (i=0; i < size; i++) {",
          "4430:     x = i*filt/max/4;",
          "4431:     curve[i+1] = (cos(x)+1)/2 * tanh(i*filt/mul) * mul + 0.5;",
          "4436: void CLASS foveon_make_curves",
          "4437:  (short **curvep, float dq[3], float div[3], float filt)",
          "4439:   double mul[3], max=0;",
          "4442:   FORC3 mul[c] = dq[c]/div[c];",
          "4444:   FORC3 curvep[c] = foveon_make_curve (max, mul[c], filt);",
          "4447: int CLASS foveon_apply_curve (short *curve, int i)",
          "4449:   if (abs(i) >= curve[0]) return 0;",
          "4450:   return i < 0 ? -curve[1-i] : curve[1+i];",
          "4453: #define image ((short (*)[4]) image)",
          "4457:   static const short hood[] = { -1,-1, -1,0, -1,1, 0,-1, 0,1, 1,-1, 1,0, 1,1 };",
          "4459:   float cfilt=0, ddft[3][3][2], ppm[3][3][3];",
          "4462:   float (*black)[3], (*sgain)[3], (*sgrow)[3];",
          "4466:   int work[3][3], smlast, smred, smred_p=0, dev[3];",
          "4469:   double dsum=0, trsum[3];",
          "4471:   const char* cp;",
          "4475:     fprintf (stderr,_(\"Foveon interpolation...\\n\"));",
          "4479:   foveon_fixed (dscr, 4, \"DarkShieldColRange\");",
          "4480:   foveon_fixed (ppm[0][0], 27, \"PostPolyMatrix\");",
          "4481:   foveon_fixed (satlev, 3, \"SaturationLevel\");",
          "4482:   foveon_fixed (keep, 4, \"KeepImageArea\");",
          "4483:   foveon_fixed (active, 4, \"ActiveImageArea\");",
          "4484:   foveon_fixed (chroma_dq, 3, \"ChromaDQ\");",
          "4485:   foveon_fixed (color_dq, 3,",
          "4486:  foveon_camf_param (\"IncludeBlocks\", \"ColorDQ\") ?",
          "4487:   \"ColorDQ\" : \"ColorDQCamRGB\");",
          "4488:   if (foveon_camf_param (\"IncludeBlocks\", \"ColumnFilter\"))",
          "4489:    foveon_fixed (&cfilt, 1, \"ColumnFilter\");",
          "4491:   memset (ddft, 0, sizeof ddft);",
          "4492:   if (!foveon_camf_param (\"IncludeBlocks\", \"DarkDrift\")",
          "4493:   || !foveon_fixed (ddft[1][0], 12, \"DarkDrift\"))",
          "4494:     for (i=0; i < 2; i++) {",
          "4495:       foveon_fixed (dstb, 4, i ? \"DarkShieldBottom\":\"DarkShieldTop\");",
          "4497:  for (col = dstb[0]; col <= dstb[2]; col++)",
          "4498:    FORC3 ddft[i+1][c][1] += (short) image[row*width+col][c];",
          "4499:       FORC3 ddft[i+1][c][1] /= (dstb[3]-dstb[1]+1) * (dstb[2]-dstb[0]+1);",
          "4502:   if (!(cp = foveon_camf_param (\"WhiteBalanceIlluminants\", model2)))",
          "4505:     fprintf (stderr,_(\"%s: Invalid white balance \\\"%s\\\"\\n\"), ifname, model2);",
          "4506: #endif",
          "4507:     return; }",
          "4508:   foveon_fixed (cam_xyz, 9, cp);",
          "4509:   foveon_fixed (correct, 9,",
          "4510:  foveon_camf_param (\"WhiteBalanceCorrections\", model2));",
          "4511:   memset (last, 0, sizeof last);",
          "4512:   for (i=0; i < 3; i++)",
          "4513:     for (j=0; j < 3; j++)",
          "4516:   #define LAST(x,y) last[(i+x)%3][(c+y)%3]",
          "4517:   for (i=0; i < 3; i++)",
          "4518:     FORC3 diag[c][i] = LAST(1,1)*LAST(2,2) - LAST(1,2)*LAST(2,1);",
          "4519:   #undef LAST",
          "4520:   FORC3 div[c] = diag[c][0]*0.3127 + diag[c][1]*0.329 + diag[c][2]*0.3583;",
          "4521:   sprintf (str, \"%sRGBNeutral\", model2);",
          "4522:   if (foveon_camf_param (\"IncludeBlocks\", str))",
          "4523:     foveon_fixed (div, 3, str);",
          "4528:   memset (trans, 0, sizeof trans);",
          "4529:   for (i=0; i < 3; i++)",
          "4530:     for (j=0; j < 3; j++)",
          "4533:   dsum = (6*trsum[0] + 11*trsum[1] + 3*trsum[2]) / 20;",
          "4534:   for (i=0; i < 3; i++)",
          "4536:   memset (trans, 0, sizeof trans);",
          "4537:   for (i=0; i < 3; i++)",
          "4538:     for (j=0; j < 3; j++)",
          "4539:       FORC3 trans[i][j] += (i==c ? 32 : -1) * last[c][j] / 30;",
          "4541:   foveon_make_curves (curve, color_dq, div, cfilt);",
          "4543:   foveon_make_curves (curve+3, chroma_dq, div, cfilt);",
          "4545:   curve[6] = foveon_make_curve (dsum, dsum, cfilt);",
          "4546:   curve[7] = foveon_make_curve (dsum*2, dsum*2, cfilt);",
          "4548:   sgain = (float (*)[3]) foveon_camf_matrix (dim, \"SpatialGain\");",
          "4549:   if (!sgain) return;",
          "4550:   sgrow = (float (*)[3]) calloc (dim[1], sizeof *sgrow);",
          "4551:   sgx = (width + dim[1]-2) / (dim[1]-1);",
          "4553:   black = (float (*)[3]) calloc (height, sizeof *black);",
          "4554:   for (row=0; row < height; row++) {",
          "4555:     for (i=0; i < 6; i++)",
          "4556:       ((float *)ddft[0])[i] = ((float *)ddft[1])[i] +",
          "4557:  row / (height-1.0) * (((float *)ddft[2])[i] - ((float *)ddft[1])[i]);",
          "4558:     FORC3 black[row][c] =",
          "4559:  ( foveon_avg (image[row*width]+c, dscr[0], cfilt) +",
          "4560:    foveon_avg (image[row*width]+c, dscr[1], cfilt) * 3",
          "4561:    - ddft[0][c][0] ) / 4 - ddft[0][c][1];",
          "4562:   }",
          "4563:   memcpy (black, black+8, sizeof *black*8);",
          "4564:   memcpy (black+height-11, black+height-22, 11*sizeof *black);",
          "4565:   memcpy (last, black, sizeof last);",
          "4567:   for (row=1; row < height-1; row++) {",
          "4568:     FORC3 if (last[1][c] > last[0][c]) {",
          "4569:  if (last[1][c] > last[2][c])",
          "4570:    black[row][c] = (last[0][c] > last[2][c]) ? last[0][c]:last[2][c];",
          "4571:       } else",
          "4572:  if (last[1][c] < last[2][c])",
          "4573:    black[row][c] = (last[0][c] < last[2][c]) ? last[0][c]:last[2][c];",
          "4574:     memmove (last, last+1, 2*sizeof last[0]);",
          "4575:     memcpy (last[2], black[row+1], sizeof last[2]);",
          "4576:   }",
          "4577:   FORC3 black[row][c] = (last[0][c] + last[1][c])/2;",
          "4578:   FORC3 black[0][c] = (black[1][c] + black[3][c])/2;",
          "4580:   val = 1 - exp(-1/24.0);",
          "4581:   memcpy (fsum, black, sizeof fsum);",
          "4582:   for (row=1; row < height; row++)",
          "4583:     FORC3 fsum[c] += black[row][c] =",
          "4584:  (black[row][c] - black[row-1][c])*val + black[row-1][c];",
          "4585:   memcpy (last[0], black[height-1], sizeof last[0]);",
          "4587:   for (row = height; row--; )",
          "4588:     FORC3 last[0][c] = black[row][c] =",
          "4589:  (black[row][c] - fsum[c] - last[0][c])*val + last[0][c];",
          "4591:   memset (total, 0, sizeof total);",
          "4592:   for (row=2; row < height; row+=4)",
          "4593:     for (col=2; col < width; col+=4) {",
          "4594:       FORC3 total[c] += (short) image[row*width+col][c];",
          "4597:   for (row=0; row < height; row++)",
          "4598:     FORC3 black[row][c] += fsum[c]/2 + total[c]/(total[3]*100.0);",
          "4600:   for (row=0; row < height; row++) {",
          "4601:     for (i=0; i < 6; i++)",
          "4602:       ((float *)ddft[0])[i] = ((float *)ddft[1])[i] +",
          "4603:  row / (height-1.0) * (((float *)ddft[2])[i] - ((float *)ddft[1])[i]);",
          "4604:     pix = image[row*width];",
          "4605:     memcpy (prev, pix, sizeof prev);",
          "4606:     frow = row / (height-1.0) * (dim[2]-1);",
          "4607:     if ((irow = frow) == dim[2]-1) irow--;",
          "4609:     for (i=0; i < dim[1]; i++)",
          "4610:       FORC3 sgrow[i][c] = sgain[ irow   *dim[1]+i][c] * (1-frow) +",
          "4611:      sgain[(irow+1)*dim[1]+i][c] *    frow;",
          "4612:     for (col=0; col < width; col++) {",
          "4613:       FORC3 {",
          "4614:  diff = pix[c] - prev[c];",
          "4615:  prev[c] = pix[c];",
          "4616:  ipix[c] = pix[c] + floor ((diff + (diff*diff >> 14)) * cfilt",
          "4617:   - ddft[0][c][1] - ddft[0][c][0] * ((float) col/width - 0.5)",
          "4618:   - black[row][c] );",
          "4619:       }",
          "4620:       FORC3 {",
          "4621:  work[0][c] = ipix[c] * ipix[c] >> 14;",
          "4622:  work[2][c] = ipix[c] * work[0][c] >> 14;",
          "4623:  work[1][2-c] = ipix[(c+1) % 3] * ipix[(c+2) % 3] >> 14;",
          "4624:       }",
          "4625:       FORC3 {",
          "4626:  for (val=i=0; i < 3; i++)",
          "4627:    for (  j=0; j < 3; j++)",
          "4628:      val += ppm[c][i][j] * work[i][j];",
          "4629:  ipix[c] = floor ((ipix[c] + floor(val)) *",
          "4630:   ( sgrow[col/sgx  ][c] * (sgx - col%sgx) +",
          "4631:     sgrow[col/sgx+1][c] * (col%sgx) ) / sgx / div[c]);",
          "4632:  if (ipix[c] > 32000) ipix[c] = 32000;",
          "4633:  pix[c] = ipix[c];",
          "4638:   free (black);",
          "4639:   free (sgrow);",
          "4640:   free (sgain);",
          "4642:   if ((badpix = (unsigned *) foveon_camf_matrix (dim, \"BadPixels\"))) {",
          "4643:     for (i=0; i < dim[0]; i++) {",
          "4645:       row = (badpix[i] >> 20       ) - keep[1];",
          "4646:       if ((unsigned)(row-1) > height-3 || (unsigned)(col-1) > width-3)",
          "4647:  continue;",
          "4648:       memset (fsum, 0, sizeof fsum);",
          "4649:       for (sum=j=0; j < 8; j++)",
          "4650:  if (badpix[i] & (1 << j)) {",
          "4651:    FORC3 fsum[c] += (short)",
          "4652:   image[(row+hood[j*2])*width+col+hood[j*2+1]][c];",
          "4653:    sum++;",
          "4654:  }",
          "4655:       if (sum) FORC3 image[row*width+col][c] = fsum[c]/sum;",
          "4657:     free (badpix);",
          "4661:   smrow[6] = (int (*)[3]) calloc (width*5, sizeof **smrow);",
          "4662:   merror (smrow[6], \"foveon_interpolate()\");",
          "4663:   for (i=0; i < 5; i++)",
          "4664:     smrow[i] = smrow[6] + i*width;",
          "4667:   for (smlast=-1, row=2; row < height-2; row++) {",
          "4668:     while (smlast < row+2) {",
          "4669:       for (i=0; i < 6; i++)",
          "4670:  smrow[(i+5) % 6] = smrow[i];",
          "4671:       pix = image[++smlast*width+2];",
          "4672:       for (col=2; col < width-2; col++) {",
          "4673:  smrow[4][col][0] =",
          "4674:    (pix[0]*6 + (pix[-4]+pix[4])*4 + pix[-8]+pix[8] + 8) >> 4;",
          "4675:  pix += 4;",
          "4676:       }",
          "4677:     }",
          "4678:     pix = image[row*width+2];",
          "4679:     for (col=2; col < width-2; col++) {",
          "4680:       smred = ( 6 *  smrow[2][col][0]",
          "4681:        + 4 * (smrow[1][col][0] + smrow[3][col][0])",
          "4682:        +      smrow[0][col][0] + smrow[4][col][0] + 8 ) >> 4;",
          "4684:  smred_p = smred;",
          "4685:       i = pix[0] + ((pix[0] - ((smred*7 + smred_p) >> 3)) >> 3);",
          "4686:       if (i > 32000) i = 32000;",
          "",
          "[Added Lines]",
          "4801:   fseek(ifp, 8, SEEK_CUR);",
          "4802:   foveon_huff(huff);",
          "4804:   FORC3 roff[c + 1] = -(-(roff[c] + get4()) & -16);",
          "4805:   FORC3",
          "4806:   {",
          "4807:     fseek(ifp, data_offset + roff[c], SEEK_SET);",
          "4810:     for (row = 0; row < height; row++)",
          "4811:     {",
          "4813:       checkCancel();",
          "4815:       for (col = 0; col < width; col++)",
          "4816:       {",
          "4817:         diff = ljpeg_diff(huff);",
          "4818:         if (col < 2)",
          "4819:           hpred[col] = vpred[row & 1][col] += diff;",
          "4820:         else",
          "4821:           hpred[col & 1] += diff;",
          "4822:         image[row * width + col][c] = hpred[col & 1];",
          "4831:   ushort huff[258], vpred[2][2] = {{512, 512}, {512, 512}}, hpred[2];",
          "4833:   fseek(ifp, meta_offset, SEEK_SET);",
          "4834:   type = get4();",
          "4835:   get4();",
          "4836:   get4();",
          "4839:   if (type == 2)",
          "4840:   {",
          "4841:     fread(meta_data, 1, meta_length, ifp);",
          "4842:     for (i = 0; i < meta_length; i++)",
          "4843:     {",
          "4845:       wide = high * (INT64)301593171 >> 24;",
          "4848:   }",
          "4849:   else if (type == 4)",
          "4850:   {",
          "4851:     free(meta_data);",
          "4852:     meta_data = (char *)malloc(meta_length = wide * high * 3 / 2);",
          "4853:     merror(meta_data, \"foveon_load_camf()\");",
          "4854:     foveon_huff(huff);",
          "4857:     for (j = row = 0; row < high; row++)",
          "4858:     {",
          "4859:       for (col = 0; col < wide; col++)",
          "4860:       {",
          "4861:         diff = ljpeg_diff(huff);",
          "4862:         if (col < 2)",
          "4863:           hpred[col] = vpred[row & 1][col] += diff;",
          "4864:         else",
          "4865:           hpred[col & 1] += diff;",
          "4866:         if (col & 1)",
          "4867:         {",
          "4868:           meta_data[j++] = hpred[0] >> 4;",
          "4869:           meta_data[j++] = hpred[0] << 4 | hpred[1] >> 8;",
          "4870:           meta_data[j++] = hpred[1];",
          "4871:         }",
          "4876:   else",
          "4877:     fprintf(stderr, _(\"%s has unknown CAMF type %d.\\n\"), ifname, type);",
          "4881: const char *CLASS foveon_camf_param(const char *block, const char *param)",
          "4886:   for (idx = 0; idx < meta_length; idx += sget4(pos + 8))",
          "4887:   {",
          "4889:     if (strncmp(pos, \"CMb\", 3))",
          "4890:       break;",
          "4891:     if (pos[3] != 'P')",
          "4892:       continue;",
          "4893:     if (strcmp(block, pos + sget4(pos + 12)))",
          "4894:       continue;",
          "4895:     cp = pos + sget4(pos + 16);",
          "4897:     dp = pos + sget4(cp + 4);",
          "4898:     while (num--)",
          "4899:     {",
          "4901:       if (!strcmp(param, dp + sget4(cp)))",
          "4902:         return dp + sget4(cp + 4);",
          "4908: void *CLASS foveon_camf_matrix(unsigned dim[3], const char *name)",
          "4914:   for (idx = 0; idx < meta_length; idx += sget4(pos + 8))",
          "4915:   {",
          "4917:     if (strncmp(pos, \"CMb\", 3))",
          "4918:       break;",
          "4919:     if (pos[3] != 'M')",
          "4920:       continue;",
          "4921:     if (strcmp(name, pos + sget4(pos + 12)))",
          "4922:       continue;",
          "4924:     cp = pos + sget4(pos + 16);",
          "4926:     if ((ndim = sget4(cp + 4)) > 3)",
          "4927:       break;",
          "4928:     dp = pos + sget4(cp + 8);",
          "4929:     for (i = ndim; i--;)",
          "4930:     {",
          "4934:     if ((dsize = (double)dim[0] * dim[1] * dim[2]) > meta_length / 4)",
          "4935:       break;",
          "4936:     mat = (unsigned *)malloc((size = dsize) * 4);",
          "4937:     merror(mat, \"foveon_camf_matrix()\");",
          "4938:     for (i = 0; i < size; i++)",
          "4940:         mat[i] = sget4(dp + i * 4);",
          "4942:         mat[i] = sget4(dp + i * 2) & 0xffff;",
          "4946:   fprintf(stderr, _(\"%s: \\\"%s\\\" matrix not found!\\n\"), ifname, name);",
          "4951: int CLASS foveon_fixed(void *ptr, int size, const char *name)",
          "4956:   if (!name)",
          "4957:     return 0;",
          "4958:   dp = foveon_camf_matrix(dim, name);",
          "4959:   if (!dp)",
          "4960:     return 0;",
          "4961:   memcpy(ptr, dp, size * 4);",
          "4962:   free(dp);",
          "4966: float CLASS foveon_avg(short *pix, int range[2], float cfilt)",
          "4969:   float val, min = FLT_MAX, max = -FLT_MAX, sum = 0;",
          "4971:   for (i = range[0]; i <= range[1]; i++)",
          "4972:   {",
          "4973:     sum += val = pix[i * 4] + (pix[i * 4] - pix[(i - 1) * 4]) * cfilt;",
          "4974:     if (min > val)",
          "4975:       min = val;",
          "4976:     if (max < val)",
          "4977:       max = val;",
          "4978:   }",
          "4979:   if (range[1] - range[0] == 1)",
          "4980:     return sum / 2;",
          "4984: short *CLASS foveon_make_curve(double max, double mul, double filt)",
          "4990:   if (!filt)",
          "4991:     filt = 0.8;",
          "4992:   size = 4 * M_PI * max / filt;",
          "4993:   if (size == UINT_MAX)",
          "4994:     size--;",
          "4995:   curve = (short *)calloc(size + 1, sizeof *curve);",
          "4996:   merror(curve, \"foveon_make_curve()\");",
          "4998:   for (i = 0; i < size; i++)",
          "4999:   {",
          "5000:     x = i * filt / max / 4;",
          "5001:     curve[i + 1] = (cos(x) + 1) / 2 * tanh(i * filt / mul) * mul + 0.5;",
          "5006: void CLASS foveon_make_curves(short **curvep, float dq[3], float div[3], float filt)",
          "5008:   double mul[3], max = 0;",
          "5011:   FORC3 mul[c] = dq[c] / div[c];",
          "5013:   FORC3 curvep[c] = foveon_make_curve(max, mul[c], filt);",
          "5016: int CLASS foveon_apply_curve(short *curve, int i)",
          "5018:   if (abs(i) >= curve[0])",
          "5019:     return 0;",
          "5020:   return i < 0 ? -curve[1 - i] : curve[1 + i];",
          "5023: #define image ((short(*)[4])image)",
          "5027:   static const short hood[] = {-1, -1, -1, 0, -1, 1, 0, -1, 0, 1, 1, -1, 1, 0, 1, 1};",
          "5029:   float cfilt = 0, ddft[3][3][2], ppm[3][3][3];",
          "5032:   float(*black)[3], (*sgain)[3], (*sgrow)[3];",
          "5036:   int work[3][3], smlast, smred, smred_p = 0, dev[3];",
          "5039:   double dsum = 0, trsum[3];",
          "5041:   const char *cp;",
          "5045:     fprintf(stderr, _(\"Foveon interpolation...\\n\"));",
          "5049:   foveon_fixed(dscr, 4, \"DarkShieldColRange\");",
          "5050:   foveon_fixed(ppm[0][0], 27, \"PostPolyMatrix\");",
          "5051:   foveon_fixed(satlev, 3, \"SaturationLevel\");",
          "5052:   foveon_fixed(keep, 4, \"KeepImageArea\");",
          "5053:   foveon_fixed(active, 4, \"ActiveImageArea\");",
          "5054:   foveon_fixed(chroma_dq, 3, \"ChromaDQ\");",
          "5055:   foveon_fixed(color_dq, 3, foveon_camf_param(\"IncludeBlocks\", \"ColorDQ\") ? \"ColorDQ\" : \"ColorDQCamRGB\");",
          "5056:   if (foveon_camf_param(\"IncludeBlocks\", \"ColumnFilter\"))",
          "5057:     foveon_fixed(&cfilt, 1, \"ColumnFilter\");",
          "5059:   memset(ddft, 0, sizeof ddft);",
          "5060:   if (!foveon_camf_param(\"IncludeBlocks\", \"DarkDrift\") || !foveon_fixed(ddft[1][0], 12, \"DarkDrift\"))",
          "5061:     for (i = 0; i < 2; i++)",
          "5062:     {",
          "5063:       foveon_fixed(dstb, 4, i ? \"DarkShieldBottom\" : \"DarkShieldTop\");",
          "5065:         for (col = dstb[0]; col <= dstb[2]; col++)",
          "5066:           FORC3 ddft[i + 1][c][1] += (short)image[row * width + col][c];",
          "5067:       FORC3 ddft[i + 1][c][1] /= (dstb[3] - dstb[1] + 1) * (dstb[2] - dstb[0] + 1);",
          "5070:   if (!(cp = foveon_camf_param(\"WhiteBalanceIlluminants\", model2)))",
          "5073:     fprintf(stderr, _(\"%s: Invalid white balance \\\"%s\\\"\\n\"), ifname, model2);",
          "5074: #endif",
          "5075:     return;",
          "5076:   }",
          "5077:   foveon_fixed(cam_xyz, 9, cp);",
          "5078:   foveon_fixed(correct, 9, foveon_camf_param(\"WhiteBalanceCorrections\", model2));",
          "5079:   memset(last, 0, sizeof last);",
          "5080:   for (i = 0; i < 3; i++)",
          "5081:     for (j = 0; j < 3; j++)",
          "5084: #define LAST(x, y) last[(i + x) % 3][(c + y) % 3]",
          "5085:   for (i = 0; i < 3; i++)",
          "5086:     FORC3 diag[c][i] = LAST(1, 1) * LAST(2, 2) - LAST(1, 2) * LAST(2, 1);",
          "5087: #undef LAST",
          "5088:   FORC3 div[c] = diag[c][0] * 0.3127 + diag[c][1] * 0.329 + diag[c][2] * 0.3583;",
          "5089:   sprintf(str, \"%sRGBNeutral\", model2);",
          "5090:   if (foveon_camf_param(\"IncludeBlocks\", str))",
          "5091:     foveon_fixed(div, 3, str);",
          "5096:   memset(trans, 0, sizeof trans);",
          "5097:   for (i = 0; i < 3; i++)",
          "5098:     for (j = 0; j < 3; j++)",
          "5101:   dsum = (6 * trsum[0] + 11 * trsum[1] + 3 * trsum[2]) / 20;",
          "5102:   for (i = 0; i < 3; i++)",
          "5104:   memset(trans, 0, sizeof trans);",
          "5105:   for (i = 0; i < 3; i++)",
          "5106:     for (j = 0; j < 3; j++)",
          "5107:       FORC3 trans[i][j] += (i == c ? 32 : -1) * last[c][j] / 30;",
          "5109:   foveon_make_curves(curve, color_dq, div, cfilt);",
          "5111:   foveon_make_curves(curve + 3, chroma_dq, div, cfilt);",
          "5113:   curve[6] = foveon_make_curve(dsum, dsum, cfilt);",
          "5114:   curve[7] = foveon_make_curve(dsum * 2, dsum * 2, cfilt);",
          "5116:   sgain = (float(*)[3])foveon_camf_matrix(dim, \"SpatialGain\");",
          "5117:   if (!sgain)",
          "5118:     return;",
          "5119:   sgrow = (float(*)[3])calloc(dim[1], sizeof *sgrow);",
          "5120:   sgx = (width + dim[1] - 2) / (dim[1] - 1);",
          "5122:   black = (float(*)[3])calloc(height, sizeof *black);",
          "5123:   for (row = 0; row < height; row++)",
          "5124:   {",
          "5125:     for (i = 0; i < 6; i++)",
          "5126:       ((float *)ddft[0])[i] =",
          "5127:           ((float *)ddft[1])[i] + row / (height - 1.0) * (((float *)ddft[2])[i] - ((float *)ddft[1])[i]);",
          "5128:     FORC3 black[row][c] = (foveon_avg(image[row * width] + c, dscr[0], cfilt) +",
          "5129:                            foveon_avg(image[row * width] + c, dscr[1], cfilt) * 3 - ddft[0][c][0]) /",
          "5130:                               4 -",
          "5131:                           ddft[0][c][1];",
          "5132:   }",
          "5133:   memcpy(black, black + 8, sizeof *black * 8);",
          "5134:   memcpy(black + height - 11, black + height - 22, 11 * sizeof *black);",
          "5135:   memcpy(last, black, sizeof last);",
          "5137:   for (row = 1; row < height - 1; row++)",
          "5138:   {",
          "5139:     FORC3 if (last[1][c] > last[0][c])",
          "5140:     {",
          "5141:       if (last[1][c] > last[2][c])",
          "5142:         black[row][c] = (last[0][c] > last[2][c]) ? last[0][c] : last[2][c];",
          "5143:     }",
          "5144:     else if (last[1][c] < last[2][c]) black[row][c] = (last[0][c] < last[2][c]) ? last[0][c] : last[2][c];",
          "5145:     memmove(last, last + 1, 2 * sizeof last[0]);",
          "5146:     memcpy(last[2], black[row + 1], sizeof last[2]);",
          "5147:   }",
          "5148:   FORC3 black[row][c] = (last[0][c] + last[1][c]) / 2;",
          "5149:   FORC3 black[0][c] = (black[1][c] + black[3][c]) / 2;",
          "5151:   val = 1 - exp(-1 / 24.0);",
          "5152:   memcpy(fsum, black, sizeof fsum);",
          "5153:   for (row = 1; row < height; row++)",
          "5154:     FORC3 fsum[c] += black[row][c] = (black[row][c] - black[row - 1][c]) * val + black[row - 1][c];",
          "5155:   memcpy(last[0], black[height - 1], sizeof last[0]);",
          "5157:   for (row = height; row--;)",
          "5158:     FORC3 last[0][c] = black[row][c] = (black[row][c] - fsum[c] - last[0][c]) * val + last[0][c];",
          "5160:   memset(total, 0, sizeof total);",
          "5161:   for (row = 2; row < height; row += 4)",
          "5162:     for (col = 2; col < width; col += 4)",
          "5163:     {",
          "5164:       FORC3 total[c] += (short)image[row * width + col][c];",
          "5167:   for (row = 0; row < height; row++)",
          "5168:     FORC3 black[row][c] += fsum[c] / 2 + total[c] / (total[3] * 100.0);",
          "5170:   for (row = 0; row < height; row++)",
          "5171:   {",
          "5172:     for (i = 0; i < 6; i++)",
          "5173:       ((float *)ddft[0])[i] =",
          "5174:           ((float *)ddft[1])[i] + row / (height - 1.0) * (((float *)ddft[2])[i] - ((float *)ddft[1])[i]);",
          "5175:     pix = image[row * width];",
          "5176:     memcpy(prev, pix, sizeof prev);",
          "5177:     frow = row / (height - 1.0) * (dim[2] - 1);",
          "5178:     if ((irow = frow) == dim[2] - 1)",
          "5179:       irow--;",
          "5181:     for (i = 0; i < dim[1]; i++)",
          "5182:       FORC3 sgrow[i][c] = sgain[irow * dim[1] + i][c] * (1 - frow) + sgain[(irow + 1) * dim[1] + i][c] * frow;",
          "5183:     for (col = 0; col < width; col++)",
          "5184:     {",
          "5185:       FORC3",
          "5186:       {",
          "5187:         diff = pix[c] - prev[c];",
          "5188:         prev[c] = pix[c];",
          "5189:         ipix[c] = pix[c] + floor((diff + (diff * diff >> 14)) * cfilt - ddft[0][c][1] -",
          "5190:                                  ddft[0][c][0] * ((float)col / width - 0.5) - black[row][c]);",
          "5191:       }",
          "5192:       FORC3",
          "5193:       {",
          "5194:         work[0][c] = ipix[c] * ipix[c] >> 14;",
          "5195:         work[2][c] = ipix[c] * work[0][c] >> 14;",
          "5196:         work[1][2 - c] = ipix[(c + 1) % 3] * ipix[(c + 2) % 3] >> 14;",
          "5197:       }",
          "5198:       FORC3",
          "5199:       {",
          "5200:         for (val = i = 0; i < 3; i++)",
          "5201:           for (j = 0; j < 3; j++)",
          "5202:             val += ppm[c][i][j] * work[i][j];",
          "5203:         ipix[c] =",
          "5204:             floor((ipix[c] + floor(val)) *",
          "5205:                   (sgrow[col / sgx][c] * (sgx - col % sgx) + sgrow[col / sgx + 1][c] * (col % sgx)) / sgx / div[c]);",
          "5206:         if (ipix[c] > 32000)",
          "5207:           ipix[c] = 32000;",
          "5208:         pix[c] = ipix[c];",
          "5213:   free(black);",
          "5214:   free(sgrow);",
          "5215:   free(sgain);",
          "5217:   if ((badpix = (unsigned *)foveon_camf_matrix(dim, \"BadPixels\")))",
          "5218:   {",
          "5219:     for (i = 0; i < dim[0]; i++)",
          "5220:     {",
          "5222:       row = (badpix[i] >> 20) - keep[1];",
          "5223:       if ((unsigned)(row - 1) > height - 3 || (unsigned)(col - 1) > width - 3)",
          "5224:         continue;",
          "5225:       memset(fsum, 0, sizeof fsum);",
          "5226:       for (sum = j = 0; j < 8; j++)",
          "5227:         if (badpix[i] & (1 << j))",
          "5228:         {",
          "5229:           FORC3 fsum[c] += (short)image[(row + hood[j * 2]) * width + col + hood[j * 2 + 1]][c];",
          "5230:           sum++;",
          "5231:         }",
          "5232:       if (sum)",
          "5233:         FORC3 image[row * width + col][c] = fsum[c] / sum;",
          "5235:     free(badpix);",
          "5239:   smrow[6] = (int(*)[3])calloc(width * 5, sizeof **smrow);",
          "5240:   merror(smrow[6], \"foveon_interpolate()\");",
          "5241:   for (i = 0; i < 5; i++)",
          "5242:     smrow[i] = smrow[6] + i * width;",
          "5245:   for (smlast = -1, row = 2; row < height - 2; row++)",
          "5246:   {",
          "5247:     while (smlast < row + 2)",
          "5248:     {",
          "5249:       for (i = 0; i < 6; i++)",
          "5250:         smrow[(i + 5) % 6] = smrow[i];",
          "5251:       pix = image[++smlast * width + 2];",
          "5252:       for (col = 2; col < width - 2; col++)",
          "5253:       {",
          "5254:         smrow[4][col][0] = (pix[0] * 6 + (pix[-4] + pix[4]) * 4 + pix[-8] + pix[8] + 8) >> 4;",
          "5255:         pix += 4;",
          "5256:       }",
          "5257:     }",
          "5258:     pix = image[row * width + 2];",
          "5259:     for (col = 2; col < width - 2; col++)",
          "5260:     {",
          "5261:       smred = (6 * smrow[2][col][0] + 4 * (smrow[1][col][0] + smrow[3][col][0]) + smrow[0][col][0] + smrow[4][col][0] +",
          "5262:                8) >>",
          "5263:               4;",
          "5265:         smred_p = smred;",
          "5266:       i = pix[0] + ((pix[0] - ((smred * 7 + smred_p) >> 3)) >> 3);",
          "5267:       if (i > 32000)",
          "5268:         i = 32000;",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "4694:   min = 0xffff;",
          "4696:     i = satlev[c] / div[c];",
          "4698:   }",
          "4699:   limit = min * 9 >> 4;",
          "4701:     if (pix[0] <= limit || pix[1] <= limit || pix[2] <= limit)",
          "4702:       continue;",
          "4703:     min = max = pix[0];",
          "4707:     }",
          "4709:       pix[0] = pix[1] = pix[2] = max;",
          "4711:       i = 0x4000 - ((min - limit) << 14) / limit;",
          "4714:       FORC3 pix[c] += (max - pix[c]) * i >> 14;",
          "4715:     }",
          "4716:   }",
          "4736:       sum = (dev[0] + dev[1] + dev[2]) >> 3;",
          "4737:       FORC3 pix[c] += dev[c] - sum;",
          "4738:       pix += 4;",
          "4739:     }",
          "4740:   }",
          "4750:       }",
          "4751:     }",
          "4759:       }",
          "4761:       j = total[3] > 375 ? (sum << 16) / total[3] : sum * 174;",
          "4764:       pix += 4;",
          "4765:     }",
          "4766:   }",
          "4778:       ipix[c] = dsum + 0.5;",
          "4779:     }",
          "4780:     FORC3 pix[c] = ipix[c];",
          "4781:   }",
          "4788:       ipix[0] = ipix[1] = ipix[2] = 0;",
          "4792:       FORC3",
          "4798:     }",
          "4801:     ipix[0] = ipix[1] = ipix[2] = 0;",
          "4802:     if ((row & 3) == 0)",
          "4808:     ipix[0] = ipix[1] = ipix[2] = 0;",
          "4814:     if (row == 0)",
          "4816:     else",
          "4826:       }",
          "4827:       j = (j << 16) / i;",
          "4832:       }",
          "4833:       sum >>= 3;",
          "4838:       }",
          "4839:     }",
          "4840:   }",
          "4847:   active[1] -= keep[1];",
          "4848:   active[3] -= 2;",
          "4849:   i = active[2] - active[0];",
          "4853:   width = i;",
          "4854:   height = row;",
          "4855: }",
          "",
          "[Removed Lines]",
          "4695:   FORC3 {",
          "4697:     if (min > i) min = i;",
          "4700:   for (pix=image[0]; pix < image[height*width]; pix+=4) {",
          "4704:     for (c=1; c < 3; c++) {",
          "4705:       if (min > pix[c]) min = pix[c];",
          "4706:       if (max < pix[c]) max = pix[c];",
          "4708:     if (min >= limit*2) {",
          "4710:     } else {",
          "4712:       i = 0x4000 - (i*i >> 14);",
          "4713:       i = i*i >> 14;",
          "4718:    Because photons that miss one detector often hit another,",
          "4719:    the sum R+G+B is much less noisy than the individual colors.",
          "4720:    So smooth the hues without smoothing the total.",
          "4722:   for (smlast=-1, row=2; row < height-2; row++) {",
          "4723:     while (smlast < row+2) {",
          "4724:       for (i=0; i < 6; i++)",
          "4725:  smrow[(i+5) % 6] = smrow[i];",
          "4726:       pix = image[++smlast*width+2];",
          "4727:       for (col=2; col < width-2; col++) {",
          "4728:  FORC3 smrow[4][col][c] = (pix[c-4]+2*pix[c]+pix[c+4]+2) >> 2;",
          "4729:  pix += 4;",
          "4730:       }",
          "4731:     }",
          "4732:     pix = image[row*width+2];",
          "4733:     for (col=2; col < width-2; col++) {",
          "4734:       FORC3 dev[c] = -foveon_apply_curve (curve[7], pix[c] -",
          "4735:  ((smrow[1][col][c] + 2*smrow[2][col][c] + smrow[3][col][c]) >> 2));",
          "4741:   for (smlast=-1, row=2; row < height-2; row++) {",
          "4742:     while (smlast < row+2) {",
          "4743:       for (i=0; i < 6; i++)",
          "4744:  smrow[(i+5) % 6] = smrow[i];",
          "4745:       pix = image[++smlast*width+2];",
          "4746:       for (col=2; col < width-2; col++) {",
          "4747:  FORC3 smrow[4][col][c] =",
          "4748:   (pix[c-8]+pix[c-4]+pix[c]+pix[c+4]+pix[c+8]+2) >> 2;",
          "4749:  pix += 4;",
          "4752:     pix = image[row*width+2];",
          "4753:     for (col=2; col < width-2; col++) {",
          "4754:       for (total[3]=375, sum=60, c=0; c < 3; c++) {",
          "4755:  for (total[c]=i=0; i < 5; i++)",
          "4756:    total[c] += smrow[i][col][c];",
          "4757:  total[3] += total[c];",
          "4758:  sum += pix[c];",
          "4760:       if (sum < 0) sum = 0;",
          "4762:       FORC3 pix[c] += foveon_apply_curve (curve[6],",
          "4763:   ((j*total[c] + 0x8000) >> 16) - pix[c]);",
          "4769:   for (pix=image[0]; pix < image[height*width]; pix+=4) {",
          "4770:     FORC3 pix[c] -= foveon_apply_curve (curve[c], pix[c]);",
          "4771:     sum = (pix[0]+pix[1]+pix[1]+pix[2]) >> 2;",
          "4772:     FORC3 pix[c] -= foveon_apply_curve (curve[c], pix[c]-sum);",
          "4773:     FORC3 {",
          "4774:       for (dsum=i=0; i < 3; i++)",
          "4775:  dsum += trans[c][i] * pix[i];",
          "4776:       if (dsum < 0)  dsum = 0;",
          "4777:       if (dsum > 24000) dsum = 24000;",
          "4784:   shrink = (short (*)[3]) calloc ((height/4), (width/4)*sizeof *shrink);",
          "4785:   merror (shrink, \"foveon_interpolate()\");",
          "4786:   for (row = height/4; row--; )",
          "4787:     for (col=0; col < width/4; col++) {",
          "4789:       for (i=0; i < 4; i++)",
          "4790:  for (j=0; j < 4; j++)",
          "4791:    FORC3 ipix[c] += image[(row*4+i)*width+col*4+j][c];",
          "4793:  if (row+2 > height/4)",
          "4794:    shrink[row*(width/4)+col][c] = ipix[c] >> 4;",
          "4795:  else",
          "4796:    shrink[row*(width/4)+col][c] =",
          "4797:      (shrink[(row+1)*(width/4)+col][c]*1840 + ipix[c]*141 + 2048) >> 12;",
          "4800:   for (row=0; row < (height & ~3); row++) {",
          "4803:       for (col = width & ~3 ; col--; )",
          "4804:  FORC3 smrow[0][col][c] = ipix[c] =",
          "4805:    (shrink[(row/4)*(width/4)+col/4][c]*1485 + ipix[c]*6707 + 4096) >> 13;",
          "4809:     for (col=0; col < (width & ~3); col++)",
          "4810:       FORC3 smrow[1][col][c] = ipix[c] =",
          "4811:  (smrow[0][col][c]*1485 + ipix[c]*6707 + 4096) >> 13;",
          "4815:       memcpy (smrow[2], smrow[1], sizeof **smrow * width);",
          "4817:       for (col=0; col < (width & ~3); col++)",
          "4818:  FORC3 smrow[2][col][c] =",
          "4819:    (smrow[2][col][c]*6707 + smrow[1][col][c]*1485 + 4096) >> 13;",
          "4822:     for (col=0; col < (width & ~3); col++) {",
          "4823:       for (i=j=30, c=0; c < 3; c++) {",
          "4824:  i += smrow[2][col][c];",
          "4825:  j += image[row*width+col][c];",
          "4828:       for (sum=c=0; c < 3; c++) {",
          "4829:  ipix[c] = foveon_apply_curve (curve[c+3],",
          "4830:    ((smrow[2][col][c] * j + 0x8000) >> 16) - image[row*width+col][c]);",
          "4831:  sum += ipix[c];",
          "4834:       FORC3 {",
          "4835:  i = image[row*width+col][c] + ipix[c] - sum;",
          "4836:  if (i < 0) i = 0;",
          "4837:  image[row*width+col][c] = i;",
          "4841:   free (shrink);",
          "4842:   free (smrow[6]);",
          "4843:   for (i=0; i < 8; i++)",
          "4844:     free (curve[i]);",
          "4850:   for (row=0; row < active[3]-active[1]; row++)",
          "4851:     memcpy (image[row*i], image[(row+active[1])*width+active[0]],",
          "4852:   i * sizeof *image);",
          "",
          "[Added Lines]",
          "5277:   FORC3",
          "5278:   {",
          "5280:     if (min > i)",
          "5281:       min = i;",
          "5284:   for (pix = image[0]; pix < image[height * width]; pix += 4)",
          "5285:   {",
          "5289:     for (c = 1; c < 3; c++)",
          "5290:     {",
          "5291:       if (min > pix[c])",
          "5292:         min = pix[c];",
          "5293:       if (max < pix[c])",
          "5294:         max = pix[c];",
          "5296:     if (min >= limit * 2)",
          "5297:     {",
          "5299:     }",
          "5300:     else",
          "5301:     {",
          "5303:       i = 0x4000 - (i * i >> 14);",
          "5304:       i = i * i >> 14;",
          "5309:      Because photons that miss one detector often hit another,",
          "5310:      the sum R+G+B is much less noisy than the individual colors.",
          "5311:      So smooth the hues without smoothing the total.",
          "5313:   for (smlast = -1, row = 2; row < height - 2; row++)",
          "5314:   {",
          "5315:     while (smlast < row + 2)",
          "5316:     {",
          "5317:       for (i = 0; i < 6; i++)",
          "5318:         smrow[(i + 5) % 6] = smrow[i];",
          "5319:       pix = image[++smlast * width + 2];",
          "5320:       for (col = 2; col < width - 2; col++)",
          "5321:       {",
          "5322:         FORC3 smrow[4][col][c] = (pix[c - 4] + 2 * pix[c] + pix[c + 4] + 2) >> 2;",
          "5323:         pix += 4;",
          "5324:       }",
          "5325:     }",
          "5326:     pix = image[row * width + 2];",
          "5327:     for (col = 2; col < width - 2; col++)",
          "5328:     {",
          "5329:       FORC3 dev[c] =",
          "5330:           -foveon_apply_curve(curve[7], pix[c] - ((smrow[1][col][c] + 2 * smrow[2][col][c] + smrow[3][col][c]) >> 2));",
          "5336:   for (smlast = -1, row = 2; row < height - 2; row++)",
          "5337:   {",
          "5338:     while (smlast < row + 2)",
          "5339:     {",
          "5340:       for (i = 0; i < 6; i++)",
          "5341:         smrow[(i + 5) % 6] = smrow[i];",
          "5342:       pix = image[++smlast * width + 2];",
          "5343:       for (col = 2; col < width - 2; col++)",
          "5344:       {",
          "5345:         FORC3 smrow[4][col][c] = (pix[c - 8] + pix[c - 4] + pix[c] + pix[c + 4] + pix[c + 8] + 2) >> 2;",
          "5346:         pix += 4;",
          "5349:     pix = image[row * width + 2];",
          "5350:     for (col = 2; col < width - 2; col++)",
          "5351:     {",
          "5352:       for (total[3] = 375, sum = 60, c = 0; c < 3; c++)",
          "5353:       {",
          "5354:         for (total[c] = i = 0; i < 5; i++)",
          "5355:           total[c] += smrow[i][col][c];",
          "5356:         total[3] += total[c];",
          "5357:         sum += pix[c];",
          "5359:       if (sum < 0)",
          "5360:         sum = 0;",
          "5362:       FORC3 pix[c] += foveon_apply_curve(curve[6], ((j * total[c] + 0x8000) >> 16) - pix[c]);",
          "5368:   for (pix = image[0]; pix < image[height * width]; pix += 4)",
          "5369:   {",
          "5370:     FORC3 pix[c] -= foveon_apply_curve(curve[c], pix[c]);",
          "5371:     sum = (pix[0] + pix[1] + pix[1] + pix[2]) >> 2;",
          "5372:     FORC3 pix[c] -= foveon_apply_curve(curve[c], pix[c] - sum);",
          "5373:     FORC3",
          "5374:     {",
          "5375:       for (dsum = i = 0; i < 3; i++)",
          "5376:         dsum += trans[c][i] * pix[i];",
          "5377:       if (dsum < 0)",
          "5378:         dsum = 0;",
          "5379:       if (dsum > 24000)",
          "5380:         dsum = 24000;",
          "5387:   shrink = (short(*)[3])calloc((height / 4), (width / 4) * sizeof *shrink);",
          "5388:   merror(shrink, \"foveon_interpolate()\");",
          "5389:   for (row = height / 4; row--;)",
          "5390:     for (col = 0; col < width / 4; col++)",
          "5391:     {",
          "5393:       for (i = 0; i < 4; i++)",
          "5394:         for (j = 0; j < 4; j++)",
          "5395:           FORC3 ipix[c] += image[(row * 4 + i) * width + col * 4 + j][c];",
          "5397:       if (row + 2 > height / 4)",
          "5398:         shrink[row * (width / 4) + col][c] = ipix[c] >> 4;",
          "5399:       else",
          "5400:         shrink[row * (width / 4) + col][c] =",
          "5401:             (shrink[(row + 1) * (width / 4) + col][c] * 1840 + ipix[c] * 141 + 2048) >> 12;",
          "5404:   for (row = 0; row < (height & ~3); row++)",
          "5405:   {",
          "5408:       for (col = width & ~3; col--;)",
          "5409:         FORC3 smrow[0][col][c] = ipix[c] =",
          "5410:             (shrink[(row / 4) * (width / 4) + col / 4][c] * 1485 + ipix[c] * 6707 + 4096) >> 13;",
          "5414:     for (col = 0; col < (width & ~3); col++)",
          "5415:       FORC3 smrow[1][col][c] = ipix[c] = (smrow[0][col][c] * 1485 + ipix[c] * 6707 + 4096) >> 13;",
          "5419:       memcpy(smrow[2], smrow[1], sizeof **smrow * width);",
          "5421:       for (col = 0; col < (width & ~3); col++)",
          "5422:         FORC3 smrow[2][col][c] = (smrow[2][col][c] * 6707 + smrow[1][col][c] * 1485 + 4096) >> 13;",
          "5425:     for (col = 0; col < (width & ~3); col++)",
          "5426:     {",
          "5427:       for (i = j = 30, c = 0; c < 3; c++)",
          "5428:       {",
          "5429:         i += smrow[2][col][c];",
          "5430:         j += image[row * width + col][c];",
          "5433:       for (sum = c = 0; c < 3; c++)",
          "5434:       {",
          "5435:         ipix[c] =",
          "5436:             foveon_apply_curve(curve[c + 3], ((smrow[2][col][c] * j + 0x8000) >> 16) - image[row * width + col][c]);",
          "5437:         sum += ipix[c];",
          "5440:       FORC3",
          "5441:       {",
          "5442:         i = image[row * width + col][c] + ipix[c] - sum;",
          "5443:         if (i < 0)",
          "5444:           i = 0;",
          "5445:         image[row * width + col][c] = i;",
          "5449:   free(shrink);",
          "5450:   free(smrow[6]);",
          "5451:   for (i = 0; i < 8; i++)",
          "5452:     free(curve[i]);",
          "5458:   for (row = 0; row < active[3] - active[1]; row++)",
          "5459:     memcpy(image[row * i], image[(row + active[1]) * width + active[0]], i * sizeof *image);",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "4863:   int row, col;",
          "4864:   unsigned",
          "4865: #ifndef LIBRAW_LIBRARY_BUILD",
          "4868: #else",
          "4870: #define mblack imgdata.color.black_stat",
          "4871: #endif",
          "4873: #ifndef LIBRAW_LIBRARY_BUILD",
          "4876:     phase_one_correct();",
          "4900:     mask[0][1] = mask[1][1] += 2;",
          "4901:     mask[0][3] -= 2;",
          "4902:     goto sides;",
          "4903:   }",
          "4910:     mask[0][0] = mask[1][0] = top_margin;",
          "4912:     mask[0][3] += left_margin;",
          "4914:     mask[1][3] += raw_width;",
          "4915:   }",
          "4917:     mask[0][2] = top_margin;",
          "4918:     mask[0][3] = width;",
          "4919:   }",
          "4920: #ifdef LIBRAW_LIBRARY_BUILD",
          "4922:     mask[0][2] = top_margin;",
          "4923:     mask[0][3] = width;",
          "4924:   }",
          "4925: #endif",
          "4926: mask_set:",
          "4939: #ifndef LIBRAW_LIBRARY_BUILD",
          "4940:     canon_600_correct();",
          "4941: #endif",
          "4944:     black = cblack[4] = cblack[5] = cblack[6] = 0;",
          "4945:   }",
          "4946: }",
          "",
          "[Removed Lines]",
          "4866:     r, raw_pitch = raw_width*2,",
          "4867:     c, m, mblack[8], zero, val;",
          "4869:     c, m, zero, val;",
          "4874:   if (load_raw == &CLASS phase_one_load_raw ||",
          "4875:       load_raw == &CLASS phase_one_load_raw_c)",
          "4877:   if (fuji_width) {",
          "4878:     for (row=0; row < raw_height-top_margin*2; row++) {",
          "4879:       for (col=0; col < fuji_width << !fuji_layout; col++) {",
          "4880:  if (fuji_layout) {",
          "4881:    r = fuji_width - 1 - col + (row >> 1);",
          "4882:    c = col + ((row+1) >> 1);",
          "4883:  } else {",
          "4884:    r = fuji_width - 1 + row - (col >> 1);",
          "4885:    c = row + ((col+1) >> 1);",
          "4886:  }",
          "4887:  if (r < height && c < width)",
          "4888:    BAYER(r,c) = RAW(row+top_margin,col+left_margin);",
          "4889:       }",
          "4890:     }",
          "4891:   } else {",
          "4892:     for (row=0; row < height; row++)",
          "4893:       for (col=0; col < width; col++)",
          "4894:  BAYER2(row,col) = RAW(row+top_margin,col+left_margin);",
          "4895:   }",
          "4896: #endif",
          "4897:   if (mask[0][3] > 0) goto mask_set;",
          "4898:   if (load_raw == &CLASS canon_load_raw ||",
          "4899:       load_raw == &CLASS lossless_jpeg_load_raw) {",
          "4904:   if (load_raw == &CLASS canon_600_load_raw ||",
          "4905:       load_raw == &CLASS sony_load_raw ||",
          "4906:      (load_raw == &CLASS eight_bit_load_raw && strncmp(model,\"DC2\",3)) ||",
          "4907:       load_raw == &CLASS kodak_262_load_raw ||",
          "4908:      (load_raw == &CLASS packed_load_raw && (load_flags & 32))) {",
          "4909: sides:",
          "4911:     mask[0][2] = mask[1][2] = top_margin+height;",
          "4913:     mask[1][1] += left_margin+width;",
          "4916:   if (load_raw == &CLASS nokia_load_raw) {",
          "4921:   if (load_raw == &CLASS broadcom_load_raw) {",
          "4927:   memset (mblack, 0, sizeof mblack);",
          "4928:   for (zero=m=0; m < 8; m++)",
          "4929:     for (row=MAX(mask[m][0],0); row < MIN(mask[m][2],raw_height); row++)",
          "4930:       for (col=MAX(mask[m][1],0); col < MIN(mask[m][3],raw_width); col++) {",
          "4931:  c = FC(row-top_margin,col-left_margin);",
          "4932:  mblack[c] += val = raw_image[(row)*raw_pitch/2+(col)];",
          "4933:  mblack[4+c]++;",
          "4934:  zero += !val;",
          "4935:       }",
          "4936:   if (load_raw == &CLASS canon_600_load_raw && width < raw_width) {",
          "4937:     black = (mblack[0]+mblack[1]+mblack[2]+mblack[3]) /",
          "4938:      (mblack[4]+mblack[5]+mblack[6]+mblack[7]) - 4;",
          "4942:   } else if (zero < mblack[4] && mblack[5] && mblack[6] && mblack[7]) {",
          "4943:     FORC4 cblack[c] = mblack[c] / mblack[4+c];",
          "",
          "[Added Lines]",
          "5473:       r,",
          "5474:       raw_pitch = raw_width * 2, c, m, mblack[8], zero, val;",
          "5476:       c,",
          "5477:       m, zero, val;",
          "5482:   if (load_raw == &CLASS phase_one_load_raw || load_raw == &CLASS phase_one_load_raw_c)",
          "5484:   if (fuji_width)",
          "5485:   {",
          "5486:     for (row = 0; row < raw_height - top_margin * 2; row++)",
          "5487:     {",
          "5488:       for (col = 0; col < fuji_width << !fuji_layout; col++)",
          "5489:       {",
          "5490:         if (fuji_layout)",
          "5491:         {",
          "5492:           r = fuji_width - 1 - col + (row >> 1);",
          "5493:           c = col + ((row + 1) >> 1);",
          "5494:         }",
          "5495:         else",
          "5496:         {",
          "5497:           r = fuji_width - 1 + row - (col >> 1);",
          "5498:           c = row + ((col + 1) >> 1);",
          "5499:         }",
          "5500:         if (r < height && c < width)",
          "5501:           BAYER(r, c) = RAW(row + top_margin, col + left_margin);",
          "5502:       }",
          "5503:     }",
          "5504:   }",
          "5505:   else",
          "5506:   {",
          "5507:     for (row = 0; row < height; row++)",
          "5508:       for (col = 0; col < width; col++)",
          "5509:         BAYER2(row, col) = RAW(row + top_margin, col + left_margin);",
          "5510:   }",
          "5511: #endif",
          "5512:   if (mask[0][3] > 0)",
          "5513:     goto mask_set;",
          "5514:   if (load_raw == &CLASS canon_load_raw || load_raw == &CLASS lossless_jpeg_load_raw)",
          "5515:   {",
          "5520:   if (load_raw == &CLASS canon_600_load_raw || load_raw == &CLASS sony_load_raw ||",
          "5521:       (load_raw == &CLASS eight_bit_load_raw && strncmp(model, \"DC2\", 3)) || load_raw == &CLASS kodak_262_load_raw ||",
          "5522:       (load_raw == &CLASS packed_load_raw && (load_flags & 32)))",
          "5523:   {",
          "5524:   sides:",
          "5526:     mask[0][2] = mask[1][2] = top_margin + height;",
          "5528:     mask[1][1] += left_margin + width;",
          "5531:   if (load_raw == &CLASS nokia_load_raw)",
          "5532:   {",
          "5537:   if (load_raw == &CLASS broadcom_load_raw)",
          "5538:   {",
          "5544:   memset(mblack, 0, sizeof mblack);",
          "5545:   for (zero = m = 0; m < 8; m++)",
          "5546:     for (row = MAX(mask[m][0], 0); row < MIN(mask[m][2], raw_height); row++)",
          "5547:       for (col = MAX(mask[m][1], 0); col < MIN(mask[m][3], raw_width); col++)",
          "5548:       {",
          "5549:         c = FC(row - top_margin, col - left_margin);",
          "5550:         mblack[c] += val = raw_image[(row)*raw_pitch / 2 + (col)];",
          "5551:         mblack[4 + c]++;",
          "5552:         zero += !val;",
          "5553:       }",
          "5554:   if (load_raw == &CLASS canon_600_load_raw && width < raw_width)",
          "5555:   {",
          "5556:     black = (mblack[0] + mblack[1] + mblack[2] + mblack[3]) / (mblack[4] + mblack[5] + mblack[6] + mblack[7]) - 4;",
          "5560:   }",
          "5561:   else if (zero < mblack[4] && mblack[5] && mblack[6] && mblack[7])",
          "5562:   {",
          "5563:     FORC4 cblack[c] = mblack[c] / mblack[4 + c];",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "4953:   unsigned row, col, tot, n, r, c;",
          "4955: #ifdef LIBRAW_LIBRARY_BUILD",
          "4957: #endif",
          "4969:       }",
          "4970: #ifdef LIBRAW_LIBRARY_BUILD",
          "4972: #endif",
          "4973: }",
          "",
          "[Removed Lines]",
          "4956:   RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,0,2);",
          "4959:   for (row=0; row < height; row++)",
          "4960:     for (col=0; col < width; col++)",
          "4961:       if (BAYER(row,col) == 0) {",
          "4962:  tot = n = 0;",
          "4963:  for (r = row-2; r <= row+2; r++)",
          "4964:    for (c = col-2; c <= col+2; c++)",
          "4965:      if (r < height && c < width &&",
          "4966:   FC(r,c) == FC(row,col) && BAYER(r,c))",
          "4967:        tot += (n++,BAYER(r,c));",
          "4968:  if (n) BAYER(row,col) = tot/n;",
          "4971:   RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,1,2);",
          "",
          "[Added Lines]",
          "5576:   RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES, 0, 2);",
          "5579:   for (row = 0; row < height; row++)",
          "5580:     for (col = 0; col < width; col++)",
          "5581:       if (BAYER(row, col) == 0)",
          "5582:       {",
          "5583:         tot = n = 0;",
          "5584:         for (r = row - 2; r <= row + 2; r++)",
          "5585:           for (c = col - 2; c <= col + 2; c++)",
          "5586:             if (r < height && c < width && FC(r, c) == FC(row, col) && BAYER(r, c))",
          "5587:               tot += (n++, BAYER(r, c));",
          "5588:         if (n)",
          "5589:           BAYER(row, col) = tot / n;",
          "5592:   RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES, 1, 2);",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "4983: #include \"internal/var_defines.h\"",
          "4989:    Seach from the current directory up to the root looking for",
          "4990:    a \".badpixels\" file, and fix those pixels now.",
          "4993: {",
          "4995: #ifndef LIBRAW_LIBRARY_BUILD",
          "4996:   char *fname, *cp, line[128];",
          "4998: #else",
          "4999:   char *cp, line[128];",
          "5000:   int time, row, col, r, c, rad, tot, n;",
          "",
          "[Removed Lines]",
          "4992: void CLASS bad_pixels (const char *cfname)",
          "4994:   FILE *fp=NULL;",
          "4997:   int len, time, row, col, r, c, rad, tot, n, fixed=0;",
          "",
          "[Added Lines]",
          "5612: void CLASS bad_pixels(const char *cfname)",
          "5614:   FILE *fp = NULL;",
          "5617:   int len, time, row, col, r, c, rad, tot, n, fixed = 0;",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "5003: #endif",
          "5004: #endif",
          "5007: #ifdef LIBRAW_LIBRARY_BUILD",
          "5009: #endif",
          "5010:   if (cfname)",
          "5020:     }",
          "5021: #if defined(WIN32) || defined(DJGPP)",
          "5022:     if (fname[1] == ':')",
          "5026: #endif",
          "5027:     cp = fname + strlen(fname);",
          "5034:     }",
          "5036:   }",
          "5038:   if (!fp)",
          "5040: #ifdef LIBRAW_LIBRARY_BUILD",
          "5060: #ifdef DCRAW_VERBOSE",
          "5062:       if (!fixed++)",
          "5065:     }",
          "5066: #endif",
          "5067:   }",
          "5068: #ifdef DCRAW_VERBOSE",
          "5070: #endif",
          "5072: #ifdef LIBRAW_LIBRARY_BUILD",
          "5074: #endif",
          "5075: }",
          "5078: {",
          "5079:   FILE *fp;",
          "5081:   ushort *pixel;",
          "5082: #ifdef LIBRAW_LIBRARY_BUILD",
          "5084: #endif",
          "5087: #ifdef DCRAW_VERBOSE",
          "5089: #endif",
          "5090: #ifdef LIBRAW_LIBRARY_BUILD",
          "5091:     imgdata.process_warnings |= LIBRAW_WARN_BAD_DARKFRAME_FILE;",
          "5092: #endif",
          "5093:     return;",
          "5094:   }",
          "5106:     }",
          "5107:   }",
          "5109: #ifdef DCRAW_VERBOSE",
          "5111: #endif",
          "5114: #ifdef DCRAW_VERBOSE",
          "5116: #endif",
          "5117: #ifdef LIBRAW_LIBRARY_BUILD",
          "5119: #endif",
          "5121:   }",
          "5128:   }",
          "5132:   black = 0;",
          "5133: #ifdef LIBRAW_LIBRARY_BUILD",
          "5135: #endif",
          "5136: }",
          "",
          "[Removed Lines]",
          "5006:   if (!filters) return;",
          "5008:   RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,0,2);",
          "5011:     fp = fopen (cfname, \"r\");",
          "5013:   else {",
          "5014:     for (len=32 ; ; len *= 2) {",
          "5015:       fname = (char *) malloc (len);",
          "5016:       if (!fname) return;",
          "5017:       if (getcwd (fname, len-16)) break;",
          "5018:       free (fname);",
          "5019:       if (errno != ERANGE) return;",
          "5023:       memmove (fname, fname+2, len-2);",
          "5024:     for (cp=fname; *cp; cp++)",
          "5025:       if (*cp == '\\\\') *cp = '/';",
          "5028:     if (cp[-1] == '/') cp--;",
          "5029:     while (*fname == '/') {",
          "5030:       strcpy (cp, \"/.badpixels\");",
          "5031:       if ((fp = fopen (fname, \"r\"))) break;",
          "5032:       if (cp == fname) break;",
          "5033:       while (*--cp != '/');",
          "5035:     free (fname);",
          "5039:       {",
          "5041:           imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;",
          "5042: #endif",
          "5043:           return;",
          "5044:       }",
          "5045:   while (fgets (line, 128, fp)) {",
          "5046:     cp = strchr (line, '#');",
          "5047:     if (cp) *cp = 0;",
          "5048:     if (sscanf (line, \"%d %d %d\", &col, &row, &time) != 3) continue;",
          "5049:     if ((unsigned) col >= width || (unsigned) row >= height) continue;",
          "5050:     if (time > timestamp) continue;",
          "5051:     for (tot=n=0, rad=1; rad < 3 && n==0; rad++)",
          "5052:       for (r = row-rad; r <= row+rad; r++)",
          "5053:  for (c = col-rad; c <= col+rad; c++)",
          "5054:    if ((unsigned) r < height && (unsigned) c < width &&",
          "5055:   (r != row || c != col) && fcol(r,c) == fcol(row,col)) {",
          "5056:      tot += BAYER2(r,c);",
          "5057:      n++;",
          "5058:    }",
          "5059:     BAYER2(row,col) = tot/n;",
          "5061:     if (verbose) {",
          "5063:  fprintf (stderr,_(\"Fixed dead pixels at:\"));",
          "5064:       fprintf (stderr, \" %d,%d\", col, row);",
          "5069:   if (fixed) fputc ('\\n', stderr);",
          "5071:   fclose (fp);",
          "5073:   RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,1,2);",
          "5077: void CLASS subtract (const char *fname)",
          "5080:   int dim[3]={0,0,0}, comment=0, number=0, error=0, nd=0, c, row, col;",
          "5083:   RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,0,2);",
          "5086:   if (!(fp = fopen (fname, \"rb\"))) {",
          "5088:     perror (fname);",
          "5095:   if (fgetc(fp) != 'P' || fgetc(fp) != '5') error = 1;",
          "5096:   while (!error && nd < 3 && (c = fgetc(fp)) != EOF) {",
          "5097:     if (c == '#')  comment = 1;",
          "5098:     if (c == '\\n') comment = 0;",
          "5099:     if (comment) continue;",
          "5100:     if (isdigit(c)) number = 1;",
          "5101:     if (number) {",
          "5102:       if (isdigit(c)) dim[nd] = dim[nd]*10 + c -'0';",
          "5103:       else if (isspace(c)) {",
          "5104:  number = 0;  nd++;",
          "5105:       } else error = 1;",
          "5108:   if (error || nd < 3) {",
          "5110:     fprintf (stderr,_(\"%s is not a valid PGM file!\\n\"), fname);",
          "5112:     fclose (fp);  return;",
          "5113:   } else if (dim[0] != width || dim[1] != height || dim[2] != 65535) {",
          "5115:       fprintf (stderr,_(\"%s has the wrong dimensions!\\n\"), fname);",
          "5118:       imgdata.process_warnings |= LIBRAW_WARN_BAD_DARKFRAME_DIM;",
          "5120:     fclose (fp);  return;",
          "5122:   pixel = (ushort *) calloc (width, sizeof *pixel);",
          "5123:   merror (pixel, \"subtract()\");",
          "5124:   for (row=0; row < height; row++) {",
          "5125:     fread (pixel, 2, width, fp);",
          "5126:     for (col=0; col < width; col++)",
          "5127:       BAYER(row,col) = MAX (BAYER(row,col) - ntohs(pixel[col]), 0);",
          "5129:   free (pixel);",
          "5130:   fclose (fp);",
          "5131:   memset (cblack, 0, sizeof cblack);",
          "5134:   RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,1,2);",
          "",
          "[Added Lines]",
          "5626:   if (!filters)",
          "5627:     return;",
          "5629:   RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS, 0, 2);",
          "5632:     fp = fopen(cfname, \"r\");",
          "5634:   else",
          "5635:   {",
          "5636:     for (len = 32;; len *= 2)",
          "5637:     {",
          "5638:       fname = (char *)malloc(len);",
          "5639:       if (!fname)",
          "5640:         return;",
          "5641:       if (getcwd(fname, len - 16))",
          "5642:         break;",
          "5643:       free(fname);",
          "5644:       if (errno != ERANGE)",
          "5645:         return;",
          "5649:       memmove(fname, fname + 2, len - 2);",
          "5650:     for (cp = fname; *cp; cp++)",
          "5651:       if (*cp == '\\\\')",
          "5655:     if (cp[-1] == '/')",
          "5656:       cp--;",
          "5657:     while (*fname == '/')",
          "5658:     {",
          "5659:       strcpy(cp, \"/.badpixels\");",
          "5660:       if ((fp = fopen(fname, \"r\")))",
          "5661:         break;",
          "5662:       if (cp == fname)",
          "5663:         break;",
          "5664:       while (*--cp != '/')",
          "5665:         ;",
          "5667:     free(fname);",
          "5671:   {",
          "5673:     imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;",
          "5674: #endif",
          "5675:     return;",
          "5676:   }",
          "5677:   while (fgets(line, 128, fp))",
          "5678:   {",
          "5679:     cp = strchr(line, '#');",
          "5680:     if (cp)",
          "5682:     if (sscanf(line, \"%d %d %d\", &col, &row, &time) != 3)",
          "5683:       continue;",
          "5684:     if ((unsigned)col >= width || (unsigned)row >= height)",
          "5685:       continue;",
          "5686:     if (time > timestamp)",
          "5687:       continue;",
          "5688:     for (tot = n = 0, rad = 1; rad < 3 && n == 0; rad++)",
          "5689:       for (r = row - rad; r <= row + rad; r++)",
          "5690:         for (c = col - rad; c <= col + rad; c++)",
          "5691:           if ((unsigned)r < height && (unsigned)c < width && (r != row || c != col) && fcol(r, c) == fcol(row, col))",
          "5692:           {",
          "5693:             tot += BAYER2(r, c);",
          "5694:             n++;",
          "5695:           }",
          "5696:     BAYER2(row, col) = tot / n;",
          "5698:     if (verbose)",
          "5699:     {",
          "5701:         fprintf(stderr, _(\"Fixed dead pixels at:\"));",
          "5702:       fprintf(stderr, \" %d,%d\", col, row);",
          "5707:   if (fixed)",
          "5708:     fputc('\\n', stderr);",
          "5710:   fclose(fp);",
          "5712:   RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS, 1, 2);",
          "5716: void CLASS subtract(const char *fname)",
          "5719:   int dim[3] = {0, 0, 0}, comment = 0, number = 0, error = 0, nd = 0, c, row, col;",
          "5722:   RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME, 0, 2);",
          "5725:   if (!(fp = fopen(fname, \"rb\")))",
          "5726:   {",
          "5728:     perror(fname);",
          "5735:   if (fgetc(fp) != 'P' || fgetc(fp) != '5')",
          "5736:     error = 1;",
          "5737:   while (!error && nd < 3 && (c = fgetc(fp)) != EOF)",
          "5738:   {",
          "5739:     if (c == '#')",
          "5740:       comment = 1;",
          "5741:     if (c == '\\n')",
          "5742:       comment = 0;",
          "5743:     if (comment)",
          "5744:       continue;",
          "5745:     if (isdigit(c))",
          "5746:       number = 1;",
          "5747:     if (number)",
          "5748:     {",
          "5749:       if (isdigit(c))",
          "5750:         dim[nd] = dim[nd] * 10 + c - '0';",
          "5751:       else if (isspace(c))",
          "5752:       {",
          "5753:         number = 0;",
          "5754:         nd++;",
          "5755:       }",
          "5756:       else",
          "5757:         error = 1;",
          "5760:   if (error || nd < 3)",
          "5761:   {",
          "5763:     fprintf(stderr, _(\"%s is not a valid PGM file!\\n\"), fname);",
          "5765:     fclose(fp);",
          "5766:     return;",
          "5767:   }",
          "5768:   else if (dim[0] != width || dim[1] != height || dim[2] != 65535)",
          "5769:   {",
          "5771:     fprintf(stderr, _(\"%s has the wrong dimensions!\\n\"), fname);",
          "5774:     imgdata.process_warnings |= LIBRAW_WARN_BAD_DARKFRAME_DIM;",
          "5776:     fclose(fp);",
          "5777:     return;",
          "5779:   pixel = (ushort *)calloc(width, sizeof *pixel);",
          "5780:   merror(pixel, \"subtract()\");",
          "5781:   for (row = 0; row < height; row++)",
          "5782:   {",
          "5783:     fread(pixel, 2, width, fp);",
          "5784:     for (col = 0; col < width; col++)",
          "5785:       BAYER(row, col) = MAX(BAYER(row, col) - ntohs(pixel[col]), 0);",
          "5787:   free(pixel);",
          "5788:   fclose(fp);",
          "5789:   memset(cblack, 0, sizeof cblack);",
          "5792:   RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME, 1, 2);",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "5141: static const uchar xlat[2][256] = {",
          "5176: {",
          "5177:   int i;",
          "5180:   g[0] = pwr;",
          "5181:   g[1] = ts;",
          "5182:   g[2] = g[3] = g[4] = 0;",
          "5183:   bnd[g[1] >= 1] = 1;",
          "5189:     }",
          "5190:     g[3] = g[2] / g[1];",
          "5199:     return;",
          "5200:   }",
          "5202:     curve[i] = 0xffff;",
          "5207:   }",
          "5208: }",
          "5211: {",
          "5212:   double work[3][6], num;",
          "5213:   int i, j, k;",
          "5221:   }",
          "5223:     num = work[i][i];",
          "5225:       work[i][j] /= num;",
          "5228:       num = work[k][i];",
          "5231:     }",
          "5232:   }",
          "5237: }",
          "5240: {",
          "5241:   double cam_rgb[4][3], inverse[4][3], num;",
          "5242:   int i, j, k;",
          "5251:       num += cam_rgb[i][j];",
          "5258:     else",
          "5264:   }",
          "5268:       _rgb_cam[i][j] = inverse[j][i];",
          "5269: }",
          "",
          "[Removed Lines]",
          "5142:   { 0xc1,0xbf,0x6d,0x0d,0x59,0xc5,0x13,0x9d,0x83,0x61,0x6b,0x4f,0xc7,0x7f,0x3d,0x3d,",
          "5143:     0x53,0x59,0xe3,0xc7,0xe9,0x2f,0x95,0xa7,0x95,0x1f,0xdf,0x7f,0x2b,0x29,0xc7,0x0d,",
          "5144:     0xdf,0x07,0xef,0x71,0x89,0x3d,0x13,0x3d,0x3b,0x13,0xfb,0x0d,0x89,0xc1,0x65,0x1f,",
          "5145:     0xb3,0x0d,0x6b,0x29,0xe3,0xfb,0xef,0xa3,0x6b,0x47,0x7f,0x95,0x35,0xa7,0x47,0x4f,",
          "5146:     0xc7,0xf1,0x59,0x95,0x35,0x11,0x29,0x61,0xf1,0x3d,0xb3,0x2b,0x0d,0x43,0x89,0xc1,",
          "5147:     0x9d,0x9d,0x89,0x65,0xf1,0xe9,0xdf,0xbf,0x3d,0x7f,0x53,0x97,0xe5,0xe9,0x95,0x17,",
          "5148:     0x1d,0x3d,0x8b,0xfb,0xc7,0xe3,0x67,0xa7,0x07,0xf1,0x71,0xa7,0x53,0xb5,0x29,0x89,",
          "5149:     0xe5,0x2b,0xa7,0x17,0x29,0xe9,0x4f,0xc5,0x65,0x6d,0x6b,0xef,0x0d,0x89,0x49,0x2f,",
          "5150:     0xb3,0x43,0x53,0x65,0x1d,0x49,0xa3,0x13,0x89,0x59,0xef,0x6b,0xef,0x65,0x1d,0x0b,",
          "5151:     0x59,0x13,0xe3,0x4f,0x9d,0xb3,0x29,0x43,0x2b,0x07,0x1d,0x95,0x59,0x59,0x47,0xfb,",
          "5152:     0xe5,0xe9,0x61,0x47,0x2f,0x35,0x7f,0x17,0x7f,0xef,0x7f,0x95,0x95,0x71,0xd3,0xa3,",
          "5153:     0x0b,0x71,0xa3,0xad,0x0b,0x3b,0xb5,0xfb,0xa3,0xbf,0x4f,0x83,0x1d,0xad,0xe9,0x2f,",
          "5154:     0x71,0x65,0xa3,0xe5,0x07,0x35,0x3d,0x0d,0xb5,0xe9,0xe5,0x47,0x3b,0x9d,0xef,0x35,",
          "5155:     0xa3,0xbf,0xb3,0xdf,0x53,0xd3,0x97,0x53,0x49,0x71,0x07,0x35,0x61,0x71,0x2f,0x43,",
          "5156:     0x2f,0x11,0xdf,0x17,0x97,0xfb,0x95,0x3b,0x7f,0x6b,0xd3,0x25,0xbf,0xad,0xc7,0xc5,",
          "5157:     0xc5,0xb5,0x8b,0xef,0x2f,0xd3,0x07,0x6b,0x25,0x49,0x95,0x25,0x49,0x6d,0x71,0xc7 },",
          "5158:   { 0xa7,0xbc,0xc9,0xad,0x91,0xdf,0x85,0xe5,0xd4,0x78,0xd5,0x17,0x46,0x7c,0x29,0x4c,",
          "5159:     0x4d,0x03,0xe9,0x25,0x68,0x11,0x86,0xb3,0xbd,0xf7,0x6f,0x61,0x22,0xa2,0x26,0x34,",
          "5160:     0x2a,0xbe,0x1e,0x46,0x14,0x68,0x9d,0x44,0x18,0xc2,0x40,0xf4,0x7e,0x5f,0x1b,0xad,",
          "5161:     0x0b,0x94,0xb6,0x67,0xb4,0x0b,0xe1,0xea,0x95,0x9c,0x66,0xdc,0xe7,0x5d,0x6c,0x05,",
          "5162:     0xda,0xd5,0xdf,0x7a,0xef,0xf6,0xdb,0x1f,0x82,0x4c,0xc0,0x68,0x47,0xa1,0xbd,0xee,",
          "5163:     0x39,0x50,0x56,0x4a,0xdd,0xdf,0xa5,0xf8,0xc6,0xda,0xca,0x90,0xca,0x01,0x42,0x9d,",
          "5164:     0x8b,0x0c,0x73,0x43,0x75,0x05,0x94,0xde,0x24,0xb3,0x80,0x34,0xe5,0x2c,0xdc,0x9b,",
          "5165:     0x3f,0xca,0x33,0x45,0xd0,0xdb,0x5f,0xf5,0x52,0xc3,0x21,0xda,0xe2,0x22,0x72,0x6b,",
          "5166:     0x3e,0xd0,0x5b,0xa8,0x87,0x8c,0x06,0x5d,0x0f,0xdd,0x09,0x19,0x93,0xd0,0xb9,0xfc,",
          "5167:     0x8b,0x0f,0x84,0x60,0x33,0x1c,0x9b,0x45,0xf1,0xf0,0xa3,0x94,0x3a,0x12,0x77,0x33,",
          "5168:     0x4d,0x44,0x78,0x28,0x3c,0x9e,0xfd,0x65,0x57,0x16,0x94,0x6b,0xfb,0x59,0xd0,0xc8,",
          "5169:     0x22,0x36,0xdb,0xd2,0x63,0x98,0x43,0xa1,0x04,0x87,0x86,0xf7,0xa6,0x26,0xbb,0xd6,",
          "5170:     0x59,0x4d,0xbf,0x6a,0x2e,0xaa,0x2b,0xef,0xe6,0x78,0xb6,0x4e,0xe0,0x2f,0xdc,0x7c,",
          "5171:     0xbe,0x57,0x19,0x32,0x7e,0x2a,0xd0,0xb8,0xba,0x29,0x00,0x3c,0x52,0x7d,0xa8,0x49,",
          "5172:     0x3b,0x2d,0xeb,0x25,0x49,0xfa,0xa3,0xaa,0x39,0xa7,0xc5,0xa7,0x50,0x11,0x36,0xfb,",
          "5173:     0xc6,0x67,0x4a,0xf5,0xa5,0x12,0x65,0x7e,0xb0,0xdf,0xaf,0x4e,0xb3,0x61,0x7f,0x2f } };",
          "5175: void CLASS gamma_curve (double pwr, double ts, int mode, int imax)",
          "5178:   double g[6], bnd[2]={0,0}, r;",
          "5184:   if (g[1] && (g[1]-1)*(g[0]-1) <= 0) {",
          "5185:     for (i=0; i < 48; i++) {",
          "5186:       g[2] = (bnd[0] + bnd[1])/2;",
          "5187:       if (g[0]) bnd[(pow(g[2]/g[1],-g[0]) - 1)/g[0] - 1/g[2] > -1] = g[2];",
          "5188:       else bnd[g[2]/exp(1-1/g[2]) < g[1]] = g[2];",
          "5191:     if (g[0]) g[4] = g[2] * (1/g[0] - 1);",
          "5192:   }",
          "5193:   if (g[0]) g[5] = 1 / (g[1]*SQR(g[3])/2 - g[4]*(1 - g[3]) +",
          "5194:   (1 - pow(g[3],1+g[0]))*(1 + g[4])/(1 + g[0])) - 1;",
          "5195:   else      g[5] = 1 / (g[1]*SQR(g[3])/2 + 1",
          "5196:   - g[2] - g[3] - g[2]*g[3]*(log(g[3]) - 1)) - 1;",
          "5197:   if (!mode--) {",
          "5198:     memcpy (gamm, g, sizeof gamm);",
          "5201:   for (i=0; i < 0x10000; i++) {",
          "5203:     if ((r = (double) i / imax) < 1)",
          "5204:       curve[i] = 0x10000 * ( mode",
          "5205:  ? (r < g[3] ? r*g[1] : (g[0] ? pow( r,g[0])*(1+g[4])-g[4]    : log(r)*g[2]+1))",
          "5206:  : (r < g[2] ? r/g[1] : (g[0] ? pow((r+g[4])/(1+g[4]),1/g[0]) : exp((r-1)/g[2]))));",
          "5210: void CLASS pseudoinverse (double (*in)[3], double (*out)[3], int size)",
          "5215:   for (i=0; i < 3; i++) {",
          "5216:     for (j=0; j < 6; j++)",
          "5217:       work[i][j] = j == i+3;",
          "5218:     for (j=0; j < 3; j++)",
          "5219:       for (k=0; k < size; k++)",
          "5220:  work[i][j] += in[k][i] * in[k][j];",
          "5222:   for (i=0; i < 3; i++) {",
          "5224:     for (j=0; j < 6; j++)",
          "5226:     for (k=0; k < 3; k++) {",
          "5227:       if (k==i) continue;",
          "5229:       for (j=0; j < 6; j++)",
          "5230:  work[k][j] -= work[i][j] * num;",
          "5233:   for (i=0; i < size; i++)",
          "5234:     for (j=0; j < 3; j++)",
          "5235:       for (out[i][j]=k=0; k < 3; k++)",
          "5236:  out[i][j] += work[j][k+3] * in[i][k];",
          "5239: void CLASS cam_xyz_coeff (float _rgb_cam[3][4], double cam_xyz[4][3])",
          "5245:     for (j=0; j < 3; j++)",
          "5246:       for (cam_rgb[i][j] = k=0; k < 3; k++)",
          "5247:  cam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];",
          "5252:     if(num > 0.00001)",
          "5253:       {",
          "5254:         for (j=0; j < 3; j++)",
          "5255:           cam_rgb[i][j] /= num;",
          "5256:         pre_mul[i] = 1 / num;",
          "5257:       }",
          "5259:       {",
          "5260:         for (j=0; j < 3; j++)",
          "5261:           cam_rgb[i][j] = 0.0;",
          "5262:         pre_mul[i] = 1.0;",
          "5263:       }",
          "5265:   pseudoinverse (cam_rgb, inverse, colors);",
          "5266:   for (i=0; i < 3; i++)",
          "5267:     for (j=0; j < colors; j++)",
          "",
          "[Added Lines]",
          "5800:     {0xc1, 0xbf, 0x6d, 0x0d, 0x59, 0xc5, 0x13, 0x9d, 0x83, 0x61, 0x6b, 0x4f, 0xc7, 0x7f, 0x3d, 0x3d, 0x53, 0x59, 0xe3,",
          "5801:      0xc7, 0xe9, 0x2f, 0x95, 0xa7, 0x95, 0x1f, 0xdf, 0x7f, 0x2b, 0x29, 0xc7, 0x0d, 0xdf, 0x07, 0xef, 0x71, 0x89, 0x3d,",
          "5802:      0x13, 0x3d, 0x3b, 0x13, 0xfb, 0x0d, 0x89, 0xc1, 0x65, 0x1f, 0xb3, 0x0d, 0x6b, 0x29, 0xe3, 0xfb, 0xef, 0xa3, 0x6b,",
          "5803:      0x47, 0x7f, 0x95, 0x35, 0xa7, 0x47, 0x4f, 0xc7, 0xf1, 0x59, 0x95, 0x35, 0x11, 0x29, 0x61, 0xf1, 0x3d, 0xb3, 0x2b,",
          "5804:      0x0d, 0x43, 0x89, 0xc1, 0x9d, 0x9d, 0x89, 0x65, 0xf1, 0xe9, 0xdf, 0xbf, 0x3d, 0x7f, 0x53, 0x97, 0xe5, 0xe9, 0x95,",
          "5805:      0x17, 0x1d, 0x3d, 0x8b, 0xfb, 0xc7, 0xe3, 0x67, 0xa7, 0x07, 0xf1, 0x71, 0xa7, 0x53, 0xb5, 0x29, 0x89, 0xe5, 0x2b,",
          "5806:      0xa7, 0x17, 0x29, 0xe9, 0x4f, 0xc5, 0x65, 0x6d, 0x6b, 0xef, 0x0d, 0x89, 0x49, 0x2f, 0xb3, 0x43, 0x53, 0x65, 0x1d,",
          "5807:      0x49, 0xa3, 0x13, 0x89, 0x59, 0xef, 0x6b, 0xef, 0x65, 0x1d, 0x0b, 0x59, 0x13, 0xe3, 0x4f, 0x9d, 0xb3, 0x29, 0x43,",
          "5808:      0x2b, 0x07, 0x1d, 0x95, 0x59, 0x59, 0x47, 0xfb, 0xe5, 0xe9, 0x61, 0x47, 0x2f, 0x35, 0x7f, 0x17, 0x7f, 0xef, 0x7f,",
          "5809:      0x95, 0x95, 0x71, 0xd3, 0xa3, 0x0b, 0x71, 0xa3, 0xad, 0x0b, 0x3b, 0xb5, 0xfb, 0xa3, 0xbf, 0x4f, 0x83, 0x1d, 0xad,",
          "5810:      0xe9, 0x2f, 0x71, 0x65, 0xa3, 0xe5, 0x07, 0x35, 0x3d, 0x0d, 0xb5, 0xe9, 0xe5, 0x47, 0x3b, 0x9d, 0xef, 0x35, 0xa3,",
          "5811:      0xbf, 0xb3, 0xdf, 0x53, 0xd3, 0x97, 0x53, 0x49, 0x71, 0x07, 0x35, 0x61, 0x71, 0x2f, 0x43, 0x2f, 0x11, 0xdf, 0x17,",
          "5812:      0x97, 0xfb, 0x95, 0x3b, 0x7f, 0x6b, 0xd3, 0x25, 0xbf, 0xad, 0xc7, 0xc5, 0xc5, 0xb5, 0x8b, 0xef, 0x2f, 0xd3, 0x07,",
          "5813:      0x6b, 0x25, 0x49, 0x95, 0x25, 0x49, 0x6d, 0x71, 0xc7},",
          "5814:     {0xa7, 0xbc, 0xc9, 0xad, 0x91, 0xdf, 0x85, 0xe5, 0xd4, 0x78, 0xd5, 0x17, 0x46, 0x7c, 0x29, 0x4c, 0x4d, 0x03, 0xe9,",
          "5815:      0x25, 0x68, 0x11, 0x86, 0xb3, 0xbd, 0xf7, 0x6f, 0x61, 0x22, 0xa2, 0x26, 0x34, 0x2a, 0xbe, 0x1e, 0x46, 0x14, 0x68,",
          "5816:      0x9d, 0x44, 0x18, 0xc2, 0x40, 0xf4, 0x7e, 0x5f, 0x1b, 0xad, 0x0b, 0x94, 0xb6, 0x67, 0xb4, 0x0b, 0xe1, 0xea, 0x95,",
          "5817:      0x9c, 0x66, 0xdc, 0xe7, 0x5d, 0x6c, 0x05, 0xda, 0xd5, 0xdf, 0x7a, 0xef, 0xf6, 0xdb, 0x1f, 0x82, 0x4c, 0xc0, 0x68,",
          "5818:      0x47, 0xa1, 0xbd, 0xee, 0x39, 0x50, 0x56, 0x4a, 0xdd, 0xdf, 0xa5, 0xf8, 0xc6, 0xda, 0xca, 0x90, 0xca, 0x01, 0x42,",
          "5819:      0x9d, 0x8b, 0x0c, 0x73, 0x43, 0x75, 0x05, 0x94, 0xde, 0x24, 0xb3, 0x80, 0x34, 0xe5, 0x2c, 0xdc, 0x9b, 0x3f, 0xca,",
          "5820:      0x33, 0x45, 0xd0, 0xdb, 0x5f, 0xf5, 0x52, 0xc3, 0x21, 0xda, 0xe2, 0x22, 0x72, 0x6b, 0x3e, 0xd0, 0x5b, 0xa8, 0x87,",
          "5821:      0x8c, 0x06, 0x5d, 0x0f, 0xdd, 0x09, 0x19, 0x93, 0xd0, 0xb9, 0xfc, 0x8b, 0x0f, 0x84, 0x60, 0x33, 0x1c, 0x9b, 0x45,",
          "5822:      0xf1, 0xf0, 0xa3, 0x94, 0x3a, 0x12, 0x77, 0x33, 0x4d, 0x44, 0x78, 0x28, 0x3c, 0x9e, 0xfd, 0x65, 0x57, 0x16, 0x94,",
          "5823:      0x6b, 0xfb, 0x59, 0xd0, 0xc8, 0x22, 0x36, 0xdb, 0xd2, 0x63, 0x98, 0x43, 0xa1, 0x04, 0x87, 0x86, 0xf7, 0xa6, 0x26,",
          "5824:      0xbb, 0xd6, 0x59, 0x4d, 0xbf, 0x6a, 0x2e, 0xaa, 0x2b, 0xef, 0xe6, 0x78, 0xb6, 0x4e, 0xe0, 0x2f, 0xdc, 0x7c, 0xbe,",
          "5825:      0x57, 0x19, 0x32, 0x7e, 0x2a, 0xd0, 0xb8, 0xba, 0x29, 0x00, 0x3c, 0x52, 0x7d, 0xa8, 0x49, 0x3b, 0x2d, 0xeb, 0x25,",
          "5826:      0x49, 0xfa, 0xa3, 0xaa, 0x39, 0xa7, 0xc5, 0xa7, 0x50, 0x11, 0x36, 0xfb, 0xc6, 0x67, 0x4a, 0xf5, 0xa5, 0x12, 0x65,",
          "5827:      0x7e, 0xb0, 0xdf, 0xaf, 0x4e, 0xb3, 0x61, 0x7f, 0x2f}};",
          "5829: void CLASS gamma_curve(double pwr, double ts, int mode, int imax)",
          "5832:   double g[6], bnd[2] = {0, 0}, r;",
          "5838:   if (g[1] && (g[1] - 1) * (g[0] - 1) <= 0)",
          "5839:   {",
          "5840:     for (i = 0; i < 48; i++)",
          "5841:     {",
          "5842:       g[2] = (bnd[0] + bnd[1]) / 2;",
          "5843:       if (g[0])",
          "5844:         bnd[(pow(g[2] / g[1], -g[0]) - 1) / g[0] - 1 / g[2] > -1] = g[2];",
          "5845:       else",
          "5846:         bnd[g[2] / exp(1 - 1 / g[2]) < g[1]] = g[2];",
          "5849:     if (g[0])",
          "5850:       g[4] = g[2] * (1 / g[0] - 1);",
          "5851:   }",
          "5852:   if (g[0])",
          "5853:     g[5] = 1 / (g[1] * SQR(g[3]) / 2 - g[4] * (1 - g[3]) + (1 - pow(g[3], 1 + g[0])) * (1 + g[4]) / (1 + g[0])) - 1;",
          "5854:   else",
          "5855:     g[5] = 1 / (g[1] * SQR(g[3]) / 2 + 1 - g[2] - g[3] - g[2] * g[3] * (log(g[3]) - 1)) - 1;",
          "5856:   if (!mode--)",
          "5857:   {",
          "5858:     memcpy(gamm, g, sizeof gamm);",
          "5861:   for (i = 0; i < 0x10000; i++)",
          "5862:   {",
          "5864:     if ((r = (double)i / imax) < 1)",
          "5865:       curve[i] = 0x10000 *",
          "5866:                  (mode ? (r < g[3] ? r * g[1] : (g[0] ? pow(r, g[0]) * (1 + g[4]) - g[4] : log(r) * g[2] + 1))",
          "5867:                        : (r < g[2] ? r / g[1] : (g[0] ? pow((r + g[4]) / (1 + g[4]), 1 / g[0]) : exp((r - 1) / g[2]))));",
          "5871: void CLASS pseudoinverse(double (*in)[3], double (*out)[3], int size)",
          "5876:   for (i = 0; i < 3; i++)",
          "5877:   {",
          "5878:     for (j = 0; j < 6; j++)",
          "5879:       work[i][j] = j == i + 3;",
          "5880:     for (j = 0; j < 3; j++)",
          "5881:       for (k = 0; k < size; k++)",
          "5882:         work[i][j] += in[k][i] * in[k][j];",
          "5884:   for (i = 0; i < 3; i++)",
          "5885:   {",
          "5887:     for (j = 0; j < 6; j++)",
          "5889:     for (k = 0; k < 3; k++)",
          "5890:     {",
          "5891:       if (k == i)",
          "5892:         continue;",
          "5894:       for (j = 0; j < 6; j++)",
          "5895:         work[k][j] -= work[i][j] * num;",
          "5898:   for (i = 0; i < size; i++)",
          "5899:     for (j = 0; j < 3; j++)",
          "5900:       for (out[i][j] = k = 0; k < 3; k++)",
          "5901:         out[i][j] += work[j][k + 3] * in[i][k];",
          "5904: void CLASS cam_xyz_coeff(float _rgb_cam[3][4], double cam_xyz[4][3])",
          "5910:     for (j = 0; j < 3; j++)",
          "5911:       for (cam_rgb[i][j] = k = 0; k < 3; k++)",
          "5912:         cam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];",
          "5914:   for (i = 0; i < colors; i++)",
          "5918:     if (num > 0.00001)",
          "5919:     {",
          "5920:       for (j = 0; j < 3; j++)",
          "5921:         cam_rgb[i][j] /= num;",
          "5922:       pre_mul[i] = 1 / num;",
          "5923:     }",
          "5925:     {",
          "5926:       for (j = 0; j < 3; j++)",
          "5927:         cam_rgb[i][j] = 0.0;",
          "5928:       pre_mul[i] = 1.0;",
          "5929:     }",
          "5931:   pseudoinverse(cam_rgb, inverse, colors);",
          "5932:   for (i = 0; i < 3; i++)",
          "5933:     for (j = 0; j < colors; j++)",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "5272: void CLASS colorcheck()",
          "5273: {",
          "5274: #define NSQ 24",
          "5304:   double gmb_cam[NSQ][4], gmb_xyz[NSQ][3];",
          "5305:   double inverse[NSQ][3], cam_xyz[4][3], balance[4], num;",
          "5306:   int c, i, j, k, sq, row, col, pass, count[4];",
          "5310:     FORCC count[c] = 0;",
          "5320:     gmb_xyz[sq][0] = gmb_xyY[sq][2] * gmb_xyY[sq][0] / gmb_xyY[sq][1];",
          "5321:     gmb_xyz[sq][1] = gmb_xyY[sq][2];",
          "5332:     FORCC balance[c] = pre_mul[c] * gmb_cam[20][c];",
          "5334:       FORCC gmb_cam[sq][c] *= balance[c];",
          "5335:   }",
          "5338:     num = 10000 / (cam_xyz[1][0] + cam_xyz[1][1] + cam_xyz[1][2]);",
          "5342:   }",
          "5343: #undef NSQ",
          "5344: }",
          "5345: #endif",
          "5348: {",
          "5349:   int i;",
          "5354:   for (; i < size; i++)",
          "5356: }",
          "5358: #if !defined(LIBRAW_USE_OPENMP)",
          "5359: void CLASS wavelet_denoise()",
          "5360: {",
          "5363:   ushort *window[4];",
          "5367: #ifdef DCRAW_VERBOSE",
          "5369: #endif",
          "5372:   maximum <<= --scale;",
          "5373:   black <<= scale;",
          "5374:   FORC4 cblack[c] <<= scale;",
          "5382:       fimg[i] = 256 * sqrt((double)(image[i][c] << scale));",
          "5394:       }",
          "5395:       thold = threshold * noise[lev];",
          "5402:       }",
          "5403:       hpass = lpass;",
          "5404:     }",
          "5437: }",
          "5439: void CLASS wavelet_denoise()",
          "5440: {",
          "5443:   ushort *window[4];",
          "5447: #ifdef DCRAW_VERBOSE",
          "5449: #endif",
          "5452:   maximum <<= --scale;",
          "5453:   black <<= scale;",
          "5454:   FORC4 cblack[c] <<= scale;",
          "5460: #ifdef LIBRAW_LIBRARY_BUILD",
          "5462: #endif",
          "5463:   {",
          "5466: #ifdef LIBRAW_LIBRARY_BUILD",
          "5467: #pragma omp for",
          "5468: #endif",
          "5470:         fimg[i] = 256 * sqrt((double)(image[i][c] << scale));",
          "5473: #ifdef LIBRAW_LIBRARY_BUILD",
          "5474: #pragma omp for",
          "5475: #endif",
          "5481: #ifdef LIBRAW_LIBRARY_BUILD",
          "5482: #pragma omp for",
          "5483: #endif",
          "5490: #ifdef LIBRAW_LIBRARY_BUILD",
          "5491: #pragma omp for",
          "5492: #endif",
          "5501:       }",
          "5502: #ifdef LIBRAW_LIBRARY_BUILD",
          "5503: #pragma omp for",
          "5504: #endif",
          "5507:     }",
          "5508:     free(temp);",
          "5543: }",
          "5545: #endif",
          "",
          "[Removed Lines]",
          "5277:   int cut[NSQ][4];   // you must set these",
          "5279:   static const double gmb_xyY[NSQ][3] = {",
          "5280:     { 0.400, 0.350, 10.1 },  // Dark Skin",
          "5281:     { 0.377, 0.345, 35.8 },  // Light Skin",
          "5282:     { 0.247, 0.251, 19.3 },  // Blue Sky",
          "5283:     { 0.337, 0.422, 13.3 },  // Foliage",
          "5284:     { 0.265, 0.240, 24.3 },  // Blue Flower",
          "5285:     { 0.261, 0.343, 43.1 },  // Bluish Green",
          "5286:     { 0.506, 0.407, 30.1 },  // Orange",
          "5287:     { 0.211, 0.175, 12.0 },  // Purplish Blue",
          "5288:     { 0.453, 0.306, 19.8 },  // Moderate Red",
          "5289:     { 0.285, 0.202, 6.6 },  // Purple",
          "5290:     { 0.380, 0.489, 44.3 },  // Yellow Green",
          "5291:     { 0.473, 0.438, 43.1 },  // Orange Yellow",
          "5292:     { 0.187, 0.129, 6.1 },  // Blue",
          "5293:     { 0.305, 0.478, 23.4 },  // Green",
          "5294:     { 0.539, 0.313, 12.0 },  // Red",
          "5295:     { 0.448, 0.470, 59.1 },  // Yellow",
          "5296:     { 0.364, 0.233, 19.8 },  // Magenta",
          "5297:     { 0.196, 0.252, 19.8 },  // Cyan",
          "5298:     { 0.310, 0.316, 90.0 },  // White",
          "5299:     { 0.310, 0.316, 59.1 },  // Neutral 8",
          "5300:     { 0.310, 0.316, 36.2 },  // Neutral 6.5",
          "5301:     { 0.310, 0.316, 19.8 },  // Neutral 5",
          "5302:     { 0.310, 0.316, 9.0 },  // Neutral 3.5",
          "5303:     { 0.310, 0.316, 3.1 } };  // Black",
          "5308:   memset (gmb_cam, 0, sizeof gmb_cam);",
          "5309:   for (sq=0; sq < NSQ; sq++) {",
          "5311:     for   (row=cut[sq][3]; row < cut[sq][3]+cut[sq][1]; row++)",
          "5312:       for (col=cut[sq][2]; col < cut[sq][2]+cut[sq][0]; col++) {",
          "5313:  c = FC(row,col);",
          "5314:  if (c >= colors) c -= 2;",
          "5315:  gmb_cam[sq][c] += BAYER2(row,col);",
          "5316:  BAYER2(row,col) = black + (BAYER2(row,col)-black)/2;",
          "5317:  count[c]++;",
          "5318:       }",
          "5319:     FORCC gmb_cam[sq][c] = gmb_cam[sq][c]/count[c] - black;",
          "5322:     gmb_xyz[sq][2] = gmb_xyY[sq][2] *",
          "5323:   (1 - gmb_xyY[sq][0] - gmb_xyY[sq][1]) / gmb_xyY[sq][1];",
          "5324:   }",
          "5325:   pseudoinverse (gmb_xyz, inverse, NSQ);",
          "5326:   for (pass=0; pass < 2; pass++) {",
          "5327:     for (raw_color = i=0; i < colors; i++)",
          "5328:       for (j=0; j < 3; j++)",
          "5329:  for (cam_xyz[i][j] = k=0; k < NSQ; k++)",
          "5330:    cam_xyz[i][j] += gmb_cam[k][i] * inverse[k][j];",
          "5331:     cam_xyz_coeff (rgb_cam, cam_xyz);",
          "5333:     for (sq=0; sq < NSQ; sq++)",
          "5336:   if (verbose) {",
          "5337:     printf (\"    { \\\"%s %s\\\", %d,\\n\\t{\", make, model, black);",
          "5339:     FORCC for (j=0; j < 3; j++)",
          "5340:       printf (\"%c%d\", (c | j) ? ',':' ', (int) (cam_xyz[c][j] * num + 0.5));",
          "5341:     puts (\" } },\");",
          "5347: void CLASS hat_transform (float *temp, float *base, int st, int size, int sc)",
          "5350:   for (i=0; i < sc; i++)",
          "5351:     temp[i] = 2*base[st*i] + base[st*(sc-i)] + base[st*(i+sc)];",
          "5352:   for (; i+sc < size; i++)",
          "5353:     temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(i+sc)];",
          "5355:     temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(2*size-2-(i+sc))];",
          "5361:   float *fimg=0, *temp, thold, mul[2], avg, diff;",
          "5362:   int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];",
          "5364:   static const float noise[] =",
          "5365:   { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };",
          "5368:   if (verbose) fprintf (stderr,_(\"Wavelet denoising...\\n\"));",
          "5371:   while (maximum << scale < 0x10000) scale++;",
          "5375:   if ((size = iheight*iwidth) < 0x15550000)",
          "5376:     fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);",
          "5377:   merror (fimg, \"wavelet_denoise()\");",
          "5378:   temp = fimg + size*3;",
          "5379:   if ((nc = colors) == 3 && filters) nc++;",
          "5381:     for (i=0; i < size; i++)",
          "5383:     for (hpass=lev=0; lev < 5; lev++) {",
          "5384:       lpass = size*((lev & 1)+1);",
          "5385:       for (row=0; row < iheight; row++) {",
          "5386:  hat_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 << lev);",
          "5387:  for (col=0; col < iwidth; col++)",
          "5388:    fimg[lpass + row*iwidth + col] = temp[col] * 0.25;",
          "5389:       }",
          "5390:       for (col=0; col < iwidth; col++) {",
          "5391:  hat_transform (temp, fimg+lpass+col, iwidth, iheight, 1 << lev);",
          "5392:  for (row=0; row < iheight; row++)",
          "5393:    fimg[lpass + row*iwidth + col] = temp[row] * 0.25;",
          "5396:       for (i=0; i < size; i++) {",
          "5397:  fimg[hpass+i] -= fimg[lpass+i];",
          "5398:  if (fimg[hpass+i] < -thold) fimg[hpass+i] += thold;",
          "5399:  else if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;",
          "5400:  else  fimg[hpass+i] = 0;",
          "5401:  if (hpass) fimg[i] += fimg[hpass+i];",
          "5405:     for (i=0; i < size; i++)",
          "5406:       image[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);",
          "5407:   }",
          "5409:     for (row=0; row < 2; row++) {",
          "5410:       mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];",
          "5411:       blk[row] = cblack[FC(row,0) | 1];",
          "5412:     }",
          "5413:     for (i=0; i < 4; i++)",
          "5414:       window[i] = (ushort *) fimg + width*i;",
          "5415:     for (wlast=-1, row=1; row < height-1; row++) {",
          "5416:       while (wlast < row+1) {",
          "5417:  for (wlast++, i=0; i < 4; i++)",
          "5418:    window[(i+3) & 3] = window[i];",
          "5419:  for (col = FC(wlast,1) & 1; col < width; col+=2)",
          "5420:    window[2][col] = BAYER(wlast,col);",
          "5421:       }",
          "5422:       thold = threshold/512;",
          "5423:       for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {",
          "5424:  avg = ( window[0][col-1] + window[0][col+1] +",
          "5425:   window[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )",
          "5427:  avg = avg < 0 ? 0 : sqrt(avg);",
          "5428:  diff = sqrt((double)BAYER(row,col)) - avg;",
          "5429:  if      (diff < -thold) diff += thold;",
          "5430:  else if (diff >  thold) diff -= thold;",
          "5431:  else diff = 0;",
          "5432:  BAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);",
          "5433:       }",
          "5434:     }",
          "5435:   }",
          "5436:   free (fimg);",
          "5441:   float *fimg=0, *temp, thold, mul[2], avg, diff;",
          "5442:    int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];",
          "5444:   static const float noise[] =",
          "5445:   { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };",
          "5448:   if (verbose) fprintf (stderr,_(\"Wavelet denoising...\\n\"));",
          "5451:   while (maximum << scale < 0x10000) scale++;",
          "5455:   if ((size = iheight*iwidth) < 0x15550000)",
          "5456:     fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);",
          "5457:   merror (fimg, \"wavelet_denoise()\");",
          "5458:   temp = fimg + size*3;",
          "5459:   if ((nc = colors) == 3 && filters) nc++;",
          "5461: #pragma omp parallel default(shared) private(i,col,row,thold,lev,lpass,hpass,temp,c) firstprivate(scale,size)",
          "5464:       temp = (float*)malloc( (iheight + iwidth) * sizeof *fimg);",
          "5469:       for (i=0; i < size; i++)",
          "5471:       for (hpass=lev=0; lev < 5; lev++) {",
          "5472:  lpass = size*((lev & 1)+1);",
          "5476:  for (row=0; row < iheight; row++) {",
          "5477:    hat_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 << lev);",
          "5478:    for (col=0; col < iwidth; col++)",
          "5479:      fimg[lpass + row*iwidth + col] = temp[col] * 0.25;",
          "5480:  }",
          "5484:  for (col=0; col < iwidth; col++) {",
          "5485:    hat_transform (temp, fimg+lpass+col, iwidth, iheight, 1 << lev);",
          "5486:    for (row=0; row < iheight; row++)",
          "5487:      fimg[lpass + row*iwidth + col] = temp[row] * 0.25;",
          "5488:  }",
          "5489:  thold = threshold * noise[lev];",
          "5493:  for (i=0; i < size; i++) {",
          "5494:    fimg[hpass+i] -= fimg[lpass+i];",
          "5495:    if (fimg[hpass+i] < -thold) fimg[hpass+i] += thold;",
          "5496:    else if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;",
          "5497:    else  fimg[hpass+i] = 0;",
          "5498:    if (hpass) fimg[i] += fimg[hpass+i];",
          "5499:  }",
          "5500:  hpass = lpass;",
          "5505:       for (i=0; i < size; i++)",
          "5506:  image[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);",
          "5515:    for (row=0; row < 2; row++){",
          "5516:       mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];",
          "5517:       blk[row] = cblack[FC(row,0) | 1];",
          "5518:    }",
          "5519:     for (i=0; i < 4; i++)",
          "5520:       window[i] = (ushort *) fimg + width*i;",
          "5521:     for (wlast=-1, row=1; row < height-1; row++) {",
          "5522:       while (wlast < row+1) {",
          "5523:  for (wlast++, i=0; i < 4; i++)",
          "5524:    window[(i+3) & 3] = window[i];",
          "5525:  for (col = FC(wlast,1) & 1; col < width; col+=2)",
          "5526:    window[2][col] = BAYER(wlast,col);",
          "5527:       }",
          "5528:       thold = threshold/512;",
          "5529:       for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {",
          "5530:  avg = ( window[0][col-1] + window[0][col+1] +",
          "5531:   window[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )",
          "5533:  avg = avg < 0 ? 0 : sqrt(avg);",
          "5534:  diff = sqrt((double)BAYER(row,col)) - avg;",
          "5535:  if      (diff < -thold) diff += thold;",
          "5536:  else if (diff >  thold) diff -= thold;",
          "5537:  else diff = 0;",
          "5538:  BAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);",
          "5539:       }",
          "5540:     }",
          "5541:   }",
          "5542:   free (fimg);",
          "",
          "[Added Lines]",
          "5943:   int cut[NSQ][4];                                             // you must set these",
          "5945:   static const double gmb_xyY[NSQ][3] = {{0.400, 0.350, 10.1}, // Dark Skin",
          "5946:                                          {0.377, 0.345, 35.8}, // Light Skin",
          "5947:                                          {0.247, 0.251, 19.3}, // Blue Sky",
          "5948:                                          {0.337, 0.422, 13.3}, // Foliage",
          "5949:                                          {0.265, 0.240, 24.3}, // Blue Flower",
          "5950:                                          {0.261, 0.343, 43.1}, // Bluish Green",
          "5951:                                          {0.506, 0.407, 30.1}, // Orange",
          "5952:                                          {0.211, 0.175, 12.0}, // Purplish Blue",
          "5953:                                          {0.453, 0.306, 19.8}, // Moderate Red",
          "5954:                                          {0.285, 0.202, 6.6},  // Purple",
          "5955:                                          {0.380, 0.489, 44.3}, // Yellow Green",
          "5956:                                          {0.473, 0.438, 43.1}, // Orange Yellow",
          "5957:                                          {0.187, 0.129, 6.1},  // Blue",
          "5958:                                          {0.305, 0.478, 23.4}, // Green",
          "5959:                                          {0.539, 0.313, 12.0}, // Red",
          "5960:                                          {0.448, 0.470, 59.1}, // Yellow",
          "5961:                                          {0.364, 0.233, 19.8}, // Magenta",
          "5962:                                          {0.196, 0.252, 19.8}, // Cyan",
          "5963:                                          {0.310, 0.316, 90.0}, // White",
          "5964:                                          {0.310, 0.316, 59.1}, // Neutral 8",
          "5965:                                          {0.310, 0.316, 36.2}, // Neutral 6.5",
          "5966:                                          {0.310, 0.316, 19.8}, // Neutral 5",
          "5967:                                          {0.310, 0.316, 9.0},  // Neutral 3.5",
          "5968:                                          {0.310, 0.316, 3.1}}; // Black",
          "5973:   memset(gmb_cam, 0, sizeof gmb_cam);",
          "5974:   for (sq = 0; sq < NSQ; sq++)",
          "5975:   {",
          "5977:     for (row = cut[sq][3]; row < cut[sq][3] + cut[sq][1]; row++)",
          "5978:       for (col = cut[sq][2]; col < cut[sq][2] + cut[sq][0]; col++)",
          "5979:       {",
          "5980:         c = FC(row, col);",
          "5981:         if (c >= colors)",
          "5982:           c -= 2;",
          "5983:         gmb_cam[sq][c] += BAYER2(row, col);",
          "5984:         BAYER2(row, col) = black + (BAYER2(row, col) - black) / 2;",
          "5985:         count[c]++;",
          "5986:       }",
          "5987:     FORCC gmb_cam[sq][c] = gmb_cam[sq][c] / count[c] - black;",
          "5990:     gmb_xyz[sq][2] = gmb_xyY[sq][2] * (1 - gmb_xyY[sq][0] - gmb_xyY[sq][1]) / gmb_xyY[sq][1];",
          "5991:   }",
          "5992:   pseudoinverse(gmb_xyz, inverse, NSQ);",
          "5993:   for (pass = 0; pass < 2; pass++)",
          "5994:   {",
          "5995:     for (raw_color = i = 0; i < colors; i++)",
          "5996:       for (j = 0; j < 3; j++)",
          "5997:         for (cam_xyz[i][j] = k = 0; k < NSQ; k++)",
          "5998:           cam_xyz[i][j] += gmb_cam[k][i] * inverse[k][j];",
          "5999:     cam_xyz_coeff(rgb_cam, cam_xyz);",
          "6001:     for (sq = 0; sq < NSQ; sq++)",
          "6004:   if (verbose)",
          "6005:   {",
          "6006:     printf(\"    { \\\"%s %s\\\", %d,\\n\\t{\", make, model, black);",
          "6008:     FORCC for (j = 0; j < 3; j++) printf(\"%c%d\", (c | j) ? ',' : ' ', (int)(cam_xyz[c][j] * num + 0.5));",
          "6009:     puts(\" } },\");",
          "6015: void CLASS hat_transform(float *temp, float *base, int st, int size, int sc)",
          "6018:   for (i = 0; i < sc; i++)",
          "6019:     temp[i] = 2 * base[st * i] + base[st * (sc - i)] + base[st * (i + sc)];",
          "6020:   for (; i + sc < size; i++)",
          "6021:     temp[i] = 2 * base[st * i] + base[st * (i - sc)] + base[st * (i + sc)];",
          "6023:     temp[i] = 2 * base[st * i] + base[st * (i - sc)] + base[st * (2 * size - 2 - (i + sc))];",
          "6029:   float *fimg = 0, *temp, thold, mul[2], avg, diff;",
          "6030:   int scale = 1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];",
          "6032:   static const float noise[] = {0.8002, 0.2735, 0.1202, 0.0585, 0.0291, 0.0152, 0.0080, 0.0044};",
          "6035:   if (verbose)",
          "6036:     fprintf(stderr, _(\"Wavelet denoising...\\n\"));",
          "6039:   while (maximum << scale < 0x10000)",
          "6040:     scale++;",
          "6044:   if ((size = iheight * iwidth) < 0x15550000)",
          "6045:     fimg = (float *)malloc((size * 3 + iheight + iwidth) * sizeof *fimg);",
          "6046:   merror(fimg, \"wavelet_denoise()\");",
          "6047:   temp = fimg + size * 3;",
          "6048:   if ((nc = colors) == 3 && filters)",
          "6049:     nc++;",
          "6050:   FORC(nc)",
          "6052:     for (i = 0; i < size; i++)",
          "6054:     for (hpass = lev = 0; lev < 5; lev++)",
          "6055:     {",
          "6056:       lpass = size * ((lev & 1) + 1);",
          "6057:       for (row = 0; row < iheight; row++)",
          "6058:       {",
          "6059:         hat_transform(temp, fimg + hpass + row * iwidth, 1, iwidth, 1 << lev);",
          "6060:         for (col = 0; col < iwidth; col++)",
          "6061:           fimg[lpass + row * iwidth + col] = temp[col] * 0.25;",
          "6062:       }",
          "6063:       for (col = 0; col < iwidth; col++)",
          "6064:       {",
          "6065:         hat_transform(temp, fimg + lpass + col, iwidth, iheight, 1 << lev);",
          "6066:         for (row = 0; row < iheight; row++)",
          "6067:           fimg[lpass + row * iwidth + col] = temp[row] * 0.25;",
          "6070:       for (i = 0; i < size; i++)",
          "6071:       {",
          "6072:         fimg[hpass + i] -= fimg[lpass + i];",
          "6073:         if (fimg[hpass + i] < -thold)",
          "6074:           fimg[hpass + i] += thold;",
          "6075:         else if (fimg[hpass + i] > thold)",
          "6076:           fimg[hpass + i] -= thold;",
          "6077:         else",
          "6078:           fimg[hpass + i] = 0;",
          "6079:         if (hpass)",
          "6080:           fimg[i] += fimg[hpass + i];",
          "6084:     for (i = 0; i < size; i++)",
          "6085:       image[i][c] = CLIP(SQR(fimg[i] + fimg[lpass + i]) / 0x10000);",
          "6086:   }",
          "6087:   if (filters && colors == 3)",
          "6089:     for (row = 0; row < 2; row++)",
          "6090:     {",
          "6091:       mul[row] = 0.125 * pre_mul[FC(row + 1, 0) | 1] / pre_mul[FC(row, 0) | 1];",
          "6092:       blk[row] = cblack[FC(row, 0) | 1];",
          "6093:     }",
          "6094:     for (i = 0; i < 4; i++)",
          "6095:       window[i] = (ushort *)fimg + width * i;",
          "6096:     for (wlast = -1, row = 1; row < height - 1; row++)",
          "6097:     {",
          "6098:       while (wlast < row + 1)",
          "6099:       {",
          "6100:         for (wlast++, i = 0; i < 4; i++)",
          "6101:           window[(i + 3) & 3] = window[i];",
          "6102:         for (col = FC(wlast, 1) & 1; col < width; col += 2)",
          "6103:           window[2][col] = BAYER(wlast, col);",
          "6104:       }",
          "6105:       thold = threshold / 512;",
          "6106:       for (col = (FC(row, 0) & 1) + 1; col < width - 1; col += 2)",
          "6107:       {",
          "6108:         avg = (window[0][col - 1] + window[0][col + 1] + window[2][col - 1] + window[2][col + 1] - blk[~row & 1] * 4) *",
          "6109:                   mul[row & 1] +",
          "6110:               (window[1][col] + blk[row & 1]) * 0.5;",
          "6111:         avg = avg < 0 ? 0 : sqrt(avg);",
          "6112:         diff = sqrt((double)BAYER(row, col)) - avg;",
          "6113:         if (diff < -thold)",
          "6114:           diff += thold;",
          "6115:         else if (diff > thold)",
          "6116:           diff -= thold;",
          "6117:         else",
          "6118:           diff = 0;",
          "6119:         BAYER(row, col) = CLIP(SQR(avg + diff) + 0.5);",
          "6120:       }",
          "6121:     }",
          "6122:   }",
          "6123:   free(fimg);",
          "6128:   float *fimg = 0, *temp, thold, mul[2], avg, diff;",
          "6129:   int scale = 1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];",
          "6131:   static const float noise[] = {0.8002, 0.2735, 0.1202, 0.0585, 0.0291, 0.0152, 0.0080, 0.0044};",
          "6134:   if (verbose)",
          "6135:     fprintf(stderr, _(\"Wavelet denoising...\\n\"));",
          "6138:   while (maximum << scale < 0x10000)",
          "6139:     scale++;",
          "6143:   if ((size = iheight * iwidth) < 0x15550000)",
          "6144:     fimg = (float *)malloc((size * 3 + iheight + iwidth) * sizeof *fimg);",
          "6145:   merror(fimg, \"wavelet_denoise()\");",
          "6146:   temp = fimg + size * 3;",
          "6147:   if ((nc = colors) == 3 && filters)",
          "6148:     nc++;",
          "6150: #pragma omp parallel default(shared) private(i, col, row, thold, lev, lpass, hpass, temp, c) firstprivate(scale, size)",
          "6153:     temp = (float *)malloc((iheight + iwidth) * sizeof *fimg);",
          "6154:     FORC(nc)",
          "6159:       for (i = 0; i < size; i++)",
          "6161:       for (hpass = lev = 0; lev < 5; lev++)",
          "6162:       {",
          "6163:         lpass = size * ((lev & 1) + 1);",
          "6167:         for (row = 0; row < iheight; row++)",
          "6168:         {",
          "6169:           hat_transform(temp, fimg + hpass + row * iwidth, 1, iwidth, 1 << lev);",
          "6170:           for (col = 0; col < iwidth; col++)",
          "6171:             fimg[lpass + row * iwidth + col] = temp[col] * 0.25;",
          "6172:         }",
          "6176:         for (col = 0; col < iwidth; col++)",
          "6177:         {",
          "6178:           hat_transform(temp, fimg + lpass + col, iwidth, iheight, 1 << lev);",
          "6179:           for (row = 0; row < iheight; row++)",
          "6180:             fimg[lpass + row * iwidth + col] = temp[row] * 0.25;",
          "6181:         }",
          "6182:         thold = threshold * noise[lev];",
          "6186:         for (i = 0; i < size; i++)",
          "6187:         {",
          "6188:           fimg[hpass + i] -= fimg[lpass + i];",
          "6189:           if (fimg[hpass + i] < -thold)",
          "6190:             fimg[hpass + i] += thold;",
          "6191:           else if (fimg[hpass + i] > thold)",
          "6192:             fimg[hpass + i] -= thold;",
          "6193:           else",
          "6194:             fimg[hpass + i] = 0;",
          "6195:           if (hpass)",
          "6196:             fimg[i] += fimg[hpass + i];",
          "6197:         }",
          "6198:         hpass = lpass;",
          "6203:       for (i = 0; i < size; i++)",
          "6204:         image[i][c] = CLIP(SQR(fimg[i] + fimg[lpass + i]) / 0x10000);",
          "6212:   if (filters && colors == 3)",
          "6214:     for (row = 0; row < 2; row++)",
          "6215:     {",
          "6216:       mul[row] = 0.125 * pre_mul[FC(row + 1, 0) | 1] / pre_mul[FC(row, 0) | 1];",
          "6217:       blk[row] = cblack[FC(row, 0) | 1];",
          "6218:     }",
          "6219:     for (i = 0; i < 4; i++)",
          "6220:       window[i] = (ushort *)fimg + width * i;",
          "6221:     for (wlast = -1, row = 1; row < height - 1; row++)",
          "6222:     {",
          "6223:       while (wlast < row + 1)",
          "6224:       {",
          "6225:         for (wlast++, i = 0; i < 4; i++)",
          "6226:           window[(i + 3) & 3] = window[i];",
          "6227:         for (col = FC(wlast, 1) & 1; col < width; col += 2)",
          "6228:           window[2][col] = BAYER(wlast, col);",
          "6229:       }",
          "6230:       thold = threshold / 512;",
          "6231:       for (col = (FC(row, 0) & 1) + 1; col < width - 1; col += 2)",
          "6232:       {",
          "6233:         avg = (window[0][col - 1] + window[0][col + 1] + window[2][col - 1] + window[2][col + 1] - blk[~row & 1] * 4) *",
          "6234:                   mul[row & 1] +",
          "6235:               (window[1][col] + blk[row & 1]) * 0.5;",
          "6236:         avg = avg < 0 ? 0 : sqrt(avg);",
          "6237:         diff = sqrt((double)BAYER(row, col)) - avg;",
          "6238:         if (diff < -thold)",
          "6239:           diff += thold;",
          "6240:         else if (diff > thold)",
          "6241:           diff -= thold;",
          "6242:         else",
          "6243:           diff = 0;",
          "6244:         BAYER(row, col) = CLIP(SQR(avg + diff) + 0.5);",
          "6245:       }",
          "6246:     }",
          "6247:   }",
          "6248:   free(fimg);",
          "",
          "---------------",
          "--- Hunk 69 ---",
          "[Context before]",
          "5548: void CLASS green_matching()",
          "5549: {",
          "5555:   const int margin = 3;",
          "5556:   int oj = 2, oi = 2;",
          "5557:   float f;",
          "5558:   const float thr = 0.01f;",
          "5585:       {",
          "5588:       }",
          "5589:     }",
          "5590:   free(img);",
          "",
          "[Removed Lines]",
          "5550:   int i,j;",
          "5551:   double m1,m2,c1,c2;",
          "5552:   int o1_1,o1_2,o1_3,o1_4;",
          "5553:   int o2_1,o2_2,o2_3,o2_4;",
          "5554:   ushort (*img)[4];",
          "5559:   if(half_size || shrink) return;",
          "5560:   if(FC(oj, oi) != 3) oj++;",
          "5561:   if(FC(oj, oi) != 3) oi++;",
          "5562:   if(FC(oj, oi) != 3) oj--;",
          "5564:   img = (ushort (*)[4]) calloc (height*width, sizeof *image);",
          "5565:   merror (img, \"green_matching()\");",
          "5566:   memcpy(img,image,height*width*sizeof *image);",
          "5568:   for(j=oj;j<height-margin;j+=2)",
          "5569:     for(i=oi;i<width-margin;i+=2){",
          "5570:       o1_1=img[(j-1)*width+i-1][1];",
          "5571:       o1_2=img[(j-1)*width+i+1][1];",
          "5572:       o1_3=img[(j+1)*width+i-1][1];",
          "5573:       o1_4=img[(j+1)*width+i+1][1];",
          "5574:       o2_1=img[(j-2)*width+i][3];",
          "5575:       o2_2=img[(j+2)*width+i][3];",
          "5576:       o2_3=img[j*width+i-2][3];",
          "5577:       o2_4=img[j*width+i+2][3];",
          "5579:       m1=(o1_1+o1_2+o1_3+o1_4)/4.0;",
          "5580:       m2=(o2_1+o2_2+o2_3+o2_4)/4.0;",
          "5582:       c1=(abs(o1_1-o1_2)+abs(o1_1-o1_3)+abs(o1_1-o1_4)+abs(o1_2-o1_3)+abs(o1_3-o1_4)+abs(o1_2-o1_4))/6.0;",
          "5583:       c2=(abs(o2_1-o2_2)+abs(o2_1-o2_3)+abs(o2_1-o2_4)+abs(o2_2-o2_3)+abs(o2_3-o2_4)+abs(o2_2-o2_4))/6.0;",
          "5584:       if((img[j*width+i][3]<maximum*0.95)&&(c1<maximum*thr)&&(c2<maximum*thr))",
          "5586:         f = image[j*width+i][3]*m1/m2;",
          "5587:         image[j*width+i][3]=f>0xffff?0xffff:f;",
          "",
          "[Added Lines]",
          "6256:   int i, j;",
          "6257:   double m1, m2, c1, c2;",
          "6258:   int o1_1, o1_2, o1_3, o1_4;",
          "6259:   int o2_1, o2_2, o2_3, o2_4;",
          "6260:   ushort(*img)[4];",
          "6265:   if (half_size || shrink)",
          "6266:     return;",
          "6267:   if (FC(oj, oi) != 3)",
          "6268:     oj++;",
          "6269:   if (FC(oj, oi) != 3)",
          "6270:     oi++;",
          "6271:   if (FC(oj, oi) != 3)",
          "6272:     oj--;",
          "6274:   img = (ushort(*)[4])calloc(height * width, sizeof *image);",
          "6275:   merror(img, \"green_matching()\");",
          "6276:   memcpy(img, image, height * width * sizeof *image);",
          "6278:   for (j = oj; j < height - margin; j += 2)",
          "6279:     for (i = oi; i < width - margin; i += 2)",
          "6280:     {",
          "6281:       o1_1 = img[(j - 1) * width + i - 1][1];",
          "6282:       o1_2 = img[(j - 1) * width + i + 1][1];",
          "6283:       o1_3 = img[(j + 1) * width + i - 1][1];",
          "6284:       o1_4 = img[(j + 1) * width + i + 1][1];",
          "6285:       o2_1 = img[(j - 2) * width + i][3];",
          "6286:       o2_2 = img[(j + 2) * width + i][3];",
          "6287:       o2_3 = img[j * width + i - 2][3];",
          "6288:       o2_4 = img[j * width + i + 2][3];",
          "6290:       m1 = (o1_1 + o1_2 + o1_3 + o1_4) / 4.0;",
          "6291:       m2 = (o2_1 + o2_2 + o2_3 + o2_4) / 4.0;",
          "6293:       c1 = (abs(o1_1 - o1_2) + abs(o1_1 - o1_3) + abs(o1_1 - o1_4) + abs(o1_2 - o1_3) + abs(o1_3 - o1_4) +",
          "6294:             abs(o1_2 - o1_4)) /",
          "6295:            6.0;",
          "6296:       c2 = (abs(o2_1 - o2_2) + abs(o2_1 - o2_3) + abs(o2_1 - o2_4) + abs(o2_2 - o2_3) + abs(o2_3 - o2_4) +",
          "6297:             abs(o2_2 - o2_4)) /",
          "6298:            6.0;",
          "6299:       if ((img[j * width + i][3] < maximum * 0.95) && (c1 < maximum * thr) && (c2 < maximum * thr))",
          "6301:         f = image[j * width + i][3] * m1 / m2;",
          "6302:         image[j * width + i][3] = f > 0xffff ? 0xffff : f;",
          "",
          "---------------",
          "--- Hunk 70 ---",
          "[Context before]",
          "5596:   int val, dark, sat;",
          "5597:   double dsum[8], dmin, dmax;",
          "5598:   float scale_mul[4], fr, fc;",
          "5601: #ifdef LIBRAW_LIBRARY_BUILD",
          "5603: #endif",
          "5605:   if (user_mul[0])",
          "5647:       }",
          "5648:     else",
          "5649: #endif",
          "5652:     else if (cam_mul[0] && cam_mul[2])",
          "5654:     else",
          "5656: #ifdef LIBRAW_LIBRARY_BUILD",
          "5658: #endif",
          "5659: #ifdef DCRAW_VERBOSE",
          "5661: #endif",
          "5663:   }",
          "5664: #ifdef LIBRAW_LIBRARY_BUILD",
          "5672:   }",
          "5673: #endif",
          "5676:   dark = black;",
          "5677:   sat = maximum;",
          "5679:   maximum -= black;",
          "5681:     if (dmin > pre_mul[c])",
          "5683:     if (dmax < pre_mul[c])",
          "5685:   }",
          "5687:   FORC4 scale_mul[c] = (pre_mul[c] /= dmax) * 65535.0 / maximum;",
          "5688: #ifdef DCRAW_VERBOSE",
          "5694:   }",
          "5695: #endif",
          "5699:     cblack[4] = cblack[5] = 0;",
          "5700:   }",
          "5702: #ifdef LIBRAW_LIBRARY_BUILD",
          "5703:   scale_colors_loop(scale_mul);",
          "5704: #else",
          "5707:     if (cblack[4] && cblack[5])",
          "5710:     val -= cblack[i & 3];",
          "5711:     val *= scale_mul[i & 3];",
          "5712:     ((ushort *)image)[i] = CLIP(val);",
          "5713:   }",
          "5714: #endif",
          "5716: #ifdef DCRAW_VERBOSE",
          "5717:     if (verbose)",
          "5739:       }",
          "5740:       free(img);",
          "5741:     }",
          "5742:   }",
          "5743: #ifdef LIBRAW_LIBRARY_BUILD",
          "5745: #endif",
          "5746: }",
          "5748: void CLASS pre_interpolate()",
          "5749: {",
          "5751:   int row, col, c;",
          "5752: #ifdef LIBRAW_LIBRARY_BUILD",
          "5754: #endif",
          "5757:       height = iheight;",
          "5780:       image = img;",
          "5781:       shrink = 0;",
          "5782:     }",
          "5783:   }",
          "5785:     mix_green = four_color_rgb ^ half_size;",
          "5791:       filters &= ~((filters & 0x55555555) << 1);",
          "5792:     }",
          "5793:   }",
          "5795: #ifdef LIBRAW_LIBRARY_BUILD",
          "5797: #endif",
          "5798: }",
          "5801: {",
          "5802:   unsigned row, col, y, x, f, c, sum[8];",
          "5819:     }",
          "5820: }",
          "5823: {",
          "5824:   int row;",
          "5826:     {",
          "5840:     }",
          "5841: }",
          "5843: void CLASS lin_interpolate()",
          "5844: {",
          "5846:   int f, c, x, y, row, col, shift, color;",
          "5849: #ifdef DCRAW_VERBOSE",
          "5851: #endif",
          "5852: #ifdef LIBRAW_LIBRARY_BUILD",
          "5854: #endif",
          "5857:   border_interpolate(1);",
          "5873:       code[row][col][0] = (ip - code[row][col]) / 3;",
          "5874:       FORCC",
          "5879:     }",
          "5880: #ifdef LIBRAW_LIBRARY_BUILD",
          "5882: #endif",
          "5884: #ifdef LIBRAW_LIBRARY_BUILD",
          "5886: #endif",
          "5887: }",
          "",
          "[Removed Lines]",
          "5599:   ushort *img=0, *pix;",
          "5602:   RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS,0,2);",
          "5606:     memcpy (pre_mul, user_mul, sizeof pre_mul);",
          "5607:   if (use_auto_wb || (use_camera_wb && cam_mul[0] == -1)) {",
          "5608:     memset (dsum, 0, sizeof dsum);",
          "5609:     bottom = MIN (greybox[1]+greybox[3], height);",
          "5610:     right  = MIN (greybox[0]+greybox[2], width);",
          "5611:     for (row=greybox[1]; row < bottom; row += 8)",
          "5612:       for (col=greybox[0]; col < right; col += 8) {",
          "5613:  memset (sum, 0, sizeof sum);",
          "5614:  for (y=row; y < row+8 && y < bottom; y++)",
          "5615:    for (x=col; x < col+8 && x < right; x++)",
          "5616:      FORC4 {",
          "5617:        if (filters) {",
          "5618:   c = fcol(y,x);",
          "5619:   val = BAYER2(y,x);",
          "5620:        } else",
          "5621:   val = image[y*width+x][c];",
          "5622:        if (val > maximum-25) goto skip_block;",
          "5623:        if ((val -= cblack[c]) < 0) val = 0;",
          "5624:        sum[c] += val;",
          "5625:        sum[c+4]++;",
          "5626:        if (filters) break;",
          "5627:      }",
          "5628:  FORC(8) dsum[c] += sum[c];",
          "5629: skip_block: ;",
          "5630:       }",
          "5631:     FORC4 if (dsum[c]) pre_mul[c] = dsum[c+4] / dsum[c];",
          "5632:   }",
          "5633:   if (use_camera_wb && cam_mul[0] != -1) {",
          "5634:     memset (sum, 0, sizeof sum);",
          "5635:     for (row=0; row < 8; row++)",
          "5636:       for (col=0; col < 8; col++) {",
          "5637:  c = FC(row,col);",
          "5638:  if ((val = white[row][col] - cblack[c]) > 0)",
          "5639:    sum[c] += val;",
          "5640:  sum[c+4]++;",
          "5641:       }",
          "5642: #ifdef LIBRAW_LIBRARY_BUILD",
          "5643:     if(load_raw == &LibRaw::nikon_load_sraw)",
          "5644:       {",
          "5646:         pre_mul[0]=pre_mul[1]=pre_mul[2]=pre_mul[3]=1.0;",
          "5650:     if (sum[0] && sum[1] && sum[2] && sum[3])",
          "5651:       FORC4 pre_mul[c] = (float) sum[c+4] / sum[c];",
          "5653:       memcpy (pre_mul, cam_mul, sizeof pre_mul);",
          "5655:       {",
          "5657:             imgdata.process_warnings |= LIBRAW_WARN_BAD_CAMERA_WB;",
          "5660:             fprintf (stderr,_(\"%s: Cannot use camera white balance.\\n\"), ifname);",
          "5662:       }",
          "5666:   if (load_raw == &LibRaw::nikon_load_sraw",
          "5667:       && !use_camera_wb && !use_auto_wb",
          "5668:       && cam_mul[0] > 0.001f && cam_mul[1] > 0.001f && cam_mul[2] > 0.001f )",
          "5669:     {",
          "5670:       for(c=0;c<3;c++)",
          "5671:         pre_mul[c]/=cam_mul[c];",
          "5674:   if (pre_mul[1] == 0) pre_mul[1] = 1;",
          "5675:   if (pre_mul[3] == 0) pre_mul[3] = colors < 4 ? pre_mul[1] : 1;",
          "5678:   if (threshold) wavelet_denoise();",
          "5680:   for (dmin=DBL_MAX, dmax=c=0; c < 4; c++) {",
          "5682:  dmin = pre_mul[c];",
          "5684:  dmax = pre_mul[c];",
          "5686:   if (!highlight) dmax = dmin;",
          "5689:   if (verbose) {",
          "5690:     fprintf (stderr,",
          "5691:       _(\"Scaling with darkness %d, saturation %d, and\\nmultipliers\"), dark, sat);",
          "5692:     FORC4 fprintf (stderr, \" %f\", pre_mul[c]);",
          "5693:     fputc ('\\n', stderr);",
          "5696:   if (filters > 1000 && (cblack[4]+1)/2 == 1 && (cblack[5]+1)/2 == 1) {",
          "5697:     FORC4 cblack[FC(c/2,c%2)] +=",
          "5698:  cblack[6 + c/2 % cblack[4] * cblack[5] + c%2 % cblack[5]];",
          "5701:   size = iheight*iwidth;",
          "5705:   for (i=0; i < size*4; i++) {",
          "5706:     if (!(val = ((ushort *)image)[i])) continue;",
          "5708:       val -= cblack[6 + i/4 / iwidth % cblack[4] * cblack[5] +",
          "5709:    i/4 % iwidth % cblack[5]];",
          "5715:   if ((aber[0] != 1 || aber[2] != 1) && colors == 3) {",
          "5718:       fprintf (stderr,_(\"Correcting chromatic aberration...\\n\"));",
          "5719: #endif",
          "5720:     for (c=0; c < 4; c+=2) {",
          "5721:       if (aber[c] == 1) continue;",
          "5722:       img = (ushort *) malloc (size * sizeof *img);",
          "5723:       merror (img, \"scale_colors()\");",
          "5724:       for (i=0; i < size; i++)",
          "5725:  img[i] = image[i][c];",
          "5726:       for (row=0; row < iheight; row++) {",
          "5727:  ur = fr = (row - iheight*0.5) * aber[c] + iheight*0.5;",
          "5728:  if (ur > iheight-2) continue;",
          "5729:  fr -= ur;",
          "5730:  for (col=0; col < iwidth; col++) {",
          "5731:    uc = fc = (col - iwidth*0.5) * aber[c] + iwidth*0.5;",
          "5732:    if (uc > iwidth-2) continue;",
          "5733:    fc -= uc;",
          "5734:    pix = img + ur*iwidth + uc;",
          "5735:    image[row*iwidth+col][c] =",
          "5736:      (pix[     0]*(1-fc) + pix[       1]*fc) * (1-fr) +",
          "5737:      (pix[iwidth]*(1-fc) + pix[iwidth+1]*fc) * fr;",
          "5738:  }",
          "5744:   RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS,1,2);",
          "5750:   ushort (*img)[4];",
          "5753:   RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE,0,2);",
          "5755:   if (shrink) {",
          "5756:     if (half_size) {",
          "5758:       width  = iwidth;",
          "5759:       if (filters == 9) {",
          "5760:  for (row=0; row < 3; row++)",
          "5761:    for (col=1; col < 4; col++)",
          "5762:      if (!(image[row*width+col][0] | image[row*width+col][2]))",
          "5763:        goto break2;  break2:",
          "5764:  for ( ; row < height; row+=3)",
          "5765:    for (col=(col-1)%3+1; col < width-1; col+=3) {",
          "5766:      img = image + row*width+col;",
          "5767:      for (c=0; c < 3; c+=2)",
          "5768:        img[0][c] = (img[-1][c] + img[1][c]) >> 1;",
          "5769:    }",
          "5770:       }",
          "5771:     } else {",
          "5772:       img = (ushort (*)[4]) calloc (height, width*sizeof *img);",
          "5773:       merror (img, \"pre_interpolate()\");",
          "5774:       for (row=0; row < height; row++)",
          "5775:  for (col=0; col < width; col++) {",
          "5776:    c = fcol(row,col);",
          "5777:    img[row*width+col][c] = image[(row >> 1)*iwidth+(col >> 1)][c];",
          "5778:  }",
          "5779:       free (image);",
          "5784:   if (filters > 1000 && colors == 3) {",
          "5786:     if (four_color_rgb | half_size) colors++;",
          "5787:     else {",
          "5788:       for (row = FC(1,0) >> 1; row < height; row+=2)",
          "5789:  for (col = FC(row,1) & 1; col < width; col+=2)",
          "5790:    image[row*width+col][1] = image[row*width+col][3];",
          "5794:   if (half_size) filters = 0;",
          "5796:   RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE,1,2);",
          "5800: void CLASS border_interpolate (int border)",
          "5804:   for (row=0; row < height; row++)",
          "5805:     for (col=0; col < width; col++) {",
          "5806:       if (col==border && row >= border && row < height-border)",
          "5807:  col = width-border;",
          "5808:       memset (sum, 0, sizeof sum);",
          "5809:       for (y=row-1; y != row+2; y++)",
          "5810:  for (x=col-1; x != col+2; x++)",
          "5811:    if (y < height && x < width) {",
          "5812:      f = fcol(y,x);",
          "5813:      sum[f] += image[y*width+x][f];",
          "5814:      sum[f+4]++;",
          "5815:    }",
          "5816:       f = fcol(row,col);",
          "5817:       FORCC if (c != f && sum[c+4])",
          "5818:  image[row*width+col][c] = sum[c] / sum[c+4];",
          "5822: void CLASS lin_interpolate_loop(int code[16][16][32],int size)",
          "5825:   for (row=1; row < height-1; row++)",
          "5827:       int col,*ip;",
          "5828:       ushort *pix;",
          "5829:       for (col=1; col < width-1; col++) {",
          "5830:         int i;",
          "5831:         int sum[4];",
          "5832:         pix = image[row*width+col];",
          "5833:         ip = code[row % size][col % size];",
          "5834:         memset (sum, 0, sizeof sum);",
          "5835:         for (i=*ip++; i--; ip+=3)",
          "5836:           sum[ip[2]] += pix[ip[0]] << ip[1];",
          "5837:         for (i=colors; --i; ip+=2)",
          "5838:           pix[ip[0]] = sum[ip[0]] * ip[1] >> 8;",
          "5839:       }",
          "5845:   int code[16][16][32], size=16, *ip, sum[4];",
          "5850:   if (verbose) fprintf (stderr,_(\"Bilinear interpolation...\\n\"));",
          "5853:   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,0,3);",
          "5856:   if (filters == 9) size = 6;",
          "5858:   for (row=0; row < size; row++)",
          "5859:     for (col=0; col < size; col++) {",
          "5860:       ip = code[row][col]+1;",
          "5861:       f = fcol(row,col);",
          "5862:       memset (sum, 0, sizeof sum);",
          "5863:       for (y=-1; y <= 1; y++)",
          "5864:  for (x=-1; x <= 1; x++) {",
          "5865:    shift = (y==0) + (x==0);",
          "5866:    color = fcol(row+y,col+x);",
          "5867:    if (color == f) continue;",
          "5871:    sum[color] += 1 << shift;",
          "5872:  }",
          "5875:  if (c != f) {",
          "5878:  }",
          "5881:   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,1,3);",
          "5883:   lin_interpolate_loop(code,size);",
          "5885:   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,2,3);",
          "",
          "[Added Lines]",
          "6314:   ushort *img = 0, *pix;",
          "6317:   RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS, 0, 2);",
          "6321:     memcpy(pre_mul, user_mul, sizeof pre_mul);",
          "6322:   if (use_auto_wb || (use_camera_wb && cam_mul[0] == -1))",
          "6323:   {",
          "6324:     memset(dsum, 0, sizeof dsum);",
          "6325:     bottom = MIN(greybox[1] + greybox[3], height);",
          "6326:     right = MIN(greybox[0] + greybox[2], width);",
          "6327:     for (row = greybox[1]; row < bottom; row += 8)",
          "6328:       for (col = greybox[0]; col < right; col += 8)",
          "6329:       {",
          "6330:         memset(sum, 0, sizeof sum);",
          "6331:         for (y = row; y < row + 8 && y < bottom; y++)",
          "6332:           for (x = col; x < col + 8 && x < right; x++)",
          "6333:             FORC4",
          "6334:             {",
          "6335:               if (filters)",
          "6336:               {",
          "6337:                 c = fcol(y, x);",
          "6338:                 val = BAYER2(y, x);",
          "6339:               }",
          "6340:               else",
          "6341:                 val = image[y * width + x][c];",
          "6342:               if (val > maximum - 25)",
          "6343:                 goto skip_block;",
          "6344:               if ((val -= cblack[c]) < 0)",
          "6345:                 val = 0;",
          "6346:               sum[c] += val;",
          "6347:               sum[c + 4]++;",
          "6348:               if (filters)",
          "6349:                 break;",
          "6350:             }",
          "6351:         FORC(8) dsum[c] += sum[c];",
          "6352:       skip_block:;",
          "6353:       }",
          "6354:     FORC4 if (dsum[c]) pre_mul[c] = dsum[c + 4] / dsum[c];",
          "6355:   }",
          "6356:   if (use_camera_wb && cam_mul[0] != -1)",
          "6357:   {",
          "6358:     memset(sum, 0, sizeof sum);",
          "6359:     for (row = 0; row < 8; row++)",
          "6360:       for (col = 0; col < 8; col++)",
          "6361:       {",
          "6362:         c = FC(row, col);",
          "6363:         if ((val = white[row][col] - cblack[c]) > 0)",
          "6364:           sum[c] += val;",
          "6365:         sum[c + 4]++;",
          "6367: #ifdef LIBRAW_LIBRARY_BUILD",
          "6368:     if (load_raw == &LibRaw::nikon_load_sraw)",
          "6369:     {",
          "6371:       pre_mul[0] = pre_mul[1] = pre_mul[2] = pre_mul[3] = 1.0;",
          "6372:     }",
          "6375:         if (sum[0] && sum[1] && sum[2] && sum[3])",
          "6376:       FORC4 pre_mul[c] = (float)sum[c + 4] / sum[c];",
          "6378:       memcpy(pre_mul, cam_mul, sizeof pre_mul);",
          "6380:     {",
          "6382:       imgdata.process_warnings |= LIBRAW_WARN_BAD_CAMERA_WB;",
          "6385:       fprintf(stderr, _(\"%s: Cannot use camera white balance.\\n\"), ifname);",
          "6387:     }",
          "6391:   if (load_raw == &LibRaw::nikon_load_sraw && !use_camera_wb && !use_auto_wb && cam_mul[0] > 0.001f &&",
          "6392:       cam_mul[1] > 0.001f && cam_mul[2] > 0.001f)",
          "6393:   {",
          "6394:     for (c = 0; c < 3; c++)",
          "6395:       pre_mul[c] /= cam_mul[c];",
          "6398:   if (pre_mul[1] == 0)",
          "6399:     pre_mul[1] = 1;",
          "6400:   if (pre_mul[3] == 0)",
          "6401:     pre_mul[3] = colors < 4 ? pre_mul[1] : 1;",
          "6404:   if (threshold)",
          "6405:     wavelet_denoise();",
          "6407:   for (dmin = DBL_MAX, dmax = c = 0; c < 4; c++)",
          "6408:   {",
          "6410:       dmin = pre_mul[c];",
          "6412:       dmax = pre_mul[c];",
          "6414:   if (!highlight)",
          "6415:     dmax = dmin;",
          "6418:   if (verbose)",
          "6419:   {",
          "6420:     fprintf(stderr, _(\"Scaling with darkness %d, saturation %d, and\\nmultipliers\"), dark, sat);",
          "6421:     FORC4 fprintf(stderr, \" %f\", pre_mul[c]);",
          "6422:     fputc('\\n', stderr);",
          "6425:   if (filters > 1000 && (cblack[4] + 1) / 2 == 1 && (cblack[5] + 1) / 2 == 1)",
          "6426:   {",
          "6427:     FORC4 cblack[FC(c / 2, c % 2)] += cblack[6 + c / 2 % cblack[4] * cblack[5] + c % 2 % cblack[5]];",
          "6430:   size = iheight * iwidth;",
          "6434:   for (i = 0; i < size * 4; i++)",
          "6435:   {",
          "6436:     if (!(val = ((ushort *)image)[i]))",
          "6437:       continue;",
          "6439:       val -= cblack[6 + i / 4 / iwidth % cblack[4] * cblack[5] + i / 4 % iwidth % cblack[5]];",
          "6445:   if ((aber[0] != 1 || aber[2] != 1) && colors == 3)",
          "6446:   {",
          "6449:       fprintf(stderr, _(\"Correcting chromatic aberration...\\n\"));",
          "6450: #endif",
          "6451:     for (c = 0; c < 4; c += 2)",
          "6452:     {",
          "6453:       if (aber[c] == 1)",
          "6454:         continue;",
          "6455:       img = (ushort *)malloc(size * sizeof *img);",
          "6456:       merror(img, \"scale_colors()\");",
          "6457:       for (i = 0; i < size; i++)",
          "6458:         img[i] = image[i][c];",
          "6459:       for (row = 0; row < iheight; row++)",
          "6460:       {",
          "6461:         ur = fr = (row - iheight * 0.5) * aber[c] + iheight * 0.5;",
          "6462:         if (ur > iheight - 2)",
          "6463:           continue;",
          "6464:         fr -= ur;",
          "6465:         for (col = 0; col < iwidth; col++)",
          "6466:         {",
          "6467:           uc = fc = (col - iwidth * 0.5) * aber[c] + iwidth * 0.5;",
          "6468:           if (uc > iwidth - 2)",
          "6469:             continue;",
          "6470:           fc -= uc;",
          "6471:           pix = img + ur * iwidth + uc;",
          "6472:           image[row * iwidth + col][c] =",
          "6473:               (pix[0] * (1 - fc) + pix[1] * fc) * (1 - fr) + (pix[iwidth] * (1 - fc) + pix[iwidth + 1] * fc) * fr;",
          "6474:         }",
          "6480:   RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS, 1, 2);",
          "6486:   ushort(*img)[4];",
          "6489:   RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE, 0, 2);",
          "6491:   if (shrink)",
          "6492:   {",
          "6493:     if (half_size)",
          "6494:     {",
          "6496:       width = iwidth;",
          "6497:       if (filters == 9)",
          "6498:       {",
          "6499:         for (row = 0; row < 3; row++)",
          "6500:           for (col = 1; col < 4; col++)",
          "6501:             if (!(image[row * width + col][0] | image[row * width + col][2]))",
          "6502:               goto break2;",
          "6503:       break2:",
          "6504:         for (; row < height; row += 3)",
          "6505:           for (col = (col - 1) % 3 + 1; col < width - 1; col += 3)",
          "6506:           {",
          "6507:             img = image + row * width + col;",
          "6508:             for (c = 0; c < 3; c += 2)",
          "6509:               img[0][c] = (img[-1][c] + img[1][c]) >> 1;",
          "6510:           }",
          "6511:       }",
          "6512:     }",
          "6513:     else",
          "6514:     {",
          "6515:       img = (ushort(*)[4])calloc(height, width * sizeof *img);",
          "6516:       merror(img, \"pre_interpolate()\");",
          "6517:       for (row = 0; row < height; row++)",
          "6518:         for (col = 0; col < width; col++)",
          "6519:         {",
          "6520:           c = fcol(row, col);",
          "6521:           img[row * width + col][c] = image[(row >> 1) * iwidth + (col >> 1)][c];",
          "6522:         }",
          "6523:       free(image);",
          "6528:   if (filters > 1000 && colors == 3)",
          "6529:   {",
          "6531:     if (four_color_rgb | half_size)",
          "6532:       colors++;",
          "6533:     else",
          "6534:     {",
          "6535:       for (row = FC(1, 0) >> 1; row < height; row += 2)",
          "6536:         for (col = FC(row, 1) & 1; col < width; col += 2)",
          "6537:           image[row * width + col][1] = image[row * width + col][3];",
          "6541:   if (half_size)",
          "6542:     filters = 0;",
          "6544:   RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE, 1, 2);",
          "6548: void CLASS border_interpolate(int border)",
          "6552:   for (row = 0; row < height; row++)",
          "6553:     for (col = 0; col < width; col++)",
          "6554:     {",
          "6555:       if (col == border && row >= border && row < height - border)",
          "6556:         col = width - border;",
          "6557:       memset(sum, 0, sizeof sum);",
          "6558:       for (y = row - 1; y != row + 2; y++)",
          "6559:         for (x = col - 1; x != col + 2; x++)",
          "6560:           if (y < height && x < width)",
          "6561:           {",
          "6562:             f = fcol(y, x);",
          "6563:             sum[f] += image[y * width + x][f];",
          "6564:             sum[f + 4]++;",
          "6565:           }",
          "6566:       f = fcol(row, col);",
          "6567:       FORCC if (c != f && sum[c + 4]) image[row * width + col][c] = sum[c] / sum[c + 4];",
          "6571: void CLASS lin_interpolate_loop(int code[16][16][32], int size)",
          "6574:   for (row = 1; row < height - 1; row++)",
          "6575:   {",
          "6576:     int col, *ip;",
          "6577:     ushort *pix;",
          "6578:     for (col = 1; col < width - 1; col++)",
          "6580:       int i;",
          "6581:       int sum[4];",
          "6582:       pix = image[row * width + col];",
          "6583:       ip = code[row % size][col % size];",
          "6584:       memset(sum, 0, sizeof sum);",
          "6585:       for (i = *ip++; i--; ip += 3)",
          "6586:         sum[ip[2]] += pix[ip[0]] << ip[1];",
          "6587:       for (i = colors; --i; ip += 2)",
          "6588:         pix[ip[0]] = sum[ip[0]] * ip[1] >> 8;",
          "6590:   }",
          "6595:   int code[16][16][32], size = 16, *ip, sum[4];",
          "6599:   if (verbose)",
          "6600:     fprintf(stderr, _(\"Bilinear interpolation...\\n\"));",
          "6603:   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 0, 3);",
          "6606:   if (filters == 9)",
          "6607:     size = 6;",
          "6609:   for (row = 0; row < size; row++)",
          "6610:     for (col = 0; col < size; col++)",
          "6611:     {",
          "6612:       ip = code[row][col] + 1;",
          "6613:       f = fcol(row, col);",
          "6614:       memset(sum, 0, sizeof sum);",
          "6615:       for (y = -1; y <= 1; y++)",
          "6616:         for (x = -1; x <= 1; x++)",
          "6617:         {",
          "6618:           shift = (y == 0) + (x == 0);",
          "6619:           color = fcol(row + y, col + x);",
          "6620:           if (color == f)",
          "6621:             continue;",
          "6625:           sum[color] += 1 << shift;",
          "6626:         }",
          "6629:       if (c != f)",
          "6630:       {",
          "6633:       }",
          "6636:   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 1, 3);",
          "6638:   lin_interpolate_loop(code, size);",
          "6640:   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 2, 3);",
          "",
          "---------------",
          "--- Hunk 71 ---",
          "[Context before]",
          "5899: void CLASS vng_interpolate()",
          "5900: {",
          "5927:   int row, col, x, y, x1, x2, y1, y2, t, weight, grads, color, diag;",
          "5928:   int g, diff, thold, num, c;",
          "5930:   lin_interpolate();",
          "5931: #ifdef DCRAW_VERBOSE",
          "5933: #endif",
          "5941:       code[row][col] = ip;",
          "5957:       }",
          "5979:       ip = code[row % prow][col % pcol];",
          "5989:       }",
          "5990:       ip++;",
          "5995:       }",
          "5999:       }",
          "6000:       thold = gmin + (gmax >> 1);",
          "6029: }",
          "",
          "[Removed Lines]",
          "5901:   static const signed char *cp, terms[] = {",
          "5902:     -2,-2,+0,-1,0,0x01, -2,-2,+0,+0,1,0x01, -2,-1,-1,+0,0,0x01,",
          "5903:     -2,-1,+0,-1,0,0x02, -2,-1,+0,+0,0,0x03, -2,-1,+0,+1,1,0x01,",
          "5904:     -2,+0,+0,-1,0,0x06, -2,+0,+0,+0,1,0x02, -2,+0,+0,+1,0,0x03,",
          "5905:     -2,+1,-1,+0,0,0x04, -2,+1,+0,-1,1,0x04, -2,+1,+0,+0,0,0x06,",
          "5906:     -2,+1,+0,+1,0,0x02, -2,+2,+0,+0,1,0x04, -2,+2,+0,+1,0,0x04,",
          "5907:     -1,-2,-1,+0,0,-128, -1,-2,+0,-1,0,0x01, -1,-2,+1,-1,0,0x01,",
          "5908:     -1,-2,+1,+0,1,0x01, -1,-1,-1,+1,0,-120, -1,-1,+1,-2,0,0x40,",
          "5909:     -1,-1,+1,-1,0,0x22, -1,-1,+1,+0,0,0x33, -1,-1,+1,+1,1,0x11,",
          "5910:     -1,+0,-1,+2,0,0x08, -1,+0,+0,-1,0,0x44, -1,+0,+0,+1,0,0x11,",
          "5911:     -1,+0,+1,-2,1,0x40, -1,+0,+1,-1,0,0x66, -1,+0,+1,+0,1,0x22,",
          "5912:     -1,+0,+1,+1,0,0x33, -1,+0,+1,+2,1,0x10, -1,+1,+1,-1,1,0x44,",
          "5913:     -1,+1,+1,+0,0,0x66, -1,+1,+1,+1,0,0x22, -1,+1,+1,+2,0,0x10,",
          "5914:     -1,+2,+0,+1,0,0x04, -1,+2,+1,+0,1,0x04, -1,+2,+1,+1,0,0x04,",
          "5915:     +0,-2,+0,+0,1,-128, +0,-1,+0,+1,1,-120, +0,-1,+1,-2,0,0x40,",
          "5916:     +0,-1,+1,+0,0,0x11, +0,-1,+2,-2,0,0x40, +0,-1,+2,-1,0,0x20,",
          "5917:     +0,-1,+2,+0,0,0x30, +0,-1,+2,+1,1,0x10, +0,+0,+0,+2,1,0x08,",
          "5918:     +0,+0,+2,-2,1,0x40, +0,+0,+2,-1,0,0x60, +0,+0,+2,+0,1,0x20,",
          "5919:     +0,+0,+2,+1,0,0x30, +0,+0,+2,+2,1,0x10, +0,+1,+1,+0,0,0x44,",
          "5920:     +0,+1,+1,+2,0,0x10, +0,+1,+2,-1,1,0x40, +0,+1,+2,+0,0,0x60,",
          "5921:     +0,+1,+2,+1,0,0x20, +0,+1,+2,+2,0,0x10, +1,-2,+1,+0,0,-128,",
          "5922:     +1,-1,+1,+1,0,-120, +1,+0,+1,+2,0,0x08, +1,+0,+2,-1,0,0x40,",
          "5923:     +1,+0,+2,+1,0,0x10",
          "5924:   }, chood[] = { -1,-1, -1,0, -1,+1, 0,+1, +1,+1, +1,0, +1,-1, 0,-1 };",
          "5925:   ushort (*brow[5])[4], *pix;",
          "5926:   int prow=8, pcol=2, *ip, *code[16][16], gval[8], gmin, gmax, sum[4];",
          "5932:   if (verbose) fprintf (stderr,_(\"VNG interpolation...\\n\"));",
          "5935:   if (filters == 1) prow = pcol = 16;",
          "5936:   if (filters == 9) prow = pcol =  6;",
          "5937:   ip = (int *) calloc (prow*pcol, 1280);",
          "5938:   merror (ip, \"vng_interpolate()\");",
          "5940:     for (col=0; col < pcol; col++) {",
          "5942:       for (cp=terms, t=0; t < 64; t++) {",
          "5943:  y1 = *cp++;  x1 = *cp++;",
          "5944:  y2 = *cp++;  x2 = *cp++;",
          "5945:  weight = *cp++;",
          "5946:  grads = *cp++;",
          "5947:  color = fcol(row+y1,col+x1);",
          "5948:  if (fcol(row+y2,col+x2) != color) continue;",
          "5949:  diag = (fcol(row,col+1) == color && fcol(row+1,col) == color) ? 2:1;",
          "5950:  if (abs(y1-y2) == diag && abs(x1-x2) == diag) continue;",
          "5954:  for (g=0; g < 8; g++)",
          "5955:    if (grads & 1<<g) *ip++ = g;",
          "5959:       for (cp=chood, g=0; g < 8; g++) {",
          "5960:  y = *cp++;  x = *cp++;",
          "5962:  color = fcol(row,col);",
          "5963:  if (fcol(row+y,col+x) != color && fcol(row+y*2,col+x*2) == color)",
          "5965:  else",
          "5967:       }",
          "5968:     }",
          "5969:   brow[4] = (ushort (*)[4]) calloc (width*3, sizeof **brow);",
          "5970:   merror (brow[4], \"vng_interpolate()\");",
          "5971:   for (row=0; row < 3; row++)",
          "5972:     brow[row] = brow[4] + row*width;",
          "5974: #ifdef LIBRAW_LIBRARY_BUILD",
          "5975:       if(!((row-2)%256))RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,(row-2)/256+1,((height-3)/256)+1);",
          "5976: #endif",
          "5977:     for (col=2; col < width-2; col++) {",
          "5978:       pix = image[row*width+col];",
          "5980:       memset (gval, 0, sizeof gval);",
          "5982:  diff = ABS(pix[g] - pix[ip[1]]) << ip[2];",
          "5983:  gval[ip[3]] += diff;",
          "5984:  ip += 5;",
          "5985:  if ((g = ip[-1]) == -1) continue;",
          "5986:  gval[g] += diff;",
          "5987:  while ((g = *ip++) != -1)",
          "5988:    gval[g] += diff;",
          "5992:       for (g=1; g < 8; g++) {",
          "5993:  if (gmin > gval[g]) gmin = gval[g];",
          "5994:  if (gmax < gval[g]) gmax = gval[g];",
          "5996:       if (gmax == 0) {",
          "5997:  memcpy (brow[2][col], pix, sizeof *image);",
          "5998:  continue;",
          "6001:       memset (sum, 0, sizeof sum);",
          "6002:       color = fcol(row,col);",
          "6004:  if (gval[g] <= thold) {",
          "6005:    FORCC",
          "6006:      if (c == color && ip[1])",
          "6007:        sum[c] += (pix[c] + pix[ip[1]]) >> 1;",
          "6008:      else",
          "6009:        sum[c] += pix[ip[0] + c];",
          "6010:    num++;",
          "6011:  }",
          "6012:       }",
          "6014:  t = pix[color];",
          "6015:  if (c != color)",
          "6016:    t += (sum[c] - sum[color]) / num;",
          "6017:  brow[2][col][c] = CLIP(t);",
          "6018:       }",
          "6019:     }",
          "6021:       memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);",
          "6022:     for (g=0; g < 4; g++)",
          "6023:       brow[(g-1) & 3] = brow[g];",
          "6024:   }",
          "6025:   memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);",
          "6026:   memcpy (image[(row-1)*width+2], brow[1]+2, (width-4)*sizeof *image);",
          "6027:   free (brow[4]);",
          "6028:   free (code[0][0]);",
          "",
          "[Added Lines]",
          "6656:   static const signed char *cp,",
          "6657:       terms[] = {-2, -2, +0, -1, 0, 0x01, -2, -2, +0, +0, 1, 0x01, -2, -1, -1, +0, 0, 0x01, -2, -1, +0, -1, 0, 0x02,",
          "6658:                  -2, -1, +0, +0, 0, 0x03, -2, -1, +0, +1, 1, 0x01, -2, +0, +0, -1, 0, 0x06, -2, +0, +0, +0, 1, 0x02,",
          "6659:                  -2, +0, +0, +1, 0, 0x03, -2, +1, -1, +0, 0, 0x04, -2, +1, +0, -1, 1, 0x04, -2, +1, +0, +0, 0, 0x06,",
          "6660:                  -2, +1, +0, +1, 0, 0x02, -2, +2, +0, +0, 1, 0x04, -2, +2, +0, +1, 0, 0x04, -1, -2, -1, +0, 0, -128,",
          "6661:                  -1, -2, +0, -1, 0, 0x01, -1, -2, +1, -1, 0, 0x01, -1, -2, +1, +0, 1, 0x01, -1, -1, -1, +1, 0, -120,",
          "6662:                  -1, -1, +1, -2, 0, 0x40, -1, -1, +1, -1, 0, 0x22, -1, -1, +1, +0, 0, 0x33, -1, -1, +1, +1, 1, 0x11,",
          "6663:                  -1, +0, -1, +2, 0, 0x08, -1, +0, +0, -1, 0, 0x44, -1, +0, +0, +1, 0, 0x11, -1, +0, +1, -2, 1, 0x40,",
          "6664:                  -1, +0, +1, -1, 0, 0x66, -1, +0, +1, +0, 1, 0x22, -1, +0, +1, +1, 0, 0x33, -1, +0, +1, +2, 1, 0x10,",
          "6665:                  -1, +1, +1, -1, 1, 0x44, -1, +1, +1, +0, 0, 0x66, -1, +1, +1, +1, 0, 0x22, -1, +1, +1, +2, 0, 0x10,",
          "6666:                  -1, +2, +0, +1, 0, 0x04, -1, +2, +1, +0, 1, 0x04, -1, +2, +1, +1, 0, 0x04, +0, -2, +0, +0, 1, -128,",
          "6667:                  +0, -1, +0, +1, 1, -120, +0, -1, +1, -2, 0, 0x40, +0, -1, +1, +0, 0, 0x11, +0, -1, +2, -2, 0, 0x40,",
          "6668:                  +0, -1, +2, -1, 0, 0x20, +0, -1, +2, +0, 0, 0x30, +0, -1, +2, +1, 1, 0x10, +0, +0, +0, +2, 1, 0x08,",
          "6669:                  +0, +0, +2, -2, 1, 0x40, +0, +0, +2, -1, 0, 0x60, +0, +0, +2, +0, 1, 0x20, +0, +0, +2, +1, 0, 0x30,",
          "6670:                  +0, +0, +2, +2, 1, 0x10, +0, +1, +1, +0, 0, 0x44, +0, +1, +1, +2, 0, 0x10, +0, +1, +2, -1, 1, 0x40,",
          "6671:                  +0, +1, +2, +0, 0, 0x60, +0, +1, +2, +1, 0, 0x20, +0, +1, +2, +2, 0, 0x10, +1, -2, +1, +0, 0, -128,",
          "6672:                  +1, -1, +1, +1, 0, -120, +1, +0, +1, +2, 0, 0x08, +1, +0, +2, -1, 0, 0x40, +1, +0, +2, +1, 0, 0x10},",
          "6673:       chood[] = {-1, -1, -1, 0, -1, +1, 0, +1, +1, +1, +1, 0, +1, -1, 0, -1};",
          "6674:   ushort(*brow[5])[4], *pix;",
          "6675:   int prow = 8, pcol = 2, *ip, *code[16][16], gval[8], gmin, gmax, sum[4];",
          "6681:   if (verbose)",
          "6682:     fprintf(stderr, _(\"VNG interpolation...\\n\"));",
          "6685:   if (filters == 1)",
          "6686:     prow = pcol = 16;",
          "6687:   if (filters == 9)",
          "6688:     prow = pcol = 6;",
          "6689:   ip = (int *)calloc(prow * pcol, 1280);",
          "6690:   merror(ip, \"vng_interpolate()\");",
          "6692:     for (col = 0; col < pcol; col++)",
          "6693:     {",
          "6695:       for (cp = terms, t = 0; t < 64; t++)",
          "6696:       {",
          "6697:         y1 = *cp++;",
          "6698:         x1 = *cp++;",
          "6699:         y2 = *cp++;",
          "6700:         x2 = *cp++;",
          "6701:         weight = *cp++;",
          "6702:         grads = *cp++;",
          "6703:         color = fcol(row + y1, col + x1);",
          "6704:         if (fcol(row + y2, col + x2) != color)",
          "6705:           continue;",
          "6706:         diag = (fcol(row, col + 1) == color && fcol(row + 1, col) == color) ? 2 : 1;",
          "6707:         if (abs(y1 - y2) == diag && abs(x1 - x2) == diag)",
          "6708:           continue;",
          "6712:         for (g = 0; g < 8; g++)",
          "6713:           if (grads & 1 << g)",
          "6718:       for (cp = chood, g = 0; g < 8; g++)",
          "6719:       {",
          "6720:         y = *cp++;",
          "6721:         x = *cp++;",
          "6723:         color = fcol(row, col);",
          "6724:         if (fcol(row + y, col + x) != color && fcol(row + y * 2, col + x * 2) == color)",
          "6726:         else",
          "6728:       }",
          "6729:     }",
          "6730:   brow[4] = (ushort(*)[4])calloc(width * 3, sizeof **brow);",
          "6731:   merror(brow[4], \"vng_interpolate()\");",
          "6732:   for (row = 0; row < 3; row++)",
          "6733:     brow[row] = brow[4] + row * width;",
          "6734:   for (row = 2; row < height - 2; row++)",
          "6736: #ifdef LIBRAW_LIBRARY_BUILD",
          "6737:     if (!((row - 2) % 256))",
          "6738:       RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, (row - 2) / 256 + 1, ((height - 3) / 256) + 1);",
          "6739: #endif",
          "6740:     for (col = 2; col < width - 2; col++)",
          "6741:     {",
          "6742:       pix = image[row * width + col];",
          "6744:       memset(gval, 0, sizeof gval);",
          "6745:       while ((g = ip[0]) != INT_MAX)",
          "6747:         diff = ABS(pix[g] - pix[ip[1]]) << ip[2];",
          "6748:         gval[ip[3]] += diff;",
          "6749:         ip += 5;",
          "6750:         if ((g = ip[-1]) == -1)",
          "6751:           continue;",
          "6752:         gval[g] += diff;",
          "6753:         while ((g = *ip++) != -1)",
          "6754:           gval[g] += diff;",
          "6758:       for (g = 1; g < 8; g++)",
          "6759:       {",
          "6760:         if (gmin > gval[g])",
          "6761:           gmin = gval[g];",
          "6762:         if (gmax < gval[g])",
          "6763:           gmax = gval[g];",
          "6765:       if (gmax == 0)",
          "6766:       {",
          "6767:         memcpy(brow[2][col], pix, sizeof *image);",
          "6768:         continue;",
          "6771:       memset(sum, 0, sizeof sum);",
          "6772:       color = fcol(row, col);",
          "6773:       for (num = g = 0; g < 8; g++, ip += 2)",
          "6775:         if (gval[g] <= thold)",
          "6776:         {",
          "6777:           FORCC",
          "6778:           if (c == color && ip[1])",
          "6779:             sum[c] += (pix[c] + pix[ip[1]]) >> 1;",
          "6780:           else",
          "6781:             sum[c] += pix[ip[0] + c];",
          "6782:           num++;",
          "6783:         }",
          "6784:       }",
          "6785:       FORCC",
          "6787:         t = pix[color];",
          "6788:         if (c != color)",
          "6789:           t += (sum[c] - sum[color]) / num;",
          "6790:         brow[2][col][c] = CLIP(t);",
          "6791:       }",
          "6792:     }",
          "6794:       memcpy(image[(row - 2) * width + 2], brow[0] + 2, (width - 4) * sizeof *image);",
          "6795:     for (g = 0; g < 4; g++)",
          "6796:       brow[(g - 1) & 3] = brow[g];",
          "6797:   }",
          "6798:   memcpy(image[(row - 2) * width + 2], brow[0] + 2, (width - 4) * sizeof *image);",
          "6799:   memcpy(image[(row - 1) * width + 2], brow[1] + 2, (width - 4) * sizeof *image);",
          "6800:   free(brow[4]);",
          "6801:   free(code[0][0]);",
          "",
          "---------------",
          "--- Hunk 72 ---",
          "[Context before]",
          "6034: void CLASS ppg_interpolate()",
          "6035: {",
          "6037:   int row, col, diff[2], guess[2], c, d, i;",
          "6040:   border_interpolate(3);",
          "6041: #ifdef DCRAW_VERBOSE",
          "6043: #endif",
          "6046: #ifdef LIBRAW_LIBRARY_BUILD",
          "6048: #ifdef LIBRAW_USE_OPENMP",
          "6049: #pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)",
          "6050: #endif",
          "6051: #endif",
          "6063:       }",
          "6064:       d = dir[i = diff[0] > diff[1]];",
          "6065:       pix[0][1] = ULIM(guess[i] >> 2, pix[d][1], pix[-d][1]);",
          "6066:     }",
          "6068: #ifdef LIBRAW_LIBRARY_BUILD",
          "6070: #ifdef LIBRAW_USE_OPENMP",
          "6071: #pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)",
          "6072: #endif",
          "6073: #endif",
          "6080:     }",
          "6082: #ifdef LIBRAW_LIBRARY_BUILD",
          "6084: #ifdef LIBRAW_USE_OPENMP",
          "6085: #pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)",
          "6086: #endif",
          "6087: #endif",
          "6097:       }",
          "6098:       if (diff[0] != diff[1])",
          "6100:       else",
          "6102:     }",
          "6103: }",
          "6106: {",
          "6107:   int c, i, j, k;",
          "6108:   float r, xyz[3];",
          "",
          "[Removed Lines]",
          "6036:   int dir[5] = { 1, width, -1, -width, 1 };",
          "6038:   ushort (*pix)[4];",
          "6042:   if (verbose) fprintf (stderr,_(\"PPG interpolation...\\n\"));",
          "6047:   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,0,3);",
          "6052:   for (row=3; row < height-3; row++)",
          "6053:     for (col=3+(FC(row,3) & 1), c=FC(row,col); col < width-3; col+=2) {",
          "6054:       pix = image + row*width+col;",
          "6055:       for (i=0; (d=dir[i]) > 0; i++) {",
          "6056:  guess[i] = (pix[-d][1] + pix[0][c] + pix[d][1]) * 2",
          "6057:         - pix[-2*d][c] - pix[2*d][c];",
          "6058:  diff[i] = ( ABS(pix[-2*d][c] - pix[ 0][c]) +",
          "6059:       ABS(pix[ 2*d][c] - pix[ 0][c]) +",
          "6060:       ABS(pix[  -d][1] - pix[ d][1]) ) * 3 +",
          "6061:     ( ABS(pix[ 3*d][1] - pix[ d][1]) +",
          "6062:       ABS(pix[-3*d][1] - pix[-d][1]) ) * 2;",
          "6069:   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,1,3);",
          "6074:   for (row=1; row < height-1; row++)",
          "6075:     for (col=1+(FC(row,2) & 1), c=FC(row,col+1); col < width-1; col+=2) {",
          "6076:       pix = image + row*width+col;",
          "6077:       for (i=0; (d=dir[i]) > 0; c=2-c, i++)",
          "6078:  pix[0][c] = CLIP((pix[-d][c] + pix[d][c] + 2*pix[0][1]",
          "6079:    - pix[-d][1] - pix[d][1]) >> 1);",
          "6083:   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,2,3);",
          "6088:   for (row=1; row < height-1; row++)",
          "6089:     for (col=1+(FC(row,1) & 1), c=2-FC(row,col); col < width-1; col+=2) {",
          "6090:       pix = image + row*width+col;",
          "6091:       for (i=0; (d=dir[i]+dir[i+1]) > 0; i++) {",
          "6092:  diff[i] = ABS(pix[-d][c] - pix[d][c]) +",
          "6093:     ABS(pix[-d][1] - pix[0][1]) +",
          "6094:     ABS(pix[ d][1] - pix[0][1]);",
          "6095:  guess[i] = pix[-d][c] + pix[d][c] + 2*pix[0][1]",
          "6096:    - pix[-d][1] - pix[d][1];",
          "6099:  pix[0][c] = CLIP(guess[diff[0] > diff[1]] >> 1);",
          "6101:  pix[0][c] = CLIP((guess[0]+guess[1]) >> 2);",
          "6105: void CLASS cielab (ushort rgb[3], short lab[3])",
          "",
          "[Added Lines]",
          "6809:   int dir[5] = {1, width, -1, -width, 1};",
          "6811:   ushort(*pix)[4];",
          "6815:   if (verbose)",
          "6816:     fprintf(stderr, _(\"PPG interpolation...\\n\"));",
          "6821:   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 0, 3);",
          "6826:   for (row = 3; row < height - 3; row++)",
          "6827:     for (col = 3 + (FC(row, 3) & 1), c = FC(row, col); col < width - 3; col += 2)",
          "6828:     {",
          "6829:       pix = image + row * width + col;",
          "6830:       for (i = 0; (d = dir[i]) > 0; i++)",
          "6831:       {",
          "6832:         guess[i] = (pix[-d][1] + pix[0][c] + pix[d][1]) * 2 - pix[-2 * d][c] - pix[2 * d][c];",
          "6833:         diff[i] = (ABS(pix[-2 * d][c] - pix[0][c]) + ABS(pix[2 * d][c] - pix[0][c]) + ABS(pix[-d][1] - pix[d][1])) * 3 +",
          "6834:                   (ABS(pix[3 * d][1] - pix[d][1]) + ABS(pix[-3 * d][1] - pix[-d][1])) * 2;",
          "6841:   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 1, 3);",
          "6846:   for (row = 1; row < height - 1; row++)",
          "6847:     for (col = 1 + (FC(row, 2) & 1), c = FC(row, col + 1); col < width - 1; col += 2)",
          "6848:     {",
          "6849:       pix = image + row * width + col;",
          "6850:       for (i = 0; (d = dir[i]) > 0; c = 2 - c, i++)",
          "6851:         pix[0][c] = CLIP((pix[-d][c] + pix[d][c] + 2 * pix[0][1] - pix[-d][1] - pix[d][1]) >> 1);",
          "6855:   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 2, 3);",
          "6860:   for (row = 1; row < height - 1; row++)",
          "6861:     for (col = 1 + (FC(row, 1) & 1), c = 2 - FC(row, col); col < width - 1; col += 2)",
          "6862:     {",
          "6863:       pix = image + row * width + col;",
          "6864:       for (i = 0; (d = dir[i] + dir[i + 1]) > 0; i++)",
          "6865:       {",
          "6866:         diff[i] = ABS(pix[-d][c] - pix[d][c]) + ABS(pix[-d][1] - pix[0][1]) + ABS(pix[d][1] - pix[0][1]);",
          "6867:         guess[i] = pix[-d][c] + pix[d][c] + 2 * pix[0][1] - pix[-d][1] - pix[d][1];",
          "6870:         pix[0][c] = CLIP(guess[diff[0] > diff[1]] >> 1);",
          "6872:         pix[0][c] = CLIP((guess[0] + guess[1]) >> 2);",
          "6876: void CLASS cielab(ushort rgb[3], short lab[3])",
          "",
          "---------------",
          "--- Hunk 73 ---",
          "[Context before]",
          "6113: #define xyz_cam tls->ahd_data.xyz_cam",
          "6114: #endif",
          "6117: #ifndef LIBRAW_NOTHREADS",
          "6119: #endif",
          "6128:     return;",
          "6129:   }",
          "6130:   xyz[0] = xyz[1] = xyz[2] = 0.5;",
          "6132:     xyz[0] += xyz_cam[0][c] * rgb[c];",
          "6133:     xyz[1] += xyz_cam[1][c] * rgb[c];",
          "6134:     xyz[2] += xyz_cam[2][c] * rgb[c];",
          "6135:   }",
          "6139:   lab[0] = 64 * (116 * xyz[1] - 16);",
          "6140:   lab[1] = 64 * 500 * (xyz[0] - xyz[1]);",
          "6141:   lab[2] = 64 * 200 * (xyz[1] - xyz[2]);",
          "",
          "[Removed Lines]",
          "6116:   if (!rgb) {",
          "6118:     if(cbrt[0] < -1.0f)",
          "6120:     for (i=0; i < 0x10000; i++) {",
          "6121:       r = i / 65535.0;",
          "6122:       cbrt[i] = r > 0.008856 ? pow(r,1.f/3.0f) : 7.787f*r + 16.f/116.0f;",
          "6123:     }",
          "6124:     for (i=0; i < 3; i++)",
          "6125:       for (j=0; j < colors; j++)",
          "6126:  for (xyz_cam[i][j] = k=0; k < 3; k++)",
          "6127:    xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];",
          "6131:   FORCC {",
          "6136:   xyz[0] = cbrt[CLIP((int) xyz[0])];",
          "6137:   xyz[1] = cbrt[CLIP((int) xyz[1])];",
          "6138:   xyz[2] = cbrt[CLIP((int) xyz[2])];",
          "",
          "[Added Lines]",
          "6887:   if (!rgb)",
          "6888:   {",
          "6890:     if (cbrt[0] < -1.0f)",
          "6892:       for (i = 0; i < 0x10000; i++)",
          "6893:       {",
          "6894:         r = i / 65535.0;",
          "6895:         cbrt[i] = r > 0.008856 ? pow(r, 1.f / 3.0f) : 7.787f * r + 16.f / 116.0f;",
          "6896:       }",
          "6897:     for (i = 0; i < 3; i++)",
          "6898:       for (j = 0; j < colors; j++)",
          "6899:         for (xyz_cam[i][j] = k = 0; k < 3; k++)",
          "6900:           xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];",
          "6904:   FORCC",
          "6905:   {",
          "6910:   xyz[0] = cbrt[CLIP((int)xyz[0])];",
          "6911:   xyz[1] = cbrt[CLIP((int)xyz[1])];",
          "6912:   xyz[2] = cbrt[CLIP((int)xyz[2])];",
          "",
          "---------------",
          "--- Hunk 74 ---",
          "[Context before]",
          "6145: #endif",
          "6146: }",
          "6152:    Frank Markesteijn's algorithm for Fuji X-Trans sensors",
          "6155: {",
          "6156:   int c, d, f, g, h, i, v, ng, row, col, top, left, mrow, mcol;",
          "6157:   int val, ndir, pass, hm[8], avg[4], color[3][8];",
          "6162:   short allhex[3][3][2][8], *hex;",
          "6163:   ushort min, max, sgrow, sgcol;",
          "6169: #ifdef DCRAW_VERBOSE",
          "6170:   if (verbose)",
          "6172: #endif",
          "6175:   ndir = 4 << (passes > 1);",
          "6208:       }",
          "6209:       pix[0][1] = min;",
          "6210:       pix[0][3] = max;",
          "6321:       mrow -= top;",
          "6322:       mcol -= left;",
          "6377:     }",
          "6378:   free(buffer);",
          "6379:   border_interpolate(8);",
          "",
          "[Removed Lines]",
          "6149: #define fcol(row,col) xtrans[(row+6) % 6][(col+6) % 6]",
          "6154: void CLASS xtrans_interpolate (int passes)",
          "6158:   static const short orth[12] = { 1,0,0,1,-1,0,0,-1,1,0,0,1 },",
          "6159:  patt[2][16] = { { 0,1,0,-1,2,0,-1,0,1,1,1,-1,0,0,0,0 },",
          "6160:    { 0,1,0,-2,1,0,-2,0,1,1,-2,-2,1,-1,-1,1 } },",
          "6161:  dir[4] = { 1,TS,TS+1,TS-1 };",
          "6164:   ushort (*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];",
          "6165:    short (*lab)    [TS][3], (*lix)[3];",
          "6166:    float (*drv)[TS][TS], diff[6], tr;",
          "6167:    char (*homo)[TS][TS], *buffer;",
          "6171:     fprintf (stderr,_(\"%d-pass X-Trans interpolation...\\n\"), passes);",
          "6174:   cielab (0,0);",
          "6176:   buffer = (char *) malloc (TS*TS*(ndir*11+6));",
          "6177:   merror (buffer, \"xtrans_interpolate()\");",
          "6178:   rgb  = (ushort(*)[TS][TS][3]) buffer;",
          "6179:   lab  = (short (*)    [TS][3])(buffer + TS*TS*(ndir*6));",
          "6180:   drv  = (float (*)[TS][TS])   (buffer + TS*TS*(ndir*6+6));",
          "6181:   homo = (char  (*)[TS][TS])   (buffer + TS*TS*(ndir*10+6));",
          "6184:   for (row=0; row < 3; row++)",
          "6185:     for (col=0; col < 3; col++)",
          "6186:       for (ng=d=0; d < 10; d+=2) {",
          "6187:  g = fcol(row,col) == 1;",
          "6188:  if (fcol(row+orth[d],col+orth[d+2]) == 1) ng=0; else ng++;",
          "6189:  if (ng == 4) { sgrow = row; sgcol = col; }",
          "6190:  if (ng == g+1) FORC(8) {",
          "6191:    v = orth[d  ]*patt[g][c*2] + orth[d+1]*patt[g][c*2+1];",
          "6192:    h = orth[d+2]*patt[g][c*2] + orth[d+3]*patt[g][c*2+1];",
          "6193:    allhex[row][col][0][c^(g*2 & d)] = h + v*width;",
          "6194:    allhex[row][col][1][c^(g*2 & d)] = h + v*TS;",
          "6195:  }",
          "6196:       }",
          "6199:   for (row=2; row < height-2; row++)",
          "6200:     for (min=~(max=0), col=2; col < width-2; col++) {",
          "6201:       if (fcol(row,col) == 1 && (min=~(max=0))) continue;",
          "6202:       pix = image + row*width + col;",
          "6203:       hex = allhex[row % 3][col % 3][0];",
          "6204:       if (!max) FORC(6) {",
          "6205:  val = pix[hex[c]][1];",
          "6206:  if (min > val) min = val;",
          "6207:  if (max < val) max = val;",
          "6211:       switch ((row-sgrow) % 3) {",
          "6212:  case 1: if (row < height-3) { row++; col--; } break;",
          "6213:  case 2: if ((min=~(max=0)) && (col+=2) < width-3 && row > 2) row--;",
          "6214:       }",
          "6215:     }",
          "6217:   for (top=3; top < height-19; top += TS-16)",
          "6218:     for (left=3; left < width-19; left += TS-16) {",
          "6219:       mrow = MIN (top+TS, height-3);",
          "6220:       mcol = MIN (left+TS, width-3);",
          "6221:       for (row=top; row < mrow; row++)",
          "6222:  for (col=left; col < mcol; col++)",
          "6223:    memcpy (rgb[0][row-top][col-left], image[row*width+col], 6);",
          "6224:       FORC3 memcpy (rgb[c+1], rgb[0], sizeof *rgb);",
          "6227:       for (row=top; row < mrow; row++)",
          "6228:  for (col=left; col < mcol; col++) {",
          "6229:    if ((f = fcol(row,col)) == 1) continue;",
          "6230:    pix = image + row*width + col;",
          "6231:    hex = allhex[row % 3][col % 3][0];",
          "6232:    color[1][0] = 174 * (pix[  hex[1]][1] + pix[  hex[0]][1]) -",
          "6233:     46 * (pix[2*hex[1]][1] + pix[2*hex[0]][1]);",
          "6234:    color[1][1] = 223 *  pix[  hex[3]][1] + pix[  hex[2]][1] * 33 +",
          "6235:     92 * (pix[      0 ][f] - pix[ -hex[2]][f]);",
          "6236:    FORC(2) color[1][2+c] =",
          "6237:   164 * pix[hex[4+c]][1] + 92 * pix[-2*hex[4+c]][1] + 33 *",
          "6238:   (2*pix[0][f] - pix[3*hex[4+c]][f] - pix[-3*hex[4+c]][f]);",
          "6239:    FORC4 rgb[c^!((row-sgrow) % 3)][row-top][col-left][1] =",
          "6240:   LIM(color[1][c] >> 8,pix[0][1],pix[0][3]);",
          "6241:  }",
          "6243:       for (pass=0; pass < passes; pass++) {",
          "6244:  if (pass == 1)",
          "6245:    memcpy (rgb+=4, buffer, 4*sizeof *rgb);",
          "6248:  if (pass) {",
          "6249:    for (row=top+2; row < mrow-2; row++)",
          "6250:      for (col=left+2; col < mcol-2; col++) {",
          "6251:        if ((f = fcol(row,col)) == 1) continue;",
          "6252:        pix = image + row*width + col;",
          "6253:        hex = allhex[row % 3][col % 3][1];",
          "6254:        for (d=3; d < 6; d++) {",
          "6255:   rix = &rgb[(d-2)^!((row-sgrow) % 3)][row-top][col-left];",
          "6256:   val = rix[-2*hex[d]][1] + 2*rix[hex[d]][1]",
          "6257:       - rix[-2*hex[d]][f] - 2*rix[hex[d]][f] + 3*rix[0][f];",
          "6258:   rix[0][1] = LIM(val/3,pix[0][1],pix[0][3]);",
          "6259:        }",
          "6260:      }",
          "6261:  }",
          "6264:  for (row=(top-sgrow+4)/3*3+sgrow; row < mrow-2; row+=3)",
          "6265:    for (col=(left-sgcol+4)/3*3+sgcol; col < mcol-2; col+=3) {",
          "6266:      rix = &rgb[0][row-top][col-left];",
          "6267:      h = fcol(row,col+1);",
          "6268:      memset (diff, 0, sizeof diff);",
          "6269:      for (i=1, d=0; d < 6; d++, i^=TS^1, h^=2) {",
          "6270:        for (c=0; c < 2; c++, h^=2) {",
          "6271:   g = 2*rix[0][1] - rix[i<<c][1] - rix[-i<<c][1];",
          "6272:   color[h][d] = g + rix[i<<c][h] + rix[-i<<c][h];",
          "6273:   if (d > 1)",
          "6274:     diff[d] += SQR (rix[i<<c][1] - rix[-i<<c][1]",
          "6275:     - rix[i<<c][h] + rix[-i<<c][h]) + SQR(g);",
          "6276:        }",
          "6277:        if (d > 1 && (d & 1))",
          "6278:   if (diff[d-1] < diff[d])",
          "6279:     FORC(2) color[c*2][d] = color[c*2][d-1];",
          "6280:        if (d < 2 || (d & 1)) {",
          "6281:   FORC(2) rix[0][c*2] = CLIP(color[c*2][d]/2);",
          "6282:   rix += TS*TS;",
          "6283:        }",
          "6284:      }",
          "6285:    }",
          "6288:  for (row=top+3; row < mrow-3; row++)",
          "6289:    for (col=left+3; col < mcol-3; col++) {",
          "6290:      if ((f = 2-fcol(row,col)) == 1) continue;",
          "6291:      rix = &rgb[0][row-top][col-left];",
          "6292:      c = (row-sgrow) % 3 ? TS:1;",
          "6293:      h = 3 * (c ^ TS ^ 1);",
          "6294:      for (d=0; d < 4; d++, rix += TS*TS) {",
          "6295:        i = d > 1 || ((d ^ c) & 1) ||",
          "6296:    ((ABS(rix[0][1]-rix[c][1])+ABS(rix[0][1]-rix[-c][1])) <",
          "6297:   2*(ABS(rix[0][1]-rix[h][1])+ABS(rix[0][1]-rix[-h][1]))) ? c:h;",
          "6298:        rix[0][f] = CLIP((rix[i][f] + rix[-i][f] +",
          "6299:     2*rix[0][1] - rix[i][1] - rix[-i][1])/2);",
          "6300:      }",
          "6301:    }",
          "6304:  for (row=top+2; row < mrow-2; row++) if ((row-sgrow) % 3)",
          "6305:    for (col=left+2; col < mcol-2; col++) if ((col-sgcol) % 3) {",
          "6306:      rix = &rgb[0][row-top][col-left];",
          "6307:      hex = allhex[row % 3][col % 3][1];",
          "6308:      for (d=0; d < ndir; d+=2, rix += TS*TS)",
          "6309:        if (hex[d] + hex[d+1]) {",
          "6310:   g = 3*rix[0][1] - 2*rix[hex[d]][1] - rix[hex[d+1]][1];",
          "6311:   for (c=0; c < 4; c+=2) rix[0][c] =",
          "6312:    CLIP((g + 2*rix[hex[d]][c] + rix[hex[d+1]][c])/3);",
          "6313:        } else {",
          "6314:   g = 2*rix[0][1] - rix[hex[d]][1] - rix[hex[d+1]][1];",
          "6315:   for (c=0; c < 4; c+=2) rix[0][c] =",
          "6316:    CLIP((g + rix[hex[d]][c] + rix[hex[d+1]][c])/2);",
          "6317:        }",
          "6318:    }",
          "6319:       }",
          "6320:       rgb = (ushort(*)[TS][TS][3]) buffer;",
          "6325:       for (d=0; d < ndir; d++) {",
          "6326:  for (row=2; row < mrow-2; row++)",
          "6327:    for (col=2; col < mcol-2; col++)",
          "6328:      cielab (rgb[d][row][col], lab[row][col]);",
          "6329:  for (f=dir[d & 3],row=3; row < mrow-3; row++)",
          "6330:    for (col=3; col < mcol-3; col++) {",
          "6331:      lix = &lab[row][col];",
          "6332:      g = 2*lix[0][0] - lix[f][0] - lix[-f][0];",
          "6333:      drv[d][row][col] = SQR(g)",
          "6334:        + SQR((2*lix[0][1] - lix[f][1] - lix[-f][1] + g*500/232))",
          "6335:        + SQR((2*lix[0][2] - lix[f][2] - lix[-f][2] - g*500/580));",
          "6336:    }",
          "6337:       }",
          "6340:       memset(homo, 0, ndir*TS*TS);",
          "6341:       for (row=4; row < mrow-4; row++)",
          "6342:  for (col=4; col < mcol-4; col++) {",
          "6343:    for (tr=FLT_MAX, d=0; d < ndir; d++)",
          "6344:      if (tr > drv[d][row][col])",
          "6345:   tr = drv[d][row][col];",
          "6346:    tr *= 8;",
          "6347:    for (d=0; d < ndir; d++)",
          "6348:      for (v=-1; v <= 1; v++)",
          "6349:        for (h=-1; h <= 1; h++)",
          "6350:   if (drv[d][row+v][col+h] <= tr)",
          "6351:     homo[d][row][col]++;",
          "6352:  }",
          "6355:       if (height-top < TS+4) mrow = height-top+2;",
          "6356:       if (width-left < TS+4) mcol = width-left+2;",
          "6357:       for (row = MIN(top,8); row < mrow-8; row++)",
          "6358:  for (col = MIN(left,8); col < mcol-8; col++) {",
          "6359:    for (d=0; d < ndir; d++)",
          "6360:      for (hm[d]=0, v=-2; v <= 2; v++)",
          "6361:        for (h=-2; h <= 2; h++)",
          "6362:   hm[d] += homo[d][row+v][col+h];",
          "6363:    for (d=0; d < ndir-4; d++)",
          "6364:      if (hm[d] < hm[d+4]) hm[d  ] = 0; else",
          "6365:      if (hm[d] > hm[d+4]) hm[d+4] = 0;",
          "6366:    for (max=hm[0],d=1; d < ndir; d++)",
          "6367:      if (max < hm[d]) max = hm[d];",
          "6368:    max -= max >> 3;",
          "6369:    memset (avg, 0, sizeof avg);",
          "6370:    for (d=0; d < ndir; d++)",
          "6371:      if (hm[d] >= max) {",
          "6372:        FORC3 avg[c] += rgb[d][row][col][c];",
          "6373:        avg[3]++;",
          "6374:      }",
          "6375:    FORC3 image[(row+top)*width+col+left][c] = avg[c]/avg[3];",
          "6376:  }",
          "",
          "[Added Lines]",
          "6923: #define fcol(row, col) xtrans[(row + 6) % 6][(col + 6) % 6]",
          "6928: void CLASS xtrans_interpolate(int passes)",
          "6932:   static const short orth[12] = {1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1},",
          "6933:                      patt[2][16] = {{0, 1, 0, -1, 2, 0, -1, 0, 1, 1, 1, -1, 0, 0, 0, 0},",
          "6934:                                     {0, 1, 0, -2, 1, 0, -2, 0, 1, 1, -2, -2, 1, -1, -1, 1}},",
          "6935:                      dir[4] = {1, TS, TS + 1, TS - 1};",
          "6938:   ushort(*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];",
          "6939:   short(*lab)[TS][3], (*lix)[3];",
          "6940:   float(*drv)[TS][TS], diff[6], tr;",
          "6941:   char(*homo)[TS][TS], *buffer;",
          "6945:     fprintf(stderr, _(\"%d-pass X-Trans interpolation...\\n\"), passes);",
          "6948:   cielab(0, 0);",
          "6950:   buffer = (char *)malloc(TS * TS * (ndir * 11 + 6));",
          "6951:   merror(buffer, \"xtrans_interpolate()\");",
          "6952:   rgb = (ushort(*)[TS][TS][3])buffer;",
          "6953:   lab = (short(*)[TS][3])(buffer + TS * TS * (ndir * 6));",
          "6954:   drv = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 6 + 6));",
          "6955:   homo = (char(*)[TS][TS])(buffer + TS * TS * (ndir * 10 + 6));",
          "6958:   for (row = 0; row < 3; row++)",
          "6959:     for (col = 0; col < 3; col++)",
          "6960:       for (ng = d = 0; d < 10; d += 2)",
          "6961:       {",
          "6962:         g = fcol(row, col) == 1;",
          "6963:         if (fcol(row + orth[d], col + orth[d + 2]) == 1)",
          "6964:           ng = 0;",
          "6965:         else",
          "6966:           ng++;",
          "6967:         if (ng == 4)",
          "6968:         {",
          "6969:           sgrow = row;",
          "6970:           sgcol = col;",
          "6971:         }",
          "6972:         if (ng == g + 1)",
          "6973:           FORC(8)",
          "6974:           {",
          "6975:             v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];",
          "6976:             h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];",
          "6977:             allhex[row][col][0][c ^ (g * 2 & d)] = h + v * width;",
          "6978:             allhex[row][col][1][c ^ (g * 2 & d)] = h + v * TS;",
          "6979:           }",
          "6983:   for (row = 2; row < height - 2; row++)",
          "6984:     for (min = ~(max = 0), col = 2; col < width - 2; col++)",
          "6985:     {",
          "6986:       if (fcol(row, col) == 1 && (min = ~(max = 0)))",
          "6987:         continue;",
          "6988:       pix = image + row * width + col;",
          "6989:       hex = allhex[row % 3][col % 3][0];",
          "6990:       if (!max)",
          "6991:         FORC(6)",
          "6992:         {",
          "6993:           val = pix[hex[c]][1];",
          "6994:           if (min > val)",
          "6995:             min = val;",
          "6996:           if (max < val)",
          "6997:             max = val;",
          "6998:         }",
          "7001:       switch ((row - sgrow) % 3)",
          "7002:       {",
          "7003:       case 1:",
          "7004:         if (row < height - 3)",
          "7005:         {",
          "7006:           row++;",
          "7007:           col--;",
          "7008:         }",
          "7009:         break;",
          "7010:       case 2:",
          "7011:         if ((min = ~(max = 0)) && (col += 2) < width - 3 && row > 2)",
          "7012:           row--;",
          "7013:       }",
          "7014:     }",
          "7016:   for (top = 3; top < height - 19; top += TS - 16)",
          "7017:     for (left = 3; left < width - 19; left += TS - 16)",
          "7018:     {",
          "7019:       mrow = MIN(top + TS, height - 3);",
          "7020:       mcol = MIN(left + TS, width - 3);",
          "7021:       for (row = top; row < mrow; row++)",
          "7022:         for (col = left; col < mcol; col++)",
          "7023:           memcpy(rgb[0][row - top][col - left], image[row * width + col], 6);",
          "7024:       FORC3 memcpy(rgb[c + 1], rgb[0], sizeof *rgb);",
          "7027:       for (row = top; row < mrow; row++)",
          "7028:         for (col = left; col < mcol; col++)",
          "7029:         {",
          "7030:           if ((f = fcol(row, col)) == 1)",
          "7031:             continue;",
          "7032:           pix = image + row * width + col;",
          "7033:           hex = allhex[row % 3][col % 3][0];",
          "7034:           color[1][0] = 174 * (pix[hex[1]][1] + pix[hex[0]][1]) - 46 * (pix[2 * hex[1]][1] + pix[2 * hex[0]][1]);",
          "7035:           color[1][1] = 223 * pix[hex[3]][1] + pix[hex[2]][1] * 33 + 92 * (pix[0][f] - pix[-hex[2]][f]);",
          "7036:           FORC(2)",
          "7037:           color[1][2 + c] = 164 * pix[hex[4 + c]][1] + 92 * pix[-2 * hex[4 + c]][1] +",
          "7038:                             33 * (2 * pix[0][f] - pix[3 * hex[4 + c]][f] - pix[-3 * hex[4 + c]][f]);",
          "7039:           FORC4 rgb[c ^ !((row - sgrow) % 3)][row - top][col - left][1] = LIM(color[1][c] >> 8, pix[0][1], pix[0][3]);",
          "7040:         }",
          "7042:       for (pass = 0; pass < passes; pass++)",
          "7043:       {",
          "7044:         if (pass == 1)",
          "7045:           memcpy(rgb += 4, buffer, 4 * sizeof *rgb);",
          "7048:         if (pass)",
          "7049:         {",
          "7050:           for (row = top + 2; row < mrow - 2; row++)",
          "7051:             for (col = left + 2; col < mcol - 2; col++)",
          "7052:             {",
          "7053:               if ((f = fcol(row, col)) == 1)",
          "7054:                 continue;",
          "7055:               pix = image + row * width + col;",
          "7056:               hex = allhex[row % 3][col % 3][1];",
          "7057:               for (d = 3; d < 6; d++)",
          "7058:               {",
          "7059:                 rix = &rgb[(d - 2) ^ !((row - sgrow) % 3)][row - top][col - left];",
          "7060:                 val =",
          "7061:                     rix[-2 * hex[d]][1] + 2 * rix[hex[d]][1] - rix[-2 * hex[d]][f] - 2 * rix[hex[d]][f] + 3 * rix[0][f];",
          "7062:                 rix[0][1] = LIM(val / 3, pix[0][1], pix[0][3]);",
          "7063:               }",
          "7064:             }",
          "7065:         }",
          "7068:         for (row = (top - sgrow + 4) / 3 * 3 + sgrow; row < mrow - 2; row += 3)",
          "7069:           for (col = (left - sgcol + 4) / 3 * 3 + sgcol; col < mcol - 2; col += 3)",
          "7070:           {",
          "7071:             rix = &rgb[0][row - top][col - left];",
          "7072:             h = fcol(row, col + 1);",
          "7073:             memset(diff, 0, sizeof diff);",
          "7074:             for (i = 1, d = 0; d < 6; d++, i ^= TS ^ 1, h ^= 2)",
          "7075:             {",
          "7076:               for (c = 0; c < 2; c++, h ^= 2)",
          "7077:               {",
          "7078:                 g = 2 * rix[0][1] - rix[i << c][1] - rix[-i << c][1];",
          "7079:                 color[h][d] = g + rix[i << c][h] + rix[-i << c][h];",
          "7080:                 if (d > 1)",
          "7081:                   diff[d] += SQR(rix[i << c][1] - rix[-i << c][1] - rix[i << c][h] + rix[-i << c][h]) + SQR(g);",
          "7082:               }",
          "7083:               if (d > 1 && (d & 1))",
          "7084:                 if (diff[d - 1] < diff[d])",
          "7085:                   FORC(2) color[c * 2][d] = color[c * 2][d - 1];",
          "7086:               if (d < 2 || (d & 1))",
          "7087:               {",
          "7088:                 FORC(2) rix[0][c * 2] = CLIP(color[c * 2][d] / 2);",
          "7089:                 rix += TS * TS;",
          "7090:               }",
          "7091:             }",
          "7092:           }",
          "7095:         for (row = top + 3; row < mrow - 3; row++)",
          "7096:           for (col = left + 3; col < mcol - 3; col++)",
          "7097:           {",
          "7098:             if ((f = 2 - fcol(row, col)) == 1)",
          "7099:               continue;",
          "7100:             rix = &rgb[0][row - top][col - left];",
          "7101:             c = (row - sgrow) % 3 ? TS : 1;",
          "7102:             h = 3 * (c ^ TS ^ 1);",
          "7103:             for (d = 0; d < 4; d++, rix += TS * TS)",
          "7104:             {",
          "7105:               i = d > 1 || ((d ^ c) & 1) || ((ABS(rix[0][1] - rix[c][1]) + ABS(rix[0][1] - rix[-c][1])) <",
          "7106:                                              2 * (ABS(rix[0][1] - rix[h][1]) + ABS(rix[0][1] - rix[-h][1])))",
          "7107:                       ? c",
          "7108:                       : h;",
          "7109:               rix[0][f] = CLIP((rix[i][f] + rix[-i][f] + 2 * rix[0][1] - rix[i][1] - rix[-i][1]) / 2);",
          "7110:             }",
          "7111:           }",
          "7114:         for (row = top + 2; row < mrow - 2; row++)",
          "7115:           if ((row - sgrow) % 3)",
          "7116:             for (col = left + 2; col < mcol - 2; col++)",
          "7117:               if ((col - sgcol) % 3)",
          "7118:               {",
          "7119:                 rix = &rgb[0][row - top][col - left];",
          "7120:                 hex = allhex[row % 3][col % 3][1];",
          "7121:                 for (d = 0; d < ndir; d += 2, rix += TS * TS)",
          "7122:                   if (hex[d] + hex[d + 1])",
          "7123:                   {",
          "7124:                     g = 3 * rix[0][1] - 2 * rix[hex[d]][1] - rix[hex[d + 1]][1];",
          "7125:                     for (c = 0; c < 4; c += 2)",
          "7126:                       rix[0][c] = CLIP((g + 2 * rix[hex[d]][c] + rix[hex[d + 1]][c]) / 3);",
          "7127:                   }",
          "7128:                   else",
          "7129:                   {",
          "7130:                     g = 2 * rix[0][1] - rix[hex[d]][1] - rix[hex[d + 1]][1];",
          "7131:                     for (c = 0; c < 4; c += 2)",
          "7132:                       rix[0][c] = CLIP((g + rix[hex[d]][c] + rix[hex[d + 1]][c]) / 2);",
          "7133:                   }",
          "7134:               }",
          "7135:       }",
          "7136:       rgb = (ushort(*)[TS][TS][3])buffer;",
          "7141:       for (d = 0; d < ndir; d++)",
          "7142:       {",
          "7143:         for (row = 2; row < mrow - 2; row++)",
          "7144:           for (col = 2; col < mcol - 2; col++)",
          "7145:             cielab(rgb[d][row][col], lab[row][col]);",
          "7146:         for (f = dir[d & 3], row = 3; row < mrow - 3; row++)",
          "7147:           for (col = 3; col < mcol - 3; col++)",
          "7148:           {",
          "7149:             lix = &lab[row][col];",
          "7150:             g = 2 * lix[0][0] - lix[f][0] - lix[-f][0];",
          "7151:             drv[d][row][col] = SQR(g) + SQR((2 * lix[0][1] - lix[f][1] - lix[-f][1] + g * 500 / 232)) +",
          "7152:                                SQR((2 * lix[0][2] - lix[f][2] - lix[-f][2] - g * 500 / 580));",
          "7153:           }",
          "7154:       }",
          "7157:       memset(homo, 0, ndir * TS * TS);",
          "7158:       for (row = 4; row < mrow - 4; row++)",
          "7159:         for (col = 4; col < mcol - 4; col++)",
          "7160:         {",
          "7161:           for (tr = FLT_MAX, d = 0; d < ndir; d++)",
          "7162:             if (tr > drv[d][row][col])",
          "7163:               tr = drv[d][row][col];",
          "7164:           tr *= 8;",
          "7165:           for (d = 0; d < ndir; d++)",
          "7166:             for (v = -1; v <= 1; v++)",
          "7167:               for (h = -1; h <= 1; h++)",
          "7168:                 if (drv[d][row + v][col + h] <= tr)",
          "7169:                   homo[d][row][col]++;",
          "7170:         }",
          "7173:       if (height - top < TS + 4)",
          "7174:         mrow = height - top + 2;",
          "7175:       if (width - left < TS + 4)",
          "7176:         mcol = width - left + 2;",
          "7177:       for (row = MIN(top, 8); row < mrow - 8; row++)",
          "7178:         for (col = MIN(left, 8); col < mcol - 8; col++)",
          "7179:         {",
          "7180:           for (d = 0; d < ndir; d++)",
          "7181:             for (hm[d] = 0, v = -2; v <= 2; v++)",
          "7182:               for (h = -2; h <= 2; h++)",
          "7183:                 hm[d] += homo[d][row + v][col + h];",
          "7184:           for (d = 0; d < ndir - 4; d++)",
          "7185:             if (hm[d] < hm[d + 4])",
          "7186:               hm[d] = 0;",
          "7187:             else if (hm[d] > hm[d + 4])",
          "7188:               hm[d + 4] = 0;",
          "7189:           for (max = hm[0], d = 1; d < ndir; d++)",
          "7190:             if (max < hm[d])",
          "7191:               max = hm[d];",
          "7192:           max -= max >> 3;",
          "7193:           memset(avg, 0, sizeof avg);",
          "7194:           for (d = 0; d < ndir; d++)",
          "7195:             if (hm[d] >= max)",
          "7196:             {",
          "7197:               FORC3 avg[c] += rgb[d][row][col][c];",
          "7198:               avg[3]++;",
          "7199:             }",
          "7200:           FORC3 image[(row + top) * width + col + left][c] = avg[c] / avg[3];",
          "7201:         }",
          "",
          "---------------",
          "--- Hunk 75 ---",
          "[Context before]",
          "6390: {",
          "6391:   int row, col;",
          "6392:   int c, val;",
          "6407:     }",
          "6408:   }",
          "6409: }",
          "6411: {",
          "6412:   unsigned row, col;",
          "6413:   int c, val;",
          "6417:   float xyz[3];",
          "6421:   ushort *pix_above;",
          "6422:   ushort *pix_below;",
          "6423:   int t1, t2;",
          "6431:       pix++;",
          "6432:       pix_above = &pix[0][0] - num_pix_per_row;",
          "6433:       pix_below = &pix[0][0] + num_pix_per_row;",
          "",
          "[Removed Lines]",
          "6393:   ushort (*pix)[4];",
          "6394:   const int rowlimit = MIN(top+TS, height-2);",
          "6395:   const int collimit = MIN(left+TS, width-2);",
          "6397:   for (row = top; row < rowlimit; row++) {",
          "6398:     col = left + (FC(row,left) & 1);",
          "6399:     for (c = FC(row,col); col < collimit; col+=2) {",
          "6400:       pix = image + row*width+col;",
          "6401:       val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2",
          "6402:             - pix[-2][c] - pix[2][c]) >> 2;",
          "6403:       out_rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);",
          "6404:       val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2",
          "6405:             - pix[-2*width][c] - pix[2*width][c]) >> 2;",
          "6406:       out_rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);",
          "6410: void CLASS ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][3], short (*out_lab)[TS][3])",
          "6414:   ushort (*pix)[4];",
          "6415:   ushort (*rix)[3];",
          "6416:   short (*lix)[3];",
          "6418:   const unsigned num_pix_per_row = 4*width;",
          "6419:   const unsigned rowlimit = MIN(top+TS-1, height-3);",
          "6420:   const unsigned collimit = MIN(left+TS-1, width-3);",
          "6425:   for (row = top+1; row < rowlimit; row++) {",
          "6426:     pix = image + row*width + left;",
          "6427:     rix = &inout_rgb[row-top][0];",
          "6428:     lix = &out_lab[row-top][0];",
          "6430:     for (col = left+1; col < collimit; col++) {",
          "",
          "[Added Lines]",
          "7218:   ushort(*pix)[4];",
          "7219:   const int rowlimit = MIN(top + TS, height - 2);",
          "7220:   const int collimit = MIN(left + TS, width - 2);",
          "7222:   for (row = top; row < rowlimit; row++)",
          "7223:   {",
          "7224:     col = left + (FC(row, left) & 1);",
          "7225:     for (c = FC(row, col); col < collimit; col += 2)",
          "7226:     {",
          "7227:       pix = image + row * width + col;",
          "7228:       val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2 - pix[-2][c] - pix[2][c]) >> 2;",
          "7229:       out_rgb[0][row - top][col - left][1] = ULIM(val, pix[-1][1], pix[1][1]);",
          "7230:       val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2 - pix[-2 * width][c] - pix[2 * width][c]) >> 2;",
          "7231:       out_rgb[1][row - top][col - left][1] = ULIM(val, pix[-width][1], pix[width][1]);",
          "7235: void CLASS ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][3],",
          "7236:                                                                 short (*out_lab)[TS][3])",
          "7240:   ushort(*pix)[4];",
          "7241:   ushort(*rix)[3];",
          "7242:   short(*lix)[3];",
          "7244:   const unsigned num_pix_per_row = 4 * width;",
          "7245:   const unsigned rowlimit = MIN(top + TS - 1, height - 3);",
          "7246:   const unsigned collimit = MIN(left + TS - 1, width - 3);",
          "7251:   for (row = top + 1; row < rowlimit; row++)",
          "7252:   {",
          "7253:     pix = image + row * width + left;",
          "7254:     rix = &inout_rgb[row - top][0];",
          "7255:     lix = &out_lab[row - top][0];",
          "7257:     for (col = left + 1; col < collimit; col++)",
          "7258:     {",
          "",
          "---------------",
          "--- Hunk 76 ---",
          "[Context before]",
          "6437:       c = 2 - FC(row, col);",
          "6444:         rix[0][t1] = CLIP(val);",
          "6454:       }",
          "6455:       rix[0][c] = CLIP(val);",
          "6457:       rix[0][c] = pix[0][c];",
          "6459:     }",
          "6460:   }",
          "6461: }",
          "6463: {",
          "6464:   int direction;",
          "6466:     ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(top, left, inout_rgb[direction], out_lab[direction]);",
          "6467:   }",
          "6468: }",
          "6471: {",
          "6472:   int row, col;",
          "6473:   int tr, tc;",
          "6474:   int direction;",
          "6475:   int i;",
          "6478:   short *adjacent_lix;",
          "6479:   unsigned ldiff[2][4], abdiff[2][4], leps, abeps;",
          "6483:   int homogeneity;",
          "6490:     homogeneity_map_p = &out_homogeneity_map[tr][1];",
          "6492:       lixs[direction] = &lab[direction][tr][1];",
          "6493:     }",
          "6497:       homogeneity_map_p++;",
          "6500:         lix = ++lixs[direction];",
          "6506:         }",
          "6507:       }",
          "6520:       }",
          "6521:     }",
          "6522:   }",
          "6523: }",
          "6525: {",
          "6526:   int row, col;",
          "6527:   int tr, tc;",
          "",
          "[Removed Lines]",
          "6439:       if (c == 1) {",
          "6440:         c = FC(row+1,col);",
          "6441:  t1 = 2-c;",
          "6442:         val = pix[0][1] + (( pix[-1][t1] + pix[1][t1]",
          "6443:               - rix[-1][1] - rix[1][1] ) >> 1);",
          "6445:         val = pix[0][1] + (( pix_above[c] + pix_below[c]",
          "6446:               - rix[-TS][1] - rix[TS][1] ) >> 1);",
          "6447:       } else {",
          "6450:         val = rix[0][1] + (( pix_above[t1] + pix_above[t2]",
          "6451:               + pix_below[t1] + pix_below[t2]",
          "6452:               - rix[-TS-1][1] - rix[-TS+1][1]",
          "6453:               - rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);",
          "6456:       c = FC(row,col);",
          "6458:       cielab(rix[0],lix[0]);",
          "6462: void CLASS ahd_interpolate_r_and_b_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][TS][3], short (*out_lab)[TS][TS][3])",
          "6465:   for (direction = 0; direction < 2; direction++) {",
          "6470: void CLASS ahd_interpolate_build_homogeneity_map(int top, int left, short (*lab)[TS][TS][3], char (*out_homogeneity_map)[TS][2])",
          "6476:   short (*lix)[3];",
          "6477:   short (*lixs[2])[3];",
          "6480:   static const int dir[4] = { -1, 1, -TS, TS };",
          "6481:   const int rowlimit = MIN(top+TS-2, height-4);",
          "6482:   const int collimit = MIN(left+TS-2, width-4);",
          "6484:   char (*homogeneity_map_p)[2];",
          "6486:   memset (out_homogeneity_map, 0, 2*TS*TS);",
          "6488:   for (row=top+2; row < rowlimit; row++) {",
          "6489:     tr = row-top;",
          "6491:     for (direction=0; direction < 2; direction++) {",
          "6495:     for (col=left+2; col < collimit; col++) {",
          "6496:       tc = col-left;",
          "6499:       for (direction=0; direction < 2; direction++) {",
          "6501:         for (i=0; i < 4; i++) {",
          "6502:    adjacent_lix = lix[dir[i]];",
          "6503:           ldiff[direction][i] = ABS(lix[0][0]-adjacent_lix[0]);",
          "6504:           abdiff[direction][i] = SQR(lix[0][1]-adjacent_lix[1])",
          "6505:             + SQR(lix[0][2]-adjacent_lix[2]);",
          "6508:       leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),",
          "6509:           MAX(ldiff[1][2],ldiff[1][3]));",
          "6510:       abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),",
          "6511:           MAX(abdiff[1][2],abdiff[1][3]));",
          "6512:       for (direction=0; direction < 2; direction++) {",
          "6513:  homogeneity = 0;",
          "6514:         for (i=0; i < 4; i++) {",
          "6515:           if (ldiff[direction][i] <= leps && abdiff[direction][i] <= abeps) {",
          "6516:      homogeneity++;",
          "6517:    }",
          "6518:  }",
          "6519:  homogeneity_map_p[0][direction] = homogeneity;",
          "6524: void CLASS ahd_interpolate_combine_homogeneous_pixels(int top, int left, ushort (*rgb)[TS][TS][3], char (*homogeneity_map)[TS][2])",
          "",
          "[Added Lines]",
          "7267:       if (c == 1)",
          "7268:       {",
          "7269:         c = FC(row + 1, col);",
          "7270:         t1 = 2 - c;",
          "7271:         val = pix[0][1] + ((pix[-1][t1] + pix[1][t1] - rix[-1][1] - rix[1][1]) >> 1);",
          "7273:         val = pix[0][1] + ((pix_above[c] + pix_below[c] - rix[-TS][1] - rix[TS][1]) >> 1);",
          "7274:       }",
          "7275:       else",
          "7276:       {",
          "7279:         val = rix[0][1] + ((pix_above[t1] + pix_above[t2] + pix_below[t1] + pix_below[t2] - rix[-TS - 1][1] -",
          "7280:                             rix[-TS + 1][1] - rix[+TS - 1][1] - rix[+TS + 1][1] + 1) >>",
          "7281:                            2);",
          "7284:       c = FC(row, col);",
          "7286:       cielab(rix[0], lix[0]);",
          "7290: void CLASS ahd_interpolate_r_and_b_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][TS][3],",
          "7291:                                                          short (*out_lab)[TS][TS][3])",
          "7294:   for (direction = 0; direction < 2; direction++)",
          "7295:   {",
          "7300: void CLASS ahd_interpolate_build_homogeneity_map(int top, int left, short (*lab)[TS][TS][3],",
          "7301:                                                  char (*out_homogeneity_map)[TS][2])",
          "7307:   short(*lix)[3];",
          "7308:   short(*lixs[2])[3];",
          "7311:   static const int dir[4] = {-1, 1, -TS, TS};",
          "7312:   const int rowlimit = MIN(top + TS - 2, height - 4);",
          "7313:   const int collimit = MIN(left + TS - 2, width - 4);",
          "7315:   char(*homogeneity_map_p)[2];",
          "7317:   memset(out_homogeneity_map, 0, 2 * TS * TS);",
          "7319:   for (row = top + 2; row < rowlimit; row++)",
          "7320:   {",
          "7321:     tr = row - top;",
          "7323:     for (direction = 0; direction < 2; direction++)",
          "7324:     {",
          "7328:     for (col = left + 2; col < collimit; col++)",
          "7329:     {",
          "7330:       tc = col - left;",
          "7333:       for (direction = 0; direction < 2; direction++)",
          "7334:       {",
          "7336:         for (i = 0; i < 4; i++)",
          "7337:         {",
          "7338:           adjacent_lix = lix[dir[i]];",
          "7339:           ldiff[direction][i] = ABS(lix[0][0] - adjacent_lix[0]);",
          "7340:           abdiff[direction][i] = SQR(lix[0][1] - adjacent_lix[1]) + SQR(lix[0][2] - adjacent_lix[2]);",
          "7343:       leps = MIN(MAX(ldiff[0][0], ldiff[0][1]), MAX(ldiff[1][2], ldiff[1][3]));",
          "7344:       abeps = MIN(MAX(abdiff[0][0], abdiff[0][1]), MAX(abdiff[1][2], abdiff[1][3]));",
          "7345:       for (direction = 0; direction < 2; direction++)",
          "7346:       {",
          "7347:         homogeneity = 0;",
          "7348:         for (i = 0; i < 4; i++)",
          "7349:         {",
          "7350:           if (ldiff[direction][i] <= leps && abdiff[direction][i] <= abeps)",
          "7351:           {",
          "7352:             homogeneity++;",
          "7353:           }",
          "7354:         }",
          "7355:         homogeneity_map_p[0][direction] = homogeneity;",
          "7360: void CLASS ahd_interpolate_combine_homogeneous_pixels(int top, int left, ushort (*rgb)[TS][TS][3],",
          "7361:                                                       char (*homogeneity_map)[TS][2])",
          "",
          "---------------",
          "--- Hunk 77 ---",
          "[Context before]",
          "6529:   int direction;",
          "6530:   int hm[2];",
          "6531:   int c;",
          "6542:       rix[direction] = &rgb[direction][tr][2];",
          "6543:     }",
          "6547:       pix++;",
          "6549:         rix[direction]++;",
          "6550:       }",
          "6553:         hm[direction] = 0;",
          "6557:           }",
          "6558:         }",
          "6559:       }",
          "6561:         memcpy(pix[0], rix[hm[1] > hm[0]][0], 3 * sizeof(ushort));",
          "6566:       }",
          "6567:     }",
          "6568:   }",
          "",
          "[Removed Lines]",
          "6532:   const int rowlimit = MIN(top+TS-3, height-5);",
          "6533:   const int collimit = MIN(left+TS-3, width-5);",
          "6535:   ushort (*pix)[4];",
          "6536:   ushort (*rix[2])[3];",
          "6538:   for (row=top+3; row < rowlimit; row++) {",
          "6539:     tr = row-top;",
          "6540:     pix = &image[row*width+left+2];",
          "6541:     for (direction = 0; direction < 2; direction++) {",
          "6545:     for (col=left+3; col < collimit; col++) {",
          "6546:       tc = col-left;",
          "6548:       for (direction = 0; direction < 2; direction++) {",
          "6552:       for (direction=0; direction < 2; direction++) {",
          "6554:         for (i=tr-1; i <= tr+1; i++) {",
          "6555:           for (j=tc-1; j <= tc+1; j++) {",
          "6556:             hm[direction] += homogeneity_map[i][j][direction];",
          "6560:       if (hm[0] != hm[1]) {",
          "6562:       } else {",
          "6563:         FORC3 {",
          "6564:           pix[0][c] = (rix[0][0][c] + rix[1][0][c]) >> 1;",
          "6565:         }",
          "",
          "[Added Lines]",
          "7369:   const int rowlimit = MIN(top + TS - 3, height - 5);",
          "7370:   const int collimit = MIN(left + TS - 3, width - 5);",
          "7372:   ushort(*pix)[4];",
          "7373:   ushort(*rix[2])[3];",
          "7375:   for (row = top + 3; row < rowlimit; row++)",
          "7376:   {",
          "7377:     tr = row - top;",
          "7378:     pix = &image[row * width + left + 2];",
          "7379:     for (direction = 0; direction < 2; direction++)",
          "7380:     {",
          "7384:     for (col = left + 3; col < collimit; col++)",
          "7385:     {",
          "7386:       tc = col - left;",
          "7388:       for (direction = 0; direction < 2; direction++)",
          "7389:       {",
          "7393:       for (direction = 0; direction < 2; direction++)",
          "7394:       {",
          "7396:         for (i = tr - 1; i <= tr + 1; i++)",
          "7397:         {",
          "7398:           for (j = tc - 1; j <= tc + 1; j++)",
          "7399:           {",
          "7400:             hm[direction] += homogeneity_map[i][j][direction];",
          "7404:       if (hm[0] != hm[1])",
          "7405:       {",
          "7407:       }",
          "7408:       else",
          "7409:       {",
          "7410:         FORC3 { pix[0][c] = (rix[0][0][c] + rix[1][0][c]) >> 1; }",
          "",
          "---------------",
          "--- Hunk 78 ---",
          "[Context before]",
          "6570: void CLASS ahd_interpolate()",
          "6571: {",
          "6572:   int i, j, k, top, left;",
          "6574:   char *buffer;",
          "6578:   int terminate_flag = 0;",
          "6582:   border_interpolate(5);",
          "6584: #ifdef LIBRAW_LIBRARY_BUILD",
          "6585: #ifdef LIBRAW_USE_OPENMP",
          "6587: #endif",
          "6588: #endif",
          "6589:   {",
          "6596: #ifdef LIBRAW_LIBRARY_BUILD",
          "6597: #ifdef LIBRAW_USE_OPENMP",
          "6598: #pragma omp for schedule(dynamic)",
          "6599: #endif",
          "6600: #endif",
          "6602: #ifdef LIBRAW_LIBRARY_BUILD",
          "6603: #ifdef LIBRAW_USE_OPENMP",
          "6605: #endif",
          "6611: #endif",
          "6617:       }",
          "6618:     }",
          "6620:   }",
          "6621: #ifdef LIBRAW_LIBRARY_BUILD",
          "6624: #endif",
          "6625: }",
          "",
          "[Removed Lines]",
          "6573:   float xyz_cam[3][4],r;",
          "6575:   ushort (*rgb)[TS][TS][3];",
          "6576:   short (*lab)[TS][TS][3];",
          "6577:   char (*homo)[TS][2];",
          "6581:   cielab(0,0);",
          "6586: #pragma omp parallel private(buffer,rgb,lab,homo,top,left,i,j,k) shared(xyz_cam,terminate_flag)",
          "6591:     merror (buffer, \"ahd_interpolate()\");",
          "6592:     rgb  = (ushort(*)[TS][TS][3]) buffer;",
          "6593:     lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);",
          "6594:     homo = (char  (*)[TS][2])    (buffer + 24*TS*TS);",
          "6601:     for (top=2; top < height-5; top += TS-6){",
          "6604:         if(0== omp_get_thread_num())",
          "6606:            if(callbacks.progress_cb) {",
          "6607:                int rr = (*callbacks.progress_cb)(callbacks.progresscb_data,LIBRAW_PROGRESS_INTERPOLATE,top-2,height-7);",
          "6608:                if(rr)",
          "6609:                    terminate_flag = 1;",
          "6610:            }",
          "6612:         for (left=2; !terminate_flag && (left < width-5); left += TS-6) {",
          "6613:             ahd_interpolate_green_h_and_v(top, left, rgb);",
          "6614:             ahd_interpolate_r_and_b_and_convert_to_cielab(top, left, rgb, lab);",
          "6615:             ahd_interpolate_build_homogeneity_map(top, left, lab, homo);",
          "6616:             ahd_interpolate_combine_homogeneous_pixels(top, left, rgb, homo);",
          "6619:     free (buffer);",
          "6622:   if(terminate_flag)",
          "6623:       throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;",
          "",
          "[Added Lines]",
          "7418:   float xyz_cam[3][4], r;",
          "7420:   ushort(*rgb)[TS][TS][3];",
          "7421:   short(*lab)[TS][TS][3];",
          "7422:   char(*homo)[TS][2];",
          "7425:   cielab(0, 0);",
          "7430: #pragma omp parallel private(buffer, rgb, lab, homo, top, left, i, j, k) shared(xyz_cam, terminate_flag)",
          "7435:     merror(buffer, \"ahd_interpolate()\");",
          "7436:     rgb = (ushort(*)[TS][TS][3])buffer;",
          "7437:     lab = (short(*)[TS][TS][3])(buffer + 12 * TS * TS);",
          "7438:     homo = (char(*)[TS][2])(buffer + 24 * TS * TS);",
          "7445:     for (top = 2; top < height - 5; top += TS - 6)",
          "7446:     {",
          "7449:       if (0 == omp_get_thread_num())",
          "7451:         if (callbacks.progress_cb)",
          "7452:         {",
          "7453:           int rr =",
          "7454:               (*callbacks.progress_cb)(callbacks.progresscb_data, LIBRAW_PROGRESS_INTERPOLATE, top - 2, height - 7);",
          "7455:           if (rr)",
          "7456:             terminate_flag = 1;",
          "7457:         }",
          "7459:       for (left = 2; !terminate_flag && (left < width - 5); left += TS - 6)",
          "7460:       {",
          "7461:         ahd_interpolate_green_h_and_v(top, left, rgb);",
          "7462:         ahd_interpolate_r_and_b_and_convert_to_cielab(top, left, rgb, lab);",
          "7463:         ahd_interpolate_build_homogeneity_map(top, left, lab, homo);",
          "7464:         ahd_interpolate_combine_homogeneous_pixels(top, left, rgb, homo);",
          "7467:     free(buffer);",
          "7470:   if (terminate_flag)",
          "7471:     throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;",
          "",
          "---------------",
          "--- Hunk 79 ---",
          "[Context before]",
          "6628: void CLASS ahd_interpolate()",
          "6629: {",
          "6630:   int i, j, top, left, row, col, tr, tc, c, d, val, hm[2];",
          "6632:   unsigned ldiff[2][4], abdiff[2][4], leps, abeps;",
          "6637: #ifdef DCRAW_VERBOSE",
          "6639: #endif",
          "6642:   border_interpolate(5);",
          "6732: }",
          "6733: #endif",
          "6734: #undef TS",
          "6736: void CLASS median_filter()",
          "6737: {",
          "6739:   int pass, c, i, j, k, med[9];",
          "6745: #ifdef LIBRAW_LIBRARY_BUILD",
          "6747: #endif",
          "6748: #ifdef DCRAW_VERBOSE",
          "6749:     if (verbose)",
          "6751: #endif",
          "6764:       }",
          "6765:     }",
          "6766:   }",
          "",
          "[Removed Lines]",
          "6631:   static const int dir[4] = { -1, 1, -TS, TS };",
          "6633:   ushort (*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];",
          "6634:    short (*lab)[TS][TS][3], (*lix)[3];",
          "6635:    char (*homo)[TS][TS], *buffer;",
          "6638:   if (verbose) fprintf (stderr,_(\"AHD interpolation...\\n\"));",
          "6641:   cielab (0,0);",
          "6643:   buffer = (char *) malloc (26*TS*TS);",
          "6644:   merror (buffer, \"ahd_interpolate()\");",
          "6645:   rgb  = (ushort(*)[TS][TS][3]) buffer;",
          "6646:   lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);",
          "6647:   homo = (char  (*)[TS][TS])   (buffer + 24*TS*TS);",
          "6649:   for (top=2; top < height-5; top += TS-6)",
          "6650:     for (left=2; left < width-5; left += TS-6) {",
          "6653:       for (row=top; row < top+TS && row < height-2; row++) {",
          "6654:  col = left + (FC(row,left) & 1);",
          "6655:  for (c = FC(row,col); col < left+TS && col < width-2; col+=2) {",
          "6656:    pix = image + row*width+col;",
          "6657:    val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2",
          "6658:   - pix[-2][c] - pix[2][c]) >> 2;",
          "6659:    rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);",
          "6660:    val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2",
          "6661:   - pix[-2*width][c] - pix[2*width][c]) >> 2;",
          "6662:    rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);",
          "6663:  }",
          "6664:       }",
          "6667:       for (d=0; d < 2; d++)",
          "6668:  for (row=top+1; row < top+TS-1 && row < height-3; row++)",
          "6669:    for (col=left+1; col < left+TS-1 && col < width-3; col++) {",
          "6670:      pix = image + row*width+col;",
          "6671:      rix = &rgb[d][row-top][col-left];",
          "6672:      lix = &lab[d][row-top][col-left];",
          "6673:      if ((c = 2 - FC(row,col)) == 1) {",
          "6674:        c = FC(row+1,col);",
          "6675:        val = pix[0][1] + (( pix[-1][2-c] + pix[1][2-c]",
          "6676:      - rix[-1][1] - rix[1][1] ) >> 1);",
          "6677:        rix[0][2-c] = CLIP(val);",
          "6678:        val = pix[0][1] + (( pix[-width][c] + pix[width][c]",
          "6679:      - rix[-TS][1] - rix[TS][1] ) >> 1);",
          "6680:      } else",
          "6681:        val = rix[0][1] + (( pix[-width-1][c] + pix[-width+1][c]",
          "6682:      + pix[+width-1][c] + pix[+width+1][c]",
          "6683:      - rix[-TS-1][1] - rix[-TS+1][1]",
          "6684:      - rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);",
          "6685:      rix[0][c] = CLIP(val);",
          "6686:      c = FC(row,col);",
          "6687:      rix[0][c] = pix[0][c];",
          "6688:      cielab (rix[0],lix[0]);",
          "6689:    }",
          "6691:       memset (homo, 0, 2*TS*TS);",
          "6692:       for (row=top+2; row < top+TS-2 && row < height-4; row++) {",
          "6693:  tr = row-top;",
          "6694:  for (col=left+2; col < left+TS-2 && col < width-4; col++) {",
          "6695:    tc = col-left;",
          "6696:    for (d=0; d < 2; d++) {",
          "6697:      lix = &lab[d][tr][tc];",
          "6698:      for (i=0; i < 4; i++) {",
          "6699:         ldiff[d][i] = ABS(lix[0][0]-lix[dir[i]][0]);",
          "6700:        abdiff[d][i] = SQR(lix[0][1]-lix[dir[i]][1])",
          "6701:       + SQR(lix[0][2]-lix[dir[i]][2]);",
          "6702:      }",
          "6703:    }",
          "6704:    leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),",
          "6705:        MAX(ldiff[1][2],ldiff[1][3]));",
          "6706:    abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),",
          "6707:         MAX(abdiff[1][2],abdiff[1][3]));",
          "6708:    for (d=0; d < 2; d++)",
          "6709:      for (i=0; i < 4; i++)",
          "6710:        if (ldiff[d][i] <= leps && abdiff[d][i] <= abeps)",
          "6711:   homo[d][tr][tc]++;",
          "6712:  }",
          "6713:       }",
          "6715:       for (row=top+3; row < top+TS-3 && row < height-5; row++) {",
          "6716:  tr = row-top;",
          "6717:  for (col=left+3; col < left+TS-3 && col < width-5; col++) {",
          "6718:    tc = col-left;",
          "6719:    for (d=0; d < 2; d++)",
          "6720:      for (hm[d]=0, i=tr-1; i <= tr+1; i++)",
          "6721:        for (j=tc-1; j <= tc+1; j++)",
          "6722:   hm[d] += homo[d][i][j];",
          "6723:    if (hm[0] != hm[1])",
          "6724:      FORC3 image[row*width+col][c] = rgb[hm[1] > hm[0]][tr][tc][c];",
          "6725:    else",
          "6726:      FORC3 image[row*width+col][c] =",
          "6727:   (rgb[0][tr][tc][c] + rgb[1][tr][tc][c]) >> 1;",
          "6728:  }",
          "6729:       }",
          "6730:     }",
          "6731:   free (buffer);",
          "6738:   ushort (*pix)[4];",
          "6741:   { 1,2, 4,5, 7,8, 0,1, 3,4, 6,7, 1,2, 4,5, 7,8,",
          "6742:     0,3, 5,8, 4,7, 3,6, 1,4, 2,5, 4,7, 4,2, 6,4, 4,2 };",
          "6744:   for (pass=1; pass <= med_passes; pass++) {",
          "6746:       RUN_CALLBACK(LIBRAW_PROGRESS_MEDIAN_FILTER,pass-1,med_passes);",
          "6750:       fprintf (stderr,_(\"Median filter pass %d...\\n\"), pass);",
          "6752:     for (c=0; c < 3; c+=2) {",
          "6753:       for (pix = image; pix < image+width*height; pix++)",
          "6754:  pix[0][3] = pix[0][c];",
          "6755:       for (pix = image+width; pix < image+width*(height-1); pix++) {",
          "6756:  if ((pix-image+1) % width < 2) continue;",
          "6757:  for (k=0, i = -width; i <= width; i += width)",
          "6758:    for (j = i-1; j <= i+1; j++)",
          "6759:      med[k++] = pix[j][3] - pix[j][1];",
          "6760:  for (i=0; i < sizeof opt; i+=2)",
          "6761:    if     (med[opt[i]] > med[opt[i+1]])",
          "6762:      SWAP (med[opt[i]] , med[opt[i+1]]);",
          "6763:  pix[0][c] = CLIP(med[4] + pix[0][1]);",
          "",
          "[Added Lines]",
          "7479:   static const int dir[4] = {-1, 1, -TS, TS};",
          "7481:   ushort(*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];",
          "7482:   short(*lab)[TS][TS][3], (*lix)[3];",
          "7483:   char(*homo)[TS][TS], *buffer;",
          "7486:   if (verbose)",
          "7487:     fprintf(stderr, _(\"AHD interpolation...\\n\"));",
          "7490:   cielab(0, 0);",
          "7492:   buffer = (char *)malloc(26 * TS * TS);",
          "7493:   merror(buffer, \"ahd_interpolate()\");",
          "7494:   rgb = (ushort(*)[TS][TS][3])buffer;",
          "7495:   lab = (short(*)[TS][TS][3])(buffer + 12 * TS * TS);",
          "7496:   homo = (char(*)[TS][TS])(buffer + 24 * TS * TS);",
          "7498:   for (top = 2; top < height - 5; top += TS - 6)",
          "7499:     for (left = 2; left < width - 5; left += TS - 6)",
          "7500:     {",
          "7503:       for (row = top; row < top + TS && row < height - 2; row++)",
          "7504:       {",
          "7505:         col = left + (FC(row, left) & 1);",
          "7506:         for (c = FC(row, col); col < left + TS && col < width - 2; col += 2)",
          "7507:         {",
          "7508:           pix = image + row * width + col;",
          "7509:           val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2 - pix[-2][c] - pix[2][c]) >> 2;",
          "7510:           rgb[0][row - top][col - left][1] = ULIM(val, pix[-1][1], pix[1][1]);",
          "7511:           val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2 - pix[-2 * width][c] - pix[2 * width][c]) >> 2;",
          "7512:           rgb[1][row - top][col - left][1] = ULIM(val, pix[-width][1], pix[width][1]);",
          "7513:         }",
          "7514:       }",
          "7517:       for (d = 0; d < 2; d++)",
          "7518:         for (row = top + 1; row < top + TS - 1 && row < height - 3; row++)",
          "7519:           for (col = left + 1; col < left + TS - 1 && col < width - 3; col++)",
          "7520:           {",
          "7521:             pix = image + row * width + col;",
          "7522:             rix = &rgb[d][row - top][col - left];",
          "7523:             lix = &lab[d][row - top][col - left];",
          "7524:             if ((c = 2 - FC(row, col)) == 1)",
          "7525:             {",
          "7526:               c = FC(row + 1, col);",
          "7527:               val = pix[0][1] + ((pix[-1][2 - c] + pix[1][2 - c] - rix[-1][1] - rix[1][1]) >> 1);",
          "7528:               rix[0][2 - c] = CLIP(val);",
          "7529:               val = pix[0][1] + ((pix[-width][c] + pix[width][c] - rix[-TS][1] - rix[TS][1]) >> 1);",
          "7530:             }",
          "7531:             else",
          "7532:               val = rix[0][1] + ((pix[-width - 1][c] + pix[-width + 1][c] + pix[+width - 1][c] + pix[+width + 1][c] -",
          "7533:                                   rix[-TS - 1][1] - rix[-TS + 1][1] - rix[+TS - 1][1] - rix[+TS + 1][1] + 1) >>",
          "7534:                                  2);",
          "7535:             rix[0][c] = CLIP(val);",
          "7536:             c = FC(row, col);",
          "7537:             rix[0][c] = pix[0][c];",
          "7538:             cielab(rix[0], lix[0]);",
          "7539:           }",
          "7541:       memset(homo, 0, 2 * TS * TS);",
          "7542:       for (row = top + 2; row < top + TS - 2 && row < height - 4; row++)",
          "7543:       {",
          "7544:         tr = row - top;",
          "7545:         for (col = left + 2; col < left + TS - 2 && col < width - 4; col++)",
          "7546:         {",
          "7547:           tc = col - left;",
          "7548:           for (d = 0; d < 2; d++)",
          "7549:           {",
          "7550:             lix = &lab[d][tr][tc];",
          "7551:             for (i = 0; i < 4; i++)",
          "7552:             {",
          "7553:               ldiff[d][i] = ABS(lix[0][0] - lix[dir[i]][0]);",
          "7554:               abdiff[d][i] = SQR(lix[0][1] - lix[dir[i]][1]) + SQR(lix[0][2] - lix[dir[i]][2]);",
          "7555:             }",
          "7556:           }",
          "7557:           leps = MIN(MAX(ldiff[0][0], ldiff[0][1]), MAX(ldiff[1][2], ldiff[1][3]));",
          "7558:           abeps = MIN(MAX(abdiff[0][0], abdiff[0][1]), MAX(abdiff[1][2], abdiff[1][3]));",
          "7559:           for (d = 0; d < 2; d++)",
          "7560:             for (i = 0; i < 4; i++)",
          "7561:               if (ldiff[d][i] <= leps && abdiff[d][i] <= abeps)",
          "7562:                 homo[d][tr][tc]++;",
          "7563:         }",
          "7564:       }",
          "7566:       for (row = top + 3; row < top + TS - 3 && row < height - 5; row++)",
          "7567:       {",
          "7568:         tr = row - top;",
          "7569:         for (col = left + 3; col < left + TS - 3 && col < width - 5; col++)",
          "7570:         {",
          "7571:           tc = col - left;",
          "7572:           for (d = 0; d < 2; d++)",
          "7573:             for (hm[d] = 0, i = tr - 1; i <= tr + 1; i++)",
          "7574:               for (j = tc - 1; j <= tc + 1; j++)",
          "7575:                 hm[d] += homo[d][i][j];",
          "7576:           if (hm[0] != hm[1])",
          "7577:             FORC3 image[row * width + col][c] = rgb[hm[1] > hm[0]][tr][tc][c];",
          "7578:           else",
          "7579:             FORC3 image[row * width + col][c] = (rgb[0][tr][tc][c] + rgb[1][tr][tc][c]) >> 1;",
          "7580:         }",
          "7581:       }",
          "7582:     }",
          "7583:   free(buffer);",
          "7590:   ushort(*pix)[4];",
          "7593:       {1, 2, 4, 5, 7, 8, 0, 1, 3, 4, 6, 7, 1, 2, 4, 5, 7, 8, 0,",
          "7594:        3, 5, 8, 4, 7, 3, 6, 1, 4, 2, 5, 4, 7, 4, 2, 6, 4, 4, 2};",
          "7596:   for (pass = 1; pass <= med_passes; pass++)",
          "7597:   {",
          "7599:     RUN_CALLBACK(LIBRAW_PROGRESS_MEDIAN_FILTER, pass - 1, med_passes);",
          "7603:       fprintf(stderr, _(\"Median filter pass %d...\\n\"), pass);",
          "7605:     for (c = 0; c < 3; c += 2)",
          "7606:     {",
          "7607:       for (pix = image; pix < image + width * height; pix++)",
          "7608:         pix[0][3] = pix[0][c];",
          "7609:       for (pix = image + width; pix < image + width * (height - 1); pix++)",
          "7610:       {",
          "7611:         if ((pix - image + 1) % width < 2)",
          "7612:           continue;",
          "7613:         for (k = 0, i = -width; i <= width; i += width)",
          "7614:           for (j = i - 1; j <= i + 1; j++)",
          "7615:             med[k++] = pix[j][3] - pix[j][1];",
          "7616:         for (i = 0; i < sizeof opt; i += 2)",
          "7617:           if (med[opt[i]] > med[opt[i + 1]])",
          "7618:             SWAP(med[opt[i]], med[opt[i + 1]]);",
          "7619:         pix[0][c] = CLIP(med[4] + pix[0][1]);",
          "",
          "---------------",
          "--- Hunk 80 ---",
          "[Context before]",
          "6769: void CLASS blend_highlights()",
          "6770: {",
          "6778:   float cam[2][4], lab[2][4], sum[2], chratio;",
          "6781: #ifdef DCRAW_VERBOSE",
          "6783: #endif",
          "6784: #ifdef LIBRAW_LIBRARY_BUILD",
          "6786: #endif",
          "6795:       }",
          "6801:       }",
          "6808:     }",
          "6809: #ifdef LIBRAW_LIBRARY_BUILD",
          "6811: #endif",
          "6812: }",
          "",
          "[Removed Lines]",
          "6771:   int clip=INT_MAX, row, col, c, i, j;",
          "6772:   static const float trans[2][4][4] =",
          "6773:   { { { 1,1,1 }, { 1.7320508,-1.7320508,0 }, { -1,-1,2 } },",
          "6774:     { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };",
          "6775:   static const float itrans[2][4][4] =",
          "6776:   { { { 1,0.8660254,-0.5 }, { 1,-0.8660254,-0.5 }, { 1,0,1 } },",
          "6777:     { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };",
          "6780:   if ((unsigned) (colors-3) > 1) return;",
          "6782:   if (verbose) fprintf (stderr,_(\"Blending highlights...\\n\"));",
          "6785:   RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,0,2);",
          "6787:   FORCC if (clip > (i = 65535*pre_mul[c])) clip = i;",
          "6788:   for (row=0; row < height; row++)",
          "6789:     for (col=0; col < width; col++) {",
          "6790:       FORCC if (image[row*width+col][c] > clip) break;",
          "6791:       if (c == colors) continue;",
          "6792:       FORCC {",
          "6793:  cam[0][c] = image[row*width+col][c];",
          "6794:  cam[1][c] = MIN(cam[0][c],clip);",
          "6796:       for (i=0; i < 2; i++) {",
          "6797:  FORCC for (lab[i][c]=j=0; j < colors; j++)",
          "6798:    lab[i][c] += trans[colors-3][c][j] * cam[i][j];",
          "6799:  for (sum[i]=0,c=1; c < colors; c++)",
          "6800:    sum[i] += SQR(lab[i][c]);",
          "6802:       chratio = sqrt(sum[1]/sum[0]);",
          "6803:       for (c=1; c < colors; c++)",
          "6804:  lab[0][c] *= chratio;",
          "6805:       FORCC for (cam[0][c]=j=0; j < colors; j++)",
          "6806:  cam[0][c] += itrans[colors-3][c][j] * lab[0][j];",
          "6807:       FORCC image[row*width+col][c] = cam[0][c] / colors;",
          "6810:   RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,1,2);",
          "",
          "[Added Lines]",
          "7627:   int clip = INT_MAX, row, col, c, i, j;",
          "7628:   static const float trans[2][4][4] = {{{1, 1, 1}, {1.7320508, -1.7320508, 0}, {-1, -1, 2}},",
          "7629:                                        {{1, 1, 1, 1}, {1, -1, 1, -1}, {1, 1, -1, -1}, {1, -1, -1, 1}}};",
          "7630:   static const float itrans[2][4][4] = {{{1, 0.8660254, -0.5}, {1, -0.8660254, -0.5}, {1, 0, 1}},",
          "7631:                                         {{1, 1, 1, 1}, {1, -1, 1, -1}, {1, 1, -1, -1}, {1, -1, -1, 1}}};",
          "7634:   if ((unsigned)(colors - 3) > 1)",
          "7635:     return;",
          "7637:   if (verbose)",
          "7638:     fprintf(stderr, _(\"Blending highlights...\\n\"));",
          "7641:   RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, 0, 2);",
          "7643:   FORCC if (clip > (i = 65535 * pre_mul[c])) clip = i;",
          "7644:   for (row = 0; row < height; row++)",
          "7645:     for (col = 0; col < width; col++)",
          "7646:     {",
          "7647:       FORCC if (image[row * width + col][c] > clip) break;",
          "7648:       if (c == colors)",
          "7649:         continue;",
          "7650:       FORCC",
          "7651:       {",
          "7652:         cam[0][c] = image[row * width + col][c];",
          "7653:         cam[1][c] = MIN(cam[0][c], clip);",
          "7655:       for (i = 0; i < 2; i++)",
          "7656:       {",
          "7657:         FORCC for (lab[i][c] = j = 0; j < colors; j++) lab[i][c] += trans[colors - 3][c][j] * cam[i][j];",
          "7658:         for (sum[i] = 0, c = 1; c < colors; c++)",
          "7659:           sum[i] += SQR(lab[i][c]);",
          "7661:       chratio = sqrt(sum[1] / sum[0]);",
          "7662:       for (c = 1; c < colors; c++)",
          "7663:         lab[0][c] *= chratio;",
          "7664:       FORCC for (cam[0][c] = j = 0; j < colors; j++) cam[0][c] += itrans[colors - 3][c][j] * lab[0][j];",
          "7665:       FORCC image[row * width + col][c] = cam[0][c] / colors;",
          "7668:   RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, 1, 2);",
          "",
          "---------------",
          "--- Hunk 81 ---",
          "[Context before]",
          "6818:   int hsat[4], count, spread, change, val, i;",
          "6819:   unsigned high, wide, mrow, mcol, row, col, kc, c, d, y, x;",
          "6820:   ushort *pixel;",
          "6824: #ifdef DCRAW_VERBOSE",
          "6826: #endif",
          "6829:   FORCC hsat[c] = 32000 * pre_mul[c];",
          "6832:   high = height / SCALE;",
          "6894: }",
          "6895: #undef SCALE",
          "6899: {",
          "6906: }",
          "6909: {",
          "6910:   unsigned entries, tag, type, len, save;",
          "6912:   entries = get2();",
          "6918:   }",
          "6919: }",
          "6936: #ifdef LIBRAW_LIBRARY_BUILD",
          "6939:   float t;",
          "6941:     t = ceilf(x);",
          "6943:     return t;",
          "6945:     t = ceilf(-x);",
          "6947:     return -t;",
          "6948:   }",
          "6949: }",
          "6951: static float _CanonConvertAperture(ushort in)",
          "6952: {",
          "6955: }",
          "6958: {",
          "6978: }",
          "7047: {",
          "7049:   CameraInfo[0] = 0;",
          "7050:   CameraInfo[1] = 0;",
          "7052:   case 0x80000001: // 1D",
          "7053:   case 0x80000167: // 1DS",
          "7054:     iCanonCurFocal = 10;",
          "",
          "[Removed Lines]",
          "6821:   static const signed char dir[8][2] =",
          "6822:     { {-1,-1}, {-1,0}, {-1,1}, {0,1}, {1,1}, {1,0}, {1,-1}, {0,-1} };",
          "6825:   if (verbose) fprintf (stderr,_(\"Rebuilding highlights...\\n\"));",
          "6828:   grow = pow (2.0, 4-highlight);",
          "6830:   for (kc=0, c=1; c < colors; c++)",
          "6831:     if (pre_mul[kc] < pre_mul[c]) kc = c;",
          "6833:   wide =  width / SCALE;",
          "6834:   map = (float *) calloc (high, wide*sizeof *map);",
          "6835:   merror (map, \"recover_highlights()\");",
          "6836:   FORCC if (c != kc) {",
          "6837: #ifdef LIBRAW_LIBRARY_BUILD",
          "6838:       RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,c-1,colors-1);",
          "6839: #endif",
          "6840:     memset (map, 0, high*wide*sizeof *map);",
          "6841:     for (mrow=0; mrow < high; mrow++)",
          "6842:       for (mcol=0; mcol < wide; mcol++) {",
          "6843:  sum = wgt = count = 0;",
          "6844:  for (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)",
          "6845:    for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {",
          "6846:      pixel = image[row*width+col];",
          "6847:      if (pixel[c] / hsat[c] == 1 && pixel[kc] > 24000) {",
          "6848:        sum += pixel[c];",
          "6849:        wgt += pixel[kc];",
          "6850:        count++;",
          "6851:      }",
          "6852:    }",
          "6853:  if (count == SCALE*SCALE)",
          "6854:    map[mrow*wide+mcol] = sum / wgt;",
          "6855:       }",
          "6856:     for (spread = 32/grow; spread--; ) {",
          "6857:       for (mrow=0; mrow < high; mrow++)",
          "6858:  for (mcol=0; mcol < wide; mcol++) {",
          "6859:    if (map[mrow*wide+mcol]) continue;",
          "6860:    sum = count = 0;",
          "6861:    for (d=0; d < 8; d++) {",
          "6862:      y = mrow + dir[d][0];",
          "6863:      x = mcol + dir[d][1];",
          "6864:      if (y < high && x < wide && map[y*wide+x] > 0) {",
          "6865:        sum  += (1 + (d & 1)) * map[y*wide+x];",
          "6866:        count += 1 + (d & 1);",
          "6867:      }",
          "6868:    }",
          "6869:    if (count > 3)",
          "6870:      map[mrow*wide+mcol] = - (sum+grow) / (count+grow);",
          "6871:  }",
          "6872:       for (change=i=0; i < high*wide; i++)",
          "6873:  if (map[i] < 0) {",
          "6874:    map[i] = -map[i];",
          "6875:    change = 1;",
          "6876:  }",
          "6877:       if (!change) break;",
          "6878:     }",
          "6879:     for (i=0; i < high*wide; i++)",
          "6880:       if (map[i] == 0) map[i] = 1;",
          "6881:     for (mrow=0; mrow < high; mrow++)",
          "6882:       for (mcol=0; mcol < wide; mcol++) {",
          "6883:  for (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)",
          "6884:    for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {",
          "6885:      pixel = image[row*width+col];",
          "6886:      if (pixel[c] / hsat[c] > 1) {",
          "6887:        val = pixel[kc] * map[mrow*wide+mcol];",
          "6888:        if (pixel[c] < val) pixel[c] = CLIP(val);",
          "6889:      }",
          "6890:    }",
          "6891:       }",
          "6892:   }",
          "6893:   free (map);",
          "6897: void CLASS tiff_get (unsigned base,",
          "6898:  unsigned *tag, unsigned *type, unsigned *len, unsigned *save)",
          "6904:   if (*len * (\"11124811248484\"[*type < 14 ? *type:0]-'0') > 4)",
          "6905:     fseek (ifp, get4()+base, SEEK_SET);",
          "6908: void CLASS parse_thumb_note (int base, unsigned toff, unsigned tlen)",
          "6913:   while (entries--) {",
          "6914:     tiff_get (base, &tag, &type, &len, &save);",
          "6915:     if (tag == toff) thumb_offset = get4()+base;",
          "6916:     if (tag == tlen) thumb_length = get4();",
          "6917:     fseek (ifp, save, SEEK_SET);",
          "6922: int CLASS parse_tiff_ifd (int base);",
          "6926: static float powf_lim(float a, float b, float limup)",
          "6927: {",
          "6928:   return (b>limup || b < -limup)?0.f:powf(a,b);",
          "6929: }",
          "6930: static float powf64(float a, float b)",
          "6931: {",
          "6932:   return powf_lim(a,b,64.f);",
          "6933: }",
          "6938: static float my_roundf(float x) {",
          "6940:   if (x >= 0.0) {",
          "6942:     if (t - x > 0.5) t -= 1.0;",
          "6944:   } else {",
          "6946:     if (t + x > 0.5) t -= 1.0;",
          "6953:   if ((in == (ushort)0xffe0) || (in == (ushort)0x7fff)) return 0.0f;",
          "6954:   return powf64(2.0, in/64.0);",
          "6957: static float _CanonConvertEV (short in)",
          "6959:  short EV, Sign, Frac;",
          "6960:  float Frac_f;",
          "6961:  EV = in;",
          "6962:  if (EV < 0) {",
          "6963:    EV = -EV;",
          "6964:    Sign = -1;",
          "6965:  } else {",
          "6966:    Sign = 1;",
          "6967:  }",
          "6968:  Frac = EV & 0x1f;",
          "6969:  EV -= Frac;   // remove fraction",
          "6971:  if (Frac == 0x0c) {  // convert 1/3 and 2/3 codes",
          "6972:    Frac_f = 32.0f / 3.0f;",
          "6973:  } else if (Frac == 0x14) {",
          "6974:    Frac_f = 64.0f / 3.0f;",
          "6975:  } else Frac_f = (float) Frac;",
          "6977:  return ((float)Sign * ((float)EV + Frac_f))/32.0f;",
          "6980: void CLASS setCanonBodyFeatures (unsigned id)",
          "6981:       {",
          "6982:       imgdata.lens.makernotes.CamID = id;",
          "6983:  if (",
          "6984:             (id == 0x80000001) || // 1D",
          "6985:             (id == 0x80000174) || // 1D2",
          "6986:             (id == 0x80000232) || // 1D2N",
          "6987:             (id == 0x80000169) || // 1D3",
          "6988:             (id == 0x80000281)  // 1D4",
          "6989:             )",
          "6990:           {",
          "6991:             imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSH;",
          "6992:             imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;",
          "6993:           }",
          "6994:         else",
          "6995:           if (",
          "6996:               (id == 0x80000167) || // 1Ds",
          "6997:               (id == 0x80000188) || // 1Ds2",
          "6998:               (id == 0x80000215) || // 1Ds3",
          "6999:               (id == 0x80000269) || // 1DX",
          "7000:               (id == 0x80000328) || // 1DX2",
          "7001:               (id == 0x80000324) || // 1DC",
          "7002:               (id == 0x80000213) || // 5D",
          "7003:               (id == 0x80000218) || // 5D2",
          "7004:               (id == 0x80000285) || // 5D3",
          "7005:               (id == 0x80000349) || // 5D4",
          "7006:               (id == 0x80000382) || // 5DS",
          "7007:               (id == 0x80000401) || // 5DS R",
          "7008:               (id == 0x80000302)  // 6D",
          "7009:               )",
          "7010:             {",
          "7011:               imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;",
          "7012:               imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;",
          "7013:             }",
          "7014:           else",
          "7015:             if (",
          "7016:                 (id == 0x80000331) || // M",
          "7017:                 (id == 0x80000355) || // M2",
          "7018:                 (id == 0x80000374) ||  // M3",
          "7019:                 (id == 0x80000384) ||  // M10",
          "7020:                 (id == 0x80000394)   // M5",
          "7021:                 )",
          "7022:               {",
          "7023:                 imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;",
          "7024:                 imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF_M;",
          "7025:               }",
          "7026:             else",
          "7027:               if (",
          "7028:                   (id == 0x01140000) || // D30",
          "7029:                   (id == 0x01668000) || // D60",
          "7030:                   (id > 0x80000000)",
          "7031:                   )",
          "7032:                 {",
          "7033:                   imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;",
          "7034:                   imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;",
          "7035:                   imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Unknown;",
          "7036:                 }",
          "7037:               else",
          "7038:                 {",
          "7039:                   imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "7040:                   imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "7041:                 }",
          "7043:  return;",
          "7044:       }",
          "7046: void CLASS processCanonCameraInfo (unsigned id, uchar *CameraInfo, unsigned maxlen)",
          "7048:   ushort iCanonLensID = 0, iCanonMaxFocal = 0, iCanonMinFocal = 0, iCanonLens = 0, iCanonCurFocal = 0, iCanonFocalType = 0;",
          "7051:   switch (id) {",
          "",
          "[Added Lines]",
          "7679:   static const signed char dir[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}};",
          "7682:   if (verbose)",
          "7683:     fprintf(stderr, _(\"Rebuilding highlights...\\n\"));",
          "7686:   grow = pow(2.0, 4 - highlight);",
          "7688:   for (kc = 0, c = 1; c < colors; c++)",
          "7689:     if (pre_mul[kc] < pre_mul[c])",
          "7690:       kc = c;",
          "7692:   wide = width / SCALE;",
          "7693:   map = (float *)calloc(high, wide * sizeof *map);",
          "7694:   merror(map, \"recover_highlights()\");",
          "7695:   FORCC if (c != kc)",
          "7696:   {",
          "7697: #ifdef LIBRAW_LIBRARY_BUILD",
          "7698:     RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, c - 1, colors - 1);",
          "7699: #endif",
          "7700:     memset(map, 0, high * wide * sizeof *map);",
          "7701:     for (mrow = 0; mrow < high; mrow++)",
          "7702:       for (mcol = 0; mcol < wide; mcol++)",
          "7703:       {",
          "7704:         sum = wgt = count = 0;",
          "7705:         for (row = mrow * SCALE; row < (mrow + 1) * SCALE; row++)",
          "7706:           for (col = mcol * SCALE; col < (mcol + 1) * SCALE; col++)",
          "7707:           {",
          "7708:             pixel = image[row * width + col];",
          "7709:             if (pixel[c] / hsat[c] == 1 && pixel[kc] > 24000)",
          "7710:             {",
          "7711:               sum += pixel[c];",
          "7712:               wgt += pixel[kc];",
          "7713:               count++;",
          "7714:             }",
          "7715:           }",
          "7716:         if (count == SCALE * SCALE)",
          "7717:           map[mrow * wide + mcol] = sum / wgt;",
          "7718:       }",
          "7719:     for (spread = 32 / grow; spread--;)",
          "7720:     {",
          "7721:       for (mrow = 0; mrow < high; mrow++)",
          "7722:         for (mcol = 0; mcol < wide; mcol++)",
          "7723:         {",
          "7724:           if (map[mrow * wide + mcol])",
          "7725:             continue;",
          "7726:           sum = count = 0;",
          "7727:           for (d = 0; d < 8; d++)",
          "7728:           {",
          "7729:             y = mrow + dir[d][0];",
          "7730:             x = mcol + dir[d][1];",
          "7731:             if (y < high && x < wide && map[y * wide + x] > 0)",
          "7732:             {",
          "7733:               sum += (1 + (d & 1)) * map[y * wide + x];",
          "7734:               count += 1 + (d & 1);",
          "7735:             }",
          "7736:           }",
          "7737:           if (count > 3)",
          "7738:             map[mrow * wide + mcol] = -(sum + grow) / (count + grow);",
          "7739:         }",
          "7740:       for (change = i = 0; i < high * wide; i++)",
          "7741:         if (map[i] < 0)",
          "7742:         {",
          "7743:           map[i] = -map[i];",
          "7744:           change = 1;",
          "7745:         }",
          "7746:       if (!change)",
          "7747:         break;",
          "7748:     }",
          "7749:     for (i = 0; i < high * wide; i++)",
          "7750:       if (map[i] == 0)",
          "7751:         map[i] = 1;",
          "7752:     for (mrow = 0; mrow < high; mrow++)",
          "7753:       for (mcol = 0; mcol < wide; mcol++)",
          "7754:       {",
          "7755:         for (row = mrow * SCALE; row < (mrow + 1) * SCALE; row++)",
          "7756:           for (col = mcol * SCALE; col < (mcol + 1) * SCALE; col++)",
          "7757:           {",
          "7758:             pixel = image[row * width + col];",
          "7759:             if (pixel[c] / hsat[c] > 1)",
          "7760:             {",
          "7761:               val = pixel[kc] * map[mrow * wide + mcol];",
          "7762:               if (pixel[c] < val)",
          "7763:                 pixel[c] = CLIP(val);",
          "7764:             }",
          "7765:           }",
          "7766:       }",
          "7767:   }",
          "7768:   free(map);",
          "7772: void CLASS tiff_get(unsigned base, unsigned *tag, unsigned *type, unsigned *len, unsigned *save)",
          "7778:   if (*len * (\"11124811248484\"[*type < 14 ? *type : 0] - '0') > 4)",
          "7779:     fseek(ifp, get4() + base, SEEK_SET);",
          "7782: void CLASS parse_thumb_note(int base, unsigned toff, unsigned tlen)",
          "7787:   while (entries--)",
          "7788:   {",
          "7789:     tiff_get(base, &tag, &type, &len, &save);",
          "7790:     if (tag == toff)",
          "7791:       thumb_offset = get4() + base;",
          "7792:     if (tag == tlen)",
          "7793:       thumb_length = get4();",
          "7794:     fseek(ifp, save, SEEK_SET);",
          "7799: int CLASS parse_tiff_ifd(int base);",
          "7803: static float powf_lim(float a, float b, float limup) { return (b > limup || b < -limup) ? 0.f : powf(a, b); }",
          "7804: static float powf64(float a, float b) { return powf_lim(a, b, 64.f); }",
          "7808: static float my_roundf(float x)",
          "7809: {",
          "7811:   if (x >= 0.0)",
          "7812:   {",
          "7814:     if (t - x > 0.5)",
          "7815:       t -= 1.0;",
          "7817:   }",
          "7818:   else",
          "7819:   {",
          "7821:     if (t + x > 0.5)",
          "7822:       t -= 1.0;",
          "7829:   if ((in == (ushort)0xffe0) || (in == (ushort)0x7fff))",
          "7830:     return 0.0f;",
          "7831:   return powf64(2.0, in / 64.0);",
          "7834: static float _CanonConvertEV(short in)",
          "7836:   short EV, Sign, Frac;",
          "7837:   float Frac_f;",
          "7838:   EV = in;",
          "7839:   if (EV < 0)",
          "7840:   {",
          "7841:     EV = -EV;",
          "7842:     Sign = -1;",
          "7843:   }",
          "7844:   else",
          "7845:   {",
          "7846:     Sign = 1;",
          "7847:   }",
          "7848:   Frac = EV & 0x1f;",
          "7849:   EV -= Frac; // remove fraction",
          "7851:   if (Frac == 0x0c)",
          "7852:   { // convert 1/3 and 2/3 codes",
          "7853:     Frac_f = 32.0f / 3.0f;",
          "7854:   }",
          "7855:   else if (Frac == 0x14)",
          "7856:   {",
          "7857:     Frac_f = 64.0f / 3.0f;",
          "7858:   }",
          "7859:   else",
          "7860:     Frac_f = (float)Frac;",
          "7862:   return ((float)Sign * ((float)EV + Frac_f)) / 32.0f;",
          "7865: void CLASS setCanonBodyFeatures(unsigned id)",
          "7866: {",
          "7867:   imgdata.lens.makernotes.CamID = id;",
          "7868:   if ((id == 0x80000001) || // 1D",
          "7869:       (id == 0x80000174) || // 1D2",
          "7870:       (id == 0x80000232) || // 1D2N",
          "7871:       (id == 0x80000169) || // 1D3",
          "7872:       (id == 0x80000281)    // 1D4",
          "7873:       )",
          "7874:   {",
          "7875:     imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSH;",
          "7876:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;",
          "7877:   }",
          "7878:   else if ((id == 0x80000167) || // 1Ds",
          "7879:            (id == 0x80000188) || // 1Ds2",
          "7880:            (id == 0x80000215) || // 1Ds3",
          "7881:            (id == 0x80000269) || // 1DX",
          "7882:            (id == 0x80000328) || // 1DX2",
          "7883:            (id == 0x80000324) || // 1DC",
          "7884:            (id == 0x80000213) || // 5D",
          "7885:            (id == 0x80000218) || // 5D2",
          "7886:            (id == 0x80000285) || // 5D3",
          "7887:            (id == 0x80000349) || // 5D4",
          "7888:            (id == 0x80000382) || // 5DS",
          "7889:            (id == 0x80000401) || // 5DS R",
          "7890:            (id == 0x80000302)    // 6D",
          "7891:            )",
          "7892:   {",
          "7893:     imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;",
          "7894:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;",
          "7895:   }",
          "7896:   else if ((id == 0x80000331) || // M",
          "7897:            (id == 0x80000355) || // M2",
          "7898:            (id == 0x80000374) || // M3",
          "7899:            (id == 0x80000384) || // M10",
          "7900:            (id == 0x80000394)    // M5",
          "7901:            )",
          "7902:   {",
          "7903:     imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;",
          "7904:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF_M;",
          "7905:   }",
          "7906:   else if ((id == 0x01140000) || // D30",
          "7907:            (id == 0x01668000) || // D60",
          "7908:            (id > 0x80000000))",
          "7909:   {",
          "7910:     imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;",
          "7911:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;",
          "7912:     imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Unknown;",
          "7913:   }",
          "7914:   else",
          "7915:   {",
          "7916:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "7917:     imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "7918:   }",
          "7920:   return;",
          "7921: }",
          "7923: void CLASS processCanonCameraInfo(unsigned id, uchar *CameraInfo, unsigned maxlen)",
          "7925:   ushort iCanonLensID = 0, iCanonMaxFocal = 0, iCanonMinFocal = 0, iCanonLens = 0, iCanonCurFocal = 0,",
          "7926:          iCanonFocalType = 0;",
          "7929:   switch (id)",
          "7930:   {",
          "",
          "---------------",
          "--- Hunk 82 ---",
          "[Context before]",
          "7058:     if (!imgdata.lens.makernotes.CurFocal)",
          "7059:       imgdata.lens.makernotes.CurFocal = sget2(CameraInfo + iCanonCurFocal);",
          "7060:     if (!imgdata.lens.makernotes.MinFocal)",
          "7062:     if (!imgdata.lens.makernotes.MaxFocal)",
          "7063:       imgdata.lens.makernotes.MaxFocal = sget2(CameraInfo + iCanonMaxFocal);",
          "7064:     break;",
          "",
          "[Removed Lines]",
          "7061:       imgdata.lens.makernotes.MinFocal  = sget2(CameraInfo + iCanonMinFocal);",
          "",
          "[Added Lines]",
          "7940:       imgdata.lens.makernotes.MinFocal = sget2(CameraInfo + iCanonMinFocal);",
          "",
          "---------------",
          "--- Hunk 83 ---",
          "[Context before]",
          "7097:     break;",
          "7098:   case 0x80000213: // 5D",
          "7099:     iCanonCurFocal = 40;",
          "7102:     iCanonMinFocal = 147;",
          "7103:     iCanonMaxFocal = 149;",
          "7104:     break;",
          "",
          "[Removed Lines]",
          "7100:     if (!sget2Rev(CameraInfo + 12)) iCanonLensID = 151;",
          "7101:     else iCanonLensID = 12;",
          "",
          "[Added Lines]",
          "7979:     if (!sget2Rev(CameraInfo + 12))",
          "7980:       iCanonLensID = 151;",
          "7981:     else",
          "7982:       iCanonLensID = 12;",
          "",
          "---------------",
          "--- Hunk 84 ---",
          "[Context before]",
          "7191:     break;",
          "7192:   }",
          "7193:   if (iCanonFocalType)",
          "7200:   if (!imgdata.lens.makernotes.CurFocal)",
          "7205:   if (!imgdata.lens.makernotes.LensID)",
          "7210:   if (!imgdata.lens.makernotes.MinFocal)",
          "7215:   if (!imgdata.lens.makernotes.MaxFocal)",
          "7216:     {",
          "7219:     }",
          "7226:     else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-S\", 4))",
          "7232:     }",
          "7234:       memcpy(imgdata.lens.makernotes.Lens, \"TS-E \", 5);",
          "7235:       memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"TS-E\", 4);",
          "7236:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "7237:       memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);",
          "7238:     }",
          "7240:       memcpy(imgdata.lens.makernotes.Lens, \"MP-E \", 5);",
          "7241:       memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"MP-E\", 4);",
          "7242:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "7243:       memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);",
          "7244:     }",
          "7246:       memcpy(imgdata.lens.makernotes.Lens, \"EF-M \", 5);",
          "7247:       memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-M\", 4);",
          "7248:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;",
          "7249:       memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);",
          "7250:     }",
          "7252:       memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 2);",
          "7253:       memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF\", 2);",
          "7254:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "",
          "[Removed Lines]",
          "7194:     {",
          "7195:       if(iCanonFocalType>=maxlen) return; // broken;",
          "7196:       imgdata.lens.makernotes.FocalType = CameraInfo[iCanonFocalType];",
          "7197:       if (!imgdata.lens.makernotes.FocalType) // zero means 'fixed' here, replacing with standard '1'",
          "7198:         imgdata.lens.makernotes.FocalType = 1;",
          "7199:     }",
          "7201:     {",
          "7202:       if(iCanonCurFocal>=maxlen) return; // broken;",
          "7203:       imgdata.lens.makernotes.CurFocal = sget2Rev(CameraInfo + iCanonCurFocal);",
          "7204:     }",
          "7206:     {",
          "7207:       if(iCanonLensID>=maxlen) return; // broken;",
          "7208:       imgdata.lens.makernotes.LensID = sget2Rev(CameraInfo + iCanonLensID);",
          "7209:     }",
          "7211:     {",
          "7212:       if(iCanonMinFocal>=maxlen) return; // broken;",
          "7213:       imgdata.lens.makernotes.MinFocal = sget2Rev(CameraInfo + iCanonMinFocal);",
          "7214:     }",
          "7217:       if(iCanonMaxFocal>=maxlen) return; // broken;",
          "7218:       imgdata.lens.makernotes.MaxFocal = sget2Rev(CameraInfo + iCanonMaxFocal);",
          "7220:   if (!imgdata.lens.makernotes.Lens[0] && iCanonLens) {",
          "7221:     if(iCanonLens+64>=maxlen) return; // broken;",
          "7222:     if (CameraInfo[iCanonLens] < 65)        // non-Canon lens",
          "7223:       {",
          "7224:         memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 64);",
          "7225:       }",
          "7227:       {",
          "7228:         memcpy(imgdata.lens.makernotes.Lens, \"EF-S \", 5);",
          "7229:         memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-E\", 4);",
          "7230:         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;",
          "7231:         memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);",
          "7233:     else if (!strncmp((char *)CameraInfo + iCanonLens, \"TS-E\", 4)) {",
          "7239:     else if (!strncmp((char *)CameraInfo + iCanonLens, \"MP-E\", 4)) {",
          "7245:     else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-M\", 4)) {",
          "7251:     else {",
          "",
          "[Added Lines]",
          "8075:   {",
          "8076:     if (iCanonFocalType >= maxlen)",
          "8077:       return; // broken;",
          "8078:     imgdata.lens.makernotes.FocalType = CameraInfo[iCanonFocalType];",
          "8079:     if (!imgdata.lens.makernotes.FocalType) // zero means 'fixed' here, replacing with standard '1'",
          "8080:       imgdata.lens.makernotes.FocalType = 1;",
          "8081:   }",
          "8083:   {",
          "8084:     if (iCanonCurFocal >= maxlen)",
          "8085:       return; // broken;",
          "8086:     imgdata.lens.makernotes.CurFocal = sget2Rev(CameraInfo + iCanonCurFocal);",
          "8087:   }",
          "8089:   {",
          "8090:     if (iCanonLensID >= maxlen)",
          "8091:       return; // broken;",
          "8092:     imgdata.lens.makernotes.LensID = sget2Rev(CameraInfo + iCanonLensID);",
          "8093:   }",
          "8095:   {",
          "8096:     if (iCanonMinFocal >= maxlen)",
          "8097:       return; // broken;",
          "8098:     imgdata.lens.makernotes.MinFocal = sget2Rev(CameraInfo + iCanonMinFocal);",
          "8099:   }",
          "8101:   {",
          "8102:     if (iCanonMaxFocal >= maxlen)",
          "8103:       return; // broken;",
          "8104:     imgdata.lens.makernotes.MaxFocal = sget2Rev(CameraInfo + iCanonMaxFocal);",
          "8105:   }",
          "8106:   if (!imgdata.lens.makernotes.Lens[0] && iCanonLens)",
          "8107:   {",
          "8108:     if (iCanonLens + 64 >= maxlen)",
          "8109:       return;                        // broken;",
          "8110:     if (CameraInfo[iCanonLens] < 65) // non-Canon lens",
          "8112:       memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 64);",
          "8115:     {",
          "8116:       memcpy(imgdata.lens.makernotes.Lens, \"EF-S \", 5);",
          "8117:       memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-E\", 4);",
          "8118:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;",
          "8119:       memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);",
          "8121:     else if (!strncmp((char *)CameraInfo + iCanonLens, \"TS-E\", 4))",
          "8122:     {",
          "8128:     else if (!strncmp((char *)CameraInfo + iCanonLens, \"MP-E\", 4))",
          "8129:     {",
          "8135:     else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-M\", 4))",
          "8136:     {",
          "8142:     else",
          "8143:     {",
          "",
          "---------------",
          "--- Hunk 85 ---",
          "[Context before]",
          "7259:   return;",
          "7260: }",
          "7263: {",
          "7264:   fseek(ifp, 10, SEEK_CUR);",
          "7266:   imgdata.shootinginfo.FocusMode = get2();",
          "7267:   fseek(ifp, 18, SEEK_CUR);",
          "7269:   imgdata.shootinginfo.AFPoint = get2();",
          "7271:   imgdata.lens.makernotes.LensID = get2();",
          "7272:   imgdata.lens.makernotes.MaxFocal = get2();",
          "7273:   imgdata.lens.makernotes.MinFocal = get2();",
          "7274:   imgdata.lens.makernotes.CanonFocalUnits = get2();",
          "7275:   if (imgdata.lens.makernotes.CanonFocalUnits > 1)",
          "7280:   imgdata.lens.makernotes.MaxAp = _CanonConvertAperture(get2());",
          "7281:   imgdata.lens.makernotes.MinAp = _CanonConvertAperture(get2());",
          "7282:   fseek(ifp, 12, SEEK_CUR);",
          "7283:   imgdata.shootinginfo.ImageStabilization = get2();",
          "7284: }",
          "7287: {",
          "7288:   int c;",
          "7289:   FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();",
          "7291:   FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();",
          "7293:   FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();",
          "7295:   FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();",
          "7297:   FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();",
          "7299:   FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();",
          "7300:   return;",
          "7301: }",
          "7304: {",
          "7349: }",
          "7352: {",
          "7353:   ushort i;",
          "7354:   if (!(imgdata.lens.nikon.NikonLensType & 0x01))",
          "7359:   else",
          "7365:   if (imgdata.lens.nikon.NikonLensType & 0x02)",
          "7374:   if (imgdata.lens.nikon.NikonLensType & 0x08)",
          "7380:   if (imgdata.lens.nikon.NikonLensType & 0x10)",
          "7381:   {",
          "",
          "[Removed Lines]",
          "7262: void CLASS Canon_CameraSettings ()",
          "7265:   imgdata.shootinginfo.DriveMode = get2(); get2();",
          "7268:   imgdata.shootinginfo.MeteringMode = get2(); get2();",
          "7270:   imgdata.shootinginfo.ExposureMode = get2(); get2();",
          "7276:     {",
          "7277:       imgdata.lens.makernotes.MaxFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "7278:       imgdata.lens.makernotes.MinFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "7279:     }",
          "7286: void CLASS Canon_WBpresets (int skip1, int skip2)",
          "7290:   if (skip1) fseek(ifp, skip1, SEEK_CUR);",
          "7292:   if (skip1) fseek(ifp, skip1, SEEK_CUR);",
          "7294:   if (skip1) fseek(ifp, skip1, SEEK_CUR);",
          "7296:   if (skip1) fseek(ifp, skip1, SEEK_CUR);",
          "7298:   if (skip2) fseek(ifp, skip2, SEEK_CUR);",
          "7303: void CLASS Canon_WBCTpresets (short WBCTversion)",
          "7305:  if (WBCTversion == 0)",
          "7306:    for (int i=0; i<15; i++)// tint, as shot R, as shot B, C\u0421T",
          "7307:      {",
          "7308:   imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;",
          "7309:   fseek (ifp, 2, SEEK_CUR);",
          "7310:   imgdata.color.WBCT_Coeffs[i][1] = 1024.0f /fMAX(get2(),1.f) ;",
          "7311:   imgdata.color.WBCT_Coeffs[i][3] = 1024.0f /fMAX(get2(),1.f);",
          "7312:   imgdata.color.WBCT_Coeffs[i][0] = get2();",
          "7313:      }",
          "7314:  else if (WBCTversion == 1)",
          "7315:    for (int i=0; i<15; i++) // as shot R, as shot B, tint, C\u0421T",
          "7316:      {",
          "7317:   imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;",
          "7318:   imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(get2(),1.f);",
          "7319:   imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(get2(),1.f);",
          "7320:   fseek (ifp, 2, SEEK_CUR);",
          "7321:   imgdata.color.WBCT_Coeffs[i][0] = get2();",
          "7322:      }",
          "7323:  else if ((WBCTversion == 2) &&",
          "7324:   ((unique_id == 0x80000374) || // M3",
          "7325:    (unique_id == 0x80000384) || // M10",
          "7326:    (unique_id == 0x80000394) || // M5",
          "7327:    (unique_id == 0x03970000))) // G7 X Mark II",
          "7328:    for (int i=0; i<15; i++) // tint, offset, as shot R, as shot B, C\u0421T",
          "7329:      {",
          "7330:   fseek (ifp, 2, SEEK_CUR);",
          "7331:   fseek (ifp, 2, SEEK_CUR);",
          "7332:   imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;",
          "7333:   imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(1.f,get2());",
          "7334:   imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(1.f,get2());",
          "7335:   imgdata.color.WBCT_Coeffs[i][0] = get2();",
          "7336:      }",
          "7337:  else if ((WBCTversion == 2) &&",
          "7338:                 ((unique_id == 0x03950000) || (unique_id == 0x03930000))) // G5 X, G9 X",
          "7339:    for (int i=0; i<15; i++) // tint, offset, as shot R, as shot B, C\u0421T",
          "7340:      {",
          "7341:   fseek (ifp, 2, SEEK_CUR);",
          "7342:   fseek (ifp, 2, SEEK_CUR);",
          "7343:   imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;",
          "7344:   imgdata.color.WBCT_Coeffs[i][1] = (float)get2() / 512.0f;",
          "7345:   imgdata.color.WBCT_Coeffs[i][3] = (float)get2() / 512.0f;",
          "7346:   imgdata.color.WBCT_Coeffs[i][0] = get2();",
          "7347:      }",
          "7348:  return;",
          "7351: void CLASS processNikonLensData (uchar *LensData, unsigned len)",
          "7355:     {",
          "7356:       imgdata.lens.makernotes.LensFeatures_pre[0] = 'A';",
          "7357:       imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';",
          "7358:     }",
          "7360:     {",
          "7361:       imgdata.lens.makernotes.LensFeatures_pre[0] = 'M';",
          "7362:       imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';",
          "7363:     }",
          "7366:     {",
          "7367:       if (imgdata.lens.nikon.NikonLensType & 0x04)",
          "7368:         imgdata.lens.makernotes.LensFeatures_suf[0] = 'G';",
          "7369:       else",
          "7370:         imgdata.lens.makernotes.LensFeatures_suf[0] = 'D';",
          "7371:       imgdata.lens.makernotes.LensFeatures_suf[1] = ' ';",
          "7372:     }",
          "7375:     {",
          "7376:       imgdata.lens.makernotes.LensFeatures_suf[2] = 'V';",
          "7377:       imgdata.lens.makernotes.LensFeatures_suf[3] = 'R';",
          "7378:     }",
          "",
          "[Added Lines]",
          "8154: void CLASS Canon_CameraSettings()",
          "8157:   imgdata.shootinginfo.DriveMode = get2();",
          "8158:   get2();",
          "8161:   imgdata.shootinginfo.MeteringMode = get2();",
          "8162:   get2();",
          "8164:   imgdata.shootinginfo.ExposureMode = get2();",
          "8165:   get2();",
          "8171:   {",
          "8172:     imgdata.lens.makernotes.MaxFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "8173:     imgdata.lens.makernotes.MinFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "8174:   }",
          "8181: void CLASS Canon_WBpresets(int skip1, int skip2)",
          "8185:   if (skip1)",
          "8186:     fseek(ifp, skip1, SEEK_CUR);",
          "8188:   if (skip1)",
          "8189:     fseek(ifp, skip1, SEEK_CUR);",
          "8191:   if (skip1)",
          "8192:     fseek(ifp, skip1, SEEK_CUR);",
          "8194:   if (skip1)",
          "8195:     fseek(ifp, skip1, SEEK_CUR);",
          "8197:   if (skip2)",
          "8198:     fseek(ifp, skip2, SEEK_CUR);",
          "8203: void CLASS Canon_WBCTpresets(short WBCTversion)",
          "8205:   if (WBCTversion == 0)",
          "8206:     for (int i = 0; i < 15; i++) // tint, as shot R, as shot B, C\u0421T",
          "8207:     {",
          "8208:       imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;",
          "8209:       fseek(ifp, 2, SEEK_CUR);",
          "8210:       imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(get2(), 1.f);",
          "8211:       imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(get2(), 1.f);",
          "8212:       imgdata.color.WBCT_Coeffs[i][0] = get2();",
          "8213:     }",
          "8214:   else if (WBCTversion == 1)",
          "8215:     for (int i = 0; i < 15; i++) // as shot R, as shot B, tint, C\u0421T",
          "8216:     {",
          "8217:       imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;",
          "8218:       imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(get2(), 1.f);",
          "8219:       imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(get2(), 1.f);",
          "8220:       fseek(ifp, 2, SEEK_CUR);",
          "8221:       imgdata.color.WBCT_Coeffs[i][0] = get2();",
          "8222:     }",
          "8223:   else if ((WBCTversion == 2) && ((unique_id == 0x80000374) || // M3",
          "8224:                                   (unique_id == 0x80000384) || // M10",
          "8225:                                   (unique_id == 0x80000394) || // M5",
          "8226:                                   (unique_id == 0x03970000)))  // G7 X Mark II",
          "8227:     for (int i = 0; i < 15; i++)                               // tint, offset, as shot R, as shot B, C\u0421T",
          "8228:     {",
          "8229:       fseek(ifp, 2, SEEK_CUR);",
          "8230:       fseek(ifp, 2, SEEK_CUR);",
          "8231:       imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;",
          "8232:       imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(1.f, get2());",
          "8233:       imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(1.f, get2());",
          "8234:       imgdata.color.WBCT_Coeffs[i][0] = get2();",
          "8235:     }",
          "8236:   else if ((WBCTversion == 2) && ((unique_id == 0x03950000) || (unique_id == 0x03930000))) // G5 X, G9 X",
          "8237:     for (int i = 0; i < 15; i++) // tint, offset, as shot R, as shot B, C\u0421T",
          "8238:     {",
          "8239:       fseek(ifp, 2, SEEK_CUR);",
          "8240:       fseek(ifp, 2, SEEK_CUR);",
          "8241:       imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;",
          "8242:       imgdata.color.WBCT_Coeffs[i][1] = (float)get2() / 512.0f;",
          "8243:       imgdata.color.WBCT_Coeffs[i][3] = (float)get2() / 512.0f;",
          "8244:       imgdata.color.WBCT_Coeffs[i][0] = get2();",
          "8245:     }",
          "8246:   return;",
          "8249: void CLASS processNikonLensData(uchar *LensData, unsigned len)",
          "8253:   {",
          "8254:     imgdata.lens.makernotes.LensFeatures_pre[0] = 'A';",
          "8255:     imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';",
          "8256:   }",
          "8258:   {",
          "8259:     imgdata.lens.makernotes.LensFeatures_pre[0] = 'M';",
          "8260:     imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';",
          "8261:   }",
          "8264:   {",
          "8265:     if (imgdata.lens.nikon.NikonLensType & 0x04)",
          "8266:       imgdata.lens.makernotes.LensFeatures_suf[0] = 'G';",
          "8267:     else",
          "8268:       imgdata.lens.makernotes.LensFeatures_suf[0] = 'D';",
          "8269:     imgdata.lens.makernotes.LensFeatures_suf[1] = ' ';",
          "8270:   }",
          "8273:   {",
          "8274:     imgdata.lens.makernotes.LensFeatures_suf[2] = 'V';",
          "8275:     imgdata.lens.makernotes.LensFeatures_suf[3] = 'R';",
          "8276:   }",
          "",
          "---------------",
          "--- Hunk 86 ---",
          "[Context before]",
          "7396:   imgdata.lens.nikon.NikonLensType = imgdata.lens.nikon.NikonLensType & 0xdf;",
          "7400:     case 9:",
          "7401:       i = 2;",
          "7402:       break;",
          "",
          "[Removed Lines]",
          "7398:   if (len < 20) {",
          "7399:     switch (len) {",
          "",
          "[Added Lines]",
          "8296:   if (len < 20)",
          "8297:   {",
          "8298:     switch (len)",
          "8299:     {",
          "",
          "---------------",
          "--- Hunk 87 ---",
          "[Context before]",
          "7409:     }",
          "7410:     imgdata.lens.nikon.NikonLensIDNumber = LensData[i];",
          "7411:     imgdata.lens.nikon.NikonLensFStops = LensData[i + 1];",
          "7413:     if (fabsf(imgdata.lens.makernotes.MinFocal) < 1.1f)",
          "7414:     {",
          "7415:       if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 2])",
          "",
          "[Removed Lines]",
          "7412:     imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops /12.0f;",
          "",
          "[Added Lines]",
          "8312:     imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops / 12.0f;",
          "",
          "---------------",
          "--- Hunk 88 ---",
          "[Context before]",
          "7423:     }",
          "7424:     imgdata.lens.nikon.NikonMCUVersion = LensData[i + 6];",
          "7425:     if (i != 2)",
          "7432:     imgdata.lens.makernotes.LensID =",
          "7442:   }",
          "7443:   else if ((len == 459) || (len == 590))",
          "7447:   else if (len == 509)",
          "7451:   else if (len == 879)",
          "7455:   return;",
          "7456: }",
          "7459: {",
          "7460:   imgdata.lens.makernotes.CamID = id;",
          "7463:       ((id & 0x00ffff0000ULL) == 0x0030300000ULL))",
          "7464:   {",
          "7480:   }",
          "7481:   else",
          "7482:   {",
          "7485:   }",
          "7486:   return;",
          "7487: }",
          "7579:       {",
          "7768:       }",
          "7769: }",
          "7772: {",
          "7773:   imgdata.lens.makernotes.CamID = id;",
          "7776:   case 0x12994:",
          "7777:   case 0x12aa2:",
          "7778:   case 0x12b1a:",
          "",
          "[Removed Lines]",
          "7426:       {",
          "7427:         if ((LensData[i - 1]) &&",
          "7428:             (fabsf(imgdata.lens.makernotes.CurFocal) < 1.1f))",
          "7429:           imgdata.lens.makernotes.CurFocal = 5.0f * powf64(2.0f, (float)LensData[i - 1] / 24.0f);",
          "7430:         if (LensData[i + 7]) imgdata.lens.nikon.NikonEffectiveMaxAp = powf64(2.0f, (float)LensData[i + 7] / 24.0f);",
          "7431:       }",
          "7433:       (unsigned long long) LensData[i] << 56 |",
          "7434:       (unsigned long long) LensData[i + 1] << 48 |",
          "7435:       (unsigned long long) LensData[i + 2] << 40 |",
          "7436:       (unsigned long long) LensData[i + 3] << 32 |",
          "7437:       (unsigned long long) LensData[i + 4] << 24 |",
          "7438:       (unsigned long long) LensData[i + 5] << 16 |",
          "7439:       (unsigned long long) LensData[i + 6] << 8 |",
          "7440:       (unsigned long long) imgdata.lens.nikon.NikonLensType;",
          "7444:     {",
          "7445:       memcpy(imgdata.lens.makernotes.Lens, LensData + 390, 64);",
          "7446:     }",
          "7448:     {",
          "7449:       memcpy(imgdata.lens.makernotes.Lens, LensData + 391, 64);",
          "7450:     }",
          "7452:     {",
          "7453:       memcpy(imgdata.lens.makernotes.Lens, LensData + 680, 64);",
          "7454:     }",
          "7458: void CLASS setOlympusBodyFeatures (unsigned long long id)",
          "7461:   if ((id == 0x4434303430ULL) || // E-1",
          "7462:       (id == 0x4434303431ULL) || // E-300",
          "7465:       imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FT;",
          "7466:    if ((id == 0x4434303430ULL) || // E-1",
          "7467:          (id == 0x4434303431ULL) || // E-330",
          "7468:          ((id >= 0x5330303033ULL) && (id <= 0x5330303138ULL)) || // E-330 to E-520",
          "7469:          (id == 0x5330303233ULL) || // E-620",
          "7470:          (id == 0x5330303239ULL) || // E-450",
          "7471:          (id == 0x5330303330ULL) || // E-600",
          "7472:          (id == 0x5330303333ULL))  // E-5",
          "7473:       {",
          "7474:        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FT;",
          "7475:       }",
          "7476:    else",
          "7477:       {",
          "7478:         imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_mFT;",
          "7479:       }",
          "7483:       imgdata.lens.makernotes.LensMount =",
          "7484:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "7489: void CLASS parseCanonMakernotes (unsigned tag, unsigned type, unsigned len) {",
          "7491: if (tag == 0x0001) Canon_CameraSettings();",
          "7492:         else if (tag == 0x0002)   // focal length",
          "7493:           {",
          "7494:             imgdata.lens.makernotes.FocalType = get2();",
          "7495:             imgdata.lens.makernotes.CurFocal = get2();",
          "7496:             if (imgdata.lens.makernotes.CanonFocalUnits > 1)",
          "7497:               {",
          "7498:                 imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "7499:               }",
          "7500:           }",
          "7502:         else if (tag == 0x0004)   // shot info",
          "7503:           {",
          "7504:             short tempAp;",
          "7505:             fseek(ifp, 30, SEEK_CUR);",
          "7506:             imgdata.other.FlashEC = _CanonConvertEV((signed short)get2());",
          "7507:             fseek(ifp, 8-32, SEEK_CUR);",
          "7508:             if ((tempAp = get2()) != 0x7fff)",
          "7509:               imgdata.lens.makernotes.CurAp = _CanonConvertAperture(tempAp);",
          "7510:             if (imgdata.lens.makernotes.CurAp < 0.7f)",
          "7511:             {",
          "7512:               fseek(ifp, 32, SEEK_CUR);",
          "7513:               imgdata.lens.makernotes.CurAp = _CanonConvertAperture(get2());",
          "7514:             }",
          "7515:             if (!aperture) aperture = imgdata.lens.makernotes.CurAp;",
          "7516:           }",
          "7518:         else if (tag == 0x0095 &&  // lens model tag",
          "7519:                  !imgdata.lens.makernotes.Lens[0])",
          "7520:           {",
          "7521:             fread(imgdata.lens.makernotes.Lens, 2, 1, ifp);",
          "7522:             imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "7523:             if (imgdata.lens.makernotes.Lens[0] < 65)     // non-Canon lens",
          "7524:               fread(imgdata.lens.makernotes.Lens + 2, 62, 1, ifp);",
          "7525:             else",
          "7526:               {",
          "7527:                 char efs[2];",
          "7528:                 imgdata.lens.makernotes.LensFeatures_pre[0] = imgdata.lens.makernotes.Lens[0];",
          "7529:                 imgdata.lens.makernotes.LensFeatures_pre[1] = imgdata.lens.makernotes.Lens[1];",
          "7530:                 fread(efs, 2, 1, ifp);",
          "7531:                 if (efs[0] == 45 && (efs[1] == 83 || efs[1] == 69 || efs[1] == 77))",
          "7532:                   { // \"EF-S, TS-E, MP-E, EF-M\" lenses",
          "7533:                     imgdata.lens.makernotes.Lens[2] = imgdata.lens.makernotes.LensFeatures_pre[2] = efs[0];",
          "7534:                     imgdata.lens.makernotes.Lens[3] = imgdata.lens.makernotes.LensFeatures_pre[3] = efs[1];",
          "7535:                     imgdata.lens.makernotes.Lens[4] = 32;",
          "7536:                     if (efs[1] == 83)",
          "7537:                       {",
          "7538:                         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;",
          "7539:                         imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;",
          "7540:                       }",
          "7541:                     else if (efs[1] == 77)",
          "7542:                       {",
          "7543:                         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;",
          "7544:                       }",
          "7545:                   }",
          "7546:                 else",
          "7547:                   {                // \"EF\" lenses",
          "7548:                     imgdata.lens.makernotes.Lens[2] = 32;",
          "7549:                     imgdata.lens.makernotes.Lens[3] = efs[0];",
          "7550:                     imgdata.lens.makernotes.Lens[4] = efs[1];",
          "7551:                   }",
          "7552:                 fread(imgdata.lens.makernotes.Lens + 5, 58, 1, ifp);",
          "7553:               }",
          "7554:           }",
          "7556:         else if (tag == 0x00a9)",
          "7557:           {",
          "7558:             long int save1 = ftell(ifp);",
          "7559:             fseek (ifp, save1+(0x5<<1), SEEK_SET);",
          "7560:             Canon_WBpresets(0,0);",
          "7561:             fseek (ifp, save1, SEEK_SET);",
          "7562:           }",
          "7564:         else if (tag == 0x00e0)   // sensor info",
          "7565:           {",
          "7566:             imgdata.makernotes.canon.SensorWidth           = (get2(),get2());",
          "7567:             imgdata.makernotes.canon.SensorHeight          = get2();",
          "7568:             imgdata.makernotes.canon.SensorLeftBorder      = (get2(),get2(),get2());",
          "7569:             imgdata.makernotes.canon.SensorTopBorder       = get2();",
          "7570:             imgdata.makernotes.canon.SensorRightBorder     = get2();",
          "7571:             imgdata.makernotes.canon.SensorBottomBorder    = get2();",
          "7572:             imgdata.makernotes.canon.BlackMaskLeftBorder   = get2();",
          "7573:             imgdata.makernotes.canon.BlackMaskTopBorder    = get2();",
          "7574:             imgdata.makernotes.canon.BlackMaskRightBorder  = get2();",
          "7575:             imgdata.makernotes.canon.BlackMaskBottomBorder = get2();",
          "7576:           }",
          "7578:     else if (tag == 0x4001 && len > 500)",
          "7580:         int c;",
          "7581:         long int save1 = ftell(ifp);",
          "7582:         switch (len)",
          "7583:           {",
          "7584:           case 582:",
          "7585:             imgdata.makernotes.canon.CanonColorDataVer = 1; // 20D / 350D",
          "7586:             {",
          "7587:              fseek (ifp, save1+(0x23<<1), SEEK_SET);",
          "7588:              Canon_WBpresets(2,2);",
          "7589:              fseek (ifp, save1+(0x4b<<1), SEEK_SET);",
          "7590:                Canon_WBCTpresets (1); // ABCT",
          "7591:             }",
          "7592:             break;",
          "7593:           case 653:",
          "7594:             imgdata.makernotes.canon.CanonColorDataVer = 2; // 1Dmk2 / 1DsMK2",
          "7595:             {",
          "7596:              fseek (ifp, save1+(0x27<<1), SEEK_SET);",
          "7597:              Canon_WBpresets(2,12);",
          "7598:              fseek (ifp, save1+(0xa4<<1), SEEK_SET);",
          "7599:                Canon_WBCTpresets (1); // ABCT",
          "7600:             }",
          "7601:             break;",
          "7602:           case 796:",
          "7603:             imgdata.makernotes.canon.CanonColorDataVer = 3; // 1DmkIIN / 5D / 30D / 400D",
          "7604:      imgdata.makernotes.canon.CanonColorDataSubVer = get2();",
          "7605:      {",
          "7606:        fseek (ifp, save1+(0x4e<<1), SEEK_SET);",
          "7607:        Canon_WBpresets(2,12);",
          "7608:        fseek (ifp, save1+(0x85<<1), SEEK_SET);",
          "7609:        Canon_WBCTpresets (0); // BCAT",
          "7610:        fseek (ifp, save1+(0x0c4<<1), SEEK_SET); // offset 196 short",
          "7611:        int bls=0;",
          "7612:        FORC4",
          "7613:   bls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());",
          "7614:        imgdata.makernotes.canon.AverageBlackLevel = bls/4;",
          "7615:      }",
          "7616:      break;",
          "7620:           case 674: case 692: case 702: case 1227: case 1250:",
          "7621:           case 1251: case 1337: case 1338: case 1346:",
          "7622:             imgdata.makernotes.canon.CanonColorDataVer = 4;",
          "7623:             imgdata.makernotes.canon.CanonColorDataSubVer = get2();",
          "7624:             {",
          "7625:        fseek (ifp, save1+(0x53<<1), SEEK_SET);",
          "7626:        Canon_WBpresets(2,12);",
          "7627:        fseek (ifp, save1+(0xa8<<1), SEEK_SET);",
          "7628:        Canon_WBCTpresets (0); // BCAT",
          "7629:               fseek (ifp, save1+(0x0e7<<1), SEEK_SET); // offset 231 short",
          "7630:               int bls=0;",
          "7631:               FORC4",
          "7632:   bls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());",
          "7633:               imgdata.makernotes.canon.AverageBlackLevel = bls/4;",
          "7634:             }",
          "7635:             if ((imgdata.makernotes.canon.CanonColorDataSubVer == 4)",
          "7636:                 || (imgdata.makernotes.canon.CanonColorDataSubVer == 5))",
          "7637:               {",
          "7638:                 fseek (ifp, save1+(0x2b9<<1), SEEK_SET);  // offset 697 shorts",
          "7639:                 imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "7640:                 FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "7641:               }",
          "7642:             else if ((imgdata.makernotes.canon.CanonColorDataSubVer == 6) ||",
          "7643:                      (imgdata.makernotes.canon.CanonColorDataSubVer == 7))",
          "7644:               {",
          "7645:                 fseek (ifp, save1+(0x2d0<<1), SEEK_SET);  // offset 720 shorts",
          "7646:                 imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "7647:                 FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "7648:               }",
          "7649:             else if (imgdata.makernotes.canon.CanonColorDataSubVer == 9)",
          "7650:               {",
          "7651:                 fseek (ifp, save1+(0x2d4<<1), SEEK_SET);  // offset 724 shorts",
          "7652:                 imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "7653:                 FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "7654:               }",
          "7655:             break;",
          "7657:           case 5120:",
          "7658:             imgdata.makernotes.canon.CanonColorDataVer = 5; // PowerSot G10, G12, G5 X, EOS M3, EOS M5",
          "7659:             {",
          "7660:               fseek (ifp, save1+(0x56<<1), SEEK_SET);",
          "7661:               if ((unique_id == 0x03970000) || // G7 X Mark II",
          "7662:                   (unique_id == 0x80000394))   // EOS M5",
          "7663:               {",
          "7664:                 fseek(ifp, 18, SEEK_CUR);",
          "7665:                 FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();",
          "7666:                 fseek(ifp, 8, SEEK_CUR);",
          "7667:                 Canon_WBpresets(8,24);",
          "7668:                 fseek(ifp, 168, SEEK_CUR);",
          "7669:                 FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ (c >> 1)] = get2();",
          "7670:                 fseek(ifp, 24, SEEK_CUR);",
          "7671:                 Canon_WBCTpresets (2);  // BCADT",
          "7672:                 fseek(ifp, 6, SEEK_CUR);",
          "7673:               }",
          "7674:               else",
          "7675:               {",
          "7676:                 FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();",
          "7677:                 get2();",
          "7678:                 Canon_WBpresets(2,12);",
          "7679:                 fseek (ifp, save1+(0xba<<1), SEEK_SET);",
          "7680:                 Canon_WBCTpresets (2);  // BCADT",
          "7681:                 fseek (ifp, save1+(0x108<<1), SEEK_SET);  // offset 264 short",
          "7682:               }",
          "7683:               int bls=0;",
          "7684:               FORC4",
          "7685:   bls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());",
          "7686:               imgdata.makernotes.canon.AverageBlackLevel = bls/4;",
          "7687:             }",
          "7688:             break;",
          "7690:           case 1273: case 1275:",
          "7691:             imgdata.makernotes.canon.CanonColorDataVer = 6; // 600D / 1200D",
          "7692:             imgdata.makernotes.canon.CanonColorDataSubVer = get2();",
          "7693:             {",
          "7694:               fseek (ifp, save1+(0x67<<1), SEEK_SET);",
          "7695:               Canon_WBpresets(2,12);",
          "7696:               fseek (ifp, save1+(0xbc<<1), SEEK_SET);",
          "7697:               Canon_WBCTpresets (0); // BCAT",
          "7698:               fseek (ifp, save1+(0x0fb<<1), SEEK_SET);   // offset 251 short",
          "7699:               int bls=0;",
          "7700:               FORC4",
          "7701:   bls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());",
          "7702:               imgdata.makernotes.canon.AverageBlackLevel = bls/4;",
          "7703:             }",
          "7704:             fseek (ifp, save1+(0x1e4<<1), SEEK_SET);   // offset 484 shorts",
          "7705:             imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "7706:             FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "7707:             break;",
          "7710:           case 1312: case 1313: case 1316: case 1506:",
          "7711:             imgdata.makernotes.canon.CanonColorDataVer = 7;",
          "7712:             imgdata.makernotes.canon.CanonColorDataSubVer = get2();",
          "7713:             {",
          "7714:               fseek (ifp, save1+(0x80<<1), SEEK_SET);",
          "7715:               Canon_WBpresets(2,12);",
          "7716:               fseek (ifp, save1+(0xd5<<1), SEEK_SET);",
          "7717:               Canon_WBCTpresets (0); // BCAT",
          "7718:               fseek (ifp, save1+(0x114<<1), SEEK_SET);   // offset 276 shorts",
          "7719:               int bls=0;",
          "7720:               FORC4",
          "7721:   bls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());",
          "7722:               imgdata.makernotes.canon.AverageBlackLevel = bls/4;",
          "7723:             }",
          "7724:             if (imgdata.makernotes.canon.CanonColorDataSubVer == 10)",
          "7725:               {",
          "7726:                 fseek (ifp, save1+(0x1fd<<1), SEEK_SET);  // offset 509 shorts",
          "7727:                 imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "7728:                 FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "7729:               } else if (imgdata.makernotes.canon.CanonColorDataSubVer == 11)",
          "7730:               {",
          "7731:                 fseek (ifp, save1+(0x2dd<<1), SEEK_SET);  // offset 733 shorts",
          "7732:                 imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "7733:                 FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "7734:               }",
          "7735:             break;",
          "7738:           case 1560: case 1592: case 1353:",
          "7739:             imgdata.makernotes.canon.CanonColorDataVer = 8;",
          "7740:             imgdata.makernotes.canon.CanonColorDataSubVer = get2();",
          "7741:             {",
          "7742:               fseek (ifp, save1+(0x85<<1), SEEK_SET);",
          "7743:               Canon_WBpresets(2,12);",
          "7744:               fseek (ifp, save1+(0x107<<1), SEEK_SET);",
          "7745:               Canon_WBCTpresets (0); // BCAT",
          "7746:               fseek (ifp, save1+(0x146<<1), SEEK_SET);   // offset 326 shorts",
          "7747:               int bls=0;",
          "7748:               FORC4",
          "7749:   bls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());",
          "7750:               imgdata.makernotes.canon.AverageBlackLevel = bls/4;",
          "7751:             }",
          "7752:               if (imgdata.makernotes.canon.CanonColorDataSubVer == 14)  // 1300D",
          "7753:                 {",
          "7754:                   fseek (ifp, save1+(0x231<<1), SEEK_SET);",
          "7755:                   imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "7756:                   FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "7757:                 }",
          "7758:               else",
          "7759:                 {",
          "7760:                   fseek (ifp, save1+(0x30f<<1), SEEK_SET);  // offset 783 shorts",
          "7761:                   imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "7762:                   FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "7763:                 }",
          "7764:             break;",
          "7766:           }",
          "7767:         fseek (ifp, save1, SEEK_SET);",
          "7771: void CLASS setPentaxBodyFeatures (unsigned id)",
          "7775:   switch (id) {",
          "",
          "[Added Lines]",
          "8326:     {",
          "8327:       if ((LensData[i - 1]) && (fabsf(imgdata.lens.makernotes.CurFocal) < 1.1f))",
          "8328:         imgdata.lens.makernotes.CurFocal = 5.0f * powf64(2.0f, (float)LensData[i - 1] / 24.0f);",
          "8329:       if (LensData[i + 7])",
          "8330:         imgdata.lens.nikon.NikonEffectiveMaxAp = powf64(2.0f, (float)LensData[i + 7] / 24.0f);",
          "8331:     }",
          "8333:         (unsigned long long)LensData[i] << 56 | (unsigned long long)LensData[i + 1] << 48 |",
          "8334:         (unsigned long long)LensData[i + 2] << 40 | (unsigned long long)LensData[i + 3] << 32 |",
          "8335:         (unsigned long long)LensData[i + 4] << 24 | (unsigned long long)LensData[i + 5] << 16 |",
          "8336:         (unsigned long long)LensData[i + 6] << 8 | (unsigned long long)imgdata.lens.nikon.NikonLensType;",
          "8339:   {",
          "8340:     memcpy(imgdata.lens.makernotes.Lens, LensData + 390, 64);",
          "8341:   }",
          "8343:   {",
          "8344:     memcpy(imgdata.lens.makernotes.Lens, LensData + 391, 64);",
          "8345:   }",
          "8347:   {",
          "8348:     memcpy(imgdata.lens.makernotes.Lens, LensData + 680, 64);",
          "8349:   }",
          "8353: void CLASS setOlympusBodyFeatures(unsigned long long id)",
          "8356:   if ((id == 0x4434303430ULL) || // E-1",
          "8357:       (id == 0x4434303431ULL) || // E-300",
          "8360:     imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FT;",
          "8361:     if ((id == 0x4434303430ULL) ||                              // E-1",
          "8362:         (id == 0x4434303431ULL) ||                              // E-330",
          "8363:         ((id >= 0x5330303033ULL) && (id <= 0x5330303138ULL)) || // E-330 to E-520",
          "8364:         (id == 0x5330303233ULL) ||                              // E-620",
          "8365:         (id == 0x5330303239ULL) ||                              // E-450",
          "8366:         (id == 0x5330303330ULL) ||                              // E-600",
          "8367:         (id == 0x5330303333ULL))                                // E-5",
          "8368:     {",
          "8369:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FT;",
          "8370:     }",
          "8371:     else",
          "8372:     {",
          "8373:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_mFT;",
          "8374:     }",
          "8378:     imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "8383: void CLASS parseCanonMakernotes(unsigned tag, unsigned type, unsigned len)",
          "8384: {",
          "8386:   if (tag == 0x0001)",
          "8387:     Canon_CameraSettings();",
          "8388:   else if (tag == 0x0002) // focal length",
          "8389:   {",
          "8390:     imgdata.lens.makernotes.FocalType = get2();",
          "8391:     imgdata.lens.makernotes.CurFocal = get2();",
          "8392:     if (imgdata.lens.makernotes.CanonFocalUnits > 1)",
          "8393:     {",
          "8394:       imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "8395:     }",
          "8396:   }",
          "8398:   else if (tag == 0x0004) // shot info",
          "8399:   {",
          "8400:     short tempAp;",
          "8401:     fseek(ifp, 30, SEEK_CUR);",
          "8402:     imgdata.other.FlashEC = _CanonConvertEV((signed short)get2());",
          "8403:     fseek(ifp, 8 - 32, SEEK_CUR);",
          "8404:     if ((tempAp = get2()) != 0x7fff)",
          "8405:       imgdata.lens.makernotes.CurAp = _CanonConvertAperture(tempAp);",
          "8406:     if (imgdata.lens.makernotes.CurAp < 0.7f)",
          "8407:     {",
          "8408:       fseek(ifp, 32, SEEK_CUR);",
          "8409:       imgdata.lens.makernotes.CurAp = _CanonConvertAperture(get2());",
          "8410:     }",
          "8411:     if (!aperture)",
          "8412:       aperture = imgdata.lens.makernotes.CurAp;",
          "8413:   }",
          "8415:   else if (tag == 0x0095 && // lens model tag",
          "8416:            !imgdata.lens.makernotes.Lens[0])",
          "8417:   {",
          "8418:     fread(imgdata.lens.makernotes.Lens, 2, 1, ifp);",
          "8419:     imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "8420:     if (imgdata.lens.makernotes.Lens[0] < 65) // non-Canon lens",
          "8421:       fread(imgdata.lens.makernotes.Lens + 2, 62, 1, ifp);",
          "8422:     else",
          "8423:     {",
          "8424:       char efs[2];",
          "8425:       imgdata.lens.makernotes.LensFeatures_pre[0] = imgdata.lens.makernotes.Lens[0];",
          "8426:       imgdata.lens.makernotes.LensFeatures_pre[1] = imgdata.lens.makernotes.Lens[1];",
          "8427:       fread(efs, 2, 1, ifp);",
          "8428:       if (efs[0] == 45 && (efs[1] == 83 || efs[1] == 69 || efs[1] == 77))",
          "8429:       { // \"EF-S, TS-E, MP-E, EF-M\" lenses",
          "8430:         imgdata.lens.makernotes.Lens[2] = imgdata.lens.makernotes.LensFeatures_pre[2] = efs[0];",
          "8431:         imgdata.lens.makernotes.Lens[3] = imgdata.lens.makernotes.LensFeatures_pre[3] = efs[1];",
          "8432:         imgdata.lens.makernotes.Lens[4] = 32;",
          "8433:         if (efs[1] == 83)",
          "8434:         {",
          "8435:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;",
          "8436:           imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;",
          "8437:         }",
          "8438:         else if (efs[1] == 77)",
          "8439:         {",
          "8440:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;",
          "8441:         }",
          "8442:       }",
          "8443:       else",
          "8444:       { // \"EF\" lenses",
          "8445:         imgdata.lens.makernotes.Lens[2] = 32;",
          "8446:         imgdata.lens.makernotes.Lens[3] = efs[0];",
          "8447:         imgdata.lens.makernotes.Lens[4] = efs[1];",
          "8448:       }",
          "8449:       fread(imgdata.lens.makernotes.Lens + 5, 58, 1, ifp);",
          "8450:     }",
          "8451:   }",
          "8453:   else if (tag == 0x00a9)",
          "8454:   {",
          "8455:     long int save1 = ftell(ifp);",
          "8456:     fseek(ifp, save1 + (0x5 << 1), SEEK_SET);",
          "8457:     Canon_WBpresets(0, 0);",
          "8458:     fseek(ifp, save1, SEEK_SET);",
          "8459:   }",
          "8461:   else if (tag == 0x00e0) // sensor info",
          "8462:   {",
          "8463:     imgdata.makernotes.canon.SensorWidth = (get2(), get2());",
          "8464:     imgdata.makernotes.canon.SensorHeight = get2();",
          "8465:     imgdata.makernotes.canon.SensorLeftBorder = (get2(), get2(), get2());",
          "8466:     imgdata.makernotes.canon.SensorTopBorder = get2();",
          "8467:     imgdata.makernotes.canon.SensorRightBorder = get2();",
          "8468:     imgdata.makernotes.canon.SensorBottomBorder = get2();",
          "8469:     imgdata.makernotes.canon.BlackMaskLeftBorder = get2();",
          "8470:     imgdata.makernotes.canon.BlackMaskTopBorder = get2();",
          "8471:     imgdata.makernotes.canon.BlackMaskRightBorder = get2();",
          "8472:     imgdata.makernotes.canon.BlackMaskBottomBorder = get2();",
          "8473:   }",
          "8475:   else if (tag == 0x4001 && len > 500)",
          "8476:   {",
          "8477:     int c;",
          "8478:     long int save1 = ftell(ifp);",
          "8479:     switch (len)",
          "8480:     {",
          "8481:     case 582:",
          "8482:       imgdata.makernotes.canon.CanonColorDataVer = 1; // 20D / 350D",
          "8484:         fseek(ifp, save1 + (0x23 << 1), SEEK_SET);",
          "8485:         Canon_WBpresets(2, 2);",
          "8486:         fseek(ifp, save1 + (0x4b << 1), SEEK_SET);",
          "8487:         Canon_WBCTpresets(1); // ABCT",
          "8488:       }",
          "8489:       break;",
          "8490:     case 653:",
          "8491:       imgdata.makernotes.canon.CanonColorDataVer = 2; // 1Dmk2 / 1DsMK2",
          "8492:       {",
          "8493:         fseek(ifp, save1 + (0x27 << 1), SEEK_SET);",
          "8494:         Canon_WBpresets(2, 12);",
          "8495:         fseek(ifp, save1 + (0xa4 << 1), SEEK_SET);",
          "8496:         Canon_WBCTpresets(1); // ABCT",
          "8497:       }",
          "8498:       break;",
          "8499:     case 796:",
          "8500:       imgdata.makernotes.canon.CanonColorDataVer = 3; // 1DmkIIN / 5D / 30D / 400D",
          "8501:       imgdata.makernotes.canon.CanonColorDataSubVer = get2();",
          "8502:       {",
          "8503:         fseek(ifp, save1 + (0x4e << 1), SEEK_SET);",
          "8504:         Canon_WBpresets(2, 12);",
          "8505:         fseek(ifp, save1 + (0x85 << 1), SEEK_SET);",
          "8506:         Canon_WBCTpresets(0);                       // BCAT",
          "8507:         fseek(ifp, save1 + (0x0c4 << 1), SEEK_SET); // offset 196 short",
          "8508:         int bls = 0;",
          "8509:         FORC4",
          "8510:         bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());",
          "8511:         imgdata.makernotes.canon.AverageBlackLevel = bls / 4;",
          "8512:       }",
          "8513:       break;",
          "8517:     case 674:",
          "8518:     case 692:",
          "8519:     case 702:",
          "8520:     case 1227:",
          "8521:     case 1250:",
          "8522:     case 1251:",
          "8523:     case 1337:",
          "8524:     case 1338:",
          "8525:     case 1346:",
          "8526:       imgdata.makernotes.canon.CanonColorDataVer = 4;",
          "8527:       imgdata.makernotes.canon.CanonColorDataSubVer = get2();",
          "8528:       {",
          "8529:         fseek(ifp, save1 + (0x53 << 1), SEEK_SET);",
          "8530:         Canon_WBpresets(2, 12);",
          "8531:         fseek(ifp, save1 + (0xa8 << 1), SEEK_SET);",
          "8532:         Canon_WBCTpresets(0);                       // BCAT",
          "8533:         fseek(ifp, save1 + (0x0e7 << 1), SEEK_SET); // offset 231 short",
          "8534:         int bls = 0;",
          "8535:         FORC4",
          "8536:         bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());",
          "8537:         imgdata.makernotes.canon.AverageBlackLevel = bls / 4;",
          "8538:       }",
          "8539:       if ((imgdata.makernotes.canon.CanonColorDataSubVer == 4) || (imgdata.makernotes.canon.CanonColorDataSubVer == 5))",
          "8540:       {",
          "8541:         fseek(ifp, save1 + (0x2b9 << 1), SEEK_SET); // offset 697 shorts",
          "8542:         imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "8543:         FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "8544:       }",
          "8545:       else if ((imgdata.makernotes.canon.CanonColorDataSubVer == 6) ||",
          "8546:                (imgdata.makernotes.canon.CanonColorDataSubVer == 7))",
          "8547:       {",
          "8548:         fseek(ifp, save1 + (0x2d0 << 1), SEEK_SET); // offset 720 shorts",
          "8549:         imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "8550:         FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "8551:       }",
          "8552:       else if (imgdata.makernotes.canon.CanonColorDataSubVer == 9)",
          "8553:       {",
          "8554:         fseek(ifp, save1 + (0x2d4 << 1), SEEK_SET); // offset 724 shorts",
          "8555:         imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "8556:         FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "8557:       }",
          "8558:       break;",
          "8560:     case 5120:",
          "8561:       imgdata.makernotes.canon.CanonColorDataVer = 5; // PowerSot G10, G12, G5 X, EOS M3, EOS M5",
          "8562:       {",
          "8563:         fseek(ifp, save1 + (0x56 << 1), SEEK_SET);",
          "8564:         if ((unique_id == 0x03970000) || // G7 X Mark II",
          "8565:             (unique_id == 0x80000394))   // EOS M5",
          "8566:         {",
          "8567:           fseek(ifp, 18, SEEK_CUR);",
          "8568:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();",
          "8569:           fseek(ifp, 8, SEEK_CUR);",
          "8570:           Canon_WBpresets(8, 24);",
          "8571:           fseek(ifp, 168, SEEK_CUR);",
          "8572:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ (c >> 1)] = get2();",
          "8573:           fseek(ifp, 24, SEEK_CUR);",
          "8574:           Canon_WBCTpresets(2); // BCADT",
          "8575:           fseek(ifp, 6, SEEK_CUR);",
          "8576:         }",
          "8577:         else",
          "8578:         {",
          "8579:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();",
          "8580:           get2();",
          "8581:           Canon_WBpresets(2, 12);",
          "8582:           fseek(ifp, save1 + (0xba << 1), SEEK_SET);",
          "8583:           Canon_WBCTpresets(2);                       // BCADT",
          "8584:           fseek(ifp, save1 + (0x108 << 1), SEEK_SET); // offset 264 short",
          "8585:         }",
          "8586:         int bls = 0;",
          "8587:         FORC4",
          "8588:         bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());",
          "8589:         imgdata.makernotes.canon.AverageBlackLevel = bls / 4;",
          "8590:       }",
          "8591:       break;",
          "8593:     case 1273:",
          "8594:     case 1275:",
          "8595:       imgdata.makernotes.canon.CanonColorDataVer = 6; // 600D / 1200D",
          "8596:       imgdata.makernotes.canon.CanonColorDataSubVer = get2();",
          "8597:       {",
          "8598:         fseek(ifp, save1 + (0x67 << 1), SEEK_SET);",
          "8599:         Canon_WBpresets(2, 12);",
          "8600:         fseek(ifp, save1 + (0xbc << 1), SEEK_SET);",
          "8601:         Canon_WBCTpresets(0);                       // BCAT",
          "8602:         fseek(ifp, save1 + (0x0fb << 1), SEEK_SET); // offset 251 short",
          "8603:         int bls = 0;",
          "8604:         FORC4",
          "8605:         bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());",
          "8606:         imgdata.makernotes.canon.AverageBlackLevel = bls / 4;",
          "8607:       }",
          "8608:       fseek(ifp, save1 + (0x1e4 << 1), SEEK_SET); // offset 484 shorts",
          "8609:       imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "8610:       FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "8611:       break;",
          "8614:     case 1312:",
          "8615:     case 1313:",
          "8616:     case 1316:",
          "8617:     case 1506:",
          "8618:       imgdata.makernotes.canon.CanonColorDataVer = 7;",
          "8619:       imgdata.makernotes.canon.CanonColorDataSubVer = get2();",
          "8620:       {",
          "8621:         fseek(ifp, save1 + (0x80 << 1), SEEK_SET);",
          "8622:         Canon_WBpresets(2, 12);",
          "8623:         fseek(ifp, save1 + (0xd5 << 1), SEEK_SET);",
          "8624:         Canon_WBCTpresets(0);                       // BCAT",
          "8625:         fseek(ifp, save1 + (0x114 << 1), SEEK_SET); // offset 276 shorts",
          "8626:         int bls = 0;",
          "8627:         FORC4",
          "8628:         bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());",
          "8629:         imgdata.makernotes.canon.AverageBlackLevel = bls / 4;",
          "8630:       }",
          "8631:       if (imgdata.makernotes.canon.CanonColorDataSubVer == 10)",
          "8632:       {",
          "8633:         fseek(ifp, save1 + (0x1fd << 1), SEEK_SET); // offset 509 shorts",
          "8634:         imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "8635:         FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "8636:       }",
          "8637:       else if (imgdata.makernotes.canon.CanonColorDataSubVer == 11)",
          "8638:       {",
          "8639:         fseek(ifp, save1 + (0x2dd << 1), SEEK_SET); // offset 733 shorts",
          "8640:         imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "8641:         FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "8642:       }",
          "8643:       break;",
          "8646:     case 1560:",
          "8647:     case 1592:",
          "8648:     case 1353:",
          "8649:       imgdata.makernotes.canon.CanonColorDataVer = 8;",
          "8650:       imgdata.makernotes.canon.CanonColorDataSubVer = get2();",
          "8651:       {",
          "8652:         fseek(ifp, save1 + (0x85 << 1), SEEK_SET);",
          "8653:         Canon_WBpresets(2, 12);",
          "8654:         fseek(ifp, save1 + (0x107 << 1), SEEK_SET);",
          "8655:         Canon_WBCTpresets(0);                       // BCAT",
          "8656:         fseek(ifp, save1 + (0x146 << 1), SEEK_SET); // offset 326 shorts",
          "8657:         int bls = 0;",
          "8658:         FORC4",
          "8659:         bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());",
          "8660:         imgdata.makernotes.canon.AverageBlackLevel = bls / 4;",
          "8661:       }",
          "8662:       if (imgdata.makernotes.canon.CanonColorDataSubVer == 14) // 1300D",
          "8663:       {",
          "8664:         fseek(ifp, save1 + (0x231 << 1), SEEK_SET);",
          "8665:         imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "8666:         FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "8668:       else",
          "8669:       {",
          "8670:         fseek(ifp, save1 + (0x30f << 1), SEEK_SET); // offset 783 shorts",
          "8671:         imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "8672:         FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "8673:       }",
          "8674:       break;",
          "8675:     }",
          "8676:     fseek(ifp, save1, SEEK_SET);",
          "8677:   }",
          "8680: void CLASS setPentaxBodyFeatures(unsigned id)",
          "8684:   switch (id)",
          "8685:   {",
          "",
          "---------------",
          "--- Hunk 89 ---",
          "[Context before]",
          "7835:   return;",
          "7836: }",
          "7839: {",
          "7843:   int i;",
          "7846:       iso_speed = value[i];",
          "7847:       return;",
          "7848:     }",
          "7849:   }",
          "7851: }",
          "7852: #undef numel",
          "7855: {",
          "7946: }",
          "7950:   ushort i;",
          "7952:     ushort id;",
          "7953:     char t_model[32];",
          "7954:   } p1_unique[] = {",
          "8094:   };",
          "8095:   imgdata.lens.makernotes.CamID = id;",
          "8100:       }",
          "8101:   }",
          "8102:   return;",
          "8103: }",
          "8137: }",
          "8141:   imgdata.lens.makernotes.CamID = id;",
          "8157:       )",
          "8279:            )",
          "8285:   return;",
          "8286: }",
          "8289:   ushort lid2;",
          "8292:   if (lid2 < 0x100)",
          "8293:     {",
          "8296:       {",
          "8304:         break;",
          "8309:         break;",
          "8311:       }",
          "8312:     }",
          "8313:   else",
          "8314:     imgdata.lens.makernotes.LensID = lid2;",
          "8315:   if ((lid2 >= 50481) && (lid2 < 50500))",
          "8320:   return;",
          "8321: }",
          "8327:   ushort features;",
          "8330:   if ((imgdata.lens.makernotes.LensMount == LIBRAW_MOUNT_Canon_EF) ||",
          "8333:     return;",
          "8335:   imgdata.lens.makernotes.LensFeatures_pre[0] = 0;",
          "8336:   imgdata.lens.makernotes.LensFeatures_suf[0] = 0;",
          "8341:   if (!imgdata.lens.makernotes.LensFormat && !imgdata.lens.makernotes.LensMount)",
          "8354:     }",
          "8356:   if (features & 0x4000)",
          "8357:     strnXcat(imgdata.lens.makernotes.LensFeatures_pre, \" PZ\");",
          "",
          "[Removed Lines]",
          "7838: void CLASS PentaxISO (ushort c)",
          "7840:   int code [] = {3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 50, 100, 200, 400, 800, 1600, 3200, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278};",
          "7841:   double value []  = {50, 64, 80, 100, 125, 160, 200, 250, 320, 400, 500, 640, 800, 1000, 1250, 1600, 2000, 2500, 3200, 4000, 5000, 6400, 8000, 10000, 12800, 16000, 20000, 25600, 32000, 40000, 51200, 64000, 80000, 102400, 128000, 160000, 204800, 50, 100, 200, 400, 800, 1600, 3200, 50, 70, 100, 140, 200, 280, 400, 560, 800, 1100, 1600, 2200, 3200, 4500, 6400, 9000, 12800, 18000, 25600, 36000, 51200};",
          "7842: #define numel (sizeof(code)/sizeof(code[0]))",
          "7844:   for (i = 0; i < numel; i++) {",
          "7845:     if (code[i] == c) {",
          "7850:   if (i == numel) iso_speed = 65535.0f;",
          "7854: void CLASS PentaxLensInfo (unsigned id, unsigned len) // tag 0x0207",
          "7856:  ushort iLensData = 0;",
          "7857:  uchar *table_buf;",
          "7858:  table_buf = (uchar*)malloc(MAX(len,128));",
          "7859:  fread(table_buf, len, 1, ifp);",
          "7860:  if ((id < 0x12b9c)  ||",
          "7861:         (((id == 0x12b9c)   ||  // K100D",
          "7862:           (id == 0x12b9d)   ||  // K110D",
          "7863:           (id == 0x12ba2)) &&   // K100D Super",
          "7864:    ((!table_buf[20] ||",
          "7865:     (table_buf[20] == 0xff)))))",
          "7866:    {",
          "7867:   iLensData = 3;",
          "7868:   if (imgdata.lens.makernotes.LensID == -1)",
          "7869:     imgdata.lens.makernotes.LensID =",
          "7870:    (((unsigned)table_buf[0]) << 8) + table_buf[1];",
          "7871:    }",
          "7872:  else switch (len)",
          "7873:    {",
          "7874:    case 90:       // LensInfo3",
          "7875:   iLensData = 13;",
          "7876:   if (imgdata.lens.makernotes.LensID == -1)",
          "7877:     imgdata.lens.makernotes.LensID =",
          "7878:    ((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) <<8) + table_buf[4];",
          "7879:   break;",
          "7880:    case 91:       // LensInfo4",
          "7881:   iLensData = 12;",
          "7882:   if (imgdata.lens.makernotes.LensID == -1)",
          "7883:     imgdata.lens.makernotes.LensID =",
          "7884:    ((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) <<8) + table_buf[4];",
          "7885:   break;",
          "7886:    case 80:       // LensInfo5",
          "7887:    case 128:",
          "7888:   iLensData = 15;",
          "7889:   if (imgdata.lens.makernotes.LensID == -1)",
          "7890:     imgdata.lens.makernotes.LensID =",
          "7891:    ((unsigned)((table_buf[1] & 0x0f) + table_buf[4]) <<8) + table_buf[5];",
          "7892:   break;",
          "7893:    default:",
          "7894:   if (id >= 0x12b9c)    // LensInfo2",
          "7895:     {",
          "7896:    iLensData = 4;",
          "7897:    if (imgdata.lens.makernotes.LensID == -1)",
          "7898:      imgdata.lens.makernotes.LensID =",
          "7899:     ((unsigned)((table_buf[0] & 0x0f) + table_buf[2]) <<8) + table_buf[3];",
          "7900:     }",
          "7901:    }",
          "7902:  if (iLensData)",
          "7903:    {",
          "7904:   if (table_buf[iLensData+9] &&",
          "7905:    (fabs(imgdata.lens.makernotes.CurFocal) < 0.1f))",
          "7906:     imgdata.lens.makernotes.CurFocal =",
          "7907:    10*(table_buf[iLensData+9]>>2) * powf64(4, (table_buf[iLensData+9] & 0x03)-2);",
          "7908:   if (table_buf[iLensData+10] & 0xf0)",
          "7909:     imgdata.lens.makernotes.MaxAp4CurFocal =",
          "7910:    powf64(2.0f, (float)((table_buf[iLensData+10] & 0xf0) >>4)/4.0f);",
          "7911:   if (table_buf[iLensData+10] & 0x0f)",
          "7912:     imgdata.lens.makernotes.MinAp4CurFocal =",
          "7913:    powf64(2.0f, (float)((table_buf[iLensData+10] & 0x0f) + 10)/4.0f);",
          "7915:   if (iLensData != 12)",
          "7916:     {",
          "7917:    switch (table_buf[iLensData] & 0x06)",
          "7918:      {",
          "7919:      case 0: imgdata.lens.makernotes.MinAp4MinFocal = 22.0f; break;",
          "7920:      case 2: imgdata.lens.makernotes.MinAp4MinFocal = 32.0f; break;",
          "7921:      case 4: imgdata.lens.makernotes.MinAp4MinFocal = 45.0f; break;",
          "7922:      case 6: imgdata.lens.makernotes.MinAp4MinFocal = 16.0f; break;",
          "7923:      }",
          "7924:    if (table_buf[iLensData] & 0x70)",
          "7925:      imgdata.lens.makernotes.LensFStops =",
          "7926:     ((float)(((table_buf[iLensData] & 0x70) >> 4) ^ 0x07)) / 2.0f + 5.0f;",
          "7928:    imgdata.lens.makernotes.MinFocusDistance = (float)(table_buf[iLensData+3] & 0xf8);",
          "7929:    imgdata.lens.makernotes.FocusRangeIndex = (float)(table_buf[iLensData+3] & 0x07);",
          "7931:    if ((table_buf[iLensData+14] > 1) &&",
          "7932:     (fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))",
          "7933:      imgdata.lens.makernotes.MaxAp4CurFocal =",
          "7934:     powf64(2.0f, (float)((table_buf[iLensData+14] & 0x7f) -1)/32.0f);",
          "7935:     }",
          "7936:   else if ((id != 0x12e76) && // K-5",
          "7937:      (table_buf[iLensData+15] > 1) &&",
          "7938:      (fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))",
          "7939:     {",
          "7940:    imgdata.lens.makernotes.MaxAp4CurFocal =",
          "7941:      powf64(2.0f, (float)((table_buf[iLensData+15] & 0x7f) -1)/32.0f);",
          "7942:     }",
          "7943:    }",
          "7944:  free(table_buf);",
          "7945:  return;",
          "7948: void CLASS setPhaseOneFeatures (unsigned id) {",
          "7951:   static const struct {",
          "7956:     {1, \"Hasselblad V\"},",
          "7957:     {10, \"PhaseOne/Mamiya\"},",
          "7958:     {12, \"Contax 645\"},",
          "7959:     {16, \"Hasselblad V\"},",
          "7960:     {17, \"Hasselblad V\"},",
          "7961:     {18, \"Contax 645\"},",
          "7962:     {19, \"PhaseOne/Mamiya\"},",
          "7963:     {20, \"Hasselblad V\"},",
          "7964:     {21, \"Contax 645\"},",
          "7965:     {22, \"PhaseOne/Mamiya\"},",
          "7966:     {23, \"Hasselblad V\"},",
          "7967:     {24, \"Hasselblad H\"},",
          "7968:     {25, \"PhaseOne/Mamiya\"},",
          "7969:     {32, \"Contax 645\"},",
          "7970:     {34, \"Hasselblad V\"},",
          "7971:     {35, \"Hasselblad V\"},",
          "7972:     {36, \"Hasselblad H\"},",
          "7973:     {37, \"Contax 645\"},",
          "7974:     {38, \"PhaseOne/Mamiya\"},",
          "7975:     {39, \"Hasselblad V\"},",
          "7976:     {40, \"Hasselblad H\"},",
          "7977:     {41, \"Contax 645\"},",
          "7978:     {42, \"PhaseOne/Mamiya\"},",
          "7979:     {44, \"Hasselblad V\"},",
          "7980:     {45, \"Hasselblad H\"},",
          "7981:     {46, \"Contax 645\"},",
          "7982:     {47, \"PhaseOne/Mamiya\"},",
          "7983:     {48, \"Hasselblad V\"},",
          "7984:     {49, \"Hasselblad H\"},",
          "7985:     {50, \"Contax 645\"},",
          "7986:     {51, \"PhaseOne/Mamiya\"},",
          "7987:     {52, \"Hasselblad V\"},",
          "7988:     {53, \"Hasselblad H\"},",
          "7989:     {54, \"Contax 645\"},",
          "7990:     {55, \"PhaseOne/Mamiya\"},",
          "7991:     {67, \"Hasselblad V\"},",
          "7992:     {68, \"Hasselblad H\"},",
          "7993:     {69, \"Contax 645\"},",
          "7994:     {70, \"PhaseOne/Mamiya\"},",
          "7995:     {71, \"Hasselblad V\"},",
          "7996:     {72, \"Hasselblad H\"},",
          "7997:     {73, \"Contax 645\"},",
          "7998:     {74, \"PhaseOne/Mamiya\"},",
          "7999:     {76, \"Hasselblad V\"},",
          "8000:     {77, \"Hasselblad H\"},",
          "8001:     {78, \"Contax 645\"},",
          "8002:     {79, \"PhaseOne/Mamiya\"},",
          "8003:     {80, \"Hasselblad V\"},",
          "8004:     {81, \"Hasselblad H\"},",
          "8005:     {82, \"Contax 645\"},",
          "8006:     {83, \"PhaseOne/Mamiya\"},",
          "8007:     {84, \"Hasselblad V\"},",
          "8008:     {85, \"Hasselblad H\"},",
          "8009:     {86, \"Contax 645\"},",
          "8010:     {87, \"PhaseOne/Mamiya\"},",
          "8011:     {99, \"Hasselblad V\"},",
          "8012:     {100, \"Hasselblad H\"},",
          "8013:     {101, \"Contax 645\"},",
          "8014:     {102, \"PhaseOne/Mamiya\"},",
          "8015:     {103, \"Hasselblad V\"},",
          "8016:     {104, \"Hasselblad H\"},",
          "8017:     {105, \"PhaseOne/Mamiya\"},",
          "8018:     {106, \"Contax 645\"},",
          "8019:     {112, \"Hasselblad V\"},",
          "8020:     {113, \"Hasselblad H\"},",
          "8021:     {114, \"Contax 645\"},",
          "8022:     {115, \"PhaseOne/Mamiya\"},",
          "8023:     {131, \"Hasselblad V\"},",
          "8024:     {132, \"Hasselblad H\"},",
          "8025:     {133, \"Contax 645\"},",
          "8026:     {134, \"PhaseOne/Mamiya\"},",
          "8027:     {135, \"Hasselblad V\"},",
          "8028:     {136, \"Hasselblad H\"},",
          "8029:     {137, \"Contax 645\"},",
          "8030:     {138, \"PhaseOne/Mamiya\"},",
          "8031:     {140, \"Hasselblad V\"},",
          "8032:     {141, \"Hasselblad H\"},",
          "8033:     {142, \"Contax 645\"},",
          "8034:     {143, \"PhaseOne/Mamiya\"},",
          "8035:     {148, \"Hasselblad V\"},",
          "8036:     {149, \"Hasselblad H\"},",
          "8037:     {150, \"Contax 645\"},",
          "8038:     {151, \"PhaseOne/Mamiya\"},",
          "8039:     {160, \"A-250\"},",
          "8040:     {161, \"A-260\"},",
          "8041:     {162, \"A-280\"},",
          "8042:     {167, \"Hasselblad V\"},",
          "8043:     {168, \"Hasselblad H\"},",
          "8044:     {169, \"Contax 645\"},",
          "8045:     {170, \"PhaseOne/Mamiya\"},",
          "8046:     {172, \"Hasselblad V\"},",
          "8047:     {173, \"Hasselblad H\"},",
          "8048:     {174, \"Contax 645\"},",
          "8049:     {175, \"PhaseOne/Mamiya\"},",
          "8050:     {176, \"Hasselblad V\"},",
          "8051:     {177, \"Hasselblad H\"},",
          "8052:     {178, \"Contax 645\"},",
          "8053:     {179, \"PhaseOne/Mamiya\"},",
          "8054:     {180, \"Hasselblad V\"},",
          "8055:     {181, \"Hasselblad H\"},",
          "8056:     {182, \"Contax 645\"},",
          "8057:     {183, \"PhaseOne/Mamiya\"},",
          "8058:     {208, \"Hasselblad V\"},",
          "8059:     {211, \"PhaseOne/Mamiya\"},",
          "8060:     {448, \"Phase One 645AF\"},",
          "8061:     {457, \"Phase One 645DF\"},",
          "8062:     {471, \"Phase One 645DF+\"},",
          "8063:     {704, \"Phase One iXA\"},",
          "8064:     {705, \"Phase One iXA - R\"},",
          "8065:     {706, \"Phase One iXU 150\"},",
          "8066:     {707, \"Phase One iXU 150 - NIR\"},",
          "8067:     {708, \"Phase One iXU 180\"},",
          "8068:     {721, \"Phase One iXR\"},",
          "8070:     {333,\"Mamiya\"},",
          "8071:     {329,\"Universal\"},",
          "8072:     {330,\"Hasselblad H1/H2\"},",
          "8073:     {332,\"Contax\"},",
          "8074:     {336,\"AFi\"},",
          "8075:     {327,\"Mamiya\"},",
          "8076:     {324,\"Universal\"},",
          "8077:     {325,\"Hasselblad H1/H2\"},",
          "8078:     {326,\"Contax\"},",
          "8079:     {335,\"AFi\"},",
          "8080:     {340,\"Mamiya\"},",
          "8081:     {337,\"Universal\"},",
          "8082:     {338,\"Hasselblad H1/H2\"},",
          "8083:     {339,\"Contax\"},",
          "8084:     {323,\"Mamiya\"},",
          "8085:     {320,\"Universal\"},",
          "8086:     {322,\"Hasselblad H1/H2\"},",
          "8087:     {321,\"Contax\"},",
          "8088:     {334,\"AFi\"},",
          "8089:     {369,\"Universal\"},",
          "8090:     {370,\"Mamiya\"},",
          "8091:     {371,\"Hasselblad H1/H2\"},",
          "8092:     {372,\"Contax\"},",
          "8093:     {373,\"Afi\"},",
          "8096:   if (id && !imgdata.lens.makernotes.body[0]) {",
          "8097:     for (i=0; i < sizeof p1_unique / sizeof *p1_unique; i++)",
          "8098:       if (id == p1_unique[i].id) {",
          "8099:         strcpy(imgdata.lens.makernotes.body,p1_unique[i].t_model);",
          "8105: void CLASS parseFujiMakernotes (unsigned tag, unsigned type) {",
          "8106:       switch (tag) {",
          "8107:       case 0x1002: imgdata.makernotes.fuji.WB_Preset = get2(); break;",
          "8108:       case 0x1011: imgdata.other.FlashEC = getreal(type); break;",
          "8109:       case 0x1020: imgdata.makernotes.fuji.Macro = get2(); break;",
          "8110:       case 0x1021: imgdata.makernotes.fuji.FocusMode = get2(); break;",
          "8111:       case 0x1022: imgdata.makernotes.fuji.AFMode = get2(); break;",
          "8112:       case 0x1023: imgdata.makernotes.fuji.FocusPixel[0] = get2();",
          "8113:                    imgdata.makernotes.fuji.FocusPixel[1] = get2();",
          "8114:       break;",
          "8115:       case 0x1034: imgdata.makernotes.fuji.ExrMode = get2(); break;",
          "8116:       case 0x1050: imgdata.makernotes.fuji.ShutterType = get2(); break;",
          "8117:       case 0x1400: imgdata.makernotes.fuji.FujiDynamicRange = get2(); break;",
          "8118:       case 0x1401: imgdata.makernotes.fuji.FujiFilmMode = get2(); break;",
          "8119:       case 0x1402: imgdata.makernotes.fuji.FujiDynamicRangeSetting = get2(); break;",
          "8120:       case 0x1403: imgdata.makernotes.fuji.FujiDevelopmentDynamicRange = get2(); break;",
          "8121:       case 0x140b: imgdata.makernotes.fuji.FujiAutoDynamicRange = get2(); break;",
          "8122:       case 0x1404: imgdata.lens.makernotes.MinFocal = getreal(type); break;",
          "8123:       case 0x1405: imgdata.lens.makernotes.MaxFocal = getreal(type); break;",
          "8124:       case 0x1406: imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type); break;",
          "8125:       case 0x1407: imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type); break;",
          "8126:       case 0x1422: imgdata.makernotes.fuji.ImageStabilization[0] = get2();",
          "8127:                    imgdata.makernotes.fuji.ImageStabilization[1] = get2();",
          "8128:                    imgdata.makernotes.fuji.ImageStabilization[2] = get2();",
          "8129:                    imgdata.shootinginfo.ImageStabilization = (imgdata.makernotes.fuji.ImageStabilization[0]<<9) + imgdata.makernotes.fuji.ImageStabilization[1];",
          "8130:       break;",
          "8131:       case 0x1431: imgdata.makernotes.fuji.Rating = get4(); break;",
          "8132:       case 0x3820: imgdata.makernotes.fuji.FrameRate = get2(); break;",
          "8133:       case 0x3821: imgdata.makernotes.fuji.FrameWidth = get2(); break;",
          "8134:       case 0x3822: imgdata.makernotes.fuji.FrameHeight = get2(); break;",
          "8135:       }",
          "8136: return;",
          "8139: void CLASS setSonyBodyFeatures (unsigned id) {",
          "8142:   if ( // FF cameras",
          "8143:       (id == 257) ||  // a900",
          "8144:       (id == 269) ||  // a850",
          "8145:       (id == 340) ||  // ILCE-7M2",
          "8146:       (id == 318) ||  // ILCE-7S",
          "8147:       (id == 350) ||  // ILCE-7SM2",
          "8148:       (id == 311) ||  // ILCE-7R",
          "8149:       (id == 347) ||  // ILCE-7RM2",
          "8150:       (id == 306) ||  // ILCE-7",
          "8151:       (id == 298) ||  // DSC-RX1",
          "8152:       (id == 299) ||  // NEX-VG900",
          "8153:       (id == 310) ||  // DSC-RX1R",
          "8154:       (id == 344) ||  // DSC-RX1RM2",
          "8155:       (id == 354) ||  // ILCA-99M2",
          "8156:       (id == 294)  // SLT-99, Hasselblad HV",
          "8158:     {",
          "8159:       imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;",
          "8160:     }",
          "8161:   else if ((id == 297) ||  // DSC-RX100",
          "8162:            (id == 308) ||  // DSC-RX100M2",
          "8163:            (id == 309) ||  // DSC-RX10",
          "8164:            (id == 317) ||  // DSC-RX100M3",
          "8165:            (id == 341) ||  // DSC-RX100M4",
          "8166:            (id == 342) ||  // DSC-RX10M2",
          "8167:            (id == 355) ||  // DSC-RX10M3",
          "8168:            (id == 356)     // DSC-RX100M5",
          "8169:          )",
          "8170:     {",
          "8171:       imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_1INCH;",
          "8172:     }",
          "8174:   else if (id != 002)     // DSC-R1",
          "8175:     {",
          "8176:       imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;",
          "8177:     }",
          "8179:   if      (               // E-mount cameras, ILCE series",
          "8180:            (id == 302) ||",
          "8181:            (id == 306) ||",
          "8182:            (id == 311) ||",
          "8183:            (id == 312) ||",
          "8184:            (id == 313) ||",
          "8185:            (id == 318) ||",
          "8186:            (id == 339) ||",
          "8187:            (id == 340) ||",
          "8188:            (id == 346) ||",
          "8189:            (id == 347) ||",
          "8190:            (id == 350) ||",
          "8191:            (id == 360)",
          "8192:           )",
          "8193:     {",
          "8194:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Sony_E;",
          "8195:       imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_ILCE;",
          "8196:     }",
          "8197:   else if (               // E-mount cameras, NEX series",
          "8198:            (id == 278) ||",
          "8199:            (id == 279) ||",
          "8200:            (id == 284) ||",
          "8201:            (id == 288) ||",
          "8202:            (id == 289) ||",
          "8203:            (id == 290) ||",
          "8204:            (id == 293) ||",
          "8205:            (id == 295) ||",
          "8206:            (id == 296) ||",
          "8207:            (id == 299) ||",
          "8208:            (id == 300) ||",
          "8209:            (id == 305) ||",
          "8210:            (id == 307)",
          "8211:           )",
          "8212:     {",
          "8213:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Sony_E;",
          "8214:       imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_NEX;",
          "8215:     }",
          "8217:   else if ( // A-mount cameras, DSLR series",
          "8218:            (id == 256) ||",
          "8219:            (id == 257) ||",
          "8220:            (id == 258) ||",
          "8221:            (id == 259) ||",
          "8222:            (id == 260) ||",
          "8223:            (id == 261) ||",
          "8224:            (id == 262) ||",
          "8225:            (id == 263) ||",
          "8226:            (id == 264) ||",
          "8227:            (id == 265) ||",
          "8228:            (id == 266) ||",
          "8229:            (id == 269) ||",
          "8230:            (id == 270) ||",
          "8231:            (id == 273) ||",
          "8232:            (id == 274) ||",
          "8233:            (id == 275) ||",
          "8234:            (id == 282) ||",
          "8235:            (id == 283)",
          "8236:           )",
          "8237:     {",
          "8238:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;",
          "8239:       imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSLR;",
          "8240:     }",
          "8241:   else if ( // A-mount cameras, SLT series",
          "8242:            (id == 280) ||",
          "8243:            (id == 281) ||",
          "8244:            (id == 285) ||",
          "8245:            (id == 286) ||",
          "8246:            (id == 287) ||",
          "8247:            (id == 291) ||",
          "8248:            (id == 292) ||",
          "8249:            (id == 294) ||",
          "8250:            (id == 303)",
          "8251:           )",
          "8252:     {",
          "8253:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;",
          "8254:       imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_SLT;",
          "8255:     }",
          "8256:   else if ( // A-mount cameras, ILCA series",
          "8257:            (id == 319)  ||",
          "8258:            (id == 353)  ||",
          "8259:            (id == 354)",
          "8260:           )",
          "8261:     {",
          "8262:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;",
          "8263:       imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_ILCA;",
          "8264:     }",
          "8266:   else if ( // DSC",
          "8267:            (id == 002) ||  // DSC-R1",
          "8268:            (id == 297) ||  // DSC-RX100",
          "8269:            (id == 298) ||  // DSC-RX1",
          "8270:            (id == 308) ||  // DSC-RX100M2",
          "8271:            (id == 309) ||  // DSC-RX10",
          "8272:            (id == 310) ||  // DSC-RX1R",
          "8273:            (id == 344) ||  // DSC-RX1RM2",
          "8274:            (id == 317) ||  // DSC-RX100M3",
          "8275:            (id == 341) ||  // DSC-RX100M4",
          "8276:            (id == 342) ||  // DSC-RX10M2",
          "8277:            (id == 355) ||  // DSC-RX10M3",
          "8278:            (id == 356)     // DSC-RX100M5",
          "8280:     {",
          "8281:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "8282:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "8283:       imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSC;",
          "8284:     }",
          "8288: void CLASS parseSonyLensType2 (uchar a, uchar b) {",
          "8290:   lid2 = (((ushort)a)<<8) | ((ushort)b);",
          "8291:   if (!lid2) return;",
          "8294:       if ((imgdata.lens.makernotes.AdapterID != 0x4900) &&",
          "8295:           (imgdata.lens.makernotes.AdapterID != 0xEF00))",
          "8297:         imgdata.lens.makernotes.AdapterID = lid2;",
          "8298:         switch (lid2) {",
          "8299:         case 1:",
          "8300:         case 2:",
          "8301:         case 3:",
          "8302:         case 6:",
          "8303:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;",
          "8305:         case 44:",
          "8306:         case 78:",
          "8307:         case 239:",
          "8308:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "8310:         }",
          "8316:     {",
          "8317:       strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");",
          "8318:       imgdata.lens.makernotes.AdapterID = 0x4900;",
          "8319:     }",
          "8323: #define strnXcat(buf,string) strncat(buf,string,LIM(sizeof(buf)-strbuflen(buf)-1,0,sizeof(buf)))",
          "8325: void CLASS parseSonyLensFeatures (uchar a, uchar b) {",
          "8328:   features = (((ushort)a)<<8) | ((ushort)b);",
          "8331:       (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F) ||",
          "8332:       !features)",
          "8337:   if ((features & 0x0200) && (features & 0x0100)) strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"E\");",
          "8338:   else if (features & 0x0200) strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"FE\");",
          "8339:   else if (features & 0x0100) strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"DT\");",
          "8342:     {",
          "8343:      imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FF;",
          "8344:      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;",
          "8346:      if ((features & 0x0200) && (features & 0x0100)) {",
          "8347:     imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;",
          "8348:     imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;",
          "8349:      } else if (features & 0x0200) {",
          "8350:     imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;",
          "8351:      } else if (features & 0x0100) {",
          "8352:     imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;",
          "8353:      }",
          "",
          "[Added Lines]",
          "8748: void CLASS PentaxISO(ushort c)",
          "8750:   int code[] = {3,   4,   5,   6,   7,   8,   9,   10,  11,   12,   13,  14,  15,  16,  17,  18,  19,",
          "8751:                 20,  21,  22,  23,  24,  25,  26,  27,  28,   29,   30,  31,  32,  33,  34,  35,  36,",
          "8752:                 37,  38,  39,  50,  100, 200, 400, 800, 1600, 3200, 258, 259, 260, 261, 262, 263, 264,",
          "8753:                 265, 266, 267, 268, 269, 270, 271, 272, 273,  274,  275, 276, 277, 278};",
          "8754:   double value[] = {50,    64,    80,    100,   125,   160,   200,   250,    320,    400,    500,    640,   800,",
          "8755:                     1000,  1250,  1600,  2000,  2500,  3200,  4000,  5000,   6400,   8000,   10000,  12800, 16000,",
          "8756:                     20000, 25600, 32000, 40000, 51200, 64000, 80000, 102400, 128000, 160000, 204800, 50,    100,",
          "8757:                     200,   400,   800,   1600,  3200,  50,    70,    100,    140,    200,    280,    400,   560,",
          "8758:                     800,   1100,  1600,  2200,  3200,  4500,  6400,  9000,   12800,  18000,  25600,  36000, 51200};",
          "8759: #define numel (sizeof(code) / sizeof(code[0]))",
          "8761:   for (i = 0; i < numel; i++)",
          "8762:   {",
          "8763:     if (code[i] == c)",
          "8764:     {",
          "8769:   if (i == numel)",
          "8770:     iso_speed = 65535.0f;",
          "8774: void CLASS PentaxLensInfo(unsigned id, unsigned len) // tag 0x0207",
          "8776:   ushort iLensData = 0;",
          "8777:   uchar *table_buf;",
          "8778:   table_buf = (uchar *)malloc(MAX(len, 128));",
          "8779:   fread(table_buf, len, 1, ifp);",
          "8780:   if ((id < 0x12b9c) || (((id == 0x12b9c) ||  // K100D",
          "8781:                           (id == 0x12b9d) ||  // K110D",
          "8782:                           (id == 0x12ba2)) && // K100D Super",
          "8783:                          ((!table_buf[20] || (table_buf[20] == 0xff)))))",
          "8784:   {",
          "8785:     iLensData = 3;",
          "8786:     if (imgdata.lens.makernotes.LensID == -1)",
          "8787:       imgdata.lens.makernotes.LensID = (((unsigned)table_buf[0]) << 8) + table_buf[1];",
          "8788:   }",
          "8789:   else",
          "8790:     switch (len)",
          "8791:     {",
          "8792:     case 90: // LensInfo3",
          "8793:       iLensData = 13;",
          "8794:       if (imgdata.lens.makernotes.LensID == -1)",
          "8795:         imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) << 8) + table_buf[4];",
          "8796:       break;",
          "8797:     case 91: // LensInfo4",
          "8798:       iLensData = 12;",
          "8799:       if (imgdata.lens.makernotes.LensID == -1)",
          "8800:         imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) << 8) + table_buf[4];",
          "8801:       break;",
          "8802:     case 80: // LensInfo5",
          "8803:     case 128:",
          "8804:       iLensData = 15;",
          "8805:       if (imgdata.lens.makernotes.LensID == -1)",
          "8806:         imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[1] & 0x0f) + table_buf[4]) << 8) + table_buf[5];",
          "8807:       break;",
          "8808:     default:",
          "8809:       if (id >= 0x12b9c) // LensInfo2",
          "8810:       {",
          "8811:         iLensData = 4;",
          "8812:         if (imgdata.lens.makernotes.LensID == -1)",
          "8813:           imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[0] & 0x0f) + table_buf[2]) << 8) + table_buf[3];",
          "8814:       }",
          "8815:     }",
          "8816:   if (iLensData)",
          "8817:   {",
          "8818:     if (table_buf[iLensData + 9] && (fabs(imgdata.lens.makernotes.CurFocal) < 0.1f))",
          "8819:       imgdata.lens.makernotes.CurFocal =",
          "8820:           10 * (table_buf[iLensData + 9] >> 2) * powf64(4, (table_buf[iLensData + 9] & 0x03) - 2);",
          "8821:     if (table_buf[iLensData + 10] & 0xf0)",
          "8822:       imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (float)((table_buf[iLensData + 10] & 0xf0) >> 4) / 4.0f);",
          "8823:     if (table_buf[iLensData + 10] & 0x0f)",
          "8824:       imgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (float)((table_buf[iLensData + 10] & 0x0f) + 10) / 4.0f);",
          "8826:     if (iLensData != 12)",
          "8827:     {",
          "8828:       switch (table_buf[iLensData] & 0x06)",
          "8829:       {",
          "8830:       case 0:",
          "8831:         imgdata.lens.makernotes.MinAp4MinFocal = 22.0f;",
          "8832:         break;",
          "8833:       case 2:",
          "8834:         imgdata.lens.makernotes.MinAp4MinFocal = 32.0f;",
          "8835:         break;",
          "8836:       case 4:",
          "8837:         imgdata.lens.makernotes.MinAp4MinFocal = 45.0f;",
          "8838:         break;",
          "8839:       case 6:",
          "8840:         imgdata.lens.makernotes.MinAp4MinFocal = 16.0f;",
          "8841:         break;",
          "8842:       }",
          "8843:       if (table_buf[iLensData] & 0x70)",
          "8844:         imgdata.lens.makernotes.LensFStops = ((float)(((table_buf[iLensData] & 0x70) >> 4) ^ 0x07)) / 2.0f + 5.0f;",
          "8846:       imgdata.lens.makernotes.MinFocusDistance = (float)(table_buf[iLensData + 3] & 0xf8);",
          "8847:       imgdata.lens.makernotes.FocusRangeIndex = (float)(table_buf[iLensData + 3] & 0x07);",
          "8849:       if ((table_buf[iLensData + 14] > 1) && (fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))",
          "8850:         imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (float)((table_buf[iLensData + 14] & 0x7f) - 1) / 32.0f);",
          "8851:     }",
          "8852:     else if ((id != 0x12e76) && // K-5",
          "8853:              (table_buf[iLensData + 15] > 1) && (fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))",
          "8854:     {",
          "8855:       imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (float)((table_buf[iLensData + 15] & 0x7f) - 1) / 32.0f);",
          "8856:     }",
          "8857:   }",
          "8858:   free(table_buf);",
          "8859:   return;",
          "8862: void CLASS setPhaseOneFeatures(unsigned id)",
          "8863: {",
          "8866:   static const struct",
          "8867:   {",
          "8872:       {1, \"Hasselblad V\"},",
          "8873:       {10, \"PhaseOne/Mamiya\"},",
          "8874:       {12, \"Contax 645\"},",
          "8875:       {16, \"Hasselblad V\"},",
          "8876:       {17, \"Hasselblad V\"},",
          "8877:       {18, \"Contax 645\"},",
          "8878:       {19, \"PhaseOne/Mamiya\"},",
          "8879:       {20, \"Hasselblad V\"},",
          "8880:       {21, \"Contax 645\"},",
          "8881:       {22, \"PhaseOne/Mamiya\"},",
          "8882:       {23, \"Hasselblad V\"},",
          "8883:       {24, \"Hasselblad H\"},",
          "8884:       {25, \"PhaseOne/Mamiya\"},",
          "8885:       {32, \"Contax 645\"},",
          "8886:       {34, \"Hasselblad V\"},",
          "8887:       {35, \"Hasselblad V\"},",
          "8888:       {36, \"Hasselblad H\"},",
          "8889:       {37, \"Contax 645\"},",
          "8890:       {38, \"PhaseOne/Mamiya\"},",
          "8891:       {39, \"Hasselblad V\"},",
          "8892:       {40, \"Hasselblad H\"},",
          "8893:       {41, \"Contax 645\"},",
          "8894:       {42, \"PhaseOne/Mamiya\"},",
          "8895:       {44, \"Hasselblad V\"},",
          "8896:       {45, \"Hasselblad H\"},",
          "8897:       {46, \"Contax 645\"},",
          "8898:       {47, \"PhaseOne/Mamiya\"},",
          "8899:       {48, \"Hasselblad V\"},",
          "8900:       {49, \"Hasselblad H\"},",
          "8901:       {50, \"Contax 645\"},",
          "8902:       {51, \"PhaseOne/Mamiya\"},",
          "8903:       {52, \"Hasselblad V\"},",
          "8904:       {53, \"Hasselblad H\"},",
          "8905:       {54, \"Contax 645\"},",
          "8906:       {55, \"PhaseOne/Mamiya\"},",
          "8907:       {67, \"Hasselblad V\"},",
          "8908:       {68, \"Hasselblad H\"},",
          "8909:       {69, \"Contax 645\"},",
          "8910:       {70, \"PhaseOne/Mamiya\"},",
          "8911:       {71, \"Hasselblad V\"},",
          "8912:       {72, \"Hasselblad H\"},",
          "8913:       {73, \"Contax 645\"},",
          "8914:       {74, \"PhaseOne/Mamiya\"},",
          "8915:       {76, \"Hasselblad V\"},",
          "8916:       {77, \"Hasselblad H\"},",
          "8917:       {78, \"Contax 645\"},",
          "8918:       {79, \"PhaseOne/Mamiya\"},",
          "8919:       {80, \"Hasselblad V\"},",
          "8920:       {81, \"Hasselblad H\"},",
          "8921:       {82, \"Contax 645\"},",
          "8922:       {83, \"PhaseOne/Mamiya\"},",
          "8923:       {84, \"Hasselblad V\"},",
          "8924:       {85, \"Hasselblad H\"},",
          "8925:       {86, \"Contax 645\"},",
          "8926:       {87, \"PhaseOne/Mamiya\"},",
          "8927:       {99, \"Hasselblad V\"},",
          "8928:       {100, \"Hasselblad H\"},",
          "8929:       {101, \"Contax 645\"},",
          "8930:       {102, \"PhaseOne/Mamiya\"},",
          "8931:       {103, \"Hasselblad V\"},",
          "8932:       {104, \"Hasselblad H\"},",
          "8933:       {105, \"PhaseOne/Mamiya\"},",
          "8934:       {106, \"Contax 645\"},",
          "8935:       {112, \"Hasselblad V\"},",
          "8936:       {113, \"Hasselblad H\"},",
          "8937:       {114, \"Contax 645\"},",
          "8938:       {115, \"PhaseOne/Mamiya\"},",
          "8939:       {131, \"Hasselblad V\"},",
          "8940:       {132, \"Hasselblad H\"},",
          "8941:       {133, \"Contax 645\"},",
          "8942:       {134, \"PhaseOne/Mamiya\"},",
          "8943:       {135, \"Hasselblad V\"},",
          "8944:       {136, \"Hasselblad H\"},",
          "8945:       {137, \"Contax 645\"},",
          "8946:       {138, \"PhaseOne/Mamiya\"},",
          "8947:       {140, \"Hasselblad V\"},",
          "8948:       {141, \"Hasselblad H\"},",
          "8949:       {142, \"Contax 645\"},",
          "8950:       {143, \"PhaseOne/Mamiya\"},",
          "8951:       {148, \"Hasselblad V\"},",
          "8952:       {149, \"Hasselblad H\"},",
          "8953:       {150, \"Contax 645\"},",
          "8954:       {151, \"PhaseOne/Mamiya\"},",
          "8955:       {160, \"A-250\"},",
          "8956:       {161, \"A-260\"},",
          "8957:       {162, \"A-280\"},",
          "8958:       {167, \"Hasselblad V\"},",
          "8959:       {168, \"Hasselblad H\"},",
          "8960:       {169, \"Contax 645\"},",
          "8961:       {170, \"PhaseOne/Mamiya\"},",
          "8962:       {172, \"Hasselblad V\"},",
          "8963:       {173, \"Hasselblad H\"},",
          "8964:       {174, \"Contax 645\"},",
          "8965:       {175, \"PhaseOne/Mamiya\"},",
          "8966:       {176, \"Hasselblad V\"},",
          "8967:       {177, \"Hasselblad H\"},",
          "8968:       {178, \"Contax 645\"},",
          "8969:       {179, \"PhaseOne/Mamiya\"},",
          "8970:       {180, \"Hasselblad V\"},",
          "8971:       {181, \"Hasselblad H\"},",
          "8972:       {182, \"Contax 645\"},",
          "8973:       {183, \"PhaseOne/Mamiya\"},",
          "8974:       {208, \"Hasselblad V\"},",
          "8975:       {211, \"PhaseOne/Mamiya\"},",
          "8976:       {448, \"Phase One 645AF\"},",
          "8977:       {457, \"Phase One 645DF\"},",
          "8978:       {471, \"Phase One 645DF+\"},",
          "8979:       {704, \"Phase One iXA\"},",
          "8980:       {705, \"Phase One iXA - R\"},",
          "8981:       {706, \"Phase One iXU 150\"},",
          "8982:       {707, \"Phase One iXU 150 - NIR\"},",
          "8983:       {708, \"Phase One iXU 180\"},",
          "8984:       {721, \"Phase One iXR\"},",
          "8986:       {333, \"Mamiya\"},",
          "8987:       {329, \"Universal\"},",
          "8988:       {330, \"Hasselblad H1/H2\"},",
          "8989:       {332, \"Contax\"},",
          "8990:       {336, \"AFi\"},",
          "8991:       {327, \"Mamiya\"},",
          "8992:       {324, \"Universal\"},",
          "8993:       {325, \"Hasselblad H1/H2\"},",
          "8994:       {326, \"Contax\"},",
          "8995:       {335, \"AFi\"},",
          "8996:       {340, \"Mamiya\"},",
          "8997:       {337, \"Universal\"},",
          "8998:       {338, \"Hasselblad H1/H2\"},",
          "8999:       {339, \"Contax\"},",
          "9000:       {323, \"Mamiya\"},",
          "9001:       {320, \"Universal\"},",
          "9002:       {322, \"Hasselblad H1/H2\"},",
          "9003:       {321, \"Contax\"},",
          "9004:       {334, \"AFi\"},",
          "9005:       {369, \"Universal\"},",
          "9006:       {370, \"Mamiya\"},",
          "9007:       {371, \"Hasselblad H1/H2\"},",
          "9008:       {372, \"Contax\"},",
          "9009:       {373, \"Afi\"},",
          "9012:   if (id && !imgdata.lens.makernotes.body[0])",
          "9013:   {",
          "9014:     for (i = 0; i < sizeof p1_unique / sizeof *p1_unique; i++)",
          "9015:       if (id == p1_unique[i].id)",
          "9016:       {",
          "9017:         strcpy(imgdata.lens.makernotes.body, p1_unique[i].t_model);",
          "9023: void CLASS parseFujiMakernotes(unsigned tag, unsigned type)",
          "9024: {",
          "9025:   switch (tag)",
          "9026:   {",
          "9027:   case 0x1002:",
          "9028:     imgdata.makernotes.fuji.WB_Preset = get2();",
          "9029:     break;",
          "9030:   case 0x1011:",
          "9031:     imgdata.other.FlashEC = getreal(type);",
          "9032:     break;",
          "9033:   case 0x1020:",
          "9034:     imgdata.makernotes.fuji.Macro = get2();",
          "9035:     break;",
          "9036:   case 0x1021:",
          "9037:     imgdata.makernotes.fuji.FocusMode = get2();",
          "9038:     break;",
          "9039:   case 0x1022:",
          "9040:     imgdata.makernotes.fuji.AFMode = get2();",
          "9041:     break;",
          "9042:   case 0x1023:",
          "9043:     imgdata.makernotes.fuji.FocusPixel[0] = get2();",
          "9044:     imgdata.makernotes.fuji.FocusPixel[1] = get2();",
          "9045:     break;",
          "9046:   case 0x1034:",
          "9047:     imgdata.makernotes.fuji.ExrMode = get2();",
          "9048:     break;",
          "9049:   case 0x1050:",
          "9050:     imgdata.makernotes.fuji.ShutterType = get2();",
          "9051:     break;",
          "9052:   case 0x1400:",
          "9053:     imgdata.makernotes.fuji.FujiDynamicRange = get2();",
          "9054:     break;",
          "9055:   case 0x1401:",
          "9056:     imgdata.makernotes.fuji.FujiFilmMode = get2();",
          "9057:     break;",
          "9058:   case 0x1402:",
          "9059:     imgdata.makernotes.fuji.FujiDynamicRangeSetting = get2();",
          "9060:     break;",
          "9061:   case 0x1403:",
          "9062:     imgdata.makernotes.fuji.FujiDevelopmentDynamicRange = get2();",
          "9063:     break;",
          "9064:   case 0x140b:",
          "9065:     imgdata.makernotes.fuji.FujiAutoDynamicRange = get2();",
          "9066:     break;",
          "9067:   case 0x1404:",
          "9068:     imgdata.lens.makernotes.MinFocal = getreal(type);",
          "9069:     break;",
          "9070:   case 0x1405:",
          "9071:     imgdata.lens.makernotes.MaxFocal = getreal(type);",
          "9072:     break;",
          "9073:   case 0x1406:",
          "9074:     imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);",
          "9075:     break;",
          "9076:   case 0x1407:",
          "9077:     imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);",
          "9078:     break;",
          "9079:   case 0x1422:",
          "9080:     imgdata.makernotes.fuji.ImageStabilization[0] = get2();",
          "9081:     imgdata.makernotes.fuji.ImageStabilization[1] = get2();",
          "9082:     imgdata.makernotes.fuji.ImageStabilization[2] = get2();",
          "9083:     imgdata.shootinginfo.ImageStabilization =",
          "9084:         (imgdata.makernotes.fuji.ImageStabilization[0] << 9) + imgdata.makernotes.fuji.ImageStabilization[1];",
          "9085:     break;",
          "9086:   case 0x1431:",
          "9087:     imgdata.makernotes.fuji.Rating = get4();",
          "9088:     break;",
          "9089:   case 0x3820:",
          "9090:     imgdata.makernotes.fuji.FrameRate = get2();",
          "9091:     break;",
          "9092:   case 0x3821:",
          "9093:     imgdata.makernotes.fuji.FrameWidth = get2();",
          "9094:     break;",
          "9095:   case 0x3822:",
          "9096:     imgdata.makernotes.fuji.FrameHeight = get2();",
          "9097:     break;",
          "9098:   }",
          "9099:   return;",
          "9102: void CLASS setSonyBodyFeatures(unsigned id)",
          "9103: {",
          "9106:   if (               // FF cameras",
          "9107:       (id == 257) || // a900",
          "9108:       (id == 269) || // a850",
          "9109:       (id == 340) || // ILCE-7M2",
          "9110:       (id == 318) || // ILCE-7S",
          "9111:       (id == 350) || // ILCE-7SM2",
          "9112:       (id == 311) || // ILCE-7R",
          "9113:       (id == 347) || // ILCE-7RM2",
          "9114:       (id == 306) || // ILCE-7",
          "9115:       (id == 298) || // DSC-RX1",
          "9116:       (id == 299) || // NEX-VG900",
          "9117:       (id == 310) || // DSC-RX1R",
          "9118:       (id == 344) || // DSC-RX1RM2",
          "9119:       (id == 354) || // ILCA-99M2",
          "9120:       (id == 294)    // SLT-99, Hasselblad HV",
          "9122:   {",
          "9123:     imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;",
          "9124:   }",
          "9125:   else if ((id == 297) || // DSC-RX100",
          "9126:            (id == 308) || // DSC-RX100M2",
          "9127:            (id == 309) || // DSC-RX10",
          "9128:            (id == 317) || // DSC-RX100M3",
          "9129:            (id == 341) || // DSC-RX100M4",
          "9130:            (id == 342) || // DSC-RX10M2",
          "9131:            (id == 355) || // DSC-RX10M3",
          "9132:            (id == 356)    // DSC-RX100M5",
          "9134:   {",
          "9135:     imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_1INCH;",
          "9136:   }",
          "9138:   else if (id != 002) // DSC-R1",
          "9139:   {",
          "9140:     imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;",
          "9141:   }",
          "9143:   if ( // E-mount cameras, ILCE series",
          "9144:       (id == 302) || (id == 306) || (id == 311) || (id == 312) || (id == 313) || (id == 318) || (id == 339) ||",
          "9145:       (id == 340) || (id == 346) || (id == 347) || (id == 350) || (id == 360))",
          "9146:   {",
          "9147:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Sony_E;",
          "9148:     imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_ILCE;",
          "9149:   }",
          "9150:   else if ( // E-mount cameras, NEX series",
          "9151:       (id == 278) || (id == 279) || (id == 284) || (id == 288) || (id == 289) || (id == 290) || (id == 293) ||",
          "9152:       (id == 295) || (id == 296) || (id == 299) || (id == 300) || (id == 305) || (id == 307))",
          "9153:   {",
          "9154:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Sony_E;",
          "9155:     imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_NEX;",
          "9156:   }",
          "9158:   else if ( // A-mount cameras, DSLR series",
          "9159:       (id == 256) || (id == 257) || (id == 258) || (id == 259) || (id == 260) || (id == 261) || (id == 262) ||",
          "9160:       (id == 263) || (id == 264) || (id == 265) || (id == 266) || (id == 269) || (id == 270) || (id == 273) ||",
          "9161:       (id == 274) || (id == 275) || (id == 282) || (id == 283))",
          "9162:   {",
          "9163:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;",
          "9164:     imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSLR;",
          "9165:   }",
          "9166:   else if ( // A-mount cameras, SLT series",
          "9167:       (id == 280) || (id == 281) || (id == 285) || (id == 286) || (id == 287) || (id == 291) || (id == 292) ||",
          "9168:       (id == 294) || (id == 303))",
          "9169:   {",
          "9170:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;",
          "9171:     imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_SLT;",
          "9172:   }",
          "9173:   else if ( // A-mount cameras, ILCA series",
          "9174:       (id == 319) || (id == 353) || (id == 354))",
          "9175:   {",
          "9176:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;",
          "9177:     imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_ILCA;",
          "9178:   }",
          "9180:   else if (          // DSC",
          "9181:       (id == 002) || // DSC-R1",
          "9182:       (id == 297) || // DSC-RX100",
          "9183:       (id == 298) || // DSC-RX1",
          "9184:       (id == 308) || // DSC-RX100M2",
          "9185:       (id == 309) || // DSC-RX10",
          "9186:       (id == 310) || // DSC-RX1R",
          "9187:       (id == 344) || // DSC-RX1RM2",
          "9188:       (id == 317) || // DSC-RX100M3",
          "9189:       (id == 341) || // DSC-RX100M4",
          "9190:       (id == 342) || // DSC-RX10M2",
          "9191:       (id == 355) || // DSC-RX10M3",
          "9192:       (id == 356)    // DSC-RX100M5",
          "9193:       )",
          "9194:   {",
          "9195:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "9196:     imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "9197:     imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSC;",
          "9198:   }",
          "9202: void CLASS parseSonyLensType2(uchar a, uchar b)",
          "9203: {",
          "9205:   lid2 = (((ushort)a) << 8) | ((ushort)b);",
          "9206:   if (!lid2)",
          "9207:     return;",
          "9209:   {",
          "9210:     if ((imgdata.lens.makernotes.AdapterID != 0x4900) && (imgdata.lens.makernotes.AdapterID != 0xEF00))",
          "9212:       imgdata.lens.makernotes.AdapterID = lid2;",
          "9213:       switch (lid2)",
          "9215:       case 1:",
          "9216:       case 2:",
          "9217:       case 3:",
          "9218:       case 6:",
          "9219:         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;",
          "9221:       case 44:",
          "9222:       case 78:",
          "9223:       case 239:",
          "9224:         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "9228:   }",
          "9232:   {",
          "9233:     strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");",
          "9234:     imgdata.lens.makernotes.AdapterID = 0x4900;",
          "9235:   }",
          "9239: #define strnXcat(buf, string) strncat(buf, string, LIM(sizeof(buf) - strbuflen(buf) - 1, 0, sizeof(buf)))",
          "9241: void CLASS parseSonyLensFeatures(uchar a, uchar b)",
          "9242: {",
          "9245:   features = (((ushort)a) << 8) | ((ushort)b);",
          "9248:       (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F) || !features)",
          "9253:   if ((features & 0x0200) && (features & 0x0100))",
          "9254:     strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"E\");",
          "9255:   else if (features & 0x0200)",
          "9256:     strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"FE\");",
          "9257:   else if (features & 0x0100)",
          "9258:     strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"DT\");",
          "9261:   {",
          "9262:     imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FF;",
          "9263:     imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;",
          "9265:     if ((features & 0x0200) && (features & 0x0100))",
          "9266:     {",
          "9267:       imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;",
          "9268:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;",
          "9269:     }",
          "9270:     else if (features & 0x0200)",
          "9271:     {",
          "9272:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;",
          "9273:     }",
          "9274:     else if (features & 0x0100)",
          "9275:     {",
          "9276:       imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;",
          "9278:   }",
          "",
          "---------------",
          "--- Hunk 90 ---",
          "[Context before]",
          "8359:   if (features & 0x0008)",
          "8360:     strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" G\");",
          "8361:   else if (features & 0x0004)",
          "8364:   if ((features & 0x0020) && (features & 0x0040))",
          "8365:     strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Macro\");",
          "",
          "[Removed Lines]",
          "8362:     strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" ZA\" );",
          "",
          "[Added Lines]",
          "9286:     strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" ZA\");",
          "",
          "---------------",
          "--- Hunk 91 ---",
          "[Context before]",
          "8385:     strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" II\");",
          "8387:   if (imgdata.lens.makernotes.LensFeatures_suf[0] == ' ')",
          "8391:   return;",
          "8392: }",
          "8393: #undef strnXcat",
          "8396: {",
          "8397:   ushort lid2;",
          "8398:   if ((imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&",
          "8399:       (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))",
          "8400:     {",
          "8410:     }",
          "8413:   if ((lid2 > 0) && (lid2 < 32784))",
          "8416:   return;",
          "8417: }",
          "8421: {",
          "8422:   ushort lid;",
          "8424:   if ((imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_Sony_E) &&",
          "8425:       (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens))",
          "8436:   if (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens)",
          "8437:     {",
          "8453:     }",
          "8455:   if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)",
          "8462:       (buf[0x010a] | buf[0x0109]))",
          "8485:     }",
          "8487:   if ((id >= 286) && (id <= 293))",
          "8492:   else if (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens)",
          "8527:   return;",
          "8528: }",
          "",
          "[Removed Lines]",
          "8388:     memmove(imgdata.lens.makernotes.LensFeatures_suf, imgdata.lens.makernotes.LensFeatures_suf+1,",
          "8389:      strbuflen(imgdata.lens.makernotes.LensFeatures_suf)-1);",
          "8395: void CLASS process_Sony_0x940c (uchar * buf)",
          "8401:       switch (SonySubstitution[buf[0x0008]]) {",
          "8402:       case 1:",
          "8403:       case 5:",
          "8404:         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;",
          "8405:         break;",
          "8406:       case 4:",
          "8407:         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;",
          "8408:         break;",
          "8409:       }",
          "8411:   lid2 = (((ushort)SonySubstitution[buf[0x000a]])<<8) |",
          "8412:     ((ushort)SonySubstitution[buf[0x0009]]);",
          "8414:     parseSonyLensType2 (SonySubstitution[buf[0x000a]], // LensType2 - Sony lens ids",
          "8415:                         SonySubstitution[buf[0x0009]]);",
          "8420: void CLASS process_Sony_0x9050 (uchar * buf, unsigned id)",
          "8426:     {",
          "8427:       if (buf[0])",
          "8428:         imgdata.lens.makernotes.MaxAp4CurFocal =",
          "8429:           my_roundf(powf64(2.0f, ((float)SonySubstitution[buf[0]] / 8.0 - 1.06f) / 2.0f)*10.0f) / 10.0f;",
          "8431:       if (buf[1])",
          "8432:         imgdata.lens.makernotes.MinAp4CurFocal =",
          "8433:           my_roundf(powf64(2.0f, ((float)SonySubstitution[buf[1]] / 8.0 - 1.06f) / 2.0f)*10.0f) / 10.0f;",
          "8434:     }",
          "8438:       if (buf[0x3d] | buf[0x3c])",
          "8439:         {",
          "8440:           lid = SonySubstitution[buf[0x3d]] << 8 |",
          "8441:             SonySubstitution[buf[0x3c]];",
          "8442:           imgdata.lens.makernotes.CurAp =",
          "8443:             powf64(2.0f, ((float)lid/256.0f - 16.0f) / 2.0f);",
          "8444:         }",
          "8445:       if (buf[0x105] &&",
          "8446:           (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&",
          "8447:           (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))",
          "8448:         imgdata.lens.makernotes.LensMount =",
          "8449:           SonySubstitution[buf[0x105]];",
          "8450:       if (buf[0x106])",
          "8451:         imgdata.lens.makernotes.LensFormat =",
          "8452:           SonySubstitution[buf[0x106]];",
          "8456:     {",
          "8457:       parseSonyLensType2 (SonySubstitution[buf[0x0108]],  // LensType2 - Sony lens ids",
          "8458:                           SonySubstitution[buf[0x0107]]);",
          "8459:     }",
          "8460:   if ((imgdata.lens.makernotes.LensID == -1) &&",
          "8461:       (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) &&",
          "8463:     {",
          "8464:       imgdata.lens.makernotes.LensID =   // LensType - Minolta/Sony lens ids",
          "8465:         SonySubstitution[buf[0x010a]] << 8 |",
          "8466:         SonySubstitution[buf[0x0109]];",
          "8468:       if ((imgdata.lens.makernotes.LensID > 0x4900) &&",
          "8469:           (imgdata.lens.makernotes.LensID <= 0x5900))",
          "8470:         {",
          "8471:           imgdata.lens.makernotes.AdapterID = 0x4900;",
          "8472:           imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;",
          "8473:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;",
          "8474:           strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");",
          "8475:         }",
          "8477:       else if ((imgdata.lens.makernotes.LensID > 0xEF00) &&",
          "8478:           (imgdata.lens.makernotes.LensID < 0xFFFF)      &&",
          "8479:           (imgdata.lens.makernotes.LensID != 0xFF00))",
          "8480:         {",
          "8481:           imgdata.lens.makernotes.AdapterID = 0xEF00;",
          "8482:           imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;",
          "8483:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "8484:         }",
          "8490:     parseSonyLensFeatures (SonySubstitution[buf[0x115]],",
          "8491:                            SonySubstitution[buf[0x116]]);",
          "8493:     parseSonyLensFeatures (SonySubstitution[buf[0x116]],",
          "8494:                            SonySubstitution[buf[0x117]]);",
          "8496:    if ((id==347) || (id==350) || (id==357))",
          "8497:    {",
          "8498:      unsigned long b88 = SonySubstitution[buf[0x88]];",
          "8499:      unsigned long b89 = SonySubstitution[buf[0x89]];",
          "8500:      unsigned long b8a = SonySubstitution[buf[0x8a]];",
          "8501:      unsigned long b8b = SonySubstitution[buf[0x8b]];",
          "8502:      unsigned long b8c = SonySubstitution[buf[0x8c]];",
          "8503:      unsigned long b8d = SonySubstitution[buf[0x8d]];",
          "8504:      sprintf(imgdata.shootinginfo.InternalBodySerial, \"%06lx\",",
          "8505:      (b88<<40) + (b89<<32) + (b8a<<24) + (b8b<<16) + (b8c<<8) + b8d);",
          "8506:    }",
          "8507:    else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) && (id > 279) && (id != 282) && (id != 283))",
          "8508:    {",
          "8509:      unsigned long bf0 = SonySubstitution[buf[0xf0]];",
          "8510:      unsigned long bf1 = SonySubstitution[buf[0xf1]];",
          "8511:      unsigned long bf2 = SonySubstitution[buf[0xf2]];",
          "8512:      unsigned long bf3 = SonySubstitution[buf[0xf3]];",
          "8513:      unsigned long bf4 = SonySubstitution[buf[0xf4]];",
          "8514:      sprintf(imgdata.shootinginfo.InternalBodySerial, \"%05lx\",",
          "8515:       (bf0<<32) + (bf1<<24) + (bf2<<16) + (bf3<<8) +bf4);",
          "8516:    }",
          "8517:    else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E) && (id != 288) && (id != 289)  && (id != 290))",
          "8518:    {",
          "8519:      unsigned b7c = SonySubstitution[buf[0x7c]];",
          "8520:      unsigned b7d = SonySubstitution[buf[0x7d]];",
          "8521:      unsigned b7e = SonySubstitution[buf[0x7e]];",
          "8522:      unsigned b7f = SonySubstitution[buf[0x7f]];",
          "8523:      sprintf(imgdata.shootinginfo.InternalBodySerial, \"%04x\",",
          "8524:      (b7c<<24) + (b7d<<16) + (b7e<<8) + b7f);",
          "8525:    }",
          "",
          "[Added Lines]",
          "9312:     memmove(imgdata.lens.makernotes.LensFeatures_suf, imgdata.lens.makernotes.LensFeatures_suf + 1,",
          "9313:             strbuflen(imgdata.lens.makernotes.LensFeatures_suf) - 1);",
          "9319: void CLASS process_Sony_0x940c(uchar *buf)",
          "9324:   {",
          "9325:     switch (SonySubstitution[buf[0x0008]])",
          "9327:     case 1:",
          "9328:     case 5:",
          "9329:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;",
          "9330:       break;",
          "9331:     case 4:",
          "9332:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;",
          "9333:       break;",
          "9335:   }",
          "9336:   lid2 = (((ushort)SonySubstitution[buf[0x000a]]) << 8) | ((ushort)SonySubstitution[buf[0x0009]]);",
          "9338:     parseSonyLensType2(SonySubstitution[buf[0x000a]], // LensType2 - Sony lens ids",
          "9339:                        SonySubstitution[buf[0x0009]]);",
          "9343: void CLASS process_Sony_0x9050(uchar *buf, unsigned id)",
          "9349:   {",
          "9350:     if (buf[0])",
          "9351:       imgdata.lens.makernotes.MaxAp4CurFocal =",
          "9352:           my_roundf(powf64(2.0f, ((float)SonySubstitution[buf[0]] / 8.0 - 1.06f) / 2.0f) * 10.0f) / 10.0f;",
          "9354:     if (buf[1])",
          "9355:       imgdata.lens.makernotes.MinAp4CurFocal =",
          "9356:           my_roundf(powf64(2.0f, ((float)SonySubstitution[buf[1]] / 8.0 - 1.06f) / 2.0f) * 10.0f) / 10.0f;",
          "9357:   }",
          "9360:   {",
          "9361:     if (buf[0x3d] | buf[0x3c])",
          "9363:       lid = SonySubstitution[buf[0x3d]] << 8 | SonySubstitution[buf[0x3c]];",
          "9364:       imgdata.lens.makernotes.CurAp = powf64(2.0f, ((float)lid / 256.0f - 16.0f) / 2.0f);",
          "9366:     if (buf[0x105] && (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&",
          "9367:         (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))",
          "9368:       imgdata.lens.makernotes.LensMount = SonySubstitution[buf[0x105]];",
          "9369:     if (buf[0x106])",
          "9370:       imgdata.lens.makernotes.LensFormat = SonySubstitution[buf[0x106]];",
          "9371:   }",
          "9374:   {",
          "9375:     parseSonyLensType2(SonySubstitution[buf[0x0108]], // LensType2 - Sony lens ids",
          "9376:                        SonySubstitution[buf[0x0107]]);",
          "9377:   }",
          "9378:   if ((imgdata.lens.makernotes.LensID == -1) && (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) &&",
          "9380:   {",
          "9381:     imgdata.lens.makernotes.LensID = // LensType - Minolta/Sony lens ids",
          "9382:         SonySubstitution[buf[0x010a]] << 8 | SonySubstitution[buf[0x0109]];",
          "9384:     if ((imgdata.lens.makernotes.LensID > 0x4900) && (imgdata.lens.makernotes.LensID <= 0x5900))",
          "9385:     {",
          "9386:       imgdata.lens.makernotes.AdapterID = 0x4900;",
          "9387:       imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;",
          "9388:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;",
          "9389:       strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");",
          "9390:     }",
          "9392:     else if ((imgdata.lens.makernotes.LensID > 0xEF00) && (imgdata.lens.makernotes.LensID < 0xFFFF) &&",
          "9393:              (imgdata.lens.makernotes.LensID != 0xFF00))",
          "9394:     {",
          "9395:       imgdata.lens.makernotes.AdapterID = 0xEF00;",
          "9396:       imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;",
          "9397:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "9399:   }",
          "9404:     parseSonyLensFeatures(SonySubstitution[buf[0x115]], SonySubstitution[buf[0x116]]);",
          "9406:     parseSonyLensFeatures(SonySubstitution[buf[0x116]], SonySubstitution[buf[0x117]]);",
          "9408:   if ((id == 347) || (id == 350) || (id == 357))",
          "9409:   {",
          "9410:     unsigned long b88 = SonySubstitution[buf[0x88]];",
          "9411:     unsigned long b89 = SonySubstitution[buf[0x89]];",
          "9412:     unsigned long b8a = SonySubstitution[buf[0x8a]];",
          "9413:     unsigned long b8b = SonySubstitution[buf[0x8b]];",
          "9414:     unsigned long b8c = SonySubstitution[buf[0x8c]];",
          "9415:     unsigned long b8d = SonySubstitution[buf[0x8d]];",
          "9416:     sprintf(imgdata.shootinginfo.InternalBodySerial, \"%06lx\",",
          "9417:             (b88 << 40) + (b89 << 32) + (b8a << 24) + (b8b << 16) + (b8c << 8) + b8d);",
          "9418:   }",
          "9419:   else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) && (id > 279) && (id != 282) && (id != 283))",
          "9420:   {",
          "9421:     unsigned long bf0 = SonySubstitution[buf[0xf0]];",
          "9422:     unsigned long bf1 = SonySubstitution[buf[0xf1]];",
          "9423:     unsigned long bf2 = SonySubstitution[buf[0xf2]];",
          "9424:     unsigned long bf3 = SonySubstitution[buf[0xf3]];",
          "9425:     unsigned long bf4 = SonySubstitution[buf[0xf4]];",
          "9426:     sprintf(imgdata.shootinginfo.InternalBodySerial, \"%05lx\",",
          "9427:             (bf0 << 32) + (bf1 << 24) + (bf2 << 16) + (bf3 << 8) + bf4);",
          "9428:   }",
          "9429:   else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E) && (id != 288) && (id != 289) && (id != 290))",
          "9430:   {",
          "9431:     unsigned b7c = SonySubstitution[buf[0x7c]];",
          "9432:     unsigned b7d = SonySubstitution[buf[0x7d]];",
          "9433:     unsigned b7e = SonySubstitution[buf[0x7e]];",
          "9434:     unsigned b7f = SonySubstitution[buf[0x7f]];",
          "9435:     sprintf(imgdata.shootinginfo.InternalBodySerial, \"%04x\", (b7c << 24) + (b7d << 16) + (b7e << 8) + b7f);",
          "9436:   }",
          "",
          "---------------",
          "--- Hunk 92 ---",
          "[Context before]",
          "8553:   INT64 fsize = ifp->size();",
          "8555:   fread(buf, 1, 10, ifp);",
          "8557:     base = ftell(ifp);",
          "8558:     order = get2();",
          "8560:     offset = get4();",
          "8561:     fseek(ifp, offset - 8, SEEK_CUR);",
          "8562:   }",
          "8566:     base = ftell(ifp) - 10;",
          "8567:     fseek(ifp, -2, SEEK_CUR);",
          "8568:     order = get2();",
          "8570:   }",
          "8573:     goto nf;",
          "8574:   }",
          "8576:     base = ftell(ifp) - 10;",
          "8578:     fseek(ifp, 2, SEEK_CUR);",
          "8579:   }",
          "8584:     fseek(ifp, -2, SEEK_CUR);",
          "8587:     fseek(ifp, -4, SEEK_CUR);",
          "8589:     fseek(ifp, -10, SEEK_CUR);",
          "8592:       base = ftell(ifp);",
          "8593:   }",
          "8595:   entries = get2();",
          "8597:   morder = order;",
          "8600:     order = morder;",
          "8601:     tiff_get(base, &tag, &type, &len, &save);",
          "8602:     INT64 pos = ifp->tell();",
          "8604:     tag |= uptag << 16;",
          "8608:       {",
          "8633:       }",
          "8635:     else if (!strncmp(make, \"FUJI\", 4))",
          "8638:     else if (!strncasecmp(make, \"LEICA\", 5))",
          "8639:       {",
          "8641:         {",
          "8647:           {",
          "8649:           }",
          "8654:           {",
          "8676:           }",
          "8693:       }",
          "8695:     else if (!strncmp(make, \"NIKON\", 5))",
          "8747:           {",
          "8750:             {",
          "8753:             }",
          "8801:             {",
          "8817:             }",
          "8818:           }",
          "8834:       }",
          "8837:       {",
          "8936:       }",
          "8941:       {",
          "9005:         {",
          "9007:         }",
          "9009:         {",
          "9011:         }",
          "9013:         {",
          "9024:         }",
          "9026:         {",
          "9029:         }",
          "9031:         {",
          "9033:         }",
          "9035:         {",
          "9056:           {",
          "9063:           }",
          "9064:       }",
          "9068:       {",
          "9100:           {",
          "9102:           }",
          "9104:           {",
          "9108:           }",
          "9109:       }",
          "9119:       {",
          "9213:           {",
          "9243:           }",
          "9260:           {",
          "9271:           }",
          "9274:           {",
          "9278:             {",
          "9283:             }",
          "9288:             {",
          "9292:             }",
          "9294:           }",
          "9297:           {",
          "9315:           }",
          "9316:       }",
          "9317:   next:",
          "9319:   }",
          "9321:   order = sorder;",
          "9322: }",
          "9324: #else",
          "9329: #endif",
          "9333: {",
          "9336:   uchar buf97[324], ci, cj, ck;",
          "9338:   char buf[10];",
          "9339:   unsigned SamsungKey[11];",
          "9340:   uchar NikonKey;",
          "",
          "[Removed Lines]",
          "8556:   if (!strcmp(buf, \"Nikon\")) {",
          "8559:     if (get2() != 42) goto quit;",
          "8563:   else if (!strcmp(buf, \"OLYMPUS\") ||",
          "8564:            !strcmp(buf, \"PENTAX \") ||",
          "8565:            (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG))) {",
          "8569:     if (buf[0] == 'O') get2();",
          "8571:   else if (!strncmp(buf, \"SONY\", 4) ||",
          "8572:            !strcmp(buf, \"Panasonic\")) {",
          "8575:   else if (!strncmp(buf, \"FUJIFILM\", 8)) {",
          "8577:   nf: order = 0x4949;",
          "8580:   else if (!strcmp(buf, \"OLYMP\") ||",
          "8581:            !strcmp(buf, \"LEICA\") ||",
          "8582:            !strcmp(buf, \"Ricoh\") ||",
          "8583:            !strcmp(buf, \"EPSON\"))",
          "8585:   else if (!strcmp(buf, \"AOC\") ||",
          "8586:            !strcmp(buf, \"QVC\"))",
          "8588:   else {",
          "8590:     if ((!strncmp(make, \"SAMSUNG\", 7) &&",
          "8591:     (dng_writer == AdobeDNG)))",
          "8596:   if (entries > 1000) return;",
          "8599:   while (entries--) {",
          "8603:     if(len > 8 && pos+len > 2* fsize) continue;",
          "8605:     if(len > 100*1024*1024) goto next; // 100Mb tag? No!",
          "8607:     if (!strncmp(make, \"Canon\",5))",
          "8609:         if (tag == 0x000d && len < 256000) // camera info",
          "8610:           {",
          "8611:             CanonCameraInfo = (uchar*)malloc(len);",
          "8612:             fread(CanonCameraInfo, len, 1, ifp);",
          "8613:             lenCanonCameraInfo = len;",
          "8614:           }",
          "8616:         else if (tag == 0x10)  // Canon ModelID",
          "8617:           {",
          "8618:             unique_id = get4();",
          "8619:             if (unique_id == 0x03740000) unique_id = 0x80000374; // M3",
          "8620:             if (unique_id == 0x03840000) unique_id = 0x80000384; // M10",
          "8621:             if (unique_id == 0x03940000) unique_id = 0x80000394; // M5",
          "8622:             setCanonBodyFeatures(unique_id);",
          "8623:             if (lenCanonCameraInfo)",
          "8624:               {",
          "8625:                 processCanonCameraInfo(unique_id, CanonCameraInfo,lenCanonCameraInfo);",
          "8626:                 free(CanonCameraInfo);",
          "8627:                 CanonCameraInfo = 0;",
          "8628:                 lenCanonCameraInfo = 0;",
          "8629:               }",
          "8630:           }",
          "8632:         else parseCanonMakernotes (tag, type, len);",
          "8636:       parseFujiMakernotes (tag, type);",
          "8640:         if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))",
          "8642:           int ind = tag == 0x035e?0:1;",
          "8643:        for (int j=0; j < 3; j++)",
          "8644:         FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c]= getreal(type);",
          "8645:         }",
          "8646:         if ((tag == 0x0303) && (type != 4))",
          "8648:             stmread(imgdata.lens.makernotes.Lens, len,ifp);",
          "8651:         if ((tag == 0x3405) ||",
          "8652:             (tag == 0x0310) ||",
          "8653:             (tag == 0x34003405))",
          "8655:             imgdata.lens.makernotes.LensID = get4();",
          "8656:             imgdata.lens.makernotes.LensID =",
          "8657:               ((imgdata.lens.makernotes.LensID>>2)<<8) |",
          "8658:               (imgdata.lens.makernotes.LensID & 0x3);",
          "8659:             if (imgdata.lens.makernotes.LensID != -1)",
          "8660:               {",
          "8661:                 if ((model[0] == 'M') ||",
          "8662:                     !strncasecmp (model, \"LEICA M\", 7))",
          "8663:                   {",
          "8664:                     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;",
          "8665:                     if (imgdata.lens.makernotes.LensID)",
          "8666:                       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;",
          "8667:                   }",
          "8668:                 else if ((model[0] == 'S') ||",
          "8669:                          !strncasecmp (model, \"LEICA S\", 7))",
          "8670:                   {",
          "8671:                     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;",
          "8672:                     if (imgdata.lens.makernotes.Lens[0])",
          "8673:                       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;",
          "8674:                   }",
          "8675:               }",
          "8678:         else if (",
          "8679:                  ((tag == 0x0313) || (tag == 0x34003406)) &&",
          "8680:                  (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&",
          "8681:                  ((type == 10) || (type == 5))",
          "8682:                 )",
          "8683:           {",
          "8684:             imgdata.lens.makernotes.CurAp = getreal(type);",
          "8685:             if (imgdata.lens.makernotes.CurAp > 126.3)",
          "8686:               imgdata.lens.makernotes.CurAp = 0.0f;",
          "8687:           }",
          "8689:         else if (tag == 0x3400)",
          "8690:           {",
          "8691:             parse_makernote (base, 0x3400);",
          "8692:           }",
          "8696:       {",
          "8697:         if (tag == 0x1d)       // serial number",
          "8698:           while ((c = fgetc(ifp)) && c != EOF)",
          "8699:           {",
          "8700:             if ((!custom_serial) && (!isdigit(c)))",
          "8701:             {",
          "8702:               if ((strbuflen(model) == 3) && (!strcmp(model,\"D50\")))",
          "8703:               {",
          "8704:                 custom_serial = 34;",
          "8705:               }",
          "8706:               else",
          "8707:               {",
          "8708:                 custom_serial = 96;",
          "8709:               }",
          "8710:             }",
          "8711:             serial = serial*10 + (isdigit(c) ? c - '0' : c % 10);",
          "8712:           }",
          "8713:         else if (tag == 0x000a)",
          "8714:           {",
          "8715:             imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "8716:             imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "8717:           }",
          "8718:         else if (tag == 0x0082)    // lens attachment",
          "8719:           {",
          "8720:             stmread(imgdata.lens.makernotes.Attachment, len, ifp);",
          "8721:           }",
          "8722:         else if (tag == 0x0083)    // lens type",
          "8723:           {",
          "8724:             imgdata.lens.nikon.NikonLensType = fgetc(ifp);",
          "8725:           }",
          "8726:         else if (tag == 0x0084)    // lens",
          "8727:           {",
          "8728:             imgdata.lens.makernotes.MinFocal = getreal(type);",
          "8729:             imgdata.lens.makernotes.MaxFocal = getreal(type);",
          "8730:             imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);",
          "8731:             imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);",
          "8732:           }",
          "8733:         else if (tag == 0x008b)    // lens f-stops",
          "8734:           {",
          "8735:             uchar a, b, c;",
          "8736:             a = fgetc(ifp);",
          "8737:             b = fgetc(ifp);",
          "8738:             c = fgetc(ifp);",
          "8739:             if (c)",
          "8740:               {",
          "8741:                 imgdata.lens.nikon.NikonLensFStops = a*b*(12/c);",
          "8742:                 imgdata.lens.makernotes.LensFStops =",
          "8743:                   (float)imgdata.lens.nikon.NikonLensFStops /12.0f;",
          "8744:               }",
          "8745:           }",
          "8746:         else if (tag == 0x0093)",
          "8748:             i = get2();",
          "8749:             if ((i == 7) || (i == 9))",
          "8751:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "8752:               imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "8754:           }",
          "8755:         else if (tag == 0x0097)",
          "8756:           {",
          "8757:             for (i=0; i < 4; i++)",
          "8758:              ver97 = ver97 * 10 + fgetc(ifp)-'0';",
          "8759:            if (ver97 == 601)  // Coolpix A",
          "8760:            {",
          "8761:              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "8762:                     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "8763:            }",
          "8764:          }",
          "8765:         else if (tag == 0x0098)    // contains lens data",
          "8766:           {",
          "8767:             for (i = 0; i < 4; i++)",
          "8768:               {",
          "8769:                 NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';",
          "8770:               }",
          "8771:             switch (NikonLensDataVersion)",
          "8772:               {",
          "8773:               case 100: lenNikonLensData = 9; break;",
          "8774:               case 101:",
          "8775:               case 201: // encrypted, starting from v.201",
          "8776:               case 202:",
          "8777:               case 203: lenNikonLensData = 15; break;",
          "8778:               case 204: lenNikonLensData = 16; break;",
          "8779:               case 400: lenNikonLensData = 459; break;",
          "8780:               case 401: lenNikonLensData = 590; break;",
          "8781:               case 402: lenNikonLensData = 509; break;",
          "8782:               case 403: lenNikonLensData = 879; break;",
          "8783:               }",
          "8784:             if(lenNikonLensData)",
          "8785:               {",
          "8786:                 table_buf = (uchar*)malloc(lenNikonLensData);",
          "8787:                 fread(table_buf, lenNikonLensData, 1, ifp);",
          "8788:                 if ((NikonLensDataVersion < 201) && lenNikonLensData)",
          "8789:                   {",
          "8790:                     processNikonLensData(table_buf, lenNikonLensData);",
          "8791:                     free(table_buf);",
          "8792:                     lenNikonLensData = 0;",
          "8793:                   }",
          "8794:               }",
          "8795:           }",
          "8797:         else if (tag == 0xa7)     // shutter count",
          "8798:           {",
          "8799:             NikonKey = fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp);",
          "8800:             if ((NikonLensDataVersion > 200) && lenNikonLensData)",
          "8802:               if (custom_serial)",
          "8803:               {",
          "8804:                 ci = xlat[0][custom_serial];",
          "8805:               }",
          "8806:               else",
          "8807:               {",
          "8808:                 ci = xlat[0][serial & 0xff];",
          "8809:               }",
          "8810:               cj = xlat[1][NikonKey];",
          "8811:               ck = 0x60;",
          "8812:               for (i = 0; i < lenNikonLensData; i++)",
          "8813:                 table_buf[i] ^= (cj += ci * ck++);",
          "8814:               processNikonLensData(table_buf, lenNikonLensData);",
          "8815:               lenNikonLensData = 0;",
          "8816:               free(table_buf);",
          "8819:         else if (tag == 0x00a8)  // contains flash data",
          "8820:           {",
          "8821:            for (i = 0; i < 4; i++)",
          "8822:               {",
          "8823:                 NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';",
          "8824:               }",
          "8825:           }",
          "8827:         else if (tag == 37 && (!iso_speed || iso_speed == 65535))",
          "8828:           {",
          "8829:             unsigned char cc;",
          "8830:             fread(&cc, 1, 1, ifp);",
          "8831:             iso_speed = (int)(100.0 * powf64(2.0, (double)(cc) / 12.0 - 5.0));",
          "8832:             break;",
          "8833:           }",
          "8836:     else if (!strncmp(make, \"OLYMPUS\", 7))",
          "8838:         int SubDirOffsetValid =",
          "8839:               strncmp (model, \"E-300\", 5) &&",
          "8840:               strncmp (model, \"E-330\", 5) &&",
          "8841:               strncmp (model, \"E-400\", 5) &&",
          "8842:               strncmp (model, \"E-500\", 5) &&",
          "8843:               strncmp (model, \"E-1\", 3);",
          "8845:         if ((tag == 0x2010) || (tag == 0x2020))",
          "8846:           {",
          "8847:             fseek(ifp, save - 4, SEEK_SET);",
          "8848:             fseek(ifp, base + get4(), SEEK_SET);",
          "8849:             parse_makernote_0xc634(base, tag, dng_writer);",
          "8850:           }",
          "8851:         if (!SubDirOffsetValid &&",
          "8852:             ((len > 4) ||",
          "8853:              ( ((type == 3) || (type == 8)) && (len > 2))  ||",
          "8854:              ( ((type == 4) || (type == 9)) && (len > 1))  || (type == 5) || (type > 9)))",
          "8855:         goto skip_Oly_broken_tags;",
          "8857:         switch (tag) {",
          "8858:         case 0x0207:",
          "8859:         case 0x20100100:",
          "8860:           {",
          "8861:             uchar sOlyID[8];",
          "8862:             unsigned long long OlyID;",
          "8863:             fread (sOlyID, MIN(len,7), 1, ifp);",
          "8864:      sOlyID[7] = 0;",
          "8865:             OlyID = sOlyID[0];",
          "8866:             i = 1;",
          "8867:             while (i < 7 && sOlyID[i])",
          "8868:               {",
          "8869:                 OlyID = OlyID << 8 | sOlyID[i];",
          "8870:                 i++;",
          "8871:               }",
          "8872:             setOlympusBodyFeatures(OlyID);",
          "8873:           }",
          "8874:           break;",
          "8875:         case 0x1002:",
          "8876:           imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type)/2);",
          "8877:           break;",
          "8878:         case 0x20100102:",
          "8879:             stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);",
          "8880:         break;",
          "8881:         case 0x20100201:",
          "8882:           imgdata.lens.makernotes.LensID =",
          "8883:             (unsigned long long)fgetc(ifp)<<16 |",
          "8884:             (unsigned long long)(fgetc(ifp), fgetc(ifp))<<8 |",
          "8885:             (unsigned long long)fgetc(ifp);",
          "8886:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;",
          "8887:           imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;",
          "8888:           if (((imgdata.lens.makernotes.LensID < 0x20000) ||",
          "8889:                (imgdata.lens.makernotes.LensID > 0x4ffff)) &&",
          "8890:               (imgdata.lens.makernotes.LensID & 0x10))",
          "8891:             {",
          "8892:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;",
          "8893:             }",
          "8894:           break;",
          "8895:         case 0x20100202:",
          "8896:           if ((!imgdata.lens.LensSerial[0]))",
          "8897:               stmread(imgdata.lens.LensSerial, len, ifp);",
          "8898:           break;",
          "8899:         case 0x20100203:",
          "8900:           stmread(imgdata.lens.makernotes.Lens,len, ifp);",
          "8901:           break;",
          "8902:         case 0x20100205:",
          "8903:           imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "8904:           break;",
          "8905:         case 0x20100206:",
          "8906:           imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "8907:           break;",
          "8908:         case 0x20100207:",
          "8909:           imgdata.lens.makernotes.MinFocal = (float)get2();",
          "8910:           break;",
          "8911:         case 0x20100208:",
          "8912:           imgdata.lens.makernotes.MaxFocal = (float)get2();",
          "8913:           if (imgdata.lens.makernotes.MaxFocal > 1000.0f)",
          "8914:             imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;",
          "8915:           break;",
          "8916:         case 0x2010020a:",
          "8917:           imgdata.lens.makernotes.MaxAp4CurFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "8918:           break;",
          "8919:         case 0x20100301:",
          "8920:           imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;",
          "8921:           fgetc(ifp);",
          "8922:           imgdata.lens.makernotes.TeleconverterID =",
          "8923:             imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);",
          "8924:           break;",
          "8925:         case 0x20100303:",
          "8926:           stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);",
          "8927:           break;",
          "8928:         case 0x20100403:",
          "8929:           stmread(imgdata.lens.makernotes.Attachment,len, ifp);",
          "8930:           break;",
          "8931:         case 0x20200401:",
          "8932:        imgdata.other.FlashEC = getreal(type);",
          "8933:        break;",
          "8934:         }",
          "8935:         skip_Oly_broken_tags:;",
          "8938:     else if (!strncmp(make, \"PENTAX\", 6) ||",
          "8939:              !strncmp(model, \"PENTAX\", 6) ||",
          "8940:              (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG)))",
          "8942:         if (tag == 0x0005)",
          "8943:           {",
          "8944:             unique_id = get4();",
          "8945:             setPentaxBodyFeatures(unique_id);",
          "8946:           }",
          "8947:         else if (tag == 0x0013)",
          "8948:           {",
          "8949:             imgdata.lens.makernotes.CurAp = (float)get2()/10.0f;",
          "8950:           }",
          "8951:         else if (tag == 0x0014)",
          "8952:           {",
          "8953:             PentaxISO(get2());",
          "8954:           }",
          "8955:         else if (tag == 0x001d)",
          "8956:           {",
          "8957:             imgdata.lens.makernotes.CurFocal = (float)get4()/100.0f;",
          "8958:           }",
          "8959:         else if (tag == 0x003f)",
          "8960:           {",
          "8961:             imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);",
          "8962:           }",
          "8963:         else if (tag == 0x004d)",
          "8964:           {",
          "8965:             if (type == 9) imgdata.other.FlashEC = getreal(type) / 256.0f;",
          "8966:             else imgdata.other.FlashEC = (float) ((signed short) fgetc(ifp)) / 6.0f;",
          "8967:           }",
          "8968:          else if (tag == 0x007e)",
          "8969:            {",
          "8970:              imgdata.color.linear_max[0] =",
          "8971:              imgdata.color.linear_max[1] =",
          "8972:              imgdata.color.linear_max[2] =",
          "8973:              imgdata.color.linear_max[3] = (long)(-1) * get4();",
          "8974:            }",
          "8975:         else if (tag == 0x0207)",
          "8976:           {",
          "8977:      if(len < 65535) // Safety belt",
          "8978:                PentaxLensInfo(imgdata.lens.makernotes.CamID, len);",
          "8979:           }",
          "8980:         else if (tag == 0x020d)",
          "8981:         {",
          "8982:                 FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();",
          "8983:         }",
          "8984:         else if (tag == 0x020e)",
          "8985:         {",
          "8986:                 FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();",
          "8987:         }",
          "8988:         else if (tag == 0x020f)",
          "8989:         {",
          "8990:                 FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();",
          "8991:         }",
          "8992:         else if (tag == 0x0210)",
          "8993:         {",
          "8994:                 FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();",
          "8995:         }",
          "8996:         else if (tag == 0x0211)",
          "8997:         {",
          "8998:                 FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();",
          "8999:         }",
          "9000:         else if (tag == 0x0212)",
          "9001:         {",
          "9002:                 FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();",
          "9003:         }",
          "9004:         else if (tag == 0x0213)",
          "9006:                 FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();",
          "9008:         else if (tag == 0x0214)",
          "9010:                 FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();",
          "9012:         else if (tag == 0x0221)",
          "9014:    int nWB = get2();",
          "9015:    if(nWB<=sizeof(imgdata.color.WBCT_Coeffs)/sizeof(imgdata.color.WBCT_Coeffs[0]))",
          "9016:       for (int i = 0; i < nWB; i++)",
          "9017:         {",
          "9018:    imgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();",
          "9019:    fseek(ifp, 2, SEEK_CUR);",
          "9020:    imgdata.color.WBCT_Coeffs[i][1] = get2();",
          "9021:    imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;",
          "9022:    imgdata.color.WBCT_Coeffs[i][3] = get2();",
          "9023:          }",
          "9025:         else if (tag == 0x0215)",
          "9027:           fseek (ifp, 16, SEEK_CUR);",
          "9028:           sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());",
          "9030:         else if (tag == 0x0229)",
          "9032:           stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "9034:         else if (tag == 0x022d)",
          "9036:    fseek (ifp,2,SEEK_CUR);",
          "9037:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();",
          "9038:    getc(ifp);",
          "9039:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();",
          "9040:    getc(ifp);",
          "9041:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();",
          "9042:    getc(ifp);",
          "9043:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();",
          "9044:    getc(ifp);",
          "9045:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();",
          "9046:    getc(ifp);",
          "9047:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();",
          "9048:    getc(ifp);",
          "9049:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();",
          "9050:    getc(ifp);",
          "9051:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();",
          "9052:    getc(ifp);",
          "9053:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ (c >> 1)] = get2();",
          "9054:         }",
          "9055:         else if (tag == 0x0239)  // Q-series lens info (LensInfoQ)",
          "9057:             char LensInfo [20];",
          "9058:             fseek (ifp, 12, SEEK_CUR);",
          "9059:             stread(imgdata.lens.makernotes.Lens, 30, ifp);",
          "9060:             strcat(imgdata.lens.makernotes.Lens, \" \");",
          "9061:             stread(LensInfo, 20, ifp);",
          "9062:             strcat(imgdata.lens.makernotes.Lens, LensInfo);",
          "9066:     else if (!strncmp(make, \"SAMSUNG\", 7) &&",
          "9067:              (dng_writer == AdobeDNG))",
          "9069:         if (tag == 0x0002)",
          "9070:           {",
          "9071:             if(get4() == 0x2000)",
          "9072:               {",
          "9073:                 imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;",
          "9074:               }",
          "9075:             else if (!strncmp(model, \"NX mini\", 7))",
          "9076:               {",
          "9077:                 imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;",
          "9078:               }",
          "9079:             else",
          "9080:               {",
          "9081:                 imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "9082:                 imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "9083:               }",
          "9084:           }",
          "9085:         else if (tag == 0x0003)",
          "9086:           {",
          "9087:             imgdata.lens.makernotes.CamID = unique_id = get4();",
          "9088:           }",
          "9089:         else if (tag == 0xa003)",
          "9090:           {",
          "9091:             imgdata.lens.makernotes.LensID = get2();",
          "9092:             if (imgdata.lens.makernotes.LensID)",
          "9093:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;",
          "9094:           }",
          "9095:         else if (tag == 0xa005)",
          "9096:           {",
          "9097:             stmread(imgdata.lens.InternalLensSerial, len, ifp);",
          "9098:           }",
          "9099:         else if (tag == 0xa019)",
          "9101:             imgdata.lens.makernotes.CurAp = getreal(type);",
          "9103:         else if (tag == 0xa01a)",
          "9105:             imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;",
          "9106:             if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)",
          "9107:               imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;",
          "9111:     else if (!strncasecmp(make, \"SONY\", 4) ||",
          "9112:              !strncasecmp(make, \"Konica\", 6) ||",
          "9113:              !strncasecmp(make, \"Minolta\", 7) ||",
          "9114:              (!strncasecmp(make, \"Hasselblad\", 10) &&",
          "9115:               (!strncasecmp(model, \"Stellar\", 7) ||",
          "9116:                !strncasecmp(model, \"Lunar\", 5) ||",
          "9117:                !strncasecmp(model, \"Lusso\", 5) ||",
          "9118:                !strncasecmp(model, \"HV\",2))))",
          "9120:         ushort lid;",
          "9122:         if (tag == 0xb001)   // Sony ModelID",
          "9123:           {",
          "9124:             unique_id = get2();",
          "9125:             setSonyBodyFeatures(unique_id);",
          "9126:             if (table_buf_0x9050_present)",
          "9127:               {",
          "9128:                 process_Sony_0x9050(table_buf_0x9050, unique_id);",
          "9129:                 free (table_buf_0x9050);",
          "9130:                 table_buf_0x9050_present = 0;",
          "9131:               }",
          "9132:             if (table_buf_0x940c_present)",
          "9133:               {",
          "9134:                 if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)",
          "9135:                   {",
          "9136:                     process_Sony_0x940c(table_buf_0x940c);",
          "9137:                   }",
          "9138:                 free (table_buf_0x940c);",
          "9139:                 table_buf_0x940c_present = 0;",
          "9140:               }",
          "9141:           }",
          "9142:         else if ((tag == 0x0010) &&     // CameraInfo",
          "9143:                  strncasecmp(model, \"DSLR-A100\", 9) &&",
          "9144:                  strncasecmp(model, \"NEX-5C\", 6) &&",
          "9145:                  !strncasecmp(make, \"SONY\", 4) &&",
          "9146:                  ((len == 368) ||   // a700",
          "9147:                   (len == 5478) ||  // a850, a900",
          "9148:                   (len == 5506) ||  // a200, a300, a350",
          "9149:                   (len == 6118) ||  // a230, a290, a330, a380, a390",
          "9154:                   (len == 15360))",
          "9155:                  )",
          "9156:           {",
          "9157:             table_buf = (uchar*)malloc(len);",
          "9158:             fread(table_buf, len, 1, ifp);",
          "9159:             if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&",
          "9160:                 memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))",
          "9161:               {",
          "9162:                 switch (len) {",
          "9163:                 case 368:",
          "9164:                 case 5478:",
          "9166:                   if (saneSonyCameraInfo(table_buf[0], table_buf[3], table_buf[2], table_buf[5], table_buf[4], table_buf[7]))",
          "9167:                     {",
          "9168:                       if (table_buf[0] | table_buf[3])",
          "9169:                         imgdata.lens.makernotes.MinFocal =",
          "9170:                           bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);",
          "9171:                       if (table_buf[2] | table_buf[5])",
          "9172:                         imgdata.lens.makernotes.MaxFocal =",
          "9173:                           bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);",
          "9174:                       if (table_buf[4])",
          "9175:                         imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;",
          "9176:                       if (table_buf[4])",
          "9177:                         imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;",
          "9178:                       parseSonyLensFeatures(table_buf[1], table_buf[6]);",
          "9179:                     }",
          "9180:                   break;",
          "9181:                 default:",
          "9183:                   if (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6]))",
          "9184:                     {",
          "9185:                       if (table_buf[1] | table_buf[2])",
          "9186:                         imgdata.lens.makernotes.MinFocal =",
          "9187:                           bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);",
          "9188:                       if (table_buf[3] | table_buf[4])",
          "9189:                         imgdata.lens.makernotes.MaxFocal =",
          "9190:                           bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);",
          "9191:                       if (table_buf[5])",
          "9192:                         imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;",
          "9193:                       if (table_buf[6])",
          "9194:                         imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;",
          "9195:                       parseSonyLensFeatures(table_buf[0], table_buf[7]);",
          "9196:                     }",
          "9197:                 }",
          "9198:               }",
          "9199:             free(table_buf);",
          "9200:           }",
          "9202:   else if (tag == 0x0104)",
          "9203:     {",
          "9204:       imgdata.other.FlashEC = getreal(type);",
          "9205:     }",
          "9207:         else if (tag == 0x0105)     // Teleconverter",
          "9208:           {",
          "9209:             imgdata.lens.makernotes.TeleconverterID = get2();",
          "9210:           }",
          "9212:         else if (tag == 0x0114 && len < 65535)     // CameraSettings",
          "9214:             table_buf = (uchar*)malloc(len);",
          "9215:             fread(table_buf, len, 1, ifp);",
          "9216:             switch (len) {",
          "9217:             case 280:",
          "9218:             case 364:",
          "9219:             case 332:",
          "9221:               if (table_buf[2] | table_buf[3])",
          "9222:                 {",
          "9223:                   lid = (((ushort)table_buf[2])<<8) |",
          "9224:                     ((ushort)table_buf[3]);",
          "9225:                   imgdata.lens.makernotes.CurAp =",
          "9226:                     powf64(2.0f, ((float)lid/8.0f-1.0f)/2.0f);",
          "9227:                 }",
          "9228:               break;",
          "9229:             case 1536:",
          "9230:             case 2048:",
          "9232:               parseSonyLensType2(table_buf[1016], table_buf[1015]);",
          "9233:               if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)",
          "9234:                 {",
          "9235:                   switch (table_buf[153]) {",
          "9236:                   case 16: imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A; break;",
          "9237:                   case 17: imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E; break;",
          "9238:                   }",
          "9239:                 }",
          "9240:               break;",
          "9241:             }",
          "9242:             free(table_buf);",
          "9245:         else if (tag == 0x9050 && len < 256000)  // little endian",
          "9246:           {",
          "9247:             table_buf_0x9050 = (uchar*)malloc(len);",
          "9248:             table_buf_0x9050_present = 1;",
          "9249:             fread(table_buf_0x9050, len, 1, ifp);",
          "9251:             if (imgdata.lens.makernotes.CamID)",
          "9252:               {",
          "9253:                 process_Sony_0x9050(table_buf_0x9050, imgdata.lens.makernotes.CamID);",
          "9254:                 free (table_buf_0x9050);",
          "9255:                 table_buf_0x9050_present = 0;",
          "9256:               }",
          "9257:           }",
          "9259:         else if (tag == 0x940c && len < 256000)",
          "9261:             table_buf_0x940c = (uchar*)malloc(len);",
          "9262:             table_buf_0x940c_present = 1;",
          "9263:             fread(table_buf_0x940c, len, 1, ifp);",
          "9264:             if ((imgdata.lens.makernotes.CamID) &&",
          "9265:                 (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E))",
          "9266:               {",
          "9267:                 process_Sony_0x940c(table_buf_0x940c);",
          "9268:                 free(table_buf_0x940c);",
          "9269:                 table_buf_0x940c_present = 0;",
          "9270:               }",
          "9273:         else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))",
          "9275:             imgdata.lens.makernotes.LensID = get4();",
          "9276:             if ((imgdata.lens.makernotes.LensID > 0x4900) &&",
          "9277:                 (imgdata.lens.makernotes.LensID <= 0x5900))",
          "9279:               imgdata.lens.makernotes.AdapterID = 0x4900;",
          "9280:               imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;",
          "9281:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;",
          "9282:               strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");",
          "9285:             else if ((imgdata.lens.makernotes.LensID > 0xEF00) &&",
          "9286:                 (imgdata.lens.makernotes.LensID < 0xFFFF)      &&",
          "9287:                 (imgdata.lens.makernotes.LensID != 0xFF00))",
          "9289:               imgdata.lens.makernotes.AdapterID = 0xEF00;",
          "9290:               imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;",
          "9291:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "9293:             if (tag == 0x010c) imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;",
          "9296:         else if (tag == 0xb02a && len < 256000) // Sony LensSpec",
          "9298:             table_buf = (uchar*)malloc(len);",
          "9299:             fread(table_buf, len, 1, ifp);",
          "9300:             if (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6]))",
          "9301:               {",
          "9302:                 if (table_buf[1] | table_buf[2])",
          "9303:                   imgdata.lens.makernotes.MinFocal =",
          "9304:                     bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);",
          "9305:                 if (table_buf[3] | table_buf[4])",
          "9306:                   imgdata.lens.makernotes.MaxFocal =",
          "9307:                     bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);",
          "9308:                 if (table_buf[5])",
          "9309:                   imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;",
          "9310:                 if (table_buf[6])",
          "9311:                   imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;",
          "9312:                 parseSonyLensFeatures(table_buf[0], table_buf[7]);",
          "9313:               }",
          "9314:             free(table_buf);",
          "9318:     fseek (ifp, save, SEEK_SET);",
          "9320:  quit:",
          "9325: void CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer)",
          "9326: {",
          "9328: }",
          "9332: void CLASS parse_makernote (int base, int uptag)",
          "9334:   unsigned offset=0, entries, tag, type, len, save, c;",
          "9335:   unsigned ver97=0, serial=0, i, wbi=0, wb[4]={0,0,0,0};",
          "9337:   short morder, sorder=order;",
          "",
          "[Added Lines]",
          "9467:   if (!strcmp(buf, \"Nikon\"))",
          "9468:   {",
          "9471:     if (get2() != 42)",
          "9472:       goto quit;",
          "9476:   else if (!strcmp(buf, \"OLYMPUS\") || !strcmp(buf, \"PENTAX \") ||",
          "9477:            (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG)))",
          "9478:   {",
          "9482:     if (buf[0] == 'O')",
          "9483:       get2();",
          "9485:   else if (!strncmp(buf, \"SONY\", 4) || !strcmp(buf, \"Panasonic\"))",
          "9486:   {",
          "9489:   else if (!strncmp(buf, \"FUJIFILM\", 8))",
          "9490:   {",
          "9492:   nf:",
          "9493:     order = 0x4949;",
          "9496:   else if (!strcmp(buf, \"OLYMP\") || !strcmp(buf, \"LEICA\") || !strcmp(buf, \"Ricoh\") || !strcmp(buf, \"EPSON\"))",
          "9498:   else if (!strcmp(buf, \"AOC\") || !strcmp(buf, \"QVC\"))",
          "9500:   else",
          "9501:   {",
          "9503:     if ((!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == AdobeDNG)))",
          "9508:   if (entries > 1000)",
          "9509:     return;",
          "9512:   while (entries--)",
          "9513:   {",
          "9517:     if (len > 8 && pos + len > 2 * fsize)",
          "9518:       continue;",
          "9520:     if (len > 100 * 1024 * 1024)",
          "9521:       goto next; // 100Mb tag? No!",
          "9523:     if (!strncmp(make, \"Canon\", 5))",
          "9524:     {",
          "9525:       if (tag == 0x000d && len < 256000) // camera info",
          "9527:         CanonCameraInfo = (uchar *)malloc(len);",
          "9528:         fread(CanonCameraInfo, len, 1, ifp);",
          "9529:         lenCanonCameraInfo = len;",
          "9530:       }",
          "9532:       else if (tag == 0x10) // Canon ModelID",
          "9533:       {",
          "9534:         unique_id = get4();",
          "9535:         if (unique_id == 0x03740000)",
          "9536:           unique_id = 0x80000374; // M3",
          "9537:         if (unique_id == 0x03840000)",
          "9538:           unique_id = 0x80000384; // M10",
          "9539:         if (unique_id == 0x03940000)",
          "9540:           unique_id = 0x80000394; // M5",
          "9541:         setCanonBodyFeatures(unique_id);",
          "9542:         if (lenCanonCameraInfo)",
          "9543:         {",
          "9544:           processCanonCameraInfo(unique_id, CanonCameraInfo, lenCanonCameraInfo);",
          "9545:           free(CanonCameraInfo);",
          "9546:           CanonCameraInfo = 0;",
          "9547:           lenCanonCameraInfo = 0;",
          "9548:         }",
          "9551:       else",
          "9552:         parseCanonMakernotes(tag, type, len);",
          "9553:     }",
          "9556:       parseFujiMakernotes(tag, type);",
          "9559:     {",
          "9560:       if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))",
          "9561:       {",
          "9562:         int ind = tag == 0x035e ? 0 : 1;",
          "9563:         for (int j = 0; j < 3; j++)",
          "9564:           FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c] = getreal(type);",
          "9565:       }",
          "9566:       if ((tag == 0x0303) && (type != 4))",
          "9568:         stmread(imgdata.lens.makernotes.Lens, len, ifp);",
          "9569:       }",
          "9571:       if ((tag == 0x3405) || (tag == 0x0310) || (tag == 0x34003405))",
          "9572:       {",
          "9573:         imgdata.lens.makernotes.LensID = get4();",
          "9574:         imgdata.lens.makernotes.LensID =",
          "9575:             ((imgdata.lens.makernotes.LensID >> 2) << 8) | (imgdata.lens.makernotes.LensID & 0x3);",
          "9576:         if (imgdata.lens.makernotes.LensID != -1)",
          "9578:           if ((model[0] == 'M') || !strncasecmp(model, \"LEICA M\", 7))",
          "9580:             imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;",
          "9581:             if (imgdata.lens.makernotes.LensID)",
          "9582:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;",
          "9584:           else if ((model[0] == 'S') || !strncasecmp(model, \"LEICA S\", 7))",
          "9586:             imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;",
          "9587:             if (imgdata.lens.makernotes.Lens[0])",
          "9588:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;",
          "9590:         }",
          "9591:       }",
          "9593:       else if (((tag == 0x0313) || (tag == 0x34003406)) && (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&",
          "9594:                ((type == 10) || (type == 5)))",
          "9595:       {",
          "9596:         imgdata.lens.makernotes.CurAp = getreal(type);",
          "9597:         if (imgdata.lens.makernotes.CurAp > 126.3)",
          "9598:           imgdata.lens.makernotes.CurAp = 0.0f;",
          "9599:       }",
          "9601:       else if (tag == 0x3400)",
          "9602:       {",
          "9603:         parse_makernote(base, 0x3400);",
          "9605:     }",
          "9608:     {",
          "9609:       if (tag == 0x1d) // serial number",
          "9610:         while ((c = fgetc(ifp)) && c != EOF)",
          "9611:         {",
          "9612:           if ((!custom_serial) && (!isdigit(c)))",
          "9614:             if ((strbuflen(model) == 3) && (!strcmp(model, \"D50\")))",
          "9616:               custom_serial = 34;",
          "9618:             else",
          "9620:               custom_serial = 96;",
          "9623:           serial = serial * 10 + (isdigit(c) ? c - '0' : c % 10);",
          "9624:         }",
          "9625:       else if (tag == 0x000a)",
          "9626:       {",
          "9627:         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "9628:         imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "9630:       else if (tag == 0x0082) // lens attachment",
          "9632:         stmread(imgdata.lens.makernotes.Attachment, len, ifp);",
          "9634:       else if (tag == 0x0083) // lens type",
          "9636:         imgdata.lens.nikon.NikonLensType = fgetc(ifp);",
          "9637:       }",
          "9638:       else if (tag == 0x0084) // lens",
          "9639:       {",
          "9640:         imgdata.lens.makernotes.MinFocal = getreal(type);",
          "9641:         imgdata.lens.makernotes.MaxFocal = getreal(type);",
          "9642:         imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);",
          "9643:         imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);",
          "9644:       }",
          "9645:       else if (tag == 0x008b) // lens f-stops",
          "9646:       {",
          "9647:         uchar a, b, c;",
          "9648:         a = fgetc(ifp);",
          "9649:         b = fgetc(ifp);",
          "9650:         c = fgetc(ifp);",
          "9651:         if (c)",
          "9653:           imgdata.lens.nikon.NikonLensFStops = a * b * (12 / c);",
          "9654:           imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops / 12.0f;",
          "9656:       }",
          "9657:       else if (tag == 0x0093)",
          "9658:       {",
          "9659:         i = get2();",
          "9660:         if ((i == 7) || (i == 9))",
          "9662:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "9663:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "9665:       }",
          "9666:       else if (tag == 0x0097)",
          "9667:       {",
          "9668:         for (i = 0; i < 4; i++)",
          "9669:           ver97 = ver97 * 10 + fgetc(ifp) - '0';",
          "9670:         if (ver97 == 601) // Coolpix A",
          "9672:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "9673:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "9675:       }",
          "9676:       else if (tag == 0x0098) // contains lens data",
          "9677:       {",
          "9678:         for (i = 0; i < 4; i++)",
          "9680:           NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';",
          "9682:         switch (NikonLensDataVersion)",
          "9684:         case 100:",
          "9685:           lenNikonLensData = 9;",
          "9686:           break;",
          "9687:         case 101:",
          "9688:         case 201: // encrypted, starting from v.201",
          "9689:         case 202:",
          "9690:         case 203:",
          "9691:           lenNikonLensData = 15;",
          "9692:           break;",
          "9693:         case 204:",
          "9694:           lenNikonLensData = 16;",
          "9695:           break;",
          "9696:         case 400:",
          "9697:           lenNikonLensData = 459;",
          "9698:           break;",
          "9699:         case 401:",
          "9700:           lenNikonLensData = 590;",
          "9701:           break;",
          "9702:         case 402:",
          "9703:           lenNikonLensData = 509;",
          "9704:           break;",
          "9705:         case 403:",
          "9706:           lenNikonLensData = 879;",
          "9707:           break;",
          "9709:         if (lenNikonLensData)",
          "9711:           table_buf = (uchar *)malloc(lenNikonLensData);",
          "9712:           fread(table_buf, lenNikonLensData, 1, ifp);",
          "9713:           if ((NikonLensDataVersion < 201) && lenNikonLensData)",
          "9715:             processNikonLensData(table_buf, lenNikonLensData);",
          "9716:             free(table_buf);",
          "9717:             lenNikonLensData = 0;",
          "9719:         }",
          "9722:       else if (tag == 0xa7) // shutter count",
          "9724:         NikonKey = fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp);",
          "9725:         if ((NikonLensDataVersion > 200) && lenNikonLensData)",
          "9726:         {",
          "9727:           if (custom_serial)",
          "9729:             ci = xlat[0][custom_serial];",
          "9731:           else",
          "9733:             ci = xlat[0][serial & 0xff];",
          "9735:           cj = xlat[1][NikonKey];",
          "9736:           ck = 0x60;",
          "9737:           for (i = 0; i < lenNikonLensData; i++)",
          "9738:             table_buf[i] ^= (cj += ci * ck++);",
          "9739:           processNikonLensData(table_buf, lenNikonLensData);",
          "9740:           lenNikonLensData = 0;",
          "9741:           free(table_buf);",
          "9742:         }",
          "9743:       }",
          "9744:       else if (tag == 0x00a8) // contains flash data",
          "9745:       {",
          "9746:         for (i = 0; i < 4; i++)",
          "9747:         {",
          "9748:           NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';",
          "9749:         }",
          "9752:       else if (tag == 37 && (!iso_speed || iso_speed == 65535))",
          "9754:         unsigned char cc;",
          "9755:         fread(&cc, 1, 1, ifp);",
          "9756:         iso_speed = (int)(100.0 * powf64(2.0, (double)(cc) / 12.0 - 5.0));",
          "9757:         break;",
          "9758:       }",
          "9759:     }",
          "9761:     else if (!strncmp(make, \"OLYMPUS\", 7))",
          "9762:     {",
          "9763:       int SubDirOffsetValid = strncmp(model, \"E-300\", 5) && strncmp(model, \"E-330\", 5) && strncmp(model, \"E-400\", 5) &&",
          "9764:                               strncmp(model, \"E-500\", 5) && strncmp(model, \"E-1\", 3);",
          "9766:       if ((tag == 0x2010) || (tag == 0x2020))",
          "9767:       {",
          "9768:         fseek(ifp, save - 4, SEEK_SET);",
          "9769:         fseek(ifp, base + get4(), SEEK_SET);",
          "9770:         parse_makernote_0xc634(base, tag, dng_writer);",
          "9771:       }",
          "9772:       if (!SubDirOffsetValid && ((len > 4) || (((type == 3) || (type == 8)) && (len > 2)) ||",
          "9773:                                  (((type == 4) || (type == 9)) && (len > 1)) || (type == 5) || (type > 9)))",
          "9774:         goto skip_Oly_broken_tags;",
          "9776:       switch (tag)",
          "9777:       {",
          "9778:       case 0x0207:",
          "9779:       case 0x20100100:",
          "9780:       {",
          "9781:         uchar sOlyID[8];",
          "9782:         unsigned long long OlyID;",
          "9783:         fread(sOlyID, MIN(len, 7), 1, ifp);",
          "9784:         sOlyID[7] = 0;",
          "9785:         OlyID = sOlyID[0];",
          "9786:         i = 1;",
          "9787:         while (i < 7 && sOlyID[i])",
          "9788:         {",
          "9789:           OlyID = OlyID << 8 | sOlyID[i];",
          "9790:           i++;",
          "9791:         }",
          "9792:         setOlympusBodyFeatures(OlyID);",
          "9793:       }",
          "9794:       break;",
          "9795:       case 0x1002:",
          "9796:         imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type) / 2);",
          "9797:         break;",
          "9798:       case 0x20100102:",
          "9799:         stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);",
          "9800:         break;",
          "9801:       case 0x20100201:",
          "9802:         imgdata.lens.makernotes.LensID = (unsigned long long)fgetc(ifp) << 16 |",
          "9803:                                          (unsigned long long)(fgetc(ifp), fgetc(ifp)) << 8 |",
          "9804:                                          (unsigned long long)fgetc(ifp);",
          "9805:         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;",
          "9806:         imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;",
          "9807:         if (((imgdata.lens.makernotes.LensID < 0x20000) || (imgdata.lens.makernotes.LensID > 0x4ffff)) &&",
          "9808:             (imgdata.lens.makernotes.LensID & 0x10))",
          "9809:         {",
          "9810:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;",
          "9811:         }",
          "9812:         break;",
          "9813:       case 0x20100202:",
          "9814:         if ((!imgdata.lens.LensSerial[0]))",
          "9815:           stmread(imgdata.lens.LensSerial, len, ifp);",
          "9816:         break;",
          "9817:       case 0x20100203:",
          "9818:         stmread(imgdata.lens.makernotes.Lens, len, ifp);",
          "9819:         break;",
          "9820:       case 0x20100205:",
          "9821:         imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "9822:         break;",
          "9823:       case 0x20100206:",
          "9824:         imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "9825:         break;",
          "9826:       case 0x20100207:",
          "9827:         imgdata.lens.makernotes.MinFocal = (float)get2();",
          "9828:         break;",
          "9829:       case 0x20100208:",
          "9830:         imgdata.lens.makernotes.MaxFocal = (float)get2();",
          "9831:         if (imgdata.lens.makernotes.MaxFocal > 1000.0f)",
          "9832:           imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;",
          "9833:         break;",
          "9834:       case 0x2010020a:",
          "9835:         imgdata.lens.makernotes.MaxAp4CurFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "9836:         break;",
          "9837:       case 0x20100301:",
          "9838:         imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;",
          "9839:         fgetc(ifp);",
          "9840:         imgdata.lens.makernotes.TeleconverterID = imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);",
          "9841:         break;",
          "9842:       case 0x20100303:",
          "9843:         stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);",
          "9844:         break;",
          "9845:       case 0x20100403:",
          "9846:         stmread(imgdata.lens.makernotes.Attachment, len, ifp);",
          "9847:         break;",
          "9848:       case 0x20200401:",
          "9849:         imgdata.other.FlashEC = getreal(type);",
          "9850:         break;",
          "9851:       }",
          "9852:     skip_Oly_broken_tags:;",
          "9853:     }",
          "9855:     else if (!strncmp(make, \"PENTAX\", 6) || !strncmp(model, \"PENTAX\", 6) ||",
          "9856:              (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG)))",
          "9857:     {",
          "9858:       if (tag == 0x0005)",
          "9859:       {",
          "9860:         unique_id = get4();",
          "9861:         setPentaxBodyFeatures(unique_id);",
          "9862:       }",
          "9863:       else if (tag == 0x0013)",
          "9864:       {",
          "9865:         imgdata.lens.makernotes.CurAp = (float)get2() / 10.0f;",
          "9866:       }",
          "9867:       else if (tag == 0x0014)",
          "9868:       {",
          "9869:         PentaxISO(get2());",
          "9870:       }",
          "9871:       else if (tag == 0x001d)",
          "9872:       {",
          "9873:         imgdata.lens.makernotes.CurFocal = (float)get4() / 100.0f;",
          "9874:       }",
          "9875:       else if (tag == 0x003f)",
          "9876:       {",
          "9877:         imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);",
          "9878:       }",
          "9879:       else if (tag == 0x004d)",
          "9880:       {",
          "9881:         if (type == 9)",
          "9882:           imgdata.other.FlashEC = getreal(type) / 256.0f;",
          "9883:         else",
          "9884:           imgdata.other.FlashEC = (float)((signed short)fgetc(ifp)) / 6.0f;",
          "9885:       }",
          "9886:       else if (tag == 0x007e)",
          "9887:       {",
          "9888:         imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =",
          "9889:             imgdata.color.linear_max[3] = (long)(-1) * get4();",
          "9890:       }",
          "9891:       else if (tag == 0x0207)",
          "9892:       {",
          "9893:         if (len < 65535) // Safety belt",
          "9894:           PentaxLensInfo(imgdata.lens.makernotes.CamID, len);",
          "9895:       }",
          "9896:       else if (tag == 0x020d)",
          "9897:       {",
          "9898:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();",
          "9899:       }",
          "9900:       else if (tag == 0x020e)",
          "9901:       {",
          "9902:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();",
          "9903:       }",
          "9904:       else if (tag == 0x020f)",
          "9905:       {",
          "9906:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();",
          "9907:       }",
          "9908:       else if (tag == 0x0210)",
          "9909:       {",
          "9910:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();",
          "9911:       }",
          "9912:       else if (tag == 0x0211)",
          "9913:       {",
          "9914:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();",
          "9915:       }",
          "9916:       else if (tag == 0x0212)",
          "9917:       {",
          "9918:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();",
          "9919:       }",
          "9920:       else if (tag == 0x0213)",
          "9921:       {",
          "9922:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();",
          "9923:       }",
          "9924:       else if (tag == 0x0214)",
          "9925:       {",
          "9926:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();",
          "9927:       }",
          "9928:       else if (tag == 0x0221)",
          "9929:       {",
          "9930:         int nWB = get2();",
          "9931:         if (nWB <= sizeof(imgdata.color.WBCT_Coeffs) / sizeof(imgdata.color.WBCT_Coeffs[0]))",
          "9932:           for (int i = 0; i < nWB; i++)",
          "9934:             imgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();",
          "9935:             fseek(ifp, 2, SEEK_CUR);",
          "9936:             imgdata.color.WBCT_Coeffs[i][1] = get2();",
          "9937:             imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;",
          "9938:             imgdata.color.WBCT_Coeffs[i][3] = get2();",
          "9940:       }",
          "9941:       else if (tag == 0x0215)",
          "9942:       {",
          "9943:         fseek(ifp, 16, SEEK_CUR);",
          "9944:         sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());",
          "9945:       }",
          "9946:       else if (tag == 0x0229)",
          "9947:       {",
          "9948:         stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "9949:       }",
          "9950:       else if (tag == 0x022d)",
          "9951:       {",
          "9952:         fseek(ifp, 2, SEEK_CUR);",
          "9953:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();",
          "9954:         getc(ifp);",
          "9955:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();",
          "9956:         getc(ifp);",
          "9957:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();",
          "9958:         getc(ifp);",
          "9959:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();",
          "9960:         getc(ifp);",
          "9961:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();",
          "9962:         getc(ifp);",
          "9963:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();",
          "9964:         getc(ifp);",
          "9965:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();",
          "9966:         getc(ifp);",
          "9967:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();",
          "9968:         getc(ifp);",
          "9969:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ (c >> 1)] = get2();",
          "9970:       }",
          "9971:       else if (tag == 0x0239) // Q-series lens info (LensInfoQ)",
          "9972:       {",
          "9973:         char LensInfo[20];",
          "9974:         fseek(ifp, 12, SEEK_CUR);",
          "9975:         stread(imgdata.lens.makernotes.Lens, 30, ifp);",
          "9976:         strcat(imgdata.lens.makernotes.Lens, \" \");",
          "9977:         stread(LensInfo, 20, ifp);",
          "9978:         strcat(imgdata.lens.makernotes.Lens, LensInfo);",
          "9979:       }",
          "9980:     }",
          "9982:     else if (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == AdobeDNG))",
          "9983:     {",
          "9984:       if (tag == 0x0002)",
          "9985:       {",
          "9986:         if (get4() == 0x2000)",
          "9987:         {",
          "9988:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;",
          "9989:         }",
          "9990:         else if (!strncmp(model, \"NX mini\", 7))",
          "9991:         {",
          "9992:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;",
          "9993:         }",
          "9994:         else",
          "9995:         {",
          "9996:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "9997:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "9998:         }",
          "9999:       }",
          "10000:       else if (tag == 0x0003)",
          "10001:       {",
          "10002:         imgdata.lens.makernotes.CamID = unique_id = get4();",
          "10003:       }",
          "10004:       else if (tag == 0xa003)",
          "10005:       {",
          "10006:         imgdata.lens.makernotes.LensID = get2();",
          "10007:         if (imgdata.lens.makernotes.LensID)",
          "10008:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;",
          "10009:       }",
          "10010:       else if (tag == 0xa005)",
          "10011:       {",
          "10012:         stmread(imgdata.lens.InternalLensSerial, len, ifp);",
          "10013:       }",
          "10014:       else if (tag == 0xa019)",
          "10015:       {",
          "10016:         imgdata.lens.makernotes.CurAp = getreal(type);",
          "10017:       }",
          "10018:       else if (tag == 0xa01a)",
          "10019:       {",
          "10020:         imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;",
          "10021:         if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)",
          "10022:           imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;",
          "10023:       }",
          "10024:     }",
          "10026:     else if (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"Konica\", 6) || !strncasecmp(make, \"Minolta\", 7) ||",
          "10027:              (!strncasecmp(make, \"Hasselblad\", 10) &&",
          "10028:               (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) ||",
          "10029:                !strncasecmp(model, \"Lusso\", 5) || !strncasecmp(model, \"HV\", 2))))",
          "10030:     {",
          "10031:       ushort lid;",
          "10033:       if (tag == 0xb001) // Sony ModelID",
          "10034:       {",
          "10035:         unique_id = get2();",
          "10036:         setSonyBodyFeatures(unique_id);",
          "10037:         if (table_buf_0x9050_present)",
          "10038:         {",
          "10039:           process_Sony_0x9050(table_buf_0x9050, unique_id);",
          "10040:           free(table_buf_0x9050);",
          "10041:           table_buf_0x9050_present = 0;",
          "10042:         }",
          "10043:         if (table_buf_0x940c_present)",
          "10044:         {",
          "10045:           if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)",
          "10047:             process_Sony_0x940c(table_buf_0x940c);",
          "10049:           free(table_buf_0x940c);",
          "10050:           table_buf_0x940c_present = 0;",
          "10051:         }",
          "10052:       }",
          "10053:       else if ((tag == 0x0010) && // CameraInfo",
          "10054:                strncasecmp(model, \"DSLR-A100\", 9) && strncasecmp(model, \"NEX-5C\", 6) && !strncasecmp(make, \"SONY\", 4) &&",
          "10055:                ((len == 368) ||  // a700",
          "10056:                 (len == 5478) || // a850, a900",
          "10057:                 (len == 5506) || // a200, a300, a350",
          "10058:                 (len == 6118) || // a230, a290, a330, a380, a390",
          "10063:                 (len == 15360)))",
          "10064:       {",
          "10065:         table_buf = (uchar *)malloc(len);",
          "10066:         fread(table_buf, len, 1, ifp);",
          "10067:         if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&",
          "10068:             memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))",
          "10069:         {",
          "10070:           switch (len)",
          "10072:           case 368:",
          "10073:           case 5478:",
          "10075:             if (saneSonyCameraInfo(table_buf[0], table_buf[3], table_buf[2], table_buf[5], table_buf[4], table_buf[7]))",
          "10077:               if (table_buf[0] | table_buf[3])",
          "10078:                 imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);",
          "10079:               if (table_buf[2] | table_buf[5])",
          "10080:                 imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);",
          "10081:               if (table_buf[4])",
          "10082:                 imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;",
          "10083:               if (table_buf[4])",
          "10084:                 imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;",
          "10085:               parseSonyLensFeatures(table_buf[1], table_buf[6]);",
          "10087:             break;",
          "10088:           default:",
          "10090:             if (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6]))",
          "10092:               if (table_buf[1] | table_buf[2])",
          "10093:                 imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);",
          "10094:               if (table_buf[3] | table_buf[4])",
          "10095:                 imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);",
          "10096:               if (table_buf[5])",
          "10097:                 imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;",
          "10098:               if (table_buf[6])",
          "10099:                 imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;",
          "10100:               parseSonyLensFeatures(table_buf[0], table_buf[7]);",
          "10103:         }",
          "10104:         free(table_buf);",
          "10105:       }",
          "10107:       else if (tag == 0x0104)",
          "10108:       {",
          "10109:         imgdata.other.FlashEC = getreal(type);",
          "10110:       }",
          "10112:       else if (tag == 0x0105) // Teleconverter",
          "10113:       {",
          "10114:         imgdata.lens.makernotes.TeleconverterID = get2();",
          "10115:       }",
          "10117:       else if (tag == 0x0114 && len < 65535) // CameraSettings",
          "10118:       {",
          "10119:         table_buf = (uchar *)malloc(len);",
          "10120:         fread(table_buf, len, 1, ifp);",
          "10121:         switch (len)",
          "10122:         {",
          "10123:         case 280:",
          "10124:         case 364:",
          "10125:         case 332:",
          "10127:           if (table_buf[2] | table_buf[3])",
          "10129:             lid = (((ushort)table_buf[2]) << 8) | ((ushort)table_buf[3]);",
          "10130:             imgdata.lens.makernotes.CurAp = powf64(2.0f, ((float)lid / 8.0f - 1.0f) / 2.0f);",
          "10131:           }",
          "10132:           break;",
          "10133:         case 1536:",
          "10134:         case 2048:",
          "10136:           parseSonyLensType2(table_buf[1016], table_buf[1015]);",
          "10137:           if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)",
          "10138:           {",
          "10139:             switch (table_buf[153])",
          "10140:             {",
          "10141:             case 16:",
          "10142:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;",
          "10143:               break;",
          "10144:             case 17:",
          "10145:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;",
          "10146:               break;",
          "10147:             }",
          "10149:           break;",
          "10150:         }",
          "10151:         free(table_buf);",
          "10152:       }",
          "10154:       else if (tag == 0x9050 && len < 256000) // little endian",
          "10155:       {",
          "10156:         table_buf_0x9050 = (uchar *)malloc(len);",
          "10157:         table_buf_0x9050_present = 1;",
          "10158:         fread(table_buf_0x9050, len, 1, ifp);",
          "10160:         if (imgdata.lens.makernotes.CamID)",
          "10161:         {",
          "10162:           process_Sony_0x9050(table_buf_0x9050, imgdata.lens.makernotes.CamID);",
          "10163:           free(table_buf_0x9050);",
          "10164:           table_buf_0x9050_present = 0;",
          "10165:         }",
          "10166:       }",
          "10168:       else if (tag == 0x940c && len < 256000)",
          "10169:       {",
          "10170:         table_buf_0x940c = (uchar *)malloc(len);",
          "10171:         table_buf_0x940c_present = 1;",
          "10172:         fread(table_buf_0x940c, len, 1, ifp);",
          "10173:         if ((imgdata.lens.makernotes.CamID) && (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E))",
          "10174:         {",
          "10175:           process_Sony_0x940c(table_buf_0x940c);",
          "10176:           free(table_buf_0x940c);",
          "10177:           table_buf_0x940c_present = 0;",
          "10178:         }",
          "10179:       }",
          "10181:       else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))",
          "10182:       {",
          "10183:         imgdata.lens.makernotes.LensID = get4();",
          "10184:         if ((imgdata.lens.makernotes.LensID > 0x4900) && (imgdata.lens.makernotes.LensID <= 0x5900))",
          "10185:         {",
          "10186:           imgdata.lens.makernotes.AdapterID = 0x4900;",
          "10187:           imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;",
          "10188:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;",
          "10189:           strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");",
          "10190:         }",
          "10192:         else if ((imgdata.lens.makernotes.LensID > 0xEF00) && (imgdata.lens.makernotes.LensID < 0xFFFF) &&",
          "10193:                  (imgdata.lens.makernotes.LensID != 0xFF00))",
          "10194:         {",
          "10195:           imgdata.lens.makernotes.AdapterID = 0xEF00;",
          "10196:           imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;",
          "10197:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "10198:         }",
          "10199:         if (tag == 0x010c)",
          "10200:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;",
          "10203:       else if (tag == 0xb02a && len < 256000) // Sony LensSpec",
          "10204:       {",
          "10205:         table_buf = (uchar *)malloc(len);",
          "10206:         fread(table_buf, len, 1, ifp);",
          "10207:         if (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6]))",
          "10208:         {",
          "10209:           if (table_buf[1] | table_buf[2])",
          "10210:             imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);",
          "10211:           if (table_buf[3] | table_buf[4])",
          "10212:             imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);",
          "10213:           if (table_buf[5])",
          "10214:             imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;",
          "10215:           if (table_buf[6])",
          "10216:             imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;",
          "10217:           parseSonyLensFeatures(table_buf[0], table_buf[7]);",
          "10218:         }",
          "10219:         free(table_buf);",
          "10220:       }",
          "10221:     }",
          "10223:     fseek(ifp, save, SEEK_SET);",
          "10225: quit:",
          "10230: void CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer) { /*placeholder */}",
          "10233: void CLASS parse_makernote(int base, int uptag)",
          "10235:   unsigned offset = 0, entries, tag, type, len, save, c;",
          "10236:   unsigned ver97 = 0, serial = 0, i, wbi = 0, wb[4] = {0, 0, 0, 0};",
          "10238:   short morder, sorder = order;",
          "",
          "---------------",
          "--- Hunk 93 ---",
          "[Context before]",
          "9358:   INT64 fsize = ifp->size();",
          "9359: #endif",
          "9372:     order = 0x4d4d;",
          "9375:       wb[3] = get2();",
          "9379:     }",
          "9380:     goto quit;",
          "9381:   }",
          "9383:     base = ftell(ifp);",
          "9384:     order = get2();",
          "9386:     offset = get4();",
          "9392:     order = get2();",
          "9396:     goto nf;",
          "9412:       base = ftell(ifp);",
          "9413:   }",
          "9416:   if (!strncasecmp(make, \"LEICA\", 5))",
          "9417:     {",
          "9447: #ifdef LIBRAW_LIBRARY_BUILD",
          "9449: #endif",
          "9451: #ifdef LIBRAW_LIBRARY_BUILD",
          "9458:     }",
          "9460:   entries = get2();",
          "9462:   morder = order;",
          "9465:     order = morder;",
          "9467:     tag |= uptag << 16;",
          "9469: #ifdef LIBRAW_LIBRARY_BUILD",
          "9470:     INT64 _pos = ftell(ifp);",
          "9473:       {",
          "9567:       }",
          "9568:       else",
          "9570:     }",
          "9573:       {",
          "9575:         {",
          "9582:           {",
          "9677:             {",
          "9680:             }",
          "9681:           }",
          "9724:       }",
          "9727:       {",
          "9820:       }",
          "9873:       }",
          "9877:       {",
          "9887:           {",
          "9889:           }",
          "9892:           {",
          "9894:           }",
          "9937:       }",
          "9943:       {",
          "9983:         {",
          "9985:         }",
          "9987:         {",
          "9989:         }",
          "9991:         {",
          "9993:         }",
          "9995:         {",
          "9997:         }",
          "9999:         {",
          "10001:         }",
          "10003:         {",
          "10005:         }",
          "10007:         {",
          "10009:         }",
          "10011:         {",
          "10013:         }",
          "10015:         {",
          "10026:         }",
          "10028:         {",
          "10031:         }",
          "10033:         {",
          "10035:         }",
          "10037:         {",
          "10056:         }",
          "10058:           {",
          "10065:           }",
          "10066:       }",
          "10068:     else if (!strncmp(make, \"SAMSUNG\", 7))",
          "10069:       {",
          "10114:       }",
          "10119:              (!strncasecmp(make, \"Hasselblad\", 10) &&",
          "10124:       {",
          "10127:         {",
          "10145:         }",
          "10160:           {",
          "10199:           }",
          "10214:           {",
          "10216:           }",
          "10219:           {",
          "10234:               break;",
          "10246:               break;",
          "10247:             }",
          "10249:           }",
          "10303:           {",
          "10318:           }",
          "10319:       }",
          "10327:       {",
          "10331:       }",
          "10352:       }",
          "10353:     }",
          "10372: #endif",
          "10540:       }",
          "10541:     }",
          "10542:     if (tag == 0x15 && type == 2 && is_raw)",
          "10547:     }",
          "10549:       while ((c = fgetc(ifp)) && c != EOF)",
          "10550: #ifdef LIBRAW_LIBRARY_BUILD",
          "10551:       {",
          "10552:         if ((!custom_serial) && (!isdigit(c)))",
          "10553:         {",
          "10555:           {",
          "10556:             custom_serial = 34;",
          "10557:           }",
          "",
          "[Removed Lines]",
          "9361:    The MakerNote might have its own TIFF header (possibly with",
          "9362:    its own byte-order!), or it might just be a table.",
          "9364:   if (!strncmp(make,\"Nokia\",5)) return;",
          "9365:   fread (buf, 1, 10, ifp);",
          "9367:       !strncmp (buf,\"VER\" ,3) ||",
          "9368:       !strncmp (buf,\"IIII\",4) ||",
          "9369:       !strncmp (buf,\"MMMM\",4)) return;",
          "9373:     while ((i=ftell(ifp)) < data_offset && i < 16384) {",
          "9374:       wb[0] = wb[2];  wb[2] = wb[1];  wb[1] = wb[3];",
          "9376:       if (wb[1] == 256 && wb[3] == 256 &&",
          "9377:    wb[0] > 256 && wb[0] < 640 && wb[2] > 256 && wb[2] < 640)",
          "9378:  FORC4 cam_mul[c] = wb[c];",
          "9382:   if (!strcmp (buf,\"Nikon\")) {",
          "9385:     if (get2() != 42) goto quit;",
          "9387:     fseek (ifp, offset-8, SEEK_CUR);",
          "9388:   } else if (!strcmp (buf,\"OLYMPUS\") ||",
          "9389:              !strcmp (buf,\"PENTAX \")) {",
          "9390:     base = ftell(ifp)-10;",
          "9391:     fseek (ifp, -2, SEEK_CUR);",
          "9393:     if (buf[0] == 'O') get2();",
          "9394:   } else if (!strncmp (buf,\"SONY\",4) ||",
          "9395:              !strcmp  (buf,\"Panasonic\")) {",
          "9397:   } else if (!strncmp (buf,\"FUJIFILM\",8)) {",
          "9398:     base = ftell(ifp)-10;",
          "9399:  nf: order = 0x4949;",
          "9400:     fseek (ifp,  2, SEEK_CUR);",
          "9401:   } else if (!strcmp (buf,\"OLYMP\") ||",
          "9402:              !strcmp (buf,\"LEICA\") ||",
          "9403:              !strcmp (buf,\"Ricoh\") ||",
          "9404:              !strcmp (buf,\"EPSON\"))",
          "9405:     fseek (ifp, -2, SEEK_CUR);",
          "9406:   else if (!strcmp (buf,\"AOC\") ||",
          "9407:            !strcmp (buf,\"QVC\"))",
          "9408:     fseek (ifp, -4, SEEK_CUR);",
          "9409:   else {",
          "9410:     fseek (ifp, -10, SEEK_CUR);",
          "9411:     if (!strncmp(make,\"SAMSUNG\",7))",
          "9418:       if (!strncmp(model, \"M8\", 2) ||",
          "9419:           !strncasecmp(model, \"Leica M8\", 8) ||",
          "9420:           !strncasecmp(model, \"LEICA X\", 7))",
          "9421:         {",
          "9422:           base = ftell(ifp)-8;",
          "9423:         }",
          "9424:       else if (!strncasecmp(model, \"LEICA M (Typ 240)\", 17))",
          "9425:         {",
          "9426:           base = 0;",
          "9427:         }",
          "9428:       else if (!strncmp(model, \"M9\", 2) ||",
          "9429:                !strncasecmp(model, \"Leica M9\", 8) ||",
          "9430:                !strncasecmp(model, \"M Monochrom\", 11) ||",
          "9431:                !strncasecmp(model, \"Leica M Monochrom\", 11))",
          "9432:         {",
          "9433:           if (!uptag)",
          "9434:             {",
          "9435:               base = ftell(ifp) - 10;",
          "9436:               fseek (ifp, 8, SEEK_CUR);",
          "9437:             }",
          "9438:           else if (uptag == 0x3400)",
          "9439:             {",
          "9440:               fseek (ifp, 10, SEEK_CUR);",
          "9441:               base += 10;",
          "9442:             }",
          "9443:         }",
          "9444:       else if (!strncasecmp(model, \"LEICA T\", 7))",
          "9445:        {",
          "9446:          base = ftell(ifp)-8;",
          "9448:          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_T;",
          "9450:        }",
          "9452:       else if (!strncasecmp(model, \"LEICA SL\", 8))",
          "9453:        {",
          "9454:          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_SL;",
          "9455:          imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;",
          "9456:        }",
          "9457: #endif",
          "9461:   if (entries > 1000) return;",
          "9464:   while (entries--) {",
          "9466:     tiff_get (base, &tag, &type, &len, &save);",
          "9471:     if(len > 8 && _pos+len > 2* fsize) continue;",
          "9472:     if (!strncmp(make, \"Canon\",5))",
          "9474:         if (tag == 0x000d && len < 256000) // camera info",
          "9475:           {",
          "9476:             CanonCameraInfo = (uchar*)malloc(len);",
          "9477:             fread(CanonCameraInfo, len, 1, ifp);",
          "9478:             lenCanonCameraInfo = len;",
          "9479:           }",
          "9481:         else if (tag == 0x10) // Canon ModelID",
          "9482:           {",
          "9483:             unique_id = get4();",
          "9484:             if (unique_id == 0x03740000) unique_id = 0x80000374; // M3",
          "9485:             if (unique_id == 0x03840000) unique_id = 0x80000384; // M10",
          "9486:             if (unique_id == 0x03940000) unique_id = 0x80000394; // M5",
          "9487:             setCanonBodyFeatures(unique_id);",
          "9488:             if (lenCanonCameraInfo)",
          "9489:               {",
          "9490:                 processCanonCameraInfo(unique_id, CanonCameraInfo,lenCanonCameraInfo);",
          "9491:                 free(CanonCameraInfo);",
          "9492:                 CanonCameraInfo = 0;",
          "9493:                 lenCanonCameraInfo = 0;",
          "9494:               }",
          "9495:           }",
          "9497:         else parseCanonMakernotes (tag, type, len);",
          "9498:       }",
          "9500:     else if (!strncmp(make, \"FUJI\", 4)) {",
          "9501:       if (tag == 0x0010) {",
          "9502:          char FujiSerial[sizeof(imgdata.shootinginfo.InternalBodySerial)];",
          "9503:          char *words[4];",
          "9504:          char yy[2], mm[3], dd[3], ystr[16], ynum[16];",
          "9505:          int year, nwords, ynum_len;",
          "9506:          unsigned c;",
          "9507:          stmread(FujiSerial, len, ifp);",
          "9508:          nwords = getwords(FujiSerial, words, 4,sizeof(imgdata.shootinginfo.InternalBodySerial));",
          "9509:          for (int i = 0; i < nwords; i++) {",
          "9510:            mm[2] = dd[2] = 0;",
          "9511:            if (strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1) < 18)",
          "9512:               if (i == 0)",
          "9513:           strncpy (imgdata.shootinginfo.InternalBodySerial,",
          "9514:     words[0],",
          "9515:    sizeof(imgdata.shootinginfo.InternalBodySerial)-1);",
          "9516:               else",
          "9517:        {",
          "9518:         char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];",
          "9519:         snprintf (tbuf, sizeof(tbuf), \"%s %s\",",
          "9520:              imgdata.shootinginfo.InternalBodySerial, words[i]);",
          "9521:         strncpy(imgdata.shootinginfo.InternalBodySerial,tbuf,",
          "9522:              sizeof(imgdata.shootinginfo.InternalBodySerial)-1);",
          "9523:         }",
          "9524:            else",
          "9525:            {",
          "9526:              strncpy (dd, words[i]+strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-14, 2);",
          "9527:              strncpy (mm, words[i]+strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-16, 2);",
          "9528:              strncpy (yy, words[i]+strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-18, 2);",
          "9529:              year = (yy[0]-'0')*10 + (yy[1]-'0');",
          "9530:              if (year <70) year += 2000; else year += 1900;",
          "9532:              ynum_len = (int)strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-18;",
          "9533:              strncpy(ynum, words[i], ynum_len);",
          "9534:              ynum[ynum_len] = 0;",
          "9535:              for ( int j = 0; ynum[j] && ynum[j+1] && sscanf(ynum+j, \"%2x\", &c); j += 2) ystr[j/2] = c;",
          "9536:              ystr[ynum_len / 2 + 1] = 0;",
          "9537:              strcpy (model2, ystr);",
          "9539:              if (i == 0) {",
          "9540:         char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];",
          "9542:                if (nwords == 1)",
          "9543:      snprintf (tbuf,sizeof(tbuf),",
          "9544:       \"%s %s %d:%s:%s\",",
          "9545:       words[0]+strnlen(words[0],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-12,",
          "9546:     ystr, year, mm, dd);",
          "9548:                else",
          "9549:    snprintf (tbuf,sizeof(tbuf),",
          "9550:        \"%s %d:%s:%s %s\",",
          "9551:        ystr, year, mm, dd,",
          "9552:        words[0]+strnlen(words[0],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-12);",
          "9554:         strncpy(imgdata.shootinginfo.InternalBodySerial,tbuf,",
          "9555:              sizeof(imgdata.shootinginfo.InternalBodySerial)-1);",
          "9556:              } else {",
          "9557:   char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];",
          "9558:          snprintf (tbuf, sizeof(tbuf),",
          "9559:   \"%s %s %d:%s:%s %s\",",
          "9560:   imgdata.shootinginfo.InternalBodySerial, ystr, year, mm, dd,",
          "9561:    words[i]+strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-12);",
          "9562:    strncpy(imgdata.shootinginfo.InternalBodySerial,tbuf,",
          "9563:     sizeof(imgdata.shootinginfo.InternalBodySerial)-1);",
          "9564:             }",
          "9565:            }",
          "9566:          }",
          "9569:  parseFujiMakernotes (tag, type);",
          "9572:     else if (!strncasecmp(make, \"LEICA\", 5))",
          "9574:         if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))",
          "9576:           int ind = tag == 0x035e?0:1;",
          "9577:        for (int j=0; j < 3; j++)",
          "9578:         FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c]= getreal(type);",
          "9579:         }",
          "9581:         if ((tag == 0x0303) && (type != 4))",
          "9583:             stmread(imgdata.lens.makernotes.Lens, len, ifp);",
          "9584:           }",
          "9586:         if ((tag == 0x3405) ||",
          "9587:             (tag == 0x0310) ||",
          "9588:             (tag == 0x34003405))",
          "9589:           {",
          "9590:             imgdata.lens.makernotes.LensID = get4();",
          "9591:             imgdata.lens.makernotes.LensID =",
          "9592:               ((imgdata.lens.makernotes.LensID>>2)<<8) |",
          "9593:               (imgdata.lens.makernotes.LensID & 0x3);",
          "9594:             if (imgdata.lens.makernotes.LensID != -1)",
          "9595:               {",
          "9596:                 if ((model[0] == 'M') ||",
          "9597:                     !strncasecmp (model, \"LEICA M\", 7))",
          "9598:                   {",
          "9599:                     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;",
          "9600:                     if (imgdata.lens.makernotes.LensID)",
          "9601:                     imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;",
          "9602:                   }",
          "9603:                 else if ((model[0] == 'S') ||",
          "9604:                          !strncasecmp (model, \"LEICA S\", 7))",
          "9605:                   {",
          "9606:                     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;",
          "9607:                     if (imgdata.lens.makernotes.Lens[0])",
          "9608:                     imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;",
          "9609:                   }",
          "9610:               }",
          "9611:           }",
          "9613:         else if (",
          "9614:                  ((tag == 0x0313) || (tag == 0x34003406)) &&",
          "9615:                  (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&",
          "9616:                  ((type == 10) || (type == 5))",
          "9617:                  )",
          "9618:           {",
          "9619:             imgdata.lens.makernotes.CurAp = getreal(type);",
          "9620:             if (imgdata.lens.makernotes.CurAp > 126.3)",
          "9621:               imgdata.lens.makernotes.CurAp = 0.0f;",
          "9622:           }",
          "9624:         else if (tag == 0x3400)",
          "9625:           {",
          "9626:             parse_makernote (base, 0x3400);",
          "9627:           }",
          "9628:       }",
          "9630:     else if (!strncmp(make, \"NIKON\",5))",
          "9631:       {",
          "9632:         if (tag == 0x000a)",
          "9633:           {",
          "9634:             imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "9635:             imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "9636:           }",
          "9637:         else if (tag == 0x0012)",
          "9638:           {",
          "9639:             char a, b, c;",
          "9640:             a = fgetc(ifp);",
          "9641:             b = fgetc(ifp);",
          "9642:             c = fgetc(ifp);",
          "9643:             if (c) imgdata.other.FlashEC = (float)(a*b)/(float)c;",
          "9644:           }",
          "9645:         else if (tag == 0x0082)    // lens attachment",
          "9646:           {",
          "9647:             stmread(imgdata.lens.makernotes.Attachment, len, ifp);",
          "9648:           }",
          "9649:         else if (tag == 0x0083)    // lens type",
          "9650:           {",
          "9651:             imgdata.lens.nikon.NikonLensType = fgetc(ifp);",
          "9652:           }",
          "9653:         else if (tag == 0x0084)    // lens",
          "9654:           {",
          "9655:             imgdata.lens.makernotes.MinFocal = getreal(type);",
          "9656:             imgdata.lens.makernotes.MaxFocal = getreal(type);",
          "9657:             imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);",
          "9658:             imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);",
          "9659:           }",
          "9660:         else if (tag == 0x008b)    // lens f-stops",
          "9661:           {",
          "9662:             uchar a, b, c;",
          "9663:             a = fgetc(ifp);",
          "9664:             b = fgetc(ifp);",
          "9665:             c = fgetc(ifp);",
          "9666:             if (c)",
          "9667:               {",
          "9668:                 imgdata.lens.nikon.NikonLensFStops = a*b*(12/c);",
          "9669:                 imgdata.lens.makernotes.LensFStops =",
          "9670:                   (float)imgdata.lens.nikon.NikonLensFStops /12.0f;",
          "9671:               }",
          "9672:           }",
          "9673:         else if (tag == 0x0093)",
          "9674:           {",
          "9675:             i = get2();",
          "9676:             if ((i == 7) || (i == 9))",
          "9678:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "9679:               imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "9682:         else if (tag == 0x0098)    // contains lens data",
          "9683:           {",
          "9684:             for (i = 0; i < 4; i++)",
          "9685:               {",
          "9686:                 NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';",
          "9687:               }",
          "9688:             switch (NikonLensDataVersion)",
          "9689:               {",
          "9690:               case 100: lenNikonLensData = 9; break;",
          "9691:               case 101:",
          "9692:               case 201: // encrypted, starting from v.201",
          "9693:               case 202:",
          "9694:               case 203: lenNikonLensData = 15; break;",
          "9695:               case 204: lenNikonLensData = 16; break;",
          "9696:               case 400: lenNikonLensData = 459; break;",
          "9697:               case 401: lenNikonLensData = 590; break;",
          "9698:               case 402: lenNikonLensData = 509; break;",
          "9699:               case 403: lenNikonLensData = 879; break;",
          "9700:               }",
          "9701:             if(lenNikonLensData>0)",
          "9702:               {",
          "9703:                 table_buf = (uchar*)malloc(lenNikonLensData);",
          "9704:                 fread(table_buf, lenNikonLensData, 1, ifp);",
          "9705:                 if ((NikonLensDataVersion < 201) && lenNikonLensData)",
          "9706:                   {",
          "9707:                     processNikonLensData(table_buf, lenNikonLensData);",
          "9708:                     free(table_buf);",
          "9709:                     lenNikonLensData = 0;",
          "9710:                   }",
          "9711:               }",
          "9712:           }",
          "9713:         else if (tag == 0x00a0)",
          "9714:           {",
          "9715:             stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "9716:           }",
          "9717:         else if (tag == 0x00a8)  // contains flash data",
          "9718:           {",
          "9719:            for (i = 0; i < 4; i++)",
          "9720:               {",
          "9721:                 NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';",
          "9722:               }",
          "9723:           }",
          "9726:     else if (!strncmp(make, \"OLYMPUS\", 7))",
          "9728:         switch (tag) {",
          "9729:         case 0x0404:",
          "9730:         case 0x101a:",
          "9731:         case 0x20100101:",
          "9732:           if (!imgdata.shootinginfo.BodySerial[0])",
          "9733:             stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "9734:         break;",
          "9735:         case 0x20100102:",
          "9736:           if (!imgdata.shootinginfo.InternalBodySerial[0])",
          "9737:             stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);",
          "9738:         break;",
          "9739:         case 0x0207:",
          "9740:         case 0x20100100:",
          "9741:           {",
          "9742:             uchar sOlyID[8];",
          "9743:             unsigned long long OlyID;",
          "9744:             fread (sOlyID, MIN(len,7), 1, ifp);",
          "9745:      sOlyID[7] = 0;",
          "9746:             OlyID = sOlyID[0];",
          "9747:             i = 1;",
          "9748:             while (i < 7 && sOlyID[i])",
          "9749:               {",
          "9750:                 OlyID = OlyID << 8 | sOlyID[i];",
          "9751:                 i++;",
          "9752:               }",
          "9753:             setOlympusBodyFeatures(OlyID);",
          "9754:           }",
          "9755:           break;",
          "9756:         case 0x1002:",
          "9757:           imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type)/2);",
          "9758:           break;",
          "9759:         case 0x20401112:",
          "9760:           imgdata.makernotes.olympus.OlympusCropID = get2();",
          "9761:           break;",
          "9762:         case 0x20401113:",
          "9763:           FORC4 imgdata.makernotes.olympus.OlympusFrame[c] = get2();",
          "9764:           break;",
          "9765:         case 0x20100201:",
          "9766:           {",
          "9767:             unsigned long long oly_lensid [3];",
          "9768:             oly_lensid[0] = fgetc(ifp);",
          "9769:             fgetc(ifp);",
          "9770:             oly_lensid[1] = fgetc(ifp);",
          "9771:             oly_lensid[2] = fgetc(ifp);",
          "9772:             imgdata.lens.makernotes.LensID =",
          "9773:               (oly_lensid[0] << 16) | (oly_lensid[1] << 8) | oly_lensid[2];",
          "9774:           }",
          "9775:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;",
          "9776:           imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;",
          "9777:           if (((imgdata.lens.makernotes.LensID < 0x20000) ||",
          "9778:                (imgdata.lens.makernotes.LensID > 0x4ffff)) &&",
          "9779:               (imgdata.lens.makernotes.LensID & 0x10))",
          "9780:             {",
          "9781:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;",
          "9782:             }",
          "9783:           break;",
          "9784:         case 0x20100202:",
          "9785:           stmread(imgdata.lens.LensSerial, len, ifp);",
          "9786:           break;",
          "9787:         case 0x20100203:",
          "9788:           stmread(imgdata.lens.makernotes.Lens, len, ifp);",
          "9789:           break;",
          "9790:         case 0x20100205:",
          "9791:           imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "9792:           break;",
          "9793:         case 0x20100206:",
          "9794:           imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "9795:           break;",
          "9796:         case 0x20100207:",
          "9797:           imgdata.lens.makernotes.MinFocal = (float)get2();",
          "9798:           break;",
          "9799:         case 0x20100208:",
          "9800:           imgdata.lens.makernotes.MaxFocal = (float)get2();",
          "9801:           if (imgdata.lens.makernotes.MaxFocal > 1000.0f)",
          "9802:             imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;",
          "9803:           break;",
          "9804:         case 0x2010020a:",
          "9805:           imgdata.lens.makernotes.MaxAp4CurFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "9806:           break;",
          "9807:         case 0x20100301:",
          "9808:           imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;",
          "9809:           fgetc(ifp);",
          "9810:           imgdata.lens.makernotes.TeleconverterID =",
          "9811:             imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);",
          "9812:           break;",
          "9813:         case 0x20100303:",
          "9814:           stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);",
          "9815:           break;",
          "9816:         case 0x20100403:",
          "9817:           stmread(imgdata.lens.makernotes.Attachment, len, ifp);",
          "9818:           break;",
          "9819:         }",
          "9822:     else if ((!strncmp(make, \"PENTAX\", 6) || !strncmp(make, \"RICOH\", 5)) &&",
          "9823:              !strncmp(model, \"GR\", 2))",
          "9824:       {",
          "9825:         if (tag == 0x0005)",
          "9826:        {",
          "9827:           char buffer[17];",
          "9828:           int count=0;",
          "9829:           fread(buffer, 16, 1, ifp);",
          "9830:           buffer[16] = 0;",
          "9831:           for (int i=0; i<16; i++)",
          "9832:           {",
          "9834:              if ((isspace(buffer[i])) ||",
          "9835:                  (buffer[i] == 0x2D) ||",
          "9836:                  (isalnum(buffer[i])))",
          "9837:              count++;",
          "9838:           }",
          "9839:           if (count == 16)",
          "9840:           {",
          "9841:              sprintf (imgdata.shootinginfo.BodySerial, \"%8s\", buffer+8);",
          "9842:              buffer[8] = 0;",
          "9843:              sprintf (imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);",
          "9844:           }",
          "9845:           else",
          "9846:           {",
          "9847:              sprintf (imgdata.shootinginfo.BodySerial, \"%02x%02x%02x%02x\", buffer[4], buffer[5], buffer[6], buffer[7]);",
          "9848:              sprintf (imgdata.shootinginfo.InternalBodySerial, \"%02x%02x%02x%02x\", buffer[8], buffer[9], buffer[10], buffer[11]);",
          "9849:           }",
          "9850:        }",
          "9851:         else if ((tag == 0x1001) && (type == 3))",
          "9852:           {",
          "9853:             imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "9854:             imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "9855:             imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;",
          "9856:             imgdata.lens.makernotes.LensID = -1;",
          "9857:             imgdata.lens.makernotes.FocalType = 1;",
          "9858:           }",
          "9860:         else if ((tag == 0x100b) && (type == 10))",
          "9861:           {",
          "9862:             imgdata.other.FlashEC = getreal(type);",
          "9863:           }",
          "9865:         else if ((tag == 0x1017) && (get2() == 2))",
          "9866:           {",
          "9867:             strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");",
          "9868:           }",
          "9869:         else if (tag == 0x1500)",
          "9870:           {",
          "9871:             imgdata.lens.makernotes.CurFocal = getreal(type);",
          "9872:           }",
          "9875:     else if (!strncmp(make, \"RICOH\", 5) &&",
          "9876:              strncmp(model, \"PENTAX\", 6))",
          "9878:      if ((tag == 0x0005) && !strncmp(model, \"GXR\", 3))",
          "9879:        {",
          "9880:           char buffer[9];",
          "9881:           buffer[8] = 0;",
          "9882:           fread(buffer, 8, 1, ifp);",
          "9883:           sprintf (imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);",
          "9884:        }",
          "9886:      else if ((tag == 0x100b) && (type == 10))",
          "9888:             imgdata.other.FlashEC = getreal(type);",
          "9891:           else if ((tag == 0x1017) && (get2() == 2))",
          "9893:             strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");",
          "9896:         else if (tag == 0x1500)",
          "9897:           {",
          "9898:             imgdata.lens.makernotes.CurFocal = getreal(type);",
          "9899:           }",
          "9901:         else if ((tag == 0x2001) && !strncmp(model, \"GXR\", 3))",
          "9902:           {",
          "9903:             short ntags, cur_tag;",
          "9904:             fseek(ifp, 20, SEEK_CUR);",
          "9905:             ntags = get2();",
          "9906:             cur_tag = get2();",
          "9907:             while (cur_tag != 0x002c)",
          "9908:               {",
          "9909:                 fseek(ifp, 10, SEEK_CUR);",
          "9910:                 cur_tag = get2();",
          "9911:               }",
          "9912:             fseek(ifp, 6, SEEK_CUR);",
          "9913:             fseek(ifp, get4()+20, SEEK_SET);",
          "9914:             stread(imgdata.shootinginfo.BodySerial, 12, ifp);",
          "9915:             get2();",
          "9916:             imgdata.lens.makernotes.LensID = getc(ifp) - '0';",
          "9917:             switch(imgdata.lens.makernotes.LensID) {",
          "9918:               case 1:",
          "9919:               case 2:",
          "9920:               case 3:",
          "9921:               case 5:",
          "9922:               case 6:",
          "9923:              imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "9924:              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_RicohModule;",
          "9925:               break;",
          "9926:               case 8:",
          "9927:              imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;",
          "9928:              imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;",
          "9929:              imgdata.lens.makernotes.LensID = -1;",
          "9930:               break;",
          "9931:               default:",
          "9932:              imgdata.lens.makernotes.LensID = -1;",
          "9933:             }",
          "9934:             fseek(ifp, 17, SEEK_CUR);",
          "9935:             stread(imgdata.lens.LensSerial, 12, ifp);",
          "9936:           }",
          "9939:     else if ((!strncmp(make, \"PENTAX\", 6) ||",
          "9940:               !strncmp(model, \"PENTAX\", 6) ||",
          "9941:              (!strncmp(make, \"SAMSUNG\", 7) && dng_version)) &&",
          "9942:              strncmp(model, \"GR\", 2))",
          "9944:         if (tag == 0x0005)",
          "9945:           {",
          "9946:             unique_id = get4();",
          "9947:             setPentaxBodyFeatures(unique_id);",
          "9948:           }",
          "9949:         else if (tag == 0x0013)",
          "9950:           {",
          "9951:             imgdata.lens.makernotes.CurAp = (float)get2()/10.0f;",
          "9952:           }",
          "9953:         else if (tag == 0x0014)",
          "9954:           {",
          "9955:             PentaxISO(get2());",
          "9956:           }",
          "9957:         else if (tag == 0x001d)",
          "9958:           {",
          "9959:             imgdata.lens.makernotes.CurFocal = (float)get4()/100.0f;",
          "9960:           }",
          "9961:         else if (tag == 0x003f)",
          "9962:           {",
          "9963:             imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);",
          "9964:           }",
          "9965:         else if (tag == 0x004d)",
          "9966:           {",
          "9967:             if (type == 9) imgdata.other.FlashEC = getreal(type) / 256.0f;",
          "9968:             else imgdata.other.FlashEC = (float) ((signed short) fgetc(ifp)) / 6.0f;",
          "9969:           }",
          "9970:          else if (tag == 0x007e)",
          "9971:            {",
          "9972:              imgdata.color.linear_max[0] =",
          "9973:              imgdata.color.linear_max[1] =",
          "9974:              imgdata.color.linear_max[2] =",
          "9975:              imgdata.color.linear_max[3] = (long)(-1) * get4();",
          "9976:            }",
          "9977:         else if (tag == 0x0207)",
          "9978:           {",
          "9979:      if(len < 65535) // Safety belt",
          "9980:              PentaxLensInfo(imgdata.lens.makernotes.CamID, len);",
          "9981:           }",
          "9982:         else if (tag == 0x020d)",
          "9984:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();",
          "9986:         else if (tag == 0x020e)",
          "9988:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();",
          "9990:         else if (tag == 0x020f)",
          "9992:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();",
          "9994:         else if (tag == 0x0210)",
          "9996:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();",
          "9998:         else if (tag == 0x0211)",
          "10000:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();",
          "10002:         else if (tag == 0x0212)",
          "10004:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();",
          "10006:         else if (tag == 0x0213)",
          "10008:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();",
          "10010:         else if (tag == 0x0214)",
          "10012:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();",
          "10014:         else if (tag == 0x0221)",
          "10016:    int nWB = get2();",
          "10017:    if(nWB<=sizeof(imgdata.color.WBCT_Coeffs)/sizeof(imgdata.color.WBCT_Coeffs[0]))",
          "10018:      for (int i = 0; i < nWB; i++)",
          "10019:        {",
          "10020:   imgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();",
          "10021:   fseek(ifp, 2, SEEK_CUR);",
          "10022:   imgdata.color.WBCT_Coeffs[i][1] = get2();",
          "10023:   imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;",
          "10024:   imgdata.color.WBCT_Coeffs[i][3] = get2();",
          "10025:        }",
          "10027:         else if (tag == 0x0215)",
          "10029:           fseek (ifp, 16, SEEK_CUR);",
          "10030:           sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());",
          "10032:         else if (tag == 0x0229)",
          "10034:           stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "10036:         else if (tag == 0x022d)",
          "10038:    fseek (ifp,2,SEEK_CUR);",
          "10039:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();",
          "10040:    getc(ifp);",
          "10041:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();",
          "10042:    getc(ifp);",
          "10043:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();",
          "10044:    getc(ifp);",
          "10045:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();",
          "10046:    getc(ifp);",
          "10047:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();",
          "10048:    getc(ifp);",
          "10049:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();",
          "10050:    getc(ifp);",
          "10051:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();",
          "10052:    getc(ifp);",
          "10053:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();",
          "10054:    getc(ifp);",
          "10055:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ (c >> 1)] = get2();",
          "10057:         else if (tag == 0x0239)  // Q-series lens info (LensInfoQ)",
          "10059:             char LensInfo [20];",
          "10060:             fseek (ifp, 2, SEEK_CUR);",
          "10061:             stread(imgdata.lens.makernotes.Lens, 30, ifp);",
          "10062:             strcat(imgdata.lens.makernotes.Lens, \" \");",
          "10063:             stread(LensInfo, 20, ifp);",
          "10064:             strcat(imgdata.lens.makernotes.Lens, LensInfo);",
          "10070:         if (tag == 0x0002)",
          "10071:           {",
          "10072:             if(get4() == 0x2000)",
          "10073:               {",
          "10074:                 imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;",
          "10075:               }",
          "10076:             else if (!strncmp(model, \"NX mini\", 7))",
          "10077:               {",
          "10078:                 imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;",
          "10079:               }",
          "10080:             else",
          "10081:               {",
          "10082:                 imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "10083:                 imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "10084:               }",
          "10085:           }",
          "10086:         else if (tag == 0x0003)",
          "10087:           {",
          "10088:             unique_id = imgdata.lens.makernotes.CamID = get4();",
          "10089:           }",
          "10090:          else if (tag == 0xa002)",
          "10091:           {",
          "10092:              stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "10093:           }",
          "10094:         else if (tag == 0xa003)",
          "10095:           {",
          "10096:             imgdata.lens.makernotes.LensID = get2();",
          "10097:             if (imgdata.lens.makernotes.LensID)",
          "10098:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;",
          "10099:           }",
          "10100:         else if (tag == 0xa005)",
          "10101:           {",
          "10102:             stmread(imgdata.lens.InternalLensSerial, len, ifp);",
          "10103:           }",
          "10104:         else if (tag == 0xa019)",
          "10105:           {",
          "10106:             imgdata.lens.makernotes.CurAp = getreal(type);",
          "10107:           }",
          "10108:         else if (tag == 0xa01a)",
          "10109:           {",
          "10110:             imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;",
          "10111:             if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)",
          "10112:               imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;",
          "10113:           }",
          "10116:     else if (!strncasecmp(make, \"SONY\", 4) ||",
          "10117:              !strncasecmp(make, \"Konica\", 6) ||",
          "10118:              !strncasecmp(make, \"Minolta\", 7) ||",
          "10120:               (!strncasecmp(model, \"Stellar\", 7) ||",
          "10121:                !strncasecmp(model, \"Lunar\", 5) ||",
          "10122:                !strncasecmp(model, \"Lusso\", 5) ||",
          "10123:                !strncasecmp(model, \"HV\",2))))",
          "10125:         ushort lid;",
          "10126:         if (tag == 0xb001)   // Sony ModelID",
          "10128:           unique_id = get2();",
          "10129:           setSonyBodyFeatures(unique_id);",
          "10130:           if (table_buf_0x9050_present)",
          "10131:             {",
          "10132:               process_Sony_0x9050(table_buf_0x9050, unique_id);",
          "10133:               free (table_buf_0x9050);",
          "10134:               table_buf_0x9050_present = 0;",
          "10135:             }",
          "10136:           if (table_buf_0x940c_present)",
          "10137:             {",
          "10138:               if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)",
          "10139:                 {",
          "10140:                   process_Sony_0x940c(table_buf_0x940c);",
          "10141:                 }",
          "10142:               free (table_buf_0x940c);",
          "10143:               table_buf_0x940c_present = 0;",
          "10144:             }",
          "10147:         else if ((tag == 0x0010) &&     // CameraInfo",
          "10148:                  strncasecmp(model, \"DSLR-A100\", 9) &&",
          "10149:                  strncasecmp(model, \"NEX-5C\", 6) &&",
          "10150:                  !strncasecmp(make, \"SONY\", 4) &&",
          "10151:                  ((len == 368) ||  // a700",
          "10152:                   (len == 5478) ||  // a850, a900",
          "10153:                   (len == 5506) ||  // a200, a300, a350",
          "10154:                   (len == 6118) ||  // a230, a290, a330, a380, a390",
          "10158:                   (len == 15360))",
          "10159:                  )",
          "10161:             table_buf = (uchar*)malloc(len);",
          "10162:             fread(table_buf, len, 1, ifp);",
          "10163:             if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&",
          "10164:                 memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))",
          "10165:               {",
          "10166:                 switch (len)",
          "10167:                   {",
          "10168:                   case 368:",
          "10169:                   case 5478:",
          "10171:                     if (table_buf[0] | table_buf[3])",
          "10172:                       imgdata.lens.makernotes.MinFocal =",
          "10173:                         bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);",
          "10174:                     if (table_buf[2] | table_buf[5])",
          "10175:                       imgdata.lens.makernotes.MaxFocal =",
          "10176:                         bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);",
          "10177:                     if (table_buf[4])",
          "10178:                       imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;",
          "10179:                     if (table_buf[4])",
          "10180:                       imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;",
          "10181:                     parseSonyLensFeatures(table_buf[1], table_buf[6]);",
          "10182:                     break;",
          "10183:                   default:",
          "10185:                     if (table_buf[1] | table_buf[2])",
          "10186:                       imgdata.lens.makernotes.MinFocal =",
          "10187:                         bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);",
          "10188:                     if (table_buf[3] | table_buf[4])",
          "10189:                       imgdata.lens.makernotes.MaxFocal =",
          "10190:                         bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);",
          "10191:                     if (table_buf[5])",
          "10192:                       imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;",
          "10193:                     if (table_buf[6])",
          "10194:                       imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;",
          "10195:                     parseSonyLensFeatures(table_buf[0], table_buf[7]);",
          "10196:                 }",
          "10197:               }",
          "10198:             free(table_buf);",
          "10201:         else if ((tag == 0x0020) &&    // WBInfoA100, needs 0xb028 processing",
          "10202:                  !strncasecmp(model, \"DSLR-A100\", 9))",
          "10203:    {",
          "10204:      fseek(ifp,0x49dc,SEEK_CUR);",
          "10205:      stmread(imgdata.shootinginfo.InternalBodySerial, 12, ifp);",
          "10206:    }",
          "10208:  else if (tag == 0x0104)",
          "10209:    {",
          "10210:      imgdata.other.FlashEC = getreal(type);",
          "10211:    }",
          "10213:         else if (tag == 0x0105)     // Teleconverter",
          "10215:             imgdata.lens.makernotes.TeleconverterID = get2();",
          "10218:         else if (tag == 0x0114 && len < 256000)  // CameraSettings",
          "10220:             table_buf = (uchar*)malloc(len);",
          "10221:             fread(table_buf, len, 1, ifp);",
          "10222:             switch (len) {",
          "10223:             case 280:",
          "10224:             case 364:",
          "10225:             case 332:",
          "10227:               if (table_buf[2] | table_buf[3])",
          "10228:                 {",
          "10229:                   lid = (((ushort)table_buf[2])<<8) |",
          "10230:                     ((ushort)table_buf[3]);",
          "10231:                   imgdata.lens.makernotes.CurAp =",
          "10232:                     powf64(2.0f, ((float)lid/8.0f-1.0f)/2.0f);",
          "10233:                 }",
          "10235:             case 1536:",
          "10236:             case 2048:",
          "10238:               parseSonyLensType2(table_buf[1016], table_buf[1015]);",
          "10239:               if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)",
          "10240:                 {",
          "10241:                   switch (table_buf[153]) {",
          "10242:                   case 16: imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A; break;",
          "10243:                   case 17: imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E; break;",
          "10244:                   }",
          "10245:                 }",
          "10248:             free(table_buf);",
          "10251:         else if (tag == 0x9050 && len < 256000)  // little endian",
          "10252:           {",
          "10253:             table_buf_0x9050 = (uchar*)malloc(len);",
          "10254:             table_buf_0x9050_present = 1;",
          "10255:             fread(table_buf_0x9050, len, 1, ifp);",
          "10257:             if (imgdata.lens.makernotes.CamID)",
          "10258:               {",
          "10259:                 process_Sony_0x9050(table_buf_0x9050, imgdata.lens.makernotes.CamID);",
          "10260:                 free (table_buf_0x9050);",
          "10261:                 table_buf_0x9050_present = 0;",
          "10262:               }",
          "10263:           }",
          "10265:         else if (tag == 0x940c && len <256000)",
          "10266:           {",
          "10267:             table_buf_0x940c = (uchar*)malloc(len);",
          "10268:             table_buf_0x940c_present = 1;",
          "10269:             fread(table_buf_0x940c, len, 1, ifp);",
          "10270:             if ((imgdata.lens.makernotes.CamID) &&",
          "10271:                 (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E))",
          "10272:               {",
          "10273:                 process_Sony_0x940c(table_buf_0x940c);",
          "10274:                 free(table_buf_0x940c);",
          "10275:                 table_buf_0x940c_present = 0;",
          "10276:               }",
          "10277:           }",
          "10279:         else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))",
          "10280:           {",
          "10281:             imgdata.lens.makernotes.LensID = get4();",
          "10282:             if ((imgdata.lens.makernotes.LensID > 0x4900) &&",
          "10283:                 (imgdata.lens.makernotes.LensID <= 0x5900))",
          "10284:             {",
          "10285:               imgdata.lens.makernotes.AdapterID = 0x4900;",
          "10286:               imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;",
          "10287:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;",
          "10288:               strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");",
          "10289:             }",
          "10291:             else if ((imgdata.lens.makernotes.LensID > 0xEF00) &&",
          "10292:                 (imgdata.lens.makernotes.LensID < 0xFFFF)      &&",
          "10293:                 (imgdata.lens.makernotes.LensID != 0xFF00))",
          "10294:             {",
          "10295:               imgdata.lens.makernotes.AdapterID = 0xEF00;",
          "10296:               imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;",
          "10297:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "10298:             }",
          "10299:             if (tag == 0x010c) imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;",
          "10300:           }",
          "10302:         else if (tag == 0xb02a && len < 256000) // Sony LensSpec",
          "10304:             table_buf = (uchar*)malloc(len);",
          "10305:             fread(table_buf, len, 1, ifp);",
          "10306:             if (table_buf[1] | table_buf[2])",
          "10307:               imgdata.lens.makernotes.MinFocal =",
          "10308:                 bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);",
          "10309:             if (table_buf[3] | table_buf[4])",
          "10310:               imgdata.lens.makernotes.MaxFocal =",
          "10311:                 bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);",
          "10312:             if (table_buf[5])",
          "10313:               imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;",
          "10314:             if (table_buf[6])",
          "10315:               imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;",
          "10316:             parseSonyLensFeatures(table_buf[0], table_buf[7]);",
          "10317:             free(table_buf);",
          "10321:     fseek(ifp,_pos,SEEK_SET);",
          "10322: #endif",
          "10324:     if (tag == 2 && strstr(make,\"NIKON\") && !iso_speed)",
          "10325:       iso_speed = (get2(),get2());",
          "10326:     if (tag == 37 && strstr(make,\"NIKON\") && (!iso_speed || iso_speed == 65535))",
          "10328:         unsigned char cc;",
          "10329:         fread(&cc,1,1,ifp);",
          "10330:         iso_speed = int(100.0 * powf64(2.0f,float(cc)/12.0-5.0));",
          "10332:     if (tag == 4 && len > 26 && len < 35) {",
          "10333:       if ((i=(get4(),get2())) != 0x7fff && (!iso_speed || iso_speed == 65535))",
          "10334:  iso_speed = 50 * powf64(2.0, i/32.0 - 4);",
          "10335: #ifdef LIBRAW_LIBRARY_BUILD",
          "10336:       get4();",
          "10337: #else",
          "10338:       if ((i=(get2(),get2())) != 0x7fff && !aperture)",
          "10339:  aperture = powf64(2.0, i/64.0);",
          "10340: #endif",
          "10341:       if ((i=get2()) != 0xffff && !shutter)",
          "10342:  shutter = powf64(2.0, (short) i/-32.0);",
          "10343:       wbi = (get2(),get2());",
          "10344:       shot_order = (get2(),get2());",
          "10345:     }",
          "10346:     if ((tag == 4 || tag == 0x114) && !strncmp(make,\"KONICA\",6)) {",
          "10347:       fseek (ifp, tag == 4 ? 140:160, SEEK_CUR);",
          "10348:       switch (get2()) {",
          "10349:  case 72:  flip = 0;  break;",
          "10350:  case 76:  flip = 6;  break;",
          "10351:  case 82:  flip = 5;  break;",
          "10354:     if (tag == 7 && type == 2 && len > 20)",
          "10355:       fgets (model2, 64, ifp);",
          "10356:     if (tag == 8 && type == 4)",
          "10357:       shot_order = get4();",
          "10358:     if (tag == 9 && !strncmp(make,\"Canon\",5))",
          "10359:       fread (artist, 64, 1, ifp);",
          "10360:     if (tag == 0xc && len == 4)",
          "10361:       FORC3 cam_mul[(c << 1 | c >> 1) & 3] = getreal(type);",
          "10362:     if (tag == 0xd && type == 7 && get2() == 0xaaaa) {",
          "10363:       for (c=i=2; (ushort) c != 0xbbbb && i < len; i++)",
          "10364:  c = c << 8 | fgetc(ifp);",
          "10365:       while ((i+=4) < len-5)",
          "10366:  if (get4() == 257 && (i=len) && (c = (get4(),fgetc(ifp))) < 3)",
          "10367:    flip = \"065\"[c]-'0';",
          "10368:     }",
          "10370: #ifndef LIBRAW_LIBRARY_BUILD",
          "10371:     if (tag == 0x10 && type == 4) unique_id = get4();",
          "10374: #ifdef LIBRAW_LIBRARY_BUILD",
          "10375:     INT64 _pos2 = ftell(ifp);",
          "10376:  if (!strncasecmp(make,\"Olympus\",7))",
          "10377:  {",
          "10378:    short nWB, tWB;",
          "10379:    if ((tag == 0x20300108) || (tag == 0x20310109))",
          "10380:        imgdata.makernotes.olympus.ColorSpace = get2();",
          "10382:    if ((tag == 0x20400102) && (len == 2) &&",
          "10383:        (!strncasecmp(model, \"E-410\", 5) || !strncasecmp(model, \"E-510\", 5)))",
          "10384:      {",
          "10385:        int i;",
          "10386:        for (i=0; i<64; i++)",
          "10387:   imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] =",
          "10388:     imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;",
          "10389:        for (i=64; i<256; i++)",
          "10390:   imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;",
          "10391:      }",
          "10392:    if ((tag >= 0x20400102) && (tag <= 0x2040010d))",
          "10393:      {",
          "10394:        ushort CT;",
          "10395:        nWB = tag-0x20400102;",
          "10396:        switch (nWB)",
          "10397:   {",
          "10398:                 case 0 : CT = 3000; tWB = LIBRAW_WBI_Tungsten; break;",
          "10399:   case 1 : CT = 3300; tWB = 0x100; break;",
          "10400:   case 2 : CT = 3600; tWB = 0x100; break;",
          "10401:   case 3 : CT = 3900; tWB = 0x100; break;",
          "10402:                 case 4 : CT = 4000; tWB = LIBRAW_WBI_FL_W; break;",
          "10403:   case 5 : CT = 4300; tWB = 0x100; break;",
          "10404:                 case 6 : CT = 4500; tWB = LIBRAW_WBI_FL_D; break;",
          "10405:   case 7 : CT = 4800; tWB = 0x100; break;",
          "10406:                 case 8 : CT = 5300; tWB = LIBRAW_WBI_FineWeather; break;",
          "10407:                 case 9 : CT = 6000; tWB = LIBRAW_WBI_Cloudy; break;",
          "10408:                 case 10: CT = 6600; tWB = LIBRAW_WBI_FL_N; break;",
          "10409:                 case 11: CT = 7500; tWB = LIBRAW_WBI_Shade; break;",
          "10410:   default: CT = 0; tWB = 0x100;",
          "10411:   }",
          "10412:        if (CT)",
          "10413:   {",
          "10414:     imgdata.color.WBCT_Coeffs[nWB][0] = CT;",
          "10415:     imgdata.color.WBCT_Coeffs[nWB][1] = get2();",
          "10416:     imgdata.color.WBCT_Coeffs[nWB][3] = get2();",
          "10417:     if (len == 4)",
          "10418:       {",
          "10419:         imgdata.color.WBCT_Coeffs[nWB][2] = get2();",
          "10420:         imgdata.color.WBCT_Coeffs[nWB][4] = get2();",
          "10421:       }",
          "10422:   }",
          "10423:        if (tWB != 0x100)",
          "10424:   FORC4 imgdata.color.WB_Coeffs[tWB][c] = imgdata.color.WBCT_Coeffs[nWB][c+1];",
          "10425:      }",
          "10426:    if ((tag >= 0x20400113) && (tag <= 0x2040011e))",
          "10427:      {",
          "10428:        nWB = tag-0x20400113;",
          "10429:        imgdata.color.WBCT_Coeffs[nWB][2] = imgdata.color.WBCT_Coeffs[nWB][4] = get2();",
          "10430:        switch (nWB)",
          "10431:   {",
          "10432:                 case 0:  tWB = LIBRAW_WBI_Tungsten; break;",
          "10433:                 case 4:  tWB = LIBRAW_WBI_FL_W; break;",
          "10434:                 case 6:  tWB = LIBRAW_WBI_FL_D; break;",
          "10435:                 case 8:  tWB = LIBRAW_WBI_FineWeather; break;",
          "10436:                 case 9:  tWB = LIBRAW_WBI_Cloudy; break;",
          "10437:                 case 10: tWB = LIBRAW_WBI_FL_N; break;",
          "10438:                 case 11: tWB = LIBRAW_WBI_Shade; break;",
          "10439:   default: tWB = 0x100;",
          "10440:   }",
          "10441:        if (tWB != 0x100)",
          "10442:   imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] =",
          "10443:     imgdata.color.WBCT_Coeffs[nWB][2];",
          "10444:      }",
          "10446:    if (tag == 0x20400121)",
          "10447:      {",
          "10448:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();",
          "10449:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();",
          "10450:        if (len == 4)",
          "10451:   {",
          "10452:                   imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = get2();",
          "10453:                   imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();",
          "10454:   }",
          "10455:      }",
          "10456:    if (tag == 0x2040011f)",
          "10457:      {",
          "10458:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();",
          "10459:      }",
          "10460:    if (tag == 0x30000120)",
          "10461:      {",
          "10462:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();",
          "10463:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();",
          "10464:        if (len == 2)",
          "10465:   {",
          "10466:     for (int i=0; i<256; i++)",
          "10467:       imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;",
          "10468:   }",
          "10469:      }",
          "10470:    if (tag == 0x30000121)",
          "10471:      {",
          "10472:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();",
          "10473:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();",
          "10474:      }",
          "10475:    if (tag == 0x30000122)",
          "10476:      {",
          "10477:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = get2();",
          "10478:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = get2();",
          "10479:      }",
          "10480:    if (tag == 0x30000123)",
          "10481:      {",
          "10482:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();",
          "10483:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();",
          "10484:      }",
          "10485:    if (tag == 0x30000124)",
          "10486:      {",
          "10487:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Sunset][0] = get2();",
          "10488:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Sunset][2] = get2();",
          "10489:      }",
          "10490:    if (tag == 0x30000130)",
          "10491:      {",
          "10492:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();",
          "10493:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();",
          "10494:      }",
          "10495:    if (tag == 0x30000131)",
          "10496:      {",
          "10497:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();",
          "10498:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();",
          "10499:      }",
          "10500:    if (tag == 0x30000132)",
          "10501:      {",
          "10502:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();",
          "10503:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();",
          "10504:      }",
          "10505:    if (tag == 0x30000133)",
          "10506:      {",
          "10507:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();",
          "10508:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();",
          "10509:      }",
          "10511:    if((tag == 0x20400805) && (len == 2))",
          "10512:      {",
          "10513:        imgdata.makernotes.olympus.OlympusSensorCalibration[0]=getreal(type);",
          "10514:        imgdata.makernotes.olympus.OlympusSensorCalibration[1]=getreal(type);",
          "10515:        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.olympus.OlympusSensorCalibration[0];",
          "10516:      }",
          "10517:    if (tag == 0x20200401)",
          "10518:      {",
          "10519:        imgdata.other.FlashEC = getreal(type);",
          "10520:      }",
          "10521:  }",
          "10522:     fseek(ifp,_pos2,SEEK_SET);",
          "10524: #endif",
          "10525:     if (tag == 0x11 && is_raw && !strncmp(make,\"NIKON\",5)) {",
          "10526:       fseek (ifp, get4()+base, SEEK_SET);",
          "10527:       parse_tiff_ifd (base);",
          "10528:     }",
          "10529:     if (tag == 0x14 && type == 7) {",
          "10530:       if (len == 2560) {",
          "10531:  fseek (ifp, 1248, SEEK_CUR);",
          "10532:  goto get2_256;",
          "10533:       }",
          "10534:       fread (buf, 1, 10, ifp);",
          "10535:       if (!strncmp(buf,\"NRW \",4)) {",
          "10536:  fseek (ifp, strcmp(buf+4,\"0100\") ? 46:1546, SEEK_CUR);",
          "10537:  cam_mul[0] = get4() << 2;",
          "10538:  cam_mul[1] = get4() + get4();",
          "10539:  cam_mul[2] = get4() << 2;",
          "10543:       fread (model, 64, 1, ifp);",
          "10544:     if (strstr(make,\"PENTAX\")) {",
          "10545:       if (tag == 0x1b) tag = 0x1018;",
          "10546:       if (tag == 0x1c) tag = 0x1017;",
          "10548:     if (tag == 0x1d) {",
          "10554:           if ((strbuflen(model) == 3) && (!strcmp(model,\"D50\")))",
          "",
          "[Added Lines]",
          "10262:      The MakerNote might have its own TIFF header (possibly with",
          "10263:      its own byte-order!), or it might just be a table.",
          "10265:   if (!strncmp(make, \"Nokia\", 5))",
          "10266:     return;",
          "10267:   fread(buf, 1, 10, ifp);",
          "10269:       !strncmp(buf, \"VER\", 3) || !strncmp(buf, \"IIII\", 4) || !strncmp(buf, \"MMMM\", 4))",
          "10270:     return;",
          "10272:       !strncmp(buf, \"MLY\", 3))",
          "10275:     while ((i = ftell(ifp)) < data_offset && i < 16384)",
          "10276:     {",
          "10277:       wb[0] = wb[2];",
          "10278:       wb[2] = wb[1];",
          "10279:       wb[1] = wb[3];",
          "10281:       if (wb[1] == 256 && wb[3] == 256 && wb[0] > 256 && wb[0] < 640 && wb[2] > 256 && wb[2] < 640)",
          "10282:         FORC4 cam_mul[c] = wb[c];",
          "10286:   if (!strcmp(buf, \"Nikon\"))",
          "10287:   {",
          "10290:     if (get2() != 42)",
          "10291:       goto quit;",
          "10293:     fseek(ifp, offset - 8, SEEK_CUR);",
          "10294:   }",
          "10295:   else if (!strcmp(buf, \"OLYMPUS\") || !strcmp(buf, \"PENTAX \"))",
          "10296:   {",
          "10297:     base = ftell(ifp) - 10;",
          "10298:     fseek(ifp, -2, SEEK_CUR);",
          "10300:     if (buf[0] == 'O')",
          "10301:       get2();",
          "10302:   }",
          "10303:   else if (!strncmp(buf, \"SONY\", 4) || !strcmp(buf, \"Panasonic\"))",
          "10304:   {",
          "10306:   }",
          "10307:   else if (!strncmp(buf, \"FUJIFILM\", 8))",
          "10308:   {",
          "10309:     base = ftell(ifp) - 10;",
          "10310:   nf:",
          "10311:     order = 0x4949;",
          "10312:     fseek(ifp, 2, SEEK_CUR);",
          "10313:   }",
          "10314:   else if (!strcmp(buf, \"OLYMP\") || !strcmp(buf, \"LEICA\") || !strcmp(buf, \"Ricoh\") || !strcmp(buf, \"EPSON\"))",
          "10315:     fseek(ifp, -2, SEEK_CUR);",
          "10316:   else if (!strcmp(buf, \"AOC\") || !strcmp(buf, \"QVC\"))",
          "10317:     fseek(ifp, -4, SEEK_CUR);",
          "10318:   else",
          "10319:   {",
          "10320:     fseek(ifp, -10, SEEK_CUR);",
          "10321:     if (!strncmp(make, \"SAMSUNG\", 7))",
          "10327:   {",
          "10328:     if (!strncmp(model, \"M8\", 2) || !strncasecmp(model, \"Leica M8\", 8) || !strncasecmp(model, \"LEICA X\", 7))",
          "10330:       base = ftell(ifp) - 8;",
          "10331:     }",
          "10332:     else if (!strncasecmp(model, \"LEICA M (Typ 240)\", 17))",
          "10333:     {",
          "10334:       base = 0;",
          "10335:     }",
          "10336:     else if (!strncmp(model, \"M9\", 2) || !strncasecmp(model, \"Leica M9\", 8) || !strncasecmp(model, \"M Monochrom\", 11) ||",
          "10337:              !strncasecmp(model, \"Leica M Monochrom\", 11))",
          "10338:     {",
          "10339:       if (!uptag)",
          "10340:       {",
          "10341:         base = ftell(ifp) - 10;",
          "10342:         fseek(ifp, 8, SEEK_CUR);",
          "10343:       }",
          "10344:       else if (uptag == 0x3400)",
          "10345:       {",
          "10346:         fseek(ifp, 10, SEEK_CUR);",
          "10347:         base += 10;",
          "10348:       }",
          "10349:     }",
          "10350:     else if (!strncasecmp(model, \"LEICA T\", 7))",
          "10351:     {",
          "10352:       base = ftell(ifp) - 8;",
          "10354:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_T;",
          "10356:     }",
          "10358:     else if (!strncasecmp(model, \"LEICA SL\", 8))",
          "10359:     {",
          "10360:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_SL;",
          "10361:       imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;",
          "10363: #endif",
          "10364:   }",
          "10367:   if (entries > 1000)",
          "10368:     return;",
          "10371:   while (entries--)",
          "10372:   {",
          "10374:     tiff_get(base, &tag, &type, &len, &save);",
          "10379:     if (len > 8 && _pos + len > 2 * fsize)",
          "10380:       continue;",
          "10381:     if (!strncmp(make, \"Canon\", 5))",
          "10382:     {",
          "10383:       if (tag == 0x000d && len < 256000) // camera info",
          "10385:         CanonCameraInfo = (uchar *)malloc(len);",
          "10386:         fread(CanonCameraInfo, len, 1, ifp);",
          "10387:         lenCanonCameraInfo = len;",
          "10388:       }",
          "10390:       else if (tag == 0x10) // Canon ModelID",
          "10391:       {",
          "10392:         unique_id = get4();",
          "10393:         if (unique_id == 0x03740000)",
          "10394:           unique_id = 0x80000374; // M3",
          "10395:         if (unique_id == 0x03840000)",
          "10396:           unique_id = 0x80000384; // M10",
          "10397:         if (unique_id == 0x03940000)",
          "10398:           unique_id = 0x80000394; // M5",
          "10399:         setCanonBodyFeatures(unique_id);",
          "10400:         if (lenCanonCameraInfo)",
          "10401:         {",
          "10402:           processCanonCameraInfo(unique_id, CanonCameraInfo, lenCanonCameraInfo);",
          "10403:           free(CanonCameraInfo);",
          "10404:           CanonCameraInfo = 0;",
          "10405:           lenCanonCameraInfo = 0;",
          "10406:         }",
          "10410:         parseCanonMakernotes(tag, type, len);",
          "10413:     else if (!strncmp(make, \"FUJI\", 4))",
          "10414:     {",
          "10415:       if (tag == 0x0010)",
          "10417:         char FujiSerial[sizeof(imgdata.shootinginfo.InternalBodySerial)];",
          "10418:         char *words[4];",
          "10419:         char yy[2], mm[3], dd[3], ystr[16], ynum[16];",
          "10420:         int year, nwords, ynum_len;",
          "10421:         unsigned c;",
          "10422:         stmread(FujiSerial, len, ifp);",
          "10423:         nwords = getwords(FujiSerial, words, 4, sizeof(imgdata.shootinginfo.InternalBodySerial));",
          "10424:         for (int i = 0; i < nwords; i++)",
          "10426:           mm[2] = dd[2] = 0;",
          "10427:           if (strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) < 18)",
          "10428:             if (i == 0)",
          "10429:               strncpy(imgdata.shootinginfo.InternalBodySerial, words[0],",
          "10430:                       sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);",
          "10431:             else",
          "10432:             {",
          "10433:               char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];",
          "10434:               snprintf(tbuf, sizeof(tbuf), \"%s %s\", imgdata.shootinginfo.InternalBodySerial, words[i]);",
          "10435:               strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,",
          "10436:                       sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);",
          "10437:             }",
          "10438:           else",
          "10440:             strncpy(dd, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 14, 2);",
          "10441:             strncpy(mm, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 16, 2);",
          "10442:             strncpy(yy, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 18, 2);",
          "10443:             year = (yy[0] - '0') * 10 + (yy[1] - '0');",
          "10444:             if (year < 70)",
          "10445:               year += 2000;",
          "10446:             else",
          "10447:               year += 1900;",
          "10449:             ynum_len = (int)strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 18;",
          "10450:             strncpy(ynum, words[i], ynum_len);",
          "10451:             ynum[ynum_len] = 0;",
          "10452:             for (int j = 0; ynum[j] && ynum[j + 1] && sscanf(ynum + j, \"%2x\", &c); j += 2)",
          "10453:               ystr[j / 2] = c;",
          "10454:             ystr[ynum_len / 2 + 1] = 0;",
          "10455:             strcpy(model2, ystr);",
          "10457:             if (i == 0)",
          "10458:             {",
          "10459:               char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];",
          "10461:               if (nwords == 1)",
          "10462:                 snprintf(tbuf, sizeof(tbuf), \"%s %s %d:%s:%s\",",
          "10463:                          words[0] + strnlen(words[0], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 12, ystr,",
          "10464:                          year, mm, dd);",
          "10466:               else",
          "10467:                 snprintf(tbuf, sizeof(tbuf), \"%s %d:%s:%s %s\", ystr, year, mm, dd,",
          "10468:                          words[0] + strnlen(words[0], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 12);",
          "10470:               strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,",
          "10471:                       sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);",
          "10472:             }",
          "10473:             else",
          "10475:               char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];",
          "10476:               snprintf(tbuf, sizeof(tbuf), \"%s %s %d:%s:%s %s\", imgdata.shootinginfo.InternalBodySerial, ystr, year, mm,",
          "10477:                        dd, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 12);",
          "10478:               strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,",
          "10479:                       sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);",
          "10482:         }",
          "10484:       else",
          "10485:         parseFujiMakernotes(tag, type);",
          "10486:     }",
          "10488:     else if (!strncasecmp(make, \"LEICA\", 5))",
          "10489:     {",
          "10490:       if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))",
          "10492:         int ind = tag == 0x035e ? 0 : 1;",
          "10493:         for (int j = 0; j < 3; j++)",
          "10494:           FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c] = getreal(type);",
          "10497:       if ((tag == 0x0303) && (type != 4))",
          "10498:       {",
          "10499:         stmread(imgdata.lens.makernotes.Lens, len, ifp);",
          "10502:       if ((tag == 0x3405) || (tag == 0x0310) || (tag == 0x34003405))",
          "10504:         imgdata.lens.makernotes.LensID = get4();",
          "10505:         imgdata.lens.makernotes.LensID =",
          "10506:             ((imgdata.lens.makernotes.LensID >> 2) << 8) | (imgdata.lens.makernotes.LensID & 0x3);",
          "10507:         if (imgdata.lens.makernotes.LensID != -1)",
          "10508:         {",
          "10509:           if ((model[0] == 'M') || !strncasecmp(model, \"LEICA M\", 7))",
          "10511:             imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;",
          "10512:             if (imgdata.lens.makernotes.LensID)",
          "10513:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;",
          "10515:           else if ((model[0] == 'S') || !strncasecmp(model, \"LEICA S\", 7))",
          "10517:             imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;",
          "10518:             if (imgdata.lens.makernotes.Lens[0])",
          "10519:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;",
          "10521:         }",
          "10522:       }",
          "10524:       else if (((tag == 0x0313) || (tag == 0x34003406)) && (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&",
          "10525:                ((type == 10) || (type == 5)))",
          "10526:       {",
          "10527:         imgdata.lens.makernotes.CurAp = getreal(type);",
          "10528:         if (imgdata.lens.makernotes.CurAp > 126.3)",
          "10529:           imgdata.lens.makernotes.CurAp = 0.0f;",
          "10530:       }",
          "10532:       else if (tag == 0x3400)",
          "10533:       {",
          "10534:         parse_makernote(base, 0x3400);",
          "10536:     }",
          "10538:     else if (!strncmp(make, \"NIKON\", 5))",
          "10539:     {",
          "10540:       if (tag == 0x000a)",
          "10542:         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "10543:         imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "10544:       }",
          "10545:       else if (tag == 0x0012)",
          "10546:       {",
          "10547:         char a, b, c;",
          "10548:         a = fgetc(ifp);",
          "10549:         b = fgetc(ifp);",
          "10550:         c = fgetc(ifp);",
          "10551:         if (c)",
          "10552:           imgdata.other.FlashEC = (float)(a * b) / (float)c;",
          "10553:       }",
          "10554:       else if (tag == 0x0082) // lens attachment",
          "10555:       {",
          "10556:         stmread(imgdata.lens.makernotes.Attachment, len, ifp);",
          "10557:       }",
          "10558:       else if (tag == 0x0083) // lens type",
          "10559:       {",
          "10560:         imgdata.lens.nikon.NikonLensType = fgetc(ifp);",
          "10561:       }",
          "10562:       else if (tag == 0x0084) // lens",
          "10563:       {",
          "10564:         imgdata.lens.makernotes.MinFocal = getreal(type);",
          "10565:         imgdata.lens.makernotes.MaxFocal = getreal(type);",
          "10566:         imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);",
          "10567:         imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);",
          "10568:       }",
          "10569:       else if (tag == 0x008b) // lens f-stops",
          "10570:       {",
          "10571:         uchar a, b, c;",
          "10572:         a = fgetc(ifp);",
          "10573:         b = fgetc(ifp);",
          "10574:         c = fgetc(ifp);",
          "10575:         if (c)",
          "10577:           imgdata.lens.nikon.NikonLensFStops = a * b * (12 / c);",
          "10578:           imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops / 12.0f;",
          "10580:       }",
          "10581:       else if (tag == 0x0093)",
          "10582:       {",
          "10583:         i = get2();",
          "10584:         if ((i == 7) || (i == 9))",
          "10586:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "10587:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "10589:       }",
          "10590:       else if (tag == 0x0098) // contains lens data",
          "10591:       {",
          "10592:         for (i = 0; i < 4; i++)",
          "10594:           NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';",
          "10596:         switch (NikonLensDataVersion)",
          "10598:         case 100:",
          "10599:           lenNikonLensData = 9;",
          "10600:           break;",
          "10601:         case 101:",
          "10602:         case 201: // encrypted, starting from v.201",
          "10603:         case 202:",
          "10604:         case 203:",
          "10605:           lenNikonLensData = 15;",
          "10606:           break;",
          "10607:         case 204:",
          "10608:           lenNikonLensData = 16;",
          "10609:           break;",
          "10610:         case 400:",
          "10611:           lenNikonLensData = 459;",
          "10612:           break;",
          "10613:         case 401:",
          "10614:           lenNikonLensData = 590;",
          "10615:           break;",
          "10616:         case 402:",
          "10617:           lenNikonLensData = 509;",
          "10618:           break;",
          "10619:         case 403:",
          "10620:           lenNikonLensData = 879;",
          "10621:           break;",
          "10623:         if (lenNikonLensData > 0)",
          "10625:           table_buf = (uchar *)malloc(lenNikonLensData);",
          "10626:           fread(table_buf, lenNikonLensData, 1, ifp);",
          "10627:           if ((NikonLensDataVersion < 201) && lenNikonLensData)",
          "10628:           {",
          "10629:             processNikonLensData(table_buf, lenNikonLensData);",
          "10630:             free(table_buf);",
          "10631:             lenNikonLensData = 0;",
          "10632:           }",
          "10634:       }",
          "10635:       else if (tag == 0x00a0)",
          "10636:       {",
          "10637:         stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "10638:       }",
          "10639:       else if (tag == 0x00a8) // contains flash data",
          "10640:       {",
          "10641:         for (i = 0; i < 4; i++)",
          "10643:           NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';",
          "10645:       }",
          "10646:     }",
          "10648:     else if (!strncmp(make, \"OLYMPUS\", 7))",
          "10649:     {",
          "10650:       switch (tag)",
          "10651:       {",
          "10652:       case 0x0404:",
          "10653:       case 0x101a:",
          "10654:       case 0x20100101:",
          "10655:         if (!imgdata.shootinginfo.BodySerial[0])",
          "10656:           stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "10657:         break;",
          "10658:       case 0x20100102:",
          "10659:         if (!imgdata.shootinginfo.InternalBodySerial[0])",
          "10660:           stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);",
          "10661:         break;",
          "10662:       case 0x0207:",
          "10663:       case 0x20100100:",
          "10664:       {",
          "10665:         uchar sOlyID[8];",
          "10666:         unsigned long long OlyID;",
          "10667:         fread(sOlyID, MIN(len, 7), 1, ifp);",
          "10668:         sOlyID[7] = 0;",
          "10669:         OlyID = sOlyID[0];",
          "10670:         i = 1;",
          "10671:         while (i < 7 && sOlyID[i])",
          "10673:           OlyID = OlyID << 8 | sOlyID[i];",
          "10674:           i++;",
          "10676:         setOlympusBodyFeatures(OlyID);",
          "10677:       }",
          "10678:       break;",
          "10679:       case 0x1002:",
          "10680:         imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type) / 2);",
          "10681:         break;",
          "10682:       case 0x20401112:",
          "10683:         imgdata.makernotes.olympus.OlympusCropID = get2();",
          "10684:         break;",
          "10685:       case 0x20401113:",
          "10686:         FORC4 imgdata.makernotes.olympus.OlympusFrame[c] = get2();",
          "10687:         break;",
          "10688:       case 0x20100201:",
          "10689:       {",
          "10690:         unsigned long long oly_lensid[3];",
          "10691:         oly_lensid[0] = fgetc(ifp);",
          "10692:         fgetc(ifp);",
          "10693:         oly_lensid[1] = fgetc(ifp);",
          "10694:         oly_lensid[2] = fgetc(ifp);",
          "10695:         imgdata.lens.makernotes.LensID = (oly_lensid[0] << 16) | (oly_lensid[1] << 8) | oly_lensid[2];",
          "10696:       }",
          "10697:         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;",
          "10698:         imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;",
          "10699:         if (((imgdata.lens.makernotes.LensID < 0x20000) || (imgdata.lens.makernotes.LensID > 0x4ffff)) &&",
          "10700:             (imgdata.lens.makernotes.LensID & 0x10))",
          "10702:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;",
          "10704:         break;",
          "10705:       case 0x20100202:",
          "10706:         stmread(imgdata.lens.LensSerial, len, ifp);",
          "10707:         break;",
          "10708:       case 0x20100203:",
          "10709:         stmread(imgdata.lens.makernotes.Lens, len, ifp);",
          "10710:         break;",
          "10711:       case 0x20100205:",
          "10712:         imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "10713:         break;",
          "10714:       case 0x20100206:",
          "10715:         imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "10716:         break;",
          "10717:       case 0x20100207:",
          "10718:         imgdata.lens.makernotes.MinFocal = (float)get2();",
          "10719:         break;",
          "10720:       case 0x20100208:",
          "10721:         imgdata.lens.makernotes.MaxFocal = (float)get2();",
          "10722:         if (imgdata.lens.makernotes.MaxFocal > 1000.0f)",
          "10723:           imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;",
          "10724:         break;",
          "10725:       case 0x2010020a:",
          "10726:         imgdata.lens.makernotes.MaxAp4CurFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "10727:         break;",
          "10728:       case 0x20100301:",
          "10729:         imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;",
          "10730:         fgetc(ifp);",
          "10731:         imgdata.lens.makernotes.TeleconverterID = imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);",
          "10732:         break;",
          "10733:       case 0x20100303:",
          "10734:         stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);",
          "10735:         break;",
          "10736:       case 0x20100403:",
          "10737:         stmread(imgdata.lens.makernotes.Attachment, len, ifp);",
          "10738:         break;",
          "10739:       }",
          "10740:     }",
          "10742:     else if ((!strncmp(make, \"PENTAX\", 6) || !strncmp(make, \"RICOH\", 5)) && !strncmp(model, \"GR\", 2))",
          "10743:     {",
          "10744:       if (tag == 0x0005)",
          "10745:       {",
          "10746:         char buffer[17];",
          "10747:         int count = 0;",
          "10748:         fread(buffer, 16, 1, ifp);",
          "10749:         buffer[16] = 0;",
          "10750:         for (int i = 0; i < 16; i++)",
          "10753:           if ((isspace(buffer[i])) || (buffer[i] == 0x2D) || (isalnum(buffer[i])))",
          "10754:             count++;",
          "10756:         if (count == 16)",
          "10758:           sprintf(imgdata.shootinginfo.BodySerial, \"%8s\", buffer + 8);",
          "10759:           buffer[8] = 0;",
          "10760:           sprintf(imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);",
          "10762:         else",
          "10764:           sprintf(imgdata.shootinginfo.BodySerial, \"%02x%02x%02x%02x\", buffer[4], buffer[5], buffer[6], buffer[7]);",
          "10765:           sprintf(imgdata.shootinginfo.InternalBodySerial, \"%02x%02x%02x%02x\", buffer[8], buffer[9], buffer[10],",
          "10766:                   buffer[11]);",
          "10767:         }",
          "10768:       }",
          "10769:       else if ((tag == 0x1001) && (type == 3))",
          "10770:       {",
          "10771:         imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "10772:         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "10773:         imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;",
          "10774:         imgdata.lens.makernotes.LensID = -1;",
          "10775:         imgdata.lens.makernotes.FocalType = 1;",
          "10776:       }",
          "10778:       else if ((tag == 0x100b) && (type == 10))",
          "10779:       {",
          "10780:         imgdata.other.FlashEC = getreal(type);",
          "10781:       }",
          "10783:       else if ((tag == 0x1017) && (get2() == 2))",
          "10784:       {",
          "10785:         strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");",
          "10786:       }",
          "10787:       else if (tag == 0x1500)",
          "10788:       {",
          "10789:         imgdata.lens.makernotes.CurFocal = getreal(type);",
          "10790:       }",
          "10791:     }",
          "10793:     else if (!strncmp(make, \"RICOH\", 5) && strncmp(model, \"PENTAX\", 6))",
          "10794:     {",
          "10795:       if ((tag == 0x0005) && !strncmp(model, \"GXR\", 3))",
          "10796:       {",
          "10797:         char buffer[9];",
          "10798:         buffer[8] = 0;",
          "10799:         fread(buffer, 8, 1, ifp);",
          "10800:         sprintf(imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);",
          "10801:       }",
          "10803:       else if ((tag == 0x100b) && (type == 10))",
          "10804:       {",
          "10805:         imgdata.other.FlashEC = getreal(type);",
          "10806:       }",
          "10808:       else if ((tag == 0x1017) && (get2() == 2))",
          "10809:       {",
          "10810:         strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");",
          "10811:       }",
          "10813:       else if (tag == 0x1500)",
          "10814:       {",
          "10815:         imgdata.lens.makernotes.CurFocal = getreal(type);",
          "10816:       }",
          "10818:       else if ((tag == 0x2001) && !strncmp(model, \"GXR\", 3))",
          "10819:       {",
          "10820:         short ntags, cur_tag;",
          "10821:         fseek(ifp, 20, SEEK_CUR);",
          "10822:         ntags = get2();",
          "10823:         cur_tag = get2();",
          "10824:         while (cur_tag != 0x002c)",
          "10825:         {",
          "10826:           fseek(ifp, 10, SEEK_CUR);",
          "10827:           cur_tag = get2();",
          "10829:         fseek(ifp, 6, SEEK_CUR);",
          "10830:         fseek(ifp, get4() + 20, SEEK_SET);",
          "10831:         stread(imgdata.shootinginfo.BodySerial, 12, ifp);",
          "10832:         get2();",
          "10833:         imgdata.lens.makernotes.LensID = getc(ifp) - '0';",
          "10834:         switch (imgdata.lens.makernotes.LensID)",
          "10836:         case 1:",
          "10837:         case 2:",
          "10838:         case 3:",
          "10839:         case 5:",
          "10840:         case 6:",
          "10841:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "10842:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_RicohModule;",
          "10843:           break;",
          "10844:         case 8:",
          "10845:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;",
          "10846:           imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;",
          "10847:           imgdata.lens.makernotes.LensID = -1;",
          "10848:           break;",
          "10849:         default:",
          "10850:           imgdata.lens.makernotes.LensID = -1;",
          "10852:         fseek(ifp, 17, SEEK_CUR);",
          "10853:         stread(imgdata.lens.LensSerial, 12, ifp);",
          "10854:       }",
          "10855:     }",
          "10857:     else if ((!strncmp(make, \"PENTAX\", 6) || !strncmp(model, \"PENTAX\", 6) ||",
          "10858:               (!strncmp(make, \"SAMSUNG\", 7) && dng_version)) &&",
          "10859:              strncmp(model, \"GR\", 2))",
          "10860:     {",
          "10861:       if (tag == 0x0005)",
          "10862:       {",
          "10863:         unique_id = get4();",
          "10864:         setPentaxBodyFeatures(unique_id);",
          "10865:       }",
          "10866:       else if (tag == 0x0013)",
          "10867:       {",
          "10868:         imgdata.lens.makernotes.CurAp = (float)get2() / 10.0f;",
          "10869:       }",
          "10870:       else if (tag == 0x0014)",
          "10871:       {",
          "10872:         PentaxISO(get2());",
          "10873:       }",
          "10874:       else if (tag == 0x001d)",
          "10875:       {",
          "10876:         imgdata.lens.makernotes.CurFocal = (float)get4() / 100.0f;",
          "10877:       }",
          "10878:       else if (tag == 0x003f)",
          "10879:       {",
          "10880:         imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);",
          "10881:       }",
          "10882:       else if (tag == 0x004d)",
          "10883:       {",
          "10884:         if (type == 9)",
          "10885:           imgdata.other.FlashEC = getreal(type) / 256.0f;",
          "10886:         else",
          "10887:           imgdata.other.FlashEC = (float)((signed short)fgetc(ifp)) / 6.0f;",
          "10888:       }",
          "10889:       else if (tag == 0x007e)",
          "10890:       {",
          "10891:         imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =",
          "10892:             imgdata.color.linear_max[3] = (long)(-1) * get4();",
          "10893:       }",
          "10894:       else if (tag == 0x0207)",
          "10895:       {",
          "10896:         if (len < 65535) // Safety belt",
          "10897:           PentaxLensInfo(imgdata.lens.makernotes.CamID, len);",
          "10898:       }",
          "10899:       else if (tag == 0x020d)",
          "10900:       {",
          "10901:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();",
          "10902:       }",
          "10903:       else if (tag == 0x020e)",
          "10904:       {",
          "10905:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();",
          "10906:       }",
          "10907:       else if (tag == 0x020f)",
          "10908:       {",
          "10909:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();",
          "10910:       }",
          "10911:       else if (tag == 0x0210)",
          "10912:       {",
          "10913:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();",
          "10914:       }",
          "10915:       else if (tag == 0x0211)",
          "10916:       {",
          "10917:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();",
          "10918:       }",
          "10919:       else if (tag == 0x0212)",
          "10920:       {",
          "10921:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();",
          "10922:       }",
          "10923:       else if (tag == 0x0213)",
          "10924:       {",
          "10925:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();",
          "10926:       }",
          "10927:       else if (tag == 0x0214)",
          "10928:       {",
          "10929:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();",
          "10930:       }",
          "10931:       else if (tag == 0x0221)",
          "10932:       {",
          "10933:         int nWB = get2();",
          "10934:         if (nWB <= sizeof(imgdata.color.WBCT_Coeffs) / sizeof(imgdata.color.WBCT_Coeffs[0]))",
          "10935:           for (int i = 0; i < nWB; i++)",
          "10937:             imgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();",
          "10938:             fseek(ifp, 2, SEEK_CUR);",
          "10939:             imgdata.color.WBCT_Coeffs[i][1] = get2();",
          "10940:             imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;",
          "10941:             imgdata.color.WBCT_Coeffs[i][3] = get2();",
          "10944:       else if (tag == 0x0215)",
          "10945:       {",
          "10946:         fseek(ifp, 16, SEEK_CUR);",
          "10947:         sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());",
          "10948:       }",
          "10949:       else if (tag == 0x0229)",
          "10950:       {",
          "10951:         stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "10952:       }",
          "10953:       else if (tag == 0x022d)",
          "10954:       {",
          "10955:         fseek(ifp, 2, SEEK_CUR);",
          "10956:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();",
          "10957:         getc(ifp);",
          "10958:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();",
          "10959:         getc(ifp);",
          "10960:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();",
          "10961:         getc(ifp);",
          "10962:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();",
          "10963:         getc(ifp);",
          "10964:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();",
          "10965:         getc(ifp);",
          "10966:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();",
          "10967:         getc(ifp);",
          "10968:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();",
          "10969:         getc(ifp);",
          "10970:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();",
          "10971:         getc(ifp);",
          "10972:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ (c >> 1)] = get2();",
          "10973:       }",
          "10974:       else if (tag == 0x0239) // Q-series lens info (LensInfoQ)",
          "10975:       {",
          "10976:         char LensInfo[20];",
          "10977:         fseek(ifp, 2, SEEK_CUR);",
          "10978:         stread(imgdata.lens.makernotes.Lens, 30, ifp);",
          "10979:         strcat(imgdata.lens.makernotes.Lens, \" \");",
          "10980:         stread(LensInfo, 20, ifp);",
          "10981:         strcat(imgdata.lens.makernotes.Lens, LensInfo);",
          "10982:       }",
          "10983:     }",
          "10986:     {",
          "10987:       if (tag == 0x0002)",
          "10989:         if (get4() == 0x2000)",
          "10990:         {",
          "10991:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;",
          "10992:         }",
          "10993:         else if (!strncmp(model, \"NX mini\", 7))",
          "10994:         {",
          "10995:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;",
          "10996:         }",
          "10997:         else",
          "10998:         {",
          "10999:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "11000:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "11001:         }",
          "11002:       }",
          "11003:       else if (tag == 0x0003)",
          "11004:       {",
          "11005:         unique_id = imgdata.lens.makernotes.CamID = get4();",
          "11006:       }",
          "11007:       else if (tag == 0xa002)",
          "11008:       {",
          "11009:         stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "11010:       }",
          "11011:       else if (tag == 0xa003)",
          "11012:       {",
          "11013:         imgdata.lens.makernotes.LensID = get2();",
          "11014:         if (imgdata.lens.makernotes.LensID)",
          "11015:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;",
          "11016:       }",
          "11017:       else if (tag == 0xa005)",
          "11018:       {",
          "11019:         stmread(imgdata.lens.InternalLensSerial, len, ifp);",
          "11020:       }",
          "11021:       else if (tag == 0xa019)",
          "11022:       {",
          "11023:         imgdata.lens.makernotes.CurAp = getreal(type);",
          "11025:       else if (tag == 0xa01a)",
          "11026:       {",
          "11027:         imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;",
          "11028:         if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)",
          "11029:           imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;",
          "11030:       }",
          "11031:     }",
          "11033:     else if (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"Konica\", 6) || !strncasecmp(make, \"Minolta\", 7) ||",
          "11035:               (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) ||",
          "11036:                !strncasecmp(model, \"Lusso\", 5) || !strncasecmp(model, \"HV\", 2))))",
          "11037:     {",
          "11038:       ushort lid;",
          "11039:       if (tag == 0xb001) // Sony ModelID",
          "11041:         unique_id = get2();",
          "11042:         setSonyBodyFeatures(unique_id);",
          "11043:         if (table_buf_0x9050_present)",
          "11045:           process_Sony_0x9050(table_buf_0x9050, unique_id);",
          "11046:           free(table_buf_0x9050);",
          "11047:           table_buf_0x9050_present = 0;",
          "11049:         if (table_buf_0x940c_present)",
          "11050:         {",
          "11051:           if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)",
          "11052:           {",
          "11053:             process_Sony_0x940c(table_buf_0x940c);",
          "11054:           }",
          "11055:           free(table_buf_0x940c);",
          "11056:           table_buf_0x940c_present = 0;",
          "11057:         }",
          "11058:       }",
          "11060:       else if ((tag == 0x0010) && // CameraInfo",
          "11061:                strncasecmp(model, \"DSLR-A100\", 9) && strncasecmp(model, \"NEX-5C\", 6) && !strncasecmp(make, \"SONY\", 4) &&",
          "11062:                ((len == 368) ||  // a700",
          "11063:                 (len == 5478) || // a850, a900",
          "11064:                 (len == 5506) || // a200, a300, a350",
          "11065:                 (len == 6118) || // a230, a290, a330, a380, a390",
          "11069:                 (len == 15360)))",
          "11070:       {",
          "11071:         table_buf = (uchar *)malloc(len);",
          "11072:         fread(table_buf, len, 1, ifp);",
          "11073:         if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&",
          "11074:             memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))",
          "11075:         {",
          "11076:           switch (len)",
          "11078:           case 368:",
          "11079:           case 5478:",
          "11081:             if (table_buf[0] | table_buf[3])",
          "11082:               imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);",
          "11083:             if (table_buf[2] | table_buf[5])",
          "11084:               imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);",
          "11085:             if (table_buf[4])",
          "11086:               imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;",
          "11087:             if (table_buf[4])",
          "11088:               imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;",
          "11089:             parseSonyLensFeatures(table_buf[1], table_buf[6]);",
          "11090:             break;",
          "11091:           default:",
          "11093:             if (table_buf[1] | table_buf[2])",
          "11094:               imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);",
          "11095:             if (table_buf[3] | table_buf[4])",
          "11096:               imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);",
          "11097:             if (table_buf[5])",
          "11098:               imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;",
          "11099:             if (table_buf[6])",
          "11100:               imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;",
          "11101:             parseSonyLensFeatures(table_buf[0], table_buf[7]);",
          "11103:         }",
          "11104:         free(table_buf);",
          "11105:       }",
          "11107:       else if ((tag == 0x0020) && // WBInfoA100, needs 0xb028 processing",
          "11108:                !strncasecmp(model, \"DSLR-A100\", 9))",
          "11109:       {",
          "11110:         fseek(ifp, 0x49dc, SEEK_CUR);",
          "11111:         stmread(imgdata.shootinginfo.InternalBodySerial, 12, ifp);",
          "11112:       }",
          "11114:       else if (tag == 0x0104)",
          "11115:       {",
          "11116:         imgdata.other.FlashEC = getreal(type);",
          "11117:       }",
          "11119:       else if (tag == 0x0105) // Teleconverter",
          "11120:       {",
          "11121:         imgdata.lens.makernotes.TeleconverterID = get2();",
          "11122:       }",
          "11124:       else if (tag == 0x0114 && len < 256000) // CameraSettings",
          "11125:       {",
          "11126:         table_buf = (uchar *)malloc(len);",
          "11127:         fread(table_buf, len, 1, ifp);",
          "11128:         switch (len)",
          "11129:         {",
          "11130:         case 280:",
          "11131:         case 364:",
          "11132:         case 332:",
          "11134:           if (table_buf[2] | table_buf[3])",
          "11136:             lid = (((ushort)table_buf[2]) << 8) | ((ushort)table_buf[3]);",
          "11137:             imgdata.lens.makernotes.CurAp = powf64(2.0f, ((float)lid / 8.0f - 1.0f) / 2.0f);",
          "11139:           break;",
          "11140:         case 1536:",
          "11141:         case 2048:",
          "11143:           parseSonyLensType2(table_buf[1016], table_buf[1015]);",
          "11144:           if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)",
          "11146:             switch (table_buf[153])",
          "11147:             {",
          "11148:             case 16:",
          "11149:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;",
          "11151:             case 17:",
          "11152:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;",
          "11156:           break;",
          "11157:         }",
          "11158:         free(table_buf);",
          "11159:       }",
          "11161:       else if (tag == 0x9050 && len < 256000) // little endian",
          "11162:       {",
          "11163:         table_buf_0x9050 = (uchar *)malloc(len);",
          "11164:         table_buf_0x9050_present = 1;",
          "11165:         fread(table_buf_0x9050, len, 1, ifp);",
          "11167:         if (imgdata.lens.makernotes.CamID)",
          "11168:         {",
          "11169:           process_Sony_0x9050(table_buf_0x9050, imgdata.lens.makernotes.CamID);",
          "11170:           free(table_buf_0x9050);",
          "11171:           table_buf_0x9050_present = 0;",
          "11172:         }",
          "11173:       }",
          "11175:       else if (tag == 0x940c && len < 256000)",
          "11176:       {",
          "11177:         table_buf_0x940c = (uchar *)malloc(len);",
          "11178:         table_buf_0x940c_present = 1;",
          "11179:         fread(table_buf_0x940c, len, 1, ifp);",
          "11180:         if ((imgdata.lens.makernotes.CamID) && (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E))",
          "11181:         {",
          "11182:           process_Sony_0x940c(table_buf_0x940c);",
          "11183:           free(table_buf_0x940c);",
          "11184:           table_buf_0x940c_present = 0;",
          "11185:         }",
          "11186:       }",
          "11188:       else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))",
          "11189:       {",
          "11190:         imgdata.lens.makernotes.LensID = get4();",
          "11191:         if ((imgdata.lens.makernotes.LensID > 0x4900) && (imgdata.lens.makernotes.LensID <= 0x5900))",
          "11192:         {",
          "11193:           imgdata.lens.makernotes.AdapterID = 0x4900;",
          "11194:           imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;",
          "11195:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;",
          "11196:           strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");",
          "11197:         }",
          "11199:         else if ((imgdata.lens.makernotes.LensID > 0xEF00) && (imgdata.lens.makernotes.LensID < 0xFFFF) &&",
          "11200:                  (imgdata.lens.makernotes.LensID != 0xFF00))",
          "11201:         {",
          "11202:           imgdata.lens.makernotes.AdapterID = 0xEF00;",
          "11203:           imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;",
          "11204:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "11205:         }",
          "11206:         if (tag == 0x010c)",
          "11207:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;",
          "11208:       }",
          "11210:       else if (tag == 0xb02a && len < 256000) // Sony LensSpec",
          "11211:       {",
          "11212:         table_buf = (uchar *)malloc(len);",
          "11213:         fread(table_buf, len, 1, ifp);",
          "11214:         if (table_buf[1] | table_buf[2])",
          "11215:           imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);",
          "11216:         if (table_buf[3] | table_buf[4])",
          "11217:           imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);",
          "11218:         if (table_buf[5])",
          "11219:           imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;",
          "11220:         if (table_buf[6])",
          "11221:           imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;",
          "11222:         parseSonyLensFeatures(table_buf[0], table_buf[7]);",
          "11223:         free(table_buf);",
          "11224:       }",
          "11225:     }",
          "11227:     fseek(ifp, _pos, SEEK_SET);",
          "11228: #endif",
          "11230:     if (tag == 2 && strstr(make, \"NIKON\") && !iso_speed)",
          "11231:       iso_speed = (get2(), get2());",
          "11232:     if (tag == 37 && strstr(make, \"NIKON\") && (!iso_speed || iso_speed == 65535))",
          "11233:     {",
          "11234:       unsigned char cc;",
          "11235:       fread(&cc, 1, 1, ifp);",
          "11236:       iso_speed = int(100.0 * powf64(2.0f, float(cc) / 12.0 - 5.0));",
          "11237:     }",
          "11238:     if (tag == 4 && len > 26 && len < 35)",
          "11239:     {",
          "11240:       if ((i = (get4(), get2())) != 0x7fff && (!iso_speed || iso_speed == 65535))",
          "11241:         iso_speed = 50 * powf64(2.0, i / 32.0 - 4);",
          "11242: #ifdef LIBRAW_LIBRARY_BUILD",
          "11243:       get4();",
          "11244: #else",
          "11245:       if ((i = (get2(), get2())) != 0x7fff && !aperture)",
          "11246:         aperture = powf64(2.0, i / 64.0);",
          "11247: #endif",
          "11248:       if ((i = get2()) != 0xffff && !shutter)",
          "11249:         shutter = powf64(2.0, (short)i / -32.0);",
          "11250:       wbi = (get2(), get2());",
          "11251:       shot_order = (get2(), get2());",
          "11252:     }",
          "11253:     if ((tag == 4 || tag == 0x114) && !strncmp(make, \"KONICA\", 6))",
          "11254:     {",
          "11255:       fseek(ifp, tag == 4 ? 140 : 160, SEEK_CUR);",
          "11256:       switch (get2())",
          "11257:       {",
          "11258:       case 72:",
          "11259:         flip = 0;",
          "11260:         break;",
          "11261:       case 76:",
          "11262:         flip = 6;",
          "11263:         break;",
          "11264:       case 82:",
          "11265:         flip = 5;",
          "11266:         break;",
          "11267:       }",
          "11268:     }",
          "11269:     if (tag == 7 && type == 2 && len > 20)",
          "11270:       fgets(model2, 64, ifp);",
          "11271:     if (tag == 8 && type == 4)",
          "11272:       shot_order = get4();",
          "11273:     if (tag == 9 && !strncmp(make, \"Canon\", 5))",
          "11274:       fread(artist, 64, 1, ifp);",
          "11275:     if (tag == 0xc && len == 4)",
          "11276:       FORC3 cam_mul[(c << 1 | c >> 1) & 3] = getreal(type);",
          "11277:     if (tag == 0xd && type == 7 && get2() == 0xaaaa)",
          "11278:     {",
          "11279:       for (c = i = 2; (ushort)c != 0xbbbb && i < len; i++)",
          "11280:         c = c << 8 | fgetc(ifp);",
          "11281:       while ((i += 4) < len - 5)",
          "11282:         if (get4() == 257 && (i = len) && (c = (get4(), fgetc(ifp))) < 3)",
          "11283:           flip = \"065\"[c] - '0';",
          "11284:     }",
          "11286: #ifndef LIBRAW_LIBRARY_BUILD",
          "11287:     if (tag == 0x10 && type == 4)",
          "11288:       unique_id = get4();",
          "11289: #endif",
          "11291: #ifdef LIBRAW_LIBRARY_BUILD",
          "11292:     INT64 _pos2 = ftell(ifp);",
          "11293:     if (!strncasecmp(make, \"Olympus\", 7))",
          "11294:     {",
          "11295:       short nWB, tWB;",
          "11296:       if ((tag == 0x20300108) || (tag == 0x20310109))",
          "11297:         imgdata.makernotes.olympus.ColorSpace = get2();",
          "11299:       if ((tag == 0x20400102) && (len == 2) && (!strncasecmp(model, \"E-410\", 5) || !strncasecmp(model, \"E-510\", 5)))",
          "11300:       {",
          "11301:         int i;",
          "11302:         for (i = 0; i < 64; i++)",
          "11303:           imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = imgdata.color.WB_Coeffs[i][1] =",
          "11304:               imgdata.color.WB_Coeffs[i][3] = 0x100;",
          "11305:         for (i = 64; i < 256; i++)",
          "11306:           imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;",
          "11307:       }",
          "11308:       if ((tag >= 0x20400102) && (tag <= 0x2040010d))",
          "11309:       {",
          "11310:         ushort CT;",
          "11311:         nWB = tag - 0x20400102;",
          "11312:         switch (nWB)",
          "11313:         {",
          "11314:         case 0:",
          "11315:           CT = 3000;",
          "11316:           tWB = LIBRAW_WBI_Tungsten;",
          "11317:           break;",
          "11318:         case 1:",
          "11319:           CT = 3300;",
          "11320:           tWB = 0x100;",
          "11321:           break;",
          "11322:         case 2:",
          "11323:           CT = 3600;",
          "11324:           tWB = 0x100;",
          "11325:           break;",
          "11326:         case 3:",
          "11327:           CT = 3900;",
          "11328:           tWB = 0x100;",
          "11329:           break;",
          "11330:         case 4:",
          "11331:           CT = 4000;",
          "11332:           tWB = LIBRAW_WBI_FL_W;",
          "11333:           break;",
          "11334:         case 5:",
          "11335:           CT = 4300;",
          "11336:           tWB = 0x100;",
          "11337:           break;",
          "11338:         case 6:",
          "11339:           CT = 4500;",
          "11340:           tWB = LIBRAW_WBI_FL_D;",
          "11341:           break;",
          "11342:         case 7:",
          "11343:           CT = 4800;",
          "11344:           tWB = 0x100;",
          "11345:           break;",
          "11346:         case 8:",
          "11347:           CT = 5300;",
          "11348:           tWB = LIBRAW_WBI_FineWeather;",
          "11349:           break;",
          "11350:         case 9:",
          "11351:           CT = 6000;",
          "11352:           tWB = LIBRAW_WBI_Cloudy;",
          "11353:           break;",
          "11354:         case 10:",
          "11355:           CT = 6600;",
          "11356:           tWB = LIBRAW_WBI_FL_N;",
          "11357:           break;",
          "11358:         case 11:",
          "11359:           CT = 7500;",
          "11360:           tWB = LIBRAW_WBI_Shade;",
          "11361:           break;",
          "11362:         default:",
          "11363:           CT = 0;",
          "11364:           tWB = 0x100;",
          "11365:         }",
          "11366:         if (CT)",
          "11367:         {",
          "11368:           imgdata.color.WBCT_Coeffs[nWB][0] = CT;",
          "11369:           imgdata.color.WBCT_Coeffs[nWB][1] = get2();",
          "11370:           imgdata.color.WBCT_Coeffs[nWB][3] = get2();",
          "11371:           if (len == 4)",
          "11373:             imgdata.color.WBCT_Coeffs[nWB][2] = get2();",
          "11374:             imgdata.color.WBCT_Coeffs[nWB][4] = get2();",
          "11376:         }",
          "11377:         if (tWB != 0x100)",
          "11378:           FORC4 imgdata.color.WB_Coeffs[tWB][c] = imgdata.color.WBCT_Coeffs[nWB][c + 1];",
          "11379:       }",
          "11380:       if ((tag >= 0x20400113) && (tag <= 0x2040011e))",
          "11381:       {",
          "11382:         nWB = tag - 0x20400113;",
          "11383:         imgdata.color.WBCT_Coeffs[nWB][2] = imgdata.color.WBCT_Coeffs[nWB][4] = get2();",
          "11384:         switch (nWB)",
          "11385:         {",
          "11386:         case 0:",
          "11387:           tWB = LIBRAW_WBI_Tungsten;",
          "11388:           break;",
          "11389:         case 4:",
          "11390:           tWB = LIBRAW_WBI_FL_W;",
          "11391:           break;",
          "11392:         case 6:",
          "11393:           tWB = LIBRAW_WBI_FL_D;",
          "11394:           break;",
          "11395:         case 8:",
          "11396:           tWB = LIBRAW_WBI_FineWeather;",
          "11397:           break;",
          "11398:         case 9:",
          "11399:           tWB = LIBRAW_WBI_Cloudy;",
          "11400:           break;",
          "11401:         case 10:",
          "11402:           tWB = LIBRAW_WBI_FL_N;",
          "11403:           break;",
          "11404:         case 11:",
          "11405:           tWB = LIBRAW_WBI_Shade;",
          "11406:           break;",
          "11407:         default:",
          "11408:           tWB = 0x100;",
          "11409:         }",
          "11410:         if (tWB != 0x100)",
          "11411:           imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = imgdata.color.WBCT_Coeffs[nWB][2];",
          "11414:       if (tag == 0x20400121)",
          "11415:       {",
          "11416:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();",
          "11417:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();",
          "11418:         if (len == 4)",
          "11419:         {",
          "11420:           imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = get2();",
          "11421:           imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();",
          "11422:         }",
          "11423:       }",
          "11424:       if (tag == 0x2040011f)",
          "11425:       {",
          "11426:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();",
          "11427:       }",
          "11428:       if (tag == 0x30000120)",
          "11429:       {",
          "11430:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();",
          "11431:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();",
          "11432:         if (len == 2)",
          "11433:         {",
          "11434:           for (int i = 0; i < 256; i++)",
          "11435:             imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;",
          "11436:         }",
          "11437:       }",
          "11438:       if (tag == 0x30000121)",
          "11439:       {",
          "11440:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();",
          "11441:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();",
          "11442:       }",
          "11443:       if (tag == 0x30000122)",
          "11444:       {",
          "11445:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = get2();",
          "11446:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = get2();",
          "11447:       }",
          "11448:       if (tag == 0x30000123)",
          "11449:       {",
          "11450:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();",
          "11451:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();",
          "11452:       }",
          "11453:       if (tag == 0x30000124)",
          "11454:       {",
          "11455:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Sunset][0] = get2();",
          "11456:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Sunset][2] = get2();",
          "11457:       }",
          "11458:       if (tag == 0x30000130)",
          "11459:       {",
          "11460:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();",
          "11461:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();",
          "11462:       }",
          "11463:       if (tag == 0x30000131)",
          "11464:       {",
          "11465:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();",
          "11466:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();",
          "11467:       }",
          "11468:       if (tag == 0x30000132)",
          "11469:       {",
          "11470:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();",
          "11471:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();",
          "11472:       }",
          "11473:       if (tag == 0x30000133)",
          "11474:       {",
          "11475:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();",
          "11476:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();",
          "11477:       }",
          "11479:       if ((tag == 0x20400805) && (len == 2))",
          "11481:         imgdata.makernotes.olympus.OlympusSensorCalibration[0] = getreal(type);",
          "11482:         imgdata.makernotes.olympus.OlympusSensorCalibration[1] = getreal(type);",
          "11483:         FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.olympus.OlympusSensorCalibration[0];",
          "11485:       if (tag == 0x20200401)",
          "11486:       {",
          "11487:         imgdata.other.FlashEC = getreal(type);",
          "11490:     fseek(ifp, _pos2, SEEK_SET);",
          "11493:     if (tag == 0x11 && is_raw && !strncmp(make, \"NIKON\", 5))",
          "11494:     {",
          "11495:       fseek(ifp, get4() + base, SEEK_SET);",
          "11496:       parse_tiff_ifd(base);",
          "11497:     }",
          "11498:     if (tag == 0x14 && type == 7)",
          "11499:     {",
          "11500:       if (len == 2560)",
          "11501:       {",
          "11502:         fseek(ifp, 1248, SEEK_CUR);",
          "11503:         goto get2_256;",
          "11504:       }",
          "11505:       fread(buf, 1, 10, ifp);",
          "11506:       if (!strncmp(buf, \"NRW \", 4))",
          "11507:       {",
          "11508:         fseek(ifp, strcmp(buf + 4, \"0100\") ? 46 : 1546, SEEK_CUR);",
          "11509:         cam_mul[0] = get4() << 2;",
          "11510:         cam_mul[1] = get4() + get4();",
          "11511:         cam_mul[2] = get4() << 2;",
          "11515:       fread(model, 64, 1, ifp);",
          "11516:     if (strstr(make, \"PENTAX\"))",
          "11517:     {",
          "11518:       if (tag == 0x1b)",
          "11519:         tag = 0x1018;",
          "11520:       if (tag == 0x1c)",
          "11521:         tag = 0x1017;",
          "11523:     if (tag == 0x1d)",
          "11524:     {",
          "11530:           if ((strbuflen(model) == 3) && (!strcmp(model, \"D50\")))",
          "",
          "---------------",
          "--- Hunk 94 ---",
          "[Context before]",
          "10561:           }",
          "10562:         }",
          "10563: #endif",
          "10565: #ifdef LIBRAW_LIBRARY_BUILD",
          "10566:       }",
          "10567:       if (!imgdata.shootinginfo.BodySerial[0])",
          "10568:         sprintf(imgdata.shootinginfo.BodySerial, \"%d\", serial);",
          "10569: #endif",
          "10570:     }",
          "10574:       FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get4();",
          "10575:     }",
          "10576: #ifndef LIBRAW_LIBRARY_BUILD",
          "10577:     if (tag == 0x3d && type == 3 && len == 4)",
          "10579: #endif",
          "10581:       data_offset = get4();",
          "10583:       raw_height = get2() * 2;",
          "10585:       filters = 0x61616161;",
          "10586:     }",
          "10590:       thumb_offset = ftell(ifp);",
          "10591:       thumb_length = len;",
          "10592:     }",
          "",
          "[Removed Lines]",
          "10564:  serial = serial*10 + (isdigit(c) ? c - '0' : c % 10);",
          "10571:     if (tag == 0x29 && type == 1) {  // Canon PowerShot G9",
          "10572:       c = wbi < 18 ? \"012347800000005896\"[wbi]-'0' : 0;",
          "10573:       fseek (ifp, 8 + c*32, SEEK_CUR);",
          "10578:       FORC4 cblack[c ^ c >> 1] = get2() >> (14-tiff_bps);",
          "10580:     if (tag == 0x81 && type == 4) {",
          "10582:       fseek (ifp, data_offset + 41, SEEK_SET);",
          "10584:       raw_width  = get2();",
          "10587:     if ((tag == 0x81  && type == 7) ||",
          "10588:  (tag == 0x100 && type == 7) ||",
          "10589:  (tag == 0x280 && type == 1)) {",
          "",
          "[Added Lines]",
          "11540:         serial = serial * 10 + (isdigit(c) ? c - '0' : c % 10);",
          "11547:     if (tag == 0x29 && type == 1)",
          "11548:     { // Canon PowerShot G9",
          "11549:       c = wbi < 18 ? \"012347800000005896\"[wbi] - '0' : 0;",
          "11550:       fseek(ifp, 8 + c * 32, SEEK_CUR);",
          "11555:       FORC4 cblack[c ^ c >> 1] = get2() >> (14 - tiff_bps);",
          "11557:     if (tag == 0x81 && type == 4)",
          "11558:     {",
          "11560:       fseek(ifp, data_offset + 41, SEEK_SET);",
          "11562:       raw_width = get2();",
          "11565:     if ((tag == 0x81 && type == 7) || (tag == 0x100 && type == 7) || (tag == 0x280 && type == 1))",
          "11566:     {",
          "",
          "---------------",
          "--- Hunk 95 ---",
          "[Context before]",
          "10596:       thumb_length = get4();",
          "10597:     if (tag == 0x8c || tag == 0x96)",
          "10598:       meta_offset = ftell(ifp);",
          "10621:       order = 0x4949;",
          "10623:       FORC3 cam_mul[c] = get4();",
          "10624:     }",
          "10627:       FORC3 cam_mul[c] = get2();",
          "10628:     }",
          "10633:         ci = xlat[0][serial & 0xff];",
          "10634:         cj = xlat[1][NikonKey];",
          "10635:         ck = 0x60;",
          "10637:           buf97[i] ^= (cj += ci * ck++);",
          "10641:       }",
          "10642: #ifdef LIBRAW_LIBRARY_BUILD",
          "10643:       if ((NikonLensDataVersion > 200) && lenNikonLensData)",
          "",
          "[Removed Lines]",
          "10599:     if (tag == 0x97) {",
          "10600:       for (i=0; i < 4; i++)",
          "10601:  ver97 = ver97 * 10 + fgetc(ifp)-'0';",
          "10602:       switch (ver97) {",
          "10603:  case 100:",
          "10604:    fseek (ifp, 68, SEEK_CUR);",
          "10605:    FORC4 cam_mul[(c >> 1) | ((c & 1) << 1)] = get2();",
          "10606:    break;",
          "10607:  case 102:",
          "10608:    fseek (ifp, 6, SEEK_CUR);",
          "10609:    FORC4 cam_mul[c ^ (c >> 1)] = get2();",
          "10610:    break;",
          "10611:  case 103:",
          "10612:    fseek (ifp, 16, SEEK_CUR);",
          "10613:    FORC4 cam_mul[c] = get2();",
          "10614:       }",
          "10615:       if (ver97 >= 200) {",
          "10616:  if (ver97 != 205) fseek (ifp, 280, SEEK_CUR);",
          "10617:  fread (buf97, 324, 1, ifp);",
          "10618:       }",
          "10619:     }",
          "10620:     if (tag == 0xa1 && type == 7) {",
          "10622:       fseek (ifp, 140, SEEK_CUR);",
          "10625:     if (tag == 0xa4 && type == 3) {",
          "10626:       fseek (ifp, wbi*48, SEEK_CUR);",
          "10630:     if (tag == 0xa7) { // shutter count",
          "10631:       NikonKey = fgetc(ifp)^fgetc(ifp)^fgetc(ifp)^fgetc(ifp);",
          "10632:         if ( (unsigned) (ver97-200) < 17) {",
          "10636:         for (i=0; i < 324; i++)",
          "10638:         i = \"66666>666;6A;:;55\"[ver97-200] - '0';",
          "10639:         FORC4 cam_mul[c ^ (c >> 1) ^ (i & 1)] =",
          "10640:           sget2 (buf97 + (i & -2) + c*2);",
          "",
          "[Added Lines]",
          "11576:     if (tag == 0x97)",
          "11577:     {",
          "11578:       for (i = 0; i < 4; i++)",
          "11579:         ver97 = ver97 * 10 + fgetc(ifp) - '0';",
          "11580:       switch (ver97)",
          "11581:       {",
          "11582:       case 100:",
          "11583:         fseek(ifp, 68, SEEK_CUR);",
          "11584:         FORC4 cam_mul[(c >> 1) | ((c & 1) << 1)] = get2();",
          "11585:         break;",
          "11586:       case 102:",
          "11587:         fseek(ifp, 6, SEEK_CUR);",
          "11588:         FORC4 cam_mul[c ^ (c >> 1)] = get2();",
          "11589:         break;",
          "11590:       case 103:",
          "11591:         fseek(ifp, 16, SEEK_CUR);",
          "11592:         FORC4 cam_mul[c] = get2();",
          "11593:       }",
          "11594:       if (ver97 >= 200)",
          "11595:       {",
          "11596:         if (ver97 != 205)",
          "11597:           fseek(ifp, 280, SEEK_CUR);",
          "11598:         fread(buf97, 324, 1, ifp);",
          "11599:       }",
          "11600:     }",
          "11601:     if (tag == 0xa1 && type == 7)",
          "11602:     {",
          "11604:       fseek(ifp, 140, SEEK_CUR);",
          "11607:     if (tag == 0xa4 && type == 3)",
          "11608:     {",
          "11609:       fseek(ifp, wbi * 48, SEEK_CUR);",
          "11613:     if (tag == 0xa7)",
          "11614:     { // shutter count",
          "11615:       NikonKey = fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp);",
          "11616:       if ((unsigned)(ver97 - 200) < 17)",
          "11617:       {",
          "11621:         for (i = 0; i < 324; i++)",
          "11623:         i = \"66666>666;6A;:;55\"[ver97 - 200] - '0';",
          "11624:         FORC4 cam_mul[c ^ (c >> 1) ^ (i & 1)] = sget2(buf97 + (i & -2) + c * 2);",
          "",
          "---------------",
          "--- Hunk 96 ---",
          "[Context before]",
          "10658:         lenNikonLensData = 0;",
          "10659:         free(table_buf);",
          "10660:       }",
          "10666: #endif",
          "10667:     }",
          "10673:     if (tag == 0x200 && len == 3)",
          "10675:     if (tag == 0x200 && len == 4)",
          "10676:       FORC4 cblack[c ^ c >> 1] = get2();",
          "10677:     if (tag == 0x201 && len == 4)",
          "10679:     if (tag == 0x220 && type == 7)",
          "10680:       meta_offset = ftell(ifp);",
          "10681:     if (tag == 0x401 && type == 4 && len == 4)",
          "10682:       FORC4 cblack[c ^ c >> 1] = get4();",
          "10683: #ifdef LIBRAW_LIBRARY_BUILD",
          "10693: #endif",
          "10695: #ifdef LIBRAW_LIBRARY_BUILD",
          "10697: #endif",
          "10698:       order = 0x4949;",
          "10701: #ifdef LIBRAW_LIBRARY_BUILD",
          "10704: #endif",
          "10710:       }",
          "10711:     }",
          "10714:       cam_mul[0] = get2() * 508 * 1.078 / 0x10000;",
          "10715:       cam_mul[2] = get2() * 382 * 1.173 / 0x10000;",
          "10716:     }",
          "10718:       if (len == 614)",
          "10720:       else if (len == 734 || len == 1502)",
          "10723:       goto get2_256;",
          "10724:     }",
          "10725:     if ((tag == 0x1011 && len == 9) || tag == 0x20400200)",
          "10737: #else",
          "10739: #endif",
          "10741:     if ((tag == 0x1012 || tag == 0x20400600) && len == 4)",
          "10742:       FORC4 cblack[c ^ c >> 1] = get2();",
          "10743:     if (tag == 0x1017 || tag == 0x20400100)",
          "10744:       cam_mul[0] = get2() / 256.0;",
          "10745:     if (tag == 0x1018 || tag == 0x20400100)",
          "10746:       cam_mul[2] = get2() / 256.0;",
          "10749:       order = 0x4d4d;",
          "10750:       cam_mul[0] = get2() / 256.0;",
          "10751:       cam_mul[2] = get2() / 256.0;",
          "10752:     }",
          "10753:     if ((tag | 0x70) == 0x2070 && (type == 4 || type == 13))",
          "10755: #ifdef LIBRAW_LIBRARY_BUILD",
          "10757:     if (tag == 0x2010)",
          "10775: #endif",
          "10778:     if (tag == 0x2040)",
          "10783:     }",
          "10785:       i = len == 582 ? 50 : len == 653 ? 68 : len == 5120 ? 142 : 126;",
          "10787:       FORC4 cam_mul[c ^ (c >> 1)] = get2();",
          "10792:       }",
          "10793:     }",
          "10800: #ifdef LIBRAW_LIBRARY_BUILD",
          "10837:       }",
          "10839:       {",
          "10845:       }",
          "10846:     if (tag == 0x4021 && get4() && get4())",
          "10847:       FORC4 cam_mul[c] = 1024;",
          "10850:   }",
          "10851: quit:",
          "10852:   order = sorder;",
          "",
          "[Removed Lines]",
          "10661:       if (ver97 == 601)  // Coolpix A",
          "10662:      {",
          "10663:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "10664:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "10665:      }",
          "10669:     if(tag == 0xb001 && type == 3) // Sony ModelID",
          "10670:       {",
          "10671:         unique_id = get2();",
          "10672:       }",
          "10674:       shot_order = (get4(),get4());",
          "10678:          FORC4 cam_mul[c ^ (c >> 1)] = get2();",
          "10685:     if (tag == 0x03d && strstr(make,\"NIKON\") && len == 4)",
          "10686:       {",
          "10687:         FORC4 cblack[c ^ c >> 1] = get2();",
          "10688:         i = cblack[3];",
          "10689:         FORC3 if(i>cblack[c]) i = cblack[c];",
          "10690:         FORC4 cblack[c]-=i;",
          "10691:         black += i;",
          "10692:       }",
          "10696:  int loopc = 0;",
          "10699:       fseek (ifp, 22, SEEK_CUR);",
          "10700:       for (offset=22; offset+22 < len; offset += 22+i) {",
          "10702:  if(loopc++>1024)",
          "10703:   throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "10705:  tag = get4();",
          "10706:  fseek (ifp, 14, SEEK_CUR);",
          "10707:  i = get4()-4;",
          "10708:  if (tag == 0x76a43207) flip = get2();",
          "10709:  else fseek (ifp, i, SEEK_CUR);",
          "10712:     if (tag == 0xe80 && len == 256 && type == 7) {",
          "10713:       fseek (ifp, 48, SEEK_CUR);",
          "10717:     if (tag == 0xf00 && type == 7) {",
          "10719:  fseek (ifp, 176, SEEK_CUR);",
          "10721:  fseek (ifp, 148, SEEK_CUR);",
          "10722:       else goto next;",
          "10726:           for (i=0; i < 3; i++)",
          "10727:    {",
          "10728: #ifdef LIBRAW_LIBRARY_BUILD",
          "10729:            if (!imgdata.makernotes.olympus.ColorSpace)",
          "10730:     {",
          "10731:             FORC3 cmatrix[i][c] = ((short) get2()) / 256.0;",
          "10732:     }",
          "10733:            else",
          "10734:     {",
          "10735:             FORC3 imgdata.color.ccm[i][c] = ((short) get2()) / 256.0;",
          "10736:     }",
          "10738:             FORC3 cmatrix[i][c] = ((short) get2()) / 256.0;",
          "10740:           }",
          "10747:     if (tag == 0x2011 && len == 2) {",
          "10748: get2_256:",
          "10754:       fseek (ifp, get4()+base, SEEK_SET);",
          "10758:       {",
          "10759:         INT64 _pos3 = ftell(ifp);",
          "10760:         parse_makernote(base, 0x2010);",
          "10761:         fseek(ifp,_pos3,SEEK_SET);",
          "10762:       }",
          "10764:     if (",
          "10765:          ((tag == 0x2020) || (tag == 0x3000) || (tag == 0x2030) || (tag == 0x2031)) &&",
          "10766:          ((type == 7) || (type == 13)) &&",
          "10767:          !strncasecmp(make,\"Olympus\",7)",
          "10768:        )",
          "10769:       {",
          "10770:         INT64 _pos3 = ftell(ifp);",
          "10771:         parse_makernote(base, tag);",
          "10772:         fseek(ifp,_pos3,SEEK_SET);",
          "10773:       }",
          "10776:     if ((tag == 0x2020) && ((type == 7) || (type == 13)) && !strncmp(buf,\"OLYMP\",5))",
          "10777:       parse_thumb_note (base, 257, 258);",
          "10779:       parse_makernote (base, 0x2040);",
          "10780:     if (tag == 0xb028) {",
          "10781:       fseek (ifp, get4()+base, SEEK_SET);",
          "10782:       parse_thumb_note (base, 136, 137);",
          "10784:     if (tag == 0x4001 && len > 500 && len < 100000) {",
          "10786:       fseek (ifp, i, SEEK_CUR);",
          "10788:       for (i+=18; i <= len; i+=10) {",
          "10789:        get2();",
          "10790:        FORC4 sraw_mul[c ^ (c >> 1)] = get2();",
          "10791:        if (sraw_mul[1] == 1170) break;",
          "10794:     if(!strncasecmp(make,\"Samsung\",7))",
          "10795:       {",
          "10796:         if (tag == 0xa020) // get the full Samsung encryption key",
          "10797:             for (i=0; i<11; i++) SamsungKey[i] = get4();",
          "10798:         if (tag == 0xa021) // get and decode Samsung cam_mul array",
          "10799:             FORC4 cam_mul[c ^ (c >> 1)] = get4() - SamsungKey[c];",
          "10801:         if (tag == 0xa023)",
          "10802:           {",
          "10803:             imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] = get4() - SamsungKey[8];",
          "10804:             imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = get4() - SamsungKey[9];",
          "10805:             imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = get4() - SamsungKey[10];",
          "10806:             imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][2] = get4() - SamsungKey[0];",
          "10807:             if (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1]>>1))",
          "10808:               {",
          "10809:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] >> 4;",
          "10810:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] >> 4;",
          "10811:               }",
          "10812:           }",
          "10813:         if (tag == 0xa024)",
          "10814:           {",
          "10815:             FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][c ^ (c >> 1)] = get4() - SamsungKey[c+1];",
          "10816:             if (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1]>>1))",
          "10817:               {",
          "10818:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] >> 4;",
          "10819:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] >> 4;",
          "10820:               }",
          "10821:           }",
          "10822:         if (tag == 0xa025)",
          "10823:            imgdata.color.linear_max[0]=",
          "10824:              imgdata.color.linear_max[1]=",
          "10825:              imgdata.color.linear_max[2]=",
          "10826:              imgdata.color.linear_max[3]= get4() - SamsungKey[0];",
          "10827:         if (tag == 0xa030 && len == 9)",
          "10828:             for (i=0; i < 3; i++)",
          "10829:               FORC3 imgdata.color.ccm[i][c] = (float)((short)((get4() + SamsungKey[i*3+c])))/256.0;",
          "10830: #endif",
          "10831:         if (tag == 0xa031 && len == 9) // get and decode Samsung color matrix",
          "10832:             for (i=0; i < 3; i++)",
          "10833:               FORC3 cmatrix[i][c] = (float)((short)((get4() + SamsungKey[i*3+c])))/256.0;",
          "10835:         if (tag == 0xa028)",
          "10836:           FORC4 cblack[c ^ (c >> 1)] = get4() - SamsungKey[c];",
          "10838:     else",
          "10841:         if (tag == 0xa021)",
          "10842:           FORC4 cam_mul[c ^ (c >> 1)] = get4();",
          "10843:         if (tag == 0xa028)",
          "10844:           FORC4 cam_mul[c ^ (c >> 1)] -= get4();",
          "10848: next:",
          "10849:     fseek (ifp, save, SEEK_SET);",
          "",
          "[Added Lines]",
          "11645:       if (ver97 == 601) // Coolpix A",
          "11646:       {",
          "11647:         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "11648:         imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "11649:       }",
          "11653:     if (tag == 0xb001 && type == 3) // Sony ModelID",
          "11654:     {",
          "11655:       unique_id = get2();",
          "11656:     }",
          "11658:       shot_order = (get4(), get4());",
          "11662:       FORC4 cam_mul[c ^ (c >> 1)] = get2();",
          "11669:     if (tag == 0x03d && strstr(make, \"NIKON\") && len == 4)",
          "11670:     {",
          "11671:       FORC4 cblack[c ^ c >> 1] = get2();",
          "11672:       i = cblack[3];",
          "11673:       FORC3 if (i > cblack[c]) i = cblack[c];",
          "11674:       FORC4 cblack[c] -= i;",
          "11675:       black += i;",
          "11676:     }",
          "11678:     if (tag == 0xe01)",
          "11681:       int loopc = 0;",
          "11684:       fseek(ifp, 22, SEEK_CUR);",
          "11685:       for (offset = 22; offset + 22 < len; offset += 22 + i)",
          "11686:       {",
          "11688:         if (loopc++ > 1024)",
          "11689:           throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "11691:         tag = get4();",
          "11692:         fseek(ifp, 14, SEEK_CUR);",
          "11693:         i = get4() - 4;",
          "11694:         if (tag == 0x76a43207)",
          "11695:           flip = get2();",
          "11696:         else",
          "11697:           fseek(ifp, i, SEEK_CUR);",
          "11700:     if (tag == 0xe80 && len == 256 && type == 7)",
          "11701:     {",
          "11702:       fseek(ifp, 48, SEEK_CUR);",
          "11706:     if (tag == 0xf00 && type == 7)",
          "11707:     {",
          "11709:         fseek(ifp, 176, SEEK_CUR);",
          "11711:         fseek(ifp, 148, SEEK_CUR);",
          "11712:       else",
          "11713:         goto next;",
          "11717:       for (i = 0; i < 3; i++)",
          "11718:       {",
          "11719: #ifdef LIBRAW_LIBRARY_BUILD",
          "11720:         if (!imgdata.makernotes.olympus.ColorSpace)",
          "11721:         {",
          "11722:           FORC3 cmatrix[i][c] = ((short)get2()) / 256.0;",
          "11723:         }",
          "11724:         else",
          "11725:         {",
          "11726:           FORC3 imgdata.color.ccm[i][c] = ((short)get2()) / 256.0;",
          "11727:         }",
          "11729:         FORC3 cmatrix[i][c] = ((short)get2()) / 256.0;",
          "11731:       }",
          "11738:     if (tag == 0x2011 && len == 2)",
          "11739:     {",
          "11740:     get2_256:",
          "11746:       fseek(ifp, get4() + base, SEEK_SET);",
          "11750:     {",
          "11751:       INT64 _pos3 = ftell(ifp);",
          "11752:       parse_makernote(base, 0x2010);",
          "11753:       fseek(ifp, _pos3, SEEK_SET);",
          "11754:     }",
          "11756:     if (((tag == 0x2020) || (tag == 0x3000) || (tag == 0x2030) || (tag == 0x2031)) && ((type == 7) || (type == 13)) &&",
          "11757:         !strncasecmp(make, \"Olympus\", 7))",
          "11758:     {",
          "11759:       INT64 _pos3 = ftell(ifp);",
          "11760:       parse_makernote(base, tag);",
          "11761:       fseek(ifp, _pos3, SEEK_SET);",
          "11762:     }",
          "11765:     if ((tag == 0x2020) && ((type == 7) || (type == 13)) && !strncmp(buf, \"OLYMP\", 5))",
          "11766:       parse_thumb_note(base, 257, 258);",
          "11768:       parse_makernote(base, 0x2040);",
          "11769:     if (tag == 0xb028)",
          "11770:     {",
          "11771:       fseek(ifp, get4() + base, SEEK_SET);",
          "11772:       parse_thumb_note(base, 136, 137);",
          "11774:     if (tag == 0x4001 && len > 500 && len < 100000)",
          "11775:     {",
          "11777:       fseek(ifp, i, SEEK_CUR);",
          "11779:       for (i += 18; i <= len; i += 10)",
          "11780:       {",
          "11781:         get2();",
          "11782:         FORC4 sraw_mul[c ^ (c >> 1)] = get2();",
          "11783:         if (sraw_mul[1] == 1170)",
          "11784:           break;",
          "11787:     if (!strncasecmp(make, \"Samsung\", 7))",
          "11788:     {",
          "11789:       if (tag == 0xa020) // get the full Samsung encryption key",
          "11790:         for (i = 0; i < 11; i++)",
          "11791:           SamsungKey[i] = get4();",
          "11792:       if (tag == 0xa021) // get and decode Samsung cam_mul array",
          "11793:         FORC4 cam_mul[c ^ (c >> 1)] = get4() - SamsungKey[c];",
          "11795:       if (tag == 0xa023)",
          "11796:       {",
          "11797:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] = get4() - SamsungKey[8];",
          "11798:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = get4() - SamsungKey[9];",
          "11799:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = get4() - SamsungKey[10];",
          "11800:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][2] = get4() - SamsungKey[0];",
          "11801:         if (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] >> 1))",
          "11802:         {",
          "11803:           imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] >> 4;",
          "11804:           imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] >> 4;",
          "11805:         }",
          "11807:       if (tag == 0xa024)",
          "11809:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][c ^ (c >> 1)] = get4() - SamsungKey[c + 1];",
          "11810:         if (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] >> 1))",
          "11811:         {",
          "11812:           imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] >> 4;",
          "11813:           imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] >> 4;",
          "11814:         }",
          "11816:       if (tag == 0xa025)",
          "11817:         imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =",
          "11818:             imgdata.color.linear_max[3] = get4() - SamsungKey[0];",
          "11819:       if (tag == 0xa030 && len == 9)",
          "11820:         for (i = 0; i < 3; i++)",
          "11821:           FORC3 imgdata.color.ccm[i][c] = (float)((short)((get4() + SamsungKey[i * 3 + c]))) / 256.0;",
          "11822: #endif",
          "11823:       if (tag == 0xa031 && len == 9) // get and decode Samsung color matrix",
          "11824:         for (i = 0; i < 3; i++)",
          "11825:           FORC3 cmatrix[i][c] = (float)((short)((get4() + SamsungKey[i * 3 + c]))) / 256.0;",
          "11827:       if (tag == 0xa028)",
          "11828:         FORC4 cblack[c ^ (c >> 1)] = get4() - SamsungKey[c];",
          "11829:     }",
          "11830:     else",
          "11831:     {",
          "11833:       if (tag == 0xa021)",
          "11834:         FORC4 cam_mul[c ^ (c >> 1)] = get4();",
          "11835:       if (tag == 0xa028)",
          "11836:         FORC4 cam_mul[c ^ (c >> 1)] -= get4();",
          "11837:     }",
          "11840:   next:",
          "11841:     fseek(ifp, save, SEEK_SET);",
          "",
          "---------------",
          "--- Hunk 97 ---",
          "[Context before]",
          "10856:    Since the TIFF DateTime string has no timezone information,",
          "10857:    assume that the camera's clock was set to Universal Time.",
          "10860: {",
          "10861:   struct tm t;",
          "10862:   char str[20];",
          "",
          "[Removed Lines]",
          "10859: void CLASS get_timestamp (int reversed)",
          "",
          "[Added Lines]",
          "11851: void CLASS get_timestamp(int reversed)",
          "",
          "---------------",
          "--- Hunk 98 ---",
          "[Context before]",
          "10865:   str[19] = 0;",
          "10866:   if (reversed)",
          "10868:   else",
          "10873:     return;",
          "10874:   t.tm_year -= 1900;",
          "10875:   t.tm_mon -= 1;",
          "",
          "[Removed Lines]",
          "10867:     for (i=19; i--; ) str[i] = fgetc(ifp);",
          "10869:     fread (str, 19, 1, ifp);",
          "10870:   memset (&t, 0, sizeof t);",
          "10871:   if (sscanf (str, \"%d:%d:%d %d:%d:%d\", &t.tm_year, &t.tm_mon,",
          "10872:  &t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec) != 6)",
          "",
          "[Added Lines]",
          "11859:     for (i = 19; i--;)",
          "11860:       str[i] = fgetc(ifp);",
          "11862:     fread(str, 19, 1, ifp);",
          "11863:   memset(&t, 0, sizeof t);",
          "11864:   if (sscanf(str, \"%d:%d:%d %d:%d:%d\", &t.tm_year, &t.tm_mon, &t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec) != 6)",
          "",
          "---------------",
          "--- Hunk 99 ---",
          "[Context before]",
          "10878:     timestamp = mktime(&t);",
          "10879: }",
          "10882: {",
          "10883:   unsigned kodak, entries, tag, type, len, save, c;",
          "10887:   entries = get2();",
          "10889: #ifdef LIBRAW_LIBRARY_BUILD",
          "10890:   INT64 fsize = ifp->size();",
          "10891: #endif",
          "10895: #ifdef LIBRAW_LIBRARY_BUILD",
          "10896:     INT64 savepos = ftell(ifp);",
          "10903: #endif",
          "10905: #ifdef LIBRAW_LIBRARY_BUILD",
          "10907:       imgdata.lens.FocalLengthIn35mmFormat = get2();",
          "10908:       break;",
          "10910:       stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "10911:       break;",
          "10913:       imgdata.lens.MinFocal = getreal(type);",
          "10914:       imgdata.lens.MaxFocal = getreal(type);",
          "10915:       imgdata.lens.MaxAp4MinFocal = getreal(type);",
          "10916:       imgdata.lens.MaxAp4MaxFocal = getreal(type);",
          "10917:       break;",
          "10919:       stmread(imgdata.lens.LensSerial, len, ifp);",
          "10920:       break;",
          "10922:       imgdata.lens.dng.MinFocal = getreal(type);",
          "10923:       imgdata.lens.dng.MaxFocal = getreal(type);",
          "10924:       imgdata.lens.dng.MaxAp4MinFocal = getreal(type);",
          "10925:       imgdata.lens.dng.MaxAp4MaxFocal = getreal(type);",
          "10926:       break;",
          "10928:       stmread(imgdata.lens.LensMake, len, ifp);",
          "10929:       break;",
          "10931:       stmread(imgdata.lens.Lens, len, ifp);",
          "10932:       if (!strncmp(imgdata.lens.Lens, \"----\", 4))",
          "10933:         imgdata.lens.Lens[0] = 0;",
          "",
          "[Removed Lines]",
          "10881: void CLASS parse_exif (int base)",
          "10884:   double expo,ape;",
          "10886:   kodak = !strncmp(make,\"EASTMAN\",7) && tiff_nifds < 3;",
          "10888:   if(!strncmp(make,\"Hasselblad\",10) && (tiff_nifds > 3) && (entries > 512)) return;",
          "10892:   while (entries--) {",
          "10893:     tiff_get (base, &tag, &type, &len, &save);",
          "10897:     if(len > 8 && savepos + len > fsize*2) continue;",
          "10898:     if(callbacks.exif_cb)",
          "10899:       {",
          "10900:         callbacks.exif_cb(callbacks.exifparser_data,tag,type,len,order,ifp);",
          "10901:         fseek(ifp,savepos,SEEK_SET);",
          "10902:       }",
          "10904:     switch (tag) {",
          "10906:     case 0xa405:  // FocalLengthIn35mmFormat",
          "10909:     case 0xa431:  // BodySerialNumber",
          "10912:     case 0xa432:  // LensInfo, 42034dec, Lens Specification per EXIF standard",
          "10918:     case 0xa435:  // LensSerialNumber",
          "10921:     case 0xc630:  // DNG LensInfo, Lens Specification per EXIF standard",
          "10927:     case 0xa433:  // LensMake",
          "10930:     case 0xa434:  // LensModel",
          "",
          "[Added Lines]",
          "11873: void CLASS parse_exif(int base)",
          "11876:   double expo, ape;",
          "11878:   kodak = !strncmp(make, \"EASTMAN\", 7) && tiff_nifds < 3;",
          "11880:   if (!strncmp(make, \"Hasselblad\", 10) && (tiff_nifds > 3) && (entries > 512))",
          "11881:     return;",
          "11885:   while (entries--)",
          "11886:   {",
          "11887:     tiff_get(base, &tag, &type, &len, &save);",
          "11891:     if (len > 8 && savepos + len > fsize * 2)",
          "11892:       continue;",
          "11893:     if (callbacks.exif_cb)",
          "11894:     {",
          "11895:       callbacks.exif_cb(callbacks.exifparser_data, tag, type, len, order, ifp);",
          "11896:       fseek(ifp, savepos, SEEK_SET);",
          "11897:     }",
          "11899:     switch (tag)",
          "11900:     {",
          "11902:     case 0xa405: // FocalLengthIn35mmFormat",
          "11905:     case 0xa431: // BodySerialNumber",
          "11908:     case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard",
          "11914:     case 0xa435: // LensSerialNumber",
          "11917:     case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard",
          "11923:     case 0xa433: // LensMake",
          "11926:     case 0xa434: // LensModel",
          "",
          "---------------",
          "--- Hunk 100 ---",
          "[Context before]",
          "10936:       imgdata.lens.EXIF_MaxAp = powf64(2.0f, (getreal(type) / 2.0f));",
          "10937:       break;",
          "10938: #endif",
          "11006:   }",
          "11007: }",
          "",
          "[Removed Lines]",
          "10939:       case 33434:  tiff_ifd[tiff_nifds-1].t_shutter =",
          "10940:      shutter = getreal(type);  break;",
          "10941:       case 33437:  aperture = getreal(type);  break;  // 0x829d FNumber",
          "10942:       case 34855:  iso_speed = get2();   break;",
          "10943:       case 34866:",
          "10944:         if (iso_speed == 0xffff && (!strncasecmp(make, \"SONY\",4) || !strncasecmp(make, \"CANON\",5)))",
          "10945:           iso_speed = getreal(type);",
          "10946:         break;",
          "10947:       case 36867:",
          "10948:       case 36868:  get_timestamp(0);   break;",
          "10949:       case 37377:  if ((expo = -getreal(type)) < 128 && shutter == 0.)",
          "10950:        tiff_ifd[tiff_nifds-1].t_shutter =",
          "10951:    shutter = powf64(2.0, expo);",
          "10952:   break;",
          "10953:       case 37378:                                       // 0x9202 ApertureValue",
          "10954:         if ((fabs(ape = getreal(type))<256.0) && (!aperture))",
          "10955:           aperture = powf64(2.0, ape/2);",
          "10956:         break;",
          "10957:       case 37385:  flash_used = getreal(type);          break;",
          "10958:       case 37386:  focal_len = getreal(type);  break;",
          "10959:       case 37500:                            // tag 0x927c",
          "10960: #ifdef LIBRAW_LIBRARY_BUILD",
          "10961:        if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\",6))) ||",
          "10962:            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_OV5647\",9))) ||",
          "10963:            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_imx219\",9)))) {",
          "10964:          char mn_text[512];",
          "10965:          char* pos;",
          "10966:          char ccms[512];",
          "10967:          ushort l;",
          "10968:          float num;",
          "10970:          fgets(mn_text, len, ifp);",
          "10971:          pos = strstr(mn_text, \"gain_r=\");",
          "10972:          if (pos) cam_mul[0] = atof(pos+7);",
          "10973:          pos = strstr(mn_text, \"gain_b=\");",
          "10974:          if (pos) cam_mul[2] = atof(pos+7);",
          "10975:          if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f)) cam_mul[1] = cam_mul[3] = 1.0f;",
          "10976:          else cam_mul[0] = cam_mul[2] = 0.0f;",
          "10978:          pos = strstr(mn_text, \"ccm=\") + 4;",
          "10979:          l = strstr(pos, \" \") - pos;",
          "10980:          memcpy (ccms, pos, l);",
          "10981:          ccms[l] = '\\0';",
          "10983:          pos = strtok (ccms, \",\");",
          "10984:          for (l=0; l<4; l++) {",
          "10985:            num = 0.0;",
          "10986:            for (c=0; c<3; c++) {",
          "10987:              imgdata.color.ccm[l][c] = (float)atoi(pos);",
          "10988:              num += imgdata.color.ccm[l][c];",
          "10989:              pos = strtok (NULL, \",\");",
          "10990:            }",
          "10991:            if (num > 0.01) FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;",
          "10992:          }",
          "10993:        }",
          "10994:        else",
          "10995: #endif",
          "10996:         parse_makernote (base, 0);",
          "10997:        break;",
          "10998:       case 40962:  if (kodak) raw_width  = get4(); break;",
          "10999:       case 40963:  if (kodak) raw_height = get4(); break;",
          "11000:       case 41730:",
          "11001:  if (get4() == 0x20002)",
          "11002:    for (exif_cfa=c=0; c < 8; c+=2)",
          "11003:      exif_cfa |= fgetc(ifp) * 0x01010101 << c;",
          "11004:     }",
          "11005:     fseek (ifp, save, SEEK_SET);",
          "",
          "[Added Lines]",
          "11935:     case 33434:",
          "11936:       tiff_ifd[tiff_nifds - 1].t_shutter = shutter = getreal(type);",
          "11937:       break;",
          "11938:     case 33437:",
          "11939:       aperture = getreal(type);",
          "11940:       break; // 0x829d FNumber",
          "11941:     case 34855:",
          "11942:       iso_speed = get2();",
          "11943:       break;",
          "11944:     case 34866:",
          "11945:       if (iso_speed == 0xffff && (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"CANON\", 5)))",
          "11946:         iso_speed = getreal(type);",
          "11947:       break;",
          "11948:     case 36867:",
          "11949:     case 36868:",
          "11950:       get_timestamp(0);",
          "11951:       break;",
          "11952:     case 37377:",
          "11953:       if ((expo = -getreal(type)) < 128 && shutter == 0.)",
          "11954:         tiff_ifd[tiff_nifds - 1].t_shutter = shutter = powf64(2.0, expo);",
          "11955:       break;",
          "11956:     case 37378: // 0x9202 ApertureValue",
          "11957:       if ((fabs(ape = getreal(type)) < 256.0) && (!aperture))",
          "11958:         aperture = powf64(2.0, ape / 2);",
          "11959:       break;",
          "11960:     case 37385:",
          "11961:       flash_used = getreal(type);",
          "11962:       break;",
          "11963:     case 37386:",
          "11964:       focal_len = getreal(type);",
          "11965:       break;",
          "11966:     case 37500: // tag 0x927c",
          "11967: #ifdef LIBRAW_LIBRARY_BUILD",
          "11968:       if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\", 6))) ||",
          "11969:           ((!strncmp(make, \"RaspberryPi\", 11)) && (!strncmp(model, \"RP_OV5647\", 9))) ||",
          "11970:           ((!strncmp(make, \"RaspberryPi\", 11)) && (!strncmp(model, \"RP_imx219\", 9))))",
          "11971:       {",
          "11972:         char mn_text[512];",
          "11973:         char *pos;",
          "11974:         char ccms[512];",
          "11975:         ushort l;",
          "11976:         float num;",
          "11978:         fgets(mn_text, len, ifp);",
          "11979:         pos = strstr(mn_text, \"gain_r=\");",
          "11980:         if (pos)",
          "11981:           cam_mul[0] = atof(pos + 7);",
          "11982:         pos = strstr(mn_text, \"gain_b=\");",
          "11983:         if (pos)",
          "11984:           cam_mul[2] = atof(pos + 7);",
          "11985:         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))",
          "11986:           cam_mul[1] = cam_mul[3] = 1.0f;",
          "11987:         else",
          "11988:           cam_mul[0] = cam_mul[2] = 0.0f;",
          "11990:         pos = strstr(mn_text, \"ccm=\") + 4;",
          "11991:         l = strstr(pos, \" \") - pos;",
          "11992:         memcpy(ccms, pos, l);",
          "11993:         ccms[l] = '\\0';",
          "11995:         pos = strtok(ccms, \",\");",
          "11996:         for (l = 0; l < 4; l++)",
          "11997:         {",
          "11998:           num = 0.0;",
          "11999:           for (c = 0; c < 3; c++)",
          "12000:           {",
          "12001:             imgdata.color.ccm[l][c] = (float)atoi(pos);",
          "12002:             num += imgdata.color.ccm[l][c];",
          "12003:             pos = strtok(NULL, \",\");",
          "12004:           }",
          "12005:           if (num > 0.01)",
          "12006:             FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;",
          "12007:         }",
          "12008:       }",
          "12009:       else",
          "12010: #endif",
          "12011:         parse_makernote(base, 0);",
          "12012:       break;",
          "12013:     case 40962:",
          "12014:       if (kodak)",
          "12015:         raw_width = get4();",
          "12016:       break;",
          "12017:     case 40963:",
          "12018:       if (kodak)",
          "12019:         raw_height = get4();",
          "12020:       break;",
          "12021:     case 41730:",
          "12022:       if (get4() == 0x20002)",
          "12023:         for (exif_cfa = c = 0; c < 8; c += 2)",
          "12024:           exif_cfa |= fgetc(ifp) * 0x01010101 << c;",
          "12025:     }",
          "12026:     fseek(ifp, save, SEEK_SET);",
          "",
          "---------------",
          "--- Hunk 101 ---",
          "[Context before]",
          "11015:   entries = get2();",
          "11016:   if (entries > 200)",
          "11018:   if (entries > 0)",
          "11019:     imgdata.other.parsed_gps.gpsparsed = 1;",
          "11021:     tiff_get(base, &tag, &type, &len, &save);",
          "11027:     case 2:",
          "11028:       if (len == 3)",
          "11029:         FORC(3) imgdata.other.parsed_gps.latitude[c] = getreal(type);",
          "",
          "[Removed Lines]",
          "11017:    return;",
          "11020:   while (entries--) {",
          "11022:     if(len > 1024) continue; // no GPS tags are 1k or larger",
          "11023:     switch (tag) {",
          "11024:     case 1:  imgdata.other.parsed_gps.latref = getc(ifp); break;",
          "11025:     case 3:  imgdata.other.parsed_gps.longref = getc(ifp); break;",
          "11026:     case 5:  imgdata.other.parsed_gps.altref = getc(ifp); break;",
          "",
          "[Added Lines]",
          "12038:     return;",
          "12041:   while (entries--)",
          "12042:   {",
          "12044:     if (len > 1024)",
          "12045:       continue; // no GPS tags are 1k or larger",
          "12046:     switch (tag)",
          "12047:     {",
          "12048:     case 1:",
          "12049:       imgdata.other.parsed_gps.latref = getc(ifp);",
          "12050:       break;",
          "12051:     case 3:",
          "12052:       imgdata.other.parsed_gps.longref = getc(ifp);",
          "12053:       break;",
          "12054:     case 5:",
          "12055:       imgdata.other.parsed_gps.altref = getc(ifp);",
          "12056:       break;",
          "",
          "---------------",
          "--- Hunk 102 ---",
          "[Context before]",
          "11039:     case 6:",
          "11040:       imgdata.other.parsed_gps.altitude = getreal(type);",
          "11041:       break;",
          "11043:     }",
          "11044:     fseek(ifp, save, SEEK_SET);",
          "11045:   }",
          "11046: }",
          "11047: #endif",
          "11050: {",
          "11051:   unsigned entries, tag, type, len, save, c;",
          "11053:   entries = get2();",
          "11066:     }",
          "11068:   }",
          "11069: }",
          "11072: {",
          "11077:   int i, j, k;",
          "11083: }",
          "11086: {",
          "11087:   char data[40];",
          "11095:   float romm_cam[3][3];",
          "11100:     get4();",
          "11102:     skip = get4();",
          "11103:     from = ftell(ifp);",
          "11106: #ifdef LIBRAW_LIBRARY_BUILD",
          "11117:     }",
          "11125:     }",
          "11126: #endif",
          "11129:       thumb_offset = from;",
          "11130:       thumb_length = skip;",
          "11131:     }",
          "11133:       profile_offset = from;",
          "11134:       profile_length = skip;",
          "11135:     }",
          "11162:       flip = i - flip;",
          "11163:     }",
          "11167:     }",
          "11169:       load_flags = get4();",
          "11172:   }",
          "11173:   if (planes)",
          "11176: }",
          "11179: {",
          "11180:   int i;",
          "11186: }",
          "11188: #ifdef LIBRAW_LIBRARY_BUILD",
          "11191: {",
          "11200: }",
          "11204: {",
          "11205:   unsigned entries, tag, type, len, save;",
          "11210:   entries = get2();",
          "11212:   INT64 fsize = ifp->size();",
          "11215:     INT64 savepos = ftell(ifp);",
          "11227:       wbi = -2;",
          "11228:     }",
          "11274:       FORC3 cam_mul[c] = get4();",
          "11278:   }",
          "11279: }",
          "11280: #else",
          "11282: {",
          "11283:   unsigned entries, tag, type, len, save;",
          "11288:   entries = get2();",
          "11296:       wbi = -2;",
          "11297:     }",
          "11299:     if (tag == 2120 + wbi && wbi >= 0)",
          "11301:     if (tag == 2130 + wbi)",
          "11302:       FORC3 mul[c] = getreal(type);",
          "11303:     if (tag == 2140 + wbi && wbi >= 0)",
          "11313:       FORC3 cam_mul[c] = get4();",
          "11317:   }",
          "11318: }",
          "11319: #endif",
          "11327: {",
          "11330:   char *cbuf, *cp;",
          "11332:   double fm[3][4], cc[4][4], cm[4][3], cam_xyz[4][3], num;",
          "11336:   struct jhead jh;",
          "11337:   int pana_raw = 0;",
          "11338: #ifndef LIBRAW_LIBRARY_BUILD",
          "",
          "[Removed Lines]",
          "11042:     case 9: imgdata.other.parsed_gps.gpsstatus = getc(ifp); break;",
          "11049: void CLASS parse_gps (int base)",
          "11054:   while (entries--) {",
          "11055:     tiff_get (base, &tag, &type, &len, &save);",
          "11056:     if(len > 1024) continue; // no GPS tags are 1k or larger",
          "11057:     switch (tag) {",
          "11058:       case 1: case 3: case 5:",
          "11059:  gpsdata[29+tag/2] = getc(ifp);   break;",
          "11060:       case 2: case 4: case 7:",
          "11061:  FORC(6) gpsdata[tag/3*6+c] = get4();  break;",
          "11062:       case 6:",
          "11063:  FORC(2) gpsdata[18+c] = get4();   break;",
          "11064:       case 18: case 29:",
          "11065:  fgets ((char *) (gpsdata+14+tag/3), MIN(len,12), ifp);",
          "11067:     fseek (ifp, save, SEEK_SET);",
          "11071: void CLASS romm_coeff (float romm_cam[3][3])",
          "11074:   { {  2.034193, -0.727420, -0.306766 },",
          "11075:     { -0.228811,  1.231729, -0.002922 },",
          "11076:     { -0.008565, -0.153273,  1.161839 } };",
          "11079:   for (i=0; i < 3; i++)",
          "11080:     for (j=0; j < 3; j++)",
          "11081:       for (cmatrix[i][j] = k=0; k < 3; k++)",
          "11082:  cmatrix[i][j] += rgb_romm[i][k] * romm_cam[k][j];",
          "11085: void CLASS parse_mos (int offset)",
          "11088:   int skip, from, i, c, neut[4], planes=0, frot=0;",
          "11089:   static const char *mod[] =",
          "11090:   { \"\",\"DCB2\",\"Volare\",\"Cantare\",\"CMost\",\"Valeo 6\",\"Valeo 11\",\"Valeo 22\",",
          "11091:     \"Valeo 11p\",\"Valeo 17\",\"\",\"Aptus 17\",\"Aptus 22\",\"Aptus 75\",\"Aptus 65\",",
          "11092:     \"Aptus 54S\",\"Aptus 65S\",\"Aptus 75S\",\"AFi 5\",\"AFi 6\",\"AFi 7\",",
          "11093:     \"AFi-II 7\",\"Aptus-II 7\",\"\",\"Aptus-II 6\",\"\",\"\",\"Aptus-II 10\",\"Aptus-II 5\",",
          "11094:     \"\",\"\",\"\",\"\",\"Aptus-II 10R\",\"Aptus-II 8\",\"\",\"Aptus-II 12\",\"\",\"AFi-II 12\" };",
          "11097:   fseek (ifp, offset, SEEK_SET);",
          "11098:   while (1) {",
          "11099:     if (get4() != 0x504b5453) break;",
          "11101:     fread (data, 1, 40, ifp);",
          "11107:     if (!strcmp(data,\"CameraObj_camera_type\")) {",
          "11108:  stmread(imgdata.lens.makernotes.body, skip, ifp);",
          "11109:     }",
          "11110:     if (!strcmp(data,\"back_serial_number\")) {",
          "11111:        char buffer [sizeof(imgdata.shootinginfo.BodySerial)];",
          "11112:        char *words[4];",
          "11113:        int nwords;",
          "11114:        stmread(buffer, skip, ifp);",
          "11115:        nwords = getwords(buffer, words, 4,sizeof(imgdata.shootinginfo.BodySerial));",
          "11116:        strcpy (imgdata.shootinginfo.BodySerial, words[0]);",
          "11118:     if (!strcmp(data,\"CaptProf_serial_number\")) {",
          "11119:        char buffer [sizeof(imgdata.shootinginfo.InternalBodySerial)];",
          "11120:        char *words[4];",
          "11121:        int nwords;",
          "11122:        stmread(buffer, skip, ifp);",
          "11123:        nwords = getwords(buffer, words, 4,sizeof(imgdata.shootinginfo.InternalBodySerial));",
          "11124:        strcpy (imgdata.shootinginfo.InternalBodySerial, words[0]);",
          "11128:     if (!strcmp(data,\"JPEG_preview_data\")) {",
          "11132:     if (!strcmp(data,\"icc_camera_profile\")) {",
          "11136:     if (!strcmp(data,\"ShootObj_back_type\")) {",
          "11137:       fscanf (ifp, \"%d\", &i);",
          "11138:       if ((unsigned) i < sizeof mod / sizeof (*mod))",
          "11139:  strcpy (model, mod[i]);",
          "11140:     }",
          "11141:     if (!strcmp(data,\"icc_camera_to_tone_matrix\")) {",
          "11142:       for (i=0; i < 9; i++)",
          "11143:  ((float *)romm_cam)[i] = int_to_float(get4());",
          "11144:       romm_coeff (romm_cam);",
          "11145:     }",
          "11146:     if (!strcmp(data,\"CaptProf_color_matrix\")) {",
          "11147:       for (i=0; i < 9; i++)",
          "11148:  fscanf (ifp, \"%f\", (float *)romm_cam + i);",
          "11149:       romm_coeff (romm_cam);",
          "11150:     }",
          "11151:     if (!strcmp(data,\"CaptProf_number_of_planes\"))",
          "11152:       fscanf (ifp, \"%d\", &planes);",
          "11153:     if (!strcmp(data,\"CaptProf_raw_data_rotation\"))",
          "11154:       fscanf (ifp, \"%d\", &flip);",
          "11155:     if (!strcmp(data,\"CaptProf_mosaic_pattern\"))",
          "11156:       FORC4 {",
          "11157:  fscanf (ifp, \"%d\", &i);",
          "11158:  if (i == 1) frot = c ^ (c >> 1);",
          "11159:       }",
          "11160:     if (!strcmp(data,\"ImgProf_rotation_angle\")) {",
          "11161:       fscanf (ifp, \"%d\", &i);",
          "11164:     if (!strcmp(data,\"NeutObj_neutrals\") && !cam_mul[0]) {",
          "11165:       FORC4 fscanf (ifp, \"%d\", neut+c);",
          "11166:       FORC3 cam_mul[c] = (float) neut[0] / neut[c+1];",
          "11168:     if (!strcmp(data,\"Rows_data\"))",
          "11170:     parse_mos (from);",
          "11171:     fseek (ifp, skip+from, SEEK_SET);",
          "11174:     filters = (planes == 1) * 0x01010101 *",
          "11175:  (uchar) \"\\x94\\x61\\x16\\x49\"[(flip/90 + frot) & 3];",
          "11178: void CLASS linear_table (unsigned len)",
          "11181:   if (len > 0x10000) len = 0x10000;",
          "11182:   read_shorts (curve, len);",
          "11183:   for (i=len; i < 0x10000; i++)",
          "11184:     curve[i] = curve[i-1];",
          "11185:   maximum = curve[len<0x1000?0xfff:len-1];",
          "11190: void CLASS Kodak_WB_0x08tags (int wb, unsigned type)",
          "11192:  float mul[3]={1,1,1}, num, mul2;",
          "11193:  int c;",
          "11194:  FORC3 mul[c] = (num=getreal(type))==0 ? 1 : num;",
          "11195:  imgdata.color.WB_Coeffs[wb][1] = imgdata.color.WB_Coeffs[wb][3] = mul[1];",
          "11196:  mul2 = mul[1] * mul[1];",
          "11197:  imgdata.color.WB_Coeffs[wb][0] = mul2 / mul[0];",
          "11198:  imgdata.color.WB_Coeffs[wb][2] = mul2 / mul[2];",
          "11199:  return;",
          "11203: void CLASS parse_kodak_ifd (int base)",
          "11206:   int i, c, wbi=-2;",
          "11207:   float mul[3]={1,1,1}, num;",
          "11208:   static const int wbtag[] = { 64037,64040,64039,64041,-1,-1,64042 };",
          "11211:   if (entries > 1024) return;",
          "11213:   while (entries--) {",
          "11214:     tiff_get (base, &tag, &type, &len, &save);",
          "11216:     if(len > 8 && len + savepos > 2*fsize) continue;",
          "11217:     if(callbacks.exif_cb)",
          "11218:       {",
          "11219:         callbacks.exif_cb(callbacks.exifparser_data,tag | 0x20000,type,len,order,ifp);",
          "11220:         fseek(ifp,savepos,SEEK_SET);",
          "11221:       }",
          "11222:     if (tag == 1011) imgdata.other.FlashEC = getreal(type);",
          "11223:     if (tag == 1020) wbi = getint(type);",
          "11225:       fseek (ifp, 40, SEEK_CUR);",
          "11226:       FORC3 cam_mul[c] = 2048.0 / fMAX(1.0f,get2());",
          "11230:     if (tag == 0x0848) Kodak_WB_0x08tags(LIBRAW_WBI_Daylight, type);",
          "11231:     if (tag == 0x0849) Kodak_WB_0x08tags(LIBRAW_WBI_Tungsten, type);",
          "11232:     if (tag == 0x084a) Kodak_WB_0x08tags(LIBRAW_WBI_Fluorescent, type);",
          "11233:     if (tag == 0x084b) Kodak_WB_0x08tags(LIBRAW_WBI_Flash, type);",
          "11234:     if (tag == 0x0e93) imgdata.color.linear_max[0] =",
          "11235:                          imgdata.color.linear_max[1] =",
          "11236:                          imgdata.color.linear_max[2] =",
          "11237:                          imgdata.color.linear_max[3] = get2();",
          "11238:         if (tag == 0x09ce)",
          "11239:   stmread(imgdata.shootinginfo.InternalBodySerial,len, ifp);",
          "11240:         if (tag == 0xfa00)",
          "11241:   stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "11242:  if (tag == 0xfa27)",
          "11243:    {",
          "11244:                 FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get4();",
          "11245:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];",
          "11246:    }",
          "11247:  if (tag == 0xfa28)",
          "11248:    {",
          "11249:                 FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get4();",
          "11250:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];",
          "11251:    }",
          "11252:  if (tag == 0xfa29)",
          "11253:    {",
          "11254:                 FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get4();",
          "11255:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];",
          "11256:    }",
          "11257:  if (tag == 0xfa2a)",
          "11258:    {",
          "11259:             FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get4();",
          "11260:             imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];",
          "11261:    }",
          "11263:     if (tag == 2120 + wbi ||",
          "11265:       {",
          "11266:         FORC3 mul[c] = (num=getreal(type))==0 ? 1 : num;",
          "11268:       }",
          "11269:     if (tag == 2317) linear_table (len);",
          "11270:     if (tag == 0x903) iso_speed = getreal(type);",
          "11272:     if (tag == 64013) wbi = fgetc(ifp);",
          "11273:     if ((unsigned) wbi < 7 && tag == wbtag[wbi])",
          "11275:     if (tag == 64019) width = getint(type);",
          "11276:     if (tag == 64020) height = (getint(type)+1) & -2;",
          "11277:     fseek (ifp, save, SEEK_SET);",
          "11281: void CLASS parse_kodak_ifd (int base)",
          "11284:   int i, c, wbi=-2, wbtemp=6500;",
          "11285:   float mul[3]={1,1,1}, num;",
          "11286:   static const int wbtag[] = { 64037,64040,64039,64041,-1,-1,64042 };",
          "11289:   if (entries > 1024) return;",
          "11290:   while (entries--) {",
          "11291:     tiff_get (base, &tag, &type, &len, &save);",
          "11292:     if (tag == 1020) wbi = getint(type);",
          "11294:       fseek (ifp, 40, SEEK_CUR);",
          "11295:       FORC3 cam_mul[c] = 2048.0 / fMAX(1.0,get2());",
          "11298:     if (tag == 2118) wbtemp = getint(type);",
          "11300:       FORC3 cam_mul[c] = 2048.0 / fMAX(1.0,getreal(type));",
          "11304:       FORC3 {",
          "11305:  for (num=i=0; i < 4; i++)",
          "11306:    num += getreal(type) * pow (wbtemp/100.0, i);",
          "11307:  cam_mul[c] = 2048 / fMAX(1.0,(num * mul[c]));",
          "11308:       }",
          "11309:     if (tag == 2317) linear_table (len);",
          "11310:     if (tag == 6020) iso_speed = getint(type);",
          "11311:     if (tag == 64013) wbi = fgetc(ifp);",
          "11312:     if ((unsigned) wbi < 7 && tag == wbtag[wbi])",
          "11314:     if (tag == 64019) width = getint(type);",
          "11315:     if (tag == 64020) height = (getint(type)+1) & -2;",
          "11316:     fseek (ifp, save, SEEK_SET);",
          "11322: void CLASS parse_minolta (int base);",
          "11323: int CLASS parse_tiff (int base);",
          "11326: int CLASS parse_tiff_ifd (int base)",
          "11328:   unsigned entries, tag, type, len, plen=16, save;",
          "11329:   int ifd, use_cm=0, cfa, i, j, c, ima_len=0;",
          "11331:   uchar cfa_pat[16], cfa_pc[] = { 0,1,2,3 }, tab[256];",
          "11333:   double ab[]={ 1,1,1,1 }, asn[] = { 0,0,0,0 }, xyz[] = { 1,1,1 };",
          "11334:   unsigned sony_curve[] = { 0,0,0,0,0,4095 };",
          "11335:   unsigned *buf, sony_offset=0, sony_length=0, sony_key=0;",
          "",
          "[Added Lines]",
          "12072:     case 9:",
          "12073:       imgdata.other.parsed_gps.gpsstatus = getc(ifp);",
          "12074:       break;",
          "12081: void CLASS parse_gps(int base)",
          "12086:   while (entries--)",
          "12087:   {",
          "12088:     tiff_get(base, &tag, &type, &len, &save);",
          "12089:     if (len > 1024)",
          "12090:       continue; // no GPS tags are 1k or larger",
          "12091:     switch (tag)",
          "12092:     {",
          "12093:     case 1:",
          "12094:     case 3:",
          "12095:     case 5:",
          "12096:       gpsdata[29 + tag / 2] = getc(ifp);",
          "12097:       break;",
          "12098:     case 2:",
          "12099:     case 4:",
          "12100:     case 7:",
          "12101:       FORC(6) gpsdata[tag / 3 * 6 + c] = get4();",
          "12102:       break;",
          "12103:     case 6:",
          "12104:       FORC(2) gpsdata[18 + c] = get4();",
          "12105:       break;",
          "12106:     case 18:",
          "12107:     case 29:",
          "12108:       fgets((char *)(gpsdata + 14 + tag / 3), MIN(len, 12), ifp);",
          "12110:     fseek(ifp, save, SEEK_SET);",
          "12114: void CLASS romm_coeff(float romm_cam[3][3])",
          "12117:       {{2.034193, -0.727420, -0.306766}, {-0.228811, 1.231729, -0.002922}, {-0.008565, -0.153273, 1.161839}};",
          "12120:   for (i = 0; i < 3; i++)",
          "12121:     for (j = 0; j < 3; j++)",
          "12122:       for (cmatrix[i][j] = k = 0; k < 3; k++)",
          "12123:         cmatrix[i][j] += rgb_romm[i][k] * romm_cam[k][j];",
          "12126: void CLASS parse_mos(int offset)",
          "12129:   int skip, from, i, c, neut[4], planes = 0, frot = 0;",
          "12130:   static const char *mod[] = {\"\",",
          "12131:                               \"DCB2\",",
          "12132:                               \"Volare\",",
          "12133:                               \"Cantare\",",
          "12134:                               \"CMost\",",
          "12135:                               \"Valeo 6\",",
          "12136:                               \"Valeo 11\",",
          "12137:                               \"Valeo 22\",",
          "12138:                               \"Valeo 11p\",",
          "12139:                               \"Valeo 17\",",
          "12140:                               \"\",",
          "12141:                               \"Aptus 17\",",
          "12142:                               \"Aptus 22\",",
          "12143:                               \"Aptus 75\",",
          "12144:                               \"Aptus 65\",",
          "12145:                               \"Aptus 54S\",",
          "12146:                               \"Aptus 65S\",",
          "12147:                               \"Aptus 75S\",",
          "12148:                               \"AFi 5\",",
          "12149:                               \"AFi 6\",",
          "12150:                               \"AFi 7\",",
          "12151:                               \"AFi-II 7\",",
          "12152:                               \"Aptus-II 7\",",
          "12153:                               \"\",",
          "12154:                               \"Aptus-II 6\",",
          "12155:                               \"\",",
          "12156:                               \"\",",
          "12157:                               \"Aptus-II 10\",",
          "12158:                               \"Aptus-II 5\",",
          "12159:                               \"\",",
          "12160:                               \"\",",
          "12161:                               \"\",",
          "12162:                               \"\",",
          "12163:                               \"Aptus-II 10R\",",
          "12164:                               \"Aptus-II 8\",",
          "12165:                               \"\",",
          "12166:                               \"Aptus-II 12\",",
          "12167:                               \"\",",
          "12168:                               \"AFi-II 12\"};",
          "12171:   fseek(ifp, offset, SEEK_SET);",
          "12172:   while (1)",
          "12173:   {",
          "12174:     if (get4() != 0x504b5453)",
          "12175:       break;",
          "12177:     fread(data, 1, 40, ifp);",
          "12183:     if (!strcmp(data, \"CameraObj_camera_type\"))",
          "12184:     {",
          "12185:       stmread(imgdata.lens.makernotes.body, skip, ifp);",
          "12187:     if (!strcmp(data, \"back_serial_number\"))",
          "12188:     {",
          "12189:       char buffer[sizeof(imgdata.shootinginfo.BodySerial)];",
          "12190:       char *words[4];",
          "12191:       int nwords;",
          "12192:       stmread(buffer, skip, ifp);",
          "12193:       nwords = getwords(buffer, words, 4, sizeof(imgdata.shootinginfo.BodySerial));",
          "12194:       strcpy(imgdata.shootinginfo.BodySerial, words[0]);",
          "12195:     }",
          "12196:     if (!strcmp(data, \"CaptProf_serial_number\"))",
          "12197:     {",
          "12198:       char buffer[sizeof(imgdata.shootinginfo.InternalBodySerial)];",
          "12199:       char *words[4];",
          "12200:       int nwords;",
          "12201:       stmread(buffer, skip, ifp);",
          "12202:       nwords = getwords(buffer, words, 4, sizeof(imgdata.shootinginfo.InternalBodySerial));",
          "12203:       strcpy(imgdata.shootinginfo.InternalBodySerial, words[0]);",
          "12207:     if (!strcmp(data, \"JPEG_preview_data\"))",
          "12208:     {",
          "12212:     if (!strcmp(data, \"icc_camera_profile\"))",
          "12213:     {",
          "12217:     if (!strcmp(data, \"ShootObj_back_type\"))",
          "12218:     {",
          "12219:       fscanf(ifp, \"%d\", &i);",
          "12220:       if ((unsigned)i < sizeof mod / sizeof(*mod))",
          "12221:         strcpy(model, mod[i]);",
          "12222:     }",
          "12223:     if (!strcmp(data, \"icc_camera_to_tone_matrix\"))",
          "12224:     {",
          "12225:       for (i = 0; i < 9; i++)",
          "12226:         ((float *)romm_cam)[i] = int_to_float(get4());",
          "12227:       romm_coeff(romm_cam);",
          "12228:     }",
          "12229:     if (!strcmp(data, \"CaptProf_color_matrix\"))",
          "12230:     {",
          "12231:       for (i = 0; i < 9; i++)",
          "12232:         fscanf(ifp, \"%f\", (float *)romm_cam + i);",
          "12233:       romm_coeff(romm_cam);",
          "12234:     }",
          "12235:     if (!strcmp(data, \"CaptProf_number_of_planes\"))",
          "12236:       fscanf(ifp, \"%d\", &planes);",
          "12237:     if (!strcmp(data, \"CaptProf_raw_data_rotation\"))",
          "12238:       fscanf(ifp, \"%d\", &flip);",
          "12239:     if (!strcmp(data, \"CaptProf_mosaic_pattern\"))",
          "12240:       FORC4",
          "12241:       {",
          "12242:         fscanf(ifp, \"%d\", &i);",
          "12243:         if (i == 1)",
          "12244:           frot = c ^ (c >> 1);",
          "12245:       }",
          "12246:     if (!strcmp(data, \"ImgProf_rotation_angle\"))",
          "12247:     {",
          "12248:       fscanf(ifp, \"%d\", &i);",
          "12251:     if (!strcmp(data, \"NeutObj_neutrals\") && !cam_mul[0])",
          "12252:     {",
          "12253:       FORC4 fscanf(ifp, \"%d\", neut + c);",
          "12254:       FORC3 cam_mul[c] = (float)neut[0] / neut[c + 1];",
          "12256:     if (!strcmp(data, \"Rows_data\"))",
          "12258:     parse_mos(from);",
          "12259:     fseek(ifp, skip + from, SEEK_SET);",
          "12262:     filters = (planes == 1) * 0x01010101 * (uchar) \"\\x94\\x61\\x16\\x49\"[(flip / 90 + frot) & 3];",
          "12265: void CLASS linear_table(unsigned len)",
          "12268:   if (len > 0x10000)",
          "12269:     len = 0x10000;",
          "12270:   read_shorts(curve, len);",
          "12271:   for (i = len; i < 0x10000; i++)",
          "12272:     curve[i] = curve[i - 1];",
          "12273:   maximum = curve[len < 0x1000 ? 0xfff : len - 1];",
          "12278: void CLASS Kodak_WB_0x08tags(int wb, unsigned type)",
          "12280:   float mul[3] = {1, 1, 1}, num, mul2;",
          "12281:   int c;",
          "12282:   FORC3 mul[c] = (num = getreal(type)) == 0 ? 1 : num;",
          "12283:   imgdata.color.WB_Coeffs[wb][1] = imgdata.color.WB_Coeffs[wb][3] = mul[1];",
          "12284:   mul2 = mul[1] * mul[1];",
          "12285:   imgdata.color.WB_Coeffs[wb][0] = mul2 / mul[0];",
          "12286:   imgdata.color.WB_Coeffs[wb][2] = mul2 / mul[2];",
          "12287:   return;",
          "12291: void CLASS parse_kodak_ifd(int base)",
          "12294:   int i, c, wbi = -2;",
          "12295:   float mul[3] = {1, 1, 1}, num;",
          "12296:   static const int wbtag[] = {64037, 64040, 64039, 64041, -1, -1, 64042};",
          "12299:   if (entries > 1024)",
          "12300:     return;",
          "12302:   while (entries--)",
          "12303:   {",
          "12304:     tiff_get(base, &tag, &type, &len, &save);",
          "12306:     if (len > 8 && len + savepos > 2 * fsize)",
          "12307:       continue;",
          "12308:     if (callbacks.exif_cb)",
          "12309:     {",
          "12310:       callbacks.exif_cb(callbacks.exifparser_data, tag | 0x20000, type, len, order, ifp);",
          "12311:       fseek(ifp, savepos, SEEK_SET);",
          "12312:     }",
          "12313:     if (tag == 1011)",
          "12314:       imgdata.other.FlashEC = getreal(type);",
          "12315:     if (tag == 1020)",
          "12316:       wbi = getint(type);",
          "12317:     if (tag == 1021 && len == 72)",
          "12319:       fseek(ifp, 40, SEEK_CUR);",
          "12320:       FORC3 cam_mul[c] = 2048.0 / fMAX(1.0f, get2());",
          "12324:     if (tag == 0x0848)",
          "12325:       Kodak_WB_0x08tags(LIBRAW_WBI_Daylight, type);",
          "12326:     if (tag == 0x0849)",
          "12327:       Kodak_WB_0x08tags(LIBRAW_WBI_Tungsten, type);",
          "12328:     if (tag == 0x084a)",
          "12329:       Kodak_WB_0x08tags(LIBRAW_WBI_Fluorescent, type);",
          "12330:     if (tag == 0x084b)",
          "12331:       Kodak_WB_0x08tags(LIBRAW_WBI_Flash, type);",
          "12332:     if (tag == 0x0e93)",
          "12333:       imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =",
          "12334:           imgdata.color.linear_max[3] = get2();",
          "12335:     if (tag == 0x09ce)",
          "12336:       stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);",
          "12337:     if (tag == 0xfa00)",
          "12338:       stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "12339:     if (tag == 0xfa27)",
          "12340:     {",
          "12341:       FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get4();",
          "12342:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];",
          "12343:     }",
          "12344:     if (tag == 0xfa28)",
          "12345:     {",
          "12346:       FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get4();",
          "12347:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];",
          "12348:     }",
          "12349:     if (tag == 0xfa29)",
          "12350:     {",
          "12351:       FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get4();",
          "12352:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];",
          "12353:     }",
          "12354:     if (tag == 0xfa2a)",
          "12355:     {",
          "12356:       FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get4();",
          "12357:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];",
          "12358:     }",
          "12361:     {",
          "12362:       FORC3 mul[c] = (num = getreal(type)) == 0 ? 1 : num;",
          "12364:     }",
          "12365:     if (tag == 2317)",
          "12366:       linear_table(len);",
          "12367:     if (tag == 0x903)",
          "12368:       iso_speed = getreal(type);",
          "12370:     if (tag == 64013)",
          "12371:       wbi = fgetc(ifp);",
          "12372:     if ((unsigned)wbi < 7 && tag == wbtag[wbi])",
          "12374:     if (tag == 64019)",
          "12375:       width = getint(type);",
          "12376:     if (tag == 64020)",
          "12377:       height = (getint(type) + 1) & -2;",
          "12378:     fseek(ifp, save, SEEK_SET);",
          "12382: void CLASS parse_kodak_ifd(int base)",
          "12385:   int i, c, wbi = -2, wbtemp = 6500;",
          "12386:   float mul[3] = {1, 1, 1}, num;",
          "12387:   static const int wbtag[] = {64037, 64040, 64039, 64041, -1, -1, 64042};",
          "12390:   if (entries > 1024)",
          "12391:     return;",
          "12392:   while (entries--)",
          "12393:   {",
          "12394:     tiff_get(base, &tag, &type, &len, &save);",
          "12395:     if (tag == 1020)",
          "12396:       wbi = getint(type);",
          "12397:     if (tag == 1021 && len == 72)",
          "12399:       fseek(ifp, 40, SEEK_CUR);",
          "12400:       FORC3 cam_mul[c] = 2048.0 / fMAX(1.0, get2());",
          "12403:     if (tag == 2118)",
          "12404:       wbtemp = getint(type);",
          "12406:       FORC3 cam_mul[c] = 2048.0 / fMAX(1.0, getreal(type));",
          "12410:       FORC3",
          "12411:       {",
          "12412:         for (num = i = 0; i < 4; i++)",
          "12413:           num += getreal(type) * pow(wbtemp / 100.0, i);",
          "12414:         cam_mul[c] = 2048 / fMAX(1.0, (num * mul[c]));",
          "12415:       }",
          "12416:     if (tag == 2317)",
          "12417:       linear_table(len);",
          "12418:     if (tag == 6020)",
          "12419:       iso_speed = getint(type);",
          "12420:     if (tag == 64013)",
          "12421:       wbi = fgetc(ifp);",
          "12422:     if ((unsigned)wbi < 7 && tag == wbtag[wbi])",
          "12424:     if (tag == 64019)",
          "12425:       width = getint(type);",
          "12426:     if (tag == 64020)",
          "12427:       height = (getint(type) + 1) & -2;",
          "12428:     fseek(ifp, save, SEEK_SET);",
          "12434: void CLASS parse_minolta(int base);",
          "12435: int CLASS parse_tiff(int base);",
          "12438: int CLASS parse_tiff_ifd(int base)",
          "12440:   unsigned entries, tag, type, len, plen = 16, save;",
          "12441:   int ifd, use_cm = 0, cfa, i, j, c, ima_len = 0;",
          "12443:   uchar cfa_pat[16], cfa_pc[] = {0, 1, 2, 3}, tab[256];",
          "12445:   double ab[] = {1, 1, 1, 1}, asn[] = {0, 0, 0, 0}, xyz[] = {1, 1, 1};",
          "12446:   unsigned sony_curve[] = {0, 0, 0, 0, 0, 4095};",
          "12447:   unsigned *buf, sony_offset = 0, sony_length = 0, sony_key = 0;",
          "",
          "---------------",
          "--- Hunk 103 ---",
          "[Context before]",
          "11342:   if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])",
          "11343:     return 1;",
          "11344:   ifd = tiff_nifds++;",
          "11347:       cc[j][i] = i == j;",
          "11348:   entries = get2();",
          "11350: #ifdef LIBRAW_LIBRARY_BUILD",
          "11351:   INT64 fsize = ifp->size();",
          "11352: #endif",
          "11355: #ifdef LIBRAW_LIBRARY_BUILD",
          "11356:     INT64 savepos = ftell(ifp);",
          "11465: #endif",
          "11469: #ifdef LIBRAW_LIBRARY_BUILD",
          "11472: #endif",
          "11473:       break;",
          "11475: #ifdef LIBRAW_LIBRARY_BUILD",
          "11480: #endif",
          "11481:       break;",
          "11486: #ifdef LIBRAW_LIBRARY_BUILD",
          "11501:       break;",
          "11502: #endif",
          "11505:       break;",
          "11507: #ifdef LIBRAW_LIBRARY_BUILD",
          "11509:           {",
          "11511:           }",
          "11513: #endif",
          "11514:           {",
          "11517:           }",
          "11725:           {",
          "11729:           }",
          "11730:         break;",
          "11731: #endif",
          "11753: #ifdef LIBRAW_LIBRARY_BUILD",
          "11754:     case 30720: // Sony matrix, Sony_SR2SubIFD_0x7800",
          "11756:         float num = 0.0;",
          "11759:           num += imgdata.color.ccm[i][c];",
          "11760:         }",
          "11762:       }",
          "11763:       break;",
          "11764: #endif",
          "11765:     case 29456: // Sony black level, Sony_SR2SubIFD_0x7310, no more needs to be divided by 4",
          "11772: #ifdef DCRAW_VERBOSE",
          "11807:         break;",
          "11819: #ifdef LIBRAW_LIBRARY_BUILD",
          "11822:       imgdata.lens.FocalLengthIn35mmFormat = get2();",
          "11823:       break;",
          "11825:     case 0xc62f:",
          "11826:       stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "11827:       break;",
          "11833:       break;",
          "11836:       break;",
          "11842:       break;",
          "11845:       break;",
          "11850:       break;",
          "11853:       break;",
          "11855: #endif",
          "11885: #ifdef LIBRAW_LIBRARY_BUILD",
          "11888: #endif",
          "12107:                 {",
          "12131:     }",
          "12132:     break;",
          "12133: #endif",
          "12135: #ifdef LIBRAW_LIBRARY_BUILD",
          "12138:       break;",
          "12139: #endif",
          "12144: #ifdef LIBRAW_LIBRARY_BUILD",
          "12155: #endif",
          "12158: #ifdef LIBRAW_LIBRARY_BUILD",
          "12160: #endif",
          "12172: #ifdef LIBRAW_LIBRARY_BUILD",
          "12181: #endif",
          "12183:       break;",
          "12189: #ifdef LIBRAW_LIBRARY_BUILD",
          "12191: #endif",
          "12194: #ifdef LIBRAW_LIBRARY_BUILD",
          "12196: #endif",
          "12198: #ifdef LIBRAW_LIBRARY_BUILD",
          "12202: #endif",
          "12210: #ifdef LIBRAW_LIBRARY_BUILD",
          "12217: #endif",
          "12220: #ifdef LIBRAW_LIBRARY_BUILD",
          "12222: #endif",
          "12225: #ifdef LIBRAW_LIBRARY_BUILD",
          "12227: #endif",
          "12235: #ifdef LIBRAW_LIBRARY_BUILD",
          "12237: #endif",
          "12241: #ifdef LIBRAW_LIBRARY_BUILD",
          "12243: #endif",
          "12244:               fm[j][c] = getreal(type);",
          "12250: #ifdef LIBRAW_LIBRARY_BUILD",
          "12252: #endif",
          "12256: #ifdef LIBRAW_LIBRARY_BUILD",
          "12258: #endif",
          "12259:               cc[i][c] = getreal(type);",
          "12283: #endif",
          "12286: #ifdef LIBRAW_LIBRARY_BUILD",
          "12287:       {",
          "12316:           {",
          "12325:           }",
          "12329:       }",
          "12331: #endif",
          "12336:       break;",
          "12337:     case 50752:",
          "12339:       break;",
          "12341:       top_margin = getint(type);",
          "12342:       left_margin = getint(type);",
          "12343:       height = getint(type) - top_margin;",
          "12344:       width = getint(type) - left_margin;",
          "12345:       break;",
          "12349:       black = 0;",
          "12350:       break;",
          "12352:       meta_offset = ftell(ifp);",
          "12353:       break;",
          "12357:       data_offset = get4();",
          "12359:       data_offset += get4();",
          "12360:       load_raw = &CLASS packed_load_raw;",
          "12361:       break;",
          "12362:     case 65026:",
          "12364:     }",
          "12366:   }",
          "12371: #ifndef LIBRAW_LIBRARY_BUILD",
          "12372:     sfp = ifp;",
          "12378:     }",
          "12379:     ifp = sfp;",
          "12380: #else",
          "12386: #endif",
          "12388:   }",
          "12390:     FORCC cc[i][c] *= ab[i];",
          "12396:   }",
          "12398:     cam_mul[3] = 0;",
          "12399:     FORCC cam_mul[c] = 1 / asn[c];",
          "12400:   }",
          "",
          "[Removed Lines]",
          "11345:   for (j=0; j < 4; j++)",
          "11346:     for (i=0; i < 4; i++)",
          "11349:   if (entries > 512) return 1;",
          "11353:   while (entries--) {",
          "11354:     tiff_get (base, &tag, &type, &len, &save);",
          "11357:     if(len > 8 && len + savepos > fsize*2) continue; // skip tag pointing out of 2xfile",
          "11358:     if(callbacks.exif_cb)",
          "11359:       {",
          "11360:         callbacks.exif_cb(callbacks.exifparser_data,tag|(pana_raw?0x30000:0),type,len,order,ifp);",
          "11361:         fseek(ifp,savepos,SEEK_SET);",
          "11362:       }",
          "11363: #endif",
          "11365: #ifdef LIBRAW_LIBRARY_BUILD",
          "11366:   if (!strncasecmp(make, \"SONY\", 4) ||",
          "11367:       (!strncasecmp(make, \"Hasselblad\", 10) &&",
          "11368:         (!strncasecmp(model, \"Stellar\", 7) ||",
          "11369:          !strncasecmp(model, \"Lunar\", 5) ||",
          "11370:          !strncasecmp(model, \"HV\",2))))",
          "11371:   {",
          "11372:    switch (tag) {",
          "11373:  case 0x7300: // SR2 black level",
          "11374:      for (int i = 0; i < 4 && i < len; i++)",
          "11375:        cblack[i] = get2();",
          "11376:    break;",
          "11377:  case 0x7480:",
          "11378:  case 0x7820:",
          "11379:      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get2();",
          "11380:      imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];",
          "11381:  break;",
          "11382:  case 0x7481:",
          "11383:  case 0x7821:",
          "11384:      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c] = get2();",
          "11385:      imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1];",
          "11386:  break;",
          "11387:  case 0x7482:",
          "11388:  case 0x7822:",
          "11389:      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get2();",
          "11390:      imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];",
          "11391:  break;",
          "11392:  case 0x7483:",
          "11393:  case 0x7823:",
          "11394:      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c] = get2();",
          "11395:      imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1];",
          "11396:  break;",
          "11397:  case 0x7484:",
          "11398:  case 0x7824:",
          "11399:      imgdata.color.WBCT_Coeffs[0][0] = 4500;",
          "11400:      FORC3 imgdata.color.WBCT_Coeffs[0][c+1] = get2();",
          "11401:      imgdata.color.WBCT_Coeffs[0][4] = imgdata.color.WBCT_Coeffs[0][2];",
          "11402:  break;",
          "11403:  case 0x7486:",
          "11404:                 FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get2();",
          "11405:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];",
          "11406:  break;",
          "11407:  case 0x7825:",
          "11408:                 FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get2();",
          "11409:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];",
          "11410:  break;",
          "11411:  case 0x7826:",
          "11412:                 FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c] = get2();",
          "11413:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1];",
          "11414:  break;",
          "11415:  case 0x7827:",
          "11416:                 FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c] = get2();",
          "11417:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1];",
          "11418:  break;",
          "11419:  case 0x7828:",
          "11420:                 FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c] = get2();",
          "11421:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1];",
          "11422:  break;",
          "11423:  case 0x7829:",
          "11424:                 FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c] = get2();",
          "11425:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1];",
          "11426:  break;",
          "11427:  case 0x782a:",
          "11428:      imgdata.color.WBCT_Coeffs[1][0] = 8500;",
          "11429:      FORC3 imgdata.color.WBCT_Coeffs[1][c+1] = get2();",
          "11430:      imgdata.color.WBCT_Coeffs[1][4] = imgdata.color.WBCT_Coeffs[1][2];",
          "11431:  break;",
          "11432:  case 0x782b:",
          "11433:      imgdata.color.WBCT_Coeffs[2][0] = 6000;",
          "11434:      FORC3 imgdata.color.WBCT_Coeffs[2][c+1] = get2();",
          "11435:      imgdata.color.WBCT_Coeffs[2][4] = imgdata.color.WBCT_Coeffs[2][2];",
          "11436:  break;",
          "11437:  case 0x782c:",
          "11438:      imgdata.color.WBCT_Coeffs[3][0] = 3200;",
          "11439:                 FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][c] = imgdata.color.WBCT_Coeffs[3][c+1] = get2();",
          "11440:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][3] = imgdata.color.WBCT_Coeffs[3][4] = imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][1];",
          "11441:  break;",
          "11442:  case 0x782d:",
          "11443:      imgdata.color.WBCT_Coeffs[4][0] = 2500;",
          "11444:      FORC3 imgdata.color.WBCT_Coeffs[4][c+1] = get2();",
          "11445:      imgdata.color.WBCT_Coeffs[4][4] = imgdata.color.WBCT_Coeffs[4][2];",
          "11446:  break;",
          "11447:  case 0x787f:",
          "11448:      FORC3 imgdata.color.linear_max[c] = get2();",
          "11449:      imgdata.color.linear_max[3] = imgdata.color.linear_max[1];",
          "11450:  break;",
          "11451:  }",
          "11452:   }",
          "11453: #endif",
          "11456:     switch (tag) {",
          "11457:       case 1:   if(len==4) pana_raw = get4(); break;",
          "11458:       case 5:   width  = get2();  break;",
          "11459:       case 6:   height = get2();  break;",
          "11460:       case 7:   width += get2();  break;",
          "11461:       case 9:   if ((i = get2())) filters = i;",
          "11462: #ifdef LIBRAW_LIBRARY_BUILD",
          "11463:         if(pana_raw && len == 1 && type ==3)",
          "11464:           pana_black[3]+=i;",
          "11466:       break;",
          "11467:       case 8:",
          "11468:       case 10:",
          "11470:         if(pana_raw && len == 1 && type ==3)",
          "11471:           pana_black[3]+=get2();",
          "11474:       case 14: case 15: case 16:",
          "11476:         if(pana_raw) {",
          "11477:           imgdata.color.linear_max[tag-14] = get2();",
          "11478:           if (tag == 15 ) imgdata.color.linear_max[3] = imgdata.color.linear_max[1];",
          "11479:         }",
          "11482:       case 17: case 18:",
          "11483:  if (type == 3 && len == 1)",
          "11484:    cam_mul[(tag-17)*2] = get2() / 256.0;",
          "11485:  break;",
          "11487:       case 19:",
          "11488:  if(pana_raw) {",
          "11489:    ushort nWB, cnt, tWB;",
          "11490:    nWB = get2();",
          "11491:    if (nWB > 0x100) break;",
          "11492:    for (cnt=0; cnt<nWB; cnt++) {",
          "11493:      tWB = get2();",
          "11494:      if (tWB < 0x100) {",
          "11495:        imgdata.color.WB_Coeffs[tWB][0] = get2();",
          "11496:        imgdata.color.WB_Coeffs[tWB][2] = get2();",
          "11497:        imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = 0x100;",
          "11498:      } else get4();",
          "11499:    }",
          "11500:  }",
          "11503:       case 23:",
          "11504:  if (type == 3) iso_speed = get2();",
          "11506:       case 28: case 29: case 30:",
          "11508:         if(pana_raw && len == 1 && type ==3)",
          "11510:             pana_black[tag-28] = get2();",
          "11512:         else",
          "11515:       cblack[tag-28] = get2();",
          "11516:       cblack[3] = cblack[1];",
          "11518:  break;",
          "11519:       case 36: case 37: case 38:",
          "11520:  cam_mul[tag-36] = get2();",
          "11521:  break;",
          "11522:       case 39:",
          "11523: #ifdef LIBRAW_LIBRARY_BUILD",
          "11524:  if(pana_raw) {",
          "11525:      ushort nWB, cnt, tWB;",
          "11526:      nWB = get2();",
          "11527:      if (nWB > 0x100) break;",
          "11528:      for (cnt=0; cnt<nWB; cnt++) {",
          "11529:          tWB = get2();",
          "11530:          if (tWB < 0x100) {",
          "11531:              imgdata.color.WB_Coeffs[tWB][0] = get2();",
          "11532:              imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = get2();",
          "11533:              imgdata.color.WB_Coeffs[tWB][2] = get2();",
          "11534:          } else fseek(ifp, 6, SEEK_CUR);",
          "11535:      }",
          "11536:  }",
          "11537:  break;",
          "11538: #endif",
          "11539:  if (len < 50 || cam_mul[0]) break;",
          "11540:  fseek (ifp, 12, SEEK_CUR);",
          "11541:  FORC3 cam_mul[c] = get2();",
          "11542:  break;",
          "11543:       case 46:",
          "11544:  if (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) break;",
          "11545:  thumb_offset = ftell(ifp) - 2;",
          "11546:  thumb_length = len;",
          "11547:  break;",
          "11549:  fseek (ifp, get4()+base, SEEK_SET);",
          "11550:  parse_tiff_ifd (base);",
          "11551:  break;",
          "11553:  tiff_ifd[ifd].t_width = getint(type);",
          "11554:  break;",
          "11556:  tiff_ifd[ifd].t_height = getint(type);",
          "11557:  break;",
          "11559:       case 61443:",
          "11560:  tiff_ifd[ifd].samples = len & 7;",
          "11561:  tiff_ifd[ifd].bps = getint(type);",
          "11562:  if (tiff_bps < tiff_ifd[ifd].bps)",
          "11563:      tiff_bps = tiff_ifd[ifd].bps;",
          "11564:  break;",
          "11565:       case 61446:",
          "11566:  raw_height = 0;",
          "11567:  if (tiff_ifd[ifd].bps > 12) break;",
          "11568:  load_raw = &CLASS packed_load_raw;",
          "11569:  load_flags = get4() ? 24:80;",
          "11570:  break;",
          "11572:  tiff_ifd[ifd].comp = getint(type);",
          "11573:  break;",
          "11575:  tiff_ifd[ifd].phint = get2();",
          "11576:  break;",
          "11578:  fread (desc, 512, 1, ifp);",
          "11579:  break;",
          "11581:  fgets (make, 64, ifp);",
          "11582:  break;",
          "11584:  fgets (model, 64, ifp);",
          "11585:  break;",
          "11586: #ifdef LIBRAW_LIBRARY_BUILD",
          "11587:       case 278:",
          "11588:  tiff_ifd[ifd].rows_per_strip = getint(type);",
          "11589:  break;",
          "11590: #endif",
          "11592:  if (type != 4) break;",
          "11593:  load_raw = &CLASS panasonic_load_raw;",
          "11594:  load_flags = 0x2008;",
          "11596: #ifdef LIBRAW_LIBRARY_BUILD",
          "11597:  if(len > 1 && len < 16384)",
          "11598:    {",
          "11599:      off_t sav = ftell(ifp);",
          "11600:      tiff_ifd[ifd].strip_offsets = (int*)calloc(len,sizeof(int));",
          "11601:      tiff_ifd[ifd].strip_offsets_count = len;",
          "11602:      for(int i=0; i< len; i++)",
          "11603:        tiff_ifd[ifd].strip_offsets[i]=get4()+base;",
          "11604:      fseek(ifp,sav,SEEK_SET); // restore position",
          "11605:    }",
          "11607: #endif",
          "11609:       case 61447:",
          "11610:  tiff_ifd[ifd].offset = get4()+base;",
          "11611:  if (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0) {",
          "11612:    fseek (ifp, tiff_ifd[ifd].offset, SEEK_SET);",
          "11613:    if (ljpeg_start (&jh, 1)) {",
          "11614:      tiff_ifd[ifd].comp    = 6;",
          "11615:      tiff_ifd[ifd].t_width   = jh.wide;",
          "11616:      tiff_ifd[ifd].t_height  = jh.high;",
          "11617:      tiff_ifd[ifd].bps     = jh.bits;",
          "11618:      tiff_ifd[ifd].samples = jh.clrs;",
          "11619:      if (!(jh.sraw || (jh.clrs & 1)))",
          "11620:        tiff_ifd[ifd].t_width *= jh.clrs;",
          "11621:      if ((tiff_ifd[ifd].t_width > 4*tiff_ifd[ifd].t_height) & ~jh.clrs) {",
          "11622:        tiff_ifd[ifd].t_width  /= 2;",
          "11623:        tiff_ifd[ifd].t_height *= 2;",
          "11624:      }",
          "11625:      i = order;",
          "11626:      parse_tiff (tiff_ifd[ifd].offset + 12);",
          "11627:      order = i;",
          "11628:    }",
          "11629:  }",
          "11630:  break;",
          "11632:  tiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7]-'0';",
          "11633:  break;",
          "11635:  tiff_ifd[ifd].samples = getint(type) & 7;",
          "11636:  break;",
          "11638: #ifdef LIBRAW_LIBRARY_BUILD",
          "11639:  if(len > 1 && len < 16384)",
          "11640:    {",
          "11641:      off_t sav = ftell(ifp);",
          "11642:      tiff_ifd[ifd].strip_byte_counts = (int*)calloc(len,sizeof(int));",
          "11643:      tiff_ifd[ifd].strip_byte_counts_count = len;",
          "11644:      for(int i=0; i< len; i++)",
          "11645:   tiff_ifd[ifd].strip_byte_counts[i]=get4();",
          "11646:      fseek(ifp,sav,SEEK_SET); // restore position",
          "11647:    }",
          "11649: #endif",
          "11650:       case 514:",
          "11651:       case 61448:",
          "11652:  tiff_ifd[ifd].bytes = get4();",
          "11653:  break;",
          "11654:       case 61454:",
          "11655:  FORC3 cam_mul[(4-c) % 3] = getint(type);",
          "11656:  break;",
          "11658:  fgets (software, 64, ifp);",
          "11659:  if (!strncmp(software,\"Adobe\",5) ||",
          "11660:      !strncmp(software,\"dcraw\",5) ||",
          "11661:      !strncmp(software,\"UFRaw\",5) ||",
          "11662:      !strncmp(software,\"Bibble\",6) ||",
          "11663:      !strcmp (software,\"Digital Photo Professional\"))",
          "11664:    is_raw = 0;",
          "11665:  break;",
          "11667:  get_timestamp(0);",
          "11668:  break;",
          "11670:  fread (artist, 64, 1, ifp);",
          "11671:  break;",
          "11672:       case 317:",
          "11673:  tiff_ifd[ifd].predictor = getint(type);",
          "11674:  break;",
          "11676:  tiff_ifd[ifd].t_tile_width = getint(type);",
          "11677:  break;",
          "11679:  tiff_ifd[ifd].t_tile_length = getint(type);",
          "11680:  break;",
          "11682:  tiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();",
          "11683:  if (len == 1)",
          "11684:    tiff_ifd[ifd].t_tile_width = tiff_ifd[ifd].t_tile_length = 0;",
          "11685:  if (len == 4) {",
          "11686:    load_raw = &CLASS sinar_4shot_load_raw;",
          "11687:    is_raw = 5;",
          "11688:  }",
          "11689:  break;",
          "11690:       case 325:",
          "11691:  tiff_ifd[ifd].bytes = len > 1 ? ftell(ifp): get4();",
          "11692:  break;",
          "11694:  if (!strcmp(model,\"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872) {",
          "11695:    load_raw = &CLASS sony_arw_load_raw;",
          "11696:    data_offset = get4()+base;",
          "11697:    ifd++;  break;",
          "11698:  }",
          "11699: #ifdef LIBRAW_LIBRARY_BUILD",
          "11700:  if (!strncmp(make,\"Hasselblad\",10) && libraw_internal_data.unpacker_data.hasselblad_parser_flag) {",
          "11701:           fseek (ifp, ftell(ifp)+4, SEEK_SET);",
          "11702:           fseek (ifp, get4()+base, SEEK_SET);",
          "11703:           parse_tiff_ifd (base);",
          "11704:           break;",
          "11705:  }",
          "11706: #endif",
          "11708:  while (len--) {",
          "11709:    i = ftell(ifp);",
          "11710:    fseek (ifp, get4()+base, SEEK_SET);",
          "11711:    if (parse_tiff_ifd (base)) break;",
          "11712:    fseek (ifp, i+4, SEEK_SET);",
          "11713:  }",
          "11714:  break;",
          "11715:       case 339:",
          "11716:  tiff_ifd[ifd].sample_format = getint(type);",
          "11717:  break;",
          "11718:       case 400:",
          "11719:  strcpy (make, \"Sarnoff\");",
          "11720:  maximum = 0xfff;",
          "11721:  break;",
          "11722: #ifdef LIBRAW_LIBRARY_BUILD",
          "11723:       case 700:",
          "11724:         if((type == 1 || type == 2 || type == 6 || type == 7) && len > 1 && len < 5100000)",
          "11726:             xmpdata = (char*)malloc(xmplen = len+1);",
          "11727:             fread(xmpdata,len,1,ifp);",
          "11728:             xmpdata[len]=0;",
          "11732:       case 28688:",
          "11733:  FORC4 sony_curve[c+1] = get2() >> 2 & 0xfff;",
          "11734:  for (i=0; i < 5; i++)",
          "11735:    for (j = sony_curve[i]+1; j <= sony_curve[i+1]; j++)",
          "11736:      curve[j] = curve[j-1] + (1 << i);",
          "11737:  break;",
          "11738:       case 29184: sony_offset = get4();  break;",
          "11739:       case 29185: sony_length = get4();  break;",
          "11740:       case 29217: sony_key    = get4();  break;",
          "11741:       case 29264:",
          "11742:  parse_minolta (ftell(ifp));",
          "11743:  raw_width = 0;",
          "11744:  break;",
          "11745:       case 29443:",
          "11746:  FORC4 cam_mul[c ^ (c < 2)] = get2();",
          "11747:  break;",
          "11748:       case 29459:",
          "11749:  FORC4 cam_mul[c] = get2();",
          "11750:  i = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;",
          "11751:  SWAP (cam_mul[i],cam_mul[i+1])",
          "11752:  break;",
          "11755:       for (i=0; i < 3; i++) {",
          "11757:         for (c=0; c<3; c++) {",
          "11758:           imgdata.color.ccm[i][c] = (float) ((short)get2());",
          "11761:         if (num > 0.01) FORC3 imgdata.color.ccm[i][c] = imgdata.color.ccm[i][c] / num;",
          "11766:    FORC4 cblack[c ^ c >> 1] = get2();",
          "11767:    i = cblack[3];",
          "11768:    FORC3 if(i>cblack[c]) i = cblack[c];",
          "11769:    FORC4 cblack[c]-=i;",
          "11770:    black = i;",
          "11773:       if (verbose) fprintf (stderr, _(\"...Sony black: %u cblack: %u %u %u %u\\n\"),black, cblack[0],cblack[1],cblack[2], cblack[3]);",
          "11774: #endif",
          "11775:       break;",
          "11777:  fgets (model2, 64, ifp);",
          "11778:  break;",
          "11780:  if (get2() == 6 && get2() == 6)",
          "11781:    filters = 9;",
          "11782:  break;",
          "11784:  if (filters == 9) {",
          "11785:    FORC(36) ((char *)xtrans)[c] = fgetc(ifp) & 3;",
          "11786:    break;",
          "11787:  }",
          "11789:         if(len == 36)",
          "11790:           {",
          "11791:             filters = 9;",
          "11792:             colors = 3;",
          "11793:             FORC(36) xtrans[0][c] = fgetc(ifp) & 3;",
          "11794:           }",
          "11795:         else if(len > 0)",
          "11796:           {",
          "11797:             if ((plen=len) > 16) plen = 16;",
          "11798:             fread (cfa_pat, 1, plen, ifp);",
          "11799:             for (colors=cfa=i=0; i < plen && colors < 4; i++) {",
          "11800:               colors += !(cfa & (1 << cfa_pat[i]));",
          "11801:               cfa |= 1 << cfa_pat[i];",
          "11802:             }",
          "11805:             goto guess_cfa_pc;",
          "11806:           }",
          "11808:       case 33424:",
          "11809:       case 65024:",
          "11810:  fseek (ifp, get4()+base, SEEK_SET);",
          "11811:  parse_kodak_ifd (base);",
          "11812:  break;",
          "11814:  tiff_ifd[ifd].t_shutter = shutter = getreal(type);",
          "11815:  break;",
          "11817:  aperture = getreal(type);",
          "11818:  break;",
          "11821:     case 0xa405:  // FocalLengthIn35mmFormat",
          "11824:     case 0xa431:  // BodySerialNumber",
          "11828:     case 0xa432:  // LensInfo, 42034dec, Lens Specification per EXIF standard",
          "11829:       imgdata.lens.MinFocal = getreal(type);",
          "11830:       imgdata.lens.MaxFocal = getreal(type);",
          "11831:       imgdata.lens.MaxAp4MinFocal = getreal(type);",
          "11832:       imgdata.lens.MaxAp4MaxFocal = getreal(type);",
          "11834:     case 0xa435:  // LensSerialNumber",
          "11835:       stmread(imgdata.lens.LensSerial, len, ifp);",
          "11837:     case 0xc630:  // DNG LensInfo, Lens Specification per EXIF standard",
          "11838:       imgdata.lens.MinFocal = getreal(type);",
          "11839:       imgdata.lens.MaxFocal = getreal(type);",
          "11840:       imgdata.lens.MaxAp4MinFocal = getreal(type);",
          "11841:       imgdata.lens.MaxAp4MaxFocal = getreal(type);",
          "11843:     case 0xa433:  // LensMake",
          "11844:       stmread(imgdata.lens.LensMake, len, ifp);",
          "11846:     case 0xa434:  // LensModel",
          "11847:       stmread(imgdata.lens.Lens, len, ifp);",
          "11848:       if (!strncmp(imgdata.lens.Lens, \"----\", 4))",
          "11849:         imgdata.lens.Lens[0] = 0;",
          "11851:     case 0x9205:",
          "11852:       imgdata.lens.EXIF_MaxAp = powf64(2.0f, (getreal(type) / 2.0f));",
          "11857:  FORC4 cam_mul[c ^ 1] = 4096.0 / get2();",
          "11858:  break;",
          "11860:  fread (software, 1, 7, ifp);",
          "11861:  if (strncmp(software,\"MATRIX\",6)) break;",
          "11862:  colors = 4;",
          "11863:  for (raw_color = i=0; i < 3; i++) {",
          "11864:    FORC4 fscanf (ifp, \"%f\", &rgb_cam[i][c^1]);",
          "11865:    if (!use_camera_wb) continue;",
          "11866:    num = 0;",
          "11867:    FORC4 num += rgb_cam[i][c];",
          "11868:    FORC4 rgb_cam[i][c] /= MAX(1,num);",
          "11869:  }",
          "11870:  break;",
          "11872:  parse_mos (ftell(ifp));",
          "11873:       case 34303:",
          "11874:  strcpy (make, \"Leaf\");",
          "11875:  break;",
          "11877:  fseek (ifp, get4()+base, SEEK_SET);",
          "11878:  parse_exif (base);",
          "11879:  break;",
          "11881:         {",
          "11882:           unsigned pos;",
          "11883:           fseek(ifp, pos = (get4() + base), SEEK_SET);",
          "11884:           parse_gps(base);",
          "11886:           fseek(ifp, pos, SEEK_SET);",
          "11887:           parse_gps_libraw(base);",
          "11889:         }",
          "11890:  break;",
          "11893:  profile_offset = ftell(ifp);",
          "11894:  profile_length = len;",
          "11895:  break;",
          "11897:  kodak_cbpp = get4();",
          "11898:  break;",
          "11900:  focal_len = getreal(type);",
          "11901:  break;",
          "11903:  shot_order = getint(type);",
          "11904:  break;",
          "11906:  for (raw_color = i=0; i < 3; i++) {",
          "11907:    getreal(type);",
          "11908:    FORC3 rgb_cam[i][c] = getreal(type);",
          "11909:  }",
          "11910:  break;",
          "11911:       case 40976:",
          "11912:  strip_offset = get4();",
          "11913:  switch (tiff_ifd[ifd].comp) {",
          "11914:    case 32770: load_raw = &CLASS samsung_load_raw;   break;",
          "11915:    case 32772: load_raw = &CLASS samsung2_load_raw;  break;",
          "11916:    case 32773: load_raw = &CLASS samsung3_load_raw;  break;",
          "11917:  }",
          "11918:  break;",
          "11920:  strcpy (make, \"Imacon\");",
          "11921:  data_offset = ftell(ifp);",
          "11922:  ima_len = len;",
          "11923:  break;",
          "11924:       case 46279:",
          "11925:  if (!ima_len) break;",
          "11926:  fseek (ifp, 38, SEEK_CUR);",
          "11927:       case 46274:",
          "11928:  fseek (ifp, 40, SEEK_CUR);",
          "11929:  raw_width  = get4();",
          "11930:  raw_height = get4();",
          "11931:  left_margin = get4() & 7;",
          "11932:  width = raw_width - left_margin - (get4() & 7);",
          "11933:  top_margin = get4() & 7;",
          "11934:  height = raw_height - top_margin - (get4() & 7);",
          "11935:  if (raw_width == 7262 && ima_len == 234317952 ) {",
          "11936:    height = 5412;",
          "11937:    width  = 7216;",
          "11938:    left_margin = 7;",
          "11939:           filters=0;",
          "11940:  } else  if (raw_width == 7262) {",
          "11941:    height = 5444;",
          "11942:    width  = 7244;",
          "11943:    left_margin = 7;",
          "11944:  }",
          "11945:  fseek (ifp, 52, SEEK_CUR);",
          "11946:  FORC3 cam_mul[c] = getreal(11);",
          "11947:  fseek (ifp, 114, SEEK_CUR);",
          "11948:  flip = (get2() >> 7) * 90;",
          "11949:  if (width * height * 6 == ima_len) {",
          "11950:    if (flip % 180 == 90) SWAP(width,height);",
          "11951:    raw_width = width;",
          "11952:    raw_height = height;",
          "11953:    left_margin = top_margin = filters = flip = 0;",
          "11954:  }",
          "11955:  sprintf (model, \"Ixpress %d-Mp\", height*width/1000000);",
          "11956:  load_raw = &CLASS imacon_full_load_raw;",
          "11957:  if (filters) {",
          "11958:    if (left_margin & 1) filters = 0x61616161;",
          "11959:    load_raw = &CLASS unpacked_load_raw;",
          "11960:  }",
          "11961:  maximum = 0xffff;",
          "11962:  break;",
          "11964:       case 50455:",
          "11965:  if (len > 2560000 || !(cbuf = (char *) malloc(len))) break;",
          "11966: #ifndef LIBRAW_LIBRARY_BUILD",
          "11967:  fread (cbuf, 1, len, ifp);",
          "11968: #else",
          "11969:  if(fread (cbuf, 1, len, ifp) != len)",
          "11970:   throw LIBRAW_EXCEPTION_IO_CORRUPT; // cbuf to be free'ed in recycle",
          "11971: #endif",
          "11972:         cbuf[len-1] = 0;",
          "11973:  for (cp = cbuf-1; cp && cp < cbuf+len; cp = strchr(cp,'\\n'))",
          "11974:    if (!strncmp (++cp,\"Neutral \",8))",
          "11975:      sscanf (cp+8, \"%f %f %f\", cam_mul, cam_mul+1, cam_mul+2);",
          "11976:  free (cbuf);",
          "11977:  break;",
          "11978:       case 50458:",
          "11979:  if (!make[0]) strcpy (make, \"Hasselblad\");",
          "11980:  break;",
          "11982: #ifdef LIBRAW_LIBRARY_BUILD",
          "11983:         libraw_internal_data.unpacker_data.hasselblad_parser_flag=1;",
          "11984: #endif",
          "11985:  i = order;",
          "11986:  j = ftell(ifp);",
          "11987:  c = tiff_nifds;",
          "11988:  order = get2();",
          "11989:  fseek (ifp, j+(get2(),get4()), SEEK_SET);",
          "11990:  parse_tiff_ifd (j);",
          "11991:  maximum = 0xffff;",
          "11992:  tiff_nifds = c;",
          "11993:  order = i;",
          "11994:  break;",
          "11996:  FORC4 dng_version = (dng_version << 8) + fgetc(ifp);",
          "11997:  if (!make[0]) strcpy (make, \"DNG\");",
          "11998:  is_raw = 1;",
          "11999:  break;",
          "12001: #ifdef LIBRAW_LIBRARY_BUILD",
          "12002:         stmread(imgdata.color.UniqueCameraModel, len, ifp);",
          "12003:         imgdata.color.UniqueCameraModel[sizeof(imgdata.color.UniqueCameraModel)-1] = 0;",
          "12004: #endif",
          "12005:  if (model[0]) break;",
          "12006: #ifndef LIBRAW_LIBRARY_BUILD",
          "12007:  fgets (make, 64, ifp);",
          "12008: #else",
          "12009:         strncpy (make, imgdata.color.UniqueCameraModel, MIN(len, sizeof(imgdata.color.UniqueCameraModel)));",
          "12010: #endif",
          "12011:  if ((cp = strchr(make,' '))) {",
          "12012:    strcpy(model,cp+1);",
          "12014:  }",
          "12015:  break;",
          "12017:  if (filters == 9) break;",
          "12018:  if (len > 4) len = 4;",
          "12019:  colors = len;",
          "12020:  fread (cfa_pc, 1, colors, ifp);",
          "12021: guess_cfa_pc:",
          "12022:         FORCC tab[cfa_pc[c]] = c;",
          "12023:         cdesc[c] = 0;",
          "12024:         for (i=16; i--; )",
          "12025:           filters = filters << 2 | tab[cfa_pat[i % plen]];",
          "12026:         filters -= !filters;",
          "12027:  break;",
          "12029:  if (get2() == 2) fuji_width = 1;",
          "12030:  break;",
          "12031:       case 291:",
          "12033:  linear_table (len);",
          "12034:  break;",
          "12036: #ifdef LIBRAW_LIBRARY_BUILD",
          "12037:         imgdata.color.dng_levels.dng_cblack[4] =",
          "12038: #endif",
          "12039:  cblack[4] = get2();",
          "12040: #ifdef LIBRAW_LIBRARY_BUILD",
          "12041:         imgdata.color.dng_levels.dng_cblack[5] =",
          "12042: #endif",
          "12043:  cblack[5] = get2();",
          "12044:  if (cblack[4] * cblack[5] > (sizeof(cblack) / sizeof (cblack[0]) - 6))",
          "12045: #ifdef LIBRAW_LIBRARY_BUILD",
          "12046:             imgdata.color.dng_levels.dng_cblack[4]=",
          "12047:      imgdata.color.dng_levels.dng_cblack[5]=",
          "12048: #endif",
          "12049:      cblack[4] = cblack[5] = 1;",
          "12050:  break;",
          "12052: #ifdef LIBRAW_LIBRARY_BUILD",
          "12053:  case 0xf00c: {",
          "12054:      unsigned fwb[4];",
          "12055:      FORC4 fwb[c] = get4();",
          "12056:   if (fwb[3] < 0x100)",
          "12057:   {",
          "12058:     imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];",
          "12059:     imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];",
          "12060:     imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];",
          "12061:     if ((fwb[3] == 17) && libraw_internal_data.unpacker_data.lenRAFData>3 && libraw_internal_data.unpacker_data.lenRAFData < 10240000)",
          "12062:     {",
          "12063:       long long f_save = ftell(ifp);",
          "12064:       int fj, found = 0;",
          "12065:       ushort *rafdata = (ushort*) malloc (sizeof(ushort)*libraw_internal_data.unpacker_data.lenRAFData);",
          "12066:       fseek (ifp, libraw_internal_data.unpacker_data.posRAFData, SEEK_SET);",
          "12067:       fread (rafdata, sizeof(ushort), libraw_internal_data.unpacker_data.lenRAFData, ifp);",
          "12068:       fseek(ifp, f_save, SEEK_SET);",
          "12069:       for (int fi=0; fi<(libraw_internal_data.unpacker_data.lenRAFData-3); fi++)",
          "12070:    {",
          "12071:      if ((fwb[0]==rafdata[fi]) && (fwb[1]==rafdata[fi+1]) && (fwb[2]==rafdata[fi+2]))",
          "12072:      {",
          "12073:        if (rafdata[fi-15] != fwb[0]) continue;",
          "12074:        fi = fi - 15;",
          "12075:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][3] = rafdata[fi];",
          "12076:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = rafdata[fi+1];",
          "12077:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = rafdata[fi+2];",
          "12079:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = rafdata[fi+3];",
          "12080:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = rafdata[fi+4];",
          "12081:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = rafdata[fi+5];",
          "12083:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = rafdata[fi+6];",
          "12084:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = rafdata[fi+7];",
          "12085:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = rafdata[fi+8];",
          "12087:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = rafdata[fi+9];",
          "12088:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][0] = rafdata[fi+10];",
          "12089:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][2] = rafdata[fi+11];",
          "12091:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = rafdata[fi+12];",
          "12092:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = rafdata[fi+13];",
          "12093:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = rafdata[fi+14];",
          "12095:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = rafdata[fi+15];",
          "12096:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = rafdata[fi+16];",
          "12097:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = rafdata[fi+17];",
          "12099:                 fi += 111;",
          "12100:                 for (fj = fi; fj<(fi+15); fj+=3)",
          "12101:                   if (rafdata[fj] != rafdata[fi])",
          "12102:                   {",
          "12103:                     found = 1;",
          "12104:                     break;",
          "12105:                   }",
          "12106:                 if (found)",
          "12108:                   int FujiCCT_K [31] = {2500,2550,2650,2700,2800,2850,2950,3000,3100,3200,3300,3400,3600,3700,3800,4000,4200,4300,4500,4800,5000,5300,5600,5900,6300,6700,7100,7700,8300,9100,10000};",
          "12109:                   fj = fj - 93;",
          "12110:                   for (int iCCT=0; iCCT < 31; iCCT++)",
          "12111:                   {",
          "12112:                     imgdata.color.WBCT_Coeffs[iCCT][0] = FujiCCT_K[iCCT];",
          "12113:                     imgdata.color.WBCT_Coeffs[iCCT][1] = rafdata[iCCT*3+1+fj];",
          "12114:                     imgdata.color.WBCT_Coeffs[iCCT][2] = imgdata.color.WBCT_Coeffs[iCCT][4] = rafdata[iCCT*3+fj];",
          "12115:                     imgdata.color.WBCT_Coeffs[iCCT][3] = rafdata[iCCT*3+2+fj];",
          "12116:       }",
          "12117:     }",
          "12118:        free (rafdata);",
          "12119:     break;",
          "12120:      }",
          "12121:    }",
          "12122:     }",
          "12123:   }",
          "12124:   FORC4 fwb[c] = get4();",
          "12125:   if (fwb[3] < 0x100)",
          "12126:   {",
          "12127:     imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];",
          "12128:     imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];",
          "12129:     imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];",
          "12130:   }",
          "12136:       case 50709:",
          "12137:         stmread(imgdata.color.LocalizedCameraModel,len, ifp);",
          "12141:       case 61450:",
          "12142:  cblack[4] = cblack[5] = MIN(sqrt((double)len),64);",
          "12145:  if(tiff_ifd[ifd].samples > 1  && tiff_ifd[ifd].samples == len) // LinearDNG, per-channel black",
          "12146:    {",
          "12147:      for(i=0; i < colors && i < 4 && i < len; i++)",
          "12148:        imgdata.color.dng_levels.dng_cblack[i]=",
          "12149:          cblack[i]=",
          "12150:     getreal(type)+0.5;",
          "12152:      imgdata.color.dng_levels.dng_black= black = 0;",
          "12153:    }",
          "12154:  else",
          "12156:    if((cblack[4] * cblack[5] < 2) && len == 1)",
          "12157:      {",
          "12159:        imgdata.color.dng_levels.dng_black=",
          "12161:          black =",
          "12162:     getreal(type);",
          "12163:      }",
          "12164:    else if(cblack[4] * cblack[5] <= len)",
          "12165:      {",
          "12166:        FORC (cblack[4] * cblack[5])",
          "12167:   cblack[6+c] = getreal(type);",
          "12168:        black = 0;",
          "12169:        FORC4",
          "12170:   cblack[c] = 0;",
          "12173:               if(tag == 50714)",
          "12174:        {",
          "12175:          FORC (cblack[4] * cblack[5])",
          "12176:            imgdata.color.dng_levels.dng_cblack[6+c]= cblack[6+c];",
          "12177:          imgdata.color.dng_levels.dng_black=0;",
          "12178:          FORC4",
          "12179:            imgdata.color.dng_levels.dng_cblack[c]= 0;",
          "12180:        }",
          "12182:      }",
          "12186:  for (num=i=0; i < len && i < 65536; i++)",
          "12187:    num += getreal(type);",
          "12188:  black += num/len + 0.5;",
          "12190:  imgdata.color.dng_levels.dng_black += num/len + 0.5;",
          "12192:  break;",
          "12195:  imgdata.color.dng_levels.dng_whitelevel[0]=",
          "12197:  maximum = getint(type);",
          "12199:  if(tiff_ifd[ifd].samples > 1 ) // Linear DNG case",
          "12200:   for(i=1; i < colors && i < 4 && i < len; i++)",
          "12201:    imgdata.color.dng_levels.dng_whitelevel[i]=getint(type);",
          "12203:  break;",
          "12205:  pixel_aspect  = getreal(type);",
          "12206:  pixel_aspect /= getreal(type);",
          "12207:  if(pixel_aspect > 0.995 && pixel_aspect < 1.005)",
          "12208:           pixel_aspect = 1.0;",
          "12209:  break;",
          "12211:       case 50778:",
          "12212:         imgdata.color.dng_color[0].illuminant = get2();",
          "12213:         break;",
          "12214:       case 50779:",
          "12215:         imgdata.color.dng_color[1].illuminant = get2();",
          "12216:         break;",
          "12221:         i = tag == 50721?0:1;",
          "12223:  FORCC for (j=0; j < 3; j++)",
          "12224:           {",
          "12226:           imgdata.color.dng_color[i].colormatrix[c][j]=",
          "12228:    cm[c][j] = getreal(type);",
          "12229:           }",
          "12230:  use_cm = 1;",
          "12231:  break;",
          "12236:         i = tag == 0xc714?0:1;",
          "12238:  for (j=0; j < 3; j++)",
          "12239:    FORCC",
          "12240:             {",
          "12242:               imgdata.color.dng_color[i].forwardmatrix[j][c]=",
          "12245:             }",
          "12246:  break;",
          "12251:         j = tag == 50723?0:1;",
          "12253:  for (i=0; i < colors; i++)",
          "12254:    FORCC",
          "12255:             {",
          "12257:               imgdata.color.dng_color[j].calibration[i][c]=",
          "12260:             }",
          "12261:  break;",
          "12263:  FORCC{",
          "12264: #ifdef LIBRAW_LIBRARY_BUILD",
          "12265:               imgdata.color.dng_levels.analogbalance[c]=",
          "12266: #endif",
          "12267:        ab[c] = getreal(type);",
          "12268:  }",
          "12269:  break;",
          "12271:  FORCC asn[c] = getreal(type);",
          "12272:  break;",
          "12274:  xyz[0] = getreal(type);",
          "12275:  xyz[1] = getreal(type);",
          "12276:  xyz[2] = 1 - xyz[0] - xyz[1];",
          "12277:  FORC3 xyz[c] /= d65_white[c];",
          "12278:  break;",
          "12279: #ifdef LIBRAW_LIBRARY_BUILD",
          "12281:         baseline_exposure = getreal(type);",
          "12282:         break;",
          "12288:         char mbuf[64];",
          "12289:         unsigned short makernote_found = 0;",
          "12290:         INT64 curr_pos, start_pos = ftell(ifp);",
          "12291:         unsigned MakN_order, m_sorder = order;",
          "12292:         unsigned MakN_length;",
          "12293:         unsigned pos_in_original_raw;",
          "12294:         fread(mbuf, 1, 6, ifp);",
          "12296:         if (!strcmp(mbuf, \"Adobe\"))",
          "12297:           {",
          "12298:             order = 0x4d4d;    // Adobe header is always in \"MM\" / big endian",
          "12299:             curr_pos = start_pos + 6;",
          "12300:             while (curr_pos + 8 - start_pos <= len)",
          "12301:               {",
          "12302:                 fread(mbuf, 1, 4, ifp);",
          "12303:                 curr_pos += 8;",
          "12304:                 if (!strncmp(mbuf, \"MakN\", 4)) {",
          "12305:                   makernote_found = 1;",
          "12306:                 MakN_length = get4();",
          "12307:                 MakN_order = get2();",
          "12308:                 pos_in_original_raw = get4();",
          "12309:                 order = MakN_order;",
          "12310:                 parse_makernote_0xc634(curr_pos + 6 - pos_in_original_raw, 0, AdobeDNG);",
          "12311:                 break;",
          "12312:                 }",
          "12313:               }",
          "12314:           }",
          "12315:         else",
          "12317:             fread(mbuf + 6, 1, 2, ifp);",
          "12318:             if (!strcmp(mbuf, \"PENTAX \") ||",
          "12319:                 !strcmp(mbuf, \"SAMSUNG\"))",
          "12320:               {",
          "12321:                 makernote_found = 1;",
          "12322:                 fseek(ifp, start_pos, SEEK_SET);",
          "12323:                 parse_makernote_0xc634(base, 0, CameraDNG);",
          "12324:               }",
          "12327:         fseek(ifp, start_pos, SEEK_SET);",
          "12328:         order = m_sorder;",
          "12332:       if (dng_version) break;",
          "12333:       parse_minolta (j = get4()+base);",
          "12334:       fseek (ifp, j, SEEK_SET);",
          "12335:       parse_tiff_ifd (base);",
          "12338:       read_shorts (cr2_slice, 3);",
          "12347:       for (i=0; i < len && i < 32; i++)",
          "12348:         ((int*)mask)[i] = getint(type);",
          "12355:       if (len < 13) break;",
          "12356:       fseek (ifp, 16, SEEK_CUR);",
          "12358:       fseek (ifp, 28, SEEK_CUR);",
          "12363:       if (type == 2) fgets (model2, 64, ifp);",
          "12365:     fseek (ifp, save, SEEK_SET);",
          "12367:   if (sony_length && sony_length < 10240000 && (buf = (unsigned *) malloc(sony_length))) {",
          "12368:     fseek (ifp, sony_offset, SEEK_SET);",
          "12369:     fread (buf, sony_length, 1, ifp);",
          "12370:     sony_decrypt (buf, sony_length/4, 1, sony_key);",
          "12373:     if ((ifp = tmpfile())) {",
          "12374:       fwrite (buf, sony_length, 1, ifp);",
          "12375:       fseek (ifp, 0, SEEK_SET);",
          "12376:       parse_tiff_ifd (-sony_offset);",
          "12377:       fclose (ifp);",
          "12381:     if( !ifp->tempbuffer_open(buf,sony_length))",
          "12382:         {",
          "12383:             parse_tiff_ifd(-sony_offset);",
          "12384:             ifp->tempbuffer_close();",
          "12385:         }",
          "12387:     free (buf);",
          "12389:   for (i=0; i < colors; i++)",
          "12391:   if (use_cm) {",
          "12392:     FORCC for (i=0; i < 3; i++)",
          "12393:       for (cam_xyz[c][i]=j=0; j < colors; j++)",
          "12394:  cam_xyz[c][i] += cc[c][j] * cm[j][i] * xyz[i];",
          "12395:     cam_xyz_coeff (cmatrix, cam_xyz);",
          "12397:   if (asn[0]) {",
          "",
          "[Added Lines]",
          "12457:   for (j = 0; j < 4; j++)",
          "12458:     for (i = 0; i < 4; i++)",
          "12461:   if (entries > 512)",
          "12462:     return 1;",
          "12466:   while (entries--)",
          "12467:   {",
          "12468:     tiff_get(base, &tag, &type, &len, &save);",
          "12471:     if (len > 8 && len + savepos > fsize * 2)",
          "12472:       continue; // skip tag pointing out of 2xfile",
          "12473:     if (callbacks.exif_cb)",
          "12474:     {",
          "12475:       callbacks.exif_cb(callbacks.exifparser_data, tag | (pana_raw ? 0x30000 : 0), type, len, order, ifp);",
          "12476:       fseek(ifp, savepos, SEEK_SET);",
          "12477:     }",
          "12481:     if (!strncasecmp(make, \"SONY\", 4) ||",
          "12482:         (!strncasecmp(make, \"Hasselblad\", 10) &&",
          "12483:          (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) || !strncasecmp(model, \"HV\", 2))))",
          "12484:     {",
          "12485:       switch (tag)",
          "12486:       {",
          "12487:       case 0x7300: // SR2 black level",
          "12488:         for (int i = 0; i < 4 && i < len; i++)",
          "12489:           cblack[i] = get2();",
          "12490:         break;",
          "12491:       case 0x7480:",
          "12492:       case 0x7820:",
          "12493:         FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get2();",
          "12494:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];",
          "12495:         break;",
          "12496:       case 0x7481:",
          "12497:       case 0x7821:",
          "12498:         FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c] = get2();",
          "12499:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1];",
          "12500:         break;",
          "12501:       case 0x7482:",
          "12502:       case 0x7822:",
          "12503:         FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get2();",
          "12504:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];",
          "12505:         break;",
          "12506:       case 0x7483:",
          "12507:       case 0x7823:",
          "12508:         FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c] = get2();",
          "12509:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1];",
          "12510:         break;",
          "12511:       case 0x7484:",
          "12512:       case 0x7824:",
          "12513:         imgdata.color.WBCT_Coeffs[0][0] = 4500;",
          "12514:         FORC3 imgdata.color.WBCT_Coeffs[0][c + 1] = get2();",
          "12515:         imgdata.color.WBCT_Coeffs[0][4] = imgdata.color.WBCT_Coeffs[0][2];",
          "12516:         break;",
          "12517:       case 0x7486:",
          "12518:         FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get2();",
          "12519:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];",
          "12520:         break;",
          "12521:       case 0x7825:",
          "12522:         FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get2();",
          "12523:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];",
          "12524:         break;",
          "12525:       case 0x7826:",
          "12526:         FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c] = get2();",
          "12527:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1];",
          "12528:         break;",
          "12529:       case 0x7827:",
          "12530:         FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c] = get2();",
          "12531:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1];",
          "12532:         break;",
          "12533:       case 0x7828:",
          "12534:         FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c] = get2();",
          "12535:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1];",
          "12536:         break;",
          "12537:       case 0x7829:",
          "12538:         FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c] = get2();",
          "12539:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1];",
          "12540:         break;",
          "12541:       case 0x782a:",
          "12542:         imgdata.color.WBCT_Coeffs[1][0] = 8500;",
          "12543:         FORC3 imgdata.color.WBCT_Coeffs[1][c + 1] = get2();",
          "12544:         imgdata.color.WBCT_Coeffs[1][4] = imgdata.color.WBCT_Coeffs[1][2];",
          "12545:         break;",
          "12546:       case 0x782b:",
          "12547:         imgdata.color.WBCT_Coeffs[2][0] = 6000;",
          "12548:         FORC3 imgdata.color.WBCT_Coeffs[2][c + 1] = get2();",
          "12549:         imgdata.color.WBCT_Coeffs[2][4] = imgdata.color.WBCT_Coeffs[2][2];",
          "12550:         break;",
          "12551:       case 0x782c:",
          "12552:         imgdata.color.WBCT_Coeffs[3][0] = 3200;",
          "12553:         FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][c] = imgdata.color.WBCT_Coeffs[3][c + 1] = get2();",
          "12554:         imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][3] = imgdata.color.WBCT_Coeffs[3][4] =",
          "12555:             imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][1];",
          "12556:         break;",
          "12557:       case 0x782d:",
          "12558:         imgdata.color.WBCT_Coeffs[4][0] = 2500;",
          "12559:         FORC3 imgdata.color.WBCT_Coeffs[4][c + 1] = get2();",
          "12560:         imgdata.color.WBCT_Coeffs[4][4] = imgdata.color.WBCT_Coeffs[4][2];",
          "12561:         break;",
          "12562:       case 0x787f:",
          "12563:         FORC3 imgdata.color.linear_max[c] = get2();",
          "12564:         imgdata.color.linear_max[3] = imgdata.color.linear_max[1];",
          "12565:         break;",
          "12566:       }",
          "12567:     }",
          "12570:     switch (tag)",
          "12571:     {",
          "12572:     case 1:",
          "12573:       if (len == 4)",
          "12574:         pana_raw = get4();",
          "12575:       break;",
          "12576:     case 5:",
          "12577:       width = get2();",
          "12578:       break;",
          "12579:     case 6:",
          "12580:       height = get2();",
          "12582:     case 7:",
          "12583:       width += get2();",
          "12584:       break;",
          "12585:     case 9:",
          "12586:       if ((i = get2()))",
          "12587:         filters = i;",
          "12589:       if (pana_raw && len == 1 && type == 3)",
          "12590:         pana_black[3] += i;",
          "12593:     case 8:",
          "12594:     case 10:",
          "12596:       if (pana_raw && len == 1 && type == 3)",
          "12597:         pana_black[3] += get2();",
          "12598: #endif",
          "12600:     case 14:",
          "12601:     case 15:",
          "12602:     case 16:",
          "12603: #ifdef LIBRAW_LIBRARY_BUILD",
          "12604:       if (pana_raw)",
          "12605:       {",
          "12606:         imgdata.color.linear_max[tag - 14] = get2();",
          "12607:         if (tag == 15)",
          "12608:           imgdata.color.linear_max[3] = imgdata.color.linear_max[1];",
          "12609:       }",
          "12612:     case 17:",
          "12613:     case 18:",
          "12614:       if (type == 3 && len == 1)",
          "12615:         cam_mul[(tag - 17) * 2] = get2() / 256.0;",
          "12616:       break;",
          "12618:     case 19:",
          "12619:       if (pana_raw)",
          "12620:       {",
          "12621:         ushort nWB, cnt, tWB;",
          "12622:         nWB = get2();",
          "12623:         if (nWB > 0x100)",
          "12624:           break;",
          "12625:         for (cnt = 0; cnt < nWB; cnt++)",
          "12626:         {",
          "12627:           tWB = get2();",
          "12628:           if (tWB < 0x100)",
          "12630:             imgdata.color.WB_Coeffs[tWB][0] = get2();",
          "12631:             imgdata.color.WB_Coeffs[tWB][2] = get2();",
          "12632:             imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = 0x100;",
          "12634:           else",
          "12635:             get4();",
          "12636:         }",
          "12637:       }",
          "12638:       break;",
          "12639: #endif",
          "12640:     case 23:",
          "12641:       if (type == 3)",
          "12642:         iso_speed = get2();",
          "12643:       break;",
          "12644:     case 28:",
          "12645:     case 29:",
          "12646:     case 30:",
          "12647: #ifdef LIBRAW_LIBRARY_BUILD",
          "12648:       if (pana_raw && len == 1 && type == 3)",
          "12649:       {",
          "12650:         pana_black[tag - 28] = get2();",
          "12651:       }",
          "12652:       else",
          "12654:       {",
          "12655:         cblack[tag - 28] = get2();",
          "12656:         cblack[3] = cblack[1];",
          "12657:       }",
          "12658:       break;",
          "12659:     case 36:",
          "12660:     case 37:",
          "12661:     case 38:",
          "12662:       cam_mul[tag - 36] = get2();",
          "12663:       break;",
          "12664:     case 39:",
          "12665: #ifdef LIBRAW_LIBRARY_BUILD",
          "12666:       if (pana_raw)",
          "12667:       {",
          "12668:         ushort nWB, cnt, tWB;",
          "12669:         nWB = get2();",
          "12670:         if (nWB > 0x100)",
          "12671:           break;",
          "12672:         for (cnt = 0; cnt < nWB; cnt++)",
          "12673:         {",
          "12674:           tWB = get2();",
          "12675:           if (tWB < 0x100)",
          "12677:             imgdata.color.WB_Coeffs[tWB][0] = get2();",
          "12678:             imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = get2();",
          "12679:             imgdata.color.WB_Coeffs[tWB][2] = get2();",
          "12681:           else",
          "12682:             fseek(ifp, 6, SEEK_CUR);",
          "12683:         }",
          "12684:       }",
          "12685:       break;",
          "12686: #endif",
          "12687:       if (len < 50 || cam_mul[0])",
          "12688:         break;",
          "12689:       fseek(ifp, 12, SEEK_CUR);",
          "12690:       FORC3 cam_mul[c] = get2();",
          "12691:       break;",
          "12692:     case 46:",
          "12693:       if (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)",
          "12694:         break;",
          "12695:       thumb_offset = ftell(ifp) - 2;",
          "12696:       thumb_length = len;",
          "12697:       break;",
          "12699:       fseek(ifp, get4() + base, SEEK_SET);",
          "12700:       parse_tiff_ifd(base);",
          "12701:       break;",
          "12702:     case 2:",
          "12703:     case 256:",
          "12705:       tiff_ifd[ifd].t_width = getint(type);",
          "12706:       break;",
          "12707:     case 3:",
          "12708:     case 257:",
          "12710:       tiff_ifd[ifd].t_height = getint(type);",
          "12711:       break;",
          "12713:     case 61443:",
          "12714:       tiff_ifd[ifd].samples = len & 7;",
          "12715:       tiff_ifd[ifd].bps = getint(type);",
          "12716:       if (tiff_bps < tiff_ifd[ifd].bps)",
          "12717:         tiff_bps = tiff_ifd[ifd].bps;",
          "12718:       break;",
          "12719:     case 61446:",
          "12720:       raw_height = 0;",
          "12721:       if (tiff_ifd[ifd].bps > 12)",
          "12722:         break;",
          "12723:       load_raw = &CLASS packed_load_raw;",
          "12724:       load_flags = get4() ? 24 : 80;",
          "12725:       break;",
          "12727:       tiff_ifd[ifd].comp = getint(type);",
          "12728:       break;",
          "12730:       tiff_ifd[ifd].phint = get2();",
          "12731:       break;",
          "12733:       fread(desc, 512, 1, ifp);",
          "12734:       break;",
          "12736:       fgets(make, 64, ifp);",
          "12737:       break;",
          "12739:       fgets(model, 64, ifp);",
          "12740:       break;",
          "12741: #ifdef LIBRAW_LIBRARY_BUILD",
          "12742:     case 278:",
          "12743:       tiff_ifd[ifd].rows_per_strip = getint(type);",
          "12744:       break;",
          "12745: #endif",
          "12747:       if (type != 4)",
          "12748:         break;",
          "12749:       load_raw = &CLASS panasonic_load_raw;",
          "12750:       load_flags = 0x2008;",
          "12752: #ifdef LIBRAW_LIBRARY_BUILD",
          "12753:       if (len > 1 && len < 16384)",
          "12754:       {",
          "12755:         off_t sav = ftell(ifp);",
          "12756:         tiff_ifd[ifd].strip_offsets = (int *)calloc(len, sizeof(int));",
          "12757:         tiff_ifd[ifd].strip_offsets_count = len;",
          "12758:         for (int i = 0; i < len; i++)",
          "12759:           tiff_ifd[ifd].strip_offsets[i] = get4() + base;",
          "12760:         fseek(ifp, sav, SEEK_SET); // restore position",
          "12761:       }",
          "12763: #endif",
          "12765:     case 61447:",
          "12766:       tiff_ifd[ifd].offset = get4() + base;",
          "12767:       if (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0)",
          "12768:       {",
          "12769:         fseek(ifp, tiff_ifd[ifd].offset, SEEK_SET);",
          "12770:         if (ljpeg_start(&jh, 1))",
          "12771:         {",
          "12772:           tiff_ifd[ifd].comp = 6;",
          "12773:           tiff_ifd[ifd].t_width = jh.wide;",
          "12774:           tiff_ifd[ifd].t_height = jh.high;",
          "12775:           tiff_ifd[ifd].bps = jh.bits;",
          "12776:           tiff_ifd[ifd].samples = jh.clrs;",
          "12777:           if (!(jh.sraw || (jh.clrs & 1)))",
          "12778:             tiff_ifd[ifd].t_width *= jh.clrs;",
          "12779:           if ((tiff_ifd[ifd].t_width > 4 * tiff_ifd[ifd].t_height) & ~jh.clrs)",
          "12781:             tiff_ifd[ifd].t_width /= 2;",
          "12782:             tiff_ifd[ifd].t_height *= 2;",
          "12784:           i = order;",
          "12785:           parse_tiff(tiff_ifd[ifd].offset + 12);",
          "12786:           order = i;",
          "12787:         }",
          "12788:       }",
          "12789:       break;",
          "12791:       tiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7] - '0';",
          "12792:       break;",
          "12794:       tiff_ifd[ifd].samples = getint(type) & 7;",
          "12795:       break;",
          "12797: #ifdef LIBRAW_LIBRARY_BUILD",
          "12798:       if (len > 1 && len < 16384)",
          "12799:       {",
          "12800:         off_t sav = ftell(ifp);",
          "12801:         tiff_ifd[ifd].strip_byte_counts = (int *)calloc(len, sizeof(int));",
          "12802:         tiff_ifd[ifd].strip_byte_counts_count = len;",
          "12803:         for (int i = 0; i < len; i++)",
          "12804:           tiff_ifd[ifd].strip_byte_counts[i] = get4();",
          "12805:         fseek(ifp, sav, SEEK_SET); // restore position",
          "12806:       }",
          "12808: #endif",
          "12809:     case 514:",
          "12810:     case 61448:",
          "12811:       tiff_ifd[ifd].bytes = get4();",
          "12812:       break;",
          "12813:     case 61454:",
          "12814:       FORC3 cam_mul[(4 - c) % 3] = getint(type);",
          "12815:       break;",
          "12816:     case 305:",
          "12818:       fgets(software, 64, ifp);",
          "12819:       if (!strncmp(software, \"Adobe\", 5) || !strncmp(software, \"dcraw\", 5) || !strncmp(software, \"UFRaw\", 5) ||",
          "12820:           !strncmp(software, \"Bibble\", 6) || !strcmp(software, \"Digital Photo Professional\"))",
          "12821:         is_raw = 0;",
          "12822:       break;",
          "12824:       get_timestamp(0);",
          "12825:       break;",
          "12827:       fread(artist, 64, 1, ifp);",
          "12828:       break;",
          "12829:     case 317:",
          "12830:       tiff_ifd[ifd].predictor = getint(type);",
          "12831:       break;",
          "12833:       tiff_ifd[ifd].t_tile_width = getint(type);",
          "12834:       break;",
          "12836:       tiff_ifd[ifd].t_tile_length = getint(type);",
          "12837:       break;",
          "12839:       tiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();",
          "12840:       if (len == 1)",
          "12841:         tiff_ifd[ifd].t_tile_width = tiff_ifd[ifd].t_tile_length = 0;",
          "12842:       if (len == 4)",
          "12843:       {",
          "12844:         load_raw = &CLASS sinar_4shot_load_raw;",
          "12845:         is_raw = 5;",
          "12846:       }",
          "12847:       break;",
          "12848:     case 325:",
          "12849:       tiff_ifd[ifd].bytes = len > 1 ? ftell(ifp) : get4();",
          "12850:       break;",
          "12852:       if (!strcmp(model, \"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872)",
          "12853:       {",
          "12854:         load_raw = &CLASS sony_arw_load_raw;",
          "12855:         data_offset = get4() + base;",
          "12856:         ifd++;",
          "12857:         break;",
          "12858:       }",
          "12859: #ifdef LIBRAW_LIBRARY_BUILD",
          "12860:       if (!strncmp(make, \"Hasselblad\", 10) && libraw_internal_data.unpacker_data.hasselblad_parser_flag)",
          "12861:       {",
          "12862:         fseek(ifp, ftell(ifp) + 4, SEEK_SET);",
          "12863:         fseek(ifp, get4() + base, SEEK_SET);",
          "12864:         parse_tiff_ifd(base);",
          "12866:       }",
          "12867: #endif",
          "12868:       if (len > 1000)",
          "12870:       while (len--)",
          "12871:       {",
          "12872:         i = ftell(ifp);",
          "12873:         fseek(ifp, get4() + base, SEEK_SET);",
          "12874:         if (parse_tiff_ifd(base))",
          "12875:           break;",
          "12876:         fseek(ifp, i + 4, SEEK_SET);",
          "12877:       }",
          "12878:       break;",
          "12879:     case 339:",
          "12880:       tiff_ifd[ifd].sample_format = getint(type);",
          "12881:       break;",
          "12882:     case 400:",
          "12883:       strcpy(make, \"Sarnoff\");",
          "12884:       maximum = 0xfff;",
          "12885:       break;",
          "12886: #ifdef LIBRAW_LIBRARY_BUILD",
          "12887:     case 700:",
          "12888:       if ((type == 1 || type == 2 || type == 6 || type == 7) && len > 1 && len < 5100000)",
          "12889:       {",
          "12890:         xmpdata = (char *)malloc(xmplen = len + 1);",
          "12891:         fread(xmpdata, len, 1, ifp);",
          "12892:         xmpdata[len] = 0;",
          "12893:       }",
          "12894:       break;",
          "12896:     case 28688:",
          "12897:       FORC4 sony_curve[c + 1] = get2() >> 2 & 0xfff;",
          "12898:       for (i = 0; i < 5; i++)",
          "12899:         for (j = sony_curve[i] + 1; j <= sony_curve[i + 1]; j++)",
          "12900:           curve[j] = curve[j - 1] + (1 << i);",
          "12901:       break;",
          "12902:     case 29184:",
          "12903:       sony_offset = get4();",
          "12904:       break;",
          "12905:     case 29185:",
          "12906:       sony_length = get4();",
          "12907:       break;",
          "12908:     case 29217:",
          "12909:       sony_key = get4();",
          "12910:       break;",
          "12911:     case 29264:",
          "12912:       parse_minolta(ftell(ifp));",
          "12913:       raw_width = 0;",
          "12914:       break;",
          "12915:     case 29443:",
          "12916:       FORC4 cam_mul[c ^ (c < 2)] = get2();",
          "12917:       break;",
          "12918:     case 29459:",
          "12919:       FORC4 cam_mul[c] = get2();",
          "12920:       i = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;",
          "12921:       SWAP(cam_mul[i], cam_mul[i + 1])",
          "12922:       break;",
          "12925:       for (i = 0; i < 3; i++)",
          "12926:       {",
          "12928:         for (c = 0; c < 3; c++)",
          "12929:         {",
          "12930:           imgdata.color.ccm[i][c] = (float)((short)get2());",
          "12933:         if (num > 0.01)",
          "12934:           FORC3 imgdata.color.ccm[i][c] = imgdata.color.ccm[i][c] / num;",
          "12939:       FORC4 cblack[c ^ c >> 1] = get2();",
          "12940:       i = cblack[3];",
          "12941:       FORC3 if (i > cblack[c]) i = cblack[c];",
          "12942:       FORC4 cblack[c] -= i;",
          "12943:       black = i;",
          "12946:       if (verbose)",
          "12947:         fprintf(stderr, _(\"...Sony black: %u cblack: %u %u %u %u\\n\"), black, cblack[0], cblack[1], cblack[2],",
          "12948:                 cblack[3]);",
          "12949: #endif",
          "12950:       break;",
          "12952:       fgets(model2, 64, ifp);",
          "12953:       break;",
          "12955:       if (get2() == 6 && get2() == 6)",
          "12956:         filters = 9;",
          "12957:       break;",
          "12959:       if (filters == 9)",
          "12960:       {",
          "12961:         FORC(36)((char *)xtrans)[c] = fgetc(ifp) & 3;",
          "12963:       }",
          "12965:       if (len == 36)",
          "12966:       {",
          "12967:         filters = 9;",
          "12968:         colors = 3;",
          "12969:         FORC(36) xtrans[0][c] = fgetc(ifp) & 3;",
          "12970:       }",
          "12971:       else if (len > 0)",
          "12972:       {",
          "12973:         if ((plen = len) > 16)",
          "12974:           plen = 16;",
          "12975:         fread(cfa_pat, 1, plen, ifp);",
          "12976:         for (colors = cfa = i = 0; i < plen && colors < 4; i++)",
          "12977:         {",
          "12978:           colors += !(cfa & (1 << cfa_pat[i]));",
          "12979:           cfa |= 1 << cfa_pat[i];",
          "12980:         }",
          "12981:         if (cfa == 070)",
          "12983:         if (cfa == 072)",
          "12985:         goto guess_cfa_pc;",
          "12986:       }",
          "12987:       break;",
          "12988:     case 33424:",
          "12989:     case 65024:",
          "12990:       fseek(ifp, get4() + base, SEEK_SET);",
          "12991:       parse_kodak_ifd(base);",
          "12992:       break;",
          "12994:       tiff_ifd[ifd].t_shutter = shutter = getreal(type);",
          "12995:       break;",
          "12997:       aperture = getreal(type);",
          "12998:       break;",
          "13001:     case 0xa405: // FocalLengthIn35mmFormat",
          "13004:     case 0xa431: // BodySerialNumber",
          "13008:     case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard",
          "13009:       imgdata.lens.MinFocal = getreal(type);",
          "13010:       imgdata.lens.MaxFocal = getreal(type);",
          "13011:       imgdata.lens.MaxAp4MinFocal = getreal(type);",
          "13012:       imgdata.lens.MaxAp4MaxFocal = getreal(type);",
          "13013:       break;",
          "13014:     case 0xa435: // LensSerialNumber",
          "13015:       stmread(imgdata.lens.LensSerial, len, ifp);",
          "13016:       break;",
          "13017:     case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard",
          "13018:       imgdata.lens.MinFocal = getreal(type);",
          "13019:       imgdata.lens.MaxFocal = getreal(type);",
          "13020:       imgdata.lens.MaxAp4MinFocal = getreal(type);",
          "13021:       imgdata.lens.MaxAp4MaxFocal = getreal(type);",
          "13022:       break;",
          "13023:     case 0xa433: // LensMake",
          "13024:       stmread(imgdata.lens.LensMake, len, ifp);",
          "13025:       break;",
          "13026:     case 0xa434: // LensModel",
          "13027:       stmread(imgdata.lens.Lens, len, ifp);",
          "13028:       if (!strncmp(imgdata.lens.Lens, \"----\", 4))",
          "13029:         imgdata.lens.Lens[0] = 0;",
          "13030:       break;",
          "13031:     case 0x9205:",
          "13032:       imgdata.lens.EXIF_MaxAp = powf64(2.0f, (getreal(type) / 2.0f));",
          "13033:       break;",
          "13035: #endif",
          "13037:       FORC4 cam_mul[c ^ 1] = 4096.0 / get2();",
          "13038:       break;",
          "13040:       fread(software, 1, 7, ifp);",
          "13041:       if (strncmp(software, \"MATRIX\", 6))",
          "13042:         break;",
          "13043:       colors = 4;",
          "13044:       for (raw_color = i = 0; i < 3; i++)",
          "13045:       {",
          "13046:         FORC4 fscanf(ifp, \"%f\", &rgb_cam[i][c ^ 1]);",
          "13047:         if (!use_camera_wb)",
          "13048:           continue;",
          "13049:         num = 0;",
          "13050:         FORC4 num += rgb_cam[i][c];",
          "13051:         FORC4 rgb_cam[i][c] /= MAX(1, num);",
          "13052:       }",
          "13053:       break;",
          "13055:       parse_mos(ftell(ifp));",
          "13056:     case 34303:",
          "13057:       strcpy(make, \"Leaf\");",
          "13058:       break;",
          "13060:       fseek(ifp, get4() + base, SEEK_SET);",
          "13061:       parse_exif(base);",
          "13062:       break;",
          "13064:     {",
          "13065:       unsigned pos;",
          "13066:       fseek(ifp, pos = (get4() + base), SEEK_SET);",
          "13067:       parse_gps(base);",
          "13068: #ifdef LIBRAW_LIBRARY_BUILD",
          "13069:       fseek(ifp, pos, SEEK_SET);",
          "13070:       parse_gps_libraw(base);",
          "13071: #endif",
          "13072:     }",
          "13073:     break;",
          "13076:       profile_offset = ftell(ifp);",
          "13077:       profile_length = len;",
          "13078:       break;",
          "13080:       kodak_cbpp = get4();",
          "13081:       break;",
          "13083:       focal_len = getreal(type);",
          "13084:       break;",
          "13086:       shot_order = getint(type);",
          "13087:       break;",
          "13089:       for (raw_color = i = 0; i < 3; i++)",
          "13090:       {",
          "13091:         getreal(type);",
          "13092:         FORC3 rgb_cam[i][c] = getreal(type);",
          "13093:       }",
          "13094:       break;",
          "13095:     case 40976:",
          "13096:       strip_offset = get4();",
          "13097:       switch (tiff_ifd[ifd].comp)",
          "13098:       {",
          "13099:       case 32770:",
          "13100:         load_raw = &CLASS samsung_load_raw;",
          "13101:         break;",
          "13102:       case 32772:",
          "13103:         load_raw = &CLASS samsung2_load_raw;",
          "13104:         break;",
          "13105:       case 32773:",
          "13106:         load_raw = &CLASS samsung3_load_raw;",
          "13107:         break;",
          "13108:       }",
          "13109:       break;",
          "13111:       strcpy(make, \"Imacon\");",
          "13112:       data_offset = ftell(ifp);",
          "13113:       ima_len = len;",
          "13114:       break;",
          "13115:     case 46279:",
          "13116:       if (!ima_len)",
          "13117:         break;",
          "13118:       fseek(ifp, 38, SEEK_CUR);",
          "13119:     case 46274:",
          "13120:       fseek(ifp, 40, SEEK_CUR);",
          "13121:       raw_width = get4();",
          "13122:       raw_height = get4();",
          "13123:       left_margin = get4() & 7;",
          "13124:       width = raw_width - left_margin - (get4() & 7);",
          "13125:       top_margin = get4() & 7;",
          "13126:       height = raw_height - top_margin - (get4() & 7);",
          "13127:       if (raw_width == 7262 && ima_len == 234317952)",
          "13128:       {",
          "13129:         height = 5412;",
          "13130:         width = 7216;",
          "13131:         left_margin = 7;",
          "13132:         filters = 0;",
          "13133:       }",
          "13134:       else if (raw_width == 7262)",
          "13135:       {",
          "13136:         height = 5444;",
          "13137:         width = 7244;",
          "13138:         left_margin = 7;",
          "13139:       }",
          "13140:       fseek(ifp, 52, SEEK_CUR);",
          "13141:       FORC3 cam_mul[c] = getreal(11);",
          "13142:       fseek(ifp, 114, SEEK_CUR);",
          "13143:       flip = (get2() >> 7) * 90;",
          "13144:       if (width * height * 6 == ima_len)",
          "13145:       {",
          "13146:         if (flip % 180 == 90)",
          "13147:           SWAP(width, height);",
          "13148:         raw_width = width;",
          "13149:         raw_height = height;",
          "13150:         left_margin = top_margin = filters = flip = 0;",
          "13151:       }",
          "13152:       sprintf(model, \"Ixpress %d-Mp\", height * width / 1000000);",
          "13153:       load_raw = &CLASS imacon_full_load_raw;",
          "13154:       if (filters)",
          "13155:       {",
          "13156:         if (left_margin & 1)",
          "13157:           filters = 0x61616161;",
          "13158:         load_raw = &CLASS unpacked_load_raw;",
          "13159:       }",
          "13160:       maximum = 0xffff;",
          "13161:       break;",
          "13163:     case 50455:",
          "13164:       if (len > 2560000 || !(cbuf = (char *)malloc(len)))",
          "13165:         break;",
          "13166: #ifndef LIBRAW_LIBRARY_BUILD",
          "13167:       fread(cbuf, 1, len, ifp);",
          "13168: #else",
          "13169:       if (fread(cbuf, 1, len, ifp) != len)",
          "13170:         throw LIBRAW_EXCEPTION_IO_CORRUPT; // cbuf to be free'ed in recycle",
          "13171: #endif",
          "13172:       cbuf[len - 1] = 0;",
          "13173:       for (cp = cbuf - 1; cp && cp < cbuf + len; cp = strchr(cp, '\\n'))",
          "13174:         if (!strncmp(++cp, \"Neutral \", 8))",
          "13175:           sscanf(cp + 8, \"%f %f %f\", cam_mul, cam_mul + 1, cam_mul + 2);",
          "13176:       free(cbuf);",
          "13177:       break;",
          "13178:     case 50458:",
          "13179:       if (!make[0])",
          "13180:         strcpy(make, \"Hasselblad\");",
          "13183: #ifdef LIBRAW_LIBRARY_BUILD",
          "13184:       libraw_internal_data.unpacker_data.hasselblad_parser_flag = 1;",
          "13185: #endif",
          "13186:       i = order;",
          "13187:       j = ftell(ifp);",
          "13188:       c = tiff_nifds;",
          "13189:       order = get2();",
          "13190:       fseek(ifp, j + (get2(), get4()), SEEK_SET);",
          "13191:       parse_tiff_ifd(j);",
          "13192:       maximum = 0xffff;",
          "13193:       tiff_nifds = c;",
          "13194:       order = i;",
          "13197:       FORC4 dng_version = (dng_version << 8) + fgetc(ifp);",
          "13198:       if (!make[0])",
          "13199:         strcpy(make, \"DNG\");",
          "13200:       is_raw = 1;",
          "13203: #ifdef LIBRAW_LIBRARY_BUILD",
          "13204:       stmread(imgdata.color.UniqueCameraModel, len, ifp);",
          "13205:       imgdata.color.UniqueCameraModel[sizeof(imgdata.color.UniqueCameraModel) - 1] = 0;",
          "13206: #endif",
          "13207:       if (model[0])",
          "13208:         break;",
          "13209: #ifndef LIBRAW_LIBRARY_BUILD",
          "13210:       fgets(make, 64, ifp);",
          "13211: #else",
          "13212:       strncpy(make, imgdata.color.UniqueCameraModel, MIN(len, sizeof(imgdata.color.UniqueCameraModel)));",
          "13213: #endif",
          "13214:       if ((cp = strchr(make, ' ')))",
          "13215:       {",
          "13216:         strcpy(model, cp + 1);",
          "13218:       }",
          "13221:       if (filters == 9)",
          "13222:         break;",
          "13223:       if (len > 4)",
          "13224:         len = 4;",
          "13225:       colors = len;",
          "13226:       fread(cfa_pc, 1, colors, ifp);",
          "13227:     guess_cfa_pc:",
          "13228:       FORCC tab[cfa_pc[c]] = c;",
          "13229:       cdesc[c] = 0;",
          "13230:       for (i = 16; i--;)",
          "13231:         filters = filters << 2 | tab[cfa_pat[i % plen]];",
          "13232:       filters -= !filters;",
          "13235:       if (get2() == 2)",
          "13236:         fuji_width = 1;",
          "13238:     case 291:",
          "13240:       linear_table(len);",
          "13241:       break;",
          "13243: #ifdef LIBRAW_LIBRARY_BUILD",
          "13244:       imgdata.color.dng_levels.dng_cblack[4] =",
          "13246:           cblack[4] = get2();",
          "13248:       imgdata.color.dng_levels.dng_cblack[5] =",
          "13250:           cblack[5] = get2();",
          "13251:       if (cblack[4] * cblack[5] > (sizeof(cblack) / sizeof(cblack[0]) - 6))",
          "13252: #ifdef LIBRAW_LIBRARY_BUILD",
          "13253:         imgdata.color.dng_levels.dng_cblack[4] = imgdata.color.dng_levels.dng_cblack[5] =",
          "13254: #endif",
          "13255:             cblack[4] = cblack[5] = 1;",
          "13256:       break;",
          "13258: #ifdef LIBRAW_LIBRARY_BUILD",
          "13259:     case 0xf00c:",
          "13260:     {",
          "13261:       unsigned fwb[4];",
          "13262:       FORC4 fwb[c] = get4();",
          "13263:       if (fwb[3] < 0x100)",
          "13264:       {",
          "13265:         imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];",
          "13266:         imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];",
          "13267:         imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];",
          "13268:         if ((fwb[3] == 17) && libraw_internal_data.unpacker_data.lenRAFData > 3 &&",
          "13269:             libraw_internal_data.unpacker_data.lenRAFData < 10240000)",
          "13270:         {",
          "13271:           long long f_save = ftell(ifp);",
          "13272:           int fj, found = 0;",
          "13273:           ushort *rafdata = (ushort *)malloc(sizeof(ushort) * libraw_internal_data.unpacker_data.lenRAFData);",
          "13274:           fseek(ifp, libraw_internal_data.unpacker_data.posRAFData, SEEK_SET);",
          "13275:           fread(rafdata, sizeof(ushort), libraw_internal_data.unpacker_data.lenRAFData, ifp);",
          "13276:           fseek(ifp, f_save, SEEK_SET);",
          "13277:           for (int fi = 0; fi < (libraw_internal_data.unpacker_data.lenRAFData - 3); fi++)",
          "13278:           {",
          "13279:             if ((fwb[0] == rafdata[fi]) && (fwb[1] == rafdata[fi + 1]) && (fwb[2] == rafdata[fi + 2]))",
          "13280:             {",
          "13281:               if (rafdata[fi - 15] != fwb[0])",
          "13282:                 continue;",
          "13283:               fi = fi - 15;",
          "13284:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][3] =",
          "13285:                   rafdata[fi];",
          "13286:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = rafdata[fi + 1];",
          "13287:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = rafdata[fi + 2];",
          "13289:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =",
          "13290:                   rafdata[fi + 3];",
          "13291:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = rafdata[fi + 4];",
          "13292:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = rafdata[fi + 5];",
          "13294:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =",
          "13295:                   rafdata[fi + 6];",
          "13296:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = rafdata[fi + 7];",
          "13297:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = rafdata[fi + 8];",
          "13299:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] =",
          "13300:                   rafdata[fi + 9];",
          "13301:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][0] = rafdata[fi + 10];",
          "13302:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][2] = rafdata[fi + 11];",
          "13304:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =",
          "13305:                   rafdata[fi + 12];",
          "13306:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = rafdata[fi + 13];",
          "13307:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = rafdata[fi + 14];",
          "13309:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =",
          "13310:                   rafdata[fi + 15];",
          "13311:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = rafdata[fi + 16];",
          "13312:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = rafdata[fi + 17];",
          "13314:               fi += 111;",
          "13315:               for (fj = fi; fj < (fi + 15); fj += 3)",
          "13316:                 if (rafdata[fj] != rafdata[fi])",
          "13318:                   found = 1;",
          "13319:                   break;",
          "13320:                 }",
          "13321:               if (found)",
          "13322:               {",
          "13323:                 int FujiCCT_K[31] = {2500, 2550, 2650, 2700, 2800, 2850, 2950, 3000, 3100, 3200, 3300,",
          "13324:                                      3400, 3600, 3700, 3800, 4000, 4200, 4300, 4500, 4800, 5000, 5300,",
          "13325:                                      5600, 5900, 6300, 6700, 7100, 7700, 8300, 9100, 10000};",
          "13326:                 fj = fj - 93;",
          "13327:                 for (int iCCT = 0; iCCT < 31; iCCT++)",
          "13328:                 {",
          "13329:                   imgdata.color.WBCT_Coeffs[iCCT][0] = FujiCCT_K[iCCT];",
          "13330:                   imgdata.color.WBCT_Coeffs[iCCT][1] = rafdata[iCCT * 3 + 1 + fj];",
          "13331:                   imgdata.color.WBCT_Coeffs[iCCT][2] = imgdata.color.WBCT_Coeffs[iCCT][4] = rafdata[iCCT * 3 + fj];",
          "13332:                   imgdata.color.WBCT_Coeffs[iCCT][3] = rafdata[iCCT * 3 + 2 + fj];",
          "13333:                 }",
          "13334:               }",
          "13335:               free(rafdata);",
          "13336:               break;",
          "13337:             }",
          "13338:           }",
          "13339:         }",
          "13340:       }",
          "13341:       FORC4 fwb[c] = get4();",
          "13342:       if (fwb[3] < 0x100)",
          "13343:       {",
          "13344:         imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];",
          "13345:         imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];",
          "13346:         imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];",
          "13347:       }",
          "13353:     case 50709:",
          "13354:       stmread(imgdata.color.LocalizedCameraModel, len, ifp);",
          "13358:     case 61450:",
          "13359:       cblack[4] = cblack[5] = MIN(sqrt((double)len), 64);",
          "13362:       if (tiff_ifd[ifd].samples > 1 && tiff_ifd[ifd].samples == len) // LinearDNG, per-channel black",
          "13363:       {",
          "13364:         for (i = 0; i < colors && i < 4 && i < len; i++)",
          "13365:           imgdata.color.dng_levels.dng_cblack[i] = cblack[i] = getreal(type) + 0.5;",
          "13367:         imgdata.color.dng_levels.dng_black = black = 0;",
          "13368:       }",
          "13369:       else",
          "13371:           if ((cblack[4] * cblack[5] < 2) && len == 1)",
          "13372:       {",
          "13374:         imgdata.color.dng_levels.dng_black =",
          "13376:             black = getreal(type);",
          "13377:       }",
          "13378:       else if (cblack[4] * cblack[5] <= len)",
          "13379:       {",
          "13380:         FORC(cblack[4] * cblack[5])",
          "13381:         cblack[6 + c] = getreal(type);",
          "13382:         black = 0;",
          "13383:         FORC4",
          "13384:         cblack[c] = 0;",
          "13387:         if (tag == 50714)",
          "13388:         {",
          "13389:           FORC(cblack[4] * cblack[5])",
          "13390:           imgdata.color.dng_levels.dng_cblack[6 + c] = cblack[6 + c];",
          "13391:           imgdata.color.dng_levels.dng_black = 0;",
          "13392:           FORC4",
          "13393:           imgdata.color.dng_levels.dng_cblack[c] = 0;",
          "13394:         }",
          "13396:       }",
          "13400:       for (num = i = 0; i < len && i < 65536; i++)",
          "13401:         num += getreal(type);",
          "13402:       black += num / len + 0.5;",
          "13404:       imgdata.color.dng_levels.dng_black += num / len + 0.5;",
          "13406:       break;",
          "13409:       imgdata.color.dng_levels.dng_whitelevel[0] =",
          "13411:           maximum = getint(type);",
          "13413:       if (tiff_ifd[ifd].samples > 1) // Linear DNG case",
          "13414:         for (i = 1; i < colors && i < 4 && i < len; i++)",
          "13415:           imgdata.color.dng_levels.dng_whitelevel[i] = getint(type);",
          "13417:       break;",
          "13419:       pixel_aspect = getreal(type);",
          "13420:       pixel_aspect /= getreal(type);",
          "13421:       if (pixel_aspect > 0.995 && pixel_aspect < 1.005)",
          "13422:         pixel_aspect = 1.0;",
          "13423:       break;",
          "13425:     case 50778:",
          "13426:       imgdata.color.dng_color[0].illuminant = get2();",
          "13427:       break;",
          "13428:     case 50779:",
          "13429:       imgdata.color.dng_color[1].illuminant = get2();",
          "13430:       break;",
          "13435:       i = tag == 50721 ? 0 : 1;",
          "13437:       FORCC for (j = 0; j < 3; j++)",
          "13438:       {",
          "13440:         imgdata.color.dng_color[i].colormatrix[c][j] =",
          "13442:             cm[c][j] = getreal(type);",
          "13443:       }",
          "13444:       use_cm = 1;",
          "13445:       break;",
          "13450:       i = tag == 0xc714 ? 0 : 1;",
          "13452:       for (j = 0; j < 3; j++)",
          "13453:         FORCC",
          "13454:         {",
          "13456:           imgdata.color.dng_color[i].forwardmatrix[j][c] =",
          "13459:         }",
          "13460:       break;",
          "13465:       j = tag == 50723 ? 0 : 1;",
          "13467:       for (i = 0; i < colors; i++)",
          "13468:         FORCC",
          "13469:         {",
          "13471:           imgdata.color.dng_color[j].calibration[i][c] =",
          "13474:         }",
          "13475:       break;",
          "13477:       FORCC",
          "13478:       {",
          "13479: #ifdef LIBRAW_LIBRARY_BUILD",
          "13480:         imgdata.color.dng_levels.analogbalance[c] =",
          "13481: #endif",
          "13482:             ab[c] = getreal(type);",
          "13483:       }",
          "13484:       break;",
          "13486:       FORCC asn[c] = getreal(type);",
          "13487:       break;",
          "13489:       xyz[0] = getreal(type);",
          "13490:       xyz[1] = getreal(type);",
          "13491:       xyz[2] = 1 - xyz[0] - xyz[1];",
          "13492:       FORC3 xyz[c] /= d65_white[c];",
          "13493:       break;",
          "13494: #ifdef LIBRAW_LIBRARY_BUILD",
          "13496:       baseline_exposure = getreal(type);",
          "13497:       break;",
          "13502:     {",
          "13503:       char mbuf[64];",
          "13504:       unsigned short makernote_found = 0;",
          "13505:       INT64 curr_pos, start_pos = ftell(ifp);",
          "13506:       unsigned MakN_order, m_sorder = order;",
          "13507:       unsigned MakN_length;",
          "13508:       unsigned pos_in_original_raw;",
          "13509:       fread(mbuf, 1, 6, ifp);",
          "13511:       if (!strcmp(mbuf, \"Adobe\"))",
          "13513:         order = 0x4d4d; // Adobe header is always in \"MM\" / big endian",
          "13514:         curr_pos = start_pos + 6;",
          "13515:         while (curr_pos + 8 - start_pos <= len)",
          "13516:         {",
          "13517:           fread(mbuf, 1, 4, ifp);",
          "13518:           curr_pos += 8;",
          "13519:           if (!strncmp(mbuf, \"MakN\", 4))",
          "13521:             makernote_found = 1;",
          "13522:             MakN_length = get4();",
          "13523:             MakN_order = get2();",
          "13524:             pos_in_original_raw = get4();",
          "13525:             order = MakN_order;",
          "13526:             parse_makernote_0xc634(curr_pos + 6 - pos_in_original_raw, 0, AdobeDNG);",
          "13527:             break;",
          "13529:         }",
          "13531:       else",
          "13532:       {",
          "13533:         fread(mbuf + 6, 1, 2, ifp);",
          "13534:         if (!strcmp(mbuf, \"PENTAX \") || !strcmp(mbuf, \"SAMSUNG\"))",
          "13535:         {",
          "13536:           makernote_found = 1;",
          "13537:           fseek(ifp, start_pos, SEEK_SET);",
          "13538:           parse_makernote_0xc634(base, 0, CameraDNG);",
          "13539:         }",
          "13540:       }",
          "13542:       fseek(ifp, start_pos, SEEK_SET);",
          "13543:       order = m_sorder;",
          "13544:     }",
          "13547:       if (dng_version)",
          "13548:         break;",
          "13549:       parse_minolta(j = get4() + base);",
          "13550:       fseek(ifp, j, SEEK_SET);",
          "13551:       parse_tiff_ifd(base);",
          "13554:       read_shorts(cr2_slice, 3);",
          "13563:       for (i = 0; i < len && i < 32; i++)",
          "13564:         ((int *)mask)[i] = getint(type);",
          "13571:       if (len < 13)",
          "13572:         break;",
          "13573:       fseek(ifp, 16, SEEK_CUR);",
          "13575:       fseek(ifp, 28, SEEK_CUR);",
          "13580:       if (type == 2)",
          "13581:         fgets(model2, 64, ifp);",
          "13583:     fseek(ifp, save, SEEK_SET);",
          "13585:   if (sony_length && sony_length < 10240000 && (buf = (unsigned *)malloc(sony_length)))",
          "13586:   {",
          "13587:     fseek(ifp, sony_offset, SEEK_SET);",
          "13588:     fread(buf, sony_length, 1, ifp);",
          "13589:     sony_decrypt(buf, sony_length / 4, 1, sony_key);",
          "13592:     if ((ifp = tmpfile()))",
          "13593:     {",
          "13594:       fwrite(buf, sony_length, 1, ifp);",
          "13595:       fseek(ifp, 0, SEEK_SET);",
          "13596:       parse_tiff_ifd(-sony_offset);",
          "13597:       fclose(ifp);",
          "13601:     if (!ifp->tempbuffer_open(buf, sony_length))",
          "13602:     {",
          "13603:       parse_tiff_ifd(-sony_offset);",
          "13604:       ifp->tempbuffer_close();",
          "13605:     }",
          "13607:     free(buf);",
          "13609:   for (i = 0; i < colors; i++)",
          "13611:   if (use_cm)",
          "13612:   {",
          "13613:     FORCC for (i = 0; i < 3; i++) for (cam_xyz[c][i] = j = 0; j < colors; j++) cam_xyz[c][i] +=",
          "13614:         cc[c][j] * cm[j][i] * xyz[i];",
          "13615:     cam_xyz_coeff(cmatrix, cam_xyz);",
          "13617:   if (asn[0])",
          "13618:   {",
          "",
          "---------------",
          "--- Hunk 104 ---",
          "[Context before]",
          "12403:   return 0;",
          "12404: }",
          "12407: {",
          "12408:   int doff;",
          "12410:   order = get2();",
          "12412:   get2();",
          "12416:   }",
          "12417:   return 1;",
          "12418: }",
          "12420: void CLASS apply_tiff()",
          "12421: {",
          "12423:   struct jhead jh;",
          "12425:   thumb_misc = 16;",
          "12435:     }",
          "12436:   }",
          "12438:     if (tiff_ifd[i].t_shutter)",
          "12439:       shutter = tiff_ifd[i].t_shutter;",
          "12440:     tiff_ifd[i].t_shutter = shutter;",
          "12441:   }",
          "12443:     if (max_samp < tiff_ifd[i].samples)",
          "12451:     }",
          "12452:     if ((tiff_ifd[i].comp != 6 || tiff_ifd[i].samples != 3) &&",
          "12460:       tiff_compress = tiff_ifd[i].comp;",
          "12462: #ifdef LIBRAW_LIBRARY_BUILD",
          "12464: #endif",
          "12470:       raw = i;",
          "12471:     }",
          "12472:   }",
          "12478:   if (raw >= 0 && !load_raw)",
          "12500: #ifdef LIBRAW_LIBRARY_BUILD",
          "12510:           {",
          "12514:             break;",
          "12515:           }",
          "12516: #endif",
          "12594:     }",
          "12595:   if (!dng_version)",
          "12602:       is_raw = 0;",
          "12614:       thumb_height = tiff_ifd[i].t_height;",
          "12615:       thumb_offset = tiff_ifd[i].offset;",
          "12616:       thumb_length = tiff_ifd[i].bytes;",
          "12618:       thm = i;",
          "12619:     }",
          "12621:     thumb_misc |= tiff_ifd[thm].samples << 5;",
          "12637:     }",
          "12638:   }",
          "12639: }",
          "12642: {",
          "12648:   order = fgetc(ifp) * 0x101;",
          "12649:   offset = base + get4() + 8;",
          "12652:       tag = tag << 8 | fgetc(ifp);",
          "12653:     len = get4();",
          "12663:     {",
          "12664:       fseek(ifp, 8, SEEK_CUR);",
          "12675:       get4();",
          "12706:   }",
          "12707:   raw_height = high;",
          "12709:   order = sorder;",
          "12710: }",
          "",
          "[Removed Lines]",
          "12406: int CLASS parse_tiff (int base)",
          "12409:   fseek (ifp, base, SEEK_SET);",
          "12411:   if (order != 0x4949 && order != 0x4d4d) return 0;",
          "12413:   while ((doff = get4())) {",
          "12414:     fseek (ifp, doff+base, SEEK_SET);",
          "12415:     if (parse_tiff_ifd (base)) break;",
          "12422:   int max_samp=0, ties=0, os, ns, raw=-1, thm=-1, i;",
          "12426:   if (thumb_offset) {",
          "12427:     fseek (ifp, thumb_offset, SEEK_SET);",
          "12428:     if (ljpeg_start (&jh, 1)) {",
          "12429:       if((unsigned)jh.bits<17 && (unsigned)jh.wide < 0x10000 && (unsigned)jh.high < 0x10000)",
          "12430:         {",
          "12431:           thumb_misc   = jh.bits;",
          "12432:           thumb_width  = jh.wide;",
          "12433:           thumb_height = jh.high;",
          "12434:         }",
          "12437:   for (i=tiff_nifds; i--; ) {",
          "12442:   for (i=0; i < tiff_nifds; i++) {",
          "12444:  max_samp = tiff_ifd[i].samples;",
          "12445:     if (max_samp > 3) max_samp = 3;",
          "12446:     os = raw_width*raw_height;",
          "12447:     ns = tiff_ifd[i].t_width*tiff_ifd[i].t_height;",
          "12448:     if (tiff_bps) {",
          "12449:         os *= tiff_bps;",
          "12450:         ns *= tiff_ifd[i].bps;",
          "12453:  unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&",
          "12454:         (unsigned)tiff_ifd[i].bps < 33 && (unsigned)tiff_ifd[i].samples < 13 &&",
          "12455:   ns && ((ns > os && (ties = 1)) ||",
          "12456:   (ns == os && shot_select == ties++))) {",
          "12457:       raw_width     = tiff_ifd[i].t_width;",
          "12458:       raw_height    = tiff_ifd[i].t_height;",
          "12459:       tiff_bps      = tiff_ifd[i].bps;",
          "12461:       data_offset   = tiff_ifd[i].offset;",
          "12463:       data_size     = tiff_ifd[i].bytes;",
          "12465:       tiff_flip     = tiff_ifd[i].t_flip;",
          "12466:       tiff_samples  = tiff_ifd[i].samples;",
          "12467:       tile_width    = tiff_ifd[i].t_tile_width;",
          "12468:       tile_length   = tiff_ifd[i].t_tile_length;",
          "12469:       shutter       = tiff_ifd[i].t_shutter;",
          "12473:   if (is_raw == 1 && ties) is_raw = ties;",
          "12474:   if (!tile_width ) tile_width  = INT_MAX;",
          "12475:   if (!tile_length) tile_length = INT_MAX;",
          "12476:   for (i=tiff_nifds; i--; )",
          "12477:     if (tiff_ifd[i].t_flip) tiff_flip = tiff_ifd[i].t_flip;",
          "12479:     switch (tiff_compress) {",
          "12480:       case 32767:",
          "12481:  if (tiff_ifd[raw].bytes == raw_width*raw_height) {",
          "12482:    tiff_bps = 12;",
          "12483:    load_raw = &CLASS sony_arw2_load_raw;   break;",
          "12484:  }",
          "12485:  if (!strncasecmp(make,\"Sony\",4) &&",
          "12486:      tiff_ifd[raw].bytes == raw_width*raw_height*2) {",
          "12487:    tiff_bps = 14;",
          "12488:    load_raw = &CLASS unpacked_load_raw;   break;",
          "12489:  }",
          "12490:  if (tiff_ifd[raw].bytes*8 != raw_width*raw_height*tiff_bps) {",
          "12491:    raw_height += 8;",
          "12492:    load_raw = &CLASS sony_arw_load_raw;   break;",
          "12493:  }",
          "12494:  load_flags = 79;",
          "12495:       case 32769:",
          "12496:  load_flags++;",
          "12497:       case 32770:",
          "12498:       case 32773: goto slr;",
          "12499:       case 0:  case 1:",
          "12502:         if(!strncasecmp(make,\"Sony\",4) &&",
          "12503:      tiff_ifd[raw].bytes == raw_width*raw_height*2)",
          "12504:           {",
          "12505:      tiff_bps = 14;",
          "12506:             load_raw = &CLASS unpacked_load_raw;",
          "12507:             break;",
          "12508:    }",
          "12509:         if(!strncasecmp(make,\"Nikon\",5) && !strncmp(software,\"Nikon Scan\",10))",
          "12511:             load_raw = &CLASS nikon_coolscan_load_raw;",
          "12512:             raw_color = 1;",
          "12513:             filters = 0;",
          "12517:  if (!strncmp(make,\"OLYMPUS\",7) &&",
          "12518:   tiff_ifd[raw].bytes*2 == raw_width*raw_height*3)",
          "12519:    load_flags = 24;",
          "12520:  if (tiff_ifd[raw].bytes*5 == raw_width*raw_height*8) {",
          "12521:    load_flags = 81;",
          "12522:    tiff_bps = 12;",
          "12523:  } slr:",
          "12524:  switch (tiff_bps) {",
          "12525:    case  8: load_raw = &CLASS eight_bit_load_raw; break;",
          "12526:    case 12: if (tiff_ifd[raw].phint == 2)",
          "12527:        load_flags = 6;",
          "12528:      load_raw = &CLASS packed_load_raw;  break;",
          "12529:    case 14: load_flags = 0;",
          "12530:    case 16: load_raw = &CLASS unpacked_load_raw;",
          "12531:      if (!strncmp(make,\"OLYMPUS\",7) &&",
          "12532:    tiff_ifd[raw].bytes*7 > raw_width*raw_height)",
          "12533:        load_raw = &CLASS olympus_load_raw;",
          "12534:  }",
          "12535:  break;",
          "12536:       case 6:  case 7:  case 99:",
          "12537:  load_raw = &CLASS lossless_jpeg_load_raw;  break;",
          "12538:       case 262:",
          "12539:  load_raw = &CLASS kodak_262_load_raw;   break;",
          "12540:       case 34713:",
          "12541:  if ((raw_width+9)/10*16*raw_height == tiff_ifd[raw].bytes) {",
          "12542:    load_raw = &CLASS packed_load_raw;",
          "12543:    load_flags = 1;",
          "12544:  } else if (raw_width*raw_height*3 == tiff_ifd[raw].bytes*2) {",
          "12545:    load_raw = &CLASS packed_load_raw;",
          "12546:    if (model[0] == 'N') load_flags = 80;",
          "12547:  } else if (raw_width*raw_height*3 == tiff_ifd[raw].bytes) {",
          "12548:    load_raw = &CLASS nikon_yuv_load_raw;",
          "12549:    gamma_curve (1/2.4, 12.92, 1, 4095);",
          "12550:    memset (cblack, 0, sizeof cblack);",
          "12551:    filters = 0;",
          "12552:  } else if (raw_width*raw_height*2 == tiff_ifd[raw].bytes) {",
          "12553:    load_raw = &CLASS unpacked_load_raw;",
          "12554:    load_flags = 4;",
          "12555:    order = 0x4d4d;",
          "12556:  } else",
          "12557: #ifdef LIBRAW_LIBRARY_BUILD",
          "12558:           if(raw_width*raw_height*3 == tiff_ifd[raw].bytes*2)",
          "12559:             {",
          "12560:               load_raw = &CLASS packed_load_raw;",
          "12561:               load_flags=80;",
          "12562:             }",
          "12563:           else if(tiff_ifd[raw].rows_per_strip && tiff_ifd[raw].strip_offsets_count &&",
          "12564:     tiff_ifd[raw].strip_offsets_count == tiff_ifd[raw].strip_byte_counts_count)",
          "12565:      {",
          "12566:        int fit = 1;",
          "12567:        for(int i = 0; i < tiff_ifd[raw].strip_byte_counts_count-1; i++) // all but last",
          "12568:   if(tiff_ifd[raw].strip_byte_counts[i]*2 != tiff_ifd[raw].rows_per_strip*raw_width*3)",
          "12569:     {",
          "12570:       fit = 0;",
          "12571:       break;",
          "12572:     }",
          "12573:        if(fit)",
          "12574:   load_raw = &CLASS nikon_load_striped_packed_raw;",
          "12575:        else",
          "12576:   load_raw = &CLASS nikon_load_raw; // fallback",
          "12577:      }",
          "12578:  else",
          "12579: #endif",
          "12580:             load_raw = &CLASS nikon_load_raw;   break;",
          "12581:       case 65535:",
          "12582:  load_raw = &CLASS pentax_load_raw;   break;",
          "12583:       case 65000:",
          "12584:  switch (tiff_ifd[raw].phint) {",
          "12585:    case 2: load_raw = &CLASS kodak_rgb_load_raw;   filters = 0;  break;",
          "12586:    case 6: load_raw = &CLASS kodak_ycbcr_load_raw; filters = 0;  break;",
          "12587:    case 32803: load_raw = &CLASS kodak_65000_load_raw;",
          "12588:  }",
          "12589:       case 32867: case 34892: break;",
          "12590: #ifdef LIBRAW_LIBRARY_BUILD",
          "12591:       case 8: break;",
          "12592: #endif",
          "12593:       default: is_raw = 0;",
          "12596:     if ( ((tiff_samples == 3 && tiff_ifd[raw].bytes && tiff_bps != 14 &&",
          "12597:    (tiff_compress & -16) != 32768)",
          "12598:           || (tiff_bps == 8 && strncmp(make,\"Phase\",5) &&",
          "12599:    !strcasestr(make,\"Kodak\") &&",
          "12600:    !strstr(model2,\"DEBUG RAW\")))",
          "12601:          && strncmp(software,\"Nikon Scan\",10))",
          "12603:   for (i=0; i < tiff_nifds; i++)",
          "12604:     if (i != raw",
          "12606:         && tiff_ifd[i].bps>0 && tiff_ifd[i].bps < 33",
          "12607:  && tiff_ifd[i].phint != 32803",
          "12608:  && tiff_ifd[i].phint != 34892",
          "12609:         && unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&",
          "12610:  tiff_ifd[i].t_width * tiff_ifd[i].t_height / (SQR(tiff_ifd[i].bps)+1) >",
          "12611:        thumb_width *       thumb_height / (SQR(thumb_misc)+1)",
          "12612:  && tiff_ifd[i].comp != 34892) {",
          "12613:       thumb_width  = tiff_ifd[i].t_width;",
          "12617:       thumb_misc   = tiff_ifd[i].bps;",
          "12620:   if (thm >= 0) {",
          "12622:     switch (tiff_ifd[thm].comp) {",
          "12623:       case 0:",
          "12624:  write_thumb = &CLASS layer_thumb;",
          "12625:  break;",
          "12626:       case 1:",
          "12627:  if (tiff_ifd[thm].bps <= 8)",
          "12628:    write_thumb = &CLASS ppm_thumb;",
          "12629:  else if (!strncmp(make,\"Imacon\",6))",
          "12630:    write_thumb = &CLASS ppm16_thumb;",
          "12631:  else",
          "12632:    thumb_load_raw = &CLASS kodak_thumb_load_raw;",
          "12633:  break;",
          "12634:       case 65000:",
          "12635:  thumb_load_raw = tiff_ifd[thm].phint == 6 ?",
          "12636:   &CLASS kodak_ycbcr_load_raw : &CLASS kodak_rgb_load_raw;",
          "12641: void CLASS parse_minolta (int base)",
          "12643:   int save, tag, len, offset, high=0, wide=0, i, c;",
          "12644:   short sorder=order;",
          "12646:   fseek (ifp, base, SEEK_SET);",
          "12647:   if (fgetc(ifp) || fgetc(ifp)-'M' || fgetc(ifp)-'R') return;",
          "12650:   while ((save=ftell(ifp)) < offset) {",
          "12651:     for (tag=i=0; i < 4; i++)",
          "12654:     switch (tag) {",
          "12656:  fseek (ifp, 8, SEEK_CUR);",
          "12657:  high = get2();",
          "12658:  wide = get2();",
          "12659:  break;",
          "12660: #ifdef LIBRAW_LIBRARY_BUILD",
          "12662:     if (!strncasecmp(model,\"DSLR-A100\", 9))",
          "12665:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();",
          "12666:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();",
          "12667:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][0] = get2();",
          "12668:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][2] = get2();",
          "12669:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();",
          "12670:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();",
          "12671:       imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();",
          "12672:       imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();",
          "12673:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();",
          "12674:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();",
          "12676:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();",
          "12677:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();",
          "12678:       imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();",
          "12679:       imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();",
          "12680:       imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();",
          "12681:       imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();",
          "12682:       imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();",
          "12683:       imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();",
          "12684:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] =",
          "12685:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =",
          "12686:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] =",
          "12687:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] =",
          "12688:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =",
          "12689:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =",
          "12690:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] =",
          "12691:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =",
          "12692:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][3] = 0x100;",
          "12693:     }",
          "12694:  break;",
          "12695: #endif",
          "12697:  get4();",
          "12698:  i = strcmp(model,\"DiMAGE A200\") ? 0:3;",
          "12699:  FORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();",
          "12700:  break;",
          "12702:  parse_tiff (ftell(ifp));",
          "12703:  data_offset = offset;",
          "12704:     }",
          "12705:     fseek (ifp, save+len+8, SEEK_SET);",
          "12708:   raw_width  = wide;",
          "",
          "[Added Lines]",
          "13627: int CLASS parse_tiff(int base)",
          "13630:   fseek(ifp, base, SEEK_SET);",
          "13632:   if (order != 0x4949 && order != 0x4d4d)",
          "13633:     return 0;",
          "13635:   while ((doff = get4()))",
          "13636:   {",
          "13637:     fseek(ifp, doff + base, SEEK_SET);",
          "13638:     if (parse_tiff_ifd(base))",
          "13639:       break;",
          "13646:   int max_samp = 0, ties = 0, os, ns, raw = -1, thm = -1, i;",
          "13650:   if (thumb_offset)",
          "13651:   {",
          "13652:     fseek(ifp, thumb_offset, SEEK_SET);",
          "13653:     if (ljpeg_start(&jh, 1))",
          "13654:     {",
          "13655:       if ((unsigned)jh.bits < 17 && (unsigned)jh.wide < 0x10000 && (unsigned)jh.high < 0x10000)",
          "13656:       {",
          "13657:         thumb_misc = jh.bits;",
          "13658:         thumb_width = jh.wide;",
          "13659:         thumb_height = jh.high;",
          "13660:       }",
          "13663:   for (i = tiff_nifds; i--;)",
          "13664:   {",
          "13669:   for (i = 0; i < tiff_nifds; i++)",
          "13670:   {",
          "13672:       max_samp = tiff_ifd[i].samples;",
          "13673:     if (max_samp > 3)",
          "13674:       max_samp = 3;",
          "13675:     os = raw_width * raw_height;",
          "13676:     ns = tiff_ifd[i].t_width * tiff_ifd[i].t_height;",
          "13677:     if (tiff_bps)",
          "13678:     {",
          "13679:       os *= tiff_bps;",
          "13680:       ns *= tiff_ifd[i].bps;",
          "13683:         unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 && (unsigned)tiff_ifd[i].bps < 33 &&",
          "13684:         (unsigned)tiff_ifd[i].samples < 13 && ns && ((ns > os && (ties = 1)) || (ns == os && shot_select == ties++)))",
          "13685:     {",
          "13686:       raw_width = tiff_ifd[i].t_width;",
          "13687:       raw_height = tiff_ifd[i].t_height;",
          "13688:       tiff_bps = tiff_ifd[i].bps;",
          "13690:       data_offset = tiff_ifd[i].offset;",
          "13692:       data_size = tiff_ifd[i].bytes;",
          "13694:       tiff_flip = tiff_ifd[i].t_flip;",
          "13695:       tiff_samples = tiff_ifd[i].samples;",
          "13696:       tile_width = tiff_ifd[i].t_tile_width;",
          "13697:       tile_length = tiff_ifd[i].t_tile_length;",
          "13698:       shutter = tiff_ifd[i].t_shutter;",
          "13702:   if (is_raw == 1 && ties)",
          "13703:     is_raw = ties;",
          "13704:   if (!tile_width)",
          "13705:     tile_width = INT_MAX;",
          "13706:   if (!tile_length)",
          "13707:     tile_length = INT_MAX;",
          "13708:   for (i = tiff_nifds; i--;)",
          "13709:     if (tiff_ifd[i].t_flip)",
          "13710:       tiff_flip = tiff_ifd[i].t_flip;",
          "13712:     switch (tiff_compress)",
          "13713:     {",
          "13714:     case 32767:",
          "13715:       if (tiff_ifd[raw].bytes == raw_width * raw_height)",
          "13716:       {",
          "13717:         tiff_bps = 12;",
          "13718:         load_raw = &CLASS sony_arw2_load_raw;",
          "13719:         break;",
          "13720:       }",
          "13721:       if (!strncasecmp(make, \"Sony\", 4) && tiff_ifd[raw].bytes == raw_width * raw_height * 2)",
          "13722:       {",
          "13723:         tiff_bps = 14;",
          "13724:         load_raw = &CLASS unpacked_load_raw;",
          "13725:         break;",
          "13726:       }",
          "13727:       if (tiff_ifd[raw].bytes * 8 != raw_width * raw_height * tiff_bps)",
          "13728:       {",
          "13729:         raw_height += 8;",
          "13730:         load_raw = &CLASS sony_arw_load_raw;",
          "13731:         break;",
          "13732:       }",
          "13733:       load_flags = 79;",
          "13734:     case 32769:",
          "13735:       load_flags++;",
          "13736:     case 32770:",
          "13737:     case 32773:",
          "13738:       goto slr;",
          "13739:     case 0:",
          "13740:     case 1:",
          "13741: #ifdef LIBRAW_LIBRARY_BUILD",
          "13743:       if (!strncasecmp(make, \"Sony\", 4) && tiff_ifd[raw].bytes == raw_width * raw_height * 2)",
          "13744:       {",
          "13745:         tiff_bps = 14;",
          "13746:         load_raw = &CLASS unpacked_load_raw;",
          "13747:         break;",
          "13748:       }",
          "13749:       if (!strncasecmp(make, \"Nikon\", 5) && !strncmp(software, \"Nikon Scan\", 10))",
          "13750:       {",
          "13751:         load_raw = &CLASS nikon_coolscan_load_raw;",
          "13752:         raw_color = 1;",
          "13753:         filters = 0;",
          "13754:         break;",
          "13755:       }",
          "13756: #endif",
          "13757:       if (!strncmp(make, \"OLYMPUS\", 7) && tiff_ifd[raw].bytes * 2 == raw_width * raw_height * 3)",
          "13758:         load_flags = 24;",
          "13759:       if (tiff_ifd[raw].bytes * 5 == raw_width * raw_height * 8)",
          "13760:       {",
          "13761:         load_flags = 81;",
          "13762:         tiff_bps = 12;",
          "13763:       }",
          "13764:     slr:",
          "13765:       switch (tiff_bps)",
          "13766:       {",
          "13767:       case 8:",
          "13768:         load_raw = &CLASS eight_bit_load_raw;",
          "13769:         break;",
          "13770:       case 12:",
          "13771:         if (tiff_ifd[raw].phint == 2)",
          "13772:           load_flags = 6;",
          "13773:         load_raw = &CLASS packed_load_raw;",
          "13774:         break;",
          "13775:       case 14:",
          "13776:         load_flags = 0;",
          "13777:       case 16:",
          "13778:         load_raw = &CLASS unpacked_load_raw;",
          "13779:         if (!strncmp(make, \"OLYMPUS\", 7) && tiff_ifd[raw].bytes * 7 > raw_width * raw_height)",
          "13780:           load_raw = &CLASS olympus_load_raw;",
          "13781:       }",
          "13782:       break;",
          "13783:     case 6:",
          "13784:     case 7:",
          "13785:     case 99:",
          "13786:       load_raw = &CLASS lossless_jpeg_load_raw;",
          "13787:       break;",
          "13788:     case 262:",
          "13789:       load_raw = &CLASS kodak_262_load_raw;",
          "13790:       break;",
          "13791:     case 34713:",
          "13792:       if ((raw_width + 9) / 10 * 16 * raw_height == tiff_ifd[raw].bytes)",
          "13793:       {",
          "13794:         load_raw = &CLASS packed_load_raw;",
          "13795:         load_flags = 1;",
          "13796:       }",
          "13797:       else if (raw_width * raw_height * 3 == tiff_ifd[raw].bytes * 2)",
          "13798:       {",
          "13799:         load_raw = &CLASS packed_load_raw;",
          "13800:         if (model[0] == 'N')",
          "13801:           load_flags = 80;",
          "13802:       }",
          "13803:       else if (raw_width * raw_height * 3 == tiff_ifd[raw].bytes)",
          "13804:       {",
          "13805:         load_raw = &CLASS nikon_yuv_load_raw;",
          "13806:         gamma_curve(1 / 2.4, 12.92, 1, 4095);",
          "13807:         memset(cblack, 0, sizeof cblack);",
          "13808:         filters = 0;",
          "13809:       }",
          "13810:       else if (raw_width * raw_height * 2 == tiff_ifd[raw].bytes)",
          "13811:       {",
          "13812:         load_raw = &CLASS unpacked_load_raw;",
          "13813:         load_flags = 4;",
          "13814:         order = 0x4d4d;",
          "13815:       }",
          "13816:       else",
          "13818:           if (raw_width * raw_height * 3 == tiff_ifd[raw].bytes * 2)",
          "13819:       {",
          "13820:         load_raw = &CLASS packed_load_raw;",
          "13821:         load_flags = 80;",
          "13822:       }",
          "13823:       else if (tiff_ifd[raw].rows_per_strip && tiff_ifd[raw].strip_offsets_count &&",
          "13824:                tiff_ifd[raw].strip_offsets_count == tiff_ifd[raw].strip_byte_counts_count)",
          "13825:       {",
          "13826:         int fit = 1;",
          "13827:         for (int i = 0; i < tiff_ifd[raw].strip_byte_counts_count - 1; i++) // all but last",
          "13828:           if (tiff_ifd[raw].strip_byte_counts[i] * 2 != tiff_ifd[raw].rows_per_strip * raw_width * 3)",
          "13830:             fit = 0;",
          "13833:         if (fit)",
          "13834:           load_raw = &CLASS nikon_load_striped_packed_raw;",
          "13835:         else",
          "13836:           load_raw = &CLASS nikon_load_raw; // fallback",
          "13837:       }",
          "13838:       else",
          "13840:         load_raw = &CLASS nikon_load_raw;",
          "13841:       break;",
          "13842:     case 65535:",
          "13843:       load_raw = &CLASS pentax_load_raw;",
          "13844:       break;",
          "13845:     case 65000:",
          "13846:       switch (tiff_ifd[raw].phint)",
          "13847:       {",
          "13848:       case 2:",
          "13849:         load_raw = &CLASS kodak_rgb_load_raw;",
          "13850:         filters = 0;",
          "13851:         break;",
          "13852:       case 6:",
          "13853:         load_raw = &CLASS kodak_ycbcr_load_raw;",
          "13854:         filters = 0;",
          "13855:         break;",
          "13856:       case 32803:",
          "13857:         load_raw = &CLASS kodak_65000_load_raw;",
          "13858:       }",
          "13859:     case 32867:",
          "13860:     case 34892:",
          "13861:       break;",
          "13862: #ifdef LIBRAW_LIBRARY_BUILD",
          "13863:     case 8:",
          "13864:       break;",
          "13865: #endif",
          "13866:     default:",
          "13867:       is_raw = 0;",
          "13870:     if (((tiff_samples == 3 && tiff_ifd[raw].bytes && tiff_bps != 14 && (tiff_compress & -16) != 32768) ||",
          "13871:          (tiff_bps == 8 && strncmp(make, \"Phase\", 5) && !strcasestr(make, \"Kodak\") && !strstr(model2, \"DEBUG RAW\"))) &&",
          "13872:         strncmp(software, \"Nikon Scan\", 10))",
          "13874:   for (i = 0; i < tiff_nifds; i++)",
          "13875:     if (i != raw &&",
          "13877:         && tiff_ifd[i].bps > 0 && tiff_ifd[i].bps < 33 && tiff_ifd[i].phint != 32803 && tiff_ifd[i].phint != 34892 &&",
          "13878:         unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&",
          "13879:         tiff_ifd[i].t_width * tiff_ifd[i].t_height / (SQR(tiff_ifd[i].bps) + 1) >",
          "13880:             thumb_width * thumb_height / (SQR(thumb_misc) + 1) &&",
          "13881:         tiff_ifd[i].comp != 34892)",
          "13882:     {",
          "13883:       thumb_width = tiff_ifd[i].t_width;",
          "13887:       thumb_misc = tiff_ifd[i].bps;",
          "13890:   if (thm >= 0)",
          "13891:   {",
          "13893:     switch (tiff_ifd[thm].comp)",
          "13894:     {",
          "13895:     case 0:",
          "13896:       write_thumb = &CLASS layer_thumb;",
          "13897:       break;",
          "13898:     case 1:",
          "13899:       if (tiff_ifd[thm].bps <= 8)",
          "13900:         write_thumb = &CLASS ppm_thumb;",
          "13901:       else if (!strncmp(make, \"Imacon\", 6))",
          "13902:         write_thumb = &CLASS ppm16_thumb;",
          "13903:       else",
          "13904:         thumb_load_raw = &CLASS kodak_thumb_load_raw;",
          "13905:       break;",
          "13906:     case 65000:",
          "13907:       thumb_load_raw = tiff_ifd[thm].phint == 6 ? &CLASS kodak_ycbcr_load_raw : &CLASS kodak_rgb_load_raw;",
          "13912: void CLASS parse_minolta(int base)",
          "13914:   int save, tag, len, offset, high = 0, wide = 0, i, c;",
          "13915:   short sorder = order;",
          "13917:   fseek(ifp, base, SEEK_SET);",
          "13918:   if (fgetc(ifp) || fgetc(ifp) - 'M' || fgetc(ifp) - 'R')",
          "13919:     return;",
          "13922:   while ((save = ftell(ifp)) < offset)",
          "13923:   {",
          "13924:     for (tag = i = 0; i < 4; i++)",
          "13927:     switch (tag)",
          "13931:       high = get2();",
          "13932:       wide = get2();",
          "13933:       break;",
          "13934: #ifdef LIBRAW_LIBRARY_BUILD",
          "13936:       if (!strncasecmp(model, \"DSLR-A100\", 9))",
          "13937:       {",
          "13938:         fseek(ifp, 8, SEEK_CUR);",
          "13939:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();",
          "13940:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();",
          "13941:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][0] = get2();",
          "13942:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][2] = get2();",
          "13943:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();",
          "13944:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();",
          "13945:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();",
          "13946:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();",
          "13947:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();",
          "13948:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();",
          "13949:         get4();",
          "13950:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();",
          "13951:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();",
          "13952:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();",
          "13953:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();",
          "13954:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();",
          "13955:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();",
          "13956:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();",
          "13957:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();",
          "13958:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] =",
          "13959:             imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =",
          "13960:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] =",
          "13961:                     imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] =",
          "13962:                         imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =",
          "13963:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =",
          "13964:                                 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1] =",
          "13965:                                     imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] =",
          "13966:                                         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] =",
          "13967:                                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =",
          "13968:                                                 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][1] =",
          "13969:                                                     imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][3] = 0x100;",
          "13970:       }",
          "13971:       break;",
          "13972: #endif",
          "13975:       i = strcmp(model, \"DiMAGE A200\") ? 0 : 3;",
          "13976:       FORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();",
          "13977:       break;",
          "13979:       parse_tiff(ftell(ifp));",
          "13980:       data_offset = offset;",
          "13981:     }",
          "13982:     fseek(ifp, save + len + 8, SEEK_SET);",
          "13985:   raw_width = wide;",
          "",
          "---------------",
          "--- Hunk 105 ---",
          "[Context before]",
          "12719:   const char *file, *ext;",
          "12720:   char *jname, *jfile, *jext;",
          "12721: #ifndef LIBRAW_LIBRARY_BUILD",
          "12723: #else",
          "12724: #if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)",
          "12726:   {",
          "12739:   }",
          "12740: #endif",
          "12746: #endif",
          "12751: #ifndef LIBRAW_LIBRARY_BUILD",
          "12753: #else",
          "12755: #endif",
          "12756:   file++;",
          "12761:   jfile = file - ifname + jname;",
          "12774:       }",
          "12776:     }",
          "12777: #ifndef LIBRAW_LIBRARY_BUILD",
          "12780: #ifdef DCRAW_VERBOSE",
          "12781:       if (verbose)",
          "12783: #endif",
          "12785:       thumb_offset = 0;",
          "12786:       is_raw = 1;",
          "12788:     }",
          "12789:   }",
          "12790: #else",
          "12803: #endif",
          "12804:   if (!timestamp)",
          "12806: #ifdef LIBRAW_LIBRARY_BUILD",
          "12808: #endif",
          "12809: #ifdef DCRAW_VERBOSE",
          "12811: #endif",
          "12814: #ifndef LIBRAW_LIBRARY_BUILD",
          "12815:   ifp = save;",
          "12816: #endif",
          "",
          "[Removed Lines]",
          "12722:   FILE *save=ifp;",
          "12725:   if(ifp->wfname())",
          "12727:    std::wstring rawfile(ifp->wfname());",
          "12728:    rawfile.replace(rawfile.length()-3,3,L\"JPG\");",
          "12729:    if(!ifp->subfile_open(rawfile.c_str()))",
          "12730:    {",
          "12731:     parse_tiff (12);",
          "12732:     thumb_offset = 0;",
          "12733:     is_raw = 1;",
          "12734:     ifp->subfile_close();",
          "12735:    }",
          "12736:    else",
          "12737:     imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;",
          "12738:   return;",
          "12741:   if(!ifp->fname())",
          "12742:       {",
          "12743:           imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;",
          "12744:           return;",
          "12745:       }",
          "12748:   ext  = strrchr (ifname, '.');",
          "12749:   file = strrchr (ifname, '/');",
          "12750:   if (!file) file = strrchr (ifname, '\\\\');",
          "12752:   if (!file) file = ifname-1;",
          "12754:   if (!file) file = (char*)ifname-1;",
          "12757:   if (!ext || strlen(ext) != 4 || ext-file != 8) return;",
          "12758:   jname = (char *) malloc (strlen(ifname) + 1);",
          "12759:   merror (jname, \"parse_external_jpeg()\");",
          "12760:   strcpy (jname, ifname);",
          "12762:   jext  = ext  - ifname + jname;",
          "12763:   if (strcasecmp (ext, \".jpg\")) {",
          "12764:     strcpy (jext, isupper(ext[1]) ? \".JPG\":\".jpg\");",
          "12765:     if (isdigit(*file)) {",
          "12766:       memcpy (jfile, file+4, 4);",
          "12767:       memcpy (jfile+4, file, 4);",
          "12768:     }",
          "12769:   } else",
          "12770:     while (isdigit(*--jext)) {",
          "12771:       if (*jext != '9') {",
          "12772:  (*jext)++;",
          "12773:  break;",
          "12778:   if (strcmp (jname, ifname)) {",
          "12779:     if ((ifp = fopen (jname, \"rb\"))) {",
          "12782:  fprintf (stderr,_(\"Reading metadata from %s ...\\n\"), jname);",
          "12784:       parse_tiff (12);",
          "12787:       fclose (ifp);",
          "12791:   if (strcmp (jname, ifname))",
          "12792:       {",
          "12793:           if(!ifp->subfile_open(jname))",
          "12794:               {",
          "12795:                   parse_tiff (12);",
          "12796:                   thumb_offset = 0;",
          "12797:                   is_raw = 1;",
          "12798:                   ifp->subfile_close();",
          "12799:               }",
          "12800:           else",
          "12801:               imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;",
          "12802:       }",
          "12805:       {",
          "12807:           imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;",
          "12810:           fprintf (stderr,_(\"Failed to read metadata from %s\\n\"), jname);",
          "12812:       }",
          "12813:   free (jname);",
          "",
          "[Added Lines]",
          "13999:   FILE *save = ifp;",
          "14002:   if (ifp->wfname())",
          "14004:     std::wstring rawfile(ifp->wfname());",
          "14005:     rawfile.replace(rawfile.length() - 3, 3, L\"JPG\");",
          "14006:     if (!ifp->subfile_open(rawfile.c_str()))",
          "14007:     {",
          "14008:       parse_tiff(12);",
          "14009:       thumb_offset = 0;",
          "14010:       is_raw = 1;",
          "14011:       ifp->subfile_close();",
          "14012:     }",
          "14013:     else",
          "14014:       imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;",
          "14015:     return;",
          "14018:   if (!ifp->fname())",
          "14019:   {",
          "14020:     imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;",
          "14021:     return;",
          "14022:   }",
          "14025:   ext = strrchr(ifname, '.');",
          "14026:   file = strrchr(ifname, '/');",
          "14027:   if (!file)",
          "14028:     file = strrchr(ifname, '\\\\');",
          "14030:   if (!file)",
          "14031:     file = ifname - 1;",
          "14033:   if (!file)",
          "14034:     file = (char *)ifname - 1;",
          "14037:   if (!ext || strlen(ext) != 4 || ext - file != 8)",
          "14038:     return;",
          "14039:   jname = (char *)malloc(strlen(ifname) + 1);",
          "14040:   merror(jname, \"parse_external_jpeg()\");",
          "14041:   strcpy(jname, ifname);",
          "14043:   jext = ext - ifname + jname;",
          "14044:   if (strcasecmp(ext, \".jpg\"))",
          "14045:   {",
          "14046:     strcpy(jext, isupper(ext[1]) ? \".JPG\" : \".jpg\");",
          "14047:     if (isdigit(*file))",
          "14048:     {",
          "14049:       memcpy(jfile, file + 4, 4);",
          "14050:       memcpy(jfile + 4, file, 4);",
          "14051:     }",
          "14052:   }",
          "14053:   else",
          "14054:     while (isdigit(*--jext))",
          "14055:     {",
          "14056:       if (*jext != '9')",
          "14057:       {",
          "14058:         (*jext)++;",
          "14059:         break;",
          "14064:   if (strcmp(jname, ifname))",
          "14065:   {",
          "14066:     if ((ifp = fopen(jname, \"rb\")))",
          "14067:     {",
          "14070:         fprintf(stderr, _(\"Reading metadata from %s ...\\n\"), jname);",
          "14072:       parse_tiff(12);",
          "14075:       fclose(ifp);",
          "14079:   if (strcmp(jname, ifname))",
          "14080:   {",
          "14081:     if (!ifp->subfile_open(jname))",
          "14082:     {",
          "14083:       parse_tiff(12);",
          "14084:       thumb_offset = 0;",
          "14085:       is_raw = 1;",
          "14086:       ifp->subfile_close();",
          "14087:     }",
          "14088:     else",
          "14089:       imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;",
          "14090:   }",
          "14093:   {",
          "14095:     imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;",
          "14098:     fprintf(stderr, _(\"Failed to read metadata from %s\\n\"), jname);",
          "14100:   }",
          "14101:   free(jname);",
          "",
          "---------------",
          "--- Hunk 106 ---",
          "[Context before]",
          "12823: void CLASS ciff_block_1030()",
          "12824: {",
          "12830:   bpp = get2();",
          "12837:       }",
          "12838:       white[row][col] = bitbuf >> (vbits -= bpp) & ~(-1 << bpp);",
          "12839:     }",
          "",
          "[Removed Lines]",
          "12825:   static const ushort key[] = { 0x410, 0x45f3 };",
          "12826:   int i, bpp, row, col, vbits=0;",
          "12827:   unsigned long bitbuf=0;",
          "12829:   if ((get2(),get4()) != 0x80008 || !get4()) return;",
          "12831:   if (bpp != 10 && bpp != 12) return;",
          "12832:   for (i=row=0; row < 8; row++)",
          "12833:     for (col=0; col < 8; col++) {",
          "12834:       if (vbits < bpp) {",
          "12835:  bitbuf = bitbuf << 16 | (get2() ^ key[i++ & 1]);",
          "12836:  vbits += 16;",
          "",
          "[Added Lines]",
          "14113:   static const ushort key[] = {0x410, 0x45f3};",
          "14114:   int i, bpp, row, col, vbits = 0;",
          "14115:   unsigned long bitbuf = 0;",
          "14117:   if ((get2(), get4()) != 0x80008 || !get4())",
          "14118:     return;",
          "14120:   if (bpp != 10 && bpp != 12)",
          "14121:     return;",
          "14122:   for (i = row = 0; row < 8; row++)",
          "14123:     for (col = 0; col < 8; col++)",
          "14124:     {",
          "14125:       if (vbits < bpp)",
          "14126:       {",
          "14127:         bitbuf = bitbuf << 16 | (get2() ^ key[i++ & 1]);",
          "14128:         vbits += 16;",
          "",
          "---------------",
          "--- Hunk 107 ---",
          "[Context before]",
          "12843:    Parse a CIFF file, better known as Canon CRW format.",
          "12847: {",
          "12852:   tboff = get4() + offset;",
          "12854:   nrecs = get2();",
          "12857:     type = get2();",
          "12859:     save = ftell(ifp) + 4;",
          "12863:     }",
          "12864: #ifdef LIBRAW_LIBRARY_BUILD",
          "12866: #endif",
          "12867:     if (type == 0x0810)",
          "12873:     }",
          "12875:       width = get4();",
          "12876:       height = get4();",
          "12877:       pixel_aspect = int_to_float(get4());",
          "12878:       flip = get4();",
          "12879:     }",
          "12881:       tiff_compress = get4();",
          "12883:       thumb_offset = ftell(ifp);",
          "12884:       thumb_length = len;",
          "12885:     }",
          "12889: #ifdef LIBRAW_LIBRARY_BUILD",
          "12890:       imgdata.lens.makernotes.CurAp = aperture;",
          "12891: #endif",
          "12892:     }",
          "12896: #ifdef LIBRAW_LIBRARY_BUILD",
          "12898:       imgdata.lens.makernotes.CurAp = aperture;",
          "12899: #else",
          "12901: #endif",
          "12907:     }",
          "12915:       }",
          "12916:     }",
          "12917: #ifdef LIBRAW_LIBRARY_BUILD",
          "12918:     if (type == 0x10a9)",
          "12925:     if (type == 0x102d)",
          "12931:     if (type == 0x580b)",
          "12932:       {",
          "12958:       FORC4 cam_mul[c ^ (c >> 1)] = get2();",
          "12959:     }",
          "12964:       raw_height = get2();",
          "12965:     }",
          "12967:       iso_speed = len & 0xffff;",
          "12968:     }",
          "12970: #ifdef LIBRAW_LIBRARY_BUILD",
          "12972:       imgdata.lens.makernotes.FocalType = len & 0xffff;",
          "12974:         imgdata.lens.makernotes.CanonFocalUnits = 32;",
          "12977:       }",
          "12978:       focal_len = imgdata.lens.makernotes.CurFocal;",
          "12979: #else",
          "12980:       focal_len = len >> 16;",
          "12982: #endif",
          "12983:     }",
          "12987:     if (type == 0x5834)",
          "12990: #ifdef LIBRAW_LIBRARY_BUILD",
          "12992: #endif",
          "12996: #ifdef LOCALTIME",
          "12997:     if ((type | 0x4000) == 0x580e)",
          "12999: #endif",
          "13001:   }",
          "13002: }",
          "",
          "[Removed Lines]",
          "12846: void CLASS parse_ciff (int offset, int length, int depth)",
          "12848:   int tboff, nrecs, c, type, len, save, wbi=-1;",
          "12849:   ushort key[] = { 0x410, 0x45f3 };",
          "12851:   fseek (ifp, offset+length-4, SEEK_SET);",
          "12853:   fseek (ifp, tboff, SEEK_SET);",
          "12855:   if ((nrecs | depth) > 127) return;",
          "12856:   while (nrecs--) {",
          "12858:     len  = get4();",
          "12860:     fseek (ifp, offset+get4(), SEEK_SET);",
          "12861:     if ((((type >> 8) + 8) | 8) == 0x38) {",
          "12865:     if (type == 0x3004) parse_ciff (ftell(ifp), len, depth+1);",
          "12868:       fread (artist, 64, 1, ifp);",
          "12869:     if (type == 0x080a) {",
          "12870:       fread (make, 64, 1, ifp);",
          "12871:       fseek (ifp, strbuflen(make) - 63, SEEK_CUR);",
          "12872:       fread (model, 64, 1, ifp);",
          "12874:     if (type == 0x1810) {",
          "12882:     if (type == 0x2007) {",
          "12886:     if (type == 0x1818) {",
          "12887:       shutter = powf64(2.0f, -int_to_float((get4(),get4())));",
          "12888:       aperture = powf64(2.0f, int_to_float(get4())/2);",
          "12893:     if (type == 0x102a) {",
          "12895:       iso_speed = powf64(2.0f, ((get2(),get2()) + get2())/32.0f - 5.0f) * 100.0f;",
          "12897:       aperture  = _CanonConvertAperture((get2(),get2()));",
          "12900:       aperture  = powf64(2.0, (get2(),(short)get2())/64.0);",
          "12902:       shutter   = powf64(2.0,-((short)get2())/32.0);",
          "12903:       wbi = (get2(),get2());",
          "12904:       if (wbi > 17) wbi = 0;",
          "12905:       fseek (ifp, 32, SEEK_CUR);",
          "12906:       if (shutter > 1e6) shutter = get2()/10.0;",
          "12908:     if (type == 0x102c) {",
          "12910:  fseek (ifp, 118, SEEK_CUR);",
          "12911:  FORC4 cam_mul[c ^ 2] = get2();",
          "12913:  fseek (ifp, 98, SEEK_CUR);",
          "12914:  FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2();",
          "12919:       {",
          "12920:  INT64 o = ftell(ifp);",
          "12921:  fseek (ifp, (0x5<<1), SEEK_CUR);",
          "12922:  Canon_WBpresets(0,0);",
          "12923:  fseek(ifp,o,SEEK_SET);",
          "12924:       }",
          "12926:       {",
          "12927:  INT64 o = ftell(ifp);",
          "12928:  Canon_CameraSettings();",
          "12929:  fseek(ifp,o,SEEK_SET);",
          "12930:       }",
          "12933:         if (strcmp(model,\"Canon EOS D30\")) sprintf(imgdata.shootinginfo.BodySerial, \"%d\", len);",
          "12934:         else sprintf(imgdata.shootinginfo.BodySerial, \"%0x-%05d\", len>>16, len&0xffff);",
          "12935:       }",
          "12936: #endif",
          "12937:     if (type == 0x0032) {",
          "12939:  fseek (ifp, 72, SEEK_CUR);",
          "12940:  FORC4 cam_mul[c ^ (c >> 1)] = 1024.0 / get2();",
          "12942:       } else if (!cam_mul[0]) {",
          "12944:    c = (strstr(model,\"Pro1\") ?",
          "12945:        \"012346000000000000\":\"01345:000000006008\")[LIM(0,wbi,17)]-'0'+ 2;",
          "12947:    c = \"023457000000006000\"[LIM(0,wbi,17)]-'0';",
          "12948:    key[0] = key[1] = 0;",
          "12949:  }",
          "12950:  fseek (ifp, 78 + c*8, SEEK_CUR);",
          "12951:  FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2() ^ key[c & 1];",
          "12952:  if (!wbi) cam_mul[0] = -1;",
          "12953:       }",
          "12954:     }",
          "12956:       if (len > 66) wbi = \"0134567028\"[LIM(0,wbi,9)]-'0';",
          "12957:       fseek (ifp, 2 + wbi*8, SEEK_CUR);",
          "12960:     if (type == 0x1030 && wbi>=0 && (0x18040 >> wbi & 1))",
          "12962:     if (type == 0x1031) {",
          "12963:       raw_width = (get2(),get2());",
          "12966:     if (type == 0x501c) {",
          "12969:     if (type == 0x5029) {",
          "12971:       imgdata.lens.makernotes.CurFocal  = len >> 16;",
          "12973:       if (imgdata.lens.makernotes.FocalType == 2) {",
          "12975:  if(imgdata.lens.makernotes.CanonFocalUnits>1)",
          "12976:    imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "12981:       if ((len & 0xffff) == 2) focal_len /= 32;",
          "12984:     if (type == 0x5813) flash_used = int_to_float(len);",
          "12985:     if (type == 0x5814) canon_ev   = int_to_float(len);",
          "12986:     if (type == 0x5817) shot_order = len;",
          "12988:       {",
          "12989:          unique_id  = len;",
          "12991:          setCanonBodyFeatures(unique_id);",
          "12993:       }",
          "12994:     if (type == 0x580e) timestamp  = len;",
          "12995:     if (type == 0x180e) timestamp  = get4();",
          "12998:       timestamp = mktime (gmtime (&timestamp));",
          "13000:     fseek (ifp, save, SEEK_SET);",
          "",
          "[Added Lines]",
          "14138: void CLASS parse_ciff(int offset, int length, int depth)",
          "14140:   int tboff, nrecs, c, type, len, save, wbi = -1;",
          "14141:   ushort key[] = {0x410, 0x45f3};",
          "14143:   fseek(ifp, offset + length - 4, SEEK_SET);",
          "14145:   fseek(ifp, tboff, SEEK_SET);",
          "14147:   if ((nrecs | depth) > 127)",
          "14148:     return;",
          "14149:   while (nrecs--)",
          "14150:   {",
          "14152:     len = get4();",
          "14154:     fseek(ifp, offset + get4(), SEEK_SET);",
          "14155:     if ((((type >> 8) + 8) | 8) == 0x38)",
          "14156:     {",
          "14160:     if (type == 0x3004)",
          "14161:       parse_ciff(ftell(ifp), len, depth + 1);",
          "14164:       fread(artist, 64, 1, ifp);",
          "14165:     if (type == 0x080a)",
          "14166:     {",
          "14167:       fread(make, 64, 1, ifp);",
          "14168:       fseek(ifp, strbuflen(make) - 63, SEEK_CUR);",
          "14169:       fread(model, 64, 1, ifp);",
          "14171:     if (type == 0x1810)",
          "14172:     {",
          "14180:     if (type == 0x2007)",
          "14181:     {",
          "14185:     if (type == 0x1818)",
          "14186:     {",
          "14187:       shutter = powf64(2.0f, -int_to_float((get4(), get4())));",
          "14188:       aperture = powf64(2.0f, int_to_float(get4()) / 2);",
          "14193:     if (type == 0x102a)",
          "14194:     {",
          "14196:       iso_speed = powf64(2.0f, ((get2(), get2()) + get2()) / 32.0f - 5.0f) * 100.0f;",
          "14198:       aperture = _CanonConvertAperture((get2(), get2()));",
          "14201:       aperture = powf64(2.0, (get2(), (short)get2()) / 64.0);",
          "14203:       shutter = powf64(2.0, -((short)get2()) / 32.0);",
          "14204:       wbi = (get2(), get2());",
          "14205:       if (wbi > 17)",
          "14206:         wbi = 0;",
          "14207:       fseek(ifp, 32, SEEK_CUR);",
          "14208:       if (shutter > 1e6)",
          "14209:         shutter = get2() / 10.0;",
          "14211:     if (type == 0x102c)",
          "14212:     {",
          "14213:       if (get2() > 512)",
          "14215:         fseek(ifp, 118, SEEK_CUR);",
          "14216:         FORC4 cam_mul[c ^ 2] = get2();",
          "14217:       }",
          "14218:       else",
          "14220:         fseek(ifp, 98, SEEK_CUR);",
          "14221:         FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2();",
          "14226:     {",
          "14227:       INT64 o = ftell(ifp);",
          "14228:       fseek(ifp, (0x5 << 1), SEEK_CUR);",
          "14229:       Canon_WBpresets(0, 0);",
          "14230:       fseek(ifp, o, SEEK_SET);",
          "14231:     }",
          "14233:     {",
          "14234:       INT64 o = ftell(ifp);",
          "14235:       Canon_CameraSettings();",
          "14236:       fseek(ifp, o, SEEK_SET);",
          "14237:     }",
          "14239:     {",
          "14240:       if (strcmp(model, \"Canon EOS D30\"))",
          "14241:         sprintf(imgdata.shootinginfo.BodySerial, \"%d\", len);",
          "14242:       else",
          "14243:         sprintf(imgdata.shootinginfo.BodySerial, \"%0x-%05d\", len >> 16, len & 0xffff);",
          "14244:     }",
          "14245: #endif",
          "14246:     if (type == 0x0032)",
          "14247:     {",
          "14248:       if (len == 768)",
          "14250:         fseek(ifp, 72, SEEK_CUR);",
          "14251:         FORC4 cam_mul[c ^ (c >> 1)] = 1024.0 / get2();",
          "14252:         if (!wbi)",
          "14254:       }",
          "14255:       else if (!cam_mul[0])",
          "14258:           c = (strstr(model, \"Pro1\") ? \"012346000000000000\" : \"01345:000000006008\")[LIM(0, wbi, 17)] - '0' + 2;",
          "14259:         else",
          "14261:           c = \"023457000000006000\"[LIM(0, wbi, 17)] - '0';",
          "14262:           key[0] = key[1] = 0;",
          "14263:         }",
          "14264:         fseek(ifp, 78 + c * 8, SEEK_CUR);",
          "14265:         FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2() ^ key[c & 1];",
          "14266:         if (!wbi)",
          "14267:           cam_mul[0] = -1;",
          "14268:       }",
          "14269:     }",
          "14270:     if (type == 0x10a9)",
          "14272:       if (len > 66)",
          "14273:         wbi = \"0134567028\"[LIM(0, wbi, 9)] - '0';",
          "14274:       fseek(ifp, 2 + wbi * 8, SEEK_CUR);",
          "14277:     if (type == 0x1030 && wbi >= 0 && (0x18040 >> wbi & 1))",
          "14279:     if (type == 0x1031)",
          "14280:     {",
          "14281:       raw_width = (get2(), get2());",
          "14284:     if (type == 0x501c)",
          "14285:     {",
          "14288:     if (type == 0x5029)",
          "14289:     {",
          "14291:       imgdata.lens.makernotes.CurFocal = len >> 16;",
          "14293:       if (imgdata.lens.makernotes.FocalType == 2)",
          "14294:       {",
          "14296:         if (imgdata.lens.makernotes.CanonFocalUnits > 1)",
          "14297:           imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "14302:       if ((len & 0xffff) == 2)",
          "14303:         focal_len /= 32;",
          "14306:     if (type == 0x5813)",
          "14307:       flash_used = int_to_float(len);",
          "14308:     if (type == 0x5814)",
          "14309:       canon_ev = int_to_float(len);",
          "14310:     if (type == 0x5817)",
          "14311:       shot_order = len;",
          "14313:     {",
          "14314:       unique_id = len;",
          "14316:       setCanonBodyFeatures(unique_id);",
          "14318:     }",
          "14319:     if (type == 0x580e)",
          "14320:       timestamp = len;",
          "14321:     if (type == 0x180e)",
          "14322:       timestamp = get4();",
          "14325:       timestamp = mktime(gmtime(&timestamp));",
          "14327:     fseek(ifp, save, SEEK_SET);",
          "",
          "---------------",
          "--- Hunk 108 ---",
          "[Context before]",
          "13006:   char line[128], *val;",
          "13007:   struct tm t;",
          "13015:     else",
          "13016:       val = line + strbuflen(line);",
          "13022:       thumb_offset = atoi(val);",
          "13024:       raw_width = atoi(val);",
          "13026:       raw_height = atoi(val);",
          "13028:       thumb_width = atoi(val);",
          "13030:       thumb_height = atoi(val);",
          "13032:   data_offset = thumb_offset + thumb_width * thumb_height * 2;",
          "13033:   t.tm_year -= 1900;",
          "13034:   t.tm_mon -= 1;",
          "13035:   if (mktime(&t) > 0)",
          "13036:     timestamp = mktime(&t);",
          "13039:   write_thumb = &CLASS rollei_thumb;",
          "13040: }",
          "",
          "[Removed Lines]",
          "13009:   fseek (ifp, 0, SEEK_SET);",
          "13010:   memset (&t, 0, sizeof t);",
          "13011:   do {",
          "13012:     fgets (line, 128, ifp);",
          "13013:     if ((val = strchr(line,'=')))",
          "13017:     if (!strcmp(line,\"DAT\"))",
          "13018:       sscanf (val, \"%d.%d.%d\", &t.tm_mday, &t.tm_mon, &t.tm_year);",
          "13019:     if (!strcmp(line,\"TIM\"))",
          "13020:       sscanf (val, \"%d:%d:%d\", &t.tm_hour, &t.tm_min, &t.tm_sec);",
          "13021:     if (!strcmp(line,\"HDR\"))",
          "13023:     if (!strcmp(line,\"X  \"))",
          "13025:     if (!strcmp(line,\"Y  \"))",
          "13027:     if (!strcmp(line,\"TX \"))",
          "13029:     if (!strcmp(line,\"TY \"))",
          "13031:   } while (strncmp(line,\"EOHD\",4));",
          "13037:   strcpy (make, \"Rollei\");",
          "13038:   strcpy (model,\"d530flex\");",
          "",
          "[Added Lines]",
          "14336:   fseek(ifp, 0, SEEK_SET);",
          "14337:   memset(&t, 0, sizeof t);",
          "14338:   do",
          "14339:   {",
          "14340:     fgets(line, 128, ifp);",
          "14341:     if ((val = strchr(line, '=')))",
          "14345:     if (!strcmp(line, \"DAT\"))",
          "14346:       sscanf(val, \"%d.%d.%d\", &t.tm_mday, &t.tm_mon, &t.tm_year);",
          "14347:     if (!strcmp(line, \"TIM\"))",
          "14348:       sscanf(val, \"%d:%d:%d\", &t.tm_hour, &t.tm_min, &t.tm_sec);",
          "14349:     if (!strcmp(line, \"HDR\"))",
          "14351:     if (!strcmp(line, \"X  \"))",
          "14353:     if (!strcmp(line, \"Y  \"))",
          "14355:     if (!strcmp(line, \"TX \"))",
          "14357:     if (!strcmp(line, \"TY \"))",
          "14359:   } while (strncmp(line, \"EOHD\", 4));",
          "14365:   strcpy(make, \"Rollei\");",
          "14366:   strcpy(model, \"d530flex\");",
          "",
          "---------------",
          "--- Hunk 109 ---",
          "[Context before]",
          "13045:   char str[8], *cp;",
          "13047:   order = 0x4949;",
          "13049:   entries = get4();",
          "13060:   make[63] = 0;",
          "13064:   }",
          "13066:   raw_height = get2();",
          "13067:   load_raw = &CLASS unpacked_load_raw;",
          "13069:   thumb_height = get2();",
          "13070:   write_thumb = &CLASS ppm_thumb;",
          "13071:   maximum = 0x3fff;",
          "13072: }",
          "13075: {",
          "13076:   unsigned entries, tag, type, len, data, save, i, c;",
          "13077:   float romm_cam[3][3];",
          "13078:   char *cp;",
          "13082:   order = get4() & 0xffff;",
          "13085:   entries = get4();",
          "13086:   get4();",
          "13089:     type = get4();",
          "13091:     data = get4();",
          "13092:     save = ftell(ifp);",
          "13096: #ifdef LIBRAW_LIBRARY_BUILD",
          "13097:     case 0x0102:",
          "13098:       stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "13103:       }",
          "13104:       setPhaseOneFeatures(unique_id);",
          "13105:       break;",
          "13106:     case 0x0401:",
          "13109:       break;",
          "13110:     case 0x0403:",
          "13113:       break;",
          "13114:     case 0x0410:",
          "13115:       stmread(imgdata.lens.makernotes.body, len, ifp);",
          "",
          "[Removed Lines]",
          "13048:   fseek (ifp, 4, SEEK_SET);",
          "13050:   fseek (ifp, get4(), SEEK_SET);",
          "13051:   while (entries--) {",
          "13052:     off = get4(); get4();",
          "13053:     fread (str, 8, 1, ifp);",
          "13054:     if (!strcmp(str,\"META\"))   meta_offset = off;",
          "13055:     if (!strcmp(str,\"THUMB\")) thumb_offset = off;",
          "13056:     if (!strcmp(str,\"RAW0\"))   data_offset = off;",
          "13057:   }",
          "13058:   fseek (ifp, meta_offset+20, SEEK_SET);",
          "13059:   fread (make, 64, 1, ifp);",
          "13061:   if ((cp = strchr(make,' '))) {",
          "13062:     strcpy (model, cp+1);",
          "13065:   raw_width  = get2();",
          "13068:   thumb_width = (get4(),get2());",
          "13074: void CLASS parse_phase_one (int base)",
          "13080:   memset (&ph1, 0, sizeof ph1);",
          "13081:   fseek (ifp, base, SEEK_SET);",
          "13084:   fseek (ifp, get4()+base, SEEK_SET);",
          "13087:   while (entries--) {",
          "13088:     tag  = get4();",
          "13090:     len  = get4();",
          "13093:     fseek (ifp, base+data, SEEK_SET);",
          "13094:     switch (tag) {",
          "13099:       if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49)) {",
          "13100:         unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;",
          "13101:       } else {",
          "13102:         unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;",
          "13107:       if (type == 4) imgdata.lens.makernotes.CurAp =  powf64(2.0f, (int_to_float(data)/2.0f));",
          "13108:       else imgdata.lens.makernotes.CurAp = powf64(2.0f, (getreal(type)/2.0f));",
          "13111:       if (type == 4) imgdata.lens.makernotes.CurFocal =  int_to_float(data);",
          "13112:       else imgdata.lens.makernotes.CurFocal = getreal(type);",
          "",
          "[Added Lines]",
          "14376:   fseek(ifp, 4, SEEK_SET);",
          "14378:   fseek(ifp, get4(), SEEK_SET);",
          "14379:   while (entries--)",
          "14380:   {",
          "14381:     off = get4();",
          "14382:     get4();",
          "14383:     fread(str, 8, 1, ifp);",
          "14384:     if (!strcmp(str, \"META\"))",
          "14385:       meta_offset = off;",
          "14386:     if (!strcmp(str, \"THUMB\"))",
          "14387:       thumb_offset = off;",
          "14388:     if (!strcmp(str, \"RAW0\"))",
          "14389:       data_offset = off;",
          "14390:   }",
          "14391:   fseek(ifp, meta_offset + 20, SEEK_SET);",
          "14392:   fread(make, 64, 1, ifp);",
          "14394:   if ((cp = strchr(make, ' ')))",
          "14395:   {",
          "14396:     strcpy(model, cp + 1);",
          "14399:   raw_width = get2();",
          "14402:   thumb_width = (get4(), get2());",
          "14408: void CLASS parse_phase_one(int base)",
          "14414:   memset(&ph1, 0, sizeof ph1);",
          "14415:   fseek(ifp, base, SEEK_SET);",
          "14417:   if (get4() >> 8 != 0x526177)",
          "14419:   fseek(ifp, get4() + base, SEEK_SET);",
          "14422:   while (entries--)",
          "14423:   {",
          "14424:     tag = get4();",
          "14426:     len = get4();",
          "14429:     fseek(ifp, base + data, SEEK_SET);",
          "14430:     switch (tag)",
          "14431:     {",
          "14436:       if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49))",
          "14437:       {",
          "14438:         unique_id =",
          "14439:             (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;",
          "14440:       }",
          "14441:       else",
          "14442:       {",
          "14443:         unique_id =",
          "14444:             (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;",
          "14449:       if (type == 4)",
          "14450:         imgdata.lens.makernotes.CurAp = powf64(2.0f, (int_to_float(data) / 2.0f));",
          "14451:       else",
          "14452:         imgdata.lens.makernotes.CurAp = powf64(2.0f, (getreal(type) / 2.0f));",
          "14455:       if (type == 4)",
          "14456:         imgdata.lens.makernotes.CurFocal = int_to_float(data);",
          "14457:       else",
          "14458:         imgdata.lens.makernotes.CurFocal = getreal(type);",
          "",
          "---------------",
          "--- Hunk 110 ---",
          "[Context before]",
          "13118:       stmread(imgdata.lens.makernotes.Lens, len, ifp);",
          "13119:       break;",
          "13120:     case 0x0414:",
          "13124:         imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (getreal(type) / 2.0f));",
          "13125:       }",
          "13126:       break;",
          "13127:     case 0x0415:",
          "13131:         imgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (getreal(type) / 2.0f));",
          "13132:       }",
          "13133:       break;",
          "13134:     case 0x0416:",
          "13138:         imgdata.lens.makernotes.MinFocal = getreal(type);",
          "13139:       }",
          "13140:       if (imgdata.lens.makernotes.MinFocal > 1000.0f)",
          "13144:       break;",
          "13145:     case 0x0417:",
          "13149:         imgdata.lens.makernotes.MaxFocal = getreal(type);",
          "13150:       }",
          "13151:       break;",
          "13152: #endif",
          "13202:     order = get2();",
          "13209:       data = get4();",
          "13210:       save = ftell(ifp);",
          "13213:         stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "13218:         }",
          "13219:         setPhaseOneFeatures(unique_id);",
          "13220:       }",
          "13222:     }",
          "13223:   }",
          "13224: #endif",
          "13228:   maximum = 0xffff;",
          "13236:   }",
          "13237: }",
          "13240: {",
          "13241:   unsigned entries, tag, len, save, c;",
          "13244:   entries = get4();",
          "13247:     tag = get2();",
          "13248:     len = get2();",
          "13249:     save = ftell(ifp);",
          "13252:       raw_height = get2();",
          "13255:       height = get2();",
          "13258:       fuji_layout = fgetc(ifp) >> 7;",
          "13259:       fuji_width = !(fgetc(ifp) & 8);",
          "13261:       filters = 9;",
          "13264:       FORC4 cam_mul[c ^ 1] = get2();",
          "13267: #ifdef LIBRAW_LIBRARY_BUILD",
          "13284: #endif",
          "13288:       c = order;",
          "13289:       order = 0x4949;",
          "13292:       width = tag;",
          "13293:       height = get4();",
          "13294: #ifdef LIBRAW_LIBRARY_BUILD",
          "13295:       libraw_internal_data.unpacker_data.posRAFData = save;",
          "13297: #endif",
          "13299:     }",
          "13301:   }",
          "13302:   height <<= fuji_layout;",
          "13304: }",
          "13307: {",
          "13308:   int len, save, hlen, mark;",
          "13313:     order = 0x4d4d;",
          "13317:       fgetc(ifp);",
          "13318:       raw_height = get2();",
          "13320:     }",
          "13321:     order = get2();",
          "13324:     {",
          "13325: #ifdef LIBRAW_LIBRARY_BUILD",
          "13326:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "13327:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "13328: #endif",
          "13330:     }",
          "13333:   }",
          "13334:   return 1;",
          "13335: }",
          "",
          "[Removed Lines]",
          "13121:       if (type == 4) {",
          "13122:        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (int_to_float(data)/2.0f));",
          "13123:       } else {",
          "13128:       if (type == 4) {",
          "13129:        imgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (int_to_float(data)/2.0f));",
          "13130:       } else {",
          "13135:       if (type == 4) {",
          "13136:         imgdata.lens.makernotes.MinFocal =  int_to_float(data);",
          "13137:       } else {",
          "13141:         {",
          "13142:           imgdata.lens.makernotes.MinFocal = 0.0f;",
          "13143:         }",
          "13146:       if (type == 4) {",
          "13147:         imgdata.lens.makernotes.MaxFocal =  int_to_float(data);",
          "13148:       } else {",
          "13154:       case 0x100:  flip = \"0653\"[data & 3]-'0';  break;",
          "13155:       case 0x106:",
          "13156:  for (i=0; i < 9; i++)",
          "13157: #ifdef LIBRAW_LIBRARY_BUILD",
          "13158:  imgdata.color.P1_color[0].romm_cam[i]=",
          "13159: #endif",
          "13160:    ((float *)romm_cam)[i] = getreal(11);",
          "13161:  romm_coeff (romm_cam);",
          "13162:  break;",
          "13163:       case 0x107:",
          "13164:  FORC3 cam_mul[c] = getreal(11);",
          "13165:  break;",
          "13166:       case 0x108:  raw_width     = data; break;",
          "13167:       case 0x109:  raw_height    = data; break;",
          "13168:       case 0x10a:  left_margin   = data; break;",
          "13169:       case 0x10b:  top_margin    = data; break;",
          "13170:       case 0x10c:  width         = data; break;",
          "13171:       case 0x10d:  height        = data; break;",
          "13172:       case 0x10e:  ph1.format    = data; break;",
          "13173:       case 0x10f:  data_offset   = data+base; break;",
          "13174:       case 0x110:  meta_offset   = data+base;",
          "13175:      meta_length   = len;   break;",
          "13176:       case 0x112:  ph1.key_off   = save - 4;  break;",
          "13177:       case 0x210:  ph1.tag_210   = int_to_float(data); break;",
          "13178:       case 0x21a:  ph1.tag_21a   = data;  break;",
          "13179:       case 0x21c:  strip_offset  = data+base;  break;",
          "13180:       case 0x21d:  ph1.t_black     = data;  break;",
          "13181:       case 0x222:  ph1.split_col = data;  break;",
          "13182:       case 0x223:  ph1.black_col = data+base;  break;",
          "13183:       case 0x224:  ph1.split_row = data;  break;",
          "13184:       case 0x225:  ph1.black_row = data+base;  break;",
          "13185: #ifdef LIBRAW_LIBRARY_BUILD",
          "13186:       case 0x226:",
          "13187:  for (i=0; i < 9; i++)",
          "13188:    imgdata.color.P1_color[1].romm_cam[i] = getreal(11);",
          "13189:  break;",
          "13190: #endif",
          "13191:       case 0x301:",
          "13192:  model[63] = 0;",
          "13193:  fread (model, 1, 63, ifp);",
          "13194:  if ((cp = strstr(model,\" camera\"))) *cp = 0;",
          "13195:     }",
          "13196:     fseek (ifp, save, SEEK_SET);",
          "13197:   }",
          "13199: #ifdef LIBRAW_LIBRARY_BUILD",
          "13200:   if (!imgdata.lens.makernotes.body[0] && !imgdata.shootinginfo.BodySerial[0]) {",
          "13201:     fseek (ifp, meta_offset, SEEK_SET);",
          "13203:     fseek (ifp, 6, SEEK_CUR);",
          "13204:     fseek (ifp, meta_offset+get4(), SEEK_SET);",
          "13205:     entries = get4();  get4();",
          "13206:     while (entries--) {",
          "13207:       tag  = get4();",
          "13208:       len  = get4();",
          "13211:       fseek (ifp, meta_offset+data, SEEK_SET);",
          "13212:       if (tag == 0x0407) {",
          "13214:         if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49)) {",
          "13215:           unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;",
          "13216:         } else {",
          "13217:           unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;",
          "13221:       fseek (ifp, save, SEEK_SET);",
          "13226:   load_raw = ph1.format < 3 ?",
          "13227:  &CLASS phase_one_load_raw : &CLASS phase_one_load_raw_c;",
          "13229:   strcpy (make, \"Phase One\");",
          "13230:   if (model[0]) return;",
          "13231:   switch (raw_height) {",
          "13232:     case 2060: strcpy (model,\"LightPhase\"); break;",
          "13233:     case 2682: strcpy (model,\"H 10\");  break;",
          "13234:     case 4128: strcpy (model,\"H 20\");  break;",
          "13235:     case 5488: strcpy (model,\"H 25\");  break;",
          "13239: void CLASS parse_fuji (int offset)",
          "13243:   fseek (ifp, offset, SEEK_SET);",
          "13245:   if (entries > 255) return;",
          "13246:   while (entries--) {",
          "13251:     if (tag == 0x100) {",
          "13253:       raw_width  = get2();",
          "13254:     } else if (tag == 0x121) {",
          "13256:       if ((width = get2()) == 4284) width += 3;",
          "13257:     } else if (tag == 0x130) {",
          "13260:     } else if (tag == 0x131) {",
          "13262:       FORC(36) xtrans_abs[0][35-c] = fgetc(ifp) & 3;",
          "13263:     } else if (tag == 0x2ff0) {",
          "13268:     } else if (tag == 0x9650) {",
          "13269:       imgdata.makernotes.fuji.FujiExpoMidPointShift = ((short)get2()) / fMAX(1.0f,get2());",
          "13270:     } else if (tag == 0x2100) {",
          "13271:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ 1] = get2();",
          "13272:     } else if (tag == 0x2200) {",
          "13273:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ 1] = get2();",
          "13274:     } else if (tag == 0x2300) {",
          "13275:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ 1] = get2();",
          "13276:     } else if (tag == 0x2301) {",
          "13277:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ 1] = get2();",
          "13278:     } else if (tag == 0x2302) {",
          "13279:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ 1] = get2();",
          "13280:     } else if (tag == 0x2310) {",
          "13281:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ 1] = get2();",
          "13282:     } else if (tag == 0x2400) {",
          "13283:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ 1] = get2();",
          "13287:     } else if (tag == 0xc000) {",
          "13290:       if ((tag = get4()) > 10000) tag = get4();",
          "13291:       if (tag > 10000) tag = get4();",
          "13296:       libraw_internal_data.unpacker_data.lenRAFData = (len>>1);",
          "13298:    order = c;",
          "13300:     fseek (ifp, save+len, SEEK_SET);",
          "13303:   width  >>= fuji_layout;",
          "13306: int CLASS parse_jpeg (int offset)",
          "13309:   fseek (ifp, offset, SEEK_SET);",
          "13310:   if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) return 0;",
          "13312:   while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda) {",
          "13314:     len   = get2() - 2;",
          "13315:     save  = ftell(ifp);",
          "13316:     if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9) {",
          "13319:       raw_width  = get2();",
          "13322:     hlen  = get4();",
          "13329:       parse_ciff (save+hlen, len-hlen, 0);",
          "13331:     if (parse_tiff (save+6)) apply_tiff();",
          "13332:     fseek (ifp, save+len, SEEK_SET);",
          "",
          "[Added Lines]",
          "14467:       if (type == 4)",
          "14468:       {",
          "14469:         imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (int_to_float(data) / 2.0f));",
          "14470:       }",
          "14471:       else",
          "14472:       {",
          "14477:       if (type == 4)",
          "14478:       {",
          "14479:         imgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (int_to_float(data) / 2.0f));",
          "14480:       }",
          "14481:       else",
          "14482:       {",
          "14487:       if (type == 4)",
          "14488:       {",
          "14489:         imgdata.lens.makernotes.MinFocal = int_to_float(data);",
          "14490:       }",
          "14491:       else",
          "14492:       {",
          "14496:       {",
          "14497:         imgdata.lens.makernotes.MinFocal = 0.0f;",
          "14498:       }",
          "14501:       if (type == 4)",
          "14502:       {",
          "14503:         imgdata.lens.makernotes.MaxFocal = int_to_float(data);",
          "14504:       }",
          "14505:       else",
          "14506:       {",
          "14512:     case 0x100:",
          "14513:       flip = \"0653\"[data & 3] - '0';",
          "14514:       break;",
          "14515:     case 0x106:",
          "14516:       for (i = 0; i < 9; i++)",
          "14517: #ifdef LIBRAW_LIBRARY_BUILD",
          "14518:         imgdata.color.P1_color[0].romm_cam[i] =",
          "14519: #endif",
          "14520:             ((float *)romm_cam)[i] = getreal(11);",
          "14521:       romm_coeff(romm_cam);",
          "14522:       break;",
          "14523:     case 0x107:",
          "14524:       FORC3 cam_mul[c] = getreal(11);",
          "14525:       break;",
          "14526:     case 0x108:",
          "14527:       raw_width = data;",
          "14528:       break;",
          "14529:     case 0x109:",
          "14530:       raw_height = data;",
          "14531:       break;",
          "14532:     case 0x10a:",
          "14533:       left_margin = data;",
          "14534:       break;",
          "14535:     case 0x10b:",
          "14536:       top_margin = data;",
          "14537:       break;",
          "14538:     case 0x10c:",
          "14539:       width = data;",
          "14540:       break;",
          "14541:     case 0x10d:",
          "14542:       height = data;",
          "14543:       break;",
          "14544:     case 0x10e:",
          "14545:       ph1.format = data;",
          "14546:       break;",
          "14547:     case 0x10f:",
          "14548:       data_offset = data + base;",
          "14549:       break;",
          "14550:     case 0x110:",
          "14551:       meta_offset = data + base;",
          "14552:       meta_length = len;",
          "14553:       break;",
          "14554:     case 0x112:",
          "14555:       ph1.key_off = save - 4;",
          "14556:       break;",
          "14557:     case 0x210:",
          "14558:       ph1.tag_210 = int_to_float(data);",
          "14559:       break;",
          "14560:     case 0x21a:",
          "14561:       ph1.tag_21a = data;",
          "14562:       break;",
          "14563:     case 0x21c:",
          "14564:       strip_offset = data + base;",
          "14565:       break;",
          "14566:     case 0x21d:",
          "14567:       ph1.t_black = data;",
          "14568:       break;",
          "14569:     case 0x222:",
          "14570:       ph1.split_col = data;",
          "14571:       break;",
          "14572:     case 0x223:",
          "14573:       ph1.black_col = data + base;",
          "14574:       break;",
          "14575:     case 0x224:",
          "14576:       ph1.split_row = data;",
          "14577:       break;",
          "14578:     case 0x225:",
          "14579:       ph1.black_row = data + base;",
          "14580:       break;",
          "14581: #ifdef LIBRAW_LIBRARY_BUILD",
          "14582:     case 0x226:",
          "14583:       for (i = 0; i < 9; i++)",
          "14584:         imgdata.color.P1_color[1].romm_cam[i] = getreal(11);",
          "14585:       break;",
          "14586: #endif",
          "14587:     case 0x301:",
          "14588:       model[63] = 0;",
          "14589:       fread(model, 1, 63, ifp);",
          "14590:       if ((cp = strstr(model, \" camera\")))",
          "14592:     }",
          "14593:     fseek(ifp, save, SEEK_SET);",
          "14594:   }",
          "14596: #ifdef LIBRAW_LIBRARY_BUILD",
          "14597:   if (!imgdata.lens.makernotes.body[0] && !imgdata.shootinginfo.BodySerial[0])",
          "14598:   {",
          "14599:     fseek(ifp, meta_offset, SEEK_SET);",
          "14601:     fseek(ifp, 6, SEEK_CUR);",
          "14602:     fseek(ifp, meta_offset + get4(), SEEK_SET);",
          "14603:     entries = get4();",
          "14604:     get4();",
          "14605:     while (entries--)",
          "14606:     {",
          "14607:       tag = get4();",
          "14608:       len = get4();",
          "14611:       fseek(ifp, meta_offset + data, SEEK_SET);",
          "14612:       if (tag == 0x0407)",
          "14613:       {",
          "14615:         if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49))",
          "14616:         {",
          "14617:           unique_id =",
          "14618:               (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;",
          "14619:         }",
          "14620:         else",
          "14621:         {",
          "14622:           unique_id =",
          "14623:               (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;",
          "14627:       fseek(ifp, save, SEEK_SET);",
          "14632:   load_raw = ph1.format < 3 ? &CLASS phase_one_load_raw : &CLASS phase_one_load_raw_c;",
          "14634:   strcpy(make, \"Phase One\");",
          "14635:   if (model[0])",
          "14636:     return;",
          "14637:   switch (raw_height)",
          "14638:   {",
          "14639:   case 2060:",
          "14640:     strcpy(model, \"LightPhase\");",
          "14641:     break;",
          "14642:   case 2682:",
          "14643:     strcpy(model, \"H 10\");",
          "14644:     break;",
          "14645:   case 4128:",
          "14646:     strcpy(model, \"H 20\");",
          "14647:     break;",
          "14648:   case 5488:",
          "14649:     strcpy(model, \"H 25\");",
          "14650:     break;",
          "14654: void CLASS parse_fuji(int offset)",
          "14658:   fseek(ifp, offset, SEEK_SET);",
          "14660:   if (entries > 255)",
          "14661:     return;",
          "14662:   while (entries--)",
          "14663:   {",
          "14668:     if (tag == 0x100)",
          "14669:     {",
          "14671:       raw_width = get2();",
          "14672:     }",
          "14673:     else if (tag == 0x121)",
          "14674:     {",
          "14676:       if ((width = get2()) == 4284)",
          "14677:         width += 3;",
          "14678:     }",
          "14679:     else if (tag == 0x130)",
          "14680:     {",
          "14683:     }",
          "14684:     else if (tag == 0x131)",
          "14685:     {",
          "14687:       FORC(36) xtrans_abs[0][35 - c] = fgetc(ifp) & 3;",
          "14688:     }",
          "14689:     else if (tag == 0x2ff0)",
          "14690:     {",
          "14695:     }",
          "14696:     else if (tag == 0x9650)",
          "14697:     {",
          "14698:       imgdata.makernotes.fuji.FujiExpoMidPointShift = ((short)get2()) / fMAX(1.0f, get2());",
          "14699:     }",
          "14700:     else if (tag == 0x2100)",
          "14701:     {",
          "14702:       FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ 1] = get2();",
          "14703:     }",
          "14704:     else if (tag == 0x2200)",
          "14705:     {",
          "14706:       FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ 1] = get2();",
          "14707:     }",
          "14708:     else if (tag == 0x2300)",
          "14709:     {",
          "14710:       FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ 1] = get2();",
          "14711:     }",
          "14712:     else if (tag == 0x2301)",
          "14713:     {",
          "14714:       FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ 1] = get2();",
          "14715:     }",
          "14716:     else if (tag == 0x2302)",
          "14717:     {",
          "14718:       FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ 1] = get2();",
          "14719:     }",
          "14720:     else if (tag == 0x2310)",
          "14721:     {",
          "14722:       FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ 1] = get2();",
          "14723:     }",
          "14724:     else if (tag == 0x2400)",
          "14725:     {",
          "14726:       FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ 1] = get2();",
          "14729:     }",
          "14730:     else if (tag == 0xc000)",
          "14731:     {",
          "14734:       if ((tag = get4()) > 10000)",
          "14735:         tag = get4();",
          "14736:       if (tag > 10000)",
          "14737:         tag = get4();",
          "14742:       libraw_internal_data.unpacker_data.lenRAFData = (len >> 1);",
          "14744:       order = c;",
          "14746:     fseek(ifp, save + len, SEEK_SET);",
          "14749:   width >>= fuji_layout;",
          "14752: int CLASS parse_jpeg(int offset)",
          "14755:   fseek(ifp, offset, SEEK_SET);",
          "14756:   if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)",
          "14757:     return 0;",
          "14759:   while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda)",
          "14760:   {",
          "14762:     len = get2() - 2;",
          "14763:     save = ftell(ifp);",
          "14764:     if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9)",
          "14765:     {",
          "14768:       raw_width = get2();",
          "14771:     hlen = get4();",
          "14778:       parse_ciff(save + hlen, len - hlen, 0);",
          "14780:     if (parse_tiff(save + 6))",
          "14781:       apply_tiff();",
          "14782:     fseek(ifp, save + len, SEEK_SET);",
          "",
          "---------------",
          "--- Hunk 111 ---",
          "[Context before]",
          "13338: {",
          "13339:   unsigned i, size, end;",
          "13340:   char tag[4], date[64], month[64];",
          "13343:   struct tm t;",
          "13345:   order = 0x4949;",
          "13347:   size = get4();",
          "13348:   end = ftell(ifp) + size;",
          "13350:     int maxloop = 1000;",
          "13351:     get4();",
          "13353:       parse_riff();",
          "13356:       i = get2();",
          "13357:       size = get2();",
          "13361:     }",
          "13364:     date[size] = 0;",
          "13369:       t.tm_mon = i;",
          "13370:       t.tm_year -= 1900;",
          "13371:       if (mktime(&t) > 0)",
          "13373:     }",
          "13376: }",
          "13379: {",
          "13380:   unsigned save, size;",
          "13381:   char tag[4];",
          "13383:   order = 0x4d4d;",
          "13385:     save = ftell(ifp);",
          "13395:   }",
          "13396: }",
          "13399: {",
          "13400:   int ver;",
          "13403:   order = 0x4949;",
          "13404:   ver = fgetc(ifp);",
          "13405:   if (ver == 6)",
          "13409:   raw_height = height = get2();",
          "13415: }",
          "13417: void CLASS parse_cine()",
          "",
          "[Removed Lines]",
          "13341:   static const char mon[12][4] =",
          "13342:   { \"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\" };",
          "13346:   fread (tag, 4, 1, ifp);",
          "13349:   if (!memcmp(tag,\"RIFF\",4) || !memcmp(tag,\"LIST\",4)) {",
          "13352:     while (ftell(ifp)+7 < end && !feof(ifp) && maxloop--)",
          "13354:   } else if (!memcmp(tag,\"nctg\",4)) {",
          "13355:     while (ftell(ifp)+7 < end) {",
          "13358:       if ((i+1) >> 1 == 10 && size == 20)",
          "13359:  get_timestamp(0);",
          "13360:       else fseek (ifp, size, SEEK_CUR);",
          "13362:   } else if (!memcmp(tag,\"IDIT\",4) && size < 64) {",
          "13363:     fread (date, 64, 1, ifp);",
          "13365:     memset (&t, 0, sizeof t);",
          "13366:     if (sscanf (date, \"%*s %s %d %d:%d:%d %d\", month, &t.tm_mday,",
          "13367:  &t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6) {",
          "13368:       for (i=0; i < 12 && strcasecmp(mon[i],month); i++);",
          "13372:  timestamp = mktime(&t);",
          "13374:   } else",
          "13375:     fseek (ifp, size, SEEK_CUR);",
          "13378: void CLASS parse_qt (int end)",
          "13384:   while (ftell(ifp)+7 < end) {",
          "13386:     if ((size = get4()) < 8) return;",
          "13387:     fread (tag, 4, 1, ifp);",
          "13388:     if (!memcmp(tag,\"moov\",4) ||",
          "13389:  !memcmp(tag,\"udta\",4) ||",
          "13390:  !memcmp(tag,\"CNTH\",4))",
          "13391:       parse_qt (save+size);",
          "13392:     if (!memcmp(tag,\"CNDA\",4))",
          "13393:       parse_jpeg (ftell(ifp));",
          "13394:     fseek (ifp, save+size, SEEK_SET);",
          "13398: void CLASS parse_smal (int offset, int fsize)",
          "13402:   fseek (ifp, offset+2, SEEK_SET);",
          "13406:     fseek (ifp, 5, SEEK_CUR);",
          "13407:   if (get4() != fsize) return;",
          "13408:   if (ver > 6) data_offset = get4();",
          "13410:   raw_width  = width  = get2();",
          "13411:   strcpy (make, \"SMaL\");",
          "13412:   sprintf (model, \"v%d %dx%d\", ver, width, height);",
          "13413:   if (ver == 6) load_raw = &CLASS smal_v6_load_raw;",
          "13414:   if (ver == 9) load_raw = &CLASS smal_v9_load_raw;",
          "",
          "[Added Lines]",
          "14791:   static const char mon[12][4] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};",
          "14795:   fread(tag, 4, 1, ifp);",
          "14798:   if (!memcmp(tag, \"RIFF\", 4) || !memcmp(tag, \"LIST\", 4))",
          "14799:   {",
          "14802:     while (ftell(ifp) + 7 < end && !feof(ifp) && maxloop--)",
          "14804:   }",
          "14805:   else if (!memcmp(tag, \"nctg\", 4))",
          "14806:   {",
          "14807:     while (ftell(ifp) + 7 < end)",
          "14808:     {",
          "14811:       if ((i + 1) >> 1 == 10 && size == 20)",
          "14812:         get_timestamp(0);",
          "14813:       else",
          "14814:         fseek(ifp, size, SEEK_CUR);",
          "14816:   }",
          "14817:   else if (!memcmp(tag, \"IDIT\", 4) && size < 64)",
          "14818:   {",
          "14819:     fread(date, 64, 1, ifp);",
          "14821:     memset(&t, 0, sizeof t);",
          "14822:     if (sscanf(date, \"%*s %s %d %d:%d:%d %d\", month, &t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6)",
          "14823:     {",
          "14824:       for (i = 0; i < 12 && strcasecmp(mon[i], month); i++)",
          "14825:         ;",
          "14829:         timestamp = mktime(&t);",
          "14831:   }",
          "14832:   else",
          "14833:     fseek(ifp, size, SEEK_CUR);",
          "14836: void CLASS parse_qt(int end)",
          "14842:   while (ftell(ifp) + 7 < end)",
          "14843:   {",
          "14845:     if ((size = get4()) < 8)",
          "14846:       return;",
          "14847:     fread(tag, 4, 1, ifp);",
          "14848:     if (!memcmp(tag, \"moov\", 4) || !memcmp(tag, \"udta\", 4) || !memcmp(tag, \"CNTH\", 4))",
          "14849:       parse_qt(save + size);",
          "14850:     if (!memcmp(tag, \"CNDA\", 4))",
          "14851:       parse_jpeg(ftell(ifp));",
          "14852:     fseek(ifp, save + size, SEEK_SET);",
          "14856: void CLASS parse_smal(int offset, int fsize)",
          "14860:   fseek(ifp, offset + 2, SEEK_SET);",
          "14864:     fseek(ifp, 5, SEEK_CUR);",
          "14865:   if (get4() != fsize)",
          "14866:     return;",
          "14867:   if (ver > 6)",
          "14868:     data_offset = get4();",
          "14870:   raw_width = width = get2();",
          "14871:   strcpy(make, \"SMaL\");",
          "14872:   sprintf(model, \"v%d %dx%d\", ver, width, height);",
          "14873:   if (ver == 6)",
          "14874:     load_raw = &CLASS smal_v6_load_raw;",
          "14875:   if (ver == 9)",
          "14876:     load_raw = &CLASS smal_v9_load_raw;",
          "",
          "---------------",
          "--- Hunk 112 ---",
          "[Context before]",
          "13419:   unsigned off_head, off_setup, off_image, i;",
          "13421:   order = 0x4949;",
          "13423:   is_raw = get2() == 2;",
          "13425:   is_raw *= get4();",
          "13426:   off_head = get4();",
          "13427:   off_setup = get4();",
          "13428:   off_image = get4();",
          "13429:   timestamp = get4();",
          "13432:   raw_width = get4();",
          "13433:   raw_height = get4();",
          "13453:   }",
          "13454:   cam_mul[0] = getreal(11);",
          "13455:   cam_mul[2] = getreal(11);",
          "13456:   maximum = ~((~0u) << get4());",
          "13460:   if (shot_select < is_raw)",
          "13464: }",
          "13466: void CLASS parse_redcine()",
          "",
          "[Removed Lines]",
          "13422:   fseek (ifp, 4, SEEK_SET);",
          "13424:   fseek (ifp, 14, SEEK_CUR);",
          "13430:   if ((i = get4())) timestamp = i;",
          "13431:   fseek (ifp, off_head+4, SEEK_SET);",
          "13434:   switch (get2(),get2()) {",
          "13435:     case  8:  load_raw = &CLASS eight_bit_load_raw;  break;",
          "13436:     case 16:  load_raw = &CLASS  unpacked_load_raw;",
          "13437:   }",
          "13438:   fseek (ifp, off_setup+792, SEEK_SET);",
          "13439:   strcpy (make, \"CINE\");",
          "13440:   sprintf (model, \"%d\", get4());",
          "13441:   fseek (ifp, 12, SEEK_CUR);",
          "13442:   switch ((i=get4()) & 0xffffff) {",
          "13443:     case  3:  filters = 0x94949494;  break;",
          "13444:     case  4:  filters = 0x49494949;  break;",
          "13445:     default:  is_raw = 0;",
          "13446:   }",
          "13447:   fseek (ifp, 72, SEEK_CUR);",
          "13448:   switch ((get4()+3600) % 360) {",
          "13449:     case 270:  flip = 4;  break;",
          "13450:     case 180:  flip = 1;  break;",
          "13451:     case  90:  flip = 7;  break;",
          "13452:     case   0:  flip = 2;",
          "13457:   fseek (ifp, 668, SEEK_CUR);",
          "13458:   shutter = get4()/1000000000.0;",
          "13459:   fseek (ifp, off_image, SEEK_SET);",
          "13461:     fseek (ifp, shot_select*8, SEEK_CUR);",
          "13462:   data_offset  = (INT64) get4() + 8;",
          "13463:   data_offset += (INT64) get4() << 32;",
          "",
          "[Added Lines]",
          "14884:   fseek(ifp, 4, SEEK_SET);",
          "14886:   fseek(ifp, 14, SEEK_CUR);",
          "14892:   if ((i = get4()))",
          "14893:     timestamp = i;",
          "14894:   fseek(ifp, off_head + 4, SEEK_SET);",
          "14897:   switch (get2(), get2())",
          "14898:   {",
          "14899:   case 8:",
          "14900:     load_raw = &CLASS eight_bit_load_raw;",
          "14901:     break;",
          "14902:   case 16:",
          "14903:     load_raw = &CLASS unpacked_load_raw;",
          "14904:   }",
          "14905:   fseek(ifp, off_setup + 792, SEEK_SET);",
          "14906:   strcpy(make, \"CINE\");",
          "14907:   sprintf(model, \"%d\", get4());",
          "14908:   fseek(ifp, 12, SEEK_CUR);",
          "14909:   switch ((i = get4()) & 0xffffff)",
          "14910:   {",
          "14911:   case 3:",
          "14912:     filters = 0x94949494;",
          "14913:     break;",
          "14914:   case 4:",
          "14915:     filters = 0x49494949;",
          "14916:     break;",
          "14917:   default:",
          "14918:     is_raw = 0;",
          "14919:   }",
          "14920:   fseek(ifp, 72, SEEK_CUR);",
          "14921:   switch ((get4() + 3600) % 360)",
          "14922:   {",
          "14923:   case 270:",
          "14924:     flip = 4;",
          "14925:     break;",
          "14926:   case 180:",
          "14927:     flip = 1;",
          "14928:     break;",
          "14929:   case 90:",
          "14930:     flip = 7;",
          "14931:     break;",
          "14932:   case 0:",
          "14933:     flip = 2;",
          "14938:   fseek(ifp, 668, SEEK_CUR);",
          "14939:   shutter = get4() / 1000000000.0;",
          "14940:   fseek(ifp, off_image, SEEK_SET);",
          "14942:     fseek(ifp, shot_select * 8, SEEK_CUR);",
          "14943:   data_offset = (INT64)get4() + 8;",
          "14944:   data_offset += (INT64)get4() << 32;",
          "",
          "---------------",
          "--- Hunk 113 ---",
          "[Context before]",
          "13470:   order = 0x4d4d;",
          "13471:   is_raw = 0;",
          "13474:   height = get4();",
          "13478: #ifdef DCRAW_VERBOSE",
          "13480: #endif",
          "13483:       if (get4() == 0x52454456)",
          "13487:     }",
          "13489:     rdvo = get4();",
          "13491:     is_raw = get4();",
          "13493:     data_offset = get4();",
          "13494:   }",
          "13495: }",
          "13499: {",
          "13500:   int i;",
          "13504:   str[i] = 0;",
          "13505:   return str;",
          "13506: }",
          "13508: void CLASS parse_foveon()",
          "13509: {",
          "13511:   char name[64], value[64];",
          "13514:   flip = get4();",
          "13520:     off = get4();",
          "13521:     len = get4();",
          "13522:     tag = get4();",
          "13523:     save = ftell(ifp);",
          "13625:         }",
          "13626: #endif",
          "13627:     }",
          "13628: #ifdef LOCALTIME",
          "13630: #endif",
          "13633:   }",
          "13634: }",
          "",
          "[Removed Lines]",
          "13472:   fseek (ifp, 52, SEEK_SET);",
          "13473:   width  = get4();",
          "13475:   fseek (ifp, 0, SEEK_END);",
          "13476:   fseek (ifp, -(i = ftello(ifp) & 511), SEEK_CUR);",
          "13477:   if (get4() != i || get4() != 0x52454f42) {",
          "13479:     fprintf (stderr,_(\"%s: Tail is missing, parsing from head...\\n\"), ifname);",
          "13481:     fseek (ifp, 0, SEEK_SET);",
          "13482:     while ((len = get4()) != EOF) {",
          "13484:  if (is_raw++ == shot_select)",
          "13485:    data_offset = ftello(ifp) - 8;",
          "13486:       fseek (ifp, len-8, SEEK_CUR);",
          "13488:   } else {",
          "13490:     fseek (ifp, 12, SEEK_CUR);",
          "13492:     fseeko (ifp, rdvo+8 + shot_select*4, SEEK_SET);",
          "13498: char * CLASS foveon_gets (int offset, char *str, int len)",
          "13501:   fseek (ifp, offset, SEEK_SET);",
          "13502:   for (i=0; i < len-1; i++)",
          "13503:     if ((str[i] = get2()) == 0) break;",
          "13510:   int entries, img=0, off, len, tag, save, i, wide, high, pent, poff[256][2];",
          "13513:   fseek (ifp, 36, SEEK_SET);",
          "13515:   fseek (ifp, -4, SEEK_END);",
          "13516:   fseek (ifp, get4(), SEEK_SET);",
          "13518:   entries = (get4(),get4());",
          "13519:   while (entries--) {",
          "13524:     fseek (ifp, off, SEEK_SET);",
          "13525:     if (get4() != (0x20434553 | (tag << 24))) return;",
          "13526:     switch (tag) {",
          "13529:  fseek (ifp, 8, SEEK_CUR);",
          "13530:  pent = get4();",
          "13531:  wide = get4();",
          "13532:  high = get4();",
          "13533:  if (wide > raw_width && high > raw_height) {",
          "13534:    switch (pent) {",
          "13535:      case  5:  load_flags = 1;",
          "13536:      case  6:  load_raw = &CLASS foveon_sd_load_raw;  break;",
          "13537:      case 30:  load_raw = &CLASS foveon_dp_load_raw;  break;",
          "13538:      default:  load_raw = 0;",
          "13539:    }",
          "13540:    raw_width  = wide;",
          "13541:    raw_height = high;",
          "13542:    data_offset = off+28;",
          "13543:    is_foveon = 1;",
          "13544:  }",
          "13545:  fseek (ifp, off+28, SEEK_SET);",
          "13546:  if (fgetc(ifp) == 0xff && fgetc(ifp) == 0xd8",
          "13547:   && thumb_length < len-28) {",
          "13548:    thumb_offset = off+28;",
          "13549:    thumb_length = len-28;",
          "13550:    write_thumb = &CLASS jpeg_thumb;",
          "13551:  }",
          "13552:  if (++img == 2 && !thumb_length) {",
          "13553:    thumb_offset = off+24;",
          "13554:    thumb_width = wide;",
          "13555:    thumb_height = high;",
          "13556:    write_thumb = &CLASS foveon_thumb;",
          "13557:  }",
          "13558:  break;",
          "13560:  meta_offset = off+8;",
          "13561:  meta_length = len-28;",
          "13562:  break;",
          "13564:  pent = (get4(),get4());",
          "13565:  fseek (ifp, 12, SEEK_CUR);",
          "13566:  off += pent*8 + 24;",
          "13567:  if ((unsigned) pent > 256) pent=256;",
          "13568:  for (i=0; i < pent*2; i++)",
          "13569:    ((int *)poff)[i] = off + get4()*2;",
          "13570:  for (i=0; i < pent; i++) {",
          "13571:    foveon_gets (poff[i][0], name, 64);",
          "13572:    foveon_gets (poff[i][1], value, 64);",
          "13573:    if (!strcmp (name, \"ISO\"))",
          "13574:      iso_speed = atoi(value);",
          "13575:    if (!strcmp (name, \"CAMMANUF\"))",
          "13576:      strcpy (make, value);",
          "13577:    if (!strcmp (name, \"CAMMODEL\"))",
          "13578:      strcpy (model, value);",
          "13579:    if (!strcmp (name, \"WB_DESC\"))",
          "13580:      strcpy (model2, value);",
          "13581:    if (!strcmp (name, \"TIME\"))",
          "13582:      timestamp = atoi(value);",
          "13583:    if (!strcmp (name, \"EXPTIME\"))",
          "13584:      shutter = atoi(value) / 1000000.0;",
          "13585:    if (!strcmp (name, \"APERTURE\"))",
          "13586:      aperture = atof(value);",
          "13587:    if (!strcmp (name, \"FLENGTH\"))",
          "13588:      focal_len = atof(value);",
          "13589: #ifdef LIBRAW_LIBRARY_BUILD",
          "13590:    if (!strcmp (name, \"CAMSERIAL\"))",
          "13591:      strcpy (imgdata.shootinginfo.BodySerial, value);",
          "13592:    if (!strcmp (name, \"FLEQ35MM\"))",
          "13593:             imgdata.lens.makernotes.FocalLengthIn35mmFormat = atof(value);",
          "13594:           if (!strcmp (name, \"LENSARANGE\"))",
          "13595:             {",
          "13596:               char *sp;",
          "13597:               imgdata.lens.makernotes.MaxAp4CurFocal = imgdata.lens.makernotes.MinAp4CurFocal = atof(value);",
          "13598:               sp = strrchr (value, ' ');",
          "13599:               if (sp)",
          "13600:                 {",
          "13601:                   imgdata.lens.makernotes.MinAp4CurFocal = atof(sp);",
          "13602:                   if (imgdata.lens.makernotes.MaxAp4CurFocal > imgdata.lens.makernotes.MinAp4CurFocal)",
          "13603:                     my_swap (float, imgdata.lens.makernotes.MaxAp4CurFocal, imgdata.lens.makernotes.MinAp4CurFocal);",
          "13604:                 }",
          "13605:             }",
          "13606:           if (!strcmp (name, \"LENSFRANGE\"))",
          "13607:             {",
          "13608:               char *sp;",
          "13609:               imgdata.lens.makernotes.MinFocal = imgdata.lens.makernotes.MaxFocal = atof(value);",
          "13610:               sp = strrchr (value, ' ');",
          "13611:               if (sp)",
          "13612:                 {",
          "13613:                   imgdata.lens.makernotes.MaxFocal = atof(sp);",
          "13614:                   if ((imgdata.lens.makernotes.MaxFocal + 0.17f) < imgdata.lens.makernotes.MinFocal)",
          "13615:                     my_swap (float, imgdata.lens.makernotes.MaxFocal, imgdata.lens.makernotes.MinFocal);",
          "13616:                 }",
          "13617:             }",
          "13618:           if (!strcmp (name, \"LENSMODEL\"))",
          "13619:             {",
          "13620:               char *sp;",
          "13621:               imgdata.lens.makernotes.LensID = strtol (value, &sp, 16); // atoi(value);",
          "13622:               if (imgdata.lens.makernotes.LensID)",
          "13623:                 imgdata.lens.makernotes.LensMount = Sigma_X3F;",
          "13624:             }",
          "13629:  timestamp = mktime (gmtime (&timestamp));",
          "13631:     }",
          "13632:     fseek (ifp, save, SEEK_SET);",
          "",
          "[Added Lines]",
          "14953:   fseek(ifp, 52, SEEK_SET);",
          "14954:   width = get4();",
          "14956:   fseek(ifp, 0, SEEK_END);",
          "14957:   fseek(ifp, -(i = ftello(ifp) & 511), SEEK_CUR);",
          "14958:   if (get4() != i || get4() != 0x52454f42)",
          "14959:   {",
          "14961:     fprintf(stderr, _(\"%s: Tail is missing, parsing from head...\\n\"), ifname);",
          "14963:     fseek(ifp, 0, SEEK_SET);",
          "14964:     while ((len = get4()) != EOF)",
          "14965:     {",
          "14967:         if (is_raw++ == shot_select)",
          "14968:           data_offset = ftello(ifp) - 8;",
          "14969:       fseek(ifp, len - 8, SEEK_CUR);",
          "14971:   }",
          "14972:   else",
          "14973:   {",
          "14975:     fseek(ifp, 12, SEEK_CUR);",
          "14977:     fseeko(ifp, rdvo + 8 + shot_select * 4, SEEK_SET);",
          "14983: char *CLASS foveon_gets(int offset, char *str, int len)",
          "14986:   fseek(ifp, offset, SEEK_SET);",
          "14987:   for (i = 0; i < len - 1; i++)",
          "14988:     if ((str[i] = get2()) == 0)",
          "14989:       break;",
          "14996:   int entries, img = 0, off, len, tag, save, i, wide, high, pent, poff[256][2];",
          "14999:   fseek(ifp, 36, SEEK_SET);",
          "15001:   fseek(ifp, -4, SEEK_END);",
          "15002:   fseek(ifp, get4(), SEEK_SET);",
          "15003:   if (get4() != 0x64434553)",
          "15005:   entries = (get4(), get4());",
          "15006:   while (entries--)",
          "15007:   {",
          "15012:     fseek(ifp, off, SEEK_SET);",
          "15013:     if (get4() != (0x20434553 | (tag << 24)))",
          "15014:       return;",
          "15015:     switch (tag)",
          "15016:     {",
          "15019:       fseek(ifp, 8, SEEK_CUR);",
          "15020:       pent = get4();",
          "15021:       wide = get4();",
          "15022:       high = get4();",
          "15023:       if (wide > raw_width && high > raw_height)",
          "15024:       {",
          "15025:         switch (pent)",
          "15026:         {",
          "15027:         case 5:",
          "15028:           load_flags = 1;",
          "15029:         case 6:",
          "15030:           load_raw = &CLASS foveon_sd_load_raw;",
          "15031:           break;",
          "15032:         case 30:",
          "15033:           load_raw = &CLASS foveon_dp_load_raw;",
          "15034:           break;",
          "15035:         default:",
          "15036:           load_raw = 0;",
          "15037:         }",
          "15038:         raw_width = wide;",
          "15039:         raw_height = high;",
          "15040:         data_offset = off + 28;",
          "15041:         is_foveon = 1;",
          "15042:       }",
          "15043:       fseek(ifp, off + 28, SEEK_SET);",
          "15044:       if (fgetc(ifp) == 0xff && fgetc(ifp) == 0xd8 && thumb_length < len - 28)",
          "15045:       {",
          "15046:         thumb_offset = off + 28;",
          "15047:         thumb_length = len - 28;",
          "15048:         write_thumb = &CLASS jpeg_thumb;",
          "15049:       }",
          "15050:       if (++img == 2 && !thumb_length)",
          "15051:       {",
          "15052:         thumb_offset = off + 24;",
          "15053:         thumb_width = wide;",
          "15054:         thumb_height = high;",
          "15055:         write_thumb = &CLASS foveon_thumb;",
          "15056:       }",
          "15057:       break;",
          "15059:       meta_offset = off + 8;",
          "15060:       meta_length = len - 28;",
          "15061:       break;",
          "15063:       pent = (get4(), get4());",
          "15064:       fseek(ifp, 12, SEEK_CUR);",
          "15065:       off += pent * 8 + 24;",
          "15066:       if ((unsigned)pent > 256)",
          "15067:         pent = 256;",
          "15068:       for (i = 0; i < pent * 2; i++)",
          "15069:         ((int *)poff)[i] = off + get4() * 2;",
          "15070:       for (i = 0; i < pent; i++)",
          "15071:       {",
          "15072:         foveon_gets(poff[i][0], name, 64);",
          "15073:         foveon_gets(poff[i][1], value, 64);",
          "15074:         if (!strcmp(name, \"ISO\"))",
          "15075:           iso_speed = atoi(value);",
          "15076:         if (!strcmp(name, \"CAMMANUF\"))",
          "15077:           strcpy(make, value);",
          "15078:         if (!strcmp(name, \"CAMMODEL\"))",
          "15079:           strcpy(model, value);",
          "15080:         if (!strcmp(name, \"WB_DESC\"))",
          "15081:           strcpy(model2, value);",
          "15082:         if (!strcmp(name, \"TIME\"))",
          "15083:           timestamp = atoi(value);",
          "15084:         if (!strcmp(name, \"EXPTIME\"))",
          "15085:           shutter = atoi(value) / 1000000.0;",
          "15086:         if (!strcmp(name, \"APERTURE\"))",
          "15087:           aperture = atof(value);",
          "15088:         if (!strcmp(name, \"FLENGTH\"))",
          "15089:           focal_len = atof(value);",
          "15090: #ifdef LIBRAW_LIBRARY_BUILD",
          "15091:         if (!strcmp(name, \"CAMSERIAL\"))",
          "15092:           strcpy(imgdata.shootinginfo.BodySerial, value);",
          "15093:         if (!strcmp(name, \"FLEQ35MM\"))",
          "15094:           imgdata.lens.makernotes.FocalLengthIn35mmFormat = atof(value);",
          "15095:         if (!strcmp(name, \"LENSARANGE\"))",
          "15096:         {",
          "15097:           char *sp;",
          "15098:           imgdata.lens.makernotes.MaxAp4CurFocal = imgdata.lens.makernotes.MinAp4CurFocal = atof(value);",
          "15099:           sp = strrchr(value, ' ');",
          "15100:           if (sp)",
          "15101:           {",
          "15102:             imgdata.lens.makernotes.MinAp4CurFocal = atof(sp);",
          "15103:             if (imgdata.lens.makernotes.MaxAp4CurFocal > imgdata.lens.makernotes.MinAp4CurFocal)",
          "15104:               my_swap(float, imgdata.lens.makernotes.MaxAp4CurFocal, imgdata.lens.makernotes.MinAp4CurFocal);",
          "15105:           }",
          "15107:         if (!strcmp(name, \"LENSFRANGE\"))",
          "15108:         {",
          "15109:           char *sp;",
          "15110:           imgdata.lens.makernotes.MinFocal = imgdata.lens.makernotes.MaxFocal = atof(value);",
          "15111:           sp = strrchr(value, ' ');",
          "15112:           if (sp)",
          "15113:           {",
          "15114:             imgdata.lens.makernotes.MaxFocal = atof(sp);",
          "15115:             if ((imgdata.lens.makernotes.MaxFocal + 0.17f) < imgdata.lens.makernotes.MinFocal)",
          "15116:               my_swap(float, imgdata.lens.makernotes.MaxFocal, imgdata.lens.makernotes.MinFocal);",
          "15117:           }",
          "15118:         }",
          "15119:         if (!strcmp(name, \"LENSMODEL\"))",
          "15120:         {",
          "15121:           char *sp;",
          "15122:           imgdata.lens.makernotes.LensID = strtol(value, &sp, 16); // atoi(value);",
          "15123:           if (imgdata.lens.makernotes.LensID)",
          "15124:             imgdata.lens.makernotes.LensMount = Sigma_X3F;",
          "15125:         }",
          "15126:       }",
          "15130:     timestamp = mktime(gmtime(&timestamp));",
          "15133:   fseek(ifp, save, SEEK_SET);",
          "15134: }",
          "",
          "---------------",
          "--- Hunk 114 ---",
          "[Context before]",
          "13639:    All matrices are from Adobe DNG Converter unless otherwise noted.",
          "13642: #ifdef LIBRAW_LIBRARY_BUILD",
          "13644: #endif",
          "13646: {",
          "13648:     const char *prefix;",
          "13649:     int t_black, t_maximum, trans[12];",
          "13650:   } table[] = {",
          "14841:   };",
          "14842:   double cam_xyz[4][3];",
          "14843:   char name[130];",
          "14844:   int i, j;",
          "14850:   {",
          "14854:   }",
          "14877: #ifdef LIBRAW_LIBRARY_BUILD",
          "14882: #endif",
          "14884: #ifdef LIBRAW_LIBRARY_BUILD",
          "14886: #endif",
          "14888:       }",
          "14889:       break;",
          "14890:     }",
          "14891: }",
          "14894: {",
          "14907:   int i, c;",
          "14911: }",
          "14914: {",
          "14915:   uchar test[4][2];",
          "14926:     }",
          "14928:   }",
          "14929:   return sum[0] < sum[1] ? 0x4d4d : 0x4949;",
          "14930: }",
          "14933: {",
          "14935:   int vbits, col, i, c;",
          "14936:   ushort img[2][2064];",
          "14946:       }",
          "14948:     }",
          "14949:   }",
          "14953:   }",
          "14955: }",
          "14957: #ifdef LIBRAW_LIBRARY_BUILD",
          "14958: static void remove_trailing_spaces(char *string, size_t len)",
          "14959: {",
          "14968:     else",
          "14969:       break;",
          "14970:   }",
          "14971: }",
          "14974: #endif",
          "14976:    Identify which camera created this file, and set global variables",
          "",
          "[Removed Lines]",
          "13641: void CLASS adobe_coeff (const char *t_make, const char *t_model",
          "13643:  ,int internal_only",
          "13645: )",
          "13647:   static const struct {",
          "13652:       { 11438,-3762,-1115,-2409,9914,2497,-1227,2295,5300 } },",
          "13654:       { 21392,-5653,-3353,2406,8010,-415,7166,1427,2078 } },",
          "13655:     {\"Broadcom RPi IMX219\", 66, 0x3ff,",
          "13657:     { \"Broadcom RPi OV5647\", 16, 0x3ff,",
          "13659:     { \"Canon EOS D2000\", 0, 0,",
          "13660:       { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },",
          "13661:     { \"Canon EOS D6000\", 0, 0,",
          "13662:       { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },",
          "13663:     { \"Canon EOS D30\", 0, 0,",
          "13664:       { 9805,-2689,-1312,-5803,13064,3068,-2438,3075,8775 } },",
          "13665:     { \"Canon EOS D60\", 0, 0xfa0,",
          "13666:       { 6188,-1341,-890,-7168,14489,2937,-2640,3228,8483 } },",
          "13667:     { \"Canon EOS 5DS\", 0, 0x3c96,",
          "13668:       { 6250,-711,-808,-5153,12794,2636,-1249,2198,5610 } },",
          "13669:     { \"Canon EOS 5D Mark IV\", 0, 0,",
          "13670:       { 6446, -366, -864, -4436, 12204, 2513, -952, 2496, 6348 }},",
          "13671:     { \"Canon EOS 5D Mark III\", 0, 0x3c80,",
          "13672:       { 6722,-635,-963,-4287,12460,2028,-908,2162,5668 } },",
          "13673:     { \"Canon EOS 5D Mark II\", 0, 0x3cf0,",
          "13674:       { 4716,603,-830,-7798,15474,2480,-1496,1937,6651 } },",
          "13675:     { \"Canon EOS 5D\", 0, 0xe6c,",
          "13676:       { 6347,-479,-972,-8297,15954,2480,-1968,2131,7649 } },",
          "13677:     { \"Canon EOS 6D\", 0, 0x3c82,",
          "13678:       { 8621,-2197,-787,-3150,11358,912,-1161,2400,4836 } },",
          "13679:     { \"Canon EOS 7D Mark II\", 0, 0x3510,",
          "13680:       { 7268,-1082,-969,-4186,11839,2663,-825,2029,5839 } },",
          "13681:     { \"Canon EOS 7D\", 0, 0x3510,",
          "13682:       { 6844,-996,-856,-3876,11761,2396,-593,1772,6198 } },",
          "13683:     { \"Canon EOS 80D\", 0, 0,",
          "13684:       { 7457,-671,-937,-4849,12495,2643,-1213,2354,5492 } },",
          "13685:     { \"Canon EOS 10D\", 0, 0xfa0,",
          "13686:       { 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },",
          "13687:     { \"Canon EOS 20Da\", 0, 0,",
          "13688:       { 14155,-5065,-1382,-6550,14633,2039,-1623,1824,6561 } },",
          "13689:     { \"Canon EOS 20D\", 0, 0xfff,",
          "13690:       { 6599,-537,-891,-8071,15783,2424,-1983,2234,7462 } },",
          "13691:     { \"Canon EOS 30D\", 0, 0,",
          "13692:       { 6257,-303,-1000,-7880,15621,2396,-1714,1904,7046 } },",
          "13693:     { \"Canon EOS 40D\", 0, 0x3f60,",
          "13694:       { 6071,-747,-856,-7653,15365,2441,-2025,2553,7315 } },",
          "13695:     { \"Canon EOS 50D\", 0, 0x3d93,",
          "13696:       { 4920,616,-593,-6493,13964,2784,-1774,3178,7005 } },",
          "13697:     { \"Canon EOS 60D\", 0, 0x2ff7,",
          "13698:       { 6719,-994,-925,-4408,12426,2211,-887,2129,6051 } },",
          "13699:     { \"Canon EOS 70D\", 0, 0x3bc7,",
          "13700:       { 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },",
          "13701:     { \"Canon EOS 100D\", 0, 0x350f,",
          "13702:       { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },",
          "13703:     { \"Canon EOS 300D\", 0, 0xfa0,",
          "13704:       { 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },",
          "13705:     { \"Canon EOS 350D\", 0, 0xfff,",
          "13706:       { 6018,-617,-965,-8645,15881,2975,-1530,1719,7642 } },",
          "13707:     { \"Canon EOS 400D\", 0, 0xe8e,",
          "13708:       { 7054,-1501,-990,-8156,15544,2812,-1278,1414,7796 } },",
          "13709:     { \"Canon EOS 450D\", 0, 0x390d,",
          "13710:       { 5784,-262,-821,-7539,15064,2672,-1982,2681,7427 } },",
          "13711:     { \"Canon EOS 500D\", 0, 0x3479,",
          "13712:       { 4763,712,-646,-6821,14399,2640,-1921,3276,6561 } },",
          "13713:     { \"Canon EOS 550D\", 0, 0x3dd7,",
          "13714:       { 6941,-1164,-857,-3825,11597,2534,-416,1540,6039 } },",
          "13715:     { \"Canon EOS 600D\", 0, 0x3510,",
          "13716:       { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },",
          "13717:     { \"Canon EOS 650D\", 0, 0x354d,",
          "13718:       { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },",
          "13719:     { \"Canon EOS 750D\", 0, 0x3c00,",
          "13720:       { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },",
          "13721:     { \"Canon EOS 760D\", 0, 0x3c00,",
          "13722:       { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },",
          "13723:     { \"Canon EOS 700D\", 0, 0x3c00,",
          "13724:       { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },",
          "13725:     { \"Canon EOS 1000D\", 0, 0xe43,",
          "13726:       { 6771,-1139,-977,-7818,15123,2928,-1244,1437,7533 } },",
          "13727:     { \"Canon EOS 1100D\", 0, 0x3510,",
          "13728:       { 6444,-904,-893,-4563,12308,2535,-903,2016,6728 } },",
          "13729:     { \"Canon EOS 1200D\", 0, 0x37c2,",
          "13730:       { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },",
          "13731:     { \"Canon EOS 1300D\", 0, 0x37c2,",
          "13732:       { 6939, -1016, -866, -4428, 12473, 2177, -1175, 2178, 6162 } },",
          "13733:     { \"Canon EOS M3\", 0, 0,",
          "13734:       { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },",
          "13736:       { 8532, -701, -1167, -4095, 11879, 2508, -797, 2424, 7010 }},",
          "13737:     { \"Canon EOS M10\", 0, 0,",
          "13738:       { 6400,-480,-888,-5294,13416,2047,-1296,2203,6137 } },",
          "13739:     { \"Canon EOS M\", 0, 0,",
          "13740:       { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },",
          "13741:     { \"Canon EOS-1Ds Mark III\", 0, 0x3bb0,",
          "13742:       { 5859,-211,-930,-8255,16017,2353,-1732,1887,7448 } },",
          "13743:     { \"Canon EOS-1Ds Mark II\", 0, 0xe80,",
          "13744:       { 6517,-602,-867,-8180,15926,2378,-1618,1771,7633 } },",
          "13745:     { \"Canon EOS-1D Mark IV\", 0, 0x3bb0,",
          "13746:       { 6014,-220,-795,-4109,12014,2361,-561,1824,5787 } },",
          "13747:     { \"Canon EOS-1D Mark III\", 0, 0x3bb0,",
          "13748:       { 6291,-540,-976,-8350,16145,2311,-1714,1858,7326 } },",
          "13749:     { \"Canon EOS-1D Mark II N\", 0, 0xe80,",
          "13750:       { 6240,-466,-822,-8180,15825,2500,-1801,1938,8042 } },",
          "13751:     { \"Canon EOS-1D Mark II\", 0, 0xe80,",
          "13752:       { 6264,-582,-724,-8312,15948,2504,-1744,1919,8664 } },",
          "13753:     { \"Canon EOS-1DS\", 0, 0xe20,",
          "13754:       { 4374,3631,-1743,-7520,15212,2472,-2892,3632,8161 } },",
          "13755:     { \"Canon EOS-1D C\", 0, 0x3c4e,",
          "13756:       { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },",
          "13757:     { \"Canon EOS-1D X Mark II\", 0, 0x3c4e,",
          "13758:       { 7596,-978,967,-4808,12571,2503,-1398,2567,5752 } },",
          "13759:     { \"Canon EOS-1D X\", 0, 0x3c4e,",
          "13760:       { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },",
          "13761:     { \"Canon EOS-1D\", 0, 0xe20,",
          "13762:       { 6806,-179,-1020,-8097,16415,1687,-3267,4236,7690 } },",
          "13764:       { 17851,-10604,922,-7425,16662,763,-3660,3636,22278 } },",
          "13765:     { \"Canon PowerShot A530\", 0, 0,",
          "13767:     { \"Canon PowerShot A50\", 0, 0,",
          "13768:       { -5300,9846,1776,3436,684,3939,-5540,9879,6200,-1404,11175,217 } },",
          "13769:     { \"Canon PowerShot A5\", 0, 0,",
          "13770:       { -4801,9475,1952,2926,1611,4094,-5259,10164,5947,-1554,10883,547 } },",
          "13771:     { \"Canon PowerShot G10\", 0, 0,",
          "13772:       { 11093,-3906,-1028,-5047,12492,2879,-1003,1750,5561 } },",
          "13773:     { \"Canon PowerShot G11\", 0, 0,",
          "13774:       { 12177,-4817,-1069,-1612,9864,2049,-98,850,4471 } },",
          "13775:     { \"Canon PowerShot G12\", 0, 0,",
          "13776:       { 13244,-5501,-1248,-1508,9858,1935,-270,1083,4366 } },",
          "13777:     { \"Canon PowerShot G15\", 0, 0,",
          "13778:       { 7474,-2301,-567,-4056,11456,2975,-222,716,4181 } },",
          "13779:     { \"Canon PowerShot G16\", 0, 0,",
          "13780:       { 14130,-8071,127,2199,6528,1551,3402,-1721,4960 } },",
          "13781:     { \"Canon PowerShot G1 X Mark II\", 0, 0,",
          "13782:       { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },",
          "13783:     { \"Canon PowerShot G1 X\", 0, 0,",
          "13784:       { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },",
          "13785:     { \"Canon PowerShot G1\", 0, 0,",
          "13786:       { -4778,9467,2172,4743,-1141,4344,-5146,9908,6077,-1566,11051,557 } },",
          "13787:     { \"Canon PowerShot G2\", 0, 0,",
          "13788:       { 9087,-2693,-1049,-6715,14382,2537,-2291,2819,7790 } },",
          "13789:     { \"Canon PowerShot G3 X\", 0, 0,",
          "13790:       { 9701,-3857,-921,-3149,11537,1817,-786,1817,5147 } },",
          "13791:     { \"Canon PowerShot G3\", 0, 0,",
          "13792:       { 9212,-2781,-1073,-6573,14189,2605,-2300,2844,7664 } },",
          "13793:     { \"Canon PowerShot G5 X\",0, 0,",
          "13794:       { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },",
          "13795:     { \"Canon PowerShot G5\", 0, 0,",
          "13796:       { 9757,-2872,-933,-5972,13861,2301,-1622,2328,7212 } },",
          "13797:     { \"Canon PowerShot G6\", 0, 0,",
          "13798:       { 9877,-3775,-871,-7613,14807,3072,-1448,1305,7485 } },",
          "13799:     { \"Canon PowerShot G7 X Mark II\", 0, 0,",
          "13800:       { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },",
          "13801:     { \"Canon PowerShot G7 X\", 0, 0,",
          "13802:       { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },",
          "13803:     { \"Canon PowerShot G9 X\",0, 0,",
          "13804:       { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },",
          "13805:     { \"Canon PowerShot G9\", 0, 0,",
          "13806:       { 7368,-2141,-598,-5621,13254,2625,-1418,1696,5743 } },",
          "13807:     { \"Canon PowerShot Pro1\", 0, 0,",
          "13808:       { 10062,-3522,-999,-7643,15117,2730,-765,817,7323 } },",
          "13809:     { \"Canon PowerShot Pro70\", 34, 0,",
          "13810:       { -4155,9818,1529,3939,-25,4522,-5521,9870,6610,-2238,10873,1342 } },",
          "13811:     { \"Canon PowerShot Pro90\", 0, 0,",
          "13812:       { -4963,9896,2235,4642,-987,4294,-5162,10011,5859,-1770,11230,577 } },",
          "13813:     { \"Canon PowerShot S30\", 0, 0,",
          "13814:       { 10566,-3652,-1129,-6552,14662,2006,-2197,2581,7670 } },",
          "13815:     { \"Canon PowerShot S40\", 0, 0,",
          "13816:       { 8510,-2487,-940,-6869,14231,2900,-2318,2829,9013 } },",
          "13817:     { \"Canon PowerShot S45\", 0, 0,",
          "13818:       { 8163,-2333,-955,-6682,14174,2751,-2077,2597,8041 } },",
          "13819:     { \"Canon PowerShot S50\", 0, 0,",
          "13820:       { 8882,-2571,-863,-6348,14234,2288,-1516,2172,6569 } },",
          "13821:     { \"Canon PowerShot S60\", 0, 0,",
          "13822:       { 8795,-2482,-797,-7804,15403,2573,-1422,1996,7082 } },",
          "13823:     { \"Canon PowerShot S70\", 0, 0,",
          "13824:       { 9976,-3810,-832,-7115,14463,2906,-901,989,7889 } },",
          "13825:     { \"Canon PowerShot S90\", 0, 0,",
          "13826:       { 12374,-5016,-1049,-1677,9902,2078,-83,852,4683 } },",
          "13827:     { \"Canon PowerShot S95\", 0, 0,",
          "13828:       { 13440,-5896,-1279,-1236,9598,1931,-180,1001,4651 } },",
          "13829:     { \"Canon PowerShot S120\", 0, 0,",
          "13830:       { 6961,-1685,-695,-4625,12945,1836,-1114,2152,5518 } },",
          "13831:     { \"Canon PowerShot S110\", 0, 0,",
          "13832:       { 8039,-2643,-654,-3783,11230,2930,-206,690,4194 } },",
          "13833:     { \"Canon PowerShot S100\", 0, 0,",
          "13834:       { 7968,-2565,-636,-2873,10697,2513,180,667,4211 } },",
          "13835:     { \"Canon PowerShot SX1 IS\", 0, 0,",
          "13836:       { 6578,-259,-502,-5974,13030,3309,-308,1058,4970 } },",
          "13837:     { \"Canon PowerShot SX50 HS\", 0, 0,",
          "13838:       { 12432,-4753,-1247,-2110,10691,1629,-412,1623,4926 } },",
          "13839:     { \"Canon PowerShot SX60 HS\", 0, 0,",
          "13840:       { 13161,-5451,-1344,-1989,10654,1531,-47,1271,4955 } },",
          "13842:       { 10826,-3654,-1023,-3215,11310,1906,0,999,4960 } },",
          "13844:       { 12513,-4407,-1242,-2680,10276,2405,-878,2215,4734 } },",
          "13846:       { 15591,-6402,-1592,-5365,13198,2168,-1300,1824,5075 } },",
          "13848:       { 15265,-6193,-1558,-4125,12116,2010,-888,1639,5220 } },",
          "13850:       { 14201,-5308,-1757,-6087,14472,1617,-2191,3105,5348 } },",
          "13852:       { 13124,-5329,-1390,-3602,11658,1944,-1612,2863,4885 } },",
          "13854:       { 9427,-3036,-959,-2581,10671,1911,-1039,1982,4430 } },",
          "13856:       { 14573,-5482,-1546,-1266,9799,1468,-1040,1912,3810 } },",
          "13858:       { 14062,-5199,-1446,-4712,12470,2243,-1286,2028,4836 } },",
          "13860:       { 14134,-5576,-1527,-1991,10719,1273,-1158,1929,3581 } },",
          "13862:       { 13898,-5076,-1447,-1405,10109,1297,-244,1860,3687 } },",
          "13864:       { 11657,-3781,-1136,-3544,11262,2283,-160,1219,4700 } },",
          "13866:       { 11634,-3924,-1128,-4968,12954,2015,-1588,2648,7206 } },",
          "13868:       { 10819,-3873,-1099,-4903,13730,1175,-1755,3751,4632 } },",
          "13870:       { 9790,-3338,-603,-2321,10222,2099,-344,1273,4799 } },",
          "13871:     { \"CINE 650\", 0, 0,",
          "13872:       { 3390,480,-500,-800,3610,340,-550,2336,1192 } },",
          "13873:     { \"CINE 660\", 0, 0,",
          "13874:       { 3390,480,-500,-800,3610,340,-550,2336,1192 } },",
          "13875:     { \"CINE\", 0, 0,",
          "13876:       { 20183,-4295,-423,-3940,15330,3985,-280,4870,9800 } },",
          "13877:     { \"Contax N Digital\", 0, 0xf1e,",
          "13878:       { 7777,1285,-1053,-9280,16543,2916,-3677,5679,7060 } },",
          "13879:     { \"DXO ONE\", 0, 0,",
          "13880:       { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },",
          "13881:     { \"Epson R-D1\", 0, 0,",
          "13882:       { 6827,-1878,-732,-8429,16012,2564,-704,592,7145 } },",
          "13883:     { \"Fujifilm E550\", 0, 0,",
          "13884:       { 11044,-3888,-1120,-7248,15168,2208,-1531,2277,8069 } },",
          "13885:     { \"Fujifilm E900\", 0, 0,",
          "13886:       { 9183,-2526,-1078,-7461,15071,2574,-2022,2440,8639 } },",
          "13887:     { \"Fujifilm F5\", 0, 0,",
          "13888:       { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },",
          "13889:     { \"Fujifilm F6\", 0, 0,",
          "13890:       { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },",
          "13891:     { \"Fujifilm F77\", 0, 0xfe9,",
          "13892:       { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },",
          "13893:     { \"Fujifilm F7\", 0, 0,",
          "13894:       { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },",
          "13895:     { \"Fujifilm F8\", 0, 0,",
          "13896:       { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },",
          "13897:     { \"Fujifilm S100FS\", 514, 0,",
          "13898:       { 11521,-4355,-1065,-6524,13767,3058,-1466,1984,6045 } },",
          "13899:     { \"Fujifilm S1\", 0, 0,",
          "13900:       { 12297,-4882,-1202,-2106,10691,1623,-88,1312,4790 } },",
          "13901:     { \"Fujifilm S20Pro\", 0, 0,",
          "13902:       { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },",
          "13903:     { \"Fujifilm S20\", 512, 0x3fff,",
          "13904:       { 11401,-4498,-1312,-5088,12751,2613,-838,1568,5941 } },",
          "13905:     { \"Fujifilm S2Pro\", 128, 0,",
          "13906:       { 12492,-4690,-1402,-7033,15423,1647,-1507,2111,7697 } },",
          "13907:     { \"Fujifilm S3Pro\", 0, 0,",
          "13908:       { 11807,-4612,-1294,-8927,16968,1988,-2120,2741,8006 } },",
          "13909:     { \"Fujifilm S5Pro\", 0, 0,",
          "13910:       { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },",
          "13911:     { \"Fujifilm S5000\", 0, 0,",
          "13912:       { 8754,-2732,-1019,-7204,15069,2276,-1702,2334,6982 } },",
          "13913:     { \"Fujifilm S5100\", 0, 0,",
          "13914:       { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },",
          "13915:     { \"Fujifilm S5500\", 0, 0,",
          "13916:       { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },",
          "13917:     { \"Fujifilm S5200\", 0, 0,",
          "13918:       { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },",
          "13919:     { \"Fujifilm S5600\", 0, 0,",
          "13920:       { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },",
          "13921:     { \"Fujifilm S6\", 0, 0,",
          "13922:       { 12628,-4887,-1401,-6861,14996,1962,-2198,2782,7091 } },",
          "13923:     { \"Fujifilm S7000\", 0, 0,",
          "13924:       { 10190,-3506,-1312,-7153,15051,2238,-2003,2399,7505 } },",
          "13925:     { \"Fujifilm S9000\", 0, 0,",
          "13926:       { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },",
          "13927:     { \"Fujifilm S9500\", 0, 0,",
          "13928:       { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },",
          "13929:     { \"Fujifilm S9100\", 0, 0,",
          "13930:       { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },",
          "13931:     { \"Fujifilm S9600\", 0, 0,",
          "13932:       { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },",
          "13933:     { \"Fujifilm SL1000\", 0, 0,",
          "13934:       { 11705,-4262,-1107,-2282,10791,1709,-555,1713,4945 } },",
          "13935:     { \"Fujifilm IS-1\", 0, 0,",
          "13936:       { 21461,-10807,-1441,-2332,10599,1999,289,875,7703 } },",
          "13937:     { \"Fujifilm IS Pro\", 0, 0,",
          "13938:       { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },",
          "13939:     { \"Fujifilm HS10 HS11\", 0, 0xf68,",
          "13940:       { 12440,-3954,-1183,-1123,9674,1708,-83,1614,4086 } },",
          "13941:     { \"Fujifilm HS2\", 0, 0,",
          "13942:       { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },",
          "13943:     { \"Fujifilm HS3\", 0, 0,",
          "13944:       { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },",
          "13945:     { \"Fujifilm HS50EXR\", 0, 0,",
          "13946:       { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },",
          "13947:     { \"Fujifilm F900EXR\", 0, 0,",
          "13948:       { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },",
          "13949:     { \"Fujifilm X100S\", 0, 0,",
          "13950:       { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },",
          "13951:     { \"Fujifilm X100T\", 0, 0,",
          "13952:       { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },",
          "13953:     { \"Fujifilm X100\", 0, 0,",
          "13954:       { 12161,-4457,-1069,-5034,12874,2400,-795,1724,6904 } },",
          "13955:     { \"Fujifilm X10\", 0, 0,",
          "13956:       { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },",
          "13957:     { \"Fujifilm X20\", 0, 0,",
          "13958:       { 11768,-4971,-1133,-4904,12927,2183,-480,1723,4605 } },",
          "13959:     { \"Fujifilm X30\", 0, 0,",
          "13960:       { 12328,-5256,-1144,-4469,12927,1675,-87,1291,4351 } },",
          "13961:     { \"Fujifilm X70\", 0, 0,",
          "13962:       { 10450,-4329,-878,-3217,11105,2421,-752,1758,6519 } },",
          "13963:     { \"Fujifilm X-Pro1\", 0, 0,",
          "13964:       { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },",
          "13965:     { \"Fujifilm X-Pro2\", 0, 0,",
          "13966:       { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },",
          "13967:     { \"Fujifilm X-A1\", 0, 0,",
          "13968:       { 11086,-4555,-839,-3512,11310,2517,-815,1341,5940 } },",
          "13969:     { \"Fujifilm X-A2\", 0, 0,",
          "13970:       { 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },",
          "13971:     { \"Fujifilm X-E1\", 0, 0,",
          "13972:       { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },",
          "13973:     { \"Fujifilm X-E2S\", 0, 0,",
          "13974:       { 11562,-5118,-961,-3022,11007,2311,-525,1569,6097 } },",
          "13975:     { \"Fujifilm X-E2\", 0, 0,",
          "13976:       { 12066,-5927,-367,-1969,9878,1503,-721,2034,5453 } },",
          "13977:     { \"Fujifilm XF1\", 0, 0,",
          "13978:       { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },",
          "13979:     { \"Fujifilm X-M1\", 0, 0,",
          "13980:       { 13193,-6685,-425,-2229,10458,1534,-878,1763,5217 } },",
          "13981:     { \"Fujifilm X-S1\", 0, 0,",
          "13982:       { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },",
          "13983:     { \"Fujifilm X-T10\", 0, 0,",
          "13984:       { 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },",
          "13985:     { \"Fujifilm X-T1\", 0, 0,",
          "13986:       { 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526 } },",
          "13987:     { \"Fujifilm X-T2\", 0, 0,",
          "13988:       { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },",
          "13989:     { \"Fujifilm XQ1\", 0, 0,",
          "13990:       { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },",
          "13991:     { \"Fujifilm XQ2\", 0, 0,",
          "13992:       { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },",
          "13993:     { \"GITUP GIT2\", 3200, 0,",
          "13994:       {8489, -2583,-1036,-8051,15583,2643,-1307,1407,7354}},",
          "13995:     { \"Hasselblad Lunar\", 0, 0,",
          "13996:       { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },",
          "13997:     { \"Hasselblad Stellar\", -800, 0,",
          "13998:       { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },",
          "14000:       { 8519, -3260, -280, -5081, 13459, 1738, -1449, 2960, 7809, } },",
          "14002:       { 17765,-5322,-1734,-6168,13354,2135,-264,2524,7440 } },",
          "14004:       { 17765,-5322,-1734,-6168,13354,2135,-264,2524,7440 } },",
          "14006:       { 14480,-5448,-1686,-3534,13123,2260,384,2952,7232 } },",
          "14008:       { 3857,452, -46, -6008, 14477, 1596, -2627, 4481, 5718 } },",
          "14010:       { 3857,452, -46, -6008, 14477, 1596, -2627, 4481, 5718 } },",
          "14012:       { 6325,-860,-957,-6559,15945,266,167,770,5936 } },",
          "14014:       { 15283,-6272,-465,-2030,16031,478,-2379,390,7965 } },",
          "14016:       { 9662, -684, -279, -4903, 12293, 2950, -344, 1669, 6024 } },",
          "14018:       { 4932, -835, 141, -4878, 11868, 3437, -1138, 1961, 7067 } },",
          "14020:       { 5656, -659, -346, -3923, 12306, 1791, -1602, 3509, 5442 } },",
          "14022:       {4932, -835, 141, -4878, 11868, 3437, -1138, 1961, 7067 }},",
          "14024:       { 101, -20, -2, -11, 145, 41, -24, 1, 56 } },",
          "14026:       { 7025,-1415,-704,-5188,13765,1424,-1248,2742,6038 } },",
          "14027:     { \"Kodak NC2000\", 0, 0,",
          "14028:       { 13891,-6055,-803,-465,9919,642,2121,82,1291 } },",
          "14029:     { \"Kodak DCS315C\", -8, 0,",
          "14030:       { 17523,-4827,-2510,756,8546,-137,6113,1649,2250 } },",
          "14031:     { \"Kodak DCS330C\", -8, 0,",
          "14032:       { 20620,-7572,-2801,-103,10073,-396,3551,-233,2220 } },",
          "14033:     { \"Kodak DCS420\", 0, 0,",
          "14034:       { 10868,-1852,-644,-1537,11083,484,2343,628,2216 } },",
          "14035:     { \"Kodak DCS460\", 0, 0,",
          "14036:       { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },",
          "14037:     { \"Kodak EOSDCS1\", 0, 0,",
          "14038:       { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },",
          "14039:     { \"Kodak EOSDCS3B\", 0, 0,",
          "14040:       { 9898,-2700,-940,-2478,12219,206,1985,634,1031 } },",
          "14041:     { \"Kodak DCS520C\", -178, 0,",
          "14042:       { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },",
          "14043:     { \"Kodak DCS560C\", -177, 0,",
          "14044:       { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },",
          "14045:     { \"Kodak DCS620C\", -177, 0,",
          "14046:       { 23617,-10175,-3149,-2054,11749,-272,2586,-489,3453 } },",
          "14047:     { \"Kodak DCS620X\", -176, 0,",
          "14048:       { 13095,-6231,154,12221,-21,-2137,895,4602,2258 } },",
          "14049:     { \"Kodak DCS660C\", -173, 0,",
          "14050:       { 18244,-6351,-2739,-791,11193,-521,3711,-129,2802 } },",
          "14051:     { \"Kodak DCS720X\", 0, 0,",
          "14052:       { 11775,-5884,950,9556,1846,-1286,-1019,6221,2728 } },",
          "14053:     { \"Kodak DCS760C\", 0, 0,",
          "14054:       { 16623,-6309,-1411,-4344,13923,323,2285,274,2926 } },",
          "14055:     { \"Kodak DCS Pro SLR\", 0, 0,",
          "14056:       { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },",
          "14057:     { \"Kodak DCS Pro 14nx\", 0, 0,",
          "14058:       { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },",
          "14059:     { \"Kodak DCS Pro 14\", 0, 0,",
          "14060:       { 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 } },",
          "14061:     { \"Kodak ProBack645\", 0, 0,",
          "14062:       { 16414,-6060,-1470,-3555,13037,473,2545,122,4948 } },",
          "14063:     { \"Kodak ProBack\", 0, 0,",
          "14064:       { 21179,-8316,-2918,-915,11019,-165,3477,-180,4210 } },",
          "14065:     { \"Kodak P712\", 0, 0,",
          "14066:       { 9658,-3314,-823,-5163,12695,2768,-1342,1843,6044 } },",
          "14067:     { \"Kodak P850\", 0, 0xf7c,",
          "14068:       { 10511,-3836,-1102,-6946,14587,2558,-1481,1792,6246 } },",
          "14069:     { \"Kodak P880\", 0, 0xfff,",
          "14070:       { 12805,-4662,-1376,-7480,15267,2360,-1626,2194,7904 } },",
          "14071:     { \"Kodak EasyShare Z980\", 0, 0,",
          "14072:       { 11313,-3559,-1101,-3893,11891,2257,-1214,2398,4908 } },",
          "14073:     { \"Kodak EasyShare Z981\", 0, 0,",
          "14074:       { 12729,-4717,-1188,-1367,9187,2582,274,860,4411 } },",
          "14075:     { \"Kodak EasyShare Z990\", 0, 0xfed,",
          "14076:       { 11749,-4048,-1309,-1867,10572,1489,-138,1449,4522 } },",
          "14077:     { \"Kodak EASYSHARE Z1015\", 0, 0xef1,",
          "14078:       { 11265,-4286,-992,-4694,12343,2647,-1090,1523,5447 } },",
          "14079:     { \"Leaf CMost\", 0, 0,",
          "14080:       { 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },",
          "14081:     { \"Leaf Valeo 6\", 0, 0,",
          "14082:       { 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },",
          "14083:     { \"Leaf Aptus 54S\", 0, 0,",
          "14084:       { 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },",
          "14085:     { \"Leaf Aptus 65\", 0, 0,",
          "14086:       { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },",
          "14087:     { \"Leaf Aptus 75\", 0, 0,",
          "14088:       { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },",
          "14089:     { \"Leaf Credo 40\", 0, 0,",
          "14090:       { 8035, 435, -962, -6001, 13872, 2320, -1159, 3065, 5434 } },",
          "14091:     { \"Leaf Credo 50\", 0, 0,",
          "14092:       { 3984, 0, 0, 0, 10000, 0, 0, 0, 7666 } },",
          "14093:     { \"Leaf Credo 60\", 0, 0,",
          "14094:       { 8035, 435, -962, -6001, 13872,2320,-1159,3065,5434 } },",
          "14095:     { \"Leaf Credo 80\", 0, 0,",
          "14096:       { 6294, 686, -712, -5435, 13417, 2211, -1006, 2435, 5042 } },",
          "14097:     { \"Leaf\", 0, 0,",
          "14098:       { 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },",
          "14099:     { \"Mamiya ZD\", 0, 0,",
          "14100:       { 7645,2579,-1363,-8689,16717,2015,-3712,5941,5961 } },",
          "14102:       { 16695,-3761,-2151,155,9682,163,3433,951,4904 } },",
          "14103:     { \"Minolta DiMAGE 5\", 0, 0xf7d,",
          "14104:       { 8983,-2942,-963,-6556,14476,2237,-2426,2887,8014 } },",
          "14105:     { \"Minolta DiMAGE 7Hi\", 0, 0xf7d,",
          "14106:       { 11368,-3894,-1242,-6521,14358,2339,-2475,3056,7285 } },",
          "14107:     { \"Minolta DiMAGE 7\", 0, 0xf7d,",
          "14108:       { 9144,-2777,-998,-6676,14556,2281,-2470,3019,7744 } },",
          "14109:     { \"Minolta DiMAGE A1\", 0, 0xf8b,",
          "14110:       { 9274,-2547,-1167,-8220,16323,1943,-2273,2720,8340 } },",
          "14111:     { \"Minolta DiMAGE A200\", 0, 0,",
          "14112:       { 8560,-2487,-986,-8112,15535,2771,-1209,1324,7743 } },",
          "14113:     { \"Minolta DiMAGE A2\", 0, 0xf8f,",
          "14114:       { 9097,-2726,-1053,-8073,15506,2762,-966,981,7763 } },",
          "14116:       { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },",
          "14117:     { \"Minolta DYNAX 5\", 0, 0xffb,",
          "14118:       { 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },",
          "14119:     { \"Minolta DYNAX 7\", 0, 0xffb,",
          "14120:       { 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },",
          "14122:       { 8898,-989,-1033,-3292,11619,1674,-661,3178,5216 } },",
          "14123:     { \"Nikon D100\", 0, 0,",
          "14124:       { 5902,-933,-782,-8983,16719,2354,-1402,1455,6464 } },",
          "14125:     { \"Nikon D1H\", 0, 0,",
          "14126:       { 7577,-2166,-926,-7454,15592,1934,-2377,2808,8606 } },",
          "14127:     { \"Nikon D1X\", 0, 0,",
          "14128:       { 7702,-2245,-975,-9114,17242,1875,-2679,3055,8521 } },",
          "14130:       { 16772,-4726,-2141,-7611,15713,1972,-2846,3494,9521 } },",
          "14131:     { \"Nikon D200\", 0, 0xfbc,",
          "14132:       { 8367,-2248,-763,-8758,16447,2422,-1527,1550,8053 } },",
          "14133:     { \"Nikon D2H\", 0, 0,",
          "14134:       { 5710,-901,-615,-8594,16617,2024,-2975,4120,6830 } },",
          "14135:     { \"Nikon D2X\", 0, 0,",
          "14136:       { 10231,-2769,-1255,-8301,15900,2552,-797,680,7148 } },",
          "14137:     { \"Nikon D3000\", 0, 0,",
          "14138:       { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },",
          "14139:     { \"Nikon D3100\", 0, 0,",
          "14140:       { 7911,-2167,-813,-5327,13150,2408,-1288,2483,7968 } },",
          "14141:     { \"Nikon D3200\", 0, 0xfb9,",
          "14142:       { 7013,-1408,-635,-5268,12902,2640,-1470,2801,7379 } },",
          "14143:     { \"Nikon D3300\", 0, 0,",
          "14144:       { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },",
          "14145:     { \"Nikon D3400\", 0, 0,",
          "14146:       { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },",
          "14147:     { \"Nikon D300\", 0, 0,",
          "14148:       { 9030,-1992,-715,-8465,16302,2255,-2689,3217,8069 } },",
          "14149:     { \"Nikon D3X\", 0, 0,",
          "14150:       { 7171,-1986,-648,-8085,15555,2718,-2170,2512,7457 } },",
          "14151:     { \"Nikon D3S\", 0, 0,",
          "14152:       { 8828,-2406,-694,-4874,12603,2541,-660,1509,7587 } },",
          "14153:     { \"Nikon D3\", 0, 0,",
          "14154:       { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },",
          "14155:     { \"Nikon D40X\", 0, 0,",
          "14156:       { 8819,-2543,-911,-9025,16928,2151,-1329,1213,8449 } },",
          "14157:     { \"Nikon D40\", 0, 0,",
          "14158:       { 6992,-1668,-806,-8138,15748,2543,-874,850,7897 } },",
          "14159:     { \"Nikon D4S\", 0, 0,",
          "14160:       { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },",
          "14161:     { \"Nikon D4\", 0, 0,",
          "14162:       { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },",
          "14163:     { \"Nikon Df\", 0, 0,",
          "14164:       { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },",
          "14165:     { \"Nikon D5000\", 0, 0xf00,",
          "14166:       { 7309,-1403,-519,-8474,16008,2622,-2433,2826,8064 } },",
          "14167:     { \"Nikon D5100\", 0, 0x3de6,",
          "14168:       { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },",
          "14169:     { \"Nikon D5200\", 0, 0,",
          "14170:       { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },",
          "14171:     { \"Nikon D5300\", 0, 0,",
          "14172:       { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },",
          "14173:     { \"Nikon D5500\", 0, 0,",
          "14174:       { 8821,-2938,-785,-4178,12142,2287,-824,1651,6860 } },",
          "14175:     { \"Nikon D500\", 0, 0,",
          "14176:         { 8813,-3210,-1036,-4703,12868,2021,-1054,1940,6129 } },",
          "14177:     { \"Nikon D50\", 0, 0,",
          "14178:       { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },",
          "14179:     { \"Nikon D5\", 0, 0,",
          "14180:       { 9200,-3522,-992,-5755,13803,2117,-753,1486,6338 } },",
          "14181:     { \"Nikon D600\", 0, 0x3e07,",
          "14182:       { 8178,-2245,-609,-4857,12394,2776,-1207,2086,7298 } },",
          "14183:     { \"Nikon D610\",0, 0,",
          "14184:       { 10426,-4005,-444,-3565,11764,1403,-1206,2266,6549 } },",
          "14185:     { \"Nikon D60\", 0, 0,",
          "14186:       { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },",
          "14187:     { \"Nikon D7000\", 0, 0,",
          "14188:       { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },",
          "14189:     { \"Nikon D7100\", 0, 0,",
          "14190:       { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },",
          "14191:     { \"Nikon D7200\", 0, 0,",
          "14192:       { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },",
          "14193:     { \"Nikon D750\", -600, 0,",
          "14194:       { 9020,-2890,-715,-4535,12436,2348,-934,1919,7086 } },",
          "14195:     { \"Nikon D700\", 0, 0,",
          "14196:       { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },",
          "14197:     { \"Nikon D70\", 0, 0,",
          "14198:       { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },",
          "14199:     { \"Nikon D810A\", 0, 0,",
          "14200:       { 11973, -5685, -888, -1965, 10326, 1901, -115, 1123, 7169 } },",
          "14201:     { \"Nikon D810\", 0, 0,",
          "14202:       { 9369,-3195,-791,-4488,12430,2301,-893,1796,6872 } },",
          "14203:     { \"Nikon D800\", 0, 0,",
          "14204:       { 7866,-2108,-555,-4869,12483,2681,-1176,2069,7501 } },",
          "14205:     { \"Nikon D80\", 0, 0,",
          "14206:       { 8629,-2410,-883,-9055,16940,2171,-1490,1363,8520 } },",
          "14207:     { \"Nikon D90\", 0, 0xf00,",
          "14208:       { 7309,-1403,-519,-8474,16008,2622,-2434,2826,8064 } },",
          "14210:       { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },",
          "14212:       { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },",
          "14214:       { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },",
          "14216:       { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },",
          "14218:       { 13142,-4152,-1596,-4655,12374,2282,-1769,2696,6711 } },",
          "14219:     { \"Nikon E2500\", 0, 0,",
          "14220:       { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },",
          "14222:       { 9846,-2085,-1019,-3278,11109,2170,-774,2134,5745 } },",
          "14224:       { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },",
          "14225:     { \"Nikon E4500\", 0, 0,",
          "14226:       { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },",
          "14227:     { \"Nikon E5000\", 0, 0,",
          "14228:       { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },",
          "14229:     { \"Nikon E5400\", 0, 0,",
          "14230:       { 9349,-2987,-1001,-7919,15766,2266,-2098,2680,6839 } },",
          "14231:     { \"Nikon E5700\", 0, 0,",
          "14232:       { -5368,11478,2368,5537,-113,3148,-4969,10021,5782,778,9028,211 } },",
          "14233:     { \"Nikon E8400\", 0, 0,",
          "14234:       { 7842,-2320,-992,-8154,15718,2599,-1098,1342,7560 } },",
          "14235:     { \"Nikon E8700\", 0, 0,",
          "14236:       { 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },",
          "14237:     { \"Nikon E8800\", 0, 0,",
          "14238:       { 7971,-2314,-913,-8451,15762,2894,-1442,1520,7610 } },",
          "14239:     { \"Nikon COOLPIX A\", 0, 0,",
          "14240:       { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },",
          "14241:     { \"Nikon COOLPIX B700\", 0, 0,",
          "14242:       { 14387,-6014,-1299,-1357,9975,1616,467,1047,4744 } },",
          "14243:     { \"Nikon COOLPIX P330\", -200, 0,",
          "14244:       { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },",
          "14245:     { \"Nikon COOLPIX P340\", -200, 0,",
          "14246:       { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },",
          "14247:     { \"Nikon COOLPIX P6000\", 0, 0,",
          "14248:       { 9698,-3367,-914,-4706,12584,2368,-837,968,5801 } },",
          "14249:     { \"Nikon COOLPIX P7000\", 0, 0,",
          "14250:       { 11432,-3679,-1111,-3169,11239,2202,-791,1380,4455 } },",
          "14251:     { \"Nikon COOLPIX P7100\", 0, 0,",
          "14252:       { 11053,-4269,-1024,-1976,10182,2088,-526,1263,4469 } },",
          "14253:     { \"Nikon COOLPIX P7700\", -3200, 0,",
          "14254:       { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },",
          "14255:     { \"Nikon COOLPIX P7800\", -3200, 0,",
          "14256:       { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },",
          "14257:     { \"Nikon 1 V3\", -200, 0,",
          "14258:       { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },",
          "14259:     { \"Nikon 1 J4\", 0, 0,",
          "14260:       { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },",
          "14261:     { \"Nikon 1 J5\", 0, 0,",
          "14262:       { 7520,-2518,-645,-3844,12102,1945,-913,2249,6835} },",
          "14263:     { \"Nikon 1 S2\", -200, 0,",
          "14264:       { 6612,-1342,-618,-3338,11055,2623,-174,1792,5075 } },",
          "14265:     { \"Nikon 1 V2\", 0, 0,",
          "14266:       { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },",
          "14267:     { \"Nikon 1 J3\", 0, 0,",
          "14268:       { 8144,-2671,-473,-1740,9834,1601,-58,1971,4296 } },",
          "14269:     { \"Nikon 1 AW1\", 0, 0,",
          "14270:       { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },",
          "14272:       { 8994,-2667,-865,-4594,12324,2552,-699,1786,6260 } },",
          "14273:     { \"Olympus AIR-A01\", 0, 0xfe1,",
          "14274:       { 8992,-3093,-639,-2563,10721,2122,-437,1270,5473 } },",
          "14275:     { \"Olympus C5050\", 0, 0,",
          "14276:       { 10508,-3124,-1273,-6079,14294,1901,-1653,2306,6237 } },",
          "14277:     { \"Olympus C5060\", 0, 0,",
          "14278:       { 10445,-3362,-1307,-7662,15690,2058,-1135,1176,7602 } },",
          "14279:     { \"Olympus C7070\", 0, 0,",
          "14280:       { 10252,-3531,-1095,-7114,14850,2436,-1451,1723,6365 } },",
          "14281:     { \"Olympus C70\", 0, 0,",
          "14282:       { 10793,-3791,-1146,-7498,15177,2488,-1390,1577,7321 } },",
          "14283:     { \"Olympus C80\", 0, 0,",
          "14284:       { 8606,-2509,-1014,-8238,15714,2703,-942,979,7760 } },",
          "14285:     { \"Olympus E-10\", 0, 0xffc,",
          "14286:       { 12745,-4500,-1416,-6062,14542,1580,-1934,2256,6603 } },",
          "14287:     { \"Olympus E-1\", 0, 0,",
          "14288:       { 11846,-4767,-945,-7027,15878,1089,-2699,4122,8311 } },",
          "14289:     { \"Olympus E-20\", 0, 0xffc,",
          "14290:       { 13173,-4732,-1499,-5807,14036,1895,-2045,2452,7142 } },",
          "14291:     { \"Olympus E-300\", 0, 0,",
          "14292:       { 7828,-1761,-348,-5788,14071,1830,-2853,4518,6557 } },",
          "14293:     { \"Olympus E-330\", 0, 0,",
          "14294:       { 8961,-2473,-1084,-7979,15990,2067,-2319,3035,8249 } },",
          "14295:     { \"Olympus E-30\", 0, 0xfbc,",
          "14296:       { 8144,-1861,-1111,-7763,15894,1929,-1865,2542,7607 } },",
          "14297:     { \"Olympus E-3\", 0, 0xf99,",
          "14298:       { 9487,-2875,-1115,-7533,15606,2010,-1618,2100,7389 } },",
          "14299:     { \"Olympus E-400\", 0, 0,",
          "14300:       { 6169,-1483,-21,-7107,14761,2536,-2904,3580,8568 } },",
          "14301:     { \"Olympus E-410\", 0, 0xf6a,",
          "14302:       { 8856,-2582,-1026,-7761,15766,2082,-2009,2575,7469 } },",
          "14303:     { \"Olympus E-420\", 0, 0xfd7,",
          "14304:       { 8746,-2425,-1095,-7594,15612,2073,-1780,2309,7416 } },",
          "14305:     { \"Olympus E-450\", 0, 0xfd2,",
          "14306:       { 8745,-2425,-1095,-7594,15613,2073,-1780,2309,7416 } },",
          "14307:     { \"Olympus E-500\", 0, 0,",
          "14308:       { 8136,-1968,-299,-5481,13742,1871,-2556,4205,6630 } },",
          "14309:     { \"Olympus E-510\", 0, 0xf6a,",
          "14310:       { 8785,-2529,-1033,-7639,15624,2112,-1783,2300,7817 } },",
          "14311:     { \"Olympus E-520\", 0, 0xfd2,",
          "14312:       { 8344,-2322,-1020,-7596,15635,2048,-1748,2269,7287 } },",
          "14313:     { \"Olympus E-5\", 0, 0xeec,",
          "14314:       { 11200,-3783,-1325,-4576,12593,2206,-695,1742,7504 } },",
          "14315:     { \"Olympus E-600\", 0, 0xfaf,",
          "14316:       { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },",
          "14317:     { \"Olympus E-620\", 0, 0xfaf,",
          "14318:       { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },",
          "14319:     { \"Olympus E-P1\", 0, 0xffd,",
          "14320:       { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },",
          "14321:     { \"Olympus E-P2\", 0, 0xffd,",
          "14322:       { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },",
          "14323:     { \"Olympus E-P3\", 0, 0,",
          "14324:       { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },",
          "14325:     { \"Olympus E-P5\", 0, 0,",
          "14326:       { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },",
          "14327:     { \"Olympus E-PL1s\", 0, 0,",
          "14328:       { 11409,-3872,-1393,-4572,12757,2003,-709,1810,7415 } },",
          "14329:     { \"Olympus E-PL1\", 0, 0,",
          "14330:       { 11408,-4289,-1215,-4286,12385,2118,-387,1467,7787 } },",
          "14331:     { \"Olympus E-PL2\", 0, 0xcf3,",
          "14332:       { 15030,-5552,-1806,-3987,12387,1767,-592,1670,7023 } },",
          "14333:     { \"Olympus E-PL3\", 0, 0,",
          "14334:       { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },",
          "14335:     { \"Olympus E-PL5\", 0, 0xfcb,",
          "14336:       { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },",
          "14337:     { \"Olympus E-PL6\", 0, 0,",
          "14338:       { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },",
          "14339:     { \"Olympus E-PL7\", 0, 0,",
          "14340:       { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },",
          "14341:     { \"Olympus E-PL8\", 0, 0,",
          "14342:       { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },",
          "14343:     { \"Olympus E-PM1\", 0, 0,",
          "14344:       { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },",
          "14345:     { \"Olympus E-PM2\", 0, 0,",
          "14346:       { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },",
          "14348:       { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },",
          "14350:       { 8380, -2630, -639, -2887, 10725, 2496, -627, 1427, 5438 }},",
          "14351:     { \"Olympus E-M1\", 0, 0,",
          "14352:       { 7687,-1984,-606,-4327,11928,2721,-1381,2339,6452 } },",
          "14353:     { \"Olympus E-M5MarkII\", 0, 0,",
          "14354:       { 9422,-3258,-711,-2655,10898,2015,-512,1354,5512 } },",
          "14355:     { \"Olympus E-M5\", 0, 0xfe1,",
          "14356:       { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },",
          "14357:     { \"Olympus PEN-F\",0, 0,",
          "14358:       { 9476,-3182,-765,-2613,10958,1893,-449,1315,5268 } },",
          "14359:     { \"Olympus SP350\", 0, 0,",
          "14360:       { 12078,-4836,-1069,-6671,14306,2578,-786,939,7418 } },",
          "14361:     { \"Olympus SP3\", 0, 0,",
          "14362:       { 11766,-4445,-1067,-6901,14421,2707,-1029,1217,7572 } },",
          "14363:     { \"Olympus SP500UZ\", 0, 0xfff,",
          "14364:       { 9493,-3415,-666,-5211,12334,3260,-1548,2262,6482 } },",
          "14365:     { \"Olympus SP510UZ\", 0, 0xffe,",
          "14366:       { 10593,-3607,-1010,-5881,13127,3084,-1200,1805,6721 } },",
          "14367:     { \"Olympus SP550UZ\", 0, 0xffe,",
          "14368:       { 11597,-4006,-1049,-5432,12799,2957,-1029,1750,6516 } },",
          "14369:     { \"Olympus SP560UZ\", 0, 0xff9,",
          "14370:       { 10915,-3677,-982,-5587,12986,2911,-1168,1968,6223 } },",
          "14371:     { \"Olympus SP570UZ\", 0, 0,",
          "14372:       { 11522,-4044,-1146,-4736,12172,2904,-988,1829,6039 } },",
          "14373:     { \"Olympus SH-2\", 0, 0,",
          "14374:      { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },",
          "14376:      { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },",
          "14377:     { \"Olympus STYLUS1\",0, 0,",
          "14378:       { 11976,-5518,-545,-1419,10472,846,-475,1766,4524 } },",
          "14379:     { \"Olympus TG-4\", 0, 0,",
          "14380:      { 11426,-4159,-1126,-2066,10678,1593,-120,1327,4998 } },",
          "14381:     { \"Olympus XZ-10\", 0, 0,",
          "14382:       { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },",
          "14383:     { \"Olympus XZ-1\", 0, 0,",
          "14384:       { 10901,-4095,-1074,-1141,9208,2293,-62,1417,5158 } },",
          "14385:     { \"Olympus XZ-2\", 0, 0,",
          "14386:       { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },",
          "14387:     { \"OmniVision\", 16, 0x3ff,",
          "14389:     { \"Pentax *ist DL2\", 0, 0,",
          "14390:       { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },",
          "14391:     { \"Pentax *ist DL\", 0, 0,",
          "14392:       { 10829,-2838,-1115,-8339,15817,2696,-837,680,11939 } },",
          "14393:     { \"Pentax *ist DS2\", 0, 0,",
          "14394:       { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },",
          "14395:     { \"Pentax *ist DS\", 0, 0,",
          "14396:       { 10371,-2333,-1206,-8688,16231,2602,-1230,1116,11282 } },",
          "14397:     { \"Pentax *ist D\", 0, 0,",
          "14398:       { 9651,-2059,-1189,-8881,16512,2487,-1460,1345,10687 } },",
          "14399:     { \"Pentax K10D\", 0, 0,",
          "14400:       { 9566,-2863,-803,-7170,15172,2112,-818,803,9705 } },",
          "14401:     { \"Pentax K1\", 0, 0,",
          "14402:       { 11095,-3157,-1324,-8377,15834,2720,-1108,947,11688 } },",
          "14403:     { \"Pentax K20D\", 0, 0,",
          "14404:       { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },",
          "14405:     { \"Pentax K200D\", 0, 0,",
          "14406:       { 9186,-2678,-907,-8693,16517,2260,-1129,1094,8524 } },",
          "14407:     { \"Pentax K2000\", 0, 0,",
          "14408:       { 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },",
          "14409:     { \"Pentax K-m\", 0, 0,",
          "14410:       { 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },",
          "14411:     { \"Pentax K-x\", 0, 0,",
          "14412:       { 8843,-2837,-625,-5025,12644,2668,-411,1234,7410 } },",
          "14413:     { \"Pentax K-r\", 0, 0,",
          "14414:       { 9895,-3077,-850,-5304,13035,2521,-883,1768,6936 } },",
          "14415:     { \"Pentax K-1\", 0, 0,",
          "14416:       { 8566,-2746,-1201,-3612,12204,1550,-893,1680,6264 } },",
          "14417:     { \"Pentax K-30\", 0, 0,",
          "14418:       { 8710,-2632,-1167,-3995,12301,1881,-981,1719,6535 } },",
          "14419:     { \"Pentax K-3 II\", 0, 0,",
          "14420:       { 8626,-2607,-1155,-3995,12301,1881,-1039,1822,6925 } },",
          "14421:     { \"Pentax K-3\", 0, 0,",
          "14422:       { 7415,-2052,-721,-5186,12788,2682,-1446,2157,6773 } },",
          "14423:     { \"Pentax K-5 II\", 0, 0,",
          "14424:       { 8170,-2725,-639,-4440,12017,2744,-771,1465,6599 } },",
          "14425:     { \"Pentax K-5\", 0, 0,",
          "14426:       { 8713,-2833,-743,-4342,11900,2772,-722,1543,6247 } },",
          "14427:     { \"Pentax K-70\", 0, 0,",
          "14428:       {8766, -3149, -747, -3976, 11943, 2292, -517, 1259, 5552 }},",
          "14429:     { \"Pentax K-7\", 0, 0,",
          "14430:       { 9142,-2947,-678,-8648,16967,1663,-2224,2898,8615 } },",
          "14431:     { \"Pentax K-S1\", 0, 0,",
          "14432:       { 8512,-3211,-787,-4167,11966,2487,-638,1288,6054 } },",
          "14433:     { \"Pentax K-S2\", 0, 0,",
          "14434:       { 8662,-3280,-798,-3928,11771,2444,-586,1232,6054 } },",
          "14435:     { \"Pentax Q-S1\", 0, 0,",
          "14436:       { 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },",
          "14437:     { \"Pentax MX-1\", 0, 0,",
          "14438:       { 8804,-2523,-1238,-2423,11627,860,-682,1774,4753 } },",
          "14439:     { \"Pentax Q10\", 0, 0,",
          "14440:       { 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },",
          "14441:     { \"Pentax 645D\", 0, 0x3e00,",
          "14442:       { 10646,-3593,-1158,-3329,11699,1831,-667,2874,6287 } },",
          "14444:       { 9702, -3060, -1254, -3685, 12133, 1721, -1086, 2010, 6971}},",
          "14445:     { \"Panasonic DMC-CM10\", -15, 0,",
          "14446:       { 8770, -3194,-820,-2871,11281,1803,-513,1552,4434 } },",
          "14447:     { \"Panasonic DMC-CM1\", -15, 0,",
          "14448:       { 8770, -3194,-820,-2871,11281,1803,-513,1552,4434 } },",
          "14449:     { \"Panasonic DMC-FZ8\", 0, 0xf7f,",
          "14450:       { 8986,-2755,-802,-6341,13575,3077,-1476,2144,6379 } },",
          "14451:     { \"Panasonic DMC-FZ18\", 0, 0,",
          "14452:       { 9932,-3060,-935,-5809,13331,2753,-1267,2155,5575 } },",
          "14453:     { \"Panasonic DMC-FZ28\", -15, 0xf96,",
          "14454:       { 10109,-3488,-993,-5412,12812,2916,-1305,2140,5543 } },",
          "14455:     { \"Panasonic DMC-FZ300\", -15, 0xfff,",
          "14456:       { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },",
          "14457:     { \"Panasonic DMC-FZ330\", -15, 0xfff,  // same as FZ300",
          "14458:       { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },",
          "14459:     { \"Panasonic DMC-FZ30\", 0, 0xf94,",
          "14460:       { 10976,-4029,-1141,-7918,15491,2600,-1670,2071,8246 } },",
          "14461:     { \"Panasonic DMC-FZ3\", -15, 0,",
          "14462:       { 9938,-2780,-890,-4604,12393,2480,-1117,2304,4620 } },",
          "14463:     { \"Panasonic DMC-FZ4\", -15, 0,",
          "14464:       { 13639,-5535,-1371,-1698,9633,2430,316,1152,4108 } },",
          "14465:     { \"Panasonic DMC-FZ50\", 0, 0,",
          "14466:       { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },",
          "14467:     { \"Panasonic DMC-FZ7\", -15, 0,",
          "14468:       { 11532,-4324,-1066,-2375,10847,1749,-564,1699,4351 } },",
          "14469:     { \"Leica V-LUX1\", 0, 0,",
          "14470:       { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },",
          "14471:     { \"Panasonic DMC-L10\", -15, 0xf96,",
          "14472:       { 8025,-1942,-1050,-7920,15904,2100,-2456,3005,7039 } },",
          "14473:     { \"Panasonic DMC-L1\", 0, 0xf7f,",
          "14474:       { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },",
          "14475:     { \"Leica DIGILUX 3\", 0, 0xf7f,",
          "14476:       { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },",
          "14477:     { \"Panasonic DMC-LC1\", 0, 0,",
          "14478:       { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },",
          "14479:     { \"Leica DIGILUX 2\", 0, 0,",
          "14480:       { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },",
          "14481:     { \"Panasonic DMC-LX100\", -15, 0,",
          "14482:       { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },",
          "14483:     { \"Leica D-LUX (Typ 109)\", -15, 0,",
          "14484:       { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },",
          "14485:     { \"Panasonic DMC-LF1\", -15, 0,",
          "14486:       { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },",
          "14487:     { \"Leica C (Typ 112)\", -15, 0,",
          "14488:       { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },",
          "14497:     { \"Panasonic DMC-LX1\", 0, 0xf7f,",
          "14498:       { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },",
          "14499:     { \"Leica D-Lux (Typ 109)\", 0, 0xf7f,",
          "14500:       { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },",
          "14501:     { \"Leica D-LUX2\", 0, 0xf7f,",
          "14502:       { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },",
          "14503:     { \"Panasonic DMC-LX2\", 0, 0,",
          "14504:       { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },",
          "14505:     { \"Leica D-LUX3\", 0, 0,",
          "14506:       { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },",
          "14507:     { \"Panasonic DMC-LX3\", -15, 0,",
          "14508:       { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },",
          "14509:     { \"Leica D-LUX 4\", -15, 0,",
          "14510:       { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },",
          "14511:     { \"Panasonic DMC-LX5\", -15, 0,",
          "14512:       { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },",
          "14513:     { \"Leica D-LUX 5\", -15, 0,",
          "14514:       { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },",
          "14515:     { \"Panasonic DMC-LX7\", -15, 0,",
          "14516:       { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },",
          "14517:     { \"Leica D-LUX 6\", -15, 0,",
          "14518:       { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },",
          "14519:     { \"Panasonic DMC-FZ1000\", -15, 0,",
          "14520:       { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },",
          "14521:     { \"Leica V-LUX (Typ 114)\", 15, 0,",
          "14522:       { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },",
          "14523:     { \"Panasonic DMC-FZ100\", -15, 0xfff,",
          "14524:       { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },",
          "14525:     { \"Leica V-LUX 2\", -15, 0xfff,",
          "14526:       { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },",
          "14527:     { \"Panasonic DMC-FZ150\", -15, 0xfff,",
          "14528:       { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },",
          "14529:     { \"Leica V-LUX 3\", -15, 0xfff,",
          "14530:       { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },",
          "14532:       { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},",
          "14533:     { \"Panasonic DMC-FZ2500\", -15, 0,",
          "14534:       { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},",
          "14535:     { \"Panasonic DMC-FZH1\", -15, 0,",
          "14536:       { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},",
          "14537:     { \"Panasonic DMC-FZ200\", -15, 0xfff,",
          "14538:       { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },",
          "14539:     { \"Leica V-LUX 4\", -15, 0xfff,",
          "14540:       { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },",
          "14541:     { \"Panasonic DMC-FX150\", -15, 0xfff,",
          "14542:       { 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },",
          "14543:     { \"Panasonic DMC-G10\", 0, 0,",
          "14544:       { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },",
          "14545:     { \"Panasonic DMC-G1\", -15, 0xf94,",
          "14546:       { 8199,-2065,-1056,-8124,16156,2033,-2458,3022,7220 } },",
          "14547:     { \"Panasonic DMC-G2\", -15, 0xf3c,",
          "14548:       { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },",
          "14549:     { \"Panasonic DMC-G3\", -15, 0xfff,",
          "14550:       { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },",
          "14551:     { \"Panasonic DMC-G5\", -15, 0xfff,",
          "14552:       { 7798,-2562,-740,-3879,11584,2613,-1055,2248,5434 } },",
          "14553:     { \"Panasonic DMC-G6\", -15, 0xfff,",
          "14554:       { 8294,-2891,-651,-3869,11590,2595,-1183,2267,5352 } },",
          "14555:     { \"Panasonic DMC-G7\", -15, 0xfff,",
          "14556:       { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },",
          "14558:       { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },",
          "14559:     { \"Panasonic DMC-GF1\", -15, 0xf92,",
          "14560:       { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },",
          "14561:     { \"Panasonic DMC-GF2\", -15, 0xfff,",
          "14562:       { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },",
          "14563:     { \"Panasonic DMC-GF3\", -15, 0xfff,",
          "14564:       { 9051,-2468,-1204,-5212,13276,2121,-1197,2510,6890 } },",
          "14565:     { \"Panasonic DMC-GF5\", -15, 0xfff,",
          "14566:       { 8228,-2945,-660,-3938,11792,2430,-1094,2278,5793 } },",
          "14567:     { \"Panasonic DMC-GF6\", -15, 0,",
          "14568:       { 8130,-2801,-946,-3520,11289,2552,-1314,2511,5791 } },",
          "14569:     { \"Panasonic DMC-GF7\", -15, 0,",
          "14570:       { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },",
          "14571:     { \"Panasonic DMC-GF8\", -15, 0,",
          "14572:       { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },",
          "14573:     { \"Panasonic DMC-GH1\", -15, 0xf92,",
          "14574:       { 6299,-1466,-532,-6535,13852,2969,-2331,3112,5984 } },",
          "14575:     { \"Panasonic DMC-GH2\", -15, 0xf95,",
          "14576:       { 7780,-2410,-806,-3913,11724,2484,-1018,2390,5298 } },",
          "14577:     { \"Panasonic DMC-GH3\", -15, 0,",
          "14578:       { 6559,-1752,-491,-3672,11407,2586,-962,1875,5130 } },",
          "14579:     { \"Panasonic DMC-GH4\", -15, 0,",
          "14580:       { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },",
          "14581:     { \"Yuneec CGO4\", -15, 0,",
          "14582:       { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },",
          "14583:     { \"Panasonic DMC-GM1\", -15, 0,",
          "14584:       { 6770,-1895,-744,-5232,13145,2303,-1664,2691,5703 } },",
          "14585:     { \"Panasonic DMC-GM5\", -15, 0,",
          "14586:       { 8238,-3244,-679,-3921,11814,2384,-836,2022,5852 } },",
          "14587:     { \"Panasonic DMC-GX1\", -15, 0,",
          "14588:       { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },",
          "14590:       { 7771,-3020,-629,4029,11950,2345,-821,1977,6119 } },",
          "14592:       { 7771,-3020,-629,4029,11950,2345,-821,1977,6119 } },",
          "14594:       { 7771,-3020,-629,4029,11950,2345,-821,1977,6119 } },",
          "14595:     { \"Panasonic DMC-GX7\", -15,0,",
          "14596:       { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },",
          "14597:     { \"Panasonic DMC-GX8\", -15,0,",
          "14598:       { 7564,-2263,-606,-3148,11239,2177,-540,1435,4853 } },",
          "14600:       { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },",
          "14602:       { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },",
          "14604:       { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },",
          "14606:       { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },",
          "14608:       { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },",
          "14610:       { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },",
          "14612:       { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },",
          "14614:       { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },",
          "14616:       { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },",
          "14618:       { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },",
          "14620:       { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },",
          "14622:       { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },",
          "14623:     { \"Leica S (Typ 007)\", 0, 0,",
          "14624:      { 6063,-2234,-231,-5210,13787,1500,-1043,2866,6997 } },",
          "14626:      { 7712,-2059,-653,-3882,11494,2726,-710,1332,5958 } },",
          "14627:     { \"Leica Q (Typ 116)\", 0, 0,",
          "14628:      { 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830 } },",
          "14629:     { \"Leica M (Typ 262)\", 0, 0,",
          "14630:      { 6653,-1486,-611,-4221,13303,929,-881,2416,7226 } },",
          "14631:     { \"Leica SL (Typ 601)\", 0, 0,",
          "14632:       { 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830} },",
          "14634:       { 1313,1855,-109,-6715,15908,808,-327,1840,6020 } },",
          "14635:     { \"Phase One H 25\", 0, 0,",
          "14636:       { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },",
          "14637:     { \"Phase One IQ250\",0, 0,",
          "14638:       { 4396,-153,-249,-5267,12249,2657,-1397,2323,6014 } },",
          "14639:     { \"Phase One P 2\", 0, 0,",
          "14640:       { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },",
          "14641:     { \"Phase One P 30\", 0, 0,",
          "14642:       { 4516,-245,-37,-7020,14976,2173,-3206,4671,7087 } },",
          "14643:     { \"Phase One P 45\", 0, 0,",
          "14644:       { 5053,-24,-117,-5684,14076,1702,-2619,4492,5849 } },",
          "14645:     { \"Phase One P40\", 0, 0,",
          "14646:       { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },",
          "14647:     { \"Phase One P65\", 0, 0,",
          "14648:       { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },",
          "14650:       { 14603,-4122,-528,-1810,9794,2017,-297,2763,5936 } },",
          "14652:       { 21014,-7891,-2613,-3056,12201,856,-2203,5125,8042 } },",
          "14653:     { \"Ricoh GR II\", 0, 0,",
          "14654:       { 4630,-834,-423,-4977,12805,2417,-638,1467,6115 } },",
          "14655:     { \"Ricoh GR\", 0, 0,",
          "14656:        { 3708,-543,-160,-5381,12254,3556,-1471,1929,8234 } },",
          "14658:       { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },",
          "14659:     { \"Samsung EX1\", 0, 0x3e00,",
          "14660:       { 8898,-2498,-994,-3144,11328,2066,-760,1381,4576 } },",
          "14661:     { \"Samsung EX2F\", 0, 0x7ff,",
          "14662:       { 10648,-3897,-1055,-2022,10573,1668,-492,1611,4742 } },",
          "14663:     { \"Samsung NX mini\", 0, 0,",
          "14664:       { 5222,-1196,-550,-6540,14649,2009,-1666,2819,5657 } },",
          "14666:       { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },",
          "14667:     { \"Samsung NX3000\", 0, 0,",
          "14668:       { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },",
          "14670:       { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },",
          "14671:     { \"Samsung NX2000\", 0, 0,",
          "14672:       { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },",
          "14674:       { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },",
          "14675:     { \"Samsung NX1000\", 0, 0,",
          "14676:       { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },",
          "14677:     { \"Samsung NX1100\", 0, 0,",
          "14678:       { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },",
          "14679:     { \"Samsung NX11\", 0, 0,",
          "14680:       { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },",
          "14682:       { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },",
          "14683:     { \"Samsung NX500\", 0, 0,",
          "14684:       { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },",
          "14685:     { \"Samsung NX5\", 0, 0,",
          "14686:       { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },",
          "14687:     { \"Samsung NX1\", 0, 0,",
          "14688:       { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },",
          "14689:     { \"Samsung WB2000\", 0, 0xfff,",
          "14690:       { 12093,-3557,-1155,-1000,9534,1733,-22,1787,4576 } },",
          "14691:     { \"Samsung GX-1\", 0, 0,",
          "14692:       { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },",
          "14694:       { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },",
          "14696:       { 11885,-3968,-1473,-4214,12299,1916,-835,1655,5549 } },",
          "14698:     { \"Sigma dp0 Quattro\", 2047, 0,",
          "14699:       { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },",
          "14700:     { \"Sigma dp1 Quattro\", 2047, 0,",
          "14701:       { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },",
          "14702:     { \"Sigma dp2 Quattro\", 2047, 0,",
          "14703:       { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },",
          "14704:     { \"Sigma dp3 Quattro\", 2047, 0,",
          "14705:       { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },",
          "14706:     { \"Sigma sd Quattro\", 2047, 0,",
          "14709:       { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },",
          "14711:       { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },",
          "14713:       { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },",
          "14715:       { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },",
          "14718:       { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },",
          "14720:       { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },",
          "14722:       { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },",
          "14724:       { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },",
          "14728:       { 13100,-3638,-847,6855,2369,580,2723,3218,3251 } },",
          "14730:       { 16442,-2956,-2422,-2877,12128,750,-1136,6066,4559 } },",
          "14731:     { \"Sony DSC-F828\", 0, 0,",
          "14732:       { 7924,-1910,-777,-8226,15459,2998,-1517,2199,6818,-7242,11401,3481 } },",
          "14733:     { \"Sony DSC-R1\", 0, 0,",
          "14734:       { 8512,-2641,-694,-8042,15670,2526,-1821,2117,7414 } },",
          "14735:     { \"Sony DSC-V3\", 0, 0,",
          "14736:       { 7511,-2571,-692,-7894,15088,3060,-948,1111,8128 } },",
          "14738:       {6596, -2079, -562, -4782, 13016, 1933, -970, 1581, 5181 }},",
          "14740:       { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },",
          "14741:     { \"Sony DSC-RX100\", 0, 0,",
          "14742:       { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },",
          "14744:       { 6679,-1825,-745,-5047,13256,1953,-1580,2422,5183 } },",
          "14745:     { \"Sony DSC-RX1RM2\", 0, 0,",
          "14746:       { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },",
          "14747:     { \"Sony DSC-RX1R\", 0, 0,",
          "14748:       { 8195,-2800,-422,-4261,12273,1709,-1505,2400,5624 } },",
          "14749:     { \"Sony DSC-RX1\", 0, 0,",
          "14750:       { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },",
          "14751:     { \"Sony DSLR-A100\", 0, 0xfeb,",
          "14752:       { 9437,-2811,-774,-8405,16215,2290,-710,596,7181 } },",
          "14753:     { \"Sony DSLR-A290\", 0, 0,",
          "14754:       { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },",
          "14755:     { \"Sony DSLR-A2\", 0, 0,",
          "14756:       { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },",
          "14757:     { \"Sony DSLR-A300\", 0, 0,",
          "14758:       { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },",
          "14759:     { \"Sony DSLR-A330\", 0, 0,",
          "14760:       { 9847,-3091,-929,-8485,16346,2225,-714,595,7103 } },",
          "14761:     { \"Sony DSLR-A350\", 0, 0xffc,",
          "14762:       { 6038,-1484,-578,-9146,16746,2513,-875,746,7217 } },",
          "14763:     { \"Sony DSLR-A380\", 0, 0,",
          "14764:       { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },",
          "14765:     { \"Sony DSLR-A390\", 0, 0,",
          "14766:       { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },",
          "14767:     { \"Sony DSLR-A450\", 0, 0xfeb,",
          "14768:       { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },",
          "14769:     { \"Sony DSLR-A580\", 0, 0xfeb,",
          "14770:       { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },",
          "14771:     { \"Sony DSLR-A500\", 0, 0xfeb,",
          "14772:       { 6046,-1127,-278,-5574,13076,2786,-691,1419,7625 } },",
          "14773:     { \"Sony DSLR-A5\", 0, 0xfeb,",
          "14774:       { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },",
          "14775:     { \"Sony DSLR-A700\", 0, 0,",
          "14776:       { 5775,-805,-359,-8574,16295,2391,-1943,2341,7249 } },",
          "14777:     { \"Sony DSLR-A850\", 0, 0,",
          "14778:       { 5413,-1162,-365,-5665,13098,2866,-608,1179,8440 } },",
          "14779:     { \"Sony DSLR-A900\", 0, 0,",
          "14780:       { 5209,-1072,-397,-8845,16120,2919,-1618,1803,8654 } },",
          "14781:     { \"Sony ILCA-68\", 0, 0,",
          "14782:       { 6435,-1903,-536,-4722,12449,2550,-663,1363,6517 } },",
          "14783:     { \"Sony ILCA-77M2\", 0, 0,",
          "14784:       { 5991,-1732,-443,-4100,11989,2381,-704,1467,5992 } },",
          "14786:       { 6660, -1918, -471, -4613, 12398, 2485, -649, 1433, 6447}},",
          "14787:     { \"Sony ILCE-7M2\", 0, 0,",
          "14788:       { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },",
          "14789:     { \"Sony ILCE-7SM2\", 0, 0,",
          "14790:       { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },",
          "14791:     { \"Sony ILCE-7S\", 0, 0,",
          "14792:       { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },",
          "14793:     { \"Sony ILCE-7RM2\", 0, 0,",
          "14794:       { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },",
          "14795:     { \"Sony ILCE-7R\", 0, 0,",
          "14796:       { 4913,-541,-202,-6130,13513,2906,-1564,2151,7183 } },",
          "14797:     { \"Sony ILCE-7\", 0, 0,",
          "14798:       { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },",
          "14799:     { \"Sony ILCE-6300\", 0, 0,",
          "14800:       { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },",
          "14802:       { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },",
          "14804:       { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },",
          "14805:     { \"Sony NEX-5N\", 0, 0,",
          "14806:       { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },",
          "14807:     { \"Sony NEX-5R\", 0, 0,",
          "14808:       { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },",
          "14809:     { \"Sony NEX-5T\", 0, 0,",
          "14810:       { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },",
          "14811:     { \"Sony NEX-3N\", 0, 0,",
          "14812:       { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },",
          "14814:       { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },",
          "14816:       { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },",
          "14817:     { \"Sony NEX-6\", 0, 0,",
          "14818:       { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },",
          "14819:     { \"Sony NEX-7\", 0, 0,",
          "14820:       { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },",
          "14822:       { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },",
          "14823:     { \"Sony SLT-A33\", 0, 0,",
          "14824:       { 6069,-1221,-366,-5221,12779,2734,-1024,2066,6834 } },",
          "14825:     { \"Sony SLT-A35\", 0, 0,",
          "14826:       { 5986,-1618,-415,-4557,11820,3120,-681,1404,6971 } },",
          "14827:     { \"Sony SLT-A37\", 0, 0,",
          "14828:       { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },",
          "14829:     { \"Sony SLT-A55\", 0, 0,",
          "14830:       { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },",
          "14831:     { \"Sony SLT-A57\", 0, 0,",
          "14832:       { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },",
          "14833:     { \"Sony SLT-A58\", 0, 0,",
          "14834:       { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },",
          "14835:     { \"Sony SLT-A65\", 0, 0,",
          "14836:       { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },",
          "14837:     { \"Sony SLT-A77\", 0, 0,",
          "14838:       { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },",
          "14839:     { \"Sony SLT-A99\", 0, 0,",
          "14840:       { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },",
          "14846:   if(colors>4 || colors < 1) return;",
          "14848:   int bl4=(cblack[0]+cblack[1]+cblack[2]+cblack[3])/4,bl64=0;",
          "14849:   if(cblack[4]*cblack[5]>0)",
          "14851:    for (unsigned c = 0; c < 4096 && c < cblack[4]*cblack[5]; c++)",
          "14852:     bl64+=cblack[c+6];",
          "14853:    bl64 /= cblack[4]*cblack[5];",
          "14855:   int rblack  = black+bl4+bl64;",
          "14857:   sprintf (name, \"%s %s\", t_make, t_model);",
          "14858:   for (i=0; i < sizeof table / sizeof *table; i++)",
          "14859:     if (!strncasecmp(name, table[i].prefix, strlen(table[i].prefix))) {",
          "14860:       if(!dng_version)",
          "14861:  {",
          "14862:    if (table[i].t_black>0)",
          "14863:      {",
          "14864:        black   = (ushort) table[i].t_black;",
          "14865:        memset(cblack,0,sizeof(cblack));",
          "14866:      }",
          "14867:    else if(table[i].t_black <0 && rblack == 0 )",
          "14868:      {",
          "14869:        black   = (ushort) (-table[i].t_black);",
          "14870:        memset(cblack,0,sizeof(cblack));",
          "14871:      }",
          "14872:    if (table[i].t_maximum)",
          "14873:        maximum = (ushort) table[i].t_maximum;",
          "14874:  }",
          "14875:       if (table[i].trans[0]) {",
          "14876:  for (raw_color = j=0; j < 12; j++)",
          "14878:   if(internal_only)",
          "14879:    imgdata.color.cam_xyz[0][j] = table[i].trans[j] / 10000.0;",
          "14880:   else",
          "14881:                   imgdata.color.cam_xyz[0][j] =",
          "14883:                     ((double*)cam_xyz)[j] = table[i].trans[j] / 10000.0;",
          "14885:  if(!internal_only)",
          "14887:           cam_xyz_coeff (rgb_cam, cam_xyz);",
          "14893: void CLASS simple_coeff (int index)",
          "14895:   static const float table[][12] = {",
          "14897:   { 1.4032,-0.2231,-0.1016,-0.5263,1.4816,0.017,-0.0112,0.0183,0.9113 },",
          "14899:   { 2.25,0.75,-1.75,-0.25,-0.25,0.75,0.75,-0.25,-0.25,-1.75,0.75,2.25 },",
          "14901:   { 1.893,-0.418,-0.476,-0.495,1.773,-0.278,-1.017,-0.655,2.672 },",
          "14903:   { -1.936280,  1.800443, -1.448486,  2.584324,",
          "14904:      1.405365, -0.524955, -0.289090,  0.408680,",
          "14905:     -1.204965,  1.082304,  2.941367, -1.818705 }",
          "14906:   };",
          "14909:   for (raw_color = i=0; i < 3; i++)",
          "14910:     FORCC rgb_cam[i][c] = table[index][i*colors+c];",
          "14913: short CLASS guess_byte_order (int words)",
          "14916:   int t=2, msb;",
          "14917:   double diff, sum[2] = {0,0};",
          "14919:   fread (test[0], 2, 2, ifp);",
          "14920:   for (words-=2; words--; ) {",
          "14921:     fread (test[t], 2, 1, ifp);",
          "14922:     for (msb=0; msb < 2; msb++) {",
          "14923:       diff = (test[t^2][msb] << 8 | test[t^2][!msb])",
          "14924:     - (test[t  ][msb] << 8 | test[t  ][!msb]);",
          "14925:       sum[msb] += diff*diff;",
          "14927:     t = (t+1) & 3;",
          "14932: float CLASS find_green (int bps, int bite, int off0, int off1)",
          "14934:   UINT64 bitbuf=0;",
          "14937:   double sum[]={0,0};",
          "14939:   FORC(2) {",
          "14940:     fseek (ifp, c ? off1:off0, SEEK_SET);",
          "14941:     for (vbits=col=0; col < width; col++) {",
          "14942:       for (vbits -= bps; vbits < 0; vbits += bite) {",
          "14943:  bitbuf <<= bite;",
          "14944:  for (i=0; i < bite; i+=8)",
          "14945:    bitbuf |= (unsigned) (fgetc(ifp) << i);",
          "14947:       img[c][col] = bitbuf << (64-bps-vbits) >> (64-bps);",
          "14950:   FORC(width-1) {",
          "14951:     sum[ c & 1] += ABS(img[0][c]-img[1][c+1]);",
          "14952:     sum[~c & 1] += ABS(img[1][c]-img[0][c+1]);",
          "14954:   return 100 * log(sum[0]/sum[1]);",
          "14960:   if(len<1) return; // not needed, b/c sizeof of make/model is 64",
          "14961:   string[len-1]=0;",
          "14962:   if(len<3) return; // also not needed",
          "14963:   len = strnlen(string,len-1);",
          "14964:   for(int i=len-1; i>=0; i--)",
          "14965:   {",
          "14966:     if(isspace(string[i]))",
          "14967:       string[i]=0;",
          "",
          "[Added Lines]",
          "15142: void CLASS adobe_coeff(const char *t_make, const char *t_model",
          "15144:                        ,",
          "15145:                        int internal_only",
          "15147:                        )",
          "15149:   static const struct",
          "15150:   {",
          "15154:       {\"AgfaPhoto DC-833m\",",
          "15155:        0,",
          "15157:        {11438, -3762, -1115, -2409, 9914, 2497, -1227, 2295, 5300}},",
          "15158:       {\"Apple QuickTake\",",
          "15159:        0,",
          "15161:        {21392, -5653, -3353, 2406, 8010, -415, 7166, 1427, 2078}},",
          "15164:       {\"Canon EOS D2000\", 0, 0, {24542, -10860, -3401, -1490, 11370, -297, 2858, -605, 3225}},",
          "15165:       {\"Canon EOS D6000\", 0, 0, {20482, -7172, -3125, -1033, 10410, -285, 2542, 226, 3136}},",
          "15166:       {\"Canon EOS D30\", 0, 0, {9805, -2689, -1312, -5803, 13064, 3068, -2438, 3075, 8775}},",
          "15167:       {\"Canon EOS D60\", 0, 0xfa0, {6188, -1341, -890, -7168, 14489, 2937, -2640, 3228, 8483}},",
          "15168:       {\"Canon EOS 5DS\", 0, 0x3c96, {6250, -711, -808, -5153, 12794, 2636, -1249, 2198, 5610}},",
          "15169:       {\"Canon EOS 5D Mark IV\", 0, 0, {6446, -366, -864, -4436, 12204, 2513, -952, 2496, 6348}},",
          "15170:       {\"Canon EOS 5D Mark III\", 0, 0x3c80, {6722, -635, -963, -4287, 12460, 2028, -908, 2162, 5668}},",
          "15171:       {\"Canon EOS 5D Mark II\", 0, 0x3cf0, {4716, 603, -830, -7798, 15474, 2480, -1496, 1937, 6651}},",
          "15172:       {\"Canon EOS 5D\", 0, 0xe6c, {6347, -479, -972, -8297, 15954, 2480, -1968, 2131, 7649}},",
          "15173:       {\"Canon EOS 6D\", 0, 0x3c82, {8621, -2197, -787, -3150, 11358, 912, -1161, 2400, 4836}},",
          "15174:       {\"Canon EOS 7D Mark II\", 0, 0x3510, {7268, -1082, -969, -4186, 11839, 2663, -825, 2029, 5839}},",
          "15175:       {\"Canon EOS 7D\", 0, 0x3510, {6844, -996, -856, -3876, 11761, 2396, -593, 1772, 6198}},",
          "15176:       {\"Canon EOS 80D\", 0, 0, {7457, -671, -937, -4849, 12495, 2643, -1213, 2354, 5492}},",
          "15177:       {\"Canon EOS 10D\", 0, 0xfa0, {8197, -2000, -1118, -6714, 14335, 2592, -2536, 3178, 8266}},",
          "15178:       {\"Canon EOS 20Da\", 0, 0, {14155, -5065, -1382, -6550, 14633, 2039, -1623, 1824, 6561}},",
          "15179:       {\"Canon EOS 20D\", 0, 0xfff, {6599, -537, -891, -8071, 15783, 2424, -1983, 2234, 7462}},",
          "15180:       {\"Canon EOS 30D\", 0, 0, {6257, -303, -1000, -7880, 15621, 2396, -1714, 1904, 7046}},",
          "15181:       {\"Canon EOS 40D\", 0, 0x3f60, {6071, -747, -856, -7653, 15365, 2441, -2025, 2553, 7315}},",
          "15182:       {\"Canon EOS 50D\", 0, 0x3d93, {4920, 616, -593, -6493, 13964, 2784, -1774, 3178, 7005}},",
          "15183:       {\"Canon EOS 60D\", 0, 0x2ff7, {6719, -994, -925, -4408, 12426, 2211, -887, 2129, 6051}},",
          "15184:       {\"Canon EOS 70D\", 0, 0x3bc7, {7034, -804, -1014, -4420, 12564, 2058, -851, 1994, 5758}},",
          "15185:       {\"Canon EOS 100D\", 0, 0x350f, {6602, -841, -939, -4472, 12458, 2247, -975, 2039, 6148}},",
          "15186:       {\"Canon EOS 300D\", 0, 0xfa0, {8197, -2000, -1118, -6714, 14335, 2592, -2536, 3178, 8266}},",
          "15187:       {\"Canon EOS 350D\", 0, 0xfff, {6018, -617, -965, -8645, 15881, 2975, -1530, 1719, 7642}},",
          "15188:       {\"Canon EOS 400D\", 0, 0xe8e, {7054, -1501, -990, -8156, 15544, 2812, -1278, 1414, 7796}},",
          "15189:       {\"Canon EOS 450D\", 0, 0x390d, {5784, -262, -821, -7539, 15064, 2672, -1982, 2681, 7427}},",
          "15190:       {\"Canon EOS 500D\", 0, 0x3479, {4763, 712, -646, -6821, 14399, 2640, -1921, 3276, 6561}},",
          "15191:       {\"Canon EOS 550D\", 0, 0x3dd7, {6941, -1164, -857, -3825, 11597, 2534, -416, 1540, 6039}},",
          "15192:       {\"Canon EOS 600D\", 0, 0x3510, {6461, -907, -882, -4300, 12184, 2378, -819, 1944, 5931}},",
          "15193:       {\"Canon EOS 650D\", 0, 0x354d, {6602, -841, -939, -4472, 12458, 2247, -975, 2039, 6148}},",
          "15194:       {\"Canon EOS 750D\", 0, 0x3c00, {6362, -823, -847, -4426, 12109, 2616, -743, 1857, 5635}},",
          "15195:       {\"Canon EOS 760D\", 0, 0x3c00, {6362, -823, -847, -4426, 12109, 2616, -743, 1857, 5635}},",
          "15196:       {\"Canon EOS 700D\", 0, 0x3c00, {6602, -841, -939, -4472, 12458, 2247, -975, 2039, 6148}},",
          "15197:       {\"Canon EOS 1000D\", 0, 0xe43, {6771, -1139, -977, -7818, 15123, 2928, -1244, 1437, 7533}},",
          "15198:       {\"Canon EOS 1100D\", 0, 0x3510, {6444, -904, -893, -4563, 12308, 2535, -903, 2016, 6728}},",
          "15199:       {\"Canon EOS 1200D\", 0, 0x37c2, {6461, -907, -882, -4300, 12184, 2378, -819, 1944, 5931}},",
          "15200:       {\"Canon EOS 1300D\", 0, 0x37c2, {6939, -1016, -866, -4428, 12473, 2177, -1175, 2178, 6162}},",
          "15201:       {\"Canon EOS M3\", 0, 0, {6362, -823, -847, -4426, 12109, 2616, -743, 1857, 5635}},",
          "15202:       {\"Canon EOS M5\",",
          "15203:        0,",
          "15205:        {8532, -701, -1167, -4095, 11879, 2508, -797, 2424, 7010}},",
          "15206:       {\"Canon EOS M10\", 0, 0, {6400, -480, -888, -5294, 13416, 2047, -1296, 2203, 6137}},",
          "15207:       {\"Canon EOS M\", 0, 0, {6602, -841, -939, -4472, 12458, 2247, -975, 2039, 6148}},",
          "15208:       {\"Canon EOS-1Ds Mark III\", 0, 0x3bb0, {5859, -211, -930, -8255, 16017, 2353, -1732, 1887, 7448}},",
          "15209:       {\"Canon EOS-1Ds Mark II\", 0, 0xe80, {6517, -602, -867, -8180, 15926, 2378, -1618, 1771, 7633}},",
          "15210:       {\"Canon EOS-1D Mark IV\", 0, 0x3bb0, {6014, -220, -795, -4109, 12014, 2361, -561, 1824, 5787}},",
          "15211:       {\"Canon EOS-1D Mark III\", 0, 0x3bb0, {6291, -540, -976, -8350, 16145, 2311, -1714, 1858, 7326}},",
          "15212:       {\"Canon EOS-1D Mark II N\", 0, 0xe80, {6240, -466, -822, -8180, 15825, 2500, -1801, 1938, 8042}},",
          "15213:       {\"Canon EOS-1D Mark II\", 0, 0xe80, {6264, -582, -724, -8312, 15948, 2504, -1744, 1919, 8664}},",
          "15214:       {\"Canon EOS-1DS\", 0, 0xe20, {4374, 3631, -1743, -7520, 15212, 2472, -2892, 3632, 8161}},",
          "15215:       {\"Canon EOS-1D C\", 0, 0x3c4e, {6847, -614, -1014, -4669, 12737, 2139, -1197, 2488, 6846}},",
          "15216:       {\"Canon EOS-1D X Mark II\", 0, 0x3c4e, {7596, -978, 967, -4808, 12571, 2503, -1398, 2567, 5752}},",
          "15217:       {\"Canon EOS-1D X\", 0, 0x3c4e, {6847, -614, -1014, -4669, 12737, 2139, -1197, 2488, 6846}},",
          "15218:       {\"Canon EOS-1D\", 0, 0xe20, {6806, -179, -1020, -8097, 16415, 1687, -3267, 4236, 7690}},",
          "15219:       {\"Canon EOS C500\",",
          "15220:        853,",
          "15222:        {17851, -10604, 922, -7425, 16662, 763, -3660, 3636, 22278}},",
          "15224:       {\"Canon PowerShot A50\", 0, 0, {-5300, 9846, 1776, 3436, 684, 3939, -5540, 9879, 6200, -1404, 11175, 217}},",
          "15225:       {\"Canon PowerShot A5\", 0, 0, {-4801, 9475, 1952, 2926, 1611, 4094, -5259, 10164, 5947, -1554, 10883, 547}},",
          "15226:       {\"Canon PowerShot G10\", 0, 0, {11093, -3906, -1028, -5047, 12492, 2879, -1003, 1750, 5561}},",
          "15227:       {\"Canon PowerShot G11\", 0, 0, {12177, -4817, -1069, -1612, 9864, 2049, -98, 850, 4471}},",
          "15228:       {\"Canon PowerShot G12\", 0, 0, {13244, -5501, -1248, -1508, 9858, 1935, -270, 1083, 4366}},",
          "15229:       {\"Canon PowerShot G15\", 0, 0, {7474, -2301, -567, -4056, 11456, 2975, -222, 716, 4181}},",
          "15230:       {\"Canon PowerShot G16\", 0, 0, {14130, -8071, 127, 2199, 6528, 1551, 3402, -1721, 4960}},",
          "15231:       {\"Canon PowerShot G1 X Mark II\", 0, 0, {7378, -1255, -1043, -4088, 12251, 2048, -876, 1946, 5805}},",
          "15232:       {\"Canon PowerShot G1 X\", 0, 0, {7378, -1255, -1043, -4088, 12251, 2048, -876, 1946, 5805}},",
          "15233:       {\"Canon PowerShot G1\", 0, 0, {-4778, 9467, 2172, 4743, -1141, 4344, -5146, 9908, 6077, -1566, 11051, 557}},",
          "15234:       {\"Canon PowerShot G2\", 0, 0, {9087, -2693, -1049, -6715, 14382, 2537, -2291, 2819, 7790}},",
          "15235:       {\"Canon PowerShot G3 X\", 0, 0, {9701, -3857, -921, -3149, 11537, 1817, -786, 1817, 5147}},",
          "15236:       {\"Canon PowerShot G3\", 0, 0, {9212, -2781, -1073, -6573, 14189, 2605, -2300, 2844, 7664}},",
          "15237:       {\"Canon PowerShot G5 X\", 0, 0, {9602, -3823, -937, -2984, 11495, 1675, -407, 1415, 5049}},",
          "15238:       {\"Canon PowerShot G5\", 0, 0, {9757, -2872, -933, -5972, 13861, 2301, -1622, 2328, 7212}},",
          "15239:       {\"Canon PowerShot G6\", 0, 0, {9877, -3775, -871, -7613, 14807, 3072, -1448, 1305, 7485}},",
          "15240:       {\"Canon PowerShot G7 X Mark II\", 0, 0, {9602, -3823, -937, -2984, 11495, 1675, -407, 1415, 5049}},",
          "15241:       {\"Canon PowerShot G7 X\", 0, 0, {9602, -3823, -937, -2984, 11495, 1675, -407, 1415, 5049}},",
          "15242:       {\"Canon PowerShot G9 X\", 0, 0, {9602, -3823, -937, -2984, 11495, 1675, -407, 1415, 5049}},",
          "15243:       {\"Canon PowerShot G9\", 0, 0, {7368, -2141, -598, -5621, 13254, 2625, -1418, 1696, 5743}},",
          "15244:       {\"Canon PowerShot Pro1\", 0, 0, {10062, -3522, -999, -7643, 15117, 2730, -765, 817, 7323}},",
          "15245:       {\"Canon PowerShot Pro70\", 34, 0, {-4155, 9818, 1529, 3939, -25, 4522, -5521, 9870, 6610, -2238, 10873, 1342}},",
          "15246:       {\"Canon PowerShot Pro90\", 0, 0, {-4963, 9896, 2235, 4642, -987, 4294, -5162, 10011, 5859, -1770, 11230, 577}},",
          "15247:       {\"Canon PowerShot S30\", 0, 0, {10566, -3652, -1129, -6552, 14662, 2006, -2197, 2581, 7670}},",
          "15248:       {\"Canon PowerShot S40\", 0, 0, {8510, -2487, -940, -6869, 14231, 2900, -2318, 2829, 9013}},",
          "15249:       {\"Canon PowerShot S45\", 0, 0, {8163, -2333, -955, -6682, 14174, 2751, -2077, 2597, 8041}},",
          "15250:       {\"Canon PowerShot S50\", 0, 0, {8882, -2571, -863, -6348, 14234, 2288, -1516, 2172, 6569}},",
          "15251:       {\"Canon PowerShot S60\", 0, 0, {8795, -2482, -797, -7804, 15403, 2573, -1422, 1996, 7082}},",
          "15252:       {\"Canon PowerShot S70\", 0, 0, {9976, -3810, -832, -7115, 14463, 2906, -901, 989, 7889}},",
          "15253:       {\"Canon PowerShot S90\", 0, 0, {12374, -5016, -1049, -1677, 9902, 2078, -83, 852, 4683}},",
          "15254:       {\"Canon PowerShot S95\", 0, 0, {13440, -5896, -1279, -1236, 9598, 1931, -180, 1001, 4651}},",
          "15255:       {\"Canon PowerShot S120\", 0, 0, {6961, -1685, -695, -4625, 12945, 1836, -1114, 2152, 5518}},",
          "15256:       {\"Canon PowerShot S110\", 0, 0, {8039, -2643, -654, -3783, 11230, 2930, -206, 690, 4194}},",
          "15257:       {\"Canon PowerShot S100\", 0, 0, {7968, -2565, -636, -2873, 10697, 2513, 180, 667, 4211}},",
          "15258:       {\"Canon PowerShot SX1 IS\", 0, 0, {6578, -259, -502, -5974, 13030, 3309, -308, 1058, 4970}},",
          "15259:       {\"Canon PowerShot SX50 HS\", 0, 0, {12432, -4753, -1247, -2110, 10691, 1629, -412, 1623, 4926}},",
          "15260:       {\"Canon PowerShot SX60 HS\", 0, 0, {13161, -5451, -1344, -1989, 10654, 1531, -47, 1271, 4955}},",
          "15261:       {\"Canon PowerShot A3300\",",
          "15262:        0,",
          "15264:        {10826, -3654, -1023, -3215, 11310, 1906, 0, 999, 4960}},",
          "15265:       {\"Canon PowerShot A470\",",
          "15266:        0,",
          "15268:        {12513, -4407, -1242, -2680, 10276, 2405, -878, 2215, 4734}},",
          "15269:       {\"Canon PowerShot A610\",",
          "15270:        0,",
          "15272:        {15591, -6402, -1592, -5365, 13198, 2168, -1300, 1824, 5075}},",
          "15273:       {\"Canon PowerShot A620\",",
          "15274:        0,",
          "15276:        {15265, -6193, -1558, -4125, 12116, 2010, -888, 1639, 5220}},",
          "15277:       {\"Canon PowerShot A630\",",
          "15278:        0,",
          "15280:        {14201, -5308, -1757, -6087, 14472, 1617, -2191, 3105, 5348}},",
          "15281:       {\"Canon PowerShot A640\",",
          "15282:        0,",
          "15284:        {13124, -5329, -1390, -3602, 11658, 1944, -1612, 2863, 4885}},",
          "15285:       {\"Canon PowerShot A650\",",
          "15286:        0,",
          "15288:        {9427, -3036, -959, -2581, 10671, 1911, -1039, 1982, 4430}},",
          "15289:       {\"Canon PowerShot A720\",",
          "15290:        0,",
          "15292:        {14573, -5482, -1546, -1266, 9799, 1468, -1040, 1912, 3810}},",
          "15293:       {\"Canon PowerShot S3 IS\",",
          "15294:        0,",
          "15296:        {14062, -5199, -1446, -4712, 12470, 2243, -1286, 2028, 4836}},",
          "15297:       {\"Canon PowerShot SX110 IS\",",
          "15298:        0,",
          "15300:        {14134, -5576, -1527, -1991, 10719, 1273, -1158, 1929, 3581}},",
          "15301:       {\"Canon PowerShot SX220\",",
          "15302:        0,",
          "15304:        {13898, -5076, -1447, -1405, 10109, 1297, -244, 1860, 3687}},",
          "15305:       {\"Canon IXUS 160\",",
          "15306:        0,",
          "15308:        {11657, -3781, -1136, -3544, 11262, 2283, -160, 1219, 4700}},",
          "15309:       {\"Casio EX-S20\",",
          "15310:        0,",
          "15312:        {11634, -3924, -1128, -4968, 12954, 2015, -1588, 2648, 7206}},",
          "15313:       {\"Casio EX-Z750\",",
          "15314:        0,",
          "15316:        {10819, -3873, -1099, -4903, 13730, 1175, -1755, 3751, 4632}},",
          "15317:       {\"Casio EX-Z10\",",
          "15318:        128,",
          "15320:        {9790, -3338, -603, -2321, 10222, 2099, -344, 1273, 4799}},",
          "15321:       {\"CINE 650\", 0, 0, {3390, 480, -500, -800, 3610, 340, -550, 2336, 1192}},",
          "15322:       {\"CINE 660\", 0, 0, {3390, 480, -500, -800, 3610, 340, -550, 2336, 1192}},",
          "15323:       {\"CINE\", 0, 0, {20183, -4295, -423, -3940, 15330, 3985, -280, 4870, 9800}},",
          "15324:       {\"Contax N Digital\", 0, 0xf1e, {7777, 1285, -1053, -9280, 16543, 2916, -3677, 5679, 7060}},",
          "15325:       {\"DXO ONE\", 0, 0, {6596, -2079, -562, -4782, 13016, 1933, -970, 1581, 5181}},",
          "15326:       {\"Epson R-D1\", 0, 0, {6827, -1878, -732, -8429, 16012, 2564, -704, 592, 7145}},",
          "15327:       {\"Fujifilm E550\", 0, 0, {11044, -3888, -1120, -7248, 15168, 2208, -1531, 2277, 8069}},",
          "15328:       {\"Fujifilm E900\", 0, 0, {9183, -2526, -1078, -7461, 15071, 2574, -2022, 2440, 8639}},",
          "15329:       {\"Fujifilm F5\", 0, 0, {13690, -5358, -1474, -3369, 11600, 1998, -132, 1554, 4395}},",
          "15330:       {\"Fujifilm F6\", 0, 0, {13690, -5358, -1474, -3369, 11600, 1998, -132, 1554, 4395}},",
          "15331:       {\"Fujifilm F77\", 0, 0xfe9, {13690, -5358, -1474, -3369, 11600, 1998, -132, 1554, 4395}},",
          "15332:       {\"Fujifilm F7\", 0, 0, {10004, -3219, -1201, -7036, 15047, 2107, -1863, 2565, 7736}},",
          "15333:       {\"Fujifilm F8\", 0, 0, {13690, -5358, -1474, -3369, 11600, 1998, -132, 1554, 4395}},",
          "15334:       {\"Fujifilm S100FS\", 514, 0, {11521, -4355, -1065, -6524, 13767, 3058, -1466, 1984, 6045}},",
          "15335:       {\"Fujifilm S1\", 0, 0, {12297, -4882, -1202, -2106, 10691, 1623, -88, 1312, 4790}},",
          "15336:       {\"Fujifilm S20Pro\", 0, 0, {10004, -3219, -1201, -7036, 15047, 2107, -1863, 2565, 7736}},",
          "15337:       {\"Fujifilm S20\", 512, 0x3fff, {11401, -4498, -1312, -5088, 12751, 2613, -838, 1568, 5941}},",
          "15338:       {\"Fujifilm S2Pro\", 128, 0, {12492, -4690, -1402, -7033, 15423, 1647, -1507, 2111, 7697}},",
          "15339:       {\"Fujifilm S3Pro\", 0, 0, {11807, -4612, -1294, -8927, 16968, 1988, -2120, 2741, 8006}},",
          "15340:       {\"Fujifilm S5Pro\", 0, 0, {12300, -5110, -1304, -9117, 17143, 1998, -1947, 2448, 8100}},",
          "15341:       {\"Fujifilm S5000\", 0, 0, {8754, -2732, -1019, -7204, 15069, 2276, -1702, 2334, 6982}},",
          "15342:       {\"Fujifilm S5100\", 0, 0, {11940, -4431, -1255, -6766, 14428, 2542, -993, 1165, 7421}},",
          "15343:       {\"Fujifilm S5500\", 0, 0, {11940, -4431, -1255, -6766, 14428, 2542, -993, 1165, 7421}},",
          "15344:       {\"Fujifilm S5200\", 0, 0, {9636, -2804, -988, -7442, 15040, 2589, -1803, 2311, 8621}},",
          "15345:       {\"Fujifilm S5600\", 0, 0, {9636, -2804, -988, -7442, 15040, 2589, -1803, 2311, 8621}},",
          "15346:       {\"Fujifilm S6\", 0, 0, {12628, -4887, -1401, -6861, 14996, 1962, -2198, 2782, 7091}},",
          "15347:       {\"Fujifilm S7000\", 0, 0, {10190, -3506, -1312, -7153, 15051, 2238, -2003, 2399, 7505}},",
          "15348:       {\"Fujifilm S9000\", 0, 0, {10491, -3423, -1145, -7385, 15027, 2538, -1809, 2275, 8692}},",
          "15349:       {\"Fujifilm S9500\", 0, 0, {10491, -3423, -1145, -7385, 15027, 2538, -1809, 2275, 8692}},",
          "15350:       {\"Fujifilm S9100\", 0, 0, {12343, -4515, -1285, -7165, 14899, 2435, -1895, 2496, 8800}},",
          "15351:       {\"Fujifilm S9600\", 0, 0, {12343, -4515, -1285, -7165, 14899, 2435, -1895, 2496, 8800}},",
          "15352:       {\"Fujifilm SL1000\", 0, 0, {11705, -4262, -1107, -2282, 10791, 1709, -555, 1713, 4945}},",
          "15353:       {\"Fujifilm IS-1\", 0, 0, {21461, -10807, -1441, -2332, 10599, 1999, 289, 875, 7703}},",
          "15354:       {\"Fujifilm IS Pro\", 0, 0, {12300, -5110, -1304, -9117, 17143, 1998, -1947, 2448, 8100}},",
          "15355:       {\"Fujifilm HS10 HS11\", 0, 0xf68, {12440, -3954, -1183, -1123, 9674, 1708, -83, 1614, 4086}},",
          "15356:       {\"Fujifilm HS2\", 0, 0, {13690, -5358, -1474, -3369, 11600, 1998, -132, 1554, 4395}},",
          "15357:       {\"Fujifilm HS3\", 0, 0, {13690, -5358, -1474, -3369, 11600, 1998, -132, 1554, 4395}},",
          "15358:       {\"Fujifilm HS50EXR\", 0, 0, {12085, -4727, -953, -3257, 11489, 2002, -511, 2046, 4592}},",
          "15359:       {\"Fujifilm F900EXR\", 0, 0, {12085, -4727, -953, -3257, 11489, 2002, -511, 2046, 4592}},",
          "15360:       {\"Fujifilm X100S\", 0, 0, {10592, -4262, -1008, -3514, 11355, 2465, -870, 2025, 6386}},",
          "15361:       {\"Fujifilm X100T\", 0, 0, {10592, -4262, -1008, -3514, 11355, 2465, -870, 2025, 6386}},",
          "15362:       {\"Fujifilm X100\", 0, 0, {12161, -4457, -1069, -5034, 12874, 2400, -795, 1724, 6904}},",
          "15363:       {\"Fujifilm X10\", 0, 0, {13509, -6199, -1254, -4430, 12733, 1865, -331, 1441, 5022}},",
          "15364:       {\"Fujifilm X20\", 0, 0, {11768, -4971, -1133, -4904, 12927, 2183, -480, 1723, 4605}},",
          "15365:       {\"Fujifilm X30\", 0, 0, {12328, -5256, -1144, -4469, 12927, 1675, -87, 1291, 4351}},",
          "15366:       {\"Fujifilm X70\", 0, 0, {10450, -4329, -878, -3217, 11105, 2421, -752, 1758, 6519}},",
          "15367:       {\"Fujifilm X-Pro1\", 0, 0, {10413, -3996, -993, -3721, 11640, 2361, -733, 1540, 6011}},",
          "15368:       {\"Fujifilm X-Pro2\", 0, 0, {11434, -4948, -1210, -3746, 12042, 1903, -666, 1479, 5235}},",
          "15369:       {\"Fujifilm X-A1\", 0, 0, {11086, -4555, -839, -3512, 11310, 2517, -815, 1341, 5940}},",
          "15370:       {\"Fujifilm X-A2\", 0, 0, {10763, -4560, -917, -3346, 11311, 2322, -475, 1135, 5843}},",
          "15371:       {\"Fujifilm X-E1\", 0, 0, {10413, -3996, -993, -3721, 11640, 2361, -733, 1540, 6011}},",
          "15372:       {\"Fujifilm X-E2S\", 0, 0, {11562, -5118, -961, -3022, 11007, 2311, -525, 1569, 6097}},",
          "15373:       {\"Fujifilm X-E2\", 0, 0, {12066, -5927, -367, -1969, 9878, 1503, -721, 2034, 5453}},",
          "15374:       {\"Fujifilm XF1\", 0, 0, {13509, -6199, -1254, -4430, 12733, 1865, -331, 1441, 5022}},",
          "15375:       {\"Fujifilm X-M1\", 0, 0, {13193, -6685, -425, -2229, 10458, 1534, -878, 1763, 5217}},",
          "15376:       {\"Fujifilm X-S1\", 0, 0, {13509, -6199, -1254, -4430, 12733, 1865, -331, 1441, 5022}},",
          "15377:       {\"Fujifilm X-T10\", 0, 0, {10763, -4560, -917, -3346, 11311, 2322, -475, 1135, 5843}},",
          "15378:       {\"Fujifilm X-T1\", 0, 0, {8458, -2451, -855, -4597, 12447, 2407, -1475, 2482, 6526}},",
          "15379:       {\"Fujifilm X-T2\", 0, 0, {11434, -4948, -1210, -3746, 12042, 1903, -666, 1479, 5235}},",
          "15380:       {\"Fujifilm XQ1\", 0, 0, {9252, -2704, -1064, -5893, 14265, 1717, -1101, 2341, 4349}},",
          "15381:       {\"Fujifilm XQ2\", 0, 0, {9252, -2704, -1064, -5893, 14265, 1717, -1101, 2341, 4349}},",
          "15382:       {\"GITUP GIT2\", 3200, 0, {8489, -2583, -1036, -8051, 15583, 2643, -1307, 1407, 7354}},",
          "15383:       {\"Hasselblad Lunar\", 0, 0, {5491, -1192, -363, -4951, 12342, 2948, -911, 1722, 7192}},",
          "15384:       {\"Hasselblad Stellar\", -800, 0, {8651, -2754, -1057, -3464, 12207, 1373, -568, 1398, 4434}},",
          "15385:       {\"Hasselblad CFV\",",
          "15386:        0,",
          "15388:        {",
          "15389:            8519, -3260, -280, -5081, 13459, 1738, -1449, 2960, 7809,",
          "15390:        }},",
          "15391:       {\"Hasselblad H-16MP\",",
          "15392:        0,",
          "15394:        {17765, -5322, -1734, -6168, 13354, 2135, -264, 2524, 7440}},",
          "15395:       {\"Hasselblad H-22MP\",",
          "15396:        0,",
          "15398:        {17765, -5322, -1734, -6168, 13354, 2135, -264, 2524, 7440}},",
          "15399:       {\"Hasselblad H-31MP\",",
          "15400:        0,",
          "15402:        {14480, -5448, -1686, -3534, 13123, 2260, 384, 2952, 7232}},",
          "15403:       {\"Hasselblad H-39MP\",",
          "15404:        0,",
          "15406:        {3857, 452, -46, -6008, 14477, 1596, -2627, 4481, 5718}},",
          "15407:       {\"Hasselblad H3D-50\",",
          "15408:        0,",
          "15410:        {3857, 452, -46, -6008, 14477, 1596, -2627, 4481, 5718}},",
          "15411:       {\"Hasselblad H4D-40\",",
          "15412:        0,",
          "15414:        {6325, -860, -957, -6559, 15945, 266, 167, 770, 5936}},",
          "15415:       {\"Hasselblad H4D-50\",",
          "15416:        0,",
          "15418:        {15283, -6272, -465, -2030, 16031, 478, -2379, 390, 7965}},",
          "15419:       {\"Hasselblad H4D-60\",",
          "15420:        0,",
          "15422:        {9662, -684, -279, -4903, 12293, 2950, -344, 1669, 6024}},",
          "15423:       {\"Hasselblad H5D-50c\",",
          "15424:        0,",
          "15426:        {4932, -835, 141, -4878, 11868, 3437, -1138, 1961, 7067}},",
          "15427:       {\"Hasselblad H5D-50\",",
          "15428:        0,",
          "15430:        {5656, -659, -346, -3923, 12306, 1791, -1602, 3509, 5442}},",
          "15431:       {\"Hasselblad X1D\",",
          "15432:        0,",
          "15434:        {4932, -835, 141, -4878, 11868, 3437, -1138, 1961, 7067}},",
          "15435:       {\"HTC One A9\",",
          "15436:        64,",
          "15438:        {101, -20, -2, -11, 145, 41, -24, 1, 56}},",
          "15439:       {\"Imacon Ixpress\",",
          "15440:        0,",
          "15442:        {7025, -1415, -704, -5188, 13765, 1424, -1248, 2742, 6038}},",
          "15443:       {\"Kodak NC2000\", 0, 0, {13891, -6055, -803, -465, 9919, 642, 2121, 82, 1291}},",
          "15444:       {\"Kodak DCS315C\", -8, 0, {17523, -4827, -2510, 756, 8546, -137, 6113, 1649, 2250}},",
          "15445:       {\"Kodak DCS330C\", -8, 0, {20620, -7572, -2801, -103, 10073, -396, 3551, -233, 2220}},",
          "15446:       {\"Kodak DCS420\", 0, 0, {10868, -1852, -644, -1537, 11083, 484, 2343, 628, 2216}},",
          "15447:       {\"Kodak DCS460\", 0, 0, {10592, -2206, -967, -1944, 11685, 230, 2206, 670, 1273}},",
          "15448:       {\"Kodak EOSDCS1\", 0, 0, {10592, -2206, -967, -1944, 11685, 230, 2206, 670, 1273}},",
          "15449:       {\"Kodak EOSDCS3B\", 0, 0, {9898, -2700, -940, -2478, 12219, 206, 1985, 634, 1031}},",
          "15450:       {\"Kodak DCS520C\", -178, 0, {24542, -10860, -3401, -1490, 11370, -297, 2858, -605, 3225}},",
          "15451:       {\"Kodak DCS560C\", -177, 0, {20482, -7172, -3125, -1033, 10410, -285, 2542, 226, 3136}},",
          "15452:       {\"Kodak DCS620C\", -177, 0, {23617, -10175, -3149, -2054, 11749, -272, 2586, -489, 3453}},",
          "15453:       {\"Kodak DCS620X\", -176, 0, {13095, -6231, 154, 12221, -21, -2137, 895, 4602, 2258}},",
          "15454:       {\"Kodak DCS660C\", -173, 0, {18244, -6351, -2739, -791, 11193, -521, 3711, -129, 2802}},",
          "15455:       {\"Kodak DCS720X\", 0, 0, {11775, -5884, 950, 9556, 1846, -1286, -1019, 6221, 2728}},",
          "15456:       {\"Kodak DCS760C\", 0, 0, {16623, -6309, -1411, -4344, 13923, 323, 2285, 274, 2926}},",
          "15457:       {\"Kodak DCS Pro SLR\", 0, 0, {5494, 2393, -232, -6427, 13850, 2846, -1876, 3997, 5445}},",
          "15458:       {\"Kodak DCS Pro 14nx\", 0, 0, {5494, 2393, -232, -6427, 13850, 2846, -1876, 3997, 5445}},",
          "15459:       {\"Kodak DCS Pro 14\", 0, 0, {7791, 3128, -776, -8588, 16458, 2039, -2455, 4006, 6198}},",
          "15460:       {\"Kodak ProBack645\", 0, 0, {16414, -6060, -1470, -3555, 13037, 473, 2545, 122, 4948}},",
          "15461:       {\"Kodak ProBack\", 0, 0, {21179, -8316, -2918, -915, 11019, -165, 3477, -180, 4210}},",
          "15462:       {\"Kodak P712\", 0, 0, {9658, -3314, -823, -5163, 12695, 2768, -1342, 1843, 6044}},",
          "15463:       {\"Kodak P850\", 0, 0xf7c, {10511, -3836, -1102, -6946, 14587, 2558, -1481, 1792, 6246}},",
          "15464:       {\"Kodak P880\", 0, 0xfff, {12805, -4662, -1376, -7480, 15267, 2360, -1626, 2194, 7904}},",
          "15465:       {\"Kodak EasyShare Z980\", 0, 0, {11313, -3559, -1101, -3893, 11891, 2257, -1214, 2398, 4908}},",
          "15466:       {\"Kodak EasyShare Z981\", 0, 0, {12729, -4717, -1188, -1367, 9187, 2582, 274, 860, 4411}},",
          "15467:       {\"Kodak EasyShare Z990\", 0, 0xfed, {11749, -4048, -1309, -1867, 10572, 1489, -138, 1449, 4522}},",
          "15468:       {\"Kodak EASYSHARE Z1015\", 0, 0xef1, {11265, -4286, -992, -4694, 12343, 2647, -1090, 1523, 5447}},",
          "15469:       {\"Leaf CMost\", 0, 0, {3952, 2189, 449, -6701, 14585, 2275, -4536, 7349, 6536}},",
          "15470:       {\"Leaf Valeo 6\", 0, 0, {3952, 2189, 449, -6701, 14585, 2275, -4536, 7349, 6536}},",
          "15471:       {\"Leaf Aptus 54S\", 0, 0, {8236, 1746, -1314, -8251, 15953, 2428, -3673, 5786, 5771}},",
          "15472:       {\"Leaf Aptus 65\", 0, 0, {7914, 1414, -1190, -8777, 16582, 2280, -2811, 4605, 5562}},",
          "15473:       {\"Leaf Aptus 75\", 0, 0, {7914, 1414, -1190, -8777, 16582, 2280, -2811, 4605, 5562}},",
          "15474:       {\"Leaf Credo 40\", 0, 0, {8035, 435, -962, -6001, 13872, 2320, -1159, 3065, 5434}},",
          "15475:       {\"Leaf Credo 50\", 0, 0, {3984, 0, 0, 0, 10000, 0, 0, 0, 7666}},",
          "15476:       {\"Leaf Credo 60\", 0, 0, {8035, 435, -962, -6001, 13872, 2320, -1159, 3065, 5434}},",
          "15477:       {\"Leaf Credo 80\", 0, 0, {6294, 686, -712, -5435, 13417, 2211, -1006, 2435, 5042}},",
          "15478:       {\"Leaf\", 0, 0, {8236, 1746, -1314, -8251, 15953, 2428, -3673, 5786, 5771}},",
          "15479:       {\"Mamiya ZD\", 0, 0, {7645, 2579, -1363, -8689, 16717, 2015, -3712, 5941, 5961}},",
          "15480:       {\"Micron 2010\",",
          "15481:        110,",
          "15483:        {16695, -3761, -2151, 155, 9682, 163, 3433, 951, 4904}},",
          "15484:       {\"Minolta DiMAGE 5\", 0, 0xf7d, {8983, -2942, -963, -6556, 14476, 2237, -2426, 2887, 8014}},",
          "15485:       {\"Minolta DiMAGE 7Hi\", 0, 0xf7d, {11368, -3894, -1242, -6521, 14358, 2339, -2475, 3056, 7285}},",
          "15486:       {\"Minolta DiMAGE 7\", 0, 0xf7d, {9144, -2777, -998, -6676, 14556, 2281, -2470, 3019, 7744}},",
          "15487:       {\"Minolta DiMAGE A1\", 0, 0xf8b, {9274, -2547, -1167, -8220, 16323, 1943, -2273, 2720, 8340}},",
          "15488:       {\"Minolta DiMAGE A200\", 0, 0, {8560, -2487, -986, -8112, 15535, 2771, -1209, 1324, 7743}},",
          "15489:       {\"Minolta DiMAGE A2\", 0, 0xf8f, {9097, -2726, -1053, -8073, 15506, 2762, -966, 981, 7763}},",
          "15490:       {\"Minolta DiMAGE Z2\",",
          "15491:        0,",
          "15493:        {11280, -3564, -1370, -4655, 12374, 2282, -1423, 2168, 5396}},",
          "15494:       {\"Minolta DYNAX 5\", 0, 0xffb, {10284, -3283, -1086, -7957, 15762, 2316, -829, 882, 6644}},",
          "15495:       {\"Minolta DYNAX 7\", 0, 0xffb, {10239, -3104, -1099, -8037, 15727, 2451, -927, 925, 6871}},",
          "15496:       {\"Motorola PIXL\",",
          "15497:        0,",
          "15499:        {8898, -989, -1033, -3292, 11619, 1674, -661, 3178, 5216}},",
          "15500:       {\"Nikon D100\", 0, 0, {5902, -933, -782, -8983, 16719, 2354, -1402, 1455, 6464}},",
          "15501:       {\"Nikon D1H\", 0, 0, {7577, -2166, -926, -7454, 15592, 1934, -2377, 2808, 8606}},",
          "15502:       {\"Nikon D1X\", 0, 0, {7702, -2245, -975, -9114, 17242, 1875, -2679, 3055, 8521}},",
          "15503:       {\"Nikon D1\",",
          "15504:        0,",
          "15506:        {16772, -4726, -2141, -7611, 15713, 1972, -2846, 3494, 9521}},",
          "15507:       {\"Nikon D200\", 0, 0xfbc, {8367, -2248, -763, -8758, 16447, 2422, -1527, 1550, 8053}},",
          "15508:       {\"Nikon D2H\", 0, 0, {5710, -901, -615, -8594, 16617, 2024, -2975, 4120, 6830}},",
          "15509:       {\"Nikon D2X\", 0, 0, {10231, -2769, -1255, -8301, 15900, 2552, -797, 680, 7148}},",
          "15510:       {\"Nikon D3000\", 0, 0, {8736, -2458, -935, -9075, 16894, 2251, -1354, 1242, 8263}},",
          "15511:       {\"Nikon D3100\", 0, 0, {7911, -2167, -813, -5327, 13150, 2408, -1288, 2483, 7968}},",
          "15512:       {\"Nikon D3200\", 0, 0xfb9, {7013, -1408, -635, -5268, 12902, 2640, -1470, 2801, 7379}},",
          "15513:       {\"Nikon D3300\", 0, 0, {6988, -1384, -714, -5631, 13410, 2447, -1485, 2204, 7318}},",
          "15514:       {\"Nikon D3400\", 0, 0, {6988, -1384, -714, -5631, 13410, 2447, -1485, 2204, 7318}},",
          "15515:       {\"Nikon D300\", 0, 0, {9030, -1992, -715, -8465, 16302, 2255, -2689, 3217, 8069}},",
          "15516:       {\"Nikon D3X\", 0, 0, {7171, -1986, -648, -8085, 15555, 2718, -2170, 2512, 7457}},",
          "15517:       {\"Nikon D3S\", 0, 0, {8828, -2406, -694, -4874, 12603, 2541, -660, 1509, 7587}},",
          "15518:       {\"Nikon D3\", 0, 0, {8139, -2171, -663, -8747, 16541, 2295, -1925, 2008, 8093}},",
          "15519:       {\"Nikon D40X\", 0, 0, {8819, -2543, -911, -9025, 16928, 2151, -1329, 1213, 8449}},",
          "15520:       {\"Nikon D40\", 0, 0, {6992, -1668, -806, -8138, 15748, 2543, -874, 850, 7897}},",
          "15521:       {\"Nikon D4S\", 0, 0, {8598, -2848, -857, -5618, 13606, 2195, -1002, 1773, 7137}},",
          "15522:       {\"Nikon D4\", 0, 0, {8598, -2848, -857, -5618, 13606, 2195, -1002, 1773, 7137}},",
          "15523:       {\"Nikon Df\", 0, 0, {8598, -2848, -857, -5618, 13606, 2195, -1002, 1773, 7137}},",
          "15524:       {\"Nikon D5000\", 0, 0xf00, {7309, -1403, -519, -8474, 16008, 2622, -2433, 2826, 8064}},",
          "15525:       {\"Nikon D5100\", 0, 0x3de6, {8198, -2239, -724, -4871, 12389, 2798, -1043, 2050, 7181}},",
          "15526:       {\"Nikon D5200\", 0, 0, {8322, -3112, -1047, -6367, 14342, 2179, -988, 1638, 6394}},",
          "15527:       {\"Nikon D5300\", 0, 0, {6988, -1384, -714, -5631, 13410, 2447, -1485, 2204, 7318}},",
          "15528:       {\"Nikon D5500\", 0, 0, {8821, -2938, -785, -4178, 12142, 2287, -824, 1651, 6860}},",
          "15529:       {\"Nikon D500\", 0, 0, {8813, -3210, -1036, -4703, 12868, 2021, -1054, 1940, 6129}},",
          "15530:       {\"Nikon D50\", 0, 0, {7732, -2422, -789, -8238, 15884, 2498, -859, 783, 7330}},",
          "15531:       {\"Nikon D5\", 0, 0, {9200, -3522, -992, -5755, 13803, 2117, -753, 1486, 6338}},",
          "15532:       {\"Nikon D600\", 0, 0x3e07, {8178, -2245, -609, -4857, 12394, 2776, -1207, 2086, 7298}},",
          "15533:       {\"Nikon D610\", 0, 0, {10426, -4005, -444, -3565, 11764, 1403, -1206, 2266, 6549}},",
          "15534:       {\"Nikon D60\", 0, 0, {8736, -2458, -935, -9075, 16894, 2251, -1354, 1242, 8263}},",
          "15535:       {\"Nikon D7000\", 0, 0, {8198, -2239, -724, -4871, 12389, 2798, -1043, 2050, 7181}},",
          "15536:       {\"Nikon D7100\", 0, 0, {8322, -3112, -1047, -6367, 14342, 2179, -988, 1638, 6394}},",
          "15537:       {\"Nikon D7200\", 0, 0, {8322, -3112, -1047, -6367, 14342, 2179, -988, 1638, 6394}},",
          "15538:       {\"Nikon D750\", -600, 0, {9020, -2890, -715, -4535, 12436, 2348, -934, 1919, 7086}},",
          "15539:       {\"Nikon D700\", 0, 0, {8139, -2171, -663, -8747, 16541, 2295, -1925, 2008, 8093}},",
          "15540:       {\"Nikon D70\", 0, 0, {7732, -2422, -789, -8238, 15884, 2498, -859, 783, 7330}},",
          "15541:       {\"Nikon D810A\", 0, 0, {11973, -5685, -888, -1965, 10326, 1901, -115, 1123, 7169}},",
          "15542:       {\"Nikon D810\", 0, 0, {9369, -3195, -791, -4488, 12430, 2301, -893, 1796, 6872}},",
          "15543:       {\"Nikon D800\", 0, 0, {7866, -2108, -555, -4869, 12483, 2681, -1176, 2069, 7501}},",
          "15544:       {\"Nikon D80\", 0, 0, {8629, -2410, -883, -9055, 16940, 2171, -1490, 1363, 8520}},",
          "15545:       {\"Nikon D90\", 0, 0xf00, {7309, -1403, -519, -8474, 16008, 2622, -2434, 2826, 8064}},",
          "15546:       {\"Nikon E700\",",
          "15547:        0,",
          "15549:        {-3746, 10611, 1665, 9621, -1734, 2114, -2389, 7082, 3064, 3406, 6116, -244}},",
          "15550:       {\"Nikon E800\",",
          "15551:        0,",
          "15553:        {-3746, 10611, 1665, 9621, -1734, 2114, -2389, 7082, 3064, 3406, 6116, -244}},",
          "15554:       {\"Nikon E950\",",
          "15555:        0,",
          "15557:        {-3746, 10611, 1665, 9621, -1734, 2114, -2389, 7082, 3064, 3406, 6116, -244}},",
          "15558:       {\"Nikon E995\",",
          "15559:        0,",
          "15561:        {-5547, 11762, 2189, 5814, -558, 3342, -4924, 9840, 5949, 688, 9083, 96}},",
          "15562:       {\"Nikon E2100\",",
          "15563:        0,",
          "15565:        {13142, -4152, -1596, -4655, 12374, 2282, -1769, 2696, 6711}},",
          "15566:       {\"Nikon E2500\", 0, 0, {-5547, 11762, 2189, 5814, -558, 3342, -4924, 9840, 5949, 688, 9083, 96}},",
          "15567:       {\"Nikon E3200\",",
          "15568:        0,",
          "15570:        {9846, -2085, -1019, -3278, 11109, 2170, -774, 2134, 5745}},",
          "15571:       {\"Nikon E4300\",",
          "15572:        0,",
          "15574:        {11280, -3564, -1370, -4655, 12374, 2282, -1423, 2168, 5396}},",
          "15575:       {\"Nikon E4500\", 0, 0, {-5547, 11762, 2189, 5814, -558, 3342, -4924, 9840, 5949, 688, 9083, 96}},",
          "15576:       {\"Nikon E5000\", 0, 0, {-5547, 11762, 2189, 5814, -558, 3342, -4924, 9840, 5949, 688, 9083, 96}},",
          "15577:       {\"Nikon E5400\", 0, 0, {9349, -2987, -1001, -7919, 15766, 2266, -2098, 2680, 6839}},",
          "15578:       {\"Nikon E5700\", 0, 0, {-5368, 11478, 2368, 5537, -113, 3148, -4969, 10021, 5782, 778, 9028, 211}},",
          "15579:       {\"Nikon E8400\", 0, 0, {7842, -2320, -992, -8154, 15718, 2599, -1098, 1342, 7560}},",
          "15580:       {\"Nikon E8700\", 0, 0, {8489, -2583, -1036, -8051, 15583, 2643, -1307, 1407, 7354}},",
          "15581:       {\"Nikon E8800\", 0, 0, {7971, -2314, -913, -8451, 15762, 2894, -1442, 1520, 7610}},",
          "15582:       {\"Nikon COOLPIX A\", 0, 0, {8198, -2239, -724, -4871, 12389, 2798, -1043, 2050, 7181}},",
          "15583:       {\"Nikon COOLPIX B700\", 0, 0, {14387, -6014, -1299, -1357, 9975, 1616, 467, 1047, 4744}},",
          "15584:       {\"Nikon COOLPIX P330\", -200, 0, {10321, -3920, -931, -2750, 11146, 1824, -442, 1545, 5539}},",
          "15585:       {\"Nikon COOLPIX P340\", -200, 0, {10321, -3920, -931, -2750, 11146, 1824, -442, 1545, 5539}},",
          "15586:       {\"Nikon COOLPIX P6000\", 0, 0, {9698, -3367, -914, -4706, 12584, 2368, -837, 968, 5801}},",
          "15587:       {\"Nikon COOLPIX P7000\", 0, 0, {11432, -3679, -1111, -3169, 11239, 2202, -791, 1380, 4455}},",
          "15588:       {\"Nikon COOLPIX P7100\", 0, 0, {11053, -4269, -1024, -1976, 10182, 2088, -526, 1263, 4469}},",
          "15589:       {\"Nikon COOLPIX P7700\", -3200, 0, {10321, -3920, -931, -2750, 11146, 1824, -442, 1545, 5539}},",
          "15590:       {\"Nikon COOLPIX P7800\", -3200, 0, {10321, -3920, -931, -2750, 11146, 1824, -442, 1545, 5539}},",
          "15591:       {\"Nikon 1 V3\", -200, 0, {5958, -1559, -571, -4021, 11453, 2939, -634, 1548, 5087}},",
          "15592:       {\"Nikon 1 J4\", 0, 0, {5958, -1559, -571, -4021, 11453, 2939, -634, 1548, 5087}},",
          "15593:       {\"Nikon 1 J5\", 0, 0, {7520, -2518, -645, -3844, 12102, 1945, -913, 2249, 6835}},",
          "15594:       {\"Nikon 1 S2\", -200, 0, {6612, -1342, -618, -3338, 11055, 2623, -174, 1792, 5075}},",
          "15595:       {\"Nikon 1 V2\", 0, 0, {6588, -1305, -693, -3277, 10987, 2634, -355, 2016, 5106}},",
          "15596:       {\"Nikon 1 J3\", 0, 0, {8144, -2671, -473, -1740, 9834, 1601, -58, 1971, 4296}},",
          "15597:       {\"Nikon 1 AW1\", 0, 0, {6588, -1305, -693, -3277, 10987, 2634, -355, 2016, 5106}},",
          "15598:       {\"Nikon 1 \",",
          "15599:        0,",
          "15601:        {8994, -2667, -865, -4594, 12324, 2552, -699, 1786, 6260}},",
          "15602:       {\"Olympus AIR-A01\", 0, 0xfe1, {8992, -3093, -639, -2563, 10721, 2122, -437, 1270, 5473}},",
          "15603:       {\"Olympus C5050\", 0, 0, {10508, -3124, -1273, -6079, 14294, 1901, -1653, 2306, 6237}},",
          "15604:       {\"Olympus C5060\", 0, 0, {10445, -3362, -1307, -7662, 15690, 2058, -1135, 1176, 7602}},",
          "15605:       {\"Olympus C7070\", 0, 0, {10252, -3531, -1095, -7114, 14850, 2436, -1451, 1723, 6365}},",
          "15606:       {\"Olympus C70\", 0, 0, {10793, -3791, -1146, -7498, 15177, 2488, -1390, 1577, 7321}},",
          "15607:       {\"Olympus C80\", 0, 0, {8606, -2509, -1014, -8238, 15714, 2703, -942, 979, 7760}},",
          "15608:       {\"Olympus E-10\", 0, 0xffc, {12745, -4500, -1416, -6062, 14542, 1580, -1934, 2256, 6603}},",
          "15609:       {\"Olympus E-1\", 0, 0, {11846, -4767, -945, -7027, 15878, 1089, -2699, 4122, 8311}},",
          "15610:       {\"Olympus E-20\", 0, 0xffc, {13173, -4732, -1499, -5807, 14036, 1895, -2045, 2452, 7142}},",
          "15611:       {\"Olympus E-300\", 0, 0, {7828, -1761, -348, -5788, 14071, 1830, -2853, 4518, 6557}},",
          "15612:       {\"Olympus E-330\", 0, 0, {8961, -2473, -1084, -7979, 15990, 2067, -2319, 3035, 8249}},",
          "15613:       {\"Olympus E-30\", 0, 0xfbc, {8144, -1861, -1111, -7763, 15894, 1929, -1865, 2542, 7607}},",
          "15614:       {\"Olympus E-3\", 0, 0xf99, {9487, -2875, -1115, -7533, 15606, 2010, -1618, 2100, 7389}},",
          "15615:       {\"Olympus E-400\", 0, 0, {6169, -1483, -21, -7107, 14761, 2536, -2904, 3580, 8568}},",
          "15616:       {\"Olympus E-410\", 0, 0xf6a, {8856, -2582, -1026, -7761, 15766, 2082, -2009, 2575, 7469}},",
          "15617:       {\"Olympus E-420\", 0, 0xfd7, {8746, -2425, -1095, -7594, 15612, 2073, -1780, 2309, 7416}},",
          "15618:       {\"Olympus E-450\", 0, 0xfd2, {8745, -2425, -1095, -7594, 15613, 2073, -1780, 2309, 7416}},",
          "15619:       {\"Olympus E-500\", 0, 0, {8136, -1968, -299, -5481, 13742, 1871, -2556, 4205, 6630}},",
          "15620:       {\"Olympus E-510\", 0, 0xf6a, {8785, -2529, -1033, -7639, 15624, 2112, -1783, 2300, 7817}},",
          "15621:       {\"Olympus E-520\", 0, 0xfd2, {8344, -2322, -1020, -7596, 15635, 2048, -1748, 2269, 7287}},",
          "15622:       {\"Olympus E-5\", 0, 0xeec, {11200, -3783, -1325, -4576, 12593, 2206, -695, 1742, 7504}},",
          "15623:       {\"Olympus E-600\", 0, 0xfaf, {8453, -2198, -1092, -7609, 15681, 2008, -1725, 2337, 7824}},",
          "15624:       {\"Olympus E-620\", 0, 0xfaf, {8453, -2198, -1092, -7609, 15681, 2008, -1725, 2337, 7824}},",
          "15625:       {\"Olympus E-P1\", 0, 0xffd, {8343, -2050, -1021, -7715, 15705, 2103, -1831, 2380, 8235}},",
          "15626:       {\"Olympus E-P2\", 0, 0xffd, {8343, -2050, -1021, -7715, 15705, 2103, -1831, 2380, 8235}},",
          "15627:       {\"Olympus E-P3\", 0, 0, {7575, -2159, -571, -3722, 11341, 2725, -1434, 2819, 6271}},",
          "15628:       {\"Olympus E-P5\", 0, 0, {8380, -2630, -639, -2887, 10725, 2496, -627, 1427, 5438}},",
          "15629:       {\"Olympus E-PL1s\", 0, 0, {11409, -3872, -1393, -4572, 12757, 2003, -709, 1810, 7415}},",
          "15630:       {\"Olympus E-PL1\", 0, 0, {11408, -4289, -1215, -4286, 12385, 2118, -387, 1467, 7787}},",
          "15631:       {\"Olympus E-PL2\", 0, 0xcf3, {15030, -5552, -1806, -3987, 12387, 1767, -592, 1670, 7023}},",
          "15632:       {\"Olympus E-PL3\", 0, 0, {7575, -2159, -571, -3722, 11341, 2725, -1434, 2819, 6271}},",
          "15633:       {\"Olympus E-PL5\", 0, 0xfcb, {8380, -2630, -639, -2887, 10725, 2496, -627, 1427, 5438}},",
          "15634:       {\"Olympus E-PL6\", 0, 0, {8380, -2630, -639, -2887, 10725, 2496, -627, 1427, 5438}},",
          "15635:       {\"Olympus E-PL7\", 0, 0, {9197, -3190, -659, -2606, 10830, 2039, -458, 1250, 5458}},",
          "15636:       {\"Olympus E-PL8\", 0, 0, {9197, -3190, -659, -2606, 10830, 2039, -458, 1250, 5458}},",
          "15637:       {\"Olympus E-PM1\", 0, 0, {7575, -2159, -571, -3722, 11341, 2725, -1434, 2819, 6271}},",
          "15638:       {\"Olympus E-PM2\", 0, 0, {8380, -2630, -639, -2887, 10725, 2496, -627, 1427, 5438}},",
          "15639:       {\"Olympus E-M10\",",
          "15640:        0,",
          "15642:        {8380, -2630, -639, -2887, 10725, 2496, -627, 1427, 5438}},",
          "15643:       {\"Olympus E-M1MarkII\",",
          "15644:        0,",
          "15646:        {8380, -2630, -639, -2887, 10725, 2496, -627, 1427, 5438}},",
          "15647:       {\"Olympus E-M1\", 0, 0, {7687, -1984, -606, -4327, 11928, 2721, -1381, 2339, 6452}},",
          "15648:       {\"Olympus E-M5MarkII\", 0, 0, {9422, -3258, -711, -2655, 10898, 2015, -512, 1354, 5512}},",
          "15649:       {\"Olympus E-M5\", 0, 0xfe1, {8380, -2630, -639, -2887, 10725, 2496, -627, 1427, 5438}},",
          "15650:       {\"Olympus PEN-F\", 0, 0, {9476, -3182, -765, -2613, 10958, 1893, -449, 1315, 5268}},",
          "15651:       {\"Olympus SP350\", 0, 0, {12078, -4836, -1069, -6671, 14306, 2578, -786, 939, 7418}},",
          "15652:       {\"Olympus SP3\", 0, 0, {11766, -4445, -1067, -6901, 14421, 2707, -1029, 1217, 7572}},",
          "15653:       {\"Olympus SP500UZ\", 0, 0xfff, {9493, -3415, -666, -5211, 12334, 3260, -1548, 2262, 6482}},",
          "15654:       {\"Olympus SP510UZ\", 0, 0xffe, {10593, -3607, -1010, -5881, 13127, 3084, -1200, 1805, 6721}},",
          "15655:       {\"Olympus SP550UZ\", 0, 0xffe, {11597, -4006, -1049, -5432, 12799, 2957, -1029, 1750, 6516}},",
          "15656:       {\"Olympus SP560UZ\", 0, 0xff9, {10915, -3677, -982, -5587, 12986, 2911, -1168, 1968, 6223}},",
          "15657:       {\"Olympus SP570UZ\", 0, 0, {11522, -4044, -1146, -4736, 12172, 2904, -988, 1829, 6039}},",
          "15658:       {\"Olympus SH-2\", 0, 0, {10156, -3425, -1077, -2611, 11177, 1624, -385, 1592, 5080}},",
          "15659:       {\"Olympus SH-3\",",
          "15660:        0,",
          "15662:        {10156, -3425, -1077, -2611, 11177, 1624, -385, 1592, 5080}},",
          "15663:       {\"Olympus STYLUS1\", 0, 0, {11976, -5518, -545, -1419, 10472, 846, -475, 1766, 4524}},",
          "15664:       {\"Olympus TG-4\", 0, 0, {11426, -4159, -1126, -2066, 10678, 1593, -120, 1327, 4998}},",
          "15665:       {\"Olympus XZ-10\", 0, 0, {9777, -3483, -925, -2886, 11297, 1800, -602, 1663, 5134}},",
          "15666:       {\"Olympus XZ-1\", 0, 0, {10901, -4095, -1074, -1141, 9208, 2293, -62, 1417, 5158}},",
          "15667:       {\"Olympus XZ-2\", 0, 0, {9777, -3483, -925, -2886, 11297, 1800, -602, 1663, 5134}},",
          "15669:       {\"Pentax *ist DL2\", 0, 0, {10504, -2438, -1189, -8603, 16207, 2531, -1022, 863, 12242}},",
          "15670:       {\"Pentax *ist DL\", 0, 0, {10829, -2838, -1115, -8339, 15817, 2696, -837, 680, 11939}},",
          "15671:       {\"Pentax *ist DS2\", 0, 0, {10504, -2438, -1189, -8603, 16207, 2531, -1022, 863, 12242}},",
          "15672:       {\"Pentax *ist DS\", 0, 0, {10371, -2333, -1206, -8688, 16231, 2602, -1230, 1116, 11282}},",
          "15673:       {\"Pentax *ist D\", 0, 0, {9651, -2059, -1189, -8881, 16512, 2487, -1460, 1345, 10687}},",
          "15674:       {\"Pentax K10D\", 0, 0, {9566, -2863, -803, -7170, 15172, 2112, -818, 803, 9705}},",
          "15675:       {\"Pentax K1\", 0, 0, {11095, -3157, -1324, -8377, 15834, 2720, -1108, 947, 11688}},",
          "15676:       {\"Pentax K20D\", 0, 0, {9427, -2714, -868, -7493, 16092, 1373, -2199, 3264, 7180}},",
          "15677:       {\"Pentax K200D\", 0, 0, {9186, -2678, -907, -8693, 16517, 2260, -1129, 1094, 8524}},",
          "15678:       {\"Pentax K2000\", 0, 0, {11057, -3604, -1155, -5152, 13046, 2329, -282, 375, 8104}},",
          "15679:       {\"Pentax K-m\", 0, 0, {11057, -3604, -1155, -5152, 13046, 2329, -282, 375, 8104}},",
          "15680:       {\"Pentax K-x\", 0, 0, {8843, -2837, -625, -5025, 12644, 2668, -411, 1234, 7410}},",
          "15681:       {\"Pentax K-r\", 0, 0, {9895, -3077, -850, -5304, 13035, 2521, -883, 1768, 6936}},",
          "15682:       {\"Pentax K-1\", 0, 0, {8566, -2746, -1201, -3612, 12204, 1550, -893, 1680, 6264}},",
          "15683:       {\"Pentax K-30\", 0, 0, {8710, -2632, -1167, -3995, 12301, 1881, -981, 1719, 6535}},",
          "15684:       {\"Pentax K-3 II\", 0, 0, {8626, -2607, -1155, -3995, 12301, 1881, -1039, 1822, 6925}},",
          "15685:       {\"Pentax K-3\", 0, 0, {7415, -2052, -721, -5186, 12788, 2682, -1446, 2157, 6773}},",
          "15686:       {\"Pentax K-5 II\", 0, 0, {8170, -2725, -639, -4440, 12017, 2744, -771, 1465, 6599}},",
          "15687:       {\"Pentax K-5\", 0, 0, {8713, -2833, -743, -4342, 11900, 2772, -722, 1543, 6247}},",
          "15688:       {\"Pentax K-70\", 0, 0, {8766, -3149, -747, -3976, 11943, 2292, -517, 1259, 5552}},",
          "15689:       {\"Pentax K-7\", 0, 0, {9142, -2947, -678, -8648, 16967, 1663, -2224, 2898, 8615}},",
          "15690:       {\"Pentax K-S1\", 0, 0, {8512, -3211, -787, -4167, 11966, 2487, -638, 1288, 6054}},",
          "15691:       {\"Pentax K-S2\", 0, 0, {8662, -3280, -798, -3928, 11771, 2444, -586, 1232, 6054}},",
          "15692:       {\"Pentax Q-S1\", 0, 0, {12995, -5593, -1107, -1879, 10139, 2027, -64, 1233, 4919}},",
          "15693:       {\"Pentax MX-1\", 0, 0, {8804, -2523, -1238, -2423, 11627, 860, -682, 1774, 4753}},",
          "15694:       {\"Pentax Q10\", 0, 0, {12995, -5593, -1107, -1879, 10139, 2027, -64, 1233, 4919}},",
          "15695:       {\"Pentax 645D\", 0, 0x3e00, {10646, -3593, -1158, -3329, 11699, 1831, -667, 2874, 6287}},",
          "15696:       {\"Pentax 645Z\",",
          "15697:        0,",
          "15699:        {9702, -3060, -1254, -3685, 12133, 1721, -1086, 2010, 6971}},",
          "15700:       {\"Panasonic DMC-CM10\", -15, 0, {8770, -3194, -820, -2871, 11281, 1803, -513, 1552, 4434}},",
          "15701:       {\"Panasonic DMC-CM1\", -15, 0, {8770, -3194, -820, -2871, 11281, 1803, -513, 1552, 4434}},",
          "15702:       {\"Panasonic DMC-FZ8\", 0, 0xf7f, {8986, -2755, -802, -6341, 13575, 3077, -1476, 2144, 6379}},",
          "15703:       {\"Panasonic DMC-FZ18\", 0, 0, {9932, -3060, -935, -5809, 13331, 2753, -1267, 2155, 5575}},",
          "15704:       {\"Panasonic DMC-FZ28\", -15, 0xf96, {10109, -3488, -993, -5412, 12812, 2916, -1305, 2140, 5543}},",
          "15705:       {\"Panasonic DMC-FZ300\", -15, 0xfff, {8378, -2798, -769, -3068, 11410, 1877, -538, 1792, 4623}},",
          "15706:       {\"Panasonic DMC-FZ330\",",
          "15707:        -15,",
          "15708:        0xfff, // same as FZ300",
          "15709:        {8378, -2798, -769, -3068, 11410, 1877, -538, 1792, 4623}},",
          "15710:       {\"Panasonic DMC-FZ30\", 0, 0xf94, {10976, -4029, -1141, -7918, 15491, 2600, -1670, 2071, 8246}},",
          "15711:       {\"Panasonic DMC-FZ3\", -15, 0, {9938, -2780, -890, -4604, 12393, 2480, -1117, 2304, 4620}},",
          "15712:       {\"Panasonic DMC-FZ4\", -15, 0, {13639, -5535, -1371, -1698, 9633, 2430, 316, 1152, 4108}},",
          "15713:       {\"Panasonic DMC-FZ50\", 0, 0, {7906, -2709, -594, -6231, 13351, 3220, -1922, 2631, 6537}},",
          "15714:       {\"Panasonic DMC-FZ7\", -15, 0, {11532, -4324, -1066, -2375, 10847, 1749, -564, 1699, 4351}},",
          "15715:       {\"Leica V-LUX1\", 0, 0, {7906, -2709, -594, -6231, 13351, 3220, -1922, 2631, 6537}},",
          "15716:       {\"Panasonic DMC-L10\", -15, 0xf96, {8025, -1942, -1050, -7920, 15904, 2100, -2456, 3005, 7039}},",
          "15717:       {\"Panasonic DMC-L1\", 0, 0xf7f, {8054, -1885, -1025, -8349, 16367, 2040, -2805, 3542, 7629}},",
          "15718:       {\"Leica DIGILUX 3\", 0, 0xf7f, {8054, -1885, -1025, -8349, 16367, 2040, -2805, 3542, 7629}},",
          "15719:       {\"Panasonic DMC-LC1\", 0, 0, {11340, -4069, -1275, -7555, 15266, 2448, -2960, 3426, 7685}},",
          "15720:       {\"Leica DIGILUX 2\", 0, 0, {11340, -4069, -1275, -7555, 15266, 2448, -2960, 3426, 7685}},",
          "15721:       {\"Panasonic DMC-LX100\", -15, 0, {8844, -3538, -768, -3709, 11762, 2200, -698, 1792, 5220}},",
          "15722:       {\"Leica D-LUX (Typ 109)\", -15, 0, {8844, -3538, -768, -3709, 11762, 2200, -698, 1792, 5220}},",
          "15723:       {\"Panasonic DMC-LF1\", -15, 0, {9379, -3267, -816, -3227, 11560, 1881, -926, 1928, 5340}},",
          "15724:       {\"Leica C (Typ 112)\", -15, 0, {9379, -3267, -816, -3227, 11560, 1881, -926, 1928, 5340}},",
          "15726:       {\"Panasonic DMC-LX9\",",
          "15727:        -15,",
          "15730:       {\"Panasonic DMC-LX10\",",
          "15731:        -15,",
          "15734:       {\"Panasonic DMC-LX15\",",
          "15735:        -15,",
          "15739:       {\"Panasonic DMC-LX1\", 0, 0xf7f, {10704, -4187, -1230, -8314, 15952, 2501, -920, 945, 8927}},",
          "15740:       {\"Leica D-Lux (Typ 109)\", 0, 0xf7f, {8844, -3538, -768, -3709, 11762, 2200, -698, 1792, 5220}},",
          "15741:       {\"Leica D-LUX2\", 0, 0xf7f, {10704, -4187, -1230, -8314, 15952, 2501, -920, 945, 8927}},",
          "15742:       {\"Panasonic DMC-LX2\", 0, 0, {8048, -2810, -623, -6450, 13519, 3272, -1700, 2146, 7049}},",
          "15743:       {\"Leica D-LUX3\", 0, 0, {8048, -2810, -623, -6450, 13519, 3272, -1700, 2146, 7049}},",
          "15744:       {\"Panasonic DMC-LX3\", -15, 0, {8128, -2668, -655, -6134, 13307, 3161, -1782, 2568, 6083}},",
          "15745:       {\"Leica D-LUX 4\", -15, 0, {8128, -2668, -655, -6134, 13307, 3161, -1782, 2568, 6083}},",
          "15746:       {\"Panasonic DMC-LX5\", -15, 0, {10909, -4295, -948, -1333, 9306, 2399, 22, 1738, 4582}},",
          "15747:       {\"Leica D-LUX 5\", -15, 0, {10909, -4295, -948, -1333, 9306, 2399, 22, 1738, 4582}},",
          "15748:       {\"Panasonic DMC-LX7\", -15, 0, {10148, -3743, -991, -2837, 11366, 1659, -701, 1893, 4899}},",
          "15749:       {\"Leica D-LUX 6\", -15, 0, {10148, -3743, -991, -2837, 11366, 1659, -701, 1893, 4899}},",
          "15750:       {\"Panasonic DMC-FZ1000\", -15, 0, {7830, -2696, -763, -3325, 11667, 1866, -641, 1712, 4824}},",
          "15751:       {\"Leica V-LUX (Typ 114)\", 15, 0, {7830, -2696, -763, -3325, 11667, 1866, -641, 1712, 4824}},",
          "15752:       {\"Panasonic DMC-FZ100\", -15, 0xfff, {16197, -6146, -1761, -2393, 10765, 1869, 366, 2238, 5248}},",
          "15753:       {\"Leica V-LUX 2\", -15, 0xfff, {16197, -6146, -1761, -2393, 10765, 1869, 366, 2238, 5248}},",
          "15754:       {\"Panasonic DMC-FZ150\", -15, 0xfff, {11904, -4541, -1189, -2355, 10899, 1662, -296, 1586, 4289}},",
          "15755:       {\"Leica V-LUX 3\", -15, 0xfff, {11904, -4541, -1189, -2355, 10899, 1662, -296, 1586, 4289}},",
          "15756:       {\"Panasonic DMC-FZ2000\",",
          "15757:        -15,",
          "15759:        {7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766}},",
          "15760:       {\"Panasonic DMC-FZ2500\", -15, 0, {7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766}},",
          "15761:       {\"Panasonic DMC-FZH1\", -15, 0, {7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766}},",
          "15762:       {\"Panasonic DMC-FZ200\", -15, 0xfff, {8112, -2563, -740, -3730, 11784, 2197, -941, 2075, 4933}},",
          "15763:       {\"Leica V-LUX 4\", -15, 0xfff, {8112, -2563, -740, -3730, 11784, 2197, -941, 2075, 4933}},",
          "15764:       {\"Panasonic DMC-FX150\", -15, 0xfff, {9082, -2907, -925, -6119, 13377, 3058, -1797, 2641, 5609}},",
          "15765:       {\"Panasonic DMC-G10\", 0, 0, {10113, -3400, -1114, -4765, 12683, 2317, -377, 1437, 6710}},",
          "15766:       {\"Panasonic DMC-G1\", -15, 0xf94, {8199, -2065, -1056, -8124, 16156, 2033, -2458, 3022, 7220}},",
          "15767:       {\"Panasonic DMC-G2\", -15, 0xf3c, {10113, -3400, -1114, -4765, 12683, 2317, -377, 1437, 6710}},",
          "15768:       {\"Panasonic DMC-G3\", -15, 0xfff, {6763, -1919, -863, -3868, 11515, 2684, -1216, 2387, 5879}},",
          "15769:       {\"Panasonic DMC-G5\", -15, 0xfff, {7798, -2562, -740, -3879, 11584, 2613, -1055, 2248, 5434}},",
          "15770:       {\"Panasonic DMC-G6\", -15, 0xfff, {8294, -2891, -651, -3869, 11590, 2595, -1183, 2267, 5352}},",
          "15771:       {\"Panasonic DMC-G7\", -15, 0xfff, {7610, -2780, -576, -4614, 12195, 2733, -1375, 2393, 6490}},",
          "15772:       {\"Panasonic DMC-G8\",",
          "15773:        -15,",
          "15775:        {7610, -2780, -576, -4614, 12195, 2733, -1375, 2393, 6490}},",
          "15776:       {\"Panasonic DMC-GF1\", -15, 0xf92, {7888, -1902, -1011, -8106, 16085, 2099, -2353, 2866, 7330}},",
          "15777:       {\"Panasonic DMC-GF2\", -15, 0xfff, {7888, -1902, -1011, -8106, 16085, 2099, -2353, 2866, 7330}},",
          "15778:       {\"Panasonic DMC-GF3\", -15, 0xfff, {9051, -2468, -1204, -5212, 13276, 2121, -1197, 2510, 6890}},",
          "15779:       {\"Panasonic DMC-GF5\", -15, 0xfff, {8228, -2945, -660, -3938, 11792, 2430, -1094, 2278, 5793}},",
          "15780:       {\"Panasonic DMC-GF6\", -15, 0, {8130, -2801, -946, -3520, 11289, 2552, -1314, 2511, 5791}},",
          "15781:       {\"Panasonic DMC-GF7\", -15, 0, {7610, -2780, -576, -4614, 12195, 2733, -1375, 2393, 6490}},",
          "15782:       {\"Panasonic DMC-GF8\", -15, 0, {7610, -2780, -576, -4614, 12195, 2733, -1375, 2393, 6490}},",
          "15783:       {\"Panasonic DMC-GH1\", -15, 0xf92, {6299, -1466, -532, -6535, 13852, 2969, -2331, 3112, 5984}},",
          "15784:       {\"Panasonic DMC-GH2\", -15, 0xf95, {7780, -2410, -806, -3913, 11724, 2484, -1018, 2390, 5298}},",
          "15785:       {\"Panasonic DMC-GH3\", -15, 0, {6559, -1752, -491, -3672, 11407, 2586, -962, 1875, 5130}},",
          "15786:       {\"Panasonic DMC-GH4\", -15, 0, {7122, -2108, -512, -3155, 11201, 2231, -541, 1423, 5045}},",
          "15787:       {\"Yuneec CGO4\", -15, 0, {7122, -2108, -512, -3155, 11201, 2231, -541, 1423, 5045}},",
          "15788:       {\"Panasonic DMC-GM1\", -15, 0, {6770, -1895, -744, -5232, 13145, 2303, -1664, 2691, 5703}},",
          "15789:       {\"Panasonic DMC-GM5\", -15, 0, {8238, -3244, -679, -3921, 11814, 2384, -836, 2022, 5852}},",
          "15790:       {\"Panasonic DMC-GX1\", -15, 0, {6763, -1919, -863, -3868, 11515, 2684, -1216, 2387, 5879}},",
          "15791:       {\"Panasonic DMC-GX85\",",
          "15792:        -15,",
          "15794:        {7771, -3020, -629, 4029, 11950, 2345, -821, 1977, 6119}},",
          "15795:       {\"Panasonic DMC-GX80\",",
          "15796:        -15,",
          "15798:        {7771, -3020, -629, 4029, 11950, 2345, -821, 1977, 6119}},",
          "15799:       {\"Panasonic DMC-GX7MK2\",",
          "15800:        -15,",
          "15802:        {7771, -3020, -629, 4029, 11950, 2345, -821, 1977, 6119}},",
          "15803:       {\"Panasonic DMC-GX7\", -15, 0, {7610, -2780, -576, -4614, 12195, 2733, -1375, 2393, 6490}},",
          "15804:       {\"Panasonic DMC-GX8\", -15, 0, {7564, -2263, -606, -3148, 11239, 2177, -540, 1435, 4853}},",
          "15805:       {\"Panasonic DMC-TZ6\",",
          "15806:        -15,",
          "15808:        {8607, -2822, -808, -3755, 11930, 2049, -820, 2060, 5224}},",
          "15809:       {\"Panasonic DMC-TZ8\",",
          "15810:        -15,",
          "15812:        {8550, -2908, -842, -3195, 11529, 1881, -338, 1603, 4631}},",
          "15813:       {\"Panasonic DMC-ZS4\",",
          "15814:        -15,",
          "15816:        {8607, -2822, -808, -3755, 11930, 2049, -820, 2060, 5224}},",
          "15817:       {\"Panasonic DMC-TZ7\",",
          "15818:        -15,",
          "15820:        {8802, -3135, -789, -3151, 11468, 1904, -550, 1745, 4810}},",
          "15821:       {\"Panasonic DMC-ZS5\",",
          "15822:        -15,",
          "15824:        {8802, -3135, -789, -3151, 11468, 1904, -550, 1745, 4810}},",
          "15825:       {\"Panasonic DMC-ZS6\",",
          "15826:        -15,",
          "15828:        {8550, -2908, -842, -3195, 11529, 1881, -338, 1603, 4631}},",
          "15829:       {\"Panasonic DMC-ZS100\",",
          "15830:        -15,",
          "15832:        {7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898}},",
          "15833:       {\"Panasonic DMC-ZS110\",",
          "15834:        -15,",
          "15836:        {7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898}},",
          "15837:       {\"Panasonic DMC-TZ100\",",
          "15838:        -15,",
          "15840:        {7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898}},",
          "15841:       {\"Panasonic DMC-TZ101\",",
          "15842:        -15,",
          "15844:        {7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898}},",
          "15845:       {\"Panasonic DMC-TZ110\",",
          "15846:        -15,",
          "15848:        {7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898}},",
          "15849:       {\"Panasonic DMC-TX1\",",
          "15850:        -15,",
          "15852:        {7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898}},",
          "15853:       {\"Leica S (Typ 007)\", 0, 0, {6063, -2234, -231, -5210, 13787, 1500, -1043, 2866, 6997}},",
          "15854:       {\"Leica X\",",
          "15855:        0,",
          "15857:        {7712, -2059, -653, -3882, 11494, 2726, -710, 1332, 5958}},",
          "15858:       {\"Leica Q (Typ 116)\", 0, 0, {11865, -4523, -1441, -5423, 14458, 935, -1587, 2687, 4830}},",
          "15859:       {\"Leica M (Typ 262)\", 0, 0, {6653, -1486, -611, -4221, 13303, 929, -881, 2416, 7226}},",
          "15860:       {\"Leica SL (Typ 601)\", 0, 0, {11865, -4523, -1441, -5423, 14458, 935, -1587, 2687, 4830}},",
          "15861:       {\"Phase One H 20\",",
          "15862:        0,",
          "15864:        {1313, 1855, -109, -6715, 15908, 808, -327, 1840, 6020}},",
          "15865:       {\"Phase One H 25\", 0, 0, {2905, 732, -237, -8134, 16626, 1476, -3038, 4253, 7517}},",
          "15866:       {\"Phase One IQ250\", 0, 0, {4396, -153, -249, -5267, 12249, 2657, -1397, 2323, 6014}},",
          "15867:       {\"Phase One P 2\", 0, 0, {2905, 732, -237, -8134, 16626, 1476, -3038, 4253, 7517}},",
          "15868:       {\"Phase One P 30\", 0, 0, {4516, -245, -37, -7020, 14976, 2173, -3206, 4671, 7087}},",
          "15869:       {\"Phase One P 45\", 0, 0, {5053, -24, -117, -5684, 14076, 1702, -2619, 4492, 5849}},",
          "15870:       {\"Phase One P40\", 0, 0, {8035, 435, -962, -6001, 13872, 2320, -1159, 3065, 5434}},",
          "15871:       {\"Phase One P65\", 0, 0, {8035, 435, -962, -6001, 13872, 2320, -1159, 3065, 5434}},",
          "15872:       {\"Photron BC2-HD\",",
          "15873:        0,",
          "15875:        {14603, -4122, -528, -1810, 9794, 2017, -297, 2763, 5936}},",
          "15876:       {\"Red One\",",
          "15877:        704,",
          "15879:        {21014, -7891, -2613, -3056, 12201, 856, -2203, 5125, 8042}},",
          "15880:       {\"Ricoh GR II\", 0, 0, {4630, -834, -423, -4977, 12805, 2417, -638, 1467, 6115}},",
          "15881:       {\"Ricoh GR\", 0, 0, {3708, -543, -160, -5381, 12254, 3556, -1471, 1929, 8234}},",
          "15882:       {\"Samsung EK-GN120\",",
          "15883:        0,",
          "15885:        {7557, -2522, -739, -4679, 12949, 1894, -840, 1777, 5311}},",
          "15886:       {\"Samsung EX1\", 0, 0x3e00, {8898, -2498, -994, -3144, 11328, 2066, -760, 1381, 4576}},",
          "15887:       {\"Samsung EX2F\", 0, 0x7ff, {10648, -3897, -1055, -2022, 10573, 1668, -492, 1611, 4742}},",
          "15888:       {\"Samsung NX mini\", 0, 0, {5222, -1196, -550, -6540, 14649, 2009, -1666, 2819, 5657}},",
          "15889:       {\"Samsung NX3300\",",
          "15890:        0,",
          "15892:        {8060, -2933, -761, -4504, 12890, 1762, -630, 1489, 5227}},",
          "15893:       {\"Samsung NX3000\", 0, 0, {8060, -2933, -761, -4504, 12890, 1762, -630, 1489, 5227}},",
          "15894:       {\"Samsung NX30\",",
          "15895:        0,",
          "15897:        {7557, -2522, -739, -4679, 12949, 1894, -840, 1777, 5311}},",
          "15898:       {\"Samsung NX2000\", 0, 0, {7557, -2522, -739, -4679, 12949, 1894, -840, 1777, 5311}},",
          "15899:       {\"Samsung NX2\",",
          "15900:        0,",
          "15902:        {6933, -2268, -753, -4921, 13387, 1647, -803, 1641, 6096}},",
          "15903:       {\"Samsung NX1000\", 0, 0, {6933, -2268, -753, -4921, 13387, 1647, -803, 1641, 6096}},",
          "15904:       {\"Samsung NX1100\", 0, 0, {6933, -2268, -753, -4921, 13387, 1647, -803, 1641, 6096}},",
          "15905:       {\"Samsung NX11\", 0, 0, {10332, -3234, -1168, -6111, 14639, 1520, -1352, 2647, 8331}},",
          "15906:       {\"Samsung NX10\",",
          "15907:        0,",
          "15909:        {10332, -3234, -1168, -6111, 14639, 1520, -1352, 2647, 8331}},",
          "15910:       {\"Samsung NX500\", 0, 0, {10686, -4042, -1052, -3595, 13238, 276, -464, 1259, 5931}},",
          "15911:       {\"Samsung NX5\", 0, 0, {10332, -3234, -1168, -6111, 14639, 1520, -1352, 2647, 8331}},",
          "15912:       {\"Samsung NX1\", 0, 0, {10686, -4042, -1052, -3595, 13238, 276, -464, 1259, 5931}},",
          "15913:       {\"Samsung WB2000\", 0, 0xfff, {12093, -3557, -1155, -1000, 9534, 1733, -22, 1787, 4576}},",
          "15914:       {\"Samsung GX-1\", 0, 0, {10504, -2438, -1189, -8603, 16207, 2531, -1022, 863, 12242}},",
          "15915:       {\"Samsung GX20\",",
          "15916:        0,",
          "15918:        {9427, -2714, -868, -7493, 16092, 1373, -2199, 3264, 7180}},",
          "15919:       {\"Samsung S85\",",
          "15920:        0,",
          "15922:        {11885, -3968, -1473, -4214, 12299, 1916, -835, 1655, 5549}},",
          "15924:       {\"Sigma dp0 Quattro\", 2047, 0, {13801, -3390, -1016, 5535, 3802, 877, 1848, 4245, 3730}},",
          "15925:       {\"Sigma dp1 Quattro\", 2047, 0, {13801, -3390, -1016, 5535, 3802, 877, 1848, 4245, 3730}},",
          "15926:       {\"Sigma dp2 Quattro\", 2047, 0, {13801, -3390, -1016, 5535, 3802, 877, 1848, 4245, 3730}},",
          "15927:       {\"Sigma dp3 Quattro\", 2047, 0, {13801, -3390, -1016, 5535, 3802, 877, 1848, 4245, 3730}},",
          "15929:       {\"Sigma SD9\",",
          "15930:        15,",
          "15932:        {14082, -2201, -1056, -5243, 14788, 167, -121, 196, 8881}},",
          "15933:       {\"Sigma SD10\",",
          "15934:        15,",
          "15936:        {14082, -2201, -1056, -5243, 14788, 167, -121, 196, 8881}},",
          "15937:       {\"Sigma SD14\",",
          "15938:        15,",
          "15940:        {14082, -2201, -1056, -5243, 14788, 167, -121, 196, 8881}},",
          "15941:       {\"Sigma SD15\",",
          "15942:        15,",
          "15944:        {14082, -2201, -1056, -5243, 14788, 167, -121, 196, 8881}},",
          "15946:       {\"Sigma SD1\",",
          "15947:        31,",
          "15949:        {5133, -1895, -353, 4978, 744, 144, 3837, 3069, 2777}},",
          "15950:       {\"Sigma DP1 Merrill\",",
          "15951:        31,",
          "15953:        {5133, -1895, -353, 4978, 744, 144, 3837, 3069, 2777}},",
          "15954:       {\"Sigma DP2 Merrill\",",
          "15955:        31,",
          "15957:        {5133, -1895, -353, 4978, 744, 144, 3837, 3069, 2777}},",
          "15958:       {\"Sigma DP3 Merrill\",",
          "15959:        31,",
          "15961:        {5133, -1895, -353, 4978, 744, 144, 3837, 3069, 2777}},",
          "15963:       {\"Sigma DP\",",
          "15964:        0,",
          "15967:        {13100, -3638, -847, 6855, 2369, 580, 2723, 3218, 3251}},",
          "15968:       {\"Sinar\",",
          "15969:        0,",
          "15971:        {16442, -2956, -2422, -2877, 12128, 750, -1136, 6066, 4559}},",
          "15972:       {\"Sony DSC-F828\", 0, 0, {7924, -1910, -777, -8226, 15459, 2998, -1517, 2199, 6818, -7242, 11401, 3481}},",
          "15973:       {\"Sony DSC-R1\", 0, 0, {8512, -2641, -694, -8042, 15670, 2526, -1821, 2117, 7414}},",
          "15974:       {\"Sony DSC-V3\", 0, 0, {7511, -2571, -692, -7894, 15088, 3060, -948, 1111, 8128}},",
          "15975:       {\"Sony DSC-RX100M5\",",
          "15976:        -800,",
          "15978:        {6596, -2079, -562, -4782, 13016, 1933, -970, 1581, 5181}},",
          "15979:       {\"Sony DSC-RX100M\",",
          "15980:        -800,",
          "15982:        {6596, -2079, -562, -4782, 13016, 1933, -970, 1581, 5181}},",
          "15983:       {\"Sony DSC-RX100\", 0, 0, {8651, -2754, -1057, -3464, 12207, 1373, -568, 1398, 4434}},",
          "15984:       {\"Sony DSC-RX10\",",
          "15985:        0,",
          "15987:        {6679, -1825, -745, -5047, 13256, 1953, -1580, 2422, 5183}},",
          "15988:       {\"Sony DSC-RX1RM2\", 0, 0, {6629, -1900, -483, -4618, 12349, 2550, -622, 1381, 6514}},",
          "15989:       {\"Sony DSC-RX1R\", 0, 0, {8195, -2800, -422, -4261, 12273, 1709, -1505, 2400, 5624}},",
          "15990:       {\"Sony DSC-RX1\", 0, 0, {6344, -1612, -462, -4863, 12477, 2681, -865, 1786, 6899}},",
          "15991:       {\"Sony DSLR-A100\", 0, 0xfeb, {9437, -2811, -774, -8405, 16215, 2290, -710, 596, 7181}},",
          "15992:       {\"Sony DSLR-A290\", 0, 0, {6038, -1484, -579, -9145, 16746, 2512, -875, 746, 7218}},",
          "15993:       {\"Sony DSLR-A2\", 0, 0, {9847, -3091, -928, -8485, 16345, 2225, -715, 595, 7103}},",
          "15994:       {\"Sony DSLR-A300\", 0, 0, {9847, -3091, -928, -8485, 16345, 2225, -715, 595, 7103}},",
          "15995:       {\"Sony DSLR-A330\", 0, 0, {9847, -3091, -929, -8485, 16346, 2225, -714, 595, 7103}},",
          "15996:       {\"Sony DSLR-A350\", 0, 0xffc, {6038, -1484, -578, -9146, 16746, 2513, -875, 746, 7217}},",
          "15997:       {\"Sony DSLR-A380\", 0, 0, {6038, -1484, -579, -9145, 16746, 2512, -875, 746, 7218}},",
          "15998:       {\"Sony DSLR-A390\", 0, 0, {6038, -1484, -579, -9145, 16746, 2512, -875, 746, 7218}},",
          "15999:       {\"Sony DSLR-A450\", 0, 0xfeb, {4950, -580, -103, -5228, 12542, 3029, -709, 1435, 7371}},",
          "16000:       {\"Sony DSLR-A580\", 0, 0xfeb, {5932, -1492, -411, -4813, 12285, 2856, -741, 1524, 6739}},",
          "16001:       {\"Sony DSLR-A500\", 0, 0xfeb, {6046, -1127, -278, -5574, 13076, 2786, -691, 1419, 7625}},",
          "16002:       {\"Sony DSLR-A5\", 0, 0xfeb, {4950, -580, -103, -5228, 12542, 3029, -709, 1435, 7371}},",
          "16003:       {\"Sony DSLR-A700\", 0, 0, {5775, -805, -359, -8574, 16295, 2391, -1943, 2341, 7249}},",
          "16004:       {\"Sony DSLR-A850\", 0, 0, {5413, -1162, -365, -5665, 13098, 2866, -608, 1179, 8440}},",
          "16005:       {\"Sony DSLR-A900\", 0, 0, {5209, -1072, -397, -8845, 16120, 2919, -1618, 1803, 8654}},",
          "16006:       {\"Sony ILCA-68\", 0, 0, {6435, -1903, -536, -4722, 12449, 2550, -663, 1363, 6517}},",
          "16007:       {\"Sony ILCA-77M2\", 0, 0, {5991, -1732, -443, -4100, 11989, 2381, -704, 1467, 5992}},",
          "16008:       {\"Sony ILCA-99M2\",",
          "16009:        0,",
          "16011:        {6660, -1918, -471, -4613, 12398, 2485, -649, 1433, 6447}},",
          "16012:       {\"Sony ILCE-7M2\", 0, 0, {5271, -712, -347, -6153, 13653, 2763, -1601, 2366, 7242}},",
          "16013:       {\"Sony ILCE-7SM2\", 0, 0, {5838, -1430, -246, -3497, 11477, 2297, -748, 1885, 5778}},",
          "16014:       {\"Sony ILCE-7S\", 0, 0, {5838, -1430, -246, -3497, 11477, 2297, -748, 1885, 5778}},",
          "16015:       {\"Sony ILCE-7RM2\", 0, 0, {6629, -1900, -483, -4618, 12349, 2550, -622, 1381, 6514}},",
          "16016:       {\"Sony ILCE-7R\", 0, 0, {4913, -541, -202, -6130, 13513, 2906, -1564, 2151, 7183}},",
          "16017:       {\"Sony ILCE-7\", 0, 0, {5271, -712, -347, -6153, 13653, 2763, -1601, 2366, 7242}},",
          "16018:       {\"Sony ILCE-6300\", 0, 0, {5973, -1695, -419, -3826, 11797, 2293, -639, 1398, 5789}},",
          "16019:       {\"Sony ILCE-6500\",",
          "16020:        0,",
          "16022:        {5973, -1695, -419, -3826, 11797, 2293, -639, 1398, 5789}},",
          "16023:       {\"Sony ILCE\",",
          "16024:        0,",
          "16026:        {5991, -1456, -455, -4764, 12135, 2980, -707, 1425, 6701}},",
          "16027:       {\"Sony NEX-5N\", 0, 0, {5991, -1456, -455, -4764, 12135, 2980, -707, 1425, 6701}},",
          "16028:       {\"Sony NEX-5R\", 0, 0, {6129, -1545, -418, -4930, 12490, 2743, -977, 1693, 6615}},",
          "16029:       {\"Sony NEX-5T\", 0, 0, {6129, -1545, -418, -4930, 12490, 2743, -977, 1693, 6615}},",
          "16030:       {\"Sony NEX-3N\", 0, 0, {6129, -1545, -418, -4930, 12490, 2743, -977, 1693, 6615}},",
          "16031:       {\"Sony NEX-3\",",
          "16032:        0,",
          "16034:        {6549, -1550, -436, -4880, 12435, 2753, -854, 1868, 6976}},",
          "16035:       {\"Sony NEX-5\",",
          "16036:        0,",
          "16038:        {6549, -1550, -436, -4880, 12435, 2753, -854, 1868, 6976}},",
          "16039:       {\"Sony NEX-6\", 0, 0, {6129, -1545, -418, -4930, 12490, 2743, -977, 1693, 6615}},",
          "16040:       {\"Sony NEX-7\", 0, 0, {5491, -1192, -363, -4951, 12342, 2948, -911, 1722, 7192}},",
          "16041:       {\"Sony NEX\",",
          "16042:        0,",
          "16044:        {5991, -1456, -455, -4764, 12135, 2980, -707, 1425, 6701}},",
          "16045:       {\"Sony SLT-A33\", 0, 0, {6069, -1221, -366, -5221, 12779, 2734, -1024, 2066, 6834}},",
          "16046:       {\"Sony SLT-A35\", 0, 0, {5986, -1618, -415, -4557, 11820, 3120, -681, 1404, 6971}},",
          "16047:       {\"Sony SLT-A37\", 0, 0, {5991, -1456, -455, -4764, 12135, 2980, -707, 1425, 6701}},",
          "16048:       {\"Sony SLT-A55\", 0, 0, {5932, -1492, -411, -4813, 12285, 2856, -741, 1524, 6739}},",
          "16049:       {\"Sony SLT-A57\", 0, 0, {5991, -1456, -455, -4764, 12135, 2980, -707, 1425, 6701}},",
          "16050:       {\"Sony SLT-A58\", 0, 0, {5991, -1456, -455, -4764, 12135, 2980, -707, 1425, 6701}},",
          "16051:       {\"Sony SLT-A65\", 0, 0, {5491, -1192, -363, -4951, 12342, 2948, -911, 1722, 7192}},",
          "16052:       {\"Sony SLT-A77\", 0, 0, {5491, -1192, -363, -4951, 12342, 2948, -911, 1722, 7192}},",
          "16053:       {\"Sony SLT-A99\", 0, 0, {6344, -1612, -462, -4863, 12477, 2681, -865, 1786, 6899}},",
          "16059:   if (colors > 4 || colors < 1)",
          "16060:     return;",
          "16062:   int bl4 = (cblack[0] + cblack[1] + cblack[2] + cblack[3]) / 4, bl64 = 0;",
          "16063:   if (cblack[4] * cblack[5] > 0)",
          "16065:     for (unsigned c = 0; c < 4096 && c < cblack[4] * cblack[5]; c++)",
          "16066:       bl64 += cblack[c + 6];",
          "16067:     bl64 /= cblack[4] * cblack[5];",
          "16069:   int rblack = black + bl4 + bl64;",
          "16071:   sprintf(name, \"%s %s\", t_make, t_model);",
          "16072:   for (i = 0; i < sizeof table / sizeof *table; i++)",
          "16073:     if (!strncasecmp(name, table[i].prefix, strlen(table[i].prefix)))",
          "16074:     {",
          "16075:       if (!dng_version)",
          "16076:       {",
          "16077:         if (table[i].t_black > 0)",
          "16078:         {",
          "16079:           black = (ushort)table[i].t_black;",
          "16080:           memset(cblack, 0, sizeof(cblack));",
          "16081:         }",
          "16082:         else if (table[i].t_black < 0 && rblack == 0)",
          "16083:         {",
          "16084:           black = (ushort)(-table[i].t_black);",
          "16085:           memset(cblack, 0, sizeof(cblack));",
          "16086:         }",
          "16087:         if (table[i].t_maximum)",
          "16088:           maximum = (ushort)table[i].t_maximum;",
          "16089:       }",
          "16090:       if (table[i].trans[0])",
          "16091:       {",
          "16092:         for (raw_color = j = 0; j < 12; j++)",
          "16094:           if (internal_only)",
          "16095:             imgdata.color.cam_xyz[0][j] = table[i].trans[j] / 10000.0;",
          "16096:           else",
          "16097:             imgdata.color.cam_xyz[0][j] =",
          "16099:                 ((double *)cam_xyz)[j] = table[i].trans[j] / 10000.0;",
          "16101:         if (!internal_only)",
          "16103:           cam_xyz_coeff(rgb_cam, cam_xyz);",
          "16109: void CLASS simple_coeff(int index)",
          "16112:                                     {1.4032, -0.2231, -0.1016, -0.5263, 1.4816, 0.017, -0.0112, 0.0183, 0.9113},",
          "16114:                                     {2.25, 0.75, -1.75, -0.25, -0.25, 0.75, 0.75, -0.25, -0.25, -1.75, 0.75, 2.25},",
          "16116:                                     {1.893, -0.418, -0.476, -0.495, 1.773, -0.278, -1.017, -0.655, 2.672},",
          "16118:                                     {-1.936280, 1.800443, -1.448486, 2.584324, 1.405365, -0.524955, -0.289090, 0.408680,",
          "16119:                                      -1.204965, 1.082304, 2.941367, -1.818705}};",
          "16122:   for (raw_color = i = 0; i < 3; i++)",
          "16123:     FORCC rgb_cam[i][c] = table[index][i * colors + c];",
          "16126: short CLASS guess_byte_order(int words)",
          "16129:   int t = 2, msb;",
          "16130:   double diff, sum[2] = {0, 0};",
          "16132:   fread(test[0], 2, 2, ifp);",
          "16133:   for (words -= 2; words--;)",
          "16134:   {",
          "16135:     fread(test[t], 2, 1, ifp);",
          "16136:     for (msb = 0; msb < 2; msb++)",
          "16137:     {",
          "16138:       diff = (test[t ^ 2][msb] << 8 | test[t ^ 2][!msb]) - (test[t][msb] << 8 | test[t][!msb]);",
          "16139:       sum[msb] += diff * diff;",
          "16141:     t = (t + 1) & 3;",
          "16146: float CLASS find_green(int bps, int bite, int off0, int off1)",
          "16148:   UINT64 bitbuf = 0;",
          "16151:   double sum[] = {0, 0};",
          "16153:   FORC(2)",
          "16154:   {",
          "16155:     fseek(ifp, c ? off1 : off0, SEEK_SET);",
          "16156:     for (vbits = col = 0; col < width; col++)",
          "16157:     {",
          "16158:       for (vbits -= bps; vbits < 0; vbits += bite)",
          "16159:       {",
          "16160:         bitbuf <<= bite;",
          "16161:         for (i = 0; i < bite; i += 8)",
          "16162:           bitbuf |= (unsigned)(fgetc(ifp) << i);",
          "16164:       img[c][col] = bitbuf << (64 - bps - vbits) >> (64 - bps);",
          "16167:   FORC(width - 1)",
          "16168:   {",
          "16169:     sum[c & 1] += ABS(img[0][c] - img[1][c + 1]);",
          "16170:     sum[~c & 1] += ABS(img[1][c] - img[0][c + 1]);",
          "16172:   return 100 * log(sum[0] / sum[1]);",
          "16178:   if (len < 1)",
          "16179:     return; // not needed, b/c sizeof of make/model is 64",
          "16180:   string[len - 1] = 0;",
          "16181:   if (len < 3)",
          "16182:     return; // also not needed",
          "16183:   len = strnlen(string, len - 1);",
          "16184:   for (int i = len - 1; i >= 0; i--)",
          "16185:   {",
          "16186:     if (isspace(string[i]))",
          "16187:       string[i] = 0;",
          "",
          "---------------",
          "--- Hunk 115 ---",
          "[Context before]",
          "14979: void CLASS identify()",
          "14980: {",
          "14981:   static const short pana[][6] = {",
          "15005:   };",
          "15006:   static const ushort canon[][11] = {",
          "15051:   };",
          "15053:     ushort id;",
          "15054:     char t_model[20];",
          "15179: #else",
          "15181:     unsigned fsize;",
          "15182:     ushort rw, rh;",
          "15183:     uchar lm, tm, rm, bm, lf, cf, max, flags;",
          "15184:     char t_make[10], t_model[20];",
          "15185:     ushort offset;",
          "15343: #ifdef LIBRAW_LIBRARY_BUILD",
          "15344:   char head[64], *cp;",
          "15345: #else",
          "15346:   char head[32], *cp;",
          "15347: #endif",
          "15349:   struct jhead jh;",
          "15351: #ifdef LIBRAW_LIBRARY_BUILD",
          "15356: #endif",
          "15359:   raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;",
          "15360:   maximum = height = width = top_margin = left_margin = 0;",
          "15361:   cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;",
          "15362:   iso_speed = shutter = aperture = focal_len = unique_id = 0;",
          "15363:   tiff_nifds = 0;",
          "15369:   thumb_offset = thumb_length = thumb_width = thumb_height = 0;",
          "15370:   load_raw = thumb_load_raw = 0;",
          "15371:   write_thumb = &CLASS jpeg_thumb;",
          "",
          "[Removed Lines]",
          "14982:     { 3130, 1743,  4,  0, -6,  0 },",
          "14983:     { 3130, 2055,  4,  0, -6,  0 },",
          "14984:     { 3130, 2319,  4,  0, -6,  0 },",
          "14985:     { 3170, 2103, 18,  0,-42, 20 },",
          "14986:     { 3170, 2367, 18, 13,-42,-21 },",
          "14987:     { 3177, 2367,  0,  0, -1,  0 },",
          "14988:     { 3304, 2458,  0,  0, -1,  0 },",
          "14989:     { 3330, 2463,  9,  0, -5,  0 },",
          "14990:     { 3330, 2479,  9,  0,-17,  4 },",
          "14991:     { 3370, 1899, 15,  0,-44, 20 },",
          "14992:     { 3370, 2235, 15,  0,-44, 20 },",
          "14993:     { 3370, 2511, 15, 10,-44,-21 },",
          "14994:     { 3690, 2751,  3,  0, -8, -3 },",
          "14995:     { 3710, 2751,  0,  0, -3,  0 },",
          "14996:     { 3724, 2450,  0,  0,  0, -2 },",
          "14997:     { 3770, 2487, 17,  0,-44, 19 },",
          "14998:     { 3770, 2799, 17, 15,-44,-19 },",
          "14999:     { 3880, 2170,  6,  0, -6,  0 },",
          "15000:     { 4060, 3018,  0,  0,  0, -2 },",
          "15001:     { 4290, 2391,  3,  0, -8, -1 },",
          "15002:     { 4330, 2439, 17, 15,-44,-19 },",
          "15003:     { 4508, 2962,  0,  0, -3, -4 },",
          "15004:     { 4508, 3330,  0,  0, -3, -6 },",
          "15007:     { 1944, 1416,   0,  0, 48,  0 },",
          "15008:     { 2144, 1560,   4,  8, 52,  2, 0, 0, 0, 25 },",
          "15009:     { 2224, 1456,  48,  6,  0,  2 },",
          "15010:     { 2376, 1728,  12,  6, 52,  2 },",
          "15011:     { 2672, 1968,  12,  6, 44,  2 },",
          "15012:     { 3152, 2068,  64, 12,  0,  0, 16 },",
          "15013:     { 3160, 2344,  44, 12,  4,  4 },",
          "15014:     { 3344, 2484,   4,  6, 52,  6 },",
          "15015:     { 3516, 2328,  42, 14,  0,  0 },",
          "15016:     { 3596, 2360,  74, 12,  0,  0 },",
          "15017:     { 3744, 2784,  52, 12,  8, 12 },",
          "15018:     { 3944, 2622,  30, 18,  6,  2 },",
          "15019:     { 3948, 2622,  42, 18,  0,  2 },",
          "15020:     { 3984, 2622,  76, 20,  0,  2, 14 },",
          "15021:     { 4104, 3048,  48, 12, 24, 12 },",
          "15022:     { 4116, 2178,   4,  2,  0,  0 },",
          "15023:     { 4152, 2772, 192, 12,  0,  0 },",
          "15024:     { 4160, 3124, 104, 11,  8, 65 },",
          "15025:     { 4176, 3062,  96, 17,  8,  0, 0, 16, 0, 7, 0x49 },",
          "15026:     { 4192, 3062,  96, 17, 24,  0, 0, 16, 0, 0, 0x49 },",
          "15027:     { 4312, 2876,  22, 18,  0,  2 },",
          "15028:     { 4352, 2874,  62, 18,  0,  0 },",
          "15029:     { 4476, 2954,  90, 34,  0,  0 },",
          "15030:     { 4480, 3348,  12, 10, 36, 12, 0, 0, 0, 18, 0x49 },",
          "15031:     { 4480, 3366,  80, 50,  0,  0 },",
          "15032:     { 4496, 3366,  80, 50, 12,  0 },",
          "15033:     { 4768, 3516,  96, 16,  0,  0, 0, 16 },",
          "15034:     { 4832, 3204,  62, 26,  0,  0 },",
          "15035:     { 4832, 3228,  62, 51,  0,  0 },",
          "15036:     { 5108, 3349,  98, 13,  0,  0 },",
          "15037:     { 5120, 3318, 142, 45, 62,  0 },",
          "15039:     { 5344, 3516, 142, 51,  0,  0 },",
          "15040:     { 5344, 3584, 126,100,  0,  2 },",
          "15041:     { 5360, 3516, 158, 51,  0,  0 },",
          "15042:     { 5568, 3708,  72, 38,  0,  0 },",
          "15043:     { 5632, 3710,  96, 17,  0,  0, 0, 16, 0, 0, 0x49 },",
          "15044:     { 5712, 3774,  62, 20, 10,  2 },",
          "15045:     { 5792, 3804, 158, 51,  0,  0 },",
          "15046:     { 5920, 3950, 122, 80,  2,  0 },",
          "15050:     { 8896, 5920, 160, 64,  0,  0 },",
          "15052:   static const struct {",
          "15055:   } unique[] = {",
          "15056:     { 0x001, \"EOS-1D\" },",
          "15057:     { 0x167, \"EOS-1DS\" },",
          "15058:     { 0x168, \"EOS 10D\" },",
          "15059:     { 0x169, \"EOS-1D Mark III\" },",
          "15060:     { 0x170, \"EOS 300D\" },",
          "15061:     { 0x174, \"EOS-1D Mark II\" },",
          "15062:     { 0x175, \"EOS 20D\" },",
          "15063:     { 0x176, \"EOS 450D\" },",
          "15064:     { 0x188, \"EOS-1Ds Mark II\" },",
          "15065:     { 0x189, \"EOS 350D\" },",
          "15066:     { 0x190, \"EOS 40D\" },",
          "15067:     { 0x213, \"EOS 5D\" },",
          "15068:     { 0x215, \"EOS-1Ds Mark III\" },",
          "15069:     { 0x218, \"EOS 5D Mark II\" },",
          "15070:     { 0x232, \"EOS-1D Mark II N\" },",
          "15071:     { 0x234, \"EOS 30D\" },",
          "15072:     { 0x236, \"EOS 400D\" },",
          "15073:     { 0x250, \"EOS 7D\" },",
          "15074:     { 0x252, \"EOS 500D\" },",
          "15075:     { 0x254, \"EOS 1000D\" },",
          "15076:     { 0x261, \"EOS 50D\" },",
          "15077:     { 0x269, \"EOS-1D X\" },",
          "15078:     { 0x270, \"EOS 550D\" },",
          "15079:     { 0x281, \"EOS-1D Mark IV\" },",
          "15080:     { 0x285, \"EOS 5D Mark III\" },",
          "15081:     { 0x286, \"EOS 600D\" },",
          "15082:     { 0x287, \"EOS 60D\" },",
          "15083:     { 0x288, \"EOS 1100D\" },",
          "15084:     { 0x289, \"EOS 7D Mark II\" },",
          "15085:     { 0x301, \"EOS 650D\" },",
          "15086:     { 0x302, \"EOS 6D\" },",
          "15087:     { 0x324, \"EOS-1D C\" },",
          "15088:     { 0x325, \"EOS 70D\" },",
          "15089:     { 0x326, \"EOS 700D\" },",
          "15090:     { 0x327, \"EOS 1200D\" },",
          "15091:     { 0x328, \"EOS-1D X Mark II\" },",
          "15092:     { 0x331, \"EOS M\" },",
          "15093:     { 0x335, \"EOS M2\" },",
          "15097:     { 0x346, \"EOS 100D\" },",
          "15098:     { 0x347, \"EOS 760D\" },",
          "15099:     { 0x349, \"EOS 5D Mark IV\" },",
          "15100:     { 0x350, \"EOS 80D\"},",
          "15101:     { 0x382, \"EOS 5DS\" },",
          "15102:     { 0x393, \"EOS 750D\" },",
          "15103:     { 0x401, \"EOS 5DS R\" },",
          "15104:     { 0x404, \"EOS 1300D\" },",
          "15105:   }, sonique[] = {",
          "15106:     { 0x002, \"DSC-R1\" },",
          "15107:     { 0x100, \"DSLR-A100\" },",
          "15108:     { 0x101, \"DSLR-A900\" },",
          "15109:     { 0x102, \"DSLR-A700\" },",
          "15110:     { 0x103, \"DSLR-A200\" },",
          "15111:     { 0x104, \"DSLR-A350\" },",
          "15112:     { 0x105, \"DSLR-A300\" },",
          "15113:     { 0x106, \"DSLR-A900\" },",
          "15114:     { 0x107, \"DSLR-A380\" },",
          "15115:     { 0x108, \"DSLR-A330\" },",
          "15116:     { 0x109, \"DSLR-A230\" },",
          "15117:     { 0x10a, \"DSLR-A290\" },",
          "15118:     { 0x10d, \"DSLR-A850\" },",
          "15119:     { 0x10e, \"DSLR-A850\" },",
          "15120:     { 0x111, \"DSLR-A550\" },",
          "15121:     { 0x112, \"DSLR-A500\" },",
          "15122:     { 0x113, \"DSLR-A450\" },",
          "15123:     { 0x116, \"NEX-5\" },",
          "15124:     { 0x117, \"NEX-3\" },",
          "15125:     { 0x118, \"SLT-A33\" },",
          "15126:     { 0x119, \"SLT-A55V\" },",
          "15127:     { 0x11a, \"DSLR-A560\" },",
          "15128:     { 0x11b, \"DSLR-A580\" },",
          "15129:     { 0x11c, \"NEX-C3\" },",
          "15130:     { 0x11d, \"SLT-A35\" },",
          "15131:     { 0x11e, \"SLT-A65V\" },",
          "15132:     { 0x11f, \"SLT-A77V\" },",
          "15133:     { 0x120, \"NEX-5N\" },",
          "15134:     { 0x121, \"NEX-7\" },",
          "15135:     { 0x122, \"NEX-VG20E\"},",
          "15136:     { 0x123, \"SLT-A37\" },",
          "15137:     { 0x124, \"SLT-A57\" },",
          "15138:     { 0x125, \"NEX-F3\" },",
          "15139:     { 0x126, \"SLT-A99V\" },",
          "15140:     { 0x127, \"NEX-6\" },",
          "15141:     { 0x128, \"NEX-5R\" },",
          "15142:     { 0x129, \"DSC-RX100\" },",
          "15143:     { 0x12a, \"DSC-RX1\" },",
          "15144:     { 0x12b, \"NEX-VG900\" },",
          "15145:     { 0x12c, \"NEX-VG30E\" },",
          "15146:     { 0x12e, \"ILCE-3000\" },",
          "15147:     { 0x12f, \"SLT-A58\" },",
          "15148:     { 0x131, \"NEX-3N\" },",
          "15149:     { 0x132, \"ILCE-7\" },",
          "15150:     { 0x133, \"NEX-5T\" },",
          "15151:     { 0x134, \"DSC-RX100M2\" },",
          "15152:     { 0x135, \"DSC-RX10\" },",
          "15153:     { 0x136, \"DSC-RX1R\" },",
          "15154:     { 0x137, \"ILCE-7R\" },",
          "15155:     { 0x138, \"ILCE-6000\" },",
          "15156:     { 0x139, \"ILCE-5000\" },",
          "15157:     { 0x13d, \"DSC-RX100M3\" },",
          "15158:     { 0x13e, \"ILCE-7S\" },",
          "15159:     { 0x13f, \"ILCA-77M2\" },",
          "15160:     { 0x153, \"ILCE-5100\" },",
          "15161:     { 0x154, \"ILCE-7M2\" },",
          "15162:     { 0x155, \"DSC-RX100M4\" },",
          "15163:     { 0x156, \"DSC-RX10M2\" },",
          "15164:     { 0x158, \"DSC-RX1RM2\" },",
          "15165:     { 0x15a, \"ILCE-QX1\" },",
          "15166:     { 0x15b, \"ILCE-7RM2\" },",
          "15167:     { 0x15e, \"ILCE-7SM2\" },",
          "15168:     { 0x161, \"ILCA-68\" },",
          "15169:     { 0x162, \"ILCA-99M2\" },",
          "15170:     { 0x163, \"DSC-RX10M3\" },",
          "15171:     { 0x164, \"DSC-RX100M5\"},",
          "15172:     { 0x165, \"ILCE-6300\" },",
          "15173:     { 0x168, \"ILCE-6500\"},",
          "15174:   };",
          "15176: #ifdef LIBRAW_LIBRARY_BUILD",
          "15177:   static const libraw_custom_camera_t",
          "15178:     const_table[]",
          "15180:   static const struct {",
          "15186:   }",
          "15187:   table[]",
          "15188: #endif",
          "15189:    = {",
          "15190:     {   786432,1024, 768, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-080C\" },",
          "15191:     {  1447680,1392,1040, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-145C\" },",
          "15192:     {  1920000,1600,1200, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-201C\" },",
          "15193:     {  5067304,2588,1958, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-510C\" },",
          "15194:     {  5067316,2588,1958, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-510C\",12 },",
          "15195:     { 10134608,2588,1958, 0, 0, 0, 0, 9,0x94,0,0,\"AVT\",\"F-510C\" },",
          "15196:     { 10134620,2588,1958, 0, 0, 0, 0, 9,0x94,0,0,\"AVT\",\"F-510C\",12 },",
          "15197:     { 16157136,3272,2469, 0, 0, 0, 0, 9,0x94,0,0,\"AVT\",\"F-810C\" },",
          "15198:     { 15980544,3264,2448, 0, 0, 0, 0, 8,0x61,0,1,\"AgfaPhoto\",\"DC-833m\" },",
          "15199:     {  9631728,2532,1902, 0, 0, 0, 0,96,0x61,0,0,\"Alcatel\",\"5035D\" },",
          "15200:     {  31850496,4608,3456, 0, 0, 0, 0,0,0x94,0,0,\"GITUP\",\"GIT2 4:3\" },",
          "15201:     {  23887872,4608,2592, 0, 0, 0, 0,0,0x94,0,0,\"GITUP\",\"GIT2 16:9\" },",
          "15204:     {  1540857,2688,1520, 0, 0, 0, 0, 1,0x61,0,0,\"Samsung\",\"S3\" },",
          "15205:     {  2658304,1212,1096, 0, 0, 0, 0, 1 ,0x16,0,0,\"LG\",\"G3FrontMipi\" },",
          "15206:     {  2842624,1296,1096, 0, 0, 0, 0, 1 ,0x16,0,0,\"LG\",\"G3FrontQCOM\" },",
          "15207:     {  2969600,1976,1200, 0, 0, 0, 0, 1 ,0x16,0,0,\"Xiaomi\",\"MI3wMipi\" },",
          "15208:     {  3170304,1976,1200, 0, 0, 0, 0, 1 ,0x16,0,0,\"Xiaomi\",\"MI3wQCOM\" },",
          "15209:     {  3763584,1584,1184, 0, 0, 0, 0, 96,0x61,0,0,\"I_Mobile\",\"I_StyleQ6\" },",
          "15210:     {  5107712,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"UltraPixel1\" },",
          "15211:     {  5382640,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"UltraPixel2\" },",
          "15212:     {  5664912,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"4688\" },",
          "15213:     {  5664912,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"4688\" },",
          "15214:     {  5364240,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"4688\" },",
          "15215:     {  6299648,2592,1944, 0, 0, 0, 0, 1 ,0x16,0,0,\"OmniVisi\",\"OV5648\" },",
          "15216:     {  6721536,2592,1944, 0, 0, 0, 0, 0 ,0x16,0,0,\"OmniVisi\",\"OV56482\" },",
          "15217:     {  6746112,2592,1944, 0, 0, 0, 0, 0 ,0x16,0,0,\"HTC\",\"OneSV\" },",
          "15218:     {  9631728,2532,1902, 0, 0, 0, 0, 96,0x61,0,0,\"Sony\",\"5mp\" },",
          "15219:     {  9830400,2560,1920, 0, 0, 0, 0, 96,0x61,0,0,\"NGM\",\"ForwardArt\" },",
          "15220:     { 10186752,3264,2448, 0, 0, 0, 0, 1,0x94,0,0,\"Sony\",\"IMX219-mipi 8mp\" },",
          "15221:     { 10223360,2608,1944, 0, 0, 0, 0, 96,0x16,0,0,\"Sony\",\"IMX\" },",
          "15222:     { 10782464,3282,2448, 0, 0, 0, 0, 0 ,0x16,0,0,\"HTC\",\"MyTouch4GSlide\" },",
          "15223:     { 10788864,3282,2448, 0, 0, 0, 0, 0, 0x16,0,0,\"Xperia\",\"L\" },",
          "15224:     { 15967488,3264,2446, 0, 0, 0, 0, 96,0x16,0,0,\"OmniVison\",\"OV8850\" },",
          "15225:     { 16224256,4208,3082, 0, 0, 0, 0, 1, 0x16,0,0,\"LG\",\"G3MipiL\" },",
          "15226:     { 16424960,4208,3120, 0, 0, 0, 0, 1, 0x16,0,0,\"IMX135\",\"MipiL\" },",
          "15227:     { 17326080,4164,3120, 0, 0, 0, 0, 1, 0x16,0,0,\"LG\",\"G3LQCom\" },",
          "15228:     { 17522688,4212,3120, 0, 0, 0, 0, 0,0x16,0,0,\"Sony\",\"IMX135-QCOM\" },",
          "15229:     { 19906560,4608,3456, 0, 0, 0, 0, 1, 0x16,0,0,\"Gione\",\"E7mipi\" },",
          "15230:     { 19976192,5312,2988, 0, 0, 0, 0, 1, 0x16,0,0,\"LG\",\"G4\" },",
          "15231:     { 20389888,4632,3480, 0, 0, 0, 0, 1, 0x16,0,0,\"Xiaomi\",\"RedmiNote3Pro\" },",
          "15232:     { 20500480,4656,3496, 0, 0, 0, 0, 1,0x94,0,0,\"Sony\",\"IMX298-mipi 16mp\" },",
          "15233:     { 21233664,4608,3456, 0, 0, 0, 0, 1, 0x16,0,0,\"Gione\",\"E7qcom\" },",
          "15234:     { 26023936,4192,3104, 0, 0, 0, 0, 96,0x94,0,0,\"THL\",\"5000\" },",
          "15235:     { 26257920,4208,3120, 0, 0, 0, 0, 96,0x94,0,0,\"Sony\",\"IMX214\" },",
          "15236:     { 26357760,4224,3120, 0, 0, 0, 0, 96,0x61,0,0,\"OV\",\"13860\" },",
          "15237:     { 41312256,5248,3936, 0, 0, 0, 0, 96,0x61,0,0,\"Meizu\",\"MX4\" },",
          "15238:     { 42923008,5344,4016, 0, 0, 0, 0, 96,0x61,0,0,\"Sony\",\"IMX230\" },",
          "15240:     {  20137344,3664,2748,0, 0, 0, 0,0x40,0x49,0,0,\"Aptina\",\"MT9J003\",0xffff },",
          "15241:     {  2868726,1384,1036, 0, 0, 0, 0,64,0x49,0,8,\"Baumer\",\"TXG14\",1078 },",
          "15242:     {  5298000,2400,1766,12,12,44, 2,40,0x94,0,2,\"Canon\",\"PowerShot SD300\" },",
          "15243:     {  6553440,2664,1968, 4, 4,44, 4,40,0x94,0,2,\"Canon\",\"PowerShot A460\" },",
          "15244:     {  6573120,2672,1968,12, 8,44, 0,40,0x94,0,2,\"Canon\",\"PowerShot A610\" },",
          "15245:     {  6653280,2672,1992,10, 6,42, 2,40,0x94,0,2,\"Canon\",\"PowerShot A530\" },",
          "15246:     {  7710960,2888,2136,44, 8, 4, 0,40,0x94,0,2,\"Canon\",\"PowerShot S3 IS\" },",
          "15247:     {  9219600,3152,2340,36,12, 4, 0,40,0x94,0,2,\"Canon\",\"PowerShot A620\" },",
          "15248:     {  9243240,3152,2346,12, 7,44,13,40,0x49,0,2,\"Canon\",\"PowerShot A470\" },",
          "15249:     { 10341600,3336,2480, 6, 5,32, 3,40,0x94,0,2,\"Canon\",\"PowerShot A720 IS\" },",
          "15250:     { 10383120,3344,2484,12, 6,44, 6,40,0x94,0,2,\"Canon\",\"PowerShot A630\" },",
          "15251:     { 12945240,3736,2772,12, 6,52, 6,40,0x94,0,2,\"Canon\",\"PowerShot A640\" },",
          "15252:     { 15636240,4104,3048,48,12,24,12,40,0x94,0,2,\"Canon\",\"PowerShot A650\" },",
          "15253:     { 15467760,3720,2772, 6,12,30, 0,40,0x94,0,2,\"Canon\",\"PowerShot SX110 IS\" },",
          "15254:     { 15534576,3728,2778,12, 9,44, 9,40,0x94,0,2,\"Canon\",\"PowerShot SX120 IS\" },",
          "15255:     { 18653760,4080,3048,24,12,24,12,40,0x94,0,2,\"Canon\",\"PowerShot SX20 IS\" },",
          "15256:     { 19131120,4168,3060,92,16, 4, 1,40,0x94,0,2,\"Canon\",\"PowerShot SX220 HS\" },",
          "15257:     { 21936096,4464,3276,25,10,73,12,40,0x16,0,2,\"Canon\",\"PowerShot SX30 IS\" },",
          "15258:     { 24724224,4704,3504, 8,16,56, 8,40,0x49,0,2,\"Canon\",\"PowerShot A3300 IS\" },",
          "15259:     { 30858240,5248,3920, 8,16,56,16,40,0x94,0,2,\"Canon\",\"IXUS 160\" },",
          "15260:     {  1976352,1632,1211, 0, 2, 0, 1, 0,0x94,0,1,\"Casio\",\"QV-2000UX\" },",
          "15261:     {  3217760,2080,1547, 0, 0,10, 1, 0,0x94,0,1,\"Casio\",\"QV-3*00EX\" },",
          "15262:     {  6218368,2585,1924, 0, 0, 9, 0, 0,0x94,0,1,\"Casio\",\"QV-5700\" },",
          "15263:     {  7816704,2867,2181, 0, 0,34,36, 0,0x16,0,1,\"Casio\",\"EX-Z60\" },",
          "15264:     {  2937856,1621,1208, 0, 0, 1, 0, 0,0x94,7,13,\"Casio\",\"EX-S20\" },",
          "15265:     {  4948608,2090,1578, 0, 0,32,34, 0,0x94,7,1,\"Casio\",\"EX-S100\" },",
          "15266:     {  6054400,2346,1720, 2, 0,32, 0, 0,0x94,7,1,\"Casio\",\"QV-R41\" },",
          "15267:     {  7426656,2568,1928, 0, 0, 0, 0, 0,0x94,0,1,\"Casio\",\"EX-P505\" },",
          "15268:     {  7530816,2602,1929, 0, 0,22, 0, 0,0x94,7,1,\"Casio\",\"QV-R51\" },",
          "15269:     {  7542528,2602,1932, 0, 0,32, 0, 0,0x94,7,1,\"Casio\",\"EX-Z50\" },",
          "15270:     {  7562048,2602,1937, 0, 0,25, 0, 0,0x16,7,1,\"Casio\",\"EX-Z500\" },",
          "15271:     {  7753344,2602,1986, 0, 0,32,26, 0,0x94,7,1,\"Casio\",\"EX-Z55\" },",
          "15272:     {  9313536,2858,2172, 0, 0,14,30, 0,0x94,7,1,\"Casio\",\"EX-P600\" },",
          "15273:     { 10834368,3114,2319, 0, 0,27, 0, 0,0x94,0,1,\"Casio\",\"EX-Z750\" },",
          "15274:     { 10843712,3114,2321, 0, 0,25, 0, 0,0x94,0,1,\"Casio\",\"EX-Z75\" },",
          "15275:     { 10979200,3114,2350, 0, 0,32,32, 0,0x94,7,1,\"Casio\",\"EX-P700\" },",
          "15276:     { 12310144,3285,2498, 0, 0, 6,30, 0,0x94,0,1,\"Casio\",\"EX-Z850\" },",
          "15277:     { 12489984,3328,2502, 0, 0,47,35, 0,0x94,0,1,\"Casio\",\"EX-Z8\" },",
          "15278:     { 15499264,3754,2752, 0, 0,82, 0, 0,0x94,0,1,\"Casio\",\"EX-Z1050\" },",
          "15279:     { 18702336,4096,3044, 0, 0,24, 0,80,0x94,7,1,\"Casio\",\"EX-ZR100\" },",
          "15280:     {  7684000,2260,1700, 0, 0, 0, 0,13,0x94,0,1,\"Casio\",\"QV-4000\" },",
          "15281:     {   787456,1024, 769, 0, 1, 0, 0, 0,0x49,0,0,\"Creative\",\"PC-CAM 600\" },",
          "15282:     { 28829184,4384,3288, 0, 0, 0, 0,36,0x61,0,0,\"DJI\" },",
          "15283:     { 15151104,4608,3288, 0, 0, 0, 0, 0,0x94,0,0,\"Matrix\" },",
          "15284:     {  3840000,1600,1200, 0, 0, 0, 0,65,0x49,0,0,\"Foculus\",\"531C\" },",
          "15285:     {   307200, 640, 480, 0, 0, 0, 0, 0,0x94,0,0,\"Generic\" },",
          "15286:     {    62464, 256, 244, 1, 1, 6, 1, 0,0x8d,0,0,\"Kodak\",\"DC20\" },",
          "15287:     {   124928, 512, 244, 1, 1,10, 1, 0,0x8d,0,0,\"Kodak\",\"DC20\" },",
          "15288:     {  1652736,1536,1076, 0,52, 0, 0, 0,0x61,0,0,\"Kodak\",\"DCS200\" },",
          "15289:     {  4159302,2338,1779, 1,33, 1, 2, 0,0x94,0,0,\"Kodak\",\"C330\" },",
          "15290:     {  4162462,2338,1779, 1,33, 1, 2, 0,0x94,0,0,\"Kodak\",\"C330\",3160 },",
          "15291:     {  2247168,1232, 912, 0, 0,16, 0, 0,0x00,0,0,\"Kodak\",\"C330\" },",
          "15292:     {  3370752,1232, 912, 0, 0,16, 0, 0,0x00,0,0,\"Kodak\",\"C330\" },",
          "15293:     {  6163328,2864,2152, 0, 0, 0, 0, 0,0x94,0,0,\"Kodak\",\"C603\" },",
          "15294:     {  6166488,2864,2152, 0, 0, 0, 0, 0,0x94,0,0,\"Kodak\",\"C603\",3160 },",
          "15295:     {   460800, 640, 480, 0, 0, 0, 0, 0,0x00,0,0,\"Kodak\",\"C603\" },",
          "15296:     {  9116448,2848,2134, 0, 0, 0, 0, 0,0x00,0,0,\"Kodak\",\"C603\" },",
          "15297:     { 12241200,4040,3030, 2, 0, 0,13, 0,0x49,0,0,\"Kodak\",\"12MP\" },",
          "15298:     { 12272756,4040,3030, 2, 0, 0,13, 0,0x49,0,0,\"Kodak\",\"12MP\",31556 },",
          "15299:     { 18000000,4000,3000, 0, 0, 0, 0, 0,0x00,0,0,\"Kodak\",\"12MP\" },",
          "15300:     {   614400, 640, 480, 0, 3, 0, 0,64,0x94,0,0,\"Kodak\",\"KAI-0340\" },",
          "15301:     { 15360000,3200,2400, 0, 0, 0, 0,96,0x16,0,0,\"Lenovo\",\"A820\" },",
          "15302:     {  3884928,1608,1207, 0, 0, 0, 0,96,0x16,0,0,\"Micron\",\"2010\",3212 },",
          "15303:     {  1138688,1534, 986, 0, 0, 0, 0, 0,0x61,0,0,\"Minolta\",\"RD175\",513 },",
          "15304:     {  1581060,1305, 969, 0, 0,18, 6, 6,0x1e,4,1,\"Nikon\",\"E900\" },",
          "15305:     {  2465792,1638,1204, 0, 0,22, 1, 6,0x4b,5,1,\"Nikon\",\"E950\" },",
          "15306:     {  2940928,1616,1213, 0, 0, 0, 7,30,0x94,0,1,\"Nikon\",\"E2100\" },",
          "15307:     {  4771840,2064,1541, 0, 0, 0, 1, 6,0xe1,0,1,\"Nikon\",\"E990\" },",
          "15308:     {  4775936,2064,1542, 0, 0, 0, 0,30,0x94,0,1,\"Nikon\",\"E3700\" },",
          "15309:     {  5865472,2288,1709, 0, 0, 0, 1, 6,0xb4,0,1,\"Nikon\",\"E4500\" },",
          "15310:     {  5869568,2288,1710, 0, 0, 0, 0, 6,0x16,0,1,\"Nikon\",\"E4300\" },",
          "15311:     {  7438336,2576,1925, 0, 0, 0, 1, 6,0xb4,0,1,\"Nikon\",\"E5000\" },",
          "15312:     {  8998912,2832,2118, 0, 0, 0, 0,30,0x94,7,1,\"Nikon\",\"COOLPIX S6\" },",
          "15313:     {  5939200,2304,1718, 0, 0, 0, 0,30,0x16,0,0,\"Olympus\",\"C770UZ\" },",
          "15314:     {  3178560,2064,1540, 0, 0, 0, 0, 0,0x94,0,1,\"Pentax\",\"Optio S\" },",
          "15315:     {  4841984,2090,1544, 0, 0,22, 0, 0,0x94,7,1,\"Pentax\",\"Optio S\" },",
          "15316:     {  6114240,2346,1737, 0, 0,22, 0, 0,0x94,7,1,\"Pentax\",\"Optio S4\" },",
          "15317:     { 10702848,3072,2322, 0, 0, 0,21,30,0x94,0,1,\"Pentax\",\"Optio 750Z\" },",
          "15318:     {  4147200,1920,1080, 0, 0, 0, 0, 0,0x49,0,0,\"Photron\",\"BC2-HD\" },",
          "15319:     {  4151666,1920,1080, 0, 0, 0, 0, 0,0x49,0,0,\"Photron\",\"BC2-HD\",8 },",
          "15320:     { 13248000,2208,3000, 0, 0, 0, 0,13,0x61,0,0,\"Pixelink\",\"A782\" },",
          "15321:     {  6291456,2048,1536, 0, 0, 0, 0,96,0x61,0,0,\"RoverShot\",\"3320AF\" },",
          "15322:     {   311696, 644, 484, 0, 0, 0, 0, 0,0x16,0,8,\"ST Micro\",\"STV680 VGA\" },",
          "15323:     { 16098048,3288,2448, 0, 0,24, 0, 9,0x94,0,1,\"Samsung\",\"S85\" },",
          "15324:     { 16215552,3312,2448, 0, 0,48, 0, 9,0x94,0,1,\"Samsung\",\"S85\" },",
          "15325:     { 20487168,3648,2808, 0, 0, 0, 0,13,0x94,5,1,\"Samsung\",\"WB550\" },",
          "15326:     { 24000000,4000,3000, 0, 0, 0, 0,13,0x94,5,1,\"Samsung\",\"WB550\" },",
          "15327:     { 12582980,3072,2048, 0, 0, 0, 0,33,0x61,0,0,\"Sinar\",\"\",68 },",
          "15328:     { 33292868,4080,4080, 0, 0, 0, 0,33,0x61,0,0,\"Sinar\",\"\",68 },",
          "15329:     { 44390468,4080,5440, 0, 0, 0, 0,33,0x61,0,0,\"Sinar\",\"\",68 },",
          "15330:     {  1409024,1376,1024, 0, 0, 1, 0, 0,0x49,0,0,\"Sony\",\"XCD-SX910CR\" },",
          "15331:     {  2818048,1376,1024, 0, 0, 1, 0,97,0x49,0,0,\"Sony\",\"XCD-SX910CR\" },",
          "15332:   };",
          "15333: #ifdef LIBRAW_LIBRARY_BUILD",
          "15334:     libraw_custom_camera_t",
          "15335:       table[64 + sizeof(const_table)/sizeof(const_table[0])];",
          "15336: #endif",
          "15338:   static const char *corp[] =",
          "15339:     { \"AgfaPhoto\", \"Canon\", \"Casio\", \"Epson\", \"Fujifilm\",",
          "15340:       \"Mamiya\", \"Minolta\", \"Motorola\", \"Kodak\", \"Konica\", \"Leica\",",
          "15341:       \"Nikon\", \"Nokia\", \"Olympus\", \"Pentax\", \"Phase One\", \"Ricoh\",",
          "15342:       \"Samsung\", \"Sigma\", \"Sinar\", \"Sony\" };",
          "15348:   int hlen, flen, fsize, zero_fsize=1, i, c;",
          "15352:   unsigned camera_count = parse_custom_cameras(64,table,imgdata.params.custom_camera_strings);",
          "15353:   for(int q = 0; q < sizeof(const_table)/sizeof(const_table[0]); q++)",
          "15354:  memmove(&table[q+camera_count],&const_table[q],sizeof(const_table[0]));",
          "15355:   camera_count += sizeof(const_table)/sizeof(const_table[0]);",
          "15364:   memset (tiff_ifd, 0, sizeof tiff_ifd);",
          "15365:   memset (gpsdata, 0, sizeof gpsdata);",
          "15366:   memset (cblack, 0, sizeof cblack);",
          "15367:   memset (white, 0, sizeof white);",
          "15368:   memset (mask, 0, sizeof mask);",
          "",
          "[Added Lines]",
          "16201:       {3130, 1743, 4, 0, -6, 0},    {3130, 2055, 4, 0, -6, 0},      {3130, 2319, 4, 0, -6, 0},",
          "16202:       {3170, 2103, 18, 0, -42, 20}, {3170, 2367, 18, 13, -42, -21}, {3177, 2367, 0, 0, -1, 0},",
          "16203:       {3304, 2458, 0, 0, -1, 0},    {3330, 2463, 9, 0, -5, 0},      {3330, 2479, 9, 0, -17, 4},",
          "16204:       {3370, 1899, 15, 0, -44, 20}, {3370, 2235, 15, 0, -44, 20},   {3370, 2511, 15, 10, -44, -21},",
          "16205:       {3690, 2751, 3, 0, -8, -3},   {3710, 2751, 0, 0, -3, 0},      {3724, 2450, 0, 0, 0, -2},",
          "16206:       {3770, 2487, 17, 0, -44, 19}, {3770, 2799, 17, 15, -44, -19}, {3880, 2170, 6, 0, -6, 0},",
          "16207:       {4060, 3018, 0, 0, 0, -2},    {4290, 2391, 3, 0, -8, -1},     {4330, 2439, 17, 15, -44, -19},",
          "16208:       {4508, 2962, 0, 0, -3, -4},   {4508, 3330, 0, 0, -3, -6},",
          "16211:       {1944, 1416, 0, 0, 48, 0},",
          "16212:       {2144, 1560, 4, 8, 52, 2, 0, 0, 0, 25},",
          "16213:       {2224, 1456, 48, 6, 0, 2},",
          "16214:       {2376, 1728, 12, 6, 52, 2},",
          "16215:       {2672, 1968, 12, 6, 44, 2},",
          "16216:       {3152, 2068, 64, 12, 0, 0, 16},",
          "16217:       {3160, 2344, 44, 12, 4, 4},",
          "16218:       {3344, 2484, 4, 6, 52, 6},",
          "16219:       {3516, 2328, 42, 14, 0, 0},",
          "16220:       {3596, 2360, 74, 12, 0, 0},",
          "16221:       {3744, 2784, 52, 12, 8, 12},",
          "16222:       {3944, 2622, 30, 18, 6, 2},",
          "16223:       {3948, 2622, 42, 18, 0, 2},",
          "16224:       {3984, 2622, 76, 20, 0, 2, 14},",
          "16225:       {4104, 3048, 48, 12, 24, 12},",
          "16226:       {4116, 2178, 4, 2, 0, 0},",
          "16227:       {4152, 2772, 192, 12, 0, 0},",
          "16228:       {4160, 3124, 104, 11, 8, 65},",
          "16229:       {4176, 3062, 96, 17, 8, 0, 0, 16, 0, 7, 0x49},",
          "16230:       {4192, 3062, 96, 17, 24, 0, 0, 16, 0, 0, 0x49},",
          "16231:       {4312, 2876, 22, 18, 0, 2},",
          "16232:       {4352, 2874, 62, 18, 0, 0},",
          "16233:       {4476, 2954, 90, 34, 0, 0},",
          "16234:       {4480, 3348, 12, 10, 36, 12, 0, 0, 0, 18, 0x49},",
          "16235:       {4480, 3366, 80, 50, 0, 0},",
          "16236:       {4496, 3366, 80, 50, 12, 0},",
          "16237:       {4768, 3516, 96, 16, 0, 0, 0, 16},",
          "16238:       {4832, 3204, 62, 26, 0, 0},",
          "16239:       {4832, 3228, 62, 51, 0, 0},",
          "16240:       {5108, 3349, 98, 13, 0, 0},",
          "16241:       {5120, 3318, 142, 45, 62, 0},",
          "16243:       {5344, 3516, 142, 51, 0, 0},",
          "16244:       {5344, 3584, 126, 100, 0, 2},",
          "16245:       {5360, 3516, 158, 51, 0, 0},",
          "16246:       {5568, 3708, 72, 38, 0, 0},",
          "16247:       {5632, 3710, 96, 17, 0, 0, 0, 16, 0, 0, 0x49},",
          "16248:       {5712, 3774, 62, 20, 10, 2},",
          "16249:       {5792, 3804, 158, 51, 0, 0},",
          "16250:       {5920, 3950, 122, 80, 2, 0},",
          "16254:       {8896, 5920, 160, 64, 0, 0},",
          "16256:   static const struct",
          "16257:   {",
          "16260:   } unique[] =",
          "16261:       {",
          "16262:           {0x001, \"EOS-1D\"},",
          "16263:           {0x167, \"EOS-1DS\"},",
          "16264:           {0x168, \"EOS 10D\"},",
          "16265:           {0x169, \"EOS-1D Mark III\"},",
          "16266:           {0x170, \"EOS 300D\"},",
          "16267:           {0x174, \"EOS-1D Mark II\"},",
          "16268:           {0x175, \"EOS 20D\"},",
          "16269:           {0x176, \"EOS 450D\"},",
          "16270:           {0x188, \"EOS-1Ds Mark II\"},",
          "16271:           {0x189, \"EOS 350D\"},",
          "16272:           {0x190, \"EOS 40D\"},",
          "16273:           {0x213, \"EOS 5D\"},",
          "16274:           {0x215, \"EOS-1Ds Mark III\"},",
          "16275:           {0x218, \"EOS 5D Mark II\"},",
          "16276:           {0x232, \"EOS-1D Mark II N\"},",
          "16277:           {0x234, \"EOS 30D\"},",
          "16278:           {0x236, \"EOS 400D\"},",
          "16279:           {0x250, \"EOS 7D\"},",
          "16280:           {0x252, \"EOS 500D\"},",
          "16281:           {0x254, \"EOS 1000D\"},",
          "16282:           {0x261, \"EOS 50D\"},",
          "16283:           {0x269, \"EOS-1D X\"},",
          "16284:           {0x270, \"EOS 550D\"},",
          "16285:           {0x281, \"EOS-1D Mark IV\"},",
          "16286:           {0x285, \"EOS 5D Mark III\"},",
          "16287:           {0x286, \"EOS 600D\"},",
          "16288:           {0x287, \"EOS 60D\"},",
          "16289:           {0x288, \"EOS 1100D\"},",
          "16290:           {0x289, \"EOS 7D Mark II\"},",
          "16291:           {0x301, \"EOS 650D\"},",
          "16292:           {0x302, \"EOS 6D\"},",
          "16293:           {0x324, \"EOS-1D C\"},",
          "16294:           {0x325, \"EOS 70D\"},",
          "16295:           {0x326, \"EOS 700D\"},",
          "16296:           {0x327, \"EOS 1200D\"},",
          "16297:           {0x328, \"EOS-1D X Mark II\"},",
          "16298:           {0x331, \"EOS M\"},",
          "16299:           {0x335, \"EOS M2\"},",
          "16303:           {0x346, \"EOS 100D\"},",
          "16304:           {0x347, \"EOS 760D\"},",
          "16305:           {0x349, \"EOS 5D Mark IV\"},",
          "16306:           {0x350, \"EOS 80D\"},",
          "16307:           {0x382, \"EOS 5DS\"},",
          "16308:           {0x393, \"EOS 750D\"},",
          "16309:           {0x401, \"EOS 5DS R\"},",
          "16310:           {0x404, \"EOS 1300D\"},",
          "16311:       },",
          "16312:     sonique[] = {",
          "16313:         {0x002, \"DSC-R1\"},      {0x100, \"DSLR-A100\"},   {0x101, \"DSLR-A900\"},  {0x102, \"DSLR-A700\"},",
          "16314:         {0x103, \"DSLR-A200\"},   {0x104, \"DSLR-A350\"},   {0x105, \"DSLR-A300\"},  {0x106, \"DSLR-A900\"},",
          "16315:         {0x107, \"DSLR-A380\"},   {0x108, \"DSLR-A330\"},   {0x109, \"DSLR-A230\"},  {0x10a, \"DSLR-A290\"},",
          "16316:         {0x10d, \"DSLR-A850\"},   {0x10e, \"DSLR-A850\"},   {0x111, \"DSLR-A550\"},  {0x112, \"DSLR-A500\"},",
          "16317:         {0x113, \"DSLR-A450\"},   {0x116, \"NEX-5\"},       {0x117, \"NEX-3\"},      {0x118, \"SLT-A33\"},",
          "16318:         {0x119, \"SLT-A55V\"},    {0x11a, \"DSLR-A560\"},   {0x11b, \"DSLR-A580\"},  {0x11c, \"NEX-C3\"},",
          "16319:         {0x11d, \"SLT-A35\"},     {0x11e, \"SLT-A65V\"},    {0x11f, \"SLT-A77V\"},   {0x120, \"NEX-5N\"},",
          "16320:         {0x121, \"NEX-7\"},       {0x122, \"NEX-VG20E\"},   {0x123, \"SLT-A37\"},    {0x124, \"SLT-A57\"},",
          "16321:         {0x125, \"NEX-F3\"},      {0x126, \"SLT-A99V\"},    {0x127, \"NEX-6\"},      {0x128, \"NEX-5R\"},",
          "16322:         {0x129, \"DSC-RX100\"},   {0x12a, \"DSC-RX1\"},     {0x12b, \"NEX-VG900\"},  {0x12c, \"NEX-VG30E\"},",
          "16323:         {0x12e, \"ILCE-3000\"},   {0x12f, \"SLT-A58\"},     {0x131, \"NEX-3N\"},     {0x132, \"ILCE-7\"},",
          "16324:         {0x133, \"NEX-5T\"},      {0x134, \"DSC-RX100M2\"}, {0x135, \"DSC-RX10\"},   {0x136, \"DSC-RX1R\"},",
          "16325:         {0x137, \"ILCE-7R\"},     {0x138, \"ILCE-6000\"},   {0x139, \"ILCE-5000\"},  {0x13d, \"DSC-RX100M3\"},",
          "16326:         {0x13e, \"ILCE-7S\"},     {0x13f, \"ILCA-77M2\"},   {0x153, \"ILCE-5100\"},  {0x154, \"ILCE-7M2\"},",
          "16327:         {0x155, \"DSC-RX100M4\"}, {0x156, \"DSC-RX10M2\"},  {0x158, \"DSC-RX1RM2\"}, {0x15a, \"ILCE-QX1\"},",
          "16328:         {0x15b, \"ILCE-7RM2\"},   {0x15e, \"ILCE-7SM2\"},   {0x161, \"ILCA-68\"},    {0x162, \"ILCA-99M2\"},",
          "16329:         {0x163, \"DSC-RX10M3\"},  {0x164, \"DSC-RX100M5\"}, {0x165, \"ILCE-6300\"},  {0x168, \"ILCE-6500\"},",
          "16330:     };",
          "16332: #ifdef LIBRAW_LIBRARY_BUILD",
          "16333:   static const libraw_custom_camera_t const_table[]",
          "16335:   static const struct",
          "16336:   {",
          "16342:   } table[]",
          "16343: #endif",
          "16344:       = {",
          "16345:           {786432, 1024, 768, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-080C\"},",
          "16346:           {1447680, 1392, 1040, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-145C\"},",
          "16347:           {1920000, 1600, 1200, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-201C\"},",
          "16348:           {5067304, 2588, 1958, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-510C\"},",
          "16349:           {5067316, 2588, 1958, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-510C\", 12},",
          "16350:           {10134608, 2588, 1958, 0, 0, 0, 0, 9, 0x94, 0, 0, \"AVT\", \"F-510C\"},",
          "16351:           {10134620, 2588, 1958, 0, 0, 0, 0, 9, 0x94, 0, 0, \"AVT\", \"F-510C\", 12},",
          "16352:           {16157136, 3272, 2469, 0, 0, 0, 0, 9, 0x94, 0, 0, \"AVT\", \"F-810C\"},",
          "16353:           {15980544, 3264, 2448, 0, 0, 0, 0, 8, 0x61, 0, 1, \"AgfaPhoto\", \"DC-833m\"},",
          "16354:           {9631728, 2532, 1902, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Alcatel\", \"5035D\"},",
          "16355:           {31850496, 4608, 3456, 0, 0, 0, 0, 0, 0x94, 0, 0, \"GITUP\", \"GIT2 4:3\"},",
          "16356:           {23887872, 4608, 2592, 0, 0, 0, 0, 0, 0x94, 0, 0, \"GITUP\", \"GIT2 16:9\"},",
          "16359:           {1540857, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"Samsung\", \"S3\"},",
          "16360:           {2658304, 1212, 1096, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3FrontMipi\"},",
          "16361:           {2842624, 1296, 1096, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3FrontQCOM\"},",
          "16362:           {2969600, 1976, 1200, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Xiaomi\", \"MI3wMipi\"},",
          "16363:           {3170304, 1976, 1200, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Xiaomi\", \"MI3wQCOM\"},",
          "16364:           {3763584, 1584, 1184, 0, 0, 0, 0, 96, 0x61, 0, 0, \"I_Mobile\", \"I_StyleQ6\"},",
          "16365:           {5107712, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"UltraPixel1\"},",
          "16366:           {5382640, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"UltraPixel2\"},",
          "16367:           {5664912, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"4688\"},",
          "16368:           {5664912, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"4688\"},",
          "16369:           {5364240, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"4688\"},",
          "16370:           {6299648, 2592, 1944, 0, 0, 0, 0, 1, 0x16, 0, 0, \"OmniVisi\", \"OV5648\"},",
          "16371:           {6721536, 2592, 1944, 0, 0, 0, 0, 0, 0x16, 0, 0, \"OmniVisi\", \"OV56482\"},",
          "16372:           {6746112, 2592, 1944, 0, 0, 0, 0, 0, 0x16, 0, 0, \"HTC\", \"OneSV\"},",
          "16373:           {9631728, 2532, 1902, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Sony\", \"5mp\"},",
          "16374:           {9830400, 2560, 1920, 0, 0, 0, 0, 96, 0x61, 0, 0, \"NGM\", \"ForwardArt\"},",
          "16375:           {10186752, 3264, 2448, 0, 0, 0, 0, 1, 0x94, 0, 0, \"Sony\", \"IMX219-mipi 8mp\"},",
          "16376:           {10223360, 2608, 1944, 0, 0, 0, 0, 96, 0x16, 0, 0, \"Sony\", \"IMX\"},",
          "16377:           {10782464, 3282, 2448, 0, 0, 0, 0, 0, 0x16, 0, 0, \"HTC\", \"MyTouch4GSlide\"},",
          "16378:           {10788864, 3282, 2448, 0, 0, 0, 0, 0, 0x16, 0, 0, \"Xperia\", \"L\"},",
          "16379:           {15967488, 3264, 2446, 0, 0, 0, 0, 96, 0x16, 0, 0, \"OmniVison\", \"OV8850\"},",
          "16380:           {16224256, 4208, 3082, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3MipiL\"},",
          "16381:           {16424960, 4208, 3120, 0, 0, 0, 0, 1, 0x16, 0, 0, \"IMX135\", \"MipiL\"},",
          "16382:           {17326080, 4164, 3120, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3LQCom\"},",
          "16383:           {17522688, 4212, 3120, 0, 0, 0, 0, 0, 0x16, 0, 0, \"Sony\", \"IMX135-QCOM\"},",
          "16384:           {19906560, 4608, 3456, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Gione\", \"E7mipi\"},",
          "16385:           {19976192, 5312, 2988, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G4\"},",
          "16386:           {20389888, 4632, 3480, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Xiaomi\", \"RedmiNote3Pro\"},",
          "16387:           {20500480, 4656, 3496, 0, 0, 0, 0, 1, 0x94, 0, 0, \"Sony\", \"IMX298-mipi 16mp\"},",
          "16388:           {21233664, 4608, 3456, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Gione\", \"E7qcom\"},",
          "16389:           {26023936, 4192, 3104, 0, 0, 0, 0, 96, 0x94, 0, 0, \"THL\", \"5000\"},",
          "16390:           {26257920, 4208, 3120, 0, 0, 0, 0, 96, 0x94, 0, 0, \"Sony\", \"IMX214\"},",
          "16391:           {26357760, 4224, 3120, 0, 0, 0, 0, 96, 0x61, 0, 0, \"OV\", \"13860\"},",
          "16392:           {41312256, 5248, 3936, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Meizu\", \"MX4\"},",
          "16393:           {42923008, 5344, 4016, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Sony\", \"IMX230\"},",
          "16395:           {20137344, 3664, 2748, 0, 0, 0, 0, 0x40, 0x49, 0, 0, \"Aptina\", \"MT9J003\", 0xffff},",
          "16396:           {2868726, 1384, 1036, 0, 0, 0, 0, 64, 0x49, 0, 8, \"Baumer\", \"TXG14\", 1078},",
          "16397:           {5298000, 2400, 1766, 12, 12, 44, 2, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SD300\"},",
          "16398:           {6553440, 2664, 1968, 4, 4, 44, 4, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A460\"},",
          "16399:           {6573120, 2672, 1968, 12, 8, 44, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A610\"},",
          "16400:           {6653280, 2672, 1992, 10, 6, 42, 2, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A530\"},",
          "16401:           {7710960, 2888, 2136, 44, 8, 4, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot S3 IS\"},",
          "16402:           {9219600, 3152, 2340, 36, 12, 4, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A620\"},",
          "16403:           {9243240, 3152, 2346, 12, 7, 44, 13, 40, 0x49, 0, 2, \"Canon\", \"PowerShot A470\"},",
          "16404:           {10341600, 3336, 2480, 6, 5, 32, 3, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A720 IS\"},",
          "16405:           {10383120, 3344, 2484, 12, 6, 44, 6, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A630\"},",
          "16406:           {12945240, 3736, 2772, 12, 6, 52, 6, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A640\"},",
          "16407:           {15636240, 4104, 3048, 48, 12, 24, 12, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A650\"},",
          "16408:           {15467760, 3720, 2772, 6, 12, 30, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX110 IS\"},",
          "16409:           {15534576, 3728, 2778, 12, 9, 44, 9, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX120 IS\"},",
          "16410:           {18653760, 4080, 3048, 24, 12, 24, 12, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX20 IS\"},",
          "16411:           {19131120, 4168, 3060, 92, 16, 4, 1, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX220 HS\"},",
          "16412:           {21936096, 4464, 3276, 25, 10, 73, 12, 40, 0x16, 0, 2, \"Canon\", \"PowerShot SX30 IS\"},",
          "16413:           {24724224, 4704, 3504, 8, 16, 56, 8, 40, 0x49, 0, 2, \"Canon\", \"PowerShot A3300 IS\"},",
          "16414:           {30858240, 5248, 3920, 8, 16, 56, 16, 40, 0x94, 0, 2, \"Canon\", \"IXUS 160\"},",
          "16415:           {1976352, 1632, 1211, 0, 2, 0, 1, 0, 0x94, 0, 1, \"Casio\", \"QV-2000UX\"},",
          "16416:           {3217760, 2080, 1547, 0, 0, 10, 1, 0, 0x94, 0, 1, \"Casio\", \"QV-3*00EX\"},",
          "16417:           {6218368, 2585, 1924, 0, 0, 9, 0, 0, 0x94, 0, 1, \"Casio\", \"QV-5700\"},",
          "16418:           {7816704, 2867, 2181, 0, 0, 34, 36, 0, 0x16, 0, 1, \"Casio\", \"EX-Z60\"},",
          "16419:           {2937856, 1621, 1208, 0, 0, 1, 0, 0, 0x94, 7, 13, \"Casio\", \"EX-S20\"},",
          "16420:           {4948608, 2090, 1578, 0, 0, 32, 34, 0, 0x94, 7, 1, \"Casio\", \"EX-S100\"},",
          "16421:           {6054400, 2346, 1720, 2, 0, 32, 0, 0, 0x94, 7, 1, \"Casio\", \"QV-R41\"},",
          "16422:           {7426656, 2568, 1928, 0, 0, 0, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-P505\"},",
          "16423:           {7530816, 2602, 1929, 0, 0, 22, 0, 0, 0x94, 7, 1, \"Casio\", \"QV-R51\"},",
          "16424:           {7542528, 2602, 1932, 0, 0, 32, 0, 0, 0x94, 7, 1, \"Casio\", \"EX-Z50\"},",
          "16425:           {7562048, 2602, 1937, 0, 0, 25, 0, 0, 0x16, 7, 1, \"Casio\", \"EX-Z500\"},",
          "16426:           {7753344, 2602, 1986, 0, 0, 32, 26, 0, 0x94, 7, 1, \"Casio\", \"EX-Z55\"},",
          "16427:           {9313536, 2858, 2172, 0, 0, 14, 30, 0, 0x94, 7, 1, \"Casio\", \"EX-P600\"},",
          "16428:           {10834368, 3114, 2319, 0, 0, 27, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-Z750\"},",
          "16429:           {10843712, 3114, 2321, 0, 0, 25, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-Z75\"},",
          "16430:           {10979200, 3114, 2350, 0, 0, 32, 32, 0, 0x94, 7, 1, \"Casio\", \"EX-P700\"},",
          "16431:           {12310144, 3285, 2498, 0, 0, 6, 30, 0, 0x94, 0, 1, \"Casio\", \"EX-Z850\"},",
          "16432:           {12489984, 3328, 2502, 0, 0, 47, 35, 0, 0x94, 0, 1, \"Casio\", \"EX-Z8\"},",
          "16433:           {15499264, 3754, 2752, 0, 0, 82, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-Z1050\"},",
          "16434:           {18702336, 4096, 3044, 0, 0, 24, 0, 80, 0x94, 7, 1, \"Casio\", \"EX-ZR100\"},",
          "16435:           {7684000, 2260, 1700, 0, 0, 0, 0, 13, 0x94, 0, 1, \"Casio\", \"QV-4000\"},",
          "16436:           {787456, 1024, 769, 0, 1, 0, 0, 0, 0x49, 0, 0, \"Creative\", \"PC-CAM 600\"},",
          "16437:           {28829184, 4384, 3288, 0, 0, 0, 0, 36, 0x61, 0, 0, \"DJI\"},",
          "16438:           {15151104, 4608, 3288, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Matrix\"},",
          "16439:           {3840000, 1600, 1200, 0, 0, 0, 0, 65, 0x49, 0, 0, \"Foculus\", \"531C\"},",
          "16440:           {307200, 640, 480, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Generic\"},",
          "16441:           {62464, 256, 244, 1, 1, 6, 1, 0, 0x8d, 0, 0, \"Kodak\", \"DC20\"},",
          "16442:           {124928, 512, 244, 1, 1, 10, 1, 0, 0x8d, 0, 0, \"Kodak\", \"DC20\"},",
          "16443:           {1652736, 1536, 1076, 0, 52, 0, 0, 0, 0x61, 0, 0, \"Kodak\", \"DCS200\"},",
          "16444:           {4159302, 2338, 1779, 1, 33, 1, 2, 0, 0x94, 0, 0, \"Kodak\", \"C330\"},",
          "16445:           {4162462, 2338, 1779, 1, 33, 1, 2, 0, 0x94, 0, 0, \"Kodak\", \"C330\", 3160},",
          "16446:           {2247168, 1232, 912, 0, 0, 16, 0, 0, 0x00, 0, 0, \"Kodak\", \"C330\"},",
          "16447:           {3370752, 1232, 912, 0, 0, 16, 0, 0, 0x00, 0, 0, \"Kodak\", \"C330\"},",
          "16448:           {6163328, 2864, 2152, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Kodak\", \"C603\"},",
          "16449:           {6166488, 2864, 2152, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Kodak\", \"C603\", 3160},",
          "16450:           {460800, 640, 480, 0, 0, 0, 0, 0, 0x00, 0, 0, \"Kodak\", \"C603\"},",
          "16451:           {9116448, 2848, 2134, 0, 0, 0, 0, 0, 0x00, 0, 0, \"Kodak\", \"C603\"},",
          "16452:           {12241200, 4040, 3030, 2, 0, 0, 13, 0, 0x49, 0, 0, \"Kodak\", \"12MP\"},",
          "16453:           {12272756, 4040, 3030, 2, 0, 0, 13, 0, 0x49, 0, 0, \"Kodak\", \"12MP\", 31556},",
          "16454:           {18000000, 4000, 3000, 0, 0, 0, 0, 0, 0x00, 0, 0, \"Kodak\", \"12MP\"},",
          "16455:           {614400, 640, 480, 0, 3, 0, 0, 64, 0x94, 0, 0, \"Kodak\", \"KAI-0340\"},",
          "16456:           {15360000, 3200, 2400, 0, 0, 0, 0, 96, 0x16, 0, 0, \"Lenovo\", \"A820\"},",
          "16457:           {3884928, 1608, 1207, 0, 0, 0, 0, 96, 0x16, 0, 0, \"Micron\", \"2010\", 3212},",
          "16458:           {1138688, 1534, 986, 0, 0, 0, 0, 0, 0x61, 0, 0, \"Minolta\", \"RD175\", 513},",
          "16459:           {1581060, 1305, 969, 0, 0, 18, 6, 6, 0x1e, 4, 1, \"Nikon\", \"E900\"},",
          "16460:           {2465792, 1638, 1204, 0, 0, 22, 1, 6, 0x4b, 5, 1, \"Nikon\", \"E950\"},",
          "16461:           {2940928, 1616, 1213, 0, 0, 0, 7, 30, 0x94, 0, 1, \"Nikon\", \"E2100\"},",
          "16462:           {4771840, 2064, 1541, 0, 0, 0, 1, 6, 0xe1, 0, 1, \"Nikon\", \"E990\"},",
          "16463:           {4775936, 2064, 1542, 0, 0, 0, 0, 30, 0x94, 0, 1, \"Nikon\", \"E3700\"},",
          "16464:           {5865472, 2288, 1709, 0, 0, 0, 1, 6, 0xb4, 0, 1, \"Nikon\", \"E4500\"},",
          "16465:           {5869568, 2288, 1710, 0, 0, 0, 0, 6, 0x16, 0, 1, \"Nikon\", \"E4300\"},",
          "16466:           {7438336, 2576, 1925, 0, 0, 0, 1, 6, 0xb4, 0, 1, \"Nikon\", \"E5000\"},",
          "16467:           {8998912, 2832, 2118, 0, 0, 0, 0, 30, 0x94, 7, 1, \"Nikon\", \"COOLPIX S6\"},",
          "16468:           {5939200, 2304, 1718, 0, 0, 0, 0, 30, 0x16, 0, 0, \"Olympus\", \"C770UZ\"},",
          "16469:           {3178560, 2064, 1540, 0, 0, 0, 0, 0, 0x94, 0, 1, \"Pentax\", \"Optio S\"},",
          "16470:           {4841984, 2090, 1544, 0, 0, 22, 0, 0, 0x94, 7, 1, \"Pentax\", \"Optio S\"},",
          "16471:           {6114240, 2346, 1737, 0, 0, 22, 0, 0, 0x94, 7, 1, \"Pentax\", \"Optio S4\"},",
          "16472:           {10702848, 3072, 2322, 0, 0, 0, 21, 30, 0x94, 0, 1, \"Pentax\", \"Optio 750Z\"},",
          "16473:           {4147200, 1920, 1080, 0, 0, 0, 0, 0, 0x49, 0, 0, \"Photron\", \"BC2-HD\"},",
          "16474:           {4151666, 1920, 1080, 0, 0, 0, 0, 0, 0x49, 0, 0, \"Photron\", \"BC2-HD\", 8},",
          "16475:           {13248000, 2208, 3000, 0, 0, 0, 0, 13, 0x61, 0, 0, \"Pixelink\", \"A782\"},",
          "16476:           {6291456, 2048, 1536, 0, 0, 0, 0, 96, 0x61, 0, 0, \"RoverShot\", \"3320AF\"},",
          "16477:           {311696, 644, 484, 0, 0, 0, 0, 0, 0x16, 0, 8, \"ST Micro\", \"STV680 VGA\"},",
          "16478:           {16098048, 3288, 2448, 0, 0, 24, 0, 9, 0x94, 0, 1, \"Samsung\", \"S85\"},",
          "16479:           {16215552, 3312, 2448, 0, 0, 48, 0, 9, 0x94, 0, 1, \"Samsung\", \"S85\"},",
          "16480:           {20487168, 3648, 2808, 0, 0, 0, 0, 13, 0x94, 5, 1, \"Samsung\", \"WB550\"},",
          "16481:           {24000000, 4000, 3000, 0, 0, 0, 0, 13, 0x94, 5, 1, \"Samsung\", \"WB550\"},",
          "16482:           {12582980, 3072, 2048, 0, 0, 0, 0, 33, 0x61, 0, 0, \"Sinar\", \"\", 68},",
          "16483:           {33292868, 4080, 4080, 0, 0, 0, 0, 33, 0x61, 0, 0, \"Sinar\", \"\", 68},",
          "16484:           {44390468, 4080, 5440, 0, 0, 0, 0, 33, 0x61, 0, 0, \"Sinar\", \"\", 68},",
          "16485:           {1409024, 1376, 1024, 0, 0, 1, 0, 0, 0x49, 0, 0, \"Sony\", \"XCD-SX910CR\"},",
          "16486:           {2818048, 1376, 1024, 0, 0, 1, 0, 97, 0x49, 0, 0, \"Sony\", \"XCD-SX910CR\"},",
          "16487:       };",
          "16488: #ifdef LIBRAW_LIBRARY_BUILD",
          "16489:   libraw_custom_camera_t table[64 + sizeof(const_table) / sizeof(const_table[0])];",
          "16490: #endif",
          "16492:   static const char *corp[] = {\"AgfaPhoto\", \"Canon\",     \"Casio\",  \"Epson\",   \"Fujifilm\", \"Mamiya\", \"Minolta\",",
          "16493:                                \"Motorola\",  \"Kodak\",     \"Konica\", \"Leica\",   \"Nikon\",    \"Nokia\",  \"Olympus\",",
          "16494:                                \"Pentax\",    \"Phase One\", \"Ricoh\",  \"Samsung\", \"Sigma\",    \"Sinar\",  \"Sony\"};",
          "16500:   int hlen, flen, fsize, zero_fsize = 1, i, c;",
          "16504:   unsigned camera_count = parse_custom_cameras(64, table, imgdata.params.custom_camera_strings);",
          "16505:   for (int q = 0; q < sizeof(const_table) / sizeof(const_table[0]); q++)",
          "16506:     memmove(&table[q + camera_count], &const_table[q], sizeof(const_table[0]));",
          "16507:   camera_count += sizeof(const_table) / sizeof(const_table[0]);",
          "16516:   memset(tiff_ifd, 0, sizeof tiff_ifd);",
          "16517:   memset(gpsdata, 0, sizeof gpsdata);",
          "16518:   memset(cblack, 0, sizeof cblack);",
          "16519:   memset(white, 0, sizeof white);",
          "16520:   memset(mask, 0, sizeof mask);",
          "",
          "---------------",
          "--- Hunk 116 ---",
          "[Context before]",
          "15376:   pixel_aspect = is_raw = raw_color = 1;",
          "15377:   tile_width = tile_length = 0;",
          "15381:     cam_mul[i] = i == 1;",
          "15382:     pre_mul[i] = i < 3;",
          "15383:     FORC3 cmatrix[c][i] = 0;",
          "15384:     FORC3 rgb_cam[c][i] = c == i;",
          "15385:   }",
          "15386:   colors = 3;",
          "15389:   order = get2();",
          "15390:   hlen = get4();",
          "15392: #ifdef LIBRAW_LIBRARY_BUILD",
          "15394:   libraw_internal_data.unpacker_data.lenRAFData = libraw_internal_data.unpacker_data.posRAFData = 0;",
          "15395: #else",
          "15397: #endif",
          "15399:   flen = fsize = ftell(ifp);",
          "15406:       data_offset = hlen;",
          "15407: #ifdef LIBRAW_LIBRARY_BUILD",
          "15408:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "15409:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "15410: #endif",
          "15412:       load_raw = &CLASS canon_load_raw;",
          "15417:     data_offset = 4 + get2();",
          "15419:     if (fgetc(ifp) != 0xff)",
          "15420:       parse_tiff(12);",
          "15421:     thumb_offset = 0;",
          "15426:     get_timestamp(1);",
          "15444:     FORC4 cam_mul[c ^ (c >> 1)] = get4();",
          "15448:     focal_len = get4();",
          "15449: #ifdef LIBRAW_LIBRARY_BUILD",
          "15453:     stmread(imgdata.lens.makernotes.Lens, 32, ifp);",
          "15454:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Contax_N;",
          "15455:     if (imgdata.lens.makernotes.Lens[0])",
          "15456:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Contax_N;",
          "15457: #endif",
          "15464:     load_raw = &CLASS quicktake_100_load_raw;",
          "15468:     load_raw = &CLASS kodak_radc_load_raw;",
          "15470: #ifdef LIBRAW_LIBRARY_BUILD",
          "15474: #endif",
          "15476:     thumb_offset = get4();",
          "15477:     thumb_length = get4();",
          "15483:       if (is_raw == 2 && shot_select)",
          "15485:     }",
          "15486:     load_raw = &CLASS unpacked_load_raw;",
          "15490:     apply_tiff();",
          "15493:     parse_riff();",
          "15497:     is_raw = 0;",
          "15503:     data_offset = get2();",
          "15504:     get2();",
          "15505:     raw_width = get2();",
          "15506:     raw_height = get2();",
          "15507:     load_raw = &CLASS nokia_load_raw;",
          "15508:     filters = 0x61616161;",
          "15511:     order = 0x4949;",
          "15513:     data_offset = get4();",
          "15514:     i = get4();",
          "15515:     width = get2();",
          "15516:     height = get2();",
          "15520:     }",
          "15522:     mask[0][3] = 1;",
          "15523:     filters = 0x61616161;",
          "15525:     order = 0x4949;",
          "15527:     width = get4();",
          "15528:     height = get4();",
          "15532:     data_offset = 4096;",
          "15533:     load_raw = &CLASS packed_load_raw;",
          "15534:     load_flags = 88;",
          "15535:     filters = 0x61616161;",
          "15537:     order = 0x4949;",
          "15540:     raw_height = get2();",
          "15544:     data_offset = 0x10000;",
          "15545:     load_raw = &CLASS canon_rmf_load_raw;",
          "15550:     parse_redcine();",
          "15551:     load_raw = &CLASS redcine_load_raw;",
          "15553:     filters = 0x49494949;",
          "15555:     parse_rollei();",
          "15557:     parse_sinar_ia();",
          "15559:     parse_minolta(0);",
          "15562: #ifdef LIBRAW_LIBRARY_BUILD",
          "15567: #endif",
          "15569: #else",
          "15572: #endif",
          "15573: #endif",
          "15576:     parse_cine();",
          "15578: #ifdef LIBRAW_LIBRARY_BUILD",
          "15580: #else",
          "15582: #endif",
          "15585: #ifdef LIBRAW_LIBRARY_BUILD",
          "15587:           {",
          "15590:           }",
          "15632:     parse_jpeg(0);",
          "15634:     int sz = ftell(ifp);",
          "15635: #ifdef LIBRAW_LIBRARY_BUILD",
          "15647:       thumb_offset = 0;",
          "15648:       thumb_length = sz - 0x9cb600 - 1;",
          "15656:       else",
          "15659:       data_offset = ftell(ifp) + 0x8000 - 0x20;",
          "15660:       parse_broadcom();",
          "15664:       thumb_offset = 0;",
          "15665:       thumb_length = sz - 0x61b800 - 1;",
          "15666: #else",
          "15672:       width = raw_width;",
          "15673:       raw_width = 2611;",
          "15674:       load_raw = &CLASS nokia_load_raw;",
          "15675:       filters = 0x16161616;",
          "15676: #endif",
          "15678:   }",
          "15679: #ifdef LIBRAW_LIBRARY_BUILD",
          "15681:   desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;",
          "15682: #endif",
          "15695: #else",
          "15698:   cp = model + strlen(model);",
          "15708:   desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;",
          "15766:     goto dng_skip;",
          "15767:   }",
          "15769:     if (!load_raw)",
          "15770:       load_raw = &CLASS lossless_jpeg_load_raw;",
          "15784:       left_margin = 8;",
          "15785:       top_margin = 16;",
          "15786:     }",
          "15787:   }",
          "15809:     if (!load_raw)",
          "15810:       load_raw = &CLASS packed_load_raw;",
          "15811:     if (model[0] == 'E')",
          "15812:       load_flags |= !data_offset << 2 | 2;",
          "15813:   }",
          "15819:     height = 480;",
          "15820:     top_margin = filters = 0;",
          "15822:   }",
          "15823:   if (!strcmp(make, \"Sony\") && raw_width > 3888 && !black && !cblack[0])",
          "15824:     black = 128 << (tiff_bps - 12);",
          "15829:     filters = 0;",
          "15830: #ifdef LIBRAW_DEMOSAIC_PACK_GPL2",
          "15832:       simple_coeff(0);",
          "15833: #endif",
          "15834:   }",
          "15836:   {",
          "15838:     {",
          "15846:     }",
          "15847:   }",
          "15852:     }",
          "15856:     }",
          "15857:     if (width == 7200 && height == 3888)",
          "15862:     filters = 0;",
          "15863:     tiff_samples = colors = 3;",
          "15864:     load_raw = &CLASS canon_sraw_load_raw;",
          "15866:     height = 613;",
          "15868:     raw_width = 896;",
          "15869:     colors = 4;",
          "15870:     filters = 0xe1e4e1e4;",
          "15871:     load_raw = &CLASS canon_600_load_raw;",
          "15874:     height = 773;",
          "15876:     raw_width = 992;",
          "15878:     filters = 0x1e4e1e4e;",
          "15879:     goto canon_a5;",
          "15883:     raw_width = 1320;",
          "15884:     filters = 0x1b4e4b1e;",
          "15885:     goto canon_a5;",
          "15887:     height = 1024;",
          "15889:     filters = 0x1e4b4e1b;",
          "15891:     colors = 4;",
          "15892:     tiff_bps = 10;",
          "15893:     load_raw = &CLASS packed_load_raw;",
          "15894:     load_flags = 40;",
          "15897:     colors = 4;",
          "15898:     filters = 0xb4b4b4b4;",
          "15902:     mask[1][3] = -4;",
          "15904:     left_margin = 92;",
          "15925:     top_margin = 17;",
          "15927:     filters = 0x61616161;",
          "15928:     black = curve[200];",
          "15933:     width -= 4;",
          "15934:     pixel_aspect = 0.5;",
          "15939:     height -= 3;",
          "15944:     width -= 4;",
          "15945:     left_margin = 2;",
          "15947:     width -= 28;",
          "15948:     left_margin = 6;",
          "15951:     width -= 42;",
          "15955:     width -= 44;",
          "15959:     width -= 46;",
          "15962:     width -= 52;",
          "15963:     left_margin = 2;",
          "15967:     width--;",
          "15969:     if (load_flags)",
          "15970:       raw_width = (width += 3) + 3;",
          "15972:     left_margin = 1;",
          "15973:     width -= 4;",
          "15974:     filters = 0x94949494;",
          "15976:     left_margin = 6;",
          "15977:     width -= 14;",
          "15982:     width -= 32;",
          "15999:     load_flags = 24;",
          "16000:     filters = 0x94949494;",
          "16002:       black = 255;",
          "16004:     height -= 2;",
          "16006:     simple_coeff(3);",
          "16007:     pre_mul[0] = 1.2085;",
          "16008:     pre_mul[1] = 1.0943;",
          "16009:     pre_mul[3] = 1.1103;",
          "16011:     cam_mul[0] *= 4;",
          "16012:     cam_mul[2] *= 4;",
          "16014:     if (!timestamp && nikon_e995())",
          "16017:       filters = 0xb4b4b4b4;",
          "16018:       simple_coeff(3);",
          "16019:       pre_mul[0] = 1.196;",
          "16020:       pre_mul[1] = 1.246;",
          "16021:       pre_mul[2] = 1.018;",
          "16022:     }",
          "16024:     if (!timestamp && !nikon_e2100())",
          "16027:       height -= 2;",
          "16028:       load_flags = 6;",
          "16029:       colors = 4;",
          "16030:       filters = 0x4b4b4b4b;",
          "16031:     }",
          "16035:       filters = 0x49494949;",
          "16037:       flip = 1;",
          "16038:       filters = 0x16161616;",
          "16039:     }",
          "16046:       }",
          "16048:     }",
          "16053:     }",
          "16058:       height -= (top_margin = 16);",
          "16059:       width -= (left_margin = 28);",
          "16060:       maximum = 0xf5c0;",
          "16062:       model[0] = 0;",
          "16063:     }",
          "16067:       height = 2144;",
          "16069:       flip = 6;",
          "16071:       maximum = (is_raw == 2 && shot_select) ? 0x2f00 : 0x3e00;",
          "16072:     top_margin = (raw_height - height) >> 2 << 1;",
          "16081:       width += 2;",
          "16082:       left_margin = 0;",
          "16083:       filters = 0x16161616;",
          "16084:     }",
          "16090:     if (filters == 9)",
          "16094:     height = 1712;",
          "16096:     raw_width = 2336;",
          "16097:     goto konica_400z;",
          "16099:     goto konica_510z;",
          "16101:     if (!load_raw && (maximum = 0xfff))",
          "16102:       load_raw = &CLASS unpacked_load_raw;",
          "16106:       tiff_bps = 12;",
          "16107:       load_raw = &CLASS packed_load_raw;",
          "16113:       load_raw = &CLASS packed_load_raw;",
          "16126:       }",
          "16127:       data_offset += 14;",
          "16128:       filters = 0x61616161;",
          "16130:       load_raw = &CLASS unpacked_load_raw;",
          "16131:       maximum = 0x3df;",
          "16132:       order = 0x4d4d;",
          "16133:     }",
          "16135:     load_raw = &CLASS unpacked_load_raw;",
          "16136:     data_error = -1;",
          "16138:     height -= 2;",
          "16140:     height -= top_margin = 8;",
          "16141:     width -= 2 * (left_margin = 8);",
          "16142:     load_flags = 32;",
          "16144:     top_margin = 24;",
          "16145:     left_margin = 64;",
          "16146:     width = 5472;",
          "16147:     height = 3648;",
          "16148:     filters = 0x61616161;",
          "16149:     colors = 3;",
          "16151:     height -= top_margin = 18;",
          "16152:     left_margin = raw_width - (width = 5536);",
          "16153:     if (raw_width != 5600)",
          "16154:       left_margin = top_margin = 0;",
          "16155:     filters = 0x61616161;",
          "16156:     colors = 3;",
          "16158:     order = 0x4949;",
          "16159:     height = 3694;",
          "16160:     top_margin = 2;",
          "16164:     height -= top_margin = 17;",
          "16165:     left_margin = 96;",
          "16166:     width = 5544;",
          "16167:     filters = 0x49494949;",
          "16169:     filters = 0x61616161;",
          "16170: #ifdef LIBRAW_LIBRARY_BUILD",
          "16172: #endif",
          "16175:     order = 0x4949;",
          "16176:     height -= 20;",
          "16177:     top_margin = 2;",
          "16179:       height -= 10;",
          "16181:       top_margin = 8;",
          "16182:     }",
          "16184:     order = 0x4949;",
          "16185:     height -= 3;",
          "16186:     top_margin = 2;",
          "16188:       height -= 28;",
          "16190:       top_margin = 8;",
          "16191:     }",
          "16195:     height = 3030;",
          "16197:     top_margin = 15;",
          "16199:     order = 0x4949;",
          "16200:     filters = 0x49494949;",
          "16201:     load_raw = &CLASS unpacked_load_raw;",
          "16203:     black = 16;",
          "16205:     height = raw_height - (top_margin = 2);",
          "16209:     if (load_raw == &CLASS lossless_jpeg_load_raw)",
          "16210:       load_raw = &CLASS hasselblad_load_raw;",
          "16212:       height = 5444;",
          "16215:       left_margin = 7;",
          "16216:       filters = 0x61616161;",
          "16223:       height -= 84;",
          "16226:       left_margin = 41;",
          "16227:       filters = 0x61616161;",
          "16230:     }",
          "16232:     {",
          "16238:     }",
          "16251:       else",
          "16263:       height -= (top_margin = 6);",
          "16264:       width -= (left_margin = 3) + 7;",
          "16265:       filters = 0x61616161;",
          "16290:       left_margin = 52;",
          "16291:       top_margin = 100;",
          "16292:       width = 8272;",
          "16293:       height = 6200;",
          "16294:       black = 256;",
          "16296:     }",
          "16300:     }",
          "16304:     maximum = 0x3fff;",
          "16306:     maximum = 0x3fff;",
          "16309:       maximum = 0x1fff;",
          "16312:       load_raw = &CLASS leaf_hdr_load_raw;",
          "16313:       raw_width = tile_width;",
          "16314:     }",
          "16338:       height -= 2 * (top_margin = 30);",
          "16339:       width -= 2 * (left_margin = 55);",
          "16340:       filters = 0x49494949;",
          "16343:       height -= 2 * (top_margin = 24);",
          "16344:       width -= 2 * (left_margin = 24);",
          "16345:       filters = 0x16161616;",
          "16346:     }",
          "16350:       load_raw = &CLASS panasonic_load_raw;",
          "16352:       load_raw = &CLASS unpacked_load_raw;",
          "16353:       load_flags = 4;",
          "16354:     }",
          "16355:     zero_is_bad = 1;",
          "16367:     height = 1718;",
          "16369:     filters = 0x16161616;",
          "16370:     load_raw = &CLASS packed_load_raw;",
          "16371:     load_flags = 30;",
          "16373:     height += height & 1;",
          "16378:     if (load_raw == &CLASS unpacked_load_raw)",
          "16379:       load_flags = 4;",
          "16380:     tiff_bps = 12;",
          "16383:       width -= 20;",
          "16387:       }",
          "16389:       width -= 14;",
          "16390:       maximum = 0xfff;",
          "16392:       width -= 30;",
          "16393:       if (load_raw == &CLASS unpacked_load_raw)",
          "16396:       thumb_length = flen - (thumb_offset = 0xa39800);",
          "16397:       thumb_height = 480;",
          "16400:       width -= 16;",
          "16401:     }",
          "16403:     height = 2047;",
          "16405:     filters = 0x61616161;",
          "16406:     data_offset = 0x1a00;",
          "16407:     load_raw = &CLASS packed_load_raw;",
          "16409:     width = 3288;",
          "16410:     left_margin = 5;",
          "16411:     mask[1][3] = -17;",
          "",
          "[Removed Lines]",
          "15380:   for (i=0; i < 4; i++) {",
          "15387:   for (i=0; i < 0x10000; i++) curve[i] = i;",
          "15391:   fseek (ifp, 0, SEEK_SET);",
          "15393:   fread (head, 1, 64, ifp);",
          "15396:   fread (head, 1, 32, ifp);",
          "15398:   fseek (ifp, 0, SEEK_END);",
          "15400:   if ((cp = (char *) memmem (head, 32, (char*)\"MMMM\", 4)) ||",
          "15401:       (cp = (char *) memmem (head, 32, (char*)\"IIII\", 4))) {",
          "15402:     parse_phase_one (cp-head);",
          "15403:     if (cp-head && parse_tiff(0)) apply_tiff();",
          "15404:   } else if (order == 0x4949 || order == 0x4d4d) {",
          "15405:     if (!memcmp (head+6,\"HEAPCCDR\",8)) {",
          "15411:       parse_ciff (hlen, flen-hlen, 0);",
          "15413:     } else if (parse_tiff(0)) apply_tiff();",
          "15414:   } else if (!memcmp (head,\"\\xff\\xd8\\xff\\xe1\",4) &&",
          "15415:       !memcmp (head+6,\"Exif\",4)) {",
          "15416:     fseek (ifp, 4, SEEK_SET);",
          "15418:     fseek (ifp, data_offset, SEEK_SET);",
          "15422:   } else if (!memcmp (head+25,\"ARECOYK\",7)) {",
          "15423:     strcpy (make, \"Contax\");",
          "15424:     strcpy (model,\"N Digital\");",
          "15425:     fseek (ifp, 33, SEEK_SET);",
          "15427:     fseek (ifp, 52, SEEK_SET);",
          "15428:     switch (get4()) {",
          "15429:       case  7: iso_speed = 25;  break;",
          "15430:       case  8: iso_speed = 32;  break;",
          "15431:       case  9: iso_speed = 40;  break;",
          "15432:       case 10: iso_speed = 50;  break;",
          "15433:       case 11: iso_speed = 64;  break;",
          "15434:       case 12: iso_speed = 80;  break;",
          "15435:       case 13: iso_speed = 100; break;",
          "15436:       case 14: iso_speed = 125; break;",
          "15437:       case 15: iso_speed = 160; break;",
          "15438:       case 16: iso_speed = 200; break;",
          "15439:       case 17: iso_speed = 250; break;",
          "15440:       case 18: iso_speed = 320; break;",
          "15441:       case 19: iso_speed = 400; break;",
          "15442:     }",
          "15443:     shutter = powf64(2.0f, (((float)get4())/8.0f)) / 16000.0f;",
          "15445:     fseek (ifp, 88, SEEK_SET);",
          "15446:     aperture = powf64(2.0f, ((float)get4())/16.0f);",
          "15447:     fseek (ifp, 112, SEEK_SET);",
          "15450:     fseek (ifp, 104, SEEK_SET);",
          "15451:     imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, ((float)get4())/16.0f);",
          "15452:     fseek (ifp, 124, SEEK_SET);",
          "15458:   } else if (!strcmp (head, \"PXN\")) {",
          "15459:     strcpy (make, \"Logitech\");",
          "15460:     strcpy (model,\"Fotoman Pixtura\");",
          "15461:   } else if (!strcmp (head, \"qktk\")) {",
          "15462:     strcpy (make, \"Apple\");",
          "15463:     strcpy (model,\"QuickTake 100\");",
          "15465:   } else if (!strcmp (head, \"qktn\")) {",
          "15466:     strcpy (make, \"Apple\");",
          "15467:     strcpy (model,\"QuickTake 150\");",
          "15469:   } else if (!memcmp (head,\"FUJIFILM\",8)) {",
          "15471:     strcpy(model, head+0x1c);",
          "15472:     memcpy(model2, head+0x3c, 4);",
          "15473:     model2[4]=0;",
          "15475:     fseek (ifp, 84, SEEK_SET);",
          "15478:     fseek (ifp, 92, SEEK_SET);",
          "15479:     parse_fuji (get4());",
          "15480:     if (thumb_offset > 120) {",
          "15481:       fseek (ifp, 120, SEEK_SET);",
          "15482:       is_raw += (i = get4())?1:0;",
          "15484:  parse_fuji (i);",
          "15487:     fseek (ifp, 100+28*(shot_select > 0), SEEK_SET);",
          "15488:     parse_tiff (data_offset = get4());",
          "15489:     parse_tiff (thumb_offset+12);",
          "15491:   } else if (!memcmp (head,\"RIFF\",4)) {",
          "15492:     fseek (ifp, 0, SEEK_SET);",
          "15494:   } else if (!memcmp (head+4,\"ftypqt   \",9)) {",
          "15495:     fseek (ifp, 0, SEEK_SET);",
          "15496:     parse_qt (fsize);",
          "15498:   } else if (!memcmp (head,\"\\0\\001\\0\\001\\0@\",6)) {",
          "15499:     fseek (ifp, 6, SEEK_SET);",
          "15500:     fread (make, 1, 8, ifp);",
          "15501:     fread (model, 1, 8, ifp);",
          "15502:     fread (model2, 1, 16, ifp);",
          "15509:   } else if (!memcmp (head,\"NOKIARAW\",8)) {",
          "15510:     strcpy (make, \"NOKIA\");",
          "15512:     fseek (ifp, 300, SEEK_SET);",
          "15517:     switch (tiff_bps = i*8 / (width * height)) {",
          "15518:       case  8: load_raw = &CLASS eight_bit_load_raw;  break;",
          "15519:       case 10: load_raw = &CLASS nokia_load_raw;",
          "15521:     raw_height = height + (top_margin = i / (width * tiff_bps/8) - height);",
          "15524:   } else if (!memcmp (head,\"ARRI\",4)) {",
          "15526:     fseek (ifp, 20, SEEK_SET);",
          "15529:     strcpy (make, \"ARRI\");",
          "15530:     fseek (ifp, 668, SEEK_SET);",
          "15531:     fread (model, 1, 64, ifp);",
          "15536:   } else if (!memcmp (head,\"XPDS\",4)) {",
          "15538:     fseek (ifp, 0x800, SEEK_SET);",
          "15539:     fread (make, 1, 41, ifp);",
          "15541:     raw_width  = get2();",
          "15542:     fseek (ifp, 56, SEEK_CUR);",
          "15543:     fread (model, 1, 30, ifp);",
          "15546:     gamma_curve (0, 12.25, 1, 1023);",
          "15547:   } else if (!memcmp (head+4,\"RED1\",4)) {",
          "15548:     strcpy (make, \"Red\");",
          "15549:     strcpy (model,\"One\");",
          "15552:     gamma_curve (1/2.4, 12.92, 1, 4095);",
          "15554:   } else if (!memcmp (head,\"DSC-Image\",9))",
          "15556:   else if (!memcmp (head,\"PWAD\",4))",
          "15558:   else if (!memcmp (head,\"\\0MRM\",4))",
          "15560:   else if (!memcmp (head,\"FOVb\",4))",
          "15561:     {",
          "15563: #ifdef  LIBRAW_DEMOSAIC_PACK_GPL2",
          "15564:       if(!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F))",
          "15565:         parse_foveon();",
          "15566:       else",
          "15568:         parse_x3f();",
          "15570: #ifdef  LIBRAW_DEMOSAIC_PACK_GPL2",
          "15571:       parse_foveon();",
          "15574:     }",
          "15575:   else if (!memcmp (head,\"CI\",2))",
          "15577:   if(make[0] == 0)",
          "15579:     for (zero_fsize=i=0; i < camera_count; i++)",
          "15581:     for (zero_fsize=i=0; i < sizeof table / sizeof *table; i++)",
          "15583:       if (fsize == table[i].fsize) {",
          "15584:  strcpy (make,  table[i].t_make );",
          "15586:         if (!strncmp(make, \"Canon\",5))",
          "15588:             imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "15589:             imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "15591: #endif",
          "15592:  strcpy (model, table[i].t_model);",
          "15593:  flip = table[i].flags >> 2;",
          "15594:  zero_is_bad = table[i].flags & 2;",
          "15595:  if (table[i].flags & 1)",
          "15596:    parse_external_jpeg();",
          "15597:  data_offset = table[i].offset == 0xffff?0:table[i].offset;",
          "15598:  raw_width   = table[i].rw;",
          "15599:  raw_height  = table[i].rh;",
          "15600:  left_margin = table[i].lm;",
          "15601:   top_margin = table[i].tm;",
          "15602:  width  = raw_width - left_margin - table[i].rm;",
          "15603:  height = raw_height - top_margin - table[i].bm;",
          "15604:  filters = 0x1010101 * table[i].cf;",
          "15605:  colors = 4 - !((filters & filters >> 1) & 0x5555);",
          "15606:  load_flags = table[i].lf;",
          "15607:  switch (tiff_bps = (fsize-data_offset)*8 / (raw_width*raw_height)) {",
          "15608:    case 6:",
          "15609:      load_raw = &CLASS minolta_rd175_load_raw;  break;",
          "15610:    case 8:",
          "15611:      load_raw = &CLASS eight_bit_load_raw;  break;",
          "15612:    case 10:",
          "15613:            if ((fsize-data_offset)/raw_height*3 >= raw_width*4) {",
          "15614:              load_raw = &CLASS android_loose_load_raw;  break;",
          "15615:            } else if (load_flags & 1) {",
          "15616:              load_raw = &CLASS android_tight_load_raw;  break;",
          "15617:            }",
          "15618:    case 12:",
          "15619:      load_flags |= 128;",
          "15620:      load_raw = &CLASS packed_load_raw;     break;",
          "15621:    case 16:",
          "15622:      order = 0x4949 | 0x404 * (load_flags & 1);",
          "15623:      tiff_bps -= load_flags >> 4;",
          "15624:      tiff_bps -= load_flags = load_flags >> 1 & 7;",
          "15625:      load_raw = table[i].offset == 0xffff ? &CLASS  unpacked_load_raw_reversed : &CLASS  unpacked_load_raw;",
          "15626:  }",
          "15627:  maximum = (1 << tiff_bps) - (1 << table[i].max);",
          "15628:       }",
          "15629:   if (zero_fsize) fsize = 0;",
          "15630:   if (make[0] == 0) parse_smal (0, flen);",
          "15631:   if (make[0] == 0) {",
          "15633:     fseek(ifp,0,SEEK_END);",
          "15636:     if (!strncmp(model,\"RP_imx219\",9) && sz >= 0x9cb600 &&",
          "15637:         !fseek (ifp, -0x9cb600, SEEK_END) &&",
          "15638:    fread (head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4)) {",
          "15639:  strcpy (make, \"Broadcom\");",
          "15640:  strcpy (model, \"RPi IMX219\");",
          "15641:  if (raw_height > raw_width) flip = 5;",
          "15642:  data_offset = ftell(ifp) + 0x8000 - 0x20;",
          "15643:  parse_broadcom();",
          "15644:  black = 66;",
          "15645:  maximum = 0x3ff;",
          "15646:  load_raw = &CLASS broadcom_load_raw;",
          "15649:     } else",
          "15650:       if (!(strncmp(model,\"ov5647\",6) && strncmp(model,\"RP_OV5647\",9)) && sz >= 0x61b800 &&",
          "15651:         !fseek (ifp, -0x61b800, SEEK_END) &&",
          "15652:    fread (head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4)) {",
          "15653:       strcpy (make, \"Broadcom\");",
          "15654:       if (!strncmp(model,\"ov5647\",6))",
          "15655:         strcpy (model, \"RPi OV5647 v.1\");",
          "15657:         strcpy (model, \"RPi OV5647 v.2\");",
          "15658:       if (raw_height > raw_width) flip = 5;",
          "15661:  black = 16;",
          "15662:  maximum = 0x3ff;",
          "15663:  load_raw = &CLASS broadcom_load_raw;",
          "15667:     if (!(strncmp(model,\"ov\",2) && strncmp(model,\"RP_OV\",5)) && sz>=6404096 &&",
          "15668:         !fseek (ifp, -6404096, SEEK_END) &&",
          "15669:    fread (head, 1, 32, ifp) && !strcmp(head,\"BRCMn\")) {",
          "15670:       strcpy (make, \"OmniVision\");",
          "15671:       data_offset = ftell(ifp) + 0x8000-32;",
          "15677:     } else is_raw = 0;",
          "15683:   for (i=0; i < sizeof corp / sizeof *corp; i++)",
          "15685:      strcpy (make, corp[i]);",
          "15686:   if ((!strncmp(make,\"Kodak\",5) || !strncmp(make,\"Leica\",5)) &&",
          "15687:  ((cp = strcasestr(model,\" DIGITAL CAMERA\")) ||",
          "15688:   (cp = strstr(model,\"FILE VERSION\"))))",
          "15690:   if (!strncasecmp(model,\"PENTAX\",6))",
          "15691:     strcpy (make, \"Pentax\");",
          "15692: #ifdef LIBRAW_LIBRARY_BUILD",
          "15693:   remove_trailing_spaces(make,sizeof(make));",
          "15694:   remove_trailing_spaces(model,sizeof(model));",
          "15697:   while (*--cp == ' ') *cp = 0;",
          "15699:   while (*--cp == ' ') *cp = 0;",
          "15700: #endif",
          "15702:   if (!strncasecmp (model, make, i) && model[i++] == ' ')",
          "15703:     memmove (model, model+i, 64-i);",
          "15704:   if (!strncmp (model,\"FinePix \",8))",
          "15705:     strcpy (model, model+8);",
          "15706:   if (!strncmp (model,\"Digital Camera \",15))",
          "15707:     strcpy (model, model+15);",
          "15709:   if (!is_raw) goto notraw;",
          "15711:   if (!height) height = raw_height;",
          "15712:   if (!width)  width  = raw_width;",
          "15714:     { height  = 2616;   width  = 3896; }",
          "15716:     { height  = 3124;   width  = 4688; filters = 0x16161616; }",
          "15717:   if (width == 4352 && (!strcmp(model,\"K-r\") || !strcmp(model,\"K-x\")))",
          "15718:     {   width  = 4309; filters = 0x16161616; }",
          "15719:   if (width >= 4960 && !strncmp(model,\"K-5\",3))",
          "15720:     { left_margin = 10; width  = 4950; filters = 0x16161616; }",
          "15721:   if (width == 6080 && !strcmp(model,\"K-70\"))",
          "15722:      { height  = 4016; top_margin=32; width=6020; left_margin = 60; }",
          "15723:   if (width == 4736 && !strcmp(model,\"K-7\"))",
          "15724:     { height  = 3122;   width  = 4684; filters = 0x16161616; top_margin = 2; }",
          "15726:     { left_margin = 4;  width  = 6040; }",
          "15727:   if (width == 6080 && !strcmp(model,\"K-3\"))",
          "15728:     { left_margin = 4;  width  = 6040; }",
          "15729:   if (width == 7424 && !strcmp(model,\"645D\"))",
          "15730:     { height  = 5502;   width  = 7328; filters = 0x61616161; top_margin = 29;",
          "15731:       left_margin = 48; }",
          "15733:    width  = 4014;",
          "15734:   if (dng_version) {",
          "15735:     if (filters == UINT_MAX) filters = 0;",
          "15736:     if (filters) is_raw *= tiff_samples;",
          "15737:     else  colors  = tiff_samples;",
          "15738:     switch (tiff_compress) {",
          "15740:       case 1:     load_raw = &CLASS   packed_dng_load_raw;  break;",
          "15741:       case 7:     load_raw = &CLASS lossless_dng_load_raw;  break;",
          "15742: #ifdef LIBRAW_LIBRARY_BUILD",
          "15743:       case 8:     load_raw = &CLASS  deflate_dng_load_raw;  break;",
          "15744: #endif",
          "15745:       case 34892: load_raw = &CLASS    lossy_dng_load_raw;  break;",
          "15746:       default:    load_raw = 0;",
          "15747:     }",
          "15748:     if (!strncmp(make, \"Canon\",5) && unique_id)",
          "15749:       {",
          "15750:         for (i = 0; i < sizeof unique / sizeof *unique; i++)",
          "15751:           if (unique_id == 0x80000000 + unique[i].id)",
          "15752:             {",
          "15753:               strcpy(model, unique[i].t_model);",
          "15754:               break;",
          "15755:             }",
          "15756:       }",
          "15757:     if (!strncasecmp(make, \"Sony\",4) && unique_id)",
          "15758:       {",
          "15759:         for (i = 0; i < sizeof sonique / sizeof *sonique; i++)",
          "15760:           if (unique_id == sonique[i].id)",
          "15761:             {",
          "15762:               strcpy(model, sonique[i].t_model);",
          "15763:               break;",
          "15764:             }",
          "15765:       }",
          "15768:   if (!strncmp(make,\"Canon\",5) && !fsize && tiff_bps != 15) {",
          "15771:     for (i=0; i < sizeof canon / sizeof *canon; i++)",
          "15772:       if (raw_width == canon[i][0] && raw_height == canon[i][1]) {",
          "15773:  width  = raw_width - (left_margin = canon[i][2]);",
          "15774:  height = raw_height - (top_margin = canon[i][3]);",
          "15775:  width  -= canon[i][4];",
          "15776:  height -= canon[i][5];",
          "15777:  mask[0][1] =  canon[i][6];",
          "15778:  mask[0][3] = -canon[i][7];",
          "15779:  mask[1][1] =  canon[i][8];",
          "15780:  mask[1][3] = -canon[i][9];",
          "15781:  if (canon[i][10]) filters = canon[i][10] * 0x01010101;",
          "15782:       }",
          "15783:     if ((unique_id | 0x20000) == 0x2720000) {",
          "15788:   if (!strncmp(make,\"Canon\",5) && unique_id)",
          "15789:     {",
          "15790:       for (i=0; i < sizeof unique / sizeof *unique; i++)",
          "15791:         if (unique_id == 0x80000000 + unique[i].id)",
          "15792:           {",
          "15793:             adobe_coeff (\"Canon\", unique[i].t_model);",
          "15794:             strcpy(model,unique[i].t_model);",
          "15795:           }",
          "15796:     }",
          "15798:   if (!strncasecmp(make,\"Sony\",4) && unique_id)",
          "15799:     {",
          "15800:       for (i=0; i < sizeof sonique / sizeof *sonique; i++)",
          "15801:         if (unique_id == sonique[i].id)",
          "15802:           {",
          "15803:             adobe_coeff (\"Sony\", sonique[i].t_model);",
          "15804:             strcpy(model,sonique[i].t_model);",
          "15805:           }",
          "15806:     }",
          "15808:   if (!strncmp(make,\"Nikon\",5)) {",
          "15817:   if (!strcmp(model,\"KAI-0340\")",
          "15818:  && find_green (16, 16, 3840, 5120) < 25) {",
          "15821:     strcpy (model,\"C603\");",
          "15826:   if (is_foveon) {",
          "15827:     if (height*2 < width) pixel_aspect = 0.5;",
          "15828:     if (height   > width) pixel_aspect = 2;",
          "15831:     if(!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F))",
          "15835:   else if(!strncmp(make,\"Pentax\",6))",
          "15837:     if(!strncmp(model,\"K-1\",3))",
          "15839:    top_margin = 18;",
          "15840:   height = raw_height - top_margin;",
          "15841:  if(raw_width == 7392)",
          "15842:  {",
          "15843:    left_margin = 6;",
          "15844:    width = 7376;",
          "15845:  }",
          "15848:   else if (!strncmp(make,\"Canon\",5) && tiff_bps == 15) {",
          "15849:     switch (width) {",
          "15850:       case 3344: width -= 66;",
          "15851:       case 3872: width -= 6;",
          "15853:     if (height > width) {",
          "15854:       SWAP(height,width);",
          "15855:       SWAP(raw_height,raw_width);",
          "15858:       {",
          "15859:  raw_width  = width  = 6480;",
          "15860:  raw_height = height = 4320;",
          "15861:       }",
          "15865:   } else if (!strcmp(model,\"PowerShot 600\")) {",
          "15867:     width  = 854;",
          "15872:   } else if (!strcmp(model,\"PowerShot A5\") ||",
          "15873:       !strcmp(model,\"PowerShot A5 Zoom\")) {",
          "15875:     width  = 960;",
          "15877:     pixel_aspect = 256/235.0;",
          "15880:   } else if (!strcmp(model,\"PowerShot A50\")) {",
          "15881:     height =  968;",
          "15882:     width  = 1290;",
          "15886:   } else if (!strcmp(model,\"PowerShot Pro70\")) {",
          "15888:     width  = 1552;",
          "15890: canon_a5:",
          "15895:   } else if (!strcmp(model,\"PowerShot Pro90 IS\") ||",
          "15896:       !strcmp(model,\"PowerShot G1\")) {",
          "15899:   } else if (!strcmp(model,\"PowerShot A610\")) {",
          "15900:     if (canon_s2is()) strcpy (model+10, \"S2 IS\");",
          "15901:   } else if (!strcmp(model,\"PowerShot SX220 HS\")) {",
          "15903:     top_margin=16;",
          "15905:   } else if (!strcmp(model,\"PowerShot S120\")) {",
          "15906:         raw_width = 4192;",
          "15907:         raw_height = 3062;",
          "15908:         width = 4022;",
          "15909:         height = 3016;",
          "15910:         mask[0][0] = top_margin = 31;",
          "15911:         mask[0][2] = top_margin + height;",
          "15912:         left_margin = 120;",
          "15913:         mask[0][1] = 23;",
          "15914:         mask[0][3] = 72;",
          "15915:   } else if (!strcmp(model,\"PowerShot G16\")) {",
          "15916:       mask[0][0] = 0;",
          "15917:       mask[0][2] = 80;",
          "15918:       mask[0][1] = 0;",
          "15919:       mask[0][3] = 16;",
          "15920:       top_margin = 29;",
          "15921:       left_margin = 120;",
          "15922:       width = raw_width-left_margin-48;",
          "15923:       height = raw_height-top_margin-14;",
          "15924:   } else if (!strcmp(model,\"PowerShot SX50 HS\")) {",
          "15926:   } else if (!strcmp(model,\"EOS D2000C\")) {",
          "15929:   } else if (!strcmp(model,\"D1\")) {",
          "15930:     cam_mul[0] *= 256/527.0;",
          "15931:     cam_mul[2] *= 256/317.0;",
          "15932:   } else if (!strcmp(model,\"D1X\")) {",
          "15935:   } else if (!strcmp(model,\"D40X\") ||",
          "15936:       !strcmp(model,\"D60\")  ||",
          "15937:       !strcmp(model,\"D80\")  ||",
          "15938:       !strcmp(model,\"D3000\")) {",
          "15940:     width  -= 4;",
          "15941:   } else if (!strcmp(model,\"D3\")   ||",
          "15942:       !strcmp(model,\"D3S\")  ||",
          "15943:       !strcmp(model,\"D700\")) {",
          "15946:   } else if (!strcmp(model,\"D3100\")) {",
          "15949:   } else if (!strcmp(model,\"D5000\") ||",
          "15950:       !strcmp(model,\"D90\")) {",
          "15952:   } else if (!strcmp(model,\"D5100\") ||",
          "15953:       !strcmp(model,\"D7000\") ||",
          "15954:       !strcmp(model,\"COOLPIX A\")) {",
          "15956:   } else if (!strcmp(model,\"D3200\") ||",
          "15957:      !strncmp(model,\"D6\",2)  ||",
          "15958:      !strncmp(model,\"D800\",4)) {",
          "15960:   } else if (!strcmp(model,\"D4\") ||",
          "15961:       !strcmp(model,\"Df\")) {",
          "15964:   } else if (!strncmp(model,\"D40\",3) ||",
          "15965:       !strncmp(model,\"D50\",3) ||",
          "15966:       !strncmp(model,\"D70\",3)) {",
          "15968:   } else if (!strcmp(model,\"D100\")) {",
          "15971:   } else if (!strcmp(model,\"D200\")) {",
          "15975:   } else if (!strncmp(model,\"D2H\",3)) {",
          "15978:   } else if (!strncmp(model,\"D2X\",3)) {",
          "15979:     if (width == 3264) width -= 32;",
          "15980:     else width -= 8;",
          "15981:   } else if (!strncmp(model,\"D300\",4)) {",
          "15983:   } else if (!strncmp(make,\"Nikon\",5) && raw_width == 4032) {",
          "15984:     if(!strcmp(model,\"COOLPIX P7700\"))",
          "15985:       {",
          "15986:         adobe_coeff (\"Nikon\",\"COOLPIX P7700\");",
          "15987:         maximum = 65504;",
          "15988:         load_flags = 0;",
          "15989:       }",
          "15990:     else if(!strcmp(model,\"COOLPIX P7800\"))",
          "15991:       {",
          "15992:         adobe_coeff (\"Nikon\",\"COOLPIX P7800\");",
          "15993:         maximum = 65504;",
          "15994:         load_flags = 0;",
          "15995:       }",
          "15996:     else  if(!strcmp(model,\"COOLPIX P340\"))",
          "15997:       load_flags=0;",
          "15998:   } else if (!strncmp(model,\"COOLPIX P\",9) && raw_width != 4032) {",
          "16001:     if (model[9] == '7' && (iso_speed >= 400 || iso_speed==0) && !strstr(software,\"V1.2\") )",
          "16003:   } else if (!strncmp(model,\"1 \",2)) {",
          "16005:   } else if (fsize == 1581060) {",
          "16010:   } else if (fsize == 3178560) {",
          "16013:   } else if (fsize == 4771840) {",
          "16015:       strcpy (model, \"E995\");",
          "16016:     if (strcmp(model,\"E995\")) {",
          "16023:   } else if (fsize == 2940928) {",
          "16025:       strcpy (model,\"E2500\");",
          "16026:     if (!strcmp(model,\"E2500\")) {",
          "16032:   } else if (fsize == 4775936) {",
          "16033:     if (!timestamp) nikon_3700();",
          "16034:     if (model[0] == 'E' && atoi(model+1) < 3700)",
          "16036:     if (!strcmp(model,\"Optio 33WR\")) {",
          "16040:     if (make[0] == 'O') {",
          "16041:       i = find_green (12, 32, 1188864, 3576832);",
          "16042:       c = find_green (12, 32, 2383920, 2387016);",
          "16043:       if (abs(i) < abs(c)) {",
          "16044:  SWAP(i,c);",
          "16045:  load_flags = 24;",
          "16047:       if (i < 0) filters = 0x61616161;",
          "16049:   } else if (fsize == 5869568) {",
          "16050:     if (!timestamp && minolta_z2()) {",
          "16051:       strcpy (make, \"Minolta\");",
          "16052:       strcpy (model,\"DiMAGE Z2\");",
          "16054:     load_flags = 6 + 24*(make[0] == 'M');",
          "16055:   } else if (fsize == 6291456) {",
          "16056:     fseek (ifp, 0x300000, SEEK_SET);",
          "16057:     if ((order = guess_byte_order(0x10000)) == 0x4d4d) {",
          "16061:       strcpy (make, \"ISG\");",
          "16064:   } else if (!strncmp(make,\"Fujifilm\",8)) {",
          "16065:     if (!strcmp(model+7,\"S2Pro\")) {",
          "16066:       strcpy (model,\"S2Pro\");",
          "16068:       width  = 2880;",
          "16070:     } else if (load_raw != &CLASS packed_load_raw)",
          "16073:     left_margin = (raw_width - width ) >> 2 << 1;",
          "16074:     if (width == 2848 || width == 3664) filters = 0x16161616;",
          "16075:     if (width == 4032 || width == 4952) left_margin = 0;",
          "16076:     if (width == 3328 && (width -= 66)) left_margin = 34;",
          "16077:     if (width == 4936) left_margin = 4;",
          "16078:     if (width == 6032) left_margin = 0;",
          "16079:     if (!strcmp(model,\"HS50EXR\") ||",
          "16080:  !strcmp(model,\"F900EXR\")) {",
          "16085:     if(!strcmp(model,\"S5500\"))",
          "16086:       {",
          "16087:         height -= (top_margin=6);",
          "16088:       }",
          "16089:     if (fuji_layout) raw_width *= is_raw;",
          "16091:       FORC(36) ((char *)xtrans)[c] =",
          "16092:  xtrans_abs[(c/6+top_margin) % 6][(c+left_margin) % 6];",
          "16093:   } else if (!strcmp(model,\"KD-400Z\")) {",
          "16095:     width  = 2312;",
          "16098:   } else if (!strcmp(model,\"KD-510Z\")) {",
          "16100:   } else if (!strncasecmp(make,\"Minolta\",7)) {",
          "16103:     if (!strncmp(model,\"DiMAGE A\",8)) {",
          "16104:       if (!strcmp(model,\"DiMAGE A200\"))",
          "16105:  filters = 0x49494949;",
          "16108:     } else if (!strncmp(model,\"ALPHA\",5) ||",
          "16109:         !strncmp(model,\"DYNAX\",5) ||",
          "16110:         !strncmp(model,\"MAXXUM\",6)) {",
          "16111:       sprintf (model+20, \"DYNAX %-10s\", model+6+(model[0]=='M'));",
          "16112:       adobe_coeff (make, model+20);",
          "16114:     } else if (!strncmp(model,\"DiMAGE G\",8)) {",
          "16115:       if (model[8] == '4') {",
          "16116:  height = 1716;",
          "16117:  width  = 2304;",
          "16118:       } else if (model[8] == '5') {",
          "16119: konica_510z:",
          "16120:  height = 1956;",
          "16121:  width  = 2607;",
          "16122:  raw_width = 2624;",
          "16123:       } else if (model[8] == '6') {",
          "16124:  height = 2136;",
          "16125:  width  = 2848;",
          "16129: konica_400z:",
          "16134:   } else if (!strcmp(model,\"*ist D\")) {",
          "16137:   } else if (!strcmp(model,\"*ist DS\")) {",
          "16139:   } else if (!strncmp(make,\"Samsung\",7) && raw_width == 4704) {",
          "16143:   } else if (!strncmp(make,\"Samsung\",7) && !strcmp(model,\"NX3000\")) {",
          "16150:   } else if (!strncmp(make,\"Samsung\",7) && raw_height == 3714) {",
          "16157:   } else if (!strncmp(make,\"Samsung\",7) && raw_width == 5632) {",
          "16161:     width  = 5574 - (left_margin = 32 + tiff_bps);",
          "16162:     if (tiff_bps == 12) load_flags = 80;",
          "16163:   } else if (!strncmp(make,\"Samsung\",7) && raw_width == 5664) {",
          "16168:   } else if (!strncmp(make,\"Samsung\",7) && raw_width == 6496) {",
          "16171:     if(!black && !cblack[0] && !cblack[1] && !cblack[2] && !cblack[3])",
          "16173:     black = 1 << (tiff_bps - 7);",
          "16174:   } else if (!strcmp(model,\"EX1\")) {",
          "16178:     if ((width -= 6) > 3682) {",
          "16180:       width  -= 46;",
          "16183:   } else if (!strcmp(model,\"WB2000\")) {",
          "16187:     if ((width -= 10) > 3718) {",
          "16189:       width  -= 56;",
          "16192:   } else if (strstr(model,\"WB550\")) {",
          "16193:     strcpy (model, \"WB550\");",
          "16194:   } else if (!strcmp(model,\"EX2F\")) {",
          "16196:     width  = 4040;",
          "16198:     left_margin=24;",
          "16202:   } else if (!strcmp(model,\"STV680 VGA\")) {",
          "16204:   } else if (!strcmp(model,\"N95\")) {",
          "16206:   } else if (!strcmp(model,\"640x480\")) {",
          "16207:     gamma_curve (0.45, 4.5, 1, 255);",
          "16208:   } else if (!strncmp(make,\"Hasselblad\",10)) {",
          "16211:     if (raw_width == 7262) {",
          "16213:       width  = 7248;",
          "16214:       top_margin  = 4;",
          "16217:       if(!strncasecmp(model,\"H3D\",3))",
          "16218:         {",
          "16219:           adobe_coeff(\"Hasselblad\",\"H3DII-39\");",
          "16220:           strcpy(model,\"H3DII-39\");",
          "16221:         }",
          "16222:     } else if (raw_width == 7410 || raw_width == 8282) {",
          "16224:       width  -= 82;",
          "16225:       top_margin  = 4;",
          "16228:       adobe_coeff(\"Hasselblad\",\"H4D-40\");",
          "16229:       strcpy(model,\"H4D-40\");",
          "16231:     else if( raw_width == 8384) // X1D",
          "16233:      top_margin  = 96;",
          "16234:      height -= 96;",
          "16235:      left_margin = 48;",
          "16236:      width  -= 106;",
          "16237:      adobe_coeff(\"Hasselblad\",\"X1D\");",
          "16239:     else if (raw_width == 9044) {",
          "16240:       if(black > 500)",
          "16241:         {",
          "16242:           top_margin = 12;",
          "16243:           left_margin = 44;",
          "16244:           width = 8956;",
          "16245:           height = 6708;",
          "16246:           memset(cblack,0,sizeof(cblack));",
          "16247:           adobe_coeff(\"Hasselblad\",\"H4D-60\");",
          "16248:           strcpy(model,\"H4D-60\");",
          "16249:           black = 512;",
          "16250:         }",
          "16252:         {",
          "16253:           height = 6716;",
          "16254:           width  = 8964;",
          "16255:           top_margin  = 8;",
          "16256:           left_margin = 40;",
          "16257:           black += load_flags = 256;",
          "16258:           maximum = 0x8101;",
          "16259:           strcpy(model,\"H3DII-60\");",
          "16260:         }",
          "16261:     } else if (raw_width == 4090) {",
          "16262:       strcpy (model, \"V96C\");",
          "16266:     } else if (raw_width == 8282 && raw_height == 6240) {",
          "16267:       if(!strncasecmp(model,\"H5D\",3))",
          "16268:         {",
          "16270:           left_margin = 54;",
          "16271:           top_margin = 16;",
          "16272:           width = 8176;",
          "16273:           height = 6132;",
          "16274:           black = 256;",
          "16275:           strcpy(model,\"H5D-50\");",
          "16276:         }",
          "16277:       else if(!strncasecmp(model,\"H3D\",3))",
          "16278:         {",
          "16279:           black=0;",
          "16280:           left_margin = 54;",
          "16281:           top_margin = 16;",
          "16282:           width = 8176;",
          "16283:           height = 6132;",
          "16284:           memset(cblack,0,sizeof(cblack));",
          "16285:           adobe_coeff(\"Hasselblad\",\"H3D-50\");",
          "16286:           strcpy(model,\"H3D-50\");",
          "16287:         }",
          "16288:     } else if (raw_width == 8374 && raw_height == 6304) {",
          "16295:       strcpy(model,\"H5D-50c\");",
          "16297:     if (tiff_samples > 1) {",
          "16298:       is_raw = tiff_samples+1;",
          "16299:       if (!shot_select && !half_size) filters = 0;",
          "16301:   } else if (!strncmp(make,\"Sinar\",5)) {",
          "16302:     if (!load_raw) load_raw = &CLASS unpacked_load_raw;",
          "16303:     if (is_raw > 1 && !shot_select && !half_size) filters = 0;",
          "16305:   } else if (!strncmp(make,\"Leaf\",4)) {",
          "16307:     fseek (ifp, data_offset, SEEK_SET);",
          "16308:     if (ljpeg_start (&jh, 1) && jh.bits == 15)",
          "16310:     if (tiff_samples > 1) filters = 0;",
          "16311:     if (tiff_samples > 1 || tile_length < raw_height) {",
          "16315:     if ((width | height) == 2048) {",
          "16316:       if (tiff_samples == 1) {",
          "16317:  filters = 1;",
          "16318:  strcpy (cdesc, \"RBTG\");",
          "16319:  strcpy (model, \"CatchLight\");",
          "16320:  top_margin =  8; left_margin = 18; height = 2032; width = 2016;",
          "16321:       } else {",
          "16322:  strcpy (model, \"DCB2\");",
          "16323:  top_margin = 10; left_margin = 16; height = 2028; width = 2022;",
          "16324:       }",
          "16325:     } else if (width+height == 3144+2060) {",
          "16326:       if (!model[0]) strcpy (model, \"Cantare\");",
          "16327:       if (width > height) {",
          "16328:   top_margin = 6; left_margin = 32; height = 2048;  width = 3072;",
          "16329:  filters = 0x61616161;",
          "16330:       } else {",
          "16331:  left_margin = 6;  top_margin = 32;  width = 2048; height = 3072;",
          "16332:  filters = 0x16161616;",
          "16333:       }",
          "16334:       if (!cam_mul[0] || model[0] == 'V') filters = 0;",
          "16335:       else is_raw = tiff_samples;",
          "16336:     } else if (width == 2116) {",
          "16337:       strcpy (model, \"Valeo 6\");",
          "16341:     } else if (width == 3171) {",
          "16342:       strcpy (model, \"Valeo 6\");",
          "16347:   } else if (!strncmp(make,\"Leica\",5) || !strncmp(make,\"Panasonic\",9)",
          "16348:       || !strncasecmp(make,\"YUNEEC\",6)) {",
          "16349:     if (raw_width > 0&& ((flen - data_offset) / (raw_width*8/7) == raw_height) )",
          "16351:     if (!load_raw) {",
          "16356:     if ((height += 12) > raw_height) height = raw_height;",
          "16357:     for (i=0; i < sizeof pana / sizeof *pana; i++)",
          "16358:       if (raw_width == pana[i][0] && raw_height == pana[i][1]) {",
          "16359:  left_margin = pana[i][2];",
          "16360:   top_margin = pana[i][3];",
          "16361:       width += pana[i][4];",
          "16362:      height += pana[i][5];",
          "16363:       }",
          "16364:     filters = 0x01010101 * (uchar) \"\\x94\\x61\\x49\\x16\"",
          "16365:  [((filters-1) ^ (left_margin & 1) ^ (top_margin << 1)) & 3];",
          "16366:   } else if (!strcmp(model,\"C770UZ\")) {",
          "16368:     width  = 2304;",
          "16372:   } else if (!strncmp(make,\"Olympus\",7)) {",
          "16374:     if (exif_cfa) filters = exif_cfa;",
          "16375:     if (width == 4100) width -= 4;",
          "16376:     if (width == 4080) width -= 24;",
          "16377:     if (width == 9280) { width -= 6; height -= 6; }",
          "16381:     if (!strcmp(model,\"E-300\") ||",
          "16382:  !strcmp(model,\"E-500\")) {",
          "16384:       if (load_raw == &CLASS unpacked_load_raw) {",
          "16385:  maximum = 0xfc3;",
          "16386:  memset (cblack, 0, sizeof cblack);",
          "16388:     } else if (!strcmp(model,\"STYLUS1\")) {",
          "16391:     } else if (!strcmp(model,\"E-330\")) {",
          "16394:  maximum = 0xf79;",
          "16395:     } else if (!strcmp(model,\"SP550UZ\")) {",
          "16398:       thumb_width  = 640;",
          "16399:     } else if (!strcmp(model,\"TG-4\")) {",
          "16402:   } else if (!strcmp(model,\"N Digital\")) {",
          "16404:     width  = 3072;",
          "16408:   } else if (!strcmp(model,\"DSC-F828\")) {",
          "",
          "[Added Lines]",
          "16531:   for (i = 0; i < 4; i++)",
          "16532:   {",
          "16539:   for (i = 0; i < 0x10000; i++)",
          "16540:     curve[i] = i;",
          "16544:   fseek(ifp, 0, SEEK_SET);",
          "16546:   fread(head, 1, 64, ifp);",
          "16549:   fread(head, 1, 32, ifp);",
          "16551:   fseek(ifp, 0, SEEK_END);",
          "16553:   if ((cp = (char *)memmem(head, 32, (char *)\"MMMM\", 4)) || (cp = (char *)memmem(head, 32, (char *)\"IIII\", 4)))",
          "16554:   {",
          "16555:     parse_phase_one(cp - head);",
          "16556:     if (cp - head && parse_tiff(0))",
          "16557:       apply_tiff();",
          "16558:   }",
          "16559:   else if (order == 0x4949 || order == 0x4d4d)",
          "16560:   {",
          "16561:     if (!memcmp(head + 6, \"HEAPCCDR\", 8))",
          "16562:     {",
          "16568:       parse_ciff(hlen, flen - hlen, 0);",
          "16570:     }",
          "16571:     else if (parse_tiff(0))",
          "16572:       apply_tiff();",
          "16573:   }",
          "16574:   else if (!memcmp(head, \"\\xff\\xd8\\xff\\xe1\", 4) && !memcmp(head + 6, \"Exif\", 4))",
          "16575:   {",
          "16576:     fseek(ifp, 4, SEEK_SET);",
          "16578:     fseek(ifp, data_offset, SEEK_SET);",
          "16582:   }",
          "16583:   else if (!memcmp(head + 25, \"ARECOYK\", 7))",
          "16584:   {",
          "16585:     strcpy(make, \"Contax\");",
          "16586:     strcpy(model, \"N Digital\");",
          "16587:     fseek(ifp, 33, SEEK_SET);",
          "16589:     fseek(ifp, 52, SEEK_SET);",
          "16590:     switch (get4())",
          "16591:     {",
          "16592:     case 7:",
          "16593:       iso_speed = 25;",
          "16594:       break;",
          "16595:     case 8:",
          "16596:       iso_speed = 32;",
          "16597:       break;",
          "16598:     case 9:",
          "16599:       iso_speed = 40;",
          "16600:       break;",
          "16601:     case 10:",
          "16602:       iso_speed = 50;",
          "16603:       break;",
          "16604:     case 11:",
          "16605:       iso_speed = 64;",
          "16606:       break;",
          "16607:     case 12:",
          "16608:       iso_speed = 80;",
          "16609:       break;",
          "16610:     case 13:",
          "16611:       iso_speed = 100;",
          "16612:       break;",
          "16613:     case 14:",
          "16614:       iso_speed = 125;",
          "16615:       break;",
          "16616:     case 15:",
          "16617:       iso_speed = 160;",
          "16618:       break;",
          "16619:     case 16:",
          "16620:       iso_speed = 200;",
          "16621:       break;",
          "16622:     case 17:",
          "16623:       iso_speed = 250;",
          "16624:       break;",
          "16625:     case 18:",
          "16626:       iso_speed = 320;",
          "16627:       break;",
          "16628:     case 19:",
          "16629:       iso_speed = 400;",
          "16630:       break;",
          "16631:     }",
          "16632:     shutter = powf64(2.0f, (((float)get4()) / 8.0f)) / 16000.0f;",
          "16634:     fseek(ifp, 88, SEEK_SET);",
          "16635:     aperture = powf64(2.0f, ((float)get4()) / 16.0f);",
          "16636:     fseek(ifp, 112, SEEK_SET);",
          "16639:     fseek(ifp, 104, SEEK_SET);",
          "16640:     imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, ((float)get4()) / 16.0f);",
          "16641:     fseek(ifp, 124, SEEK_SET);",
          "16647:   }",
          "16648:   else if (!strcmp(head, \"PXN\"))",
          "16649:   {",
          "16650:     strcpy(make, \"Logitech\");",
          "16651:     strcpy(model, \"Fotoman Pixtura\");",
          "16652:   }",
          "16653:   else if (!strcmp(head, \"qktk\"))",
          "16654:   {",
          "16655:     strcpy(make, \"Apple\");",
          "16656:     strcpy(model, \"QuickTake 100\");",
          "16658:   }",
          "16659:   else if (!strcmp(head, \"qktn\"))",
          "16660:   {",
          "16661:     strcpy(make, \"Apple\");",
          "16662:     strcpy(model, \"QuickTake 150\");",
          "16664:   }",
          "16665:   else if (!memcmp(head, \"FUJIFILM\", 8))",
          "16666:   {",
          "16668:     strcpy(model, head + 0x1c);",
          "16669:     memcpy(model2, head + 0x3c, 4);",
          "16670:     model2[4] = 0;",
          "16672:     fseek(ifp, 84, SEEK_SET);",
          "16675:     fseek(ifp, 92, SEEK_SET);",
          "16676:     parse_fuji(get4());",
          "16677:     if (thumb_offset > 120)",
          "16678:     {",
          "16679:       fseek(ifp, 120, SEEK_SET);",
          "16680:       is_raw += (i = get4()) ? 1 : 0;",
          "16682:         parse_fuji(i);",
          "16685:     fseek(ifp, 100 + 28 * (shot_select > 0), SEEK_SET);",
          "16686:     parse_tiff(data_offset = get4());",
          "16687:     parse_tiff(thumb_offset + 12);",
          "16689:   }",
          "16690:   else if (!memcmp(head, \"RIFF\", 4))",
          "16691:   {",
          "16692:     fseek(ifp, 0, SEEK_SET);",
          "16694:   }",
          "16695:   else if (!memcmp(head + 4, \"ftypqt   \", 9))",
          "16696:   {",
          "16697:     fseek(ifp, 0, SEEK_SET);",
          "16698:     parse_qt(fsize);",
          "16700:   }",
          "16701:   else if (!memcmp(head, \"\\0\\001\\0\\001\\0@\", 6))",
          "16702:   {",
          "16703:     fseek(ifp, 6, SEEK_SET);",
          "16704:     fread(make, 1, 8, ifp);",
          "16705:     fread(model, 1, 8, ifp);",
          "16706:     fread(model2, 1, 16, ifp);",
          "16713:   }",
          "16714:   else if (!memcmp(head, \"NOKIARAW\", 8))",
          "16715:   {",
          "16716:     strcpy(make, \"NOKIA\");",
          "16718:     fseek(ifp, 300, SEEK_SET);",
          "16723:     switch (tiff_bps = i * 8 / (width * height))",
          "16724:     {",
          "16725:     case 8:",
          "16726:       load_raw = &CLASS eight_bit_load_raw;",
          "16727:       break;",
          "16728:     case 10:",
          "16729:       load_raw = &CLASS nokia_load_raw;",
          "16731:     raw_height = height + (top_margin = i / (width * tiff_bps / 8) - height);",
          "16734:   }",
          "16735:   else if (!memcmp(head, \"ARRI\", 4))",
          "16736:   {",
          "16738:     fseek(ifp, 20, SEEK_SET);",
          "16741:     strcpy(make, \"ARRI\");",
          "16742:     fseek(ifp, 668, SEEK_SET);",
          "16743:     fread(model, 1, 64, ifp);",
          "16748:   }",
          "16749:   else if (!memcmp(head, \"XPDS\", 4))",
          "16750:   {",
          "16752:     fseek(ifp, 0x800, SEEK_SET);",
          "16753:     fread(make, 1, 41, ifp);",
          "16755:     raw_width = get2();",
          "16756:     fseek(ifp, 56, SEEK_CUR);",
          "16757:     fread(model, 1, 30, ifp);",
          "16760:     gamma_curve(0, 12.25, 1, 1023);",
          "16761:   }",
          "16762:   else if (!memcmp(head + 4, \"RED1\", 4))",
          "16763:   {",
          "16764:     strcpy(make, \"Red\");",
          "16765:     strcpy(model, \"One\");",
          "16768:     gamma_curve(1 / 2.4, 12.92, 1, 4095);",
          "16770:   }",
          "16771:   else if (!memcmp(head, \"DSC-Image\", 9))",
          "16773:   else if (!memcmp(head, \"PWAD\", 4))",
          "16775:   else if (!memcmp(head, \"\\0MRM\", 4))",
          "16777:   else if (!memcmp(head, \"FOVb\", 4))",
          "16778:   {",
          "16780: #ifdef LIBRAW_DEMOSAIC_PACK_GPL2",
          "16781:     if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F))",
          "16782:       parse_foveon();",
          "16783:     else",
          "16785:       parse_x3f();",
          "16787: #ifdef LIBRAW_DEMOSAIC_PACK_GPL2",
          "16788:     parse_foveon();",
          "16791:   }",
          "16792:   else if (!memcmp(head, \"CI\", 2))",
          "16794:   if (make[0] == 0)",
          "16796:     for (zero_fsize = i = 0; i < camera_count; i++)",
          "16798:     for (zero_fsize = i = 0; i < sizeof table / sizeof *table; i++)",
          "16800:       if (fsize == table[i].fsize)",
          "16801:       {",
          "16802:         strcpy(make, table[i].t_make);",
          "16804:         if (!strncmp(make, \"Canon\", 5))",
          "16805:         {",
          "16806:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "16807:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "16808:         }",
          "16809: #endif",
          "16810:         strcpy(model, table[i].t_model);",
          "16811:         flip = table[i].flags >> 2;",
          "16812:         zero_is_bad = table[i].flags & 2;",
          "16813:         if (table[i].flags & 1)",
          "16814:           parse_external_jpeg();",
          "16815:         data_offset = table[i].offset == 0xffff ? 0 : table[i].offset;",
          "16816:         raw_width = table[i].rw;",
          "16817:         raw_height = table[i].rh;",
          "16818:         left_margin = table[i].lm;",
          "16819:         top_margin = table[i].tm;",
          "16820:         width = raw_width - left_margin - table[i].rm;",
          "16821:         height = raw_height - top_margin - table[i].bm;",
          "16822:         filters = 0x1010101 * table[i].cf;",
          "16823:         colors = 4 - !((filters & filters >> 1) & 0x5555);",
          "16824:         load_flags = table[i].lf;",
          "16825:         switch (tiff_bps = (fsize - data_offset) * 8 / (raw_width * raw_height))",
          "16826:         {",
          "16827:         case 6:",
          "16828:           load_raw = &CLASS minolta_rd175_load_raw;",
          "16829:           break;",
          "16830:         case 8:",
          "16831:           load_raw = &CLASS eight_bit_load_raw;",
          "16832:           break;",
          "16833:         case 10:",
          "16834:           if ((fsize - data_offset) / raw_height * 3 >= raw_width * 4)",
          "16836:             load_raw = &CLASS android_loose_load_raw;",
          "16837:             break;",
          "16839:           else if (load_flags & 1)",
          "16840:           {",
          "16841:             load_raw = &CLASS android_tight_load_raw;",
          "16842:             break;",
          "16843:           }",
          "16844:         case 12:",
          "16845:           load_flags |= 128;",
          "16846:           load_raw = &CLASS packed_load_raw;",
          "16847:           break;",
          "16848:         case 16:",
          "16849:           order = 0x4949 | 0x404 * (load_flags & 1);",
          "16850:           tiff_bps -= load_flags >> 4;",
          "16851:           tiff_bps -= load_flags = load_flags >> 1 & 7;",
          "16852:           load_raw = table[i].offset == 0xffff ? &CLASS unpacked_load_raw_reversed : &CLASS unpacked_load_raw;",
          "16853:         }",
          "16854:         maximum = (1 << tiff_bps) - (1 << table[i].max);",
          "16855:       }",
          "16856:   if (zero_fsize)",
          "16857:     fsize = 0;",
          "16858:   if (make[0] == 0)",
          "16859:     parse_smal(0, flen);",
          "16860:   if (make[0] == 0)",
          "16861:   {",
          "16863:     fseek(ifp, 0, SEEK_END);",
          "16866:     if (!strncmp(model, \"RP_imx219\", 9) && sz >= 0x9cb600 && !fseek(ifp, -0x9cb600, SEEK_END) &&",
          "16867:         fread(head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4))",
          "16868:     {",
          "16869:       strcpy(make, \"Broadcom\");",
          "16870:       strcpy(model, \"RPi IMX219\");",
          "16871:       if (raw_height > raw_width)",
          "16872:         flip = 5;",
          "16873:       data_offset = ftell(ifp) + 0x8000 - 0x20;",
          "16874:       parse_broadcom();",
          "16875:       black = 66;",
          "16876:       maximum = 0x3ff;",
          "16877:       load_raw = &CLASS broadcom_load_raw;",
          "16880:     }",
          "16881:     else if (!(strncmp(model, \"ov5647\", 6) && strncmp(model, \"RP_OV5647\", 9)) && sz >= 0x61b800 &&",
          "16882:              !fseek(ifp, -0x61b800, SEEK_END) && fread(head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4))",
          "16883:     {",
          "16884:       strcpy(make, \"Broadcom\");",
          "16885:       if (!strncmp(model, \"ov5647\", 6))",
          "16886:         strcpy(model, \"RPi OV5647 v.1\");",
          "16888:         strcpy(model, \"RPi OV5647 v.2\");",
          "16889:       if (raw_height > raw_width)",
          "16890:         flip = 5;",
          "16893:       black = 16;",
          "16894:       maximum = 0x3ff;",
          "16895:       load_raw = &CLASS broadcom_load_raw;",
          "16899:     if (!(strncmp(model, \"ov\", 2) && strncmp(model, \"RP_OV\", 5)) && sz >= 6404096 && !fseek(ifp, -6404096, SEEK_END) &&",
          "16900:         fread(head, 1, 32, ifp) && !strcmp(head, \"BRCMn\"))",
          "16901:     {",
          "16902:       strcpy(make, \"OmniVision\");",
          "16903:       data_offset = ftell(ifp) + 0x8000 - 32;",
          "16909:     }",
          "16910:     else",
          "16911:       is_raw = 0;",
          "16917:   for (i = 0; i < sizeof corp / sizeof *corp; i++)",
          "16919:       strcpy(make, corp[i]);",
          "16920:   if ((!strncmp(make, \"Kodak\", 5) || !strncmp(make, \"Leica\", 5)) &&",
          "16921:       ((cp = strcasestr(model, \" DIGITAL CAMERA\")) || (cp = strstr(model, \"FILE VERSION\"))))",
          "16923:   if (!strncasecmp(model, \"PENTAX\", 6))",
          "16924:     strcpy(make, \"Pentax\");",
          "16925: #ifdef LIBRAW_LIBRARY_BUILD",
          "16926:   remove_trailing_spaces(make, sizeof(make));",
          "16927:   remove_trailing_spaces(model, sizeof(model));",
          "16930:   while (*--cp == ' ')",
          "16933:   while (*--cp == ' ')",
          "16935: #endif",
          "16937:   if (!strncasecmp(model, make, i) && model[i++] == ' ')",
          "16938:     memmove(model, model + i, 64 - i);",
          "16939:   if (!strncmp(model, \"FinePix \", 8))",
          "16940:     strcpy(model, model + 8);",
          "16941:   if (!strncmp(model, \"Digital Camera \", 15))",
          "16942:     strcpy(model, model + 15);",
          "16944:   if (!is_raw)",
          "16945:     goto notraw;",
          "16947:   if (!height)",
          "16948:     height = raw_height;",
          "16949:   if (!width)",
          "16950:     width = raw_width;",
          "16952:   {",
          "16953:     height = 2616;",
          "16954:     width = 3896;",
          "16955:   }",
          "16957:   {",
          "16958:     height = 3124;",
          "16959:     width = 4688;",
          "16960:     filters = 0x16161616;",
          "16961:   }",
          "16962:   if (width == 4352 && (!strcmp(model, \"K-r\") || !strcmp(model, \"K-x\")))",
          "16963:   {",
          "16964:     width = 4309;",
          "16965:     filters = 0x16161616;",
          "16966:   }",
          "16967:   if (width >= 4960 && !strncmp(model, \"K-5\", 3))",
          "16968:   {",
          "16969:     left_margin = 10;",
          "16970:     width = 4950;",
          "16971:     filters = 0x16161616;",
          "16972:   }",
          "16973:   if (width == 6080 && !strcmp(model, \"K-70\"))",
          "16974:   {",
          "16975:     height = 4016;",
          "16976:     top_margin = 32;",
          "16977:     width = 6020;",
          "16978:     left_margin = 60;",
          "16979:   }",
          "16980:   if (width == 4736 && !strcmp(model, \"K-7\"))",
          "16981:   {",
          "16982:     height = 3122;",
          "16983:     width = 4684;",
          "16984:     filters = 0x16161616;",
          "16985:     top_margin = 2;",
          "16986:   }",
          "16988:   {",
          "16989:     left_margin = 4;",
          "16990:     width = 6040;",
          "16991:   }",
          "16992:   if (width == 6080 && !strcmp(model, \"K-3\"))",
          "16993:   {",
          "16994:     left_margin = 4;",
          "16995:     width = 6040;",
          "16996:   }",
          "16997:   if (width == 7424 && !strcmp(model, \"645D\"))",
          "16998:   {",
          "16999:     height = 5502;",
          "17000:     width = 7328;",
          "17001:     filters = 0x61616161;",
          "17002:     top_margin = 29;",
          "17003:     left_margin = 48;",
          "17004:   }",
          "17006:     width = 4014;",
          "17007:   if (dng_version)",
          "17008:   {",
          "17009:     if (filters == UINT_MAX)",
          "17010:       filters = 0;",
          "17011:     if (filters)",
          "17012:       is_raw *= tiff_samples;",
          "17013:     else",
          "17014:       colors = tiff_samples;",
          "17015:     switch (tiff_compress)",
          "17016:     {",
          "17018:     case 1:",
          "17019:       load_raw = &CLASS packed_dng_load_raw;",
          "17020:       break;",
          "17021:     case 7:",
          "17022:       load_raw = &CLASS lossless_dng_load_raw;",
          "17023:       break;",
          "17024: #ifdef LIBRAW_LIBRARY_BUILD",
          "17025:     case 8:",
          "17026:       load_raw = &CLASS deflate_dng_load_raw;",
          "17027:       break;",
          "17028: #endif",
          "17029:     case 34892:",
          "17030:       load_raw = &CLASS lossy_dng_load_raw;",
          "17031:       break;",
          "17032:     default:",
          "17033:       load_raw = 0;",
          "17034:     }",
          "17035:     if (!strncmp(make, \"Canon\", 5) && unique_id)",
          "17036:     {",
          "17037:       for (i = 0; i < sizeof unique / sizeof *unique; i++)",
          "17038:         if (unique_id == 0x80000000 + unique[i].id)",
          "17039:         {",
          "17040:           strcpy(model, unique[i].t_model);",
          "17041:           break;",
          "17042:         }",
          "17043:     }",
          "17044:     if (!strncasecmp(make, \"Sony\", 4) && unique_id)",
          "17045:     {",
          "17046:       for (i = 0; i < sizeof sonique / sizeof *sonique; i++)",
          "17047:         if (unique_id == sonique[i].id)",
          "17048:         {",
          "17049:           strcpy(model, sonique[i].t_model);",
          "17050:           break;",
          "17051:         }",
          "17052:     }",
          "17055:   if (!strncmp(make, \"Canon\", 5) && !fsize && tiff_bps != 15)",
          "17056:   {",
          "17059:     for (i = 0; i < sizeof canon / sizeof *canon; i++)",
          "17060:       if (raw_width == canon[i][0] && raw_height == canon[i][1])",
          "17061:       {",
          "17062:         width = raw_width - (left_margin = canon[i][2]);",
          "17063:         height = raw_height - (top_margin = canon[i][3]);",
          "17064:         width -= canon[i][4];",
          "17065:         height -= canon[i][5];",
          "17066:         mask[0][1] = canon[i][6];",
          "17067:         mask[0][3] = -canon[i][7];",
          "17068:         mask[1][1] = canon[i][8];",
          "17069:         mask[1][3] = -canon[i][9];",
          "17070:         if (canon[i][10])",
          "17071:           filters = canon[i][10] * 0x01010101;",
          "17072:       }",
          "17073:     if ((unique_id | 0x20000) == 0x2720000)",
          "17074:     {",
          "17079:   if (!strncmp(make, \"Canon\", 5) && unique_id)",
          "17080:   {",
          "17081:     for (i = 0; i < sizeof unique / sizeof *unique; i++)",
          "17082:       if (unique_id == 0x80000000 + unique[i].id)",
          "17083:       {",
          "17084:         adobe_coeff(\"Canon\", unique[i].t_model);",
          "17085:         strcpy(model, unique[i].t_model);",
          "17086:       }",
          "17087:   }",
          "17089:   if (!strncasecmp(make, \"Sony\", 4) && unique_id)",
          "17090:   {",
          "17091:     for (i = 0; i < sizeof sonique / sizeof *sonique; i++)",
          "17092:       if (unique_id == sonique[i].id)",
          "17093:       {",
          "17094:         adobe_coeff(\"Sony\", sonique[i].t_model);",
          "17095:         strcpy(model, sonique[i].t_model);",
          "17096:       }",
          "17097:   }",
          "17099:   if (!strncmp(make, \"Nikon\", 5))",
          "17100:   {",
          "17109:   if (!strcmp(model, \"KAI-0340\") && find_green(16, 16, 3840, 5120) < 25)",
          "17110:   {",
          "17113:     strcpy(model, \"C603\");",
          "17118:   if (is_foveon)",
          "17119:   {",
          "17120:     if (height * 2 < width)",
          "17121:       pixel_aspect = 0.5;",
          "17122:     if (height > width)",
          "17123:       pixel_aspect = 2;",
          "17126:     if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F))",
          "17130:   else if (!strncmp(make, \"Pentax\", 6))",
          "17132:     if (!strncmp(model, \"K-1\", 3))",
          "17134:       top_margin = 18;",
          "17135:       height = raw_height - top_margin;",
          "17136:       if (raw_width == 7392)",
          "17137:       {",
          "17138:         left_margin = 6;",
          "17139:         width = 7376;",
          "17140:       }",
          "17143:   else if (!strncmp(make, \"Canon\", 5) && tiff_bps == 15)",
          "17144:   {",
          "17145:     switch (width)",
          "17146:     {",
          "17147:     case 3344:",
          "17148:       width -= 66;",
          "17149:     case 3872:",
          "17150:       width -= 6;",
          "17152:     if (height > width)",
          "17153:     {",
          "17154:       SWAP(height, width);",
          "17155:       SWAP(raw_height, raw_width);",
          "17158:     {",
          "17159:       raw_width = width = 6480;",
          "17160:       raw_height = height = 4320;",
          "17161:     }",
          "17165:   }",
          "17166:   else if (!strcmp(model, \"PowerShot 600\"))",
          "17167:   {",
          "17169:     width = 854;",
          "17174:   }",
          "17175:   else if (!strcmp(model, \"PowerShot A5\") || !strcmp(model, \"PowerShot A5 Zoom\"))",
          "17176:   {",
          "17178:     width = 960;",
          "17180:     pixel_aspect = 256 / 235.0;",
          "17183:   }",
          "17184:   else if (!strcmp(model, \"PowerShot A50\"))",
          "17185:   {",
          "17186:     height = 968;",
          "17187:     width = 1290;",
          "17191:   }",
          "17192:   else if (!strcmp(model, \"PowerShot Pro70\"))",
          "17193:   {",
          "17195:     width = 1552;",
          "17197:   canon_a5:",
          "17202:   }",
          "17203:   else if (!strcmp(model, \"PowerShot Pro90 IS\") || !strcmp(model, \"PowerShot G1\"))",
          "17204:   {",
          "17207:   }",
          "17208:   else if (!strcmp(model, \"PowerShot A610\"))",
          "17209:   {",
          "17210:     if (canon_s2is())",
          "17211:       strcpy(model + 10, \"S2 IS\");",
          "17212:   }",
          "17213:   else if (!strcmp(model, \"PowerShot SX220 HS\"))",
          "17214:   {",
          "17216:     top_margin = 16;",
          "17218:   }",
          "17219:   else if (!strcmp(model, \"PowerShot S120\"))",
          "17220:   {",
          "17221:     raw_width = 4192;",
          "17222:     raw_height = 3062;",
          "17223:     width = 4022;",
          "17224:     height = 3016;",
          "17225:     mask[0][0] = top_margin = 31;",
          "17226:     mask[0][2] = top_margin + height;",
          "17227:     left_margin = 120;",
          "17228:     mask[0][1] = 23;",
          "17229:     mask[0][3] = 72;",
          "17230:   }",
          "17231:   else if (!strcmp(model, \"PowerShot G16\"))",
          "17232:   {",
          "17233:     mask[0][0] = 0;",
          "17234:     mask[0][2] = 80;",
          "17235:     mask[0][1] = 0;",
          "17236:     mask[0][3] = 16;",
          "17237:     top_margin = 29;",
          "17238:     left_margin = 120;",
          "17239:     width = raw_width - left_margin - 48;",
          "17240:     height = raw_height - top_margin - 14;",
          "17241:   }",
          "17242:   else if (!strcmp(model, \"PowerShot SX50 HS\"))",
          "17243:   {",
          "17245:   }",
          "17246:   else if (!strcmp(model, \"EOS D2000C\"))",
          "17247:   {",
          "17250:   }",
          "17251:   else if (!strcmp(model, \"D1\"))",
          "17252:   {",
          "17253:     cam_mul[0] *= 256 / 527.0;",
          "17254:     cam_mul[2] *= 256 / 317.0;",
          "17255:   }",
          "17256:   else if (!strcmp(model, \"D1X\"))",
          "17257:   {",
          "17260:   }",
          "17261:   else if (!strcmp(model, \"D40X\") || !strcmp(model, \"D60\") || !strcmp(model, \"D80\") || !strcmp(model, \"D3000\"))",
          "17262:   {",
          "17264:     width -= 4;",
          "17265:   }",
          "17266:   else if (!strcmp(model, \"D3\") || !strcmp(model, \"D3S\") || !strcmp(model, \"D700\"))",
          "17267:   {",
          "17270:   }",
          "17271:   else if (!strcmp(model, \"D3100\"))",
          "17272:   {",
          "17275:   }",
          "17276:   else if (!strcmp(model, \"D5000\") || !strcmp(model, \"D90\"))",
          "17277:   {",
          "17279:   }",
          "17280:   else if (!strcmp(model, \"D5100\") || !strcmp(model, \"D7000\") || !strcmp(model, \"COOLPIX A\"))",
          "17281:   {",
          "17283:   }",
          "17284:   else if (!strcmp(model, \"D3200\") || !strncmp(model, \"D6\", 2) || !strncmp(model, \"D800\", 4))",
          "17285:   {",
          "17287:   }",
          "17288:   else if (!strcmp(model, \"D4\") || !strcmp(model, \"Df\"))",
          "17289:   {",
          "17292:   }",
          "17293:   else if (!strncmp(model, \"D40\", 3) || !strncmp(model, \"D50\", 3) || !strncmp(model, \"D70\", 3))",
          "17294:   {",
          "17296:   }",
          "17297:   else if (!strcmp(model, \"D100\"))",
          "17298:   {",
          "17301:   }",
          "17302:   else if (!strcmp(model, \"D200\"))",
          "17303:   {",
          "17307:   }",
          "17308:   else if (!strncmp(model, \"D2H\", 3))",
          "17309:   {",
          "17312:   }",
          "17313:   else if (!strncmp(model, \"D2X\", 3))",
          "17314:   {",
          "17315:     if (width == 3264)",
          "17316:       width -= 32;",
          "17317:     else",
          "17318:       width -= 8;",
          "17319:   }",
          "17320:   else if (!strncmp(model, \"D300\", 4))",
          "17321:   {",
          "17323:   }",
          "17324:   else if (!strncmp(make, \"Nikon\", 5) && raw_width == 4032)",
          "17325:   {",
          "17326:     if (!strcmp(model, \"COOLPIX P7700\"))",
          "17327:     {",
          "17328:       adobe_coeff(\"Nikon\", \"COOLPIX P7700\");",
          "17329:       maximum = 65504;",
          "17330:       load_flags = 0;",
          "17331:     }",
          "17332:     else if (!strcmp(model, \"COOLPIX P7800\"))",
          "17333:     {",
          "17334:       adobe_coeff(\"Nikon\", \"COOLPIX P7800\");",
          "17335:       maximum = 65504;",
          "17336:       load_flags = 0;",
          "17337:     }",
          "17338:     else if (!strcmp(model, \"COOLPIX P340\"))",
          "17339:       load_flags = 0;",
          "17340:   }",
          "17341:   else if (!strncmp(model, \"COOLPIX P\", 9) && raw_width != 4032)",
          "17342:   {",
          "17345:     if (model[9] == '7' && (iso_speed >= 400 || iso_speed == 0) && !strstr(software, \"V1.2\"))",
          "17347:   }",
          "17348:   else if (!strncmp(model, \"1 \", 2))",
          "17349:   {",
          "17351:   }",
          "17352:   else if (fsize == 1581060)",
          "17353:   {",
          "17358:   }",
          "17359:   else if (fsize == 3178560)",
          "17360:   {",
          "17363:   }",
          "17364:   else if (fsize == 4771840)",
          "17365:   {",
          "17367:       strcpy(model, \"E995\");",
          "17368:     if (strcmp(model, \"E995\"))",
          "17369:     {",
          "17376:   }",
          "17377:   else if (fsize == 2940928)",
          "17378:   {",
          "17380:       strcpy(model, \"E2500\");",
          "17381:     if (!strcmp(model, \"E2500\"))",
          "17382:     {",
          "17388:   }",
          "17389:   else if (fsize == 4775936)",
          "17390:   {",
          "17391:     if (!timestamp)",
          "17392:       nikon_3700();",
          "17393:     if (model[0] == 'E' && atoi(model + 1) < 3700)",
          "17395:     if (!strcmp(model, \"Optio 33WR\"))",
          "17396:     {",
          "17400:     if (make[0] == 'O')",
          "17401:     {",
          "17402:       i = find_green(12, 32, 1188864, 3576832);",
          "17403:       c = find_green(12, 32, 2383920, 2387016);",
          "17404:       if (abs(i) < abs(c))",
          "17405:       {",
          "17406:         SWAP(i, c);",
          "17407:         load_flags = 24;",
          "17409:       if (i < 0)",
          "17410:         filters = 0x61616161;",
          "17412:   }",
          "17413:   else if (fsize == 5869568)",
          "17414:   {",
          "17415:     if (!timestamp && minolta_z2())",
          "17416:     {",
          "17417:       strcpy(make, \"Minolta\");",
          "17418:       strcpy(model, \"DiMAGE Z2\");",
          "17420:     load_flags = 6 + 24 * (make[0] == 'M');",
          "17421:   }",
          "17422:   else if (fsize == 6291456)",
          "17423:   {",
          "17424:     fseek(ifp, 0x300000, SEEK_SET);",
          "17425:     if ((order = guess_byte_order(0x10000)) == 0x4d4d)",
          "17426:     {",
          "17430:       strcpy(make, \"ISG\");",
          "17433:   }",
          "17434:   else if (!strncmp(make, \"Fujifilm\", 8))",
          "17435:   {",
          "17436:     if (!strcmp(model + 7, \"S2Pro\"))",
          "17437:     {",
          "17438:       strcpy(model, \"S2Pro\");",
          "17440:       width = 2880;",
          "17442:     }",
          "17443:     else if (load_raw != &CLASS packed_load_raw)",
          "17446:     left_margin = (raw_width - width) >> 2 << 1;",
          "17447:     if (width == 2848 || width == 3664)",
          "17448:       filters = 0x16161616;",
          "17449:     if (width == 4032 || width == 4952)",
          "17450:       left_margin = 0;",
          "17451:     if (width == 3328 && (width -= 66))",
          "17452:       left_margin = 34;",
          "17453:     if (width == 4936)",
          "17454:       left_margin = 4;",
          "17455:     if (width == 6032)",
          "17456:       left_margin = 0;",
          "17457:     if (!strcmp(model, \"HS50EXR\") || !strcmp(model, \"F900EXR\"))",
          "17458:     {",
          "17463:     if (!strcmp(model, \"S5500\"))",
          "17464:     {",
          "17465:       height -= (top_margin = 6);",
          "17466:     }",
          "17467:     if (fuji_layout)",
          "17468:       raw_width *= is_raw;",
          "17470:       FORC(36)((char *)xtrans)[c] = xtrans_abs[(c / 6 + top_margin) % 6][(c + left_margin) % 6];",
          "17471:   }",
          "17472:   else if (!strcmp(model, \"KD-400Z\"))",
          "17473:   {",
          "17475:     width = 2312;",
          "17478:   }",
          "17479:   else if (!strcmp(model, \"KD-510Z\"))",
          "17480:   {",
          "17482:   }",
          "17483:   else if (!strncasecmp(make, \"Minolta\", 7))",
          "17484:   {",
          "17487:     if (!strncmp(model, \"DiMAGE A\", 8))",
          "17488:     {",
          "17489:       if (!strcmp(model, \"DiMAGE A200\"))",
          "17490:         filters = 0x49494949;",
          "17493:     }",
          "17494:     else if (!strncmp(model, \"ALPHA\", 5) || !strncmp(model, \"DYNAX\", 5) || !strncmp(model, \"MAXXUM\", 6))",
          "17495:     {",
          "17496:       sprintf(model + 20, \"DYNAX %-10s\", model + 6 + (model[0] == 'M'));",
          "17497:       adobe_coeff(make, model + 20);",
          "17499:     }",
          "17500:     else if (!strncmp(model, \"DiMAGE G\", 8))",
          "17501:     {",
          "17502:       if (model[8] == '4')",
          "17503:       {",
          "17504:         height = 1716;",
          "17505:         width = 2304;",
          "17506:       }",
          "17507:       else if (model[8] == '5')",
          "17508:       {",
          "17509:       konica_510z:",
          "17510:         height = 1956;",
          "17511:         width = 2607;",
          "17512:         raw_width = 2624;",
          "17513:       }",
          "17514:       else if (model[8] == '6')",
          "17515:       {",
          "17516:         height = 2136;",
          "17517:         width = 2848;",
          "17521:     konica_400z:",
          "17526:   }",
          "17527:   else if (!strcmp(model, \"*ist D\"))",
          "17528:   {",
          "17531:   }",
          "17532:   else if (!strcmp(model, \"*ist DS\"))",
          "17533:   {",
          "17535:   }",
          "17536:   else if (!strncmp(make, \"Samsung\", 7) && raw_width == 4704)",
          "17537:   {",
          "17541:   }",
          "17542:   else if (!strncmp(make, \"Samsung\", 7) && !strcmp(model, \"NX3000\"))",
          "17543:   {",
          "17550:   }",
          "17551:   else if (!strncmp(make, \"Samsung\", 7) && raw_height == 3714)",
          "17552:   {",
          "17559:   }",
          "17560:   else if (!strncmp(make, \"Samsung\", 7) && raw_width == 5632)",
          "17561:   {",
          "17565:     width = 5574 - (left_margin = 32 + tiff_bps);",
          "17566:     if (tiff_bps == 12)",
          "17567:       load_flags = 80;",
          "17568:   }",
          "17569:   else if (!strncmp(make, \"Samsung\", 7) && raw_width == 5664)",
          "17570:   {",
          "17575:   }",
          "17576:   else if (!strncmp(make, \"Samsung\", 7) && raw_width == 6496)",
          "17577:   {",
          "17580:     if (!black && !cblack[0] && !cblack[1] && !cblack[2] && !cblack[3])",
          "17582:       black = 1 << (tiff_bps - 7);",
          "17583:   }",
          "17584:   else if (!strcmp(model, \"EX1\"))",
          "17585:   {",
          "17589:     if ((width -= 6) > 3682)",
          "17590:     {",
          "17592:       width -= 46;",
          "17595:   }",
          "17596:   else if (!strcmp(model, \"WB2000\"))",
          "17597:   {",
          "17601:     if ((width -= 10) > 3718)",
          "17602:     {",
          "17604:       width -= 56;",
          "17607:   }",
          "17608:   else if (strstr(model, \"WB550\"))",
          "17609:   {",
          "17610:     strcpy(model, \"WB550\");",
          "17611:   }",
          "17612:   else if (!strcmp(model, \"EX2F\"))",
          "17613:   {",
          "17615:     width = 4040;",
          "17617:     left_margin = 24;",
          "17621:   }",
          "17622:   else if (!strcmp(model, \"STV680 VGA\"))",
          "17623:   {",
          "17625:   }",
          "17626:   else if (!strcmp(model, \"N95\"))",
          "17627:   {",
          "17629:   }",
          "17630:   else if (!strcmp(model, \"640x480\"))",
          "17631:   {",
          "17632:     gamma_curve(0.45, 4.5, 1, 255);",
          "17633:   }",
          "17634:   else if (!strncmp(make, \"Hasselblad\", 10))",
          "17635:   {",
          "17638:     if (raw_width == 7262)",
          "17639:     {",
          "17641:       width = 7248;",
          "17642:       top_margin = 4;",
          "17645:       if (!strncasecmp(model, \"H3D\", 3))",
          "17646:       {",
          "17647:         adobe_coeff(\"Hasselblad\", \"H3DII-39\");",
          "17648:         strcpy(model, \"H3DII-39\");",
          "17649:       }",
          "17650:     }",
          "17651:     else if (raw_width == 7410 || raw_width == 8282)",
          "17652:     {",
          "17654:       width -= 82;",
          "17655:       top_margin = 4;",
          "17658:       adobe_coeff(\"Hasselblad\", \"H4D-40\");",
          "17659:       strcpy(model, \"H4D-40\");",
          "17661:     else if (raw_width == 8384) // X1D",
          "17663:       top_margin = 96;",
          "17664:       height -= 96;",
          "17665:       left_margin = 48;",
          "17666:       width -= 106;",
          "17667:       adobe_coeff(\"Hasselblad\", \"X1D\");",
          "17669:     else if (raw_width == 9044)",
          "17670:     {",
          "17671:       if (black > 500)",
          "17672:       {",
          "17673:         top_margin = 12;",
          "17674:         left_margin = 44;",
          "17675:         width = 8956;",
          "17676:         height = 6708;",
          "17677:         memset(cblack, 0, sizeof(cblack));",
          "17678:         adobe_coeff(\"Hasselblad\", \"H4D-60\");",
          "17679:         strcpy(model, \"H4D-60\");",
          "17680:         black = 512;",
          "17681:       }",
          "17683:       {",
          "17684:         height = 6716;",
          "17685:         width = 8964;",
          "17686:         top_margin = 8;",
          "17687:         left_margin = 40;",
          "17688:         black += load_flags = 256;",
          "17689:         maximum = 0x8101;",
          "17690:         strcpy(model, \"H3DII-60\");",
          "17691:       }",
          "17692:     }",
          "17693:     else if (raw_width == 4090)",
          "17694:     {",
          "17695:       strcpy(model, \"V96C\");",
          "17699:     }",
          "17700:     else if (raw_width == 8282 && raw_height == 6240)",
          "17701:     {",
          "17702:       if (!strncasecmp(model, \"H5D\", 3))",
          "17703:       {",
          "17705:         left_margin = 54;",
          "17706:         top_margin = 16;",
          "17707:         width = 8176;",
          "17708:         height = 6132;",
          "17709:         black = 256;",
          "17710:         strcpy(model, \"H5D-50\");",
          "17711:       }",
          "17712:       else if (!strncasecmp(model, \"H3D\", 3))",
          "17713:       {",
          "17714:         black = 0;",
          "17715:         left_margin = 54;",
          "17716:         top_margin = 16;",
          "17717:         width = 8176;",
          "17718:         height = 6132;",
          "17719:         memset(cblack, 0, sizeof(cblack));",
          "17720:         adobe_coeff(\"Hasselblad\", \"H3D-50\");",
          "17721:         strcpy(model, \"H3D-50\");",
          "17722:       }",
          "17723:     }",
          "17724:     else if (raw_width == 8374 && raw_height == 6304)",
          "17725:     {",
          "17732:       strcpy(model, \"H5D-50c\");",
          "17734:     if (tiff_samples > 1)",
          "17735:     {",
          "17736:       is_raw = tiff_samples + 1;",
          "17737:       if (!shot_select && !half_size)",
          "17738:         filters = 0;",
          "17740:   }",
          "17741:   else if (!strncmp(make, \"Sinar\", 5))",
          "17742:   {",
          "17743:     if (!load_raw)",
          "17744:       load_raw = &CLASS unpacked_load_raw;",
          "17745:     if (is_raw > 1 && !shot_select && !half_size)",
          "17746:       filters = 0;",
          "17748:   }",
          "17749:   else if (!strncmp(make, \"Leaf\", 4))",
          "17750:   {",
          "17752:     fseek(ifp, data_offset, SEEK_SET);",
          "17753:     if (ljpeg_start(&jh, 1) && jh.bits == 15)",
          "17755:     if (tiff_samples > 1)",
          "17756:       filters = 0;",
          "17757:     if (tiff_samples > 1 || tile_length < raw_height)",
          "17758:     {",
          "17762:     if ((width | height) == 2048)",
          "17763:     {",
          "17764:       if (tiff_samples == 1)",
          "17765:       {",
          "17766:         filters = 1;",
          "17767:         strcpy(cdesc, \"RBTG\");",
          "17768:         strcpy(model, \"CatchLight\");",
          "17769:         top_margin = 8;",
          "17770:         left_margin = 18;",
          "17771:         height = 2032;",
          "17772:         width = 2016;",
          "17773:       }",
          "17774:       else",
          "17775:       {",
          "17776:         strcpy(model, \"DCB2\");",
          "17777:         top_margin = 10;",
          "17778:         left_margin = 16;",
          "17779:         height = 2028;",
          "17780:         width = 2022;",
          "17781:       }",
          "17782:     }",
          "17783:     else if (width + height == 3144 + 2060)",
          "17784:     {",
          "17785:       if (!model[0])",
          "17786:         strcpy(model, \"Cantare\");",
          "17787:       if (width > height)",
          "17788:       {",
          "17789:         top_margin = 6;",
          "17790:         left_margin = 32;",
          "17791:         height = 2048;",
          "17792:         width = 3072;",
          "17793:         filters = 0x61616161;",
          "17794:       }",
          "17795:       else",
          "17796:       {",
          "17797:         left_margin = 6;",
          "17798:         top_margin = 32;",
          "17799:         width = 2048;",
          "17800:         height = 3072;",
          "17801:         filters = 0x16161616;",
          "17802:       }",
          "17803:       if (!cam_mul[0] || model[0] == 'V')",
          "17804:         filters = 0;",
          "17805:       else",
          "17806:         is_raw = tiff_samples;",
          "17807:     }",
          "17808:     else if (width == 2116)",
          "17809:     {",
          "17810:       strcpy(model, \"Valeo 6\");",
          "17814:     }",
          "17815:     else if (width == 3171)",
          "17816:     {",
          "17817:       strcpy(model, \"Valeo 6\");",
          "17822:   }",
          "17823:   else if (!strncmp(make, \"Leica\", 5) || !strncmp(make, \"Panasonic\", 9) || !strncasecmp(make, \"YUNEEC\", 6))",
          "17824:   {",
          "17825:     if (raw_width > 0 && ((flen - data_offset) / (raw_width * 8 / 7) == raw_height))",
          "17827:     if (!load_raw)",
          "17828:     {",
          "17833:     if ((height += 12) > raw_height)",
          "17834:       height = raw_height;",
          "17835:     for (i = 0; i < sizeof pana / sizeof *pana; i++)",
          "17836:       if (raw_width == pana[i][0] && raw_height == pana[i][1])",
          "17837:       {",
          "17838:         left_margin = pana[i][2];",
          "17839:         top_margin = pana[i][3];",
          "17840:         width += pana[i][4];",
          "17841:         height += pana[i][5];",
          "17842:       }",
          "17843:     filters = 0x01010101 * (uchar) \"\\x94\\x61\\x49\\x16\"[((filters - 1) ^ (left_margin & 1) ^ (top_margin << 1)) & 3];",
          "17844:   }",
          "17845:   else if (!strcmp(model, \"C770UZ\"))",
          "17846:   {",
          "17848:     width = 2304;",
          "17852:   }",
          "17853:   else if (!strncmp(make, \"Olympus\", 7))",
          "17854:   {",
          "17856:     if (exif_cfa)",
          "17857:       filters = exif_cfa;",
          "17858:     if (width == 4100)",
          "17859:       width -= 4;",
          "17860:     if (width == 4080)",
          "17861:       width -= 24;",
          "17862:     if (width == 9280)",
          "17863:     {",
          "17864:       width -= 6;",
          "17865:       height -= 6;",
          "17866:     }",
          "17870:     if (!strcmp(model, \"E-300\") || !strcmp(model, \"E-500\"))",
          "17871:     {",
          "17873:       if (load_raw == &CLASS unpacked_load_raw)",
          "17874:       {",
          "17875:         maximum = 0xfc3;",
          "17876:         memset(cblack, 0, sizeof cblack);",
          "17878:     }",
          "17879:     else if (!strcmp(model, \"STYLUS1\"))",
          "17880:     {",
          "17883:     }",
          "17884:     else if (!strcmp(model, \"E-330\"))",
          "17885:     {",
          "17888:         maximum = 0xf79;",
          "17889:     }",
          "17890:     else if (!strcmp(model, \"SP550UZ\"))",
          "17891:     {",
          "17894:       thumb_width = 640;",
          "17895:     }",
          "17896:     else if (!strcmp(model, \"TG-4\"))",
          "17897:     {",
          "17900:   }",
          "17901:   else if (!strcmp(model, \"N Digital\"))",
          "17902:   {",
          "17904:     width = 3072;",
          "17908:   }",
          "17909:   else if (!strcmp(model, \"DSC-F828\"))",
          "17910:   {",
          "",
          "---------------",
          "--- Hunk 117 ---",
          "[Context before]",
          "16413:     load_raw = &CLASS sony_load_raw;",
          "16414:     filters = 0x9c9c9c9c;",
          "16415:     colors = 4;",
          "16418:     width = 3109;",
          "16419:     left_margin = 59;",
          "16420:     mask[0][1] = 9;",
          "16421:     data_offset = 787392;",
          "16422:     load_raw = &CLASS sony_load_raw;",
          "16424:     width = 3925;",
          "16425:     order = 0x4d4d;",
          "16427:     width -= 32;",
          "16431:     width -= height > 3664 ? 8 : 32;",
          "16433:     width -= 24;",
          "16435:       width -= 6;",
          "16437:     width -= 30;",
          "16439:     width -= 32;",
          "16442:       height--;",
          "16443:       width = ++raw_width;",
          "16445:       height -= 4;",
          "16447:       order = 0x4d4d;",
          "16448:       load_flags = 2;",
          "16449:     }",
          "16450:     filters = 0x61616161;",
          "16452:     height -= 4;",
          "16454:     height -= top_margin = 4;",
          "16455:     width -= left_margin = 32;",
          "16459:     order = 0x4949;",
          "16467:     load_flags = tiff_bps > 16;",
          "16468:     tiff_bps = 8;",
          "16470:     data_offset = data_offset < 0x15000 ? 0x15000 : 0x17000;",
          "16471:     load_raw = &CLASS packed_load_raw;",
          "16477:       width -= 4;",
          "16478:       left_margin = 2;",
          "16482:       black = 214;",
          "16483:       goto bw;",
          "16486:       filters = 0;",
          "16487:     }",
          "16492:       data_offset = 15424;",
          "16493:     }",
          "16495:       raw_height = 2 + (height = 242);",
          "16496:       if (!strncmp(model, \"DC290\", 5))",
          "16497:         iso_speed = 100;",
          "16498:       if (!strncmp(model, \"DC280\", 5))",
          "16499:         iso_speed = 70;",
          "16506:       }",
          "16507:       top_margin = left_margin = 1;",
          "16508:       colors = 4;",
          "",
          "[Removed Lines]",
          "16416:     strcpy (cdesc, \"RGBE\");",
          "16417:   } else if (!strcmp(model,\"DSC-V3\")) {",
          "16423:   } else if (!strncmp(make,\"Sony\",4) && raw_width == 3984) {",
          "16426:   } else if (!strncmp(make,\"Sony\",4) && raw_width == 4288) {",
          "16428:   } else if (!strncmp(make,\"Sony\",4) && raw_width == 4928) {",
          "16429:     if (height < 3280) width -= 8;",
          "16430:   } else if (!strncmp(make,\"Sony\",4) && raw_width == 5504) { // ILCE-3000//5000",
          "16432:   } else if (!strncmp(make,\"Sony\",4) && raw_width == 6048) {",
          "16434:     if (strstr(model,\"RX1\") || strstr(model,\"A99\"))",
          "16436:   } else if (!strncmp(make,\"Sony\",4) && raw_width == 7392) {",
          "16438:   } else if (!strncmp(make,\"Sony\",4) && raw_width == 8000) {",
          "16440:   } else if (!strcmp(model,\"DSLR-A100\")) {",
          "16441:     if (width == 3880) {",
          "16444:     } else {",
          "16446:       width  -= 4;",
          "16451:   } else if (!strcmp(model,\"DSLR-A350\")) {",
          "16453:   } else if (!strcmp(model,\"PIXL\")) {",
          "16456:     gamma_curve (0, 7, 1, 255);",
          "16457:   } else if (!strcmp(model,\"C603\") || !strcmp(model,\"C330\")",
          "16458:  || !strcmp(model,\"12MP\")) {",
          "16460:     if (filters && data_offset) {",
          "16461:       fseek (ifp, data_offset < 4096 ? 168 : 5252, SEEK_SET);",
          "16462:       read_shorts (curve, 256);",
          "16463:     } else gamma_curve (0, 3.875, 1, 255);",
          "16464:     load_raw  =  filters   ? &CLASS eight_bit_load_raw :",
          "16465:       strcmp(model,\"C330\") ? &CLASS kodak_c603_load_raw :",
          "16466:         &CLASS kodak_c330_load_raw;",
          "16469:   } else if (!strncasecmp(model,\"EasyShare\",9)) {",
          "16472:   } else if (!strncasecmp(make,\"Kodak\",5)) {",
          "16473:     if (filters == UINT_MAX) filters = 0x61616161;",
          "16474:     if (!strncmp(model,\"NC2000\",6) ||",
          "16475:  !strncmp(model,\"EOSDCS\",6) ||",
          "16476:  !strncmp(model,\"DCS4\",4)) {",
          "16479:       if (model[6] == ' ') model[6] = 0;",
          "16480:       if (!strcmp(model,\"DCS460A\")) goto bw;",
          "16481:     } else if (!strcmp(model,\"DCS660M\")) {",
          "16484:     } else if (!strcmp(model,\"DCS760M\")) {",
          "16485: bw:   colors = 1;",
          "16488:     if (!strcmp(model+4,\"20X\"))",
          "16489:       strcpy (cdesc, \"MYCY\");",
          "16490:     if (strstr(model,\"DC25\")) {",
          "16491:       strcpy (model, \"DC25\");",
          "16494:     if (!strncmp(model,\"DC2\",3)) {",
          "16500:       if (flen < 100000) {",
          "16501:  raw_width = 256; width = 249;",
          "16502:  pixel_aspect = (4.0*height) / (3.0*width);",
          "16503:       } else {",
          "16504:  raw_width = 512; width = 501;",
          "16505:  pixel_aspect = (493.0*height) / (373.0*width);",
          "",
          "[Added Lines]",
          "17918:     strcpy(cdesc, \"RGBE\");",
          "17919:   }",
          "17920:   else if (!strcmp(model, \"DSC-V3\"))",
          "17921:   {",
          "17927:   }",
          "17928:   else if (!strncmp(make, \"Sony\", 4) && raw_width == 3984)",
          "17929:   {",
          "17932:   }",
          "17933:   else if (!strncmp(make, \"Sony\", 4) && raw_width == 4288)",
          "17934:   {",
          "17936:   }",
          "17937:   else if (!strncmp(make, \"Sony\", 4) && raw_width == 4928)",
          "17938:   {",
          "17939:     if (height < 3280)",
          "17940:       width -= 8;",
          "17941:   }",
          "17942:   else if (!strncmp(make, \"Sony\", 4) && raw_width == 5504)",
          "17943:   { // ILCE-3000//5000",
          "17945:   }",
          "17946:   else if (!strncmp(make, \"Sony\", 4) && raw_width == 6048)",
          "17947:   {",
          "17949:     if (strstr(model, \"RX1\") || strstr(model, \"A99\"))",
          "17951:   }",
          "17952:   else if (!strncmp(make, \"Sony\", 4) && raw_width == 7392)",
          "17953:   {",
          "17955:   }",
          "17956:   else if (!strncmp(make, \"Sony\", 4) && raw_width == 8000)",
          "17957:   {",
          "17959:   }",
          "17960:   else if (!strcmp(model, \"DSLR-A100\"))",
          "17961:   {",
          "17962:     if (width == 3880)",
          "17963:     {",
          "17966:     }",
          "17967:     else",
          "17968:     {",
          "17970:       width -= 4;",
          "17975:   }",
          "17976:   else if (!strcmp(model, \"DSLR-A350\"))",
          "17977:   {",
          "17979:   }",
          "17980:   else if (!strcmp(model, \"PIXL\"))",
          "17981:   {",
          "17984:     gamma_curve(0, 7, 1, 255);",
          "17985:   }",
          "17986:   else if (!strcmp(model, \"C603\") || !strcmp(model, \"C330\") || !strcmp(model, \"12MP\"))",
          "17987:   {",
          "17989:     if (filters && data_offset)",
          "17990:     {",
          "17991:       fseek(ifp, data_offset < 4096 ? 168 : 5252, SEEK_SET);",
          "17992:       read_shorts(curve, 256);",
          "17993:     }",
          "17994:     else",
          "17995:       gamma_curve(0, 3.875, 1, 255);",
          "17996:     load_raw = filters ? &CLASS eight_bit_load_raw",
          "17997:                        : strcmp(model, \"C330\") ? &CLASS kodak_c603_load_raw : &CLASS kodak_c330_load_raw;",
          "18000:   }",
          "18001:   else if (!strncasecmp(model, \"EasyShare\", 9))",
          "18002:   {",
          "18005:   }",
          "18006:   else if (!strncasecmp(make, \"Kodak\", 5))",
          "18007:   {",
          "18008:     if (filters == UINT_MAX)",
          "18009:       filters = 0x61616161;",
          "18010:     if (!strncmp(model, \"NC2000\", 6) || !strncmp(model, \"EOSDCS\", 6) || !strncmp(model, \"DCS4\", 4))",
          "18011:     {",
          "18014:       if (model[6] == ' ')",
          "18015:         model[6] = 0;",
          "18016:       if (!strcmp(model, \"DCS460A\"))",
          "18017:         goto bw;",
          "18018:     }",
          "18019:     else if (!strcmp(model, \"DCS660M\"))",
          "18020:     {",
          "18023:     }",
          "18024:     else if (!strcmp(model, \"DCS760M\"))",
          "18025:     {",
          "18026:     bw:",
          "18027:       colors = 1;",
          "18030:     if (!strcmp(model + 4, \"20X\"))",
          "18031:       strcpy(cdesc, \"MYCY\");",
          "18032:     if (strstr(model, \"DC25\"))",
          "18033:     {",
          "18034:       strcpy(model, \"DC25\");",
          "18037:     if (!strncmp(model, \"DC2\", 3))",
          "18038:     {",
          "18044:       if (flen < 100000)",
          "18045:       {",
          "18046:         raw_width = 256;",
          "18047:         width = 249;",
          "18048:         pixel_aspect = (4.0 * height) / (3.0 * width);",
          "18049:       }",
          "18050:       else",
          "18051:       {",
          "18052:         raw_width = 512;",
          "18053:         width = 501;",
          "18054:         pixel_aspect = (493.0 * height) / (373.0 * width);",
          "",
          "---------------",
          "--- Hunk 118 ---",
          "[Context before]",
          "16512:       pre_mul[2] = 1.209;",
          "16513:       pre_mul[3] = 1.036;",
          "16514:       load_raw = &CLASS eight_bit_load_raw;",
          "16517:       height = 512;",
          "16519:       data_offset = 1152;",
          "16520:       load_raw = &CLASS kodak_radc_load_raw;",
          "16521:       tiff_bps = 12;",
          "16524:       height = 512;",
          "16527:       data_offset = 19712;",
          "16528:       load_raw = &CLASS kodak_radc_load_raw;",
          "16531:       height = 976;",
          "16538:       thumb_height = 128;",
          "16540:       thumb_offset = 6144;",
          "16543:       write_thumb = &CLASS layer_thumb;",
          "16544:       black = 17;",
          "16545:     }",
          "16547:     height = 512;",
          "16549:     data_offset = 3632;",
          "16550:     load_raw = &CLASS kodak_radc_load_raw;",
          "16551:     filters = 0x61616161;",
          "16552:     simple_coeff(2);",
          "16556:     height = get2();",
          "16563:     }",
          "16564:     filters = 0x61616161;",
          "16578:     }",
          "16579:     filters = 0x16161616;",
          "16580:     load_raw = &CLASS rollei_load_raw;",
          "16581:   }",
          "16614:   }",
          "16616:   if (!load_raw || height < 22 || width < 22 ||",
          "16617: #ifdef LIBRAW_LIBRARY_BUILD",
          "16618:       (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)",
          "16619: #else",
          "16621: #endif",
          "16622:       || tiff_samples > 4 || colors > 4 || colors < 1)",
          "16625: #ifdef LIBRAW_LIBRARY_BUILD",
          "16627: #endif",
          "16630:   if (!model[0])",
          "16637:       thumb_height = jh.high;",
          "16638:     }",
          "16639:   }",
          "16641: dng_skip:",
          "16642: #ifdef LIBRAW_LIBRARY_BUILD",
          "16644:   {",
          "16645:     black = imgdata.color.dng_levels.dng_black;",
          "16650:       cblack[i] = imgdata.color.dng_levels.dng_cblack[i];",
          "16651:   }",
          "16652: #endif",
          "",
          "[Removed Lines]",
          "16515:     } else if (!strcmp(model,\"40\")) {",
          "16516:       strcpy (model, \"DC40\");",
          "16518:       width  = 768;",
          "16522:     } else if (strstr(model,\"DC50\")) {",
          "16523:       strcpy (model, \"DC50\");",
          "16525:       width  = 768;",
          "16526:       iso_speed=84;",
          "16529:     } else if (strstr(model,\"DC120\")) {",
          "16530:       strcpy (model, \"DC120\");",
          "16532:       width  = 848;",
          "16533:       iso_speed=160;",
          "16534:       pixel_aspect = height/0.75/width;",
          "16535:       load_raw = tiff_compress == 7 ?",
          "16536:  &CLASS kodak_jpeg_load_raw : &CLASS kodak_dc120_load_raw;",
          "16537:     } else if (!strcmp(model,\"DCS200\")) {",
          "16539:       thumb_width  = 192;",
          "16541:       thumb_misc   = 360;",
          "16542:       iso_speed=140;",
          "16546:   } else if (!strcmp(model,\"Fotoman Pixtura\")) {",
          "16548:     width  = 768;",
          "16553:   } else if (!strncmp(model,\"QuickTake\",9)) {",
          "16554:     if (head[5]) strcpy (model+10, \"200\");",
          "16555:     fseek (ifp, 544, SEEK_SET);",
          "16557:     width  = get2();",
          "16558:     data_offset = (get4(),get2()) == 30 ? 738:736;",
          "16559:     if (height > width) {",
          "16560:       SWAP(height,width);",
          "16561:       fseek (ifp, data_offset-6, SEEK_SET);",
          "16562:       flip = ~get2() & 3 ? 5:6;",
          "16565:   } else if (!strncmp(make,\"Rollei\",6) && !load_raw) {",
          "16566:     switch (raw_width) {",
          "16567:       case 1316:",
          "16568:  height = 1030;",
          "16569:  width  = 1300;",
          "16570:  top_margin  = 1;",
          "16571:  left_margin = 6;",
          "16572:  break;",
          "16573:       case 2568:",
          "16574:  height = 1960;",
          "16575:  width  = 2560;",
          "16576:  top_margin  = 2;",
          "16577:  left_margin = 8;",
          "16582:   else if (!strcmp(model,\"GRAS-50S5C\")) {",
          "16583:    height = 2048;",
          "16584:    width = 2440;",
          "16585:    load_raw = &CLASS unpacked_load_raw;",
          "16586:    data_offset = 0;",
          "16587:    filters = 0x49494949;",
          "16588:    order = 0x4949;",
          "16589:    maximum = 0xfffC;",
          "16590:   } else if (!strcmp(model,\"BB-500CL\")) {",
          "16591:    height = 2058;",
          "16592:    width = 2448;",
          "16593:    load_raw = &CLASS unpacked_load_raw;",
          "16594:    data_offset = 0;",
          "16595:    filters = 0x94949494;",
          "16596:    order = 0x4949;",
          "16597:    maximum = 0x3fff;",
          "16598:   } else if (!strcmp(model,\"BB-500GE\")) {",
          "16599:    height = 2058;",
          "16600:    width = 2456;",
          "16601:    load_raw = &CLASS unpacked_load_raw;",
          "16602:    data_offset = 0;",
          "16603:    filters = 0x94949494;",
          "16604:    order = 0x4949;",
          "16605:    maximum = 0x3fff;",
          "16606:   } else if (!strcmp(model,\"SVS625CL\")) {",
          "16607:    height = 2050;",
          "16608:    width = 2448;",
          "16609:    load_raw = &CLASS unpacked_load_raw;",
          "16610:    data_offset = 0;",
          "16611:    filters = 0x94949494;",
          "16612:    order = 0x4949;",
          "16613:    maximum = 0x0fff;",
          "16620:  tiff_bps > 16",
          "16623:     {",
          "16624:       is_raw = 0;",
          "16626:       RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,1,2);",
          "16628:       return;",
          "16629:     }",
          "16631:     sprintf (model, \"%dx%d\", width, height);",
          "16632:   if (filters == UINT_MAX) filters = 0x94949494;",
          "16633:   if (thumb_offset && !thumb_height) {",
          "16634:     fseek (ifp, thumb_offset, SEEK_SET);",
          "16635:     if (ljpeg_start (&jh, 1)) {",
          "16636:       thumb_width  = jh.wide;",
          "16646:     int ll = LIM(0,",
          "16647:     (sizeof(cblack)/sizeof(cblack[0])),",
          "16648:     (sizeof(imgdata.color.dng_levels.dng_cblack)/sizeof(imgdata.color.dng_levels.dng_cblack[0])));",
          "16649:     for(int i=0; i < ll; i++)",
          "",
          "[Added Lines]",
          "18064:     }",
          "18065:     else if (!strcmp(model, \"40\"))",
          "18066:     {",
          "18067:       strcpy(model, \"DC40\");",
          "18069:       width = 768;",
          "18073:     }",
          "18074:     else if (strstr(model, \"DC50\"))",
          "18075:     {",
          "18076:       strcpy(model, \"DC50\");",
          "18078:       width = 768;",
          "18079:       iso_speed = 84;",
          "18082:     }",
          "18083:     else if (strstr(model, \"DC120\"))",
          "18084:     {",
          "18085:       strcpy(model, \"DC120\");",
          "18087:       width = 848;",
          "18088:       iso_speed = 160;",
          "18089:       pixel_aspect = height / 0.75 / width;",
          "18090:       load_raw = tiff_compress == 7 ? &CLASS kodak_jpeg_load_raw : &CLASS kodak_dc120_load_raw;",
          "18091:     }",
          "18092:     else if (!strcmp(model, \"DCS200\"))",
          "18093:     {",
          "18095:       thumb_width = 192;",
          "18097:       thumb_misc = 360;",
          "18098:       iso_speed = 140;",
          "18102:   }",
          "18103:   else if (!strcmp(model, \"Fotoman Pixtura\"))",
          "18104:   {",
          "18106:     width = 768;",
          "18111:   }",
          "18112:   else if (!strncmp(model, \"QuickTake\", 9))",
          "18113:   {",
          "18114:     if (head[5])",
          "18115:       strcpy(model + 10, \"200\");",
          "18116:     fseek(ifp, 544, SEEK_SET);",
          "18118:     width = get2();",
          "18119:     data_offset = (get4(), get2()) == 30 ? 738 : 736;",
          "18120:     if (height > width)",
          "18121:     {",
          "18122:       SWAP(height, width);",
          "18123:       fseek(ifp, data_offset - 6, SEEK_SET);",
          "18124:       flip = ~get2() & 3 ? 5 : 6;",
          "18127:   }",
          "18128:   else if (!strncmp(make, \"Rollei\", 6) && !load_raw)",
          "18129:   {",
          "18130:     switch (raw_width)",
          "18131:     {",
          "18132:     case 1316:",
          "18133:       height = 1030;",
          "18134:       width = 1300;",
          "18135:       top_margin = 1;",
          "18136:       left_margin = 6;",
          "18137:       break;",
          "18138:     case 2568:",
          "18139:       height = 1960;",
          "18140:       width = 2560;",
          "18141:       top_margin = 2;",
          "18142:       left_margin = 8;",
          "18147:   else if (!strcmp(model, \"GRAS-50S5C\"))",
          "18148:   {",
          "18149:     height = 2048;",
          "18150:     width = 2440;",
          "18151:     load_raw = &CLASS unpacked_load_raw;",
          "18152:     data_offset = 0;",
          "18153:     filters = 0x49494949;",
          "18154:     order = 0x4949;",
          "18155:     maximum = 0xfffC;",
          "18156:   }",
          "18157:   else if (!strcmp(model, \"BB-500CL\"))",
          "18158:   {",
          "18159:     height = 2058;",
          "18160:     width = 2448;",
          "18161:     load_raw = &CLASS unpacked_load_raw;",
          "18162:     data_offset = 0;",
          "18163:     filters = 0x94949494;",
          "18164:     order = 0x4949;",
          "18165:     maximum = 0x3fff;",
          "18166:   }",
          "18167:   else if (!strcmp(model, \"BB-500GE\"))",
          "18168:   {",
          "18169:     height = 2058;",
          "18170:     width = 2456;",
          "18171:     load_raw = &CLASS unpacked_load_raw;",
          "18172:     data_offset = 0;",
          "18173:     filters = 0x94949494;",
          "18174:     order = 0x4949;",
          "18175:     maximum = 0x3fff;",
          "18176:   }",
          "18177:   else if (!strcmp(model, \"SVS625CL\"))",
          "18178:   {",
          "18179:     height = 2050;",
          "18180:     width = 2448;",
          "18181:     load_raw = &CLASS unpacked_load_raw;",
          "18182:     data_offset = 0;",
          "18183:     filters = 0x94949494;",
          "18184:     order = 0x4949;",
          "18185:     maximum = 0x0fff;",
          "18192:       tiff_bps > 16",
          "18195:   {",
          "18196:     is_raw = 0;",
          "18198:     RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);",
          "18200:     return;",
          "18201:   }",
          "18203:     sprintf(model, \"%dx%d\", width, height);",
          "18204:   if (filters == UINT_MAX)",
          "18205:     filters = 0x94949494;",
          "18206:   if (thumb_offset && !thumb_height)",
          "18207:   {",
          "18208:     fseek(ifp, thumb_offset, SEEK_SET);",
          "18209:     if (ljpeg_start(&jh, 1))",
          "18210:     {",
          "18211:       thumb_width = jh.wide;",
          "18221:     int ll = LIM(0, (sizeof(cblack) / sizeof(cblack[0])),",
          "18222:                  (sizeof(imgdata.color.dng_levels.dng_cblack) / sizeof(imgdata.color.dng_levels.dng_cblack[0])));",
          "18223:     for (int i = 0; i < ll; i++)",
          "",
          "---------------",
          "--- Hunk 119 ---",
          "[Context before]",
          "16655: #ifdef LIBRAW_LIBRARY_BUILD",
          "16656:       (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)",
          "16657: #else",
          "16659: #endif",
          "16660:       || tiff_samples > 4 || colors > 4 || colors < 1)",
          "16663: #ifdef LIBRAW_LIBRARY_BUILD",
          "16665: #endif",
          "16671:     raw_color = 0;",
          "16672:   }",
          "16675: #ifdef LIBRAW_LIBRARY_BUILD",
          "16678: #endif",
          "16680:   if (load_raw == &CLASS kodak_radc_load_raw)",
          "16684:     fuji_width = width >> !fuji_layout;",
          "16685:     filters = fuji_width & 1 ? 0x94949494 : 0x49494949;",
          "16686:     width = (height >> fuji_layout) + fuji_width;",
          "16687:     height = width - 1;",
          "16688:     pixel_aspect = 1;",
          "16692:   }",
          "16694:   if (!maximum)",
          "16700:   if (!load_raw || height < 22 || width < 22 ||",
          "16701: #ifdef LIBRAW_LIBRARY_BUILD",
          "16702:       (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)",
          "16703: #else",
          "16705: #endif",
          "16706:       || tiff_samples > 6 || colors > 4)",
          "16707:     is_raw = 0;",
          "16710:     is_raw = 0;",
          "16712: #ifdef NO_JASPER",
          "16714: #ifdef DCRAW_VERBOSE",
          "16717: #endif",
          "16718:     is_raw = 0;",
          "16719: #ifdef LIBRAW_LIBRARY_BUILD",
          "",
          "[Removed Lines]",
          "16658:  tiff_bps > 16",
          "16661:     {",
          "16662:       is_raw = 0;",
          "16664:       RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,1,2);",
          "16666:       return;",
          "16667:     }",
          "16668:   if ((use_camera_matrix & ((use_camera_wb || dng_version) | 0x2) )",
          "16669:  && cmatrix[0][0] > 0.125) {",
          "16670:     memcpy (rgb_cam, cmatrix, sizeof cmatrix);",
          "16674:   if (raw_color) adobe_coeff (make, model);",
          "16676:   else if(imgdata.color.cam_xyz[0][0]<0.01)",
          "16677:    adobe_coeff (make, model,1);",
          "16681:     if (raw_color) adobe_coeff (\"Apple\",\"Quicktake\");",
          "16683:   if (fuji_width) {",
          "16689:   } else {",
          "16690:     if (raw_height < height) raw_height = height;",
          "16691:     if (raw_width  < width ) raw_width  = width;",
          "16693:   if (!tiff_bps) tiff_bps = 12;",
          "16695:     {",
          "16696:       maximum = (1 << tiff_bps) - 1;",
          "16697:       if(maximum < 0x10000 && curve[maximum]>0 &&    load_raw == &CLASS sony_arw2_load_raw)",
          "16698:         maximum = curve[maximum];",
          "16699:     }",
          "16704:  tiff_bps > 16",
          "16709:   if(raw_width < 22 || raw_width > 64000 || raw_height < 22 || raw_width > 64000)",
          "16713:   if (load_raw == &CLASS redcine_load_raw) {",
          "16715:     fprintf (stderr,_(\"%s: You must link dcraw with %s!!\\n\"),",
          "16716:  ifname, \"libjasper\");",
          "",
          "[Added Lines]",
          "18232:       tiff_bps > 16",
          "18235:   {",
          "18236:     is_raw = 0;",
          "18238:     RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);",
          "18240:     return;",
          "18241:   }",
          "18242:   if ((use_camera_matrix & ((use_camera_wb || dng_version) | 0x2)) && cmatrix[0][0] > 0.125)",
          "18243:   {",
          "18244:     memcpy(rgb_cam, cmatrix, sizeof cmatrix);",
          "18248:   if (raw_color)",
          "18249:     adobe_coeff(make, model);",
          "18251:   else if (imgdata.color.cam_xyz[0][0] < 0.01)",
          "18252:     adobe_coeff(make, model, 1);",
          "18256:     if (raw_color)",
          "18257:       adobe_coeff(\"Apple\", \"Quicktake\");",
          "18259:   if (fuji_width)",
          "18260:   {",
          "18267:   else",
          "18268:   {",
          "18269:     if (raw_height < height)",
          "18270:       raw_height = height;",
          "18271:     if (raw_width < width)",
          "18272:       raw_width = width;",
          "18273:   }",
          "18274:   if (!tiff_bps)",
          "18275:     tiff_bps = 12;",
          "18277:   {",
          "18278:     maximum = (1 << tiff_bps) - 1;",
          "18279:     if (maximum < 0x10000 && curve[maximum] > 0 && load_raw == &CLASS sony_arw2_load_raw)",
          "18280:       maximum = curve[maximum];",
          "18281:   }",
          "18286:       tiff_bps > 16",
          "18291:   if (raw_width < 22 || raw_width > 64000 || raw_height < 22 || raw_width > 64000)",
          "18295:   if (load_raw == &CLASS redcine_load_raw)",
          "18296:   {",
          "18298:     fprintf(stderr, _(\"%s: You must link dcraw with %s!!\\n\"), ifname, \"libjasper\");",
          "",
          "---------------",
          "--- Hunk 120 ---",
          "[Context before]",
          "16722:   }",
          "16723: #endif",
          "16724: #ifdef NO_JPEG",
          "16727: #ifdef DCRAW_VERBOSE",
          "16730: #endif",
          "16731:     is_raw = 0;",
          "16732: #ifdef LIBRAW_LIBRARY_BUILD",
          "",
          "[Removed Lines]",
          "16725:   if (load_raw == &CLASS kodak_jpeg_load_raw ||",
          "16726:       load_raw == &CLASS lossy_dng_load_raw) {",
          "16728:     fprintf (stderr,_(\"%s: You must link dcraw with %s!!\\n\"),",
          "16729:  ifname, \"libjpeg\");",
          "",
          "[Added Lines]",
          "18307:   if (load_raw == &CLASS kodak_jpeg_load_raw || load_raw == &CLASS lossy_dng_load_raw)",
          "18308:   {",
          "18310:     fprintf(stderr, _(\"%s: You must link dcraw with %s!!\\n\"), ifname, \"libjpeg\");",
          "",
          "---------------",
          "--- Hunk 121 ---",
          "[Context before]",
          "16735:   }",
          "16736: #endif",
          "16737:   if (!cdesc[0])",
          "16741:   if (filters > 999 && colors == 3)",
          "16744: notraw:",
          "16759: #ifdef LIBRAW_LIBRARY_BUILD",
          "16761: #endif",
          "16762: }",
          "16768: #ifndef NO_LCMS",
          "16770: {",
          "16771:   char *prof;",
          "16773:   cmsHTRANSFORM hTransform;",
          "16774:   FILE *fp;",
          "16775:   unsigned size;",
          "16780: #ifndef LIBRAW_LIBRARY_BUILD",
          "16787: #else",
          "16789: #endif",
          "16792: #ifdef LIBRAW_LIBRARY_BUILD",
          "16794: #endif",
          "16795: #ifdef DCRAW_VERBOSE",
          "16797: #endif",
          "16799:   if (!hInProfile)",
          "16801: #ifdef LIBRAW_LIBRARY_BUILD",
          "16803: #endif",
          "16806:   if (!output)",
          "16807:     hOutProfile = cmsCreate_sRGBProfile();",
          "16817:       oprof = 0;",
          "16818:     }",
          "16819:   }",
          "16820: #ifdef DCRAW_VERBOSE",
          "16823: #endif",
          "16824:   if (!hOutProfile)",
          "16826: #ifdef LIBRAW_LIBRARY_BUILD",
          "16828: #endif",
          "16831: #ifdef DCRAW_VERBOSE",
          "16832:   if (verbose)",
          "16834: #endif",
          "16835: #ifdef LIBRAW_LIBRARY_BUILD",
          "16837: #endif",
          "16844: quit:",
          "16846: #ifdef LIBRAW_LIBRARY_BUILD",
          "16848: #endif",
          "16849: }",
          "16850: #endif",
          "",
          "[Removed Lines]",
          "16738:     strcpy (cdesc, colors == 3 ? \"RGBG\":\"GMCY\");",
          "16739:   if (!raw_height) raw_height = height;",
          "16740:   if (!raw_width ) raw_width  = width;",
          "16742:     filters |= ((filters >> 2 & 0x22222222) |",
          "16743:   (filters << 2 & 0x88888888)) & filters << 1;",
          "16745:   if (flip == UINT_MAX) flip = tiff_flip;",
          "16746:   if (flip == UINT_MAX) flip = 0;",
          "16749:   if(flip > 89 || flip < -89)",
          "16750:    {",
          "16751:      switch ((flip+3600) % 360)",
          "16752:      {",
          "16753:        case 270:  flip = 5;  break;",
          "16754:        case 180:  flip = 3;  break;",
          "16755:        case  90:  flip = 6;  break;",
          "16756:      }",
          "16757:    }",
          "16760:   RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,1,2);",
          "16769: void CLASS apply_profile (const char *input, const char *output)",
          "16772:   cmsHPROFILE hInProfile=0, hOutProfile=0;",
          "16777:   if (strcmp (input, \"embed\"))",
          "16778:     hInProfile = cmsOpenProfileFromFile (input, \"r\");",
          "16779:   else if (profile_length) {",
          "16781:     prof = (char *) malloc (profile_length);",
          "16782:     merror (prof, \"apply_profile()\");",
          "16783:     fseek (ifp, profile_offset, SEEK_SET);",
          "16784:     fread (prof, 1, profile_length, ifp);",
          "16785:     hInProfile = cmsOpenProfileFromMem (prof, profile_length);",
          "16786:     free (prof);",
          "16788:     hInProfile = cmsOpenProfileFromMem (imgdata.color.profile, profile_length);",
          "16790:   } else",
          "16791:     {",
          "16793:           imgdata.process_warnings |= LIBRAW_WARN_NO_EMBEDDED_PROFILE;",
          "16796:           fprintf (stderr,_(\"%s has no embedded profile.\\n\"), ifname);",
          "16798:     }",
          "16800:       {",
          "16802:           imgdata.process_warnings |= LIBRAW_WARN_NO_INPUT_PROFILE;",
          "16804:           return;",
          "16805:       }",
          "16808:   else if ((fp = fopen (output, \"rb\"))) {",
          "16809:     fread (&size, 4, 1, fp);",
          "16810:     fseek (fp, 0, SEEK_SET);",
          "16811:     oprof = (unsigned *) malloc (size = ntohl(size));",
          "16812:     merror (oprof, \"apply_profile()\");",
          "16813:     fread (oprof, 1, size, fp);",
          "16814:     fclose (fp);",
          "16815:     if (!(hOutProfile = cmsOpenProfileFromMem (oprof, size))) {",
          "16816:       free (oprof);",
          "16821:  else",
          "16822:     fprintf (stderr,_(\"Cannot open file %s!\\n\"), output);",
          "16825:       {",
          "16827:           imgdata.process_warnings |= LIBRAW_WARN_BAD_OUTPUT_PROFILE;",
          "16829:           goto quit;",
          "16830:       }",
          "16833:     fprintf (stderr,_(\"Applying color profile...\\n\"));",
          "16836:   RUN_CALLBACK(LIBRAW_PROGRESS_APPLY_PROFILE,0,2);",
          "16838:   hTransform = cmsCreateTransform (hInProfile, TYPE_RGBA_16,",
          "16839:  hOutProfile, TYPE_RGBA_16, INTENT_PERCEPTUAL, 0);",
          "16840:   cmsDoTransform (hTransform, image, image, width*height);",
          "16842:   cmsDeleteTransform (hTransform);",
          "16843:   cmsCloseProfile (hOutProfile);",
          "16845:   cmsCloseProfile (hInProfile);",
          "16847:   RUN_CALLBACK(LIBRAW_PROGRESS_APPLY_PROFILE,1,2);",
          "",
          "[Added Lines]",
          "18319:     strcpy(cdesc, colors == 3 ? \"RGBG\" : \"GMCY\");",
          "18320:   if (!raw_height)",
          "18321:     raw_height = height;",
          "18322:   if (!raw_width)",
          "18323:     raw_width = width;",
          "18325:     filters |= ((filters >> 2 & 0x22222222) | (filters << 2 & 0x88888888)) & filters << 1;",
          "18327:   if (flip == UINT_MAX)",
          "18328:     flip = tiff_flip;",
          "18329:   if (flip == UINT_MAX)",
          "18330:     flip = 0;",
          "18333:   if (flip > 89 || flip < -89)",
          "18334:   {",
          "18335:     switch ((flip + 3600) % 360)",
          "18336:     {",
          "18337:     case 270:",
          "18338:       flip = 5;",
          "18339:       break;",
          "18340:     case 180:",
          "18341:       flip = 3;",
          "18342:       break;",
          "18343:     case 90:",
          "18344:       flip = 6;",
          "18345:       break;",
          "18346:     }",
          "18347:   }",
          "18350:   RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);",
          "18358: void CLASS apply_profile(const char *input, const char *output)",
          "18361:   cmsHPROFILE hInProfile = 0, hOutProfile = 0;",
          "18366:   if (strcmp(input, \"embed\"))",
          "18367:     hInProfile = cmsOpenProfileFromFile(input, \"r\");",
          "18368:   else if (profile_length)",
          "18369:   {",
          "18371:     prof = (char *)malloc(profile_length);",
          "18372:     merror(prof, \"apply_profile()\");",
          "18373:     fseek(ifp, profile_offset, SEEK_SET);",
          "18374:     fread(prof, 1, profile_length, ifp);",
          "18375:     hInProfile = cmsOpenProfileFromMem(prof, profile_length);",
          "18376:     free(prof);",
          "18378:     hInProfile = cmsOpenProfileFromMem(imgdata.color.profile, profile_length);",
          "18380:   }",
          "18381:   else",
          "18382:   {",
          "18384:     imgdata.process_warnings |= LIBRAW_WARN_NO_EMBEDDED_PROFILE;",
          "18387:     fprintf(stderr, _(\"%s has no embedded profile.\\n\"), ifname);",
          "18389:   }",
          "18391:   {",
          "18393:     imgdata.process_warnings |= LIBRAW_WARN_NO_INPUT_PROFILE;",
          "18395:     return;",
          "18396:   }",
          "18399:   else if ((fp = fopen(output, \"rb\")))",
          "18400:   {",
          "18401:     fread(&size, 4, 1, fp);",
          "18402:     fseek(fp, 0, SEEK_SET);",
          "18403:     oprof = (unsigned *)malloc(size = ntohl(size));",
          "18404:     merror(oprof, \"apply_profile()\");",
          "18405:     fread(oprof, 1, size, fp);",
          "18406:     fclose(fp);",
          "18407:     if (!(hOutProfile = cmsOpenProfileFromMem(oprof, size)))",
          "18408:     {",
          "18409:       free(oprof);",
          "18414:   else",
          "18415:     fprintf(stderr, _(\"Cannot open file %s!\\n\"), output);",
          "18418:   {",
          "18420:     imgdata.process_warnings |= LIBRAW_WARN_BAD_OUTPUT_PROFILE;",
          "18422:     goto quit;",
          "18423:   }",
          "18426:     fprintf(stderr, _(\"Applying color profile...\\n\"));",
          "18429:   RUN_CALLBACK(LIBRAW_PROGRESS_APPLY_PROFILE, 0, 2);",
          "18431:   hTransform = cmsCreateTransform(hInProfile, TYPE_RGBA_16, hOutProfile, TYPE_RGBA_16, INTENT_PERCEPTUAL, 0);",
          "18432:   cmsDoTransform(hTransform, image, image, width * height);",
          "18434:   cmsDeleteTransform(hTransform);",
          "18435:   cmsCloseProfile(hOutProfile);",
          "18437:   cmsCloseProfile(hInProfile);",
          "18439:   RUN_CALLBACK(LIBRAW_PROGRESS_APPLY_PROFILE, 1, 2);",
          "",
          "---------------",
          "--- Hunk 122 ---",
          "[Context before]",
          "16856: #ifndef LIBRAW_LIBRARY_BUILD",
          "16857:   int row, col, c;",
          "16858: #endif",
          "16860: #ifndef LIBRAW_LIBRARY_BUILD",
          "16861:   ushort *img;",
          "16862:   float out[3];",
          "16863: #endif",
          "16864:   float out_cam[3][4];",
          "16865:   double num, inverse[3][3];",
          "16914: #ifndef LIBRAW_LIBRARY_BUILD",
          "16917: #else",
          "16946:       oprof[i] = htonl(oprof[i]);",
          "16953:   }",
          "16954: #ifdef DCRAW_VERBOSE",
          "16955:   if (verbose)",
          "16958: #endif",
          "16959: #ifdef LIBRAW_LIBRARY_BUILD",
          "16960:   convert_to_rgb_loop(out_cam);",
          "16961: #else",
          "16973:       }",
          "16974:       else if (document_mode)",
          "16976:       FORCC histogram[c][img[c] >> 3]++;",
          "16977:     }",
          "16978: #endif",
          "16980: #ifndef LIBRAW_LIBRARY_BUILD",
          "16982: #endif",
          "16983: #ifdef LIBRAW_LIBRARY_BUILD",
          "16985: #endif",
          "16986: }",
          "",
          "[Removed Lines]",
          "16859:   int  i, j, k;",
          "16866:   static const double xyzd50_srgb[3][3] =",
          "16867:   { { 0.436083, 0.385083, 0.143055 },",
          "16868:     { 0.222507, 0.716888, 0.060608 },",
          "16869:     { 0.013930, 0.097097, 0.714022 } };",
          "16870:   static const double rgb_rgb[3][3] =",
          "16871:   { { 1,0,0 }, { 0,1,0 }, { 0,0,1 } };",
          "16872:   static const double adobe_rgb[3][3] =",
          "16873:   { { 0.715146, 0.284856, 0.000000 },",
          "16874:     { 0.000000, 1.000000, 0.000000 },",
          "16875:     { 0.000000, 0.041166, 0.958839 } };",
          "16876:   static const double wide_rgb[3][3] =",
          "16877:   { { 0.593087, 0.404710, 0.002206 },",
          "16878:     { 0.095413, 0.843149, 0.061439 },",
          "16879:     { 0.011621, 0.069091, 0.919288 } };",
          "16880:   static const double prophoto_rgb[3][3] =",
          "16881:   { { 0.529317, 0.330092, 0.140588 },",
          "16882:     { 0.098368, 0.873465, 0.028169 },",
          "16883:     { 0.016879, 0.117663, 0.865457 } };",
          "16884:   static const double aces_rgb[3][3] =",
          "16885:   { { 0.432996, 0.375380, 0.189317 },",
          "16886:     { 0.089427, 0.816523, 0.102989 },",
          "16887:     { 0.019165, 0.118150, 0.941914 } };",
          "16888:   static const double (*out_rgb[])[3] =",
          "16889:   { rgb_rgb, adobe_rgb, wide_rgb, prophoto_rgb, xyz_rgb, aces_rgb };",
          "16890:   static const char *name[] =",
          "16891:   { \"sRGB\", \"Adobe RGB (1998)\", \"WideGamut D65\", \"ProPhoto D65\", \"XYZ\", \"ACES\" };",
          "16892:   static const unsigned phead[] =",
          "16893:   { 1024, 0, 0x2100000, 0x6d6e7472, 0x52474220, 0x58595a20, 0, 0, 0,",
          "16894:     0x61637370, 0, 0, 0x6e6f6e65, 0, 0, 0, 0, 0xf6d6, 0x10000, 0xd32d };",
          "16895:   unsigned pbody[] =",
          "16906:   static const unsigned pwhite[] = { 0xf351, 0x10000, 0x116cc };",
          "16907:   unsigned pcurve[] = { 0x63757276, 0, 1, 0x1000000 };",
          "16909: #ifdef LIBRAW_LIBRARY_BUILD",
          "16910:   RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB,0,2);",
          "16911: #endif",
          "16912:   gamma_curve (gamm[0], gamm[1], 0, 0);",
          "16913:   memcpy (out_cam, rgb_cam, sizeof out_cam);",
          "16915:   raw_color |= colors == 1 || document_mode ||",
          "16916:   output_color < 1 || output_color > 6;",
          "16918:   raw_color |= colors == 1 ||",
          "16919:   output_color < 1 || output_color > 6;",
          "16920: #endif",
          "16921:   if (!raw_color) {",
          "16922:     oprof = (unsigned *) calloc (phead[0], 1);",
          "16923:     merror (oprof, \"convert_to_rgb()\");",
          "16924:     memcpy (oprof, phead, sizeof phead);",
          "16925:     if (output_color == 5) oprof[4] = oprof[5];",
          "16926:     oprof[0] = 132 + 12*pbody[0];",
          "16927:     for (i=0; i < pbody[0]; i++) {",
          "16928:       oprof[oprof[0]/4] = i ? (i > 1 ? 0x58595a20 : 0x64657363) : 0x74657874;",
          "16929:       pbody[i*3+2] = oprof[0];",
          "16930:       oprof[0] += (pbody[i*3+3] + 3) & -4;",
          "16931:     }",
          "16932:     memcpy (oprof+32, pbody, sizeof pbody);",
          "16933:     oprof[pbody[5]/4+2] = strlen(name[output_color-1]) + 1;",
          "16934:     memcpy ((char *)oprof+pbody[8]+8, pwhite, sizeof pwhite);",
          "16935:     pcurve[3] = (short)(256/gamm[5]+0.5) << 16;",
          "16936:     for (i=4; i < 7; i++)",
          "16937:       memcpy ((char *)oprof+pbody[i*3+2], pcurve, sizeof pcurve);",
          "16938:     pseudoinverse ((double (*)[3]) out_rgb[output_color-1], inverse, 3);",
          "16939:     for (i=0; i < 3; i++)",
          "16940:       for (j=0; j < 3; j++) {",
          "16941:  for (num = k=0; k < 3; k++)",
          "16942:    num += xyzd50_srgb[i][k] * inverse[j][k];",
          "16943:  oprof[pbody[j*3+23]/4+i+2] = num * 0x10000 + 0.5;",
          "16944:       }",
          "16945:     for (i=0; i < phead[0]/4; i++)",
          "16947:     strcpy ((char *)oprof+pbody[2]+8, \"auto-generated by dcraw\");",
          "16948:     strcpy ((char *)oprof+pbody[5]+12, name[output_color-1]);",
          "16949:     for (i=0; i < 3; i++)",
          "16950:       for (j=0; j < colors; j++)",
          "16951:  for (out_cam[i][j] = k=0; k < 3; k++)",
          "16952:    out_cam[i][j] += out_rgb[output_color-1][i][k] * rgb_cam[k][j];",
          "16956:     fprintf (stderr, raw_color ? _(\"Building histograms...\\n\") :",
          "16957:  _(\"Converting to %s colorspace...\\n\"), name[output_color-1]);",
          "16962:   memset (histogram, 0, sizeof histogram);",
          "16963:   for (img=image[0], row=0; row < height; row++)",
          "16964:     for (col=0; col < width; col++, img+=4) {",
          "16965:       if (!raw_color) {",
          "16966:  out[0] = out[1] = out[2] = 0;",
          "16967:  FORCC {",
          "16968:    out[0] += out_cam[0][c] * img[c];",
          "16969:    out[1] += out_cam[1][c] * img[c];",
          "16970:    out[2] += out_cam[2][c] * img[c];",
          "16971:  }",
          "16972:  FORC3 img[c] = CLIP((int) out[c]);",
          "16975:  img[0] = img[fcol(row,col)];",
          "16979:   if (colors == 4 && output_color) colors = 3;",
          "16981:   if (document_mode && filters) colors = 1;",
          "16984:   RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB,1,2);",
          "",
          "[Added Lines]",
          "18451:   int i, j, k;",
          "18458:   static const double xyzd50_srgb[3][3] = {",
          "18459:       {0.436083, 0.385083, 0.143055}, {0.222507, 0.716888, 0.060608}, {0.013930, 0.097097, 0.714022}};",
          "18460:   static const double rgb_rgb[3][3] = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};",
          "18461:   static const double adobe_rgb[3][3] = {",
          "18462:       {0.715146, 0.284856, 0.000000}, {0.000000, 1.000000, 0.000000}, {0.000000, 0.041166, 0.958839}};",
          "18463:   static const double wide_rgb[3][3] = {",
          "18464:       {0.593087, 0.404710, 0.002206}, {0.095413, 0.843149, 0.061439}, {0.011621, 0.069091, 0.919288}};",
          "18465:   static const double prophoto_rgb[3][3] = {",
          "18466:       {0.529317, 0.330092, 0.140588}, {0.098368, 0.873465, 0.028169}, {0.016879, 0.117663, 0.865457}};",
          "18467:   static const double aces_rgb[3][3] = {",
          "18468:       {0.432996, 0.375380, 0.189317}, {0.089427, 0.816523, 0.102989}, {0.019165, 0.118150, 0.941914}};",
          "18469:   static const double(*out_rgb[])[3] = {rgb_rgb, adobe_rgb, wide_rgb, prophoto_rgb, xyz_rgb, aces_rgb};",
          "18470:   static const char *name[] = {\"sRGB\", \"Adobe RGB (1998)\", \"WideGamut D65\", \"ProPhoto D65\", \"XYZ\", \"ACES\"};",
          "18471:   static const unsigned phead[] = {1024, 0, 0x2100000,  0x6d6e7472, 0x52474220, 0x58595a20, 0,",
          "18472:                                    0,    0, 0x61637370, 0,          0,          0x6e6f6e65, 0,",
          "18473:                                    0,    0, 0,          0xf6d6,     0x10000,    0xd32d};",
          "18484:   static const unsigned pwhite[] = {0xf351, 0x10000, 0x116cc};",
          "18485:   unsigned pcurve[] = {0x63757276, 0, 1, 0x1000000};",
          "18487: #ifdef LIBRAW_LIBRARY_BUILD",
          "18488:   RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB, 0, 2);",
          "18489: #endif",
          "18490:   gamma_curve(gamm[0], gamm[1], 0, 0);",
          "18491:   memcpy(out_cam, rgb_cam, sizeof out_cam);",
          "18493:   raw_color |= colors == 1 || document_mode || output_color < 1 || output_color > 6;",
          "18495:   raw_color |= colors == 1 || output_color < 1 || output_color > 6;",
          "18496: #endif",
          "18497:   if (!raw_color)",
          "18498:   {",
          "18499:     oprof = (unsigned *)calloc(phead[0], 1);",
          "18500:     merror(oprof, \"convert_to_rgb()\");",
          "18501:     memcpy(oprof, phead, sizeof phead);",
          "18502:     if (output_color == 5)",
          "18503:       oprof[4] = oprof[5];",
          "18504:     oprof[0] = 132 + 12 * pbody[0];",
          "18505:     for (i = 0; i < pbody[0]; i++)",
          "18506:     {",
          "18507:       oprof[oprof[0] / 4] = i ? (i > 1 ? 0x58595a20 : 0x64657363) : 0x74657874;",
          "18508:       pbody[i * 3 + 2] = oprof[0];",
          "18509:       oprof[0] += (pbody[i * 3 + 3] + 3) & -4;",
          "18510:     }",
          "18511:     memcpy(oprof + 32, pbody, sizeof pbody);",
          "18512:     oprof[pbody[5] / 4 + 2] = strlen(name[output_color - 1]) + 1;",
          "18513:     memcpy((char *)oprof + pbody[8] + 8, pwhite, sizeof pwhite);",
          "18514:     pcurve[3] = (short)(256 / gamm[5] + 0.5) << 16;",
          "18515:     for (i = 4; i < 7; i++)",
          "18516:       memcpy((char *)oprof + pbody[i * 3 + 2], pcurve, sizeof pcurve);",
          "18517:     pseudoinverse((double(*)[3])out_rgb[output_color - 1], inverse, 3);",
          "18518:     for (i = 0; i < 3; i++)",
          "18519:       for (j = 0; j < 3; j++)",
          "18520:       {",
          "18521:         for (num = k = 0; k < 3; k++)",
          "18522:           num += xyzd50_srgb[i][k] * inverse[j][k];",
          "18523:         oprof[pbody[j * 3 + 23] / 4 + i + 2] = num * 0x10000 + 0.5;",
          "18524:       }",
          "18525:     for (i = 0; i < phead[0] / 4; i++)",
          "18527:     strcpy((char *)oprof + pbody[2] + 8, \"auto-generated by dcraw\");",
          "18528:     strcpy((char *)oprof + pbody[5] + 12, name[output_color - 1]);",
          "18529:     for (i = 0; i < 3; i++)",
          "18530:       for (j = 0; j < colors; j++)",
          "18531:         for (out_cam[i][j] = k = 0; k < 3; k++)",
          "18532:           out_cam[i][j] += out_rgb[output_color - 1][i][k] * rgb_cam[k][j];",
          "18536:     fprintf(stderr, raw_color ? _(\"Building histograms...\\n\") : _(\"Converting to %s colorspace...\\n\"),",
          "18537:             name[output_color - 1]);",
          "18542:   memset(histogram, 0, sizeof histogram);",
          "18543:   for (img = image[0], row = 0; row < height; row++)",
          "18544:     for (col = 0; col < width; col++, img += 4)",
          "18545:     {",
          "18546:       if (!raw_color)",
          "18547:       {",
          "18548:         out[0] = out[1] = out[2] = 0;",
          "18549:         FORCC",
          "18550:         {",
          "18551:           out[0] += out_cam[0][c] * img[c];",
          "18552:           out[1] += out_cam[1][c] * img[c];",
          "18553:           out[2] += out_cam[2][c] * img[c];",
          "18554:         }",
          "18555:         FORC3 img[c] = CLIP((int)out[c]);",
          "18558:         img[0] = img[fcol(row, col)];",
          "18562:   if (colors == 4 && output_color)",
          "18563:     colors = 3;",
          "18565:   if (document_mode && filters)",
          "18566:     colors = 1;",
          "18569:   RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB, 1, 2);",
          "",
          "---------------",
          "--- Hunk 123 ---",
          "[Context before]",
          "16993:   unsigned ur, uc;",
          "16994:   ushort wide, high, (*img)[4], (*pix)[4];",
          "16997: #ifdef DCRAW_VERBOSE",
          "16998:   if (verbose)",
          "17000: #endif",
          "17001:   fuji_width = (fuji_width - 1 + shrink) >> shrink;",
          "17002:   step = sqrt(0.5);",
          "17003:   wide = fuji_width / step;",
          "17004:   high = (height - fuji_width) / step;",
          "17008: #ifdef LIBRAW_LIBRARY_BUILD",
          "17010: #endif",
          "17017:       fr = r - ur;",
          "17018:       fc = c - uc;",
          "17024:     }",
          "17028:   height = high;",
          "17030:   fuji_width = 0;",
          "17031: #ifdef LIBRAW_LIBRARY_BUILD",
          "17033: #endif",
          "17034: }",
          "",
          "[Removed Lines]",
          "16996:   if (!fuji_width) return;",
          "16999:     fprintf (stderr,_(\"Rotating image 45 degrees...\\n\"));",
          "17005:   img = (ushort (*)[4]) calloc (high, wide*sizeof *img);",
          "17006:   merror (img, \"fuji_rotate()\");",
          "17009:   RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE,0,2);",
          "17012:   for (row=0; row < high; row++)",
          "17013:     for (col=0; col < wide; col++) {",
          "17014:       ur = r = fuji_width + (row-col)*step;",
          "17015:       uc = c = (row+col)*step;",
          "17016:       if (ur > height-2 || uc > width-2) continue;",
          "17019:       pix = image + ur*width + uc;",
          "17020:       for (i=0; i < colors; i++)",
          "17021:  img[row*wide+col][i] =",
          "17022:    (pix[    0][i]*(1-fc) + pix[      1][i]*fc) * (1-fr) +",
          "17023:    (pix[width][i]*(1-fc) + pix[width+1][i]*fc) * fr;",
          "17026:   free (image);",
          "17027:   width  = wide;",
          "17029:   image  = img;",
          "17032:   RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE,1,2);",
          "",
          "[Added Lines]",
          "18581:   if (!fuji_width)",
          "18582:     return;",
          "18585:     fprintf(stderr, _(\"Rotating image 45 degrees...\\n\"));",
          "18591:   img = (ushort(*)[4])calloc(high, wide * sizeof *img);",
          "18592:   merror(img, \"fuji_rotate()\");",
          "18595:   RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE, 0, 2);",
          "18598:   for (row = 0; row < high; row++)",
          "18599:     for (col = 0; col < wide; col++)",
          "18600:     {",
          "18601:       ur = r = fuji_width + (row - col) * step;",
          "18602:       uc = c = (row + col) * step;",
          "18603:       if (ur > height - 2 || uc > width - 2)",
          "18604:         continue;",
          "18607:       pix = image + ur * width + uc;",
          "18608:       for (i = 0; i < colors; i++)",
          "18609:         img[row * wide + col][i] = (pix[0][i] * (1 - fc) + pix[1][i] * fc) * (1 - fr) +",
          "18610:                                    (pix[width][i] * (1 - fc) + pix[width + 1][i] * fc) * fr;",
          "18613:   free(image);",
          "18614:   width = wide;",
          "18616:   image = img;",
          "18619:   RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE, 1, 2);",
          "",
          "---------------",
          "--- Hunk 124 ---",
          "[Context before]",
          "17039:   int row, col, c;",
          "17040:   double rc, frac;",
          "17043: #ifdef LIBRAW_LIBRARY_BUILD",
          "17045: #endif",
          "17046: #ifdef DCRAW_VERBOSE",
          "17048: #endif",
          "17050:     newdim = height / pixel_aspect + 0.5;",
          "17054:       frac = rc - (c = rc);",
          "17059:     }",
          "17060:     height = newdim;",
          "17062:     newdim = width * pixel_aspect + 0.5;",
          "17066:       frac = rc - (c = rc);",
          "17067:       pix0 = pix1 = image[c];",
          "17071:     }",
          "17072:     width = newdim;",
          "17073:   }",
          "17075:   image = img;",
          "17076: #ifdef LIBRAW_LIBRARY_BUILD",
          "17078: #endif",
          "17079: }",
          "17082: {",
          "17086:   return row * iwidth + col;",
          "17087: }",
          "17092:   ushort tag, type;",
          "17093:   int count;",
          "17095: };",
          "17098:   ushort t_order, magic;",
          "17099:   int ifd;",
          "17100:   ushort pad, ntag;",
          "",
          "[Removed Lines]",
          "17042:   if (pixel_aspect == 1) return;",
          "17044:   RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH,0,2);",
          "17047:   if (verbose) fprintf (stderr,_(\"Stretching the image...\\n\"));",
          "17049:   if (pixel_aspect < 1) {",
          "17051:     img = (ushort (*)[4]) calloc (width, newdim*sizeof *img);",
          "17052:     merror (img, \"stretch()\");",
          "17053:     for (rc=row=0; row < newdim; row++, rc+=pixel_aspect) {",
          "17055:       pix0 = pix1 = image[c*width];",
          "17056:       if (c+1 < height) pix1 += width*4;",
          "17057:       for (col=0; col < width; col++, pix0+=4, pix1+=4)",
          "17058:  FORCC img[row*width+col][c] = pix0[c]*(1-frac) + pix1[c]*frac + 0.5;",
          "17061:   } else {",
          "17063:     img = (ushort (*)[4]) calloc (height, newdim*sizeof *img);",
          "17064:     merror (img, \"stretch()\");",
          "17065:     for (rc=col=0; col < newdim; col++, rc+=1/pixel_aspect) {",
          "17068:       if (c+1 < width) pix1 += 4;",
          "17069:       for (row=0; row < height; row++, pix0+=width*4, pix1+=width*4)",
          "17070:  FORCC img[row*newdim+col][c] = pix0[c]*(1-frac) + pix1[c]*frac + 0.5;",
          "17074:   free (image);",
          "17077:   RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH,1,2);",
          "17081: int CLASS flip_index (int row, int col)",
          "17083:   if (flip & 4) SWAP(row,col);",
          "17084:   if (flip & 2) row = iheight - 1 - row;",
          "17085:   if (flip & 1) col = iwidth  - 1 - col;",
          "17091: struct tiff_tag {",
          "17094:   union { char c[4]; short s[2]; int i; } val;",
          "17097: struct tiff_hdr {",
          "",
          "[Added Lines]",
          "18629:   if (pixel_aspect == 1)",
          "18630:     return;",
          "18632:   RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH, 0, 2);",
          "18635:   if (verbose)",
          "18636:     fprintf(stderr, _(\"Stretching the image...\\n\"));",
          "18638:   if (pixel_aspect < 1)",
          "18639:   {",
          "18641:     img = (ushort(*)[4])calloc(width, newdim * sizeof *img);",
          "18642:     merror(img, \"stretch()\");",
          "18643:     for (rc = row = 0; row < newdim; row++, rc += pixel_aspect)",
          "18644:     {",
          "18646:       pix0 = pix1 = image[c * width];",
          "18647:       if (c + 1 < height)",
          "18648:         pix1 += width * 4;",
          "18649:       for (col = 0; col < width; col++, pix0 += 4, pix1 += 4)",
          "18650:         FORCC img[row * width + col][c] = pix0[c] * (1 - frac) + pix1[c] * frac + 0.5;",
          "18653:   }",
          "18654:   else",
          "18655:   {",
          "18657:     img = (ushort(*)[4])calloc(height, newdim * sizeof *img);",
          "18658:     merror(img, \"stretch()\");",
          "18659:     for (rc = col = 0; col < newdim; col++, rc += 1 / pixel_aspect)",
          "18660:     {",
          "18663:       if (c + 1 < width)",
          "18664:         pix1 += 4;",
          "18665:       for (row = 0; row < height; row++, pix0 += width * 4, pix1 += width * 4)",
          "18666:         FORCC img[row * newdim + col][c] = pix0[c] * (1 - frac) + pix1[c] * frac + 0.5;",
          "18670:   free(image);",
          "18673:   RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH, 1, 2);",
          "18677: int CLASS flip_index(int row, int col)",
          "18679:   if (flip & 4)",
          "18680:     SWAP(row, col);",
          "18681:   if (flip & 2)",
          "18682:     row = iheight - 1 - row;",
          "18683:   if (flip & 1)",
          "18684:     col = iwidth - 1 - col;",
          "18689: struct tiff_tag",
          "18690: {",
          "18693:   union {",
          "18694:     char c[4];",
          "18695:     short s[2];",
          "18696:     int i;",
          "18697:   } val;",
          "18700: struct tiff_hdr",
          "18701: {",
          "",
          "---------------",
          "--- Hunk 125 ---",
          "[Context before]",
          "17117: {",
          "17118:   struct tiff_tag *tt;",
          "17119:   int c;",
          "17122:   tt->val.i = val;",
          "17123:   if (type == 1 && count <= 4)",
          "17124:     FORC(4) tt->val.c[c] = val >> (c << 3);",
          "17127:     if (count <= 4)",
          "17130:     FORC(2) tt->val.s[c] = val >> (c << 4);",
          "17131:   tt->count = count;",
          "17132:   tt->type = type;",
          "",
          "[Removed Lines]",
          "17115: void CLASS tiff_set (struct tiff_hdr *th, ushort *ntag,",
          "17116:  ushort tag, ushort type, int count, int val)",
          "17121:   tt = (struct tiff_tag *)(ntag+1) + (*ntag)++;",
          "17125:   else if (type == 2) {",
          "17126:     count = strnlen((char *)th + val, count-1) + 1;",
          "17128:       FORC(4) tt->val.c[c] = ((char *)th)[val+c];",
          "17129:   } else if (type == 3 && count <= 2)",
          "",
          "[Added Lines]",
          "18719: void CLASS tiff_set(struct tiff_hdr *th, ushort *ntag, ushort tag, ushort type, int count, int val)",
          "18724:   tt = (struct tiff_tag *)(ntag + 1) + (*ntag)++;",
          "18728:   else if (type == 2)",
          "18729:   {",
          "18730:     count = strnlen((char *)th + val, count - 1) + 1;",
          "18732:       FORC(4) tt->val.c[c] = ((char *)th)[val + c];",
          "18733:   }",
          "18734:   else if (type == 3 && count <= 2)",
          "",
          "---------------",
          "--- Hunk 126 ---",
          "[Context before]",
          "17136: #define TOFF(ptr) ((char *)(&(ptr)) - (char *)th)",
          "17139: {",
          "17141:   struct tm *t;",
          "17144:   th->t_order = htonl(0x4d4d4949) >> 16;",
          "17145:   th->magic = 42;",
          "17146:   th->ifd = 10;",
          "17147:   th->rat[0] = th->rat[2] = 300;",
          "17148:   th->rat[1] = th->rat[3] = 1;",
          "17150:   th->rat[4] *= shutter;",
          "17151:   th->rat[6] *= aperture;",
          "17152:   th->rat[8] *= focal_len;",
          "17166:     if (colors > 2)",
          "17168:     FORC4 th->bps[c] = output_bps;",
          "17209:   }",
          "17210: }",
          "17212: #ifdef LIBRAW_LIBRARY_BUILD",
          "17214: {",
          "17215:   ushort exif[5];",
          "17216:   struct tiff_hdr th;",
          "17227: }",
          "17229: void CLASS jpeg_thumb()",
          "17230: {",
          "17231:   char *thumb;",
          "17238: }",
          "17239: #else",
          "17240: void CLASS jpeg_thumb()",
          "",
          "[Removed Lines]",
          "17138: void CLASS tiff_head (struct tiff_hdr *th, int full)",
          "17140:   int c, psize=0;",
          "17143:   memset (th, 0, sizeof *th);",
          "17149:   FORC(6) th->rat[4+c] = 1000000;",
          "17153:   strncpy (th->t_desc, desc, 512);",
          "17154:   strncpy (th->t_make, make, 64);",
          "17155:   strncpy (th->t_model, model, 64);",
          "17156:   strcpy (th->soft, \"dcraw v\" DCRAW_VERSION);",
          "17157:   t = localtime (&timestamp);",
          "17158:   sprintf (th->date, \"%04d:%02d:%02d %02d:%02d:%02d\",",
          "17159:       t->tm_year+1900,t->tm_mon+1,t->tm_mday,t->tm_hour,t->tm_min,t->tm_sec);",
          "17160:   strncpy (th->t_artist, artist, 64);",
          "17161:   if (full) {",
          "17162:     tiff_set (th, &th->ntag, 254, 4, 1, 0);",
          "17163:     tiff_set (th, &th->ntag, 256, 4, 1, width);",
          "17164:     tiff_set (th, &th->ntag, 257, 4, 1, height);",
          "17165:     tiff_set (th, &th->ntag, 258, 3, colors, output_bps);",
          "17167:       th->tag[th->ntag-1].val.i = TOFF(th->bps);",
          "17169:     tiff_set (th, &th->ntag, 259, 3, 1, 1);",
          "17170:     tiff_set (th, &th->ntag, 262, 3, 1, 1 + (colors > 1));",
          "17171:   }",
          "17172:   tiff_set (th, &th->ntag, 270, 2, 512, TOFF(th->t_desc));",
          "17173:   tiff_set (th, &th->ntag, 271, 2, 64, TOFF(th->t_make));",
          "17174:   tiff_set (th, &th->ntag, 272, 2, 64, TOFF(th->t_model));",
          "17175:   if (full) {",
          "17176:     if (oprof) psize = ntohl(oprof[0]);",
          "17177:     tiff_set (th, &th->ntag, 273, 4, 1, sizeof *th + psize);",
          "17178:     tiff_set (th, &th->ntag, 277, 3, 1, colors);",
          "17179:     tiff_set (th, &th->ntag, 278, 4, 1, height);",
          "17180:     tiff_set (th, &th->ntag, 279, 4, 1, height*width*colors*output_bps/8);",
          "17181:   } else",
          "17182:     tiff_set (th, &th->ntag, 274, 3, 1, \"12435867\"[flip]-'0');",
          "17183:   tiff_set (th, &th->ntag, 282, 5, 1, TOFF(th->rat[0]));",
          "17184:   tiff_set (th, &th->ntag, 283, 5, 1, TOFF(th->rat[2]));",
          "17185:   tiff_set (th, &th->ntag, 284, 3, 1, 1);",
          "17186:   tiff_set (th, &th->ntag, 296, 3, 1, 2);",
          "17187:   tiff_set (th, &th->ntag, 305, 2, 32, TOFF(th->soft));",
          "17188:   tiff_set (th, &th->ntag, 306, 2, 20, TOFF(th->date));",
          "17189:   tiff_set (th, &th->ntag, 315, 2, 64, TOFF(th->t_artist));",
          "17190:   tiff_set (th, &th->ntag, 34665, 4, 1, TOFF(th->nexif));",
          "17191:   if (psize) tiff_set (th, &th->ntag, 34675, 7, psize, sizeof *th);",
          "17192:   tiff_set (th, &th->nexif, 33434, 5, 1, TOFF(th->rat[4]));",
          "17193:   tiff_set (th, &th->nexif, 33437, 5, 1, TOFF(th->rat[6]));",
          "17194:   tiff_set (th, &th->nexif, 34855, 3, 1, iso_speed);",
          "17195:   tiff_set (th, &th->nexif, 37386, 5, 1, TOFF(th->rat[8]));",
          "17196:   if (gpsdata[1]) {",
          "17197:     tiff_set (th, &th->ntag, 34853, 4, 1, TOFF(th->ngps));",
          "17198:     tiff_set (th, &th->ngps,  0, 1,  4, 0x202);",
          "17199:     tiff_set (th, &th->ngps,  1, 2,  2, gpsdata[29]);",
          "17200:     tiff_set (th, &th->ngps,  2, 5,  3, TOFF(th->gps[0]));",
          "17201:     tiff_set (th, &th->ngps,  3, 2,  2, gpsdata[30]);",
          "17202:     tiff_set (th, &th->ngps,  4, 5,  3, TOFF(th->gps[6]));",
          "17203:     tiff_set (th, &th->ngps,  5, 1,  1, gpsdata[31]);",
          "17204:     tiff_set (th, &th->ngps,  6, 5,  1, TOFF(th->gps[18]));",
          "17205:     tiff_set (th, &th->ngps,  7, 5,  3, TOFF(th->gps[12]));",
          "17206:     tiff_set (th, &th->ngps, 18, 2, 12, TOFF(th->gps[20]));",
          "17207:     tiff_set (th, &th->ngps, 29, 2, 12, TOFF(th->gps[23]));",
          "17208:     memcpy (th->gps, gpsdata, sizeof th->gps);",
          "17213: void CLASS jpeg_thumb_writer (FILE *tfp,char *t_humb,int t_humb_length)",
          "17217:   fputc (0xff, tfp);",
          "17218:   fputc (0xd8, tfp);",
          "17219:   if (strcmp (t_humb+6, \"Exif\")) {",
          "17220:     memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);",
          "17221:     exif[1] = htons (8 + sizeof th);",
          "17222:     fwrite (exif, 1, sizeof exif, tfp);",
          "17223:     tiff_head (&th, 0);",
          "17224:     fwrite (&th, 1, sizeof th, tfp);",
          "17225:   }",
          "17226:   fwrite (t_humb+2, 1, t_humb_length-2, tfp);",
          "17233:   thumb = (char *) malloc (thumb_length);",
          "17234:   merror (thumb, \"jpeg_thumb()\");",
          "17235:   fread (thumb, 1, thumb_length, ifp);",
          "17236:   jpeg_thumb_writer(ofp,thumb,thumb_length);",
          "17237:   free (thumb);",
          "",
          "[Added Lines]",
          "18743: void CLASS tiff_head(struct tiff_hdr *th, int full)",
          "18745:   int c, psize = 0;",
          "18748:   memset(th, 0, sizeof *th);",
          "18754:   FORC(6) th->rat[4 + c] = 1000000;",
          "18758:   strncpy(th->t_desc, desc, 512);",
          "18759:   strncpy(th->t_make, make, 64);",
          "18760:   strncpy(th->t_model, model, 64);",
          "18761:   strcpy(th->soft, \"dcraw v\" DCRAW_VERSION);",
          "18762:   t = localtime(&timestamp);",
          "18763:   sprintf(th->date, \"%04d:%02d:%02d %02d:%02d:%02d\", t->tm_year + 1900, t->tm_mon + 1, t->tm_mday, t->tm_hour,",
          "18764:           t->tm_min, t->tm_sec);",
          "18765:   strncpy(th->t_artist, artist, 64);",
          "18766:   if (full)",
          "18767:   {",
          "18768:     tiff_set(th, &th->ntag, 254, 4, 1, 0);",
          "18769:     tiff_set(th, &th->ntag, 256, 4, 1, width);",
          "18770:     tiff_set(th, &th->ntag, 257, 4, 1, height);",
          "18771:     tiff_set(th, &th->ntag, 258, 3, colors, output_bps);",
          "18773:       th->tag[th->ntag - 1].val.i = TOFF(th->bps);",
          "18775:     tiff_set(th, &th->ntag, 259, 3, 1, 1);",
          "18776:     tiff_set(th, &th->ntag, 262, 3, 1, 1 + (colors > 1));",
          "18777:   }",
          "18778:   tiff_set(th, &th->ntag, 270, 2, 512, TOFF(th->t_desc));",
          "18779:   tiff_set(th, &th->ntag, 271, 2, 64, TOFF(th->t_make));",
          "18780:   tiff_set(th, &th->ntag, 272, 2, 64, TOFF(th->t_model));",
          "18781:   if (full)",
          "18782:   {",
          "18783:     if (oprof)",
          "18784:       psize = ntohl(oprof[0]);",
          "18785:     tiff_set(th, &th->ntag, 273, 4, 1, sizeof *th + psize);",
          "18786:     tiff_set(th, &th->ntag, 277, 3, 1, colors);",
          "18787:     tiff_set(th, &th->ntag, 278, 4, 1, height);",
          "18788:     tiff_set(th, &th->ntag, 279, 4, 1, height * width * colors * output_bps / 8);",
          "18789:   }",
          "18790:   else",
          "18791:     tiff_set(th, &th->ntag, 274, 3, 1, \"12435867\"[flip] - '0');",
          "18792:   tiff_set(th, &th->ntag, 282, 5, 1, TOFF(th->rat[0]));",
          "18793:   tiff_set(th, &th->ntag, 283, 5, 1, TOFF(th->rat[2]));",
          "18794:   tiff_set(th, &th->ntag, 284, 3, 1, 1);",
          "18795:   tiff_set(th, &th->ntag, 296, 3, 1, 2);",
          "18796:   tiff_set(th, &th->ntag, 305, 2, 32, TOFF(th->soft));",
          "18797:   tiff_set(th, &th->ntag, 306, 2, 20, TOFF(th->date));",
          "18798:   tiff_set(th, &th->ntag, 315, 2, 64, TOFF(th->t_artist));",
          "18799:   tiff_set(th, &th->ntag, 34665, 4, 1, TOFF(th->nexif));",
          "18800:   if (psize)",
          "18801:     tiff_set(th, &th->ntag, 34675, 7, psize, sizeof *th);",
          "18802:   tiff_set(th, &th->nexif, 33434, 5, 1, TOFF(th->rat[4]));",
          "18803:   tiff_set(th, &th->nexif, 33437, 5, 1, TOFF(th->rat[6]));",
          "18804:   tiff_set(th, &th->nexif, 34855, 3, 1, iso_speed);",
          "18805:   tiff_set(th, &th->nexif, 37386, 5, 1, TOFF(th->rat[8]));",
          "18806:   if (gpsdata[1])",
          "18807:   {",
          "18808:     tiff_set(th, &th->ntag, 34853, 4, 1, TOFF(th->ngps));",
          "18809:     tiff_set(th, &th->ngps, 0, 1, 4, 0x202);",
          "18810:     tiff_set(th, &th->ngps, 1, 2, 2, gpsdata[29]);",
          "18811:     tiff_set(th, &th->ngps, 2, 5, 3, TOFF(th->gps[0]));",
          "18812:     tiff_set(th, &th->ngps, 3, 2, 2, gpsdata[30]);",
          "18813:     tiff_set(th, &th->ngps, 4, 5, 3, TOFF(th->gps[6]));",
          "18814:     tiff_set(th, &th->ngps, 5, 1, 1, gpsdata[31]);",
          "18815:     tiff_set(th, &th->ngps, 6, 5, 1, TOFF(th->gps[18]));",
          "18816:     tiff_set(th, &th->ngps, 7, 5, 3, TOFF(th->gps[12]));",
          "18817:     tiff_set(th, &th->ngps, 18, 2, 12, TOFF(th->gps[20]));",
          "18818:     tiff_set(th, &th->ngps, 29, 2, 12, TOFF(th->gps[23]));",
          "18819:     memcpy(th->gps, gpsdata, sizeof th->gps);",
          "18824: void CLASS jpeg_thumb_writer(FILE *tfp, char *t_humb, int t_humb_length)",
          "18828:   fputc(0xff, tfp);",
          "18829:   fputc(0xd8, tfp);",
          "18830:   if (strcmp(t_humb + 6, \"Exif\"))",
          "18831:   {",
          "18832:     memcpy(exif, \"\\xff\\xe1  Exif\\0\\0\", 10);",
          "18833:     exif[1] = htons(8 + sizeof th);",
          "18834:     fwrite(exif, 1, sizeof exif, tfp);",
          "18835:     tiff_head(&th, 0);",
          "18836:     fwrite(&th, 1, sizeof th, tfp);",
          "18837:   }",
          "18838:   fwrite(t_humb + 2, 1, t_humb_length - 2, tfp);",
          "18845:   thumb = (char *)malloc(thumb_length);",
          "18846:   merror(thumb, \"jpeg_thumb()\");",
          "18847:   fread(thumb, 1, thumb_length, ifp);",
          "18848:   jpeg_thumb_writer(ofp, thumb, thumb_length);",
          "18849:   free(thumb);",
          "",
          "---------------",
          "--- Hunk 127 ---",
          "[Context before]",
          "17243:   ushort exif[5];",
          "17244:   struct tiff_hdr th;",
          "17260: }",
          "17261: #endif",
          "",
          "[Removed Lines]",
          "17246:   thumb = (char *) malloc (thumb_length);",
          "17247:   merror (thumb, \"jpeg_thumb()\");",
          "17248:   fread (thumb, 1, thumb_length, ifp);",
          "17249:   fputc (0xff, ofp);",
          "17250:   fputc (0xd8, ofp);",
          "17251:   if (strcmp (thumb+6, \"Exif\")) {",
          "17252:     memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);",
          "17253:     exif[1] = htons (8 + sizeof th);",
          "17254:     fwrite (exif, 1, sizeof exif, ofp);",
          "17255:     tiff_head (&th, 0);",
          "17256:     fwrite (&th, 1, sizeof th, ofp);",
          "17257:   }",
          "17258:   fwrite (thumb+2, 1, thumb_length-2, ofp);",
          "17259:   free (thumb);",
          "",
          "[Added Lines]",
          "18858:   thumb = (char *)malloc(thumb_length);",
          "18859:   merror(thumb, \"jpeg_thumb()\");",
          "18860:   fread(thumb, 1, thumb_length, ifp);",
          "18861:   fputc(0xff, ofp);",
          "18862:   fputc(0xd8, ofp);",
          "18863:   if (strcmp(thumb + 6, \"Exif\"))",
          "18864:   {",
          "18865:     memcpy(exif, \"\\xff\\xe1  Exif\\0\\0\", 10);",
          "18866:     exif[1] = htons(8 + sizeof th);",
          "18867:     fwrite(exif, 1, sizeof exif, ofp);",
          "18868:     tiff_head(&th, 0);",
          "18869:     fwrite(&th, 1, sizeof th, ofp);",
          "18870:   }",
          "18871:   fwrite(thumb + 2, 1, thumb_length - 2, ofp);",
          "18872:   free(thumb);",
          "",
          "---------------",
          "--- Hunk 128 ---",
          "[Context before]",
          "17266:   uchar *ppm;",
          "17267:   ushort *ppm2;",
          "17268:   int c, row, col, soff, rstep, cstep;",
          "17271: #ifdef LIBRAW_LIBRARY_BUILD",
          "17272:   perc = width * height * auto_bright_thr;",
          "17273: #else",
          "17275: #endif",
          "17277:   if (!((highlight & ~2) || no_auto_bright))",
          "17282:     }",
          "17284:   iheight = height;",
          "17293:     if (oprof)",
          "17299:   else",
          "17307:       if (output_bps == 8)",
          "17310:     if (output_bps == 16 && !output_tiff && htons(0x55aa) != 0x55aa)",
          "17313:   }",
          "17315: }",
          "17319: {",
          "17325:   char opm, opt, *ofname, *cp;",
          "17326:   struct utimbuf ut;",
          "17327: #ifndef NO_LCMS",
          "17329: #endif",
          "17331: #ifndef LOCALTIME",
          "17333: #endif",
          "17334: #ifdef LOCALEDIR",
          "17339: #endif",
          "17342:     printf(_(\"\\nRaw photo decoder \\\"dcraw\\\" v%s\"), DCRAW_VERSION);",
          "17343:     printf(_(\"\\nby Dave Coffin, dcoffin a cybercom o net\\n\"));",
          "17344:     printf(_(\"\\nUsage:  %s [OPTION]... [FILE]...\\n\\n\"), argv[0]);",
          "",
          "[Removed Lines]",
          "17269:   int perc, val, total, t_white=0x2000;",
          "17276:   if (fuji_width) perc /= 2;",
          "17278:     for (t_white=c=0; c < colors; c++) {",
          "17279:       for (val=0x2000, total=0; --val > 32; )",
          "17280:  if ((total += histogram[c][val]) > perc) break;",
          "17281:       if (t_white < val) t_white = val;",
          "17283:   gamma_curve (gamm[0], gamm[1], 2, (t_white << 3)/bright);",
          "17285:   iwidth  = width;",
          "17286:   if (flip & 4) SWAP(height,width);",
          "17287:   ppm = (uchar *) calloc (width, colors*output_bps/8);",
          "17288:   ppm2 = (ushort *) ppm;",
          "17289:   merror (ppm, \"write_ppm_tiff()\");",
          "17290:   if (output_tiff) {",
          "17291:     tiff_head (&th, 1);",
          "17292:     fwrite (&th, sizeof th, 1, ofp);",
          "17294:       fwrite (oprof, ntohl(oprof[0]), 1, ofp);",
          "17295:   } else if (colors > 3)",
          "17296:     fprintf (ofp,",
          "17297:       \"P7\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %d\\nMAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\",",
          "17298:  width, height, colors, (1 << output_bps)-1, cdesc);",
          "17300:     fprintf (ofp, \"P%d\\n%d %d\\n%d\\n\",",
          "17301:  colors/2+5, width, height, (1 << output_bps)-1);",
          "17302:   soff  = flip_index (0, 0);",
          "17303:   cstep = flip_index (0, 1) - soff;",
          "17304:   rstep = flip_index (1, 0) - flip_index (0, width);",
          "17305:   for (row=0; row < height; row++, soff += rstep) {",
          "17306:     for (col=0; col < width; col++, soff += cstep)",
          "17308:     FORCC ppm [col*colors+c] = curve[image[soff][c]] >> 8;",
          "17309:       else FORCC ppm2[col*colors+c] = curve[image[soff][c]];",
          "17311:       swab ((char*)ppm2, (char*)ppm2, width*colors*2);",
          "17312:     fwrite (ppm, colors*output_bps/8, width, ofp);",
          "17314:   free (ppm);",
          "17318: int CLASS main (int argc, const char **argv)",
          "17320:   int arg, status=0, quality, i, c;",
          "17321:   int timestamp_only=0, thumbnail_only=0, identify_only=0;",
          "17322:   int user_qual=-1, user_black=-1, user_sat=-1, user_flip=-1;",
          "17323:   int use_fuji_rotate=1, write_to_stdout=0, read_from_stdin=0;",
          "17324:   const char *sp, *bpfile=0, *dark_frame=0, *write_ext;",
          "17328:   const char *cam_profile=0, *out_profile=0;",
          "17332:   putenv ((char *) \"TZ=UTC\");",
          "17335:   setlocale (LC_CTYPE, \"\");",
          "17336:   setlocale (LC_MESSAGES, \"\");",
          "17337:   bindtextdomain (\"dcraw\", LOCALEDIR);",
          "17338:   textdomain (\"dcraw\");",
          "17341:   if (argc == 1) {",
          "",
          "[Added Lines]",
          "18882:   int perc, val, total, t_white = 0x2000;",
          "18889:   if (fuji_width)",
          "18890:     perc /= 2;",
          "18892:     for (t_white = c = 0; c < colors; c++)",
          "18893:     {",
          "18894:       for (val = 0x2000, total = 0; --val > 32;)",
          "18895:         if ((total += histogram[c][val]) > perc)",
          "18896:           break;",
          "18897:       if (t_white < val)",
          "18898:         t_white = val;",
          "18900:   gamma_curve(gamm[0], gamm[1], 2, (t_white << 3) / bright);",
          "18902:   iwidth = width;",
          "18903:   if (flip & 4)",
          "18904:     SWAP(height, width);",
          "18905:   ppm = (uchar *)calloc(width, colors * output_bps / 8);",
          "18906:   ppm2 = (ushort *)ppm;",
          "18907:   merror(ppm, \"write_ppm_tiff()\");",
          "18908:   if (output_tiff)",
          "18909:   {",
          "18910:     tiff_head(&th, 1);",
          "18911:     fwrite(&th, sizeof th, 1, ofp);",
          "18913:       fwrite(oprof, ntohl(oprof[0]), 1, ofp);",
          "18914:   }",
          "18915:   else if (colors > 3)",
          "18916:     fprintf(ofp, \"P7\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %d\\nMAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\", width, height, colors,",
          "18917:             (1 << output_bps) - 1, cdesc);",
          "18919:     fprintf(ofp, \"P%d\\n%d %d\\n%d\\n\", colors / 2 + 5, width, height, (1 << output_bps) - 1);",
          "18920:   soff = flip_index(0, 0);",
          "18921:   cstep = flip_index(0, 1) - soff;",
          "18922:   rstep = flip_index(1, 0) - flip_index(0, width);",
          "18923:   for (row = 0; row < height; row++, soff += rstep)",
          "18924:   {",
          "18925:     for (col = 0; col < width; col++, soff += cstep)",
          "18927:         FORCC ppm[col * colors + c] = curve[image[soff][c]] >> 8;",
          "18928:       else",
          "18929:         FORCC ppm2[col * colors + c] = curve[image[soff][c]];",
          "18931:       swab((char *)ppm2, (char *)ppm2, width * colors * 2);",
          "18932:     fwrite(ppm, colors * output_bps / 8, width, ofp);",
          "18934:   free(ppm);",
          "18938: int CLASS main(int argc, const char **argv)",
          "18940:   int arg, status = 0, quality, i, c;",
          "18941:   int timestamp_only = 0, thumbnail_only = 0, identify_only = 0;",
          "18942:   int user_qual = -1, user_black = -1, user_sat = -1, user_flip = -1;",
          "18943:   int use_fuji_rotate = 1, write_to_stdout = 0, read_from_stdin = 0;",
          "18944:   const char *sp, *bpfile = 0, *dark_frame = 0, *write_ext;",
          "18948:   const char *cam_profile = 0, *out_profile = 0;",
          "18952:   putenv((char *)\"TZ=UTC\");",
          "18955:   setlocale(LC_CTYPE, \"\");",
          "18956:   setlocale(LC_MESSAGES, \"\");",
          "18957:   bindtextdomain(\"dcraw\", LOCALEDIR);",
          "18958:   textdomain(\"dcraw\");",
          "18961:   if (argc == 1)",
          "18962:   {",
          "",
          "---------------",
          "--- Hunk 129 ---",
          "[Context before]",
          "17384:     return 1;",
          "17385:   }",
          "17386:   argv[argc] = \"\";",
          "17388:     opt = argv[arg++][1];",
          "17418: #ifndef NO_LCMS",
          "17454:     return 1;",
          "17455:   }",
          "17459:       return 1;",
          "17460:     }",
          "17461: #if defined(WIN32) || defined(DJGPP) || defined(__CYGWIN__)",
          "17464:       return 1;",
          "17465:     }",
          "17466: #endif",
          "17467:   }",
          "17469:     status = 1;",
          "17470:     raw_image = 0;",
          "17471:     image = 0;",
          "17472:     oprof = 0;",
          "17473:     meta_data = ofname = 0;",
          "17474:     ofp = stdout;",
          "17478:       status = 1;",
          "17479:       goto cleanup;",
          "17480:     }",
          "17481:     ifname = argv[arg];",
          "17484:       continue;",
          "17485:     }",
          "17487:     if (user_flip >= 0)",
          "17488:       flip = user_flip;",
          "17493:     }",
          "17495:       if ((status = !timestamp))",
          "17497:       else if (identify_only)",
          "17504:       }",
          "17505:       goto next;",
          "17506:     }",
          "17507:     write_fun = &CLASS write_ppm_tiff;",
          "17526:       height += height & 1;",
          "17528:     }",
          "17534:       if (artist[0])",
          "17543:       if (shutter > 0 && shutter < 1)",
          "17550:       if (pixel_aspect != 1)",
          "17552:       if (thumb_offset)",
          "17560:     iheight = (height + shrink) >> shrink;",
          "17607:       fclose(ifp);",
          "17608:       continue;",
          "17609:     }",
          "17613:     }",
          "17620:     }",
          "17621:     if (verbose)",
          "17624:     if (shot_select >= is_raw)",
          "17628:     if (raw_image && read_from_stdin)",
          "17632:       top_margin = left_margin = fuji_width = 0;",
          "17633:       height = raw_height;",
          "17635:     }",
          "17636:     iheight = (height + shrink) >> shrink;",
          "17641:       crop_masked_pixels();",
          "17643:     }",
          "17647:     quality = 2 + !fuji_width;",
          "17649:     i = cblack[3];",
          "17650:     FORC3 if (i > cblack[c]) i = cblack[c];",
          "17651:     FORC4 cblack[c] -= i;",
          "17652:     black += i;",
          "17653:     i = cblack[6];",
          "17658:     black += i;",
          "17660:     FORC4 cblack[c] += black;",
          "17662: #ifdef COLORCHECK",
          "17663:     colorcheck();",
          "17664: #endif",
          "17671:       scale_colors();",
          "17672:     pre_interpolate();",
          "17674:       if (quality == 0)",
          "17676:       else if (quality == 1 || colors > 3)",
          "17678:       else if (quality == 2 && filters > 1000)",
          "17680:       else if (filters == 9)",
          "17682:       else",
          "17684:     }",
          "17685:     if (mix_green)",
          "17692: #ifndef NO_LCMS",
          "17694: #endif",
          "17695:     convert_to_rgb();",
          "17698:     if (write_fun == &CLASS jpeg_thumb)",
          "17699:       write_ext = \".jpg\";",
          "17700:     else if (output_tiff && write_fun == &CLASS write_ppm_tiff)",
          "17701:       write_ext = \".tiff\";",
          "17702:     else",
          "17706:     if (write_to_stdout)",
          "17711:       if (multi_out)",
          "17714:       if (thumbnail_only)",
          "17722:       }",
          "17723:     }",
          "17724:     if (verbose)",
          "17726:     (*write_fun)();",
          "17727:     fclose(ifp);",
          "17737:     }",
          "17738:   }",
          "17739:   return status;",
          "",
          "[Removed Lines]",
          "17387:   for (arg=1; (((opm = argv[arg][0]) - 2) | 2) == '+'; ) {",
          "17389:     if ((cp = (char *) strchr (sp=\"nbrkStqmHACg\", opt)))",
          "17390:       for (i=0; i < \"114111111422\"[cp-sp]-'0'; i++)",
          "17391:  if (!isdigit(argv[arg+i][0])) {",
          "17392:    fprintf (stderr,_(\"Non-numeric argument to \\\"-%c\\\"\\n\"), opt);",
          "17393:    return 1;",
          "17394:  }",
          "17395:     switch (opt) {",
          "17396:       case 'n':  threshold   = atof(argv[arg++]);  break;",
          "17397:       case 'b':  bright      = atof(argv[arg++]);  break;",
          "17398:       case 'r':",
          "17399:     FORC4 user_mul[c] = atof(argv[arg++]);  break;",
          "17400:       case 'C':  aber[0] = 1 / atof(argv[arg++]);",
          "17401:    aber[2] = 1 / atof(argv[arg++]);  break;",
          "17402:       case 'g':  gamm[0] =     atof(argv[arg++]);",
          "17403:    gamm[1] =     atof(argv[arg++]);",
          "17404:    if (gamm[0]) gamm[0] = 1/gamm[0]; break;",
          "17405:       case 'k':  user_black  = atoi(argv[arg++]);  break;",
          "17406:       case 'S':  user_sat    = atoi(argv[arg++]);  break;",
          "17407:       case 't':  user_flip   = atoi(argv[arg++]);  break;",
          "17408:       case 'q':  user_qual   = atoi(argv[arg++]);  break;",
          "17409:       case 'm':  med_passes  = atoi(argv[arg++]);  break;",
          "17410:       case 'H':  highlight   = atoi(argv[arg++]);  break;",
          "17411:       case 's':",
          "17412:  shot_select = abs(atoi(argv[arg]));",
          "17413:  multi_out = !strcmp(argv[arg++],\"all\");",
          "17414:  break;",
          "17415:       case 'o':",
          "17416:  if (isdigit(argv[arg][0]) && !argv[arg][1])",
          "17417:    output_color = atoi(argv[arg++]);",
          "17419:  else     out_profile = argv[arg++];",
          "17420:  break;",
          "17421:       case 'p':  cam_profile = argv[arg++];",
          "17422: #endif",
          "17423:  break;",
          "17424:       case 'P':  bpfile     = argv[arg++];  break;",
          "17425:       case 'K':  dark_frame = argv[arg++];  break;",
          "17426:       case 'z':  timestamp_only    = 1;  break;",
          "17427:       case 'e':  thumbnail_only    = 1;  break;",
          "17428:       case 'i':  identify_only     = 1;  break;",
          "17429:       case 'c':  write_to_stdout   = 1;  break;",
          "17430:       case 'v':  verbose           = 1;  break;",
          "17431:       case 'h':  half_size         = 1;  break;",
          "17432:       case 'f':  four_color_rgb    = 1;  break;",
          "17433:       case 'A':  FORC4 greybox[c]  = atoi(argv[arg++]);",
          "17434:       case 'a':  use_auto_wb       = 1;  break;",
          "17435:       case 'w':  use_camera_wb     = 1;  break;",
          "17436:       case 'M':  use_camera_matrix = 3 * (opm == '+');  break;",
          "17437:       case 'I':  read_from_stdin   = 1;  break;",
          "17438:       case 'E':  document_mode++;",
          "17439:       case 'D':  document_mode++;",
          "17440:       case 'd':  document_mode++;",
          "17441:       case 'j':  use_fuji_rotate   = 0;  break;",
          "17442:       case 'W':  no_auto_bright    = 1;  break;",
          "17443:       case 'T':  output_tiff       = 1;  break;",
          "17444:       case '4':  gamm[0] = gamm[1] =",
          "17445:    no_auto_bright    = 1;",
          "17446:       case '6':  output_bps       = 16;  break;",
          "17447:       default:",
          "17448:  fprintf (stderr,_(\"Unknown option \\\"-%c\\\".\\n\"), opt);",
          "17449:  return 1;",
          "17450:     }",
          "17451:   }",
          "17452:   if (arg == argc) {",
          "17453:     fprintf (stderr,_(\"No files to process.\\n\"));",
          "17456:   if (write_to_stdout) {",
          "17457:     if (isatty(1)) {",
          "17458:       fprintf (stderr,_(\"Will not write an image to the terminal!\\n\"));",
          "17462:     if (setmode(1,O_BINARY) < 0) {",
          "17463:       perror (\"setmode()\");",
          "17468:   for ( ; arg < argc; arg++) {",
          "17475:     if (setjmp (failure)) {",
          "17476:       if (fileno(ifp) > 2) fclose(ifp);",
          "17477:       if (fileno(ofp) > 2) fclose(ofp);",
          "17482:     if (!(ifp = fopen (ifname, \"rb\"))) {",
          "17483:       perror (ifname);",
          "17486:     status = (identify(),!is_raw);",
          "17489:     switch ((flip+3600) % 360) {",
          "17490:       case 270:  flip = 5;  break;",
          "17491:       case 180:  flip = 3;  break;",
          "17492:       case  90:  flip = 6;",
          "17494:     if (timestamp_only) {",
          "17496:  fprintf (stderr,_(\"%s has no timestamp.\\n\"), ifname);",
          "17498:  printf (\"%10ld%10d %s\\n\", (long) timestamp, shot_order, ifname);",
          "17499:       else {",
          "17500:  if (verbose)",
          "17501:    fprintf (stderr,_(\"%s time set to %d.\\n\"), ifname, (int) timestamp);",
          "17502:  ut.actime = ut.modtime = timestamp;",
          "17503:  utime (ifname, &ut);",
          "17508:     if (thumbnail_only) {",
          "17509:       if ((status = !thumb_offset)) {",
          "17510:  fprintf (stderr,_(\"%s has no thumbnail.\\n\"), ifname);",
          "17511:  goto next;",
          "17512:       } else if (thumb_load_raw) {",
          "17513:  load_raw = thumb_load_raw;",
          "17514:  data_offset = thumb_offset;",
          "17515:  height = thumb_height;",
          "17516:  width  = thumb_width;",
          "17517:  filters = 0;",
          "17518:  colors = 3;",
          "17519:       } else {",
          "17520:  fseek (ifp, thumb_offset, SEEK_SET);",
          "17521:  write_fun = write_thumb;",
          "17522:  goto thumbnail;",
          "17523:       }",
          "17524:     }",
          "17525:     if (load_raw == &CLASS kodak_ycbcr_load_raw) {",
          "17527:       width  += width  & 1;",
          "17530:     if (identify_only && verbose && make[0]) {",
          "17531:       printf (_(\"\\nFilename: %s\\n\"), ifname);",
          "17532:       printf (_(\"Timestamp: %s\"), ctime(&timestamp));",
          "17533:       printf (_(\"Camera: %s %s\\n\"), make, model);",
          "17535:  printf (_(\"Owner: %s\\n\"), artist);",
          "17536:       if (dng_version) {",
          "17537:  printf (_(\"DNG Version: \"));",
          "17538:  for (i=24; i >= 0; i -= 8)",
          "17539:    printf (\"%d%c\", dng_version >> i & 255, i ? '.':'\\n');",
          "17540:       }",
          "17541:       printf (_(\"ISO speed: %d\\n\"), (int) iso_speed);",
          "17542:       printf (_(\"Shutter: \"));",
          "17544:  shutter = (printf (\"1/\"), 1 / shutter);",
          "17545:       printf (_(\"%0.1f sec\\n\"), shutter);",
          "17546:       printf (_(\"Aperture: f/%0.1f\\n\"), aperture);",
          "17547:       printf (_(\"Focal length: %0.1f mm\\n\"), focal_len);",
          "17548:       printf (_(\"Embedded ICC profile: %s\\n\"), profile_length ? _(\"yes\"):_(\"no\"));",
          "17549:       printf (_(\"Number of raw images: %d\\n\"), is_raw);",
          "17551:  printf (_(\"Pixel Aspect Ratio: %0.6f\\n\"), pixel_aspect);",
          "17553:  printf (_(\"Thumb size:  %4d x %d\\n\"), thumb_width, thumb_height);",
          "17554:       printf (_(\"Full size:   %4d x %d\\n\"), raw_width, raw_height);",
          "17555:     } else if (!is_raw)",
          "17556:       fprintf (stderr,_(\"Cannot decode file %s\\n\"), ifname);",
          "17557:     if (!is_raw) goto next;",
          "17558:     shrink = filters && (half_size || (!identify_only &&",
          "17559:  (threshold || aber[0] != 1 || aber[2] != 1)));",
          "17561:     iwidth  = (width  + shrink) >> shrink;",
          "17562:     if (identify_only) {",
          "17563:       if (verbose) {",
          "17564:  if (document_mode == 3) {",
          "17565:    top_margin = left_margin = fuji_width = 0;",
          "17566:    height = raw_height;",
          "17567:    width  = raw_width;",
          "17568:  }",
          "17569:  iheight = (height + shrink) >> shrink;",
          "17570:  iwidth  = (width  + shrink) >> shrink;",
          "17571:  if (use_fuji_rotate) {",
          "17572:    if (fuji_width) {",
          "17573:      fuji_width = (fuji_width - 1 + shrink) >> shrink;",
          "17574:      iwidth = fuji_width / sqrt(0.5);",
          "17575:      iheight = (iheight - fuji_width) / sqrt(0.5);",
          "17576:    } else {",
          "17577:      if (pixel_aspect < 1) iheight = iheight / pixel_aspect + 0.5;",
          "17578:      if (pixel_aspect > 1) iwidth  = iwidth  * pixel_aspect + 0.5;",
          "17579:    }",
          "17580:  }",
          "17581:  if (flip & 4)",
          "17582:    SWAP(iheight,iwidth);",
          "17583:  printf (_(\"Image size:  %4d x %d\\n\"), width, height);",
          "17584:  printf (_(\"Output size: %4d x %d\\n\"), iwidth, iheight);",
          "17585:  printf (_(\"Raw colors: %d\"), colors);",
          "17586:  if (filters) {",
          "17587:    int fhigh = 2, fwide = 2;",
          "17588:    if ((filters ^ (filters >>  8)) & 0xff)   fhigh = 4;",
          "17589:    if ((filters ^ (filters >> 16)) & 0xffff) fhigh = 8;",
          "17590:    if (filters == 1) fhigh = fwide = 16;",
          "17591:    if (filters == 9) fhigh = fwide = 6;",
          "17592:    printf (_(\"\\nFilter pattern: \"));",
          "17593:    for (i=0; i < fhigh; i++)",
          "17594:      for (c = i && putchar('/') && 0; c < fwide; c++)",
          "17595:        putchar (cdesc[fcol(i,c)]);",
          "17596:  }",
          "17597:  printf (_(\"\\nDaylight multipliers:\"));",
          "17598:  FORCC printf (\" %f\", pre_mul[c]);",
          "17599:  if (cam_mul[0] > 0) {",
          "17600:    printf (_(\"\\nCamera multipliers:\"));",
          "17601:    FORC4 printf (\" %f\", cam_mul[c]);",
          "17602:  }",
          "17603:  putchar ('\\n');",
          "17604:       } else",
          "17605:  printf (_(\"%s is a %s %s image.\\n\"), ifname, make, model);",
          "17606: next:",
          "17610:     if (meta_length) {",
          "17611:       meta_data = (char *) malloc (meta_length);",
          "17612:       merror (meta_data, \"main()\");",
          "17614:     if (filters || colors == 1) {",
          "17615:       raw_image = (ushort *) calloc ((raw_height+7), raw_width*2);",
          "17616:       merror (raw_image, \"main()\");",
          "17617:     } else {",
          "17618:       image = (ushort (*)[4]) calloc (iheight, iwidth*sizeof *image);",
          "17619:       merror (image, \"main()\");",
          "17622:       fprintf (stderr,_(\"Loading %s %s image from %s ...\\n\"),",
          "17623:  make, model, ifname);",
          "17625:       fprintf (stderr,_(\"%s: \\\"-s %d\\\" requests a nonexistent image!\\n\"),",
          "17626:  ifname, shot_select);",
          "17627:     fseeko (ifp, data_offset, SEEK_SET);",
          "17629:       fread (raw_image, 2, raw_height*raw_width, stdin);",
          "17630:     else (*load_raw)();",
          "17631:     if (document_mode == 3) {",
          "17634:       width  = raw_width;",
          "17637:     iwidth  = (width  + shrink) >> shrink;",
          "17638:     if (raw_image) {",
          "17639:       image = (ushort (*)[4]) calloc (iheight, iwidth*sizeof *image);",
          "17640:       merror (image, \"main()\");",
          "17642:       free (raw_image);",
          "17644:     if (zero_is_bad) remove_zeroes();",
          "17645:     bad_pixels (bpfile);",
          "17646:     if (dark_frame) subtract (dark_frame);",
          "17648:     if (user_qual >= 0) quality = user_qual;",
          "17654:     FORC (cblack[4] * cblack[5])",
          "17655:       if (i > cblack[6+c]) i = cblack[6+c];",
          "17656:     FORC (cblack[4] * cblack[5])",
          "17657:       cblack[6+c] -= i;",
          "17659:     if (user_black >= 0) black = user_black;",
          "17661:     if (user_sat > 0) maximum = user_sat;",
          "17665:     if (is_foveon) {",
          "17666:       if (document_mode || load_raw == &CLASS foveon_dp_load_raw) {",
          "17667:  for (i=0; i < height*width*4; i++)",
          "17668:    if ((short) image[0][i] < 0) image[0][i] = 0;",
          "17669:       } else foveon_interpolate();",
          "17670:     } else if (document_mode < 2)",
          "17673:     if (filters && !document_mode) {",
          "17675:  lin_interpolate();",
          "17677:  vng_interpolate();",
          "17679:  ppg_interpolate();",
          "17681:  xtrans_interpolate (quality*2-3);",
          "17683:  ahd_interpolate();",
          "17686:       for (colors=3, i=0; i < height*width; i++)",
          "17687:  image[i][1] = (image[i][1] + image[i][3]) >> 1;",
          "17688:     if (!is_foveon && colors == 3) median_filter();",
          "17689:     if (!is_foveon && highlight == 2) blend_highlights();",
          "17690:     if (!is_foveon && highlight > 2) recover_highlights();",
          "17691:     if (use_fuji_rotate) fuji_rotate();",
          "17693:     if (cam_profile) apply_profile (cam_profile, out_profile);",
          "17696:     if (use_fuji_rotate) stretch();",
          "17697: thumbnail:",
          "17703:       write_ext = \".pgm\\0.ppm\\0.ppm\\0.pam\" + colors*5-5;",
          "17704:     ofname = (char *) malloc (strlen(ifname) + 64);",
          "17705:     merror (ofname, \"main()\");",
          "17707:       strcpy (ofname,_(\"standard output\"));",
          "17708:     else {",
          "17709:       strcpy (ofname, ifname);",
          "17710:       if ((cp = strrchr (ofname, '.'))) *cp = 0;",
          "17712:  sprintf (ofname+strlen(ofname), \"_%0*d\",",
          "17713:   snprintf(0,0,\"%d\",is_raw-1), shot_select);",
          "17715:  strcat (ofname, \".thumb\");",
          "17716:       strcat (ofname, write_ext);",
          "17717:       ofp = fopen (ofname, \"wb\");",
          "17718:       if (!ofp) {",
          "17719:  status = 1;",
          "17720:  perror (ofname);",
          "17721:  goto cleanup;",
          "17725:       fprintf (stderr,_(\"Writing data to %s ...\\n\"), ofname);",
          "17728:     if (ofp != stdout) fclose(ofp);",
          "17729: cleanup:",
          "17730:     if (meta_data) free (meta_data);",
          "17731:     if (ofname) free (ofname);",
          "17732:     if (oprof) free (oprof);",
          "17733:     if (image) free (image);",
          "17734:     if (multi_out) {",
          "17735:       if (++shot_select < is_raw) arg--;",
          "17736:       else shot_select = 0;",
          "",
          "[Added Lines]",
          "19008:   for (arg = 1; (((opm = argv[arg][0]) - 2) | 2) == '+';)",
          "19009:   {",
          "19011:     if ((cp = (char *)strchr(sp = \"nbrkStqmHACg\", opt)))",
          "19012:       for (i = 0; i < \"114111111422\"[cp - sp] - '0'; i++)",
          "19013:         if (!isdigit(argv[arg + i][0]))",
          "19014:         {",
          "19015:           fprintf(stderr, _(\"Non-numeric argument to \\\"-%c\\\"\\n\"), opt);",
          "19016:           return 1;",
          "19017:         }",
          "19018:     switch (opt)",
          "19019:     {",
          "19020:     case 'n':",
          "19021:       threshold = atof(argv[arg++]);",
          "19022:       break;",
          "19023:     case 'b':",
          "19024:       bright = atof(argv[arg++]);",
          "19025:       break;",
          "19026:     case 'r':",
          "19027:       FORC4 user_mul[c] = atof(argv[arg++]);",
          "19028:       break;",
          "19029:     case 'C':",
          "19030:       aber[0] = 1 / atof(argv[arg++]);",
          "19031:       aber[2] = 1 / atof(argv[arg++]);",
          "19032:       break;",
          "19033:     case 'g':",
          "19034:       gamm[0] = atof(argv[arg++]);",
          "19035:       gamm[1] = atof(argv[arg++]);",
          "19036:       if (gamm[0])",
          "19037:         gamm[0] = 1 / gamm[0];",
          "19038:       break;",
          "19039:     case 'k':",
          "19040:       user_black = atoi(argv[arg++]);",
          "19041:       break;",
          "19042:     case 'S':",
          "19043:       user_sat = atoi(argv[arg++]);",
          "19044:       break;",
          "19045:     case 't':",
          "19046:       user_flip = atoi(argv[arg++]);",
          "19047:       break;",
          "19048:     case 'q':",
          "19049:       user_qual = atoi(argv[arg++]);",
          "19050:       break;",
          "19051:     case 'm':",
          "19052:       med_passes = atoi(argv[arg++]);",
          "19053:       break;",
          "19054:     case 'H':",
          "19055:       highlight = atoi(argv[arg++]);",
          "19056:       break;",
          "19057:     case 's':",
          "19058:       shot_select = abs(atoi(argv[arg]));",
          "19059:       multi_out = !strcmp(argv[arg++], \"all\");",
          "19060:       break;",
          "19061:     case 'o':",
          "19062:       if (isdigit(argv[arg][0]) && !argv[arg][1])",
          "19063:         output_color = atoi(argv[arg++]);",
          "19065:       else",
          "19066:         out_profile = argv[arg++];",
          "19067:       break;",
          "19068:     case 'p':",
          "19069:       cam_profile = argv[arg++];",
          "19070: #endif",
          "19071:       break;",
          "19072:     case 'P':",
          "19073:       bpfile = argv[arg++];",
          "19074:       break;",
          "19075:     case 'K':",
          "19076:       dark_frame = argv[arg++];",
          "19077:       break;",
          "19078:     case 'z':",
          "19079:       timestamp_only = 1;",
          "19080:       break;",
          "19081:     case 'e':",
          "19082:       thumbnail_only = 1;",
          "19083:       break;",
          "19084:     case 'i':",
          "19085:       identify_only = 1;",
          "19086:       break;",
          "19087:     case 'c':",
          "19088:       write_to_stdout = 1;",
          "19089:       break;",
          "19090:     case 'v':",
          "19091:       verbose = 1;",
          "19092:       break;",
          "19093:     case 'h':",
          "19094:       half_size = 1;",
          "19095:       break;",
          "19096:     case 'f':",
          "19097:       four_color_rgb = 1;",
          "19098:       break;",
          "19099:     case 'A':",
          "19100:       FORC4 greybox[c] = atoi(argv[arg++]);",
          "19101:     case 'a':",
          "19102:       use_auto_wb = 1;",
          "19103:       break;",
          "19104:     case 'w':",
          "19105:       use_camera_wb = 1;",
          "19106:       break;",
          "19107:     case 'M':",
          "19108:       use_camera_matrix = 3 * (opm == '+');",
          "19109:       break;",
          "19110:     case 'I':",
          "19111:       read_from_stdin = 1;",
          "19112:       break;",
          "19113:     case 'E':",
          "19114:       document_mode++;",
          "19115:     case 'D':",
          "19116:       document_mode++;",
          "19117:     case 'd':",
          "19118:       document_mode++;",
          "19119:     case 'j':",
          "19120:       use_fuji_rotate = 0;",
          "19121:       break;",
          "19122:     case 'W':",
          "19123:       no_auto_bright = 1;",
          "19124:       break;",
          "19125:     case 'T':",
          "19126:       output_tiff = 1;",
          "19127:       break;",
          "19128:     case '4':",
          "19129:       gamm[0] = gamm[1] = no_auto_bright = 1;",
          "19130:     case '6':",
          "19131:       output_bps = 16;",
          "19132:       break;",
          "19133:     default:",
          "19134:       fprintf(stderr, _(\"Unknown option \\\"-%c\\\".\\n\"), opt);",
          "19135:       return 1;",
          "19136:     }",
          "19137:   }",
          "19138:   if (arg == argc)",
          "19139:   {",
          "19140:     fprintf(stderr, _(\"No files to process.\\n\"));",
          "19143:   if (write_to_stdout)",
          "19144:   {",
          "19145:     if (isatty(1))",
          "19146:     {",
          "19147:       fprintf(stderr, _(\"Will not write an image to the terminal!\\n\"));",
          "19151:     if (setmode(1, O_BINARY) < 0)",
          "19152:     {",
          "19153:       perror(\"setmode()\");",
          "19158:   for (; arg < argc; arg++)",
          "19159:   {",
          "19166:     if (setjmp(failure))",
          "19167:     {",
          "19168:       if (fileno(ifp) > 2)",
          "19169:         fclose(ifp);",
          "19170:       if (fileno(ofp) > 2)",
          "19171:         fclose(ofp);",
          "19176:     if (!(ifp = fopen(ifname, \"rb\")))",
          "19177:     {",
          "19178:       perror(ifname);",
          "19181:     status = (identify(), !is_raw);",
          "19184:     switch ((flip + 3600) % 360)",
          "19185:     {",
          "19186:     case 270:",
          "19187:       flip = 5;",
          "19188:       break;",
          "19189:     case 180:",
          "19190:       flip = 3;",
          "19191:       break;",
          "19192:     case 90:",
          "19193:       flip = 6;",
          "19195:     if (timestamp_only)",
          "19196:     {",
          "19198:         fprintf(stderr, _(\"%s has no timestamp.\\n\"), ifname);",
          "19200:         printf(\"%10ld%10d %s\\n\", (long)timestamp, shot_order, ifname);",
          "19201:       else",
          "19202:       {",
          "19203:         if (verbose)",
          "19204:           fprintf(stderr, _(\"%s time set to %d.\\n\"), ifname, (int)timestamp);",
          "19205:         ut.actime = ut.modtime = timestamp;",
          "19206:         utime(ifname, &ut);",
          "19211:     if (thumbnail_only)",
          "19212:     {",
          "19213:       if ((status = !thumb_offset))",
          "19214:       {",
          "19215:         fprintf(stderr, _(\"%s has no thumbnail.\\n\"), ifname);",
          "19216:         goto next;",
          "19217:       }",
          "19218:       else if (thumb_load_raw)",
          "19219:       {",
          "19220:         load_raw = thumb_load_raw;",
          "19221:         data_offset = thumb_offset;",
          "19222:         height = thumb_height;",
          "19223:         width = thumb_width;",
          "19224:         filters = 0;",
          "19225:         colors = 3;",
          "19226:       }",
          "19227:       else",
          "19228:       {",
          "19229:         fseek(ifp, thumb_offset, SEEK_SET);",
          "19230:         write_fun = write_thumb;",
          "19231:         goto thumbnail;",
          "19232:       }",
          "19233:     }",
          "19234:     if (load_raw == &CLASS kodak_ycbcr_load_raw)",
          "19235:     {",
          "19237:       width += width & 1;",
          "19240:     if (identify_only && verbose && make[0])",
          "19241:     {",
          "19242:       printf(_(\"\\nFilename: %s\\n\"), ifname);",
          "19243:       printf(_(\"Timestamp: %s\"), ctime(&timestamp));",
          "19244:       printf(_(\"Camera: %s %s\\n\"), make, model);",
          "19246:         printf(_(\"Owner: %s\\n\"), artist);",
          "19247:       if (dng_version)",
          "19248:       {",
          "19249:         printf(_(\"DNG Version: \"));",
          "19250:         for (i = 24; i >= 0; i -= 8)",
          "19251:           printf(\"%d%c\", dng_version >> i & 255, i ? '.' : '\\n');",
          "19252:       }",
          "19253:       printf(_(\"ISO speed: %d\\n\"), (int)iso_speed);",
          "19254:       printf(_(\"Shutter: \"));",
          "19256:         shutter = (printf(\"1/\"), 1 / shutter);",
          "19257:       printf(_(\"%0.1f sec\\n\"), shutter);",
          "19258:       printf(_(\"Aperture: f/%0.1f\\n\"), aperture);",
          "19259:       printf(_(\"Focal length: %0.1f mm\\n\"), focal_len);",
          "19260:       printf(_(\"Embedded ICC profile: %s\\n\"), profile_length ? _(\"yes\") : _(\"no\"));",
          "19261:       printf(_(\"Number of raw images: %d\\n\"), is_raw);",
          "19263:         printf(_(\"Pixel Aspect Ratio: %0.6f\\n\"), pixel_aspect);",
          "19265:         printf(_(\"Thumb size:  %4d x %d\\n\"), thumb_width, thumb_height);",
          "19266:       printf(_(\"Full size:   %4d x %d\\n\"), raw_width, raw_height);",
          "19267:     }",
          "19268:     else if (!is_raw)",
          "19269:       fprintf(stderr, _(\"Cannot decode file %s\\n\"), ifname);",
          "19270:     if (!is_raw)",
          "19271:       goto next;",
          "19272:     shrink = filters && (half_size || (!identify_only && (threshold || aber[0] != 1 || aber[2] != 1)));",
          "19274:     iwidth = (width + shrink) >> shrink;",
          "19275:     if (identify_only)",
          "19276:     {",
          "19277:       if (verbose)",
          "19278:       {",
          "19279:         if (document_mode == 3)",
          "19280:         {",
          "19281:           top_margin = left_margin = fuji_width = 0;",
          "19282:           height = raw_height;",
          "19283:           width = raw_width;",
          "19284:         }",
          "19285:         iheight = (height + shrink) >> shrink;",
          "19286:         iwidth = (width + shrink) >> shrink;",
          "19287:         if (use_fuji_rotate)",
          "19288:         {",
          "19289:           if (fuji_width)",
          "19290:           {",
          "19291:             fuji_width = (fuji_width - 1 + shrink) >> shrink;",
          "19292:             iwidth = fuji_width / sqrt(0.5);",
          "19293:             iheight = (iheight - fuji_width) / sqrt(0.5);",
          "19294:           }",
          "19295:           else",
          "19296:           {",
          "19297:             if (pixel_aspect < 1)",
          "19298:               iheight = iheight / pixel_aspect + 0.5;",
          "19299:             if (pixel_aspect > 1)",
          "19300:               iwidth = iwidth * pixel_aspect + 0.5;",
          "19301:           }",
          "19302:         }",
          "19303:         if (flip & 4)",
          "19304:           SWAP(iheight, iwidth);",
          "19305:         printf(_(\"Image size:  %4d x %d\\n\"), width, height);",
          "19306:         printf(_(\"Output size: %4d x %d\\n\"), iwidth, iheight);",
          "19307:         printf(_(\"Raw colors: %d\"), colors);",
          "19308:         if (filters)",
          "19309:         {",
          "19310:           int fhigh = 2, fwide = 2;",
          "19311:           if ((filters ^ (filters >> 8)) & 0xff)",
          "19312:             fhigh = 4;",
          "19313:           if ((filters ^ (filters >> 16)) & 0xffff)",
          "19314:             fhigh = 8;",
          "19315:           if (filters == 1)",
          "19316:             fhigh = fwide = 16;",
          "19317:           if (filters == 9)",
          "19318:             fhigh = fwide = 6;",
          "19319:           printf(_(\"\\nFilter pattern: \"));",
          "19320:           for (i = 0; i < fhigh; i++)",
          "19321:             for (c = i && putchar('/') && 0; c < fwide; c++)",
          "19322:               putchar(cdesc[fcol(i, c)]);",
          "19323:         }",
          "19324:         printf(_(\"\\nDaylight multipliers:\"));",
          "19325:         FORCC printf(\" %f\", pre_mul[c]);",
          "19326:         if (cam_mul[0] > 0)",
          "19327:         {",
          "19328:           printf(_(\"\\nCamera multipliers:\"));",
          "19329:           FORC4 printf(\" %f\", cam_mul[c]);",
          "19330:         }",
          "19331:         putchar('\\n');",
          "19332:       }",
          "19333:       else",
          "19334:         printf(_(\"%s is a %s %s image.\\n\"), ifname, make, model);",
          "19335:     next:",
          "19339:     if (meta_length)",
          "19340:     {",
          "19341:       meta_data = (char *)malloc(meta_length);",
          "19342:       merror(meta_data, \"main()\");",
          "19343:     }",
          "19344:     if (filters || colors == 1)",
          "19345:     {",
          "19346:       raw_image = (ushort *)calloc((raw_height + 7), raw_width * 2);",
          "19347:       merror(raw_image, \"main()\");",
          "19349:     else",
          "19350:     {",
          "19351:       image = (ushort(*)[4])calloc(iheight, iwidth * sizeof *image);",
          "19352:       merror(image, \"main()\");",
          "19355:       fprintf(stderr, _(\"Loading %s %s image from %s ...\\n\"), make, model, ifname);",
          "19357:       fprintf(stderr, _(\"%s: \\\"-s %d\\\" requests a nonexistent image!\\n\"), ifname, shot_select);",
          "19358:     fseeko(ifp, data_offset, SEEK_SET);",
          "19360:       fread(raw_image, 2, raw_height * raw_width, stdin);",
          "19361:     else",
          "19362:       (*load_raw)();",
          "19363:     if (document_mode == 3)",
          "19364:     {",
          "19367:       width = raw_width;",
          "19370:     iwidth = (width + shrink) >> shrink;",
          "19371:     if (raw_image)",
          "19372:     {",
          "19373:       image = (ushort(*)[4])calloc(iheight, iwidth * sizeof *image);",
          "19374:       merror(image, \"main()\");",
          "19376:       free(raw_image);",
          "19378:     if (zero_is_bad)",
          "19379:       remove_zeroes();",
          "19380:     bad_pixels(bpfile);",
          "19381:     if (dark_frame)",
          "19382:       subtract(dark_frame);",
          "19384:     if (user_qual >= 0)",
          "19385:       quality = user_qual;",
          "19391:     FORC(cblack[4] * cblack[5])",
          "19392:     if (i > cblack[6 + c])",
          "19393:       i = cblack[6 + c];",
          "19394:     FORC(cblack[4] * cblack[5])",
          "19395:     cblack[6 + c] -= i;",
          "19397:     if (user_black >= 0)",
          "19398:       black = user_black;",
          "19400:     if (user_sat > 0)",
          "19401:       maximum = user_sat;",
          "19405:     if (is_foveon)",
          "19406:     {",
          "19407:       if (document_mode || load_raw == &CLASS foveon_dp_load_raw)",
          "19408:       {",
          "19409:         for (i = 0; i < height * width * 4; i++)",
          "19410:           if ((short)image[0][i] < 0)",
          "19411:             image[0][i] = 0;",
          "19412:       }",
          "19413:       else",
          "19414:         foveon_interpolate();",
          "19415:     }",
          "19416:     else if (document_mode < 2)",
          "19419:     if (filters && !document_mode)",
          "19420:     {",
          "19422:         lin_interpolate();",
          "19424:         vng_interpolate();",
          "19426:         ppg_interpolate();",
          "19428:         xtrans_interpolate(quality * 2 - 3);",
          "19430:         ahd_interpolate();",
          "19433:       for (colors = 3, i = 0; i < height * width; i++)",
          "19434:         image[i][1] = (image[i][1] + image[i][3]) >> 1;",
          "19435:     if (!is_foveon && colors == 3)",
          "19436:       median_filter();",
          "19437:     if (!is_foveon && highlight == 2)",
          "19438:       blend_highlights();",
          "19439:     if (!is_foveon && highlight > 2)",
          "19440:       recover_highlights();",
          "19441:     if (use_fuji_rotate)",
          "19442:       fuji_rotate();",
          "19444:     if (cam_profile)",
          "19445:       apply_profile(cam_profile, out_profile);",
          "19448:     if (use_fuji_rotate)",
          "19449:       stretch();",
          "19450:   thumbnail:",
          "19456:       write_ext = \".pgm\\0.ppm\\0.ppm\\0.pam\" + colors * 5 - 5;",
          "19457:     ofname = (char *)malloc(strlen(ifname) + 64);",
          "19458:     merror(ofname, \"main()\");",
          "19460:       strcpy(ofname, _(\"standard output\"));",
          "19461:     else",
          "19462:     {",
          "19463:       strcpy(ofname, ifname);",
          "19464:       if ((cp = strrchr(ofname, '.')))",
          "19467:         sprintf(ofname + strlen(ofname), \"_%0*d\", snprintf(0, 0, \"%d\", is_raw - 1), shot_select);",
          "19469:         strcat(ofname, \".thumb\");",
          "19470:       strcat(ofname, write_ext);",
          "19471:       ofp = fopen(ofname, \"wb\");",
          "19472:       if (!ofp)",
          "19473:       {",
          "19474:         status = 1;",
          "19475:         perror(ofname);",
          "19476:         goto cleanup;",
          "19480:       fprintf(stderr, _(\"Writing data to %s ...\\n\"), ofname);",
          "19483:     if (ofp != stdout)",
          "19484:       fclose(ofp);",
          "19485:   cleanup:",
          "19486:     if (meta_data)",
          "19487:       free(meta_data);",
          "19488:     if (ofname)",
          "19489:       free(ofname);",
          "19490:     if (oprof)",
          "19491:       free(oprof);",
          "19492:     if (image)",
          "19493:       free(image);",
          "19494:     if (multi_out)",
          "19495:     {",
          "19496:       if (++shot_select < is_raw)",
          "19497:         arg--;",
          "19498:       else",
          "19499:         shot_select = 0;",
          "",
          "---------------"
        ],
        "internal/dcraw_common.cpp||internal/dcraw_common.cpp": [
          "File: internal/dcraw_common.cpp -> internal/dcraw_common.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: #include \"libraw/libraw.h\"",
          "28: #include \"internal/defines.h\"",
          "29: #include \"internal/var_defines.h\"",
          "53: }",
          "54: static size_t local_strnlen(const char *s, size_t n)",
          "55: {",
          "56:   const char *p = (const char *)memchr(s, 0, n);",
          "58: }",
          "62: #ifdef LIBRAW_LIBRARY_BUILD",
          "63: static int stread(char *buf, size_t len, LibRaw_abstract_datastream *fp)",
          "64: {",
          "68: }",
          "70: #endif",
          "72: #ifndef __GLIBC__",
          "75: {",
          "76:   char *c;",
          "77:   for (c = haystack; c <= haystack + haystacklen - needlelen; c++)",
          "79:       return c;",
          "80:   return 0;",
          "81: }",
          "82: #define memmem my_memmem",
          "84: {",
          "85:   char *c;",
          "86:   for (c = haystack; *c; c++)",
          "",
          "[Removed Lines]",
          "30: int CLASS fcol (int row, int col)",
          "31: {",
          "32:   static const char filter[16][16] =",
          "33:   { { 2,1,1,3,2,3,2,0,3,2,3,0,1,2,1,0 },",
          "34:     { 0,3,0,2,0,1,3,1,0,1,1,2,0,3,3,2 },",
          "35:     { 2,3,3,2,3,1,1,3,3,1,2,1,2,0,0,3 },",
          "36:     { 0,1,0,1,0,2,0,2,2,0,3,0,1,3,2,1 },",
          "37:     { 3,1,1,2,0,1,0,2,1,3,1,3,0,1,3,0 },",
          "38:     { 2,0,0,3,3,2,3,1,2,0,2,0,3,2,2,1 },",
          "39:     { 2,3,3,1,2,1,2,1,2,1,1,2,3,0,0,1 },",
          "40:     { 1,0,0,2,3,0,0,3,0,3,0,3,2,1,2,3 },",
          "41:     { 2,3,3,1,1,2,1,0,3,2,3,0,2,3,1,3 },",
          "42:     { 1,0,2,0,3,0,3,2,0,1,1,2,0,1,0,2 },",
          "43:     { 0,1,1,3,3,2,2,1,1,3,3,0,2,1,3,2 },",
          "44:     { 2,3,2,0,0,1,3,0,2,0,1,2,3,0,1,0 },",
          "45:     { 1,3,1,2,3,2,3,2,0,2,0,1,1,0,3,0 },",
          "46:     { 0,2,0,3,1,0,0,1,1,3,3,2,3,2,2,1 },",
          "47:     { 2,1,3,2,3,1,2,1,0,3,0,2,0,2,0,2 },",
          "48:     { 0,3,1,0,0,2,0,3,2,1,3,1,1,3,1,3 } };",
          "50:   if (filters == 1) return filter[(row+top_margin)&15][(col+left_margin)&15];",
          "51:   if (filters == 9) return xtrans[(row+6) % 6][(col+6) % 6];",
          "52:   return FC(row,col);",
          "57:   return(p ? p-s : n);",
          "60: #define strnlen(a,b) local_strnlen(a,b)",
          "65:  int r = fp->read(buf,len,1);",
          "66:  buf[len-1] = 0;",
          "67:  return r;",
          "69: #define stmread(buf,maxlen,fp) stread(buf,MIN(maxlen,sizeof(buf)),fp)",
          "73: char *my_memmem (char *haystack, size_t haystacklen,",
          "74:        char *needle, size_t needlelen)",
          "78:     if (!memcmp (c, needle, needlelen))",
          "83: char *my_strcasestr (char *haystack, const char *needle)",
          "",
          "[Added Lines]",
          "30: int CLASS fcol(int row, int col)",
          "31: {",
          "32:   static const char filter[16][16] = {",
          "33:       {2, 1, 1, 3, 2, 3, 2, 0, 3, 2, 3, 0, 1, 2, 1, 0}, {0, 3, 0, 2, 0, 1, 3, 1, 0, 1, 1, 2, 0, 3, 3, 2},",
          "34:       {2, 3, 3, 2, 3, 1, 1, 3, 3, 1, 2, 1, 2, 0, 0, 3}, {0, 1, 0, 1, 0, 2, 0, 2, 2, 0, 3, 0, 1, 3, 2, 1},",
          "35:       {3, 1, 1, 2, 0, 1, 0, 2, 1, 3, 1, 3, 0, 1, 3, 0}, {2, 0, 0, 3, 3, 2, 3, 1, 2, 0, 2, 0, 3, 2, 2, 1},",
          "36:       {2, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 2, 3, 0, 0, 1}, {1, 0, 0, 2, 3, 0, 0, 3, 0, 3, 0, 3, 2, 1, 2, 3},",
          "37:       {2, 3, 3, 1, 1, 2, 1, 0, 3, 2, 3, 0, 2, 3, 1, 3}, {1, 0, 2, 0, 3, 0, 3, 2, 0, 1, 1, 2, 0, 1, 0, 2},",
          "38:       {0, 1, 1, 3, 3, 2, 2, 1, 1, 3, 3, 0, 2, 1, 3, 2}, {2, 3, 2, 0, 0, 1, 3, 0, 2, 0, 1, 2, 3, 0, 1, 0},",
          "39:       {1, 3, 1, 2, 3, 2, 3, 2, 0, 2, 0, 1, 1, 0, 3, 0}, {0, 2, 0, 3, 1, 0, 0, 1, 1, 3, 3, 2, 3, 2, 2, 1},",
          "40:       {2, 1, 3, 2, 3, 1, 2, 1, 0, 3, 0, 2, 0, 2, 0, 2}, {0, 3, 1, 0, 0, 2, 0, 3, 2, 1, 3, 1, 1, 3, 1, 3}};",
          "42:   if (filters == 1)",
          "43:     return filter[(row + top_margin) & 15][(col + left_margin) & 15];",
          "44:   if (filters == 9)",
          "45:     return xtrans[(row + 6) % 6][(col + 6) % 6];",
          "46:   return FC(row, col);",
          "51:   return (p ? p - s : n);",
          "54: #define strnlen(a, b) local_strnlen(a, b)",
          "59:   int r = fp->read(buf, len, 1);",
          "60:   buf[len - 1] = 0;",
          "61:   return r;",
          "63: #define stmread(buf, maxlen, fp) stread(buf, MIN(maxlen, sizeof(buf)), fp)",
          "67: char *my_memmem(char *haystack, size_t haystacklen, char *needle, size_t needlelen)",
          "71:     if (!memcmp(c, needle, needlelen))",
          "76: char *my_strcasestr(char *haystack, const char *needle)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "91: #define strcasestr my_strcasestr",
          "92: #endif",
          "97: {",
          "99:     return s[0] | s[1] << 8;",
          "101:     return s[0] << 8 | s[1];",
          "102: }",
          "108: #ifdef LIBRAW_LIBRARY_BUILD",
          "110: {",
          "112:   char *p = line;",
          "113:   int nwords = 0;",
          "116:   {",
          "119:     words[nwords++] = p;",
          "124:   }",
          "125: }",
          "141: }",
          "147: }",
          "152: {",
          "157: }",
          "158: #endif",
          "160: ushort CLASS get2()",
          "161: {",
          "164:   return sget2(str);",
          "165: }",
          "168: {",
          "169:   if (order == 0x4949)",
          "170:     return s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;",
          "",
          "[Removed Lines]",
          "94: #define strbuflen(buf) strnlen(buf,sizeof(buf)-1)",
          "96: ushort CLASS sget2 (uchar *s)",
          "105: #define CameraDNG 1",
          "106: #define AdobeDNG 2",
          "109: static int getwords(char *line, char *words[], int maxwords,int maxlen)",
          "111:   line[maxlen-1] = 0;",
          "115:   while(1)",
          "117:     while(isspace(*p)) p++;",
          "118:     if(*p == '\\0') return nwords;",
          "120:     while(!isspace(*p) && *p != '\\0') p++;",
          "121:     if(*p == '\\0') return nwords;",
          "123:     if(nwords >= maxwords) return nwords;",
          "127: static ushort saneSonyCameraInfo(uchar a, uchar b, uchar c, uchar d, uchar e, uchar f){",
          "128:  if ((a >> 4) > 9) return 0;",
          "129:  else if ((a & 0x0f) > 9) return 0;",
          "130:  else if ((b >> 4) > 9) return 0;",
          "131:  else if ((b & 0x0f) > 9) return 0;",
          "132:  else if ((c >> 4) > 9) return 0;",
          "133:  else if ((c & 0x0f) > 9) return 0;",
          "134:  else if ((d >> 4) > 9) return 0;",
          "135:  else if ((d & 0x0f) > 9) return 0;",
          "136:  else if ((e >> 4) > 9) return 0;",
          "137:  else if ((e & 0x0f) > 9) return 0;",
          "138:  else if ((f >> 4) > 9) return 0;",
          "139:  else if ((f & 0x0f) > 9) return 0;",
          "140: return 1;",
          "143: static ushort bcd2dec(uchar data){",
          "144:  if ((data >> 4) > 9) return 0;",
          "145:  else if ((data & 0x0f) > 9) return 0;",
          "146:  else return (data >> 4) * 10 + (data & 0x0f);",
          "149: static uchar SonySubstitution[257] = \"\\x00\\x01\\x32\\xb1\\x0a\\x0e\\x87\\x28\\x02\\xcc\\xca\\xad\\x1b\\xdc\\x08\\xed\\x64\\x86\\xf0\\x4f\\x8c\\x6c\\xb8\\xcb\\x69\\xc4\\x2c\\x03\\x97\\xb6\\x93\\x7c\\x14\\xf3\\xe2\\x3e\\x30\\x8e\\xd7\\x60\\x1c\\xa1\\xab\\x37\\xec\\x75\\xbe\\x23\\x15\\x6a\\x59\\x3f\\xd0\\xb9\\x96\\xb5\\x50\\x27\\x88\\xe3\\x81\\x94\\xe0\\xc0\\x04\\x5c\\xc6\\xe8\\x5f\\x4b\\x70\\x38\\x9f\\x82\\x80\\x51\\x2b\\xc5\\x45\\x49\\x9b\\x21\\x52\\x53\\x54\\x85\\x0b\\x5d\\x61\\xda\\x7b\\x55\\x26\\x24\\x07\\x6e\\x36\\x5b\\x47\\xb7\\xd9\\x4a\\xa2\\xdf\\xbf\\x12\\x25\\xbc\\x1e\\x7f\\x56\\xea\\x10\\xe6\\xcf\\x67\\x4d\\x3c\\x91\\x83\\xe1\\x31\\xb3\\x6f\\xf4\\x05\\x8a\\x46\\xc8\\x18\\x76\\x68\\xbd\\xac\\x92\\x2a\\x13\\xe9\\x0f\\xa3\\x7a\\xdb\\x3d\\xd4\\xe7\\x3a\\x1a\\x57\\xaf\\x20\\x42\\xb2\\x9e\\xc3\\x8b\\xf2\\xd5\\xd3\\xa4\\x7e\\x1f\\x98\\x9c\\xee\\x74\\xa5\\xa6\\xa7\\xd8\\x5e\\xb0\\xb4\\x34\\xce\\xa8\\x79\\x77\\x5a\\xc1\\x89\\xae\\x9a\\x11\\x33\\x9d\\xf5\\x39\\x19\\x65\\x78\\x16\\x71\\xd2\\xa9\\x44\\x63\\x40\\x29\\xba\\xa0\\x8f\\xe4\\xd6\\x3b\\x84\\x0d\\xc2\\x4e\\x58\\xdd\\x99\\x22\\x6b\\xc9\\xbb\\x17\\x06\\xe5\\x7d\\x66\\x43\\x62\\xf6\\xcd\\x35\\x90\\x2e\\x41\\x8d\\x6d\\xaa\\x09\\x73\\x95\\x0c\\xf1\\x1d\\xde\\x4c\\x2f\\x2d\\xf7\\xd1\\x72\\xeb\\xef\\x48\\xc7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\";",
          "151: ushort CLASS sget2Rev(uchar *s) // specific to some Canon Makernotes fields, where they have endian in reverse",
          "154:   return s[0] | s[1] << 8;",
          "156:   return s[0] << 8 | s[1];",
          "162:   uchar str[2] = { 0xff,0xff };",
          "163:   fread (str, 1, 2, ifp);",
          "167: unsigned CLASS sget4 (uchar *s)",
          "",
          "[Added Lines]",
          "87: #define strbuflen(buf) strnlen(buf, sizeof(buf) - 1)",
          "89: ushort CLASS sget2(uchar *s)",
          "98: #define CameraDNG 1",
          "99: #define AdobeDNG 2",
          "102: static int getwords(char *line, char *words[], int maxwords, int maxlen)",
          "104:   line[maxlen - 1] = 0;",
          "108:   while (1)",
          "110:     while (isspace(*p))",
          "111:       p++;",
          "112:     if (*p == '\\0')",
          "113:       return nwords;",
          "115:     while (!isspace(*p) && *p != '\\0')",
          "116:       p++;",
          "117:     if (*p == '\\0')",
          "118:       return nwords;",
          "120:     if (nwords >= maxwords)",
          "121:       return nwords;",
          "125: static ushort saneSonyCameraInfo(uchar a, uchar b, uchar c, uchar d, uchar e, uchar f)",
          "126: {",
          "127:   if ((a >> 4) > 9)",
          "128:     return 0;",
          "129:   else if ((a & 0x0f) > 9)",
          "130:     return 0;",
          "131:   else if ((b >> 4) > 9)",
          "132:     return 0;",
          "133:   else if ((b & 0x0f) > 9)",
          "134:     return 0;",
          "135:   else if ((c >> 4) > 9)",
          "136:     return 0;",
          "137:   else if ((c & 0x0f) > 9)",
          "138:     return 0;",
          "139:   else if ((d >> 4) > 9)",
          "140:     return 0;",
          "141:   else if ((d & 0x0f) > 9)",
          "142:     return 0;",
          "143:   else if ((e >> 4) > 9)",
          "144:     return 0;",
          "145:   else if ((e & 0x0f) > 9)",
          "146:     return 0;",
          "147:   else if ((f >> 4) > 9)",
          "148:     return 0;",
          "149:   else if ((f & 0x0f) > 9)",
          "150:     return 0;",
          "151:   return 1;",
          "154: static ushort bcd2dec(uchar data)",
          "155: {",
          "156:   if ((data >> 4) > 9)",
          "157:     return 0;",
          "158:   else if ((data & 0x0f) > 9)",
          "159:     return 0;",
          "160:   else",
          "161:     return (data >> 4) * 10 + (data & 0x0f);",
          "164: static uchar SonySubstitution[257] =",
          "165:     \"\\x00\\x01\\x32\\xb1\\x0a\\x0e\\x87\\x28\\x02\\xcc\\xca\\xad\\x1b\\xdc\\x08\\xed\\x64\\x86\\xf0\\x4f\\x8c\\x6c\\xb8\\xcb\\x69\\xc4\\x2c\\x03\"",
          "166:     \"\\x97\\xb6\\x93\\x7c\\x14\\xf3\\xe2\\x3e\\x30\\x8e\\xd7\\x60\\x1c\\xa1\\xab\\x37\\xec\\x75\\xbe\\x23\\x15\\x6a\\x59\\x3f\\xd0\\xb9\\x96\\xb5\"",
          "167:     \"\\x50\\x27\\x88\\xe3\\x81\\x94\\xe0\\xc0\\x04\\x5c\\xc6\\xe8\\x5f\\x4b\\x70\\x38\\x9f\\x82\\x80\\x51\\x2b\\xc5\\x45\\x49\\x9b\\x21\\x52\\x53\"",
          "168:     \"\\x54\\x85\\x0b\\x5d\\x61\\xda\\x7b\\x55\\x26\\x24\\x07\\x6e\\x36\\x5b\\x47\\xb7\\xd9\\x4a\\xa2\\xdf\\xbf\\x12\\x25\\xbc\\x1e\\x7f\\x56\\xea\"",
          "169:     \"\\x10\\xe6\\xcf\\x67\\x4d\\x3c\\x91\\x83\\xe1\\x31\\xb3\\x6f\\xf4\\x05\\x8a\\x46\\xc8\\x18\\x76\\x68\\xbd\\xac\\x92\\x2a\\x13\\xe9\\x0f\\xa3\"",
          "170:     \"\\x7a\\xdb\\x3d\\xd4\\xe7\\x3a\\x1a\\x57\\xaf\\x20\\x42\\xb2\\x9e\\xc3\\x8b\\xf2\\xd5\\xd3\\xa4\\x7e\\x1f\\x98\\x9c\\xee\\x74\\xa5\\xa6\\xa7\"",
          "171:     \"\\xd8\\x5e\\xb0\\xb4\\x34\\xce\\xa8\\x79\\x77\\x5a\\xc1\\x89\\xae\\x9a\\x11\\x33\\x9d\\xf5\\x39\\x19\\x65\\x78\\x16\\x71\\xd2\\xa9\\x44\\x63\"",
          "172:     \"\\x40\\x29\\xba\\xa0\\x8f\\xe4\\xd6\\x3b\\x84\\x0d\\xc2\\x4e\\x58\\xdd\\x99\\x22\\x6b\\xc9\\xbb\\x17\\x06\\xe5\\x7d\\x66\\x43\\x62\\xf6\\xcd\"",
          "173:     \"\\x35\\x90\\x2e\\x41\\x8d\\x6d\\xaa\\x09\\x73\\x95\\x0c\\xf1\\x1d\\xde\\x4c\\x2f\\x2d\\xf7\\xd1\\x72\\xeb\\xef\\x48\\xc7\\xf8\\xf9\\xfa\\xfb\"",
          "174:     \"\\xfc\\xfd\\xfe\\xff\";",
          "176: ushort CLASS sget2Rev(uchar *s) // specific to some Canon Makernotes fields, where they have endian in reverse",
          "179:     return s[0] | s[1] << 8;",
          "181:     return s[0] << 8 | s[1];",
          "187:   uchar str[2] = {0xff, 0xff};",
          "188:   fread(str, 1, 2, ifp);",
          "192: unsigned CLASS sget4(uchar *s)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "176: unsigned CLASS get4()",
          "177: {",
          "180:   return sget4(str);",
          "181: }",
          "189: {",
          "191:   u.i = i;",
          "192:   return u.f;",
          "193: }",
          "196: {",
          "198:   int i, rev;",
          "220:   }",
          "221: }",
          "224: {",
          "226:   if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))",
          "228: }",
          "231: {",
          "232:   float **A, *b, *c, *d, *x, *y;",
          "233:   int i, j;",
          "242:     x[i] = x_[i] / 65535.0;",
          "243:     y[i] = y_[i] / 65535.0;",
          "244:   }",
          "248:   }",
          "254:     }",
          "256:   }",
          "261:   }",
          "263:     float acc = 0;",
          "267:   }",
          "269:     float x_out = (float)(i / 65535.0);",
          "270:     float y_out = 0;",
          "277:       }",
          "278:     }",
          "281:   }",
          "283: }",
          "286: {",
          "287:   static const short mul[4][5] = {",
          "292:   int lo, hi, i;",
          "299:   if (lo != hi)",
          "303: }",
          "307: {",
          "311:     if (ratio[1] < -104)",
          "317:     if (ratio[1] < -50)",
          "319:     if (ratio[1] > 307)",
          "321:   }",
          "327:   miss = target - ratio[0];",
          "331:   ratio[0] = target - miss;",
          "332:   return 1;",
          "333: }",
          "335: void CLASS canon_600_auto_wb()",
          "336: {",
          "338:   int test[8], total[2][8], ratio[2][2], stat[2];",
          "341:   i = canon_ev + 0.5;",
          "367:       count[st]++;",
          "369:     }",
          "374:   }",
          "375: }",
          "377: void CLASS canon_600_coeff()",
          "378: {",
          "387:   float mc, yc;",
          "389:   mc = pre_mul[1] / pre_mul[2];",
          "390:   yc = pre_mul[3] / pre_mul[2];",
          "395:   }",
          "399: }",
          "401: void CLASS canon_600_load_raw()",
          "402: {",
          "404:   ushort *pix;",
          "405:   int irow, row;",
          "408: #ifdef LIBRAW_LIBRARY_BUILD",
          "409:     checkCancel();",
          "410: #endif",
          "415:       pix[1] = (dp[2] << 2) + (dp[1] >> 4 & 3);",
          "416:       pix[2] = (dp[3] << 2) + (dp[1] >> 2 & 3);",
          "419:       pix[5] = (dp[6] << 2) + (dp[9] >> 2 & 3);",
          "420:       pix[6] = (dp[7] << 2) + (dp[9] >> 4 & 3);",
          "422:     }",
          "424:   }",
          "425: }",
          "427: void CLASS canon_600_correct()",
          "428: {",
          "429:   int row, col, val;",
          "435: #ifdef LIBRAW_LIBRARY_BUILD",
          "436:     checkCancel();",
          "437: #endif",
          "440:       val = val * mul[row & 3][col & 1] >> 9;",
          "443:     }",
          "444:   canon_600_fixed_wb(1311);",
          "445:   canon_600_auto_wb();",
          "446:   canon_600_coeff();",
          "",
          "[Removed Lines]",
          "178:   uchar str[4] = { 0xff,0xff,0xff,0xff };",
          "179:   fread (str, 1, 4, ifp);",
          "183: unsigned CLASS getint (int type)",
          "184: {",
          "185:   return type == 3 ? get2() : get4();",
          "186: }",
          "188: float CLASS int_to_float (int i)",
          "190:   union { int i; float f; } u;",
          "195: double CLASS getreal (int type)",
          "197:   union { char c[8]; double d; } u,v;",
          "200:   switch (type) {",
          "201:     case 3: return (unsigned short) get2();",
          "202:     case 4: return (unsigned int) get4();",
          "203:     case 5:",
          "204:       u.d = (unsigned int) get4();",
          "205:       v.d = (unsigned int)get4();",
          "206:       return u.d / (v.d ? v.d : 1);",
          "207:     case 8: return (signed short) get2();",
          "208:     case 9: return (signed int) get4();",
          "209:     case 10:",
          "210:       u.d = (signed int) get4();",
          "211:       v.d = (signed int)get4();",
          "212:       return u.d / (v.d?v.d:1);",
          "213:     case 11: return int_to_float (get4());",
          "214:     case 12:",
          "215:       rev = 7 * ((order == 0x4949) == (ntohs(0x1234) == 0x1234));",
          "216:       for (i=0; i < 8; i++)",
          "217:  u.c[i ^ rev] = fgetc(ifp);",
          "218:       return u.d;",
          "219:     default: return fgetc(ifp);",
          "223: void CLASS read_shorts (ushort *pixel, int count)",
          "225:   if (fread (pixel, 2, count, ifp) < count) derror();",
          "227:     swab ((char*)pixel, (char*)pixel, count*2);",
          "230: void CLASS cubic_spline (const int *x_, const int *y_, const int len)",
          "235:   A = (float **) calloc (((2*len + 4)*sizeof **A + sizeof *A), 2*len);",
          "236:   if (!A) return;",
          "237:   A[0] = (float *) (A + 2*len);",
          "238:   for (i = 1; i < 2*len; i++)",
          "239:     A[i] = A[0] + 2*len*i;",
          "240:   y = len + (x = i + (d = i + (c = i + (b = A[0] + i*i))));",
          "241:   for (i = 0; i < len; i++) {",
          "245:   for (i = len-1; i > 0; i--) {",
          "246:     b[i] = (y[i] - y[i-1]) / (x[i] - x[i-1]);",
          "247:     d[i-1] = x[i] - x[i-1];",
          "249:   for (i = 1; i < len-1; i++) {",
          "250:     A[i][i] = 2 * (d[i-1] + d[i]);",
          "251:     if (i > 1) {",
          "252:       A[i][i-1] = d[i-1];",
          "253:       A[i-1][i] = d[i-1];",
          "255:     A[i][len-1] = 6 * (b[i+1] - b[i]);",
          "257:   for(i = 1; i < len-2; i++) {",
          "258:     float v = A[i+1][i] / A[i][i];",
          "259:     for(j = 1; j <= len-1; j++)",
          "260:       A[i+1][j] -= v * A[i][j];",
          "262:   for(i = len-2; i > 0; i--) {",
          "264:     for(j = i; j <= len-2; j++)",
          "265:       acc += A[i][j]*c[j];",
          "266:     c[i] = (A[i][len-1] - acc) / A[i][i];",
          "268:   for (i = 0; i < 0x10000; i++) {",
          "271:     for (j = 0; j < len-1; j++) {",
          "272:       if (x[j] <= x_out && x_out <= x[j+1]) {",
          "273:  float v = x_out - x[j];",
          "274:  y_out = y[j] +",
          "275:    ((y[j+1] - y[j]) / d[j] - (2 * d[j] * c[j] + c[j+1] * d[j])/6) * v",
          "276:     + (c[j] * 0.5) * v*v + ((c[j+1] - c[j]) / (6 * d[j])) * v*v*v;",
          "279:     curve[i] = y_out < 0.0 ? 0 : (y_out >= 1.0 ? 65535 :",
          "280:   (ushort)(y_out * 65535.0 + 0.5));",
          "282:   free (A);",
          "285: void CLASS canon_600_fixed_wb (int temp)",
          "288:     {  667, 358,397,565,452 },",
          "289:     {  731, 390,367,499,517 },",
          "290:     { 1119, 396,348,448,537 },",
          "291:     { 1399, 485,431,508,688 } };",
          "293:   float frac=0;",
          "295:   for (lo=4; --lo; )",
          "296:     if (*mul[lo] <= temp) break;",
          "297:   for (hi=0; hi < 3; hi++)",
          "298:     if (*mul[hi] >= temp) break;",
          "300:     frac = (float) (temp - *mul[lo]) / (*mul[hi] - *mul[lo]);",
          "301:   for (i=1; i < 5; i++)",
          "302:     pre_mul[i-1] = 1 / (frac * mul[hi][i] + (1-frac) * mul[lo][i]);",
          "306: int CLASS canon_600_color (int ratio[2], int mar)",
          "308:   int clipped=0, target, miss;",
          "310:   if (flash_used) {",
          "312:       { ratio[1] = -104; clipped = 1; }",
          "313:     if (ratio[1] >   12)",
          "314:       { ratio[1] =   12; clipped = 1; }",
          "315:   } else {",
          "316:     if (ratio[1] < -264 || ratio[1] > 461) return 2;",
          "318:       { ratio[1] = -50; clipped = 1; }",
          "320:       { ratio[1] = 307; clipped = 1; }",
          "322:   target = flash_used || ratio[1] < 197",
          "323:  ? -38 - (398 * ratio[1] >> 10)",
          "324:  : -123 + (48 * ratio[1] >> 10);",
          "325:   if (target - mar <= ratio[0] &&",
          "326:       target + 20  >= ratio[0] && !clipped) return 0;",
          "328:   if (abs(miss) >= mar*4) return 2;",
          "329:   if (miss < -20) miss = -20;",
          "330:   if (miss > mar) miss = mar;",
          "337:   int mar, row, col, i, j, st, count[] = { 0,0 };",
          "340:   memset (&total, 0, sizeof total);",
          "342:   if      (i < 10) mar = 150;",
          "343:   else if (i > 12) mar = 20;",
          "344:   else mar = 280 - 20 * i;",
          "345:   if (flash_used) mar = 80;",
          "346:   for (row=14; row < height-14; row+=4)",
          "347:     for (col=10; col < width; col+=2) {",
          "348:       for (i=0; i < 8; i++)",
          "349:  test[(i & 4) + FC(row+(i >> 1),col+(i & 1))] =",
          "350:       BAYER(row+(i >> 1),col+(i & 1));",
          "351:       for (i=0; i < 8; i++)",
          "352:  if (test[i] < 150 || test[i] > 1500) goto next;",
          "353:       for (i=0; i < 4; i++)",
          "354:  if (abs(test[i] - test[i+4]) > 50) goto next;",
          "355:       for (i=0; i < 2; i++) {",
          "356:  for (j=0; j < 4; j+=2)",
          "357:    ratio[i][j >> 1] = ((test[i*4+j+1]-test[i*4+j]) << 10) / test[i*4+j];",
          "358:  stat[i] = canon_600_color (ratio[i], mar);",
          "359:       }",
          "360:       if ((st = stat[0] | stat[1]) > 1) goto next;",
          "361:       for (i=0; i < 2; i++)",
          "362:  if (stat[i])",
          "363:    for (j=0; j < 2; j++)",
          "364:      test[i*4+j*2+1] = test[i*4+j*2] * (0x400 + ratio[i][j]) >> 10;",
          "365:       for (i=0; i < 8; i++)",
          "366:  total[st][i] += test[i];",
          "368: next: ;",
          "370:   if (count[0] | count[1]) {",
          "371:     st = count[0]*200 < count[1];",
          "372:     for (i=0; i < 4; i++)",
          "373:       pre_mul[i] = 1.0 / (total[st][i] + total[st][i+4]);",
          "379:   static const short table[6][12] = {",
          "380:     { -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },",
          "381:     { -1203,1715,-1136,1648, 1388,-876,267,245,  -1641,2153,3921,-3409 },",
          "382:     { -615,1127,-1563,2075,  1437,-925,509,3,     -756,1268,2519,-2007 },",
          "383:     { -190,702,-1886,2398,   2153,-1641,763,-251, -452,964,3040,-2528  },",
          "384:     { -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },",
          "385:     { -807,1319,-1785,2297,  1388,-876,769,-257,  -230,742,2067,-1555  } };",
          "386:   int t=0, i, c;",
          "391:   if (mc > 1 && mc <= 1.28 && yc < 0.8789) t=1;",
          "392:   if (mc > 1.28 && mc <= 2) {",
          "393:     if  (yc < 0.8789) t=3;",
          "394:     else if (yc <= 2) t=4;",
          "396:   if (flash_used) t=5;",
          "397:   for (raw_color = i=0; i < 3; i++)",
          "398:     FORCC rgb_cam[i][c] = table[t][i*4 + c] / 1024.0;",
          "403:   uchar  data[1120], *dp;",
          "407:   for (irow=row=0; irow < height; irow++) {",
          "411:     if (fread (data, 1, 1120, ifp) < 1120) derror();",
          "412:     pix = raw_image + row*raw_width;",
          "413:     for (dp=data; dp < data+1120;  dp+=10, pix+=8) {",
          "414:       pix[0] = (dp[0] << 2) + (dp[1] >> 6    );",
          "417:       pix[3] = (dp[4] << 2) + (dp[1]      & 3);",
          "418:       pix[4] = (dp[5] << 2) + (dp[9]      & 3);",
          "421:       pix[7] = (dp[8] << 2) + (dp[9] >> 6    );",
          "423:     if ((row+=2) > height) row = 1;",
          "430:   static const short mul[4][2] =",
          "431:   { { 1141,1145 }, { 1128,1109 }, { 1178,1149 }, { 1128,1109 } };",
          "433:   for (row=0; row < height; row++)",
          "434:     {",
          "438:     for (col=0; col < width; col++) {",
          "439:       if ((val = BAYER(row,col) - black) < 0) val = 0;",
          "441:       BAYER(row,col) = val;",
          "442:     }",
          "",
          "[Added Lines]",
          "203:   uchar str[4] = {0xff, 0xff, 0xff, 0xff};",
          "204:   fread(str, 1, 4, ifp);",
          "208: unsigned CLASS getint(int type) { return type == 3 ? get2() : get4(); }",
          "210: float CLASS int_to_float(int i)",
          "212:   union {",
          "213:     int i;",
          "214:     float f;",
          "215:   } u;",
          "220: double CLASS getreal(int type)",
          "222:   union {",
          "223:     char c[8];",
          "224:     double d;",
          "225:   } u, v;",
          "228:   switch (type)",
          "229:   {",
          "230:   case 3:",
          "231:     return (unsigned short)get2();",
          "232:   case 4:",
          "233:     return (unsigned int)get4();",
          "234:   case 5:",
          "235:     u.d = (unsigned int)get4();",
          "236:     v.d = (unsigned int)get4();",
          "237:     return u.d / (v.d ? v.d : 1);",
          "238:   case 8:",
          "239:     return (signed short)get2();",
          "240:   case 9:",
          "241:     return (signed int)get4();",
          "242:   case 10:",
          "243:     u.d = (signed int)get4();",
          "244:     v.d = (signed int)get4();",
          "245:     return u.d / (v.d ? v.d : 1);",
          "246:   case 11:",
          "247:     return int_to_float(get4());",
          "248:   case 12:",
          "249:     rev = 7 * ((order == 0x4949) == (ntohs(0x1234) == 0x1234));",
          "250:     for (i = 0; i < 8; i++)",
          "251:       u.c[i ^ rev] = fgetc(ifp);",
          "252:     return u.d;",
          "253:   default:",
          "254:     return fgetc(ifp);",
          "258: void CLASS read_shorts(ushort *pixel, int count)",
          "260:   if (fread(pixel, 2, count, ifp) < count)",
          "261:     derror();",
          "263:     swab((char *)pixel, (char *)pixel, count * 2);",
          "266: void CLASS cubic_spline(const int *x_, const int *y_, const int len)",
          "271:   A = (float **)calloc(((2 * len + 4) * sizeof **A + sizeof *A), 2 * len);",
          "272:   if (!A)",
          "273:     return;",
          "274:   A[0] = (float *)(A + 2 * len);",
          "275:   for (i = 1; i < 2 * len; i++)",
          "276:     A[i] = A[0] + 2 * len * i;",
          "277:   y = len + (x = i + (d = i + (c = i + (b = A[0] + i * i))));",
          "278:   for (i = 0; i < len; i++)",
          "279:   {",
          "283:   for (i = len - 1; i > 0; i--)",
          "284:   {",
          "285:     b[i] = (y[i] - y[i - 1]) / (x[i] - x[i - 1]);",
          "286:     d[i - 1] = x[i] - x[i - 1];",
          "288:   for (i = 1; i < len - 1; i++)",
          "289:   {",
          "290:     A[i][i] = 2 * (d[i - 1] + d[i]);",
          "291:     if (i > 1)",
          "292:     {",
          "293:       A[i][i - 1] = d[i - 1];",
          "294:       A[i - 1][i] = d[i - 1];",
          "296:     A[i][len - 1] = 6 * (b[i + 1] - b[i]);",
          "298:   for (i = 1; i < len - 2; i++)",
          "299:   {",
          "300:     float v = A[i + 1][i] / A[i][i];",
          "301:     for (j = 1; j <= len - 1; j++)",
          "302:       A[i + 1][j] -= v * A[i][j];",
          "304:   for (i = len - 2; i > 0; i--)",
          "305:   {",
          "307:     for (j = i; j <= len - 2; j++)",
          "308:       acc += A[i][j] * c[j];",
          "309:     c[i] = (A[i][len - 1] - acc) / A[i][i];",
          "311:   for (i = 0; i < 0x10000; i++)",
          "312:   {",
          "315:     for (j = 0; j < len - 1; j++)",
          "316:     {",
          "317:       if (x[j] <= x_out && x_out <= x[j + 1])",
          "318:       {",
          "319:         float v = x_out - x[j];",
          "320:         y_out = y[j] + ((y[j + 1] - y[j]) / d[j] - (2 * d[j] * c[j] + c[j + 1] * d[j]) / 6) * v + (c[j] * 0.5) * v * v +",
          "321:                 ((c[j + 1] - c[j]) / (6 * d[j])) * v * v * v;",
          "324:     curve[i] = y_out < 0.0 ? 0 : (y_out >= 1.0 ? 65535 : (ushort)(y_out * 65535.0 + 0.5));",
          "326:   free(A);",
          "329: void CLASS canon_600_fixed_wb(int temp)",
          "332:       {667, 358, 397, 565, 452}, {731, 390, 367, 499, 517}, {1119, 396, 348, 448, 537}, {1399, 485, 431, 508, 688}};",
          "334:   float frac = 0;",
          "336:   for (lo = 4; --lo;)",
          "337:     if (*mul[lo] <= temp)",
          "338:       break;",
          "339:   for (hi = 0; hi < 3; hi++)",
          "340:     if (*mul[hi] >= temp)",
          "341:       break;",
          "343:     frac = (float)(temp - *mul[lo]) / (*mul[hi] - *mul[lo]);",
          "344:   for (i = 1; i < 5; i++)",
          "345:     pre_mul[i - 1] = 1 / (frac * mul[hi][i] + (1 - frac) * mul[lo][i]);",
          "349: int CLASS canon_600_color(int ratio[2], int mar)",
          "351:   int clipped = 0, target, miss;",
          "353:   if (flash_used)",
          "354:   {",
          "356:     {",
          "357:       ratio[1] = -104;",
          "358:       clipped = 1;",
          "359:     }",
          "360:     if (ratio[1] > 12)",
          "361:     {",
          "362:       ratio[1] = 12;",
          "363:       clipped = 1;",
          "364:     }",
          "365:   }",
          "366:   else",
          "367:   {",
          "368:     if (ratio[1] < -264 || ratio[1] > 461)",
          "369:       return 2;",
          "371:     {",
          "372:       ratio[1] = -50;",
          "373:       clipped = 1;",
          "374:     }",
          "376:     {",
          "377:       ratio[1] = 307;",
          "378:       clipped = 1;",
          "379:     }",
          "381:   target = flash_used || ratio[1] < 197 ? -38 - (398 * ratio[1] >> 10) : -123 + (48 * ratio[1] >> 10);",
          "382:   if (target - mar <= ratio[0] && target + 20 >= ratio[0] && !clipped)",
          "383:     return 0;",
          "385:   if (abs(miss) >= mar * 4)",
          "386:     return 2;",
          "387:   if (miss < -20)",
          "388:     miss = -20;",
          "389:   if (miss > mar)",
          "390:     miss = mar;",
          "397:   int mar, row, col, i, j, st, count[] = {0, 0};",
          "400:   memset(&total, 0, sizeof total);",
          "402:   if (i < 10)",
          "403:     mar = 150;",
          "404:   else if (i > 12)",
          "405:     mar = 20;",
          "406:   else",
          "407:     mar = 280 - 20 * i;",
          "408:   if (flash_used)",
          "409:     mar = 80;",
          "410:   for (row = 14; row < height - 14; row += 4)",
          "411:     for (col = 10; col < width; col += 2)",
          "412:     {",
          "413:       for (i = 0; i < 8; i++)",
          "414:         test[(i & 4) + FC(row + (i >> 1), col + (i & 1))] = BAYER(row + (i >> 1), col + (i & 1));",
          "415:       for (i = 0; i < 8; i++)",
          "416:         if (test[i] < 150 || test[i] > 1500)",
          "417:           goto next;",
          "418:       for (i = 0; i < 4; i++)",
          "419:         if (abs(test[i] - test[i + 4]) > 50)",
          "420:           goto next;",
          "421:       for (i = 0; i < 2; i++)",
          "422:       {",
          "423:         for (j = 0; j < 4; j += 2)",
          "424:           ratio[i][j >> 1] = ((test[i * 4 + j + 1] - test[i * 4 + j]) << 10) / test[i * 4 + j];",
          "425:         stat[i] = canon_600_color(ratio[i], mar);",
          "426:       }",
          "427:       if ((st = stat[0] | stat[1]) > 1)",
          "428:         goto next;",
          "429:       for (i = 0; i < 2; i++)",
          "430:         if (stat[i])",
          "431:           for (j = 0; j < 2; j++)",
          "432:             test[i * 4 + j * 2 + 1] = test[i * 4 + j * 2] * (0x400 + ratio[i][j]) >> 10;",
          "433:       for (i = 0; i < 8; i++)",
          "434:         total[st][i] += test[i];",
          "436:     next:;",
          "438:   if (count[0] | count[1])",
          "439:   {",
          "440:     st = count[0] * 200 < count[1];",
          "441:     for (i = 0; i < 4; i++)",
          "442:       pre_mul[i] = 1.0 / (total[st][i] + total[st][i + 4]);",
          "448:   static const short table[6][12] = {{-190, 702, -1878, 2390, 1861, -1349, 905, -393, -432, 944, 2617, -2105},",
          "449:                                      {-1203, 1715, -1136, 1648, 1388, -876, 267, 245, -1641, 2153, 3921, -3409},",
          "450:                                      {-615, 1127, -1563, 2075, 1437, -925, 509, 3, -756, 1268, 2519, -2007},",
          "451:                                      {-190, 702, -1886, 2398, 2153, -1641, 763, -251, -452, 964, 3040, -2528},",
          "452:                                      {-190, 702, -1878, 2390, 1861, -1349, 905, -393, -432, 944, 2617, -2105},",
          "453:                                      {-807, 1319, -1785, 2297, 1388, -876, 769, -257, -230, 742, 2067, -1555}};",
          "454:   int t = 0, i, c;",
          "459:   if (mc > 1 && mc <= 1.28 && yc < 0.8789)",
          "460:     t = 1;",
          "461:   if (mc > 1.28 && mc <= 2)",
          "462:   {",
          "463:     if (yc < 0.8789)",
          "464:       t = 3;",
          "465:     else if (yc <= 2)",
          "466:       t = 4;",
          "468:   if (flash_used)",
          "469:     t = 5;",
          "470:   for (raw_color = i = 0; i < 3; i++)",
          "471:     FORCC rgb_cam[i][c] = table[t][i * 4 + c] / 1024.0;",
          "476:   uchar data[1120], *dp;",
          "480:   for (irow = row = 0; irow < height; irow++)",
          "481:   {",
          "485:     if (fread(data, 1, 1120, ifp) < 1120)",
          "486:       derror();",
          "487:     pix = raw_image + row * raw_width;",
          "488:     for (dp = data; dp < data + 1120; dp += 10, pix += 8)",
          "489:     {",
          "490:       pix[0] = (dp[0] << 2) + (dp[1] >> 6);",
          "493:       pix[3] = (dp[4] << 2) + (dp[1] & 3);",
          "494:       pix[4] = (dp[5] << 2) + (dp[9] & 3);",
          "497:       pix[7] = (dp[8] << 2) + (dp[9] >> 6);",
          "499:     if ((row += 2) > height)",
          "500:       row = 1;",
          "507:   static const short mul[4][2] = {{1141, 1145}, {1128, 1109}, {1178, 1149}, {1128, 1109}};",
          "509:   for (row = 0; row < height; row++)",
          "510:   {",
          "514:     for (col = 0; col < width; col++)",
          "515:     {",
          "516:       if ((val = BAYER(row, col) - black) < 0)",
          "517:         val = 0;",
          "519:       BAYER(row, col) = val;",
          "521:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "452: {",
          "453:   unsigned row;",
          "458:   }",
          "459:   return 0;",
          "460: }",
          "463: {",
          "464: #ifdef LIBRAW_NOTHREADS",
          "467: #else",
          "468: #define bitbuf tls->getbits.bitbuf",
          "471: #endif",
          "472:   unsigned c;",
          "475:   if (nbits < 0)",
          "476:     return bitbuf = vbits = reset = 0;",
          "481:     vbits += 8;",
          "482:   }",
          "485:     vbits -= huff[c] >> 8;",
          "488:     vbits -= nbits;",
          "490:   return c;",
          "491: #ifndef LIBRAW_NOTHREADS",
          "492: #undef bitbuf",
          "",
          "[Removed Lines]",
          "455:   for (row=0; row < 100; row++) {",
          "456:     fseek (ifp, row*3340 + 3284, SEEK_SET);",
          "457:     if (getc(ifp) > 15) return 1;",
          "462: unsigned CLASS getbithuff (int nbits, ushort *huff)",
          "465:   static unsigned bitbuf=0;",
          "466:   static int vbits=0, reset=0;",
          "469: #define vbits  tls->getbits.vbits",
          "470: #define reset  tls->getbits.reset",
          "474:   if (nbits > 25) return 0;",
          "477:   if (nbits == 0 || vbits < 0) return 0;",
          "478:   while (!reset && vbits < nbits && (c = fgetc(ifp)) != EOF &&",
          "479:     !(reset = zero_after_ff && c == 0xff && fgetc(ifp))) {",
          "480:     bitbuf = (bitbuf << 8) + (uchar) c;",
          "483:   c = bitbuf << (32-vbits) >> (32-nbits);",
          "484:   if (huff) {",
          "486:     c = (uchar) huff[c];",
          "487:   } else",
          "489:   if (vbits < 0) derror();",
          "",
          "[Added Lines]",
          "533:   for (row = 0; row < 100; row++)",
          "534:   {",
          "535:     fseek(ifp, row * 3340 + 3284, SEEK_SET);",
          "536:     if (getc(ifp) > 15)",
          "537:       return 1;",
          "542: unsigned CLASS getbithuff(int nbits, ushort *huff)",
          "545:   static unsigned bitbuf = 0;",
          "546:   static int vbits = 0, reset = 0;",
          "549: #define vbits tls->getbits.vbits",
          "550: #define reset tls->getbits.reset",
          "554:   if (nbits > 25)",
          "555:     return 0;",
          "558:   if (nbits == 0 || vbits < 0)",
          "559:     return 0;",
          "560:   while (!reset && vbits < nbits && (c = fgetc(ifp)) != EOF && !(reset = zero_after_ff && c == 0xff && fgetc(ifp)))",
          "561:   {",
          "562:     bitbuf = (bitbuf << 8) + (uchar)c;",
          "565:   c = bitbuf << (32 - vbits) >> (32 - nbits);",
          "566:   if (huff)",
          "567:   {",
          "569:     c = (uchar)huff[c];",
          "570:   }",
          "571:   else",
          "573:   if (vbits < 0)",
          "574:     derror();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "495: #endif",
          "496: }",
          "502:    Construct a decode tree according the specification in *source.",
          "",
          "[Removed Lines]",
          "498: #define getbits(n) getbithuff(n,0)",
          "499: #define gethuff(h) getbithuff(*h,h+1)",
          "",
          "[Added Lines]",
          "583: #define getbits(n) getbithuff(n, 0)",
          "584: #define gethuff(h) getbithuff(*h, h + 1)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "511:    then the code is",
          "528: {",
          "529:   int max, len, h, i, j;",
          "530:   const uchar *count;",
          "531:   ushort *huff;",
          "533:   count = (*source += 16) - 17;",
          "537:   huff[0] = max;",
          "543:   return huff;",
          "544: }",
          "552: {",
          "553:   static const uchar first_tree[3][29] = {",
          "560:   };",
          "561:   static const uchar second_tree[3][180] = {",
          "611: }",
          "",
          "[Removed Lines]",
          "513:  00  0x04",
          "514:  010  0x03",
          "515:  011  0x05",
          "516:  100  0x06",
          "517:  101  0x02",
          "518:  1100  0x07",
          "519:  1101  0x01",
          "520:  11100  0x08",
          "521:  11101  0x09",
          "522:  11110  0x00",
          "523:  111110  0x0a",
          "524:  1111110  0x0b",
          "525:  1111111  0xff",
          "527: ushort * CLASS make_decoder_ref (const uchar **source)",
          "534:   for (max=16; max && !count[max]; max--);",
          "535:   huff = (ushort *) calloc (1 + (1 << max), sizeof *huff);",
          "536:   merror (huff, \"make_decoder()\");",
          "538:   for (h=len=1; len <= max; len++)",
          "539:     for (i=0; i < count[len]; i++, ++*source)",
          "540:       for (j=0; j < 1 << (max-len); j++)",
          "541:  if (h <= 1 << max)",
          "542:    huff[h++] = len << 8 | **source;",
          "546: ushort * CLASS make_decoder (const uchar *source)",
          "547: {",
          "548:   return make_decoder_ref (&source);",
          "549: }",
          "551: void CLASS crw_init_tables (unsigned table, ushort *huff[2])",
          "554:     { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,",
          "555:       0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },",
          "556:     { 0,2,2,3,1,1,1,1,2,0,0,0,0,0,0,0,",
          "557:       0x03,0x02,0x04,0x01,0x05,0x00,0x06,0x07,0x09,0x08,0x0a,0x0b,0xff  },",
          "558:     { 0,0,6,3,1,1,2,0,0,0,0,0,0,0,0,0,",
          "559:       0x06,0x05,0x07,0x04,0x08,0x03,0x09,0x02,0x00,0x0a,0x01,0x0b,0xff  },",
          "562:     { 0,2,2,2,1,4,2,1,2,5,1,1,0,0,0,139,",
          "563:       0x03,0x04,0x02,0x05,0x01,0x06,0x07,0x08,",
          "564:       0x12,0x13,0x11,0x14,0x09,0x15,0x22,0x00,0x21,0x16,0x0a,0xf0,",
          "565:       0x23,0x17,0x24,0x31,0x32,0x18,0x19,0x33,0x25,0x41,0x34,0x42,",
          "566:       0x35,0x51,0x36,0x37,0x38,0x29,0x79,0x26,0x1a,0x39,0x56,0x57,",
          "567:       0x28,0x27,0x52,0x55,0x58,0x43,0x76,0x59,0x77,0x54,0x61,0xf9,",
          "568:       0x71,0x78,0x75,0x96,0x97,0x49,0xb7,0x53,0xd7,0x74,0xb6,0x98,",
          "569:       0x47,0x48,0x95,0x69,0x99,0x91,0xfa,0xb8,0x68,0xb5,0xb9,0xd6,",
          "570:       0xf7,0xd8,0x67,0x46,0x45,0x94,0x89,0xf8,0x81,0xd5,0xf6,0xb4,",
          "571:       0x88,0xb1,0x2a,0x44,0x72,0xd9,0x87,0x66,0xd4,0xf5,0x3a,0xa7,",
          "572:       0x73,0xa9,0xa8,0x86,0x62,0xc7,0x65,0xc8,0xc9,0xa1,0xf4,0xd1,",
          "573:       0xe9,0x5a,0x92,0x85,0xa6,0xe7,0x93,0xe8,0xc1,0xc6,0x7a,0x64,",
          "574:       0xe1,0x4a,0x6a,0xe6,0xb3,0xf1,0xd3,0xa5,0x8a,0xb2,0x9a,0xba,",
          "575:       0x84,0xa4,0x63,0xe5,0xc5,0xf3,0xd2,0xc4,0x82,0xaa,0xda,0xe4,",
          "576:       0xf2,0xca,0x83,0xa3,0xa2,0xc3,0xea,0xc2,0xe2,0xe3,0xff,0xff  },",
          "577:     { 0,2,2,1,4,1,4,1,3,3,1,0,0,0,0,140,",
          "578:       0x02,0x03,0x01,0x04,0x05,0x12,0x11,0x06,",
          "579:       0x13,0x07,0x08,0x14,0x22,0x09,0x21,0x00,0x23,0x15,0x31,0x32,",
          "580:       0x0a,0x16,0xf0,0x24,0x33,0x41,0x42,0x19,0x17,0x25,0x18,0x51,",
          "581:       0x34,0x43,0x52,0x29,0x35,0x61,0x39,0x71,0x62,0x36,0x53,0x26,",
          "582:       0x38,0x1a,0x37,0x81,0x27,0x91,0x79,0x55,0x45,0x28,0x72,0x59,",
          "583:       0xa1,0xb1,0x44,0x69,0x54,0x58,0xd1,0xfa,0x57,0xe1,0xf1,0xb9,",
          "584:       0x49,0x47,0x63,0x6a,0xf9,0x56,0x46,0xa8,0x2a,0x4a,0x78,0x99,",
          "585:       0x3a,0x75,0x74,0x86,0x65,0xc1,0x76,0xb6,0x96,0xd6,0x89,0x85,",
          "586:       0xc9,0xf5,0x95,0xb4,0xc7,0xf7,0x8a,0x97,0xb8,0x73,0xb7,0xd8,",
          "587:       0xd9,0x87,0xa7,0x7a,0x48,0x82,0x84,0xea,0xf4,0xa6,0xc5,0x5a,",
          "588:       0x94,0xa4,0xc6,0x92,0xc3,0x68,0xb5,0xc8,0xe4,0xe5,0xe6,0xe9,",
          "589:       0xa2,0xa3,0xe3,0xc2,0x66,0x67,0x93,0xaa,0xd4,0xd5,0xe7,0xf8,",
          "590:       0x88,0x9a,0xd7,0x77,0xc4,0x64,0xe2,0x98,0xa5,0xca,0xda,0xe8,",
          "591:       0xf3,0xf6,0xa9,0xb2,0xb3,0xf2,0xd2,0x83,0xba,0xd3,0xff,0xff  },",
          "592:     { 0,0,6,2,1,3,3,2,5,1,2,2,8,10,0,117,",
          "593:       0x04,0x05,0x03,0x06,0x02,0x07,0x01,0x08,",
          "594:       0x09,0x12,0x13,0x14,0x11,0x15,0x0a,0x16,0x17,0xf0,0x00,0x22,",
          "595:       0x21,0x18,0x23,0x19,0x24,0x32,0x31,0x25,0x33,0x38,0x37,0x34,",
          "596:       0x35,0x36,0x39,0x79,0x57,0x58,0x59,0x28,0x56,0x78,0x27,0x41,",
          "597:       0x29,0x77,0x26,0x42,0x76,0x99,0x1a,0x55,0x98,0x97,0xf9,0x48,",
          "598:       0x54,0x96,0x89,0x47,0xb7,0x49,0xfa,0x75,0x68,0xb6,0x67,0x69,",
          "599:       0xb9,0xb8,0xd8,0x52,0xd7,0x88,0xb5,0x74,0x51,0x46,0xd9,0xf8,",
          "600:       0x3a,0xd6,0x87,0x45,0x7a,0x95,0xd5,0xf6,0x86,0xb4,0xa9,0x94,",
          "601:       0x53,0x2a,0xa8,0x43,0xf5,0xf7,0xd4,0x66,0xa7,0x5a,0x44,0x8a,",
          "602:       0xc9,0xe8,0xc8,0xe7,0x9a,0x6a,0x73,0x4a,0x61,0xc7,0xf4,0xc6,",
          "603:       0x65,0xe9,0x72,0xe6,0x71,0x91,0x93,0xa6,0xda,0x92,0x85,0x62,",
          "604:       0xf3,0xc5,0xb2,0xa4,0x84,0xba,0x64,0xa5,0xb3,0xd2,0x81,0xe5,",
          "605:       0xd3,0xaa,0xc4,0xca,0xf2,0xb1,0xe4,0xd1,0x83,0x63,0xea,0xc3,",
          "606:       0xe2,0x82,0xf1,0xa3,0xc2,0xa1,0xc1,0xe3,0xa2,0xe1,0xff,0xff  }",
          "607:   };",
          "608:   if (table > 2) table = 2;",
          "609:   huff[0] = make_decoder ( first_tree[table]);",
          "610:   huff[1] = make_decoder (second_tree[table]);",
          "",
          "[Added Lines]",
          "598:         00  0x04",
          "599:         010  0x03",
          "600:         011  0x05",
          "601:         100  0x06",
          "602:         101  0x02",
          "603:         1100  0x07",
          "604:         1101  0x01",
          "605:         11100  0x08",
          "606:         11101  0x09",
          "607:         11110  0x00",
          "608:         111110  0x0a",
          "609:         1111110  0x0b",
          "610:         1111111  0xff",
          "612: ushort *CLASS make_decoder_ref(const uchar **source)",
          "619:   for (max = 16; max && !count[max]; max--)",
          "620:     ;",
          "621:   huff = (ushort *)calloc(1 + (1 << max), sizeof *huff);",
          "622:   merror(huff, \"make_decoder()\");",
          "624:   for (h = len = 1; len <= max; len++)",
          "625:     for (i = 0; i < count[len]; i++, ++*source)",
          "626:       for (j = 0; j < 1 << (max - len); j++)",
          "627:         if (h <= 1 << max)",
          "628:           huff[h++] = len << 8 | **source;",
          "632: ushort *CLASS make_decoder(const uchar *source) { return make_decoder_ref(&source); }",
          "634: void CLASS crw_init_tables(unsigned table, ushort *huff[2])",
          "637:       {0, 1,    4,    2,    3,    1,    2,    0,    0,    0,    0,    0,    0,    0,   0,",
          "638:        0, 0x04, 0x03, 0x05, 0x06, 0x02, 0x07, 0x01, 0x08, 0x09, 0x00, 0x0a, 0x0b, 0xff},",
          "639:       {0, 2,    2,    3,    1,    1,    1,    1,    2,    0,    0,    0,    0,    0,   0,",
          "640:        0, 0x03, 0x02, 0x04, 0x01, 0x05, 0x00, 0x06, 0x07, 0x09, 0x08, 0x0a, 0x0b, 0xff},",
          "641:       {0, 0,    6,    3,    1,    1,    2,    0,    0,    0,    0,    0,    0,    0,   0,",
          "642:        0, 0x06, 0x05, 0x07, 0x04, 0x08, 0x03, 0x09, 0x02, 0x00, 0x0a, 0x01, 0x0b, 0xff},",
          "645:       {0,    2,    2,    2,    1,    4,    2,    1,    2,    5,    1,    1,    0,    0,    0,    139,  0x03, 0x04,",
          "646:        0x02, 0x05, 0x01, 0x06, 0x07, 0x08, 0x12, 0x13, 0x11, 0x14, 0x09, 0x15, 0x22, 0x00, 0x21, 0x16, 0x0a, 0xf0,",
          "647:        0x23, 0x17, 0x24, 0x31, 0x32, 0x18, 0x19, 0x33, 0x25, 0x41, 0x34, 0x42, 0x35, 0x51, 0x36, 0x37, 0x38, 0x29,",
          "648:        0x79, 0x26, 0x1a, 0x39, 0x56, 0x57, 0x28, 0x27, 0x52, 0x55, 0x58, 0x43, 0x76, 0x59, 0x77, 0x54, 0x61, 0xf9,",
          "649:        0x71, 0x78, 0x75, 0x96, 0x97, 0x49, 0xb7, 0x53, 0xd7, 0x74, 0xb6, 0x98, 0x47, 0x48, 0x95, 0x69, 0x99, 0x91,",
          "650:        0xfa, 0xb8, 0x68, 0xb5, 0xb9, 0xd6, 0xf7, 0xd8, 0x67, 0x46, 0x45, 0x94, 0x89, 0xf8, 0x81, 0xd5, 0xf6, 0xb4,",
          "651:        0x88, 0xb1, 0x2a, 0x44, 0x72, 0xd9, 0x87, 0x66, 0xd4, 0xf5, 0x3a, 0xa7, 0x73, 0xa9, 0xa8, 0x86, 0x62, 0xc7,",
          "652:        0x65, 0xc8, 0xc9, 0xa1, 0xf4, 0xd1, 0xe9, 0x5a, 0x92, 0x85, 0xa6, 0xe7, 0x93, 0xe8, 0xc1, 0xc6, 0x7a, 0x64,",
          "653:        0xe1, 0x4a, 0x6a, 0xe6, 0xb3, 0xf1, 0xd3, 0xa5, 0x8a, 0xb2, 0x9a, 0xba, 0x84, 0xa4, 0x63, 0xe5, 0xc5, 0xf3,",
          "654:        0xd2, 0xc4, 0x82, 0xaa, 0xda, 0xe4, 0xf2, 0xca, 0x83, 0xa3, 0xa2, 0xc3, 0xea, 0xc2, 0xe2, 0xe3, 0xff, 0xff},",
          "655:       {0,    2,    2,    1,    4,    1,    4,    1,    3,    3,    1,    0,    0,    0,    0,    140,  0x02, 0x03,",
          "656:        0x01, 0x04, 0x05, 0x12, 0x11, 0x06, 0x13, 0x07, 0x08, 0x14, 0x22, 0x09, 0x21, 0x00, 0x23, 0x15, 0x31, 0x32,",
          "657:        0x0a, 0x16, 0xf0, 0x24, 0x33, 0x41, 0x42, 0x19, 0x17, 0x25, 0x18, 0x51, 0x34, 0x43, 0x52, 0x29, 0x35, 0x61,",
          "658:        0x39, 0x71, 0x62, 0x36, 0x53, 0x26, 0x38, 0x1a, 0x37, 0x81, 0x27, 0x91, 0x79, 0x55, 0x45, 0x28, 0x72, 0x59,",
          "659:        0xa1, 0xb1, 0x44, 0x69, 0x54, 0x58, 0xd1, 0xfa, 0x57, 0xe1, 0xf1, 0xb9, 0x49, 0x47, 0x63, 0x6a, 0xf9, 0x56,",
          "660:        0x46, 0xa8, 0x2a, 0x4a, 0x78, 0x99, 0x3a, 0x75, 0x74, 0x86, 0x65, 0xc1, 0x76, 0xb6, 0x96, 0xd6, 0x89, 0x85,",
          "661:        0xc9, 0xf5, 0x95, 0xb4, 0xc7, 0xf7, 0x8a, 0x97, 0xb8, 0x73, 0xb7, 0xd8, 0xd9, 0x87, 0xa7, 0x7a, 0x48, 0x82,",
          "662:        0x84, 0xea, 0xf4, 0xa6, 0xc5, 0x5a, 0x94, 0xa4, 0xc6, 0x92, 0xc3, 0x68, 0xb5, 0xc8, 0xe4, 0xe5, 0xe6, 0xe9,",
          "663:        0xa2, 0xa3, 0xe3, 0xc2, 0x66, 0x67, 0x93, 0xaa, 0xd4, 0xd5, 0xe7, 0xf8, 0x88, 0x9a, 0xd7, 0x77, 0xc4, 0x64,",
          "664:        0xe2, 0x98, 0xa5, 0xca, 0xda, 0xe8, 0xf3, 0xf6, 0xa9, 0xb2, 0xb3, 0xf2, 0xd2, 0x83, 0xba, 0xd3, 0xff, 0xff},",
          "665:       {0,    0,    6,    2,    1,    3,    3,    2,    5,    1,    2,    2,    8,    10,   0,    117,  0x04, 0x05,",
          "666:        0x03, 0x06, 0x02, 0x07, 0x01, 0x08, 0x09, 0x12, 0x13, 0x14, 0x11, 0x15, 0x0a, 0x16, 0x17, 0xf0, 0x00, 0x22,",
          "667:        0x21, 0x18, 0x23, 0x19, 0x24, 0x32, 0x31, 0x25, 0x33, 0x38, 0x37, 0x34, 0x35, 0x36, 0x39, 0x79, 0x57, 0x58,",
          "668:        0x59, 0x28, 0x56, 0x78, 0x27, 0x41, 0x29, 0x77, 0x26, 0x42, 0x76, 0x99, 0x1a, 0x55, 0x98, 0x97, 0xf9, 0x48,",
          "669:        0x54, 0x96, 0x89, 0x47, 0xb7, 0x49, 0xfa, 0x75, 0x68, 0xb6, 0x67, 0x69, 0xb9, 0xb8, 0xd8, 0x52, 0xd7, 0x88,",
          "670:        0xb5, 0x74, 0x51, 0x46, 0xd9, 0xf8, 0x3a, 0xd6, 0x87, 0x45, 0x7a, 0x95, 0xd5, 0xf6, 0x86, 0xb4, 0xa9, 0x94,",
          "671:        0x53, 0x2a, 0xa8, 0x43, 0xf5, 0xf7, 0xd4, 0x66, 0xa7, 0x5a, 0x44, 0x8a, 0xc9, 0xe8, 0xc8, 0xe7, 0x9a, 0x6a,",
          "672:        0x73, 0x4a, 0x61, 0xc7, 0xf4, 0xc6, 0x65, 0xe9, 0x72, 0xe6, 0x71, 0x91, 0x93, 0xa6, 0xda, 0x92, 0x85, 0x62,",
          "673:        0xf3, 0xc5, 0xb2, 0xa4, 0x84, 0xba, 0x64, 0xa5, 0xb3, 0xd2, 0x81, 0xe5, 0xd3, 0xaa, 0xc4, 0xca, 0xf2, 0xb1,",
          "674:        0xe4, 0xd1, 0x83, 0x63, 0xea, 0xc3, 0xe2, 0x82, 0xf1, 0xa3, 0xc2, 0xa1, 0xc1, 0xe3, 0xa2, 0xe1, 0xff, 0xff}};",
          "675:   if (table > 2)",
          "676:     table = 2;",
          "677:   huff[0] = make_decoder(first_tree[table]);",
          "678:   huff[1] = make_decoder(second_tree[table]);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "619: int CLASS canon_has_lowbits()",
          "620: {",
          "621:   uchar test[0x4000];",
          "630:     }",
          "631:   return ret;",
          "632: }",
          "",
          "[Removed Lines]",
          "622:   int ret=1, i;",
          "624:   fseek (ifp, 0, SEEK_SET);",
          "625:   fread (test, 1, sizeof test, ifp);",
          "626:   for (i=540; i < sizeof test - 1; i++)",
          "627:     if (test[i] == 0xff) {",
          "628:       if (test[i+1]) return 1;",
          "629:       ret=0;",
          "",
          "[Added Lines]",
          "690:   int ret = 1, i;",
          "692:   fseek(ifp, 0, SEEK_SET);",
          "693:   fread(test, 1, sizeof test, ifp);",
          "694:   for (i = 540; i < sizeof test - 1; i++)",
          "695:     if (test[i] == 0xff)",
          "696:     {",
          "697:       if (test[i + 1])",
          "698:         return 1;",
          "699:       ret = 0;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "635: {",
          "636:   ushort *pixel, *prow, *huff[2];",
          "637:   int nblocks, lowbits, i, c, row, r, save, val;",
          "641:   lowbits = canon_has_lowbits();",
          "644:   zero_after_ff = 1;",
          "645:   getbits(-1);",
          "646: #ifdef LIBRAW_LIBRARY_BUILD",
          "648: #endif",
          "650: #ifdef LIBRAW_LIBRARY_BUILD",
          "652: #endif",
          "688:       }",
          "690:     }",
          "692: #ifdef LIBRAW_LIBRARY_BUILD",
          "695:     throw;",
          "696:   }",
          "697: #endif",
          "699: }",
          "702: {",
          "703:   ushort c, tag, len;",
          "704:   int cnt = 0;",
          "705:   uchar data[0x10000];",
          "706:   const uchar *dp;",
          "709:   jh->restart = INT_MAX;",
          "716:     len = (data[2] << 8 | data[3]) - 2;",
          "745:     }",
          "746:   } while (tag != 0xffda);",
          "758:   return zero_after_ff = 1;",
          "759: }",
          "762: {",
          "763:   int c;",
          "766: }",
          "769: {",
          "770:   int len, diff;",
          "772: #ifdef LIBRAW_LIBRARY_BUILD",
          "773:     throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "774: #else",
          "776: #endif",
          "779:   len = gethuff(huff);",
          "780:   if (len == 16 && (!dng_version || dng_version >= 0x1010000))",
          "781:     return -32768;",
          "782:   diff = getbits(len);",
          "784:     diff -= (1 << len) - 1;",
          "785:   return diff;",
          "786: }",
          "789: {",
          "798:       while (c != EOF && mark >> 4 != 0xffd);",
          "799:     }",
          "800:     getbits(-1);",
          "801:   }",
          "806:       if (jh->sraw && c <= jh->sraw && (col | c))",
          "823:     }",
          "824:   return row[2];",
          "825: }",
          "827: void CLASS lossless_jpeg_load_raw()",
          "828: {",
          "830:   struct jhead jh;",
          "831:   ushort *rp;",
          "836: #ifdef LIBRAW_LIBRARY_BUILD",
          "837:     throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "838: #else",
          "840: #endif",
          "841:   jwide = jh.wide * jh.clrs;",
          "842:   jhigh = jh.high;",
          "845: #ifdef LIBRAW_LIBRARY_BUILD",
          "847: #endif",
          "849: #ifdef LIBRAW_LIBRARY_BUILD",
          "851: #endif",
          "871: #else",
          "873: #endif",
          "877:     }",
          "879: #ifdef LIBRAW_LIBRARY_BUILD",
          "882:     throw;",
          "883:   }",
          "884: #endif",
          "886: }",
          "888: void CLASS canon_sraw_load_raw()",
          "889: {",
          "890:   struct jhead jh;",
          "894: #ifdef LIBRAW_LIBRARY_BUILD",
          "895:   int saved_w = width, saved_h = height;",
          "896: #endif",
          "897:   char *cp;",
          "900:   jwide = (jh.wide >>= 1) * jh.clrs;",
          "903: #ifdef LIBRAW_LIBRARY_BUILD",
          "905:   {",
          "908:   }",
          "911: #endif",
          "917: #ifdef LIBRAW_LIBRARY_BUILD",
          "919: #endif",
          "925: #ifdef LIBRAW_LIBRARY_BUILD",
          "927:           {",
          "935:           }",
          "937:           {",
          "942:           }",
          "944: #endif",
          "945:           {",
          "950:           }",
          "951:       }",
          "952:     }",
          "954: #ifdef LIBRAW_LIBRARY_BUILD",
          "958:   }",
          "959: #endif",
          "961: #ifdef LIBRAW_LIBRARY_BUILD",
          "970: #endif",
          "972: #ifdef LIBRAW_LIBRARY_BUILD",
          "974: #endif",
          "984: #ifdef LIBRAW_LIBRARY_BUILD",
          "986: #endif",
          "995:           else",
          "999:     }",
          "1006: #ifdef LIBRAW_LIBRARY_BUILD",
          "1008: #endif",
          "1010: #ifdef LIBRAW_LIBRARY_BUILD",
          "1012: #endif",
          "1035:   }",
          "1036:   height = saved_h;",
          "1037:   width = saved_w;",
          "1038: #endif",
          "1040:   maximum = 0x3fff;",
          "1041: }",
          "1044: {",
          "1045:   int c;",
          "1049:     if (row < raw_height && col < raw_width)",
          "1053:     if (row < height && col < width)",
          "1054:       FORC(tiff_samples)",
          "1057:   }",
          "1059: }",
          "1062: {",
          "1063:   int c, i, j, len, skip, coef;",
          "1064:   float work[3][8][8];",
          "1072:   if (!cs[0])",
          "1078:     i += skip = len >> 4;",
          "1080:     coef = getbits(len);",
          "1082:       coef -= (1 << len) - 1;",
          "1083:     ((float *)work)[zigzag[i]] = coef * jh->quant[i];",
          "1084:   }",
          "1085:   FORC(8) work[0][0][c] *= M_SQRT1_2;",
          "1086:   FORC(8) work[0][c][0] *= M_SQRT1_2;",
          "1095: }",
          "1097: void CLASS lossless_dng_load_raw()",
          "1098: {",
          "1100:   struct jhead jh;",
          "1101:   ushort *rp;",
          "1104: #ifdef LIBRAW_LIBRARY_BUILD",
          "1105:     checkCancel();",
          "1106: #endif",
          "1107:     save = ftell(ifp);",
          "1108:     if (tile_length < INT_MAX)",
          "1111:     jwide = jh.wide;",
          "1114: #ifdef LIBRAW_LIBRARY_BUILD",
          "1116: #endif",
          "1118:       case 0xc1:",
          "1136:       case 0xc3:",
          "1138: #ifdef LIBRAW_LIBRARY_BUILD",
          "1140: #endif",
          "1148:       }",
          "1149: #ifdef LIBRAW_LIBRARY_BUILD",
          "1153:     }",
          "1154: #endif",
          "1156:     if ((tcol += tile_width) >= raw_width)",
          "1157:       trow += tile_length + (tcol = 0);",
          "1159:   }",
          "1160: }",
          "",
          "[Removed Lines]",
          "638:   int block, diffbuf[64], leaf, len, diff, carry=0, pnum=0, base[2];",
          "640:   crw_init_tables (tiff_compress, huff);",
          "642:   if (!lowbits) maximum = 0x3ff;",
          "643:   fseek (ifp, 540 + lowbits*raw_height*raw_width/4, SEEK_SET);",
          "647:   try {",
          "649:   for (row=0; row < raw_height; row+=8) {",
          "651:     checkCancel();",
          "653:     pixel = raw_image + row*raw_width;",
          "654:     nblocks = MIN (8, raw_height-row) * raw_width >> 6;",
          "655:     for (block=0; block < nblocks; block++) {",
          "656:       memset (diffbuf, 0, sizeof diffbuf);",
          "657:       for (i=0; i < 64; i++ ) {",
          "658:  leaf = gethuff(huff[i > 0]);",
          "659:  if (leaf == 0 && i) break;",
          "660:  if (leaf == 0xff) continue;",
          "661:  i  += leaf >> 4;",
          "662:  len = leaf & 15;",
          "663:  if (len == 0) continue;",
          "664:  diff = getbits(len);",
          "665:  if ((diff & (1 << (len-1))) == 0)",
          "666:    diff -= (1 << len) - 1;",
          "667:  if (i < 64) diffbuf[i] = diff;",
          "668:       }",
          "669:       diffbuf[0] += carry;",
          "670:       carry = diffbuf[0];",
          "671:       for (i=0; i < 64; i++ ) {",
          "672:  if (pnum++ % raw_width == 0)",
          "673:    base[0] = base[1] = 512;",
          "674:  if ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)",
          "675:    derror();",
          "676:       }",
          "677:     }",
          "678:     if (lowbits) {",
          "679:       save = ftell(ifp);",
          "680:       fseek (ifp, 26 + row*raw_width/4, SEEK_SET);",
          "681:       for (prow=pixel, i=0; i < raw_width*2; i++) {",
          "682:  c = fgetc(ifp);",
          "683:  for (r=0; r < 8; r+=2, prow++) {",
          "684:    val = (*prow << 2) + ((c >> r) & 3);",
          "685:    if (raw_width == 2672 && val < 512) val += 2;",
          "687:  }",
          "689:       fseek (ifp, save, SEEK_SET);",
          "691:   }",
          "693:   } catch (...) {",
          "694:     FORC(2) free (huff[c]);",
          "698:   FORC(2) free (huff[c]);",
          "701: int CLASS ljpeg_start (struct jhead *jh, int info_only)",
          "708:   memset (jh, 0, sizeof *jh);",
          "710:   if ((fgetc(ifp),fgetc(ifp)) != 0xd8) return 0;",
          "711:   do {",
          "712:     if(feof(ifp)) return 0;",
          "713:     if(cnt++ > 1024) return 0; // 1024 tags limit",
          "714:     if (!fread (data, 2, 2, ifp)) return 0;",
          "715:     tag =  data[0] << 8 | data[1];",
          "717:     if (tag <= 0xff00) return 0;",
          "718:     fread (data, 1, len, ifp);",
          "719:     switch (tag) {",
          "720:       case 0xffc3:        // start of frame; lossless, Huffman",
          "721:  jh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;",
          "722:       case 0xffc1:",
          "723:       case 0xffc0:",
          "724:  jh->algo = tag & 0xff;",
          "725:  jh->bits = data[0];",
          "726:  jh->high = data[1] << 8 | data[2];",
          "727:  jh->wide = data[3] << 8 | data[4];",
          "728:  jh->clrs = data[5] + jh->sraw;",
          "729:  if (len == 9 && !dng_version) getc(ifp);",
          "730:  break;",
          "731:       case 0xffc4:          // define Huffman tables",
          "732:  if (info_only) break;",
          "733:  for (dp = data; dp < data+len && !((c = *dp++) & -20); )",
          "734:    jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);",
          "735:  break;",
          "736:       case 0xffda:          // start of scan",
          "737:  jh->psv = data[1+data[0]*2];",
          "738:  jh->bits -= data[3+data[0]*2] & 15;",
          "739:  break;",
          "740:       case 0xffdb:",
          "741:  FORC(64) jh->quant[c] = data[c*2+1] << 8 | data[c*2+2];",
          "742:  break;",
          "743:       case 0xffdd:",
          "744:  jh->restart = data[0] << 8 | data[1];",
          "747:   if (jh->bits > 16 || jh->clrs > 6 ||",
          "748:      !jh->bits || !jh->high || !jh->wide || !jh->clrs) return 0;",
          "749:   if (info_only) return 1;",
          "750:   if (!jh->huff[0]) return 0;",
          "751:   FORC(19) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];",
          "752:   if (jh->sraw) {",
          "753:     FORC(4)        jh->huff[2+c] = jh->huff[1];",
          "754:     FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];",
          "755:   }",
          "756:   jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);",
          "757:   merror (jh->row, \"ljpeg_start()\");",
          "761: void CLASS ljpeg_end (struct jhead *jh)",
          "764:   FORC4 if (jh->free[c]) free (jh->free[c]);",
          "765:   free (jh->row);",
          "768: int CLASS ljpeg_diff (ushort *huff)",
          "771:   if(!huff)",
          "775:     longjmp (failure, 2);",
          "783:   if ((diff & (1 << (len-1))) == 0)",
          "788: ushort * CLASS ljpeg_row (int jrow, struct jhead *jh)",
          "790:   int col, c, diff, pred, spred=0;",
          "791:   ushort mark=0, *row[3];",
          "793:   if (jrow * jh->wide % jh->restart == 0) {",
          "794:     FORC(6) jh->vpred[c] = 1 << (jh->bits-1);",
          "795:     if (jrow) {",
          "796:       fseek (ifp, -2, SEEK_CUR);",
          "797:       do mark = (mark << 8) + (c = fgetc(ifp));",
          "802:   FORC3 row[c] = jh->row + jh->wide*jh->clrs*((jrow+c) & 1);",
          "803:   for (col=0; col < jh->wide; col++)",
          "804:     FORC(jh->clrs) {",
          "805:       diff = ljpeg_diff (jh->huff[c]);",
          "807:       pred = spred;",
          "808:       else if (col) pred = row[0][-jh->clrs];",
          "809:       else     pred = (jh->vpred[c] += diff) - diff;",
          "810:       if (jrow && col) switch (jh->psv) {",
          "811:  case 1: break;",
          "812:  case 2: pred = row[1][0];     break;",
          "813:  case 3: pred = row[1][-jh->clrs];    break;",
          "814:  case 4: pred = pred +   row[1][0] - row[1][-jh->clrs];  break;",
          "815:  case 5: pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1); break;",
          "816:  case 6: pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1); break;",
          "817:  case 7: pred = (pred + row[1][0]) >> 1;    break;",
          "818:  default: pred = 0;",
          "819:       }",
          "820:       if ((**row = pred + diff) >> jh->bits) derror();",
          "821:       if (c <= jh->sraw) spred = **row;",
          "822:       row[0]++; row[1]++;",
          "829:   int jwide, jhigh, jrow, jcol, val, jidx, i, j, row=0, col=0;",
          "833:   if (!ljpeg_start (&jh, 0)) return;",
          "835:   if(jh.wide<1 || jh.high<1 || jh.clrs<1 || jh.bits <1)",
          "839:     longjmp (failure, 2);",
          "843:   if(jh.clrs == 4 && jwide >= raw_width*2) jhigh *= 2;",
          "846:   try {",
          "848:   for (jrow=0; jrow < jh.high; jrow++) {",
          "850:     checkCancel();",
          "852:     rp = ljpeg_row (jrow, &jh);",
          "853:     if (load_flags & 1)",
          "854:       row = jrow & 1 ? height-1-jrow/2 : jrow/2;",
          "855:     for (jcol=0; jcol < jwide; jcol++) {",
          "856:       val = curve[*rp++];",
          "857:       if (cr2_slice[0]) {",
          "858:  jidx = jrow*jwide + jcol;",
          "859:  i = jidx / (cr2_slice[1]*raw_height);",
          "860:  if ((j = i >= cr2_slice[0]))",
          "861:    i  = cr2_slice[0];",
          "862:  jidx -= i * (cr2_slice[1]*raw_height);",
          "863:  row = jidx / cr2_slice[1+j];",
          "864:  col = jidx % cr2_slice[1+j] + i*cr2_slice[1];",
          "865:       }",
          "866:       if (raw_width == 3984 && (col -= 2) < 0)",
          "867:  col += (row--,raw_width);",
          "868:       if(row>raw_height)",
          "869: #ifdef LIBRAW_LIBRARY_BUILD",
          "870:         throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "872:         longjmp (failure, 3);",
          "874:       if ((unsigned) row < raw_height) RAW(row,col) = val;",
          "875:       if (++col >= raw_width)",
          "876:  col = (row++,0);",
          "878:   }",
          "880:   } catch (...) {",
          "881:     ljpeg_end (&jh);",
          "885:   ljpeg_end (&jh);",
          "891:   short *rp=0, (*ip)[4];",
          "892:   int jwide, slice, scol, ecol, row, col, jrow=0, jcol=0, pix[3], c;",
          "893:   int v[3]={0,0,0}, ver, hue;",
          "899:   if (!ljpeg_start (&jh, 0) || jh.clrs < 4) return;",
          "904:   if(load_flags & 256)",
          "906:  width = raw_width;",
          "907:  height = raw_height;",
          "910:   try {",
          "912:   for (ecol=slice=0; slice <= cr2_slice[0]; slice++) {",
          "913:     scol = ecol;",
          "914:     ecol += cr2_slice[1] * 2 / jh.clrs;",
          "915:     if (!cr2_slice[0] || ecol > raw_width-1) ecol = raw_width & -2;",
          "916:     for (row=0; row < height; row += (jh.clrs >> 1) - 1) {",
          "918:     checkCancel();",
          "920:       ip = (short (*)[4]) image + row*width;",
          "921:       for (col=scol; col < ecol; col+=2, jcol+=jh.clrs) {",
          "922:  if ((jcol %= jwide) == 0)",
          "923:    rp = (short *) ljpeg_row (jrow++, &jh);",
          "924:  if (col >= width) continue;",
          "926:         if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)",
          "928:             FORC (jh.clrs-2)",
          "929:               {",
          "930:                 ip[col + (c >> 1)*width + (c & 1)][0] = rp[jcol+c];",
          "931:                 ip[col + (c >> 1)*width + (c & 1)][1] = ip[col + (c >> 1)*width + (c & 1)][2] = 8192;",
          "932:               }",
          "933:             ip[col][1] = rp[jcol+jh.clrs-2] - 8192;",
          "934:             ip[col][2] = rp[jcol+jh.clrs-1] - 8192;",
          "936:         else if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB)",
          "938:             FORC (jh.clrs-2)",
          "939:                 ip[col + (c >> 1)*width + (c & 1)][0] = rp[jcol+c];",
          "940:             ip[col][1] = rp[jcol+jh.clrs-2] - 8192;",
          "941:             ip[col][2] = rp[jcol+jh.clrs-1] - 8192;",
          "943:         else",
          "946:             FORC (jh.clrs-2)",
          "947:               ip[col + (c >> 1)*width + (c & 1)][0] = rp[jcol+c];",
          "948:             ip[col][1] = rp[jcol+jh.clrs-2] - 16384;",
          "949:             ip[col][2] = rp[jcol+jh.clrs-1] - 16384;",
          "953:   }",
          "955:   } catch (...) {",
          "956:       ljpeg_end (&jh);",
          "957:       throw ;",
          "962:   if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)",
          "963:     {",
          "964:       ljpeg_end (&jh);",
          "965:       maximum = 0x3fff;",
          "966:       height = saved_h;",
          "967:       width = saved_w;",
          "968:       return;",
          "969:     }",
          "973:   try {",
          "975:   for (cp=model2; *cp && !isdigit(*cp); cp++);",
          "976:   sscanf (cp, \"%d.%d.%d\", v, v+1, v+2);",
          "977:   ver = (v[0]*1000 + v[1])*1000 + v[2];",
          "978:   hue = (jh.sraw+1) << 2;",
          "979:   if (unique_id >= 0x80000281 || (unique_id == 0x80000218 && ver > 1000006))",
          "980:     hue = jh.sraw << 1;",
          "981:   ip = (short (*)[4]) image;",
          "982:   rp = ip[0];",
          "983:   for (row=0; row < height; row++, ip+=width) {",
          "985:     checkCancel();",
          "987:     if (row & (jh.sraw >> 1))",
          "988:     {",
          "989:       for (col=0; col < width; col+=2)",
          "990:  for (c=1; c < 3; c++)",
          "991:    if (row == height-1)",
          "992:           {",
          "993:         ip[col][c] =  ip[col-width][c];",
          "994:           }",
          "996:           {",
          "997:               ip[col][c] = (ip[col-width][c] + ip[col+width][c] + 1) >> 1;",
          "998:           }",
          "1000:     for (col=1; col < width; col+=2)",
          "1001:       for (c=1; c < 3; c++)",
          "1002:  if (col == width-1)",
          "1003:       ip[col][c] =  ip[col-1][c];",
          "1004:  else ip[col][c] = (ip[col-1][c] + ip[col+1][c] + 1) >> 1;",
          "1005:   }",
          "1007:   if(!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB) )",
          "1009:     for ( ; rp < ip[0]; rp+=4) {",
          "1011:     checkCancel();",
          "1013:       if (unique_id == 0x80000218 ||",
          "1014:           unique_id == 0x80000250 ||",
          "1015:           unique_id == 0x80000261 ||",
          "1016:           unique_id == 0x80000281 ||",
          "1017:           unique_id == 0x80000287) {",
          "1018:         rp[1] = (rp[1] << 2) + hue;",
          "1019:         rp[2] = (rp[2] << 2) + hue;",
          "1020:         pix[0] = rp[0] + ((   50*rp[1] + 22929*rp[2]) >> 14);",
          "1021:         pix[1] = rp[0] + ((-5640*rp[1] - 11751*rp[2]) >> 14);",
          "1022:         pix[2] = rp[0] + ((29040*rp[1] -   101*rp[2]) >> 14);",
          "1023:       } else {",
          "1024:         if (unique_id < 0x80000218) rp[0] -= 512;",
          "1025:         pix[0] = rp[0] + rp[2];",
          "1026:         pix[2] = rp[0] + rp[1];",
          "1027:         pix[1] = rp[0] + ((-778*rp[1] - (rp[2] << 11)) >> 12);",
          "1028:       }",
          "1029:       FORC3 rp[c] = CLIP(pix[c] * sraw_mul[c] >> 10);",
          "1030:     }",
          "1031: #ifdef LIBRAW_LIBRARY_BUILD",
          "1032:   } catch (...) {",
          "1033:       ljpeg_end (&jh);",
          "1034:       throw ;",
          "1039:   ljpeg_end (&jh);",
          "1043: void CLASS adobe_copy_pixel (unsigned row, unsigned col, ushort **rp)",
          "1047:   if (tiff_samples == 2 && shot_select) (*rp)++;",
          "1048:   if (raw_image) {",
          "1050:       RAW(row,col) = curve[**rp];",
          "1052:   } else {",
          "1055:  image[row*width+col][c] = curve[(*rp)[c]];",
          "1058:   if (tiff_samples == 2 && shot_select) (*rp)--;",
          "1061: void CLASS ljpeg_idct (struct jhead *jh)",
          "1065:   static float cs[106] = { 0 };",
          "1066:   static const uchar zigzag[80] =",
          "1067:   {  0, 1, 8,16, 9, 2, 3,10,17,24,32,25,18,11, 4, 5,12,19,26,33,",
          "1068:     40,48,41,34,27,20,13, 6, 7,14,21,28,35,42,49,56,57,50,43,36,",
          "1069:     29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,",
          "1070:     47,55,62,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63 };",
          "1073:     FORC(106) cs[c] = cos((c & 31)*M_PI/16)/2;",
          "1074:   memset (work, 0, sizeof work);",
          "1075:   work[0][0][0] = jh->vpred[0] += ljpeg_diff (jh->huff[0]) * jh->quant[0];",
          "1076:   for (i=1; i < 64; i++ ) {",
          "1077:     len = gethuff (jh->huff[16]);",
          "1079:     if (!(len &= 15) && skip < 15) break;",
          "1081:     if ((coef & (1 << (len-1))) == 0)",
          "1087:   for (i=0; i < 8; i++)",
          "1088:     for (j=0; j < 8; j++)",
          "1089:       FORC(8) work[1][i][j] += work[0][i][c] * cs[(j*2+1)*c];",
          "1090:   for (i=0; i < 8; i++)",
          "1091:     for (j=0; j < 8; j++)",
          "1092:       FORC(8) work[2][i][j] += work[1][c][j] * cs[(i*2+1)*c];",
          "1094:   FORC(64) jh->idct[c] = CLIP(((float *)work[2])[c]+0.5);",
          "1099:   unsigned save, trow=0, tcol=0, jwide, jrow, jcol, row, col, i, j;",
          "1103:   while (trow < raw_height) {",
          "1109:       fseek (ifp, get4(), SEEK_SET);",
          "1110:     if (!ljpeg_start (&jh, 0)) break;",
          "1112:     if (filters) jwide *= jh.clrs;",
          "1113:     jwide /= MIN (is_raw, tiff_samples);",
          "1115:     try {",
          "1117:       switch (jh.algo) {",
          "1119:  jh.vpred[0] = 16384;",
          "1120:  getbits(-1);",
          "1121:  for (jrow=0; jrow+7 < jh.high; jrow += 8) {",
          "1122: #ifdef LIBRAW_LIBRARY_BUILD",
          "1123:    checkCancel();",
          "1124: #endif",
          "1125:    for (jcol=0; jcol+7 < jh.wide; jcol += 8) {",
          "1126:      ljpeg_idct (&jh);",
          "1127:      rp = jh.idct;",
          "1128:      row = trow + jcol/tile_width + jrow*2;",
          "1129:      col = tcol + jcol%tile_width;",
          "1130:      for (i=0; i < 16; i+=2)",
          "1131:        for (j=0; j < 8; j++)",
          "1132:   adobe_copy_pixel (row+i, col+j, &rp);",
          "1133:    }",
          "1134:  }",
          "1135:  break;",
          "1137:  for (row=col=jrow=0; jrow < jh.high; jrow++) {",
          "1139:    checkCancel();",
          "1141:    rp = ljpeg_row (jrow, &jh);",
          "1142:    for (jcol=0; jcol < jwide; jcol++) {",
          "1143:      adobe_copy_pixel (trow+row, tcol+col, &rp);",
          "1144:      if (++col >= tile_width || col >= raw_width)",
          "1145:        row += 1 + (col = 0);",
          "1146:    }",
          "1147:  }",
          "1150:     } catch (...) {",
          "1151:       ljpeg_end (&jh);",
          "1152:       throw ;",
          "1155:     fseek (ifp, save+4, SEEK_SET);",
          "1158:     ljpeg_end (&jh);",
          "",
          "[Added Lines]",
          "708:   int block, diffbuf[64], leaf, len, diff, carry = 0, pnum = 0, base[2];",
          "710:   crw_init_tables(tiff_compress, huff);",
          "712:   if (!lowbits)",
          "713:     maximum = 0x3ff;",
          "714:   fseek(ifp, 540 + lowbits * raw_height * raw_width / 4, SEEK_SET);",
          "718:   try",
          "719:   {",
          "721:     for (row = 0; row < raw_height; row += 8)",
          "722:     {",
          "724:       checkCancel();",
          "726:       pixel = raw_image + row * raw_width;",
          "727:       nblocks = MIN(8, raw_height - row) * raw_width >> 6;",
          "728:       for (block = 0; block < nblocks; block++)",
          "729:       {",
          "730:         memset(diffbuf, 0, sizeof diffbuf);",
          "731:         for (i = 0; i < 64; i++)",
          "732:         {",
          "733:           leaf = gethuff(huff[i > 0]);",
          "734:           if (leaf == 0 && i)",
          "735:             break;",
          "736:           if (leaf == 0xff)",
          "737:             continue;",
          "738:           i += leaf >> 4;",
          "739:           len = leaf & 15;",
          "740:           if (len == 0)",
          "741:             continue;",
          "742:           diff = getbits(len);",
          "743:           if ((diff & (1 << (len - 1))) == 0)",
          "744:             diff -= (1 << len) - 1;",
          "745:           if (i < 64)",
          "746:             diffbuf[i] = diff;",
          "747:         }",
          "748:         diffbuf[0] += carry;",
          "749:         carry = diffbuf[0];",
          "750:         for (i = 0; i < 64; i++)",
          "751:         {",
          "752:           if (pnum++ % raw_width == 0)",
          "753:             base[0] = base[1] = 512;",
          "754:           if ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)",
          "755:             derror();",
          "756:         }",
          "757:       }",
          "758:       if (lowbits)",
          "759:       {",
          "760:         save = ftell(ifp);",
          "761:         fseek(ifp, 26 + row * raw_width / 4, SEEK_SET);",
          "762:         for (prow = pixel, i = 0; i < raw_width * 2; i++)",
          "763:         {",
          "764:           c = fgetc(ifp);",
          "765:           for (r = 0; r < 8; r += 2, prow++)",
          "766:           {",
          "767:             val = (*prow << 2) + ((c >> r) & 3);",
          "768:             if (raw_width == 2672 && val < 512)",
          "769:               val += 2;",
          "771:           }",
          "772:         }",
          "773:         fseek(ifp, save, SEEK_SET);",
          "777:   }",
          "778:   catch (...)",
          "779:   {",
          "780:     FORC(2) free(huff[c]);",
          "784:   FORC(2) free(huff[c]);",
          "787: int CLASS ljpeg_start(struct jhead *jh, int info_only)",
          "794:   memset(jh, 0, sizeof *jh);",
          "796:   if ((fgetc(ifp), fgetc(ifp)) != 0xd8)",
          "797:     return 0;",
          "798:   do",
          "799:   {",
          "800:     if (feof(ifp))",
          "801:       return 0;",
          "802:     if (cnt++ > 1024)",
          "803:       return 0; // 1024 tags limit",
          "804:     if (!fread(data, 2, 2, ifp))",
          "805:       return 0;",
          "806:     tag = data[0] << 8 | data[1];",
          "808:     if (tag <= 0xff00)",
          "809:       return 0;",
          "810:     fread(data, 1, len, ifp);",
          "811:     switch (tag)",
          "812:     {",
          "813:     case 0xffc3: // start of frame; lossless, Huffman",
          "814:       jh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;",
          "815:     case 0xffc1:",
          "816:     case 0xffc0:",
          "817:       jh->algo = tag & 0xff;",
          "818:       jh->bits = data[0];",
          "819:       jh->high = data[1] << 8 | data[2];",
          "820:       jh->wide = data[3] << 8 | data[4];",
          "821:       jh->clrs = data[5] + jh->sraw;",
          "822:       if (len == 9 && !dng_version)",
          "823:         getc(ifp);",
          "824:       break;",
          "825:     case 0xffc4: // define Huffman tables",
          "826:       if (info_only)",
          "827:         break;",
          "828:       for (dp = data; dp < data + len && !((c = *dp++) & -20);)",
          "829:         jh->free[c] = jh->huff[c] = make_decoder_ref(&dp);",
          "830:       break;",
          "831:     case 0xffda: // start of scan",
          "832:       jh->psv = data[1 + data[0] * 2];",
          "833:       jh->bits -= data[3 + data[0] * 2] & 15;",
          "834:       break;",
          "835:     case 0xffdb:",
          "836:       FORC(64) jh->quant[c] = data[c * 2 + 1] << 8 | data[c * 2 + 2];",
          "837:       break;",
          "838:     case 0xffdd:",
          "839:       jh->restart = data[0] << 8 | data[1];",
          "842:   if (jh->bits > 16 || jh->clrs > 6 || !jh->bits || !jh->high || !jh->wide || !jh->clrs)",
          "843:     return 0;",
          "844:   if (info_only)",
          "845:     return 1;",
          "846:   if (!jh->huff[0])",
          "847:     return 0;",
          "848:   FORC(19) if (!jh->huff[c + 1]) jh->huff[c + 1] = jh->huff[c];",
          "849:   if (jh->sraw)",
          "850:   {",
          "851:     FORC(4) jh->huff[2 + c] = jh->huff[1];",
          "852:     FORC(jh->sraw) jh->huff[1 + c] = jh->huff[0];",
          "853:   }",
          "854:   jh->row = (ushort *)calloc(jh->wide * jh->clrs, 4);",
          "855:   merror(jh->row, \"ljpeg_start()\");",
          "859: void CLASS ljpeg_end(struct jhead *jh)",
          "862:   FORC4 if (jh->free[c]) free(jh->free[c]);",
          "863:   free(jh->row);",
          "866: int CLASS ljpeg_diff(ushort *huff)",
          "869:   if (!huff)",
          "873:     longjmp(failure, 2);",
          "880:   if ((diff & (1 << (len - 1))) == 0)",
          "885: ushort *CLASS ljpeg_row(int jrow, struct jhead *jh)",
          "887:   int col, c, diff, pred, spred = 0;",
          "888:   ushort mark = 0, *row[3];",
          "890:   if (jrow * jh->wide % jh->restart == 0)",
          "891:   {",
          "892:     FORC(6) jh->vpred[c] = 1 << (jh->bits - 1);",
          "893:     if (jrow)",
          "894:     {",
          "895:       fseek(ifp, -2, SEEK_CUR);",
          "896:       do",
          "897:         mark = (mark << 8) + (c = fgetc(ifp));",
          "902:   FORC3 row[c] = jh->row + jh->wide * jh->clrs * ((jrow + c) & 1);",
          "903:   for (col = 0; col < jh->wide; col++)",
          "904:     FORC(jh->clrs)",
          "905:     {",
          "906:       diff = ljpeg_diff(jh->huff[c]);",
          "908:         pred = spred;",
          "909:       else if (col)",
          "910:         pred = row[0][-jh->clrs];",
          "911:       else",
          "912:         pred = (jh->vpred[c] += diff) - diff;",
          "913:       if (jrow && col)",
          "914:         switch (jh->psv)",
          "915:         {",
          "916:         case 1:",
          "917:           break;",
          "918:         case 2:",
          "919:           pred = row[1][0];",
          "920:           break;",
          "921:         case 3:",
          "922:           pred = row[1][-jh->clrs];",
          "923:           break;",
          "924:         case 4:",
          "925:           pred = pred + row[1][0] - row[1][-jh->clrs];",
          "926:           break;",
          "927:         case 5:",
          "928:           pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);",
          "929:           break;",
          "930:         case 6:",
          "931:           pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);",
          "932:           break;",
          "933:         case 7:",
          "934:           pred = (pred + row[1][0]) >> 1;",
          "935:           break;",
          "936:         default:",
          "937:           pred = 0;",
          "938:         }",
          "939:       if ((**row = pred + diff) >> jh->bits)",
          "940:         derror();",
          "941:       if (c <= jh->sraw)",
          "942:         spred = **row;",
          "943:       row[0]++;",
          "944:       row[1]++;",
          "951:   int jwide, jhigh, jrow, jcol, val, jidx, i, j, row = 0, col = 0;",
          "955:   if (!ljpeg_start(&jh, 0))",
          "956:     return;",
          "958:   if (jh.wide < 1 || jh.high < 1 || jh.clrs < 1 || jh.bits < 1)",
          "962:     longjmp(failure, 2);",
          "966:   if (jh.clrs == 4 && jwide >= raw_width * 2)",
          "967:     jhigh *= 2;",
          "970:   try",
          "971:   {",
          "973:     for (jrow = 0; jrow < jh.high; jrow++)",
          "974:     {",
          "976:       checkCancel();",
          "978:       rp = ljpeg_row(jrow, &jh);",
          "979:       if (load_flags & 1)",
          "980:         row = jrow & 1 ? height - 1 - jrow / 2 : jrow / 2;",
          "981:       for (jcol = 0; jcol < jwide; jcol++)",
          "982:       {",
          "983:         val = curve[*rp++];",
          "984:         if (cr2_slice[0])",
          "985:         {",
          "986:           jidx = jrow * jwide + jcol;",
          "987:           i = jidx / (cr2_slice[1] * raw_height);",
          "988:           if ((j = i >= cr2_slice[0]))",
          "989:             i = cr2_slice[0];",
          "990:           jidx -= i * (cr2_slice[1] * raw_height);",
          "991:           row = jidx / cr2_slice[1 + j];",
          "992:           col = jidx % cr2_slice[1 + j] + i * cr2_slice[1];",
          "993:         }",
          "994:         if (raw_width == 3984 && (col -= 2) < 0)",
          "995:           col += (row--, raw_width);",
          "996:         if (row > raw_height)",
          "997: #ifdef LIBRAW_LIBRARY_BUILD",
          "998:           throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "1000:         longjmp(failure, 3);",
          "1002:         if ((unsigned)row < raw_height)",
          "1003:           RAW(row, col) = val;",
          "1004:         if (++col >= raw_width)",
          "1005:           col = (row++, 0);",
          "1006:       }",
          "1009:   }",
          "1010:   catch (...)",
          "1011:   {",
          "1012:     ljpeg_end(&jh);",
          "1016:   ljpeg_end(&jh);",
          "1022:   short *rp = 0, (*ip)[4];",
          "1023:   int jwide, slice, scol, ecol, row, col, jrow = 0, jcol = 0, pix[3], c;",
          "1024:   int v[3] = {0, 0, 0}, ver, hue;",
          "1030:   if (!ljpeg_start(&jh, 0) || jh.clrs < 4)",
          "1031:     return;",
          "1035:   if (load_flags & 256)",
          "1037:     width = raw_width;",
          "1038:     height = raw_height;",
          "1041:   try",
          "1042:   {",
          "1044:     for (ecol = slice = 0; slice <= cr2_slice[0]; slice++)",
          "1045:     {",
          "1046:       scol = ecol;",
          "1047:       ecol += cr2_slice[1] * 2 / jh.clrs;",
          "1048:       if (!cr2_slice[0] || ecol > raw_width - 1)",
          "1049:         ecol = raw_width & -2;",
          "1050:       for (row = 0; row < height; row += (jh.clrs >> 1) - 1)",
          "1051:       {",
          "1053:         checkCancel();",
          "1055:         ip = (short(*)[4])image + row * width;",
          "1056:         for (col = scol; col < ecol; col += 2, jcol += jh.clrs)",
          "1057:         {",
          "1058:           if ((jcol %= jwide) == 0)",
          "1059:             rp = (short *)ljpeg_row(jrow++, &jh);",
          "1060:           if (col >= width)",
          "1061:             continue;",
          "1063:           if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)",
          "1065:             FORC(jh.clrs - 2)",
          "1066:             {",
          "1067:               ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];",
          "1068:               ip[col + (c >> 1) * width + (c & 1)][1] = ip[col + (c >> 1) * width + (c & 1)][2] = 8192;",
          "1069:             }",
          "1070:             ip[col][1] = rp[jcol + jh.clrs - 2] - 8192;",
          "1071:             ip[col][2] = rp[jcol + jh.clrs - 1] - 8192;",
          "1073:           else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB)",
          "1075:             FORC(jh.clrs - 2)",
          "1076:             ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];",
          "1077:             ip[col][1] = rp[jcol + jh.clrs - 2] - 8192;",
          "1078:             ip[col][2] = rp[jcol + jh.clrs - 1] - 8192;",
          "1080:           else",
          "1083:             FORC(jh.clrs - 2)",
          "1084:             ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];",
          "1085:             ip[col][1] = rp[jcol + jh.clrs - 2] - 16384;",
          "1086:             ip[col][2] = rp[jcol + jh.clrs - 1] - 16384;",
          "1088:         }",
          "1092:   }",
          "1093:   catch (...)",
          "1094:   {",
          "1095:     ljpeg_end(&jh);",
          "1096:     throw;",
          "1101:   if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)",
          "1102:   {",
          "1103:     ljpeg_end(&jh);",
          "1104:     maximum = 0x3fff;",
          "1105:     height = saved_h;",
          "1106:     width = saved_w;",
          "1107:     return;",
          "1108:   }",
          "1112:   try",
          "1113:   {",
          "1115:     for (cp = model2; *cp && !isdigit(*cp); cp++)",
          "1116:       ;",
          "1117:     sscanf(cp, \"%d.%d.%d\", v, v + 1, v + 2);",
          "1118:     ver = (v[0] * 1000 + v[1]) * 1000 + v[2];",
          "1119:     hue = (jh.sraw + 1) << 2;",
          "1120:     if (unique_id >= 0x80000281 || (unique_id == 0x80000218 && ver > 1000006))",
          "1121:       hue = jh.sraw << 1;",
          "1122:     ip = (short(*)[4])image;",
          "1123:     rp = ip[0];",
          "1124:     for (row = 0; row < height; row++, ip += width)",
          "1125:     {",
          "1127:       checkCancel();",
          "1129:       if (row & (jh.sraw >> 1))",
          "1130:       {",
          "1131:         for (col = 0; col < width; col += 2)",
          "1132:           for (c = 1; c < 3; c++)",
          "1133:             if (row == height - 1)",
          "1134:             {",
          "1135:               ip[col][c] = ip[col - width][c];",
          "1136:             }",
          "1137:             else",
          "1138:             {",
          "1139:               ip[col][c] = (ip[col - width][c] + ip[col + width][c] + 1) >> 1;",
          "1140:             }",
          "1141:       }",
          "1142:       for (col = 1; col < width; col += 2)",
          "1143:         for (c = 1; c < 3; c++)",
          "1144:           if (col == width - 1)",
          "1145:             ip[col][c] = ip[col - 1][c];",
          "1147:             ip[col][c] = (ip[col - 1][c] + ip[col + 1][c] + 1) >> 1;",
          "1150:     if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB))",
          "1152:       for (; rp < ip[0]; rp += 4)",
          "1153:       {",
          "1155:         checkCancel();",
          "1157:         if (unique_id == 0x80000218 || unique_id == 0x80000250 || unique_id == 0x80000261 || unique_id == 0x80000281 ||",
          "1158:             unique_id == 0x80000287)",
          "1159:         {",
          "1160:           rp[1] = (rp[1] << 2) + hue;",
          "1161:           rp[2] = (rp[2] << 2) + hue;",
          "1162:           pix[0] = rp[0] + ((50 * rp[1] + 22929 * rp[2]) >> 14);",
          "1163:           pix[1] = rp[0] + ((-5640 * rp[1] - 11751 * rp[2]) >> 14);",
          "1164:           pix[2] = rp[0] + ((29040 * rp[1] - 101 * rp[2]) >> 14);",
          "1165:         }",
          "1166:         else",
          "1167:         {",
          "1168:           if (unique_id < 0x80000218)",
          "1169:             rp[0] -= 512;",
          "1170:           pix[0] = rp[0] + rp[2];",
          "1171:           pix[2] = rp[0] + rp[1];",
          "1172:           pix[1] = rp[0] + ((-778 * rp[1] - (rp[2] << 11)) >> 12);",
          "1173:         }",
          "1174:         FORC3 rp[c] = CLIP(pix[c] * sraw_mul[c] >> 10);",
          "1175:       }",
          "1176: #ifdef LIBRAW_LIBRARY_BUILD",
          "1177:   }",
          "1178:   catch (...)",
          "1179:   {",
          "1180:     ljpeg_end(&jh);",
          "1181:     throw;",
          "1186:   ljpeg_end(&jh);",
          "1190: void CLASS adobe_copy_pixel(unsigned row, unsigned col, ushort **rp)",
          "1194:   if (tiff_samples == 2 && shot_select)",
          "1195:     (*rp)++;",
          "1196:   if (raw_image)",
          "1197:   {",
          "1199:       RAW(row, col) = curve[**rp];",
          "1201:   }",
          "1202:   else",
          "1203:   {",
          "1206:     image[row * width + col][c] = curve[(*rp)[c]];",
          "1209:   if (tiff_samples == 2 && shot_select)",
          "1210:     (*rp)--;",
          "1213: void CLASS ljpeg_idct(struct jhead *jh)",
          "1217:   static float cs[106] = {0};",
          "1218:   static const uchar zigzag[80] = {0,  1,  8,  16, 9,  2,  3,  10, 17, 24, 32, 25, 18, 11, 4,  5,  12, 19, 26, 33,",
          "1219:                                    40, 48, 41, 34, 27, 20, 13, 6,  7,  14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36,",
          "1220:                                    29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54,",
          "1221:                                    47, 55, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63};",
          "1224:     FORC(106) cs[c] = cos((c & 31) * M_PI / 16) / 2;",
          "1225:   memset(work, 0, sizeof work);",
          "1226:   work[0][0][0] = jh->vpred[0] += ljpeg_diff(jh->huff[0]) * jh->quant[0];",
          "1227:   for (i = 1; i < 64; i++)",
          "1228:   {",
          "1229:     len = gethuff(jh->huff[16]);",
          "1231:     if (!(len &= 15) && skip < 15)",
          "1232:       break;",
          "1234:     if ((coef & (1 << (len - 1))) == 0)",
          "1240:   for (i = 0; i < 8; i++)",
          "1241:     for (j = 0; j < 8; j++)",
          "1242:       FORC(8) work[1][i][j] += work[0][i][c] * cs[(j * 2 + 1) * c];",
          "1243:   for (i = 0; i < 8; i++)",
          "1244:     for (j = 0; j < 8; j++)",
          "1245:       FORC(8) work[2][i][j] += work[1][c][j] * cs[(i * 2 + 1) * c];",
          "1247:   FORC(64) jh->idct[c] = CLIP(((float *)work[2])[c] + 0.5);",
          "1252:   unsigned save, trow = 0, tcol = 0, jwide, jrow, jcol, row, col, i, j;",
          "1256:   while (trow < raw_height)",
          "1257:   {",
          "1263:       fseek(ifp, get4(), SEEK_SET);",
          "1264:     if (!ljpeg_start(&jh, 0))",
          "1265:       break;",
          "1267:     if (filters)",
          "1268:       jwide *= jh.clrs;",
          "1269:     jwide /= MIN(is_raw, tiff_samples);",
          "1271:     try",
          "1272:     {",
          "1274:       switch (jh.algo)",
          "1275:       {",
          "1277:         jh.vpred[0] = 16384;",
          "1278:         getbits(-1);",
          "1279:         for (jrow = 0; jrow + 7 < jh.high; jrow += 8)",
          "1280:         {",
          "1281: #ifdef LIBRAW_LIBRARY_BUILD",
          "1282:           checkCancel();",
          "1283: #endif",
          "1284:           for (jcol = 0; jcol + 7 < jh.wide; jcol += 8)",
          "1285:           {",
          "1286:             ljpeg_idct(&jh);",
          "1287:             rp = jh.idct;",
          "1288:             row = trow + jcol / tile_width + jrow * 2;",
          "1289:             col = tcol + jcol % tile_width;",
          "1290:             for (i = 0; i < 16; i += 2)",
          "1291:               for (j = 0; j < 8; j++)",
          "1292:                 adobe_copy_pixel(row + i, col + j, &rp);",
          "1293:           }",
          "1294:         }",
          "1295:         break;",
          "1297:         for (row = col = jrow = 0; jrow < jh.high; jrow++)",
          "1298:         {",
          "1300:           checkCancel();",
          "1302:           rp = ljpeg_row(jrow, &jh);",
          "1303:           for (jcol = 0; jcol < jwide; jcol++)",
          "1304:           {",
          "1305:             adobe_copy_pixel(trow + row, tcol + col, &rp);",
          "1306:             if (++col >= tile_width || col >= raw_width)",
          "1307:               row += 1 + (col = 0);",
          "1308:           }",
          "1309:         }",
          "1312:     }",
          "1313:     catch (...)",
          "1314:     {",
          "1315:       ljpeg_end(&jh);",
          "1316:       throw;",
          "1319:     fseek(ifp, save + 4, SEEK_SET);",
          "1322:     ljpeg_end(&jh);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1164:   ushort *pixel, *rp;",
          "1165:   int row, col;",
          "1169: #ifdef LIBRAW_LIBRARY_BUILD",
          "1171: #endif",
          "1173: #ifdef LIBRAW_LIBRARY_BUILD",
          "1175: #endif",
          "1182:     }",
          "1186: #ifdef LIBRAW_LIBRARY_BUILD",
          "1190:   }",
          "1191: #endif",
          "1193: }",
          "1195: void CLASS pentax_load_raw()",
          "1196: {",
          "1197:   ushort bit[2][15], huff[4097];",
          "1198:   int dep, row, col, diff, c, i;",
          "1202:   dep = (get2() + 12) & 15;",
          "1204:   FORC(dep) bit[0][c] = get2();",
          "1205:   FORC(dep) bit[1][c] = fgetc(ifp);",
          "1206:   FORC(dep)",
          "1209:   huff[0] = 12;",
          "1211:   getbits(-1);",
          "1213:   {",
          "1214: #ifdef LIBRAW_LIBRARY_BUILD",
          "1215:     checkCancel();",
          "1216: #endif",
          "1223:     }",
          "1224:   }",
          "1225: }",
          "",
          "[Removed Lines]",
          "1167:   pixel = (ushort *) calloc (raw_width, tiff_samples*sizeof *pixel);",
          "1168:   merror (pixel, \"packed_dng_load_raw()\");",
          "1170:   try {",
          "1172:   for (row=0; row < raw_height; row++) {",
          "1174:     checkCancel();",
          "1176:     if (tiff_bps == 16)",
          "1177:       read_shorts (pixel, raw_width * tiff_samples);",
          "1178:     else {",
          "1179:       getbits(-1);",
          "1180:       for (col=0; col < raw_width * tiff_samples; col++)",
          "1181:  pixel[col] = getbits(tiff_bps);",
          "1183:     for (rp=pixel, col=0; col < raw_width; col++)",
          "1184:       adobe_copy_pixel (row, col, &rp);",
          "1185:   }",
          "1187:   } catch (...) {",
          "1188:     free (pixel);",
          "1189:     throw ;",
          "1192:   free (pixel);",
          "1199:   ushort vpred[2][2] = {{0,0},{0,0}}, hpred[2];",
          "1201:   fseek (ifp, meta_offset, SEEK_SET);",
          "1203:   fseek (ifp, 12, SEEK_CUR);",
          "1207:     for (i=bit[0][c]; i <= ((bit[0][c]+(4096 >> bit[1][c])-1) & 4095); )",
          "1208:       huff[++i] = bit[1][c] << 8 | c;",
          "1210:   fseek (ifp, data_offset, SEEK_SET);",
          "1212:   for (row=0; row < raw_height; row++)",
          "1217:     for (col=0; col < raw_width; col++) {",
          "1218:       diff = ljpeg_diff (huff);",
          "1219:       if (col < 2) hpred[col] = vpred[row & 1][col] += diff;",
          "1220:       else    hpred[col & 1] += diff;",
          "1221:       RAW(row,col) = hpred[col & 1];",
          "1222:       if (hpred[col & 1] >> tiff_bps) derror();",
          "",
          "[Added Lines]",
          "1331:   pixel = (ushort *)calloc(raw_width, tiff_samples * sizeof *pixel);",
          "1332:   merror(pixel, \"packed_dng_load_raw()\");",
          "1334:   try",
          "1335:   {",
          "1337:     for (row = 0; row < raw_height; row++)",
          "1338:     {",
          "1340:       checkCancel();",
          "1342:       if (tiff_bps == 16)",
          "1343:         read_shorts(pixel, raw_width * tiff_samples);",
          "1344:       else",
          "1345:       {",
          "1346:         getbits(-1);",
          "1347:         for (col = 0; col < raw_width * tiff_samples; col++)",
          "1348:           pixel[col] = getbits(tiff_bps);",
          "1349:       }",
          "1350:       for (rp = pixel, col = 0; col < raw_width; col++)",
          "1351:         adobe_copy_pixel(row, col, &rp);",
          "1354:   }",
          "1355:   catch (...)",
          "1356:   {",
          "1357:     free(pixel);",
          "1358:     throw;",
          "1361:   free(pixel);",
          "1368:   ushort vpred[2][2] = {{0, 0}, {0, 0}}, hpred[2];",
          "1370:   fseek(ifp, meta_offset, SEEK_SET);",
          "1372:   fseek(ifp, 12, SEEK_CUR);",
          "1376:   for (i = bit[0][c]; i <= ((bit[0][c] + (4096 >> bit[1][c]) - 1) & 4095);)",
          "1377:     huff[++i] = bit[1][c] << 8 | c;",
          "1379:   fseek(ifp, data_offset, SEEK_SET);",
          "1381:   for (row = 0; row < raw_height; row++)",
          "1386:     for (col = 0; col < raw_width; col++)",
          "1387:     {",
          "1388:       diff = ljpeg_diff(huff);",
          "1389:       if (col < 2)",
          "1390:         hpred[col] = vpred[row & 1][col] += diff;",
          "1391:       else",
          "1392:         hpred[col & 1] += diff;",
          "1393:       RAW(row, col) = hpred[col & 1];",
          "1394:       if (hpred[col & 1] >> tiff_bps)",
          "1395:         derror();",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1229: void CLASS nikon_coolscan_load_raw()",
          "1230: {",
          "1234:   else",
          "1238:   unsigned short *ubuf = (unsigned short *)buf;",
          "1260:   free(buf);",
          "1261: }",
          "1262: #endif",
          "",
          "[Removed Lines]",
          "1231:   int bufsize = width*3*tiff_bps/8;",
          "1232:   if(tiff_bps <= 8)",
          "1233:     gamma_curve(1.0/imgdata.params.coolscan_nef_gamma,0.,1,255);",
          "1235:     gamma_curve(1.0/imgdata.params.coolscan_nef_gamma,0.,1,65535);",
          "1236:   fseek (ifp, data_offset, SEEK_SET);",
          "1237:   unsigned char *buf = (unsigned char*)malloc(bufsize);",
          "1239:   for(int row = 0; row < raw_height; row++)",
          "1240:     {",
          "1241:       int red = fread (buf, 1, bufsize, ifp);",
          "1242:       unsigned short (*ip)[4] = (unsigned short (*)[4]) image + row*width;",
          "1243:       if(tiff_bps <= 8)",
          "1244:         for(int col=0; col<width;col++)",
          "1245:           {",
          "1246:             ip[col][0] = curve[buf[col*3]];",
          "1247:             ip[col][1] = curve[buf[col*3+1]];",
          "1248:             ip[col][2] = curve[buf[col*3+2]];",
          "1249:             ip[col][3]=0;",
          "1250:           }",
          "1251:       else",
          "1252:         for(int col=0; col<width;col++)",
          "1253:           {",
          "1254:             ip[col][0] = curve[ubuf[col*3]];",
          "1255:             ip[col][1] = curve[ubuf[col*3+1]];",
          "1256:             ip[col][2] = curve[ubuf[col*3+2]];",
          "1257:             ip[col][3]=0;",
          "1258:           }",
          "1259:     }",
          "",
          "[Added Lines]",
          "1404:   int bufsize = width * 3 * tiff_bps / 8;",
          "1405:   if (tiff_bps <= 8)",
          "1406:     gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 255);",
          "1408:     gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 65535);",
          "1409:   fseek(ifp, data_offset, SEEK_SET);",
          "1410:   unsigned char *buf = (unsigned char *)malloc(bufsize);",
          "1412:   for (int row = 0; row < raw_height; row++)",
          "1413:   {",
          "1414:     int red = fread(buf, 1, bufsize, ifp);",
          "1415:     unsigned short(*ip)[4] = (unsigned short(*)[4])image + row * width;",
          "1416:     if (tiff_bps <= 8)",
          "1417:       for (int col = 0; col < width; col++)",
          "1418:       {",
          "1419:         ip[col][0] = curve[buf[col * 3]];",
          "1420:         ip[col][1] = curve[buf[col * 3 + 1]];",
          "1421:         ip[col][2] = curve[buf[col * 3 + 2]];",
          "1422:         ip[col][3] = 0;",
          "1423:       }",
          "1424:     else",
          "1425:       for (int col = 0; col < width; col++)",
          "1426:       {",
          "1427:         ip[col][0] = curve[ubuf[col * 3]];",
          "1428:         ip[col][1] = curve[ubuf[col * 3 + 1]];",
          "1429:         ip[col][2] = curve[ubuf[col * 3 + 2]];",
          "1430:         ip[col][3] = 0;",
          "1431:       }",
          "1432:   }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1264: void CLASS nikon_load_raw()",
          "1265: {",
          "1266:   static const uchar nikon_tree[][32] = {",
          "1279:   ushort *huff, ver0, ver1, vpred[2][2], hpred[2], csize;",
          "1283:   ver0 = fgetc(ifp);",
          "1284:   ver1 = fgetc(ifp);",
          "1285:   if (ver0 == 0x49 || ver1 == 0x58)",
          "1290:   max = 1 << tiff_bps & 0x7fff;",
          "1291:   if ((csize = get2()) > 1)",
          "1300:     split = get2();",
          "1306:   getbits(-1);",
          "1307: #ifdef LIBRAW_LIBRARY_BUILD",
          "1309: #endif",
          "1311: #ifdef LIBRAW_LIBRARY_BUILD",
          "1313: #endif",
          "1330:     }",
          "1332: #ifdef LIBRAW_LIBRARY_BUILD",
          "1335:     throw;",
          "1336:   }",
          "1337: #endif",
          "1339: }",
          "1341: void CLASS nikon_yuv_load_raw()",
          "1342: {",
          "1343:   int row, col, yuv[4], rgb[3], b, c;",
          "1345:   float cmul[4];",
          "1348:   {",
          "1349: #ifdef LIBRAW_LIBRARY_BUILD",
          "1350:     checkCancel();",
          "1351: #endif",
          "1358:       }",
          "1363:     }",
          "1364:   }",
          "1365: }",
          "",
          "[Removed Lines]",
          "1268:       5,4,3,6,2,7,1,0,8,9,11,10,12 },",
          "1270:       0x39,0x5a,0x38,0x27,0x16,5,4,3,2,1,0,11,12,12 },",
          "1272:       5,4,6,3,7,2,8,1,9,0,10,11,12 },",
          "1274:       5,6,4,7,8,3,9,2,1,0,10,11,12,13,14 },",
          "1276:       8,0x5c,0x4b,0x3a,0x29,7,6,5,4,3,2,1,0,13,14 },",
          "1278:       7,6,8,5,9,4,10,3,11,12,2,0,1,13,14 } };",
          "1280:   int i, min, max, step=0, tree=0, split=0, row, col, len, shl, diff;",
          "1282:   fseek (ifp, meta_offset, SEEK_SET);",
          "1286:     fseek (ifp, 2110, SEEK_CUR);",
          "1287:   if (ver0 == 0x46) tree = 2;",
          "1288:   if (tiff_bps == 14) tree += 3;",
          "1289:   read_shorts (vpred[0], 4);",
          "1292:     step = max / (csize-1);",
          "1293:   if (ver0 == 0x44 && ver1 == 0x20 && step > 0) {",
          "1294:     for (i=0; i < csize; i++)",
          "1295:       curve[i*step] = get2();",
          "1296:     for (i=0; i < max; i++)",
          "1297:       curve[i] = ( curve[i-i%step]*(step-i%step) +",
          "1298:      curve[i-i%step+step]*(i%step) ) / step;",
          "1299:     fseek (ifp, meta_offset+562, SEEK_SET);",
          "1301:   } else if (ver0 != 0x46 && csize <= 0x4001)",
          "1302:     read_shorts (curve, max=csize);",
          "1303:   while (curve[max-2] == curve[max-1]) max--;",
          "1304:   huff = make_decoder (nikon_tree[tree]);",
          "1305:   fseek (ifp, data_offset, SEEK_SET);",
          "1308:   try {",
          "1310:   for (min=row=0; row < height; row++) {",
          "1312:     checkCancel();",
          "1314:     if (split && row == split) {",
          "1315:       free (huff);",
          "1316:       huff = make_decoder (nikon_tree[tree+1]);",
          "1317:       max += (min = 16) << 1;",
          "1318:     }",
          "1319:     for (col=0; col < raw_width; col++) {",
          "1320:       i = gethuff(huff);",
          "1321:       len = i & 15;",
          "1322:       shl = i >> 4;",
          "1323:       diff = ((getbits(len-shl) << 1) + 1) << shl >> 1;",
          "1324:       if ((diff & (1 << (len-1))) == 0)",
          "1325:  diff -= (1 << len) - !shl;",
          "1326:       if (col < 2) hpred[col] = vpred[row & 1][col] += diff;",
          "1327:       else    hpred[col & 1] += diff;",
          "1328:       if ((ushort)(hpred[col & 1] + min) >= max) derror();",
          "1329:       RAW(row,col) = curve[LIM((short)hpred[col & 1],0,0x3fff)];",
          "1331:   }",
          "1333:   } catch (...) {",
          "1334:     free (huff);",
          "1338:   free (huff);",
          "1344:   UINT64 bitbuf=0;",
          "1346:   FORC4 { cmul[c] = cam_mul[c]>0.001f?cam_mul[c]:1.f; }",
          "1347:   for (row=0; row < raw_height; row++)",
          "1353:     for (col=0; col < raw_width; col++) {",
          "1354:       if (!(b = col & 1)) {",
          "1355:  bitbuf = 0;",
          "1356:  FORC(6) bitbuf |= (UINT64) fgetc(ifp) << c*8;",
          "1357:  FORC(4) yuv[c] = (bitbuf >> c*12 & 0xfff) - (c >> 1 << 11);",
          "1359:       rgb[0] = yuv[b] + 1.370705*yuv[3];",
          "1360:       rgb[1] = yuv[b] - 0.337633*yuv[2] - 0.698001*yuv[3];",
          "1361:       rgb[2] = yuv[b] + 1.732446*yuv[2];",
          "1362:       FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,0xfff)] / cmul[c];",
          "",
          "[Added Lines]",
          "1441:        5, 4, 3, 6, 2, 7, 1, 0, 8, 9, 11, 10, 12},",
          "1443:        0x39, 0x5a, 0x38, 0x27, 0x16, 5, 4, 3, 2, 1, 0, 11, 12, 12},",
          "1445:        5, 4, 6, 3, 7, 2, 8, 1, 9, 0, 10, 11, 12},",
          "1447:        5, 6, 4, 7, 8, 3, 9, 2, 1, 0, 10, 11, 12, 13, 14},",
          "1449:        8, 0x5c, 0x4b, 0x3a, 0x29, 7, 6, 5, 4, 3, 2, 1, 0, 13, 14},",
          "1451:        7, 6, 8, 5, 9, 4, 10, 3, 11, 12, 2, 0, 1, 13, 14}};",
          "1453:   int i, min, max, step = 0, tree = 0, split = 0, row, col, len, shl, diff;",
          "1455:   fseek(ifp, meta_offset, SEEK_SET);",
          "1459:     fseek(ifp, 2110, SEEK_CUR);",
          "1460:   if (ver0 == 0x46)",
          "1461:     tree = 2;",
          "1462:   if (tiff_bps == 14)",
          "1463:     tree += 3;",
          "1464:   read_shorts(vpred[0], 4);",
          "1467:     step = max / (csize - 1);",
          "1468:   if (ver0 == 0x44 && ver1 == 0x20 && step > 0)",
          "1469:   {",
          "1470:     for (i = 0; i < csize; i++)",
          "1471:       curve[i * step] = get2();",
          "1472:     for (i = 0; i < max; i++)",
          "1473:       curve[i] = (curve[i - i % step] * (step - i % step) + curve[i - i % step + step] * (i % step)) / step;",
          "1474:     fseek(ifp, meta_offset + 562, SEEK_SET);",
          "1476:   }",
          "1477:   else if (ver0 != 0x46 && csize <= 0x4001)",
          "1478:     read_shorts(curve, max = csize);",
          "1479:   while (curve[max - 2] == curve[max - 1])",
          "1480:     max--;",
          "1481:   huff = make_decoder(nikon_tree[tree]);",
          "1482:   fseek(ifp, data_offset, SEEK_SET);",
          "1485:   try",
          "1486:   {",
          "1488:     for (min = row = 0; row < height; row++)",
          "1489:     {",
          "1491:       checkCancel();",
          "1493:       if (split && row == split)",
          "1494:       {",
          "1495:         free(huff);",
          "1496:         huff = make_decoder(nikon_tree[tree + 1]);",
          "1497:         max += (min = 16) << 1;",
          "1498:       }",
          "1499:       for (col = 0; col < raw_width; col++)",
          "1500:       {",
          "1501:         i = gethuff(huff);",
          "1502:         len = i & 15;",
          "1503:         shl = i >> 4;",
          "1504:         diff = ((getbits(len - shl) << 1) + 1) << shl >> 1;",
          "1505:         if ((diff & (1 << (len - 1))) == 0)",
          "1506:           diff -= (1 << len) - !shl;",
          "1507:         if (col < 2)",
          "1508:           hpred[col] = vpred[row & 1][col] += diff;",
          "1509:         else",
          "1510:           hpred[col & 1] += diff;",
          "1511:         if ((ushort)(hpred[col & 1] + min) >= max)",
          "1512:           derror();",
          "1513:         RAW(row, col) = curve[LIM((short)hpred[col & 1], 0, 0x3fff)];",
          "1514:       }",
          "1517:   }",
          "1518:   catch (...)",
          "1519:   {",
          "1520:     free(huff);",
          "1524:   free(huff);",
          "1530:   UINT64 bitbuf = 0;",
          "1532:   FORC4 { cmul[c] = cam_mul[c] > 0.001f ? cam_mul[c] : 1.f; }",
          "1533:   for (row = 0; row < raw_height; row++)",
          "1539:     for (col = 0; col < raw_width; col++)",
          "1540:     {",
          "1541:       if (!(b = col & 1))",
          "1542:       {",
          "1543:         bitbuf = 0;",
          "1544:         FORC(6) bitbuf |= (UINT64)fgetc(ifp) << c * 8;",
          "1545:         FORC(4) yuv[c] = (bitbuf >> c * 12 & 0xfff) - (c >> 1 << 11);",
          "1547:       rgb[0] = yuv[b] + 1.370705 * yuv[3];",
          "1548:       rgb[1] = yuv[b] - 0.337633 * yuv[2] - 0.698001 * yuv[3];",
          "1549:       rgb[2] = yuv[b] + 1.732446 * yuv[2];",
          "1550:       FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 0xfff)] / cmul[c];",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1370: int CLASS nikon_e995()",
          "1371: {",
          "1372:   int i, histo[256];",
          "1378:     histo[fgetc(ifp)]++;",
          "1380:     if (histo[often[i]] < 200)",
          "1381:       return 0;",
          "1382:   return 1;",
          "",
          "[Removed Lines]",
          "1373:   const uchar often[] = { 0x00, 0x55, 0xaa, 0xff };",
          "1375:   memset (histo, 0, sizeof histo);",
          "1376:   fseek (ifp, -2000, SEEK_END);",
          "1377:   for (i=0; i < 2000; i++)",
          "1379:   for (i=0; i < 4; i++)",
          "",
          "[Added Lines]",
          "1561:   const uchar often[] = {0x00, 0x55, 0xaa, 0xff};",
          "1563:   memset(histo, 0, sizeof histo);",
          "1564:   fseek(ifp, -2000, SEEK_END);",
          "1565:   for (i = 0; i < 2000; i++)",
          "1567:   for (i = 0; i < 4; i++)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1390:   uchar t[12];",
          "1391:   int i;",
          "1398:       return 0;",
          "1399:   }",
          "1400:   return 1;",
          "",
          "[Removed Lines]",
          "1393:   fseek (ifp, 0, SEEK_SET);",
          "1394:   for (i=0; i < 1024; i++) {",
          "1395:     fread (t, 1, 12, ifp);",
          "1396:     if (((t[2] & t[4] & t[7] & t[9]) >> 4",
          "1397:  & t[1] & t[6] & t[8] & t[11] & 3) != 3)",
          "",
          "[Added Lines]",
          "1581:   fseek(ifp, 0, SEEK_SET);",
          "1582:   for (i = 0; i < 1024; i++)",
          "1583:   {",
          "1584:     fread(t, 1, 12, ifp);",
          "1585:     if (((t[2] & t[4] & t[7] & t[9]) >> 4 & t[1] & t[6] & t[8] & t[11] & 3) != 3)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1404: {",
          "1405:   int bits, i;",
          "1406:   uchar dp[24];",
          "1408:     int bits;",
          "1409:     char t_make[12], t_model[15];",
          "1410:   } table[] = {",
          "1418:   bits = (dp[8] & 3) << 4 | (dp[20] & 3);",
          "1423:     }",
          "1424: }",
          "",
          "[Removed Lines]",
          "1407:   static const struct {",
          "1411:     { 0x00, \"Pentax\",  \"Optio 33WR\" },",
          "1412:     { 0x03, \"Nikon\",   \"E3200\" },",
          "1413:     { 0x32, \"Nikon\",   \"E3700\" },",
          "1414:     { 0x33, \"Olympus\", \"C740UZ\" } };",
          "1416:   fseek (ifp, 3072, SEEK_SET);",
          "1417:   fread (dp, 1, 24, ifp);",
          "1419:   for (i=0; i < sizeof table / sizeof *table; i++)",
          "1420:     if (bits == table[i].bits) {",
          "1421:       strcpy (make,  table[i].t_make );",
          "1422:       strcpy (model, table[i].t_model);",
          "",
          "[Added Lines]",
          "1595:   static const struct",
          "1596:   {",
          "1600:       {0x00, \"Pentax\", \"Optio 33WR\"}, {0x03, \"Nikon\", \"E3200\"}, {0x32, \"Nikon\", \"E3700\"}, {0x33, \"Olympus\", \"C740UZ\"}};",
          "1602:   fseek(ifp, 3072, SEEK_SET);",
          "1603:   fread(dp, 1, 24, ifp);",
          "1605:   for (i = 0; i < sizeof table / sizeof *table; i++)",
          "1606:     if (bits == table[i].bits)",
          "1607:     {",
          "1608:       strcpy(make, table[i].t_make);",
          "1609:       strcpy(model, table[i].t_model);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1431:   int i, nz;",
          "1432:   char tail[424];",
          "1438:   return nz > 20;",
          "1439: }",
          "1440: void CLASS ppm_thumb()",
          "1441: {",
          "1442:   char *thumb;",
          "1450: }",
          "1452: void CLASS ppm16_thumb()",
          "1453: {",
          "1454:   int i;",
          "1455:   char *thumb;",
          "1465: }",
          "1467: void CLASS layer_thumb()",
          "1468: {",
          "1469:   int i, c;",
          "1472:   colors = thumb_misc >> 5 & 7;",
          "1482: }",
          "1484: void CLASS rollei_thumb()",
          "",
          "[Removed Lines]",
          "1434:   fseek (ifp, -sizeof tail, SEEK_END);",
          "1435:   fread (tail, 1, sizeof tail, ifp);",
          "1436:   for (nz=i=0; i < sizeof tail; i++)",
          "1437:     if (tail[i]) nz++;",
          "1443:   thumb_length = thumb_width*thumb_height*3;",
          "1444:   thumb = (char *) malloc (thumb_length);",
          "1445:   merror (thumb, \"ppm_thumb()\");",
          "1446:   fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);",
          "1447:   fread  (thumb, 1, thumb_length, ifp);",
          "1448:   fwrite (thumb, 1, thumb_length, ofp);",
          "1449:   free (thumb);",
          "1456:   thumb_length = thumb_width*thumb_height*3;",
          "1457:   thumb = (char *) calloc (thumb_length, 2);",
          "1458:   merror (thumb, \"ppm16_thumb()\");",
          "1459:   read_shorts ((ushort *) thumb, thumb_length);",
          "1460:   for (i=0; i < thumb_length; i++)",
          "1461:     thumb[i] = ((ushort *) thumb)[i] >> 8;",
          "1462:   fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);",
          "1463:   fwrite (thumb, 1, thumb_length, ofp);",
          "1464:   free (thumb);",
          "1470:   char *thumb, map[][4] = { \"012\",\"102\" };",
          "1473:   thumb_length = thumb_width*thumb_height;",
          "1474:   thumb = (char *) calloc (colors, thumb_length);",
          "1475:   merror (thumb, \"layer_thumb()\");",
          "1476:   fprintf (ofp, \"P%d\\n%d %d\\n255\\n\",",
          "1477:  5 + (colors >> 1), thumb_width, thumb_height);",
          "1478:   fread (thumb, thumb_length, colors, ifp);",
          "1479:   for (i=0; i < thumb_length; i++)",
          "1480:     FORCC putc (thumb[i+thumb_length*(map[thumb_misc >> 8][c]-'0')], ofp);",
          "1481:   free (thumb);",
          "",
          "[Added Lines]",
          "1621:   fseek(ifp, -sizeof tail, SEEK_END);",
          "1622:   fread(tail, 1, sizeof tail, ifp);",
          "1623:   for (nz = i = 0; i < sizeof tail; i++)",
          "1624:     if (tail[i])",
          "1625:       nz++;",
          "1631:   thumb_length = thumb_width * thumb_height * 3;",
          "1632:   thumb = (char *)malloc(thumb_length);",
          "1633:   merror(thumb, \"ppm_thumb()\");",
          "1634:   fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);",
          "1635:   fread(thumb, 1, thumb_length, ifp);",
          "1636:   fwrite(thumb, 1, thumb_length, ofp);",
          "1637:   free(thumb);",
          "1644:   thumb_length = thumb_width * thumb_height * 3;",
          "1645:   thumb = (char *)calloc(thumb_length, 2);",
          "1646:   merror(thumb, \"ppm16_thumb()\");",
          "1647:   read_shorts((ushort *)thumb, thumb_length);",
          "1648:   for (i = 0; i < thumb_length; i++)",
          "1649:     thumb[i] = ((ushort *)thumb)[i] >> 8;",
          "1650:   fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);",
          "1651:   fwrite(thumb, 1, thumb_length, ofp);",
          "1652:   free(thumb);",
          "1658:   char *thumb, map[][4] = {\"012\", \"102\"};",
          "1661:   thumb_length = thumb_width * thumb_height;",
          "1662:   thumb = (char *)calloc(colors, thumb_length);",
          "1663:   merror(thumb, \"layer_thumb()\");",
          "1664:   fprintf(ofp, \"P%d\\n%d %d\\n255\\n\", 5 + (colors >> 1), thumb_width, thumb_height);",
          "1665:   fread(thumb, thumb_length, colors, ifp);",
          "1666:   for (i = 0; i < thumb_length; i++)",
          "1667:     FORCC putc(thumb[i + thumb_length * (map[thumb_misc >> 8][c] - '0')], ofp);",
          "1668:   free(thumb);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1487:   ushort *thumb;",
          "1489:   thumb_length = thumb_width * thumb_height;",
          "1498:   }",
          "1500: }",
          "1502: void CLASS rollei_load_raw()",
          "1503: {",
          "1504:   uchar pixel[10];",
          "1507:   isix = raw_width * raw_height * 5 / 8;",
          "1509: #ifdef LIBRAW_LIBRARY_BUILD",
          "1510:     checkCancel();",
          "1511: #endif",
          "1516:     }",
          "1520:     }",
          "1523:   }",
          "1524:   maximum = 0x3ff;",
          "1525: }",
          "1533: {",
          "1534:   ushort head[8];",
          "1535:   unsigned wide, high, y, x, c, rend, cend, row, col;",
          "1536:   float *mrow, num, mult[4];",
          "1540:   wide = head[2] / head[4] + (head[2] % head[4] != 0);",
          "1541:   high = head[3] / head[5] + (head[3] % head[5] != 0);",
          "1545: #ifdef LIBRAW_LIBRARY_BUILD",
          "1546:     checkCancel();",
          "1547: #endif",
          "1583: }",
          "1585: int CLASS phase_one_correct()",
          "1586: {",
          "1587:   unsigned entries, tag, data, save, col, row, type;",
          "1588:   int len, i, j, k, cip, val[4], dev[4], sum, max;",
          "1594:   ushort *xval[2];",
          "1595:   int qmult_applied = 0, qlin_applied = 0;",
          "1598: #ifdef DCRAW_VERBOSE",
          "1600: #endif",
          "1602:   order = get2();",
          "1607: #ifdef LIBRAW_LIBRARY_BUILD",
          "1609: #endif",
          "1611: #ifdef LIBRAW_LIBRARY_BUILD",
          "1613: #endif",
          "1637: #ifdef LIBRAW_LIBRARY_BUILD",
          "1639: #endif",
          "1714:           {",
          "1715: #ifdef LIBRAW_LIBRARY_BUILD",
          "1717: #endif",
          "1721:           }",
          "1737: #ifdef LIBRAW_LIBRARY_BUILD",
          "1739: #endif",
          "1767:           {",
          "1768: #ifdef LIBRAW_LIBRARY_BUILD",
          "1770: #endif",
          "1774:           }",
          "1775:         }",
          "1776:       }",
          "1779:     }",
          "1798:     {",
          "1799: #ifdef LIBRAW_LIBRARY_BUILD",
          "1801: #endif",
          "1815:       }",
          "1816:     }",
          "1819: #ifdef LIBRAW_LIBRARY_BUILD",
          "1820:   }",
          "1821:   catch (...)",
          "1822:   {",
          "1824:     return LIBRAW_CANCELLED_BY_CALLBACK;",
          "1825:   }",
          "1826: #endif",
          "",
          "[Removed Lines]",
          "1490:   thumb = (ushort *) calloc (thumb_length, 2);",
          "1491:   merror (thumb, \"rollei_thumb()\");",
          "1492:   fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);",
          "1493:   read_shorts (thumb, thumb_length);",
          "1494:   for (i=0; i < thumb_length; i++) {",
          "1495:     putc (thumb[i] << 3, ofp);",
          "1496:     putc (thumb[i] >> 5  << 2, ofp);",
          "1497:     putc (thumb[i] >> 11 << 3, ofp);",
          "1499:   free (thumb);",
          "1505:   unsigned iten=0, isix, i, buffer=0, todo[16];",
          "1508:   while (fread (pixel, 1, 10, ifp) == 10) {",
          "1512:     for (i=0; i < 10; i+=2) {",
          "1513:       todo[i]   = iten++;",
          "1514:       todo[i+1] = pixel[i] << 8 | pixel[i+1];",
          "1515:       buffer    = pixel[i] >> 2 | buffer << 6;",
          "1517:     for (   ; i < 16; i+=2) {",
          "1518:       todo[i]   = isix++;",
          "1519:       todo[i+1] = buffer >> (14-i)*5;",
          "1521:     for (i=0; i < 16; i+=2)",
          "1522:       raw_image[todo[i]] = (todo[i+1] & 0x3ff);",
          "1527: int CLASS raw (unsigned row, unsigned col)",
          "1528: {",
          "1529:   return (row < raw_height && col < raw_width) ? RAW(row,col) : 0;",
          "1530: }",
          "1532: void CLASS phase_one_flat_field (int is_float, int nc)",
          "1538:   read_shorts (head, 8);",
          "1539:   if (head[2] * head[3] * head[4] * head[5] == 0) return;",
          "1542:   mrow = (float *) calloc (nc*wide, sizeof *mrow);",
          "1543:   merror (mrow, \"phase_one_flat_field()\");",
          "1544:   for (y=0; y < high; y++) {",
          "1548:     for (x=0; x < wide; x++)",
          "1549:       for (c=0; c < nc; c+=2) {",
          "1550:  num = is_float ? getreal(11) : get2()/32768.0;",
          "1551:  if (y==0) mrow[c*wide+x] = num;",
          "1552:  else mrow[(c+1)*wide+x] = (num - mrow[c*wide+x]) / head[5];",
          "1553:       }",
          "1554:     if (y==0) continue;",
          "1555:     rend = head[1] + y*head[5];",
          "1556:     for (row = rend-head[5];",
          "1557:   row < raw_height && row < rend &&",
          "1558:   row < head[1]+head[3]-head[5]; row++) {",
          "1559:       for (x=1; x < wide; x++) {",
          "1560:  for (c=0; c < nc; c+=2) {",
          "1561:    mult[c] = mrow[c*wide+x-1];",
          "1562:    mult[c+1] = (mrow[c*wide+x] - mult[c]) / head[4];",
          "1563:  }",
          "1564:  cend = head[0] + x*head[4];",
          "1565:  for (col = cend-head[4];",
          "1566:       col < raw_width &&",
          "1567:       col < cend && col < head[0]+head[2]-head[4]; col++) {",
          "1568:    c = nc > 2 ? FC(row-top_margin,col-left_margin) : 0;",
          "1569:    if (!(c & 1)) {",
          "1570:      c = RAW(row,col) * mult[c];",
          "1571:      RAW(row,col) = LIM(c,0,65535);",
          "1572:    }",
          "1573:    for (c=0; c < nc; c+=2)",
          "1574:      mult[c] += mult[c+1];",
          "1575:  }",
          "1576:       }",
          "1577:       for (x=0; x < wide; x++)",
          "1578:  for (c=0; c < nc; c+=2)",
          "1579:    mrow[c*wide+x] += mrow[(c+1)*wide+x];",
          "1580:     }",
          "1581:   }",
          "1582:   free (mrow);",
          "1589:   int head[9], diff, mindiff=INT_MAX, off_412=0;",
          "1591:     { {-1,-1}, {-1,1}, {1,-1}, {1,1}, {-2,0}, {0,-2}, {0,2}, {2,0},",
          "1592:       {-2,-2}, {-2,2}, {2,-2}, {2,2} };",
          "1593:   float poly[8], num, cfrac, frac, mult[2], *yval[2]={NULL,NULL};",
          "1597:   if (half_size || !meta_length) return 0;",
          "1599:   if (verbose) fprintf (stderr,_(\"Phase One correction...\\n\"));",
          "1601:   fseek (ifp, meta_offset, SEEK_SET);",
          "1603:   fseek (ifp, 6, SEEK_CUR);",
          "1604:   fseek (ifp, meta_offset+get4(), SEEK_SET);",
          "1605:   entries = get4();  get4();",
          "1608:   try {",
          "1610:   while (entries--) {",
          "1612:     checkCancel();",
          "1614:     tag  = get4();",
          "1615:     len  = get4();",
          "1616:     data = get4();",
          "1617:     save = ftell(ifp);",
          "1618:     fseek (ifp, meta_offset+data, SEEK_SET);",
          "1620:       for (get4(), i=0; i < 8; i++)",
          "1621:  poly[i] = getreal(11);",
          "1622:       poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;",
          "1623:       for (i=0; i < 0x10000; i++) {",
          "1624:  num = (poly[5]*i + poly[3])*i + poly[1];",
          "1625:  curve[i] = LIM(num,0,65535);",
          "1628:       for (i=0; i < 4; i++)",
          "1629:  poly[i] = getreal(11);",
          "1630:       for (i=0; i < 0x10000; i++) {",
          "1631:  for (num=0, j=4; j--; )",
          "1632:    num = num * i + poly[j];",
          "1633:  curve[i] = LIM(num+i,0,65535);",
          "1635:       for (row=0; row < raw_height; row++)",
          "1636:       {",
          "1638:         checkCancel();",
          "1640:  for (col = (tag & 1)*ph1.split_col; col < raw_width; col++)",
          "1641:    RAW(row,col) = curve[RAW(row,col)];",
          "1642:       }",
          "1644:       while ((len -= 8) >= 0) {",
          "1645:  col  = get2();",
          "1646:  row  = get2();",
          "1647:  type = get2(); get2();",
          "1648:  if (col >= raw_width) continue;",
          "1650:    for (row=0; row < raw_height; row++)",
          "1651:      if (FC(row-top_margin,col-left_margin) == 1) {",
          "1652:        for (sum=i=0; i < 4; i++)",
          "1653:   sum += val[i] = raw (row+dir[i][0], col+dir[i][1]);",
          "1654:        for (max=i=0; i < 4; i++) {",
          "1655:   dev[i] = abs((val[i] << 2) - sum);",
          "1656:   if (dev[max] < dev[i]) max = i;",
          "1657:        }",
          "1658:        RAW(row,col) = (sum - val[max])/3.0 + 0.5;",
          "1659:      } else {",
          "1660:        for (sum=0, i=8; i < 12; i++)",
          "1661:   sum += raw (row+dir[i][0], col+dir[i][1]);",
          "1662:        RAW(row,col) = 0.5 + sum * 0.0732233 +",
          "1663:   (raw(row,col-2) + raw(row,col+2)) * 0.3535534;",
          "1664:      }",
          "1666:    if (row >= raw_height) continue;",
          "1667:    j = (FC(row-top_margin,col-left_margin) != 1) * 4;",
          "1668:    for (sum=0, i=j; i < j+8; i++)",
          "1669:      sum += raw (row+dir[i][0], col+dir[i][1]);",
          "1670:    RAW(row,col) = (sum + 4) >> 3;",
          "1671:  }",
          "1672:       }",
          "1674:       phase_one_flat_field (1, 2);",
          "1675:     } else if (tag == 0x416 || tag == 0x410) {",
          "1676:       phase_one_flat_field (0, 2);",
          "1678:       phase_one_flat_field (0, 4);",
          "1679:     } else if (tag == 0x412) {",
          "1680:       fseek (ifp, 36, SEEK_CUR);",
          "1681:       diff = abs (get2() - ph1.tag_21a);",
          "1682:       if (mindiff > diff) {",
          "1683:  mindiff = diff;",
          "1684:  off_412 = ftell(ifp) - 38;",
          "1685:       }",
          "1687:       ushort lc[2][2][16], ref[16];",
          "1688:       int qr, qc;",
          "1689:       for (qr = 0; qr < 2; qr++)",
          "1690:  for (qc = 0; qc < 2; qc++)",
          "1691:    for (i = 0; i < 16; i++)",
          "1692:      lc[qr][qc][i] = get4();",
          "1693:       for (i = 0; i < 16; i++) {",
          "1694:  int v = 0;",
          "1695:  for (qr = 0; qr < 2; qr++)",
          "1696:    for (qc = 0; qc < 2; qc++)",
          "1697:      v += lc[qr][qc][i];",
          "1698:  ref[i] = (v + 2) >> 2;",
          "1699:       }",
          "1700:       for (qr = 0; qr < 2; qr++) {",
          "1701:  for (qc = 0; qc < 2; qc++) {",
          "1702:    int cx[19], cf[19];",
          "1703:    for (i = 0; i < 16; i++) {",
          "1704:      cx[1+i] = lc[qr][qc][i];",
          "1705:      cf[1+i] = ref[i];",
          "1706:    }",
          "1707:    cx[0] = cf[0] = 0;",
          "1708:    cx[17] = cf[17] = ((unsigned int)ref[15] * 65535) / lc[qr][qc][15];",
          "1709:           cf[18] = cx[18] = 65535;",
          "1710:    cubic_spline(cx, cf, 19);",
          "1712:    for (row = (qr ? ph1.split_row : 0);",
          "1713:         row < (qr ? raw_height : ph1.split_row); row++)",
          "1716:             checkCancel();",
          "1718:      for (col = (qc ? ph1.split_col : 0);",
          "1719:    col < (qc ? raw_width : ph1.split_col); col++)",
          "1720:        RAW(row,col) = curve[RAW(row,col)];",
          "1722:  }",
          "1723:       }",
          "1724:       qlin_applied = 1;",
          "1726:       float qmult[2][2] = { { 1, 1 }, { 1, 1 } };",
          "1727:       get4(); get4(); get4(); get4();",
          "1728:       qmult[0][0] = 1.0 + getreal(11);",
          "1729:       get4(); get4(); get4(); get4(); get4();",
          "1730:       qmult[0][1] = 1.0 + getreal(11);",
          "1731:       get4(); get4(); get4();",
          "1732:       qmult[1][0] = 1.0 + getreal(11);",
          "1733:       get4(); get4(); get4();",
          "1734:       qmult[1][1] = 1.0 + getreal(11);",
          "1735:       for (row=0; row < raw_height; row++)",
          "1736:       {",
          "1738:         checkCancel();",
          "1740:  for (col=0; col < raw_width; col++) {",
          "1741:    i = qmult[row >= ph1.split_row][col >= ph1.split_col] * RAW(row,col);",
          "1742:    RAW(row,col) = LIM(i,0,65535);",
          "1743:  }",
          "1744:       }",
          "1745:       qmult_applied = 1;",
          "1747:       ushort lc[2][2][7], ref[7];",
          "1748:       int qr, qc;",
          "1749:       for (i = 0; i < 7; i++)",
          "1750:  ref[i] = get4();",
          "1751:       for (qr = 0; qr < 2; qr++)",
          "1752:  for (qc = 0; qc < 2; qc++)",
          "1753:    for (i = 0; i < 7; i++)",
          "1754:      lc[qr][qc][i] = get4();",
          "1755:       for (qr = 0; qr < 2; qr++) {",
          "1756:  for (qc = 0; qc < 2; qc++) {",
          "1757:    int cx[9], cf[9];",
          "1758:    for (i = 0; i < 7; i++) {",
          "1759:      cx[1+i] = ref[i];",
          "1760:      cf[1+i] = ((unsigned) ref[i] * lc[qr][qc][i]) / 10000;",
          "1761:    }",
          "1762:    cx[0] = cf[0] = 0;",
          "1763:    cx[8] = cf[8] = 65535;",
          "1764:    cubic_spline(cx, cf, 9);",
          "1765:    for (row = (qr ? ph1.split_row : 0);",
          "1766:         row < (qr ? raw_height : ph1.split_row); row++)",
          "1769:             checkCancel();",
          "1771:      for (col = (qc ? ph1.split_col : 0);",
          "1772:    col < (qc ? raw_width : ph1.split_col); col++)",
          "1773:        RAW(row,col) = curve[RAW(row,col)];",
          "1777:       qmult_applied = 1;",
          "1778:       qlin_applied = 1;",
          "1780:     fseek (ifp, save, SEEK_SET);",
          "1781:   }",
          "1782:   if (off_412) {",
          "1783:     fseek (ifp, off_412, SEEK_SET);",
          "1784:     for (i=0; i < 9; i++) head[i] = get4() & 0x7fff;",
          "1785:     yval[0] = (float *) calloc (head[1]*head[3] + head[2]*head[4], 6);",
          "1786:     merror (yval[0], \"phase_one_correct()\");",
          "1787:     yval[1] = (float  *) (yval[0] + head[1]*head[3]);",
          "1788:     xval[0] = (ushort *) (yval[1] + head[2]*head[4]);",
          "1789:     xval[1] = (ushort *) (xval[0] + head[1]*head[3]);",
          "1790:     get2();",
          "1791:     for (i=0; i < 2; i++)",
          "1792:       for (j=0; j < head[i+1]*head[i+3]; j++)",
          "1793:  yval[i][j] = getreal(11);",
          "1794:     for (i=0; i < 2; i++)",
          "1795:       for (j=0; j < head[i+1]*head[i+3]; j++)",
          "1796:  xval[i][j] = get2();",
          "1797:     for (row=0; row < raw_height; row++)",
          "1800:       checkCancel();",
          "1802:       for (col=0; col < raw_width; col++) {",
          "1803:  cfrac = (float) col * head[3] / raw_width;",
          "1804:  cfrac -= cip = cfrac;",
          "1805:  num = RAW(row,col) * 0.5;",
          "1806:  for (i=cip; i < cip+2; i++) {",
          "1807:    for (k=j=0; j < head[1]; j++)",
          "1808:      if (num < xval[0][k = head[1]*i+j]) break;",
          "1809:    frac = (j == 0 || j == head[1]) ? 0 :",
          "1810:   (xval[0][k] - num) / (xval[0][k] - xval[0][k-1]);",
          "1811:    mult[i-cip] = yval[0][k-1] * frac + yval[0][k] * (1-frac);",
          "1812:  }",
          "1813:  i = ((mult[0] * (1-cfrac) + mult[1] * cfrac) * row + num) * 2;",
          "1814:  RAW(row,col) = LIM(i,0,65535);",
          "1817:     free (yval[0]);",
          "1818:   }",
          "1823:     if(yval[0]) free(yval[0]);",
          "",
          "[Added Lines]",
          "1677:   thumb = (ushort *)calloc(thumb_length, 2);",
          "1678:   merror(thumb, \"rollei_thumb()\");",
          "1679:   fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);",
          "1680:   read_shorts(thumb, thumb_length);",
          "1681:   for (i = 0; i < thumb_length; i++)",
          "1682:   {",
          "1683:     putc(thumb[i] << 3, ofp);",
          "1684:     putc(thumb[i] >> 5 << 2, ofp);",
          "1685:     putc(thumb[i] >> 11 << 3, ofp);",
          "1687:   free(thumb);",
          "1693:   unsigned iten = 0, isix, i, buffer = 0, todo[16];",
          "1696:   while (fread(pixel, 1, 10, ifp) == 10)",
          "1697:   {",
          "1701:     for (i = 0; i < 10; i += 2)",
          "1702:     {",
          "1703:       todo[i] = iten++;",
          "1704:       todo[i + 1] = pixel[i] << 8 | pixel[i + 1];",
          "1705:       buffer = pixel[i] >> 2 | buffer << 6;",
          "1707:     for (; i < 16; i += 2)",
          "1708:     {",
          "1709:       todo[i] = isix++;",
          "1710:       todo[i + 1] = buffer >> (14 - i) * 5;",
          "1712:     for (i = 0; i < 16; i += 2)",
          "1713:       raw_image[todo[i]] = (todo[i + 1] & 0x3ff);",
          "1718: int CLASS raw(unsigned row, unsigned col) { return (row < raw_height && col < raw_width) ? RAW(row, col) : 0; }",
          "1720: void CLASS phase_one_flat_field(int is_float, int nc)",
          "1726:   read_shorts(head, 8);",
          "1727:   if (head[2] * head[3] * head[4] * head[5] == 0)",
          "1728:     return;",
          "1731:   mrow = (float *)calloc(nc * wide, sizeof *mrow);",
          "1732:   merror(mrow, \"phase_one_flat_field()\");",
          "1733:   for (y = 0; y < high; y++)",
          "1734:   {",
          "1738:     for (x = 0; x < wide; x++)",
          "1739:       for (c = 0; c < nc; c += 2)",
          "1740:       {",
          "1741:         num = is_float ? getreal(11) : get2() / 32768.0;",
          "1742:         if (y == 0)",
          "1743:           mrow[c * wide + x] = num;",
          "1744:         else",
          "1745:           mrow[(c + 1) * wide + x] = (num - mrow[c * wide + x]) / head[5];",
          "1746:       }",
          "1747:     if (y == 0)",
          "1748:       continue;",
          "1749:     rend = head[1] + y * head[5];",
          "1750:     for (row = rend - head[5]; row < raw_height && row < rend && row < head[1] + head[3] - head[5]; row++)",
          "1751:     {",
          "1752:       for (x = 1; x < wide; x++)",
          "1753:       {",
          "1754:         for (c = 0; c < nc; c += 2)",
          "1755:         {",
          "1756:           mult[c] = mrow[c * wide + x - 1];",
          "1757:           mult[c + 1] = (mrow[c * wide + x] - mult[c]) / head[4];",
          "1758:         }",
          "1759:         cend = head[0] + x * head[4];",
          "1760:         for (col = cend - head[4]; col < raw_width && col < cend && col < head[0] + head[2] - head[4]; col++)",
          "1761:         {",
          "1762:           c = nc > 2 ? FC(row - top_margin, col - left_margin) : 0;",
          "1763:           if (!(c & 1))",
          "1764:           {",
          "1765:             c = RAW(row, col) * mult[c];",
          "1766:             RAW(row, col) = LIM(c, 0, 65535);",
          "1767:           }",
          "1768:           for (c = 0; c < nc; c += 2)",
          "1769:             mult[c] += mult[c + 1];",
          "1770:         }",
          "1771:       }",
          "1772:       for (x = 0; x < wide; x++)",
          "1773:         for (c = 0; c < nc; c += 2)",
          "1774:           mrow[c * wide + x] += mrow[(c + 1) * wide + x];",
          "1775:     }",
          "1776:   }",
          "1777:   free(mrow);",
          "1784:   int head[9], diff, mindiff = INT_MAX, off_412 = 0;",
          "1786:                                                {0, 2},   {2, 0},  {-2, -2}, {-2, 2}, {2, -2}, {2, 2}};",
          "1787:   float poly[8], num, cfrac, frac, mult[2], *yval[2] = {NULL, NULL};",
          "1791:   if (half_size || !meta_length)",
          "1792:     return 0;",
          "1794:   if (verbose)",
          "1795:     fprintf(stderr, _(\"Phase One correction...\\n\"));",
          "1797:   fseek(ifp, meta_offset, SEEK_SET);",
          "1799:   fseek(ifp, 6, SEEK_CUR);",
          "1800:   fseek(ifp, meta_offset + get4(), SEEK_SET);",
          "1801:   entries = get4();",
          "1802:   get4();",
          "1805:   try",
          "1806:   {",
          "1808:     while (entries--)",
          "1809:     {",
          "1811:       checkCancel();",
          "1813:       tag = get4();",
          "1814:       len = get4();",
          "1815:       data = get4();",
          "1816:       save = ftell(ifp);",
          "1817:       fseek(ifp, meta_offset + data, SEEK_SET);",
          "1818:       if (tag == 0x419)",
          "1820:         for (get4(), i = 0; i < 8; i++)",
          "1821:           poly[i] = getreal(11);",
          "1822:         poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;",
          "1823:         for (i = 0; i < 0x10000; i++)",
          "1824:         {",
          "1825:           num = (poly[5] * i + poly[3]) * i + poly[1];",
          "1826:           curve[i] = LIM(num, 0, 65535);",
          "1827:         }",
          "1829:       }",
          "1830:       else if (tag == 0x41a)",
          "1832:         for (i = 0; i < 4; i++)",
          "1833:           poly[i] = getreal(11);",
          "1834:         for (i = 0; i < 0x10000; i++)",
          "1835:         {",
          "1836:           for (num = 0, j = 4; j--;)",
          "1837:             num = num * i + poly[j];",
          "1838:           curve[i] = LIM(num + i, 0, 65535);",
          "1839:         }",
          "1841:         for (row = 0; row < raw_height; row++)",
          "1842:         {",
          "1844:           checkCancel();",
          "1846:           for (col = (tag & 1) * ph1.split_col; col < raw_width; col++)",
          "1847:             RAW(row, col) = curve[RAW(row, col)];",
          "1848:         }",
          "1849:       }",
          "1850:       else if (tag == 0x400)",
          "1852:         while ((len -= 8) >= 0)",
          "1853:         {",
          "1854:           col = get2();",
          "1855:           row = get2();",
          "1856:           type = get2();",
          "1857:           get2();",
          "1858:           if (col >= raw_width)",
          "1859:             continue;",
          "1861:             for (row = 0; row < raw_height; row++)",
          "1862:               if (FC(row - top_margin, col - left_margin) == 1)",
          "1863:               {",
          "1864:                 for (sum = i = 0; i < 4; i++)",
          "1865:                   sum += val[i] = raw(row + dir[i][0], col + dir[i][1]);",
          "1866:                 for (max = i = 0; i < 4; i++)",
          "1867:                 {",
          "1868:                   dev[i] = abs((val[i] << 2) - sum);",
          "1869:                   if (dev[max] < dev[i])",
          "1870:                     max = i;",
          "1871:                 }",
          "1872:                 RAW(row, col) = (sum - val[max]) / 3.0 + 0.5;",
          "1873:               }",
          "1874:               else",
          "1875:               {",
          "1876:                 for (sum = 0, i = 8; i < 12; i++)",
          "1877:                   sum += raw(row + dir[i][0], col + dir[i][1]);",
          "1878:                 RAW(row, col) = 0.5 + sum * 0.0732233 + (raw(row, col - 2) + raw(row, col + 2)) * 0.3535534;",
          "1879:               }",
          "1880:           else if (type == 129)",
          "1882:             if (row >= raw_height)",
          "1883:               continue;",
          "1884:             j = (FC(row - top_margin, col - left_margin) != 1) * 4;",
          "1885:             for (sum = 0, i = j; i < j + 8; i++)",
          "1886:               sum += raw(row + dir[i][0], col + dir[i][1]);",
          "1887:             RAW(row, col) = (sum + 4) >> 3;",
          "1888:           }",
          "1889:         }",
          "1890:       }",
          "1891:       else if (tag == 0x401)",
          "1893:         phase_one_flat_field(1, 2);",
          "1894:       }",
          "1895:       else if (tag == 0x416 || tag == 0x410)",
          "1896:       {",
          "1897:         phase_one_flat_field(0, 2);",
          "1898:       }",
          "1899:       else if (tag == 0x40b)",
          "1901:         phase_one_flat_field(0, 4);",
          "1902:       }",
          "1903:       else if (tag == 0x412)",
          "1904:       {",
          "1905:         fseek(ifp, 36, SEEK_CUR);",
          "1906:         diff = abs(get2() - ph1.tag_21a);",
          "1907:         if (mindiff > diff)",
          "1908:         {",
          "1909:           mindiff = diff;",
          "1910:           off_412 = ftell(ifp) - 38;",
          "1911:         }",
          "1912:       }",
          "1913:       else if (tag == 0x41f && !qlin_applied)",
          "1915:         ushort lc[2][2][16], ref[16];",
          "1916:         int qr, qc;",
          "1917:         for (qr = 0; qr < 2; qr++)",
          "1918:           for (qc = 0; qc < 2; qc++)",
          "1919:             for (i = 0; i < 16; i++)",
          "1920:               lc[qr][qc][i] = get4();",
          "1921:         for (i = 0; i < 16; i++)",
          "1922:         {",
          "1923:           int v = 0;",
          "1924:           for (qr = 0; qr < 2; qr++)",
          "1925:             for (qc = 0; qc < 2; qc++)",
          "1926:               v += lc[qr][qc][i];",
          "1927:           ref[i] = (v + 2) >> 2;",
          "1928:         }",
          "1929:         for (qr = 0; qr < 2; qr++)",
          "1930:         {",
          "1931:           for (qc = 0; qc < 2; qc++)",
          "1933:             int cx[19], cf[19];",
          "1934:             for (i = 0; i < 16; i++)",
          "1935:             {",
          "1936:               cx[1 + i] = lc[qr][qc][i];",
          "1937:               cf[1 + i] = ref[i];",
          "1938:             }",
          "1939:             cx[0] = cf[0] = 0;",
          "1940:             cx[17] = cf[17] = ((unsigned int)ref[15] * 65535) / lc[qr][qc][15];",
          "1941:             cf[18] = cx[18] = 65535;",
          "1942:             cubic_spline(cx, cf, 19);",
          "1944:             for (row = (qr ? ph1.split_row : 0); row < (qr ? raw_height : ph1.split_row); row++)",
          "1945:             {",
          "1947:               checkCancel();",
          "1949:               for (col = (qc ? ph1.split_col : 0); col < (qc ? raw_width : ph1.split_col); col++)",
          "1950:                 RAW(row, col) = curve[RAW(row, col)];",
          "1951:             }",
          "1953:         }",
          "1954:         qlin_applied = 1;",
          "1955:       }",
          "1956:       else if (tag == 0x41e && !qmult_applied)",
          "1958:         float qmult[2][2] = {{1, 1}, {1, 1}};",
          "1959:         get4();",
          "1960:         get4();",
          "1961:         get4();",
          "1962:         get4();",
          "1963:         qmult[0][0] = 1.0 + getreal(11);",
          "1964:         get4();",
          "1965:         get4();",
          "1966:         get4();",
          "1967:         get4();",
          "1968:         get4();",
          "1969:         qmult[0][1] = 1.0 + getreal(11);",
          "1970:         get4();",
          "1971:         get4();",
          "1972:         get4();",
          "1973:         qmult[1][0] = 1.0 + getreal(11);",
          "1974:         get4();",
          "1975:         get4();",
          "1976:         get4();",
          "1977:         qmult[1][1] = 1.0 + getreal(11);",
          "1978:         for (row = 0; row < raw_height; row++)",
          "1979:         {",
          "1981:           checkCancel();",
          "1983:           for (col = 0; col < raw_width; col++)",
          "1985:             i = qmult[row >= ph1.split_row][col >= ph1.split_col] * RAW(row, col);",
          "1986:             RAW(row, col) = LIM(i, 0, 65535);",
          "1987:           }",
          "1988:         }",
          "1989:         qmult_applied = 1;",
          "1990:       }",
          "1991:       else if (tag == 0x431 && !qmult_applied)",
          "1993:         ushort lc[2][2][7], ref[7];",
          "1994:         int qr, qc;",
          "1995:         for (i = 0; i < 7; i++)",
          "1996:           ref[i] = get4();",
          "1997:         for (qr = 0; qr < 2; qr++)",
          "1998:           for (qc = 0; qc < 2; qc++)",
          "1999:             for (i = 0; i < 7; i++)",
          "2000:               lc[qr][qc][i] = get4();",
          "2001:         for (qr = 0; qr < 2; qr++)",
          "2002:         {",
          "2003:           for (qc = 0; qc < 2; qc++)",
          "2004:           {",
          "2005:             int cx[9], cf[9];",
          "2006:             for (i = 0; i < 7; i++)",
          "2007:             {",
          "2008:               cx[1 + i] = ref[i];",
          "2009:               cf[1 + i] = ((unsigned)ref[i] * lc[qr][qc][i]) / 10000;",
          "2010:             }",
          "2011:             cx[0] = cf[0] = 0;",
          "2012:             cx[8] = cf[8] = 65535;",
          "2013:             cubic_spline(cx, cf, 9);",
          "2014:             for (row = (qr ? ph1.split_row : 0); row < (qr ? raw_height : ph1.split_row); row++)",
          "2015:             {",
          "2017:               checkCancel();",
          "2019:               for (col = (qc ? ph1.split_col : 0); col < (qc ? raw_width : ph1.split_col); col++)",
          "2020:                 RAW(row, col) = curve[RAW(row, col)];",
          "2021:             }",
          "2024:         qmult_applied = 1;",
          "2025:         qlin_applied = 1;",
          "2027:       fseek(ifp, save, SEEK_SET);",
          "2029:     if (off_412)",
          "2031:       fseek(ifp, off_412, SEEK_SET);",
          "2032:       for (i = 0; i < 9; i++)",
          "2033:         head[i] = get4() & 0x7fff;",
          "2034:       yval[0] = (float *)calloc(head[1] * head[3] + head[2] * head[4], 6);",
          "2035:       merror(yval[0], \"phase_one_correct()\");",
          "2036:       yval[1] = (float *)(yval[0] + head[1] * head[3]);",
          "2037:       xval[0] = (ushort *)(yval[1] + head[2] * head[4]);",
          "2038:       xval[1] = (ushort *)(xval[0] + head[1] * head[3]);",
          "2039:       get2();",
          "2040:       for (i = 0; i < 2; i++)",
          "2041:         for (j = 0; j < head[i + 1] * head[i + 3]; j++)",
          "2042:           yval[i][j] = getreal(11);",
          "2043:       for (i = 0; i < 2; i++)",
          "2044:         for (j = 0; j < head[i + 1] * head[i + 3]; j++)",
          "2045:           xval[i][j] = get2();",
          "2046:       for (row = 0; row < raw_height; row++)",
          "2047:       {",
          "2049:         checkCancel();",
          "2051:         for (col = 0; col < raw_width; col++)",
          "2052:         {",
          "2053:           cfrac = (float)col * head[3] / raw_width;",
          "2054:           cfrac -= cip = cfrac;",
          "2055:           num = RAW(row, col) * 0.5;",
          "2056:           for (i = cip; i < cip + 2; i++)",
          "2057:           {",
          "2058:             for (k = j = 0; j < head[1]; j++)",
          "2059:               if (num < xval[0][k = head[1] * i + j])",
          "2060:                 break;",
          "2061:             frac = (j == 0 || j == head[1]) ? 0 : (xval[0][k] - num) / (xval[0][k] - xval[0][k - 1]);",
          "2062:             mult[i - cip] = yval[0][k - 1] * frac + yval[0][k] * (1 - frac);",
          "2063:           }",
          "2064:           i = ((mult[0] * (1 - cfrac) + mult[1] * cfrac) * row + num) * 2;",
          "2065:           RAW(row, col) = LIM(i, 0, 65535);",
          "2066:         }",
          "2068:       free(yval[0]);",
          "2074:     if (yval[0])",
          "2075:       free(yval[0]);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1832:   int a, b, i;",
          "1833:   ushort akey, bkey, t_mask;",
          "1836:   akey = get2();",
          "1837:   bkey = get2();",
          "1839: #ifdef LIBRAW_LIBRARY_BUILD",
          "1841:     {",
          "1857: #endif",
          "1860:   if (ph1.format)",
          "1866:     }",
          "1867: }",
          "1870: {",
          "1871: #ifndef LIBRAW_NOTHREADS",
          "1872: #define bitbuf tls->ph1_bits.bitbuf",
          "1874: #else",
          "1877: #endif",
          "1878:   unsigned c;",
          "1880:   if (nbits == -1)",
          "1881:     return bitbuf = vbits = 0;",
          "1884:     bitbuf = bitbuf << 32 | get4();",
          "1885:     vbits += 32;",
          "1886:   }",
          "1889:     vbits -= huff[c] >> 8;",
          "1891:   }",
          "1892:   vbits -= nbits;",
          "1893:   return c;",
          "",
          "[Removed Lines]",
          "1835:   fseek (ifp, ph1.key_off, SEEK_SET);",
          "1838:   t_mask = ph1.format == 1 ? 0x5555:0x1354;",
          "1840:   if (ph1.black_col || ph1.black_row )",
          "1842:       imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height*2,sizeof(ushort));",
          "1843:       merror(imgdata.rawdata.ph1_cblack,\"phase_one_load_raw()\");",
          "1844:       imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width*2,sizeof(ushort));",
          "1845:       merror(imgdata.rawdata.ph1_rblack,\"phase_one_load_raw()\");",
          "1846:       if (ph1.black_col)",
          "1847:         {",
          "1848:           fseek (ifp, ph1.black_col, SEEK_SET);",
          "1849:           read_shorts ((ushort *)imgdata.rawdata.ph1_cblack[0], raw_height*2);",
          "1850:         }",
          "1851:       if (ph1.black_row)",
          "1852:         {",
          "1853:           fseek (ifp, ph1.black_row, SEEK_SET);",
          "1854:           read_shorts ((ushort *) imgdata.rawdata.ph1_rblack[0], raw_width*2);",
          "1855:         }",
          "1856:       }",
          "1858:   fseek (ifp, data_offset, SEEK_SET);",
          "1859:   read_shorts (raw_image, raw_width*raw_height);",
          "1861:     for (i=0; i < raw_width*raw_height; i+=2) {",
          "1862:       a = raw_image[i+0] ^ akey;",
          "1863:       b = raw_image[i+1] ^ bkey;",
          "1864:       raw_image[i+0] = (a & t_mask) | (b & ~t_mask);",
          "1865:       raw_image[i+1] = (b & t_mask) | (a & ~t_mask);",
          "1869: unsigned CLASS ph1_bithuff (int nbits, ushort *huff)",
          "1873: #define vbits  tls->ph1_bits.vbits",
          "1875:   static UINT64 bitbuf=0;",
          "1876:   static int vbits=0;",
          "1882:   if (nbits == 0) return 0;",
          "1883:   if (vbits < nbits) {",
          "1887:   c = bitbuf << (64-vbits) >> (64-nbits);",
          "1888:   if (huff) {",
          "1890:     return (uchar) huff[c];",
          "",
          "[Added Lines]",
          "2087:   fseek(ifp, ph1.key_off, SEEK_SET);",
          "2090:   t_mask = ph1.format == 1 ? 0x5555 : 0x1354;",
          "2092:   if (ph1.black_col || ph1.black_row)",
          "2093:   {",
          "2094:     imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height * 2, sizeof(ushort));",
          "2095:     merror(imgdata.rawdata.ph1_cblack, \"phase_one_load_raw()\");",
          "2096:     imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width * 2, sizeof(ushort));",
          "2097:     merror(imgdata.rawdata.ph1_rblack, \"phase_one_load_raw()\");",
          "2098:     if (ph1.black_col)",
          "2100:       fseek(ifp, ph1.black_col, SEEK_SET);",
          "2101:       read_shorts((ushort *)imgdata.rawdata.ph1_cblack[0], raw_height * 2);",
          "2102:     }",
          "2103:     if (ph1.black_row)",
          "2104:     {",
          "2105:       fseek(ifp, ph1.black_row, SEEK_SET);",
          "2106:       read_shorts((ushort *)imgdata.rawdata.ph1_rblack[0], raw_width * 2);",
          "2107:     }",
          "2108:   }",
          "2110:   fseek(ifp, data_offset, SEEK_SET);",
          "2111:   read_shorts(raw_image, raw_width * raw_height);",
          "2113:     for (i = 0; i < raw_width * raw_height; i += 2)",
          "2114:     {",
          "2115:       a = raw_image[i + 0] ^ akey;",
          "2116:       b = raw_image[i + 1] ^ bkey;",
          "2117:       raw_image[i + 0] = (a & t_mask) | (b & ~t_mask);",
          "2118:       raw_image[i + 1] = (b & t_mask) | (a & ~t_mask);",
          "2122: unsigned CLASS ph1_bithuff(int nbits, ushort *huff)",
          "2126: #define vbits tls->ph1_bits.vbits",
          "2128:   static UINT64 bitbuf = 0;",
          "2129:   static int vbits = 0;",
          "2135:   if (nbits == 0)",
          "2136:     return 0;",
          "2137:   if (vbits < nbits)",
          "2138:   {",
          "2142:   c = bitbuf << (64 - vbits) >> (64 - nbits);",
          "2143:   if (huff)",
          "2144:   {",
          "2146:     return (uchar)huff[c];",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1896: #undef vbits",
          "1897: #endif",
          "1898: }",
          "1902: void CLASS phase_one_load_raw_c()",
          "1903: {",
          "1905:   int *offset, len[2], pred[2], row, col, i, j;",
          "1906:   ushort *pixel;",
          "1908: #ifdef LIBRAW_LIBRARY_BUILD",
          "1910:     throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "1911: #endif",
          "1918:     offset[row] = get4();",
          "1921:   if (ph1.black_col)",
          "1923:   r_black = c_black + raw_height;",
          "1925:   if (ph1.black_row)",
          "1928: #ifdef LIBRAW_LIBRARY_BUILD",
          "1939: #endif",
          "1943: #ifdef LIBRAW_LIBRARY_BUILD",
          "1945: #endif",
          "1947: #ifdef LIBRAW_LIBRARY_BUILD",
          "1949: #endif",
          "1969: #ifndef LIBRAW_LIBRARY_BUILD",
          "1977: #else",
          "1980:     else",
          "1983: #endif",
          "1985: #ifdef LIBRAW_LIBRARY_BUILD",
          "1988:     throw;",
          "1989:   }",
          "1990: #endif",
          "1992:   maximum = 0xfffc - ph1.t_black;",
          "1993: }",
          "",
          "[Removed Lines]",
          "1899: #define ph1_bits(n) ph1_bithuff(n,0)",
          "1900: #define ph1_huff(h) ph1_bithuff(*h,h+1)",
          "1904:   static const int length[] = { 8,7,6,9,11,10,5,12,14,13 };",
          "1907:   short (*c_black)[2], (*r_black)[2];",
          "1909:   if(ph1.format == 6)",
          "1913:   pixel = (ushort *) calloc (raw_width*3 + raw_height*4, 2);",
          "1914:   merror (pixel, \"phase_one_load_raw_c()\");",
          "1915:   offset = (int *) (pixel + raw_width);",
          "1916:   fseek (ifp, strip_offset, SEEK_SET);",
          "1917:   for (row=0; row < raw_height; row++)",
          "1919:   c_black = (short (*)[2]) (offset + raw_height);",
          "1920:   fseek (ifp, ph1.black_col, SEEK_SET);",
          "1922:       read_shorts ((ushort *) c_black[0], raw_height*2);",
          "1924:   fseek (ifp, ph1.black_row, SEEK_SET);",
          "1926:       read_shorts ((ushort *) r_black[0], raw_width*2);",
          "1930:   if (ph1.black_col || ph1.black_row )",
          "1931:     {",
          "1932:       imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height*2,sizeof(ushort));",
          "1933:       merror(imgdata.rawdata.ph1_cblack,\"phase_one_load_raw_c()\");",
          "1934:       memmove(imgdata.rawdata.ph1_cblack,(ushort*)c_black[0],raw_height*2*sizeof(ushort));",
          "1935:       imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width*2,sizeof(ushort));",
          "1936:       merror(imgdata.rawdata.ph1_rblack,\"phase_one_load_raw_c()\");",
          "1937:       memmove(imgdata.rawdata.ph1_rblack,(ushort*)r_black[0],raw_width*2*sizeof(ushort));",
          "1938:     }",
          "1941:   for (i=0; i < 256; i++)",
          "1942:     curve[i] = i*i / 3.969 + 0.5;",
          "1944:   try {",
          "1946:   for (row=0; row < raw_height; row++) {",
          "1948:     checkCancel();",
          "1950:     fseek (ifp, data_offset + offset[row], SEEK_SET);",
          "1951:     ph1_bits(-1);",
          "1952:     pred[0] = pred[1] = 0;",
          "1953:     for (col=0; col < raw_width; col++) {",
          "1954:       if (col >= (raw_width & -8))",
          "1955:  len[0] = len[1] = 14;",
          "1956:       else if ((col & 7) == 0)",
          "1957:  for (i=0; i < 2; i++) {",
          "1958:    for (j=0; j < 5 && !ph1_bits(1); j++);",
          "1959:    if (j--) len[i] = length[j*2 + ph1_bits(1)];",
          "1960:  }",
          "1961:       if ((i = len[col & 1]) == 14)",
          "1962:  pixel[col] = pred[col & 1] = ph1_bits(16);",
          "1963:       else",
          "1964:  pixel[col] = pred[col & 1] += ph1_bits(i) + 1 - (1 << (i - 1));",
          "1965:       if (pred[col & 1] >> 16) derror();",
          "1966:       if (ph1.format == 5 && pixel[col] < 256)",
          "1967:  pixel[col] = curve[pixel[col]];",
          "1968:     }",
          "1970:     for (col=0; col < raw_width; col++) {",
          "1971:       int shift = ph1.format == 8? 0: 2;",
          "1972:       i = (pixel[col] << shift) - ph1.t_black",
          "1973:  + c_black[row][col >= ph1.split_col]",
          "1974:  + r_black[col][row >= ph1.split_row];",
          "1975:       if (i > 0) RAW(row,col) = i;",
          "1976:     }",
          "1978:     if(ph1.format == 8)",
          "1979:       memmove(&RAW(row,0),&pixel[0],raw_width*2);",
          "1981:       for (col=0; col < raw_width; col++)",
          "1982:        RAW(row,col) = pixel[col] << 2;",
          "1984:   }",
          "1986:   } catch(...) {",
          "1987:     free (pixel);",
          "1991:   free (pixel);",
          "",
          "[Added Lines]",
          "2155: #define ph1_bits(n) ph1_bithuff(n, 0)",
          "2156: #define ph1_huff(h) ph1_bithuff(*h, h + 1)",
          "2160:   static const int length[] = {8, 7, 6, 9, 11, 10, 5, 12, 14, 13};",
          "2163:   short(*c_black)[2], (*r_black)[2];",
          "2165:   if (ph1.format == 6)",
          "2169:   pixel = (ushort *)calloc(raw_width * 3 + raw_height * 4, 2);",
          "2170:   merror(pixel, \"phase_one_load_raw_c()\");",
          "2171:   offset = (int *)(pixel + raw_width);",
          "2172:   fseek(ifp, strip_offset, SEEK_SET);",
          "2173:   for (row = 0; row < raw_height; row++)",
          "2175:   c_black = (short(*)[2])(offset + raw_height);",
          "2176:   fseek(ifp, ph1.black_col, SEEK_SET);",
          "2178:     read_shorts((ushort *)c_black[0], raw_height * 2);",
          "2180:   fseek(ifp, ph1.black_row, SEEK_SET);",
          "2182:     read_shorts((ushort *)r_black[0], raw_width * 2);",
          "2186:   if (ph1.black_col || ph1.black_row)",
          "2187:   {",
          "2188:     imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height * 2, sizeof(ushort));",
          "2189:     merror(imgdata.rawdata.ph1_cblack, \"phase_one_load_raw_c()\");",
          "2190:     memmove(imgdata.rawdata.ph1_cblack, (ushort *)c_black[0], raw_height * 2 * sizeof(ushort));",
          "2191:     imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width * 2, sizeof(ushort));",
          "2192:     merror(imgdata.rawdata.ph1_rblack, \"phase_one_load_raw_c()\");",
          "2193:     memmove(imgdata.rawdata.ph1_rblack, (ushort *)r_black[0], raw_width * 2 * sizeof(ushort));",
          "2194:   }",
          "2197:   for (i = 0; i < 256; i++)",
          "2198:     curve[i] = i * i / 3.969 + 0.5;",
          "2200:   try",
          "2201:   {",
          "2203:     for (row = 0; row < raw_height; row++)",
          "2204:     {",
          "2206:       checkCancel();",
          "2208:       fseek(ifp, data_offset + offset[row], SEEK_SET);",
          "2209:       ph1_bits(-1);",
          "2210:       pred[0] = pred[1] = 0;",
          "2211:       for (col = 0; col < raw_width; col++)",
          "2212:       {",
          "2213:         if (col >= (raw_width & -8))",
          "2214:           len[0] = len[1] = 14;",
          "2215:         else if ((col & 7) == 0)",
          "2216:           for (i = 0; i < 2; i++)",
          "2217:           {",
          "2218:             for (j = 0; j < 5 && !ph1_bits(1); j++)",
          "2219:               ;",
          "2220:             if (j--)",
          "2221:               len[i] = length[j * 2 + ph1_bits(1)];",
          "2222:           }",
          "2223:         if ((i = len[col & 1]) == 14)",
          "2224:           pixel[col] = pred[col & 1] = ph1_bits(16);",
          "2225:         else",
          "2226:           pixel[col] = pred[col & 1] += ph1_bits(i) + 1 - (1 << (i - 1));",
          "2227:         if (pred[col & 1] >> 16)",
          "2228:           derror();",
          "2229:         if (ph1.format == 5 && pixel[col] < 256)",
          "2230:           pixel[col] = curve[pixel[col]];",
          "2231:       }",
          "2233:       for (col = 0; col < raw_width; col++)",
          "2234:       {",
          "2235:         int shift = ph1.format == 8 ? 0 : 2;",
          "2236:         i = (pixel[col] << shift) - ph1.t_black + c_black[row][col >= ph1.split_col] +",
          "2237:             r_black[col][row >= ph1.split_row];",
          "2238:         if (i > 0)",
          "2239:           RAW(row, col) = i;",
          "2240:       }",
          "2242:     if (ph1.format == 8)",
          "2243:       memmove(&RAW(row, 0), &pixel[0], raw_width * 2);",
          "2245:       for (col = 0; col < raw_width; col++)",
          "2246:         RAW(row, col) = pixel[col] << 2;",
          "2248:     }",
          "2250:   }",
          "2251:   catch (...)",
          "2252:   {",
          "2253:     free(pixel);",
          "2257:   free(pixel);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1999:   unsigned upix, urow, ucol;",
          "2000:   ushort *ip;",
          "2003:   order = 0x4949;",
          "2004:   ph1_bits(-1);",
          "2005: #ifdef LIBRAW_LIBRARY_BUILD",
          "2007: #endif",
          "2014: #ifdef LIBRAW_LIBRARY_BUILD",
          "2016: #endif",
          "2056:     throw;",
          "2057:   }",
          "2058: #endif",
          "2062: }",
          "2065: void CLASS leaf_hdr_load_raw()",
          "2066: {",
          "2073:   }",
          "2074: #ifdef LIBRAW_LIBRARY_BUILD",
          "2076: #endif",
          "2079: #ifdef LIBRAW_LIBRARY_BUILD",
          "2081: #endif",
          "2085:       }",
          "2089:       if (!filters && (row = r - top_margin) < height)",
          "2092:     }",
          "2093: #ifdef LIBRAW_LIBRARY_BUILD",
          "2096:     throw;",
          "2097:   }",
          "2098: #endif",
          "2100:     maximum = 0xffff;",
          "2101:     raw_color = 1;",
          "2103:   }",
          "2104: }",
          "2106: void CLASS unpacked_load_raw()",
          "2107: {",
          "2112:   {",
          "2113: #ifdef LIBRAW_LIBRARY_BUILD",
          "2114:     checkCancel();",
          "2115: #endif",
          "2120:   }",
          "2121: }",
          "2123: void CLASS unpacked_load_raw_reversed()",
          "2124: {",
          "2129: #ifdef LIBRAW_LIBRARY_BUILD",
          "2131: #endif",
          "2138: }",
          "2142: void CLASS sinar_4shot_load_raw()",
          "2143: {",
          "2144:   ushort *pixel;",
          "2145:   unsigned shot, row, col, r, c;",
          "2151:     unpacked_load_raw();",
          "2152:     return;",
          "2153:   }",
          "2156: #ifdef LIBRAW_LIBRARY_BUILD",
          "2158: #endif",
          "2160: #ifdef LIBRAW_LIBRARY_BUILD",
          "2162: #endif",
          "2171:       }",
          "2172:     }",
          "2174: #ifdef LIBRAW_LIBRARY_BUILD",
          "2176:     free(pixel);",
          "2177:     throw;",
          "2178:   }",
          "2179: #endif",
          "2181:   mix_green = 1;",
          "2182: }",
          "",
          "[Removed Lines]",
          "2002:   if (!ljpeg_start (&jh, 0)) return;",
          "2006:   try {",
          "2008:   back[4] = (int *) calloc (raw_width, 3*sizeof **back);",
          "2009:   merror (back[4], \"hasselblad_load_raw()\");",
          "2010:   FORC3 back[c] = back[4] + c*raw_width;",
          "2011:   cblack[6] >>= sh = tiff_samples > 1;",
          "2012:   shot = LIM(shot_select, 1, tiff_samples) - 1;",
          "2013:   for (row=0; row < raw_height; row++) {",
          "2015:     checkCancel();",
          "2017:     FORC4 back[(c+3) & 3] = back[c];",
          "2018:     for (col=0; col < raw_width; col+=2) {",
          "2019:       for (s=0; s < tiff_samples*2; s+=2) {",
          "2020:  FORC(2) len[c] = ph1_huff(jh.huff[0]);",
          "2021:  FORC(2) {",
          "2022:    diff[s+c] = ph1_bits(len[c]);",
          "2023:    if ((diff[s+c] & (1 << (len[c]-1))) == 0)",
          "2024:      diff[s+c] -= (1 << len[c]) - 1;",
          "2025:    if (diff[s+c] == 65535) diff[s+c] = -32768;",
          "2026:  }",
          "2027:       }",
          "2028:       for (s=col; s < col+2; s++) {",
          "2029:  pred = 0x8000 + load_flags;",
          "2030:  if (col) pred = back[2][s-2];",
          "2031:  if (col && row > 1) switch (jh.psv) {",
          "2032:    case 11: pred += back[0][s]/2 - back[0][s-2]/2;  break;",
          "2033:  }",
          "2034:  f = (row & 1)*3 ^ ((col+s) & 1);",
          "2035:  FORC (tiff_samples) {",
          "2036:    pred += diff[(s & 1)*tiff_samples+c];",
          "2037:    upix = pred >> sh & 0xffff;",
          "2038:    if (raw_image && c == shot)",
          "2039:      RAW(row,s) = upix;",
          "2040:    if (image) {",
          "2041:      urow = row-top_margin  + (c & 1);",
          "2042:      ucol = col-left_margin - ((c >> 1) & 1);",
          "2043:      ip = &image[urow*width+ucol][f];",
          "2044:      if (urow < height && ucol < width)",
          "2046:    }",
          "2047:  }",
          "2048:  back[2][s] = pred;",
          "2049:       }",
          "2050:     }",
          "2051:   }",
          "2052: #ifdef LIBRAW_LIBRARY_BUILD",
          "2053:   } catch (...){",
          "2054:     free (back[4]);",
          "2055:     ljpeg_end (&jh);",
          "2059:   free (back[4]);",
          "2060:   ljpeg_end (&jh);",
          "2061:   if (image) mix_green = 1;",
          "2067:   ushort *pixel=0;",
          "2068:   unsigned tile=0, r, c, row, col;",
          "2070:   if (!filters) {",
          "2071:     pixel = (ushort *) calloc (raw_width, sizeof *pixel);",
          "2072:     merror (pixel, \"leaf_hdr_load_raw()\");",
          "2075:   try {",
          "2077:   FORC(tiff_samples)",
          "2078:     for (r=0; r < raw_height; r++) {",
          "2080:     checkCancel();",
          "2082:       if (r % tile_length == 0) {",
          "2083:  fseek (ifp, data_offset + 4*tile++, SEEK_SET);",
          "2084:  fseek (ifp, get4(), SEEK_SET);",
          "2086:       if (filters && c != shot_select) continue;",
          "2087:       if (filters) pixel = raw_image + r*raw_width;",
          "2088:       read_shorts (pixel, raw_width);",
          "2090:  for (col=0; col < width; col++)",
          "2091:    image[row*width+col][c] = pixel[col+left_margin];",
          "2094:   } catch (...) {",
          "2095:     if(!filters) free(pixel);",
          "2099:   if (!filters) {",
          "2102:     free (pixel);",
          "2108:   int row, col, bits=0;",
          "2109:   while (1 << ++bits < maximum);",
          "2110:   read_shorts (raw_image, raw_width*raw_height);",
          "2111:   for (row=0; row < raw_height; row++)",
          "2116:     for (col=0; col < raw_width; col++)",
          "2117:       if ((RAW(row,col) >>= load_flags) >> bits",
          "2118:  && (unsigned) (row-top_margin) < height",
          "2119:  && (unsigned) (col-left_margin) < width) derror();",
          "2125:     int row, col, bits=0;",
          "2126:     while (1 << ++bits < maximum);",
          "2127:     for (row=raw_height-1; row >= 0; row--)",
          "2128:     {",
          "2130:  checkCancel();",
          "2132:  read_shorts (&raw_image[row*raw_width], raw_width);",
          "2133:  for (col=0; col < raw_width; col++)",
          "2134:   if ((RAW(row,col) >>= load_flags) >> bits",
          "2135:    && (unsigned) (row-top_margin) < height",
          "2136:    && (unsigned) (col-left_margin) < width) derror();",
          "2137:     }",
          "2147:   if (raw_image) {",
          "2148:     shot = LIM (shot_select, 1, 4) - 1;",
          "2149:     fseek (ifp, data_offset + shot*4, SEEK_SET);",
          "2150:     fseek (ifp, get4(), SEEK_SET);",
          "2154:   pixel = (ushort *) calloc (raw_width, sizeof *pixel);",
          "2155:   merror (pixel, \"sinar_4shot_load_raw()\");",
          "2157:   try {",
          "2159:   for (shot=0; shot < 4; shot++) {",
          "2161:     checkCancel();",
          "2163:     fseek (ifp, data_offset + shot*4, SEEK_SET);",
          "2164:     fseek (ifp, get4(), SEEK_SET);",
          "2165:     for (row=0; row < raw_height; row++) {",
          "2166:       read_shorts (pixel, raw_width);",
          "2167:       if ((r = row-top_margin - (shot >> 1 & 1)) >= height) continue;",
          "2168:       for (col=0; col < raw_width; col++) {",
          "2169:  if ((c = col-left_margin - (shot & 1)) >= width) continue;",
          "2170:  image[r*width+c][(row & 1)*3 ^ (~col & 1)] = pixel[col];",
          "2173:   }",
          "2175:   } catch (...) {",
          "2180:   free (pixel);",
          "",
          "[Added Lines]",
          "2268:   if (!ljpeg_start(&jh, 0))",
          "2269:     return;",
          "2273:   try",
          "2274:   {",
          "2276:     back[4] = (int *)calloc(raw_width, 3 * sizeof **back);",
          "2277:     merror(back[4], \"hasselblad_load_raw()\");",
          "2278:     FORC3 back[c] = back[4] + c * raw_width;",
          "2279:     cblack[6] >>= sh = tiff_samples > 1;",
          "2280:     shot = LIM(shot_select, 1, tiff_samples) - 1;",
          "2281:     for (row = 0; row < raw_height; row++)",
          "2282:     {",
          "2284:       checkCancel();",
          "2286:       FORC4 back[(c + 3) & 3] = back[c];",
          "2287:       for (col = 0; col < raw_width; col += 2)",
          "2288:       {",
          "2289:         for (s = 0; s < tiff_samples * 2; s += 2)",
          "2290:         {",
          "2291:           FORC(2) len[c] = ph1_huff(jh.huff[0]);",
          "2292:           FORC(2)",
          "2293:           {",
          "2294:             diff[s + c] = ph1_bits(len[c]);",
          "2295:             if ((diff[s + c] & (1 << (len[c] - 1))) == 0)",
          "2296:               diff[s + c] -= (1 << len[c]) - 1;",
          "2297:             if (diff[s + c] == 65535)",
          "2298:               diff[s + c] = -32768;",
          "2299:           }",
          "2300:         }",
          "2301:         for (s = col; s < col + 2; s++)",
          "2302:         {",
          "2303:           pred = 0x8000 + load_flags;",
          "2304:           if (col)",
          "2305:             pred = back[2][s - 2];",
          "2306:           if (col && row > 1)",
          "2307:             switch (jh.psv)",
          "2308:             {",
          "2309:             case 11:",
          "2310:               pred += back[0][s] / 2 - back[0][s - 2] / 2;",
          "2311:               break;",
          "2312:             }",
          "2313:           f = (row & 1) * 3 ^ ((col + s) & 1);",
          "2314:           FORC(tiff_samples)",
          "2315:           {",
          "2316:             pred += diff[(s & 1) * tiff_samples + c];",
          "2317:             upix = pred >> sh & 0xffff;",
          "2318:             if (raw_image && c == shot)",
          "2319:               RAW(row, s) = upix;",
          "2320:             if (image)",
          "2321:             {",
          "2322:               urow = row - top_margin + (c & 1);",
          "2323:               ucol = col - left_margin - ((c >> 1) & 1);",
          "2324:               ip = &image[urow * width + ucol][f];",
          "2325:               if (urow < height && ucol < width)",
          "2327:             }",
          "2328:           }",
          "2329:           back[2][s] = pred;",
          "2330:         }",
          "2331:       }",
          "2332:     }",
          "2333: #ifdef LIBRAW_LIBRARY_BUILD",
          "2334:   }",
          "2335:   catch (...)",
          "2336:   {",
          "2337:     free(back[4]);",
          "2338:     ljpeg_end(&jh);",
          "2342:   free(back[4]);",
          "2343:   ljpeg_end(&jh);",
          "2344:   if (image)",
          "2345:     mix_green = 1;",
          "2350:   ushort *pixel = 0;",
          "2351:   unsigned tile = 0, r, c, row, col;",
          "2353:   if (!filters)",
          "2354:   {",
          "2355:     pixel = (ushort *)calloc(raw_width, sizeof *pixel);",
          "2356:     merror(pixel, \"leaf_hdr_load_raw()\");",
          "2359:   try",
          "2360:   {",
          "2362:     FORC(tiff_samples)",
          "2363:     for (r = 0; r < raw_height; r++)",
          "2364:     {",
          "2366:       checkCancel();",
          "2368:       if (r % tile_length == 0)",
          "2369:       {",
          "2370:         fseek(ifp, data_offset + 4 * tile++, SEEK_SET);",
          "2371:         fseek(ifp, get4(), SEEK_SET);",
          "2373:       if (filters && c != shot_select)",
          "2374:         continue;",
          "2375:       if (filters)",
          "2376:         pixel = raw_image + r * raw_width;",
          "2377:       read_shorts(pixel, raw_width);",
          "2379:         for (col = 0; col < width; col++)",
          "2380:           image[row * width + col][c] = pixel[col + left_margin];",
          "2383:   }",
          "2384:   catch (...)",
          "2385:   {",
          "2386:     if (!filters)",
          "2387:       free(pixel);",
          "2391:   if (!filters)",
          "2392:   {",
          "2395:     free(pixel);",
          "2401:   int row, col, bits = 0;",
          "2402:   while (1 << ++bits < maximum)",
          "2403:     ;",
          "2404:   read_shorts(raw_image, raw_width * raw_height);",
          "2405:   for (row = 0; row < raw_height; row++)",
          "2410:     for (col = 0; col < raw_width; col++)",
          "2411:       if ((RAW(row, col) >>= load_flags) >> bits && (unsigned)(row - top_margin) < height &&",
          "2412:           (unsigned)(col - left_margin) < width)",
          "2413:         derror();",
          "2419:   int row, col, bits = 0;",
          "2420:   while (1 << ++bits < maximum)",
          "2421:     ;",
          "2422:   for (row = raw_height - 1; row >= 0; row--)",
          "2423:   {",
          "2425:     checkCancel();",
          "2427:     read_shorts(&raw_image[row * raw_width], raw_width);",
          "2428:     for (col = 0; col < raw_width; col++)",
          "2429:       if ((RAW(row, col) >>= load_flags) >> bits && (unsigned)(row - top_margin) < height &&",
          "2430:           (unsigned)(col - left_margin) < width)",
          "2431:         derror();",
          "2432:   }",
          "2440:   if (raw_image)",
          "2441:   {",
          "2442:     shot = LIM(shot_select, 1, 4) - 1;",
          "2443:     fseek(ifp, data_offset + shot * 4, SEEK_SET);",
          "2444:     fseek(ifp, get4(), SEEK_SET);",
          "2448:   pixel = (ushort *)calloc(raw_width, sizeof *pixel);",
          "2449:   merror(pixel, \"sinar_4shot_load_raw()\");",
          "2451:   try",
          "2452:   {",
          "2454:     for (shot = 0; shot < 4; shot++)",
          "2455:     {",
          "2457:       checkCancel();",
          "2459:       fseek(ifp, data_offset + shot * 4, SEEK_SET);",
          "2460:       fseek(ifp, get4(), SEEK_SET);",
          "2461:       for (row = 0; row < raw_height; row++)",
          "2462:       {",
          "2463:         read_shorts(pixel, raw_width);",
          "2464:         if ((r = row - top_margin - (shot >> 1 & 1)) >= height)",
          "2465:           continue;",
          "2466:         for (col = 0; col < raw_width; col++)",
          "2467:         {",
          "2468:           if ((c = col - left_margin - (shot & 1)) >= width)",
          "2469:             continue;",
          "2470:           image[r * width + c][(row & 1) * 3 ^ (~col & 1)] = pixel[col];",
          "2471:         }",
          "2475:   }",
          "2476:   catch (...)",
          "2477:   {",
          "2482:   free(pixel);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2185: {",
          "2186:   int row, col;",
          "2190: #ifdef LIBRAW_LIBRARY_BUILD",
          "2193: #endif",
          "2196:   {",
          "2197: #ifdef LIBRAW_LIBRARY_BUILD",
          "2198:     checkCancel();",
          "2208: #else",
          "2211: #endif",
          "2212:   }",
          "2213: #ifdef LIBRAW_LIBRARY_BUILD",
          "",
          "[Removed Lines]",
          "2188:   if (!image) return;",
          "2191:   unsigned short *buf = (unsigned short *)malloc(width*3*sizeof(unsigned short));",
          "2192:   merror(buf,\"imacon_full_load_raw\");",
          "2195:   for (row=0; row < height; row++)",
          "2199:     read_shorts(buf,width*3);",
          "2200:     unsigned short (*rowp)[4] = &image[row*width];",
          "2201:     for (col=0; col < width; col++)",
          "2202:       {",
          "2203:         rowp[col][0]=buf[col*3];",
          "2204:         rowp[col][1]=buf[col*3+1];",
          "2205:         rowp[col][2]=buf[col*3+2];",
          "2206:         rowp[col][3]=0;",
          "2207:       }",
          "2209:     for (col=0; col < width; col++)",
          "2210:       read_shorts (image[row*width+col], 3);",
          "",
          "[Added Lines]",
          "2490:   if (!image)",
          "2491:     return;",
          "2494:   unsigned short *buf = (unsigned short *)malloc(width * 3 * sizeof(unsigned short));",
          "2495:   merror(buf, \"imacon_full_load_raw\");",
          "2498:   for (row = 0; row < height; row++)",
          "2502:     read_shorts(buf, width * 3);",
          "2503:     unsigned short(*rowp)[4] = &image[row * width];",
          "2504:     for (col = 0; col < width; col++)",
          "2505:     {",
          "2506:       rowp[col][0] = buf[col * 3];",
          "2507:       rowp[col][1] = buf[col * 3 + 1];",
          "2508:       rowp[col][2] = buf[col * 3 + 2];",
          "2509:       rowp[col][3] = 0;",
          "2510:     }",
          "2512:     for (col = 0; col < width; col++)",
          "2513:       read_shorts(image[row * width + col], 3);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2218: void CLASS packed_load_raw()",
          "2219: {",
          "2223:   bwide = raw_width * tiff_bps / 8;",
          "2224:   bwide += bwide & load_flags >> 7;",
          "2225:   rbits = bwide * 8 - raw_width * tiff_bps;",
          "2227:   bite = 8 + (load_flags & 24);",
          "2230: #ifdef LIBRAW_LIBRARY_BUILD",
          "2231:     checkCancel();",
          "2232: #endif",
          "2233:     row = irow;",
          "2254:     }",
          "2255:     vbits -= rbits;",
          "2256:   }",
          "",
          "[Removed Lines]",
          "2220:   int vbits=0, bwide, rbits, bite, half, irow, row, col, val, i;",
          "2221:   UINT64 bitbuf=0;",
          "2226:   if (load_flags & 1) bwide = bwide * 16 / 15;",
          "2228:   half = (raw_height+1) >> 1;",
          "2229:   for (irow=0; irow < raw_height; irow++) {",
          "2234:     if (load_flags & 2 &&",
          "2235:  (row = irow % half * 2 + irow / half) == 1 &&",
          "2236:  load_flags & 4) {",
          "2237:       if (vbits=0, tiff_compress)",
          "2238:  fseek (ifp, data_offset - (-half*bwide & -2048), SEEK_SET);",
          "2239:       else {",
          "2240:  fseek (ifp, 0, SEEK_END);",
          "2241:  fseek (ifp, ftell(ifp) >> 3 << 2, SEEK_SET);",
          "2242:       }",
          "2243:     }",
          "2244:     for (col=0; col < raw_width; col++) {",
          "2245:       for (vbits -= tiff_bps; vbits < 0; vbits += bite) {",
          "2246:  bitbuf <<= bite;",
          "2247:  for (i=0; i < bite; i+=8)",
          "2248:    bitbuf |= (unsigned) (fgetc(ifp) << i);",
          "2249:       }",
          "2250:       val = bitbuf << (64-tiff_bps-vbits) >> (64-tiff_bps);",
          "2251:       RAW(row,col ^ (load_flags >> 6 & 1)) = val;",
          "2252:       if (load_flags & 1 && (col % 10) == 9 && fgetc(ifp) &&",
          "2253:  row < height+top_margin && col < width+left_margin) derror();",
          "",
          "[Added Lines]",
          "2523:   int vbits = 0, bwide, rbits, bite, half, irow, row, col, val, i;",
          "2524:   UINT64 bitbuf = 0;",
          "2529:   if (load_flags & 1)",
          "2530:     bwide = bwide * 16 / 15;",
          "2532:   half = (raw_height + 1) >> 1;",
          "2533:   for (irow = 0; irow < raw_height; irow++)",
          "2534:   {",
          "2539:     if (load_flags & 2 && (row = irow % half * 2 + irow / half) == 1 && load_flags & 4)",
          "2540:     {",
          "2541:       if (vbits = 0, tiff_compress)",
          "2542:         fseek(ifp, data_offset - (-half * bwide & -2048), SEEK_SET);",
          "2543:       else",
          "2544:       {",
          "2545:         fseek(ifp, 0, SEEK_END);",
          "2546:         fseek(ifp, ftell(ifp) >> 3 << 2, SEEK_SET);",
          "2547:       }",
          "2548:     }",
          "2549:     for (col = 0; col < raw_width; col++)",
          "2550:     {",
          "2551:       for (vbits -= tiff_bps; vbits < 0; vbits += bite)",
          "2552:       {",
          "2553:         bitbuf <<= bite;",
          "2554:         for (i = 0; i < bite; i += 8)",
          "2555:           bitbuf |= (unsigned)(fgetc(ifp) << i);",
          "2556:       }",
          "2557:       val = bitbuf << (64 - tiff_bps - vbits) >> (64 - tiff_bps);",
          "2558:       RAW(row, col ^ (load_flags >> 6 & 1)) = val;",
          "2559:       if (load_flags & 1 && (col % 10) == 9 && fgetc(ifp) && row < height + top_margin && col < width + left_margin)",
          "2560:         derror();",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "2261: ushort raw_stride;",
          "2267:     uint8_t umode[32];",
          "2268:     uint16_t uwidth;",
          "2269:     uint16_t uheight;",
          "",
          "[Removed Lines]",
          "2263: void CLASS parse_broadcom () {",
          "2266:   struct {",
          "",
          "[Added Lines]",
          "2570: void CLASS parse_broadcom()",
          "2571: {",
          "2574:   struct",
          "2575:   {",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "2277:   } header;",
          "2279:   header.bayer_order = 0;",
          "2283:   raw_width = width = header.uwidth;",
          "2284:   raw_height = height = header.uheight;",
          "2297:   }",
          "2298: }",
          "2302:   uchar *data, *dp;",
          "2303:   int rev, row, col, c;",
          "2305:   rev = 3 * (order == 0x4949);",
          "2314:   }",
          "2316: }",
          "2317: #endif",
          "2319: void CLASS nokia_load_raw()",
          "2320: {",
          "2322:   int rev, dwide, row, col, c;",
          "2325:   rev = 3 * (order == 0x4949);",
          "2326:   dwide = (raw_width * 5 + 1) / 4;",
          "2329: #ifdef LIBRAW_LIBRARY_BUILD",
          "2331: #endif",
          "2333: #ifdef LIBRAW_LIBRARY_BUILD",
          "2335: #endif",
          "2341: #ifdef LIBRAW_LIBRARY_BUILD",
          "2344:     throw;",
          "2345:   }",
          "2346: #endif",
          "2348:   maximum = 0x3ff;",
          "2354:   }",
          "2356: }",
          "2358: void CLASS android_tight_load_raw()",
          "",
          "[Removed Lines]",
          "2280:   fseek (ifp, 0xb0 - 0x20, SEEK_CUR);",
          "2281:   fread (&header, 1, sizeof(header), ifp);",
          "2282:   raw_stride = ((((((header.uwidth + header.padding_right)*5)+3)>>2) + 0x1f)&(~0x1f));",
          "2287:   switch (header.bayer_order) {",
          "2289:       filters = 0x94949494;",
          "2290:       break;",
          "2292:       filters = 0x49494949;",
          "2293:       break;",
          "2295:       filters = 0x61616161;",
          "2296:       break;",
          "2300: void CLASS broadcom_load_raw() {",
          "2306:   data = (uchar *) malloc (raw_stride*2);",
          "2307:   merror (data, \"broadcom_load_raw()\");",
          "2309:   for (row=0; row < raw_height; row++) {",
          "2310:     if (fread (data+raw_stride, 1, raw_stride, ifp) < raw_stride) derror();",
          "2311:     FORC(raw_stride) data[c] = data[raw_stride+(c ^ rev)];",
          "2312:     for (dp=data, col=0; col < raw_width; dp+=5, col+=4)",
          "2313:       FORC4 RAW(row,col+c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);",
          "2315:   free (data);",
          "2321:   uchar  *data,  *dp;",
          "2323:   double sum[]={0,0};",
          "2327:   data = (uchar *) malloc (dwide*2);",
          "2328:   merror (data, \"nokia_load_raw()\");",
          "2330:   try {",
          "2332:   for (row=0; row < raw_height; row++) {",
          "2334:     checkCancel();",
          "2336:     if (fread (data+dwide, 1, dwide, ifp) < dwide) derror();",
          "2337:     FORC(dwide) data[c] = data[dwide+(c ^ rev)];",
          "2338:     for (dp=data, col=0; col < raw_width; dp+=5, col+=4)",
          "2339:       FORC4 RAW(row,col+c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);",
          "2340:   }",
          "2342:   } catch (...){",
          "2343:     free (data);",
          "2347:   free (data);",
          "2349:   if (strncmp(make,\"OmniVision\",10)) return;",
          "2350:   row = raw_height/2;",
          "2351:   FORC(width-1) {",
          "2352:     sum[ c & 1] += SQR(RAW(row,c)-RAW(row+1,c+1));",
          "2353:     sum[~c & 1] += SQR(RAW(row+1,c)-RAW(row,c+1));",
          "2355:   if (sum[1] > sum[0]) filters = 0x4b4b4b4b;",
          "",
          "[Added Lines]",
          "2589:   fseek(ifp, 0xb0 - 0x20, SEEK_CUR);",
          "2590:   fread(&header, 1, sizeof(header), ifp);",
          "2591:   raw_stride = ((((((header.uwidth + header.padding_right) * 5) + 3) >> 2) + 0x1f) & (~0x1f));",
          "2596:   switch (header.bayer_order)",
          "2597:   {",
          "2599:     filters = 0x94949494;",
          "2600:     break;",
          "2602:     filters = 0x49494949;",
          "2603:     break;",
          "2605:     filters = 0x61616161;",
          "2606:     break;",
          "2610: void CLASS broadcom_load_raw()",
          "2611: {",
          "2617:   data = (uchar *)malloc(raw_stride * 2);",
          "2618:   merror(data, \"broadcom_load_raw()\");",
          "2620:   for (row = 0; row < raw_height; row++)",
          "2621:   {",
          "2622:     if (fread(data + raw_stride, 1, raw_stride, ifp) < raw_stride)",
          "2623:       derror();",
          "2624:     FORC(raw_stride) data[c] = data[raw_stride + (c ^ rev)];",
          "2625:     for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)",
          "2626:       FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);",
          "2628:   free(data);",
          "2634:   uchar *data, *dp;",
          "2636:   double sum[] = {0, 0};",
          "2640:   data = (uchar *)malloc(dwide * 2);",
          "2641:   merror(data, \"nokia_load_raw()\");",
          "2643:   try",
          "2644:   {",
          "2646:     for (row = 0; row < raw_height; row++)",
          "2647:     {",
          "2649:       checkCancel();",
          "2651:       if (fread(data + dwide, 1, dwide, ifp) < dwide)",
          "2652:         derror();",
          "2653:       FORC(dwide) data[c] = data[dwide + (c ^ rev)];",
          "2654:       for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)",
          "2655:         FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);",
          "2656:     }",
          "2658:   }",
          "2659:   catch (...)",
          "2660:   {",
          "2661:     free(data);",
          "2665:   free(data);",
          "2667:   if (strncmp(make, \"OmniVision\", 10))",
          "2668:     return;",
          "2669:   row = raw_height / 2;",
          "2670:   FORC(width - 1)",
          "2671:   {",
          "2672:     sum[c & 1] += SQR(RAW(row, c) - RAW(row + 1, c + 1));",
          "2673:     sum[~c & 1] += SQR(RAW(row + 1, c) - RAW(row, c + 1));",
          "2675:   if (sum[1] > sum[0])",
          "2676:     filters = 0x4b4b4b4b;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "2360:   uchar *data, *dp;",
          "2361:   int bwide, row, col, c;",
          "2372: }",
          "2374: void CLASS android_loose_load_raw()",
          "2375: {",
          "2376:   uchar *data, *dp;",
          "2377:   int bwide, row, col, c;",
          "2388:     }",
          "2389:   }",
          "2391: }",
          "2393: void CLASS canon_rmf_load_raw()",
          "",
          "[Removed Lines]",
          "2363:   bwide = -(-5*raw_width >> 5) << 3;",
          "2364:   data = (uchar *) malloc (bwide);",
          "2365:   merror (data, \"android_tight_load_raw()\");",
          "2366:   for (row=0; row < raw_height; row++) {",
          "2367:     if (fread (data, 1, bwide, ifp) < bwide) derror();",
          "2368:     for (dp=data, col=0; col < raw_width; dp+=5, col+=4)",
          "2369:       FORC4 RAW(row,col+c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);",
          "2370: }",
          "2371:   free (data);",
          "2378:   UINT64 bitbuf=0;",
          "2380:   bwide = (raw_width+5)/6 << 3;",
          "2381:   data = (uchar *) malloc (bwide);",
          "2382:   merror (data, \"android_loose_load_raw()\");",
          "2383:   for (row=0; row < raw_height; row++) {",
          "2384:     if (fread (data, 1, bwide, ifp) < bwide) derror();",
          "2385:     for (dp=data, col=0; col < raw_width; dp+=8, col+=6) {",
          "2386:       FORC(8) bitbuf = (bitbuf << 8) | dp[c^7];",
          "2387:       FORC(6) RAW(row,col+c) = (bitbuf >> c*10) & 0x3ff;",
          "2390:   free (data);",
          "",
          "[Added Lines]",
          "2684:   bwide = -(-5 * raw_width >> 5) << 3;",
          "2685:   data = (uchar *)malloc(bwide);",
          "2686:   merror(data, \"android_tight_load_raw()\");",
          "2687:   for (row = 0; row < raw_height; row++)",
          "2688:   {",
          "2689:     if (fread(data, 1, bwide, ifp) < bwide)",
          "2690:       derror();",
          "2691:     for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)",
          "2692:       FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);",
          "2693:   }",
          "2694:   free(data);",
          "2701:   UINT64 bitbuf = 0;",
          "2703:   bwide = (raw_width + 5) / 6 << 3;",
          "2704:   data = (uchar *)malloc(bwide);",
          "2705:   merror(data, \"android_loose_load_raw()\");",
          "2706:   for (row = 0; row < raw_height; row++)",
          "2707:   {",
          "2708:     if (fread(data, 1, bwide, ifp) < bwide)",
          "2709:       derror();",
          "2710:     for (dp = data, col = 0; col < raw_width; dp += 8, col += 6)",
          "2711:     {",
          "2712:       FORC(8) bitbuf = (bitbuf << 8) | dp[c ^ 7];",
          "2713:       FORC(6) RAW(row, col + c) = (bitbuf >> c * 10) & 0x3ff;",
          "2716:   free(data);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "2395:   int row, col, bits, orow, ocol, c;",
          "2397: #ifdef LIBRAW_LIBRARY_BUILD",
          "2400: #endif",
          "2402:   {",
          "2403: #ifdef LIBRAW_LIBRARY_BUILD",
          "2404:     checkCancel();",
          "2407:       {",
          "2418:         }",
          "2419:       }",
          "2420: #else",
          "2422:       bits = get4();",
          "2431:       }",
          "2432:     }",
          "2433: #endif",
          "",
          "[Removed Lines]",
          "2398:   int *words = (int*)malloc(sizeof(int)*(raw_width/3+1));",
          "2399:   merror(words,\"canon_rmf_load_raw\");",
          "2401:   for (row=0; row < raw_height; row++)",
          "2405:     fread(words,sizeof(int),raw_width/3,ifp);",
          "2406:     for (col=0; col < raw_width-2; col+=3)",
          "2408:         bits = words[col/3];",
          "2409:         FORC3 {",
          "2410:           orow = row;",
          "2411:           if ((ocol = col+c-4) < 0)",
          "2412:             {",
          "2413:               ocol += raw_width;",
          "2414:               if ((orow -= 2) < 0)",
          "2415:                 orow += raw_height;",
          "2416:             }",
          "2417:           RAW(orow,ocol) = curve[bits >> (10*c+2) & 0x3ff];",
          "2421:     for (col=0; col < raw_width-2; col+=3) {",
          "2423:       FORC3 {",
          "2424:  orow = row;",
          "2425:  if ((ocol = col+c-4) < 0) {",
          "2426:    ocol += raw_width;",
          "2427:    if ((orow -= 2) < 0)",
          "2428:      orow += raw_height;",
          "2429:  }",
          "2430:  RAW(orow,ocol) = curve[bits >> (10*c+2) & 0x3ff];",
          "",
          "[Added Lines]",
          "2724:   int *words = (int *)malloc(sizeof(int) * (raw_width / 3 + 1));",
          "2725:   merror(words, \"canon_rmf_load_raw\");",
          "2727:   for (row = 0; row < raw_height; row++)",
          "2731:     fread(words, sizeof(int), raw_width / 3, ifp);",
          "2732:     for (col = 0; col < raw_width - 2; col += 3)",
          "2733:     {",
          "2734:       bits = words[col / 3];",
          "2735:       FORC3",
          "2737:         orow = row;",
          "2738:         if ((ocol = col + c - 4) < 0)",
          "2739:         {",
          "2740:           ocol += raw_width;",
          "2741:           if ((orow -= 2) < 0)",
          "2742:             orow += raw_height;",
          "2744:         RAW(orow, ocol) = curve[bits >> (10 * c + 2) & 0x3ff];",
          "2746:     }",
          "2748:     for (col = 0; col < raw_width - 2; col += 3)",
          "2749:     {",
          "2751:       FORC3",
          "2752:       {",
          "2753:         orow = row;",
          "2754:         if ((ocol = col + c - 4) < 0)",
          "2755:         {",
          "2756:           ocol += raw_width;",
          "2757:           if ((orow -= 2) < 0)",
          "2758:             orow += raw_height;",
          "2759:         }",
          "2760:         RAW(orow, ocol) = curve[bits >> (10 * c + 2) & 0x3ff];",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "2438:   maximum = curve[0x3ff];",
          "2439: }",
          "2442: {",
          "2443: #ifndef LIBRAW_NOTHREADS",
          "2444: #define buf tls->pana_bits.buf",
          "",
          "[Removed Lines]",
          "2441: unsigned CLASS pana_bits (int nbits)",
          "",
          "[Added Lines]",
          "2771: unsigned CLASS pana_bits(int nbits)",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "2449: #endif",
          "2450:   int byte;",
          "2456:   }",
          "2457:   vbits = (vbits - nbits) & 0x1ffff;",
          "2458:   byte = vbits >> 3 ^ 0x3ff0;",
          "2460: #ifndef LIBRAW_NOTHREADS",
          "2461: #undef buf",
          "2462: #undef vbits",
          "",
          "[Removed Lines]",
          "2452:   if (!nbits) return vbits=0;",
          "2453:   if (!vbits) {",
          "2454:     fread (buf+load_flags, 1, 0x4000-load_flags, ifp);",
          "2455:     fread (buf, 1, load_flags, ifp);",
          "2459:   return (buf[byte] | buf[byte+1] << 8) >> (vbits & 7) & ~((~0u) << nbits);",
          "",
          "[Added Lines]",
          "2782:   if (!nbits)",
          "2783:     return vbits = 0;",
          "2784:   if (!vbits)",
          "2785:   {",
          "2786:     fread(buf + load_flags, 1, 0x4000 - load_flags, ifp);",
          "2787:     fread(buf, 1, load_flags, ifp);",
          "2791:   return (buf[byte] | buf[byte + 1] << 8) >> (vbits & 7) & ~((~0u) << nbits);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "2466: void CLASS panasonic_load_raw()",
          "2467: {",
          "2470:   pana_bits(0);",
          "2472:   {",
          "2473: #ifdef LIBRAW_LIBRARY_BUILD",
          "2474:     checkCancel();",
          "2475: #endif",
          "2477:       if ((i = col % 14) == 0)",
          "2483:             pred[i & 1] &= ~((~0u) << sh);",
          "2489:     }",
          "2490:   }",
          "2491: }",
          "",
          "[Removed Lines]",
          "2468:   int row, col, i, j, sh=0, pred[2], nonz[2];",
          "2471:   for (row=0; row < height; row++)",
          "2476:     for (col=0; col < raw_width; col++) {",
          "2478:  pred[0] = pred[1] = nonz[0] = nonz[1] = 0;",
          "2479:       if (i % 3 == 2) sh = 4 >> (3 - pana_bits(2));",
          "2480:       if (nonz[i & 1]) {",
          "2481:  if ((j = pana_bits(8))) {",
          "2482:    if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)",
          "2484:    pred[i & 1] += j << sh;",
          "2485:  }",
          "2486:       } else if ((nonz[i & 1] = pana_bits(8)) || i > 11)",
          "2487:  pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);",
          "2488:       if ((RAW(row,col) = pred[col & 1]) > 4098 && col < width) derror();",
          "",
          "[Added Lines]",
          "2800:   int row, col, i, j, sh = 0, pred[2], nonz[2];",
          "2803:   for (row = 0; row < height; row++)",
          "2808:     for (col = 0; col < raw_width; col++)",
          "2809:     {",
          "2811:         pred[0] = pred[1] = nonz[0] = nonz[1] = 0;",
          "2812:       if (i % 3 == 2)",
          "2813:         sh = 4 >> (3 - pana_bits(2));",
          "2814:       if (nonz[i & 1])",
          "2815:       {",
          "2816:         if ((j = pana_bits(8)))",
          "2817:         {",
          "2818:           if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)",
          "2820:           pred[i & 1] += j << sh;",
          "2821:         }",
          "2822:       }",
          "2823:       else if ((nonz[i & 1] = pana_bits(8)) || i > 11)",
          "2824:         pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);",
          "2825:       if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)",
          "2826:         derror();",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "2496:   int row, col, nbits, sign, low, high, i, c, w, n, nw;",
          "2497:   int acarry[2][3], *carry, pred, diff;",
          "2503:   getbits(-1);",
          "2505: #ifdef LIBRAW_LIBRARY_BUILD",
          "2506:     checkCancel();",
          "2507: #endif",
          "2510:       carry = acarry[col & 1];",
          "2511:       i = 2 * (carry[2] < 3);",
          "2513:       low = (sign = getbits(3)) & 3;",
          "2514:       sign = sign << 29 >> 31;",
          "2517:       carry[0] = (high << nbits) | getbits(nbits);",
          "2518:       diff = (carry[0] ^ sign) + carry[1];",
          "2534:       }",
          "2536:     }",
          "2537:   }",
          "2538: }",
          "",
          "[Removed Lines]",
          "2499:   huff[n=0] = 0xc0c;",
          "2500:   for (i=12; i--; )",
          "2501:     FORC(2048 >> i) huff[++n] = (i+1) << 8 | i;",
          "2502:   fseek (ifp, 7, SEEK_CUR);",
          "2504:   for (row=0; row < height; row++) {",
          "2508:     memset (acarry, 0, sizeof acarry);",
          "2509:     for (col=0; col < raw_width; col++) {",
          "2512:       for (nbits=2+i; (ushort) carry[0] >> (nbits+i); nbits++);",
          "2515:       if ((high = getbithuff(12,huff)) == 12)",
          "2516:  high = getbits(16-nbits) >> 1;",
          "2519:       carry[1] = (diff*3 + carry[1]) >> 5;",
          "2520:       carry[2] = carry[0] > 16 ? 0 : carry[2]+1;",
          "2521:       if (col >= width) continue;",
          "2522:       if (row < 2 && col < 2) pred = 0;",
          "2523:       else if (row < 2) pred = RAW(row,col-2);",
          "2524:       else if (col < 2) pred = RAW(row-2,col);",
          "2525:       else {",
          "2526:  w  = RAW(row,col-2);",
          "2527:  n  = RAW(row-2,col);",
          "2528:  nw = RAW(row-2,col-2);",
          "2529:  if ((w < nw && nw < n) || (n < nw && nw < w)) {",
          "2530:    if (ABS(w-nw) > 32 || ABS(n-nw) > 32)",
          "2531:      pred = w + n - nw;",
          "2532:    else pred = (w + n) >> 1;",
          "2533:  } else pred = ABS(w-nw) > ABS(n-nw) ? w : n;",
          "2535:       if ((RAW(row,col) = pred + ((diff << 2) | low)) >> 12) derror();",
          "",
          "[Added Lines]",
          "2837:   huff[n = 0] = 0xc0c;",
          "2838:   for (i = 12; i--;)",
          "2839:     FORC(2048 >> i) huff[++n] = (i + 1) << 8 | i;",
          "2840:   fseek(ifp, 7, SEEK_CUR);",
          "2842:   for (row = 0; row < height; row++)",
          "2843:   {",
          "2847:     memset(acarry, 0, sizeof acarry);",
          "2848:     for (col = 0; col < raw_width; col++)",
          "2849:     {",
          "2852:       for (nbits = 2 + i; (ushort)carry[0] >> (nbits + i); nbits++)",
          "2853:         ;",
          "2856:       if ((high = getbithuff(12, huff)) == 12)",
          "2857:         high = getbits(16 - nbits) >> 1;",
          "2860:       carry[1] = (diff * 3 + carry[1]) >> 5;",
          "2861:       carry[2] = carry[0] > 16 ? 0 : carry[2] + 1;",
          "2862:       if (col >= width)",
          "2863:         continue;",
          "2864:       if (row < 2 && col < 2)",
          "2865:         pred = 0;",
          "2866:       else if (row < 2)",
          "2867:         pred = RAW(row, col - 2);",
          "2868:       else if (col < 2)",
          "2869:         pred = RAW(row - 2, col);",
          "2870:       else",
          "2871:       {",
          "2872:         w = RAW(row, col - 2);",
          "2873:         n = RAW(row - 2, col);",
          "2874:         nw = RAW(row - 2, col - 2);",
          "2875:         if ((w < nw && nw < n) || (n < nw && nw < w))",
          "2876:         {",
          "2877:           if (ABS(w - nw) > 32 || ABS(n - nw) > 32)",
          "2878:             pred = w + n - nw;",
          "2879:           else",
          "2880:             pred = (w + n) >> 1;",
          "2881:         }",
          "2882:         else",
          "2883:           pred = ABS(w - nw) > ABS(n - nw) ? w : n;",
          "2885:       if ((RAW(row, col) = pred + ((diff << 2) | low)) >> 12)",
          "2886:         derror();",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "2542:   uchar pixel[768];",
          "2543:   unsigned irow, box, row, col;",
          "2546: #ifdef LIBRAW_LIBRARY_BUILD",
          "2547:     checkCancel();",
          "2548: #endif",
          "2550:     box = irow / 82;",
          "2567:   }",
          "2568:   maximum = 0xff << 1;",
          "2569: }",
          "",
          "[Removed Lines]",
          "2545:   for (irow=0; irow < 1481; irow++) {",
          "2549:     if (fread (pixel, 1, 768, ifp) < 768) derror();",
          "2551:     row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box-12)*2);",
          "2552:     switch (irow) {",
          "2553:       case 1477: case 1479: continue;",
          "2554:       case 1476: row = 984; break;",
          "2555:       case 1480: row = 985; break;",
          "2556:       case 1478: row = 985; box = 1;",
          "2557:     }",
          "2558:     if ((box < 12) && (box & 1)) {",
          "2559:       for (col=0; col < 1533; col++, row ^= 1)",
          "2560:  if (col != 1) RAW(row,col) = (col+1) & 2 ?",
          "2561:      pixel[col/2-1] + pixel[col/2+1] : pixel[col/2] << 1;",
          "2562:       RAW(row,1)    = pixel[1]   << 1;",
          "2563:       RAW(row,1533) = pixel[765] << 1;",
          "2564:     } else",
          "2565:       for (col=row & 1; col < 1534; col+=2)",
          "2566:  RAW(row,col) = pixel[col/2] << 1;",
          "",
          "[Added Lines]",
          "2896:   for (irow = 0; irow < 1481; irow++)",
          "2897:   {",
          "2901:     if (fread(pixel, 1, 768, ifp) < 768)",
          "2902:       derror();",
          "2904:     row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box - 12) * 2);",
          "2905:     switch (irow)",
          "2906:     {",
          "2907:     case 1477:",
          "2908:     case 1479:",
          "2909:       continue;",
          "2910:     case 1476:",
          "2911:       row = 984;",
          "2912:       break;",
          "2913:     case 1480:",
          "2914:       row = 985;",
          "2915:       break;",
          "2916:     case 1478:",
          "2917:       row = 985;",
          "2918:       box = 1;",
          "2919:     }",
          "2920:     if ((box < 12) && (box & 1))",
          "2921:     {",
          "2922:       for (col = 0; col < 1533; col++, row ^= 1)",
          "2923:         if (col != 1)",
          "2924:           RAW(row, col) = (col + 1) & 2 ? pixel[col / 2 - 1] + pixel[col / 2 + 1] : pixel[col / 2] << 1;",
          "2925:       RAW(row, 1) = pixel[1] << 1;",
          "2926:       RAW(row, 1533) = pixel[765] << 1;",
          "2927:     }",
          "2928:     else",
          "2929:       for (col = row & 1; col < 1534; col += 2)",
          "2930:         RAW(row, col) = pixel[col / 2] << 1;",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "2571: void CLASS quicktake_100_load_raw()",
          "2572: {",
          "2573:   uchar pixel[484][644];",
          "2595:   getbits(-1);",
          "2598: #ifdef LIBRAW_LIBRARY_BUILD",
          "2599:     checkCancel();",
          "2600: #endif",
          "2605:       if (col < 4)",
          "2607:       if (row == 2)",
          "2609:     }",
          "2610:     pixel[row][col] = val;",
          "2611:   }",
          "2614:     {",
          "2615: #ifdef LIBRAW_LIBRARY_BUILD",
          "2617: #endif",
          "2632:       }",
          "2633:     }",
          "2635:   {",
          "2636: #ifdef LIBRAW_LIBRARY_BUILD",
          "2637:     checkCancel();",
          "2638: #endif",
          "2643:     }",
          "2644:   }",
          "2646:   {",
          "2647: #ifdef LIBRAW_LIBRARY_BUILD",
          "2648:     checkCancel();",
          "2649: #endif",
          "2652:   }",
          "2653:   maximum = 0x3ff;",
          "2654: }",
          "2663: #ifdef __GNUC__",
          "2667: #endif",
          "2669: void CLASS kodak_radc_load_raw()",
          "2670: {",
          "2671:   static const signed char src[] = {",
          "2691:   ushort huff[19][256];",
          "2692:   int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;",
          "2702:     FORC(256 >> src[i])",
          "2704:   s = kodak_cbpp == 243 ? 2 : 3;",
          "2706:   getbits(-1);",
          "2708:     ((short *)buf)[i] = 2048;",
          "2710: #ifdef LIBRAW_LIBRARY_BUILD",
          "2711:     checkCancel();",
          "2712: #endif",
          "2713:     FORC3 mul[c] = getbits(6);",
          "2721:       last[c] = mul[c];",
          "2765:     raw_image[i] = curve[raw_image[i]];",
          "2766:   maximum = 0x3fff;",
          "2767: }",
          "",
          "[Removed Lines]",
          "2574:   static const short gstep[16] =",
          "2575:   { -89,-60,-44,-32,-22,-15,-8,-2,2,8,15,22,32,44,60,89 };",
          "2576:   static const short rstep[6][4] =",
          "2577:   { {  -3,-1,1,3  }, {  -5,-1,1,5  }, {  -8,-2,2,8  },",
          "2578:     { -13,-3,3,13 }, { -19,-4,4,19 }, { -28,-6,6,28 } };",
          "2579:   static const short t_curve[256] =",
          "2580:   { 0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,",
          "2581:     28,29,30,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,",
          "2582:     54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,74,75,76,77,78,",
          "2583:     79,80,81,82,83,84,86,88,90,92,94,97,99,101,103,105,107,110,112,114,116,",
          "2584:     118,120,123,125,127,129,131,134,136,138,140,142,144,147,149,151,153,155,",
          "2585:     158,160,162,164,166,168,171,173,175,177,179,181,184,186,188,190,192,195,",
          "2586:     197,199,201,203,205,208,210,212,214,216,218,221,223,226,230,235,239,244,",
          "2587:     248,252,257,261,265,270,274,278,283,287,291,296,300,305,309,313,318,322,",
          "2588:     326,331,335,339,344,348,352,357,361,365,370,374,379,383,387,392,396,400,",
          "2589:     405,409,413,418,422,426,431,435,440,444,448,453,457,461,466,470,474,479,",
          "2590:     483,487,492,496,500,508,519,531,542,553,564,575,587,598,609,620,631,643,",
          "2591:     654,665,676,687,698,710,721,732,743,754,766,777,788,799,810,822,833,844,",
          "2592:     855,866,878,889,900,911,922,933,945,956,967,978,989,1001,1012,1023 };",
          "2593:   int rb, row, col, sharp, val=0;",
          "2596:   memset (pixel, 0x80, sizeof pixel);",
          "2597:   for (row=2; row < height+2; row++) {",
          "2601:     for (col=2+(row & 1); col < width+2; col+=2) {",
          "2602:       val = ((pixel[row-1][col-1] + 2*pixel[row-1][col+1] +",
          "2603:   pixel[row][col-2]) >> 2) + gstep[getbits(4)];",
          "2604:       pixel[row][col] = val = LIM(val,0,255);",
          "2606:  pixel[row][col-2] = pixel[row+1][~row & 1] = val;",
          "2608:  pixel[row-1][col+1] = pixel[row-1][col+3] = val;",
          "2612:   for (rb=0; rb < 2; rb++)",
          "2613:     for (row=2+rb; row < height+2; row+=2)",
          "2616:     checkCancel();",
          "2618:       for (col=3-(row & 1); col < width+2; col+=2) {",
          "2619:  if (row < 4 || col < 4) sharp = 2;",
          "2620:  else {",
          "2621:    val = ABS(pixel[row-2][col] - pixel[row][col-2])",
          "2622:        + ABS(pixel[row-2][col] - pixel[row-2][col-2])",
          "2623:        + ABS(pixel[row][col-2] - pixel[row-2][col-2]);",
          "2624:    sharp = val <  4 ? 0 : val <  8 ? 1 : val < 16 ? 2 :",
          "2625:     val < 32 ? 3 : val < 48 ? 4 : 5;",
          "2626:  }",
          "2627:  val = ((pixel[row-2][col] + pixel[row][col-2]) >> 1)",
          "2628:        + rstep[sharp][getbits(2)];",
          "2629:  pixel[row][col] = val = LIM(val,0,255);",
          "2630:  if (row < 4) pixel[row-2][col+2] = val;",
          "2631:  if (col < 4) pixel[row+2][col-2] = val;",
          "2634:   for (row=2; row < height+2; row++)",
          "2639:     for (col=3-(row & 1); col < width+2; col+=2) {",
          "2640:       val = ((pixel[row][col-1] + (pixel[row][col] << 2) +",
          "2641:        pixel[row][col+1]) >> 1) - 0x100;",
          "2642:       pixel[row][col] = LIM(val,0,255);",
          "2645:   for (row=0; row < height; row++)",
          "2650:     for (col=0; col < width; col++)",
          "2651:       RAW(row,col) = t_curve[pixel[row+2][col+2]];",
          "2656: #define radc_token(tree) ((signed char) getbithuff(8,huff[tree]))",
          "2658: #define FORYX for (y=1; y < 3; y++) for (x=col+1; x >= col; x--)",
          "2660: #define PREDICTOR (c ? (buf[c][y-1][x] + buf[c][y][x+1]) / 2 \\",
          "2661: : (buf[c][y-1][x+1] + 2*buf[c][y-1][x] + buf[c][y][x+1]) / 4)",
          "2664: # if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)",
          "2665: # pragma GCC optimize(\"no-aggressive-loop-optimizations\")",
          "2666: # endif",
          "2672:     1,1, 2,3, 3,4, 4,2, 5,7, 6,5, 7,6, 7,8,",
          "2673:     1,0, 2,1, 3,3, 4,4, 5,2, 6,7, 7,6, 8,5, 8,8,",
          "2674:     2,1, 2,3, 3,0, 3,2, 3,4, 4,6, 5,5, 6,7, 6,8,",
          "2675:     2,0, 2,1, 2,3, 3,2, 4,4, 5,6, 6,7, 7,5, 7,8,",
          "2676:     2,1, 2,4, 3,0, 3,2, 3,3, 4,7, 5,5, 6,6, 6,8,",
          "2677:     2,3, 3,1, 3,2, 3,4, 3,5, 3,6, 4,7, 5,0, 5,8,",
          "2678:     2,3, 2,6, 3,0, 3,1, 4,4, 4,5, 4,7, 5,2, 5,8,",
          "2679:     2,4, 2,7, 3,3, 3,6, 4,1, 4,2, 4,5, 5,0, 5,8,",
          "2680:     2,6, 3,1, 3,3, 3,5, 3,7, 3,8, 4,0, 5,2, 5,4,",
          "2681:     2,0, 2,1, 3,2, 3,3, 4,4, 4,5, 5,6, 5,7, 4,8,",
          "2682:     1,0, 2,2, 2,-2,",
          "2683:     1,-3, 1,3,",
          "2684:     2,-17, 2,-5, 2,5, 2,17,",
          "2685:     2,-7, 2,2, 2,9, 2,18,",
          "2686:     2,-18, 2,-9, 2,-2, 2,7,",
          "2687:     2,-28, 2,28, 3,-49, 3,-9, 3,9, 4,49, 5,-79, 5,79,",
          "2688:     2,-1, 2,13, 2,26, 3,39, 4,-16, 5,55, 6,-37, 6,76,",
          "2689:     2,-26, 2,-13, 2,1, 3,-39, 4,16, 5,-55, 6,-76, 6,37",
          "2690:   };",
          "2693:   short last[3] = { 16,16,16 }, mul[3], buf[3][3][386];",
          "2694:   static const ushort pt[] =",
          "2695:     { 0,0, 1280,1344, 2320,3616, 3328,8000, 4095,16383, 65535,16383 };",
          "2697:   for (i=2; i < 12; i+=2)",
          "2698:     for (c=pt[i-2]; c <= pt[i]; c++)",
          "2699:       curve[c] = (float)",
          "2700:  (c-pt[i-2]) / (pt[i]-pt[i-2]) * (pt[i+1]-pt[i-1]) + pt[i-1] + 0.5;",
          "2701:   for (s=i=0; i < sizeof src; i+=2)",
          "2703:       ((ushort *)huff)[s++] = src[i] << 8 | (uchar) src[i+1];",
          "2705:   FORC(256) huff[18][c] = (8-s) << 8 | c >> s << s | 1 << (s-1);",
          "2707:   for (i=0; i < sizeof(buf)/sizeof(short); i++)",
          "2709:   for (row=0; row < height; row+=4) {",
          "2714:     FORC3 {",
          "2715:       val = ((0x1000000/last[c] + 0x7ff) >> 12) * mul[c];",
          "2716:       s = val > 65564 ? 10:12;",
          "2717:       x = ~((~0u) << (s-1));",
          "2718:       val <<= 12-s;",
          "2719:       for (i=0; i < sizeof(buf[0])/sizeof(short); i++)",
          "2720:  ((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;",
          "2722:       for (r=0; r <= !c; r++) {",
          "2723:  buf[c][1][width/2] = buf[c][2][width/2] = mul[c] << 7;",
          "2724:  for (tree=1, col=width/2; col > 0; ) {",
          "2725:    if ((tree = radc_token(tree))) {",
          "2726:      col -= 2;",
          "2727:      if (tree == 8)",
          "2728:        FORYX buf[c][y][x] = (uchar) radc_token(18) * mul[c];",
          "2729:      else",
          "2730:        FORYX buf[c][y][x] = radc_token(tree+10) * 16 + PREDICTOR;",
          "2731:    } else",
          "2732:      do {",
          "2733:        nreps = (col > 2) ? radc_token(9) + 1 : 1;",
          "2734:        for (rep=0; rep < 8 && rep < nreps && col > 0; rep++) {",
          "2735:   col -= 2;",
          "2736:   FORYX buf[c][y][x] = PREDICTOR;",
          "2737:   if (rep & 1) {",
          "2738:     step = radc_token(10) << 4;",
          "2739:     FORYX buf[c][y][x] += step;",
          "2740:   }",
          "2741:        }",
          "2742:      } while (nreps == 9);",
          "2743:  }",
          "2744:  for (y=0; y < 2; y++)",
          "2745:    for (x=0; x < width/2; x++) {",
          "2746:      val = (buf[c][y+1][x] << 4) / mul[c];",
          "2747:      if (val < 0) val = 0;",
          "2748:      if (c) RAW(row+y*2+c-1,x*2+2-c) = val;",
          "2749:      else   RAW(row+r*2+y,x*2+y) = val;",
          "2750:    }",
          "2751:  memcpy (buf[c][0]+!c, buf[c][2], sizeof buf[c][0]-2*!c);",
          "2752:       }",
          "2753:     }",
          "2754:     for (y=row; y < row+4; y++)",
          "2755:       for (x=0; x < width; x++)",
          "2756:  if ((x+y) & 1) {",
          "2757:    r = x ? x-1 : x+1;",
          "2758:    s = x+1 < width ? x+1 : x-1;",
          "2759:    val = (RAW(y,x)-2048)*2 + (RAW(y,r)+RAW(y,s))/2;",
          "2760:    if (val < 0) val = 0;",
          "2761:    RAW(y,x) = val;",
          "2762:  }",
          "2763:   }",
          "2764:   for (i=0; i < height*width; i++)",
          "",
          "[Added Lines]",
          "2938:   static const short gstep[16] = {-89, -60, -44, -32, -22, -15, -8, -2, 2, 8, 15, 22, 32, 44, 60, 89};",
          "2939:   static const short rstep[6][4] = {{-3, -1, 1, 3},   {-5, -1, 1, 5},   {-8, -2, 2, 8},",
          "2940:                                     {-13, -3, 3, 13}, {-19, -4, 4, 19}, {-28, -6, 6, 28}};",
          "2941:   static const short t_curve[256] = {",
          "2942:       0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   11,  12,   13,   14,  15,  16,  17,  18,  19,  20,  21,  22,",
          "2943:       23,  24,  25,  26,  27,  28,  29,  30,  32,  33,  34,  35,   36,   37,  38,  39,  40,  41,  42,  43,  44,  45,",
          "2944:       46,  47,  48,  49,  50,  51,  53,  54,  55,  56,  57,  58,   59,   60,  61,  62,  63,  64,  65,  66,  67,  68,",
          "2945:       69,  70,  71,  72,  74,  75,  76,  77,  78,  79,  80,  81,   82,   83,  84,  86,  88,  90,  92,  94,  97,  99,",
          "2946:       101, 103, 105, 107, 110, 112, 114, 116, 118, 120, 123, 125,  127,  129, 131, 134, 136, 138, 140, 142, 144, 147,",
          "2947:       149, 151, 153, 155, 158, 160, 162, 164, 166, 168, 171, 173,  175,  177, 179, 181, 184, 186, 188, 190, 192, 195,",
          "2948:       197, 199, 201, 203, 205, 208, 210, 212, 214, 216, 218, 221,  223,  226, 230, 235, 239, 244, 248, 252, 257, 261,",
          "2949:       265, 270, 274, 278, 283, 287, 291, 296, 300, 305, 309, 313,  318,  322, 326, 331, 335, 339, 344, 348, 352, 357,",
          "2950:       361, 365, 370, 374, 379, 383, 387, 392, 396, 400, 405, 409,  413,  418, 422, 426, 431, 435, 440, 444, 448, 453,",
          "2951:       457, 461, 466, 470, 474, 479, 483, 487, 492, 496, 500, 508,  519,  531, 542, 553, 564, 575, 587, 598, 609, 620,",
          "2952:       631, 643, 654, 665, 676, 687, 698, 710, 721, 732, 743, 754,  766,  777, 788, 799, 810, 822, 833, 844, 855, 866,",
          "2953:       878, 889, 900, 911, 922, 933, 945, 956, 967, 978, 989, 1001, 1012, 1023};",
          "2954:   int rb, row, col, sharp, val = 0;",
          "2957:   memset(pixel, 0x80, sizeof pixel);",
          "2958:   for (row = 2; row < height + 2; row++)",
          "2959:   {",
          "2963:     for (col = 2 + (row & 1); col < width + 2; col += 2)",
          "2964:     {",
          "2965:       val = ((pixel[row - 1][col - 1] + 2 * pixel[row - 1][col + 1] + pixel[row][col - 2]) >> 2) + gstep[getbits(4)];",
          "2966:       pixel[row][col] = val = LIM(val, 0, 255);",
          "2968:         pixel[row][col - 2] = pixel[row + 1][~row & 1] = val;",
          "2970:         pixel[row - 1][col + 1] = pixel[row - 1][col + 3] = val;",
          "2974:   for (rb = 0; rb < 2; rb++)",
          "2975:     for (row = 2 + rb; row < height + 2; row += 2)",
          "2978:       checkCancel();",
          "2980:       for (col = 3 - (row & 1); col < width + 2; col += 2)",
          "2981:       {",
          "2982:         if (row < 4 || col < 4)",
          "2983:           sharp = 2;",
          "2984:         else",
          "2985:         {",
          "2986:           val = ABS(pixel[row - 2][col] - pixel[row][col - 2]) + ABS(pixel[row - 2][col] - pixel[row - 2][col - 2]) +",
          "2987:                 ABS(pixel[row][col - 2] - pixel[row - 2][col - 2]);",
          "2988:           sharp = val < 4 ? 0 : val < 8 ? 1 : val < 16 ? 2 : val < 32 ? 3 : val < 48 ? 4 : 5;",
          "2989:         }",
          "2990:         val = ((pixel[row - 2][col] + pixel[row][col - 2]) >> 1) + rstep[sharp][getbits(2)];",
          "2991:         pixel[row][col] = val = LIM(val, 0, 255);",
          "2992:         if (row < 4)",
          "2993:           pixel[row - 2][col + 2] = val;",
          "2994:         if (col < 4)",
          "2995:           pixel[row + 2][col - 2] = val;",
          "2998:   for (row = 2; row < height + 2; row++)",
          "3003:     for (col = 3 - (row & 1); col < width + 2; col += 2)",
          "3004:     {",
          "3005:       val = ((pixel[row][col - 1] + (pixel[row][col] << 2) + pixel[row][col + 1]) >> 1) - 0x100;",
          "3006:       pixel[row][col] = LIM(val, 0, 255);",
          "3009:   for (row = 0; row < height; row++)",
          "3014:     for (col = 0; col < width; col++)",
          "3015:       RAW(row, col) = t_curve[pixel[row + 2][col + 2]];",
          "3020: #define radc_token(tree) ((signed char)getbithuff(8, huff[tree]))",
          "3022: #define FORYX                                                                                                          \\",
          "3023:   for (y = 1; y < 3; y++)                                                                                              \\",
          "3024:     for (x = col + 1; x >= col; x--)",
          "3026: #define PREDICTOR                                                                                                      \\",
          "3027:   (c ? (buf[c][y - 1][x] + buf[c][y][x + 1]) / 2 : (buf[c][y - 1][x + 1] + 2 * buf[c][y - 1][x] + buf[c][y][x + 1]) / 4)",
          "3030: #if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)",
          "3031: #pragma GCC optimize(\"no-aggressive-loop-optimizations\")",
          "3032: #endif",
          "3038:       1, 1,   2, 3,   3, 4,   4, 2,   5, 7,   6, 5,   7, 6,  7, 8,   1, 0,   2, 1,  3, 3,  4, 4,  5, 2,   6, 7,   7, 6,",
          "3039:       8, 5,   8, 8,   2, 1,   2, 3,   3, 0,   3, 2,   3, 4,  4, 6,   5, 5,   6, 7,  6, 8,  2, 0,  2, 1,   2, 3,   3, 2,",
          "3040:       4, 4,   5, 6,   6, 7,   7, 5,   7, 8,   2, 1,   2, 4,  3, 0,   3, 2,   3, 3,  4, 7,  5, 5,  6, 6,   6, 8,   2, 3,",
          "3041:       3, 1,   3, 2,   3, 4,   3, 5,   3, 6,   4, 7,   5, 0,  5, 8,   2, 3,   2, 6,  3, 0,  3, 1,  4, 4,   4, 5,   4, 7,",
          "3042:       5, 2,   5, 8,   2, 4,   2, 7,   3, 3,   3, 6,   4, 1,  4, 2,   4, 5,   5, 0,  5, 8,  2, 6,  3, 1,   3, 3,   3, 5,",
          "3043:       3, 7,   3, 8,   4, 0,   5, 2,   5, 4,   2, 0,   2, 1,  3, 2,   3, 3,   4, 4,  4, 5,  5, 6,  5, 7,   4, 8,   1, 0,",
          "3044:       2, 2,   2, -2,  1, -3,  1, 3,   2, -17, 2, -5,  2, 5,  2, 17,  2, -7,  2, 2,  2, 9,  2, 18, 2, -18, 2, -9,  2, -2,",
          "3045:       2, 7,   2, -28, 2, 28,  3, -49, 3, -9,  3, 9,   4, 49, 5, -79, 5, 79,  2, -1, 2, 13, 2, 26, 3, 39,  4, -16, 5, 55,",
          "3046:       6, -37, 6, 76,  2, -26, 2, -13, 2, 1,   3, -39, 4, 16, 5, -55, 6, -76, 6, 37};",
          "3049:   short last[3] = {16, 16, 16}, mul[3], buf[3][3][386];",
          "3050:   static const ushort pt[] = {0, 0, 1280, 1344, 2320, 3616, 3328, 8000, 4095, 16383, 65535, 16383};",
          "3052:   for (i = 2; i < 12; i += 2)",
          "3053:     for (c = pt[i - 2]; c <= pt[i]; c++)",
          "3054:       curve[c] = (float)(c - pt[i - 2]) / (pt[i] - pt[i - 2]) * (pt[i + 1] - pt[i - 1]) + pt[i - 1] + 0.5;",
          "3055:   for (s = i = 0; i < sizeof src; i += 2)",
          "3057:   ((ushort *)huff)[s++] = src[i] << 8 | (uchar)src[i + 1];",
          "3059:   FORC(256) huff[18][c] = (8 - s) << 8 | c >> s << s | 1 << (s - 1);",
          "3061:   for (i = 0; i < sizeof(buf) / sizeof(short); i++)",
          "3063:   for (row = 0; row < height; row += 4)",
          "3064:   {",
          "3069:     FORC3",
          "3070:     {",
          "3071:       val = ((0x1000000 / last[c] + 0x7ff) >> 12) * mul[c];",
          "3072:       s = val > 65564 ? 10 : 12;",
          "3073:       x = ~((~0u) << (s - 1));",
          "3074:       val <<= 12 - s;",
          "3075:       for (i = 0; i < sizeof(buf[0]) / sizeof(short); i++)",
          "3076:         ((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;",
          "3078:       for (r = 0; r <= !c; r++)",
          "3079:       {",
          "3080:         buf[c][1][width / 2] = buf[c][2][width / 2] = mul[c] << 7;",
          "3081:         for (tree = 1, col = width / 2; col > 0;)",
          "3082:         {",
          "3083:           if ((tree = radc_token(tree)))",
          "3084:           {",
          "3085:             col -= 2;",
          "3086:             if (tree == 8)",
          "3087:               FORYX buf[c][y][x] = (uchar)radc_token(18) * mul[c];",
          "3088:             else",
          "3089:               FORYX buf[c][y][x] = radc_token(tree + 10) * 16 + PREDICTOR;",
          "3090:           }",
          "3091:           else",
          "3092:             do",
          "3093:             {",
          "3094:               nreps = (col > 2) ? radc_token(9) + 1 : 1;",
          "3095:               for (rep = 0; rep < 8 && rep < nreps && col > 0; rep++)",
          "3096:               {",
          "3097:                 col -= 2;",
          "3098:                 FORYX buf[c][y][x] = PREDICTOR;",
          "3099:                 if (rep & 1)",
          "3100:                 {",
          "3101:                   step = radc_token(10) << 4;",
          "3102:                   FORYX buf[c][y][x] += step;",
          "3103:                 }",
          "3104:               }",
          "3105:             } while (nreps == 9);",
          "3106:         }",
          "3107:         for (y = 0; y < 2; y++)",
          "3108:           for (x = 0; x < width / 2; x++)",
          "3109:           {",
          "3110:             val = (buf[c][y + 1][x] << 4) / mul[c];",
          "3111:             if (val < 0)",
          "3112:               val = 0;",
          "3113:             if (c)",
          "3114:               RAW(row + y * 2 + c - 1, x * 2 + 2 - c) = val;",
          "3115:             else",
          "3116:               RAW(row + r * 2 + y, x * 2 + y) = val;",
          "3117:           }",
          "3118:         memcpy(buf[c][0] + !c, buf[c][2], sizeof buf[c][0] - 2 * !c);",
          "3119:       }",
          "3120:     }",
          "3121:     for (y = row; y < row + 4; y++)",
          "3122:       for (x = 0; x < width; x++)",
          "3123:         if ((x + y) & 1)",
          "3124:         {",
          "3125:           r = x ? x - 1 : x + 1;",
          "3126:           s = x + 1 < width ? x + 1 : x - 1;",
          "3127:           val = (RAW(y, x) - 2048) * 2 + (RAW(y, r) + RAW(y, s)) / 2;",
          "3128:           if (val < 0)",
          "3129:             val = 0;",
          "3130:           RAW(y, x) = val;",
          "3131:         }",
          "3132:   }",
          "3133:   for (i = 0; i < height * width; i++)",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "2774: void CLASS lossy_dng_load_raw() {}",
          "2775: #else",
          "2778: #ifndef LIBRAW_LIBRARY_BUILD",
          "2779: METHODDEF(boolean)",
          "2781: {",
          "2782:   static uchar jpeg_buffer[4096];",
          "2783:   size_t nbytes;",
          "2787:   cinfo->src->next_input_byte = jpeg_buffer;",
          "2788:   cinfo->src->bytes_in_buffer = nbytes;",
          "2789:   return TRUE;",
          "",
          "[Removed Lines]",
          "2780: fill_input_buffer (j_decompress_ptr cinfo)",
          "2785:   nbytes = fread (jpeg_buffer, 1, 4096, ifp);",
          "2786:   swab (jpeg_buffer, jpeg_buffer, nbytes);",
          "",
          "[Added Lines]",
          "3148: fill_input_buffer(j_decompress_ptr cinfo)",
          "3153:   nbytes = fread(jpeg_buffer, 1, 4096, ifp);",
          "3154:   swab(jpeg_buffer, jpeg_buffer, nbytes);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "2793:   struct jpeg_decompress_struct cinfo;",
          "2794:   struct jpeg_error_mgr jerr;",
          "2795:   JSAMPARRAY buf;",
          "2797:   int row, col;",
          "2802:   cinfo.src->fill_input_buffer = fill_input_buffer;",
          "2816:     row = cinfo.output_scanline * 2;",
          "2824:     }",
          "2825:   }",
          "2828:   maximum = 0xff << 1;",
          "2829: }",
          "2830: #else",
          "2833:   struct jpeg_error_mgr pub;",
          "2834: };",
          "2837: {",
          "2839:   throw LIBRAW_EXCEPTION_DECODE_JPEG;",
          "2840: }",
          "2844: void CLASS kodak_jpeg_load_raw()",
          "2845: {",
          "2847:     throw LIBRAW_EXCEPTION_DECODE_JPEG;",
          "2849:   int row, col;",
          "",
          "[Removed Lines]",
          "2796:   JSAMPLE (*pixel)[3];",
          "2799:   cinfo.err = jpeg_std_error (&jerr);",
          "2800:   jpeg_create_decompress (&cinfo);",
          "2801:   jpeg_stdio_src (&cinfo, ifp);",
          "2803:   jpeg_read_header (&cinfo, TRUE);",
          "2804:   jpeg_start_decompress (&cinfo);",
          "2805:   if ((cinfo.output_width      != width  ) ||",
          "2806:       (cinfo.output_height*2   != height ) ||",
          "2807:       (cinfo.output_components != 3      )) {",
          "2808:     fprintf (stderr,_(\"%s: incorrect JPEG dimensions\\n\"), ifname);",
          "2809:     jpeg_destroy_decompress (&cinfo);",
          "2810:     longjmp (failure, 3);",
          "2811:   }",
          "2812:   buf = (*cinfo.mem->alloc_sarray)",
          "2813:     ((j_common_ptr) &cinfo, JPOOL_IMAGE, width*3, 1);",
          "2815:   while (cinfo.output_scanline < cinfo.output_height) {",
          "2817:     jpeg_read_scanlines (&cinfo, buf, 1);",
          "2818:     pixel = (JSAMPLE (*)[3]) buf[0];",
          "2819:     for (col=0; col < width; col+=2) {",
          "2820:       RAW(row+0,col+0) = pixel[col+0][1] << 1;",
          "2821:       RAW(row+1,col+1) = pixel[col+1][1] << 1;",
          "2822:       RAW(row+0,col+1) = pixel[col][0] + pixel[col+1][0];",
          "2823:       RAW(row+1,col+0) = pixel[col][2] + pixel[col+1][2];",
          "2826:   jpeg_finish_decompress (&cinfo);",
          "2827:   jpeg_destroy_decompress (&cinfo);",
          "2832: struct jpegErrorManager {",
          "2836: static void jpegErrorExit (j_common_ptr cinfo)",
          "2838:   jpegErrorManager* myerr = (jpegErrorManager*) cinfo->err;",
          "2846:   if(data_size < 1)",
          "",
          "[Added Lines]",
          "3164:   JSAMPLE(*pixel)[3];",
          "3167:   cinfo.err = jpeg_std_error(&jerr);",
          "3168:   jpeg_create_decompress(&cinfo);",
          "3169:   jpeg_stdio_src(&cinfo, ifp);",
          "3171:   jpeg_read_header(&cinfo, TRUE);",
          "3172:   jpeg_start_decompress(&cinfo);",
          "3173:   if ((cinfo.output_width != width) || (cinfo.output_height * 2 != height) || (cinfo.output_components != 3))",
          "3174:   {",
          "3175:     fprintf(stderr, _(\"%s: incorrect JPEG dimensions\\n\"), ifname);",
          "3176:     jpeg_destroy_decompress(&cinfo);",
          "3177:     longjmp(failure, 3);",
          "3178:   }",
          "3179:   buf = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, width * 3, 1);",
          "3181:   while (cinfo.output_scanline < cinfo.output_height)",
          "3182:   {",
          "3184:     jpeg_read_scanlines(&cinfo, buf, 1);",
          "3185:     pixel = (JSAMPLE(*)[3])buf[0];",
          "3186:     for (col = 0; col < width; col += 2)",
          "3187:     {",
          "3188:       RAW(row + 0, col + 0) = pixel[col + 0][1] << 1;",
          "3189:       RAW(row + 1, col + 1) = pixel[col + 1][1] << 1;",
          "3190:       RAW(row + 0, col + 1) = pixel[col][0] + pixel[col + 1][0];",
          "3191:       RAW(row + 1, col + 0) = pixel[col][2] + pixel[col + 1][2];",
          "3194:   jpeg_finish_decompress(&cinfo);",
          "3195:   jpeg_destroy_decompress(&cinfo);",
          "3200: struct jpegErrorManager",
          "3201: {",
          "3205: static void jpegErrorExit(j_common_ptr cinfo)",
          "3207:   jpegErrorManager *myerr = (jpegErrorManager *)cinfo->err;",
          "3214:   if (data_size < 1)",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "2854:   jerr.pub.error_exit = jpegErrorExit;",
          "2856:   unsigned char *jpg_buf = (unsigned char *)malloc(data_size);",
          "2864:   try",
          "2895:     }",
          "2896:   catch (...)",
          "2906:   free(jpg_buf);",
          "2907:   free(pixel_buf);",
          "2908:   maximum = 0xff << 1;",
          "",
          "[Removed Lines]",
          "2857:   merror(jpg_buf,\"kodak_jpeg_load_raw\");",
          "2858:   unsigned char *pixel_buf = (unsigned char*) malloc(width*3);",
          "2859:   jpeg_create_decompress (&cinfo);",
          "2860:   merror(pixel_buf,\"kodak_jpeg_load_raw\");",
          "2862:   fread(jpg_buf,data_size,1,ifp);",
          "2863:   swab ((char*)jpg_buf, (char*)jpg_buf, data_size);",
          "2865:     {",
          "2866:       jpeg_mem_src(&cinfo, jpg_buf, data_size);",
          "2867:       int rc = jpeg_read_header(&cinfo, TRUE);",
          "2868:       if(rc!=1)",
          "2869:         throw LIBRAW_EXCEPTION_DECODE_JPEG;",
          "2871:       jpeg_start_decompress (&cinfo);",
          "2872:       if ((cinfo.output_width      != width  ) ||",
          "2873:           (cinfo.output_height*2   != height ) ||",
          "2874:           (cinfo.output_components != 3      ))",
          "2875:         {",
          "2876:           throw LIBRAW_EXCEPTION_DECODE_JPEG;",
          "2877:         }",
          "2879:       unsigned char *buf[1];",
          "2880:       buf[0] = pixel_buf;",
          "2882:       while (cinfo.output_scanline < cinfo.output_height)",
          "2883:         {",
          "2884:           checkCancel();",
          "2885:           row = cinfo.output_scanline * 2;",
          "2886:           jpeg_read_scanlines (&cinfo, buf, 1);",
          "2887:           unsigned char (*pixel)[3] = (unsigned char (*)[3]) buf[0];",
          "2888:           for (col=0; col < width; col+=2) {",
          "2889:             RAW(row+0,col+0) = pixel[col+0][1] << 1;",
          "2890:             RAW(row+1,col+1) = pixel[col+1][1] << 1;",
          "2891:             RAW(row+0,col+1) = pixel[col][0] + pixel[col+1][0];",
          "2892:             RAW(row+1,col+0) = pixel[col][2] + pixel[col+1][2];",
          "2893:           }",
          "2894:         }",
          "2897:         {",
          "2898:           jpeg_finish_decompress (&cinfo);",
          "2899:           jpeg_destroy_decompress (&cinfo);",
          "2900:           free(jpg_buf);",
          "2901:           free(pixel_buf);",
          "2902:           throw;",
          "2903:         }",
          "2904:   jpeg_finish_decompress (&cinfo);",
          "2905:   jpeg_destroy_decompress (&cinfo);",
          "",
          "[Added Lines]",
          "3225:   merror(jpg_buf, \"kodak_jpeg_load_raw\");",
          "3226:   unsigned char *pixel_buf = (unsigned char *)malloc(width * 3);",
          "3227:   jpeg_create_decompress(&cinfo);",
          "3228:   merror(pixel_buf, \"kodak_jpeg_load_raw\");",
          "3230:   fread(jpg_buf, data_size, 1, ifp);",
          "3231:   swab((char *)jpg_buf, (char *)jpg_buf, data_size);",
          "3233:   {",
          "3234:     jpeg_mem_src(&cinfo, jpg_buf, data_size);",
          "3235:     int rc = jpeg_read_header(&cinfo, TRUE);",
          "3236:     if (rc != 1)",
          "3237:       throw LIBRAW_EXCEPTION_DECODE_JPEG;",
          "3239:     jpeg_start_decompress(&cinfo);",
          "3240:     if ((cinfo.output_width != width) || (cinfo.output_height * 2 != height) || (cinfo.output_components != 3))",
          "3241:     {",
          "3242:       throw LIBRAW_EXCEPTION_DECODE_JPEG;",
          "3243:     }",
          "3245:     unsigned char *buf[1];",
          "3246:     buf[0] = pixel_buf;",
          "3248:     while (cinfo.output_scanline < cinfo.output_height)",
          "3249:     {",
          "3250:       checkCancel();",
          "3251:       row = cinfo.output_scanline * 2;",
          "3252:       jpeg_read_scanlines(&cinfo, buf, 1);",
          "3253:       unsigned char(*pixel)[3] = (unsigned char(*)[3])buf[0];",
          "3254:       for (col = 0; col < width; col += 2)",
          "3255:       {",
          "3256:         RAW(row + 0, col + 0) = pixel[col + 0][1] << 1;",
          "3257:         RAW(row + 1, col + 1) = pixel[col + 1][1] << 1;",
          "3258:         RAW(row + 0, col + 1) = pixel[col][0] + pixel[col + 1][0];",
          "3259:         RAW(row + 1, col + 0) = pixel[col][2] + pixel[col + 1][2];",
          "3260:       }",
          "3262:   }",
          "3264:   {",
          "3265:     jpeg_finish_decompress(&cinfo);",
          "3266:     jpeg_destroy_decompress(&cinfo);",
          "3267:     free(jpg_buf);",
          "3268:     free(pixel_buf);",
          "3269:     throw;",
          "3270:   }",
          "3271:   jpeg_finish_decompress(&cinfo);",
          "3272:   jpeg_destroy_decompress(&cinfo);",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "2910: #endif",
          "2912: #ifndef LIBRAW_LIBRARY_BUILD",
          "2914: #endif",
          "2916: void CLASS lossy_dng_load_raw()",
          "",
          "[Removed Lines]",
          "2913: void CLASS gamma_curve (double pwr, double ts, int mode, int imax);",
          "",
          "[Added Lines]",
          "3280: void CLASS gamma_curve(double pwr, double ts, int mode, int imax);",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "2918:   struct jpeg_decompress_struct cinfo;",
          "2919:   struct jpeg_error_mgr jerr;",
          "2920:   JSAMPARRAY buf;",
          "2924:   ushort cur[3][256];",
          "2925:   double coeff[9], tot;",
          "2929:     order = 0x4d4d;",
          "2930:     ntags = get4();",
          "2933:       if (opcode != 8)",
          "2945:       }",
          "2946:     }",
          "2947:     order = sorder;",
          "2956:     if (tile_length < INT_MAX)",
          "2958: #ifdef LIBRAW_LIBRARY_BUILD",
          "2964: #else",
          "2966: #endif",
          "2971: #ifdef LIBRAW_LIBRARY_BUILD",
          "2973: #endif",
          "2976: #ifdef LIBRAW_LIBRARY_BUILD",
          "2978: #endif",
          "2983:       }",
          "2985: #ifdef LIBRAW_LIBRARY_BUILD",
          "2990: #endif",
          "2992:     if ((tcol += tile_width) >= raw_width)",
          "2993:       trow += tile_length + (tcol = 0);",
          "2994:   }",
          "2996:   maximum = 0xffff;",
          "2997: }",
          "2998: #endif",
          "3000: void CLASS kodak_dc120_load_raw()",
          "3001: {",
          "3004:   uchar pixel[848];",
          "3005:   int row, shift, col;",
          "3008: #ifdef LIBRAW_LIBRARY_BUILD",
          "3009:     checkCancel();",
          "3010: #endif",
          "3012:     shift = row * mul[row & 3] + add[row & 3];",
          "3015:   }",
          "3016:   maximum = 0xff;",
          "3017: }",
          "",
          "[Removed Lines]",
          "2921:   JSAMPLE (*pixel)[3];",
          "2922:   unsigned sorder=order, ntags, opcode, deg, i, j, c;",
          "2923:   unsigned save=data_offset-4, trow=0, tcol=0, row, col;",
          "2927:   if (meta_offset) {",
          "2928:     fseek (ifp, meta_offset, SEEK_SET);",
          "2931:     while (ntags--) {",
          "2932:       opcode = get4(); get4(); get4();",
          "2934:       { fseek (ifp, get4(), SEEK_CUR); continue; }",
          "2935:       fseek (ifp, 20, SEEK_CUR);",
          "2936:       if ((c = get4()) > 2) break;",
          "2937:       fseek (ifp, 12, SEEK_CUR);",
          "2938:       if ((deg = get4()) > 8) break;",
          "2939:       for (i=0; i <= deg && i < 9; i++)",
          "2940:  coeff[i] = getreal(12);",
          "2941:       for (i=0; i < 256; i++) {",
          "2942:  for (tot=j=0; j <= deg; j++)",
          "2943:    tot += coeff[j] * pow(i/255.0, (int)j);",
          "2944:  cur[c][i] = tot*0xffff;",
          "2948:   } else {",
          "2949:     gamma_curve (1/2.4, 12.92, 1, 255);",
          "2950:     FORC3 memcpy (cur[c], curve, sizeof cur[0]);",
          "2951:   }",
          "2952:   cinfo.err = jpeg_std_error (&jerr);",
          "2953:   jpeg_create_decompress (&cinfo);",
          "2954:   while (trow < raw_height) {",
          "2955:     fseek (ifp, save+=4, SEEK_SET);",
          "2957:       fseek (ifp, get4(), SEEK_SET);",
          "2959:     if(libraw_internal_data.internal_data.input->jpeg_src(&cinfo) == -1)",
          "2960:       {",
          "2961:         jpeg_destroy_decompress(&cinfo);",
          "2962:         throw LIBRAW_EXCEPTION_DECODE_JPEG;",
          "2963:       }",
          "2965:     jpeg_stdio_src (&cinfo, ifp);",
          "2967:     jpeg_read_header (&cinfo, TRUE);",
          "2968:     jpeg_start_decompress (&cinfo);",
          "2969:     buf = (*cinfo.mem->alloc_sarray)",
          "2970:  ((j_common_ptr) &cinfo, JPOOL_IMAGE, cinfo.output_width*3, 1);",
          "2972:   try {",
          "2974:     while (cinfo.output_scanline < cinfo.output_height &&",
          "2975:  (row = trow + cinfo.output_scanline) < height) {",
          "2977:     checkCancel();",
          "2979:       jpeg_read_scanlines (&cinfo, buf, 1);",
          "2980:       pixel = (JSAMPLE (*)[3]) buf[0];",
          "2981:       for (col=0; col < cinfo.output_width && tcol+col < width; col++) {",
          "2982:  FORC3 image[row*width+tcol+col][c] = cur[c][pixel[col][c]];",
          "2984:     }",
          "2986:   } catch(...) {",
          "2987:     jpeg_destroy_decompress (&cinfo);",
          "2988:     throw;",
          "2989:   }",
          "2991:     jpeg_abort_decompress (&cinfo);",
          "2995:   jpeg_destroy_decompress (&cinfo);",
          "3002:   static const int mul[4] = { 162, 192, 187,  92 };",
          "3003:   static const int add[4] = {   0, 636, 424, 212 };",
          "3007:   for (row=0; row < height; row++) {",
          "3011:     if (fread (pixel, 1, 848, ifp) < 848) derror();",
          "3013:     for (col=0; col < width; col++)",
          "3014:       RAW(row,col) = (ushort) pixel[(col + shift) % 848];",
          "",
          "[Added Lines]",
          "3288:   JSAMPLE(*pixel)[3];",
          "3289:   unsigned sorder = order, ntags, opcode, deg, i, j, c;",
          "3290:   unsigned save = data_offset - 4, trow = 0, tcol = 0, row, col;",
          "3294:   if (meta_offset)",
          "3295:   {",
          "3296:     fseek(ifp, meta_offset, SEEK_SET);",
          "3299:     while (ntags--)",
          "3300:     {",
          "3301:       opcode = get4();",
          "3302:       get4();",
          "3303:       get4();",
          "3305:       {",
          "3306:         fseek(ifp, get4(), SEEK_CUR);",
          "3307:         continue;",
          "3308:       }",
          "3309:       fseek(ifp, 20, SEEK_CUR);",
          "3310:       if ((c = get4()) > 2)",
          "3311:         break;",
          "3312:       fseek(ifp, 12, SEEK_CUR);",
          "3313:       if ((deg = get4()) > 8)",
          "3314:         break;",
          "3315:       for (i = 0; i <= deg && i < 9; i++)",
          "3316:         coeff[i] = getreal(12);",
          "3317:       for (i = 0; i < 256; i++)",
          "3318:       {",
          "3319:         for (tot = j = 0; j <= deg; j++)",
          "3320:           tot += coeff[j] * pow(i / 255.0, (int)j);",
          "3321:         cur[c][i] = tot * 0xffff;",
          "3325:   }",
          "3326:   else",
          "3327:   {",
          "3328:     gamma_curve(1 / 2.4, 12.92, 1, 255);",
          "3329:     FORC3 memcpy(cur[c], curve, sizeof cur[0]);",
          "3330:   }",
          "3331:   cinfo.err = jpeg_std_error(&jerr);",
          "3332:   jpeg_create_decompress(&cinfo);",
          "3333:   while (trow < raw_height)",
          "3334:   {",
          "3335:     fseek(ifp, save += 4, SEEK_SET);",
          "3337:       fseek(ifp, get4(), SEEK_SET);",
          "3339:     if (libraw_internal_data.internal_data.input->jpeg_src(&cinfo) == -1)",
          "3340:     {",
          "3341:       jpeg_destroy_decompress(&cinfo);",
          "3342:       throw LIBRAW_EXCEPTION_DECODE_JPEG;",
          "3343:     }",
          "3345:     jpeg_stdio_src(&cinfo, ifp);",
          "3347:     jpeg_read_header(&cinfo, TRUE);",
          "3348:     jpeg_start_decompress(&cinfo);",
          "3349:     buf = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, cinfo.output_width * 3, 1);",
          "3351:     try",
          "3352:     {",
          "3354:       while (cinfo.output_scanline < cinfo.output_height && (row = trow + cinfo.output_scanline) < height)",
          "3355:       {",
          "3357:         checkCancel();",
          "3359:         jpeg_read_scanlines(&cinfo, buf, 1);",
          "3360:         pixel = (JSAMPLE(*)[3])buf[0];",
          "3361:         for (col = 0; col < cinfo.output_width && tcol + col < width; col++)",
          "3362:         {",
          "3363:           FORC3 image[row * width + tcol + col][c] = cur[c][pixel[col][c]];",
          "3364:         }",
          "3367:     }",
          "3368:     catch (...)",
          "3369:     {",
          "3370:       jpeg_destroy_decompress(&cinfo);",
          "3371:       throw;",
          "3372:     }",
          "3374:     jpeg_abort_decompress(&cinfo);",
          "3378:   jpeg_destroy_decompress(&cinfo);",
          "3385:   static const int mul[4] = {162, 192, 187, 92};",
          "3386:   static const int add[4] = {0, 636, 424, 212};",
          "3390:   for (row = 0; row < height; row++)",
          "3391:   {",
          "3395:     if (fread(pixel, 1, 848, ifp) < 848)",
          "3396:       derror();",
          "3398:     for (col = 0; col < width; col++)",
          "3399:       RAW(row, col) = (ushort)pixel[(col + shift) % 848];",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "3021:   uchar *pixel;",
          "3022:   unsigned row, col;",
          "3026: #ifdef LIBRAW_LIBRARY_BUILD",
          "3028: #endif",
          "3030: #ifdef LIBRAW_LIBRARY_BUILD",
          "3032: #endif",
          "3037: #ifdef LIBRAW_LIBRARY_BUILD",
          "3040:     throw;",
          "3041:   }",
          "3042: #endif",
          "3044:   maximum = curve[0xff];",
          "3045: }",
          "",
          "[Removed Lines]",
          "3024:   pixel = (uchar *) calloc (raw_width, sizeof *pixel);",
          "3025:   merror (pixel, \"eight_bit_load_raw()\");",
          "3027:   try {",
          "3029:   for (row=0; row < raw_height; row++) {",
          "3031:     checkCancel();",
          "3033:     if (fread (pixel, 1, raw_width, ifp) < raw_width) derror();",
          "3034:     for (col=0; col < raw_width; col++)",
          "3035:       RAW(row,col) = curve[pixel[col]];",
          "3036:   }",
          "3038:   } catch(...) {",
          "3039:     free (pixel);",
          "3043:   free (pixel);",
          "",
          "[Added Lines]",
          "3409:   pixel = (uchar *)calloc(raw_width, sizeof *pixel);",
          "3410:   merror(pixel, \"eight_bit_load_raw()\");",
          "3412:   try",
          "3413:   {",
          "3415:     for (row = 0; row < raw_height; row++)",
          "3416:     {",
          "3418:       checkCancel();",
          "3420:       if (fread(pixel, 1, raw_width, ifp) < raw_width)",
          "3421:         derror();",
          "3422:       for (col = 0; col < raw_width; col++)",
          "3423:         RAW(row, col) = curve[pixel[col]];",
          "3424:     }",
          "3426:   }",
          "3427:   catch (...)",
          "3428:   {",
          "3429:     free(pixel);",
          "3433:   free(pixel);",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "3049:   uchar *pixel;",
          "3050:   int row, col, y, cb, cr, rgb[3], c;",
          "3054: #ifdef LIBRAW_LIBRARY_BUILD",
          "3056: #endif",
          "3058: #ifdef LIBRAW_LIBRARY_BUILD",
          "3060: #endif",
          "3072:     }",
          "3074: #ifdef LIBRAW_LIBRARY_BUILD",
          "3077:     throw;",
          "3078:   }",
          "3079: #endif",
          "3081:   maximum = curve[0xff];",
          "3082: }",
          "",
          "[Removed Lines]",
          "3052:   pixel = (uchar *) calloc (raw_width, 2*sizeof *pixel);",
          "3053:   merror (pixel, \"kodak_c330_load_raw()\");",
          "3055:   try {",
          "3057:   for (row=0; row < height; row++) {",
          "3059:     checkCancel();",
          "3061:     if (fread (pixel, raw_width, 2, ifp) < 2) derror();",
          "3062:     if (load_flags && (row & 31) == 31)",
          "3063:       fseek (ifp, raw_width*32, SEEK_CUR);",
          "3064:     for (col=0; col < width; col++) {",
          "3065:       y  = pixel[col*2];",
          "3066:       cb = pixel[(col*2 & -4) | 1] - 128;",
          "3067:       cr = pixel[(col*2 & -4) | 3] - 128;",
          "3068:       rgb[1] = y - ((cb + cr + 2) >> 2);",
          "3069:       rgb[2] = rgb[1] + cb;",
          "3070:       rgb[0] = rgb[1] + cr;",
          "3071:       FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];",
          "3073:   }",
          "3075:   } catch(...) {",
          "3076:     free (pixel);",
          "3080:   free (pixel);",
          "",
          "[Added Lines]",
          "3442:   pixel = (uchar *)calloc(raw_width, 2 * sizeof *pixel);",
          "3443:   merror(pixel, \"kodak_c330_load_raw()\");",
          "3445:   try",
          "3446:   {",
          "3448:     for (row = 0; row < height; row++)",
          "3449:     {",
          "3451:       checkCancel();",
          "3453:       if (fread(pixel, raw_width, 2, ifp) < 2)",
          "3454:         derror();",
          "3455:       if (load_flags && (row & 31) == 31)",
          "3456:         fseek(ifp, raw_width * 32, SEEK_CUR);",
          "3457:       for (col = 0; col < width; col++)",
          "3458:       {",
          "3459:         y = pixel[col * 2];",
          "3460:         cb = pixel[(col * 2 & -4) | 1] - 128;",
          "3461:         cr = pixel[(col * 2 & -4) | 3] - 128;",
          "3462:         rgb[1] = y - ((cb + cr + 2) >> 2);",
          "3463:         rgb[2] = rgb[1] + cb;",
          "3464:         rgb[0] = rgb[1] + cr;",
          "3465:         FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];",
          "3466:       }",
          "3469:   }",
          "3470:   catch (...)",
          "3471:   {",
          "3472:     free(pixel);",
          "3476:   free(pixel);",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "3086:   uchar *pixel;",
          "3087:   int row, col, y, cb, cr, rgb[3], c;",
          "3091: #ifdef LIBRAW_LIBRARY_BUILD",
          "3093: #endif",
          "3095: #ifdef LIBRAW_LIBRARY_BUILD",
          "3097: #endif",
          "3108:     }",
          "3110: #ifdef LIBRAW_LIBRARY_BUILD",
          "3113:     throw;",
          "3114:   }",
          "3115: #endif",
          "3117:   maximum = curve[0xff];",
          "3118: }",
          "3120: void CLASS kodak_262_load_raw()",
          "3121: {",
          "3125:   ushort *huff[2];",
          "3126:   uchar *pixel;",
          "3134:   order = 0x4d4d;",
          "3135:   FORC(ns) strip[c] = get4();",
          "3136: #ifdef LIBRAW_LIBRARY_BUILD",
          "3138: #endif",
          "3140: #ifdef LIBRAW_LIBRARY_BUILD",
          "3142: #endif",
          "3166:     throw;",
          "3167:   }",
          "3168: #endif",
          "3171: }",
          "3174: {",
          "3175:   uchar c, blen[768];",
          "3176:   ushort raw[6];",
          "3180:   save = ftell(ifp);",
          "3181:   bsize = (bsize + 3) & -4;",
          "3183:     c = fgetc(ifp);",
          "3193:       }",
          "3194:       return 1;",
          "3195:     }",
          "3196:   }",
          "3199:     bitbuf += fgetc(ifp);",
          "3200:     bits = 16;",
          "3201:   }",
          "3203:     len = blen[i];",
          "3207:       bits += 32;",
          "3208:     }",
          "3210:     bitbuf >>= len;",
          "3211:     bits -= len;",
          "3213:       diff -= (1 << len) - 1;",
          "3214:     out[i] = diff;",
          "3215:   }",
          "",
          "[Removed Lines]",
          "3089:   pixel = (uchar *) calloc (raw_width, 3*sizeof *pixel);",
          "3090:   merror (pixel, \"kodak_c603_load_raw()\");",
          "3092:   try {",
          "3094:   for (row=0; row < height; row++) {",
          "3096:     checkCancel();",
          "3098:     if (~row & 1)",
          "3099:       if (fread (pixel, raw_width, 3, ifp) < 3) derror();",
          "3100:     for (col=0; col < width; col++) {",
          "3101:       y  = pixel[width*2*(row & 1) + col];",
          "3102:       cb = pixel[width + (col & -2)]   - 128;",
          "3103:       cr = pixel[width + (col & -2)+1] - 128;",
          "3104:       rgb[1] = y - ((cb + cr + 2) >> 2);",
          "3105:       rgb[2] = rgb[1] + cb;",
          "3106:       rgb[0] = rgb[1] + cr;",
          "3107:       FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];",
          "3109:   }",
          "3111:   } catch(...) {",
          "3112:     free (pixel);",
          "3116:   free (pixel);",
          "3122:   static const uchar kodak_tree[2][26] =",
          "3123:   { { 0,1,5,1,1,2,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 },",
          "3124:     { 0,3,1,1,1,1,1,2,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 } };",
          "3127:   int *strip, ns, c, row, col, chess, pi=0, pi1, pi2, pred, val;",
          "3129:   FORC(2) huff[c] = make_decoder (kodak_tree[c]);",
          "3130:   ns = (raw_height+63) >> 5;",
          "3131:   pixel = (uchar *) malloc (raw_width*32 + ns*4);",
          "3132:   merror (pixel, \"kodak_262_load_raw()\");",
          "3133:   strip = (int *) (pixel + raw_width*32);",
          "3137:   try {",
          "3139:   for (row=0; row < raw_height; row++) {",
          "3141:     checkCancel();",
          "3143:     if ((row & 31) == 0) {",
          "3144:       fseek (ifp, strip[row >> 5], SEEK_SET);",
          "3145:       getbits(-1);",
          "3146:       pi = 0;",
          "3147:     }",
          "3148:     for (col=0; col < raw_width; col++) {",
          "3149:       chess = (row + col) & 1;",
          "3150:       pi1 = chess ? pi-2           : pi-raw_width-1;",
          "3151:       pi2 = chess ? pi-2*raw_width : pi-raw_width+1;",
          "3152:       if (col <= chess) pi1 = -1;",
          "3153:       if (pi1 < 0) pi1 = pi2;",
          "3154:       if (pi2 < 0) pi2 = pi1;",
          "3155:       if (pi1 < 0 && col > 1) pi1 = pi2 = pi-2;",
          "3156:       pred = (pi1 < 0) ? 0 : (pixel[pi1] + pixel[pi2]) >> 1;",
          "3157:       pixel[pi] = val = pred + ljpeg_diff (huff[chess]);",
          "3158:       if (val >> 8) derror();",
          "3159:       val = curve[pixel[pi++]];",
          "3160:       RAW(row,col) = val;",
          "3161:     }",
          "3162:   }",
          "3163: #ifdef LIBRAW_LIBRARY_BUILD",
          "3164:   } catch(...) {",
          "3165:     free (pixel);",
          "3169:   free (pixel);",
          "3170:   FORC(2) free (huff[c]);",
          "3173: int CLASS kodak_65000_decode (short *out, int bsize)",
          "3177:   INT64 bitbuf=0;",
          "3178:   int save, bits=0, i, j, len, diff;",
          "3182:   for (i=0; i < bsize; i+=2) {",
          "3184:     if ((blen[i  ] = c & 15) > 12 ||",
          "3185:  (blen[i+1] = c >> 4) > 12 ) {",
          "3186:       fseek (ifp, save, SEEK_SET);",
          "3187:       for (i=0; i < bsize; i+=8) {",
          "3188:  read_shorts (raw, 6);",
          "3189:  out[i  ] = raw[0] >> 12 << 8 | raw[2] >> 12 << 4 | raw[4] >> 12;",
          "3190:  out[i+1] = raw[1] >> 12 << 8 | raw[3] >> 12 << 4 | raw[5] >> 12;",
          "3191:  for (j=0; j < 6; j++)",
          "3192:    out[i+2+j] = raw[j] & 0xfff;",
          "3197:   if ((bsize & 7) == 4) {",
          "3198:     bitbuf  = fgetc(ifp) << 8;",
          "3202:   for (i=0; i < bsize; i++) {",
          "3204:     if (bits < len) {",
          "3205:       for (j=0; j < 32; j+=8)",
          "3206:  bitbuf += (INT64) fgetc(ifp) << (bits+(j^8));",
          "3209:     diff = bitbuf & (0xffff >> (16-len));",
          "3212:     if ((diff & (1 << (len-1))) == 0)",
          "",
          "[Added Lines]",
          "3485:   pixel = (uchar *)calloc(raw_width, 3 * sizeof *pixel);",
          "3486:   merror(pixel, \"kodak_c603_load_raw()\");",
          "3488:   try",
          "3489:   {",
          "3491:     for (row = 0; row < height; row++)",
          "3492:     {",
          "3494:       checkCancel();",
          "3496:       if (~row & 1)",
          "3497:         if (fread(pixel, raw_width, 3, ifp) < 3)",
          "3498:           derror();",
          "3499:       for (col = 0; col < width; col++)",
          "3500:       {",
          "3501:         y = pixel[width * 2 * (row & 1) + col];",
          "3502:         cb = pixel[width + (col & -2)] - 128;",
          "3503:         cr = pixel[width + (col & -2) + 1] - 128;",
          "3504:         rgb[1] = y - ((cb + cr + 2) >> 2);",
          "3505:         rgb[2] = rgb[1] + cb;",
          "3506:         rgb[0] = rgb[1] + cr;",
          "3507:         FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];",
          "3508:       }",
          "3511:   }",
          "3512:   catch (...)",
          "3513:   {",
          "3514:     free(pixel);",
          "3518:   free(pixel);",
          "3524:   static const uchar kodak_tree[2][26] = {",
          "3525:       {0, 1, 5, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9},",
          "3526:       {0, 3, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9}};",
          "3529:   int *strip, ns, c, row, col, chess, pi = 0, pi1, pi2, pred, val;",
          "3531:   FORC(2) huff[c] = make_decoder(kodak_tree[c]);",
          "3532:   ns = (raw_height + 63) >> 5;",
          "3533:   pixel = (uchar *)malloc(raw_width * 32 + ns * 4);",
          "3534:   merror(pixel, \"kodak_262_load_raw()\");",
          "3535:   strip = (int *)(pixel + raw_width * 32);",
          "3539:   try",
          "3540:   {",
          "3542:     for (row = 0; row < raw_height; row++)",
          "3543:     {",
          "3545:       checkCancel();",
          "3547:       if ((row & 31) == 0)",
          "3548:       {",
          "3549:         fseek(ifp, strip[row >> 5], SEEK_SET);",
          "3550:         getbits(-1);",
          "3551:         pi = 0;",
          "3552:       }",
          "3553:       for (col = 0; col < raw_width; col++)",
          "3554:       {",
          "3555:         chess = (row + col) & 1;",
          "3556:         pi1 = chess ? pi - 2 : pi - raw_width - 1;",
          "3557:         pi2 = chess ? pi - 2 * raw_width : pi - raw_width + 1;",
          "3558:         if (col <= chess)",
          "3559:           pi1 = -1;",
          "3560:         if (pi1 < 0)",
          "3561:           pi1 = pi2;",
          "3562:         if (pi2 < 0)",
          "3563:           pi2 = pi1;",
          "3564:         if (pi1 < 0 && col > 1)",
          "3565:           pi1 = pi2 = pi - 2;",
          "3566:         pred = (pi1 < 0) ? 0 : (pixel[pi1] + pixel[pi2]) >> 1;",
          "3567:         pixel[pi] = val = pred + ljpeg_diff(huff[chess]);",
          "3568:         if (val >> 8)",
          "3569:           derror();",
          "3570:         val = curve[pixel[pi++]];",
          "3571:         RAW(row, col) = val;",
          "3572:       }",
          "3573:     }",
          "3574: #ifdef LIBRAW_LIBRARY_BUILD",
          "3575:   }",
          "3576:   catch (...)",
          "3577:   {",
          "3578:     free(pixel);",
          "3582:   free(pixel);",
          "3583:   FORC(2) free(huff[c]);",
          "3586: int CLASS kodak_65000_decode(short *out, int bsize)",
          "3590:   INT64 bitbuf = 0;",
          "3591:   int save, bits = 0, i, j, len, diff;",
          "3595:   for (i = 0; i < bsize; i += 2)",
          "3596:   {",
          "3598:     if ((blen[i] = c & 15) > 12 || (blen[i + 1] = c >> 4) > 12)",
          "3599:     {",
          "3600:       fseek(ifp, save, SEEK_SET);",
          "3601:       for (i = 0; i < bsize; i += 8)",
          "3602:       {",
          "3603:         read_shorts(raw, 6);",
          "3604:         out[i] = raw[0] >> 12 << 8 | raw[2] >> 12 << 4 | raw[4] >> 12;",
          "3605:         out[i + 1] = raw[1] >> 12 << 8 | raw[3] >> 12 << 4 | raw[5] >> 12;",
          "3606:         for (j = 0; j < 6; j++)",
          "3607:           out[i + 2 + j] = raw[j] & 0xfff;",
          "3612:   if ((bsize & 7) == 4)",
          "3613:   {",
          "3614:     bitbuf = fgetc(ifp) << 8;",
          "3618:   for (i = 0; i < bsize; i++)",
          "3619:   {",
          "3621:     if (bits < len)",
          "3622:     {",
          "3623:       for (j = 0; j < 32; j += 8)",
          "3624:         bitbuf += (INT64)fgetc(ifp) << (bits + (j ^ 8));",
          "3627:     diff = bitbuf & (0xffff >> (16 - len));",
          "3630:     if ((diff & (1 << (len - 1))) == 0)",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "3221:   short buf[256];",
          "3222:   int row, col, len, pred[2], ret, i;",
          "3225:   {",
          "3226: #ifdef LIBRAW_LIBRARY_BUILD",
          "3227:     checkCancel();",
          "3228: #endif",
          "3230:       pred[0] = pred[1] = 0;",
          "3236:     }",
          "3237:   }",
          "3238: }",
          "",
          "[Removed Lines]",
          "3224:   for (row=0; row < height; row++)",
          "3229:     for (col=0; col < width; col+=256) {",
          "3231:       len = MIN (256, width-col);",
          "3232:       ret = kodak_65000_decode (buf, len);",
          "3233:       for (i=0; i < len; i++)",
          "3234:  if ((RAW(row,col+i) = curve[ret ? buf[i] :",
          "3235:   (pred[i & 1] += buf[i])]) >> 12) derror();",
          "",
          "[Added Lines]",
          "3642:   for (row = 0; row < height; row++)",
          "3647:     for (col = 0; col < width; col += 256)",
          "3648:     {",
          "3650:       len = MIN(256, width - col);",
          "3651:       ret = kodak_65000_decode(buf, len);",
          "3652:       for (i = 0; i < len; i++)",
          "3653:         if ((RAW(row, col + i) = curve[ret ? buf[i] : (pred[i & 1] += buf[i])]) >> 12)",
          "3654:           derror();",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "3243:   int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];",
          "3244:   ushort *ip;",
          "3249:   {",
          "3250: #ifdef LIBRAW_LIBRARY_BUILD",
          "3251:     checkCancel();",
          "3252: #endif",
          "3256:       y[0][1] = y[1][1] = cb = cr = 0;",
          "3269:       }",
          "3270:     }",
          "3271:   }",
          "",
          "[Removed Lines]",
          "3246:   if (!image) return;",
          "3247:   unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17)?load_flags:10;",
          "3248:   for (row=0; row < height; row+=2)",
          "3253:     for (col=0; col < width; col+=128) {",
          "3254:       len = MIN (128, width-col);",
          "3255:       kodak_65000_decode (buf, len*3);",
          "3257:       for (bp=buf, i=0; i < len; i+=2, bp+=2) {",
          "3258:  cb += bp[4];",
          "3259:  cr += bp[5];",
          "3260:  rgb[1] = -((cb + cr + 2) >> 2);",
          "3261:  rgb[2] = rgb[1] + cb;",
          "3262:  rgb[0] = rgb[1] + cr;",
          "3263:  for (j=0; j < 2; j++)",
          "3264:    for (k=0; k < 2; k++) {",
          "3265:      if ((y[j][k] = y[j][k^1] + *bp++) >> bits) derror();",
          "3266:      ip = image[(row+j)*width + col+i+k];",
          "3267:      FORC3 ip[c] = curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];",
          "3268:    }",
          "",
          "[Added Lines]",
          "3665:   if (!image)",
          "3666:     return;",
          "3667:   unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17) ? load_flags : 10;",
          "3668:   for (row = 0; row < height; row += 2)",
          "3673:     for (col = 0; col < width; col += 128)",
          "3674:     {",
          "3675:       len = MIN(128, width - col);",
          "3676:       kodak_65000_decode(buf, len * 3);",
          "3678:       for (bp = buf, i = 0; i < len; i += 2, bp += 2)",
          "3679:       {",
          "3680:         cb += bp[4];",
          "3681:         cr += bp[5];",
          "3682:         rgb[1] = -((cb + cr + 2) >> 2);",
          "3683:         rgb[2] = rgb[1] + cb;",
          "3684:         rgb[0] = rgb[1] + cr;",
          "3685:         for (j = 0; j < 2; j++)",
          "3686:           for (k = 0; k < 2; k++)",
          "3687:           {",
          "3688:             if ((y[j][k] = y[j][k ^ 1] + *bp++) >> bits)",
          "3689:               derror();",
          "3690:             ip = image[(row + j) * width + col + i + k];",
          "3691:             FORC3 ip[c] = curve[LIM(y[j][k] + rgb[c], 0, 0xfff)];",
          "3692:           }",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "3274: void CLASS kodak_rgb_load_raw()",
          "3275: {",
          "3276:   short buf[768], *bp;",
          "3281:   {",
          "3282: #ifdef LIBRAW_LIBRARY_BUILD",
          "3283:     checkCancel();",
          "3284: #endif",
          "3290: #ifdef LIBRAW_LIBRARY_BUILD",
          "3295:         else",
          "3296: #endif",
          "3297:           FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();",
          "",
          "[Removed Lines]",
          "3277:   int row, col, len, c, i, rgb[3],ret;",
          "3278:   ushort *ip=image[0];",
          "3280:   for (row=0; row < height; row++)",
          "3285:     for (col=0; col < width; col+=256) {",
          "3286:       len = MIN (256, width-col);",
          "3287:       ret = kodak_65000_decode (buf, len*3);",
          "3288:       memset (rgb, 0, sizeof rgb);",
          "3289:       for (bp=buf, i=0; i < len; i++, ip+=4)",
          "3291:         if(load_flags == 12)",
          "3292:           {",
          "3293:             FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);",
          "3294:           }",
          "",
          "[Added Lines]",
          "3701:   int row, col, len, c, i, rgb[3], ret;",
          "3702:   ushort *ip = image[0];",
          "3704:   for (row = 0; row < height; row++)",
          "3709:     for (col = 0; col < width; col += 256)",
          "3710:     {",
          "3711:       len = MIN(256, width - col);",
          "3712:       ret = kodak_65000_decode(buf, len * 3);",
          "3713:       memset(rgb, 0, sizeof rgb);",
          "3714:       for (bp = buf, i = 0; i < len; i++, ip += 4)",
          "3716:         if (load_flags == 12)",
          "3717:         {",
          "3718:           FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);",
          "3719:         }",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "3303: {",
          "3304:   int row, col;",
          "3305:   colors = thumb_misc >> 5;",
          "3309:   maximum = (1 << (thumb_misc & 31)) - 1;",
          "3310: }",
          "3313: {",
          "3314: #ifndef LIBRAW_NOTHREADS",
          "3315: #define pad tls->sony_decrypt.pad",
          "3317: #else",
          "3318:   static unsigned pad[128], p;",
          "3319: #endif",
          "3322:       pad[p] = key = key * 48828125 + 1;",
          "3327:       pad[p] = htonl(pad[p]);",
          "3328:   }",
          "3329:   while (len--)",
          "3334: #ifndef LIBRAW_NOTHREADS",
          "3335: #undef pad",
          "3336: #undef p",
          "",
          "[Removed Lines]",
          "3306:   for (row=0; row < height; row++)",
          "3307:     for (col=0; col < width; col++)",
          "3308:       read_shorts (image[row*width+col], colors);",
          "3312: void CLASS sony_decrypt (unsigned *data, int len, int start, int key)",
          "3316: #define p   tls->sony_decrypt.p",
          "3320:   if (start) {",
          "3321:     for (p=0; p < 4; p++)",
          "3323:     pad[3] = pad[3] << 1 | (pad[0]^pad[2]) >> 31;",
          "3324:     for (p=4; p < 127; p++)",
          "3325:       pad[p] = (pad[p-4]^pad[p-2]) << 1 | (pad[p-3]^pad[p-1]) >> 31;",
          "3326:     for (p=0; p < 127; p++)",
          "3330:     {",
          "3332:       p++;",
          "3333:     }",
          "",
          "[Added Lines]",
          "3731:   for (row = 0; row < height; row++)",
          "3732:     for (col = 0; col < width; col++)",
          "3733:       read_shorts(image[row * width + col], colors);",
          "3737: void CLASS sony_decrypt(unsigned *data, int len, int start, int key)",
          "3741: #define p tls->sony_decrypt.p",
          "3745:   if (start)",
          "3746:   {",
          "3747:     for (p = 0; p < 4; p++)",
          "3749:     pad[3] = pad[3] << 1 | (pad[0] ^ pad[2]) >> 31;",
          "3750:     for (p = 4; p < 127; p++)",
          "3751:       pad[p] = (pad[p - 4] ^ pad[p - 2]) << 1 | (pad[p - 3] ^ pad[p - 1]) >> 31;",
          "3752:     for (p = 0; p < 127; p++)",
          "3756:   {",
          "3758:     p++;",
          "3759:   }",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "3343:   ushort *pixel;",
          "3344:   unsigned i, key, row, col;",
          "3348:   order = 0x4d4d;",
          "3349:   key = get4();",
          "3354:     key = key << 8 | head[i];",
          "3357: #ifdef LIBRAW_LIBRARY_BUILD",
          "3358:     checkCancel();",
          "3359: #endif",
          "3365:   }",
          "3366:   maximum = 0x3ff0;",
          "3367: }",
          "",
          "[Removed Lines]",
          "3346:   fseek (ifp, 200896, SEEK_SET);",
          "3347:   fseek (ifp, (unsigned) fgetc(ifp)*4 - 1, SEEK_CUR);",
          "3350:   fseek (ifp, 164600, SEEK_SET);",
          "3351:   fread (head, 1, 40, ifp);",
          "3352:   sony_decrypt ((unsigned *) head, 10, 1, key);",
          "3353:   for (i=26; i-- > 22; )",
          "3355:   fseek (ifp, data_offset, SEEK_SET);",
          "3356:   for (row=0; row < raw_height; row++) {",
          "3360:     pixel = raw_image + row*raw_width;",
          "3361:     if (fread (pixel, 2, raw_width, ifp) < raw_width) derror();",
          "3362:     sony_decrypt ((unsigned *) pixel, raw_width/2, !row, key);",
          "3363:     for (col=0; col < raw_width; col++)",
          "3364:       if ((pixel[col] = ntohs(pixel[col])) >> 14) derror();",
          "",
          "[Added Lines]",
          "3772:   fseek(ifp, 200896, SEEK_SET);",
          "3773:   fseek(ifp, (unsigned)fgetc(ifp) * 4 - 1, SEEK_CUR);",
          "3776:   fseek(ifp, 164600, SEEK_SET);",
          "3777:   fread(head, 1, 40, ifp);",
          "3778:   sony_decrypt((unsigned *)head, 10, 1, key);",
          "3779:   for (i = 26; i-- > 22;)",
          "3781:   fseek(ifp, data_offset, SEEK_SET);",
          "3782:   for (row = 0; row < raw_height; row++)",
          "3783:   {",
          "3787:     pixel = raw_image + row * raw_width;",
          "3788:     if (fread(pixel, 2, raw_width, ifp) < raw_width)",
          "3789:       derror();",
          "3790:     sony_decrypt((unsigned *)pixel, raw_width / 2, !row, key);",
          "3791:     for (col = 0; col < raw_width; col++)",
          "3792:       if ((pixel[col] = ntohs(pixel[col])) >> 14)",
          "3793:         derror();",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "3369: void CLASS sony_arw_load_raw()",
          "3370: {",
          "3371:   ushort huff[32770];",
          "3377:   huff[0] = 15;",
          "3379:     FORC(32768 >> (tab[i] >> 8)) huff[++n] = tab[i];",
          "3380:   getbits(-1);",
          "3382:   {",
          "3383: #ifdef LIBRAW_LIBRARY_BUILD",
          "3384:     checkCancel();",
          "3385: #endif",
          "3390:     }",
          "3391:   }",
          "3392: }",
          "",
          "[Removed Lines]",
          "3372:   static const ushort tab[18] =",
          "3373:   { 0xf11,0xf10,0xe0f,0xd0e,0xc0d,0xb0c,0xa0b,0x90a,0x809,",
          "3374:     0x708,0x607,0x506,0x405,0x304,0x303,0x300,0x202,0x201 };",
          "3375:   int i, c, n, col, row, sum=0;",
          "3378:   for (n=i=0; i < 18; i++)",
          "3381:   for (col = raw_width; col--; )",
          "3386:     for (row=0; row < raw_height+1; row+=2) {",
          "3387:       if (row == raw_height) row = 1;",
          "3388:       if ((sum += ljpeg_diff(huff)) >> 12) derror();",
          "3389:       if (row < height) RAW(row,col) = sum;",
          "",
          "[Added Lines]",
          "3801:   static const ushort tab[18] = {0xf11, 0xf10, 0xe0f, 0xd0e, 0xc0d, 0xb0c, 0xa0b, 0x90a, 0x809,",
          "3802:                                  0x708, 0x607, 0x506, 0x405, 0x304, 0x303, 0x300, 0x202, 0x201};",
          "3803:   int i, c, n, col, row, sum = 0;",
          "3806:   for (n = i = 0; i < 18; i++)",
          "3809:   for (col = raw_width; col--;)",
          "3814:     for (row = 0; row < raw_height + 1; row += 2)",
          "3815:     {",
          "3816:       if (row == raw_height)",
          "3817:         row = 1;",
          "3818:       if ((sum += ljpeg_diff(huff)) >> 12)",
          "3819:         derror();",
          "3820:       if (row < height)",
          "3821:         RAW(row, col) = sum;",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "3397:   ushort pix[16];",
          "3398:   int row, col, val, max, min, imax, imin, sh, bit, i;",
          "3402: #ifdef LIBRAW_LIBRARY_BUILD",
          "3404: #endif",
          "3406: #ifdef LIBRAW_LIBRARY_BUILD",
          "3408: #endif",
          "3428:               bit += 7;",
          "3429:             }",
          "3430:         }",
          "3432:         {",
          "3437:         }",
          "3439:         {",
          "3446:               bit += 7;",
          "3447:             }",
          "3448:         }",
          "3450:         {",
          "3457:               bit += 7;",
          "3458:             }",
          "3459:         }",
          "3460: #else",
          "3470: #endif",
          "3472: #ifdef LIBRAW_LIBRARY_BUILD",
          "3474:         {",
          "3482:         }",
          "3484:         {",
          "3487:         }",
          "3488: #else",
          "3491: #endif",
          "3493:     }",
          "3495: #ifdef LIBRAW_LIBRARY_BUILD",
          "3498:     throw;",
          "3499:   }",
          "3502: #endif",
          "3504: }",
          "3506: void CLASS samsung_load_raw()",
          "",
          "[Removed Lines]",
          "3400:   data = (uchar *) malloc (raw_width+1);",
          "3401:   merror (data, \"sony_arw2_load_raw()\");",
          "3403:   try {",
          "3405:   for (row=0; row < height; row++) {",
          "3407:     checkCancel();",
          "3409:     fread (data, 1, raw_width, ifp);",
          "3410:     for (dp=data, col=0; col < raw_width-30; dp+=16) {",
          "3411:       max = 0x7ff & (val = sget4(dp));",
          "3412:       min = 0x7ff & val >> 11;",
          "3413:       imax = 0x0f & val >> 22;",
          "3414:       imin = 0x0f & val >> 26;",
          "3415:       for (sh=0; sh < 4 && 0x80 << sh <= max-min; sh++);",
          "3416: #ifdef LIBRAW_LIBRARY_BUILD",
          "3418:       if(! (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_ALLFLAGS) // no flag set",
          "3419:          || (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)",
          "3420:          )",
          "3421:         {",
          "3422:           for (bit=30, i=0; i < 16; i++)",
          "3423:             if      (i == imax) pix[i] = max;",
          "3424:             else if (i == imin) pix[i] = min;",
          "3425:             else {",
          "3426:               pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;",
          "3427:               if (pix[i] > 0x7ff) pix[i] = 0x7ff;",
          "3431:       else if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_BASEONLY)",
          "3433:           for (bit=30, i=0; i < 16; i++)",
          "3434:             if      (i == imax) pix[i] = max;",
          "3435:             else if (i == imin) pix[i] = min;",
          "3436:             else pix[i]=0;",
          "3438:       else if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAONLY)",
          "3440:           for (bit=30, i=0; i < 16; i++)",
          "3441:             if      (i == imax) pix[i] = 0;",
          "3442:             else if (i == imin) pix[i] = 0;",
          "3443:             else {",
          "3444:               pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;",
          "3445:               if (pix[i] > 0x7ff) pix[i] = 0x7ff;",
          "3449:       else if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE)",
          "3451:           for (bit=30, i=0; i < 16; i++)",
          "3452:             if      (i == imax) pix[i] = 0;",
          "3453:             else if (i == imin) pix[i] = 0;",
          "3454:             else {",
          "3455:               pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh);",
          "3456:               if (pix[i] > 0x7ff) pix[i] = 0x7ff;",
          "3462:       for (bit=30, i=0; i < 16; i++)",
          "3463:  if      (i == imax) pix[i] = max;",
          "3464:  else if (i == imin) pix[i] = min;",
          "3465:  else {",
          "3466:    pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;",
          "3467:    if (pix[i] > 0x7ff) pix[i] = 0x7ff;",
          "3468:    bit += 7;",
          "3469:  }",
          "3473:       if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)",
          "3475:           for (i=0; i < 16; i++, col+=2)",
          "3476:             {",
          "3477:               unsigned slope = pix[i] < 1001? 2 : curve[pix[i]<<1]-curve[(pix[i]<<1)-2];",
          "3478:               unsigned step = 1 << sh;",
          "3479:               RAW(row,col)=curve[pix[i]<<1]>black+imgdata.params.sony_arw2_posterization_thr?",
          "3480:                 LIM(((slope*step*1000)/(curve[pix[i]<<1]-black)),0,10000):0;",
          "3481:             }",
          "3483:       else",
          "3485:           for (i=0; i < 16; i++, col+=2)",
          "3486:             RAW(row,col) = curve[pix[i] << 1];",
          "3489:       for (i=0; i < 16; i++, col+=2)",
          "3490:  RAW(row,col) = curve[pix[i] << 1] >> 2;",
          "3492:       col -= col & 1 ? 1:31;",
          "3494:   }",
          "3496:   } catch(...) {",
          "3497:     free (data);",
          "3500:   if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)",
          "3501:     maximum=10000;",
          "3503:   free (data);",
          "",
          "[Added Lines]",
          "3832:   data = (uchar *)malloc(raw_width + 1);",
          "3833:   merror(data, \"sony_arw2_load_raw()\");",
          "3835:   try",
          "3836:   {",
          "3838:     for (row = 0; row < height; row++)",
          "3839:     {",
          "3841:       checkCancel();",
          "3843:       fread(data, 1, raw_width, ifp);",
          "3844:       for (dp = data, col = 0; col < raw_width - 30; dp += 16)",
          "3845:       {",
          "3846:         max = 0x7ff & (val = sget4(dp));",
          "3847:         min = 0x7ff & val >> 11;",
          "3848:         imax = 0x0f & val >> 22;",
          "3849:         imin = 0x0f & val >> 26;",
          "3850:         for (sh = 0; sh < 4 && 0x80 << sh <= max - min; sh++)",
          "3851:           ;",
          "3852: #ifdef LIBRAW_LIBRARY_BUILD",
          "3854:         if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_ALLFLAGS) // no flag set",
          "3855:             || (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE))",
          "3856:         {",
          "3857:           for (bit = 30, i = 0; i < 16; i++)",
          "3858:             if (i == imax)",
          "3859:               pix[i] = max;",
          "3860:             else if (i == imin)",
          "3861:               pix[i] = min;",
          "3862:             else",
          "3863:             {",
          "3864:               pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;",
          "3865:               if (pix[i] > 0x7ff)",
          "3866:                 pix[i] = 0x7ff;",
          "3870:         else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_BASEONLY)",
          "3872:           for (bit = 30, i = 0; i < 16; i++)",
          "3873:             if (i == imax)",
          "3874:               pix[i] = max;",
          "3875:             else if (i == imin)",
          "3876:               pix[i] = min;",
          "3877:             else",
          "3878:               pix[i] = 0;",
          "3880:         else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAONLY)",
          "3882:           for (bit = 30, i = 0; i < 16; i++)",
          "3883:             if (i == imax)",
          "3884:               pix[i] = 0;",
          "3885:             else if (i == imin)",
          "3886:               pix[i] = 0;",
          "3887:             else",
          "3888:             {",
          "3889:               pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;",
          "3890:               if (pix[i] > 0x7ff)",
          "3891:                 pix[i] = 0x7ff;",
          "3895:         else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE)",
          "3897:           for (bit = 30, i = 0; i < 16; i++)",
          "3898:             if (i == imax)",
          "3899:               pix[i] = 0;",
          "3900:             else if (i == imin)",
          "3901:               pix[i] = 0;",
          "3902:             else",
          "3903:             {",
          "3904:               pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh);",
          "3905:               if (pix[i] > 0x7ff)",
          "3906:                 pix[i] = 0x7ff;",
          "3912:       for (bit = 30, i = 0; i < 16; i++)",
          "3913:         if (i == imax)",
          "3914:           pix[i] = max;",
          "3915:         else if (i == imin)",
          "3916:           pix[i] = min;",
          "3917:         else",
          "3918:         {",
          "3919:           pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;",
          "3920:           if (pix[i] > 0x7ff)",
          "3921:             pix[i] = 0x7ff;",
          "3922:           bit += 7;",
          "3923:         }",
          "3927:         if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)",
          "3929:           for (i = 0; i < 16; i++, col += 2)",
          "3930:           {",
          "3931:             unsigned slope = pix[i] < 1001 ? 2 : curve[pix[i] << 1] - curve[(pix[i] << 1) - 2];",
          "3932:             unsigned step = 1 << sh;",
          "3933:             RAW(row, col) = curve[pix[i] << 1] > black + imgdata.params.sony_arw2_posterization_thr",
          "3934:                                 ? LIM(((slope * step * 1000) / (curve[pix[i] << 1] - black)), 0, 10000)",
          "3935:                                 : 0;",
          "3936:           }",
          "3938:         else",
          "3940:           for (i = 0; i < 16; i++, col += 2)",
          "3941:             RAW(row, col) = curve[pix[i] << 1];",
          "3944:       for (i = 0; i < 16; i++, col += 2)",
          "3945:         RAW(row, col) = curve[pix[i] << 1] >> 2;",
          "3947:         col -= col & 1 ? 1 : 31;",
          "3948:       }",
          "3951:   }",
          "3952:   catch (...)",
          "3953:   {",
          "3954:     free(data);",
          "3957:   if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)",
          "3958:     maximum = 10000;",
          "3960:   free(data);",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "3508:   int row, col, c, i, dir, op[4], len[4];",
          "3510:   order = 0x4949;",
          "3512: #ifdef LIBRAW_LIBRARY_BUILD",
          "3513:     checkCancel();",
          "3514: #endif",
          "3517:     ph1_bits(-1);",
          "3520:       dir = ph1_bits(1);",
          "3521:       FORC4 op[c] = ph1_bits(2);",
          "3526:       }",
          "3532:       }",
          "3533:     }",
          "3534:   }",
          "3538: }",
          "3540: void CLASS samsung2_load_raw()",
          "3541: {",
          "3546:   int i, c, n, row, col, diff;",
          "3548:   huff[0] = 10;",
          "3550:     FORC(1024 >> (tab[i] >> 8)) huff[++n] = tab[i];",
          "3551:   getbits(-1);",
          "3553:   {",
          "3554: #ifdef LIBRAW_LIBRARY_BUILD",
          "3555:     checkCancel();",
          "3556: #endif",
          "3563:     }",
          "3564:   }",
          "3565: }",
          "",
          "[Removed Lines]",
          "3511:   for (row=0; row < raw_height; row++) {",
          "3515:     fseek (ifp, strip_offset+row*4, SEEK_SET);",
          "3516:     fseek (ifp, data_offset+get4(), SEEK_SET);",
          "3518:     FORC4 len[c] = row < 2 ? 7:4;",
          "3519:     for (col=0; col < raw_width; col+=16) {",
          "3522:       FORC4 switch (op[c]) {",
          "3523:  case 3: len[c] = ph1_bits(4); break;",
          "3524:  case 2: len[c]--;  break;",
          "3525:  case 1: len[c]++;",
          "3527:       for (c=0; c < 16; c+=2) {",
          "3528:  i = len[((c & 1) << 1) | (c >> 3)];",
          "3529:         RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +",
          "3530:    (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);",
          "3531:  if (c == 14) c = -1;",
          "3535:   for (row=0; row < raw_height-1; row+=2)",
          "3536:     for (col=0; col < raw_width-1; col+=2)",
          "3537:       SWAP (RAW(row,col+1), RAW(row+1,col));",
          "3542:   static const ushort tab[14] =",
          "3543:   { 0x304,0x307,0x206,0x205,0x403,0x600,0x709,",
          "3544:     0x80a,0x90b,0xa0c,0xa0d,0x501,0x408,0x402 };",
          "3545:   ushort huff[1026], vpred[2][2] = {{0,0},{0,0}}, hpred[2];",
          "3549:   for (n=i=0; i < 14; i++)",
          "3552:   for (row=0; row < raw_height; row++)",
          "3557:     for (col=0; col < raw_width; col++) {",
          "3558:       diff = ljpeg_diff (huff);",
          "3559:       if (col < 2) hpred[col] = vpred[row & 1][col] += diff;",
          "3560:       else    hpred[col & 1] += diff;",
          "3561:       RAW(row,col) = hpred[col & 1];",
          "3562:       if (hpred[col & 1] >> tiff_bps) derror();",
          "",
          "[Added Lines]",
          "3968:   for (row = 0; row < raw_height; row++)",
          "3969:   {",
          "3973:     fseek(ifp, strip_offset + row * 4, SEEK_SET);",
          "3974:     fseek(ifp, data_offset + get4(), SEEK_SET);",
          "3976:     FORC4 len[c] = row < 2 ? 7 : 4;",
          "3977:     for (col = 0; col < raw_width; col += 16)",
          "3978:     {",
          "3981:       FORC4 switch (op[c])",
          "3982:       {",
          "3983:       case 3:",
          "3984:         len[c] = ph1_bits(4);",
          "3985:         break;",
          "3986:       case 2:",
          "3987:         len[c]--;",
          "3988:         break;",
          "3989:       case 1:",
          "3990:         len[c]++;",
          "3992:       for (c = 0; c < 16; c += 2)",
          "3993:       {",
          "3994:         i = len[((c & 1) << 1) | (c >> 3)];",
          "3995:         RAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) +",
          "3996:                             (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);",
          "3997:         if (c == 14)",
          "3998:           c = -1;",
          "4002:   for (row = 0; row < raw_height - 1; row += 2)",
          "4003:     for (col = 0; col < raw_width - 1; col += 2)",
          "4004:       SWAP(RAW(row, col + 1), RAW(row + 1, col));",
          "4009:   static const ushort tab[14] = {0x304, 0x307, 0x206, 0x205, 0x403, 0x600, 0x709,",
          "4010:                                  0x80a, 0x90b, 0xa0c, 0xa0d, 0x501, 0x408, 0x402};",
          "4011:   ushort huff[1026], vpred[2][2] = {{0, 0}, {0, 0}}, hpred[2];",
          "4015:   for (n = i = 0; i < 14; i++)",
          "4018:   for (row = 0; row < raw_height; row++)",
          "4023:     for (col = 0; col < raw_width; col++)",
          "4024:     {",
          "4025:       diff = ljpeg_diff(huff);",
          "4026:       if (col < 2)",
          "4027:         hpred[col] = vpred[row & 1][col] += diff;",
          "4028:       else",
          "4029:         hpred[col & 1] += diff;",
          "4030:       RAW(row, col) = hpred[col & 1];",
          "4031:       if (hpred[col & 1] >> tiff_bps)",
          "4032:         derror();",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "3570:   ushort lent[3][2], len[4], *prow[2];",
          "3572:   order = 0x4949;",
          "3574:   opt = fgetc(ifp);",
          "3577: #ifdef LIBRAW_LIBRARY_BUILD",
          "3578:     checkCancel();",
          "3579: #endif",
          "3581:     ph1_bits(-1);",
          "3590:       }",
          "3591:       if (opt & 2)",
          "3593:       else if (!ph1_bits(1))",
          "3603:       }",
          "3614:       }",
          "3615:     }",
          "3616:   }",
          "3617: }",
          "3623: {",
          "3629:   int pix, s, count, bin, next, i, sym[3];",
          "3634:   getbits(-1);",
          "3639:       data = data << nbits | getbits(nbits);",
          "3640:       if (carry < 0)",
          "3642:       while (--nbits >= 0)",
          "3644:       if (nbits > 0)",
          "3655:       high -= low;",
          "3658:       high <<= nbits;",
          "3659:       next = hist[s][1];",
          "3664:       }",
          "3670:       }",
          "3671:       hist[s][1] = next;",
          "3672:       sym[s] = bin;",
          "",
          "[Removed Lines]",
          "3573:   fseek (ifp, 9, SEEK_CUR);",
          "3575:   init = (get2(),get2());",
          "3576:   for (row=0; row < raw_height; row++) {",
          "3580:     fseek (ifp, (data_offset-ftell(ifp)) & 15, SEEK_CUR);",
          "3582:     mag = 0; pmode = 7;",
          "3583:     FORC(6) ((ushort *)lent)[c] = row < 2 ? 7:4;",
          "3584:     prow[ row & 1] = &RAW(row-1,1-((row & 1) << 1)); // green",
          "3585:     prow[~row & 1] = &RAW(row-2,0);   // red and blue",
          "3586:     for (tab=0; tab+15 < raw_width; tab+=16) {",
          "3587:       if (~opt & 4 && !(tab & 63)) {",
          "3588:  i = ph1_bits(2);",
          "3589:  mag = i < 3 ? mag-'2'+\"204\"[i] : ph1_bits(12);",
          "3592:  pmode = 7 - 4*ph1_bits(1);",
          "3594:  pmode = ph1_bits(3);",
          "3595:       if (opt & 1 || !ph1_bits(1)) {",
          "3596:  FORC4 len[c] = ph1_bits(2);",
          "3597:  FORC4 {",
          "3598:    i = ((row & 1) << 1 | (c & 1)) % 3;",
          "3599:    len[c] = len[c] < 3 ? lent[i][0]-'1'+\"120\"[len[c]] : ph1_bits(4);",
          "3600:    lent[i][0] = lent[i][1];",
          "3601:    lent[i][1] = len[c];",
          "3602:  }",
          "3604:       FORC(16) {",
          "3605:  col = tab + (((c & 7) << 1)^(c >> 3)^(row & 1));",
          "3606:  pred = (pmode == 7 || row < 2)",
          "3607:       ? (tab ? RAW(row,tab-2+(col & 1)) : init)",
          "3608:       : (prow[col & 1][col-'4'+\"0224468\"[pmode]] +",
          "3609:   prow[col & 1][col-'4'+\"0244668\"[pmode]] + 1) >> 1;",
          "3610:  diff = ph1_bits (i = len[c >> 2]);",
          "3611:  if (diff >> (i-1)) diff -= 1 << i;",
          "3612:  diff = diff * (mag*2+1) + mag;",
          "3613:  RAW(row,col) = pred + diff;",
          "3619: #define HOLE(row) ((holes >> (((row) - raw_height) & 7)) & 1)",
          "3622: void CLASS smal_decode_segment (unsigned seg[2][2], int holes)",
          "3624:   uchar hist[3][13] = {",
          "3625:     { 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },",
          "3626:     { 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },",
          "3627:     { 3, 3, 0, 0, 63,     47,     31,     15,    0 } };",
          "3628:   int low, high=0xff, carry=0, nbits=8;",
          "3630:   uchar diff, pred[]={0,0};",
          "3631:   ushort data=0, range=0;",
          "3633:   fseek (ifp, seg[0][1]+1, SEEK_SET);",
          "3635:   if (seg[1][0] > raw_width*raw_height)",
          "3636:        seg[1][0] = raw_width*raw_height;",
          "3637:   for (pix=seg[0][0]; pix < seg[1][0]; pix++) {",
          "3638:     for (s=0; s < 3; s++) {",
          "3641:  carry = (nbits += carry+1) < 1 ? nbits-1 : 0;",
          "3643:  if ((data >> nbits & 0xff) == 0xff) break;",
          "3645:    data = ((data & ((1 << (nbits-1)) - 1)) << 1) |",
          "3646:             ((data + (((data & (1 << (nbits-1)))) << 1)) & ((~0u) << nbits));",
          "3647:       if (nbits >= 0) {",
          "3648:  data += getbits(1);",
          "3649:  carry = nbits - 8;",
          "3650:       }",
          "3651:       count = ((((data-range+1) & 0xffff) << 2) - 1) / (high >> 4);",
          "3652:       for (bin=0; hist[s][bin+5] > count; bin++);",
          "3653:   low = hist[s][bin+5] * (high >> 4) >> 2;",
          "3654:       if (bin) high = hist[s][bin+4] * (high >> 4) >> 2;",
          "3656:       for (nbits=0; high << nbits < 128; nbits++);",
          "3657:       range = (range+low) << nbits;",
          "3660:       if (++hist[s][2] > hist[s][3]) {",
          "3661:  next = (next+1) & hist[s][0];",
          "3662:  hist[s][3] = (hist[s][next+4] - hist[s][next+5]) >> 2;",
          "3663:  hist[s][2] = 1;",
          "3665:       if (hist[s][hist[s][1]+4] - hist[s][hist[s][1]+5] > 1) {",
          "3666:  if (bin < hist[s][1])",
          "3667:    for (i=bin; i < hist[s][1]; i++) hist[s][i+5]--;",
          "3668:  else if (next <= bin)",
          "3669:    for (i=hist[s][1]; i < bin; i++) hist[s][i+5]++;",
          "",
          "[Added Lines]",
          "4043:   fseek(ifp, 9, SEEK_CUR);",
          "4045:   init = (get2(), get2());",
          "4046:   for (row = 0; row < raw_height; row++)",
          "4047:   {",
          "4051:     fseek(ifp, (data_offset - ftell(ifp)) & 15, SEEK_CUR);",
          "4053:     mag = 0;",
          "4054:     pmode = 7;",
          "4055:     FORC(6)((ushort *)lent)[c] = row < 2 ? 7 : 4;",
          "4056:     prow[row & 1] = &RAW(row - 1, 1 - ((row & 1) << 1)); // green",
          "4057:     prow[~row & 1] = &RAW(row - 2, 0);                   // red and blue",
          "4058:     for (tab = 0; tab + 15 < raw_width; tab += 16)",
          "4059:     {",
          "4060:       if (~opt & 4 && !(tab & 63))",
          "4061:       {",
          "4062:         i = ph1_bits(2);",
          "4063:         mag = i < 3 ? mag - '2' + \"204\"[i] : ph1_bits(12);",
          "4066:         pmode = 7 - 4 * ph1_bits(1);",
          "4068:         pmode = ph1_bits(3);",
          "4069:       if (opt & 1 || !ph1_bits(1))",
          "4070:       {",
          "4071:         FORC4 len[c] = ph1_bits(2);",
          "4072:         FORC4",
          "4073:         {",
          "4074:           i = ((row & 1) << 1 | (c & 1)) % 3;",
          "4075:           len[c] = len[c] < 3 ? lent[i][0] - '1' + \"120\"[len[c]] : ph1_bits(4);",
          "4076:           lent[i][0] = lent[i][1];",
          "4077:           lent[i][1] = len[c];",
          "4078:         }",
          "4080:       FORC(16)",
          "4081:       {",
          "4082:         col = tab + (((c & 7) << 1) ^ (c >> 3) ^ (row & 1));",
          "4083:         pred =",
          "4084:             (pmode == 7 || row < 2)",
          "4085:                 ? (tab ? RAW(row, tab - 2 + (col & 1)) : init)",
          "4086:                 : (prow[col & 1][col - '4' + \"0224468\"[pmode]] + prow[col & 1][col - '4' + \"0244668\"[pmode]] + 1) >> 1;",
          "4087:         diff = ph1_bits(i = len[c >> 2]);",
          "4088:         if (diff >> (i - 1))",
          "4089:           diff -= 1 << i;",
          "4090:         diff = diff * (mag * 2 + 1) + mag;",
          "4091:         RAW(row, col) = pred + diff;",
          "4097: #define HOLE(row) ((holes >> (((row)-raw_height) & 7)) & 1)",
          "4100: void CLASS smal_decode_segment(unsigned seg[2][2], int holes)",
          "4102:   uchar hist[3][13] = {{7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0},",
          "4103:                        {7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0},",
          "4104:                        {3, 3, 0, 0, 63, 47, 31, 15, 0}};",
          "4105:   int low, high = 0xff, carry = 0, nbits = 8;",
          "4107:   uchar diff, pred[] = {0, 0};",
          "4108:   ushort data = 0, range = 0;",
          "4110:   fseek(ifp, seg[0][1] + 1, SEEK_SET);",
          "4112:   if (seg[1][0] > raw_width * raw_height)",
          "4113:     seg[1][0] = raw_width * raw_height;",
          "4114:   for (pix = seg[0][0]; pix < seg[1][0]; pix++)",
          "4115:   {",
          "4116:     for (s = 0; s < 3; s++)",
          "4117:     {",
          "4120:         carry = (nbits += carry + 1) < 1 ? nbits - 1 : 0;",
          "4122:         if ((data >> nbits & 0xff) == 0xff)",
          "4123:           break;",
          "4125:         data = ((data & ((1 << (nbits - 1)) - 1)) << 1) |",
          "4126:                ((data + (((data & (1 << (nbits - 1)))) << 1)) & ((~0u) << nbits));",
          "4127:       if (nbits >= 0)",
          "4128:       {",
          "4129:         data += getbits(1);",
          "4130:         carry = nbits - 8;",
          "4131:       }",
          "4132:       count = ((((data - range + 1) & 0xffff) << 2) - 1) / (high >> 4);",
          "4133:       for (bin = 0; hist[s][bin + 5] > count; bin++)",
          "4134:         ;",
          "4135:       low = hist[s][bin + 5] * (high >> 4) >> 2;",
          "4136:       if (bin)",
          "4137:         high = hist[s][bin + 4] * (high >> 4) >> 2;",
          "4139:       for (nbits = 0; high << nbits < 128; nbits++)",
          "4140:         ;",
          "4141:       range = (range + low) << nbits;",
          "4144:       if (++hist[s][2] > hist[s][3])",
          "4145:       {",
          "4146:         next = (next + 1) & hist[s][0];",
          "4147:         hist[s][3] = (hist[s][next + 4] - hist[s][next + 5]) >> 2;",
          "4148:         hist[s][2] = 1;",
          "4150:       if (hist[s][hist[s][1] + 4] - hist[s][hist[s][1] + 5] > 1)",
          "4151:       {",
          "4152:         if (bin < hist[s][1])",
          "4153:           for (i = bin; i < hist[s][1]; i++)",
          "4154:             hist[s][i + 5]--;",
          "4155:         else if (next <= bin)",
          "4156:           for (i = hist[s][1]; i < bin; i++)",
          "4157:             hist[s][i + 5]++;",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "3677:     if (ftell(ifp) + 12 >= seg[1][1])",
          "3678:       diff = 0;",
          "3679: #ifdef LIBRAW_LIBRARY_BUILD",
          "3681:       throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "3682: #endif",
          "3683:     raw_image[pix] = pred[pix & 1] += diff;",
          "3685:   }",
          "3686:   maximum = 0xff;",
          "3687: }",
          "",
          "[Removed Lines]",
          "3680:     if(pix>=raw_width*raw_height)",
          "3684:     if (!(pix & 1) && HOLE(pix / raw_width)) pix += 2;",
          "",
          "[Added Lines]",
          "4168:     if (pix >= raw_width * raw_height)",
          "4172:     if (!(pix & 1) && HOLE(pix / raw_width))",
          "4173:       pix += 2;",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "3690: {",
          "3691:   unsigned seg[2][2];",
          "3694:   seg[0][0] = 0;",
          "3695:   seg[0][1] = get2();",
          "3696:   seg[1][0] = raw_width * raw_height;",
          "3697:   seg[1][1] = INT_MAX;",
          "3699: }",
          "3702: {",
          "3703:   int min, max, sum, i;",
          "3705:   min = max = sum = p[0];",
          "3707:     sum += p[i];",
          "3710:   }",
          "3711:   return (sum - min - max) >> 1;",
          "3712: }",
          "3715: {",
          "3716:   int row, col, val[4];",
          "3736:       }",
          "3737:   }",
          "3738: }",
          "",
          "[Removed Lines]",
          "3693:   fseek (ifp, 16, SEEK_SET);",
          "3698:   smal_decode_segment (seg, 0);",
          "3701: int CLASS median4 (int *p)",
          "3706:   for (i=1; i < 4; i++) {",
          "3708:     if (min > p[i]) min = p[i];",
          "3709:     if (max < p[i]) max = p[i];",
          "3714: void CLASS fill_holes (int holes)",
          "3718:   for (row=2; row < height-2; row++) {",
          "3719:     if (!HOLE(row)) continue;",
          "3720:     for (col=1; col < width-1; col+=4) {",
          "3721:       val[0] = RAW(row-1,col-1);",
          "3722:       val[1] = RAW(row-1,col+1);",
          "3723:       val[2] = RAW(row+1,col-1);",
          "3724:       val[3] = RAW(row+1,col+1);",
          "3725:       RAW(row,col) = median4(val);",
          "3726:     }",
          "3727:     for (col=2; col < width-2; col+=4)",
          "3728:       if (HOLE(row-2) || HOLE(row+2))",
          "3729:  RAW(row,col) = (RAW(row,col-2) + RAW(row,col+2)) >> 1;",
          "3730:       else {",
          "3731:  val[0] = RAW(row,col-2);",
          "3732:  val[1] = RAW(row,col+2);",
          "3733:  val[2] = RAW(row-2,col);",
          "3734:  val[3] = RAW(row+2,col);",
          "3735:  RAW(row,col) = median4(val);",
          "",
          "[Added Lines]",
          "4182:   fseek(ifp, 16, SEEK_SET);",
          "4187:   smal_decode_segment(seg, 0);",
          "4190: int CLASS median4(int *p)",
          "4195:   for (i = 1; i < 4; i++)",
          "4196:   {",
          "4198:     if (min > p[i])",
          "4199:       min = p[i];",
          "4200:     if (max < p[i])",
          "4201:       max = p[i];",
          "4206: void CLASS fill_holes(int holes)",
          "4210:   for (row = 2; row < height - 2; row++)",
          "4211:   {",
          "4212:     if (!HOLE(row))",
          "4213:       continue;",
          "4214:     for (col = 1; col < width - 1; col += 4)",
          "4215:     {",
          "4216:       val[0] = RAW(row - 1, col - 1);",
          "4217:       val[1] = RAW(row - 1, col + 1);",
          "4218:       val[2] = RAW(row + 1, col - 1);",
          "4219:       val[3] = RAW(row + 1, col + 1);",
          "4220:       RAW(row, col) = median4(val);",
          "4221:     }",
          "4222:     for (col = 2; col < width - 2; col += 4)",
          "4223:       if (HOLE(row - 2) || HOLE(row + 2))",
          "4224:         RAW(row, col) = (RAW(row, col - 2) + RAW(row, col + 2)) >> 1;",
          "4225:       else",
          "4226:       {",
          "4227:         val[0] = RAW(row, col - 2);",
          "4228:         val[1] = RAW(row, col + 2);",
          "4229:         val[2] = RAW(row - 2, col);",
          "4230:         val[3] = RAW(row + 2, col);",
          "4231:         RAW(row, col) = median4(val);",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "3741: {",
          "3742:   unsigned seg[256][2], offset, nseg, holes, i;",
          "3745:   offset = get4();",
          "3751:   holes = fgetc(ifp);",
          "3753:   seg[nseg][0] = raw_height * raw_width;",
          "3754:   seg[nseg][1] = get4() + data_offset;",
          "3758: }",
          "3760: void CLASS redcine_load_raw()",
          "",
          "[Removed Lines]",
          "3744:   fseek (ifp, 67, SEEK_SET);",
          "3746:   nseg = (uchar) fgetc(ifp);",
          "3747:   fseek (ifp, offset, SEEK_SET);",
          "3748:   for (i=0; i < nseg*2; i++)",
          "3749:     ((unsigned *)seg)[i] = get4() + data_offset*(i & 1);",
          "3750:   fseek (ifp, 78, SEEK_SET);",
          "3752:   fseek (ifp, 88, SEEK_SET);",
          "3755:   for (i=0; i < nseg; i++)",
          "3756:     smal_decode_segment (seg+i, holes);",
          "3757:   if (holes) fill_holes (holes);",
          "",
          "[Added Lines]",
          "4240:   fseek(ifp, 67, SEEK_SET);",
          "4242:   nseg = (uchar)fgetc(ifp);",
          "4243:   fseek(ifp, offset, SEEK_SET);",
          "4244:   for (i = 0; i < nseg * 2; i++)",
          "4245:     ((unsigned *)seg)[i] = get4() + data_offset * (i & 1);",
          "4246:   fseek(ifp, 78, SEEK_SET);",
          "4248:   fseek(ifp, 88, SEEK_SET);",
          "4251:   for (i = 0; i < nseg; i++)",
          "4252:     smal_decode_segment(seg + i, holes);",
          "4253:   if (holes)",
          "4254:     fill_holes(holes);",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "3770:   jas_init();",
          "3771: #ifndef LIBRAW_LIBRARY_BUILD",
          "3773: #else",
          "3777: #endif",
          "3780: #ifndef LIBRAW_LIBRARY_BUILD",
          "3782: #else",
          "3788: #endif",
          "3793: #ifdef LIBRAW_LIBRARY_BUILD",
          "3794:   bool fastexitflag = false;",
          "3796: #endif",
          "3798: #ifdef LIBRAW_LIBRARY_BUILD",
          "3800: #endif",
          "3816: #ifdef LIBRAW_LIBRARY_BUILD",
          "3818: #endif",
          "3824:     }",
          "3828: #ifdef LIBRAW_LIBRARY_BUILD",
          "3830: #endif",
          "3834: #ifdef LIBRAW_LIBRARY_BUILD",
          "3837:   }",
          "3838: #endif",
          "3843: #ifdef LIBRAW_LIBRARY_BUILD",
          "3845:     throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;",
          "3846: #endif",
          "3847: #endif",
          "",
          "[Removed Lines]",
          "3772:   in = jas_stream_fopen (ifname, \"rb\");",
          "3774:   in = (jas_stream_t*)ifp->make_jas_stream();",
          "3775:   if(!in)",
          "3776:           throw LIBRAW_EXCEPTION_DECODE_JPEG2000;",
          "3778:   jas_stream_seek (in, data_offset+20, SEEK_SET);",
          "3779:   jimg = jas_image_decode (in, -1, 0);",
          "3781:   if (!jimg) longjmp (failure, 3);",
          "3783:   if(!jimg)",
          "3784:     {",
          "3785:       jas_stream_close (in);",
          "3786:       throw LIBRAW_EXCEPTION_DECODE_JPEG2000;",
          "3787:     }",
          "3789:   jmat = jas_matrix_create (height/2, width/2);",
          "3790:   merror (jmat, \"redcine_load_raw()\");",
          "3791:   img = (ushort *) calloc ((height+2), (width+2)*2);",
          "3792:   merror (img, \"redcine_load_raw()\");",
          "3795:   try {",
          "3797:   FORC4 {",
          "3799:     checkCancel();",
          "3801:     jas_image_readcmpt (jimg, c, 0, 0, width/2, height/2, jmat);",
          "3802:     data = jas_matrix_getref (jmat, 0, 0);",
          "3803:     for (row = c >> 1; row < height; row+=2)",
          "3804:       for (col = c & 1; col < width; col+=2)",
          "3805:  img[(row+1)*(width+2)+col+1] = data[(row/2)*(width/2)+col/2];",
          "3806:   }",
          "3807:   for (col=1; col <= width; col++) {",
          "3808:     img[col] = img[2*(width+2)+col];",
          "3809:     img[(height+1)*(width+2)+col] = img[(height-1)*(width+2)+col];",
          "3810:   }",
          "3811:   for (row=0; row < height+2; row++) {",
          "3812:     img[row*(width+2)] = img[row*(width+2)+2];",
          "3813:     img[(row+1)*(width+2)-1] = img[(row+1)*(width+2)-3];",
          "3814:   }",
          "3815:   for (row=1; row <= height; row++) {",
          "3817:     checkCancel();",
          "3819:     pix = img + row*(width+2) + (col = 1 + (FC(row,1) & 1));",
          "3820:     for (   ; col <= width; col+=2, pix+=2) {",
          "3821:       c = (((pix[0] - 0x800) << 3) +",
          "3822:  pix[-(width+2)] + pix[width+2] + pix[-1] + pix[1]) >> 2;",
          "3823:       pix[0] = LIM(c,0,4095);",
          "3825:   }",
          "3826:   for (row=0; row < height; row++)",
          "3827:   {",
          "3829:     checkCancel();",
          "3831:     for (col=0; col < width; col++)",
          "3832:       RAW(row,col) = curve[img[(row+1)*(width+2)+col+1]];",
          "3833:   }",
          "3835:   } catch (...) {",
          "3836:     fastexitflag=true;",
          "3839:   free (img);",
          "3840:   jas_matrix_destroy (jmat);",
          "3841:   jas_image_destroy (jimg);",
          "3842:   jas_stream_close (in);",
          "3844:   if(fastexitflag)",
          "",
          "[Added Lines]",
          "4269:   in = jas_stream_fopen(ifname, \"rb\");",
          "4271:   in = (jas_stream_t *)ifp->make_jas_stream();",
          "4272:   if (!in)",
          "4273:     throw LIBRAW_EXCEPTION_DECODE_JPEG2000;",
          "4275:   jas_stream_seek(in, data_offset + 20, SEEK_SET);",
          "4276:   jimg = jas_image_decode(in, -1, 0);",
          "4278:   if (!jimg)",
          "4279:     longjmp(failure, 3);",
          "4281:   if (!jimg)",
          "4282:   {",
          "4283:     jas_stream_close(in);",
          "4284:     throw LIBRAW_EXCEPTION_DECODE_JPEG2000;",
          "4285:   }",
          "4287:   jmat = jas_matrix_create(height / 2, width / 2);",
          "4288:   merror(jmat, \"redcine_load_raw()\");",
          "4289:   img = (ushort *)calloc((height + 2), (width + 2) * 2);",
          "4290:   merror(img, \"redcine_load_raw()\");",
          "4293:   try",
          "4294:   {",
          "4296:     FORC4",
          "4297:     {",
          "4299:       checkCancel();",
          "4301:       jas_image_readcmpt(jimg, c, 0, 0, width / 2, height / 2, jmat);",
          "4302:       data = jas_matrix_getref(jmat, 0, 0);",
          "4303:       for (row = c >> 1; row < height; row += 2)",
          "4304:         for (col = c & 1; col < width; col += 2)",
          "4305:           img[(row + 1) * (width + 2) + col + 1] = data[(row / 2) * (width / 2) + col / 2];",
          "4306:     }",
          "4307:     for (col = 1; col <= width; col++)",
          "4308:     {",
          "4309:       img[col] = img[2 * (width + 2) + col];",
          "4310:       img[(height + 1) * (width + 2) + col] = img[(height - 1) * (width + 2) + col];",
          "4311:     }",
          "4312:     for (row = 0; row < height + 2; row++)",
          "4313:     {",
          "4314:       img[row * (width + 2)] = img[row * (width + 2) + 2];",
          "4315:       img[(row + 1) * (width + 2) - 1] = img[(row + 1) * (width + 2) - 3];",
          "4316:     }",
          "4317:     for (row = 1; row <= height; row++)",
          "4318:     {",
          "4320:       checkCancel();",
          "4322:       pix = img + row * (width + 2) + (col = 1 + (FC(row, 1) & 1));",
          "4323:       for (; col <= width; col += 2, pix += 2)",
          "4324:       {",
          "4325:         c = (((pix[0] - 0x800) << 3) + pix[-(width + 2)] + pix[width + 2] + pix[-1] + pix[1]) >> 2;",
          "4326:         pix[0] = LIM(c, 0, 4095);",
          "4327:       }",
          "4329:     for (row = 0; row < height; row++)",
          "4330:     {",
          "4332:       checkCancel();",
          "4334:       for (col = 0; col < width; col++)",
          "4335:         RAW(row, col) = curve[img[(row + 1) * (width + 2) + col + 1]];",
          "4336:     }",
          "4338:   }",
          "4339:   catch (...)",
          "4340:   {",
          "4341:     fastexitflag = true;",
          "4344:   free(img);",
          "4345:   jas_matrix_destroy(jmat);",
          "4346:   jas_image_destroy(jimg);",
          "4347:   jas_stream_close(in);",
          "4349:   if (fastexitflag)",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "3851:   int row, col;",
          "3852:   unsigned",
          "3853: #ifndef LIBRAW_LIBRARY_BUILD",
          "3856: #else",
          "3858: #define mblack imgdata.color.black_stat",
          "3859: #endif",
          "3861: #ifndef LIBRAW_LIBRARY_BUILD",
          "3864:     phase_one_correct();",
          "3888:     mask[0][1] = mask[1][1] += 2;",
          "3889:     mask[0][3] -= 2;",
          "3890:     goto sides;",
          "3891:   }",
          "3898:     mask[0][0] = mask[1][0] = top_margin;",
          "3900:     mask[0][3] += left_margin;",
          "3902:     mask[1][3] += raw_width;",
          "3903:   }",
          "3905:     mask[0][2] = top_margin;",
          "3906:     mask[0][3] = width;",
          "3907:   }",
          "3908: #ifdef LIBRAW_LIBRARY_BUILD",
          "3910:     mask[0][2] = top_margin;",
          "3911:     mask[0][3] = width;",
          "3912:   }",
          "3913: #endif",
          "3914: mask_set:",
          "3927: #ifndef LIBRAW_LIBRARY_BUILD",
          "3928:     canon_600_correct();",
          "3929: #endif",
          "3932:     black = cblack[4] = cblack[5] = cblack[6] = 0;",
          "3933:   }",
          "3934: }",
          "",
          "[Removed Lines]",
          "3854:     r, raw_pitch = raw_width*2,",
          "3855:     c, m, mblack[8], zero, val;",
          "3857:     c, m, zero, val;",
          "3862:   if (load_raw == &CLASS phase_one_load_raw ||",
          "3863:       load_raw == &CLASS phase_one_load_raw_c)",
          "3865:   if (fuji_width) {",
          "3866:     for (row=0; row < raw_height-top_margin*2; row++) {",
          "3867:       for (col=0; col < fuji_width << !fuji_layout; col++) {",
          "3868:  if (fuji_layout) {",
          "3869:    r = fuji_width - 1 - col + (row >> 1);",
          "3870:    c = col + ((row+1) >> 1);",
          "3871:  } else {",
          "3872:    r = fuji_width - 1 + row - (col >> 1);",
          "3873:    c = row + ((col+1) >> 1);",
          "3874:  }",
          "3875:  if (r < height && c < width)",
          "3876:    BAYER(r,c) = RAW(row+top_margin,col+left_margin);",
          "3877:       }",
          "3878:     }",
          "3879:   } else {",
          "3880:     for (row=0; row < height; row++)",
          "3881:       for (col=0; col < width; col++)",
          "3882:  BAYER2(row,col) = RAW(row+top_margin,col+left_margin);",
          "3883:   }",
          "3884: #endif",
          "3885:   if (mask[0][3] > 0) goto mask_set;",
          "3886:   if (load_raw == &CLASS canon_load_raw ||",
          "3887:       load_raw == &CLASS lossless_jpeg_load_raw) {",
          "3892:   if (load_raw == &CLASS canon_600_load_raw ||",
          "3893:       load_raw == &CLASS sony_load_raw ||",
          "3894:      (load_raw == &CLASS eight_bit_load_raw && strncmp(model,\"DC2\",3)) ||",
          "3895:       load_raw == &CLASS kodak_262_load_raw ||",
          "3896:      (load_raw == &CLASS packed_load_raw && (load_flags & 32))) {",
          "3897: sides:",
          "3899:     mask[0][2] = mask[1][2] = top_margin+height;",
          "3901:     mask[1][1] += left_margin+width;",
          "3904:   if (load_raw == &CLASS nokia_load_raw) {",
          "3909:   if (load_raw == &CLASS broadcom_load_raw) {",
          "3915:   memset (mblack, 0, sizeof mblack);",
          "3916:   for (zero=m=0; m < 8; m++)",
          "3917:     for (row=MAX(mask[m][0],0); row < MIN(mask[m][2],raw_height); row++)",
          "3918:       for (col=MAX(mask[m][1],0); col < MIN(mask[m][3],raw_width); col++) {",
          "3919:  c = FC(row-top_margin,col-left_margin);",
          "3920:  mblack[c] += val = raw_image[(row)*raw_pitch/2+(col)];",
          "3921:  mblack[4+c]++;",
          "3922:  zero += !val;",
          "3923:       }",
          "3924:   if (load_raw == &CLASS canon_600_load_raw && width < raw_width) {",
          "3925:     black = (mblack[0]+mblack[1]+mblack[2]+mblack[3]) /",
          "3926:      (mblack[4]+mblack[5]+mblack[6]+mblack[7]) - 4;",
          "3930:   } else if (zero < mblack[4] && mblack[5] && mblack[6] && mblack[7]) {",
          "3931:     FORC4 cblack[c] = mblack[c] / mblack[4+c];",
          "",
          "[Added Lines]",
          "4359:       r,",
          "4360:       raw_pitch = raw_width * 2, c, m, mblack[8], zero, val;",
          "4362:       c,",
          "4363:       m, zero, val;",
          "4368:   if (load_raw == &CLASS phase_one_load_raw || load_raw == &CLASS phase_one_load_raw_c)",
          "4370:   if (fuji_width)",
          "4371:   {",
          "4372:     for (row = 0; row < raw_height - top_margin * 2; row++)",
          "4373:     {",
          "4374:       for (col = 0; col < fuji_width << !fuji_layout; col++)",
          "4375:       {",
          "4376:         if (fuji_layout)",
          "4377:         {",
          "4378:           r = fuji_width - 1 - col + (row >> 1);",
          "4379:           c = col + ((row + 1) >> 1);",
          "4380:         }",
          "4381:         else",
          "4382:         {",
          "4383:           r = fuji_width - 1 + row - (col >> 1);",
          "4384:           c = row + ((col + 1) >> 1);",
          "4385:         }",
          "4386:         if (r < height && c < width)",
          "4387:           BAYER(r, c) = RAW(row + top_margin, col + left_margin);",
          "4388:       }",
          "4389:     }",
          "4390:   }",
          "4391:   else",
          "4392:   {",
          "4393:     for (row = 0; row < height; row++)",
          "4394:       for (col = 0; col < width; col++)",
          "4395:         BAYER2(row, col) = RAW(row + top_margin, col + left_margin);",
          "4396:   }",
          "4397: #endif",
          "4398:   if (mask[0][3] > 0)",
          "4399:     goto mask_set;",
          "4400:   if (load_raw == &CLASS canon_load_raw || load_raw == &CLASS lossless_jpeg_load_raw)",
          "4401:   {",
          "4406:   if (load_raw == &CLASS canon_600_load_raw || load_raw == &CLASS sony_load_raw ||",
          "4407:       (load_raw == &CLASS eight_bit_load_raw && strncmp(model, \"DC2\", 3)) || load_raw == &CLASS kodak_262_load_raw ||",
          "4408:       (load_raw == &CLASS packed_load_raw && (load_flags & 32)))",
          "4409:   {",
          "4410:   sides:",
          "4412:     mask[0][2] = mask[1][2] = top_margin + height;",
          "4414:     mask[1][1] += left_margin + width;",
          "4417:   if (load_raw == &CLASS nokia_load_raw)",
          "4418:   {",
          "4423:   if (load_raw == &CLASS broadcom_load_raw)",
          "4424:   {",
          "4430:   memset(mblack, 0, sizeof mblack);",
          "4431:   for (zero = m = 0; m < 8; m++)",
          "4432:     for (row = MAX(mask[m][0], 0); row < MIN(mask[m][2], raw_height); row++)",
          "4433:       for (col = MAX(mask[m][1], 0); col < MIN(mask[m][3], raw_width); col++)",
          "4434:       {",
          "4435:         c = FC(row - top_margin, col - left_margin);",
          "4436:         mblack[c] += val = raw_image[(row)*raw_pitch / 2 + (col)];",
          "4437:         mblack[4 + c]++;",
          "4438:         zero += !val;",
          "4439:       }",
          "4440:   if (load_raw == &CLASS canon_600_load_raw && width < raw_width)",
          "4441:   {",
          "4442:     black = (mblack[0] + mblack[1] + mblack[2] + mblack[3]) / (mblack[4] + mblack[5] + mblack[6] + mblack[7]) - 4;",
          "4446:   }",
          "4447:   else if (zero < mblack[4] && mblack[5] && mblack[6] && mblack[7])",
          "4448:   {",
          "4449:     FORC4 cblack[c] = mblack[c] / mblack[4 + c];",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "3941:   unsigned row, col, tot, n, r, c;",
          "3943: #ifdef LIBRAW_LIBRARY_BUILD",
          "3945: #endif",
          "3957:       }",
          "3958: #ifdef LIBRAW_LIBRARY_BUILD",
          "3960: #endif",
          "3961: }",
          "3963: static const uchar xlat[2][256] = {",
          "3998: {",
          "3999:   int i;",
          "4002:   g[0] = pwr;",
          "4003:   g[1] = ts;",
          "4004:   g[2] = g[3] = g[4] = 0;",
          "4005:   bnd[g[1] >= 1] = 1;",
          "4011:     }",
          "4012:     g[3] = g[2] / g[1];",
          "4021:     return;",
          "4022:   }",
          "4024:     curve[i] = 0xffff;",
          "4029:   }",
          "4030: }",
          "4033: {",
          "4034:   double work[3][6], num;",
          "4035:   int i, j, k;",
          "4043:   }",
          "4045:     num = work[i][i];",
          "4047:       work[i][j] /= num;",
          "4050:       num = work[k][i];",
          "4053:     }",
          "4054:   }",
          "4059: }",
          "4062: {",
          "4063:   double cam_rgb[4][3], inverse[4][3], num;",
          "4064:   int i, j, k;",
          "4073:       num += cam_rgb[i][j];",
          "4080:     else",
          "4086:   }",
          "4090:       _rgb_cam[i][j] = inverse[j][i];",
          "4091: }",
          "",
          "[Removed Lines]",
          "3944:   RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,0,2);",
          "3947:   for (row=0; row < height; row++)",
          "3948:     for (col=0; col < width; col++)",
          "3949:       if (BAYER(row,col) == 0) {",
          "3950:  tot = n = 0;",
          "3951:  for (r = row-2; r <= row+2; r++)",
          "3952:    for (c = col-2; c <= col+2; c++)",
          "3953:      if (r < height && c < width &&",
          "3954:   FC(r,c) == FC(row,col) && BAYER(r,c))",
          "3955:        tot += (n++,BAYER(r,c));",
          "3956:  if (n) BAYER(row,col) = tot/n;",
          "3959:   RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,1,2);",
          "3964:   { 0xc1,0xbf,0x6d,0x0d,0x59,0xc5,0x13,0x9d,0x83,0x61,0x6b,0x4f,0xc7,0x7f,0x3d,0x3d,",
          "3965:     0x53,0x59,0xe3,0xc7,0xe9,0x2f,0x95,0xa7,0x95,0x1f,0xdf,0x7f,0x2b,0x29,0xc7,0x0d,",
          "3966:     0xdf,0x07,0xef,0x71,0x89,0x3d,0x13,0x3d,0x3b,0x13,0xfb,0x0d,0x89,0xc1,0x65,0x1f,",
          "3967:     0xb3,0x0d,0x6b,0x29,0xe3,0xfb,0xef,0xa3,0x6b,0x47,0x7f,0x95,0x35,0xa7,0x47,0x4f,",
          "3968:     0xc7,0xf1,0x59,0x95,0x35,0x11,0x29,0x61,0xf1,0x3d,0xb3,0x2b,0x0d,0x43,0x89,0xc1,",
          "3969:     0x9d,0x9d,0x89,0x65,0xf1,0xe9,0xdf,0xbf,0x3d,0x7f,0x53,0x97,0xe5,0xe9,0x95,0x17,",
          "3970:     0x1d,0x3d,0x8b,0xfb,0xc7,0xe3,0x67,0xa7,0x07,0xf1,0x71,0xa7,0x53,0xb5,0x29,0x89,",
          "3971:     0xe5,0x2b,0xa7,0x17,0x29,0xe9,0x4f,0xc5,0x65,0x6d,0x6b,0xef,0x0d,0x89,0x49,0x2f,",
          "3972:     0xb3,0x43,0x53,0x65,0x1d,0x49,0xa3,0x13,0x89,0x59,0xef,0x6b,0xef,0x65,0x1d,0x0b,",
          "3973:     0x59,0x13,0xe3,0x4f,0x9d,0xb3,0x29,0x43,0x2b,0x07,0x1d,0x95,0x59,0x59,0x47,0xfb,",
          "3974:     0xe5,0xe9,0x61,0x47,0x2f,0x35,0x7f,0x17,0x7f,0xef,0x7f,0x95,0x95,0x71,0xd3,0xa3,",
          "3975:     0x0b,0x71,0xa3,0xad,0x0b,0x3b,0xb5,0xfb,0xa3,0xbf,0x4f,0x83,0x1d,0xad,0xe9,0x2f,",
          "3976:     0x71,0x65,0xa3,0xe5,0x07,0x35,0x3d,0x0d,0xb5,0xe9,0xe5,0x47,0x3b,0x9d,0xef,0x35,",
          "3977:     0xa3,0xbf,0xb3,0xdf,0x53,0xd3,0x97,0x53,0x49,0x71,0x07,0x35,0x61,0x71,0x2f,0x43,",
          "3978:     0x2f,0x11,0xdf,0x17,0x97,0xfb,0x95,0x3b,0x7f,0x6b,0xd3,0x25,0xbf,0xad,0xc7,0xc5,",
          "3979:     0xc5,0xb5,0x8b,0xef,0x2f,0xd3,0x07,0x6b,0x25,0x49,0x95,0x25,0x49,0x6d,0x71,0xc7 },",
          "3980:   { 0xa7,0xbc,0xc9,0xad,0x91,0xdf,0x85,0xe5,0xd4,0x78,0xd5,0x17,0x46,0x7c,0x29,0x4c,",
          "3981:     0x4d,0x03,0xe9,0x25,0x68,0x11,0x86,0xb3,0xbd,0xf7,0x6f,0x61,0x22,0xa2,0x26,0x34,",
          "3982:     0x2a,0xbe,0x1e,0x46,0x14,0x68,0x9d,0x44,0x18,0xc2,0x40,0xf4,0x7e,0x5f,0x1b,0xad,",
          "3983:     0x0b,0x94,0xb6,0x67,0xb4,0x0b,0xe1,0xea,0x95,0x9c,0x66,0xdc,0xe7,0x5d,0x6c,0x05,",
          "3984:     0xda,0xd5,0xdf,0x7a,0xef,0xf6,0xdb,0x1f,0x82,0x4c,0xc0,0x68,0x47,0xa1,0xbd,0xee,",
          "3985:     0x39,0x50,0x56,0x4a,0xdd,0xdf,0xa5,0xf8,0xc6,0xda,0xca,0x90,0xca,0x01,0x42,0x9d,",
          "3986:     0x8b,0x0c,0x73,0x43,0x75,0x05,0x94,0xde,0x24,0xb3,0x80,0x34,0xe5,0x2c,0xdc,0x9b,",
          "3987:     0x3f,0xca,0x33,0x45,0xd0,0xdb,0x5f,0xf5,0x52,0xc3,0x21,0xda,0xe2,0x22,0x72,0x6b,",
          "3988:     0x3e,0xd0,0x5b,0xa8,0x87,0x8c,0x06,0x5d,0x0f,0xdd,0x09,0x19,0x93,0xd0,0xb9,0xfc,",
          "3989:     0x8b,0x0f,0x84,0x60,0x33,0x1c,0x9b,0x45,0xf1,0xf0,0xa3,0x94,0x3a,0x12,0x77,0x33,",
          "3990:     0x4d,0x44,0x78,0x28,0x3c,0x9e,0xfd,0x65,0x57,0x16,0x94,0x6b,0xfb,0x59,0xd0,0xc8,",
          "3991:     0x22,0x36,0xdb,0xd2,0x63,0x98,0x43,0xa1,0x04,0x87,0x86,0xf7,0xa6,0x26,0xbb,0xd6,",
          "3992:     0x59,0x4d,0xbf,0x6a,0x2e,0xaa,0x2b,0xef,0xe6,0x78,0xb6,0x4e,0xe0,0x2f,0xdc,0x7c,",
          "3993:     0xbe,0x57,0x19,0x32,0x7e,0x2a,0xd0,0xb8,0xba,0x29,0x00,0x3c,0x52,0x7d,0xa8,0x49,",
          "3994:     0x3b,0x2d,0xeb,0x25,0x49,0xfa,0xa3,0xaa,0x39,0xa7,0xc5,0xa7,0x50,0x11,0x36,0xfb,",
          "3995:     0xc6,0x67,0x4a,0xf5,0xa5,0x12,0x65,0x7e,0xb0,0xdf,0xaf,0x4e,0xb3,0x61,0x7f,0x2f } };",
          "3997: void CLASS gamma_curve (double pwr, double ts, int mode, int imax)",
          "4000:   double g[6], bnd[2]={0,0}, r;",
          "4006:   if (g[1] && (g[1]-1)*(g[0]-1) <= 0) {",
          "4007:     for (i=0; i < 48; i++) {",
          "4008:       g[2] = (bnd[0] + bnd[1])/2;",
          "4009:       if (g[0]) bnd[(pow(g[2]/g[1],-g[0]) - 1)/g[0] - 1/g[2] > -1] = g[2];",
          "4010:       else bnd[g[2]/exp(1-1/g[2]) < g[1]] = g[2];",
          "4013:     if (g[0]) g[4] = g[2] * (1/g[0] - 1);",
          "4014:   }",
          "4015:   if (g[0]) g[5] = 1 / (g[1]*SQR(g[3])/2 - g[4]*(1 - g[3]) +",
          "4016:   (1 - pow(g[3],1+g[0]))*(1 + g[4])/(1 + g[0])) - 1;",
          "4017:   else      g[5] = 1 / (g[1]*SQR(g[3])/2 + 1",
          "4018:   - g[2] - g[3] - g[2]*g[3]*(log(g[3]) - 1)) - 1;",
          "4019:   if (!mode--) {",
          "4020:     memcpy (gamm, g, sizeof gamm);",
          "4023:   for (i=0; i < 0x10000; i++) {",
          "4025:     if ((r = (double) i / imax) < 1)",
          "4026:       curve[i] = 0x10000 * ( mode",
          "4027:  ? (r < g[3] ? r*g[1] : (g[0] ? pow( r,g[0])*(1+g[4])-g[4]    : log(r)*g[2]+1))",
          "4028:  : (r < g[2] ? r/g[1] : (g[0] ? pow((r+g[4])/(1+g[4]),1/g[0]) : exp((r-1)/g[2]))));",
          "4032: void CLASS pseudoinverse (double (*in)[3], double (*out)[3], int size)",
          "4037:   for (i=0; i < 3; i++) {",
          "4038:     for (j=0; j < 6; j++)",
          "4039:       work[i][j] = j == i+3;",
          "4040:     for (j=0; j < 3; j++)",
          "4041:       for (k=0; k < size; k++)",
          "4042:  work[i][j] += in[k][i] * in[k][j];",
          "4044:   for (i=0; i < 3; i++) {",
          "4046:     for (j=0; j < 6; j++)",
          "4048:     for (k=0; k < 3; k++) {",
          "4049:       if (k==i) continue;",
          "4051:       for (j=0; j < 6; j++)",
          "4052:  work[k][j] -= work[i][j] * num;",
          "4055:   for (i=0; i < size; i++)",
          "4056:     for (j=0; j < 3; j++)",
          "4057:       for (out[i][j]=k=0; k < 3; k++)",
          "4058:  out[i][j] += work[j][k+3] * in[i][k];",
          "4061: void CLASS cam_xyz_coeff (float _rgb_cam[3][4], double cam_xyz[4][3])",
          "4067:     for (j=0; j < 3; j++)",
          "4068:       for (cam_rgb[i][j] = k=0; k < 3; k++)",
          "4069:  cam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];",
          "4074:     if(num > 0.00001)",
          "4075:       {",
          "4076:         for (j=0; j < 3; j++)",
          "4077:           cam_rgb[i][j] /= num;",
          "4078:         pre_mul[i] = 1 / num;",
          "4079:       }",
          "4081:       {",
          "4082:         for (j=0; j < 3; j++)",
          "4083:           cam_rgb[i][j] = 0.0;",
          "4084:         pre_mul[i] = 1.0;",
          "4085:       }",
          "4087:   pseudoinverse (cam_rgb, inverse, colors);",
          "4088:   for (i=0; i < 3; i++)",
          "4089:     for (j=0; j < colors; j++)",
          "",
          "[Added Lines]",
          "4462:   RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES, 0, 2);",
          "4465:   for (row = 0; row < height; row++)",
          "4466:     for (col = 0; col < width; col++)",
          "4467:       if (BAYER(row, col) == 0)",
          "4468:       {",
          "4469:         tot = n = 0;",
          "4470:         for (r = row - 2; r <= row + 2; r++)",
          "4471:           for (c = col - 2; c <= col + 2; c++)",
          "4472:             if (r < height && c < width && FC(r, c) == FC(row, col) && BAYER(r, c))",
          "4473:               tot += (n++, BAYER(r, c));",
          "4474:         if (n)",
          "4475:           BAYER(row, col) = tot / n;",
          "4478:   RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES, 1, 2);",
          "4483:     {0xc1, 0xbf, 0x6d, 0x0d, 0x59, 0xc5, 0x13, 0x9d, 0x83, 0x61, 0x6b, 0x4f, 0xc7, 0x7f, 0x3d, 0x3d, 0x53, 0x59, 0xe3,",
          "4484:      0xc7, 0xe9, 0x2f, 0x95, 0xa7, 0x95, 0x1f, 0xdf, 0x7f, 0x2b, 0x29, 0xc7, 0x0d, 0xdf, 0x07, 0xef, 0x71, 0x89, 0x3d,",
          "4485:      0x13, 0x3d, 0x3b, 0x13, 0xfb, 0x0d, 0x89, 0xc1, 0x65, 0x1f, 0xb3, 0x0d, 0x6b, 0x29, 0xe3, 0xfb, 0xef, 0xa3, 0x6b,",
          "4486:      0x47, 0x7f, 0x95, 0x35, 0xa7, 0x47, 0x4f, 0xc7, 0xf1, 0x59, 0x95, 0x35, 0x11, 0x29, 0x61, 0xf1, 0x3d, 0xb3, 0x2b,",
          "4487:      0x0d, 0x43, 0x89, 0xc1, 0x9d, 0x9d, 0x89, 0x65, 0xf1, 0xe9, 0xdf, 0xbf, 0x3d, 0x7f, 0x53, 0x97, 0xe5, 0xe9, 0x95,",
          "4488:      0x17, 0x1d, 0x3d, 0x8b, 0xfb, 0xc7, 0xe3, 0x67, 0xa7, 0x07, 0xf1, 0x71, 0xa7, 0x53, 0xb5, 0x29, 0x89, 0xe5, 0x2b,",
          "4489:      0xa7, 0x17, 0x29, 0xe9, 0x4f, 0xc5, 0x65, 0x6d, 0x6b, 0xef, 0x0d, 0x89, 0x49, 0x2f, 0xb3, 0x43, 0x53, 0x65, 0x1d,",
          "4490:      0x49, 0xa3, 0x13, 0x89, 0x59, 0xef, 0x6b, 0xef, 0x65, 0x1d, 0x0b, 0x59, 0x13, 0xe3, 0x4f, 0x9d, 0xb3, 0x29, 0x43,",
          "4491:      0x2b, 0x07, 0x1d, 0x95, 0x59, 0x59, 0x47, 0xfb, 0xe5, 0xe9, 0x61, 0x47, 0x2f, 0x35, 0x7f, 0x17, 0x7f, 0xef, 0x7f,",
          "4492:      0x95, 0x95, 0x71, 0xd3, 0xa3, 0x0b, 0x71, 0xa3, 0xad, 0x0b, 0x3b, 0xb5, 0xfb, 0xa3, 0xbf, 0x4f, 0x83, 0x1d, 0xad,",
          "4493:      0xe9, 0x2f, 0x71, 0x65, 0xa3, 0xe5, 0x07, 0x35, 0x3d, 0x0d, 0xb5, 0xe9, 0xe5, 0x47, 0x3b, 0x9d, 0xef, 0x35, 0xa3,",
          "4494:      0xbf, 0xb3, 0xdf, 0x53, 0xd3, 0x97, 0x53, 0x49, 0x71, 0x07, 0x35, 0x61, 0x71, 0x2f, 0x43, 0x2f, 0x11, 0xdf, 0x17,",
          "4495:      0x97, 0xfb, 0x95, 0x3b, 0x7f, 0x6b, 0xd3, 0x25, 0xbf, 0xad, 0xc7, 0xc5, 0xc5, 0xb5, 0x8b, 0xef, 0x2f, 0xd3, 0x07,",
          "4496:      0x6b, 0x25, 0x49, 0x95, 0x25, 0x49, 0x6d, 0x71, 0xc7},",
          "4497:     {0xa7, 0xbc, 0xc9, 0xad, 0x91, 0xdf, 0x85, 0xe5, 0xd4, 0x78, 0xd5, 0x17, 0x46, 0x7c, 0x29, 0x4c, 0x4d, 0x03, 0xe9,",
          "4498:      0x25, 0x68, 0x11, 0x86, 0xb3, 0xbd, 0xf7, 0x6f, 0x61, 0x22, 0xa2, 0x26, 0x34, 0x2a, 0xbe, 0x1e, 0x46, 0x14, 0x68,",
          "4499:      0x9d, 0x44, 0x18, 0xc2, 0x40, 0xf4, 0x7e, 0x5f, 0x1b, 0xad, 0x0b, 0x94, 0xb6, 0x67, 0xb4, 0x0b, 0xe1, 0xea, 0x95,",
          "4500:      0x9c, 0x66, 0xdc, 0xe7, 0x5d, 0x6c, 0x05, 0xda, 0xd5, 0xdf, 0x7a, 0xef, 0xf6, 0xdb, 0x1f, 0x82, 0x4c, 0xc0, 0x68,",
          "4501:      0x47, 0xa1, 0xbd, 0xee, 0x39, 0x50, 0x56, 0x4a, 0xdd, 0xdf, 0xa5, 0xf8, 0xc6, 0xda, 0xca, 0x90, 0xca, 0x01, 0x42,",
          "4502:      0x9d, 0x8b, 0x0c, 0x73, 0x43, 0x75, 0x05, 0x94, 0xde, 0x24, 0xb3, 0x80, 0x34, 0xe5, 0x2c, 0xdc, 0x9b, 0x3f, 0xca,",
          "4503:      0x33, 0x45, 0xd0, 0xdb, 0x5f, 0xf5, 0x52, 0xc3, 0x21, 0xda, 0xe2, 0x22, 0x72, 0x6b, 0x3e, 0xd0, 0x5b, 0xa8, 0x87,",
          "4504:      0x8c, 0x06, 0x5d, 0x0f, 0xdd, 0x09, 0x19, 0x93, 0xd0, 0xb9, 0xfc, 0x8b, 0x0f, 0x84, 0x60, 0x33, 0x1c, 0x9b, 0x45,",
          "4505:      0xf1, 0xf0, 0xa3, 0x94, 0x3a, 0x12, 0x77, 0x33, 0x4d, 0x44, 0x78, 0x28, 0x3c, 0x9e, 0xfd, 0x65, 0x57, 0x16, 0x94,",
          "4506:      0x6b, 0xfb, 0x59, 0xd0, 0xc8, 0x22, 0x36, 0xdb, 0xd2, 0x63, 0x98, 0x43, 0xa1, 0x04, 0x87, 0x86, 0xf7, 0xa6, 0x26,",
          "4507:      0xbb, 0xd6, 0x59, 0x4d, 0xbf, 0x6a, 0x2e, 0xaa, 0x2b, 0xef, 0xe6, 0x78, 0xb6, 0x4e, 0xe0, 0x2f, 0xdc, 0x7c, 0xbe,",
          "4508:      0x57, 0x19, 0x32, 0x7e, 0x2a, 0xd0, 0xb8, 0xba, 0x29, 0x00, 0x3c, 0x52, 0x7d, 0xa8, 0x49, 0x3b, 0x2d, 0xeb, 0x25,",
          "4509:      0x49, 0xfa, 0xa3, 0xaa, 0x39, 0xa7, 0xc5, 0xa7, 0x50, 0x11, 0x36, 0xfb, 0xc6, 0x67, 0x4a, 0xf5, 0xa5, 0x12, 0x65,",
          "4510:      0x7e, 0xb0, 0xdf, 0xaf, 0x4e, 0xb3, 0x61, 0x7f, 0x2f}};",
          "4512: void CLASS gamma_curve(double pwr, double ts, int mode, int imax)",
          "4515:   double g[6], bnd[2] = {0, 0}, r;",
          "4521:   if (g[1] && (g[1] - 1) * (g[0] - 1) <= 0)",
          "4522:   {",
          "4523:     for (i = 0; i < 48; i++)",
          "4524:     {",
          "4525:       g[2] = (bnd[0] + bnd[1]) / 2;",
          "4526:       if (g[0])",
          "4527:         bnd[(pow(g[2] / g[1], -g[0]) - 1) / g[0] - 1 / g[2] > -1] = g[2];",
          "4528:       else",
          "4529:         bnd[g[2] / exp(1 - 1 / g[2]) < g[1]] = g[2];",
          "4532:     if (g[0])",
          "4533:       g[4] = g[2] * (1 / g[0] - 1);",
          "4534:   }",
          "4535:   if (g[0])",
          "4536:     g[5] = 1 / (g[1] * SQR(g[3]) / 2 - g[4] * (1 - g[3]) + (1 - pow(g[3], 1 + g[0])) * (1 + g[4]) / (1 + g[0])) - 1;",
          "4537:   else",
          "4538:     g[5] = 1 / (g[1] * SQR(g[3]) / 2 + 1 - g[2] - g[3] - g[2] * g[3] * (log(g[3]) - 1)) - 1;",
          "4539:   if (!mode--)",
          "4540:   {",
          "4541:     memcpy(gamm, g, sizeof gamm);",
          "4544:   for (i = 0; i < 0x10000; i++)",
          "4545:   {",
          "4547:     if ((r = (double)i / imax) < 1)",
          "4548:       curve[i] = 0x10000 *",
          "4549:                  (mode ? (r < g[3] ? r * g[1] : (g[0] ? pow(r, g[0]) * (1 + g[4]) - g[4] : log(r) * g[2] + 1))",
          "4550:                        : (r < g[2] ? r / g[1] : (g[0] ? pow((r + g[4]) / (1 + g[4]), 1 / g[0]) : exp((r - 1) / g[2]))));",
          "4554: void CLASS pseudoinverse(double (*in)[3], double (*out)[3], int size)",
          "4559:   for (i = 0; i < 3; i++)",
          "4560:   {",
          "4561:     for (j = 0; j < 6; j++)",
          "4562:       work[i][j] = j == i + 3;",
          "4563:     for (j = 0; j < 3; j++)",
          "4564:       for (k = 0; k < size; k++)",
          "4565:         work[i][j] += in[k][i] * in[k][j];",
          "4567:   for (i = 0; i < 3; i++)",
          "4568:   {",
          "4570:     for (j = 0; j < 6; j++)",
          "4572:     for (k = 0; k < 3; k++)",
          "4573:     {",
          "4574:       if (k == i)",
          "4575:         continue;",
          "4577:       for (j = 0; j < 6; j++)",
          "4578:         work[k][j] -= work[i][j] * num;",
          "4581:   for (i = 0; i < size; i++)",
          "4582:     for (j = 0; j < 3; j++)",
          "4583:       for (out[i][j] = k = 0; k < 3; k++)",
          "4584:         out[i][j] += work[j][k + 3] * in[i][k];",
          "4587: void CLASS cam_xyz_coeff(float _rgb_cam[3][4], double cam_xyz[4][3])",
          "4593:     for (j = 0; j < 3; j++)",
          "4594:       for (cam_rgb[i][j] = k = 0; k < 3; k++)",
          "4595:         cam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];",
          "4597:   for (i = 0; i < colors; i++)",
          "4601:     if (num > 0.00001)",
          "4602:     {",
          "4603:       for (j = 0; j < 3; j++)",
          "4604:         cam_rgb[i][j] /= num;",
          "4605:       pre_mul[i] = 1 / num;",
          "4606:     }",
          "4608:     {",
          "4609:       for (j = 0; j < 3; j++)",
          "4610:         cam_rgb[i][j] = 0.0;",
          "4611:       pre_mul[i] = 1.0;",
          "4612:     }",
          "4614:   pseudoinverse(cam_rgb, inverse, colors);",
          "4615:   for (i = 0; i < 3; i++)",
          "4616:     for (j = 0; j < colors; j++)",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "4094: void CLASS colorcheck()",
          "4095: {",
          "4096: #define NSQ 24",
          "4126:   double gmb_cam[NSQ][4], gmb_xyz[NSQ][3];",
          "4127:   double inverse[NSQ][3], cam_xyz[4][3], balance[4], num;",
          "4128:   int c, i, j, k, sq, row, col, pass, count[4];",
          "4132:     FORCC count[c] = 0;",
          "4142:     gmb_xyz[sq][0] = gmb_xyY[sq][2] * gmb_xyY[sq][0] / gmb_xyY[sq][1];",
          "4143:     gmb_xyz[sq][1] = gmb_xyY[sq][2];",
          "4154:     FORCC balance[c] = pre_mul[c] * gmb_cam[20][c];",
          "4156:       FORCC gmb_cam[sq][c] *= balance[c];",
          "4157:   }",
          "4160:     num = 10000 / (cam_xyz[1][0] + cam_xyz[1][1] + cam_xyz[1][2]);",
          "4164:   }",
          "4165: #undef NSQ",
          "4166: }",
          "4167: #endif",
          "4170: {",
          "4171:   int i;",
          "4176:   for (; i < size; i++)",
          "4178: }",
          "4180: #if !defined(LIBRAW_USE_OPENMP)",
          "4181: void CLASS wavelet_denoise()",
          "4182: {",
          "4185:   ushort *window[4];",
          "4189: #ifdef DCRAW_VERBOSE",
          "4191: #endif",
          "4194:   maximum <<= --scale;",
          "4195:   black <<= scale;",
          "4196:   FORC4 cblack[c] <<= scale;",
          "4204:       fimg[i] = 256 * sqrt((double)(image[i][c] << scale));",
          "4216:       }",
          "4217:       thold = threshold * noise[lev];",
          "4224:       }",
          "4225:       hpass = lpass;",
          "4226:     }",
          "4229:   }",
          "4234:     }",
          "4243:       }",
          "4255:       }",
          "4256:     }",
          "4257:   }",
          "4259: }",
          "4261: void CLASS wavelet_denoise()",
          "4262: {",
          "4265:   ushort *window[4];",
          "4269: #ifdef DCRAW_VERBOSE",
          "4271: #endif",
          "4274:   maximum <<= --scale;",
          "4275:   black <<= scale;",
          "4276:   FORC4 cblack[c] <<= scale;",
          "4282: #ifdef LIBRAW_LIBRARY_BUILD",
          "4284: #endif",
          "4285:   {",
          "4288: #ifdef LIBRAW_LIBRARY_BUILD",
          "4289: #pragma omp for",
          "4290: #endif",
          "4292:         fimg[i] = 256 * sqrt((double)(image[i][c] << scale));",
          "4295: #ifdef LIBRAW_LIBRARY_BUILD",
          "4296: #pragma omp for",
          "4297: #endif",
          "4303: #ifdef LIBRAW_LIBRARY_BUILD",
          "4304: #pragma omp for",
          "4305: #endif",
          "4312: #ifdef LIBRAW_LIBRARY_BUILD",
          "4313: #pragma omp for",
          "4314: #endif",
          "4323:       }",
          "4324: #ifdef LIBRAW_LIBRARY_BUILD",
          "4325: #pragma omp for",
          "4326: #endif",
          "4329:     }",
          "4330:     free(temp);",
          "4349:       }",
          "4361:       }",
          "4362:     }",
          "4363:   }",
          "4365: }",
          "4367: #endif",
          "",
          "[Removed Lines]",
          "4099:   int cut[NSQ][4];   // you must set these",
          "4101:   static const double gmb_xyY[NSQ][3] = {",
          "4102:     { 0.400, 0.350, 10.1 },  // Dark Skin",
          "4103:     { 0.377, 0.345, 35.8 },  // Light Skin",
          "4104:     { 0.247, 0.251, 19.3 },  // Blue Sky",
          "4105:     { 0.337, 0.422, 13.3 },  // Foliage",
          "4106:     { 0.265, 0.240, 24.3 },  // Blue Flower",
          "4107:     { 0.261, 0.343, 43.1 },  // Bluish Green",
          "4108:     { 0.506, 0.407, 30.1 },  // Orange",
          "4109:     { 0.211, 0.175, 12.0 },  // Purplish Blue",
          "4110:     { 0.453, 0.306, 19.8 },  // Moderate Red",
          "4111:     { 0.285, 0.202, 6.6 },  // Purple",
          "4112:     { 0.380, 0.489, 44.3 },  // Yellow Green",
          "4113:     { 0.473, 0.438, 43.1 },  // Orange Yellow",
          "4114:     { 0.187, 0.129, 6.1 },  // Blue",
          "4115:     { 0.305, 0.478, 23.4 },  // Green",
          "4116:     { 0.539, 0.313, 12.0 },  // Red",
          "4117:     { 0.448, 0.470, 59.1 },  // Yellow",
          "4118:     { 0.364, 0.233, 19.8 },  // Magenta",
          "4119:     { 0.196, 0.252, 19.8 },  // Cyan",
          "4120:     { 0.310, 0.316, 90.0 },  // White",
          "4121:     { 0.310, 0.316, 59.1 },  // Neutral 8",
          "4122:     { 0.310, 0.316, 36.2 },  // Neutral 6.5",
          "4123:     { 0.310, 0.316, 19.8 },  // Neutral 5",
          "4124:     { 0.310, 0.316, 9.0 },  // Neutral 3.5",
          "4125:     { 0.310, 0.316, 3.1 } };  // Black",
          "4130:   memset (gmb_cam, 0, sizeof gmb_cam);",
          "4131:   for (sq=0; sq < NSQ; sq++) {",
          "4133:     for   (row=cut[sq][3]; row < cut[sq][3]+cut[sq][1]; row++)",
          "4134:       for (col=cut[sq][2]; col < cut[sq][2]+cut[sq][0]; col++) {",
          "4135:  c = FC(row,col);",
          "4136:  if (c >= colors) c -= 2;",
          "4137:  gmb_cam[sq][c] += BAYER2(row,col);",
          "4138:  BAYER2(row,col) = black + (BAYER2(row,col)-black)/2;",
          "4139:  count[c]++;",
          "4140:       }",
          "4141:     FORCC gmb_cam[sq][c] = gmb_cam[sq][c]/count[c] - black;",
          "4144:     gmb_xyz[sq][2] = gmb_xyY[sq][2] *",
          "4145:   (1 - gmb_xyY[sq][0] - gmb_xyY[sq][1]) / gmb_xyY[sq][1];",
          "4146:   }",
          "4147:   pseudoinverse (gmb_xyz, inverse, NSQ);",
          "4148:   for (pass=0; pass < 2; pass++) {",
          "4149:     for (raw_color = i=0; i < colors; i++)",
          "4150:       for (j=0; j < 3; j++)",
          "4151:  for (cam_xyz[i][j] = k=0; k < NSQ; k++)",
          "4152:    cam_xyz[i][j] += gmb_cam[k][i] * inverse[k][j];",
          "4153:     cam_xyz_coeff (rgb_cam, cam_xyz);",
          "4155:     for (sq=0; sq < NSQ; sq++)",
          "4158:   if (verbose) {",
          "4159:     printf (\"    { \\\"%s %s\\\", %d,\\n\\t{\", make, model, black);",
          "4161:     FORCC for (j=0; j < 3; j++)",
          "4162:       printf (\"%c%d\", (c | j) ? ',':' ', (int) (cam_xyz[c][j] * num + 0.5));",
          "4163:     puts (\" } },\");",
          "4169: void CLASS hat_transform (float *temp, float *base, int st, int size, int sc)",
          "4172:   for (i=0; i < sc; i++)",
          "4173:     temp[i] = 2*base[st*i] + base[st*(sc-i)] + base[st*(i+sc)];",
          "4174:   for (; i+sc < size; i++)",
          "4175:     temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(i+sc)];",
          "4177:     temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(2*size-2-(i+sc))];",
          "4183:   float *fimg=0, *temp, thold, mul[2], avg, diff;",
          "4184:   int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];",
          "4186:   static const float noise[] =",
          "4187:   { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };",
          "4190:   if (verbose) fprintf (stderr,_(\"Wavelet denoising...\\n\"));",
          "4193:   while (maximum << scale < 0x10000) scale++;",
          "4197:   if ((size = iheight*iwidth) < 0x15550000)",
          "4198:     fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);",
          "4199:   merror (fimg, \"wavelet_denoise()\");",
          "4200:   temp = fimg + size*3;",
          "4201:   if ((nc = colors) == 3 && filters) nc++;",
          "4203:     for (i=0; i < size; i++)",
          "4205:     for (hpass=lev=0; lev < 5; lev++) {",
          "4206:       lpass = size*((lev & 1)+1);",
          "4207:       for (row=0; row < iheight; row++) {",
          "4208:  hat_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 << lev);",
          "4209:  for (col=0; col < iwidth; col++)",
          "4210:    fimg[lpass + row*iwidth + col] = temp[col] * 0.25;",
          "4211:       }",
          "4212:       for (col=0; col < iwidth; col++) {",
          "4213:  hat_transform (temp, fimg+lpass+col, iwidth, iheight, 1 << lev);",
          "4214:  for (row=0; row < iheight; row++)",
          "4215:    fimg[lpass + row*iwidth + col] = temp[row] * 0.25;",
          "4218:       for (i=0; i < size; i++) {",
          "4219:  fimg[hpass+i] -= fimg[lpass+i];",
          "4220:  if (fimg[hpass+i] < -thold) fimg[hpass+i] += thold;",
          "4221:  else if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;",
          "4222:  else  fimg[hpass+i] = 0;",
          "4223:  if (hpass) fimg[i] += fimg[hpass+i];",
          "4227:     for (i=0; i < size; i++)",
          "4228:       image[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);",
          "4231:     for (row=0; row < 2; row++) {",
          "4232:       mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];",
          "4233:       blk[row] = cblack[FC(row,0) | 1];",
          "4235:     for (i=0; i < 4; i++)",
          "4236:       window[i] = (ushort *) fimg + width*i;",
          "4237:     for (wlast=-1, row=1; row < height-1; row++) {",
          "4238:       while (wlast < row+1) {",
          "4239:  for (wlast++, i=0; i < 4; i++)",
          "4240:    window[(i+3) & 3] = window[i];",
          "4241:  for (col = FC(wlast,1) & 1; col < width; col+=2)",
          "4242:    window[2][col] = BAYER(wlast,col);",
          "4244:       thold = threshold/512;",
          "4245:       for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {",
          "4246:  avg = ( window[0][col-1] + window[0][col+1] +",
          "4247:   window[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )",
          "4249:  avg = avg < 0 ? 0 : sqrt(avg);",
          "4250:  diff = sqrt((double)BAYER(row,col)) - avg;",
          "4251:  if      (diff < -thold) diff += thold;",
          "4252:  else if (diff >  thold) diff -= thold;",
          "4253:  else diff = 0;",
          "4254:  BAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);",
          "4258:   free (fimg);",
          "4263:   float *fimg=0, *temp, thold, mul[2], avg, diff;",
          "4264:    int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];",
          "4266:   static const float noise[] =",
          "4267:   { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };",
          "4270:   if (verbose) fprintf (stderr,_(\"Wavelet denoising...\\n\"));",
          "4273:   while (maximum << scale < 0x10000) scale++;",
          "4277:   if ((size = iheight*iwidth) < 0x15550000)",
          "4278:     fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);",
          "4279:   merror (fimg, \"wavelet_denoise()\");",
          "4280:   temp = fimg + size*3;",
          "4281:   if ((nc = colors) == 3 && filters) nc++;",
          "4283: #pragma omp parallel default(shared) private(i,col,row,thold,lev,lpass,hpass,temp,c) firstprivate(scale,size)",
          "4286:       temp = (float*)malloc( (iheight + iwidth) * sizeof *fimg);",
          "4291:       for (i=0; i < size; i++)",
          "4293:       for (hpass=lev=0; lev < 5; lev++) {",
          "4294:  lpass = size*((lev & 1)+1);",
          "4298:  for (row=0; row < iheight; row++) {",
          "4299:    hat_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 << lev);",
          "4300:    for (col=0; col < iwidth; col++)",
          "4301:      fimg[lpass + row*iwidth + col] = temp[col] * 0.25;",
          "4302:  }",
          "4306:  for (col=0; col < iwidth; col++) {",
          "4307:    hat_transform (temp, fimg+lpass+col, iwidth, iheight, 1 << lev);",
          "4308:    for (row=0; row < iheight; row++)",
          "4309:      fimg[lpass + row*iwidth + col] = temp[row] * 0.25;",
          "4310:  }",
          "4311:  thold = threshold * noise[lev];",
          "4315:  for (i=0; i < size; i++) {",
          "4316:    fimg[hpass+i] -= fimg[lpass+i];",
          "4317:    if (fimg[hpass+i] < -thold) fimg[hpass+i] += thold;",
          "4318:    else if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;",
          "4319:    else  fimg[hpass+i] = 0;",
          "4320:    if (hpass) fimg[i] += fimg[hpass+i];",
          "4321:  }",
          "4322:  hpass = lpass;",
          "4327:       for (i=0; i < size; i++)",
          "4328:  image[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);",
          "4337:    for (row=0; row < 2; row++){",
          "4338:       mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];",
          "4339:       blk[row] = cblack[FC(row,0) | 1];",
          "4340:    }",
          "4341:     for (i=0; i < 4; i++)",
          "4342:       window[i] = (ushort *) fimg + width*i;",
          "4343:     for (wlast=-1, row=1; row < height-1; row++) {",
          "4344:       while (wlast < row+1) {",
          "4345:  for (wlast++, i=0; i < 4; i++)",
          "4346:    window[(i+3) & 3] = window[i];",
          "4347:  for (col = FC(wlast,1) & 1; col < width; col+=2)",
          "4348:    window[2][col] = BAYER(wlast,col);",
          "4350:       thold = threshold/512;",
          "4351:       for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {",
          "4352:  avg = ( window[0][col-1] + window[0][col+1] +",
          "4353:   window[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )",
          "4355:  avg = avg < 0 ? 0 : sqrt(avg);",
          "4356:  diff = sqrt((double)BAYER(row,col)) - avg;",
          "4357:  if      (diff < -thold) diff += thold;",
          "4358:  else if (diff >  thold) diff -= thold;",
          "4359:  else diff = 0;",
          "4360:  BAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);",
          "4364:   free (fimg);",
          "",
          "[Added Lines]",
          "4626:   int cut[NSQ][4];                                             // you must set these",
          "4628:   static const double gmb_xyY[NSQ][3] = {{0.400, 0.350, 10.1}, // Dark Skin",
          "4629:                                          {0.377, 0.345, 35.8}, // Light Skin",
          "4630:                                          {0.247, 0.251, 19.3}, // Blue Sky",
          "4631:                                          {0.337, 0.422, 13.3}, // Foliage",
          "4632:                                          {0.265, 0.240, 24.3}, // Blue Flower",
          "4633:                                          {0.261, 0.343, 43.1}, // Bluish Green",
          "4634:                                          {0.506, 0.407, 30.1}, // Orange",
          "4635:                                          {0.211, 0.175, 12.0}, // Purplish Blue",
          "4636:                                          {0.453, 0.306, 19.8}, // Moderate Red",
          "4637:                                          {0.285, 0.202, 6.6},  // Purple",
          "4638:                                          {0.380, 0.489, 44.3}, // Yellow Green",
          "4639:                                          {0.473, 0.438, 43.1}, // Orange Yellow",
          "4640:                                          {0.187, 0.129, 6.1},  // Blue",
          "4641:                                          {0.305, 0.478, 23.4}, // Green",
          "4642:                                          {0.539, 0.313, 12.0}, // Red",
          "4643:                                          {0.448, 0.470, 59.1}, // Yellow",
          "4644:                                          {0.364, 0.233, 19.8}, // Magenta",
          "4645:                                          {0.196, 0.252, 19.8}, // Cyan",
          "4646:                                          {0.310, 0.316, 90.0}, // White",
          "4647:                                          {0.310, 0.316, 59.1}, // Neutral 8",
          "4648:                                          {0.310, 0.316, 36.2}, // Neutral 6.5",
          "4649:                                          {0.310, 0.316, 19.8}, // Neutral 5",
          "4650:                                          {0.310, 0.316, 9.0},  // Neutral 3.5",
          "4651:                                          {0.310, 0.316, 3.1}}; // Black",
          "4656:   memset(gmb_cam, 0, sizeof gmb_cam);",
          "4657:   for (sq = 0; sq < NSQ; sq++)",
          "4658:   {",
          "4660:     for (row = cut[sq][3]; row < cut[sq][3] + cut[sq][1]; row++)",
          "4661:       for (col = cut[sq][2]; col < cut[sq][2] + cut[sq][0]; col++)",
          "4662:       {",
          "4663:         c = FC(row, col);",
          "4664:         if (c >= colors)",
          "4665:           c -= 2;",
          "4666:         gmb_cam[sq][c] += BAYER2(row, col);",
          "4667:         BAYER2(row, col) = black + (BAYER2(row, col) - black) / 2;",
          "4668:         count[c]++;",
          "4669:       }",
          "4670:     FORCC gmb_cam[sq][c] = gmb_cam[sq][c] / count[c] - black;",
          "4673:     gmb_xyz[sq][2] = gmb_xyY[sq][2] * (1 - gmb_xyY[sq][0] - gmb_xyY[sq][1]) / gmb_xyY[sq][1];",
          "4674:   }",
          "4675:   pseudoinverse(gmb_xyz, inverse, NSQ);",
          "4676:   for (pass = 0; pass < 2; pass++)",
          "4677:   {",
          "4678:     for (raw_color = i = 0; i < colors; i++)",
          "4679:       for (j = 0; j < 3; j++)",
          "4680:         for (cam_xyz[i][j] = k = 0; k < NSQ; k++)",
          "4681:           cam_xyz[i][j] += gmb_cam[k][i] * inverse[k][j];",
          "4682:     cam_xyz_coeff(rgb_cam, cam_xyz);",
          "4684:     for (sq = 0; sq < NSQ; sq++)",
          "4687:   if (verbose)",
          "4688:   {",
          "4689:     printf(\"    { \\\"%s %s\\\", %d,\\n\\t{\", make, model, black);",
          "4691:     FORCC for (j = 0; j < 3; j++) printf(\"%c%d\", (c | j) ? ',' : ' ', (int)(cam_xyz[c][j] * num + 0.5));",
          "4692:     puts(\" } },\");",
          "4698: void CLASS hat_transform(float *temp, float *base, int st, int size, int sc)",
          "4701:   for (i = 0; i < sc; i++)",
          "4702:     temp[i] = 2 * base[st * i] + base[st * (sc - i)] + base[st * (i + sc)];",
          "4703:   for (; i + sc < size; i++)",
          "4704:     temp[i] = 2 * base[st * i] + base[st * (i - sc)] + base[st * (i + sc)];",
          "4706:     temp[i] = 2 * base[st * i] + base[st * (i - sc)] + base[st * (2 * size - 2 - (i + sc))];",
          "4712:   float *fimg = 0, *temp, thold, mul[2], avg, diff;",
          "4713:   int scale = 1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];",
          "4715:   static const float noise[] = {0.8002, 0.2735, 0.1202, 0.0585, 0.0291, 0.0152, 0.0080, 0.0044};",
          "4718:   if (verbose)",
          "4719:     fprintf(stderr, _(\"Wavelet denoising...\\n\"));",
          "4722:   while (maximum << scale < 0x10000)",
          "4723:     scale++;",
          "4727:   if ((size = iheight * iwidth) < 0x15550000)",
          "4728:     fimg = (float *)malloc((size * 3 + iheight + iwidth) * sizeof *fimg);",
          "4729:   merror(fimg, \"wavelet_denoise()\");",
          "4730:   temp = fimg + size * 3;",
          "4731:   if ((nc = colors) == 3 && filters)",
          "4732:     nc++;",
          "4733:   FORC(nc)",
          "4735:     for (i = 0; i < size; i++)",
          "4737:     for (hpass = lev = 0; lev < 5; lev++)",
          "4738:     {",
          "4739:       lpass = size * ((lev & 1) + 1);",
          "4740:       for (row = 0; row < iheight; row++)",
          "4741:       {",
          "4742:         hat_transform(temp, fimg + hpass + row * iwidth, 1, iwidth, 1 << lev);",
          "4743:         for (col = 0; col < iwidth; col++)",
          "4744:           fimg[lpass + row * iwidth + col] = temp[col] * 0.25;",
          "4745:       }",
          "4746:       for (col = 0; col < iwidth; col++)",
          "4747:       {",
          "4748:         hat_transform(temp, fimg + lpass + col, iwidth, iheight, 1 << lev);",
          "4749:         for (row = 0; row < iheight; row++)",
          "4750:           fimg[lpass + row * iwidth + col] = temp[row] * 0.25;",
          "4753:       for (i = 0; i < size; i++)",
          "4754:       {",
          "4755:         fimg[hpass + i] -= fimg[lpass + i];",
          "4756:         if (fimg[hpass + i] < -thold)",
          "4757:           fimg[hpass + i] += thold;",
          "4758:         else if (fimg[hpass + i] > thold)",
          "4759:           fimg[hpass + i] -= thold;",
          "4760:         else",
          "4761:           fimg[hpass + i] = 0;",
          "4762:         if (hpass)",
          "4763:           fimg[i] += fimg[hpass + i];",
          "4767:     for (i = 0; i < size; i++)",
          "4768:       image[i][c] = CLIP(SQR(fimg[i] + fimg[lpass + i]) / 0x10000);",
          "4770:   if (filters && colors == 3)",
          "4772:     for (row = 0; row < 2; row++)",
          "4773:     {",
          "4774:       mul[row] = 0.125 * pre_mul[FC(row + 1, 0) | 1] / pre_mul[FC(row, 0) | 1];",
          "4775:       blk[row] = cblack[FC(row, 0) | 1];",
          "4777:     for (i = 0; i < 4; i++)",
          "4778:       window[i] = (ushort *)fimg + width * i;",
          "4779:     for (wlast = -1, row = 1; row < height - 1; row++)",
          "4780:     {",
          "4781:       while (wlast < row + 1)",
          "4782:       {",
          "4783:         for (wlast++, i = 0; i < 4; i++)",
          "4784:           window[(i + 3) & 3] = window[i];",
          "4785:         for (col = FC(wlast, 1) & 1; col < width; col += 2)",
          "4786:           window[2][col] = BAYER(wlast, col);",
          "4788:       thold = threshold / 512;",
          "4789:       for (col = (FC(row, 0) & 1) + 1; col < width - 1; col += 2)",
          "4790:       {",
          "4791:         avg = (window[0][col - 1] + window[0][col + 1] + window[2][col - 1] + window[2][col + 1] - blk[~row & 1] * 4) *",
          "4792:                   mul[row & 1] +",
          "4793:               (window[1][col] + blk[row & 1]) * 0.5;",
          "4794:         avg = avg < 0 ? 0 : sqrt(avg);",
          "4795:         diff = sqrt((double)BAYER(row, col)) - avg;",
          "4796:         if (diff < -thold)",
          "4797:           diff += thold;",
          "4798:         else if (diff > thold)",
          "4799:           diff -= thold;",
          "4800:         else",
          "4801:           diff = 0;",
          "4802:         BAYER(row, col) = CLIP(SQR(avg + diff) + 0.5);",
          "4806:   free(fimg);",
          "4811:   float *fimg = 0, *temp, thold, mul[2], avg, diff;",
          "4812:   int scale = 1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];",
          "4814:   static const float noise[] = {0.8002, 0.2735, 0.1202, 0.0585, 0.0291, 0.0152, 0.0080, 0.0044};",
          "4817:   if (verbose)",
          "4818:     fprintf(stderr, _(\"Wavelet denoising...\\n\"));",
          "4821:   while (maximum << scale < 0x10000)",
          "4822:     scale++;",
          "4826:   if ((size = iheight * iwidth) < 0x15550000)",
          "4827:     fimg = (float *)malloc((size * 3 + iheight + iwidth) * sizeof *fimg);",
          "4828:   merror(fimg, \"wavelet_denoise()\");",
          "4829:   temp = fimg + size * 3;",
          "4830:   if ((nc = colors) == 3 && filters)",
          "4831:     nc++;",
          "4833: #pragma omp parallel default(shared) private(i, col, row, thold, lev, lpass, hpass, temp, c) firstprivate(scale, size)",
          "4836:     temp = (float *)malloc((iheight + iwidth) * sizeof *fimg);",
          "4837:     FORC(nc)",
          "4842:       for (i = 0; i < size; i++)",
          "4844:       for (hpass = lev = 0; lev < 5; lev++)",
          "4845:       {",
          "4846:         lpass = size * ((lev & 1) + 1);",
          "4850:         for (row = 0; row < iheight; row++)",
          "4851:         {",
          "4852:           hat_transform(temp, fimg + hpass + row * iwidth, 1, iwidth, 1 << lev);",
          "4853:           for (col = 0; col < iwidth; col++)",
          "4854:             fimg[lpass + row * iwidth + col] = temp[col] * 0.25;",
          "4855:         }",
          "4859:         for (col = 0; col < iwidth; col++)",
          "4860:         {",
          "4861:           hat_transform(temp, fimg + lpass + col, iwidth, iheight, 1 << lev);",
          "4862:           for (row = 0; row < iheight; row++)",
          "4863:             fimg[lpass + row * iwidth + col] = temp[row] * 0.25;",
          "4864:         }",
          "4865:         thold = threshold * noise[lev];",
          "4869:         for (i = 0; i < size; i++)",
          "4870:         {",
          "4871:           fimg[hpass + i] -= fimg[lpass + i];",
          "4872:           if (fimg[hpass + i] < -thold)",
          "4873:             fimg[hpass + i] += thold;",
          "4874:           else if (fimg[hpass + i] > thold)",
          "4875:             fimg[hpass + i] -= thold;",
          "4876:           else",
          "4877:             fimg[hpass + i] = 0;",
          "4878:           if (hpass)",
          "4879:             fimg[i] += fimg[hpass + i];",
          "4880:         }",
          "4881:         hpass = lpass;",
          "4886:       for (i = 0; i < size; i++)",
          "4887:         image[i][c] = CLIP(SQR(fimg[i] + fimg[lpass + i]) / 0x10000);",
          "4895:   if (filters && colors == 3)",
          "4897:     for (row = 0; row < 2; row++)",
          "4898:     {",
          "4899:       mul[row] = 0.125 * pre_mul[FC(row + 1, 0) | 1] / pre_mul[FC(row, 0) | 1];",
          "4900:       blk[row] = cblack[FC(row, 0) | 1];",
          "4901:     }",
          "4902:     for (i = 0; i < 4; i++)",
          "4903:       window[i] = (ushort *)fimg + width * i;",
          "4904:     for (wlast = -1, row = 1; row < height - 1; row++)",
          "4905:     {",
          "4906:       while (wlast < row + 1)",
          "4907:       {",
          "4908:         for (wlast++, i = 0; i < 4; i++)",
          "4909:           window[(i + 3) & 3] = window[i];",
          "4910:         for (col = FC(wlast, 1) & 1; col < width; col += 2)",
          "4911:           window[2][col] = BAYER(wlast, col);",
          "4913:       thold = threshold / 512;",
          "4914:       for (col = (FC(row, 0) & 1) + 1; col < width - 1; col += 2)",
          "4915:       {",
          "4916:         avg = (window[0][col - 1] + window[0][col + 1] + window[2][col - 1] + window[2][col + 1] - blk[~row & 1] * 4) *",
          "4917:                   mul[row & 1] +",
          "4918:               (window[1][col] + blk[row & 1]) * 0.5;",
          "4919:         avg = avg < 0 ? 0 : sqrt(avg);",
          "4920:         diff = sqrt((double)BAYER(row, col)) - avg;",
          "4921:         if (diff < -thold)",
          "4922:           diff += thold;",
          "4923:         else if (diff > thold)",
          "4924:           diff -= thold;",
          "4925:         else",
          "4926:           diff = 0;",
          "4927:         BAYER(row, col) = CLIP(SQR(avg + diff) + 0.5);",
          "4931:   free(fimg);",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "4370: void CLASS green_matching()",
          "4371: {",
          "4377:   const int margin = 3;",
          "4378:   int oj = 2, oi = 2;",
          "4379:   float f;",
          "4380:   const float thr = 0.01f;",
          "4407:       {",
          "4410:       }",
          "4411:     }",
          "4412:   free(img);",
          "",
          "[Removed Lines]",
          "4372:   int i,j;",
          "4373:   double m1,m2,c1,c2;",
          "4374:   int o1_1,o1_2,o1_3,o1_4;",
          "4375:   int o2_1,o2_2,o2_3,o2_4;",
          "4376:   ushort (*img)[4];",
          "4381:   if(half_size || shrink) return;",
          "4382:   if(FC(oj, oi) != 3) oj++;",
          "4383:   if(FC(oj, oi) != 3) oi++;",
          "4384:   if(FC(oj, oi) != 3) oj--;",
          "4386:   img = (ushort (*)[4]) calloc (height*width, sizeof *image);",
          "4387:   merror (img, \"green_matching()\");",
          "4388:   memcpy(img,image,height*width*sizeof *image);",
          "4390:   for(j=oj;j<height-margin;j+=2)",
          "4391:     for(i=oi;i<width-margin;i+=2){",
          "4392:       o1_1=img[(j-1)*width+i-1][1];",
          "4393:       o1_2=img[(j-1)*width+i+1][1];",
          "4394:       o1_3=img[(j+1)*width+i-1][1];",
          "4395:       o1_4=img[(j+1)*width+i+1][1];",
          "4396:       o2_1=img[(j-2)*width+i][3];",
          "4397:       o2_2=img[(j+2)*width+i][3];",
          "4398:       o2_3=img[j*width+i-2][3];",
          "4399:       o2_4=img[j*width+i+2][3];",
          "4401:       m1=(o1_1+o1_2+o1_3+o1_4)/4.0;",
          "4402:       m2=(o2_1+o2_2+o2_3+o2_4)/4.0;",
          "4404:       c1=(abs(o1_1-o1_2)+abs(o1_1-o1_3)+abs(o1_1-o1_4)+abs(o1_2-o1_3)+abs(o1_3-o1_4)+abs(o1_2-o1_4))/6.0;",
          "4405:       c2=(abs(o2_1-o2_2)+abs(o2_1-o2_3)+abs(o2_1-o2_4)+abs(o2_2-o2_3)+abs(o2_3-o2_4)+abs(o2_2-o2_4))/6.0;",
          "4406:       if((img[j*width+i][3]<maximum*0.95)&&(c1<maximum*thr)&&(c2<maximum*thr))",
          "4408:         f = image[j*width+i][3]*m1/m2;",
          "4409:         image[j*width+i][3]=f>0xffff?0xffff:f;",
          "",
          "[Added Lines]",
          "4939:   int i, j;",
          "4940:   double m1, m2, c1, c2;",
          "4941:   int o1_1, o1_2, o1_3, o1_4;",
          "4942:   int o2_1, o2_2, o2_3, o2_4;",
          "4943:   ushort(*img)[4];",
          "4948:   if (half_size || shrink)",
          "4949:     return;",
          "4950:   if (FC(oj, oi) != 3)",
          "4951:     oj++;",
          "4952:   if (FC(oj, oi) != 3)",
          "4953:     oi++;",
          "4954:   if (FC(oj, oi) != 3)",
          "4955:     oj--;",
          "4957:   img = (ushort(*)[4])calloc(height * width, sizeof *image);",
          "4958:   merror(img, \"green_matching()\");",
          "4959:   memcpy(img, image, height * width * sizeof *image);",
          "4961:   for (j = oj; j < height - margin; j += 2)",
          "4962:     for (i = oi; i < width - margin; i += 2)",
          "4963:     {",
          "4964:       o1_1 = img[(j - 1) * width + i - 1][1];",
          "4965:       o1_2 = img[(j - 1) * width + i + 1][1];",
          "4966:       o1_3 = img[(j + 1) * width + i - 1][1];",
          "4967:       o1_4 = img[(j + 1) * width + i + 1][1];",
          "4968:       o2_1 = img[(j - 2) * width + i][3];",
          "4969:       o2_2 = img[(j + 2) * width + i][3];",
          "4970:       o2_3 = img[j * width + i - 2][3];",
          "4971:       o2_4 = img[j * width + i + 2][3];",
          "4973:       m1 = (o1_1 + o1_2 + o1_3 + o1_4) / 4.0;",
          "4974:       m2 = (o2_1 + o2_2 + o2_3 + o2_4) / 4.0;",
          "4976:       c1 = (abs(o1_1 - o1_2) + abs(o1_1 - o1_3) + abs(o1_1 - o1_4) + abs(o1_2 - o1_3) + abs(o1_3 - o1_4) +",
          "4977:             abs(o1_2 - o1_4)) /",
          "4978:            6.0;",
          "4979:       c2 = (abs(o2_1 - o2_2) + abs(o2_1 - o2_3) + abs(o2_1 - o2_4) + abs(o2_2 - o2_3) + abs(o2_3 - o2_4) +",
          "4980:             abs(o2_2 - o2_4)) /",
          "4981:            6.0;",
          "4982:       if ((img[j * width + i][3] < maximum * 0.95) && (c1 < maximum * thr) && (c2 < maximum * thr))",
          "4984:         f = image[j * width + i][3] * m1 / m2;",
          "4985:         image[j * width + i][3] = f > 0xffff ? 0xffff : f;",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "4418:   int val, dark, sat;",
          "4419:   double dsum[8], dmin, dmax;",
          "4420:   float scale_mul[4], fr, fc;",
          "4423: #ifdef LIBRAW_LIBRARY_BUILD",
          "4425: #endif",
          "4427:   if (user_mul[0])",
          "4469:       }",
          "4470:     else",
          "4471: #endif",
          "4474:     else if (cam_mul[0] && cam_mul[2])",
          "4476:     else",
          "4478: #ifdef LIBRAW_LIBRARY_BUILD",
          "4480: #endif",
          "4481: #ifdef DCRAW_VERBOSE",
          "4483: #endif",
          "4485:   }",
          "4486: #ifdef LIBRAW_LIBRARY_BUILD",
          "4494:   }",
          "4495: #endif",
          "4498:   dark = black;",
          "4499:   sat = maximum;",
          "4501:   maximum -= black;",
          "4503:     if (dmin > pre_mul[c])",
          "4505:     if (dmax < pre_mul[c])",
          "4507:   }",
          "4509:   FORC4 scale_mul[c] = (pre_mul[c] /= dmax) * 65535.0 / maximum;",
          "4510: #ifdef DCRAW_VERBOSE",
          "4516:   }",
          "4517: #endif",
          "4521:     cblack[4] = cblack[5] = 0;",
          "4522:   }",
          "4524: #ifdef LIBRAW_LIBRARY_BUILD",
          "4525:   scale_colors_loop(scale_mul);",
          "4526: #else",
          "4529:     if (cblack[4] && cblack[5])",
          "4532:     val -= cblack[i & 3];",
          "4533:     val *= scale_mul[i & 3];",
          "4534:     ((ushort *)image)[i] = CLIP(val);",
          "4535:   }",
          "4536: #endif",
          "4538: #ifdef DCRAW_VERBOSE",
          "4539:     if (verbose)",
          "4561:       }",
          "4562:       free(img);",
          "4563:     }",
          "4564:   }",
          "4565: #ifdef LIBRAW_LIBRARY_BUILD",
          "4567: #endif",
          "4568: }",
          "4570: void CLASS pre_interpolate()",
          "4571: {",
          "4573:   int row, col, c;",
          "4574: #ifdef LIBRAW_LIBRARY_BUILD",
          "4576: #endif",
          "4579:       height = iheight;",
          "4602:       image = img;",
          "4603:       shrink = 0;",
          "4604:     }",
          "4605:   }",
          "4607:     mix_green = four_color_rgb ^ half_size;",
          "4613:       filters &= ~((filters & 0x55555555) << 1);",
          "4614:     }",
          "4615:   }",
          "4617: #ifdef LIBRAW_LIBRARY_BUILD",
          "4619: #endif",
          "4620: }",
          "4623: {",
          "4624:   unsigned row, col, y, x, f, c, sum[8];",
          "4641:     }",
          "4642: }",
          "4645: {",
          "4646:   int row;",
          "4648:     {",
          "4662:     }",
          "4663: }",
          "4665: void CLASS lin_interpolate()",
          "4666: {",
          "4668:   int f, c, x, y, row, col, shift, color;",
          "4671: #ifdef DCRAW_VERBOSE",
          "4673: #endif",
          "4674: #ifdef LIBRAW_LIBRARY_BUILD",
          "4676: #endif",
          "4679:   border_interpolate(1);",
          "4695:       code[row][col][0] = (ip - code[row][col]) / 3;",
          "4696:       FORCC",
          "4701:     }",
          "4702: #ifdef LIBRAW_LIBRARY_BUILD",
          "4704: #endif",
          "4706: #ifdef LIBRAW_LIBRARY_BUILD",
          "4708: #endif",
          "4709: }",
          "",
          "[Removed Lines]",
          "4421:   ushort *img=0, *pix;",
          "4424:   RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS,0,2);",
          "4428:     memcpy (pre_mul, user_mul, sizeof pre_mul);",
          "4429:   if (use_auto_wb || (use_camera_wb && cam_mul[0] == -1)) {",
          "4430:     memset (dsum, 0, sizeof dsum);",
          "4431:     bottom = MIN (greybox[1]+greybox[3], height);",
          "4432:     right  = MIN (greybox[0]+greybox[2], width);",
          "4433:     for (row=greybox[1]; row < bottom; row += 8)",
          "4434:       for (col=greybox[0]; col < right; col += 8) {",
          "4435:  memset (sum, 0, sizeof sum);",
          "4436:  for (y=row; y < row+8 && y < bottom; y++)",
          "4437:    for (x=col; x < col+8 && x < right; x++)",
          "4438:      FORC4 {",
          "4439:        if (filters) {",
          "4440:   c = fcol(y,x);",
          "4441:   val = BAYER2(y,x);",
          "4442:        } else",
          "4443:   val = image[y*width+x][c];",
          "4444:        if (val > maximum-25) goto skip_block;",
          "4445:        if ((val -= cblack[c]) < 0) val = 0;",
          "4446:        sum[c] += val;",
          "4447:        sum[c+4]++;",
          "4448:        if (filters) break;",
          "4449:      }",
          "4450:  FORC(8) dsum[c] += sum[c];",
          "4451: skip_block: ;",
          "4452:       }",
          "4453:     FORC4 if (dsum[c]) pre_mul[c] = dsum[c+4] / dsum[c];",
          "4454:   }",
          "4455:   if (use_camera_wb && cam_mul[0] != -1) {",
          "4456:     memset (sum, 0, sizeof sum);",
          "4457:     for (row=0; row < 8; row++)",
          "4458:       for (col=0; col < 8; col++) {",
          "4459:  c = FC(row,col);",
          "4460:  if ((val = white[row][col] - cblack[c]) > 0)",
          "4461:    sum[c] += val;",
          "4462:  sum[c+4]++;",
          "4463:       }",
          "4464: #ifdef LIBRAW_LIBRARY_BUILD",
          "4465:     if(load_raw == &LibRaw::nikon_load_sraw)",
          "4466:       {",
          "4468:         pre_mul[0]=pre_mul[1]=pre_mul[2]=pre_mul[3]=1.0;",
          "4472:     if (sum[0] && sum[1] && sum[2] && sum[3])",
          "4473:       FORC4 pre_mul[c] = (float) sum[c+4] / sum[c];",
          "4475:       memcpy (pre_mul, cam_mul, sizeof pre_mul);",
          "4477:       {",
          "4479:             imgdata.process_warnings |= LIBRAW_WARN_BAD_CAMERA_WB;",
          "4482:             fprintf (stderr,_(\"%s: Cannot use camera white balance.\\n\"), ifname);",
          "4484:       }",
          "4488:   if (load_raw == &LibRaw::nikon_load_sraw",
          "4489:       && !use_camera_wb && !use_auto_wb",
          "4490:       && cam_mul[0] > 0.001f && cam_mul[1] > 0.001f && cam_mul[2] > 0.001f )",
          "4491:     {",
          "4492:       for(c=0;c<3;c++)",
          "4493:         pre_mul[c]/=cam_mul[c];",
          "4496:   if (pre_mul[1] == 0) pre_mul[1] = 1;",
          "4497:   if (pre_mul[3] == 0) pre_mul[3] = colors < 4 ? pre_mul[1] : 1;",
          "4500:   if (threshold) wavelet_denoise();",
          "4502:   for (dmin=DBL_MAX, dmax=c=0; c < 4; c++) {",
          "4504:  dmin = pre_mul[c];",
          "4506:  dmax = pre_mul[c];",
          "4508:   if (!highlight) dmax = dmin;",
          "4511:   if (verbose) {",
          "4512:     fprintf (stderr,",
          "4513:       _(\"Scaling with darkness %d, saturation %d, and\\nmultipliers\"), dark, sat);",
          "4514:     FORC4 fprintf (stderr, \" %f\", pre_mul[c]);",
          "4515:     fputc ('\\n', stderr);",
          "4518:   if (filters > 1000 && (cblack[4]+1)/2 == 1 && (cblack[5]+1)/2 == 1) {",
          "4519:     FORC4 cblack[FC(c/2,c%2)] +=",
          "4520:  cblack[6 + c/2 % cblack[4] * cblack[5] + c%2 % cblack[5]];",
          "4523:   size = iheight*iwidth;",
          "4527:   for (i=0; i < size*4; i++) {",
          "4528:     if (!(val = ((ushort *)image)[i])) continue;",
          "4530:       val -= cblack[6 + i/4 / iwidth % cblack[4] * cblack[5] +",
          "4531:    i/4 % iwidth % cblack[5]];",
          "4537:   if ((aber[0] != 1 || aber[2] != 1) && colors == 3) {",
          "4540:       fprintf (stderr,_(\"Correcting chromatic aberration...\\n\"));",
          "4541: #endif",
          "4542:     for (c=0; c < 4; c+=2) {",
          "4543:       if (aber[c] == 1) continue;",
          "4544:       img = (ushort *) malloc (size * sizeof *img);",
          "4545:       merror (img, \"scale_colors()\");",
          "4546:       for (i=0; i < size; i++)",
          "4547:  img[i] = image[i][c];",
          "4548:       for (row=0; row < iheight; row++) {",
          "4549:  ur = fr = (row - iheight*0.5) * aber[c] + iheight*0.5;",
          "4550:  if (ur > iheight-2) continue;",
          "4551:  fr -= ur;",
          "4552:  for (col=0; col < iwidth; col++) {",
          "4553:    uc = fc = (col - iwidth*0.5) * aber[c] + iwidth*0.5;",
          "4554:    if (uc > iwidth-2) continue;",
          "4555:    fc -= uc;",
          "4556:    pix = img + ur*iwidth + uc;",
          "4557:    image[row*iwidth+col][c] =",
          "4558:      (pix[     0]*(1-fc) + pix[       1]*fc) * (1-fr) +",
          "4559:      (pix[iwidth]*(1-fc) + pix[iwidth+1]*fc) * fr;",
          "4560:  }",
          "4566:   RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS,1,2);",
          "4572:   ushort (*img)[4];",
          "4575:   RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE,0,2);",
          "4577:   if (shrink) {",
          "4578:     if (half_size) {",
          "4580:       width  = iwidth;",
          "4581:       if (filters == 9) {",
          "4582:  for (row=0; row < 3; row++)",
          "4583:    for (col=1; col < 4; col++)",
          "4584:      if (!(image[row*width+col][0] | image[row*width+col][2]))",
          "4585:        goto break2;  break2:",
          "4586:  for ( ; row < height; row+=3)",
          "4587:    for (col=(col-1)%3+1; col < width-1; col+=3) {",
          "4588:      img = image + row*width+col;",
          "4589:      for (c=0; c < 3; c+=2)",
          "4590:        img[0][c] = (img[-1][c] + img[1][c]) >> 1;",
          "4591:    }",
          "4592:       }",
          "4593:     } else {",
          "4594:       img = (ushort (*)[4]) calloc (height, width*sizeof *img);",
          "4595:       merror (img, \"pre_interpolate()\");",
          "4596:       for (row=0; row < height; row++)",
          "4597:  for (col=0; col < width; col++) {",
          "4598:    c = fcol(row,col);",
          "4599:    img[row*width+col][c] = image[(row >> 1)*iwidth+(col >> 1)][c];",
          "4600:  }",
          "4601:       free (image);",
          "4606:   if (filters > 1000 && colors == 3) {",
          "4608:     if (four_color_rgb | half_size) colors++;",
          "4609:     else {",
          "4610:       for (row = FC(1,0) >> 1; row < height; row+=2)",
          "4611:  for (col = FC(row,1) & 1; col < width; col+=2)",
          "4612:    image[row*width+col][1] = image[row*width+col][3];",
          "4616:   if (half_size) filters = 0;",
          "4618:   RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE,1,2);",
          "4622: void CLASS border_interpolate (int border)",
          "4626:   for (row=0; row < height; row++)",
          "4627:     for (col=0; col < width; col++) {",
          "4628:       if (col==border && row >= border && row < height-border)",
          "4629:  col = width-border;",
          "4630:       memset (sum, 0, sizeof sum);",
          "4631:       for (y=row-1; y != row+2; y++)",
          "4632:  for (x=col-1; x != col+2; x++)",
          "4633:    if (y < height && x < width) {",
          "4634:      f = fcol(y,x);",
          "4635:      sum[f] += image[y*width+x][f];",
          "4636:      sum[f+4]++;",
          "4637:    }",
          "4638:       f = fcol(row,col);",
          "4639:       FORCC if (c != f && sum[c+4])",
          "4640:  image[row*width+col][c] = sum[c] / sum[c+4];",
          "4644: void CLASS lin_interpolate_loop(int code[16][16][32],int size)",
          "4647:   for (row=1; row < height-1; row++)",
          "4649:       int col,*ip;",
          "4650:       ushort *pix;",
          "4651:       for (col=1; col < width-1; col++) {",
          "4652:         int i;",
          "4653:         int sum[4];",
          "4654:         pix = image[row*width+col];",
          "4655:         ip = code[row % size][col % size];",
          "4656:         memset (sum, 0, sizeof sum);",
          "4657:         for (i=*ip++; i--; ip+=3)",
          "4658:           sum[ip[2]] += pix[ip[0]] << ip[1];",
          "4659:         for (i=colors; --i; ip+=2)",
          "4660:           pix[ip[0]] = sum[ip[0]] * ip[1] >> 8;",
          "4661:       }",
          "4667:   int code[16][16][32], size=16, *ip, sum[4];",
          "4672:   if (verbose) fprintf (stderr,_(\"Bilinear interpolation...\\n\"));",
          "4675:   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,0,3);",
          "4678:   if (filters == 9) size = 6;",
          "4680:   for (row=0; row < size; row++)",
          "4681:     for (col=0; col < size; col++) {",
          "4682:       ip = code[row][col]+1;",
          "4683:       f = fcol(row,col);",
          "4684:       memset (sum, 0, sizeof sum);",
          "4685:       for (y=-1; y <= 1; y++)",
          "4686:  for (x=-1; x <= 1; x++) {",
          "4687:    shift = (y==0) + (x==0);",
          "4688:    color = fcol(row+y,col+x);",
          "4689:    if (color == f) continue;",
          "4693:    sum[color] += 1 << shift;",
          "4694:  }",
          "4697:  if (c != f) {",
          "4700:  }",
          "4703:   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,1,3);",
          "4705:   lin_interpolate_loop(code,size);",
          "4707:   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,2,3);",
          "",
          "[Added Lines]",
          "4997:   ushort *img = 0, *pix;",
          "5000:   RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS, 0, 2);",
          "5004:     memcpy(pre_mul, user_mul, sizeof pre_mul);",
          "5005:   if (use_auto_wb || (use_camera_wb && cam_mul[0] == -1))",
          "5006:   {",
          "5007:     memset(dsum, 0, sizeof dsum);",
          "5008:     bottom = MIN(greybox[1] + greybox[3], height);",
          "5009:     right = MIN(greybox[0] + greybox[2], width);",
          "5010:     for (row = greybox[1]; row < bottom; row += 8)",
          "5011:       for (col = greybox[0]; col < right; col += 8)",
          "5012:       {",
          "5013:         memset(sum, 0, sizeof sum);",
          "5014:         for (y = row; y < row + 8 && y < bottom; y++)",
          "5015:           for (x = col; x < col + 8 && x < right; x++)",
          "5016:             FORC4",
          "5017:             {",
          "5018:               if (filters)",
          "5019:               {",
          "5020:                 c = fcol(y, x);",
          "5021:                 val = BAYER2(y, x);",
          "5022:               }",
          "5023:               else",
          "5024:                 val = image[y * width + x][c];",
          "5025:               if (val > maximum - 25)",
          "5026:                 goto skip_block;",
          "5027:               if ((val -= cblack[c]) < 0)",
          "5028:                 val = 0;",
          "5029:               sum[c] += val;",
          "5030:               sum[c + 4]++;",
          "5031:               if (filters)",
          "5032:                 break;",
          "5033:             }",
          "5034:         FORC(8) dsum[c] += sum[c];",
          "5035:       skip_block:;",
          "5036:       }",
          "5037:     FORC4 if (dsum[c]) pre_mul[c] = dsum[c + 4] / dsum[c];",
          "5038:   }",
          "5039:   if (use_camera_wb && cam_mul[0] != -1)",
          "5040:   {",
          "5041:     memset(sum, 0, sizeof sum);",
          "5042:     for (row = 0; row < 8; row++)",
          "5043:       for (col = 0; col < 8; col++)",
          "5044:       {",
          "5045:         c = FC(row, col);",
          "5046:         if ((val = white[row][col] - cblack[c]) > 0)",
          "5047:           sum[c] += val;",
          "5048:         sum[c + 4]++;",
          "5050: #ifdef LIBRAW_LIBRARY_BUILD",
          "5051:     if (load_raw == &LibRaw::nikon_load_sraw)",
          "5052:     {",
          "5054:       pre_mul[0] = pre_mul[1] = pre_mul[2] = pre_mul[3] = 1.0;",
          "5055:     }",
          "5058:         if (sum[0] && sum[1] && sum[2] && sum[3])",
          "5059:       FORC4 pre_mul[c] = (float)sum[c + 4] / sum[c];",
          "5061:       memcpy(pre_mul, cam_mul, sizeof pre_mul);",
          "5063:     {",
          "5065:       imgdata.process_warnings |= LIBRAW_WARN_BAD_CAMERA_WB;",
          "5068:       fprintf(stderr, _(\"%s: Cannot use camera white balance.\\n\"), ifname);",
          "5070:     }",
          "5074:   if (load_raw == &LibRaw::nikon_load_sraw && !use_camera_wb && !use_auto_wb && cam_mul[0] > 0.001f &&",
          "5075:       cam_mul[1] > 0.001f && cam_mul[2] > 0.001f)",
          "5076:   {",
          "5077:     for (c = 0; c < 3; c++)",
          "5078:       pre_mul[c] /= cam_mul[c];",
          "5081:   if (pre_mul[1] == 0)",
          "5082:     pre_mul[1] = 1;",
          "5083:   if (pre_mul[3] == 0)",
          "5084:     pre_mul[3] = colors < 4 ? pre_mul[1] : 1;",
          "5087:   if (threshold)",
          "5088:     wavelet_denoise();",
          "5090:   for (dmin = DBL_MAX, dmax = c = 0; c < 4; c++)",
          "5091:   {",
          "5093:       dmin = pre_mul[c];",
          "5095:       dmax = pre_mul[c];",
          "5097:   if (!highlight)",
          "5098:     dmax = dmin;",
          "5101:   if (verbose)",
          "5102:   {",
          "5103:     fprintf(stderr, _(\"Scaling with darkness %d, saturation %d, and\\nmultipliers\"), dark, sat);",
          "5104:     FORC4 fprintf(stderr, \" %f\", pre_mul[c]);",
          "5105:     fputc('\\n', stderr);",
          "5108:   if (filters > 1000 && (cblack[4] + 1) / 2 == 1 && (cblack[5] + 1) / 2 == 1)",
          "5109:   {",
          "5110:     FORC4 cblack[FC(c / 2, c % 2)] += cblack[6 + c / 2 % cblack[4] * cblack[5] + c % 2 % cblack[5]];",
          "5113:   size = iheight * iwidth;",
          "5117:   for (i = 0; i < size * 4; i++)",
          "5118:   {",
          "5119:     if (!(val = ((ushort *)image)[i]))",
          "5120:       continue;",
          "5122:       val -= cblack[6 + i / 4 / iwidth % cblack[4] * cblack[5] + i / 4 % iwidth % cblack[5]];",
          "5128:   if ((aber[0] != 1 || aber[2] != 1) && colors == 3)",
          "5129:   {",
          "5132:       fprintf(stderr, _(\"Correcting chromatic aberration...\\n\"));",
          "5133: #endif",
          "5134:     for (c = 0; c < 4; c += 2)",
          "5135:     {",
          "5136:       if (aber[c] == 1)",
          "5137:         continue;",
          "5138:       img = (ushort *)malloc(size * sizeof *img);",
          "5139:       merror(img, \"scale_colors()\");",
          "5140:       for (i = 0; i < size; i++)",
          "5141:         img[i] = image[i][c];",
          "5142:       for (row = 0; row < iheight; row++)",
          "5143:       {",
          "5144:         ur = fr = (row - iheight * 0.5) * aber[c] + iheight * 0.5;",
          "5145:         if (ur > iheight - 2)",
          "5146:           continue;",
          "5147:         fr -= ur;",
          "5148:         for (col = 0; col < iwidth; col++)",
          "5149:         {",
          "5150:           uc = fc = (col - iwidth * 0.5) * aber[c] + iwidth * 0.5;",
          "5151:           if (uc > iwidth - 2)",
          "5152:             continue;",
          "5153:           fc -= uc;",
          "5154:           pix = img + ur * iwidth + uc;",
          "5155:           image[row * iwidth + col][c] =",
          "5156:               (pix[0] * (1 - fc) + pix[1] * fc) * (1 - fr) + (pix[iwidth] * (1 - fc) + pix[iwidth + 1] * fc) * fr;",
          "5157:         }",
          "5163:   RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS, 1, 2);",
          "5169:   ushort(*img)[4];",
          "5172:   RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE, 0, 2);",
          "5174:   if (shrink)",
          "5175:   {",
          "5176:     if (half_size)",
          "5177:     {",
          "5179:       width = iwidth;",
          "5180:       if (filters == 9)",
          "5181:       {",
          "5182:         for (row = 0; row < 3; row++)",
          "5183:           for (col = 1; col < 4; col++)",
          "5184:             if (!(image[row * width + col][0] | image[row * width + col][2]))",
          "5185:               goto break2;",
          "5186:       break2:",
          "5187:         for (; row < height; row += 3)",
          "5188:           for (col = (col - 1) % 3 + 1; col < width - 1; col += 3)",
          "5189:           {",
          "5190:             img = image + row * width + col;",
          "5191:             for (c = 0; c < 3; c += 2)",
          "5192:               img[0][c] = (img[-1][c] + img[1][c]) >> 1;",
          "5193:           }",
          "5194:       }",
          "5195:     }",
          "5196:     else",
          "5197:     {",
          "5198:       img = (ushort(*)[4])calloc(height, width * sizeof *img);",
          "5199:       merror(img, \"pre_interpolate()\");",
          "5200:       for (row = 0; row < height; row++)",
          "5201:         for (col = 0; col < width; col++)",
          "5202:         {",
          "5203:           c = fcol(row, col);",
          "5204:           img[row * width + col][c] = image[(row >> 1) * iwidth + (col >> 1)][c];",
          "5205:         }",
          "5206:       free(image);",
          "5211:   if (filters > 1000 && colors == 3)",
          "5212:   {",
          "5214:     if (four_color_rgb | half_size)",
          "5215:       colors++;",
          "5216:     else",
          "5217:     {",
          "5218:       for (row = FC(1, 0) >> 1; row < height; row += 2)",
          "5219:         for (col = FC(row, 1) & 1; col < width; col += 2)",
          "5220:           image[row * width + col][1] = image[row * width + col][3];",
          "5224:   if (half_size)",
          "5225:     filters = 0;",
          "5227:   RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE, 1, 2);",
          "5231: void CLASS border_interpolate(int border)",
          "5235:   for (row = 0; row < height; row++)",
          "5236:     for (col = 0; col < width; col++)",
          "5237:     {",
          "5238:       if (col == border && row >= border && row < height - border)",
          "5239:         col = width - border;",
          "5240:       memset(sum, 0, sizeof sum);",
          "5241:       for (y = row - 1; y != row + 2; y++)",
          "5242:         for (x = col - 1; x != col + 2; x++)",
          "5243:           if (y < height && x < width)",
          "5244:           {",
          "5245:             f = fcol(y, x);",
          "5246:             sum[f] += image[y * width + x][f];",
          "5247:             sum[f + 4]++;",
          "5248:           }",
          "5249:       f = fcol(row, col);",
          "5250:       FORCC if (c != f && sum[c + 4]) image[row * width + col][c] = sum[c] / sum[c + 4];",
          "5254: void CLASS lin_interpolate_loop(int code[16][16][32], int size)",
          "5257:   for (row = 1; row < height - 1; row++)",
          "5258:   {",
          "5259:     int col, *ip;",
          "5260:     ushort *pix;",
          "5261:     for (col = 1; col < width - 1; col++)",
          "5263:       int i;",
          "5264:       int sum[4];",
          "5265:       pix = image[row * width + col];",
          "5266:       ip = code[row % size][col % size];",
          "5267:       memset(sum, 0, sizeof sum);",
          "5268:       for (i = *ip++; i--; ip += 3)",
          "5269:         sum[ip[2]] += pix[ip[0]] << ip[1];",
          "5270:       for (i = colors; --i; ip += 2)",
          "5271:         pix[ip[0]] = sum[ip[0]] * ip[1] >> 8;",
          "5273:   }",
          "5278:   int code[16][16][32], size = 16, *ip, sum[4];",
          "5282:   if (verbose)",
          "5283:     fprintf(stderr, _(\"Bilinear interpolation...\\n\"));",
          "5286:   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 0, 3);",
          "5289:   if (filters == 9)",
          "5290:     size = 6;",
          "5292:   for (row = 0; row < size; row++)",
          "5293:     for (col = 0; col < size; col++)",
          "5294:     {",
          "5295:       ip = code[row][col] + 1;",
          "5296:       f = fcol(row, col);",
          "5297:       memset(sum, 0, sizeof sum);",
          "5298:       for (y = -1; y <= 1; y++)",
          "5299:         for (x = -1; x <= 1; x++)",
          "5300:         {",
          "5301:           shift = (y == 0) + (x == 0);",
          "5302:           color = fcol(row + y, col + x);",
          "5303:           if (color == f)",
          "5304:             continue;",
          "5308:           sum[color] += 1 << shift;",
          "5309:         }",
          "5312:       if (c != f)",
          "5313:       {",
          "5316:       }",
          "5319:   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 1, 3);",
          "5321:   lin_interpolate_loop(code, size);",
          "5323:   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 2, 3);",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "4721: void CLASS vng_interpolate()",
          "4722: {",
          "4749:   int row, col, x, y, x1, x2, y1, y2, t, weight, grads, color, diag;",
          "4750:   int g, diff, thold, num, c;",
          "4752:   lin_interpolate();",
          "4753: #ifdef DCRAW_VERBOSE",
          "4755: #endif",
          "4763:       code[row][col] = ip;",
          "4779:       }",
          "4801:       ip = code[row % prow][col % pcol];",
          "4811:       }",
          "4812:       ip++;",
          "4817:       }",
          "4821:       }",
          "4822:       thold = gmin + (gmax >> 1);",
          "4851: }",
          "",
          "[Removed Lines]",
          "4723:   static const signed char *cp, terms[] = {",
          "4724:     -2,-2,+0,-1,0,0x01, -2,-2,+0,+0,1,0x01, -2,-1,-1,+0,0,0x01,",
          "4725:     -2,-1,+0,-1,0,0x02, -2,-1,+0,+0,0,0x03, -2,-1,+0,+1,1,0x01,",
          "4726:     -2,+0,+0,-1,0,0x06, -2,+0,+0,+0,1,0x02, -2,+0,+0,+1,0,0x03,",
          "4727:     -2,+1,-1,+0,0,0x04, -2,+1,+0,-1,1,0x04, -2,+1,+0,+0,0,0x06,",
          "4728:     -2,+1,+0,+1,0,0x02, -2,+2,+0,+0,1,0x04, -2,+2,+0,+1,0,0x04,",
          "4729:     -1,-2,-1,+0,0,-128, -1,-2,+0,-1,0,0x01, -1,-2,+1,-1,0,0x01,",
          "4730:     -1,-2,+1,+0,1,0x01, -1,-1,-1,+1,0,-120, -1,-1,+1,-2,0,0x40,",
          "4731:     -1,-1,+1,-1,0,0x22, -1,-1,+1,+0,0,0x33, -1,-1,+1,+1,1,0x11,",
          "4732:     -1,+0,-1,+2,0,0x08, -1,+0,+0,-1,0,0x44, -1,+0,+0,+1,0,0x11,",
          "4733:     -1,+0,+1,-2,1,0x40, -1,+0,+1,-1,0,0x66, -1,+0,+1,+0,1,0x22,",
          "4734:     -1,+0,+1,+1,0,0x33, -1,+0,+1,+2,1,0x10, -1,+1,+1,-1,1,0x44,",
          "4735:     -1,+1,+1,+0,0,0x66, -1,+1,+1,+1,0,0x22, -1,+1,+1,+2,0,0x10,",
          "4736:     -1,+2,+0,+1,0,0x04, -1,+2,+1,+0,1,0x04, -1,+2,+1,+1,0,0x04,",
          "4737:     +0,-2,+0,+0,1,-128, +0,-1,+0,+1,1,-120, +0,-1,+1,-2,0,0x40,",
          "4738:     +0,-1,+1,+0,0,0x11, +0,-1,+2,-2,0,0x40, +0,-1,+2,-1,0,0x20,",
          "4739:     +0,-1,+2,+0,0,0x30, +0,-1,+2,+1,1,0x10, +0,+0,+0,+2,1,0x08,",
          "4740:     +0,+0,+2,-2,1,0x40, +0,+0,+2,-1,0,0x60, +0,+0,+2,+0,1,0x20,",
          "4741:     +0,+0,+2,+1,0,0x30, +0,+0,+2,+2,1,0x10, +0,+1,+1,+0,0,0x44,",
          "4742:     +0,+1,+1,+2,0,0x10, +0,+1,+2,-1,1,0x40, +0,+1,+2,+0,0,0x60,",
          "4743:     +0,+1,+2,+1,0,0x20, +0,+1,+2,+2,0,0x10, +1,-2,+1,+0,0,-128,",
          "4744:     +1,-1,+1,+1,0,-120, +1,+0,+1,+2,0,0x08, +1,+0,+2,-1,0,0x40,",
          "4745:     +1,+0,+2,+1,0,0x10",
          "4746:   }, chood[] = { -1,-1, -1,0, -1,+1, 0,+1, +1,+1, +1,0, +1,-1, 0,-1 };",
          "4747:   ushort (*brow[5])[4], *pix;",
          "4748:   int prow=8, pcol=2, *ip, *code[16][16], gval[8], gmin, gmax, sum[4];",
          "4754:   if (verbose) fprintf (stderr,_(\"VNG interpolation...\\n\"));",
          "4757:   if (filters == 1) prow = pcol = 16;",
          "4758:   if (filters == 9) prow = pcol =  6;",
          "4759:   ip = (int *) calloc (prow*pcol, 1280);",
          "4760:   merror (ip, \"vng_interpolate()\");",
          "4762:     for (col=0; col < pcol; col++) {",
          "4764:       for (cp=terms, t=0; t < 64; t++) {",
          "4765:  y1 = *cp++;  x1 = *cp++;",
          "4766:  y2 = *cp++;  x2 = *cp++;",
          "4767:  weight = *cp++;",
          "4768:  grads = *cp++;",
          "4769:  color = fcol(row+y1,col+x1);",
          "4770:  if (fcol(row+y2,col+x2) != color) continue;",
          "4771:  diag = (fcol(row,col+1) == color && fcol(row+1,col) == color) ? 2:1;",
          "4772:  if (abs(y1-y2) == diag && abs(x1-x2) == diag) continue;",
          "4776:  for (g=0; g < 8; g++)",
          "4777:    if (grads & 1<<g) *ip++ = g;",
          "4781:       for (cp=chood, g=0; g < 8; g++) {",
          "4782:  y = *cp++;  x = *cp++;",
          "4784:  color = fcol(row,col);",
          "4785:  if (fcol(row+y,col+x) != color && fcol(row+y*2,col+x*2) == color)",
          "4787:  else",
          "4789:       }",
          "4790:     }",
          "4791:   brow[4] = (ushort (*)[4]) calloc (width*3, sizeof **brow);",
          "4792:   merror (brow[4], \"vng_interpolate()\");",
          "4793:   for (row=0; row < 3; row++)",
          "4794:     brow[row] = brow[4] + row*width;",
          "4796: #ifdef LIBRAW_LIBRARY_BUILD",
          "4797:       if(!((row-2)%256))RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,(row-2)/256+1,((height-3)/256)+1);",
          "4798: #endif",
          "4799:     for (col=2; col < width-2; col++) {",
          "4800:       pix = image[row*width+col];",
          "4802:       memset (gval, 0, sizeof gval);",
          "4804:  diff = ABS(pix[g] - pix[ip[1]]) << ip[2];",
          "4805:  gval[ip[3]] += diff;",
          "4806:  ip += 5;",
          "4807:  if ((g = ip[-1]) == -1) continue;",
          "4808:  gval[g] += diff;",
          "4809:  while ((g = *ip++) != -1)",
          "4810:    gval[g] += diff;",
          "4814:       for (g=1; g < 8; g++) {",
          "4815:  if (gmin > gval[g]) gmin = gval[g];",
          "4816:  if (gmax < gval[g]) gmax = gval[g];",
          "4818:       if (gmax == 0) {",
          "4819:  memcpy (brow[2][col], pix, sizeof *image);",
          "4820:  continue;",
          "4823:       memset (sum, 0, sizeof sum);",
          "4824:       color = fcol(row,col);",
          "4826:  if (gval[g] <= thold) {",
          "4827:    FORCC",
          "4828:      if (c == color && ip[1])",
          "4829:        sum[c] += (pix[c] + pix[ip[1]]) >> 1;",
          "4830:      else",
          "4831:        sum[c] += pix[ip[0] + c];",
          "4832:    num++;",
          "4833:  }",
          "4834:       }",
          "4836:  t = pix[color];",
          "4837:  if (c != color)",
          "4838:    t += (sum[c] - sum[color]) / num;",
          "4839:  brow[2][col][c] = CLIP(t);",
          "4840:       }",
          "4841:     }",
          "4843:       memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);",
          "4844:     for (g=0; g < 4; g++)",
          "4845:       brow[(g-1) & 3] = brow[g];",
          "4846:   }",
          "4847:   memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);",
          "4848:   memcpy (image[(row-1)*width+2], brow[1]+2, (width-4)*sizeof *image);",
          "4849:   free (brow[4]);",
          "4850:   free (code[0][0]);",
          "",
          "[Added Lines]",
          "5339:   static const signed char *cp,",
          "5340:       terms[] = {-2, -2, +0, -1, 0, 0x01, -2, -2, +0, +0, 1, 0x01, -2, -1, -1, +0, 0, 0x01, -2, -1, +0, -1, 0, 0x02,",
          "5341:                  -2, -1, +0, +0, 0, 0x03, -2, -1, +0, +1, 1, 0x01, -2, +0, +0, -1, 0, 0x06, -2, +0, +0, +0, 1, 0x02,",
          "5342:                  -2, +0, +0, +1, 0, 0x03, -2, +1, -1, +0, 0, 0x04, -2, +1, +0, -1, 1, 0x04, -2, +1, +0, +0, 0, 0x06,",
          "5343:                  -2, +1, +0, +1, 0, 0x02, -2, +2, +0, +0, 1, 0x04, -2, +2, +0, +1, 0, 0x04, -1, -2, -1, +0, 0, -128,",
          "5344:                  -1, -2, +0, -1, 0, 0x01, -1, -2, +1, -1, 0, 0x01, -1, -2, +1, +0, 1, 0x01, -1, -1, -1, +1, 0, -120,",
          "5345:                  -1, -1, +1, -2, 0, 0x40, -1, -1, +1, -1, 0, 0x22, -1, -1, +1, +0, 0, 0x33, -1, -1, +1, +1, 1, 0x11,",
          "5346:                  -1, +0, -1, +2, 0, 0x08, -1, +0, +0, -1, 0, 0x44, -1, +0, +0, +1, 0, 0x11, -1, +0, +1, -2, 1, 0x40,",
          "5347:                  -1, +0, +1, -1, 0, 0x66, -1, +0, +1, +0, 1, 0x22, -1, +0, +1, +1, 0, 0x33, -1, +0, +1, +2, 1, 0x10,",
          "5348:                  -1, +1, +1, -1, 1, 0x44, -1, +1, +1, +0, 0, 0x66, -1, +1, +1, +1, 0, 0x22, -1, +1, +1, +2, 0, 0x10,",
          "5349:                  -1, +2, +0, +1, 0, 0x04, -1, +2, +1, +0, 1, 0x04, -1, +2, +1, +1, 0, 0x04, +0, -2, +0, +0, 1, -128,",
          "5350:                  +0, -1, +0, +1, 1, -120, +0, -1, +1, -2, 0, 0x40, +0, -1, +1, +0, 0, 0x11, +0, -1, +2, -2, 0, 0x40,",
          "5351:                  +0, -1, +2, -1, 0, 0x20, +0, -1, +2, +0, 0, 0x30, +0, -1, +2, +1, 1, 0x10, +0, +0, +0, +2, 1, 0x08,",
          "5352:                  +0, +0, +2, -2, 1, 0x40, +0, +0, +2, -1, 0, 0x60, +0, +0, +2, +0, 1, 0x20, +0, +0, +2, +1, 0, 0x30,",
          "5353:                  +0, +0, +2, +2, 1, 0x10, +0, +1, +1, +0, 0, 0x44, +0, +1, +1, +2, 0, 0x10, +0, +1, +2, -1, 1, 0x40,",
          "5354:                  +0, +1, +2, +0, 0, 0x60, +0, +1, +2, +1, 0, 0x20, +0, +1, +2, +2, 0, 0x10, +1, -2, +1, +0, 0, -128,",
          "5355:                  +1, -1, +1, +1, 0, -120, +1, +0, +1, +2, 0, 0x08, +1, +0, +2, -1, 0, 0x40, +1, +0, +2, +1, 0, 0x10},",
          "5356:       chood[] = {-1, -1, -1, 0, -1, +1, 0, +1, +1, +1, +1, 0, +1, -1, 0, -1};",
          "5357:   ushort(*brow[5])[4], *pix;",
          "5358:   int prow = 8, pcol = 2, *ip, *code[16][16], gval[8], gmin, gmax, sum[4];",
          "5364:   if (verbose)",
          "5365:     fprintf(stderr, _(\"VNG interpolation...\\n\"));",
          "5368:   if (filters == 1)",
          "5369:     prow = pcol = 16;",
          "5370:   if (filters == 9)",
          "5371:     prow = pcol = 6;",
          "5372:   ip = (int *)calloc(prow * pcol, 1280);",
          "5373:   merror(ip, \"vng_interpolate()\");",
          "5375:     for (col = 0; col < pcol; col++)",
          "5376:     {",
          "5378:       for (cp = terms, t = 0; t < 64; t++)",
          "5379:       {",
          "5380:         y1 = *cp++;",
          "5381:         x1 = *cp++;",
          "5382:         y2 = *cp++;",
          "5383:         x2 = *cp++;",
          "5384:         weight = *cp++;",
          "5385:         grads = *cp++;",
          "5386:         color = fcol(row + y1, col + x1);",
          "5387:         if (fcol(row + y2, col + x2) != color)",
          "5388:           continue;",
          "5389:         diag = (fcol(row, col + 1) == color && fcol(row + 1, col) == color) ? 2 : 1;",
          "5390:         if (abs(y1 - y2) == diag && abs(x1 - x2) == diag)",
          "5391:           continue;",
          "5395:         for (g = 0; g < 8; g++)",
          "5396:           if (grads & 1 << g)",
          "5401:       for (cp = chood, g = 0; g < 8; g++)",
          "5402:       {",
          "5403:         y = *cp++;",
          "5404:         x = *cp++;",
          "5406:         color = fcol(row, col);",
          "5407:         if (fcol(row + y, col + x) != color && fcol(row + y * 2, col + x * 2) == color)",
          "5409:         else",
          "5411:       }",
          "5412:     }",
          "5413:   brow[4] = (ushort(*)[4])calloc(width * 3, sizeof **brow);",
          "5414:   merror(brow[4], \"vng_interpolate()\");",
          "5415:   for (row = 0; row < 3; row++)",
          "5416:     brow[row] = brow[4] + row * width;",
          "5417:   for (row = 2; row < height - 2; row++)",
          "5419: #ifdef LIBRAW_LIBRARY_BUILD",
          "5420:     if (!((row - 2) % 256))",
          "5421:       RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, (row - 2) / 256 + 1, ((height - 3) / 256) + 1);",
          "5422: #endif",
          "5423:     for (col = 2; col < width - 2; col++)",
          "5424:     {",
          "5425:       pix = image[row * width + col];",
          "5427:       memset(gval, 0, sizeof gval);",
          "5428:       while ((g = ip[0]) != INT_MAX)",
          "5430:         diff = ABS(pix[g] - pix[ip[1]]) << ip[2];",
          "5431:         gval[ip[3]] += diff;",
          "5432:         ip += 5;",
          "5433:         if ((g = ip[-1]) == -1)",
          "5434:           continue;",
          "5435:         gval[g] += diff;",
          "5436:         while ((g = *ip++) != -1)",
          "5437:           gval[g] += diff;",
          "5441:       for (g = 1; g < 8; g++)",
          "5442:       {",
          "5443:         if (gmin > gval[g])",
          "5444:           gmin = gval[g];",
          "5445:         if (gmax < gval[g])",
          "5446:           gmax = gval[g];",
          "5448:       if (gmax == 0)",
          "5449:       {",
          "5450:         memcpy(brow[2][col], pix, sizeof *image);",
          "5451:         continue;",
          "5454:       memset(sum, 0, sizeof sum);",
          "5455:       color = fcol(row, col);",
          "5456:       for (num = g = 0; g < 8; g++, ip += 2)",
          "5458:         if (gval[g] <= thold)",
          "5459:         {",
          "5460:           FORCC",
          "5461:           if (c == color && ip[1])",
          "5462:             sum[c] += (pix[c] + pix[ip[1]]) >> 1;",
          "5463:           else",
          "5464:             sum[c] += pix[ip[0] + c];",
          "5465:           num++;",
          "5466:         }",
          "5467:       }",
          "5468:       FORCC",
          "5470:         t = pix[color];",
          "5471:         if (c != color)",
          "5472:           t += (sum[c] - sum[color]) / num;",
          "5473:         brow[2][col][c] = CLIP(t);",
          "5474:       }",
          "5475:     }",
          "5477:       memcpy(image[(row - 2) * width + 2], brow[0] + 2, (width - 4) * sizeof *image);",
          "5478:     for (g = 0; g < 4; g++)",
          "5479:       brow[(g - 1) & 3] = brow[g];",
          "5480:   }",
          "5481:   memcpy(image[(row - 2) * width + 2], brow[0] + 2, (width - 4) * sizeof *image);",
          "5482:   memcpy(image[(row - 1) * width + 2], brow[1] + 2, (width - 4) * sizeof *image);",
          "5483:   free(brow[4]);",
          "5484:   free(code[0][0]);",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "4856: void CLASS ppg_interpolate()",
          "4857: {",
          "4859:   int row, col, diff[2], guess[2], c, d, i;",
          "4862:   border_interpolate(3);",
          "4863: #ifdef DCRAW_VERBOSE",
          "4865: #endif",
          "4868: #ifdef LIBRAW_LIBRARY_BUILD",
          "4870: #ifdef LIBRAW_USE_OPENMP",
          "4871: #pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)",
          "4872: #endif",
          "4873: #endif",
          "4885:       }",
          "4886:       d = dir[i = diff[0] > diff[1]];",
          "4887:       pix[0][1] = ULIM(guess[i] >> 2, pix[d][1], pix[-d][1]);",
          "4888:     }",
          "4890: #ifdef LIBRAW_LIBRARY_BUILD",
          "4892: #ifdef LIBRAW_USE_OPENMP",
          "4893: #pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)",
          "4894: #endif",
          "4895: #endif",
          "4902:     }",
          "4904: #ifdef LIBRAW_LIBRARY_BUILD",
          "4906: #ifdef LIBRAW_USE_OPENMP",
          "4907: #pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)",
          "4908: #endif",
          "4909: #endif",
          "4919:       }",
          "4920:       if (diff[0] != diff[1])",
          "4922:       else",
          "4924:     }",
          "4925: }",
          "4928: {",
          "4929:   int c, i, j, k;",
          "4930:   float r, xyz[3];",
          "",
          "[Removed Lines]",
          "4858:   int dir[5] = { 1, width, -1, -width, 1 };",
          "4860:   ushort (*pix)[4];",
          "4864:   if (verbose) fprintf (stderr,_(\"PPG interpolation...\\n\"));",
          "4869:   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,0,3);",
          "4874:   for (row=3; row < height-3; row++)",
          "4875:     for (col=3+(FC(row,3) & 1), c=FC(row,col); col < width-3; col+=2) {",
          "4876:       pix = image + row*width+col;",
          "4877:       for (i=0; (d=dir[i]) > 0; i++) {",
          "4878:  guess[i] = (pix[-d][1] + pix[0][c] + pix[d][1]) * 2",
          "4879:         - pix[-2*d][c] - pix[2*d][c];",
          "4880:  diff[i] = ( ABS(pix[-2*d][c] - pix[ 0][c]) +",
          "4881:       ABS(pix[ 2*d][c] - pix[ 0][c]) +",
          "4882:       ABS(pix[  -d][1] - pix[ d][1]) ) * 3 +",
          "4883:     ( ABS(pix[ 3*d][1] - pix[ d][1]) +",
          "4884:       ABS(pix[-3*d][1] - pix[-d][1]) ) * 2;",
          "4891:   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,1,3);",
          "4896:   for (row=1; row < height-1; row++)",
          "4897:     for (col=1+(FC(row,2) & 1), c=FC(row,col+1); col < width-1; col+=2) {",
          "4898:       pix = image + row*width+col;",
          "4899:       for (i=0; (d=dir[i]) > 0; c=2-c, i++)",
          "4900:  pix[0][c] = CLIP((pix[-d][c] + pix[d][c] + 2*pix[0][1]",
          "4901:    - pix[-d][1] - pix[d][1]) >> 1);",
          "4905:   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,2,3);",
          "4910:   for (row=1; row < height-1; row++)",
          "4911:     for (col=1+(FC(row,1) & 1), c=2-FC(row,col); col < width-1; col+=2) {",
          "4912:       pix = image + row*width+col;",
          "4913:       for (i=0; (d=dir[i]+dir[i+1]) > 0; i++) {",
          "4914:  diff[i] = ABS(pix[-d][c] - pix[d][c]) +",
          "4915:     ABS(pix[-d][1] - pix[0][1]) +",
          "4916:     ABS(pix[ d][1] - pix[0][1]);",
          "4917:  guess[i] = pix[-d][c] + pix[d][c] + 2*pix[0][1]",
          "4918:    - pix[-d][1] - pix[d][1];",
          "4921:  pix[0][c] = CLIP(guess[diff[0] > diff[1]] >> 1);",
          "4923:  pix[0][c] = CLIP((guess[0]+guess[1]) >> 2);",
          "4927: void CLASS cielab (ushort rgb[3], short lab[3])",
          "",
          "[Added Lines]",
          "5492:   int dir[5] = {1, width, -1, -width, 1};",
          "5494:   ushort(*pix)[4];",
          "5498:   if (verbose)",
          "5499:     fprintf(stderr, _(\"PPG interpolation...\\n\"));",
          "5504:   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 0, 3);",
          "5509:   for (row = 3; row < height - 3; row++)",
          "5510:     for (col = 3 + (FC(row, 3) & 1), c = FC(row, col); col < width - 3; col += 2)",
          "5511:     {",
          "5512:       pix = image + row * width + col;",
          "5513:       for (i = 0; (d = dir[i]) > 0; i++)",
          "5514:       {",
          "5515:         guess[i] = (pix[-d][1] + pix[0][c] + pix[d][1]) * 2 - pix[-2 * d][c] - pix[2 * d][c];",
          "5516:         diff[i] = (ABS(pix[-2 * d][c] - pix[0][c]) + ABS(pix[2 * d][c] - pix[0][c]) + ABS(pix[-d][1] - pix[d][1])) * 3 +",
          "5517:                   (ABS(pix[3 * d][1] - pix[d][1]) + ABS(pix[-3 * d][1] - pix[-d][1])) * 2;",
          "5524:   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 1, 3);",
          "5529:   for (row = 1; row < height - 1; row++)",
          "5530:     for (col = 1 + (FC(row, 2) & 1), c = FC(row, col + 1); col < width - 1; col += 2)",
          "5531:     {",
          "5532:       pix = image + row * width + col;",
          "5533:       for (i = 0; (d = dir[i]) > 0; c = 2 - c, i++)",
          "5534:         pix[0][c] = CLIP((pix[-d][c] + pix[d][c] + 2 * pix[0][1] - pix[-d][1] - pix[d][1]) >> 1);",
          "5538:   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 2, 3);",
          "5543:   for (row = 1; row < height - 1; row++)",
          "5544:     for (col = 1 + (FC(row, 1) & 1), c = 2 - FC(row, col); col < width - 1; col += 2)",
          "5545:     {",
          "5546:       pix = image + row * width + col;",
          "5547:       for (i = 0; (d = dir[i] + dir[i + 1]) > 0; i++)",
          "5548:       {",
          "5549:         diff[i] = ABS(pix[-d][c] - pix[d][c]) + ABS(pix[-d][1] - pix[0][1]) + ABS(pix[d][1] - pix[0][1]);",
          "5550:         guess[i] = pix[-d][c] + pix[d][c] + 2 * pix[0][1] - pix[-d][1] - pix[d][1];",
          "5553:         pix[0][c] = CLIP(guess[diff[0] > diff[1]] >> 1);",
          "5555:         pix[0][c] = CLIP((guess[0] + guess[1]) >> 2);",
          "5559: void CLASS cielab(ushort rgb[3], short lab[3])",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "4935: #define xyz_cam tls->ahd_data.xyz_cam",
          "4936: #endif",
          "4939: #ifndef LIBRAW_NOTHREADS",
          "4941: #endif",
          "4950:     return;",
          "4951:   }",
          "4952:   xyz[0] = xyz[1] = xyz[2] = 0.5;",
          "4954:     xyz[0] += xyz_cam[0][c] * rgb[c];",
          "4955:     xyz[1] += xyz_cam[1][c] * rgb[c];",
          "4956:     xyz[2] += xyz_cam[2][c] * rgb[c];",
          "4957:   }",
          "4961:   lab[0] = 64 * (116 * xyz[1] - 16);",
          "4962:   lab[1] = 64 * 500 * (xyz[0] - xyz[1]);",
          "4963:   lab[2] = 64 * 200 * (xyz[1] - xyz[2]);",
          "",
          "[Removed Lines]",
          "4938:   if (!rgb) {",
          "4940:     if(cbrt[0] < -1.0f)",
          "4942:     for (i=0; i < 0x10000; i++) {",
          "4943:       r = i / 65535.0;",
          "4944:       cbrt[i] = r > 0.008856 ? pow(r,1.f/3.0f) : 7.787f*r + 16.f/116.0f;",
          "4945:     }",
          "4946:     for (i=0; i < 3; i++)",
          "4947:       for (j=0; j < colors; j++)",
          "4948:  for (xyz_cam[i][j] = k=0; k < 3; k++)",
          "4949:    xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];",
          "4953:   FORCC {",
          "4958:   xyz[0] = cbrt[CLIP((int) xyz[0])];",
          "4959:   xyz[1] = cbrt[CLIP((int) xyz[1])];",
          "4960:   xyz[2] = cbrt[CLIP((int) xyz[2])];",
          "",
          "[Added Lines]",
          "5570:   if (!rgb)",
          "5571:   {",
          "5573:     if (cbrt[0] < -1.0f)",
          "5575:       for (i = 0; i < 0x10000; i++)",
          "5576:       {",
          "5577:         r = i / 65535.0;",
          "5578:         cbrt[i] = r > 0.008856 ? pow(r, 1.f / 3.0f) : 7.787f * r + 16.f / 116.0f;",
          "5579:       }",
          "5580:     for (i = 0; i < 3; i++)",
          "5581:       for (j = 0; j < colors; j++)",
          "5582:         for (xyz_cam[i][j] = k = 0; k < 3; k++)",
          "5583:           xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];",
          "5587:   FORCC",
          "5588:   {",
          "5593:   xyz[0] = cbrt[CLIP((int)xyz[0])];",
          "5594:   xyz[1] = cbrt[CLIP((int)xyz[1])];",
          "5595:   xyz[2] = cbrt[CLIP((int)xyz[2])];",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "4967: #endif",
          "4968: }",
          "4974:    Frank Markesteijn's algorithm for Fuji X-Trans sensors",
          "4977: {",
          "4978:   int c, d, f, g, h, i, v, ng, row, col, top, left, mrow, mcol;",
          "4979:   int val, ndir, pass, hm[8], avg[4], color[3][8];",
          "4984:   short allhex[3][3][2][8], *hex;",
          "4985:   ushort min, max, sgrow, sgcol;",
          "4991: #ifdef DCRAW_VERBOSE",
          "4992:   if (verbose)",
          "4994: #endif",
          "4997:   ndir = 4 << (passes > 1);",
          "5030:       }",
          "5031:       pix[0][1] = min;",
          "5032:       pix[0][3] = max;",
          "5199:     }",
          "5229:     }",
          "5230:   }",
          "5231: }",
          "5233: {",
          "5234:   unsigned row, col;",
          "5235:   int c, val;",
          "5239:   float xyz[3];",
          "5243:   ushort *pix_above;",
          "5244:   ushort *pix_below;",
          "5245:   int t1, t2;",
          "5253:       pix++;",
          "5254:       pix_above = &pix[0][0] - num_pix_per_row;",
          "5255:       pix_below = &pix[0][0] + num_pix_per_row;",
          "",
          "[Removed Lines]",
          "4971: #define fcol(row,col) xtrans[(row+6) % 6][(col+6) % 6]",
          "4976: void CLASS xtrans_interpolate (int passes)",
          "4980:   static const short orth[12] = { 1,0,0,1,-1,0,0,-1,1,0,0,1 },",
          "4981:  patt[2][16] = { { 0,1,0,-1,2,0,-1,0,1,1,1,-1,0,0,0,0 },",
          "4982:    { 0,1,0,-2,1,0,-2,0,1,1,-2,-2,1,-1,-1,1 } },",
          "4983:  dir[4] = { 1,TS,TS+1,TS-1 };",
          "4986:   ushort (*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];",
          "4987:    short (*lab)    [TS][3], (*lix)[3];",
          "4988:    float (*drv)[TS][TS], diff[6], tr;",
          "4989:    char (*homo)[TS][TS], *buffer;",
          "4993:     fprintf (stderr,_(\"%d-pass X-Trans interpolation...\\n\"), passes);",
          "4996:   cielab (0,0);",
          "4998:   buffer = (char *) malloc (TS*TS*(ndir*11+6));",
          "4999:   merror (buffer, \"xtrans_interpolate()\");",
          "5000:   rgb  = (ushort(*)[TS][TS][3]) buffer;",
          "5001:   lab  = (short (*)    [TS][3])(buffer + TS*TS*(ndir*6));",
          "5002:   drv  = (float (*)[TS][TS])   (buffer + TS*TS*(ndir*6+6));",
          "5003:   homo = (char  (*)[TS][TS])   (buffer + TS*TS*(ndir*10+6));",
          "5006:   for (row=0; row < 3; row++)",
          "5007:     for (col=0; col < 3; col++)",
          "5008:       for (ng=d=0; d < 10; d+=2) {",
          "5009:  g = fcol(row,col) == 1;",
          "5010:  if (fcol(row+orth[d],col+orth[d+2]) == 1) ng=0; else ng++;",
          "5011:  if (ng == 4) { sgrow = row; sgcol = col; }",
          "5012:  if (ng == g+1) FORC(8) {",
          "5013:    v = orth[d  ]*patt[g][c*2] + orth[d+1]*patt[g][c*2+1];",
          "5014:    h = orth[d+2]*patt[g][c*2] + orth[d+3]*patt[g][c*2+1];",
          "5015:    allhex[row][col][0][c^(g*2 & d)] = h + v*width;",
          "5016:    allhex[row][col][1][c^(g*2 & d)] = h + v*TS;",
          "5017:  }",
          "5018:       }",
          "5021:   for (row=2; row < height-2; row++)",
          "5022:     for (min=~(max=0), col=2; col < width-2; col++) {",
          "5023:       if (fcol(row,col) == 1 && (min=~(max=0))) continue;",
          "5024:       pix = image + row*width + col;",
          "5025:       hex = allhex[row % 3][col % 3][0];",
          "5026:       if (!max) FORC(6) {",
          "5027:  val = pix[hex[c]][1];",
          "5028:  if (min > val) min = val;",
          "5029:  if (max < val) max = val;",
          "5033:       switch ((row-sgrow) % 3) {",
          "5034:  case 1: if (row < height-3) { row++; col--; } break;",
          "5035:  case 2: if ((min=~(max=0)) && (col+=2) < width-3 && row > 2) row--;",
          "5036:       }",
          "5037:     }",
          "5039:   for (top=3; top < height-19; top += TS-16)",
          "5040:     for (left=3; left < width-19; left += TS-16) {",
          "5041:       mrow = MIN (top+TS, height-3);",
          "5042:       mcol = MIN (left+TS, width-3);",
          "5043:       for (row=top; row < mrow; row++)",
          "5044:  for (col=left; col < mcol; col++)",
          "5045:    memcpy (rgb[0][row-top][col-left], image[row*width+col], 6);",
          "5046:       FORC3 memcpy (rgb[c+1], rgb[0], sizeof *rgb);",
          "5049:       for (row=top; row < mrow; row++)",
          "5050:  for (col=left; col < mcol; col++) {",
          "5051:    if ((f = fcol(row,col)) == 1) continue;",
          "5052:    pix = image + row*width + col;",
          "5053:    hex = allhex[row % 3][col % 3][0];",
          "5054:    color[1][0] = 174 * (pix[  hex[1]][1] + pix[  hex[0]][1]) -",
          "5055:     46 * (pix[2*hex[1]][1] + pix[2*hex[0]][1]);",
          "5056:    color[1][1] = 223 *  pix[  hex[3]][1] + pix[  hex[2]][1] * 33 +",
          "5057:     92 * (pix[      0 ][f] - pix[ -hex[2]][f]);",
          "5058:    FORC(2) color[1][2+c] =",
          "5059:   164 * pix[hex[4+c]][1] + 92 * pix[-2*hex[4+c]][1] + 33 *",
          "5060:   (2*pix[0][f] - pix[3*hex[4+c]][f] - pix[-3*hex[4+c]][f]);",
          "5061:    FORC4 rgb[c^!((row-sgrow) % 3)][row-top][col-left][1] =",
          "5062:   LIM(color[1][c] >> 8,pix[0][1],pix[0][3]);",
          "5063:  }",
          "5065:       for (pass=0; pass < passes; pass++) {",
          "5066:  if (pass == 1)",
          "5067:    memcpy (rgb+=4, buffer, 4*sizeof *rgb);",
          "5070:  if (pass) {",
          "5071:    for (row=top+2; row < mrow-2; row++)",
          "5072:      for (col=left+2; col < mcol-2; col++) {",
          "5073:        if ((f = fcol(row,col)) == 1) continue;",
          "5074:        pix = image + row*width + col;",
          "5075:        hex = allhex[row % 3][col % 3][1];",
          "5076:        for (d=3; d < 6; d++) {",
          "5077:   rix = &rgb[(d-2)^!((row-sgrow) % 3)][row-top][col-left];",
          "5078:   val = rix[-2*hex[d]][1] + 2*rix[hex[d]][1]",
          "5079:       - rix[-2*hex[d]][f] - 2*rix[hex[d]][f] + 3*rix[0][f];",
          "5080:   rix[0][1] = LIM(val/3,pix[0][1],pix[0][3]);",
          "5081:        }",
          "5082:      }",
          "5083:  }",
          "5086:  for (row=(top-sgrow+4)/3*3+sgrow; row < mrow-2; row+=3)",
          "5087:    for (col=(left-sgcol+4)/3*3+sgcol; col < mcol-2; col+=3) {",
          "5088:      rix = &rgb[0][row-top][col-left];",
          "5089:      h = fcol(row,col+1);",
          "5090:      memset (diff, 0, sizeof diff);",
          "5091:      for (i=1, d=0; d < 6; d++, i^=TS^1, h^=2) {",
          "5092:        for (c=0; c < 2; c++, h^=2) {",
          "5093:   g = 2*rix[0][1] - rix[i<<c][1] - rix[-i<<c][1];",
          "5094:   color[h][d] = g + rix[i<<c][h] + rix[-i<<c][h];",
          "5095:   if (d > 1)",
          "5096:     diff[d] += SQR (rix[i<<c][1] - rix[-i<<c][1]",
          "5097:     - rix[i<<c][h] + rix[-i<<c][h]) + SQR(g);",
          "5098:        }",
          "5099:        if (d > 1 && (d & 1))",
          "5100:   if (diff[d-1] < diff[d])",
          "5101:     FORC(2) color[c*2][d] = color[c*2][d-1];",
          "5102:        if (d < 2 || (d & 1)) {",
          "5103:   FORC(2) rix[0][c*2] = CLIP(color[c*2][d]/2);",
          "5104:   rix += TS*TS;",
          "5105:        }",
          "5106:      }",
          "5107:    }",
          "5110:  for (row=top+3; row < mrow-3; row++)",
          "5111:    for (col=left+3; col < mcol-3; col++) {",
          "5112:      if ((f = 2-fcol(row,col)) == 1) continue;",
          "5113:      rix = &rgb[0][row-top][col-left];",
          "5114:      c = (row-sgrow) % 3 ? TS:1;",
          "5115:      h = 3 * (c ^ TS ^ 1);",
          "5116:      for (d=0; d < 4; d++, rix += TS*TS) {",
          "5117:        i = d > 1 || ((d ^ c) & 1) ||",
          "5118:    ((ABS(rix[0][1]-rix[c][1])+ABS(rix[0][1]-rix[-c][1])) <",
          "5119:   2*(ABS(rix[0][1]-rix[h][1])+ABS(rix[0][1]-rix[-h][1]))) ? c:h;",
          "5120:        rix[0][f] = CLIP((rix[i][f] + rix[-i][f] +",
          "5121:     2*rix[0][1] - rix[i][1] - rix[-i][1])/2);",
          "5122:      }",
          "5123:    }",
          "5126:  for (row=top+2; row < mrow-2; row++) if ((row-sgrow) % 3)",
          "5127:    for (col=left+2; col < mcol-2; col++) if ((col-sgcol) % 3) {",
          "5128:      rix = &rgb[0][row-top][col-left];",
          "5129:      hex = allhex[row % 3][col % 3][1];",
          "5130:      for (d=0; d < ndir; d+=2, rix += TS*TS)",
          "5131:        if (hex[d] + hex[d+1]) {",
          "5132:   g = 3*rix[0][1] - 2*rix[hex[d]][1] - rix[hex[d+1]][1];",
          "5133:   for (c=0; c < 4; c+=2) rix[0][c] =",
          "5134:    CLIP((g + 2*rix[hex[d]][c] + rix[hex[d+1]][c])/3);",
          "5135:        } else {",
          "5136:   g = 2*rix[0][1] - rix[hex[d]][1] - rix[hex[d+1]][1];",
          "5137:   for (c=0; c < 4; c+=2) rix[0][c] =",
          "5138:    CLIP((g + rix[hex[d]][c] + rix[hex[d+1]][c])/2);",
          "5139:        }",
          "5140:    }",
          "5141:       }",
          "5142:       rgb = (ushort(*)[TS][TS][3]) buffer;",
          "5143:       mrow -= top;",
          "5144:       mcol -= left;",
          "5147:       for (d=0; d < ndir; d++) {",
          "5148:  for (row=2; row < mrow-2; row++)",
          "5149:    for (col=2; col < mcol-2; col++)",
          "5150:      cielab (rgb[d][row][col], lab[row][col]);",
          "5151:  for (f=dir[d & 3],row=3; row < mrow-3; row++)",
          "5152:    for (col=3; col < mcol-3; col++) {",
          "5153:      lix = &lab[row][col];",
          "5154:      g = 2*lix[0][0] - lix[f][0] - lix[-f][0];",
          "5155:      drv[d][row][col] = SQR(g)",
          "5156:        + SQR((2*lix[0][1] - lix[f][1] - lix[-f][1] + g*500/232))",
          "5157:        + SQR((2*lix[0][2] - lix[f][2] - lix[-f][2] - g*500/580));",
          "5158:    }",
          "5159:       }",
          "5162:       memset(homo, 0, ndir*TS*TS);",
          "5163:       for (row=4; row < mrow-4; row++)",
          "5164:  for (col=4; col < mcol-4; col++) {",
          "5165:    for (tr=FLT_MAX, d=0; d < ndir; d++)",
          "5166:      if (tr > drv[d][row][col])",
          "5167:   tr = drv[d][row][col];",
          "5168:    tr *= 8;",
          "5169:    for (d=0; d < ndir; d++)",
          "5170:      for (v=-1; v <= 1; v++)",
          "5171:        for (h=-1; h <= 1; h++)",
          "5172:   if (drv[d][row+v][col+h] <= tr)",
          "5173:     homo[d][row][col]++;",
          "5174:  }",
          "5177:       if (height-top < TS+4) mrow = height-top+2;",
          "5178:       if (width-left < TS+4) mcol = width-left+2;",
          "5179:       for (row = MIN(top,8); row < mrow-8; row++)",
          "5180:  for (col = MIN(left,8); col < mcol-8; col++) {",
          "5181:    for (d=0; d < ndir; d++)",
          "5182:      for (hm[d]=0, v=-2; v <= 2; v++)",
          "5183:        for (h=-2; h <= 2; h++)",
          "5184:   hm[d] += homo[d][row+v][col+h];",
          "5185:    for (d=0; d < ndir-4; d++)",
          "5186:      if (hm[d] < hm[d+4]) hm[d  ] = 0; else",
          "5187:      if (hm[d] > hm[d+4]) hm[d+4] = 0;",
          "5188:    for (max=hm[0],d=1; d < ndir; d++)",
          "5189:      if (max < hm[d]) max = hm[d];",
          "5190:    max -= max >> 3;",
          "5191:    memset (avg, 0, sizeof avg);",
          "5192:    for (d=0; d < ndir; d++)",
          "5193:      if (hm[d] >= max) {",
          "5194:        FORC3 avg[c] += rgb[d][row][col][c];",
          "5195:        avg[3]++;",
          "5196:      }",
          "5197:    FORC3 image[(row+top)*width+col+left][c] = avg[c]/avg[3];",
          "5198:  }",
          "5200:   free(buffer);",
          "5201:   border_interpolate(8);",
          "5202: }",
          "5203: #undef fcol",
          "5206:    Adaptive Homogeneity-Directed interpolation is based on",
          "5207:    the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.",
          "5209: #ifdef LIBRAW_LIBRARY_BUILD",
          "5211: void CLASS ahd_interpolate_green_h_and_v(int top, int left, ushort (*out_rgb)[TS][TS][3])",
          "5212: {",
          "5213:   int row, col;",
          "5214:   int c, val;",
          "5215:   ushort (*pix)[4];",
          "5216:   const int rowlimit = MIN(top+TS, height-2);",
          "5217:   const int collimit = MIN(left+TS, width-2);",
          "5219:   for (row = top; row < rowlimit; row++) {",
          "5220:     col = left + (FC(row,left) & 1);",
          "5221:     for (c = FC(row,col); col < collimit; col+=2) {",
          "5222:       pix = image + row*width+col;",
          "5223:       val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2",
          "5224:             - pix[-2][c] - pix[2][c]) >> 2;",
          "5225:       out_rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);",
          "5226:       val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2",
          "5227:             - pix[-2*width][c] - pix[2*width][c]) >> 2;",
          "5228:       out_rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);",
          "5232: void CLASS ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][3], short (*out_lab)[TS][3])",
          "5236:   ushort (*pix)[4];",
          "5237:   ushort (*rix)[3];",
          "5238:   short (*lix)[3];",
          "5240:   const unsigned num_pix_per_row = 4*width;",
          "5241:   const unsigned rowlimit = MIN(top+TS-1, height-3);",
          "5242:   const unsigned collimit = MIN(left+TS-1, width-3);",
          "5247:   for (row = top+1; row < rowlimit; row++) {",
          "5248:     pix = image + row*width + left;",
          "5249:     rix = &inout_rgb[row-top][0];",
          "5250:     lix = &out_lab[row-top][0];",
          "5252:     for (col = left+1; col < collimit; col++) {",
          "",
          "[Added Lines]",
          "5606: #define fcol(row, col) xtrans[(row + 6) % 6][(col + 6) % 6]",
          "5611: void CLASS xtrans_interpolate(int passes)",
          "5615:   static const short orth[12] = {1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1},",
          "5616:                      patt[2][16] = {{0, 1, 0, -1, 2, 0, -1, 0, 1, 1, 1, -1, 0, 0, 0, 0},",
          "5617:                                     {0, 1, 0, -2, 1, 0, -2, 0, 1, 1, -2, -2, 1, -1, -1, 1}},",
          "5618:                      dir[4] = {1, TS, TS + 1, TS - 1};",
          "5621:   ushort(*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];",
          "5622:   short(*lab)[TS][3], (*lix)[3];",
          "5623:   float(*drv)[TS][TS], diff[6], tr;",
          "5624:   char(*homo)[TS][TS], *buffer;",
          "5628:     fprintf(stderr, _(\"%d-pass X-Trans interpolation...\\n\"), passes);",
          "5631:   cielab(0, 0);",
          "5633:   buffer = (char *)malloc(TS * TS * (ndir * 11 + 6));",
          "5634:   merror(buffer, \"xtrans_interpolate()\");",
          "5635:   rgb = (ushort(*)[TS][TS][3])buffer;",
          "5636:   lab = (short(*)[TS][3])(buffer + TS * TS * (ndir * 6));",
          "5637:   drv = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 6 + 6));",
          "5638:   homo = (char(*)[TS][TS])(buffer + TS * TS * (ndir * 10 + 6));",
          "5641:   for (row = 0; row < 3; row++)",
          "5642:     for (col = 0; col < 3; col++)",
          "5643:       for (ng = d = 0; d < 10; d += 2)",
          "5644:       {",
          "5645:         g = fcol(row, col) == 1;",
          "5646:         if (fcol(row + orth[d], col + orth[d + 2]) == 1)",
          "5647:           ng = 0;",
          "5648:         else",
          "5649:           ng++;",
          "5650:         if (ng == 4)",
          "5651:         {",
          "5652:           sgrow = row;",
          "5653:           sgcol = col;",
          "5654:         }",
          "5655:         if (ng == g + 1)",
          "5656:           FORC(8)",
          "5657:           {",
          "5658:             v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];",
          "5659:             h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];",
          "5660:             allhex[row][col][0][c ^ (g * 2 & d)] = h + v * width;",
          "5661:             allhex[row][col][1][c ^ (g * 2 & d)] = h + v * TS;",
          "5662:           }",
          "5666:   for (row = 2; row < height - 2; row++)",
          "5667:     for (min = ~(max = 0), col = 2; col < width - 2; col++)",
          "5668:     {",
          "5669:       if (fcol(row, col) == 1 && (min = ~(max = 0)))",
          "5670:         continue;",
          "5671:       pix = image + row * width + col;",
          "5672:       hex = allhex[row % 3][col % 3][0];",
          "5673:       if (!max)",
          "5674:         FORC(6)",
          "5675:         {",
          "5676:           val = pix[hex[c]][1];",
          "5677:           if (min > val)",
          "5678:             min = val;",
          "5679:           if (max < val)",
          "5680:             max = val;",
          "5681:         }",
          "5684:       switch ((row - sgrow) % 3)",
          "5685:       {",
          "5686:       case 1:",
          "5687:         if (row < height - 3)",
          "5688:         {",
          "5689:           row++;",
          "5690:           col--;",
          "5691:         }",
          "5692:         break;",
          "5693:       case 2:",
          "5694:         if ((min = ~(max = 0)) && (col += 2) < width - 3 && row > 2)",
          "5695:           row--;",
          "5696:       }",
          "5699:   for (top = 3; top < height - 19; top += TS - 16)",
          "5700:     for (left = 3; left < width - 19; left += TS - 16)",
          "5701:     {",
          "5702:       mrow = MIN(top + TS, height - 3);",
          "5703:       mcol = MIN(left + TS, width - 3);",
          "5704:       for (row = top; row < mrow; row++)",
          "5705:         for (col = left; col < mcol; col++)",
          "5706:           memcpy(rgb[0][row - top][col - left], image[row * width + col], 6);",
          "5707:       FORC3 memcpy(rgb[c + 1], rgb[0], sizeof *rgb);",
          "5710:       for (row = top; row < mrow; row++)",
          "5711:         for (col = left; col < mcol; col++)",
          "5712:         {",
          "5713:           if ((f = fcol(row, col)) == 1)",
          "5714:             continue;",
          "5715:           pix = image + row * width + col;",
          "5716:           hex = allhex[row % 3][col % 3][0];",
          "5717:           color[1][0] = 174 * (pix[hex[1]][1] + pix[hex[0]][1]) - 46 * (pix[2 * hex[1]][1] + pix[2 * hex[0]][1]);",
          "5718:           color[1][1] = 223 * pix[hex[3]][1] + pix[hex[2]][1] * 33 + 92 * (pix[0][f] - pix[-hex[2]][f]);",
          "5719:           FORC(2)",
          "5720:           color[1][2 + c] = 164 * pix[hex[4 + c]][1] + 92 * pix[-2 * hex[4 + c]][1] +",
          "5721:                             33 * (2 * pix[0][f] - pix[3 * hex[4 + c]][f] - pix[-3 * hex[4 + c]][f]);",
          "5722:           FORC4 rgb[c ^ !((row - sgrow) % 3)][row - top][col - left][1] = LIM(color[1][c] >> 8, pix[0][1], pix[0][3]);",
          "5723:         }",
          "5725:       for (pass = 0; pass < passes; pass++)",
          "5726:       {",
          "5727:         if (pass == 1)",
          "5728:           memcpy(rgb += 4, buffer, 4 * sizeof *rgb);",
          "5731:         if (pass)",
          "5732:         {",
          "5733:           for (row = top + 2; row < mrow - 2; row++)",
          "5734:             for (col = left + 2; col < mcol - 2; col++)",
          "5735:             {",
          "5736:               if ((f = fcol(row, col)) == 1)",
          "5737:                 continue;",
          "5738:               pix = image + row * width + col;",
          "5739:               hex = allhex[row % 3][col % 3][1];",
          "5740:               for (d = 3; d < 6; d++)",
          "5741:               {",
          "5742:                 rix = &rgb[(d - 2) ^ !((row - sgrow) % 3)][row - top][col - left];",
          "5743:                 val =",
          "5744:                     rix[-2 * hex[d]][1] + 2 * rix[hex[d]][1] - rix[-2 * hex[d]][f] - 2 * rix[hex[d]][f] + 3 * rix[0][f];",
          "5745:                 rix[0][1] = LIM(val / 3, pix[0][1], pix[0][3]);",
          "5746:               }",
          "5747:             }",
          "5748:         }",
          "5751:         for (row = (top - sgrow + 4) / 3 * 3 + sgrow; row < mrow - 2; row += 3)",
          "5752:           for (col = (left - sgcol + 4) / 3 * 3 + sgcol; col < mcol - 2; col += 3)",
          "5753:           {",
          "5754:             rix = &rgb[0][row - top][col - left];",
          "5755:             h = fcol(row, col + 1);",
          "5756:             memset(diff, 0, sizeof diff);",
          "5757:             for (i = 1, d = 0; d < 6; d++, i ^= TS ^ 1, h ^= 2)",
          "5758:             {",
          "5759:               for (c = 0; c < 2; c++, h ^= 2)",
          "5760:               {",
          "5761:                 g = 2 * rix[0][1] - rix[i << c][1] - rix[-i << c][1];",
          "5762:                 color[h][d] = g + rix[i << c][h] + rix[-i << c][h];",
          "5763:                 if (d > 1)",
          "5764:                   diff[d] += SQR(rix[i << c][1] - rix[-i << c][1] - rix[i << c][h] + rix[-i << c][h]) + SQR(g);",
          "5765:               }",
          "5766:               if (d > 1 && (d & 1))",
          "5767:                 if (diff[d - 1] < diff[d])",
          "5768:                   FORC(2) color[c * 2][d] = color[c * 2][d - 1];",
          "5769:               if (d < 2 || (d & 1))",
          "5770:               {",
          "5771:                 FORC(2) rix[0][c * 2] = CLIP(color[c * 2][d] / 2);",
          "5772:                 rix += TS * TS;",
          "5773:               }",
          "5774:             }",
          "5775:           }",
          "5778:         for (row = top + 3; row < mrow - 3; row++)",
          "5779:           for (col = left + 3; col < mcol - 3; col++)",
          "5780:           {",
          "5781:             if ((f = 2 - fcol(row, col)) == 1)",
          "5782:               continue;",
          "5783:             rix = &rgb[0][row - top][col - left];",
          "5784:             c = (row - sgrow) % 3 ? TS : 1;",
          "5785:             h = 3 * (c ^ TS ^ 1);",
          "5786:             for (d = 0; d < 4; d++, rix += TS * TS)",
          "5787:             {",
          "5788:               i = d > 1 || ((d ^ c) & 1) || ((ABS(rix[0][1] - rix[c][1]) + ABS(rix[0][1] - rix[-c][1])) <",
          "5789:                                              2 * (ABS(rix[0][1] - rix[h][1]) + ABS(rix[0][1] - rix[-h][1])))",
          "5790:                       ? c",
          "5791:                       : h;",
          "5792:               rix[0][f] = CLIP((rix[i][f] + rix[-i][f] + 2 * rix[0][1] - rix[i][1] - rix[-i][1]) / 2);",
          "5793:             }",
          "5794:           }",
          "5797:         for (row = top + 2; row < mrow - 2; row++)",
          "5798:           if ((row - sgrow) % 3)",
          "5799:             for (col = left + 2; col < mcol - 2; col++)",
          "5800:               if ((col - sgcol) % 3)",
          "5801:               {",
          "5802:                 rix = &rgb[0][row - top][col - left];",
          "5803:                 hex = allhex[row % 3][col % 3][1];",
          "5804:                 for (d = 0; d < ndir; d += 2, rix += TS * TS)",
          "5805:                   if (hex[d] + hex[d + 1])",
          "5806:                   {",
          "5807:                     g = 3 * rix[0][1] - 2 * rix[hex[d]][1] - rix[hex[d + 1]][1];",
          "5808:                     for (c = 0; c < 4; c += 2)",
          "5809:                       rix[0][c] = CLIP((g + 2 * rix[hex[d]][c] + rix[hex[d + 1]][c]) / 3);",
          "5810:                   }",
          "5811:                   else",
          "5812:                   {",
          "5813:                     g = 2 * rix[0][1] - rix[hex[d]][1] - rix[hex[d + 1]][1];",
          "5814:                     for (c = 0; c < 4; c += 2)",
          "5815:                       rix[0][c] = CLIP((g + rix[hex[d]][c] + rix[hex[d + 1]][c]) / 2);",
          "5816:                   }",
          "5817:               }",
          "5818:       }",
          "5819:       rgb = (ushort(*)[TS][TS][3])buffer;",
          "5820:       mrow -= top;",
          "5821:       mcol -= left;",
          "5824:       for (d = 0; d < ndir; d++)",
          "5825:       {",
          "5826:         for (row = 2; row < mrow - 2; row++)",
          "5827:           for (col = 2; col < mcol - 2; col++)",
          "5828:             cielab(rgb[d][row][col], lab[row][col]);",
          "5829:         for (f = dir[d & 3], row = 3; row < mrow - 3; row++)",
          "5830:           for (col = 3; col < mcol - 3; col++)",
          "5831:           {",
          "5832:             lix = &lab[row][col];",
          "5833:             g = 2 * lix[0][0] - lix[f][0] - lix[-f][0];",
          "5834:             drv[d][row][col] = SQR(g) + SQR((2 * lix[0][1] - lix[f][1] - lix[-f][1] + g * 500 / 232)) +",
          "5835:                                SQR((2 * lix[0][2] - lix[f][2] - lix[-f][2] - g * 500 / 580));",
          "5836:           }",
          "5837:       }",
          "5840:       memset(homo, 0, ndir * TS * TS);",
          "5841:       for (row = 4; row < mrow - 4; row++)",
          "5842:         for (col = 4; col < mcol - 4; col++)",
          "5843:         {",
          "5844:           for (tr = FLT_MAX, d = 0; d < ndir; d++)",
          "5845:             if (tr > drv[d][row][col])",
          "5846:               tr = drv[d][row][col];",
          "5847:           tr *= 8;",
          "5848:           for (d = 0; d < ndir; d++)",
          "5849:             for (v = -1; v <= 1; v++)",
          "5850:               for (h = -1; h <= 1; h++)",
          "5851:                 if (drv[d][row + v][col + h] <= tr)",
          "5852:                   homo[d][row][col]++;",
          "5853:         }",
          "5856:       if (height - top < TS + 4)",
          "5857:         mrow = height - top + 2;",
          "5858:       if (width - left < TS + 4)",
          "5859:         mcol = width - left + 2;",
          "5860:       for (row = MIN(top, 8); row < mrow - 8; row++)",
          "5861:         for (col = MIN(left, 8); col < mcol - 8; col++)",
          "5862:         {",
          "5863:           for (d = 0; d < ndir; d++)",
          "5864:             for (hm[d] = 0, v = -2; v <= 2; v++)",
          "5865:               for (h = -2; h <= 2; h++)",
          "5866:                 hm[d] += homo[d][row + v][col + h];",
          "5867:           for (d = 0; d < ndir - 4; d++)",
          "5868:             if (hm[d] < hm[d + 4])",
          "5869:               hm[d] = 0;",
          "5870:             else if (hm[d] > hm[d + 4])",
          "5871:               hm[d + 4] = 0;",
          "5872:           for (max = hm[0], d = 1; d < ndir; d++)",
          "5873:             if (max < hm[d])",
          "5874:               max = hm[d];",
          "5875:           max -= max >> 3;",
          "5876:           memset(avg, 0, sizeof avg);",
          "5877:           for (d = 0; d < ndir; d++)",
          "5878:             if (hm[d] >= max)",
          "5879:             {",
          "5880:               FORC3 avg[c] += rgb[d][row][col][c];",
          "5881:               avg[3]++;",
          "5882:             }",
          "5883:           FORC3 image[(row + top) * width + col + left][c] = avg[c] / avg[3];",
          "5884:         }",
          "5885:     }",
          "5886:   free(buffer);",
          "5887:   border_interpolate(8);",
          "5888: }",
          "5889: #undef fcol",
          "5892:    Adaptive Homogeneity-Directed interpolation is based on",
          "5893:    the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.",
          "5895: #ifdef LIBRAW_LIBRARY_BUILD",
          "5897: void CLASS ahd_interpolate_green_h_and_v(int top, int left, ushort (*out_rgb)[TS][TS][3])",
          "5898: {",
          "5899:   int row, col;",
          "5900:   int c, val;",
          "5901:   ushort(*pix)[4];",
          "5902:   const int rowlimit = MIN(top + TS, height - 2);",
          "5903:   const int collimit = MIN(left + TS, width - 2);",
          "5905:   for (row = top; row < rowlimit; row++)",
          "5906:   {",
          "5907:     col = left + (FC(row, left) & 1);",
          "5908:     for (c = FC(row, col); col < collimit; col += 2)",
          "5909:     {",
          "5910:       pix = image + row * width + col;",
          "5911:       val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2 - pix[-2][c] - pix[2][c]) >> 2;",
          "5912:       out_rgb[0][row - top][col - left][1] = ULIM(val, pix[-1][1], pix[1][1]);",
          "5913:       val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2 - pix[-2 * width][c] - pix[2 * width][c]) >> 2;",
          "5914:       out_rgb[1][row - top][col - left][1] = ULIM(val, pix[-width][1], pix[width][1]);",
          "5918: void CLASS ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][3],",
          "5919:                                                                 short (*out_lab)[TS][3])",
          "5923:   ushort(*pix)[4];",
          "5924:   ushort(*rix)[3];",
          "5925:   short(*lix)[3];",
          "5927:   const unsigned num_pix_per_row = 4 * width;",
          "5928:   const unsigned rowlimit = MIN(top + TS - 1, height - 3);",
          "5929:   const unsigned collimit = MIN(left + TS - 1, width - 3);",
          "5934:   for (row = top + 1; row < rowlimit; row++)",
          "5935:   {",
          "5936:     pix = image + row * width + left;",
          "5937:     rix = &inout_rgb[row - top][0];",
          "5938:     lix = &out_lab[row - top][0];",
          "5940:     for (col = left + 1; col < collimit; col++)",
          "5941:     {",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "5259:       c = 2 - FC(row, col);",
          "5266:         rix[0][t1] = CLIP(val);",
          "5276:       }",
          "5277:       rix[0][c] = CLIP(val);",
          "5279:       rix[0][c] = pix[0][c];",
          "5281:     }",
          "5282:   }",
          "5283: }",
          "5285: {",
          "5286:   int direction;",
          "5288:     ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(top, left, inout_rgb[direction], out_lab[direction]);",
          "5289:   }",
          "5290: }",
          "5293: {",
          "5294:   int row, col;",
          "5295:   int tr, tc;",
          "5296:   int direction;",
          "5297:   int i;",
          "5300:   short *adjacent_lix;",
          "5301:   unsigned ldiff[2][4], abdiff[2][4], leps, abeps;",
          "5305:   int homogeneity;",
          "5312:     homogeneity_map_p = &out_homogeneity_map[tr][1];",
          "5314:       lixs[direction] = &lab[direction][tr][1];",
          "5315:     }",
          "5319:       homogeneity_map_p++;",
          "5322:         lix = ++lixs[direction];",
          "5328:         }",
          "5329:       }",
          "5342:       }",
          "5343:     }",
          "5344:   }",
          "5345: }",
          "5347: {",
          "5348:   int row, col;",
          "5349:   int tr, tc;",
          "",
          "[Removed Lines]",
          "5261:       if (c == 1) {",
          "5262:         c = FC(row+1,col);",
          "5263:  t1 = 2-c;",
          "5264:         val = pix[0][1] + (( pix[-1][t1] + pix[1][t1]",
          "5265:               - rix[-1][1] - rix[1][1] ) >> 1);",
          "5267:         val = pix[0][1] + (( pix_above[c] + pix_below[c]",
          "5268:               - rix[-TS][1] - rix[TS][1] ) >> 1);",
          "5269:       } else {",
          "5272:         val = rix[0][1] + (( pix_above[t1] + pix_above[t2]",
          "5273:               + pix_below[t1] + pix_below[t2]",
          "5274:               - rix[-TS-1][1] - rix[-TS+1][1]",
          "5275:               - rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);",
          "5278:       c = FC(row,col);",
          "5280:       cielab(rix[0],lix[0]);",
          "5284: void CLASS ahd_interpolate_r_and_b_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][TS][3], short (*out_lab)[TS][TS][3])",
          "5287:   for (direction = 0; direction < 2; direction++) {",
          "5292: void CLASS ahd_interpolate_build_homogeneity_map(int top, int left, short (*lab)[TS][TS][3], char (*out_homogeneity_map)[TS][2])",
          "5298:   short (*lix)[3];",
          "5299:   short (*lixs[2])[3];",
          "5302:   static const int dir[4] = { -1, 1, -TS, TS };",
          "5303:   const int rowlimit = MIN(top+TS-2, height-4);",
          "5304:   const int collimit = MIN(left+TS-2, width-4);",
          "5306:   char (*homogeneity_map_p)[2];",
          "5308:   memset (out_homogeneity_map, 0, 2*TS*TS);",
          "5310:   for (row=top+2; row < rowlimit; row++) {",
          "5311:     tr = row-top;",
          "5313:     for (direction=0; direction < 2; direction++) {",
          "5317:     for (col=left+2; col < collimit; col++) {",
          "5318:       tc = col-left;",
          "5321:       for (direction=0; direction < 2; direction++) {",
          "5323:         for (i=0; i < 4; i++) {",
          "5324:    adjacent_lix = lix[dir[i]];",
          "5325:           ldiff[direction][i] = ABS(lix[0][0]-adjacent_lix[0]);",
          "5326:           abdiff[direction][i] = SQR(lix[0][1]-adjacent_lix[1])",
          "5327:             + SQR(lix[0][2]-adjacent_lix[2]);",
          "5330:       leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),",
          "5331:           MAX(ldiff[1][2],ldiff[1][3]));",
          "5332:       abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),",
          "5333:           MAX(abdiff[1][2],abdiff[1][3]));",
          "5334:       for (direction=0; direction < 2; direction++) {",
          "5335:  homogeneity = 0;",
          "5336:         for (i=0; i < 4; i++) {",
          "5337:           if (ldiff[direction][i] <= leps && abdiff[direction][i] <= abeps) {",
          "5338:      homogeneity++;",
          "5339:    }",
          "5340:  }",
          "5341:  homogeneity_map_p[0][direction] = homogeneity;",
          "5346: void CLASS ahd_interpolate_combine_homogeneous_pixels(int top, int left, ushort (*rgb)[TS][TS][3], char (*homogeneity_map)[TS][2])",
          "",
          "[Added Lines]",
          "5950:       if (c == 1)",
          "5951:       {",
          "5952:         c = FC(row + 1, col);",
          "5953:         t1 = 2 - c;",
          "5954:         val = pix[0][1] + ((pix[-1][t1] + pix[1][t1] - rix[-1][1] - rix[1][1]) >> 1);",
          "5956:         val = pix[0][1] + ((pix_above[c] + pix_below[c] - rix[-TS][1] - rix[TS][1]) >> 1);",
          "5957:       }",
          "5958:       else",
          "5959:       {",
          "5962:         val = rix[0][1] + ((pix_above[t1] + pix_above[t2] + pix_below[t1] + pix_below[t2] - rix[-TS - 1][1] -",
          "5963:                             rix[-TS + 1][1] - rix[+TS - 1][1] - rix[+TS + 1][1] + 1) >>",
          "5964:                            2);",
          "5967:       c = FC(row, col);",
          "5969:       cielab(rix[0], lix[0]);",
          "5973: void CLASS ahd_interpolate_r_and_b_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][TS][3],",
          "5974:                                                          short (*out_lab)[TS][TS][3])",
          "5977:   for (direction = 0; direction < 2; direction++)",
          "5978:   {",
          "5983: void CLASS ahd_interpolate_build_homogeneity_map(int top, int left, short (*lab)[TS][TS][3],",
          "5984:                                                  char (*out_homogeneity_map)[TS][2])",
          "5990:   short(*lix)[3];",
          "5991:   short(*lixs[2])[3];",
          "5994:   static const int dir[4] = {-1, 1, -TS, TS};",
          "5995:   const int rowlimit = MIN(top + TS - 2, height - 4);",
          "5996:   const int collimit = MIN(left + TS - 2, width - 4);",
          "5998:   char(*homogeneity_map_p)[2];",
          "6000:   memset(out_homogeneity_map, 0, 2 * TS * TS);",
          "6002:   for (row = top + 2; row < rowlimit; row++)",
          "6003:   {",
          "6004:     tr = row - top;",
          "6006:     for (direction = 0; direction < 2; direction++)",
          "6007:     {",
          "6011:     for (col = left + 2; col < collimit; col++)",
          "6012:     {",
          "6013:       tc = col - left;",
          "6016:       for (direction = 0; direction < 2; direction++)",
          "6017:       {",
          "6019:         for (i = 0; i < 4; i++)",
          "6020:         {",
          "6021:           adjacent_lix = lix[dir[i]];",
          "6022:           ldiff[direction][i] = ABS(lix[0][0] - adjacent_lix[0]);",
          "6023:           abdiff[direction][i] = SQR(lix[0][1] - adjacent_lix[1]) + SQR(lix[0][2] - adjacent_lix[2]);",
          "6026:       leps = MIN(MAX(ldiff[0][0], ldiff[0][1]), MAX(ldiff[1][2], ldiff[1][3]));",
          "6027:       abeps = MIN(MAX(abdiff[0][0], abdiff[0][1]), MAX(abdiff[1][2], abdiff[1][3]));",
          "6028:       for (direction = 0; direction < 2; direction++)",
          "6029:       {",
          "6030:         homogeneity = 0;",
          "6031:         for (i = 0; i < 4; i++)",
          "6032:         {",
          "6033:           if (ldiff[direction][i] <= leps && abdiff[direction][i] <= abeps)",
          "6034:           {",
          "6035:             homogeneity++;",
          "6036:           }",
          "6037:         }",
          "6038:         homogeneity_map_p[0][direction] = homogeneity;",
          "6043: void CLASS ahd_interpolate_combine_homogeneous_pixels(int top, int left, ushort (*rgb)[TS][TS][3],",
          "6044:                                                       char (*homogeneity_map)[TS][2])",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "5351:   int direction;",
          "5352:   int hm[2];",
          "5353:   int c;",
          "5364:       rix[direction] = &rgb[direction][tr][2];",
          "5365:     }",
          "5369:       pix++;",
          "5371:         rix[direction]++;",
          "5372:       }",
          "5375:         hm[direction] = 0;",
          "5378:             hm[direction] += homogeneity_map[i][j][direction];",
          "5379:           }",
          "5380:         }",
          "5381:       }",
          "5383:         memcpy(pix[0], rix[hm[1] > hm[0]][0], 3 * sizeof(ushort));",
          "5388:       }",
          "5389:     }",
          "5390:   }",
          "",
          "[Removed Lines]",
          "5354:   const int rowlimit = MIN(top+TS-3, height-5);",
          "5355:   const int collimit = MIN(left+TS-3, width-5);",
          "5357:   ushort (*pix)[4];",
          "5358:   ushort (*rix[2])[3];",
          "5360:   for (row=top+3; row < rowlimit; row++) {",
          "5361:     tr = row-top;",
          "5362:     pix = &image[row*width+left+2];",
          "5363:     for (direction = 0; direction < 2; direction++) {",
          "5367:     for (col=left+3; col < collimit; col++) {",
          "5368:       tc = col-left;",
          "5370:       for (direction = 0; direction < 2; direction++) {",
          "5374:       for (direction=0; direction < 2; direction++) {",
          "5376:         for (i=tr-1; i <= tr+1; i++) {",
          "5377:           for (j=tc-1; j <= tc+1; j++) {",
          "5382:       if (hm[0] != hm[1]) {",
          "5384:       } else {",
          "5385:         FORC3 {",
          "5386:           pix[0][c] = (rix[0][0][c] + rix[1][0][c]) >> 1;",
          "5387:         }",
          "",
          "[Added Lines]",
          "6052:   const int rowlimit = MIN(top + TS - 3, height - 5);",
          "6053:   const int collimit = MIN(left + TS - 3, width - 5);",
          "6055:   ushort(*pix)[4];",
          "6056:   ushort(*rix[2])[3];",
          "6058:   for (row = top + 3; row < rowlimit; row++)",
          "6059:   {",
          "6060:     tr = row - top;",
          "6061:     pix = &image[row * width + left + 2];",
          "6062:     for (direction = 0; direction < 2; direction++)",
          "6063:     {",
          "6067:     for (col = left + 3; col < collimit; col++)",
          "6068:     {",
          "6069:       tc = col - left;",
          "6071:       for (direction = 0; direction < 2; direction++)",
          "6072:       {",
          "6076:       for (direction = 0; direction < 2; direction++)",
          "6077:       {",
          "6079:         for (i = tr - 1; i <= tr + 1; i++)",
          "6080:         {",
          "6081:           for (j = tc - 1; j <= tc + 1; j++)",
          "6082:           {",
          "6087:       if (hm[0] != hm[1])",
          "6088:       {",
          "6090:       }",
          "6091:       else",
          "6092:       {",
          "6093:         FORC3 { pix[0][c] = (rix[0][0][c] + rix[1][0][c]) >> 1; }",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "5392: void CLASS ahd_interpolate()",
          "5393: {",
          "5394:   int i, j, k, top, left;",
          "5396:   char *buffer;",
          "5400:   int terminate_flag = 0;",
          "5404:   border_interpolate(5);",
          "5406: #ifdef LIBRAW_LIBRARY_BUILD",
          "5407: #ifdef LIBRAW_USE_OPENMP",
          "5409: #endif",
          "5410: #endif",
          "5411:   {",
          "5418: #ifdef LIBRAW_LIBRARY_BUILD",
          "5419: #ifdef LIBRAW_USE_OPENMP",
          "5420: #pragma omp for schedule(dynamic)",
          "5421: #endif",
          "5422: #endif",
          "5424: #ifdef LIBRAW_LIBRARY_BUILD",
          "5425: #ifdef LIBRAW_USE_OPENMP",
          "5427: #endif",
          "5433: #endif",
          "5439:       }",
          "5440:     }",
          "5442:   }",
          "5443: #ifdef LIBRAW_LIBRARY_BUILD",
          "5446: #endif",
          "5447: }",
          "",
          "[Removed Lines]",
          "5395:   float xyz_cam[3][4],r;",
          "5397:   ushort (*rgb)[TS][TS][3];",
          "5398:   short (*lab)[TS][TS][3];",
          "5399:   char (*homo)[TS][2];",
          "5403:   cielab(0,0);",
          "5408: #pragma omp parallel private(buffer,rgb,lab,homo,top,left,i,j,k) shared(xyz_cam,terminate_flag)",
          "5413:     merror (buffer, \"ahd_interpolate()\");",
          "5414:     rgb  = (ushort(*)[TS][TS][3]) buffer;",
          "5415:     lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);",
          "5416:     homo = (char  (*)[TS][2])    (buffer + 24*TS*TS);",
          "5423:     for (top=2; top < height-5; top += TS-6){",
          "5426:         if(0== omp_get_thread_num())",
          "5428:            if(callbacks.progress_cb) {",
          "5429:                int rr = (*callbacks.progress_cb)(callbacks.progresscb_data,LIBRAW_PROGRESS_INTERPOLATE,top-2,height-7);",
          "5430:                if(rr)",
          "5431:                    terminate_flag = 1;",
          "5432:            }",
          "5434:         for (left=2; !terminate_flag && (left < width-5); left += TS-6) {",
          "5435:             ahd_interpolate_green_h_and_v(top, left, rgb);",
          "5436:             ahd_interpolate_r_and_b_and_convert_to_cielab(top, left, rgb, lab);",
          "5437:             ahd_interpolate_build_homogeneity_map(top, left, lab, homo);",
          "5438:             ahd_interpolate_combine_homogeneous_pixels(top, left, rgb, homo);",
          "5441:     free (buffer);",
          "5444:   if(terminate_flag)",
          "5445:       throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;",
          "",
          "[Added Lines]",
          "6101:   float xyz_cam[3][4], r;",
          "6103:   ushort(*rgb)[TS][TS][3];",
          "6104:   short(*lab)[TS][TS][3];",
          "6105:   char(*homo)[TS][2];",
          "6108:   cielab(0, 0);",
          "6113: #pragma omp parallel private(buffer, rgb, lab, homo, top, left, i, j, k) shared(xyz_cam, terminate_flag)",
          "6118:     merror(buffer, \"ahd_interpolate()\");",
          "6119:     rgb = (ushort(*)[TS][TS][3])buffer;",
          "6120:     lab = (short(*)[TS][TS][3])(buffer + 12 * TS * TS);",
          "6121:     homo = (char(*)[TS][2])(buffer + 24 * TS * TS);",
          "6128:     for (top = 2; top < height - 5; top += TS - 6)",
          "6129:     {",
          "6132:       if (0 == omp_get_thread_num())",
          "6134:         if (callbacks.progress_cb)",
          "6135:         {",
          "6136:           int rr =",
          "6137:               (*callbacks.progress_cb)(callbacks.progresscb_data, LIBRAW_PROGRESS_INTERPOLATE, top - 2, height - 7);",
          "6138:           if (rr)",
          "6139:             terminate_flag = 1;",
          "6140:         }",
          "6142:       for (left = 2; !terminate_flag && (left < width - 5); left += TS - 6)",
          "6143:       {",
          "6144:         ahd_interpolate_green_h_and_v(top, left, rgb);",
          "6145:         ahd_interpolate_r_and_b_and_convert_to_cielab(top, left, rgb, lab);",
          "6146:         ahd_interpolate_build_homogeneity_map(top, left, lab, homo);",
          "6147:         ahd_interpolate_combine_homogeneous_pixels(top, left, rgb, homo);",
          "6150:     free(buffer);",
          "6153:   if (terminate_flag)",
          "6154:     throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "5450: void CLASS ahd_interpolate()",
          "5451: {",
          "5452:   int i, j, top, left, row, col, tr, tc, c, d, val, hm[2];",
          "5454:   unsigned ldiff[2][4], abdiff[2][4], leps, abeps;",
          "5459: #ifdef DCRAW_VERBOSE",
          "5461: #endif",
          "5464:   border_interpolate(5);",
          "5554: }",
          "5555: #endif",
          "5556: #undef TS",
          "5558: void CLASS median_filter()",
          "5559: {",
          "5561:   int pass, c, i, j, k, med[9];",
          "5567: #ifdef LIBRAW_LIBRARY_BUILD",
          "5569: #endif",
          "5570: #ifdef DCRAW_VERBOSE",
          "5571:     if (verbose)",
          "5573: #endif",
          "5586:       }",
          "5587:     }",
          "5588:   }",
          "",
          "[Removed Lines]",
          "5453:   static const int dir[4] = { -1, 1, -TS, TS };",
          "5455:   ushort (*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];",
          "5456:    short (*lab)[TS][TS][3], (*lix)[3];",
          "5457:    char (*homo)[TS][TS], *buffer;",
          "5460:   if (verbose) fprintf (stderr,_(\"AHD interpolation...\\n\"));",
          "5463:   cielab (0,0);",
          "5465:   buffer = (char *) malloc (26*TS*TS);",
          "5466:   merror (buffer, \"ahd_interpolate()\");",
          "5467:   rgb  = (ushort(*)[TS][TS][3]) buffer;",
          "5468:   lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);",
          "5469:   homo = (char  (*)[TS][TS])   (buffer + 24*TS*TS);",
          "5471:   for (top=2; top < height-5; top += TS-6)",
          "5472:     for (left=2; left < width-5; left += TS-6) {",
          "5475:       for (row=top; row < top+TS && row < height-2; row++) {",
          "5476:  col = left + (FC(row,left) & 1);",
          "5477:  for (c = FC(row,col); col < left+TS && col < width-2; col+=2) {",
          "5478:    pix = image + row*width+col;",
          "5479:    val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2",
          "5480:   - pix[-2][c] - pix[2][c]) >> 2;",
          "5481:    rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);",
          "5482:    val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2",
          "5483:   - pix[-2*width][c] - pix[2*width][c]) >> 2;",
          "5484:    rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);",
          "5485:  }",
          "5486:       }",
          "5489:       for (d=0; d < 2; d++)",
          "5490:  for (row=top+1; row < top+TS-1 && row < height-3; row++)",
          "5491:    for (col=left+1; col < left+TS-1 && col < width-3; col++) {",
          "5492:      pix = image + row*width+col;",
          "5493:      rix = &rgb[d][row-top][col-left];",
          "5494:      lix = &lab[d][row-top][col-left];",
          "5495:      if ((c = 2 - FC(row,col)) == 1) {",
          "5496:        c = FC(row+1,col);",
          "5497:        val = pix[0][1] + (( pix[-1][2-c] + pix[1][2-c]",
          "5498:      - rix[-1][1] - rix[1][1] ) >> 1);",
          "5499:        rix[0][2-c] = CLIP(val);",
          "5500:        val = pix[0][1] + (( pix[-width][c] + pix[width][c]",
          "5501:      - rix[-TS][1] - rix[TS][1] ) >> 1);",
          "5502:      } else",
          "5503:        val = rix[0][1] + (( pix[-width-1][c] + pix[-width+1][c]",
          "5504:      + pix[+width-1][c] + pix[+width+1][c]",
          "5505:      - rix[-TS-1][1] - rix[-TS+1][1]",
          "5506:      - rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);",
          "5507:      rix[0][c] = CLIP(val);",
          "5508:      c = FC(row,col);",
          "5509:      rix[0][c] = pix[0][c];",
          "5510:      cielab (rix[0],lix[0]);",
          "5511:    }",
          "5513:       memset (homo, 0, 2*TS*TS);",
          "5514:       for (row=top+2; row < top+TS-2 && row < height-4; row++) {",
          "5515:  tr = row-top;",
          "5516:  for (col=left+2; col < left+TS-2 && col < width-4; col++) {",
          "5517:    tc = col-left;",
          "5518:    for (d=0; d < 2; d++) {",
          "5519:      lix = &lab[d][tr][tc];",
          "5520:      for (i=0; i < 4; i++) {",
          "5521:         ldiff[d][i] = ABS(lix[0][0]-lix[dir[i]][0]);",
          "5522:        abdiff[d][i] = SQR(lix[0][1]-lix[dir[i]][1])",
          "5523:       + SQR(lix[0][2]-lix[dir[i]][2]);",
          "5524:      }",
          "5525:    }",
          "5526:    leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),",
          "5527:        MAX(ldiff[1][2],ldiff[1][3]));",
          "5528:    abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),",
          "5529:         MAX(abdiff[1][2],abdiff[1][3]));",
          "5530:    for (d=0; d < 2; d++)",
          "5531:      for (i=0; i < 4; i++)",
          "5532:        if (ldiff[d][i] <= leps && abdiff[d][i] <= abeps)",
          "5533:   homo[d][tr][tc]++;",
          "5534:  }",
          "5535:       }",
          "5537:       for (row=top+3; row < top+TS-3 && row < height-5; row++) {",
          "5538:  tr = row-top;",
          "5539:  for (col=left+3; col < left+TS-3 && col < width-5; col++) {",
          "5540:    tc = col-left;",
          "5541:    for (d=0; d < 2; d++)",
          "5542:      for (hm[d]=0, i=tr-1; i <= tr+1; i++)",
          "5543:        for (j=tc-1; j <= tc+1; j++)",
          "5544:   hm[d] += homo[d][i][j];",
          "5545:    if (hm[0] != hm[1])",
          "5546:      FORC3 image[row*width+col][c] = rgb[hm[1] > hm[0]][tr][tc][c];",
          "5547:    else",
          "5548:      FORC3 image[row*width+col][c] =",
          "5549:   (rgb[0][tr][tc][c] + rgb[1][tr][tc][c]) >> 1;",
          "5550:  }",
          "5551:       }",
          "5552:     }",
          "5553:   free (buffer);",
          "5560:   ushort (*pix)[4];",
          "5563:   { 1,2, 4,5, 7,8, 0,1, 3,4, 6,7, 1,2, 4,5, 7,8,",
          "5564:     0,3, 5,8, 4,7, 3,6, 1,4, 2,5, 4,7, 4,2, 6,4, 4,2 };",
          "5566:   for (pass=1; pass <= med_passes; pass++) {",
          "5568:       RUN_CALLBACK(LIBRAW_PROGRESS_MEDIAN_FILTER,pass-1,med_passes);",
          "5572:       fprintf (stderr,_(\"Median filter pass %d...\\n\"), pass);",
          "5574:     for (c=0; c < 3; c+=2) {",
          "5575:       for (pix = image; pix < image+width*height; pix++)",
          "5576:  pix[0][3] = pix[0][c];",
          "5577:       for (pix = image+width; pix < image+width*(height-1); pix++) {",
          "5578:  if ((pix-image+1) % width < 2) continue;",
          "5579:  for (k=0, i = -width; i <= width; i += width)",
          "5580:    for (j = i-1; j <= i+1; j++)",
          "5581:      med[k++] = pix[j][3] - pix[j][1];",
          "5582:  for (i=0; i < sizeof opt; i+=2)",
          "5583:    if     (med[opt[i]] > med[opt[i+1]])",
          "5584:      SWAP (med[opt[i]] , med[opt[i+1]]);",
          "5585:  pix[0][c] = CLIP(med[4] + pix[0][1]);",
          "",
          "[Added Lines]",
          "6162:   static const int dir[4] = {-1, 1, -TS, TS};",
          "6164:   ushort(*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];",
          "6165:   short(*lab)[TS][TS][3], (*lix)[3];",
          "6166:   char(*homo)[TS][TS], *buffer;",
          "6169:   if (verbose)",
          "6170:     fprintf(stderr, _(\"AHD interpolation...\\n\"));",
          "6173:   cielab(0, 0);",
          "6175:   buffer = (char *)malloc(26 * TS * TS);",
          "6176:   merror(buffer, \"ahd_interpolate()\");",
          "6177:   rgb = (ushort(*)[TS][TS][3])buffer;",
          "6178:   lab = (short(*)[TS][TS][3])(buffer + 12 * TS * TS);",
          "6179:   homo = (char(*)[TS][TS])(buffer + 24 * TS * TS);",
          "6181:   for (top = 2; top < height - 5; top += TS - 6)",
          "6182:     for (left = 2; left < width - 5; left += TS - 6)",
          "6183:     {",
          "6186:       for (row = top; row < top + TS && row < height - 2; row++)",
          "6187:       {",
          "6188:         col = left + (FC(row, left) & 1);",
          "6189:         for (c = FC(row, col); col < left + TS && col < width - 2; col += 2)",
          "6190:         {",
          "6191:           pix = image + row * width + col;",
          "6192:           val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2 - pix[-2][c] - pix[2][c]) >> 2;",
          "6193:           rgb[0][row - top][col - left][1] = ULIM(val, pix[-1][1], pix[1][1]);",
          "6194:           val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2 - pix[-2 * width][c] - pix[2 * width][c]) >> 2;",
          "6195:           rgb[1][row - top][col - left][1] = ULIM(val, pix[-width][1], pix[width][1]);",
          "6196:         }",
          "6197:       }",
          "6200:       for (d = 0; d < 2; d++)",
          "6201:         for (row = top + 1; row < top + TS - 1 && row < height - 3; row++)",
          "6202:           for (col = left + 1; col < left + TS - 1 && col < width - 3; col++)",
          "6203:           {",
          "6204:             pix = image + row * width + col;",
          "6205:             rix = &rgb[d][row - top][col - left];",
          "6206:             lix = &lab[d][row - top][col - left];",
          "6207:             if ((c = 2 - FC(row, col)) == 1)",
          "6208:             {",
          "6209:               c = FC(row + 1, col);",
          "6210:               val = pix[0][1] + ((pix[-1][2 - c] + pix[1][2 - c] - rix[-1][1] - rix[1][1]) >> 1);",
          "6211:               rix[0][2 - c] = CLIP(val);",
          "6212:               val = pix[0][1] + ((pix[-width][c] + pix[width][c] - rix[-TS][1] - rix[TS][1]) >> 1);",
          "6213:             }",
          "6214:             else",
          "6215:               val = rix[0][1] + ((pix[-width - 1][c] + pix[-width + 1][c] + pix[+width - 1][c] + pix[+width + 1][c] -",
          "6216:                                   rix[-TS - 1][1] - rix[-TS + 1][1] - rix[+TS - 1][1] - rix[+TS + 1][1] + 1) >>",
          "6217:                                  2);",
          "6218:             rix[0][c] = CLIP(val);",
          "6219:             c = FC(row, col);",
          "6220:             rix[0][c] = pix[0][c];",
          "6221:             cielab(rix[0], lix[0]);",
          "6222:           }",
          "6224:       memset(homo, 0, 2 * TS * TS);",
          "6225:       for (row = top + 2; row < top + TS - 2 && row < height - 4; row++)",
          "6226:       {",
          "6227:         tr = row - top;",
          "6228:         for (col = left + 2; col < left + TS - 2 && col < width - 4; col++)",
          "6229:         {",
          "6230:           tc = col - left;",
          "6231:           for (d = 0; d < 2; d++)",
          "6232:           {",
          "6233:             lix = &lab[d][tr][tc];",
          "6234:             for (i = 0; i < 4; i++)",
          "6235:             {",
          "6236:               ldiff[d][i] = ABS(lix[0][0] - lix[dir[i]][0]);",
          "6237:               abdiff[d][i] = SQR(lix[0][1] - lix[dir[i]][1]) + SQR(lix[0][2] - lix[dir[i]][2]);",
          "6238:             }",
          "6239:           }",
          "6240:           leps = MIN(MAX(ldiff[0][0], ldiff[0][1]), MAX(ldiff[1][2], ldiff[1][3]));",
          "6241:           abeps = MIN(MAX(abdiff[0][0], abdiff[0][1]), MAX(abdiff[1][2], abdiff[1][3]));",
          "6242:           for (d = 0; d < 2; d++)",
          "6243:             for (i = 0; i < 4; i++)",
          "6244:               if (ldiff[d][i] <= leps && abdiff[d][i] <= abeps)",
          "6245:                 homo[d][tr][tc]++;",
          "6246:         }",
          "6247:       }",
          "6249:       for (row = top + 3; row < top + TS - 3 && row < height - 5; row++)",
          "6250:       {",
          "6251:         tr = row - top;",
          "6252:         for (col = left + 3; col < left + TS - 3 && col < width - 5; col++)",
          "6253:         {",
          "6254:           tc = col - left;",
          "6255:           for (d = 0; d < 2; d++)",
          "6256:             for (hm[d] = 0, i = tr - 1; i <= tr + 1; i++)",
          "6257:               for (j = tc - 1; j <= tc + 1; j++)",
          "6258:                 hm[d] += homo[d][i][j];",
          "6259:           if (hm[0] != hm[1])",
          "6260:             FORC3 image[row * width + col][c] = rgb[hm[1] > hm[0]][tr][tc][c];",
          "6261:           else",
          "6262:             FORC3 image[row * width + col][c] = (rgb[0][tr][tc][c] + rgb[1][tr][tc][c]) >> 1;",
          "6263:         }",
          "6264:       }",
          "6265:     }",
          "6266:   free(buffer);",
          "6273:   ushort(*pix)[4];",
          "6276:       {1, 2, 4, 5, 7, 8, 0, 1, 3, 4, 6, 7, 1, 2, 4, 5, 7, 8, 0,",
          "6277:        3, 5, 8, 4, 7, 3, 6, 1, 4, 2, 5, 4, 7, 4, 2, 6, 4, 4, 2};",
          "6279:   for (pass = 1; pass <= med_passes; pass++)",
          "6280:   {",
          "6282:     RUN_CALLBACK(LIBRAW_PROGRESS_MEDIAN_FILTER, pass - 1, med_passes);",
          "6286:       fprintf(stderr, _(\"Median filter pass %d...\\n\"), pass);",
          "6288:     for (c = 0; c < 3; c += 2)",
          "6289:     {",
          "6290:       for (pix = image; pix < image + width * height; pix++)",
          "6291:         pix[0][3] = pix[0][c];",
          "6292:       for (pix = image + width; pix < image + width * (height - 1); pix++)",
          "6293:       {",
          "6294:         if ((pix - image + 1) % width < 2)",
          "6295:           continue;",
          "6296:         for (k = 0, i = -width; i <= width; i += width)",
          "6297:           for (j = i - 1; j <= i + 1; j++)",
          "6298:             med[k++] = pix[j][3] - pix[j][1];",
          "6299:         for (i = 0; i < sizeof opt; i += 2)",
          "6300:           if (med[opt[i]] > med[opt[i + 1]])",
          "6301:             SWAP(med[opt[i]], med[opt[i + 1]]);",
          "6302:         pix[0][c] = CLIP(med[4] + pix[0][1]);",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "5591: void CLASS blend_highlights()",
          "5592: {",
          "5600:   float cam[2][4], lab[2][4], sum[2], chratio;",
          "5603: #ifdef DCRAW_VERBOSE",
          "5605: #endif",
          "5606: #ifdef LIBRAW_LIBRARY_BUILD",
          "5608: #endif",
          "5617:       }",
          "5623:       }",
          "5630:     }",
          "5631: #ifdef LIBRAW_LIBRARY_BUILD",
          "5633: #endif",
          "5634: }",
          "",
          "[Removed Lines]",
          "5593:   int clip=INT_MAX, row, col, c, i, j;",
          "5594:   static const float trans[2][4][4] =",
          "5595:   { { { 1,1,1 }, { 1.7320508,-1.7320508,0 }, { -1,-1,2 } },",
          "5596:     { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };",
          "5597:   static const float itrans[2][4][4] =",
          "5598:   { { { 1,0.8660254,-0.5 }, { 1,-0.8660254,-0.5 }, { 1,0,1 } },",
          "5599:     { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };",
          "5602:   if ((unsigned) (colors-3) > 1) return;",
          "5604:   if (verbose) fprintf (stderr,_(\"Blending highlights...\\n\"));",
          "5607:   RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,0,2);",
          "5609:   FORCC if (clip > (i = 65535*pre_mul[c])) clip = i;",
          "5610:   for (row=0; row < height; row++)",
          "5611:     for (col=0; col < width; col++) {",
          "5612:       FORCC if (image[row*width+col][c] > clip) break;",
          "5613:       if (c == colors) continue;",
          "5614:       FORCC {",
          "5615:  cam[0][c] = image[row*width+col][c];",
          "5616:  cam[1][c] = MIN(cam[0][c],clip);",
          "5618:       for (i=0; i < 2; i++) {",
          "5619:  FORCC for (lab[i][c]=j=0; j < colors; j++)",
          "5620:    lab[i][c] += trans[colors-3][c][j] * cam[i][j];",
          "5621:  for (sum[i]=0,c=1; c < colors; c++)",
          "5622:    sum[i] += SQR(lab[i][c]);",
          "5624:       chratio = sqrt(sum[1]/sum[0]);",
          "5625:       for (c=1; c < colors; c++)",
          "5626:  lab[0][c] *= chratio;",
          "5627:       FORCC for (cam[0][c]=j=0; j < colors; j++)",
          "5628:  cam[0][c] += itrans[colors-3][c][j] * lab[0][j];",
          "5629:       FORCC image[row*width+col][c] = cam[0][c] / colors;",
          "5632:   RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,1,2);",
          "",
          "[Added Lines]",
          "6310:   int clip = INT_MAX, row, col, c, i, j;",
          "6311:   static const float trans[2][4][4] = {{{1, 1, 1}, {1.7320508, -1.7320508, 0}, {-1, -1, 2}},",
          "6312:                                        {{1, 1, 1, 1}, {1, -1, 1, -1}, {1, 1, -1, -1}, {1, -1, -1, 1}}};",
          "6313:   static const float itrans[2][4][4] = {{{1, 0.8660254, -0.5}, {1, -0.8660254, -0.5}, {1, 0, 1}},",
          "6314:                                         {{1, 1, 1, 1}, {1, -1, 1, -1}, {1, 1, -1, -1}, {1, -1, -1, 1}}};",
          "6317:   if ((unsigned)(colors - 3) > 1)",
          "6318:     return;",
          "6320:   if (verbose)",
          "6321:     fprintf(stderr, _(\"Blending highlights...\\n\"));",
          "6324:   RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, 0, 2);",
          "6326:   FORCC if (clip > (i = 65535 * pre_mul[c])) clip = i;",
          "6327:   for (row = 0; row < height; row++)",
          "6328:     for (col = 0; col < width; col++)",
          "6329:     {",
          "6330:       FORCC if (image[row * width + col][c] > clip) break;",
          "6331:       if (c == colors)",
          "6332:         continue;",
          "6333:       FORCC",
          "6334:       {",
          "6335:         cam[0][c] = image[row * width + col][c];",
          "6336:         cam[1][c] = MIN(cam[0][c], clip);",
          "6338:       for (i = 0; i < 2; i++)",
          "6339:       {",
          "6340:         FORCC for (lab[i][c] = j = 0; j < colors; j++) lab[i][c] += trans[colors - 3][c][j] * cam[i][j];",
          "6341:         for (sum[i] = 0, c = 1; c < colors; c++)",
          "6342:           sum[i] += SQR(lab[i][c]);",
          "6344:       chratio = sqrt(sum[1] / sum[0]);",
          "6345:       for (c = 1; c < colors; c++)",
          "6346:         lab[0][c] *= chratio;",
          "6347:       FORCC for (cam[0][c] = j = 0; j < colors; j++) cam[0][c] += itrans[colors - 3][c][j] * lab[0][j];",
          "6348:       FORCC image[row * width + col][c] = cam[0][c] / colors;",
          "6351:   RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, 1, 2);",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "5640:   int hsat[4], count, spread, change, val, i;",
          "5641:   unsigned high, wide, mrow, mcol, row, col, kc, c, d, y, x;",
          "5642:   ushort *pixel;",
          "5646: #ifdef DCRAW_VERBOSE",
          "5648: #endif",
          "5651:   FORCC hsat[c] = 32000 * pre_mul[c];",
          "5654:   high = height / SCALE;",
          "5716: }",
          "5717: #undef SCALE",
          "5721: {",
          "5728: }",
          "5731: {",
          "5732:   unsigned entries, tag, type, len, save;",
          "5734:   entries = get2();",
          "5740:   }",
          "5741: }",
          "5753: #ifdef LIBRAW_LIBRARY_BUILD",
          "5756:   float t;",
          "5758:     t = ceilf(x);",
          "5760:     return t;",
          "5762:     t = ceilf(-x);",
          "5764:     return -t;",
          "5765:   }",
          "5766: }",
          "5768: static float _CanonConvertAperture(ushort in)",
          "5769: {",
          "5772: }",
          "5775: {",
          "5795: }",
          "5864: {",
          "5866:   CameraInfo[0] = 0;",
          "5867:   CameraInfo[1] = 0;",
          "5869:   case 0x80000001: // 1D",
          "5870:   case 0x80000167: // 1DS",
          "5871:     iCanonCurFocal = 10;",
          "",
          "[Removed Lines]",
          "5643:   static const signed char dir[8][2] =",
          "5644:     { {-1,-1}, {-1,0}, {-1,1}, {0,1}, {1,1}, {1,0}, {1,-1}, {0,-1} };",
          "5647:   if (verbose) fprintf (stderr,_(\"Rebuilding highlights...\\n\"));",
          "5650:   grow = pow (2.0, 4-highlight);",
          "5652:   for (kc=0, c=1; c < colors; c++)",
          "5653:     if (pre_mul[kc] < pre_mul[c]) kc = c;",
          "5655:   wide =  width / SCALE;",
          "5656:   map = (float *) calloc (high, wide*sizeof *map);",
          "5657:   merror (map, \"recover_highlights()\");",
          "5658:   FORCC if (c != kc) {",
          "5659: #ifdef LIBRAW_LIBRARY_BUILD",
          "5660:       RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,c-1,colors-1);",
          "5661: #endif",
          "5662:     memset (map, 0, high*wide*sizeof *map);",
          "5663:     for (mrow=0; mrow < high; mrow++)",
          "5664:       for (mcol=0; mcol < wide; mcol++) {",
          "5665:  sum = wgt = count = 0;",
          "5666:  for (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)",
          "5667:    for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {",
          "5668:      pixel = image[row*width+col];",
          "5669:      if (pixel[c] / hsat[c] == 1 && pixel[kc] > 24000) {",
          "5670:        sum += pixel[c];",
          "5671:        wgt += pixel[kc];",
          "5672:        count++;",
          "5673:      }",
          "5674:    }",
          "5675:  if (count == SCALE*SCALE)",
          "5676:    map[mrow*wide+mcol] = sum / wgt;",
          "5677:       }",
          "5678:     for (spread = 32/grow; spread--; ) {",
          "5679:       for (mrow=0; mrow < high; mrow++)",
          "5680:  for (mcol=0; mcol < wide; mcol++) {",
          "5681:    if (map[mrow*wide+mcol]) continue;",
          "5682:    sum = count = 0;",
          "5683:    for (d=0; d < 8; d++) {",
          "5684:      y = mrow + dir[d][0];",
          "5685:      x = mcol + dir[d][1];",
          "5686:      if (y < high && x < wide && map[y*wide+x] > 0) {",
          "5687:        sum  += (1 + (d & 1)) * map[y*wide+x];",
          "5688:        count += 1 + (d & 1);",
          "5689:      }",
          "5690:    }",
          "5691:    if (count > 3)",
          "5692:      map[mrow*wide+mcol] = - (sum+grow) / (count+grow);",
          "5693:  }",
          "5694:       for (change=i=0; i < high*wide; i++)",
          "5695:  if (map[i] < 0) {",
          "5696:    map[i] = -map[i];",
          "5697:    change = 1;",
          "5698:  }",
          "5699:       if (!change) break;",
          "5700:     }",
          "5701:     for (i=0; i < high*wide; i++)",
          "5702:       if (map[i] == 0) map[i] = 1;",
          "5703:     for (mrow=0; mrow < high; mrow++)",
          "5704:       for (mcol=0; mcol < wide; mcol++) {",
          "5705:  for (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)",
          "5706:    for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {",
          "5707:      pixel = image[row*width+col];",
          "5708:      if (pixel[c] / hsat[c] > 1) {",
          "5709:        val = pixel[kc] * map[mrow*wide+mcol];",
          "5710:        if (pixel[c] < val) pixel[c] = CLIP(val);",
          "5711:      }",
          "5712:    }",
          "5713:       }",
          "5714:   }",
          "5715:   free (map);",
          "5719: void CLASS tiff_get (unsigned base,",
          "5720:  unsigned *tag, unsigned *type, unsigned *len, unsigned *save)",
          "5726:   if (*len * (\"11124811248484\"[*type < 14 ? *type:0]-'0') > 4)",
          "5727:     fseek (ifp, get4()+base, SEEK_SET);",
          "5730: void CLASS parse_thumb_note (int base, unsigned toff, unsigned tlen)",
          "5735:   while (entries--) {",
          "5736:     tiff_get (base, &tag, &type, &len, &save);",
          "5737:     if (tag == toff) thumb_offset = get4()+base;",
          "5738:     if (tag == tlen) thumb_length = get4();",
          "5739:     fseek (ifp, save, SEEK_SET);",
          "5743: static float powf_lim(float a, float b, float limup)",
          "5744: {",
          "5745:   return (b>limup || b < -limup)?0.f:powf(a,b);",
          "5746: }",
          "5747: static float powf64(float a, float b)",
          "5748: {",
          "5749:   return powf_lim(a,b,64.f);",
          "5750: }",
          "5755: static float my_roundf(float x) {",
          "5757:   if (x >= 0.0) {",
          "5759:     if (t - x > 0.5) t -= 1.0;",
          "5761:   } else {",
          "5763:     if (t + x > 0.5) t -= 1.0;",
          "5770:   if ((in == (ushort)0xffe0) || (in == (ushort)0x7fff)) return 0.0f;",
          "5771:   return powf64(2.0, in/64.0);",
          "5774: static float _CanonConvertEV (short in)",
          "5776:  short EV, Sign, Frac;",
          "5777:  float Frac_f;",
          "5778:  EV = in;",
          "5779:  if (EV < 0) {",
          "5780:    EV = -EV;",
          "5781:    Sign = -1;",
          "5782:  } else {",
          "5783:    Sign = 1;",
          "5784:  }",
          "5785:  Frac = EV & 0x1f;",
          "5786:  EV -= Frac;   // remove fraction",
          "5788:  if (Frac == 0x0c) {  // convert 1/3 and 2/3 codes",
          "5789:    Frac_f = 32.0f / 3.0f;",
          "5790:  } else if (Frac == 0x14) {",
          "5791:    Frac_f = 64.0f / 3.0f;",
          "5792:  } else Frac_f = (float) Frac;",
          "5794:  return ((float)Sign * ((float)EV + Frac_f))/32.0f;",
          "5797: void CLASS setCanonBodyFeatures (unsigned id)",
          "5798:       {",
          "5799:       imgdata.lens.makernotes.CamID = id;",
          "5800:  if (",
          "5801:             (id == 0x80000001) || // 1D",
          "5802:             (id == 0x80000174) || // 1D2",
          "5803:             (id == 0x80000232) || // 1D2N",
          "5804:             (id == 0x80000169) || // 1D3",
          "5805:             (id == 0x80000281)  // 1D4",
          "5806:             )",
          "5807:           {",
          "5808:             imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSH;",
          "5809:             imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;",
          "5810:           }",
          "5811:         else",
          "5812:           if (",
          "5813:               (id == 0x80000167) || // 1Ds",
          "5814:               (id == 0x80000188) || // 1Ds2",
          "5815:               (id == 0x80000215) || // 1Ds3",
          "5816:               (id == 0x80000269) || // 1DX",
          "5817:               (id == 0x80000328) || // 1DX2",
          "5818:               (id == 0x80000324) || // 1DC",
          "5819:               (id == 0x80000213) || // 5D",
          "5820:               (id == 0x80000218) || // 5D2",
          "5821:               (id == 0x80000285) || // 5D3",
          "5822:               (id == 0x80000349) || // 5D4",
          "5823:               (id == 0x80000382) || // 5DS",
          "5824:               (id == 0x80000401) || // 5DS R",
          "5825:               (id == 0x80000302)  // 6D",
          "5826:               )",
          "5827:             {",
          "5828:               imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;",
          "5829:               imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;",
          "5830:             }",
          "5831:           else",
          "5832:             if (",
          "5833:                 (id == 0x80000331) || // M",
          "5834:                 (id == 0x80000355) || // M2",
          "5835:                 (id == 0x80000374) ||  // M3",
          "5836:                 (id == 0x80000384) ||  // M10",
          "5837:                 (id == 0x80000394)   // M5",
          "5838:                 )",
          "5839:               {",
          "5840:                 imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;",
          "5841:                 imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF_M;",
          "5842:               }",
          "5843:             else",
          "5844:               if (",
          "5845:                   (id == 0x01140000) || // D30",
          "5846:                   (id == 0x01668000) || // D60",
          "5847:                   (id > 0x80000000)",
          "5848:                   )",
          "5849:                 {",
          "5850:                   imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;",
          "5851:                   imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;",
          "5852:                   imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Unknown;",
          "5853:                 }",
          "5854:               else",
          "5855:                 {",
          "5856:                   imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "5857:                   imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "5858:                 }",
          "5860:  return;",
          "5861:       }",
          "5863: void CLASS processCanonCameraInfo (unsigned id, uchar *CameraInfo, unsigned maxlen)",
          "5865:   ushort iCanonLensID = 0, iCanonMaxFocal = 0, iCanonMinFocal = 0, iCanonLens = 0, iCanonCurFocal = 0, iCanonFocalType = 0;",
          "5868:   switch (id) {",
          "",
          "[Added Lines]",
          "6362:   static const signed char dir[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}};",
          "6365:   if (verbose)",
          "6366:     fprintf(stderr, _(\"Rebuilding highlights...\\n\"));",
          "6369:   grow = pow(2.0, 4 - highlight);",
          "6371:   for (kc = 0, c = 1; c < colors; c++)",
          "6372:     if (pre_mul[kc] < pre_mul[c])",
          "6373:       kc = c;",
          "6375:   wide = width / SCALE;",
          "6376:   map = (float *)calloc(high, wide * sizeof *map);",
          "6377:   merror(map, \"recover_highlights()\");",
          "6378:   FORCC if (c != kc)",
          "6379:   {",
          "6380: #ifdef LIBRAW_LIBRARY_BUILD",
          "6381:     RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, c - 1, colors - 1);",
          "6382: #endif",
          "6383:     memset(map, 0, high * wide * sizeof *map);",
          "6384:     for (mrow = 0; mrow < high; mrow++)",
          "6385:       for (mcol = 0; mcol < wide; mcol++)",
          "6386:       {",
          "6387:         sum = wgt = count = 0;",
          "6388:         for (row = mrow * SCALE; row < (mrow + 1) * SCALE; row++)",
          "6389:           for (col = mcol * SCALE; col < (mcol + 1) * SCALE; col++)",
          "6390:           {",
          "6391:             pixel = image[row * width + col];",
          "6392:             if (pixel[c] / hsat[c] == 1 && pixel[kc] > 24000)",
          "6393:             {",
          "6394:               sum += pixel[c];",
          "6395:               wgt += pixel[kc];",
          "6396:               count++;",
          "6397:             }",
          "6398:           }",
          "6399:         if (count == SCALE * SCALE)",
          "6400:           map[mrow * wide + mcol] = sum / wgt;",
          "6401:       }",
          "6402:     for (spread = 32 / grow; spread--;)",
          "6403:     {",
          "6404:       for (mrow = 0; mrow < high; mrow++)",
          "6405:         for (mcol = 0; mcol < wide; mcol++)",
          "6406:         {",
          "6407:           if (map[mrow * wide + mcol])",
          "6408:             continue;",
          "6409:           sum = count = 0;",
          "6410:           for (d = 0; d < 8; d++)",
          "6411:           {",
          "6412:             y = mrow + dir[d][0];",
          "6413:             x = mcol + dir[d][1];",
          "6414:             if (y < high && x < wide && map[y * wide + x] > 0)",
          "6415:             {",
          "6416:               sum += (1 + (d & 1)) * map[y * wide + x];",
          "6417:               count += 1 + (d & 1);",
          "6418:             }",
          "6419:           }",
          "6420:           if (count > 3)",
          "6421:             map[mrow * wide + mcol] = -(sum + grow) / (count + grow);",
          "6422:         }",
          "6423:       for (change = i = 0; i < high * wide; i++)",
          "6424:         if (map[i] < 0)",
          "6425:         {",
          "6426:           map[i] = -map[i];",
          "6427:           change = 1;",
          "6428:         }",
          "6429:       if (!change)",
          "6430:         break;",
          "6431:     }",
          "6432:     for (i = 0; i < high * wide; i++)",
          "6433:       if (map[i] == 0)",
          "6434:         map[i] = 1;",
          "6435:     for (mrow = 0; mrow < high; mrow++)",
          "6436:       for (mcol = 0; mcol < wide; mcol++)",
          "6437:       {",
          "6438:         for (row = mrow * SCALE; row < (mrow + 1) * SCALE; row++)",
          "6439:           for (col = mcol * SCALE; col < (mcol + 1) * SCALE; col++)",
          "6440:           {",
          "6441:             pixel = image[row * width + col];",
          "6442:             if (pixel[c] / hsat[c] > 1)",
          "6443:             {",
          "6444:               val = pixel[kc] * map[mrow * wide + mcol];",
          "6445:               if (pixel[c] < val)",
          "6446:                 pixel[c] = CLIP(val);",
          "6447:             }",
          "6448:           }",
          "6449:       }",
          "6450:   }",
          "6451:   free(map);",
          "6455: void CLASS tiff_get(unsigned base, unsigned *tag, unsigned *type, unsigned *len, unsigned *save)",
          "6461:   if (*len * (\"11124811248484\"[*type < 14 ? *type : 0] - '0') > 4)",
          "6462:     fseek(ifp, get4() + base, SEEK_SET);",
          "6465: void CLASS parse_thumb_note(int base, unsigned toff, unsigned tlen)",
          "6470:   while (entries--)",
          "6471:   {",
          "6472:     tiff_get(base, &tag, &type, &len, &save);",
          "6473:     if (tag == toff)",
          "6474:       thumb_offset = get4() + base;",
          "6475:     if (tag == tlen)",
          "6476:       thumb_length = get4();",
          "6477:     fseek(ifp, save, SEEK_SET);",
          "6481: static float powf_lim(float a, float b, float limup) { return (b > limup || b < -limup) ? 0.f : powf(a, b); }",
          "6482: static float powf64(float a, float b) { return powf_lim(a, b, 64.f); }",
          "6486: static float my_roundf(float x)",
          "6487: {",
          "6489:   if (x >= 0.0)",
          "6490:   {",
          "6492:     if (t - x > 0.5)",
          "6493:       t -= 1.0;",
          "6495:   }",
          "6496:   else",
          "6497:   {",
          "6499:     if (t + x > 0.5)",
          "6500:       t -= 1.0;",
          "6507:   if ((in == (ushort)0xffe0) || (in == (ushort)0x7fff))",
          "6508:     return 0.0f;",
          "6509:   return powf64(2.0, in / 64.0);",
          "6512: static float _CanonConvertEV(short in)",
          "6514:   short EV, Sign, Frac;",
          "6515:   float Frac_f;",
          "6516:   EV = in;",
          "6517:   if (EV < 0)",
          "6518:   {",
          "6519:     EV = -EV;",
          "6520:     Sign = -1;",
          "6521:   }",
          "6522:   else",
          "6523:   {",
          "6524:     Sign = 1;",
          "6525:   }",
          "6526:   Frac = EV & 0x1f;",
          "6527:   EV -= Frac; // remove fraction",
          "6529:   if (Frac == 0x0c)",
          "6530:   { // convert 1/3 and 2/3 codes",
          "6531:     Frac_f = 32.0f / 3.0f;",
          "6532:   }",
          "6533:   else if (Frac == 0x14)",
          "6534:   {",
          "6535:     Frac_f = 64.0f / 3.0f;",
          "6536:   }",
          "6537:   else",
          "6538:     Frac_f = (float)Frac;",
          "6540:   return ((float)Sign * ((float)EV + Frac_f)) / 32.0f;",
          "6543: void CLASS setCanonBodyFeatures(unsigned id)",
          "6544: {",
          "6545:   imgdata.lens.makernotes.CamID = id;",
          "6546:   if ((id == 0x80000001) || // 1D",
          "6547:       (id == 0x80000174) || // 1D2",
          "6548:       (id == 0x80000232) || // 1D2N",
          "6549:       (id == 0x80000169) || // 1D3",
          "6550:       (id == 0x80000281)    // 1D4",
          "6551:       )",
          "6552:   {",
          "6553:     imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSH;",
          "6554:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;",
          "6555:   }",
          "6556:   else if ((id == 0x80000167) || // 1Ds",
          "6557:            (id == 0x80000188) || // 1Ds2",
          "6558:            (id == 0x80000215) || // 1Ds3",
          "6559:            (id == 0x80000269) || // 1DX",
          "6560:            (id == 0x80000328) || // 1DX2",
          "6561:            (id == 0x80000324) || // 1DC",
          "6562:            (id == 0x80000213) || // 5D",
          "6563:            (id == 0x80000218) || // 5D2",
          "6564:            (id == 0x80000285) || // 5D3",
          "6565:            (id == 0x80000349) || // 5D4",
          "6566:            (id == 0x80000382) || // 5DS",
          "6567:            (id == 0x80000401) || // 5DS R",
          "6568:            (id == 0x80000302)    // 6D",
          "6569:            )",
          "6570:   {",
          "6571:     imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;",
          "6572:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;",
          "6573:   }",
          "6574:   else if ((id == 0x80000331) || // M",
          "6575:            (id == 0x80000355) || // M2",
          "6576:            (id == 0x80000374) || // M3",
          "6577:            (id == 0x80000384) || // M10",
          "6578:            (id == 0x80000394)    // M5",
          "6579:            )",
          "6580:   {",
          "6581:     imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;",
          "6582:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF_M;",
          "6583:   }",
          "6584:   else if ((id == 0x01140000) || // D30",
          "6585:            (id == 0x01668000) || // D60",
          "6586:            (id > 0x80000000))",
          "6587:   {",
          "6588:     imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;",
          "6589:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;",
          "6590:     imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Unknown;",
          "6591:   }",
          "6592:   else",
          "6593:   {",
          "6594:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "6595:     imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "6596:   }",
          "6598:   return;",
          "6599: }",
          "6601: void CLASS processCanonCameraInfo(unsigned id, uchar *CameraInfo, unsigned maxlen)",
          "6603:   ushort iCanonLensID = 0, iCanonMaxFocal = 0, iCanonMinFocal = 0, iCanonLens = 0, iCanonCurFocal = 0,",
          "6604:          iCanonFocalType = 0;",
          "6607:   switch (id)",
          "6608:   {",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "5875:     if (!imgdata.lens.makernotes.CurFocal)",
          "5876:       imgdata.lens.makernotes.CurFocal = sget2(CameraInfo + iCanonCurFocal);",
          "5877:     if (!imgdata.lens.makernotes.MinFocal)",
          "5879:     if (!imgdata.lens.makernotes.MaxFocal)",
          "5880:       imgdata.lens.makernotes.MaxFocal = sget2(CameraInfo + iCanonMaxFocal);",
          "5881:     break;",
          "",
          "[Removed Lines]",
          "5878:       imgdata.lens.makernotes.MinFocal  = sget2(CameraInfo + iCanonMinFocal);",
          "",
          "[Added Lines]",
          "6618:       imgdata.lens.makernotes.MinFocal = sget2(CameraInfo + iCanonMinFocal);",
          "",
          "---------------",
          "--- Hunk 69 ---",
          "[Context before]",
          "5914:     break;",
          "5915:   case 0x80000213: // 5D",
          "5916:     iCanonCurFocal = 40;",
          "5919:     iCanonMinFocal = 147;",
          "5920:     iCanonMaxFocal = 149;",
          "5921:     break;",
          "",
          "[Removed Lines]",
          "5917:     if (!sget2Rev(CameraInfo + 12)) iCanonLensID = 151;",
          "5918:     else iCanonLensID = 12;",
          "",
          "[Added Lines]",
          "6657:     if (!sget2Rev(CameraInfo + 12))",
          "6658:       iCanonLensID = 151;",
          "6659:     else",
          "6660:       iCanonLensID = 12;",
          "",
          "---------------",
          "--- Hunk 70 ---",
          "[Context before]",
          "6008:     break;",
          "6009:   }",
          "6010:   if (iCanonFocalType)",
          "6017:   if (!imgdata.lens.makernotes.CurFocal)",
          "6022:   if (!imgdata.lens.makernotes.LensID)",
          "6027:   if (!imgdata.lens.makernotes.MinFocal)",
          "6032:   if (!imgdata.lens.makernotes.MaxFocal)",
          "6033:     {",
          "6036:     }",
          "6043:     else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-S\", 4))",
          "6049:     }",
          "6051:       memcpy(imgdata.lens.makernotes.Lens, \"TS-E \", 5);",
          "6052:       memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"TS-E\", 4);",
          "6053:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "6054:       memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);",
          "6055:     }",
          "6057:       memcpy(imgdata.lens.makernotes.Lens, \"MP-E \", 5);",
          "6058:       memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"MP-E\", 4);",
          "6059:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "6060:       memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);",
          "6061:     }",
          "6063:       memcpy(imgdata.lens.makernotes.Lens, \"EF-M \", 5);",
          "6064:       memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-M\", 4);",
          "6065:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;",
          "6066:       memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);",
          "6067:     }",
          "6069:       memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 2);",
          "6070:       memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF\", 2);",
          "6071:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "",
          "[Removed Lines]",
          "6011:     {",
          "6012:       if(iCanonFocalType>=maxlen) return; // broken;",
          "6013:       imgdata.lens.makernotes.FocalType = CameraInfo[iCanonFocalType];",
          "6014:       if (!imgdata.lens.makernotes.FocalType) // zero means 'fixed' here, replacing with standard '1'",
          "6015:         imgdata.lens.makernotes.FocalType = 1;",
          "6016:     }",
          "6018:     {",
          "6019:       if(iCanonCurFocal>=maxlen) return; // broken;",
          "6020:       imgdata.lens.makernotes.CurFocal = sget2Rev(CameraInfo + iCanonCurFocal);",
          "6021:     }",
          "6023:     {",
          "6024:       if(iCanonLensID>=maxlen) return; // broken;",
          "6025:       imgdata.lens.makernotes.LensID = sget2Rev(CameraInfo + iCanonLensID);",
          "6026:     }",
          "6028:     {",
          "6029:       if(iCanonMinFocal>=maxlen) return; // broken;",
          "6030:       imgdata.lens.makernotes.MinFocal = sget2Rev(CameraInfo + iCanonMinFocal);",
          "6031:     }",
          "6034:       if(iCanonMaxFocal>=maxlen) return; // broken;",
          "6035:       imgdata.lens.makernotes.MaxFocal = sget2Rev(CameraInfo + iCanonMaxFocal);",
          "6037:   if (!imgdata.lens.makernotes.Lens[0] && iCanonLens) {",
          "6038:     if(iCanonLens+64>=maxlen) return; // broken;",
          "6039:     if (CameraInfo[iCanonLens] < 65)        // non-Canon lens",
          "6040:       {",
          "6041:         memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 64);",
          "6042:       }",
          "6044:       {",
          "6045:         memcpy(imgdata.lens.makernotes.Lens, \"EF-S \", 5);",
          "6046:         memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-E\", 4);",
          "6047:         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;",
          "6048:         memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);",
          "6050:     else if (!strncmp((char *)CameraInfo + iCanonLens, \"TS-E\", 4)) {",
          "6056:     else if (!strncmp((char *)CameraInfo + iCanonLens, \"MP-E\", 4)) {",
          "6062:     else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-M\", 4)) {",
          "6068:     else {",
          "",
          "[Added Lines]",
          "6753:   {",
          "6754:     if (iCanonFocalType >= maxlen)",
          "6755:       return; // broken;",
          "6756:     imgdata.lens.makernotes.FocalType = CameraInfo[iCanonFocalType];",
          "6757:     if (!imgdata.lens.makernotes.FocalType) // zero means 'fixed' here, replacing with standard '1'",
          "6758:       imgdata.lens.makernotes.FocalType = 1;",
          "6759:   }",
          "6761:   {",
          "6762:     if (iCanonCurFocal >= maxlen)",
          "6763:       return; // broken;",
          "6764:     imgdata.lens.makernotes.CurFocal = sget2Rev(CameraInfo + iCanonCurFocal);",
          "6765:   }",
          "6767:   {",
          "6768:     if (iCanonLensID >= maxlen)",
          "6769:       return; // broken;",
          "6770:     imgdata.lens.makernotes.LensID = sget2Rev(CameraInfo + iCanonLensID);",
          "6771:   }",
          "6773:   {",
          "6774:     if (iCanonMinFocal >= maxlen)",
          "6775:       return; // broken;",
          "6776:     imgdata.lens.makernotes.MinFocal = sget2Rev(CameraInfo + iCanonMinFocal);",
          "6777:   }",
          "6779:   {",
          "6780:     if (iCanonMaxFocal >= maxlen)",
          "6781:       return; // broken;",
          "6782:     imgdata.lens.makernotes.MaxFocal = sget2Rev(CameraInfo + iCanonMaxFocal);",
          "6783:   }",
          "6784:   if (!imgdata.lens.makernotes.Lens[0] && iCanonLens)",
          "6785:   {",
          "6786:     if (iCanonLens + 64 >= maxlen)",
          "6787:       return;                        // broken;",
          "6788:     if (CameraInfo[iCanonLens] < 65) // non-Canon lens",
          "6790:       memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 64);",
          "6793:     {",
          "6794:       memcpy(imgdata.lens.makernotes.Lens, \"EF-S \", 5);",
          "6795:       memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-E\", 4);",
          "6796:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;",
          "6797:       memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);",
          "6799:     else if (!strncmp((char *)CameraInfo + iCanonLens, \"TS-E\", 4))",
          "6800:     {",
          "6806:     else if (!strncmp((char *)CameraInfo + iCanonLens, \"MP-E\", 4))",
          "6807:     {",
          "6813:     else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-M\", 4))",
          "6814:     {",
          "6820:     else",
          "6821:     {",
          "",
          "---------------",
          "--- Hunk 71 ---",
          "[Context before]",
          "6076:   return;",
          "6077: }",
          "6080: {",
          "6081:   fseek(ifp, 10, SEEK_CUR);",
          "6083:   imgdata.shootinginfo.FocusMode = get2();",
          "6084:   fseek(ifp, 18, SEEK_CUR);",
          "6086:   imgdata.shootinginfo.AFPoint = get2();",
          "6088:   imgdata.lens.makernotes.LensID = get2();",
          "6089:   imgdata.lens.makernotes.MaxFocal = get2();",
          "6090:   imgdata.lens.makernotes.MinFocal = get2();",
          "6091:   imgdata.lens.makernotes.CanonFocalUnits = get2();",
          "6092:   if (imgdata.lens.makernotes.CanonFocalUnits > 1)",
          "6097:   imgdata.lens.makernotes.MaxAp = _CanonConvertAperture(get2());",
          "6098:   imgdata.lens.makernotes.MinAp = _CanonConvertAperture(get2());",
          "6099:   fseek(ifp, 12, SEEK_CUR);",
          "6100:   imgdata.shootinginfo.ImageStabilization = get2();",
          "6101: }",
          "6104: {",
          "6105:   int c;",
          "6106:   FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();",
          "6108:   FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();",
          "6110:   FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();",
          "6112:   FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();",
          "6114:   FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();",
          "6116:   FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();",
          "6117:   return;",
          "6118: }",
          "6169: {",
          "6172:     {",
          "6177:     {",
          "6180:     }",
          "6182:   if (imgdata.lens.nikon.NikonLensType & 0x02)",
          "6191:   if (imgdata.lens.nikon.NikonLensType & 0x08)",
          "6197:   if (imgdata.lens.nikon.NikonLensType & 0x10)",
          "6198:   {",
          "",
          "[Removed Lines]",
          "6079: void CLASS Canon_CameraSettings ()",
          "6082:   imgdata.shootinginfo.DriveMode = get2(); get2();",
          "6085:   imgdata.shootinginfo.MeteringMode = get2(); get2();",
          "6087:   imgdata.shootinginfo.ExposureMode = get2(); get2();",
          "6093:     {",
          "6094:       imgdata.lens.makernotes.MaxFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "6095:       imgdata.lens.makernotes.MinFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "6096:     }",
          "6103: void CLASS Canon_WBpresets (int skip1, int skip2)",
          "6107:   if (skip1) fseek(ifp, skip1, SEEK_CUR);",
          "6109:   if (skip1) fseek(ifp, skip1, SEEK_CUR);",
          "6111:   if (skip1) fseek(ifp, skip1, SEEK_CUR);",
          "6113:   if (skip1) fseek(ifp, skip1, SEEK_CUR);",
          "6115:   if (skip2) fseek(ifp, skip2, SEEK_CUR);",
          "6120: void CLASS Canon_WBCTpresets (short WBCTversion)",
          "6121: {",
          "6122:  if (WBCTversion == 0)",
          "6123:    for (int i=0; i<15; i++)// tint, as shot R, as shot B, C\u0421T",
          "6124:      {",
          "6125:   imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;",
          "6126:   fseek (ifp, 2, SEEK_CUR);",
          "6127:   imgdata.color.WBCT_Coeffs[i][1] = 1024.0f /fMAX(get2(),1.f) ;",
          "6128:   imgdata.color.WBCT_Coeffs[i][3] = 1024.0f /fMAX(get2(),1.f);",
          "6129:   imgdata.color.WBCT_Coeffs[i][0] = get2();",
          "6130:      }",
          "6131:  else if (WBCTversion == 1)",
          "6132:    for (int i=0; i<15; i++) // as shot R, as shot B, tint, C\u0421T",
          "6133:      {",
          "6134:   imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;",
          "6135:   imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(get2(),1.f);",
          "6136:   imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(get2(),1.f);",
          "6137:   fseek (ifp, 2, SEEK_CUR);",
          "6138:   imgdata.color.WBCT_Coeffs[i][0] = get2();",
          "6139:      }",
          "6140:  else if ((WBCTversion == 2) &&",
          "6141:   ((unique_id == 0x80000374) || // M3",
          "6142:    (unique_id == 0x80000384) || // M10",
          "6143:    (unique_id == 0x80000394) || // M5",
          "6144:    (unique_id == 0x03970000))) // G7 X Mark II",
          "6145:    for (int i=0; i<15; i++) // tint, offset, as shot R, as shot B, C\u0421T",
          "6146:      {",
          "6147:   fseek (ifp, 2, SEEK_CUR);",
          "6148:   fseek (ifp, 2, SEEK_CUR);",
          "6149:   imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;",
          "6150:   imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(1.f,get2());",
          "6151:   imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(1.f,get2());",
          "6152:   imgdata.color.WBCT_Coeffs[i][0] = get2();",
          "6153:      }",
          "6154:  else if ((WBCTversion == 2) &&",
          "6155:                 ((unique_id == 0x03950000) || (unique_id == 0x03930000))) // G5 X, G9 X",
          "6156:    for (int i=0; i<15; i++) // tint, offset, as shot R, as shot B, C\u0421T",
          "6157:      {",
          "6158:   fseek (ifp, 2, SEEK_CUR);",
          "6159:   fseek (ifp, 2, SEEK_CUR);",
          "6160:   imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;",
          "6161:   imgdata.color.WBCT_Coeffs[i][1] = (float)get2() / 512.0f;",
          "6162:   imgdata.color.WBCT_Coeffs[i][3] = (float)get2() / 512.0f;",
          "6163:   imgdata.color.WBCT_Coeffs[i][0] = get2();",
          "6164:      }",
          "6165:  return;",
          "6166: }",
          "6168: void CLASS processNikonLensData (uchar *LensData, unsigned len)",
          "6170:   ushort i;",
          "6171:   if (!(imgdata.lens.nikon.NikonLensType & 0x01))",
          "6173:       imgdata.lens.makernotes.LensFeatures_pre[0] = 'A';",
          "6174:       imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';",
          "6175:     }",
          "6176:   else",
          "6178:       imgdata.lens.makernotes.LensFeatures_pre[0] = 'M';",
          "6179:       imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';",
          "6183:     {",
          "6184:       if (imgdata.lens.nikon.NikonLensType & 0x04)",
          "6185:         imgdata.lens.makernotes.LensFeatures_suf[0] = 'G';",
          "6186:       else",
          "6187:         imgdata.lens.makernotes.LensFeatures_suf[0] = 'D';",
          "6188:       imgdata.lens.makernotes.LensFeatures_suf[1] = ' ';",
          "6189:     }",
          "6192:     {",
          "6193:       imgdata.lens.makernotes.LensFeatures_suf[2] = 'V';",
          "6194:       imgdata.lens.makernotes.LensFeatures_suf[3] = 'R';",
          "6195:     }",
          "",
          "[Added Lines]",
          "6832: void CLASS Canon_CameraSettings()",
          "6835:   imgdata.shootinginfo.DriveMode = get2();",
          "6836:   get2();",
          "6839:   imgdata.shootinginfo.MeteringMode = get2();",
          "6840:   get2();",
          "6842:   imgdata.shootinginfo.ExposureMode = get2();",
          "6843:   get2();",
          "6849:   {",
          "6850:     imgdata.lens.makernotes.MaxFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "6851:     imgdata.lens.makernotes.MinFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "6852:   }",
          "6859: void CLASS Canon_WBpresets(int skip1, int skip2)",
          "6863:   if (skip1)",
          "6864:     fseek(ifp, skip1, SEEK_CUR);",
          "6866:   if (skip1)",
          "6867:     fseek(ifp, skip1, SEEK_CUR);",
          "6869:   if (skip1)",
          "6870:     fseek(ifp, skip1, SEEK_CUR);",
          "6872:   if (skip1)",
          "6873:     fseek(ifp, skip1, SEEK_CUR);",
          "6875:   if (skip2)",
          "6876:     fseek(ifp, skip2, SEEK_CUR);",
          "6881: void CLASS Canon_WBCTpresets(short WBCTversion)",
          "6883:   if (WBCTversion == 0)",
          "6884:     for (int i = 0; i < 15; i++) // tint, as shot R, as shot B, C\u0421T",
          "6886:       imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;",
          "6887:       fseek(ifp, 2, SEEK_CUR);",
          "6888:       imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(get2(), 1.f);",
          "6889:       imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(get2(), 1.f);",
          "6890:       imgdata.color.WBCT_Coeffs[i][0] = get2();",
          "6891:     }",
          "6892:   else if (WBCTversion == 1)",
          "6893:     for (int i = 0; i < 15; i++) // as shot R, as shot B, tint, C\u0421T",
          "6894:     {",
          "6895:       imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;",
          "6896:       imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(get2(), 1.f);",
          "6897:       imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(get2(), 1.f);",
          "6898:       fseek(ifp, 2, SEEK_CUR);",
          "6899:       imgdata.color.WBCT_Coeffs[i][0] = get2();",
          "6900:     }",
          "6901:   else if ((WBCTversion == 2) && ((unique_id == 0x80000374) || // M3",
          "6902:                                   (unique_id == 0x80000384) || // M10",
          "6903:                                   (unique_id == 0x80000394) || // M5",
          "6904:                                   (unique_id == 0x03970000)))  // G7 X Mark II",
          "6905:     for (int i = 0; i < 15; i++)                               // tint, offset, as shot R, as shot B, C\u0421T",
          "6907:       fseek(ifp, 2, SEEK_CUR);",
          "6908:       fseek(ifp, 2, SEEK_CUR);",
          "6909:       imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;",
          "6910:       imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(1.f, get2());",
          "6911:       imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(1.f, get2());",
          "6912:       imgdata.color.WBCT_Coeffs[i][0] = get2();",
          "6913:     }",
          "6914:   else if ((WBCTversion == 2) && ((unique_id == 0x03950000) || (unique_id == 0x03930000))) // G5 X, G9 X",
          "6915:     for (int i = 0; i < 15; i++) // tint, offset, as shot R, as shot B, C\u0421T",
          "6916:     {",
          "6917:       fseek(ifp, 2, SEEK_CUR);",
          "6918:       fseek(ifp, 2, SEEK_CUR);",
          "6919:       imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;",
          "6920:       imgdata.color.WBCT_Coeffs[i][1] = (float)get2() / 512.0f;",
          "6921:       imgdata.color.WBCT_Coeffs[i][3] = (float)get2() / 512.0f;",
          "6922:       imgdata.color.WBCT_Coeffs[i][0] = get2();",
          "6924:   return;",
          "6925: }",
          "6927: void CLASS processNikonLensData(uchar *LensData, unsigned len)",
          "6928: {",
          "6929:   ushort i;",
          "6930:   if (!(imgdata.lens.nikon.NikonLensType & 0x01))",
          "6931:   {",
          "6932:     imgdata.lens.makernotes.LensFeatures_pre[0] = 'A';",
          "6933:     imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';",
          "6934:   }",
          "6935:   else",
          "6936:   {",
          "6937:     imgdata.lens.makernotes.LensFeatures_pre[0] = 'M';",
          "6938:     imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';",
          "6939:   }",
          "6942:   {",
          "6943:     if (imgdata.lens.nikon.NikonLensType & 0x04)",
          "6944:       imgdata.lens.makernotes.LensFeatures_suf[0] = 'G';",
          "6945:     else",
          "6946:       imgdata.lens.makernotes.LensFeatures_suf[0] = 'D';",
          "6947:     imgdata.lens.makernotes.LensFeatures_suf[1] = ' ';",
          "6948:   }",
          "6951:   {",
          "6952:     imgdata.lens.makernotes.LensFeatures_suf[2] = 'V';",
          "6953:     imgdata.lens.makernotes.LensFeatures_suf[3] = 'R';",
          "6954:   }",
          "",
          "---------------",
          "--- Hunk 72 ---",
          "[Context before]",
          "6213:   imgdata.lens.nikon.NikonLensType = imgdata.lens.nikon.NikonLensType & 0xdf;",
          "6217:     case 9:",
          "6218:       i = 2;",
          "6219:       break;",
          "",
          "[Removed Lines]",
          "6215:   if (len < 20) {",
          "6216:     switch (len) {",
          "",
          "[Added Lines]",
          "6974:   if (len < 20)",
          "6975:   {",
          "6976:     switch (len)",
          "6977:     {",
          "",
          "---------------",
          "--- Hunk 73 ---",
          "[Context before]",
          "6226:     }",
          "6227:     imgdata.lens.nikon.NikonLensIDNumber = LensData[i];",
          "6228:     imgdata.lens.nikon.NikonLensFStops = LensData[i + 1];",
          "6230:     if (fabsf(imgdata.lens.makernotes.MinFocal) < 1.1f)",
          "6231:     {",
          "6232:       if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 2])",
          "",
          "[Removed Lines]",
          "6229:     imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops /12.0f;",
          "",
          "[Added Lines]",
          "6990:     imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops / 12.0f;",
          "",
          "---------------",
          "--- Hunk 74 ---",
          "[Context before]",
          "6240:     }",
          "6241:     imgdata.lens.nikon.NikonMCUVersion = LensData[i + 6];",
          "6242:     if (i != 2)",
          "6249:     imgdata.lens.makernotes.LensID =",
          "6259:   }",
          "6260:   else if ((len == 459) || (len == 590))",
          "6264:   else if (len == 509)",
          "6268:   else if (len == 879)",
          "6272:   return;",
          "6273: }",
          "6276: {",
          "6277:   imgdata.lens.makernotes.CamID = id;",
          "6280:       ((id & 0x00ffff0000ULL) == 0x0030300000ULL))",
          "6281:   {",
          "6297:   }",
          "6298:   else",
          "6299:   {",
          "6302:   }",
          "6303:   return;",
          "6304: }",
          "6396:       {",
          "6585:       }",
          "6586: }",
          "6589: {",
          "6590:   imgdata.lens.makernotes.CamID = id;",
          "6593:   case 0x12994:",
          "6594:   case 0x12aa2:",
          "6595:   case 0x12b1a:",
          "",
          "[Removed Lines]",
          "6243:       {",
          "6244:         if ((LensData[i - 1]) &&",
          "6245:             (fabsf(imgdata.lens.makernotes.CurFocal) < 1.1f))",
          "6246:           imgdata.lens.makernotes.CurFocal = 5.0f * powf64(2.0f, (float)LensData[i - 1] / 24.0f);",
          "6247:         if (LensData[i + 7]) imgdata.lens.nikon.NikonEffectiveMaxAp = powf64(2.0f, (float)LensData[i + 7] / 24.0f);",
          "6248:       }",
          "6250:       (unsigned long long) LensData[i] << 56 |",
          "6251:       (unsigned long long) LensData[i + 1] << 48 |",
          "6252:       (unsigned long long) LensData[i + 2] << 40 |",
          "6253:       (unsigned long long) LensData[i + 3] << 32 |",
          "6254:       (unsigned long long) LensData[i + 4] << 24 |",
          "6255:       (unsigned long long) LensData[i + 5] << 16 |",
          "6256:       (unsigned long long) LensData[i + 6] << 8 |",
          "6257:       (unsigned long long) imgdata.lens.nikon.NikonLensType;",
          "6261:     {",
          "6262:       memcpy(imgdata.lens.makernotes.Lens, LensData + 390, 64);",
          "6263:     }",
          "6265:     {",
          "6266:       memcpy(imgdata.lens.makernotes.Lens, LensData + 391, 64);",
          "6267:     }",
          "6269:     {",
          "6270:       memcpy(imgdata.lens.makernotes.Lens, LensData + 680, 64);",
          "6271:     }",
          "6275: void CLASS setOlympusBodyFeatures (unsigned long long id)",
          "6278:   if ((id == 0x4434303430ULL) || // E-1",
          "6279:       (id == 0x4434303431ULL) || // E-300",
          "6282:       imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FT;",
          "6283:    if ((id == 0x4434303430ULL) || // E-1",
          "6284:          (id == 0x4434303431ULL) || // E-330",
          "6285:          ((id >= 0x5330303033ULL) && (id <= 0x5330303138ULL)) || // E-330 to E-520",
          "6286:          (id == 0x5330303233ULL) || // E-620",
          "6287:          (id == 0x5330303239ULL) || // E-450",
          "6288:          (id == 0x5330303330ULL) || // E-600",
          "6289:          (id == 0x5330303333ULL))  // E-5",
          "6290:       {",
          "6291:        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FT;",
          "6292:       }",
          "6293:    else",
          "6294:       {",
          "6295:         imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_mFT;",
          "6296:       }",
          "6300:       imgdata.lens.makernotes.LensMount =",
          "6301:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "6306: void CLASS parseCanonMakernotes (unsigned tag, unsigned type, unsigned len) {",
          "6308: if (tag == 0x0001) Canon_CameraSettings();",
          "6309:         else if (tag == 0x0002)   // focal length",
          "6310:           {",
          "6311:             imgdata.lens.makernotes.FocalType = get2();",
          "6312:             imgdata.lens.makernotes.CurFocal = get2();",
          "6313:             if (imgdata.lens.makernotes.CanonFocalUnits > 1)",
          "6314:               {",
          "6315:                 imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "6316:               }",
          "6317:           }",
          "6319:         else if (tag == 0x0004)   // shot info",
          "6320:           {",
          "6321:             short tempAp;",
          "6322:             fseek(ifp, 30, SEEK_CUR);",
          "6323:             imgdata.other.FlashEC = _CanonConvertEV((signed short)get2());",
          "6324:             fseek(ifp, 8-32, SEEK_CUR);",
          "6325:             if ((tempAp = get2()) != 0x7fff)",
          "6326:               imgdata.lens.makernotes.CurAp = _CanonConvertAperture(tempAp);",
          "6327:             if (imgdata.lens.makernotes.CurAp < 0.7f)",
          "6328:             {",
          "6329:               fseek(ifp, 32, SEEK_CUR);",
          "6330:               imgdata.lens.makernotes.CurAp = _CanonConvertAperture(get2());",
          "6331:             }",
          "6332:             if (!aperture) aperture = imgdata.lens.makernotes.CurAp;",
          "6333:           }",
          "6335:         else if (tag == 0x0095 &&  // lens model tag",
          "6336:                  !imgdata.lens.makernotes.Lens[0])",
          "6337:           {",
          "6338:             fread(imgdata.lens.makernotes.Lens, 2, 1, ifp);",
          "6339:             imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "6340:             if (imgdata.lens.makernotes.Lens[0] < 65)     // non-Canon lens",
          "6341:               fread(imgdata.lens.makernotes.Lens + 2, 62, 1, ifp);",
          "6342:             else",
          "6343:               {",
          "6344:                 char efs[2];",
          "6345:                 imgdata.lens.makernotes.LensFeatures_pre[0] = imgdata.lens.makernotes.Lens[0];",
          "6346:                 imgdata.lens.makernotes.LensFeatures_pre[1] = imgdata.lens.makernotes.Lens[1];",
          "6347:                 fread(efs, 2, 1, ifp);",
          "6348:                 if (efs[0] == 45 && (efs[1] == 83 || efs[1] == 69 || efs[1] == 77))",
          "6349:                   { // \"EF-S, TS-E, MP-E, EF-M\" lenses",
          "6350:                     imgdata.lens.makernotes.Lens[2] = imgdata.lens.makernotes.LensFeatures_pre[2] = efs[0];",
          "6351:                     imgdata.lens.makernotes.Lens[3] = imgdata.lens.makernotes.LensFeatures_pre[3] = efs[1];",
          "6352:                     imgdata.lens.makernotes.Lens[4] = 32;",
          "6353:                     if (efs[1] == 83)",
          "6354:                       {",
          "6355:                         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;",
          "6356:                         imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;",
          "6357:                       }",
          "6358:                     else if (efs[1] == 77)",
          "6359:                       {",
          "6360:                         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;",
          "6361:                       }",
          "6362:                   }",
          "6363:                 else",
          "6364:                   {                // \"EF\" lenses",
          "6365:                     imgdata.lens.makernotes.Lens[2] = 32;",
          "6366:                     imgdata.lens.makernotes.Lens[3] = efs[0];",
          "6367:                     imgdata.lens.makernotes.Lens[4] = efs[1];",
          "6368:                   }",
          "6369:                 fread(imgdata.lens.makernotes.Lens + 5, 58, 1, ifp);",
          "6370:               }",
          "6371:           }",
          "6373:         else if (tag == 0x00a9)",
          "6374:           {",
          "6375:             long int save1 = ftell(ifp);",
          "6376:             fseek (ifp, save1+(0x5<<1), SEEK_SET);",
          "6377:             Canon_WBpresets(0,0);",
          "6378:             fseek (ifp, save1, SEEK_SET);",
          "6379:           }",
          "6381:         else if (tag == 0x00e0)   // sensor info",
          "6382:           {",
          "6383:             imgdata.makernotes.canon.SensorWidth           = (get2(),get2());",
          "6384:             imgdata.makernotes.canon.SensorHeight          = get2();",
          "6385:             imgdata.makernotes.canon.SensorLeftBorder      = (get2(),get2(),get2());",
          "6386:             imgdata.makernotes.canon.SensorTopBorder       = get2();",
          "6387:             imgdata.makernotes.canon.SensorRightBorder     = get2();",
          "6388:             imgdata.makernotes.canon.SensorBottomBorder    = get2();",
          "6389:             imgdata.makernotes.canon.BlackMaskLeftBorder   = get2();",
          "6390:             imgdata.makernotes.canon.BlackMaskTopBorder    = get2();",
          "6391:             imgdata.makernotes.canon.BlackMaskRightBorder  = get2();",
          "6392:             imgdata.makernotes.canon.BlackMaskBottomBorder = get2();",
          "6393:           }",
          "6395:     else if (tag == 0x4001 && len > 500)",
          "6397:         int c;",
          "6398:         long int save1 = ftell(ifp);",
          "6399:         switch (len)",
          "6400:           {",
          "6401:           case 582:",
          "6402:             imgdata.makernotes.canon.CanonColorDataVer = 1; // 20D / 350D",
          "6403:             {",
          "6404:              fseek (ifp, save1+(0x23<<1), SEEK_SET);",
          "6405:              Canon_WBpresets(2,2);",
          "6406:              fseek (ifp, save1+(0x4b<<1), SEEK_SET);",
          "6407:                Canon_WBCTpresets (1); // ABCT",
          "6408:             }",
          "6409:             break;",
          "6410:           case 653:",
          "6411:             imgdata.makernotes.canon.CanonColorDataVer = 2; // 1Dmk2 / 1DsMK2",
          "6412:             {",
          "6413:              fseek (ifp, save1+(0x27<<1), SEEK_SET);",
          "6414:              Canon_WBpresets(2,12);",
          "6415:              fseek (ifp, save1+(0xa4<<1), SEEK_SET);",
          "6416:                Canon_WBCTpresets (1); // ABCT",
          "6417:             }",
          "6418:             break;",
          "6419:           case 796:",
          "6420:             imgdata.makernotes.canon.CanonColorDataVer = 3; // 1DmkIIN / 5D / 30D / 400D",
          "6421:      imgdata.makernotes.canon.CanonColorDataSubVer = get2();",
          "6422:      {",
          "6423:        fseek (ifp, save1+(0x4e<<1), SEEK_SET);",
          "6424:        Canon_WBpresets(2,12);",
          "6425:        fseek (ifp, save1+(0x85<<1), SEEK_SET);",
          "6426:        Canon_WBCTpresets (0); // BCAT",
          "6427:        fseek (ifp, save1+(0x0c4<<1), SEEK_SET); // offset 196 short",
          "6428:        int bls=0;",
          "6429:        FORC4",
          "6430:   bls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());",
          "6431:        imgdata.makernotes.canon.AverageBlackLevel = bls/4;",
          "6432:      }",
          "6433:      break;",
          "6437:           case 674: case 692: case 702: case 1227: case 1250:",
          "6438:           case 1251: case 1337: case 1338: case 1346:",
          "6439:             imgdata.makernotes.canon.CanonColorDataVer = 4;",
          "6440:             imgdata.makernotes.canon.CanonColorDataSubVer = get2();",
          "6441:             {",
          "6442:        fseek (ifp, save1+(0x53<<1), SEEK_SET);",
          "6443:        Canon_WBpresets(2,12);",
          "6444:        fseek (ifp, save1+(0xa8<<1), SEEK_SET);",
          "6445:        Canon_WBCTpresets (0); // BCAT",
          "6446:               fseek (ifp, save1+(0x0e7<<1), SEEK_SET); // offset 231 short",
          "6447:               int bls=0;",
          "6448:               FORC4",
          "6449:   bls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());",
          "6450:               imgdata.makernotes.canon.AverageBlackLevel = bls/4;",
          "6451:             }",
          "6452:             if ((imgdata.makernotes.canon.CanonColorDataSubVer == 4)",
          "6453:                 || (imgdata.makernotes.canon.CanonColorDataSubVer == 5))",
          "6454:               {",
          "6455:                 fseek (ifp, save1+(0x2b9<<1), SEEK_SET);  // offset 697 shorts",
          "6456:                 imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "6457:                 FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "6458:               }",
          "6459:             else if ((imgdata.makernotes.canon.CanonColorDataSubVer == 6) ||",
          "6460:                      (imgdata.makernotes.canon.CanonColorDataSubVer == 7))",
          "6461:               {",
          "6462:                 fseek (ifp, save1+(0x2d0<<1), SEEK_SET);  // offset 720 shorts",
          "6463:                 imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "6464:                 FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "6465:               }",
          "6466:             else if (imgdata.makernotes.canon.CanonColorDataSubVer == 9)",
          "6467:               {",
          "6468:                 fseek (ifp, save1+(0x2d4<<1), SEEK_SET);  // offset 724 shorts",
          "6469:                 imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "6470:                 FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "6471:               }",
          "6472:             break;",
          "6474:           case 5120:",
          "6475:             imgdata.makernotes.canon.CanonColorDataVer = 5; // PowerSot G10, G12, G5 X, EOS M3, EOS M5",
          "6476:             {",
          "6477:               fseek (ifp, save1+(0x56<<1), SEEK_SET);",
          "6478:               if ((unique_id == 0x03970000) || // G7 X Mark II",
          "6479:                   (unique_id == 0x80000394))   // EOS M5",
          "6480:               {",
          "6481:                 fseek(ifp, 18, SEEK_CUR);",
          "6482:                 FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();",
          "6483:                 fseek(ifp, 8, SEEK_CUR);",
          "6484:                 Canon_WBpresets(8,24);",
          "6485:                 fseek(ifp, 168, SEEK_CUR);",
          "6486:                 FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ (c >> 1)] = get2();",
          "6487:                 fseek(ifp, 24, SEEK_CUR);",
          "6488:                 Canon_WBCTpresets (2);  // BCADT",
          "6489:                 fseek(ifp, 6, SEEK_CUR);",
          "6490:               }",
          "6491:               else",
          "6492:               {",
          "6493:                 FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();",
          "6494:                 get2();",
          "6495:                 Canon_WBpresets(2,12);",
          "6496:                 fseek (ifp, save1+(0xba<<1), SEEK_SET);",
          "6497:                 Canon_WBCTpresets (2);  // BCADT",
          "6498:                 fseek (ifp, save1+(0x108<<1), SEEK_SET);  // offset 264 short",
          "6499:               }",
          "6500:               int bls=0;",
          "6501:               FORC4",
          "6502:   bls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());",
          "6503:               imgdata.makernotes.canon.AverageBlackLevel = bls/4;",
          "6504:             }",
          "6505:             break;",
          "6507:           case 1273: case 1275:",
          "6508:             imgdata.makernotes.canon.CanonColorDataVer = 6; // 600D / 1200D",
          "6509:             imgdata.makernotes.canon.CanonColorDataSubVer = get2();",
          "6510:             {",
          "6511:               fseek (ifp, save1+(0x67<<1), SEEK_SET);",
          "6512:               Canon_WBpresets(2,12);",
          "6513:               fseek (ifp, save1+(0xbc<<1), SEEK_SET);",
          "6514:               Canon_WBCTpresets (0); // BCAT",
          "6515:               fseek (ifp, save1+(0x0fb<<1), SEEK_SET);   // offset 251 short",
          "6516:               int bls=0;",
          "6517:               FORC4",
          "6518:   bls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());",
          "6519:               imgdata.makernotes.canon.AverageBlackLevel = bls/4;",
          "6520:             }",
          "6521:             fseek (ifp, save1+(0x1e4<<1), SEEK_SET);   // offset 484 shorts",
          "6522:             imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "6523:             FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "6524:             break;",
          "6527:           case 1312: case 1313: case 1316: case 1506:",
          "6528:             imgdata.makernotes.canon.CanonColorDataVer = 7;",
          "6529:             imgdata.makernotes.canon.CanonColorDataSubVer = get2();",
          "6530:             {",
          "6531:               fseek (ifp, save1+(0x80<<1), SEEK_SET);",
          "6532:               Canon_WBpresets(2,12);",
          "6533:               fseek (ifp, save1+(0xd5<<1), SEEK_SET);",
          "6534:               Canon_WBCTpresets (0); // BCAT",
          "6535:               fseek (ifp, save1+(0x114<<1), SEEK_SET);   // offset 276 shorts",
          "6536:               int bls=0;",
          "6537:               FORC4",
          "6538:   bls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());",
          "6539:               imgdata.makernotes.canon.AverageBlackLevel = bls/4;",
          "6540:             }",
          "6541:             if (imgdata.makernotes.canon.CanonColorDataSubVer == 10)",
          "6542:               {",
          "6543:                 fseek (ifp, save1+(0x1fd<<1), SEEK_SET);  // offset 509 shorts",
          "6544:                 imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "6545:                 FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "6546:               } else if (imgdata.makernotes.canon.CanonColorDataSubVer == 11)",
          "6547:               {",
          "6548:                 fseek (ifp, save1+(0x2dd<<1), SEEK_SET);  // offset 733 shorts",
          "6549:                 imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "6550:                 FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "6551:               }",
          "6552:             break;",
          "6555:           case 1560: case 1592: case 1353:",
          "6556:             imgdata.makernotes.canon.CanonColorDataVer = 8;",
          "6557:             imgdata.makernotes.canon.CanonColorDataSubVer = get2();",
          "6558:             {",
          "6559:               fseek (ifp, save1+(0x85<<1), SEEK_SET);",
          "6560:               Canon_WBpresets(2,12);",
          "6561:               fseek (ifp, save1+(0x107<<1), SEEK_SET);",
          "6562:               Canon_WBCTpresets (0); // BCAT",
          "6563:               fseek (ifp, save1+(0x146<<1), SEEK_SET);   // offset 326 shorts",
          "6564:               int bls=0;",
          "6565:               FORC4",
          "6566:   bls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());",
          "6567:               imgdata.makernotes.canon.AverageBlackLevel = bls/4;",
          "6568:             }",
          "6569:               if (imgdata.makernotes.canon.CanonColorDataSubVer == 14)  // 1300D",
          "6570:                 {",
          "6571:                   fseek (ifp, save1+(0x231<<1), SEEK_SET);",
          "6572:                   imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "6573:                   FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "6574:                 }",
          "6575:               else",
          "6576:                 {",
          "6577:                   fseek (ifp, save1+(0x30f<<1), SEEK_SET);  // offset 783 shorts",
          "6578:                   imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "6579:                   FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "6580:                 }",
          "6581:             break;",
          "6583:           }",
          "6584:         fseek (ifp, save1, SEEK_SET);",
          "6588: void CLASS setPentaxBodyFeatures (unsigned id)",
          "6592:   switch (id) {",
          "",
          "[Added Lines]",
          "7004:     {",
          "7005:       if ((LensData[i - 1]) && (fabsf(imgdata.lens.makernotes.CurFocal) < 1.1f))",
          "7006:         imgdata.lens.makernotes.CurFocal = 5.0f * powf64(2.0f, (float)LensData[i - 1] / 24.0f);",
          "7007:       if (LensData[i + 7])",
          "7008:         imgdata.lens.nikon.NikonEffectiveMaxAp = powf64(2.0f, (float)LensData[i + 7] / 24.0f);",
          "7009:     }",
          "7011:         (unsigned long long)LensData[i] << 56 | (unsigned long long)LensData[i + 1] << 48 |",
          "7012:         (unsigned long long)LensData[i + 2] << 40 | (unsigned long long)LensData[i + 3] << 32 |",
          "7013:         (unsigned long long)LensData[i + 4] << 24 | (unsigned long long)LensData[i + 5] << 16 |",
          "7014:         (unsigned long long)LensData[i + 6] << 8 | (unsigned long long)imgdata.lens.nikon.NikonLensType;",
          "7017:   {",
          "7018:     memcpy(imgdata.lens.makernotes.Lens, LensData + 390, 64);",
          "7019:   }",
          "7021:   {",
          "7022:     memcpy(imgdata.lens.makernotes.Lens, LensData + 391, 64);",
          "7023:   }",
          "7025:   {",
          "7026:     memcpy(imgdata.lens.makernotes.Lens, LensData + 680, 64);",
          "7027:   }",
          "7031: void CLASS setOlympusBodyFeatures(unsigned long long id)",
          "7034:   if ((id == 0x4434303430ULL) || // E-1",
          "7035:       (id == 0x4434303431ULL) || // E-300",
          "7038:     imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FT;",
          "7039:     if ((id == 0x4434303430ULL) ||                              // E-1",
          "7040:         (id == 0x4434303431ULL) ||                              // E-330",
          "7041:         ((id >= 0x5330303033ULL) && (id <= 0x5330303138ULL)) || // E-330 to E-520",
          "7042:         (id == 0x5330303233ULL) ||                              // E-620",
          "7043:         (id == 0x5330303239ULL) ||                              // E-450",
          "7044:         (id == 0x5330303330ULL) ||                              // E-600",
          "7045:         (id == 0x5330303333ULL))                                // E-5",
          "7046:     {",
          "7047:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FT;",
          "7048:     }",
          "7049:     else",
          "7050:     {",
          "7051:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_mFT;",
          "7052:     }",
          "7056:     imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "7061: void CLASS parseCanonMakernotes(unsigned tag, unsigned type, unsigned len)",
          "7062: {",
          "7064:   if (tag == 0x0001)",
          "7065:     Canon_CameraSettings();",
          "7066:   else if (tag == 0x0002) // focal length",
          "7067:   {",
          "7068:     imgdata.lens.makernotes.FocalType = get2();",
          "7069:     imgdata.lens.makernotes.CurFocal = get2();",
          "7070:     if (imgdata.lens.makernotes.CanonFocalUnits > 1)",
          "7071:     {",
          "7072:       imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "7073:     }",
          "7074:   }",
          "7076:   else if (tag == 0x0004) // shot info",
          "7077:   {",
          "7078:     short tempAp;",
          "7079:     fseek(ifp, 30, SEEK_CUR);",
          "7080:     imgdata.other.FlashEC = _CanonConvertEV((signed short)get2());",
          "7081:     fseek(ifp, 8 - 32, SEEK_CUR);",
          "7082:     if ((tempAp = get2()) != 0x7fff)",
          "7083:       imgdata.lens.makernotes.CurAp = _CanonConvertAperture(tempAp);",
          "7084:     if (imgdata.lens.makernotes.CurAp < 0.7f)",
          "7085:     {",
          "7086:       fseek(ifp, 32, SEEK_CUR);",
          "7087:       imgdata.lens.makernotes.CurAp = _CanonConvertAperture(get2());",
          "7088:     }",
          "7089:     if (!aperture)",
          "7090:       aperture = imgdata.lens.makernotes.CurAp;",
          "7091:   }",
          "7093:   else if (tag == 0x0095 && // lens model tag",
          "7094:            !imgdata.lens.makernotes.Lens[0])",
          "7095:   {",
          "7096:     fread(imgdata.lens.makernotes.Lens, 2, 1, ifp);",
          "7097:     imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "7098:     if (imgdata.lens.makernotes.Lens[0] < 65) // non-Canon lens",
          "7099:       fread(imgdata.lens.makernotes.Lens + 2, 62, 1, ifp);",
          "7100:     else",
          "7101:     {",
          "7102:       char efs[2];",
          "7103:       imgdata.lens.makernotes.LensFeatures_pre[0] = imgdata.lens.makernotes.Lens[0];",
          "7104:       imgdata.lens.makernotes.LensFeatures_pre[1] = imgdata.lens.makernotes.Lens[1];",
          "7105:       fread(efs, 2, 1, ifp);",
          "7106:       if (efs[0] == 45 && (efs[1] == 83 || efs[1] == 69 || efs[1] == 77))",
          "7107:       { // \"EF-S, TS-E, MP-E, EF-M\" lenses",
          "7108:         imgdata.lens.makernotes.Lens[2] = imgdata.lens.makernotes.LensFeatures_pre[2] = efs[0];",
          "7109:         imgdata.lens.makernotes.Lens[3] = imgdata.lens.makernotes.LensFeatures_pre[3] = efs[1];",
          "7110:         imgdata.lens.makernotes.Lens[4] = 32;",
          "7111:         if (efs[1] == 83)",
          "7112:         {",
          "7113:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;",
          "7114:           imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;",
          "7115:         }",
          "7116:         else if (efs[1] == 77)",
          "7117:         {",
          "7118:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;",
          "7119:         }",
          "7120:       }",
          "7121:       else",
          "7122:       { // \"EF\" lenses",
          "7123:         imgdata.lens.makernotes.Lens[2] = 32;",
          "7124:         imgdata.lens.makernotes.Lens[3] = efs[0];",
          "7125:         imgdata.lens.makernotes.Lens[4] = efs[1];",
          "7126:       }",
          "7127:       fread(imgdata.lens.makernotes.Lens + 5, 58, 1, ifp);",
          "7128:     }",
          "7129:   }",
          "7131:   else if (tag == 0x00a9)",
          "7132:   {",
          "7133:     long int save1 = ftell(ifp);",
          "7134:     fseek(ifp, save1 + (0x5 << 1), SEEK_SET);",
          "7135:     Canon_WBpresets(0, 0);",
          "7136:     fseek(ifp, save1, SEEK_SET);",
          "7137:   }",
          "7139:   else if (tag == 0x00e0) // sensor info",
          "7140:   {",
          "7141:     imgdata.makernotes.canon.SensorWidth = (get2(), get2());",
          "7142:     imgdata.makernotes.canon.SensorHeight = get2();",
          "7143:     imgdata.makernotes.canon.SensorLeftBorder = (get2(), get2(), get2());",
          "7144:     imgdata.makernotes.canon.SensorTopBorder = get2();",
          "7145:     imgdata.makernotes.canon.SensorRightBorder = get2();",
          "7146:     imgdata.makernotes.canon.SensorBottomBorder = get2();",
          "7147:     imgdata.makernotes.canon.BlackMaskLeftBorder = get2();",
          "7148:     imgdata.makernotes.canon.BlackMaskTopBorder = get2();",
          "7149:     imgdata.makernotes.canon.BlackMaskRightBorder = get2();",
          "7150:     imgdata.makernotes.canon.BlackMaskBottomBorder = get2();",
          "7151:   }",
          "7153:   else if (tag == 0x4001 && len > 500)",
          "7154:   {",
          "7155:     int c;",
          "7156:     long int save1 = ftell(ifp);",
          "7157:     switch (len)",
          "7158:     {",
          "7159:     case 582:",
          "7160:       imgdata.makernotes.canon.CanonColorDataVer = 1; // 20D / 350D",
          "7162:         fseek(ifp, save1 + (0x23 << 1), SEEK_SET);",
          "7163:         Canon_WBpresets(2, 2);",
          "7164:         fseek(ifp, save1 + (0x4b << 1), SEEK_SET);",
          "7165:         Canon_WBCTpresets(1); // ABCT",
          "7166:       }",
          "7167:       break;",
          "7168:     case 653:",
          "7169:       imgdata.makernotes.canon.CanonColorDataVer = 2; // 1Dmk2 / 1DsMK2",
          "7170:       {",
          "7171:         fseek(ifp, save1 + (0x27 << 1), SEEK_SET);",
          "7172:         Canon_WBpresets(2, 12);",
          "7173:         fseek(ifp, save1 + (0xa4 << 1), SEEK_SET);",
          "7174:         Canon_WBCTpresets(1); // ABCT",
          "7175:       }",
          "7176:       break;",
          "7177:     case 796:",
          "7178:       imgdata.makernotes.canon.CanonColorDataVer = 3; // 1DmkIIN / 5D / 30D / 400D",
          "7179:       imgdata.makernotes.canon.CanonColorDataSubVer = get2();",
          "7180:       {",
          "7181:         fseek(ifp, save1 + (0x4e << 1), SEEK_SET);",
          "7182:         Canon_WBpresets(2, 12);",
          "7183:         fseek(ifp, save1 + (0x85 << 1), SEEK_SET);",
          "7184:         Canon_WBCTpresets(0);                       // BCAT",
          "7185:         fseek(ifp, save1 + (0x0c4 << 1), SEEK_SET); // offset 196 short",
          "7186:         int bls = 0;",
          "7187:         FORC4",
          "7188:         bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());",
          "7189:         imgdata.makernotes.canon.AverageBlackLevel = bls / 4;",
          "7190:       }",
          "7191:       break;",
          "7195:     case 674:",
          "7196:     case 692:",
          "7197:     case 702:",
          "7198:     case 1227:",
          "7199:     case 1250:",
          "7200:     case 1251:",
          "7201:     case 1337:",
          "7202:     case 1338:",
          "7203:     case 1346:",
          "7204:       imgdata.makernotes.canon.CanonColorDataVer = 4;",
          "7205:       imgdata.makernotes.canon.CanonColorDataSubVer = get2();",
          "7206:       {",
          "7207:         fseek(ifp, save1 + (0x53 << 1), SEEK_SET);",
          "7208:         Canon_WBpresets(2, 12);",
          "7209:         fseek(ifp, save1 + (0xa8 << 1), SEEK_SET);",
          "7210:         Canon_WBCTpresets(0);                       // BCAT",
          "7211:         fseek(ifp, save1 + (0x0e7 << 1), SEEK_SET); // offset 231 short",
          "7212:         int bls = 0;",
          "7213:         FORC4",
          "7214:         bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());",
          "7215:         imgdata.makernotes.canon.AverageBlackLevel = bls / 4;",
          "7216:       }",
          "7217:       if ((imgdata.makernotes.canon.CanonColorDataSubVer == 4) || (imgdata.makernotes.canon.CanonColorDataSubVer == 5))",
          "7218:       {",
          "7219:         fseek(ifp, save1 + (0x2b9 << 1), SEEK_SET); // offset 697 shorts",
          "7220:         imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "7221:         FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "7222:       }",
          "7223:       else if ((imgdata.makernotes.canon.CanonColorDataSubVer == 6) ||",
          "7224:                (imgdata.makernotes.canon.CanonColorDataSubVer == 7))",
          "7225:       {",
          "7226:         fseek(ifp, save1 + (0x2d0 << 1), SEEK_SET); // offset 720 shorts",
          "7227:         imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "7228:         FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "7229:       }",
          "7230:       else if (imgdata.makernotes.canon.CanonColorDataSubVer == 9)",
          "7231:       {",
          "7232:         fseek(ifp, save1 + (0x2d4 << 1), SEEK_SET); // offset 724 shorts",
          "7233:         imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "7234:         FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "7235:       }",
          "7236:       break;",
          "7238:     case 5120:",
          "7239:       imgdata.makernotes.canon.CanonColorDataVer = 5; // PowerSot G10, G12, G5 X, EOS M3, EOS M5",
          "7240:       {",
          "7241:         fseek(ifp, save1 + (0x56 << 1), SEEK_SET);",
          "7242:         if ((unique_id == 0x03970000) || // G7 X Mark II",
          "7243:             (unique_id == 0x80000394))   // EOS M5",
          "7244:         {",
          "7245:           fseek(ifp, 18, SEEK_CUR);",
          "7246:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();",
          "7247:           fseek(ifp, 8, SEEK_CUR);",
          "7248:           Canon_WBpresets(8, 24);",
          "7249:           fseek(ifp, 168, SEEK_CUR);",
          "7250:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ (c >> 1)] = get2();",
          "7251:           fseek(ifp, 24, SEEK_CUR);",
          "7252:           Canon_WBCTpresets(2); // BCADT",
          "7253:           fseek(ifp, 6, SEEK_CUR);",
          "7254:         }",
          "7255:         else",
          "7256:         {",
          "7257:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();",
          "7258:           get2();",
          "7259:           Canon_WBpresets(2, 12);",
          "7260:           fseek(ifp, save1 + (0xba << 1), SEEK_SET);",
          "7261:           Canon_WBCTpresets(2);                       // BCADT",
          "7262:           fseek(ifp, save1 + (0x108 << 1), SEEK_SET); // offset 264 short",
          "7263:         }",
          "7264:         int bls = 0;",
          "7265:         FORC4",
          "7266:         bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());",
          "7267:         imgdata.makernotes.canon.AverageBlackLevel = bls / 4;",
          "7268:       }",
          "7269:       break;",
          "7271:     case 1273:",
          "7272:     case 1275:",
          "7273:       imgdata.makernotes.canon.CanonColorDataVer = 6; // 600D / 1200D",
          "7274:       imgdata.makernotes.canon.CanonColorDataSubVer = get2();",
          "7275:       {",
          "7276:         fseek(ifp, save1 + (0x67 << 1), SEEK_SET);",
          "7277:         Canon_WBpresets(2, 12);",
          "7278:         fseek(ifp, save1 + (0xbc << 1), SEEK_SET);",
          "7279:         Canon_WBCTpresets(0);                       // BCAT",
          "7280:         fseek(ifp, save1 + (0x0fb << 1), SEEK_SET); // offset 251 short",
          "7281:         int bls = 0;",
          "7282:         FORC4",
          "7283:         bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());",
          "7284:         imgdata.makernotes.canon.AverageBlackLevel = bls / 4;",
          "7285:       }",
          "7286:       fseek(ifp, save1 + (0x1e4 << 1), SEEK_SET); // offset 484 shorts",
          "7287:       imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "7288:       FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "7289:       break;",
          "7292:     case 1312:",
          "7293:     case 1313:",
          "7294:     case 1316:",
          "7295:     case 1506:",
          "7296:       imgdata.makernotes.canon.CanonColorDataVer = 7;",
          "7297:       imgdata.makernotes.canon.CanonColorDataSubVer = get2();",
          "7298:       {",
          "7299:         fseek(ifp, save1 + (0x80 << 1), SEEK_SET);",
          "7300:         Canon_WBpresets(2, 12);",
          "7301:         fseek(ifp, save1 + (0xd5 << 1), SEEK_SET);",
          "7302:         Canon_WBCTpresets(0);                       // BCAT",
          "7303:         fseek(ifp, save1 + (0x114 << 1), SEEK_SET); // offset 276 shorts",
          "7304:         int bls = 0;",
          "7305:         FORC4",
          "7306:         bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());",
          "7307:         imgdata.makernotes.canon.AverageBlackLevel = bls / 4;",
          "7308:       }",
          "7309:       if (imgdata.makernotes.canon.CanonColorDataSubVer == 10)",
          "7310:       {",
          "7311:         fseek(ifp, save1 + (0x1fd << 1), SEEK_SET); // offset 509 shorts",
          "7312:         imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "7313:         FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "7314:       }",
          "7315:       else if (imgdata.makernotes.canon.CanonColorDataSubVer == 11)",
          "7316:       {",
          "7317:         fseek(ifp, save1 + (0x2dd << 1), SEEK_SET); // offset 733 shorts",
          "7318:         imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "7319:         FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "7320:       }",
          "7321:       break;",
          "7324:     case 1560:",
          "7325:     case 1592:",
          "7326:     case 1353:",
          "7327:       imgdata.makernotes.canon.CanonColorDataVer = 8;",
          "7328:       imgdata.makernotes.canon.CanonColorDataSubVer = get2();",
          "7329:       {",
          "7330:         fseek(ifp, save1 + (0x85 << 1), SEEK_SET);",
          "7331:         Canon_WBpresets(2, 12);",
          "7332:         fseek(ifp, save1 + (0x107 << 1), SEEK_SET);",
          "7333:         Canon_WBCTpresets(0);                       // BCAT",
          "7334:         fseek(ifp, save1 + (0x146 << 1), SEEK_SET); // offset 326 shorts",
          "7335:         int bls = 0;",
          "7336:         FORC4",
          "7337:         bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());",
          "7338:         imgdata.makernotes.canon.AverageBlackLevel = bls / 4;",
          "7339:       }",
          "7340:       if (imgdata.makernotes.canon.CanonColorDataSubVer == 14) // 1300D",
          "7341:       {",
          "7342:         fseek(ifp, save1 + (0x231 << 1), SEEK_SET);",
          "7343:         imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "7344:         FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "7345:       }",
          "7346:       else",
          "7347:       {",
          "7348:         fseek(ifp, save1 + (0x30f << 1), SEEK_SET); // offset 783 shorts",
          "7349:         imgdata.makernotes.canon.SpecularWhiteLevel = get2();",
          "7350:         FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;",
          "7352:       break;",
          "7353:     }",
          "7354:     fseek(ifp, save1, SEEK_SET);",
          "7355:   }",
          "7358: void CLASS setPentaxBodyFeatures(unsigned id)",
          "7362:   switch (id)",
          "7363:   {",
          "",
          "---------------",
          "--- Hunk 75 ---",
          "[Context before]",
          "6652:   return;",
          "6653: }",
          "6656: {",
          "6660:   int i;",
          "6663:       iso_speed = value[i];",
          "6664:       return;",
          "6665:     }",
          "6666:   }",
          "6668: }",
          "6669: #undef numel",
          "6918:   }",
          "7097:     {",
          "7101:     }",
          "7110:     {",
          "7113:       {",
          "7121:         break;",
          "7126:         break;",
          "7128:       }",
          "7129:     }",
          "7133:     {",
          "7136:     }",
          "7137:   return;",
          "7138: }",
          "7144:   ushort features;",
          "7147:   if ((imgdata.lens.makernotes.LensMount == LIBRAW_MOUNT_Canon_EF) ||",
          "7150:     return;",
          "7152:   imgdata.lens.makernotes.LensFeatures_pre[0] = 0;",
          "7153:   imgdata.lens.makernotes.LensFeatures_suf[0] = 0;",
          "7158:   if (!imgdata.lens.makernotes.LensFormat && !imgdata.lens.makernotes.LensMount)",
          "7171:     }",
          "7173:   if (features & 0x4000)",
          "7174:     strnXcat(imgdata.lens.makernotes.LensFeatures_pre, \" PZ\");",
          "",
          "[Removed Lines]",
          "6655: void CLASS PentaxISO (ushort c)",
          "6657:   int code [] = {3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 50, 100, 200, 400, 800, 1600, 3200, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278};",
          "6658:   double value []  = {50, 64, 80, 100, 125, 160, 200, 250, 320, 400, 500, 640, 800, 1000, 1250, 1600, 2000, 2500, 3200, 4000, 5000, 6400, 8000, 10000, 12800, 16000, 20000, 25600, 32000, 40000, 51200, 64000, 80000, 102400, 128000, 160000, 204800, 50, 100, 200, 400, 800, 1600, 3200, 50, 70, 100, 140, 200, 280, 400, 560, 800, 1100, 1600, 2200, 3200, 4500, 6400, 9000, 12800, 18000, 25600, 36000, 51200};",
          "6659: #define numel (sizeof(code)/sizeof(code[0]))",
          "6661:   for (i = 0; i < numel; i++) {",
          "6662:     if (code[i] == c) {",
          "6667:   if (i == numel) iso_speed = 65535.0f;",
          "6671: void CLASS PentaxLensInfo (unsigned id, unsigned len) // tag 0x0207",
          "6672: {",
          "6673:  ushort iLensData = 0;",
          "6674:  uchar *table_buf;",
          "6675:  table_buf = (uchar*)malloc(MAX(len,128));",
          "6676:  fread(table_buf, len, 1, ifp);",
          "6677:  if ((id < 0x12b9c)  ||",
          "6678:         (((id == 0x12b9c)   ||  // K100D",
          "6679:           (id == 0x12b9d)   ||  // K110D",
          "6680:           (id == 0x12ba2)) &&   // K100D Super",
          "6681:    ((!table_buf[20] ||",
          "6682:     (table_buf[20] == 0xff)))))",
          "6683:    {",
          "6684:   iLensData = 3;",
          "6685:   if (imgdata.lens.makernotes.LensID == -1)",
          "6686:     imgdata.lens.makernotes.LensID =",
          "6687:    (((unsigned)table_buf[0]) << 8) + table_buf[1];",
          "6688:    }",
          "6689:  else switch (len)",
          "6690:    {",
          "6691:    case 90:       // LensInfo3",
          "6692:   iLensData = 13;",
          "6693:   if (imgdata.lens.makernotes.LensID == -1)",
          "6694:     imgdata.lens.makernotes.LensID =",
          "6695:    ((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) <<8) + table_buf[4];",
          "6696:   break;",
          "6697:    case 91:       // LensInfo4",
          "6698:   iLensData = 12;",
          "6699:   if (imgdata.lens.makernotes.LensID == -1)",
          "6700:     imgdata.lens.makernotes.LensID =",
          "6701:    ((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) <<8) + table_buf[4];",
          "6702:   break;",
          "6703:    case 80:       // LensInfo5",
          "6704:    case 128:",
          "6705:   iLensData = 15;",
          "6706:   if (imgdata.lens.makernotes.LensID == -1)",
          "6707:     imgdata.lens.makernotes.LensID =",
          "6708:    ((unsigned)((table_buf[1] & 0x0f) + table_buf[4]) <<8) + table_buf[5];",
          "6709:   break;",
          "6710:    default:",
          "6711:   if (id >= 0x12b9c)    // LensInfo2",
          "6712:     {",
          "6713:    iLensData = 4;",
          "6714:    if (imgdata.lens.makernotes.LensID == -1)",
          "6715:      imgdata.lens.makernotes.LensID =",
          "6716:     ((unsigned)((table_buf[0] & 0x0f) + table_buf[2]) <<8) + table_buf[3];",
          "6717:     }",
          "6718:    }",
          "6719:  if (iLensData)",
          "6720:    {",
          "6721:   if (table_buf[iLensData+9] &&",
          "6722:    (fabs(imgdata.lens.makernotes.CurFocal) < 0.1f))",
          "6723:     imgdata.lens.makernotes.CurFocal =",
          "6724:    10*(table_buf[iLensData+9]>>2) * powf64(4, (table_buf[iLensData+9] & 0x03)-2);",
          "6725:   if (table_buf[iLensData+10] & 0xf0)",
          "6726:     imgdata.lens.makernotes.MaxAp4CurFocal =",
          "6727:    powf64(2.0f, (float)((table_buf[iLensData+10] & 0xf0) >>4)/4.0f);",
          "6728:   if (table_buf[iLensData+10] & 0x0f)",
          "6729:     imgdata.lens.makernotes.MinAp4CurFocal =",
          "6730:    powf64(2.0f, (float)((table_buf[iLensData+10] & 0x0f) + 10)/4.0f);",
          "6732:   if (iLensData != 12)",
          "6733:     {",
          "6734:    switch (table_buf[iLensData] & 0x06)",
          "6735:      {",
          "6736:      case 0: imgdata.lens.makernotes.MinAp4MinFocal = 22.0f; break;",
          "6737:      case 2: imgdata.lens.makernotes.MinAp4MinFocal = 32.0f; break;",
          "6738:      case 4: imgdata.lens.makernotes.MinAp4MinFocal = 45.0f; break;",
          "6739:      case 6: imgdata.lens.makernotes.MinAp4MinFocal = 16.0f; break;",
          "6740:      }",
          "6741:    if (table_buf[iLensData] & 0x70)",
          "6742:      imgdata.lens.makernotes.LensFStops =",
          "6743:     ((float)(((table_buf[iLensData] & 0x70) >> 4) ^ 0x07)) / 2.0f + 5.0f;",
          "6745:    imgdata.lens.makernotes.MinFocusDistance = (float)(table_buf[iLensData+3] & 0xf8);",
          "6746:    imgdata.lens.makernotes.FocusRangeIndex = (float)(table_buf[iLensData+3] & 0x07);",
          "6748:    if ((table_buf[iLensData+14] > 1) &&",
          "6749:     (fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))",
          "6750:      imgdata.lens.makernotes.MaxAp4CurFocal =",
          "6751:     powf64(2.0f, (float)((table_buf[iLensData+14] & 0x7f) -1)/32.0f);",
          "6752:     }",
          "6753:   else if ((id != 0x12e76) && // K-5",
          "6754:      (table_buf[iLensData+15] > 1) &&",
          "6755:      (fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))",
          "6756:     {",
          "6757:    imgdata.lens.makernotes.MaxAp4CurFocal =",
          "6758:      powf64(2.0f, (float)((table_buf[iLensData+15] & 0x7f) -1)/32.0f);",
          "6759:     }",
          "6760:    }",
          "6761:  free(table_buf);",
          "6762:  return;",
          "6763: }",
          "6765: void CLASS setPhaseOneFeatures (unsigned id) {",
          "6767:   ushort i;",
          "6768:   static const struct {",
          "6769:     ushort id;",
          "6770:     char t_model[32];",
          "6771:   } p1_unique[] = {",
          "6773:     {1, \"Hasselblad V\"},",
          "6774:     {10, \"PhaseOne/Mamiya\"},",
          "6775:     {12, \"Contax 645\"},",
          "6776:     {16, \"Hasselblad V\"},",
          "6777:     {17, \"Hasselblad V\"},",
          "6778:     {18, \"Contax 645\"},",
          "6779:     {19, \"PhaseOne/Mamiya\"},",
          "6780:     {20, \"Hasselblad V\"},",
          "6781:     {21, \"Contax 645\"},",
          "6782:     {22, \"PhaseOne/Mamiya\"},",
          "6783:     {23, \"Hasselblad V\"},",
          "6784:     {24, \"Hasselblad H\"},",
          "6785:     {25, \"PhaseOne/Mamiya\"},",
          "6786:     {32, \"Contax 645\"},",
          "6787:     {34, \"Hasselblad V\"},",
          "6788:     {35, \"Hasselblad V\"},",
          "6789:     {36, \"Hasselblad H\"},",
          "6790:     {37, \"Contax 645\"},",
          "6791:     {38, \"PhaseOne/Mamiya\"},",
          "6792:     {39, \"Hasselblad V\"},",
          "6793:     {40, \"Hasselblad H\"},",
          "6794:     {41, \"Contax 645\"},",
          "6795:     {42, \"PhaseOne/Mamiya\"},",
          "6796:     {44, \"Hasselblad V\"},",
          "6797:     {45, \"Hasselblad H\"},",
          "6798:     {46, \"Contax 645\"},",
          "6799:     {47, \"PhaseOne/Mamiya\"},",
          "6800:     {48, \"Hasselblad V\"},",
          "6801:     {49, \"Hasselblad H\"},",
          "6802:     {50, \"Contax 645\"},",
          "6803:     {51, \"PhaseOne/Mamiya\"},",
          "6804:     {52, \"Hasselblad V\"},",
          "6805:     {53, \"Hasselblad H\"},",
          "6806:     {54, \"Contax 645\"},",
          "6807:     {55, \"PhaseOne/Mamiya\"},",
          "6808:     {67, \"Hasselblad V\"},",
          "6809:     {68, \"Hasselblad H\"},",
          "6810:     {69, \"Contax 645\"},",
          "6811:     {70, \"PhaseOne/Mamiya\"},",
          "6812:     {71, \"Hasselblad V\"},",
          "6813:     {72, \"Hasselblad H\"},",
          "6814:     {73, \"Contax 645\"},",
          "6815:     {74, \"PhaseOne/Mamiya\"},",
          "6816:     {76, \"Hasselblad V\"},",
          "6817:     {77, \"Hasselblad H\"},",
          "6818:     {78, \"Contax 645\"},",
          "6819:     {79, \"PhaseOne/Mamiya\"},",
          "6820:     {80, \"Hasselblad V\"},",
          "6821:     {81, \"Hasselblad H\"},",
          "6822:     {82, \"Contax 645\"},",
          "6823:     {83, \"PhaseOne/Mamiya\"},",
          "6824:     {84, \"Hasselblad V\"},",
          "6825:     {85, \"Hasselblad H\"},",
          "6826:     {86, \"Contax 645\"},",
          "6827:     {87, \"PhaseOne/Mamiya\"},",
          "6828:     {99, \"Hasselblad V\"},",
          "6829:     {100, \"Hasselblad H\"},",
          "6830:     {101, \"Contax 645\"},",
          "6831:     {102, \"PhaseOne/Mamiya\"},",
          "6832:     {103, \"Hasselblad V\"},",
          "6833:     {104, \"Hasselblad H\"},",
          "6834:     {105, \"PhaseOne/Mamiya\"},",
          "6835:     {106, \"Contax 645\"},",
          "6836:     {112, \"Hasselblad V\"},",
          "6837:     {113, \"Hasselblad H\"},",
          "6838:     {114, \"Contax 645\"},",
          "6839:     {115, \"PhaseOne/Mamiya\"},",
          "6840:     {131, \"Hasselblad V\"},",
          "6841:     {132, \"Hasselblad H\"},",
          "6842:     {133, \"Contax 645\"},",
          "6843:     {134, \"PhaseOne/Mamiya\"},",
          "6844:     {135, \"Hasselblad V\"},",
          "6845:     {136, \"Hasselblad H\"},",
          "6846:     {137, \"Contax 645\"},",
          "6847:     {138, \"PhaseOne/Mamiya\"},",
          "6848:     {140, \"Hasselblad V\"},",
          "6849:     {141, \"Hasselblad H\"},",
          "6850:     {142, \"Contax 645\"},",
          "6851:     {143, \"PhaseOne/Mamiya\"},",
          "6852:     {148, \"Hasselblad V\"},",
          "6853:     {149, \"Hasselblad H\"},",
          "6854:     {150, \"Contax 645\"},",
          "6855:     {151, \"PhaseOne/Mamiya\"},",
          "6856:     {160, \"A-250\"},",
          "6857:     {161, \"A-260\"},",
          "6858:     {162, \"A-280\"},",
          "6859:     {167, \"Hasselblad V\"},",
          "6860:     {168, \"Hasselblad H\"},",
          "6861:     {169, \"Contax 645\"},",
          "6862:     {170, \"PhaseOne/Mamiya\"},",
          "6863:     {172, \"Hasselblad V\"},",
          "6864:     {173, \"Hasselblad H\"},",
          "6865:     {174, \"Contax 645\"},",
          "6866:     {175, \"PhaseOne/Mamiya\"},",
          "6867:     {176, \"Hasselblad V\"},",
          "6868:     {177, \"Hasselblad H\"},",
          "6869:     {178, \"Contax 645\"},",
          "6870:     {179, \"PhaseOne/Mamiya\"},",
          "6871:     {180, \"Hasselblad V\"},",
          "6872:     {181, \"Hasselblad H\"},",
          "6873:     {182, \"Contax 645\"},",
          "6874:     {183, \"PhaseOne/Mamiya\"},",
          "6875:     {208, \"Hasselblad V\"},",
          "6876:     {211, \"PhaseOne/Mamiya\"},",
          "6877:     {448, \"Phase One 645AF\"},",
          "6878:     {457, \"Phase One 645DF\"},",
          "6879:     {471, \"Phase One 645DF+\"},",
          "6880:     {704, \"Phase One iXA\"},",
          "6881:     {705, \"Phase One iXA - R\"},",
          "6882:     {706, \"Phase One iXU 150\"},",
          "6883:     {707, \"Phase One iXU 150 - NIR\"},",
          "6884:     {708, \"Phase One iXU 180\"},",
          "6885:     {721, \"Phase One iXR\"},",
          "6887:     {333,\"Mamiya\"},",
          "6888:     {329,\"Universal\"},",
          "6889:     {330,\"Hasselblad H1/H2\"},",
          "6890:     {332,\"Contax\"},",
          "6891:     {336,\"AFi\"},",
          "6892:     {327,\"Mamiya\"},",
          "6893:     {324,\"Universal\"},",
          "6894:     {325,\"Hasselblad H1/H2\"},",
          "6895:     {326,\"Contax\"},",
          "6896:     {335,\"AFi\"},",
          "6897:     {340,\"Mamiya\"},",
          "6898:     {337,\"Universal\"},",
          "6899:     {338,\"Hasselblad H1/H2\"},",
          "6900:     {339,\"Contax\"},",
          "6901:     {323,\"Mamiya\"},",
          "6902:     {320,\"Universal\"},",
          "6903:     {322,\"Hasselblad H1/H2\"},",
          "6904:     {321,\"Contax\"},",
          "6905:     {334,\"AFi\"},",
          "6906:     {369,\"Universal\"},",
          "6907:     {370,\"Mamiya\"},",
          "6908:     {371,\"Hasselblad H1/H2\"},",
          "6909:     {372,\"Contax\"},",
          "6910:     {373,\"Afi\"},",
          "6911:   };",
          "6912:   imgdata.lens.makernotes.CamID = id;",
          "6913:   if (id && !imgdata.lens.makernotes.body[0]) {",
          "6914:     for (i=0; i < sizeof p1_unique / sizeof *p1_unique; i++)",
          "6915:       if (id == p1_unique[i].id) {",
          "6916:         strcpy(imgdata.lens.makernotes.body,p1_unique[i].t_model);",
          "6917:       }",
          "6919:   return;",
          "6920: }",
          "6922: void CLASS parseFujiMakernotes (unsigned tag, unsigned type) {",
          "6923:       switch (tag) {",
          "6924:       case 0x1002: imgdata.makernotes.fuji.WB_Preset = get2(); break;",
          "6925:       case 0x1011: imgdata.other.FlashEC = getreal(type); break;",
          "6926:       case 0x1020: imgdata.makernotes.fuji.Macro = get2(); break;",
          "6927:       case 0x1021: imgdata.makernotes.fuji.FocusMode = get2(); break;",
          "6928:       case 0x1022: imgdata.makernotes.fuji.AFMode = get2(); break;",
          "6929:       case 0x1023: imgdata.makernotes.fuji.FocusPixel[0] = get2();",
          "6930:                    imgdata.makernotes.fuji.FocusPixel[1] = get2();",
          "6931:       break;",
          "6932:       case 0x1034: imgdata.makernotes.fuji.ExrMode = get2(); break;",
          "6933:       case 0x1050: imgdata.makernotes.fuji.ShutterType = get2(); break;",
          "6934:       case 0x1400: imgdata.makernotes.fuji.FujiDynamicRange = get2(); break;",
          "6935:       case 0x1401: imgdata.makernotes.fuji.FujiFilmMode = get2(); break;",
          "6936:       case 0x1402: imgdata.makernotes.fuji.FujiDynamicRangeSetting = get2(); break;",
          "6937:       case 0x1403: imgdata.makernotes.fuji.FujiDevelopmentDynamicRange = get2(); break;",
          "6938:       case 0x140b: imgdata.makernotes.fuji.FujiAutoDynamicRange = get2(); break;",
          "6939:       case 0x1404: imgdata.lens.makernotes.MinFocal = getreal(type); break;",
          "6940:       case 0x1405: imgdata.lens.makernotes.MaxFocal = getreal(type); break;",
          "6941:       case 0x1406: imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type); break;",
          "6942:       case 0x1407: imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type); break;",
          "6943:       case 0x1422: imgdata.makernotes.fuji.ImageStabilization[0] = get2();",
          "6944:                    imgdata.makernotes.fuji.ImageStabilization[1] = get2();",
          "6945:                    imgdata.makernotes.fuji.ImageStabilization[2] = get2();",
          "6946:                    imgdata.shootinginfo.ImageStabilization = (imgdata.makernotes.fuji.ImageStabilization[0]<<9) + imgdata.makernotes.fuji.ImageStabilization[1];",
          "6947:       break;",
          "6948:       case 0x1431: imgdata.makernotes.fuji.Rating = get4(); break;",
          "6949:       case 0x3820: imgdata.makernotes.fuji.FrameRate = get2(); break;",
          "6950:       case 0x3821: imgdata.makernotes.fuji.FrameWidth = get2(); break;",
          "6951:       case 0x3822: imgdata.makernotes.fuji.FrameHeight = get2(); break;",
          "6952:       }",
          "6953: return;",
          "6954: }",
          "6956: void CLASS setSonyBodyFeatures (unsigned id) {",
          "6958:   imgdata.lens.makernotes.CamID = id;",
          "6959:   if ( // FF cameras",
          "6960:       (id == 257) ||  // a900",
          "6961:       (id == 269) ||  // a850",
          "6962:       (id == 340) ||  // ILCE-7M2",
          "6963:       (id == 318) ||  // ILCE-7S",
          "6964:       (id == 350) ||  // ILCE-7SM2",
          "6965:       (id == 311) ||  // ILCE-7R",
          "6966:       (id == 347) ||  // ILCE-7RM2",
          "6967:       (id == 306) ||  // ILCE-7",
          "6968:       (id == 298) ||  // DSC-RX1",
          "6969:       (id == 299) ||  // NEX-VG900",
          "6970:       (id == 310) ||  // DSC-RX1R",
          "6971:       (id == 344) ||  // DSC-RX1RM2",
          "6972:       (id == 354) ||  // ILCA-99M2",
          "6973:       (id == 294)  // SLT-99, Hasselblad HV",
          "6974:       )",
          "6975:     {",
          "6976:       imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;",
          "6977:     }",
          "6978:   else if ((id == 297) ||  // DSC-RX100",
          "6979:            (id == 308) ||  // DSC-RX100M2",
          "6980:            (id == 309) ||  // DSC-RX10",
          "6981:            (id == 317) ||  // DSC-RX100M3",
          "6982:            (id == 341) ||  // DSC-RX100M4",
          "6983:            (id == 342) ||  // DSC-RX10M2",
          "6984:            (id == 355) ||  // DSC-RX10M3",
          "6985:            (id == 356)     // DSC-RX100M5",
          "6986:          )",
          "6987:     {",
          "6988:       imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_1INCH;",
          "6989:     }",
          "6991:   else if (id != 002)     // DSC-R1",
          "6992:     {",
          "6993:       imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;",
          "6994:     }",
          "6996:   if      (               // E-mount cameras, ILCE series",
          "6997:            (id == 302) ||",
          "6998:            (id == 306) ||",
          "6999:            (id == 311) ||",
          "7000:            (id == 312) ||",
          "7001:            (id == 313) ||",
          "7002:            (id == 318) ||",
          "7003:            (id == 339) ||",
          "7004:            (id == 340) ||",
          "7005:            (id == 346) ||",
          "7006:            (id == 347) ||",
          "7007:            (id == 350) ||",
          "7008:            (id == 360)",
          "7009:           )",
          "7010:     {",
          "7011:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Sony_E;",
          "7012:       imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_ILCE;",
          "7013:     }",
          "7014:   else if (               // E-mount cameras, NEX series",
          "7015:            (id == 278) ||",
          "7016:            (id == 279) ||",
          "7017:            (id == 284) ||",
          "7018:            (id == 288) ||",
          "7019:            (id == 289) ||",
          "7020:            (id == 290) ||",
          "7021:            (id == 293) ||",
          "7022:            (id == 295) ||",
          "7023:            (id == 296) ||",
          "7024:            (id == 299) ||",
          "7025:            (id == 300) ||",
          "7026:            (id == 305) ||",
          "7027:            (id == 307)",
          "7028:           )",
          "7029:     {",
          "7030:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Sony_E;",
          "7031:       imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_NEX;",
          "7032:     }",
          "7034:   else if ( // A-mount cameras, DSLR series",
          "7035:            (id == 256) ||",
          "7036:            (id == 257) ||",
          "7037:            (id == 258) ||",
          "7038:            (id == 259) ||",
          "7039:            (id == 260) ||",
          "7040:            (id == 261) ||",
          "7041:            (id == 262) ||",
          "7042:            (id == 263) ||",
          "7043:            (id == 264) ||",
          "7044:            (id == 265) ||",
          "7045:            (id == 266) ||",
          "7046:            (id == 269) ||",
          "7047:            (id == 270) ||",
          "7048:            (id == 273) ||",
          "7049:            (id == 274) ||",
          "7050:            (id == 275) ||",
          "7051:            (id == 282) ||",
          "7052:            (id == 283)",
          "7053:           )",
          "7054:     {",
          "7055:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;",
          "7056:       imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSLR;",
          "7057:     }",
          "7058:   else if ( // A-mount cameras, SLT series",
          "7059:            (id == 280) ||",
          "7060:            (id == 281) ||",
          "7061:            (id == 285) ||",
          "7062:            (id == 286) ||",
          "7063:            (id == 287) ||",
          "7064:            (id == 291) ||",
          "7065:            (id == 292) ||",
          "7066:            (id == 294) ||",
          "7067:            (id == 303)",
          "7068:           )",
          "7069:     {",
          "7070:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;",
          "7071:       imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_SLT;",
          "7072:     }",
          "7073:   else if ( // A-mount cameras, ILCA series",
          "7074:            (id == 319)  ||",
          "7075:            (id == 353)  ||",
          "7076:            (id == 354)",
          "7077:           )",
          "7078:     {",
          "7079:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;",
          "7080:       imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_ILCA;",
          "7081:     }",
          "7083:   else if ( // DSC",
          "7084:            (id == 002) ||  // DSC-R1",
          "7085:            (id == 297) ||  // DSC-RX100",
          "7086:            (id == 298) ||  // DSC-RX1",
          "7087:            (id == 308) ||  // DSC-RX100M2",
          "7088:            (id == 309) ||  // DSC-RX10",
          "7089:            (id == 310) ||  // DSC-RX1R",
          "7090:            (id == 344) ||  // DSC-RX1RM2",
          "7091:            (id == 317) ||  // DSC-RX100M3",
          "7092:            (id == 341) ||  // DSC-RX100M4",
          "7093:            (id == 342) ||  // DSC-RX10M2",
          "7094:            (id == 355) ||  // DSC-RX10M3",
          "7095:            (id == 356)     // DSC-RX100M5",
          "7096:            )",
          "7098:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "7099:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "7100:       imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSC;",
          "7102:   return;",
          "7103: }",
          "7105: void CLASS parseSonyLensType2 (uchar a, uchar b) {",
          "7106:   ushort lid2;",
          "7107:   lid2 = (((ushort)a)<<8) | ((ushort)b);",
          "7108:   if (!lid2) return;",
          "7109:   if (lid2 < 0x100)",
          "7111:       if ((imgdata.lens.makernotes.AdapterID != 0x4900) &&",
          "7112:           (imgdata.lens.makernotes.AdapterID != 0xEF00))",
          "7114:         imgdata.lens.makernotes.AdapterID = lid2;",
          "7115:         switch (lid2) {",
          "7116:         case 1:",
          "7117:         case 2:",
          "7118:         case 3:",
          "7119:         case 6:",
          "7120:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;",
          "7122:         case 44:",
          "7123:         case 78:",
          "7124:         case 239:",
          "7125:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "7127:         }",
          "7130:   else",
          "7131:     imgdata.lens.makernotes.LensID = lid2;",
          "7132:   if ((lid2 >= 50481) && (lid2 < 50500))",
          "7134:       strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");",
          "7135:       imgdata.lens.makernotes.AdapterID = 0x4900;",
          "7140: #define strnXcat(buf,string) strncat(buf,string,LIM(sizeof(buf)-strbuflen(buf)-1,0,sizeof(buf)))",
          "7142: void CLASS parseSonyLensFeatures (uchar a, uchar b) {",
          "7145:   features = (((ushort)a)<<8) | ((ushort)b);",
          "7148:       (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F) ||",
          "7149:       !features)",
          "7154:   if ((features & 0x0200) && (features & 0x0100)) strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"E\");",
          "7155:   else if (features & 0x0200) strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"FE\");",
          "7156:   else if (features & 0x0100) strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"DT\");",
          "7159:     {",
          "7160:      imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FF;",
          "7161:      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;",
          "7163:      if ((features & 0x0200) && (features & 0x0100)) {",
          "7164:     imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;",
          "7165:     imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;",
          "7166:      } else if (features & 0x0200) {",
          "7167:     imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;",
          "7168:      } else if (features & 0x0100) {",
          "7169:     imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;",
          "7170:      }",
          "",
          "[Added Lines]",
          "7426: void CLASS PentaxISO(ushort c)",
          "7428:   int code[] = {3,   4,   5,   6,   7,   8,   9,   10,  11,   12,   13,  14,  15,  16,  17,  18,  19,",
          "7429:                 20,  21,  22,  23,  24,  25,  26,  27,  28,   29,   30,  31,  32,  33,  34,  35,  36,",
          "7430:                 37,  38,  39,  50,  100, 200, 400, 800, 1600, 3200, 258, 259, 260, 261, 262, 263, 264,",
          "7431:                 265, 266, 267, 268, 269, 270, 271, 272, 273,  274,  275, 276, 277, 278};",
          "7432:   double value[] = {50,    64,    80,    100,   125,   160,   200,   250,    320,    400,    500,    640,   800,",
          "7433:                     1000,  1250,  1600,  2000,  2500,  3200,  4000,  5000,   6400,   8000,   10000,  12800, 16000,",
          "7434:                     20000, 25600, 32000, 40000, 51200, 64000, 80000, 102400, 128000, 160000, 204800, 50,    100,",
          "7435:                     200,   400,   800,   1600,  3200,  50,    70,    100,    140,    200,    280,    400,   560,",
          "7436:                     800,   1100,  1600,  2200,  3200,  4500,  6400,  9000,   12800,  18000,  25600,  36000, 51200};",
          "7437: #define numel (sizeof(code) / sizeof(code[0]))",
          "7439:   for (i = 0; i < numel; i++)",
          "7440:   {",
          "7441:     if (code[i] == c)",
          "7442:     {",
          "7447:   if (i == numel)",
          "7448:     iso_speed = 65535.0f;",
          "7452: void CLASS PentaxLensInfo(unsigned id, unsigned len) // tag 0x0207",
          "7453: {",
          "7454:   ushort iLensData = 0;",
          "7455:   uchar *table_buf;",
          "7456:   table_buf = (uchar *)malloc(MAX(len, 128));",
          "7457:   fread(table_buf, len, 1, ifp);",
          "7458:   if ((id < 0x12b9c) || (((id == 0x12b9c) ||  // K100D",
          "7459:                           (id == 0x12b9d) ||  // K110D",
          "7460:                           (id == 0x12ba2)) && // K100D Super",
          "7461:                          ((!table_buf[20] || (table_buf[20] == 0xff)))))",
          "7462:   {",
          "7463:     iLensData = 3;",
          "7464:     if (imgdata.lens.makernotes.LensID == -1)",
          "7465:       imgdata.lens.makernotes.LensID = (((unsigned)table_buf[0]) << 8) + table_buf[1];",
          "7467:   else",
          "7468:     switch (len)",
          "7470:     case 90: // LensInfo3",
          "7471:       iLensData = 13;",
          "7472:       if (imgdata.lens.makernotes.LensID == -1)",
          "7473:         imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) << 8) + table_buf[4];",
          "7474:       break;",
          "7475:     case 91: // LensInfo4",
          "7476:       iLensData = 12;",
          "7477:       if (imgdata.lens.makernotes.LensID == -1)",
          "7478:         imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) << 8) + table_buf[4];",
          "7479:       break;",
          "7480:     case 80: // LensInfo5",
          "7481:     case 128:",
          "7482:       iLensData = 15;",
          "7483:       if (imgdata.lens.makernotes.LensID == -1)",
          "7484:         imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[1] & 0x0f) + table_buf[4]) << 8) + table_buf[5];",
          "7485:       break;",
          "7486:     default:",
          "7487:       if (id >= 0x12b9c) // LensInfo2",
          "7488:       {",
          "7489:         iLensData = 4;",
          "7490:         if (imgdata.lens.makernotes.LensID == -1)",
          "7491:           imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[0] & 0x0f) + table_buf[2]) << 8) + table_buf[3];",
          "7492:       }",
          "7494:   if (iLensData)",
          "7495:   {",
          "7496:     if (table_buf[iLensData + 9] && (fabs(imgdata.lens.makernotes.CurFocal) < 0.1f))",
          "7497:       imgdata.lens.makernotes.CurFocal =",
          "7498:           10 * (table_buf[iLensData + 9] >> 2) * powf64(4, (table_buf[iLensData + 9] & 0x03) - 2);",
          "7499:     if (table_buf[iLensData + 10] & 0xf0)",
          "7500:       imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (float)((table_buf[iLensData + 10] & 0xf0) >> 4) / 4.0f);",
          "7501:     if (table_buf[iLensData + 10] & 0x0f)",
          "7502:       imgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (float)((table_buf[iLensData + 10] & 0x0f) + 10) / 4.0f);",
          "7504:     if (iLensData != 12)",
          "7506:       switch (table_buf[iLensData] & 0x06)",
          "7508:       case 0:",
          "7509:         imgdata.lens.makernotes.MinAp4MinFocal = 22.0f;",
          "7511:       case 2:",
          "7512:         imgdata.lens.makernotes.MinAp4MinFocal = 32.0f;",
          "7513:         break;",
          "7514:       case 4:",
          "7515:         imgdata.lens.makernotes.MinAp4MinFocal = 45.0f;",
          "7516:         break;",
          "7517:       case 6:",
          "7518:         imgdata.lens.makernotes.MinAp4MinFocal = 16.0f;",
          "7521:       if (table_buf[iLensData] & 0x70)",
          "7522:         imgdata.lens.makernotes.LensFStops = ((float)(((table_buf[iLensData] & 0x70) >> 4) ^ 0x07)) / 2.0f + 5.0f;",
          "7524:       imgdata.lens.makernotes.MinFocusDistance = (float)(table_buf[iLensData + 3] & 0xf8);",
          "7525:       imgdata.lens.makernotes.FocusRangeIndex = (float)(table_buf[iLensData + 3] & 0x07);",
          "7527:       if ((table_buf[iLensData + 14] > 1) && (fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))",
          "7528:         imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (float)((table_buf[iLensData + 14] & 0x7f) - 1) / 32.0f);",
          "7530:     else if ((id != 0x12e76) && // K-5",
          "7531:              (table_buf[iLensData + 15] > 1) && (fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))",
          "7533:       imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (float)((table_buf[iLensData + 15] & 0x7f) - 1) / 32.0f);",
          "7535:   }",
          "7536:   free(table_buf);",
          "7540: void CLASS setPhaseOneFeatures(unsigned id)",
          "7541: {",
          "7543:   ushort i;",
          "7544:   static const struct",
          "7545:   {",
          "7546:     ushort id;",
          "7547:     char t_model[32];",
          "7548:   } p1_unique[] = {",
          "7550:       {1, \"Hasselblad V\"},",
          "7551:       {10, \"PhaseOne/Mamiya\"},",
          "7552:       {12, \"Contax 645\"},",
          "7553:       {16, \"Hasselblad V\"},",
          "7554:       {17, \"Hasselblad V\"},",
          "7555:       {18, \"Contax 645\"},",
          "7556:       {19, \"PhaseOne/Mamiya\"},",
          "7557:       {20, \"Hasselblad V\"},",
          "7558:       {21, \"Contax 645\"},",
          "7559:       {22, \"PhaseOne/Mamiya\"},",
          "7560:       {23, \"Hasselblad V\"},",
          "7561:       {24, \"Hasselblad H\"},",
          "7562:       {25, \"PhaseOne/Mamiya\"},",
          "7563:       {32, \"Contax 645\"},",
          "7564:       {34, \"Hasselblad V\"},",
          "7565:       {35, \"Hasselblad V\"},",
          "7566:       {36, \"Hasselblad H\"},",
          "7567:       {37, \"Contax 645\"},",
          "7568:       {38, \"PhaseOne/Mamiya\"},",
          "7569:       {39, \"Hasselblad V\"},",
          "7570:       {40, \"Hasselblad H\"},",
          "7571:       {41, \"Contax 645\"},",
          "7572:       {42, \"PhaseOne/Mamiya\"},",
          "7573:       {44, \"Hasselblad V\"},",
          "7574:       {45, \"Hasselblad H\"},",
          "7575:       {46, \"Contax 645\"},",
          "7576:       {47, \"PhaseOne/Mamiya\"},",
          "7577:       {48, \"Hasselblad V\"},",
          "7578:       {49, \"Hasselblad H\"},",
          "7579:       {50, \"Contax 645\"},",
          "7580:       {51, \"PhaseOne/Mamiya\"},",
          "7581:       {52, \"Hasselblad V\"},",
          "7582:       {53, \"Hasselblad H\"},",
          "7583:       {54, \"Contax 645\"},",
          "7584:       {55, \"PhaseOne/Mamiya\"},",
          "7585:       {67, \"Hasselblad V\"},",
          "7586:       {68, \"Hasselblad H\"},",
          "7587:       {69, \"Contax 645\"},",
          "7588:       {70, \"PhaseOne/Mamiya\"},",
          "7589:       {71, \"Hasselblad V\"},",
          "7590:       {72, \"Hasselblad H\"},",
          "7591:       {73, \"Contax 645\"},",
          "7592:       {74, \"PhaseOne/Mamiya\"},",
          "7593:       {76, \"Hasselblad V\"},",
          "7594:       {77, \"Hasselblad H\"},",
          "7595:       {78, \"Contax 645\"},",
          "7596:       {79, \"PhaseOne/Mamiya\"},",
          "7597:       {80, \"Hasselblad V\"},",
          "7598:       {81, \"Hasselblad H\"},",
          "7599:       {82, \"Contax 645\"},",
          "7600:       {83, \"PhaseOne/Mamiya\"},",
          "7601:       {84, \"Hasselblad V\"},",
          "7602:       {85, \"Hasselblad H\"},",
          "7603:       {86, \"Contax 645\"},",
          "7604:       {87, \"PhaseOne/Mamiya\"},",
          "7605:       {99, \"Hasselblad V\"},",
          "7606:       {100, \"Hasselblad H\"},",
          "7607:       {101, \"Contax 645\"},",
          "7608:       {102, \"PhaseOne/Mamiya\"},",
          "7609:       {103, \"Hasselblad V\"},",
          "7610:       {104, \"Hasselblad H\"},",
          "7611:       {105, \"PhaseOne/Mamiya\"},",
          "7612:       {106, \"Contax 645\"},",
          "7613:       {112, \"Hasselblad V\"},",
          "7614:       {113, \"Hasselblad H\"},",
          "7615:       {114, \"Contax 645\"},",
          "7616:       {115, \"PhaseOne/Mamiya\"},",
          "7617:       {131, \"Hasselblad V\"},",
          "7618:       {132, \"Hasselblad H\"},",
          "7619:       {133, \"Contax 645\"},",
          "7620:       {134, \"PhaseOne/Mamiya\"},",
          "7621:       {135, \"Hasselblad V\"},",
          "7622:       {136, \"Hasselblad H\"},",
          "7623:       {137, \"Contax 645\"},",
          "7624:       {138, \"PhaseOne/Mamiya\"},",
          "7625:       {140, \"Hasselblad V\"},",
          "7626:       {141, \"Hasselblad H\"},",
          "7627:       {142, \"Contax 645\"},",
          "7628:       {143, \"PhaseOne/Mamiya\"},",
          "7629:       {148, \"Hasselblad V\"},",
          "7630:       {149, \"Hasselblad H\"},",
          "7631:       {150, \"Contax 645\"},",
          "7632:       {151, \"PhaseOne/Mamiya\"},",
          "7633:       {160, \"A-250\"},",
          "7634:       {161, \"A-260\"},",
          "7635:       {162, \"A-280\"},",
          "7636:       {167, \"Hasselblad V\"},",
          "7637:       {168, \"Hasselblad H\"},",
          "7638:       {169, \"Contax 645\"},",
          "7639:       {170, \"PhaseOne/Mamiya\"},",
          "7640:       {172, \"Hasselblad V\"},",
          "7641:       {173, \"Hasselblad H\"},",
          "7642:       {174, \"Contax 645\"},",
          "7643:       {175, \"PhaseOne/Mamiya\"},",
          "7644:       {176, \"Hasselblad V\"},",
          "7645:       {177, \"Hasselblad H\"},",
          "7646:       {178, \"Contax 645\"},",
          "7647:       {179, \"PhaseOne/Mamiya\"},",
          "7648:       {180, \"Hasselblad V\"},",
          "7649:       {181, \"Hasselblad H\"},",
          "7650:       {182, \"Contax 645\"},",
          "7651:       {183, \"PhaseOne/Mamiya\"},",
          "7652:       {208, \"Hasselblad V\"},",
          "7653:       {211, \"PhaseOne/Mamiya\"},",
          "7654:       {448, \"Phase One 645AF\"},",
          "7655:       {457, \"Phase One 645DF\"},",
          "7656:       {471, \"Phase One 645DF+\"},",
          "7657:       {704, \"Phase One iXA\"},",
          "7658:       {705, \"Phase One iXA - R\"},",
          "7659:       {706, \"Phase One iXU 150\"},",
          "7660:       {707, \"Phase One iXU 150 - NIR\"},",
          "7661:       {708, \"Phase One iXU 180\"},",
          "7662:       {721, \"Phase One iXR\"},",
          "7664:       {333, \"Mamiya\"},",
          "7665:       {329, \"Universal\"},",
          "7666:       {330, \"Hasselblad H1/H2\"},",
          "7667:       {332, \"Contax\"},",
          "7668:       {336, \"AFi\"},",
          "7669:       {327, \"Mamiya\"},",
          "7670:       {324, \"Universal\"},",
          "7671:       {325, \"Hasselblad H1/H2\"},",
          "7672:       {326, \"Contax\"},",
          "7673:       {335, \"AFi\"},",
          "7674:       {340, \"Mamiya\"},",
          "7675:       {337, \"Universal\"},",
          "7676:       {338, \"Hasselblad H1/H2\"},",
          "7677:       {339, \"Contax\"},",
          "7678:       {323, \"Mamiya\"},",
          "7679:       {320, \"Universal\"},",
          "7680:       {322, \"Hasselblad H1/H2\"},",
          "7681:       {321, \"Contax\"},",
          "7682:       {334, \"AFi\"},",
          "7683:       {369, \"Universal\"},",
          "7684:       {370, \"Mamiya\"},",
          "7685:       {371, \"Hasselblad H1/H2\"},",
          "7686:       {372, \"Contax\"},",
          "7687:       {373, \"Afi\"},",
          "7688:   };",
          "7689:   imgdata.lens.makernotes.CamID = id;",
          "7690:   if (id && !imgdata.lens.makernotes.body[0])",
          "7691:   {",
          "7692:     for (i = 0; i < sizeof p1_unique / sizeof *p1_unique; i++)",
          "7693:       if (id == p1_unique[i].id)",
          "7694:       {",
          "7695:         strcpy(imgdata.lens.makernotes.body, p1_unique[i].t_model);",
          "7696:       }",
          "7697:   }",
          "7698:   return;",
          "7699: }",
          "7701: void CLASS parseFujiMakernotes(unsigned tag, unsigned type)",
          "7702: {",
          "7703:   switch (tag)",
          "7704:   {",
          "7705:   case 0x1002:",
          "7706:     imgdata.makernotes.fuji.WB_Preset = get2();",
          "7707:     break;",
          "7708:   case 0x1011:",
          "7709:     imgdata.other.FlashEC = getreal(type);",
          "7710:     break;",
          "7711:   case 0x1020:",
          "7712:     imgdata.makernotes.fuji.Macro = get2();",
          "7713:     break;",
          "7714:   case 0x1021:",
          "7715:     imgdata.makernotes.fuji.FocusMode = get2();",
          "7716:     break;",
          "7717:   case 0x1022:",
          "7718:     imgdata.makernotes.fuji.AFMode = get2();",
          "7719:     break;",
          "7720:   case 0x1023:",
          "7721:     imgdata.makernotes.fuji.FocusPixel[0] = get2();",
          "7722:     imgdata.makernotes.fuji.FocusPixel[1] = get2();",
          "7723:     break;",
          "7724:   case 0x1034:",
          "7725:     imgdata.makernotes.fuji.ExrMode = get2();",
          "7726:     break;",
          "7727:   case 0x1050:",
          "7728:     imgdata.makernotes.fuji.ShutterType = get2();",
          "7729:     break;",
          "7730:   case 0x1400:",
          "7731:     imgdata.makernotes.fuji.FujiDynamicRange = get2();",
          "7732:     break;",
          "7733:   case 0x1401:",
          "7734:     imgdata.makernotes.fuji.FujiFilmMode = get2();",
          "7735:     break;",
          "7736:   case 0x1402:",
          "7737:     imgdata.makernotes.fuji.FujiDynamicRangeSetting = get2();",
          "7738:     break;",
          "7739:   case 0x1403:",
          "7740:     imgdata.makernotes.fuji.FujiDevelopmentDynamicRange = get2();",
          "7741:     break;",
          "7742:   case 0x140b:",
          "7743:     imgdata.makernotes.fuji.FujiAutoDynamicRange = get2();",
          "7744:     break;",
          "7745:   case 0x1404:",
          "7746:     imgdata.lens.makernotes.MinFocal = getreal(type);",
          "7747:     break;",
          "7748:   case 0x1405:",
          "7749:     imgdata.lens.makernotes.MaxFocal = getreal(type);",
          "7750:     break;",
          "7751:   case 0x1406:",
          "7752:     imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);",
          "7753:     break;",
          "7754:   case 0x1407:",
          "7755:     imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);",
          "7756:     break;",
          "7757:   case 0x1422:",
          "7758:     imgdata.makernotes.fuji.ImageStabilization[0] = get2();",
          "7759:     imgdata.makernotes.fuji.ImageStabilization[1] = get2();",
          "7760:     imgdata.makernotes.fuji.ImageStabilization[2] = get2();",
          "7761:     imgdata.shootinginfo.ImageStabilization =",
          "7762:         (imgdata.makernotes.fuji.ImageStabilization[0] << 9) + imgdata.makernotes.fuji.ImageStabilization[1];",
          "7763:     break;",
          "7764:   case 0x1431:",
          "7765:     imgdata.makernotes.fuji.Rating = get4();",
          "7766:     break;",
          "7767:   case 0x3820:",
          "7768:     imgdata.makernotes.fuji.FrameRate = get2();",
          "7769:     break;",
          "7770:   case 0x3821:",
          "7771:     imgdata.makernotes.fuji.FrameWidth = get2();",
          "7772:     break;",
          "7773:   case 0x3822:",
          "7774:     imgdata.makernotes.fuji.FrameHeight = get2();",
          "7775:     break;",
          "7776:   }",
          "7777:   return;",
          "7778: }",
          "7780: void CLASS setSonyBodyFeatures(unsigned id)",
          "7781: {",
          "7783:   imgdata.lens.makernotes.CamID = id;",
          "7784:   if (               // FF cameras",
          "7785:       (id == 257) || // a900",
          "7786:       (id == 269) || // a850",
          "7787:       (id == 340) || // ILCE-7M2",
          "7788:       (id == 318) || // ILCE-7S",
          "7789:       (id == 350) || // ILCE-7SM2",
          "7790:       (id == 311) || // ILCE-7R",
          "7791:       (id == 347) || // ILCE-7RM2",
          "7792:       (id == 306) || // ILCE-7",
          "7793:       (id == 298) || // DSC-RX1",
          "7794:       (id == 299) || // NEX-VG900",
          "7795:       (id == 310) || // DSC-RX1R",
          "7796:       (id == 344) || // DSC-RX1RM2",
          "7797:       (id == 354) || // ILCA-99M2",
          "7798:       (id == 294)    // SLT-99, Hasselblad HV",
          "7799:       )",
          "7800:   {",
          "7801:     imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;",
          "7802:   }",
          "7803:   else if ((id == 297) || // DSC-RX100",
          "7804:            (id == 308) || // DSC-RX100M2",
          "7805:            (id == 309) || // DSC-RX10",
          "7806:            (id == 317) || // DSC-RX100M3",
          "7807:            (id == 341) || // DSC-RX100M4",
          "7808:            (id == 342) || // DSC-RX10M2",
          "7809:            (id == 355) || // DSC-RX10M3",
          "7810:            (id == 356)    // DSC-RX100M5",
          "7811:            )",
          "7812:   {",
          "7813:     imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_1INCH;",
          "7814:   }",
          "7816:   else if (id != 002) // DSC-R1",
          "7817:   {",
          "7818:     imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;",
          "7819:   }",
          "7821:   if ( // E-mount cameras, ILCE series",
          "7822:       (id == 302) || (id == 306) || (id == 311) || (id == 312) || (id == 313) || (id == 318) || (id == 339) ||",
          "7823:       (id == 340) || (id == 346) || (id == 347) || (id == 350) || (id == 360))",
          "7824:   {",
          "7825:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Sony_E;",
          "7826:     imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_ILCE;",
          "7827:   }",
          "7828:   else if ( // E-mount cameras, NEX series",
          "7829:       (id == 278) || (id == 279) || (id == 284) || (id == 288) || (id == 289) || (id == 290) || (id == 293) ||",
          "7830:       (id == 295) || (id == 296) || (id == 299) || (id == 300) || (id == 305) || (id == 307))",
          "7831:   {",
          "7832:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Sony_E;",
          "7833:     imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_NEX;",
          "7834:   }",
          "7836:   else if ( // A-mount cameras, DSLR series",
          "7837:       (id == 256) || (id == 257) || (id == 258) || (id == 259) || (id == 260) || (id == 261) || (id == 262) ||",
          "7838:       (id == 263) || (id == 264) || (id == 265) || (id == 266) || (id == 269) || (id == 270) || (id == 273) ||",
          "7839:       (id == 274) || (id == 275) || (id == 282) || (id == 283))",
          "7840:   {",
          "7841:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;",
          "7842:     imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSLR;",
          "7843:   }",
          "7844:   else if ( // A-mount cameras, SLT series",
          "7845:       (id == 280) || (id == 281) || (id == 285) || (id == 286) || (id == 287) || (id == 291) || (id == 292) ||",
          "7846:       (id == 294) || (id == 303))",
          "7847:   {",
          "7848:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;",
          "7849:     imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_SLT;",
          "7850:   }",
          "7851:   else if ( // A-mount cameras, ILCA series",
          "7852:       (id == 319) || (id == 353) || (id == 354))",
          "7853:   {",
          "7854:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;",
          "7855:     imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_ILCA;",
          "7856:   }",
          "7858:   else if (          // DSC",
          "7859:       (id == 002) || // DSC-R1",
          "7860:       (id == 297) || // DSC-RX100",
          "7861:       (id == 298) || // DSC-RX1",
          "7862:       (id == 308) || // DSC-RX100M2",
          "7863:       (id == 309) || // DSC-RX10",
          "7864:       (id == 310) || // DSC-RX1R",
          "7865:       (id == 344) || // DSC-RX1RM2",
          "7866:       (id == 317) || // DSC-RX100M3",
          "7867:       (id == 341) || // DSC-RX100M4",
          "7868:       (id == 342) || // DSC-RX10M2",
          "7869:       (id == 355) || // DSC-RX10M3",
          "7870:       (id == 356)    // DSC-RX100M5",
          "7871:       )",
          "7872:   {",
          "7873:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "7874:     imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "7875:     imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSC;",
          "7876:   }",
          "7877:   return;",
          "7878: }",
          "7880: void CLASS parseSonyLensType2(uchar a, uchar b)",
          "7881: {",
          "7882:   ushort lid2;",
          "7883:   lid2 = (((ushort)a) << 8) | ((ushort)b);",
          "7884:   if (!lid2)",
          "7885:     return;",
          "7886:   if (lid2 < 0x100)",
          "7887:   {",
          "7888:     if ((imgdata.lens.makernotes.AdapterID != 0x4900) && (imgdata.lens.makernotes.AdapterID != 0xEF00))",
          "7889:     {",
          "7890:       imgdata.lens.makernotes.AdapterID = lid2;",
          "7891:       switch (lid2)",
          "7892:       {",
          "7893:       case 1:",
          "7894:       case 2:",
          "7895:       case 3:",
          "7896:       case 6:",
          "7897:         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;",
          "7898:         break;",
          "7899:       case 44:",
          "7900:       case 78:",
          "7901:       case 239:",
          "7902:         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "7903:         break;",
          "7904:       }",
          "7905:     }",
          "7906:   }",
          "7907:   else",
          "7908:     imgdata.lens.makernotes.LensID = lid2;",
          "7909:   if ((lid2 >= 50481) && (lid2 < 50500))",
          "7910:   {",
          "7911:     strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");",
          "7912:     imgdata.lens.makernotes.AdapterID = 0x4900;",
          "7913:   }",
          "7914:   return;",
          "7915: }",
          "7917: #define strnXcat(buf, string) strncat(buf, string, LIM(sizeof(buf) - strbuflen(buf) - 1, 0, sizeof(buf)))",
          "7919: void CLASS parseSonyLensFeatures(uchar a, uchar b)",
          "7920: {",
          "7923:   features = (((ushort)a) << 8) | ((ushort)b);",
          "7926:       (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F) || !features)",
          "7931:   if ((features & 0x0200) && (features & 0x0100))",
          "7932:     strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"E\");",
          "7933:   else if (features & 0x0200)",
          "7934:     strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"FE\");",
          "7935:   else if (features & 0x0100)",
          "7936:     strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"DT\");",
          "7939:   {",
          "7940:     imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FF;",
          "7941:     imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;",
          "7943:     if ((features & 0x0200) && (features & 0x0100))",
          "7944:     {",
          "7945:       imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;",
          "7946:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;",
          "7947:     }",
          "7948:     else if (features & 0x0200)",
          "7949:     {",
          "7950:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;",
          "7951:     }",
          "7952:     else if (features & 0x0100)",
          "7953:     {",
          "7954:       imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;",
          "7956:   }",
          "",
          "---------------",
          "--- Hunk 76 ---",
          "[Context before]",
          "7176:   if (features & 0x0008)",
          "7177:     strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" G\");",
          "7178:   else if (features & 0x0004)",
          "7181:   if ((features & 0x0020) && (features & 0x0040))",
          "7182:     strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Macro\");",
          "",
          "[Removed Lines]",
          "7179:     strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" ZA\" );",
          "",
          "[Added Lines]",
          "7964:     strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" ZA\");",
          "",
          "---------------",
          "--- Hunk 77 ---",
          "[Context before]",
          "7202:     strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" II\");",
          "7204:   if (imgdata.lens.makernotes.LensFeatures_suf[0] == ' ')",
          "7208:   return;",
          "7209: }",
          "7210: #undef strnXcat",
          "7213: {",
          "7214:   ushort lid2;",
          "7215:   if ((imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&",
          "7216:       (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))",
          "7217:     {",
          "7227:     }",
          "7230:   if ((lid2 > 0) && (lid2 < 32784))",
          "7233:   return;",
          "7234: }",
          "7238: {",
          "7239:   ushort lid;",
          "7241:   if ((imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_Sony_E) &&",
          "7242:       (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens))",
          "7253:   if (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens)",
          "7254:     {",
          "7272:   if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)",
          "7279:       (buf[0x010a] | buf[0x0109]))",
          "7302:     }",
          "7304:   if ((id >= 286) && (id <= 293))",
          "7309:   else if (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens)",
          "7344:   return;",
          "7345: }",
          "",
          "[Removed Lines]",
          "7205:     memmove(imgdata.lens.makernotes.LensFeatures_suf, imgdata.lens.makernotes.LensFeatures_suf+1,",
          "7206:      strbuflen(imgdata.lens.makernotes.LensFeatures_suf)-1);",
          "7212: void CLASS process_Sony_0x940c (uchar * buf)",
          "7218:       switch (SonySubstitution[buf[0x0008]]) {",
          "7219:       case 1:",
          "7220:       case 5:",
          "7221:         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;",
          "7222:         break;",
          "7223:       case 4:",
          "7224:         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;",
          "7225:         break;",
          "7226:       }",
          "7228:   lid2 = (((ushort)SonySubstitution[buf[0x000a]])<<8) |",
          "7229:     ((ushort)SonySubstitution[buf[0x0009]]);",
          "7231:     parseSonyLensType2 (SonySubstitution[buf[0x000a]], // LensType2 - Sony lens ids",
          "7232:                         SonySubstitution[buf[0x0009]]);",
          "7237: void CLASS process_Sony_0x9050 (uchar * buf, unsigned id)",
          "7243:     {",
          "7244:       if (buf[0])",
          "7245:         imgdata.lens.makernotes.MaxAp4CurFocal =",
          "7246:           my_roundf(powf64(2.0f, ((float)SonySubstitution[buf[0]] / 8.0 - 1.06f) / 2.0f)*10.0f) / 10.0f;",
          "7248:       if (buf[1])",
          "7249:         imgdata.lens.makernotes.MinAp4CurFocal =",
          "7250:           my_roundf(powf64(2.0f, ((float)SonySubstitution[buf[1]] / 8.0 - 1.06f) / 2.0f)*10.0f) / 10.0f;",
          "7251:     }",
          "7255:       if (buf[0x3d] | buf[0x3c])",
          "7256:         {",
          "7257:           lid = SonySubstitution[buf[0x3d]] << 8 |",
          "7258:             SonySubstitution[buf[0x3c]];",
          "7259:           imgdata.lens.makernotes.CurAp =",
          "7260:             powf64(2.0f, ((float)lid/256.0f - 16.0f) / 2.0f);",
          "7261:         }",
          "7262:       if (buf[0x105] &&",
          "7263:           (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&",
          "7264:           (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))",
          "7265:         imgdata.lens.makernotes.LensMount =",
          "7266:           SonySubstitution[buf[0x105]];",
          "7267:       if (buf[0x106])",
          "7268:         imgdata.lens.makernotes.LensFormat =",
          "7269:           SonySubstitution[buf[0x106]];",
          "7270:     }",
          "7273:     {",
          "7274:       parseSonyLensType2 (SonySubstitution[buf[0x0108]],  // LensType2 - Sony lens ids",
          "7275:                           SonySubstitution[buf[0x0107]]);",
          "7276:     }",
          "7277:   if ((imgdata.lens.makernotes.LensID == -1) &&",
          "7278:       (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) &&",
          "7280:     {",
          "7281:       imgdata.lens.makernotes.LensID =   // LensType - Minolta/Sony lens ids",
          "7282:         SonySubstitution[buf[0x010a]] << 8 |",
          "7283:         SonySubstitution[buf[0x0109]];",
          "7285:       if ((imgdata.lens.makernotes.LensID > 0x4900) &&",
          "7286:           (imgdata.lens.makernotes.LensID <= 0x5900))",
          "7287:         {",
          "7288:           imgdata.lens.makernotes.AdapterID = 0x4900;",
          "7289:           imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;",
          "7290:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;",
          "7291:           strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");",
          "7292:         }",
          "7294:       else if ((imgdata.lens.makernotes.LensID > 0xEF00) &&",
          "7295:           (imgdata.lens.makernotes.LensID < 0xFFFF)      &&",
          "7296:           (imgdata.lens.makernotes.LensID != 0xFF00))",
          "7297:         {",
          "7298:           imgdata.lens.makernotes.AdapterID = 0xEF00;",
          "7299:           imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;",
          "7300:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "7301:         }",
          "7307:     parseSonyLensFeatures (SonySubstitution[buf[0x115]],",
          "7308:                            SonySubstitution[buf[0x116]]);",
          "7310:     parseSonyLensFeatures (SonySubstitution[buf[0x116]],",
          "7311:                            SonySubstitution[buf[0x117]]);",
          "7313:    if ((id==347) || (id==350) || (id==357))",
          "7314:    {",
          "7315:      unsigned long b88 = SonySubstitution[buf[0x88]];",
          "7316:      unsigned long b89 = SonySubstitution[buf[0x89]];",
          "7317:      unsigned long b8a = SonySubstitution[buf[0x8a]];",
          "7318:      unsigned long b8b = SonySubstitution[buf[0x8b]];",
          "7319:      unsigned long b8c = SonySubstitution[buf[0x8c]];",
          "7320:      unsigned long b8d = SonySubstitution[buf[0x8d]];",
          "7321:      sprintf(imgdata.shootinginfo.InternalBodySerial, \"%06lx\",",
          "7322:      (b88<<40) + (b89<<32) + (b8a<<24) + (b8b<<16) + (b8c<<8) + b8d);",
          "7323:    }",
          "7324:    else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) && (id > 279) && (id != 282) && (id != 283))",
          "7325:    {",
          "7326:      unsigned long bf0 = SonySubstitution[buf[0xf0]];",
          "7327:      unsigned long bf1 = SonySubstitution[buf[0xf1]];",
          "7328:      unsigned long bf2 = SonySubstitution[buf[0xf2]];",
          "7329:      unsigned long bf3 = SonySubstitution[buf[0xf3]];",
          "7330:      unsigned long bf4 = SonySubstitution[buf[0xf4]];",
          "7331:      sprintf(imgdata.shootinginfo.InternalBodySerial, \"%05lx\",",
          "7332:       (bf0<<32) + (bf1<<24) + (bf2<<16) + (bf3<<8) +bf4);",
          "7333:    }",
          "7334:    else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E) && (id != 288) && (id != 289)  && (id != 290))",
          "7335:    {",
          "7336:      unsigned b7c = SonySubstitution[buf[0x7c]];",
          "7337:      unsigned b7d = SonySubstitution[buf[0x7d]];",
          "7338:      unsigned b7e = SonySubstitution[buf[0x7e]];",
          "7339:      unsigned b7f = SonySubstitution[buf[0x7f]];",
          "7340:      sprintf(imgdata.shootinginfo.InternalBodySerial, \"%04x\",",
          "7341:      (b7c<<24) + (b7d<<16) + (b7e<<8) + b7f);",
          "7342:    }",
          "",
          "[Added Lines]",
          "7990:     memmove(imgdata.lens.makernotes.LensFeatures_suf, imgdata.lens.makernotes.LensFeatures_suf + 1,",
          "7991:             strbuflen(imgdata.lens.makernotes.LensFeatures_suf) - 1);",
          "7997: void CLASS process_Sony_0x940c(uchar *buf)",
          "8002:   {",
          "8003:     switch (SonySubstitution[buf[0x0008]])",
          "8005:     case 1:",
          "8006:     case 5:",
          "8007:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;",
          "8008:       break;",
          "8009:     case 4:",
          "8010:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;",
          "8011:       break;",
          "8013:   }",
          "8014:   lid2 = (((ushort)SonySubstitution[buf[0x000a]]) << 8) | ((ushort)SonySubstitution[buf[0x0009]]);",
          "8016:     parseSonyLensType2(SonySubstitution[buf[0x000a]], // LensType2 - Sony lens ids",
          "8017:                        SonySubstitution[buf[0x0009]]);",
          "8021: void CLASS process_Sony_0x9050(uchar *buf, unsigned id)",
          "8027:   {",
          "8028:     if (buf[0])",
          "8029:       imgdata.lens.makernotes.MaxAp4CurFocal =",
          "8030:           my_roundf(powf64(2.0f, ((float)SonySubstitution[buf[0]] / 8.0 - 1.06f) / 2.0f) * 10.0f) / 10.0f;",
          "8032:     if (buf[1])",
          "8033:       imgdata.lens.makernotes.MinAp4CurFocal =",
          "8034:           my_roundf(powf64(2.0f, ((float)SonySubstitution[buf[1]] / 8.0 - 1.06f) / 2.0f) * 10.0f) / 10.0f;",
          "8035:   }",
          "8038:   {",
          "8039:     if (buf[0x3d] | buf[0x3c])",
          "8041:       lid = SonySubstitution[buf[0x3d]] << 8 | SonySubstitution[buf[0x3c]];",
          "8042:       imgdata.lens.makernotes.CurAp = powf64(2.0f, ((float)lid / 256.0f - 16.0f) / 2.0f);",
          "8043:     }",
          "8044:     if (buf[0x105] && (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&",
          "8045:         (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))",
          "8046:       imgdata.lens.makernotes.LensMount = SonySubstitution[buf[0x105]];",
          "8047:     if (buf[0x106])",
          "8048:       imgdata.lens.makernotes.LensFormat = SonySubstitution[buf[0x106]];",
          "8049:   }",
          "8052:   {",
          "8053:     parseSonyLensType2(SonySubstitution[buf[0x0108]], // LensType2 - Sony lens ids",
          "8054:                        SonySubstitution[buf[0x0107]]);",
          "8055:   }",
          "8056:   if ((imgdata.lens.makernotes.LensID == -1) && (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) &&",
          "8058:   {",
          "8059:     imgdata.lens.makernotes.LensID = // LensType - Minolta/Sony lens ids",
          "8060:         SonySubstitution[buf[0x010a]] << 8 | SonySubstitution[buf[0x0109]];",
          "8062:     if ((imgdata.lens.makernotes.LensID > 0x4900) && (imgdata.lens.makernotes.LensID <= 0x5900))",
          "8063:     {",
          "8064:       imgdata.lens.makernotes.AdapterID = 0x4900;",
          "8065:       imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;",
          "8066:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;",
          "8067:       strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");",
          "8068:     }",
          "8070:     else if ((imgdata.lens.makernotes.LensID > 0xEF00) && (imgdata.lens.makernotes.LensID < 0xFFFF) &&",
          "8071:              (imgdata.lens.makernotes.LensID != 0xFF00))",
          "8072:     {",
          "8073:       imgdata.lens.makernotes.AdapterID = 0xEF00;",
          "8074:       imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;",
          "8075:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "8077:   }",
          "8082:     parseSonyLensFeatures(SonySubstitution[buf[0x115]], SonySubstitution[buf[0x116]]);",
          "8084:     parseSonyLensFeatures(SonySubstitution[buf[0x116]], SonySubstitution[buf[0x117]]);",
          "8086:   if ((id == 347) || (id == 350) || (id == 357))",
          "8087:   {",
          "8088:     unsigned long b88 = SonySubstitution[buf[0x88]];",
          "8089:     unsigned long b89 = SonySubstitution[buf[0x89]];",
          "8090:     unsigned long b8a = SonySubstitution[buf[0x8a]];",
          "8091:     unsigned long b8b = SonySubstitution[buf[0x8b]];",
          "8092:     unsigned long b8c = SonySubstitution[buf[0x8c]];",
          "8093:     unsigned long b8d = SonySubstitution[buf[0x8d]];",
          "8094:     sprintf(imgdata.shootinginfo.InternalBodySerial, \"%06lx\",",
          "8095:             (b88 << 40) + (b89 << 32) + (b8a << 24) + (b8b << 16) + (b8c << 8) + b8d);",
          "8096:   }",
          "8097:   else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) && (id > 279) && (id != 282) && (id != 283))",
          "8098:   {",
          "8099:     unsigned long bf0 = SonySubstitution[buf[0xf0]];",
          "8100:     unsigned long bf1 = SonySubstitution[buf[0xf1]];",
          "8101:     unsigned long bf2 = SonySubstitution[buf[0xf2]];",
          "8102:     unsigned long bf3 = SonySubstitution[buf[0xf3]];",
          "8103:     unsigned long bf4 = SonySubstitution[buf[0xf4]];",
          "8104:     sprintf(imgdata.shootinginfo.InternalBodySerial, \"%05lx\",",
          "8105:             (bf0 << 32) + (bf1 << 24) + (bf2 << 16) + (bf3 << 8) + bf4);",
          "8106:   }",
          "8107:   else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E) && (id != 288) && (id != 289) && (id != 290))",
          "8108:   {",
          "8109:     unsigned b7c = SonySubstitution[buf[0x7c]];",
          "8110:     unsigned b7d = SonySubstitution[buf[0x7d]];",
          "8111:     unsigned b7e = SonySubstitution[buf[0x7e]];",
          "8112:     unsigned b7f = SonySubstitution[buf[0x7f]];",
          "8113:     sprintf(imgdata.shootinginfo.InternalBodySerial, \"%04x\", (b7c << 24) + (b7d << 16) + (b7e << 8) + b7f);",
          "8114:   }",
          "",
          "---------------",
          "--- Hunk 78 ---",
          "[Context before]",
          "7370:   INT64 fsize = ifp->size();",
          "7372:   fread(buf, 1, 10, ifp);",
          "7374:     base = ftell(ifp);",
          "7375:     order = get2();",
          "7377:     offset = get4();",
          "7378:     fseek(ifp, offset - 8, SEEK_CUR);",
          "7379:   }",
          "7383:     base = ftell(ifp) - 10;",
          "7384:     fseek(ifp, -2, SEEK_CUR);",
          "7385:     order = get2();",
          "7387:   }",
          "7390:     goto nf;",
          "7391:   }",
          "7393:     base = ftell(ifp) - 10;",
          "7395:     fseek(ifp, 2, SEEK_CUR);",
          "7396:   }",
          "7401:     fseek(ifp, -2, SEEK_CUR);",
          "7404:     fseek(ifp, -4, SEEK_CUR);",
          "7406:     fseek(ifp, -10, SEEK_CUR);",
          "7409:       base = ftell(ifp);",
          "7410:   }",
          "7412:   entries = get2();",
          "7414:   morder = order;",
          "7417:     order = morder;",
          "7418:     tiff_get(base, &tag, &type, &len, &save);",
          "7419:     INT64 pos = ifp->tell();",
          "7421:     tag |= uptag << 16;",
          "7425:       {",
          "7450:       }",
          "7452:     else if (!strncmp(make, \"FUJI\", 4))",
          "7455:     else if (!strncasecmp(make, \"LEICA\", 5))",
          "7456:       {",
          "7458:         {",
          "7464:           {",
          "7466:           }",
          "7471:           {",
          "7493:           }",
          "7510:       }",
          "7512:     else if (!strncmp(make, \"NIKON\", 5))",
          "7516:           {",
          "7518:             {",
          "7527:             }",
          "7567:             {",
          "7570:             }",
          "7571:           }",
          "7651:       }",
          "7654:       {",
          "7724:           break;",
          "7727:           break;",
          "7732:           break;",
          "7735:           break;",
          "7741:           break;",
          "7744:           break;",
          "7747:           break;",
          "7751:         }",
          "7753:       }",
          "7758:       {",
          "7781:           {",
          "7784:           }",
          "7793:           {",
          "7796:           }",
          "7800:         }",
          "7806:         {",
          "7808:         }",
          "7810:         {",
          "7812:         }",
          "7814:         {",
          "7816:         }",
          "7818:         {",
          "7820:         }",
          "7822:         {",
          "7824:         }",
          "7826:         {",
          "7828:         }",
          "7830:         {",
          "7841:         }",
          "7843:         {",
          "7846:         }",
          "7848:         {",
          "7873:           {",
          "7880:           }",
          "7881:       }",
          "7885:       {",
          "7926:       }",
          "7936:       {",
          "7940:           {",
          "7958:           }",
          "7973:           {",
          "8017:           }",
          "8133:       }",
          "8134:   next:",
          "8136:   }",
          "8138:   order = sorder;",
          "8139: }",
          "8141: #else",
          "8146: #endif",
          "8150: {",
          "8153:   uchar buf97[324], ci, cj, ck;",
          "8155:   char buf[10];",
          "8156:   unsigned SamsungKey[11];",
          "8157:   uchar NikonKey;",
          "",
          "[Removed Lines]",
          "7373:   if (!strcmp(buf, \"Nikon\")) {",
          "7376:     if (get2() != 42) goto quit;",
          "7380:   else if (!strcmp(buf, \"OLYMPUS\") ||",
          "7381:            !strcmp(buf, \"PENTAX \") ||",
          "7382:            (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG))) {",
          "7386:     if (buf[0] == 'O') get2();",
          "7388:   else if (!strncmp(buf, \"SONY\", 4) ||",
          "7389:            !strcmp(buf, \"Panasonic\")) {",
          "7392:   else if (!strncmp(buf, \"FUJIFILM\", 8)) {",
          "7394:   nf: order = 0x4949;",
          "7397:   else if (!strcmp(buf, \"OLYMP\") ||",
          "7398:            !strcmp(buf, \"LEICA\") ||",
          "7399:            !strcmp(buf, \"Ricoh\") ||",
          "7400:            !strcmp(buf, \"EPSON\"))",
          "7402:   else if (!strcmp(buf, \"AOC\") ||",
          "7403:            !strcmp(buf, \"QVC\"))",
          "7405:   else {",
          "7407:     if ((!strncmp(make, \"SAMSUNG\", 7) &&",
          "7408:     (dng_writer == AdobeDNG)))",
          "7413:   if (entries > 1000) return;",
          "7416:   while (entries--) {",
          "7420:     if(len > 8 && pos+len > 2* fsize) continue;",
          "7422:     if(len > 100*1024*1024) goto next; // 100Mb tag? No!",
          "7424:     if (!strncmp(make, \"Canon\",5))",
          "7426:         if (tag == 0x000d && len < 256000) // camera info",
          "7427:           {",
          "7428:             CanonCameraInfo = (uchar*)malloc(len);",
          "7429:             fread(CanonCameraInfo, len, 1, ifp);",
          "7430:             lenCanonCameraInfo = len;",
          "7431:           }",
          "7433:         else if (tag == 0x10)  // Canon ModelID",
          "7434:           {",
          "7435:             unique_id = get4();",
          "7436:             if (unique_id == 0x03740000) unique_id = 0x80000374; // M3",
          "7437:             if (unique_id == 0x03840000) unique_id = 0x80000384; // M10",
          "7438:             if (unique_id == 0x03940000) unique_id = 0x80000394; // M5",
          "7439:             setCanonBodyFeatures(unique_id);",
          "7440:             if (lenCanonCameraInfo)",
          "7441:               {",
          "7442:                 processCanonCameraInfo(unique_id, CanonCameraInfo,lenCanonCameraInfo);",
          "7443:                 free(CanonCameraInfo);",
          "7444:                 CanonCameraInfo = 0;",
          "7445:                 lenCanonCameraInfo = 0;",
          "7446:               }",
          "7447:           }",
          "7449:         else parseCanonMakernotes (tag, type, len);",
          "7453:       parseFujiMakernotes (tag, type);",
          "7457:         if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))",
          "7459:           int ind = tag == 0x035e?0:1;",
          "7460:        for (int j=0; j < 3; j++)",
          "7461:         FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c]= getreal(type);",
          "7462:         }",
          "7463:         if ((tag == 0x0303) && (type != 4))",
          "7465:             stmread(imgdata.lens.makernotes.Lens, len,ifp);",
          "7468:         if ((tag == 0x3405) ||",
          "7469:             (tag == 0x0310) ||",
          "7470:             (tag == 0x34003405))",
          "7472:             imgdata.lens.makernotes.LensID = get4();",
          "7473:             imgdata.lens.makernotes.LensID =",
          "7474:               ((imgdata.lens.makernotes.LensID>>2)<<8) |",
          "7475:               (imgdata.lens.makernotes.LensID & 0x3);",
          "7476:             if (imgdata.lens.makernotes.LensID != -1)",
          "7477:               {",
          "7478:                 if ((model[0] == 'M') ||",
          "7479:                     !strncasecmp (model, \"LEICA M\", 7))",
          "7480:                   {",
          "7481:                     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;",
          "7482:                     if (imgdata.lens.makernotes.LensID)",
          "7483:                       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;",
          "7484:                   }",
          "7485:                 else if ((model[0] == 'S') ||",
          "7486:                          !strncasecmp (model, \"LEICA S\", 7))",
          "7487:                   {",
          "7488:                     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;",
          "7489:                     if (imgdata.lens.makernotes.Lens[0])",
          "7490:                       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;",
          "7491:                   }",
          "7492:               }",
          "7495:         else if (",
          "7496:                  ((tag == 0x0313) || (tag == 0x34003406)) &&",
          "7497:                  (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&",
          "7498:                  ((type == 10) || (type == 5))",
          "7499:                 )",
          "7500:           {",
          "7501:             imgdata.lens.makernotes.CurAp = getreal(type);",
          "7502:             if (imgdata.lens.makernotes.CurAp > 126.3)",
          "7503:               imgdata.lens.makernotes.CurAp = 0.0f;",
          "7504:           }",
          "7506:         else if (tag == 0x3400)",
          "7507:           {",
          "7508:             parse_makernote (base, 0x3400);",
          "7509:           }",
          "7513:       {",
          "7514:         if (tag == 0x1d)       // serial number",
          "7515:           while ((c = fgetc(ifp)) && c != EOF)",
          "7517:             if ((!custom_serial) && (!isdigit(c)))",
          "7519:               if ((strbuflen(model) == 3) && (!strcmp(model,\"D50\")))",
          "7520:               {",
          "7521:                 custom_serial = 34;",
          "7522:               }",
          "7523:               else",
          "7524:               {",
          "7525:                 custom_serial = 96;",
          "7526:               }",
          "7528:             serial = serial*10 + (isdigit(c) ? c - '0' : c % 10);",
          "7529:           }",
          "7530:         else if (tag == 0x000a)",
          "7531:           {",
          "7532:             imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "7533:             imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "7534:           }",
          "7535:         else if (tag == 0x0082)    // lens attachment",
          "7536:           {",
          "7537:             stmread(imgdata.lens.makernotes.Attachment, len, ifp);",
          "7538:           }",
          "7539:         else if (tag == 0x0083)    // lens type",
          "7540:           {",
          "7541:             imgdata.lens.nikon.NikonLensType = fgetc(ifp);",
          "7542:           }",
          "7543:         else if (tag == 0x0084)    // lens",
          "7544:           {",
          "7545:             imgdata.lens.makernotes.MinFocal = getreal(type);",
          "7546:             imgdata.lens.makernotes.MaxFocal = getreal(type);",
          "7547:             imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);",
          "7548:             imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);",
          "7549:           }",
          "7550:         else if (tag == 0x008b)    // lens f-stops",
          "7551:           {",
          "7552:             uchar a, b, c;",
          "7553:             a = fgetc(ifp);",
          "7554:             b = fgetc(ifp);",
          "7555:             c = fgetc(ifp);",
          "7556:             if (c)",
          "7557:               {",
          "7558:                 imgdata.lens.nikon.NikonLensFStops = a*b*(12/c);",
          "7559:                 imgdata.lens.makernotes.LensFStops =",
          "7560:                   (float)imgdata.lens.nikon.NikonLensFStops /12.0f;",
          "7561:               }",
          "7562:           }",
          "7563:         else if (tag == 0x0093)",
          "7564:           {",
          "7565:             i = get2();",
          "7566:             if ((i == 7) || (i == 9))",
          "7568:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "7569:               imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "7572:         else if (tag == 0x0097)",
          "7573:           {",
          "7574:             for (i=0; i < 4; i++)",
          "7575:              ver97 = ver97 * 10 + fgetc(ifp)-'0';",
          "7576:            if (ver97 == 601)  // Coolpix A",
          "7577:            {",
          "7578:              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "7579:                     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "7580:            }",
          "7581:          }",
          "7582:         else if (tag == 0x0098)    // contains lens data",
          "7583:           {",
          "7584:             for (i = 0; i < 4; i++)",
          "7585:               {",
          "7586:                 NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';",
          "7587:               }",
          "7588:             switch (NikonLensDataVersion)",
          "7589:               {",
          "7590:               case 100: lenNikonLensData = 9; break;",
          "7591:               case 101:",
          "7592:               case 201: // encrypted, starting from v.201",
          "7593:               case 202:",
          "7594:               case 203: lenNikonLensData = 15; break;",
          "7595:               case 204: lenNikonLensData = 16; break;",
          "7596:               case 400: lenNikonLensData = 459; break;",
          "7597:               case 401: lenNikonLensData = 590; break;",
          "7598:               case 402: lenNikonLensData = 509; break;",
          "7599:               case 403: lenNikonLensData = 879; break;",
          "7600:               }",
          "7601:             if(lenNikonLensData)",
          "7602:               {",
          "7603:                 table_buf = (uchar*)malloc(lenNikonLensData);",
          "7604:                 fread(table_buf, lenNikonLensData, 1, ifp);",
          "7605:                 if ((NikonLensDataVersion < 201) && lenNikonLensData)",
          "7606:                   {",
          "7607:                     processNikonLensData(table_buf, lenNikonLensData);",
          "7608:                     free(table_buf);",
          "7609:                     lenNikonLensData = 0;",
          "7610:                   }",
          "7611:               }",
          "7612:           }",
          "7614:         else if (tag == 0xa7)     // shutter count",
          "7615:           {",
          "7616:             NikonKey = fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp);",
          "7617:             if ((NikonLensDataVersion > 200) && lenNikonLensData)",
          "7618:             {",
          "7619:               if (custom_serial)",
          "7620:               {",
          "7621:                 ci = xlat[0][custom_serial];",
          "7622:               }",
          "7623:               else",
          "7624:               {",
          "7625:                 ci = xlat[0][serial & 0xff];",
          "7626:               }",
          "7627:               cj = xlat[1][NikonKey];",
          "7628:               ck = 0x60;",
          "7629:               for (i = 0; i < lenNikonLensData; i++)",
          "7630:                 table_buf[i] ^= (cj += ci * ck++);",
          "7631:               processNikonLensData(table_buf, lenNikonLensData);",
          "7632:               lenNikonLensData = 0;",
          "7633:               free(table_buf);",
          "7634:             }",
          "7635:           }",
          "7636:         else if (tag == 0x00a8)  // contains flash data",
          "7637:           {",
          "7638:            for (i = 0; i < 4; i++)",
          "7639:               {",
          "7640:                 NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';",
          "7641:               }",
          "7642:           }",
          "7644:         else if (tag == 37 && (!iso_speed || iso_speed == 65535))",
          "7645:           {",
          "7646:             unsigned char cc;",
          "7647:             fread(&cc, 1, 1, ifp);",
          "7648:             iso_speed = (int)(100.0 * powf64(2.0, (double)(cc) / 12.0 - 5.0));",
          "7649:             break;",
          "7650:           }",
          "7653:     else if (!strncmp(make, \"OLYMPUS\", 7))",
          "7655:         int SubDirOffsetValid =",
          "7656:               strncmp (model, \"E-300\", 5) &&",
          "7657:               strncmp (model, \"E-330\", 5) &&",
          "7658:               strncmp (model, \"E-400\", 5) &&",
          "7659:               strncmp (model, \"E-500\", 5) &&",
          "7660:               strncmp (model, \"E-1\", 3);",
          "7662:         if ((tag == 0x2010) || (tag == 0x2020))",
          "7663:           {",
          "7664:             fseek(ifp, save - 4, SEEK_SET);",
          "7665:             fseek(ifp, base + get4(), SEEK_SET);",
          "7666:             parse_makernote_0xc634(base, tag, dng_writer);",
          "7667:           }",
          "7668:         if (!SubDirOffsetValid &&",
          "7669:             ((len > 4) ||",
          "7670:              ( ((type == 3) || (type == 8)) && (len > 2))  ||",
          "7671:              ( ((type == 4) || (type == 9)) && (len > 1))  || (type == 5) || (type > 9)))",
          "7672:         goto skip_Oly_broken_tags;",
          "7674:         switch (tag) {",
          "7675:         case 0x0207:",
          "7676:         case 0x20100100:",
          "7677:           {",
          "7678:             uchar sOlyID[8];",
          "7679:             unsigned long long OlyID;",
          "7680:             fread (sOlyID, MIN(len,7), 1, ifp);",
          "7681:      sOlyID[7] = 0;",
          "7682:             OlyID = sOlyID[0];",
          "7683:             i = 1;",
          "7684:             while (i < 7 && sOlyID[i])",
          "7685:               {",
          "7686:                 OlyID = OlyID << 8 | sOlyID[i];",
          "7687:                 i++;",
          "7688:               }",
          "7689:             setOlympusBodyFeatures(OlyID);",
          "7690:           }",
          "7691:           break;",
          "7692:         case 0x1002:",
          "7693:           imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type)/2);",
          "7694:           break;",
          "7695:         case 0x20100102:",
          "7696:             stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);",
          "7697:         break;",
          "7698:         case 0x20100201:",
          "7699:           imgdata.lens.makernotes.LensID =",
          "7700:             (unsigned long long)fgetc(ifp)<<16 |",
          "7701:             (unsigned long long)(fgetc(ifp), fgetc(ifp))<<8 |",
          "7702:             (unsigned long long)fgetc(ifp);",
          "7703:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;",
          "7704:           imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;",
          "7705:           if (((imgdata.lens.makernotes.LensID < 0x20000) ||",
          "7706:                (imgdata.lens.makernotes.LensID > 0x4ffff)) &&",
          "7707:               (imgdata.lens.makernotes.LensID & 0x10))",
          "7708:             {",
          "7709:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;",
          "7710:             }",
          "7711:           break;",
          "7712:         case 0x20100202:",
          "7713:           if ((!imgdata.lens.LensSerial[0]))",
          "7714:               stmread(imgdata.lens.LensSerial, len, ifp);",
          "7715:           break;",
          "7716:         case 0x20100203:",
          "7717:           stmread(imgdata.lens.makernotes.Lens,len, ifp);",
          "7718:           break;",
          "7719:         case 0x20100205:",
          "7720:           imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "7721:           break;",
          "7722:         case 0x20100206:",
          "7723:           imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "7725:         case 0x20100207:",
          "7726:           imgdata.lens.makernotes.MinFocal = (float)get2();",
          "7728:         case 0x20100208:",
          "7729:           imgdata.lens.makernotes.MaxFocal = (float)get2();",
          "7730:           if (imgdata.lens.makernotes.MaxFocal > 1000.0f)",
          "7731:             imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;",
          "7733:         case 0x2010020a:",
          "7734:           imgdata.lens.makernotes.MaxAp4CurFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "7736:         case 0x20100301:",
          "7737:           imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;",
          "7738:           fgetc(ifp);",
          "7739:           imgdata.lens.makernotes.TeleconverterID =",
          "7740:             imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);",
          "7742:         case 0x20100303:",
          "7743:           stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);",
          "7745:         case 0x20100403:",
          "7746:           stmread(imgdata.lens.makernotes.Attachment,len, ifp);",
          "7748:         case 0x20200401:",
          "7749:        imgdata.other.FlashEC = getreal(type);",
          "7750:        break;",
          "7752:         skip_Oly_broken_tags:;",
          "7755:     else if (!strncmp(make, \"PENTAX\", 6) ||",
          "7756:              !strncmp(model, \"PENTAX\", 6) ||",
          "7757:              (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG)))",
          "7759:         if (tag == 0x0005)",
          "7760:           {",
          "7761:             unique_id = get4();",
          "7762:             setPentaxBodyFeatures(unique_id);",
          "7763:           }",
          "7764:         else if (tag == 0x0013)",
          "7765:           {",
          "7766:             imgdata.lens.makernotes.CurAp = (float)get2()/10.0f;",
          "7767:           }",
          "7768:         else if (tag == 0x0014)",
          "7769:           {",
          "7770:             PentaxISO(get2());",
          "7771:           }",
          "7772:         else if (tag == 0x001d)",
          "7773:           {",
          "7774:             imgdata.lens.makernotes.CurFocal = (float)get4()/100.0f;",
          "7775:           }",
          "7776:         else if (tag == 0x003f)",
          "7777:           {",
          "7778:             imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);",
          "7779:           }",
          "7780:         else if (tag == 0x004d)",
          "7782:             if (type == 9) imgdata.other.FlashEC = getreal(type) / 256.0f;",
          "7783:             else imgdata.other.FlashEC = (float) ((signed short) fgetc(ifp)) / 6.0f;",
          "7785:          else if (tag == 0x007e)",
          "7786:            {",
          "7787:              imgdata.color.linear_max[0] =",
          "7788:              imgdata.color.linear_max[1] =",
          "7789:              imgdata.color.linear_max[2] =",
          "7790:              imgdata.color.linear_max[3] = (long)(-1) * get4();",
          "7791:            }",
          "7792:         else if (tag == 0x0207)",
          "7794:      if(len < 65535) // Safety belt",
          "7795:                PentaxLensInfo(imgdata.lens.makernotes.CamID, len);",
          "7797:         else if (tag == 0x020d)",
          "7798:         {",
          "7799:                 FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();",
          "7801:         else if (tag == 0x020e)",
          "7802:         {",
          "7803:                 FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();",
          "7804:         }",
          "7805:         else if (tag == 0x020f)",
          "7807:                 FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();",
          "7809:         else if (tag == 0x0210)",
          "7811:                 FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();",
          "7813:         else if (tag == 0x0211)",
          "7815:                 FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();",
          "7817:         else if (tag == 0x0212)",
          "7819:                 FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();",
          "7821:         else if (tag == 0x0213)",
          "7823:                 FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();",
          "7825:         else if (tag == 0x0214)",
          "7827:                 FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();",
          "7829:         else if (tag == 0x0221)",
          "7831:    int nWB = get2();",
          "7832:    if(nWB<=sizeof(imgdata.color.WBCT_Coeffs)/sizeof(imgdata.color.WBCT_Coeffs[0]))",
          "7833:       for (int i = 0; i < nWB; i++)",
          "7834:         {",
          "7835:    imgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();",
          "7836:    fseek(ifp, 2, SEEK_CUR);",
          "7837:    imgdata.color.WBCT_Coeffs[i][1] = get2();",
          "7838:    imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;",
          "7839:    imgdata.color.WBCT_Coeffs[i][3] = get2();",
          "7840:          }",
          "7842:         else if (tag == 0x0215)",
          "7844:           fseek (ifp, 16, SEEK_CUR);",
          "7845:           sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());",
          "7847:         else if (tag == 0x0229)",
          "7849:           stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "7850:         }",
          "7851:         else if (tag == 0x022d)",
          "7852:         {",
          "7853:    fseek (ifp,2,SEEK_CUR);",
          "7854:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();",
          "7855:    getc(ifp);",
          "7856:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();",
          "7857:    getc(ifp);",
          "7858:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();",
          "7859:    getc(ifp);",
          "7860:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();",
          "7861:    getc(ifp);",
          "7862:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();",
          "7863:    getc(ifp);",
          "7864:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();",
          "7865:    getc(ifp);",
          "7866:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();",
          "7867:    getc(ifp);",
          "7868:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();",
          "7869:    getc(ifp);",
          "7870:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ (c >> 1)] = get2();",
          "7871:         }",
          "7872:         else if (tag == 0x0239)  // Q-series lens info (LensInfoQ)",
          "7874:             char LensInfo [20];",
          "7875:             fseek (ifp, 12, SEEK_CUR);",
          "7876:             stread(imgdata.lens.makernotes.Lens, 30, ifp);",
          "7877:             strcat(imgdata.lens.makernotes.Lens, \" \");",
          "7878:             stread(LensInfo, 20, ifp);",
          "7879:             strcat(imgdata.lens.makernotes.Lens, LensInfo);",
          "7883:     else if (!strncmp(make, \"SAMSUNG\", 7) &&",
          "7884:              (dng_writer == AdobeDNG))",
          "7886:         if (tag == 0x0002)",
          "7887:           {",
          "7888:             if(get4() == 0x2000)",
          "7889:               {",
          "7890:                 imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;",
          "7891:               }",
          "7892:             else if (!strncmp(model, \"NX mini\", 7))",
          "7893:               {",
          "7894:                 imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;",
          "7895:               }",
          "7896:             else",
          "7897:               {",
          "7898:                 imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "7899:                 imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "7900:               }",
          "7901:           }",
          "7902:         else if (tag == 0x0003)",
          "7903:           {",
          "7904:             imgdata.lens.makernotes.CamID = unique_id = get4();",
          "7905:           }",
          "7906:         else if (tag == 0xa003)",
          "7907:           {",
          "7908:             imgdata.lens.makernotes.LensID = get2();",
          "7909:             if (imgdata.lens.makernotes.LensID)",
          "7910:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;",
          "7911:           }",
          "7912:         else if (tag == 0xa005)",
          "7913:           {",
          "7914:             stmread(imgdata.lens.InternalLensSerial, len, ifp);",
          "7915:           }",
          "7916:         else if (tag == 0xa019)",
          "7917:           {",
          "7918:             imgdata.lens.makernotes.CurAp = getreal(type);",
          "7919:           }",
          "7920:         else if (tag == 0xa01a)",
          "7921:           {",
          "7922:             imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;",
          "7923:             if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)",
          "7924:               imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;",
          "7925:           }",
          "7928:     else if (!strncasecmp(make, \"SONY\", 4) ||",
          "7929:              !strncasecmp(make, \"Konica\", 6) ||",
          "7930:              !strncasecmp(make, \"Minolta\", 7) ||",
          "7931:              (!strncasecmp(make, \"Hasselblad\", 10) &&",
          "7932:               (!strncasecmp(model, \"Stellar\", 7) ||",
          "7933:                !strncasecmp(model, \"Lunar\", 5) ||",
          "7934:                !strncasecmp(model, \"Lusso\", 5) ||",
          "7935:                !strncasecmp(model, \"HV\",2))))",
          "7937:         ushort lid;",
          "7939:         if (tag == 0xb001)   // Sony ModelID",
          "7941:             unique_id = get2();",
          "7942:             setSonyBodyFeatures(unique_id);",
          "7943:             if (table_buf_0x9050_present)",
          "7944:               {",
          "7945:                 process_Sony_0x9050(table_buf_0x9050, unique_id);",
          "7946:                 free (table_buf_0x9050);",
          "7947:                 table_buf_0x9050_present = 0;",
          "7948:               }",
          "7949:             if (table_buf_0x940c_present)",
          "7950:               {",
          "7951:                 if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)",
          "7952:                   {",
          "7953:                     process_Sony_0x940c(table_buf_0x940c);",
          "7954:                   }",
          "7955:                 free (table_buf_0x940c);",
          "7956:                 table_buf_0x940c_present = 0;",
          "7957:               }",
          "7959:         else if ((tag == 0x0010) &&     // CameraInfo",
          "7960:                  strncasecmp(model, \"DSLR-A100\", 9) &&",
          "7961:                  strncasecmp(model, \"NEX-5C\", 6) &&",
          "7962:                  !strncasecmp(make, \"SONY\", 4) &&",
          "7963:                  ((len == 368) ||   // a700",
          "7964:                   (len == 5478) ||  // a850, a900",
          "7965:                   (len == 5506) ||  // a200, a300, a350",
          "7966:                   (len == 6118) ||  // a230, a290, a330, a380, a390",
          "7971:                   (len == 15360))",
          "7972:                  )",
          "7974:             table_buf = (uchar*)malloc(len);",
          "7975:             fread(table_buf, len, 1, ifp);",
          "7976:             if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&",
          "7977:                 memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))",
          "7978:               {",
          "7979:                 switch (len) {",
          "7980:                 case 368:",
          "7981:                 case 5478:",
          "7983:                   if (saneSonyCameraInfo(table_buf[0], table_buf[3], table_buf[2], table_buf[5], table_buf[4], table_buf[7]))",
          "7984:                     {",
          "7985:                       if (table_buf[0] | table_buf[3])",
          "7986:                         imgdata.lens.makernotes.MinFocal =",
          "7987:                           bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);",
          "7988:                       if (table_buf[2] | table_buf[5])",
          "7989:                         imgdata.lens.makernotes.MaxFocal =",
          "7990:                           bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);",
          "7991:                       if (table_buf[4])",
          "7992:                         imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;",
          "7993:                       if (table_buf[4])",
          "7994:                         imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;",
          "7995:                       parseSonyLensFeatures(table_buf[1], table_buf[6]);",
          "7996:                     }",
          "7997:                   break;",
          "7998:                 default:",
          "8000:                   if (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6]))",
          "8001:                     {",
          "8002:                       if (table_buf[1] | table_buf[2])",
          "8003:                         imgdata.lens.makernotes.MinFocal =",
          "8004:                           bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);",
          "8005:                       if (table_buf[3] | table_buf[4])",
          "8006:                         imgdata.lens.makernotes.MaxFocal =",
          "8007:                           bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);",
          "8008:                       if (table_buf[5])",
          "8009:                         imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;",
          "8010:                       if (table_buf[6])",
          "8011:                         imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;",
          "8012:                       parseSonyLensFeatures(table_buf[0], table_buf[7]);",
          "8013:                     }",
          "8014:                 }",
          "8015:               }",
          "8016:             free(table_buf);",
          "8019:   else if (tag == 0x0104)",
          "8020:     {",
          "8021:       imgdata.other.FlashEC = getreal(type);",
          "8022:     }",
          "8024:         else if (tag == 0x0105)     // Teleconverter",
          "8025:           {",
          "8026:             imgdata.lens.makernotes.TeleconverterID = get2();",
          "8027:           }",
          "8029:         else if (tag == 0x0114 && len < 65535)     // CameraSettings",
          "8030:           {",
          "8031:             table_buf = (uchar*)malloc(len);",
          "8032:             fread(table_buf, len, 1, ifp);",
          "8033:             switch (len) {",
          "8034:             case 280:",
          "8035:             case 364:",
          "8036:             case 332:",
          "8038:               if (table_buf[2] | table_buf[3])",
          "8039:                 {",
          "8040:                   lid = (((ushort)table_buf[2])<<8) |",
          "8041:                     ((ushort)table_buf[3]);",
          "8042:                   imgdata.lens.makernotes.CurAp =",
          "8043:                     powf64(2.0f, ((float)lid/8.0f-1.0f)/2.0f);",
          "8044:                 }",
          "8045:               break;",
          "8046:             case 1536:",
          "8047:             case 2048:",
          "8049:               parseSonyLensType2(table_buf[1016], table_buf[1015]);",
          "8050:               if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)",
          "8051:                 {",
          "8052:                   switch (table_buf[153]) {",
          "8053:                   case 16: imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A; break;",
          "8054:                   case 17: imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E; break;",
          "8055:                   }",
          "8056:                 }",
          "8057:               break;",
          "8058:             }",
          "8059:             free(table_buf);",
          "8060:           }",
          "8062:         else if (tag == 0x9050 && len < 256000)  // little endian",
          "8063:           {",
          "8064:             table_buf_0x9050 = (uchar*)malloc(len);",
          "8065:             table_buf_0x9050_present = 1;",
          "8066:             fread(table_buf_0x9050, len, 1, ifp);",
          "8068:             if (imgdata.lens.makernotes.CamID)",
          "8069:               {",
          "8070:                 process_Sony_0x9050(table_buf_0x9050, imgdata.lens.makernotes.CamID);",
          "8071:                 free (table_buf_0x9050);",
          "8072:                 table_buf_0x9050_present = 0;",
          "8073:               }",
          "8074:           }",
          "8076:         else if (tag == 0x940c && len < 256000)",
          "8077:           {",
          "8078:             table_buf_0x940c = (uchar*)malloc(len);",
          "8079:             table_buf_0x940c_present = 1;",
          "8080:             fread(table_buf_0x940c, len, 1, ifp);",
          "8081:             if ((imgdata.lens.makernotes.CamID) &&",
          "8082:                 (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E))",
          "8083:               {",
          "8084:                 process_Sony_0x940c(table_buf_0x940c);",
          "8085:                 free(table_buf_0x940c);",
          "8086:                 table_buf_0x940c_present = 0;",
          "8087:               }",
          "8088:           }",
          "8090:         else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))",
          "8091:           {",
          "8092:             imgdata.lens.makernotes.LensID = get4();",
          "8093:             if ((imgdata.lens.makernotes.LensID > 0x4900) &&",
          "8094:                 (imgdata.lens.makernotes.LensID <= 0x5900))",
          "8095:             {",
          "8096:               imgdata.lens.makernotes.AdapterID = 0x4900;",
          "8097:               imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;",
          "8098:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;",
          "8099:               strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");",
          "8100:             }",
          "8102:             else if ((imgdata.lens.makernotes.LensID > 0xEF00) &&",
          "8103:                 (imgdata.lens.makernotes.LensID < 0xFFFF)      &&",
          "8104:                 (imgdata.lens.makernotes.LensID != 0xFF00))",
          "8105:             {",
          "8106:               imgdata.lens.makernotes.AdapterID = 0xEF00;",
          "8107:               imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;",
          "8108:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "8109:             }",
          "8110:             if (tag == 0x010c) imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;",
          "8111:           }",
          "8113:         else if (tag == 0xb02a && len < 256000) // Sony LensSpec",
          "8114:           {",
          "8115:             table_buf = (uchar*)malloc(len);",
          "8116:             fread(table_buf, len, 1, ifp);",
          "8117:             if (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6]))",
          "8118:               {",
          "8119:                 if (table_buf[1] | table_buf[2])",
          "8120:                   imgdata.lens.makernotes.MinFocal =",
          "8121:                     bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);",
          "8122:                 if (table_buf[3] | table_buf[4])",
          "8123:                   imgdata.lens.makernotes.MaxFocal =",
          "8124:                     bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);",
          "8125:                 if (table_buf[5])",
          "8126:                   imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;",
          "8127:                 if (table_buf[6])",
          "8128:                   imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;",
          "8129:                 parseSonyLensFeatures(table_buf[0], table_buf[7]);",
          "8130:               }",
          "8131:             free(table_buf);",
          "8132:           }",
          "8135:     fseek (ifp, save, SEEK_SET);",
          "8137:  quit:",
          "8142: void CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer)",
          "8143: {",
          "8145: }",
          "8149: void CLASS parse_makernote (int base, int uptag)",
          "8151:   unsigned offset=0, entries, tag, type, len, save, c;",
          "8152:   unsigned ver97=0, serial=0, i, wbi=0, wb[4]={0,0,0,0};",
          "8154:   short morder, sorder=order;",
          "",
          "[Added Lines]",
          "8145:   if (!strcmp(buf, \"Nikon\"))",
          "8146:   {",
          "8149:     if (get2() != 42)",
          "8150:       goto quit;",
          "8154:   else if (!strcmp(buf, \"OLYMPUS\") || !strcmp(buf, \"PENTAX \") ||",
          "8155:            (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG)))",
          "8156:   {",
          "8160:     if (buf[0] == 'O')",
          "8161:       get2();",
          "8163:   else if (!strncmp(buf, \"SONY\", 4) || !strcmp(buf, \"Panasonic\"))",
          "8164:   {",
          "8167:   else if (!strncmp(buf, \"FUJIFILM\", 8))",
          "8168:   {",
          "8170:   nf:",
          "8171:     order = 0x4949;",
          "8174:   else if (!strcmp(buf, \"OLYMP\") || !strcmp(buf, \"LEICA\") || !strcmp(buf, \"Ricoh\") || !strcmp(buf, \"EPSON\"))",
          "8176:   else if (!strcmp(buf, \"AOC\") || !strcmp(buf, \"QVC\"))",
          "8178:   else",
          "8179:   {",
          "8181:     if ((!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == AdobeDNG)))",
          "8186:   if (entries > 1000)",
          "8187:     return;",
          "8190:   while (entries--)",
          "8191:   {",
          "8195:     if (len > 8 && pos + len > 2 * fsize)",
          "8196:       continue;",
          "8198:     if (len > 100 * 1024 * 1024)",
          "8199:       goto next; // 100Mb tag? No!",
          "8201:     if (!strncmp(make, \"Canon\", 5))",
          "8202:     {",
          "8203:       if (tag == 0x000d && len < 256000) // camera info",
          "8205:         CanonCameraInfo = (uchar *)malloc(len);",
          "8206:         fread(CanonCameraInfo, len, 1, ifp);",
          "8207:         lenCanonCameraInfo = len;",
          "8208:       }",
          "8210:       else if (tag == 0x10) // Canon ModelID",
          "8211:       {",
          "8212:         unique_id = get4();",
          "8213:         if (unique_id == 0x03740000)",
          "8214:           unique_id = 0x80000374; // M3",
          "8215:         if (unique_id == 0x03840000)",
          "8216:           unique_id = 0x80000384; // M10",
          "8217:         if (unique_id == 0x03940000)",
          "8218:           unique_id = 0x80000394; // M5",
          "8219:         setCanonBodyFeatures(unique_id);",
          "8220:         if (lenCanonCameraInfo)",
          "8221:         {",
          "8222:           processCanonCameraInfo(unique_id, CanonCameraInfo, lenCanonCameraInfo);",
          "8223:           free(CanonCameraInfo);",
          "8224:           CanonCameraInfo = 0;",
          "8225:           lenCanonCameraInfo = 0;",
          "8226:         }",
          "8229:       else",
          "8230:         parseCanonMakernotes(tag, type, len);",
          "8231:     }",
          "8234:       parseFujiMakernotes(tag, type);",
          "8237:     {",
          "8238:       if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))",
          "8239:       {",
          "8240:         int ind = tag == 0x035e ? 0 : 1;",
          "8241:         for (int j = 0; j < 3; j++)",
          "8242:           FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c] = getreal(type);",
          "8243:       }",
          "8244:       if ((tag == 0x0303) && (type != 4))",
          "8246:         stmread(imgdata.lens.makernotes.Lens, len, ifp);",
          "8247:       }",
          "8249:       if ((tag == 0x3405) || (tag == 0x0310) || (tag == 0x34003405))",
          "8250:       {",
          "8251:         imgdata.lens.makernotes.LensID = get4();",
          "8252:         imgdata.lens.makernotes.LensID =",
          "8253:             ((imgdata.lens.makernotes.LensID >> 2) << 8) | (imgdata.lens.makernotes.LensID & 0x3);",
          "8254:         if (imgdata.lens.makernotes.LensID != -1)",
          "8256:           if ((model[0] == 'M') || !strncasecmp(model, \"LEICA M\", 7))",
          "8258:             imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;",
          "8259:             if (imgdata.lens.makernotes.LensID)",
          "8260:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;",
          "8262:           else if ((model[0] == 'S') || !strncasecmp(model, \"LEICA S\", 7))",
          "8264:             imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;",
          "8265:             if (imgdata.lens.makernotes.Lens[0])",
          "8266:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;",
          "8268:         }",
          "8269:       }",
          "8271:       else if (((tag == 0x0313) || (tag == 0x34003406)) && (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&",
          "8272:                ((type == 10) || (type == 5)))",
          "8273:       {",
          "8274:         imgdata.lens.makernotes.CurAp = getreal(type);",
          "8275:         if (imgdata.lens.makernotes.CurAp > 126.3)",
          "8276:           imgdata.lens.makernotes.CurAp = 0.0f;",
          "8277:       }",
          "8279:       else if (tag == 0x3400)",
          "8280:       {",
          "8281:         parse_makernote(base, 0x3400);",
          "8283:     }",
          "8286:     {",
          "8287:       if (tag == 0x1d) // serial number",
          "8288:         while ((c = fgetc(ifp)) && c != EOF)",
          "8289:         {",
          "8290:           if ((!custom_serial) && (!isdigit(c)))",
          "8292:             if ((strbuflen(model) == 3) && (!strcmp(model, \"D50\")))",
          "8294:               custom_serial = 34;",
          "8296:             else",
          "8298:               custom_serial = 96;",
          "8301:           serial = serial * 10 + (isdigit(c) ? c - '0' : c % 10);",
          "8302:         }",
          "8303:       else if (tag == 0x000a)",
          "8304:       {",
          "8305:         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "8306:         imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "8308:       else if (tag == 0x0082) // lens attachment",
          "8310:         stmread(imgdata.lens.makernotes.Attachment, len, ifp);",
          "8311:       }",
          "8312:       else if (tag == 0x0083) // lens type",
          "8313:       {",
          "8314:         imgdata.lens.nikon.NikonLensType = fgetc(ifp);",
          "8315:       }",
          "8316:       else if (tag == 0x0084) // lens",
          "8317:       {",
          "8318:         imgdata.lens.makernotes.MinFocal = getreal(type);",
          "8319:         imgdata.lens.makernotes.MaxFocal = getreal(type);",
          "8320:         imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);",
          "8321:         imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);",
          "8322:       }",
          "8323:       else if (tag == 0x008b) // lens f-stops",
          "8324:       {",
          "8325:         uchar a, b, c;",
          "8326:         a = fgetc(ifp);",
          "8327:         b = fgetc(ifp);",
          "8328:         c = fgetc(ifp);",
          "8329:         if (c)",
          "8330:         {",
          "8331:           imgdata.lens.nikon.NikonLensFStops = a * b * (12 / c);",
          "8332:           imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops / 12.0f;",
          "8333:         }",
          "8334:       }",
          "8335:       else if (tag == 0x0093)",
          "8336:       {",
          "8337:         i = get2();",
          "8338:         if ((i == 7) || (i == 9))",
          "8339:         {",
          "8340:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "8341:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "8342:         }",
          "8343:       }",
          "8344:       else if (tag == 0x0097)",
          "8345:       {",
          "8346:         for (i = 0; i < 4; i++)",
          "8347:           ver97 = ver97 * 10 + fgetc(ifp) - '0';",
          "8348:         if (ver97 == 601) // Coolpix A",
          "8349:         {",
          "8350:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "8351:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "8352:         }",
          "8353:       }",
          "8354:       else if (tag == 0x0098) // contains lens data",
          "8355:       {",
          "8356:         for (i = 0; i < 4; i++)",
          "8357:         {",
          "8358:           NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';",
          "8359:         }",
          "8360:         switch (NikonLensDataVersion)",
          "8361:         {",
          "8362:         case 100:",
          "8363:           lenNikonLensData = 9;",
          "8365:         case 101:",
          "8366:         case 201: // encrypted, starting from v.201",
          "8367:         case 202:",
          "8368:         case 203:",
          "8369:           lenNikonLensData = 15;",
          "8371:         case 204:",
          "8372:           lenNikonLensData = 16;",
          "8374:         case 400:",
          "8375:           lenNikonLensData = 459;",
          "8377:         case 401:",
          "8378:           lenNikonLensData = 590;",
          "8380:         case 402:",
          "8381:           lenNikonLensData = 509;",
          "8383:         case 403:",
          "8384:           lenNikonLensData = 879;",
          "8387:         if (lenNikonLensData)",
          "8388:         {",
          "8389:           table_buf = (uchar *)malloc(lenNikonLensData);",
          "8390:           fread(table_buf, lenNikonLensData, 1, ifp);",
          "8391:           if ((NikonLensDataVersion < 201) && lenNikonLensData)",
          "8392:           {",
          "8393:             processNikonLensData(table_buf, lenNikonLensData);",
          "8394:             free(table_buf);",
          "8395:             lenNikonLensData = 0;",
          "8396:           }",
          "8397:         }",
          "8400:       else if (tag == 0xa7) // shutter count",
          "8402:         NikonKey = fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp);",
          "8403:         if ((NikonLensDataVersion > 200) && lenNikonLensData)",
          "8404:         {",
          "8405:           if (custom_serial)",
          "8407:             ci = xlat[0][custom_serial];",
          "8409:           else",
          "8411:             ci = xlat[0][serial & 0xff];",
          "8413:           cj = xlat[1][NikonKey];",
          "8414:           ck = 0x60;",
          "8415:           for (i = 0; i < lenNikonLensData; i++)",
          "8416:             table_buf[i] ^= (cj += ci * ck++);",
          "8417:           processNikonLensData(table_buf, lenNikonLensData);",
          "8418:           lenNikonLensData = 0;",
          "8419:           free(table_buf);",
          "8421:       }",
          "8422:       else if (tag == 0x00a8) // contains flash data",
          "8423:       {",
          "8424:         for (i = 0; i < 4; i++)",
          "8426:           NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';",
          "8428:       }",
          "8430:       else if (tag == 37 && (!iso_speed || iso_speed == 65535))",
          "8431:       {",
          "8432:         unsigned char cc;",
          "8433:         fread(&cc, 1, 1, ifp);",
          "8434:         iso_speed = (int)(100.0 * powf64(2.0, (double)(cc) / 12.0 - 5.0));",
          "8435:         break;",
          "8436:       }",
          "8437:     }",
          "8439:     else if (!strncmp(make, \"OLYMPUS\", 7))",
          "8440:     {",
          "8441:       int SubDirOffsetValid = strncmp(model, \"E-300\", 5) && strncmp(model, \"E-330\", 5) && strncmp(model, \"E-400\", 5) &&",
          "8442:                               strncmp(model, \"E-500\", 5) && strncmp(model, \"E-1\", 3);",
          "8444:       if ((tag == 0x2010) || (tag == 0x2020))",
          "8445:       {",
          "8446:         fseek(ifp, save - 4, SEEK_SET);",
          "8447:         fseek(ifp, base + get4(), SEEK_SET);",
          "8448:         parse_makernote_0xc634(base, tag, dng_writer);",
          "8449:       }",
          "8450:       if (!SubDirOffsetValid && ((len > 4) || (((type == 3) || (type == 8)) && (len > 2)) ||",
          "8451:                                  (((type == 4) || (type == 9)) && (len > 1)) || (type == 5) || (type > 9)))",
          "8452:         goto skip_Oly_broken_tags;",
          "8454:       switch (tag)",
          "8455:       {",
          "8456:       case 0x0207:",
          "8457:       case 0x20100100:",
          "8458:       {",
          "8459:         uchar sOlyID[8];",
          "8460:         unsigned long long OlyID;",
          "8461:         fread(sOlyID, MIN(len, 7), 1, ifp);",
          "8462:         sOlyID[7] = 0;",
          "8463:         OlyID = sOlyID[0];",
          "8464:         i = 1;",
          "8465:         while (i < 7 && sOlyID[i])",
          "8467:           OlyID = OlyID << 8 | sOlyID[i];",
          "8468:           i++;",
          "8470:         setOlympusBodyFeatures(OlyID);",
          "8471:       }",
          "8472:       break;",
          "8473:       case 0x1002:",
          "8474:         imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type) / 2);",
          "8475:         break;",
          "8476:       case 0x20100102:",
          "8477:         stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);",
          "8478:         break;",
          "8479:       case 0x20100201:",
          "8480:         imgdata.lens.makernotes.LensID = (unsigned long long)fgetc(ifp) << 16 |",
          "8481:                                          (unsigned long long)(fgetc(ifp), fgetc(ifp)) << 8 |",
          "8482:                                          (unsigned long long)fgetc(ifp);",
          "8483:         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;",
          "8484:         imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;",
          "8485:         if (((imgdata.lens.makernotes.LensID < 0x20000) || (imgdata.lens.makernotes.LensID > 0x4ffff)) &&",
          "8486:             (imgdata.lens.makernotes.LensID & 0x10))",
          "8488:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;",
          "8490:         break;",
          "8491:       case 0x20100202:",
          "8492:         if ((!imgdata.lens.LensSerial[0]))",
          "8493:           stmread(imgdata.lens.LensSerial, len, ifp);",
          "8494:         break;",
          "8495:       case 0x20100203:",
          "8496:         stmread(imgdata.lens.makernotes.Lens, len, ifp);",
          "8497:         break;",
          "8498:       case 0x20100205:",
          "8499:         imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "8500:         break;",
          "8501:       case 0x20100206:",
          "8502:         imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "8503:         break;",
          "8504:       case 0x20100207:",
          "8505:         imgdata.lens.makernotes.MinFocal = (float)get2();",
          "8506:         break;",
          "8507:       case 0x20100208:",
          "8508:         imgdata.lens.makernotes.MaxFocal = (float)get2();",
          "8509:         if (imgdata.lens.makernotes.MaxFocal > 1000.0f)",
          "8510:           imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;",
          "8511:         break;",
          "8512:       case 0x2010020a:",
          "8513:         imgdata.lens.makernotes.MaxAp4CurFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "8514:         break;",
          "8515:       case 0x20100301:",
          "8516:         imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;",
          "8517:         fgetc(ifp);",
          "8518:         imgdata.lens.makernotes.TeleconverterID = imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);",
          "8519:         break;",
          "8520:       case 0x20100303:",
          "8521:         stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);",
          "8522:         break;",
          "8523:       case 0x20100403:",
          "8524:         stmread(imgdata.lens.makernotes.Attachment, len, ifp);",
          "8525:         break;",
          "8526:       case 0x20200401:",
          "8527:         imgdata.other.FlashEC = getreal(type);",
          "8528:         break;",
          "8529:       }",
          "8530:     skip_Oly_broken_tags:;",
          "8531:     }",
          "8533:     else if (!strncmp(make, \"PENTAX\", 6) || !strncmp(model, \"PENTAX\", 6) ||",
          "8534:              (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG)))",
          "8535:     {",
          "8536:       if (tag == 0x0005)",
          "8537:       {",
          "8538:         unique_id = get4();",
          "8539:         setPentaxBodyFeatures(unique_id);",
          "8540:       }",
          "8541:       else if (tag == 0x0013)",
          "8542:       {",
          "8543:         imgdata.lens.makernotes.CurAp = (float)get2() / 10.0f;",
          "8544:       }",
          "8545:       else if (tag == 0x0014)",
          "8546:       {",
          "8547:         PentaxISO(get2());",
          "8548:       }",
          "8549:       else if (tag == 0x001d)",
          "8550:       {",
          "8551:         imgdata.lens.makernotes.CurFocal = (float)get4() / 100.0f;",
          "8552:       }",
          "8553:       else if (tag == 0x003f)",
          "8554:       {",
          "8555:         imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);",
          "8556:       }",
          "8557:       else if (tag == 0x004d)",
          "8558:       {",
          "8559:         if (type == 9)",
          "8560:           imgdata.other.FlashEC = getreal(type) / 256.0f;",
          "8561:         else",
          "8562:           imgdata.other.FlashEC = (float)((signed short)fgetc(ifp)) / 6.0f;",
          "8563:       }",
          "8564:       else if (tag == 0x007e)",
          "8565:       {",
          "8566:         imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =",
          "8567:             imgdata.color.linear_max[3] = (long)(-1) * get4();",
          "8568:       }",
          "8569:       else if (tag == 0x0207)",
          "8570:       {",
          "8571:         if (len < 65535) // Safety belt",
          "8572:           PentaxLensInfo(imgdata.lens.makernotes.CamID, len);",
          "8573:       }",
          "8574:       else if (tag == 0x020d)",
          "8575:       {",
          "8576:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();",
          "8577:       }",
          "8578:       else if (tag == 0x020e)",
          "8579:       {",
          "8580:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();",
          "8581:       }",
          "8582:       else if (tag == 0x020f)",
          "8583:       {",
          "8584:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();",
          "8585:       }",
          "8586:       else if (tag == 0x0210)",
          "8587:       {",
          "8588:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();",
          "8589:       }",
          "8590:       else if (tag == 0x0211)",
          "8591:       {",
          "8592:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();",
          "8593:       }",
          "8594:       else if (tag == 0x0212)",
          "8595:       {",
          "8596:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();",
          "8597:       }",
          "8598:       else if (tag == 0x0213)",
          "8599:       {",
          "8600:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();",
          "8601:       }",
          "8602:       else if (tag == 0x0214)",
          "8603:       {",
          "8604:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();",
          "8605:       }",
          "8606:       else if (tag == 0x0221)",
          "8607:       {",
          "8608:         int nWB = get2();",
          "8609:         if (nWB <= sizeof(imgdata.color.WBCT_Coeffs) / sizeof(imgdata.color.WBCT_Coeffs[0]))",
          "8610:           for (int i = 0; i < nWB; i++)",
          "8611:           {",
          "8612:             imgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();",
          "8613:             fseek(ifp, 2, SEEK_CUR);",
          "8614:             imgdata.color.WBCT_Coeffs[i][1] = get2();",
          "8615:             imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;",
          "8616:             imgdata.color.WBCT_Coeffs[i][3] = get2();",
          "8617:           }",
          "8618:       }",
          "8619:       else if (tag == 0x0215)",
          "8620:       {",
          "8621:         fseek(ifp, 16, SEEK_CUR);",
          "8622:         sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());",
          "8623:       }",
          "8624:       else if (tag == 0x0229)",
          "8625:       {",
          "8626:         stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "8627:       }",
          "8628:       else if (tag == 0x022d)",
          "8629:       {",
          "8630:         fseek(ifp, 2, SEEK_CUR);",
          "8631:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();",
          "8632:         getc(ifp);",
          "8633:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();",
          "8634:         getc(ifp);",
          "8635:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();",
          "8636:         getc(ifp);",
          "8637:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();",
          "8638:         getc(ifp);",
          "8639:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();",
          "8640:         getc(ifp);",
          "8641:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();",
          "8642:         getc(ifp);",
          "8643:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();",
          "8644:         getc(ifp);",
          "8645:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();",
          "8646:         getc(ifp);",
          "8647:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ (c >> 1)] = get2();",
          "8648:       }",
          "8649:       else if (tag == 0x0239) // Q-series lens info (LensInfoQ)",
          "8650:       {",
          "8651:         char LensInfo[20];",
          "8652:         fseek(ifp, 12, SEEK_CUR);",
          "8653:         stread(imgdata.lens.makernotes.Lens, 30, ifp);",
          "8654:         strcat(imgdata.lens.makernotes.Lens, \" \");",
          "8655:         stread(LensInfo, 20, ifp);",
          "8656:         strcat(imgdata.lens.makernotes.Lens, LensInfo);",
          "8657:       }",
          "8658:     }",
          "8660:     else if (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == AdobeDNG))",
          "8661:     {",
          "8662:       if (tag == 0x0002)",
          "8663:       {",
          "8664:         if (get4() == 0x2000)",
          "8666:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;",
          "8668:         else if (!strncmp(model, \"NX mini\", 7))",
          "8670:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;",
          "8672:         else",
          "8674:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "8675:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "8677:       }",
          "8678:       else if (tag == 0x0003)",
          "8679:       {",
          "8680:         imgdata.lens.makernotes.CamID = unique_id = get4();",
          "8681:       }",
          "8682:       else if (tag == 0xa003)",
          "8683:       {",
          "8684:         imgdata.lens.makernotes.LensID = get2();",
          "8685:         if (imgdata.lens.makernotes.LensID)",
          "8686:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;",
          "8687:       }",
          "8688:       else if (tag == 0xa005)",
          "8689:       {",
          "8690:         stmread(imgdata.lens.InternalLensSerial, len, ifp);",
          "8691:       }",
          "8692:       else if (tag == 0xa019)",
          "8693:       {",
          "8694:         imgdata.lens.makernotes.CurAp = getreal(type);",
          "8695:       }",
          "8696:       else if (tag == 0xa01a)",
          "8697:       {",
          "8698:         imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;",
          "8699:         if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)",
          "8700:           imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;",
          "8701:       }",
          "8702:     }",
          "8704:     else if (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"Konica\", 6) || !strncasecmp(make, \"Minolta\", 7) ||",
          "8705:              (!strncasecmp(make, \"Hasselblad\", 10) &&",
          "8706:               (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) ||",
          "8707:                !strncasecmp(model, \"Lusso\", 5) || !strncasecmp(model, \"HV\", 2))))",
          "8708:     {",
          "8709:       ushort lid;",
          "8711:       if (tag == 0xb001) // Sony ModelID",
          "8712:       {",
          "8713:         unique_id = get2();",
          "8714:         setSonyBodyFeatures(unique_id);",
          "8715:         if (table_buf_0x9050_present)",
          "8717:           process_Sony_0x9050(table_buf_0x9050, unique_id);",
          "8718:           free(table_buf_0x9050);",
          "8719:           table_buf_0x9050_present = 0;",
          "8721:         if (table_buf_0x940c_present)",
          "8723:           if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)",
          "8724:           {",
          "8725:             process_Sony_0x940c(table_buf_0x940c);",
          "8726:           }",
          "8727:           free(table_buf_0x940c);",
          "8728:           table_buf_0x940c_present = 0;",
          "8730:       }",
          "8731:       else if ((tag == 0x0010) && // CameraInfo",
          "8732:                strncasecmp(model, \"DSLR-A100\", 9) && strncasecmp(model, \"NEX-5C\", 6) && !strncasecmp(make, \"SONY\", 4) &&",
          "8733:                ((len == 368) ||  // a700",
          "8734:                 (len == 5478) || // a850, a900",
          "8735:                 (len == 5506) || // a200, a300, a350",
          "8736:                 (len == 6118) || // a230, a290, a330, a380, a390",
          "8741:                 (len == 15360)))",
          "8742:       {",
          "8743:         table_buf = (uchar *)malloc(len);",
          "8744:         fread(table_buf, len, 1, ifp);",
          "8745:         if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&",
          "8746:             memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))",
          "8748:           switch (len)",
          "8750:           case 368:",
          "8751:           case 5478:",
          "8753:             if (saneSonyCameraInfo(table_buf[0], table_buf[3], table_buf[2], table_buf[5], table_buf[4], table_buf[7]))",
          "8754:             {",
          "8755:               if (table_buf[0] | table_buf[3])",
          "8756:                 imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);",
          "8757:               if (table_buf[2] | table_buf[5])",
          "8758:                 imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);",
          "8759:               if (table_buf[4])",
          "8760:                 imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;",
          "8761:               if (table_buf[4])",
          "8762:                 imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;",
          "8763:               parseSonyLensFeatures(table_buf[1], table_buf[6]);",
          "8764:             }",
          "8765:             break;",
          "8766:           default:",
          "8768:             if (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6]))",
          "8769:             {",
          "8770:               if (table_buf[1] | table_buf[2])",
          "8771:                 imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);",
          "8772:               if (table_buf[3] | table_buf[4])",
          "8773:                 imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);",
          "8774:               if (table_buf[5])",
          "8775:                 imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;",
          "8776:               if (table_buf[6])",
          "8777:                 imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;",
          "8778:               parseSonyLensFeatures(table_buf[0], table_buf[7]);",
          "8779:             }",
          "8781:         }",
          "8782:         free(table_buf);",
          "8785:       else if (tag == 0x0104)",
          "8787:         imgdata.other.FlashEC = getreal(type);",
          "8790:       else if (tag == 0x0105) // Teleconverter",
          "8792:         imgdata.lens.makernotes.TeleconverterID = get2();",
          "8793:       }",
          "8795:       else if (tag == 0x0114 && len < 65535) // CameraSettings",
          "8796:       {",
          "8797:         table_buf = (uchar *)malloc(len);",
          "8798:         fread(table_buf, len, 1, ifp);",
          "8799:         switch (len)",
          "8800:         {",
          "8801:         case 280:",
          "8802:         case 364:",
          "8803:         case 332:",
          "8805:           if (table_buf[2] | table_buf[3])",
          "8807:             lid = (((ushort)table_buf[2]) << 8) | ((ushort)table_buf[3]);",
          "8808:             imgdata.lens.makernotes.CurAp = powf64(2.0f, ((float)lid / 8.0f - 1.0f) / 2.0f);",
          "8810:           break;",
          "8811:         case 1536:",
          "8812:         case 2048:",
          "8814:           parseSonyLensType2(table_buf[1016], table_buf[1015]);",
          "8815:           if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)",
          "8817:             switch (table_buf[153])",
          "8818:             {",
          "8819:             case 16:",
          "8820:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;",
          "8821:               break;",
          "8822:             case 17:",
          "8823:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;",
          "8824:               break;",
          "8825:             }",
          "8827:           break;",
          "8828:         }",
          "8829:         free(table_buf);",
          "8830:       }",
          "8832:       else if (tag == 0x9050 && len < 256000) // little endian",
          "8833:       {",
          "8834:         table_buf_0x9050 = (uchar *)malloc(len);",
          "8835:         table_buf_0x9050_present = 1;",
          "8836:         fread(table_buf_0x9050, len, 1, ifp);",
          "8838:         if (imgdata.lens.makernotes.CamID)",
          "8839:         {",
          "8840:           process_Sony_0x9050(table_buf_0x9050, imgdata.lens.makernotes.CamID);",
          "8841:           free(table_buf_0x9050);",
          "8842:           table_buf_0x9050_present = 0;",
          "8843:         }",
          "8844:       }",
          "8846:       else if (tag == 0x940c && len < 256000)",
          "8847:       {",
          "8848:         table_buf_0x940c = (uchar *)malloc(len);",
          "8849:         table_buf_0x940c_present = 1;",
          "8850:         fread(table_buf_0x940c, len, 1, ifp);",
          "8851:         if ((imgdata.lens.makernotes.CamID) && (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E))",
          "8852:         {",
          "8853:           process_Sony_0x940c(table_buf_0x940c);",
          "8854:           free(table_buf_0x940c);",
          "8855:           table_buf_0x940c_present = 0;",
          "8856:         }",
          "8857:       }",
          "8859:       else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))",
          "8860:       {",
          "8861:         imgdata.lens.makernotes.LensID = get4();",
          "8862:         if ((imgdata.lens.makernotes.LensID > 0x4900) && (imgdata.lens.makernotes.LensID <= 0x5900))",
          "8863:         {",
          "8864:           imgdata.lens.makernotes.AdapterID = 0x4900;",
          "8865:           imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;",
          "8866:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;",
          "8867:           strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");",
          "8868:         }",
          "8870:         else if ((imgdata.lens.makernotes.LensID > 0xEF00) && (imgdata.lens.makernotes.LensID < 0xFFFF) &&",
          "8871:                  (imgdata.lens.makernotes.LensID != 0xFF00))",
          "8872:         {",
          "8873:           imgdata.lens.makernotes.AdapterID = 0xEF00;",
          "8874:           imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;",
          "8875:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "8876:         }",
          "8877:         if (tag == 0x010c)",
          "8878:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;",
          "8879:       }",
          "8881:       else if (tag == 0xb02a && len < 256000) // Sony LensSpec",
          "8882:       {",
          "8883:         table_buf = (uchar *)malloc(len);",
          "8884:         fread(table_buf, len, 1, ifp);",
          "8885:         if (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6]))",
          "8886:         {",
          "8887:           if (table_buf[1] | table_buf[2])",
          "8888:             imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);",
          "8889:           if (table_buf[3] | table_buf[4])",
          "8890:             imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);",
          "8891:           if (table_buf[5])",
          "8892:             imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;",
          "8893:           if (table_buf[6])",
          "8894:             imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;",
          "8895:           parseSonyLensFeatures(table_buf[0], table_buf[7]);",
          "8896:         }",
          "8897:         free(table_buf);",
          "8899:     }",
          "8901:     fseek(ifp, save, SEEK_SET);",
          "8903: quit:",
          "8908: void CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer) { /*placeholder */ }",
          "8911: void CLASS parse_makernote(int base, int uptag)",
          "8913:   unsigned offset = 0, entries, tag, type, len, save, c;",
          "8914:   unsigned ver97 = 0, serial = 0, i, wbi = 0, wb[4] = {0, 0, 0, 0};",
          "8916:   short morder, sorder = order;",
          "",
          "---------------",
          "--- Hunk 79 ---",
          "[Context before]",
          "8175:   INT64 fsize = ifp->size();",
          "8176: #endif",
          "8189:     order = 0x4d4d;",
          "8192:       wb[3] = get2();",
          "8196:     }",
          "8197:     goto quit;",
          "8198:   }",
          "8200:     base = ftell(ifp);",
          "8201:     order = get2();",
          "8203:     offset = get4();",
          "8209:     order = get2();",
          "8213:     goto nf;",
          "8229:       base = ftell(ifp);",
          "8230:   }",
          "8233:   if (!strncasecmp(make, \"LEICA\", 5))",
          "8234:     {",
          "8264: #ifdef LIBRAW_LIBRARY_BUILD",
          "8266: #endif",
          "8268: #ifdef LIBRAW_LIBRARY_BUILD",
          "8275:     }",
          "8277:   entries = get2();",
          "8279:   morder = order;",
          "8282:     order = morder;",
          "8284:     tag |= uptag << 16;",
          "8286: #ifdef LIBRAW_LIBRARY_BUILD",
          "8287:     INT64 _pos = ftell(ifp);",
          "8290:       {",
          "8384:       }",
          "8385:       else",
          "8387:     }",
          "8390:       {",
          "8392:         {",
          "8399:           {",
          "8494:             {",
          "8497:             }",
          "8498:           }",
          "8541:       }",
          "8544:       {",
          "8637:       }",
          "8683:           {",
          "8685:           }",
          "8687:           {",
          "8689:           }",
          "8690:       }",
          "8694:       {",
          "8754:       }",
          "8760:       {",
          "8800:         {",
          "8802:         }",
          "8804:         {",
          "8806:         }",
          "8808:         {",
          "8810:         }",
          "8812:         {",
          "8814:         }",
          "8816:         {",
          "8818:         }",
          "8820:         {",
          "8822:         }",
          "8824:         {",
          "8826:         }",
          "8828:         {",
          "8830:         }",
          "8832:         {",
          "8843:         }",
          "8845:         {",
          "8848:         }",
          "8850:         {",
          "8852:         }",
          "8875:           {",
          "8882:           }",
          "8883:       }",
          "8885:     else if (!strncmp(make, \"SAMSUNG\", 7))",
          "8886:       {",
          "8931:       }",
          "8936:              (!strncasecmp(make, \"Hasselblad\", 10) &&",
          "8941:       {",
          "8944:         {",
          "8962:         }",
          "8977:           {",
          "9016:           }",
          "9031:           {",
          "9033:           }",
          "9036:           {",
          "9051:               break;",
          "9063:               break;",
          "9064:             }",
          "9066:           }",
          "9120:           {",
          "9135:           }",
          "9136:       }",
          "9144:       {",
          "9148:       }",
          "9169:       }",
          "9170:     }",
          "9189: #endif",
          "9357:       }",
          "9358:     }",
          "9359:     if (tag == 0x15 && type == 2 && is_raw)",
          "9364:     }",
          "9366:       while ((c = fgetc(ifp)) && c != EOF)",
          "9367: #ifdef LIBRAW_LIBRARY_BUILD",
          "9368:       {",
          "9369:         if ((!custom_serial) && (!isdigit(c)))",
          "9370:         {",
          "9372:           {",
          "9373:             custom_serial = 34;",
          "9374:           }",
          "",
          "[Removed Lines]",
          "8178:    The MakerNote might have its own TIFF header (possibly with",
          "8179:    its own byte-order!), or it might just be a table.",
          "8181:   if (!strncmp(make,\"Nokia\",5)) return;",
          "8182:   fread (buf, 1, 10, ifp);",
          "8184:       !strncmp (buf,\"VER\" ,3) ||",
          "8185:       !strncmp (buf,\"IIII\",4) ||",
          "8186:       !strncmp (buf,\"MMMM\",4)) return;",
          "8190:     while ((i=ftell(ifp)) < data_offset && i < 16384) {",
          "8191:       wb[0] = wb[2];  wb[2] = wb[1];  wb[1] = wb[3];",
          "8193:       if (wb[1] == 256 && wb[3] == 256 &&",
          "8194:    wb[0] > 256 && wb[0] < 640 && wb[2] > 256 && wb[2] < 640)",
          "8195:  FORC4 cam_mul[c] = wb[c];",
          "8199:   if (!strcmp (buf,\"Nikon\")) {",
          "8202:     if (get2() != 42) goto quit;",
          "8204:     fseek (ifp, offset-8, SEEK_CUR);",
          "8205:   } else if (!strcmp (buf,\"OLYMPUS\") ||",
          "8206:              !strcmp (buf,\"PENTAX \")) {",
          "8207:     base = ftell(ifp)-10;",
          "8208:     fseek (ifp, -2, SEEK_CUR);",
          "8210:     if (buf[0] == 'O') get2();",
          "8211:   } else if (!strncmp (buf,\"SONY\",4) ||",
          "8212:              !strcmp  (buf,\"Panasonic\")) {",
          "8214:   } else if (!strncmp (buf,\"FUJIFILM\",8)) {",
          "8215:     base = ftell(ifp)-10;",
          "8216:  nf: order = 0x4949;",
          "8217:     fseek (ifp,  2, SEEK_CUR);",
          "8218:   } else if (!strcmp (buf,\"OLYMP\") ||",
          "8219:              !strcmp (buf,\"LEICA\") ||",
          "8220:              !strcmp (buf,\"Ricoh\") ||",
          "8221:              !strcmp (buf,\"EPSON\"))",
          "8222:     fseek (ifp, -2, SEEK_CUR);",
          "8223:   else if (!strcmp (buf,\"AOC\") ||",
          "8224:            !strcmp (buf,\"QVC\"))",
          "8225:     fseek (ifp, -4, SEEK_CUR);",
          "8226:   else {",
          "8227:     fseek (ifp, -10, SEEK_CUR);",
          "8228:     if (!strncmp(make,\"SAMSUNG\",7))",
          "8235:       if (!strncmp(model, \"M8\", 2) ||",
          "8236:           !strncasecmp(model, \"Leica M8\", 8) ||",
          "8237:           !strncasecmp(model, \"LEICA X\", 7))",
          "8238:         {",
          "8239:           base = ftell(ifp)-8;",
          "8240:         }",
          "8241:       else if (!strncasecmp(model, \"LEICA M (Typ 240)\", 17))",
          "8242:         {",
          "8243:           base = 0;",
          "8244:         }",
          "8245:       else if (!strncmp(model, \"M9\", 2) ||",
          "8246:                !strncasecmp(model, \"Leica M9\", 8) ||",
          "8247:                !strncasecmp(model, \"M Monochrom\", 11) ||",
          "8248:                !strncasecmp(model, \"Leica M Monochrom\", 11))",
          "8249:         {",
          "8250:           if (!uptag)",
          "8251:             {",
          "8252:               base = ftell(ifp) - 10;",
          "8253:               fseek (ifp, 8, SEEK_CUR);",
          "8254:             }",
          "8255:           else if (uptag == 0x3400)",
          "8256:             {",
          "8257:               fseek (ifp, 10, SEEK_CUR);",
          "8258:               base += 10;",
          "8259:             }",
          "8260:         }",
          "8261:       else if (!strncasecmp(model, \"LEICA T\", 7))",
          "8262:        {",
          "8263:          base = ftell(ifp)-8;",
          "8265:          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_T;",
          "8267:        }",
          "8269:       else if (!strncasecmp(model, \"LEICA SL\", 8))",
          "8270:        {",
          "8271:          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_SL;",
          "8272:          imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;",
          "8273:        }",
          "8274: #endif",
          "8278:   if (entries > 1000) return;",
          "8281:   while (entries--) {",
          "8283:     tiff_get (base, &tag, &type, &len, &save);",
          "8288:     if(len > 8 && _pos+len > 2* fsize) continue;",
          "8289:     if (!strncmp(make, \"Canon\",5))",
          "8291:         if (tag == 0x000d && len < 256000) // camera info",
          "8292:           {",
          "8293:             CanonCameraInfo = (uchar*)malloc(len);",
          "8294:             fread(CanonCameraInfo, len, 1, ifp);",
          "8295:             lenCanonCameraInfo = len;",
          "8296:           }",
          "8298:         else if (tag == 0x10) // Canon ModelID",
          "8299:           {",
          "8300:             unique_id = get4();",
          "8301:             if (unique_id == 0x03740000) unique_id = 0x80000374; // M3",
          "8302:             if (unique_id == 0x03840000) unique_id = 0x80000384; // M10",
          "8303:             if (unique_id == 0x03940000) unique_id = 0x80000394; // M5",
          "8304:             setCanonBodyFeatures(unique_id);",
          "8305:             if (lenCanonCameraInfo)",
          "8306:               {",
          "8307:                 processCanonCameraInfo(unique_id, CanonCameraInfo,lenCanonCameraInfo);",
          "8308:                 free(CanonCameraInfo);",
          "8309:                 CanonCameraInfo = 0;",
          "8310:                 lenCanonCameraInfo = 0;",
          "8311:               }",
          "8312:           }",
          "8314:         else parseCanonMakernotes (tag, type, len);",
          "8315:       }",
          "8317:     else if (!strncmp(make, \"FUJI\", 4)) {",
          "8318:       if (tag == 0x0010) {",
          "8319:          char FujiSerial[sizeof(imgdata.shootinginfo.InternalBodySerial)];",
          "8320:          char *words[4];",
          "8321:          char yy[2], mm[3], dd[3], ystr[16], ynum[16];",
          "8322:          int year, nwords, ynum_len;",
          "8323:          unsigned c;",
          "8324:          stmread(FujiSerial, len, ifp);",
          "8325:          nwords = getwords(FujiSerial, words, 4,sizeof(imgdata.shootinginfo.InternalBodySerial));",
          "8326:          for (int i = 0; i < nwords; i++) {",
          "8327:            mm[2] = dd[2] = 0;",
          "8328:            if (strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1) < 18)",
          "8329:               if (i == 0)",
          "8330:           strncpy (imgdata.shootinginfo.InternalBodySerial,",
          "8331:     words[0],",
          "8332:    sizeof(imgdata.shootinginfo.InternalBodySerial)-1);",
          "8333:               else",
          "8334:        {",
          "8335:         char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];",
          "8336:         snprintf (tbuf, sizeof(tbuf), \"%s %s\",",
          "8337:              imgdata.shootinginfo.InternalBodySerial, words[i]);",
          "8338:         strncpy(imgdata.shootinginfo.InternalBodySerial,tbuf,",
          "8339:              sizeof(imgdata.shootinginfo.InternalBodySerial)-1);",
          "8340:         }",
          "8341:            else",
          "8342:            {",
          "8343:              strncpy (dd, words[i]+strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-14, 2);",
          "8344:              strncpy (mm, words[i]+strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-16, 2);",
          "8345:              strncpy (yy, words[i]+strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-18, 2);",
          "8346:              year = (yy[0]-'0')*10 + (yy[1]-'0');",
          "8347:              if (year <70) year += 2000; else year += 1900;",
          "8349:              ynum_len = (int)strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-18;",
          "8350:              strncpy(ynum, words[i], ynum_len);",
          "8351:              ynum[ynum_len] = 0;",
          "8352:              for ( int j = 0; ynum[j] && ynum[j+1] && sscanf(ynum+j, \"%2x\", &c); j += 2) ystr[j/2] = c;",
          "8353:              ystr[ynum_len / 2 + 1] = 0;",
          "8354:              strcpy (model2, ystr);",
          "8356:              if (i == 0) {",
          "8357:         char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];",
          "8359:                if (nwords == 1)",
          "8360:      snprintf (tbuf,sizeof(tbuf),",
          "8361:       \"%s %s %d:%s:%s\",",
          "8362:       words[0]+strnlen(words[0],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-12,",
          "8363:     ystr, year, mm, dd);",
          "8365:                else",
          "8366:    snprintf (tbuf,sizeof(tbuf),",
          "8367:        \"%s %d:%s:%s %s\",",
          "8368:        ystr, year, mm, dd,",
          "8369:        words[0]+strnlen(words[0],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-12);",
          "8371:         strncpy(imgdata.shootinginfo.InternalBodySerial,tbuf,",
          "8372:              sizeof(imgdata.shootinginfo.InternalBodySerial)-1);",
          "8373:              } else {",
          "8374:   char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];",
          "8375:          snprintf (tbuf, sizeof(tbuf),",
          "8376:   \"%s %s %d:%s:%s %s\",",
          "8377:   imgdata.shootinginfo.InternalBodySerial, ystr, year, mm, dd,",
          "8378:    words[i]+strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-12);",
          "8379:    strncpy(imgdata.shootinginfo.InternalBodySerial,tbuf,",
          "8380:     sizeof(imgdata.shootinginfo.InternalBodySerial)-1);",
          "8381:             }",
          "8382:            }",
          "8383:          }",
          "8386:  parseFujiMakernotes (tag, type);",
          "8389:     else if (!strncasecmp(make, \"LEICA\", 5))",
          "8391:         if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))",
          "8393:           int ind = tag == 0x035e?0:1;",
          "8394:        for (int j=0; j < 3; j++)",
          "8395:         FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c]= getreal(type);",
          "8396:         }",
          "8398:         if ((tag == 0x0303) && (type != 4))",
          "8400:             stmread(imgdata.lens.makernotes.Lens, len, ifp);",
          "8401:           }",
          "8403:         if ((tag == 0x3405) ||",
          "8404:             (tag == 0x0310) ||",
          "8405:             (tag == 0x34003405))",
          "8406:           {",
          "8407:             imgdata.lens.makernotes.LensID = get4();",
          "8408:             imgdata.lens.makernotes.LensID =",
          "8409:               ((imgdata.lens.makernotes.LensID>>2)<<8) |",
          "8410:               (imgdata.lens.makernotes.LensID & 0x3);",
          "8411:             if (imgdata.lens.makernotes.LensID != -1)",
          "8412:               {",
          "8413:                 if ((model[0] == 'M') ||",
          "8414:                     !strncasecmp (model, \"LEICA M\", 7))",
          "8415:                   {",
          "8416:                     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;",
          "8417:                     if (imgdata.lens.makernotes.LensID)",
          "8418:                     imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;",
          "8419:                   }",
          "8420:                 else if ((model[0] == 'S') ||",
          "8421:                          !strncasecmp (model, \"LEICA S\", 7))",
          "8422:                   {",
          "8423:                     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;",
          "8424:                     if (imgdata.lens.makernotes.Lens[0])",
          "8425:                     imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;",
          "8426:                   }",
          "8427:               }",
          "8428:           }",
          "8430:         else if (",
          "8431:                  ((tag == 0x0313) || (tag == 0x34003406)) &&",
          "8432:                  (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&",
          "8433:                  ((type == 10) || (type == 5))",
          "8434:                  )",
          "8435:           {",
          "8436:             imgdata.lens.makernotes.CurAp = getreal(type);",
          "8437:             if (imgdata.lens.makernotes.CurAp > 126.3)",
          "8438:               imgdata.lens.makernotes.CurAp = 0.0f;",
          "8439:           }",
          "8441:         else if (tag == 0x3400)",
          "8442:           {",
          "8443:             parse_makernote (base, 0x3400);",
          "8444:           }",
          "8445:       }",
          "8447:     else if (!strncmp(make, \"NIKON\",5))",
          "8448:       {",
          "8449:         if (tag == 0x000a)",
          "8450:           {",
          "8451:             imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "8452:             imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "8453:           }",
          "8454:         else if (tag == 0x0012)",
          "8455:           {",
          "8456:             char a, b, c;",
          "8457:             a = fgetc(ifp);",
          "8458:             b = fgetc(ifp);",
          "8459:             c = fgetc(ifp);",
          "8460:             if (c) imgdata.other.FlashEC = (float)(a*b)/(float)c;",
          "8461:           }",
          "8462:         else if (tag == 0x0082)    // lens attachment",
          "8463:           {",
          "8464:             stmread(imgdata.lens.makernotes.Attachment, len, ifp);",
          "8465:           }",
          "8466:         else if (tag == 0x0083)    // lens type",
          "8467:           {",
          "8468:             imgdata.lens.nikon.NikonLensType = fgetc(ifp);",
          "8469:           }",
          "8470:         else if (tag == 0x0084)    // lens",
          "8471:           {",
          "8472:             imgdata.lens.makernotes.MinFocal = getreal(type);",
          "8473:             imgdata.lens.makernotes.MaxFocal = getreal(type);",
          "8474:             imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);",
          "8475:             imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);",
          "8476:           }",
          "8477:         else if (tag == 0x008b)    // lens f-stops",
          "8478:           {",
          "8479:             uchar a, b, c;",
          "8480:             a = fgetc(ifp);",
          "8481:             b = fgetc(ifp);",
          "8482:             c = fgetc(ifp);",
          "8483:             if (c)",
          "8484:               {",
          "8485:                 imgdata.lens.nikon.NikonLensFStops = a*b*(12/c);",
          "8486:                 imgdata.lens.makernotes.LensFStops =",
          "8487:                   (float)imgdata.lens.nikon.NikonLensFStops /12.0f;",
          "8488:               }",
          "8489:           }",
          "8490:         else if (tag == 0x0093)",
          "8491:           {",
          "8492:             i = get2();",
          "8493:             if ((i == 7) || (i == 9))",
          "8495:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "8496:               imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "8499:         else if (tag == 0x0098)    // contains lens data",
          "8500:           {",
          "8501:             for (i = 0; i < 4; i++)",
          "8502:               {",
          "8503:                 NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';",
          "8504:               }",
          "8505:             switch (NikonLensDataVersion)",
          "8506:               {",
          "8507:               case 100: lenNikonLensData = 9; break;",
          "8508:               case 101:",
          "8509:               case 201: // encrypted, starting from v.201",
          "8510:               case 202:",
          "8511:               case 203: lenNikonLensData = 15; break;",
          "8512:               case 204: lenNikonLensData = 16; break;",
          "8513:               case 400: lenNikonLensData = 459; break;",
          "8514:               case 401: lenNikonLensData = 590; break;",
          "8515:               case 402: lenNikonLensData = 509; break;",
          "8516:               case 403: lenNikonLensData = 879; break;",
          "8517:               }",
          "8518:             if(lenNikonLensData>0)",
          "8519:               {",
          "8520:                 table_buf = (uchar*)malloc(lenNikonLensData);",
          "8521:                 fread(table_buf, lenNikonLensData, 1, ifp);",
          "8522:                 if ((NikonLensDataVersion < 201) && lenNikonLensData)",
          "8523:                   {",
          "8524:                     processNikonLensData(table_buf, lenNikonLensData);",
          "8525:                     free(table_buf);",
          "8526:                     lenNikonLensData = 0;",
          "8527:                   }",
          "8528:               }",
          "8529:           }",
          "8530:         else if (tag == 0x00a0)",
          "8531:           {",
          "8532:             stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "8533:           }",
          "8534:         else if (tag == 0x00a8)  // contains flash data",
          "8535:           {",
          "8536:            for (i = 0; i < 4; i++)",
          "8537:               {",
          "8538:                 NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';",
          "8539:               }",
          "8540:           }",
          "8543:     else if (!strncmp(make, \"OLYMPUS\", 7))",
          "8545:         switch (tag) {",
          "8546:         case 0x0404:",
          "8547:         case 0x101a:",
          "8548:         case 0x20100101:",
          "8549:           if (!imgdata.shootinginfo.BodySerial[0])",
          "8550:             stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "8551:         break;",
          "8552:         case 0x20100102:",
          "8553:           if (!imgdata.shootinginfo.InternalBodySerial[0])",
          "8554:             stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);",
          "8555:         break;",
          "8556:         case 0x0207:",
          "8557:         case 0x20100100:",
          "8558:           {",
          "8559:             uchar sOlyID[8];",
          "8560:             unsigned long long OlyID;",
          "8561:             fread (sOlyID, MIN(len,7), 1, ifp);",
          "8562:      sOlyID[7] = 0;",
          "8563:             OlyID = sOlyID[0];",
          "8564:             i = 1;",
          "8565:             while (i < 7 && sOlyID[i])",
          "8566:               {",
          "8567:                 OlyID = OlyID << 8 | sOlyID[i];",
          "8568:                 i++;",
          "8569:               }",
          "8570:             setOlympusBodyFeatures(OlyID);",
          "8571:           }",
          "8572:           break;",
          "8573:         case 0x1002:",
          "8574:           imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type)/2);",
          "8575:           break;",
          "8576:         case 0x20401112:",
          "8577:           imgdata.makernotes.olympus.OlympusCropID = get2();",
          "8578:           break;",
          "8579:         case 0x20401113:",
          "8580:           FORC4 imgdata.makernotes.olympus.OlympusFrame[c] = get2();",
          "8581:           break;",
          "8582:         case 0x20100201:",
          "8583:           {",
          "8584:             unsigned long long oly_lensid [3];",
          "8585:             oly_lensid[0] = fgetc(ifp);",
          "8586:             fgetc(ifp);",
          "8587:             oly_lensid[1] = fgetc(ifp);",
          "8588:             oly_lensid[2] = fgetc(ifp);",
          "8589:             imgdata.lens.makernotes.LensID =",
          "8590:               (oly_lensid[0] << 16) | (oly_lensid[1] << 8) | oly_lensid[2];",
          "8591:           }",
          "8592:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;",
          "8593:           imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;",
          "8594:           if (((imgdata.lens.makernotes.LensID < 0x20000) ||",
          "8595:                (imgdata.lens.makernotes.LensID > 0x4ffff)) &&",
          "8596:               (imgdata.lens.makernotes.LensID & 0x10))",
          "8597:             {",
          "8598:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;",
          "8599:             }",
          "8600:           break;",
          "8601:         case 0x20100202:",
          "8602:           stmread(imgdata.lens.LensSerial, len, ifp);",
          "8603:           break;",
          "8604:         case 0x20100203:",
          "8605:           stmread(imgdata.lens.makernotes.Lens, len, ifp);",
          "8606:           break;",
          "8607:         case 0x20100205:",
          "8608:           imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "8609:           break;",
          "8610:         case 0x20100206:",
          "8611:           imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "8612:           break;",
          "8613:         case 0x20100207:",
          "8614:           imgdata.lens.makernotes.MinFocal = (float)get2();",
          "8615:           break;",
          "8616:         case 0x20100208:",
          "8617:           imgdata.lens.makernotes.MaxFocal = (float)get2();",
          "8618:           if (imgdata.lens.makernotes.MaxFocal > 1000.0f)",
          "8619:             imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;",
          "8620:           break;",
          "8621:         case 0x2010020a:",
          "8622:           imgdata.lens.makernotes.MaxAp4CurFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "8623:           break;",
          "8624:         case 0x20100301:",
          "8625:           imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;",
          "8626:           fgetc(ifp);",
          "8627:           imgdata.lens.makernotes.TeleconverterID =",
          "8628:             imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);",
          "8629:           break;",
          "8630:         case 0x20100303:",
          "8631:           stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);",
          "8632:           break;",
          "8633:         case 0x20100403:",
          "8634:           stmread(imgdata.lens.makernotes.Attachment, len, ifp);",
          "8635:           break;",
          "8636:         }",
          "8639:     else if ((!strncmp(make, \"PENTAX\", 6) || !strncmp(make, \"RICOH\", 5)) &&",
          "8640:              !strncmp(model, \"GR\", 2))",
          "8641:       {",
          "8642:         if (tag == 0x0005)",
          "8643:        {",
          "8644:           char buffer[17];",
          "8645:           int count=0;",
          "8646:           fread(buffer, 16, 1, ifp);",
          "8647:           buffer[16] = 0;",
          "8648:           for (int i=0; i<16; i++)",
          "8649:           {",
          "8651:              if ((isspace(buffer[i])) ||",
          "8652:                  (buffer[i] == 0x2D) ||",
          "8653:                  (isalnum(buffer[i])))",
          "8654:              count++;",
          "8655:           }",
          "8656:           if (count == 16)",
          "8657:           {",
          "8658:              sprintf (imgdata.shootinginfo.BodySerial, \"%8s\", buffer+8);",
          "8659:              buffer[8] = 0;",
          "8660:              sprintf (imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);",
          "8661:           }",
          "8662:           else",
          "8663:           {",
          "8664:              sprintf (imgdata.shootinginfo.BodySerial, \"%02x%02x%02x%02x\", buffer[4], buffer[5], buffer[6], buffer[7]);",
          "8665:              sprintf (imgdata.shootinginfo.InternalBodySerial, \"%02x%02x%02x%02x\", buffer[8], buffer[9], buffer[10], buffer[11]);",
          "8666:           }",
          "8667:        }",
          "8668:         else if ((tag == 0x1001) && (type == 3))",
          "8669:           {",
          "8670:             imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "8671:             imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "8672:             imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;",
          "8673:             imgdata.lens.makernotes.LensID = -1;",
          "8674:             imgdata.lens.makernotes.FocalType = 1;",
          "8675:           }",
          "8677:         else if ((tag == 0x100b) && (type == 10))",
          "8678:           {",
          "8679:             imgdata.other.FlashEC = getreal(type);",
          "8680:           }",
          "8682:         else if ((tag == 0x1017) && (get2() == 2))",
          "8684:             strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");",
          "8686:         else if (tag == 0x1500)",
          "8688:             imgdata.lens.makernotes.CurFocal = getreal(type);",
          "8692:     else if (!strncmp(make, \"RICOH\", 5) &&",
          "8693:              strncmp(model, \"PENTAX\", 6))",
          "8695:      if ((tag == 0x0005) && !strncmp(model, \"GXR\", 3))",
          "8696:        {",
          "8697:           char buffer[9];",
          "8698:           buffer[8] = 0;",
          "8699:           fread(buffer, 8, 1, ifp);",
          "8700:           sprintf (imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);",
          "8701:        }",
          "8703:      else if ((tag == 0x100b) && (type == 10))",
          "8704:           {",
          "8705:             imgdata.other.FlashEC = getreal(type);",
          "8706:           }",
          "8708:           else if ((tag == 0x1017) && (get2() == 2))",
          "8709:           {",
          "8710:             strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");",
          "8711:           }",
          "8713:         else if (tag == 0x1500)",
          "8714:           {",
          "8715:             imgdata.lens.makernotes.CurFocal = getreal(type);",
          "8716:           }",
          "8718:         else if ((tag == 0x2001) && !strncmp(model, \"GXR\", 3))",
          "8719:           {",
          "8720:             short ntags, cur_tag;",
          "8721:             fseek(ifp, 20, SEEK_CUR);",
          "8722:             ntags = get2();",
          "8723:             cur_tag = get2();",
          "8724:             while (cur_tag != 0x002c)",
          "8725:               {",
          "8726:                 fseek(ifp, 10, SEEK_CUR);",
          "8727:                 cur_tag = get2();",
          "8728:               }",
          "8729:             fseek(ifp, 6, SEEK_CUR);",
          "8730:             fseek(ifp, get4()+20, SEEK_SET);",
          "8731:             stread(imgdata.shootinginfo.BodySerial, 12, ifp);",
          "8732:             get2();",
          "8733:             imgdata.lens.makernotes.LensID = getc(ifp) - '0';",
          "8734:             switch(imgdata.lens.makernotes.LensID) {",
          "8735:               case 1:",
          "8736:               case 2:",
          "8737:               case 3:",
          "8738:               case 5:",
          "8739:               case 6:",
          "8740:              imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "8741:              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_RicohModule;",
          "8742:               break;",
          "8743:               case 8:",
          "8744:              imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;",
          "8745:              imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;",
          "8746:              imgdata.lens.makernotes.LensID = -1;",
          "8747:               break;",
          "8748:               default:",
          "8749:              imgdata.lens.makernotes.LensID = -1;",
          "8750:             }",
          "8751:             fseek(ifp, 17, SEEK_CUR);",
          "8752:             stread(imgdata.lens.LensSerial, 12, ifp);",
          "8753:           }",
          "8756:     else if ((!strncmp(make, \"PENTAX\", 6) ||",
          "8757:               !strncmp(model, \"PENTAX\", 6) ||",
          "8758:              (!strncmp(make, \"SAMSUNG\", 7) && dng_version)) &&",
          "8759:              strncmp(model, \"GR\", 2))",
          "8761:         if (tag == 0x0005)",
          "8762:           {",
          "8763:             unique_id = get4();",
          "8764:             setPentaxBodyFeatures(unique_id);",
          "8765:           }",
          "8766:         else if (tag == 0x0013)",
          "8767:           {",
          "8768:             imgdata.lens.makernotes.CurAp = (float)get2()/10.0f;",
          "8769:           }",
          "8770:         else if (tag == 0x0014)",
          "8771:           {",
          "8772:             PentaxISO(get2());",
          "8773:           }",
          "8774:         else if (tag == 0x001d)",
          "8775:           {",
          "8776:             imgdata.lens.makernotes.CurFocal = (float)get4()/100.0f;",
          "8777:           }",
          "8778:         else if (tag == 0x003f)",
          "8779:           {",
          "8780:             imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);",
          "8781:           }",
          "8782:         else if (tag == 0x004d)",
          "8783:           {",
          "8784:             if (type == 9) imgdata.other.FlashEC = getreal(type) / 256.0f;",
          "8785:             else imgdata.other.FlashEC = (float) ((signed short) fgetc(ifp)) / 6.0f;",
          "8786:           }",
          "8787:          else if (tag == 0x007e)",
          "8788:            {",
          "8789:              imgdata.color.linear_max[0] =",
          "8790:              imgdata.color.linear_max[1] =",
          "8791:              imgdata.color.linear_max[2] =",
          "8792:              imgdata.color.linear_max[3] = (long)(-1) * get4();",
          "8793:            }",
          "8794:         else if (tag == 0x0207)",
          "8795:           {",
          "8796:      if(len < 65535) // Safety belt",
          "8797:              PentaxLensInfo(imgdata.lens.makernotes.CamID, len);",
          "8798:           }",
          "8799:         else if (tag == 0x020d)",
          "8801:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();",
          "8803:         else if (tag == 0x020e)",
          "8805:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();",
          "8807:         else if (tag == 0x020f)",
          "8809:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();",
          "8811:         else if (tag == 0x0210)",
          "8813:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();",
          "8815:         else if (tag == 0x0211)",
          "8817:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();",
          "8819:         else if (tag == 0x0212)",
          "8821:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();",
          "8823:         else if (tag == 0x0213)",
          "8825:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();",
          "8827:         else if (tag == 0x0214)",
          "8829:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();",
          "8831:         else if (tag == 0x0221)",
          "8833:    int nWB = get2();",
          "8834:    if(nWB<=sizeof(imgdata.color.WBCT_Coeffs)/sizeof(imgdata.color.WBCT_Coeffs[0]))",
          "8835:      for (int i = 0; i < nWB; i++)",
          "8836:        {",
          "8837:   imgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();",
          "8838:   fseek(ifp, 2, SEEK_CUR);",
          "8839:   imgdata.color.WBCT_Coeffs[i][1] = get2();",
          "8840:   imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;",
          "8841:   imgdata.color.WBCT_Coeffs[i][3] = get2();",
          "8842:        }",
          "8844:         else if (tag == 0x0215)",
          "8846:           fseek (ifp, 16, SEEK_CUR);",
          "8847:           sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());",
          "8849:         else if (tag == 0x0229)",
          "8851:           stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "8853:         else if (tag == 0x022d)",
          "8854:         {",
          "8855:    fseek (ifp,2,SEEK_CUR);",
          "8856:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();",
          "8857:    getc(ifp);",
          "8858:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();",
          "8859:    getc(ifp);",
          "8860:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();",
          "8861:    getc(ifp);",
          "8862:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();",
          "8863:    getc(ifp);",
          "8864:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();",
          "8865:    getc(ifp);",
          "8866:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();",
          "8867:    getc(ifp);",
          "8868:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();",
          "8869:    getc(ifp);",
          "8870:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();",
          "8871:    getc(ifp);",
          "8872:           FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ (c >> 1)] = get2();",
          "8873:         }",
          "8874:         else if (tag == 0x0239)  // Q-series lens info (LensInfoQ)",
          "8876:             char LensInfo [20];",
          "8877:             fseek (ifp, 2, SEEK_CUR);",
          "8878:             stread(imgdata.lens.makernotes.Lens, 30, ifp);",
          "8879:             strcat(imgdata.lens.makernotes.Lens, \" \");",
          "8880:             stread(LensInfo, 20, ifp);",
          "8881:             strcat(imgdata.lens.makernotes.Lens, LensInfo);",
          "8887:         if (tag == 0x0002)",
          "8888:           {",
          "8889:             if(get4() == 0x2000)",
          "8890:               {",
          "8891:                 imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;",
          "8892:               }",
          "8893:             else if (!strncmp(model, \"NX mini\", 7))",
          "8894:               {",
          "8895:                 imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;",
          "8896:               }",
          "8897:             else",
          "8898:               {",
          "8899:                 imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "8900:                 imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "8901:               }",
          "8902:           }",
          "8903:         else if (tag == 0x0003)",
          "8904:           {",
          "8905:             unique_id = imgdata.lens.makernotes.CamID = get4();",
          "8906:           }",
          "8907:          else if (tag == 0xa002)",
          "8908:           {",
          "8909:              stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "8910:           }",
          "8911:         else if (tag == 0xa003)",
          "8912:           {",
          "8913:             imgdata.lens.makernotes.LensID = get2();",
          "8914:             if (imgdata.lens.makernotes.LensID)",
          "8915:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;",
          "8916:           }",
          "8917:         else if (tag == 0xa005)",
          "8918:           {",
          "8919:             stmread(imgdata.lens.InternalLensSerial, len, ifp);",
          "8920:           }",
          "8921:         else if (tag == 0xa019)",
          "8922:           {",
          "8923:             imgdata.lens.makernotes.CurAp = getreal(type);",
          "8924:           }",
          "8925:         else if (tag == 0xa01a)",
          "8926:           {",
          "8927:             imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;",
          "8928:             if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)",
          "8929:               imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;",
          "8930:           }",
          "8933:     else if (!strncasecmp(make, \"SONY\", 4) ||",
          "8934:              !strncasecmp(make, \"Konica\", 6) ||",
          "8935:              !strncasecmp(make, \"Minolta\", 7) ||",
          "8937:               (!strncasecmp(model, \"Stellar\", 7) ||",
          "8938:                !strncasecmp(model, \"Lunar\", 5) ||",
          "8939:                !strncasecmp(model, \"Lusso\", 5) ||",
          "8940:                !strncasecmp(model, \"HV\",2))))",
          "8942:         ushort lid;",
          "8943:         if (tag == 0xb001)   // Sony ModelID",
          "8945:           unique_id = get2();",
          "8946:           setSonyBodyFeatures(unique_id);",
          "8947:           if (table_buf_0x9050_present)",
          "8948:             {",
          "8949:               process_Sony_0x9050(table_buf_0x9050, unique_id);",
          "8950:               free (table_buf_0x9050);",
          "8951:               table_buf_0x9050_present = 0;",
          "8952:             }",
          "8953:           if (table_buf_0x940c_present)",
          "8954:             {",
          "8955:               if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)",
          "8956:                 {",
          "8957:                   process_Sony_0x940c(table_buf_0x940c);",
          "8958:                 }",
          "8959:               free (table_buf_0x940c);",
          "8960:               table_buf_0x940c_present = 0;",
          "8961:             }",
          "8964:         else if ((tag == 0x0010) &&     // CameraInfo",
          "8965:                  strncasecmp(model, \"DSLR-A100\", 9) &&",
          "8966:                  strncasecmp(model, \"NEX-5C\", 6) &&",
          "8967:                  !strncasecmp(make, \"SONY\", 4) &&",
          "8968:                  ((len == 368) ||  // a700",
          "8969:                   (len == 5478) ||  // a850, a900",
          "8970:                   (len == 5506) ||  // a200, a300, a350",
          "8971:                   (len == 6118) ||  // a230, a290, a330, a380, a390",
          "8975:                   (len == 15360))",
          "8976:                  )",
          "8978:             table_buf = (uchar*)malloc(len);",
          "8979:             fread(table_buf, len, 1, ifp);",
          "8980:             if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&",
          "8981:                 memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))",
          "8982:               {",
          "8983:                 switch (len)",
          "8984:                   {",
          "8985:                   case 368:",
          "8986:                   case 5478:",
          "8988:                     if (table_buf[0] | table_buf[3])",
          "8989:                       imgdata.lens.makernotes.MinFocal =",
          "8990:                         bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);",
          "8991:                     if (table_buf[2] | table_buf[5])",
          "8992:                       imgdata.lens.makernotes.MaxFocal =",
          "8993:                         bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);",
          "8994:                     if (table_buf[4])",
          "8995:                       imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;",
          "8996:                     if (table_buf[4])",
          "8997:                       imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;",
          "8998:                     parseSonyLensFeatures(table_buf[1], table_buf[6]);",
          "8999:                     break;",
          "9000:                   default:",
          "9002:                     if (table_buf[1] | table_buf[2])",
          "9003:                       imgdata.lens.makernotes.MinFocal =",
          "9004:                         bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);",
          "9005:                     if (table_buf[3] | table_buf[4])",
          "9006:                       imgdata.lens.makernotes.MaxFocal =",
          "9007:                         bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);",
          "9008:                     if (table_buf[5])",
          "9009:                       imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;",
          "9010:                     if (table_buf[6])",
          "9011:                       imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;",
          "9012:                     parseSonyLensFeatures(table_buf[0], table_buf[7]);",
          "9013:                 }",
          "9014:               }",
          "9015:             free(table_buf);",
          "9018:         else if ((tag == 0x0020) &&    // WBInfoA100, needs 0xb028 processing",
          "9019:                  !strncasecmp(model, \"DSLR-A100\", 9))",
          "9020:    {",
          "9021:      fseek(ifp,0x49dc,SEEK_CUR);",
          "9022:      stmread(imgdata.shootinginfo.InternalBodySerial, 12, ifp);",
          "9023:    }",
          "9025:  else if (tag == 0x0104)",
          "9026:    {",
          "9027:      imgdata.other.FlashEC = getreal(type);",
          "9028:    }",
          "9030:         else if (tag == 0x0105)     // Teleconverter",
          "9032:             imgdata.lens.makernotes.TeleconverterID = get2();",
          "9035:         else if (tag == 0x0114 && len < 256000)  // CameraSettings",
          "9037:             table_buf = (uchar*)malloc(len);",
          "9038:             fread(table_buf, len, 1, ifp);",
          "9039:             switch (len) {",
          "9040:             case 280:",
          "9041:             case 364:",
          "9042:             case 332:",
          "9044:               if (table_buf[2] | table_buf[3])",
          "9045:                 {",
          "9046:                   lid = (((ushort)table_buf[2])<<8) |",
          "9047:                     ((ushort)table_buf[3]);",
          "9048:                   imgdata.lens.makernotes.CurAp =",
          "9049:                     powf64(2.0f, ((float)lid/8.0f-1.0f)/2.0f);",
          "9050:                 }",
          "9052:             case 1536:",
          "9053:             case 2048:",
          "9055:               parseSonyLensType2(table_buf[1016], table_buf[1015]);",
          "9056:               if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)",
          "9057:                 {",
          "9058:                   switch (table_buf[153]) {",
          "9059:                   case 16: imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A; break;",
          "9060:                   case 17: imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E; break;",
          "9061:                   }",
          "9062:                 }",
          "9065:             free(table_buf);",
          "9068:         else if (tag == 0x9050 && len < 256000)  // little endian",
          "9069:           {",
          "9070:             table_buf_0x9050 = (uchar*)malloc(len);",
          "9071:             table_buf_0x9050_present = 1;",
          "9072:             fread(table_buf_0x9050, len, 1, ifp);",
          "9074:             if (imgdata.lens.makernotes.CamID)",
          "9075:               {",
          "9076:                 process_Sony_0x9050(table_buf_0x9050, imgdata.lens.makernotes.CamID);",
          "9077:                 free (table_buf_0x9050);",
          "9078:                 table_buf_0x9050_present = 0;",
          "9079:               }",
          "9080:           }",
          "9082:         else if (tag == 0x940c && len <256000)",
          "9083:           {",
          "9084:             table_buf_0x940c = (uchar*)malloc(len);",
          "9085:             table_buf_0x940c_present = 1;",
          "9086:             fread(table_buf_0x940c, len, 1, ifp);",
          "9087:             if ((imgdata.lens.makernotes.CamID) &&",
          "9088:                 (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E))",
          "9089:               {",
          "9090:                 process_Sony_0x940c(table_buf_0x940c);",
          "9091:                 free(table_buf_0x940c);",
          "9092:                 table_buf_0x940c_present = 0;",
          "9093:               }",
          "9094:           }",
          "9096:         else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))",
          "9097:           {",
          "9098:             imgdata.lens.makernotes.LensID = get4();",
          "9099:             if ((imgdata.lens.makernotes.LensID > 0x4900) &&",
          "9100:                 (imgdata.lens.makernotes.LensID <= 0x5900))",
          "9101:             {",
          "9102:               imgdata.lens.makernotes.AdapterID = 0x4900;",
          "9103:               imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;",
          "9104:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;",
          "9105:               strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");",
          "9106:             }",
          "9108:             else if ((imgdata.lens.makernotes.LensID > 0xEF00) &&",
          "9109:                 (imgdata.lens.makernotes.LensID < 0xFFFF)      &&",
          "9110:                 (imgdata.lens.makernotes.LensID != 0xFF00))",
          "9111:             {",
          "9112:               imgdata.lens.makernotes.AdapterID = 0xEF00;",
          "9113:               imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;",
          "9114:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "9115:             }",
          "9116:             if (tag == 0x010c) imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;",
          "9117:           }",
          "9119:         else if (tag == 0xb02a && len < 256000) // Sony LensSpec",
          "9121:             table_buf = (uchar*)malloc(len);",
          "9122:             fread(table_buf, len, 1, ifp);",
          "9123:             if (table_buf[1] | table_buf[2])",
          "9124:               imgdata.lens.makernotes.MinFocal =",
          "9125:                 bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);",
          "9126:             if (table_buf[3] | table_buf[4])",
          "9127:               imgdata.lens.makernotes.MaxFocal =",
          "9128:                 bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);",
          "9129:             if (table_buf[5])",
          "9130:               imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;",
          "9131:             if (table_buf[6])",
          "9132:               imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;",
          "9133:             parseSonyLensFeatures(table_buf[0], table_buf[7]);",
          "9134:             free(table_buf);",
          "9138:     fseek(ifp,_pos,SEEK_SET);",
          "9139: #endif",
          "9141:     if (tag == 2 && strstr(make,\"NIKON\") && !iso_speed)",
          "9142:       iso_speed = (get2(),get2());",
          "9143:     if (tag == 37 && strstr(make,\"NIKON\") && (!iso_speed || iso_speed == 65535))",
          "9145:         unsigned char cc;",
          "9146:         fread(&cc,1,1,ifp);",
          "9147:         iso_speed = int(100.0 * powf64(2.0f,float(cc)/12.0-5.0));",
          "9149:     if (tag == 4 && len > 26 && len < 35) {",
          "9150:       if ((i=(get4(),get2())) != 0x7fff && (!iso_speed || iso_speed == 65535))",
          "9151:  iso_speed = 50 * powf64(2.0, i/32.0 - 4);",
          "9152: #ifdef LIBRAW_LIBRARY_BUILD",
          "9153:       get4();",
          "9154: #else",
          "9155:       if ((i=(get2(),get2())) != 0x7fff && !aperture)",
          "9156:  aperture = powf64(2.0, i/64.0);",
          "9157: #endif",
          "9158:       if ((i=get2()) != 0xffff && !shutter)",
          "9159:  shutter = powf64(2.0, (short) i/-32.0);",
          "9160:       wbi = (get2(),get2());",
          "9161:       shot_order = (get2(),get2());",
          "9162:     }",
          "9163:     if ((tag == 4 || tag == 0x114) && !strncmp(make,\"KONICA\",6)) {",
          "9164:       fseek (ifp, tag == 4 ? 140:160, SEEK_CUR);",
          "9165:       switch (get2()) {",
          "9166:  case 72:  flip = 0;  break;",
          "9167:  case 76:  flip = 6;  break;",
          "9168:  case 82:  flip = 5;  break;",
          "9171:     if (tag == 7 && type == 2 && len > 20)",
          "9172:       fgets (model2, 64, ifp);",
          "9173:     if (tag == 8 && type == 4)",
          "9174:       shot_order = get4();",
          "9175:     if (tag == 9 && !strncmp(make,\"Canon\",5))",
          "9176:       fread (artist, 64, 1, ifp);",
          "9177:     if (tag == 0xc && len == 4)",
          "9178:       FORC3 cam_mul[(c << 1 | c >> 1) & 3] = getreal(type);",
          "9179:     if (tag == 0xd && type == 7 && get2() == 0xaaaa) {",
          "9180:       for (c=i=2; (ushort) c != 0xbbbb && i < len; i++)",
          "9181:  c = c << 8 | fgetc(ifp);",
          "9182:       while ((i+=4) < len-5)",
          "9183:  if (get4() == 257 && (i=len) && (c = (get4(),fgetc(ifp))) < 3)",
          "9184:    flip = \"065\"[c]-'0';",
          "9185:     }",
          "9187: #ifndef LIBRAW_LIBRARY_BUILD",
          "9188:     if (tag == 0x10 && type == 4) unique_id = get4();",
          "9191: #ifdef LIBRAW_LIBRARY_BUILD",
          "9192:     INT64 _pos2 = ftell(ifp);",
          "9193:  if (!strncasecmp(make,\"Olympus\",7))",
          "9194:  {",
          "9195:    short nWB, tWB;",
          "9196:    if ((tag == 0x20300108) || (tag == 0x20310109))",
          "9197:        imgdata.makernotes.olympus.ColorSpace = get2();",
          "9199:    if ((tag == 0x20400102) && (len == 2) &&",
          "9200:        (!strncasecmp(model, \"E-410\", 5) || !strncasecmp(model, \"E-510\", 5)))",
          "9201:      {",
          "9202:        int i;",
          "9203:        for (i=0; i<64; i++)",
          "9204:   imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] =",
          "9205:     imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;",
          "9206:        for (i=64; i<256; i++)",
          "9207:   imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;",
          "9208:      }",
          "9209:    if ((tag >= 0x20400102) && (tag <= 0x2040010d))",
          "9210:      {",
          "9211:        ushort CT;",
          "9212:        nWB = tag-0x20400102;",
          "9213:        switch (nWB)",
          "9214:   {",
          "9215:                 case 0 : CT = 3000; tWB = LIBRAW_WBI_Tungsten; break;",
          "9216:   case 1 : CT = 3300; tWB = 0x100; break;",
          "9217:   case 2 : CT = 3600; tWB = 0x100; break;",
          "9218:   case 3 : CT = 3900; tWB = 0x100; break;",
          "9219:                 case 4 : CT = 4000; tWB = LIBRAW_WBI_FL_W; break;",
          "9220:   case 5 : CT = 4300; tWB = 0x100; break;",
          "9221:                 case 6 : CT = 4500; tWB = LIBRAW_WBI_FL_D; break;",
          "9222:   case 7 : CT = 4800; tWB = 0x100; break;",
          "9223:                 case 8 : CT = 5300; tWB = LIBRAW_WBI_FineWeather; break;",
          "9224:                 case 9 : CT = 6000; tWB = LIBRAW_WBI_Cloudy; break;",
          "9225:                 case 10: CT = 6600; tWB = LIBRAW_WBI_FL_N; break;",
          "9226:                 case 11: CT = 7500; tWB = LIBRAW_WBI_Shade; break;",
          "9227:   default: CT = 0; tWB = 0x100;",
          "9228:   }",
          "9229:        if (CT)",
          "9230:   {",
          "9231:     imgdata.color.WBCT_Coeffs[nWB][0] = CT;",
          "9232:     imgdata.color.WBCT_Coeffs[nWB][1] = get2();",
          "9233:     imgdata.color.WBCT_Coeffs[nWB][3] = get2();",
          "9234:     if (len == 4)",
          "9235:       {",
          "9236:         imgdata.color.WBCT_Coeffs[nWB][2] = get2();",
          "9237:         imgdata.color.WBCT_Coeffs[nWB][4] = get2();",
          "9238:       }",
          "9239:   }",
          "9240:        if (tWB != 0x100)",
          "9241:   FORC4 imgdata.color.WB_Coeffs[tWB][c] = imgdata.color.WBCT_Coeffs[nWB][c+1];",
          "9242:      }",
          "9243:    if ((tag >= 0x20400113) && (tag <= 0x2040011e))",
          "9244:      {",
          "9245:        nWB = tag-0x20400113;",
          "9246:        imgdata.color.WBCT_Coeffs[nWB][2] = imgdata.color.WBCT_Coeffs[nWB][4] = get2();",
          "9247:        switch (nWB)",
          "9248:   {",
          "9249:                 case 0:  tWB = LIBRAW_WBI_Tungsten; break;",
          "9250:                 case 4:  tWB = LIBRAW_WBI_FL_W; break;",
          "9251:                 case 6:  tWB = LIBRAW_WBI_FL_D; break;",
          "9252:                 case 8:  tWB = LIBRAW_WBI_FineWeather; break;",
          "9253:                 case 9:  tWB = LIBRAW_WBI_Cloudy; break;",
          "9254:                 case 10: tWB = LIBRAW_WBI_FL_N; break;",
          "9255:                 case 11: tWB = LIBRAW_WBI_Shade; break;",
          "9256:   default: tWB = 0x100;",
          "9257:   }",
          "9258:        if (tWB != 0x100)",
          "9259:   imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] =",
          "9260:     imgdata.color.WBCT_Coeffs[nWB][2];",
          "9261:      }",
          "9263:    if (tag == 0x20400121)",
          "9264:      {",
          "9265:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();",
          "9266:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();",
          "9267:        if (len == 4)",
          "9268:   {",
          "9269:                   imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = get2();",
          "9270:                   imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();",
          "9271:   }",
          "9272:      }",
          "9273:    if (tag == 0x2040011f)",
          "9274:      {",
          "9275:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();",
          "9276:      }",
          "9277:    if (tag == 0x30000120)",
          "9278:      {",
          "9279:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();",
          "9280:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();",
          "9281:        if (len == 2)",
          "9282:   {",
          "9283:     for (int i=0; i<256; i++)",
          "9284:       imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;",
          "9285:   }",
          "9286:      }",
          "9287:    if (tag == 0x30000121)",
          "9288:      {",
          "9289:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();",
          "9290:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();",
          "9291:      }",
          "9292:    if (tag == 0x30000122)",
          "9293:      {",
          "9294:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = get2();",
          "9295:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = get2();",
          "9296:      }",
          "9297:    if (tag == 0x30000123)",
          "9298:      {",
          "9299:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();",
          "9300:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();",
          "9301:      }",
          "9302:    if (tag == 0x30000124)",
          "9303:      {",
          "9304:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Sunset][0] = get2();",
          "9305:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Sunset][2] = get2();",
          "9306:      }",
          "9307:    if (tag == 0x30000130)",
          "9308:      {",
          "9309:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();",
          "9310:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();",
          "9311:      }",
          "9312:    if (tag == 0x30000131)",
          "9313:      {",
          "9314:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();",
          "9315:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();",
          "9316:      }",
          "9317:    if (tag == 0x30000132)",
          "9318:      {",
          "9319:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();",
          "9320:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();",
          "9321:      }",
          "9322:    if (tag == 0x30000133)",
          "9323:      {",
          "9324:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();",
          "9325:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();",
          "9326:      }",
          "9328:    if((tag == 0x20400805) && (len == 2))",
          "9329:      {",
          "9330:        imgdata.makernotes.olympus.OlympusSensorCalibration[0]=getreal(type);",
          "9331:        imgdata.makernotes.olympus.OlympusSensorCalibration[1]=getreal(type);",
          "9332:        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.olympus.OlympusSensorCalibration[0];",
          "9333:      }",
          "9334:    if (tag == 0x20200401)",
          "9335:      {",
          "9336:        imgdata.other.FlashEC = getreal(type);",
          "9337:      }",
          "9338:  }",
          "9339:     fseek(ifp,_pos2,SEEK_SET);",
          "9341: #endif",
          "9342:     if (tag == 0x11 && is_raw && !strncmp(make,\"NIKON\",5)) {",
          "9343:       fseek (ifp, get4()+base, SEEK_SET);",
          "9344:       parse_tiff_ifd (base);",
          "9345:     }",
          "9346:     if (tag == 0x14 && type == 7) {",
          "9347:       if (len == 2560) {",
          "9348:  fseek (ifp, 1248, SEEK_CUR);",
          "9349:  goto get2_256;",
          "9350:       }",
          "9351:       fread (buf, 1, 10, ifp);",
          "9352:       if (!strncmp(buf,\"NRW \",4)) {",
          "9353:  fseek (ifp, strcmp(buf+4,\"0100\") ? 46:1546, SEEK_CUR);",
          "9354:  cam_mul[0] = get4() << 2;",
          "9355:  cam_mul[1] = get4() + get4();",
          "9356:  cam_mul[2] = get4() << 2;",
          "9360:       fread (model, 64, 1, ifp);",
          "9361:     if (strstr(make,\"PENTAX\")) {",
          "9362:       if (tag == 0x1b) tag = 0x1018;",
          "9363:       if (tag == 0x1c) tag = 0x1017;",
          "9365:     if (tag == 0x1d) {",
          "9371:           if ((strbuflen(model) == 3) && (!strcmp(model,\"D50\")))",
          "",
          "[Added Lines]",
          "8940:      The MakerNote might have its own TIFF header (possibly with",
          "8941:      its own byte-order!), or it might just be a table.",
          "8943:   if (!strncmp(make, \"Nokia\", 5))",
          "8944:     return;",
          "8945:   fread(buf, 1, 10, ifp);",
          "8947:       !strncmp(buf, \"VER\", 3) || !strncmp(buf, \"IIII\", 4) || !strncmp(buf, \"MMMM\", 4))",
          "8948:     return;",
          "8950:       !strncmp(buf, \"MLY\", 3))",
          "8953:     while ((i = ftell(ifp)) < data_offset && i < 16384)",
          "8954:     {",
          "8955:       wb[0] = wb[2];",
          "8956:       wb[2] = wb[1];",
          "8957:       wb[1] = wb[3];",
          "8959:       if (wb[1] == 256 && wb[3] == 256 && wb[0] > 256 && wb[0] < 640 && wb[2] > 256 && wb[2] < 640)",
          "8960:         FORC4 cam_mul[c] = wb[c];",
          "8964:   if (!strcmp(buf, \"Nikon\"))",
          "8965:   {",
          "8968:     if (get2() != 42)",
          "8969:       goto quit;",
          "8971:     fseek(ifp, offset - 8, SEEK_CUR);",
          "8972:   }",
          "8973:   else if (!strcmp(buf, \"OLYMPUS\") || !strcmp(buf, \"PENTAX \"))",
          "8974:   {",
          "8975:     base = ftell(ifp) - 10;",
          "8976:     fseek(ifp, -2, SEEK_CUR);",
          "8978:     if (buf[0] == 'O')",
          "8979:       get2();",
          "8980:   }",
          "8981:   else if (!strncmp(buf, \"SONY\", 4) || !strcmp(buf, \"Panasonic\"))",
          "8982:   {",
          "8984:   }",
          "8985:   else if (!strncmp(buf, \"FUJIFILM\", 8))",
          "8986:   {",
          "8987:     base = ftell(ifp) - 10;",
          "8988:   nf:",
          "8989:     order = 0x4949;",
          "8990:     fseek(ifp, 2, SEEK_CUR);",
          "8991:   }",
          "8992:   else if (!strcmp(buf, \"OLYMP\") || !strcmp(buf, \"LEICA\") || !strcmp(buf, \"Ricoh\") || !strcmp(buf, \"EPSON\"))",
          "8993:     fseek(ifp, -2, SEEK_CUR);",
          "8994:   else if (!strcmp(buf, \"AOC\") || !strcmp(buf, \"QVC\"))",
          "8995:     fseek(ifp, -4, SEEK_CUR);",
          "8996:   else",
          "8997:   {",
          "8998:     fseek(ifp, -10, SEEK_CUR);",
          "8999:     if (!strncmp(make, \"SAMSUNG\", 7))",
          "9005:   {",
          "9006:     if (!strncmp(model, \"M8\", 2) || !strncasecmp(model, \"Leica M8\", 8) || !strncasecmp(model, \"LEICA X\", 7))",
          "9008:       base = ftell(ifp) - 8;",
          "9009:     }",
          "9010:     else if (!strncasecmp(model, \"LEICA M (Typ 240)\", 17))",
          "9011:     {",
          "9012:       base = 0;",
          "9013:     }",
          "9014:     else if (!strncmp(model, \"M9\", 2) || !strncasecmp(model, \"Leica M9\", 8) || !strncasecmp(model, \"M Monochrom\", 11) ||",
          "9015:              !strncasecmp(model, \"Leica M Monochrom\", 11))",
          "9016:     {",
          "9017:       if (!uptag)",
          "9018:       {",
          "9019:         base = ftell(ifp) - 10;",
          "9020:         fseek(ifp, 8, SEEK_CUR);",
          "9021:       }",
          "9022:       else if (uptag == 0x3400)",
          "9023:       {",
          "9024:         fseek(ifp, 10, SEEK_CUR);",
          "9025:         base += 10;",
          "9026:       }",
          "9027:     }",
          "9028:     else if (!strncasecmp(model, \"LEICA T\", 7))",
          "9029:     {",
          "9030:       base = ftell(ifp) - 8;",
          "9032:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_T;",
          "9034:     }",
          "9036:     else if (!strncasecmp(model, \"LEICA SL\", 8))",
          "9037:     {",
          "9038:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_SL;",
          "9039:       imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;",
          "9041: #endif",
          "9042:   }",
          "9045:   if (entries > 1000)",
          "9046:     return;",
          "9049:   while (entries--)",
          "9050:   {",
          "9052:     tiff_get(base, &tag, &type, &len, &save);",
          "9057:     if (len > 8 && _pos + len > 2 * fsize)",
          "9058:       continue;",
          "9059:     if (!strncmp(make, \"Canon\", 5))",
          "9060:     {",
          "9061:       if (tag == 0x000d && len < 256000) // camera info",
          "9063:         CanonCameraInfo = (uchar *)malloc(len);",
          "9064:         fread(CanonCameraInfo, len, 1, ifp);",
          "9065:         lenCanonCameraInfo = len;",
          "9066:       }",
          "9068:       else if (tag == 0x10) // Canon ModelID",
          "9069:       {",
          "9070:         unique_id = get4();",
          "9071:         if (unique_id == 0x03740000)",
          "9072:           unique_id = 0x80000374; // M3",
          "9073:         if (unique_id == 0x03840000)",
          "9074:           unique_id = 0x80000384; // M10",
          "9075:         if (unique_id == 0x03940000)",
          "9076:           unique_id = 0x80000394; // M5",
          "9077:         setCanonBodyFeatures(unique_id);",
          "9078:         if (lenCanonCameraInfo)",
          "9079:         {",
          "9080:           processCanonCameraInfo(unique_id, CanonCameraInfo, lenCanonCameraInfo);",
          "9081:           free(CanonCameraInfo);",
          "9082:           CanonCameraInfo = 0;",
          "9083:           lenCanonCameraInfo = 0;",
          "9084:         }",
          "9088:         parseCanonMakernotes(tag, type, len);",
          "9091:     else if (!strncmp(make, \"FUJI\", 4))",
          "9092:     {",
          "9093:       if (tag == 0x0010)",
          "9095:         char FujiSerial[sizeof(imgdata.shootinginfo.InternalBodySerial)];",
          "9096:         char *words[4];",
          "9097:         char yy[2], mm[3], dd[3], ystr[16], ynum[16];",
          "9098:         int year, nwords, ynum_len;",
          "9099:         unsigned c;",
          "9100:         stmread(FujiSerial, len, ifp);",
          "9101:         nwords = getwords(FujiSerial, words, 4, sizeof(imgdata.shootinginfo.InternalBodySerial));",
          "9102:         for (int i = 0; i < nwords; i++)",
          "9104:           mm[2] = dd[2] = 0;",
          "9105:           if (strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) < 18)",
          "9106:             if (i == 0)",
          "9107:               strncpy(imgdata.shootinginfo.InternalBodySerial, words[0],",
          "9108:                       sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);",
          "9109:             else",
          "9110:             {",
          "9111:               char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];",
          "9112:               snprintf(tbuf, sizeof(tbuf), \"%s %s\", imgdata.shootinginfo.InternalBodySerial, words[i]);",
          "9113:               strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,",
          "9114:                       sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);",
          "9115:             }",
          "9116:           else",
          "9118:             strncpy(dd, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 14, 2);",
          "9119:             strncpy(mm, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 16, 2);",
          "9120:             strncpy(yy, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 18, 2);",
          "9121:             year = (yy[0] - '0') * 10 + (yy[1] - '0');",
          "9122:             if (year < 70)",
          "9123:               year += 2000;",
          "9124:             else",
          "9125:               year += 1900;",
          "9127:             ynum_len = (int)strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 18;",
          "9128:             strncpy(ynum, words[i], ynum_len);",
          "9129:             ynum[ynum_len] = 0;",
          "9130:             for (int j = 0; ynum[j] && ynum[j + 1] && sscanf(ynum + j, \"%2x\", &c); j += 2)",
          "9131:               ystr[j / 2] = c;",
          "9132:             ystr[ynum_len / 2 + 1] = 0;",
          "9133:             strcpy(model2, ystr);",
          "9135:             if (i == 0)",
          "9136:             {",
          "9137:               char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];",
          "9139:               if (nwords == 1)",
          "9140:                 snprintf(tbuf, sizeof(tbuf), \"%s %s %d:%s:%s\",",
          "9141:                          words[0] + strnlen(words[0], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 12, ystr,",
          "9142:                          year, mm, dd);",
          "9144:               else",
          "9145:                 snprintf(tbuf, sizeof(tbuf), \"%s %d:%s:%s %s\", ystr, year, mm, dd,",
          "9146:                          words[0] + strnlen(words[0], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 12);",
          "9148:               strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,",
          "9149:                       sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);",
          "9150:             }",
          "9151:             else",
          "9153:               char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];",
          "9154:               snprintf(tbuf, sizeof(tbuf), \"%s %s %d:%s:%s %s\", imgdata.shootinginfo.InternalBodySerial, ystr, year, mm,",
          "9155:                        dd, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 12);",
          "9156:               strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,",
          "9157:                       sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);",
          "9160:         }",
          "9162:       else",
          "9163:         parseFujiMakernotes(tag, type);",
          "9164:     }",
          "9166:     else if (!strncasecmp(make, \"LEICA\", 5))",
          "9167:     {",
          "9168:       if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))",
          "9170:         int ind = tag == 0x035e ? 0 : 1;",
          "9171:         for (int j = 0; j < 3; j++)",
          "9172:           FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c] = getreal(type);",
          "9175:       if ((tag == 0x0303) && (type != 4))",
          "9176:       {",
          "9177:         stmread(imgdata.lens.makernotes.Lens, len, ifp);",
          "9178:       }",
          "9180:       if ((tag == 0x3405) || (tag == 0x0310) || (tag == 0x34003405))",
          "9181:       {",
          "9182:         imgdata.lens.makernotes.LensID = get4();",
          "9183:         imgdata.lens.makernotes.LensID =",
          "9184:             ((imgdata.lens.makernotes.LensID >> 2) << 8) | (imgdata.lens.makernotes.LensID & 0x3);",
          "9185:         if (imgdata.lens.makernotes.LensID != -1)",
          "9186:         {",
          "9187:           if ((model[0] == 'M') || !strncasecmp(model, \"LEICA M\", 7))",
          "9189:             imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;",
          "9190:             if (imgdata.lens.makernotes.LensID)",
          "9191:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;",
          "9193:           else if ((model[0] == 'S') || !strncasecmp(model, \"LEICA S\", 7))",
          "9195:             imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;",
          "9196:             if (imgdata.lens.makernotes.Lens[0])",
          "9197:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;",
          "9199:         }",
          "9202:       else if (((tag == 0x0313) || (tag == 0x34003406)) && (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&",
          "9203:                ((type == 10) || (type == 5)))",
          "9205:         imgdata.lens.makernotes.CurAp = getreal(type);",
          "9206:         if (imgdata.lens.makernotes.CurAp > 126.3)",
          "9207:           imgdata.lens.makernotes.CurAp = 0.0f;",
          "9208:       }",
          "9210:       else if (tag == 0x3400)",
          "9211:       {",
          "9212:         parse_makernote(base, 0x3400);",
          "9213:       }",
          "9214:     }",
          "9216:     else if (!strncmp(make, \"NIKON\", 5))",
          "9217:     {",
          "9218:       if (tag == 0x000a)",
          "9219:       {",
          "9220:         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "9221:         imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "9223:       else if (tag == 0x0012)",
          "9225:         char a, b, c;",
          "9226:         a = fgetc(ifp);",
          "9227:         b = fgetc(ifp);",
          "9228:         c = fgetc(ifp);",
          "9229:         if (c)",
          "9230:           imgdata.other.FlashEC = (float)(a * b) / (float)c;",
          "9231:       }",
          "9232:       else if (tag == 0x0082) // lens attachment",
          "9233:       {",
          "9234:         stmread(imgdata.lens.makernotes.Attachment, len, ifp);",
          "9235:       }",
          "9236:       else if (tag == 0x0083) // lens type",
          "9237:       {",
          "9238:         imgdata.lens.nikon.NikonLensType = fgetc(ifp);",
          "9239:       }",
          "9240:       else if (tag == 0x0084) // lens",
          "9241:       {",
          "9242:         imgdata.lens.makernotes.MinFocal = getreal(type);",
          "9243:         imgdata.lens.makernotes.MaxFocal = getreal(type);",
          "9244:         imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);",
          "9245:         imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);",
          "9246:       }",
          "9247:       else if (tag == 0x008b) // lens f-stops",
          "9248:       {",
          "9249:         uchar a, b, c;",
          "9250:         a = fgetc(ifp);",
          "9251:         b = fgetc(ifp);",
          "9252:         c = fgetc(ifp);",
          "9253:         if (c)",
          "9255:           imgdata.lens.nikon.NikonLensFStops = a * b * (12 / c);",
          "9256:           imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops / 12.0f;",
          "9258:       }",
          "9259:       else if (tag == 0x0093)",
          "9260:       {",
          "9261:         i = get2();",
          "9262:         if ((i == 7) || (i == 9))",
          "9264:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "9265:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "9267:       }",
          "9268:       else if (tag == 0x0098) // contains lens data",
          "9269:       {",
          "9270:         for (i = 0; i < 4; i++)",
          "9272:           NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';",
          "9274:         switch (NikonLensDataVersion)",
          "9276:         case 100:",
          "9277:           lenNikonLensData = 9;",
          "9278:           break;",
          "9279:         case 101:",
          "9280:         case 201: // encrypted, starting from v.201",
          "9281:         case 202:",
          "9282:         case 203:",
          "9283:           lenNikonLensData = 15;",
          "9284:           break;",
          "9285:         case 204:",
          "9286:           lenNikonLensData = 16;",
          "9287:           break;",
          "9288:         case 400:",
          "9289:           lenNikonLensData = 459;",
          "9290:           break;",
          "9291:         case 401:",
          "9292:           lenNikonLensData = 590;",
          "9293:           break;",
          "9294:         case 402:",
          "9295:           lenNikonLensData = 509;",
          "9296:           break;",
          "9297:         case 403:",
          "9298:           lenNikonLensData = 879;",
          "9299:           break;",
          "9301:         if (lenNikonLensData > 0)",
          "9303:           table_buf = (uchar *)malloc(lenNikonLensData);",
          "9304:           fread(table_buf, lenNikonLensData, 1, ifp);",
          "9305:           if ((NikonLensDataVersion < 201) && lenNikonLensData)",
          "9306:           {",
          "9307:             processNikonLensData(table_buf, lenNikonLensData);",
          "9308:             free(table_buf);",
          "9309:             lenNikonLensData = 0;",
          "9310:           }",
          "9312:       }",
          "9313:       else if (tag == 0x00a0)",
          "9314:       {",
          "9315:         stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "9316:       }",
          "9317:       else if (tag == 0x00a8) // contains flash data",
          "9318:       {",
          "9319:         for (i = 0; i < 4; i++)",
          "9321:           NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';",
          "9323:       }",
          "9324:     }",
          "9326:     else if (!strncmp(make, \"OLYMPUS\", 7))",
          "9327:     {",
          "9328:       switch (tag)",
          "9329:       {",
          "9330:       case 0x0404:",
          "9331:       case 0x101a:",
          "9332:       case 0x20100101:",
          "9333:         if (!imgdata.shootinginfo.BodySerial[0])",
          "9334:           stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "9335:         break;",
          "9336:       case 0x20100102:",
          "9337:         if (!imgdata.shootinginfo.InternalBodySerial[0])",
          "9338:           stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);",
          "9339:         break;",
          "9340:       case 0x0207:",
          "9341:       case 0x20100100:",
          "9342:       {",
          "9343:         uchar sOlyID[8];",
          "9344:         unsigned long long OlyID;",
          "9345:         fread(sOlyID, MIN(len, 7), 1, ifp);",
          "9346:         sOlyID[7] = 0;",
          "9347:         OlyID = sOlyID[0];",
          "9348:         i = 1;",
          "9349:         while (i < 7 && sOlyID[i])",
          "9351:           OlyID = OlyID << 8 | sOlyID[i];",
          "9352:           i++;",
          "9354:         setOlympusBodyFeatures(OlyID);",
          "9355:       }",
          "9356:       break;",
          "9357:       case 0x1002:",
          "9358:         imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type) / 2);",
          "9359:         break;",
          "9360:       case 0x20401112:",
          "9361:         imgdata.makernotes.olympus.OlympusCropID = get2();",
          "9362:         break;",
          "9363:       case 0x20401113:",
          "9364:         FORC4 imgdata.makernotes.olympus.OlympusFrame[c] = get2();",
          "9365:         break;",
          "9366:       case 0x20100201:",
          "9367:       {",
          "9368:         unsigned long long oly_lensid[3];",
          "9369:         oly_lensid[0] = fgetc(ifp);",
          "9370:         fgetc(ifp);",
          "9371:         oly_lensid[1] = fgetc(ifp);",
          "9372:         oly_lensid[2] = fgetc(ifp);",
          "9373:         imgdata.lens.makernotes.LensID = (oly_lensid[0] << 16) | (oly_lensid[1] << 8) | oly_lensid[2];",
          "9374:       }",
          "9375:         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;",
          "9376:         imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;",
          "9377:         if (((imgdata.lens.makernotes.LensID < 0x20000) || (imgdata.lens.makernotes.LensID > 0x4ffff)) &&",
          "9378:             (imgdata.lens.makernotes.LensID & 0x10))",
          "9380:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;",
          "9382:         break;",
          "9383:       case 0x20100202:",
          "9384:         stmread(imgdata.lens.LensSerial, len, ifp);",
          "9385:         break;",
          "9386:       case 0x20100203:",
          "9387:         stmread(imgdata.lens.makernotes.Lens, len, ifp);",
          "9388:         break;",
          "9389:       case 0x20100205:",
          "9390:         imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "9391:         break;",
          "9392:       case 0x20100206:",
          "9393:         imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "9394:         break;",
          "9395:       case 0x20100207:",
          "9396:         imgdata.lens.makernotes.MinFocal = (float)get2();",
          "9397:         break;",
          "9398:       case 0x20100208:",
          "9399:         imgdata.lens.makernotes.MaxFocal = (float)get2();",
          "9400:         if (imgdata.lens.makernotes.MaxFocal > 1000.0f)",
          "9401:           imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;",
          "9402:         break;",
          "9403:       case 0x2010020a:",
          "9404:         imgdata.lens.makernotes.MaxAp4CurFocal = powf64(sqrt(2.0f), get2() / 256.0f);",
          "9405:         break;",
          "9406:       case 0x20100301:",
          "9407:         imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;",
          "9408:         fgetc(ifp);",
          "9409:         imgdata.lens.makernotes.TeleconverterID = imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);",
          "9410:         break;",
          "9411:       case 0x20100303:",
          "9412:         stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);",
          "9413:         break;",
          "9414:       case 0x20100403:",
          "9415:         stmread(imgdata.lens.makernotes.Attachment, len, ifp);",
          "9416:         break;",
          "9417:       }",
          "9418:     }",
          "9420:     else if ((!strncmp(make, \"PENTAX\", 6) || !strncmp(make, \"RICOH\", 5)) && !strncmp(model, \"GR\", 2))",
          "9421:     {",
          "9422:       if (tag == 0x0005)",
          "9423:       {",
          "9424:         char buffer[17];",
          "9425:         int count = 0;",
          "9426:         fread(buffer, 16, 1, ifp);",
          "9427:         buffer[16] = 0;",
          "9428:         for (int i = 0; i < 16; i++)",
          "9431:           if ((isspace(buffer[i])) || (buffer[i] == 0x2D) || (isalnum(buffer[i])))",
          "9432:             count++;",
          "9434:         if (count == 16)",
          "9436:           sprintf(imgdata.shootinginfo.BodySerial, \"%8s\", buffer + 8);",
          "9437:           buffer[8] = 0;",
          "9438:           sprintf(imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);",
          "9440:         else",
          "9442:           sprintf(imgdata.shootinginfo.BodySerial, \"%02x%02x%02x%02x\", buffer[4], buffer[5], buffer[6], buffer[7]);",
          "9443:           sprintf(imgdata.shootinginfo.InternalBodySerial, \"%02x%02x%02x%02x\", buffer[8], buffer[9], buffer[10],",
          "9444:                   buffer[11]);",
          "9445:         }",
          "9446:       }",
          "9447:       else if ((tag == 0x1001) && (type == 3))",
          "9448:       {",
          "9449:         imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "9450:         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "9451:         imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;",
          "9452:         imgdata.lens.makernotes.LensID = -1;",
          "9453:         imgdata.lens.makernotes.FocalType = 1;",
          "9454:       }",
          "9456:       else if ((tag == 0x100b) && (type == 10))",
          "9457:       {",
          "9458:         imgdata.other.FlashEC = getreal(type);",
          "9459:       }",
          "9461:       else if ((tag == 0x1017) && (get2() == 2))",
          "9462:       {",
          "9463:         strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");",
          "9464:       }",
          "9465:       else if (tag == 0x1500)",
          "9466:       {",
          "9467:         imgdata.lens.makernotes.CurFocal = getreal(type);",
          "9468:       }",
          "9469:     }",
          "9471:     else if (!strncmp(make, \"RICOH\", 5) && strncmp(model, \"PENTAX\", 6))",
          "9472:     {",
          "9473:       if ((tag == 0x0005) && !strncmp(model, \"GXR\", 3))",
          "9474:       {",
          "9475:         char buffer[9];",
          "9476:         buffer[8] = 0;",
          "9477:         fread(buffer, 8, 1, ifp);",
          "9478:         sprintf(imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);",
          "9479:       }",
          "9481:       else if ((tag == 0x100b) && (type == 10))",
          "9482:       {",
          "9483:         imgdata.other.FlashEC = getreal(type);",
          "9484:       }",
          "9486:       else if ((tag == 0x1017) && (get2() == 2))",
          "9487:       {",
          "9488:         strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");",
          "9489:       }",
          "9491:       else if (tag == 0x1500)",
          "9492:       {",
          "9493:         imgdata.lens.makernotes.CurFocal = getreal(type);",
          "9494:       }",
          "9496:       else if ((tag == 0x2001) && !strncmp(model, \"GXR\", 3))",
          "9497:       {",
          "9498:         short ntags, cur_tag;",
          "9499:         fseek(ifp, 20, SEEK_CUR);",
          "9500:         ntags = get2();",
          "9501:         cur_tag = get2();",
          "9502:         while (cur_tag != 0x002c)",
          "9503:         {",
          "9504:           fseek(ifp, 10, SEEK_CUR);",
          "9505:           cur_tag = get2();",
          "9507:         fseek(ifp, 6, SEEK_CUR);",
          "9508:         fseek(ifp, get4() + 20, SEEK_SET);",
          "9509:         stread(imgdata.shootinginfo.BodySerial, 12, ifp);",
          "9510:         get2();",
          "9511:         imgdata.lens.makernotes.LensID = getc(ifp) - '0';",
          "9512:         switch (imgdata.lens.makernotes.LensID)",
          "9513:         {",
          "9514:         case 1:",
          "9515:         case 2:",
          "9516:         case 3:",
          "9517:         case 5:",
          "9518:         case 6:",
          "9519:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "9520:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_RicohModule;",
          "9521:           break;",
          "9522:         case 8:",
          "9523:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;",
          "9524:           imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;",
          "9525:           imgdata.lens.makernotes.LensID = -1;",
          "9526:           break;",
          "9527:         default:",
          "9528:           imgdata.lens.makernotes.LensID = -1;",
          "9529:         }",
          "9530:         fseek(ifp, 17, SEEK_CUR);",
          "9531:         stread(imgdata.lens.LensSerial, 12, ifp);",
          "9532:       }",
          "9533:     }",
          "9535:     else if ((!strncmp(make, \"PENTAX\", 6) || !strncmp(model, \"PENTAX\", 6) ||",
          "9536:               (!strncmp(make, \"SAMSUNG\", 7) && dng_version)) &&",
          "9537:              strncmp(model, \"GR\", 2))",
          "9538:     {",
          "9539:       if (tag == 0x0005)",
          "9540:       {",
          "9541:         unique_id = get4();",
          "9542:         setPentaxBodyFeatures(unique_id);",
          "9543:       }",
          "9544:       else if (tag == 0x0013)",
          "9545:       {",
          "9546:         imgdata.lens.makernotes.CurAp = (float)get2() / 10.0f;",
          "9547:       }",
          "9548:       else if (tag == 0x0014)",
          "9549:       {",
          "9550:         PentaxISO(get2());",
          "9551:       }",
          "9552:       else if (tag == 0x001d)",
          "9553:       {",
          "9554:         imgdata.lens.makernotes.CurFocal = (float)get4() / 100.0f;",
          "9555:       }",
          "9556:       else if (tag == 0x003f)",
          "9557:       {",
          "9558:         imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);",
          "9559:       }",
          "9560:       else if (tag == 0x004d)",
          "9561:       {",
          "9562:         if (type == 9)",
          "9563:           imgdata.other.FlashEC = getreal(type) / 256.0f;",
          "9564:         else",
          "9565:           imgdata.other.FlashEC = (float)((signed short)fgetc(ifp)) / 6.0f;",
          "9566:       }",
          "9567:       else if (tag == 0x007e)",
          "9568:       {",
          "9569:         imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =",
          "9570:             imgdata.color.linear_max[3] = (long)(-1) * get4();",
          "9571:       }",
          "9572:       else if (tag == 0x0207)",
          "9573:       {",
          "9574:         if (len < 65535) // Safety belt",
          "9575:           PentaxLensInfo(imgdata.lens.makernotes.CamID, len);",
          "9576:       }",
          "9577:       else if (tag == 0x020d)",
          "9578:       {",
          "9579:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();",
          "9580:       }",
          "9581:       else if (tag == 0x020e)",
          "9582:       {",
          "9583:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();",
          "9584:       }",
          "9585:       else if (tag == 0x020f)",
          "9586:       {",
          "9587:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();",
          "9588:       }",
          "9589:       else if (tag == 0x0210)",
          "9590:       {",
          "9591:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();",
          "9592:       }",
          "9593:       else if (tag == 0x0211)",
          "9594:       {",
          "9595:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();",
          "9596:       }",
          "9597:       else if (tag == 0x0212)",
          "9598:       {",
          "9599:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();",
          "9600:       }",
          "9601:       else if (tag == 0x0213)",
          "9602:       {",
          "9603:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();",
          "9604:       }",
          "9605:       else if (tag == 0x0214)",
          "9606:       {",
          "9607:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();",
          "9608:       }",
          "9609:       else if (tag == 0x0221)",
          "9610:       {",
          "9611:         int nWB = get2();",
          "9612:         if (nWB <= sizeof(imgdata.color.WBCT_Coeffs) / sizeof(imgdata.color.WBCT_Coeffs[0]))",
          "9613:           for (int i = 0; i < nWB; i++)",
          "9615:             imgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();",
          "9616:             fseek(ifp, 2, SEEK_CUR);",
          "9617:             imgdata.color.WBCT_Coeffs[i][1] = get2();",
          "9618:             imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;",
          "9619:             imgdata.color.WBCT_Coeffs[i][3] = get2();",
          "9622:       else if (tag == 0x0215)",
          "9623:       {",
          "9624:         fseek(ifp, 16, SEEK_CUR);",
          "9625:         sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());",
          "9626:       }",
          "9627:       else if (tag == 0x0229)",
          "9628:       {",
          "9629:         stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "9630:       }",
          "9631:       else if (tag == 0x022d)",
          "9632:       {",
          "9633:         fseek(ifp, 2, SEEK_CUR);",
          "9634:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();",
          "9635:         getc(ifp);",
          "9636:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();",
          "9637:         getc(ifp);",
          "9638:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();",
          "9639:         getc(ifp);",
          "9640:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();",
          "9641:         getc(ifp);",
          "9642:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();",
          "9643:         getc(ifp);",
          "9644:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();",
          "9645:         getc(ifp);",
          "9646:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();",
          "9647:         getc(ifp);",
          "9648:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();",
          "9649:         getc(ifp);",
          "9650:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ (c >> 1)] = get2();",
          "9651:       }",
          "9652:       else if (tag == 0x0239) // Q-series lens info (LensInfoQ)",
          "9653:       {",
          "9654:         char LensInfo[20];",
          "9655:         fseek(ifp, 2, SEEK_CUR);",
          "9656:         stread(imgdata.lens.makernotes.Lens, 30, ifp);",
          "9657:         strcat(imgdata.lens.makernotes.Lens, \" \");",
          "9658:         stread(LensInfo, 20, ifp);",
          "9659:         strcat(imgdata.lens.makernotes.Lens, LensInfo);",
          "9660:       }",
          "9661:     }",
          "9664:     {",
          "9665:       if (tag == 0x0002)",
          "9667:         if (get4() == 0x2000)",
          "9668:         {",
          "9669:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;",
          "9670:         }",
          "9671:         else if (!strncmp(model, \"NX mini\", 7))",
          "9672:         {",
          "9673:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;",
          "9674:         }",
          "9675:         else",
          "9676:         {",
          "9677:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "9678:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "9679:         }",
          "9680:       }",
          "9681:       else if (tag == 0x0003)",
          "9682:       {",
          "9683:         unique_id = imgdata.lens.makernotes.CamID = get4();",
          "9684:       }",
          "9685:       else if (tag == 0xa002)",
          "9686:       {",
          "9687:         stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "9688:       }",
          "9689:       else if (tag == 0xa003)",
          "9690:       {",
          "9691:         imgdata.lens.makernotes.LensID = get2();",
          "9692:         if (imgdata.lens.makernotes.LensID)",
          "9693:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;",
          "9694:       }",
          "9695:       else if (tag == 0xa005)",
          "9696:       {",
          "9697:         stmread(imgdata.lens.InternalLensSerial, len, ifp);",
          "9698:       }",
          "9699:       else if (tag == 0xa019)",
          "9700:       {",
          "9701:         imgdata.lens.makernotes.CurAp = getreal(type);",
          "9702:       }",
          "9703:       else if (tag == 0xa01a)",
          "9704:       {",
          "9705:         imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;",
          "9706:         if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)",
          "9707:           imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;",
          "9709:     }",
          "9711:     else if (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"Konica\", 6) || !strncasecmp(make, \"Minolta\", 7) ||",
          "9713:               (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) ||",
          "9714:                !strncasecmp(model, \"Lusso\", 5) || !strncasecmp(model, \"HV\", 2))))",
          "9715:     {",
          "9716:       ushort lid;",
          "9717:       if (tag == 0xb001) // Sony ModelID",
          "9719:         unique_id = get2();",
          "9720:         setSonyBodyFeatures(unique_id);",
          "9721:         if (table_buf_0x9050_present)",
          "9723:           process_Sony_0x9050(table_buf_0x9050, unique_id);",
          "9724:           free(table_buf_0x9050);",
          "9725:           table_buf_0x9050_present = 0;",
          "9726:         }",
          "9727:         if (table_buf_0x940c_present)",
          "9728:         {",
          "9729:           if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)",
          "9730:           {",
          "9731:             process_Sony_0x940c(table_buf_0x940c);",
          "9732:           }",
          "9733:           free(table_buf_0x940c);",
          "9734:           table_buf_0x940c_present = 0;",
          "9736:       }",
          "9738:       else if ((tag == 0x0010) && // CameraInfo",
          "9739:                strncasecmp(model, \"DSLR-A100\", 9) && strncasecmp(model, \"NEX-5C\", 6) && !strncasecmp(make, \"SONY\", 4) &&",
          "9740:                ((len == 368) ||  // a700",
          "9741:                 (len == 5478) || // a850, a900",
          "9742:                 (len == 5506) || // a200, a300, a350",
          "9743:                 (len == 6118) || // a230, a290, a330, a380, a390",
          "9747:                 (len == 15360)))",
          "9748:       {",
          "9749:         table_buf = (uchar *)malloc(len);",
          "9750:         fread(table_buf, len, 1, ifp);",
          "9751:         if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&",
          "9752:             memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))",
          "9753:         {",
          "9754:           switch (len)",
          "9756:           case 368:",
          "9757:           case 5478:",
          "9759:             if (table_buf[0] | table_buf[3])",
          "9760:               imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);",
          "9761:             if (table_buf[2] | table_buf[5])",
          "9762:               imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);",
          "9763:             if (table_buf[4])",
          "9764:               imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;",
          "9765:             if (table_buf[4])",
          "9766:               imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;",
          "9767:             parseSonyLensFeatures(table_buf[1], table_buf[6]);",
          "9768:             break;",
          "9769:           default:",
          "9771:             if (table_buf[1] | table_buf[2])",
          "9772:               imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);",
          "9773:             if (table_buf[3] | table_buf[4])",
          "9774:               imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);",
          "9775:             if (table_buf[5])",
          "9776:               imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;",
          "9777:             if (table_buf[6])",
          "9778:               imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;",
          "9779:             parseSonyLensFeatures(table_buf[0], table_buf[7]);",
          "9781:         }",
          "9782:         free(table_buf);",
          "9783:       }",
          "9785:       else if ((tag == 0x0020) && // WBInfoA100, needs 0xb028 processing",
          "9786:                !strncasecmp(model, \"DSLR-A100\", 9))",
          "9787:       {",
          "9788:         fseek(ifp, 0x49dc, SEEK_CUR);",
          "9789:         stmread(imgdata.shootinginfo.InternalBodySerial, 12, ifp);",
          "9790:       }",
          "9792:       else if (tag == 0x0104)",
          "9793:       {",
          "9794:         imgdata.other.FlashEC = getreal(type);",
          "9795:       }",
          "9797:       else if (tag == 0x0105) // Teleconverter",
          "9798:       {",
          "9799:         imgdata.lens.makernotes.TeleconverterID = get2();",
          "9800:       }",
          "9802:       else if (tag == 0x0114 && len < 256000) // CameraSettings",
          "9803:       {",
          "9804:         table_buf = (uchar *)malloc(len);",
          "9805:         fread(table_buf, len, 1, ifp);",
          "9806:         switch (len)",
          "9807:         {",
          "9808:         case 280:",
          "9809:         case 364:",
          "9810:         case 332:",
          "9812:           if (table_buf[2] | table_buf[3])",
          "9814:             lid = (((ushort)table_buf[2]) << 8) | ((ushort)table_buf[3]);",
          "9815:             imgdata.lens.makernotes.CurAp = powf64(2.0f, ((float)lid / 8.0f - 1.0f) / 2.0f);",
          "9817:           break;",
          "9818:         case 1536:",
          "9819:         case 2048:",
          "9821:           parseSonyLensType2(table_buf[1016], table_buf[1015]);",
          "9822:           if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)",
          "9824:             switch (table_buf[153])",
          "9825:             {",
          "9826:             case 16:",
          "9827:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;",
          "9829:             case 17:",
          "9830:               imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;",
          "9834:           break;",
          "9835:         }",
          "9836:         free(table_buf);",
          "9837:       }",
          "9839:       else if (tag == 0x9050 && len < 256000) // little endian",
          "9840:       {",
          "9841:         table_buf_0x9050 = (uchar *)malloc(len);",
          "9842:         table_buf_0x9050_present = 1;",
          "9843:         fread(table_buf_0x9050, len, 1, ifp);",
          "9845:         if (imgdata.lens.makernotes.CamID)",
          "9846:         {",
          "9847:           process_Sony_0x9050(table_buf_0x9050, imgdata.lens.makernotes.CamID);",
          "9848:           free(table_buf_0x9050);",
          "9849:           table_buf_0x9050_present = 0;",
          "9850:         }",
          "9851:       }",
          "9853:       else if (tag == 0x940c && len < 256000)",
          "9854:       {",
          "9855:         table_buf_0x940c = (uchar *)malloc(len);",
          "9856:         table_buf_0x940c_present = 1;",
          "9857:         fread(table_buf_0x940c, len, 1, ifp);",
          "9858:         if ((imgdata.lens.makernotes.CamID) && (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E))",
          "9859:         {",
          "9860:           process_Sony_0x940c(table_buf_0x940c);",
          "9861:           free(table_buf_0x940c);",
          "9862:           table_buf_0x940c_present = 0;",
          "9863:         }",
          "9864:       }",
          "9866:       else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))",
          "9867:       {",
          "9868:         imgdata.lens.makernotes.LensID = get4();",
          "9869:         if ((imgdata.lens.makernotes.LensID > 0x4900) && (imgdata.lens.makernotes.LensID <= 0x5900))",
          "9870:         {",
          "9871:           imgdata.lens.makernotes.AdapterID = 0x4900;",
          "9872:           imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;",
          "9873:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;",
          "9874:           strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");",
          "9875:         }",
          "9877:         else if ((imgdata.lens.makernotes.LensID > 0xEF00) && (imgdata.lens.makernotes.LensID < 0xFFFF) &&",
          "9878:                  (imgdata.lens.makernotes.LensID != 0xFF00))",
          "9879:         {",
          "9880:           imgdata.lens.makernotes.AdapterID = 0xEF00;",
          "9881:           imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;",
          "9882:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;",
          "9883:         }",
          "9884:         if (tag == 0x010c)",
          "9885:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;",
          "9886:       }",
          "9888:       else if (tag == 0xb02a && len < 256000) // Sony LensSpec",
          "9889:       {",
          "9890:         table_buf = (uchar *)malloc(len);",
          "9891:         fread(table_buf, len, 1, ifp);",
          "9892:         if (table_buf[1] | table_buf[2])",
          "9893:           imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);",
          "9894:         if (table_buf[3] | table_buf[4])",
          "9895:           imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);",
          "9896:         if (table_buf[5])",
          "9897:           imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;",
          "9898:         if (table_buf[6])",
          "9899:           imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;",
          "9900:         parseSonyLensFeatures(table_buf[0], table_buf[7]);",
          "9901:         free(table_buf);",
          "9902:       }",
          "9903:     }",
          "9905:     fseek(ifp, _pos, SEEK_SET);",
          "9906: #endif",
          "9908:     if (tag == 2 && strstr(make, \"NIKON\") && !iso_speed)",
          "9909:       iso_speed = (get2(), get2());",
          "9910:     if (tag == 37 && strstr(make, \"NIKON\") && (!iso_speed || iso_speed == 65535))",
          "9911:     {",
          "9912:       unsigned char cc;",
          "9913:       fread(&cc, 1, 1, ifp);",
          "9914:       iso_speed = int(100.0 * powf64(2.0f, float(cc) / 12.0 - 5.0));",
          "9915:     }",
          "9916:     if (tag == 4 && len > 26 && len < 35)",
          "9917:     {",
          "9918:       if ((i = (get4(), get2())) != 0x7fff && (!iso_speed || iso_speed == 65535))",
          "9919:         iso_speed = 50 * powf64(2.0, i / 32.0 - 4);",
          "9920: #ifdef LIBRAW_LIBRARY_BUILD",
          "9921:       get4();",
          "9922: #else",
          "9923:       if ((i = (get2(), get2())) != 0x7fff && !aperture)",
          "9924:         aperture = powf64(2.0, i / 64.0);",
          "9925: #endif",
          "9926:       if ((i = get2()) != 0xffff && !shutter)",
          "9927:         shutter = powf64(2.0, (short)i / -32.0);",
          "9928:       wbi = (get2(), get2());",
          "9929:       shot_order = (get2(), get2());",
          "9930:     }",
          "9931:     if ((tag == 4 || tag == 0x114) && !strncmp(make, \"KONICA\", 6))",
          "9932:     {",
          "9933:       fseek(ifp, tag == 4 ? 140 : 160, SEEK_CUR);",
          "9934:       switch (get2())",
          "9935:       {",
          "9936:       case 72:",
          "9937:         flip = 0;",
          "9938:         break;",
          "9939:       case 76:",
          "9940:         flip = 6;",
          "9941:         break;",
          "9942:       case 82:",
          "9943:         flip = 5;",
          "9944:         break;",
          "9945:       }",
          "9946:     }",
          "9947:     if (tag == 7 && type == 2 && len > 20)",
          "9948:       fgets(model2, 64, ifp);",
          "9949:     if (tag == 8 && type == 4)",
          "9950:       shot_order = get4();",
          "9951:     if (tag == 9 && !strncmp(make, \"Canon\", 5))",
          "9952:       fread(artist, 64, 1, ifp);",
          "9953:     if (tag == 0xc && len == 4)",
          "9954:       FORC3 cam_mul[(c << 1 | c >> 1) & 3] = getreal(type);",
          "9955:     if (tag == 0xd && type == 7 && get2() == 0xaaaa)",
          "9956:     {",
          "9957:       for (c = i = 2; (ushort)c != 0xbbbb && i < len; i++)",
          "9958:         c = c << 8 | fgetc(ifp);",
          "9959:       while ((i += 4) < len - 5)",
          "9960:         if (get4() == 257 && (i = len) && (c = (get4(), fgetc(ifp))) < 3)",
          "9961:           flip = \"065\"[c] - '0';",
          "9962:     }",
          "9964: #ifndef LIBRAW_LIBRARY_BUILD",
          "9965:     if (tag == 0x10 && type == 4)",
          "9966:       unique_id = get4();",
          "9967: #endif",
          "9969: #ifdef LIBRAW_LIBRARY_BUILD",
          "9970:     INT64 _pos2 = ftell(ifp);",
          "9971:     if (!strncasecmp(make, \"Olympus\", 7))",
          "9972:     {",
          "9973:       short nWB, tWB;",
          "9974:       if ((tag == 0x20300108) || (tag == 0x20310109))",
          "9975:         imgdata.makernotes.olympus.ColorSpace = get2();",
          "9977:       if ((tag == 0x20400102) && (len == 2) && (!strncasecmp(model, \"E-410\", 5) || !strncasecmp(model, \"E-510\", 5)))",
          "9978:       {",
          "9979:         int i;",
          "9980:         for (i = 0; i < 64; i++)",
          "9981:           imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = imgdata.color.WB_Coeffs[i][1] =",
          "9982:               imgdata.color.WB_Coeffs[i][3] = 0x100;",
          "9983:         for (i = 64; i < 256; i++)",
          "9984:           imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;",
          "9985:       }",
          "9986:       if ((tag >= 0x20400102) && (tag <= 0x2040010d))",
          "9987:       {",
          "9988:         ushort CT;",
          "9989:         nWB = tag - 0x20400102;",
          "9990:         switch (nWB)",
          "9991:         {",
          "9992:         case 0:",
          "9993:           CT = 3000;",
          "9994:           tWB = LIBRAW_WBI_Tungsten;",
          "9995:           break;",
          "9996:         case 1:",
          "9997:           CT = 3300;",
          "9998:           tWB = 0x100;",
          "9999:           break;",
          "10000:         case 2:",
          "10001:           CT = 3600;",
          "10002:           tWB = 0x100;",
          "10003:           break;",
          "10004:         case 3:",
          "10005:           CT = 3900;",
          "10006:           tWB = 0x100;",
          "10007:           break;",
          "10008:         case 4:",
          "10009:           CT = 4000;",
          "10010:           tWB = LIBRAW_WBI_FL_W;",
          "10011:           break;",
          "10012:         case 5:",
          "10013:           CT = 4300;",
          "10014:           tWB = 0x100;",
          "10015:           break;",
          "10016:         case 6:",
          "10017:           CT = 4500;",
          "10018:           tWB = LIBRAW_WBI_FL_D;",
          "10019:           break;",
          "10020:         case 7:",
          "10021:           CT = 4800;",
          "10022:           tWB = 0x100;",
          "10023:           break;",
          "10024:         case 8:",
          "10025:           CT = 5300;",
          "10026:           tWB = LIBRAW_WBI_FineWeather;",
          "10027:           break;",
          "10028:         case 9:",
          "10029:           CT = 6000;",
          "10030:           tWB = LIBRAW_WBI_Cloudy;",
          "10031:           break;",
          "10032:         case 10:",
          "10033:           CT = 6600;",
          "10034:           tWB = LIBRAW_WBI_FL_N;",
          "10035:           break;",
          "10036:         case 11:",
          "10037:           CT = 7500;",
          "10038:           tWB = LIBRAW_WBI_Shade;",
          "10039:           break;",
          "10040:         default:",
          "10041:           CT = 0;",
          "10042:           tWB = 0x100;",
          "10043:         }",
          "10044:         if (CT)",
          "10045:         {",
          "10046:           imgdata.color.WBCT_Coeffs[nWB][0] = CT;",
          "10047:           imgdata.color.WBCT_Coeffs[nWB][1] = get2();",
          "10048:           imgdata.color.WBCT_Coeffs[nWB][3] = get2();",
          "10049:           if (len == 4)",
          "10051:             imgdata.color.WBCT_Coeffs[nWB][2] = get2();",
          "10052:             imgdata.color.WBCT_Coeffs[nWB][4] = get2();",
          "10054:         }",
          "10055:         if (tWB != 0x100)",
          "10056:           FORC4 imgdata.color.WB_Coeffs[tWB][c] = imgdata.color.WBCT_Coeffs[nWB][c + 1];",
          "10057:       }",
          "10058:       if ((tag >= 0x20400113) && (tag <= 0x2040011e))",
          "10059:       {",
          "10060:         nWB = tag - 0x20400113;",
          "10061:         imgdata.color.WBCT_Coeffs[nWB][2] = imgdata.color.WBCT_Coeffs[nWB][4] = get2();",
          "10062:         switch (nWB)",
          "10063:         {",
          "10064:         case 0:",
          "10065:           tWB = LIBRAW_WBI_Tungsten;",
          "10066:           break;",
          "10067:         case 4:",
          "10068:           tWB = LIBRAW_WBI_FL_W;",
          "10069:           break;",
          "10070:         case 6:",
          "10071:           tWB = LIBRAW_WBI_FL_D;",
          "10072:           break;",
          "10073:         case 8:",
          "10074:           tWB = LIBRAW_WBI_FineWeather;",
          "10075:           break;",
          "10076:         case 9:",
          "10077:           tWB = LIBRAW_WBI_Cloudy;",
          "10078:           break;",
          "10079:         case 10:",
          "10080:           tWB = LIBRAW_WBI_FL_N;",
          "10081:           break;",
          "10082:         case 11:",
          "10083:           tWB = LIBRAW_WBI_Shade;",
          "10084:           break;",
          "10085:         default:",
          "10086:           tWB = 0x100;",
          "10087:         }",
          "10088:         if (tWB != 0x100)",
          "10089:           imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = imgdata.color.WBCT_Coeffs[nWB][2];",
          "10090:       }",
          "10092:       if (tag == 0x20400121)",
          "10093:       {",
          "10094:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();",
          "10095:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();",
          "10096:         if (len == 4)",
          "10097:         {",
          "10098:           imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = get2();",
          "10099:           imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();",
          "10100:         }",
          "10101:       }",
          "10102:       if (tag == 0x2040011f)",
          "10103:       {",
          "10104:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();",
          "10105:       }",
          "10106:       if (tag == 0x30000120)",
          "10107:       {",
          "10108:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();",
          "10109:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();",
          "10110:         if (len == 2)",
          "10111:         {",
          "10112:           for (int i = 0; i < 256; i++)",
          "10113:             imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;",
          "10114:         }",
          "10115:       }",
          "10116:       if (tag == 0x30000121)",
          "10117:       {",
          "10118:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();",
          "10119:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();",
          "10120:       }",
          "10121:       if (tag == 0x30000122)",
          "10122:       {",
          "10123:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = get2();",
          "10124:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = get2();",
          "10125:       }",
          "10126:       if (tag == 0x30000123)",
          "10127:       {",
          "10128:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();",
          "10129:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();",
          "10130:       }",
          "10131:       if (tag == 0x30000124)",
          "10132:       {",
          "10133:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Sunset][0] = get2();",
          "10134:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Sunset][2] = get2();",
          "10135:       }",
          "10136:       if (tag == 0x30000130)",
          "10137:       {",
          "10138:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();",
          "10139:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();",
          "10140:       }",
          "10141:       if (tag == 0x30000131)",
          "10142:       {",
          "10143:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();",
          "10144:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();",
          "10145:       }",
          "10146:       if (tag == 0x30000132)",
          "10147:       {",
          "10148:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();",
          "10149:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();",
          "10150:       }",
          "10151:       if (tag == 0x30000133)",
          "10152:       {",
          "10153:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();",
          "10154:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();",
          "10157:       if ((tag == 0x20400805) && (len == 2))",
          "10159:         imgdata.makernotes.olympus.OlympusSensorCalibration[0] = getreal(type);",
          "10160:         imgdata.makernotes.olympus.OlympusSensorCalibration[1] = getreal(type);",
          "10161:         FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.olympus.OlympusSensorCalibration[0];",
          "10163:       if (tag == 0x20200401)",
          "10164:       {",
          "10165:         imgdata.other.FlashEC = getreal(type);",
          "10168:     fseek(ifp, _pos2, SEEK_SET);",
          "10171:     if (tag == 0x11 && is_raw && !strncmp(make, \"NIKON\", 5))",
          "10172:     {",
          "10173:       fseek(ifp, get4() + base, SEEK_SET);",
          "10174:       parse_tiff_ifd(base);",
          "10175:     }",
          "10176:     if (tag == 0x14 && type == 7)",
          "10177:     {",
          "10178:       if (len == 2560)",
          "10179:       {",
          "10180:         fseek(ifp, 1248, SEEK_CUR);",
          "10181:         goto get2_256;",
          "10182:       }",
          "10183:       fread(buf, 1, 10, ifp);",
          "10184:       if (!strncmp(buf, \"NRW \", 4))",
          "10185:       {",
          "10186:         fseek(ifp, strcmp(buf + 4, \"0100\") ? 46 : 1546, SEEK_CUR);",
          "10187:         cam_mul[0] = get4() << 2;",
          "10188:         cam_mul[1] = get4() + get4();",
          "10189:         cam_mul[2] = get4() << 2;",
          "10193:       fread(model, 64, 1, ifp);",
          "10194:     if (strstr(make, \"PENTAX\"))",
          "10195:     {",
          "10196:       if (tag == 0x1b)",
          "10197:         tag = 0x1018;",
          "10198:       if (tag == 0x1c)",
          "10199:         tag = 0x1017;",
          "10201:     if (tag == 0x1d)",
          "10202:     {",
          "10208:           if ((strbuflen(model) == 3) && (!strcmp(model, \"D50\")))",
          "",
          "---------------",
          "--- Hunk 80 ---",
          "[Context before]",
          "9378:           }",
          "9379:         }",
          "9380: #endif",
          "9382: #ifdef LIBRAW_LIBRARY_BUILD",
          "9383:       }",
          "9384:       if (!imgdata.shootinginfo.BodySerial[0])",
          "9385:         sprintf(imgdata.shootinginfo.BodySerial, \"%d\", serial);",
          "9386: #endif",
          "9387:     }",
          "9391:       FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get4();",
          "9392:     }",
          "9393: #ifndef LIBRAW_LIBRARY_BUILD",
          "9394:     if (tag == 0x3d && type == 3 && len == 4)",
          "9396: #endif",
          "9398:       data_offset = get4();",
          "9400:       raw_height = get2() * 2;",
          "9402:       filters = 0x61616161;",
          "9403:     }",
          "9407:       thumb_offset = ftell(ifp);",
          "9408:       thumb_length = len;",
          "9409:     }",
          "",
          "[Removed Lines]",
          "9381:  serial = serial*10 + (isdigit(c) ? c - '0' : c % 10);",
          "9388:     if (tag == 0x29 && type == 1) {  // Canon PowerShot G9",
          "9389:       c = wbi < 18 ? \"012347800000005896\"[wbi]-'0' : 0;",
          "9390:       fseek (ifp, 8 + c*32, SEEK_CUR);",
          "9395:       FORC4 cblack[c ^ c >> 1] = get2() >> (14-tiff_bps);",
          "9397:     if (tag == 0x81 && type == 4) {",
          "9399:       fseek (ifp, data_offset + 41, SEEK_SET);",
          "9401:       raw_width  = get2();",
          "9404:     if ((tag == 0x81  && type == 7) ||",
          "9405:  (tag == 0x100 && type == 7) ||",
          "9406:  (tag == 0x280 && type == 1)) {",
          "",
          "[Added Lines]",
          "10218:         serial = serial * 10 + (isdigit(c) ? c - '0' : c % 10);",
          "10225:     if (tag == 0x29 && type == 1)",
          "10226:     { // Canon PowerShot G9",
          "10227:       c = wbi < 18 ? \"012347800000005896\"[wbi] - '0' : 0;",
          "10228:       fseek(ifp, 8 + c * 32, SEEK_CUR);",
          "10233:       FORC4 cblack[c ^ c >> 1] = get2() >> (14 - tiff_bps);",
          "10235:     if (tag == 0x81 && type == 4)",
          "10236:     {",
          "10238:       fseek(ifp, data_offset + 41, SEEK_SET);",
          "10240:       raw_width = get2();",
          "10243:     if ((tag == 0x81 && type == 7) || (tag == 0x100 && type == 7) || (tag == 0x280 && type == 1))",
          "10244:     {",
          "",
          "---------------",
          "--- Hunk 81 ---",
          "[Context before]",
          "9413:       thumb_length = get4();",
          "9414:     if (tag == 0x8c || tag == 0x96)",
          "9415:       meta_offset = ftell(ifp);",
          "9438:       order = 0x4949;",
          "9440:       FORC3 cam_mul[c] = get4();",
          "9441:     }",
          "9444:       FORC3 cam_mul[c] = get2();",
          "9445:     }",
          "9450:         ci = xlat[0][serial & 0xff];",
          "9451:         cj = xlat[1][NikonKey];",
          "9452:         ck = 0x60;",
          "9454:           buf97[i] ^= (cj += ci * ck++);",
          "9458:       }",
          "9459: #ifdef LIBRAW_LIBRARY_BUILD",
          "9460:       if ((NikonLensDataVersion > 200) && lenNikonLensData)",
          "",
          "[Removed Lines]",
          "9416:     if (tag == 0x97) {",
          "9417:       for (i=0; i < 4; i++)",
          "9418:  ver97 = ver97 * 10 + fgetc(ifp)-'0';",
          "9419:       switch (ver97) {",
          "9420:  case 100:",
          "9421:    fseek (ifp, 68, SEEK_CUR);",
          "9422:    FORC4 cam_mul[(c >> 1) | ((c & 1) << 1)] = get2();",
          "9423:    break;",
          "9424:  case 102:",
          "9425:    fseek (ifp, 6, SEEK_CUR);",
          "9426:    FORC4 cam_mul[c ^ (c >> 1)] = get2();",
          "9427:    break;",
          "9428:  case 103:",
          "9429:    fseek (ifp, 16, SEEK_CUR);",
          "9430:    FORC4 cam_mul[c] = get2();",
          "9431:       }",
          "9432:       if (ver97 >= 200) {",
          "9433:  if (ver97 != 205) fseek (ifp, 280, SEEK_CUR);",
          "9434:  fread (buf97, 324, 1, ifp);",
          "9435:       }",
          "9436:     }",
          "9437:     if (tag == 0xa1 && type == 7) {",
          "9439:       fseek (ifp, 140, SEEK_CUR);",
          "9442:     if (tag == 0xa4 && type == 3) {",
          "9443:       fseek (ifp, wbi*48, SEEK_CUR);",
          "9447:     if (tag == 0xa7) { // shutter count",
          "9448:       NikonKey = fgetc(ifp)^fgetc(ifp)^fgetc(ifp)^fgetc(ifp);",
          "9449:         if ( (unsigned) (ver97-200) < 17) {",
          "9453:         for (i=0; i < 324; i++)",
          "9455:         i = \"66666>666;6A;:;55\"[ver97-200] - '0';",
          "9456:         FORC4 cam_mul[c ^ (c >> 1) ^ (i & 1)] =",
          "9457:           sget2 (buf97 + (i & -2) + c*2);",
          "",
          "[Added Lines]",
          "10254:     if (tag == 0x97)",
          "10255:     {",
          "10256:       for (i = 0; i < 4; i++)",
          "10257:         ver97 = ver97 * 10 + fgetc(ifp) - '0';",
          "10258:       switch (ver97)",
          "10259:       {",
          "10260:       case 100:",
          "10261:         fseek(ifp, 68, SEEK_CUR);",
          "10262:         FORC4 cam_mul[(c >> 1) | ((c & 1) << 1)] = get2();",
          "10263:         break;",
          "10264:       case 102:",
          "10265:         fseek(ifp, 6, SEEK_CUR);",
          "10266:         FORC4 cam_mul[c ^ (c >> 1)] = get2();",
          "10267:         break;",
          "10268:       case 103:",
          "10269:         fseek(ifp, 16, SEEK_CUR);",
          "10270:         FORC4 cam_mul[c] = get2();",
          "10271:       }",
          "10272:       if (ver97 >= 200)",
          "10273:       {",
          "10274:         if (ver97 != 205)",
          "10275:           fseek(ifp, 280, SEEK_CUR);",
          "10276:         fread(buf97, 324, 1, ifp);",
          "10277:       }",
          "10278:     }",
          "10279:     if (tag == 0xa1 && type == 7)",
          "10280:     {",
          "10282:       fseek(ifp, 140, SEEK_CUR);",
          "10285:     if (tag == 0xa4 && type == 3)",
          "10286:     {",
          "10287:       fseek(ifp, wbi * 48, SEEK_CUR);",
          "10291:     if (tag == 0xa7)",
          "10292:     { // shutter count",
          "10293:       NikonKey = fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp);",
          "10294:       if ((unsigned)(ver97 - 200) < 17)",
          "10295:       {",
          "10299:         for (i = 0; i < 324; i++)",
          "10301:         i = \"66666>666;6A;:;55\"[ver97 - 200] - '0';",
          "10302:         FORC4 cam_mul[c ^ (c >> 1) ^ (i & 1)] = sget2(buf97 + (i & -2) + c * 2);",
          "",
          "---------------",
          "--- Hunk 82 ---",
          "[Context before]",
          "9475:         lenNikonLensData = 0;",
          "9476:         free(table_buf);",
          "9477:       }",
          "9483: #endif",
          "9484:     }",
          "9490:     if (tag == 0x200 && len == 3)",
          "9492:     if (tag == 0x200 && len == 4)",
          "9493:       FORC4 cblack[c ^ c >> 1] = get2();",
          "9494:     if (tag == 0x201 && len == 4)",
          "9496:     if (tag == 0x220 && type == 7)",
          "9497:       meta_offset = ftell(ifp);",
          "9498:     if (tag == 0x401 && type == 4 && len == 4)",
          "9499:       FORC4 cblack[c ^ c >> 1] = get4();",
          "9500: #ifdef LIBRAW_LIBRARY_BUILD",
          "9510: #endif",
          "9512: #ifdef LIBRAW_LIBRARY_BUILD",
          "9514: #endif",
          "9515:       order = 0x4949;",
          "9518: #ifdef LIBRAW_LIBRARY_BUILD",
          "9521: #endif",
          "9527:       }",
          "9528:     }",
          "9531:       cam_mul[0] = get2() * 508 * 1.078 / 0x10000;",
          "9532:       cam_mul[2] = get2() * 382 * 1.173 / 0x10000;",
          "9533:     }",
          "9535:       if (len == 614)",
          "9537:       else if (len == 734 || len == 1502)",
          "9540:       goto get2_256;",
          "9541:     }",
          "9542:     if ((tag == 0x1011 && len == 9) || tag == 0x20400200)",
          "9554: #else",
          "9556: #endif",
          "9558:     if ((tag == 0x1012 || tag == 0x20400600) && len == 4)",
          "9559:       FORC4 cblack[c ^ c >> 1] = get2();",
          "9560:     if (tag == 0x1017 || tag == 0x20400100)",
          "9561:       cam_mul[0] = get2() / 256.0;",
          "9562:     if (tag == 0x1018 || tag == 0x20400100)",
          "9563:       cam_mul[2] = get2() / 256.0;",
          "9566:       order = 0x4d4d;",
          "9567:       cam_mul[0] = get2() / 256.0;",
          "9568:       cam_mul[2] = get2() / 256.0;",
          "9569:     }",
          "9570:     if ((tag | 0x70) == 0x2070 && (type == 4 || type == 13))",
          "9572: #ifdef LIBRAW_LIBRARY_BUILD",
          "9574:     if (tag == 0x2010)",
          "9592: #endif",
          "9595:     if (tag == 0x2040)",
          "9600:     }",
          "9602:       i = len == 582 ? 50 : len == 653 ? 68 : len == 5120 ? 142 : 126;",
          "9604:       FORC4 cam_mul[c ^ (c >> 1)] = get2();",
          "9609:       }",
          "9610:     }",
          "9617: #ifdef LIBRAW_LIBRARY_BUILD",
          "9654:       }",
          "9656:       {",
          "9662:       }",
          "9663:     if (tag == 0x4021 && get4() && get4())",
          "9664:       FORC4 cam_mul[c] = 1024;",
          "9667:   }",
          "9668: quit:",
          "9669:   order = sorder;",
          "",
          "[Removed Lines]",
          "9478:       if (ver97 == 601)  // Coolpix A",
          "9479:      {",
          "9480:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "9481:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "9482:      }",
          "9486:     if(tag == 0xb001 && type == 3) // Sony ModelID",
          "9487:       {",
          "9488:         unique_id = get2();",
          "9489:       }",
          "9491:       shot_order = (get4(),get4());",
          "9495:          FORC4 cam_mul[c ^ (c >> 1)] = get2();",
          "9502:     if (tag == 0x03d && strstr(make,\"NIKON\") && len == 4)",
          "9503:       {",
          "9504:         FORC4 cblack[c ^ c >> 1] = get2();",
          "9505:         i = cblack[3];",
          "9506:         FORC3 if(i>cblack[c]) i = cblack[c];",
          "9507:         FORC4 cblack[c]-=i;",
          "9508:         black += i;",
          "9509:       }",
          "9513:  int loopc = 0;",
          "9516:       fseek (ifp, 22, SEEK_CUR);",
          "9517:       for (offset=22; offset+22 < len; offset += 22+i) {",
          "9519:  if(loopc++>1024)",
          "9520:   throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "9522:  tag = get4();",
          "9523:  fseek (ifp, 14, SEEK_CUR);",
          "9524:  i = get4()-4;",
          "9525:  if (tag == 0x76a43207) flip = get2();",
          "9526:  else fseek (ifp, i, SEEK_CUR);",
          "9529:     if (tag == 0xe80 && len == 256 && type == 7) {",
          "9530:       fseek (ifp, 48, SEEK_CUR);",
          "9534:     if (tag == 0xf00 && type == 7) {",
          "9536:  fseek (ifp, 176, SEEK_CUR);",
          "9538:  fseek (ifp, 148, SEEK_CUR);",
          "9539:       else goto next;",
          "9543:           for (i=0; i < 3; i++)",
          "9544:    {",
          "9545: #ifdef LIBRAW_LIBRARY_BUILD",
          "9546:            if (!imgdata.makernotes.olympus.ColorSpace)",
          "9547:     {",
          "9548:             FORC3 cmatrix[i][c] = ((short) get2()) / 256.0;",
          "9549:     }",
          "9550:            else",
          "9551:     {",
          "9552:             FORC3 imgdata.color.ccm[i][c] = ((short) get2()) / 256.0;",
          "9553:     }",
          "9555:             FORC3 cmatrix[i][c] = ((short) get2()) / 256.0;",
          "9557:           }",
          "9564:     if (tag == 0x2011 && len == 2) {",
          "9565: get2_256:",
          "9571:       fseek (ifp, get4()+base, SEEK_SET);",
          "9575:       {",
          "9576:         INT64 _pos3 = ftell(ifp);",
          "9577:         parse_makernote(base, 0x2010);",
          "9578:         fseek(ifp,_pos3,SEEK_SET);",
          "9579:       }",
          "9581:     if (",
          "9582:          ((tag == 0x2020) || (tag == 0x3000) || (tag == 0x2030) || (tag == 0x2031)) &&",
          "9583:          ((type == 7) || (type == 13)) &&",
          "9584:          !strncasecmp(make,\"Olympus\",7)",
          "9585:        )",
          "9586:       {",
          "9587:         INT64 _pos3 = ftell(ifp);",
          "9588:         parse_makernote(base, tag);",
          "9589:         fseek(ifp,_pos3,SEEK_SET);",
          "9590:       }",
          "9593:     if ((tag == 0x2020) && ((type == 7) || (type == 13)) && !strncmp(buf,\"OLYMP\",5))",
          "9594:       parse_thumb_note (base, 257, 258);",
          "9596:       parse_makernote (base, 0x2040);",
          "9597:     if (tag == 0xb028) {",
          "9598:       fseek (ifp, get4()+base, SEEK_SET);",
          "9599:       parse_thumb_note (base, 136, 137);",
          "9601:     if (tag == 0x4001 && len > 500 && len < 100000) {",
          "9603:       fseek (ifp, i, SEEK_CUR);",
          "9605:       for (i+=18; i <= len; i+=10) {",
          "9606:        get2();",
          "9607:        FORC4 sraw_mul[c ^ (c >> 1)] = get2();",
          "9608:        if (sraw_mul[1] == 1170) break;",
          "9611:     if(!strncasecmp(make,\"Samsung\",7))",
          "9612:       {",
          "9613:         if (tag == 0xa020) // get the full Samsung encryption key",
          "9614:             for (i=0; i<11; i++) SamsungKey[i] = get4();",
          "9615:         if (tag == 0xa021) // get and decode Samsung cam_mul array",
          "9616:             FORC4 cam_mul[c ^ (c >> 1)] = get4() - SamsungKey[c];",
          "9618:         if (tag == 0xa023)",
          "9619:           {",
          "9620:             imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] = get4() - SamsungKey[8];",
          "9621:             imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = get4() - SamsungKey[9];",
          "9622:             imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = get4() - SamsungKey[10];",
          "9623:             imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][2] = get4() - SamsungKey[0];",
          "9624:             if (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1]>>1))",
          "9625:               {",
          "9626:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] >> 4;",
          "9627:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] >> 4;",
          "9628:               }",
          "9629:           }",
          "9630:         if (tag == 0xa024)",
          "9631:           {",
          "9632:             FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][c ^ (c >> 1)] = get4() - SamsungKey[c+1];",
          "9633:             if (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1]>>1))",
          "9634:               {",
          "9635:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] >> 4;",
          "9636:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] >> 4;",
          "9637:               }",
          "9638:           }",
          "9639:         if (tag == 0xa025)",
          "9640:            imgdata.color.linear_max[0]=",
          "9641:              imgdata.color.linear_max[1]=",
          "9642:              imgdata.color.linear_max[2]=",
          "9643:              imgdata.color.linear_max[3]= get4() - SamsungKey[0];",
          "9644:         if (tag == 0xa030 && len == 9)",
          "9645:             for (i=0; i < 3; i++)",
          "9646:               FORC3 imgdata.color.ccm[i][c] = (float)((short)((get4() + SamsungKey[i*3+c])))/256.0;",
          "9647: #endif",
          "9648:         if (tag == 0xa031 && len == 9) // get and decode Samsung color matrix",
          "9649:             for (i=0; i < 3; i++)",
          "9650:               FORC3 cmatrix[i][c] = (float)((short)((get4() + SamsungKey[i*3+c])))/256.0;",
          "9652:         if (tag == 0xa028)",
          "9653:           FORC4 cblack[c ^ (c >> 1)] = get4() - SamsungKey[c];",
          "9655:     else",
          "9658:         if (tag == 0xa021)",
          "9659:           FORC4 cam_mul[c ^ (c >> 1)] = get4();",
          "9660:         if (tag == 0xa028)",
          "9661:           FORC4 cam_mul[c ^ (c >> 1)] -= get4();",
          "9665: next:",
          "9666:     fseek (ifp, save, SEEK_SET);",
          "",
          "[Added Lines]",
          "10323:       if (ver97 == 601) // Coolpix A",
          "10324:       {",
          "10325:         imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "10326:         imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "10327:       }",
          "10331:     if (tag == 0xb001 && type == 3) // Sony ModelID",
          "10332:     {",
          "10333:       unique_id = get2();",
          "10334:     }",
          "10336:       shot_order = (get4(), get4());",
          "10340:       FORC4 cam_mul[c ^ (c >> 1)] = get2();",
          "10347:     if (tag == 0x03d && strstr(make, \"NIKON\") && len == 4)",
          "10348:     {",
          "10349:       FORC4 cblack[c ^ c >> 1] = get2();",
          "10350:       i = cblack[3];",
          "10351:       FORC3 if (i > cblack[c]) i = cblack[c];",
          "10352:       FORC4 cblack[c] -= i;",
          "10353:       black += i;",
          "10354:     }",
          "10356:     if (tag == 0xe01)",
          "10359:       int loopc = 0;",
          "10362:       fseek(ifp, 22, SEEK_CUR);",
          "10363:       for (offset = 22; offset + 22 < len; offset += 22 + i)",
          "10364:       {",
          "10366:         if (loopc++ > 1024)",
          "10367:           throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "10369:         tag = get4();",
          "10370:         fseek(ifp, 14, SEEK_CUR);",
          "10371:         i = get4() - 4;",
          "10372:         if (tag == 0x76a43207)",
          "10373:           flip = get2();",
          "10374:         else",
          "10375:           fseek(ifp, i, SEEK_CUR);",
          "10378:     if (tag == 0xe80 && len == 256 && type == 7)",
          "10379:     {",
          "10380:       fseek(ifp, 48, SEEK_CUR);",
          "10384:     if (tag == 0xf00 && type == 7)",
          "10385:     {",
          "10387:         fseek(ifp, 176, SEEK_CUR);",
          "10389:         fseek(ifp, 148, SEEK_CUR);",
          "10390:       else",
          "10391:         goto next;",
          "10395:       for (i = 0; i < 3; i++)",
          "10396:       {",
          "10397: #ifdef LIBRAW_LIBRARY_BUILD",
          "10398:         if (!imgdata.makernotes.olympus.ColorSpace)",
          "10399:         {",
          "10400:           FORC3 cmatrix[i][c] = ((short)get2()) / 256.0;",
          "10401:         }",
          "10402:         else",
          "10403:         {",
          "10404:           FORC3 imgdata.color.ccm[i][c] = ((short)get2()) / 256.0;",
          "10405:         }",
          "10407:         FORC3 cmatrix[i][c] = ((short)get2()) / 256.0;",
          "10409:       }",
          "10416:     if (tag == 0x2011 && len == 2)",
          "10417:     {",
          "10418:     get2_256:",
          "10424:       fseek(ifp, get4() + base, SEEK_SET);",
          "10428:     {",
          "10429:       INT64 _pos3 = ftell(ifp);",
          "10430:       parse_makernote(base, 0x2010);",
          "10431:       fseek(ifp, _pos3, SEEK_SET);",
          "10432:     }",
          "10434:     if (((tag == 0x2020) || (tag == 0x3000) || (tag == 0x2030) || (tag == 0x2031)) && ((type == 7) || (type == 13)) &&",
          "10435:         !strncasecmp(make, \"Olympus\", 7))",
          "10436:     {",
          "10437:       INT64 _pos3 = ftell(ifp);",
          "10438:       parse_makernote(base, tag);",
          "10439:       fseek(ifp, _pos3, SEEK_SET);",
          "10440:     }",
          "10443:     if ((tag == 0x2020) && ((type == 7) || (type == 13)) && !strncmp(buf, \"OLYMP\", 5))",
          "10444:       parse_thumb_note(base, 257, 258);",
          "10446:       parse_makernote(base, 0x2040);",
          "10447:     if (tag == 0xb028)",
          "10448:     {",
          "10449:       fseek(ifp, get4() + base, SEEK_SET);",
          "10450:       parse_thumb_note(base, 136, 137);",
          "10452:     if (tag == 0x4001 && len > 500 && len < 100000)",
          "10453:     {",
          "10455:       fseek(ifp, i, SEEK_CUR);",
          "10457:       for (i += 18; i <= len; i += 10)",
          "10458:       {",
          "10459:         get2();",
          "10460:         FORC4 sraw_mul[c ^ (c >> 1)] = get2();",
          "10461:         if (sraw_mul[1] == 1170)",
          "10462:           break;",
          "10465:     if (!strncasecmp(make, \"Samsung\", 7))",
          "10466:     {",
          "10467:       if (tag == 0xa020) // get the full Samsung encryption key",
          "10468:         for (i = 0; i < 11; i++)",
          "10469:           SamsungKey[i] = get4();",
          "10470:       if (tag == 0xa021) // get and decode Samsung cam_mul array",
          "10471:         FORC4 cam_mul[c ^ (c >> 1)] = get4() - SamsungKey[c];",
          "10473:       if (tag == 0xa023)",
          "10474:       {",
          "10475:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] = get4() - SamsungKey[8];",
          "10476:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = get4() - SamsungKey[9];",
          "10477:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = get4() - SamsungKey[10];",
          "10478:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][2] = get4() - SamsungKey[0];",
          "10479:         if (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] >> 1))",
          "10480:         {",
          "10481:           imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] >> 4;",
          "10482:           imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] >> 4;",
          "10483:         }",
          "10485:       if (tag == 0xa024)",
          "10487:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][c ^ (c >> 1)] = get4() - SamsungKey[c + 1];",
          "10488:         if (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] >> 1))",
          "10489:         {",
          "10490:           imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] >> 4;",
          "10491:           imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] >> 4;",
          "10492:         }",
          "10494:       if (tag == 0xa025)",
          "10495:         imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =",
          "10496:             imgdata.color.linear_max[3] = get4() - SamsungKey[0];",
          "10497:       if (tag == 0xa030 && len == 9)",
          "10498:         for (i = 0; i < 3; i++)",
          "10499:           FORC3 imgdata.color.ccm[i][c] = (float)((short)((get4() + SamsungKey[i * 3 + c]))) / 256.0;",
          "10500: #endif",
          "10501:       if (tag == 0xa031 && len == 9) // get and decode Samsung color matrix",
          "10502:         for (i = 0; i < 3; i++)",
          "10503:           FORC3 cmatrix[i][c] = (float)((short)((get4() + SamsungKey[i * 3 + c]))) / 256.0;",
          "10505:       if (tag == 0xa028)",
          "10506:         FORC4 cblack[c ^ (c >> 1)] = get4() - SamsungKey[c];",
          "10507:     }",
          "10508:     else",
          "10509:     {",
          "10511:       if (tag == 0xa021)",
          "10512:         FORC4 cam_mul[c ^ (c >> 1)] = get4();",
          "10513:       if (tag == 0xa028)",
          "10514:         FORC4 cam_mul[c ^ (c >> 1)] -= get4();",
          "10515:     }",
          "10518:   next:",
          "10519:     fseek(ifp, save, SEEK_SET);",
          "",
          "---------------",
          "--- Hunk 83 ---",
          "[Context before]",
          "9673:    Since the TIFF DateTime string has no timezone information,",
          "9674:    assume that the camera's clock was set to Universal Time.",
          "9677: {",
          "9678:   struct tm t;",
          "9679:   char str[20];",
          "",
          "[Removed Lines]",
          "9676: void CLASS get_timestamp (int reversed)",
          "",
          "[Added Lines]",
          "10529: void CLASS get_timestamp(int reversed)",
          "",
          "---------------",
          "--- Hunk 84 ---",
          "[Context before]",
          "9682:   str[19] = 0;",
          "9683:   if (reversed)",
          "9685:   else",
          "9690:     return;",
          "9691:   t.tm_year -= 1900;",
          "9692:   t.tm_mon -= 1;",
          "",
          "[Removed Lines]",
          "9684:     for (i=19; i--; ) str[i] = fgetc(ifp);",
          "9686:     fread (str, 19, 1, ifp);",
          "9687:   memset (&t, 0, sizeof t);",
          "9688:   if (sscanf (str, \"%d:%d:%d %d:%d:%d\", &t.tm_year, &t.tm_mon,",
          "9689:  &t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec) != 6)",
          "",
          "[Added Lines]",
          "10537:     for (i = 19; i--;)",
          "10538:       str[i] = fgetc(ifp);",
          "10540:     fread(str, 19, 1, ifp);",
          "10541:   memset(&t, 0, sizeof t);",
          "10542:   if (sscanf(str, \"%d:%d:%d %d:%d:%d\", &t.tm_year, &t.tm_mon, &t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec) != 6)",
          "",
          "---------------",
          "--- Hunk 85 ---",
          "[Context before]",
          "9695:     timestamp = mktime(&t);",
          "9696: }",
          "9699: {",
          "9700:   unsigned kodak, entries, tag, type, len, save, c;",
          "9704:   entries = get2();",
          "9706: #ifdef LIBRAW_LIBRARY_BUILD",
          "9707:   INT64 fsize = ifp->size();",
          "9708: #endif",
          "9712: #ifdef LIBRAW_LIBRARY_BUILD",
          "9713:     INT64 savepos = ftell(ifp);",
          "9720: #endif",
          "9722: #ifdef LIBRAW_LIBRARY_BUILD",
          "9724:       imgdata.lens.FocalLengthIn35mmFormat = get2();",
          "9725:       break;",
          "9727:       stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "9728:       break;",
          "9730:       imgdata.lens.MinFocal = getreal(type);",
          "9731:       imgdata.lens.MaxFocal = getreal(type);",
          "9732:       imgdata.lens.MaxAp4MinFocal = getreal(type);",
          "9733:       imgdata.lens.MaxAp4MaxFocal = getreal(type);",
          "9734:       break;",
          "9736:       stmread(imgdata.lens.LensSerial, len, ifp);",
          "9737:       break;",
          "9739:       imgdata.lens.dng.MinFocal = getreal(type);",
          "9740:       imgdata.lens.dng.MaxFocal = getreal(type);",
          "9741:       imgdata.lens.dng.MaxAp4MinFocal = getreal(type);",
          "9742:       imgdata.lens.dng.MaxAp4MaxFocal = getreal(type);",
          "9743:       break;",
          "9745:       stmread(imgdata.lens.LensMake, len, ifp);",
          "9746:       break;",
          "9748:       stmread(imgdata.lens.Lens, len, ifp);",
          "9749:       if (!strncmp(imgdata.lens.Lens, \"----\", 4))",
          "9750:         imgdata.lens.Lens[0] = 0;",
          "",
          "[Removed Lines]",
          "9698: void CLASS parse_exif (int base)",
          "9701:   double expo,ape;",
          "9703:   kodak = !strncmp(make,\"EASTMAN\",7) && tiff_nifds < 3;",
          "9705:   if(!strncmp(make,\"Hasselblad\",10) && (tiff_nifds > 3) && (entries > 512)) return;",
          "9709:   while (entries--) {",
          "9710:     tiff_get (base, &tag, &type, &len, &save);",
          "9714:     if(len > 8 && savepos + len > fsize*2) continue;",
          "9715:     if(callbacks.exif_cb)",
          "9716:       {",
          "9717:         callbacks.exif_cb(callbacks.exifparser_data,tag,type,len,order,ifp);",
          "9718:         fseek(ifp,savepos,SEEK_SET);",
          "9719:       }",
          "9721:     switch (tag) {",
          "9723:     case 0xa405:  // FocalLengthIn35mmFormat",
          "9726:     case 0xa431:  // BodySerialNumber",
          "9729:     case 0xa432:  // LensInfo, 42034dec, Lens Specification per EXIF standard",
          "9735:     case 0xa435:  // LensSerialNumber",
          "9738:     case 0xc630:  // DNG LensInfo, Lens Specification per EXIF standard",
          "9744:     case 0xa433:  // LensMake",
          "9747:     case 0xa434:  // LensModel",
          "",
          "[Added Lines]",
          "10551: void CLASS parse_exif(int base)",
          "10554:   double expo, ape;",
          "10556:   kodak = !strncmp(make, \"EASTMAN\", 7) && tiff_nifds < 3;",
          "10558:   if (!strncmp(make, \"Hasselblad\", 10) && (tiff_nifds > 3) && (entries > 512))",
          "10559:     return;",
          "10563:   while (entries--)",
          "10564:   {",
          "10565:     tiff_get(base, &tag, &type, &len, &save);",
          "10569:     if (len > 8 && savepos + len > fsize * 2)",
          "10570:       continue;",
          "10571:     if (callbacks.exif_cb)",
          "10572:     {",
          "10573:       callbacks.exif_cb(callbacks.exifparser_data, tag, type, len, order, ifp);",
          "10574:       fseek(ifp, savepos, SEEK_SET);",
          "10575:     }",
          "10577:     switch (tag)",
          "10578:     {",
          "10580:     case 0xa405: // FocalLengthIn35mmFormat",
          "10583:     case 0xa431: // BodySerialNumber",
          "10586:     case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard",
          "10592:     case 0xa435: // LensSerialNumber",
          "10595:     case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard",
          "10601:     case 0xa433: // LensMake",
          "10604:     case 0xa434: // LensModel",
          "",
          "---------------",
          "--- Hunk 86 ---",
          "[Context before]",
          "9753:       imgdata.lens.EXIF_MaxAp = powf64(2.0f, (getreal(type) / 2.0f));",
          "9754:       break;",
          "9755: #endif",
          "9823:   }",
          "9824: }",
          "",
          "[Removed Lines]",
          "9756:       case 33434:  tiff_ifd[tiff_nifds-1].t_shutter =",
          "9757:      shutter = getreal(type);  break;",
          "9758:       case 33437:  aperture = getreal(type);  break;  // 0x829d FNumber",
          "9759:       case 34855:  iso_speed = get2();   break;",
          "9760:       case 34866:",
          "9761:         if (iso_speed == 0xffff && (!strncasecmp(make, \"SONY\",4) || !strncasecmp(make, \"CANON\",5)))",
          "9762:           iso_speed = getreal(type);",
          "9763:         break;",
          "9764:       case 36867:",
          "9765:       case 36868:  get_timestamp(0);   break;",
          "9766:       case 37377:  if ((expo = -getreal(type)) < 128 && shutter == 0.)",
          "9767:        tiff_ifd[tiff_nifds-1].t_shutter =",
          "9768:    shutter = powf64(2.0, expo);",
          "9769:   break;",
          "9770:       case 37378:                                       // 0x9202 ApertureValue",
          "9771:         if ((fabs(ape = getreal(type))<256.0) && (!aperture))",
          "9772:           aperture = powf64(2.0, ape/2);",
          "9773:         break;",
          "9774:       case 37385:  flash_used = getreal(type);          break;",
          "9775:       case 37386:  focal_len = getreal(type);  break;",
          "9776:       case 37500:                            // tag 0x927c",
          "9777: #ifdef LIBRAW_LIBRARY_BUILD",
          "9778:        if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\",6))) ||",
          "9779:            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_OV5647\",9))) ||",
          "9780:            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_imx219\",9)))) {",
          "9781:          char mn_text[512];",
          "9782:          char* pos;",
          "9783:          char ccms[512];",
          "9784:          ushort l;",
          "9785:          float num;",
          "9787:          fgets(mn_text, len, ifp);",
          "9788:          pos = strstr(mn_text, \"gain_r=\");",
          "9789:          if (pos) cam_mul[0] = atof(pos+7);",
          "9790:          pos = strstr(mn_text, \"gain_b=\");",
          "9791:          if (pos) cam_mul[2] = atof(pos+7);",
          "9792:          if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f)) cam_mul[1] = cam_mul[3] = 1.0f;",
          "9793:          else cam_mul[0] = cam_mul[2] = 0.0f;",
          "9795:          pos = strstr(mn_text, \"ccm=\") + 4;",
          "9796:          l = strstr(pos, \" \") - pos;",
          "9797:          memcpy (ccms, pos, l);",
          "9798:          ccms[l] = '\\0';",
          "9800:          pos = strtok (ccms, \",\");",
          "9801:          for (l=0; l<4; l++) {",
          "9802:            num = 0.0;",
          "9803:            for (c=0; c<3; c++) {",
          "9804:              imgdata.color.ccm[l][c] = (float)atoi(pos);",
          "9805:              num += imgdata.color.ccm[l][c];",
          "9806:              pos = strtok (NULL, \",\");",
          "9807:            }",
          "9808:            if (num > 0.01) FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;",
          "9809:          }",
          "9810:        }",
          "9811:        else",
          "9812: #endif",
          "9813:         parse_makernote (base, 0);",
          "9814:        break;",
          "9815:       case 40962:  if (kodak) raw_width  = get4(); break;",
          "9816:       case 40963:  if (kodak) raw_height = get4(); break;",
          "9817:       case 41730:",
          "9818:  if (get4() == 0x20002)",
          "9819:    for (exif_cfa=c=0; c < 8; c+=2)",
          "9820:      exif_cfa |= fgetc(ifp) * 0x01010101 << c;",
          "9821:     }",
          "9822:     fseek (ifp, save, SEEK_SET);",
          "",
          "[Added Lines]",
          "10613:     case 33434:",
          "10614:       tiff_ifd[tiff_nifds - 1].t_shutter = shutter = getreal(type);",
          "10615:       break;",
          "10616:     case 33437:",
          "10617:       aperture = getreal(type);",
          "10618:       break; // 0x829d FNumber",
          "10619:     case 34855:",
          "10620:       iso_speed = get2();",
          "10621:       break;",
          "10622:     case 34866:",
          "10623:       if (iso_speed == 0xffff && (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"CANON\", 5)))",
          "10624:         iso_speed = getreal(type);",
          "10625:       break;",
          "10626:     case 36867:",
          "10627:     case 36868:",
          "10628:       get_timestamp(0);",
          "10629:       break;",
          "10630:     case 37377:",
          "10631:       if ((expo = -getreal(type)) < 128 && shutter == 0.)",
          "10632:         tiff_ifd[tiff_nifds - 1].t_shutter = shutter = powf64(2.0, expo);",
          "10633:       break;",
          "10634:     case 37378: // 0x9202 ApertureValue",
          "10635:       if ((fabs(ape = getreal(type)) < 256.0) && (!aperture))",
          "10636:         aperture = powf64(2.0, ape / 2);",
          "10637:       break;",
          "10638:     case 37385:",
          "10639:       flash_used = getreal(type);",
          "10640:       break;",
          "10641:     case 37386:",
          "10642:       focal_len = getreal(type);",
          "10643:       break;",
          "10644:     case 37500: // tag 0x927c",
          "10645: #ifdef LIBRAW_LIBRARY_BUILD",
          "10646:       if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\", 6))) ||",
          "10647:           ((!strncmp(make, \"RaspberryPi\", 11)) && (!strncmp(model, \"RP_OV5647\", 9))) ||",
          "10648:           ((!strncmp(make, \"RaspberryPi\", 11)) && (!strncmp(model, \"RP_imx219\", 9))))",
          "10649:       {",
          "10650:         char mn_text[512];",
          "10651:         char *pos;",
          "10652:         char ccms[512];",
          "10653:         ushort l;",
          "10654:         float num;",
          "10656:         fgets(mn_text, len, ifp);",
          "10657:         pos = strstr(mn_text, \"gain_r=\");",
          "10658:         if (pos)",
          "10659:           cam_mul[0] = atof(pos + 7);",
          "10660:         pos = strstr(mn_text, \"gain_b=\");",
          "10661:         if (pos)",
          "10662:           cam_mul[2] = atof(pos + 7);",
          "10663:         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))",
          "10664:           cam_mul[1] = cam_mul[3] = 1.0f;",
          "10665:         else",
          "10666:           cam_mul[0] = cam_mul[2] = 0.0f;",
          "10668:         pos = strstr(mn_text, \"ccm=\") + 4;",
          "10669:         l = strstr(pos, \" \") - pos;",
          "10670:         memcpy(ccms, pos, l);",
          "10671:         ccms[l] = '\\0';",
          "10673:         pos = strtok(ccms, \",\");",
          "10674:         for (l = 0; l < 4; l++)",
          "10675:         {",
          "10676:           num = 0.0;",
          "10677:           for (c = 0; c < 3; c++)",
          "10678:           {",
          "10679:             imgdata.color.ccm[l][c] = (float)atoi(pos);",
          "10680:             num += imgdata.color.ccm[l][c];",
          "10681:             pos = strtok(NULL, \",\");",
          "10682:           }",
          "10683:           if (num > 0.01)",
          "10684:             FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;",
          "10685:         }",
          "10686:       }",
          "10687:       else",
          "10688: #endif",
          "10689:         parse_makernote(base, 0);",
          "10690:       break;",
          "10691:     case 40962:",
          "10692:       if (kodak)",
          "10693:         raw_width = get4();",
          "10694:       break;",
          "10695:     case 40963:",
          "10696:       if (kodak)",
          "10697:         raw_height = get4();",
          "10698:       break;",
          "10699:     case 41730:",
          "10700:       if (get4() == 0x20002)",
          "10701:         for (exif_cfa = c = 0; c < 8; c += 2)",
          "10702:           exif_cfa |= fgetc(ifp) * 0x01010101 << c;",
          "10703:     }",
          "10704:     fseek(ifp, save, SEEK_SET);",
          "",
          "---------------",
          "--- Hunk 87 ---",
          "[Context before]",
          "9832:   entries = get2();",
          "9833:   if (entries > 200)",
          "9835:   if (entries > 0)",
          "9836:     imgdata.other.parsed_gps.gpsparsed = 1;",
          "9838:     tiff_get(base, &tag, &type, &len, &save);",
          "9844:     case 2:",
          "9845:       if (len == 3)",
          "9846:         FORC(3) imgdata.other.parsed_gps.latitude[c] = getreal(type);",
          "",
          "[Removed Lines]",
          "9834:    return;",
          "9837:   while (entries--) {",
          "9839:     if(len > 1024) continue; // no GPS tags are 1k or larger",
          "9840:     switch (tag) {",
          "9841:     case 1:  imgdata.other.parsed_gps.latref = getc(ifp); break;",
          "9842:     case 3:  imgdata.other.parsed_gps.longref = getc(ifp); break;",
          "9843:     case 5:  imgdata.other.parsed_gps.altref = getc(ifp); break;",
          "",
          "[Added Lines]",
          "10716:     return;",
          "10719:   while (entries--)",
          "10720:   {",
          "10722:     if (len > 1024)",
          "10723:       continue; // no GPS tags are 1k or larger",
          "10724:     switch (tag)",
          "10725:     {",
          "10726:     case 1:",
          "10727:       imgdata.other.parsed_gps.latref = getc(ifp);",
          "10728:       break;",
          "10729:     case 3:",
          "10730:       imgdata.other.parsed_gps.longref = getc(ifp);",
          "10731:       break;",
          "10732:     case 5:",
          "10733:       imgdata.other.parsed_gps.altref = getc(ifp);",
          "10734:       break;",
          "",
          "---------------",
          "--- Hunk 88 ---",
          "[Context before]",
          "9856:     case 6:",
          "9857:       imgdata.other.parsed_gps.altitude = getreal(type);",
          "9858:       break;",
          "9860:     }",
          "9861:     fseek(ifp, save, SEEK_SET);",
          "9862:   }",
          "9863: }",
          "9864: #endif",
          "9867: {",
          "9868:   unsigned entries, tag, type, len, save, c;",
          "9870:   entries = get2();",
          "9883:     }",
          "9885:   }",
          "9886: }",
          "9889: {",
          "9894:   int i, j, k;",
          "9900: }",
          "9903: {",
          "9904:   char data[40];",
          "9912:   float romm_cam[3][3];",
          "9917:     get4();",
          "9919:     skip = get4();",
          "9920:     from = ftell(ifp);",
          "9923: #ifdef LIBRAW_LIBRARY_BUILD",
          "9934:     }",
          "9942:     }",
          "9943: #endif",
          "9946:       thumb_offset = from;",
          "9947:       thumb_length = skip;",
          "9948:     }",
          "9950:       profile_offset = from;",
          "9951:       profile_length = skip;",
          "9952:     }",
          "9979:       flip = i - flip;",
          "9980:     }",
          "9984:     }",
          "9986:       load_flags = get4();",
          "9989:   }",
          "9990:   if (planes)",
          "9993: }",
          "9996: {",
          "9997:   int i;",
          "10003: }",
          "10005: #ifdef LIBRAW_LIBRARY_BUILD",
          "10008: {",
          "10017: }",
          "10021: {",
          "10022:   unsigned entries, tag, type, len, save;",
          "10027:   entries = get2();",
          "10029:   INT64 fsize = ifp->size();",
          "10032:     INT64 savepos = ftell(ifp);",
          "10044:       wbi = -2;",
          "10045:     }",
          "10091:       FORC3 cam_mul[c] = get4();",
          "10095:   }",
          "10096: }",
          "10097: #else",
          "10099: {",
          "10100:   unsigned entries, tag, type, len, save;",
          "10105:   entries = get2();",
          "10113:       wbi = -2;",
          "10114:     }",
          "10116:     if (tag == 2120 + wbi && wbi >= 0)",
          "10118:     if (tag == 2130 + wbi)",
          "10119:       FORC3 mul[c] = getreal(type);",
          "10120:     if (tag == 2140 + wbi && wbi >= 0)",
          "10130:       FORC3 cam_mul[c] = get4();",
          "10134:   }",
          "10135: }",
          "10136: #endif",
          "10138: {",
          "10141:   char *cbuf, *cp;",
          "10143:   double fm[3][4], cc[4][4], cm[4][3], cam_xyz[4][3], num;",
          "10147:   struct jhead jh;",
          "10148:   int pana_raw = 0;",
          "10149: #ifndef LIBRAW_LIBRARY_BUILD",
          "",
          "[Removed Lines]",
          "9859:     case 9: imgdata.other.parsed_gps.gpsstatus = getc(ifp); break;",
          "9866: void CLASS parse_gps (int base)",
          "9871:   while (entries--) {",
          "9872:     tiff_get (base, &tag, &type, &len, &save);",
          "9873:     if(len > 1024) continue; // no GPS tags are 1k or larger",
          "9874:     switch (tag) {",
          "9875:       case 1: case 3: case 5:",
          "9876:  gpsdata[29+tag/2] = getc(ifp);   break;",
          "9877:       case 2: case 4: case 7:",
          "9878:  FORC(6) gpsdata[tag/3*6+c] = get4();  break;",
          "9879:       case 6:",
          "9880:  FORC(2) gpsdata[18+c] = get4();   break;",
          "9881:       case 18: case 29:",
          "9882:  fgets ((char *) (gpsdata+14+tag/3), MIN(len,12), ifp);",
          "9884:     fseek (ifp, save, SEEK_SET);",
          "9888: void CLASS romm_coeff (float romm_cam[3][3])",
          "9891:   { {  2.034193, -0.727420, -0.306766 },",
          "9892:     { -0.228811,  1.231729, -0.002922 },",
          "9893:     { -0.008565, -0.153273,  1.161839 } };",
          "9896:   for (i=0; i < 3; i++)",
          "9897:     for (j=0; j < 3; j++)",
          "9898:       for (cmatrix[i][j] = k=0; k < 3; k++)",
          "9899:  cmatrix[i][j] += rgb_romm[i][k] * romm_cam[k][j];",
          "9902: void CLASS parse_mos (int offset)",
          "9905:   int skip, from, i, c, neut[4], planes=0, frot=0;",
          "9906:   static const char *mod[] =",
          "9907:   { \"\",\"DCB2\",\"Volare\",\"Cantare\",\"CMost\",\"Valeo 6\",\"Valeo 11\",\"Valeo 22\",",
          "9908:     \"Valeo 11p\",\"Valeo 17\",\"\",\"Aptus 17\",\"Aptus 22\",\"Aptus 75\",\"Aptus 65\",",
          "9909:     \"Aptus 54S\",\"Aptus 65S\",\"Aptus 75S\",\"AFi 5\",\"AFi 6\",\"AFi 7\",",
          "9910:     \"AFi-II 7\",\"Aptus-II 7\",\"\",\"Aptus-II 6\",\"\",\"\",\"Aptus-II 10\",\"Aptus-II 5\",",
          "9911:     \"\",\"\",\"\",\"\",\"Aptus-II 10R\",\"Aptus-II 8\",\"\",\"Aptus-II 12\",\"\",\"AFi-II 12\" };",
          "9914:   fseek (ifp, offset, SEEK_SET);",
          "9915:   while (1) {",
          "9916:     if (get4() != 0x504b5453) break;",
          "9918:     fread (data, 1, 40, ifp);",
          "9924:     if (!strcmp(data,\"CameraObj_camera_type\")) {",
          "9925:  stmread(imgdata.lens.makernotes.body, skip, ifp);",
          "9926:     }",
          "9927:     if (!strcmp(data,\"back_serial_number\")) {",
          "9928:        char buffer [sizeof(imgdata.shootinginfo.BodySerial)];",
          "9929:        char *words[4];",
          "9930:        int nwords;",
          "9931:        stmread(buffer, skip, ifp);",
          "9932:        nwords = getwords(buffer, words, 4,sizeof(imgdata.shootinginfo.BodySerial));",
          "9933:        strcpy (imgdata.shootinginfo.BodySerial, words[0]);",
          "9935:     if (!strcmp(data,\"CaptProf_serial_number\")) {",
          "9936:        char buffer [sizeof(imgdata.shootinginfo.InternalBodySerial)];",
          "9937:        char *words[4];",
          "9938:        int nwords;",
          "9939:        stmread(buffer, skip, ifp);",
          "9940:        nwords = getwords(buffer, words, 4,sizeof(imgdata.shootinginfo.InternalBodySerial));",
          "9941:        strcpy (imgdata.shootinginfo.InternalBodySerial, words[0]);",
          "9945:     if (!strcmp(data,\"JPEG_preview_data\")) {",
          "9949:     if (!strcmp(data,\"icc_camera_profile\")) {",
          "9953:     if (!strcmp(data,\"ShootObj_back_type\")) {",
          "9954:       fscanf (ifp, \"%d\", &i);",
          "9955:       if ((unsigned) i < sizeof mod / sizeof (*mod))",
          "9956:  strcpy (model, mod[i]);",
          "9957:     }",
          "9958:     if (!strcmp(data,\"icc_camera_to_tone_matrix\")) {",
          "9959:       for (i=0; i < 9; i++)",
          "9960:  ((float *)romm_cam)[i] = int_to_float(get4());",
          "9961:       romm_coeff (romm_cam);",
          "9962:     }",
          "9963:     if (!strcmp(data,\"CaptProf_color_matrix\")) {",
          "9964:       for (i=0; i < 9; i++)",
          "9965:  fscanf (ifp, \"%f\", (float *)romm_cam + i);",
          "9966:       romm_coeff (romm_cam);",
          "9967:     }",
          "9968:     if (!strcmp(data,\"CaptProf_number_of_planes\"))",
          "9969:       fscanf (ifp, \"%d\", &planes);",
          "9970:     if (!strcmp(data,\"CaptProf_raw_data_rotation\"))",
          "9971:       fscanf (ifp, \"%d\", &flip);",
          "9972:     if (!strcmp(data,\"CaptProf_mosaic_pattern\"))",
          "9973:       FORC4 {",
          "9974:  fscanf (ifp, \"%d\", &i);",
          "9975:  if (i == 1) frot = c ^ (c >> 1);",
          "9976:       }",
          "9977:     if (!strcmp(data,\"ImgProf_rotation_angle\")) {",
          "9978:       fscanf (ifp, \"%d\", &i);",
          "9981:     if (!strcmp(data,\"NeutObj_neutrals\") && !cam_mul[0]) {",
          "9982:       FORC4 fscanf (ifp, \"%d\", neut+c);",
          "9983:       FORC3 cam_mul[c] = (float) neut[0] / neut[c+1];",
          "9985:     if (!strcmp(data,\"Rows_data\"))",
          "9987:     parse_mos (from);",
          "9988:     fseek (ifp, skip+from, SEEK_SET);",
          "9991:     filters = (planes == 1) * 0x01010101 *",
          "9992:  (uchar) \"\\x94\\x61\\x16\\x49\"[(flip/90 + frot) & 3];",
          "9995: void CLASS linear_table (unsigned len)",
          "9998:   if (len > 0x10000) len = 0x10000;",
          "9999:   read_shorts (curve, len);",
          "10000:   for (i=len; i < 0x10000; i++)",
          "10001:     curve[i] = curve[i-1];",
          "10002:   maximum = curve[len<0x1000?0xfff:len-1];",
          "10007: void CLASS Kodak_WB_0x08tags (int wb, unsigned type)",
          "10009:  float mul[3]={1,1,1}, num, mul2;",
          "10010:  int c;",
          "10011:  FORC3 mul[c] = (num=getreal(type))==0 ? 1 : num;",
          "10012:  imgdata.color.WB_Coeffs[wb][1] = imgdata.color.WB_Coeffs[wb][3] = mul[1];",
          "10013:  mul2 = mul[1] * mul[1];",
          "10014:  imgdata.color.WB_Coeffs[wb][0] = mul2 / mul[0];",
          "10015:  imgdata.color.WB_Coeffs[wb][2] = mul2 / mul[2];",
          "10016:  return;",
          "10020: void CLASS parse_kodak_ifd (int base)",
          "10023:   int i, c, wbi=-2;",
          "10024:   float mul[3]={1,1,1}, num;",
          "10025:   static const int wbtag[] = { 64037,64040,64039,64041,-1,-1,64042 };",
          "10028:   if (entries > 1024) return;",
          "10030:   while (entries--) {",
          "10031:     tiff_get (base, &tag, &type, &len, &save);",
          "10033:     if(len > 8 && len + savepos > 2*fsize) continue;",
          "10034:     if(callbacks.exif_cb)",
          "10035:       {",
          "10036:         callbacks.exif_cb(callbacks.exifparser_data,tag | 0x20000,type,len,order,ifp);",
          "10037:         fseek(ifp,savepos,SEEK_SET);",
          "10038:       }",
          "10039:     if (tag == 1011) imgdata.other.FlashEC = getreal(type);",
          "10040:     if (tag == 1020) wbi = getint(type);",
          "10042:       fseek (ifp, 40, SEEK_CUR);",
          "10043:       FORC3 cam_mul[c] = 2048.0 / fMAX(1.0f,get2());",
          "10047:     if (tag == 0x0848) Kodak_WB_0x08tags(LIBRAW_WBI_Daylight, type);",
          "10048:     if (tag == 0x0849) Kodak_WB_0x08tags(LIBRAW_WBI_Tungsten, type);",
          "10049:     if (tag == 0x084a) Kodak_WB_0x08tags(LIBRAW_WBI_Fluorescent, type);",
          "10050:     if (tag == 0x084b) Kodak_WB_0x08tags(LIBRAW_WBI_Flash, type);",
          "10051:     if (tag == 0x0e93) imgdata.color.linear_max[0] =",
          "10052:                          imgdata.color.linear_max[1] =",
          "10053:                          imgdata.color.linear_max[2] =",
          "10054:                          imgdata.color.linear_max[3] = get2();",
          "10055:         if (tag == 0x09ce)",
          "10056:   stmread(imgdata.shootinginfo.InternalBodySerial,len, ifp);",
          "10057:         if (tag == 0xfa00)",
          "10058:   stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "10059:  if (tag == 0xfa27)",
          "10060:    {",
          "10061:                 FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get4();",
          "10062:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];",
          "10063:    }",
          "10064:  if (tag == 0xfa28)",
          "10065:    {",
          "10066:                 FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get4();",
          "10067:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];",
          "10068:    }",
          "10069:  if (tag == 0xfa29)",
          "10070:    {",
          "10071:                 FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get4();",
          "10072:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];",
          "10073:    }",
          "10074:  if (tag == 0xfa2a)",
          "10075:    {",
          "10076:             FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get4();",
          "10077:             imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];",
          "10078:    }",
          "10080:     if (tag == 2120 + wbi ||",
          "10082:       {",
          "10083:         FORC3 mul[c] = (num=getreal(type))==0 ? 1 : num;",
          "10085:       }",
          "10086:     if (tag == 2317) linear_table (len);",
          "10087:     if (tag == 0x903) iso_speed = getreal(type);",
          "10089:     if (tag == 64013) wbi = fgetc(ifp);",
          "10090:     if ((unsigned) wbi < 7 && tag == wbtag[wbi])",
          "10092:     if (tag == 64019) width = getint(type);",
          "10093:     if (tag == 64020) height = (getint(type)+1) & -2;",
          "10094:     fseek (ifp, save, SEEK_SET);",
          "10098: void CLASS parse_kodak_ifd (int base)",
          "10101:   int i, c, wbi=-2, wbtemp=6500;",
          "10102:   float mul[3]={1,1,1}, num;",
          "10103:   static const int wbtag[] = { 64037,64040,64039,64041,-1,-1,64042 };",
          "10106:   if (entries > 1024) return;",
          "10107:   while (entries--) {",
          "10108:     tiff_get (base, &tag, &type, &len, &save);",
          "10109:     if (tag == 1020) wbi = getint(type);",
          "10111:       fseek (ifp, 40, SEEK_CUR);",
          "10112:       FORC3 cam_mul[c] = 2048.0 / fMAX(1.0,get2());",
          "10115:     if (tag == 2118) wbtemp = getint(type);",
          "10117:       FORC3 cam_mul[c] = 2048.0 / fMAX(1.0,getreal(type));",
          "10121:       FORC3 {",
          "10122:  for (num=i=0; i < 4; i++)",
          "10123:    num += getreal(type) * pow (wbtemp/100.0, i);",
          "10124:  cam_mul[c] = 2048 / fMAX(1.0,(num * mul[c]));",
          "10125:       }",
          "10126:     if (tag == 2317) linear_table (len);",
          "10127:     if (tag == 6020) iso_speed = getint(type);",
          "10128:     if (tag == 64013) wbi = fgetc(ifp);",
          "10129:     if ((unsigned) wbi < 7 && tag == wbtag[wbi])",
          "10131:     if (tag == 64019) width = getint(type);",
          "10132:     if (tag == 64020) height = (getint(type)+1) & -2;",
          "10133:     fseek (ifp, save, SEEK_SET);",
          "10137: int CLASS parse_tiff_ifd (int base)",
          "10139:   unsigned entries, tag, type, len, plen=16, save;",
          "10140:   int ifd, use_cm=0, cfa, i, j, c, ima_len=0;",
          "10142:   uchar cfa_pat[16], cfa_pc[] = { 0,1,2,3 }, tab[256];",
          "10144:   double ab[]={ 1,1,1,1 }, asn[] = { 0,0,0,0 }, xyz[] = { 1,1,1 };",
          "10145:   unsigned sony_curve[] = { 0,0,0,0,0,4095 };",
          "10146:   unsigned *buf, sony_offset=0, sony_length=0, sony_key=0;",
          "",
          "[Added Lines]",
          "10750:     case 9:",
          "10751:       imgdata.other.parsed_gps.gpsstatus = getc(ifp);",
          "10752:       break;",
          "10759: void CLASS parse_gps(int base)",
          "10764:   while (entries--)",
          "10765:   {",
          "10766:     tiff_get(base, &tag, &type, &len, &save);",
          "10767:     if (len > 1024)",
          "10768:       continue; // no GPS tags are 1k or larger",
          "10769:     switch (tag)",
          "10770:     {",
          "10771:     case 1:",
          "10772:     case 3:",
          "10773:     case 5:",
          "10774:       gpsdata[29 + tag / 2] = getc(ifp);",
          "10775:       break;",
          "10776:     case 2:",
          "10777:     case 4:",
          "10778:     case 7:",
          "10779:       FORC(6) gpsdata[tag / 3 * 6 + c] = get4();",
          "10780:       break;",
          "10781:     case 6:",
          "10782:       FORC(2) gpsdata[18 + c] = get4();",
          "10783:       break;",
          "10784:     case 18:",
          "10785:     case 29:",
          "10786:       fgets((char *)(gpsdata + 14 + tag / 3), MIN(len, 12), ifp);",
          "10788:     fseek(ifp, save, SEEK_SET);",
          "10792: void CLASS romm_coeff(float romm_cam[3][3])",
          "10795:       {{2.034193, -0.727420, -0.306766}, {-0.228811, 1.231729, -0.002922}, {-0.008565, -0.153273, 1.161839}};",
          "10798:   for (i = 0; i < 3; i++)",
          "10799:     for (j = 0; j < 3; j++)",
          "10800:       for (cmatrix[i][j] = k = 0; k < 3; k++)",
          "10801:         cmatrix[i][j] += rgb_romm[i][k] * romm_cam[k][j];",
          "10804: void CLASS parse_mos(int offset)",
          "10807:   int skip, from, i, c, neut[4], planes = 0, frot = 0;",
          "10808:   static const char *mod[] = {\"\",",
          "10809:                               \"DCB2\",",
          "10810:                               \"Volare\",",
          "10811:                               \"Cantare\",",
          "10812:                               \"CMost\",",
          "10813:                               \"Valeo 6\",",
          "10814:                               \"Valeo 11\",",
          "10815:                               \"Valeo 22\",",
          "10816:                               \"Valeo 11p\",",
          "10817:                               \"Valeo 17\",",
          "10818:                               \"\",",
          "10819:                               \"Aptus 17\",",
          "10820:                               \"Aptus 22\",",
          "10821:                               \"Aptus 75\",",
          "10822:                               \"Aptus 65\",",
          "10823:                               \"Aptus 54S\",",
          "10824:                               \"Aptus 65S\",",
          "10825:                               \"Aptus 75S\",",
          "10826:                               \"AFi 5\",",
          "10827:                               \"AFi 6\",",
          "10828:                               \"AFi 7\",",
          "10829:                               \"AFi-II 7\",",
          "10830:                               \"Aptus-II 7\",",
          "10831:                               \"\",",
          "10832:                               \"Aptus-II 6\",",
          "10833:                               \"\",",
          "10834:                               \"\",",
          "10835:                               \"Aptus-II 10\",",
          "10836:                               \"Aptus-II 5\",",
          "10837:                               \"\",",
          "10838:                               \"\",",
          "10839:                               \"\",",
          "10840:                               \"\",",
          "10841:                               \"Aptus-II 10R\",",
          "10842:                               \"Aptus-II 8\",",
          "10843:                               \"\",",
          "10844:                               \"Aptus-II 12\",",
          "10845:                               \"\",",
          "10846:                               \"AFi-II 12\"};",
          "10849:   fseek(ifp, offset, SEEK_SET);",
          "10850:   while (1)",
          "10851:   {",
          "10852:     if (get4() != 0x504b5453)",
          "10853:       break;",
          "10855:     fread(data, 1, 40, ifp);",
          "10861:     if (!strcmp(data, \"CameraObj_camera_type\"))",
          "10862:     {",
          "10863:       stmread(imgdata.lens.makernotes.body, skip, ifp);",
          "10865:     if (!strcmp(data, \"back_serial_number\"))",
          "10866:     {",
          "10867:       char buffer[sizeof(imgdata.shootinginfo.BodySerial)];",
          "10868:       char *words[4];",
          "10869:       int nwords;",
          "10870:       stmread(buffer, skip, ifp);",
          "10871:       nwords = getwords(buffer, words, 4, sizeof(imgdata.shootinginfo.BodySerial));",
          "10872:       strcpy(imgdata.shootinginfo.BodySerial, words[0]);",
          "10873:     }",
          "10874:     if (!strcmp(data, \"CaptProf_serial_number\"))",
          "10875:     {",
          "10876:       char buffer[sizeof(imgdata.shootinginfo.InternalBodySerial)];",
          "10877:       char *words[4];",
          "10878:       int nwords;",
          "10879:       stmread(buffer, skip, ifp);",
          "10880:       nwords = getwords(buffer, words, 4, sizeof(imgdata.shootinginfo.InternalBodySerial));",
          "10881:       strcpy(imgdata.shootinginfo.InternalBodySerial, words[0]);",
          "10885:     if (!strcmp(data, \"JPEG_preview_data\"))",
          "10886:     {",
          "10890:     if (!strcmp(data, \"icc_camera_profile\"))",
          "10891:     {",
          "10895:     if (!strcmp(data, \"ShootObj_back_type\"))",
          "10896:     {",
          "10897:       fscanf(ifp, \"%d\", &i);",
          "10898:       if ((unsigned)i < sizeof mod / sizeof(*mod))",
          "10899:         strcpy(model, mod[i]);",
          "10900:     }",
          "10901:     if (!strcmp(data, \"icc_camera_to_tone_matrix\"))",
          "10902:     {",
          "10903:       for (i = 0; i < 9; i++)",
          "10904:         ((float *)romm_cam)[i] = int_to_float(get4());",
          "10905:       romm_coeff(romm_cam);",
          "10906:     }",
          "10907:     if (!strcmp(data, \"CaptProf_color_matrix\"))",
          "10908:     {",
          "10909:       for (i = 0; i < 9; i++)",
          "10910:         fscanf(ifp, \"%f\", (float *)romm_cam + i);",
          "10911:       romm_coeff(romm_cam);",
          "10912:     }",
          "10913:     if (!strcmp(data, \"CaptProf_number_of_planes\"))",
          "10914:       fscanf(ifp, \"%d\", &planes);",
          "10915:     if (!strcmp(data, \"CaptProf_raw_data_rotation\"))",
          "10916:       fscanf(ifp, \"%d\", &flip);",
          "10917:     if (!strcmp(data, \"CaptProf_mosaic_pattern\"))",
          "10918:       FORC4",
          "10919:       {",
          "10920:         fscanf(ifp, \"%d\", &i);",
          "10921:         if (i == 1)",
          "10922:           frot = c ^ (c >> 1);",
          "10923:       }",
          "10924:     if (!strcmp(data, \"ImgProf_rotation_angle\"))",
          "10925:     {",
          "10926:       fscanf(ifp, \"%d\", &i);",
          "10929:     if (!strcmp(data, \"NeutObj_neutrals\") && !cam_mul[0])",
          "10930:     {",
          "10931:       FORC4 fscanf(ifp, \"%d\", neut + c);",
          "10932:       FORC3 cam_mul[c] = (float)neut[0] / neut[c + 1];",
          "10934:     if (!strcmp(data, \"Rows_data\"))",
          "10936:     parse_mos(from);",
          "10937:     fseek(ifp, skip + from, SEEK_SET);",
          "10940:     filters = (planes == 1) * 0x01010101 * (uchar) \"\\x94\\x61\\x16\\x49\"[(flip / 90 + frot) & 3];",
          "10943: void CLASS linear_table(unsigned len)",
          "10946:   if (len > 0x10000)",
          "10947:     len = 0x10000;",
          "10948:   read_shorts(curve, len);",
          "10949:   for (i = len; i < 0x10000; i++)",
          "10950:     curve[i] = curve[i - 1];",
          "10951:   maximum = curve[len < 0x1000 ? 0xfff : len - 1];",
          "10956: void CLASS Kodak_WB_0x08tags(int wb, unsigned type)",
          "10958:   float mul[3] = {1, 1, 1}, num, mul2;",
          "10959:   int c;",
          "10960:   FORC3 mul[c] = (num = getreal(type)) == 0 ? 1 : num;",
          "10961:   imgdata.color.WB_Coeffs[wb][1] = imgdata.color.WB_Coeffs[wb][3] = mul[1];",
          "10962:   mul2 = mul[1] * mul[1];",
          "10963:   imgdata.color.WB_Coeffs[wb][0] = mul2 / mul[0];",
          "10964:   imgdata.color.WB_Coeffs[wb][2] = mul2 / mul[2];",
          "10965:   return;",
          "10969: void CLASS parse_kodak_ifd(int base)",
          "10972:   int i, c, wbi = -2;",
          "10973:   float mul[3] = {1, 1, 1}, num;",
          "10974:   static const int wbtag[] = {64037, 64040, 64039, 64041, -1, -1, 64042};",
          "10977:   if (entries > 1024)",
          "10978:     return;",
          "10980:   while (entries--)",
          "10981:   {",
          "10982:     tiff_get(base, &tag, &type, &len, &save);",
          "10984:     if (len > 8 && len + savepos > 2 * fsize)",
          "10985:       continue;",
          "10986:     if (callbacks.exif_cb)",
          "10987:     {",
          "10988:       callbacks.exif_cb(callbacks.exifparser_data, tag | 0x20000, type, len, order, ifp);",
          "10989:       fseek(ifp, savepos, SEEK_SET);",
          "10990:     }",
          "10991:     if (tag == 1011)",
          "10992:       imgdata.other.FlashEC = getreal(type);",
          "10993:     if (tag == 1020)",
          "10994:       wbi = getint(type);",
          "10995:     if (tag == 1021 && len == 72)",
          "10997:       fseek(ifp, 40, SEEK_CUR);",
          "10998:       FORC3 cam_mul[c] = 2048.0 / fMAX(1.0f, get2());",
          "11002:     if (tag == 0x0848)",
          "11003:       Kodak_WB_0x08tags(LIBRAW_WBI_Daylight, type);",
          "11004:     if (tag == 0x0849)",
          "11005:       Kodak_WB_0x08tags(LIBRAW_WBI_Tungsten, type);",
          "11006:     if (tag == 0x084a)",
          "11007:       Kodak_WB_0x08tags(LIBRAW_WBI_Fluorescent, type);",
          "11008:     if (tag == 0x084b)",
          "11009:       Kodak_WB_0x08tags(LIBRAW_WBI_Flash, type);",
          "11010:     if (tag == 0x0e93)",
          "11011:       imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =",
          "11012:           imgdata.color.linear_max[3] = get2();",
          "11013:     if (tag == 0x09ce)",
          "11014:       stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);",
          "11015:     if (tag == 0xfa00)",
          "11016:       stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "11017:     if (tag == 0xfa27)",
          "11018:     {",
          "11019:       FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get4();",
          "11020:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];",
          "11021:     }",
          "11022:     if (tag == 0xfa28)",
          "11023:     {",
          "11024:       FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get4();",
          "11025:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];",
          "11026:     }",
          "11027:     if (tag == 0xfa29)",
          "11028:     {",
          "11029:       FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get4();",
          "11030:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];",
          "11031:     }",
          "11032:     if (tag == 0xfa2a)",
          "11033:     {",
          "11034:       FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get4();",
          "11035:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];",
          "11036:     }",
          "11039:     {",
          "11040:       FORC3 mul[c] = (num = getreal(type)) == 0 ? 1 : num;",
          "11042:     }",
          "11043:     if (tag == 2317)",
          "11044:       linear_table(len);",
          "11045:     if (tag == 0x903)",
          "11046:       iso_speed = getreal(type);",
          "11048:     if (tag == 64013)",
          "11049:       wbi = fgetc(ifp);",
          "11050:     if ((unsigned)wbi < 7 && tag == wbtag[wbi])",
          "11052:     if (tag == 64019)",
          "11053:       width = getint(type);",
          "11054:     if (tag == 64020)",
          "11055:       height = (getint(type) + 1) & -2;",
          "11056:     fseek(ifp, save, SEEK_SET);",
          "11060: void CLASS parse_kodak_ifd(int base)",
          "11063:   int i, c, wbi = -2, wbtemp = 6500;",
          "11064:   float mul[3] = {1, 1, 1}, num;",
          "11065:   static const int wbtag[] = {64037, 64040, 64039, 64041, -1, -1, 64042};",
          "11068:   if (entries > 1024)",
          "11069:     return;",
          "11070:   while (entries--)",
          "11071:   {",
          "11072:     tiff_get(base, &tag, &type, &len, &save);",
          "11073:     if (tag == 1020)",
          "11074:       wbi = getint(type);",
          "11075:     if (tag == 1021 && len == 72)",
          "11077:       fseek(ifp, 40, SEEK_CUR);",
          "11078:       FORC3 cam_mul[c] = 2048.0 / fMAX(1.0, get2());",
          "11081:     if (tag == 2118)",
          "11082:       wbtemp = getint(type);",
          "11084:       FORC3 cam_mul[c] = 2048.0 / fMAX(1.0, getreal(type));",
          "11088:       FORC3",
          "11089:       {",
          "11090:         for (num = i = 0; i < 4; i++)",
          "11091:           num += getreal(type) * pow(wbtemp / 100.0, i);",
          "11092:         cam_mul[c] = 2048 / fMAX(1.0, (num * mul[c]));",
          "11093:       }",
          "11094:     if (tag == 2317)",
          "11095:       linear_table(len);",
          "11096:     if (tag == 6020)",
          "11097:       iso_speed = getint(type);",
          "11098:     if (tag == 64013)",
          "11099:       wbi = fgetc(ifp);",
          "11100:     if ((unsigned)wbi < 7 && tag == wbtag[wbi])",
          "11102:     if (tag == 64019)",
          "11103:       width = getint(type);",
          "11104:     if (tag == 64020)",
          "11105:       height = (getint(type) + 1) & -2;",
          "11106:     fseek(ifp, save, SEEK_SET);",
          "11110: int CLASS parse_tiff_ifd(int base)",
          "11112:   unsigned entries, tag, type, len, plen = 16, save;",
          "11113:   int ifd, use_cm = 0, cfa, i, j, c, ima_len = 0;",
          "11115:   uchar cfa_pat[16], cfa_pc[] = {0, 1, 2, 3}, tab[256];",
          "11117:   double ab[] = {1, 1, 1, 1}, asn[] = {0, 0, 0, 0}, xyz[] = {1, 1, 1};",
          "11118:   unsigned sony_curve[] = {0, 0, 0, 0, 0, 4095};",
          "11119:   unsigned *buf, sony_offset = 0, sony_length = 0, sony_key = 0;",
          "",
          "---------------",
          "--- Hunk 89 ---",
          "[Context before]",
          "10153:   if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])",
          "10154:     return 1;",
          "10155:   ifd = tiff_nifds++;",
          "10158:       cc[j][i] = i == j;",
          "10159:   entries = get2();",
          "10161: #ifdef LIBRAW_LIBRARY_BUILD",
          "10163: #endif",
          "10166: #ifdef LIBRAW_LIBRARY_BUILD",
          "10276: #endif",
          "10277:       break;",
          "10280: #ifdef LIBRAW_LIBRARY_BUILD",
          "10283: #endif",
          "10284:       break;",
          "10286: #ifdef LIBRAW_LIBRARY_BUILD",
          "10290:         }",
          "10291: #endif",
          "10292:       break;",
          "10297: #ifdef LIBRAW_LIBRARY_BUILD",
          "10313: #endif",
          "10316:       break;",
          "10318: #ifdef LIBRAW_LIBRARY_BUILD",
          "10320:           {",
          "10322:           }",
          "10324: #endif",
          "10325:           {",
          "10540:           }",
          "10541:         break;",
          "10542: #endif",
          "10564: #ifdef LIBRAW_LIBRARY_BUILD",
          "10565:     case 30720: // Sony matrix, Sony_SR2SubIFD_0x7800",
          "10567:         float num = 0.0;",
          "10570:           num += imgdata.color.ccm[i][c];",
          "10571:         }",
          "10573:       }",
          "10574:       break;",
          "10575: #endif",
          "10576:     case 29456: // Sony black level, Sony_SR2SubIFD_0x7310, no more needs to be divided by 4",
          "10583: #ifdef DCRAW_VERBOSE",
          "10618:         break;",
          "10630: #ifdef LIBRAW_LIBRARY_BUILD",
          "10633:       imgdata.lens.FocalLengthIn35mmFormat = get2();",
          "10634:       break;",
          "10636:     case 0xc62f:",
          "10637:       stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "10638:       break;",
          "10640:       imgdata.lens.MinFocal = getreal(type);",
          "10641:       imgdata.lens.MaxFocal = getreal(type);",
          "10642:       imgdata.lens.MaxAp4MinFocal = getreal(type);",
          "10643:       imgdata.lens.MaxAp4MaxFocal = getreal(type);",
          "10644:       break;",
          "10646:       stmread(imgdata.lens.LensSerial, len, ifp);",
          "10647:       break;",
          "10649:       imgdata.lens.MinFocal = getreal(type);",
          "10650:       imgdata.lens.MaxFocal = getreal(type);",
          "10651:       imgdata.lens.MaxAp4MinFocal = getreal(type);",
          "10652:       imgdata.lens.MaxAp4MaxFocal = getreal(type);",
          "10653:       break;",
          "10655:       stmread(imgdata.lens.LensMake, len, ifp);",
          "10656:       break;",
          "10658:       stmread(imgdata.lens.Lens, len, ifp);",
          "10659:       if (!strncmp(imgdata.lens.Lens, \"----\", 4))",
          "10660:         imgdata.lens.Lens[0] = 0;",
          "",
          "[Removed Lines]",
          "10156:   for (j=0; j < 4; j++)",
          "10157:     for (i=0; i < 4; i++)",
          "10160:   if (entries > 512) return 1;",
          "10162:   INT64 fsize = ifp->size();",
          "10164:   while (entries--) {",
          "10165:     tiff_get (base, &tag, &type, &len, &save);",
          "10167:     INT64 savepos = ftell(ifp);",
          "10168:     if(len > 8 && len + savepos > fsize*2) continue; // skip tag pointing out of 2xfile",
          "10169:     if(callbacks.exif_cb)",
          "10170:       {",
          "10171:         callbacks.exif_cb(callbacks.exifparser_data,tag|(pana_raw?0x30000:0),type,len,order,ifp);",
          "10172:         fseek(ifp,savepos,SEEK_SET);",
          "10173:       }",
          "10174: #endif",
          "10176: #ifdef LIBRAW_LIBRARY_BUILD",
          "10177:   if (!strncasecmp(make, \"SONY\", 4) ||",
          "10178:       (!strncasecmp(make, \"Hasselblad\", 10) &&",
          "10179:         (!strncasecmp(model, \"Stellar\", 7) ||",
          "10180:          !strncasecmp(model, \"Lunar\", 5) ||",
          "10181:          !strncasecmp(model, \"HV\",2))))",
          "10182:   {",
          "10183:    switch (tag) {",
          "10184:  case 0x7300: // SR2 black level",
          "10185:      for (int i = 0; i < 4 && i < len; i++)",
          "10186:        cblack[i] = get2();",
          "10187:    break;",
          "10188:  case 0x7480:",
          "10189:  case 0x7820:",
          "10190:      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get2();",
          "10191:      imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];",
          "10192:  break;",
          "10193:  case 0x7481:",
          "10194:  case 0x7821:",
          "10195:      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c] = get2();",
          "10196:      imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1];",
          "10197:  break;",
          "10198:  case 0x7482:",
          "10199:  case 0x7822:",
          "10200:      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get2();",
          "10201:      imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];",
          "10202:  break;",
          "10203:  case 0x7483:",
          "10204:  case 0x7823:",
          "10205:      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c] = get2();",
          "10206:      imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1];",
          "10207:  break;",
          "10208:  case 0x7484:",
          "10209:  case 0x7824:",
          "10210:      imgdata.color.WBCT_Coeffs[0][0] = 4500;",
          "10211:      FORC3 imgdata.color.WBCT_Coeffs[0][c+1] = get2();",
          "10212:      imgdata.color.WBCT_Coeffs[0][4] = imgdata.color.WBCT_Coeffs[0][2];",
          "10213:  break;",
          "10214:  case 0x7486:",
          "10215:                 FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get2();",
          "10216:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];",
          "10217:  break;",
          "10218:  case 0x7825:",
          "10219:                 FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get2();",
          "10220:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];",
          "10221:  break;",
          "10222:  case 0x7826:",
          "10223:                 FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c] = get2();",
          "10224:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1];",
          "10225:  break;",
          "10226:  case 0x7827:",
          "10227:                 FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c] = get2();",
          "10228:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1];",
          "10229:  break;",
          "10230:  case 0x7828:",
          "10231:                 FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c] = get2();",
          "10232:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1];",
          "10233:  break;",
          "10234:  case 0x7829:",
          "10235:                 FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c] = get2();",
          "10236:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1];",
          "10237:  break;",
          "10238:  case 0x782a:",
          "10239:      imgdata.color.WBCT_Coeffs[1][0] = 8500;",
          "10240:      FORC3 imgdata.color.WBCT_Coeffs[1][c+1] = get2();",
          "10241:      imgdata.color.WBCT_Coeffs[1][4] = imgdata.color.WBCT_Coeffs[1][2];",
          "10242:  break;",
          "10243:  case 0x782b:",
          "10244:      imgdata.color.WBCT_Coeffs[2][0] = 6000;",
          "10245:      FORC3 imgdata.color.WBCT_Coeffs[2][c+1] = get2();",
          "10246:      imgdata.color.WBCT_Coeffs[2][4] = imgdata.color.WBCT_Coeffs[2][2];",
          "10247:  break;",
          "10248:  case 0x782c:",
          "10249:      imgdata.color.WBCT_Coeffs[3][0] = 3200;",
          "10250:                 FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][c] = imgdata.color.WBCT_Coeffs[3][c+1] = get2();",
          "10251:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][3] = imgdata.color.WBCT_Coeffs[3][4] = imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][1];",
          "10252:  break;",
          "10253:  case 0x782d:",
          "10254:      imgdata.color.WBCT_Coeffs[4][0] = 2500;",
          "10255:      FORC3 imgdata.color.WBCT_Coeffs[4][c+1] = get2();",
          "10256:      imgdata.color.WBCT_Coeffs[4][4] = imgdata.color.WBCT_Coeffs[4][2];",
          "10257:  break;",
          "10258:  case 0x787f:",
          "10259:      FORC3 imgdata.color.linear_max[c] = get2();",
          "10260:      imgdata.color.linear_max[3] = imgdata.color.linear_max[1];",
          "10261:  break;",
          "10262:  }",
          "10263:   }",
          "10264: #endif",
          "10267:     switch (tag) {",
          "10268:       case 1:   if(len==4) pana_raw = get4(); break;",
          "10269:       case 5:   width  = get2();  break;",
          "10270:       case 6:   height = get2();  break;",
          "10271:       case 7:   width += get2();  break;",
          "10272:       case 9:   if ((i = get2())) filters = i;",
          "10273: #ifdef LIBRAW_LIBRARY_BUILD",
          "10274:         if(pana_raw && len == 1 && type ==3)",
          "10275:           pana_black[3]+=i;",
          "10278:       case 8:",
          "10279:       case 10:",
          "10281:         if(pana_raw && len == 1 && type ==3)",
          "10282:           pana_black[3]+=get2();",
          "10285:       case 14: case 15: case 16:",
          "10287:         if(pana_raw) {",
          "10288:           imgdata.color.linear_max[tag-14] = get2();",
          "10289:           if (tag == 15 ) imgdata.color.linear_max[3] = imgdata.color.linear_max[1];",
          "10293:       case 17: case 18:",
          "10294:  if (type == 3 && len == 1)",
          "10295:    cam_mul[(tag-17)*2] = get2() / 256.0;",
          "10296:  break;",
          "10298:       case 19:",
          "10299:  if(pana_raw) {",
          "10300:    ushort nWB, cnt, tWB;",
          "10301:    nWB = get2();",
          "10302:    if (nWB > 0x100) break;",
          "10303:    for (cnt=0; cnt<nWB; cnt++) {",
          "10304:      tWB = get2();",
          "10305:      if (tWB < 0x100) {",
          "10306:        imgdata.color.WB_Coeffs[tWB][0] = get2();",
          "10307:        imgdata.color.WB_Coeffs[tWB][2] = get2();",
          "10308:        imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = 0x100;",
          "10309:      } else get4();",
          "10310:    }",
          "10311:  }",
          "10312:       break;",
          "10314:       case 23:",
          "10315:  if (type == 3) iso_speed = get2();",
          "10317:       case 28: case 29: case 30:",
          "10319:         if(pana_raw && len == 1 && type ==3)",
          "10321:             pana_black[tag-28] = get2();",
          "10323:         else",
          "10326:       cblack[tag-28] = get2();",
          "10327:       cblack[3] = cblack[1];",
          "10328:           }",
          "10329:  break;",
          "10330:       case 36: case 37: case 38:",
          "10331:  cam_mul[tag-36] = get2();",
          "10332:  break;",
          "10333:       case 39:",
          "10334: #ifdef LIBRAW_LIBRARY_BUILD",
          "10335:  if(pana_raw) {",
          "10336:      ushort nWB, cnt, tWB;",
          "10337:      nWB = get2();",
          "10338:      if (nWB > 0x100) break;",
          "10339:      for (cnt=0; cnt<nWB; cnt++) {",
          "10340:          tWB = get2();",
          "10341:          if (tWB < 0x100) {",
          "10342:              imgdata.color.WB_Coeffs[tWB][0] = get2();",
          "10343:              imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = get2();",
          "10344:              imgdata.color.WB_Coeffs[tWB][2] = get2();",
          "10345:          } else fseek(ifp, 6, SEEK_CUR);",
          "10346:      }",
          "10347:  }",
          "10348:  break;",
          "10349: #endif",
          "10350:  if (len < 50 || cam_mul[0]) break;",
          "10351:  fseek (ifp, 12, SEEK_CUR);",
          "10352:  FORC3 cam_mul[c] = get2();",
          "10353:  break;",
          "10354:       case 46:",
          "10355:  if (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) break;",
          "10356:  thumb_offset = ftell(ifp) - 2;",
          "10357:  thumb_length = len;",
          "10358:  break;",
          "10360:  fseek (ifp, get4()+base, SEEK_SET);",
          "10361:  parse_tiff_ifd (base);",
          "10362:  break;",
          "10364:  tiff_ifd[ifd].t_width = getint(type);",
          "10365:  break;",
          "10367:  tiff_ifd[ifd].t_height = getint(type);",
          "10368:  break;",
          "10370:       case 61443:",
          "10371:  tiff_ifd[ifd].samples = len & 7;",
          "10372:  tiff_ifd[ifd].bps = getint(type);",
          "10373:  if (tiff_bps < tiff_ifd[ifd].bps)",
          "10374:      tiff_bps = tiff_ifd[ifd].bps;",
          "10375:  break;",
          "10376:       case 61446:",
          "10377:  raw_height = 0;",
          "10378:  if (tiff_ifd[ifd].bps > 12) break;",
          "10379:  load_raw = &CLASS packed_load_raw;",
          "10380:  load_flags = get4() ? 24:80;",
          "10381:  break;",
          "10383:  tiff_ifd[ifd].comp = getint(type);",
          "10384:  break;",
          "10386:  tiff_ifd[ifd].phint = get2();",
          "10387:  break;",
          "10389:  fread (desc, 512, 1, ifp);",
          "10390:  break;",
          "10392:  fgets (make, 64, ifp);",
          "10393:  break;",
          "10395:  fgets (model, 64, ifp);",
          "10396:  break;",
          "10397: #ifdef LIBRAW_LIBRARY_BUILD",
          "10398:       case 278:",
          "10399:  tiff_ifd[ifd].rows_per_strip = getint(type);",
          "10400:  break;",
          "10401: #endif",
          "10403:  if (type != 4) break;",
          "10404:  load_raw = &CLASS panasonic_load_raw;",
          "10405:  load_flags = 0x2008;",
          "10407: #ifdef LIBRAW_LIBRARY_BUILD",
          "10408:  if(len > 1 && len < 16384)",
          "10409:    {",
          "10410:      off_t sav = ftell(ifp);",
          "10411:      tiff_ifd[ifd].strip_offsets = (int*)calloc(len,sizeof(int));",
          "10412:      tiff_ifd[ifd].strip_offsets_count = len;",
          "10413:      for(int i=0; i< len; i++)",
          "10414:        tiff_ifd[ifd].strip_offsets[i]=get4()+base;",
          "10415:      fseek(ifp,sav,SEEK_SET); // restore position",
          "10416:    }",
          "10418: #endif",
          "10420:       case 61447:",
          "10421:  tiff_ifd[ifd].offset = get4()+base;",
          "10422:  if (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0) {",
          "10423:    fseek (ifp, tiff_ifd[ifd].offset, SEEK_SET);",
          "10424:    if (ljpeg_start (&jh, 1)) {",
          "10425:      tiff_ifd[ifd].comp    = 6;",
          "10426:      tiff_ifd[ifd].t_width   = jh.wide;",
          "10427:      tiff_ifd[ifd].t_height  = jh.high;",
          "10428:      tiff_ifd[ifd].bps     = jh.bits;",
          "10429:      tiff_ifd[ifd].samples = jh.clrs;",
          "10430:      if (!(jh.sraw || (jh.clrs & 1)))",
          "10431:        tiff_ifd[ifd].t_width *= jh.clrs;",
          "10432:      if ((tiff_ifd[ifd].t_width > 4*tiff_ifd[ifd].t_height) & ~jh.clrs) {",
          "10433:        tiff_ifd[ifd].t_width  /= 2;",
          "10434:        tiff_ifd[ifd].t_height *= 2;",
          "10435:      }",
          "10436:      i = order;",
          "10437:      parse_tiff (tiff_ifd[ifd].offset + 12);",
          "10438:      order = i;",
          "10439:    }",
          "10440:  }",
          "10441:  break;",
          "10443:  tiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7]-'0';",
          "10444:  break;",
          "10446:  tiff_ifd[ifd].samples = getint(type) & 7;",
          "10447:  break;",
          "10449: #ifdef LIBRAW_LIBRARY_BUILD",
          "10450:  if(len > 1 && len < 16384)",
          "10451:    {",
          "10452:      off_t sav = ftell(ifp);",
          "10453:      tiff_ifd[ifd].strip_byte_counts = (int*)calloc(len,sizeof(int));",
          "10454:      tiff_ifd[ifd].strip_byte_counts_count = len;",
          "10455:      for(int i=0; i< len; i++)",
          "10456:   tiff_ifd[ifd].strip_byte_counts[i]=get4();",
          "10457:      fseek(ifp,sav,SEEK_SET); // restore position",
          "10458:    }",
          "10460: #endif",
          "10461:       case 514:",
          "10462:       case 61448:",
          "10463:  tiff_ifd[ifd].bytes = get4();",
          "10464:  break;",
          "10465:       case 61454:",
          "10466:  FORC3 cam_mul[(4-c) % 3] = getint(type);",
          "10467:  break;",
          "10469:  fgets (software, 64, ifp);",
          "10470:  if (!strncmp(software,\"Adobe\",5) ||",
          "10471:      !strncmp(software,\"dcraw\",5) ||",
          "10472:      !strncmp(software,\"UFRaw\",5) ||",
          "10473:      !strncmp(software,\"Bibble\",6) ||",
          "10474:      !strcmp (software,\"Digital Photo Professional\"))",
          "10475:    is_raw = 0;",
          "10476:  break;",
          "10478:  get_timestamp(0);",
          "10479:  break;",
          "10481:  fread (artist, 64, 1, ifp);",
          "10482:  break;",
          "10483:       case 317:",
          "10484:  tiff_ifd[ifd].predictor = getint(type);",
          "10485:  break;",
          "10487:  tiff_ifd[ifd].t_tile_width = getint(type);",
          "10488:  break;",
          "10490:  tiff_ifd[ifd].t_tile_length = getint(type);",
          "10491:  break;",
          "10493:  tiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();",
          "10494:  if (len == 1)",
          "10495:    tiff_ifd[ifd].t_tile_width = tiff_ifd[ifd].t_tile_length = 0;",
          "10496:  if (len == 4) {",
          "10497:    load_raw = &CLASS sinar_4shot_load_raw;",
          "10498:    is_raw = 5;",
          "10499:  }",
          "10500:  break;",
          "10501:       case 325:",
          "10502:  tiff_ifd[ifd].bytes = len > 1 ? ftell(ifp): get4();",
          "10503:  break;",
          "10505:  if (!strcmp(model,\"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872) {",
          "10506:    load_raw = &CLASS sony_arw_load_raw;",
          "10507:    data_offset = get4()+base;",
          "10508:    ifd++;  break;",
          "10509:  }",
          "10510: #ifdef LIBRAW_LIBRARY_BUILD",
          "10511:  if (!strncmp(make,\"Hasselblad\",10) && libraw_internal_data.unpacker_data.hasselblad_parser_flag) {",
          "10512:           fseek (ifp, ftell(ifp)+4, SEEK_SET);",
          "10513:           fseek (ifp, get4()+base, SEEK_SET);",
          "10514:           parse_tiff_ifd (base);",
          "10515:           break;",
          "10516:  }",
          "10517: #endif",
          "10519:  while (len--) {",
          "10520:    i = ftell(ifp);",
          "10521:    fseek (ifp, get4()+base, SEEK_SET);",
          "10522:    if (parse_tiff_ifd (base)) break;",
          "10523:    fseek (ifp, i+4, SEEK_SET);",
          "10524:  }",
          "10525:  break;",
          "10526:       case 339:",
          "10527:  tiff_ifd[ifd].sample_format = getint(type);",
          "10528:  break;",
          "10529:       case 400:",
          "10530:  strcpy (make, \"Sarnoff\");",
          "10531:  maximum = 0xfff;",
          "10532:  break;",
          "10533: #ifdef LIBRAW_LIBRARY_BUILD",
          "10534:       case 700:",
          "10535:         if((type == 1 || type == 2 || type == 6 || type == 7) && len > 1 && len < 5100000)",
          "10536:           {",
          "10537:             xmpdata = (char*)malloc(xmplen = len+1);",
          "10538:             fread(xmpdata,len,1,ifp);",
          "10539:             xmpdata[len]=0;",
          "10543:       case 28688:",
          "10544:  FORC4 sony_curve[c+1] = get2() >> 2 & 0xfff;",
          "10545:  for (i=0; i < 5; i++)",
          "10546:    for (j = sony_curve[i]+1; j <= sony_curve[i+1]; j++)",
          "10547:      curve[j] = curve[j-1] + (1 << i);",
          "10548:  break;",
          "10549:       case 29184: sony_offset = get4();  break;",
          "10550:       case 29185: sony_length = get4();  break;",
          "10551:       case 29217: sony_key    = get4();  break;",
          "10552:       case 29264:",
          "10553:  parse_minolta (ftell(ifp));",
          "10554:  raw_width = 0;",
          "10555:  break;",
          "10556:       case 29443:",
          "10557:  FORC4 cam_mul[c ^ (c < 2)] = get2();",
          "10558:  break;",
          "10559:       case 29459:",
          "10560:  FORC4 cam_mul[c] = get2();",
          "10561:  i = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;",
          "10562:  SWAP (cam_mul[i],cam_mul[i+1])",
          "10563:  break;",
          "10566:       for (i=0; i < 3; i++) {",
          "10568:         for (c=0; c<3; c++) {",
          "10569:           imgdata.color.ccm[i][c] = (float) ((short)get2());",
          "10572:         if (num > 0.01) FORC3 imgdata.color.ccm[i][c] = imgdata.color.ccm[i][c] / num;",
          "10577:    FORC4 cblack[c ^ c >> 1] = get2();",
          "10578:    i = cblack[3];",
          "10579:    FORC3 if(i>cblack[c]) i = cblack[c];",
          "10580:    FORC4 cblack[c]-=i;",
          "10581:    black = i;",
          "10584:       if (verbose) fprintf (stderr, _(\"...Sony black: %u cblack: %u %u %u %u\\n\"),black, cblack[0],cblack[1],cblack[2], cblack[3]);",
          "10585: #endif",
          "10586:       break;",
          "10588:  fgets (model2, 64, ifp);",
          "10589:  break;",
          "10591:  if (get2() == 6 && get2() == 6)",
          "10592:    filters = 9;",
          "10593:  break;",
          "10595:  if (filters == 9) {",
          "10596:    FORC(36) ((char *)xtrans)[c] = fgetc(ifp) & 3;",
          "10597:    break;",
          "10598:  }",
          "10600:         if(len == 36)",
          "10601:           {",
          "10602:             filters = 9;",
          "10603:             colors = 3;",
          "10604:             FORC(36) xtrans[0][c] = fgetc(ifp) & 3;",
          "10605:           }",
          "10606:         else if(len > 0)",
          "10607:           {",
          "10608:             if ((plen=len) > 16) plen = 16;",
          "10609:             fread (cfa_pat, 1, plen, ifp);",
          "10610:             for (colors=cfa=i=0; i < plen && colors < 4; i++) {",
          "10611:               colors += !(cfa & (1 << cfa_pat[i]));",
          "10612:               cfa |= 1 << cfa_pat[i];",
          "10613:             }",
          "10616:             goto guess_cfa_pc;",
          "10617:           }",
          "10619:       case 33424:",
          "10620:       case 65024:",
          "10621:  fseek (ifp, get4()+base, SEEK_SET);",
          "10622:  parse_kodak_ifd (base);",
          "10623:  break;",
          "10625:  tiff_ifd[ifd].t_shutter = shutter = getreal(type);",
          "10626:  break;",
          "10628:  aperture = getreal(type);",
          "10629:  break;",
          "10632:     case 0xa405:  // FocalLengthIn35mmFormat",
          "10635:     case 0xa431:  // BodySerialNumber",
          "10639:     case 0xa432:  // LensInfo, 42034dec, Lens Specification per EXIF standard",
          "10645:     case 0xa435:  // LensSerialNumber",
          "10648:     case 0xc630:  // DNG LensInfo, Lens Specification per EXIF standard",
          "10654:     case 0xa433:  // LensMake",
          "10657:     case 0xa434:  // LensModel",
          "",
          "[Added Lines]",
          "11129:   for (j = 0; j < 4; j++)",
          "11130:     for (i = 0; i < 4; i++)",
          "11133:   if (entries > 512)",
          "11134:     return 1;",
          "11135: #ifdef LIBRAW_LIBRARY_BUILD",
          "11136:   INT64 fsize = ifp->size();",
          "11137: #endif",
          "11138:   while (entries--)",
          "11139:   {",
          "11140:     tiff_get(base, &tag, &type, &len, &save);",
          "11141: #ifdef LIBRAW_LIBRARY_BUILD",
          "11142:     INT64 savepos = ftell(ifp);",
          "11143:     if (len > 8 && len + savepos > fsize * 2)",
          "11144:       continue; // skip tag pointing out of 2xfile",
          "11145:     if (callbacks.exif_cb)",
          "11146:     {",
          "11147:       callbacks.exif_cb(callbacks.exifparser_data, tag | (pana_raw ? 0x30000 : 0), type, len, order, ifp);",
          "11148:       fseek(ifp, savepos, SEEK_SET);",
          "11149:     }",
          "11150: #endif",
          "11152: #ifdef LIBRAW_LIBRARY_BUILD",
          "11153:     if (!strncasecmp(make, \"SONY\", 4) ||",
          "11154:         (!strncasecmp(make, \"Hasselblad\", 10) &&",
          "11155:          (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) || !strncasecmp(model, \"HV\", 2))))",
          "11156:     {",
          "11157:       switch (tag)",
          "11158:       {",
          "11159:       case 0x7300: // SR2 black level",
          "11160:         for (int i = 0; i < 4 && i < len; i++)",
          "11161:           cblack[i] = get2();",
          "11162:         break;",
          "11163:       case 0x7480:",
          "11164:       case 0x7820:",
          "11165:         FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get2();",
          "11166:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];",
          "11167:         break;",
          "11168:       case 0x7481:",
          "11169:       case 0x7821:",
          "11170:         FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c] = get2();",
          "11171:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1];",
          "11172:         break;",
          "11173:       case 0x7482:",
          "11174:       case 0x7822:",
          "11175:         FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get2();",
          "11176:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];",
          "11177:         break;",
          "11178:       case 0x7483:",
          "11179:       case 0x7823:",
          "11180:         FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c] = get2();",
          "11181:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1];",
          "11182:         break;",
          "11183:       case 0x7484:",
          "11184:       case 0x7824:",
          "11185:         imgdata.color.WBCT_Coeffs[0][0] = 4500;",
          "11186:         FORC3 imgdata.color.WBCT_Coeffs[0][c + 1] = get2();",
          "11187:         imgdata.color.WBCT_Coeffs[0][4] = imgdata.color.WBCT_Coeffs[0][2];",
          "11188:         break;",
          "11189:       case 0x7486:",
          "11190:         FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get2();",
          "11191:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];",
          "11192:         break;",
          "11193:       case 0x7825:",
          "11194:         FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get2();",
          "11195:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];",
          "11196:         break;",
          "11197:       case 0x7826:",
          "11198:         FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c] = get2();",
          "11199:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1];",
          "11200:         break;",
          "11201:       case 0x7827:",
          "11202:         FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c] = get2();",
          "11203:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1];",
          "11204:         break;",
          "11205:       case 0x7828:",
          "11206:         FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c] = get2();",
          "11207:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1];",
          "11208:         break;",
          "11209:       case 0x7829:",
          "11210:         FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c] = get2();",
          "11211:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1];",
          "11212:         break;",
          "11213:       case 0x782a:",
          "11214:         imgdata.color.WBCT_Coeffs[1][0] = 8500;",
          "11215:         FORC3 imgdata.color.WBCT_Coeffs[1][c + 1] = get2();",
          "11216:         imgdata.color.WBCT_Coeffs[1][4] = imgdata.color.WBCT_Coeffs[1][2];",
          "11217:         break;",
          "11218:       case 0x782b:",
          "11219:         imgdata.color.WBCT_Coeffs[2][0] = 6000;",
          "11220:         FORC3 imgdata.color.WBCT_Coeffs[2][c + 1] = get2();",
          "11221:         imgdata.color.WBCT_Coeffs[2][4] = imgdata.color.WBCT_Coeffs[2][2];",
          "11222:         break;",
          "11223:       case 0x782c:",
          "11224:         imgdata.color.WBCT_Coeffs[3][0] = 3200;",
          "11225:         FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][c] = imgdata.color.WBCT_Coeffs[3][c + 1] = get2();",
          "11226:         imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][3] = imgdata.color.WBCT_Coeffs[3][4] =",
          "11227:             imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][1];",
          "11228:         break;",
          "11229:       case 0x782d:",
          "11230:         imgdata.color.WBCT_Coeffs[4][0] = 2500;",
          "11231:         FORC3 imgdata.color.WBCT_Coeffs[4][c + 1] = get2();",
          "11232:         imgdata.color.WBCT_Coeffs[4][4] = imgdata.color.WBCT_Coeffs[4][2];",
          "11233:         break;",
          "11234:       case 0x787f:",
          "11235:         FORC3 imgdata.color.linear_max[c] = get2();",
          "11236:         imgdata.color.linear_max[3] = imgdata.color.linear_max[1];",
          "11237:         break;",
          "11238:       }",
          "11239:     }",
          "11240: #endif",
          "11242:     switch (tag)",
          "11243:     {",
          "11244:     case 1:",
          "11245:       if (len == 4)",
          "11246:         pana_raw = get4();",
          "11247:       break;",
          "11248:     case 5:",
          "11249:       width = get2();",
          "11250:       break;",
          "11251:     case 6:",
          "11252:       height = get2();",
          "11253:       break;",
          "11254:     case 7:",
          "11255:       width += get2();",
          "11256:       break;",
          "11257:     case 9:",
          "11258:       if ((i = get2()))",
          "11259:         filters = i;",
          "11261:       if (pana_raw && len == 1 && type == 3)",
          "11262:         pana_black[3] += i;",
          "11264:       break;",
          "11265:     case 8:",
          "11266:     case 10:",
          "11268:       if (pana_raw && len == 1 && type == 3)",
          "11269:         pana_black[3] += get2();",
          "11272:     case 14:",
          "11273:     case 15:",
          "11274:     case 16:",
          "11276:       if (pana_raw)",
          "11277:       {",
          "11278:         imgdata.color.linear_max[tag - 14] = get2();",
          "11279:         if (tag == 15)",
          "11280:           imgdata.color.linear_max[3] = imgdata.color.linear_max[1];",
          "11281:       }",
          "11284:     case 17:",
          "11285:     case 18:",
          "11286:       if (type == 3 && len == 1)",
          "11287:         cam_mul[(tag - 17) * 2] = get2() / 256.0;",
          "11288:       break;",
          "11290:     case 19:",
          "11291:       if (pana_raw)",
          "11292:       {",
          "11293:         ushort nWB, cnt, tWB;",
          "11294:         nWB = get2();",
          "11295:         if (nWB > 0x100)",
          "11296:           break;",
          "11297:         for (cnt = 0; cnt < nWB; cnt++)",
          "11298:         {",
          "11299:           tWB = get2();",
          "11300:           if (tWB < 0x100)",
          "11301:           {",
          "11302:             imgdata.color.WB_Coeffs[tWB][0] = get2();",
          "11303:             imgdata.color.WB_Coeffs[tWB][2] = get2();",
          "11304:             imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = 0x100;",
          "11305:           }",
          "11306:           else",
          "11307:             get4();",
          "11309:       }",
          "11310:       break;",
          "11312:     case 23:",
          "11313:       if (type == 3)",
          "11314:         iso_speed = get2();",
          "11316:     case 28:",
          "11317:     case 29:",
          "11318:     case 30:",
          "11320:       if (pana_raw && len == 1 && type == 3)",
          "11321:       {",
          "11322:         pana_black[tag - 28] = get2();",
          "11323:       }",
          "11324:       else",
          "11326:       {",
          "11327:         cblack[tag - 28] = get2();",
          "11328:         cblack[3] = cblack[1];",
          "11329:       }",
          "11330:       break;",
          "11331:     case 36:",
          "11332:     case 37:",
          "11333:     case 38:",
          "11334:       cam_mul[tag - 36] = get2();",
          "11336:     case 39:",
          "11338:       if (pana_raw)",
          "11339:       {",
          "11340:         ushort nWB, cnt, tWB;",
          "11341:         nWB = get2();",
          "11342:         if (nWB > 0x100)",
          "11343:           break;",
          "11344:         for (cnt = 0; cnt < nWB; cnt++)",
          "11345:         {",
          "11346:           tWB = get2();",
          "11347:           if (tWB < 0x100)",
          "11349:             imgdata.color.WB_Coeffs[tWB][0] = get2();",
          "11350:             imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = get2();",
          "11351:             imgdata.color.WB_Coeffs[tWB][2] = get2();",
          "11353:           else",
          "11354:             fseek(ifp, 6, SEEK_CUR);",
          "11355:         }",
          "11356:       }",
          "11357:       break;",
          "11359:       if (len < 50 || cam_mul[0])",
          "11360:         break;",
          "11361:       fseek(ifp, 12, SEEK_CUR);",
          "11362:       FORC3 cam_mul[c] = get2();",
          "11363:       break;",
          "11364:     case 46:",
          "11365:       if (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)",
          "11366:         break;",
          "11367:       thumb_offset = ftell(ifp) - 2;",
          "11368:       thumb_length = len;",
          "11369:       break;",
          "11371:       fseek(ifp, get4() + base, SEEK_SET);",
          "11372:       parse_tiff_ifd(base);",
          "11373:       break;",
          "11374:     case 2:",
          "11375:     case 256:",
          "11377:       tiff_ifd[ifd].t_width = getint(type);",
          "11378:       break;",
          "11379:     case 3:",
          "11380:     case 257:",
          "11382:       tiff_ifd[ifd].t_height = getint(type);",
          "11383:       break;",
          "11385:     case 61443:",
          "11386:       tiff_ifd[ifd].samples = len & 7;",
          "11387:       tiff_ifd[ifd].bps = getint(type);",
          "11388:       if (tiff_bps < tiff_ifd[ifd].bps)",
          "11389:         tiff_bps = tiff_ifd[ifd].bps;",
          "11390:       break;",
          "11391:     case 61446:",
          "11392:       raw_height = 0;",
          "11393:       if (tiff_ifd[ifd].bps > 12)",
          "11394:         break;",
          "11395:       load_raw = &CLASS packed_load_raw;",
          "11396:       load_flags = get4() ? 24 : 80;",
          "11397:       break;",
          "11399:       tiff_ifd[ifd].comp = getint(type);",
          "11400:       break;",
          "11402:       tiff_ifd[ifd].phint = get2();",
          "11403:       break;",
          "11405:       fread(desc, 512, 1, ifp);",
          "11406:       break;",
          "11408:       fgets(make, 64, ifp);",
          "11409:       break;",
          "11411:       fgets(model, 64, ifp);",
          "11412:       break;",
          "11413: #ifdef LIBRAW_LIBRARY_BUILD",
          "11414:     case 278:",
          "11415:       tiff_ifd[ifd].rows_per_strip = getint(type);",
          "11416:       break;",
          "11417: #endif",
          "11419:       if (type != 4)",
          "11420:         break;",
          "11421:       load_raw = &CLASS panasonic_load_raw;",
          "11422:       load_flags = 0x2008;",
          "11424: #ifdef LIBRAW_LIBRARY_BUILD",
          "11425:       if (len > 1 && len < 16384)",
          "11426:       {",
          "11427:         off_t sav = ftell(ifp);",
          "11428:         tiff_ifd[ifd].strip_offsets = (int *)calloc(len, sizeof(int));",
          "11429:         tiff_ifd[ifd].strip_offsets_count = len;",
          "11430:         for (int i = 0; i < len; i++)",
          "11431:           tiff_ifd[ifd].strip_offsets[i] = get4() + base;",
          "11432:         fseek(ifp, sav, SEEK_SET); // restore position",
          "11433:       }",
          "11435: #endif",
          "11437:     case 61447:",
          "11438:       tiff_ifd[ifd].offset = get4() + base;",
          "11439:       if (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0)",
          "11440:       {",
          "11441:         fseek(ifp, tiff_ifd[ifd].offset, SEEK_SET);",
          "11442:         if (ljpeg_start(&jh, 1))",
          "11443:         {",
          "11444:           tiff_ifd[ifd].comp = 6;",
          "11445:           tiff_ifd[ifd].t_width = jh.wide;",
          "11446:           tiff_ifd[ifd].t_height = jh.high;",
          "11447:           tiff_ifd[ifd].bps = jh.bits;",
          "11448:           tiff_ifd[ifd].samples = jh.clrs;",
          "11449:           if (!(jh.sraw || (jh.clrs & 1)))",
          "11450:             tiff_ifd[ifd].t_width *= jh.clrs;",
          "11451:           if ((tiff_ifd[ifd].t_width > 4 * tiff_ifd[ifd].t_height) & ~jh.clrs)",
          "11453:             tiff_ifd[ifd].t_width /= 2;",
          "11454:             tiff_ifd[ifd].t_height *= 2;",
          "11456:           i = order;",
          "11457:           parse_tiff(tiff_ifd[ifd].offset + 12);",
          "11458:           order = i;",
          "11459:         }",
          "11460:       }",
          "11461:       break;",
          "11463:       tiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7] - '0';",
          "11464:       break;",
          "11466:       tiff_ifd[ifd].samples = getint(type) & 7;",
          "11467:       break;",
          "11469: #ifdef LIBRAW_LIBRARY_BUILD",
          "11470:       if (len > 1 && len < 16384)",
          "11471:       {",
          "11472:         off_t sav = ftell(ifp);",
          "11473:         tiff_ifd[ifd].strip_byte_counts = (int *)calloc(len, sizeof(int));",
          "11474:         tiff_ifd[ifd].strip_byte_counts_count = len;",
          "11475:         for (int i = 0; i < len; i++)",
          "11476:           tiff_ifd[ifd].strip_byte_counts[i] = get4();",
          "11477:         fseek(ifp, sav, SEEK_SET); // restore position",
          "11478:       }",
          "11480: #endif",
          "11481:     case 514:",
          "11482:     case 61448:",
          "11483:       tiff_ifd[ifd].bytes = get4();",
          "11484:       break;",
          "11485:     case 61454:",
          "11486:       FORC3 cam_mul[(4 - c) % 3] = getint(type);",
          "11487:       break;",
          "11488:     case 305:",
          "11490:       fgets(software, 64, ifp);",
          "11491:       if (!strncmp(software, \"Adobe\", 5) || !strncmp(software, \"dcraw\", 5) || !strncmp(software, \"UFRaw\", 5) ||",
          "11492:           !strncmp(software, \"Bibble\", 6) || !strcmp(software, \"Digital Photo Professional\"))",
          "11493:         is_raw = 0;",
          "11494:       break;",
          "11496:       get_timestamp(0);",
          "11497:       break;",
          "11499:       fread(artist, 64, 1, ifp);",
          "11500:       break;",
          "11501:     case 317:",
          "11502:       tiff_ifd[ifd].predictor = getint(type);",
          "11503:       break;",
          "11505:       tiff_ifd[ifd].t_tile_width = getint(type);",
          "11506:       break;",
          "11508:       tiff_ifd[ifd].t_tile_length = getint(type);",
          "11509:       break;",
          "11511:       tiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();",
          "11512:       if (len == 1)",
          "11513:         tiff_ifd[ifd].t_tile_width = tiff_ifd[ifd].t_tile_length = 0;",
          "11514:       if (len == 4)",
          "11515:       {",
          "11516:         load_raw = &CLASS sinar_4shot_load_raw;",
          "11517:         is_raw = 5;",
          "11518:       }",
          "11519:       break;",
          "11520:     case 325:",
          "11521:       tiff_ifd[ifd].bytes = len > 1 ? ftell(ifp) : get4();",
          "11522:       break;",
          "11524:       if (!strcmp(model, \"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872)",
          "11525:       {",
          "11526:         load_raw = &CLASS sony_arw_load_raw;",
          "11527:         data_offset = get4() + base;",
          "11528:         ifd++;",
          "11529:         break;",
          "11530:       }",
          "11531: #ifdef LIBRAW_LIBRARY_BUILD",
          "11532:       if (!strncmp(make, \"Hasselblad\", 10) && libraw_internal_data.unpacker_data.hasselblad_parser_flag)",
          "11533:       {",
          "11534:         fseek(ifp, ftell(ifp) + 4, SEEK_SET);",
          "11535:         fseek(ifp, get4() + base, SEEK_SET);",
          "11536:         parse_tiff_ifd(base);",
          "11538:       }",
          "11539: #endif",
          "11540:       if (len > 1000)",
          "11542:       while (len--)",
          "11543:       {",
          "11544:         i = ftell(ifp);",
          "11545:         fseek(ifp, get4() + base, SEEK_SET);",
          "11546:         if (parse_tiff_ifd(base))",
          "11547:           break;",
          "11548:         fseek(ifp, i + 4, SEEK_SET);",
          "11549:       }",
          "11550:       break;",
          "11551:     case 339:",
          "11552:       tiff_ifd[ifd].sample_format = getint(type);",
          "11553:       break;",
          "11554:     case 400:",
          "11555:       strcpy(make, \"Sarnoff\");",
          "11556:       maximum = 0xfff;",
          "11557:       break;",
          "11558: #ifdef LIBRAW_LIBRARY_BUILD",
          "11559:     case 700:",
          "11560:       if ((type == 1 || type == 2 || type == 6 || type == 7) && len > 1 && len < 5100000)",
          "11561:       {",
          "11562:         xmpdata = (char *)malloc(xmplen = len + 1);",
          "11563:         fread(xmpdata, len, 1, ifp);",
          "11564:         xmpdata[len] = 0;",
          "11565:       }",
          "11566:       break;",
          "11568:     case 28688:",
          "11569:       FORC4 sony_curve[c + 1] = get2() >> 2 & 0xfff;",
          "11570:       for (i = 0; i < 5; i++)",
          "11571:         for (j = sony_curve[i] + 1; j <= sony_curve[i + 1]; j++)",
          "11572:           curve[j] = curve[j - 1] + (1 << i);",
          "11573:       break;",
          "11574:     case 29184:",
          "11575:       sony_offset = get4();",
          "11576:       break;",
          "11577:     case 29185:",
          "11578:       sony_length = get4();",
          "11579:       break;",
          "11580:     case 29217:",
          "11581:       sony_key = get4();",
          "11582:       break;",
          "11583:     case 29264:",
          "11584:       parse_minolta(ftell(ifp));",
          "11585:       raw_width = 0;",
          "11586:       break;",
          "11587:     case 29443:",
          "11588:       FORC4 cam_mul[c ^ (c < 2)] = get2();",
          "11589:       break;",
          "11590:     case 29459:",
          "11591:       FORC4 cam_mul[c] = get2();",
          "11592:       i = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;",
          "11593:       SWAP(cam_mul[i], cam_mul[i + 1])",
          "11594:       break;",
          "11597:       for (i = 0; i < 3; i++)",
          "11598:       {",
          "11600:         for (c = 0; c < 3; c++)",
          "11601:         {",
          "11602:           imgdata.color.ccm[i][c] = (float)((short)get2());",
          "11605:         if (num > 0.01)",
          "11606:           FORC3 imgdata.color.ccm[i][c] = imgdata.color.ccm[i][c] / num;",
          "11611:       FORC4 cblack[c ^ c >> 1] = get2();",
          "11612:       i = cblack[3];",
          "11613:       FORC3 if (i > cblack[c]) i = cblack[c];",
          "11614:       FORC4 cblack[c] -= i;",
          "11615:       black = i;",
          "11618:       if (verbose)",
          "11619:         fprintf(stderr, _(\"...Sony black: %u cblack: %u %u %u %u\\n\"), black, cblack[0], cblack[1], cblack[2],",
          "11620:                 cblack[3]);",
          "11621: #endif",
          "11622:       break;",
          "11624:       fgets(model2, 64, ifp);",
          "11625:       break;",
          "11627:       if (get2() == 6 && get2() == 6)",
          "11628:         filters = 9;",
          "11629:       break;",
          "11631:       if (filters == 9)",
          "11632:       {",
          "11633:         FORC(36)((char *)xtrans)[c] = fgetc(ifp) & 3;",
          "11635:       }",
          "11637:       if (len == 36)",
          "11638:       {",
          "11639:         filters = 9;",
          "11640:         colors = 3;",
          "11641:         FORC(36) xtrans[0][c] = fgetc(ifp) & 3;",
          "11642:       }",
          "11643:       else if (len > 0)",
          "11644:       {",
          "11645:         if ((plen = len) > 16)",
          "11646:           plen = 16;",
          "11647:         fread(cfa_pat, 1, plen, ifp);",
          "11648:         for (colors = cfa = i = 0; i < plen && colors < 4; i++)",
          "11649:         {",
          "11650:           colors += !(cfa & (1 << cfa_pat[i]));",
          "11651:           cfa |= 1 << cfa_pat[i];",
          "11652:         }",
          "11653:         if (cfa == 070)",
          "11655:         if (cfa == 072)",
          "11657:         goto guess_cfa_pc;",
          "11658:       }",
          "11659:       break;",
          "11660:     case 33424:",
          "11661:     case 65024:",
          "11662:       fseek(ifp, get4() + base, SEEK_SET);",
          "11663:       parse_kodak_ifd(base);",
          "11664:       break;",
          "11666:       tiff_ifd[ifd].t_shutter = shutter = getreal(type);",
          "11667:       break;",
          "11669:       aperture = getreal(type);",
          "11670:       break;",
          "11673:     case 0xa405: // FocalLengthIn35mmFormat",
          "11676:     case 0xa431: // BodySerialNumber",
          "11680:     case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard",
          "11686:     case 0xa435: // LensSerialNumber",
          "11689:     case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard",
          "11695:     case 0xa433: // LensMake",
          "11698:     case 0xa434: // LensModel",
          "",
          "---------------",
          "--- Hunk 90 ---",
          "[Context before]",
          "10664:       break;",
          "10666: #endif",
          "10777: #ifndef LIBRAW_LIBRARY_BUILD",
          "10779: #else",
          "10817: #ifndef LIBRAW_LIBRARY_BUILD",
          "10819: #else",
          "10918:                 {",
          "10942:     }",
          "10943:     break;",
          "10944: #endif",
          "10946: #ifdef LIBRAW_LIBRARY_BUILD",
          "10949:       break;",
          "10950: #endif",
          "10955: #ifdef LIBRAW_LIBRARY_BUILD",
          "10966: #endif",
          "10969: #ifdef LIBRAW_LIBRARY_BUILD",
          "10971: #endif",
          "10983: #ifdef LIBRAW_LIBRARY_BUILD",
          "10992: #endif",
          "10994:       break;",
          "11000: #ifdef LIBRAW_LIBRARY_BUILD",
          "11002: #endif",
          "11005: #ifdef LIBRAW_LIBRARY_BUILD",
          "11007: #endif",
          "11009: #ifdef LIBRAW_LIBRARY_BUILD",
          "11013: #endif",
          "11021: #ifdef LIBRAW_LIBRARY_BUILD",
          "11028: #endif",
          "11031: #ifdef LIBRAW_LIBRARY_BUILD",
          "11033: #endif",
          "11036: #ifdef LIBRAW_LIBRARY_BUILD",
          "11038: #endif",
          "11046: #ifdef LIBRAW_LIBRARY_BUILD",
          "11048: #endif",
          "11052: #ifdef LIBRAW_LIBRARY_BUILD",
          "11054: #endif",
          "11055:               fm[j][c] = getreal(type);",
          "11061: #ifdef LIBRAW_LIBRARY_BUILD",
          "11063: #endif",
          "11067: #ifdef LIBRAW_LIBRARY_BUILD",
          "11069: #endif",
          "11070:               cc[i][c] = getreal(type);",
          "11094: #endif",
          "11097: #ifdef LIBRAW_LIBRARY_BUILD",
          "11098:       {",
          "11127:           {",
          "11136:           }",
          "11140:       }",
          "11142: #endif",
          "11147:       break;",
          "11148:     case 50752:",
          "11150:       break;",
          "11152:       top_margin = getint(type);",
          "11153:       left_margin = getint(type);",
          "11154:       height = getint(type) - top_margin;",
          "11155:       width = getint(type) - left_margin;",
          "11156:       break;",
          "11160:       black = 0;",
          "11161:       break;",
          "11163:       meta_offset = ftell(ifp);",
          "11164:       break;",
          "11168:       data_offset = get4();",
          "11170:       data_offset += get4();",
          "11171:       load_raw = &CLASS packed_load_raw;",
          "11172:       break;",
          "11173:     case 65026:",
          "11175:     }",
          "11177:   }",
          "11182: #ifndef LIBRAW_LIBRARY_BUILD",
          "11183:     sfp = ifp;",
          "11189:     }",
          "11190:     ifp = sfp;",
          "11191: #else",
          "11197: #endif",
          "11199:   }",
          "11201:     FORCC cc[i][c] *= ab[i];",
          "11207:   }",
          "11209:     cam_mul[3] = 0;",
          "11210:     FORCC cam_mul[c] = 1 / asn[c];",
          "11211:   }",
          "",
          "[Removed Lines]",
          "10668:  FORC4 cam_mul[c ^ 1] = 4096.0 / get2();",
          "10669:  break;",
          "10671:  fread (software, 1, 7, ifp);",
          "10672:  if (strncmp(software,\"MATRIX\",6)) break;",
          "10673:  colors = 4;",
          "10674:  for (raw_color = i=0; i < 3; i++) {",
          "10675:    FORC4 fscanf (ifp, \"%f\", &rgb_cam[i][c^1]);",
          "10676:    if (!use_camera_wb) continue;",
          "10677:    num = 0;",
          "10678:    FORC4 num += rgb_cam[i][c];",
          "10679:    FORC4 rgb_cam[i][c] /= MAX(1,num);",
          "10680:  }",
          "10681:  break;",
          "10683:  parse_mos (ftell(ifp));",
          "10684:       case 34303:",
          "10685:  strcpy (make, \"Leaf\");",
          "10686:  break;",
          "10688:  fseek (ifp, get4()+base, SEEK_SET);",
          "10689:  parse_exif (base);",
          "10690:  break;",
          "10692:         {",
          "10693:           unsigned pos;",
          "10694:           fseek(ifp, pos = (get4() + base), SEEK_SET);",
          "10695:           parse_gps(base);",
          "10696: #ifdef LIBRAW_LIBRARY_BUILD",
          "10697:           fseek(ifp, pos, SEEK_SET);",
          "10698:           parse_gps_libraw(base);",
          "10699: #endif",
          "10700:         }",
          "10701:  break;",
          "10704:  profile_offset = ftell(ifp);",
          "10705:  profile_length = len;",
          "10706:  break;",
          "10708:  kodak_cbpp = get4();",
          "10709:  break;",
          "10711:  focal_len = getreal(type);",
          "10712:  break;",
          "10714:  shot_order = getint(type);",
          "10715:  break;",
          "10717:  for (raw_color = i=0; i < 3; i++) {",
          "10718:    getreal(type);",
          "10719:    FORC3 rgb_cam[i][c] = getreal(type);",
          "10720:  }",
          "10721:  break;",
          "10722:       case 40976:",
          "10723:  strip_offset = get4();",
          "10724:  switch (tiff_ifd[ifd].comp) {",
          "10725:    case 32770: load_raw = &CLASS samsung_load_raw;   break;",
          "10726:    case 32772: load_raw = &CLASS samsung2_load_raw;  break;",
          "10727:    case 32773: load_raw = &CLASS samsung3_load_raw;  break;",
          "10728:  }",
          "10729:  break;",
          "10731:  strcpy (make, \"Imacon\");",
          "10732:  data_offset = ftell(ifp);",
          "10733:  ima_len = len;",
          "10734:  break;",
          "10735:       case 46279:",
          "10736:  if (!ima_len) break;",
          "10737:  fseek (ifp, 38, SEEK_CUR);",
          "10738:       case 46274:",
          "10739:  fseek (ifp, 40, SEEK_CUR);",
          "10740:  raw_width  = get4();",
          "10741:  raw_height = get4();",
          "10742:  left_margin = get4() & 7;",
          "10743:  width = raw_width - left_margin - (get4() & 7);",
          "10744:  top_margin = get4() & 7;",
          "10745:  height = raw_height - top_margin - (get4() & 7);",
          "10746:  if (raw_width == 7262 && ima_len == 234317952 ) {",
          "10747:    height = 5412;",
          "10748:    width  = 7216;",
          "10749:    left_margin = 7;",
          "10750:           filters=0;",
          "10751:  } else  if (raw_width == 7262) {",
          "10752:    height = 5444;",
          "10753:    width  = 7244;",
          "10754:    left_margin = 7;",
          "10755:  }",
          "10756:  fseek (ifp, 52, SEEK_CUR);",
          "10757:  FORC3 cam_mul[c] = getreal(11);",
          "10758:  fseek (ifp, 114, SEEK_CUR);",
          "10759:  flip = (get2() >> 7) * 90;",
          "10760:  if (width * height * 6 == ima_len) {",
          "10761:    if (flip % 180 == 90) SWAP(width,height);",
          "10762:    raw_width = width;",
          "10763:    raw_height = height;",
          "10764:    left_margin = top_margin = filters = flip = 0;",
          "10765:  }",
          "10766:  sprintf (model, \"Ixpress %d-Mp\", height*width/1000000);",
          "10767:  load_raw = &CLASS imacon_full_load_raw;",
          "10768:  if (filters) {",
          "10769:    if (left_margin & 1) filters = 0x61616161;",
          "10770:    load_raw = &CLASS unpacked_load_raw;",
          "10771:  }",
          "10772:  maximum = 0xffff;",
          "10773:  break;",
          "10775:       case 50455:",
          "10776:  if (len > 2560000 || !(cbuf = (char *) malloc(len))) break;",
          "10778:  fread (cbuf, 1, len, ifp);",
          "10780:  if(fread (cbuf, 1, len, ifp) != len)",
          "10781:   throw LIBRAW_EXCEPTION_IO_CORRUPT; // cbuf to be free'ed in recycle",
          "10782: #endif",
          "10783:         cbuf[len-1] = 0;",
          "10784:  for (cp = cbuf-1; cp && cp < cbuf+len; cp = strchr(cp,'\\n'))",
          "10785:    if (!strncmp (++cp,\"Neutral \",8))",
          "10786:      sscanf (cp+8, \"%f %f %f\", cam_mul, cam_mul+1, cam_mul+2);",
          "10787:  free (cbuf);",
          "10788:  break;",
          "10789:       case 50458:",
          "10790:  if (!make[0]) strcpy (make, \"Hasselblad\");",
          "10791:  break;",
          "10793: #ifdef LIBRAW_LIBRARY_BUILD",
          "10794:         libraw_internal_data.unpacker_data.hasselblad_parser_flag=1;",
          "10795: #endif",
          "10796:  i = order;",
          "10797:  j = ftell(ifp);",
          "10798:  c = tiff_nifds;",
          "10799:  order = get2();",
          "10800:  fseek (ifp, j+(get2(),get4()), SEEK_SET);",
          "10801:  parse_tiff_ifd (j);",
          "10802:  maximum = 0xffff;",
          "10803:  tiff_nifds = c;",
          "10804:  order = i;",
          "10805:  break;",
          "10807:  FORC4 dng_version = (dng_version << 8) + fgetc(ifp);",
          "10808:  if (!make[0]) strcpy (make, \"DNG\");",
          "10809:  is_raw = 1;",
          "10810:  break;",
          "10812: #ifdef LIBRAW_LIBRARY_BUILD",
          "10813:         stmread(imgdata.color.UniqueCameraModel, len, ifp);",
          "10814:         imgdata.color.UniqueCameraModel[sizeof(imgdata.color.UniqueCameraModel)-1] = 0;",
          "10815: #endif",
          "10816:  if (model[0]) break;",
          "10818:  fgets (make, 64, ifp);",
          "10820:         strncpy (make, imgdata.color.UniqueCameraModel, MIN(len, sizeof(imgdata.color.UniqueCameraModel)));",
          "10821: #endif",
          "10822:  if ((cp = strchr(make,' '))) {",
          "10823:    strcpy(model,cp+1);",
          "10825:  }",
          "10826:  break;",
          "10828:  if (filters == 9) break;",
          "10829:  if (len > 4) len = 4;",
          "10830:  colors = len;",
          "10831:  fread (cfa_pc, 1, colors, ifp);",
          "10832: guess_cfa_pc:",
          "10833:         FORCC tab[cfa_pc[c]] = c;",
          "10834:         cdesc[c] = 0;",
          "10835:         for (i=16; i--; )",
          "10836:           filters = filters << 2 | tab[cfa_pat[i % plen]];",
          "10837:         filters -= !filters;",
          "10838:  break;",
          "10840:  if (get2() == 2) fuji_width = 1;",
          "10841:  break;",
          "10842:       case 291:",
          "10844:  linear_table (len);",
          "10845:  break;",
          "10847: #ifdef LIBRAW_LIBRARY_BUILD",
          "10848:         imgdata.color.dng_levels.dng_cblack[4] =",
          "10849: #endif",
          "10850:  cblack[4] = get2();",
          "10851: #ifdef LIBRAW_LIBRARY_BUILD",
          "10852:         imgdata.color.dng_levels.dng_cblack[5] =",
          "10853: #endif",
          "10854:  cblack[5] = get2();",
          "10855:  if (cblack[4] * cblack[5] > (sizeof(cblack) / sizeof (cblack[0]) - 6))",
          "10856: #ifdef LIBRAW_LIBRARY_BUILD",
          "10857:             imgdata.color.dng_levels.dng_cblack[4]=",
          "10858:      imgdata.color.dng_levels.dng_cblack[5]=",
          "10859: #endif",
          "10860:      cblack[4] = cblack[5] = 1;",
          "10861:  break;",
          "10863: #ifdef LIBRAW_LIBRARY_BUILD",
          "10864:  case 0xf00c: {",
          "10865:      unsigned fwb[4];",
          "10866:      FORC4 fwb[c] = get4();",
          "10867:   if (fwb[3] < 0x100)",
          "10868:   {",
          "10869:     imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];",
          "10870:     imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];",
          "10871:     imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];",
          "10872:     if ((fwb[3] == 17) && libraw_internal_data.unpacker_data.lenRAFData>3 && libraw_internal_data.unpacker_data.lenRAFData < 10240000)",
          "10873:     {",
          "10874:       long long f_save = ftell(ifp);",
          "10875:       int fj, found = 0;",
          "10876:       ushort *rafdata = (ushort*) malloc (sizeof(ushort)*libraw_internal_data.unpacker_data.lenRAFData);",
          "10877:       fseek (ifp, libraw_internal_data.unpacker_data.posRAFData, SEEK_SET);",
          "10878:       fread (rafdata, sizeof(ushort), libraw_internal_data.unpacker_data.lenRAFData, ifp);",
          "10879:       fseek(ifp, f_save, SEEK_SET);",
          "10880:       for (int fi=0; fi<(libraw_internal_data.unpacker_data.lenRAFData-3); fi++)",
          "10881:    {",
          "10882:      if ((fwb[0]==rafdata[fi]) && (fwb[1]==rafdata[fi+1]) && (fwb[2]==rafdata[fi+2]))",
          "10883:      {",
          "10884:        if (rafdata[fi-15] != fwb[0]) continue;",
          "10885:        fi = fi - 15;",
          "10886:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][3] = rafdata[fi];",
          "10887:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = rafdata[fi+1];",
          "10888:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = rafdata[fi+2];",
          "10890:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = rafdata[fi+3];",
          "10891:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = rafdata[fi+4];",
          "10892:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = rafdata[fi+5];",
          "10894:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = rafdata[fi+6];",
          "10895:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = rafdata[fi+7];",
          "10896:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = rafdata[fi+8];",
          "10898:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = rafdata[fi+9];",
          "10899:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][0] = rafdata[fi+10];",
          "10900:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][2] = rafdata[fi+11];",
          "10902:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = rafdata[fi+12];",
          "10903:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = rafdata[fi+13];",
          "10904:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = rafdata[fi+14];",
          "10906:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = rafdata[fi+15];",
          "10907:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = rafdata[fi+16];",
          "10908:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = rafdata[fi+17];",
          "10910:                 fi += 111;",
          "10911:                 for (fj = fi; fj<(fi+15); fj+=3)",
          "10912:                   if (rafdata[fj] != rafdata[fi])",
          "10913:                   {",
          "10914:                     found = 1;",
          "10915:                     break;",
          "10916:                   }",
          "10917:                 if (found)",
          "10919:                   int FujiCCT_K [31] = {2500,2550,2650,2700,2800,2850,2950,3000,3100,3200,3300,3400,3600,3700,3800,4000,4200,4300,4500,4800,5000,5300,5600,5900,6300,6700,7100,7700,8300,9100,10000};",
          "10920:                   fj = fj - 93;",
          "10921:                   for (int iCCT=0; iCCT < 31; iCCT++)",
          "10922:                   {",
          "10923:                     imgdata.color.WBCT_Coeffs[iCCT][0] = FujiCCT_K[iCCT];",
          "10924:                     imgdata.color.WBCT_Coeffs[iCCT][1] = rafdata[iCCT*3+1+fj];",
          "10925:                     imgdata.color.WBCT_Coeffs[iCCT][2] = imgdata.color.WBCT_Coeffs[iCCT][4] = rafdata[iCCT*3+fj];",
          "10926:                     imgdata.color.WBCT_Coeffs[iCCT][3] = rafdata[iCCT*3+2+fj];",
          "10927:       }",
          "10928:     }",
          "10929:        free (rafdata);",
          "10930:     break;",
          "10931:      }",
          "10932:    }",
          "10933:     }",
          "10934:   }",
          "10935:   FORC4 fwb[c] = get4();",
          "10936:   if (fwb[3] < 0x100)",
          "10937:   {",
          "10938:     imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];",
          "10939:     imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];",
          "10940:     imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];",
          "10941:   }",
          "10947:       case 50709:",
          "10948:         stmread(imgdata.color.LocalizedCameraModel,len, ifp);",
          "10952:       case 61450:",
          "10953:  cblack[4] = cblack[5] = MIN(sqrt((double)len),64);",
          "10956:  if(tiff_ifd[ifd].samples > 1  && tiff_ifd[ifd].samples == len) // LinearDNG, per-channel black",
          "10957:    {",
          "10958:      for(i=0; i < colors && i < 4 && i < len; i++)",
          "10959:        imgdata.color.dng_levels.dng_cblack[i]=",
          "10960:          cblack[i]=",
          "10961:     getreal(type)+0.5;",
          "10963:      imgdata.color.dng_levels.dng_black= black = 0;",
          "10964:    }",
          "10965:  else",
          "10967:    if((cblack[4] * cblack[5] < 2) && len == 1)",
          "10968:      {",
          "10970:        imgdata.color.dng_levels.dng_black=",
          "10972:          black =",
          "10973:     getreal(type);",
          "10974:      }",
          "10975:    else if(cblack[4] * cblack[5] <= len)",
          "10976:      {",
          "10977:        FORC (cblack[4] * cblack[5])",
          "10978:   cblack[6+c] = getreal(type);",
          "10979:        black = 0;",
          "10980:        FORC4",
          "10981:   cblack[c] = 0;",
          "10984:               if(tag == 50714)",
          "10985:        {",
          "10986:          FORC (cblack[4] * cblack[5])",
          "10987:            imgdata.color.dng_levels.dng_cblack[6+c]= cblack[6+c];",
          "10988:          imgdata.color.dng_levels.dng_black=0;",
          "10989:          FORC4",
          "10990:            imgdata.color.dng_levels.dng_cblack[c]= 0;",
          "10991:        }",
          "10993:      }",
          "10997:  for (num=i=0; i < len && i < 65536; i++)",
          "10998:    num += getreal(type);",
          "10999:  black += num/len + 0.5;",
          "11001:  imgdata.color.dng_levels.dng_black += num/len + 0.5;",
          "11003:  break;",
          "11006:  imgdata.color.dng_levels.dng_whitelevel[0]=",
          "11008:  maximum = getint(type);",
          "11010:  if(tiff_ifd[ifd].samples > 1 ) // Linear DNG case",
          "11011:   for(i=1; i < colors && i < 4 && i < len; i++)",
          "11012:    imgdata.color.dng_levels.dng_whitelevel[i]=getint(type);",
          "11014:  break;",
          "11016:  pixel_aspect  = getreal(type);",
          "11017:  pixel_aspect /= getreal(type);",
          "11018:  if(pixel_aspect > 0.995 && pixel_aspect < 1.005)",
          "11019:           pixel_aspect = 1.0;",
          "11020:  break;",
          "11022:       case 50778:",
          "11023:         imgdata.color.dng_color[0].illuminant = get2();",
          "11024:         break;",
          "11025:       case 50779:",
          "11026:         imgdata.color.dng_color[1].illuminant = get2();",
          "11027:         break;",
          "11032:         i = tag == 50721?0:1;",
          "11034:  FORCC for (j=0; j < 3; j++)",
          "11035:           {",
          "11037:           imgdata.color.dng_color[i].colormatrix[c][j]=",
          "11039:    cm[c][j] = getreal(type);",
          "11040:           }",
          "11041:  use_cm = 1;",
          "11042:  break;",
          "11047:         i = tag == 0xc714?0:1;",
          "11049:  for (j=0; j < 3; j++)",
          "11050:    FORCC",
          "11051:             {",
          "11053:               imgdata.color.dng_color[i].forwardmatrix[j][c]=",
          "11056:             }",
          "11057:  break;",
          "11062:         j = tag == 50723?0:1;",
          "11064:  for (i=0; i < colors; i++)",
          "11065:    FORCC",
          "11066:             {",
          "11068:               imgdata.color.dng_color[j].calibration[i][c]=",
          "11071:             }",
          "11072:  break;",
          "11074:  FORCC{",
          "11075: #ifdef LIBRAW_LIBRARY_BUILD",
          "11076:               imgdata.color.dng_levels.analogbalance[c]=",
          "11077: #endif",
          "11078:        ab[c] = getreal(type);",
          "11079:  }",
          "11080:  break;",
          "11082:  FORCC asn[c] = getreal(type);",
          "11083:  break;",
          "11085:  xyz[0] = getreal(type);",
          "11086:  xyz[1] = getreal(type);",
          "11087:  xyz[2] = 1 - xyz[0] - xyz[1];",
          "11088:  FORC3 xyz[c] /= d65_white[c];",
          "11089:  break;",
          "11090: #ifdef LIBRAW_LIBRARY_BUILD",
          "11092:         baseline_exposure = getreal(type);",
          "11093:         break;",
          "11099:         char mbuf[64];",
          "11100:         unsigned short makernote_found = 0;",
          "11101:         INT64 curr_pos, start_pos = ftell(ifp);",
          "11102:         unsigned MakN_order, m_sorder = order;",
          "11103:         unsigned MakN_length;",
          "11104:         unsigned pos_in_original_raw;",
          "11105:         fread(mbuf, 1, 6, ifp);",
          "11107:         if (!strcmp(mbuf, \"Adobe\"))",
          "11108:           {",
          "11109:             order = 0x4d4d;    // Adobe header is always in \"MM\" / big endian",
          "11110:             curr_pos = start_pos + 6;",
          "11111:             while (curr_pos + 8 - start_pos <= len)",
          "11112:               {",
          "11113:                 fread(mbuf, 1, 4, ifp);",
          "11114:                 curr_pos += 8;",
          "11115:                 if (!strncmp(mbuf, \"MakN\", 4)) {",
          "11116:                   makernote_found = 1;",
          "11117:                 MakN_length = get4();",
          "11118:                 MakN_order = get2();",
          "11119:                 pos_in_original_raw = get4();",
          "11120:                 order = MakN_order;",
          "11121:                 parse_makernote_0xc634(curr_pos + 6 - pos_in_original_raw, 0, AdobeDNG);",
          "11122:                 break;",
          "11123:                 }",
          "11124:               }",
          "11125:           }",
          "11126:         else",
          "11128:             fread(mbuf + 6, 1, 2, ifp);",
          "11129:             if (!strcmp(mbuf, \"PENTAX \") ||",
          "11130:                 !strcmp(mbuf, \"SAMSUNG\"))",
          "11131:               {",
          "11132:                 makernote_found = 1;",
          "11133:                 fseek(ifp, start_pos, SEEK_SET);",
          "11134:                 parse_makernote_0xc634(base, 0, CameraDNG);",
          "11135:               }",
          "11138:         fseek(ifp, start_pos, SEEK_SET);",
          "11139:         order = m_sorder;",
          "11143:       if (dng_version) break;",
          "11144:       parse_minolta (j = get4()+base);",
          "11145:       fseek (ifp, j, SEEK_SET);",
          "11146:       parse_tiff_ifd (base);",
          "11149:       read_shorts (cr2_slice, 3);",
          "11158:       for (i=0; i < len && i < 32; i++)",
          "11159:         ((int*)mask)[i] = getint(type);",
          "11166:       if (len < 13) break;",
          "11167:       fseek (ifp, 16, SEEK_CUR);",
          "11169:       fseek (ifp, 28, SEEK_CUR);",
          "11174:       if (type == 2) fgets (model2, 64, ifp);",
          "11176:     fseek (ifp, save, SEEK_SET);",
          "11178:   if (sony_length && sony_length < 10240000 && (buf = (unsigned *) malloc(sony_length))) {",
          "11179:     fseek (ifp, sony_offset, SEEK_SET);",
          "11180:     fread (buf, sony_length, 1, ifp);",
          "11181:     sony_decrypt (buf, sony_length/4, 1, sony_key);",
          "11184:     if ((ifp = tmpfile())) {",
          "11185:       fwrite (buf, sony_length, 1, ifp);",
          "11186:       fseek (ifp, 0, SEEK_SET);",
          "11187:       parse_tiff_ifd (-sony_offset);",
          "11188:       fclose (ifp);",
          "11192:     if( !ifp->tempbuffer_open(buf,sony_length))",
          "11193:         {",
          "11194:             parse_tiff_ifd(-sony_offset);",
          "11195:             ifp->tempbuffer_close();",
          "11196:         }",
          "11198:     free (buf);",
          "11200:   for (i=0; i < colors; i++)",
          "11202:   if (use_cm) {",
          "11203:     FORCC for (i=0; i < 3; i++)",
          "11204:       for (cam_xyz[c][i]=j=0; j < colors; j++)",
          "11205:  cam_xyz[c][i] += cc[c][j] * cm[j][i] * xyz[i];",
          "11206:     cam_xyz_coeff (cmatrix, cam_xyz);",
          "11208:   if (asn[0]) {",
          "",
          "[Added Lines]",
          "11709:       FORC4 cam_mul[c ^ 1] = 4096.0 / get2();",
          "11710:       break;",
          "11712:       fread(software, 1, 7, ifp);",
          "11713:       if (strncmp(software, \"MATRIX\", 6))",
          "11714:         break;",
          "11715:       colors = 4;",
          "11716:       for (raw_color = i = 0; i < 3; i++)",
          "11717:       {",
          "11718:         FORC4 fscanf(ifp, \"%f\", &rgb_cam[i][c ^ 1]);",
          "11719:         if (!use_camera_wb)",
          "11720:           continue;",
          "11721:         num = 0;",
          "11722:         FORC4 num += rgb_cam[i][c];",
          "11723:         FORC4 rgb_cam[i][c] /= MAX(1, num);",
          "11724:       }",
          "11725:       break;",
          "11727:       parse_mos(ftell(ifp));",
          "11728:     case 34303:",
          "11729:       strcpy(make, \"Leaf\");",
          "11730:       break;",
          "11732:       fseek(ifp, get4() + base, SEEK_SET);",
          "11733:       parse_exif(base);",
          "11734:       break;",
          "11736:     {",
          "11737:       unsigned pos;",
          "11738:       fseek(ifp, pos = (get4() + base), SEEK_SET);",
          "11739:       parse_gps(base);",
          "11740: #ifdef LIBRAW_LIBRARY_BUILD",
          "11741:       fseek(ifp, pos, SEEK_SET);",
          "11742:       parse_gps_libraw(base);",
          "11743: #endif",
          "11744:     }",
          "11745:     break;",
          "11748:       profile_offset = ftell(ifp);",
          "11749:       profile_length = len;",
          "11750:       break;",
          "11752:       kodak_cbpp = get4();",
          "11753:       break;",
          "11755:       focal_len = getreal(type);",
          "11756:       break;",
          "11758:       shot_order = getint(type);",
          "11759:       break;",
          "11761:       for (raw_color = i = 0; i < 3; i++)",
          "11762:       {",
          "11763:         getreal(type);",
          "11764:         FORC3 rgb_cam[i][c] = getreal(type);",
          "11765:       }",
          "11766:       break;",
          "11767:     case 40976:",
          "11768:       strip_offset = get4();",
          "11769:       switch (tiff_ifd[ifd].comp)",
          "11770:       {",
          "11771:       case 32770:",
          "11772:         load_raw = &CLASS samsung_load_raw;",
          "11773:         break;",
          "11774:       case 32772:",
          "11775:         load_raw = &CLASS samsung2_load_raw;",
          "11776:         break;",
          "11777:       case 32773:",
          "11778:         load_raw = &CLASS samsung3_load_raw;",
          "11779:         break;",
          "11780:       }",
          "11781:       break;",
          "11783:       strcpy(make, \"Imacon\");",
          "11784:       data_offset = ftell(ifp);",
          "11785:       ima_len = len;",
          "11786:       break;",
          "11787:     case 46279:",
          "11788:       if (!ima_len)",
          "11789:         break;",
          "11790:       fseek(ifp, 38, SEEK_CUR);",
          "11791:     case 46274:",
          "11792:       fseek(ifp, 40, SEEK_CUR);",
          "11793:       raw_width = get4();",
          "11794:       raw_height = get4();",
          "11795:       left_margin = get4() & 7;",
          "11796:       width = raw_width - left_margin - (get4() & 7);",
          "11797:       top_margin = get4() & 7;",
          "11798:       height = raw_height - top_margin - (get4() & 7);",
          "11799:       if (raw_width == 7262 && ima_len == 234317952)",
          "11800:       {",
          "11801:         height = 5412;",
          "11802:         width = 7216;",
          "11803:         left_margin = 7;",
          "11804:         filters = 0;",
          "11805:       }",
          "11806:       else if (raw_width == 7262)",
          "11807:       {",
          "11808:         height = 5444;",
          "11809:         width = 7244;",
          "11810:         left_margin = 7;",
          "11811:       }",
          "11812:       fseek(ifp, 52, SEEK_CUR);",
          "11813:       FORC3 cam_mul[c] = getreal(11);",
          "11814:       fseek(ifp, 114, SEEK_CUR);",
          "11815:       flip = (get2() >> 7) * 90;",
          "11816:       if (width * height * 6 == ima_len)",
          "11817:       {",
          "11818:         if (flip % 180 == 90)",
          "11819:           SWAP(width, height);",
          "11820:         raw_width = width;",
          "11821:         raw_height = height;",
          "11822:         left_margin = top_margin = filters = flip = 0;",
          "11823:       }",
          "11824:       sprintf(model, \"Ixpress %d-Mp\", height * width / 1000000);",
          "11825:       load_raw = &CLASS imacon_full_load_raw;",
          "11826:       if (filters)",
          "11827:       {",
          "11828:         if (left_margin & 1)",
          "11829:           filters = 0x61616161;",
          "11830:         load_raw = &CLASS unpacked_load_raw;",
          "11831:       }",
          "11832:       maximum = 0xffff;",
          "11833:       break;",
          "11835:     case 50455:",
          "11836:       if (len > 2560000 || !(cbuf = (char *)malloc(len)))",
          "11837:         break;",
          "11839:       fread(cbuf, 1, len, ifp);",
          "11841:       if (fread(cbuf, 1, len, ifp) != len)",
          "11842:         throw LIBRAW_EXCEPTION_IO_CORRUPT; // cbuf to be free'ed in recycle",
          "11843: #endif",
          "11844:       cbuf[len - 1] = 0;",
          "11845:       for (cp = cbuf - 1; cp && cp < cbuf + len; cp = strchr(cp, '\\n'))",
          "11846:         if (!strncmp(++cp, \"Neutral \", 8))",
          "11847:           sscanf(cp + 8, \"%f %f %f\", cam_mul, cam_mul + 1, cam_mul + 2);",
          "11848:       free(cbuf);",
          "11849:       break;",
          "11850:     case 50458:",
          "11851:       if (!make[0])",
          "11852:         strcpy(make, \"Hasselblad\");",
          "11853:       break;",
          "11855: #ifdef LIBRAW_LIBRARY_BUILD",
          "11856:       libraw_internal_data.unpacker_data.hasselblad_parser_flag = 1;",
          "11857: #endif",
          "11858:       i = order;",
          "11859:       j = ftell(ifp);",
          "11860:       c = tiff_nifds;",
          "11861:       order = get2();",
          "11862:       fseek(ifp, j + (get2(), get4()), SEEK_SET);",
          "11863:       parse_tiff_ifd(j);",
          "11864:       maximum = 0xffff;",
          "11865:       tiff_nifds = c;",
          "11866:       order = i;",
          "11867:       break;",
          "11869:       FORC4 dng_version = (dng_version << 8) + fgetc(ifp);",
          "11870:       if (!make[0])",
          "11871:         strcpy(make, \"DNG\");",
          "11872:       is_raw = 1;",
          "11873:       break;",
          "11875: #ifdef LIBRAW_LIBRARY_BUILD",
          "11876:       stmread(imgdata.color.UniqueCameraModel, len, ifp);",
          "11877:       imgdata.color.UniqueCameraModel[sizeof(imgdata.color.UniqueCameraModel) - 1] = 0;",
          "11878: #endif",
          "11879:       if (model[0])",
          "11880:         break;",
          "11882:       fgets(make, 64, ifp);",
          "11884:       strncpy(make, imgdata.color.UniqueCameraModel, MIN(len, sizeof(imgdata.color.UniqueCameraModel)));",
          "11885: #endif",
          "11886:       if ((cp = strchr(make, ' ')))",
          "11887:       {",
          "11888:         strcpy(model, cp + 1);",
          "11890:       }",
          "11891:       break;",
          "11893:       if (filters == 9)",
          "11894:         break;",
          "11895:       if (len > 4)",
          "11896:         len = 4;",
          "11897:       colors = len;",
          "11898:       fread(cfa_pc, 1, colors, ifp);",
          "11899:     guess_cfa_pc:",
          "11900:       FORCC tab[cfa_pc[c]] = c;",
          "11901:       cdesc[c] = 0;",
          "11902:       for (i = 16; i--;)",
          "11903:         filters = filters << 2 | tab[cfa_pat[i % plen]];",
          "11904:       filters -= !filters;",
          "11905:       break;",
          "11907:       if (get2() == 2)",
          "11908:         fuji_width = 1;",
          "11909:       break;",
          "11910:     case 291:",
          "11912:       linear_table(len);",
          "11913:       break;",
          "11915: #ifdef LIBRAW_LIBRARY_BUILD",
          "11916:       imgdata.color.dng_levels.dng_cblack[4] =",
          "11917: #endif",
          "11918:           cblack[4] = get2();",
          "11919: #ifdef LIBRAW_LIBRARY_BUILD",
          "11920:       imgdata.color.dng_levels.dng_cblack[5] =",
          "11921: #endif",
          "11922:           cblack[5] = get2();",
          "11923:       if (cblack[4] * cblack[5] > (sizeof(cblack) / sizeof(cblack[0]) - 6))",
          "11924: #ifdef LIBRAW_LIBRARY_BUILD",
          "11925:         imgdata.color.dng_levels.dng_cblack[4] = imgdata.color.dng_levels.dng_cblack[5] =",
          "11926: #endif",
          "11927:             cblack[4] = cblack[5] = 1;",
          "11928:       break;",
          "11930: #ifdef LIBRAW_LIBRARY_BUILD",
          "11931:     case 0xf00c:",
          "11932:     {",
          "11933:       unsigned fwb[4];",
          "11934:       FORC4 fwb[c] = get4();",
          "11935:       if (fwb[3] < 0x100)",
          "11936:       {",
          "11937:         imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];",
          "11938:         imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];",
          "11939:         imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];",
          "11940:         if ((fwb[3] == 17) && libraw_internal_data.unpacker_data.lenRAFData > 3 &&",
          "11941:             libraw_internal_data.unpacker_data.lenRAFData < 10240000)",
          "11942:         {",
          "11943:           long long f_save = ftell(ifp);",
          "11944:           int fj, found = 0;",
          "11945:           ushort *rafdata = (ushort *)malloc(sizeof(ushort) * libraw_internal_data.unpacker_data.lenRAFData);",
          "11946:           fseek(ifp, libraw_internal_data.unpacker_data.posRAFData, SEEK_SET);",
          "11947:           fread(rafdata, sizeof(ushort), libraw_internal_data.unpacker_data.lenRAFData, ifp);",
          "11948:           fseek(ifp, f_save, SEEK_SET);",
          "11949:           for (int fi = 0; fi < (libraw_internal_data.unpacker_data.lenRAFData - 3); fi++)",
          "11950:           {",
          "11951:             if ((fwb[0] == rafdata[fi]) && (fwb[1] == rafdata[fi + 1]) && (fwb[2] == rafdata[fi + 2]))",
          "11952:             {",
          "11953:               if (rafdata[fi - 15] != fwb[0])",
          "11954:                 continue;",
          "11955:               fi = fi - 15;",
          "11956:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][3] =",
          "11957:                   rafdata[fi];",
          "11958:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = rafdata[fi + 1];",
          "11959:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = rafdata[fi + 2];",
          "11961:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =",
          "11962:                   rafdata[fi + 3];",
          "11963:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = rafdata[fi + 4];",
          "11964:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = rafdata[fi + 5];",
          "11966:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =",
          "11967:                   rafdata[fi + 6];",
          "11968:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = rafdata[fi + 7];",
          "11969:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = rafdata[fi + 8];",
          "11971:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] =",
          "11972:                   rafdata[fi + 9];",
          "11973:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][0] = rafdata[fi + 10];",
          "11974:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][2] = rafdata[fi + 11];",
          "11976:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =",
          "11977:                   rafdata[fi + 12];",
          "11978:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = rafdata[fi + 13];",
          "11979:               imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = rafdata[fi + 14];",
          "11981:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =",
          "11982:                   rafdata[fi + 15];",
          "11983:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = rafdata[fi + 16];",
          "11984:               imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = rafdata[fi + 17];",
          "11986:               fi += 111;",
          "11987:               for (fj = fi; fj < (fi + 15); fj += 3)",
          "11988:                 if (rafdata[fj] != rafdata[fi])",
          "11990:                   found = 1;",
          "11991:                   break;",
          "11992:                 }",
          "11993:               if (found)",
          "11994:               {",
          "11995:                 int FujiCCT_K[31] = {2500, 2550, 2650, 2700, 2800, 2850, 2950, 3000, 3100, 3200, 3300,",
          "11996:                                      3400, 3600, 3700, 3800, 4000, 4200, 4300, 4500, 4800, 5000, 5300,",
          "11997:                                      5600, 5900, 6300, 6700, 7100, 7700, 8300, 9100, 10000};",
          "11998:                 fj = fj - 93;",
          "11999:                 for (int iCCT = 0; iCCT < 31; iCCT++)",
          "12000:                 {",
          "12001:                   imgdata.color.WBCT_Coeffs[iCCT][0] = FujiCCT_K[iCCT];",
          "12002:                   imgdata.color.WBCT_Coeffs[iCCT][1] = rafdata[iCCT * 3 + 1 + fj];",
          "12003:                   imgdata.color.WBCT_Coeffs[iCCT][2] = imgdata.color.WBCT_Coeffs[iCCT][4] = rafdata[iCCT * 3 + fj];",
          "12004:                   imgdata.color.WBCT_Coeffs[iCCT][3] = rafdata[iCCT * 3 + 2 + fj];",
          "12005:                 }",
          "12006:               }",
          "12007:               free(rafdata);",
          "12008:               break;",
          "12009:             }",
          "12010:           }",
          "12011:         }",
          "12012:       }",
          "12013:       FORC4 fwb[c] = get4();",
          "12014:       if (fwb[3] < 0x100)",
          "12015:       {",
          "12016:         imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];",
          "12017:         imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];",
          "12018:         imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];",
          "12019:       }",
          "12025:     case 50709:",
          "12026:       stmread(imgdata.color.LocalizedCameraModel, len, ifp);",
          "12030:     case 61450:",
          "12031:       cblack[4] = cblack[5] = MIN(sqrt((double)len), 64);",
          "12034:       if (tiff_ifd[ifd].samples > 1 && tiff_ifd[ifd].samples == len) // LinearDNG, per-channel black",
          "12035:       {",
          "12036:         for (i = 0; i < colors && i < 4 && i < len; i++)",
          "12037:           imgdata.color.dng_levels.dng_cblack[i] = cblack[i] = getreal(type) + 0.5;",
          "12039:         imgdata.color.dng_levels.dng_black = black = 0;",
          "12040:       }",
          "12041:       else",
          "12043:           if ((cblack[4] * cblack[5] < 2) && len == 1)",
          "12044:       {",
          "12046:         imgdata.color.dng_levels.dng_black =",
          "12048:             black = getreal(type);",
          "12049:       }",
          "12050:       else if (cblack[4] * cblack[5] <= len)",
          "12051:       {",
          "12052:         FORC(cblack[4] * cblack[5])",
          "12053:         cblack[6 + c] = getreal(type);",
          "12054:         black = 0;",
          "12055:         FORC4",
          "12056:         cblack[c] = 0;",
          "12059:         if (tag == 50714)",
          "12060:         {",
          "12061:           FORC(cblack[4] * cblack[5])",
          "12062:           imgdata.color.dng_levels.dng_cblack[6 + c] = cblack[6 + c];",
          "12063:           imgdata.color.dng_levels.dng_black = 0;",
          "12064:           FORC4",
          "12065:           imgdata.color.dng_levels.dng_cblack[c] = 0;",
          "12066:         }",
          "12068:       }",
          "12072:       for (num = i = 0; i < len && i < 65536; i++)",
          "12073:         num += getreal(type);",
          "12074:       black += num / len + 0.5;",
          "12076:       imgdata.color.dng_levels.dng_black += num / len + 0.5;",
          "12078:       break;",
          "12081:       imgdata.color.dng_levels.dng_whitelevel[0] =",
          "12083:           maximum = getint(type);",
          "12085:       if (tiff_ifd[ifd].samples > 1) // Linear DNG case",
          "12086:         for (i = 1; i < colors && i < 4 && i < len; i++)",
          "12087:           imgdata.color.dng_levels.dng_whitelevel[i] = getint(type);",
          "12089:       break;",
          "12091:       pixel_aspect = getreal(type);",
          "12092:       pixel_aspect /= getreal(type);",
          "12093:       if (pixel_aspect > 0.995 && pixel_aspect < 1.005)",
          "12094:         pixel_aspect = 1.0;",
          "12095:       break;",
          "12097:     case 50778:",
          "12098:       imgdata.color.dng_color[0].illuminant = get2();",
          "12099:       break;",
          "12100:     case 50779:",
          "12101:       imgdata.color.dng_color[1].illuminant = get2();",
          "12102:       break;",
          "12107:       i = tag == 50721 ? 0 : 1;",
          "12109:       FORCC for (j = 0; j < 3; j++)",
          "12110:       {",
          "12112:         imgdata.color.dng_color[i].colormatrix[c][j] =",
          "12114:             cm[c][j] = getreal(type);",
          "12115:       }",
          "12116:       use_cm = 1;",
          "12117:       break;",
          "12122:       i = tag == 0xc714 ? 0 : 1;",
          "12124:       for (j = 0; j < 3; j++)",
          "12125:         FORCC",
          "12126:         {",
          "12128:           imgdata.color.dng_color[i].forwardmatrix[j][c] =",
          "12131:         }",
          "12132:       break;",
          "12137:       j = tag == 50723 ? 0 : 1;",
          "12139:       for (i = 0; i < colors; i++)",
          "12140:         FORCC",
          "12141:         {",
          "12143:           imgdata.color.dng_color[j].calibration[i][c] =",
          "12146:         }",
          "12147:       break;",
          "12149:       FORCC",
          "12150:       {",
          "12151: #ifdef LIBRAW_LIBRARY_BUILD",
          "12152:         imgdata.color.dng_levels.analogbalance[c] =",
          "12154:             ab[c] = getreal(type);",
          "12155:       }",
          "12156:       break;",
          "12158:       FORCC asn[c] = getreal(type);",
          "12159:       break;",
          "12161:       xyz[0] = getreal(type);",
          "12162:       xyz[1] = getreal(type);",
          "12163:       xyz[2] = 1 - xyz[0] - xyz[1];",
          "12164:       FORC3 xyz[c] /= d65_white[c];",
          "12165:       break;",
          "12168:       baseline_exposure = getreal(type);",
          "12169:       break;",
          "12170: #endif",
          "12173: #ifdef LIBRAW_LIBRARY_BUILD",
          "12174:     {",
          "12175:       char mbuf[64];",
          "12176:       unsigned short makernote_found = 0;",
          "12177:       INT64 curr_pos, start_pos = ftell(ifp);",
          "12178:       unsigned MakN_order, m_sorder = order;",
          "12179:       unsigned MakN_length;",
          "12180:       unsigned pos_in_original_raw;",
          "12181:       fread(mbuf, 1, 6, ifp);",
          "12183:       if (!strcmp(mbuf, \"Adobe\"))",
          "12185:         order = 0x4d4d; // Adobe header is always in \"MM\" / big endian",
          "12186:         curr_pos = start_pos + 6;",
          "12187:         while (curr_pos + 8 - start_pos <= len)",
          "12188:         {",
          "12189:           fread(mbuf, 1, 4, ifp);",
          "12190:           curr_pos += 8;",
          "12191:           if (!strncmp(mbuf, \"MakN\", 4))",
          "12193:             makernote_found = 1;",
          "12194:             MakN_length = get4();",
          "12195:             MakN_order = get2();",
          "12196:             pos_in_original_raw = get4();",
          "12197:             order = MakN_order;",
          "12198:             parse_makernote_0xc634(curr_pos + 6 - pos_in_original_raw, 0, AdobeDNG);",
          "12199:             break;",
          "12201:         }",
          "12203:       else",
          "12204:       {",
          "12205:         fread(mbuf + 6, 1, 2, ifp);",
          "12206:         if (!strcmp(mbuf, \"PENTAX \") || !strcmp(mbuf, \"SAMSUNG\"))",
          "12207:         {",
          "12208:           makernote_found = 1;",
          "12209:           fseek(ifp, start_pos, SEEK_SET);",
          "12210:           parse_makernote_0xc634(base, 0, CameraDNG);",
          "12211:         }",
          "12212:       }",
          "12214:       fseek(ifp, start_pos, SEEK_SET);",
          "12215:       order = m_sorder;",
          "12216:     }",
          "12219:       if (dng_version)",
          "12220:         break;",
          "12221:       parse_minolta(j = get4() + base);",
          "12222:       fseek(ifp, j, SEEK_SET);",
          "12223:       parse_tiff_ifd(base);",
          "12226:       read_shorts(cr2_slice, 3);",
          "12235:       for (i = 0; i < len && i < 32; i++)",
          "12236:         ((int *)mask)[i] = getint(type);",
          "12243:       if (len < 13)",
          "12244:         break;",
          "12245:       fseek(ifp, 16, SEEK_CUR);",
          "12247:       fseek(ifp, 28, SEEK_CUR);",
          "12252:       if (type == 2)",
          "12253:         fgets(model2, 64, ifp);",
          "12255:     fseek(ifp, save, SEEK_SET);",
          "12257:   if (sony_length && sony_length < 10240000 && (buf = (unsigned *)malloc(sony_length)))",
          "12258:   {",
          "12259:     fseek(ifp, sony_offset, SEEK_SET);",
          "12260:     fread(buf, sony_length, 1, ifp);",
          "12261:     sony_decrypt(buf, sony_length / 4, 1, sony_key);",
          "12264:     if ((ifp = tmpfile()))",
          "12265:     {",
          "12266:       fwrite(buf, sony_length, 1, ifp);",
          "12267:       fseek(ifp, 0, SEEK_SET);",
          "12268:       parse_tiff_ifd(-sony_offset);",
          "12269:       fclose(ifp);",
          "12273:     if (!ifp->tempbuffer_open(buf, sony_length))",
          "12274:     {",
          "12275:       parse_tiff_ifd(-sony_offset);",
          "12276:       ifp->tempbuffer_close();",
          "12277:     }",
          "12279:     free(buf);",
          "12281:   for (i = 0; i < colors; i++)",
          "12283:   if (use_cm)",
          "12284:   {",
          "12285:     FORCC for (i = 0; i < 3; i++) for (cam_xyz[c][i] = j = 0; j < colors; j++) cam_xyz[c][i] +=",
          "12286:         cc[c][j] * cm[j][i] * xyz[i];",
          "12287:     cam_xyz_coeff(cmatrix, cam_xyz);",
          "12289:   if (asn[0])",
          "12290:   {",
          "",
          "---------------",
          "--- Hunk 91 ---",
          "[Context before]",
          "11214:   return 0;",
          "11215: }",
          "11218: {",
          "11219:   int doff;",
          "11221:   order = get2();",
          "11223:   get2();",
          "11227:   }",
          "11228:   return 1;",
          "11229: }",
          "11231: void CLASS apply_tiff()",
          "11232: {",
          "11234:   struct jhead jh;",
          "11236:   thumb_misc = 16;",
          "11246:     }",
          "11247:   }",
          "11249:     if (tiff_ifd[i].t_shutter)",
          "11250:       shutter = tiff_ifd[i].t_shutter;",
          "11251:     tiff_ifd[i].t_shutter = shutter;",
          "11252:   }",
          "11254:     if (max_samp < tiff_ifd[i].samples)",
          "11262:     }",
          "11263:     if ((tiff_ifd[i].comp != 6 || tiff_ifd[i].samples != 3) &&",
          "11271:       tiff_compress = tiff_ifd[i].comp;",
          "11273: #ifdef LIBRAW_LIBRARY_BUILD",
          "11275: #endif",
          "11281:       raw = i;",
          "11282:     }",
          "11283:   }",
          "11289:   if (raw >= 0 && !load_raw)",
          "11311: #ifdef LIBRAW_LIBRARY_BUILD",
          "11321:           {",
          "11325:             break;",
          "11326:           }",
          "11327: #endif",
          "11405:     }",
          "11406:   if (!dng_version)",
          "11413:       is_raw = 0;",
          "11425:       thumb_height = tiff_ifd[i].t_height;",
          "11426:       thumb_offset = tiff_ifd[i].offset;",
          "11427:       thumb_length = tiff_ifd[i].bytes;",
          "11429:       thm = i;",
          "11430:     }",
          "11432:     thumb_misc |= tiff_ifd[thm].samples << 5;",
          "11448:     }",
          "11449:   }",
          "11450: }",
          "11453: {",
          "11459:   order = fgetc(ifp) * 0x101;",
          "11460:   offset = base + get4() + 8;",
          "11463:       tag = tag << 8 | fgetc(ifp);",
          "11464:     len = get4();",
          "11474:     {",
          "11475:       fseek(ifp, 8, SEEK_CUR);",
          "11486:       get4();",
          "11517:   }",
          "11518:   raw_height = high;",
          "11520:   order = sorder;",
          "11521: }",
          "",
          "[Removed Lines]",
          "11217: int CLASS parse_tiff (int base)",
          "11220:   fseek (ifp, base, SEEK_SET);",
          "11222:   if (order != 0x4949 && order != 0x4d4d) return 0;",
          "11224:   while ((doff = get4())) {",
          "11225:     fseek (ifp, doff+base, SEEK_SET);",
          "11226:     if (parse_tiff_ifd (base)) break;",
          "11233:   int max_samp=0, ties=0, os, ns, raw=-1, thm=-1, i;",
          "11237:   if (thumb_offset) {",
          "11238:     fseek (ifp, thumb_offset, SEEK_SET);",
          "11239:     if (ljpeg_start (&jh, 1)) {",
          "11240:       if((unsigned)jh.bits<17 && (unsigned)jh.wide < 0x10000 && (unsigned)jh.high < 0x10000)",
          "11241:         {",
          "11242:           thumb_misc   = jh.bits;",
          "11243:           thumb_width  = jh.wide;",
          "11244:           thumb_height = jh.high;",
          "11245:         }",
          "11248:   for (i=tiff_nifds; i--; ) {",
          "11253:   for (i=0; i < tiff_nifds; i++) {",
          "11255:  max_samp = tiff_ifd[i].samples;",
          "11256:     if (max_samp > 3) max_samp = 3;",
          "11257:     os = raw_width*raw_height;",
          "11258:     ns = tiff_ifd[i].t_width*tiff_ifd[i].t_height;",
          "11259:     if (tiff_bps) {",
          "11260:         os *= tiff_bps;",
          "11261:         ns *= tiff_ifd[i].bps;",
          "11264:  unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&",
          "11265:         (unsigned)tiff_ifd[i].bps < 33 && (unsigned)tiff_ifd[i].samples < 13 &&",
          "11266:   ns && ((ns > os && (ties = 1)) ||",
          "11267:   (ns == os && shot_select == ties++))) {",
          "11268:       raw_width     = tiff_ifd[i].t_width;",
          "11269:       raw_height    = tiff_ifd[i].t_height;",
          "11270:       tiff_bps      = tiff_ifd[i].bps;",
          "11272:       data_offset   = tiff_ifd[i].offset;",
          "11274:       data_size     = tiff_ifd[i].bytes;",
          "11276:       tiff_flip     = tiff_ifd[i].t_flip;",
          "11277:       tiff_samples  = tiff_ifd[i].samples;",
          "11278:       tile_width    = tiff_ifd[i].t_tile_width;",
          "11279:       tile_length   = tiff_ifd[i].t_tile_length;",
          "11280:       shutter       = tiff_ifd[i].t_shutter;",
          "11284:   if (is_raw == 1 && ties) is_raw = ties;",
          "11285:   if (!tile_width ) tile_width  = INT_MAX;",
          "11286:   if (!tile_length) tile_length = INT_MAX;",
          "11287:   for (i=tiff_nifds; i--; )",
          "11288:     if (tiff_ifd[i].t_flip) tiff_flip = tiff_ifd[i].t_flip;",
          "11290:     switch (tiff_compress) {",
          "11291:       case 32767:",
          "11292:  if (tiff_ifd[raw].bytes == raw_width*raw_height) {",
          "11293:    tiff_bps = 12;",
          "11294:    load_raw = &CLASS sony_arw2_load_raw;   break;",
          "11295:  }",
          "11296:  if (!strncasecmp(make,\"Sony\",4) &&",
          "11297:      tiff_ifd[raw].bytes == raw_width*raw_height*2) {",
          "11298:    tiff_bps = 14;",
          "11299:    load_raw = &CLASS unpacked_load_raw;   break;",
          "11300:  }",
          "11301:  if (tiff_ifd[raw].bytes*8 != raw_width*raw_height*tiff_bps) {",
          "11302:    raw_height += 8;",
          "11303:    load_raw = &CLASS sony_arw_load_raw;   break;",
          "11304:  }",
          "11305:  load_flags = 79;",
          "11306:       case 32769:",
          "11307:  load_flags++;",
          "11308:       case 32770:",
          "11309:       case 32773: goto slr;",
          "11310:       case 0:  case 1:",
          "11313:         if(!strncasecmp(make,\"Sony\",4) &&",
          "11314:      tiff_ifd[raw].bytes == raw_width*raw_height*2)",
          "11315:           {",
          "11316:      tiff_bps = 14;",
          "11317:             load_raw = &CLASS unpacked_load_raw;",
          "11318:             break;",
          "11319:    }",
          "11320:         if(!strncasecmp(make,\"Nikon\",5) && !strncmp(software,\"Nikon Scan\",10))",
          "11322:             load_raw = &CLASS nikon_coolscan_load_raw;",
          "11323:             raw_color = 1;",
          "11324:             filters = 0;",
          "11328:  if (!strncmp(make,\"OLYMPUS\",7) &&",
          "11329:   tiff_ifd[raw].bytes*2 == raw_width*raw_height*3)",
          "11330:    load_flags = 24;",
          "11331:  if (tiff_ifd[raw].bytes*5 == raw_width*raw_height*8) {",
          "11332:    load_flags = 81;",
          "11333:    tiff_bps = 12;",
          "11334:  } slr:",
          "11335:  switch (tiff_bps) {",
          "11336:    case  8: load_raw = &CLASS eight_bit_load_raw; break;",
          "11337:    case 12: if (tiff_ifd[raw].phint == 2)",
          "11338:        load_flags = 6;",
          "11339:      load_raw = &CLASS packed_load_raw;  break;",
          "11340:    case 14: load_flags = 0;",
          "11341:    case 16: load_raw = &CLASS unpacked_load_raw;",
          "11342:      if (!strncmp(make,\"OLYMPUS\",7) &&",
          "11343:    tiff_ifd[raw].bytes*7 > raw_width*raw_height)",
          "11344:        load_raw = &CLASS olympus_load_raw;",
          "11345:  }",
          "11346:  break;",
          "11347:       case 6:  case 7:  case 99:",
          "11348:  load_raw = &CLASS lossless_jpeg_load_raw;  break;",
          "11349:       case 262:",
          "11350:  load_raw = &CLASS kodak_262_load_raw;   break;",
          "11351:       case 34713:",
          "11352:  if ((raw_width+9)/10*16*raw_height == tiff_ifd[raw].bytes) {",
          "11353:    load_raw = &CLASS packed_load_raw;",
          "11354:    load_flags = 1;",
          "11355:  } else if (raw_width*raw_height*3 == tiff_ifd[raw].bytes*2) {",
          "11356:    load_raw = &CLASS packed_load_raw;",
          "11357:    if (model[0] == 'N') load_flags = 80;",
          "11358:  } else if (raw_width*raw_height*3 == tiff_ifd[raw].bytes) {",
          "11359:    load_raw = &CLASS nikon_yuv_load_raw;",
          "11360:    gamma_curve (1/2.4, 12.92, 1, 4095);",
          "11361:    memset (cblack, 0, sizeof cblack);",
          "11362:    filters = 0;",
          "11363:  } else if (raw_width*raw_height*2 == tiff_ifd[raw].bytes) {",
          "11364:    load_raw = &CLASS unpacked_load_raw;",
          "11365:    load_flags = 4;",
          "11366:    order = 0x4d4d;",
          "11367:  } else",
          "11368: #ifdef LIBRAW_LIBRARY_BUILD",
          "11369:           if(raw_width*raw_height*3 == tiff_ifd[raw].bytes*2)",
          "11370:             {",
          "11371:               load_raw = &CLASS packed_load_raw;",
          "11372:               load_flags=80;",
          "11373:             }",
          "11374:           else if(tiff_ifd[raw].rows_per_strip && tiff_ifd[raw].strip_offsets_count &&",
          "11375:     tiff_ifd[raw].strip_offsets_count == tiff_ifd[raw].strip_byte_counts_count)",
          "11376:      {",
          "11377:        int fit = 1;",
          "11378:        for(int i = 0; i < tiff_ifd[raw].strip_byte_counts_count-1; i++) // all but last",
          "11379:   if(tiff_ifd[raw].strip_byte_counts[i]*2 != tiff_ifd[raw].rows_per_strip*raw_width*3)",
          "11380:     {",
          "11381:       fit = 0;",
          "11382:       break;",
          "11383:     }",
          "11384:        if(fit)",
          "11385:   load_raw = &CLASS nikon_load_striped_packed_raw;",
          "11386:        else",
          "11387:   load_raw = &CLASS nikon_load_raw; // fallback",
          "11388:      }",
          "11389:  else",
          "11390: #endif",
          "11391:             load_raw = &CLASS nikon_load_raw;   break;",
          "11392:       case 65535:",
          "11393:  load_raw = &CLASS pentax_load_raw;   break;",
          "11394:       case 65000:",
          "11395:  switch (tiff_ifd[raw].phint) {",
          "11396:    case 2: load_raw = &CLASS kodak_rgb_load_raw;   filters = 0;  break;",
          "11397:    case 6: load_raw = &CLASS kodak_ycbcr_load_raw; filters = 0;  break;",
          "11398:    case 32803: load_raw = &CLASS kodak_65000_load_raw;",
          "11399:  }",
          "11400:       case 32867: case 34892: break;",
          "11401: #ifdef LIBRAW_LIBRARY_BUILD",
          "11402:       case 8: break;",
          "11403: #endif",
          "11404:       default: is_raw = 0;",
          "11407:     if ( ((tiff_samples == 3 && tiff_ifd[raw].bytes && tiff_bps != 14 &&",
          "11408:    (tiff_compress & -16) != 32768)",
          "11409:           || (tiff_bps == 8 && strncmp(make,\"Phase\",5) &&",
          "11410:    !strcasestr(make,\"Kodak\") &&",
          "11411:    !strstr(model2,\"DEBUG RAW\")))",
          "11412:          && strncmp(software,\"Nikon Scan\",10))",
          "11414:   for (i=0; i < tiff_nifds; i++)",
          "11415:     if (i != raw",
          "11417:         && tiff_ifd[i].bps>0 && tiff_ifd[i].bps < 33",
          "11418:  && tiff_ifd[i].phint != 32803",
          "11419:  && tiff_ifd[i].phint != 34892",
          "11420:         && unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&",
          "11421:  tiff_ifd[i].t_width * tiff_ifd[i].t_height / (SQR(tiff_ifd[i].bps)+1) >",
          "11422:        thumb_width *       thumb_height / (SQR(thumb_misc)+1)",
          "11423:  && tiff_ifd[i].comp != 34892) {",
          "11424:       thumb_width  = tiff_ifd[i].t_width;",
          "11428:       thumb_misc   = tiff_ifd[i].bps;",
          "11431:   if (thm >= 0) {",
          "11433:     switch (tiff_ifd[thm].comp) {",
          "11434:       case 0:",
          "11435:  write_thumb = &CLASS layer_thumb;",
          "11436:  break;",
          "11437:       case 1:",
          "11438:  if (tiff_ifd[thm].bps <= 8)",
          "11439:    write_thumb = &CLASS ppm_thumb;",
          "11440:  else if (!strncmp(make,\"Imacon\",6))",
          "11441:    write_thumb = &CLASS ppm16_thumb;",
          "11442:  else",
          "11443:    thumb_load_raw = &CLASS kodak_thumb_load_raw;",
          "11444:  break;",
          "11445:       case 65000:",
          "11446:  thumb_load_raw = tiff_ifd[thm].phint == 6 ?",
          "11447:   &CLASS kodak_ycbcr_load_raw : &CLASS kodak_rgb_load_raw;",
          "11452: void CLASS parse_minolta (int base)",
          "11454:   int save, tag, len, offset, high=0, wide=0, i, c;",
          "11455:   short sorder=order;",
          "11457:   fseek (ifp, base, SEEK_SET);",
          "11458:   if (fgetc(ifp) || fgetc(ifp)-'M' || fgetc(ifp)-'R') return;",
          "11461:   while ((save=ftell(ifp)) < offset) {",
          "11462:     for (tag=i=0; i < 4; i++)",
          "11465:     switch (tag) {",
          "11467:  fseek (ifp, 8, SEEK_CUR);",
          "11468:  high = get2();",
          "11469:  wide = get2();",
          "11470:  break;",
          "11471: #ifdef LIBRAW_LIBRARY_BUILD",
          "11473:     if (!strncasecmp(model,\"DSLR-A100\", 9))",
          "11476:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();",
          "11477:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();",
          "11478:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][0] = get2();",
          "11479:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][2] = get2();",
          "11480:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();",
          "11481:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();",
          "11482:       imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();",
          "11483:       imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();",
          "11484:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();",
          "11485:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();",
          "11487:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();",
          "11488:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();",
          "11489:       imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();",
          "11490:       imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();",
          "11491:       imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();",
          "11492:       imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();",
          "11493:       imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();",
          "11494:       imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();",
          "11495:       imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] =",
          "11496:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =",
          "11497:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] =",
          "11498:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] =",
          "11499:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =",
          "11500:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =",
          "11501:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] =",
          "11502:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =",
          "11503:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][3] = 0x100;",
          "11504:     }",
          "11505:  break;",
          "11506: #endif",
          "11508:  get4();",
          "11509:  i = strcmp(model,\"DiMAGE A200\") ? 0:3;",
          "11510:  FORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();",
          "11511:  break;",
          "11513:  parse_tiff (ftell(ifp));",
          "11514:  data_offset = offset;",
          "11515:     }",
          "11516:     fseek (ifp, save+len+8, SEEK_SET);",
          "11519:   raw_width  = wide;",
          "",
          "[Added Lines]",
          "12299: int CLASS parse_tiff(int base)",
          "12302:   fseek(ifp, base, SEEK_SET);",
          "12304:   if (order != 0x4949 && order != 0x4d4d)",
          "12305:     return 0;",
          "12307:   while ((doff = get4()))",
          "12308:   {",
          "12309:     fseek(ifp, doff + base, SEEK_SET);",
          "12310:     if (parse_tiff_ifd(base))",
          "12311:       break;",
          "12318:   int max_samp = 0, ties = 0, os, ns, raw = -1, thm = -1, i;",
          "12322:   if (thumb_offset)",
          "12323:   {",
          "12324:     fseek(ifp, thumb_offset, SEEK_SET);",
          "12325:     if (ljpeg_start(&jh, 1))",
          "12326:     {",
          "12327:       if ((unsigned)jh.bits < 17 && (unsigned)jh.wide < 0x10000 && (unsigned)jh.high < 0x10000)",
          "12328:       {",
          "12329:         thumb_misc = jh.bits;",
          "12330:         thumb_width = jh.wide;",
          "12331:         thumb_height = jh.high;",
          "12332:       }",
          "12335:   for (i = tiff_nifds; i--;)",
          "12336:   {",
          "12341:   for (i = 0; i < tiff_nifds; i++)",
          "12342:   {",
          "12344:       max_samp = tiff_ifd[i].samples;",
          "12345:     if (max_samp > 3)",
          "12346:       max_samp = 3;",
          "12347:     os = raw_width * raw_height;",
          "12348:     ns = tiff_ifd[i].t_width * tiff_ifd[i].t_height;",
          "12349:     if (tiff_bps)",
          "12350:     {",
          "12351:       os *= tiff_bps;",
          "12352:       ns *= tiff_ifd[i].bps;",
          "12355:         unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 && (unsigned)tiff_ifd[i].bps < 33 &&",
          "12356:         (unsigned)tiff_ifd[i].samples < 13 && ns && ((ns > os && (ties = 1)) || (ns == os && shot_select == ties++)))",
          "12357:     {",
          "12358:       raw_width = tiff_ifd[i].t_width;",
          "12359:       raw_height = tiff_ifd[i].t_height;",
          "12360:       tiff_bps = tiff_ifd[i].bps;",
          "12362:       data_offset = tiff_ifd[i].offset;",
          "12364:       data_size = tiff_ifd[i].bytes;",
          "12366:       tiff_flip = tiff_ifd[i].t_flip;",
          "12367:       tiff_samples = tiff_ifd[i].samples;",
          "12368:       tile_width = tiff_ifd[i].t_tile_width;",
          "12369:       tile_length = tiff_ifd[i].t_tile_length;",
          "12370:       shutter = tiff_ifd[i].t_shutter;",
          "12374:   if (is_raw == 1 && ties)",
          "12375:     is_raw = ties;",
          "12376:   if (!tile_width)",
          "12377:     tile_width = INT_MAX;",
          "12378:   if (!tile_length)",
          "12379:     tile_length = INT_MAX;",
          "12380:   for (i = tiff_nifds; i--;)",
          "12381:     if (tiff_ifd[i].t_flip)",
          "12382:       tiff_flip = tiff_ifd[i].t_flip;",
          "12384:     switch (tiff_compress)",
          "12385:     {",
          "12386:     case 32767:",
          "12387:       if (tiff_ifd[raw].bytes == raw_width * raw_height)",
          "12388:       {",
          "12389:         tiff_bps = 12;",
          "12390:         load_raw = &CLASS sony_arw2_load_raw;",
          "12391:         break;",
          "12392:       }",
          "12393:       if (!strncasecmp(make, \"Sony\", 4) && tiff_ifd[raw].bytes == raw_width * raw_height * 2)",
          "12394:       {",
          "12395:         tiff_bps = 14;",
          "12396:         load_raw = &CLASS unpacked_load_raw;",
          "12397:         break;",
          "12398:       }",
          "12399:       if (tiff_ifd[raw].bytes * 8 != raw_width * raw_height * tiff_bps)",
          "12400:       {",
          "12401:         raw_height += 8;",
          "12402:         load_raw = &CLASS sony_arw_load_raw;",
          "12403:         break;",
          "12404:       }",
          "12405:       load_flags = 79;",
          "12406:     case 32769:",
          "12407:       load_flags++;",
          "12408:     case 32770:",
          "12409:     case 32773:",
          "12410:       goto slr;",
          "12411:     case 0:",
          "12412:     case 1:",
          "12413: #ifdef LIBRAW_LIBRARY_BUILD",
          "12415:       if (!strncasecmp(make, \"Sony\", 4) && tiff_ifd[raw].bytes == raw_width * raw_height * 2)",
          "12416:       {",
          "12417:         tiff_bps = 14;",
          "12418:         load_raw = &CLASS unpacked_load_raw;",
          "12419:         break;",
          "12420:       }",
          "12421:       if (!strncasecmp(make, \"Nikon\", 5) && !strncmp(software, \"Nikon Scan\", 10))",
          "12422:       {",
          "12423:         load_raw = &CLASS nikon_coolscan_load_raw;",
          "12424:         raw_color = 1;",
          "12425:         filters = 0;",
          "12426:         break;",
          "12427:       }",
          "12428: #endif",
          "12429:       if (!strncmp(make, \"OLYMPUS\", 7) && tiff_ifd[raw].bytes * 2 == raw_width * raw_height * 3)",
          "12430:         load_flags = 24;",
          "12431:       if (tiff_ifd[raw].bytes * 5 == raw_width * raw_height * 8)",
          "12432:       {",
          "12433:         load_flags = 81;",
          "12434:         tiff_bps = 12;",
          "12435:       }",
          "12436:     slr:",
          "12437:       switch (tiff_bps)",
          "12438:       {",
          "12439:       case 8:",
          "12440:         load_raw = &CLASS eight_bit_load_raw;",
          "12441:         break;",
          "12442:       case 12:",
          "12443:         if (tiff_ifd[raw].phint == 2)",
          "12444:           load_flags = 6;",
          "12445:         load_raw = &CLASS packed_load_raw;",
          "12446:         break;",
          "12447:       case 14:",
          "12448:         load_flags = 0;",
          "12449:       case 16:",
          "12450:         load_raw = &CLASS unpacked_load_raw;",
          "12451:         if (!strncmp(make, \"OLYMPUS\", 7) && tiff_ifd[raw].bytes * 7 > raw_width * raw_height)",
          "12452:           load_raw = &CLASS olympus_load_raw;",
          "12453:       }",
          "12454:       break;",
          "12455:     case 6:",
          "12456:     case 7:",
          "12457:     case 99:",
          "12458:       load_raw = &CLASS lossless_jpeg_load_raw;",
          "12459:       break;",
          "12460:     case 262:",
          "12461:       load_raw = &CLASS kodak_262_load_raw;",
          "12462:       break;",
          "12463:     case 34713:",
          "12464:       if ((raw_width + 9) / 10 * 16 * raw_height == tiff_ifd[raw].bytes)",
          "12465:       {",
          "12466:         load_raw = &CLASS packed_load_raw;",
          "12467:         load_flags = 1;",
          "12468:       }",
          "12469:       else if (raw_width * raw_height * 3 == tiff_ifd[raw].bytes * 2)",
          "12470:       {",
          "12471:         load_raw = &CLASS packed_load_raw;",
          "12472:         if (model[0] == 'N')",
          "12473:           load_flags = 80;",
          "12474:       }",
          "12475:       else if (raw_width * raw_height * 3 == tiff_ifd[raw].bytes)",
          "12476:       {",
          "12477:         load_raw = &CLASS nikon_yuv_load_raw;",
          "12478:         gamma_curve(1 / 2.4, 12.92, 1, 4095);",
          "12479:         memset(cblack, 0, sizeof cblack);",
          "12480:         filters = 0;",
          "12481:       }",
          "12482:       else if (raw_width * raw_height * 2 == tiff_ifd[raw].bytes)",
          "12483:       {",
          "12484:         load_raw = &CLASS unpacked_load_raw;",
          "12485:         load_flags = 4;",
          "12486:         order = 0x4d4d;",
          "12487:       }",
          "12488:       else",
          "12490:           if (raw_width * raw_height * 3 == tiff_ifd[raw].bytes * 2)",
          "12491:       {",
          "12492:         load_raw = &CLASS packed_load_raw;",
          "12493:         load_flags = 80;",
          "12494:       }",
          "12495:       else if (tiff_ifd[raw].rows_per_strip && tiff_ifd[raw].strip_offsets_count &&",
          "12496:                tiff_ifd[raw].strip_offsets_count == tiff_ifd[raw].strip_byte_counts_count)",
          "12497:       {",
          "12498:         int fit = 1;",
          "12499:         for (int i = 0; i < tiff_ifd[raw].strip_byte_counts_count - 1; i++) // all but last",
          "12500:           if (tiff_ifd[raw].strip_byte_counts[i] * 2 != tiff_ifd[raw].rows_per_strip * raw_width * 3)",
          "12502:             fit = 0;",
          "12505:         if (fit)",
          "12506:           load_raw = &CLASS nikon_load_striped_packed_raw;",
          "12507:         else",
          "12508:           load_raw = &CLASS nikon_load_raw; // fallback",
          "12509:       }",
          "12510:       else",
          "12512:         load_raw = &CLASS nikon_load_raw;",
          "12513:       break;",
          "12514:     case 65535:",
          "12515:       load_raw = &CLASS pentax_load_raw;",
          "12516:       break;",
          "12517:     case 65000:",
          "12518:       switch (tiff_ifd[raw].phint)",
          "12519:       {",
          "12520:       case 2:",
          "12521:         load_raw = &CLASS kodak_rgb_load_raw;",
          "12522:         filters = 0;",
          "12523:         break;",
          "12524:       case 6:",
          "12525:         load_raw = &CLASS kodak_ycbcr_load_raw;",
          "12526:         filters = 0;",
          "12527:         break;",
          "12528:       case 32803:",
          "12529:         load_raw = &CLASS kodak_65000_load_raw;",
          "12530:       }",
          "12531:     case 32867:",
          "12532:     case 34892:",
          "12533:       break;",
          "12534: #ifdef LIBRAW_LIBRARY_BUILD",
          "12535:     case 8:",
          "12536:       break;",
          "12537: #endif",
          "12538:     default:",
          "12539:       is_raw = 0;",
          "12542:     if (((tiff_samples == 3 && tiff_ifd[raw].bytes && tiff_bps != 14 && (tiff_compress & -16) != 32768) ||",
          "12543:          (tiff_bps == 8 && strncmp(make, \"Phase\", 5) && !strcasestr(make, \"Kodak\") && !strstr(model2, \"DEBUG RAW\"))) &&",
          "12544:         strncmp(software, \"Nikon Scan\", 10))",
          "12546:   for (i = 0; i < tiff_nifds; i++)",
          "12547:     if (i != raw &&",
          "12549:         && tiff_ifd[i].bps > 0 && tiff_ifd[i].bps < 33 && tiff_ifd[i].phint != 32803 && tiff_ifd[i].phint != 34892 &&",
          "12550:         unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&",
          "12551:         tiff_ifd[i].t_width * tiff_ifd[i].t_height / (SQR(tiff_ifd[i].bps) + 1) >",
          "12552:             thumb_width * thumb_height / (SQR(thumb_misc) + 1) &&",
          "12553:         tiff_ifd[i].comp != 34892)",
          "12554:     {",
          "12555:       thumb_width = tiff_ifd[i].t_width;",
          "12559:       thumb_misc = tiff_ifd[i].bps;",
          "12562:   if (thm >= 0)",
          "12563:   {",
          "12565:     switch (tiff_ifd[thm].comp)",
          "12566:     {",
          "12567:     case 0:",
          "12568:       write_thumb = &CLASS layer_thumb;",
          "12569:       break;",
          "12570:     case 1:",
          "12571:       if (tiff_ifd[thm].bps <= 8)",
          "12572:         write_thumb = &CLASS ppm_thumb;",
          "12573:       else if (!strncmp(make, \"Imacon\", 6))",
          "12574:         write_thumb = &CLASS ppm16_thumb;",
          "12575:       else",
          "12576:         thumb_load_raw = &CLASS kodak_thumb_load_raw;",
          "12577:       break;",
          "12578:     case 65000:",
          "12579:       thumb_load_raw = tiff_ifd[thm].phint == 6 ? &CLASS kodak_ycbcr_load_raw : &CLASS kodak_rgb_load_raw;",
          "12584: void CLASS parse_minolta(int base)",
          "12586:   int save, tag, len, offset, high = 0, wide = 0, i, c;",
          "12587:   short sorder = order;",
          "12589:   fseek(ifp, base, SEEK_SET);",
          "12590:   if (fgetc(ifp) || fgetc(ifp) - 'M' || fgetc(ifp) - 'R')",
          "12591:     return;",
          "12594:   while ((save = ftell(ifp)) < offset)",
          "12595:   {",
          "12596:     for (tag = i = 0; i < 4; i++)",
          "12599:     switch (tag)",
          "12603:       high = get2();",
          "12604:       wide = get2();",
          "12605:       break;",
          "12606: #ifdef LIBRAW_LIBRARY_BUILD",
          "12608:       if (!strncasecmp(model, \"DSLR-A100\", 9))",
          "12609:       {",
          "12610:         fseek(ifp, 8, SEEK_CUR);",
          "12611:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();",
          "12612:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();",
          "12613:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][0] = get2();",
          "12614:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][2] = get2();",
          "12615:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();",
          "12616:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();",
          "12617:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();",
          "12618:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();",
          "12619:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();",
          "12620:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();",
          "12621:         get4();",
          "12622:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();",
          "12623:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();",
          "12624:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();",
          "12625:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();",
          "12626:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();",
          "12627:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();",
          "12628:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();",
          "12629:         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();",
          "12630:         imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] =",
          "12631:             imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =",
          "12632:                 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] =",
          "12633:                     imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] =",
          "12634:                         imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =",
          "12635:                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =",
          "12636:                                 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1] =",
          "12637:                                     imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] =",
          "12638:                                         imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] =",
          "12639:                                             imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =",
          "12640:                                                 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][1] =",
          "12641:                                                     imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][3] = 0x100;",
          "12642:       }",
          "12643:       break;",
          "12644: #endif",
          "12647:       i = strcmp(model, \"DiMAGE A200\") ? 0 : 3;",
          "12648:       FORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();",
          "12649:       break;",
          "12651:       parse_tiff(ftell(ifp));",
          "12652:       data_offset = offset;",
          "12653:     }",
          "12654:     fseek(ifp, save + len + 8, SEEK_SET);",
          "12657:   raw_width = wide;",
          "",
          "---------------",
          "--- Hunk 92 ---",
          "[Context before]",
          "11530:   const char *file, *ext;",
          "11531:   char *jname, *jfile, *jext;",
          "11532: #ifndef LIBRAW_LIBRARY_BUILD",
          "11534: #else",
          "11535: #if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)",
          "11537:   {",
          "11550:   }",
          "11551: #endif",
          "11557: #endif",
          "11562: #ifndef LIBRAW_LIBRARY_BUILD",
          "11564: #else",
          "11566: #endif",
          "11567:   file++;",
          "11572:   jfile = file - ifname + jname;",
          "11585:       }",
          "11587:     }",
          "11588: #ifndef LIBRAW_LIBRARY_BUILD",
          "11591: #ifdef DCRAW_VERBOSE",
          "11592:       if (verbose)",
          "11594: #endif",
          "11596:       thumb_offset = 0;",
          "11597:       is_raw = 1;",
          "11599:     }",
          "11600:   }",
          "11601: #else",
          "11614: #endif",
          "11615:   if (!timestamp)",
          "11617: #ifdef LIBRAW_LIBRARY_BUILD",
          "11619: #endif",
          "11620: #ifdef DCRAW_VERBOSE",
          "11622: #endif",
          "11625: #ifndef LIBRAW_LIBRARY_BUILD",
          "11626:   ifp = save;",
          "11627: #endif",
          "",
          "[Removed Lines]",
          "11533:   FILE *save=ifp;",
          "11536:   if(ifp->wfname())",
          "11538:    std::wstring rawfile(ifp->wfname());",
          "11539:    rawfile.replace(rawfile.length()-3,3,L\"JPG\");",
          "11540:    if(!ifp->subfile_open(rawfile.c_str()))",
          "11541:    {",
          "11542:     parse_tiff (12);",
          "11543:     thumb_offset = 0;",
          "11544:     is_raw = 1;",
          "11545:     ifp->subfile_close();",
          "11546:    }",
          "11547:    else",
          "11548:     imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;",
          "11549:   return;",
          "11552:   if(!ifp->fname())",
          "11553:       {",
          "11554:           imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;",
          "11555:           return;",
          "11556:       }",
          "11559:   ext  = strrchr (ifname, '.');",
          "11560:   file = strrchr (ifname, '/');",
          "11561:   if (!file) file = strrchr (ifname, '\\\\');",
          "11563:   if (!file) file = ifname-1;",
          "11565:   if (!file) file = (char*)ifname-1;",
          "11568:   if (!ext || strlen(ext) != 4 || ext-file != 8) return;",
          "11569:   jname = (char *) malloc (strlen(ifname) + 1);",
          "11570:   merror (jname, \"parse_external_jpeg()\");",
          "11571:   strcpy (jname, ifname);",
          "11573:   jext  = ext  - ifname + jname;",
          "11574:   if (strcasecmp (ext, \".jpg\")) {",
          "11575:     strcpy (jext, isupper(ext[1]) ? \".JPG\":\".jpg\");",
          "11576:     if (isdigit(*file)) {",
          "11577:       memcpy (jfile, file+4, 4);",
          "11578:       memcpy (jfile+4, file, 4);",
          "11579:     }",
          "11580:   } else",
          "11581:     while (isdigit(*--jext)) {",
          "11582:       if (*jext != '9') {",
          "11583:  (*jext)++;",
          "11584:  break;",
          "11589:   if (strcmp (jname, ifname)) {",
          "11590:     if ((ifp = fopen (jname, \"rb\"))) {",
          "11593:  fprintf (stderr,_(\"Reading metadata from %s ...\\n\"), jname);",
          "11595:       parse_tiff (12);",
          "11598:       fclose (ifp);",
          "11602:   if (strcmp (jname, ifname))",
          "11603:       {",
          "11604:           if(!ifp->subfile_open(jname))",
          "11605:               {",
          "11606:                   parse_tiff (12);",
          "11607:                   thumb_offset = 0;",
          "11608:                   is_raw = 1;",
          "11609:                   ifp->subfile_close();",
          "11610:               }",
          "11611:           else",
          "11612:               imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;",
          "11613:       }",
          "11616:       {",
          "11618:           imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;",
          "11621:           fprintf (stderr,_(\"Failed to read metadata from %s\\n\"), jname);",
          "11623:       }",
          "11624:   free (jname);",
          "",
          "[Added Lines]",
          "12671:   FILE *save = ifp;",
          "12674:   if (ifp->wfname())",
          "12676:     std::wstring rawfile(ifp->wfname());",
          "12677:     rawfile.replace(rawfile.length() - 3, 3, L\"JPG\");",
          "12678:     if (!ifp->subfile_open(rawfile.c_str()))",
          "12679:     {",
          "12680:       parse_tiff(12);",
          "12681:       thumb_offset = 0;",
          "12682:       is_raw = 1;",
          "12683:       ifp->subfile_close();",
          "12684:     }",
          "12685:     else",
          "12686:       imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;",
          "12687:     return;",
          "12690:   if (!ifp->fname())",
          "12691:   {",
          "12692:     imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;",
          "12693:     return;",
          "12694:   }",
          "12697:   ext = strrchr(ifname, '.');",
          "12698:   file = strrchr(ifname, '/');",
          "12699:   if (!file)",
          "12700:     file = strrchr(ifname, '\\\\');",
          "12702:   if (!file)",
          "12703:     file = ifname - 1;",
          "12705:   if (!file)",
          "12706:     file = (char *)ifname - 1;",
          "12709:   if (!ext || strlen(ext) != 4 || ext - file != 8)",
          "12710:     return;",
          "12711:   jname = (char *)malloc(strlen(ifname) + 1);",
          "12712:   merror(jname, \"parse_external_jpeg()\");",
          "12713:   strcpy(jname, ifname);",
          "12715:   jext = ext - ifname + jname;",
          "12716:   if (strcasecmp(ext, \".jpg\"))",
          "12717:   {",
          "12718:     strcpy(jext, isupper(ext[1]) ? \".JPG\" : \".jpg\");",
          "12719:     if (isdigit(*file))",
          "12720:     {",
          "12721:       memcpy(jfile, file + 4, 4);",
          "12722:       memcpy(jfile + 4, file, 4);",
          "12723:     }",
          "12724:   }",
          "12725:   else",
          "12726:     while (isdigit(*--jext))",
          "12727:     {",
          "12728:       if (*jext != '9')",
          "12729:       {",
          "12730:         (*jext)++;",
          "12731:         break;",
          "12736:   if (strcmp(jname, ifname))",
          "12737:   {",
          "12738:     if ((ifp = fopen(jname, \"rb\")))",
          "12739:     {",
          "12742:         fprintf(stderr, _(\"Reading metadata from %s ...\\n\"), jname);",
          "12744:       parse_tiff(12);",
          "12747:       fclose(ifp);",
          "12751:   if (strcmp(jname, ifname))",
          "12752:   {",
          "12753:     if (!ifp->subfile_open(jname))",
          "12754:     {",
          "12755:       parse_tiff(12);",
          "12756:       thumb_offset = 0;",
          "12757:       is_raw = 1;",
          "12758:       ifp->subfile_close();",
          "12759:     }",
          "12760:     else",
          "12761:       imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;",
          "12762:   }",
          "12765:   {",
          "12767:     imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;",
          "12770:     fprintf(stderr, _(\"Failed to read metadata from %s\\n\"), jname);",
          "12772:   }",
          "12773:   free(jname);",
          "",
          "---------------",
          "--- Hunk 93 ---",
          "[Context before]",
          "11634: void CLASS ciff_block_1030()",
          "11635: {",
          "11641:   bpp = get2();",
          "11648:       }",
          "11649:       white[row][col] = bitbuf >> (vbits -= bpp) & ~(-1 << bpp);",
          "11650:     }",
          "",
          "[Removed Lines]",
          "11636:   static const ushort key[] = { 0x410, 0x45f3 };",
          "11637:   int i, bpp, row, col, vbits=0;",
          "11638:   unsigned long bitbuf=0;",
          "11640:   if ((get2(),get4()) != 0x80008 || !get4()) return;",
          "11642:   if (bpp != 10 && bpp != 12) return;",
          "11643:   for (i=row=0; row < 8; row++)",
          "11644:     for (col=0; col < 8; col++) {",
          "11645:       if (vbits < bpp) {",
          "11646:  bitbuf = bitbuf << 16 | (get2() ^ key[i++ & 1]);",
          "11647:  vbits += 16;",
          "",
          "[Added Lines]",
          "12785:   static const ushort key[] = {0x410, 0x45f3};",
          "12786:   int i, bpp, row, col, vbits = 0;",
          "12787:   unsigned long bitbuf = 0;",
          "12789:   if ((get2(), get4()) != 0x80008 || !get4())",
          "12790:     return;",
          "12792:   if (bpp != 10 && bpp != 12)",
          "12793:     return;",
          "12794:   for (i = row = 0; row < 8; row++)",
          "12795:     for (col = 0; col < 8; col++)",
          "12796:     {",
          "12797:       if (vbits < bpp)",
          "12798:       {",
          "12799:         bitbuf = bitbuf << 16 | (get2() ^ key[i++ & 1]);",
          "12800:         vbits += 16;",
          "",
          "---------------",
          "--- Hunk 94 ---",
          "[Context before]",
          "11654:    Parse a CIFF file, better known as Canon CRW format.",
          "11658: {",
          "11663:   tboff = get4() + offset;",
          "11665:   nrecs = get2();",
          "11668:     type = get2();",
          "11670:     save = ftell(ifp) + 4;",
          "11674:     }",
          "11675: #ifdef LIBRAW_LIBRARY_BUILD",
          "11677: #endif",
          "11678:     if (type == 0x0810)",
          "11684:     }",
          "11686:       width = get4();",
          "11687:       height = get4();",
          "11688:       pixel_aspect = int_to_float(get4());",
          "11689:       flip = get4();",
          "11690:     }",
          "11692:       tiff_compress = get4();",
          "11694:       thumb_offset = ftell(ifp);",
          "11695:       thumb_length = len;",
          "11696:     }",
          "11700: #ifdef LIBRAW_LIBRARY_BUILD",
          "11701:       imgdata.lens.makernotes.CurAp = aperture;",
          "11702: #endif",
          "11703:     }",
          "11707: #ifdef LIBRAW_LIBRARY_BUILD",
          "11709:       imgdata.lens.makernotes.CurAp = aperture;",
          "11710: #else",
          "11712: #endif",
          "11718:     }",
          "11726:       }",
          "11727:     }",
          "11728: #ifdef LIBRAW_LIBRARY_BUILD",
          "11729:     if (type == 0x10a9)",
          "11736:     if (type == 0x102d)",
          "11742:     if (type == 0x580b)",
          "11743:       {",
          "11769:       FORC4 cam_mul[c ^ (c >> 1)] = get2();",
          "11770:     }",
          "11775:       raw_height = get2();",
          "11776:     }",
          "11778:       iso_speed = len & 0xffff;",
          "11779:     }",
          "11781: #ifdef LIBRAW_LIBRARY_BUILD",
          "11783:       imgdata.lens.makernotes.FocalType = len & 0xffff;",
          "11785:         imgdata.lens.makernotes.CanonFocalUnits = 32;",
          "11788:       }",
          "11789:       focal_len = imgdata.lens.makernotes.CurFocal;",
          "11790: #else",
          "11791:       focal_len = len >> 16;",
          "11793: #endif",
          "11794:     }",
          "11798:     if (type == 0x5834)",
          "11801: #ifdef LIBRAW_LIBRARY_BUILD",
          "11803: #endif",
          "11807: #ifdef LOCALTIME",
          "11808:     if ((type | 0x4000) == 0x580e)",
          "11810: #endif",
          "11812:   }",
          "11813: }",
          "",
          "[Removed Lines]",
          "11657: void CLASS parse_ciff (int offset, int length, int depth)",
          "11659:   int tboff, nrecs, c, type, len, save, wbi=-1;",
          "11660:   ushort key[] = { 0x410, 0x45f3 };",
          "11662:   fseek (ifp, offset+length-4, SEEK_SET);",
          "11664:   fseek (ifp, tboff, SEEK_SET);",
          "11666:   if ((nrecs | depth) > 127) return;",
          "11667:   while (nrecs--) {",
          "11669:     len  = get4();",
          "11671:     fseek (ifp, offset+get4(), SEEK_SET);",
          "11672:     if ((((type >> 8) + 8) | 8) == 0x38) {",
          "11676:     if (type == 0x3004) parse_ciff (ftell(ifp), len, depth+1);",
          "11679:       fread (artist, 64, 1, ifp);",
          "11680:     if (type == 0x080a) {",
          "11681:       fread (make, 64, 1, ifp);",
          "11682:       fseek (ifp, strbuflen(make) - 63, SEEK_CUR);",
          "11683:       fread (model, 64, 1, ifp);",
          "11685:     if (type == 0x1810) {",
          "11693:     if (type == 0x2007) {",
          "11697:     if (type == 0x1818) {",
          "11698:       shutter = powf64(2.0f, -int_to_float((get4(),get4())));",
          "11699:       aperture = powf64(2.0f, int_to_float(get4())/2);",
          "11704:     if (type == 0x102a) {",
          "11706:       iso_speed = powf64(2.0f, ((get2(),get2()) + get2())/32.0f - 5.0f) * 100.0f;",
          "11708:       aperture  = _CanonConvertAperture((get2(),get2()));",
          "11711:       aperture  = powf64(2.0, (get2(),(short)get2())/64.0);",
          "11713:       shutter   = powf64(2.0,-((short)get2())/32.0);",
          "11714:       wbi = (get2(),get2());",
          "11715:       if (wbi > 17) wbi = 0;",
          "11716:       fseek (ifp, 32, SEEK_CUR);",
          "11717:       if (shutter > 1e6) shutter = get2()/10.0;",
          "11719:     if (type == 0x102c) {",
          "11721:  fseek (ifp, 118, SEEK_CUR);",
          "11722:  FORC4 cam_mul[c ^ 2] = get2();",
          "11724:  fseek (ifp, 98, SEEK_CUR);",
          "11725:  FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2();",
          "11730:       {",
          "11731:  INT64 o = ftell(ifp);",
          "11732:  fseek (ifp, (0x5<<1), SEEK_CUR);",
          "11733:  Canon_WBpresets(0,0);",
          "11734:  fseek(ifp,o,SEEK_SET);",
          "11735:       }",
          "11737:       {",
          "11738:  INT64 o = ftell(ifp);",
          "11739:  Canon_CameraSettings();",
          "11740:  fseek(ifp,o,SEEK_SET);",
          "11741:       }",
          "11744:         if (strcmp(model,\"Canon EOS D30\")) sprintf(imgdata.shootinginfo.BodySerial, \"%d\", len);",
          "11745:         else sprintf(imgdata.shootinginfo.BodySerial, \"%0x-%05d\", len>>16, len&0xffff);",
          "11746:       }",
          "11747: #endif",
          "11748:     if (type == 0x0032) {",
          "11750:  fseek (ifp, 72, SEEK_CUR);",
          "11751:  FORC4 cam_mul[c ^ (c >> 1)] = 1024.0 / get2();",
          "11753:       } else if (!cam_mul[0]) {",
          "11755:    c = (strstr(model,\"Pro1\") ?",
          "11756:        \"012346000000000000\":\"01345:000000006008\")[LIM(0,wbi,17)]-'0'+ 2;",
          "11758:    c = \"023457000000006000\"[LIM(0,wbi,17)]-'0';",
          "11759:    key[0] = key[1] = 0;",
          "11760:  }",
          "11761:  fseek (ifp, 78 + c*8, SEEK_CUR);",
          "11762:  FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2() ^ key[c & 1];",
          "11763:  if (!wbi) cam_mul[0] = -1;",
          "11764:       }",
          "11765:     }",
          "11767:       if (len > 66) wbi = \"0134567028\"[LIM(0,wbi,9)]-'0';",
          "11768:       fseek (ifp, 2 + wbi*8, SEEK_CUR);",
          "11771:     if (type == 0x1030 && wbi>=0 && (0x18040 >> wbi & 1))",
          "11773:     if (type == 0x1031) {",
          "11774:       raw_width = (get2(),get2());",
          "11777:     if (type == 0x501c) {",
          "11780:     if (type == 0x5029) {",
          "11782:       imgdata.lens.makernotes.CurFocal  = len >> 16;",
          "11784:       if (imgdata.lens.makernotes.FocalType == 2) {",
          "11786:  if(imgdata.lens.makernotes.CanonFocalUnits>1)",
          "11787:    imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "11792:       if ((len & 0xffff) == 2) focal_len /= 32;",
          "11795:     if (type == 0x5813) flash_used = int_to_float(len);",
          "11796:     if (type == 0x5814) canon_ev   = int_to_float(len);",
          "11797:     if (type == 0x5817) shot_order = len;",
          "11799:       {",
          "11800:          unique_id  = len;",
          "11802:          setCanonBodyFeatures(unique_id);",
          "11804:       }",
          "11805:     if (type == 0x580e) timestamp  = len;",
          "11806:     if (type == 0x180e) timestamp  = get4();",
          "11809:       timestamp = mktime (gmtime (&timestamp));",
          "11811:     fseek (ifp, save, SEEK_SET);",
          "",
          "[Added Lines]",
          "12810: void CLASS parse_ciff(int offset, int length, int depth)",
          "12812:   int tboff, nrecs, c, type, len, save, wbi = -1;",
          "12813:   ushort key[] = {0x410, 0x45f3};",
          "12815:   fseek(ifp, offset + length - 4, SEEK_SET);",
          "12817:   fseek(ifp, tboff, SEEK_SET);",
          "12819:   if ((nrecs | depth) > 127)",
          "12820:     return;",
          "12821:   while (nrecs--)",
          "12822:   {",
          "12824:     len = get4();",
          "12826:     fseek(ifp, offset + get4(), SEEK_SET);",
          "12827:     if ((((type >> 8) + 8) | 8) == 0x38)",
          "12828:     {",
          "12832:     if (type == 0x3004)",
          "12833:       parse_ciff(ftell(ifp), len, depth + 1);",
          "12836:       fread(artist, 64, 1, ifp);",
          "12837:     if (type == 0x080a)",
          "12838:     {",
          "12839:       fread(make, 64, 1, ifp);",
          "12840:       fseek(ifp, strbuflen(make) - 63, SEEK_CUR);",
          "12841:       fread(model, 64, 1, ifp);",
          "12843:     if (type == 0x1810)",
          "12844:     {",
          "12852:     if (type == 0x2007)",
          "12853:     {",
          "12857:     if (type == 0x1818)",
          "12858:     {",
          "12859:       shutter = powf64(2.0f, -int_to_float((get4(), get4())));",
          "12860:       aperture = powf64(2.0f, int_to_float(get4()) / 2);",
          "12865:     if (type == 0x102a)",
          "12866:     {",
          "12868:       iso_speed = powf64(2.0f, ((get2(), get2()) + get2()) / 32.0f - 5.0f) * 100.0f;",
          "12870:       aperture = _CanonConvertAperture((get2(), get2()));",
          "12873:       aperture = powf64(2.0, (get2(), (short)get2()) / 64.0);",
          "12875:       shutter = powf64(2.0, -((short)get2()) / 32.0);",
          "12876:       wbi = (get2(), get2());",
          "12877:       if (wbi > 17)",
          "12878:         wbi = 0;",
          "12879:       fseek(ifp, 32, SEEK_CUR);",
          "12880:       if (shutter > 1e6)",
          "12881:         shutter = get2() / 10.0;",
          "12883:     if (type == 0x102c)",
          "12884:     {",
          "12885:       if (get2() > 512)",
          "12887:         fseek(ifp, 118, SEEK_CUR);",
          "12888:         FORC4 cam_mul[c ^ 2] = get2();",
          "12889:       }",
          "12890:       else",
          "12892:         fseek(ifp, 98, SEEK_CUR);",
          "12893:         FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2();",
          "12898:     {",
          "12899:       INT64 o = ftell(ifp);",
          "12900:       fseek(ifp, (0x5 << 1), SEEK_CUR);",
          "12901:       Canon_WBpresets(0, 0);",
          "12902:       fseek(ifp, o, SEEK_SET);",
          "12903:     }",
          "12905:     {",
          "12906:       INT64 o = ftell(ifp);",
          "12907:       Canon_CameraSettings();",
          "12908:       fseek(ifp, o, SEEK_SET);",
          "12909:     }",
          "12911:     {",
          "12912:       if (strcmp(model, \"Canon EOS D30\"))",
          "12913:         sprintf(imgdata.shootinginfo.BodySerial, \"%d\", len);",
          "12914:       else",
          "12915:         sprintf(imgdata.shootinginfo.BodySerial, \"%0x-%05d\", len >> 16, len & 0xffff);",
          "12916:     }",
          "12917: #endif",
          "12918:     if (type == 0x0032)",
          "12919:     {",
          "12920:       if (len == 768)",
          "12922:         fseek(ifp, 72, SEEK_CUR);",
          "12923:         FORC4 cam_mul[c ^ (c >> 1)] = 1024.0 / get2();",
          "12924:         if (!wbi)",
          "12926:       }",
          "12927:       else if (!cam_mul[0])",
          "12930:           c = (strstr(model, \"Pro1\") ? \"012346000000000000\" : \"01345:000000006008\")[LIM(0, wbi, 17)] - '0' + 2;",
          "12931:         else",
          "12933:           c = \"023457000000006000\"[LIM(0, wbi, 17)] - '0';",
          "12934:           key[0] = key[1] = 0;",
          "12935:         }",
          "12936:         fseek(ifp, 78 + c * 8, SEEK_CUR);",
          "12937:         FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2() ^ key[c & 1];",
          "12938:         if (!wbi)",
          "12939:           cam_mul[0] = -1;",
          "12940:       }",
          "12941:     }",
          "12942:     if (type == 0x10a9)",
          "12944:       if (len > 66)",
          "12945:         wbi = \"0134567028\"[LIM(0, wbi, 9)] - '0';",
          "12946:       fseek(ifp, 2 + wbi * 8, SEEK_CUR);",
          "12949:     if (type == 0x1030 && wbi >= 0 && (0x18040 >> wbi & 1))",
          "12951:     if (type == 0x1031)",
          "12952:     {",
          "12953:       raw_width = (get2(), get2());",
          "12956:     if (type == 0x501c)",
          "12957:     {",
          "12960:     if (type == 0x5029)",
          "12961:     {",
          "12963:       imgdata.lens.makernotes.CurFocal = len >> 16;",
          "12965:       if (imgdata.lens.makernotes.FocalType == 2)",
          "12966:       {",
          "12968:         if (imgdata.lens.makernotes.CanonFocalUnits > 1)",
          "12969:           imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;",
          "12974:       if ((len & 0xffff) == 2)",
          "12975:         focal_len /= 32;",
          "12978:     if (type == 0x5813)",
          "12979:       flash_used = int_to_float(len);",
          "12980:     if (type == 0x5814)",
          "12981:       canon_ev = int_to_float(len);",
          "12982:     if (type == 0x5817)",
          "12983:       shot_order = len;",
          "12985:     {",
          "12986:       unique_id = len;",
          "12988:       setCanonBodyFeatures(unique_id);",
          "12990:     }",
          "12991:     if (type == 0x580e)",
          "12992:       timestamp = len;",
          "12993:     if (type == 0x180e)",
          "12994:       timestamp = get4();",
          "12997:       timestamp = mktime(gmtime(&timestamp));",
          "12999:     fseek(ifp, save, SEEK_SET);",
          "",
          "---------------",
          "--- Hunk 95 ---",
          "[Context before]",
          "11817:   char line[128], *val;",
          "11818:   struct tm t;",
          "11826:     else",
          "11827:       val = line + strbuflen(line);",
          "11833:       thumb_offset = atoi(val);",
          "11835:       raw_width = atoi(val);",
          "11837:       raw_height = atoi(val);",
          "11839:       thumb_width = atoi(val);",
          "11841:       thumb_height = atoi(val);",
          "11843:   data_offset = thumb_offset + thumb_width * thumb_height * 2;",
          "11844:   t.tm_year -= 1900;",
          "11845:   t.tm_mon -= 1;",
          "11846:   if (mktime(&t) > 0)",
          "11847:     timestamp = mktime(&t);",
          "11850:   write_thumb = &CLASS rollei_thumb;",
          "11851: }",
          "",
          "[Removed Lines]",
          "11820:   fseek (ifp, 0, SEEK_SET);",
          "11821:   memset (&t, 0, sizeof t);",
          "11822:   do {",
          "11823:     fgets (line, 128, ifp);",
          "11824:     if ((val = strchr(line,'=')))",
          "11828:     if (!strcmp(line,\"DAT\"))",
          "11829:       sscanf (val, \"%d.%d.%d\", &t.tm_mday, &t.tm_mon, &t.tm_year);",
          "11830:     if (!strcmp(line,\"TIM\"))",
          "11831:       sscanf (val, \"%d:%d:%d\", &t.tm_hour, &t.tm_min, &t.tm_sec);",
          "11832:     if (!strcmp(line,\"HDR\"))",
          "11834:     if (!strcmp(line,\"X  \"))",
          "11836:     if (!strcmp(line,\"Y  \"))",
          "11838:     if (!strcmp(line,\"TX \"))",
          "11840:     if (!strcmp(line,\"TY \"))",
          "11842:   } while (strncmp(line,\"EOHD\",4));",
          "11848:   strcpy (make, \"Rollei\");",
          "11849:   strcpy (model,\"d530flex\");",
          "",
          "[Added Lines]",
          "13008:   fseek(ifp, 0, SEEK_SET);",
          "13009:   memset(&t, 0, sizeof t);",
          "13010:   do",
          "13011:   {",
          "13012:     fgets(line, 128, ifp);",
          "13013:     if ((val = strchr(line, '=')))",
          "13017:     if (!strcmp(line, \"DAT\"))",
          "13018:       sscanf(val, \"%d.%d.%d\", &t.tm_mday, &t.tm_mon, &t.tm_year);",
          "13019:     if (!strcmp(line, \"TIM\"))",
          "13020:       sscanf(val, \"%d:%d:%d\", &t.tm_hour, &t.tm_min, &t.tm_sec);",
          "13021:     if (!strcmp(line, \"HDR\"))",
          "13023:     if (!strcmp(line, \"X  \"))",
          "13025:     if (!strcmp(line, \"Y  \"))",
          "13027:     if (!strcmp(line, \"TX \"))",
          "13029:     if (!strcmp(line, \"TY \"))",
          "13031:   } while (strncmp(line, \"EOHD\", 4));",
          "13037:   strcpy(make, \"Rollei\");",
          "13038:   strcpy(model, \"d530flex\");",
          "",
          "---------------",
          "--- Hunk 96 ---",
          "[Context before]",
          "11856:   char str[8], *cp;",
          "11858:   order = 0x4949;",
          "11860:   entries = get4();",
          "11871:   make[63] = 0;",
          "11875:   }",
          "11877:   raw_height = get2();",
          "11878:   load_raw = &CLASS unpacked_load_raw;",
          "11880:   thumb_height = get2();",
          "11881:   write_thumb = &CLASS ppm_thumb;",
          "11882:   maximum = 0x3fff;",
          "11883: }",
          "11886: {",
          "11887:   unsigned entries, tag, type, len, data, save, i, c;",
          "11888:   float romm_cam[3][3];",
          "11889:   char *cp;",
          "11893:   order = get4() & 0xffff;",
          "11896:   entries = get4();",
          "11897:   get4();",
          "11900:     type = get4();",
          "11902:     data = get4();",
          "11903:     save = ftell(ifp);",
          "11907: #ifdef LIBRAW_LIBRARY_BUILD",
          "11908:     case 0x0102:",
          "11909:       stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "11914:       }",
          "11915:       setPhaseOneFeatures(unique_id);",
          "11916:       break;",
          "11917:     case 0x0401:",
          "11920:       break;",
          "11921:     case 0x0403:",
          "11924:       break;",
          "11925:     case 0x0410:",
          "11926:       stmread(imgdata.lens.makernotes.body, len, ifp);",
          "",
          "[Removed Lines]",
          "11859:   fseek (ifp, 4, SEEK_SET);",
          "11861:   fseek (ifp, get4(), SEEK_SET);",
          "11862:   while (entries--) {",
          "11863:     off = get4(); get4();",
          "11864:     fread (str, 8, 1, ifp);",
          "11865:     if (!strcmp(str,\"META\"))   meta_offset = off;",
          "11866:     if (!strcmp(str,\"THUMB\")) thumb_offset = off;",
          "11867:     if (!strcmp(str,\"RAW0\"))   data_offset = off;",
          "11868:   }",
          "11869:   fseek (ifp, meta_offset+20, SEEK_SET);",
          "11870:   fread (make, 64, 1, ifp);",
          "11872:   if ((cp = strchr(make,' '))) {",
          "11873:     strcpy (model, cp+1);",
          "11876:   raw_width  = get2();",
          "11879:   thumb_width = (get4(),get2());",
          "11885: void CLASS parse_phase_one (int base)",
          "11891:   memset (&ph1, 0, sizeof ph1);",
          "11892:   fseek (ifp, base, SEEK_SET);",
          "11895:   fseek (ifp, get4()+base, SEEK_SET);",
          "11898:   while (entries--) {",
          "11899:     tag  = get4();",
          "11901:     len  = get4();",
          "11904:     fseek (ifp, base+data, SEEK_SET);",
          "11905:     switch (tag) {",
          "11910:       if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49)) {",
          "11911:         unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;",
          "11912:       } else {",
          "11913:         unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;",
          "11918:       if (type == 4) imgdata.lens.makernotes.CurAp =  powf64(2.0f, (int_to_float(data)/2.0f));",
          "11919:       else imgdata.lens.makernotes.CurAp = powf64(2.0f, (getreal(type)/2.0f));",
          "11922:       if (type == 4) imgdata.lens.makernotes.CurFocal =  int_to_float(data);",
          "11923:       else imgdata.lens.makernotes.CurFocal = getreal(type);",
          "",
          "[Added Lines]",
          "13048:   fseek(ifp, 4, SEEK_SET);",
          "13050:   fseek(ifp, get4(), SEEK_SET);",
          "13051:   while (entries--)",
          "13052:   {",
          "13053:     off = get4();",
          "13054:     get4();",
          "13055:     fread(str, 8, 1, ifp);",
          "13056:     if (!strcmp(str, \"META\"))",
          "13057:       meta_offset = off;",
          "13058:     if (!strcmp(str, \"THUMB\"))",
          "13059:       thumb_offset = off;",
          "13060:     if (!strcmp(str, \"RAW0\"))",
          "13061:       data_offset = off;",
          "13062:   }",
          "13063:   fseek(ifp, meta_offset + 20, SEEK_SET);",
          "13064:   fread(make, 64, 1, ifp);",
          "13066:   if ((cp = strchr(make, ' ')))",
          "13067:   {",
          "13068:     strcpy(model, cp + 1);",
          "13071:   raw_width = get2();",
          "13074:   thumb_width = (get4(), get2());",
          "13080: void CLASS parse_phase_one(int base)",
          "13086:   memset(&ph1, 0, sizeof ph1);",
          "13087:   fseek(ifp, base, SEEK_SET);",
          "13089:   if (get4() >> 8 != 0x526177)",
          "13091:   fseek(ifp, get4() + base, SEEK_SET);",
          "13094:   while (entries--)",
          "13095:   {",
          "13096:     tag = get4();",
          "13098:     len = get4();",
          "13101:     fseek(ifp, base + data, SEEK_SET);",
          "13102:     switch (tag)",
          "13103:     {",
          "13108:       if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49))",
          "13109:       {",
          "13110:         unique_id =",
          "13111:             (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;",
          "13112:       }",
          "13113:       else",
          "13114:       {",
          "13115:         unique_id =",
          "13116:             (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;",
          "13121:       if (type == 4)",
          "13122:         imgdata.lens.makernotes.CurAp = powf64(2.0f, (int_to_float(data) / 2.0f));",
          "13123:       else",
          "13124:         imgdata.lens.makernotes.CurAp = powf64(2.0f, (getreal(type) / 2.0f));",
          "13127:       if (type == 4)",
          "13128:         imgdata.lens.makernotes.CurFocal = int_to_float(data);",
          "13129:       else",
          "13130:         imgdata.lens.makernotes.CurFocal = getreal(type);",
          "",
          "---------------",
          "--- Hunk 97 ---",
          "[Context before]",
          "11929:       stmread(imgdata.lens.makernotes.Lens, len, ifp);",
          "11930:       break;",
          "11931:     case 0x0414:",
          "11935:         imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (getreal(type) / 2.0f));",
          "11936:       }",
          "11937:       break;",
          "11938:     case 0x0415:",
          "11942:         imgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (getreal(type) / 2.0f));",
          "11943:       }",
          "11944:       break;",
          "11945:     case 0x0416:",
          "11949:         imgdata.lens.makernotes.MinFocal = getreal(type);",
          "11950:       }",
          "11951:       if (imgdata.lens.makernotes.MinFocal > 1000.0f)",
          "11955:       break;",
          "11956:     case 0x0417:",
          "11960:         imgdata.lens.makernotes.MaxFocal = getreal(type);",
          "11961:       }",
          "11962:       break;",
          "11963: #endif",
          "12013:     order = get2();",
          "12020:       data = get4();",
          "12021:       save = ftell(ifp);",
          "12024:         stmread(imgdata.shootinginfo.BodySerial, len, ifp);",
          "12029:         }",
          "12030:         setPhaseOneFeatures(unique_id);",
          "12031:       }",
          "12033:     }",
          "12034:   }",
          "12035: #endif",
          "12039:   maximum = 0xffff;",
          "12047:   }",
          "12048: }",
          "12051: {",
          "12052:   unsigned entries, tag, len, save, c;",
          "12055:   entries = get4();",
          "12058:     tag = get2();",
          "12059:     len = get2();",
          "12060:     save = ftell(ifp);",
          "12063:       raw_height = get2();",
          "12066:       height = get2();",
          "12069:       fuji_layout = fgetc(ifp) >> 7;",
          "12070:       fuji_width = !(fgetc(ifp) & 8);",
          "12072:       filters = 9;",
          "12075:       FORC4 cam_mul[c ^ 1] = get2();",
          "12078: #ifdef LIBRAW_LIBRARY_BUILD",
          "12095: #endif",
          "12099:       c = order;",
          "12100:       order = 0x4949;",
          "12103:       width = tag;",
          "12104:       height = get4();",
          "12105: #ifdef LIBRAW_LIBRARY_BUILD",
          "12106:       libraw_internal_data.unpacker_data.posRAFData = save;",
          "12108: #endif",
          "12110:     }",
          "12112:   }",
          "12113:   height <<= fuji_layout;",
          "12115: }",
          "12118: {",
          "12119:   int len, save, hlen, mark;",
          "12124:     order = 0x4d4d;",
          "12128:       fgetc(ifp);",
          "12129:       raw_height = get2();",
          "12131:     }",
          "12132:     order = get2();",
          "12135:     {",
          "12136: #ifdef LIBRAW_LIBRARY_BUILD",
          "12137:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "12138:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "12139: #endif",
          "12141:     }",
          "12144:   }",
          "12145:   return 1;",
          "12146: }",
          "",
          "[Removed Lines]",
          "11932:       if (type == 4) {",
          "11933:        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (int_to_float(data)/2.0f));",
          "11934:       } else {",
          "11939:       if (type == 4) {",
          "11940:        imgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (int_to_float(data)/2.0f));",
          "11941:       } else {",
          "11946:       if (type == 4) {",
          "11947:         imgdata.lens.makernotes.MinFocal =  int_to_float(data);",
          "11948:       } else {",
          "11952:         {",
          "11953:           imgdata.lens.makernotes.MinFocal = 0.0f;",
          "11954:         }",
          "11957:       if (type == 4) {",
          "11958:         imgdata.lens.makernotes.MaxFocal =  int_to_float(data);",
          "11959:       } else {",
          "11965:       case 0x100:  flip = \"0653\"[data & 3]-'0';  break;",
          "11966:       case 0x106:",
          "11967:  for (i=0; i < 9; i++)",
          "11968: #ifdef LIBRAW_LIBRARY_BUILD",
          "11969:  imgdata.color.P1_color[0].romm_cam[i]=",
          "11970: #endif",
          "11971:    ((float *)romm_cam)[i] = getreal(11);",
          "11972:  romm_coeff (romm_cam);",
          "11973:  break;",
          "11974:       case 0x107:",
          "11975:  FORC3 cam_mul[c] = getreal(11);",
          "11976:  break;",
          "11977:       case 0x108:  raw_width     = data; break;",
          "11978:       case 0x109:  raw_height    = data; break;",
          "11979:       case 0x10a:  left_margin   = data; break;",
          "11980:       case 0x10b:  top_margin    = data; break;",
          "11981:       case 0x10c:  width         = data; break;",
          "11982:       case 0x10d:  height        = data; break;",
          "11983:       case 0x10e:  ph1.format    = data; break;",
          "11984:       case 0x10f:  data_offset   = data+base; break;",
          "11985:       case 0x110:  meta_offset   = data+base;",
          "11986:      meta_length   = len;   break;",
          "11987:       case 0x112:  ph1.key_off   = save - 4;  break;",
          "11988:       case 0x210:  ph1.tag_210   = int_to_float(data); break;",
          "11989:       case 0x21a:  ph1.tag_21a   = data;  break;",
          "11990:       case 0x21c:  strip_offset  = data+base;  break;",
          "11991:       case 0x21d:  ph1.t_black     = data;  break;",
          "11992:       case 0x222:  ph1.split_col = data;  break;",
          "11993:       case 0x223:  ph1.black_col = data+base;  break;",
          "11994:       case 0x224:  ph1.split_row = data;  break;",
          "11995:       case 0x225:  ph1.black_row = data+base;  break;",
          "11996: #ifdef LIBRAW_LIBRARY_BUILD",
          "11997:       case 0x226:",
          "11998:  for (i=0; i < 9; i++)",
          "11999:    imgdata.color.P1_color[1].romm_cam[i] = getreal(11);",
          "12000:  break;",
          "12001: #endif",
          "12002:       case 0x301:",
          "12003:  model[63] = 0;",
          "12004:  fread (model, 1, 63, ifp);",
          "12005:  if ((cp = strstr(model,\" camera\"))) *cp = 0;",
          "12006:     }",
          "12007:     fseek (ifp, save, SEEK_SET);",
          "12008:   }",
          "12010: #ifdef LIBRAW_LIBRARY_BUILD",
          "12011:   if (!imgdata.lens.makernotes.body[0] && !imgdata.shootinginfo.BodySerial[0]) {",
          "12012:     fseek (ifp, meta_offset, SEEK_SET);",
          "12014:     fseek (ifp, 6, SEEK_CUR);",
          "12015:     fseek (ifp, meta_offset+get4(), SEEK_SET);",
          "12016:     entries = get4();  get4();",
          "12017:     while (entries--) {",
          "12018:       tag  = get4();",
          "12019:       len  = get4();",
          "12022:       fseek (ifp, meta_offset+data, SEEK_SET);",
          "12023:       if (tag == 0x0407) {",
          "12025:         if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49)) {",
          "12026:           unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;",
          "12027:         } else {",
          "12028:           unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;",
          "12032:       fseek (ifp, save, SEEK_SET);",
          "12037:   load_raw = ph1.format < 3 ?",
          "12038:  &CLASS phase_one_load_raw : &CLASS phase_one_load_raw_c;",
          "12040:   strcpy (make, \"Phase One\");",
          "12041:   if (model[0]) return;",
          "12042:   switch (raw_height) {",
          "12043:     case 2060: strcpy (model,\"LightPhase\"); break;",
          "12044:     case 2682: strcpy (model,\"H 10\");  break;",
          "12045:     case 4128: strcpy (model,\"H 20\");  break;",
          "12046:     case 5488: strcpy (model,\"H 25\");  break;",
          "12050: void CLASS parse_fuji (int offset)",
          "12054:   fseek (ifp, offset, SEEK_SET);",
          "12056:   if (entries > 255) return;",
          "12057:   while (entries--) {",
          "12062:     if (tag == 0x100) {",
          "12064:       raw_width  = get2();",
          "12065:     } else if (tag == 0x121) {",
          "12067:       if ((width = get2()) == 4284) width += 3;",
          "12068:     } else if (tag == 0x130) {",
          "12071:     } else if (tag == 0x131) {",
          "12073:       FORC(36) xtrans_abs[0][35-c] = fgetc(ifp) & 3;",
          "12074:     } else if (tag == 0x2ff0) {",
          "12079:     } else if (tag == 0x9650) {",
          "12080:       imgdata.makernotes.fuji.FujiExpoMidPointShift = ((short)get2()) / fMAX(1.0f,get2());",
          "12081:     } else if (tag == 0x2100) {",
          "12082:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ 1] = get2();",
          "12083:     } else if (tag == 0x2200) {",
          "12084:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ 1] = get2();",
          "12085:     } else if (tag == 0x2300) {",
          "12086:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ 1] = get2();",
          "12087:     } else if (tag == 0x2301) {",
          "12088:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ 1] = get2();",
          "12089:     } else if (tag == 0x2302) {",
          "12090:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ 1] = get2();",
          "12091:     } else if (tag == 0x2310) {",
          "12092:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ 1] = get2();",
          "12093:     } else if (tag == 0x2400) {",
          "12094:         FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ 1] = get2();",
          "12098:     } else if (tag == 0xc000) {",
          "12101:       if ((tag = get4()) > 10000) tag = get4();",
          "12102:       if (tag > 10000) tag = get4();",
          "12107:       libraw_internal_data.unpacker_data.lenRAFData = (len>>1);",
          "12109:    order = c;",
          "12111:     fseek (ifp, save+len, SEEK_SET);",
          "12114:   width  >>= fuji_layout;",
          "12117: int CLASS parse_jpeg (int offset)",
          "12120:   fseek (ifp, offset, SEEK_SET);",
          "12121:   if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) return 0;",
          "12123:   while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda) {",
          "12125:     len   = get2() - 2;",
          "12126:     save  = ftell(ifp);",
          "12127:     if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9) {",
          "12130:       raw_width  = get2();",
          "12133:     hlen  = get4();",
          "12140:       parse_ciff (save+hlen, len-hlen, 0);",
          "12142:     if (parse_tiff (save+6)) apply_tiff();",
          "12143:     fseek (ifp, save+len, SEEK_SET);",
          "",
          "[Added Lines]",
          "13139:       if (type == 4)",
          "13140:       {",
          "13141:         imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (int_to_float(data) / 2.0f));",
          "13142:       }",
          "13143:       else",
          "13144:       {",
          "13149:       if (type == 4)",
          "13150:       {",
          "13151:         imgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (int_to_float(data) / 2.0f));",
          "13152:       }",
          "13153:       else",
          "13154:       {",
          "13159:       if (type == 4)",
          "13160:       {",
          "13161:         imgdata.lens.makernotes.MinFocal = int_to_float(data);",
          "13162:       }",
          "13163:       else",
          "13164:       {",
          "13168:       {",
          "13169:         imgdata.lens.makernotes.MinFocal = 0.0f;",
          "13170:       }",
          "13173:       if (type == 4)",
          "13174:       {",
          "13175:         imgdata.lens.makernotes.MaxFocal = int_to_float(data);",
          "13176:       }",
          "13177:       else",
          "13178:       {",
          "13184:     case 0x100:",
          "13185:       flip = \"0653\"[data & 3] - '0';",
          "13186:       break;",
          "13187:     case 0x106:",
          "13188:       for (i = 0; i < 9; i++)",
          "13189: #ifdef LIBRAW_LIBRARY_BUILD",
          "13190:         imgdata.color.P1_color[0].romm_cam[i] =",
          "13191: #endif",
          "13192:             ((float *)romm_cam)[i] = getreal(11);",
          "13193:       romm_coeff(romm_cam);",
          "13194:       break;",
          "13195:     case 0x107:",
          "13196:       FORC3 cam_mul[c] = getreal(11);",
          "13197:       break;",
          "13198:     case 0x108:",
          "13199:       raw_width = data;",
          "13200:       break;",
          "13201:     case 0x109:",
          "13202:       raw_height = data;",
          "13203:       break;",
          "13204:     case 0x10a:",
          "13205:       left_margin = data;",
          "13206:       break;",
          "13207:     case 0x10b:",
          "13208:       top_margin = data;",
          "13209:       break;",
          "13210:     case 0x10c:",
          "13211:       width = data;",
          "13212:       break;",
          "13213:     case 0x10d:",
          "13214:       height = data;",
          "13215:       break;",
          "13216:     case 0x10e:",
          "13217:       ph1.format = data;",
          "13218:       break;",
          "13219:     case 0x10f:",
          "13220:       data_offset = data + base;",
          "13221:       break;",
          "13222:     case 0x110:",
          "13223:       meta_offset = data + base;",
          "13224:       meta_length = len;",
          "13225:       break;",
          "13226:     case 0x112:",
          "13227:       ph1.key_off = save - 4;",
          "13228:       break;",
          "13229:     case 0x210:",
          "13230:       ph1.tag_210 = int_to_float(data);",
          "13231:       break;",
          "13232:     case 0x21a:",
          "13233:       ph1.tag_21a = data;",
          "13234:       break;",
          "13235:     case 0x21c:",
          "13236:       strip_offset = data + base;",
          "13237:       break;",
          "13238:     case 0x21d:",
          "13239:       ph1.t_black = data;",
          "13240:       break;",
          "13241:     case 0x222:",
          "13242:       ph1.split_col = data;",
          "13243:       break;",
          "13244:     case 0x223:",
          "13245:       ph1.black_col = data + base;",
          "13246:       break;",
          "13247:     case 0x224:",
          "13248:       ph1.split_row = data;",
          "13249:       break;",
          "13250:     case 0x225:",
          "13251:       ph1.black_row = data + base;",
          "13252:       break;",
          "13253: #ifdef LIBRAW_LIBRARY_BUILD",
          "13254:     case 0x226:",
          "13255:       for (i = 0; i < 9; i++)",
          "13256:         imgdata.color.P1_color[1].romm_cam[i] = getreal(11);",
          "13257:       break;",
          "13258: #endif",
          "13259:     case 0x301:",
          "13260:       model[63] = 0;",
          "13261:       fread(model, 1, 63, ifp);",
          "13262:       if ((cp = strstr(model, \" camera\")))",
          "13264:     }",
          "13265:     fseek(ifp, save, SEEK_SET);",
          "13266:   }",
          "13268: #ifdef LIBRAW_LIBRARY_BUILD",
          "13269:   if (!imgdata.lens.makernotes.body[0] && !imgdata.shootinginfo.BodySerial[0])",
          "13270:   {",
          "13271:     fseek(ifp, meta_offset, SEEK_SET);",
          "13273:     fseek(ifp, 6, SEEK_CUR);",
          "13274:     fseek(ifp, meta_offset + get4(), SEEK_SET);",
          "13275:     entries = get4();",
          "13276:     get4();",
          "13277:     while (entries--)",
          "13278:     {",
          "13279:       tag = get4();",
          "13280:       len = get4();",
          "13283:       fseek(ifp, meta_offset + data, SEEK_SET);",
          "13284:       if (tag == 0x0407)",
          "13285:       {",
          "13287:         if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49))",
          "13288:         {",
          "13289:           unique_id =",
          "13290:               (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;",
          "13291:         }",
          "13292:         else",
          "13293:         {",
          "13294:           unique_id =",
          "13295:               (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;",
          "13299:       fseek(ifp, save, SEEK_SET);",
          "13304:   load_raw = ph1.format < 3 ? &CLASS phase_one_load_raw : &CLASS phase_one_load_raw_c;",
          "13306:   strcpy(make, \"Phase One\");",
          "13307:   if (model[0])",
          "13308:     return;",
          "13309:   switch (raw_height)",
          "13310:   {",
          "13311:   case 2060:",
          "13312:     strcpy(model, \"LightPhase\");",
          "13313:     break;",
          "13314:   case 2682:",
          "13315:     strcpy(model, \"H 10\");",
          "13316:     break;",
          "13317:   case 4128:",
          "13318:     strcpy(model, \"H 20\");",
          "13319:     break;",
          "13320:   case 5488:",
          "13321:     strcpy(model, \"H 25\");",
          "13322:     break;",
          "13326: void CLASS parse_fuji(int offset)",
          "13330:   fseek(ifp, offset, SEEK_SET);",
          "13332:   if (entries > 255)",
          "13333:     return;",
          "13334:   while (entries--)",
          "13335:   {",
          "13340:     if (tag == 0x100)",
          "13341:     {",
          "13343:       raw_width = get2();",
          "13344:     }",
          "13345:     else if (tag == 0x121)",
          "13346:     {",
          "13348:       if ((width = get2()) == 4284)",
          "13349:         width += 3;",
          "13350:     }",
          "13351:     else if (tag == 0x130)",
          "13352:     {",
          "13355:     }",
          "13356:     else if (tag == 0x131)",
          "13357:     {",
          "13359:       FORC(36) xtrans_abs[0][35 - c] = fgetc(ifp) & 3;",
          "13360:     }",
          "13361:     else if (tag == 0x2ff0)",
          "13362:     {",
          "13367:     }",
          "13368:     else if (tag == 0x9650)",
          "13369:     {",
          "13370:       imgdata.makernotes.fuji.FujiExpoMidPointShift = ((short)get2()) / fMAX(1.0f, get2());",
          "13371:     }",
          "13372:     else if (tag == 0x2100)",
          "13373:     {",
          "13374:       FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ 1] = get2();",
          "13375:     }",
          "13376:     else if (tag == 0x2200)",
          "13377:     {",
          "13378:       FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ 1] = get2();",
          "13379:     }",
          "13380:     else if (tag == 0x2300)",
          "13381:     {",
          "13382:       FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ 1] = get2();",
          "13383:     }",
          "13384:     else if (tag == 0x2301)",
          "13385:     {",
          "13386:       FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ 1] = get2();",
          "13387:     }",
          "13388:     else if (tag == 0x2302)",
          "13389:     {",
          "13390:       FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ 1] = get2();",
          "13391:     }",
          "13392:     else if (tag == 0x2310)",
          "13393:     {",
          "13394:       FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ 1] = get2();",
          "13395:     }",
          "13396:     else if (tag == 0x2400)",
          "13397:     {",
          "13398:       FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ 1] = get2();",
          "13401:     }",
          "13402:     else if (tag == 0xc000)",
          "13403:     {",
          "13406:       if ((tag = get4()) > 10000)",
          "13407:         tag = get4();",
          "13408:       if (tag > 10000)",
          "13409:         tag = get4();",
          "13414:       libraw_internal_data.unpacker_data.lenRAFData = (len >> 1);",
          "13416:       order = c;",
          "13418:     fseek(ifp, save + len, SEEK_SET);",
          "13421:   width >>= fuji_layout;",
          "13424: int CLASS parse_jpeg(int offset)",
          "13427:   fseek(ifp, offset, SEEK_SET);",
          "13428:   if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)",
          "13429:     return 0;",
          "13431:   while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda)",
          "13432:   {",
          "13434:     len = get2() - 2;",
          "13435:     save = ftell(ifp);",
          "13436:     if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9)",
          "13437:     {",
          "13440:       raw_width = get2();",
          "13443:     hlen = get4();",
          "13450:       parse_ciff(save + hlen, len - hlen, 0);",
          "13452:     if (parse_tiff(save + 6))",
          "13453:       apply_tiff();",
          "13454:     fseek(ifp, save + len, SEEK_SET);",
          "",
          "---------------",
          "--- Hunk 98 ---",
          "[Context before]",
          "12149: {",
          "12150:   unsigned i, size, end;",
          "12151:   char tag[4], date[64], month[64];",
          "12154:   struct tm t;",
          "12156:   order = 0x4949;",
          "12158:   size = get4();",
          "12159:   end = ftell(ifp) + size;",
          "12161:     int maxloop = 1000;",
          "12162:     get4();",
          "12164:       parse_riff();",
          "12167:       i = get2();",
          "12168:       size = get2();",
          "12172:     }",
          "12175:     date[size] = 0;",
          "12180:       t.tm_mon = i;",
          "12181:       t.tm_year -= 1900;",
          "12182:       if (mktime(&t) > 0)",
          "12184:     }",
          "12187: }",
          "12190: {",
          "12191:   unsigned save, size;",
          "12192:   char tag[4];",
          "12194:   order = 0x4d4d;",
          "12196:     save = ftell(ifp);",
          "12206:   }",
          "12207: }",
          "12210: {",
          "12211:   int ver;",
          "12214:   order = 0x4949;",
          "12215:   ver = fgetc(ifp);",
          "12216:   if (ver == 6)",
          "12220:   raw_height = height = get2();",
          "12226: }",
          "12228: void CLASS parse_cine()",
          "",
          "[Removed Lines]",
          "12152:   static const char mon[12][4] =",
          "12153:   { \"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\" };",
          "12157:   fread (tag, 4, 1, ifp);",
          "12160:   if (!memcmp(tag,\"RIFF\",4) || !memcmp(tag,\"LIST\",4)) {",
          "12163:     while (ftell(ifp)+7 < end && !feof(ifp) && maxloop--)",
          "12165:   } else if (!memcmp(tag,\"nctg\",4)) {",
          "12166:     while (ftell(ifp)+7 < end) {",
          "12169:       if ((i+1) >> 1 == 10 && size == 20)",
          "12170:  get_timestamp(0);",
          "12171:       else fseek (ifp, size, SEEK_CUR);",
          "12173:   } else if (!memcmp(tag,\"IDIT\",4) && size < 64) {",
          "12174:     fread (date, 64, 1, ifp);",
          "12176:     memset (&t, 0, sizeof t);",
          "12177:     if (sscanf (date, \"%*s %s %d %d:%d:%d %d\", month, &t.tm_mday,",
          "12178:  &t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6) {",
          "12179:       for (i=0; i < 12 && strcasecmp(mon[i],month); i++);",
          "12183:  timestamp = mktime(&t);",
          "12185:   } else",
          "12186:     fseek (ifp, size, SEEK_CUR);",
          "12189: void CLASS parse_qt (int end)",
          "12195:   while (ftell(ifp)+7 < end) {",
          "12197:     if ((size = get4()) < 8) return;",
          "12198:     fread (tag, 4, 1, ifp);",
          "12199:     if (!memcmp(tag,\"moov\",4) ||",
          "12200:  !memcmp(tag,\"udta\",4) ||",
          "12201:  !memcmp(tag,\"CNTH\",4))",
          "12202:       parse_qt (save+size);",
          "12203:     if (!memcmp(tag,\"CNDA\",4))",
          "12204:       parse_jpeg (ftell(ifp));",
          "12205:     fseek (ifp, save+size, SEEK_SET);",
          "12209: void CLASS parse_smal (int offset, int fsize)",
          "12213:   fseek (ifp, offset+2, SEEK_SET);",
          "12217:     fseek (ifp, 5, SEEK_CUR);",
          "12218:   if (get4() != fsize) return;",
          "12219:   if (ver > 6) data_offset = get4();",
          "12221:   raw_width  = width  = get2();",
          "12222:   strcpy (make, \"SMaL\");",
          "12223:   sprintf (model, \"v%d %dx%d\", ver, width, height);",
          "12224:   if (ver == 6) load_raw = &CLASS smal_v6_load_raw;",
          "12225:   if (ver == 9) load_raw = &CLASS smal_v9_load_raw;",
          "",
          "[Added Lines]",
          "13463:   static const char mon[12][4] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};",
          "13467:   fread(tag, 4, 1, ifp);",
          "13470:   if (!memcmp(tag, \"RIFF\", 4) || !memcmp(tag, \"LIST\", 4))",
          "13471:   {",
          "13474:     while (ftell(ifp) + 7 < end && !feof(ifp) && maxloop--)",
          "13476:   }",
          "13477:   else if (!memcmp(tag, \"nctg\", 4))",
          "13478:   {",
          "13479:     while (ftell(ifp) + 7 < end)",
          "13480:     {",
          "13483:       if ((i + 1) >> 1 == 10 && size == 20)",
          "13484:         get_timestamp(0);",
          "13485:       else",
          "13486:         fseek(ifp, size, SEEK_CUR);",
          "13488:   }",
          "13489:   else if (!memcmp(tag, \"IDIT\", 4) && size < 64)",
          "13490:   {",
          "13491:     fread(date, 64, 1, ifp);",
          "13493:     memset(&t, 0, sizeof t);",
          "13494:     if (sscanf(date, \"%*s %s %d %d:%d:%d %d\", month, &t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6)",
          "13495:     {",
          "13496:       for (i = 0; i < 12 && strcasecmp(mon[i], month); i++)",
          "13497:         ;",
          "13501:         timestamp = mktime(&t);",
          "13503:   }",
          "13504:   else",
          "13505:     fseek(ifp, size, SEEK_CUR);",
          "13508: void CLASS parse_qt(int end)",
          "13514:   while (ftell(ifp) + 7 < end)",
          "13515:   {",
          "13517:     if ((size = get4()) < 8)",
          "13518:       return;",
          "13519:     fread(tag, 4, 1, ifp);",
          "13520:     if (!memcmp(tag, \"moov\", 4) || !memcmp(tag, \"udta\", 4) || !memcmp(tag, \"CNTH\", 4))",
          "13521:       parse_qt(save + size);",
          "13522:     if (!memcmp(tag, \"CNDA\", 4))",
          "13523:       parse_jpeg(ftell(ifp));",
          "13524:     fseek(ifp, save + size, SEEK_SET);",
          "13528: void CLASS parse_smal(int offset, int fsize)",
          "13532:   fseek(ifp, offset + 2, SEEK_SET);",
          "13536:     fseek(ifp, 5, SEEK_CUR);",
          "13537:   if (get4() != fsize)",
          "13538:     return;",
          "13539:   if (ver > 6)",
          "13540:     data_offset = get4();",
          "13542:   raw_width = width = get2();",
          "13543:   strcpy(make, \"SMaL\");",
          "13544:   sprintf(model, \"v%d %dx%d\", ver, width, height);",
          "13545:   if (ver == 6)",
          "13546:     load_raw = &CLASS smal_v6_load_raw;",
          "13547:   if (ver == 9)",
          "13548:     load_raw = &CLASS smal_v9_load_raw;",
          "",
          "---------------",
          "--- Hunk 99 ---",
          "[Context before]",
          "12230:   unsigned off_head, off_setup, off_image, i;",
          "12232:   order = 0x4949;",
          "12234:   is_raw = get2() == 2;",
          "12236:   is_raw *= get4();",
          "12237:   off_head = get4();",
          "12238:   off_setup = get4();",
          "12239:   off_image = get4();",
          "12240:   timestamp = get4();",
          "12243:   raw_width = get4();",
          "12244:   raw_height = get4();",
          "12264:   }",
          "12265:   cam_mul[0] = getreal(11);",
          "12266:   cam_mul[2] = getreal(11);",
          "12267:   maximum = ~((~0u) << get4());",
          "12271:   if (shot_select < is_raw)",
          "12275: }",
          "12277: void CLASS parse_redcine()",
          "",
          "[Removed Lines]",
          "12233:   fseek (ifp, 4, SEEK_SET);",
          "12235:   fseek (ifp, 14, SEEK_CUR);",
          "12241:   if ((i = get4())) timestamp = i;",
          "12242:   fseek (ifp, off_head+4, SEEK_SET);",
          "12245:   switch (get2(),get2()) {",
          "12246:     case  8:  load_raw = &CLASS eight_bit_load_raw;  break;",
          "12247:     case 16:  load_raw = &CLASS  unpacked_load_raw;",
          "12248:   }",
          "12249:   fseek (ifp, off_setup+792, SEEK_SET);",
          "12250:   strcpy (make, \"CINE\");",
          "12251:   sprintf (model, \"%d\", get4());",
          "12252:   fseek (ifp, 12, SEEK_CUR);",
          "12253:   switch ((i=get4()) & 0xffffff) {",
          "12254:     case  3:  filters = 0x94949494;  break;",
          "12255:     case  4:  filters = 0x49494949;  break;",
          "12256:     default:  is_raw = 0;",
          "12257:   }",
          "12258:   fseek (ifp, 72, SEEK_CUR);",
          "12259:   switch ((get4()+3600) % 360) {",
          "12260:     case 270:  flip = 4;  break;",
          "12261:     case 180:  flip = 1;  break;",
          "12262:     case  90:  flip = 7;  break;",
          "12263:     case   0:  flip = 2;",
          "12268:   fseek (ifp, 668, SEEK_CUR);",
          "12269:   shutter = get4()/1000000000.0;",
          "12270:   fseek (ifp, off_image, SEEK_SET);",
          "12272:     fseek (ifp, shot_select*8, SEEK_CUR);",
          "12273:   data_offset  = (INT64) get4() + 8;",
          "12274:   data_offset += (INT64) get4() << 32;",
          "",
          "[Added Lines]",
          "13556:   fseek(ifp, 4, SEEK_SET);",
          "13558:   fseek(ifp, 14, SEEK_CUR);",
          "13564:   if ((i = get4()))",
          "13565:     timestamp = i;",
          "13566:   fseek(ifp, off_head + 4, SEEK_SET);",
          "13569:   switch (get2(), get2())",
          "13570:   {",
          "13571:   case 8:",
          "13572:     load_raw = &CLASS eight_bit_load_raw;",
          "13573:     break;",
          "13574:   case 16:",
          "13575:     load_raw = &CLASS unpacked_load_raw;",
          "13576:   }",
          "13577:   fseek(ifp, off_setup + 792, SEEK_SET);",
          "13578:   strcpy(make, \"CINE\");",
          "13579:   sprintf(model, \"%d\", get4());",
          "13580:   fseek(ifp, 12, SEEK_CUR);",
          "13581:   switch ((i = get4()) & 0xffffff)",
          "13582:   {",
          "13583:   case 3:",
          "13584:     filters = 0x94949494;",
          "13585:     break;",
          "13586:   case 4:",
          "13587:     filters = 0x49494949;",
          "13588:     break;",
          "13589:   default:",
          "13590:     is_raw = 0;",
          "13591:   }",
          "13592:   fseek(ifp, 72, SEEK_CUR);",
          "13593:   switch ((get4() + 3600) % 360)",
          "13594:   {",
          "13595:   case 270:",
          "13596:     flip = 4;",
          "13597:     break;",
          "13598:   case 180:",
          "13599:     flip = 1;",
          "13600:     break;",
          "13601:   case 90:",
          "13602:     flip = 7;",
          "13603:     break;",
          "13604:   case 0:",
          "13605:     flip = 2;",
          "13610:   fseek(ifp, 668, SEEK_CUR);",
          "13611:   shutter = get4() / 1000000000.0;",
          "13612:   fseek(ifp, off_image, SEEK_SET);",
          "13614:     fseek(ifp, shot_select * 8, SEEK_CUR);",
          "13615:   data_offset = (INT64)get4() + 8;",
          "13616:   data_offset += (INT64)get4() << 32;",
          "",
          "---------------",
          "--- Hunk 100 ---",
          "[Context before]",
          "12281:   order = 0x4d4d;",
          "12282:   is_raw = 0;",
          "12285:   height = get4();",
          "12289: #ifdef DCRAW_VERBOSE",
          "12291: #endif",
          "12294:       if (get4() == 0x52454456)",
          "12298:     }",
          "12300:     rdvo = get4();",
          "12302:     is_raw = get4();",
          "12304:     data_offset = get4();",
          "12305:   }",
          "12306: }",
          "",
          "[Removed Lines]",
          "12283:   fseek (ifp, 52, SEEK_SET);",
          "12284:   width  = get4();",
          "12286:   fseek (ifp, 0, SEEK_END);",
          "12287:   fseek (ifp, -(i = ftello(ifp) & 511), SEEK_CUR);",
          "12288:   if (get4() != i || get4() != 0x52454f42) {",
          "12290:     fprintf (stderr,_(\"%s: Tail is missing, parsing from head...\\n\"), ifname);",
          "12292:     fseek (ifp, 0, SEEK_SET);",
          "12293:     while ((len = get4()) != EOF) {",
          "12295:  if (is_raw++ == shot_select)",
          "12296:    data_offset = ftello(ifp) - 8;",
          "12297:       fseek (ifp, len-8, SEEK_CUR);",
          "12299:   } else {",
          "12301:     fseek (ifp, 12, SEEK_CUR);",
          "12303:     fseeko (ifp, rdvo+8 + shot_select*4, SEEK_SET);",
          "",
          "[Added Lines]",
          "13625:   fseek(ifp, 52, SEEK_SET);",
          "13626:   width = get4();",
          "13628:   fseek(ifp, 0, SEEK_END);",
          "13629:   fseek(ifp, -(i = ftello(ifp) & 511), SEEK_CUR);",
          "13630:   if (get4() != i || get4() != 0x52454f42)",
          "13631:   {",
          "13633:     fprintf(stderr, _(\"%s: Tail is missing, parsing from head...\\n\"), ifname);",
          "13635:     fseek(ifp, 0, SEEK_SET);",
          "13636:     while ((len = get4()) != EOF)",
          "13637:     {",
          "13639:         if (is_raw++ == shot_select)",
          "13640:           data_offset = ftello(ifp) - 8;",
          "13641:       fseek(ifp, len - 8, SEEK_CUR);",
          "13643:   }",
          "13644:   else",
          "13645:   {",
          "13647:     fseek(ifp, 12, SEEK_CUR);",
          "13649:     fseeko(ifp, rdvo + 8 + shot_select * 4, SEEK_SET);",
          "",
          "---------------",
          "--- Hunk 101 ---",
          "[Context before]",
          "12309:    All matrices are from Adobe DNG Converter unless otherwise noted.",
          "12312: #ifdef LIBRAW_LIBRARY_BUILD",
          "12314: #endif",
          "12316: {",
          "12318:     const char *prefix;",
          "12319:     int t_black, t_maximum, trans[12];",
          "12320:   } table[] = {",
          "13514:   };",
          "13515:   double cam_xyz[4][3];",
          "13516:   char name[130];",
          "13517:   int i, j;",
          "13523:   {",
          "13527:   }",
          "13550: #ifdef LIBRAW_LIBRARY_BUILD",
          "13555: #endif",
          "13557: #ifdef LIBRAW_LIBRARY_BUILD",
          "13559: #endif",
          "13561:       }",
          "13562:       break;",
          "13563:     }",
          "13564: }",
          "13567: {",
          "13580:   int i, c;",
          "13584: }",
          "13587: {",
          "13588:   uchar test[4][2];",
          "13599:     }",
          "13601:   }",
          "13602:   return sum[0] < sum[1] ? 0x4d4d : 0x4949;",
          "13603: }",
          "13606: {",
          "13608:   int vbits, col, i, c;",
          "13609:   ushort img[2][2064];",
          "13619:       }",
          "13621:     }",
          "13622:   }",
          "13626:   }",
          "13628: }",
          "13630: #ifdef LIBRAW_LIBRARY_BUILD",
          "13631: static void remove_trailing_spaces(char *string, size_t len)",
          "13632: {",
          "13638:   {",
          "13641:     else",
          "13642:       break;",
          "13643:   }",
          "13644: }",
          "13647: #endif",
          "13649:    Identify which camera created this file, and set global variables",
          "",
          "[Removed Lines]",
          "12311: void CLASS adobe_coeff (const char *t_make, const char *t_model",
          "12313:  ,int internal_only",
          "12315: )",
          "12317:   static const struct {",
          "12322:       { 11438,-3762,-1115,-2409,9914,2497,-1227,2295,5300 } },",
          "12324:       { 21392,-5653,-3353,2406,8010,-415,7166,1427,2078 } },",
          "12325:     {\"Broadcom RPi IMX219\", 66, 0x3ff,",
          "12327:     { \"Broadcom RPi OV5647\", 16, 0x3ff,",
          "12329:     { \"Canon EOS D2000\", 0, 0,",
          "12330:       { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },",
          "12331:     { \"Canon EOS D6000\", 0, 0,",
          "12332:       { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },",
          "12333:     { \"Canon EOS D30\", 0, 0,",
          "12334:       { 9805,-2689,-1312,-5803,13064,3068,-2438,3075,8775 } },",
          "12335:     { \"Canon EOS D60\", 0, 0xfa0,",
          "12336:       { 6188,-1341,-890,-7168,14489,2937,-2640,3228,8483 } },",
          "12337:     { \"Canon EOS 5DS\", 0, 0x3c96,",
          "12338:       { 6250,-711,-808,-5153,12794,2636,-1249,2198,5610 } },",
          "12339:     { \"Canon EOS 5D Mark IV\", 0, 0,",
          "12340:       { 6446, -366, -864, -4436, 12204, 2513, -952, 2496, 6348 }},",
          "12341:     { \"Canon EOS 5D Mark III\", 0, 0x3c80,",
          "12342:       { 6722,-635,-963,-4287,12460,2028,-908,2162,5668 } },",
          "12343:     { \"Canon EOS 5D Mark II\", 0, 0x3cf0,",
          "12344:       { 4716,603,-830,-7798,15474,2480,-1496,1937,6651 } },",
          "12345:     { \"Canon EOS 5D\", 0, 0xe6c,",
          "12346:       { 6347,-479,-972,-8297,15954,2480,-1968,2131,7649 } },",
          "12347:     { \"Canon EOS 6D\", 0, 0x3c82,",
          "12348:       { 8621,-2197,-787,-3150,11358,912,-1161,2400,4836 } },",
          "12349:     { \"Canon EOS 7D Mark II\", 0, 0x3510,",
          "12350:       { 7268,-1082,-969,-4186,11839,2663,-825,2029,5839 } },",
          "12351:     { \"Canon EOS 7D\", 0, 0x3510,",
          "12352:       { 6844,-996,-856,-3876,11761,2396,-593,1772,6198 } },",
          "12353:     { \"Canon EOS 80D\", 0, 0,",
          "12354:       { 7457,-671,-937,-4849,12495,2643,-1213,2354,5492 } },",
          "12355:     { \"Canon EOS 10D\", 0, 0xfa0,",
          "12356:       { 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },",
          "12357:     { \"Canon EOS 20Da\", 0, 0,",
          "12358:       { 14155,-5065,-1382,-6550,14633,2039,-1623,1824,6561 } },",
          "12359:     { \"Canon EOS 20D\", 0, 0xfff,",
          "12360:       { 6599,-537,-891,-8071,15783,2424,-1983,2234,7462 } },",
          "12361:     { \"Canon EOS 30D\", 0, 0,",
          "12362:       { 6257,-303,-1000,-7880,15621,2396,-1714,1904,7046 } },",
          "12363:     { \"Canon EOS 40D\", 0, 0x3f60,",
          "12364:       { 6071,-747,-856,-7653,15365,2441,-2025,2553,7315 } },",
          "12365:     { \"Canon EOS 50D\", 0, 0x3d93,",
          "12366:       { 4920,616,-593,-6493,13964,2784,-1774,3178,7005 } },",
          "12367:     { \"Canon EOS 60D\", 0, 0x2ff7,",
          "12368:       { 6719,-994,-925,-4408,12426,2211,-887,2129,6051 } },",
          "12369:     { \"Canon EOS 70D\", 0, 0x3bc7,",
          "12370:       { 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },",
          "12371:     { \"Canon EOS 100D\", 0, 0x350f,",
          "12372:       { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },",
          "12373:     { \"Canon EOS 300D\", 0, 0xfa0,",
          "12374:       { 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },",
          "12375:     { \"Canon EOS 350D\", 0, 0xfff,",
          "12376:       { 6018,-617,-965,-8645,15881,2975,-1530,1719,7642 } },",
          "12377:     { \"Canon EOS 400D\", 0, 0xe8e,",
          "12378:       { 7054,-1501,-990,-8156,15544,2812,-1278,1414,7796 } },",
          "12379:     { \"Canon EOS 450D\", 0, 0x390d,",
          "12380:       { 5784,-262,-821,-7539,15064,2672,-1982,2681,7427 } },",
          "12381:     { \"Canon EOS 500D\", 0, 0x3479,",
          "12382:       { 4763,712,-646,-6821,14399,2640,-1921,3276,6561 } },",
          "12383:     { \"Canon EOS 550D\", 0, 0x3dd7,",
          "12384:       { 6941,-1164,-857,-3825,11597,2534,-416,1540,6039 } },",
          "12385:     { \"Canon EOS 600D\", 0, 0x3510,",
          "12386:       { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },",
          "12387:     { \"Canon EOS 650D\", 0, 0x354d,",
          "12388:       { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },",
          "12389:     { \"Canon EOS 750D\", 0, 0x3c00,",
          "12390:       { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },",
          "12391:     { \"Canon EOS 760D\", 0, 0x3c00,",
          "12392:       { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },",
          "12393:     { \"Canon EOS 700D\", 0, 0x3c00,",
          "12394:       { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },",
          "12395:     { \"Canon EOS 1000D\", 0, 0xe43,",
          "12396:       { 6771,-1139,-977,-7818,15123,2928,-1244,1437,7533 } },",
          "12397:     { \"Canon EOS 1100D\", 0, 0x3510,",
          "12398:       { 6444,-904,-893,-4563,12308,2535,-903,2016,6728 } },",
          "12399:     { \"Canon EOS 1200D\", 0, 0x37c2,",
          "12400:       { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },",
          "12401:     { \"Canon EOS 1300D\", 0, 0x37c2,",
          "12402:       { 6939, -1016, -866, -4428, 12473, 2177, -1175, 2178, 6162 } },",
          "12403:     { \"Canon EOS M3\", 0, 0,",
          "12404:       { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },",
          "12406:       { 8532, -701, -1167, -4095, 11879, 2508, -797, 2424, 7010 }},",
          "12407:     { \"Canon EOS M10\", 0, 0,",
          "12408:       { 6400,-480,-888,-5294,13416,2047,-1296,2203,6137 } },",
          "12409:     { \"Canon EOS M\", 0, 0,",
          "12410:       { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },",
          "12411:     { \"Canon EOS-1Ds Mark III\", 0, 0x3bb0,",
          "12412:       { 5859,-211,-930,-8255,16017,2353,-1732,1887,7448 } },",
          "12413:     { \"Canon EOS-1Ds Mark II\", 0, 0xe80,",
          "12414:       { 6517,-602,-867,-8180,15926,2378,-1618,1771,7633 } },",
          "12415:     { \"Canon EOS-1D Mark IV\", 0, 0x3bb0,",
          "12416:       { 6014,-220,-795,-4109,12014,2361,-561,1824,5787 } },",
          "12417:     { \"Canon EOS-1D Mark III\", 0, 0x3bb0,",
          "12418:       { 6291,-540,-976,-8350,16145,2311,-1714,1858,7326 } },",
          "12419:     { \"Canon EOS-1D Mark II N\", 0, 0xe80,",
          "12420:       { 6240,-466,-822,-8180,15825,2500,-1801,1938,8042 } },",
          "12421:     { \"Canon EOS-1D Mark II\", 0, 0xe80,",
          "12422:       { 6264,-582,-724,-8312,15948,2504,-1744,1919,8664 } },",
          "12423:     { \"Canon EOS-1DS\", 0, 0xe20,",
          "12424:       { 4374,3631,-1743,-7520,15212,2472,-2892,3632,8161 } },",
          "12425:     { \"Canon EOS-1D C\", 0, 0x3c4e,",
          "12426:       { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },",
          "12427:     { \"Canon EOS-1D X Mark II\", 0, 0x3c4e,",
          "12428:       { 7596,-978,967,-4808,12571,2503,-1398,2567,5752 } },",
          "12429:     { \"Canon EOS-1D X\", 0, 0x3c4e,",
          "12430:       { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },",
          "12431:     { \"Canon EOS-1D\", 0, 0xe20,",
          "12432:       { 6806,-179,-1020,-8097,16415,1687,-3267,4236,7690 } },",
          "12434:       { 17851,-10604,922,-7425,16662,763,-3660,3636,22278 } },",
          "12435:     { \"Canon PowerShot A530\", 0, 0,",
          "12437:     { \"Canon PowerShot A50\", 0, 0,",
          "12438:       { -5300,9846,1776,3436,684,3939,-5540,9879,6200,-1404,11175,217 } },",
          "12439:     { \"Canon PowerShot A5\", 0, 0,",
          "12440:       { -4801,9475,1952,2926,1611,4094,-5259,10164,5947,-1554,10883,547 } },",
          "12441:     { \"Canon PowerShot G10\", 0, 0,",
          "12442:       { 11093,-3906,-1028,-5047,12492,2879,-1003,1750,5561 } },",
          "12443:     { \"Canon PowerShot G11\", 0, 0,",
          "12444:       { 12177,-4817,-1069,-1612,9864,2049,-98,850,4471 } },",
          "12445:     { \"Canon PowerShot G12\", 0, 0,",
          "12446:       { 13244,-5501,-1248,-1508,9858,1935,-270,1083,4366 } },",
          "12447:     { \"Canon PowerShot G15\", 0, 0,",
          "12448:       { 7474,-2301,-567,-4056,11456,2975,-222,716,4181 } },",
          "12449:     { \"Canon PowerShot G16\", 0, 0,",
          "12450:       { 14130,-8071,127,2199,6528,1551,3402,-1721,4960 } },",
          "12451:     { \"Canon PowerShot G1 X Mark II\", 0, 0,",
          "12452:       { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },",
          "12453:     { \"Canon PowerShot G1 X\", 0, 0,",
          "12454:       { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },",
          "12455:     { \"Canon PowerShot G1\", 0, 0,",
          "12456:       { -4778,9467,2172,4743,-1141,4344,-5146,9908,6077,-1566,11051,557 } },",
          "12457:     { \"Canon PowerShot G2\", 0, 0,",
          "12458:       { 9087,-2693,-1049,-6715,14382,2537,-2291,2819,7790 } },",
          "12459:     { \"Canon PowerShot G3 X\", 0, 0,",
          "12460:       { 9701,-3857,-921,-3149,11537,1817,-786,1817,5147 } },",
          "12461:     { \"Canon PowerShot G3\", 0, 0,",
          "12462:       { 9212,-2781,-1073,-6573,14189,2605,-2300,2844,7664 } },",
          "12463:     { \"Canon PowerShot G5 X\",0, 0,",
          "12464:       { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },",
          "12465:     { \"Canon PowerShot G5\", 0, 0,",
          "12466:       { 9757,-2872,-933,-5972,13861,2301,-1622,2328,7212 } },",
          "12467:     { \"Canon PowerShot G6\", 0, 0,",
          "12468:       { 9877,-3775,-871,-7613,14807,3072,-1448,1305,7485 } },",
          "12469:     { \"Canon PowerShot G7 X Mark II\", 0, 0,",
          "12470:       { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },",
          "12471:     { \"Canon PowerShot G7 X\", 0, 0,",
          "12472:       { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },",
          "12473:     { \"Canon PowerShot G9 X\",0, 0,",
          "12474:       { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },",
          "12475:     { \"Canon PowerShot G9\", 0, 0,",
          "12476:       { 7368,-2141,-598,-5621,13254,2625,-1418,1696,5743 } },",
          "12477:     { \"Canon PowerShot Pro1\", 0, 0,",
          "12478:       { 10062,-3522,-999,-7643,15117,2730,-765,817,7323 } },",
          "12479:     { \"Canon PowerShot Pro70\", 34, 0,",
          "12480:       { -4155,9818,1529,3939,-25,4522,-5521,9870,6610,-2238,10873,1342 } },",
          "12481:     { \"Canon PowerShot Pro90\", 0, 0,",
          "12482:       { -4963,9896,2235,4642,-987,4294,-5162,10011,5859,-1770,11230,577 } },",
          "12483:     { \"Canon PowerShot S30\", 0, 0,",
          "12484:       { 10566,-3652,-1129,-6552,14662,2006,-2197,2581,7670 } },",
          "12485:     { \"Canon PowerShot S40\", 0, 0,",
          "12486:       { 8510,-2487,-940,-6869,14231,2900,-2318,2829,9013 } },",
          "12487:     { \"Canon PowerShot S45\", 0, 0,",
          "12488:       { 8163,-2333,-955,-6682,14174,2751,-2077,2597,8041 } },",
          "12489:     { \"Canon PowerShot S50\", 0, 0,",
          "12490:       { 8882,-2571,-863,-6348,14234,2288,-1516,2172,6569 } },",
          "12491:     { \"Canon PowerShot S60\", 0, 0,",
          "12492:       { 8795,-2482,-797,-7804,15403,2573,-1422,1996,7082 } },",
          "12493:     { \"Canon PowerShot S70\", 0, 0,",
          "12494:       { 9976,-3810,-832,-7115,14463,2906,-901,989,7889 } },",
          "12495:     { \"Canon PowerShot S90\", 0, 0,",
          "12496:       { 12374,-5016,-1049,-1677,9902,2078,-83,852,4683 } },",
          "12497:     { \"Canon PowerShot S95\", 0, 0,",
          "12498:       { 13440,-5896,-1279,-1236,9598,1931,-180,1001,4651 } },",
          "12499:     { \"Canon PowerShot S120\", 0, 0,",
          "12500:       { 6961,-1685,-695,-4625,12945,1836,-1114,2152,5518 } },",
          "12501:     { \"Canon PowerShot S110\", 0, 0,",
          "12502:       { 8039,-2643,-654,-3783,11230,2930,-206,690,4194 } },",
          "12503:     { \"Canon PowerShot S100\", 0, 0,",
          "12504:       { 7968,-2565,-636,-2873,10697,2513,180,667,4211 } },",
          "12505:     { \"Canon PowerShot SX1 IS\", 0, 0,",
          "12506:       { 6578,-259,-502,-5974,13030,3309,-308,1058,4970 } },",
          "12507:     { \"Canon PowerShot SX50 HS\", 0, 0,",
          "12508:       { 12432,-4753,-1247,-2110,10691,1629,-412,1623,4926 } },",
          "12509:     { \"Canon PowerShot SX60 HS\", 0, 0,",
          "12510:       { 13161,-5451,-1344,-1989,10654,1531,-47,1271,4955 } },",
          "12512:       { 10826,-3654,-1023,-3215,11310,1906,0,999,4960 } },",
          "12514:       { 12513,-4407,-1242,-2680,10276,2405,-878,2215,4734 } },",
          "12516:       { 15591,-6402,-1592,-5365,13198,2168,-1300,1824,5075 } },",
          "12518:       { 15265,-6193,-1558,-4125,12116,2010,-888,1639,5220 } },",
          "12520:       { 14201,-5308,-1757,-6087,14472,1617,-2191,3105,5348 } },",
          "12522:       { 13124,-5329,-1390,-3602,11658,1944,-1612,2863,4885 } },",
          "12524:       { 9427,-3036,-959,-2581,10671,1911,-1039,1982,4430 } },",
          "12526:       { 14573,-5482,-1546,-1266,9799,1468,-1040,1912,3810 } },",
          "12528:       { 14062,-5199,-1446,-4712,12470,2243,-1286,2028,4836 } },",
          "12530:       { 14134,-5576,-1527,-1991,10719,1273,-1158,1929,3581 } },",
          "12532:       { 13898,-5076,-1447,-1405,10109,1297,-244,1860,3687 } },",
          "12534:       { 11657,-3781,-1136,-3544,11262,2283,-160,1219,4700 } },",
          "12536:       { 11634,-3924,-1128,-4968,12954,2015,-1588,2648,7206 } },",
          "12538:       { 10819,-3873,-1099,-4903,13730,1175,-1755,3751,4632 } },",
          "12540:       { 9790,-3338,-603,-2321,10222,2099,-344,1273,4799 } },",
          "12541:     { \"CINE 650\", 0, 0,",
          "12542:       { 3390,480,-500,-800,3610,340,-550,2336,1192 } },",
          "12543:     { \"CINE 660\", 0, 0,",
          "12544:       { 3390,480,-500,-800,3610,340,-550,2336,1192 } },",
          "12545:     { \"CINE\", 0, 0,",
          "12546:       { 20183,-4295,-423,-3940,15330,3985,-280,4870,9800 } },",
          "12547:     { \"Contax N Digital\", 0, 0xf1e,",
          "12548:       { 7777,1285,-1053,-9280,16543,2916,-3677,5679,7060 } },",
          "12549:     { \"DXO ONE\", 0, 0,",
          "12550:       { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },",
          "12551:     { \"Epson R-D1\", 0, 0,",
          "12552:       { 6827,-1878,-732,-8429,16012,2564,-704,592,7145 } },",
          "12553:     { \"Fujifilm E550\", 0, 0,",
          "12554:       { 11044,-3888,-1120,-7248,15168,2208,-1531,2277,8069 } },",
          "12555:     { \"Fujifilm E900\", 0, 0,",
          "12556:       { 9183,-2526,-1078,-7461,15071,2574,-2022,2440,8639 } },",
          "12557:     { \"Fujifilm F5\", 0, 0,",
          "12558:       { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },",
          "12559:     { \"Fujifilm F6\", 0, 0,",
          "12560:       { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },",
          "12561:     { \"Fujifilm F77\", 0, 0xfe9,",
          "12562:       { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },",
          "12563:     { \"Fujifilm F7\", 0, 0,",
          "12564:       { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },",
          "12565:     { \"Fujifilm F8\", 0, 0,",
          "12566:       { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },",
          "12567:     { \"Fujifilm S100FS\", 514, 0,",
          "12568:       { 11521,-4355,-1065,-6524,13767,3058,-1466,1984,6045 } },",
          "12569:     { \"Fujifilm S1\", 0, 0,",
          "12570:       { 12297,-4882,-1202,-2106,10691,1623,-88,1312,4790 } },",
          "12571:     { \"Fujifilm S20Pro\", 0, 0,",
          "12572:       { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },",
          "12573:     { \"Fujifilm S20\", 512, 0x3fff,",
          "12574:       { 11401,-4498,-1312,-5088,12751,2613,-838,1568,5941 } },",
          "12575:     { \"Fujifilm S2Pro\", 128, 0,",
          "12576:       { 12492,-4690,-1402,-7033,15423,1647,-1507,2111,7697 } },",
          "12577:     { \"Fujifilm S3Pro\", 0, 0,",
          "12578:       { 11807,-4612,-1294,-8927,16968,1988,-2120,2741,8006 } },",
          "12579:     { \"Fujifilm S5Pro\", 0, 0,",
          "12580:       { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },",
          "12581:     { \"Fujifilm S5000\", 0, 0,",
          "12582:       { 8754,-2732,-1019,-7204,15069,2276,-1702,2334,6982 } },",
          "12583:     { \"Fujifilm S5100\", 0, 0,",
          "12584:       { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },",
          "12585:     { \"Fujifilm S5500\", 0, 0,",
          "12586:       { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },",
          "12587:     { \"Fujifilm S5200\", 0, 0,",
          "12588:       { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },",
          "12589:     { \"Fujifilm S5600\", 0, 0,",
          "12590:       { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },",
          "12591:     { \"Fujifilm S6\", 0, 0,",
          "12592:       { 12628,-4887,-1401,-6861,14996,1962,-2198,2782,7091 } },",
          "12593:     { \"Fujifilm S7000\", 0, 0,",
          "12594:       { 10190,-3506,-1312,-7153,15051,2238,-2003,2399,7505 } },",
          "12595:     { \"Fujifilm S9000\", 0, 0,",
          "12596:       { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },",
          "12597:     { \"Fujifilm S9500\", 0, 0,",
          "12598:       { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },",
          "12599:     { \"Fujifilm S9100\", 0, 0,",
          "12600:       { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },",
          "12601:     { \"Fujifilm S9600\", 0, 0,",
          "12602:       { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },",
          "12603:     { \"Fujifilm SL1000\", 0, 0,",
          "12604:       { 11705,-4262,-1107,-2282,10791,1709,-555,1713,4945 } },",
          "12605:     { \"Fujifilm IS-1\", 0, 0,",
          "12606:       { 21461,-10807,-1441,-2332,10599,1999,289,875,7703 } },",
          "12607:     { \"Fujifilm IS Pro\", 0, 0,",
          "12608:       { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },",
          "12609:     { \"Fujifilm HS10 HS11\", 0, 0xf68,",
          "12610:       { 12440,-3954,-1183,-1123,9674,1708,-83,1614,4086 } },",
          "12611:     { \"Fujifilm HS2\", 0, 0,",
          "12612:       { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },",
          "12613:     { \"Fujifilm HS3\", 0, 0,",
          "12614:       { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },",
          "12615:     { \"Fujifilm HS50EXR\", 0, 0,",
          "12616:       { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },",
          "12617:     { \"Fujifilm F900EXR\", 0, 0,",
          "12618:       { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },",
          "12619:     { \"Fujifilm X100S\", 0, 0,",
          "12620:       { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },",
          "12621:     { \"Fujifilm X100T\", 0, 0,",
          "12622:       { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },",
          "12623:     { \"Fujifilm X100\", 0, 0,",
          "12624:       { 12161,-4457,-1069,-5034,12874,2400,-795,1724,6904 } },",
          "12625:     { \"Fujifilm X10\", 0, 0,",
          "12626:       { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },",
          "12627:     { \"Fujifilm X20\", 0, 0,",
          "12628:       { 11768,-4971,-1133,-4904,12927,2183,-480,1723,4605 } },",
          "12629:     { \"Fujifilm X30\", 0, 0,",
          "12630:       { 12328,-5256,-1144,-4469,12927,1675,-87,1291,4351 } },",
          "12631:     { \"Fujifilm X70\", 0, 0,",
          "12632:       { 10450,-4329,-878,-3217,11105,2421,-752,1758,6519 } },",
          "12633:     { \"Fujifilm X-Pro1\", 0, 0,",
          "12634:       { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },",
          "12635:     { \"Fujifilm X-Pro2\", 0, 0,",
          "12636:       { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },",
          "12637:     { \"Fujifilm X-A1\", 0, 0,",
          "12638:       { 11086,-4555,-839,-3512,11310,2517,-815,1341,5940 } },",
          "12639:     { \"Fujifilm X-A2\", 0, 0,",
          "12640:       { 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },",
          "12641:     { \"Fujifilm X-E1\", 0, 0,",
          "12642:       { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },",
          "12643:     { \"Fujifilm X-E2S\", 0, 0,",
          "12644:       { 11562,-5118,-961,-3022,11007,2311,-525,1569,6097 } },",
          "12645:     { \"Fujifilm X-E2\", 0, 0,",
          "12646:       { 12066,-5927,-367,-1969,9878,1503,-721,2034,5453 } },",
          "12647:     { \"Fujifilm XF1\", 0, 0,",
          "12648:       { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },",
          "12649:     { \"Fujifilm X-M1\", 0, 0,",
          "12650:       { 13193,-6685,-425,-2229,10458,1534,-878,1763,5217 } },",
          "12651:     { \"Fujifilm X-S1\", 0, 0,",
          "12652:       { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },",
          "12653:     { \"Fujifilm X-T10\", 0, 0,",
          "12654:       { 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },",
          "12655:     { \"Fujifilm X-T1\", 0, 0,",
          "12656:       { 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526 } },",
          "12657:     { \"Fujifilm X-T2\", 0, 0,",
          "12658:       { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },",
          "12659:     { \"Fujifilm XQ1\", 0, 0,",
          "12660:       { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },",
          "12661:     { \"Fujifilm XQ2\", 0, 0,",
          "12662:       { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },",
          "12663:     { \"GITUP GIT2\", 3200, 0,",
          "12664:       {8489, -2583,-1036,-8051,15583,2643,-1307,1407,7354}},",
          "12665:     { \"Hasselblad Lunar\", 0, 0,",
          "12666:       { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },",
          "12667:     { \"Hasselblad Stellar\", -800, 0,",
          "12668:       { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },",
          "12670:       { 8519, -3260, -280, -5081, 13459, 1738, -1449, 2960, 7809, } },",
          "12672:       { 17765,-5322,-1734,-6168,13354,2135,-264,2524,7440 } },",
          "12674:       { 17765,-5322,-1734,-6168,13354,2135,-264,2524,7440 } },",
          "12676:       { 14480,-5448,-1686,-3534,13123,2260,384,2952,7232 } },",
          "12678:       { 3857,452, -46, -6008, 14477, 1596, -2627, 4481, 5718 } },",
          "12680:       { 3857,452, -46, -6008, 14477, 1596, -2627, 4481, 5718 } },",
          "12682:       { 6325,-860,-957,-6559,15945,266,167,770,5936 } },",
          "12684:       { 15283,-6272,-465,-2030,16031,478,-2379,390,7965 } },",
          "12686:       { 9662, -684, -279, -4903, 12293, 2950, -344, 1669, 6024 } },",
          "12688:       { 4932, -835, 141, -4878, 11868, 3437, -1138, 1961, 7067 } },",
          "12690:       { 5656, -659, -346, -3923, 12306, 1791, -1602, 3509, 5442 } },",
          "12692:       {4932, -835, 141, -4878, 11868, 3437, -1138, 1961, 7067 }},",
          "12694:       { 101, -20, -2, -11, 145, 41, -24, 1, 56 } },",
          "12696:       { 7025,-1415,-704,-5188,13765,1424,-1248,2742,6038 } },",
          "12697:     { \"Kodak NC2000\", 0, 0,",
          "12698:       { 13891,-6055,-803,-465,9919,642,2121,82,1291 } },",
          "12699:     { \"Kodak DCS315C\", -8, 0,",
          "12700:       { 17523,-4827,-2510,756,8546,-137,6113,1649,2250 } },",
          "12701:     { \"Kodak DCS330C\", -8, 0,",
          "12702:       { 20620,-7572,-2801,-103,10073,-396,3551,-233,2220 } },",
          "12703:     { \"Kodak DCS420\", 0, 0,",
          "12704:       { 10868,-1852,-644,-1537,11083,484,2343,628,2216 } },",
          "12705:     { \"Kodak DCS460\", 0, 0,",
          "12706:       { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },",
          "12707:     { \"Kodak EOSDCS1\", 0, 0,",
          "12708:       { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },",
          "12709:     { \"Kodak EOSDCS3B\", 0, 0,",
          "12710:       { 9898,-2700,-940,-2478,12219,206,1985,634,1031 } },",
          "12711:     { \"Kodak DCS520C\", -178, 0,",
          "12712:       { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },",
          "12713:     { \"Kodak DCS560C\", -177, 0,",
          "12714:       { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },",
          "12715:     { \"Kodak DCS620C\", -177, 0,",
          "12716:       { 23617,-10175,-3149,-2054,11749,-272,2586,-489,3453 } },",
          "12717:     { \"Kodak DCS620X\", -176, 0,",
          "12718:       { 13095,-6231,154,12221,-21,-2137,895,4602,2258 } },",
          "12719:     { \"Kodak DCS660C\", -173, 0,",
          "12720:       { 18244,-6351,-2739,-791,11193,-521,3711,-129,2802 } },",
          "12721:     { \"Kodak DCS720X\", 0, 0,",
          "12722:       { 11775,-5884,950,9556,1846,-1286,-1019,6221,2728 } },",
          "12723:     { \"Kodak DCS760C\", 0, 0,",
          "12724:       { 16623,-6309,-1411,-4344,13923,323,2285,274,2926 } },",
          "12725:     { \"Kodak DCS Pro SLR\", 0, 0,",
          "12726:       { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },",
          "12727:     { \"Kodak DCS Pro 14nx\", 0, 0,",
          "12728:       { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },",
          "12729:     { \"Kodak DCS Pro 14\", 0, 0,",
          "12730:       { 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 } },",
          "12731:     { \"Kodak ProBack645\", 0, 0,",
          "12732:       { 16414,-6060,-1470,-3555,13037,473,2545,122,4948 } },",
          "12733:     { \"Kodak ProBack\", 0, 0,",
          "12734:       { 21179,-8316,-2918,-915,11019,-165,3477,-180,4210 } },",
          "12735:     { \"Kodak P712\", 0, 0,",
          "12736:       { 9658,-3314,-823,-5163,12695,2768,-1342,1843,6044 } },",
          "12737:     { \"Kodak P850\", 0, 0xf7c,",
          "12738:       { 10511,-3836,-1102,-6946,14587,2558,-1481,1792,6246 } },",
          "12739:     { \"Kodak P880\", 0, 0xfff,",
          "12740:       { 12805,-4662,-1376,-7480,15267,2360,-1626,2194,7904 } },",
          "12741:     { \"Kodak EasyShare Z980\", 0, 0,",
          "12742:       { 11313,-3559,-1101,-3893,11891,2257,-1214,2398,4908 } },",
          "12743:     { \"Kodak EasyShare Z981\", 0, 0,",
          "12744:       { 12729,-4717,-1188,-1367,9187,2582,274,860,4411 } },",
          "12745:     { \"Kodak EasyShare Z990\", 0, 0xfed,",
          "12746:       { 11749,-4048,-1309,-1867,10572,1489,-138,1449,4522 } },",
          "12747:     { \"Kodak EASYSHARE Z1015\", 0, 0xef1,",
          "12748:       { 11265,-4286,-992,-4694,12343,2647,-1090,1523,5447 } },",
          "12749:     { \"Leaf CMost\", 0, 0,",
          "12750:       { 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },",
          "12751:     { \"Leaf Valeo 6\", 0, 0,",
          "12752:       { 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },",
          "12753:     { \"Leaf Aptus 54S\", 0, 0,",
          "12754:       { 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },",
          "12755:     { \"Leaf Aptus 65\", 0, 0,",
          "12756:       { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },",
          "12757:     { \"Leaf Aptus 75\", 0, 0,",
          "12758:       { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },",
          "12759:     { \"Leaf Credo 40\", 0, 0,",
          "12760:       { 8035, 435, -962, -6001, 13872, 2320, -1159, 3065, 5434 } },",
          "12761:     { \"Leaf Credo 50\", 0, 0,",
          "12762:       { 3984, 0, 0, 0, 10000, 0, 0, 0, 7666 } },",
          "12763:     { \"Leaf Credo 60\", 0, 0,",
          "12764:       { 8035, 435, -962, -6001, 13872,2320,-1159,3065,5434 } },",
          "12765:     { \"Leaf Credo 80\", 0, 0,",
          "12766:       { 6294, 686, -712, -5435, 13417, 2211, -1006, 2435, 5042 } },",
          "12767:     { \"Leaf\", 0, 0,",
          "12768:       { 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },",
          "12769:     { \"Mamiya ZD\", 0, 0,",
          "12770:       { 7645,2579,-1363,-8689,16717,2015,-3712,5941,5961 } },",
          "12772:       { 16695,-3761,-2151,155,9682,163,3433,951,4904 } },",
          "12773:     { \"Minolta DiMAGE 5\", 0, 0xf7d,",
          "12774:       { 8983,-2942,-963,-6556,14476,2237,-2426,2887,8014 } },",
          "12775:     { \"Minolta DiMAGE 7Hi\", 0, 0xf7d,",
          "12776:       { 11368,-3894,-1242,-6521,14358,2339,-2475,3056,7285 } },",
          "12777:     { \"Minolta DiMAGE 7\", 0, 0xf7d,",
          "12778:       { 9144,-2777,-998,-6676,14556,2281,-2470,3019,7744 } },",
          "12779:     { \"Minolta DiMAGE A1\", 0, 0xf8b,",
          "12780:       { 9274,-2547,-1167,-8220,16323,1943,-2273,2720,8340 } },",
          "12781:     { \"Minolta DiMAGE A200\", 0, 0,",
          "12782:       { 8560,-2487,-986,-8112,15535,2771,-1209,1324,7743 } },",
          "12783:     { \"Minolta DiMAGE A2\", 0, 0xf8f,",
          "12784:       { 9097,-2726,-1053,-8073,15506,2762,-966,981,7763 } },",
          "12786:       { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },",
          "12787:     { \"Minolta DYNAX 5\", 0, 0xffb,",
          "12788:       { 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },",
          "12789:     { \"Minolta DYNAX 7\", 0, 0xffb,",
          "12790:       { 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },",
          "12792:       { 8898,-989,-1033,-3292,11619,1674,-661,3178,5216 } },",
          "12793:     { \"Nikon D100\", 0, 0,",
          "12794:       { 5902,-933,-782,-8983,16719,2354,-1402,1455,6464 } },",
          "12795:     { \"Nikon D1H\", 0, 0,",
          "12796:       { 7577,-2166,-926,-7454,15592,1934,-2377,2808,8606 } },",
          "12797:     { \"Nikon D1X\", 0, 0,",
          "12798:       { 7702,-2245,-975,-9114,17242,1875,-2679,3055,8521 } },",
          "12800:       { 16772,-4726,-2141,-7611,15713,1972,-2846,3494,9521 } },",
          "12801:     { \"Nikon D200\", 0, 0xfbc,",
          "12802:       { 8367,-2248,-763,-8758,16447,2422,-1527,1550,8053 } },",
          "12803:     { \"Nikon D2H\", 0, 0,",
          "12804:       { 5710,-901,-615,-8594,16617,2024,-2975,4120,6830 } },",
          "12805:     { \"Nikon D2X\", 0, 0,",
          "12806:       { 10231,-2769,-1255,-8301,15900,2552,-797,680,7148 } },",
          "12807:     { \"Nikon D3000\", 0, 0,",
          "12808:       { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },",
          "12809:     { \"Nikon D3100\", 0, 0,",
          "12810:       { 7911,-2167,-813,-5327,13150,2408,-1288,2483,7968 } },",
          "12811:     { \"Nikon D3200\", 0, 0xfb9,",
          "12812:       { 7013,-1408,-635,-5268,12902,2640,-1470,2801,7379 } },",
          "12813:     { \"Nikon D3300\", 0, 0,",
          "12814:       { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },",
          "12815:     { \"Nikon D3400\", 0, 0,",
          "12816:       { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },",
          "12817:     { \"Nikon D300\", 0, 0,",
          "12818:       { 9030,-1992,-715,-8465,16302,2255,-2689,3217,8069 } },",
          "12819:     { \"Nikon D3X\", 0, 0,",
          "12820:       { 7171,-1986,-648,-8085,15555,2718,-2170,2512,7457 } },",
          "12821:     { \"Nikon D3S\", 0, 0,",
          "12822:       { 8828,-2406,-694,-4874,12603,2541,-660,1509,7587 } },",
          "12823:     { \"Nikon D3\", 0, 0,",
          "12824:       { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },",
          "12825:     { \"Nikon D40X\", 0, 0,",
          "12826:       { 8819,-2543,-911,-9025,16928,2151,-1329,1213,8449 } },",
          "12827:     { \"Nikon D40\", 0, 0,",
          "12828:       { 6992,-1668,-806,-8138,15748,2543,-874,850,7897 } },",
          "12829:     { \"Nikon D4S\", 0, 0,",
          "12830:       { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },",
          "12831:     { \"Nikon D4\", 0, 0,",
          "12832:       { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },",
          "12833:     { \"Nikon Df\", 0, 0,",
          "12834:       { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },",
          "12835:     { \"Nikon D5000\", 0, 0xf00,",
          "12836:       { 7309,-1403,-519,-8474,16008,2622,-2433,2826,8064 } },",
          "12837:     { \"Nikon D5100\", 0, 0x3de6,",
          "12838:       { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },",
          "12839:     { \"Nikon D5200\", 0, 0,",
          "12840:       { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },",
          "12841:     { \"Nikon D5300\", 0, 0,",
          "12842:       { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },",
          "12843:     { \"Nikon D5500\", 0, 0,",
          "12844:       { 8821,-2938,-785,-4178,12142,2287,-824,1651,6860 } },",
          "12845:     { \"Nikon D500\", 0, 0,",
          "12846:         { 8813,-3210,-1036,-4703,12868,2021,-1054,1940,6129 } },",
          "12847:     { \"Nikon D50\", 0, 0,",
          "12848:       { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },",
          "12849:     { \"Nikon D5\", 0, 0,",
          "12850:       { 9200,-3522,-992,-5755,13803,2117,-753,1486,6338 } },",
          "12851:     { \"Nikon D600\", 0, 0x3e07,",
          "12852:       { 8178,-2245,-609,-4857,12394,2776,-1207,2086,7298 } },",
          "12853:     { \"Nikon D610\",0, 0,",
          "12854:       { 10426,-4005,-444,-3565,11764,1403,-1206,2266,6549 } },",
          "12855:     { \"Nikon D60\", 0, 0,",
          "12856:       { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },",
          "12857:     { \"Nikon D7000\", 0, 0,",
          "12858:       { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },",
          "12859:     { \"Nikon D7100\", 0, 0,",
          "12860:       { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },",
          "12861:     { \"Nikon D7200\", 0, 0,",
          "12862:       { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },",
          "12863:     { \"Nikon D750\", -600, 0,",
          "12864:       { 9020,-2890,-715,-4535,12436,2348,-934,1919,7086 } },",
          "12865:     { \"Nikon D700\", 0, 0,",
          "12866:       { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },",
          "12867:     { \"Nikon D70\", 0, 0,",
          "12868:       { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },",
          "12869:     { \"Nikon D810A\", 0, 0,",
          "12870:       { 11973, -5685, -888, -1965, 10326, 1901, -115, 1123, 7169 } },",
          "12871:     { \"Nikon D810\", 0, 0,",
          "12872:       { 9369,-3195,-791,-4488,12430,2301,-893,1796,6872 } },",
          "12873:     { \"Nikon D800\", 0, 0,",
          "12874:       { 7866,-2108,-555,-4869,12483,2681,-1176,2069,7501 } },",
          "12875:     { \"Nikon D80\", 0, 0,",
          "12876:       { 8629,-2410,-883,-9055,16940,2171,-1490,1363,8520 } },",
          "12877:     { \"Nikon D90\", 0, 0xf00,",
          "12878:       { 7309,-1403,-519,-8474,16008,2622,-2434,2826,8064 } },",
          "12880:       { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },",
          "12882:       { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },",
          "12884:       { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },",
          "12886:       { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },",
          "12888:       { 13142,-4152,-1596,-4655,12374,2282,-1769,2696,6711 } },",
          "12889:     { \"Nikon E2500\", 0, 0,",
          "12890:       { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },",
          "12892:       { 9846,-2085,-1019,-3278,11109,2170,-774,2134,5745 } },",
          "12894:       { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },",
          "12895:     { \"Nikon E4500\", 0, 0,",
          "12896:       { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },",
          "12897:     { \"Nikon E5000\", 0, 0,",
          "12898:       { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },",
          "12899:     { \"Nikon E5400\", 0, 0,",
          "12900:       { 9349,-2987,-1001,-7919,15766,2266,-2098,2680,6839 } },",
          "12901:     { \"Nikon E5700\", 0, 0,",
          "12902:       { -5368,11478,2368,5537,-113,3148,-4969,10021,5782,778,9028,211 } },",
          "12903:     { \"Nikon E8400\", 0, 0,",
          "12904:       { 7842,-2320,-992,-8154,15718,2599,-1098,1342,7560 } },",
          "12905:     { \"Nikon E8700\", 0, 0,",
          "12906:       { 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },",
          "12907:     { \"Nikon E8800\", 0, 0,",
          "12908:       { 7971,-2314,-913,-8451,15762,2894,-1442,1520,7610 } },",
          "12909:     { \"Nikon COOLPIX A\", 0, 0,",
          "12910:       { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },",
          "12911:     { \"Nikon COOLPIX B700\", 0, 0,",
          "12912:       { 14387,-6014,-1299,-1357,9975,1616,467,1047,4744 } },",
          "12913:     { \"Nikon COOLPIX P330\", -200, 0,",
          "12914:       { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },",
          "12915:     { \"Nikon COOLPIX P340\", -200, 0,",
          "12916:       { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },",
          "12917:     { \"Nikon COOLPIX P6000\", 0, 0,",
          "12918:       { 9698,-3367,-914,-4706,12584,2368,-837,968,5801 } },",
          "12919:     { \"Nikon COOLPIX P7000\", 0, 0,",
          "12920:       { 11432,-3679,-1111,-3169,11239,2202,-791,1380,4455 } },",
          "12921:     { \"Nikon COOLPIX P7100\", 0, 0,",
          "12922:       { 11053,-4269,-1024,-1976,10182,2088,-526,1263,4469 } },",
          "12923:     { \"Nikon COOLPIX P7700\", -3200, 0,",
          "12924:       { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },",
          "12925:     { \"Nikon COOLPIX P7800\", -3200, 0,",
          "12926:       { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },",
          "12927:     { \"Nikon 1 V3\", -200, 0,",
          "12928:       { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },",
          "12929:     { \"Nikon 1 J4\", 0, 0,",
          "12930:       { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },",
          "12931:     { \"Nikon 1 J5\", 0, 0,",
          "12932:       { 7520,-2518,-645,-3844,12102,1945,-913,2249,6835} },",
          "12933:     { \"Nikon 1 S2\", -200, 0,",
          "12934:       { 6612,-1342,-618,-3338,11055,2623,-174,1792,5075 } },",
          "12935:     { \"Nikon 1 V2\", 0, 0,",
          "12936:       { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },",
          "12937:     { \"Nikon 1 J3\", 0, 0,",
          "12938:       { 8144,-2671,-473,-1740,9834,1601,-58,1971,4296 } },",
          "12939:     { \"Nikon 1 AW1\", 0, 0,",
          "12940:       { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },",
          "12942:       { 8994,-2667,-865,-4594,12324,2552,-699,1786,6260 } },",
          "12943:     { \"Olympus AIR-A01\", 0, 0xfe1,",
          "12944:       { 8992,-3093,-639,-2563,10721,2122,-437,1270,5473 } },",
          "12945:     { \"Olympus C5050\", 0, 0,",
          "12946:       { 10508,-3124,-1273,-6079,14294,1901,-1653,2306,6237 } },",
          "12947:     { \"Olympus C5060\", 0, 0,",
          "12948:       { 10445,-3362,-1307,-7662,15690,2058,-1135,1176,7602 } },",
          "12949:     { \"Olympus C7070\", 0, 0,",
          "12950:       { 10252,-3531,-1095,-7114,14850,2436,-1451,1723,6365 } },",
          "12951:     { \"Olympus C70\", 0, 0,",
          "12952:       { 10793,-3791,-1146,-7498,15177,2488,-1390,1577,7321 } },",
          "12953:     { \"Olympus C80\", 0, 0,",
          "12954:       { 8606,-2509,-1014,-8238,15714,2703,-942,979,7760 } },",
          "12955:     { \"Olympus E-10\", 0, 0xffc,",
          "12956:       { 12745,-4500,-1416,-6062,14542,1580,-1934,2256,6603 } },",
          "12957:     { \"Olympus E-1\", 0, 0,",
          "12958:       { 11846,-4767,-945,-7027,15878,1089,-2699,4122,8311 } },",
          "12959:     { \"Olympus E-20\", 0, 0xffc,",
          "12960:       { 13173,-4732,-1499,-5807,14036,1895,-2045,2452,7142 } },",
          "12961:     { \"Olympus E-300\", 0, 0,",
          "12962:       { 7828,-1761,-348,-5788,14071,1830,-2853,4518,6557 } },",
          "12963:     { \"Olympus E-330\", 0, 0,",
          "12964:       { 8961,-2473,-1084,-7979,15990,2067,-2319,3035,8249 } },",
          "12965:     { \"Olympus E-30\", 0, 0xfbc,",
          "12966:       { 8144,-1861,-1111,-7763,15894,1929,-1865,2542,7607 } },",
          "12967:     { \"Olympus E-3\", 0, 0xf99,",
          "12968:       { 9487,-2875,-1115,-7533,15606,2010,-1618,2100,7389 } },",
          "12969:     { \"Olympus E-400\", 0, 0,",
          "12970:       { 6169,-1483,-21,-7107,14761,2536,-2904,3580,8568 } },",
          "12971:     { \"Olympus E-410\", 0, 0xf6a,",
          "12972:       { 8856,-2582,-1026,-7761,15766,2082,-2009,2575,7469 } },",
          "12973:     { \"Olympus E-420\", 0, 0xfd7,",
          "12974:       { 8746,-2425,-1095,-7594,15612,2073,-1780,2309,7416 } },",
          "12975:     { \"Olympus E-450\", 0, 0xfd2,",
          "12976:       { 8745,-2425,-1095,-7594,15613,2073,-1780,2309,7416 } },",
          "12977:     { \"Olympus E-500\", 0, 0,",
          "12978:       { 8136,-1968,-299,-5481,13742,1871,-2556,4205,6630 } },",
          "12979:     { \"Olympus E-510\", 0, 0xf6a,",
          "12980:       { 8785,-2529,-1033,-7639,15624,2112,-1783,2300,7817 } },",
          "12981:     { \"Olympus E-520\", 0, 0xfd2,",
          "12982:       { 8344,-2322,-1020,-7596,15635,2048,-1748,2269,7287 } },",
          "12983:     { \"Olympus E-5\", 0, 0xeec,",
          "12984:       { 11200,-3783,-1325,-4576,12593,2206,-695,1742,7504 } },",
          "12985:     { \"Olympus E-600\", 0, 0xfaf,",
          "12986:       { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },",
          "12987:     { \"Olympus E-620\", 0, 0xfaf,",
          "12988:       { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },",
          "12989:     { \"Olympus E-P1\", 0, 0xffd,",
          "12990:       { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },",
          "12991:     { \"Olympus E-P2\", 0, 0xffd,",
          "12992:       { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },",
          "12993:     { \"Olympus E-P3\", 0, 0,",
          "12994:       { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },",
          "12995:     { \"Olympus E-P5\", 0, 0,",
          "12996:       { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },",
          "12997:     { \"Olympus E-PL1s\", 0, 0,",
          "12998:       { 11409,-3872,-1393,-4572,12757,2003,-709,1810,7415 } },",
          "12999:     { \"Olympus E-PL1\", 0, 0,",
          "13000:       { 11408,-4289,-1215,-4286,12385,2118,-387,1467,7787 } },",
          "13001:     { \"Olympus E-PL2\", 0, 0xcf3,",
          "13002:       { 15030,-5552,-1806,-3987,12387,1767,-592,1670,7023 } },",
          "13003:     { \"Olympus E-PL3\", 0, 0,",
          "13004:       { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },",
          "13005:     { \"Olympus E-PL5\", 0, 0xfcb,",
          "13006:       { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },",
          "13007:     { \"Olympus E-PL6\", 0, 0,",
          "13008:       { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },",
          "13009:     { \"Olympus E-PL7\", 0, 0,",
          "13010:       { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },",
          "13011:     { \"Olympus E-PL8\", 0, 0,",
          "13012:       { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },",
          "13013:     { \"Olympus E-PM1\", 0, 0,",
          "13014:       { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },",
          "13015:     { \"Olympus E-PM2\", 0, 0,",
          "13016:       { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },",
          "13018:       { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },",
          "13020:       { 8380, -2630, -639, -2887, 10725, 2496, -627, 1427, 5438 }},",
          "13021:     { \"Olympus E-M1\", 0, 0,",
          "13022:       { 7687,-1984,-606,-4327,11928,2721,-1381,2339,6452 } },",
          "13023:     { \"Olympus E-M5MarkII\", 0, 0,",
          "13024:       { 9422,-3258,-711,-2655,10898,2015,-512,1354,5512 } },",
          "13025:     { \"Olympus E-M5\", 0, 0xfe1,",
          "13026:       { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },",
          "13027:     { \"Olympus PEN-F\",0, 0,",
          "13028:       { 9476,-3182,-765,-2613,10958,1893,-449,1315,5268 } },",
          "13029:     { \"Olympus SP350\", 0, 0,",
          "13030:       { 12078,-4836,-1069,-6671,14306,2578,-786,939,7418 } },",
          "13031:     { \"Olympus SP3\", 0, 0,",
          "13032:       { 11766,-4445,-1067,-6901,14421,2707,-1029,1217,7572 } },",
          "13033:     { \"Olympus SP500UZ\", 0, 0xfff,",
          "13034:       { 9493,-3415,-666,-5211,12334,3260,-1548,2262,6482 } },",
          "13035:     { \"Olympus SP510UZ\", 0, 0xffe,",
          "13036:       { 10593,-3607,-1010,-5881,13127,3084,-1200,1805,6721 } },",
          "13037:     { \"Olympus SP550UZ\", 0, 0xffe,",
          "13038:       { 11597,-4006,-1049,-5432,12799,2957,-1029,1750,6516 } },",
          "13039:     { \"Olympus SP560UZ\", 0, 0xff9,",
          "13040:       { 10915,-3677,-982,-5587,12986,2911,-1168,1968,6223 } },",
          "13041:     { \"Olympus SP570UZ\", 0, 0,",
          "13042:       { 11522,-4044,-1146,-4736,12172,2904,-988,1829,6039 } },",
          "13043:     { \"Olympus SH-2\", 0, 0,",
          "13044:      { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },",
          "13046:      { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },",
          "13047:     { \"Olympus STYLUS1\",0, 0,",
          "13048:       { 11976,-5518,-545,-1419,10472,846,-475,1766,4524 } },",
          "13049:     { \"Olympus TG-4\", 0, 0,",
          "13050:      { 11426,-4159,-1126,-2066,10678,1593,-120,1327,4998 } },",
          "13051:     { \"Olympus XZ-10\", 0, 0,",
          "13052:       { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },",
          "13053:     { \"Olympus XZ-1\", 0, 0,",
          "13054:       { 10901,-4095,-1074,-1141,9208,2293,-62,1417,5158 } },",
          "13055:     { \"Olympus XZ-2\", 0, 0,",
          "13056:       { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },",
          "13057:     { \"OmniVision\", 16, 0x3ff,",
          "13059:     { \"Pentax *ist DL2\", 0, 0,",
          "13060:       { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },",
          "13061:     { \"Pentax *ist DL\", 0, 0,",
          "13062:       { 10829,-2838,-1115,-8339,15817,2696,-837,680,11939 } },",
          "13063:     { \"Pentax *ist DS2\", 0, 0,",
          "13064:       { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },",
          "13065:     { \"Pentax *ist DS\", 0, 0,",
          "13066:       { 10371,-2333,-1206,-8688,16231,2602,-1230,1116,11282 } },",
          "13067:     { \"Pentax *ist D\", 0, 0,",
          "13068:       { 9651,-2059,-1189,-8881,16512,2487,-1460,1345,10687 } },",
          "13069:     { \"Pentax K10D\", 0, 0,",
          "13070:       { 9566,-2863,-803,-7170,15172,2112,-818,803,9705 } },",
          "13071:     { \"Pentax K1\", 0, 0,",
          "13072:       { 11095,-3157,-1324,-8377,15834,2720,-1108,947,11688 } },",
          "13073:     { \"Pentax K20D\", 0, 0,",
          "13074:       { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },",
          "13075:     { \"Pentax K200D\", 0, 0,",
          "13076:       { 9186,-2678,-907,-8693,16517,2260,-1129,1094,8524 } },",
          "13077:     { \"Pentax K2000\", 0, 0,",
          "13078:       { 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },",
          "13079:     { \"Pentax K-m\", 0, 0,",
          "13080:       { 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },",
          "13081:     { \"Pentax K-x\", 0, 0,",
          "13082:       { 8843,-2837,-625,-5025,12644,2668,-411,1234,7410 } },",
          "13083:     { \"Pentax K-r\", 0, 0,",
          "13084:       { 9895,-3077,-850,-5304,13035,2521,-883,1768,6936 } },",
          "13085:     { \"Pentax K-1\", 0, 0,",
          "13086:       { 8566,-2746,-1201,-3612,12204,1550,-893,1680,6264 } },",
          "13087:     { \"Pentax K-30\", 0, 0,",
          "13088:       { 8710,-2632,-1167,-3995,12301,1881,-981,1719,6535 } },",
          "13089:     { \"Pentax K-3 II\", 0, 0,",
          "13090:       { 8626,-2607,-1155,-3995,12301,1881,-1039,1822,6925 } },",
          "13091:     { \"Pentax K-3\", 0, 0,",
          "13092:       { 7415,-2052,-721,-5186,12788,2682,-1446,2157,6773 } },",
          "13093:     { \"Pentax K-5 II\", 0, 0,",
          "13094:       { 8170,-2725,-639,-4440,12017,2744,-771,1465,6599 } },",
          "13095:     { \"Pentax K-5\", 0, 0,",
          "13096:       { 8713,-2833,-743,-4342,11900,2772,-722,1543,6247 } },",
          "13097:     { \"Pentax K-70\", 0, 0,",
          "13098:       {8766, -3149, -747, -3976, 11943, 2292, -517, 1259, 5552 }},",
          "13099:     { \"Pentax K-7\", 0, 0,",
          "13100:       { 9142,-2947,-678,-8648,16967,1663,-2224,2898,8615 } },",
          "13101:     { \"Pentax K-S1\", 0, 0,",
          "13102:       { 8512,-3211,-787,-4167,11966,2487,-638,1288,6054 } },",
          "13103:     { \"Pentax K-S2\", 0, 0,",
          "13104:       { 8662,-3280,-798,-3928,11771,2444,-586,1232,6054 } },",
          "13105:     { \"Pentax Q-S1\", 0, 0,",
          "13106:       { 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },",
          "13107:     { \"Pentax MX-1\", 0, 0,",
          "13108:       { 8804,-2523,-1238,-2423,11627,860,-682,1774,4753 } },",
          "13109:     { \"Pentax Q10\", 0, 0,",
          "13110:       { 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },",
          "13111:     { \"Pentax 645D\", 0, 0x3e00,",
          "13112:       { 10646,-3593,-1158,-3329,11699,1831,-667,2874,6287 } },",
          "13114:       { 9702, -3060, -1254, -3685, 12133, 1721, -1086, 2010, 6971}},",
          "13115:     { \"Panasonic DMC-CM10\", -15, 0,",
          "13116:       { 8770, -3194,-820,-2871,11281,1803,-513,1552,4434 } },",
          "13117:     { \"Panasonic DMC-CM1\", -15, 0,",
          "13118:       { 8770, -3194,-820,-2871,11281,1803,-513,1552,4434 } },",
          "13119:     { \"Panasonic DMC-FZ8\", 0, 0xf7f,",
          "13120:       { 8986,-2755,-802,-6341,13575,3077,-1476,2144,6379 } },",
          "13121:     { \"Panasonic DMC-FZ18\", 0, 0,",
          "13122:       { 9932,-3060,-935,-5809,13331,2753,-1267,2155,5575 } },",
          "13123:     { \"Panasonic DMC-FZ28\", -15, 0xf96,",
          "13124:       { 10109,-3488,-993,-5412,12812,2916,-1305,2140,5543 } },",
          "13125:     { \"Panasonic DMC-FZ300\", -15, 0xfff,",
          "13126:       { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },",
          "13127:     { \"Panasonic DMC-FZ330\", -15, 0xfff,  // same as FZ300",
          "13128:       { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },",
          "13129:     { \"Panasonic DMC-FZ30\", 0, 0xf94,",
          "13130:       { 10976,-4029,-1141,-7918,15491,2600,-1670,2071,8246 } },",
          "13131:     { \"Panasonic DMC-FZ3\", -15, 0,",
          "13132:       { 9938,-2780,-890,-4604,12393,2480,-1117,2304,4620 } },",
          "13133:     { \"Panasonic DMC-FZ4\", -15, 0,",
          "13134:       { 13639,-5535,-1371,-1698,9633,2430,316,1152,4108 } },",
          "13135:     { \"Panasonic DMC-FZ50\", 0, 0,",
          "13136:       { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },",
          "13137:     { \"Panasonic DMC-FZ7\", -15, 0,",
          "13138:       { 11532,-4324,-1066,-2375,10847,1749,-564,1699,4351 } },",
          "13139:     { \"Leica V-LUX1\", 0, 0,",
          "13140:       { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },",
          "13141:     { \"Panasonic DMC-L10\", -15, 0xf96,",
          "13142:       { 8025,-1942,-1050,-7920,15904,2100,-2456,3005,7039 } },",
          "13143:     { \"Panasonic DMC-L1\", 0, 0xf7f,",
          "13144:       { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },",
          "13145:     { \"Leica DIGILUX 3\", 0, 0xf7f,",
          "13146:       { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },",
          "13147:     { \"Panasonic DMC-LC1\", 0, 0,",
          "13148:       { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },",
          "13149:     { \"Leica DIGILUX 2\", 0, 0,",
          "13150:       { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },",
          "13151:     { \"Panasonic DMC-LX100\", -15, 0,",
          "13152:       { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },",
          "13153:     { \"Leica D-LUX (Typ 109)\", -15, 0,",
          "13154:       { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },",
          "13155:     { \"Panasonic DMC-LF1\", -15, 0,",
          "13156:       { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },",
          "13157:     { \"Leica C (Typ 112)\", -15, 0,",
          "13158:       { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },",
          "13167:     { \"Panasonic DMC-LX1\", 0, 0xf7f,",
          "13168:       { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },",
          "13169:     { \"Leica D-Lux (Typ 109)\", 0, 0xf7f,",
          "13170:       { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },",
          "13171:     { \"Leica D-LUX2\", 0, 0xf7f,",
          "13172:       { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },",
          "13173:     { \"Panasonic DMC-LX2\", 0, 0,",
          "13174:       { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },",
          "13175:     { \"Leica D-LUX3\", 0, 0,",
          "13176:       { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },",
          "13177:     { \"Panasonic DMC-LX3\", -15, 0,",
          "13178:       { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },",
          "13179:     { \"Leica D-LUX 4\", -15, 0,",
          "13180:       { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },",
          "13181:     { \"Panasonic DMC-LX5\", -15, 0,",
          "13182:       { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },",
          "13183:     { \"Leica D-LUX 5\", -15, 0,",
          "13184:       { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },",
          "13185:     { \"Panasonic DMC-LX7\", -15, 0,",
          "13186:       { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },",
          "13187:     { \"Leica D-LUX 6\", -15, 0,",
          "13188:       { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },",
          "13189:     { \"Panasonic DMC-FZ1000\", -15, 0,",
          "13190:       { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },",
          "13191:     { \"Leica V-LUX (Typ 114)\", 15, 0,",
          "13192:       { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },",
          "13193:     { \"Panasonic DMC-FZ100\", -15, 0xfff,",
          "13194:       { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },",
          "13195:     { \"Leica V-LUX 2\", -15, 0xfff,",
          "13196:       { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },",
          "13197:     { \"Panasonic DMC-FZ150\", -15, 0xfff,",
          "13198:       { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },",
          "13199:     { \"Leica V-LUX 3\", -15, 0xfff,",
          "13200:       { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },",
          "13202:       { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},",
          "13203:     { \"Panasonic DMC-FZ2500\", -15, 0,",
          "13204:       { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},",
          "13205:     { \"Panasonic DMC-FZH1\", -15, 0,",
          "13206:       { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},",
          "13207:     { \"Panasonic DMC-FZ200\", -15, 0xfff,",
          "13208:       { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },",
          "13209:     { \"Leica V-LUX 4\", -15, 0xfff,",
          "13210:       { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },",
          "13211:     { \"Panasonic DMC-FX150\", -15, 0xfff,",
          "13212:       { 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },",
          "13213:     { \"Panasonic DMC-G10\", 0, 0,",
          "13214:       { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },",
          "13215:     { \"Panasonic DMC-G1\", -15, 0xf94,",
          "13216:       { 8199,-2065,-1056,-8124,16156,2033,-2458,3022,7220 } },",
          "13217:     { \"Panasonic DMC-G2\", -15, 0xf3c,",
          "13218:       { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },",
          "13219:     { \"Panasonic DMC-G3\", -15, 0xfff,",
          "13220:       { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },",
          "13221:     { \"Panasonic DMC-G5\", -15, 0xfff,",
          "13222:       { 7798,-2562,-740,-3879,11584,2613,-1055,2248,5434 } },",
          "13223:     { \"Panasonic DMC-G6\", -15, 0xfff,",
          "13224:       { 8294,-2891,-651,-3869,11590,2595,-1183,2267,5352 } },",
          "13225:     { \"Panasonic DMC-G7\", -15, 0xfff,",
          "13226:       { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },",
          "13228:       { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },",
          "13229:     { \"Panasonic DMC-GF1\", -15, 0xf92,",
          "13230:       { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },",
          "13231:     { \"Panasonic DMC-GF2\", -15, 0xfff,",
          "13232:       { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },",
          "13233:     { \"Panasonic DMC-GF3\", -15, 0xfff,",
          "13234:       { 9051,-2468,-1204,-5212,13276,2121,-1197,2510,6890 } },",
          "13235:     { \"Panasonic DMC-GF5\", -15, 0xfff,",
          "13236:       { 8228,-2945,-660,-3938,11792,2430,-1094,2278,5793 } },",
          "13237:     { \"Panasonic DMC-GF6\", -15, 0,",
          "13238:       { 8130,-2801,-946,-3520,11289,2552,-1314,2511,5791 } },",
          "13239:     { \"Panasonic DMC-GF7\", -15, 0,",
          "13240:       { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },",
          "13241:     { \"Panasonic DMC-GF8\", -15, 0,",
          "13242:       { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },",
          "13243:     { \"Panasonic DMC-GH1\", -15, 0xf92,",
          "13244:       { 6299,-1466,-532,-6535,13852,2969,-2331,3112,5984 } },",
          "13245:     { \"Panasonic DMC-GH2\", -15, 0xf95,",
          "13246:       { 7780,-2410,-806,-3913,11724,2484,-1018,2390,5298 } },",
          "13247:     { \"Panasonic DMC-GH3\", -15, 0,",
          "13248:       { 6559,-1752,-491,-3672,11407,2586,-962,1875,5130 } },",
          "13249:     { \"Panasonic DMC-GH4\", -15, 0,",
          "13250:       { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },",
          "13251:     { \"Yuneec CGO4\", -15, 0,",
          "13252:       { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },",
          "13253:     { \"Panasonic DMC-GM1\", -15, 0,",
          "13254:       { 6770,-1895,-744,-5232,13145,2303,-1664,2691,5703 } },",
          "13255:     { \"Panasonic DMC-GM5\", -15, 0,",
          "13256:       { 8238,-3244,-679,-3921,11814,2384,-836,2022,5852 } },",
          "13257:     { \"Panasonic DMC-GX1\", -15, 0,",
          "13258:       { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },",
          "13260:       { 7771,-3020,-629,4029,11950,2345,-821,1977,6119 } },",
          "13262:       { 7771,-3020,-629,4029,11950,2345,-821,1977,6119 } },",
          "13264:       { 7771,-3020,-629,4029,11950,2345,-821,1977,6119 } },",
          "13265:     { \"Panasonic DMC-GX7\", -15,0,",
          "13266:       { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },",
          "13267:     { \"Panasonic DMC-GX8\", -15,0,",
          "13268:       { 7564,-2263,-606,-3148,11239,2177,-540,1435,4853 } },",
          "13270:       { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },",
          "13272:       { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },",
          "13274:       { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },",
          "13276:       { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },",
          "13278:       { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },",
          "13280:       { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },",
          "13282:       { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },",
          "13284:       { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },",
          "13286:       { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },",
          "13288:       { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },",
          "13290:       { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },",
          "13292:       { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },",
          "13293:     { \"Leica S (Typ 007)\", 0, 0,",
          "13294:      { 6063,-2234,-231,-5210,13787,1500,-1043,2866,6997 } },",
          "13296:      { 7712,-2059,-653,-3882,11494,2726,-710,1332,5958 } },",
          "13297:     { \"Leica Q (Typ 116)\", 0, 0,",
          "13298:      { 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830 } },",
          "13299:     { \"Leica M (Typ 262)\", 0, 0,",
          "13300:      { 6653,-1486,-611,-4221,13303,929,-881,2416,7226 } },",
          "13301:     { \"Leica SL (Typ 601)\", 0, 0,",
          "13302:       { 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830} },",
          "13304:       { 1313,1855,-109,-6715,15908,808,-327,1840,6020 } },",
          "13305:     { \"Phase One H 25\", 0, 0,",
          "13306:       { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },",
          "13307:     { \"Phase One IQ250\",0, 0,",
          "13308:       { 4396,-153,-249,-5267,12249,2657,-1397,2323,6014 } },",
          "13309:     { \"Phase One P 2\", 0, 0,",
          "13310:       { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },",
          "13311:     { \"Phase One P 30\", 0, 0,",
          "13312:       { 4516,-245,-37,-7020,14976,2173,-3206,4671,7087 } },",
          "13313:     { \"Phase One P 45\", 0, 0,",
          "13314:       { 5053,-24,-117,-5684,14076,1702,-2619,4492,5849 } },",
          "13315:     { \"Phase One P40\", 0, 0,",
          "13316:       { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },",
          "13317:     { \"Phase One P65\", 0, 0,",
          "13318:       { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },",
          "13320:       { 14603,-4122,-528,-1810,9794,2017,-297,2763,5936 } },",
          "13322:       { 21014,-7891,-2613,-3056,12201,856,-2203,5125,8042 } },",
          "13323:     { \"Ricoh GR II\", 0, 0,",
          "13324:       { 4630,-834,-423,-4977,12805,2417,-638,1467,6115 } },",
          "13325:     { \"Ricoh GR\", 0, 0,",
          "13326:        { 3708,-543,-160,-5381,12254,3556,-1471,1929,8234 } },",
          "13328:       { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },",
          "13329:     { \"Samsung EX1\", 0, 0x3e00,",
          "13330:       { 8898,-2498,-994,-3144,11328,2066,-760,1381,4576 } },",
          "13331:     { \"Samsung EX2F\", 0, 0x7ff,",
          "13332:       { 10648,-3897,-1055,-2022,10573,1668,-492,1611,4742 } },",
          "13333:     { \"Samsung NX mini\", 0, 0,",
          "13334:       { 5222,-1196,-550,-6540,14649,2009,-1666,2819,5657 } },",
          "13336:       { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },",
          "13337:     { \"Samsung NX3000\", 0, 0,",
          "13338:       { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },",
          "13340:       { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },",
          "13341:     { \"Samsung NX2000\", 0, 0,",
          "13342:       { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },",
          "13344:       { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },",
          "13345:     { \"Samsung NX1000\", 0, 0,",
          "13346:       { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },",
          "13347:     { \"Samsung NX1100\", 0, 0,",
          "13348:       { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },",
          "13349:     { \"Samsung NX11\", 0, 0,",
          "13350:       { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },",
          "13352:       { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },",
          "13353:     { \"Samsung NX500\", 0, 0,",
          "13354:       { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },",
          "13355:     { \"Samsung NX5\", 0, 0,",
          "13356:       { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },",
          "13357:     { \"Samsung NX1\", 0, 0,",
          "13358:       { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },",
          "13359:     { \"Samsung WB2000\", 0, 0xfff,",
          "13360:       { 12093,-3557,-1155,-1000,9534,1733,-22,1787,4576 } },",
          "13361:     { \"Samsung GX-1\", 0, 0,",
          "13362:       { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },",
          "13364:       { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },",
          "13366:       { 11885,-3968,-1473,-4214,12299,1916,-835,1655,5549 } },",
          "13368:     { \"Sigma dp0 Quattro\", 2047, 0,",
          "13369:       { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },",
          "13370:     { \"Sigma dp1 Quattro\", 2047, 0,",
          "13371:       { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },",
          "13372:     { \"Sigma dp2 Quattro\", 2047, 0,",
          "13373:       { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },",
          "13374:     { \"Sigma dp3 Quattro\", 2047, 0,",
          "13375:       { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },",
          "13379:     { \"Sigma sd Quattro\", 2047, 0,",
          "13382:       { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },",
          "13384:       { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },",
          "13386:       { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },",
          "13388:       { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },",
          "13391:       { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },",
          "13393:       { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },",
          "13395:       { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },",
          "13397:       { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },",
          "13401:       { 13100,-3638,-847,6855,2369,580,2723,3218,3251 } },",
          "13403:       { 16442,-2956,-2422,-2877,12128,750,-1136,6066,4559 } },",
          "13404:     { \"Sony DSC-F828\", 0, 0,",
          "13405:       { 7924,-1910,-777,-8226,15459,2998,-1517,2199,6818,-7242,11401,3481 } },",
          "13406:     { \"Sony DSC-R1\", 0, 0,",
          "13407:       { 8512,-2641,-694,-8042,15670,2526,-1821,2117,7414 } },",
          "13408:     { \"Sony DSC-V3\", 0, 0,",
          "13409:       { 7511,-2571,-692,-7894,15088,3060,-948,1111,8128 } },",
          "13411:       {6596, -2079, -562, -4782, 13016, 1933, -970, 1581, 5181 }},",
          "13413:       { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },",
          "13414:     { \"Sony DSC-RX100\", 0, 0,",
          "13415:       { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },",
          "13417:       { 6679,-1825,-745,-5047,13256,1953,-1580,2422,5183 } },",
          "13418:     { \"Sony DSC-RX1RM2\", 0, 0,",
          "13419:       { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },",
          "13420:     { \"Sony DSC-RX1R\", 0, 0,",
          "13421:       { 8195,-2800,-422,-4261,12273,1709,-1505,2400,5624 } },",
          "13422:     { \"Sony DSC-RX1\", 0, 0,",
          "13423:       { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },",
          "13424:     { \"Sony DSLR-A100\", 0, 0xfeb,",
          "13425:       { 9437,-2811,-774,-8405,16215,2290,-710,596,7181 } },",
          "13426:     { \"Sony DSLR-A290\", 0, 0,",
          "13427:       { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },",
          "13428:     { \"Sony DSLR-A2\", 0, 0,",
          "13429:       { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },",
          "13430:     { \"Sony DSLR-A300\", 0, 0,",
          "13431:       { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },",
          "13432:     { \"Sony DSLR-A330\", 0, 0,",
          "13433:       { 9847,-3091,-929,-8485,16346,2225,-714,595,7103 } },",
          "13434:     { \"Sony DSLR-A350\", 0, 0xffc,",
          "13435:       { 6038,-1484,-578,-9146,16746,2513,-875,746,7217 } },",
          "13436:     { \"Sony DSLR-A380\", 0, 0,",
          "13437:       { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },",
          "13438:     { \"Sony DSLR-A390\", 0, 0,",
          "13439:       { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },",
          "13440:     { \"Sony DSLR-A450\", 0, 0xfeb,",
          "13441:       { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },",
          "13442:     { \"Sony DSLR-A580\", 0, 0xfeb,",
          "13443:       { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },",
          "13444:     { \"Sony DSLR-A500\", 0, 0xfeb,",
          "13445:       { 6046,-1127,-278,-5574,13076,2786,-691,1419,7625 } },",
          "13446:     { \"Sony DSLR-A5\", 0, 0xfeb,",
          "13447:       { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },",
          "13448:     { \"Sony DSLR-A700\", 0, 0,",
          "13449:       { 5775,-805,-359,-8574,16295,2391,-1943,2341,7249 } },",
          "13450:     { \"Sony DSLR-A850\", 0, 0,",
          "13451:       { 5413,-1162,-365,-5665,13098,2866,-608,1179,8440 } },",
          "13452:     { \"Sony DSLR-A900\", 0, 0,",
          "13453:       { 5209,-1072,-397,-8845,16120,2919,-1618,1803,8654 } },",
          "13454:     { \"Sony ILCA-68\", 0, 0,",
          "13455:       { 6435,-1903,-536,-4722,12449,2550,-663,1363,6517 } },",
          "13456:     { \"Sony ILCA-77M2\", 0, 0,",
          "13457:       { 5991,-1732,-443,-4100,11989,2381,-704,1467,5992 } },",
          "13459:       { 6660, -1918, -471, -4613, 12398, 2485, -649, 1433, 6447}},",
          "13460:     { \"Sony ILCE-7M2\", 0, 0,",
          "13461:       { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },",
          "13462:     { \"Sony ILCE-7SM2\", 0, 0,",
          "13463:       { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },",
          "13464:     { \"Sony ILCE-7S\", 0, 0,",
          "13465:       { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },",
          "13466:     { \"Sony ILCE-7RM2\", 0, 0,",
          "13467:       { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },",
          "13468:     { \"Sony ILCE-7R\", 0, 0,",
          "13469:       { 4913,-541,-202,-6130,13513,2906,-1564,2151,7183 } },",
          "13470:     { \"Sony ILCE-7\", 0, 0,",
          "13471:       { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },",
          "13472:     { \"Sony ILCE-6300\", 0, 0,",
          "13473:       { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },",
          "13475:       { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },",
          "13477:       { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },",
          "13478:     { \"Sony NEX-5N\", 0, 0,",
          "13479:       { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },",
          "13480:     { \"Sony NEX-5R\", 0, 0,",
          "13481:       { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },",
          "13482:     { \"Sony NEX-5T\", 0, 0,",
          "13483:       { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },",
          "13484:     { \"Sony NEX-3N\", 0, 0,",
          "13485:       { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },",
          "13487:       { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },",
          "13489:       { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },",
          "13490:     { \"Sony NEX-6\", 0, 0,",
          "13491:       { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },",
          "13492:     { \"Sony NEX-7\", 0, 0,",
          "13493:       { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },",
          "13495:       { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },",
          "13496:     { \"Sony SLT-A33\", 0, 0,",
          "13497:       { 6069,-1221,-366,-5221,12779,2734,-1024,2066,6834 } },",
          "13498:     { \"Sony SLT-A35\", 0, 0,",
          "13499:       { 5986,-1618,-415,-4557,11820,3120,-681,1404,6971 } },",
          "13500:     { \"Sony SLT-A37\", 0, 0,",
          "13501:       { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },",
          "13502:     { \"Sony SLT-A55\", 0, 0,",
          "13503:       { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },",
          "13504:     { \"Sony SLT-A57\", 0, 0,",
          "13505:       { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },",
          "13506:     { \"Sony SLT-A58\", 0, 0,",
          "13507:       { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },",
          "13508:     { \"Sony SLT-A65\", 0, 0,",
          "13509:       { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },",
          "13510:     { \"Sony SLT-A77\", 0, 0,",
          "13511:       { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },",
          "13512:     { \"Sony SLT-A99\", 0, 0,",
          "13513:       { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },",
          "13519:   if(colors>4 || colors < 1) return;",
          "13521:   int bl4=(cblack[0]+cblack[1]+cblack[2]+cblack[3])/4,bl64=0;",
          "13522:   if(cblack[4]*cblack[5]>0)",
          "13524:    for (unsigned c = 0; c < 4096 && c < cblack[4]*cblack[5]; c++)",
          "13525:     bl64+=cblack[c+6];",
          "13526:    bl64 /= cblack[4]*cblack[5];",
          "13528:   int rblack  = black+bl4+bl64;",
          "13530:   sprintf (name, \"%s %s\", t_make, t_model);",
          "13531:   for (i=0; i < sizeof table / sizeof *table; i++)",
          "13532:     if (!strncasecmp(name, table[i].prefix, strlen(table[i].prefix))) {",
          "13533:       if(!dng_version)",
          "13534:  {",
          "13535:    if (table[i].t_black>0)",
          "13536:      {",
          "13537:        black   = (ushort) table[i].t_black;",
          "13538:        memset(cblack,0,sizeof(cblack));",
          "13539:      }",
          "13540:    else if(table[i].t_black <0 && rblack == 0 )",
          "13541:      {",
          "13542:        black   = (ushort) (-table[i].t_black);",
          "13543:        memset(cblack,0,sizeof(cblack));",
          "13544:      }",
          "13545:    if (table[i].t_maximum)",
          "13546:        maximum = (ushort) table[i].t_maximum;",
          "13547:  }",
          "13548:       if (table[i].trans[0]) {",
          "13549:  for (raw_color = j=0; j < 12; j++)",
          "13551:   if(internal_only)",
          "13552:    imgdata.color.cam_xyz[0][j] = table[i].trans[j] / 10000.0;",
          "13553:   else",
          "13554:                   imgdata.color.cam_xyz[0][j] =",
          "13556:                     ((double*)cam_xyz)[j] = table[i].trans[j] / 10000.0;",
          "13558:  if(!internal_only)",
          "13560:           cam_xyz_coeff (rgb_cam, cam_xyz);",
          "13566: void CLASS simple_coeff (int index)",
          "13568:   static const float table[][12] = {",
          "13570:   { 1.4032,-0.2231,-0.1016,-0.5263,1.4816,0.017,-0.0112,0.0183,0.9113 },",
          "13572:   { 2.25,0.75,-1.75,-0.25,-0.25,0.75,0.75,-0.25,-0.25,-1.75,0.75,2.25 },",
          "13574:   { 1.893,-0.418,-0.476,-0.495,1.773,-0.278,-1.017,-0.655,2.672 },",
          "13576:   { -1.936280,  1.800443, -1.448486,  2.584324,",
          "13577:      1.405365, -0.524955, -0.289090,  0.408680,",
          "13578:     -1.204965,  1.082304,  2.941367, -1.818705 }",
          "13579:   };",
          "13582:   for (raw_color = i=0; i < 3; i++)",
          "13583:     FORCC rgb_cam[i][c] = table[index][i*colors+c];",
          "13586: short CLASS guess_byte_order (int words)",
          "13589:   int t=2, msb;",
          "13590:   double diff, sum[2] = {0,0};",
          "13592:   fread (test[0], 2, 2, ifp);",
          "13593:   for (words-=2; words--; ) {",
          "13594:     fread (test[t], 2, 1, ifp);",
          "13595:     for (msb=0; msb < 2; msb++) {",
          "13596:       diff = (test[t^2][msb] << 8 | test[t^2][!msb])",
          "13597:     - (test[t  ][msb] << 8 | test[t  ][!msb]);",
          "13598:       sum[msb] += diff*diff;",
          "13600:     t = (t+1) & 3;",
          "13605: float CLASS find_green (int bps, int bite, int off0, int off1)",
          "13607:   UINT64 bitbuf=0;",
          "13610:   double sum[]={0,0};",
          "13612:   FORC(2) {",
          "13613:     fseek (ifp, c ? off1:off0, SEEK_SET);",
          "13614:     for (vbits=col=0; col < width; col++) {",
          "13615:       for (vbits -= bps; vbits < 0; vbits += bite) {",
          "13616:  bitbuf <<= bite;",
          "13617:  for (i=0; i < bite; i+=8)",
          "13618:    bitbuf |= (unsigned) (fgetc(ifp) << i);",
          "13620:       img[c][col] = bitbuf << (64-bps-vbits) >> (64-bps);",
          "13623:   FORC(width-1) {",
          "13624:     sum[ c & 1] += ABS(img[0][c]-img[1][c+1]);",
          "13625:     sum[~c & 1] += ABS(img[1][c]-img[0][c+1]);",
          "13627:   return 100 * log(sum[0]/sum[1]);",
          "13633:   if(len<1) return; // not needed, b/c sizeof of make/model is 64",
          "13634:   string[len-1]=0;",
          "13635:   if(len<3) return; // also not needed",
          "13636:   len = strnlen(string,len-1);",
          "13637:   for(int i=len-1; i>=0; i--)",
          "13639:     if(isspace(string[i]))",
          "13640:       string[i]=0;",
          "",
          "[Added Lines]",
          "13657: void CLASS adobe_coeff(const char *t_make, const char *t_model",
          "13659:                        ,",
          "13660:                        int internal_only",
          "13662:                        )",
          "13664:   static const struct",
          "13665:   {",
          "13669:       {\"AgfaPhoto DC-833m\",",
          "13670:        0,",
          "13672:        {11438, -3762, -1115, -2409, 9914, 2497, -1227, 2295, 5300}},",
          "13673:       {\"Apple QuickTake\",",
          "13674:        0,",
          "13676:        {21392, -5653, -3353, 2406, 8010, -415, 7166, 1427, 2078}},",
          "13679:       {\"Canon EOS D2000\", 0, 0, {24542, -10860, -3401, -1490, 11370, -297, 2858, -605, 3225}},",
          "13680:       {\"Canon EOS D6000\", 0, 0, {20482, -7172, -3125, -1033, 10410, -285, 2542, 226, 3136}},",
          "13681:       {\"Canon EOS D30\", 0, 0, {9805, -2689, -1312, -5803, 13064, 3068, -2438, 3075, 8775}},",
          "13682:       {\"Canon EOS D60\", 0, 0xfa0, {6188, -1341, -890, -7168, 14489, 2937, -2640, 3228, 8483}},",
          "13683:       {\"Canon EOS 5DS\", 0, 0x3c96, {6250, -711, -808, -5153, 12794, 2636, -1249, 2198, 5610}},",
          "13684:       {\"Canon EOS 5D Mark IV\", 0, 0, {6446, -366, -864, -4436, 12204, 2513, -952, 2496, 6348}},",
          "13685:       {\"Canon EOS 5D Mark III\", 0, 0x3c80, {6722, -635, -963, -4287, 12460, 2028, -908, 2162, 5668}},",
          "13686:       {\"Canon EOS 5D Mark II\", 0, 0x3cf0, {4716, 603, -830, -7798, 15474, 2480, -1496, 1937, 6651}},",
          "13687:       {\"Canon EOS 5D\", 0, 0xe6c, {6347, -479, -972, -8297, 15954, 2480, -1968, 2131, 7649}},",
          "13688:       {\"Canon EOS 6D\", 0, 0x3c82, {8621, -2197, -787, -3150, 11358, 912, -1161, 2400, 4836}},",
          "13689:       {\"Canon EOS 7D Mark II\", 0, 0x3510, {7268, -1082, -969, -4186, 11839, 2663, -825, 2029, 5839}},",
          "13690:       {\"Canon EOS 7D\", 0, 0x3510, {6844, -996, -856, -3876, 11761, 2396, -593, 1772, 6198}},",
          "13691:       {\"Canon EOS 80D\", 0, 0, {7457, -671, -937, -4849, 12495, 2643, -1213, 2354, 5492}},",
          "13692:       {\"Canon EOS 10D\", 0, 0xfa0, {8197, -2000, -1118, -6714, 14335, 2592, -2536, 3178, 8266}},",
          "13693:       {\"Canon EOS 20Da\", 0, 0, {14155, -5065, -1382, -6550, 14633, 2039, -1623, 1824, 6561}},",
          "13694:       {\"Canon EOS 20D\", 0, 0xfff, {6599, -537, -891, -8071, 15783, 2424, -1983, 2234, 7462}},",
          "13695:       {\"Canon EOS 30D\", 0, 0, {6257, -303, -1000, -7880, 15621, 2396, -1714, 1904, 7046}},",
          "13696:       {\"Canon EOS 40D\", 0, 0x3f60, {6071, -747, -856, -7653, 15365, 2441, -2025, 2553, 7315}},",
          "13697:       {\"Canon EOS 50D\", 0, 0x3d93, {4920, 616, -593, -6493, 13964, 2784, -1774, 3178, 7005}},",
          "13698:       {\"Canon EOS 60D\", 0, 0x2ff7, {6719, -994, -925, -4408, 12426, 2211, -887, 2129, 6051}},",
          "13699:       {\"Canon EOS 70D\", 0, 0x3bc7, {7034, -804, -1014, -4420, 12564, 2058, -851, 1994, 5758}},",
          "13700:       {\"Canon EOS 100D\", 0, 0x350f, {6602, -841, -939, -4472, 12458, 2247, -975, 2039, 6148}},",
          "13701:       {\"Canon EOS 300D\", 0, 0xfa0, {8197, -2000, -1118, -6714, 14335, 2592, -2536, 3178, 8266}},",
          "13702:       {\"Canon EOS 350D\", 0, 0xfff, {6018, -617, -965, -8645, 15881, 2975, -1530, 1719, 7642}},",
          "13703:       {\"Canon EOS 400D\", 0, 0xe8e, {7054, -1501, -990, -8156, 15544, 2812, -1278, 1414, 7796}},",
          "13704:       {\"Canon EOS 450D\", 0, 0x390d, {5784, -262, -821, -7539, 15064, 2672, -1982, 2681, 7427}},",
          "13705:       {\"Canon EOS 500D\", 0, 0x3479, {4763, 712, -646, -6821, 14399, 2640, -1921, 3276, 6561}},",
          "13706:       {\"Canon EOS 550D\", 0, 0x3dd7, {6941, -1164, -857, -3825, 11597, 2534, -416, 1540, 6039}},",
          "13707:       {\"Canon EOS 600D\", 0, 0x3510, {6461, -907, -882, -4300, 12184, 2378, -819, 1944, 5931}},",
          "13708:       {\"Canon EOS 650D\", 0, 0x354d, {6602, -841, -939, -4472, 12458, 2247, -975, 2039, 6148}},",
          "13709:       {\"Canon EOS 750D\", 0, 0x3c00, {6362, -823, -847, -4426, 12109, 2616, -743, 1857, 5635}},",
          "13710:       {\"Canon EOS 760D\", 0, 0x3c00, {6362, -823, -847, -4426, 12109, 2616, -743, 1857, 5635}},",
          "13711:       {\"Canon EOS 700D\", 0, 0x3c00, {6602, -841, -939, -4472, 12458, 2247, -975, 2039, 6148}},",
          "13712:       {\"Canon EOS 1000D\", 0, 0xe43, {6771, -1139, -977, -7818, 15123, 2928, -1244, 1437, 7533}},",
          "13713:       {\"Canon EOS 1100D\", 0, 0x3510, {6444, -904, -893, -4563, 12308, 2535, -903, 2016, 6728}},",
          "13714:       {\"Canon EOS 1200D\", 0, 0x37c2, {6461, -907, -882, -4300, 12184, 2378, -819, 1944, 5931}},",
          "13715:       {\"Canon EOS 1300D\", 0, 0x37c2, {6939, -1016, -866, -4428, 12473, 2177, -1175, 2178, 6162}},",
          "13716:       {\"Canon EOS M3\", 0, 0, {6362, -823, -847, -4426, 12109, 2616, -743, 1857, 5635}},",
          "13717:       {\"Canon EOS M5\",",
          "13718:        0,",
          "13720:        {8532, -701, -1167, -4095, 11879, 2508, -797, 2424, 7010}},",
          "13721:       {\"Canon EOS M10\", 0, 0, {6400, -480, -888, -5294, 13416, 2047, -1296, 2203, 6137}},",
          "13722:       {\"Canon EOS M\", 0, 0, {6602, -841, -939, -4472, 12458, 2247, -975, 2039, 6148}},",
          "13723:       {\"Canon EOS-1Ds Mark III\", 0, 0x3bb0, {5859, -211, -930, -8255, 16017, 2353, -1732, 1887, 7448}},",
          "13724:       {\"Canon EOS-1Ds Mark II\", 0, 0xe80, {6517, -602, -867, -8180, 15926, 2378, -1618, 1771, 7633}},",
          "13725:       {\"Canon EOS-1D Mark IV\", 0, 0x3bb0, {6014, -220, -795, -4109, 12014, 2361, -561, 1824, 5787}},",
          "13726:       {\"Canon EOS-1D Mark III\", 0, 0x3bb0, {6291, -540, -976, -8350, 16145, 2311, -1714, 1858, 7326}},",
          "13727:       {\"Canon EOS-1D Mark II N\", 0, 0xe80, {6240, -466, -822, -8180, 15825, 2500, -1801, 1938, 8042}},",
          "13728:       {\"Canon EOS-1D Mark II\", 0, 0xe80, {6264, -582, -724, -8312, 15948, 2504, -1744, 1919, 8664}},",
          "13729:       {\"Canon EOS-1DS\", 0, 0xe20, {4374, 3631, -1743, -7520, 15212, 2472, -2892, 3632, 8161}},",
          "13730:       {\"Canon EOS-1D C\", 0, 0x3c4e, {6847, -614, -1014, -4669, 12737, 2139, -1197, 2488, 6846}},",
          "13731:       {\"Canon EOS-1D X Mark II\", 0, 0x3c4e, {7596, -978, 967, -4808, 12571, 2503, -1398, 2567, 5752}},",
          "13732:       {\"Canon EOS-1D X\", 0, 0x3c4e, {6847, -614, -1014, -4669, 12737, 2139, -1197, 2488, 6846}},",
          "13733:       {\"Canon EOS-1D\", 0, 0xe20, {6806, -179, -1020, -8097, 16415, 1687, -3267, 4236, 7690}},",
          "13734:       {\"Canon EOS C500\",",
          "13735:        853,",
          "13737:        {17851, -10604, 922, -7425, 16662, 763, -3660, 3636, 22278}},",
          "13739:       {\"Canon PowerShot A50\", 0, 0, {-5300, 9846, 1776, 3436, 684, 3939, -5540, 9879, 6200, -1404, 11175, 217}},",
          "13740:       {\"Canon PowerShot A5\", 0, 0, {-4801, 9475, 1952, 2926, 1611, 4094, -5259, 10164, 5947, -1554, 10883, 547}},",
          "13741:       {\"Canon PowerShot G10\", 0, 0, {11093, -3906, -1028, -5047, 12492, 2879, -1003, 1750, 5561}},",
          "13742:       {\"Canon PowerShot G11\", 0, 0, {12177, -4817, -1069, -1612, 9864, 2049, -98, 850, 4471}},",
          "13743:       {\"Canon PowerShot G12\", 0, 0, {13244, -5501, -1248, -1508, 9858, 1935, -270, 1083, 4366}},",
          "13744:       {\"Canon PowerShot G15\", 0, 0, {7474, -2301, -567, -4056, 11456, 2975, -222, 716, 4181}},",
          "13745:       {\"Canon PowerShot G16\", 0, 0, {14130, -8071, 127, 2199, 6528, 1551, 3402, -1721, 4960}},",
          "13746:       {\"Canon PowerShot G1 X Mark II\", 0, 0, {7378, -1255, -1043, -4088, 12251, 2048, -876, 1946, 5805}},",
          "13747:       {\"Canon PowerShot G1 X\", 0, 0, {7378, -1255, -1043, -4088, 12251, 2048, -876, 1946, 5805}},",
          "13748:       {\"Canon PowerShot G1\", 0, 0, {-4778, 9467, 2172, 4743, -1141, 4344, -5146, 9908, 6077, -1566, 11051, 557}},",
          "13749:       {\"Canon PowerShot G2\", 0, 0, {9087, -2693, -1049, -6715, 14382, 2537, -2291, 2819, 7790}},",
          "13750:       {\"Canon PowerShot G3 X\", 0, 0, {9701, -3857, -921, -3149, 11537, 1817, -786, 1817, 5147}},",
          "13751:       {\"Canon PowerShot G3\", 0, 0, {9212, -2781, -1073, -6573, 14189, 2605, -2300, 2844, 7664}},",
          "13752:       {\"Canon PowerShot G5 X\", 0, 0, {9602, -3823, -937, -2984, 11495, 1675, -407, 1415, 5049}},",
          "13753:       {\"Canon PowerShot G5\", 0, 0, {9757, -2872, -933, -5972, 13861, 2301, -1622, 2328, 7212}},",
          "13754:       {\"Canon PowerShot G6\", 0, 0, {9877, -3775, -871, -7613, 14807, 3072, -1448, 1305, 7485}},",
          "13755:       {\"Canon PowerShot G7 X Mark II\", 0, 0, {9602, -3823, -937, -2984, 11495, 1675, -407, 1415, 5049}},",
          "13756:       {\"Canon PowerShot G7 X\", 0, 0, {9602, -3823, -937, -2984, 11495, 1675, -407, 1415, 5049}},",
          "13757:       {\"Canon PowerShot G9 X\", 0, 0, {9602, -3823, -937, -2984, 11495, 1675, -407, 1415, 5049}},",
          "13758:       {\"Canon PowerShot G9\", 0, 0, {7368, -2141, -598, -5621, 13254, 2625, -1418, 1696, 5743}},",
          "13759:       {\"Canon PowerShot Pro1\", 0, 0, {10062, -3522, -999, -7643, 15117, 2730, -765, 817, 7323}},",
          "13760:       {\"Canon PowerShot Pro70\", 34, 0, {-4155, 9818, 1529, 3939, -25, 4522, -5521, 9870, 6610, -2238, 10873, 1342}},",
          "13761:       {\"Canon PowerShot Pro90\", 0, 0, {-4963, 9896, 2235, 4642, -987, 4294, -5162, 10011, 5859, -1770, 11230, 577}},",
          "13762:       {\"Canon PowerShot S30\", 0, 0, {10566, -3652, -1129, -6552, 14662, 2006, -2197, 2581, 7670}},",
          "13763:       {\"Canon PowerShot S40\", 0, 0, {8510, -2487, -940, -6869, 14231, 2900, -2318, 2829, 9013}},",
          "13764:       {\"Canon PowerShot S45\", 0, 0, {8163, -2333, -955, -6682, 14174, 2751, -2077, 2597, 8041}},",
          "13765:       {\"Canon PowerShot S50\", 0, 0, {8882, -2571, -863, -6348, 14234, 2288, -1516, 2172, 6569}},",
          "13766:       {\"Canon PowerShot S60\", 0, 0, {8795, -2482, -797, -7804, 15403, 2573, -1422, 1996, 7082}},",
          "13767:       {\"Canon PowerShot S70\", 0, 0, {9976, -3810, -832, -7115, 14463, 2906, -901, 989, 7889}},",
          "13768:       {\"Canon PowerShot S90\", 0, 0, {12374, -5016, -1049, -1677, 9902, 2078, -83, 852, 4683}},",
          "13769:       {\"Canon PowerShot S95\", 0, 0, {13440, -5896, -1279, -1236, 9598, 1931, -180, 1001, 4651}},",
          "13770:       {\"Canon PowerShot S120\", 0, 0, {6961, -1685, -695, -4625, 12945, 1836, -1114, 2152, 5518}},",
          "13771:       {\"Canon PowerShot S110\", 0, 0, {8039, -2643, -654, -3783, 11230, 2930, -206, 690, 4194}},",
          "13772:       {\"Canon PowerShot S100\", 0, 0, {7968, -2565, -636, -2873, 10697, 2513, 180, 667, 4211}},",
          "13773:       {\"Canon PowerShot SX1 IS\", 0, 0, {6578, -259, -502, -5974, 13030, 3309, -308, 1058, 4970}},",
          "13774:       {\"Canon PowerShot SX50 HS\", 0, 0, {12432, -4753, -1247, -2110, 10691, 1629, -412, 1623, 4926}},",
          "13775:       {\"Canon PowerShot SX60 HS\", 0, 0, {13161, -5451, -1344, -1989, 10654, 1531, -47, 1271, 4955}},",
          "13776:       {\"Canon PowerShot A3300\",",
          "13777:        0,",
          "13779:        {10826, -3654, -1023, -3215, 11310, 1906, 0, 999, 4960}},",
          "13780:       {\"Canon PowerShot A470\",",
          "13781:        0,",
          "13783:        {12513, -4407, -1242, -2680, 10276, 2405, -878, 2215, 4734}},",
          "13784:       {\"Canon PowerShot A610\",",
          "13785:        0,",
          "13787:        {15591, -6402, -1592, -5365, 13198, 2168, -1300, 1824, 5075}},",
          "13788:       {\"Canon PowerShot A620\",",
          "13789:        0,",
          "13791:        {15265, -6193, -1558, -4125, 12116, 2010, -888, 1639, 5220}},",
          "13792:       {\"Canon PowerShot A630\",",
          "13793:        0,",
          "13795:        {14201, -5308, -1757, -6087, 14472, 1617, -2191, 3105, 5348}},",
          "13796:       {\"Canon PowerShot A640\",",
          "13797:        0,",
          "13799:        {13124, -5329, -1390, -3602, 11658, 1944, -1612, 2863, 4885}},",
          "13800:       {\"Canon PowerShot A650\",",
          "13801:        0,",
          "13803:        {9427, -3036, -959, -2581, 10671, 1911, -1039, 1982, 4430}},",
          "13804:       {\"Canon PowerShot A720\",",
          "13805:        0,",
          "13807:        {14573, -5482, -1546, -1266, 9799, 1468, -1040, 1912, 3810}},",
          "13808:       {\"Canon PowerShot S3 IS\",",
          "13809:        0,",
          "13811:        {14062, -5199, -1446, -4712, 12470, 2243, -1286, 2028, 4836}},",
          "13812:       {\"Canon PowerShot SX110 IS\",",
          "13813:        0,",
          "13815:        {14134, -5576, -1527, -1991, 10719, 1273, -1158, 1929, 3581}},",
          "13816:       {\"Canon PowerShot SX220\",",
          "13817:        0,",
          "13819:        {13898, -5076, -1447, -1405, 10109, 1297, -244, 1860, 3687}},",
          "13820:       {\"Canon IXUS 160\",",
          "13821:        0,",
          "13823:        {11657, -3781, -1136, -3544, 11262, 2283, -160, 1219, 4700}},",
          "13824:       {\"Casio EX-S20\",",
          "13825:        0,",
          "13827:        {11634, -3924, -1128, -4968, 12954, 2015, -1588, 2648, 7206}},",
          "13828:       {\"Casio EX-Z750\",",
          "13829:        0,",
          "13831:        {10819, -3873, -1099, -4903, 13730, 1175, -1755, 3751, 4632}},",
          "13832:       {\"Casio EX-Z10\",",
          "13833:        128,",
          "13835:        {9790, -3338, -603, -2321, 10222, 2099, -344, 1273, 4799}},",
          "13836:       {\"CINE 650\", 0, 0, {3390, 480, -500, -800, 3610, 340, -550, 2336, 1192}},",
          "13837:       {\"CINE 660\", 0, 0, {3390, 480, -500, -800, 3610, 340, -550, 2336, 1192}},",
          "13838:       {\"CINE\", 0, 0, {20183, -4295, -423, -3940, 15330, 3985, -280, 4870, 9800}},",
          "13839:       {\"Contax N Digital\", 0, 0xf1e, {7777, 1285, -1053, -9280, 16543, 2916, -3677, 5679, 7060}},",
          "13840:       {\"DXO ONE\", 0, 0, {6596, -2079, -562, -4782, 13016, 1933, -970, 1581, 5181}},",
          "13841:       {\"Epson R-D1\", 0, 0, {6827, -1878, -732, -8429, 16012, 2564, -704, 592, 7145}},",
          "13842:       {\"Fujifilm E550\", 0, 0, {11044, -3888, -1120, -7248, 15168, 2208, -1531, 2277, 8069}},",
          "13843:       {\"Fujifilm E900\", 0, 0, {9183, -2526, -1078, -7461, 15071, 2574, -2022, 2440, 8639}},",
          "13844:       {\"Fujifilm F5\", 0, 0, {13690, -5358, -1474, -3369, 11600, 1998, -132, 1554, 4395}},",
          "13845:       {\"Fujifilm F6\", 0, 0, {13690, -5358, -1474, -3369, 11600, 1998, -132, 1554, 4395}},",
          "13846:       {\"Fujifilm F77\", 0, 0xfe9, {13690, -5358, -1474, -3369, 11600, 1998, -132, 1554, 4395}},",
          "13847:       {\"Fujifilm F7\", 0, 0, {10004, -3219, -1201, -7036, 15047, 2107, -1863, 2565, 7736}},",
          "13848:       {\"Fujifilm F8\", 0, 0, {13690, -5358, -1474, -3369, 11600, 1998, -132, 1554, 4395}},",
          "13849:       {\"Fujifilm S100FS\", 514, 0, {11521, -4355, -1065, -6524, 13767, 3058, -1466, 1984, 6045}},",
          "13850:       {\"Fujifilm S1\", 0, 0, {12297, -4882, -1202, -2106, 10691, 1623, -88, 1312, 4790}},",
          "13851:       {\"Fujifilm S20Pro\", 0, 0, {10004, -3219, -1201, -7036, 15047, 2107, -1863, 2565, 7736}},",
          "13852:       {\"Fujifilm S20\", 512, 0x3fff, {11401, -4498, -1312, -5088, 12751, 2613, -838, 1568, 5941}},",
          "13853:       {\"Fujifilm S2Pro\", 128, 0, {12492, -4690, -1402, -7033, 15423, 1647, -1507, 2111, 7697}},",
          "13854:       {\"Fujifilm S3Pro\", 0, 0, {11807, -4612, -1294, -8927, 16968, 1988, -2120, 2741, 8006}},",
          "13855:       {\"Fujifilm S5Pro\", 0, 0, {12300, -5110, -1304, -9117, 17143, 1998, -1947, 2448, 8100}},",
          "13856:       {\"Fujifilm S5000\", 0, 0, {8754, -2732, -1019, -7204, 15069, 2276, -1702, 2334, 6982}},",
          "13857:       {\"Fujifilm S5100\", 0, 0, {11940, -4431, -1255, -6766, 14428, 2542, -993, 1165, 7421}},",
          "13858:       {\"Fujifilm S5500\", 0, 0, {11940, -4431, -1255, -6766, 14428, 2542, -993, 1165, 7421}},",
          "13859:       {\"Fujifilm S5200\", 0, 0, {9636, -2804, -988, -7442, 15040, 2589, -1803, 2311, 8621}},",
          "13860:       {\"Fujifilm S5600\", 0, 0, {9636, -2804, -988, -7442, 15040, 2589, -1803, 2311, 8621}},",
          "13861:       {\"Fujifilm S6\", 0, 0, {12628, -4887, -1401, -6861, 14996, 1962, -2198, 2782, 7091}},",
          "13862:       {\"Fujifilm S7000\", 0, 0, {10190, -3506, -1312, -7153, 15051, 2238, -2003, 2399, 7505}},",
          "13863:       {\"Fujifilm S9000\", 0, 0, {10491, -3423, -1145, -7385, 15027, 2538, -1809, 2275, 8692}},",
          "13864:       {\"Fujifilm S9500\", 0, 0, {10491, -3423, -1145, -7385, 15027, 2538, -1809, 2275, 8692}},",
          "13865:       {\"Fujifilm S9100\", 0, 0, {12343, -4515, -1285, -7165, 14899, 2435, -1895, 2496, 8800}},",
          "13866:       {\"Fujifilm S9600\", 0, 0, {12343, -4515, -1285, -7165, 14899, 2435, -1895, 2496, 8800}},",
          "13867:       {\"Fujifilm SL1000\", 0, 0, {11705, -4262, -1107, -2282, 10791, 1709, -555, 1713, 4945}},",
          "13868:       {\"Fujifilm IS-1\", 0, 0, {21461, -10807, -1441, -2332, 10599, 1999, 289, 875, 7703}},",
          "13869:       {\"Fujifilm IS Pro\", 0, 0, {12300, -5110, -1304, -9117, 17143, 1998, -1947, 2448, 8100}},",
          "13870:       {\"Fujifilm HS10 HS11\", 0, 0xf68, {12440, -3954, -1183, -1123, 9674, 1708, -83, 1614, 4086}},",
          "13871:       {\"Fujifilm HS2\", 0, 0, {13690, -5358, -1474, -3369, 11600, 1998, -132, 1554, 4395}},",
          "13872:       {\"Fujifilm HS3\", 0, 0, {13690, -5358, -1474, -3369, 11600, 1998, -132, 1554, 4395}},",
          "13873:       {\"Fujifilm HS50EXR\", 0, 0, {12085, -4727, -953, -3257, 11489, 2002, -511, 2046, 4592}},",
          "13874:       {\"Fujifilm F900EXR\", 0, 0, {12085, -4727, -953, -3257, 11489, 2002, -511, 2046, 4592}},",
          "13875:       {\"Fujifilm X100S\", 0, 0, {10592, -4262, -1008, -3514, 11355, 2465, -870, 2025, 6386}},",
          "13876:       {\"Fujifilm X100T\", 0, 0, {10592, -4262, -1008, -3514, 11355, 2465, -870, 2025, 6386}},",
          "13877:       {\"Fujifilm X100\", 0, 0, {12161, -4457, -1069, -5034, 12874, 2400, -795, 1724, 6904}},",
          "13878:       {\"Fujifilm X10\", 0, 0, {13509, -6199, -1254, -4430, 12733, 1865, -331, 1441, 5022}},",
          "13879:       {\"Fujifilm X20\", 0, 0, {11768, -4971, -1133, -4904, 12927, 2183, -480, 1723, 4605}},",
          "13880:       {\"Fujifilm X30\", 0, 0, {12328, -5256, -1144, -4469, 12927, 1675, -87, 1291, 4351}},",
          "13881:       {\"Fujifilm X70\", 0, 0, {10450, -4329, -878, -3217, 11105, 2421, -752, 1758, 6519}},",
          "13882:       {\"Fujifilm X-Pro1\", 0, 0, {10413, -3996, -993, -3721, 11640, 2361, -733, 1540, 6011}},",
          "13883:       {\"Fujifilm X-Pro2\", 0, 0, {11434, -4948, -1210, -3746, 12042, 1903, -666, 1479, 5235}},",
          "13884:       {\"Fujifilm X-A1\", 0, 0, {11086, -4555, -839, -3512, 11310, 2517, -815, 1341, 5940}},",
          "13885:       {\"Fujifilm X-A2\", 0, 0, {10763, -4560, -917, -3346, 11311, 2322, -475, 1135, 5843}},",
          "13886:       {\"Fujifilm X-E1\", 0, 0, {10413, -3996, -993, -3721, 11640, 2361, -733, 1540, 6011}},",
          "13887:       {\"Fujifilm X-E2S\", 0, 0, {11562, -5118, -961, -3022, 11007, 2311, -525, 1569, 6097}},",
          "13888:       {\"Fujifilm X-E2\", 0, 0, {12066, -5927, -367, -1969, 9878, 1503, -721, 2034, 5453}},",
          "13889:       {\"Fujifilm XF1\", 0, 0, {13509, -6199, -1254, -4430, 12733, 1865, -331, 1441, 5022}},",
          "13890:       {\"Fujifilm X-M1\", 0, 0, {13193, -6685, -425, -2229, 10458, 1534, -878, 1763, 5217}},",
          "13891:       {\"Fujifilm X-S1\", 0, 0, {13509, -6199, -1254, -4430, 12733, 1865, -331, 1441, 5022}},",
          "13892:       {\"Fujifilm X-T10\", 0, 0, {10763, -4560, -917, -3346, 11311, 2322, -475, 1135, 5843}},",
          "13893:       {\"Fujifilm X-T1\", 0, 0, {8458, -2451, -855, -4597, 12447, 2407, -1475, 2482, 6526}},",
          "13894:       {\"Fujifilm X-T2\", 0, 0, {11434, -4948, -1210, -3746, 12042, 1903, -666, 1479, 5235}},",
          "13895:       {\"Fujifilm XQ1\", 0, 0, {9252, -2704, -1064, -5893, 14265, 1717, -1101, 2341, 4349}},",
          "13896:       {\"Fujifilm XQ2\", 0, 0, {9252, -2704, -1064, -5893, 14265, 1717, -1101, 2341, 4349}},",
          "13897:       {\"GITUP GIT2\", 3200, 0, {8489, -2583, -1036, -8051, 15583, 2643, -1307, 1407, 7354}},",
          "13898:       {\"Hasselblad Lunar\", 0, 0, {5491, -1192, -363, -4951, 12342, 2948, -911, 1722, 7192}},",
          "13899:       {\"Hasselblad Stellar\", -800, 0, {8651, -2754, -1057, -3464, 12207, 1373, -568, 1398, 4434}},",
          "13900:       {\"Hasselblad CFV\",",
          "13901:        0,",
          "13903:        {",
          "13904:            8519, -3260, -280, -5081, 13459, 1738, -1449, 2960, 7809,",
          "13905:        }},",
          "13906:       {\"Hasselblad H-16MP\",",
          "13907:        0,",
          "13909:        {17765, -5322, -1734, -6168, 13354, 2135, -264, 2524, 7440}},",
          "13910:       {\"Hasselblad H-22MP\",",
          "13911:        0,",
          "13913:        {17765, -5322, -1734, -6168, 13354, 2135, -264, 2524, 7440}},",
          "13914:       {\"Hasselblad H-31MP\",",
          "13915:        0,",
          "13917:        {14480, -5448, -1686, -3534, 13123, 2260, 384, 2952, 7232}},",
          "13918:       {\"Hasselblad H-39MP\",",
          "13919:        0,",
          "13921:        {3857, 452, -46, -6008, 14477, 1596, -2627, 4481, 5718}},",
          "13922:       {\"Hasselblad H3D-50\",",
          "13923:        0,",
          "13925:        {3857, 452, -46, -6008, 14477, 1596, -2627, 4481, 5718}},",
          "13926:       {\"Hasselblad H4D-40\",",
          "13927:        0,",
          "13929:        {6325, -860, -957, -6559, 15945, 266, 167, 770, 5936}},",
          "13930:       {\"Hasselblad H4D-50\",",
          "13931:        0,",
          "13933:        {15283, -6272, -465, -2030, 16031, 478, -2379, 390, 7965}},",
          "13934:       {\"Hasselblad H4D-60\",",
          "13935:        0,",
          "13937:        {9662, -684, -279, -4903, 12293, 2950, -344, 1669, 6024}},",
          "13938:       {\"Hasselblad H5D-50c\",",
          "13939:        0,",
          "13941:        {4932, -835, 141, -4878, 11868, 3437, -1138, 1961, 7067}},",
          "13942:       {\"Hasselblad H5D-50\",",
          "13943:        0,",
          "13945:        {5656, -659, -346, -3923, 12306, 1791, -1602, 3509, 5442}},",
          "13946:       {\"Hasselblad X1D\",",
          "13947:        0,",
          "13949:        {4932, -835, 141, -4878, 11868, 3437, -1138, 1961, 7067}},",
          "13950:       {\"HTC One A9\",",
          "13951:        64,",
          "13953:        {101, -20, -2, -11, 145, 41, -24, 1, 56}},",
          "13954:       {\"Imacon Ixpress\",",
          "13955:        0,",
          "13957:        {7025, -1415, -704, -5188, 13765, 1424, -1248, 2742, 6038}},",
          "13958:       {\"Kodak NC2000\", 0, 0, {13891, -6055, -803, -465, 9919, 642, 2121, 82, 1291}},",
          "13959:       {\"Kodak DCS315C\", -8, 0, {17523, -4827, -2510, 756, 8546, -137, 6113, 1649, 2250}},",
          "13960:       {\"Kodak DCS330C\", -8, 0, {20620, -7572, -2801, -103, 10073, -396, 3551, -233, 2220}},",
          "13961:       {\"Kodak DCS420\", 0, 0, {10868, -1852, -644, -1537, 11083, 484, 2343, 628, 2216}},",
          "13962:       {\"Kodak DCS460\", 0, 0, {10592, -2206, -967, -1944, 11685, 230, 2206, 670, 1273}},",
          "13963:       {\"Kodak EOSDCS1\", 0, 0, {10592, -2206, -967, -1944, 11685, 230, 2206, 670, 1273}},",
          "13964:       {\"Kodak EOSDCS3B\", 0, 0, {9898, -2700, -940, -2478, 12219, 206, 1985, 634, 1031}},",
          "13965:       {\"Kodak DCS520C\", -178, 0, {24542, -10860, -3401, -1490, 11370, -297, 2858, -605, 3225}},",
          "13966:       {\"Kodak DCS560C\", -177, 0, {20482, -7172, -3125, -1033, 10410, -285, 2542, 226, 3136}},",
          "13967:       {\"Kodak DCS620C\", -177, 0, {23617, -10175, -3149, -2054, 11749, -272, 2586, -489, 3453}},",
          "13968:       {\"Kodak DCS620X\", -176, 0, {13095, -6231, 154, 12221, -21, -2137, 895, 4602, 2258}},",
          "13969:       {\"Kodak DCS660C\", -173, 0, {18244, -6351, -2739, -791, 11193, -521, 3711, -129, 2802}},",
          "13970:       {\"Kodak DCS720X\", 0, 0, {11775, -5884, 950, 9556, 1846, -1286, -1019, 6221, 2728}},",
          "13971:       {\"Kodak DCS760C\", 0, 0, {16623, -6309, -1411, -4344, 13923, 323, 2285, 274, 2926}},",
          "13972:       {\"Kodak DCS Pro SLR\", 0, 0, {5494, 2393, -232, -6427, 13850, 2846, -1876, 3997, 5445}},",
          "13973:       {\"Kodak DCS Pro 14nx\", 0, 0, {5494, 2393, -232, -6427, 13850, 2846, -1876, 3997, 5445}},",
          "13974:       {\"Kodak DCS Pro 14\", 0, 0, {7791, 3128, -776, -8588, 16458, 2039, -2455, 4006, 6198}},",
          "13975:       {\"Kodak ProBack645\", 0, 0, {16414, -6060, -1470, -3555, 13037, 473, 2545, 122, 4948}},",
          "13976:       {\"Kodak ProBack\", 0, 0, {21179, -8316, -2918, -915, 11019, -165, 3477, -180, 4210}},",
          "13977:       {\"Kodak P712\", 0, 0, {9658, -3314, -823, -5163, 12695, 2768, -1342, 1843, 6044}},",
          "13978:       {\"Kodak P850\", 0, 0xf7c, {10511, -3836, -1102, -6946, 14587, 2558, -1481, 1792, 6246}},",
          "13979:       {\"Kodak P880\", 0, 0xfff, {12805, -4662, -1376, -7480, 15267, 2360, -1626, 2194, 7904}},",
          "13980:       {\"Kodak EasyShare Z980\", 0, 0, {11313, -3559, -1101, -3893, 11891, 2257, -1214, 2398, 4908}},",
          "13981:       {\"Kodak EasyShare Z981\", 0, 0, {12729, -4717, -1188, -1367, 9187, 2582, 274, 860, 4411}},",
          "13982:       {\"Kodak EasyShare Z990\", 0, 0xfed, {11749, -4048, -1309, -1867, 10572, 1489, -138, 1449, 4522}},",
          "13983:       {\"Kodak EASYSHARE Z1015\", 0, 0xef1, {11265, -4286, -992, -4694, 12343, 2647, -1090, 1523, 5447}},",
          "13984:       {\"Leaf CMost\", 0, 0, {3952, 2189, 449, -6701, 14585, 2275, -4536, 7349, 6536}},",
          "13985:       {\"Leaf Valeo 6\", 0, 0, {3952, 2189, 449, -6701, 14585, 2275, -4536, 7349, 6536}},",
          "13986:       {\"Leaf Aptus 54S\", 0, 0, {8236, 1746, -1314, -8251, 15953, 2428, -3673, 5786, 5771}},",
          "13987:       {\"Leaf Aptus 65\", 0, 0, {7914, 1414, -1190, -8777, 16582, 2280, -2811, 4605, 5562}},",
          "13988:       {\"Leaf Aptus 75\", 0, 0, {7914, 1414, -1190, -8777, 16582, 2280, -2811, 4605, 5562}},",
          "13989:       {\"Leaf Credo 40\", 0, 0, {8035, 435, -962, -6001, 13872, 2320, -1159, 3065, 5434}},",
          "13990:       {\"Leaf Credo 50\", 0, 0, {3984, 0, 0, 0, 10000, 0, 0, 0, 7666}},",
          "13991:       {\"Leaf Credo 60\", 0, 0, {8035, 435, -962, -6001, 13872, 2320, -1159, 3065, 5434}},",
          "13992:       {\"Leaf Credo 80\", 0, 0, {6294, 686, -712, -5435, 13417, 2211, -1006, 2435, 5042}},",
          "13993:       {\"Leaf\", 0, 0, {8236, 1746, -1314, -8251, 15953, 2428, -3673, 5786, 5771}},",
          "13994:       {\"Mamiya ZD\", 0, 0, {7645, 2579, -1363, -8689, 16717, 2015, -3712, 5941, 5961}},",
          "13995:       {\"Micron 2010\",",
          "13996:        110,",
          "13998:        {16695, -3761, -2151, 155, 9682, 163, 3433, 951, 4904}},",
          "13999:       {\"Minolta DiMAGE 5\", 0, 0xf7d, {8983, -2942, -963, -6556, 14476, 2237, -2426, 2887, 8014}},",
          "14000:       {\"Minolta DiMAGE 7Hi\", 0, 0xf7d, {11368, -3894, -1242, -6521, 14358, 2339, -2475, 3056, 7285}},",
          "14001:       {\"Minolta DiMAGE 7\", 0, 0xf7d, {9144, -2777, -998, -6676, 14556, 2281, -2470, 3019, 7744}},",
          "14002:       {\"Minolta DiMAGE A1\", 0, 0xf8b, {9274, -2547, -1167, -8220, 16323, 1943, -2273, 2720, 8340}},",
          "14003:       {\"Minolta DiMAGE A200\", 0, 0, {8560, -2487, -986, -8112, 15535, 2771, -1209, 1324, 7743}},",
          "14004:       {\"Minolta DiMAGE A2\", 0, 0xf8f, {9097, -2726, -1053, -8073, 15506, 2762, -966, 981, 7763}},",
          "14005:       {\"Minolta DiMAGE Z2\",",
          "14006:        0,",
          "14008:        {11280, -3564, -1370, -4655, 12374, 2282, -1423, 2168, 5396}},",
          "14009:       {\"Minolta DYNAX 5\", 0, 0xffb, {10284, -3283, -1086, -7957, 15762, 2316, -829, 882, 6644}},",
          "14010:       {\"Minolta DYNAX 7\", 0, 0xffb, {10239, -3104, -1099, -8037, 15727, 2451, -927, 925, 6871}},",
          "14011:       {\"Motorola PIXL\",",
          "14012:        0,",
          "14014:        {8898, -989, -1033, -3292, 11619, 1674, -661, 3178, 5216}},",
          "14015:       {\"Nikon D100\", 0, 0, {5902, -933, -782, -8983, 16719, 2354, -1402, 1455, 6464}},",
          "14016:       {\"Nikon D1H\", 0, 0, {7577, -2166, -926, -7454, 15592, 1934, -2377, 2808, 8606}},",
          "14017:       {\"Nikon D1X\", 0, 0, {7702, -2245, -975, -9114, 17242, 1875, -2679, 3055, 8521}},",
          "14018:       {\"Nikon D1\",",
          "14019:        0,",
          "14021:        {16772, -4726, -2141, -7611, 15713, 1972, -2846, 3494, 9521}},",
          "14022:       {\"Nikon D200\", 0, 0xfbc, {8367, -2248, -763, -8758, 16447, 2422, -1527, 1550, 8053}},",
          "14023:       {\"Nikon D2H\", 0, 0, {5710, -901, -615, -8594, 16617, 2024, -2975, 4120, 6830}},",
          "14024:       {\"Nikon D2X\", 0, 0, {10231, -2769, -1255, -8301, 15900, 2552, -797, 680, 7148}},",
          "14025:       {\"Nikon D3000\", 0, 0, {8736, -2458, -935, -9075, 16894, 2251, -1354, 1242, 8263}},",
          "14026:       {\"Nikon D3100\", 0, 0, {7911, -2167, -813, -5327, 13150, 2408, -1288, 2483, 7968}},",
          "14027:       {\"Nikon D3200\", 0, 0xfb9, {7013, -1408, -635, -5268, 12902, 2640, -1470, 2801, 7379}},",
          "14028:       {\"Nikon D3300\", 0, 0, {6988, -1384, -714, -5631, 13410, 2447, -1485, 2204, 7318}},",
          "14029:       {\"Nikon D3400\", 0, 0, {6988, -1384, -714, -5631, 13410, 2447, -1485, 2204, 7318}},",
          "14030:       {\"Nikon D300\", 0, 0, {9030, -1992, -715, -8465, 16302, 2255, -2689, 3217, 8069}},",
          "14031:       {\"Nikon D3X\", 0, 0, {7171, -1986, -648, -8085, 15555, 2718, -2170, 2512, 7457}},",
          "14032:       {\"Nikon D3S\", 0, 0, {8828, -2406, -694, -4874, 12603, 2541, -660, 1509, 7587}},",
          "14033:       {\"Nikon D3\", 0, 0, {8139, -2171, -663, -8747, 16541, 2295, -1925, 2008, 8093}},",
          "14034:       {\"Nikon D40X\", 0, 0, {8819, -2543, -911, -9025, 16928, 2151, -1329, 1213, 8449}},",
          "14035:       {\"Nikon D40\", 0, 0, {6992, -1668, -806, -8138, 15748, 2543, -874, 850, 7897}},",
          "14036:       {\"Nikon D4S\", 0, 0, {8598, -2848, -857, -5618, 13606, 2195, -1002, 1773, 7137}},",
          "14037:       {\"Nikon D4\", 0, 0, {8598, -2848, -857, -5618, 13606, 2195, -1002, 1773, 7137}},",
          "14038:       {\"Nikon Df\", 0, 0, {8598, -2848, -857, -5618, 13606, 2195, -1002, 1773, 7137}},",
          "14039:       {\"Nikon D5000\", 0, 0xf00, {7309, -1403, -519, -8474, 16008, 2622, -2433, 2826, 8064}},",
          "14040:       {\"Nikon D5100\", 0, 0x3de6, {8198, -2239, -724, -4871, 12389, 2798, -1043, 2050, 7181}},",
          "14041:       {\"Nikon D5200\", 0, 0, {8322, -3112, -1047, -6367, 14342, 2179, -988, 1638, 6394}},",
          "14042:       {\"Nikon D5300\", 0, 0, {6988, -1384, -714, -5631, 13410, 2447, -1485, 2204, 7318}},",
          "14043:       {\"Nikon D5500\", 0, 0, {8821, -2938, -785, -4178, 12142, 2287, -824, 1651, 6860}},",
          "14044:       {\"Nikon D500\", 0, 0, {8813, -3210, -1036, -4703, 12868, 2021, -1054, 1940, 6129}},",
          "14045:       {\"Nikon D50\", 0, 0, {7732, -2422, -789, -8238, 15884, 2498, -859, 783, 7330}},",
          "14046:       {\"Nikon D5\", 0, 0, {9200, -3522, -992, -5755, 13803, 2117, -753, 1486, 6338}},",
          "14047:       {\"Nikon D600\", 0, 0x3e07, {8178, -2245, -609, -4857, 12394, 2776, -1207, 2086, 7298}},",
          "14048:       {\"Nikon D610\", 0, 0, {10426, -4005, -444, -3565, 11764, 1403, -1206, 2266, 6549}},",
          "14049:       {\"Nikon D60\", 0, 0, {8736, -2458, -935, -9075, 16894, 2251, -1354, 1242, 8263}},",
          "14050:       {\"Nikon D7000\", 0, 0, {8198, -2239, -724, -4871, 12389, 2798, -1043, 2050, 7181}},",
          "14051:       {\"Nikon D7100\", 0, 0, {8322, -3112, -1047, -6367, 14342, 2179, -988, 1638, 6394}},",
          "14052:       {\"Nikon D7200\", 0, 0, {8322, -3112, -1047, -6367, 14342, 2179, -988, 1638, 6394}},",
          "14053:       {\"Nikon D750\", -600, 0, {9020, -2890, -715, -4535, 12436, 2348, -934, 1919, 7086}},",
          "14054:       {\"Nikon D700\", 0, 0, {8139, -2171, -663, -8747, 16541, 2295, -1925, 2008, 8093}},",
          "14055:       {\"Nikon D70\", 0, 0, {7732, -2422, -789, -8238, 15884, 2498, -859, 783, 7330}},",
          "14056:       {\"Nikon D810A\", 0, 0, {11973, -5685, -888, -1965, 10326, 1901, -115, 1123, 7169}},",
          "14057:       {\"Nikon D810\", 0, 0, {9369, -3195, -791, -4488, 12430, 2301, -893, 1796, 6872}},",
          "14058:       {\"Nikon D800\", 0, 0, {7866, -2108, -555, -4869, 12483, 2681, -1176, 2069, 7501}},",
          "14059:       {\"Nikon D80\", 0, 0, {8629, -2410, -883, -9055, 16940, 2171, -1490, 1363, 8520}},",
          "14060:       {\"Nikon D90\", 0, 0xf00, {7309, -1403, -519, -8474, 16008, 2622, -2434, 2826, 8064}},",
          "14061:       {\"Nikon E700\",",
          "14062:        0,",
          "14064:        {-3746, 10611, 1665, 9621, -1734, 2114, -2389, 7082, 3064, 3406, 6116, -244}},",
          "14065:       {\"Nikon E800\",",
          "14066:        0,",
          "14068:        {-3746, 10611, 1665, 9621, -1734, 2114, -2389, 7082, 3064, 3406, 6116, -244}},",
          "14069:       {\"Nikon E950\",",
          "14070:        0,",
          "14072:        {-3746, 10611, 1665, 9621, -1734, 2114, -2389, 7082, 3064, 3406, 6116, -244}},",
          "14073:       {\"Nikon E995\",",
          "14074:        0,",
          "14076:        {-5547, 11762, 2189, 5814, -558, 3342, -4924, 9840, 5949, 688, 9083, 96}},",
          "14077:       {\"Nikon E2100\",",
          "14078:        0,",
          "14080:        {13142, -4152, -1596, -4655, 12374, 2282, -1769, 2696, 6711}},",
          "14081:       {\"Nikon E2500\", 0, 0, {-5547, 11762, 2189, 5814, -558, 3342, -4924, 9840, 5949, 688, 9083, 96}},",
          "14082:       {\"Nikon E3200\",",
          "14083:        0,",
          "14085:        {9846, -2085, -1019, -3278, 11109, 2170, -774, 2134, 5745}},",
          "14086:       {\"Nikon E4300\",",
          "14087:        0,",
          "14089:        {11280, -3564, -1370, -4655, 12374, 2282, -1423, 2168, 5396}},",
          "14090:       {\"Nikon E4500\", 0, 0, {-5547, 11762, 2189, 5814, -558, 3342, -4924, 9840, 5949, 688, 9083, 96}},",
          "14091:       {\"Nikon E5000\", 0, 0, {-5547, 11762, 2189, 5814, -558, 3342, -4924, 9840, 5949, 688, 9083, 96}},",
          "14092:       {\"Nikon E5400\", 0, 0, {9349, -2987, -1001, -7919, 15766, 2266, -2098, 2680, 6839}},",
          "14093:       {\"Nikon E5700\", 0, 0, {-5368, 11478, 2368, 5537, -113, 3148, -4969, 10021, 5782, 778, 9028, 211}},",
          "14094:       {\"Nikon E8400\", 0, 0, {7842, -2320, -992, -8154, 15718, 2599, -1098, 1342, 7560}},",
          "14095:       {\"Nikon E8700\", 0, 0, {8489, -2583, -1036, -8051, 15583, 2643, -1307, 1407, 7354}},",
          "14096:       {\"Nikon E8800\", 0, 0, {7971, -2314, -913, -8451, 15762, 2894, -1442, 1520, 7610}},",
          "14097:       {\"Nikon COOLPIX A\", 0, 0, {8198, -2239, -724, -4871, 12389, 2798, -1043, 2050, 7181}},",
          "14098:       {\"Nikon COOLPIX B700\", 0, 0, {14387, -6014, -1299, -1357, 9975, 1616, 467, 1047, 4744}},",
          "14099:       {\"Nikon COOLPIX P330\", -200, 0, {10321, -3920, -931, -2750, 11146, 1824, -442, 1545, 5539}},",
          "14100:       {\"Nikon COOLPIX P340\", -200, 0, {10321, -3920, -931, -2750, 11146, 1824, -442, 1545, 5539}},",
          "14101:       {\"Nikon COOLPIX P6000\", 0, 0, {9698, -3367, -914, -4706, 12584, 2368, -837, 968, 5801}},",
          "14102:       {\"Nikon COOLPIX P7000\", 0, 0, {11432, -3679, -1111, -3169, 11239, 2202, -791, 1380, 4455}},",
          "14103:       {\"Nikon COOLPIX P7100\", 0, 0, {11053, -4269, -1024, -1976, 10182, 2088, -526, 1263, 4469}},",
          "14104:       {\"Nikon COOLPIX P7700\", -3200, 0, {10321, -3920, -931, -2750, 11146, 1824, -442, 1545, 5539}},",
          "14105:       {\"Nikon COOLPIX P7800\", -3200, 0, {10321, -3920, -931, -2750, 11146, 1824, -442, 1545, 5539}},",
          "14106:       {\"Nikon 1 V3\", -200, 0, {5958, -1559, -571, -4021, 11453, 2939, -634, 1548, 5087}},",
          "14107:       {\"Nikon 1 J4\", 0, 0, {5958, -1559, -571, -4021, 11453, 2939, -634, 1548, 5087}},",
          "14108:       {\"Nikon 1 J5\", 0, 0, {7520, -2518, -645, -3844, 12102, 1945, -913, 2249, 6835}},",
          "14109:       {\"Nikon 1 S2\", -200, 0, {6612, -1342, -618, -3338, 11055, 2623, -174, 1792, 5075}},",
          "14110:       {\"Nikon 1 V2\", 0, 0, {6588, -1305, -693, -3277, 10987, 2634, -355, 2016, 5106}},",
          "14111:       {\"Nikon 1 J3\", 0, 0, {8144, -2671, -473, -1740, 9834, 1601, -58, 1971, 4296}},",
          "14112:       {\"Nikon 1 AW1\", 0, 0, {6588, -1305, -693, -3277, 10987, 2634, -355, 2016, 5106}},",
          "14113:       {\"Nikon 1 \",",
          "14114:        0,",
          "14116:        {8994, -2667, -865, -4594, 12324, 2552, -699, 1786, 6260}},",
          "14117:       {\"Olympus AIR-A01\", 0, 0xfe1, {8992, -3093, -639, -2563, 10721, 2122, -437, 1270, 5473}},",
          "14118:       {\"Olympus C5050\", 0, 0, {10508, -3124, -1273, -6079, 14294, 1901, -1653, 2306, 6237}},",
          "14119:       {\"Olympus C5060\", 0, 0, {10445, -3362, -1307, -7662, 15690, 2058, -1135, 1176, 7602}},",
          "14120:       {\"Olympus C7070\", 0, 0, {10252, -3531, -1095, -7114, 14850, 2436, -1451, 1723, 6365}},",
          "14121:       {\"Olympus C70\", 0, 0, {10793, -3791, -1146, -7498, 15177, 2488, -1390, 1577, 7321}},",
          "14122:       {\"Olympus C80\", 0, 0, {8606, -2509, -1014, -8238, 15714, 2703, -942, 979, 7760}},",
          "14123:       {\"Olympus E-10\", 0, 0xffc, {12745, -4500, -1416, -6062, 14542, 1580, -1934, 2256, 6603}},",
          "14124:       {\"Olympus E-1\", 0, 0, {11846, -4767, -945, -7027, 15878, 1089, -2699, 4122, 8311}},",
          "14125:       {\"Olympus E-20\", 0, 0xffc, {13173, -4732, -1499, -5807, 14036, 1895, -2045, 2452, 7142}},",
          "14126:       {\"Olympus E-300\", 0, 0, {7828, -1761, -348, -5788, 14071, 1830, -2853, 4518, 6557}},",
          "14127:       {\"Olympus E-330\", 0, 0, {8961, -2473, -1084, -7979, 15990, 2067, -2319, 3035, 8249}},",
          "14128:       {\"Olympus E-30\", 0, 0xfbc, {8144, -1861, -1111, -7763, 15894, 1929, -1865, 2542, 7607}},",
          "14129:       {\"Olympus E-3\", 0, 0xf99, {9487, -2875, -1115, -7533, 15606, 2010, -1618, 2100, 7389}},",
          "14130:       {\"Olympus E-400\", 0, 0, {6169, -1483, -21, -7107, 14761, 2536, -2904, 3580, 8568}},",
          "14131:       {\"Olympus E-410\", 0, 0xf6a, {8856, -2582, -1026, -7761, 15766, 2082, -2009, 2575, 7469}},",
          "14132:       {\"Olympus E-420\", 0, 0xfd7, {8746, -2425, -1095, -7594, 15612, 2073, -1780, 2309, 7416}},",
          "14133:       {\"Olympus E-450\", 0, 0xfd2, {8745, -2425, -1095, -7594, 15613, 2073, -1780, 2309, 7416}},",
          "14134:       {\"Olympus E-500\", 0, 0, {8136, -1968, -299, -5481, 13742, 1871, -2556, 4205, 6630}},",
          "14135:       {\"Olympus E-510\", 0, 0xf6a, {8785, -2529, -1033, -7639, 15624, 2112, -1783, 2300, 7817}},",
          "14136:       {\"Olympus E-520\", 0, 0xfd2, {8344, -2322, -1020, -7596, 15635, 2048, -1748, 2269, 7287}},",
          "14137:       {\"Olympus E-5\", 0, 0xeec, {11200, -3783, -1325, -4576, 12593, 2206, -695, 1742, 7504}},",
          "14138:       {\"Olympus E-600\", 0, 0xfaf, {8453, -2198, -1092, -7609, 15681, 2008, -1725, 2337, 7824}},",
          "14139:       {\"Olympus E-620\", 0, 0xfaf, {8453, -2198, -1092, -7609, 15681, 2008, -1725, 2337, 7824}},",
          "14140:       {\"Olympus E-P1\", 0, 0xffd, {8343, -2050, -1021, -7715, 15705, 2103, -1831, 2380, 8235}},",
          "14141:       {\"Olympus E-P2\", 0, 0xffd, {8343, -2050, -1021, -7715, 15705, 2103, -1831, 2380, 8235}},",
          "14142:       {\"Olympus E-P3\", 0, 0, {7575, -2159, -571, -3722, 11341, 2725, -1434, 2819, 6271}},",
          "14143:       {\"Olympus E-P5\", 0, 0, {8380, -2630, -639, -2887, 10725, 2496, -627, 1427, 5438}},",
          "14144:       {\"Olympus E-PL1s\", 0, 0, {11409, -3872, -1393, -4572, 12757, 2003, -709, 1810, 7415}},",
          "14145:       {\"Olympus E-PL1\", 0, 0, {11408, -4289, -1215, -4286, 12385, 2118, -387, 1467, 7787}},",
          "14146:       {\"Olympus E-PL2\", 0, 0xcf3, {15030, -5552, -1806, -3987, 12387, 1767, -592, 1670, 7023}},",
          "14147:       {\"Olympus E-PL3\", 0, 0, {7575, -2159, -571, -3722, 11341, 2725, -1434, 2819, 6271}},",
          "14148:       {\"Olympus E-PL5\", 0, 0xfcb, {8380, -2630, -639, -2887, 10725, 2496, -627, 1427, 5438}},",
          "14149:       {\"Olympus E-PL6\", 0, 0, {8380, -2630, -639, -2887, 10725, 2496, -627, 1427, 5438}},",
          "14150:       {\"Olympus E-PL7\", 0, 0, {9197, -3190, -659, -2606, 10830, 2039, -458, 1250, 5458}},",
          "14151:       {\"Olympus E-PL8\", 0, 0, {9197, -3190, -659, -2606, 10830, 2039, -458, 1250, 5458}},",
          "14152:       {\"Olympus E-PM1\", 0, 0, {7575, -2159, -571, -3722, 11341, 2725, -1434, 2819, 6271}},",
          "14153:       {\"Olympus E-PM2\", 0, 0, {8380, -2630, -639, -2887, 10725, 2496, -627, 1427, 5438}},",
          "14154:       {\"Olympus E-M10\",",
          "14155:        0,",
          "14157:        {8380, -2630, -639, -2887, 10725, 2496, -627, 1427, 5438}},",
          "14158:       {\"Olympus E-M1MarkII\",",
          "14159:        0,",
          "14161:        {8380, -2630, -639, -2887, 10725, 2496, -627, 1427, 5438}},",
          "14162:       {\"Olympus E-M1\", 0, 0, {7687, -1984, -606, -4327, 11928, 2721, -1381, 2339, 6452}},",
          "14163:       {\"Olympus E-M5MarkII\", 0, 0, {9422, -3258, -711, -2655, 10898, 2015, -512, 1354, 5512}},",
          "14164:       {\"Olympus E-M5\", 0, 0xfe1, {8380, -2630, -639, -2887, 10725, 2496, -627, 1427, 5438}},",
          "14165:       {\"Olympus PEN-F\", 0, 0, {9476, -3182, -765, -2613, 10958, 1893, -449, 1315, 5268}},",
          "14166:       {\"Olympus SP350\", 0, 0, {12078, -4836, -1069, -6671, 14306, 2578, -786, 939, 7418}},",
          "14167:       {\"Olympus SP3\", 0, 0, {11766, -4445, -1067, -6901, 14421, 2707, -1029, 1217, 7572}},",
          "14168:       {\"Olympus SP500UZ\", 0, 0xfff, {9493, -3415, -666, -5211, 12334, 3260, -1548, 2262, 6482}},",
          "14169:       {\"Olympus SP510UZ\", 0, 0xffe, {10593, -3607, -1010, -5881, 13127, 3084, -1200, 1805, 6721}},",
          "14170:       {\"Olympus SP550UZ\", 0, 0xffe, {11597, -4006, -1049, -5432, 12799, 2957, -1029, 1750, 6516}},",
          "14171:       {\"Olympus SP560UZ\", 0, 0xff9, {10915, -3677, -982, -5587, 12986, 2911, -1168, 1968, 6223}},",
          "14172:       {\"Olympus SP570UZ\", 0, 0, {11522, -4044, -1146, -4736, 12172, 2904, -988, 1829, 6039}},",
          "14173:       {\"Olympus SH-2\", 0, 0, {10156, -3425, -1077, -2611, 11177, 1624, -385, 1592, 5080}},",
          "14174:       {\"Olympus SH-3\",",
          "14175:        0,",
          "14177:        {10156, -3425, -1077, -2611, 11177, 1624, -385, 1592, 5080}},",
          "14178:       {\"Olympus STYLUS1\", 0, 0, {11976, -5518, -545, -1419, 10472, 846, -475, 1766, 4524}},",
          "14179:       {\"Olympus TG-4\", 0, 0, {11426, -4159, -1126, -2066, 10678, 1593, -120, 1327, 4998}},",
          "14180:       {\"Olympus XZ-10\", 0, 0, {9777, -3483, -925, -2886, 11297, 1800, -602, 1663, 5134}},",
          "14181:       {\"Olympus XZ-1\", 0, 0, {10901, -4095, -1074, -1141, 9208, 2293, -62, 1417, 5158}},",
          "14182:       {\"Olympus XZ-2\", 0, 0, {9777, -3483, -925, -2886, 11297, 1800, -602, 1663, 5134}},",
          "14184:       {\"Pentax *ist DL2\", 0, 0, {10504, -2438, -1189, -8603, 16207, 2531, -1022, 863, 12242}},",
          "14185:       {\"Pentax *ist DL\", 0, 0, {10829, -2838, -1115, -8339, 15817, 2696, -837, 680, 11939}},",
          "14186:       {\"Pentax *ist DS2\", 0, 0, {10504, -2438, -1189, -8603, 16207, 2531, -1022, 863, 12242}},",
          "14187:       {\"Pentax *ist DS\", 0, 0, {10371, -2333, -1206, -8688, 16231, 2602, -1230, 1116, 11282}},",
          "14188:       {\"Pentax *ist D\", 0, 0, {9651, -2059, -1189, -8881, 16512, 2487, -1460, 1345, 10687}},",
          "14189:       {\"Pentax K10D\", 0, 0, {9566, -2863, -803, -7170, 15172, 2112, -818, 803, 9705}},",
          "14190:       {\"Pentax K1\", 0, 0, {11095, -3157, -1324, -8377, 15834, 2720, -1108, 947, 11688}},",
          "14191:       {\"Pentax K20D\", 0, 0, {9427, -2714, -868, -7493, 16092, 1373, -2199, 3264, 7180}},",
          "14192:       {\"Pentax K200D\", 0, 0, {9186, -2678, -907, -8693, 16517, 2260, -1129, 1094, 8524}},",
          "14193:       {\"Pentax K2000\", 0, 0, {11057, -3604, -1155, -5152, 13046, 2329, -282, 375, 8104}},",
          "14194:       {\"Pentax K-m\", 0, 0, {11057, -3604, -1155, -5152, 13046, 2329, -282, 375, 8104}},",
          "14195:       {\"Pentax K-x\", 0, 0, {8843, -2837, -625, -5025, 12644, 2668, -411, 1234, 7410}},",
          "14196:       {\"Pentax K-r\", 0, 0, {9895, -3077, -850, -5304, 13035, 2521, -883, 1768, 6936}},",
          "14197:       {\"Pentax K-1\", 0, 0, {8566, -2746, -1201, -3612, 12204, 1550, -893, 1680, 6264}},",
          "14198:       {\"Pentax K-30\", 0, 0, {8710, -2632, -1167, -3995, 12301, 1881, -981, 1719, 6535}},",
          "14199:       {\"Pentax K-3 II\", 0, 0, {8626, -2607, -1155, -3995, 12301, 1881, -1039, 1822, 6925}},",
          "14200:       {\"Pentax K-3\", 0, 0, {7415, -2052, -721, -5186, 12788, 2682, -1446, 2157, 6773}},",
          "14201:       {\"Pentax K-5 II\", 0, 0, {8170, -2725, -639, -4440, 12017, 2744, -771, 1465, 6599}},",
          "14202:       {\"Pentax K-5\", 0, 0, {8713, -2833, -743, -4342, 11900, 2772, -722, 1543, 6247}},",
          "14203:       {\"Pentax K-70\", 0, 0, {8766, -3149, -747, -3976, 11943, 2292, -517, 1259, 5552}},",
          "14204:       {\"Pentax K-7\", 0, 0, {9142, -2947, -678, -8648, 16967, 1663, -2224, 2898, 8615}},",
          "14205:       {\"Pentax K-S1\", 0, 0, {8512, -3211, -787, -4167, 11966, 2487, -638, 1288, 6054}},",
          "14206:       {\"Pentax K-S2\", 0, 0, {8662, -3280, -798, -3928, 11771, 2444, -586, 1232, 6054}},",
          "14207:       {\"Pentax Q-S1\", 0, 0, {12995, -5593, -1107, -1879, 10139, 2027, -64, 1233, 4919}},",
          "14208:       {\"Pentax MX-1\", 0, 0, {8804, -2523, -1238, -2423, 11627, 860, -682, 1774, 4753}},",
          "14209:       {\"Pentax Q10\", 0, 0, {12995, -5593, -1107, -1879, 10139, 2027, -64, 1233, 4919}},",
          "14210:       {\"Pentax 645D\", 0, 0x3e00, {10646, -3593, -1158, -3329, 11699, 1831, -667, 2874, 6287}},",
          "14211:       {\"Pentax 645Z\",",
          "14212:        0,",
          "14214:        {9702, -3060, -1254, -3685, 12133, 1721, -1086, 2010, 6971}},",
          "14215:       {\"Panasonic DMC-CM10\", -15, 0, {8770, -3194, -820, -2871, 11281, 1803, -513, 1552, 4434}},",
          "14216:       {\"Panasonic DMC-CM1\", -15, 0, {8770, -3194, -820, -2871, 11281, 1803, -513, 1552, 4434}},",
          "14217:       {\"Panasonic DMC-FZ8\", 0, 0xf7f, {8986, -2755, -802, -6341, 13575, 3077, -1476, 2144, 6379}},",
          "14218:       {\"Panasonic DMC-FZ18\", 0, 0, {9932, -3060, -935, -5809, 13331, 2753, -1267, 2155, 5575}},",
          "14219:       {\"Panasonic DMC-FZ28\", -15, 0xf96, {10109, -3488, -993, -5412, 12812, 2916, -1305, 2140, 5543}},",
          "14220:       {\"Panasonic DMC-FZ300\", -15, 0xfff, {8378, -2798, -769, -3068, 11410, 1877, -538, 1792, 4623}},",
          "14221:       {\"Panasonic DMC-FZ330\",",
          "14222:        -15,",
          "14223:        0xfff, // same as FZ300",
          "14224:        {8378, -2798, -769, -3068, 11410, 1877, -538, 1792, 4623}},",
          "14225:       {\"Panasonic DMC-FZ30\", 0, 0xf94, {10976, -4029, -1141, -7918, 15491, 2600, -1670, 2071, 8246}},",
          "14226:       {\"Panasonic DMC-FZ3\", -15, 0, {9938, -2780, -890, -4604, 12393, 2480, -1117, 2304, 4620}},",
          "14227:       {\"Panasonic DMC-FZ4\", -15, 0, {13639, -5535, -1371, -1698, 9633, 2430, 316, 1152, 4108}},",
          "14228:       {\"Panasonic DMC-FZ50\", 0, 0, {7906, -2709, -594, -6231, 13351, 3220, -1922, 2631, 6537}},",
          "14229:       {\"Panasonic DMC-FZ7\", -15, 0, {11532, -4324, -1066, -2375, 10847, 1749, -564, 1699, 4351}},",
          "14230:       {\"Leica V-LUX1\", 0, 0, {7906, -2709, -594, -6231, 13351, 3220, -1922, 2631, 6537}},",
          "14231:       {\"Panasonic DMC-L10\", -15, 0xf96, {8025, -1942, -1050, -7920, 15904, 2100, -2456, 3005, 7039}},",
          "14232:       {\"Panasonic DMC-L1\", 0, 0xf7f, {8054, -1885, -1025, -8349, 16367, 2040, -2805, 3542, 7629}},",
          "14233:       {\"Leica DIGILUX 3\", 0, 0xf7f, {8054, -1885, -1025, -8349, 16367, 2040, -2805, 3542, 7629}},",
          "14234:       {\"Panasonic DMC-LC1\", 0, 0, {11340, -4069, -1275, -7555, 15266, 2448, -2960, 3426, 7685}},",
          "14235:       {\"Leica DIGILUX 2\", 0, 0, {11340, -4069, -1275, -7555, 15266, 2448, -2960, 3426, 7685}},",
          "14236:       {\"Panasonic DMC-LX100\", -15, 0, {8844, -3538, -768, -3709, 11762, 2200, -698, 1792, 5220}},",
          "14237:       {\"Leica D-LUX (Typ 109)\", -15, 0, {8844, -3538, -768, -3709, 11762, 2200, -698, 1792, 5220}},",
          "14238:       {\"Panasonic DMC-LF1\", -15, 0, {9379, -3267, -816, -3227, 11560, 1881, -926, 1928, 5340}},",
          "14239:       {\"Leica C (Typ 112)\", -15, 0, {9379, -3267, -816, -3227, 11560, 1881, -926, 1928, 5340}},",
          "14241:       {\"Panasonic DMC-LX9\",",
          "14242:        -15,",
          "14245:       {\"Panasonic DMC-LX10\",",
          "14246:        -15,",
          "14249:       {\"Panasonic DMC-LX15\",",
          "14250:        -15,",
          "14254:       {\"Panasonic DMC-LX1\", 0, 0xf7f, {10704, -4187, -1230, -8314, 15952, 2501, -920, 945, 8927}},",
          "14255:       {\"Leica D-Lux (Typ 109)\", 0, 0xf7f, {8844, -3538, -768, -3709, 11762, 2200, -698, 1792, 5220}},",
          "14256:       {\"Leica D-LUX2\", 0, 0xf7f, {10704, -4187, -1230, -8314, 15952, 2501, -920, 945, 8927}},",
          "14257:       {\"Panasonic DMC-LX2\", 0, 0, {8048, -2810, -623, -6450, 13519, 3272, -1700, 2146, 7049}},",
          "14258:       {\"Leica D-LUX3\", 0, 0, {8048, -2810, -623, -6450, 13519, 3272, -1700, 2146, 7049}},",
          "14259:       {\"Panasonic DMC-LX3\", -15, 0, {8128, -2668, -655, -6134, 13307, 3161, -1782, 2568, 6083}},",
          "14260:       {\"Leica D-LUX 4\", -15, 0, {8128, -2668, -655, -6134, 13307, 3161, -1782, 2568, 6083}},",
          "14261:       {\"Panasonic DMC-LX5\", -15, 0, {10909, -4295, -948, -1333, 9306, 2399, 22, 1738, 4582}},",
          "14262:       {\"Leica D-LUX 5\", -15, 0, {10909, -4295, -948, -1333, 9306, 2399, 22, 1738, 4582}},",
          "14263:       {\"Panasonic DMC-LX7\", -15, 0, {10148, -3743, -991, -2837, 11366, 1659, -701, 1893, 4899}},",
          "14264:       {\"Leica D-LUX 6\", -15, 0, {10148, -3743, -991, -2837, 11366, 1659, -701, 1893, 4899}},",
          "14265:       {\"Panasonic DMC-FZ1000\", -15, 0, {7830, -2696, -763, -3325, 11667, 1866, -641, 1712, 4824}},",
          "14266:       {\"Leica V-LUX (Typ 114)\", 15, 0, {7830, -2696, -763, -3325, 11667, 1866, -641, 1712, 4824}},",
          "14267:       {\"Panasonic DMC-FZ100\", -15, 0xfff, {16197, -6146, -1761, -2393, 10765, 1869, 366, 2238, 5248}},",
          "14268:       {\"Leica V-LUX 2\", -15, 0xfff, {16197, -6146, -1761, -2393, 10765, 1869, 366, 2238, 5248}},",
          "14269:       {\"Panasonic DMC-FZ150\", -15, 0xfff, {11904, -4541, -1189, -2355, 10899, 1662, -296, 1586, 4289}},",
          "14270:       {\"Leica V-LUX 3\", -15, 0xfff, {11904, -4541, -1189, -2355, 10899, 1662, -296, 1586, 4289}},",
          "14271:       {\"Panasonic DMC-FZ2000\",",
          "14272:        -15,",
          "14274:        {7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766}},",
          "14275:       {\"Panasonic DMC-FZ2500\", -15, 0, {7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766}},",
          "14276:       {\"Panasonic DMC-FZH1\", -15, 0, {7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766}},",
          "14277:       {\"Panasonic DMC-FZ200\", -15, 0xfff, {8112, -2563, -740, -3730, 11784, 2197, -941, 2075, 4933}},",
          "14278:       {\"Leica V-LUX 4\", -15, 0xfff, {8112, -2563, -740, -3730, 11784, 2197, -941, 2075, 4933}},",
          "14279:       {\"Panasonic DMC-FX150\", -15, 0xfff, {9082, -2907, -925, -6119, 13377, 3058, -1797, 2641, 5609}},",
          "14280:       {\"Panasonic DMC-G10\", 0, 0, {10113, -3400, -1114, -4765, 12683, 2317, -377, 1437, 6710}},",
          "14281:       {\"Panasonic DMC-G1\", -15, 0xf94, {8199, -2065, -1056, -8124, 16156, 2033, -2458, 3022, 7220}},",
          "14282:       {\"Panasonic DMC-G2\", -15, 0xf3c, {10113, -3400, -1114, -4765, 12683, 2317, -377, 1437, 6710}},",
          "14283:       {\"Panasonic DMC-G3\", -15, 0xfff, {6763, -1919, -863, -3868, 11515, 2684, -1216, 2387, 5879}},",
          "14284:       {\"Panasonic DMC-G5\", -15, 0xfff, {7798, -2562, -740, -3879, 11584, 2613, -1055, 2248, 5434}},",
          "14285:       {\"Panasonic DMC-G6\", -15, 0xfff, {8294, -2891, -651, -3869, 11590, 2595, -1183, 2267, 5352}},",
          "14286:       {\"Panasonic DMC-G7\", -15, 0xfff, {7610, -2780, -576, -4614, 12195, 2733, -1375, 2393, 6490}},",
          "14287:       {\"Panasonic DMC-G8\",",
          "14288:        -15,",
          "14290:        {7610, -2780, -576, -4614, 12195, 2733, -1375, 2393, 6490}},",
          "14291:       {\"Panasonic DMC-GF1\", -15, 0xf92, {7888, -1902, -1011, -8106, 16085, 2099, -2353, 2866, 7330}},",
          "14292:       {\"Panasonic DMC-GF2\", -15, 0xfff, {7888, -1902, -1011, -8106, 16085, 2099, -2353, 2866, 7330}},",
          "14293:       {\"Panasonic DMC-GF3\", -15, 0xfff, {9051, -2468, -1204, -5212, 13276, 2121, -1197, 2510, 6890}},",
          "14294:       {\"Panasonic DMC-GF5\", -15, 0xfff, {8228, -2945, -660, -3938, 11792, 2430, -1094, 2278, 5793}},",
          "14295:       {\"Panasonic DMC-GF6\", -15, 0, {8130, -2801, -946, -3520, 11289, 2552, -1314, 2511, 5791}},",
          "14296:       {\"Panasonic DMC-GF7\", -15, 0, {7610, -2780, -576, -4614, 12195, 2733, -1375, 2393, 6490}},",
          "14297:       {\"Panasonic DMC-GF8\", -15, 0, {7610, -2780, -576, -4614, 12195, 2733, -1375, 2393, 6490}},",
          "14298:       {\"Panasonic DMC-GH1\", -15, 0xf92, {6299, -1466, -532, -6535, 13852, 2969, -2331, 3112, 5984}},",
          "14299:       {\"Panasonic DMC-GH2\", -15, 0xf95, {7780, -2410, -806, -3913, 11724, 2484, -1018, 2390, 5298}},",
          "14300:       {\"Panasonic DMC-GH3\", -15, 0, {6559, -1752, -491, -3672, 11407, 2586, -962, 1875, 5130}},",
          "14301:       {\"Panasonic DMC-GH4\", -15, 0, {7122, -2108, -512, -3155, 11201, 2231, -541, 1423, 5045}},",
          "14302:       {\"Yuneec CGO4\", -15, 0, {7122, -2108, -512, -3155, 11201, 2231, -541, 1423, 5045}},",
          "14303:       {\"Panasonic DMC-GM1\", -15, 0, {6770, -1895, -744, -5232, 13145, 2303, -1664, 2691, 5703}},",
          "14304:       {\"Panasonic DMC-GM5\", -15, 0, {8238, -3244, -679, -3921, 11814, 2384, -836, 2022, 5852}},",
          "14305:       {\"Panasonic DMC-GX1\", -15, 0, {6763, -1919, -863, -3868, 11515, 2684, -1216, 2387, 5879}},",
          "14306:       {\"Panasonic DMC-GX85\",",
          "14307:        -15,",
          "14309:        {7771, -3020, -629, 4029, 11950, 2345, -821, 1977, 6119}},",
          "14310:       {\"Panasonic DMC-GX80\",",
          "14311:        -15,",
          "14313:        {7771, -3020, -629, 4029, 11950, 2345, -821, 1977, 6119}},",
          "14314:       {\"Panasonic DMC-GX7MK2\",",
          "14315:        -15,",
          "14317:        {7771, -3020, -629, 4029, 11950, 2345, -821, 1977, 6119}},",
          "14318:       {\"Panasonic DMC-GX7\", -15, 0, {7610, -2780, -576, -4614, 12195, 2733, -1375, 2393, 6490}},",
          "14319:       {\"Panasonic DMC-GX8\", -15, 0, {7564, -2263, -606, -3148, 11239, 2177, -540, 1435, 4853}},",
          "14320:       {\"Panasonic DMC-TZ6\",",
          "14321:        -15,",
          "14323:        {8607, -2822, -808, -3755, 11930, 2049, -820, 2060, 5224}},",
          "14324:       {\"Panasonic DMC-TZ8\",",
          "14325:        -15,",
          "14327:        {8550, -2908, -842, -3195, 11529, 1881, -338, 1603, 4631}},",
          "14328:       {\"Panasonic DMC-ZS4\",",
          "14329:        -15,",
          "14331:        {8607, -2822, -808, -3755, 11930, 2049, -820, 2060, 5224}},",
          "14332:       {\"Panasonic DMC-TZ7\",",
          "14333:        -15,",
          "14335:        {8802, -3135, -789, -3151, 11468, 1904, -550, 1745, 4810}},",
          "14336:       {\"Panasonic DMC-ZS5\",",
          "14337:        -15,",
          "14339:        {8802, -3135, -789, -3151, 11468, 1904, -550, 1745, 4810}},",
          "14340:       {\"Panasonic DMC-ZS6\",",
          "14341:        -15,",
          "14343:        {8550, -2908, -842, -3195, 11529, 1881, -338, 1603, 4631}},",
          "14344:       {\"Panasonic DMC-ZS100\",",
          "14345:        -15,",
          "14347:        {7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898}},",
          "14348:       {\"Panasonic DMC-ZS110\",",
          "14349:        -15,",
          "14351:        {7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898}},",
          "14352:       {\"Panasonic DMC-TZ100\",",
          "14353:        -15,",
          "14355:        {7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898}},",
          "14356:       {\"Panasonic DMC-TZ101\",",
          "14357:        -15,",
          "14359:        {7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898}},",
          "14360:       {\"Panasonic DMC-TZ110\",",
          "14361:        -15,",
          "14363:        {7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898}},",
          "14364:       {\"Panasonic DMC-TX1\",",
          "14365:        -15,",
          "14367:        {7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898}},",
          "14368:       {\"Leica S (Typ 007)\", 0, 0, {6063, -2234, -231, -5210, 13787, 1500, -1043, 2866, 6997}},",
          "14369:       {\"Leica X\",",
          "14370:        0,",
          "14372:        {7712, -2059, -653, -3882, 11494, 2726, -710, 1332, 5958}},",
          "14373:       {\"Leica Q (Typ 116)\", 0, 0, {11865, -4523, -1441, -5423, 14458, 935, -1587, 2687, 4830}},",
          "14374:       {\"Leica M (Typ 262)\", 0, 0, {6653, -1486, -611, -4221, 13303, 929, -881, 2416, 7226}},",
          "14375:       {\"Leica SL (Typ 601)\", 0, 0, {11865, -4523, -1441, -5423, 14458, 935, -1587, 2687, 4830}},",
          "14376:       {\"Phase One H 20\",",
          "14377:        0,",
          "14379:        {1313, 1855, -109, -6715, 15908, 808, -327, 1840, 6020}},",
          "14380:       {\"Phase One H 25\", 0, 0, {2905, 732, -237, -8134, 16626, 1476, -3038, 4253, 7517}},",
          "14381:       {\"Phase One IQ250\", 0, 0, {4396, -153, -249, -5267, 12249, 2657, -1397, 2323, 6014}},",
          "14382:       {\"Phase One P 2\", 0, 0, {2905, 732, -237, -8134, 16626, 1476, -3038, 4253, 7517}},",
          "14383:       {\"Phase One P 30\", 0, 0, {4516, -245, -37, -7020, 14976, 2173, -3206, 4671, 7087}},",
          "14384:       {\"Phase One P 45\", 0, 0, {5053, -24, -117, -5684, 14076, 1702, -2619, 4492, 5849}},",
          "14385:       {\"Phase One P40\", 0, 0, {8035, 435, -962, -6001, 13872, 2320, -1159, 3065, 5434}},",
          "14386:       {\"Phase One P65\", 0, 0, {8035, 435, -962, -6001, 13872, 2320, -1159, 3065, 5434}},",
          "14387:       {\"Photron BC2-HD\",",
          "14388:        0,",
          "14390:        {14603, -4122, -528, -1810, 9794, 2017, -297, 2763, 5936}},",
          "14391:       {\"Red One\",",
          "14392:        704,",
          "14394:        {21014, -7891, -2613, -3056, 12201, 856, -2203, 5125, 8042}},",
          "14395:       {\"Ricoh GR II\", 0, 0, {4630, -834, -423, -4977, 12805, 2417, -638, 1467, 6115}},",
          "14396:       {\"Ricoh GR\", 0, 0, {3708, -543, -160, -5381, 12254, 3556, -1471, 1929, 8234}},",
          "14397:       {\"Samsung EK-GN120\",",
          "14398:        0,",
          "14400:        {7557, -2522, -739, -4679, 12949, 1894, -840, 1777, 5311}},",
          "14401:       {\"Samsung EX1\", 0, 0x3e00, {8898, -2498, -994, -3144, 11328, 2066, -760, 1381, 4576}},",
          "14402:       {\"Samsung EX2F\", 0, 0x7ff, {10648, -3897, -1055, -2022, 10573, 1668, -492, 1611, 4742}},",
          "14403:       {\"Samsung NX mini\", 0, 0, {5222, -1196, -550, -6540, 14649, 2009, -1666, 2819, 5657}},",
          "14404:       {\"Samsung NX3300\",",
          "14405:        0,",
          "14407:        {8060, -2933, -761, -4504, 12890, 1762, -630, 1489, 5227}},",
          "14408:       {\"Samsung NX3000\", 0, 0, {8060, -2933, -761, -4504, 12890, 1762, -630, 1489, 5227}},",
          "14409:       {\"Samsung NX30\",",
          "14410:        0,",
          "14412:        {7557, -2522, -739, -4679, 12949, 1894, -840, 1777, 5311}},",
          "14413:       {\"Samsung NX2000\", 0, 0, {7557, -2522, -739, -4679, 12949, 1894, -840, 1777, 5311}},",
          "14414:       {\"Samsung NX2\",",
          "14415:        0,",
          "14417:        {6933, -2268, -753, -4921, 13387, 1647, -803, 1641, 6096}},",
          "14418:       {\"Samsung NX1000\", 0, 0, {6933, -2268, -753, -4921, 13387, 1647, -803, 1641, 6096}},",
          "14419:       {\"Samsung NX1100\", 0, 0, {6933, -2268, -753, -4921, 13387, 1647, -803, 1641, 6096}},",
          "14420:       {\"Samsung NX11\", 0, 0, {10332, -3234, -1168, -6111, 14639, 1520, -1352, 2647, 8331}},",
          "14421:       {\"Samsung NX10\",",
          "14422:        0,",
          "14424:        {10332, -3234, -1168, -6111, 14639, 1520, -1352, 2647, 8331}},",
          "14425:       {\"Samsung NX500\", 0, 0, {10686, -4042, -1052, -3595, 13238, 276, -464, 1259, 5931}},",
          "14426:       {\"Samsung NX5\", 0, 0, {10332, -3234, -1168, -6111, 14639, 1520, -1352, 2647, 8331}},",
          "14427:       {\"Samsung NX1\", 0, 0, {10686, -4042, -1052, -3595, 13238, 276, -464, 1259, 5931}},",
          "14428:       {\"Samsung WB2000\", 0, 0xfff, {12093, -3557, -1155, -1000, 9534, 1733, -22, 1787, 4576}},",
          "14429:       {\"Samsung GX-1\", 0, 0, {10504, -2438, -1189, -8603, 16207, 2531, -1022, 863, 12242}},",
          "14430:       {\"Samsung GX20\",",
          "14431:        0,",
          "14433:        {9427, -2714, -868, -7493, 16092, 1373, -2199, 3264, 7180}},",
          "14434:       {\"Samsung S85\",",
          "14435:        0,",
          "14437:        {11885, -3968, -1473, -4214, 12299, 1916, -835, 1655, 5549}},",
          "14439:       {\"Sigma dp0 Quattro\", 2047, 0, {13801, -3390, -1016, 5535, 3802, 877, 1848, 4245, 3730}},",
          "14440:       {\"Sigma dp1 Quattro\", 2047, 0, {13801, -3390, -1016, 5535, 3802, 877, 1848, 4245, 3730}},",
          "14441:       {\"Sigma dp2 Quattro\", 2047, 0, {13801, -3390, -1016, 5535, 3802, 877, 1848, 4245, 3730}},",
          "14442:       {\"Sigma dp3 Quattro\", 2047, 0, {13801, -3390, -1016, 5535, 3802, 877, 1848, 4245, 3730}},",
          "14444:       {\"Sigma SD9\",",
          "14445:        15,",
          "14447:        {14082, -2201, -1056, -5243, 14788, 167, -121, 196, 8881}},",
          "14448:       {\"Sigma SD10\",",
          "14449:        15,",
          "14451:        {14082, -2201, -1056, -5243, 14788, 167, -121, 196, 8881}},",
          "14452:       {\"Sigma SD14\",",
          "14453:        15,",
          "14455:        {14082, -2201, -1056, -5243, 14788, 167, -121, 196, 8881}},",
          "14456:       {\"Sigma SD15\",",
          "14457:        15,",
          "14459:        {14082, -2201, -1056, -5243, 14788, 167, -121, 196, 8881}},",
          "14461:       {\"Sigma SD1\",",
          "14462:        31,",
          "14464:        {5133, -1895, -353, 4978, 744, 144, 3837, 3069, 2777}},",
          "14465:       {\"Sigma DP1 Merrill\",",
          "14466:        31,",
          "14468:        {5133, -1895, -353, 4978, 744, 144, 3837, 3069, 2777}},",
          "14469:       {\"Sigma DP2 Merrill\",",
          "14470:        31,",
          "14472:        {5133, -1895, -353, 4978, 744, 144, 3837, 3069, 2777}},",
          "14473:       {\"Sigma DP3 Merrill\",",
          "14474:        31,",
          "14476:        {5133, -1895, -353, 4978, 744, 144, 3837, 3069, 2777}},",
          "14478:       {\"Sigma DP\",",
          "14479:        0,",
          "14482:        {13100, -3638, -847, 6855, 2369, 580, 2723, 3218, 3251}},",
          "14483:       {\"Sinar\",",
          "14484:        0,",
          "14486:        {16442, -2956, -2422, -2877, 12128, 750, -1136, 6066, 4559}},",
          "14487:       {\"Sony DSC-F828\", 0, 0, {7924, -1910, -777, -8226, 15459, 2998, -1517, 2199, 6818, -7242, 11401, 3481}},",
          "14488:       {\"Sony DSC-R1\", 0, 0, {8512, -2641, -694, -8042, 15670, 2526, -1821, 2117, 7414}},",
          "14489:       {\"Sony DSC-V3\", 0, 0, {7511, -2571, -692, -7894, 15088, 3060, -948, 1111, 8128}},",
          "14490:       {\"Sony DSC-RX100M5\",",
          "14491:        -800,",
          "14493:        {6596, -2079, -562, -4782, 13016, 1933, -970, 1581, 5181}},",
          "14494:       {\"Sony DSC-RX100M\",",
          "14495:        -800,",
          "14497:        {6596, -2079, -562, -4782, 13016, 1933, -970, 1581, 5181}},",
          "14498:       {\"Sony DSC-RX100\", 0, 0, {8651, -2754, -1057, -3464, 12207, 1373, -568, 1398, 4434}},",
          "14499:       {\"Sony DSC-RX10\",",
          "14500:        0,",
          "14502:        {6679, -1825, -745, -5047, 13256, 1953, -1580, 2422, 5183}},",
          "14503:       {\"Sony DSC-RX1RM2\", 0, 0, {6629, -1900, -483, -4618, 12349, 2550, -622, 1381, 6514}},",
          "14504:       {\"Sony DSC-RX1R\", 0, 0, {8195, -2800, -422, -4261, 12273, 1709, -1505, 2400, 5624}},",
          "14505:       {\"Sony DSC-RX1\", 0, 0, {6344, -1612, -462, -4863, 12477, 2681, -865, 1786, 6899}},",
          "14506:       {\"Sony DSLR-A100\", 0, 0xfeb, {9437, -2811, -774, -8405, 16215, 2290, -710, 596, 7181}},",
          "14507:       {\"Sony DSLR-A290\", 0, 0, {6038, -1484, -579, -9145, 16746, 2512, -875, 746, 7218}},",
          "14508:       {\"Sony DSLR-A2\", 0, 0, {9847, -3091, -928, -8485, 16345, 2225, -715, 595, 7103}},",
          "14509:       {\"Sony DSLR-A300\", 0, 0, {9847, -3091, -928, -8485, 16345, 2225, -715, 595, 7103}},",
          "14510:       {\"Sony DSLR-A330\", 0, 0, {9847, -3091, -929, -8485, 16346, 2225, -714, 595, 7103}},",
          "14511:       {\"Sony DSLR-A350\", 0, 0xffc, {6038, -1484, -578, -9146, 16746, 2513, -875, 746, 7217}},",
          "14512:       {\"Sony DSLR-A380\", 0, 0, {6038, -1484, -579, -9145, 16746, 2512, -875, 746, 7218}},",
          "14513:       {\"Sony DSLR-A390\", 0, 0, {6038, -1484, -579, -9145, 16746, 2512, -875, 746, 7218}},",
          "14514:       {\"Sony DSLR-A450\", 0, 0xfeb, {4950, -580, -103, -5228, 12542, 3029, -709, 1435, 7371}},",
          "14515:       {\"Sony DSLR-A580\", 0, 0xfeb, {5932, -1492, -411, -4813, 12285, 2856, -741, 1524, 6739}},",
          "14516:       {\"Sony DSLR-A500\", 0, 0xfeb, {6046, -1127, -278, -5574, 13076, 2786, -691, 1419, 7625}},",
          "14517:       {\"Sony DSLR-A5\", 0, 0xfeb, {4950, -580, -103, -5228, 12542, 3029, -709, 1435, 7371}},",
          "14518:       {\"Sony DSLR-A700\", 0, 0, {5775, -805, -359, -8574, 16295, 2391, -1943, 2341, 7249}},",
          "14519:       {\"Sony DSLR-A850\", 0, 0, {5413, -1162, -365, -5665, 13098, 2866, -608, 1179, 8440}},",
          "14520:       {\"Sony DSLR-A900\", 0, 0, {5209, -1072, -397, -8845, 16120, 2919, -1618, 1803, 8654}},",
          "14521:       {\"Sony ILCA-68\", 0, 0, {6435, -1903, -536, -4722, 12449, 2550, -663, 1363, 6517}},",
          "14522:       {\"Sony ILCA-77M2\", 0, 0, {5991, -1732, -443, -4100, 11989, 2381, -704, 1467, 5992}},",
          "14523:       {\"Sony ILCA-99M2\",",
          "14524:        0,",
          "14526:        {6660, -1918, -471, -4613, 12398, 2485, -649, 1433, 6447}},",
          "14527:       {\"Sony ILCE-7M2\", 0, 0, {5271, -712, -347, -6153, 13653, 2763, -1601, 2366, 7242}},",
          "14528:       {\"Sony ILCE-7SM2\", 0, 0, {5838, -1430, -246, -3497, 11477, 2297, -748, 1885, 5778}},",
          "14529:       {\"Sony ILCE-7S\", 0, 0, {5838, -1430, -246, -3497, 11477, 2297, -748, 1885, 5778}},",
          "14530:       {\"Sony ILCE-7RM2\", 0, 0, {6629, -1900, -483, -4618, 12349, 2550, -622, 1381, 6514}},",
          "14531:       {\"Sony ILCE-7R\", 0, 0, {4913, -541, -202, -6130, 13513, 2906, -1564, 2151, 7183}},",
          "14532:       {\"Sony ILCE-7\", 0, 0, {5271, -712, -347, -6153, 13653, 2763, -1601, 2366, 7242}},",
          "14533:       {\"Sony ILCE-6300\", 0, 0, {5973, -1695, -419, -3826, 11797, 2293, -639, 1398, 5789}},",
          "14534:       {\"Sony ILCE-6500\",",
          "14535:        0,",
          "14537:        {5973, -1695, -419, -3826, 11797, 2293, -639, 1398, 5789}},",
          "14538:       {\"Sony ILCE\",",
          "14539:        0,",
          "14541:        {5991, -1456, -455, -4764, 12135, 2980, -707, 1425, 6701}},",
          "14542:       {\"Sony NEX-5N\", 0, 0, {5991, -1456, -455, -4764, 12135, 2980, -707, 1425, 6701}},",
          "14543:       {\"Sony NEX-5R\", 0, 0, {6129, -1545, -418, -4930, 12490, 2743, -977, 1693, 6615}},",
          "14544:       {\"Sony NEX-5T\", 0, 0, {6129, -1545, -418, -4930, 12490, 2743, -977, 1693, 6615}},",
          "14545:       {\"Sony NEX-3N\", 0, 0, {6129, -1545, -418, -4930, 12490, 2743, -977, 1693, 6615}},",
          "14546:       {\"Sony NEX-3\",",
          "14547:        0,",
          "14549:        {6549, -1550, -436, -4880, 12435, 2753, -854, 1868, 6976}},",
          "14550:       {\"Sony NEX-5\",",
          "14551:        0,",
          "14553:        {6549, -1550, -436, -4880, 12435, 2753, -854, 1868, 6976}},",
          "14554:       {\"Sony NEX-6\", 0, 0, {6129, -1545, -418, -4930, 12490, 2743, -977, 1693, 6615}},",
          "14555:       {\"Sony NEX-7\", 0, 0, {5491, -1192, -363, -4951, 12342, 2948, -911, 1722, 7192}},",
          "14556:       {\"Sony NEX\",",
          "14557:        0,",
          "14559:        {5991, -1456, -455, -4764, 12135, 2980, -707, 1425, 6701}},",
          "14560:       {\"Sony SLT-A33\", 0, 0, {6069, -1221, -366, -5221, 12779, 2734, -1024, 2066, 6834}},",
          "14561:       {\"Sony SLT-A35\", 0, 0, {5986, -1618, -415, -4557, 11820, 3120, -681, 1404, 6971}},",
          "14562:       {\"Sony SLT-A37\", 0, 0, {5991, -1456, -455, -4764, 12135, 2980, -707, 1425, 6701}},",
          "14563:       {\"Sony SLT-A55\", 0, 0, {5932, -1492, -411, -4813, 12285, 2856, -741, 1524, 6739}},",
          "14564:       {\"Sony SLT-A57\", 0, 0, {5991, -1456, -455, -4764, 12135, 2980, -707, 1425, 6701}},",
          "14565:       {\"Sony SLT-A58\", 0, 0, {5991, -1456, -455, -4764, 12135, 2980, -707, 1425, 6701}},",
          "14566:       {\"Sony SLT-A65\", 0, 0, {5491, -1192, -363, -4951, 12342, 2948, -911, 1722, 7192}},",
          "14567:       {\"Sony SLT-A77\", 0, 0, {5491, -1192, -363, -4951, 12342, 2948, -911, 1722, 7192}},",
          "14568:       {\"Sony SLT-A99\", 0, 0, {6344, -1612, -462, -4863, 12477, 2681, -865, 1786, 6899}},",
          "14574:   if (colors > 4 || colors < 1)",
          "14575:     return;",
          "14577:   int bl4 = (cblack[0] + cblack[1] + cblack[2] + cblack[3]) / 4, bl64 = 0;",
          "14578:   if (cblack[4] * cblack[5] > 0)",
          "14580:     for (unsigned c = 0; c < 4096 && c < cblack[4] * cblack[5]; c++)",
          "14581:       bl64 += cblack[c + 6];",
          "14582:     bl64 /= cblack[4] * cblack[5];",
          "14584:   int rblack = black + bl4 + bl64;",
          "14586:   sprintf(name, \"%s %s\", t_make, t_model);",
          "14587:   for (i = 0; i < sizeof table / sizeof *table; i++)",
          "14588:     if (!strncasecmp(name, table[i].prefix, strlen(table[i].prefix)))",
          "14589:     {",
          "14590:       if (!dng_version)",
          "14591:       {",
          "14592:         if (table[i].t_black > 0)",
          "14593:         {",
          "14594:           black = (ushort)table[i].t_black;",
          "14595:           memset(cblack, 0, sizeof(cblack));",
          "14596:         }",
          "14597:         else if (table[i].t_black < 0 && rblack == 0)",
          "14598:         {",
          "14599:           black = (ushort)(-table[i].t_black);",
          "14600:           memset(cblack, 0, sizeof(cblack));",
          "14601:         }",
          "14602:         if (table[i].t_maximum)",
          "14603:           maximum = (ushort)table[i].t_maximum;",
          "14604:       }",
          "14605:       if (table[i].trans[0])",
          "14606:       {",
          "14607:         for (raw_color = j = 0; j < 12; j++)",
          "14609:           if (internal_only)",
          "14610:             imgdata.color.cam_xyz[0][j] = table[i].trans[j] / 10000.0;",
          "14611:           else",
          "14612:             imgdata.color.cam_xyz[0][j] =",
          "14614:                 ((double *)cam_xyz)[j] = table[i].trans[j] / 10000.0;",
          "14616:         if (!internal_only)",
          "14618:           cam_xyz_coeff(rgb_cam, cam_xyz);",
          "14624: void CLASS simple_coeff(int index)",
          "14627:                                     {1.4032, -0.2231, -0.1016, -0.5263, 1.4816, 0.017, -0.0112, 0.0183, 0.9113},",
          "14629:                                     {2.25, 0.75, -1.75, -0.25, -0.25, 0.75, 0.75, -0.25, -0.25, -1.75, 0.75, 2.25},",
          "14631:                                     {1.893, -0.418, -0.476, -0.495, 1.773, -0.278, -1.017, -0.655, 2.672},",
          "14633:                                     {-1.936280, 1.800443, -1.448486, 2.584324, 1.405365, -0.524955, -0.289090, 0.408680,",
          "14634:                                      -1.204965, 1.082304, 2.941367, -1.818705}};",
          "14637:   for (raw_color = i = 0; i < 3; i++)",
          "14638:     FORCC rgb_cam[i][c] = table[index][i * colors + c];",
          "14641: short CLASS guess_byte_order(int words)",
          "14644:   int t = 2, msb;",
          "14645:   double diff, sum[2] = {0, 0};",
          "14647:   fread(test[0], 2, 2, ifp);",
          "14648:   for (words -= 2; words--;)",
          "14649:   {",
          "14650:     fread(test[t], 2, 1, ifp);",
          "14651:     for (msb = 0; msb < 2; msb++)",
          "14652:     {",
          "14653:       diff = (test[t ^ 2][msb] << 8 | test[t ^ 2][!msb]) - (test[t][msb] << 8 | test[t][!msb]);",
          "14654:       sum[msb] += diff * diff;",
          "14656:     t = (t + 1) & 3;",
          "14661: float CLASS find_green(int bps, int bite, int off0, int off1)",
          "14663:   UINT64 bitbuf = 0;",
          "14666:   double sum[] = {0, 0};",
          "14668:   FORC(2)",
          "14669:   {",
          "14670:     fseek(ifp, c ? off1 : off0, SEEK_SET);",
          "14671:     for (vbits = col = 0; col < width; col++)",
          "14672:     {",
          "14673:       for (vbits -= bps; vbits < 0; vbits += bite)",
          "14674:       {",
          "14675:         bitbuf <<= bite;",
          "14676:         for (i = 0; i < bite; i += 8)",
          "14677:           bitbuf |= (unsigned)(fgetc(ifp) << i);",
          "14679:       img[c][col] = bitbuf << (64 - bps - vbits) >> (64 - bps);",
          "14682:   FORC(width - 1)",
          "14683:   {",
          "14684:     sum[c & 1] += ABS(img[0][c] - img[1][c + 1]);",
          "14685:     sum[~c & 1] += ABS(img[1][c] - img[0][c + 1]);",
          "14687:   return 100 * log(sum[0] / sum[1]);",
          "14693:   if (len < 1)",
          "14694:     return; // not needed, b/c sizeof of make/model is 64",
          "14695:   string[len - 1] = 0;",
          "14696:   if (len < 3)",
          "14697:     return; // also not needed",
          "14698:   len = strnlen(string, len - 1);",
          "14699:   for (int i = len - 1; i >= 0; i--)",
          "14701:     if (isspace(string[i]))",
          "14702:       string[i] = 0;",
          "",
          "---------------",
          "--- Hunk 102 ---",
          "[Context before]",
          "13652: void CLASS identify()",
          "13653: {",
          "13654:   static const short pana[][6] = {",
          "13678:   };",
          "13679:   static const ushort canon[][11] = {",
          "13724:   };",
          "13726:     ushort id;",
          "13727:     char t_model[20];",
          "13852: #else",
          "13854:     unsigned fsize;",
          "13855:     ushort rw, rh;",
          "13856:     uchar lm, tm, rm, bm, lf, cf, max, flags;",
          "13857:     char t_make[10], t_model[20];",
          "13858:     ushort offset;",
          "14016: #ifdef LIBRAW_LIBRARY_BUILD",
          "14017:   char head[64], *cp;",
          "14018: #else",
          "14019:   char head[32], *cp;",
          "14020: #endif",
          "14022:   struct jhead jh;",
          "14024: #ifdef LIBRAW_LIBRARY_BUILD",
          "14029: #endif",
          "14032:   raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;",
          "14033:   maximum = height = width = top_margin = left_margin = 0;",
          "14034:   cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;",
          "14035:   iso_speed = shutter = aperture = focal_len = unique_id = 0;",
          "14036:   tiff_nifds = 0;",
          "14042:   thumb_offset = thumb_length = thumb_width = thumb_height = 0;",
          "14043:   load_raw = thumb_load_raw = 0;",
          "14044:   write_thumb = &CLASS jpeg_thumb;",
          "",
          "[Removed Lines]",
          "13655:     { 3130, 1743,  4,  0, -6,  0 },",
          "13656:     { 3130, 2055,  4,  0, -6,  0 },",
          "13657:     { 3130, 2319,  4,  0, -6,  0 },",
          "13658:     { 3170, 2103, 18,  0,-42, 20 },",
          "13659:     { 3170, 2367, 18, 13,-42,-21 },",
          "13660:     { 3177, 2367,  0,  0, -1,  0 },",
          "13661:     { 3304, 2458,  0,  0, -1,  0 },",
          "13662:     { 3330, 2463,  9,  0, -5,  0 },",
          "13663:     { 3330, 2479,  9,  0,-17,  4 },",
          "13664:     { 3370, 1899, 15,  0,-44, 20 },",
          "13665:     { 3370, 2235, 15,  0,-44, 20 },",
          "13666:     { 3370, 2511, 15, 10,-44,-21 },",
          "13667:     { 3690, 2751,  3,  0, -8, -3 },",
          "13668:     { 3710, 2751,  0,  0, -3,  0 },",
          "13669:     { 3724, 2450,  0,  0,  0, -2 },",
          "13670:     { 3770, 2487, 17,  0,-44, 19 },",
          "13671:     { 3770, 2799, 17, 15,-44,-19 },",
          "13672:     { 3880, 2170,  6,  0, -6,  0 },",
          "13673:     { 4060, 3018,  0,  0,  0, -2 },",
          "13674:     { 4290, 2391,  3,  0, -8, -1 },",
          "13675:     { 4330, 2439, 17, 15,-44,-19 },",
          "13676:     { 4508, 2962,  0,  0, -3, -4 },",
          "13677:     { 4508, 3330,  0,  0, -3, -6 },",
          "13680:     { 1944, 1416,   0,  0, 48,  0 },",
          "13681:     { 2144, 1560,   4,  8, 52,  2, 0, 0, 0, 25 },",
          "13682:     { 2224, 1456,  48,  6,  0,  2 },",
          "13683:     { 2376, 1728,  12,  6, 52,  2 },",
          "13684:     { 2672, 1968,  12,  6, 44,  2 },",
          "13685:     { 3152, 2068,  64, 12,  0,  0, 16 },",
          "13686:     { 3160, 2344,  44, 12,  4,  4 },",
          "13687:     { 3344, 2484,   4,  6, 52,  6 },",
          "13688:     { 3516, 2328,  42, 14,  0,  0 },",
          "13689:     { 3596, 2360,  74, 12,  0,  0 },",
          "13690:     { 3744, 2784,  52, 12,  8, 12 },",
          "13691:     { 3944, 2622,  30, 18,  6,  2 },",
          "13692:     { 3948, 2622,  42, 18,  0,  2 },",
          "13693:     { 3984, 2622,  76, 20,  0,  2, 14 },",
          "13694:     { 4104, 3048,  48, 12, 24, 12 },",
          "13695:     { 4116, 2178,   4,  2,  0,  0 },",
          "13696:     { 4152, 2772, 192, 12,  0,  0 },",
          "13697:     { 4160, 3124, 104, 11,  8, 65 },",
          "13698:     { 4176, 3062,  96, 17,  8,  0, 0, 16, 0, 7, 0x49 },",
          "13699:     { 4192, 3062,  96, 17, 24,  0, 0, 16, 0, 0, 0x49 },",
          "13700:     { 4312, 2876,  22, 18,  0,  2 },",
          "13701:     { 4352, 2874,  62, 18,  0,  0 },",
          "13702:     { 4476, 2954,  90, 34,  0,  0 },",
          "13703:     { 4480, 3348,  12, 10, 36, 12, 0, 0, 0, 18, 0x49 },",
          "13704:     { 4480, 3366,  80, 50,  0,  0 },",
          "13705:     { 4496, 3366,  80, 50, 12,  0 },",
          "13706:     { 4768, 3516,  96, 16,  0,  0, 0, 16 },",
          "13707:     { 4832, 3204,  62, 26,  0,  0 },",
          "13708:     { 4832, 3228,  62, 51,  0,  0 },",
          "13709:     { 5108, 3349,  98, 13,  0,  0 },",
          "13710:     { 5120, 3318, 142, 45, 62,  0 },",
          "13712:     { 5344, 3516, 142, 51,  0,  0 },",
          "13713:     { 5344, 3584, 126,100,  0,  2 },",
          "13714:     { 5360, 3516, 158, 51,  0,  0 },",
          "13715:     { 5568, 3708,  72, 38,  0,  0 },",
          "13716:     { 5632, 3710,  96, 17,  0,  0, 0, 16, 0, 0, 0x49 },",
          "13717:     { 5712, 3774,  62, 20, 10,  2 },",
          "13718:     { 5792, 3804, 158, 51,  0,  0 },",
          "13719:     { 5920, 3950, 122, 80,  2,  0 },",
          "13723:     { 8896, 5920, 160, 64,  0,  0 },",
          "13725:   static const struct {",
          "13728:   } unique[] = {",
          "13729:     { 0x001, \"EOS-1D\" },",
          "13730:     { 0x167, \"EOS-1DS\" },",
          "13731:     { 0x168, \"EOS 10D\" },",
          "13732:     { 0x169, \"EOS-1D Mark III\" },",
          "13733:     { 0x170, \"EOS 300D\" },",
          "13734:     { 0x174, \"EOS-1D Mark II\" },",
          "13735:     { 0x175, \"EOS 20D\" },",
          "13736:     { 0x176, \"EOS 450D\" },",
          "13737:     { 0x188, \"EOS-1Ds Mark II\" },",
          "13738:     { 0x189, \"EOS 350D\" },",
          "13739:     { 0x190, \"EOS 40D\" },",
          "13740:     { 0x213, \"EOS 5D\" },",
          "13741:     { 0x215, \"EOS-1Ds Mark III\" },",
          "13742:     { 0x218, \"EOS 5D Mark II\" },",
          "13743:     { 0x232, \"EOS-1D Mark II N\" },",
          "13744:     { 0x234, \"EOS 30D\" },",
          "13745:     { 0x236, \"EOS 400D\" },",
          "13746:     { 0x250, \"EOS 7D\" },",
          "13747:     { 0x252, \"EOS 500D\" },",
          "13748:     { 0x254, \"EOS 1000D\" },",
          "13749:     { 0x261, \"EOS 50D\" },",
          "13750:     { 0x269, \"EOS-1D X\" },",
          "13751:     { 0x270, \"EOS 550D\" },",
          "13752:     { 0x281, \"EOS-1D Mark IV\" },",
          "13753:     { 0x285, \"EOS 5D Mark III\" },",
          "13754:     { 0x286, \"EOS 600D\" },",
          "13755:     { 0x287, \"EOS 60D\" },",
          "13756:     { 0x288, \"EOS 1100D\" },",
          "13757:     { 0x289, \"EOS 7D Mark II\" },",
          "13758:     { 0x301, \"EOS 650D\" },",
          "13759:     { 0x302, \"EOS 6D\" },",
          "13760:     { 0x324, \"EOS-1D C\" },",
          "13761:     { 0x325, \"EOS 70D\" },",
          "13762:     { 0x326, \"EOS 700D\" },",
          "13763:     { 0x327, \"EOS 1200D\" },",
          "13764:     { 0x328, \"EOS-1D X Mark II\" },",
          "13765:     { 0x331, \"EOS M\" },",
          "13766:     { 0x335, \"EOS M2\" },",
          "13770:     { 0x346, \"EOS 100D\" },",
          "13771:     { 0x347, \"EOS 760D\" },",
          "13772:     { 0x349, \"EOS 5D Mark IV\" },",
          "13773:     { 0x350, \"EOS 80D\"},",
          "13774:     { 0x382, \"EOS 5DS\" },",
          "13775:     { 0x393, \"EOS 750D\" },",
          "13776:     { 0x401, \"EOS 5DS R\" },",
          "13777:     { 0x404, \"EOS 1300D\" },",
          "13778:   }, sonique[] = {",
          "13779:     { 0x002, \"DSC-R1\" },",
          "13780:     { 0x100, \"DSLR-A100\" },",
          "13781:     { 0x101, \"DSLR-A900\" },",
          "13782:     { 0x102, \"DSLR-A700\" },",
          "13783:     { 0x103, \"DSLR-A200\" },",
          "13784:     { 0x104, \"DSLR-A350\" },",
          "13785:     { 0x105, \"DSLR-A300\" },",
          "13786:     { 0x106, \"DSLR-A900\" },",
          "13787:     { 0x107, \"DSLR-A380\" },",
          "13788:     { 0x108, \"DSLR-A330\" },",
          "13789:     { 0x109, \"DSLR-A230\" },",
          "13790:     { 0x10a, \"DSLR-A290\" },",
          "13791:     { 0x10d, \"DSLR-A850\" },",
          "13792:     { 0x10e, \"DSLR-A850\" },",
          "13793:     { 0x111, \"DSLR-A550\" },",
          "13794:     { 0x112, \"DSLR-A500\" },",
          "13795:     { 0x113, \"DSLR-A450\" },",
          "13796:     { 0x116, \"NEX-5\" },",
          "13797:     { 0x117, \"NEX-3\" },",
          "13798:     { 0x118, \"SLT-A33\" },",
          "13799:     { 0x119, \"SLT-A55V\" },",
          "13800:     { 0x11a, \"DSLR-A560\" },",
          "13801:     { 0x11b, \"DSLR-A580\" },",
          "13802:     { 0x11c, \"NEX-C3\" },",
          "13803:     { 0x11d, \"SLT-A35\" },",
          "13804:     { 0x11e, \"SLT-A65V\" },",
          "13805:     { 0x11f, \"SLT-A77V\" },",
          "13806:     { 0x120, \"NEX-5N\" },",
          "13807:     { 0x121, \"NEX-7\" },",
          "13808:     { 0x122, \"NEX-VG20E\"},",
          "13809:     { 0x123, \"SLT-A37\" },",
          "13810:     { 0x124, \"SLT-A57\" },",
          "13811:     { 0x125, \"NEX-F3\" },",
          "13812:     { 0x126, \"SLT-A99V\" },",
          "13813:     { 0x127, \"NEX-6\" },",
          "13814:     { 0x128, \"NEX-5R\" },",
          "13815:     { 0x129, \"DSC-RX100\" },",
          "13816:     { 0x12a, \"DSC-RX1\" },",
          "13817:     { 0x12b, \"NEX-VG900\" },",
          "13818:     { 0x12c, \"NEX-VG30E\" },",
          "13819:     { 0x12e, \"ILCE-3000\" },",
          "13820:     { 0x12f, \"SLT-A58\" },",
          "13821:     { 0x131, \"NEX-3N\" },",
          "13822:     { 0x132, \"ILCE-7\" },",
          "13823:     { 0x133, \"NEX-5T\" },",
          "13824:     { 0x134, \"DSC-RX100M2\" },",
          "13825:     { 0x135, \"DSC-RX10\" },",
          "13826:     { 0x136, \"DSC-RX1R\" },",
          "13827:     { 0x137, \"ILCE-7R\" },",
          "13828:     { 0x138, \"ILCE-6000\" },",
          "13829:     { 0x139, \"ILCE-5000\" },",
          "13830:     { 0x13d, \"DSC-RX100M3\" },",
          "13831:     { 0x13e, \"ILCE-7S\" },",
          "13832:     { 0x13f, \"ILCA-77M2\" },",
          "13833:     { 0x153, \"ILCE-5100\" },",
          "13834:     { 0x154, \"ILCE-7M2\" },",
          "13835:     { 0x155, \"DSC-RX100M4\" },",
          "13836:     { 0x156, \"DSC-RX10M2\" },",
          "13837:     { 0x158, \"DSC-RX1RM2\" },",
          "13838:     { 0x15a, \"ILCE-QX1\" },",
          "13839:     { 0x15b, \"ILCE-7RM2\" },",
          "13840:     { 0x15e, \"ILCE-7SM2\" },",
          "13841:     { 0x161, \"ILCA-68\" },",
          "13842:     { 0x162, \"ILCA-99M2\" },",
          "13843:     { 0x163, \"DSC-RX10M3\" },",
          "13844:     { 0x164, \"DSC-RX100M5\"},",
          "13845:     { 0x165, \"ILCE-6300\" },",
          "13846:     { 0x168, \"ILCE-6500\"},",
          "13847:   };",
          "13849: #ifdef LIBRAW_LIBRARY_BUILD",
          "13850:   static const libraw_custom_camera_t",
          "13851:     const_table[]",
          "13853:   static const struct {",
          "13859:   }",
          "13860:   table[]",
          "13861: #endif",
          "13862:    = {",
          "13863:     {   786432,1024, 768, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-080C\" },",
          "13864:     {  1447680,1392,1040, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-145C\" },",
          "13865:     {  1920000,1600,1200, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-201C\" },",
          "13866:     {  5067304,2588,1958, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-510C\" },",
          "13867:     {  5067316,2588,1958, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-510C\",12 },",
          "13868:     { 10134608,2588,1958, 0, 0, 0, 0, 9,0x94,0,0,\"AVT\",\"F-510C\" },",
          "13869:     { 10134620,2588,1958, 0, 0, 0, 0, 9,0x94,0,0,\"AVT\",\"F-510C\",12 },",
          "13870:     { 16157136,3272,2469, 0, 0, 0, 0, 9,0x94,0,0,\"AVT\",\"F-810C\" },",
          "13871:     { 15980544,3264,2448, 0, 0, 0, 0, 8,0x61,0,1,\"AgfaPhoto\",\"DC-833m\" },",
          "13872:     {  9631728,2532,1902, 0, 0, 0, 0,96,0x61,0,0,\"Alcatel\",\"5035D\" },",
          "13873:     {  31850496,4608,3456, 0, 0, 0, 0,0,0x94,0,0,\"GITUP\",\"GIT2 4:3\" },",
          "13874:     {  23887872,4608,2592, 0, 0, 0, 0,0,0x94,0,0,\"GITUP\",\"GIT2 16:9\" },",
          "13877:     {  1540857,2688,1520, 0, 0, 0, 0, 1,0x61,0,0,\"Samsung\",\"S3\" },",
          "13878:     {  2658304,1212,1096, 0, 0, 0, 0, 1 ,0x16,0,0,\"LG\",\"G3FrontMipi\" },",
          "13879:     {  2842624,1296,1096, 0, 0, 0, 0, 1 ,0x16,0,0,\"LG\",\"G3FrontQCOM\" },",
          "13880:     {  2969600,1976,1200, 0, 0, 0, 0, 1 ,0x16,0,0,\"Xiaomi\",\"MI3wMipi\" },",
          "13881:     {  3170304,1976,1200, 0, 0, 0, 0, 1 ,0x16,0,0,\"Xiaomi\",\"MI3wQCOM\" },",
          "13882:     {  3763584,1584,1184, 0, 0, 0, 0, 96,0x61,0,0,\"I_Mobile\",\"I_StyleQ6\" },",
          "13883:     {  5107712,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"UltraPixel1\" },",
          "13884:     {  5382640,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"UltraPixel2\" },",
          "13885:     {  5664912,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"4688\" },",
          "13886:     {  5664912,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"4688\" },",
          "13887:     {  5364240,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"4688\" },",
          "13888:     {  6299648,2592,1944, 0, 0, 0, 0, 1 ,0x16,0,0,\"OmniVisi\",\"OV5648\" },",
          "13889:     {  6721536,2592,1944, 0, 0, 0, 0, 0 ,0x16,0,0,\"OmniVisi\",\"OV56482\" },",
          "13890:     {  6746112,2592,1944, 0, 0, 0, 0, 0 ,0x16,0,0,\"HTC\",\"OneSV\" },",
          "13891:     {  9631728,2532,1902, 0, 0, 0, 0, 96,0x61,0,0,\"Sony\",\"5mp\" },",
          "13892:     {  9830400,2560,1920, 0, 0, 0, 0, 96,0x61,0,0,\"NGM\",\"ForwardArt\" },",
          "13893:     { 10186752,3264,2448, 0, 0, 0, 0, 1,0x94,0,0,\"Sony\",\"IMX219-mipi 8mp\" },",
          "13894:     { 10223360,2608,1944, 0, 0, 0, 0, 96,0x16,0,0,\"Sony\",\"IMX\" },",
          "13895:     { 10782464,3282,2448, 0, 0, 0, 0, 0 ,0x16,0,0,\"HTC\",\"MyTouch4GSlide\" },",
          "13896:     { 10788864,3282,2448, 0, 0, 0, 0, 0, 0x16,0,0,\"Xperia\",\"L\" },",
          "13897:     { 15967488,3264,2446, 0, 0, 0, 0, 96,0x16,0,0,\"OmniVison\",\"OV8850\" },",
          "13898:     { 16224256,4208,3082, 0, 0, 0, 0, 1, 0x16,0,0,\"LG\",\"G3MipiL\" },",
          "13899:     { 16424960,4208,3120, 0, 0, 0, 0, 1, 0x16,0,0,\"IMX135\",\"MipiL\" },",
          "13900:     { 17326080,4164,3120, 0, 0, 0, 0, 1, 0x16,0,0,\"LG\",\"G3LQCom\" },",
          "13901:     { 17522688,4212,3120, 0, 0, 0, 0, 0,0x16,0,0,\"Sony\",\"IMX135-QCOM\" },",
          "13902:     { 19906560,4608,3456, 0, 0, 0, 0, 1, 0x16,0,0,\"Gione\",\"E7mipi\" },",
          "13903:     { 19976192,5312,2988, 0, 0, 0, 0, 1, 0x16,0,0,\"LG\",\"G4\" },",
          "13904:     { 20389888,4632,3480, 0, 0, 0, 0, 1, 0x16,0,0,\"Xiaomi\",\"RedmiNote3Pro\" },",
          "13905:     { 20500480,4656,3496, 0, 0, 0, 0, 1,0x94,0,0,\"Sony\",\"IMX298-mipi 16mp\" },",
          "13906:     { 21233664,4608,3456, 0, 0, 0, 0, 1, 0x16,0,0,\"Gione\",\"E7qcom\" },",
          "13907:     { 26023936,4192,3104, 0, 0, 0, 0, 96,0x94,0,0,\"THL\",\"5000\" },",
          "13908:     { 26257920,4208,3120, 0, 0, 0, 0, 96,0x94,0,0,\"Sony\",\"IMX214\" },",
          "13909:     { 26357760,4224,3120, 0, 0, 0, 0, 96,0x61,0,0,\"OV\",\"13860\" },",
          "13910:     { 41312256,5248,3936, 0, 0, 0, 0, 96,0x61,0,0,\"Meizu\",\"MX4\" },",
          "13911:     { 42923008,5344,4016, 0, 0, 0, 0, 96,0x61,0,0,\"Sony\",\"IMX230\" },",
          "13913:     {  20137344,3664,2748,0, 0, 0, 0,0x40,0x49,0,0,\"Aptina\",\"MT9J003\",0xffff },",
          "13914:     {  2868726,1384,1036, 0, 0, 0, 0,64,0x49,0,8,\"Baumer\",\"TXG14\",1078 },",
          "13915:     {  5298000,2400,1766,12,12,44, 2,40,0x94,0,2,\"Canon\",\"PowerShot SD300\" },",
          "13916:     {  6553440,2664,1968, 4, 4,44, 4,40,0x94,0,2,\"Canon\",\"PowerShot A460\" },",
          "13917:     {  6573120,2672,1968,12, 8,44, 0,40,0x94,0,2,\"Canon\",\"PowerShot A610\" },",
          "13918:     {  6653280,2672,1992,10, 6,42, 2,40,0x94,0,2,\"Canon\",\"PowerShot A530\" },",
          "13919:     {  7710960,2888,2136,44, 8, 4, 0,40,0x94,0,2,\"Canon\",\"PowerShot S3 IS\" },",
          "13920:     {  9219600,3152,2340,36,12, 4, 0,40,0x94,0,2,\"Canon\",\"PowerShot A620\" },",
          "13921:     {  9243240,3152,2346,12, 7,44,13,40,0x49,0,2,\"Canon\",\"PowerShot A470\" },",
          "13922:     { 10341600,3336,2480, 6, 5,32, 3,40,0x94,0,2,\"Canon\",\"PowerShot A720 IS\" },",
          "13923:     { 10383120,3344,2484,12, 6,44, 6,40,0x94,0,2,\"Canon\",\"PowerShot A630\" },",
          "13924:     { 12945240,3736,2772,12, 6,52, 6,40,0x94,0,2,\"Canon\",\"PowerShot A640\" },",
          "13925:     { 15636240,4104,3048,48,12,24,12,40,0x94,0,2,\"Canon\",\"PowerShot A650\" },",
          "13926:     { 15467760,3720,2772, 6,12,30, 0,40,0x94,0,2,\"Canon\",\"PowerShot SX110 IS\" },",
          "13927:     { 15534576,3728,2778,12, 9,44, 9,40,0x94,0,2,\"Canon\",\"PowerShot SX120 IS\" },",
          "13928:     { 18653760,4080,3048,24,12,24,12,40,0x94,0,2,\"Canon\",\"PowerShot SX20 IS\" },",
          "13929:     { 19131120,4168,3060,92,16, 4, 1,40,0x94,0,2,\"Canon\",\"PowerShot SX220 HS\" },",
          "13930:     { 21936096,4464,3276,25,10,73,12,40,0x16,0,2,\"Canon\",\"PowerShot SX30 IS\" },",
          "13931:     { 24724224,4704,3504, 8,16,56, 8,40,0x49,0,2,\"Canon\",\"PowerShot A3300 IS\" },",
          "13932:     { 30858240,5248,3920, 8,16,56,16,40,0x94,0,2,\"Canon\",\"IXUS 160\" },",
          "13933:     {  1976352,1632,1211, 0, 2, 0, 1, 0,0x94,0,1,\"Casio\",\"QV-2000UX\" },",
          "13934:     {  3217760,2080,1547, 0, 0,10, 1, 0,0x94,0,1,\"Casio\",\"QV-3*00EX\" },",
          "13935:     {  6218368,2585,1924, 0, 0, 9, 0, 0,0x94,0,1,\"Casio\",\"QV-5700\" },",
          "13936:     {  7816704,2867,2181, 0, 0,34,36, 0,0x16,0,1,\"Casio\",\"EX-Z60\" },",
          "13937:     {  2937856,1621,1208, 0, 0, 1, 0, 0,0x94,7,13,\"Casio\",\"EX-S20\" },",
          "13938:     {  4948608,2090,1578, 0, 0,32,34, 0,0x94,7,1,\"Casio\",\"EX-S100\" },",
          "13939:     {  6054400,2346,1720, 2, 0,32, 0, 0,0x94,7,1,\"Casio\",\"QV-R41\" },",
          "13940:     {  7426656,2568,1928, 0, 0, 0, 0, 0,0x94,0,1,\"Casio\",\"EX-P505\" },",
          "13941:     {  7530816,2602,1929, 0, 0,22, 0, 0,0x94,7,1,\"Casio\",\"QV-R51\" },",
          "13942:     {  7542528,2602,1932, 0, 0,32, 0, 0,0x94,7,1,\"Casio\",\"EX-Z50\" },",
          "13943:     {  7562048,2602,1937, 0, 0,25, 0, 0,0x16,7,1,\"Casio\",\"EX-Z500\" },",
          "13944:     {  7753344,2602,1986, 0, 0,32,26, 0,0x94,7,1,\"Casio\",\"EX-Z55\" },",
          "13945:     {  9313536,2858,2172, 0, 0,14,30, 0,0x94,7,1,\"Casio\",\"EX-P600\" },",
          "13946:     { 10834368,3114,2319, 0, 0,27, 0, 0,0x94,0,1,\"Casio\",\"EX-Z750\" },",
          "13947:     { 10843712,3114,2321, 0, 0,25, 0, 0,0x94,0,1,\"Casio\",\"EX-Z75\" },",
          "13948:     { 10979200,3114,2350, 0, 0,32,32, 0,0x94,7,1,\"Casio\",\"EX-P700\" },",
          "13949:     { 12310144,3285,2498, 0, 0, 6,30, 0,0x94,0,1,\"Casio\",\"EX-Z850\" },",
          "13950:     { 12489984,3328,2502, 0, 0,47,35, 0,0x94,0,1,\"Casio\",\"EX-Z8\" },",
          "13951:     { 15499264,3754,2752, 0, 0,82, 0, 0,0x94,0,1,\"Casio\",\"EX-Z1050\" },",
          "13952:     { 18702336,4096,3044, 0, 0,24, 0,80,0x94,7,1,\"Casio\",\"EX-ZR100\" },",
          "13953:     {  7684000,2260,1700, 0, 0, 0, 0,13,0x94,0,1,\"Casio\",\"QV-4000\" },",
          "13954:     {   787456,1024, 769, 0, 1, 0, 0, 0,0x49,0,0,\"Creative\",\"PC-CAM 600\" },",
          "13955:     { 28829184,4384,3288, 0, 0, 0, 0,36,0x61,0,0,\"DJI\" },",
          "13956:     { 15151104,4608,3288, 0, 0, 0, 0, 0,0x94,0,0,\"Matrix\" },",
          "13957:     {  3840000,1600,1200, 0, 0, 0, 0,65,0x49,0,0,\"Foculus\",\"531C\" },",
          "13958:     {   307200, 640, 480, 0, 0, 0, 0, 0,0x94,0,0,\"Generic\" },",
          "13959:     {    62464, 256, 244, 1, 1, 6, 1, 0,0x8d,0,0,\"Kodak\",\"DC20\" },",
          "13960:     {   124928, 512, 244, 1, 1,10, 1, 0,0x8d,0,0,\"Kodak\",\"DC20\" },",
          "13961:     {  1652736,1536,1076, 0,52, 0, 0, 0,0x61,0,0,\"Kodak\",\"DCS200\" },",
          "13962:     {  4159302,2338,1779, 1,33, 1, 2, 0,0x94,0,0,\"Kodak\",\"C330\" },",
          "13963:     {  4162462,2338,1779, 1,33, 1, 2, 0,0x94,0,0,\"Kodak\",\"C330\",3160 },",
          "13964:     {  2247168,1232, 912, 0, 0,16, 0, 0,0x00,0,0,\"Kodak\",\"C330\" },",
          "13965:     {  3370752,1232, 912, 0, 0,16, 0, 0,0x00,0,0,\"Kodak\",\"C330\" },",
          "13966:     {  6163328,2864,2152, 0, 0, 0, 0, 0,0x94,0,0,\"Kodak\",\"C603\" },",
          "13967:     {  6166488,2864,2152, 0, 0, 0, 0, 0,0x94,0,0,\"Kodak\",\"C603\",3160 },",
          "13968:     {   460800, 640, 480, 0, 0, 0, 0, 0,0x00,0,0,\"Kodak\",\"C603\" },",
          "13969:     {  9116448,2848,2134, 0, 0, 0, 0, 0,0x00,0,0,\"Kodak\",\"C603\" },",
          "13970:     { 12241200,4040,3030, 2, 0, 0,13, 0,0x49,0,0,\"Kodak\",\"12MP\" },",
          "13971:     { 12272756,4040,3030, 2, 0, 0,13, 0,0x49,0,0,\"Kodak\",\"12MP\",31556 },",
          "13972:     { 18000000,4000,3000, 0, 0, 0, 0, 0,0x00,0,0,\"Kodak\",\"12MP\" },",
          "13973:     {   614400, 640, 480, 0, 3, 0, 0,64,0x94,0,0,\"Kodak\",\"KAI-0340\" },",
          "13974:     { 15360000,3200,2400, 0, 0, 0, 0,96,0x16,0,0,\"Lenovo\",\"A820\" },",
          "13975:     {  3884928,1608,1207, 0, 0, 0, 0,96,0x16,0,0,\"Micron\",\"2010\",3212 },",
          "13976:     {  1138688,1534, 986, 0, 0, 0, 0, 0,0x61,0,0,\"Minolta\",\"RD175\",513 },",
          "13977:     {  1581060,1305, 969, 0, 0,18, 6, 6,0x1e,4,1,\"Nikon\",\"E900\" },",
          "13978:     {  2465792,1638,1204, 0, 0,22, 1, 6,0x4b,5,1,\"Nikon\",\"E950\" },",
          "13979:     {  2940928,1616,1213, 0, 0, 0, 7,30,0x94,0,1,\"Nikon\",\"E2100\" },",
          "13980:     {  4771840,2064,1541, 0, 0, 0, 1, 6,0xe1,0,1,\"Nikon\",\"E990\" },",
          "13981:     {  4775936,2064,1542, 0, 0, 0, 0,30,0x94,0,1,\"Nikon\",\"E3700\" },",
          "13982:     {  5865472,2288,1709, 0, 0, 0, 1, 6,0xb4,0,1,\"Nikon\",\"E4500\" },",
          "13983:     {  5869568,2288,1710, 0, 0, 0, 0, 6,0x16,0,1,\"Nikon\",\"E4300\" },",
          "13984:     {  7438336,2576,1925, 0, 0, 0, 1, 6,0xb4,0,1,\"Nikon\",\"E5000\" },",
          "13985:     {  8998912,2832,2118, 0, 0, 0, 0,30,0x94,7,1,\"Nikon\",\"COOLPIX S6\" },",
          "13986:     {  5939200,2304,1718, 0, 0, 0, 0,30,0x16,0,0,\"Olympus\",\"C770UZ\" },",
          "13987:     {  3178560,2064,1540, 0, 0, 0, 0, 0,0x94,0,1,\"Pentax\",\"Optio S\" },",
          "13988:     {  4841984,2090,1544, 0, 0,22, 0, 0,0x94,7,1,\"Pentax\",\"Optio S\" },",
          "13989:     {  6114240,2346,1737, 0, 0,22, 0, 0,0x94,7,1,\"Pentax\",\"Optio S4\" },",
          "13990:     { 10702848,3072,2322, 0, 0, 0,21,30,0x94,0,1,\"Pentax\",\"Optio 750Z\" },",
          "13991:     {  4147200,1920,1080, 0, 0, 0, 0, 0,0x49,0,0,\"Photron\",\"BC2-HD\" },",
          "13992:     {  4151666,1920,1080, 0, 0, 0, 0, 0,0x49,0,0,\"Photron\",\"BC2-HD\",8 },",
          "13993:     { 13248000,2208,3000, 0, 0, 0, 0,13,0x61,0,0,\"Pixelink\",\"A782\" },",
          "13994:     {  6291456,2048,1536, 0, 0, 0, 0,96,0x61,0,0,\"RoverShot\",\"3320AF\" },",
          "13995:     {   311696, 644, 484, 0, 0, 0, 0, 0,0x16,0,8,\"ST Micro\",\"STV680 VGA\" },",
          "13996:     { 16098048,3288,2448, 0, 0,24, 0, 9,0x94,0,1,\"Samsung\",\"S85\" },",
          "13997:     { 16215552,3312,2448, 0, 0,48, 0, 9,0x94,0,1,\"Samsung\",\"S85\" },",
          "13998:     { 20487168,3648,2808, 0, 0, 0, 0,13,0x94,5,1,\"Samsung\",\"WB550\" },",
          "13999:     { 24000000,4000,3000, 0, 0, 0, 0,13,0x94,5,1,\"Samsung\",\"WB550\" },",
          "14000:     { 12582980,3072,2048, 0, 0, 0, 0,33,0x61,0,0,\"Sinar\",\"\",68 },",
          "14001:     { 33292868,4080,4080, 0, 0, 0, 0,33,0x61,0,0,\"Sinar\",\"\",68 },",
          "14002:     { 44390468,4080,5440, 0, 0, 0, 0,33,0x61,0,0,\"Sinar\",\"\",68 },",
          "14003:     {  1409024,1376,1024, 0, 0, 1, 0, 0,0x49,0,0,\"Sony\",\"XCD-SX910CR\" },",
          "14004:     {  2818048,1376,1024, 0, 0, 1, 0,97,0x49,0,0,\"Sony\",\"XCD-SX910CR\" },",
          "14005:   };",
          "14006: #ifdef LIBRAW_LIBRARY_BUILD",
          "14007:     libraw_custom_camera_t",
          "14008:       table[64 + sizeof(const_table)/sizeof(const_table[0])];",
          "14009: #endif",
          "14011:   static const char *corp[] =",
          "14012:     { \"AgfaPhoto\", \"Canon\", \"Casio\", \"Epson\", \"Fujifilm\",",
          "14013:       \"Mamiya\", \"Minolta\", \"Motorola\", \"Kodak\", \"Konica\", \"Leica\",",
          "14014:       \"Nikon\", \"Nokia\", \"Olympus\", \"Pentax\", \"Phase One\", \"Ricoh\",",
          "14015:       \"Samsung\", \"Sigma\", \"Sinar\", \"Sony\" };",
          "14021:   int hlen, flen, fsize, zero_fsize=1, i, c;",
          "14025:   unsigned camera_count = parse_custom_cameras(64,table,imgdata.params.custom_camera_strings);",
          "14026:   for(int q = 0; q < sizeof(const_table)/sizeof(const_table[0]); q++)",
          "14027:  memmove(&table[q+camera_count],&const_table[q],sizeof(const_table[0]));",
          "14028:   camera_count += sizeof(const_table)/sizeof(const_table[0]);",
          "14037:   memset (tiff_ifd, 0, sizeof tiff_ifd);",
          "14038:   memset (gpsdata, 0, sizeof gpsdata);",
          "14039:   memset (cblack, 0, sizeof cblack);",
          "14040:   memset (white, 0, sizeof white);",
          "14041:   memset (mask, 0, sizeof mask);",
          "",
          "[Added Lines]",
          "14716:       {3130, 1743, 4, 0, -6, 0},    {3130, 2055, 4, 0, -6, 0},      {3130, 2319, 4, 0, -6, 0},",
          "14717:       {3170, 2103, 18, 0, -42, 20}, {3170, 2367, 18, 13, -42, -21}, {3177, 2367, 0, 0, -1, 0},",
          "14718:       {3304, 2458, 0, 0, -1, 0},    {3330, 2463, 9, 0, -5, 0},      {3330, 2479, 9, 0, -17, 4},",
          "14719:       {3370, 1899, 15, 0, -44, 20}, {3370, 2235, 15, 0, -44, 20},   {3370, 2511, 15, 10, -44, -21},",
          "14720:       {3690, 2751, 3, 0, -8, -3},   {3710, 2751, 0, 0, -3, 0},      {3724, 2450, 0, 0, 0, -2},",
          "14721:       {3770, 2487, 17, 0, -44, 19}, {3770, 2799, 17, 15, -44, -19}, {3880, 2170, 6, 0, -6, 0},",
          "14722:       {4060, 3018, 0, 0, 0, -2},    {4290, 2391, 3, 0, -8, -1},     {4330, 2439, 17, 15, -44, -19},",
          "14723:       {4508, 2962, 0, 0, -3, -4},   {4508, 3330, 0, 0, -3, -6},",
          "14726:       {1944, 1416, 0, 0, 48, 0},",
          "14727:       {2144, 1560, 4, 8, 52, 2, 0, 0, 0, 25},",
          "14728:       {2224, 1456, 48, 6, 0, 2},",
          "14729:       {2376, 1728, 12, 6, 52, 2},",
          "14730:       {2672, 1968, 12, 6, 44, 2},",
          "14731:       {3152, 2068, 64, 12, 0, 0, 16},",
          "14732:       {3160, 2344, 44, 12, 4, 4},",
          "14733:       {3344, 2484, 4, 6, 52, 6},",
          "14734:       {3516, 2328, 42, 14, 0, 0},",
          "14735:       {3596, 2360, 74, 12, 0, 0},",
          "14736:       {3744, 2784, 52, 12, 8, 12},",
          "14737:       {3944, 2622, 30, 18, 6, 2},",
          "14738:       {3948, 2622, 42, 18, 0, 2},",
          "14739:       {3984, 2622, 76, 20, 0, 2, 14},",
          "14740:       {4104, 3048, 48, 12, 24, 12},",
          "14741:       {4116, 2178, 4, 2, 0, 0},",
          "14742:       {4152, 2772, 192, 12, 0, 0},",
          "14743:       {4160, 3124, 104, 11, 8, 65},",
          "14744:       {4176, 3062, 96, 17, 8, 0, 0, 16, 0, 7, 0x49},",
          "14745:       {4192, 3062, 96, 17, 24, 0, 0, 16, 0, 0, 0x49},",
          "14746:       {4312, 2876, 22, 18, 0, 2},",
          "14747:       {4352, 2874, 62, 18, 0, 0},",
          "14748:       {4476, 2954, 90, 34, 0, 0},",
          "14749:       {4480, 3348, 12, 10, 36, 12, 0, 0, 0, 18, 0x49},",
          "14750:       {4480, 3366, 80, 50, 0, 0},",
          "14751:       {4496, 3366, 80, 50, 12, 0},",
          "14752:       {4768, 3516, 96, 16, 0, 0, 0, 16},",
          "14753:       {4832, 3204, 62, 26, 0, 0},",
          "14754:       {4832, 3228, 62, 51, 0, 0},",
          "14755:       {5108, 3349, 98, 13, 0, 0},",
          "14756:       {5120, 3318, 142, 45, 62, 0},",
          "14758:       {5344, 3516, 142, 51, 0, 0},",
          "14759:       {5344, 3584, 126, 100, 0, 2},",
          "14760:       {5360, 3516, 158, 51, 0, 0},",
          "14761:       {5568, 3708, 72, 38, 0, 0},",
          "14762:       {5632, 3710, 96, 17, 0, 0, 0, 16, 0, 0, 0x49},",
          "14763:       {5712, 3774, 62, 20, 10, 2},",
          "14764:       {5792, 3804, 158, 51, 0, 0},",
          "14765:       {5920, 3950, 122, 80, 2, 0},",
          "14769:       {8896, 5920, 160, 64, 0, 0},",
          "14771:   static const struct",
          "14772:   {",
          "14775:   } unique[] =",
          "14776:       {",
          "14777:           {0x001, \"EOS-1D\"},",
          "14778:           {0x167, \"EOS-1DS\"},",
          "14779:           {0x168, \"EOS 10D\"},",
          "14780:           {0x169, \"EOS-1D Mark III\"},",
          "14781:           {0x170, \"EOS 300D\"},",
          "14782:           {0x174, \"EOS-1D Mark II\"},",
          "14783:           {0x175, \"EOS 20D\"},",
          "14784:           {0x176, \"EOS 450D\"},",
          "14785:           {0x188, \"EOS-1Ds Mark II\"},",
          "14786:           {0x189, \"EOS 350D\"},",
          "14787:           {0x190, \"EOS 40D\"},",
          "14788:           {0x213, \"EOS 5D\"},",
          "14789:           {0x215, \"EOS-1Ds Mark III\"},",
          "14790:           {0x218, \"EOS 5D Mark II\"},",
          "14791:           {0x232, \"EOS-1D Mark II N\"},",
          "14792:           {0x234, \"EOS 30D\"},",
          "14793:           {0x236, \"EOS 400D\"},",
          "14794:           {0x250, \"EOS 7D\"},",
          "14795:           {0x252, \"EOS 500D\"},",
          "14796:           {0x254, \"EOS 1000D\"},",
          "14797:           {0x261, \"EOS 50D\"},",
          "14798:           {0x269, \"EOS-1D X\"},",
          "14799:           {0x270, \"EOS 550D\"},",
          "14800:           {0x281, \"EOS-1D Mark IV\"},",
          "14801:           {0x285, \"EOS 5D Mark III\"},",
          "14802:           {0x286, \"EOS 600D\"},",
          "14803:           {0x287, \"EOS 60D\"},",
          "14804:           {0x288, \"EOS 1100D\"},",
          "14805:           {0x289, \"EOS 7D Mark II\"},",
          "14806:           {0x301, \"EOS 650D\"},",
          "14807:           {0x302, \"EOS 6D\"},",
          "14808:           {0x324, \"EOS-1D C\"},",
          "14809:           {0x325, \"EOS 70D\"},",
          "14810:           {0x326, \"EOS 700D\"},",
          "14811:           {0x327, \"EOS 1200D\"},",
          "14812:           {0x328, \"EOS-1D X Mark II\"},",
          "14813:           {0x331, \"EOS M\"},",
          "14814:           {0x335, \"EOS M2\"},",
          "14818:           {0x346, \"EOS 100D\"},",
          "14819:           {0x347, \"EOS 760D\"},",
          "14820:           {0x349, \"EOS 5D Mark IV\"},",
          "14821:           {0x350, \"EOS 80D\"},",
          "14822:           {0x382, \"EOS 5DS\"},",
          "14823:           {0x393, \"EOS 750D\"},",
          "14824:           {0x401, \"EOS 5DS R\"},",
          "14825:           {0x404, \"EOS 1300D\"},",
          "14826:       },",
          "14827:     sonique[] = {",
          "14828:         {0x002, \"DSC-R1\"},      {0x100, \"DSLR-A100\"},   {0x101, \"DSLR-A900\"},  {0x102, \"DSLR-A700\"},",
          "14829:         {0x103, \"DSLR-A200\"},   {0x104, \"DSLR-A350\"},   {0x105, \"DSLR-A300\"},  {0x106, \"DSLR-A900\"},",
          "14830:         {0x107, \"DSLR-A380\"},   {0x108, \"DSLR-A330\"},   {0x109, \"DSLR-A230\"},  {0x10a, \"DSLR-A290\"},",
          "14831:         {0x10d, \"DSLR-A850\"},   {0x10e, \"DSLR-A850\"},   {0x111, \"DSLR-A550\"},  {0x112, \"DSLR-A500\"},",
          "14832:         {0x113, \"DSLR-A450\"},   {0x116, \"NEX-5\"},       {0x117, \"NEX-3\"},      {0x118, \"SLT-A33\"},",
          "14833:         {0x119, \"SLT-A55V\"},    {0x11a, \"DSLR-A560\"},   {0x11b, \"DSLR-A580\"},  {0x11c, \"NEX-C3\"},",
          "14834:         {0x11d, \"SLT-A35\"},     {0x11e, \"SLT-A65V\"},    {0x11f, \"SLT-A77V\"},   {0x120, \"NEX-5N\"},",
          "14835:         {0x121, \"NEX-7\"},       {0x122, \"NEX-VG20E\"},   {0x123, \"SLT-A37\"},    {0x124, \"SLT-A57\"},",
          "14836:         {0x125, \"NEX-F3\"},      {0x126, \"SLT-A99V\"},    {0x127, \"NEX-6\"},      {0x128, \"NEX-5R\"},",
          "14837:         {0x129, \"DSC-RX100\"},   {0x12a, \"DSC-RX1\"},     {0x12b, \"NEX-VG900\"},  {0x12c, \"NEX-VG30E\"},",
          "14838:         {0x12e, \"ILCE-3000\"},   {0x12f, \"SLT-A58\"},     {0x131, \"NEX-3N\"},     {0x132, \"ILCE-7\"},",
          "14839:         {0x133, \"NEX-5T\"},      {0x134, \"DSC-RX100M2\"}, {0x135, \"DSC-RX10\"},   {0x136, \"DSC-RX1R\"},",
          "14840:         {0x137, \"ILCE-7R\"},     {0x138, \"ILCE-6000\"},   {0x139, \"ILCE-5000\"},  {0x13d, \"DSC-RX100M3\"},",
          "14841:         {0x13e, \"ILCE-7S\"},     {0x13f, \"ILCA-77M2\"},   {0x153, \"ILCE-5100\"},  {0x154, \"ILCE-7M2\"},",
          "14842:         {0x155, \"DSC-RX100M4\"}, {0x156, \"DSC-RX10M2\"},  {0x158, \"DSC-RX1RM2\"}, {0x15a, \"ILCE-QX1\"},",
          "14843:         {0x15b, \"ILCE-7RM2\"},   {0x15e, \"ILCE-7SM2\"},   {0x161, \"ILCA-68\"},    {0x162, \"ILCA-99M2\"},",
          "14844:         {0x163, \"DSC-RX10M3\"},  {0x164, \"DSC-RX100M5\"}, {0x165, \"ILCE-6300\"},  {0x168, \"ILCE-6500\"},",
          "14845:     };",
          "14847: #ifdef LIBRAW_LIBRARY_BUILD",
          "14848:   static const libraw_custom_camera_t const_table[]",
          "14850:   static const struct",
          "14851:   {",
          "14857:   } table[]",
          "14858: #endif",
          "14859:       = {",
          "14860:           {786432, 1024, 768, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-080C\"},",
          "14861:           {1447680, 1392, 1040, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-145C\"},",
          "14862:           {1920000, 1600, 1200, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-201C\"},",
          "14863:           {5067304, 2588, 1958, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-510C\"},",
          "14864:           {5067316, 2588, 1958, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-510C\", 12},",
          "14865:           {10134608, 2588, 1958, 0, 0, 0, 0, 9, 0x94, 0, 0, \"AVT\", \"F-510C\"},",
          "14866:           {10134620, 2588, 1958, 0, 0, 0, 0, 9, 0x94, 0, 0, \"AVT\", \"F-510C\", 12},",
          "14867:           {16157136, 3272, 2469, 0, 0, 0, 0, 9, 0x94, 0, 0, \"AVT\", \"F-810C\"},",
          "14868:           {15980544, 3264, 2448, 0, 0, 0, 0, 8, 0x61, 0, 1, \"AgfaPhoto\", \"DC-833m\"},",
          "14869:           {9631728, 2532, 1902, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Alcatel\", \"5035D\"},",
          "14870:           {31850496, 4608, 3456, 0, 0, 0, 0, 0, 0x94, 0, 0, \"GITUP\", \"GIT2 4:3\"},",
          "14871:           {23887872, 4608, 2592, 0, 0, 0, 0, 0, 0x94, 0, 0, \"GITUP\", \"GIT2 16:9\"},",
          "14874:           {1540857, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"Samsung\", \"S3\"},",
          "14875:           {2658304, 1212, 1096, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3FrontMipi\"},",
          "14876:           {2842624, 1296, 1096, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3FrontQCOM\"},",
          "14877:           {2969600, 1976, 1200, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Xiaomi\", \"MI3wMipi\"},",
          "14878:           {3170304, 1976, 1200, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Xiaomi\", \"MI3wQCOM\"},",
          "14879:           {3763584, 1584, 1184, 0, 0, 0, 0, 96, 0x61, 0, 0, \"I_Mobile\", \"I_StyleQ6\"},",
          "14880:           {5107712, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"UltraPixel1\"},",
          "14881:           {5382640, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"UltraPixel2\"},",
          "14882:           {5664912, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"4688\"},",
          "14883:           {5664912, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"4688\"},",
          "14884:           {5364240, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"4688\"},",
          "14885:           {6299648, 2592, 1944, 0, 0, 0, 0, 1, 0x16, 0, 0, \"OmniVisi\", \"OV5648\"},",
          "14886:           {6721536, 2592, 1944, 0, 0, 0, 0, 0, 0x16, 0, 0, \"OmniVisi\", \"OV56482\"},",
          "14887:           {6746112, 2592, 1944, 0, 0, 0, 0, 0, 0x16, 0, 0, \"HTC\", \"OneSV\"},",
          "14888:           {9631728, 2532, 1902, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Sony\", \"5mp\"},",
          "14889:           {9830400, 2560, 1920, 0, 0, 0, 0, 96, 0x61, 0, 0, \"NGM\", \"ForwardArt\"},",
          "14890:           {10186752, 3264, 2448, 0, 0, 0, 0, 1, 0x94, 0, 0, \"Sony\", \"IMX219-mipi 8mp\"},",
          "14891:           {10223360, 2608, 1944, 0, 0, 0, 0, 96, 0x16, 0, 0, \"Sony\", \"IMX\"},",
          "14892:           {10782464, 3282, 2448, 0, 0, 0, 0, 0, 0x16, 0, 0, \"HTC\", \"MyTouch4GSlide\"},",
          "14893:           {10788864, 3282, 2448, 0, 0, 0, 0, 0, 0x16, 0, 0, \"Xperia\", \"L\"},",
          "14894:           {15967488, 3264, 2446, 0, 0, 0, 0, 96, 0x16, 0, 0, \"OmniVison\", \"OV8850\"},",
          "14895:           {16224256, 4208, 3082, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3MipiL\"},",
          "14896:           {16424960, 4208, 3120, 0, 0, 0, 0, 1, 0x16, 0, 0, \"IMX135\", \"MipiL\"},",
          "14897:           {17326080, 4164, 3120, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3LQCom\"},",
          "14898:           {17522688, 4212, 3120, 0, 0, 0, 0, 0, 0x16, 0, 0, \"Sony\", \"IMX135-QCOM\"},",
          "14899:           {19906560, 4608, 3456, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Gione\", \"E7mipi\"},",
          "14900:           {19976192, 5312, 2988, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G4\"},",
          "14901:           {20389888, 4632, 3480, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Xiaomi\", \"RedmiNote3Pro\"},",
          "14902:           {20500480, 4656, 3496, 0, 0, 0, 0, 1, 0x94, 0, 0, \"Sony\", \"IMX298-mipi 16mp\"},",
          "14903:           {21233664, 4608, 3456, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Gione\", \"E7qcom\"},",
          "14904:           {26023936, 4192, 3104, 0, 0, 0, 0, 96, 0x94, 0, 0, \"THL\", \"5000\"},",
          "14905:           {26257920, 4208, 3120, 0, 0, 0, 0, 96, 0x94, 0, 0, \"Sony\", \"IMX214\"},",
          "14906:           {26357760, 4224, 3120, 0, 0, 0, 0, 96, 0x61, 0, 0, \"OV\", \"13860\"},",
          "14907:           {41312256, 5248, 3936, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Meizu\", \"MX4\"},",
          "14908:           {42923008, 5344, 4016, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Sony\", \"IMX230\"},",
          "14910:           {20137344, 3664, 2748, 0, 0, 0, 0, 0x40, 0x49, 0, 0, \"Aptina\", \"MT9J003\", 0xffff},",
          "14911:           {2868726, 1384, 1036, 0, 0, 0, 0, 64, 0x49, 0, 8, \"Baumer\", \"TXG14\", 1078},",
          "14912:           {5298000, 2400, 1766, 12, 12, 44, 2, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SD300\"},",
          "14913:           {6553440, 2664, 1968, 4, 4, 44, 4, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A460\"},",
          "14914:           {6573120, 2672, 1968, 12, 8, 44, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A610\"},",
          "14915:           {6653280, 2672, 1992, 10, 6, 42, 2, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A530\"},",
          "14916:           {7710960, 2888, 2136, 44, 8, 4, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot S3 IS\"},",
          "14917:           {9219600, 3152, 2340, 36, 12, 4, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A620\"},",
          "14918:           {9243240, 3152, 2346, 12, 7, 44, 13, 40, 0x49, 0, 2, \"Canon\", \"PowerShot A470\"},",
          "14919:           {10341600, 3336, 2480, 6, 5, 32, 3, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A720 IS\"},",
          "14920:           {10383120, 3344, 2484, 12, 6, 44, 6, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A630\"},",
          "14921:           {12945240, 3736, 2772, 12, 6, 52, 6, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A640\"},",
          "14922:           {15636240, 4104, 3048, 48, 12, 24, 12, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A650\"},",
          "14923:           {15467760, 3720, 2772, 6, 12, 30, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX110 IS\"},",
          "14924:           {15534576, 3728, 2778, 12, 9, 44, 9, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX120 IS\"},",
          "14925:           {18653760, 4080, 3048, 24, 12, 24, 12, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX20 IS\"},",
          "14926:           {19131120, 4168, 3060, 92, 16, 4, 1, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX220 HS\"},",
          "14927:           {21936096, 4464, 3276, 25, 10, 73, 12, 40, 0x16, 0, 2, \"Canon\", \"PowerShot SX30 IS\"},",
          "14928:           {24724224, 4704, 3504, 8, 16, 56, 8, 40, 0x49, 0, 2, \"Canon\", \"PowerShot A3300 IS\"},",
          "14929:           {30858240, 5248, 3920, 8, 16, 56, 16, 40, 0x94, 0, 2, \"Canon\", \"IXUS 160\"},",
          "14930:           {1976352, 1632, 1211, 0, 2, 0, 1, 0, 0x94, 0, 1, \"Casio\", \"QV-2000UX\"},",
          "14931:           {3217760, 2080, 1547, 0, 0, 10, 1, 0, 0x94, 0, 1, \"Casio\", \"QV-3*00EX\"},",
          "14932:           {6218368, 2585, 1924, 0, 0, 9, 0, 0, 0x94, 0, 1, \"Casio\", \"QV-5700\"},",
          "14933:           {7816704, 2867, 2181, 0, 0, 34, 36, 0, 0x16, 0, 1, \"Casio\", \"EX-Z60\"},",
          "14934:           {2937856, 1621, 1208, 0, 0, 1, 0, 0, 0x94, 7, 13, \"Casio\", \"EX-S20\"},",
          "14935:           {4948608, 2090, 1578, 0, 0, 32, 34, 0, 0x94, 7, 1, \"Casio\", \"EX-S100\"},",
          "14936:           {6054400, 2346, 1720, 2, 0, 32, 0, 0, 0x94, 7, 1, \"Casio\", \"QV-R41\"},",
          "14937:           {7426656, 2568, 1928, 0, 0, 0, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-P505\"},",
          "14938:           {7530816, 2602, 1929, 0, 0, 22, 0, 0, 0x94, 7, 1, \"Casio\", \"QV-R51\"},",
          "14939:           {7542528, 2602, 1932, 0, 0, 32, 0, 0, 0x94, 7, 1, \"Casio\", \"EX-Z50\"},",
          "14940:           {7562048, 2602, 1937, 0, 0, 25, 0, 0, 0x16, 7, 1, \"Casio\", \"EX-Z500\"},",
          "14941:           {7753344, 2602, 1986, 0, 0, 32, 26, 0, 0x94, 7, 1, \"Casio\", \"EX-Z55\"},",
          "14942:           {9313536, 2858, 2172, 0, 0, 14, 30, 0, 0x94, 7, 1, \"Casio\", \"EX-P600\"},",
          "14943:           {10834368, 3114, 2319, 0, 0, 27, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-Z750\"},",
          "14944:           {10843712, 3114, 2321, 0, 0, 25, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-Z75\"},",
          "14945:           {10979200, 3114, 2350, 0, 0, 32, 32, 0, 0x94, 7, 1, \"Casio\", \"EX-P700\"},",
          "14946:           {12310144, 3285, 2498, 0, 0, 6, 30, 0, 0x94, 0, 1, \"Casio\", \"EX-Z850\"},",
          "14947:           {12489984, 3328, 2502, 0, 0, 47, 35, 0, 0x94, 0, 1, \"Casio\", \"EX-Z8\"},",
          "14948:           {15499264, 3754, 2752, 0, 0, 82, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-Z1050\"},",
          "14949:           {18702336, 4096, 3044, 0, 0, 24, 0, 80, 0x94, 7, 1, \"Casio\", \"EX-ZR100\"},",
          "14950:           {7684000, 2260, 1700, 0, 0, 0, 0, 13, 0x94, 0, 1, \"Casio\", \"QV-4000\"},",
          "14951:           {787456, 1024, 769, 0, 1, 0, 0, 0, 0x49, 0, 0, \"Creative\", \"PC-CAM 600\"},",
          "14952:           {28829184, 4384, 3288, 0, 0, 0, 0, 36, 0x61, 0, 0, \"DJI\"},",
          "14953:           {15151104, 4608, 3288, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Matrix\"},",
          "14954:           {3840000, 1600, 1200, 0, 0, 0, 0, 65, 0x49, 0, 0, \"Foculus\", \"531C\"},",
          "14955:           {307200, 640, 480, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Generic\"},",
          "14956:           {62464, 256, 244, 1, 1, 6, 1, 0, 0x8d, 0, 0, \"Kodak\", \"DC20\"},",
          "14957:           {124928, 512, 244, 1, 1, 10, 1, 0, 0x8d, 0, 0, \"Kodak\", \"DC20\"},",
          "14958:           {1652736, 1536, 1076, 0, 52, 0, 0, 0, 0x61, 0, 0, \"Kodak\", \"DCS200\"},",
          "14959:           {4159302, 2338, 1779, 1, 33, 1, 2, 0, 0x94, 0, 0, \"Kodak\", \"C330\"},",
          "14960:           {4162462, 2338, 1779, 1, 33, 1, 2, 0, 0x94, 0, 0, \"Kodak\", \"C330\", 3160},",
          "14961:           {2247168, 1232, 912, 0, 0, 16, 0, 0, 0x00, 0, 0, \"Kodak\", \"C330\"},",
          "14962:           {3370752, 1232, 912, 0, 0, 16, 0, 0, 0x00, 0, 0, \"Kodak\", \"C330\"},",
          "14963:           {6163328, 2864, 2152, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Kodak\", \"C603\"},",
          "14964:           {6166488, 2864, 2152, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Kodak\", \"C603\", 3160},",
          "14965:           {460800, 640, 480, 0, 0, 0, 0, 0, 0x00, 0, 0, \"Kodak\", \"C603\"},",
          "14966:           {9116448, 2848, 2134, 0, 0, 0, 0, 0, 0x00, 0, 0, \"Kodak\", \"C603\"},",
          "14967:           {12241200, 4040, 3030, 2, 0, 0, 13, 0, 0x49, 0, 0, \"Kodak\", \"12MP\"},",
          "14968:           {12272756, 4040, 3030, 2, 0, 0, 13, 0, 0x49, 0, 0, \"Kodak\", \"12MP\", 31556},",
          "14969:           {18000000, 4000, 3000, 0, 0, 0, 0, 0, 0x00, 0, 0, \"Kodak\", \"12MP\"},",
          "14970:           {614400, 640, 480, 0, 3, 0, 0, 64, 0x94, 0, 0, \"Kodak\", \"KAI-0340\"},",
          "14971:           {15360000, 3200, 2400, 0, 0, 0, 0, 96, 0x16, 0, 0, \"Lenovo\", \"A820\"},",
          "14972:           {3884928, 1608, 1207, 0, 0, 0, 0, 96, 0x16, 0, 0, \"Micron\", \"2010\", 3212},",
          "14973:           {1138688, 1534, 986, 0, 0, 0, 0, 0, 0x61, 0, 0, \"Minolta\", \"RD175\", 513},",
          "14974:           {1581060, 1305, 969, 0, 0, 18, 6, 6, 0x1e, 4, 1, \"Nikon\", \"E900\"},",
          "14975:           {2465792, 1638, 1204, 0, 0, 22, 1, 6, 0x4b, 5, 1, \"Nikon\", \"E950\"},",
          "14976:           {2940928, 1616, 1213, 0, 0, 0, 7, 30, 0x94, 0, 1, \"Nikon\", \"E2100\"},",
          "14977:           {4771840, 2064, 1541, 0, 0, 0, 1, 6, 0xe1, 0, 1, \"Nikon\", \"E990\"},",
          "14978:           {4775936, 2064, 1542, 0, 0, 0, 0, 30, 0x94, 0, 1, \"Nikon\", \"E3700\"},",
          "14979:           {5865472, 2288, 1709, 0, 0, 0, 1, 6, 0xb4, 0, 1, \"Nikon\", \"E4500\"},",
          "14980:           {5869568, 2288, 1710, 0, 0, 0, 0, 6, 0x16, 0, 1, \"Nikon\", \"E4300\"},",
          "14981:           {7438336, 2576, 1925, 0, 0, 0, 1, 6, 0xb4, 0, 1, \"Nikon\", \"E5000\"},",
          "14982:           {8998912, 2832, 2118, 0, 0, 0, 0, 30, 0x94, 7, 1, \"Nikon\", \"COOLPIX S6\"},",
          "14983:           {5939200, 2304, 1718, 0, 0, 0, 0, 30, 0x16, 0, 0, \"Olympus\", \"C770UZ\"},",
          "14984:           {3178560, 2064, 1540, 0, 0, 0, 0, 0, 0x94, 0, 1, \"Pentax\", \"Optio S\"},",
          "14985:           {4841984, 2090, 1544, 0, 0, 22, 0, 0, 0x94, 7, 1, \"Pentax\", \"Optio S\"},",
          "14986:           {6114240, 2346, 1737, 0, 0, 22, 0, 0, 0x94, 7, 1, \"Pentax\", \"Optio S4\"},",
          "14987:           {10702848, 3072, 2322, 0, 0, 0, 21, 30, 0x94, 0, 1, \"Pentax\", \"Optio 750Z\"},",
          "14988:           {4147200, 1920, 1080, 0, 0, 0, 0, 0, 0x49, 0, 0, \"Photron\", \"BC2-HD\"},",
          "14989:           {4151666, 1920, 1080, 0, 0, 0, 0, 0, 0x49, 0, 0, \"Photron\", \"BC2-HD\", 8},",
          "14990:           {13248000, 2208, 3000, 0, 0, 0, 0, 13, 0x61, 0, 0, \"Pixelink\", \"A782\"},",
          "14991:           {6291456, 2048, 1536, 0, 0, 0, 0, 96, 0x61, 0, 0, \"RoverShot\", \"3320AF\"},",
          "14992:           {311696, 644, 484, 0, 0, 0, 0, 0, 0x16, 0, 8, \"ST Micro\", \"STV680 VGA\"},",
          "14993:           {16098048, 3288, 2448, 0, 0, 24, 0, 9, 0x94, 0, 1, \"Samsung\", \"S85\"},",
          "14994:           {16215552, 3312, 2448, 0, 0, 48, 0, 9, 0x94, 0, 1, \"Samsung\", \"S85\"},",
          "14995:           {20487168, 3648, 2808, 0, 0, 0, 0, 13, 0x94, 5, 1, \"Samsung\", \"WB550\"},",
          "14996:           {24000000, 4000, 3000, 0, 0, 0, 0, 13, 0x94, 5, 1, \"Samsung\", \"WB550\"},",
          "14997:           {12582980, 3072, 2048, 0, 0, 0, 0, 33, 0x61, 0, 0, \"Sinar\", \"\", 68},",
          "14998:           {33292868, 4080, 4080, 0, 0, 0, 0, 33, 0x61, 0, 0, \"Sinar\", \"\", 68},",
          "14999:           {44390468, 4080, 5440, 0, 0, 0, 0, 33, 0x61, 0, 0, \"Sinar\", \"\", 68},",
          "15000:           {1409024, 1376, 1024, 0, 0, 1, 0, 0, 0x49, 0, 0, \"Sony\", \"XCD-SX910CR\"},",
          "15001:           {2818048, 1376, 1024, 0, 0, 1, 0, 97, 0x49, 0, 0, \"Sony\", \"XCD-SX910CR\"},",
          "15002:       };",
          "15003: #ifdef LIBRAW_LIBRARY_BUILD",
          "15004:   libraw_custom_camera_t table[64 + sizeof(const_table) / sizeof(const_table[0])];",
          "15005: #endif",
          "15007:   static const char *corp[] = {\"AgfaPhoto\", \"Canon\",     \"Casio\",  \"Epson\",   \"Fujifilm\", \"Mamiya\", \"Minolta\",",
          "15008:                                \"Motorola\",  \"Kodak\",     \"Konica\", \"Leica\",   \"Nikon\",    \"Nokia\",  \"Olympus\",",
          "15009:                                \"Pentax\",    \"Phase One\", \"Ricoh\",  \"Samsung\", \"Sigma\",    \"Sinar\",  \"Sony\"};",
          "15015:   int hlen, flen, fsize, zero_fsize = 1, i, c;",
          "15019:   unsigned camera_count = parse_custom_cameras(64, table, imgdata.params.custom_camera_strings);",
          "15020:   for (int q = 0; q < sizeof(const_table) / sizeof(const_table[0]); q++)",
          "15021:     memmove(&table[q + camera_count], &const_table[q], sizeof(const_table[0]));",
          "15022:   camera_count += sizeof(const_table) / sizeof(const_table[0]);",
          "15031:   memset(tiff_ifd, 0, sizeof tiff_ifd);",
          "15032:   memset(gpsdata, 0, sizeof gpsdata);",
          "15033:   memset(cblack, 0, sizeof cblack);",
          "15034:   memset(white, 0, sizeof white);",
          "15035:   memset(mask, 0, sizeof mask);",
          "",
          "---------------",
          "--- Hunk 103 ---",
          "[Context before]",
          "14049:   pixel_aspect = is_raw = raw_color = 1;",
          "14050:   tile_width = tile_length = 0;",
          "14054:     cam_mul[i] = i == 1;",
          "14055:     pre_mul[i] = i < 3;",
          "14056:     FORC3 cmatrix[c][i] = 0;",
          "14057:     FORC3 rgb_cam[c][i] = c == i;",
          "14058:   }",
          "14059:   colors = 3;",
          "14062:   order = get2();",
          "14063:   hlen = get4();",
          "14065: #ifdef LIBRAW_LIBRARY_BUILD",
          "14067:   libraw_internal_data.unpacker_data.lenRAFData = libraw_internal_data.unpacker_data.posRAFData = 0;",
          "14068: #else",
          "14070: #endif",
          "14072:   flen = fsize = ftell(ifp);",
          "14079:       data_offset = hlen;",
          "14080: #ifdef LIBRAW_LIBRARY_BUILD",
          "14081:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "14082:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "14083: #endif",
          "14085:       load_raw = &CLASS canon_load_raw;",
          "14090:     data_offset = 4 + get2();",
          "14092:     if (fgetc(ifp) != 0xff)",
          "14093:       parse_tiff(12);",
          "14094:     thumb_offset = 0;",
          "14099:     get_timestamp(1);",
          "14117:     FORC4 cam_mul[c ^ (c >> 1)] = get4();",
          "14121:     focal_len = get4();",
          "14122: #ifdef LIBRAW_LIBRARY_BUILD",
          "14126:     stmread(imgdata.lens.makernotes.Lens, 32, ifp);",
          "14127:     imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Contax_N;",
          "14128:     if (imgdata.lens.makernotes.Lens[0])",
          "14129:       imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Contax_N;",
          "14130: #endif",
          "14137:     load_raw = &CLASS quicktake_100_load_raw;",
          "14141:     load_raw = &CLASS kodak_radc_load_raw;",
          "14143: #ifdef LIBRAW_LIBRARY_BUILD",
          "14147: #endif",
          "14149:     thumb_offset = get4();",
          "14150:     thumb_length = get4();",
          "14156:       if (is_raw == 2 && shot_select)",
          "14158:     }",
          "14159:     load_raw = &CLASS unpacked_load_raw;",
          "14163:     apply_tiff();",
          "14166:     parse_riff();",
          "14170:     is_raw = 0;",
          "14176:     data_offset = get2();",
          "14177:     get2();",
          "14178:     raw_width = get2();",
          "14179:     raw_height = get2();",
          "14180:     load_raw = &CLASS nokia_load_raw;",
          "14181:     filters = 0x61616161;",
          "14184:     order = 0x4949;",
          "14186:     data_offset = get4();",
          "14187:     i = get4();",
          "14188:     width = get2();",
          "14189:     height = get2();",
          "14193:     }",
          "14195:     mask[0][3] = 1;",
          "14196:     filters = 0x61616161;",
          "14198:     order = 0x4949;",
          "14200:     width = get4();",
          "14201:     height = get4();",
          "14205:     data_offset = 4096;",
          "14206:     load_raw = &CLASS packed_load_raw;",
          "14207:     load_flags = 88;",
          "14208:     filters = 0x61616161;",
          "14210:     order = 0x4949;",
          "14213:     raw_height = get2();",
          "14217:     data_offset = 0x10000;",
          "14218:     load_raw = &CLASS canon_rmf_load_raw;",
          "14223:     parse_redcine();",
          "14224:     load_raw = &CLASS redcine_load_raw;",
          "14226:     filters = 0x49494949;",
          "14228:     parse_rollei();",
          "14230:     parse_sinar_ia();",
          "14232:     parse_minolta(0);",
          "14235: #ifdef LIBRAW_LIBRARY_BUILD",
          "14240: #endif",
          "14242: #else",
          "14245: #endif",
          "14246: #endif",
          "14249:     parse_cine();",
          "14251: #ifdef LIBRAW_LIBRARY_BUILD",
          "14253: #else",
          "14255: #endif",
          "14258: #ifdef LIBRAW_LIBRARY_BUILD",
          "14260:           {",
          "14263:           }",
          "14305:     parse_jpeg(0);",
          "14307:     int sz = ftell(ifp);",
          "14308: #ifdef LIBRAW_LIBRARY_BUILD",
          "14320:       thumb_offset = 0;",
          "14321:       thumb_length = sz - 0x9cb600 - 1;",
          "14329:       else",
          "14332:       data_offset = ftell(ifp) + 0x8000 - 0x20;",
          "14333:       parse_broadcom();",
          "14337:       thumb_offset = 0;",
          "14338:       thumb_length = sz - 0x61b800 - 1;",
          "14339: #else",
          "14345:       width = raw_width;",
          "14346:       raw_width = 2611;",
          "14347:       load_raw = &CLASS nokia_load_raw;",
          "14348:       filters = 0x16161616;",
          "14349: #endif",
          "14351:   }",
          "14352: #ifdef LIBRAW_LIBRARY_BUILD",
          "14354:   desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;",
          "14355: #endif",
          "14368: #else",
          "14371:   cp = model + strlen(model);",
          "14381:   desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;",
          "14439:     goto dng_skip;",
          "14440:   }",
          "14442:     if (!load_raw)",
          "14443:       load_raw = &CLASS lossless_jpeg_load_raw;",
          "14457:       left_margin = 8;",
          "14458:       top_margin = 16;",
          "14459:     }",
          "14460:   }",
          "14482:     if (!load_raw)",
          "14483:       load_raw = &CLASS packed_load_raw;",
          "14484:     if (model[0] == 'E')",
          "14485:       load_flags |= !data_offset << 2 | 2;",
          "14486:   }",
          "14492:     height = 480;",
          "14493:     top_margin = filters = 0;",
          "14495:   }",
          "14496:   if (!strcmp(make, \"Sony\") && raw_width > 3888 && !black && !cblack[0])",
          "14497:     black = 128 << (tiff_bps - 12);",
          "14502:     filters = 0;",
          "14503: #ifdef LIBRAW_DEMOSAIC_PACK_GPL2",
          "14505:       simple_coeff(0);",
          "14506: #endif",
          "14507:   }",
          "14509:   {",
          "14511:     {",
          "14519:     }",
          "14520:   }",
          "14525:     }",
          "14529:     }",
          "14530:     if (width == 7200 && height == 3888)",
          "14535:     filters = 0;",
          "14536:     tiff_samples = colors = 3;",
          "14537:     load_raw = &CLASS canon_sraw_load_raw;",
          "14539:     height = 613;",
          "14541:     raw_width = 896;",
          "14542:     colors = 4;",
          "14543:     filters = 0xe1e4e1e4;",
          "14544:     load_raw = &CLASS canon_600_load_raw;",
          "14547:     height = 773;",
          "14549:     raw_width = 992;",
          "14551:     filters = 0x1e4e1e4e;",
          "14552:     goto canon_a5;",
          "14556:     raw_width = 1320;",
          "14557:     filters = 0x1b4e4b1e;",
          "14558:     goto canon_a5;",
          "14560:     height = 1024;",
          "14562:     filters = 0x1e4b4e1b;",
          "14564:     colors = 4;",
          "14565:     tiff_bps = 10;",
          "14566:     load_raw = &CLASS packed_load_raw;",
          "14567:     load_flags = 40;",
          "14570:     colors = 4;",
          "14571:     filters = 0xb4b4b4b4;",
          "14575:     mask[1][3] = -4;",
          "14577:     left_margin = 92;",
          "14598:     top_margin = 17;",
          "14600:     filters = 0x61616161;",
          "14601:     black = curve[200];",
          "14606:     width -= 4;",
          "14607:     pixel_aspect = 0.5;",
          "14612:     height -= 3;",
          "14617:     width -= 4;",
          "14618:     left_margin = 2;",
          "14620:     width -= 28;",
          "14621:     left_margin = 6;",
          "14624:     width -= 42;",
          "14628:     width -= 44;",
          "14632:     width -= 46;",
          "14635:     width -= 52;",
          "14636:     left_margin = 2;",
          "14640:     width--;",
          "14642:     if (load_flags)",
          "14643:       raw_width = (width += 3) + 3;",
          "14645:     left_margin = 1;",
          "14646:     width -= 4;",
          "14647:     filters = 0x94949494;",
          "14649:     left_margin = 6;",
          "14650:     width -= 14;",
          "14655:     width -= 32;",
          "14672:     load_flags = 24;",
          "14673:     filters = 0x94949494;",
          "14675:       black = 255;",
          "14677:     height -= 2;",
          "14679:     simple_coeff(3);",
          "14680:     pre_mul[0] = 1.2085;",
          "14681:     pre_mul[1] = 1.0943;",
          "14682:     pre_mul[3] = 1.1103;",
          "14684:     cam_mul[0] *= 4;",
          "14685:     cam_mul[2] *= 4;",
          "14687:     if (!timestamp && nikon_e995())",
          "14690:       filters = 0xb4b4b4b4;",
          "14691:       simple_coeff(3);",
          "14692:       pre_mul[0] = 1.196;",
          "14693:       pre_mul[1] = 1.246;",
          "14694:       pre_mul[2] = 1.018;",
          "14695:     }",
          "14697:     if (!timestamp && !nikon_e2100())",
          "14700:       height -= 2;",
          "14701:       load_flags = 6;",
          "14702:       colors = 4;",
          "14703:       filters = 0x4b4b4b4b;",
          "14704:     }",
          "14708:       filters = 0x49494949;",
          "14710:       flip = 1;",
          "14711:       filters = 0x16161616;",
          "14712:     }",
          "14719:       }",
          "14721:     }",
          "14726:     }",
          "14731:       height -= (top_margin = 16);",
          "14732:       width -= (left_margin = 28);",
          "14733:       maximum = 0xf5c0;",
          "14735:       model[0] = 0;",
          "14736:     }",
          "14740:       height = 2144;",
          "14742:       flip = 6;",
          "14744:       maximum = (is_raw == 2 && shot_select) ? 0x2f00 : 0x3e00;",
          "14745:     top_margin = (raw_height - height) >> 2 << 1;",
          "14754:       width += 2;",
          "14755:       left_margin = 0;",
          "14756:       filters = 0x16161616;",
          "14757:     }",
          "14763:     if (filters == 9)",
          "14767:     height = 1712;",
          "14769:     raw_width = 2336;",
          "14770:     goto konica_400z;",
          "14772:     goto konica_510z;",
          "14774:     if (!load_raw && (maximum = 0xfff))",
          "14775:       load_raw = &CLASS unpacked_load_raw;",
          "14779:       tiff_bps = 12;",
          "14780:       load_raw = &CLASS packed_load_raw;",
          "14786:       load_raw = &CLASS packed_load_raw;",
          "14799:       }",
          "14800:       data_offset += 14;",
          "14801:       filters = 0x61616161;",
          "14803:       load_raw = &CLASS unpacked_load_raw;",
          "14804:       maximum = 0x3df;",
          "14805:       order = 0x4d4d;",
          "14806:     }",
          "14808:     load_raw = &CLASS unpacked_load_raw;",
          "14809:     data_error = -1;",
          "14811:     height -= 2;",
          "14813:     height -= top_margin = 8;",
          "14814:     width -= 2 * (left_margin = 8);",
          "14815:     load_flags = 32;",
          "14817:     top_margin = 24;",
          "14818:     left_margin = 64;",
          "14819:     width = 5472;",
          "14820:     height = 3648;",
          "14821:     filters = 0x61616161;",
          "14822:     colors = 3;",
          "14824:     height -= top_margin = 18;",
          "14825:     left_margin = raw_width - (width = 5536);",
          "14826:     if (raw_width != 5600)",
          "14827:       left_margin = top_margin = 0;",
          "14828:     filters = 0x61616161;",
          "14829:     colors = 3;",
          "14831:     order = 0x4949;",
          "14832:     height = 3694;",
          "14833:     top_margin = 2;",
          "14837:     height -= top_margin = 17;",
          "14838:     left_margin = 96;",
          "14839:     width = 5544;",
          "14840:     filters = 0x49494949;",
          "14842:     filters = 0x61616161;",
          "14843: #ifdef LIBRAW_LIBRARY_BUILD",
          "14845: #endif",
          "14848:     order = 0x4949;",
          "14849:     height -= 20;",
          "14850:     top_margin = 2;",
          "14852:       height -= 10;",
          "14854:       top_margin = 8;",
          "14855:     }",
          "14857:     order = 0x4949;",
          "14858:     height -= 3;",
          "14859:     top_margin = 2;",
          "14861:       height -= 28;",
          "14863:       top_margin = 8;",
          "14864:     }",
          "14868:     height = 3030;",
          "14870:     top_margin = 15;",
          "14872:     order = 0x4949;",
          "14873:     filters = 0x49494949;",
          "14874:     load_raw = &CLASS unpacked_load_raw;",
          "14876:     black = 16;",
          "14878:     height = raw_height - (top_margin = 2);",
          "14882:     if (load_raw == &CLASS lossless_jpeg_load_raw)",
          "14883:       load_raw = &CLASS hasselblad_load_raw;",
          "14885:       height = 5444;",
          "14888:       left_margin = 7;",
          "14889:       filters = 0x61616161;",
          "14896:       height -= 84;",
          "14899:       left_margin = 41;",
          "14900:       filters = 0x61616161;",
          "14903:     }",
          "14905:     {",
          "14911:     }",
          "14924:       else",
          "14936:       height -= (top_margin = 6);",
          "14937:       width -= (left_margin = 3) + 7;",
          "14938:       filters = 0x61616161;",
          "14963:       left_margin = 52;",
          "14964:       top_margin = 100;",
          "14965:       width = 8272;",
          "14966:       height = 6200;",
          "14967:       black = 256;",
          "14969:     }",
          "14973:     }",
          "14977:     maximum = 0x3fff;",
          "14979:     maximum = 0x3fff;",
          "14982:       maximum = 0x1fff;",
          "14985:       load_raw = &CLASS leaf_hdr_load_raw;",
          "14986:       raw_width = tile_width;",
          "14987:     }",
          "15011:       height -= 2 * (top_margin = 30);",
          "15012:       width -= 2 * (left_margin = 55);",
          "15013:       filters = 0x49494949;",
          "15016:       height -= 2 * (top_margin = 24);",
          "15017:       width -= 2 * (left_margin = 24);",
          "15018:       filters = 0x16161616;",
          "15019:     }",
          "15023:       load_raw = &CLASS panasonic_load_raw;",
          "15025:       load_raw = &CLASS unpacked_load_raw;",
          "15026:       load_flags = 4;",
          "15027:     }",
          "15028:     zero_is_bad = 1;",
          "15040:     height = 1718;",
          "15042:     filters = 0x16161616;",
          "15043:     load_raw = &CLASS packed_load_raw;",
          "15044:     load_flags = 30;",
          "15046:     height += height & 1;",
          "15051:     if (load_raw == &CLASS unpacked_load_raw)",
          "15052:       load_flags = 4;",
          "15053:     tiff_bps = 12;",
          "15056:       width -= 20;",
          "15060:       }",
          "15062:       width -= 14;",
          "15063:       maximum = 0xfff;",
          "15065:       width -= 30;",
          "15066:       if (load_raw == &CLASS unpacked_load_raw)",
          "15069:       thumb_length = flen - (thumb_offset = 0xa39800);",
          "15070:       thumb_height = 480;",
          "15073:       width -= 16;",
          "15074:     }",
          "15076:     height = 2047;",
          "15078:     filters = 0x61616161;",
          "15079:     data_offset = 0x1a00;",
          "15080:     load_raw = &CLASS packed_load_raw;",
          "15082:     width = 3288;",
          "15083:     left_margin = 5;",
          "15084:     mask[1][3] = -17;",
          "",
          "[Removed Lines]",
          "14053:   for (i=0; i < 4; i++) {",
          "14060:   for (i=0; i < 0x10000; i++) curve[i] = i;",
          "14064:   fseek (ifp, 0, SEEK_SET);",
          "14066:   fread (head, 1, 64, ifp);",
          "14069:   fread (head, 1, 32, ifp);",
          "14071:   fseek (ifp, 0, SEEK_END);",
          "14073:   if ((cp = (char *) memmem (head, 32, (char*)\"MMMM\", 4)) ||",
          "14074:       (cp = (char *) memmem (head, 32, (char*)\"IIII\", 4))) {",
          "14075:     parse_phase_one (cp-head);",
          "14076:     if (cp-head && parse_tiff(0)) apply_tiff();",
          "14077:   } else if (order == 0x4949 || order == 0x4d4d) {",
          "14078:     if (!memcmp (head+6,\"HEAPCCDR\",8)) {",
          "14084:       parse_ciff (hlen, flen-hlen, 0);",
          "14086:     } else if (parse_tiff(0)) apply_tiff();",
          "14087:   } else if (!memcmp (head,\"\\xff\\xd8\\xff\\xe1\",4) &&",
          "14088:       !memcmp (head+6,\"Exif\",4)) {",
          "14089:     fseek (ifp, 4, SEEK_SET);",
          "14091:     fseek (ifp, data_offset, SEEK_SET);",
          "14095:   } else if (!memcmp (head+25,\"ARECOYK\",7)) {",
          "14096:     strcpy (make, \"Contax\");",
          "14097:     strcpy (model,\"N Digital\");",
          "14098:     fseek (ifp, 33, SEEK_SET);",
          "14100:     fseek (ifp, 52, SEEK_SET);",
          "14101:     switch (get4()) {",
          "14102:       case  7: iso_speed = 25;  break;",
          "14103:       case  8: iso_speed = 32;  break;",
          "14104:       case  9: iso_speed = 40;  break;",
          "14105:       case 10: iso_speed = 50;  break;",
          "14106:       case 11: iso_speed = 64;  break;",
          "14107:       case 12: iso_speed = 80;  break;",
          "14108:       case 13: iso_speed = 100; break;",
          "14109:       case 14: iso_speed = 125; break;",
          "14110:       case 15: iso_speed = 160; break;",
          "14111:       case 16: iso_speed = 200; break;",
          "14112:       case 17: iso_speed = 250; break;",
          "14113:       case 18: iso_speed = 320; break;",
          "14114:       case 19: iso_speed = 400; break;",
          "14115:     }",
          "14116:     shutter = powf64(2.0f, (((float)get4())/8.0f)) / 16000.0f;",
          "14118:     fseek (ifp, 88, SEEK_SET);",
          "14119:     aperture = powf64(2.0f, ((float)get4())/16.0f);",
          "14120:     fseek (ifp, 112, SEEK_SET);",
          "14123:     fseek (ifp, 104, SEEK_SET);",
          "14124:     imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, ((float)get4())/16.0f);",
          "14125:     fseek (ifp, 124, SEEK_SET);",
          "14131:   } else if (!strcmp (head, \"PXN\")) {",
          "14132:     strcpy (make, \"Logitech\");",
          "14133:     strcpy (model,\"Fotoman Pixtura\");",
          "14134:   } else if (!strcmp (head, \"qktk\")) {",
          "14135:     strcpy (make, \"Apple\");",
          "14136:     strcpy (model,\"QuickTake 100\");",
          "14138:   } else if (!strcmp (head, \"qktn\")) {",
          "14139:     strcpy (make, \"Apple\");",
          "14140:     strcpy (model,\"QuickTake 150\");",
          "14142:   } else if (!memcmp (head,\"FUJIFILM\",8)) {",
          "14144:     strcpy(model, head+0x1c);",
          "14145:     memcpy(model2, head+0x3c, 4);",
          "14146:     model2[4]=0;",
          "14148:     fseek (ifp, 84, SEEK_SET);",
          "14151:     fseek (ifp, 92, SEEK_SET);",
          "14152:     parse_fuji (get4());",
          "14153:     if (thumb_offset > 120) {",
          "14154:       fseek (ifp, 120, SEEK_SET);",
          "14155:       is_raw += (i = get4())?1:0;",
          "14157:  parse_fuji (i);",
          "14160:     fseek (ifp, 100+28*(shot_select > 0), SEEK_SET);",
          "14161:     parse_tiff (data_offset = get4());",
          "14162:     parse_tiff (thumb_offset+12);",
          "14164:   } else if (!memcmp (head,\"RIFF\",4)) {",
          "14165:     fseek (ifp, 0, SEEK_SET);",
          "14167:   } else if (!memcmp (head+4,\"ftypqt   \",9)) {",
          "14168:     fseek (ifp, 0, SEEK_SET);",
          "14169:     parse_qt (fsize);",
          "14171:   } else if (!memcmp (head,\"\\0\\001\\0\\001\\0@\",6)) {",
          "14172:     fseek (ifp, 6, SEEK_SET);",
          "14173:     fread (make, 1, 8, ifp);",
          "14174:     fread (model, 1, 8, ifp);",
          "14175:     fread (model2, 1, 16, ifp);",
          "14182:   } else if (!memcmp (head,\"NOKIARAW\",8)) {",
          "14183:     strcpy (make, \"NOKIA\");",
          "14185:     fseek (ifp, 300, SEEK_SET);",
          "14190:     switch (tiff_bps = i*8 / (width * height)) {",
          "14191:       case  8: load_raw = &CLASS eight_bit_load_raw;  break;",
          "14192:       case 10: load_raw = &CLASS nokia_load_raw;",
          "14194:     raw_height = height + (top_margin = i / (width * tiff_bps/8) - height);",
          "14197:   } else if (!memcmp (head,\"ARRI\",4)) {",
          "14199:     fseek (ifp, 20, SEEK_SET);",
          "14202:     strcpy (make, \"ARRI\");",
          "14203:     fseek (ifp, 668, SEEK_SET);",
          "14204:     fread (model, 1, 64, ifp);",
          "14209:   } else if (!memcmp (head,\"XPDS\",4)) {",
          "14211:     fseek (ifp, 0x800, SEEK_SET);",
          "14212:     fread (make, 1, 41, ifp);",
          "14214:     raw_width  = get2();",
          "14215:     fseek (ifp, 56, SEEK_CUR);",
          "14216:     fread (model, 1, 30, ifp);",
          "14219:     gamma_curve (0, 12.25, 1, 1023);",
          "14220:   } else if (!memcmp (head+4,\"RED1\",4)) {",
          "14221:     strcpy (make, \"Red\");",
          "14222:     strcpy (model,\"One\");",
          "14225:     gamma_curve (1/2.4, 12.92, 1, 4095);",
          "14227:   } else if (!memcmp (head,\"DSC-Image\",9))",
          "14229:   else if (!memcmp (head,\"PWAD\",4))",
          "14231:   else if (!memcmp (head,\"\\0MRM\",4))",
          "14233:   else if (!memcmp (head,\"FOVb\",4))",
          "14234:     {",
          "14236: #ifdef  LIBRAW_DEMOSAIC_PACK_GPL2",
          "14237:       if(!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F))",
          "14238:         parse_foveon();",
          "14239:       else",
          "14241:         parse_x3f();",
          "14243: #ifdef  LIBRAW_DEMOSAIC_PACK_GPL2",
          "14244:       parse_foveon();",
          "14247:     }",
          "14248:   else if (!memcmp (head,\"CI\",2))",
          "14250:   if(make[0] == 0)",
          "14252:     for (zero_fsize=i=0; i < camera_count; i++)",
          "14254:     for (zero_fsize=i=0; i < sizeof table / sizeof *table; i++)",
          "14256:       if (fsize == table[i].fsize) {",
          "14257:  strcpy (make,  table[i].t_make );",
          "14259:         if (!strncmp(make, \"Canon\",5))",
          "14261:             imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "14262:             imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "14264: #endif",
          "14265:  strcpy (model, table[i].t_model);",
          "14266:  flip = table[i].flags >> 2;",
          "14267:  zero_is_bad = table[i].flags & 2;",
          "14268:  if (table[i].flags & 1)",
          "14269:    parse_external_jpeg();",
          "14270:  data_offset = table[i].offset == 0xffff?0:table[i].offset;",
          "14271:  raw_width   = table[i].rw;",
          "14272:  raw_height  = table[i].rh;",
          "14273:  left_margin = table[i].lm;",
          "14274:   top_margin = table[i].tm;",
          "14275:  width  = raw_width - left_margin - table[i].rm;",
          "14276:  height = raw_height - top_margin - table[i].bm;",
          "14277:  filters = 0x1010101 * table[i].cf;",
          "14278:  colors = 4 - !((filters & filters >> 1) & 0x5555);",
          "14279:  load_flags = table[i].lf;",
          "14280:  switch (tiff_bps = (fsize-data_offset)*8 / (raw_width*raw_height)) {",
          "14281:    case 6:",
          "14282:      load_raw = &CLASS minolta_rd175_load_raw;  break;",
          "14283:    case 8:",
          "14284:      load_raw = &CLASS eight_bit_load_raw;  break;",
          "14285:    case 10:",
          "14286:            if ((fsize-data_offset)/raw_height*3 >= raw_width*4) {",
          "14287:              load_raw = &CLASS android_loose_load_raw;  break;",
          "14288:            } else if (load_flags & 1) {",
          "14289:              load_raw = &CLASS android_tight_load_raw;  break;",
          "14290:            }",
          "14291:    case 12:",
          "14292:      load_flags |= 128;",
          "14293:      load_raw = &CLASS packed_load_raw;     break;",
          "14294:    case 16:",
          "14295:      order = 0x4949 | 0x404 * (load_flags & 1);",
          "14296:      tiff_bps -= load_flags >> 4;",
          "14297:      tiff_bps -= load_flags = load_flags >> 1 & 7;",
          "14298:      load_raw = table[i].offset == 0xffff ? &CLASS  unpacked_load_raw_reversed : &CLASS  unpacked_load_raw;",
          "14299:  }",
          "14300:  maximum = (1 << tiff_bps) - (1 << table[i].max);",
          "14301:       }",
          "14302:   if (zero_fsize) fsize = 0;",
          "14303:   if (make[0] == 0) parse_smal (0, flen);",
          "14304:   if (make[0] == 0) {",
          "14306:     fseek(ifp,0,SEEK_END);",
          "14309:     if (!strncmp(model,\"RP_imx219\",9) && sz >= 0x9cb600 &&",
          "14310:         !fseek (ifp, -0x9cb600, SEEK_END) &&",
          "14311:    fread (head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4)) {",
          "14312:  strcpy (make, \"Broadcom\");",
          "14313:  strcpy (model, \"RPi IMX219\");",
          "14314:  if (raw_height > raw_width) flip = 5;",
          "14315:  data_offset = ftell(ifp) + 0x8000 - 0x20;",
          "14316:  parse_broadcom();",
          "14317:  black = 66;",
          "14318:  maximum = 0x3ff;",
          "14319:  load_raw = &CLASS broadcom_load_raw;",
          "14322:     } else",
          "14323:       if (!(strncmp(model,\"ov5647\",6) && strncmp(model,\"RP_OV5647\",9)) && sz >= 0x61b800 &&",
          "14324:         !fseek (ifp, -0x61b800, SEEK_END) &&",
          "14325:    fread (head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4)) {",
          "14326:       strcpy (make, \"Broadcom\");",
          "14327:       if (!strncmp(model,\"ov5647\",6))",
          "14328:         strcpy (model, \"RPi OV5647 v.1\");",
          "14330:         strcpy (model, \"RPi OV5647 v.2\");",
          "14331:       if (raw_height > raw_width) flip = 5;",
          "14334:  black = 16;",
          "14335:  maximum = 0x3ff;",
          "14336:  load_raw = &CLASS broadcom_load_raw;",
          "14340:     if (!(strncmp(model,\"ov\",2) && strncmp(model,\"RP_OV\",5)) && sz>=6404096 &&",
          "14341:         !fseek (ifp, -6404096, SEEK_END) &&",
          "14342:    fread (head, 1, 32, ifp) && !strcmp(head,\"BRCMn\")) {",
          "14343:       strcpy (make, \"OmniVision\");",
          "14344:       data_offset = ftell(ifp) + 0x8000-32;",
          "14350:     } else is_raw = 0;",
          "14356:   for (i=0; i < sizeof corp / sizeof *corp; i++)",
          "14358:      strcpy (make, corp[i]);",
          "14359:   if ((!strncmp(make,\"Kodak\",5) || !strncmp(make,\"Leica\",5)) &&",
          "14360:  ((cp = strcasestr(model,\" DIGITAL CAMERA\")) ||",
          "14361:   (cp = strstr(model,\"FILE VERSION\"))))",
          "14363:   if (!strncasecmp(model,\"PENTAX\",6))",
          "14364:     strcpy (make, \"Pentax\");",
          "14365: #ifdef LIBRAW_LIBRARY_BUILD",
          "14366:   remove_trailing_spaces(make,sizeof(make));",
          "14367:   remove_trailing_spaces(model,sizeof(model));",
          "14370:   while (*--cp == ' ') *cp = 0;",
          "14372:   while (*--cp == ' ') *cp = 0;",
          "14373: #endif",
          "14375:   if (!strncasecmp (model, make, i) && model[i++] == ' ')",
          "14376:     memmove (model, model+i, 64-i);",
          "14377:   if (!strncmp (model,\"FinePix \",8))",
          "14378:     strcpy (model, model+8);",
          "14379:   if (!strncmp (model,\"Digital Camera \",15))",
          "14380:     strcpy (model, model+15);",
          "14382:   if (!is_raw) goto notraw;",
          "14384:   if (!height) height = raw_height;",
          "14385:   if (!width)  width  = raw_width;",
          "14387:     { height  = 2616;   width  = 3896; }",
          "14389:     { height  = 3124;   width  = 4688; filters = 0x16161616; }",
          "14390:   if (width == 4352 && (!strcmp(model,\"K-r\") || !strcmp(model,\"K-x\")))",
          "14391:     {   width  = 4309; filters = 0x16161616; }",
          "14392:   if (width >= 4960 && !strncmp(model,\"K-5\",3))",
          "14393:     { left_margin = 10; width  = 4950; filters = 0x16161616; }",
          "14394:   if (width == 6080 && !strcmp(model,\"K-70\"))",
          "14395:      { height  = 4016; top_margin=32; width=6020; left_margin = 60; }",
          "14396:   if (width == 4736 && !strcmp(model,\"K-7\"))",
          "14397:     { height  = 3122;   width  = 4684; filters = 0x16161616; top_margin = 2; }",
          "14399:     { left_margin = 4;  width  = 6040; }",
          "14400:   if (width == 6080 && !strcmp(model,\"K-3\"))",
          "14401:     { left_margin = 4;  width  = 6040; }",
          "14402:   if (width == 7424 && !strcmp(model,\"645D\"))",
          "14403:     { height  = 5502;   width  = 7328; filters = 0x61616161; top_margin = 29;",
          "14404:       left_margin = 48; }",
          "14406:    width  = 4014;",
          "14407:   if (dng_version) {",
          "14408:     if (filters == UINT_MAX) filters = 0;",
          "14409:     if (filters) is_raw *= tiff_samples;",
          "14410:     else  colors  = tiff_samples;",
          "14411:     switch (tiff_compress) {",
          "14413:       case 1:     load_raw = &CLASS   packed_dng_load_raw;  break;",
          "14414:       case 7:     load_raw = &CLASS lossless_dng_load_raw;  break;",
          "14415: #ifdef LIBRAW_LIBRARY_BUILD",
          "14416:       case 8:     load_raw = &CLASS  deflate_dng_load_raw;  break;",
          "14417: #endif",
          "14418:       case 34892: load_raw = &CLASS    lossy_dng_load_raw;  break;",
          "14419:       default:    load_raw = 0;",
          "14420:     }",
          "14421:     if (!strncmp(make, \"Canon\",5) && unique_id)",
          "14422:       {",
          "14423:         for (i = 0; i < sizeof unique / sizeof *unique; i++)",
          "14424:           if (unique_id == 0x80000000 + unique[i].id)",
          "14425:             {",
          "14426:               strcpy(model, unique[i].t_model);",
          "14427:               break;",
          "14428:             }",
          "14429:       }",
          "14430:     if (!strncasecmp(make, \"Sony\",4) && unique_id)",
          "14431:       {",
          "14432:         for (i = 0; i < sizeof sonique / sizeof *sonique; i++)",
          "14433:           if (unique_id == sonique[i].id)",
          "14434:             {",
          "14435:               strcpy(model, sonique[i].t_model);",
          "14436:               break;",
          "14437:             }",
          "14438:       }",
          "14441:   if (!strncmp(make,\"Canon\",5) && !fsize && tiff_bps != 15) {",
          "14444:     for (i=0; i < sizeof canon / sizeof *canon; i++)",
          "14445:       if (raw_width == canon[i][0] && raw_height == canon[i][1]) {",
          "14446:  width  = raw_width - (left_margin = canon[i][2]);",
          "14447:  height = raw_height - (top_margin = canon[i][3]);",
          "14448:  width  -= canon[i][4];",
          "14449:  height -= canon[i][5];",
          "14450:  mask[0][1] =  canon[i][6];",
          "14451:  mask[0][3] = -canon[i][7];",
          "14452:  mask[1][1] =  canon[i][8];",
          "14453:  mask[1][3] = -canon[i][9];",
          "14454:  if (canon[i][10]) filters = canon[i][10] * 0x01010101;",
          "14455:       }",
          "14456:     if ((unique_id | 0x20000) == 0x2720000) {",
          "14461:   if (!strncmp(make,\"Canon\",5) && unique_id)",
          "14462:     {",
          "14463:       for (i=0; i < sizeof unique / sizeof *unique; i++)",
          "14464:         if (unique_id == 0x80000000 + unique[i].id)",
          "14465:           {",
          "14466:             adobe_coeff (\"Canon\", unique[i].t_model);",
          "14467:             strcpy(model,unique[i].t_model);",
          "14468:           }",
          "14469:     }",
          "14471:   if (!strncasecmp(make,\"Sony\",4) && unique_id)",
          "14472:     {",
          "14473:       for (i=0; i < sizeof sonique / sizeof *sonique; i++)",
          "14474:         if (unique_id == sonique[i].id)",
          "14475:           {",
          "14476:             adobe_coeff (\"Sony\", sonique[i].t_model);",
          "14477:             strcpy(model,sonique[i].t_model);",
          "14478:           }",
          "14479:     }",
          "14481:   if (!strncmp(make,\"Nikon\",5)) {",
          "14490:   if (!strcmp(model,\"KAI-0340\")",
          "14491:  && find_green (16, 16, 3840, 5120) < 25) {",
          "14494:     strcpy (model,\"C603\");",
          "14499:   if (is_foveon) {",
          "14500:     if (height*2 < width) pixel_aspect = 0.5;",
          "14501:     if (height   > width) pixel_aspect = 2;",
          "14504:     if(!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F))",
          "14508:   else if(!strncmp(make,\"Pentax\",6))",
          "14510:     if(!strncmp(model,\"K-1\",3))",
          "14512:    top_margin = 18;",
          "14513:   height = raw_height - top_margin;",
          "14514:  if(raw_width == 7392)",
          "14515:  {",
          "14516:    left_margin = 6;",
          "14517:    width = 7376;",
          "14518:  }",
          "14521:   else if (!strncmp(make,\"Canon\",5) && tiff_bps == 15) {",
          "14522:     switch (width) {",
          "14523:       case 3344: width -= 66;",
          "14524:       case 3872: width -= 6;",
          "14526:     if (height > width) {",
          "14527:       SWAP(height,width);",
          "14528:       SWAP(raw_height,raw_width);",
          "14531:       {",
          "14532:  raw_width  = width  = 6480;",
          "14533:  raw_height = height = 4320;",
          "14534:       }",
          "14538:   } else if (!strcmp(model,\"PowerShot 600\")) {",
          "14540:     width  = 854;",
          "14545:   } else if (!strcmp(model,\"PowerShot A5\") ||",
          "14546:       !strcmp(model,\"PowerShot A5 Zoom\")) {",
          "14548:     width  = 960;",
          "14550:     pixel_aspect = 256/235.0;",
          "14553:   } else if (!strcmp(model,\"PowerShot A50\")) {",
          "14554:     height =  968;",
          "14555:     width  = 1290;",
          "14559:   } else if (!strcmp(model,\"PowerShot Pro70\")) {",
          "14561:     width  = 1552;",
          "14563: canon_a5:",
          "14568:   } else if (!strcmp(model,\"PowerShot Pro90 IS\") ||",
          "14569:       !strcmp(model,\"PowerShot G1\")) {",
          "14572:   } else if (!strcmp(model,\"PowerShot A610\")) {",
          "14573:     if (canon_s2is()) strcpy (model+10, \"S2 IS\");",
          "14574:   } else if (!strcmp(model,\"PowerShot SX220 HS\")) {",
          "14576:     top_margin=16;",
          "14578:   } else if (!strcmp(model,\"PowerShot S120\")) {",
          "14579:         raw_width = 4192;",
          "14580:         raw_height = 3062;",
          "14581:         width = 4022;",
          "14582:         height = 3016;",
          "14583:         mask[0][0] = top_margin = 31;",
          "14584:         mask[0][2] = top_margin + height;",
          "14585:         left_margin = 120;",
          "14586:         mask[0][1] = 23;",
          "14587:         mask[0][3] = 72;",
          "14588:   } else if (!strcmp(model,\"PowerShot G16\")) {",
          "14589:       mask[0][0] = 0;",
          "14590:       mask[0][2] = 80;",
          "14591:       mask[0][1] = 0;",
          "14592:       mask[0][3] = 16;",
          "14593:       top_margin = 29;",
          "14594:       left_margin = 120;",
          "14595:       width = raw_width-left_margin-48;",
          "14596:       height = raw_height-top_margin-14;",
          "14597:   } else if (!strcmp(model,\"PowerShot SX50 HS\")) {",
          "14599:   } else if (!strcmp(model,\"EOS D2000C\")) {",
          "14602:   } else if (!strcmp(model,\"D1\")) {",
          "14603:     cam_mul[0] *= 256/527.0;",
          "14604:     cam_mul[2] *= 256/317.0;",
          "14605:   } else if (!strcmp(model,\"D1X\")) {",
          "14608:   } else if (!strcmp(model,\"D40X\") ||",
          "14609:       !strcmp(model,\"D60\")  ||",
          "14610:       !strcmp(model,\"D80\")  ||",
          "14611:       !strcmp(model,\"D3000\")) {",
          "14613:     width  -= 4;",
          "14614:   } else if (!strcmp(model,\"D3\")   ||",
          "14615:       !strcmp(model,\"D3S\")  ||",
          "14616:       !strcmp(model,\"D700\")) {",
          "14619:   } else if (!strcmp(model,\"D3100\")) {",
          "14622:   } else if (!strcmp(model,\"D5000\") ||",
          "14623:       !strcmp(model,\"D90\")) {",
          "14625:   } else if (!strcmp(model,\"D5100\") ||",
          "14626:       !strcmp(model,\"D7000\") ||",
          "14627:       !strcmp(model,\"COOLPIX A\")) {",
          "14629:   } else if (!strcmp(model,\"D3200\") ||",
          "14630:      !strncmp(model,\"D6\",2)  ||",
          "14631:      !strncmp(model,\"D800\",4)) {",
          "14633:   } else if (!strcmp(model,\"D4\") ||",
          "14634:       !strcmp(model,\"Df\")) {",
          "14637:   } else if (!strncmp(model,\"D40\",3) ||",
          "14638:       !strncmp(model,\"D50\",3) ||",
          "14639:       !strncmp(model,\"D70\",3)) {",
          "14641:   } else if (!strcmp(model,\"D100\")) {",
          "14644:   } else if (!strcmp(model,\"D200\")) {",
          "14648:   } else if (!strncmp(model,\"D2H\",3)) {",
          "14651:   } else if (!strncmp(model,\"D2X\",3)) {",
          "14652:     if (width == 3264) width -= 32;",
          "14653:     else width -= 8;",
          "14654:   } else if (!strncmp(model,\"D300\",4)) {",
          "14656:   } else if (!strncmp(make,\"Nikon\",5) && raw_width == 4032) {",
          "14657:     if(!strcmp(model,\"COOLPIX P7700\"))",
          "14658:       {",
          "14659:         adobe_coeff (\"Nikon\",\"COOLPIX P7700\");",
          "14660:         maximum = 65504;",
          "14661:         load_flags = 0;",
          "14662:       }",
          "14663:     else if(!strcmp(model,\"COOLPIX P7800\"))",
          "14664:       {",
          "14665:         adobe_coeff (\"Nikon\",\"COOLPIX P7800\");",
          "14666:         maximum = 65504;",
          "14667:         load_flags = 0;",
          "14668:       }",
          "14669:     else  if(!strcmp(model,\"COOLPIX P340\"))",
          "14670:       load_flags=0;",
          "14671:   } else if (!strncmp(model,\"COOLPIX P\",9) && raw_width != 4032) {",
          "14674:     if (model[9] == '7' && (iso_speed >= 400 || iso_speed==0) && !strstr(software,\"V1.2\") )",
          "14676:   } else if (!strncmp(model,\"1 \",2)) {",
          "14678:   } else if (fsize == 1581060) {",
          "14683:   } else if (fsize == 3178560) {",
          "14686:   } else if (fsize == 4771840) {",
          "14688:       strcpy (model, \"E995\");",
          "14689:     if (strcmp(model,\"E995\")) {",
          "14696:   } else if (fsize == 2940928) {",
          "14698:       strcpy (model,\"E2500\");",
          "14699:     if (!strcmp(model,\"E2500\")) {",
          "14705:   } else if (fsize == 4775936) {",
          "14706:     if (!timestamp) nikon_3700();",
          "14707:     if (model[0] == 'E' && atoi(model+1) < 3700)",
          "14709:     if (!strcmp(model,\"Optio 33WR\")) {",
          "14713:     if (make[0] == 'O') {",
          "14714:       i = find_green (12, 32, 1188864, 3576832);",
          "14715:       c = find_green (12, 32, 2383920, 2387016);",
          "14716:       if (abs(i) < abs(c)) {",
          "14717:  SWAP(i,c);",
          "14718:  load_flags = 24;",
          "14720:       if (i < 0) filters = 0x61616161;",
          "14722:   } else if (fsize == 5869568) {",
          "14723:     if (!timestamp && minolta_z2()) {",
          "14724:       strcpy (make, \"Minolta\");",
          "14725:       strcpy (model,\"DiMAGE Z2\");",
          "14727:     load_flags = 6 + 24*(make[0] == 'M');",
          "14728:   } else if (fsize == 6291456) {",
          "14729:     fseek (ifp, 0x300000, SEEK_SET);",
          "14730:     if ((order = guess_byte_order(0x10000)) == 0x4d4d) {",
          "14734:       strcpy (make, \"ISG\");",
          "14737:   } else if (!strncmp(make,\"Fujifilm\",8)) {",
          "14738:     if (!strcmp(model+7,\"S2Pro\")) {",
          "14739:       strcpy (model,\"S2Pro\");",
          "14741:       width  = 2880;",
          "14743:     } else if (load_raw != &CLASS packed_load_raw)",
          "14746:     left_margin = (raw_width - width ) >> 2 << 1;",
          "14747:     if (width == 2848 || width == 3664) filters = 0x16161616;",
          "14748:     if (width == 4032 || width == 4952) left_margin = 0;",
          "14749:     if (width == 3328 && (width -= 66)) left_margin = 34;",
          "14750:     if (width == 4936) left_margin = 4;",
          "14751:     if (width == 6032) left_margin = 0;",
          "14752:     if (!strcmp(model,\"HS50EXR\") ||",
          "14753:  !strcmp(model,\"F900EXR\")) {",
          "14758:     if(!strcmp(model,\"S5500\"))",
          "14759:       {",
          "14760:         height -= (top_margin=6);",
          "14761:       }",
          "14762:     if (fuji_layout) raw_width *= is_raw;",
          "14764:       FORC(36) ((char *)xtrans)[c] =",
          "14765:  xtrans_abs[(c/6+top_margin) % 6][(c+left_margin) % 6];",
          "14766:   } else if (!strcmp(model,\"KD-400Z\")) {",
          "14768:     width  = 2312;",
          "14771:   } else if (!strcmp(model,\"KD-510Z\")) {",
          "14773:   } else if (!strncasecmp(make,\"Minolta\",7)) {",
          "14776:     if (!strncmp(model,\"DiMAGE A\",8)) {",
          "14777:       if (!strcmp(model,\"DiMAGE A200\"))",
          "14778:  filters = 0x49494949;",
          "14781:     } else if (!strncmp(model,\"ALPHA\",5) ||",
          "14782:         !strncmp(model,\"DYNAX\",5) ||",
          "14783:         !strncmp(model,\"MAXXUM\",6)) {",
          "14784:       sprintf (model+20, \"DYNAX %-10s\", model+6+(model[0]=='M'));",
          "14785:       adobe_coeff (make, model+20);",
          "14787:     } else if (!strncmp(model,\"DiMAGE G\",8)) {",
          "14788:       if (model[8] == '4') {",
          "14789:  height = 1716;",
          "14790:  width  = 2304;",
          "14791:       } else if (model[8] == '5') {",
          "14792: konica_510z:",
          "14793:  height = 1956;",
          "14794:  width  = 2607;",
          "14795:  raw_width = 2624;",
          "14796:       } else if (model[8] == '6') {",
          "14797:  height = 2136;",
          "14798:  width  = 2848;",
          "14802: konica_400z:",
          "14807:   } else if (!strcmp(model,\"*ist D\")) {",
          "14810:   } else if (!strcmp(model,\"*ist DS\")) {",
          "14812:   } else if (!strncmp(make,\"Samsung\",7) && raw_width == 4704) {",
          "14816:   } else if (!strncmp(make,\"Samsung\",7) && !strcmp(model,\"NX3000\")) {",
          "14823:   } else if (!strncmp(make,\"Samsung\",7) && raw_height == 3714) {",
          "14830:   } else if (!strncmp(make,\"Samsung\",7) && raw_width == 5632) {",
          "14834:     width  = 5574 - (left_margin = 32 + tiff_bps);",
          "14835:     if (tiff_bps == 12) load_flags = 80;",
          "14836:   } else if (!strncmp(make,\"Samsung\",7) && raw_width == 5664) {",
          "14841:   } else if (!strncmp(make,\"Samsung\",7) && raw_width == 6496) {",
          "14844:     if(!black && !cblack[0] && !cblack[1] && !cblack[2] && !cblack[3])",
          "14846:     black = 1 << (tiff_bps - 7);",
          "14847:   } else if (!strcmp(model,\"EX1\")) {",
          "14851:     if ((width -= 6) > 3682) {",
          "14853:       width  -= 46;",
          "14856:   } else if (!strcmp(model,\"WB2000\")) {",
          "14860:     if ((width -= 10) > 3718) {",
          "14862:       width  -= 56;",
          "14865:   } else if (strstr(model,\"WB550\")) {",
          "14866:     strcpy (model, \"WB550\");",
          "14867:   } else if (!strcmp(model,\"EX2F\")) {",
          "14869:     width  = 4040;",
          "14871:     left_margin=24;",
          "14875:   } else if (!strcmp(model,\"STV680 VGA\")) {",
          "14877:   } else if (!strcmp(model,\"N95\")) {",
          "14879:   } else if (!strcmp(model,\"640x480\")) {",
          "14880:     gamma_curve (0.45, 4.5, 1, 255);",
          "14881:   } else if (!strncmp(make,\"Hasselblad\",10)) {",
          "14884:     if (raw_width == 7262) {",
          "14886:       width  = 7248;",
          "14887:       top_margin  = 4;",
          "14890:       if(!strncasecmp(model,\"H3D\",3))",
          "14891:         {",
          "14892:           adobe_coeff(\"Hasselblad\",\"H3DII-39\");",
          "14893:           strcpy(model,\"H3DII-39\");",
          "14894:         }",
          "14895:     } else if (raw_width == 7410 || raw_width == 8282) {",
          "14897:       width  -= 82;",
          "14898:       top_margin  = 4;",
          "14901:       adobe_coeff(\"Hasselblad\",\"H4D-40\");",
          "14902:       strcpy(model,\"H4D-40\");",
          "14904:     else if( raw_width == 8384) // X1D",
          "14906:      top_margin  = 96;",
          "14907:      height -= 96;",
          "14908:      left_margin = 48;",
          "14909:      width  -= 106;",
          "14910:      adobe_coeff(\"Hasselblad\",\"X1D\");",
          "14912:     else if (raw_width == 9044) {",
          "14913:       if(black > 500)",
          "14914:         {",
          "14915:           top_margin = 12;",
          "14916:           left_margin = 44;",
          "14917:           width = 8956;",
          "14918:           height = 6708;",
          "14919:           memset(cblack,0,sizeof(cblack));",
          "14920:           adobe_coeff(\"Hasselblad\",\"H4D-60\");",
          "14921:           strcpy(model,\"H4D-60\");",
          "14922:           black = 512;",
          "14923:         }",
          "14925:         {",
          "14926:           height = 6716;",
          "14927:           width  = 8964;",
          "14928:           top_margin  = 8;",
          "14929:           left_margin = 40;",
          "14930:           black += load_flags = 256;",
          "14931:           maximum = 0x8101;",
          "14932:           strcpy(model,\"H3DII-60\");",
          "14933:         }",
          "14934:     } else if (raw_width == 4090) {",
          "14935:       strcpy (model, \"V96C\");",
          "14939:     } else if (raw_width == 8282 && raw_height == 6240) {",
          "14940:       if(!strncasecmp(model,\"H5D\",3))",
          "14941:         {",
          "14943:           left_margin = 54;",
          "14944:           top_margin = 16;",
          "14945:           width = 8176;",
          "14946:           height = 6132;",
          "14947:           black = 256;",
          "14948:           strcpy(model,\"H5D-50\");",
          "14949:         }",
          "14950:       else if(!strncasecmp(model,\"H3D\",3))",
          "14951:         {",
          "14952:           black=0;",
          "14953:           left_margin = 54;",
          "14954:           top_margin = 16;",
          "14955:           width = 8176;",
          "14956:           height = 6132;",
          "14957:           memset(cblack,0,sizeof(cblack));",
          "14958:           adobe_coeff(\"Hasselblad\",\"H3D-50\");",
          "14959:           strcpy(model,\"H3D-50\");",
          "14960:         }",
          "14961:     } else if (raw_width == 8374 && raw_height == 6304) {",
          "14968:       strcpy(model,\"H5D-50c\");",
          "14970:     if (tiff_samples > 1) {",
          "14971:       is_raw = tiff_samples+1;",
          "14972:       if (!shot_select && !half_size) filters = 0;",
          "14974:   } else if (!strncmp(make,\"Sinar\",5)) {",
          "14975:     if (!load_raw) load_raw = &CLASS unpacked_load_raw;",
          "14976:     if (is_raw > 1 && !shot_select && !half_size) filters = 0;",
          "14978:   } else if (!strncmp(make,\"Leaf\",4)) {",
          "14980:     fseek (ifp, data_offset, SEEK_SET);",
          "14981:     if (ljpeg_start (&jh, 1) && jh.bits == 15)",
          "14983:     if (tiff_samples > 1) filters = 0;",
          "14984:     if (tiff_samples > 1 || tile_length < raw_height) {",
          "14988:     if ((width | height) == 2048) {",
          "14989:       if (tiff_samples == 1) {",
          "14990:  filters = 1;",
          "14991:  strcpy (cdesc, \"RBTG\");",
          "14992:  strcpy (model, \"CatchLight\");",
          "14993:  top_margin =  8; left_margin = 18; height = 2032; width = 2016;",
          "14994:       } else {",
          "14995:  strcpy (model, \"DCB2\");",
          "14996:  top_margin = 10; left_margin = 16; height = 2028; width = 2022;",
          "14997:       }",
          "14998:     } else if (width+height == 3144+2060) {",
          "14999:       if (!model[0]) strcpy (model, \"Cantare\");",
          "15000:       if (width > height) {",
          "15001:   top_margin = 6; left_margin = 32; height = 2048;  width = 3072;",
          "15002:  filters = 0x61616161;",
          "15003:       } else {",
          "15004:  left_margin = 6;  top_margin = 32;  width = 2048; height = 3072;",
          "15005:  filters = 0x16161616;",
          "15006:       }",
          "15007:       if (!cam_mul[0] || model[0] == 'V') filters = 0;",
          "15008:       else is_raw = tiff_samples;",
          "15009:     } else if (width == 2116) {",
          "15010:       strcpy (model, \"Valeo 6\");",
          "15014:     } else if (width == 3171) {",
          "15015:       strcpy (model, \"Valeo 6\");",
          "15020:   } else if (!strncmp(make,\"Leica\",5) || !strncmp(make,\"Panasonic\",9)",
          "15021:       || !strncasecmp(make,\"YUNEEC\",6)) {",
          "15022:     if (raw_width > 0&& ((flen - data_offset) / (raw_width*8/7) == raw_height) )",
          "15024:     if (!load_raw) {",
          "15029:     if ((height += 12) > raw_height) height = raw_height;",
          "15030:     for (i=0; i < sizeof pana / sizeof *pana; i++)",
          "15031:       if (raw_width == pana[i][0] && raw_height == pana[i][1]) {",
          "15032:  left_margin = pana[i][2];",
          "15033:   top_margin = pana[i][3];",
          "15034:       width += pana[i][4];",
          "15035:      height += pana[i][5];",
          "15036:       }",
          "15037:     filters = 0x01010101 * (uchar) \"\\x94\\x61\\x49\\x16\"",
          "15038:  [((filters-1) ^ (left_margin & 1) ^ (top_margin << 1)) & 3];",
          "15039:   } else if (!strcmp(model,\"C770UZ\")) {",
          "15041:     width  = 2304;",
          "15045:   } else if (!strncmp(make,\"Olympus\",7)) {",
          "15047:     if (exif_cfa) filters = exif_cfa;",
          "15048:     if (width == 4100) width -= 4;",
          "15049:     if (width == 4080) width -= 24;",
          "15050:     if (width == 9280) { width -= 6; height -= 6; }",
          "15054:     if (!strcmp(model,\"E-300\") ||",
          "15055:  !strcmp(model,\"E-500\")) {",
          "15057:       if (load_raw == &CLASS unpacked_load_raw) {",
          "15058:  maximum = 0xfc3;",
          "15059:  memset (cblack, 0, sizeof cblack);",
          "15061:     } else if (!strcmp(model,\"STYLUS1\")) {",
          "15064:     } else if (!strcmp(model,\"E-330\")) {",
          "15067:  maximum = 0xf79;",
          "15068:     } else if (!strcmp(model,\"SP550UZ\")) {",
          "15071:       thumb_width  = 640;",
          "15072:     } else if (!strcmp(model,\"TG-4\")) {",
          "15075:   } else if (!strcmp(model,\"N Digital\")) {",
          "15077:     width  = 3072;",
          "15081:   } else if (!strcmp(model,\"DSC-F828\")) {",
          "",
          "[Added Lines]",
          "15046:   for (i = 0; i < 4; i++)",
          "15047:   {",
          "15054:   for (i = 0; i < 0x10000; i++)",
          "15055:     curve[i] = i;",
          "15059:   fseek(ifp, 0, SEEK_SET);",
          "15061:   fread(head, 1, 64, ifp);",
          "15064:   fread(head, 1, 32, ifp);",
          "15066:   fseek(ifp, 0, SEEK_END);",
          "15068:   if ((cp = (char *)memmem(head, 32, (char *)\"MMMM\", 4)) || (cp = (char *)memmem(head, 32, (char *)\"IIII\", 4)))",
          "15069:   {",
          "15070:     parse_phase_one(cp - head);",
          "15071:     if (cp - head && parse_tiff(0))",
          "15072:       apply_tiff();",
          "15073:   }",
          "15074:   else if (order == 0x4949 || order == 0x4d4d)",
          "15075:   {",
          "15076:     if (!memcmp(head + 6, \"HEAPCCDR\", 8))",
          "15077:     {",
          "15083:       parse_ciff(hlen, flen - hlen, 0);",
          "15085:     }",
          "15086:     else if (parse_tiff(0))",
          "15087:       apply_tiff();",
          "15088:   }",
          "15089:   else if (!memcmp(head, \"\\xff\\xd8\\xff\\xe1\", 4) && !memcmp(head + 6, \"Exif\", 4))",
          "15090:   {",
          "15091:     fseek(ifp, 4, SEEK_SET);",
          "15093:     fseek(ifp, data_offset, SEEK_SET);",
          "15097:   }",
          "15098:   else if (!memcmp(head + 25, \"ARECOYK\", 7))",
          "15099:   {",
          "15100:     strcpy(make, \"Contax\");",
          "15101:     strcpy(model, \"N Digital\");",
          "15102:     fseek(ifp, 33, SEEK_SET);",
          "15104:     fseek(ifp, 52, SEEK_SET);",
          "15105:     switch (get4())",
          "15106:     {",
          "15107:     case 7:",
          "15108:       iso_speed = 25;",
          "15109:       break;",
          "15110:     case 8:",
          "15111:       iso_speed = 32;",
          "15112:       break;",
          "15113:     case 9:",
          "15114:       iso_speed = 40;",
          "15115:       break;",
          "15116:     case 10:",
          "15117:       iso_speed = 50;",
          "15118:       break;",
          "15119:     case 11:",
          "15120:       iso_speed = 64;",
          "15121:       break;",
          "15122:     case 12:",
          "15123:       iso_speed = 80;",
          "15124:       break;",
          "15125:     case 13:",
          "15126:       iso_speed = 100;",
          "15127:       break;",
          "15128:     case 14:",
          "15129:       iso_speed = 125;",
          "15130:       break;",
          "15131:     case 15:",
          "15132:       iso_speed = 160;",
          "15133:       break;",
          "15134:     case 16:",
          "15135:       iso_speed = 200;",
          "15136:       break;",
          "15137:     case 17:",
          "15138:       iso_speed = 250;",
          "15139:       break;",
          "15140:     case 18:",
          "15141:       iso_speed = 320;",
          "15142:       break;",
          "15143:     case 19:",
          "15144:       iso_speed = 400;",
          "15145:       break;",
          "15146:     }",
          "15147:     shutter = powf64(2.0f, (((float)get4()) / 8.0f)) / 16000.0f;",
          "15149:     fseek(ifp, 88, SEEK_SET);",
          "15150:     aperture = powf64(2.0f, ((float)get4()) / 16.0f);",
          "15151:     fseek(ifp, 112, SEEK_SET);",
          "15154:     fseek(ifp, 104, SEEK_SET);",
          "15155:     imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, ((float)get4()) / 16.0f);",
          "15156:     fseek(ifp, 124, SEEK_SET);",
          "15162:   }",
          "15163:   else if (!strcmp(head, \"PXN\"))",
          "15164:   {",
          "15165:     strcpy(make, \"Logitech\");",
          "15166:     strcpy(model, \"Fotoman Pixtura\");",
          "15167:   }",
          "15168:   else if (!strcmp(head, \"qktk\"))",
          "15169:   {",
          "15170:     strcpy(make, \"Apple\");",
          "15171:     strcpy(model, \"QuickTake 100\");",
          "15173:   }",
          "15174:   else if (!strcmp(head, \"qktn\"))",
          "15175:   {",
          "15176:     strcpy(make, \"Apple\");",
          "15177:     strcpy(model, \"QuickTake 150\");",
          "15179:   }",
          "15180:   else if (!memcmp(head, \"FUJIFILM\", 8))",
          "15181:   {",
          "15183:     strcpy(model, head + 0x1c);",
          "15184:     memcpy(model2, head + 0x3c, 4);",
          "15185:     model2[4] = 0;",
          "15187:     fseek(ifp, 84, SEEK_SET);",
          "15190:     fseek(ifp, 92, SEEK_SET);",
          "15191:     parse_fuji(get4());",
          "15192:     if (thumb_offset > 120)",
          "15193:     {",
          "15194:       fseek(ifp, 120, SEEK_SET);",
          "15195:       is_raw += (i = get4()) ? 1 : 0;",
          "15197:         parse_fuji(i);",
          "15200:     fseek(ifp, 100 + 28 * (shot_select > 0), SEEK_SET);",
          "15201:     parse_tiff(data_offset = get4());",
          "15202:     parse_tiff(thumb_offset + 12);",
          "15204:   }",
          "15205:   else if (!memcmp(head, \"RIFF\", 4))",
          "15206:   {",
          "15207:     fseek(ifp, 0, SEEK_SET);",
          "15209:   }",
          "15210:   else if (!memcmp(head + 4, \"ftypqt   \", 9))",
          "15211:   {",
          "15212:     fseek(ifp, 0, SEEK_SET);",
          "15213:     parse_qt(fsize);",
          "15215:   }",
          "15216:   else if (!memcmp(head, \"\\0\\001\\0\\001\\0@\", 6))",
          "15217:   {",
          "15218:     fseek(ifp, 6, SEEK_SET);",
          "15219:     fread(make, 1, 8, ifp);",
          "15220:     fread(model, 1, 8, ifp);",
          "15221:     fread(model2, 1, 16, ifp);",
          "15228:   }",
          "15229:   else if (!memcmp(head, \"NOKIARAW\", 8))",
          "15230:   {",
          "15231:     strcpy(make, \"NOKIA\");",
          "15233:     fseek(ifp, 300, SEEK_SET);",
          "15238:     switch (tiff_bps = i * 8 / (width * height))",
          "15239:     {",
          "15240:     case 8:",
          "15241:       load_raw = &CLASS eight_bit_load_raw;",
          "15242:       break;",
          "15243:     case 10:",
          "15244:       load_raw = &CLASS nokia_load_raw;",
          "15246:     raw_height = height + (top_margin = i / (width * tiff_bps / 8) - height);",
          "15249:   }",
          "15250:   else if (!memcmp(head, \"ARRI\", 4))",
          "15251:   {",
          "15253:     fseek(ifp, 20, SEEK_SET);",
          "15256:     strcpy(make, \"ARRI\");",
          "15257:     fseek(ifp, 668, SEEK_SET);",
          "15258:     fread(model, 1, 64, ifp);",
          "15263:   }",
          "15264:   else if (!memcmp(head, \"XPDS\", 4))",
          "15265:   {",
          "15267:     fseek(ifp, 0x800, SEEK_SET);",
          "15268:     fread(make, 1, 41, ifp);",
          "15270:     raw_width = get2();",
          "15271:     fseek(ifp, 56, SEEK_CUR);",
          "15272:     fread(model, 1, 30, ifp);",
          "15275:     gamma_curve(0, 12.25, 1, 1023);",
          "15276:   }",
          "15277:   else if (!memcmp(head + 4, \"RED1\", 4))",
          "15278:   {",
          "15279:     strcpy(make, \"Red\");",
          "15280:     strcpy(model, \"One\");",
          "15283:     gamma_curve(1 / 2.4, 12.92, 1, 4095);",
          "15285:   }",
          "15286:   else if (!memcmp(head, \"DSC-Image\", 9))",
          "15288:   else if (!memcmp(head, \"PWAD\", 4))",
          "15290:   else if (!memcmp(head, \"\\0MRM\", 4))",
          "15292:   else if (!memcmp(head, \"FOVb\", 4))",
          "15293:   {",
          "15295: #ifdef LIBRAW_DEMOSAIC_PACK_GPL2",
          "15296:     if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F))",
          "15297:       parse_foveon();",
          "15298:     else",
          "15300:       parse_x3f();",
          "15302: #ifdef LIBRAW_DEMOSAIC_PACK_GPL2",
          "15303:     parse_foveon();",
          "15306:   }",
          "15307:   else if (!memcmp(head, \"CI\", 2))",
          "15309:   if (make[0] == 0)",
          "15311:     for (zero_fsize = i = 0; i < camera_count; i++)",
          "15313:     for (zero_fsize = i = 0; i < sizeof table / sizeof *table; i++)",
          "15315:       if (fsize == table[i].fsize)",
          "15316:       {",
          "15317:         strcpy(make, table[i].t_make);",
          "15319:         if (!strncmp(make, \"Canon\", 5))",
          "15320:         {",
          "15321:           imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "15322:           imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;",
          "15323:         }",
          "15324: #endif",
          "15325:         strcpy(model, table[i].t_model);",
          "15326:         flip = table[i].flags >> 2;",
          "15327:         zero_is_bad = table[i].flags & 2;",
          "15328:         if (table[i].flags & 1)",
          "15329:           parse_external_jpeg();",
          "15330:         data_offset = table[i].offset == 0xffff ? 0 : table[i].offset;",
          "15331:         raw_width = table[i].rw;",
          "15332:         raw_height = table[i].rh;",
          "15333:         left_margin = table[i].lm;",
          "15334:         top_margin = table[i].tm;",
          "15335:         width = raw_width - left_margin - table[i].rm;",
          "15336:         height = raw_height - top_margin - table[i].bm;",
          "15337:         filters = 0x1010101 * table[i].cf;",
          "15338:         colors = 4 - !((filters & filters >> 1) & 0x5555);",
          "15339:         load_flags = table[i].lf;",
          "15340:         switch (tiff_bps = (fsize - data_offset) * 8 / (raw_width * raw_height))",
          "15341:         {",
          "15342:         case 6:",
          "15343:           load_raw = &CLASS minolta_rd175_load_raw;",
          "15344:           break;",
          "15345:         case 8:",
          "15346:           load_raw = &CLASS eight_bit_load_raw;",
          "15347:           break;",
          "15348:         case 10:",
          "15349:           if ((fsize - data_offset) / raw_height * 3 >= raw_width * 4)",
          "15351:             load_raw = &CLASS android_loose_load_raw;",
          "15352:             break;",
          "15354:           else if (load_flags & 1)",
          "15355:           {",
          "15356:             load_raw = &CLASS android_tight_load_raw;",
          "15357:             break;",
          "15358:           }",
          "15359:         case 12:",
          "15360:           load_flags |= 128;",
          "15361:           load_raw = &CLASS packed_load_raw;",
          "15362:           break;",
          "15363:         case 16:",
          "15364:           order = 0x4949 | 0x404 * (load_flags & 1);",
          "15365:           tiff_bps -= load_flags >> 4;",
          "15366:           tiff_bps -= load_flags = load_flags >> 1 & 7;",
          "15367:           load_raw = table[i].offset == 0xffff ? &CLASS unpacked_load_raw_reversed : &CLASS unpacked_load_raw;",
          "15368:         }",
          "15369:         maximum = (1 << tiff_bps) - (1 << table[i].max);",
          "15370:       }",
          "15371:   if (zero_fsize)",
          "15372:     fsize = 0;",
          "15373:   if (make[0] == 0)",
          "15374:     parse_smal(0, flen);",
          "15375:   if (make[0] == 0)",
          "15376:   {",
          "15378:     fseek(ifp, 0, SEEK_END);",
          "15381:     if (!strncmp(model, \"RP_imx219\", 9) && sz >= 0x9cb600 && !fseek(ifp, -0x9cb600, SEEK_END) &&",
          "15382:         fread(head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4))",
          "15383:     {",
          "15384:       strcpy(make, \"Broadcom\");",
          "15385:       strcpy(model, \"RPi IMX219\");",
          "15386:       if (raw_height > raw_width)",
          "15387:         flip = 5;",
          "15388:       data_offset = ftell(ifp) + 0x8000 - 0x20;",
          "15389:       parse_broadcom();",
          "15390:       black = 66;",
          "15391:       maximum = 0x3ff;",
          "15392:       load_raw = &CLASS broadcom_load_raw;",
          "15395:     }",
          "15396:     else if (!(strncmp(model, \"ov5647\", 6) && strncmp(model, \"RP_OV5647\", 9)) && sz >= 0x61b800 &&",
          "15397:              !fseek(ifp, -0x61b800, SEEK_END) && fread(head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4))",
          "15398:     {",
          "15399:       strcpy(make, \"Broadcom\");",
          "15400:       if (!strncmp(model, \"ov5647\", 6))",
          "15401:         strcpy(model, \"RPi OV5647 v.1\");",
          "15403:         strcpy(model, \"RPi OV5647 v.2\");",
          "15404:       if (raw_height > raw_width)",
          "15405:         flip = 5;",
          "15408:       black = 16;",
          "15409:       maximum = 0x3ff;",
          "15410:       load_raw = &CLASS broadcom_load_raw;",
          "15414:     if (!(strncmp(model, \"ov\", 2) && strncmp(model, \"RP_OV\", 5)) && sz >= 6404096 && !fseek(ifp, -6404096, SEEK_END) &&",
          "15415:         fread(head, 1, 32, ifp) && !strcmp(head, \"BRCMn\"))",
          "15416:     {",
          "15417:       strcpy(make, \"OmniVision\");",
          "15418:       data_offset = ftell(ifp) + 0x8000 - 32;",
          "15424:     }",
          "15425:     else",
          "15426:       is_raw = 0;",
          "15432:   for (i = 0; i < sizeof corp / sizeof *corp; i++)",
          "15434:       strcpy(make, corp[i]);",
          "15435:   if ((!strncmp(make, \"Kodak\", 5) || !strncmp(make, \"Leica\", 5)) &&",
          "15436:       ((cp = strcasestr(model, \" DIGITAL CAMERA\")) || (cp = strstr(model, \"FILE VERSION\"))))",
          "15438:   if (!strncasecmp(model, \"PENTAX\", 6))",
          "15439:     strcpy(make, \"Pentax\");",
          "15440: #ifdef LIBRAW_LIBRARY_BUILD",
          "15441:   remove_trailing_spaces(make, sizeof(make));",
          "15442:   remove_trailing_spaces(model, sizeof(model));",
          "15445:   while (*--cp == ' ')",
          "15448:   while (*--cp == ' ')",
          "15450: #endif",
          "15452:   if (!strncasecmp(model, make, i) && model[i++] == ' ')",
          "15453:     memmove(model, model + i, 64 - i);",
          "15454:   if (!strncmp(model, \"FinePix \", 8))",
          "15455:     strcpy(model, model + 8);",
          "15456:   if (!strncmp(model, \"Digital Camera \", 15))",
          "15457:     strcpy(model, model + 15);",
          "15459:   if (!is_raw)",
          "15460:     goto notraw;",
          "15462:   if (!height)",
          "15463:     height = raw_height;",
          "15464:   if (!width)",
          "15465:     width = raw_width;",
          "15467:   {",
          "15468:     height = 2616;",
          "15469:     width = 3896;",
          "15470:   }",
          "15472:   {",
          "15473:     height = 3124;",
          "15474:     width = 4688;",
          "15475:     filters = 0x16161616;",
          "15476:   }",
          "15477:   if (width == 4352 && (!strcmp(model, \"K-r\") || !strcmp(model, \"K-x\")))",
          "15478:   {",
          "15479:     width = 4309;",
          "15480:     filters = 0x16161616;",
          "15481:   }",
          "15482:   if (width >= 4960 && !strncmp(model, \"K-5\", 3))",
          "15483:   {",
          "15484:     left_margin = 10;",
          "15485:     width = 4950;",
          "15486:     filters = 0x16161616;",
          "15487:   }",
          "15488:   if (width == 6080 && !strcmp(model, \"K-70\"))",
          "15489:   {",
          "15490:     height = 4016;",
          "15491:     top_margin = 32;",
          "15492:     width = 6020;",
          "15493:     left_margin = 60;",
          "15494:   }",
          "15495:   if (width == 4736 && !strcmp(model, \"K-7\"))",
          "15496:   {",
          "15497:     height = 3122;",
          "15498:     width = 4684;",
          "15499:     filters = 0x16161616;",
          "15500:     top_margin = 2;",
          "15501:   }",
          "15503:   {",
          "15504:     left_margin = 4;",
          "15505:     width = 6040;",
          "15506:   }",
          "15507:   if (width == 6080 && !strcmp(model, \"K-3\"))",
          "15508:   {",
          "15509:     left_margin = 4;",
          "15510:     width = 6040;",
          "15511:   }",
          "15512:   if (width == 7424 && !strcmp(model, \"645D\"))",
          "15513:   {",
          "15514:     height = 5502;",
          "15515:     width = 7328;",
          "15516:     filters = 0x61616161;",
          "15517:     top_margin = 29;",
          "15518:     left_margin = 48;",
          "15519:   }",
          "15521:     width = 4014;",
          "15522:   if (dng_version)",
          "15523:   {",
          "15524:     if (filters == UINT_MAX)",
          "15525:       filters = 0;",
          "15526:     if (filters)",
          "15527:       is_raw *= tiff_samples;",
          "15528:     else",
          "15529:       colors = tiff_samples;",
          "15530:     switch (tiff_compress)",
          "15531:     {",
          "15533:     case 1:",
          "15534:       load_raw = &CLASS packed_dng_load_raw;",
          "15535:       break;",
          "15536:     case 7:",
          "15537:       load_raw = &CLASS lossless_dng_load_raw;",
          "15538:       break;",
          "15539: #ifdef LIBRAW_LIBRARY_BUILD",
          "15540:     case 8:",
          "15541:       load_raw = &CLASS deflate_dng_load_raw;",
          "15542:       break;",
          "15543: #endif",
          "15544:     case 34892:",
          "15545:       load_raw = &CLASS lossy_dng_load_raw;",
          "15546:       break;",
          "15547:     default:",
          "15548:       load_raw = 0;",
          "15549:     }",
          "15550:     if (!strncmp(make, \"Canon\", 5) && unique_id)",
          "15551:     {",
          "15552:       for (i = 0; i < sizeof unique / sizeof *unique; i++)",
          "15553:         if (unique_id == 0x80000000 + unique[i].id)",
          "15554:         {",
          "15555:           strcpy(model, unique[i].t_model);",
          "15556:           break;",
          "15557:         }",
          "15558:     }",
          "15559:     if (!strncasecmp(make, \"Sony\", 4) && unique_id)",
          "15560:     {",
          "15561:       for (i = 0; i < sizeof sonique / sizeof *sonique; i++)",
          "15562:         if (unique_id == sonique[i].id)",
          "15563:         {",
          "15564:           strcpy(model, sonique[i].t_model);",
          "15565:           break;",
          "15566:         }",
          "15567:     }",
          "15570:   if (!strncmp(make, \"Canon\", 5) && !fsize && tiff_bps != 15)",
          "15571:   {",
          "15574:     for (i = 0; i < sizeof canon / sizeof *canon; i++)",
          "15575:       if (raw_width == canon[i][0] && raw_height == canon[i][1])",
          "15576:       {",
          "15577:         width = raw_width - (left_margin = canon[i][2]);",
          "15578:         height = raw_height - (top_margin = canon[i][3]);",
          "15579:         width -= canon[i][4];",
          "15580:         height -= canon[i][5];",
          "15581:         mask[0][1] = canon[i][6];",
          "15582:         mask[0][3] = -canon[i][7];",
          "15583:         mask[1][1] = canon[i][8];",
          "15584:         mask[1][3] = -canon[i][9];",
          "15585:         if (canon[i][10])",
          "15586:           filters = canon[i][10] * 0x01010101;",
          "15587:       }",
          "15588:     if ((unique_id | 0x20000) == 0x2720000)",
          "15589:     {",
          "15594:   if (!strncmp(make, \"Canon\", 5) && unique_id)",
          "15595:   {",
          "15596:     for (i = 0; i < sizeof unique / sizeof *unique; i++)",
          "15597:       if (unique_id == 0x80000000 + unique[i].id)",
          "15598:       {",
          "15599:         adobe_coeff(\"Canon\", unique[i].t_model);",
          "15600:         strcpy(model, unique[i].t_model);",
          "15601:       }",
          "15602:   }",
          "15604:   if (!strncasecmp(make, \"Sony\", 4) && unique_id)",
          "15605:   {",
          "15606:     for (i = 0; i < sizeof sonique / sizeof *sonique; i++)",
          "15607:       if (unique_id == sonique[i].id)",
          "15608:       {",
          "15609:         adobe_coeff(\"Sony\", sonique[i].t_model);",
          "15610:         strcpy(model, sonique[i].t_model);",
          "15611:       }",
          "15612:   }",
          "15614:   if (!strncmp(make, \"Nikon\", 5))",
          "15615:   {",
          "15624:   if (!strcmp(model, \"KAI-0340\") && find_green(16, 16, 3840, 5120) < 25)",
          "15625:   {",
          "15628:     strcpy(model, \"C603\");",
          "15633:   if (is_foveon)",
          "15634:   {",
          "15635:     if (height * 2 < width)",
          "15636:       pixel_aspect = 0.5;",
          "15637:     if (height > width)",
          "15638:       pixel_aspect = 2;",
          "15641:     if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F))",
          "15645:   else if (!strncmp(make, \"Pentax\", 6))",
          "15647:     if (!strncmp(model, \"K-1\", 3))",
          "15649:       top_margin = 18;",
          "15650:       height = raw_height - top_margin;",
          "15651:       if (raw_width == 7392)",
          "15652:       {",
          "15653:         left_margin = 6;",
          "15654:         width = 7376;",
          "15655:       }",
          "15658:   else if (!strncmp(make, \"Canon\", 5) && tiff_bps == 15)",
          "15659:   {",
          "15660:     switch (width)",
          "15661:     {",
          "15662:     case 3344:",
          "15663:       width -= 66;",
          "15664:     case 3872:",
          "15665:       width -= 6;",
          "15667:     if (height > width)",
          "15668:     {",
          "15669:       SWAP(height, width);",
          "15670:       SWAP(raw_height, raw_width);",
          "15673:     {",
          "15674:       raw_width = width = 6480;",
          "15675:       raw_height = height = 4320;",
          "15676:     }",
          "15680:   }",
          "15681:   else if (!strcmp(model, \"PowerShot 600\"))",
          "15682:   {",
          "15684:     width = 854;",
          "15689:   }",
          "15690:   else if (!strcmp(model, \"PowerShot A5\") || !strcmp(model, \"PowerShot A5 Zoom\"))",
          "15691:   {",
          "15693:     width = 960;",
          "15695:     pixel_aspect = 256 / 235.0;",
          "15698:   }",
          "15699:   else if (!strcmp(model, \"PowerShot A50\"))",
          "15700:   {",
          "15701:     height = 968;",
          "15702:     width = 1290;",
          "15706:   }",
          "15707:   else if (!strcmp(model, \"PowerShot Pro70\"))",
          "15708:   {",
          "15710:     width = 1552;",
          "15712:   canon_a5:",
          "15717:   }",
          "15718:   else if (!strcmp(model, \"PowerShot Pro90 IS\") || !strcmp(model, \"PowerShot G1\"))",
          "15719:   {",
          "15722:   }",
          "15723:   else if (!strcmp(model, \"PowerShot A610\"))",
          "15724:   {",
          "15725:     if (canon_s2is())",
          "15726:       strcpy(model + 10, \"S2 IS\");",
          "15727:   }",
          "15728:   else if (!strcmp(model, \"PowerShot SX220 HS\"))",
          "15729:   {",
          "15731:     top_margin = 16;",
          "15733:   }",
          "15734:   else if (!strcmp(model, \"PowerShot S120\"))",
          "15735:   {",
          "15736:     raw_width = 4192;",
          "15737:     raw_height = 3062;",
          "15738:     width = 4022;",
          "15739:     height = 3016;",
          "15740:     mask[0][0] = top_margin = 31;",
          "15741:     mask[0][2] = top_margin + height;",
          "15742:     left_margin = 120;",
          "15743:     mask[0][1] = 23;",
          "15744:     mask[0][3] = 72;",
          "15745:   }",
          "15746:   else if (!strcmp(model, \"PowerShot G16\"))",
          "15747:   {",
          "15748:     mask[0][0] = 0;",
          "15749:     mask[0][2] = 80;",
          "15750:     mask[0][1] = 0;",
          "15751:     mask[0][3] = 16;",
          "15752:     top_margin = 29;",
          "15753:     left_margin = 120;",
          "15754:     width = raw_width - left_margin - 48;",
          "15755:     height = raw_height - top_margin - 14;",
          "15756:   }",
          "15757:   else if (!strcmp(model, \"PowerShot SX50 HS\"))",
          "15758:   {",
          "15760:   }",
          "15761:   else if (!strcmp(model, \"EOS D2000C\"))",
          "15762:   {",
          "15765:   }",
          "15766:   else if (!strcmp(model, \"D1\"))",
          "15767:   {",
          "15768:     cam_mul[0] *= 256 / 527.0;",
          "15769:     cam_mul[2] *= 256 / 317.0;",
          "15770:   }",
          "15771:   else if (!strcmp(model, \"D1X\"))",
          "15772:   {",
          "15775:   }",
          "15776:   else if (!strcmp(model, \"D40X\") || !strcmp(model, \"D60\") || !strcmp(model, \"D80\") || !strcmp(model, \"D3000\"))",
          "15777:   {",
          "15779:     width -= 4;",
          "15780:   }",
          "15781:   else if (!strcmp(model, \"D3\") || !strcmp(model, \"D3S\") || !strcmp(model, \"D700\"))",
          "15782:   {",
          "15785:   }",
          "15786:   else if (!strcmp(model, \"D3100\"))",
          "15787:   {",
          "15790:   }",
          "15791:   else if (!strcmp(model, \"D5000\") || !strcmp(model, \"D90\"))",
          "15792:   {",
          "15794:   }",
          "15795:   else if (!strcmp(model, \"D5100\") || !strcmp(model, \"D7000\") || !strcmp(model, \"COOLPIX A\"))",
          "15796:   {",
          "15798:   }",
          "15799:   else if (!strcmp(model, \"D3200\") || !strncmp(model, \"D6\", 2) || !strncmp(model, \"D800\", 4))",
          "15800:   {",
          "15802:   }",
          "15803:   else if (!strcmp(model, \"D4\") || !strcmp(model, \"Df\"))",
          "15804:   {",
          "15807:   }",
          "15808:   else if (!strncmp(model, \"D40\", 3) || !strncmp(model, \"D50\", 3) || !strncmp(model, \"D70\", 3))",
          "15809:   {",
          "15811:   }",
          "15812:   else if (!strcmp(model, \"D100\"))",
          "15813:   {",
          "15816:   }",
          "15817:   else if (!strcmp(model, \"D200\"))",
          "15818:   {",
          "15822:   }",
          "15823:   else if (!strncmp(model, \"D2H\", 3))",
          "15824:   {",
          "15827:   }",
          "15828:   else if (!strncmp(model, \"D2X\", 3))",
          "15829:   {",
          "15830:     if (width == 3264)",
          "15831:       width -= 32;",
          "15832:     else",
          "15833:       width -= 8;",
          "15834:   }",
          "15835:   else if (!strncmp(model, \"D300\", 4))",
          "15836:   {",
          "15838:   }",
          "15839:   else if (!strncmp(make, \"Nikon\", 5) && raw_width == 4032)",
          "15840:   {",
          "15841:     if (!strcmp(model, \"COOLPIX P7700\"))",
          "15842:     {",
          "15843:       adobe_coeff(\"Nikon\", \"COOLPIX P7700\");",
          "15844:       maximum = 65504;",
          "15845:       load_flags = 0;",
          "15846:     }",
          "15847:     else if (!strcmp(model, \"COOLPIX P7800\"))",
          "15848:     {",
          "15849:       adobe_coeff(\"Nikon\", \"COOLPIX P7800\");",
          "15850:       maximum = 65504;",
          "15851:       load_flags = 0;",
          "15852:     }",
          "15853:     else if (!strcmp(model, \"COOLPIX P340\"))",
          "15854:       load_flags = 0;",
          "15855:   }",
          "15856:   else if (!strncmp(model, \"COOLPIX P\", 9) && raw_width != 4032)",
          "15857:   {",
          "15860:     if (model[9] == '7' && (iso_speed >= 400 || iso_speed == 0) && !strstr(software, \"V1.2\"))",
          "15862:   }",
          "15863:   else if (!strncmp(model, \"1 \", 2))",
          "15864:   {",
          "15866:   }",
          "15867:   else if (fsize == 1581060)",
          "15868:   {",
          "15873:   }",
          "15874:   else if (fsize == 3178560)",
          "15875:   {",
          "15878:   }",
          "15879:   else if (fsize == 4771840)",
          "15880:   {",
          "15882:       strcpy(model, \"E995\");",
          "15883:     if (strcmp(model, \"E995\"))",
          "15884:     {",
          "15891:   }",
          "15892:   else if (fsize == 2940928)",
          "15893:   {",
          "15895:       strcpy(model, \"E2500\");",
          "15896:     if (!strcmp(model, \"E2500\"))",
          "15897:     {",
          "15903:   }",
          "15904:   else if (fsize == 4775936)",
          "15905:   {",
          "15906:     if (!timestamp)",
          "15907:       nikon_3700();",
          "15908:     if (model[0] == 'E' && atoi(model + 1) < 3700)",
          "15910:     if (!strcmp(model, \"Optio 33WR\"))",
          "15911:     {",
          "15915:     if (make[0] == 'O')",
          "15916:     {",
          "15917:       i = find_green(12, 32, 1188864, 3576832);",
          "15918:       c = find_green(12, 32, 2383920, 2387016);",
          "15919:       if (abs(i) < abs(c))",
          "15920:       {",
          "15921:         SWAP(i, c);",
          "15922:         load_flags = 24;",
          "15924:       if (i < 0)",
          "15925:         filters = 0x61616161;",
          "15927:   }",
          "15928:   else if (fsize == 5869568)",
          "15929:   {",
          "15930:     if (!timestamp && minolta_z2())",
          "15931:     {",
          "15932:       strcpy(make, \"Minolta\");",
          "15933:       strcpy(model, \"DiMAGE Z2\");",
          "15935:     load_flags = 6 + 24 * (make[0] == 'M');",
          "15936:   }",
          "15937:   else if (fsize == 6291456)",
          "15938:   {",
          "15939:     fseek(ifp, 0x300000, SEEK_SET);",
          "15940:     if ((order = guess_byte_order(0x10000)) == 0x4d4d)",
          "15941:     {",
          "15945:       strcpy(make, \"ISG\");",
          "15948:   }",
          "15949:   else if (!strncmp(make, \"Fujifilm\", 8))",
          "15950:   {",
          "15951:     if (!strcmp(model + 7, \"S2Pro\"))",
          "15952:     {",
          "15953:       strcpy(model, \"S2Pro\");",
          "15955:       width = 2880;",
          "15957:     }",
          "15958:     else if (load_raw != &CLASS packed_load_raw)",
          "15961:     left_margin = (raw_width - width) >> 2 << 1;",
          "15962:     if (width == 2848 || width == 3664)",
          "15963:       filters = 0x16161616;",
          "15964:     if (width == 4032 || width == 4952)",
          "15965:       left_margin = 0;",
          "15966:     if (width == 3328 && (width -= 66))",
          "15967:       left_margin = 34;",
          "15968:     if (width == 4936)",
          "15969:       left_margin = 4;",
          "15970:     if (width == 6032)",
          "15971:       left_margin = 0;",
          "15972:     if (!strcmp(model, \"HS50EXR\") || !strcmp(model, \"F900EXR\"))",
          "15973:     {",
          "15978:     if (!strcmp(model, \"S5500\"))",
          "15979:     {",
          "15980:       height -= (top_margin = 6);",
          "15981:     }",
          "15982:     if (fuji_layout)",
          "15983:       raw_width *= is_raw;",
          "15985:       FORC(36)((char *)xtrans)[c] = xtrans_abs[(c / 6 + top_margin) % 6][(c + left_margin) % 6];",
          "15986:   }",
          "15987:   else if (!strcmp(model, \"KD-400Z\"))",
          "15988:   {",
          "15990:     width = 2312;",
          "15993:   }",
          "15994:   else if (!strcmp(model, \"KD-510Z\"))",
          "15995:   {",
          "15997:   }",
          "15998:   else if (!strncasecmp(make, \"Minolta\", 7))",
          "15999:   {",
          "16002:     if (!strncmp(model, \"DiMAGE A\", 8))",
          "16003:     {",
          "16004:       if (!strcmp(model, \"DiMAGE A200\"))",
          "16005:         filters = 0x49494949;",
          "16008:     }",
          "16009:     else if (!strncmp(model, \"ALPHA\", 5) || !strncmp(model, \"DYNAX\", 5) || !strncmp(model, \"MAXXUM\", 6))",
          "16010:     {",
          "16011:       sprintf(model + 20, \"DYNAX %-10s\", model + 6 + (model[0] == 'M'));",
          "16012:       adobe_coeff(make, model + 20);",
          "16014:     }",
          "16015:     else if (!strncmp(model, \"DiMAGE G\", 8))",
          "16016:     {",
          "16017:       if (model[8] == '4')",
          "16018:       {",
          "16019:         height = 1716;",
          "16020:         width = 2304;",
          "16021:       }",
          "16022:       else if (model[8] == '5')",
          "16023:       {",
          "16024:       konica_510z:",
          "16025:         height = 1956;",
          "16026:         width = 2607;",
          "16027:         raw_width = 2624;",
          "16028:       }",
          "16029:       else if (model[8] == '6')",
          "16030:       {",
          "16031:         height = 2136;",
          "16032:         width = 2848;",
          "16036:     konica_400z:",
          "16041:   }",
          "16042:   else if (!strcmp(model, \"*ist D\"))",
          "16043:   {",
          "16046:   }",
          "16047:   else if (!strcmp(model, \"*ist DS\"))",
          "16048:   {",
          "16050:   }",
          "16051:   else if (!strncmp(make, \"Samsung\", 7) && raw_width == 4704)",
          "16052:   {",
          "16056:   }",
          "16057:   else if (!strncmp(make, \"Samsung\", 7) && !strcmp(model, \"NX3000\"))",
          "16058:   {",
          "16065:   }",
          "16066:   else if (!strncmp(make, \"Samsung\", 7) && raw_height == 3714)",
          "16067:   {",
          "16074:   }",
          "16075:   else if (!strncmp(make, \"Samsung\", 7) && raw_width == 5632)",
          "16076:   {",
          "16080:     width = 5574 - (left_margin = 32 + tiff_bps);",
          "16081:     if (tiff_bps == 12)",
          "16082:       load_flags = 80;",
          "16083:   }",
          "16084:   else if (!strncmp(make, \"Samsung\", 7) && raw_width == 5664)",
          "16085:   {",
          "16090:   }",
          "16091:   else if (!strncmp(make, \"Samsung\", 7) && raw_width == 6496)",
          "16092:   {",
          "16095:     if (!black && !cblack[0] && !cblack[1] && !cblack[2] && !cblack[3])",
          "16097:       black = 1 << (tiff_bps - 7);",
          "16098:   }",
          "16099:   else if (!strcmp(model, \"EX1\"))",
          "16100:   {",
          "16104:     if ((width -= 6) > 3682)",
          "16105:     {",
          "16107:       width -= 46;",
          "16110:   }",
          "16111:   else if (!strcmp(model, \"WB2000\"))",
          "16112:   {",
          "16116:     if ((width -= 10) > 3718)",
          "16117:     {",
          "16119:       width -= 56;",
          "16122:   }",
          "16123:   else if (strstr(model, \"WB550\"))",
          "16124:   {",
          "16125:     strcpy(model, \"WB550\");",
          "16126:   }",
          "16127:   else if (!strcmp(model, \"EX2F\"))",
          "16128:   {",
          "16130:     width = 4040;",
          "16132:     left_margin = 24;",
          "16136:   }",
          "16137:   else if (!strcmp(model, \"STV680 VGA\"))",
          "16138:   {",
          "16140:   }",
          "16141:   else if (!strcmp(model, \"N95\"))",
          "16142:   {",
          "16144:   }",
          "16145:   else if (!strcmp(model, \"640x480\"))",
          "16146:   {",
          "16147:     gamma_curve(0.45, 4.5, 1, 255);",
          "16148:   }",
          "16149:   else if (!strncmp(make, \"Hasselblad\", 10))",
          "16150:   {",
          "16153:     if (raw_width == 7262)",
          "16154:     {",
          "16156:       width = 7248;",
          "16157:       top_margin = 4;",
          "16160:       if (!strncasecmp(model, \"H3D\", 3))",
          "16161:       {",
          "16162:         adobe_coeff(\"Hasselblad\", \"H3DII-39\");",
          "16163:         strcpy(model, \"H3DII-39\");",
          "16164:       }",
          "16165:     }",
          "16166:     else if (raw_width == 7410 || raw_width == 8282)",
          "16167:     {",
          "16169:       width -= 82;",
          "16170:       top_margin = 4;",
          "16173:       adobe_coeff(\"Hasselblad\", \"H4D-40\");",
          "16174:       strcpy(model, \"H4D-40\");",
          "16176:     else if (raw_width == 8384) // X1D",
          "16178:       top_margin = 96;",
          "16179:       height -= 96;",
          "16180:       left_margin = 48;",
          "16181:       width -= 106;",
          "16182:       adobe_coeff(\"Hasselblad\", \"X1D\");",
          "16184:     else if (raw_width == 9044)",
          "16185:     {",
          "16186:       if (black > 500)",
          "16187:       {",
          "16188:         top_margin = 12;",
          "16189:         left_margin = 44;",
          "16190:         width = 8956;",
          "16191:         height = 6708;",
          "16192:         memset(cblack, 0, sizeof(cblack));",
          "16193:         adobe_coeff(\"Hasselblad\", \"H4D-60\");",
          "16194:         strcpy(model, \"H4D-60\");",
          "16195:         black = 512;",
          "16196:       }",
          "16198:       {",
          "16199:         height = 6716;",
          "16200:         width = 8964;",
          "16201:         top_margin = 8;",
          "16202:         left_margin = 40;",
          "16203:         black += load_flags = 256;",
          "16204:         maximum = 0x8101;",
          "16205:         strcpy(model, \"H3DII-60\");",
          "16206:       }",
          "16207:     }",
          "16208:     else if (raw_width == 4090)",
          "16209:     {",
          "16210:       strcpy(model, \"V96C\");",
          "16214:     }",
          "16215:     else if (raw_width == 8282 && raw_height == 6240)",
          "16216:     {",
          "16217:       if (!strncasecmp(model, \"H5D\", 3))",
          "16218:       {",
          "16220:         left_margin = 54;",
          "16221:         top_margin = 16;",
          "16222:         width = 8176;",
          "16223:         height = 6132;",
          "16224:         black = 256;",
          "16225:         strcpy(model, \"H5D-50\");",
          "16226:       }",
          "16227:       else if (!strncasecmp(model, \"H3D\", 3))",
          "16228:       {",
          "16229:         black = 0;",
          "16230:         left_margin = 54;",
          "16231:         top_margin = 16;",
          "16232:         width = 8176;",
          "16233:         height = 6132;",
          "16234:         memset(cblack, 0, sizeof(cblack));",
          "16235:         adobe_coeff(\"Hasselblad\", \"H3D-50\");",
          "16236:         strcpy(model, \"H3D-50\");",
          "16237:       }",
          "16238:     }",
          "16239:     else if (raw_width == 8374 && raw_height == 6304)",
          "16240:     {",
          "16247:       strcpy(model, \"H5D-50c\");",
          "16249:     if (tiff_samples > 1)",
          "16250:     {",
          "16251:       is_raw = tiff_samples + 1;",
          "16252:       if (!shot_select && !half_size)",
          "16253:         filters = 0;",
          "16255:   }",
          "16256:   else if (!strncmp(make, \"Sinar\", 5))",
          "16257:   {",
          "16258:     if (!load_raw)",
          "16259:       load_raw = &CLASS unpacked_load_raw;",
          "16260:     if (is_raw > 1 && !shot_select && !half_size)",
          "16261:       filters = 0;",
          "16263:   }",
          "16264:   else if (!strncmp(make, \"Leaf\", 4))",
          "16265:   {",
          "16267:     fseek(ifp, data_offset, SEEK_SET);",
          "16268:     if (ljpeg_start(&jh, 1) && jh.bits == 15)",
          "16270:     if (tiff_samples > 1)",
          "16271:       filters = 0;",
          "16272:     if (tiff_samples > 1 || tile_length < raw_height)",
          "16273:     {",
          "16277:     if ((width | height) == 2048)",
          "16278:     {",
          "16279:       if (tiff_samples == 1)",
          "16280:       {",
          "16281:         filters = 1;",
          "16282:         strcpy(cdesc, \"RBTG\");",
          "16283:         strcpy(model, \"CatchLight\");",
          "16284:         top_margin = 8;",
          "16285:         left_margin = 18;",
          "16286:         height = 2032;",
          "16287:         width = 2016;",
          "16288:       }",
          "16289:       else",
          "16290:       {",
          "16291:         strcpy(model, \"DCB2\");",
          "16292:         top_margin = 10;",
          "16293:         left_margin = 16;",
          "16294:         height = 2028;",
          "16295:         width = 2022;",
          "16296:       }",
          "16297:     }",
          "16298:     else if (width + height == 3144 + 2060)",
          "16299:     {",
          "16300:       if (!model[0])",
          "16301:         strcpy(model, \"Cantare\");",
          "16302:       if (width > height)",
          "16303:       {",
          "16304:         top_margin = 6;",
          "16305:         left_margin = 32;",
          "16306:         height = 2048;",
          "16307:         width = 3072;",
          "16308:         filters = 0x61616161;",
          "16309:       }",
          "16310:       else",
          "16311:       {",
          "16312:         left_margin = 6;",
          "16313:         top_margin = 32;",
          "16314:         width = 2048;",
          "16315:         height = 3072;",
          "16316:         filters = 0x16161616;",
          "16317:       }",
          "16318:       if (!cam_mul[0] || model[0] == 'V')",
          "16319:         filters = 0;",
          "16320:       else",
          "16321:         is_raw = tiff_samples;",
          "16322:     }",
          "16323:     else if (width == 2116)",
          "16324:     {",
          "16325:       strcpy(model, \"Valeo 6\");",
          "16329:     }",
          "16330:     else if (width == 3171)",
          "16331:     {",
          "16332:       strcpy(model, \"Valeo 6\");",
          "16337:   }",
          "16338:   else if (!strncmp(make, \"Leica\", 5) || !strncmp(make, \"Panasonic\", 9) || !strncasecmp(make, \"YUNEEC\", 6))",
          "16339:   {",
          "16340:     if (raw_width > 0 && ((flen - data_offset) / (raw_width * 8 / 7) == raw_height))",
          "16342:     if (!load_raw)",
          "16343:     {",
          "16348:     if ((height += 12) > raw_height)",
          "16349:       height = raw_height;",
          "16350:     for (i = 0; i < sizeof pana / sizeof *pana; i++)",
          "16351:       if (raw_width == pana[i][0] && raw_height == pana[i][1])",
          "16352:       {",
          "16353:         left_margin = pana[i][2];",
          "16354:         top_margin = pana[i][3];",
          "16355:         width += pana[i][4];",
          "16356:         height += pana[i][5];",
          "16357:       }",
          "16358:     filters = 0x01010101 * (uchar) \"\\x94\\x61\\x49\\x16\"[((filters - 1) ^ (left_margin & 1) ^ (top_margin << 1)) & 3];",
          "16359:   }",
          "16360:   else if (!strcmp(model, \"C770UZ\"))",
          "16361:   {",
          "16363:     width = 2304;",
          "16367:   }",
          "16368:   else if (!strncmp(make, \"Olympus\", 7))",
          "16369:   {",
          "16371:     if (exif_cfa)",
          "16372:       filters = exif_cfa;",
          "16373:     if (width == 4100)",
          "16374:       width -= 4;",
          "16375:     if (width == 4080)",
          "16376:       width -= 24;",
          "16377:     if (width == 9280)",
          "16378:     {",
          "16379:       width -= 6;",
          "16380:       height -= 6;",
          "16381:     }",
          "16385:     if (!strcmp(model, \"E-300\") || !strcmp(model, \"E-500\"))",
          "16386:     {",
          "16388:       if (load_raw == &CLASS unpacked_load_raw)",
          "16389:       {",
          "16390:         maximum = 0xfc3;",
          "16391:         memset(cblack, 0, sizeof cblack);",
          "16393:     }",
          "16394:     else if (!strcmp(model, \"STYLUS1\"))",
          "16395:     {",
          "16398:     }",
          "16399:     else if (!strcmp(model, \"E-330\"))",
          "16400:     {",
          "16403:         maximum = 0xf79;",
          "16404:     }",
          "16405:     else if (!strcmp(model, \"SP550UZ\"))",
          "16406:     {",
          "16409:       thumb_width = 640;",
          "16410:     }",
          "16411:     else if (!strcmp(model, \"TG-4\"))",
          "16412:     {",
          "16415:   }",
          "16416:   else if (!strcmp(model, \"N Digital\"))",
          "16417:   {",
          "16419:     width = 3072;",
          "16423:   }",
          "16424:   else if (!strcmp(model, \"DSC-F828\"))",
          "16425:   {",
          "",
          "---------------",
          "--- Hunk 104 ---",
          "[Context before]",
          "15086:     load_raw = &CLASS sony_load_raw;",
          "15087:     filters = 0x9c9c9c9c;",
          "15088:     colors = 4;",
          "15091:     width = 3109;",
          "15092:     left_margin = 59;",
          "15093:     mask[0][1] = 9;",
          "15094:     data_offset = 787392;",
          "15095:     load_raw = &CLASS sony_load_raw;",
          "15097:     width = 3925;",
          "15098:     order = 0x4d4d;",
          "15100:     width -= 32;",
          "15104:     width -= height > 3664 ? 8 : 32;",
          "15106:     width -= 24;",
          "15108:       width -= 6;",
          "15110:     width -= 30;",
          "15112:     width -= 32;",
          "15115:       height--;",
          "15116:       width = ++raw_width;",
          "15118:       height -= 4;",
          "15120:       order = 0x4d4d;",
          "15121:       load_flags = 2;",
          "15122:     }",
          "15123:     filters = 0x61616161;",
          "15125:     height -= 4;",
          "15127:     height -= top_margin = 4;",
          "15128:     width -= left_margin = 32;",
          "15132:     order = 0x4949;",
          "15140:     load_flags = tiff_bps > 16;",
          "15141:     tiff_bps = 8;",
          "15143:     data_offset = data_offset < 0x15000 ? 0x15000 : 0x17000;",
          "15144:     load_raw = &CLASS packed_load_raw;",
          "15150:       width -= 4;",
          "15151:       left_margin = 2;",
          "15155:       black = 214;",
          "15156:       goto bw;",
          "15159:       filters = 0;",
          "15160:     }",
          "15165:       data_offset = 15424;",
          "15166:     }",
          "15168:       raw_height = 2 + (height = 242);",
          "15169:       if (!strncmp(model, \"DC290\", 5))",
          "15170:         iso_speed = 100;",
          "15171:       if (!strncmp(model, \"DC280\", 5))",
          "15172:         iso_speed = 70;",
          "15179:       }",
          "15180:       top_margin = left_margin = 1;",
          "15181:       colors = 4;",
          "",
          "[Removed Lines]",
          "15089:     strcpy (cdesc, \"RGBE\");",
          "15090:   } else if (!strcmp(model,\"DSC-V3\")) {",
          "15096:   } else if (!strncmp(make,\"Sony\",4) && raw_width == 3984) {",
          "15099:   } else if (!strncmp(make,\"Sony\",4) && raw_width == 4288) {",
          "15101:   } else if (!strncmp(make,\"Sony\",4) && raw_width == 4928) {",
          "15102:     if (height < 3280) width -= 8;",
          "15103:   } else if (!strncmp(make,\"Sony\",4) && raw_width == 5504) { // ILCE-3000//5000",
          "15105:   } else if (!strncmp(make,\"Sony\",4) && raw_width == 6048) {",
          "15107:     if (strstr(model,\"RX1\") || strstr(model,\"A99\"))",
          "15109:   } else if (!strncmp(make,\"Sony\",4) && raw_width == 7392) {",
          "15111:   } else if (!strncmp(make,\"Sony\",4) && raw_width == 8000) {",
          "15113:   } else if (!strcmp(model,\"DSLR-A100\")) {",
          "15114:     if (width == 3880) {",
          "15117:     } else {",
          "15119:       width  -= 4;",
          "15124:   } else if (!strcmp(model,\"DSLR-A350\")) {",
          "15126:   } else if (!strcmp(model,\"PIXL\")) {",
          "15129:     gamma_curve (0, 7, 1, 255);",
          "15130:   } else if (!strcmp(model,\"C603\") || !strcmp(model,\"C330\")",
          "15131:  || !strcmp(model,\"12MP\")) {",
          "15133:     if (filters && data_offset) {",
          "15134:       fseek (ifp, data_offset < 4096 ? 168 : 5252, SEEK_SET);",
          "15135:       read_shorts (curve, 256);",
          "15136:     } else gamma_curve (0, 3.875, 1, 255);",
          "15137:     load_raw  =  filters   ? &CLASS eight_bit_load_raw :",
          "15138:       strcmp(model,\"C330\") ? &CLASS kodak_c603_load_raw :",
          "15139:         &CLASS kodak_c330_load_raw;",
          "15142:   } else if (!strncasecmp(model,\"EasyShare\",9)) {",
          "15145:   } else if (!strncasecmp(make,\"Kodak\",5)) {",
          "15146:     if (filters == UINT_MAX) filters = 0x61616161;",
          "15147:     if (!strncmp(model,\"NC2000\",6) ||",
          "15148:  !strncmp(model,\"EOSDCS\",6) ||",
          "15149:  !strncmp(model,\"DCS4\",4)) {",
          "15152:       if (model[6] == ' ') model[6] = 0;",
          "15153:       if (!strcmp(model,\"DCS460A\")) goto bw;",
          "15154:     } else if (!strcmp(model,\"DCS660M\")) {",
          "15157:     } else if (!strcmp(model,\"DCS760M\")) {",
          "15158: bw:   colors = 1;",
          "15161:     if (!strcmp(model+4,\"20X\"))",
          "15162:       strcpy (cdesc, \"MYCY\");",
          "15163:     if (strstr(model,\"DC25\")) {",
          "15164:       strcpy (model, \"DC25\");",
          "15167:     if (!strncmp(model,\"DC2\",3)) {",
          "15173:       if (flen < 100000) {",
          "15174:  raw_width = 256; width = 249;",
          "15175:  pixel_aspect = (4.0*height) / (3.0*width);",
          "15176:       } else {",
          "15177:  raw_width = 512; width = 501;",
          "15178:  pixel_aspect = (493.0*height) / (373.0*width);",
          "",
          "[Added Lines]",
          "16433:     strcpy(cdesc, \"RGBE\");",
          "16434:   }",
          "16435:   else if (!strcmp(model, \"DSC-V3\"))",
          "16436:   {",
          "16442:   }",
          "16443:   else if (!strncmp(make, \"Sony\", 4) && raw_width == 3984)",
          "16444:   {",
          "16447:   }",
          "16448:   else if (!strncmp(make, \"Sony\", 4) && raw_width == 4288)",
          "16449:   {",
          "16451:   }",
          "16452:   else if (!strncmp(make, \"Sony\", 4) && raw_width == 4928)",
          "16453:   {",
          "16454:     if (height < 3280)",
          "16455:       width -= 8;",
          "16456:   }",
          "16457:   else if (!strncmp(make, \"Sony\", 4) && raw_width == 5504)",
          "16458:   { // ILCE-3000//5000",
          "16460:   }",
          "16461:   else if (!strncmp(make, \"Sony\", 4) && raw_width == 6048)",
          "16462:   {",
          "16464:     if (strstr(model, \"RX1\") || strstr(model, \"A99\"))",
          "16466:   }",
          "16467:   else if (!strncmp(make, \"Sony\", 4) && raw_width == 7392)",
          "16468:   {",
          "16470:   }",
          "16471:   else if (!strncmp(make, \"Sony\", 4) && raw_width == 8000)",
          "16472:   {",
          "16474:   }",
          "16475:   else if (!strcmp(model, \"DSLR-A100\"))",
          "16476:   {",
          "16477:     if (width == 3880)",
          "16478:     {",
          "16481:     }",
          "16482:     else",
          "16483:     {",
          "16485:       width -= 4;",
          "16490:   }",
          "16491:   else if (!strcmp(model, \"DSLR-A350\"))",
          "16492:   {",
          "16494:   }",
          "16495:   else if (!strcmp(model, \"PIXL\"))",
          "16496:   {",
          "16499:     gamma_curve(0, 7, 1, 255);",
          "16500:   }",
          "16501:   else if (!strcmp(model, \"C603\") || !strcmp(model, \"C330\") || !strcmp(model, \"12MP\"))",
          "16502:   {",
          "16504:     if (filters && data_offset)",
          "16505:     {",
          "16506:       fseek(ifp, data_offset < 4096 ? 168 : 5252, SEEK_SET);",
          "16507:       read_shorts(curve, 256);",
          "16508:     }",
          "16509:     else",
          "16510:       gamma_curve(0, 3.875, 1, 255);",
          "16511:     load_raw = filters ? &CLASS eight_bit_load_raw",
          "16512:                        : strcmp(model, \"C330\") ? &CLASS kodak_c603_load_raw : &CLASS kodak_c330_load_raw;",
          "16515:   }",
          "16516:   else if (!strncasecmp(model, \"EasyShare\", 9))",
          "16517:   {",
          "16520:   }",
          "16521:   else if (!strncasecmp(make, \"Kodak\", 5))",
          "16522:   {",
          "16523:     if (filters == UINT_MAX)",
          "16524:       filters = 0x61616161;",
          "16525:     if (!strncmp(model, \"NC2000\", 6) || !strncmp(model, \"EOSDCS\", 6) || !strncmp(model, \"DCS4\", 4))",
          "16526:     {",
          "16529:       if (model[6] == ' ')",
          "16530:         model[6] = 0;",
          "16531:       if (!strcmp(model, \"DCS460A\"))",
          "16532:         goto bw;",
          "16533:     }",
          "16534:     else if (!strcmp(model, \"DCS660M\"))",
          "16535:     {",
          "16538:     }",
          "16539:     else if (!strcmp(model, \"DCS760M\"))",
          "16540:     {",
          "16541:     bw:",
          "16542:       colors = 1;",
          "16545:     if (!strcmp(model + 4, \"20X\"))",
          "16546:       strcpy(cdesc, \"MYCY\");",
          "16547:     if (strstr(model, \"DC25\"))",
          "16548:     {",
          "16549:       strcpy(model, \"DC25\");",
          "16552:     if (!strncmp(model, \"DC2\", 3))",
          "16553:     {",
          "16559:       if (flen < 100000)",
          "16560:       {",
          "16561:         raw_width = 256;",
          "16562:         width = 249;",
          "16563:         pixel_aspect = (4.0 * height) / (3.0 * width);",
          "16564:       }",
          "16565:       else",
          "16566:       {",
          "16567:         raw_width = 512;",
          "16568:         width = 501;",
          "16569:         pixel_aspect = (493.0 * height) / (373.0 * width);",
          "",
          "---------------",
          "--- Hunk 105 ---",
          "[Context before]",
          "15185:       pre_mul[2] = 1.209;",
          "15186:       pre_mul[3] = 1.036;",
          "15187:       load_raw = &CLASS eight_bit_load_raw;",
          "15190:       height = 512;",
          "15192:       data_offset = 1152;",
          "15193:       load_raw = &CLASS kodak_radc_load_raw;",
          "15194:       tiff_bps = 12;",
          "15197:       height = 512;",
          "15200:       data_offset = 19712;",
          "15201:       load_raw = &CLASS kodak_radc_load_raw;",
          "15204:       height = 976;",
          "15211:       thumb_height = 128;",
          "15213:       thumb_offset = 6144;",
          "15216:       write_thumb = &CLASS layer_thumb;",
          "15217:       black = 17;",
          "15218:     }",
          "15220:     height = 512;",
          "15222:     data_offset = 3632;",
          "15223:     load_raw = &CLASS kodak_radc_load_raw;",
          "15224:     filters = 0x61616161;",
          "15225:     simple_coeff(2);",
          "15229:     height = get2();",
          "15236:     }",
          "15237:     filters = 0x61616161;",
          "15251:     }",
          "15252:     filters = 0x16161616;",
          "15253:     load_raw = &CLASS rollei_load_raw;",
          "15254:   }",
          "15287:   }",
          "15289:   if (!load_raw || height < 22 || width < 22 ||",
          "15290: #ifdef LIBRAW_LIBRARY_BUILD",
          "15291:       (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)",
          "15292: #else",
          "15294: #endif",
          "15295:       || tiff_samples > 4 || colors > 4 || colors < 1)",
          "15298: #ifdef LIBRAW_LIBRARY_BUILD",
          "15300: #endif",
          "15303:   if (!model[0])",
          "15310:       thumb_height = jh.high;",
          "15311:     }",
          "15312:   }",
          "15314: dng_skip:",
          "15315: #ifdef LIBRAW_LIBRARY_BUILD",
          "15317:   {",
          "15318:     black = imgdata.color.dng_levels.dng_black;",
          "15323:       cblack[i] = imgdata.color.dng_levels.dng_cblack[i];",
          "15324:   }",
          "15325: #endif",
          "",
          "[Removed Lines]",
          "15188:     } else if (!strcmp(model,\"40\")) {",
          "15189:       strcpy (model, \"DC40\");",
          "15191:       width  = 768;",
          "15195:     } else if (strstr(model,\"DC50\")) {",
          "15196:       strcpy (model, \"DC50\");",
          "15198:       width  = 768;",
          "15199:       iso_speed=84;",
          "15202:     } else if (strstr(model,\"DC120\")) {",
          "15203:       strcpy (model, \"DC120\");",
          "15205:       width  = 848;",
          "15206:       iso_speed=160;",
          "15207:       pixel_aspect = height/0.75/width;",
          "15208:       load_raw = tiff_compress == 7 ?",
          "15209:  &CLASS kodak_jpeg_load_raw : &CLASS kodak_dc120_load_raw;",
          "15210:     } else if (!strcmp(model,\"DCS200\")) {",
          "15212:       thumb_width  = 192;",
          "15214:       thumb_misc   = 360;",
          "15215:       iso_speed=140;",
          "15219:   } else if (!strcmp(model,\"Fotoman Pixtura\")) {",
          "15221:     width  = 768;",
          "15226:   } else if (!strncmp(model,\"QuickTake\",9)) {",
          "15227:     if (head[5]) strcpy (model+10, \"200\");",
          "15228:     fseek (ifp, 544, SEEK_SET);",
          "15230:     width  = get2();",
          "15231:     data_offset = (get4(),get2()) == 30 ? 738:736;",
          "15232:     if (height > width) {",
          "15233:       SWAP(height,width);",
          "15234:       fseek (ifp, data_offset-6, SEEK_SET);",
          "15235:       flip = ~get2() & 3 ? 5:6;",
          "15238:   } else if (!strncmp(make,\"Rollei\",6) && !load_raw) {",
          "15239:     switch (raw_width) {",
          "15240:       case 1316:",
          "15241:  height = 1030;",
          "15242:  width  = 1300;",
          "15243:  top_margin  = 1;",
          "15244:  left_margin = 6;",
          "15245:  break;",
          "15246:       case 2568:",
          "15247:  height = 1960;",
          "15248:  width  = 2560;",
          "15249:  top_margin  = 2;",
          "15250:  left_margin = 8;",
          "15255:   else if (!strcmp(model,\"GRAS-50S5C\")) {",
          "15256:    height = 2048;",
          "15257:    width = 2440;",
          "15258:    load_raw = &CLASS unpacked_load_raw;",
          "15259:    data_offset = 0;",
          "15260:    filters = 0x49494949;",
          "15261:    order = 0x4949;",
          "15262:    maximum = 0xfffC;",
          "15263:   } else if (!strcmp(model,\"BB-500CL\")) {",
          "15264:    height = 2058;",
          "15265:    width = 2448;",
          "15266:    load_raw = &CLASS unpacked_load_raw;",
          "15267:    data_offset = 0;",
          "15268:    filters = 0x94949494;",
          "15269:    order = 0x4949;",
          "15270:    maximum = 0x3fff;",
          "15271:   } else if (!strcmp(model,\"BB-500GE\")) {",
          "15272:    height = 2058;",
          "15273:    width = 2456;",
          "15274:    load_raw = &CLASS unpacked_load_raw;",
          "15275:    data_offset = 0;",
          "15276:    filters = 0x94949494;",
          "15277:    order = 0x4949;",
          "15278:    maximum = 0x3fff;",
          "15279:   } else if (!strcmp(model,\"SVS625CL\")) {",
          "15280:    height = 2050;",
          "15281:    width = 2448;",
          "15282:    load_raw = &CLASS unpacked_load_raw;",
          "15283:    data_offset = 0;",
          "15284:    filters = 0x94949494;",
          "15285:    order = 0x4949;",
          "15286:    maximum = 0x0fff;",
          "15293:  tiff_bps > 16",
          "15296:     {",
          "15297:       is_raw = 0;",
          "15299:       RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,1,2);",
          "15301:       return;",
          "15302:     }",
          "15304:     sprintf (model, \"%dx%d\", width, height);",
          "15305:   if (filters == UINT_MAX) filters = 0x94949494;",
          "15306:   if (thumb_offset && !thumb_height) {",
          "15307:     fseek (ifp, thumb_offset, SEEK_SET);",
          "15308:     if (ljpeg_start (&jh, 1)) {",
          "15309:       thumb_width  = jh.wide;",
          "15319:     int ll = LIM(0,",
          "15320:     (sizeof(cblack)/sizeof(cblack[0])),",
          "15321:     (sizeof(imgdata.color.dng_levels.dng_cblack)/sizeof(imgdata.color.dng_levels.dng_cblack[0])));",
          "15322:     for(int i=0; i < ll; i++)",
          "",
          "[Added Lines]",
          "16579:     }",
          "16580:     else if (!strcmp(model, \"40\"))",
          "16581:     {",
          "16582:       strcpy(model, \"DC40\");",
          "16584:       width = 768;",
          "16588:     }",
          "16589:     else if (strstr(model, \"DC50\"))",
          "16590:     {",
          "16591:       strcpy(model, \"DC50\");",
          "16593:       width = 768;",
          "16594:       iso_speed = 84;",
          "16597:     }",
          "16598:     else if (strstr(model, \"DC120\"))",
          "16599:     {",
          "16600:       strcpy(model, \"DC120\");",
          "16602:       width = 848;",
          "16603:       iso_speed = 160;",
          "16604:       pixel_aspect = height / 0.75 / width;",
          "16605:       load_raw = tiff_compress == 7 ? &CLASS kodak_jpeg_load_raw : &CLASS kodak_dc120_load_raw;",
          "16606:     }",
          "16607:     else if (!strcmp(model, \"DCS200\"))",
          "16608:     {",
          "16610:       thumb_width = 192;",
          "16612:       thumb_misc = 360;",
          "16613:       iso_speed = 140;",
          "16617:   }",
          "16618:   else if (!strcmp(model, \"Fotoman Pixtura\"))",
          "16619:   {",
          "16621:     width = 768;",
          "16626:   }",
          "16627:   else if (!strncmp(model, \"QuickTake\", 9))",
          "16628:   {",
          "16629:     if (head[5])",
          "16630:       strcpy(model + 10, \"200\");",
          "16631:     fseek(ifp, 544, SEEK_SET);",
          "16633:     width = get2();",
          "16634:     data_offset = (get4(), get2()) == 30 ? 738 : 736;",
          "16635:     if (height > width)",
          "16636:     {",
          "16637:       SWAP(height, width);",
          "16638:       fseek(ifp, data_offset - 6, SEEK_SET);",
          "16639:       flip = ~get2() & 3 ? 5 : 6;",
          "16642:   }",
          "16643:   else if (!strncmp(make, \"Rollei\", 6) && !load_raw)",
          "16644:   {",
          "16645:     switch (raw_width)",
          "16646:     {",
          "16647:     case 1316:",
          "16648:       height = 1030;",
          "16649:       width = 1300;",
          "16650:       top_margin = 1;",
          "16651:       left_margin = 6;",
          "16652:       break;",
          "16653:     case 2568:",
          "16654:       height = 1960;",
          "16655:       width = 2560;",
          "16656:       top_margin = 2;",
          "16657:       left_margin = 8;",
          "16662:   else if (!strcmp(model, \"GRAS-50S5C\"))",
          "16663:   {",
          "16664:     height = 2048;",
          "16665:     width = 2440;",
          "16666:     load_raw = &CLASS unpacked_load_raw;",
          "16667:     data_offset = 0;",
          "16668:     filters = 0x49494949;",
          "16669:     order = 0x4949;",
          "16670:     maximum = 0xfffC;",
          "16671:   }",
          "16672:   else if (!strcmp(model, \"BB-500CL\"))",
          "16673:   {",
          "16674:     height = 2058;",
          "16675:     width = 2448;",
          "16676:     load_raw = &CLASS unpacked_load_raw;",
          "16677:     data_offset = 0;",
          "16678:     filters = 0x94949494;",
          "16679:     order = 0x4949;",
          "16680:     maximum = 0x3fff;",
          "16681:   }",
          "16682:   else if (!strcmp(model, \"BB-500GE\"))",
          "16683:   {",
          "16684:     height = 2058;",
          "16685:     width = 2456;",
          "16686:     load_raw = &CLASS unpacked_load_raw;",
          "16687:     data_offset = 0;",
          "16688:     filters = 0x94949494;",
          "16689:     order = 0x4949;",
          "16690:     maximum = 0x3fff;",
          "16691:   }",
          "16692:   else if (!strcmp(model, \"SVS625CL\"))",
          "16693:   {",
          "16694:     height = 2050;",
          "16695:     width = 2448;",
          "16696:     load_raw = &CLASS unpacked_load_raw;",
          "16697:     data_offset = 0;",
          "16698:     filters = 0x94949494;",
          "16699:     order = 0x4949;",
          "16700:     maximum = 0x0fff;",
          "16707:       tiff_bps > 16",
          "16710:   {",
          "16711:     is_raw = 0;",
          "16713:     RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);",
          "16715:     return;",
          "16716:   }",
          "16718:     sprintf(model, \"%dx%d\", width, height);",
          "16719:   if (filters == UINT_MAX)",
          "16720:     filters = 0x94949494;",
          "16721:   if (thumb_offset && !thumb_height)",
          "16722:   {",
          "16723:     fseek(ifp, thumb_offset, SEEK_SET);",
          "16724:     if (ljpeg_start(&jh, 1))",
          "16725:     {",
          "16726:       thumb_width = jh.wide;",
          "16736:     int ll = LIM(0, (sizeof(cblack) / sizeof(cblack[0])),",
          "16737:                  (sizeof(imgdata.color.dng_levels.dng_cblack) / sizeof(imgdata.color.dng_levels.dng_cblack[0])));",
          "16738:     for (int i = 0; i < ll; i++)",
          "",
          "---------------",
          "--- Hunk 106 ---",
          "[Context before]",
          "15328: #ifdef LIBRAW_LIBRARY_BUILD",
          "15329:       (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)",
          "15330: #else",
          "15332: #endif",
          "15333:       || tiff_samples > 4 || colors > 4 || colors < 1)",
          "15336: #ifdef LIBRAW_LIBRARY_BUILD",
          "15338: #endif",
          "15344:     raw_color = 0;",
          "15345:   }",
          "15348: #ifdef LIBRAW_LIBRARY_BUILD",
          "15351: #endif",
          "15353:   if (load_raw == &CLASS kodak_radc_load_raw)",
          "15357:     fuji_width = width >> !fuji_layout;",
          "15358:     filters = fuji_width & 1 ? 0x94949494 : 0x49494949;",
          "15359:     width = (height >> fuji_layout) + fuji_width;",
          "15360:     height = width - 1;",
          "15361:     pixel_aspect = 1;",
          "15365:   }",
          "15367:   if (!maximum)",
          "15373:   if (!load_raw || height < 22 || width < 22 ||",
          "15374: #ifdef LIBRAW_LIBRARY_BUILD",
          "15375:       (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)",
          "15376: #else",
          "15378: #endif",
          "15379:       || tiff_samples > 6 || colors > 4)",
          "15380:     is_raw = 0;",
          "15383:     is_raw = 0;",
          "15385: #ifdef NO_JASPER",
          "15387: #ifdef DCRAW_VERBOSE",
          "15390: #endif",
          "15391:     is_raw = 0;",
          "15392: #ifdef LIBRAW_LIBRARY_BUILD",
          "",
          "[Removed Lines]",
          "15331:  tiff_bps > 16",
          "15334:     {",
          "15335:       is_raw = 0;",
          "15337:       RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,1,2);",
          "15339:       return;",
          "15340:     }",
          "15341:   if ((use_camera_matrix & ((use_camera_wb || dng_version) | 0x2) )",
          "15342:  && cmatrix[0][0] > 0.125) {",
          "15343:     memcpy (rgb_cam, cmatrix, sizeof cmatrix);",
          "15347:   if (raw_color) adobe_coeff (make, model);",
          "15349:   else if(imgdata.color.cam_xyz[0][0]<0.01)",
          "15350:    adobe_coeff (make, model,1);",
          "15354:     if (raw_color) adobe_coeff (\"Apple\",\"Quicktake\");",
          "15356:   if (fuji_width) {",
          "15362:   } else {",
          "15363:     if (raw_height < height) raw_height = height;",
          "15364:     if (raw_width  < width ) raw_width  = width;",
          "15366:   if (!tiff_bps) tiff_bps = 12;",
          "15368:     {",
          "15369:       maximum = (1 << tiff_bps) - 1;",
          "15370:       if(maximum < 0x10000 && curve[maximum]>0 &&    load_raw == &CLASS sony_arw2_load_raw)",
          "15371:         maximum = curve[maximum];",
          "15372:     }",
          "15377:  tiff_bps > 16",
          "15382:   if(raw_width < 22 || raw_width > 64000 || raw_height < 22 || raw_width > 64000)",
          "15386:   if (load_raw == &CLASS redcine_load_raw) {",
          "15388:     fprintf (stderr,_(\"%s: You must link dcraw with %s!!\\n\"),",
          "15389:  ifname, \"libjasper\");",
          "",
          "[Added Lines]",
          "16747:       tiff_bps > 16",
          "16750:   {",
          "16751:     is_raw = 0;",
          "16753:     RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);",
          "16755:     return;",
          "16756:   }",
          "16757:   if ((use_camera_matrix & ((use_camera_wb || dng_version) | 0x2)) && cmatrix[0][0] > 0.125)",
          "16758:   {",
          "16759:     memcpy(rgb_cam, cmatrix, sizeof cmatrix);",
          "16763:   if (raw_color)",
          "16764:     adobe_coeff(make, model);",
          "16766:   else if (imgdata.color.cam_xyz[0][0] < 0.01)",
          "16767:     adobe_coeff(make, model, 1);",
          "16771:     if (raw_color)",
          "16772:       adobe_coeff(\"Apple\", \"Quicktake\");",
          "16774:   if (fuji_width)",
          "16775:   {",
          "16782:   else",
          "16783:   {",
          "16784:     if (raw_height < height)",
          "16785:       raw_height = height;",
          "16786:     if (raw_width < width)",
          "16787:       raw_width = width;",
          "16788:   }",
          "16789:   if (!tiff_bps)",
          "16790:     tiff_bps = 12;",
          "16792:   {",
          "16793:     maximum = (1 << tiff_bps) - 1;",
          "16794:     if (maximum < 0x10000 && curve[maximum] > 0 && load_raw == &CLASS sony_arw2_load_raw)",
          "16795:       maximum = curve[maximum];",
          "16796:   }",
          "16801:       tiff_bps > 16",
          "16806:   if (raw_width < 22 || raw_width > 64000 || raw_height < 22 || raw_width > 64000)",
          "16810:   if (load_raw == &CLASS redcine_load_raw)",
          "16811:   {",
          "16813:     fprintf(stderr, _(\"%s: You must link dcraw with %s!!\\n\"), ifname, \"libjasper\");",
          "",
          "---------------",
          "--- Hunk 107 ---",
          "[Context before]",
          "15395:   }",
          "15396: #endif",
          "15397: #ifdef NO_JPEG",
          "15400: #ifdef DCRAW_VERBOSE",
          "15403: #endif",
          "15404:     is_raw = 0;",
          "15405: #ifdef LIBRAW_LIBRARY_BUILD",
          "",
          "[Removed Lines]",
          "15398:   if (load_raw == &CLASS kodak_jpeg_load_raw ||",
          "15399:       load_raw == &CLASS lossy_dng_load_raw) {",
          "15401:     fprintf (stderr,_(\"%s: You must link dcraw with %s!!\\n\"),",
          "15402:  ifname, \"libjpeg\");",
          "",
          "[Added Lines]",
          "16822:   if (load_raw == &CLASS kodak_jpeg_load_raw || load_raw == &CLASS lossy_dng_load_raw)",
          "16823:   {",
          "16825:     fprintf(stderr, _(\"%s: You must link dcraw with %s!!\\n\"), ifname, \"libjpeg\");",
          "",
          "---------------",
          "--- Hunk 108 ---",
          "[Context before]",
          "15408:   }",
          "15409: #endif",
          "15410:   if (!cdesc[0])",
          "15414:   if (filters > 999 && colors == 3)",
          "15417: notraw:",
          "15432: #ifdef LIBRAW_LIBRARY_BUILD",
          "15434: #endif",
          "15435: }",
          "15438: void CLASS convert_to_rgb()",
          "15439: {",
          "15440: #ifndef LIBRAW_LIBRARY_BUILD",
          "15441:   int row, col, c;",
          "15442: #endif",
          "15444: #ifndef LIBRAW_LIBRARY_BUILD",
          "15445:   ushort *img;",
          "15446:   float out[3];",
          "15447: #endif",
          "15448:   float out_cam[3][4];",
          "15449:   double num, inverse[3][3];",
          "15498: #ifndef LIBRAW_LIBRARY_BUILD",
          "15501: #else",
          "15530:       oprof[i] = htonl(oprof[i]);",
          "15537:   }",
          "15538: #ifdef DCRAW_VERBOSE",
          "15539:   if (verbose)",
          "15542: #endif",
          "15543: #ifdef LIBRAW_LIBRARY_BUILD",
          "15544:   convert_to_rgb_loop(out_cam);",
          "15545: #else",
          "15557:       }",
          "15558:       else if (document_mode)",
          "15560:       FORCC histogram[c][img[c] >> 3]++;",
          "15561:     }",
          "15562: #endif",
          "15564: #ifndef LIBRAW_LIBRARY_BUILD",
          "15566: #endif",
          "15567: #ifdef LIBRAW_LIBRARY_BUILD",
          "15569: #endif",
          "15570: }",
          "",
          "[Removed Lines]",
          "15411:     strcpy (cdesc, colors == 3 ? \"RGBG\":\"GMCY\");",
          "15412:   if (!raw_height) raw_height = height;",
          "15413:   if (!raw_width ) raw_width  = width;",
          "15415:     filters |= ((filters >> 2 & 0x22222222) |",
          "15416:   (filters << 2 & 0x88888888)) & filters << 1;",
          "15418:   if (flip == UINT_MAX) flip = tiff_flip;",
          "15419:   if (flip == UINT_MAX) flip = 0;",
          "15422:   if(flip > 89 || flip < -89)",
          "15423:    {",
          "15424:      switch ((flip+3600) % 360)",
          "15425:      {",
          "15426:        case 270:  flip = 5;  break;",
          "15427:        case 180:  flip = 3;  break;",
          "15428:        case  90:  flip = 6;  break;",
          "15429:      }",
          "15430:    }",
          "15433:   RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,1,2);",
          "15443:   int  i, j, k;",
          "15450:   static const double xyzd50_srgb[3][3] =",
          "15451:   { { 0.436083, 0.385083, 0.143055 },",
          "15452:     { 0.222507, 0.716888, 0.060608 },",
          "15453:     { 0.013930, 0.097097, 0.714022 } };",
          "15454:   static const double rgb_rgb[3][3] =",
          "15455:   { { 1,0,0 }, { 0,1,0 }, { 0,0,1 } };",
          "15456:   static const double adobe_rgb[3][3] =",
          "15457:   { { 0.715146, 0.284856, 0.000000 },",
          "15458:     { 0.000000, 1.000000, 0.000000 },",
          "15459:     { 0.000000, 0.041166, 0.958839 } };",
          "15460:   static const double wide_rgb[3][3] =",
          "15461:   { { 0.593087, 0.404710, 0.002206 },",
          "15462:     { 0.095413, 0.843149, 0.061439 },",
          "15463:     { 0.011621, 0.069091, 0.919288 } };",
          "15464:   static const double prophoto_rgb[3][3] =",
          "15465:   { { 0.529317, 0.330092, 0.140588 },",
          "15466:     { 0.098368, 0.873465, 0.028169 },",
          "15467:     { 0.016879, 0.117663, 0.865457 } };",
          "15468:   static const double aces_rgb[3][3] =",
          "15469:   { { 0.432996, 0.375380, 0.189317 },",
          "15470:     { 0.089427, 0.816523, 0.102989 },",
          "15471:     { 0.019165, 0.118150, 0.941914 } };",
          "15472:   static const double (*out_rgb[])[3] =",
          "15473:   { rgb_rgb, adobe_rgb, wide_rgb, prophoto_rgb, xyz_rgb, aces_rgb };",
          "15474:   static const char *name[] =",
          "15475:   { \"sRGB\", \"Adobe RGB (1998)\", \"WideGamut D65\", \"ProPhoto D65\", \"XYZ\", \"ACES\" };",
          "15476:   static const unsigned phead[] =",
          "15477:   { 1024, 0, 0x2100000, 0x6d6e7472, 0x52474220, 0x58595a20, 0, 0, 0,",
          "15478:     0x61637370, 0, 0, 0x6e6f6e65, 0, 0, 0, 0, 0xf6d6, 0x10000, 0xd32d };",
          "15479:   unsigned pbody[] =",
          "15490:   static const unsigned pwhite[] = { 0xf351, 0x10000, 0x116cc };",
          "15491:   unsigned pcurve[] = { 0x63757276, 0, 1, 0x1000000 };",
          "15493: #ifdef LIBRAW_LIBRARY_BUILD",
          "15494:   RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB,0,2);",
          "15495: #endif",
          "15496:   gamma_curve (gamm[0], gamm[1], 0, 0);",
          "15497:   memcpy (out_cam, rgb_cam, sizeof out_cam);",
          "15499:   raw_color |= colors == 1 || document_mode ||",
          "15500:   output_color < 1 || output_color > 6;",
          "15502:   raw_color |= colors == 1 ||",
          "15503:   output_color < 1 || output_color > 6;",
          "15504: #endif",
          "15505:   if (!raw_color) {",
          "15506:     oprof = (unsigned *) calloc (phead[0], 1);",
          "15507:     merror (oprof, \"convert_to_rgb()\");",
          "15508:     memcpy (oprof, phead, sizeof phead);",
          "15509:     if (output_color == 5) oprof[4] = oprof[5];",
          "15510:     oprof[0] = 132 + 12*pbody[0];",
          "15511:     for (i=0; i < pbody[0]; i++) {",
          "15512:       oprof[oprof[0]/4] = i ? (i > 1 ? 0x58595a20 : 0x64657363) : 0x74657874;",
          "15513:       pbody[i*3+2] = oprof[0];",
          "15514:       oprof[0] += (pbody[i*3+3] + 3) & -4;",
          "15515:     }",
          "15516:     memcpy (oprof+32, pbody, sizeof pbody);",
          "15517:     oprof[pbody[5]/4+2] = strlen(name[output_color-1]) + 1;",
          "15518:     memcpy ((char *)oprof+pbody[8]+8, pwhite, sizeof pwhite);",
          "15519:     pcurve[3] = (short)(256/gamm[5]+0.5) << 16;",
          "15520:     for (i=4; i < 7; i++)",
          "15521:       memcpy ((char *)oprof+pbody[i*3+2], pcurve, sizeof pcurve);",
          "15522:     pseudoinverse ((double (*)[3]) out_rgb[output_color-1], inverse, 3);",
          "15523:     for (i=0; i < 3; i++)",
          "15524:       for (j=0; j < 3; j++) {",
          "15525:  for (num = k=0; k < 3; k++)",
          "15526:    num += xyzd50_srgb[i][k] * inverse[j][k];",
          "15527:  oprof[pbody[j*3+23]/4+i+2] = num * 0x10000 + 0.5;",
          "15528:       }",
          "15529:     for (i=0; i < phead[0]/4; i++)",
          "15531:     strcpy ((char *)oprof+pbody[2]+8, \"auto-generated by dcraw\");",
          "15532:     strcpy ((char *)oprof+pbody[5]+12, name[output_color-1]);",
          "15533:     for (i=0; i < 3; i++)",
          "15534:       for (j=0; j < colors; j++)",
          "15535:  for (out_cam[i][j] = k=0; k < 3; k++)",
          "15536:    out_cam[i][j] += out_rgb[output_color-1][i][k] * rgb_cam[k][j];",
          "15540:     fprintf (stderr, raw_color ? _(\"Building histograms...\\n\") :",
          "15541:  _(\"Converting to %s colorspace...\\n\"), name[output_color-1]);",
          "15546:   memset (histogram, 0, sizeof histogram);",
          "15547:   for (img=image[0], row=0; row < height; row++)",
          "15548:     for (col=0; col < width; col++, img+=4) {",
          "15549:       if (!raw_color) {",
          "15550:  out[0] = out[1] = out[2] = 0;",
          "15551:  FORCC {",
          "15552:    out[0] += out_cam[0][c] * img[c];",
          "15553:    out[1] += out_cam[1][c] * img[c];",
          "15554:    out[2] += out_cam[2][c] * img[c];",
          "15555:  }",
          "15556:  FORC3 img[c] = CLIP((int) out[c]);",
          "15559:  img[0] = img[fcol(row,col)];",
          "15563:   if (colors == 4 && output_color) colors = 3;",
          "15565:   if (document_mode && filters) colors = 1;",
          "15568:   RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB,1,2);",
          "",
          "[Added Lines]",
          "16834:     strcpy(cdesc, colors == 3 ? \"RGBG\" : \"GMCY\");",
          "16835:   if (!raw_height)",
          "16836:     raw_height = height;",
          "16837:   if (!raw_width)",
          "16838:     raw_width = width;",
          "16840:     filters |= ((filters >> 2 & 0x22222222) | (filters << 2 & 0x88888888)) & filters << 1;",
          "16842:   if (flip == UINT_MAX)",
          "16843:     flip = tiff_flip;",
          "16844:   if (flip == UINT_MAX)",
          "16845:     flip = 0;",
          "16848:   if (flip > 89 || flip < -89)",
          "16849:   {",
          "16850:     switch ((flip + 3600) % 360)",
          "16851:     {",
          "16852:     case 270:",
          "16853:       flip = 5;",
          "16854:       break;",
          "16855:     case 180:",
          "16856:       flip = 3;",
          "16857:       break;",
          "16858:     case 90:",
          "16859:       flip = 6;",
          "16860:       break;",
          "16861:     }",
          "16862:   }",
          "16865:   RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);",
          "16874:   int i, j, k;",
          "16881:   static const double xyzd50_srgb[3][3] = {",
          "16882:       {0.436083, 0.385083, 0.143055}, {0.222507, 0.716888, 0.060608}, {0.013930, 0.097097, 0.714022}};",
          "16883:   static const double rgb_rgb[3][3] = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};",
          "16884:   static const double adobe_rgb[3][3] = {",
          "16885:       {0.715146, 0.284856, 0.000000}, {0.000000, 1.000000, 0.000000}, {0.000000, 0.041166, 0.958839}};",
          "16886:   static const double wide_rgb[3][3] = {",
          "16887:       {0.593087, 0.404710, 0.002206}, {0.095413, 0.843149, 0.061439}, {0.011621, 0.069091, 0.919288}};",
          "16888:   static const double prophoto_rgb[3][3] = {",
          "16889:       {0.529317, 0.330092, 0.140588}, {0.098368, 0.873465, 0.028169}, {0.016879, 0.117663, 0.865457}};",
          "16890:   static const double aces_rgb[3][3] = {",
          "16891:       {0.432996, 0.375380, 0.189317}, {0.089427, 0.816523, 0.102989}, {0.019165, 0.118150, 0.941914}};",
          "16892:   static const double(*out_rgb[])[3] = {rgb_rgb, adobe_rgb, wide_rgb, prophoto_rgb, xyz_rgb, aces_rgb};",
          "16893:   static const char *name[] = {\"sRGB\", \"Adobe RGB (1998)\", \"WideGamut D65\", \"ProPhoto D65\", \"XYZ\", \"ACES\"};",
          "16894:   static const unsigned phead[] = {1024, 0, 0x2100000,  0x6d6e7472, 0x52474220, 0x58595a20, 0,",
          "16895:                                    0,    0, 0x61637370, 0,          0,          0x6e6f6e65, 0,",
          "16896:                                    0,    0, 0,          0xf6d6,     0x10000,    0xd32d};",
          "16907:   static const unsigned pwhite[] = {0xf351, 0x10000, 0x116cc};",
          "16908:   unsigned pcurve[] = {0x63757276, 0, 1, 0x1000000};",
          "16910: #ifdef LIBRAW_LIBRARY_BUILD",
          "16911:   RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB, 0, 2);",
          "16912: #endif",
          "16913:   gamma_curve(gamm[0], gamm[1], 0, 0);",
          "16914:   memcpy(out_cam, rgb_cam, sizeof out_cam);",
          "16916:   raw_color |= colors == 1 || document_mode || output_color < 1 || output_color > 6;",
          "16918:   raw_color |= colors == 1 || output_color < 1 || output_color > 6;",
          "16919: #endif",
          "16920:   if (!raw_color)",
          "16921:   {",
          "16922:     oprof = (unsigned *)calloc(phead[0], 1);",
          "16923:     merror(oprof, \"convert_to_rgb()\");",
          "16924:     memcpy(oprof, phead, sizeof phead);",
          "16925:     if (output_color == 5)",
          "16926:       oprof[4] = oprof[5];",
          "16927:     oprof[0] = 132 + 12 * pbody[0];",
          "16928:     for (i = 0; i < pbody[0]; i++)",
          "16929:     {",
          "16930:       oprof[oprof[0] / 4] = i ? (i > 1 ? 0x58595a20 : 0x64657363) : 0x74657874;",
          "16931:       pbody[i * 3 + 2] = oprof[0];",
          "16932:       oprof[0] += (pbody[i * 3 + 3] + 3) & -4;",
          "16933:     }",
          "16934:     memcpy(oprof + 32, pbody, sizeof pbody);",
          "16935:     oprof[pbody[5] / 4 + 2] = strlen(name[output_color - 1]) + 1;",
          "16936:     memcpy((char *)oprof + pbody[8] + 8, pwhite, sizeof pwhite);",
          "16937:     pcurve[3] = (short)(256 / gamm[5] + 0.5) << 16;",
          "16938:     for (i = 4; i < 7; i++)",
          "16939:       memcpy((char *)oprof + pbody[i * 3 + 2], pcurve, sizeof pcurve);",
          "16940:     pseudoinverse((double(*)[3])out_rgb[output_color - 1], inverse, 3);",
          "16941:     for (i = 0; i < 3; i++)",
          "16942:       for (j = 0; j < 3; j++)",
          "16943:       {",
          "16944:         for (num = k = 0; k < 3; k++)",
          "16945:           num += xyzd50_srgb[i][k] * inverse[j][k];",
          "16946:         oprof[pbody[j * 3 + 23] / 4 + i + 2] = num * 0x10000 + 0.5;",
          "16947:       }",
          "16948:     for (i = 0; i < phead[0] / 4; i++)",
          "16950:     strcpy((char *)oprof + pbody[2] + 8, \"auto-generated by dcraw\");",
          "16951:     strcpy((char *)oprof + pbody[5] + 12, name[output_color - 1]);",
          "16952:     for (i = 0; i < 3; i++)",
          "16953:       for (j = 0; j < colors; j++)",
          "16954:         for (out_cam[i][j] = k = 0; k < 3; k++)",
          "16955:           out_cam[i][j] += out_rgb[output_color - 1][i][k] * rgb_cam[k][j];",
          "16959:     fprintf(stderr, raw_color ? _(\"Building histograms...\\n\") : _(\"Converting to %s colorspace...\\n\"),",
          "16960:             name[output_color - 1]);",
          "16965:   memset(histogram, 0, sizeof histogram);",
          "16966:   for (img = image[0], row = 0; row < height; row++)",
          "16967:     for (col = 0; col < width; col++, img += 4)",
          "16968:     {",
          "16969:       if (!raw_color)",
          "16970:       {",
          "16971:         out[0] = out[1] = out[2] = 0;",
          "16972:         FORCC",
          "16973:         {",
          "16974:           out[0] += out_cam[0][c] * img[c];",
          "16975:           out[1] += out_cam[1][c] * img[c];",
          "16976:           out[2] += out_cam[2][c] * img[c];",
          "16977:         }",
          "16978:         FORC3 img[c] = CLIP((int)out[c]);",
          "16981:         img[0] = img[fcol(row, col)];",
          "16985:   if (colors == 4 && output_color)",
          "16986:     colors = 3;",
          "16988:   if (document_mode && filters)",
          "16989:     colors = 1;",
          "16992:   RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB, 1, 2);",
          "",
          "---------------",
          "--- Hunk 109 ---",
          "[Context before]",
          "15577:   unsigned ur, uc;",
          "15578:   ushort wide, high, (*img)[4], (*pix)[4];",
          "15581: #ifdef DCRAW_VERBOSE",
          "15582:   if (verbose)",
          "15584: #endif",
          "15585:   fuji_width = (fuji_width - 1 + shrink) >> shrink;",
          "15586:   step = sqrt(0.5);",
          "15587:   wide = fuji_width / step;",
          "15588:   high = (height - fuji_width) / step;",
          "15592: #ifdef LIBRAW_LIBRARY_BUILD",
          "15594: #endif",
          "15601:       fr = r - ur;",
          "15602:       fc = c - uc;",
          "15608:     }",
          "15612:   height = high;",
          "15614:   fuji_width = 0;",
          "15615: #ifdef LIBRAW_LIBRARY_BUILD",
          "15617: #endif",
          "15618: }",
          "",
          "[Removed Lines]",
          "15580:   if (!fuji_width) return;",
          "15583:     fprintf (stderr,_(\"Rotating image 45 degrees...\\n\"));",
          "15589:   img = (ushort (*)[4]) calloc (high, wide*sizeof *img);",
          "15590:   merror (img, \"fuji_rotate()\");",
          "15593:   RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE,0,2);",
          "15596:   for (row=0; row < high; row++)",
          "15597:     for (col=0; col < wide; col++) {",
          "15598:       ur = r = fuji_width + (row-col)*step;",
          "15599:       uc = c = (row+col)*step;",
          "15600:       if (ur > height-2 || uc > width-2) continue;",
          "15603:       pix = image + ur*width + uc;",
          "15604:       for (i=0; i < colors; i++)",
          "15605:  img[row*wide+col][i] =",
          "15606:    (pix[    0][i]*(1-fc) + pix[      1][i]*fc) * (1-fr) +",
          "15607:    (pix[width][i]*(1-fc) + pix[width+1][i]*fc) * fr;",
          "15610:   free (image);",
          "15611:   width  = wide;",
          "15613:   image  = img;",
          "15616:   RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE,1,2);",
          "",
          "[Added Lines]",
          "17004:   if (!fuji_width)",
          "17005:     return;",
          "17008:     fprintf(stderr, _(\"Rotating image 45 degrees...\\n\"));",
          "17014:   img = (ushort(*)[4])calloc(high, wide * sizeof *img);",
          "17015:   merror(img, \"fuji_rotate()\");",
          "17018:   RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE, 0, 2);",
          "17021:   for (row = 0; row < high; row++)",
          "17022:     for (col = 0; col < wide; col++)",
          "17023:     {",
          "17024:       ur = r = fuji_width + (row - col) * step;",
          "17025:       uc = c = (row + col) * step;",
          "17026:       if (ur > height - 2 || uc > width - 2)",
          "17027:         continue;",
          "17030:       pix = image + ur * width + uc;",
          "17031:       for (i = 0; i < colors; i++)",
          "17032:         img[row * wide + col][i] = (pix[0][i] * (1 - fc) + pix[1][i] * fc) * (1 - fr) +",
          "17033:                                    (pix[width][i] * (1 - fc) + pix[width + 1][i] * fc) * fr;",
          "17036:   free(image);",
          "17037:   width = wide;",
          "17039:   image = img;",
          "17042:   RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE, 1, 2);",
          "",
          "---------------",
          "--- Hunk 110 ---",
          "[Context before]",
          "15623:   int row, col, c;",
          "15624:   double rc, frac;",
          "15627: #ifdef LIBRAW_LIBRARY_BUILD",
          "15629: #endif",
          "15630: #ifdef DCRAW_VERBOSE",
          "15632: #endif",
          "15634:     newdim = height / pixel_aspect + 0.5;",
          "15638:       frac = rc - (c = rc);",
          "15643:     }",
          "15644:     height = newdim;",
          "15646:     newdim = width * pixel_aspect + 0.5;",
          "15650:       frac = rc - (c = rc);",
          "15651:       pix0 = pix1 = image[c];",
          "15655:     }",
          "15656:     width = newdim;",
          "15657:   }",
          "15659:   image = img;",
          "15660: #ifdef LIBRAW_LIBRARY_BUILD",
          "15662: #endif",
          "15663: }",
          "15666: {",
          "15670:   return row * iwidth + col;",
          "15671: }",
          "15675: {",
          "15676:   struct tiff_tag *tt;",
          "15677:   int c;",
          "15680:   tt->val.i = val;",
          "15681:   if (type == 1 && count <= 4)",
          "15682:     FORC(4) tt->val.c[c] = val >> (c << 3);",
          "15685:     if (count <= 4)",
          "15688:     FORC(2) tt->val.s[c] = val >> (c << 4);",
          "15689:   tt->count = count;",
          "15690:   tt->type = type;",
          "",
          "[Removed Lines]",
          "15626:   if (pixel_aspect == 1) return;",
          "15628:   RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH,0,2);",
          "15631:   if (verbose) fprintf (stderr,_(\"Stretching the image...\\n\"));",
          "15633:   if (pixel_aspect < 1) {",
          "15635:     img = (ushort (*)[4]) calloc (width, newdim*sizeof *img);",
          "15636:     merror (img, \"stretch()\");",
          "15637:     for (rc=row=0; row < newdim; row++, rc+=pixel_aspect) {",
          "15639:       pix0 = pix1 = image[c*width];",
          "15640:       if (c+1 < height) pix1 += width*4;",
          "15641:       for (col=0; col < width; col++, pix0+=4, pix1+=4)",
          "15642:  FORCC img[row*width+col][c] = pix0[c]*(1-frac) + pix1[c]*frac + 0.5;",
          "15645:   } else {",
          "15647:     img = (ushort (*)[4]) calloc (height, newdim*sizeof *img);",
          "15648:     merror (img, \"stretch()\");",
          "15649:     for (rc=col=0; col < newdim; col++, rc+=1/pixel_aspect) {",
          "15652:       if (c+1 < width) pix1 += 4;",
          "15653:       for (row=0; row < height; row++, pix0+=width*4, pix1+=width*4)",
          "15654:  FORCC img[row*newdim+col][c] = pix0[c]*(1-frac) + pix1[c]*frac + 0.5;",
          "15658:   free (image);",
          "15661:   RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH,1,2);",
          "15665: int CLASS flip_index (int row, int col)",
          "15667:   if (flip & 4) SWAP(row,col);",
          "15668:   if (flip & 2) row = iheight - 1 - row;",
          "15669:   if (flip & 1) col = iwidth  - 1 - col;",
          "15673: void CLASS tiff_set (struct tiff_hdr *th, ushort *ntag,",
          "15674:  ushort tag, ushort type, int count, int val)",
          "15679:   tt = (struct tiff_tag *)(ntag+1) + (*ntag)++;",
          "15683:   else if (type == 2) {",
          "15684:     count = strnlen((char *)th + val, count-1) + 1;",
          "15686:       FORC(4) tt->val.c[c] = ((char *)th)[val+c];",
          "15687:   } else if (type == 3 && count <= 2)",
          "",
          "[Added Lines]",
          "17052:   if (pixel_aspect == 1)",
          "17053:     return;",
          "17055:   RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH, 0, 2);",
          "17058:   if (verbose)",
          "17059:     fprintf(stderr, _(\"Stretching the image...\\n\"));",
          "17061:   if (pixel_aspect < 1)",
          "17062:   {",
          "17064:     img = (ushort(*)[4])calloc(width, newdim * sizeof *img);",
          "17065:     merror(img, \"stretch()\");",
          "17066:     for (rc = row = 0; row < newdim; row++, rc += pixel_aspect)",
          "17067:     {",
          "17069:       pix0 = pix1 = image[c * width];",
          "17070:       if (c + 1 < height)",
          "17071:         pix1 += width * 4;",
          "17072:       for (col = 0; col < width; col++, pix0 += 4, pix1 += 4)",
          "17073:         FORCC img[row * width + col][c] = pix0[c] * (1 - frac) + pix1[c] * frac + 0.5;",
          "17076:   }",
          "17077:   else",
          "17078:   {",
          "17080:     img = (ushort(*)[4])calloc(height, newdim * sizeof *img);",
          "17081:     merror(img, \"stretch()\");",
          "17082:     for (rc = col = 0; col < newdim; col++, rc += 1 / pixel_aspect)",
          "17083:     {",
          "17086:       if (c + 1 < width)",
          "17087:         pix1 += 4;",
          "17088:       for (row = 0; row < height; row++, pix0 += width * 4, pix1 += width * 4)",
          "17089:         FORCC img[row * newdim + col][c] = pix0[c] * (1 - frac) + pix1[c] * frac + 0.5;",
          "17093:   free(image);",
          "17096:   RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH, 1, 2);",
          "17100: int CLASS flip_index(int row, int col)",
          "17102:   if (flip & 4)",
          "17103:     SWAP(row, col);",
          "17104:   if (flip & 2)",
          "17105:     row = iheight - 1 - row;",
          "17106:   if (flip & 1)",
          "17107:     col = iwidth - 1 - col;",
          "17111: void CLASS tiff_set(struct tiff_hdr *th, ushort *ntag, ushort tag, ushort type, int count, int val)",
          "17116:   tt = (struct tiff_tag *)(ntag + 1) + (*ntag)++;",
          "17120:   else if (type == 2)",
          "17121:   {",
          "17122:     count = strnlen((char *)th + val, count - 1) + 1;",
          "17124:       FORC(4) tt->val.c[c] = ((char *)th)[val + c];",
          "17125:   }",
          "17126:   else if (type == 3 && count <= 2)",
          "",
          "---------------",
          "--- Hunk 111 ---",
          "[Context before]",
          "15694: #define TOFF(ptr) ((char *)(&(ptr)) - (char *)th)",
          "15697: {",
          "15699:   struct tm *t;",
          "15702:   th->t_order = htonl(0x4d4d4949) >> 16;",
          "15703:   th->magic = 42;",
          "15704:   th->ifd = 10;",
          "15705:   th->rat[0] = th->rat[2] = 300;",
          "15706:   th->rat[1] = th->rat[3] = 1;",
          "15708:   th->rat[4] *= shutter;",
          "15709:   th->rat[6] *= aperture;",
          "15710:   th->rat[8] *= focal_len;",
          "15724:     if (colors > 2)",
          "15726:     FORC4 th->bps[c] = output_bps;",
          "15772: {",
          "15773:   ushort exif[5];",
          "15774:   struct tiff_hdr th;",
          "15783:   }",
          "15785: }",
          "15787: void CLASS jpeg_thumb()",
          "15788: {",
          "15789:   char *thumb;",
          "15796: }",
          "15797: #else",
          "15798: void CLASS jpeg_thumb()",
          "",
          "[Removed Lines]",
          "15696: void CLASS tiff_head (struct tiff_hdr *th, int full)",
          "15698:   int c, psize=0;",
          "15701:   memset (th, 0, sizeof *th);",
          "15707:   FORC(6) th->rat[4+c] = 1000000;",
          "15711:   strncpy (th->t_desc, desc, 512);",
          "15712:   strncpy (th->t_make, make, 64);",
          "15713:   strncpy (th->t_model, model, 64);",
          "15714:   strcpy (th->soft, \"dcraw v\" DCRAW_VERSION);",
          "15715:   t = localtime (&timestamp);",
          "15716:   sprintf (th->date, \"%04d:%02d:%02d %02d:%02d:%02d\",",
          "15717:       t->tm_year+1900,t->tm_mon+1,t->tm_mday,t->tm_hour,t->tm_min,t->tm_sec);",
          "15718:   strncpy (th->t_artist, artist, 64);",
          "15719:   if (full) {",
          "15720:     tiff_set (th, &th->ntag, 254, 4, 1, 0);",
          "15721:     tiff_set (th, &th->ntag, 256, 4, 1, width);",
          "15722:     tiff_set (th, &th->ntag, 257, 4, 1, height);",
          "15723:     tiff_set (th, &th->ntag, 258, 3, colors, output_bps);",
          "15725:       th->tag[th->ntag-1].val.i = TOFF(th->bps);",
          "15727:     tiff_set (th, &th->ntag, 259, 3, 1, 1);",
          "15728:     tiff_set (th, &th->ntag, 262, 3, 1, 1 + (colors > 1));",
          "15729:   }",
          "15730:   tiff_set (th, &th->ntag, 270, 2, 512, TOFF(th->t_desc));",
          "15731:   tiff_set (th, &th->ntag, 271, 2, 64, TOFF(th->t_make));",
          "15732:   tiff_set (th, &th->ntag, 272, 2, 64, TOFF(th->t_model));",
          "15733:   if (full) {",
          "15734:     if (oprof) psize = ntohl(oprof[0]);",
          "15735:     tiff_set (th, &th->ntag, 273, 4, 1, sizeof *th + psize);",
          "15736:     tiff_set (th, &th->ntag, 277, 3, 1, colors);",
          "15737:     tiff_set (th, &th->ntag, 278, 4, 1, height);",
          "15738:     tiff_set (th, &th->ntag, 279, 4, 1, height*width*colors*output_bps/8);",
          "15739:   } else",
          "15740:     tiff_set (th, &th->ntag, 274, 3, 1, \"12435867\"[flip]-'0');",
          "15741:   tiff_set (th, &th->ntag, 282, 5, 1, TOFF(th->rat[0]));",
          "15742:   tiff_set (th, &th->ntag, 283, 5, 1, TOFF(th->rat[2]));",
          "15743:   tiff_set (th, &th->ntag, 284, 3, 1, 1);",
          "15744:   tiff_set (th, &th->ntag, 296, 3, 1, 2);",
          "15745:   tiff_set (th, &th->ntag, 305, 2, 32, TOFF(th->soft));",
          "15746:   tiff_set (th, &th->ntag, 306, 2, 20, TOFF(th->date));",
          "15747:   tiff_set (th, &th->ntag, 315, 2, 64, TOFF(th->t_artist));",
          "15748:   tiff_set (th, &th->ntag, 34665, 4, 1, TOFF(th->nexif));",
          "15749:   if (psize) tiff_set (th, &th->ntag, 34675, 7, psize, sizeof *th);",
          "15750:   tiff_set (th, &th->nexif, 33434, 5, 1, TOFF(th->rat[4]));",
          "15751:   tiff_set (th, &th->nexif, 33437, 5, 1, TOFF(th->rat[6]));",
          "15752:   tiff_set (th, &th->nexif, 34855, 3, 1, iso_speed);",
          "15753:   tiff_set (th, &th->nexif, 37386, 5, 1, TOFF(th->rat[8]));",
          "15754:   if (gpsdata[1]) {",
          "15755:     tiff_set (th, &th->ntag, 34853, 4, 1, TOFF(th->ngps));",
          "15756:     tiff_set (th, &th->ngps,  0, 1,  4, 0x202);",
          "15757:     tiff_set (th, &th->ngps,  1, 2,  2, gpsdata[29]);",
          "15758:     tiff_set (th, &th->ngps,  2, 5,  3, TOFF(th->gps[0]));",
          "15759:     tiff_set (th, &th->ngps,  3, 2,  2, gpsdata[30]);",
          "15760:     tiff_set (th, &th->ngps,  4, 5,  3, TOFF(th->gps[6]));",
          "15761:     tiff_set (th, &th->ngps,  5, 1,  1, gpsdata[31]);",
          "15762:     tiff_set (th, &th->ngps,  6, 5,  1, TOFF(th->gps[18]));",
          "15763:     tiff_set (th, &th->ngps,  7, 5,  3, TOFF(th->gps[12]));",
          "15764:     tiff_set (th, &th->ngps, 18, 2, 12, TOFF(th->gps[20]));",
          "15765:     tiff_set (th, &th->ngps, 29, 2, 12, TOFF(th->gps[23]));",
          "15766:     memcpy (th->gps, gpsdata, sizeof th->gps);",
          "15767:   }",
          "15768: }",
          "15770: #ifdef LIBRAW_LIBRARY_BUILD",
          "15771: void CLASS jpeg_thumb_writer (FILE *tfp,char *t_humb,int t_humb_length)",
          "15775:   fputc (0xff, tfp);",
          "15776:   fputc (0xd8, tfp);",
          "15777:   if (strcmp (t_humb+6, \"Exif\")) {",
          "15778:     memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);",
          "15779:     exif[1] = htons (8 + sizeof th);",
          "15780:     fwrite (exif, 1, sizeof exif, tfp);",
          "15781:     tiff_head (&th, 0);",
          "15782:     fwrite (&th, 1, sizeof th, tfp);",
          "15784:   fwrite (t_humb+2, 1, t_humb_length-2, tfp);",
          "15791:   thumb = (char *) malloc (thumb_length);",
          "15792:   merror (thumb, \"jpeg_thumb()\");",
          "15793:   fread (thumb, 1, thumb_length, ifp);",
          "15794:   jpeg_thumb_writer(ofp,thumb,thumb_length);",
          "15795:   free (thumb);",
          "",
          "[Added Lines]",
          "17135: void CLASS tiff_head(struct tiff_hdr *th, int full)",
          "17137:   int c, psize = 0;",
          "17140:   memset(th, 0, sizeof *th);",
          "17146:   FORC(6) th->rat[4 + c] = 1000000;",
          "17150:   strncpy(th->t_desc, desc, 512);",
          "17151:   strncpy(th->t_make, make, 64);",
          "17152:   strncpy(th->t_model, model, 64);",
          "17153:   strcpy(th->soft, \"dcraw v\" DCRAW_VERSION);",
          "17154:   t = localtime(&timestamp);",
          "17155:   sprintf(th->date, \"%04d:%02d:%02d %02d:%02d:%02d\", t->tm_year + 1900, t->tm_mon + 1, t->tm_mday, t->tm_hour,",
          "17156:           t->tm_min, t->tm_sec);",
          "17157:   strncpy(th->t_artist, artist, 64);",
          "17158:   if (full)",
          "17159:   {",
          "17160:     tiff_set(th, &th->ntag, 254, 4, 1, 0);",
          "17161:     tiff_set(th, &th->ntag, 256, 4, 1, width);",
          "17162:     tiff_set(th, &th->ntag, 257, 4, 1, height);",
          "17163:     tiff_set(th, &th->ntag, 258, 3, colors, output_bps);",
          "17165:       th->tag[th->ntag - 1].val.i = TOFF(th->bps);",
          "17167:     tiff_set(th, &th->ntag, 259, 3, 1, 1);",
          "17168:     tiff_set(th, &th->ntag, 262, 3, 1, 1 + (colors > 1));",
          "17169:   }",
          "17170:   tiff_set(th, &th->ntag, 270, 2, 512, TOFF(th->t_desc));",
          "17171:   tiff_set(th, &th->ntag, 271, 2, 64, TOFF(th->t_make));",
          "17172:   tiff_set(th, &th->ntag, 272, 2, 64, TOFF(th->t_model));",
          "17173:   if (full)",
          "17174:   {",
          "17175:     if (oprof)",
          "17176:       psize = ntohl(oprof[0]);",
          "17177:     tiff_set(th, &th->ntag, 273, 4, 1, sizeof *th + psize);",
          "17178:     tiff_set(th, &th->ntag, 277, 3, 1, colors);",
          "17179:     tiff_set(th, &th->ntag, 278, 4, 1, height);",
          "17180:     tiff_set(th, &th->ntag, 279, 4, 1, height * width * colors * output_bps / 8);",
          "17181:   }",
          "17182:   else",
          "17183:     tiff_set(th, &th->ntag, 274, 3, 1, \"12435867\"[flip] - '0');",
          "17184:   tiff_set(th, &th->ntag, 282, 5, 1, TOFF(th->rat[0]));",
          "17185:   tiff_set(th, &th->ntag, 283, 5, 1, TOFF(th->rat[2]));",
          "17186:   tiff_set(th, &th->ntag, 284, 3, 1, 1);",
          "17187:   tiff_set(th, &th->ntag, 296, 3, 1, 2);",
          "17188:   tiff_set(th, &th->ntag, 305, 2, 32, TOFF(th->soft));",
          "17189:   tiff_set(th, &th->ntag, 306, 2, 20, TOFF(th->date));",
          "17190:   tiff_set(th, &th->ntag, 315, 2, 64, TOFF(th->t_artist));",
          "17191:   tiff_set(th, &th->ntag, 34665, 4, 1, TOFF(th->nexif));",
          "17192:   if (psize)",
          "17193:     tiff_set(th, &th->ntag, 34675, 7, psize, sizeof *th);",
          "17194:   tiff_set(th, &th->nexif, 33434, 5, 1, TOFF(th->rat[4]));",
          "17195:   tiff_set(th, &th->nexif, 33437, 5, 1, TOFF(th->rat[6]));",
          "17196:   tiff_set(th, &th->nexif, 34855, 3, 1, iso_speed);",
          "17197:   tiff_set(th, &th->nexif, 37386, 5, 1, TOFF(th->rat[8]));",
          "17198:   if (gpsdata[1])",
          "17199:   {",
          "17200:     tiff_set(th, &th->ntag, 34853, 4, 1, TOFF(th->ngps));",
          "17201:     tiff_set(th, &th->ngps, 0, 1, 4, 0x202);",
          "17202:     tiff_set(th, &th->ngps, 1, 2, 2, gpsdata[29]);",
          "17203:     tiff_set(th, &th->ngps, 2, 5, 3, TOFF(th->gps[0]));",
          "17204:     tiff_set(th, &th->ngps, 3, 2, 2, gpsdata[30]);",
          "17205:     tiff_set(th, &th->ngps, 4, 5, 3, TOFF(th->gps[6]));",
          "17206:     tiff_set(th, &th->ngps, 5, 1, 1, gpsdata[31]);",
          "17207:     tiff_set(th, &th->ngps, 6, 5, 1, TOFF(th->gps[18]));",
          "17208:     tiff_set(th, &th->ngps, 7, 5, 3, TOFF(th->gps[12]));",
          "17209:     tiff_set(th, &th->ngps, 18, 2, 12, TOFF(th->gps[20]));",
          "17210:     tiff_set(th, &th->ngps, 29, 2, 12, TOFF(th->gps[23]));",
          "17211:     memcpy(th->gps, gpsdata, sizeof th->gps);",
          "17212:   }",
          "17213: }",
          "17215: #ifdef LIBRAW_LIBRARY_BUILD",
          "17216: void CLASS jpeg_thumb_writer(FILE *tfp, char *t_humb, int t_humb_length)",
          "17220:   fputc(0xff, tfp);",
          "17221:   fputc(0xd8, tfp);",
          "17222:   if (strcmp(t_humb + 6, \"Exif\"))",
          "17223:   {",
          "17224:     memcpy(exif, \"\\xff\\xe1  Exif\\0\\0\", 10);",
          "17225:     exif[1] = htons(8 + sizeof th);",
          "17226:     fwrite(exif, 1, sizeof exif, tfp);",
          "17227:     tiff_head(&th, 0);",
          "17228:     fwrite(&th, 1, sizeof th, tfp);",
          "17230:   fwrite(t_humb + 2, 1, t_humb_length - 2, tfp);",
          "17237:   thumb = (char *)malloc(thumb_length);",
          "17238:   merror(thumb, \"jpeg_thumb()\");",
          "17239:   fread(thumb, 1, thumb_length, ifp);",
          "17240:   jpeg_thumb_writer(ofp, thumb, thumb_length);",
          "17241:   free(thumb);",
          "",
          "---------------",
          "--- Hunk 112 ---",
          "[Context before]",
          "15801:   ushort exif[5];",
          "15802:   struct tiff_hdr th;",
          "15815:   }",
          "15818: }",
          "15819: #endif",
          "",
          "[Removed Lines]",
          "15804:   thumb = (char *) malloc (thumb_length);",
          "15805:   merror (thumb, \"jpeg_thumb()\");",
          "15806:   fread (thumb, 1, thumb_length, ifp);",
          "15807:   fputc (0xff, ofp);",
          "15808:   fputc (0xd8, ofp);",
          "15809:   if (strcmp (thumb+6, \"Exif\")) {",
          "15810:     memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);",
          "15811:     exif[1] = htons (8 + sizeof th);",
          "15812:     fwrite (exif, 1, sizeof exif, ofp);",
          "15813:     tiff_head (&th, 0);",
          "15814:     fwrite (&th, 1, sizeof th, ofp);",
          "15816:   fwrite (thumb+2, 1, thumb_length-2, ofp);",
          "15817:   free (thumb);",
          "",
          "[Added Lines]",
          "17250:   thumb = (char *)malloc(thumb_length);",
          "17251:   merror(thumb, \"jpeg_thumb()\");",
          "17252:   fread(thumb, 1, thumb_length, ifp);",
          "17253:   fputc(0xff, ofp);",
          "17254:   fputc(0xd8, ofp);",
          "17255:   if (strcmp(thumb + 6, \"Exif\"))",
          "17256:   {",
          "17257:     memcpy(exif, \"\\xff\\xe1  Exif\\0\\0\", 10);",
          "17258:     exif[1] = htons(8 + sizeof th);",
          "17259:     fwrite(exif, 1, sizeof exif, ofp);",
          "17260:     tiff_head(&th, 0);",
          "17261:     fwrite(&th, 1, sizeof th, ofp);",
          "17263:   fwrite(thumb + 2, 1, thumb_length - 2, ofp);",
          "17264:   free(thumb);",
          "",
          "---------------",
          "--- Hunk 113 ---",
          "[Context before]",
          "15824:   uchar *ppm;",
          "15825:   ushort *ppm2;",
          "15826:   int c, row, col, soff, rstep, cstep;",
          "15829: #ifdef LIBRAW_LIBRARY_BUILD",
          "15830:   perc = width * height * auto_bright_thr;",
          "15831: #else",
          "15833: #endif",
          "15835:   if (!((highlight & ~2) || no_auto_bright))",
          "15840:     }",
          "15842:   iheight = height;",
          "15851:     if (oprof)",
          "15857:   else",
          "15865:       if (output_bps == 8)",
          "15868:     if (output_bps == 16 && !output_tiff && htons(0x55aa) != 0x55aa)",
          "15871:   }",
          "15873: }",
          "",
          "[Removed Lines]",
          "15827:   int perc, val, total, t_white=0x2000;",
          "15834:   if (fuji_width) perc /= 2;",
          "15836:     for (t_white=c=0; c < colors; c++) {",
          "15837:       for (val=0x2000, total=0; --val > 32; )",
          "15838:  if ((total += histogram[c][val]) > perc) break;",
          "15839:       if (t_white < val) t_white = val;",
          "15841:   gamma_curve (gamm[0], gamm[1], 2, (t_white << 3)/bright);",
          "15843:   iwidth  = width;",
          "15844:   if (flip & 4) SWAP(height,width);",
          "15845:   ppm = (uchar *) calloc (width, colors*output_bps/8);",
          "15846:   ppm2 = (ushort *) ppm;",
          "15847:   merror (ppm, \"write_ppm_tiff()\");",
          "15848:   if (output_tiff) {",
          "15849:     tiff_head (&th, 1);",
          "15850:     fwrite (&th, sizeof th, 1, ofp);",
          "15852:       fwrite (oprof, ntohl(oprof[0]), 1, ofp);",
          "15853:   } else if (colors > 3)",
          "15854:     fprintf (ofp,",
          "15855:       \"P7\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %d\\nMAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\",",
          "15856:  width, height, colors, (1 << output_bps)-1, cdesc);",
          "15858:     fprintf (ofp, \"P%d\\n%d %d\\n%d\\n\",",
          "15859:  colors/2+5, width, height, (1 << output_bps)-1);",
          "15860:   soff  = flip_index (0, 0);",
          "15861:   cstep = flip_index (0, 1) - soff;",
          "15862:   rstep = flip_index (1, 0) - flip_index (0, width);",
          "15863:   for (row=0; row < height; row++, soff += rstep) {",
          "15864:     for (col=0; col < width; col++, soff += cstep)",
          "15866:     FORCC ppm [col*colors+c] = curve[image[soff][c]] >> 8;",
          "15867:       else FORCC ppm2[col*colors+c] = curve[image[soff][c]];",
          "15869:       swab ((char*)ppm2, (char*)ppm2, width*colors*2);",
          "15870:     fwrite (ppm, colors*output_bps/8, width, ofp);",
          "15872:   free (ppm);",
          "",
          "[Added Lines]",
          "17274:   int perc, val, total, t_white = 0x2000;",
          "17281:   if (fuji_width)",
          "17282:     perc /= 2;",
          "17284:     for (t_white = c = 0; c < colors; c++)",
          "17285:     {",
          "17286:       for (val = 0x2000, total = 0; --val > 32;)",
          "17287:         if ((total += histogram[c][val]) > perc)",
          "17288:           break;",
          "17289:       if (t_white < val)",
          "17290:         t_white = val;",
          "17292:   gamma_curve(gamm[0], gamm[1], 2, (t_white << 3) / bright);",
          "17294:   iwidth = width;",
          "17295:   if (flip & 4)",
          "17296:     SWAP(height, width);",
          "17297:   ppm = (uchar *)calloc(width, colors * output_bps / 8);",
          "17298:   ppm2 = (ushort *)ppm;",
          "17299:   merror(ppm, \"write_ppm_tiff()\");",
          "17300:   if (output_tiff)",
          "17301:   {",
          "17302:     tiff_head(&th, 1);",
          "17303:     fwrite(&th, sizeof th, 1, ofp);",
          "17305:       fwrite(oprof, ntohl(oprof[0]), 1, ofp);",
          "17306:   }",
          "17307:   else if (colors > 3)",
          "17308:     fprintf(ofp, \"P7\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %d\\nMAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\", width, height, colors,",
          "17309:             (1 << output_bps) - 1, cdesc);",
          "17311:     fprintf(ofp, \"P%d\\n%d %d\\n%d\\n\", colors / 2 + 5, width, height, (1 << output_bps) - 1);",
          "17312:   soff = flip_index(0, 0);",
          "17313:   cstep = flip_index(0, 1) - soff;",
          "17314:   rstep = flip_index(1, 0) - flip_index(0, width);",
          "17315:   for (row = 0; row < height; row++, soff += rstep)",
          "17316:   {",
          "17317:     for (col = 0; col < width; col++, soff += cstep)",
          "17319:         FORCC ppm[col * colors + c] = curve[image[soff][c]] >> 8;",
          "17320:       else",
          "17321:         FORCC ppm2[col * colors + c] = curve[image[soff][c]];",
          "17323:       swab((char *)ppm2, (char *)ppm2, width * colors * 2);",
          "17324:     fwrite(ppm, colors * output_bps / 8, width, ofp);",
          "17326:   free(ppm);",
          "",
          "---------------"
        ],
        "internal/dcraw_fileio.cpp||internal/dcraw_fileio.cpp": [
          "File: internal/dcraw_fileio.cpp -> internal/dcraw_fileio.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "29:    Seach from the current directory up to the root looking for",
          "30:    a \".badpixels\" file, and fix those pixels now.",
          "33: {",
          "35: #ifndef LIBRAW_LIBRARY_BUILD",
          "36:   char *fname, *cp, line[128];",
          "38: #else",
          "39:   char *cp, line[128];",
          "40:   int time, row, col, r, c, rad, tot, n;",
          "",
          "[Removed Lines]",
          "32: void CLASS bad_pixels (const char *cfname)",
          "34:   FILE *fp=NULL;",
          "37:   int len, time, row, col, r, c, rad, tot, n, fixed=0;",
          "",
          "[Added Lines]",
          "32: void CLASS bad_pixels(const char *cfname)",
          "34:   FILE *fp = NULL;",
          "37:   int len, time, row, col, r, c, rad, tot, n, fixed = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "43: #endif",
          "44: #endif",
          "47: #ifdef LIBRAW_LIBRARY_BUILD",
          "49: #endif",
          "50:   if (cfname)",
          "52:   if (!fp)",
          "54: #ifdef LIBRAW_LIBRARY_BUILD",
          "56: #endif",
          "74: #ifdef DCRAW_VERBOSE",
          "76:       if (!fixed++)",
          "79:     }",
          "80: #endif",
          "81:   }",
          "82: #ifdef DCRAW_VERBOSE",
          "84: #endif",
          "86: #ifdef LIBRAW_LIBRARY_BUILD",
          "88: #endif",
          "89: }",
          "92: {",
          "93:   FILE *fp;",
          "95:   ushort *pixel;",
          "96: #ifdef LIBRAW_LIBRARY_BUILD",
          "98: #endif",
          "101: #ifdef DCRAW_VERBOSE",
          "103: #endif",
          "104: #ifdef LIBRAW_LIBRARY_BUILD",
          "105:     imgdata.process_warnings |= LIBRAW_WARN_BAD_DARKFRAME_FILE;",
          "106: #endif",
          "107:     return;",
          "108:   }",
          "120:     }",
          "121:   }",
          "123: #ifdef DCRAW_VERBOSE",
          "125: #endif",
          "128: #ifdef DCRAW_VERBOSE",
          "130: #endif",
          "131: #ifdef LIBRAW_LIBRARY_BUILD",
          "133: #endif",
          "135:   }",
          "142:   }",
          "146:   black = 0;",
          "147: #ifdef LIBRAW_LIBRARY_BUILD",
          "149: #endif",
          "150: }",
          "151: #ifndef NO_LCMS",
          "153: {",
          "154:   char *prof;",
          "156:   cmsHTRANSFORM hTransform;",
          "157:   FILE *fp;",
          "158:   unsigned size;",
          "163: #ifndef LIBRAW_LIBRARY_BUILD",
          "170: #else",
          "172: #endif",
          "175: #ifdef LIBRAW_LIBRARY_BUILD",
          "177: #endif",
          "178: #ifdef DCRAW_VERBOSE",
          "180: #endif",
          "182:   if (!hInProfile)",
          "184: #ifdef LIBRAW_LIBRARY_BUILD",
          "186: #endif",
          "189:   if (!output)",
          "190:     hOutProfile = cmsCreate_sRGBProfile();",
          "200:       oprof = 0;",
          "201:     }",
          "202:   }",
          "203: #ifdef DCRAW_VERBOSE",
          "206: #endif",
          "207:   if (!hOutProfile)",
          "209: #ifdef LIBRAW_LIBRARY_BUILD",
          "211: #endif",
          "214: #ifdef DCRAW_VERBOSE",
          "215:   if (verbose)",
          "217: #endif",
          "218: #ifdef LIBRAW_LIBRARY_BUILD",
          "227: quit:",
          "229: #ifdef LIBRAW_LIBRARY_BUILD",
          "231: #endif",
          "232: }",
          "233: #endif",
          "",
          "[Removed Lines]",
          "46:   if (!filters) return;",
          "48:   RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,0,2);",
          "51:     fp = fopen (cfname, \"r\");",
          "53:       {",
          "55:           imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;",
          "57:           return;",
          "58:       }",
          "59:   while (fgets (line, 128, fp)) {",
          "60:     cp = strchr (line, '#');",
          "61:     if (cp) *cp = 0;",
          "62:     if (sscanf (line, \"%d %d %d\", &col, &row, &time) != 3) continue;",
          "63:     if ((unsigned) col >= width || (unsigned) row >= height) continue;",
          "64:     if (time > timestamp) continue;",
          "65:     for (tot=n=0, rad=1; rad < 3 && n==0; rad++)",
          "66:       for (r = row-rad; r <= row+rad; r++)",
          "67:  for (c = col-rad; c <= col+rad; c++)",
          "68:    if ((unsigned) r < height && (unsigned) c < width &&",
          "69:   (r != row || c != col) && fcol(r,c) == fcol(row,col)) {",
          "70:      tot += BAYER2(r,c);",
          "71:      n++;",
          "72:    }",
          "73:     BAYER2(row,col) = tot/n;",
          "75:     if (verbose) {",
          "77:  fprintf (stderr,_(\"Fixed dead pixels at:\"));",
          "78:       fprintf (stderr, \" %d,%d\", col, row);",
          "83:   if (fixed) fputc ('\\n', stderr);",
          "85:   fclose (fp);",
          "87:   RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,1,2);",
          "91: void CLASS subtract (const char *fname)",
          "94:   int dim[3]={0,0,0}, comment=0, number=0, error=0, nd=0, c, row, col;",
          "97:   RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,0,2);",
          "100:   if (!(fp = fopen (fname, \"rb\"))) {",
          "102:     perror (fname);",
          "109:   if (fgetc(fp) != 'P' || fgetc(fp) != '5') error = 1;",
          "110:   while (!error && nd < 3 && (c = fgetc(fp)) != EOF) {",
          "111:     if (c == '#')  comment = 1;",
          "112:     if (c == '\\n') comment = 0;",
          "113:     if (comment) continue;",
          "114:     if (isdigit(c)) number = 1;",
          "115:     if (number) {",
          "116:       if (isdigit(c)) dim[nd] = dim[nd]*10 + c -'0';",
          "117:       else if (isspace(c)) {",
          "118:  number = 0;  nd++;",
          "119:       } else error = 1;",
          "122:   if (error || nd < 3) {",
          "124:     fprintf (stderr,_(\"%s is not a valid PGM file!\\n\"), fname);",
          "126:     fclose (fp);  return;",
          "127:   } else if (dim[0] != width || dim[1] != height || dim[2] != 65535) {",
          "129:       fprintf (stderr,_(\"%s has the wrong dimensions!\\n\"), fname);",
          "132:       imgdata.process_warnings |= LIBRAW_WARN_BAD_DARKFRAME_DIM;",
          "134:     fclose (fp);  return;",
          "136:   pixel = (ushort *) calloc (width, sizeof *pixel);",
          "137:   merror (pixel, \"subtract()\");",
          "138:   for (row=0; row < height; row++) {",
          "139:     fread (pixel, 2, width, fp);",
          "140:     for (col=0; col < width; col++)",
          "141:       BAYER(row,col) = MAX (BAYER(row,col) - ntohs(pixel[col]), 0);",
          "143:   free (pixel);",
          "144:   fclose (fp);",
          "145:   memset (cblack, 0, sizeof cblack);",
          "148:   RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,1,2);",
          "152: void CLASS apply_profile (const char *input, const char *output)",
          "155:   cmsHPROFILE hInProfile=0, hOutProfile=0;",
          "160:   if (strcmp (input, \"embed\"))",
          "161:     hInProfile = cmsOpenProfileFromFile (input, \"r\");",
          "162:   else if (profile_length) {",
          "164:     prof = (char *) malloc (profile_length);",
          "165:     merror (prof, \"apply_profile()\");",
          "166:     fseek (ifp, profile_offset, SEEK_SET);",
          "167:     fread (prof, 1, profile_length, ifp);",
          "168:     hInProfile = cmsOpenProfileFromMem (prof, profile_length);",
          "169:     free (prof);",
          "171:     hInProfile = cmsOpenProfileFromMem (imgdata.color.profile, profile_length);",
          "173:   } else",
          "174:     {",
          "176:           imgdata.process_warnings |= LIBRAW_WARN_NO_EMBEDDED_PROFILE;",
          "179:           fprintf (stderr,_(\"%s has no embedded profile.\\n\"), ifname);",
          "181:     }",
          "183:       {",
          "185:           imgdata.process_warnings |= LIBRAW_WARN_NO_INPUT_PROFILE;",
          "187:           return;",
          "188:       }",
          "191:   else if ((fp = fopen (output, \"rb\"))) {",
          "192:     fread (&size, 4, 1, fp);",
          "193:     fseek (fp, 0, SEEK_SET);",
          "194:     oprof = (unsigned *) malloc (size = ntohl(size));",
          "195:     merror (oprof, \"apply_profile()\");",
          "196:     fread (oprof, 1, size, fp);",
          "197:     fclose (fp);",
          "198:     if (!(hOutProfile = cmsOpenProfileFromMem (oprof, size))) {",
          "199:       free (oprof);",
          "204:  else",
          "205:     fprintf (stderr,_(\"Cannot open file %s!\\n\"), output);",
          "208:       {",
          "210:           imgdata.process_warnings |= LIBRAW_WARN_BAD_OUTPUT_PROFILE;",
          "212:           goto quit;",
          "213:       }",
          "216:     fprintf (stderr,_(\"Applying color profile...\\n\"));",
          "219:   RUN_CALLBACK(LIBRAW_PROGRESS_APPLY_PROFILE,0,2);",
          "220: #endif",
          "221:   hTransform = cmsCreateTransform (hInProfile, TYPE_RGBA_16,",
          "222:  hOutProfile, TYPE_RGBA_16, INTENT_PERCEPTUAL, 0);",
          "223:   cmsDoTransform (hTransform, image, image, width*height);",
          "225:   cmsDeleteTransform (hTransform);",
          "226:   cmsCloseProfile (hOutProfile);",
          "228:   cmsCloseProfile (hInProfile);",
          "230:   RUN_CALLBACK(LIBRAW_PROGRESS_APPLY_PROFILE,1,2);",
          "",
          "[Added Lines]",
          "46:   if (!filters)",
          "47:     return;",
          "49:   RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS, 0, 2);",
          "52:     fp = fopen(cfname, \"r\");",
          "54:   {",
          "56:     imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;",
          "58:     return;",
          "59:   }",
          "60:   while (fgets(line, 128, fp))",
          "61:   {",
          "62:     cp = strchr(line, '#');",
          "63:     if (cp)",
          "65:     if (sscanf(line, \"%d %d %d\", &col, &row, &time) != 3)",
          "66:       continue;",
          "67:     if ((unsigned)col >= width || (unsigned)row >= height)",
          "68:       continue;",
          "69:     if (time > timestamp)",
          "70:       continue;",
          "71:     for (tot = n = 0, rad = 1; rad < 3 && n == 0; rad++)",
          "72:       for (r = row - rad; r <= row + rad; r++)",
          "73:         for (c = col - rad; c <= col + rad; c++)",
          "74:           if ((unsigned)r < height && (unsigned)c < width && (r != row || c != col) && fcol(r, c) == fcol(row, col))",
          "75:           {",
          "76:             tot += BAYER2(r, c);",
          "77:             n++;",
          "78:           }",
          "79:     BAYER2(row, col) = tot / n;",
          "81:     if (verbose)",
          "82:     {",
          "84:         fprintf(stderr, _(\"Fixed dead pixels at:\"));",
          "85:       fprintf(stderr, \" %d,%d\", col, row);",
          "90:   if (fixed)",
          "91:     fputc('\\n', stderr);",
          "93:   fclose(fp);",
          "95:   RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS, 1, 2);",
          "99: void CLASS subtract(const char *fname)",
          "102:   int dim[3] = {0, 0, 0}, comment = 0, number = 0, error = 0, nd = 0, c, row, col;",
          "105:   RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME, 0, 2);",
          "108:   if (!(fp = fopen(fname, \"rb\")))",
          "109:   {",
          "111:     perror(fname);",
          "118:   if (fgetc(fp) != 'P' || fgetc(fp) != '5')",
          "119:     error = 1;",
          "120:   while (!error && nd < 3 && (c = fgetc(fp)) != EOF)",
          "121:   {",
          "122:     if (c == '#')",
          "123:       comment = 1;",
          "124:     if (c == '\\n')",
          "125:       comment = 0;",
          "126:     if (comment)",
          "127:       continue;",
          "128:     if (isdigit(c))",
          "129:       number = 1;",
          "130:     if (number)",
          "131:     {",
          "132:       if (isdigit(c))",
          "133:         dim[nd] = dim[nd] * 10 + c - '0';",
          "134:       else if (isspace(c))",
          "135:       {",
          "136:         number = 0;",
          "137:         nd++;",
          "138:       }",
          "139:       else",
          "140:         error = 1;",
          "143:   if (error || nd < 3)",
          "144:   {",
          "146:     fprintf(stderr, _(\"%s is not a valid PGM file!\\n\"), fname);",
          "148:     fclose(fp);",
          "149:     return;",
          "150:   }",
          "151:   else if (dim[0] != width || dim[1] != height || dim[2] != 65535)",
          "152:   {",
          "154:     fprintf(stderr, _(\"%s has the wrong dimensions!\\n\"), fname);",
          "157:     imgdata.process_warnings |= LIBRAW_WARN_BAD_DARKFRAME_DIM;",
          "159:     fclose(fp);",
          "160:     return;",
          "162:   pixel = (ushort *)calloc(width, sizeof *pixel);",
          "163:   merror(pixel, \"subtract()\");",
          "164:   for (row = 0; row < height; row++)",
          "165:   {",
          "166:     fread(pixel, 2, width, fp);",
          "167:     for (col = 0; col < width; col++)",
          "168:       BAYER(row, col) = MAX(BAYER(row, col) - ntohs(pixel[col]), 0);",
          "170:   free(pixel);",
          "171:   fclose(fp);",
          "172:   memset(cblack, 0, sizeof cblack);",
          "175:   RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME, 1, 2);",
          "179: void CLASS apply_profile(const char *input, const char *output)",
          "182:   cmsHPROFILE hInProfile = 0, hOutProfile = 0;",
          "187:   if (strcmp(input, \"embed\"))",
          "188:     hInProfile = cmsOpenProfileFromFile(input, \"r\");",
          "189:   else if (profile_length)",
          "190:   {",
          "192:     prof = (char *)malloc(profile_length);",
          "193:     merror(prof, \"apply_profile()\");",
          "194:     fseek(ifp, profile_offset, SEEK_SET);",
          "195:     fread(prof, 1, profile_length, ifp);",
          "196:     hInProfile = cmsOpenProfileFromMem(prof, profile_length);",
          "197:     free(prof);",
          "199:     hInProfile = cmsOpenProfileFromMem(imgdata.color.profile, profile_length);",
          "201:   }",
          "202:   else",
          "203:   {",
          "205:     imgdata.process_warnings |= LIBRAW_WARN_NO_EMBEDDED_PROFILE;",
          "208:     fprintf(stderr, _(\"%s has no embedded profile.\\n\"), ifname);",
          "210:   }",
          "212:   {",
          "214:     imgdata.process_warnings |= LIBRAW_WARN_NO_INPUT_PROFILE;",
          "216:     return;",
          "217:   }",
          "220:   else if ((fp = fopen(output, \"rb\")))",
          "221:   {",
          "222:     fread(&size, 4, 1, fp);",
          "223:     fseek(fp, 0, SEEK_SET);",
          "224:     oprof = (unsigned *)malloc(size = ntohl(size));",
          "225:     merror(oprof, \"apply_profile()\");",
          "226:     fread(oprof, 1, size, fp);",
          "227:     fclose(fp);",
          "228:     if (!(hOutProfile = cmsOpenProfileFromMem(oprof, size)))",
          "229:     {",
          "230:       free(oprof);",
          "235:   else",
          "236:     fprintf(stderr, _(\"Cannot open file %s!\\n\"), output);",
          "239:   {",
          "241:     imgdata.process_warnings |= LIBRAW_WARN_BAD_OUTPUT_PROFILE;",
          "243:     goto quit;",
          "244:   }",
          "247:     fprintf(stderr, _(\"Applying color profile...\\n\"));",
          "250:   RUN_CALLBACK(LIBRAW_PROGRESS_APPLY_PROFILE, 0, 2);",
          "251: #endif",
          "252:   hTransform = cmsCreateTransform(hInProfile, TYPE_RGBA_16, hOutProfile, TYPE_RGBA_16, INTENT_PERCEPTUAL, 0);",
          "253:   cmsDoTransform(hTransform, image, image, width * height);",
          "255:   cmsDeleteTransform(hTransform);",
          "256:   cmsCloseProfile(hOutProfile);",
          "258:   cmsCloseProfile(hInProfile);",
          "260:   RUN_CALLBACK(LIBRAW_PROGRESS_APPLY_PROFILE, 1, 2);",
          "",
          "---------------"
        ],
        "internal/defines.h||internal/defines.h": [
          "File: internal/defines.h -> internal/defines.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "45: #ifdef __CYGWIN__",
          "46: #include <io.h>",
          "47: #endif",
          "49: #include <sys/utime.h>",
          "50: #include <winsock2.h>",
          "51: #pragma comment(lib, \"ws2_32.lib\")",
          "",
          "[Removed Lines]",
          "48: #if defined WIN32 || defined (__MINGW32__)",
          "",
          "[Added Lines]",
          "48: #if defined WIN32 || defined(__MINGW32__)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "91: #endif",
          "93: #ifndef LONG_BIT",
          "95: #endif",
          "97: #define FORC3 FORC(3)",
          "98: #define FORC4 FORC(4)",
          "102: #define ABS(x) (((int)(x) ^ ((int)(x) >> 31)) - ((int)(x) >> 31))",
          "118:    In order to inline this calculation, I make the risky",
          "",
          "[Removed Lines]",
          "94: #define LONG_BIT (8 * sizeof (long))",
          "96: #define FORC(cnt) for (c=0; c < cnt; c++)",
          "99: #define FORCC for (c=0; c < colors && c < 4; c++)",
          "101: #define SQR(x) ((x)*(x))",
          "103: #define MIN(a,b) ((a) < (b) ? (a) : (b))",
          "104: #define MAX(a,b) ((a) > (b) ? (a) : (b))",
          "105: #define LIM(x,min,max) MAX(min,MIN(x,max))",
          "106: #define ULIM(x,y,z) ((y) < (z) ? LIM(x,y,z) : LIM(x,z,y))",
          "107: #define CLIP(x) LIM((int)(x),0,65535)",
          "108: #define SWAP(a,b) { a=a+b; b=a-b; a=a-b; }",
          "110: #define my_swap(type, i, j) {type t = i; i = j; j = t;}",
          "112: static float fMAX(float a, float b)",
          "113: {",
          "114:   return MAX(a,b);",
          "115: }",
          "",
          "[Added Lines]",
          "94: #define LONG_BIT (8 * sizeof(long))",
          "96: #define FORC(cnt) for (c = 0; c < cnt; c++)",
          "99: #define FORCC for (c = 0; c < colors && c < 4; c++)",
          "101: #define SQR(x) ((x) * (x))",
          "103: #define MIN(a, b) ((a) < (b) ? (a) : (b))",
          "104: #define MAX(a, b) ((a) > (b) ? (a) : (b))",
          "105: #define LIM(x, min, max) MAX(min, MIN(x, max))",
          "106: #define ULIM(x, y, z) ((y) < (z) ? LIM(x, y, z) : LIM(x, z, y))",
          "107: #define CLIP(x) LIM((int)(x), 0, 65535)",
          "108: #define SWAP(a, b)                                                                                                     \\",
          "109:   {                                                                                                                    \\",
          "110:     a = a + b;                                                                                                         \\",
          "111:     b = a - b;                                                                                                         \\",
          "112:     a = a - b;                                                                                                         \\",
          "113:   }",
          "115: #define my_swap(type, i, j)                                                                                            \\",
          "116:   {                                                                                                                    \\",
          "117:     type t = i;                                                                                                        \\",
          "118:     i = j;                                                                                                             \\",
          "119:     j = t;                                                                                                             \\",
          "120:   }",
          "122: static float fMAX(float a, float b) { return MAX(a, b); }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "125:    Return values are either 0/1/2/3 = G/M/C/Y or 0/1/2/3 = R/G1/B/G2",
          "145:    All RGB cameras use one of these Bayer grids:",
          "",
          "[Removed Lines]",
          "127:  PowerShot 600 PowerShot A50 PowerShot Pro70 Pro90 & G1",
          "128:  0xe1e4e1e4: 0x1b4e4b1e: 0x1e4b4e1b: 0xb4b4b4b4:",
          "130:    0 1 2 3 4 5   0 1 2 3 4 5   0 1 2 3 4 5   0 1 2 3 4 5",
          "131:  0 G M G M G M 0 C Y C Y C Y 0 Y C Y C Y C 0 G M G M G M",
          "132:  1 C Y C Y C Y 1 M G M G M G 1 M G M G M G 1 Y C Y C Y C",
          "133:  2 M G M G M G 2 Y C Y C Y C 2 C Y C Y C Y",
          "134:  3 C Y C Y C Y 3 G M G M G M 3 G M G M G M",
          "135:    4 C Y C Y C Y 4 Y C Y C Y C",
          "136:  PowerShot A5 5 G M G M G M 5 G M G M G M",
          "137:  0x1e4e1e4e: 6 Y C Y C Y C 6 C Y C Y C Y",
          "138:    7 M G M G M G 7 M G M G M G",
          "139:    0 1 2 3 4 5",
          "140:  0 C Y C Y C Y",
          "141:  1 G M G M G M",
          "142:  2 C Y C Y C Y",
          "143:  3 M G M G M G",
          "147:  0x16161616: 0x61616161: 0x49494949: 0x94949494:",
          "149:    0 1 2 3 4 5   0 1 2 3 4 5   0 1 2 3 4 5   0 1 2 3 4 5",
          "150:  0 B G B G B G 0 G R G R G R 0 G B G B G B 0 R G R G R G",
          "151:  1 G R G R G R 1 B G B G B G 1 R G R G R G 1 G B G B G B",
          "152:  2 B G B G B G 2 G R G R G R 2 G B G B G B 2 R G R G R G",
          "153:  3 G R G R G R 3 B G B G B G 3 R G R G R G 3 G B G B G B",
          "156: #define RAW(row,col) \\",
          "157:  raw_image[(row)*raw_width+(col)]",
          "158: #define BAYER(row,col) \\",
          "159:  image[((row) >> shrink)*iwidth + ((col) >> shrink)][FC(row,col)]",
          "161: #define BAYER2(row,col) \\",
          "162:  image[((row) >> shrink)*iwidth + ((col) >> shrink)][fcol(row,col)]",
          "",
          "[Added Lines]",
          "134:         PowerShot 600 PowerShot A50 PowerShot Pro70 Pro90 & G1",
          "135:         0xe1e4e1e4: 0x1b4e4b1e: 0x1e4b4e1b: 0xb4b4b4b4:",
          "137:           0 1 2 3 4 5   0 1 2 3 4 5   0 1 2 3 4 5   0 1 2 3 4 5",
          "138:         0 G M G M G M 0 C Y C Y C Y 0 Y C Y C Y C 0 G M G M G M",
          "139:         1 C Y C Y C Y 1 M G M G M G 1 M G M G M G 1 Y C Y C Y C",
          "140:         2 M G M G M G 2 Y C Y C Y C 2 C Y C Y C Y",
          "141:         3 C Y C Y C Y 3 G M G M G M 3 G M G M G M",
          "142:                         4 C Y C Y C Y 4 Y C Y C Y C",
          "143:         PowerShot A5 5 G M G M G M 5 G M G M G M",
          "144:         0x1e4e1e4e: 6 Y C Y C Y C 6 C Y C Y C Y",
          "145:                         7 M G M G M G 7 M G M G M G",
          "146:           0 1 2 3 4 5",
          "147:         0 C Y C Y C Y",
          "148:         1 G M G M G M",
          "149:         2 C Y C Y C Y",
          "150:         3 M G M G M G",
          "154:         0x16161616: 0x61616161: 0x49494949: 0x94949494:",
          "156:           0 1 2 3 4 5   0 1 2 3 4 5   0 1 2 3 4 5   0 1 2 3 4 5",
          "157:         0 B G B G B G 0 G R G R G R 0 G B G B G B 0 R G R G R G",
          "158:         1 G R G R G R 1 B G B G B G 1 R G R G R G 1 G B G B G B",
          "159:         2 B G B G B G 2 G R G R G R 2 G B G B G B 2 R G R G R G",
          "160:         3 G R G R G R 3 B G B G B G 3 R G R G R G 3 G B G B G B",
          "163: #define RAW(row, col) raw_image[(row)*raw_width + (col)]",
          "164: #define BAYER(row, col) image[((row) >> shrink) * iwidth + ((col) >> shrink)][FC(row, col)]",
          "166: #define BAYER2(row, col) image[((row) >> shrink) * iwidth + ((col) >> shrink)][fcol(row, col)]",
          "",
          "---------------"
        ],
        "libraw/libraw.h||libraw/libraw.h": [
          "File: libraw/libraw.h -> libraw/libraw.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: #endif",
          "31: #include <limits.h>",
          "32: #include <memory.h>",
          "33: #include <stdio.h>",
          "34: #include <stdlib.h>",
          "37: #include \"libraw_datastream.h\"",
          "38: #include \"libraw_types.h\"",
          "39: #include \"libraw_const.h\"",
          "",
          "[Removed Lines]",
          "28: #define LIBRAW_USE_STREAMS_DATASTREAM_MAXSIZE (250*1024L*1024L)",
          "",
          "[Added Lines]",
          "28: #define LIBRAW_USE_STREAMS_DATASTREAM_MAXSIZE (250 * 1024L * 1024L)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "41: #include \"libraw_alloc.h\"",
          "43: #ifdef __cplusplus",
          "46: #endif",
          "53: #if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)",
          "56: #endif",
          "101: DllDef int libraw_get_raw_height(libraw_data_t *lr);",
          "102: DllDef int libraw_get_raw_width(libraw_data_t *lr);",
          "103: DllDef int libraw_get_iheight(libraw_data_t *lr);",
          "104: DllDef int libraw_get_iwidth(libraw_data_t *lr);",
          "108: DllDef int libraw_get_color_maximum(libraw_data_t *lr);",
          "114: #ifdef __cplusplus",
          "115: }",
          "116: #endif",
          "119: #ifdef __cplusplus",
          "121: class DllDef LibRaw",
          "122: {",
          "130: #if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)",
          "132: #endif",
          "202:   int phase_one_subtract_black(ushort *src, ushort *dest);",
          "203:   int phase_one_correct();",
          "206:   virtual void setCancelFlag();",
          "207:   virtual void clearCancelFlag();",
          "212: protected:",
          "242:     }",
          "273: #ifdef LIBRAW_DEMOSAIC_PACK_GPL2",
          "275: #endif",
          "284: #ifndef NO_LCMS",
          "286: #endif",
          "327: #ifdef LIBRAW_DEMOSAIC_PACK_GPL2",
          "329: #endif",
          "338: #ifdef LIBRAW_DEMOSAIC_PACK_GPL2",
          "340: #endif",
          "362:   int raw_was_read()",
          "363:   {",
          "366:   }",
          "368: #ifdef LIBRAW_LIBRARY_BUILD",
          "369: #include \"internal/libraw_internal_funcs.h\"",
          "370: #endif",
          "372: };",
          "374: #ifdef LIBRAW_LIBRARY_BUILD",
          "379: #endif",
          "",
          "[Removed Lines]",
          "44: extern \"C\"",
          "45: {",
          "47: DllDef    const char          *libraw_strerror(int errorcode);",
          "48: DllDef    const char          *libraw_strprogress(enum LibRaw_progress);",
          "50: DllDef    libraw_data_t       *libraw_init(unsigned int flags);",
          "51: DllDef    int                 libraw_open_file(libraw_data_t*, const char *);",
          "52: DllDef    int                 libraw_open_file_ex(libraw_data_t*, const char *, INT64 max_buff_sz);",
          "54: DllDef    int                 libraw_open_wfile(libraw_data_t*, const wchar_t *);",
          "55: DllDef    int                 libraw_open_wfile_ex(libraw_data_t*, const wchar_t *, INT64 max_buff_sz);",
          "57: DllDef    int                 libraw_open_buffer(libraw_data_t*, void * buffer, size_t size);",
          "58: DllDef    int                 libraw_unpack(libraw_data_t*);",
          "59: DllDef    int                 libraw_unpack_thumb(libraw_data_t*);",
          "60: DllDef    void                libraw_recycle_datastream(libraw_data_t*);",
          "61: DllDef    void                libraw_recycle(libraw_data_t*);",
          "62: DllDef    void                libraw_close(libraw_data_t*);",
          "63: DllDef    void                libraw_subtract_black(libraw_data_t*);",
          "64: DllDef    int                 libraw_raw2image(libraw_data_t*);",
          "65: DllDef    void                libraw_free_image(libraw_data_t*);",
          "67: DllDef    const char*         libraw_version();",
          "68: DllDef    int                 libraw_versionNumber();",
          "70: DllDef    const char**        libraw_cameraList();",
          "71: DllDef    int                 libraw_cameraCount();",
          "74: DllDef    void                libraw_set_memerror_handler(libraw_data_t*, memory_callback cb, void *datap);",
          "75: DllDef    void                libraw_set_exifparser_handler(libraw_data_t*, exif_parser_callback cb, void *datap);",
          "76: DllDef    void                libraw_set_dataerror_handler(libraw_data_t*,data_callback func,void *datap);",
          "77: DllDef    void                libraw_set_progress_handler(libraw_data_t*,progress_callback cb,void *datap);",
          "78: DllDef    const char *        libraw_unpack_function_name(libraw_data_t* lr);",
          "79: DllDef    int                 libraw_get_decoder_info(libraw_data_t* lr,libraw_decoder_info_t* d);",
          "80: DllDef    int      libraw_COLOR(libraw_data_t*,int row, int col);",
          "81: DllDef   unsigned     libraw_capabilities();",
          "84: DllDef    int                 libraw_adjust_sizes_info_only(libraw_data_t*);",
          "85: DllDef    int                 libraw_dcraw_ppm_tiff_writer(libraw_data_t* lr,const char *filename);",
          "86: DllDef    int                 libraw_dcraw_thumb_writer(libraw_data_t* lr,const char *fname);",
          "87: DllDef    int                 libraw_dcraw_process(libraw_data_t* lr);",
          "88: DllDef    libraw_processed_image_t* libraw_dcraw_make_mem_image(libraw_data_t* lr, int *errc);",
          "89: DllDef    libraw_processed_image_t* libraw_dcraw_make_mem_thumb(libraw_data_t* lr, int *errc);",
          "90: DllDef    void libraw_dcraw_clear_mem(libraw_processed_image_t*);",
          "92: DllDef void libraw_set_demosaic(libraw_data_t *lr,int value);",
          "93: DllDef void libraw_set_output_color(libraw_data_t *lr,int value);",
          "94: DllDef void libraw_set_user_mul(libraw_data_t *lr,int index, float val);",
          "95: DllDef void libraw_set_output_bps(libraw_data_t *lr,int value);",
          "96: DllDef void libraw_set_gamma(libraw_data_t *lr,int index, float value);",
          "97: DllDef void libraw_set_no_auto_bright(libraw_data_t *lr,int value);",
          "98: DllDef void libraw_set_bright(libraw_data_t *lr,float value);",
          "99: DllDef void libraw_set_highlight(libraw_data_t *lr,int value);",
          "100: DllDef void libraw_set_fbdd_noiserd(libraw_data_t *lr,int value);",
          "105: DllDef float libraw_get_cam_mul(libraw_data_t *lr,int index);",
          "106: DllDef float libraw_get_pre_mul(libraw_data_t *lr,int index);",
          "107: DllDef float libraw_get_rgb_cam(libraw_data_t *lr,int index1, int index2);",
          "109: DllDef void libraw_set_ca_correction(libraw_data_t *lr,int ca_correc, float ca_red, float ca_blue);",
          "110: DllDef void libraw_set_cfalinenoise(libraw_data_t *lr,int cfaline, float linenoise);",
          "111: DllDef void libraw_set_wf_debanding(libraw_data_t *lr, int wf_debanding, float wfd0, float wfd1, float wfd2, float wfd3);",
          "112: DllDef void libraw_set_interpolation_passes(libraw_data_t *lr,int passes);",
          "123:   public:",
          "124:     libraw_data_t imgdata;",
          "125:     int verbose;",
          "127:     LibRaw(unsigned int flags = LIBRAW_OPTIONS_NONE);",
          "128:     libraw_output_params_t*     output_params_ptr() { return &imgdata.params;}",
          "129:     int                         open_file(const char *fname, INT64 max_buffered_sz=LIBRAW_USE_STREAMS_DATASTREAM_MAXSIZE);",
          "131:  int                         open_file(const wchar_t *fname, INT64 max_buffered_sz=LIBRAW_USE_STREAMS_DATASTREAM_MAXSIZE);",
          "133:     int                         open_buffer(void *buffer, size_t size);",
          "134:     virtual int                 open_datastream(LibRaw_abstract_datastream *);",
          "135:  int       error_count(){return libraw_internal_data.unpacker_data.data_error;}",
          "136:  void       recycle_datastream();",
          "137:     int                         unpack(void);",
          "138:     int                         unpack_thumb(void);",
          "139:  int       thumbOK(INT64 maxsz=-1);",
          "140:     int                         adjust_sizes_info_only(void);",
          "141:     int                         subtract_black();",
          "142:     int                         subtract_black_internal();",
          "143:     int                         raw2image();",
          "144:     int                         raw2image_ex(int do_subtract_black);",
          "145:     void                        raw2image_start();",
          "146:     void                        free_image();",
          "147:     int                         adjust_maximum();",
          "148:     void           set_exifparser_handler( exif_parser_callback cb,void *data) {callbacks.exifparser_data = data; callbacks.exif_cb = cb; }",
          "149:     void                        set_memerror_handler( memory_callback cb,void *data) {callbacks.memcb_data = data; callbacks.mem_cb = cb; }",
          "150:     void                        set_dataerror_handler(data_callback func, void *data) { callbacks.datacb_data = data; callbacks.data_cb = func;}",
          "151:     void                        set_progress_handler(progress_callback pcb, void *data) { callbacks.progresscb_data = data; callbacks.progress_cb = pcb;}",
          "153:  void      convertFloatToInt(float dmin=4096.f, float dmax=32767.f, float dtarget = 16383.f);",
          "155:  static unsigned    capabilities();",
          "156:     static const char*          version();",
          "157:     static int                  versionNumber();",
          "158:     static const char**         cameraList();",
          "159:     static int                  cameraCount();",
          "160:     static const char*          strprogress(enum LibRaw_progress);",
          "161:     static const char*          strerror(int p);",
          "163:     int                         dcraw_ppm_tiff_writer(const char *filename);",
          "164:     int                         dcraw_thumb_writer(const char *fname);",
          "165:     int                         dcraw_process(void);",
          "167:     int is_fuji_rotated(){return libraw_internal_data.internal_output_params.fuji_width;}",
          "168:     int is_sraw();",
          "169:  int sraw_midpoint();",
          "170:  int is_nikon_sraw();",
          "171:  int is_coolscan_nef();",
          "172:  int is_floating_point();",
          "173:  int have_fpdata();",
          "175:     virtual libraw_processed_image_t*   dcraw_make_mem_image(int *errcode=NULL);",
          "176:     virtual libraw_processed_image_t*   dcraw_make_mem_thumb(int *errcode=NULL);",
          "177:     static void                 dcraw_clear_mem(libraw_processed_image_t*);",
          "180:     void get_mem_image_format(int* width, int* height, int* colors, int* bps) const;",
          "181:     int  copy_mem_image(void* scan0, int stride, int bgr);",
          "184:     void         recycle();",
          "185:     virtual ~LibRaw(void);",
          "187:     int COLOR(int row, int col) { return libraw_internal_data.internal_output_params.fuji_width? FCF(row,col):FC(row,col);}",
          "189:     int FC(int row,int col) { return (imgdata.idata.filters >> (((row << 1 & 14) | (col & 1)) << 1) & 3);}",
          "190:     int         fcol (int row, int col);",
          "192:     const char *unpack_function_name();",
          "193:     virtual int get_decoder_info(libraw_decoder_info_t* d_info);",
          "194:     libraw_internal_data_t * get_internal_data_pointer(){ return &libraw_internal_data; }",
          "197:     int  wf_remove_banding();",
          "205:   int  set_rawspeed_camerafile(char *filename);",
          "208:   virtual void adobe_coeff (const char *, const char *, int internal_only=0);",
          "210:   void set_dng_host(void *);",
          "213:  int  is_curve_linear();",
          "214:     void checkCancel();",
          "215:  void        cam_xyz_coeff(float _rgb_cam[3][4], double cam_xyz[4][3]);",
          "216:     void phase_one_allocate_tempbuffer();",
          "217:     void phase_one_free_tempbuffer();",
          "218:     virtual int  is_phaseone_compressed();",
          "219:  virtual int  is_canon_600();",
          "221:     virtual void copy_fuji_uncropped(unsigned short cblack[4], unsigned short *dmaxp);",
          "222:     virtual void copy_bayer(unsigned short cblack[4], unsigned short *dmaxp);",
          "223:     virtual void fuji_rotate();",
          "224:     virtual void convert_to_rgb_loop(float out_cam[3][4]);",
          "225:     virtual void lin_interpolate_loop(int code[16][16][32],int size);",
          "226:     virtual void scale_colors_loop(float scale_mul[4]);",
          "229:  virtual void xtrans_decode_loop(const struct xtrans_params* common_info, int count, INT64* offsets, unsigned *sizes);",
          "230:  void xtrans_decode_strip(const struct xtrans_params* info_common, int cur_block, INT64 raw_offset, unsigned size);",
          "232:     int FCF(int row,int col) {",
          "233:         int rr,cc;",
          "234:         if (libraw_internal_data.unpacker_data.fuji_layout) {",
          "235:             rr = libraw_internal_data.internal_output_params.fuji_width - 1 - col + (row >> 1);",
          "236:             cc = col + ((row+1) >> 1);",
          "237:         } else {",
          "238:             rr = libraw_internal_data.internal_output_params.fuji_width - 1 + row - (col >> 1);",
          "239:             cc = row + ((col+1) >> 1);",
          "240:         }",
          "241:         return FC(rr,cc);",
          "244:     void adjust_bl();",
          "245:     void*        malloc(size_t t);",
          "246:     void*        calloc(size_t n,size_t t);",
          "247:     void*        realloc(void *p, size_t s);",
          "248:     void        free(void *p);",
          "249:     void        merror (void *ptr, const char *where);",
          "250:     void        derror();",
          "252:     LibRaw_TLS  *tls;",
          "253:     libraw_internal_data_t libraw_internal_data;",
          "254:     decode      first_decode[2048], *second_decode, *free_decode;",
          "255:     tiff_ifd_t  tiff_ifd[10];",
          "256:     libraw_memmgr memmgr;",
          "257:     libraw_callbacks_t callbacks;",
          "259:     LibRaw_constants rgb_constants;",
          "261:     void        (LibRaw:: *write_thumb)();",
          "262:     void        (LibRaw:: *write_fun)();",
          "263:     void        (LibRaw:: *load_raw)();",
          "264:     void        (LibRaw:: *thumb_load_raw)();",
          "265:     void        (LibRaw:: *pentax_component_load_raw)();",
          "266:  void        (LibRaw:: *interpolate_bayer)();",
          "267:  void        (LibRaw:: *interpolate_xtrans)();",
          "269:     void        kodak_thumb_loader();",
          "270:     void        write_thumb_ppm_tiff(FILE *);",
          "271:     void        x3f_thumb_loader();",
          "272:  INT64  x3f_thumb_size();",
          "274:     void        foveon_thumb_loader (void);",
          "277:     int         own_filtering_supported(){ return 0;}",
          "278:     void        identify();",
          "279:     unsigned    parse_custom_cameras(unsigned limit, libraw_custom_camera_t table[], char** list);",
          "280:     void        write_ppm_tiff ();",
          "281:     void        convert_to_rgb();",
          "282:     void        remove_zeroes();",
          "283:     void        crop_masked_pixels();",
          "285:     void apply_profile(const char*,const char*);",
          "287:     void        pre_interpolate();",
          "288:     void        border_interpolate (int border);",
          "289:     void        lin_interpolate();",
          "290:     void        vng_interpolate();",
          "291:     void        ppg_interpolate();",
          "292:     void        cielab(ushort rgb[3], short lab[3]);",
          "293:     void        xtrans_interpolate(int);",
          "294:     void        ahd_interpolate();",
          "295:     void        dht_interpolate();",
          "296:     void        aahd_interpolate();",
          "299:     void        ahd_interpolate_mod();",
          "300:     void        afd_interpolate_pl(int afd_passes, int clip_on);",
          "301:     void        afd_noise_filter_pl();",
          "302:     void lmmse_interpolate(int gamma_apply);",
          "303:     void        dcb(int iterations, int dcb_enhance);",
          "304:     void        fbdd(int noiserd);",
          "305:     void        vcd_interpolate(int ahd_cutoff);",
          "306:     void        amaze_demosaic_RT();",
          "307:     void exp_bef(float expos, float preser);",
          "308:     void        CA_correct_RT(float cared, float cablue);",
          "309:     void        cfa_linedn(float linenoise);",
          "310:     void        cfa_impulse_gauss(float lclean, float cclean);",
          "311:     void        green_equilibrate(float thresh);",
          "315:     void        bad_pixels(const char*);",
          "316:     void        subtract(const char*);",
          "317:     void        hat_transform (float *temp, float *base, int st, int size, int sc);",
          "318:     void        wavelet_denoise();",
          "319:     void        scale_colors();",
          "320:     void        median_filter ();",
          "321:     void        blend_highlights();",
          "322:     void        recover_highlights();",
          "323:     void        green_matching();",
          "325:     void        stretch();",
          "328:     void        foveon_thumb ();",
          "330:     void        jpeg_thumb_writer (FILE *tfp,char *thumb,int thumb_length);",
          "331:     void        jpeg_thumb ();",
          "332:     void        ppm_thumb ();",
          "333:     void        ppm16_thumb();",
          "334:     void        layer_thumb ();",
          "335:     void        rollei_thumb ();",
          "336:     void        kodak_thumb_load_raw();",
          "339:     void        foveon_decoder (unsigned size, unsigned code);",
          "341:     unsigned    get4();",
          "343:     int         flip_index (int row, int col);",
          "344:     void        gamma_curve (double pwr, double ts, int mode, int imax);",
          "345:     void        cubic_spline (const int *x_, const int *y_, const int len);",
          "348:   void   *_rawspeed_camerameta;",
          "349:   void          *_rawspeed_decoder;",
          "350:   void   fix_after_rawspeed(int bl);",
          "353:   long          _exitflag;",
          "356:   void      *dnghost;",
          "357:   int   valid_for_dngsdk();",
          "358:   int   try_dngsdk();",
          "360:   void          *_x3f_data;",
          "364:    return imgdata.rawdata.raw_image || imgdata.rawdata.color4_image || imgdata.rawdata.color3_image",
          "365:     || imgdata.rawdata.float_image || imgdata.rawdata.float3_image || imgdata.rawdata.float4_image;",
          "375: #define RUN_CALLBACK(stage,iter,expect)  if(callbacks.progress_cb) { \\",
          "376:         int rr = (*callbacks.progress_cb)(callbacks.progresscb_data,stage,iter,expect); \\",
          "377:         if(rr!=0) throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK; \\",
          "378:     }",
          "",
          "[Added Lines]",
          "42: extern \"C\" {",
          "44: DllDef const char *libraw_strerror(int errorcode);",
          "45: DllDef const char *libraw_strprogress(enum LibRaw_progress);",
          "47: DllDef libraw_data_t *libraw_init(unsigned int flags);",
          "48: DllDef int libraw_open_file(libraw_data_t *, const char *);",
          "49: DllDef int libraw_open_file_ex(libraw_data_t *, const char *, INT64 max_buff_sz);",
          "51: DllDef int libraw_open_wfile(libraw_data_t *, const wchar_t *);",
          "52: DllDef int libraw_open_wfile_ex(libraw_data_t *, const wchar_t *, INT64 max_buff_sz);",
          "54: DllDef int libraw_open_buffer(libraw_data_t *, void *buffer, size_t size);",
          "55: DllDef int libraw_unpack(libraw_data_t *);",
          "56: DllDef int libraw_unpack_thumb(libraw_data_t *);",
          "57: DllDef void libraw_recycle_datastream(libraw_data_t *);",
          "58: DllDef void libraw_recycle(libraw_data_t *);",
          "59: DllDef void libraw_close(libraw_data_t *);",
          "60: DllDef void libraw_subtract_black(libraw_data_t *);",
          "61: DllDef int libraw_raw2image(libraw_data_t *);",
          "62: DllDef void libraw_free_image(libraw_data_t *);",
          "64: DllDef const char *libraw_version();",
          "65: DllDef int libraw_versionNumber();",
          "67: DllDef const char **libraw_cameraList();",
          "68: DllDef int libraw_cameraCount();",
          "71: DllDef void libraw_set_memerror_handler(libraw_data_t *, memory_callback cb, void *datap);",
          "72: DllDef void libraw_set_exifparser_handler(libraw_data_t *, exif_parser_callback cb, void *datap);",
          "73: DllDef void libraw_set_dataerror_handler(libraw_data_t *, data_callback func, void *datap);",
          "74: DllDef void libraw_set_progress_handler(libraw_data_t *, progress_callback cb, void *datap);",
          "75: DllDef const char *libraw_unpack_function_name(libraw_data_t *lr);",
          "76: DllDef int libraw_get_decoder_info(libraw_data_t *lr, libraw_decoder_info_t *d);",
          "77: DllDef int libraw_COLOR(libraw_data_t *, int row, int col);",
          "78: DllDef unsigned libraw_capabilities();",
          "81: DllDef int libraw_adjust_sizes_info_only(libraw_data_t *);",
          "82: DllDef int libraw_dcraw_ppm_tiff_writer(libraw_data_t *lr, const char *filename);",
          "83: DllDef int libraw_dcraw_thumb_writer(libraw_data_t *lr, const char *fname);",
          "84: DllDef int libraw_dcraw_process(libraw_data_t *lr);",
          "85: DllDef libraw_processed_image_t *libraw_dcraw_make_mem_image(libraw_data_t *lr, int *errc);",
          "86: DllDef libraw_processed_image_t *libraw_dcraw_make_mem_thumb(libraw_data_t *lr, int *errc);",
          "87: DllDef void libraw_dcraw_clear_mem(libraw_processed_image_t *);",
          "89: DllDef void libraw_set_demosaic(libraw_data_t *lr, int value);",
          "90: DllDef void libraw_set_output_color(libraw_data_t *lr, int value);",
          "91: DllDef void libraw_set_user_mul(libraw_data_t *lr, int index, float val);",
          "92: DllDef void libraw_set_output_bps(libraw_data_t *lr, int value);",
          "93: DllDef void libraw_set_gamma(libraw_data_t *lr, int index, float value);",
          "94: DllDef void libraw_set_no_auto_bright(libraw_data_t *lr, int value);",
          "95: DllDef void libraw_set_bright(libraw_data_t *lr, float value);",
          "96: DllDef void libraw_set_highlight(libraw_data_t *lr, int value);",
          "97: DllDef void libraw_set_fbdd_noiserd(libraw_data_t *lr, int value);",
          "102: DllDef float libraw_get_cam_mul(libraw_data_t *lr, int index);",
          "103: DllDef float libraw_get_pre_mul(libraw_data_t *lr, int index);",
          "104: DllDef float libraw_get_rgb_cam(libraw_data_t *lr, int index1, int index2);",
          "106: DllDef void libraw_set_ca_correction(libraw_data_t *lr, int ca_correc, float ca_red, float ca_blue);",
          "107: DllDef void libraw_set_cfalinenoise(libraw_data_t *lr, int cfaline, float linenoise);",
          "108: DllDef void libraw_set_wf_debanding(libraw_data_t *lr, int wf_debanding, float wfd0, float wfd1, float wfd2,",
          "109:                                     float wfd3);",
          "110: DllDef void libraw_set_interpolation_passes(libraw_data_t *lr, int passes);",
          "120: public:",
          "121:   libraw_data_t imgdata;",
          "122:   int verbose;",
          "124:   LibRaw(unsigned int flags = LIBRAW_OPTIONS_NONE);",
          "125:   libraw_output_params_t *output_params_ptr() { return &imgdata.params; }",
          "126:   int open_file(const char *fname, INT64 max_buffered_sz = LIBRAW_USE_STREAMS_DATASTREAM_MAXSIZE);",
          "128:   int open_file(const wchar_t *fname, INT64 max_buffered_sz = LIBRAW_USE_STREAMS_DATASTREAM_MAXSIZE);",
          "130:   int open_buffer(void *buffer, size_t size);",
          "131:   virtual int open_datastream(LibRaw_abstract_datastream *);",
          "132:   int error_count() { return libraw_internal_data.unpacker_data.data_error; }",
          "133:   void recycle_datastream();",
          "134:   int unpack(void);",
          "135:   int unpack_thumb(void);",
          "136:   int thumbOK(INT64 maxsz = -1);",
          "137:   int adjust_sizes_info_only(void);",
          "138:   int subtract_black();",
          "139:   int subtract_black_internal();",
          "140:   int raw2image();",
          "141:   int raw2image_ex(int do_subtract_black);",
          "142:   void raw2image_start();",
          "143:   void free_image();",
          "144:   int adjust_maximum();",
          "145:   void set_exifparser_handler(exif_parser_callback cb, void *data)",
          "146:   {",
          "147:     callbacks.exifparser_data = data;",
          "148:     callbacks.exif_cb = cb;",
          "149:   }",
          "150:   void set_memerror_handler(memory_callback cb, void *data)",
          "151:   {",
          "152:     callbacks.memcb_data = data;",
          "153:     callbacks.mem_cb = cb;",
          "154:   }",
          "155:   void set_dataerror_handler(data_callback func, void *data)",
          "156:   {",
          "157:     callbacks.datacb_data = data;",
          "158:     callbacks.data_cb = func;",
          "159:   }",
          "160:   void set_progress_handler(progress_callback pcb, void *data)",
          "161:   {",
          "162:     callbacks.progresscb_data = data;",
          "163:     callbacks.progress_cb = pcb;",
          "164:   }",
          "166:   void convertFloatToInt(float dmin = 4096.f, float dmax = 32767.f, float dtarget = 16383.f);",
          "168:   static unsigned capabilities();",
          "169:   static const char *version();",
          "170:   static int versionNumber();",
          "171:   static const char **cameraList();",
          "172:   static int cameraCount();",
          "173:   static const char *strprogress(enum LibRaw_progress);",
          "174:   static const char *strerror(int p);",
          "176:   int dcraw_ppm_tiff_writer(const char *filename);",
          "177:   int dcraw_thumb_writer(const char *fname);",
          "178:   int dcraw_process(void);",
          "180:   int is_fuji_rotated() { return libraw_internal_data.internal_output_params.fuji_width; }",
          "181:   int is_sraw();",
          "182:   int sraw_midpoint();",
          "183:   int is_nikon_sraw();",
          "184:   int is_coolscan_nef();",
          "185:   int is_floating_point();",
          "186:   int have_fpdata();",
          "188:   virtual libraw_processed_image_t *dcraw_make_mem_image(int *errcode = NULL);",
          "189:   virtual libraw_processed_image_t *dcraw_make_mem_thumb(int *errcode = NULL);",
          "190:   static void dcraw_clear_mem(libraw_processed_image_t *);",
          "193:   void get_mem_image_format(int *width, int *height, int *colors, int *bps) const;",
          "194:   int copy_mem_image(void *scan0, int stride, int bgr);",
          "197:   void recycle();",
          "198:   virtual ~LibRaw(void);",
          "200:   int COLOR(int row, int col)",
          "201:   {",
          "202:     return libraw_internal_data.internal_output_params.fuji_width ? FCF(row, col) : FC(row, col);",
          "203:   }",
          "205:   int FC(int row, int col) { return (imgdata.idata.filters >> (((row << 1 & 14) | (col & 1)) << 1) & 3); }",
          "206:   int fcol(int row, int col);",
          "208:   const char *unpack_function_name();",
          "209:   virtual int get_decoder_info(libraw_decoder_info_t *d_info);",
          "210:   libraw_internal_data_t *get_internal_data_pointer() { return &libraw_internal_data; }",
          "213:   int wf_remove_banding();",
          "221:   int set_rawspeed_camerafile(char *filename);",
          "224:   virtual void adobe_coeff(const char *, const char *, int internal_only = 0);",
          "226:   void set_dng_host(void *);",
          "229:   int is_curve_linear();",
          "230:   void checkCancel();",
          "231:   void cam_xyz_coeff(float _rgb_cam[3][4], double cam_xyz[4][3]);",
          "232:   void phase_one_allocate_tempbuffer();",
          "233:   void phase_one_free_tempbuffer();",
          "234:   virtual int is_phaseone_compressed();",
          "235:   virtual int is_canon_600();",
          "237:   virtual void copy_fuji_uncropped(unsigned short cblack[4], unsigned short *dmaxp);",
          "238:   virtual void copy_bayer(unsigned short cblack[4], unsigned short *dmaxp);",
          "239:   virtual void fuji_rotate();",
          "240:   virtual void convert_to_rgb_loop(float out_cam[3][4]);",
          "241:   virtual void lin_interpolate_loop(int code[16][16][32], int size);",
          "242:   virtual void scale_colors_loop(float scale_mul[4]);",
          "245:   virtual void xtrans_decode_loop(const struct xtrans_params *common_info, int count, INT64 *offsets, unsigned *sizes);",
          "246:   void xtrans_decode_strip(const struct xtrans_params *info_common, int cur_block, INT64 raw_offset, unsigned size);",
          "248:   int FCF(int row, int col)",
          "249:   {",
          "250:     int rr, cc;",
          "251:     if (libraw_internal_data.unpacker_data.fuji_layout)",
          "252:     {",
          "253:       rr = libraw_internal_data.internal_output_params.fuji_width - 1 - col + (row >> 1);",
          "254:       cc = col + ((row + 1) >> 1);",
          "256:     else",
          "257:     {",
          "258:       rr = libraw_internal_data.internal_output_params.fuji_width - 1 + row - (col >> 1);",
          "259:       cc = row + ((col + 1) >> 1);",
          "260:     }",
          "261:     return FC(rr, cc);",
          "262:   }",
          "264:   void adjust_bl();",
          "265:   void *malloc(size_t t);",
          "266:   void *calloc(size_t n, size_t t);",
          "267:   void *realloc(void *p, size_t s);",
          "268:   void free(void *p);",
          "269:   void merror(void *ptr, const char *where);",
          "270:   void derror();",
          "272:   LibRaw_TLS *tls;",
          "273:   libraw_internal_data_t libraw_internal_data;",
          "274:   decode first_decode[2048], *second_decode, *free_decode;",
          "275:   tiff_ifd_t tiff_ifd[10];",
          "276:   libraw_memmgr memmgr;",
          "277:   libraw_callbacks_t callbacks;",
          "279:   LibRaw_constants rgb_constants;",
          "281:   void (LibRaw::*write_thumb)();",
          "282:   void (LibRaw::*write_fun)();",
          "283:   void (LibRaw::*load_raw)();",
          "284:   void (LibRaw::*thumb_load_raw)();",
          "285:   void (LibRaw::*pentax_component_load_raw)();",
          "286:   void (LibRaw::*interpolate_bayer)();",
          "287:   void (LibRaw::*interpolate_xtrans)();",
          "289:   void kodak_thumb_loader();",
          "290:   void write_thumb_ppm_tiff(FILE *);",
          "291:   void x3f_thumb_loader();",
          "292:   INT64 x3f_thumb_size();",
          "294:   void foveon_thumb_loader(void);",
          "297:   int own_filtering_supported() { return 0; }",
          "298:   void identify();",
          "299:   unsigned parse_custom_cameras(unsigned limit, libraw_custom_camera_t table[], char **list);",
          "300:   void write_ppm_tiff();",
          "301:   void convert_to_rgb();",
          "302:   void remove_zeroes();",
          "303:   void crop_masked_pixels();",
          "305:   void apply_profile(const char *, const char *);",
          "307:   void pre_interpolate();",
          "308:   void border_interpolate(int border);",
          "309:   void lin_interpolate();",
          "310:   void vng_interpolate();",
          "311:   void ppg_interpolate();",
          "312:   void cielab(ushort rgb[3], short lab[3]);",
          "313:   void xtrans_interpolate(int);",
          "314:   void ahd_interpolate();",
          "315:   void dht_interpolate();",
          "316:   void aahd_interpolate();",
          "319:   void ahd_interpolate_mod();",
          "320:   void afd_interpolate_pl(int afd_passes, int clip_on);",
          "321:   void afd_noise_filter_pl();",
          "322:   void lmmse_interpolate(int gamma_apply);",
          "323:   void dcb(int iterations, int dcb_enhance);",
          "324:   void fbdd(int noiserd);",
          "325:   void vcd_interpolate(int ahd_cutoff);",
          "326:   void amaze_demosaic_RT();",
          "327:   void exp_bef(float expos, float preser);",
          "328:   void CA_correct_RT(float cared, float cablue);",
          "329:   void cfa_linedn(float linenoise);",
          "330:   void cfa_impulse_gauss(float lclean, float cclean);",
          "331:   void green_equilibrate(float thresh);",
          "335:   void bad_pixels(const char *);",
          "336:   void subtract(const char *);",
          "337:   void hat_transform(float *temp, float *base, int st, int size, int sc);",
          "338:   void wavelet_denoise();",
          "339:   void scale_colors();",
          "340:   void median_filter();",
          "341:   void blend_highlights();",
          "342:   void recover_highlights();",
          "343:   void green_matching();",
          "345:   void stretch();",
          "348:   void foveon_thumb();",
          "350:   void jpeg_thumb_writer(FILE *tfp, char *thumb, int thumb_length);",
          "351:   void jpeg_thumb();",
          "352:   void ppm_thumb();",
          "353:   void ppm16_thumb();",
          "354:   void layer_thumb();",
          "355:   void rollei_thumb();",
          "356:   void kodak_thumb_load_raw();",
          "359:   void foveon_decoder(unsigned size, unsigned code);",
          "361:   unsigned get4();",
          "363:   int flip_index(int row, int col);",
          "364:   void gamma_curve(double pwr, double ts, int mode, int imax);",
          "365:   void cubic_spline(const int *x_, const int *y_, const int len);",
          "368:   void *_rawspeed_camerameta;",
          "369:   void *_rawspeed_decoder;",
          "370:   void fix_after_rawspeed(int bl);",
          "373:   long _exitflag;",
          "376:   void *dnghost;",
          "377:   int valid_for_dngsdk();",
          "378:   int try_dngsdk();",
          "380:   void *_x3f_data;",
          "384:     return imgdata.rawdata.raw_image || imgdata.rawdata.color4_image || imgdata.rawdata.color3_image ||",
          "385:            imgdata.rawdata.float_image || imgdata.rawdata.float3_image || imgdata.rawdata.float4_image;",
          "394: #define RUN_CALLBACK(stage, iter, expect)                                                                              \\",
          "395:   if (callbacks.progress_cb)                                                                                           \\",
          "396:   {                                                                                                                    \\",
          "397:     int rr = (*callbacks.progress_cb)(callbacks.progresscb_data, stage, iter, expect);                                 \\",
          "398:     if (rr != 0)                                                                                                       \\",
          "399:       throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;                                                                    \\",
          "400:   }",
          "",
          "---------------"
        ],
        "libraw/libraw_alloc.h||libraw/libraw_alloc.h": [
          "File: libraw/libraw_alloc.h -> libraw/libraw_alloc.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: class DllDef libraw_memmgr",
          "30: {",
          "50:         {",
          "55:         }",
          "92: };",
          "",
          "[Removed Lines]",
          "31:   public:",
          "32:     libraw_memmgr()",
          "33:         {",
          "34:             memset(mems,0,sizeof(mems));",
          "35:             calloc_cnt=0;",
          "36:         }",
          "37:     void *malloc(size_t sz)",
          "38:         {",
          "39:             void *ptr = ::malloc(sz);",
          "40:             mem_ptr(ptr);",
          "41:             return ptr;",
          "42:         }",
          "43:     void *calloc(size_t n, size_t sz)",
          "44:         {",
          "45:             void *ptr =  ::calloc(n,sz);",
          "46:             mem_ptr(ptr);",
          "47:             return ptr;",
          "48:         }",
          "49:     void *realloc(void *ptr,size_t newsz)",
          "51:             void *ret = ::realloc(ptr,newsz);",
          "52:             forget_ptr(ptr);",
          "53:             mem_ptr(ret);",
          "54:             return ret;",
          "56:     void  free(void *ptr)",
          "57:     {",
          "58:         forget_ptr(ptr);",
          "59:         ::free(ptr);",
          "60:     }",
          "61:     void cleanup(void)",
          "62:     {",
          "63:         for(int i = 0; i< LIBRAW_MSIZE; i++)",
          "64:             if(mems[i])",
          "65:                 {",
          "66:                     free(mems[i]);",
          "67:                     mems[i] = NULL;",
          "68:                 }",
          "69:     }",
          "71:   private:",
          "72:     void *mems[LIBRAW_MSIZE];",
          "73:     int calloc_cnt;",
          "74:     void mem_ptr(void *ptr)",
          "75:     {",
          "76:         if(ptr)",
          "77:             for(int i=0;i < LIBRAW_MSIZE; i++)",
          "78:                 if(!mems[i])",
          "79:                     {",
          "80:                         mems[i] = ptr;",
          "81:                         break;",
          "82:                     }",
          "83:     }",
          "84:     void forget_ptr(void *ptr)",
          "85:     {",
          "86:         if(ptr)",
          "87:             for(int i=0;i < LIBRAW_MSIZE; i++)",
          "88:                 if(mems[i] == ptr)",
          "89:                     mems[i] = NULL;",
          "90:     }",
          "",
          "[Added Lines]",
          "31: public:",
          "32:   libraw_memmgr()",
          "33:   {",
          "34:     memset(mems, 0, sizeof(mems));",
          "35:     calloc_cnt = 0;",
          "36:   }",
          "37:   void *malloc(size_t sz)",
          "38:   {",
          "39:     void *ptr = ::malloc(sz);",
          "40:     mem_ptr(ptr);",
          "41:     return ptr;",
          "42:   }",
          "43:   void *calloc(size_t n, size_t sz)",
          "44:   {",
          "45:     void *ptr = ::calloc(n, sz);",
          "46:     mem_ptr(ptr);",
          "47:     return ptr;",
          "48:   }",
          "49:   void *realloc(void *ptr, size_t newsz)",
          "50:   {",
          "51:     void *ret = ::realloc(ptr, newsz);",
          "52:     forget_ptr(ptr);",
          "53:     mem_ptr(ret);",
          "54:     return ret;",
          "55:   }",
          "56:   void free(void *ptr)",
          "57:   {",
          "58:     forget_ptr(ptr);",
          "59:     ::free(ptr);",
          "60:   }",
          "61:   void cleanup(void)",
          "62:   {",
          "63:     for (int i = 0; i < LIBRAW_MSIZE; i++)",
          "64:       if (mems[i])",
          "65:       {",
          "66:         free(mems[i]);",
          "67:         mems[i] = NULL;",
          "68:       }",
          "69:   }",
          "71: private:",
          "72:   void *mems[LIBRAW_MSIZE];",
          "73:   int calloc_cnt;",
          "74:   void mem_ptr(void *ptr)",
          "75:   {",
          "76:     if (ptr)",
          "77:       for (int i = 0; i < LIBRAW_MSIZE; i++)",
          "78:         if (!mems[i])",
          "80:           mems[i] = ptr;",
          "81:           break;",
          "83:   }",
          "84:   void forget_ptr(void *ptr)",
          "85:   {",
          "86:     if (ptr)",
          "87:       for (int i = 0; i < LIBRAW_MSIZE; i++)",
          "88:         if (mems[i] == ptr)",
          "89:           mems[i] = NULL;",
          "90:   }",
          "",
          "---------------"
        ],
        "libraw/libraw_const.h||libraw/libraw_const.h": [
          "File: libraw/libraw_const.h -> libraw/libraw_const.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: enum LibRaw_whitebalance_code",
          "24: {",
          "56: };",
          "58: enum LibRaw_dng_processing",
          "59: {",
          "70: };",
          "72: enum LibRaw_runtime_capabilities",
          "73: {",
          "78: };",
          "80: enum LibRaw_camera_mounts",
          "109: enum LibRaw_camera_formats",
          "119: enum LibRaw_sony_cameratypes",
          "129: enum LibRaw_processing_options",
          "146: enum LibRaw_decoder_flags",
          "147: {",
          "156: };",
          "158: #define LIBRAW_XTRANS 9",
          "160: enum LibRaw_constructor_flags",
          "161: {",
          "165: };",
          "167: enum LibRaw_warnings",
          "168: {",
          "186: };",
          "188: enum LibRaw_exceptions",
          "189: {",
          "200: };",
          "202: enum LibRaw_progress",
          "203: {",
          "239: };",
          "240: #define LIBRAW_PROGRESS_THUMB_MASK 0x0fffffff",
          "242: enum LibRaw_errors",
          "243: {",
          "258: };",
          "262: enum LibRaw_thumbnail_formats",
          "263: {",
          "269: };",
          "271: enum LibRaw_image_formats",
          "272: {",
          "275: };",
          "277: #endif",
          "",
          "[Removed Lines]",
          "26:     EXIF light sources",
          "27:     12 = FL-D; Daylight fluorescent (D 5700K \u2013 7100K) (F1,F5)",
          "28:     13 = FL-N; Day white fluorescent (N 4600K \u2013 5400K) (F7,F8)",
          "29:     14 = FL-W; Cool white fluorescent (W 3900K \u2013 4500K) (F2,F6, office, store, warehouse)",
          "30:     15 = FL-WW; White fluorescent (WW 3200K \u2013 3700K) (F3, residential)",
          "31:     16 = FL-L; Soft/Warm white fluorescent (L 2600K - 3250K) (F4, kitchen, bath)",
          "33: LIBRAW_WBI_Unknown=0,",
          "34: LIBRAW_WBI_Daylight=1,",
          "35: LIBRAW_WBI_Fluorescent=2,",
          "36: LIBRAW_WBI_Tungsten=3,",
          "37: LIBRAW_WBI_Flash=4,",
          "38: LIBRAW_WBI_FineWeather=9,",
          "39: LIBRAW_WBI_Cloudy=10,",
          "40: LIBRAW_WBI_Shade=11,",
          "41: LIBRAW_WBI_FL_D=12,",
          "42: LIBRAW_WBI_FL_N=13,",
          "43: LIBRAW_WBI_FL_W=14,",
          "44: LIBRAW_WBI_FL_WW=15,",
          "45: LIBRAW_WBI_FL_L=16,",
          "46: LIBRAW_WBI_Ill_A=17,",
          "47: LIBRAW_WBI_Ill_B=18,",
          "48: LIBRAW_WBI_Ill_C=19,",
          "49: LIBRAW_WBI_D55=20,",
          "50: LIBRAW_WBI_D65=21,",
          "51: LIBRAW_WBI_D75=22,",
          "52: LIBRAW_WBI_D50=23,",
          "53: LIBRAW_WBI_StudioTungsten=24,",
          "54: LIBRAW_WBI_Sunset=64,",
          "55: LIBRAW_WBI_Other=255",
          "60:  LIBRAW_DNG_NONE=0,",
          "61:  LIBRAW_DNG_FLOAT=1,",
          "62:  LIBRAW_DNG_LINEAR=2,",
          "63:  LIBRAW_DNG_DEFLATE=4,",
          "64:  LIBRAW_DNG_XTRANS=8,",
          "65:  LIBRAW_DNG_OTHER=16,",
          "66:  LIBRAW_DNG_8BIT=32,",
          "68:  LIBRAW_DNG_ALL = LIBRAW_DNG_FLOAT|LIBRAW_DNG_LINEAR|LIBRAW_DNG_XTRANS|LIBRAW_DNG_8BIT|LIBRAW_DNG_OTHER /* |LIBRAW_DNG_LARGERANGE */,",
          "69:  LIBRAW_DNG_DEFAULT=LIBRAW_DNG_FLOAT|LIBRAW_DNG_LINEAR|LIBRAW_DNG_DEFLATE|LIBRAW_DNG_8BIT",
          "74:  LIBRAW_CAPS_RAWSPEED=1,",
          "75:  LIBRAW_CAPS_DNGSDK=2,",
          "76:  LIBRAW_CAPS_DEMOSAICSGPL2=4,",
          "77:  LIBRAW_CAPS_DEMOSAICSGPL3=8",
          "81:   {",
          "82:     LIBRAW_MOUNT_Unknown=0,",
          "83:     LIBRAW_MOUNT_Minolta_A=1,",
          "84:     LIBRAW_MOUNT_Sony_E=2,",
          "85:     LIBRAW_MOUNT_Canon_EF=3,",
          "86:     LIBRAW_MOUNT_Canon_EF_S=4,",
          "87:     LIBRAW_MOUNT_Canon_EF_M=5,",
          "88:     LIBRAW_MOUNT_Nikon_F=6,",
          "92:     LIBRAW_MOUNT_Pentax_K=10,",
          "93:     LIBRAW_MOUNT_Pentax_Q=11,",
          "94:     LIBRAW_MOUNT_Pentax_645=12,",
          "95:     LIBRAW_MOUNT_Fuji_X=13,",
          "96:     LIBRAW_MOUNT_Leica_M=14,",
          "97:     LIBRAW_MOUNT_Leica_R=15,",
          "98:     LIBRAW_MOUNT_Leica_S=16,",
          "99:     LIBRAW_MOUNT_Samsung_NX=17,",
          "100:     LIBRAW_MOUNT_RicohModule=18,",
          "101:     LIBRAW_MOUNT_Samsung_NX_M=19,",
          "102:     LIBRAW_MOUNT_Leica_T=20,",
          "103:     LIBRAW_MOUNT_Contax_N=21,",
          "104:     LIBRAW_MOUNT_Sigma_X3F=22,",
          "105:     LIBRAW_MOUNT_Leica_SL=23,",
          "106:     LIBRAW_MOUNT_FixedLens=99",
          "107:   };",
          "110:   {",
          "111:     LIBRAW_FORMAT_APSC=1,",
          "112:     LIBRAW_FORMAT_FF=2,",
          "113:     LIBRAW_FORMAT_MF=3,",
          "114:     LIBRAW_FORMAT_APSH=4,",
          "115:     LIBRAW_FORMAT_1INCH=5,",
          "116:     LIBRAW_FORMAT_FT=8",
          "117:   };",
          "120:   {",
          "121:     LIBRAW_SONY_DSC=1,",
          "122:     LIBRAW_SONY_DSLR=2,",
          "123:     LIBRAW_SONY_NEX=3,",
          "124:     LIBRAW_SONY_SLT=4,",
          "125:     LIBRAW_SONY_ILCE=5,",
          "126:     LIBRAW_SONY_ILCA=6",
          "127:   };",
          "130:   {",
          "131:     LIBRAW_PROCESSING_SONYARW2_NONE=0,",
          "132:     LIBRAW_PROCESSING_SONYARW2_BASEONLY=1,",
          "133:     LIBRAW_PROCESSING_SONYARW2_DELTAONLY=1<<1,",
          "134:     LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE=1<<2,",
          "135:     LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE=1<<3,",
          "136:     LIBRAW_PROCESSING_SONYARW2_ALLFLAGS = LIBRAW_PROCESSING_SONYARW2_BASEONLY + LIBRAW_PROCESSING_SONYARW2_DELTAONLY + LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE + LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE,",
          "137:     LIBRAW_PROCESSING_DP2Q_INTERPOLATERG=1<<4,",
          "138:     LIBRAW_PROCESSING_DP2Q_INTERPOLATEAF=1<<5,",
          "139:     LIBRAW_PROCESSING_PENTAX_PS_ALLFRAMES=1<<6,",
          "140:     LIBRAW_PROCESSING_CONVERTFLOAT_TO_INT=1<<7,",
          "141:     LIBRAW_PROCESSING_SRAW_NO_RGB=1<<8,",
          "142:     LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE=1<<9,",
          "143:     LIBRAW_PROCESSING_FORCE_FOVEON_X3F=1<<10",
          "144:   };",
          "148:     LIBRAW_DECODER_HASCURVE = 1<<4,",
          "149:     LIBRAW_DECODER_SONYARW2 = 1<<5,",
          "150:     LIBRAW_DECODER_TRYRAWSPEED = 1<<6,",
          "151:     LIBRAW_DECODER_OWNALLOC = 1<<7,",
          "152:     LIBRAW_DECODER_FIXEDMAXC = 1<<8,",
          "153:  LIBRAW_DECODER_ADOBECOPYPIXEL = 1<<9,",
          "154:  LIBRAW_DECODER_LEGACY_WITH_MARGINS = 1<<10,",
          "155:     LIBRAW_DECODER_NOTSET = 1<<15",
          "162:     LIBRAW_OPTIONS_NONE         =0,",
          "163:     LIBRAW_OPIONS_NO_MEMERR_CALLBACK=1,",
          "164:     LIBRAW_OPIONS_NO_DATAERR_CALLBACK=1<<1",
          "169:     LIBRAW_WARN_NONE            =0,",
          "170:     LIBRAW_WARN_FOVEON_NOMATRIX =1,",
          "171:     LIBRAW_WARN_FOVEON_INVALIDWB =1<<1,",
          "172:     LIBRAW_WARN_BAD_CAMERA_WB   =1<<2,",
          "173:     LIBRAW_WARN_NO_METADATA     =1<<3,",
          "174:     LIBRAW_WARN_NO_JPEGLIB     = 1<<4,",
          "175:     LIBRAW_WARN_NO_EMBEDDED_PROFILE = 1<<5,",
          "176:     LIBRAW_WARN_NO_INPUT_PROFILE = 1<<6,",
          "177:     LIBRAW_WARN_BAD_OUTPUT_PROFILE= 1<<7,",
          "178:     LIBRAW_WARN_NO_BADPIXELMAP=1<<8,",
          "179:     LIBRAW_WARN_BAD_DARKFRAME_FILE=1<<9,",
          "180:     LIBRAW_WARN_BAD_DARKFRAME_DIM=1<<10,",
          "181:     LIBRAW_WARN_NO_JASPER = 1<<11,",
          "182:     LIBRAW_WARN_RAWSPEED_PROBLEM = 1<<12,",
          "183:     LIBRAW_WARN_RAWSPEED_UNSUPPORTED = 1<<13,",
          "184:     LIBRAW_WARN_RAWSPEED_PROCESSED = 1<<14,",
          "185:     LIBRAW_WARN_FALLBACK_TO_AHD = 1<<15",
          "190:     LIBRAW_EXCEPTION_NONE       =0,",
          "191:     LIBRAW_EXCEPTION_ALLOC      =1,",
          "192:     LIBRAW_EXCEPTION_DECODE_RAW =2,",
          "193:     LIBRAW_EXCEPTION_DECODE_JPEG=3,",
          "194:     LIBRAW_EXCEPTION_IO_EOF     =4,",
          "195:     LIBRAW_EXCEPTION_IO_CORRUPT =5,",
          "196:     LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK=6,",
          "197:     LIBRAW_EXCEPTION_BAD_CROP =7,",
          "198:     LIBRAW_EXCEPTION_IO_BADFILE =8,",
          "199:     LIBRAW_EXCEPTION_DECODE_JPEG2000=9",
          "204:     LIBRAW_PROGRESS_START               = 0,",
          "205:     LIBRAW_PROGRESS_OPEN                = 1,",
          "206:     LIBRAW_PROGRESS_IDENTIFY            = 1<<1,",
          "207:     LIBRAW_PROGRESS_SIZE_ADJUST         = 1<<2,",
          "208:     LIBRAW_PROGRESS_LOAD_RAW            = 1<<3,",
          "209:     LIBRAW_PROGRESS_RAW2_IMAGE  = 1<<4,",
          "210:     LIBRAW_PROGRESS_REMOVE_ZEROES       = 1<<5,",
          "211:     LIBRAW_PROGRESS_BAD_PIXELS          = 1<<6,",
          "212:     LIBRAW_PROGRESS_DARK_FRAME          = 1<<7,",
          "213:     LIBRAW_PROGRESS_FOVEON_INTERPOLATE  = 1<<8,",
          "214:     LIBRAW_PROGRESS_SCALE_COLORS        = 1<<9,",
          "215:     LIBRAW_PROGRESS_PRE_INTERPOLATE     = 1<<10,",
          "216:     LIBRAW_PROGRESS_INTERPOLATE         = 1<<11,",
          "217:     LIBRAW_PROGRESS_MIX_GREEN           = 1<<12,",
          "218:     LIBRAW_PROGRESS_MEDIAN_FILTER       = 1<<13,",
          "219:     LIBRAW_PROGRESS_HIGHLIGHTS          = 1<<14,",
          "220:     LIBRAW_PROGRESS_FUJI_ROTATE         = 1<<15,",
          "221:     LIBRAW_PROGRESS_FLIP                = 1<<16,",
          "222:     LIBRAW_PROGRESS_APPLY_PROFILE       = 1<<17,",
          "223:     LIBRAW_PROGRESS_CONVERT_RGB         = 1<<18,",
          "224:     LIBRAW_PROGRESS_STRETCH             = 1<<19,",
          "226:     LIBRAW_PROGRESS_STAGE20             = 1<<20,",
          "227:     LIBRAW_PROGRESS_STAGE21             = 1<<21,",
          "228:     LIBRAW_PROGRESS_STAGE22             = 1<<22,",
          "229:     LIBRAW_PROGRESS_STAGE23             = 1<<23,",
          "230:     LIBRAW_PROGRESS_STAGE24             = 1<<24,",
          "231:     LIBRAW_PROGRESS_STAGE25             = 1<<25,",
          "232:     LIBRAW_PROGRESS_STAGE26             = 1<<26,",
          "233:     LIBRAW_PROGRESS_STAGE27             = 1<<27,",
          "235:     LIBRAW_PROGRESS_THUMB_LOAD          = 1<<28,",
          "236:     LIBRAW_PROGRESS_TRESERVED1          = 1<<29,",
          "237:     LIBRAW_PROGRESS_TRESERVED2          = 1<<30,",
          "238:     LIBRAW_PROGRESS_TRESERVED3          = 1<<31",
          "244:     LIBRAW_SUCCESS = 0,",
          "245:     LIBRAW_UNSPECIFIED_ERROR=-1,",
          "246:     LIBRAW_FILE_UNSUPPORTED = -2,",
          "247:     LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE=-3,",
          "248:     LIBRAW_OUT_OF_ORDER_CALL=-4,",
          "249:     LIBRAW_NO_THUMBNAIL=-5,",
          "250:     LIBRAW_UNSUPPORTED_THUMBNAIL=-6,",
          "251:     LIBRAW_INPUT_CLOSED=-7,",
          "252:     LIBRAW_NOT_IMPLEMENTED=-8,",
          "253:     LIBRAW_UNSUFFICIENT_MEMORY=-100007,",
          "254:     LIBRAW_DATA_ERROR=-100008,",
          "255:     LIBRAW_IO_ERROR=-100009,",
          "256:     LIBRAW_CANCELLED_BY_CALLBACK=-100010,",
          "257:     LIBRAW_BAD_CROP=-100011",
          "260: #define LIBRAW_FATAL_ERROR(ec) ((ec)<-100000)",
          "264:     LIBRAW_THUMBNAIL_UNKNOWN=0,",
          "265:     LIBRAW_THUMBNAIL_JPEG=1,",
          "266:     LIBRAW_THUMBNAIL_BITMAP=2,",
          "267:     LIBRAW_THUMBNAIL_LAYER=4,",
          "268:     LIBRAW_THUMBNAIL_ROLLEI=5",
          "273:     LIBRAW_IMAGE_JPEG=1,",
          "274:     LIBRAW_IMAGE_BITMAP=2",
          "",
          "[Added Lines]",
          "26:       EXIF light sources",
          "27:       12 = FL-D; Daylight fluorescent (D 5700K \u2013 7100K) (F1,F5)",
          "28:       13 = FL-N; Day white fluorescent (N 4600K \u2013 5400K) (F7,F8)",
          "29:       14 = FL-W; Cool white fluorescent (W 3900K \u2013 4500K) (F2,F6, office, store, warehouse)",
          "30:       15 = FL-WW; White fluorescent (WW 3200K \u2013 3700K) (F3, residential)",
          "31:       16 = FL-L; Soft/Warm white fluorescent (L 2600K - 3250K) (F4, kitchen, bath)",
          "33:   LIBRAW_WBI_Unknown = 0,",
          "34:   LIBRAW_WBI_Daylight = 1,",
          "35:   LIBRAW_WBI_Fluorescent = 2,",
          "36:   LIBRAW_WBI_Tungsten = 3,",
          "37:   LIBRAW_WBI_Flash = 4,",
          "38:   LIBRAW_WBI_FineWeather = 9,",
          "39:   LIBRAW_WBI_Cloudy = 10,",
          "40:   LIBRAW_WBI_Shade = 11,",
          "41:   LIBRAW_WBI_FL_D = 12,",
          "42:   LIBRAW_WBI_FL_N = 13,",
          "43:   LIBRAW_WBI_FL_W = 14,",
          "44:   LIBRAW_WBI_FL_WW = 15,",
          "45:   LIBRAW_WBI_FL_L = 16,",
          "46:   LIBRAW_WBI_Ill_A = 17,",
          "47:   LIBRAW_WBI_Ill_B = 18,",
          "48:   LIBRAW_WBI_Ill_C = 19,",
          "49:   LIBRAW_WBI_D55 = 20,",
          "50:   LIBRAW_WBI_D65 = 21,",
          "51:   LIBRAW_WBI_D75 = 22,",
          "52:   LIBRAW_WBI_D50 = 23,",
          "53:   LIBRAW_WBI_StudioTungsten = 24,",
          "54:   LIBRAW_WBI_Sunset = 64,",
          "55:   LIBRAW_WBI_Other = 255",
          "60:   LIBRAW_DNG_NONE = 0,",
          "61:   LIBRAW_DNG_FLOAT = 1,",
          "62:   LIBRAW_DNG_LINEAR = 2,",
          "63:   LIBRAW_DNG_DEFLATE = 4,",
          "64:   LIBRAW_DNG_XTRANS = 8,",
          "65:   LIBRAW_DNG_OTHER = 16,",
          "66:   LIBRAW_DNG_8BIT = 32,",
          "68:   LIBRAW_DNG_ALL = LIBRAW_DNG_FLOAT | LIBRAW_DNG_LINEAR | LIBRAW_DNG_XTRANS | LIBRAW_DNG_8BIT |",
          "69:                    LIBRAW_DNG_OTHER /* |LIBRAW_DNG_LARGERANGE */,",
          "70:   LIBRAW_DNG_DEFAULT = LIBRAW_DNG_FLOAT | LIBRAW_DNG_LINEAR | LIBRAW_DNG_DEFLATE | LIBRAW_DNG_8BIT",
          "75:   LIBRAW_CAPS_RAWSPEED = 1,",
          "76:   LIBRAW_CAPS_DNGSDK = 2,",
          "77:   LIBRAW_CAPS_DEMOSAICSGPL2 = 4,",
          "78:   LIBRAW_CAPS_DEMOSAICSGPL3 = 8",
          "82: {",
          "83:   LIBRAW_MOUNT_Unknown = 0,",
          "84:   LIBRAW_MOUNT_Minolta_A = 1,",
          "85:   LIBRAW_MOUNT_Sony_E = 2,",
          "86:   LIBRAW_MOUNT_Canon_EF = 3,",
          "87:   LIBRAW_MOUNT_Canon_EF_S = 4,",
          "88:   LIBRAW_MOUNT_Canon_EF_M = 5,",
          "89:   LIBRAW_MOUNT_Nikon_F = 6,",
          "93:   LIBRAW_MOUNT_Pentax_K = 10,",
          "94:   LIBRAW_MOUNT_Pentax_Q = 11,",
          "95:   LIBRAW_MOUNT_Pentax_645 = 12,",
          "96:   LIBRAW_MOUNT_Fuji_X = 13,",
          "97:   LIBRAW_MOUNT_Leica_M = 14,",
          "98:   LIBRAW_MOUNT_Leica_R = 15,",
          "99:   LIBRAW_MOUNT_Leica_S = 16,",
          "100:   LIBRAW_MOUNT_Samsung_NX = 17,",
          "101:   LIBRAW_MOUNT_RicohModule = 18,",
          "102:   LIBRAW_MOUNT_Samsung_NX_M = 19,",
          "103:   LIBRAW_MOUNT_Leica_T = 20,",
          "104:   LIBRAW_MOUNT_Contax_N = 21,",
          "105:   LIBRAW_MOUNT_Sigma_X3F = 22,",
          "106:   LIBRAW_MOUNT_Leica_SL = 23,",
          "107:   LIBRAW_MOUNT_FixedLens = 99",
          "108: };",
          "111: {",
          "112:   LIBRAW_FORMAT_APSC = 1,",
          "113:   LIBRAW_FORMAT_FF = 2,",
          "114:   LIBRAW_FORMAT_MF = 3,",
          "115:   LIBRAW_FORMAT_APSH = 4,",
          "116:   LIBRAW_FORMAT_1INCH = 5,",
          "117:   LIBRAW_FORMAT_FT = 8",
          "118: };",
          "121: {",
          "122:   LIBRAW_SONY_DSC = 1,",
          "123:   LIBRAW_SONY_DSLR = 2,",
          "124:   LIBRAW_SONY_NEX = 3,",
          "125:   LIBRAW_SONY_SLT = 4,",
          "126:   LIBRAW_SONY_ILCE = 5,",
          "127:   LIBRAW_SONY_ILCA = 6",
          "128: };",
          "131: {",
          "132:   LIBRAW_PROCESSING_SONYARW2_NONE = 0,",
          "133:   LIBRAW_PROCESSING_SONYARW2_BASEONLY = 1,",
          "134:   LIBRAW_PROCESSING_SONYARW2_DELTAONLY = 1 << 1,",
          "135:   LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE = 1 << 2,",
          "136:   LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE = 1 << 3,",
          "137:   LIBRAW_PROCESSING_SONYARW2_ALLFLAGS = LIBRAW_PROCESSING_SONYARW2_BASEONLY + LIBRAW_PROCESSING_SONYARW2_DELTAONLY +",
          "138:                                         LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE +",
          "139:                                         LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE,",
          "140:   LIBRAW_PROCESSING_DP2Q_INTERPOLATERG = 1 << 4,",
          "141:   LIBRAW_PROCESSING_DP2Q_INTERPOLATEAF = 1 << 5,",
          "142:   LIBRAW_PROCESSING_PENTAX_PS_ALLFRAMES = 1 << 6,",
          "143:   LIBRAW_PROCESSING_CONVERTFLOAT_TO_INT = 1 << 7,",
          "144:   LIBRAW_PROCESSING_SRAW_NO_RGB = 1 << 8,",
          "145:   LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE = 1 << 9,",
          "146:   LIBRAW_PROCESSING_FORCE_FOVEON_X3F = 1 << 10",
          "147: };",
          "151:   LIBRAW_DECODER_HASCURVE = 1 << 4,",
          "152:   LIBRAW_DECODER_SONYARW2 = 1 << 5,",
          "153:   LIBRAW_DECODER_TRYRAWSPEED = 1 << 6,",
          "154:   LIBRAW_DECODER_OWNALLOC = 1 << 7,",
          "155:   LIBRAW_DECODER_FIXEDMAXC = 1 << 8,",
          "156:   LIBRAW_DECODER_ADOBECOPYPIXEL = 1 << 9,",
          "157:   LIBRAW_DECODER_LEGACY_WITH_MARGINS = 1 << 10,",
          "158:   LIBRAW_DECODER_NOTSET = 1 << 15",
          "165:   LIBRAW_OPTIONS_NONE = 0,",
          "166:   LIBRAW_OPIONS_NO_MEMERR_CALLBACK = 1,",
          "167:   LIBRAW_OPIONS_NO_DATAERR_CALLBACK = 1 << 1",
          "172:   LIBRAW_WARN_NONE = 0,",
          "173:   LIBRAW_WARN_FOVEON_NOMATRIX = 1,",
          "174:   LIBRAW_WARN_FOVEON_INVALIDWB = 1 << 1,",
          "175:   LIBRAW_WARN_BAD_CAMERA_WB = 1 << 2,",
          "176:   LIBRAW_WARN_NO_METADATA = 1 << 3,",
          "177:   LIBRAW_WARN_NO_JPEGLIB = 1 << 4,",
          "178:   LIBRAW_WARN_NO_EMBEDDED_PROFILE = 1 << 5,",
          "179:   LIBRAW_WARN_NO_INPUT_PROFILE = 1 << 6,",
          "180:   LIBRAW_WARN_BAD_OUTPUT_PROFILE = 1 << 7,",
          "181:   LIBRAW_WARN_NO_BADPIXELMAP = 1 << 8,",
          "182:   LIBRAW_WARN_BAD_DARKFRAME_FILE = 1 << 9,",
          "183:   LIBRAW_WARN_BAD_DARKFRAME_DIM = 1 << 10,",
          "184:   LIBRAW_WARN_NO_JASPER = 1 << 11,",
          "185:   LIBRAW_WARN_RAWSPEED_PROBLEM = 1 << 12,",
          "186:   LIBRAW_WARN_RAWSPEED_UNSUPPORTED = 1 << 13,",
          "187:   LIBRAW_WARN_RAWSPEED_PROCESSED = 1 << 14,",
          "188:   LIBRAW_WARN_FALLBACK_TO_AHD = 1 << 15",
          "193:   LIBRAW_EXCEPTION_NONE = 0,",
          "194:   LIBRAW_EXCEPTION_ALLOC = 1,",
          "195:   LIBRAW_EXCEPTION_DECODE_RAW = 2,",
          "196:   LIBRAW_EXCEPTION_DECODE_JPEG = 3,",
          "197:   LIBRAW_EXCEPTION_IO_EOF = 4,",
          "198:   LIBRAW_EXCEPTION_IO_CORRUPT = 5,",
          "199:   LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK = 6,",
          "200:   LIBRAW_EXCEPTION_BAD_CROP = 7,",
          "201:   LIBRAW_EXCEPTION_IO_BADFILE = 8,",
          "202:   LIBRAW_EXCEPTION_DECODE_JPEG2000 = 9",
          "207:   LIBRAW_PROGRESS_START = 0,",
          "208:   LIBRAW_PROGRESS_OPEN = 1,",
          "209:   LIBRAW_PROGRESS_IDENTIFY = 1 << 1,",
          "210:   LIBRAW_PROGRESS_SIZE_ADJUST = 1 << 2,",
          "211:   LIBRAW_PROGRESS_LOAD_RAW = 1 << 3,",
          "212:   LIBRAW_PROGRESS_RAW2_IMAGE = 1 << 4,",
          "213:   LIBRAW_PROGRESS_REMOVE_ZEROES = 1 << 5,",
          "214:   LIBRAW_PROGRESS_BAD_PIXELS = 1 << 6,",
          "215:   LIBRAW_PROGRESS_DARK_FRAME = 1 << 7,",
          "216:   LIBRAW_PROGRESS_FOVEON_INTERPOLATE = 1 << 8,",
          "217:   LIBRAW_PROGRESS_SCALE_COLORS = 1 << 9,",
          "218:   LIBRAW_PROGRESS_PRE_INTERPOLATE = 1 << 10,",
          "219:   LIBRAW_PROGRESS_INTERPOLATE = 1 << 11,",
          "220:   LIBRAW_PROGRESS_MIX_GREEN = 1 << 12,",
          "221:   LIBRAW_PROGRESS_MEDIAN_FILTER = 1 << 13,",
          "222:   LIBRAW_PROGRESS_HIGHLIGHTS = 1 << 14,",
          "223:   LIBRAW_PROGRESS_FUJI_ROTATE = 1 << 15,",
          "224:   LIBRAW_PROGRESS_FLIP = 1 << 16,",
          "225:   LIBRAW_PROGRESS_APPLY_PROFILE = 1 << 17,",
          "226:   LIBRAW_PROGRESS_CONVERT_RGB = 1 << 18,",
          "227:   LIBRAW_PROGRESS_STRETCH = 1 << 19,",
          "229:   LIBRAW_PROGRESS_STAGE20 = 1 << 20,",
          "230:   LIBRAW_PROGRESS_STAGE21 = 1 << 21,",
          "231:   LIBRAW_PROGRESS_STAGE22 = 1 << 22,",
          "232:   LIBRAW_PROGRESS_STAGE23 = 1 << 23,",
          "233:   LIBRAW_PROGRESS_STAGE24 = 1 << 24,",
          "234:   LIBRAW_PROGRESS_STAGE25 = 1 << 25,",
          "235:   LIBRAW_PROGRESS_STAGE26 = 1 << 26,",
          "236:   LIBRAW_PROGRESS_STAGE27 = 1 << 27,",
          "238:   LIBRAW_PROGRESS_THUMB_LOAD = 1 << 28,",
          "239:   LIBRAW_PROGRESS_TRESERVED1 = 1 << 29,",
          "240:   LIBRAW_PROGRESS_TRESERVED2 = 1 << 30,",
          "241:   LIBRAW_PROGRESS_TRESERVED3 = 1 << 31",
          "247:   LIBRAW_SUCCESS = 0,",
          "248:   LIBRAW_UNSPECIFIED_ERROR = -1,",
          "249:   LIBRAW_FILE_UNSUPPORTED = -2,",
          "250:   LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE = -3,",
          "251:   LIBRAW_OUT_OF_ORDER_CALL = -4,",
          "252:   LIBRAW_NO_THUMBNAIL = -5,",
          "253:   LIBRAW_UNSUPPORTED_THUMBNAIL = -6,",
          "254:   LIBRAW_INPUT_CLOSED = -7,",
          "255:   LIBRAW_NOT_IMPLEMENTED = -8,",
          "256:   LIBRAW_UNSUFFICIENT_MEMORY = -100007,",
          "257:   LIBRAW_DATA_ERROR = -100008,",
          "258:   LIBRAW_IO_ERROR = -100009,",
          "259:   LIBRAW_CANCELLED_BY_CALLBACK = -100010,",
          "260:   LIBRAW_BAD_CROP = -100011",
          "263: #define LIBRAW_FATAL_ERROR(ec) ((ec) < -100000)",
          "267:   LIBRAW_THUMBNAIL_UNKNOWN = 0,",
          "268:   LIBRAW_THUMBNAIL_JPEG = 1,",
          "269:   LIBRAW_THUMBNAIL_BITMAP = 2,",
          "270:   LIBRAW_THUMBNAIL_LAYER = 4,",
          "271:   LIBRAW_THUMBNAIL_ROLLEI = 5",
          "276:   LIBRAW_IMAGE_JPEG = 1,",
          "277:   LIBRAW_IMAGE_BITMAP = 2",
          "",
          "---------------"
        ],
        "libraw/libraw_datastream.h||libraw/libraw_datastream.h": [
          "File: libraw/libraw_datastream.h -> libraw/libraw_datastream.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: #include <fstream>",
          "35: #include <memory>",
          "38: #include <winsock2.h>",
          "",
          "[Removed Lines]",
          "37: #if defined WIN32 || defined (__MINGW32__)",
          "",
          "[Added Lines]",
          "36: #if defined WIN32 || defined(__MINGW32__)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "46: #ifdef USE_DNGSDK",
          "49: #define qWinOS 1",
          "50: #define qMacOS 0",
          "51: #elif defined(__APPLE__)",
          "",
          "[Removed Lines]",
          "48: #if defined WIN32 || defined (__MINGW32__)",
          "",
          "[Added Lines]",
          "47: #if defined WIN32 || defined(__MINGW32__)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "54: #else",
          "56: #endif",
          "58: #define qDNGUseLibJPEG 1",
          "60: #define qDNGExperimental 1",
          "61: #define qDNGThreadSafe 1",
          "62: #include \"dng_stream.h\"",
          "68: class LibRaw_buffer_datastream;",
          "69: class LibRaw_bit_buffer;",
          "71: class DllDef LibRaw_abstract_datastream",
          "72: {",
          "92: #if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)",
          "95: #endif",
          "104: };",
          "106: #ifdef WIN32",
          "107: template class DllDef std::auto_ptr<std::streambuf>;",
          "108: #endif",
          "111: {",
          "117: #ifdef WIN32",
          "119: #endif",
          "124: #if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)",
          "126: #endif",
          "143: #if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)",
          "146: #endif",
          "149: };",
          "153: {",
          "178: };",
          "180: class DllDef LibRaw_bigfile_datastream : public LibRaw_abstract_datastream",
          "181: {",
          "184: #if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)",
          "186: #endif",
          "200: #if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)",
          "203: #endif",
          "208: #if !defined(_WIN32) && !defined(__MINGW32__)",
          "210: #else",
          "212: #endif",
          "215: protected:",
          "219: #ifdef WIN32",
          "221: #endif",
          "222: };",
          "224: #ifdef WIN32",
          "226: {",
          "227: public:",
          "236: protected:",
          "247: };",
          "249: #endif",
          "251: #ifdef USE_DNGSDK",
          "254: {",
          "255: public:",
          "282: private:",
          "287: };",
          "289: #endif",
          "",
          "[Removed Lines]",
          "57: #define qDNGXMPDocOps  0",
          "59: #define qDNGXMPFiles   0",
          "66: #define IOERROR() do { throw LIBRAW_EXCEPTION_IO_EOF; } while(0)",
          "73:   public:",
          "74:     LibRaw_abstract_datastream(){ substream=0;};",
          "75:     virtual             ~LibRaw_abstract_datastream(void){if(substream) delete substream;}",
          "76:     virtual int         valid() = 0;",
          "77:     virtual int         read(void *,size_t, size_t ) = 0;",
          "78:     virtual int         seek(INT64 , int ) = 0;",
          "79:     virtual INT64       tell() = 0;",
          "80:     virtual INT64  size() = 0;",
          "81:     virtual int         get_char() = 0;",
          "82:     virtual char*       gets(char *, int) = 0;",
          "83:     virtual int         scanf_one(const char *, void *) = 0;",
          "84:     virtual int         eof() = 0;",
          "85:     virtual void *      make_jas_stream() = 0;",
          "86:     virtual int         jpeg_src(void *) { return -1; }",
          "89:  virtual void  unlock(){}",
          "91:     virtual const char* fname(){ return NULL;};",
          "93:  virtual const wchar_t* wfname(){ return NULL;};",
          "94:  virtual int         subfile_open(const wchar_t*) { return -1;}",
          "96:     virtual int         subfile_open(const char*) { return -1;}",
          "97:     virtual void        subfile_close() { }",
          "99:     virtual int  tempbuffer_open(void*, size_t);",
          "100:     virtual void tempbuffer_close();",
          "102:   protected:",
          "103:     LibRaw_abstract_datastream *substream;",
          "110: class DllDef  LibRaw_file_datastream: public LibRaw_abstract_datastream",
          "112:   protected:",
          "115:     std::string filename;",
          "116:     INT64 _fsize;",
          "118:     std::wstring wfilename;",
          "120:     FILE *jas_file;",
          "121:   public:",
          "122:     virtual     ~LibRaw_file_datastream();",
          "123:                 LibRaw_file_datastream(const char *fname);",
          "125:                 LibRaw_file_datastream(const wchar_t *fname);",
          "127:     virtual void        *make_jas_stream();",
          "128:     virtual int         jpeg_src(void *jpegdata);",
          "129:     virtual int         valid();",
          "130:     virtual int         read(void * ptr,size_t size, size_t nmemb);",
          "131:     virtual int         eof();",
          "132:     virtual int         seek(INT64 o, int whence);",
          "133:     virtual INT64       tell();",
          "134:     virtual INT64 size() { return _fsize;}",
          "135:     virtual int         get_char()",
          "136:         {",
          "137:             if(substream) return substream->get_char();",
          "138:             return f->sbumpc();",
          "139:         }",
          "140:     virtual char*       gets(char *str, int sz);",
          "141:     virtual int         scanf_one(const char *fmt, void*val);",
          "142:     virtual const char* fname();",
          "144:     virtual const wchar_t* wfname();",
          "145:     virtual int         subfile_open(const wchar_t *fn);",
          "147:     virtual int         subfile_open(const char *fn);",
          "148:     virtual void        subfile_close();",
          "152: class DllDef  LibRaw_buffer_datastream : public LibRaw_abstract_datastream",
          "154:   public:",
          "155:                         LibRaw_buffer_datastream(void *buffer, size_t bsize);",
          "156:     virtual             ~LibRaw_buffer_datastream();",
          "157:     virtual int         valid();",
          "158:     virtual void        *make_jas_stream();",
          "159:     virtual int         jpeg_src(void *jpegdata);",
          "160:     virtual int         read(void * ptr,size_t sz, size_t nmemb);",
          "161:     virtual int         eof();",
          "162:     virtual int         seek(INT64 o, int whence);",
          "163:     virtual INT64       tell();",
          "164:     virtual INT64 size() { return streamsize;}",
          "165:     virtual char*       gets(char *s, int sz);",
          "166:     virtual int         scanf_one(const char *fmt, void* val);",
          "167:     virtual int         get_char()",
          "168:     {",
          "169:         if(substream) return substream->get_char();",
          "170:         if(streampos>=streamsize)",
          "171:             return -1;",
          "172:         return buf[streampos++];",
          "173:     }",
          "175:   private:",
          "176:     unsigned char *buf;",
          "177:     size_t   streampos,streamsize;",
          "182:   public:",
          "183:                         LibRaw_bigfile_datastream(const char *fname);",
          "185:    LibRaw_bigfile_datastream(const wchar_t *fname);",
          "187:     virtual             ~LibRaw_bigfile_datastream();",
          "188:     virtual int         valid();",
          "189:     virtual int         jpeg_src(void *jpegdata);",
          "190:     virtual void        *make_jas_stream();",
          "192:     virtual int         read(void * ptr,size_t size, size_t nmemb);",
          "193:     virtual int         eof();",
          "194:     virtual int         seek(INT64 o, int whence);",
          "195:     virtual INT64       tell();",
          "196:     virtual INT64 size() { return _fsize;}",
          "197:     virtual char*       gets(char *str, int sz);",
          "198:     virtual int         scanf_one(const char *fmt, void*val);",
          "199:     virtual const char *fname();",
          "201:     virtual const wchar_t* wfname();",
          "202:     virtual int         subfile_open(const wchar_t *fn);",
          "204:     virtual int         subfile_open(const char *fn);",
          "205:     virtual void        subfile_close();",
          "206:     virtual int         get_char()",
          "207:     {",
          "209:         return substream?substream->get_char():getc_unlocked(f);",
          "211:         return substream?substream->get_char():fgetc(f);",
          "213:     }",
          "216:     FILE *f,*sav;",
          "217:     std::string filename;",
          "218:     INT64 _fsize;",
          "220:     std::wstring wfilename;",
          "225: class DllDef  LibRaw_windows_datastream : public LibRaw_buffer_datastream",
          "229:     LibRaw_windows_datastream(const TCHAR* sFile);",
          "231:     LibRaw_windows_datastream(HANDLE hFile);",
          "233:     virtual ~LibRaw_windows_datastream();",
          "234:     virtual INT64 size() { return cbView_;}",
          "237:     void Open(HANDLE hFile);",
          "238:     inline void reconstruct_base()",
          "239:  {",
          "241:             (LibRaw_buffer_datastream&)*this = LibRaw_buffer_datastream(pView_, (size_t)cbView_);",
          "242:  }",
          "253: class libraw_dng_stream: public dng_stream",
          "256:  libraw_dng_stream(LibRaw_abstract_datastream* p): dng_stream((dng_abort_sniffer*)NULL,kBigBufferSize,0),parent_stream(p)",
          "257:  {",
          "258:   if(parent_stream)",
          "259:   {",
          "260:    off = parent_stream->tell();",
          "262:   }",
          "263:  }",
          "264:  ~libraw_dng_stream(){",
          "265:   if(parent_stream)",
          "266:    parent_stream->seek(off,SEEK_SET);",
          "267:  }",
          "268:  virtual uint64 DoGetLength (){",
          "269:   if(parent_stream)",
          "270:    return parent_stream->size();",
          "271:   return 0;",
          "272:  }",
          "273:  virtual void DoRead (void *data, uint32 count, uint64 offset)",
          "274:  {",
          "275:   if(parent_stream)",
          "276:   {",
          "277:    parent_stream->seek(offset,SEEK_SET);",
          "278:    parent_stream->read(data,1,count);",
          "279:   }",
          "280:  }",
          "283:  libraw_dng_stream (const libraw_dng_stream &stream);",
          "284:  libraw_dng_stream & operator= (const libraw_dng_stream &stream);",
          "285:  LibRaw_abstract_datastream *parent_stream;",
          "286:  INT64 off;",
          "",
          "[Added Lines]",
          "56: #define qDNGXMPDocOps 0",
          "58: #define qDNGXMPFiles 0",
          "64: #define IOERROR()                                                                                                      \\",
          "65:   do                                                                                                                   \\",
          "66:   {                                                                                                                    \\",
          "67:     throw LIBRAW_EXCEPTION_IO_EOF;                                                                                     \\",
          "68:   } while (0)",
          "75: public:",
          "76:   LibRaw_abstract_datastream() { substream = 0; };",
          "77:   virtual ~LibRaw_abstract_datastream(void)",
          "78:   {",
          "79:     if (substream)",
          "80:       delete substream;",
          "81:   }",
          "82:   virtual int valid() = 0;",
          "83:   virtual int read(void *, size_t, size_t) = 0;",
          "84:   virtual int seek(INT64, int) = 0;",
          "85:   virtual INT64 tell() = 0;",
          "86:   virtual INT64 size() = 0;",
          "87:   virtual int get_char() = 0;",
          "88:   virtual char *gets(char *, int) = 0;",
          "89:   virtual int scanf_one(const char *, void *) = 0;",
          "90:   virtual int eof() = 0;",
          "91:   virtual void *make_jas_stream() = 0;",
          "92:   virtual int jpeg_src(void *) { return -1; }",
          "95:   virtual void unlock() {}",
          "97:   virtual const char *fname() { return NULL; };",
          "99:   virtual const wchar_t *wfname() { return NULL; };",
          "100:   virtual int subfile_open(const wchar_t *) { return -1; }",
          "102:   virtual int subfile_open(const char *) { return -1; }",
          "103:   virtual void subfile_close() {}",
          "105:   virtual int tempbuffer_open(void *, size_t);",
          "106:   virtual void tempbuffer_close();",
          "108: protected:",
          "109:   LibRaw_abstract_datastream *substream;",
          "116: class DllDef LibRaw_file_datastream : public LibRaw_abstract_datastream",
          "118: protected:",
          "121:   std::string filename;",
          "122:   INT64 _fsize;",
          "124:   std::wstring wfilename;",
          "126:   FILE *jas_file;",
          "128: public:",
          "129:   virtual ~LibRaw_file_datastream();",
          "130:   LibRaw_file_datastream(const char *fname);",
          "132:   LibRaw_file_datastream(const wchar_t *fname);",
          "134:   virtual void *make_jas_stream();",
          "135:   virtual int jpeg_src(void *jpegdata);",
          "136:   virtual int valid();",
          "137:   virtual int read(void *ptr, size_t size, size_t nmemb);",
          "138:   virtual int eof();",
          "139:   virtual int seek(INT64 o, int whence);",
          "140:   virtual INT64 tell();",
          "141:   virtual INT64 size() { return _fsize; }",
          "142:   virtual int get_char()",
          "143:   {",
          "144:     if (substream)",
          "145:       return substream->get_char();",
          "146:     return f->sbumpc();",
          "147:   }",
          "148:   virtual char *gets(char *str, int sz);",
          "149:   virtual int scanf_one(const char *fmt, void *val);",
          "150:   virtual const char *fname();",
          "152:   virtual const wchar_t *wfname();",
          "153:   virtual int subfile_open(const wchar_t *fn);",
          "155:   virtual int subfile_open(const char *fn);",
          "156:   virtual void subfile_close();",
          "159: class DllDef LibRaw_buffer_datastream : public LibRaw_abstract_datastream",
          "161: public:",
          "162:   LibRaw_buffer_datastream(void *buffer, size_t bsize);",
          "163:   virtual ~LibRaw_buffer_datastream();",
          "164:   virtual int valid();",
          "165:   virtual void *make_jas_stream();",
          "166:   virtual int jpeg_src(void *jpegdata);",
          "167:   virtual int read(void *ptr, size_t sz, size_t nmemb);",
          "168:   virtual int eof();",
          "169:   virtual int seek(INT64 o, int whence);",
          "170:   virtual INT64 tell();",
          "171:   virtual INT64 size() { return streamsize; }",
          "172:   virtual char *gets(char *s, int sz);",
          "173:   virtual int scanf_one(const char *fmt, void *val);",
          "174:   virtual int get_char()",
          "175:   {",
          "176:     if (substream)",
          "177:       return substream->get_char();",
          "178:     if (streampos >= streamsize)",
          "179:       return -1;",
          "180:     return buf[streampos++];",
          "181:   }",
          "183: private:",
          "184:   unsigned char *buf;",
          "185:   size_t streampos, streamsize;",
          "190: public:",
          "191:   LibRaw_bigfile_datastream(const char *fname);",
          "193:   LibRaw_bigfile_datastream(const wchar_t *fname);",
          "195:   virtual ~LibRaw_bigfile_datastream();",
          "196:   virtual int valid();",
          "197:   virtual int jpeg_src(void *jpegdata);",
          "198:   virtual void *make_jas_stream();",
          "200:   virtual int read(void *ptr, size_t size, size_t nmemb);",
          "201:   virtual int eof();",
          "202:   virtual int seek(INT64 o, int whence);",
          "203:   virtual INT64 tell();",
          "204:   virtual INT64 size() { return _fsize; }",
          "205:   virtual char *gets(char *str, int sz);",
          "206:   virtual int scanf_one(const char *fmt, void *val);",
          "207:   virtual const char *fname();",
          "209:   virtual const wchar_t *wfname();",
          "210:   virtual int subfile_open(const wchar_t *fn);",
          "212:   virtual int subfile_open(const char *fn);",
          "213:   virtual void subfile_close();",
          "214:   virtual int get_char()",
          "215:   {",
          "217:     return substream ? substream->get_char() : getc_unlocked(f);",
          "219:     return substream ? substream->get_char() : fgetc(f);",
          "221:   }",
          "224:   FILE *f, *sav;",
          "225:   std::string filename;",
          "226:   INT64 _fsize;",
          "228:   std::wstring wfilename;",
          "233: class DllDef LibRaw_windows_datastream : public LibRaw_buffer_datastream",
          "237:   LibRaw_windows_datastream(const TCHAR *sFile);",
          "239:   LibRaw_windows_datastream(HANDLE hFile);",
          "241:   virtual ~LibRaw_windows_datastream();",
          "242:   virtual INT64 size() { return cbView_; }",
          "245:   void Open(HANDLE hFile);",
          "246:   inline void reconstruct_base()",
          "247:   {",
          "249:     (LibRaw_buffer_datastream &)*this = LibRaw_buffer_datastream(pView_, (size_t)cbView_);",
          "250:   }",
          "261: class libraw_dng_stream : public dng_stream",
          "264:   libraw_dng_stream(LibRaw_abstract_datastream *p)",
          "265:       : dng_stream((dng_abort_sniffer *)NULL, kBigBufferSize, 0), parent_stream(p)",
          "266:   {",
          "267:     if (parent_stream)",
          "268:     {",
          "269:       off = parent_stream->tell();",
          "271:     }",
          "272:   }",
          "273:   ~libraw_dng_stream()",
          "274:   {",
          "275:     if (parent_stream)",
          "276:       parent_stream->seek(off, SEEK_SET);",
          "277:   }",
          "278:   virtual uint64 DoGetLength()",
          "279:   {",
          "280:     if (parent_stream)",
          "281:       return parent_stream->size();",
          "282:     return 0;",
          "283:   }",
          "284:   virtual void DoRead(void *data, uint32 count, uint64 offset)",
          "285:   {",
          "286:     if (parent_stream)",
          "287:     {",
          "288:       parent_stream->seek(offset, SEEK_SET);",
          "289:       parent_stream->read(data, 1, count);",
          "290:     }",
          "291:   }",
          "294:   libraw_dng_stream(const libraw_dng_stream &stream);",
          "295:   libraw_dng_stream &operator=(const libraw_dng_stream &stream);",
          "296:   LibRaw_abstract_datastream *parent_stream;",
          "297:   INT64 off;",
          "",
          "---------------"
        ],
        "libraw/libraw_internal.h||libraw/libraw_internal.h": [
          "File: libraw/libraw_internal.h -> libraw/libraw_internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "43: class LibRaw_TLS",
          "44: {",
          "45: public:",
          "78: };",
          "81: class LibRaw_constants",
          "82: {",
          "86: };",
          "90: typedef struct",
          "91: {",
          "92: #ifndef __cplusplus",
          "94: #endif",
          "103: } internal_data_t;",
          "106: #define LIBRAW_HISTOGRAM_SIZE 0x2000",
          "107: typedef struct",
          "108: {",
          "111: } output_data_t;",
          "113: typedef struct",
          "114: {",
          "121: typedef struct",
          "122: {",
          "139:   long long posRAFData;",
          "140:   unsigned lenRAFData;",
          "141:   int fuji_total_lines, fuji_total_blocks, fuji_block_width, fuji_bits;",
          "144: typedef struct",
          "145: {",
          "151: } libraw_internal_data_t;",
          "154: struct decode",
          "155: {",
          "158: };",
          "161:   int t_width, t_height, bps, comp, phint, offset, t_flip, samples, bytes;",
          "163:   int rows_per_strip;",
          "166:   float t_shutter;",
          "167: };",
          "170:   int algo, bits, high, wide, clrs, sraw, psv, restart, vpred[6];",
          "171:   ushort quant[64], idct[64], *huff[20], *free[20], *row;",
          "172: };",
          "175:   ushort tag, type;",
          "176:   int count;",
          "178: };",
          "181:   ushort t_order, magic;",
          "182:   int ifd;",
          "183:   ushort pad, ntag;",
          "",
          "[Removed Lines]",
          "46:     struct",
          "47:     {",
          "48:          unsigned bitbuf;",
          "49:          int vbits, reset;",
          "50:     }getbits;",
          "51:     struct",
          "52:     {",
          "53:          UINT64 bitbuf;",
          "54:          int vbits;",
          "56:     }ph1_bits;",
          "57:     struct",
          "58:     {",
          "59:          unsigned pad[128], p;",
          "60:     }sony_decrypt;",
          "61:     struct",
          "62:     {",
          "63:         uchar buf[0x4000];",
          "64:         int vbits, padding;",
          "65:     }pana_bits;",
          "66:     uchar jpeg_buffer[4096];",
          "67:     struct",
          "68:     {",
          "69:       float cbrt[0x10000], xyz_cam[3][4];",
          "70:     }ahd_data;",
          "71:     void init()",
          "72:         {",
          "73:             getbits.bitbuf = 0; getbits.vbits = getbits.reset = 0;",
          "74:             ph1_bits.bitbuf = 0; ph1_bits.vbits = 0;",
          "75:             pana_bits.vbits = 0;",
          "76:             ahd_data.cbrt[0]=-2.0f;",
          "77:         }",
          "83:   public:",
          "84:     static const float d65_white[3];",
          "85:     static const double xyz_rgb[3][3];",
          "93:     struct",
          "95:     LibRaw_abstract_datastream *input;",
          "96:   FILE        *output;",
          "97:   int         input_internal;",
          "98:   char        *meta_data;",
          "99:   INT64       profile_offset;",
          "100:   INT64       toffset;",
          "101:   unsigned    pana_black[4];",
          "109:     int         (*histogram)[LIBRAW_HISTOGRAM_SIZE];",
          "110:     unsigned    *oprof;",
          "115:     unsigned olympus_exif_cfa;",
          "116:     unsigned     unique_id;",
          "117:     unsigned tiff_nifds;",
          "118:     int  tiff_flip;",
          "119: }identify_data_t;",
          "123:     short       order;",
          "124:     ushort      sraw_mul[4],cr2_slice[3];",
          "125:     unsigned    kodak_cbpp;",
          "126:     INT64       strip_offset, data_offset;",
          "127:     INT64       meta_offset;",
          "128:     unsigned    data_size;",
          "129:     unsigned     meta_length;",
          "130:     unsigned    thumb_misc;",
          "131:     unsigned    fuji_layout;",
          "132:     unsigned    tiff_samples;",
          "133:     unsigned    tiff_bps;",
          "134:     unsigned    tiff_compress;",
          "135:     unsigned    zero_after_ff;",
          "136:     unsigned    tile_width, tile_length,load_flags;",
          "137:     unsigned    data_error;",
          "138:  int   hasselblad_parser_flag;",
          "142: }unpacker_data_t;",
          "146:     internal_data_t internal_data;",
          "147:     libraw_internal_output_params_t internal_output_params;",
          "148:     output_data_t output_data;",
          "149:     identify_data_t identify_data;",
          "150:     unpacker_data_t unpacker_data;",
          "156:     struct decode *branch[2];",
          "157:     int leaf;",
          "160: struct tiff_ifd_t {",
          "162:   int t_tile_width, t_tile_length,sample_format,predictor;",
          "164:   int *strip_offsets,strip_offsets_count;",
          "165:   int *strip_byte_counts,strip_byte_counts_count;",
          "169: struct jhead {",
          "174: struct tiff_tag {",
          "177:   union { char c[4]; short s[2]; int i; } val;",
          "180: struct tiff_hdr {",
          "",
          "[Added Lines]",
          "45:   struct",
          "46:   {",
          "47:     unsigned bitbuf;",
          "48:     int vbits, reset;",
          "49:   } getbits;",
          "50:   struct",
          "51:   {",
          "52:     UINT64 bitbuf;",
          "53:     int vbits;",
          "55:   } ph1_bits;",
          "56:   struct",
          "57:   {",
          "58:     unsigned pad[128], p;",
          "59:   } sony_decrypt;",
          "60:   struct",
          "61:   {",
          "62:     uchar buf[0x4000];",
          "63:     int vbits, padding;",
          "64:   } pana_bits;",
          "65:   uchar jpeg_buffer[4096];",
          "66:   struct",
          "67:   {",
          "68:     float cbrt[0x10000], xyz_cam[3][4];",
          "69:   } ahd_data;",
          "70:   void init()",
          "71:   {",
          "72:     getbits.bitbuf = 0;",
          "73:     getbits.vbits = getbits.reset = 0;",
          "74:     ph1_bits.bitbuf = 0;",
          "75:     ph1_bits.vbits = 0;",
          "76:     pana_bits.vbits = 0;",
          "77:     ahd_data.cbrt[0] = -2.0f;",
          "78:   }",
          "83: public:",
          "84:   static const float d65_white[3];",
          "85:   static const double xyz_rgb[3][3];",
          "92:   struct",
          "94:       LibRaw_abstract_datastream *input;",
          "95:   FILE *output;",
          "96:   int input_internal;",
          "97:   char *meta_data;",
          "98:   INT64 profile_offset;",
          "99:   INT64 toffset;",
          "100:   unsigned pana_black[4];",
          "107:   int (*histogram)[LIBRAW_HISTOGRAM_SIZE];",
          "108:   unsigned *oprof;",
          "113:   unsigned olympus_exif_cfa;",
          "114:   unsigned unique_id;",
          "115:   unsigned tiff_nifds;",
          "116:   int tiff_flip;",
          "117: } identify_data_t;",
          "121:   short order;",
          "122:   ushort sraw_mul[4], cr2_slice[3];",
          "123:   unsigned kodak_cbpp;",
          "124:   INT64 strip_offset, data_offset;",
          "125:   INT64 meta_offset;",
          "126:   unsigned data_size;",
          "127:   unsigned meta_length;",
          "128:   unsigned thumb_misc;",
          "129:   unsigned fuji_layout;",
          "130:   unsigned tiff_samples;",
          "131:   unsigned tiff_bps;",
          "132:   unsigned tiff_compress;",
          "133:   unsigned zero_after_ff;",
          "134:   unsigned tile_width, tile_length, load_flags;",
          "135:   unsigned data_error;",
          "136:   int hasselblad_parser_flag;",
          "140: } unpacker_data_t;",
          "144:   internal_data_t internal_data;",
          "145:   libraw_internal_output_params_t internal_output_params;",
          "146:   output_data_t output_data;",
          "147:   identify_data_t identify_data;",
          "148:   unpacker_data_t unpacker_data;",
          "153:   struct decode *branch[2];",
          "154:   int leaf;",
          "157: struct tiff_ifd_t",
          "158: {",
          "160:   int t_tile_width, t_tile_length, sample_format, predictor;",
          "162:   int *strip_offsets, strip_offsets_count;",
          "163:   int *strip_byte_counts, strip_byte_counts_count;",
          "167: struct jhead",
          "168: {",
          "173: struct tiff_tag",
          "174: {",
          "177:   union {",
          "178:     char c[4];",
          "179:     short s[2];",
          "180:     int i;",
          "181:   } val;",
          "184: struct tiff_hdr",
          "185: {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "193:   char t_desc[512], t_make[64], t_model[64], soft[32], date[20], t_artist[64];",
          "194: };",
          "198: #ifdef DEBUG_STAGE_CHECKS",
          "209: #else",
          "224: #endif",
          "",
          "[Removed Lines]",
          "199: #define CHECK_ORDER_HIGH(expected_stage) \\",
          "200:     do { if((imgdata.progress_flags & LIBRAW_PROGRESS_THUMB_MASK) >= expected_stage) {fprintf(stderr,\"CHECK_HIGH: check %d >=  %d\\n\",imgdata.progress_flags & LIBRAW_PROGRESS_THUMB_MASK,expected_stage);return LIBRAW_OUT_OF_ORDER_CALL;} } while(0)",
          "202: #define CHECK_ORDER_LOW(expected_stage) \\",
          "203:     do { printf(\"Checking LOW %d/%d : %d\\n\",imgdata.progress_flags,expected_stage,imgdata.progress_flags<expected_stage); if( (imgdata.progress_flags&LIBRAW_PROGRESS_THUMB_MASK) < expected_stage ) { printf(\"failed!\\n\"); return LIBRAW_OUT_OF_ORDER_CALL;} } while(0)",
          "204: #define CHECK_ORDER_BIT(expected_stage) \\",
          "205:     do { if(imgdata.progress_flags & expected_stage) return LIBRAW_OUT_OF_ORDER_CALL; } while(0)",
          "207: #define SET_PROC_FLAG(stage) do {imgdata.progress_flags |= stage; fprintf(stderr,\"SET_FLAG: %d\\n\",stage); } while (0)",
          "211: #define CHECK_ORDER_HIGH(expected_stage) \\",
          "212:     do { if((imgdata.progress_flags & LIBRAW_PROGRESS_THUMB_MASK) >= expected_stage) \\",
          "213:             {return LIBRAW_OUT_OF_ORDER_CALL;} } while(0)",
          "215: #define CHECK_ORDER_LOW(expected_stage) \\",
          "216:     do { if((imgdata.progress_flags&LIBRAW_PROGRESS_THUMB_MASK) < expected_stage) \\",
          "217:             return LIBRAW_OUT_OF_ORDER_CALL; } while(0)",
          "219: #define CHECK_ORDER_BIT(expected_stage) \\",
          "220:     do { if(imgdata.progress_flags & expected_stage) return LIBRAW_OUT_OF_ORDER_CALL; } while(0)",
          "222: #define SET_PROC_FLAG(stage) do {imgdata.progress_flags |= stage;} while (0)",
          "",
          "[Added Lines]",
          "202: #define CHECK_ORDER_HIGH(expected_stage)                                                                               \\",
          "203:   do                                                                                                                   \\",
          "204:   {                                                                                                                    \\",
          "205:     if ((imgdata.progress_flags & LIBRAW_PROGRESS_THUMB_MASK) >= expected_stage)                                       \\",
          "206:     {                                                                                                                  \\",
          "207:       fprintf(stderr, \"CHECK_HIGH: check %d >=  %d\\n\", imgdata.progress_flags &LIBRAW_PROGRESS_THUMB_MASK,             \\",
          "208:               expected_stage);                                                                                         \\",
          "209:       return LIBRAW_OUT_OF_ORDER_CALL;                                                                                 \\",
          "210:     }                                                                                                                  \\",
          "211:   } while (0)",
          "213: #define CHECK_ORDER_LOW(expected_stage)                                                                                \\",
          "214:   do                                                                                                                   \\",
          "215:   {                                                                                                                    \\",
          "216:     printf(\"Checking LOW %d/%d : %d\\n\", imgdata.progress_flags, expected_stage,                                        \\",
          "217:            imgdata.progress_flags < expected_stage);                                                                   \\",
          "218:     if ((imgdata.progress_flags & LIBRAW_PROGRESS_THUMB_MASK) < expected_stage)                                        \\",
          "219:     {                                                                                                                  \\",
          "220:       printf(\"failed!\\n\");                                                                                             \\",
          "221:       return LIBRAW_OUT_OF_ORDER_CALL;                                                                                 \\",
          "222:     }                                                                                                                  \\",
          "223:   } while (0)",
          "224: #define CHECK_ORDER_BIT(expected_stage)                                                                                \\",
          "225:   do                                                                                                                   \\",
          "226:   {                                                                                                                    \\",
          "227:     if (imgdata.progress_flags & expected_stage)                                                                       \\",
          "228:       return LIBRAW_OUT_OF_ORDER_CALL;                                                                                 \\",
          "229:   } while (0)",
          "231: #define SET_PROC_FLAG(stage)                                                                                           \\",
          "232:   do                                                                                                                   \\",
          "233:   {                                                                                                                    \\",
          "234:     imgdata.progress_flags |= stage;                                                                                   \\",
          "235:     fprintf(stderr, \"SET_FLAG: %d\\n\", stage);                                                                          \\",
          "236:   } while (0)",
          "240: #define CHECK_ORDER_HIGH(expected_stage)                                                                               \\",
          "241:   do                                                                                                                   \\",
          "242:   {                                                                                                                    \\",
          "243:     if ((imgdata.progress_flags & LIBRAW_PROGRESS_THUMB_MASK) >= expected_stage)                                       \\",
          "244:     {                                                                                                                  \\",
          "245:       return LIBRAW_OUT_OF_ORDER_CALL;                                                                                 \\",
          "246:     }                                                                                                                  \\",
          "247:   } while (0)",
          "249: #define CHECK_ORDER_LOW(expected_stage)                                                                                \\",
          "250:   do                                                                                                                   \\",
          "251:   {                                                                                                                    \\",
          "252:     if ((imgdata.progress_flags & LIBRAW_PROGRESS_THUMB_MASK) < expected_stage)                                        \\",
          "253:       return LIBRAW_OUT_OF_ORDER_CALL;                                                                                 \\",
          "254:   } while (0)",
          "256: #define CHECK_ORDER_BIT(expected_stage)                                                                                \\",
          "257:   do                                                                                                                   \\",
          "258:   {                                                                                                                    \\",
          "259:     if (imgdata.progress_flags & expected_stage)                                                                       \\",
          "260:       return LIBRAW_OUT_OF_ORDER_CALL;                                                                                 \\",
          "261:   } while (0)",
          "263: #define SET_PROC_FLAG(stage)                                                                                           \\",
          "264:   do                                                                                                                   \\",
          "265:   {                                                                                                                    \\",
          "266:     imgdata.progress_flags |= stage;                                                                                   \\",
          "267:   } while (0)",
          "",
          "---------------"
        ],
        "libraw/libraw_types.h||libraw/libraw_types.h": [
          "File: libraw/libraw_types.h -> libraw/libraw_types.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #endif",
          "27: #include <stdio.h>",
          "31: #if defined(WIN32)",
          "38: #else",
          "40: #endif",
          "47: #endif",
          "49: #ifdef LIBRAW_USE_OPENMP",
          "50: #include <omp.h>",
          "51: #endif",
          "54: #ifdef __cplusplus",
          "55: extern \"C\" {",
          "56: #endif",
          "",
          "[Removed Lines]",
          "29: #if defined (_OPENMP)",
          "32: # if defined (_MSC_VER) && (_MSC_VER >= 1600 || (_MSC_VER == 1500 && _MSC_FULL_VER >= 150030729) )",
          "34: #   define LIBRAW_USE_OPENMP",
          "35: #elif defined (__INTEL_COMPILER) && (__INTEL_COMPILER >=910)",
          "37: #   define LIBRAW_USE_OPENMP",
          "39: #  undef LIBRAW_USE_OPENMP",
          "42: # elif (defined(__APPLE__) || defined(__MACOSX__)) && defined(_REENTRANT)",
          "43: #   undef LIBRAW_USE_OPENMP",
          "44: # else",
          "45: #   define LIBRAW_USE_OPENMP",
          "46: # endif",
          "",
          "[Added Lines]",
          "29: #if defined(_OPENMP)",
          "32: #if defined(_MSC_VER) && (_MSC_VER >= 1600 || (_MSC_VER == 1500 && _MSC_FULL_VER >= 150030729))",
          "34: #define LIBRAW_USE_OPENMP",
          "35: #elif defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 910)",
          "37: #define LIBRAW_USE_OPENMP",
          "39: #undef LIBRAW_USE_OPENMP",
          "42: #elif (defined(__APPLE__) || defined(__MACOSX__)) && defined(_REENTRANT)",
          "43: #undef LIBRAW_USE_OPENMP",
          "44: #else",
          "45: #define LIBRAW_USE_OPENMP",
          "46: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "80: #ifdef WIN32",
          "81: #ifdef LIBRAW_NODLL",
          "83: #else",
          "89: #endif",
          "90: #else",
          "92: #endif",
          "94: typedef struct",
          "95: {",
          "100: typedef struct",
          "101: {",
          "107: } libraw_internal_output_params_t;",
          "121: typedef struct",
          "122: {",
          "134: } libraw_callbacks_t;",
          "137: typedef struct",
          "138: {",
          "149: typedef struct",
          "150: {",
          "168: typedef struct",
          "169: {",
          "182: } libraw_image_sizes_t;",
          "184: struct ph1_t",
          "",
          "[Removed Lines]",
          "82: # define DllDef",
          "84: # ifdef LIBRAW_BUILDLIB",
          "85: #    define DllDef   __declspec( dllexport )",
          "86: # else",
          "87: #    define DllDef   __declspec( dllimport )",
          "88: # endif",
          "91: #  define DllDef",
          "96:     const char          *decoder_name;",
          "97:     unsigned             decoder_flags;",
          "98: }libraw_decoder_info_t;",
          "102:     unsigned    mix_green;",
          "103:     unsigned    raw_color;",
          "104:     unsigned    zero_is_bad;",
          "105:     ushort      shrink;",
          "106:     ushort      fuji_width;",
          "110: typedef void (* memory_callback)(void * data, const char *file, const char *where);",
          "111: typedef void (*exif_parser_callback) (void *context, int tag, int type, int len,unsigned int ord, void *ifp);",
          "113: DllDef void default_memory_callback(void *data,const char *file, const char *where);",
          "115: typedef void (*data_callback)(void *data,const char *file, const int offset);",
          "117: DllDef void default_data_callback(void *data,const char *file, const int offset);",
          "119: typedef int (* progress_callback) (void *data,enum LibRaw_progress stage, int iteration,int expected);",
          "123:     memory_callback mem_cb;",
          "124:     void*  memcb_data;",
          "126:     data_callback data_cb;",
          "127:     void*       datacb_data;",
          "129:     progress_callback progress_cb;",
          "130:     void *progresscb_data;",
          "132:  exif_parser_callback exif_cb;",
          "133:  void *exifparser_data;",
          "139:     enum LibRaw_image_formats type;",
          "140:     ushort      height,",
          "141:                 width,",
          "142:                 colors,",
          "143:                 bits;",
          "144:     unsigned int  data_size;",
          "145:     unsigned char data[1];",
          "146: }libraw_processed_image_t;",
          "151:   char       guard[4];",
          "152:   char        make[64];",
          "153:   char        model[64];",
          "154:   char        software[64];",
          "155:   unsigned    raw_count;",
          "156:   unsigned    dng_version;",
          "157:   unsigned    is_foveon;",
          "158:   int         colors;",
          "159:   unsigned    filters;",
          "160:   char        xtrans[6][6];",
          "161:   char        xtrans_abs[6][6];",
          "162:   char        cdesc[5];",
          "163:   unsigned    xmplen;",
          "164:   char        *xmpdata;",
          "166: }libraw_iparams_t;",
          "170:   ushort      raw_height,",
          "171:               raw_width,",
          "172:               height,",
          "173:               width,",
          "174:               top_margin,",
          "175:               left_margin;",
          "176:   ushort      iheight,",
          "177:               iwidth;",
          "178:   unsigned    raw_pitch;",
          "179:   double      pixel_aspect;",
          "180:   int         flip;",
          "181:   int         mask[8][4];",
          "",
          "[Added Lines]",
          "81: #define DllDef",
          "82: #else",
          "83: #ifdef LIBRAW_BUILDLIB",
          "84: #define DllDef __declspec(dllexport)",
          "86: #define DllDef __declspec(dllimport)",
          "87: #endif",
          "90: #define DllDef",
          "95:   const char *decoder_name;",
          "96:   unsigned decoder_flags;",
          "97: } libraw_decoder_info_t;",
          "101:   unsigned mix_green;",
          "102:   unsigned raw_color;",
          "103:   unsigned zero_is_bad;",
          "104:   ushort shrink;",
          "105:   ushort fuji_width;",
          "108: typedef void (*memory_callback)(void *data, const char *file, const char *where);",
          "109: typedef void (*exif_parser_callback)(void *context, int tag, int type, int len, unsigned int ord, void *ifp);",
          "111: DllDef void default_memory_callback(void *data, const char *file, const char *where);",
          "113: typedef void (*data_callback)(void *data, const char *file, const int offset);",
          "115: DllDef void default_data_callback(void *data, const char *file, const int offset);",
          "117: typedef int (*progress_callback)(void *data, enum LibRaw_progress stage, int iteration, int expected);",
          "121:   memory_callback mem_cb;",
          "122:   void *memcb_data;",
          "124:   data_callback data_cb;",
          "125:   void *datacb_data;",
          "127:   progress_callback progress_cb;",
          "128:   void *progresscb_data;",
          "130:   exif_parser_callback exif_cb;",
          "131:   void *exifparser_data;",
          "136:   enum LibRaw_image_formats type;",
          "137:   ushort height, width, colors, bits;",
          "138:   unsigned int data_size;",
          "139:   unsigned char data[1];",
          "140: } libraw_processed_image_t;",
          "144:   char guard[4];",
          "145:   char make[64];",
          "146:   char model[64];",
          "147:   char software[64];",
          "148:   unsigned raw_count;",
          "149:   unsigned dng_version;",
          "150:   unsigned is_foveon;",
          "151:   int colors;",
          "152:   unsigned filters;",
          "153:   char xtrans[6][6];",
          "154:   char xtrans_abs[6][6];",
          "155:   char cdesc[5];",
          "156:   unsigned xmplen;",
          "157:   char *xmpdata;",
          "159: } libraw_iparams_t;",
          "163:   ushort raw_height, raw_width, height, width, top_margin, left_margin;",
          "164:   ushort iheight, iwidth;",
          "165:   unsigned raw_pitch;",
          "166:   double pixel_aspect;",
          "167:   int flip;",
          "168:   int mask[8][4];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "191: typedef struct",
          "192: {",
          "197: } libraw_dng_color_t;",
          "199: typedef struct",
          "200: {",
          "207: } libraw_dng_levels_t;",
          "209: typedef struct",
          "210: {",
          "212: } libraw_P1_color_t;",
          "214: typedef struct",
          "215: {",
          "272: } libraw_canon_makernotes_t;",
          "274: typedef struct",
          "275: {",
          "295: } libraw_fuji_info_t;",
          "297: typedef struct",
          "298: {",
          "343: } libraw_nikon_makernotes_t;",
          "345: typedef struct",
          "346: {",
          "358: } libraw_olympus_makernotes_t;",
          "360: typedef struct",
          "361: {",
          "369: } libraw_pentax_makernotes_t;",
          "371: typedef struct",
          "372: {",
          "374: } libraw_sony_info_t;",
          "376: typedef struct",
          "377: {",
          "403:   libraw_dng_levels_t dng_levels;",
          "408: } libraw_colordata_t;",
          "410: typedef struct",
          "411: {",
          "412:   enum LibRaw_thumbnail_formats tformat;",
          "420: typedef struct",
          "421: {",
          "428: } libraw_gps_info_t;",
          "430: typedef struct",
          "431: {",
          "439:   libraw_gps_info_t parsed_gps;",
          "443: } libraw_imgother_t;",
          "445: typedef struct",
          "446: {",
          "491:   int cfaline;",
          "492:   float linenoise;",
          "493:   int cfa_clean;",
          "",
          "[Removed Lines]",
          "193:   ushort       illuminant;",
          "194:   float        calibration[4][4];",
          "195:   float        colormatrix[4][3];",
          "196:   float        forwardmatrix[3][4];",
          "202:   unsigned     dng_cblack[4102];",
          "203:   unsigned     dng_black;",
          "204:   unsigned     dng_whitelevel[4];",
          "205:   float        dng_blacklevel[4];",
          "206:   float        analogbalance[4];",
          "211:   float        romm_cam[9];",
          "216:   int          CanonColorDataVer;",
          "217:   int          CanonColorDataSubVer;",
          "218:   int          SpecularWhiteLevel;",
          "219:   int          ChannelBlackLevel[4];",
          "220:   int          AverageBlackLevel;",
          "222:   short        MeteringMode;",
          "223:   short        SpotMeteringMode;",
          "224:   uchar        FlashMeteringMode;",
          "225:   short        FlashExposureLock;",
          "226:   short        ExposureMode;",
          "227:   short        AESetting;",
          "228:   uchar        HighlightTonePriority;",
          "230:   short        ImageStabilization;",
          "232:   short        FocusMode;",
          "233:   short        AFPoint;",
          "234:   short        FocusContinuous;",
          "235:   short        AFPointsInFocus30D;",
          "236:   uchar        AFPointsInFocus1D[8];",
          "239:   ushort       AFAreaMode;",
          "240:   ushort       NumAFPoints;",
          "241:   ushort       ValidAFPoints;",
          "242:   ushort       AFImageWidth;",
          "243:   ushort       AFImageHeight;",
          "250:   ushort       PrimaryAFPoint;",
          "252:   short        FlashMode;",
          "253:   short        FlashActivity;",
          "254:   short        FlashBits;",
          "255:   short        ManualFlashOutput;",
          "256:   short        FlashOutput;",
          "257:   short        FlashGuideNumber;",
          "259:   short        ContinuousDrive;",
          "261:   short        SensorWidth;",
          "262:   short        SensorHeight;",
          "263:   short        SensorLeftBorder;",
          "264:   short        SensorTopBorder;",
          "265:   short        SensorRightBorder;",
          "266:   short        SensorBottomBorder;",
          "267:   short        BlackMaskLeftBorder;",
          "268:   short        BlackMaskTopBorder;",
          "269:   short        BlackMaskRightBorder;",
          "270:   short        BlackMaskBottomBorder;",
          "276:   float        FujiExpoMidPointShift;",
          "277:   ushort       FujiDynamicRange;",
          "278:   ushort       FujiFilmMode;",
          "279:   ushort       FujiDynamicRangeSetting;",
          "280:   ushort       FujiDevelopmentDynamicRange;",
          "281:   ushort       FujiAutoDynamicRange;",
          "282:   ushort       FocusMode;",
          "283:   ushort       AFMode;",
          "284:   ushort       FocusPixel[2];",
          "285:   ushort       ImageStabilization[3];",
          "286:   ushort       FlashMode;",
          "287:   ushort       WB_Preset;",
          "288:   ushort       ShutterType;",
          "289:   ushort       ExrMode;",
          "290:   ushort       Macro;",
          "291:   unsigned     Rating;",
          "292:   ushort       FrameRate;",
          "293:   ushort       FrameWidth;",
          "294:   ushort       FrameHeight;",
          "300:   double       ExposureBracketValue;",
          "301:   ushort       ActiveDLighting;",
          "302:   ushort       ShootingMode;",
          "304:   uchar        ImageStabilization[7];",
          "305:   uchar        VibrationReduction;",
          "306:   uchar        VRMode;",
          "308:   char         FocusMode[7];",
          "309:   uchar        AFPoint;",
          "310:   ushort       AFPointsInFocus;",
          "311:   uchar        ContrastDetectAF;",
          "312:   uchar        AFAreaMode;",
          "313:   uchar        PhaseDetectAF;",
          "314:   uchar        PrimaryAFPoint;",
          "315:   uchar        AFPointsUsed[29];",
          "316:   ushort       AFImageWidth;",
          "317:   ushort       AFImageHeight;",
          "318:   ushort       AFAreaXPposition;",
          "319:   ushort       AFAreaYPosition;",
          "320:   ushort       AFAreaWidth;",
          "321:   ushort       AFAreaHeight;",
          "322:   uchar        ContrastDetectAFInFocus;",
          "324:   char         FlashSetting[13];",
          "325:   char         FlashType[20];",
          "326:   uchar        FlashExposureCompensation[4];",
          "327:   uchar        ExternalFlashExposureComp[4];",
          "328:   uchar        FlashExposureBracketValue[4];",
          "329:   uchar        FlashMode;",
          "330:   signed char  FlashExposureCompensation2;",
          "331:   signed char  FlashExposureCompensation3;",
          "332:   signed char  FlashExposureCompensation4;",
          "333:   uchar        FlashSource;",
          "334:   uchar        FlashFirmware[2];",
          "335:   uchar        ExternalFlashFlags;",
          "336:   uchar        FlashControlCommanderMode;",
          "337:   uchar        FlashOutputAndCompensation;",
          "338:   uchar        FlashFocalLength;",
          "339:   uchar        FlashGNDistance;",
          "340:   uchar        FlashGroupControlMode[4];",
          "341:   uchar        FlashGroupOutputAndCompensation[4];",
          "342:   uchar        FlashColorFilter;",
          "347:   int          OlympusCropID;",
          "349:   int          OlympusSensorCalibration[2];",
          "350:   ushort       FocusMode[2];",
          "351:   ushort       AutoFocus;",
          "352:   ushort       AFPoint;",
          "353:   unsigned     AFAreas[64];",
          "354:   double       AFPointSelected[5];",
          "355:   ushort       AFResult;",
          "356:   unsigned     ImageStabilization;",
          "357:   ushort       ColorSpace;",
          "362:   ushort       FocusMode;",
          "363:   uchar        AFPointMode;",
          "364:   ushort       AFPointSelected[2];",
          "365:   unsigned     AFPointsInFocus;",
          "366:   uchar        DriveMode[4];",
          "367:   uchar        SRResult;",
          "368:   uchar        ShakeReduction;",
          "373:   ushort       SonyCameraType;",
          "378:   ushort       curve[0x10000];",
          "379:   unsigned     cblack[4102];",
          "380:   unsigned     black;",
          "381:   unsigned     data_maximum;",
          "382:   unsigned     maximum;",
          "383:   long         linear_max[4];",
          "384:   float        fmaximum;",
          "385:   float        fnorm;",
          "386:   ushort       white[8][8];",
          "387:   float        cam_mul[4];",
          "388:   float        pre_mul[4];",
          "389:   float        cmatrix[3][4];",
          "390:   float        ccm[3][4];",
          "391:   float        rgb_cam[3][4];",
          "392:   float        cam_xyz[4][3];",
          "393:   struct ph1_t       phase_one_data;",
          "394:   float        flash_used;",
          "395:   float        canon_ev;",
          "396:   char         model2[64];",
          "397:   char         UniqueCameraModel[64];",
          "398:   char         LocalizedCameraModel[64];",
          "399:   void         *profile;",
          "400:   unsigned     profile_length;",
          "401:   unsigned     black_stat[8];",
          "402:   libraw_dng_color_t  dng_color[2];",
          "404:   float        baseline_exposure;",
          "407:   libraw_P1_color_t  P1_color[2];",
          "413:   ushort       twidth,",
          "414:                theight;",
          "415:   unsigned     tlength;",
          "416:   int          tcolors;",
          "417:   char         *thumb;",
          "418: }libraw_thumbnail_t;",
          "425:   float        altitude;",
          "426:   char         altref, latref, longref, gpsstatus;",
          "427:   char         gpsparsed;",
          "432:   float        iso_speed;",
          "433:   float        shutter;",
          "434:   float        aperture;",
          "435:   float        focal_len;",
          "436:   time_t       timestamp;",
          "437:   unsigned     shot_order;",
          "438:   unsigned     gpsdata[32];",
          "440:   char         desc[512],",
          "441:                artist[64];",
          "442:   float        FlashEC;",
          "471:   int  user_cblack[4];",
          "475:   float       auto_bright_thr;",
          "476:   float       adjust_maximum_thr;",
          "479:   int         green_matching;",
          "481:   int         dcb_iterations;",
          "482:   int         dcb_enhance_fl;",
          "483:   int         fbdd_noiserd;",
          "485:   int         eeci_refine;",
          "486:   int         es_med_passes;",
          "488:   int         ca_correc;",
          "489:   float       cared;",
          "490:   float cablue;",
          "",
          "[Added Lines]",
          "180:   ushort illuminant;",
          "181:   float calibration[4][4];",
          "182:   float colormatrix[4][3];",
          "183:   float forwardmatrix[3][4];",
          "189:   unsigned dng_cblack[4102];",
          "190:   unsigned dng_black;",
          "191:   unsigned dng_whitelevel[4];",
          "192:   float dng_blacklevel[4];",
          "193:   float analogbalance[4];",
          "198:   float romm_cam[9];",
          "203:   int CanonColorDataVer;",
          "204:   int CanonColorDataSubVer;",
          "205:   int SpecularWhiteLevel;",
          "206:   int ChannelBlackLevel[4];",
          "207:   int AverageBlackLevel;",
          "209:   short MeteringMode;",
          "210:   short SpotMeteringMode;",
          "211:   uchar FlashMeteringMode;",
          "212:   short FlashExposureLock;",
          "213:   short ExposureMode;",
          "214:   short AESetting;",
          "215:   uchar HighlightTonePriority;",
          "217:   short ImageStabilization;",
          "219:   short FocusMode;",
          "220:   short AFPoint;",
          "221:   short FocusContinuous;",
          "222:   short AFPointsInFocus30D;",
          "223:   uchar AFPointsInFocus1D[8];",
          "226:   ushort AFAreaMode;",
          "227:   ushort NumAFPoints;",
          "228:   ushort ValidAFPoints;",
          "229:   ushort AFImageWidth;",
          "230:   ushort AFImageHeight;",
          "237:   ushort PrimaryAFPoint;",
          "239:   short FlashMode;",
          "240:   short FlashActivity;",
          "241:   short FlashBits;",
          "242:   short ManualFlashOutput;",
          "243:   short FlashOutput;",
          "244:   short FlashGuideNumber;",
          "246:   short ContinuousDrive;",
          "248:   short SensorWidth;",
          "249:   short SensorHeight;",
          "250:   short SensorLeftBorder;",
          "251:   short SensorTopBorder;",
          "252:   short SensorRightBorder;",
          "253:   short SensorBottomBorder;",
          "254:   short BlackMaskLeftBorder;",
          "255:   short BlackMaskTopBorder;",
          "256:   short BlackMaskRightBorder;",
          "257:   short BlackMaskBottomBorder;",
          "263:   float FujiExpoMidPointShift;",
          "264:   ushort FujiDynamicRange;",
          "265:   ushort FujiFilmMode;",
          "266:   ushort FujiDynamicRangeSetting;",
          "267:   ushort FujiDevelopmentDynamicRange;",
          "268:   ushort FujiAutoDynamicRange;",
          "269:   ushort FocusMode;",
          "270:   ushort AFMode;",
          "271:   ushort FocusPixel[2];",
          "272:   ushort ImageStabilization[3];",
          "273:   ushort FlashMode;",
          "274:   ushort WB_Preset;",
          "275:   ushort ShutterType;",
          "276:   ushort ExrMode;",
          "277:   ushort Macro;",
          "278:   unsigned Rating;",
          "279:   ushort FrameRate;",
          "280:   ushort FrameWidth;",
          "281:   ushort FrameHeight;",
          "287:   double ExposureBracketValue;",
          "288:   ushort ActiveDLighting;",
          "289:   ushort ShootingMode;",
          "291:   uchar ImageStabilization[7];",
          "292:   uchar VibrationReduction;",
          "293:   uchar VRMode;",
          "295:   char FocusMode[7];",
          "296:   uchar AFPoint;",
          "297:   ushort AFPointsInFocus;",
          "298:   uchar ContrastDetectAF;",
          "299:   uchar AFAreaMode;",
          "300:   uchar PhaseDetectAF;",
          "301:   uchar PrimaryAFPoint;",
          "302:   uchar AFPointsUsed[29];",
          "303:   ushort AFImageWidth;",
          "304:   ushort AFImageHeight;",
          "305:   ushort AFAreaXPposition;",
          "306:   ushort AFAreaYPosition;",
          "307:   ushort AFAreaWidth;",
          "308:   ushort AFAreaHeight;",
          "309:   uchar ContrastDetectAFInFocus;",
          "311:   char FlashSetting[13];",
          "312:   char FlashType[20];",
          "313:   uchar FlashExposureCompensation[4];",
          "314:   uchar ExternalFlashExposureComp[4];",
          "315:   uchar FlashExposureBracketValue[4];",
          "316:   uchar FlashMode;",
          "317:   signed char FlashExposureCompensation2;",
          "318:   signed char FlashExposureCompensation3;",
          "319:   signed char FlashExposureCompensation4;",
          "320:   uchar FlashSource;",
          "321:   uchar FlashFirmware[2];",
          "322:   uchar ExternalFlashFlags;",
          "323:   uchar FlashControlCommanderMode;",
          "324:   uchar FlashOutputAndCompensation;",
          "325:   uchar FlashFocalLength;",
          "326:   uchar FlashGNDistance;",
          "327:   uchar FlashGroupControlMode[4];",
          "328:   uchar FlashGroupOutputAndCompensation[4];",
          "329:   uchar FlashColorFilter;",
          "334:   int OlympusCropID;",
          "336:   int OlympusSensorCalibration[2];",
          "337:   ushort FocusMode[2];",
          "338:   ushort AutoFocus;",
          "339:   ushort AFPoint;",
          "340:   unsigned AFAreas[64];",
          "341:   double AFPointSelected[5];",
          "342:   ushort AFResult;",
          "343:   unsigned ImageStabilization;",
          "344:   ushort ColorSpace;",
          "349:   ushort FocusMode;",
          "350:   uchar AFPointMode;",
          "351:   ushort AFPointSelected[2];",
          "352:   unsigned AFPointsInFocus;",
          "353:   uchar DriveMode[4];",
          "354:   uchar SRResult;",
          "355:   uchar ShakeReduction;",
          "360:   ushort SonyCameraType;",
          "365:   ushort curve[0x10000];",
          "366:   unsigned cblack[4102];",
          "367:   unsigned black;",
          "368:   unsigned data_maximum;",
          "369:   unsigned maximum;",
          "370:   long linear_max[4];",
          "371:   float fmaximum;",
          "372:   float fnorm;",
          "373:   ushort white[8][8];",
          "374:   float cam_mul[4];",
          "375:   float pre_mul[4];",
          "376:   float cmatrix[3][4];",
          "377:   float ccm[3][4];",
          "378:   float rgb_cam[3][4];",
          "379:   float cam_xyz[4][3];",
          "380:   struct ph1_t phase_one_data;",
          "381:   float flash_used;",
          "382:   float canon_ev;",
          "383:   char model2[64];",
          "384:   char UniqueCameraModel[64];",
          "385:   char LocalizedCameraModel[64];",
          "386:   void *profile;",
          "387:   unsigned profile_length;",
          "388:   unsigned black_stat[8];",
          "389:   libraw_dng_color_t dng_color[2];",
          "391:   float baseline_exposure;",
          "394:   libraw_P1_color_t P1_color[2];",
          "400:   ushort twidth, theight;",
          "401:   unsigned tlength;",
          "402:   int tcolors;",
          "403:   char *thumb;",
          "404: } libraw_thumbnail_t;",
          "411:   float altitude;",
          "412:   char altref, latref, longref, gpsstatus;",
          "413:   char gpsparsed;",
          "418:   float iso_speed;",
          "419:   float shutter;",
          "420:   float aperture;",
          "421:   float focal_len;",
          "422:   time_t timestamp;",
          "423:   unsigned shot_order;",
          "424:   unsigned gpsdata[32];",
          "426:   char desc[512], artist[64];",
          "427:   float FlashEC;",
          "456:   int user_cblack[4];",
          "460:   float auto_bright_thr;",
          "461:   float adjust_maximum_thr;",
          "464:   int green_matching;",
          "466:   int dcb_iterations;",
          "467:   int dcb_enhance_fl;",
          "468:   int fbdd_noiserd;",
          "470:   int eeci_refine;",
          "471:   int es_med_passes;",
          "473:   int ca_correc;",
          "474:   float cared;",
          "475:   float cablue;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "498:   int exp_correc;",
          "499:   float exp_shift;",
          "500:   float exp_preser;",
          "503:   float wf_deband_treshold[4];",
          "505:   int use_rawspeed;",
          "507:   int use_dngsdk;",
          "509:   int no_auto_scale;",
          "",
          "[Removed Lines]",
          "502:   int   wf_debanding;",
          "",
          "[Added Lines]",
          "487:   int wf_debanding;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "519:   char p4shot_order[5];",
          "521:   char **custom_camera_strings;",
          "524: typedef struct",
          "525: {",
          "546:   libraw_image_sizes_t sizes;",
          "547:   libraw_internal_output_params_t ioparams;",
          "548:   libraw_colordata_t color;",
          "",
          "[Removed Lines]",
          "522: }libraw_output_params_t;",
          "527:   void          *raw_alloc;",
          "529:   ushort        *raw_image;",
          "531:   ushort        (*color4_image)[4] ;",
          "533:   ushort        (*color3_image)[3];",
          "535:   float   *float_image;",
          "537:   float   (*float3_image)[3];",
          "539:   float   (*float4_image)[4];",
          "542:   short  (*ph1_cblack)[2];",
          "543:   short  (*ph1_rblack)[2];",
          "545:   libraw_iparams_t  iparams;",
          "",
          "[Added Lines]",
          "507: } libraw_output_params_t;",
          "512:   void *raw_alloc;",
          "514:   ushort *raw_image;",
          "516:   ushort (*color4_image)[4];",
          "518:   ushort (*color3_image)[3];",
          "520:   float *float_image;",
          "522:   float (*float3_image)[3];",
          "524:   float (*float4_image)[4];",
          "527:   short (*ph1_cblack)[2];",
          "528:   short (*ph1_rblack)[2];",
          "530:   libraw_iparams_t iparams;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "551: typedef struct",
          "552: {",
          "553:   unsigned long long LensID;",
          "571:   unsigned long long TeleconverterID;",
          "573:   unsigned long long AdapterID;",
          "575:   unsigned long long AttachmentID;",
          "579: } libraw_makernotes_lens_t;",
          "581: typedef struct",
          "582: {",
          "585: } libraw_nikonlens_t;",
          "587: typedef struct",
          "588: {",
          "590: } libraw_dnglens_t;",
          "592: typedef struct",
          "593: {",
          "597:   libraw_nikonlens_t nikon;",
          "598:   libraw_dnglens_t dng;",
          "599:   libraw_makernotes_lens_t makernotes;",
          "",
          "[Removed Lines]",
          "554:   char         Lens[128];",
          "557:   unsigned long long  CamID;",
          "560:   char         body[64];",
          "562:   char         LensFeatures_pre[16], LensFeatures_suf[16];",
          "563:   float        MinFocal, MaxFocal;",
          "564:   float        MaxAp4MinFocal, MaxAp4MaxFocal, MinAp4MinFocal, MinAp4MaxFocal;",
          "565:   float        MaxAp, MinAp;",
          "566:   float        CurFocal, CurAp;",
          "567:   float        MaxAp4CurFocal, MinAp4CurFocal;",
          "568:   float        MinFocusDistance;",
          "569:   float        FocusRangeIndex;",
          "570:   float        LensFStops;",
          "572:   char         Teleconverter[128];",
          "574:   char         Adapter[128];",
          "576:   char         Attachment[128];",
          "577:   ushort        CanonFocalUnits;",
          "578:   float        FocalLengthIn35mmFormat;",
          "583:   float        NikonEffectiveMaxAp;",
          "584:   uchar        NikonLensIDNumber, NikonLensFStops, NikonMCUVersion, NikonLensType;",
          "589:   float        MinFocal, MaxFocal, MaxAp4MinFocal, MaxAp4MaxFocal;",
          "594:   float        MinFocal, MaxFocal, MaxAp4MinFocal, MaxAp4MaxFocal, EXIF_MaxAp;",
          "595:   char         LensMake[128], Lens[128], LensSerial[128], InternalLensSerial[128];",
          "596:   ushort       FocalLengthIn35mmFormat;",
          "",
          "[Added Lines]",
          "539:   char Lens[128];",
          "542:   unsigned long long CamID;",
          "545:   char body[64];",
          "547:   char LensFeatures_pre[16], LensFeatures_suf[16];",
          "548:   float MinFocal, MaxFocal;",
          "549:   float MaxAp4MinFocal, MaxAp4MaxFocal, MinAp4MinFocal, MinAp4MaxFocal;",
          "550:   float MaxAp, MinAp;",
          "551:   float CurFocal, CurAp;",
          "552:   float MaxAp4CurFocal, MinAp4CurFocal;",
          "553:   float MinFocusDistance;",
          "554:   float FocusRangeIndex;",
          "555:   float LensFStops;",
          "557:   char Teleconverter[128];",
          "559:   char Adapter[128];",
          "561:   char Attachment[128];",
          "562:   ushort CanonFocalUnits;",
          "563:   float FocalLengthIn35mmFormat;",
          "568:   float NikonEffectiveMaxAp;",
          "569:   uchar NikonLensIDNumber, NikonLensFStops, NikonMCUVersion, NikonLensType;",
          "574:   float MinFocal, MaxFocal, MaxAp4MinFocal, MaxAp4MaxFocal;",
          "579:   float MinFocal, MaxFocal, MaxAp4MinFocal, MaxAp4MaxFocal, EXIF_MaxAp;",
          "580:   char LensMake[128], Lens[128], LensSerial[128], InternalLensSerial[128];",
          "581:   ushort FocalLengthIn35mmFormat;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "610: typedef struct",
          "611: {",
          "620: } libraw_shootinginfo_t;",
          "628: } libraw_custom_camera_t;",
          "630: typedef struct",
          "631: {",
          "646: } libraw_data_t;",
          "649: struct xtrans_params",
          "650: {",
          "659: };",
          "661: #ifdef __cplusplus",
          "",
          "[Removed Lines]",
          "612:  short DriveMode;",
          "613:  short FocusMode;",
          "614:  short MeteringMode;",
          "615:  short AFPoint;",
          "616:  short ExposureMode;",
          "617:  short ImageStabilization;",
          "618:  char BodySerial[64];",
          "622: typedef struct {",
          "623:     unsigned fsize;",
          "624:     ushort rw, rh;",
          "625:     uchar lm, tm, rm, bm, lf, cf, max, flags;",
          "626:     char t_make[10], t_model[20];",
          "627:     ushort offset;",
          "632:   ushort                      (*image)[4] ;",
          "633:   libraw_image_sizes_t        sizes;",
          "634:   libraw_iparams_t            idata;",
          "635:   libraw_lensinfo_t           lens;",
          "636:   libraw_makernotes_t         makernotes;",
          "637:   libraw_shootinginfo_t       shootinginfo;",
          "638:   libraw_output_params_t      params;",
          "639:   unsigned int                progress_flags;",
          "640:   unsigned int                process_warnings;",
          "641:   libraw_colordata_t          color;",
          "642:   libraw_imgother_t           other;",
          "643:   libraw_thumbnail_t          thumbnail;",
          "644:   libraw_rawdata_t            rawdata;",
          "645:   void                *parent_class;",
          "653:  int         max_bits;",
          "654:  int         min_value;",
          "655:  int         raw_bits;",
          "656:  int         total_values;",
          "657:  int         maxDiff;",
          "658:  ushort      line_width;",
          "",
          "[Added Lines]",
          "597:   short DriveMode;",
          "598:   short FocusMode;",
          "599:   short MeteringMode;",
          "600:   short AFPoint;",
          "601:   short ExposureMode;",
          "602:   short ImageStabilization;",
          "603:   char BodySerial[64];",
          "607: typedef struct",
          "608: {",
          "609:   unsigned fsize;",
          "610:   ushort rw, rh;",
          "611:   uchar lm, tm, rm, bm, lf, cf, max, flags;",
          "612:   char t_make[10], t_model[20];",
          "613:   ushort offset;",
          "618:   ushort (*image)[4];",
          "619:   libraw_image_sizes_t sizes;",
          "620:   libraw_iparams_t idata;",
          "621:   libraw_lensinfo_t lens;",
          "622:   libraw_makernotes_t makernotes;",
          "623:   libraw_shootinginfo_t shootinginfo;",
          "624:   libraw_output_params_t params;",
          "625:   unsigned int progress_flags;",
          "626:   unsigned int process_warnings;",
          "627:   libraw_colordata_t color;",
          "628:   libraw_imgother_t other;",
          "629:   libraw_thumbnail_t thumbnail;",
          "630:   libraw_rawdata_t rawdata;",
          "631:   void *parent_class;",
          "638:   int max_bits;",
          "639:   int min_value;",
          "640:   int raw_bits;",
          "641:   int total_values;",
          "642:   int maxDiff;",
          "643:   ushort line_width;",
          "",
          "---------------"
        ],
        "libraw/libraw_version.h||libraw/libraw_version.h": [
          "File: libraw/libraw_version.h -> libraw/libraw_version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: #ifndef __VERSION_H",
          "21: #define __VERSION_H",
          "59: #endif",
          "",
          "[Removed Lines]",
          "23: #define LIBRAW_MAJOR_VERSION  0",
          "24: #define LIBRAW_MINOR_VERSION  18",
          "25: #define LIBRAW_PATCH_VERSION  0",
          "26: #define LIBRAW_VERSION_TAIL   Release",
          "28: #define LIBRAW_SHLIB_CURRENT   16",
          "29: #define LIBRAW_SHLIB_REVISION  0",
          "30: #define LIBRAW_SHLIB_AGE      0",
          "32: #define _LIBRAW_VERSION_MAKE(a,b,c,d) #a\".\"#b\".\"#c\"-\"#d",
          "33: #define LIBRAW_VERSION_MAKE(a,b,c,d) _LIBRAW_VERSION_MAKE(a,b,c,d)",
          "35: #define LIBRAW_VERSION_STR LIBRAW_VERSION_MAKE(LIBRAW_MAJOR_VERSION,LIBRAW_MINOR_VERSION,LIBRAW_PATCH_VERSION,LIBRAW_VERSION_TAIL)",
          "37: #define LIBRAW_MAKE_VERSION(major,minor,patch) \\",
          "38:     (((major) << 16) | ((minor) << 8) | (patch))",
          "40: #define LIBRAW_VERSION \\",
          "41:     LIBRAW_MAKE_VERSION(LIBRAW_MAJOR_VERSION,LIBRAW_MINOR_VERSION,LIBRAW_PATCH_VERSION)",
          "43: #define LIBRAW_CHECK_VERSION(major,minor,patch) \\",
          "44:     ( LibRaw::versionNumber() >= LIBRAW_MAKE_VERSION(major,minor,patch) )",
          "46: #define LIBRAW_RUNTIME_CHECK_VERSION_EXACT() \\",
          "47:     ( (LibRaw::versionNumber() & 0xffff00) == LIBRAW_MAKE_VERSION(LIBRAW_MAJOR_VERSION,LIBRAW_MINOR_VERSION,0) )",
          "49: #define LIBRAW_RUNTIME_CHECK_VERSION_NOTLESS() \\",
          "50:     ( (LibRaw::versionNumber() & 0xffff00) >= LIBRAW_MAKE_VERSION(LIBRAW_MAJOR_VERSION,LIBRAW_MINOR_VERSION,0) )",
          "52: #define LIBRAW_COMPILE_CHECK_VERSION(major,minor) \\",
          "53:     (LIBRAW_MAKE_VERSION(major,minor,0) == (LIBRAW_VERSION & 0xffff00))",
          "55: #define LIBRAW_COMPILE_CHECK_VERSION_NOTLESS(major,minor) \\",
          "56:     (LIBRAW_MAKE_VERSION(major,minor,0) <= (LIBRAW_VERSION & 0xffff00))",
          "",
          "[Added Lines]",
          "23: #define LIBRAW_MAJOR_VERSION 0",
          "24: #define LIBRAW_MINOR_VERSION 18",
          "25: #define LIBRAW_PATCH_VERSION 0",
          "26: #define LIBRAW_VERSION_TAIL Release",
          "28: #define LIBRAW_SHLIB_CURRENT 16",
          "29: #define LIBRAW_SHLIB_REVISION 0",
          "30: #define LIBRAW_SHLIB_AGE 0",
          "32: #define _LIBRAW_VERSION_MAKE(a, b, c, d) #a \".\" #b \".\" #c \"-\" #d",
          "33: #define LIBRAW_VERSION_MAKE(a, b, c, d) _LIBRAW_VERSION_MAKE(a, b, c, d)",
          "35: #define LIBRAW_VERSION_STR                                                                                             \\",
          "36:   LIBRAW_VERSION_MAKE(LIBRAW_MAJOR_VERSION, LIBRAW_MINOR_VERSION, LIBRAW_PATCH_VERSION, LIBRAW_VERSION_TAIL)",
          "38: #define LIBRAW_MAKE_VERSION(major, minor, patch) (((major) << 16) | ((minor) << 8) | (patch))",
          "40: #define LIBRAW_VERSION LIBRAW_MAKE_VERSION(LIBRAW_MAJOR_VERSION, LIBRAW_MINOR_VERSION, LIBRAW_PATCH_VERSION)",
          "42: #define LIBRAW_CHECK_VERSION(major, minor, patch) (LibRaw::versionNumber() >= LIBRAW_MAKE_VERSION(major, minor, patch))",
          "44: #define LIBRAW_RUNTIME_CHECK_VERSION_EXACT()                                                                           \\",
          "45:   ((LibRaw::versionNumber() & 0xffff00) == LIBRAW_MAKE_VERSION(LIBRAW_MAJOR_VERSION, LIBRAW_MINOR_VERSION, 0))",
          "47: #define LIBRAW_RUNTIME_CHECK_VERSION_NOTLESS()                                                                         \\",
          "48:   ((LibRaw::versionNumber() & 0xffff00) >= LIBRAW_MAKE_VERSION(LIBRAW_MAJOR_VERSION, LIBRAW_MINOR_VERSION, 0))",
          "50: #define LIBRAW_COMPILE_CHECK_VERSION(major, minor) (LIBRAW_MAKE_VERSION(major, minor, 0) == (LIBRAW_VERSION & 0xffff00))",
          "52: #define LIBRAW_COMPILE_CHECK_VERSION_NOTLESS(major, minor)                                                             \\",
          "53:   (LIBRAW_MAKE_VERSION(major, minor, 0) <= (LIBRAW_VERSION & 0xffff00))",
          "",
          "---------------"
        ],
        "src/libraw_c_api.cpp||src/libraw_c_api.cpp": [
          "File: src/libraw_c_api.cpp -> src/libraw_c_api.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #ifdef __cplusplus",
          "25: #include <new>",
          "28: #endif",
          "77: #if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)",
          "91: #endif",
          "296: DllDef int libraw_get_raw_height(libraw_data_t *lr)",
          "302: DllDef int libraw_get_raw_width(libraw_data_t *lr)",
          "308: DllDef int libraw_get_iheight(libraw_data_t *lr)",
          "314: DllDef int libraw_get_iwidth(libraw_data_t *lr)",
          "339: DllDef int libraw_get_color_maximum(libraw_data_t *lr)",
          "362: DllDef void libraw_set_wf_debanding(libraw_data_t *lr, int wf_debanding, float wfd0, float wfd1, float wfd2, float wfd3)",
          "382: #ifdef __cplusplus",
          "383: }",
          "",
          "[Removed Lines]",
          "26: extern \"C\"",
          "27: {",
          "30:     libraw_data_t *libraw_init(unsigned int flags)",
          "31:     {",
          "32:         LibRaw *ret;",
          "33:         try {",
          "34:             ret = new LibRaw(flags);",
          "35:         }",
          "36:         catch (std::bad_alloc)",
          "37:             {",
          "38:                 return NULL;",
          "39:             }",
          "40:         return &(ret->imgdata);",
          "41:     }",
          "43:  unsigned libraw_capabilities() { return LibRaw::capabilities();}",
          "44:     const char*   libraw_version() { return LibRaw::version();}",
          "45:     const char*   libraw_strprogress(enum LibRaw_progress p) { return LibRaw::strprogress(p);}",
          "46:     int     libraw_versionNumber() { return LibRaw::versionNumber();}",
          "47:     const char**  libraw_cameraList() { return LibRaw::cameraList();}",
          "48:     int   libraw_cameraCount() { return LibRaw::cameraCount(); }",
          "49:     const char* libraw_unpack_function_name(libraw_data_t* lr)",
          "50:     {",
          "51:         if(!lr) return \"NULL parameter passed\";",
          "52:         LibRaw *ip = (LibRaw*) lr->parent_class;",
          "53:         return ip->unpack_function_name();",
          "54:     }",
          "56:     void libraw_subtract_black(libraw_data_t* lr)",
          "57:     {",
          "58:         if(!lr) return;",
          "59:         LibRaw *ip = (LibRaw*) lr->parent_class;",
          "60:         ip->subtract_black();",
          "61:     }",
          "64:     int libraw_open_file(libraw_data_t* lr, const char *file)",
          "65:     {",
          "66:         if(!lr) return EINVAL;",
          "67:         LibRaw *ip = (LibRaw*) lr->parent_class;",
          "68:         return ip->open_file(file);",
          "69:     }",
          "71:     int libraw_open_file_ex(libraw_data_t* lr, const char *file,INT64 sz)",
          "72:     {",
          "73:         if(!lr) return EINVAL;",
          "74:         LibRaw *ip = (LibRaw*) lr->parent_class;",
          "75:         return ip->open_file(file,sz);",
          "76:     }",
          "78:     int libraw_open_wfile(libraw_data_t* lr, const wchar_t *file)",
          "79:     {",
          "80:         if(!lr) return EINVAL;",
          "81:         LibRaw *ip = (LibRaw*) lr->parent_class;",
          "82:         return ip->open_file(file);",
          "83:     }",
          "85:     int libraw_open_wfile_ex(libraw_data_t* lr, const wchar_t *file,INT64 sz)",
          "86:     {",
          "87:         if(!lr) return EINVAL;",
          "88:         LibRaw *ip = (LibRaw*) lr->parent_class;",
          "89:         return ip->open_file(file,sz);",
          "90:     }",
          "92:     int libraw_open_buffer(libraw_data_t* lr, void *buffer, size_t size)",
          "93:     {",
          "94:         if(!lr) return EINVAL;",
          "95:         LibRaw *ip = (LibRaw*) lr->parent_class;",
          "96:         return ip->open_buffer(buffer,size);",
          "97:     }",
          "98:     int libraw_unpack(libraw_data_t* lr)",
          "99:     {",
          "100:         if(!lr) return EINVAL;",
          "101:         LibRaw *ip = (LibRaw*) lr->parent_class;",
          "102:         return ip->unpack();",
          "103:     }",
          "104:     int libraw_unpack_thumb(libraw_data_t* lr)",
          "105:     {",
          "106:         if(!lr) return EINVAL;",
          "107:         LibRaw *ip = (LibRaw*) lr->parent_class;",
          "108:         return ip->unpack_thumb();",
          "109:     }",
          "110:  void libraw_recycle_datastream(libraw_data_t* lr)",
          "111:  {",
          "112:   if(!lr) return;",
          "113:   LibRaw *ip = (LibRaw*) lr->parent_class;",
          "114:   ip->recycle_datastream();",
          "115:  }",
          "116:     void libraw_recycle(libraw_data_t* lr)",
          "117:     {",
          "118:         if(!lr) return;",
          "119:         LibRaw *ip = (LibRaw*) lr->parent_class;",
          "120:         ip->recycle();",
          "121:     }",
          "122:     void libraw_close(libraw_data_t* lr)",
          "123:     {",
          "124:         if(!lr) return;",
          "125:         LibRaw *ip = (LibRaw*) lr->parent_class;",
          "126:         delete ip;",
          "127:     }",
          "129:  void  libraw_set_exifparser_handler(libraw_data_t* lr, exif_parser_callback cb,void *data)",
          "130:  {",
          "131:   if(!lr) return;",
          "132:   LibRaw *ip = (LibRaw*) lr->parent_class;",
          "133:   ip->set_exifparser_handler(cb,data);",
          "135:  }",
          "137:     void  libraw_set_memerror_handler(libraw_data_t* lr, memory_callback cb,void *data)",
          "138:     {",
          "139:         if(!lr) return;",
          "140:         LibRaw *ip = (LibRaw*) lr->parent_class;",
          "141:         ip->set_memerror_handler(cb,data);",
          "143:     }",
          "144:     void libraw_set_dataerror_handler(libraw_data_t* lr,data_callback func,void *data)",
          "145:     {",
          "146:         if(!lr) return;",
          "147:         LibRaw *ip = (LibRaw*) lr->parent_class;",
          "148:         ip->set_dataerror_handler(func,data);",
          "150:     }",
          "151:     void  libraw_set_progress_handler(libraw_data_t* lr, progress_callback cb,void *data)",
          "152:     {",
          "153:         if(!lr) return;",
          "154:         LibRaw *ip = (LibRaw*) lr->parent_class;",
          "155:         ip->set_progress_handler(cb,data);",
          "157:     }",
          "160:     int  libraw_adjust_sizes_info_only(libraw_data_t* lr)",
          "161:     {",
          "162:         if(!lr) return EINVAL;",
          "163:         LibRaw *ip = (LibRaw*) lr->parent_class;",
          "164:         return ip->adjust_sizes_info_only();",
          "165:     }",
          "166:     int  libraw_dcraw_ppm_tiff_writer(libraw_data_t* lr,const char *filename)",
          "167:     {",
          "168:         if(!lr) return EINVAL;",
          "169:         LibRaw *ip = (LibRaw*) lr->parent_class;",
          "170:         return ip->dcraw_ppm_tiff_writer(filename);",
          "171:     }",
          "172:     int  libraw_dcraw_thumb_writer(libraw_data_t* lr,const char *fname)",
          "173:     {",
          "174:         if(!lr) return EINVAL;",
          "175:         LibRaw *ip = (LibRaw*) lr->parent_class;",
          "176:         return ip->dcraw_thumb_writer(fname);",
          "178:     }",
          "179:     int libraw_dcraw_process(libraw_data_t* lr)",
          "180:     {",
          "181:         if(!lr) return EINVAL;",
          "182:         LibRaw *ip = (LibRaw*) lr->parent_class;",
          "183:         return ip->dcraw_process();",
          "184:     }",
          "185:     libraw_processed_image_t *libraw_dcraw_make_mem_image(libraw_data_t* lr,int *errc)",
          "186:     {",
          "187:         if(!lr) { if(errc) *errc=EINVAL; return NULL;}",
          "188:         LibRaw *ip = (LibRaw*) lr->parent_class;",
          "189:         return ip->dcraw_make_mem_image(errc);",
          "190:     }",
          "191:     libraw_processed_image_t *libraw_dcraw_make_mem_thumb(libraw_data_t* lr,int *errc)",
          "192:     {",
          "193:         if(!lr) { if(errc) *errc=EINVAL; return NULL;}",
          "194:         LibRaw *ip = (LibRaw*) lr->parent_class;",
          "195:         return ip->dcraw_make_mem_thumb(errc);",
          "196:     }",
          "198:     void libraw_dcraw_clear_mem(libraw_processed_image_t* p)",
          "199:     {",
          "200:         LibRaw::dcraw_clear_mem(p);",
          "201:     }",
          "203:     int  libraw_raw2image(libraw_data_t* lr)",
          "204:     {",
          "205:         if(!lr) return EINVAL;",
          "206:         LibRaw *ip = (LibRaw*) lr->parent_class;",
          "207:         return ip->raw2image();",
          "208:     }",
          "209:     void  libraw_free_image(libraw_data_t* lr)",
          "210:     {",
          "211:         if(!lr) return;",
          "212:         LibRaw *ip = (LibRaw*) lr->parent_class;",
          "213:         ip->free_image();",
          "214:     }",
          "215:     int  libraw_get_decoder_info(libraw_data_t* lr,libraw_decoder_info_t *d)",
          "216:     {",
          "217:         if(!lr || !d) return EINVAL;",
          "218:         LibRaw *ip = (LibRaw*) lr->parent_class;",
          "219:         return ip->get_decoder_info(d);",
          "220:     }",
          "221:     int libraw_COLOR(libraw_data_t *lr, int row, int col)",
          "222:     {",
          "223:         if(!lr) return EINVAL;",
          "224:         LibRaw *ip = (LibRaw*) lr->parent_class;",
          "225:         return ip->COLOR(row,col);",
          "226:     }",
          "229: DllDef void libraw_set_demosaic(libraw_data_t *lr,int value)",
          "230:  {",
          "231:   if(!lr) return;",
          "232:   LibRaw *ip = (LibRaw*) lr->parent_class;",
          "233:   ip->imgdata.params.user_qual = value;",
          "234:  }",
          "236: DllDef void libraw_set_output_color(libraw_data_t *lr,int value)",
          "237:  {",
          "238:   if(!lr) return;",
          "239:   LibRaw *ip = (LibRaw*) lr->parent_class;",
          "240:   ip->imgdata.params.output_color = value;",
          "241:  }",
          "243: DllDef void libraw_set_output_bps(libraw_data_t *lr,int value)",
          "244:  {",
          "245:   if(!lr) return;",
          "246:   LibRaw *ip = (LibRaw*) lr->parent_class;",
          "247:   ip->imgdata.params.output_bps = value;",
          "248:  }",
          "250: #define MIN(a,b) ((a) < (b) ? (a) : (b))",
          "251: #define MAX(a,b) ((a) > (b) ? (a) : (b))",
          "252: #define LIM(x,min,max) MAX(min,MIN(x,max))",
          "254: DllDef void libraw_set_user_mul(libraw_data_t *lr,int index, float val)",
          "255:  {",
          "256:   if(!lr) return;",
          "257:   LibRaw *ip = (LibRaw*) lr->parent_class;",
          "258:   ip->imgdata.params.user_mul[LIM(index,0,3)]=val;",
          "259:  }",
          "261: DllDef void libraw_set_gamma(libraw_data_t *lr,int index, float value)",
          "262:  {",
          "263:   if(!lr) return;",
          "264:   LibRaw *ip = (LibRaw*) lr->parent_class;",
          "265:   ip->imgdata.params.gamm[LIM(index,0,5)] = value;",
          "266:  }",
          "268: DllDef void libraw_set_no_auto_bright(libraw_data_t *lr,int value)",
          "269:  {",
          "270:   if(!lr) return;",
          "271:   LibRaw *ip = (LibRaw*) lr->parent_class;",
          "272:   ip->imgdata.params.no_auto_bright = value;",
          "273:  }",
          "275: DllDef void libraw_set_bright(libraw_data_t *lr,float value)",
          "276:  {",
          "277:   if(!lr) return;",
          "278:   LibRaw *ip = (LibRaw*) lr->parent_class;",
          "279:   ip->imgdata.params.bright = value;",
          "280:  }",
          "282: DllDef void libraw_set_highlight(libraw_data_t *lr,int value)",
          "283:  {",
          "284:   if(!lr) return;",
          "285:   LibRaw *ip = (LibRaw*) lr->parent_class;",
          "286:   ip->imgdata.params.highlight = value;",
          "287:  }",
          "289: DllDef void libraw_set_fbdd_noiserd(libraw_data_t *lr,int value)",
          "290:  {",
          "291:   if(!lr) return;",
          "292:   LibRaw *ip = (LibRaw*) lr->parent_class;",
          "293:   ip->imgdata.params.fbdd_noiserd = value;",
          "294:  }",
          "297:     {",
          "298:         if(!lr) return EINVAL;",
          "299:         return lr->sizes.raw_height;",
          "300:     }",
          "303:     {",
          "304:         if(!lr) return EINVAL;",
          "305:         return lr->sizes.raw_width;",
          "306:     }",
          "309:     {",
          "310:         if(!lr) return EINVAL;",
          "311:         return lr->sizes.iheight;",
          "312:     }",
          "315:     {",
          "316:         if(!lr) return EINVAL;",
          "317:         return lr->sizes.iwidth;",
          "318:     }",
          "321: DllDef float libraw_get_cam_mul(libraw_data_t *lr,int index)",
          "322:  {",
          "323:   if(!lr) return EINVAL;",
          "324:   return lr->color.cam_mul[LIM(index,0,3)];",
          "325:  }",
          "327: DllDef float libraw_get_pre_mul(libraw_data_t *lr,int index)",
          "328:  {",
          "329:   if(!lr) return EINVAL;",
          "330:   return lr->color.pre_mul[LIM(index,0,3)];",
          "331:  }",
          "333: DllDef float libraw_get_rgb_cam(libraw_data_t *lr,int index1, int index2)",
          "334:  {",
          "335:   if(!lr) return EINVAL;",
          "336:   return lr->color.rgb_cam[LIM(index1,0,2)][LIM(index2,0,3)];",
          "337:  }",
          "340:     {",
          "341:         if(!lr) return EINVAL;",
          "342:         return lr->color.maximum;",
          "343:     }",
          "345: DllDef void libraw_set_ca_correction(libraw_data_t *lr,int ca_correc, float ca_red, float ca_blue)",
          "346:  {",
          "347:   if(!lr) return;",
          "348:   LibRaw *ip = (LibRaw*) lr->parent_class;",
          "349:   ip->imgdata.params.ca_correc = ca_correc;",
          "350:   ip->imgdata.params.cared = ca_red;",
          "351:   ip->imgdata.params.cablue = ca_blue;",
          "352:  }",
          "354: DllDef void libraw_set_cfalinenoise(libraw_data_t *lr,int cfaline, float linenoise)",
          "355:  {",
          "356:   if(!lr) return;",
          "357:   LibRaw *ip = (LibRaw*) lr->parent_class;",
          "358:   ip->imgdata.params.cfaline = cfaline;",
          "359:   ip->imgdata.params.linenoise = linenoise;",
          "360:  }",
          "363:  {",
          "364:   if(!lr) return;",
          "365:   LibRaw *ip = (LibRaw*) lr->parent_class;",
          "366:   ip->imgdata.params.wf_debanding = wf_debanding;",
          "367:   ip->imgdata.params.wf_deband_treshold[0] = wfd0;",
          "368:   ip->imgdata.params.wf_deband_treshold[1] = wfd1;",
          "369:   ip->imgdata.params.wf_deband_treshold[2] = wfd2;",
          "370:   ip->imgdata.params.wf_deband_treshold[3] = wfd3;",
          "371:  }",
          "373: DllDef void libraw_set_interpolation_passes(libraw_data_t *lr,int passes)",
          "374:  {",
          "375:   if(!lr) return;",
          "376:   LibRaw *ip = (LibRaw*) lr->parent_class;",
          "377:   ip->imgdata.params.med_passes = passes;",
          "378:   ip->imgdata.params.es_med_passes = passes;",
          "379:   ip->imgdata.params.dcb_iterations = passes;",
          "380:  }",
          "",
          "[Added Lines]",
          "26: extern \"C\" {",
          "29: libraw_data_t *libraw_init(unsigned int flags)",
          "30: {",
          "31:   LibRaw *ret;",
          "32:   try",
          "33:   {",
          "34:     ret = new LibRaw(flags);",
          "35:   }",
          "36:   catch (std::bad_alloc)",
          "37:   {",
          "38:     return NULL;",
          "39:   }",
          "40:   return &(ret->imgdata);",
          "41: }",
          "43: unsigned libraw_capabilities() { return LibRaw::capabilities(); }",
          "44: const char *libraw_version() { return LibRaw::version(); }",
          "45: const char *libraw_strprogress(enum LibRaw_progress p) { return LibRaw::strprogress(p); }",
          "46: int libraw_versionNumber() { return LibRaw::versionNumber(); }",
          "47: const char **libraw_cameraList() { return LibRaw::cameraList(); }",
          "48: int libraw_cameraCount() { return LibRaw::cameraCount(); }",
          "49: const char *libraw_unpack_function_name(libraw_data_t *lr)",
          "50: {",
          "51:   if (!lr)",
          "52:     return \"NULL parameter passed\";",
          "53:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "54:   return ip->unpack_function_name();",
          "55: }",
          "57: void libraw_subtract_black(libraw_data_t *lr)",
          "58: {",
          "59:   if (!lr)",
          "60:     return;",
          "61:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "62:   ip->subtract_black();",
          "63: }",
          "65: int libraw_open_file(libraw_data_t *lr, const char *file)",
          "66: {",
          "67:   if (!lr)",
          "68:     return EINVAL;",
          "69:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "70:   return ip->open_file(file);",
          "71: }",
          "73: int libraw_open_file_ex(libraw_data_t *lr, const char *file, INT64 sz)",
          "74: {",
          "75:   if (!lr)",
          "76:     return EINVAL;",
          "77:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "78:   return ip->open_file(file, sz);",
          "79: }",
          "81: int libraw_open_wfile(libraw_data_t *lr, const wchar_t *file)",
          "82: {",
          "83:   if (!lr)",
          "84:     return EINVAL;",
          "85:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "86:   return ip->open_file(file);",
          "87: }",
          "89: int libraw_open_wfile_ex(libraw_data_t *lr, const wchar_t *file, INT64 sz)",
          "90: {",
          "91:   if (!lr)",
          "92:     return EINVAL;",
          "93:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "94:   return ip->open_file(file, sz);",
          "95: }",
          "97: int libraw_open_buffer(libraw_data_t *lr, void *buffer, size_t size)",
          "98: {",
          "99:   if (!lr)",
          "100:     return EINVAL;",
          "101:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "102:   return ip->open_buffer(buffer, size);",
          "103: }",
          "104: int libraw_unpack(libraw_data_t *lr)",
          "105: {",
          "106:   if (!lr)",
          "107:     return EINVAL;",
          "108:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "109:   return ip->unpack();",
          "110: }",
          "111: int libraw_unpack_thumb(libraw_data_t *lr)",
          "112: {",
          "113:   if (!lr)",
          "114:     return EINVAL;",
          "115:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "116:   return ip->unpack_thumb();",
          "117: }",
          "118: void libraw_recycle_datastream(libraw_data_t *lr)",
          "119: {",
          "120:   if (!lr)",
          "121:     return;",
          "122:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "123:   ip->recycle_datastream();",
          "124: }",
          "125: void libraw_recycle(libraw_data_t *lr)",
          "126: {",
          "127:   if (!lr)",
          "128:     return;",
          "129:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "130:   ip->recycle();",
          "131: }",
          "132: void libraw_close(libraw_data_t *lr)",
          "133: {",
          "134:   if (!lr)",
          "135:     return;",
          "136:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "137:   delete ip;",
          "138: }",
          "140: void libraw_set_exifparser_handler(libraw_data_t *lr, exif_parser_callback cb, void *data)",
          "141: {",
          "142:   if (!lr)",
          "143:     return;",
          "144:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "145:   ip->set_exifparser_handler(cb, data);",
          "146: }",
          "148: void libraw_set_memerror_handler(libraw_data_t *lr, memory_callback cb, void *data)",
          "149: {",
          "150:   if (!lr)",
          "151:     return;",
          "152:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "153:   ip->set_memerror_handler(cb, data);",
          "154: }",
          "155: void libraw_set_dataerror_handler(libraw_data_t *lr, data_callback func, void *data)",
          "156: {",
          "157:   if (!lr)",
          "158:     return;",
          "159:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "160:   ip->set_dataerror_handler(func, data);",
          "161: }",
          "162: void libraw_set_progress_handler(libraw_data_t *lr, progress_callback cb, void *data)",
          "163: {",
          "164:   if (!lr)",
          "165:     return;",
          "166:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "167:   ip->set_progress_handler(cb, data);",
          "168: }",
          "171: int libraw_adjust_sizes_info_only(libraw_data_t *lr)",
          "172: {",
          "173:   if (!lr)",
          "174:     return EINVAL;",
          "175:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "176:   return ip->adjust_sizes_info_only();",
          "177: }",
          "178: int libraw_dcraw_ppm_tiff_writer(libraw_data_t *lr, const char *filename)",
          "179: {",
          "180:   if (!lr)",
          "181:     return EINVAL;",
          "182:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "183:   return ip->dcraw_ppm_tiff_writer(filename);",
          "184: }",
          "185: int libraw_dcraw_thumb_writer(libraw_data_t *lr, const char *fname)",
          "186: {",
          "187:   if (!lr)",
          "188:     return EINVAL;",
          "189:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "190:   return ip->dcraw_thumb_writer(fname);",
          "191: }",
          "192: int libraw_dcraw_process(libraw_data_t *lr)",
          "193: {",
          "194:   if (!lr)",
          "195:     return EINVAL;",
          "196:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "197:   return ip->dcraw_process();",
          "198: }",
          "199: libraw_processed_image_t *libraw_dcraw_make_mem_image(libraw_data_t *lr, int *errc)",
          "200: {",
          "201:   if (!lr)",
          "202:   {",
          "203:     if (errc)",
          "205:     return NULL;",
          "206:   }",
          "207:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "208:   return ip->dcraw_make_mem_image(errc);",
          "209: }",
          "210: libraw_processed_image_t *libraw_dcraw_make_mem_thumb(libraw_data_t *lr, int *errc)",
          "211: {",
          "212:   if (!lr)",
          "213:   {",
          "214:     if (errc)",
          "216:     return NULL;",
          "217:   }",
          "218:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "219:   return ip->dcraw_make_mem_thumb(errc);",
          "220: }",
          "222: void libraw_dcraw_clear_mem(libraw_processed_image_t *p) { LibRaw::dcraw_clear_mem(p); }",
          "224: int libraw_raw2image(libraw_data_t *lr)",
          "225: {",
          "226:   if (!lr)",
          "227:     return EINVAL;",
          "228:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "229:   return ip->raw2image();",
          "230: }",
          "231: void libraw_free_image(libraw_data_t *lr)",
          "232: {",
          "233:   if (!lr)",
          "234:     return;",
          "235:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "236:   ip->free_image();",
          "237: }",
          "238: int libraw_get_decoder_info(libraw_data_t *lr, libraw_decoder_info_t *d)",
          "239: {",
          "240:   if (!lr || !d)",
          "241:     return EINVAL;",
          "242:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "243:   return ip->get_decoder_info(d);",
          "244: }",
          "245: int libraw_COLOR(libraw_data_t *lr, int row, int col)",
          "246: {",
          "247:   if (!lr)",
          "248:     return EINVAL;",
          "249:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "250:   return ip->COLOR(row, col);",
          "251: }",
          "254: DllDef void libraw_set_demosaic(libraw_data_t *lr, int value)",
          "255: {",
          "256:   if (!lr)",
          "257:     return;",
          "258:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "259:   ip->imgdata.params.user_qual = value;",
          "260: }",
          "262: DllDef void libraw_set_output_color(libraw_data_t *lr, int value)",
          "263: {",
          "264:   if (!lr)",
          "265:     return;",
          "266:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "267:   ip->imgdata.params.output_color = value;",
          "268: }",
          "270: DllDef void libraw_set_output_bps(libraw_data_t *lr, int value)",
          "271: {",
          "272:   if (!lr)",
          "273:     return;",
          "274:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "275:   ip->imgdata.params.output_bps = value;",
          "276: }",
          "278: #define MIN(a, b) ((a) < (b) ? (a) : (b))",
          "279: #define MAX(a, b) ((a) > (b) ? (a) : (b))",
          "280: #define LIM(x, min, max) MAX(min, MIN(x, max))",
          "282: DllDef void libraw_set_user_mul(libraw_data_t *lr, int index, float val)",
          "283: {",
          "284:   if (!lr)",
          "285:     return;",
          "286:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "287:   ip->imgdata.params.user_mul[LIM(index, 0, 3)] = val;",
          "288: }",
          "290: DllDef void libraw_set_gamma(libraw_data_t *lr, int index, float value)",
          "291: {",
          "292:   if (!lr)",
          "293:     return;",
          "294:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "295:   ip->imgdata.params.gamm[LIM(index, 0, 5)] = value;",
          "296: }",
          "298: DllDef void libraw_set_no_auto_bright(libraw_data_t *lr, int value)",
          "299: {",
          "300:   if (!lr)",
          "301:     return;",
          "302:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "303:   ip->imgdata.params.no_auto_bright = value;",
          "304: }",
          "306: DllDef void libraw_set_bright(libraw_data_t *lr, float value)",
          "307: {",
          "308:   if (!lr)",
          "309:     return;",
          "310:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "311:   ip->imgdata.params.bright = value;",
          "312: }",
          "314: DllDef void libraw_set_highlight(libraw_data_t *lr, int value)",
          "315: {",
          "316:   if (!lr)",
          "317:     return;",
          "318:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "319:   ip->imgdata.params.highlight = value;",
          "320: }",
          "322: DllDef void libraw_set_fbdd_noiserd(libraw_data_t *lr, int value)",
          "323: {",
          "324:   if (!lr)",
          "325:     return;",
          "326:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "327:   ip->imgdata.params.fbdd_noiserd = value;",
          "328: }",
          "331: {",
          "332:   if (!lr)",
          "333:     return EINVAL;",
          "334:   return lr->sizes.raw_height;",
          "335: }",
          "338: {",
          "339:   if (!lr)",
          "340:     return EINVAL;",
          "341:   return lr->sizes.raw_width;",
          "342: }",
          "345: {",
          "346:   if (!lr)",
          "347:     return EINVAL;",
          "348:   return lr->sizes.iheight;",
          "349: }",
          "352: {",
          "353:   if (!lr)",
          "354:     return EINVAL;",
          "355:   return lr->sizes.iwidth;",
          "356: }",
          "358: DllDef float libraw_get_cam_mul(libraw_data_t *lr, int index)",
          "359: {",
          "360:   if (!lr)",
          "361:     return EINVAL;",
          "362:   return lr->color.cam_mul[LIM(index, 0, 3)];",
          "363: }",
          "365: DllDef float libraw_get_pre_mul(libraw_data_t *lr, int index)",
          "366: {",
          "367:   if (!lr)",
          "368:     return EINVAL;",
          "369:   return lr->color.pre_mul[LIM(index, 0, 3)];",
          "370: }",
          "372: DllDef float libraw_get_rgb_cam(libraw_data_t *lr, int index1, int index2)",
          "373: {",
          "374:   if (!lr)",
          "375:     return EINVAL;",
          "376:   return lr->color.rgb_cam[LIM(index1, 0, 2)][LIM(index2, 0, 3)];",
          "377: }",
          "380: {",
          "381:   if (!lr)",
          "382:     return EINVAL;",
          "383:   return lr->color.maximum;",
          "384: }",
          "386: DllDef void libraw_set_ca_correction(libraw_data_t *lr, int ca_correc, float ca_red, float ca_blue)",
          "387: {",
          "388:   if (!lr)",
          "389:     return;",
          "390:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "391:   ip->imgdata.params.ca_correc = ca_correc;",
          "392:   ip->imgdata.params.cared = ca_red;",
          "393:   ip->imgdata.params.cablue = ca_blue;",
          "394: }",
          "396: DllDef void libraw_set_cfalinenoise(libraw_data_t *lr, int cfaline, float linenoise)",
          "397: {",
          "398:   if (!lr)",
          "399:     return;",
          "400:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "401:   ip->imgdata.params.cfaline = cfaline;",
          "402:   ip->imgdata.params.linenoise = linenoise;",
          "403: }",
          "406: {",
          "407:   if (!lr)",
          "408:     return;",
          "409:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "410:   ip->imgdata.params.wf_debanding = wf_debanding;",
          "411:   ip->imgdata.params.wf_deband_treshold[0] = wfd0;",
          "412:   ip->imgdata.params.wf_deband_treshold[1] = wfd1;",
          "413:   ip->imgdata.params.wf_deband_treshold[2] = wfd2;",
          "414:   ip->imgdata.params.wf_deband_treshold[3] = wfd3;",
          "415: }",
          "417: DllDef void libraw_set_interpolation_passes(libraw_data_t *lr, int passes)",
          "418: {",
          "419:   if (!lr)",
          "420:     return;",
          "421:   LibRaw *ip = (LibRaw *)lr->parent_class;",
          "422:   ip->imgdata.params.med_passes = passes;",
          "423:   ip->imgdata.params.es_med_passes = passes;",
          "424:   ip->imgdata.params.dcb_iterations = passes;",
          "425: }",
          "",
          "---------------"
        ],
        "src/libraw_cxx.cpp||src/libraw_cxx.cpp": [
          "File: src/libraw_cxx.cpp -> src/libraw_cxx.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: #if defined(_WIN32)",
          "39: #if defined _MSC_VER",
          "48: #else",
          "49: #include <stdint.h>",
          "50: #endif // _WIN32",
          "",
          "[Removed Lines]",
          "40: typedef   signed __int8   int8_t;",
          "41: typedef unsigned __int8   uint8_t;",
          "42: typedef   signed __int16  int16_t;",
          "43: typedef unsigned __int16  uint16_t;",
          "44: typedef   signed __int32  int32_t;",
          "45: typedef unsigned __int32  uint32_t;",
          "46: typedef   signed __int64  int64_t;",
          "47: typedef unsigned __int64  uint64_t;",
          "",
          "[Added Lines]",
          "40: typedef signed __int8 int8_t;",
          "41: typedef unsigned __int8 uint8_t;",
          "42: typedef signed __int16 int16_t;",
          "43: typedef unsigned __int16 uint16_t;",
          "44: typedef signed __int32 int32_t;",
          "45: typedef unsigned __int32 uint32_t;",
          "46: typedef signed __int64 int64_t;",
          "47: typedef unsigned __int64 uint64_t;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "74: #include \"libraw_xtrans_compressed.cpp\"",
          "76: #ifdef __cplusplus",
          "79: #endif",
          "93:   {",
          "126:   }",
          "128: #ifdef __cplusplus",
          "129: }",
          "130: #endif",
          "143: #define P1 imgdata.idata",
          "144: #define S imgdata.sizes",
          "",
          "[Removed Lines]",
          "77: extern \"C\"",
          "78: {",
          "80:   void default_memory_callback(void *,const char *file,const char *where)",
          "81:   {",
          "82:     fprintf (stderr,\"%s: Out of memory in %s\\n\", file?file:\"unknown file\", where);",
          "83:   }",
          "85:   void default_data_callback(void*,const char *file, const int offset)",
          "86:   {",
          "87:     if(offset < 0)",
          "88:       fprintf (stderr,\"%s: Unexpected end of file\\n\", file?file:\"unknown file\");",
          "89:     else",
          "90:       fprintf (stderr,\"%s: data corrupted at %d\\n\",file?file:\"unknown file\",offset);",
          "91:   }",
          "92:   const char *libraw_strerror(int e)",
          "94:     enum LibRaw_errors errorcode = (LibRaw_errors)e;",
          "95:     switch(errorcode)",
          "96:       {",
          "97:       case        LIBRAW_SUCCESS:",
          "98:         return \"No error\";",
          "99:       case        LIBRAW_UNSPECIFIED_ERROR:",
          "100:         return \"Unspecified error\";",
          "101:       case        LIBRAW_FILE_UNSUPPORTED:",
          "102:         return \"Unsupported file format or not RAW file\";",
          "103:       case        LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE:",
          "104:         return \"Request for nonexisting image number\";",
          "105:       case        LIBRAW_OUT_OF_ORDER_CALL:",
          "106:         return \"Out of order call of libraw function\";",
          "107:       case    LIBRAW_NO_THUMBNAIL:",
          "108:         return \"No thumbnail in file\";",
          "109:       case    LIBRAW_UNSUPPORTED_THUMBNAIL:",
          "110:         return \"Unsupported thumbnail format\";",
          "111:       case LIBRAW_INPUT_CLOSED:",
          "112:         return \"No input stream, or input stream closed\";",
          "113:       case    LIBRAW_UNSUFFICIENT_MEMORY:",
          "114:         return \"Unsufficient memory\";",
          "115:       case    LIBRAW_DATA_ERROR:",
          "116:         return \"Corrupted data or unexpected EOF\";",
          "117:       case    LIBRAW_IO_ERROR:",
          "118:         return \"Input/output error\";",
          "119:       case LIBRAW_CANCELLED_BY_CALLBACK:",
          "120:         return \"Cancelled by user callback\";",
          "121:       case LIBRAW_BAD_CROP:",
          "122:         return \"Bad crop box\";",
          "123:       default:",
          "124:         return \"Unknown error code\";",
          "125:       }",
          "132: #define Sigma_X3F   22",
          "134: const double LibRaw_constants::xyz_rgb[3][3] =",
          "135: {",
          "136:     { 0.412453, 0.357580, 0.180423 },",
          "137:     { 0.212671, 0.715160, 0.072169 },",
          "138:     { 0.019334, 0.119193, 0.950227 }",
          "139: };",
          "141: const float LibRaw_constants::d65_white[3] =  { 0.950456f, 1.0f, 1.088754f };",
          "",
          "[Added Lines]",
          "76: extern \"C\" {",
          "78: void default_memory_callback(void *, const char *file, const char *where)",
          "79: {",
          "80:   fprintf(stderr, \"%s: Out of memory in %s\\n\", file ? file : \"unknown file\", where);",
          "81: }",
          "83: void default_data_callback(void *, const char *file, const int offset)",
          "84: {",
          "85:   if (offset < 0)",
          "86:     fprintf(stderr, \"%s: Unexpected end of file\\n\", file ? file : \"unknown file\");",
          "87:   else",
          "88:     fprintf(stderr, \"%s: data corrupted at %d\\n\", file ? file : \"unknown file\", offset);",
          "89: }",
          "90: const char *libraw_strerror(int e)",
          "91: {",
          "92:   enum LibRaw_errors errorcode = (LibRaw_errors)e;",
          "93:   switch (errorcode)",
          "95:   case LIBRAW_SUCCESS:",
          "96:     return \"No error\";",
          "97:   case LIBRAW_UNSPECIFIED_ERROR:",
          "98:     return \"Unspecified error\";",
          "99:   case LIBRAW_FILE_UNSUPPORTED:",
          "100:     return \"Unsupported file format or not RAW file\";",
          "101:   case LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE:",
          "102:     return \"Request for nonexisting image number\";",
          "103:   case LIBRAW_OUT_OF_ORDER_CALL:",
          "104:     return \"Out of order call of libraw function\";",
          "105:   case LIBRAW_NO_THUMBNAIL:",
          "106:     return \"No thumbnail in file\";",
          "107:   case LIBRAW_UNSUPPORTED_THUMBNAIL:",
          "108:     return \"Unsupported thumbnail format\";",
          "109:   case LIBRAW_INPUT_CLOSED:",
          "110:     return \"No input stream, or input stream closed\";",
          "111:   case LIBRAW_UNSUFFICIENT_MEMORY:",
          "112:     return \"Unsufficient memory\";",
          "113:   case LIBRAW_DATA_ERROR:",
          "114:     return \"Corrupted data or unexpected EOF\";",
          "115:   case LIBRAW_IO_ERROR:",
          "116:     return \"Input/output error\";",
          "117:   case LIBRAW_CANCELLED_BY_CALLBACK:",
          "118:     return \"Cancelled by user callback\";",
          "119:   case LIBRAW_BAD_CROP:",
          "120:     return \"Bad crop box\";",
          "121:   default:",
          "122:     return \"Unknown error code\";",
          "124: }",
          "130: #define Sigma_X3F 22",
          "132: const double LibRaw_constants::xyz_rgb[3][3] = {",
          "133:     {0.412453, 0.357580, 0.180423}, {0.212671, 0.715160, 0.072169}, {0.019334, 0.119193, 0.950227}};",
          "135: const float LibRaw_constants::d65_white[3] = {0.950456f, 1.0f, 1.088754f};",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "148: #define IO libraw_internal_data.internal_output_params",
          "149: #define ID libraw_internal_data.internal_data",
          "181: int LibRaw::versionNumber() { return LIBRAW_VERSION; }",
          "184: unsigned LibRaw::capabilities()",
          "185: {",
          "187: #ifdef USE_RAWSPEED",
          "189: #endif",
          "190: #ifdef USE_DNGSDK",
          "192: #endif",
          "193: #ifdef LIBRAW_DEMOSAIC_PACK_GPL2",
          "195: #endif",
          "196: #ifdef LIBRAW_DEMOSAIC_PACK_GPL3",
          "198: #endif",
          "200: }",
          "203: {",
          "205:   unsigned index = 0;",
          "243:     }",
          "244:   return index;",
          "245: }",
          "247: void LibRaw::derror()",
          "248: {",
          "249:   if (!libraw_internal_data.unpacker_data.data_error && libraw_internal_data.internal_data.input)",
          "250:     {",
          "264:     }",
          "265:   libraw_internal_data.unpacker_data.data_error++;",
          "266: }",
          "269: {",
          "271: }",
          "283: }",
          "286: #ifdef USE_RAWSPEED",
          "287: using namespace RawSpeed;",
          "288: class CameraMetaDataLR : public CameraMetaData",
          "289: {",
          "290: public:",
          "291:   CameraMetaDataLR() : CameraMetaData() {}",
          "293:   CameraMetaDataLR(char *data, int sz);",
          "294: };",
          "297:   ctxt = xmlNewParserCtxt();",
          "299:     ThrowCME(\"CameraMetaData:Could not initialize context.\");",
          "300:   }",
          "302:   xmlResetLastError();",
          "306:     ThrowCME(\"CameraMetaData: XML Document could not be parsed successfully. Error was: %s\", ctxt->lastError.message);",
          "307:   }",
          "313:       ThrowCME(\"CameraMetaData: XML file does not validate. DTD Error was: %s\", ctxt->lastError.message);",
          "314:     }",
          "315:   }",
          "317:   xmlNodePtr cur;",
          "318:   cur = xmlDocGetRootElement(doc);",
          "320:     ThrowCME(\"CameraMetaData: XML document of the wrong type, root node is not cameras.\");",
          "321:     return;",
          "322:   }",
          "324:   cur = cur->xmlChildrenNode;",
          "327:       Camera *camera = new Camera(doc, cur);",
          "328:       addCamera(camera);",
          "332:         addCamera(new Camera(camera, i));",
          "333:       }",
          "334:     }",
          "",
          "[Removed Lines]",
          "151: #define EXCEPTION_HANDLER(e) do{                        \\",
          "153:     switch(e)                                           \\",
          "154:       {                                                 \\",
          "155:       case LIBRAW_EXCEPTION_ALLOC:                      \\",
          "156:         recycle();                                      \\",
          "157:         return LIBRAW_UNSUFFICIENT_MEMORY;              \\",
          "158:       case LIBRAW_EXCEPTION_DECODE_RAW:                 \\",
          "159:       case LIBRAW_EXCEPTION_DECODE_JPEG:                \\",
          "160:         recycle();                                      \\",
          "161:         return LIBRAW_DATA_ERROR;                       \\",
          "162:       case LIBRAW_EXCEPTION_DECODE_JPEG2000:            \\",
          "163:         recycle();                                      \\",
          "164:         return LIBRAW_DATA_ERROR;                       \\",
          "165:       case LIBRAW_EXCEPTION_IO_EOF:                     \\",
          "166:       case LIBRAW_EXCEPTION_IO_CORRUPT:                 \\",
          "167:         recycle();                                      \\",
          "168:         return LIBRAW_IO_ERROR;                                 \\",
          "169:       case LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK:              \\",
          "170:         recycle();                                              \\",
          "171:         return LIBRAW_CANCELLED_BY_CALLBACK;                    \\",
          "172:       case LIBRAW_EXCEPTION_BAD_CROP:                           \\",
          "173:         recycle();                                              \\",
          "174:         return LIBRAW_BAD_CROP;                                 \\",
          "175:       default:                                                  \\",
          "176:         return LIBRAW_UNSPECIFIED_ERROR;                        \\",
          "177:       }                                                         \\",
          "178:   }while(0)",
          "180: const char* LibRaw::version() { return LIBRAW_VERSION_STR;}",
          "182: const char* LibRaw::strerror(int p) { return libraw_strerror(p);}",
          "186:  unsigned ret = 0;",
          "188:  ret |= LIBRAW_CAPS_RAWSPEED;",
          "191:  ret |= LIBRAW_CAPS_DNGSDK;",
          "194:  ret |= LIBRAW_CAPS_DEMOSAICSGPL2;",
          "197:  ret |= LIBRAW_CAPS_DEMOSAICSGPL3;",
          "199:  return ret;",
          "202: unsigned LibRaw:: parse_custom_cameras(unsigned limit, libraw_custom_camera_t table[], char** list)",
          "204:   if(!list) return 0;",
          "206:   for(int i=0; i< limit; i++)",
          "207:     {",
          "208:       if(!list[i]) break;",
          "209:       if(strlen(list[i])<10) continue;",
          "210:       char *string =  (char*)malloc(strlen(list[i])+1);",
          "211:    strcpy(string,list[i]);",
          "212:       char *start = string;",
          "213:       memset(&table[index],0,sizeof(table[0]));",
          "214:       for(int j = 0; start && j < 14; j++)",
          "215:  {",
          "216:    char *end = strchr(start,',');",
          "217:    if(end) { *end = 0; end++; } // move to next char",
          "218:    while(isspace(*start) && *start) start++; // skip leading spaces?",
          "219:    unsigned val = strtol(start,0,10);",
          "220:    switch(j)",
          "221:      {",
          "222:      case 0:  table[index].fsize = val; break;",
          "223:      case 1:  table[index].rw = val;    break;",
          "224:      case 2:  table[index].rh = val;    break;",
          "225:      case 3:  table[index].lm = val;    break;",
          "226:      case 4:  table[index].tm = val;    break;",
          "227:      case 5:  table[index].rm = val;    break;",
          "228:      case 6:  table[index].bm = val;    break;",
          "229:      case 7:  table[index].lf = val;    break;",
          "230:      case 8:  table[index].cf = val;    break;",
          "231:      case 9:  table[index].max = val;    break;",
          "232:      case 10:  table[index].flags = val;    break;",
          "233:      case 11: strncpy(table[index].t_make,start,sizeof(table[index].t_make)-1);    break;",
          "234:      case 12: strncpy(table[index].t_model,start,sizeof(table[index].t_model)-1);    break;",
          "235:      case 13:  table[index].offset = val;    break;",
          "236:      default: break;",
          "237:      }",
          "238:    start = end;",
          "239:  }",
          "240:       free(string);",
          "241:       if(table[index].t_make[0])",
          "242:    index++;",
          "251:       if (libraw_internal_data.internal_data.input->eof())",
          "252:         {",
          "253:           if(callbacks.data_cb)(*callbacks.data_cb)(callbacks.datacb_data,",
          "254:                                                     libraw_internal_data.internal_data.input->fname(),-1);",
          "255:           throw LIBRAW_EXCEPTION_IO_EOF;",
          "256:         }",
          "257:       else",
          "258:         {",
          "259:           if(callbacks.data_cb)(*callbacks.data_cb)(callbacks.datacb_data,",
          "260:                                                     libraw_internal_data.internal_data.input->fname(),",
          "261:                                                     libraw_internal_data.internal_data.input->tell());",
          "263:         }",
          "268: void LibRaw::dcraw_clear_mem(libraw_processed_image_t* p)",
          "270:     if(p) ::free(p);",
          "273: int LibRaw::is_sraw() { return load_raw == &LibRaw::canon_sraw_load_raw || load_raw == &LibRaw::nikon_load_sraw ; }",
          "274: int LibRaw::is_coolscan_nef() { return load_raw == &LibRaw::nikon_coolscan_load_raw;}",
          "276: int LibRaw::is_nikon_sraw(){",
          "277:   return load_raw == &LibRaw::nikon_load_sraw;",
          "278: }",
          "279: int LibRaw::sraw_midpoint() {",
          "280:   if (load_raw == &LibRaw::canon_sraw_load_raw) return 8192;",
          "281:   else if (load_raw == &LibRaw::nikon_load_sraw) return 2048;",
          "282:   else return 0;",
          "292:   CameraMetaDataLR(char *filename) : CameraMetaData(filename){}",
          "296: CameraMetaDataLR::CameraMetaDataLR(char *data, int sz) : CameraMetaData() {",
          "298:   if (ctxt == NULL) {",
          "303:   doc = xmlCtxtReadMemory(ctxt, data,sz, \"\", NULL, XML_PARSE_DTDVALID);",
          "305:   if (doc == NULL) {",
          "309:   if (ctxt->valid == 0) {",
          "310:     if (ctxt->lastError.code == 0x5e) {",
          "312:     } else {",
          "319:   if (xmlStrcmp(cur->name, (const xmlChar *) \"Cameras\")) {",
          "325:   while (cur != NULL) {",
          "326:     if ((!xmlStrcmp(cur->name, (const xmlChar *)\"Camera\"))) {",
          "331:       for (unsigned int i = 0; i < camera->aliases.size(); i++) {",
          "",
          "[Added Lines]",
          "145: #define EXCEPTION_HANDLER(e)                                                                                           \\",
          "146:   do                                                                                                                   \\",
          "147:   {                                                                                                                    \\",
          "149:     switch (e)                                                                                                         \\",
          "150:     {                                                                                                                  \\",
          "151:     case LIBRAW_EXCEPTION_ALLOC:                                                                                       \\",
          "152:       recycle();                                                                                                       \\",
          "153:       return LIBRAW_UNSUFFICIENT_MEMORY;                                                                               \\",
          "154:     case LIBRAW_EXCEPTION_DECODE_RAW:                                                                                  \\",
          "155:     case LIBRAW_EXCEPTION_DECODE_JPEG:                                                                                 \\",
          "156:       recycle();                                                                                                       \\",
          "157:       return LIBRAW_DATA_ERROR;                                                                                        \\",
          "158:     case LIBRAW_EXCEPTION_DECODE_JPEG2000:                                                                             \\",
          "159:       recycle();                                                                                                       \\",
          "160:       return LIBRAW_DATA_ERROR;                                                                                        \\",
          "161:     case LIBRAW_EXCEPTION_IO_EOF:                                                                                      \\",
          "162:     case LIBRAW_EXCEPTION_IO_CORRUPT:                                                                                  \\",
          "163:       recycle();                                                                                                       \\",
          "164:       return LIBRAW_IO_ERROR;                                                                                          \\",
          "165:     case LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK:                                                                       \\",
          "166:       recycle();                                                                                                       \\",
          "167:       return LIBRAW_CANCELLED_BY_CALLBACK;                                                                             \\",
          "168:     case LIBRAW_EXCEPTION_BAD_CROP:                                                                                    \\",
          "169:       recycle();                                                                                                       \\",
          "170:       return LIBRAW_BAD_CROP;                                                                                          \\",
          "171:     default:                                                                                                           \\",
          "172:       return LIBRAW_UNSPECIFIED_ERROR;                                                                                 \\",
          "173:     }                                                                                                                  \\",
          "174:   } while (0)",
          "176: const char *LibRaw::version() { return LIBRAW_VERSION_STR; }",
          "178: const char *LibRaw::strerror(int p) { return libraw_strerror(p); }",
          "182:   unsigned ret = 0;",
          "184:   ret |= LIBRAW_CAPS_RAWSPEED;",
          "187:   ret |= LIBRAW_CAPS_DNGSDK;",
          "190:   ret |= LIBRAW_CAPS_DEMOSAICSGPL2;",
          "193:   ret |= LIBRAW_CAPS_DEMOSAICSGPL3;",
          "195:   return ret;",
          "198: unsigned LibRaw::parse_custom_cameras(unsigned limit, libraw_custom_camera_t table[], char **list)",
          "200:   if (!list)",
          "201:     return 0;",
          "203:   for (int i = 0; i < limit; i++)",
          "204:   {",
          "205:     if (!list[i])",
          "206:       break;",
          "207:     if (strlen(list[i]) < 10)",
          "208:       continue;",
          "209:     char *string = (char *)malloc(strlen(list[i]) + 1);",
          "210:     strcpy(string, list[i]);",
          "211:     char *start = string;",
          "212:     memset(&table[index], 0, sizeof(table[0]));",
          "213:     for (int j = 0; start && j < 14; j++)",
          "214:     {",
          "215:       char *end = strchr(start, ',');",
          "216:       if (end)",
          "217:       {",
          "219:         end++;",
          "220:       } // move to next char",
          "221:       while (isspace(*start) && *start)",
          "222:         start++; // skip leading spaces?",
          "223:       unsigned val = strtol(start, 0, 10);",
          "224:       switch (j)",
          "225:       {",
          "226:       case 0:",
          "227:         table[index].fsize = val;",
          "228:         break;",
          "229:       case 1:",
          "230:         table[index].rw = val;",
          "231:         break;",
          "232:       case 2:",
          "233:         table[index].rh = val;",
          "234:         break;",
          "235:       case 3:",
          "236:         table[index].lm = val;",
          "237:         break;",
          "238:       case 4:",
          "239:         table[index].tm = val;",
          "240:         break;",
          "241:       case 5:",
          "242:         table[index].rm = val;",
          "243:         break;",
          "244:       case 6:",
          "245:         table[index].bm = val;",
          "246:         break;",
          "247:       case 7:",
          "248:         table[index].lf = val;",
          "249:         break;",
          "250:       case 8:",
          "251:         table[index].cf = val;",
          "252:         break;",
          "253:       case 9:",
          "254:         table[index].max = val;",
          "255:         break;",
          "256:       case 10:",
          "257:         table[index].flags = val;",
          "258:         break;",
          "259:       case 11:",
          "260:         strncpy(table[index].t_make, start, sizeof(table[index].t_make) - 1);",
          "261:         break;",
          "262:       case 12:",
          "263:         strncpy(table[index].t_model, start, sizeof(table[index].t_model) - 1);",
          "264:         break;",
          "265:       case 13:",
          "266:         table[index].offset = val;",
          "267:         break;",
          "268:       default:",
          "269:         break;",
          "270:       }",
          "271:       start = end;",
          "273:     free(string);",
          "274:     if (table[index].t_make[0])",
          "275:       index++;",
          "276:   }",
          "283:   {",
          "284:     if (libraw_internal_data.internal_data.input->eof())",
          "286:       if (callbacks.data_cb)",
          "287:         (*callbacks.data_cb)(callbacks.datacb_data, libraw_internal_data.internal_data.input->fname(), -1);",
          "288:       throw LIBRAW_EXCEPTION_IO_EOF;",
          "289:     }",
          "290:     else",
          "291:     {",
          "292:       if (callbacks.data_cb)",
          "293:         (*callbacks.data_cb)(callbacks.datacb_data, libraw_internal_data.internal_data.input->fname(),",
          "294:                              libraw_internal_data.internal_data.input->tell());",
          "297:   }",
          "301: void LibRaw::dcraw_clear_mem(libraw_processed_image_t *p)",
          "303:   if (p)",
          "304:     ::free(p);",
          "307: int LibRaw::is_sraw() { return load_raw == &LibRaw::canon_sraw_load_raw || load_raw == &LibRaw::nikon_load_sraw; }",
          "308: int LibRaw::is_coolscan_nef() { return load_raw == &LibRaw::nikon_coolscan_load_raw; }",
          "310: int LibRaw::is_nikon_sraw() { return load_raw == &LibRaw::nikon_load_sraw; }",
          "311: int LibRaw::sraw_midpoint()",
          "312: {",
          "313:   if (load_raw == &LibRaw::canon_sraw_load_raw)",
          "314:     return 8192;",
          "315:   else if (load_raw == &LibRaw::nikon_load_sraw)",
          "316:     return 2048;",
          "317:   else",
          "318:     return 0;",
          "327:   CameraMetaDataLR(char *filename) : CameraMetaData(filename) {}",
          "331: CameraMetaDataLR::CameraMetaDataLR(char *data, int sz) : CameraMetaData()",
          "332: {",
          "334:   if (ctxt == NULL)",
          "335:   {",
          "340:   doc = xmlCtxtReadMemory(ctxt, data, sz, \"\", NULL, XML_PARSE_DTDVALID);",
          "342:   if (doc == NULL)",
          "343:   {",
          "347:   if (ctxt->valid == 0)",
          "348:   {",
          "349:     if (ctxt->lastError.code == 0x5e)",
          "350:     {",
          "352:     }",
          "353:     else",
          "354:     {",
          "361:   if (xmlStrcmp(cur->name, (const xmlChar *)\"Cameras\"))",
          "362:   {",
          "368:   while (cur != NULL)",
          "369:   {",
          "370:     if ((!xmlStrcmp(cur->name, (const xmlChar *)\"Camera\")))",
          "371:     {",
          "376:       for (unsigned int i = 0; i < camera->aliases.size(); i++)",
          "377:       {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "342:   ctxt = 0;",
          "343: }",
          "347: {",
          "356:   int offt = 0;",
          "371:   }",
          "372:   free(rawspeed_xml);",
          "",
          "[Removed Lines]",
          "345: #define RAWSPEED_DATA_COUNT (sizeof(_rawspeed_data_xml)/sizeof(_rawspeed_data_xml[0]))",
          "346: static CameraMetaDataLR* make_camera_metadata()",
          "348:   int len = 0,i;",
          "349:   for(i=0;i<RAWSPEED_DATA_COUNT;i++)",
          "350:     if(_rawspeed_data_xml[i])",
          "351:       {",
          "352:         len+=strlen(_rawspeed_data_xml[i]);",
          "353:       }",
          "354:   char *rawspeed_xml = (char*)calloc(len+1,sizeof(_rawspeed_data_xml[0][0]));",
          "355:   if(!rawspeed_xml) return NULL;",
          "357:   for(i=0;i<RAWSPEED_DATA_COUNT;i++)",
          "358:     if(_rawspeed_data_xml[i])",
          "359:       {",
          "360:         int ll = strlen(_rawspeed_data_xml[i]);",
          "361:         if(offt+ll>len) break;",
          "362:         memmove(rawspeed_xml+offt,_rawspeed_data_xml[i],ll);",
          "363:         offt+=ll;",
          "364:       }",
          "365:   rawspeed_xml[offt]=0;",
          "366:   CameraMetaDataLR *ret=NULL;",
          "367:   try {",
          "368:     ret = new CameraMetaDataLR(rawspeed_xml,offt);",
          "369:   } catch (...) {",
          "",
          "[Added Lines]",
          "391: #define RAWSPEED_DATA_COUNT (sizeof(_rawspeed_data_xml) / sizeof(_rawspeed_data_xml[0]))",
          "392: static CameraMetaDataLR *make_camera_metadata()",
          "394:   int len = 0, i;",
          "395:   for (i = 0; i < RAWSPEED_DATA_COUNT; i++)",
          "396:     if (_rawspeed_data_xml[i])",
          "397:     {",
          "398:       len += strlen(_rawspeed_data_xml[i]);",
          "399:     }",
          "400:   char *rawspeed_xml = (char *)calloc(len + 1, sizeof(_rawspeed_data_xml[0][0]));",
          "401:   if (!rawspeed_xml)",
          "402:     return NULL;",
          "404:   for (i = 0; i < RAWSPEED_DATA_COUNT; i++)",
          "405:     if (_rawspeed_data_xml[i])",
          "406:     {",
          "407:       int ll = strlen(_rawspeed_data_xml[i]);",
          "408:       if (offt + ll > len)",
          "409:         break;",
          "410:       memmove(rawspeed_xml + offt, _rawspeed_data_xml[i], ll);",
          "411:       offt += ll;",
          "412:     }",
          "413:   rawspeed_xml[offt] = 0;",
          "414:   CameraMetaDataLR *ret = NULL;",
          "415:   try",
          "416:   {",
          "417:     ret = new CameraMetaDataLR(rawspeed_xml, offt);",
          "418:   }",
          "419:   catch (...)",
          "420:   {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "376: #endif",
          "381: {",
          "386: }",
          "389: {",
          "394: #ifdef DCRAW_VERBOSE",
          "395:   verbose = 1;",
          "396: #else",
          "",
          "[Removed Lines]",
          "378: #define ZERO(a) memset(&a,0,sizeof(a))",
          "380: static void cleargps(libraw_gps_info_t*q)",
          "382:  for (int i = 0; i < 3; i++)",
          "383:   q->latitude[i] = q->longtitude[i] = q->gpstimestamp[i] = 0.f;",
          "384:  q->altitude = 0.f;",
          "385:  q->altref = q->latref = q->longref = q->gpsstatus = q->gpsparsed = 0;",
          "388: LibRaw:: LibRaw(unsigned int flags)",
          "390:   double aber[4] = {1,1,1,1};",
          "391:   double gamm[6] = { 0.45,4.5,0,0,0,0 };",
          "392:   unsigned greybox[4] =  { 0, 0, UINT_MAX, UINT_MAX };",
          "393:   unsigned cropbox[4] =  { 0, 0, UINT_MAX, UINT_MAX };",
          "",
          "[Added Lines]",
          "429: #define ZERO(a) memset(&a, 0, sizeof(a))",
          "431: static void cleargps(libraw_gps_info_t *q)",
          "433:   for (int i = 0; i < 3; i++)",
          "434:     q->latitude[i] = q->longtitude[i] = q->gpstimestamp[i] = 0.f;",
          "435:   q->altitude = 0.f;",
          "436:   q->altref = q->latref = q->longref = q->gpsstatus = q->gpsparsed = 0;",
          "439: LibRaw::LibRaw(unsigned int flags)",
          "441:   double aber[4] = {1, 1, 1, 1};",
          "442:   double gamm[6] = {0.45, 4.5, 0, 0, 0, 0};",
          "443:   unsigned greybox[4] = {0, 0, UINT_MAX, UINT_MAX};",
          "444:   unsigned cropbox[4] = {0, 0, UINT_MAX, UINT_MAX};",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "403:   ZERO(callbacks);",
          "405:   _rawspeed_camerameta = _rawspeed_decoder = NULL;",
          "407:   _x3f_data = NULL;",
          "409: #ifdef USE_RAWSPEED",
          "410:   CameraMetaDataLR *camerameta = make_camera_metadata(); // May be NULL in case of exception in make_camera_metadata()",
          "412: #endif",
          "415:   callbacks.exif_cb = NULL; // no default callback",
          "431:   imgdata.params.exp_shift = 1.0;",
          "432:   imgdata.params.auto_bright_thr = LIBRAW_DEFAULT_AUTO_BRIGHTNESS_THRESHOLD;",
          "434:   imgdata.params.use_rawspeed = 1;",
          "435:   imgdata.params.use_dngsdk = LIBRAW_DNG_DEFAULT;",
          "436:   imgdata.params.no_auto_scale = 0;",
          "437:   imgdata.params.no_interpolation = 0;",
          "439:   imgdata.params.sony_arw2_posterization_thr = 0;",
          "440:   imgdata.params.green_matching = 0;",
          "442:   imgdata.params.coolscan_nef_gamma = 1.0f;",
          "443:   imgdata.parent_class = this;",
          "444:   imgdata.progress_flags = 0;",
          "",
          "[Removed Lines]",
          "406:   dnghost =  NULL;",
          "411:   _rawspeed_camerameta = static_cast<void*>(camerameta);",
          "413:   callbacks.mem_cb = (flags & LIBRAW_OPIONS_NO_MEMERR_CALLBACK) ? NULL:  &default_memory_callback;",
          "414:   callbacks.data_cb = (flags & LIBRAW_OPIONS_NO_DATAERR_CALLBACK)? NULL : &default_data_callback;",
          "416:   memmove(&imgdata.params.aber,&aber,sizeof(aber));",
          "417:   memmove(&imgdata.params.gamm,&gamm,sizeof(gamm));",
          "418:   memmove(&imgdata.params.greybox,&greybox,sizeof(greybox));",
          "419:   memmove(&imgdata.params.cropbox,&cropbox,sizeof(cropbox));",
          "421:   imgdata.params.bright=1;",
          "422:   imgdata.params.use_camera_matrix=1;",
          "423:   imgdata.params.user_flip=-1;",
          "424:   imgdata.params.user_black=-1;",
          "425:   imgdata.params.user_cblack[0]=imgdata.params.user_cblack[1]=imgdata.params.user_cblack[2]=imgdata.params.user_cblack[3]=-1000001;",
          "426:   imgdata.params.user_sat=-1;",
          "427:   imgdata.params.user_qual=-1;",
          "428:   imgdata.params.output_color=1;",
          "429:   imgdata.params.output_bps=8;",
          "430:   imgdata.params.use_fuji_rotate=1;",
          "433:   imgdata.params.adjust_maximum_thr= LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD;",
          "438:   imgdata.params.raw_processing_options = LIBRAW_PROCESSING_DP2Q_INTERPOLATERG|LIBRAW_PROCESSING_DP2Q_INTERPOLATEAF | LIBRAW_PROCESSING_CONVERTFLOAT_TO_INT;",
          "441:   imgdata.params.custom_camera_strings=0;",
          "",
          "[Added Lines]",
          "457:   dnghost = NULL;",
          "462:   _rawspeed_camerameta = static_cast<void *>(camerameta);",
          "464:   callbacks.mem_cb = (flags & LIBRAW_OPIONS_NO_MEMERR_CALLBACK) ? NULL : &default_memory_callback;",
          "465:   callbacks.data_cb = (flags & LIBRAW_OPIONS_NO_DATAERR_CALLBACK) ? NULL : &default_data_callback;",
          "467:   memmove(&imgdata.params.aber, &aber, sizeof(aber));",
          "468:   memmove(&imgdata.params.gamm, &gamm, sizeof(gamm));",
          "469:   memmove(&imgdata.params.greybox, &greybox, sizeof(greybox));",
          "470:   memmove(&imgdata.params.cropbox, &cropbox, sizeof(cropbox));",
          "472:   imgdata.params.bright = 1;",
          "473:   imgdata.params.use_camera_matrix = 1;",
          "474:   imgdata.params.user_flip = -1;",
          "475:   imgdata.params.user_black = -1;",
          "476:   imgdata.params.user_cblack[0] = imgdata.params.user_cblack[1] = imgdata.params.user_cblack[2] =",
          "477:       imgdata.params.user_cblack[3] = -1000001;",
          "478:   imgdata.params.user_sat = -1;",
          "479:   imgdata.params.user_qual = -1;",
          "480:   imgdata.params.output_color = 1;",
          "481:   imgdata.params.output_bps = 8;",
          "482:   imgdata.params.use_fuji_rotate = 1;",
          "485:   imgdata.params.adjust_maximum_thr = LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD;",
          "490:   imgdata.params.raw_processing_options = LIBRAW_PROCESSING_DP2Q_INTERPOLATERG | LIBRAW_PROCESSING_DP2Q_INTERPOLATEAF |",
          "491:                                           LIBRAW_PROCESSING_CONVERTFLOAT_TO_INT;",
          "494:   imgdata.params.custom_camera_strings = 0;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "455: {",
          "456: #ifdef USE_RAWSPEED",
          "457:   try",
          "458:     {",
          "466:     }",
          "467:   catch (...)",
          "472: #endif",
          "473:   return 0;",
          "474: }",
          "",
          "[Removed Lines]",
          "459:       CameraMetaDataLR *camerameta = new CameraMetaDataLR(filename);",
          "460:       if(_rawspeed_camerameta)",
          "461:         {",
          "462:           CameraMetaDataLR *d = static_cast<CameraMetaDataLR*>(_rawspeed_camerameta);",
          "463:           delete d;",
          "464:         }",
          "465:       _rawspeed_camerameta = static_cast<void*>(camerameta);",
          "468:     {",
          "470:       return -1;",
          "471:     }",
          "",
          "[Added Lines]",
          "511:   {",
          "512:     CameraMetaDataLR *camerameta = new CameraMetaDataLR(filename);",
          "513:     if (_rawspeed_camerameta)",
          "515:       CameraMetaDataLR *d = static_cast<CameraMetaDataLR *>(_rawspeed_camerameta);",
          "516:       delete d;",
          "518:     _rawspeed_camerameta = static_cast<void *>(camerameta);",
          "519:   }",
          "521:   {",
          "523:     return -1;",
          "524:   }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "478:   recycle();",
          "479:   delete tls;",
          "480: #ifdef USE_RAWSPEED",
          "487: #endif",
          "488: }",
          "491: {",
          "496: }",
          "498: {",
          "503: }",
          "507: {",
          "516: }",
          "519: {",
          "525:   libraw_internal_data.internal_data.input_internal = 0;",
          "526: }",
          "532: {",
          "533:   recycle_datastream();",
          "536:   FREE(imgdata.image);",
          "537:   FREE(imgdata.thumbnail.thumb);",
          "",
          "[Removed Lines]",
          "481:   if(_rawspeed_camerameta)",
          "482:     {",
          "483:       CameraMetaDataLR *cmeta = static_cast<CameraMetaDataLR*>(_rawspeed_camerameta);",
          "484:       delete cmeta;",
          "485:       _rawspeed_camerameta = NULL;",
          "486:     }",
          "490: void* LibRaw:: malloc(size_t t)",
          "492:     void *p = memmgr.malloc(t);",
          "493:  if(!p)",
          "494:   throw LIBRAW_EXCEPTION_ALLOC;",
          "495:     return p;",
          "497: void* LibRaw:: realloc(void *q,size_t t)",
          "499:     void *p = memmgr.realloc(q,t);",
          "500:  if(!p)",
          "501:   throw LIBRAW_EXCEPTION_ALLOC;",
          "502:     return p;",
          "506: void* LibRaw::       calloc(size_t n,size_t t)",
          "508:     void *p = memmgr.calloc(n,t);",
          "509:  if(!p)",
          "510:   throw LIBRAW_EXCEPTION_ALLOC;",
          "511:     return p;",
          "512: }",
          "513: void  LibRaw::      free(void *p)",
          "514: {",
          "515:     memmgr.free(p);",
          "518: void LibRaw:: recycle_datastream()",
          "520:   if(libraw_internal_data.internal_data.input && libraw_internal_data.internal_data.input_internal)",
          "521:     {",
          "522:       delete libraw_internal_data.internal_data.input;",
          "523:       libraw_internal_data.internal_data.input = NULL;",
          "524:     }",
          "528: void x3f_clear(void*);",
          "531: void LibRaw:: recycle()",
          "534: #define FREE(a) do { if(a) { free(a); a = NULL;} }while(0)",
          "",
          "[Added Lines]",
          "534:   if (_rawspeed_camerameta)",
          "535:   {",
          "536:     CameraMetaDataLR *cmeta = static_cast<CameraMetaDataLR *>(_rawspeed_camerameta);",
          "537:     delete cmeta;",
          "538:     _rawspeed_camerameta = NULL;",
          "539:   }",
          "543: void *LibRaw::malloc(size_t t)",
          "545:   void *p = memmgr.malloc(t);",
          "546:   if (!p)",
          "547:     throw LIBRAW_EXCEPTION_ALLOC;",
          "548:   return p;",
          "550: void *LibRaw::realloc(void *q, size_t t)",
          "552:   void *p = memmgr.realloc(q, t);",
          "553:   if (!p)",
          "554:     throw LIBRAW_EXCEPTION_ALLOC;",
          "555:   return p;",
          "558: void *LibRaw::calloc(size_t n, size_t t)",
          "560:   void *p = memmgr.calloc(n, t);",
          "561:   if (!p)",
          "562:     throw LIBRAW_EXCEPTION_ALLOC;",
          "563:   return p;",
          "565: void LibRaw::free(void *p) { memmgr.free(p); }",
          "567: void LibRaw::recycle_datastream()",
          "569:   if (libraw_internal_data.internal_data.input && libraw_internal_data.internal_data.input_internal)",
          "570:   {",
          "571:     delete libraw_internal_data.internal_data.input;",
          "572:     libraw_internal_data.internal_data.input = NULL;",
          "573:   }",
          "577: void x3f_clear(void *);",
          "579: void LibRaw::recycle()",
          "582: #define FREE(a)                                                                                                        \\",
          "583:   do                                                                                                                   \\",
          "584:   {                                                                                                                    \\",
          "585:     if (a)                                                                                                             \\",
          "586:     {                                                                                                                  \\",
          "587:       free(a);                                                                                                         \\",
          "588:       a = NULL;                                                                                                        \\",
          "589:     }                                                                                                                  \\",
          "590:   } while (0)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "564:   imgdata.makernotes.fuji.FocusMode = 0xffff;",
          "565:   imgdata.makernotes.fuji.AFMode = 0xffff;",
          "566:   imgdata.makernotes.fuji.FocusPixel[0] = imgdata.makernotes.fuji.FocusPixel[1] = 0xffff;",
          "569:   imgdata.makernotes.sony.SonyCameraType = 0xffff;",
          "570:   imgdata.color.dng_color[0].illuminant = imgdata.color.dng_color[1].illuminant = 0xffff;",
          "576:   ZERO(libraw_internal_data);",
          "577:   ZERO(imgdata.lens);",
          "",
          "[Removed Lines]",
          "567:   imgdata.makernotes.fuji.ImageStabilization[0] = imgdata.makernotes.fuji.ImageStabilization[1] = imgdata.makernotes.fuji.ImageStabilization[2] = 0xffff;",
          "572:   for(int i = 0; i < 4; i++)",
          "573:    imgdata.color.dng_levels.analogbalance[i]=",
          "574:    imgdata.color.dng_levels.analogbalance[i]=1.0f;",
          "",
          "[Added Lines]",
          "623:   imgdata.makernotes.fuji.ImageStabilization[0] = imgdata.makernotes.fuji.ImageStabilization[1] =",
          "624:       imgdata.makernotes.fuji.ImageStabilization[2] = 0xffff;",
          "629:   for (int i = 0; i < 4; i++)",
          "630:     imgdata.color.dng_levels.analogbalance[i] = imgdata.color.dng_levels.analogbalance[i] = 1.0f;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "588:   _exitflag = 0;",
          "589: #ifdef USE_RAWSPEED",
          "595:   _rawspeed_decoder = 0;",
          "596: #endif",
          "604:   memmgr.cleanup();",
          "605:   imgdata.thumbnail.tformat = LIBRAW_THUMBNAIL_UNKNOWN;",
          "",
          "[Removed Lines]",
          "590:   if(_rawspeed_decoder)",
          "591:     {",
          "592:       RawDecoder *d = static_cast<RawDecoder*>(_rawspeed_decoder);",
          "593:       delete d;",
          "594:     }",
          "598:   if(_x3f_data)",
          "599:     {",
          "600:       x3f_clear(_x3f_data);",
          "601:       _x3f_data = 0;",
          "602:     }",
          "",
          "[Added Lines]",
          "646:   if (_rawspeed_decoder)",
          "647:   {",
          "648:     RawDecoder *d = static_cast<RawDecoder *>(_rawspeed_decoder);",
          "649:     delete d;",
          "650:   }",
          "654:   if (_x3f_data)",
          "655:   {",
          "656:     x3f_clear(_x3f_data);",
          "657:     _x3f_data = 0;",
          "658:   }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "610:   tls->init();",
          "611: }",
          "614: {",
          "615:   libraw_decoder_info_t decoder_info;",
          "616:   get_decoder_info(&decoder_info);",
          "617:   return decoder_info.decoder_name;",
          "618: }",
          "621: {",
          "623:   d_info->decoder_name = 0;",
          "624:   d_info->decoder_flags = 0;",
          "627:   int rawdata = (imgdata.idata.filters || P1.colors == 1);",
          "629:   if (load_raw == &LibRaw::android_tight_load_raw)",
          "630:   {",
          "633:   }",
          "634:   else if (load_raw == &LibRaw::android_loose_load_raw)",
          "635:   {",
          "638:   }",
          "639:   else if (load_raw == &LibRaw::canon_600_load_raw)",
          "644:   else if (load_raw == &LibRaw::xtrans_compressed_load_raw)",
          "645:   {",
          "647:   }",
          "648:   else if (load_raw == &LibRaw::canon_load_raw)",
          "652:   else if (load_raw == &LibRaw::lossless_jpeg_load_raw)",
          "657:   else if (load_raw == &LibRaw::canon_sraw_load_raw)",
          "662:   else if (load_raw == &LibRaw::lossless_dng_load_raw)",
          "667:   else if (load_raw == &LibRaw::packed_dng_load_raw)",
          "677:   else if (load_raw == &LibRaw::nikon_load_raw)",
          "683:   {",
          "686:   }",
          "724:   {",
          "727:   }",
          "890:   {",
          "893:   }",
          "895:   {",
          "898:   }",
          "940: }",
          "944: {",
          "956: int LibRaw::open_file(const char *fname, INT64 max_buf_size)",
          "957: {",
          "958: #ifndef WIN32",
          "959:   struct stat st;",
          "961:     return LIBRAW_IO_ERROR;",
          "963: #else",
          "964:   struct _stati64 st;",
          "966:     return LIBRAW_IO_ERROR;",
          "968: #endif",
          "970:   LibRaw_abstract_datastream *stream;",
          "973:       stream = new LibRaw_bigfile_datastream(fname);",
          "974:     else",
          "975:       stream = new LibRaw_file_datastream(fname);",
          "976:   }",
          "978:   catch (std::bad_alloc)",
          "988:   ID.input_internal = 0; // preserve from deletion on error",
          "989:   int ret = open_datastream(stream);",
          "990:   if (ret == LIBRAW_SUCCESS)",
          "994:   else",
          "999:   return ret;",
          "1000: }",
          "",
          "[Removed Lines]",
          "613: const char * LibRaw::unpack_function_name()",
          "620: int LibRaw::get_decoder_info(libraw_decoder_info_t* d_info)",
          "622:   if(!d_info)   return LIBRAW_UNSPECIFIED_ERROR;",
          "625:   if (!load_raw) return LIBRAW_OUT_OF_ORDER_CALL;",
          "631:    d_info->decoder_name = \"android_tight_load_raw()\";",
          "632:    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;",
          "636:    d_info->decoder_name = \"android_loose_load_raw()\";",
          "637:    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;",
          "640:     {",
          "641:       d_info->decoder_name = \"canon_600_load_raw()\";",
          "642:    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;",
          "643:     }",
          "646:    d_info->decoder_name = \"xtrans_compressed_load_raw()\";",
          "649:     {",
          "650:       d_info->decoder_name = \"canon_load_raw()\";",
          "651:     }",
          "653:     {",
          "654:       d_info->decoder_name = \"lossless_jpeg_load_raw()\";",
          "655:       d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED;",
          "656:     }",
          "658:     {",
          "659:       d_info->decoder_name = \"canon_sraw_load_raw()\";",
          "661:     }",
          "663:     {",
          "664:       d_info->decoder_name = \"lossless_dng_load_raw()\";",
          "665:       d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_ADOBECOPYPIXEL;",
          "666:     }",
          "668:     {",
          "669:       d_info->decoder_name = \"packed_dng_load_raw()\";",
          "670:       d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_ADOBECOPYPIXEL;",
          "671:     }",
          "672:   else if (load_raw == &LibRaw::pentax_load_raw )",
          "673:     {",
          "674:       d_info->decoder_name = \"pentax_load_raw()\";",
          "675:       d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;",
          "676:     }",
          "678:     {",
          "679:       d_info->decoder_name = \"nikon_load_raw()\";",
          "680:       d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;",
          "681:     }",
          "682:   else if (load_raw == &LibRaw::nikon_coolscan_load_raw )",
          "684:    d_info->decoder_name = \"nikon_coolscan_load_raw()\";",
          "685:    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;",
          "687:   else if (load_raw == &LibRaw::nikon_load_sraw )",
          "688:     {",
          "689:       d_info->decoder_name = \"nikon_load_sraw()\";",
          "690:       d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;",
          "691:     }",
          "692:   else if (load_raw == &LibRaw::nikon_yuv_load_raw )",
          "693:     {",
          "694:       d_info->decoder_name = \"nikon_load_yuv_load_raw()\";",
          "695:       d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;",
          "696:     }",
          "697:   else if (load_raw == &LibRaw::rollei_load_raw )",
          "698:     {",
          "700:       d_info->decoder_name = \"rollei_load_raw()\";",
          "701:       d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;",
          "702:     }",
          "703:   else if (load_raw == &LibRaw::phase_one_load_raw )",
          "704:     {",
          "705:       d_info->decoder_name = \"phase_one_load_raw()\";",
          "706:     }",
          "707:   else if (load_raw == &LibRaw::phase_one_load_raw_c )",
          "708:     {",
          "709:       d_info->decoder_name = \"phase_one_load_raw_c()\";",
          "710:     }",
          "711:   else if (load_raw == &LibRaw::hasselblad_load_raw )",
          "712:     {",
          "713:       d_info->decoder_name = \"hasselblad_load_raw()\";",
          "714:     }",
          "715:   else if (load_raw == &LibRaw::leaf_hdr_load_raw )",
          "716:     {",
          "717:       d_info->decoder_name = \"leaf_hdr_load_raw()\";",
          "718:     }",
          "719:   else if (load_raw == &LibRaw::unpacked_load_raw )",
          "720:     {",
          "721:       d_info->decoder_name = \"unpacked_load_raw()\";",
          "722:     }",
          "723:   else if (load_raw == &LibRaw::unpacked_load_raw_reversed )",
          "725:    d_info->decoder_name = \"unpacked_load_raw_reversed()\";",
          "726:    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;",
          "728:   else if (load_raw == &LibRaw::sinar_4shot_load_raw )",
          "729:     {",
          "731:       d_info->decoder_name = \"sinar_4shot_load_raw()\";",
          "732:     }",
          "733:   else if (load_raw == &LibRaw::imacon_full_load_raw )",
          "734:     {",
          "735:       d_info->decoder_name = \"imacon_full_load_raw()\";",
          "736:     }",
          "737:   else if (load_raw == &LibRaw::hasselblad_full_load_raw )",
          "738:     {",
          "739:       d_info->decoder_name = \"hasselblad_full_load_raw()\";",
          "740:     }",
          "741:   else if (load_raw == &LibRaw::packed_load_raw )",
          "742:     {",
          "743:       d_info->decoder_name = \"packed_load_raw()\";",
          "744:       d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;",
          "745:     }",
          "746:   else if (load_raw == &LibRaw::broadcom_load_raw )",
          "747:     {",
          "749:       d_info->decoder_name = \"broadcom_load_raw()\";",
          "750:       d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;",
          "751:     }",
          "752:   else if (load_raw == &LibRaw::nokia_load_raw )",
          "753:     {",
          "755:       d_info->decoder_name = \"nokia_load_raw()\";",
          "756:       d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;",
          "757:     }",
          "758:   else if (load_raw == &LibRaw::canon_rmf_load_raw )",
          "759:     {",
          "761:       d_info->decoder_name = \"canon_rmf_load_raw()\";",
          "762:     }",
          "763:   else if (load_raw == &LibRaw::panasonic_load_raw )",
          "764:     {",
          "765:       d_info->decoder_name = \"panasonic_load_raw()\";",
          "766:       d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;",
          "767:     }",
          "768:   else if (load_raw == &LibRaw::olympus_load_raw )",
          "769:     {",
          "770:       d_info->decoder_name = \"olympus_load_raw()\";",
          "771:       d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;",
          "772:     }",
          "773:   else if (load_raw == &LibRaw::minolta_rd175_load_raw )",
          "774:     {",
          "776:       d_info->decoder_name = \"minolta_rd175_load_raw()\";",
          "777:     }",
          "778:   else if (load_raw == &LibRaw::quicktake_100_load_raw )",
          "779:     {",
          "781:       d_info->decoder_name = \"quicktake_100_load_raw()\";",
          "782:     }",
          "783:   else if (load_raw == &LibRaw::kodak_radc_load_raw )",
          "784:     {",
          "785:       d_info->decoder_name = \"kodak_radc_load_raw()\";",
          "786:     }",
          "787:   else if (load_raw == &LibRaw::kodak_jpeg_load_raw )",
          "788:     {",
          "790:       d_info->decoder_name = \"kodak_jpeg_load_raw()\";",
          "791:     }",
          "792:   else if (load_raw == &LibRaw::lossy_dng_load_raw)",
          "793:     {",
          "795:       d_info->decoder_name = \"lossy_dng_load_raw()\";",
          "796:       d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_HASCURVE;",
          "797:     }",
          "798:   else if (load_raw == &LibRaw::kodak_dc120_load_raw )",
          "799:     {",
          "800:       d_info->decoder_name = \"kodak_dc120_load_raw()\";",
          "801:     }",
          "802:   else if (load_raw == &LibRaw::eight_bit_load_raw )",
          "803:     {",
          "804:       d_info->decoder_name = \"eight_bit_load_raw()\";",
          "805:       d_info->decoder_flags = LIBRAW_DECODER_HASCURVE|LIBRAW_DECODER_FIXEDMAXC;",
          "806:     }",
          "807:   else if (load_raw == &LibRaw::kodak_c330_load_raw )",
          "808:     {",
          "809:       d_info->decoder_name = \"kodak_yrgb_load_raw()\";",
          "810:       d_info->decoder_flags = LIBRAW_DECODER_HASCURVE|LIBRAW_DECODER_FIXEDMAXC;",
          "811:     }",
          "812:   else if (load_raw == &LibRaw::kodak_c603_load_raw )",
          "813:     {",
          "814:       d_info->decoder_name = \"kodak_yrgb_load_raw()\";",
          "815:       d_info->decoder_flags = LIBRAW_DECODER_HASCURVE|LIBRAW_DECODER_FIXEDMAXC;",
          "816:     }",
          "817:   else if (load_raw == &LibRaw::kodak_262_load_raw )",
          "818:     {",
          "819:       d_info->decoder_name = \"kodak_262_load_raw()\"; // UNTESTED!",
          "820:       d_info->decoder_flags = LIBRAW_DECODER_HASCURVE|LIBRAW_DECODER_FIXEDMAXC;",
          "821:     }",
          "822:   else if (load_raw == &LibRaw::kodak_65000_load_raw )",
          "823:     {",
          "824:       d_info->decoder_name = \"kodak_65000_load_raw()\";",
          "825:       d_info->decoder_flags = LIBRAW_DECODER_HASCURVE;",
          "826:     }",
          "827:   else if (load_raw == &LibRaw::kodak_ycbcr_load_raw )",
          "828:     {",
          "830:       d_info->decoder_name = \"kodak_ycbcr_load_raw()\";",
          "831:       d_info->decoder_flags = LIBRAW_DECODER_HASCURVE|LIBRAW_DECODER_FIXEDMAXC;",
          "832:     }",
          "833:   else if (load_raw == &LibRaw::kodak_rgb_load_raw )",
          "834:     {",
          "836:       d_info->decoder_name = \"kodak_rgb_load_raw()\";",
          "837:       d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;",
          "838:     }",
          "839:   else if (load_raw == &LibRaw::sony_load_raw )",
          "840:     {",
          "841:       d_info->decoder_name = \"sony_load_raw()\";",
          "842:     }",
          "843:   else if (load_raw == &LibRaw::sony_arw_load_raw )",
          "844:     {",
          "845:       d_info->decoder_name = \"sony_arw_load_raw()\";",
          "846:       d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;",
          "848:     }",
          "849:   else if (load_raw == &LibRaw::sony_arw2_load_raw )",
          "850:     {",
          "851:       d_info->decoder_name = \"sony_arw2_load_raw()\";",
          "852:       d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_SONYARW2;",
          "853:     }",
          "854:   else if (load_raw == &LibRaw::samsung_load_raw )",
          "855:     {",
          "856:       d_info->decoder_name = \"samsung_load_raw()\";",
          "857:       d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;",
          "858:     }",
          "859:   else if (load_raw == &LibRaw::samsung2_load_raw )",
          "860:     {",
          "861:       d_info->decoder_name = \"samsung2_load_raw()\";",
          "862:     }",
          "863:   else if (load_raw == &LibRaw::samsung3_load_raw )",
          "864:     {",
          "865:       d_info->decoder_name = \"samsung3_load_raw()\";",
          "866:     }",
          "867:   else if (load_raw == &LibRaw::smal_v6_load_raw )",
          "868:     {",
          "870:       d_info->decoder_name = \"smal_v6_load_raw()\";",
          "871:    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;",
          "872:     }",
          "873:   else if (load_raw == &LibRaw::smal_v9_load_raw )",
          "874:     {",
          "876:       d_info->decoder_name = \"smal_v9_load_raw()\";",
          "877:    d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;",
          "878:     }",
          "879:   else  if (load_raw == &LibRaw::redcine_load_raw)",
          "880:     {",
          "881:       d_info->decoder_name = \"redcine_load_raw()\";",
          "882:       d_info->decoder_flags = LIBRAW_DECODER_HASCURVE;",
          "883:     }",
          "884:   else if (load_raw == &LibRaw::x3f_load_raw )",
          "885:     {",
          "886:       d_info->decoder_name = \"x3f_load_raw()\";",
          "887:       d_info->decoder_flags = LIBRAW_DECODER_OWNALLOC|LIBRAW_DECODER_FIXEDMAXC | LIBRAW_DECODER_LEGACY_WITH_MARGINS ;",
          "888:     }",
          "889:   else if (load_raw == &LibRaw::pentax_4shot_load_raw )",
          "891:    d_info->decoder_name = \"pentax_4shot_load_raw()\";",
          "892:    d_info->decoder_flags = LIBRAW_DECODER_OWNALLOC;",
          "894:   else if (load_raw == &LibRaw::deflate_dng_load_raw )",
          "896:    d_info->decoder_name = \"deflate_dng_load_raw()\";",
          "897:    d_info->decoder_flags = LIBRAW_DECODER_OWNALLOC;",
          "899:   else if (load_raw == &LibRaw::nikon_load_striped_packed_raw )",
          "900:     {",
          "901:       d_info->decoder_name = \"nikon_load_striped_packed_raw()\";",
          "902:     }",
          "903: #ifdef LIBRAW_DEMOSAIC_PACK_GPL2",
          "904:   else if (load_raw == &LibRaw::foveon_sd_load_raw )",
          "905:     {",
          "906:       d_info->decoder_name = \"foveon_sd_load_raw()\";",
          "907:     }",
          "908:   else if (load_raw == &LibRaw::foveon_dp_load_raw )",
          "909:     {",
          "910:       d_info->decoder_name = \"foveon_dp_load_raw()\";",
          "911:     }",
          "912: #endif",
          "913:   else",
          "914:     {",
          "915:       d_info->decoder_name = \"Unknown unpack function\";",
          "916:       d_info->decoder_flags = LIBRAW_DECODER_NOTSET;",
          "917:     }",
          "918:   return LIBRAW_SUCCESS;",
          "919: }",
          "921: int LibRaw::adjust_maximum()",
          "922: {",
          "923:     ushort real_max;",
          "924:     float  auto_threshold;",
          "926:     if(O.adjust_maximum_thr < 0.00001)",
          "927:         return LIBRAW_SUCCESS;",
          "928:     else if (O.adjust_maximum_thr > 0.99999)",
          "929:         auto_threshold = LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD;",
          "930:     else",
          "931:         auto_threshold = O.adjust_maximum_thr;",
          "934:     real_max = C.data_maximum;",
          "935:     if (real_max > 0 && real_max < C.maximum && real_max > C.maximum* auto_threshold)",
          "936:       {",
          "937:         C.maximum = real_max;",
          "938:       }",
          "939:     return LIBRAW_SUCCESS;",
          "943: void LibRaw:: merror (void *ptr, const char *where)",
          "945:     if (ptr) return;",
          "946:     if(callbacks.mem_cb)(*callbacks.mem_cb)(callbacks.memcb_data,",
          "947:                                             libraw_internal_data.internal_data.input",
          "948:                                             ?libraw_internal_data.internal_data.input->fname()",
          "949:                                             :NULL,",
          "950:                                             where);",
          "951:     throw LIBRAW_EXCEPTION_ALLOC;",
          "952: }",
          "960:   if(stat(fname,&st))",
          "962:   int big = (st.st_size > max_buf_size)?1:0;",
          "965:   if(_stati64(fname,&st))",
          "967:   int big = (st.st_size > max_buf_size)?1:0;",
          "971:   try {",
          "972:     if(big)",
          "979:     {",
          "980:       recycle();",
          "981:       return LIBRAW_UNSUFFICIENT_MEMORY;",
          "982:     }",
          "983:   if(!stream->valid())",
          "984:     {",
          "985:       delete stream;",
          "986:       return LIBRAW_IO_ERROR;",
          "987:     }",
          "991:     {",
          "992:       ID.input_internal =1 ; // flag to delete datastream on recycle",
          "993:     }",
          "995:     {",
          "996:       delete stream;",
          "997:       ID.input_internal = 0;",
          "998:     }",
          "",
          "[Added Lines]",
          "669: const char *LibRaw::unpack_function_name()",
          "676: int LibRaw::get_decoder_info(libraw_decoder_info_t *d_info)",
          "678:   if (!d_info)",
          "679:     return LIBRAW_UNSPECIFIED_ERROR;",
          "682:   if (!load_raw)",
          "683:     return LIBRAW_OUT_OF_ORDER_CALL;",
          "689:     d_info->decoder_name = \"android_tight_load_raw()\";",
          "690:     d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;",
          "694:     d_info->decoder_name = \"android_loose_load_raw()\";",
          "695:     d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;",
          "698:   {",
          "699:     d_info->decoder_name = \"canon_600_load_raw()\";",
          "700:     d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;",
          "701:   }",
          "704:     d_info->decoder_name = \"xtrans_compressed_load_raw()\";",
          "707:   {",
          "708:     d_info->decoder_name = \"canon_load_raw()\";",
          "709:   }",
          "711:   {",
          "712:     d_info->decoder_name = \"lossless_jpeg_load_raw()\";",
          "713:     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED;",
          "714:   }",
          "716:   {",
          "717:     d_info->decoder_name = \"canon_sraw_load_raw()\";",
          "719:   }",
          "721:   {",
          "722:     d_info->decoder_name = \"lossless_dng_load_raw()\";",
          "723:     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_ADOBECOPYPIXEL;",
          "724:   }",
          "726:   {",
          "727:     d_info->decoder_name = \"packed_dng_load_raw()\";",
          "728:     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_ADOBECOPYPIXEL;",
          "729:   }",
          "730:   else if (load_raw == &LibRaw::pentax_load_raw)",
          "731:   {",
          "732:     d_info->decoder_name = \"pentax_load_raw()\";",
          "733:     d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;",
          "734:   }",
          "737:     d_info->decoder_name = \"nikon_load_raw()\";",
          "738:     d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;",
          "740:   else if (load_raw == &LibRaw::nikon_coolscan_load_raw)",
          "742:     d_info->decoder_name = \"nikon_coolscan_load_raw()\";",
          "743:     d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;",
          "745:   else if (load_raw == &LibRaw::nikon_load_sraw)",
          "747:     d_info->decoder_name = \"nikon_load_sraw()\";",
          "748:     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;",
          "750:   else if (load_raw == &LibRaw::nikon_yuv_load_raw)",
          "752:     d_info->decoder_name = \"nikon_load_yuv_load_raw()\";",
          "753:     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;",
          "755:   else if (load_raw == &LibRaw::rollei_load_raw)",
          "756:   {",
          "758:     d_info->decoder_name = \"rollei_load_raw()\";",
          "759:     d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;",
          "760:   }",
          "761:   else if (load_raw == &LibRaw::phase_one_load_raw)",
          "762:   {",
          "763:     d_info->decoder_name = \"phase_one_load_raw()\";",
          "764:   }",
          "765:   else if (load_raw == &LibRaw::phase_one_load_raw_c)",
          "766:   {",
          "767:     d_info->decoder_name = \"phase_one_load_raw_c()\";",
          "768:   }",
          "769:   else if (load_raw == &LibRaw::hasselblad_load_raw)",
          "770:   {",
          "771:     d_info->decoder_name = \"hasselblad_load_raw()\";",
          "772:   }",
          "773:   else if (load_raw == &LibRaw::leaf_hdr_load_raw)",
          "774:   {",
          "775:     d_info->decoder_name = \"leaf_hdr_load_raw()\";",
          "776:   }",
          "777:   else if (load_raw == &LibRaw::unpacked_load_raw)",
          "778:   {",
          "779:     d_info->decoder_name = \"unpacked_load_raw()\";",
          "780:   }",
          "781:   else if (load_raw == &LibRaw::unpacked_load_raw_reversed)",
          "782:   {",
          "783:     d_info->decoder_name = \"unpacked_load_raw_reversed()\";",
          "784:     d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;",
          "785:   }",
          "786:   else if (load_raw == &LibRaw::sinar_4shot_load_raw)",
          "787:   {",
          "789:     d_info->decoder_name = \"sinar_4shot_load_raw()\";",
          "790:   }",
          "791:   else if (load_raw == &LibRaw::imacon_full_load_raw)",
          "792:   {",
          "793:     d_info->decoder_name = \"imacon_full_load_raw()\";",
          "794:   }",
          "795:   else if (load_raw == &LibRaw::hasselblad_full_load_raw)",
          "796:   {",
          "797:     d_info->decoder_name = \"hasselblad_full_load_raw()\";",
          "798:   }",
          "799:   else if (load_raw == &LibRaw::packed_load_raw)",
          "800:   {",
          "801:     d_info->decoder_name = \"packed_load_raw()\";",
          "802:     d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;",
          "803:   }",
          "804:   else if (load_raw == &LibRaw::broadcom_load_raw)",
          "805:   {",
          "807:     d_info->decoder_name = \"broadcom_load_raw()\";",
          "808:     d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;",
          "809:   }",
          "810:   else if (load_raw == &LibRaw::nokia_load_raw)",
          "811:   {",
          "813:     d_info->decoder_name = \"nokia_load_raw()\";",
          "814:     d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;",
          "815:   }",
          "816:   else if (load_raw == &LibRaw::canon_rmf_load_raw)",
          "817:   {",
          "819:     d_info->decoder_name = \"canon_rmf_load_raw()\";",
          "820:   }",
          "821:   else if (load_raw == &LibRaw::panasonic_load_raw)",
          "822:   {",
          "823:     d_info->decoder_name = \"panasonic_load_raw()\";",
          "824:     d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;",
          "825:   }",
          "826:   else if (load_raw == &LibRaw::olympus_load_raw)",
          "827:   {",
          "828:     d_info->decoder_name = \"olympus_load_raw()\";",
          "829:     d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;",
          "830:   }",
          "831:   else if (load_raw == &LibRaw::minolta_rd175_load_raw)",
          "832:   {",
          "834:     d_info->decoder_name = \"minolta_rd175_load_raw()\";",
          "835:   }",
          "836:   else if (load_raw == &LibRaw::quicktake_100_load_raw)",
          "837:   {",
          "839:     d_info->decoder_name = \"quicktake_100_load_raw()\";",
          "840:   }",
          "841:   else if (load_raw == &LibRaw::kodak_radc_load_raw)",
          "842:   {",
          "843:     d_info->decoder_name = \"kodak_radc_load_raw()\";",
          "844:   }",
          "845:   else if (load_raw == &LibRaw::kodak_jpeg_load_raw)",
          "846:   {",
          "848:     d_info->decoder_name = \"kodak_jpeg_load_raw()\";",
          "849:   }",
          "850:   else if (load_raw == &LibRaw::lossy_dng_load_raw)",
          "851:   {",
          "853:     d_info->decoder_name = \"lossy_dng_load_raw()\";",
          "854:     d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_HASCURVE;",
          "855:   }",
          "856:   else if (load_raw == &LibRaw::kodak_dc120_load_raw)",
          "857:   {",
          "858:     d_info->decoder_name = \"kodak_dc120_load_raw()\";",
          "859:   }",
          "860:   else if (load_raw == &LibRaw::eight_bit_load_raw)",
          "861:   {",
          "862:     d_info->decoder_name = \"eight_bit_load_raw()\";",
          "863:     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;",
          "864:   }",
          "865:   else if (load_raw == &LibRaw::kodak_c330_load_raw)",
          "866:   {",
          "867:     d_info->decoder_name = \"kodak_yrgb_load_raw()\";",
          "868:     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;",
          "869:   }",
          "870:   else if (load_raw == &LibRaw::kodak_c603_load_raw)",
          "871:   {",
          "872:     d_info->decoder_name = \"kodak_yrgb_load_raw()\";",
          "873:     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;",
          "874:   }",
          "875:   else if (load_raw == &LibRaw::kodak_262_load_raw)",
          "876:   {",
          "877:     d_info->decoder_name = \"kodak_262_load_raw()\"; // UNTESTED!",
          "878:     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;",
          "879:   }",
          "880:   else if (load_raw == &LibRaw::kodak_65000_load_raw)",
          "881:   {",
          "882:     d_info->decoder_name = \"kodak_65000_load_raw()\";",
          "883:     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE;",
          "884:   }",
          "885:   else if (load_raw == &LibRaw::kodak_ycbcr_load_raw)",
          "886:   {",
          "888:     d_info->decoder_name = \"kodak_ycbcr_load_raw()\";",
          "889:     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;",
          "890:   }",
          "891:   else if (load_raw == &LibRaw::kodak_rgb_load_raw)",
          "892:   {",
          "894:     d_info->decoder_name = \"kodak_rgb_load_raw()\";",
          "895:     d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;",
          "896:   }",
          "897:   else if (load_raw == &LibRaw::sony_load_raw)",
          "898:   {",
          "899:     d_info->decoder_name = \"sony_load_raw()\";",
          "900:   }",
          "901:   else if (load_raw == &LibRaw::sony_arw_load_raw)",
          "902:   {",
          "903:     d_info->decoder_name = \"sony_arw_load_raw()\";",
          "904:     d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;",
          "905:   }",
          "906:   else if (load_raw == &LibRaw::sony_arw2_load_raw)",
          "907:   {",
          "908:     d_info->decoder_name = \"sony_arw2_load_raw()\";",
          "909:     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_SONYARW2;",
          "910:   }",
          "911:   else if (load_raw == &LibRaw::samsung_load_raw)",
          "912:   {",
          "913:     d_info->decoder_name = \"samsung_load_raw()\";",
          "914:     d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;",
          "915:   }",
          "916:   else if (load_raw == &LibRaw::samsung2_load_raw)",
          "917:   {",
          "918:     d_info->decoder_name = \"samsung2_load_raw()\";",
          "919:   }",
          "920:   else if (load_raw == &LibRaw::samsung3_load_raw)",
          "921:   {",
          "922:     d_info->decoder_name = \"samsung3_load_raw()\";",
          "923:   }",
          "924:   else if (load_raw == &LibRaw::smal_v6_load_raw)",
          "925:   {",
          "927:     d_info->decoder_name = \"smal_v6_load_raw()\";",
          "928:     d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;",
          "929:   }",
          "930:   else if (load_raw == &LibRaw::smal_v9_load_raw)",
          "931:   {",
          "933:     d_info->decoder_name = \"smal_v9_load_raw()\";",
          "934:     d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;",
          "935:   }",
          "936:   else if (load_raw == &LibRaw::redcine_load_raw)",
          "937:   {",
          "938:     d_info->decoder_name = \"redcine_load_raw()\";",
          "939:     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE;",
          "940:   }",
          "941:   else if (load_raw == &LibRaw::x3f_load_raw)",
          "942:   {",
          "943:     d_info->decoder_name = \"x3f_load_raw()\";",
          "944:     d_info->decoder_flags = LIBRAW_DECODER_OWNALLOC | LIBRAW_DECODER_FIXEDMAXC | LIBRAW_DECODER_LEGACY_WITH_MARGINS;",
          "945:   }",
          "946:   else if (load_raw == &LibRaw::pentax_4shot_load_raw)",
          "947:   {",
          "948:     d_info->decoder_name = \"pentax_4shot_load_raw()\";",
          "949:     d_info->decoder_flags = LIBRAW_DECODER_OWNALLOC;",
          "950:   }",
          "951:   else if (load_raw == &LibRaw::deflate_dng_load_raw)",
          "952:   {",
          "953:     d_info->decoder_name = \"deflate_dng_load_raw()\";",
          "954:     d_info->decoder_flags = LIBRAW_DECODER_OWNALLOC;",
          "955:   }",
          "956:   else if (load_raw == &LibRaw::nikon_load_striped_packed_raw)",
          "957:   {",
          "958:     d_info->decoder_name = \"nikon_load_striped_packed_raw()\";",
          "959:   }",
          "960: #ifdef LIBRAW_DEMOSAIC_PACK_GPL2",
          "961:   else if (load_raw == &LibRaw::foveon_sd_load_raw)",
          "962:   {",
          "963:     d_info->decoder_name = \"foveon_sd_load_raw()\";",
          "964:   }",
          "965:   else if (load_raw == &LibRaw::foveon_dp_load_raw)",
          "966:   {",
          "967:     d_info->decoder_name = \"foveon_dp_load_raw()\";",
          "968:   }",
          "969: #endif",
          "970:   else",
          "971:   {",
          "972:     d_info->decoder_name = \"Unknown unpack function\";",
          "973:     d_info->decoder_flags = LIBRAW_DECODER_NOTSET;",
          "974:   }",
          "975:   return LIBRAW_SUCCESS;",
          "978: int LibRaw::adjust_maximum()",
          "980:   ushort real_max;",
          "981:   float auto_threshold;",
          "983:   if (O.adjust_maximum_thr < 0.00001)",
          "984:     return LIBRAW_SUCCESS;",
          "985:   else if (O.adjust_maximum_thr > 0.99999)",
          "986:     auto_threshold = LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD;",
          "987:   else",
          "988:     auto_threshold = O.adjust_maximum_thr;",
          "990:   real_max = C.data_maximum;",
          "991:   if (real_max > 0 && real_max < C.maximum && real_max > C.maximum * auto_threshold)",
          "992:   {",
          "993:     C.maximum = real_max;",
          "994:   }",
          "995:   return LIBRAW_SUCCESS;",
          "996: }",
          "998: void LibRaw::merror(void *ptr, const char *where)",
          "999: {",
          "1000:   if (ptr)",
          "1001:     return;",
          "1002:   if (callbacks.mem_cb)",
          "1003:     (*callbacks.mem_cb)(",
          "1004:         callbacks.memcb_data,",
          "1005:         libraw_internal_data.internal_data.input ? libraw_internal_data.internal_data.input->fname() : NULL, where);",
          "1006:   throw LIBRAW_EXCEPTION_ALLOC;",
          "1007: }",
          "1013:   if (stat(fname, &st))",
          "1015:   int big = (st.st_size > max_buf_size) ? 1 : 0;",
          "1018:   if (_stati64(fname, &st))",
          "1020:   int big = (st.st_size > max_buf_size) ? 1 : 0;",
          "1024:   try",
          "1025:   {",
          "1026:     if (big)",
          "1033:   {",
          "1034:     recycle();",
          "1035:     return LIBRAW_UNSUFFICIENT_MEMORY;",
          "1036:   }",
          "1037:   if (!stream->valid())",
          "1038:   {",
          "1039:     delete stream;",
          "1040:     return LIBRAW_IO_ERROR;",
          "1041:   }",
          "1045:   {",
          "1046:     ID.input_internal = 1; // flag to delete datastream on recycle",
          "1047:   }",
          "1049:   {",
          "1050:     delete stream;",
          "1051:     ID.input_internal = 0;",
          "1052:   }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1003: int LibRaw::open_file(const wchar_t *fname, INT64 max_buf_size)",
          "1004: {",
          "1005:   struct _stati64 st;",
          "1007:     return LIBRAW_IO_ERROR;",
          "1010:   LibRaw_abstract_datastream *stream;",
          "1013:       stream = new LibRaw_bigfile_datastream(fname);",
          "1014:     else",
          "1015:       stream = new LibRaw_file_datastream(fname);",
          "1016:   }",
          "1018:   catch (std::bad_alloc)",
          "1028:   ID.input_internal = 0; // preserve from deletion on error",
          "1029:   int ret = open_datastream(stream);",
          "1030:   if (ret == LIBRAW_SUCCESS)",
          "1034:   else",
          "1039:   return ret;",
          "1040: }",
          "1041: #endif",
          "",
          "[Removed Lines]",
          "1006:   if(_wstati64(fname,&st))",
          "1008:   int big = (st.st_size > max_buf_size)?1:0;",
          "1011:   try {",
          "1012:     if(big)",
          "1019:     {",
          "1020:       recycle();",
          "1021:       return LIBRAW_UNSUFFICIENT_MEMORY;",
          "1022:     }",
          "1023:   if(!stream->valid())",
          "1024:     {",
          "1025:       delete stream;",
          "1026:       return LIBRAW_IO_ERROR;",
          "1027:     }",
          "1031:     {",
          "1032:       ID.input_internal =1 ; // flag to delete datastream on recycle",
          "1033:     }",
          "1035:     {",
          "1036:       delete stream;",
          "1037:       ID.input_internal = 0;",
          "1038:     }",
          "",
          "[Added Lines]",
          "1060:   if (_wstati64(fname, &st))",
          "1062:   int big = (st.st_size > max_buf_size) ? 1 : 0;",
          "1065:   try",
          "1066:   {",
          "1067:     if (big)",
          "1074:   {",
          "1075:     recycle();",
          "1076:     return LIBRAW_UNSUFFICIENT_MEMORY;",
          "1077:   }",
          "1078:   if (!stream->valid())",
          "1079:   {",
          "1080:     delete stream;",
          "1081:     return LIBRAW_IO_ERROR;",
          "1082:   }",
          "1086:   {",
          "1087:     ID.input_internal = 1; // flag to delete datastream on recycle",
          "1088:   }",
          "1090:   {",
          "1091:     delete stream;",
          "1092:     ID.input_internal = 0;",
          "1093:   }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1043: int LibRaw::open_buffer(void *buffer, size_t size)",
          "1044: {",
          "1047:     return LIBRAW_IO_ERROR;",
          "1049:   LibRaw_buffer_datastream *stream;",
          "1052:   }",
          "1053:   catch (std::bad_alloc)",
          "1063:   ID.input_internal = 0; // preserve from deletion on error",
          "1064:   int ret = open_datastream(stream);",
          "1065:   if (ret == LIBRAW_SUCCESS)",
          "1069:   else",
          "1074:   return ret;",
          "1075: }",
          "1077: #ifdef USE_ZLIB",
          "1079: {",
          "1114: }",
          "1117: {",
          "1153: }",
          "1156: {",
          "1216: }",
          "1223: {",
          "1230: #if LibRawBigEndian",
          "1233: #else",
          "1236: #endif",
          "1259: #if LibRawBigEndian",
          "1264: #else",
          "1269: #endif",
          "1309: }",
          "1312: {",
          "1452: }",
          "1454: void LibRaw::deflate_dng_load_raw()",
          "1455: {",
          "1458: }",
          "1459: #endif",
          "1461: int LibRaw::is_floating_point()",
          "1462: {",
          "1469: }",
          "1471: int LibRaw::have_fpdata()",
          "1472: {",
          "1474: }",
          "1478: {",
          "1545: }",
          "1547: void LibRaw::pentax_4shot_load_raw()",
          "1548: {",
          "1604: }",
          "1606: void LibRaw::hasselblad_full_load_raw()",
          "1607: {",
          "1608:   int row, col;",
          "1617: }",
          "1619: void LibRaw::nikon_load_striped_packed_raw()",
          "1620: {",
          "1664: }",
          "1666: struct foveon_data_t",
          "1667: {",
          "1737: };",
          "1741: int LibRaw::open_datastream(LibRaw_abstract_datastream *stream)",
          "1742: {",
          "1745:     return ENOENT;",
          "1747:     return LIBRAW_IO_ERROR;",
          "1748:   recycle();",
          "1751:     ID.input = stream;",
          "1752:     SET_PROC_FLAG(LIBRAW_PROGRESS_OPEN);",
          "1754:     identify();",
          "1808:       {",
          "1827:       }",
          "1836:       imgdata.sizes.width = 4288;",
          "1897:       {",
          "1908:       }",
          "1910:       {",
          "1931:       }",
          "1957:       }",
          "1958:     }",
          "1966:     }",
          "1980:           imgdata.color.WBCT_Coeffs[c][3] *= 2.56f;",
          "1981:         }",
          "1982:       }",
          "1983:     }",
          "2001:     {",
          "2015:     }",
          "2016: #if 0",
          "2017:     size_t bytes = ID.input->size()-libraw_internal_data.unpacker_data.data_offset;",
          "",
          "[Removed Lines]",
          "1046:   if(!buffer  || buffer==(void*)-1)",
          "1050:   try {",
          "1051:     stream = new LibRaw_buffer_datastream(buffer,size);",
          "1054:     {",
          "1055:       recycle();",
          "1056:       return LIBRAW_UNSUFFICIENT_MEMORY;",
          "1057:     }",
          "1058:   if(!stream->valid())",
          "1059:     {",
          "1060:       delete stream;",
          "1061:       return LIBRAW_IO_ERROR;",
          "1062:     }",
          "1066:     {",
          "1067:       ID.input_internal =1 ; // flag to delete datastream on recycle",
          "1068:     }",
          "1070:     {",
          "1071:       delete stream;",
          "1072:       ID.input_internal = 0;",
          "1073:     }",
          "1078: inline unsigned int __DNG_HalfToFloat (ushort halfValue)",
          "1080:  int sign     = (halfValue >> 15) & 0x00000001;",
          "1081:  int exponent = (halfValue >> 10) & 0x0000001f;",
          "1082:  int mantissa =  halfValue     & 0x000003ff;",
          "1083:  if (exponent == 0)",
          "1084:  {",
          "1085:   if (mantissa == 0)",
          "1086:   {",
          "1087:    return (unsigned int) (sign << 31);",
          "1088:   }",
          "1089:   else",
          "1090:   {",
          "1091:    while (!(mantissa & 0x00000400))",
          "1092:    {",
          "1093:     mantissa <<= 1;",
          "1094:     exponent -=  1;",
          "1095:    }",
          "1096:    exponent += 1;",
          "1097:    mantissa &= ~0x00000400;",
          "1098:   }",
          "1099:  }",
          "1100:  else if (exponent == 31)",
          "1101:  {",
          "1102:   if (mantissa == 0)",
          "1103:   {",
          "1104:    return (unsigned int) ((sign << 31) | ((0x1eL + 127 - 15) << 23) |  (0x3ffL << 13));",
          "1105:   }",
          "1106:   else",
          "1107:   {",
          "1108:    return 0;",
          "1109:   }",
          "1110:  }",
          "1111:  exponent += (127 - 15);",
          "1112:  mantissa <<= 13;",
          "1113:  return (unsigned int) ((sign << 31) | (exponent << 23) | mantissa);",
          "1116: inline unsigned int __DNG_FP24ToFloat (const unsigned char *input)",
          "1118:  int sign     = (input [0] >> 7) & 0x01;",
          "1119:  int exponent = (input [0]     ) & 0x7F;",
          "1120:  int mantissa = (((int) input [1]) << 8) | input[2];",
          "1121:  if (exponent == 0)",
          "1122:  {",
          "1123:   if (mantissa == 0)",
          "1124:   {",
          "1125:    return (unsigned int) (sign << 31);",
          "1126:   }",
          "1127:   else",
          "1128:   {",
          "1129:    while (!(mantissa & 0x00010000))",
          "1130:    {",
          "1131:     mantissa <<= 1;",
          "1132:     exponent -=  1;",
          "1133:    }",
          "1134:    exponent += 1;",
          "1135:    mantissa &= ~0x00010000;",
          "1136:   }",
          "1137:  }",
          "1138:  else if (exponent == 127)",
          "1139:  {",
          "1140:   if (mantissa == 0)",
          "1141:   {",
          "1142:    return (unsigned int) ((sign << 31) | ((0x7eL + 128 - 64) << 23) |  (0xffffL << 7));",
          "1143:   }",
          "1144:   else",
          "1145:   {",
          "1147:    return 0;",
          "1148:   }",
          "1149:  }",
          "1150:  exponent += (128 - 64);",
          "1151:  mantissa <<= 7;",
          "1152:  return (uint32_t) ((sign << 31) | (exponent << 23) | mantissa);",
          "1155: inline void DecodeDeltaBytes (unsigned char *bytePtr, int cols, int channels)",
          "1157:  if (channels == 1)",
          "1158:  {",
          "1159:   unsigned char b0 = bytePtr [0];",
          "1160:   bytePtr += 1;",
          "1161:   for (uint32_t col = 1; col < cols; ++col)",
          "1162:   {",
          "1163:    b0 += bytePtr [0];",
          "1164:    bytePtr [0] = b0;",
          "1165:    bytePtr += 1;",
          "1166:   }",
          "1167:  }",
          "1168:  else if (channels == 3)",
          "1169:  {",
          "1170:   unsigned char b0 = bytePtr [0];",
          "1171:   unsigned char b1 = bytePtr [1];",
          "1172:   unsigned char b2 = bytePtr [2];",
          "1173:   bytePtr += 3;",
          "1174:   for (int col = 1; col < cols; ++col)",
          "1175:   {",
          "1176:    b0 += bytePtr [0];",
          "1177:    b1 += bytePtr [1];",
          "1178:    b2 += bytePtr [2];",
          "1179:    bytePtr [0] = b0;",
          "1180:    bytePtr [1] = b1;",
          "1181:    bytePtr [2] = b2;",
          "1182:    bytePtr += 3;",
          "1183:   }",
          "1184:  }",
          "1185:  else if (channels == 4)",
          "1186:  {",
          "1187:   unsigned char b0 = bytePtr [0];",
          "1188:   unsigned char b1 = bytePtr [1];",
          "1189:   unsigned char b2 = bytePtr [2];",
          "1190:   unsigned char b3 = bytePtr [3];",
          "1191:   bytePtr += 4;",
          "1192:   for (uint32_t col = 1; col < cols; ++col)",
          "1193:   {",
          "1194:    b0 += bytePtr [0];",
          "1195:    b1 += bytePtr [1];",
          "1196:    b2 += bytePtr [2];",
          "1197:    b3 += bytePtr [3];",
          "1198:    bytePtr [0] = b0;",
          "1199:    bytePtr [1] = b1;",
          "1200:    bytePtr [2] = b2;",
          "1201:    bytePtr [3] = b3;",
          "1202:    bytePtr += 4;",
          "1203:   }",
          "1204:  }",
          "1205:  else",
          "1206:  {",
          "1207:   for (int col = 1; col < cols; ++col)",
          "1208:   {",
          "1209:    for (int chan = 0; chan < channels; ++chan)",
          "1210:    {",
          "1211:     bytePtr [chan + channels] += bytePtr [chan];",
          "1212:    }",
          "1213:    bytePtr += channels;",
          "1214:   }",
          "1215:  }",
          "1218: static void DecodeFPDelta (unsigned char *input,",
          "1219:  unsigned char *output,",
          "1220:  int cols,",
          "1221:  int channels,",
          "1222:  int bytesPerSample)",
          "1224:  DecodeDeltaBytes (input, cols * bytesPerSample, channels);",
          "1225:  int32_t rowIncrement = cols * channels;",
          "1227:  if (bytesPerSample == 2)",
          "1228:  {",
          "1231:   const unsigned char *input0 = input;",
          "1232:   const unsigned char *input1 = input + rowIncrement;",
          "1234:   const unsigned char *input1 = input;",
          "1235:   const unsigned char *input0 = input + rowIncrement;",
          "1237:   for (int col = 0; col < rowIncrement; ++col)",
          "1238:   {",
          "1239:    output [0] = input0 [col];",
          "1240:    output [1] = input1 [col];",
          "1241:    output += 2;",
          "1242:   }",
          "1243:  }",
          "1244:  else if (bytesPerSample == 3)",
          "1245:  {",
          "1246:   const unsigned char *input0 = input;",
          "1247:   const unsigned char *input1 = input + rowIncrement;",
          "1248:   const unsigned char *input2 = input + rowIncrement * 2;",
          "1249:   for (int col = 0; col < rowIncrement; ++col)",
          "1250:   {",
          "1251:    output [0] = input0 [col];",
          "1252:    output [1] = input1 [col];",
          "1253:    output [2] = input2 [col];",
          "1254:    output += 3;",
          "1255:   }",
          "1256:  }",
          "1257:  else",
          "1258:  {",
          "1260:   const unsigned char *input0 = input;",
          "1261:   const unsigned char *input1 = input + rowIncrement;",
          "1262:   const unsigned char *input2 = input + rowIncrement * 2;",
          "1263:   const unsigned char *input3 = input + rowIncrement * 3;",
          "1265:   const unsigned char *input3 = input;",
          "1266:   const unsigned char *input2 = input + rowIncrement;",
          "1267:   const unsigned char *input1 = input + rowIncrement * 2;",
          "1268:   const unsigned char *input0 = input + rowIncrement * 3;",
          "1270:   for (int col = 0; col < rowIncrement; ++col)",
          "1271:   {",
          "1272:    output [0] = input0 [col];",
          "1273:    output [1] = input1 [col];",
          "1274:    output [2] = input2 [col];",
          "1275:    output [3] = input3 [col];",
          "1276:    output += 4;",
          "1277:   }",
          "1278:  }",
          "1279: }",
          "1281: static float expandFloats(unsigned char * dst, int tileWidth, int bytesps) {",
          "1282:  float max = 0.f;",
          "1283:  if (bytesps == 2) {",
          "1284:   uint16_t * dst16 = (ushort *) dst;",
          "1285:   uint32_t * dst32 = (unsigned int *) dst;",
          "1286:   float *f32 = (float*) dst;",
          "1287:   for (int index = tileWidth - 1; index >= 0; --index) {",
          "1288:    dst32[index] = __DNG_HalfToFloat(dst16[index]);",
          "1289:    max = MAX(max,f32[index]);",
          "1290:   }",
          "1291:  }",
          "1292:  else if (bytesps == 3)",
          "1293:  {",
          "1294:   uint8_t  * dst8  = ((unsigned char *) dst) + (tileWidth - 1) * 3;",
          "1295:   uint32_t * dst32 = (unsigned int *) dst;",
          "1296:   float *f32 = (float*) dst;",
          "1297:   for (int index = tileWidth - 1; index >= 0; --index, dst8 -= 3) {",
          "1298:    dst32[index] = __DNG_FP24ToFloat(dst8);",
          "1299:    max = MAX(max,f32[index]);",
          "1300:   }",
          "1301:  }",
          "1302:  else if (bytesps==4)",
          "1303:  {",
          "1304:   float *f32 = (float*) dst;",
          "1305:   for (int index = 0; index < tileWidth; index++)",
          "1306:    max = MAX(max,f32[index]);",
          "1307:  }",
          "1308:  return max;",
          "1311: void LibRaw::deflate_dng_load_raw()",
          "1313:  struct tiff_ifd_t * ifd = &tiff_ifd[0];",
          "1314:  while (ifd < &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds] && ifd->offset != libraw_internal_data.unpacker_data.data_offset) ++ifd;",
          "1315:  if (ifd == &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds])",
          "1316:  {",
          "1317:   throw LIBRAW_EXCEPTION_DECODE_RAW;",
          "1318:  }",
          "1320:  float *float_raw_image=0;",
          "1321:  float max = 0.f;",
          "1323:  if(ifd->samples!=1 && ifd->samples!=3 && ifd->samples !=4)",
          "1324:   throw LIBRAW_EXCEPTION_DECODE_RAW; // Only float deflated supported",
          "1326:  if(libraw_internal_data.unpacker_data.tiff_samples != ifd->samples)",
          "1327:   throw LIBRAW_EXCEPTION_DECODE_RAW; // Wrong IFD",
          "1330:  size_t tilesH = (imgdata.sizes.raw_width + libraw_internal_data.unpacker_data.tile_width - 1) / libraw_internal_data.unpacker_data.tile_width;",
          "1331:  size_t tilesV = (imgdata.sizes.raw_height + libraw_internal_data.unpacker_data.tile_length - 1) / libraw_internal_data.unpacker_data.tile_length;",
          "1332:  size_t tileCnt = tilesH * tilesV;",
          "1335:  if (ifd->sample_format == 3)",
          "1336:  {  // Floating point data",
          "1337:   float_raw_image = (float*)calloc(tileCnt*libraw_internal_data.unpacker_data.tile_length* libraw_internal_data.unpacker_data.tile_width * ifd->samples,sizeof(float));",
          "1341:  }",
          "1342:  else",
          "1343:   throw LIBRAW_EXCEPTION_DECODE_RAW; // Only float deflated supported",
          "1345:  int xFactor;",
          "1346:  switch(ifd->predictor)",
          "1347:  {",
          "1348:   case 3:",
          "1349:   default:",
          "1350:    xFactor = 1; break;",
          "1351:   case 34894: xFactor = 2; break;",
          "1352:   case 34895: xFactor = 4; break;",
          "1353:  }",
          "1355:  if (libraw_internal_data.unpacker_data.tile_length < INT_MAX)",
          "1356:  {",
          "1357:   if(tileCnt<1 || tileCnt > 1000000)",
          "1358:    throw LIBRAW_EXCEPTION_DECODE_RAW;",
          "1360:   size_t *tOffsets = (size_t*)malloc(tileCnt*sizeof(size_t));",
          "1361:   for (int t = 0; t < tileCnt; ++t)",
          "1362:    tOffsets[t] = get4();",
          "1364:   size_t *tBytes = (size_t*) malloc(tileCnt*sizeof(size_t));",
          "1365:   unsigned long maxBytesInTile = 0;",
          "1366:   if (tileCnt == 1)",
          "1367:    tBytes[0] = maxBytesInTile = ifd->bytes;",
          "1368:   else",
          "1369:   {",
          "1370:    libraw_internal_data.internal_data.input->seek(ifd->bytes, SEEK_SET);",
          "1371:    for (size_t t = 0; t < tileCnt; ++t)",
          "1372:    {",
          "1373:     tBytes[t] = get4();",
          "1374:     maxBytesInTile = MAX(maxBytesInTile,tBytes[t]);",
          "1375:    }",
          "1376:   }",
          "1377:   unsigned tilePixels = libraw_internal_data.unpacker_data.tile_width * libraw_internal_data.unpacker_data.tile_length;",
          "1378:   unsigned pixelSize = sizeof(float)*ifd->samples;",
          "1379:   unsigned tileBytes = tilePixels*pixelSize;",
          "1380:   unsigned tileRowBytes = libraw_internal_data.unpacker_data.tile_width*pixelSize;",
          "1382:   unsigned char *cBuffer = (unsigned char*)malloc(maxBytesInTile);",
          "1383:   unsigned char *uBuffer = (unsigned char*)malloc(tileBytes+tileRowBytes); // extra row for decoding",
          "1385:   for (size_t y = 0, t = 0; y < imgdata.sizes.raw_height; y += libraw_internal_data.unpacker_data.tile_length)",
          "1386:   {",
          "1387:    for (size_t x = 0; x < imgdata.sizes.raw_width; x += libraw_internal_data.unpacker_data.tile_width, ++t)",
          "1388:    {",
          "1389:     libraw_internal_data.internal_data.input->seek(tOffsets[t], SEEK_SET);",
          "1390:     libraw_internal_data.internal_data.input->read(cBuffer, 1, tBytes[t]);",
          "1391:     unsigned long dstLen = tileBytes;",
          "1392:     int err = uncompress(uBuffer+tileRowBytes, &dstLen, cBuffer, tBytes[t]);",
          "1393:     if (err != Z_OK)",
          "1394:     {",
          "1395:      free(tOffsets);",
          "1396:      free(tBytes);",
          "1397:      free(cBuffer);",
          "1398:      free(uBuffer);",
          "1399:      throw LIBRAW_EXCEPTION_DECODE_RAW;",
          "1400:      return;",
          "1401:     }",
          "1402:     else",
          "1403:     {",
          "1404:      int bytesps = ifd->bps >> 3;",
          "1405:      size_t rowsInTile = y + libraw_internal_data.unpacker_data.tile_length > imgdata.sizes.raw_height ? imgdata.sizes.raw_height - y : libraw_internal_data.unpacker_data.tile_length;",
          "1406:      size_t colsInTile= x + libraw_internal_data.unpacker_data.tile_width > imgdata.sizes.raw_width ? imgdata.sizes.raw_width - x : libraw_internal_data.unpacker_data.tile_width;",
          "1408:      for (size_t row = 0; row < rowsInTile; ++row) // do not process full tile if not needed",
          "1409:      {",
          "1410:       unsigned char* dst = uBuffer + row*libraw_internal_data.unpacker_data.tile_width*bytesps*ifd->samples;",
          "1411:       unsigned char* src = dst+tileRowBytes;",
          "1412:       DecodeFPDelta (src,dst,",
          "1413:        libraw_internal_data.unpacker_data.tile_width/ xFactor,",
          "1414:        ifd->samples * xFactor,",
          "1415:        bytesps);",
          "1416:       float lmax = expandFloats(dst, libraw_internal_data.unpacker_data.tile_width*ifd->samples, bytesps);",
          "1417:       max = MAX(max,lmax);",
          "1418:       unsigned char* dst2 = (unsigned char*)&float_raw_image[((y+row)*imgdata.sizes.raw_width + x)*ifd->samples];",
          "1419:       memmove(dst2,dst,colsInTile*ifd->samples*sizeof(float));",
          "1420:      }",
          "1421:     }",
          "1422:    }",
          "1423:   }",
          "1424:   free(tOffsets);",
          "1425:   free(tBytes);",
          "1426:   free(cBuffer);",
          "1427:   free(uBuffer);",
          "1428:  }",
          "1429:  imgdata.color.fmaximum = max;",
          "1433:  imgdata.rawdata.raw_alloc = float_raw_image;",
          "1434:  if(ifd->samples == 1)",
          "1435:  {",
          "1436:   imgdata.rawdata.float_image = float_raw_image;",
          "1437:   imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*4;",
          "1438:  }",
          "1439:  else if(ifd->samples == 3)",
          "1440:  {",
          "1441:   imgdata.rawdata.float3_image = (float(*)[3])float_raw_image;",
          "1442:   imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*12;",
          "1443:  }",
          "1444:  else if(ifd->samples == 4)",
          "1445:  {",
          "1446:   imgdata.rawdata.float4_image = (float(*)[4])float_raw_image;",
          "1447:   imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*16;",
          "1448:  }",
          "1450:  if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_CONVERTFLOAT_TO_INT)",
          "1451:   convertFloatToInt(); // with default settings",
          "1453: #else",
          "1457:  throw LIBRAW_EXCEPTION_DECODE_RAW;",
          "1463:  struct tiff_ifd_t * ifd = &tiff_ifd[0];",
          "1464:  while (ifd < &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds] && ifd->offset != libraw_internal_data.unpacker_data.data_offset) ++ifd;",
          "1465:  if (ifd == &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds])",
          "1466:   return 0;",
          "1468:  return ifd->sample_format == 3;",
          "1473:  return imgdata.rawdata.float_image || imgdata.rawdata.float3_image || imgdata.rawdata.float4_image;",
          "1477: void LibRaw::convertFloatToInt(float dmin/* =4096.f */, float dmax/* =32767.f */, float dtarget /*= 16383.f */)",
          "1479:  int samples = 0;",
          "1480:  float *data = 0;",
          "1481:  if(imgdata.rawdata.float_image)",
          "1482:  {",
          "1483:   samples = 1;",
          "1484:   data = imgdata.rawdata.float_image;",
          "1485:  }",
          "1486:  else if (imgdata.rawdata.float3_image)",
          "1487:  {",
          "1488:   samples = 3;",
          "1489:   data = (float*)imgdata.rawdata.float3_image;",
          "1490:  }",
          "1491:  else if (imgdata.rawdata.float4_image)",
          "1492:  {",
          "1493:   samples = 4;",
          "1494:   data = (float*)imgdata.rawdata.float4_image;",
          "1495:  }",
          "1496:  else",
          "1497:   return;",
          "1499:  ushort *raw_alloc = (ushort*)malloc(imgdata.sizes.raw_height*imgdata.sizes.raw_width*libraw_internal_data.unpacker_data.tiff_samples*sizeof(ushort));",
          "1500:  float tmax = MAX(imgdata.color.maximum,1);",
          "1501:  float datamax = imgdata.color.fmaximum;",
          "1503:  tmax = MAX(tmax,datamax);",
          "1504:  tmax = MAX(tmax,1.f);",
          "1506:  float multip = 1.f;",
          "1507:  if(tmax < dmin || tmax > dmax)",
          "1508:  {",
          "1509:   imgdata.rawdata.color.fnorm = imgdata.color.fnorm = multip = dtarget / tmax;",
          "1510:   imgdata.rawdata.color.maximum = imgdata.color.maximum = dtarget;",
          "1511:   imgdata.rawdata.color.black = imgdata.color.black = (float)imgdata.color.black*multip;",
          "1512:   for(int i=0; i<sizeof(imgdata.color.cblack)/sizeof(imgdata.color.cblack[0]); i++)",
          "1513:    if(i!=4 && i!=5)",
          "1514:     imgdata.rawdata.color.cblack[i] = imgdata.color.cblack[i] = (float)imgdata.color.cblack[i]*multip;",
          "1516:  }",
          "1517:  else",
          "1518:   imgdata.rawdata.color.fnorm = imgdata.color.fnorm = 0.f;",
          "1520:  for (size_t i = 0; i < imgdata.sizes.raw_height*imgdata.sizes.raw_width*libraw_internal_data.unpacker_data.tiff_samples; ++i)",
          "1521:  {",
          "1522:   float val = MAX(data[i],0.f);",
          "1523:   raw_alloc[i] = (ushort)(val*multip);",
          "1524:  }",
          "1526:  if(samples==1)",
          "1527:  {",
          "1528:   imgdata.rawdata.raw_alloc = imgdata.rawdata.raw_image = raw_alloc;",
          "1529:   imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*2;",
          "1530:  }",
          "1531:  else if(samples == 3)",
          "1532:  {",
          "1533:   imgdata.rawdata.raw_alloc = imgdata.rawdata.color3_image = (ushort (*)[3]) raw_alloc;",
          "1534:   imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*6;",
          "1535:  }",
          "1536:  else if(samples == 4)",
          "1537:  {",
          "1538:   imgdata.rawdata.raw_alloc = imgdata.rawdata.color4_image = (ushort (*)[4]) raw_alloc;",
          "1539:   imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*8;",
          "1540:  }",
          "1541:  free(data); // remove old allocation",
          "1542:  imgdata.rawdata.float_image = 0;",
          "1543:  imgdata.rawdata.float3_image = 0;",
          "1544:  imgdata.rawdata.float4_image = 0;",
          "1549:  ushort *plane = (ushort*)malloc(imgdata.sizes.raw_width*imgdata.sizes.raw_height*sizeof(ushort));",
          "1550:  int alloc_sz = imgdata.sizes.raw_width*(imgdata.sizes.raw_height+16)*4*sizeof(ushort);",
          "1551:  ushort (*result)[4] = (ushort(*)[4]) malloc(alloc_sz);",
          "1552:  struct movement_t",
          "1553:  {",
          "1554:   int row,col;",
          "1555:  } _move[4] = {",
          "1556:   {1,1},",
          "1557:   {0,1},",
          "1558:   {0,0},",
          "1559:   {1,0},",
          "1560:  };",
          "1562:  int tidx = 0;",
          "1563:  for(int i=0; i<4; i++)",
          "1564:  {",
          "1565:   int move_row,move_col;",
          "1566:   if(imgdata.params.p4shot_order[i] >= '0' && imgdata.params.p4shot_order[i] <= '3')",
          "1567:   {",
          "1568:    move_row = (imgdata.params.p4shot_order[i]-'0' & 2)?1:0;",
          "1569:    move_col = (imgdata.params.p4shot_order[i]-'0' & 1)?1:0;",
          "1570:   }",
          "1571:   else",
          "1572:   {",
          "1573:    move_row = _move[i].row;",
          "1574:    move_col = _move[i].col;",
          "1575:   }",
          "1576:   for(; tidx<16; tidx++)",
          "1577:    if(tiff_ifd[tidx].t_width == imgdata.sizes.raw_width && tiff_ifd[tidx].t_height == imgdata.sizes.raw_height && tiff_ifd[tidx].bps>8 && tiff_ifd[tidx].samples == 1 )",
          "1578:     break;",
          "1579:   if(tidx>=16)",
          "1580:    break;",
          "1581:   imgdata.rawdata.raw_image = plane;",
          "1582:   ID.input->seek(tiff_ifd[tidx].offset, SEEK_SET);",
          "1583:   imgdata.idata.filters = 0xb4b4b4b4;",
          "1584:   libraw_internal_data.unpacker_data.data_offset = tiff_ifd[tidx].offset;",
          "1585:   (this->*pentax_component_load_raw)();",
          "1586:   for(int row = 0; row < imgdata.sizes.raw_height-move_row; row++)",
          "1587:   {",
          "1588:    int colors[2];",
          "1589:    for(int c = 0; c < 2; c++ )",
          "1590:     colors[c] = COLOR(row,c);",
          "1591:    ushort *srcrow = &plane[imgdata.sizes.raw_width*row];",
          "1592:    ushort (*dstrow)[4] = & result[(imgdata.sizes.raw_width)*(row+move_row)+move_col];",
          "1593:    for(int col = 0; col < imgdata.sizes.raw_width-move_col; col++)",
          "1594:     dstrow[col][colors[col%2]] = srcrow[col];",
          "1595:   }",
          "1596:   tidx++;",
          "1597:  }",
          "1599:  imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*8;",
          "1600:  imgdata.idata.filters = 0;",
          "1601:  imgdata.rawdata.raw_alloc = imgdata.rawdata.color4_image = result;",
          "1602:  free(plane);",
          "1603:  imgdata.rawdata.raw_image = 0;",
          "1610:   for (row=0; row < S.height; row++)",
          "1611:     for (col=0; col < S.width; col++)",
          "1612:       {",
          "1613:         read_shorts (&imgdata.image[row*S.width+col][2], 1); // B",
          "1614:         read_shorts (&imgdata.image[row*S.width+col][1], 1); // G",
          "1615:         read_shorts (&imgdata.image[row*S.width+col][0], 1); // R",
          "1616:       }",
          "1621:  int vbits=0, bwide, rbits, bite,row, col, val, i;",
          "1623:  UINT64 bitbuf=0;",
          "1624:  unsigned load_flags = 24; //libraw_internal_data.unpacker_data.load_flags;",
          "1625:  unsigned tiff_bps = libraw_internal_data.unpacker_data.tiff_bps;",
          "1626:  int tiff_compress = libraw_internal_data.unpacker_data.tiff_compress;",
          "1628:  struct tiff_ifd_t * ifd = &tiff_ifd[0];",
          "1629:  while (ifd < &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds] && ifd->offset != libraw_internal_data.unpacker_data.data_offset) ++ifd;",
          "1630:  if (ifd == &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds])",
          "1631:   throw LIBRAW_EXCEPTION_DECODE_RAW;",
          "1633:  if(!ifd->rows_per_strip || !ifd->strip_offsets_count)",
          "1634:   return; // not unpacked",
          "1635:  int stripcnt = 0;",
          "1637:  bwide = S.raw_width *  tiff_bps / 8;",
          "1638:  bwide += bwide & load_flags >> 7;",
          "1639:  rbits = bwide * 8 - S.raw_width * tiff_bps;",
          "1640:  if (load_flags & 1) bwide = bwide * 16 / 15;",
          "1641:  bite = 8 + (load_flags & 24);",
          "1642:  for (row=0; row < S.raw_height; row++)",
          "1643:  {",
          "1644:   checkCancel();",
          "1645:   if(!(row%ifd->rows_per_strip))",
          "1646:   {",
          "1647:    if(stripcnt >= ifd->strip_offsets_count)",
          "1648:     return; // run out of data",
          "1649:    libraw_internal_data.internal_data.input->seek(ifd->strip_offsets[stripcnt],SEEK_SET);",
          "1650:    stripcnt++;",
          "1651:   }",
          "1652:   for (col=0; col < S.raw_width; col++)",
          "1653:   {",
          "1654:    for (vbits -= tiff_bps; vbits < 0; vbits += bite)",
          "1655:    {",
          "1656:     bitbuf <<= bite;",
          "1657:     for (i=0; i < bite; i+=8)",
          "1658:      bitbuf |= (unsigned) (libraw_internal_data.internal_data.input->get_char() << i);",
          "1659:    }",
          "1660:    imgdata.rawdata.raw_image[(row)*S.raw_width+(col)] = bitbuf << (64-tiff_bps-vbits) >> (64-tiff_bps);",
          "1661:   }",
          "1662:   vbits -= rbits;",
          "1663:  }",
          "1668:     const char *make;",
          "1669:     const char *model;",
          "1670:     const int raw_width,raw_height;",
          "1671:     const int  white;",
          "1672:     const int  left_margin,top_margin;",
          "1673:     const int  width,height;",
          "1674: } foveon_data [] =",
          "1675: {",
          "1676:   {\"Sigma\",\"SD9\",2304,1531,12000,20,8,2266,1510},",
          "1677:   {\"Sigma\",\"SD9\",1152,763,12000,10,2,1132,755},",
          "1678:   {\"Sigma\",\"SD10\",2304,1531,12000,20,8,2266,1510},",
          "1679:   {\"Sigma\",\"SD10\",1152,763,12000,10,2,1132,755},",
          "1680:   {\"Sigma\",\"SD14\",2688,1792,14000,18,12,2651,1767},",
          "1681:   {\"Sigma\",\"SD14\",2688,896,14000,18,6,2651,883}, // 2/3",
          "1682:   {\"Sigma\",\"SD14\",1344,896,14000,9,6,1326,883}, // 1/2",
          "1683:   {\"Sigma\",\"SD15\",2688,1792,2900,18,12,2651,1767},",
          "1684:   {\"Sigma\",\"SD15\",2688,896,2900,18,6,2651,883}, // 2/3 ?",
          "1685:   {\"Sigma\",\"SD15\",1344,896,2900,9,6,1326,883}, // 1/2 ?",
          "1686:   {\"Sigma\",\"DP1\",2688,1792,2100,18,12,2651,1767},",
          "1687:   {\"Sigma\",\"DP1\",2688,896,2100,18,6,2651,883}, // 2/3 ?",
          "1688:   {\"Sigma\",\"DP1\",1344,896,2100,9,6,1326,883}, // 1/2 ?",
          "1689:   {\"Sigma\",\"DP1S\",2688,1792,2200,18,12,2651,1767},",
          "1690:   {\"Sigma\",\"DP1S\",2688,896,2200,18,6,2651,883}, // 2/3",
          "1691:   {\"Sigma\",\"DP1S\",1344,896,2200,9,6,1326,883}, // 1/2",
          "1692:   {\"Sigma\",\"DP1X\",2688,1792,3560,18,12,2651,1767},",
          "1693:   {\"Sigma\",\"DP1X\",2688,896,3560,18,6,2651,883}, // 2/3",
          "1694:   {\"Sigma\",\"DP1X\",1344,896,3560,9,6,1326,883}, // 1/2",
          "1695:   {\"Sigma\",\"DP2\",2688,1792,2326,13,16,2651,1767},",
          "1696:   {\"Sigma\",\"DP2\",2688,896,2326,13,8,2651,883}, // 2/3 ??",
          "1697:   {\"Sigma\",\"DP2\",1344,896,2326,7,8,1325,883}, // 1/2 ??",
          "1698:   {\"Sigma\",\"DP2S\",2688,1792,2300,18,12,2651,1767},",
          "1699:   {\"Sigma\",\"DP2S\",2688,896,2300,18,6,2651,883}, // 2/3",
          "1700:   {\"Sigma\",\"DP2S\",1344,896,2300,9,6,1326,883}, // 1/2",
          "1701:   {\"Sigma\",\"DP2X\",2688,1792,2300,18,12,2651,1767},",
          "1702:   {\"Sigma\",\"DP2X\",2688,896,2300,18,6,2651,883}, // 2/3",
          "1703:   {\"Sigma\",\"DP2X\",1344,896,2300,9,6,1325,883}, // 1/2",
          "1704:   {\"Sigma\",\"SD1\",4928,3264,3900,12,52,4807,3205}, // Full size",
          "1705:   {\"Sigma\",\"SD1\",4928,1632,3900,12,26,4807,1603}, // 2/3 size",
          "1706:   {\"Sigma\",\"SD1\",2464,1632,3900,6,26,2403,1603}, // 1/2 size",
          "1707:   {\"Sigma\",\"SD1 Merrill\",4928,3264,3900,12,52,4807,3205}, // Full size",
          "1708:   {\"Sigma\",\"SD1 Merrill\",4928,1632,3900,12,26,4807,1603}, // 2/3 size",
          "1709:   {\"Sigma\",\"SD1 Merrill\",2464,1632,3900,6,26,2403,1603}, // 1/2 size",
          "1710:   {\"Sigma\",\"DP1 Merrill\",4928,3264,3900,12,0,4807,3205},",
          "1711:   {\"Sigma\",\"DP1 Merrill\",2464,1632,3900,12,0,2403,1603}, // 1/2 size",
          "1712:   {\"Sigma\",\"DP1 Merrill\",4928,1632,3900,12,0,4807,1603}, // 2/3 size",
          "1713:   {\"Sigma\",\"DP2 Merrill\",4928,3264,3900,12,0,4807,3205},",
          "1714:   {\"Sigma\",\"DP2 Merrill\",2464,1632,3900,12,0,2403,1603}, // 1/2 size",
          "1715:   {\"Sigma\",\"DP2 Merrill\",4928,1632,3900,12,0,4807,1603}, // 2/3 size",
          "1716:   {\"Sigma\",\"DP3 Merrill\",4928,3264,3900,12,0,4807,3205},",
          "1717:   {\"Sigma\",\"DP3 Merrill\",2464,1632,3900,12,0,2403,1603}, // 1/2 size",
          "1718:   {\"Sigma\",\"DP3 Merrill\",4928,1632,3900,12,0,4807,1603}, // 2/3 size",
          "1719:   {\"Polaroid\",\"x530\",1440,1088,2700,10,13,1419,1059},",
          "1721:   {\"Sigma\",\"dp3 Quattro\",5888,3672,16383,204,24,5446,3624}, // full size",
          "1722:   {\"Sigma\",\"dp3 Quattro\",2944,1836,16383,102,12,2723,1812}, // half size",
          "1723:   {\"Sigma\",\"dp2 Quattro\",5888,3672,16383,204,24,5446,3624}, // full size",
          "1724:   {\"Sigma\",\"dp2 Quattro\",2944,1836,16383,102,12,2723,1812}, // half size",
          "1725:   {\"Sigma\",\"dp1 Quattro\",5888,3672,16383,204,24,5446,3624}, // full size",
          "1726:   {\"Sigma\",\"dp1 Quattro\",2944,1836,16383,102,12,2723,1812}, // half size",
          "1727:   {\"Sigma\",\"dp0 Quattro\",5888,3672,16383,204,24,5446,3624}, // full size",
          "1728:   {\"Sigma\",\"dp0 Quattro\",2944,1836,16383,102,12,2723,1812}, // half size",
          "1730:   {\"Sigma\",\"sd Quattro\",5888,3776,16383,204,76,5446,3624}, // full size",
          "1731:   {\"Sigma\",\"sd Quattro\",2944,1888,16383,102,38,2723,1812}, // half size",
          "1733:   {\"Sigma\",\"sd Quattro H\",6656,4480,16383,224,160,6208,4160}, // full size",
          "1734:   {\"Sigma\",\"sd Quattro H\",3328,2240,16383,112,80,3104,2080}, // half size",
          "1735:   {\"Sigma\",\"sd Quattro H\",5504,3680,16383,0,4,5496,3668}, // full size",
          "1736:   {\"Sigma\",\"sd Quattro H\",2752,1840,16383,0,2,2748,1834}, // half size",
          "1738: const int foveon_count = sizeof(foveon_data)/sizeof(foveon_data[0]);",
          "1744:   if(!stream)",
          "1746:   if(!stream->valid())",
          "1750:   try {",
          "1756:  if (!strcasecmp(imgdata.idata.make, \"Canon\")  && (load_raw == &LibRaw::canon_sraw_load_raw) && imgdata.sizes.raw_width>0)",
          "1757:  {",
          "1758:   float ratio = float(imgdata.sizes.raw_height) / float(imgdata.sizes.raw_width);",
          "1759:   if((ratio < 0.57 || ratio > 0.75) && imgdata.makernotes.canon.SensorHeight>1 && imgdata.makernotes.canon.SensorWidth > 1)",
          "1760:   {",
          "1761:    imgdata.sizes.raw_width = imgdata.makernotes.canon.SensorWidth;",
          "1762:    imgdata.sizes.left_margin = imgdata.makernotes.canon.SensorLeftBorder;",
          "1763:    imgdata.sizes.iwidth = imgdata.sizes.width = imgdata.makernotes.canon.SensorRightBorder - imgdata.makernotes.canon.SensorLeftBorder+1;",
          "1764:    imgdata.sizes.raw_height = imgdata.makernotes.canon.SensorHeight;",
          "1765:    imgdata.sizes.top_margin = imgdata.makernotes.canon.SensorTopBorder;",
          "1766:    imgdata.sizes.iheight = imgdata.sizes.height = imgdata.makernotes.canon.SensorBottomBorder - imgdata.makernotes.canon.SensorTopBorder+1;",
          "1767:    libraw_internal_data.unpacker_data.load_flags |= 256; // reset width/height in canon_sraw_load_raw()",
          "1768:    imgdata.sizes.raw_pitch = 8*imgdata.sizes.raw_width;",
          "1769:   }",
          "1770:   else if(imgdata.sizes.raw_width == 4032 && imgdata.sizes.raw_height == 3402 && !strcasecmp(imgdata.idata.model, \"EOS 80D\")) // 80D hardcoded",
          "1771:   {",
          "1772:    imgdata.sizes.raw_width = 4536;",
          "1773:    imgdata.sizes.left_margin = 28;",
          "1774:    imgdata.sizes.iwidth = imgdata.sizes.width = imgdata.sizes.raw_width - imgdata.sizes.left_margin;",
          "1775:    imgdata.sizes.raw_height = 3024;",
          "1776:    imgdata.sizes.top_margin = 8;",
          "1777:    imgdata.sizes.iheight = imgdata.sizes.height = imgdata.sizes.raw_height - imgdata.sizes.top_margin;",
          "1778:    libraw_internal_data.unpacker_data.load_flags |= 256;",
          "1779:    imgdata.sizes.raw_pitch = 8*imgdata.sizes.raw_width;",
          "1780:   }",
          "1781:  }",
          "1784:  if (!imgdata.idata.dng_version && !strcasecmp(imgdata.idata.make, \"Fujifilm\") && (load_raw == &LibRaw::unpacked_load_raw) )",
          "1785:  {",
          "1786:   if (imgdata.sizes.raw_width * imgdata.sizes.raw_height * 2 != libraw_internal_data.unpacker_data.data_size)",
          "1787:    parse_xtrans_header();",
          "1789:   if(imgdata.idata.filters == 9)",
          "1790:   {",
          "1792:    int newtm = imgdata.sizes.top_margin%6?(imgdata.sizes.top_margin/6+1)*6 : imgdata.sizes.top_margin;",
          "1793:    int newlm = imgdata.sizes.left_margin%6?(imgdata.sizes.left_margin/6+1)*6 : imgdata.sizes.left_margin;",
          "1794:    if(newtm != imgdata.sizes.top_margin || newlm != imgdata.sizes.left_margin)",
          "1795:    {",
          "1796:     imgdata.sizes.height -= (newtm - imgdata.sizes.top_margin);",
          "1797:     imgdata.sizes.top_margin = newtm;",
          "1798:     imgdata.sizes.width -= (newlm - imgdata.sizes.left_margin);",
          "1799:     imgdata.sizes.left_margin = newlm;",
          "1800:     for(int c = 0; c < 36; c++)",
          "1801:      imgdata.idata.xtrans[0][c] = imgdata.idata.xtrans_abs[0][c];",
          "1802:    }",
          "1803:   }",
          "1804:  }",
          "1807:     if(imgdata.idata.dng_version && (imgdata.idata.filters == 0) && imgdata.idata.colors > 1 && imgdata.idata.colors < 5)",
          "1809:  float delta[4]={0.f,0.f,0.f,0.f};",
          "1810:  for(int c = 0; c < imgdata.idata.colors ; c++ )",
          "1811:    delta[c] = imgdata.color.dng_levels.dng_whitelevel[c] - imgdata.color.dng_levels.dng_blacklevel[c];",
          "1812:  float mindelta = delta[0],maxdelta = delta[0];",
          "1813:  for(int c = 1; c < imgdata.idata.colors; c++)",
          "1814:    {",
          "1815:      if(mindelta > delta[c]) mindelta = delta[c];",
          "1816:      if(maxdelta < delta[c]) maxdelta = delta[c];",
          "1817:    }",
          "1818:  if(mindelta > 1 && maxdelta < (mindelta *20)) // safety",
          "1819:    {",
          "1820:      for(int c = 0; c < imgdata.idata.colors; c++)",
          "1821:        {",
          "1822:   imgdata.color.cam_mul[c] /= (delta[c]/maxdelta);",
          "1823:   imgdata.color.pre_mul[c] /= (delta[c]/maxdelta);",
          "1824:        }",
          "1825:      imgdata.color.maximum = imgdata.color.cblack[0]+maxdelta;",
          "1826:    }",
          "1829:     if(imgdata.idata.dng_version &&",
          "1830:       (",
          "1831:     (!strcasecmp(imgdata.idata.make,\"Leica\") && !strcasecmp(imgdata.idata.model,\"D-LUX (Typ 109)\"))",
          "1832:    ||",
          "1833:    (!strcasecmp(imgdata.idata.make,\"Panasonic\") && !strcasecmp(imgdata.idata.model,\"LX100\"))",
          "1834:  )",
          "1835:        )",
          "1838:  if (!strncasecmp(imgdata.idata.make, \"Sony\", 4) && imgdata.idata.dng_version)",
          "1839:  {",
          "1840:   if(S.raw_width == 3984) S.width = 3925;",
          "1841:   else if (S.raw_width == 4288) S.width = S.raw_width-32;",
          "1842:   else if (S.raw_width == 4928 && S.height < 3280) S.width = S.raw_width-8;",
          "1843:   else if (S.raw_width == 5504) S.width = S.raw_width-(S.height > 3664 ? 8 : 32);",
          "1844:   else if (S.raw_width == 6048)",
          "1845:   {",
          "1846:    S.width = S.raw_width-24;",
          "1847:    if (strstr(imgdata.idata.model,\"RX1\") || strstr(imgdata.idata.model,\"A99\")) S.width -= 6;",
          "1848:   }",
          "1849:   else if (S.raw_width == 7392) S.width = S.raw_width-30;",
          "1850:   else if(S.raw_width == 8000) S.width = S.raw_width - 32;",
          "1851:  }",
          "1853:  if(!strcasecmp(imgdata.idata.make,\"Pentax\") &&  /*!strcasecmp(imgdata.idata.model,\"K-3 II\")  &&*/ imgdata.idata.raw_count == 4 && (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_PENTAX_PS_ALLFRAMES))",
          "1854:  {",
          "1855:   imgdata.idata.raw_count = 1;",
          "1856:   imgdata.idata.filters = 0;",
          "1857:   imgdata.idata.colors = 4;",
          "1858:   IO.mix_green = 1;",
          "1859:   pentax_component_load_raw = load_raw;",
          "1860:   load_raw= &LibRaw::pentax_4shot_load_raw;",
          "1861:  }",
          "1863:  if (!imgdata.idata.dng_version && !strcmp(imgdata.idata.make, \"Leaf\") && !strcmp(imgdata.idata.model, \"Credo 50\"))",
          "1864:  {",
          "1865:   imgdata.color.pre_mul[0] = 1.f / 0.3984f;",
          "1866:   imgdata.color.pre_mul[2] = 1.f / 0.7666f;",
          "1867:   imgdata.color.pre_mul[1] = imgdata.color.pre_mul[3] = 1.0;",
          "1868:  }",
          "1871:  if(imgdata.idata.dng_version && !strcmp(imgdata.idata.make,\"Fujifilm\") && !strcmp(imgdata.idata.model,\"S3Pro\") && imgdata.sizes.raw_width == 4288 )",
          "1872:  {",
          "1873:   imgdata.sizes.left_margin++;",
          "1874:   imgdata.sizes.width--;",
          "1875:  }",
          "1876:  if(imgdata.idata.dng_version && !strcmp(imgdata.idata.make,\"Fujifilm\") && !strcmp(imgdata.idata.model,\"S5Pro\") && imgdata.sizes.raw_width == 4288 )",
          "1877:  {",
          "1878:   imgdata.sizes.left_margin++;",
          "1879:   imgdata.sizes.width--;",
          "1880:  }",
          "1881:  if(!imgdata.idata.dng_version && !strcmp(imgdata.idata.make,\"Fujifilm\")",
          "1882:            && (!strncmp(imgdata.idata.model,\"S20Pro\",6) || !strncmp(imgdata.idata.model,\"F700\",4))",
          "1883:            )",
          "1884:  {",
          "1885:           imgdata.sizes.raw_width/=2;",
          "1886:           load_raw= &LibRaw::unpacked_load_raw_fuji_f700s20;",
          "1887:  }",
          "1888:  if(load_raw == &LibRaw::packed_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\")",
          "1889:    && !libraw_internal_data.unpacker_data.load_flags",
          "1890:    && (!strncasecmp(imgdata.idata.model,\"D810\",4) || !strcasecmp(imgdata.idata.model,\"D4S\"))",
          "1891:    && libraw_internal_data.unpacker_data.data_size*2 == imgdata.sizes.raw_height*imgdata.sizes.raw_width*3)",
          "1892:  {",
          "1893:   libraw_internal_data.unpacker_data.load_flags = 80;",
          "1894:  }",
          "1896:     if(load_raw == &LibRaw::packed_load_raw && !strcasecmp(imgdata.idata.make,\"Sony\")) // 12 bit sony, but metadata may be for 14-bit range",
          "1898:         if(C.maximum>4095)",
          "1899:           C.maximum = 4095;",
          "1900:         if(C.black > 256 || C.cblack[0] > 256)",
          "1901:           {",
          "1902:             C.black /=4;",
          "1903:             for(int c=0; c< 4; c++)",
          "1904:               C.cblack[c]/=4;",
          "1905:             for(int c=0; c< C.cblack[4]*C.cblack[5];c++)",
          "1906:               C.cblack[6+c]/=4;",
          "1907:           }",
          "1909:     if(  load_raw == &LibRaw::nikon_yuv_load_raw  ) // Is it Nikon sRAW?",
          "1911:            load_raw= &LibRaw::nikon_load_sraw;",
          "1912:            C.black =0;",
          "1913:            memset(C.cblack,0,sizeof(C.cblack));",
          "1914:            imgdata.idata.filters = 0;",
          "1915:            libraw_internal_data.unpacker_data.tiff_samples=3;",
          "1916:            imgdata.idata.colors = 3;",
          "1917:            double beta_1 = -5.79342238397656E-02;",
          "1918:            double beta_2 = 3.28163551282665;",
          "1919:            double beta_3 = -8.43136004842678;",
          "1920:            double beta_4 = 1.03533181861023E+01;",
          "1921:            for(int i=0; i<=3072;i++)",
          "1922:            {",
          "1923:                double x = (double)i/3072.;",
          "1924:                double y = (1.-exp(-beta_1*x-beta_2*x*x-beta_3*x*x*x-beta_4*x*x*x*x));",
          "1925:                if(y<0.)y=0.;",
          "1926:                imgdata.color.curve[i] = (y*16383.);",
          "1927:            }",
          "1928:            for(int i=0;i<3;i++)",
          "1929:              for(int j=0;j<4;j++)",
          "1930:                imgdata.color.rgb_cam[i][j]=float(i==j);",
          "1933:     if((",
          "1934:         load_raw == &LibRaw::nikon_load_raw",
          "1935:         || load_raw == &LibRaw::packed_load_raw)",
          "1936:        && !strcasecmp(imgdata.idata.make,\"Nikon\")",
          "1937:        && strncmp(imgdata.idata.model,\"COOLPIX\",7)",
          "1939:        && libraw_internal_data.unpacker_data.tiff_bps == 12)",
          "1940:       {",
          "1941:         C.maximum = 4095;",
          "1942:         C.black /=4;",
          "1943:         for(int c=0; c< 4; c++)",
          "1944:           C.cblack[c]/=4;",
          "1945:         for(int c=0; c< C.cblack[4]*C.cblack[5];c++)",
          "1946:           C.cblack[6+c]/=4;",
          "1947:       }",
          "1950:     if (C.linear_max[0] < 0) {",
          "1951:       if (imgdata.idata.dng_version) {",
          "1952:           for (int c=0; c<4; c++)",
          "1953:             C.linear_max[c] = -1 * C.linear_max[c] + imgdata.color.cblack[c+6];",
          "1954:       } else {",
          "1955:           for (int c=0; c<4; c++)",
          "1956:             C.linear_max[c] = -1 * C.linear_max[c] + imgdata.color.cblack[c];",
          "1960:     if  (!strcasecmp(imgdata.idata.make,\"Nikon\") && (!C.linear_max[0]) && (C.maximum > 1024) && (load_raw != &LibRaw::nikon_load_sraw)) {",
          "1961:       C.linear_max[0] =",
          "1962:         C.linear_max[1] =",
          "1963:         C.linear_max[2] =",
          "1964:         C.linear_max[3] =",
          "1965:         (long) ((float)(C.maximum) / 1.07f);",
          "1969:     if  (!strcasecmp(imgdata.idata.make,\"Samsung\") && !strcasecmp(imgdata.idata.model,\"GX20\")) {",
          "1970:       C.WB_Coeffs[LIBRAW_WBI_Daylight][2] = (int) ((float) (C.WB_Coeffs[LIBRAW_WBI_Daylight][2]) * 2.56f);",
          "1971:       C.WB_Coeffs[LIBRAW_WBI_Shade][2] = (int) ((float) (C.WB_Coeffs[LIBRAW_WBI_Shade][2]) * 2.56f);",
          "1972:       C.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = (int) ((float) (C.WB_Coeffs[LIBRAW_WBI_Cloudy][2]) * 2.56f);",
          "1973:       C.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = (int) ((float) (C.WB_Coeffs[LIBRAW_WBI_Tungsten][2]) * 2.56f);",
          "1974:       C.WB_Coeffs[LIBRAW_WBI_FL_D][2] = (int) ((float) (C.WB_Coeffs[LIBRAW_WBI_FL_D][2]) * 2.56f);",
          "1975:       C.WB_Coeffs[LIBRAW_WBI_FL_N][2] = (int) ((float) (C.WB_Coeffs[LIBRAW_WBI_FL_N][2]) * 2.56f);",
          "1976:       C.WB_Coeffs[LIBRAW_WBI_FL_W][2] = (int) ((float) (C.WB_Coeffs[LIBRAW_WBI_FL_W][2]) * 2.56f);",
          "1977:       C.WB_Coeffs[LIBRAW_WBI_Flash][2] = (int) ((float) (C.WB_Coeffs[LIBRAW_WBI_Flash][2]) * 2.56f);",
          "1978:       for (int c=0; c<64; c++) {",
          "1979:         if (imgdata.color.WBCT_Coeffs[c][0] > 0.0f) {",
          "1986:     if(load_raw == &LibRaw::panasonic_load_raw && (!strcasecmp(imgdata.idata.make,\"Panasonic\") || !strcasecmp(imgdata.idata.make,\"Leica\") ||  !strcasecmp(imgdata.idata.make,\"YUNEEC\"))",
          "1987:        &&  ID.pana_black[0] && ID.pana_black[1] && ID.pana_black[2])",
          "1988:       {",
          "1989:         C.black=0;",
          "1990:         C.cblack[0] = ID.pana_black[0]+ID.pana_black[3];",
          "1991:         C.cblack[1] = C.cblack[3] = ID.pana_black[1]+ID.pana_black[3];",
          "1992:         C.cblack[2] = ID.pana_black[2]+ID.pana_black[3];",
          "1993:         int i = C.cblack[3];",
          "1994:         for(int c=0; c<3; c++) if(i>C.cblack[c]) i = C.cblack[c];",
          "1995:         for(int c=0; c< 4; c++) C.cblack[c]-=i;",
          "1996:         C.black = i;",
          "1997:       }",
          "2000:     if(load_raw == &LibRaw::x3f_load_raw)",
          "2002:         for(int i=0; i< foveon_count;i++)",
          "2003:             if(!strcasecmp(imgdata.idata.make,foveon_data[i].make) && !strcasecmp(imgdata.idata.model,foveon_data[i].model)",
          "2004:                 && imgdata.sizes.raw_width == foveon_data[i].raw_width",
          "2005:                 && imgdata.sizes.raw_height == foveon_data[i].raw_height",
          "2006:                 )",
          "2007:             {",
          "2008:                 imgdata.sizes.top_margin = foveon_data[i].top_margin;",
          "2009:                 imgdata.sizes.left_margin = foveon_data[i].left_margin;",
          "2010:                 imgdata.sizes.width = imgdata.sizes.iwidth = foveon_data[i].width;",
          "2011:                 imgdata.sizes.height = imgdata.sizes.iheight = foveon_data[i].height;",
          "2012:                 C.maximum = foveon_data[i].white;",
          "2013:                 break;",
          "2014:             }",
          "",
          "[Added Lines]",
          "1101:   if (!buffer || buffer == (void *)-1)",
          "1105:   try",
          "1106:   {",
          "1107:     stream = new LibRaw_buffer_datastream(buffer, size);",
          "1110:   {",
          "1111:     recycle();",
          "1112:     return LIBRAW_UNSUFFICIENT_MEMORY;",
          "1113:   }",
          "1114:   if (!stream->valid())",
          "1115:   {",
          "1116:     delete stream;",
          "1117:     return LIBRAW_IO_ERROR;",
          "1118:   }",
          "1122:   {",
          "1123:     ID.input_internal = 1; // flag to delete datastream on recycle",
          "1124:   }",
          "1126:   {",
          "1127:     delete stream;",
          "1128:     ID.input_internal = 0;",
          "1129:   }",
          "1134: inline unsigned int __DNG_HalfToFloat(ushort halfValue)",
          "1136:   int sign = (halfValue >> 15) & 0x00000001;",
          "1137:   int exponent = (halfValue >> 10) & 0x0000001f;",
          "1138:   int mantissa = halfValue & 0x000003ff;",
          "1139:   if (exponent == 0)",
          "1140:   {",
          "1141:     if (mantissa == 0)",
          "1142:     {",
          "1143:       return (unsigned int)(sign << 31);",
          "1144:     }",
          "1145:     else",
          "1146:     {",
          "1147:       while (!(mantissa & 0x00000400))",
          "1148:       {",
          "1149:         mantissa <<= 1;",
          "1150:         exponent -= 1;",
          "1151:       }",
          "1152:       exponent += 1;",
          "1153:       mantissa &= ~0x00000400;",
          "1154:     }",
          "1155:   }",
          "1156:   else if (exponent == 31)",
          "1157:   {",
          "1158:     if (mantissa == 0)",
          "1159:     {",
          "1160:       return (unsigned int)((sign << 31) | ((0x1eL + 127 - 15) << 23) | (0x3ffL << 13));",
          "1161:     }",
          "1162:     else",
          "1163:     {",
          "1164:       return 0;",
          "1165:     }",
          "1166:   }",
          "1167:   exponent += (127 - 15);",
          "1168:   mantissa <<= 13;",
          "1169:   return (unsigned int)((sign << 31) | (exponent << 23) | mantissa);",
          "1172: inline unsigned int __DNG_FP24ToFloat(const unsigned char *input)",
          "1174:   int sign = (input[0] >> 7) & 0x01;",
          "1175:   int exponent = (input[0]) & 0x7F;",
          "1176:   int mantissa = (((int)input[1]) << 8) | input[2];",
          "1177:   if (exponent == 0)",
          "1178:   {",
          "1179:     if (mantissa == 0)",
          "1180:     {",
          "1181:       return (unsigned int)(sign << 31);",
          "1182:     }",
          "1183:     else",
          "1184:     {",
          "1185:       while (!(mantissa & 0x00010000))",
          "1186:       {",
          "1187:         mantissa <<= 1;",
          "1188:         exponent -= 1;",
          "1189:       }",
          "1190:       exponent += 1;",
          "1191:       mantissa &= ~0x00010000;",
          "1192:     }",
          "1193:   }",
          "1194:   else if (exponent == 127)",
          "1195:   {",
          "1196:     if (mantissa == 0)",
          "1197:     {",
          "1198:       return (unsigned int)((sign << 31) | ((0x7eL + 128 - 64) << 23) | (0xffffL << 7));",
          "1199:     }",
          "1200:     else",
          "1201:     {",
          "1203:       return 0;",
          "1204:     }",
          "1205:   }",
          "1206:   exponent += (128 - 64);",
          "1207:   mantissa <<= 7;",
          "1208:   return (uint32_t)((sign << 31) | (exponent << 23) | mantissa);",
          "1211: inline void DecodeDeltaBytes(unsigned char *bytePtr, int cols, int channels)",
          "1213:   if (channels == 1)",
          "1214:   {",
          "1215:     unsigned char b0 = bytePtr[0];",
          "1216:     bytePtr += 1;",
          "1217:     for (uint32_t col = 1; col < cols; ++col)",
          "1218:     {",
          "1219:       b0 += bytePtr[0];",
          "1220:       bytePtr[0] = b0;",
          "1221:       bytePtr += 1;",
          "1222:     }",
          "1223:   }",
          "1224:   else if (channels == 3)",
          "1225:   {",
          "1226:     unsigned char b0 = bytePtr[0];",
          "1227:     unsigned char b1 = bytePtr[1];",
          "1228:     unsigned char b2 = bytePtr[2];",
          "1229:     bytePtr += 3;",
          "1230:     for (int col = 1; col < cols; ++col)",
          "1231:     {",
          "1232:       b0 += bytePtr[0];",
          "1233:       b1 += bytePtr[1];",
          "1234:       b2 += bytePtr[2];",
          "1235:       bytePtr[0] = b0;",
          "1236:       bytePtr[1] = b1;",
          "1237:       bytePtr[2] = b2;",
          "1238:       bytePtr += 3;",
          "1239:     }",
          "1240:   }",
          "1241:   else if (channels == 4)",
          "1242:   {",
          "1243:     unsigned char b0 = bytePtr[0];",
          "1244:     unsigned char b1 = bytePtr[1];",
          "1245:     unsigned char b2 = bytePtr[2];",
          "1246:     unsigned char b3 = bytePtr[3];",
          "1247:     bytePtr += 4;",
          "1248:     for (uint32_t col = 1; col < cols; ++col)",
          "1249:     {",
          "1250:       b0 += bytePtr[0];",
          "1251:       b1 += bytePtr[1];",
          "1252:       b2 += bytePtr[2];",
          "1253:       b3 += bytePtr[3];",
          "1254:       bytePtr[0] = b0;",
          "1255:       bytePtr[1] = b1;",
          "1256:       bytePtr[2] = b2;",
          "1257:       bytePtr[3] = b3;",
          "1258:       bytePtr += 4;",
          "1259:     }",
          "1260:   }",
          "1261:   else",
          "1262:   {",
          "1263:     for (int col = 1; col < cols; ++col)",
          "1264:     {",
          "1265:       for (int chan = 0; chan < channels; ++chan)",
          "1266:       {",
          "1267:         bytePtr[chan + channels] += bytePtr[chan];",
          "1268:       }",
          "1269:       bytePtr += channels;",
          "1270:     }",
          "1271:   }",
          "1274: static void DecodeFPDelta(unsigned char *input, unsigned char *output, int cols, int channels, int bytesPerSample)",
          "1276:   DecodeDeltaBytes(input, cols * bytesPerSample, channels);",
          "1277:   int32_t rowIncrement = cols * channels;",
          "1279:   if (bytesPerSample == 2)",
          "1280:   {",
          "1283:     const unsigned char *input0 = input;",
          "1284:     const unsigned char *input1 = input + rowIncrement;",
          "1286:     const unsigned char *input1 = input;",
          "1287:     const unsigned char *input0 = input + rowIncrement;",
          "1289:     for (int col = 0; col < rowIncrement; ++col)",
          "1290:     {",
          "1291:       output[0] = input0[col];",
          "1292:       output[1] = input1[col];",
          "1293:       output += 2;",
          "1294:     }",
          "1295:   }",
          "1296:   else if (bytesPerSample == 3)",
          "1297:   {",
          "1298:     const unsigned char *input0 = input;",
          "1299:     const unsigned char *input1 = input + rowIncrement;",
          "1300:     const unsigned char *input2 = input + rowIncrement * 2;",
          "1301:     for (int col = 0; col < rowIncrement; ++col)",
          "1302:     {",
          "1303:       output[0] = input0[col];",
          "1304:       output[1] = input1[col];",
          "1305:       output[2] = input2[col];",
          "1306:       output += 3;",
          "1307:     }",
          "1308:   }",
          "1309:   else",
          "1310:   {",
          "1312:     const unsigned char *input0 = input;",
          "1313:     const unsigned char *input1 = input + rowIncrement;",
          "1314:     const unsigned char *input2 = input + rowIncrement * 2;",
          "1315:     const unsigned char *input3 = input + rowIncrement * 3;",
          "1317:     const unsigned char *input3 = input;",
          "1318:     const unsigned char *input2 = input + rowIncrement;",
          "1319:     const unsigned char *input1 = input + rowIncrement * 2;",
          "1320:     const unsigned char *input0 = input + rowIncrement * 3;",
          "1322:     for (int col = 0; col < rowIncrement; ++col)",
          "1323:     {",
          "1324:       output[0] = input0[col];",
          "1325:       output[1] = input1[col];",
          "1326:       output[2] = input2[col];",
          "1327:       output[3] = input3[col];",
          "1328:       output += 4;",
          "1329:     }",
          "1330:   }",
          "1333: static float expandFloats(unsigned char *dst, int tileWidth, int bytesps)",
          "1335:   float max = 0.f;",
          "1336:   if (bytesps == 2)",
          "1337:   {",
          "1338:     uint16_t *dst16 = (ushort *)dst;",
          "1339:     uint32_t *dst32 = (unsigned int *)dst;",
          "1340:     float *f32 = (float *)dst;",
          "1341:     for (int index = tileWidth - 1; index >= 0; --index)",
          "1342:     {",
          "1343:       dst32[index] = __DNG_HalfToFloat(dst16[index]);",
          "1344:       max = MAX(max, f32[index]);",
          "1345:     }",
          "1346:   }",
          "1347:   else if (bytesps == 3)",
          "1348:   {",
          "1349:     uint8_t *dst8 = ((unsigned char *)dst) + (tileWidth - 1) * 3;",
          "1350:     uint32_t *dst32 = (unsigned int *)dst;",
          "1351:     float *f32 = (float *)dst;",
          "1352:     for (int index = tileWidth - 1; index >= 0; --index, dst8 -= 3)",
          "1353:     {",
          "1354:       dst32[index] = __DNG_FP24ToFloat(dst8);",
          "1355:       max = MAX(max, f32[index]);",
          "1356:     }",
          "1357:   }",
          "1358:   else if (bytesps == 4)",
          "1359:   {",
          "1360:     float *f32 = (float *)dst;",
          "1361:     for (int index = 0; index < tileWidth; index++)",
          "1362:       max = MAX(max, f32[index]);",
          "1363:   }",
          "1364:   return max;",
          "1369:   struct tiff_ifd_t *ifd = &tiff_ifd[0];",
          "1370:   while (ifd < &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds] &&",
          "1371:          ifd->offset != libraw_internal_data.unpacker_data.data_offset)",
          "1372:     ++ifd;",
          "1373:   if (ifd == &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds])",
          "1374:   {",
          "1375:     throw LIBRAW_EXCEPTION_DECODE_RAW;",
          "1376:   }",
          "1378:   float *float_raw_image = 0;",
          "1379:   float max = 0.f;",
          "1381:   if (ifd->samples != 1 && ifd->samples != 3 && ifd->samples != 4)",
          "1382:     throw LIBRAW_EXCEPTION_DECODE_RAW; // Only float deflated supported",
          "1384:   if (libraw_internal_data.unpacker_data.tiff_samples != ifd->samples)",
          "1385:     throw LIBRAW_EXCEPTION_DECODE_RAW; // Wrong IFD",
          "1387:   size_t tilesH = (imgdata.sizes.raw_width + libraw_internal_data.unpacker_data.tile_width - 1) /",
          "1388:                   libraw_internal_data.unpacker_data.tile_width;",
          "1389:   size_t tilesV = (imgdata.sizes.raw_height + libraw_internal_data.unpacker_data.tile_length - 1) /",
          "1390:                   libraw_internal_data.unpacker_data.tile_length;",
          "1391:   size_t tileCnt = tilesH * tilesV;",
          "1393:   if (ifd->sample_format == 3)",
          "1394:   { // Floating point data",
          "1395:     float_raw_image = (float *)calloc(tileCnt * libraw_internal_data.unpacker_data.tile_length *",
          "1396:                                           libraw_internal_data.unpacker_data.tile_width * ifd->samples,",
          "1397:                                       sizeof(float));",
          "1401:   }",
          "1402:   else",
          "1403:     throw LIBRAW_EXCEPTION_DECODE_RAW; // Only float deflated supported",
          "1405:   int xFactor;",
          "1406:   switch (ifd->predictor)",
          "1407:   {",
          "1408:   case 3:",
          "1409:   default:",
          "1410:     xFactor = 1;",
          "1411:     break;",
          "1412:   case 34894:",
          "1413:     xFactor = 2;",
          "1414:     break;",
          "1415:   case 34895:",
          "1416:     xFactor = 4;",
          "1417:     break;",
          "1418:   }",
          "1420:   if (libraw_internal_data.unpacker_data.tile_length < INT_MAX)",
          "1421:   {",
          "1422:     if (tileCnt < 1 || tileCnt > 1000000)",
          "1423:       throw LIBRAW_EXCEPTION_DECODE_RAW;",
          "1425:     size_t *tOffsets = (size_t *)malloc(tileCnt * sizeof(size_t));",
          "1426:     for (int t = 0; t < tileCnt; ++t)",
          "1427:       tOffsets[t] = get4();",
          "1429:     size_t *tBytes = (size_t *)malloc(tileCnt * sizeof(size_t));",
          "1430:     unsigned long maxBytesInTile = 0;",
          "1431:     if (tileCnt == 1)",
          "1432:       tBytes[0] = maxBytesInTile = ifd->bytes;",
          "1433:     else",
          "1434:     {",
          "1435:       libraw_internal_data.internal_data.input->seek(ifd->bytes, SEEK_SET);",
          "1436:       for (size_t t = 0; t < tileCnt; ++t)",
          "1437:       {",
          "1438:         tBytes[t] = get4();",
          "1439:         maxBytesInTile = MAX(maxBytesInTile, tBytes[t]);",
          "1440:       }",
          "1441:     }",
          "1442:     unsigned tilePixels =",
          "1443:         libraw_internal_data.unpacker_data.tile_width * libraw_internal_data.unpacker_data.tile_length;",
          "1444:     unsigned pixelSize = sizeof(float) * ifd->samples;",
          "1445:     unsigned tileBytes = tilePixels * pixelSize;",
          "1446:     unsigned tileRowBytes = libraw_internal_data.unpacker_data.tile_width * pixelSize;",
          "1448:     unsigned char *cBuffer = (unsigned char *)malloc(maxBytesInTile);",
          "1449:     unsigned char *uBuffer = (unsigned char *)malloc(tileBytes + tileRowBytes); // extra row for decoding",
          "1451:     for (size_t y = 0, t = 0; y < imgdata.sizes.raw_height; y += libraw_internal_data.unpacker_data.tile_length)",
          "1452:     {",
          "1453:       for (size_t x = 0; x < imgdata.sizes.raw_width; x += libraw_internal_data.unpacker_data.tile_width, ++t)",
          "1454:       {",
          "1455:         libraw_internal_data.internal_data.input->seek(tOffsets[t], SEEK_SET);",
          "1456:         libraw_internal_data.internal_data.input->read(cBuffer, 1, tBytes[t]);",
          "1457:         unsigned long dstLen = tileBytes;",
          "1458:         int err = uncompress(uBuffer + tileRowBytes, &dstLen, cBuffer, tBytes[t]);",
          "1459:         if (err != Z_OK)",
          "1460:         {",
          "1461:           free(tOffsets);",
          "1462:           free(tBytes);",
          "1463:           free(cBuffer);",
          "1464:           free(uBuffer);",
          "1465:           throw LIBRAW_EXCEPTION_DECODE_RAW;",
          "1466:           return;",
          "1467:         }",
          "1468:         else",
          "1469:         {",
          "1470:           int bytesps = ifd->bps >> 3;",
          "1471:           size_t rowsInTile = y + libraw_internal_data.unpacker_data.tile_length > imgdata.sizes.raw_height",
          "1472:                                   ? imgdata.sizes.raw_height - y",
          "1473:                                   : libraw_internal_data.unpacker_data.tile_length;",
          "1474:           size_t colsInTile = x + libraw_internal_data.unpacker_data.tile_width > imgdata.sizes.raw_width",
          "1475:                                   ? imgdata.sizes.raw_width - x",
          "1476:                                   : libraw_internal_data.unpacker_data.tile_width;",
          "1478:           for (size_t row = 0; row < rowsInTile; ++row) // do not process full tile if not needed",
          "1479:           {",
          "1480:             unsigned char *dst = uBuffer + row * libraw_internal_data.unpacker_data.tile_width * bytesps * ifd->samples;",
          "1481:             unsigned char *src = dst + tileRowBytes;",
          "1482:             DecodeFPDelta(src, dst, libraw_internal_data.unpacker_data.tile_width / xFactor, ifd->samples * xFactor,",
          "1483:                           bytesps);",
          "1484:             float lmax = expandFloats(dst, libraw_internal_data.unpacker_data.tile_width * ifd->samples, bytesps);",
          "1485:             max = MAX(max, lmax);",
          "1486:             unsigned char *dst2 =",
          "1487:                 (unsigned char *)&float_raw_image[((y + row) * imgdata.sizes.raw_width + x) * ifd->samples];",
          "1488:             memmove(dst2, dst, colsInTile * ifd->samples * sizeof(float));",
          "1489:           }",
          "1490:         }",
          "1491:       }",
          "1492:     }",
          "1493:     free(tOffsets);",
          "1494:     free(tBytes);",
          "1495:     free(cBuffer);",
          "1496:     free(uBuffer);",
          "1497:   }",
          "1498:   imgdata.color.fmaximum = max;",
          "1502:   imgdata.rawdata.raw_alloc = float_raw_image;",
          "1503:   if (ifd->samples == 1)",
          "1504:   {",
          "1505:     imgdata.rawdata.float_image = float_raw_image;",
          "1506:     imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 4;",
          "1507:   }",
          "1508:   else if (ifd->samples == 3)",
          "1509:   {",
          "1510:     imgdata.rawdata.float3_image = (float(*)[3])float_raw_image;",
          "1511:     imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 12;",
          "1512:   }",
          "1513:   else if (ifd->samples == 4)",
          "1514:   {",
          "1515:     imgdata.rawdata.float4_image = (float(*)[4])float_raw_image;",
          "1516:     imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 16;",
          "1517:   }",
          "1519:   if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_CONVERTFLOAT_TO_INT)",
          "1520:     convertFloatToInt(); // with default settings",
          "1522: #else",
          "1523: void LibRaw::deflate_dng_load_raw() { throw LIBRAW_EXCEPTION_DECODE_RAW; }",
          "1528:   struct tiff_ifd_t *ifd = &tiff_ifd[0];",
          "1529:   while (ifd < &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds] &&",
          "1530:          ifd->offset != libraw_internal_data.unpacker_data.data_offset)",
          "1531:     ++ifd;",
          "1532:   if (ifd == &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds])",
          "1533:     return 0;",
          "1535:   return ifd->sample_format == 3;",
          "1540:   return imgdata.rawdata.float_image || imgdata.rawdata.float3_image || imgdata.rawdata.float4_image;",
          "1543: void LibRaw::convertFloatToInt(float dmin /* =4096.f */, float dmax /* =32767.f */, float dtarget /*= 16383.f */)",
          "1545:   int samples = 0;",
          "1546:   float *data = 0;",
          "1547:   if (imgdata.rawdata.float_image)",
          "1548:   {",
          "1549:     samples = 1;",
          "1550:     data = imgdata.rawdata.float_image;",
          "1551:   }",
          "1552:   else if (imgdata.rawdata.float3_image)",
          "1553:   {",
          "1554:     samples = 3;",
          "1555:     data = (float *)imgdata.rawdata.float3_image;",
          "1556:   }",
          "1557:   else if (imgdata.rawdata.float4_image)",
          "1558:   {",
          "1559:     samples = 4;",
          "1560:     data = (float *)imgdata.rawdata.float4_image;",
          "1561:   }",
          "1562:   else",
          "1563:     return;",
          "1565:   ushort *raw_alloc = (ushort *)malloc(imgdata.sizes.raw_height * imgdata.sizes.raw_width *",
          "1566:                                        libraw_internal_data.unpacker_data.tiff_samples * sizeof(ushort));",
          "1567:   float tmax = MAX(imgdata.color.maximum, 1);",
          "1568:   float datamax = imgdata.color.fmaximum;",
          "1570:   tmax = MAX(tmax, datamax);",
          "1571:   tmax = MAX(tmax, 1.f);",
          "1573:   float multip = 1.f;",
          "1574:   if (tmax < dmin || tmax > dmax)",
          "1575:   {",
          "1576:     imgdata.rawdata.color.fnorm = imgdata.color.fnorm = multip = dtarget / tmax;",
          "1577:     imgdata.rawdata.color.maximum = imgdata.color.maximum = dtarget;",
          "1578:     imgdata.rawdata.color.black = imgdata.color.black = (float)imgdata.color.black * multip;",
          "1579:     for (int i = 0; i < sizeof(imgdata.color.cblack) / sizeof(imgdata.color.cblack[0]); i++)",
          "1580:       if (i != 4 && i != 5)",
          "1581:         imgdata.rawdata.color.cblack[i] = imgdata.color.cblack[i] = (float)imgdata.color.cblack[i] * multip;",
          "1582:   }",
          "1583:   else",
          "1584:     imgdata.rawdata.color.fnorm = imgdata.color.fnorm = 0.f;",
          "1586:   for (size_t i = 0;",
          "1587:        i < imgdata.sizes.raw_height * imgdata.sizes.raw_width * libraw_internal_data.unpacker_data.tiff_samples; ++i)",
          "1588:   {",
          "1589:     float val = MAX(data[i], 0.f);",
          "1590:     raw_alloc[i] = (ushort)(val * multip);",
          "1591:   }",
          "1593:   if (samples == 1)",
          "1594:   {",
          "1595:     imgdata.rawdata.raw_alloc = imgdata.rawdata.raw_image = raw_alloc;",
          "1596:     imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 2;",
          "1597:   }",
          "1598:   else if (samples == 3)",
          "1599:   {",
          "1600:     imgdata.rawdata.raw_alloc = imgdata.rawdata.color3_image = (ushort(*)[3])raw_alloc;",
          "1601:     imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 6;",
          "1602:   }",
          "1603:   else if (samples == 4)",
          "1604:   {",
          "1605:     imgdata.rawdata.raw_alloc = imgdata.rawdata.color4_image = (ushort(*)[4])raw_alloc;",
          "1606:     imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 8;",
          "1607:   }",
          "1608:   free(data); // remove old allocation",
          "1609:   imgdata.rawdata.float_image = 0;",
          "1610:   imgdata.rawdata.float3_image = 0;",
          "1611:   imgdata.rawdata.float4_image = 0;",
          "1616:   ushort *plane = (ushort *)malloc(imgdata.sizes.raw_width * imgdata.sizes.raw_height * sizeof(ushort));",
          "1617:   int alloc_sz = imgdata.sizes.raw_width * (imgdata.sizes.raw_height + 16) * 4 * sizeof(ushort);",
          "1618:   ushort(*result)[4] = (ushort(*)[4])malloc(alloc_sz);",
          "1619:   struct movement_t",
          "1620:   {",
          "1621:     int row, col;",
          "1622:   } _move[4] = {",
          "1623:       {1, 1}, {0, 1}, {0, 0}, {1, 0},",
          "1624:   };",
          "1626:   int tidx = 0;",
          "1627:   for (int i = 0; i < 4; i++)",
          "1628:   {",
          "1629:     int move_row, move_col;",
          "1630:     if (imgdata.params.p4shot_order[i] >= '0' && imgdata.params.p4shot_order[i] <= '3')",
          "1631:     {",
          "1632:       move_row = (imgdata.params.p4shot_order[i] - '0' & 2) ? 1 : 0;",
          "1633:       move_col = (imgdata.params.p4shot_order[i] - '0' & 1) ? 1 : 0;",
          "1634:     }",
          "1635:     else",
          "1636:     {",
          "1637:       move_row = _move[i].row;",
          "1638:       move_col = _move[i].col;",
          "1639:     }",
          "1640:     for (; tidx < 16; tidx++)",
          "1641:       if (tiff_ifd[tidx].t_width == imgdata.sizes.raw_width && tiff_ifd[tidx].t_height == imgdata.sizes.raw_height &&",
          "1642:           tiff_ifd[tidx].bps > 8 && tiff_ifd[tidx].samples == 1)",
          "1643:         break;",
          "1644:     if (tidx >= 16)",
          "1645:       break;",
          "1646:     imgdata.rawdata.raw_image = plane;",
          "1647:     ID.input->seek(tiff_ifd[tidx].offset, SEEK_SET);",
          "1648:     imgdata.idata.filters = 0xb4b4b4b4;",
          "1649:     libraw_internal_data.unpacker_data.data_offset = tiff_ifd[tidx].offset;",
          "1650:     (this->*pentax_component_load_raw)();",
          "1651:     for (int row = 0; row < imgdata.sizes.raw_height - move_row; row++)",
          "1652:     {",
          "1653:       int colors[2];",
          "1654:       for (int c = 0; c < 2; c++)",
          "1655:         colors[c] = COLOR(row, c);",
          "1656:       ushort *srcrow = &plane[imgdata.sizes.raw_width * row];",
          "1657:       ushort(*dstrow)[4] = &result[(imgdata.sizes.raw_width) * (row + move_row) + move_col];",
          "1658:       for (int col = 0; col < imgdata.sizes.raw_width - move_col; col++)",
          "1659:         dstrow[col][colors[col % 2]] = srcrow[col];",
          "1660:     }",
          "1661:     tidx++;",
          "1662:   }",
          "1664:   imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 8;",
          "1665:   imgdata.idata.filters = 0;",
          "1666:   imgdata.rawdata.raw_alloc = imgdata.rawdata.color4_image = result;",
          "1667:   free(plane);",
          "1668:   imgdata.rawdata.raw_image = 0;",
          "1675:   for (row = 0; row < S.height; row++)",
          "1676:     for (col = 0; col < S.width; col++)",
          "1677:     {",
          "1678:       read_shorts(&imgdata.image[row * S.width + col][2], 1); // B",
          "1679:       read_shorts(&imgdata.image[row * S.width + col][1], 1); // G",
          "1680:       read_shorts(&imgdata.image[row * S.width + col][0], 1); // R",
          "1681:     }",
          "1686:   int vbits = 0, bwide, rbits, bite, row, col, val, i;",
          "1688:   UINT64 bitbuf = 0;",
          "1689:   unsigned load_flags = 24; // libraw_internal_data.unpacker_data.load_flags;",
          "1690:   unsigned tiff_bps = libraw_internal_data.unpacker_data.tiff_bps;",
          "1691:   int tiff_compress = libraw_internal_data.unpacker_data.tiff_compress;",
          "1693:   struct tiff_ifd_t *ifd = &tiff_ifd[0];",
          "1694:   while (ifd < &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds] &&",
          "1695:          ifd->offset != libraw_internal_data.unpacker_data.data_offset)",
          "1696:     ++ifd;",
          "1697:   if (ifd == &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds])",
          "1698:     throw LIBRAW_EXCEPTION_DECODE_RAW;",
          "1700:   if (!ifd->rows_per_strip || !ifd->strip_offsets_count)",
          "1701:     return; // not unpacked",
          "1702:   int stripcnt = 0;",
          "1704:   bwide = S.raw_width * tiff_bps / 8;",
          "1705:   bwide += bwide & load_flags >> 7;",
          "1706:   rbits = bwide * 8 - S.raw_width * tiff_bps;",
          "1707:   if (load_flags & 1)",
          "1708:     bwide = bwide * 16 / 15;",
          "1709:   bite = 8 + (load_flags & 24);",
          "1710:   for (row = 0; row < S.raw_height; row++)",
          "1711:   {",
          "1712:     checkCancel();",
          "1713:     if (!(row % ifd->rows_per_strip))",
          "1714:     {",
          "1715:       if (stripcnt >= ifd->strip_offsets_count)",
          "1716:         return; // run out of data",
          "1717:       libraw_internal_data.internal_data.input->seek(ifd->strip_offsets[stripcnt], SEEK_SET);",
          "1718:       stripcnt++;",
          "1719:     }",
          "1720:     for (col = 0; col < S.raw_width; col++)",
          "1721:     {",
          "1722:       for (vbits -= tiff_bps; vbits < 0; vbits += bite)",
          "1723:       {",
          "1724:         bitbuf <<= bite;",
          "1725:         for (i = 0; i < bite; i += 8)",
          "1726:           bitbuf |= (unsigned)(libraw_internal_data.internal_data.input->get_char() << i);",
          "1727:       }",
          "1728:       imgdata.rawdata.raw_image[(row)*S.raw_width + (col)] = bitbuf << (64 - tiff_bps - vbits) >> (64 - tiff_bps);",
          "1729:     }",
          "1730:     vbits -= rbits;",
          "1731:   }",
          "1736:   const char *make;",
          "1737:   const char *model;",
          "1738:   const int raw_width, raw_height;",
          "1739:   const int white;",
          "1740:   const int left_margin, top_margin;",
          "1741:   const int width, height;",
          "1742: } foveon_data[] = {",
          "1743:     {\"Sigma\", \"SD9\", 2304, 1531, 12000, 20, 8, 2266, 1510},",
          "1744:     {\"Sigma\", \"SD9\", 1152, 763, 12000, 10, 2, 1132, 755},",
          "1745:     {\"Sigma\", \"SD10\", 2304, 1531, 12000, 20, 8, 2266, 1510},",
          "1746:     {\"Sigma\", \"SD10\", 1152, 763, 12000, 10, 2, 1132, 755},",
          "1747:     {\"Sigma\", \"SD14\", 2688, 1792, 14000, 18, 12, 2651, 1767},",
          "1748:     {\"Sigma\", \"SD14\", 2688, 896, 14000, 18, 6, 2651, 883}, // 2/3",
          "1749:     {\"Sigma\", \"SD14\", 1344, 896, 14000, 9, 6, 1326, 883},  // 1/2",
          "1750:     {\"Sigma\", \"SD15\", 2688, 1792, 2900, 18, 12, 2651, 1767},",
          "1751:     {\"Sigma\", \"SD15\", 2688, 896, 2900, 18, 6, 2651, 883}, // 2/3 ?",
          "1752:     {\"Sigma\", \"SD15\", 1344, 896, 2900, 9, 6, 1326, 883},  // 1/2 ?",
          "1753:     {\"Sigma\", \"DP1\", 2688, 1792, 2100, 18, 12, 2651, 1767},",
          "1754:     {\"Sigma\", \"DP1\", 2688, 896, 2100, 18, 6, 2651, 883}, // 2/3 ?",
          "1755:     {\"Sigma\", \"DP1\", 1344, 896, 2100, 9, 6, 1326, 883},  // 1/2 ?",
          "1756:     {\"Sigma\", \"DP1S\", 2688, 1792, 2200, 18, 12, 2651, 1767},",
          "1757:     {\"Sigma\", \"DP1S\", 2688, 896, 2200, 18, 6, 2651, 883}, // 2/3",
          "1758:     {\"Sigma\", \"DP1S\", 1344, 896, 2200, 9, 6, 1326, 883},  // 1/2",
          "1759:     {\"Sigma\", \"DP1X\", 2688, 1792, 3560, 18, 12, 2651, 1767},",
          "1760:     {\"Sigma\", \"DP1X\", 2688, 896, 3560, 18, 6, 2651, 883}, // 2/3",
          "1761:     {\"Sigma\", \"DP1X\", 1344, 896, 3560, 9, 6, 1326, 883},  // 1/2",
          "1762:     {\"Sigma\", \"DP2\", 2688, 1792, 2326, 13, 16, 2651, 1767},",
          "1763:     {\"Sigma\", \"DP2\", 2688, 896, 2326, 13, 8, 2651, 883}, // 2/3 ??",
          "1764:     {\"Sigma\", \"DP2\", 1344, 896, 2326, 7, 8, 1325, 883},  // 1/2 ??",
          "1765:     {\"Sigma\", \"DP2S\", 2688, 1792, 2300, 18, 12, 2651, 1767},",
          "1766:     {\"Sigma\", \"DP2S\", 2688, 896, 2300, 18, 6, 2651, 883}, // 2/3",
          "1767:     {\"Sigma\", \"DP2S\", 1344, 896, 2300, 9, 6, 1326, 883},  // 1/2",
          "1768:     {\"Sigma\", \"DP2X\", 2688, 1792, 2300, 18, 12, 2651, 1767},",
          "1769:     {\"Sigma\", \"DP2X\", 2688, 896, 2300, 18, 6, 2651, 883},           // 2/3",
          "1770:     {\"Sigma\", \"DP2X\", 1344, 896, 2300, 9, 6, 1325, 883},            // 1/2",
          "1771:     {\"Sigma\", \"SD1\", 4928, 3264, 3900, 12, 52, 4807, 3205},         // Full size",
          "1772:     {\"Sigma\", \"SD1\", 4928, 1632, 3900, 12, 26, 4807, 1603},         // 2/3 size",
          "1773:     {\"Sigma\", \"SD1\", 2464, 1632, 3900, 6, 26, 2403, 1603},          // 1/2 size",
          "1774:     {\"Sigma\", \"SD1 Merrill\", 4928, 3264, 3900, 12, 52, 4807, 3205}, // Full size",
          "1775:     {\"Sigma\", \"SD1 Merrill\", 4928, 1632, 3900, 12, 26, 4807, 1603}, // 2/3 size",
          "1776:     {\"Sigma\", \"SD1 Merrill\", 2464, 1632, 3900, 6, 26, 2403, 1603},  // 1/2 size",
          "1777:     {\"Sigma\", \"DP1 Merrill\", 4928, 3264, 3900, 12, 0, 4807, 3205},",
          "1778:     {\"Sigma\", \"DP1 Merrill\", 2464, 1632, 3900, 12, 0, 2403, 1603}, // 1/2 size",
          "1779:     {\"Sigma\", \"DP1 Merrill\", 4928, 1632, 3900, 12, 0, 4807, 1603}, // 2/3 size",
          "1780:     {\"Sigma\", \"DP2 Merrill\", 4928, 3264, 3900, 12, 0, 4807, 3205},",
          "1781:     {\"Sigma\", \"DP2 Merrill\", 2464, 1632, 3900, 12, 0, 2403, 1603}, // 1/2 size",
          "1782:     {\"Sigma\", \"DP2 Merrill\", 4928, 1632, 3900, 12, 0, 4807, 1603}, // 2/3 size",
          "1783:     {\"Sigma\", \"DP3 Merrill\", 4928, 3264, 3900, 12, 0, 4807, 3205},",
          "1784:     {\"Sigma\", \"DP3 Merrill\", 2464, 1632, 3900, 12, 0, 2403, 1603}, // 1/2 size",
          "1785:     {\"Sigma\", \"DP3 Merrill\", 4928, 1632, 3900, 12, 0, 4807, 1603}, // 2/3 size",
          "1786:     {\"Polaroid\", \"x530\", 1440, 1088, 2700, 10, 13, 1419, 1059},",
          "1788:     {\"Sigma\", \"dp3 Quattro\", 5888, 3672, 16383, 204, 24, 5446, 3624}, // full size",
          "1789:     {\"Sigma\", \"dp3 Quattro\", 2944, 1836, 16383, 102, 12, 2723, 1812}, // half size",
          "1790:     {\"Sigma\", \"dp2 Quattro\", 5888, 3672, 16383, 204, 24, 5446, 3624}, // full size",
          "1791:     {\"Sigma\", \"dp2 Quattro\", 2944, 1836, 16383, 102, 12, 2723, 1812}, // half size",
          "1792:     {\"Sigma\", \"dp1 Quattro\", 5888, 3672, 16383, 204, 24, 5446, 3624}, // full size",
          "1793:     {\"Sigma\", \"dp1 Quattro\", 2944, 1836, 16383, 102, 12, 2723, 1812}, // half size",
          "1794:     {\"Sigma\", \"dp0 Quattro\", 5888, 3672, 16383, 204, 24, 5446, 3624}, // full size",
          "1795:     {\"Sigma\", \"dp0 Quattro\", 2944, 1836, 16383, 102, 12, 2723, 1812}, // half size",
          "1797:     {\"Sigma\", \"sd Quattro\", 5888, 3776, 16383, 204, 76, 5446, 3624}, // full size",
          "1798:     {\"Sigma\", \"sd Quattro\", 2944, 1888, 16383, 102, 38, 2723, 1812}, // half size",
          "1800:     {\"Sigma\", \"sd Quattro H\", 6656, 4480, 16383, 224, 160, 6208, 4160}, // full size",
          "1801:     {\"Sigma\", \"sd Quattro H\", 3328, 2240, 16383, 112, 80, 3104, 2080},  // half size",
          "1802:     {\"Sigma\", \"sd Quattro H\", 5504, 3680, 16383, 0, 4, 5496, 3668},     // full size",
          "1803:     {\"Sigma\", \"sd Quattro H\", 2752, 1840, 16383, 0, 2, 2748, 1834},     // half size",
          "1805: const int foveon_count = sizeof(foveon_data) / sizeof(foveon_data[0]);",
          "1810:   if (!stream)",
          "1812:   if (!stream->valid())",
          "1816:   try",
          "1817:   {",
          "1823:     if (!strcasecmp(imgdata.idata.make, \"Canon\") && (load_raw == &LibRaw::canon_sraw_load_raw) &&",
          "1824:         imgdata.sizes.raw_width > 0)",
          "1825:     {",
          "1826:       float ratio = float(imgdata.sizes.raw_height) / float(imgdata.sizes.raw_width);",
          "1827:       if ((ratio < 0.57 || ratio > 0.75) && imgdata.makernotes.canon.SensorHeight > 1 &&",
          "1828:           imgdata.makernotes.canon.SensorWidth > 1)",
          "1829:       {",
          "1830:         imgdata.sizes.raw_width = imgdata.makernotes.canon.SensorWidth;",
          "1831:         imgdata.sizes.left_margin = imgdata.makernotes.canon.SensorLeftBorder;",
          "1832:         imgdata.sizes.iwidth = imgdata.sizes.width =",
          "1833:             imgdata.makernotes.canon.SensorRightBorder - imgdata.makernotes.canon.SensorLeftBorder + 1;",
          "1834:         imgdata.sizes.raw_height = imgdata.makernotes.canon.SensorHeight;",
          "1835:         imgdata.sizes.top_margin = imgdata.makernotes.canon.SensorTopBorder;",
          "1836:         imgdata.sizes.iheight = imgdata.sizes.height =",
          "1837:             imgdata.makernotes.canon.SensorBottomBorder - imgdata.makernotes.canon.SensorTopBorder + 1;",
          "1838:         libraw_internal_data.unpacker_data.load_flags |= 256; // reset width/height in canon_sraw_load_raw()",
          "1839:         imgdata.sizes.raw_pitch = 8 * imgdata.sizes.raw_width;",
          "1840:       }",
          "1841:       else if (imgdata.sizes.raw_width == 4032 && imgdata.sizes.raw_height == 3402 &&",
          "1842:                !strcasecmp(imgdata.idata.model, \"EOS 80D\")) // 80D hardcoded",
          "1843:       {",
          "1844:         imgdata.sizes.raw_width = 4536;",
          "1845:         imgdata.sizes.left_margin = 28;",
          "1846:         imgdata.sizes.iwidth = imgdata.sizes.width = imgdata.sizes.raw_width - imgdata.sizes.left_margin;",
          "1847:         imgdata.sizes.raw_height = 3024;",
          "1848:         imgdata.sizes.top_margin = 8;",
          "1849:         imgdata.sizes.iheight = imgdata.sizes.height = imgdata.sizes.raw_height - imgdata.sizes.top_margin;",
          "1850:         libraw_internal_data.unpacker_data.load_flags |= 256;",
          "1851:         imgdata.sizes.raw_pitch = 8 * imgdata.sizes.raw_width;",
          "1852:       }",
          "1853:     }",
          "1856:     if (!imgdata.idata.dng_version && !strcasecmp(imgdata.idata.make, \"Fujifilm\") &&",
          "1857:         (load_raw == &LibRaw::unpacked_load_raw))",
          "1858:     {",
          "1859:       if (imgdata.sizes.raw_width * imgdata.sizes.raw_height * 2 != libraw_internal_data.unpacker_data.data_size)",
          "1860:         parse_xtrans_header();",
          "1862:       if (imgdata.idata.filters == 9)",
          "1863:       {",
          "1865:         int newtm = imgdata.sizes.top_margin % 6 ? (imgdata.sizes.top_margin / 6 + 1) * 6 : imgdata.sizes.top_margin;",
          "1866:         int newlm = imgdata.sizes.left_margin % 6 ? (imgdata.sizes.left_margin / 6 + 1) * 6 : imgdata.sizes.left_margin;",
          "1867:         if (newtm != imgdata.sizes.top_margin || newlm != imgdata.sizes.left_margin)",
          "1868:         {",
          "1869:           imgdata.sizes.height -= (newtm - imgdata.sizes.top_margin);",
          "1870:           imgdata.sizes.top_margin = newtm;",
          "1871:           imgdata.sizes.width -= (newlm - imgdata.sizes.left_margin);",
          "1872:           imgdata.sizes.left_margin = newlm;",
          "1873:           for (int c = 0; c < 36; c++)",
          "1874:             imgdata.idata.xtrans[0][c] = imgdata.idata.xtrans_abs[0][c];",
          "1875:         }",
          "1876:       }",
          "1877:     }",
          "1880:     if (imgdata.idata.dng_version && (imgdata.idata.filters == 0) && imgdata.idata.colors > 1 &&",
          "1881:         imgdata.idata.colors < 5)",
          "1882:     {",
          "1883:       float delta[4] = {0.f, 0.f, 0.f, 0.f};",
          "1884:       for (int c = 0; c < imgdata.idata.colors; c++)",
          "1885:         delta[c] = imgdata.color.dng_levels.dng_whitelevel[c] - imgdata.color.dng_levels.dng_blacklevel[c];",
          "1886:       float mindelta = delta[0], maxdelta = delta[0];",
          "1887:       for (int c = 1; c < imgdata.idata.colors; c++)",
          "1888:       {",
          "1889:         if (mindelta > delta[c])",
          "1890:           mindelta = delta[c];",
          "1891:         if (maxdelta < delta[c])",
          "1892:           maxdelta = delta[c];",
          "1893:       }",
          "1894:       if (mindelta > 1 && maxdelta < (mindelta * 20)) // safety",
          "1896:         for (int c = 0; c < imgdata.idata.colors; c++)",
          "1897:         {",
          "1898:           imgdata.color.cam_mul[c] /= (delta[c] / maxdelta);",
          "1899:           imgdata.color.pre_mul[c] /= (delta[c] / maxdelta);",
          "1900:         }",
          "1901:         imgdata.color.maximum = imgdata.color.cblack[0] + maxdelta;",
          "1903:     }",
          "1905:     if (imgdata.idata.dng_version &&",
          "1906:         ((!strcasecmp(imgdata.idata.make, \"Leica\") && !strcasecmp(imgdata.idata.model, \"D-LUX (Typ 109)\")) ||",
          "1907:          (!strcasecmp(imgdata.idata.make, \"Panasonic\") && !strcasecmp(imgdata.idata.model, \"LX100\"))))",
          "1910:     if (!strncasecmp(imgdata.idata.make, \"Sony\", 4) && imgdata.idata.dng_version)",
          "1911:     {",
          "1912:       if (S.raw_width == 3984)",
          "1913:         S.width = 3925;",
          "1914:       else if (S.raw_width == 4288)",
          "1915:         S.width = S.raw_width - 32;",
          "1916:       else if (S.raw_width == 4928 && S.height < 3280)",
          "1917:         S.width = S.raw_width - 8;",
          "1918:       else if (S.raw_width == 5504)",
          "1919:         S.width = S.raw_width - (S.height > 3664 ? 8 : 32);",
          "1920:       else if (S.raw_width == 6048)",
          "1921:       {",
          "1922:         S.width = S.raw_width - 24;",
          "1923:         if (strstr(imgdata.idata.model, \"RX1\") || strstr(imgdata.idata.model, \"A99\"))",
          "1924:           S.width -= 6;",
          "1925:       }",
          "1926:       else if (S.raw_width == 7392)",
          "1927:         S.width = S.raw_width - 30;",
          "1928:       else if (S.raw_width == 8000)",
          "1929:         S.width = S.raw_width - 32;",
          "1930:     }",
          "1932:     if (!strcasecmp(imgdata.idata.make, \"Pentax\") &&",
          "1934:         (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_PENTAX_PS_ALLFRAMES))",
          "1935:     {",
          "1936:       imgdata.idata.raw_count = 1;",
          "1937:       imgdata.idata.filters = 0;",
          "1938:       imgdata.idata.colors = 4;",
          "1939:       IO.mix_green = 1;",
          "1940:       pentax_component_load_raw = load_raw;",
          "1941:       load_raw = &LibRaw::pentax_4shot_load_raw;",
          "1942:     }",
          "1944:     if (!imgdata.idata.dng_version && !strcmp(imgdata.idata.make, \"Leaf\") && !strcmp(imgdata.idata.model, \"Credo 50\"))",
          "1945:     {",
          "1946:       imgdata.color.pre_mul[0] = 1.f / 0.3984f;",
          "1947:       imgdata.color.pre_mul[2] = 1.f / 0.7666f;",
          "1948:       imgdata.color.pre_mul[1] = imgdata.color.pre_mul[3] = 1.0;",
          "1949:     }",
          "1952:     if (imgdata.idata.dng_version && !strcmp(imgdata.idata.make, \"Fujifilm\") && !strcmp(imgdata.idata.model, \"S3Pro\") &&",
          "1953:         imgdata.sizes.raw_width == 4288)",
          "1954:     {",
          "1955:       imgdata.sizes.left_margin++;",
          "1956:       imgdata.sizes.width--;",
          "1957:     }",
          "1958:     if (imgdata.idata.dng_version && !strcmp(imgdata.idata.make, \"Fujifilm\") && !strcmp(imgdata.idata.model, \"S5Pro\") &&",
          "1959:         imgdata.sizes.raw_width == 4288)",
          "1960:     {",
          "1961:       imgdata.sizes.left_margin++;",
          "1962:       imgdata.sizes.width--;",
          "1963:     }",
          "1964:     if (!imgdata.idata.dng_version && !strcmp(imgdata.idata.make, \"Fujifilm\") &&",
          "1965:         (!strncmp(imgdata.idata.model, \"S20Pro\", 6) || !strncmp(imgdata.idata.model, \"F700\", 4)))",
          "1966:     {",
          "1967:       imgdata.sizes.raw_width /= 2;",
          "1968:       load_raw = &LibRaw::unpacked_load_raw_fuji_f700s20;",
          "1969:     }",
          "1970:     if (load_raw == &LibRaw::packed_load_raw && !strcasecmp(imgdata.idata.make, \"Nikon\") &&",
          "1971:         !libraw_internal_data.unpacker_data.load_flags &&",
          "1972:         (!strncasecmp(imgdata.idata.model, \"D810\", 4) || !strcasecmp(imgdata.idata.model, \"D4S\")) &&",
          "1973:         libraw_internal_data.unpacker_data.data_size * 2 == imgdata.sizes.raw_height * imgdata.sizes.raw_width * 3)",
          "1974:     {",
          "1975:       libraw_internal_data.unpacker_data.load_flags = 80;",
          "1976:     }",
          "1978:     if (load_raw == &LibRaw::packed_load_raw &&",
          "1979:         !strcasecmp(imgdata.idata.make, \"Sony\")) // 12 bit sony, but metadata may be for 14-bit range",
          "1980:     {",
          "1981:       if (C.maximum > 4095)",
          "1982:         C.maximum = 4095;",
          "1983:       if (C.black > 256 || C.cblack[0] > 256)",
          "1985:         C.black /= 4;",
          "1986:         for (int c = 0; c < 4; c++)",
          "1987:           C.cblack[c] /= 4;",
          "1988:         for (int c = 0; c < C.cblack[4] * C.cblack[5]; c++)",
          "1989:           C.cblack[6 + c] /= 4;",
          "1991:     }",
          "1992:     if (load_raw == &LibRaw::nikon_yuv_load_raw) // Is it Nikon sRAW?",
          "1993:     {",
          "1994:       load_raw = &LibRaw::nikon_load_sraw;",
          "1995:       C.black = 0;",
          "1996:       memset(C.cblack, 0, sizeof(C.cblack));",
          "1997:       imgdata.idata.filters = 0;",
          "1998:       libraw_internal_data.unpacker_data.tiff_samples = 3;",
          "1999:       imgdata.idata.colors = 3;",
          "2000:       double beta_1 = -5.79342238397656E-02;",
          "2001:       double beta_2 = 3.28163551282665;",
          "2002:       double beta_3 = -8.43136004842678;",
          "2003:       double beta_4 = 1.03533181861023E+01;",
          "2004:       for (int i = 0; i <= 3072; i++)",
          "2006:         double x = (double)i / 3072.;",
          "2007:         double y = (1. - exp(-beta_1 * x - beta_2 * x * x - beta_3 * x * x * x - beta_4 * x * x * x * x));",
          "2008:         if (y < 0.)",
          "2009:           y = 0.;",
          "2010:         imgdata.color.curve[i] = (y * 16383.);",
          "2012:       for (int i = 0; i < 3; i++)",
          "2013:         for (int j = 0; j < 4; j++)",
          "2014:           imgdata.color.rgb_cam[i][j] = float(i == j);",
          "2015:     }",
          "2017:     if ((load_raw == &LibRaw::nikon_load_raw || load_raw == &LibRaw::packed_load_raw) &&",
          "2018:         !strcasecmp(imgdata.idata.make, \"Nikon\") && strncmp(imgdata.idata.model, \"COOLPIX\", 7)",
          "2020:         && libraw_internal_data.unpacker_data.tiff_bps == 12)",
          "2021:     {",
          "2022:       C.maximum = 4095;",
          "2023:       C.black /= 4;",
          "2024:       for (int c = 0; c < 4; c++)",
          "2025:         C.cblack[c] /= 4;",
          "2026:       for (int c = 0; c < C.cblack[4] * C.cblack[5]; c++)",
          "2027:         C.cblack[6 + c] /= 4;",
          "2028:     }",
          "2031:     if (C.linear_max[0] < 0)",
          "2032:     {",
          "2033:       if (imgdata.idata.dng_version)",
          "2034:       {",
          "2035:         for (int c = 0; c < 4; c++)",
          "2036:           C.linear_max[c] = -1 * C.linear_max[c] + imgdata.color.cblack[c + 6];",
          "2037:       }",
          "2038:       else",
          "2039:       {",
          "2040:         for (int c = 0; c < 4; c++)",
          "2041:           C.linear_max[c] = -1 * C.linear_max[c] + imgdata.color.cblack[c];",
          "2045:     if (!strcasecmp(imgdata.idata.make, \"Nikon\") && (!C.linear_max[0]) && (C.maximum > 1024) &&",
          "2046:         (load_raw != &LibRaw::nikon_load_sraw))",
          "2047:     {",
          "2048:       C.linear_max[0] = C.linear_max[1] = C.linear_max[2] = C.linear_max[3] = (long)((float)(C.maximum) / 1.07f);",
          "2052:     if (!strcasecmp(imgdata.idata.make, \"Samsung\") && !strcasecmp(imgdata.idata.model, \"GX20\"))",
          "2053:     {",
          "2054:       C.WB_Coeffs[LIBRAW_WBI_Daylight][2] = (int)((float)(C.WB_Coeffs[LIBRAW_WBI_Daylight][2]) * 2.56f);",
          "2055:       C.WB_Coeffs[LIBRAW_WBI_Shade][2] = (int)((float)(C.WB_Coeffs[LIBRAW_WBI_Shade][2]) * 2.56f);",
          "2056:       C.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = (int)((float)(C.WB_Coeffs[LIBRAW_WBI_Cloudy][2]) * 2.56f);",
          "2057:       C.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = (int)((float)(C.WB_Coeffs[LIBRAW_WBI_Tungsten][2]) * 2.56f);",
          "2058:       C.WB_Coeffs[LIBRAW_WBI_FL_D][2] = (int)((float)(C.WB_Coeffs[LIBRAW_WBI_FL_D][2]) * 2.56f);",
          "2059:       C.WB_Coeffs[LIBRAW_WBI_FL_N][2] = (int)((float)(C.WB_Coeffs[LIBRAW_WBI_FL_N][2]) * 2.56f);",
          "2060:       C.WB_Coeffs[LIBRAW_WBI_FL_W][2] = (int)((float)(C.WB_Coeffs[LIBRAW_WBI_FL_W][2]) * 2.56f);",
          "2061:       C.WB_Coeffs[LIBRAW_WBI_Flash][2] = (int)((float)(C.WB_Coeffs[LIBRAW_WBI_Flash][2]) * 2.56f);",
          "2062:       for (int c = 0; c < 64; c++)",
          "2063:       {",
          "2064:         if (imgdata.color.WBCT_Coeffs[c][0] > 0.0f)",
          "2065:         {",
          "2072:     if (load_raw == &LibRaw::panasonic_load_raw &&",
          "2073:         (!strcasecmp(imgdata.idata.make, \"Panasonic\") || !strcasecmp(imgdata.idata.make, \"Leica\") ||",
          "2074:          !strcasecmp(imgdata.idata.make, \"YUNEEC\")) &&",
          "2075:         ID.pana_black[0] && ID.pana_black[1] && ID.pana_black[2])",
          "2076:     {",
          "2077:       C.black = 0;",
          "2078:       C.cblack[0] = ID.pana_black[0] + ID.pana_black[3];",
          "2079:       C.cblack[1] = C.cblack[3] = ID.pana_black[1] + ID.pana_black[3];",
          "2080:       C.cblack[2] = ID.pana_black[2] + ID.pana_black[3];",
          "2081:       int i = C.cblack[3];",
          "2082:       for (int c = 0; c < 3; c++)",
          "2083:         if (i > C.cblack[c])",
          "2084:           i = C.cblack[c];",
          "2085:       for (int c = 0; c < 4; c++)",
          "2086:         C.cblack[c] -= i;",
          "2087:       C.black = i;",
          "2088:     }",
          "2091:     if (load_raw == &LibRaw::x3f_load_raw)",
          "2093:       for (int i = 0; i < foveon_count; i++)",
          "2094:         if (!strcasecmp(imgdata.idata.make, foveon_data[i].make) &&",
          "2095:             !strcasecmp(imgdata.idata.model, foveon_data[i].model) &&",
          "2096:             imgdata.sizes.raw_width == foveon_data[i].raw_width &&",
          "2097:             imgdata.sizes.raw_height == foveon_data[i].raw_height)",
          "2098:         {",
          "2099:           imgdata.sizes.top_margin = foveon_data[i].top_margin;",
          "2100:           imgdata.sizes.left_margin = foveon_data[i].left_margin;",
          "2101:           imgdata.sizes.width = imgdata.sizes.iwidth = foveon_data[i].width;",
          "2102:           imgdata.sizes.height = imgdata.sizes.iheight = foveon_data[i].height;",
          "2103:           C.maximum = foveon_data[i].white;",
          "2104:           break;",
          "2105:         }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2030:         printf(\"3 channel hassy found\\n\");",
          "2031:       }",
          "2032: #endif",
          "2042:     SET_PROC_FLAG(LIBRAW_PROGRESS_IDENTIFY);",
          "2043:   }",
          "2045:     EXCEPTION_HANDLER(err);",
          "2046:   }",
          "2048:     EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);",
          "2049:   }",
          "2052:     return LIBRAW_FILE_UNSUPPORTED;",
          "2055:   write_fun = &LibRaw::write_ppm_tiff;",
          "2057:   if (load_raw == &LibRaw::kodak_ycbcr_load_raw)",
          "2066:   S.iheight = (S.height + IO.shrink) >> IO.shrink;",
          "2075:   SET_PROC_FLAG(LIBRAW_PROGRESS_SIZE_ADJUST);",
          "2078:   return LIBRAW_SUCCESS;",
          "2079: }",
          "",
          "[Removed Lines]",
          "2033:     if(C.profile_length)",
          "2034:       {",
          "2035:         if(C.profile) free(C.profile);",
          "2036:         C.profile = malloc(C.profile_length);",
          "2037:         merror(C.profile,\"LibRaw::open_file()\");",
          "2038:         ID.input->seek(ID.profile_offset,SEEK_SET);",
          "2039:         ID.input->read(C.profile,C.profile_length,1);",
          "2040:       }",
          "2044:   catch ( LibRaw_exceptions err) {",
          "2047:   catch (std::exception ee) {",
          "2051:   if(P1.raw_count < 1)",
          "2058:     {",
          "2059:       S.height += S.height & 1;",
          "2060:       S.width  += S.width  & 1;",
          "2061:     }",
          "2063:   IO.shrink = P1.filters && (O.half_size ||",
          "2064:                              ((O.threshold || O.aber[0] != 1 || O.aber[2] != 1) ));",
          "2067:   S.iwidth  = (S.width  + IO.shrink) >> IO.shrink;",
          "2070:   memmove(&imgdata.rawdata.color,&imgdata.color,sizeof(imgdata.color));",
          "2071:   memmove(&imgdata.rawdata.sizes,&imgdata.sizes,sizeof(imgdata.sizes));",
          "2072:   memmove(&imgdata.rawdata.iparams,&imgdata.idata,sizeof(imgdata.idata));",
          "2073:   memmove(&imgdata.rawdata.ioparams,&libraw_internal_data.internal_output_params,sizeof(libraw_internal_data.internal_output_params));",
          "",
          "[Added Lines]",
          "2124:     if (C.profile_length)",
          "2125:     {",
          "2126:       if (C.profile)",
          "2127:         free(C.profile);",
          "2128:       C.profile = malloc(C.profile_length);",
          "2129:       merror(C.profile, \"LibRaw::open_file()\");",
          "2130:       ID.input->seek(ID.profile_offset, SEEK_SET);",
          "2131:       ID.input->read(C.profile, C.profile_length, 1);",
          "2132:     }",
          "2136:   catch (LibRaw_exceptions err)",
          "2137:   {",
          "2140:   catch (std::exception ee)",
          "2141:   {",
          "2145:   if (P1.raw_count < 1)",
          "2151:   {",
          "2152:     S.height += S.height & 1;",
          "2153:     S.width += S.width & 1;",
          "2154:   }",
          "2156:   IO.shrink = P1.filters && (O.half_size || ((O.threshold || O.aber[0] != 1 || O.aber[2] != 1)));",
          "2159:   S.iwidth = (S.width + IO.shrink) >> IO.shrink;",
          "2162:   memmove(&imgdata.rawdata.color, &imgdata.color, sizeof(imgdata.color));",
          "2163:   memmove(&imgdata.rawdata.sizes, &imgdata.sizes, sizeof(imgdata.sizes));",
          "2164:   memmove(&imgdata.rawdata.iparams, &imgdata.idata, sizeof(imgdata.idata));",
          "2165:   memmove(&imgdata.rawdata.ioparams, &libraw_internal_data.internal_output_params,",
          "2166:           sizeof(libraw_internal_data.internal_output_params));",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2087:     C.maximum = 0x3ff0;",
          "2088: }",
          "2089: #else",
          "2093: #endif",
          "2095: void LibRaw::clearCancelFlag()",
          "2096: {",
          "2097: #ifdef WIN32",
          "2099: #else",
          "2101: #endif",
          "2102: #ifdef RAWSPEED_FASTEXIT",
          "2108: #endif",
          "2110: }",
          "2112: void LibRaw::setCancelFlag()",
          "2113: {",
          "2114: #ifdef WIN32",
          "2116: #else",
          "2118: #endif",
          "2119: #ifdef RAWSPEED_FASTEXIT",
          "2125: #endif",
          "2126: }",
          "2128: void LibRaw::checkCancel()",
          "2129: {",
          "2130: #ifdef WIN32",
          "2132:     throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;",
          "2133: #else",
          "2135:     throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;",
          "2136: #endif",
          "2137: }",
          "",
          "[Removed Lines]",
          "2090: void LibRaw::fix_after_rawspeed(int)",
          "2091: {",
          "2092: }",
          "2098:  InterlockedExchange(&_exitflag, 0);",
          "2100:  __sync_fetch_and_and(&_exitflag, 0);",
          "2103:  if (_rawspeed_decoder)",
          "2104:  {",
          "2105:   RawDecoder *d = static_cast<RawDecoder*>(_rawspeed_decoder);",
          "2106:   d->resumeProcessing();",
          "2107:  }",
          "2115:   InterlockedExchange(&_exitflag,1);",
          "2117:   __sync_fetch_and_add(&_exitflag,1);",
          "2120:   if(_rawspeed_decoder)",
          "2121:     {",
          "2122:       RawDecoder *d = static_cast<RawDecoder*>(_rawspeed_decoder);",
          "2123:       d->cancelProcessing();",
          "2124:     }",
          "2131:   if(InterlockedExchange(&_exitflag,0))",
          "2134:   if( __sync_fetch_and_and(&_exitflag,0))",
          "",
          "[Added Lines]",
          "2182: void LibRaw::fix_after_rawspeed(int) {}",
          "2188:   InterlockedExchange(&_exitflag, 0);",
          "2190:   __sync_fetch_and_and(&_exitflag, 0);",
          "2193:   if (_rawspeed_decoder)",
          "2194:   {",
          "2195:     RawDecoder *d = static_cast<RawDecoder *>(_rawspeed_decoder);",
          "2196:     d->resumeProcessing();",
          "2197:   }",
          "2204:   InterlockedExchange(&_exitflag, 1);",
          "2206:   __sync_fetch_and_add(&_exitflag, 1);",
          "2209:   if (_rawspeed_decoder)",
          "2210:   {",
          "2211:     RawDecoder *d = static_cast<RawDecoder *>(_rawspeed_decoder);",
          "2212:     d->cancelProcessing();",
          "2213:   }",
          "2220:   if (InterlockedExchange(&_exitflag, 0))",
          "2223:   if (__sync_fetch_and_and(&_exitflag, 0))",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2139: int LibRaw::try_rawspeed()",
          "2140: {",
          "2141: #ifdef USE_RAWSPEED",
          "2247: #else",
          "2249: #endif",
          "2250: }",
          "2252: int LibRaw::valid_for_dngsdk()",
          "2253: {",
          "2254: #ifndef USE_DNGSDK",
          "2256: #else",
          "2280: #endif",
          "2281: }",
          "2284: int LibRaw::is_curve_linear()",
          "2285: {",
          "2290: }",
          "2293: int LibRaw::try_dngsdk()",
          "2294: {",
          "2295: #ifdef USE_DNGSDK",
          "2397: #else",
          "2399: #endif",
          "2400: }",
          "2401: void LibRaw::set_dng_host(void *p)",
          "2402: {",
          "2403: #ifdef USE_DNGSDK",
          "2405: #endif",
          "2406: }",
          "",
          "[Removed Lines]",
          "2142:  int ret=LIBRAW_SUCCESS;",
          "2144:  int rawspeed_ignore_errors = 0;",
          "2145:  if (imgdata.idata.dng_version && imgdata.idata.colors == 3 && !strcasecmp(imgdata.idata.software, \"Adobe Photoshop Lightroom 6.1.1 (Windows)\"))",
          "2146:   rawspeed_ignore_errors = 1;",
          "2149:   INT64 spos = ID.input->tell();",
          "2150:   void *_rawspeed_buffer = 0;",
          "2151:   try",
          "2152:   {",
          "2154:    ID.input->seek(0,SEEK_SET);",
          "2155:    INT64 _rawspeed_buffer_sz = ID.input->size()+32;",
          "2156:    _rawspeed_buffer = malloc(_rawspeed_buffer_sz);",
          "2157:    if(!_rawspeed_buffer) throw LIBRAW_EXCEPTION_ALLOC;",
          "2158:    ID.input->read(_rawspeed_buffer,_rawspeed_buffer_sz,1);",
          "2159:    FileMap map((uchar8*)_rawspeed_buffer,_rawspeed_buffer_sz);",
          "2160:    RawParser t(&map);",
          "2161:    RawDecoder *d = 0;",
          "2162:    CameraMetaDataLR *meta = static_cast<CameraMetaDataLR*>(_rawspeed_camerameta);",
          "2163:    d = t.getDecoder();",
          "2164:    if(!d) throw \"Unable to find decoder\";",
          "2165:    try {",
          "2166:     d->checkSupport(meta);",
          "2167:    }",
          "2168:    catch (const RawDecoderException& e)",
          "2169:    {",
          "2170:     imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_UNSUPPORTED;",
          "2171:     throw e;",
          "2172:    }",
          "2173:    d->interpolateBadPixels = FALSE;",
          "2174:    d->applyStage1DngOpcodes = FALSE;",
          "2175:    _rawspeed_decoder = static_cast<void*>(d);",
          "2176:    d->decodeRaw();",
          "2177:    d->decodeMetaData(meta);",
          "2178:    RawImage r = d->mRaw;",
          "2179:    if( r->errors.size()>0 && !rawspeed_ignore_errors)",
          "2180:    {",
          "2181:     delete d;",
          "2182:     _rawspeed_decoder = 0;",
          "2183:     throw 1;",
          "2184:    }",
          "2185:    if (r->isCFA)",
          "2186:    {",
          "2187:     imgdata.rawdata.raw_image = (ushort*) r->getDataUncropped(0,0);",
          "2188:    }",
          "2189:    else if(r->getCpp()==4)",
          "2190:    {",
          "2191:     imgdata.rawdata.color4_image = (ushort(*)[4]) r->getDataUncropped(0,0);",
          "2192:     if(r->whitePoint > 0 && r->whitePoint < 65536)",
          "2193:      C.maximum = r->whitePoint;",
          "2194:    } else if(r->getCpp() == 3)",
          "2195:    {",
          "2196:     imgdata.rawdata.color3_image = (ushort(*)[3]) r->getDataUncropped(0,0);",
          "2197:     if(r->whitePoint > 0 && r->whitePoint < 65536)",
          "2198:      C.maximum = r->whitePoint;",
          "2199:    }",
          "2200:    else",
          "2201:    {",
          "2202:     delete d;",
          "2203:     _rawspeed_decoder = 0;",
          "2204:     ret = LIBRAW_UNSPECIFIED_ERROR;",
          "2205:    }",
          "2206:    if(_rawspeed_decoder)",
          "2207:    {",
          "2209:     iPoint2D rsdim = r->getUncroppedDim();",
          "2210:     S.raw_pitch = r->pitch;",
          "2211:     S.raw_width = rsdim.x;",
          "2212:     S.raw_height = rsdim.y;",
          "2214:     fix_after_rawspeed(r->blackLevel);",
          "2215:    }",
          "2216:    free(_rawspeed_buffer);",
          "2217:    _rawspeed_buffer = 0;",
          "2218:    imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROCESSED;",
          "2219:   }",
          "2220:   catch (const RawDecoderException& RDE)",
          "2221:   {",
          "2222:    imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROBLEM;",
          "2223:    if (_rawspeed_buffer)",
          "2224:    {",
          "2225:     free(_rawspeed_buffer);",
          "2226:     _rawspeed_buffer = 0;",
          "2227:    }",
          "2228:    const char *p = RDE.what();",
          "2229:    if (!strncmp(RDE.what(), \"Decoder canceled\", strlen(\"Decoder canceled\")))",
          "2230:     throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;",
          "2231:    ret = LIBRAW_UNSPECIFIED_ERROR;",
          "2232:   }",
          "2233:   catch (...)",
          "2234:   {",
          "2236:    imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROBLEM;",
          "2237:    if(_rawspeed_buffer)",
          "2238:    {",
          "2239:     free(_rawspeed_buffer);",
          "2240:     _rawspeed_buffer = 0;",
          "2241:    }",
          "2242:    ret = LIBRAW_UNSPECIFIED_ERROR;",
          "2243:   }",
          "2244:   ID.input->seek(spos,SEEK_SET);",
          "2246:  return ret;",
          "2248:  return LIBRAW_NOT_IMPLEMENTED;",
          "2255:  return 0;",
          "2257:  if(!imgdata.idata.dng_version)",
          "2258:   return 0;",
          "2259:  if(!imgdata.params.use_dngsdk)",
          "2260:   return 0;",
          "2261:  if (load_raw == &LibRaw::lossy_dng_load_raw)",
          "2262:   return 0;",
          "2263:  if(is_floating_point() && (imgdata.params.use_dngsdk & LIBRAW_DNG_FLOAT))",
          "2264:   return 1;",
          "2265:  if(!imgdata.idata.filters && (imgdata.params.use_dngsdk & LIBRAW_DNG_LINEAR))",
          "2266:   return 1;",
          "2267:  if(libraw_internal_data.unpacker_data.tiff_bps == 8 && (imgdata.params.use_dngsdk & LIBRAW_DNG_8BIT))",
          "2268:   return 1;",
          "2269:  if(libraw_internal_data.unpacker_data.tiff_compress == 8 && (imgdata.params.use_dngsdk & LIBRAW_DNG_DEFLATE))",
          "2270:   return 1;",
          "2271:  if(libraw_internal_data.unpacker_data.tiff_samples == 2 )",
          "2272:   return 0; // Always deny 2-samples (old fuji superccd)",
          "2273:  if(imgdata.idata.filters == 9 && (imgdata.params.use_dngsdk & LIBRAW_DNG_XTRANS))",
          "2274:   return 1;",
          "2275:  if(is_fuji_rotated())",
          "2276:   return 0; // refuse",
          "2277:  if(imgdata.params.use_dngsdk & LIBRAW_DNG_OTHER)",
          "2278:   return 1;",
          "2279:  return 0;",
          "2286:  for (int i=0; i < 0x10000; i++)",
          "2287:   if(imgdata.color.curve[i] != i)",
          "2288:    return 0;",
          "2289:  return 1;",
          "2296:  if(!dnghost)",
          "2297:   return LIBRAW_UNSPECIFIED_ERROR;",
          "2299:  dng_host *host = static_cast<dng_host*>(dnghost);",
          "2301:  try",
          "2302:  {",
          "2303:   libraw_dng_stream stream(libraw_internal_data.internal_data.input);",
          "2305:   AutoPtr<dng_negative> negative;",
          "2306:   negative.Reset (host->Make_dng_negative ());",
          "2308:   dng_info info;",
          "2309:   info.Parse (*host, stream);",
          "2310:   info.PostParse (*host);",
          "2312:   if (!info.IsValidDNG ())",
          "2313:   {",
          "2314:    return LIBRAW_DATA_ERROR;",
          "2315:   }",
          "2316:   negative->Parse (*host, stream, info);",
          "2317:   negative->PostParse (*host, stream, info);",
          "2318:   negative->ReadStage1Image (*host, stream, info);",
          "2319:   dng_simple_image *stage2 = (dng_simple_image *)negative->Stage1Image ();",
          "2320:   if(stage2->Bounds().W() != S.raw_width || stage2->Bounds().H()!= S.raw_height)",
          "2321:   {",
          "2322:    return LIBRAW_DATA_ERROR;",
          "2323:   }",
          "2325:   int pplanes = stage2->Planes();",
          "2326:   int ptype = stage2->PixelType();",
          "2328:   dng_pixel_buffer buffer;",
          "2329:   stage2->GetPixelBuffer(buffer);",
          "2331:   int pixels =  stage2->Bounds().H () * stage2->Bounds().W () * pplanes;",
          "2332:   if(ptype == ttByte )",
          "2333:    imgdata.rawdata.raw_alloc = malloc(pixels * TagTypeSize(ttShort));",
          "2334:   else",
          "2335:    imgdata.rawdata.raw_alloc = malloc(pixels * TagTypeSize(ptype));",
          "2337:   if(ptype == ttShort && !is_curve_linear())",
          "2338:   {",
          "2339:    ushort *src = (ushort *)buffer.fData;",
          "2340:    ushort *dst = (ushort*)imgdata.rawdata.raw_alloc;",
          "2341:    for(int i = 0; i < pixels; i++)",
          "2342:     dst[i] = imgdata.color.curve[src[i]];",
          "2343:    S.raw_pitch = S.raw_width*pplanes*TagTypeSize(ptype);",
          "2344:   }",
          "2345:   else if(ptype == ttByte)",
          "2346:   {",
          "2347:    unsigned char *src = (unsigned char *)buffer.fData;",
          "2348:    ushort *dst = (ushort*)imgdata.rawdata.raw_alloc;",
          "2349:    if(is_curve_linear())",
          "2350:    {",
          "2351:     for(int i = 0; i < pixels; i++)",
          "2352:      dst[i] = src[i];",
          "2353:    }",
          "2354:    else",
          "2355:    {",
          "2356:     for(int i = 0; i < pixels; i++)",
          "2357:      dst[i] = imgdata.color.curve[src[i]];",
          "2358:    }",
          "2359:    S.raw_pitch = S.raw_width*pplanes*TagTypeSize(ttShort);",
          "2360:   }",
          "2361:   else",
          "2362:   {",
          "2363:    memmove(imgdata.rawdata.raw_alloc,buffer.fData,pixels * TagTypeSize(ptype));",
          "2364:    S.raw_pitch = S.raw_width*pplanes*TagTypeSize(ptype);",
          "2365:   }",
          "2367:   switch(ptype)",
          "2368:   {",
          "2369:   case ttFloat:",
          "2370:    if(pplanes==1)",
          "2371:     imgdata.rawdata.float_image = (float*)imgdata.rawdata.raw_alloc;",
          "2372:    else if(pplanes == 3)",
          "2373:     imgdata.rawdata.float3_image = (float (*)[3])imgdata.rawdata.raw_alloc;",
          "2374:    else if(pplanes == 4)",
          "2375:     imgdata.rawdata.float4_image = (float (*)[4])imgdata.rawdata.raw_alloc;",
          "2376:    break;",
          "2378:   case ttByte:",
          "2379:   case ttShort:",
          "2380:    if(pplanes==1)",
          "2381:     imgdata.rawdata.raw_image = (ushort*)imgdata.rawdata.raw_alloc;",
          "2382:    else if(pplanes == 3)",
          "2383:     imgdata.rawdata.color3_image = (ushort(*)[3])imgdata.rawdata.raw_alloc;",
          "2384:    else if(pplanes == 4)",
          "2385:     imgdata.rawdata.color4_image = (ushort(*)[4])imgdata.rawdata.raw_alloc;",
          "2386:    break;",
          "2387:   default:",
          "2389:    break;",
          "2390:   }",
          "2391:  }",
          "2392:  catch (...)",
          "2393:  {",
          "2394:   return LIBRAW_UNSPECIFIED_ERROR;",
          "2395:  }",
          "2396:  return imgdata.rawdata.raw_alloc?LIBRAW_SUCCESS:LIBRAW_UNSPECIFIED_ERROR;",
          "2398:  return LIBRAW_UNSPECIFIED_ERROR;",
          "2404:  dnghost = p;",
          "",
          "[Added Lines]",
          "2231:   int ret = LIBRAW_SUCCESS;",
          "2233:   int rawspeed_ignore_errors = 0;",
          "2234:   if (imgdata.idata.dng_version && imgdata.idata.colors == 3 &&",
          "2235:       !strcasecmp(imgdata.idata.software, \"Adobe Photoshop Lightroom 6.1.1 (Windows)\"))",
          "2236:     rawspeed_ignore_errors = 1;",
          "2239:   INT64 spos = ID.input->tell();",
          "2240:   void *_rawspeed_buffer = 0;",
          "2241:   try",
          "2242:   {",
          "2244:     ID.input->seek(0, SEEK_SET);",
          "2245:     INT64 _rawspeed_buffer_sz = ID.input->size() + 32;",
          "2246:     _rawspeed_buffer = malloc(_rawspeed_buffer_sz);",
          "2247:     if (!_rawspeed_buffer)",
          "2248:       throw LIBRAW_EXCEPTION_ALLOC;",
          "2249:     ID.input->read(_rawspeed_buffer, _rawspeed_buffer_sz, 1);",
          "2250:     FileMap map((uchar8 *)_rawspeed_buffer, _rawspeed_buffer_sz);",
          "2251:     RawParser t(&map);",
          "2252:     RawDecoder *d = 0;",
          "2253:     CameraMetaDataLR *meta = static_cast<CameraMetaDataLR *>(_rawspeed_camerameta);",
          "2254:     d = t.getDecoder();",
          "2255:     if (!d)",
          "2256:       throw \"Unable to find decoder\";",
          "2257:     try",
          "2258:     {",
          "2259:       d->checkSupport(meta);",
          "2260:     }",
          "2261:     catch (const RawDecoderException &e)",
          "2262:     {",
          "2263:       imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_UNSUPPORTED;",
          "2264:       throw e;",
          "2265:     }",
          "2266:     d->interpolateBadPixels = FALSE;",
          "2267:     d->applyStage1DngOpcodes = FALSE;",
          "2268:     _rawspeed_decoder = static_cast<void *>(d);",
          "2269:     d->decodeRaw();",
          "2270:     d->decodeMetaData(meta);",
          "2271:     RawImage r = d->mRaw;",
          "2272:     if (r->errors.size() > 0 && !rawspeed_ignore_errors)",
          "2273:     {",
          "2274:       delete d;",
          "2275:       _rawspeed_decoder = 0;",
          "2276:       throw 1;",
          "2277:     }",
          "2278:     if (r->isCFA)",
          "2279:     {",
          "2280:       imgdata.rawdata.raw_image = (ushort *)r->getDataUncropped(0, 0);",
          "2281:     }",
          "2282:     else if (r->getCpp() == 4)",
          "2283:     {",
          "2284:       imgdata.rawdata.color4_image = (ushort(*)[4])r->getDataUncropped(0, 0);",
          "2285:       if (r->whitePoint > 0 && r->whitePoint < 65536)",
          "2286:         C.maximum = r->whitePoint;",
          "2287:     }",
          "2288:     else if (r->getCpp() == 3)",
          "2289:     {",
          "2290:       imgdata.rawdata.color3_image = (ushort(*)[3])r->getDataUncropped(0, 0);",
          "2291:       if (r->whitePoint > 0 && r->whitePoint < 65536)",
          "2292:         C.maximum = r->whitePoint;",
          "2293:     }",
          "2294:     else",
          "2295:     {",
          "2296:       delete d;",
          "2297:       _rawspeed_decoder = 0;",
          "2298:       ret = LIBRAW_UNSPECIFIED_ERROR;",
          "2299:     }",
          "2300:     if (_rawspeed_decoder)",
          "2301:     {",
          "2303:       iPoint2D rsdim = r->getUncroppedDim();",
          "2304:       S.raw_pitch = r->pitch;",
          "2305:       S.raw_width = rsdim.x;",
          "2306:       S.raw_height = rsdim.y;",
          "2308:       fix_after_rawspeed(r->blackLevel);",
          "2309:     }",
          "2310:     free(_rawspeed_buffer);",
          "2311:     _rawspeed_buffer = 0;",
          "2312:     imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROCESSED;",
          "2313:   }",
          "2314:   catch (const RawDecoderException &RDE)",
          "2315:   {",
          "2316:     imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROBLEM;",
          "2317:     if (_rawspeed_buffer)",
          "2318:     {",
          "2319:       free(_rawspeed_buffer);",
          "2320:       _rawspeed_buffer = 0;",
          "2321:     }",
          "2322:     const char *p = RDE.what();",
          "2323:     if (!strncmp(RDE.what(), \"Decoder canceled\", strlen(\"Decoder canceled\")))",
          "2324:       throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;",
          "2325:     ret = LIBRAW_UNSPECIFIED_ERROR;",
          "2326:   }",
          "2327:   catch (...)",
          "2328:   {",
          "2330:     imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROBLEM;",
          "2331:     if (_rawspeed_buffer)",
          "2332:     {",
          "2333:       free(_rawspeed_buffer);",
          "2334:       _rawspeed_buffer = 0;",
          "2335:     }",
          "2336:     ret = LIBRAW_UNSPECIFIED_ERROR;",
          "2337:   }",
          "2338:   ID.input->seek(spos, SEEK_SET);",
          "2340:   return ret;",
          "2342:   return LIBRAW_NOT_IMPLEMENTED;",
          "2349:   return 0;",
          "2351:   if (!imgdata.idata.dng_version)",
          "2352:     return 0;",
          "2353:   if (!imgdata.params.use_dngsdk)",
          "2354:     return 0;",
          "2355:   if (load_raw == &LibRaw::lossy_dng_load_raw)",
          "2356:     return 0;",
          "2357:   if (is_floating_point() && (imgdata.params.use_dngsdk & LIBRAW_DNG_FLOAT))",
          "2358:     return 1;",
          "2359:   if (!imgdata.idata.filters && (imgdata.params.use_dngsdk & LIBRAW_DNG_LINEAR))",
          "2360:     return 1;",
          "2361:   if (libraw_internal_data.unpacker_data.tiff_bps == 8 && (imgdata.params.use_dngsdk & LIBRAW_DNG_8BIT))",
          "2362:     return 1;",
          "2363:   if (libraw_internal_data.unpacker_data.tiff_compress == 8 && (imgdata.params.use_dngsdk & LIBRAW_DNG_DEFLATE))",
          "2364:     return 1;",
          "2365:   if (libraw_internal_data.unpacker_data.tiff_samples == 2)",
          "2366:     return 0; // Always deny 2-samples (old fuji superccd)",
          "2367:   if (imgdata.idata.filters == 9 && (imgdata.params.use_dngsdk & LIBRAW_DNG_XTRANS))",
          "2368:     return 1;",
          "2369:   if (is_fuji_rotated())",
          "2370:     return 0; // refuse",
          "2371:   if (imgdata.params.use_dngsdk & LIBRAW_DNG_OTHER)",
          "2372:     return 1;",
          "2373:   return 0;",
          "2379:   for (int i = 0; i < 0x10000; i++)",
          "2380:     if (imgdata.color.curve[i] != i)",
          "2381:       return 0;",
          "2382:   return 1;",
          "2388:   if (!dnghost)",
          "2389:     return LIBRAW_UNSPECIFIED_ERROR;",
          "2391:   dng_host *host = static_cast<dng_host *>(dnghost);",
          "2393:   try",
          "2394:   {",
          "2395:     libraw_dng_stream stream(libraw_internal_data.internal_data.input);",
          "2397:     AutoPtr<dng_negative> negative;",
          "2398:     negative.Reset(host->Make_dng_negative());",
          "2400:     dng_info info;",
          "2401:     info.Parse(*host, stream);",
          "2402:     info.PostParse(*host);",
          "2404:     if (!info.IsValidDNG())",
          "2405:     {",
          "2406:       return LIBRAW_DATA_ERROR;",
          "2407:     }",
          "2408:     negative->Parse(*host, stream, info);",
          "2409:     negative->PostParse(*host, stream, info);",
          "2410:     negative->ReadStage1Image(*host, stream, info);",
          "2411:     dng_simple_image *stage2 = (dng_simple_image *)negative->Stage1Image();",
          "2412:     if (stage2->Bounds().W() != S.raw_width || stage2->Bounds().H() != S.raw_height)",
          "2413:     {",
          "2414:       return LIBRAW_DATA_ERROR;",
          "2415:     }",
          "2417:     int pplanes = stage2->Planes();",
          "2418:     int ptype = stage2->PixelType();",
          "2420:     dng_pixel_buffer buffer;",
          "2421:     stage2->GetPixelBuffer(buffer);",
          "2423:     int pixels = stage2->Bounds().H() * stage2->Bounds().W() * pplanes;",
          "2424:     if (ptype == ttByte)",
          "2425:       imgdata.rawdata.raw_alloc = malloc(pixels * TagTypeSize(ttShort));",
          "2426:     else",
          "2427:       imgdata.rawdata.raw_alloc = malloc(pixels * TagTypeSize(ptype));",
          "2429:     if (ptype == ttShort && !is_curve_linear())",
          "2430:     {",
          "2431:       ushort *src = (ushort *)buffer.fData;",
          "2432:       ushort *dst = (ushort *)imgdata.rawdata.raw_alloc;",
          "2433:       for (int i = 0; i < pixels; i++)",
          "2434:         dst[i] = imgdata.color.curve[src[i]];",
          "2435:       S.raw_pitch = S.raw_width * pplanes * TagTypeSize(ptype);",
          "2436:     }",
          "2437:     else if (ptype == ttByte)",
          "2438:     {",
          "2439:       unsigned char *src = (unsigned char *)buffer.fData;",
          "2440:       ushort *dst = (ushort *)imgdata.rawdata.raw_alloc;",
          "2441:       if (is_curve_linear())",
          "2442:       {",
          "2443:         for (int i = 0; i < pixels; i++)",
          "2444:           dst[i] = src[i];",
          "2445:       }",
          "2446:       else",
          "2447:       {",
          "2448:         for (int i = 0; i < pixels; i++)",
          "2449:           dst[i] = imgdata.color.curve[src[i]];",
          "2450:       }",
          "2451:       S.raw_pitch = S.raw_width * pplanes * TagTypeSize(ttShort);",
          "2452:     }",
          "2453:     else",
          "2454:     {",
          "2455:       memmove(imgdata.rawdata.raw_alloc, buffer.fData, pixels * TagTypeSize(ptype));",
          "2456:       S.raw_pitch = S.raw_width * pplanes * TagTypeSize(ptype);",
          "2457:     }",
          "2459:     switch (ptype)",
          "2460:     {",
          "2461:     case ttFloat:",
          "2462:       if (pplanes == 1)",
          "2463:         imgdata.rawdata.float_image = (float *)imgdata.rawdata.raw_alloc;",
          "2464:       else if (pplanes == 3)",
          "2465:         imgdata.rawdata.float3_image = (float(*)[3])imgdata.rawdata.raw_alloc;",
          "2466:       else if (pplanes == 4)",
          "2467:         imgdata.rawdata.float4_image = (float(*)[4])imgdata.rawdata.raw_alloc;",
          "2468:       break;",
          "2470:     case ttByte:",
          "2471:     case ttShort:",
          "2472:       if (pplanes == 1)",
          "2473:         imgdata.rawdata.raw_image = (ushort *)imgdata.rawdata.raw_alloc;",
          "2474:       else if (pplanes == 3)",
          "2475:         imgdata.rawdata.color3_image = (ushort(*)[3])imgdata.rawdata.raw_alloc;",
          "2476:       else if (pplanes == 4)",
          "2477:         imgdata.rawdata.color4_image = (ushort(*)[4])imgdata.rawdata.raw_alloc;",
          "2478:       break;",
          "2479:     default:",
          "2481:       break;",
          "2482:     }",
          "2483:   }",
          "2484:   catch (...)",
          "2485:   {",
          "2486:     return LIBRAW_UNSPECIFIED_ERROR;",
          "2487:   }",
          "2488:   return imgdata.rawdata.raw_alloc ? LIBRAW_SUCCESS : LIBRAW_UNSPECIFIED_ERROR;",
          "2490:   return LIBRAW_UNSPECIFIED_ERROR;",
          "2496:   dnghost = p;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2409: {",
          "2410:   CHECK_ORDER_HIGH(LIBRAW_PROGRESS_LOAD_RAW);",
          "2411:   CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);",
          "2415:       return LIBRAW_INPUT_CLOSED;",
          "2418:     if (O.shot_select >= P1.raw_count)",
          "2419:       return LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE;",
          "2422:       return LIBRAW_UNSPECIFIED_ERROR;",
          "2435:     if (libraw_internal_data.unpacker_data.meta_length)",
          "2442:     libraw_decoder_info_t decoder_info;",
          "2443:     get_decoder_info(&decoder_info);",
          "",
          "[Removed Lines]",
          "2412:   try {",
          "2414:     if(!libraw_internal_data.internal_data.input)",
          "2417:     RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW,0,2);",
          "2421:     if(!load_raw)",
          "2425:     if(imgdata.image)",
          "2426:       {",
          "2427:         free(imgdata.image);",
          "2428:         imgdata.image = 0;",
          "2429:       }",
          "2430:     if(imgdata.rawdata.raw_alloc)",
          "2431:       {",
          "2432:         free(imgdata.rawdata.raw_alloc);",
          "2433:         imgdata.rawdata.raw_alloc = 0;",
          "2434:       }",
          "2436:       {",
          "2437:         libraw_internal_data.internal_data.meta_data =",
          "2438:           (char *) malloc (libraw_internal_data.unpacker_data.meta_length);",
          "2439:         merror (libraw_internal_data.internal_data.meta_data, \"LibRaw::unpack()\");",
          "2440:       }",
          "",
          "[Added Lines]",
          "2504:   try",
          "2505:   {",
          "2507:     if (!libraw_internal_data.internal_data.input)",
          "2510:     RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW, 0, 2);",
          "2514:     if (!load_raw)",
          "2518:     if (imgdata.image)",
          "2519:     {",
          "2520:       free(imgdata.image);",
          "2521:       imgdata.image = 0;",
          "2522:     }",
          "2523:     if (imgdata.rawdata.raw_alloc)",
          "2524:     {",
          "2525:       free(imgdata.rawdata.raw_alloc);",
          "2526:       imgdata.rawdata.raw_alloc = 0;",
          "2527:     }",
          "2529:     {",
          "2530:       libraw_internal_data.internal_data.meta_data = (char *)malloc(libraw_internal_data.unpacker_data.meta_length);",
          "2531:       merror(libraw_internal_data.internal_data.meta_data, \"LibRaw::unpack()\");",
          "2532:     }",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2445:     int save_iwidth = S.iwidth, save_iheight = S.iheight, save_shrink = IO.shrink;",
          "2447:     int rwidth = S.raw_width, rheight = S.raw_height;",
          "2457:     imgdata.rawdata.raw_image = 0;",
          "2458:     imgdata.rawdata.color4_image = 0;",
          "2459:     imgdata.rawdata.color3_image = 0;",
          "2463: #ifdef USE_DNGSDK",
          "2468: #endif",
          "2470: #ifdef USE_RAWSPEED",
          "2501: #endif",
          "2503:       {",
          "2566:       }",
          "2569:       crop_masked_pixels(); // calculate black levels",
          "",
          "[Removed Lines]",
          "2448:     if( !IO.fuji_width)",
          "2449:       {",
          "2451:         if(rwidth < S.width + S.left_margin)",
          "2452:           rwidth = S.width + S.left_margin;",
          "2453:         if(rheight < S.height + S.top_margin)",
          "2454:           rheight = S.height + S.top_margin;",
          "2455:       }",
          "2460:  imgdata.rawdata.float_image = 0;",
          "2461:  imgdata.rawdata.float3_image = 0;",
          "2464:  if(imgdata.idata.dng_version && dnghost && valid_for_dngsdk() && load_raw != &LibRaw::pentax_4shot_load_raw)",
          "2465:  {",
          "2466:   int rr = try_dngsdk();",
          "2467:  }",
          "2471:  if(!raw_was_read())",
          "2472:  {",
          "2473:   int rawspeed_enabled = 1;",
          "2475:   if(imgdata.idata.dng_version && libraw_internal_data.unpacker_data.tiff_samples == 2)",
          "2476:    rawspeed_enabled = 0;",
          "2478:   if(imgdata.idata.raw_count > 1)",
          "2479:    rawspeed_enabled = 0;",
          "2482:   if(!strncasecmp(imgdata.idata.make,\"Olympus\",7) &&",
          "2483:    ( ( imgdata.sizes.raw_width > 6000) || !strncasecmp(imgdata.idata.model,\"SH-2\",4) || !strncasecmp(imgdata.idata.model,\"SH-3\",4) || !strncasecmp(imgdata.idata.model,\"TG-4\",4))",
          "2484:    )",
          "2485:    rawspeed_enabled = 0;",
          "2487:   if(imgdata.idata.dng_version && imgdata.idata.filters==0 && libraw_internal_data.unpacker_data.tiff_bps == 8) // Disable for 8 bit",
          "2488:    rawspeed_enabled = 0;",
          "2490:   if(load_raw == &LibRaw::packed_load_raw && !strncasecmp(imgdata.idata.make,\"Nikon\",5) && !strncasecmp(imgdata.idata.model,\"E\",1) )",
          "2491:    rawspeed_enabled = 0;",
          "2494:   if(O.use_rawspeed  && rawspeed_enabled",
          "2495:    && !(is_sraw() && (O.raw_processing_options & (LIBRAW_PROCESSING_SRAW_NO_RGB | LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)))",
          "2496:    && (decoder_info.decoder_flags & LIBRAW_DECODER_TRYRAWSPEED) && _rawspeed_camerameta)",
          "2497:   {",
          "2498:    int rr = try_rawspeed();",
          "2499:   }",
          "2500:  }",
          "2502:     if(!raw_was_read()) //RawSpeed failed or not run",
          "2505:   int zero_rawimage = 0;",
          "2506:         if(decoder_info.decoder_flags &  LIBRAW_DECODER_OWNALLOC)",
          "2507:           {",
          "2510:           }",
          "2511:         else if(imgdata.idata.filters || P1.colors == 1) // Bayer image or single color -> decode to raw_image",
          "2512:           {",
          "2513:             imgdata.rawdata.raw_alloc = malloc(rwidth*(rheight+8)*sizeof(imgdata.rawdata.raw_image[0]));",
          "2514:             imgdata.rawdata.raw_image = (ushort*) imgdata.rawdata.raw_alloc;",
          "2515:             if(!S.raw_pitch)",
          "2516:                 S.raw_pitch = S.raw_width*2; // Bayer case, not set before",
          "2517:           }",
          "2518:         else // NO LEGACY FLAG if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "2519:           {",
          "2521:             S.iwidth = S.width;",
          "2522:             S.iheight= S.height;",
          "2523:             IO.shrink = 0;",
          "2524:    if(!S.raw_pitch)",
          "2525:     S.raw_pitch = (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY_WITH_MARGINS) ? S.raw_width*8 : S.width*8;",
          "2527:             imgdata.rawdata.raw_alloc = 0;",
          "2528:             imgdata.image = (ushort (*)[4]) calloc(unsigned(S.raw_width)*unsigned(S.raw_height),sizeof(*imgdata.image));",
          "2529:    if(!(decoder_info.decoder_flags &  LIBRAW_DECODER_ADOBECOPYPIXEL))",
          "2530:    {",
          "2531:     imgdata.rawdata.raw_image = (ushort*) imgdata.image ;",
          "2532:     zero_rawimage = 1;",
          "2533:    }",
          "2534:           }",
          "2535:         ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);",
          "2537:         unsigned m_save = C.maximum;",
          "2538:         if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))",
          "2539:           C.maximum=65535;",
          "2540:         (this->*load_raw)();",
          "2541:   if(zero_rawimage)",
          "2542:    imgdata.rawdata.raw_image = 0;",
          "2543:         if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))",
          "2544:           C.maximum = m_save;",
          "2545:         if(decoder_info.decoder_flags &  LIBRAW_DECODER_OWNALLOC)",
          "2546:           {",
          "2549:           }",
          "2550:         else if (!(imgdata.idata.filters || P1.colors == 1) ) // legacy decoder, ownalloc handled above",
          "2551:           {",
          "2553:             imgdata.rawdata.raw_alloc = imgdata.image;",
          "2554:       imgdata.rawdata.color4_image = (ushort (*)[4]) imgdata.rawdata.raw_alloc;",
          "2555:             imgdata.image = 0;",
          "2558:    if(!(libraw_internal_data.unpacker_data.load_flags & 256))",
          "2559:    {",
          "2560:     S.raw_width = S.width;",
          "2561:     S.left_margin = 0;",
          "2562:     S.raw_height = S.height;",
          "2563:     S.top_margin = 0;",
          "2564:    }",
          "2565:           }",
          "2568:     if(imgdata.rawdata.raw_image)",
          "",
          "[Added Lines]",
          "2540:     if (!IO.fuji_width)",
          "2541:     {",
          "2543:       if (rwidth < S.width + S.left_margin)",
          "2544:         rwidth = S.width + S.left_margin;",
          "2545:       if (rheight < S.height + S.top_margin)",
          "2546:         rheight = S.height + S.top_margin;",
          "2547:     }",
          "2552:     imgdata.rawdata.float_image = 0;",
          "2553:     imgdata.rawdata.float3_image = 0;",
          "2556:     if (imgdata.idata.dng_version && dnghost && valid_for_dngsdk() && load_raw != &LibRaw::pentax_4shot_load_raw)",
          "2557:     {",
          "2558:       int rr = try_dngsdk();",
          "2559:     }",
          "2563:     if (!raw_was_read())",
          "2564:     {",
          "2565:       int rawspeed_enabled = 1;",
          "2567:       if (imgdata.idata.dng_version && libraw_internal_data.unpacker_data.tiff_samples == 2)",
          "2568:         rawspeed_enabled = 0;",
          "2570:       if (imgdata.idata.raw_count > 1)",
          "2571:         rawspeed_enabled = 0;",
          "2574:       if (!strncasecmp(imgdata.idata.make, \"Olympus\", 7) &&",
          "2575:           ((imgdata.sizes.raw_width > 6000) || !strncasecmp(imgdata.idata.model, \"SH-2\", 4) ||",
          "2576:            !strncasecmp(imgdata.idata.model, \"SH-3\", 4) || !strncasecmp(imgdata.idata.model, \"TG-4\", 4)))",
          "2577:         rawspeed_enabled = 0;",
          "2579:       if (imgdata.idata.dng_version && imgdata.idata.filters == 0 &&",
          "2580:           libraw_internal_data.unpacker_data.tiff_bps == 8) // Disable for 8 bit",
          "2581:         rawspeed_enabled = 0;",
          "2583:       if (load_raw == &LibRaw::packed_load_raw && !strncasecmp(imgdata.idata.make, \"Nikon\", 5) &&",
          "2584:           !strncasecmp(imgdata.idata.model, \"E\", 1))",
          "2585:         rawspeed_enabled = 0;",
          "2588:       if (O.use_rawspeed && rawspeed_enabled &&",
          "2589:           !(is_sraw() &&",
          "2590:             (O.raw_processing_options & (LIBRAW_PROCESSING_SRAW_NO_RGB | LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE))) &&",
          "2591:           (decoder_info.decoder_flags & LIBRAW_DECODER_TRYRAWSPEED) && _rawspeed_camerameta)",
          "2592:       {",
          "2593:         int rr = try_rawspeed();",
          "2594:       }",
          "2595:     }",
          "2597:     if (!raw_was_read()) // RawSpeed failed or not run",
          "2598:     {",
          "2600:       int zero_rawimage = 0;",
          "2601:       if (decoder_info.decoder_flags & LIBRAW_DECODER_OWNALLOC)",
          "2605:       }",
          "2606:       else if (imgdata.idata.filters || P1.colors == 1) // Bayer image or single color -> decode to raw_image",
          "2607:       {",
          "2608:         imgdata.rawdata.raw_alloc = malloc(rwidth * (rheight + 8) * sizeof(imgdata.rawdata.raw_image[0]));",
          "2609:         imgdata.rawdata.raw_image = (ushort *)imgdata.rawdata.raw_alloc;",
          "2610:         if (!S.raw_pitch)",
          "2611:           S.raw_pitch = S.raw_width * 2; // Bayer case, not set before",
          "2612:       }",
          "2613:       else // NO LEGACY FLAG if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "2614:       {",
          "2616:         S.iwidth = S.width;",
          "2617:         S.iheight = S.height;",
          "2618:         IO.shrink = 0;",
          "2619:         if (!S.raw_pitch)",
          "2620:           S.raw_pitch =",
          "2621:               (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY_WITH_MARGINS) ? S.raw_width * 8 : S.width * 8;",
          "2623:         imgdata.rawdata.raw_alloc = 0;",
          "2624:         imgdata.image = (ushort(*)[4])calloc(unsigned(S.raw_width) * unsigned(S.raw_height), sizeof(*imgdata.image));",
          "2625:         if (!(decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL))",
          "2626:         {",
          "2627:           imgdata.rawdata.raw_image = (ushort *)imgdata.image;",
          "2628:           zero_rawimage = 1;",
          "2629:         }",
          "2630:       }",
          "2631:       ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);",
          "2633:       unsigned m_save = C.maximum;",
          "2634:       if (load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make, \"Nikon\"))",
          "2635:         C.maximum = 65535;",
          "2636:       (this->*load_raw)();",
          "2637:       if (zero_rawimage)",
          "2638:         imgdata.rawdata.raw_image = 0;",
          "2639:       if (load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make, \"Nikon\"))",
          "2640:         C.maximum = m_save;",
          "2641:       if (decoder_info.decoder_flags & LIBRAW_DECODER_OWNALLOC)",
          "2642:       {",
          "2644:       }",
          "2645:       else if (!(imgdata.idata.filters || P1.colors == 1)) // legacy decoder, ownalloc handled above",
          "2646:       {",
          "2648:         imgdata.rawdata.raw_alloc = imgdata.image;",
          "2649:         imgdata.rawdata.color4_image = (ushort(*)[4])imgdata.rawdata.raw_alloc;",
          "2650:         imgdata.image = 0;",
          "2653:         if (!(libraw_internal_data.unpacker_data.load_flags & 256))",
          "2654:         {",
          "2655:           S.raw_width = S.width;",
          "2656:           S.left_margin = 0;",
          "2657:           S.raw_height = S.height;",
          "2658:           S.top_margin = 0;",
          "2659:         }",
          "2661:     }",
          "2663:     if (imgdata.rawdata.raw_image)",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2577:     unsigned int i = C.cblack[3];",
          "2578:     unsigned int c;",
          "2582:       C.cblack[c] -= i;",
          "2583:     C.black += i;",
          "2591:     SET_PROC_FLAG(LIBRAW_PROGRESS_LOAD_RAW);",
          "2594:     return 0;",
          "2595:   }",
          "2597:     EXCEPTION_HANDLER(err);",
          "2598:   }",
          "2600:     EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);",
          "2601:   }",
          "2602: }",
          "",
          "[Removed Lines]",
          "2579:     for(c=0;c<3;c++)",
          "2580:       if (i > C.cblack[c]) i = C.cblack[c];",
          "2581:     for (c=0;c<4;c++)",
          "2586:     memmove(&imgdata.rawdata.color,&imgdata.color,sizeof(imgdata.color));",
          "2587:     memmove(&imgdata.rawdata.sizes,&imgdata.sizes,sizeof(imgdata.sizes));",
          "2588:     memmove(&imgdata.rawdata.iparams,&imgdata.idata,sizeof(imgdata.idata));",
          "2589:     memmove(&imgdata.rawdata.ioparams,&libraw_internal_data.internal_output_params,sizeof(libraw_internal_data.internal_output_params));",
          "2592:     RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW,1,2);",
          "2596:   catch ( LibRaw_exceptions err) {",
          "2599:   catch (std::exception ee) {",
          "",
          "[Added Lines]",
          "2674:     for (c = 0; c < 3; c++)",
          "2675:       if (i > C.cblack[c])",
          "2676:         i = C.cblack[c];",
          "2677:     for (c = 0; c < 4; c++)",
          "2682:     memmove(&imgdata.rawdata.color, &imgdata.color, sizeof(imgdata.color));",
          "2683:     memmove(&imgdata.rawdata.sizes, &imgdata.sizes, sizeof(imgdata.sizes));",
          "2684:     memmove(&imgdata.rawdata.iparams, &imgdata.idata, sizeof(imgdata.idata));",
          "2685:     memmove(&imgdata.rawdata.ioparams, &libraw_internal_data.internal_output_params,",
          "2686:             sizeof(libraw_internal_data.internal_output_params));",
          "2689:     RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW, 1, 2);",
          "2693:   catch (LibRaw_exceptions err)",
          "2694:   {",
          "2697:   catch (std::exception ee)",
          "2698:   {",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2605: {",
          "2606:   int base_offset = 0;",
          "2607:   int row_size = imgdata.sizes.raw_width * 2; // in bytes",
          "2619:   free(buffer);",
          "2620: }",
          "2622: void LibRaw::nikon_load_sraw()",
          "2623: {",
          "2630:       {",
          "2647:       }",
          "2649:     free(rd);",
          "2651:   }",
          "2652:   free(rd);",
          "2653:   C.maximum = 0xfff; // 12 bit?",
          "2661:     {",
          "2673:     }",
          "2675:     return;",
          "2678:     {",
          "2700:     }",
          "2702: }",
          "2704: void LibRaw::free_image(void)",
          "2705: {",
          "2714: }",
          "2717: void LibRaw::raw2image_start()",
          "2718: {",
          "2725:   if (O.user_flip >= 0)",
          "2726:     S.flip = O.user_flip;",
          "2739:   S.iheight = (S.height + IO.shrink) >> IO.shrink;",
          "2742: }",
          "2744: int LibRaw::is_phaseone_compressed()",
          "",
          "[Removed Lines]",
          "2608:   if(imgdata.idata.raw_count==2 && imgdata.params.shot_select)",
          "2609:     {",
          "2610:       libraw_internal_data.internal_data.input->seek(-row_size,SEEK_CUR);",
          "2611:       base_offset = row_size; // in bytes",
          "2612:     }",
          "2613:   unsigned char *buffer = (unsigned char*)malloc(row_size*2);",
          "2614:   for(int row = 0; row < imgdata.sizes.raw_height; row++)",
          "2615:     {",
          "2616:       read_shorts((ushort*)buffer,imgdata.sizes.raw_width * 2);",
          "2617:       memmove(&imgdata.rawdata.raw_image[row*imgdata.sizes.raw_pitch/2],buffer+base_offset,row_size);",
          "2618:     }",
          "2625:   unsigned char *rd = (unsigned char *)malloc(3*(imgdata.sizes.raw_width+2));",
          "2626:   if(!rd) throw LIBRAW_EXCEPTION_ALLOC;",
          "2627:   try {",
          "2628:     int row,col;",
          "2629:     for(row = 0; row < imgdata.sizes.raw_height; row++)",
          "2631:         checkCancel();",
          "2632:         libraw_internal_data.internal_data.input->read(rd,3,imgdata.sizes.raw_width);",
          "2633:         for(col = 0; col < imgdata.sizes.raw_width-1;col+=2)",
          "2634:           {",
          "2635:             int bi = col*3;",
          "2636:             ushort bits1 = (rd[bi+1] &0xf)<<8| rd[bi]; // 3,0,1",
          "2637:             ushort bits2 = rd[bi+2] << 4 | ((rd[bi+1]>>4)& 0xf); //452",
          "2638:             ushort bits3 =  ((rd[bi+4] & 0xf)<<8) | rd[bi+3]; // 967",
          "2639:             ushort bits4 = rd[bi+5] << 4 | ((rd[bi+4]>>4)& 0xf); // ab8",
          "2640:             imgdata.image[row*imgdata.sizes.raw_width+col][0]=bits1;",
          "2641:             imgdata.image[row*imgdata.sizes.raw_width+col][1]=bits3;",
          "2642:             imgdata.image[row*imgdata.sizes.raw_width+col][2]=bits4;",
          "2643:             imgdata.image[row*imgdata.sizes.raw_width+col+1][0]=bits2;",
          "2644:             imgdata.image[row*imgdata.sizes.raw_width+col+1][1]=2048;",
          "2645:             imgdata.image[row*imgdata.sizes.raw_width+col+1][2]=2048;",
          "2646:           }",
          "2648:   }catch (...) {",
          "2650:     throw ;",
          "2654:   if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)",
          "2655:     {",
          "2656:       return; // no CbCr interpolation",
          "2657:     }",
          "2659:   int row,col;",
          "2660:   for(row = 0; row < imgdata.sizes.raw_height; row++)",
          "2662:       checkCancel(); // will throw out",
          "2663:       for(col = 0; col < imgdata.sizes.raw_width;col+=2)",
          "2664:         {",
          "2665:           int col2 = col<imgdata.sizes.raw_width-2?col+2:col;",
          "2666:           imgdata.image[row*imgdata.sizes.raw_width+col+1][1]",
          "2667:             =(unsigned short)(int(imgdata.image[row*imgdata.sizes.raw_width+col][1]",
          "2668:                                   +imgdata.image[row*imgdata.sizes.raw_width+col2][1])/2);",
          "2669:           imgdata.image[row*imgdata.sizes.raw_width+col+1][2]",
          "2670:             =(unsigned short)(int(imgdata.image[row*imgdata.sizes.raw_width+col][2]",
          "2671:                                   +imgdata.image[row*imgdata.sizes.raw_width+col2][2])/2);",
          "2672:         }",
          "2674:   if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB)",
          "2677:   for(row = 0; row < imgdata.sizes.raw_height; row++)",
          "2679:       checkCancel(); // will throw out",
          "2680:       for(col = 0; col < imgdata.sizes.raw_width;col++)",
          "2681:         {",
          "2682:           float Y = float(imgdata.image[row*imgdata.sizes.raw_width+col][0])/2549.f;",
          "2683:           float Ch2 = float(imgdata.image[row*imgdata.sizes.raw_width+col][1]-1280)/1536.f;",
          "2684:           float Ch3 = float(imgdata.image[row*imgdata.sizes.raw_width+col][2]-1280)/1536.f;",
          "2685:           if(Y>1.f) Y = 1.f;",
          "2686:     if(Y>0.803f) Ch2 = Ch3 = 0.5f;",
          "2687:           float r = Y + 1.40200f*(Ch3 - 0.5f);",
          "2688:     if(r<0.f) r=0.f;",
          "2689:     if(r>1.f) r=1.f;",
          "2690:           float g = Y - 0.34414f*(Ch2-0.5f) - 0.71414*(Ch3 - 0.5f) ;",
          "2691:     if(g>1.f) g = 1.f;",
          "2692:     if(g<0.f) g = 0.f;",
          "2693:           float b = Y + 1.77200*(Ch2-0.5f);",
          "2694:     if(b>1.f) b = 1.f;",
          "2695:     if(b<0.f) b = 0.f;",
          "2696:           imgdata.image[row*imgdata.sizes.raw_width+col][0]=imgdata.color.curve[int(r*3072.f)];",
          "2697:           imgdata.image[row*imgdata.sizes.raw_width+col][1]=imgdata.color.curve[int(g*3072.f)];",
          "2698:           imgdata.image[row*imgdata.sizes.raw_width+col][2]=imgdata.color.curve[int(b*3072.f)];",
          "2699:         }",
          "2701:   C.maximum=16383;",
          "2706:   if(imgdata.image)",
          "2707:     {",
          "2708:       free(imgdata.image);",
          "2709:       imgdata.image = 0;",
          "2710:       imgdata.progress_flags",
          "2711:         = LIBRAW_PROGRESS_START|LIBRAW_PROGRESS_OPEN",
          "2712:         |LIBRAW_PROGRESS_IDENTIFY|LIBRAW_PROGRESS_SIZE_ADJUST|LIBRAW_PROGRESS_LOAD_RAW;",
          "2713:     }",
          "2720:   memmove(&imgdata.color,&imgdata.rawdata.color,sizeof(imgdata.color));",
          "2721:   memmove(&imgdata.sizes,&imgdata.rawdata.sizes,sizeof(imgdata.sizes));",
          "2722:   memmove(&imgdata.idata,&imgdata.rawdata.iparams,sizeof(imgdata.idata));",
          "2723:   memmove(&libraw_internal_data.internal_output_params,&imgdata.rawdata.ioparams,sizeof(libraw_internal_data.internal_output_params));",
          "2728:   switch ((S.flip+3600) % 360)",
          "2729:     {",
          "2730:     case 270:  S.flip = 5;  break;",
          "2731:     case 180:  S.flip = 3;  break;",
          "2732:     case  90:  S.flip = 6;  break;",
          "2733:     }",
          "2736:   IO.shrink = P1.filters && (O.half_size ||",
          "2737:                              ((O.threshold || O.aber[0] != 1 || O.aber[2] != 1) ));",
          "2740:   S.iwidth  = (S.width  + IO.shrink) >> IO.shrink;",
          "",
          "[Added Lines]",
          "2707:   if (imgdata.idata.raw_count == 2 && imgdata.params.shot_select)",
          "2708:   {",
          "2709:     libraw_internal_data.internal_data.input->seek(-row_size, SEEK_CUR);",
          "2710:     base_offset = row_size; // in bytes",
          "2711:   }",
          "2712:   unsigned char *buffer = (unsigned char *)malloc(row_size * 2);",
          "2713:   for (int row = 0; row < imgdata.sizes.raw_height; row++)",
          "2714:   {",
          "2715:     read_shorts((ushort *)buffer, imgdata.sizes.raw_width * 2);",
          "2716:     memmove(&imgdata.rawdata.raw_image[row * imgdata.sizes.raw_pitch / 2], buffer + base_offset, row_size);",
          "2717:   }",
          "2724:   unsigned char *rd = (unsigned char *)malloc(3 * (imgdata.sizes.raw_width + 2));",
          "2725:   if (!rd)",
          "2726:     throw LIBRAW_EXCEPTION_ALLOC;",
          "2727:   try",
          "2728:   {",
          "2729:     int row, col;",
          "2730:     for (row = 0; row < imgdata.sizes.raw_height; row++)",
          "2731:     {",
          "2732:       checkCancel();",
          "2733:       libraw_internal_data.internal_data.input->read(rd, 3, imgdata.sizes.raw_width);",
          "2734:       for (col = 0; col < imgdata.sizes.raw_width - 1; col += 2)",
          "2736:         int bi = col * 3;",
          "2737:         ushort bits1 = (rd[bi + 1] & 0xf) << 8 | rd[bi];            // 3,0,1",
          "2738:         ushort bits2 = rd[bi + 2] << 4 | ((rd[bi + 1] >> 4) & 0xf); // 452",
          "2739:         ushort bits3 = ((rd[bi + 4] & 0xf) << 8) | rd[bi + 3];      // 967",
          "2740:         ushort bits4 = rd[bi + 5] << 4 | ((rd[bi + 4] >> 4) & 0xf); // ab8",
          "2741:         imgdata.image[row * imgdata.sizes.raw_width + col][0] = bits1;",
          "2742:         imgdata.image[row * imgdata.sizes.raw_width + col][1] = bits3;",
          "2743:         imgdata.image[row * imgdata.sizes.raw_width + col][2] = bits4;",
          "2744:         imgdata.image[row * imgdata.sizes.raw_width + col + 1][0] = bits2;",
          "2745:         imgdata.image[row * imgdata.sizes.raw_width + col + 1][1] = 2048;",
          "2746:         imgdata.image[row * imgdata.sizes.raw_width + col + 1][2] = 2048;",
          "2748:     }",
          "2749:   }",
          "2750:   catch (...)",
          "2751:   {",
          "2753:     throw;",
          "2757:   if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)",
          "2758:   {",
          "2759:     return; // no CbCr interpolation",
          "2760:   }",
          "2762:   int row, col;",
          "2763:   for (row = 0; row < imgdata.sizes.raw_height; row++)",
          "2764:   {",
          "2765:     checkCancel(); // will throw out",
          "2766:     for (col = 0; col < imgdata.sizes.raw_width; col += 2)",
          "2768:       int col2 = col < imgdata.sizes.raw_width - 2 ? col + 2 : col;",
          "2769:       imgdata.image[row * imgdata.sizes.raw_width + col + 1][1] =",
          "2770:           (unsigned short)(int(imgdata.image[row * imgdata.sizes.raw_width + col][1] +",
          "2771:                                imgdata.image[row * imgdata.sizes.raw_width + col2][1]) /",
          "2772:                            2);",
          "2773:       imgdata.image[row * imgdata.sizes.raw_width + col + 1][2] =",
          "2774:           (unsigned short)(int(imgdata.image[row * imgdata.sizes.raw_width + col][2] +",
          "2775:                                imgdata.image[row * imgdata.sizes.raw_width + col2][2]) /",
          "2776:                            2);",
          "2778:   }",
          "2779:   if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB)",
          "2782:   for (row = 0; row < imgdata.sizes.raw_height; row++)",
          "2783:   {",
          "2784:     checkCancel(); // will throw out",
          "2785:     for (col = 0; col < imgdata.sizes.raw_width; col++)",
          "2787:       float Y = float(imgdata.image[row * imgdata.sizes.raw_width + col][0]) / 2549.f;",
          "2788:       float Ch2 = float(imgdata.image[row * imgdata.sizes.raw_width + col][1] - 1280) / 1536.f;",
          "2789:       float Ch3 = float(imgdata.image[row * imgdata.sizes.raw_width + col][2] - 1280) / 1536.f;",
          "2790:       if (Y > 1.f)",
          "2791:         Y = 1.f;",
          "2792:       if (Y > 0.803f)",
          "2793:         Ch2 = Ch3 = 0.5f;",
          "2794:       float r = Y + 1.40200f * (Ch3 - 0.5f);",
          "2795:       if (r < 0.f)",
          "2796:         r = 0.f;",
          "2797:       if (r > 1.f)",
          "2798:         r = 1.f;",
          "2799:       float g = Y - 0.34414f * (Ch2 - 0.5f) - 0.71414 * (Ch3 - 0.5f);",
          "2800:       if (g > 1.f)",
          "2801:         g = 1.f;",
          "2802:       if (g < 0.f)",
          "2803:         g = 0.f;",
          "2804:       float b = Y + 1.77200 * (Ch2 - 0.5f);",
          "2805:       if (b > 1.f)",
          "2806:         b = 1.f;",
          "2807:       if (b < 0.f)",
          "2808:         b = 0.f;",
          "2809:       imgdata.image[row * imgdata.sizes.raw_width + col][0] = imgdata.color.curve[int(r * 3072.f)];",
          "2810:       imgdata.image[row * imgdata.sizes.raw_width + col][1] = imgdata.color.curve[int(g * 3072.f)];",
          "2811:       imgdata.image[row * imgdata.sizes.raw_width + col][2] = imgdata.color.curve[int(b * 3072.f)];",
          "2813:   }",
          "2814:   C.maximum = 16383;",
          "2819:   if (imgdata.image)",
          "2820:   {",
          "2821:     free(imgdata.image);",
          "2822:     imgdata.image = 0;",
          "2823:     imgdata.progress_flags = LIBRAW_PROGRESS_START | LIBRAW_PROGRESS_OPEN | LIBRAW_PROGRESS_IDENTIFY |",
          "2824:                              LIBRAW_PROGRESS_SIZE_ADJUST | LIBRAW_PROGRESS_LOAD_RAW;",
          "2825:   }",
          "2831:   memmove(&imgdata.color, &imgdata.rawdata.color, sizeof(imgdata.color));",
          "2832:   memmove(&imgdata.sizes, &imgdata.rawdata.sizes, sizeof(imgdata.sizes));",
          "2833:   memmove(&imgdata.idata, &imgdata.rawdata.iparams, sizeof(imgdata.idata));",
          "2834:   memmove(&libraw_internal_data.internal_output_params, &imgdata.rawdata.ioparams,",
          "2835:           sizeof(libraw_internal_data.internal_output_params));",
          "2840:   switch ((S.flip + 3600) % 360)",
          "2841:   {",
          "2842:   case 270:",
          "2843:     S.flip = 5;",
          "2844:     break;",
          "2845:   case 180:",
          "2846:     S.flip = 3;",
          "2847:     break;",
          "2848:   case 90:",
          "2849:     S.flip = 6;",
          "2850:     break;",
          "2851:   }",
          "2854:   IO.shrink = P1.filters && (O.half_size || ((O.threshold || O.aber[0] != 1 || O.aber[2] != 1)));",
          "2857:   S.iwidth = (S.width + IO.shrink) >> IO.shrink;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2746:   return (load_raw == &LibRaw::phase_one_load_raw_c || load_raw == &LibRaw::phase_one_load_raw);",
          "2747: }",
          "2754: int LibRaw::raw2image(void)",
          "2755: {",
          "2757:   CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);",
          "2760:     raw2image_start();",
          "2762:     if (is_phaseone_compressed())",
          "2763:       {",
          "2773:       }",
          "2781:     else",
          "2786:     libraw_decoder_info_t decoder_info;",
          "2787:     get_decoder_info(&decoder_info);",
          "2807:             }",
          "2808:           }",
          "2809:         }",
          "2817:       }",
          "2818:     else // if(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "2819:       {",
          "2847:         else",
          "2848:           {",
          "2851:           }",
          "2852:       }",
          "2855:     if (is_phaseone_compressed())",
          "2861:     if (load_raw == &CLASS canon_600_load_raw && S.width < S.raw_width)",
          "2869:     return 0;",
          "2870:   }",
          "2872:     EXCEPTION_HANDLER(err);",
          "2873:   }",
          "2874: }",
          "",
          "[Removed Lines]",
          "2749: int LibRaw::is_canon_600()",
          "2750: {",
          "2751:  return load_raw == &LibRaw::canon_600_load_raw;",
          "2752: }",
          "2759:   try {",
          "2764:         phase_one_allocate_tempbuffer();",
          "2765:         int rc = phase_one_subtract_black((ushort*)imgdata.rawdata.raw_alloc,imgdata.rawdata.raw_image);",
          "2766:  if(rc == 0)",
          "2767:    rc = phase_one_correct();",
          "2768:  if(rc!=0)",
          "2769:  {",
          "2770:    phase_one_free_tempbuffer();",
          "2771:    return rc;",
          "2772:  }",
          "2776:     if(imgdata.image)",
          "2777:       {",
          "2778:         imgdata.image = (ushort (*)[4]) realloc (imgdata.image,S.iheight*S.iwidth *sizeof (*imgdata.image));",
          "2779:         memset(imgdata.image,0,S.iheight*S.iwidth *sizeof (*imgdata.image));",
          "2780:       }",
          "2782:       imgdata.image = (ushort (*)[4]) calloc (S.iheight*S.iwidth, sizeof (*imgdata.image));",
          "2784:     merror (imgdata.image, \"raw2image()\");",
          "2790:     if( imgdata.idata.filters || P1.colors == 1)",
          "2791:       {",
          "2792:         if (IO.fuji_width) {",
          "2793:           unsigned r,c;",
          "2794:           int row,col;",
          "2795:           for (row=0; row < S.raw_height-S.top_margin*2; row++) {",
          "2796:             for (col=0; col < IO.fuji_width << !libraw_internal_data.unpacker_data.fuji_layout; col++) {",
          "2797:               if (libraw_internal_data.unpacker_data.fuji_layout) {",
          "2798:                 r = IO.fuji_width - 1 - col + (row >> 1);",
          "2799:                 c = col + ((row+1) >> 1);",
          "2800:               } else {",
          "2801:                 r = IO.fuji_width - 1 + row - (col >> 1);",
          "2802:                 c = row + ((col+1) >> 1);",
          "2803:               }",
          "2804:               if (r < S.height && c < S.width)",
          "2805:                 imgdata.image[((r)>>IO.shrink)*S.iwidth+((c)>>IO.shrink)][FC(r,c)]",
          "2806:                   = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch/2+(col+S.left_margin)];",
          "2810:         else {",
          "2811:           int row,col;",
          "2812:           for (row=0; row < S.height; row++)",
          "2813:             for (col=0; col < S.width; col++)",
          "2814:               imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][fcol(row,col)]",
          "2815:                 = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch/2+(col+S.left_margin)];",
          "2816:         }",
          "2820:         if(imgdata.rawdata.color4_image)",
          "2821:           {",
          "2822:             if(S.width*8 == S.raw_pitch)",
          "2823:               memmove(imgdata.image,imgdata.rawdata.color4_image,S.width*S.height*sizeof(*imgdata.image));",
          "2824:             else",
          "2825:               {",
          "2826:                 for(int row = 0; row < S.height; row++)",
          "2827:                   memmove(&imgdata.image[row*S.width],",
          "2828:                           &imgdata.rawdata.color4_image[(row+S.top_margin)*S.raw_pitch/8+S.left_margin],",
          "2829:                           S.width*sizeof(*imgdata.image));",
          "2830:               }",
          "2831:           }",
          "2832:         else if(imgdata.rawdata.color3_image)",
          "2833:           {",
          "2834:             unsigned char *c3image = (unsigned char*) imgdata.rawdata.color3_image;",
          "2835:             for(int row = 0; row < S.height; row++)",
          "2836:               {",
          "2837:                 ushort (*srcrow)[3] = (ushort (*)[3]) &c3image[(row+S.top_margin)*S.raw_pitch];",
          "2838:                 ushort (*dstrow)[4] = (ushort (*)[4]) &imgdata.image[row*S.width];",
          "2839:                 for(int col=0; col < S.width; col++)",
          "2840:                   {",
          "2841:                     for(int c=0; c< 3; c++)",
          "2842:                       dstrow[col][c] = srcrow[S.left_margin+col][c];",
          "2843:                     dstrow[col][3]=0;",
          "2844:                   }",
          "2845:               }",
          "2846:           }",
          "2850:             throw LIBRAW_EXCEPTION_DECODE_RAW;",
          "2856:       {",
          "2857:         phase_one_free_tempbuffer();",
          "2858:       }",
          "2862:       {",
          "2863:         canon_600_correct();",
          "2864:       }",
          "2866:     imgdata.progress_flags",
          "2867:       = LIBRAW_PROGRESS_START|LIBRAW_PROGRESS_OPEN | LIBRAW_PROGRESS_RAW2_IMAGE",
          "2868:       |LIBRAW_PROGRESS_IDENTIFY|LIBRAW_PROGRESS_SIZE_ADJUST|LIBRAW_PROGRESS_LOAD_RAW;",
          "2871:   catch ( LibRaw_exceptions err) {",
          "",
          "[Added Lines]",
          "2865: int LibRaw::is_canon_600() { return load_raw == &LibRaw::canon_600_load_raw; }",
          "2872:   try",
          "2873:   {",
          "2877:     {",
          "2878:       phase_one_allocate_tempbuffer();",
          "2879:       int rc = phase_one_subtract_black((ushort *)imgdata.rawdata.raw_alloc, imgdata.rawdata.raw_image);",
          "2880:       if (rc == 0)",
          "2881:         rc = phase_one_correct();",
          "2882:       if (rc != 0)",
          "2884:         phase_one_free_tempbuffer();",
          "2885:         return rc;",
          "2887:     }",
          "2890:     if (imgdata.image)",
          "2891:     {",
          "2892:       imgdata.image = (ushort(*)[4])realloc(imgdata.image, S.iheight * S.iwidth * sizeof(*imgdata.image));",
          "2893:       memset(imgdata.image, 0, S.iheight * S.iwidth * sizeof(*imgdata.image));",
          "2894:     }",
          "2896:       imgdata.image = (ushort(*)[4])calloc(S.iheight * S.iwidth, sizeof(*imgdata.image));",
          "2898:     merror(imgdata.image, \"raw2image()\");",
          "2904:     if (imgdata.idata.filters || P1.colors == 1)",
          "2905:     {",
          "2906:       if (IO.fuji_width)",
          "2907:       {",
          "2908:         unsigned r, c;",
          "2909:         int row, col;",
          "2910:         for (row = 0; row < S.raw_height - S.top_margin * 2; row++)",
          "2911:         {",
          "2912:           for (col = 0; col < IO.fuji_width << !libraw_internal_data.unpacker_data.fuji_layout; col++)",
          "2913:           {",
          "2914:             if (libraw_internal_data.unpacker_data.fuji_layout)",
          "2915:             {",
          "2916:               r = IO.fuji_width - 1 - col + (row >> 1);",
          "2917:               c = col + ((row + 1) >> 1);",
          "2918:             }",
          "2919:             else",
          "2920:             {",
          "2921:               r = IO.fuji_width - 1 + row - (col >> 1);",
          "2922:               c = row + ((col + 1) >> 1);",
          "2924:             if (r < S.height && c < S.width)",
          "2925:               imgdata.image[((r) >> IO.shrink) * S.iwidth + ((c) >> IO.shrink)][FC(r, c)] =",
          "2926:                   imgdata.rawdata.raw_image[(row + S.top_margin) * S.raw_pitch / 2 + (col + S.left_margin)];",
          "2930:       else",
          "2931:       {",
          "2932:         int row, col;",
          "2933:         for (row = 0; row < S.height; row++)",
          "2934:           for (col = 0; col < S.width; col++)",
          "2935:             imgdata.image[((row) >> IO.shrink) * S.iwidth + ((col) >> IO.shrink)][fcol(row, col)] =",
          "2936:                 imgdata.rawdata.raw_image[(row + S.top_margin) * S.raw_pitch / 2 + (col + S.left_margin)];",
          "2937:       }",
          "2938:     }",
          "2940:     {",
          "2941:       if (imgdata.rawdata.color4_image)",
          "2943:         if (S.width * 8 == S.raw_pitch)",
          "2944:           memmove(imgdata.image, imgdata.rawdata.color4_image, S.width * S.height * sizeof(*imgdata.image));",
          "2946:         {",
          "2947:           for (int row = 0; row < S.height; row++)",
          "2948:             memmove(&imgdata.image[row * S.width],",
          "2949:                     &imgdata.rawdata.color4_image[(row + S.top_margin) * S.raw_pitch / 8 + S.left_margin],",
          "2950:                     S.width * sizeof(*imgdata.image));",
          "2951:         }",
          "2952:       }",
          "2953:       else if (imgdata.rawdata.color3_image)",
          "2954:       {",
          "2955:         unsigned char *c3image = (unsigned char *)imgdata.rawdata.color3_image;",
          "2956:         for (int row = 0; row < S.height; row++)",
          "2957:         {",
          "2958:           ushort(*srcrow)[3] = (ushort(*)[3]) & c3image[(row + S.top_margin) * S.raw_pitch];",
          "2959:           ushort(*dstrow)[4] = (ushort(*)[4]) & imgdata.image[row * S.width];",
          "2960:           for (int col = 0; col < S.width; col++)",
          "2962:             for (int c = 0; c < 3; c++)",
          "2963:               dstrow[col][c] = srcrow[S.left_margin + col][c];",
          "2964:             dstrow[col][3] = 0;",
          "2966:         }",
          "2967:       }",
          "2968:       else",
          "2969:       {",
          "2971:         throw LIBRAW_EXCEPTION_DECODE_RAW;",
          "2973:     }",
          "2977:     {",
          "2978:       phase_one_free_tempbuffer();",
          "2979:     }",
          "2983:     {",
          "2984:       canon_600_correct();",
          "2985:     }",
          "2987:     imgdata.progress_flags = LIBRAW_PROGRESS_START | LIBRAW_PROGRESS_OPEN | LIBRAW_PROGRESS_RAW2_IMAGE |",
          "2988:                              LIBRAW_PROGRESS_IDENTIFY | LIBRAW_PROGRESS_SIZE_ADJUST | LIBRAW_PROGRESS_LOAD_RAW;",
          "2991:   catch (LibRaw_exceptions err)",
          "2992:   {",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "2876: void LibRaw::phase_one_allocate_tempbuffer()",
          "2877: {",
          "2881: }",
          "2882: void LibRaw::phase_one_free_tempbuffer()",
          "2883: {",
          "2886: }",
          "2888: int LibRaw::phase_one_subtract_black(ushort *src, ushort *dest)",
          "2889: {",
          "2891:   try",
          "2892:     {",
          "2894:         {",
          "2925:         }",
          "2927:         {",
          "2943:         }",
          "2945:     }",
          "2947:     return LIBRAW_CANCELLED_BY_CALLBACK;",
          "2948:   }",
          "2949: }",
          "2952: {",
          "2953:   int row;",
          "2954: #if defined(LIBRAW_USE_OPENMP)",
          "2955: #pragma omp parallel for default(shared)",
          "2956: #endif",
          "2958:     {",
          "2962:         {",
          "2984:         }",
          "2985: #if defined(LIBRAW_USE_OPENMP)",
          "2986: #pragma omp critical(dataupdate)",
          "2987: #endif",
          "2992:     }",
          "2993: }",
          "2996: {",
          "2998:   int row;",
          "",
          "[Removed Lines]",
          "2879:   imgdata.rawdata.raw_image = (ushort*)malloc(S.raw_pitch*S.raw_height);",
          "2880:   merror (imgdata.rawdata.raw_image, \"phase_one_prepare_to_correct()\");",
          "2884:  free(imgdata.rawdata.raw_image);",
          "2885:  imgdata.rawdata.raw_image = (ushort*) imgdata.rawdata.raw_alloc;",
          "2893:       if (O.user_black < 0 && O.user_cblack[0] <= -1000000 && O.user_cblack[1] <= -1000000 && O.user_cblack[2] <= -1000000 && O.user_cblack[3] <= -1000000)",
          "2895:           if (!imgdata.rawdata.ph1_cblack || !imgdata.rawdata.ph1_rblack)",
          "2896:             {",
          "2897:               register int bl = imgdata.color.phase_one_data.t_black;",
          "2898:               for (int row = 0; row < S.raw_height; row++)",
          "2899:                 {",
          "2900:                   checkCancel();",
          "2901:                   for (int col = 0; col < S.raw_width; col++)",
          "2902:                     {",
          "2903:                       int idx = row*S.raw_width + col;",
          "2904:                       int val = int(src[idx]) - bl;",
          "2905:                       dest[idx] = val>0 ? val : 0;",
          "2906:                     }",
          "2907:                 }",
          "2908:             }",
          "2909:           else",
          "2910:             {",
          "2911:               register int bl = imgdata.color.phase_one_data.t_black;",
          "2912:               for (int row = 0; row < S.raw_height; row++)",
          "2913:                 {",
          "2914:                   checkCancel();",
          "2915:                   for (int col = 0; col < S.raw_width; col++)",
          "2916:                     {",
          "2917:                       int idx = row*S.raw_width + col;",
          "2918:                       int val = int(src[idx]) - bl",
          "2919:                       + imgdata.rawdata.ph1_cblack[row][col >= imgdata.rawdata.color.phase_one_data.split_col]",
          "2920:                         + imgdata.rawdata.ph1_rblack[col][row >= imgdata.rawdata.color.phase_one_data.split_row];",
          "2921:                       dest[idx] = val>0 ? val : 0;",
          "2922:                     }",
          "2923:                 }",
          "2924:             }",
          "2926:       else // black set by user interaction",
          "2929:           for (int row = 0; row < S.raw_height; row++)",
          "2930:             {",
          "2931:               checkCancel();",
          "2932:               unsigned short cblk[16];",
          "2933:               for (int cc = 0; cc < 16; cc++)",
          "2934:                 cblk[cc] = C.cblack[fcol(row, cc)];",
          "2935:               for (int col = 0; col < S.raw_width; col++)",
          "2936:                 {",
          "2937:                   int idx = row*S.raw_width + col;",
          "2938:                   ushort val = src[idx];",
          "2939:                   ushort bl = cblk[col & 0xf];",
          "2940:                   dest[idx] = val>bl ? val - bl : 0;",
          "2941:                 }",
          "2942:             }",
          "2944:       return 0;",
          "2946:   catch (LibRaw_exceptions err) {",
          "2951: void LibRaw::copy_fuji_uncropped(unsigned short cblack[4],unsigned short *dmaxp)",
          "2957:   for (row=0; row < S.raw_height-S.top_margin*2; row++)",
          "2959:       int col;",
          "2960:       unsigned short ldmax = 0;",
          "2961:       for (col=0; col < IO.fuji_width << !libraw_internal_data.unpacker_data.fuji_layout; col++)",
          "2963:           unsigned r,c;",
          "2964:           if (libraw_internal_data.unpacker_data.fuji_layout) {",
          "2965:             r = IO.fuji_width - 1 - col + (row >> 1);",
          "2966:             c = col + ((row+1) >> 1);",
          "2967:           } else {",
          "2968:             r = IO.fuji_width - 1 + row - (col >> 1);",
          "2969:             c = row + ((col+1) >> 1);",
          "2970:           }",
          "2971:           if (r < S.height && c < S.width)",
          "2972:             {",
          "2973:               unsigned short val = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch/2+(col+S.left_margin)];",
          "2974:               int cc = FC(r,c);",
          "2975:               if(val>cblack[cc])",
          "2976:                 {",
          "2977:                   val-=cblack[cc];",
          "2978:                   if(val>ldmax)ldmax = val;",
          "2979:                 }",
          "2980:               else",
          "2981:                 val = 0;",
          "2982:               imgdata.image[((r)>>IO.shrink)*S.iwidth+((c)>>IO.shrink)][cc] = val;",
          "2983:             }",
          "2988:       {",
          "2989:         if(*dmaxp < ldmax)",
          "2991:       }",
          "2995: void LibRaw::copy_bayer(unsigned short cblack[4],unsigned short *dmaxp)",
          "",
          "[Added Lines]",
          "3000:   imgdata.rawdata.raw_image = (ushort *)malloc(S.raw_pitch * S.raw_height);",
          "3001:   merror(imgdata.rawdata.raw_image, \"phase_one_prepare_to_correct()\");",
          "3005:   free(imgdata.rawdata.raw_image);",
          "3006:   imgdata.rawdata.raw_image = (ushort *)imgdata.rawdata.raw_alloc;",
          "3013:   {",
          "3014:     if (O.user_black < 0 && O.user_cblack[0] <= -1000000 && O.user_cblack[1] <= -1000000 &&",
          "3015:         O.user_cblack[2] <= -1000000 && O.user_cblack[3] <= -1000000)",
          "3017:       if (!imgdata.rawdata.ph1_cblack || !imgdata.rawdata.ph1_rblack)",
          "3018:       {",
          "3019:         register int bl = imgdata.color.phase_one_data.t_black;",
          "3020:         for (int row = 0; row < S.raw_height; row++)",
          "3022:           checkCancel();",
          "3023:           for (int col = 0; col < S.raw_width; col++)",
          "3024:           {",
          "3025:             int idx = row * S.raw_width + col;",
          "3026:             int val = int(src[idx]) - bl;",
          "3027:             dest[idx] = val > 0 ? val : 0;",
          "3028:           }",
          "3030:       }",
          "3031:       else",
          "3032:       {",
          "3033:         register int bl = imgdata.color.phase_one_data.t_black;",
          "3034:         for (int row = 0; row < S.raw_height; row++)",
          "3036:           checkCancel();",
          "3037:           for (int col = 0; col < S.raw_width; col++)",
          "3038:           {",
          "3039:             int idx = row * S.raw_width + col;",
          "3040:             int val = int(src[idx]) - bl +",
          "3041:                       imgdata.rawdata.ph1_cblack[row][col >= imgdata.rawdata.color.phase_one_data.split_col] +",
          "3042:                       imgdata.rawdata.ph1_rblack[col][row >= imgdata.rawdata.color.phase_one_data.split_row];",
          "3043:             dest[idx] = val > 0 ? val : 0;",
          "3044:           }",
          "3046:       }",
          "3047:     }",
          "3048:     else // black set by user interaction",
          "3049:     {",
          "3051:       for (int row = 0; row < S.raw_height; row++)",
          "3052:       {",
          "3053:         checkCancel();",
          "3054:         unsigned short cblk[16];",
          "3055:         for (int cc = 0; cc < 16; cc++)",
          "3056:           cblk[cc] = C.cblack[fcol(row, cc)];",
          "3057:         for (int col = 0; col < S.raw_width; col++)",
          "3058:         {",
          "3059:           int idx = row * S.raw_width + col;",
          "3060:           ushort val = src[idx];",
          "3061:           ushort bl = cblk[col & 0xf];",
          "3062:           dest[idx] = val > bl ? val - bl : 0;",
          "3063:         }",
          "3064:       }",
          "3066:     return 0;",
          "3067:   }",
          "3068:   catch (LibRaw_exceptions err)",
          "3069:   {",
          "3074: void LibRaw::copy_fuji_uncropped(unsigned short cblack[4], unsigned short *dmaxp)",
          "3080:   for (row = 0; row < S.raw_height - S.top_margin * 2; row++)",
          "3081:   {",
          "3082:     int col;",
          "3083:     unsigned short ldmax = 0;",
          "3084:     for (col = 0; col < IO.fuji_width << !libraw_internal_data.unpacker_data.fuji_layout; col++)",
          "3086:       unsigned r, c;",
          "3087:       if (libraw_internal_data.unpacker_data.fuji_layout)",
          "3088:       {",
          "3089:         r = IO.fuji_width - 1 - col + (row >> 1);",
          "3090:         c = col + ((row + 1) >> 1);",
          "3091:       }",
          "3092:       else",
          "3093:       {",
          "3094:         r = IO.fuji_width - 1 + row - (col >> 1);",
          "3095:         c = row + ((col + 1) >> 1);",
          "3096:       }",
          "3097:       if (r < S.height && c < S.width)",
          "3098:       {",
          "3099:         unsigned short val = imgdata.rawdata.raw_image[(row + S.top_margin) * S.raw_pitch / 2 + (col + S.left_margin)];",
          "3100:         int cc = FC(r, c);",
          "3101:         if (val > cblack[cc])",
          "3103:           val -= cblack[cc];",
          "3104:           if (val > ldmax)",
          "3105:             ldmax = val;",
          "3107:         else",
          "3108:           val = 0;",
          "3109:         imgdata.image[((r) >> IO.shrink) * S.iwidth + ((c) >> IO.shrink)][cc] = val;",
          "3110:       }",
          "3111:     }",
          "3115:     {",
          "3116:       if (*dmaxp < ldmax)",
          "3119:   }",
          "3122: void LibRaw::copy_bayer(unsigned short cblack[4], unsigned short *dmaxp)",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "3000: #if defined(LIBRAW_USE_OPENMP)",
          "3001: #pragma omp parallel for default(shared)",
          "3002: #endif",
          "3004:     {",
          "3020: #if defined(LIBRAW_USE_OPENMP)",
          "3021: #pragma omp critical(dataupdate)",
          "3022: #endif",
          "3027:     }",
          "3028: }",
          "3031: int LibRaw::raw2image_ex(int do_subtract_black)",
          "3032: {",
          "3034:   CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);",
          "3037:     raw2image_start();",
          "3040:     if (is_phaseone_compressed())",
          "3041:       {",
          "3051:       }",
          "3054:     int do_crop = 0;",
          "",
          "[Removed Lines]",
          "3003:   for (row=0; row < S.height; row++)",
          "3005:       int col;",
          "3006:       unsigned short ldmax = 0;",
          "3007:       for (col=0; col < S.width; col++)",
          "3008:         {",
          "3009:           unsigned short val = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch/2+(col+S.left_margin)];",
          "3010:           int cc = fcol(row,col);",
          "3011:           if(val>cblack[cc])",
          "3012:             {",
          "3013:               val-=cblack[cc];",
          "3014:               if(val>ldmax)ldmax = val;",
          "3015:             }",
          "3016:           else",
          "3017:             val = 0;",
          "3018:           imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][cc] = val;",
          "3019:         }",
          "3023:       {",
          "3024:         if(*dmaxp < ldmax)",
          "3026:       }",
          "3036:   try {",
          "3042:         phase_one_allocate_tempbuffer();",
          "3043:         int rc = phase_one_subtract_black((ushort*)imgdata.rawdata.raw_alloc,imgdata.rawdata.raw_image);",
          "3044:  if(rc == 0)",
          "3045:    rc = phase_one_correct();",
          "3046:  if(rc!=0)",
          "3047:    {",
          "3048:      phase_one_free_tempbuffer();",
          "3049:      return rc;",
          "3050:    }",
          "",
          "[Added Lines]",
          "3130:   for (row = 0; row < S.height; row++)",
          "3131:   {",
          "3132:     int col;",
          "3133:     unsigned short ldmax = 0;",
          "3134:     for (col = 0; col < S.width; col++)",
          "3136:       unsigned short val = imgdata.rawdata.raw_image[(row + S.top_margin) * S.raw_pitch / 2 + (col + S.left_margin)];",
          "3137:       int cc = fcol(row, col);",
          "3138:       if (val > cblack[cc])",
          "3139:       {",
          "3140:         val -= cblack[cc];",
          "3141:         if (val > ldmax)",
          "3142:           ldmax = val;",
          "3143:       }",
          "3144:       else",
          "3145:         val = 0;",
          "3146:       imgdata.image[((row) >> IO.shrink) * S.iwidth + ((col) >> IO.shrink)][cc] = val;",
          "3147:     }",
          "3151:     {",
          "3152:       if (*dmaxp < ldmax)",
          "3155:   }",
          "3163:   try",
          "3164:   {",
          "3169:     {",
          "3170:       phase_one_allocate_tempbuffer();",
          "3171:       int rc = phase_one_subtract_black((ushort *)imgdata.rawdata.raw_alloc, imgdata.rawdata.raw_image);",
          "3172:       if (rc == 0)",
          "3173:         rc = phase_one_correct();",
          "3174:       if (rc != 0)",
          "3176:         phase_one_free_tempbuffer();",
          "3177:         return rc;",
          "3179:     }",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "3058:         && load_raw != &LibRaw::foveon_sd_load_raw",
          "3059: #endif",
          "3060:         ) // Foveon SD to be cropped later",
          "3061:       {",
          "3114:       }",
          "3116:     int alloc_width = S.iwidth;",
          "3117:     int alloc_height = S.iheight;",
          "3134:     else",
          "3138:     libraw_decoder_info_t decoder_info;",
          "3139:     get_decoder_info(&decoder_info);",
          "3143:     unsigned short dmax = 0;",
          "3206:       {",
          "3208:           {",
          "3210:               {",
          "3215:               }",
          "3217:               {",
          "3220:               }",
          "3226:               {",
          "3235:               }",
          "3236:           }",
          "3237:         else",
          "3238:           {",
          "3241:           }",
          "3242:       }",
          "3245:     if (is_phaseone_compressed())",
          "3249:     if (load_raw == &CLASS canon_600_load_raw && S.width < S.raw_width)",
          "3267:     return 0;",
          "3268:   }",
          "3270:     EXCEPTION_HANDLER(err);",
          "3271:   }",
          "3272: }",
          "3274: #if 1",
          "3277: {",
          "3282:         )",
          "3291:     }",
          "3294:     {",
          "3316:     {",
          "3356:     }",
          "3358:     {",
          "3361:     }",
          "3362: }",
          "3373: {",
          "3377:   }",
          "3381:   }",
          "",
          "[Removed Lines]",
          "3062:         int crop[4],c,filt;",
          "3063:         for(int c=0;c<4;c++)",
          "3064:           {",
          "3065:             crop[c] = O.cropbox[c];",
          "3066:             if(crop[c]<0)",
          "3067:               crop[c]=0;",
          "3068:           }",
          "3070:         if(IO.fuji_width && imgdata.idata.filters >= 1000)",
          "3071:           {",
          "3072:             crop[0] = (crop[0]/4)*4;",
          "3073:             crop[1] = (crop[1]/4)*4;",
          "3074:             if(!libraw_internal_data.unpacker_data.fuji_layout)",
          "3075:               {",
          "3076:                 crop[2]*=sqrt(2.0);",
          "3077:                 crop[3]/=sqrt(2.0);",
          "3078:               }",
          "3079:             crop[2] = (crop[2]/4+1)*4;",
          "3080:             crop[3] = (crop[3]/4+1)*4;",
          "3081:           }",
          "3082:         else if (imgdata.idata.filters == 1)",
          "3083:           {",
          "3084:             crop[0] = (crop[0]/16)*16;",
          "3085:             crop[1] = (crop[1]/16)*16;",
          "3086:           }",
          "3087:         else if(imgdata.idata.filters == LIBRAW_XTRANS)",
          "3088:           {",
          "3089:             crop[0] = (crop[0]/6)*6;",
          "3090:             crop[1] = (crop[1]/6)*6;",
          "3091:           }",
          "3092:         do_crop = 1;",
          "3094:         crop[2] = MIN (crop[2], (signed) S.width-crop[0]);",
          "3095:         crop[3] = MIN (crop[3], (signed) S.height-crop[1]);",
          "3096:         if (crop[2] <= 0 || crop[3] <= 0)",
          "3097:           throw LIBRAW_EXCEPTION_BAD_CROP;",
          "3100:         S.left_margin+=crop[0];",
          "3101:         S.top_margin+=crop[1];",
          "3102:         S.width=crop[2];",
          "3103:         S.height=crop[3];",
          "3105:         S.iheight = (S.height + IO.shrink) >> IO.shrink;",
          "3106:         S.iwidth  = (S.width  + IO.shrink) >> IO.shrink;",
          "3107:         if(!IO.fuji_width && imgdata.idata.filters && imgdata.idata.filters >= 1000)",
          "3108:           {",
          "3109:             for (filt=c=0; c < 16; c++)",
          "3110:               filt |= FC((c >> 1)+(crop[1]),",
          "3111:                          (c &  1)+(crop[0])) << c*2;",
          "3112:             imgdata.idata.filters = filt;",
          "3113:           }",
          "3119:     if(IO.fuji_width && do_crop)",
          "3120:       {",
          "3121:         int IO_fw = S.width >> !libraw_internal_data.unpacker_data.fuji_layout;",
          "3122:         int t_alloc_width = (S.height >> libraw_internal_data.unpacker_data.fuji_layout) + IO_fw;",
          "3123:         int t_alloc_height = t_alloc_width - 1;",
          "3124:         alloc_height = (t_alloc_height + IO.shrink) >> IO.shrink;",
          "3125:         alloc_width = (t_alloc_width + IO.shrink) >> IO.shrink;",
          "3126:       }",
          "3127:     int alloc_sz = alloc_width*alloc_height;",
          "3129:     if(imgdata.image)",
          "3130:       {",
          "3131:         imgdata.image = (ushort (*)[4]) realloc (imgdata.image,alloc_sz *sizeof (*imgdata.image));",
          "3132:         memset(imgdata.image,0,alloc_sz *sizeof (*imgdata.image));",
          "3133:       }",
          "3135:       imgdata.image = (ushort (*)[4]) calloc (alloc_sz, sizeof (*imgdata.image));",
          "3136:     merror (imgdata.image, \"raw2image_ex()\");",
          "3142:     unsigned short cblack[4]={0,0,0,0};",
          "3144:     if(do_subtract_black)",
          "3145:       {",
          "3146:         adjust_bl();",
          "3147:         for(int i=0; i< 4; i++)",
          "3148:           cblack[i] = (unsigned short)C.cblack[i];",
          "3149:       }",
          "3152:     if(imgdata.idata.filters || P1.colors == 1)",
          "3153:       {",
          "3154:         if (IO.fuji_width)",
          "3155:           {",
          "3156:             if(do_crop)",
          "3157:               {",
          "3158:                 IO.fuji_width = S.width >> !libraw_internal_data.unpacker_data.fuji_layout;",
          "3159:                 int IO_fwidth = (S.height >> libraw_internal_data.unpacker_data.fuji_layout) + IO.fuji_width;",
          "3160:                 int IO_fheight = IO_fwidth - 1;",
          "3162:                 int row,col;",
          "3163:                 for(row=0;row<S.height;row++)",
          "3164:                   {",
          "3165:                     for(col=0;col<S.width;col++)",
          "3166:                       {",
          "3167:                         int r,c;",
          "3168:                         if (libraw_internal_data.unpacker_data.fuji_layout) {",
          "3169:                           r = IO.fuji_width - 1 - col + (row >> 1);",
          "3170:                           c = col + ((row+1) >> 1);",
          "3171:                         } else {",
          "3172:                           r = IO.fuji_width - 1 + row - (col >> 1);",
          "3173:                           c = row + ((col+1) >> 1);",
          "3174:                         }",
          "3176:                         unsigned short val = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch/2",
          "3177:                                                             +(col+S.left_margin)];",
          "3178:                         int cc = FCF(row,col);",
          "3179:                         if(val > cblack[cc])",
          "3180:                           {",
          "3181:                             val-=cblack[cc];",
          "3182:                             if(dmax < val) dmax = val;",
          "3183:                           }",
          "3184:                         else",
          "3185:                           val = 0;",
          "3186:                         imgdata.image[((r) >> IO.shrink)*alloc_width + ((c) >> IO.shrink)][cc] = val;",
          "3187:                       }",
          "3188:                   }",
          "3189:                 S.height = IO_fheight;",
          "3190:                 S.width = IO_fwidth;",
          "3191:                 S.iheight = (S.height + IO.shrink) >> IO.shrink;",
          "3192:                 S.iwidth  = (S.width  + IO.shrink) >> IO.shrink;",
          "3193:                 S.raw_height -= 2*S.top_margin;",
          "3194:               }",
          "3195:             else",
          "3196:               {",
          "3197:                 copy_fuji_uncropped(cblack,&dmax);",
          "3198:               }",
          "3199:           } // end Fuji",
          "3200:         else",
          "3201:           {",
          "3202:             copy_bayer(cblack,&dmax);",
          "3203:           }",
          "3204:       }",
          "3205:     else //if(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "3207:         if(imgdata.rawdata.color4_image)",
          "3209:             if(S.raw_pitch != S.width*8)",
          "3211:                 for(int row = 0; row < S.height; row++)",
          "3212:                   memmove(&imgdata.image[row*S.width],",
          "3213:                           &imgdata.rawdata.color4_image[(row+S.top_margin)*S.raw_pitch/8+S.left_margin],",
          "3214:                           S.width*sizeof(*imgdata.image));",
          "3216:             else",
          "3219:                 memmove(imgdata.image,imgdata.rawdata.color4_image,S.width*S.height*sizeof(*imgdata.image));",
          "3221:           }",
          "3222:         else if(imgdata.rawdata.color3_image)",
          "3223:           {",
          "3224:             unsigned char *c3image = (unsigned char*) imgdata.rawdata.color3_image;",
          "3225:             for(int row = 0; row < S.height; row++)",
          "3227:                 ushort (*srcrow)[3] = (ushort (*)[3]) &c3image[(row+S.top_margin)*S.raw_pitch];",
          "3228:                 ushort (*dstrow)[4] = (ushort (*)[4]) &imgdata.image[row*S.width];",
          "3229:                 for(int col=0; col < S.width; col++)",
          "3230:                   {",
          "3231:                     for(int c=0; c< 3; c++)",
          "3232:                       dstrow[col][c] = srcrow[S.left_margin+col][c];",
          "3233:                     dstrow[col][3]=0;",
          "3234:                   }",
          "3240:             throw LIBRAW_EXCEPTION_DECODE_RAW;",
          "3246:       {",
          "3247:     phase_one_free_tempbuffer();",
          "3248:       }",
          "3250:       {",
          "3251:         canon_600_correct();",
          "3252:       }",
          "3254:     if(do_subtract_black)",
          "3255:       {",
          "3256:         C.data_maximum = (int)dmax;",
          "3257:         C.maximum -= C.black;",
          "3259:         C.cblack[0]=C.cblack[1]=C.cblack[2]=C.cblack[3]=0;",
          "3260:         C.black = 0;",
          "3261:       }",
          "3264:     imgdata.progress_flags",
          "3265:       = LIBRAW_PROGRESS_START|LIBRAW_PROGRESS_OPEN | LIBRAW_PROGRESS_RAW2_IMAGE",
          "3266:       |LIBRAW_PROGRESS_IDENTIFY|LIBRAW_PROGRESS_SIZE_ADJUST|LIBRAW_PROGRESS_LOAD_RAW;",
          "3269:   catch ( LibRaw_exceptions err) {",
          "3276: libraw_processed_image_t * LibRaw::dcraw_make_mem_thumb(int *errcode)",
          "3278:   if(!T.thumb)",
          "3279:     {",
          "3280:       if ( !ID.toffset",
          "3281:         && !(imgdata.thumbnail.tlength>0 && load_raw == &LibRaw::broadcom_load_raw) // RPi",
          "3283:         {",
          "3284:           if(errcode) *errcode= LIBRAW_NO_THUMBNAIL;",
          "3285:         }",
          "3286:       else",
          "3287:         {",
          "3288:           if(errcode) *errcode= LIBRAW_OUT_OF_ORDER_CALL;",
          "3289:         }",
          "3290:       return NULL;",
          "3293:   if (T.tformat == LIBRAW_THUMBNAIL_BITMAP)",
          "3295:       libraw_processed_image_t * ret =",
          "3296:         (libraw_processed_image_t *)::malloc(sizeof(libraw_processed_image_t)+T.tlength);",
          "3298:       if(!ret)",
          "3299:         {",
          "3300:           if(errcode) *errcode= ENOMEM;",
          "3301:           return NULL;",
          "3302:         }",
          "3304:       memset(ret,0,sizeof(libraw_processed_image_t));",
          "3305:       ret->type   = LIBRAW_IMAGE_BITMAP;",
          "3306:       ret->height = T.theight;",
          "3307:       ret->width  = T.twidth;",
          "3308:       ret->colors = 3;",
          "3309:       ret->bits   = 8;",
          "3310:       ret->data_size = T.tlength;",
          "3311:       memmove(ret->data,T.thumb,T.tlength);",
          "3312:       if(errcode) *errcode= 0;",
          "3313:       return ret;",
          "3314:     }",
          "3315:   else if (T.tformat == LIBRAW_THUMBNAIL_JPEG)",
          "3317:       ushort exif[5];",
          "3318:       int mk_exif = 0;",
          "3319:       if(strcmp(T.thumb+6,\"Exif\")) mk_exif = 1;",
          "3321:       int dsize = T.tlength + mk_exif * (sizeof(exif)+sizeof(tiff_hdr));",
          "3323:       libraw_processed_image_t * ret =",
          "3324:         (libraw_processed_image_t *)::malloc(sizeof(libraw_processed_image_t)+dsize);",
          "3326:       if(!ret)",
          "3327:         {",
          "3328:           if(errcode) *errcode= ENOMEM;",
          "3329:           return NULL;",
          "3330:         }",
          "3332:       memset(ret,0,sizeof(libraw_processed_image_t));",
          "3334:       ret->type = LIBRAW_IMAGE_JPEG;",
          "3335:       ret->data_size = dsize;",
          "3337:       ret->data[0] = 0xff;",
          "3338:       ret->data[1] = 0xd8;",
          "3339:       if(mk_exif)",
          "3340:         {",
          "3341:           struct tiff_hdr th;",
          "3342:           memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);",
          "3343:           exif[1] = htons (8 + sizeof th);",
          "3344:           memmove(ret->data+2,exif,sizeof(exif));",
          "3345:           tiff_head (&th, 0);",
          "3346:           memmove(ret->data+(2+sizeof(exif)),&th,sizeof(th));",
          "3347:           memmove(ret->data+(2+sizeof(exif)+sizeof(th)),T.thumb+2,T.tlength-2);",
          "3348:         }",
          "3349:       else",
          "3350:         {",
          "3351:           memmove(ret->data+2,T.thumb+2,T.tlength-2);",
          "3352:         }",
          "3353:       if(errcode) *errcode= 0;",
          "3354:       return ret;",
          "3357:   else",
          "3359:       if(errcode) *errcode= LIBRAW_UNSUPPORTED_THUMBNAIL;",
          "3360:       return NULL;",
          "3368: #define FORBGR for(c=P1.colors-1; c >=0 ; c--)",
          "3369: #define FORRGB for(c=0; c < P1.colors ; c++)",
          "3371: void LibRaw::get_mem_image_format(int* width, int* height, int* colors, int* bps) const",
          "3374:   if (S.flip & 4) {",
          "3378:   else {",
          "",
          "[Added Lines]",
          "3189:     {",
          "3190:       int crop[4], c, filt;",
          "3191:       for (int c = 0; c < 4; c++)",
          "3193:         crop[c] = O.cropbox[c];",
          "3194:         if (crop[c] < 0)",
          "3195:           crop[c] = 0;",
          "3196:       }",
          "3198:       if (IO.fuji_width && imgdata.idata.filters >= 1000)",
          "3199:       {",
          "3200:         crop[0] = (crop[0] / 4) * 4;",
          "3201:         crop[1] = (crop[1] / 4) * 4;",
          "3202:         if (!libraw_internal_data.unpacker_data.fuji_layout)",
          "3203:         {",
          "3204:           crop[2] *= sqrt(2.0);",
          "3205:           crop[3] /= sqrt(2.0);",
          "3206:         }",
          "3207:         crop[2] = (crop[2] / 4 + 1) * 4;",
          "3208:         crop[3] = (crop[3] / 4 + 1) * 4;",
          "3209:       }",
          "3210:       else if (imgdata.idata.filters == 1)",
          "3211:       {",
          "3212:         crop[0] = (crop[0] / 16) * 16;",
          "3213:         crop[1] = (crop[1] / 16) * 16;",
          "3214:       }",
          "3215:       else if (imgdata.idata.filters == LIBRAW_XTRANS)",
          "3216:       {",
          "3217:         crop[0] = (crop[0] / 6) * 6;",
          "3218:         crop[1] = (crop[1] / 6) * 6;",
          "3219:       }",
          "3220:       do_crop = 1;",
          "3222:       crop[2] = MIN(crop[2], (signed)S.width - crop[0]);",
          "3223:       crop[3] = MIN(crop[3], (signed)S.height - crop[1]);",
          "3224:       if (crop[2] <= 0 || crop[3] <= 0)",
          "3225:         throw LIBRAW_EXCEPTION_BAD_CROP;",
          "3228:       S.left_margin += crop[0];",
          "3229:       S.top_margin += crop[1];",
          "3230:       S.width = crop[2];",
          "3231:       S.height = crop[3];",
          "3233:       S.iheight = (S.height + IO.shrink) >> IO.shrink;",
          "3234:       S.iwidth = (S.width + IO.shrink) >> IO.shrink;",
          "3235:       if (!IO.fuji_width && imgdata.idata.filters && imgdata.idata.filters >= 1000)",
          "3236:       {",
          "3237:         for (filt = c = 0; c < 16; c++)",
          "3238:           filt |= FC((c >> 1) + (crop[1]), (c & 1) + (crop[0])) << c * 2;",
          "3239:         imgdata.idata.filters = filt;",
          "3241:     }",
          "3246:     if (IO.fuji_width && do_crop)",
          "3247:     {",
          "3248:       int IO_fw = S.width >> !libraw_internal_data.unpacker_data.fuji_layout;",
          "3249:       int t_alloc_width = (S.height >> libraw_internal_data.unpacker_data.fuji_layout) + IO_fw;",
          "3250:       int t_alloc_height = t_alloc_width - 1;",
          "3251:       alloc_height = (t_alloc_height + IO.shrink) >> IO.shrink;",
          "3252:       alloc_width = (t_alloc_width + IO.shrink) >> IO.shrink;",
          "3253:     }",
          "3254:     int alloc_sz = alloc_width * alloc_height;",
          "3256:     if (imgdata.image)",
          "3257:     {",
          "3258:       imgdata.image = (ushort(*)[4])realloc(imgdata.image, alloc_sz * sizeof(*imgdata.image));",
          "3259:       memset(imgdata.image, 0, alloc_sz * sizeof(*imgdata.image));",
          "3260:     }",
          "3262:       imgdata.image = (ushort(*)[4])calloc(alloc_sz, sizeof(*imgdata.image));",
          "3263:     merror(imgdata.image, \"raw2image_ex()\");",
          "3269:     unsigned short cblack[4] = {0, 0, 0, 0};",
          "3271:     if (do_subtract_black)",
          "3272:     {",
          "3273:       adjust_bl();",
          "3274:       for (int i = 0; i < 4; i++)",
          "3275:         cblack[i] = (unsigned short)C.cblack[i];",
          "3276:     }",
          "3279:     if (imgdata.idata.filters || P1.colors == 1)",
          "3280:     {",
          "3281:       if (IO.fuji_width)",
          "3283:         if (do_crop)",
          "3284:         {",
          "3285:           IO.fuji_width = S.width >> !libraw_internal_data.unpacker_data.fuji_layout;",
          "3286:           int IO_fwidth = (S.height >> libraw_internal_data.unpacker_data.fuji_layout) + IO.fuji_width;",
          "3287:           int IO_fheight = IO_fwidth - 1;",
          "3289:           int row, col;",
          "3290:           for (row = 0; row < S.height; row++)",
          "3292:             for (col = 0; col < S.width; col++)",
          "3293:             {",
          "3294:               int r, c;",
          "3295:               if (libraw_internal_data.unpacker_data.fuji_layout)",
          "3297:                 r = IO.fuji_width - 1 - col + (row >> 1);",
          "3298:                 c = col + ((row + 1) >> 1);",
          "3300:               else",
          "3302:                 r = IO.fuji_width - 1 + row - (col >> 1);",
          "3303:                 c = row + ((col + 1) >> 1);",
          "3306:               unsigned short val =",
          "3307:                   imgdata.rawdata.raw_image[(row + S.top_margin) * S.raw_pitch / 2 + (col + S.left_margin)];",
          "3308:               int cc = FCF(row, col);",
          "3309:               if (val > cblack[cc])",
          "3311:                 val -= cblack[cc];",
          "3312:                 if (dmax < val)",
          "3313:                   dmax = val;",
          "3315:               else",
          "3316:                 val = 0;",
          "3317:               imgdata.image[((r) >> IO.shrink) * alloc_width + ((c) >> IO.shrink)][cc] = val;",
          "3318:             }",
          "3320:           S.height = IO_fheight;",
          "3321:           S.width = IO_fwidth;",
          "3322:           S.iheight = (S.height + IO.shrink) >> IO.shrink;",
          "3323:           S.iwidth = (S.width + IO.shrink) >> IO.shrink;",
          "3324:           S.raw_height -= 2 * S.top_margin;",
          "3325:         }",
          "3326:         else",
          "3327:         {",
          "3328:           copy_fuji_uncropped(cblack, &dmax);",
          "3329:         }",
          "3330:       } // end Fuji",
          "3331:       else",
          "3332:       {",
          "3333:         copy_bayer(cblack, &dmax);",
          "3334:       }",
          "3335:     }",
          "3336:     else // if(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "3337:     {",
          "3338:       if (imgdata.rawdata.color4_image)",
          "3339:       {",
          "3340:         if (S.raw_pitch != S.width * 8)",
          "3341:         {",
          "3342:           for (int row = 0; row < S.height; row++)",
          "3343:             memmove(&imgdata.image[row * S.width],",
          "3344:                     &imgdata.rawdata.color4_image[(row + S.top_margin) * S.raw_pitch / 8 + S.left_margin],",
          "3345:                     S.width * sizeof(*imgdata.image));",
          "3346:         }",
          "3348:         {",
          "3350:           memmove(imgdata.image, imgdata.rawdata.color4_image, S.width * S.height * sizeof(*imgdata.image));",
          "3351:         }",
          "3352:       }",
          "3353:       else if (imgdata.rawdata.color3_image)",
          "3354:       {",
          "3355:         unsigned char *c3image = (unsigned char *)imgdata.rawdata.color3_image;",
          "3356:         for (int row = 0; row < S.height; row++)",
          "3357:         {",
          "3358:           ushort(*srcrow)[3] = (ushort(*)[3]) & c3image[(row + S.top_margin) * S.raw_pitch];",
          "3359:           ushort(*dstrow)[4] = (ushort(*)[4]) & imgdata.image[row * S.width];",
          "3360:           for (int col = 0; col < S.width; col++)",
          "3362:             for (int c = 0; c < 3; c++)",
          "3363:               dstrow[col][c] = srcrow[S.left_margin + col][c];",
          "3364:             dstrow[col][3] = 0;",
          "3366:         }",
          "3367:       }",
          "3368:       else",
          "3369:       {",
          "3371:         throw LIBRAW_EXCEPTION_DECODE_RAW;",
          "3373:     }",
          "3377:     {",
          "3378:       phase_one_free_tempbuffer();",
          "3379:     }",
          "3381:     {",
          "3382:       canon_600_correct();",
          "3383:     }",
          "3385:     if (do_subtract_black)",
          "3386:     {",
          "3387:       C.data_maximum = (int)dmax;",
          "3388:       C.maximum -= C.black;",
          "3390:       C.cblack[0] = C.cblack[1] = C.cblack[2] = C.cblack[3] = 0;",
          "3391:       C.black = 0;",
          "3392:     }",
          "3395:     imgdata.progress_flags = LIBRAW_PROGRESS_START | LIBRAW_PROGRESS_OPEN | LIBRAW_PROGRESS_RAW2_IMAGE |",
          "3396:                              LIBRAW_PROGRESS_IDENTIFY | LIBRAW_PROGRESS_SIZE_ADJUST | LIBRAW_PROGRESS_LOAD_RAW;",
          "3399:   catch (LibRaw_exceptions err)",
          "3400:   {",
          "3407: libraw_processed_image_t *LibRaw::dcraw_make_mem_thumb(int *errcode)",
          "3409:   if (!T.thumb)",
          "3410:   {",
          "3411:     if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 && load_raw == &LibRaw::broadcom_load_raw) // RPi",
          "3413:     {",
          "3414:       if (errcode)",
          "3417:     else",
          "3419:       if (errcode)",
          "3421:     }",
          "3422:     return NULL;",
          "3423:   }",
          "3425:   if (T.tformat == LIBRAW_THUMBNAIL_BITMAP)",
          "3426:   {",
          "3427:     libraw_processed_image_t *ret = (libraw_processed_image_t *)::malloc(sizeof(libraw_processed_image_t) + T.tlength);",
          "3429:     if (!ret)",
          "3431:       if (errcode)",
          "3433:       return NULL;",
          "3434:     }",
          "3436:     memset(ret, 0, sizeof(libraw_processed_image_t));",
          "3437:     ret->type = LIBRAW_IMAGE_BITMAP;",
          "3438:     ret->height = T.theight;",
          "3439:     ret->width = T.twidth;",
          "3440:     ret->colors = 3;",
          "3441:     ret->bits = 8;",
          "3442:     ret->data_size = T.tlength;",
          "3443:     memmove(ret->data, T.thumb, T.tlength);",
          "3444:     if (errcode)",
          "3446:     return ret;",
          "3447:   }",
          "3448:   else if (T.tformat == LIBRAW_THUMBNAIL_JPEG)",
          "3449:   {",
          "3450:     ushort exif[5];",
          "3451:     int mk_exif = 0;",
          "3452:     if (strcmp(T.thumb + 6, \"Exif\"))",
          "3453:       mk_exif = 1;",
          "3455:     int dsize = T.tlength + mk_exif * (sizeof(exif) + sizeof(tiff_hdr));",
          "3457:     libraw_processed_image_t *ret = (libraw_processed_image_t *)::malloc(sizeof(libraw_processed_image_t) + dsize);",
          "3459:     if (!ret)",
          "3460:     {",
          "3461:       if (errcode)",
          "3463:       return NULL;",
          "3464:     }",
          "3466:     memset(ret, 0, sizeof(libraw_processed_image_t));",
          "3468:     ret->type = LIBRAW_IMAGE_JPEG;",
          "3469:     ret->data_size = dsize;",
          "3471:     ret->data[0] = 0xff;",
          "3472:     ret->data[1] = 0xd8;",
          "3473:     if (mk_exif)",
          "3474:     {",
          "3475:       struct tiff_hdr th;",
          "3476:       memcpy(exif, \"\\xff\\xe1  Exif\\0\\0\", 10);",
          "3477:       exif[1] = htons(8 + sizeof th);",
          "3478:       memmove(ret->data + 2, exif, sizeof(exif));",
          "3479:       tiff_head(&th, 0);",
          "3480:       memmove(ret->data + (2 + sizeof(exif)), &th, sizeof(th));",
          "3481:       memmove(ret->data + (2 + sizeof(exif) + sizeof(th)), T.thumb + 2, T.tlength - 2);",
          "3483:     else",
          "3485:       memmove(ret->data + 2, T.thumb + 2, T.tlength - 2);",
          "3487:     if (errcode)",
          "3489:     return ret;",
          "3490:   }",
          "3491:   else",
          "3492:   {",
          "3493:     if (errcode)",
          "3495:     return NULL;",
          "3496:   }",
          "3501: #define FORBGR for (c = P1.colors - 1; c >= 0; c--)",
          "3502: #define FORRGB for (c = 0; c < P1.colors; c++)",
          "3504: void LibRaw::get_mem_image_format(int *width, int *height, int *colors, int *bps) const",
          "3507:   if (S.flip & 4)",
          "3508:   {",
          "3512:   else",
          "3513:   {",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "3384: }",
          "3388: {",
          "3394:       {",
          "3405:       }",
          "3425:       {",
          "3451:       }",
          "3461: }",
          "3462: #undef FORBGR",
          "3463: #undef FORRGB",
          "3467: libraw_processed_image_t *LibRaw::dcraw_make_mem_image(int *errcode)",
          "3469: {",
          "3492: }",
          "3494: #undef FORC",
          "",
          "[Removed Lines]",
          "3386: int LibRaw::copy_mem_image(void* scan0, int stride, int bgr)",
          "3390:     if((imgdata.progress_flags & LIBRAW_PROGRESS_THUMB_MASK) < LIBRAW_PROGRESS_PRE_INTERPOLATE)",
          "3391:         return LIBRAW_OUT_OF_ORDER_CALL;",
          "3393:     if(libraw_internal_data.output_data.histogram)",
          "3395:         int perc, val, total, t_white=0x2000,c;",
          "3396:         perc = S.width * S.height * O.auto_bright_thr;",
          "3397:         if (IO.fuji_width) perc /= 2;",
          "3398:         if (!((O.highlight & ~2) || O.no_auto_bright))",
          "3399:           for (t_white=c=0; c < P1.colors; c++) {",
          "3400:             for (val=0x2000, total=0; --val > 32; )",
          "3401:               if ((total += libraw_internal_data.output_data.histogram[c][val]) > perc) break;",
          "3402:             if (t_white < val) t_white = val;",
          "3403:           }",
          "3404:         gamma_curve (O.gamm[0], O.gamm[1], 2, (t_white << 3)/O.bright);",
          "3407:     int s_iheight = S.iheight;",
          "3408:     int s_iwidth = S.iwidth;",
          "3409:     int s_width = S.width;",
          "3410:     int s_hwight = S.height;",
          "3412:     S.iheight = S.height;",
          "3413:     S.iwidth  = S.width;",
          "3415:     if (S.flip & 4) SWAP(S.height,S.width);",
          "3416:     uchar *ppm;",
          "3417:     ushort *ppm2;",
          "3418:     int c, row, col, soff, rstep, cstep;",
          "3420:     soff  = flip_index (0, 0);",
          "3421:     cstep = flip_index (0, 1) - soff;",
          "3422:     rstep = flip_index (1, 0) - flip_index (0, S.width);",
          "3424:     for (row=0; row < S.height; row++, soff += rstep)",
          "3426:         uchar *bufp = ((uchar*)scan0)+row*stride;",
          "3427:         ppm2 = (ushort*) (ppm = bufp);",
          "3429:         if (bgr) {",
          "3430:           if (O.output_bps == 8) {",
          "3431:             for (col=0; col < S.width; col++, soff += cstep)",
          "3432:               FORBGR *ppm++ = imgdata.color.curve[imgdata.image[soff][c]]>>8;",
          "3433:           }",
          "3434:           else {",
          "3435:             for (col=0; col < S.width; col++, soff += cstep)",
          "3436:               FORBGR *ppm2++ = imgdata.color.curve[imgdata.image[soff][c]];",
          "3437:           }",
          "3438:         }",
          "3439:         else {",
          "3440:           if (O.output_bps == 8) {",
          "3441:             for (col=0; col < S.width; col++, soff += cstep)",
          "3442:               FORRGB *ppm++ = imgdata.color.curve[imgdata.image[soff][c]]>>8;",
          "3443:           }",
          "3444:           else {",
          "3445:             for (col=0; col < S.width; col++, soff += cstep)",
          "3446:               FORRGB *ppm2++ = imgdata.color.curve[imgdata.image[soff][c]];",
          "3447:           }",
          "3448:         }",
          "3453:     S.iheight = s_iheight;",
          "3454:     S.iwidth = s_iwidth;",
          "3455:     S.width = s_width;",
          "3456:     S.height = s_hwight;",
          "3458:     return 0;",
          "3470:     int width, height, colors, bps;",
          "3471:     get_mem_image_format(&width, &height, &colors, &bps);",
          "3472:     int stride = width * (bps/8) * colors;",
          "3473:     unsigned ds = height * stride;",
          "3474:     libraw_processed_image_t *ret = (libraw_processed_image_t*)::malloc(sizeof(libraw_processed_image_t)+ds);",
          "3475:     if(!ret)",
          "3476:         {",
          "3477:                 if(errcode) *errcode= ENOMEM;",
          "3478:                 return NULL;",
          "3479:         }",
          "3480:     memset(ret,0,sizeof(libraw_processed_image_t));",
          "3483:     ret->type   = LIBRAW_IMAGE_BITMAP;",
          "3484:     ret->height = height;",
          "3485:     ret->width  = width;",
          "3486:     ret->colors = colors;",
          "3487:     ret->bits   = bps;",
          "3488:     ret->data_size = ds;",
          "3489:     copy_mem_image(ret->data, stride, 0);",
          "3491:     return ret;",
          "",
          "[Added Lines]",
          "3521: int LibRaw::copy_mem_image(void *scan0, int stride, int bgr)",
          "3525:   if ((imgdata.progress_flags & LIBRAW_PROGRESS_THUMB_MASK) < LIBRAW_PROGRESS_PRE_INTERPOLATE)",
          "3526:     return LIBRAW_OUT_OF_ORDER_CALL;",
          "3528:   if (libraw_internal_data.output_data.histogram)",
          "3529:   {",
          "3530:     int perc, val, total, t_white = 0x2000, c;",
          "3531:     perc = S.width * S.height * O.auto_bright_thr;",
          "3532:     if (IO.fuji_width)",
          "3533:       perc /= 2;",
          "3534:     if (!((O.highlight & ~2) || O.no_auto_bright))",
          "3535:       for (t_white = c = 0; c < P1.colors; c++)",
          "3537:         for (val = 0x2000, total = 0; --val > 32;)",
          "3538:           if ((total += libraw_internal_data.output_data.histogram[c][val]) > perc)",
          "3539:             break;",
          "3540:         if (t_white < val)",
          "3541:           t_white = val;",
          "3543:     gamma_curve(O.gamm[0], O.gamm[1], 2, (t_white << 3) / O.bright);",
          "3544:   }",
          "3546:   int s_iheight = S.iheight;",
          "3547:   int s_iwidth = S.iwidth;",
          "3548:   int s_width = S.width;",
          "3549:   int s_hwight = S.height;",
          "3551:   S.iheight = S.height;",
          "3552:   S.iwidth = S.width;",
          "3554:   if (S.flip & 4)",
          "3555:     SWAP(S.height, S.width);",
          "3556:   uchar *ppm;",
          "3557:   ushort *ppm2;",
          "3558:   int c, row, col, soff, rstep, cstep;",
          "3560:   soff = flip_index(0, 0);",
          "3561:   cstep = flip_index(0, 1) - soff;",
          "3562:   rstep = flip_index(1, 0) - flip_index(0, S.width);",
          "3564:   for (row = 0; row < S.height; row++, soff += rstep)",
          "3565:   {",
          "3566:     uchar *bufp = ((uchar *)scan0) + row * stride;",
          "3567:     ppm2 = (ushort *)(ppm = bufp);",
          "3569:     if (bgr)",
          "3570:     {",
          "3571:       if (O.output_bps == 8)",
          "3573:         for (col = 0; col < S.width; col++, soff += cstep)",
          "3574:           FORBGR *ppm++ = imgdata.color.curve[imgdata.image[soff][c]] >> 8;",
          "3576:       else",
          "3577:       {",
          "3578:         for (col = 0; col < S.width; col++, soff += cstep)",
          "3579:           FORBGR *ppm2++ = imgdata.color.curve[imgdata.image[soff][c]];",
          "3580:       }",
          "3581:     }",
          "3582:     else",
          "3583:     {",
          "3584:       if (O.output_bps == 8)",
          "3585:       {",
          "3586:         for (col = 0; col < S.width; col++, soff += cstep)",
          "3587:           FORRGB *ppm++ = imgdata.color.curve[imgdata.image[soff][c]] >> 8;",
          "3588:       }",
          "3589:       else",
          "3590:       {",
          "3591:         for (col = 0; col < S.width; col++, soff += cstep)",
          "3592:           FORRGB *ppm2++ = imgdata.color.curve[imgdata.image[soff][c]];",
          "3593:       }",
          "3594:     }",
          "3597:   }",
          "3599:   S.iheight = s_iheight;",
          "3600:   S.iwidth = s_iwidth;",
          "3601:   S.width = s_width;",
          "3602:   S.height = s_hwight;",
          "3604:   return 0;",
          "3612:   int width, height, colors, bps;",
          "3613:   get_mem_image_format(&width, &height, &colors, &bps);",
          "3614:   int stride = width * (bps / 8) * colors;",
          "3615:   unsigned ds = height * stride;",
          "3616:   libraw_processed_image_t *ret = (libraw_processed_image_t *)::malloc(sizeof(libraw_processed_image_t) + ds);",
          "3617:   if (!ret)",
          "3618:   {",
          "3619:     if (errcode)",
          "3621:     return NULL;",
          "3622:   }",
          "3623:   memset(ret, 0, sizeof(libraw_processed_image_t));",
          "3626:   ret->type = LIBRAW_IMAGE_BITMAP;",
          "3627:   ret->height = height;",
          "3628:   ret->width = width;",
          "3629:   ret->colors = colors;",
          "3630:   ret->bits = bps;",
          "3631:   ret->data_size = ds;",
          "3632:   copy_mem_image(ret->data, stride, 0);",
          "3634:   return ret;",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "3496: #undef SWAP",
          "3497: #endif",
          "3500: int LibRaw::dcraw_ppm_tiff_writer(const char *filename)",
          "3501: {",
          "3502:   CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);",
          "3505:     return LIBRAW_OUT_OF_ORDER_CALL;",
          "3508:     return ENOENT;",
          "3512:     return errno;",
          "3521:     libraw_internal_data.internal_data.output = f;",
          "3522:     write_ppm_tiff();",
          "3523:     SET_PROC_FLAG(LIBRAW_PROGRESS_FLIP);",
          "",
          "[Removed Lines]",
          "3504:   if(!imgdata.image)",
          "3507:   if(!filename)",
          "3509:   FILE *f = fopen(filename,\"wb\");",
          "3511:   if(!f)",
          "3514:   try {",
          "3515:     if(!libraw_internal_data.output_data.histogram)",
          "3516:       {",
          "3517:         libraw_internal_data.output_data.histogram =",
          "3518:           (int (*)[LIBRAW_HISTOGRAM_SIZE]) malloc(sizeof(*libraw_internal_data.output_data.histogram)*4);",
          "3519:         merror(libraw_internal_data.output_data.histogram,\"LibRaw::dcraw_ppm_tiff_writer()\");",
          "3520:       }",
          "",
          "[Added Lines]",
          "3646:   if (!imgdata.image)",
          "3649:   if (!filename)",
          "3651:   FILE *f = fopen(filename, \"wb\");",
          "3653:   if (!f)",
          "3656:   try",
          "3657:   {",
          "3658:     if (!libraw_internal_data.output_data.histogram)",
          "3659:     {",
          "3660:       libraw_internal_data.output_data.histogram =",
          "3661:           (int(*)[LIBRAW_HISTOGRAM_SIZE])malloc(sizeof(*libraw_internal_data.output_data.histogram) * 4);",
          "3662:       merror(libraw_internal_data.output_data.histogram, \"LibRaw::dcraw_ppm_tiff_writer()\");",
          "3663:     }",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "3525:     fclose(f);",
          "3526:     return 0;",
          "3527:   }",
          "3529:     fclose(f);",
          "3530:     EXCEPTION_HANDLER(err);",
          "3531:   }",
          "3532: }",
          "3536: void LibRaw::kodak_thumb_loader()",
          "3537: {",
          "3547:   ushort s_flags = libraw_internal_data.unpacker_data.load_flags;",
          "3548:   libraw_internal_data.unpacker_data.load_flags = 12;",
          "3549:   int s_colors = P1.colors;",
          "3550:   unsigned s_filters = P1.filters;",
          "3553:   S.height = T.theight;",
          "3555:   P1.filters = 0;",
          "3557:   if (thumb_load_raw == &CLASS kodak_ycbcr_load_raw)",
          "3566:   ID.input->seek(ID.toffset, SEEK_SET);",
          "3571:   {",
          "3591:   }",
          "3597: #ifndef CLIP",
          "3599: #endif",
          "3603:   {",
          "3605:     float scale_mul[4];",
          "3608:       if (dmax > C.pre_mul[c])",
          "3609:         dmax = C.pre_mul[c];",
          "3612:       scale_mul[c] = (C.pre_mul[c] / dmax) * 65535.0 / C.maximum;",
          "3613:     scale_mul[3] = scale_mul[1];",
          "3615:     size_t size = S.height * S.width;",
          "3623:   }",
          "3626:   ushort *img;",
          "3632:   float out[3],",
          "3642:       {",
          "3656:       }",
          "3660:   libraw_internal_data.output_data.histogram = t_hist;",
          "3667:   {",
          "3672:     if (!((O.highlight & ~2) || O.no_auto_bright))",
          "3677:       }",
          "3679:   }",
          "3681:   libraw_internal_data.output_data.histogram = save_hist;",
          "",
          "[Removed Lines]",
          "3528:   catch ( LibRaw_exceptions err) {",
          "3534: #define THUMB_READ_BEYOND  16384",
          "3538:  INT64 est_datasize = T.theight * T.twidth / 3; // is 0.3 bytes per pixel good estimate?",
          "3539:  if (ID.toffset < 0)",
          "3540:   throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "3542:  if (ID.toffset + est_datasize > ID.input->size() + THUMB_READ_BEYOND)",
          "3543:   throw LIBRAW_EXCEPTION_IO_EOF;",
          "3546:   ushort s_height = S.height, s_width = S.width,s_iwidth = S.iwidth,s_iheight=S.iheight;",
          "3551:   ushort (*s_image)[4] = imgdata.image;",
          "3554:   S.width  = T.twidth;",
          "3558:     {",
          "3559:       S.height += S.height & 1;",
          "3560:       S.width  += S.width  & 1;",
          "3561:     }",
          "3563:   imgdata.image = (ushort (*)[4]) calloc (S.iheight*S.iwidth, sizeof (*imgdata.image));",
          "3564:   merror (imgdata.image, \"LibRaw::kodak_thumb_loader()\");",
          "3568:   try {",
          "3569:    (this->*thumb_load_raw)();",
          "3570:   } catch (...)",
          "3572:    free(imgdata.image);",
          "3573:    imgdata.image  = s_image;",
          "3575:    T.twidth = 0;",
          "3576:    S.width = s_width;",
          "3578:    S.iwidth = s_iwidth;",
          "3579:    S.iheight = s_iheight;",
          "3581:    T.theight = 0;",
          "3582:    S.height = s_height;",
          "3584:    T.tcolors = 0;",
          "3585:    P1.colors = s_colors;",
          "3587:    P1.filters = s_filters;",
          "3588:    T.tlength=0;",
          "3589:    libraw_internal_data.unpacker_data.load_flags = s_flags;",
          "3590:    return;",
          "3594: #define MIN(a,b) ((a) < (b) ? (a) : (b))",
          "3595: #define MAX(a,b) ((a) > (b) ? (a) : (b))",
          "3596: #define LIM(x,min,max) MAX(min,MIN(x,max))",
          "3598: #define CLIP(x) LIM(x,0,65535)",
          "3600: #define SWAP(a,b) { a ^= b; a ^= (b ^= a); }",
          "3604:     double   dmax;",
          "3606:     int c,val;",
          "3607:     for (dmax=DBL_MAX, c=0; c < 3; c++)",
          "3611:     for( c=0; c< 3; c++)",
          "3616:     for (unsigned i=0; i < size*4 ; i++)",
          "3617:       {",
          "3618:         val = imgdata.image[0][i];",
          "3619:         if(!val) continue;",
          "3620:         val *= scale_mul[i & 3];",
          "3621:         imgdata.image[0][i] = CLIP(val);",
          "3622:       }",
          "3627:   int row,col;",
          "3629:   int  (*t_hist)[LIBRAW_HISTOGRAM_SIZE] =  (int (*)[LIBRAW_HISTOGRAM_SIZE]) calloc(sizeof(*t_hist),4);",
          "3630:   merror (t_hist, \"LibRaw::kodak_thumb_loader()\");",
          "3633:     out_cam[3][4] =",
          "3634:     {",
          "3635:       {2.81761312, -1.98369181, 0.166078627, 0},",
          "3636:       {-0.111855984, 1.73688626, -0.625030339, 0},",
          "3637:       {-0.0379119813, -0.891268849, 1.92918086, 0}",
          "3638:     };",
          "3640:   for (img=imgdata.image[0], row=0; row < S.height; row++)",
          "3641:     for (col=0; col < S.width; col++, img+=4)",
          "3643:         out[0] = out[1] = out[2] = 0;",
          "3644:         int c;",
          "3645:         for(c=0;c<3;c++)",
          "3646:           {",
          "3647:             out[0] += out_cam[0][c] * img[c];",
          "3648:             out[1] += out_cam[1][c] * img[c];",
          "3649:             out[2] += out_cam[2][c] * img[c];",
          "3650:           }",
          "3651:         for(c=0; c<3; c++)",
          "3652:           img[c] = CLIP((int) out[c]);",
          "3653:         for(c=0; c<P1.colors;c++)",
          "3654:           t_hist[c][img[c] >> 3]++;",
          "3659:   int  (*save_hist)[LIBRAW_HISTOGRAM_SIZE] = libraw_internal_data.output_data.histogram;",
          "3663:   ushort (*t_curve) = (ushort*) calloc(sizeof(C.curve),1);",
          "3664:   merror (t_curve, \"LibRaw::kodak_thumb_loader()\");",
          "3665:   memmove(t_curve,C.curve,sizeof(C.curve));",
          "3666:   memset(C.curve,0,sizeof(C.curve));",
          "3668:     int perc, val, total, t_white=0x2000,c;",
          "3671:     if (IO.fuji_width) perc /= 2;",
          "3673:       for (t_white=c=0; c < P1.colors; c++) {",
          "3674:         for (val=0x2000, total=0; --val > 32; )",
          "3675:           if ((total += libraw_internal_data.output_data.histogram[c][val]) > perc) break;",
          "3676:         if (t_white < val) t_white = val;",
          "3678:     gamma_curve (O.gamm[0], O.gamm[1], 2, (t_white << 3)/O.bright);",
          "",
          "[Added Lines]",
          "3671:   catch (LibRaw_exceptions err)",
          "3672:   {",
          "3678: #define THUMB_READ_BEYOND 16384",
          "3682:   INT64 est_datasize = T.theight * T.twidth / 3; // is 0.3 bytes per pixel good estimate?",
          "3683:   if (ID.toffset < 0)",
          "3684:     throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "3686:   if (ID.toffset + est_datasize > ID.input->size() + THUMB_READ_BEYOND)",
          "3687:     throw LIBRAW_EXCEPTION_IO_EOF;",
          "3690:   ushort s_height = S.height, s_width = S.width, s_iwidth = S.iwidth, s_iheight = S.iheight;",
          "3695:   ushort(*s_image)[4] = imgdata.image;",
          "3698:   S.width = T.twidth;",
          "3702:   {",
          "3703:     S.height += S.height & 1;",
          "3704:     S.width += S.width & 1;",
          "3705:   }",
          "3707:   imgdata.image = (ushort(*)[4])calloc(S.iheight * S.iwidth, sizeof(*imgdata.image));",
          "3708:   merror(imgdata.image, \"LibRaw::kodak_thumb_loader()\");",
          "3712:   try",
          "3713:   {",
          "3714:     (this->*thumb_load_raw)();",
          "3715:   }",
          "3716:   catch (...)",
          "3718:     free(imgdata.image);",
          "3719:     imgdata.image = s_image;",
          "3721:     T.twidth = 0;",
          "3722:     S.width = s_width;",
          "3724:     S.iwidth = s_iwidth;",
          "3725:     S.iheight = s_iheight;",
          "3727:     T.theight = 0;",
          "3728:     S.height = s_height;",
          "3730:     T.tcolors = 0;",
          "3731:     P1.colors = s_colors;",
          "3733:     P1.filters = s_filters;",
          "3734:     T.tlength = 0;",
          "3735:     libraw_internal_data.unpacker_data.load_flags = s_flags;",
          "3736:     return;",
          "3740: #define MIN(a, b) ((a) < (b) ? (a) : (b))",
          "3741: #define MAX(a, b) ((a) > (b) ? (a) : (b))",
          "3742: #define LIM(x, min, max) MAX(min, MIN(x, max))",
          "3744: #define CLIP(x) LIM(x, 0, 65535)",
          "3746: #define SWAP(a, b)                                                                                                     \\",
          "3747:   {                                                                                                                    \\",
          "3748:     a ^= b;                                                                                                            \\",
          "3749:     a ^= (b ^= a);                                                                                                     \\",
          "3750:   }",
          "3754:     double dmax;",
          "3756:     int c, val;",
          "3757:     for (dmax = DBL_MAX, c = 0; c < 3; c++)",
          "3761:     for (c = 0; c < 3; c++)",
          "3766:     for (unsigned i = 0; i < size * 4; i++)",
          "3767:     {",
          "3768:       val = imgdata.image[0][i];",
          "3769:       if (!val)",
          "3770:         continue;",
          "3771:       val *= scale_mul[i & 3];",
          "3772:       imgdata.image[0][i] = CLIP(val);",
          "3773:     }",
          "3778:   int row, col;",
          "3780:   int(*t_hist)[LIBRAW_HISTOGRAM_SIZE] = (int(*)[LIBRAW_HISTOGRAM_SIZE])calloc(sizeof(*t_hist), 4);",
          "3781:   merror(t_hist, \"LibRaw::kodak_thumb_loader()\");",
          "3784:       out_cam[3][4] = {{2.81761312, -1.98369181, 0.166078627, 0},",
          "3785:                        {-0.111855984, 1.73688626, -0.625030339, 0},",
          "3786:                        {-0.0379119813, -0.891268849, 1.92918086, 0}};",
          "3788:   for (img = imgdata.image[0], row = 0; row < S.height; row++)",
          "3789:     for (col = 0; col < S.width; col++, img += 4)",
          "3790:     {",
          "3791:       out[0] = out[1] = out[2] = 0;",
          "3792:       int c;",
          "3793:       for (c = 0; c < 3; c++)",
          "3795:         out[0] += out_cam[0][c] * img[c];",
          "3796:         out[1] += out_cam[1][c] * img[c];",
          "3797:         out[2] += out_cam[2][c] * img[c];",
          "3799:       for (c = 0; c < 3; c++)",
          "3800:         img[c] = CLIP((int)out[c]);",
          "3801:       for (c = 0; c < P1.colors; c++)",
          "3802:         t_hist[c][img[c] >> 3]++;",
          "3803:     }",
          "3806:   int(*save_hist)[LIBRAW_HISTOGRAM_SIZE] = libraw_internal_data.output_data.histogram;",
          "3810:   ushort(*t_curve) = (ushort *)calloc(sizeof(C.curve), 1);",
          "3811:   merror(t_curve, \"LibRaw::kodak_thumb_loader()\");",
          "3812:   memmove(t_curve, C.curve, sizeof(C.curve));",
          "3813:   memset(C.curve, 0, sizeof(C.curve));",
          "3815:     int perc, val, total, t_white = 0x2000, c;",
          "3818:     if (IO.fuji_width)",
          "3819:       perc /= 2;",
          "3821:       for (t_white = c = 0; c < P1.colors; c++)",
          "3822:       {",
          "3823:         for (val = 0x2000, total = 0; --val > 32;)",
          "3824:           if ((total += libraw_internal_data.output_data.histogram[c][val]) > perc)",
          "3825:             break;",
          "3826:         if (t_white < val)",
          "3827:           t_white = val;",
          "3829:     gamma_curve(O.gamm[0], O.gamm[1], 2, (t_white << 3) / O.bright);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "3686:   S.iheight = S.height;",
          "3693:   T.tlength = S.width * S.height * P1.colors;",
          "3696:   {",
          "3708:   }",
          "3710:   memmove(C.curve, t_curve, sizeof(C.curve));",
          "",
          "[Removed Lines]",
          "3687:   S.iwidth  = S.width;",
          "3688:   if (S.flip & 4) SWAP(S.height,S.width);",
          "3690:   if(T.thumb) free(T.thumb);",
          "3691:   T.thumb = (char*) calloc (S.width * S.height, P1.colors);",
          "3692:   merror (T.thumb, \"LibRaw::kodak_thumb_loader()\");",
          "3697:    int soff = flip_index(0, 0);",
          "3698:    int cstep = flip_index(0, 1) - soff;",
          "3699:    int rstep = flip_index(1, 0) - flip_index(0, S.width);",
          "3701:    for (int row = 0; row < S.height; row++, soff += rstep)",
          "3702:    {",
          "3703:     char *ppm = T.thumb + row*S.width*P1.colors;",
          "3704:     for (int col = 0; col < S.width; col++, soff += cstep)",
          "3705:      for (int c = 0; c < P1.colors; c++)",
          "3706:       ppm[col*P1.colors + c] = imgdata.color.curve[imgdata.image[soff][c]] >> 8;",
          "3707:    }",
          "",
          "[Added Lines]",
          "3838:   S.iwidth = S.width;",
          "3839:   if (S.flip & 4)",
          "3840:     SWAP(S.height, S.width);",
          "3842:   if (T.thumb)",
          "3843:     free(T.thumb);",
          "3844:   T.thumb = (char *)calloc(S.width * S.height, P1.colors);",
          "3845:   merror(T.thumb, \"LibRaw::kodak_thumb_loader()\");",
          "3850:     int soff = flip_index(0, 0);",
          "3851:     int cstep = flip_index(0, 1) - soff;",
          "3852:     int rstep = flip_index(1, 0) - flip_index(0, S.width);",
          "3854:     for (int row = 0; row < S.height; row++, soff += rstep)",
          "3855:     {",
          "3856:       char *ppm = T.thumb + row * S.width * P1.colors;",
          "3857:       for (int col = 0; col < S.width; col++, soff += cstep)",
          "3858:         for (int c = 0; c < P1.colors; c++)",
          "3859:           ppm[col * P1.colors + c] = imgdata.color.curve[imgdata.image[soff][c]] >> 8;",
          "3860:     }",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "3735: #undef CLIP",
          "3736: #undef SWAP",
          "3741: int LibRaw::thumbOK(INT64 maxsz)",
          "3742: {",
          "3768: }",
          "3770: int LibRaw::unpack_thumb(void)",
          "3771: {",
          "3866: #ifdef LIBRAW_DEMOSAIC_PACK_GPL2",
          "3876: #endif",
          "3881:       }",
          "3883:     return LIBRAW_UNSUPPORTED_THUMBNAIL;",
          "3884:   }",
          "3886:     EXCEPTION_HANDLER(err);",
          "3887:   }",
          "3889: }",
          "3891: int LibRaw::dcraw_thumb_writer(const char *fname)",
          "3892: {",
          "3896:     return ENOENT;",
          "3901:     return errno;",
          "3904:     {",
          "3905:       fclose(tfp);",
          "3907:     }",
          "3923:     fclose(tfp);",
          "3924:     return 0;",
          "3925:   }",
          "3927:     fclose(tfp);",
          "3928:     EXCEPTION_HANDLER(err);",
          "3929:   }",
          "",
          "[Removed Lines]",
          "3743:  if (!ID.input) return 0;",
          "3744:  if (!ID.toffset",
          "3745:   && !(imgdata.thumbnail.tlength > 0 && load_raw == &LibRaw::broadcom_load_raw) // RPi",
          "3746:   ) return 0;",
          "3747:  INT64 fsize = ID.input->size();",
          "3748:  if (fsize > 0x7fffffffU) return 0; // No thumb for raw > 2Gb",
          "3749:  int tsize = 0;",
          "3750:  int tcol = (T.tcolors > 0 && T.tcolors < 4) ? T.tcolors : 3;",
          "3751:  if (write_thumb == &LibRaw::jpeg_thumb)",
          "3752:   tsize = T.tlength;",
          "3753:  else if (write_thumb == &LibRaw::ppm_thumb)",
          "3754:   tsize = tcol * T.twidth * T.theight;",
          "3755:  else if (write_thumb == &LibRaw::ppm16_thumb)",
          "3756:   tsize = tcol * T.twidth * T.theight * 2;",
          "3757:  else if (write_thumb == &LibRaw::x3f_thumb_loader)",
          "3758:  {",
          "3759:   tsize = x3f_thumb_size();",
          "3760:  }",
          "3761:  else // Kodak => no check",
          "3762:   tsize = 1;",
          "3763:  if (tsize < 0)",
          "3764:   return 0;",
          "3765:  if (maxsz > 0 && tsize > maxsz)",
          "3766:   return 0;",
          "3767:  return (tsize + ID.toffset <= fsize) ? 1 : 0;",
          "3772:  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);",
          "3773:  CHECK_ORDER_BIT(LIBRAW_PROGRESS_THUMB_LOAD);",
          "3775:  try {",
          "3776:   if (!libraw_internal_data.internal_data.input)",
          "3777:    return LIBRAW_INPUT_CLOSED;",
          "3779:   if (!ID.toffset &&",
          "3780:    !(imgdata.thumbnail.tlength > 0 && load_raw == &LibRaw::broadcom_load_raw) // RPi",
          "3781:    )",
          "3782:   {",
          "3783:    return LIBRAW_NO_THUMBNAIL;",
          "3784:   }",
          "3785:   else if (thumb_load_raw)",
          "3786:   {",
          "3787:    kodak_thumb_loader();",
          "3788:    T.tformat = LIBRAW_THUMBNAIL_BITMAP;",
          "3789:    SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "3790:    return 0;",
          "3791:   }",
          "3792:   else",
          "3793:   {",
          "3794:    if (write_thumb == &LibRaw::x3f_thumb_loader)",
          "3795:    {",
          "3796:     INT64 tsize = x3f_thumb_size();",
          "3797:     if (tsize < 2048 ||INT64(ID.toffset) + tsize < 1)",
          "3798:      throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "3800:     if (INT64(ID.toffset) + tsize > ID.input->size() + THUMB_READ_BEYOND)",
          "3801:      throw LIBRAW_EXCEPTION_IO_EOF;",
          "3802:    }",
          "3803:    else",
          "3804:    {",
          "3805:     if (INT64(ID.toffset) + INT64(T.tlength) < 1)",
          "3806:      throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "3808:     if (INT64(ID.toffset) + INT64(T.tlength) > ID.input->size() + THUMB_READ_BEYOND)",
          "3809:      throw LIBRAW_EXCEPTION_IO_EOF;",
          "3810:    }",
          "3812:         ID.input->seek(ID.toffset, SEEK_SET);",
          "3813:         if ( write_thumb == &LibRaw::jpeg_thumb)",
          "3814:           {",
          "3815:             if(T.thumb) free(T.thumb);",
          "3816:             T.thumb = (char *) malloc (T.tlength);",
          "3817:             merror (T.thumb, \"jpeg_thumb()\");",
          "3818:             ID.input->read (T.thumb, 1, T.tlength);",
          "3819:    T.thumb[0] = 0xff;",
          "3820:    T.thumb[1] = 0xd8;",
          "3821:             T.tcolors = 3;",
          "3822:             T.tformat = LIBRAW_THUMBNAIL_JPEG;",
          "3823:             SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "3824:             return 0;",
          "3825:           }",
          "3826:         else if (write_thumb == &LibRaw::ppm_thumb)",
          "3827:           {",
          "3828:             T.tlength = T.twidth * T.theight*3;",
          "3829:             if(T.thumb) free(T.thumb);",
          "3831:             T.thumb = (char *) malloc (T.tlength);",
          "3832:             merror (T.thumb, \"ppm_thumb()\");",
          "3834:             ID.input->read(T.thumb, 1, T.tlength);",
          "3836:             T.tformat = LIBRAW_THUMBNAIL_BITMAP;",
          "3837:             SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "3838:             return 0;",
          "3840:           }",
          "3841:         else if (write_thumb == &LibRaw::ppm16_thumb)",
          "3842:           {",
          "3843:             T.tlength = T.twidth * T.theight*3;",
          "3844:             ushort *t_thumb = (ushort*)calloc(T.tlength,2);",
          "3845:             ID.input->read(t_thumb,2,T.tlength);",
          "3846:             if ((libraw_internal_data.unpacker_data.order == 0x4949) == (ntohs(0x1234) == 0x1234))",
          "3847:               swab ((char*)t_thumb, (char*)t_thumb, T.tlength*2);",
          "3849:             if(T.thumb) free(T.thumb);",
          "3850:             T.thumb = (char *) malloc (T.tlength);",
          "3851:             merror (T.thumb, \"ppm_thumb()\");",
          "3852:             for (int i=0; i < T.tlength; i++)",
          "3853:               T.thumb[i] = t_thumb[i] >> 8;",
          "3854:             free(t_thumb);",
          "3855:             T.tformat = LIBRAW_THUMBNAIL_BITMAP;",
          "3856:             SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "3857:             return 0;",
          "3859:           }",
          "3860:         else if (write_thumb == &LibRaw::x3f_thumb_loader)",
          "3861:           {",
          "3862:             x3f_thumb_loader();",
          "3863:             SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "3864:             return 0;",
          "3865:           }",
          "3867:         else if (write_thumb == &LibRaw::foveon_thumb)",
          "3868:           {",
          "3869:             foveon_thumb_loader();",
          "3872:             SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "3873:             return 0;",
          "3874:           }",
          "3877:         else",
          "3878:           {",
          "3879:             return LIBRAW_UNSUPPORTED_THUMBNAIL;",
          "3880:           }",
          "3885:   catch ( LibRaw_exceptions err) {",
          "3895:   if(!fname)",
          "3898:   FILE *tfp = fopen(fname,\"wb\");",
          "3900:   if(!tfp)",
          "3903:   if(!T.thumb)",
          "3906:       return LIBRAW_OUT_OF_ORDER_CALL;",
          "3909:   try {",
          "3910:     switch (T.tformat)",
          "3911:       {",
          "3912:       case LIBRAW_THUMBNAIL_JPEG:",
          "3913:         jpeg_thumb_writer (tfp,T.thumb,T.tlength);",
          "3914:         break;",
          "3915:       case LIBRAW_THUMBNAIL_BITMAP:",
          "3916:         fprintf (tfp, \"P6\\n%d %d\\n255\\n\", T.twidth, T.theight);",
          "3917:         fwrite (T.thumb, 1, T.tlength, tfp);",
          "3918:         break;",
          "3919:       default:",
          "3920:         fclose(tfp);",
          "3921:         return LIBRAW_UNSUPPORTED_THUMBNAIL;",
          "3922:       }",
          "3926:   catch ( LibRaw_exceptions err) {",
          "",
          "[Added Lines]",
          "3895:   if (!ID.input)",
          "3896:     return 0;",
          "3897:   if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 && load_raw == &LibRaw::broadcom_load_raw) // RPi",
          "3898:       )",
          "3899:     return 0;",
          "3900:   INT64 fsize = ID.input->size();",
          "3901:   if (fsize > 0x7fffffffU)",
          "3902:     return 0; // No thumb for raw > 2Gb",
          "3903:   int tsize = 0;",
          "3904:   int tcol = (T.tcolors > 0 && T.tcolors < 4) ? T.tcolors : 3;",
          "3905:   if (write_thumb == &LibRaw::jpeg_thumb)",
          "3906:     tsize = T.tlength;",
          "3907:   else if (write_thumb == &LibRaw::ppm_thumb)",
          "3908:     tsize = tcol * T.twidth * T.theight;",
          "3909:   else if (write_thumb == &LibRaw::ppm16_thumb)",
          "3910:     tsize = tcol * T.twidth * T.theight * 2;",
          "3911:   else if (write_thumb == &LibRaw::x3f_thumb_loader)",
          "3912:   {",
          "3913:     tsize = x3f_thumb_size();",
          "3914:   }",
          "3915:   else // Kodak => no check",
          "3916:     tsize = 1;",
          "3917:   if (tsize < 0)",
          "3918:     return 0;",
          "3919:   if (maxsz > 0 && tsize > maxsz)",
          "3920:     return 0;",
          "3921:   return (tsize + ID.toffset <= fsize) ? 1 : 0;",
          "3926:   CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);",
          "3927:   CHECK_ORDER_BIT(LIBRAW_PROGRESS_THUMB_LOAD);",
          "3929:   try",
          "3930:   {",
          "3931:     if (!libraw_internal_data.internal_data.input)",
          "3932:       return LIBRAW_INPUT_CLOSED;",
          "3934:     if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 && load_raw == &LibRaw::broadcom_load_raw) // RPi",
          "3935:         )",
          "3936:     {",
          "3937:       return LIBRAW_NO_THUMBNAIL;",
          "3938:     }",
          "3939:     else if (thumb_load_raw)",
          "3940:     {",
          "3941:       kodak_thumb_loader();",
          "3942:       T.tformat = LIBRAW_THUMBNAIL_BITMAP;",
          "3943:       SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "3944:       return 0;",
          "3945:     }",
          "3946:     else",
          "3947:     {",
          "3948:       if (write_thumb == &LibRaw::x3f_thumb_loader)",
          "3949:       {",
          "3950:         INT64 tsize = x3f_thumb_size();",
          "3951:         if (tsize < 2048 || INT64(ID.toffset) + tsize < 1)",
          "3952:           throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "3954:         if (INT64(ID.toffset) + tsize > ID.input->size() + THUMB_READ_BEYOND)",
          "3955:           throw LIBRAW_EXCEPTION_IO_EOF;",
          "3956:       }",
          "3957:       else",
          "3958:       {",
          "3959:         if (INT64(ID.toffset) + INT64(T.tlength) < 1)",
          "3960:           throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "3962:         if (INT64(ID.toffset) + INT64(T.tlength) > ID.input->size() + THUMB_READ_BEYOND)",
          "3963:           throw LIBRAW_EXCEPTION_IO_EOF;",
          "3964:       }",
          "3966:       ID.input->seek(ID.toffset, SEEK_SET);",
          "3967:       if (write_thumb == &LibRaw::jpeg_thumb)",
          "3968:       {",
          "3969:         if (T.thumb)",
          "3970:           free(T.thumb);",
          "3971:         T.thumb = (char *)malloc(T.tlength);",
          "3972:         merror(T.thumb, \"jpeg_thumb()\");",
          "3973:         ID.input->read(T.thumb, 1, T.tlength);",
          "3974:         T.thumb[0] = 0xff;",
          "3975:         T.thumb[1] = 0xd8;",
          "3976:         T.tcolors = 3;",
          "3977:         T.tformat = LIBRAW_THUMBNAIL_JPEG;",
          "3978:         SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "3979:         return 0;",
          "3980:       }",
          "3981:       else if (write_thumb == &LibRaw::ppm_thumb)",
          "3982:       {",
          "3983:         T.tlength = T.twidth * T.theight * 3;",
          "3984:         if (T.thumb)",
          "3985:           free(T.thumb);",
          "3987:         T.thumb = (char *)malloc(T.tlength);",
          "3988:         merror(T.thumb, \"ppm_thumb()\");",
          "3990:         ID.input->read(T.thumb, 1, T.tlength);",
          "3992:         T.tformat = LIBRAW_THUMBNAIL_BITMAP;",
          "3993:         SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "3994:         return 0;",
          "3995:       }",
          "3996:       else if (write_thumb == &LibRaw::ppm16_thumb)",
          "3997:       {",
          "3998:         T.tlength = T.twidth * T.theight * 3;",
          "3999:         ushort *t_thumb = (ushort *)calloc(T.tlength, 2);",
          "4000:         ID.input->read(t_thumb, 2, T.tlength);",
          "4001:         if ((libraw_internal_data.unpacker_data.order == 0x4949) == (ntohs(0x1234) == 0x1234))",
          "4002:           swab((char *)t_thumb, (char *)t_thumb, T.tlength * 2);",
          "4004:         if (T.thumb)",
          "4005:           free(T.thumb);",
          "4006:         T.thumb = (char *)malloc(T.tlength);",
          "4007:         merror(T.thumb, \"ppm_thumb()\");",
          "4008:         for (int i = 0; i < T.tlength; i++)",
          "4009:           T.thumb[i] = t_thumb[i] >> 8;",
          "4010:         free(t_thumb);",
          "4011:         T.tformat = LIBRAW_THUMBNAIL_BITMAP;",
          "4012:         SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "4013:         return 0;",
          "4014:       }",
          "4015:       else if (write_thumb == &LibRaw::x3f_thumb_loader)",
          "4016:       {",
          "4017:         x3f_thumb_loader();",
          "4018:         SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "4019:         return 0;",
          "4020:       }",
          "4022:       else if (write_thumb == &LibRaw::foveon_thumb)",
          "4023:       {",
          "4024:         foveon_thumb_loader();",
          "4027:         SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "4028:         return 0;",
          "4029:       }",
          "4032:       else",
          "4033:       {",
          "4034:         return LIBRAW_UNSUPPORTED_THUMBNAIL;",
          "4036:     }",
          "4040:   catch (LibRaw_exceptions err)",
          "4041:   {",
          "4050:   if (!fname)",
          "4053:   FILE *tfp = fopen(fname, \"wb\");",
          "4055:   if (!tfp)",
          "4058:   if (!T.thumb)",
          "4059:   {",
          "4060:     fclose(tfp);",
          "4061:     return LIBRAW_OUT_OF_ORDER_CALL;",
          "4062:   }",
          "4064:   try",
          "4065:   {",
          "4066:     switch (T.tformat)",
          "4068:     case LIBRAW_THUMBNAIL_JPEG:",
          "4069:       jpeg_thumb_writer(tfp, T.thumb, T.tlength);",
          "4070:       break;",
          "4071:     case LIBRAW_THUMBNAIL_BITMAP:",
          "4072:       fprintf(tfp, \"P6\\n%d %d\\n255\\n\", T.twidth, T.theight);",
          "4073:       fwrite(T.thumb, 1, T.tlength, tfp);",
          "4074:       break;",
          "4075:     default:",
          "4077:       return LIBRAW_UNSUPPORTED_THUMBNAIL;",
          "4082:   catch (LibRaw_exceptions err)",
          "4083:   {",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "3936:   raw2image_start();",
          "3937:   if (O.use_fuji_rotate)",
          "3938:     {",
          "3950:     }",
          "3953:     {",
          "3958:     }",
          "3959:   return 0;",
          "3960: }",
          "",
          "[Removed Lines]",
          "3939:       if (IO.fuji_width)",
          "3940:         {",
          "3941:           IO.fuji_width = (IO.fuji_width - 1 + IO.shrink) >> IO.shrink;",
          "3942:           S.iwidth = (ushort)(IO.fuji_width / sqrt(0.5));",
          "3943:           S.iheight = (ushort)( (S.iheight - IO.fuji_width) / sqrt(0.5));",
          "3944:         }",
          "3945:       else",
          "3946:         {",
          "3947:           if (S.pixel_aspect < 0.995) S.iheight = (ushort)( S.iheight / S.pixel_aspect + 0.5);",
          "3948:           if (S.pixel_aspect > 1.005) S.iwidth  = (ushort) (S.iwidth  * S.pixel_aspect + 0.5);",
          "3949:         }",
          "3951:   SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE);",
          "3952:   if ( S.flip & 4)",
          "3954:       unsigned short t = S.iheight;",
          "3955:       S.iheight=S.iwidth;",
          "3956:       S.iwidth = t;",
          "3957:       SET_PROC_FLAG(LIBRAW_PROGRESS_FLIP);",
          "",
          "[Added Lines]",
          "4095:   {",
          "4096:     if (IO.fuji_width)",
          "4098:       IO.fuji_width = (IO.fuji_width - 1 + IO.shrink) >> IO.shrink;",
          "4099:       S.iwidth = (ushort)(IO.fuji_width / sqrt(0.5));",
          "4100:       S.iheight = (ushort)((S.iheight - IO.fuji_width) / sqrt(0.5));",
          "4102:     else",
          "4104:       if (S.pixel_aspect < 0.995)",
          "4105:         S.iheight = (ushort)(S.iheight / S.pixel_aspect + 0.5);",
          "4106:       if (S.pixel_aspect > 1.005)",
          "4107:         S.iwidth = (ushort)(S.iwidth * S.pixel_aspect + 0.5);",
          "4109:   }",
          "4110:   SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE);",
          "4111:   if (S.flip & 4)",
          "4112:   {",
          "4113:     unsigned short t = S.iheight;",
          "4114:     S.iheight = S.iwidth;",
          "4115:     S.iwidth = t;",
          "4116:     SET_PROC_FLAG(LIBRAW_PROGRESS_FLIP);",
          "4117:   }",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "3969: {",
          "3970:   CHECK_ORDER_LOW(LIBRAW_PROGRESS_RAW2_IMAGE);",
          "3974:       {",
          "4009: #undef MIN",
          "4010: #undef MAX",
          "4011: #undef LIM",
          "4012: #undef CLIP",
          "4016: #undef BAYERC",
          "4018:     else",
          "4029:     return 0;",
          "4030:   }",
          "4032:     EXCEPTION_HANDLER(err);",
          "4033:   }",
          "4035: }",
          "4037: #define TBLN 65535",
          "",
          "[Removed Lines]",
          "3972:   try {",
          "3973:     if(!is_phaseone_compressed() && (C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3] || (C.cblack[4] && C.cblack[5]) ))",
          "3975: #define BAYERC(row,col,c) imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][c]",
          "3976:         int cblk[4],i;",
          "3977:         for(i=0;i<4;i++)",
          "3978:           cblk[i] = C.cblack[i];",
          "3980:         int size = S.iheight * S.iwidth;",
          "3981: #define MIN(a,b) ((a) < (b) ? (a) : (b))",
          "3982: #define MAX(a,b) ((a) > (b) ? (a) : (b))",
          "3983: #define LIM(x,min,max) MAX(min,MIN(x,max))",
          "3984: #define CLIP(x) LIM(x,0,65535)",
          "3985:         int dmax = 0;",
          "3986:         if(C.cblack[4] && C.cblack[5])",
          "3987:           {",
          "3988:             for(i=0; i< size*4; i++)",
          "3989:               {",
          "3990:                 int val = imgdata.image[0][i];",
          "3991:                 val -= C.cblack[6 + i/4 / S.iwidth % C.cblack[4] * C.cblack[5] +",
          "3992:    i/4 % S.iwidth % C.cblack[5]];",
          "3993:                 val -= cblk[i & 3];",
          "3994:                 imgdata.image[0][i] = CLIP(val);",
          "3995:                 if(dmax < val) dmax = val;",
          "3996:               }",
          "3997:           }",
          "3998:         else",
          "3999:           {",
          "4000:             for(i=0; i< size*4; i++)",
          "4001:               {",
          "4002:                 int val = imgdata.image[0][i];",
          "4003:                 val -= cblk[i & 3];",
          "4004:                 imgdata.image[0][i] = CLIP(val);",
          "4005:                 if(dmax < val) dmax = val;",
          "4006:               }",
          "4007:           }",
          "4008:         C.data_maximum = dmax & 0xffff;",
          "4013:         C.maximum -= C.black;",
          "4014:         ZERO(C.cblack); // Yeah, we used cblack[6+] values too!",
          "4015:         C.black = 0;",
          "4017:       }",
          "4019:       {",
          "4022:         int idx;",
          "4023:         ushort *p = (ushort*)imgdata.image;",
          "4024:         int dmax = 0;",
          "4025:         for(idx=0;idx<S.iheight*S.iwidth*4;idx++)",
          "4026:           if(dmax < p[idx]) dmax = p[idx];",
          "4027:         C.data_maximum = dmax;",
          "4028:       }",
          "4031:   catch ( LibRaw_exceptions err) {",
          "",
          "[Added Lines]",
          "4131:   try",
          "4132:   {",
          "4133:     if (!is_phaseone_compressed() &&",
          "4134:         (C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3] || (C.cblack[4] && C.cblack[5])))",
          "4135:     {",
          "4136: #define BAYERC(row, col, c) imgdata.image[((row) >> IO.shrink) * S.iwidth + ((col) >> IO.shrink)][c]",
          "4137:       int cblk[4], i;",
          "4138:       for (i = 0; i < 4; i++)",
          "4139:         cblk[i] = C.cblack[i];",
          "4141:       int size = S.iheight * S.iwidth;",
          "4142: #define MIN(a, b) ((a) < (b) ? (a) : (b))",
          "4143: #define MAX(a, b) ((a) > (b) ? (a) : (b))",
          "4144: #define LIM(x, min, max) MAX(min, MIN(x, max))",
          "4145: #define CLIP(x) LIM(x, 0, 65535)",
          "4146:       int dmax = 0;",
          "4147:       if (C.cblack[4] && C.cblack[5])",
          "4149:         for (i = 0; i < size * 4; i++)",
          "4150:         {",
          "4151:           int val = imgdata.image[0][i];",
          "4152:           val -= C.cblack[6 + i / 4 / S.iwidth % C.cblack[4] * C.cblack[5] + i / 4 % S.iwidth % C.cblack[5]];",
          "4153:           val -= cblk[i & 3];",
          "4154:           imgdata.image[0][i] = CLIP(val);",
          "4155:           if (dmax < val)",
          "4156:             dmax = val;",
          "4157:         }",
          "4158:       }",
          "4159:       else",
          "4160:       {",
          "4161:         for (i = 0; i < size * 4; i++)",
          "4162:         {",
          "4163:           int val = imgdata.image[0][i];",
          "4164:           val -= cblk[i & 3];",
          "4165:           imgdata.image[0][i] = CLIP(val);",
          "4166:           if (dmax < val)",
          "4167:             dmax = val;",
          "4168:         }",
          "4169:       }",
          "4170:       C.data_maximum = dmax & 0xffff;",
          "4175:       C.maximum -= C.black;",
          "4176:       ZERO(C.cblack); // Yeah, we used cblack[6+] values too!",
          "4177:       C.black = 0;",
          "4179:     }",
          "4181:     {",
          "4184:       int idx;",
          "4185:       ushort *p = (ushort *)imgdata.image;",
          "4186:       int dmax = 0;",
          "4187:       for (idx = 0; idx < S.iheight * S.iwidth * 4; idx++)",
          "4188:         if (dmax < p[idx])",
          "4189:           dmax = p[idx];",
          "4190:       C.data_maximum = dmax;",
          "4191:     }",
          "4194:   catch (LibRaw_exceptions err)",
          "4195:   {",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "4039: void LibRaw::exp_bef(float shift, float smooth)",
          "4040: {",
          "4054:   else",
          "4055:     {",
          "4085:     }",
          "4088:     C.data_maximum = lut[C.data_maximum];",
          "4090:     C.maximum = lut[C.maximum];",
          "4092:   free(lut);",
          "4093: }",
          "4101: void LibRaw::convert_to_rgb_loop(float out_cam[3][4])",
          "4102: {",
          "4104:   float out[3];",
          "4105:   ushort *img;",
          "4110:         out[0] = out[1] = out[2] = 0;",
          "4112:           out[0] += out_cam[0][c] * img[c];",
          "4113:           out[1] += out_cam[1][c] * img[c];",
          "4114:           out[2] += out_cam[2][c] * img[c];",
          "4115:         }",
          "4117:       }",
          "4119:     }",
          "4121: }",
          "4123: void LibRaw::scale_colors_loop(float scale_mul[4])",
          "4124: {",
          "4128:   if (C.cblack[4] && C.cblack[5])",
          "4129:     {",
          "4140:     }",
          "4142:     {",
          "4151:     }",
          "4152:   else // BL is zero",
          "4153:     {",
          "4160:     }",
          "4161: }",
          "4163: void LibRaw::adjust_bl()",
          "4164: {",
          "4209:   int i = C.cblack[3];",
          "4210:   int c;",
          "4214:   C.black += i;",
          "4219:     {",
          "4233:     }",
          "4235: }",
          "4237: int LibRaw::dcraw_process(void)",
          "4238: {",
          "4251:   CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);",
          "4256:     int no_crop = 1;",
          "4258:     if (~O.cropbox[2] && ~O.cropbox[3])",
          "4261:     libraw_decoder_info_t di;",
          "4262:     get_decoder_info(&di);",
          "",
          "[Removed Lines]",
          "4042:   if(shift>8) shift = 8;",
          "4043:   if(shift<0.25) shift = 0.25;",
          "4044:   if(smooth < 0.0) smooth = 0.0;",
          "4045:   if(smooth > 1.0) smooth = 1.0;",
          "4047:   unsigned short *lut = (ushort*)malloc((TBLN+1)*sizeof(unsigned short));",
          "4049:   if(shift <=1.0)",
          "4050:     {",
          "4051:       for(int i=0;i<=TBLN;i++)",
          "4052:         lut[i] = (unsigned short)((float)i*shift);",
          "4053:     }",
          "4056:       float x1,x2,y1,y2;",
          "4058:       float cstops = log(shift)/log(2.0f);",
          "4059:       float room = cstops*2;",
          "4060:       float roomlin = powf(2.0f,room);",
          "4061:       x2 = (float)TBLN;",
          "4062:       x1 = (x2+1)/roomlin-1;",
          "4063:       y1 = x1*shift;",
          "4064:       y2 = x2*(1+(1-smooth)*(shift-1));",
          "4065:       float sq3x=powf(x1*x1*x2,1.0f/3.0f);",
          "4066:       float B = (y2-y1+shift*(3*x1-3.0f*sq3x)) / (x2+2.0f*x1-3.0f*sq3x);",
          "4067:       float A = (shift - B)*3.0f*powf(x1*x1,1.0f/3.0f);",
          "4068:       float CC = y2 - A*powf(x2,1.0f/3.0f)-B*x2;",
          "4069:       for(int i=0;i<=TBLN;i++)",
          "4070:         {",
          "4071:           float X = (float)i;",
          "4072:           float Y = A*powf(X,1.0f/3.0f)+B*X+CC;",
          "4073:           if(i<x1)",
          "4074:             lut[i] = (unsigned short)((float)i*shift);",
          "4075:           else",
          "4076:             lut[i] = Y<0?0:(Y>TBLN?TBLN:(unsigned short)(Y));",
          "4077:         }",
          "4078:     }",
          "4079:   for(int i=0; i< S.height*S.width; i++)",
          "4080:     {",
          "4081:       imgdata.image[i][0] = lut[imgdata.image[i][0]];",
          "4082:       imgdata.image[i][1] = lut[imgdata.image[i][1]];",
          "4083:       imgdata.image[i][2] = lut[imgdata.image[i][2]];",
          "4084:       imgdata.image[i][3] = lut[imgdata.image[i][3]];",
          "4087:   if(C.data_maximum <=TBLN)",
          "4089:   if(C.maximum <= TBLN)",
          "4095: #define MIN(a,b) ((a) < (b) ? (a) : (b))",
          "4096: #define MAX(a,b) ((a) > (b) ? (a) : (b))",
          "4097: #define LIM(x,min,max) MAX(min,MIN(x,max))",
          "4098: #define ULIM(x,y,z) ((y) < (z) ? LIM(x,y,z) : LIM(x,z,y))",
          "4099: #define CLIP(x) LIM(x,0,65535)",
          "4103:   int row,col,c;",
          "4106:   memset(libraw_internal_data.output_data.histogram,0,sizeof(int)*LIBRAW_HISTOGRAM_SIZE*4);",
          "4107:   for (img=imgdata.image[0], row=0; row < S.height; row++)",
          "4108:     for (col=0; col < S.width; col++, img+=4) {",
          "4109:       if (!libraw_internal_data.internal_output_params.raw_color) {",
          "4111:         for(c=0; c< imgdata.idata.colors; c++) {",
          "4116:         for(c=0;c<3;c++) img[c] = CLIP((int) out[c]);",
          "4118:       for(c=0; c< imgdata.idata.colors; c++) libraw_internal_data.output_data.histogram[c][img[c] >> 3]++;",
          "4125:   unsigned size = S.iheight*S.iwidth;",
          "4130:       int val;",
          "4131:       for (unsigned i=0; i < size*4; i++)",
          "4132:         {",
          "4133:           if (!(val = imgdata.image[0][i])) continue;",
          "4134:           val -= C.cblack[6 + i/4 / S.iwidth % C.cblack[4] * C.cblack[5] +",
          "4135:    i/4 % S.iwidth % C.cblack[5]];",
          "4136:           val -= C.cblack[i & 3];",
          "4137:           val *= scale_mul[i & 3];",
          "4138:           imgdata.image[0][i] = CLIP(val);",
          "4139:         }",
          "4141:   else if(C.cblack[0]||C.cblack[1]||C.cblack[2]||C.cblack[3])",
          "4143:       for (unsigned i=0; i < size*4; i++)",
          "4144:         {",
          "4145:           int val = imgdata.image[0][i];",
          "4146:           if (!val) continue;",
          "4147:           val -= C.cblack[i & 3];",
          "4148:           val *= scale_mul[i & 3];",
          "4149:           imgdata.image[0][i] = CLIP(val);",
          "4150:         }",
          "4154:       for (unsigned i=0; i < size*4; i++)",
          "4155:         {",
          "4156:           int val = imgdata.image[0][i];",
          "4157:           val *= scale_mul[i & 3];",
          "4158:           imgdata.image[0][i] = CLIP(val);",
          "4159:         }",
          "4165:   int clear_repeat=0;",
          "4166:    if (O.user_black >= 0)",
          "4167:      {",
          "4168:        C.black = O.user_black;",
          "4169:        clear_repeat = 1;",
          "4170:      }",
          "4171:    for(int i=0; i<4; i++)",
          "4172:      if(O.user_cblack[i]>-1000000)",
          "4173:        {",
          "4174:          C.cblack[i] = O.user_cblack[i];",
          "4175:          clear_repeat  = 1;",
          "4176:        }",
          "4178:    if(clear_repeat)",
          "4179:      C.cblack[4]=C.cblack[5]=0;",
          "4182:    if (imgdata.idata.filters > 1000 && (C.cblack[4]+1)/2 == 1 && (C.cblack[5]+1)/2 == 1)",
          "4183:    {",
          "4184:     int clrs[4];",
          "4185:     int lastg = -1, gcnt = 0;",
          "4186:     for(int c = 0; c < 4; c++)",
          "4187:     {",
          "4188:    clrs[c] = FC(c/2,c%2);",
          "4189:    if(clrs[c]==1)",
          "4190:    {",
          "4191:     gcnt++;",
          "4192:     lastg = c;",
          "4193:    }",
          "4194:     }",
          "4195:     if(gcnt>1 && lastg>=0)",
          "4196:      clrs[lastg] = 3;",
          "4197:     for(int c=0; c<4; c++)",
          "4198:      C.cblack[clrs[c]] += C.cblack[6 + c/2 % C.cblack[4] * C.cblack[5] + c%2 % C.cblack[5]];",
          "4199:     C.cblack[4]=C.cblack[5]=0;",
          "4201:    }",
          "4202:    else if(imgdata.idata.filters <= 1000 && C.cblack[4]==1 && C.cblack[5]==1) // Fuji RAF dng",
          "4203:    {",
          "4204:     for(int c=0; c<4; c++)",
          "4205:      C.cblack[c] += C.cblack[6];",
          "4206:     C.cblack[4]=C.cblack[5]=0;",
          "4207:    }",
          "4211:   for(c=0;c<3;c++) if (i > C.cblack[c]) i = C.cblack[c];",
          "4213:   for(c=0;c<4;c++) C.cblack[c] -= i; // remove common part",
          "4218:   if(C.cblack[4] && C.cblack[5])",
          "4220:       i = C.cblack[6];",
          "4221:       for(c=1; c<C.cblack[4]*C.cblack[5]; c++)",
          "4222:         if(i>C.cblack[6+c]) i = C.cblack[6+c];",
          "4224:       int nonz=0;",
          "4225:       for(c=0; c<C.cblack[4]*C.cblack[5]; c++)",
          "4226:         {",
          "4227:           C.cblack[6+c]-=i;",
          "4228:           if(C.cblack[6+c])nonz++;",
          "4229:         }",
          "4230:       C.black +=i;",
          "4231:       if(!nonz)",
          "4232:         C.cblack[4] = C.cblack[5] = 0;",
          "4234:   for(c=0;c<4;c++) C.cblack[c] += C.black;",
          "4239:   int quality,i;",
          "4241:   int iterations=-1, dcb_enhance=1, noiserd=0;",
          "4242:   int eeci_refine_fl=0, es_med_passes_fl=0;",
          "4243:   float cared=0,cablue=0;",
          "4244:   float linenoise=0;",
          "4245:   float lclean=0,cclean=0;",
          "4246:   float thresh=0;",
          "4247:   float preser=0;",
          "4248:   float expos=1.0;",
          "4254:   try {",
          "4259:       no_crop=0;",
          "",
          "[Added Lines]",
          "4205:   if (shift > 8)",
          "4206:     shift = 8;",
          "4207:   if (shift < 0.25)",
          "4208:     shift = 0.25;",
          "4209:   if (smooth < 0.0)",
          "4210:     smooth = 0.0;",
          "4211:   if (smooth > 1.0)",
          "4212:     smooth = 1.0;",
          "4214:   unsigned short *lut = (ushort *)malloc((TBLN + 1) * sizeof(unsigned short));",
          "4216:   if (shift <= 1.0)",
          "4217:   {",
          "4218:     for (int i = 0; i <= TBLN; i++)",
          "4219:       lut[i] = (unsigned short)((float)i * shift);",
          "4220:   }",
          "4222:   {",
          "4223:     float x1, x2, y1, y2;",
          "4225:     float cstops = log(shift) / log(2.0f);",
          "4226:     float room = cstops * 2;",
          "4227:     float roomlin = powf(2.0f, room);",
          "4228:     x2 = (float)TBLN;",
          "4229:     x1 = (x2 + 1) / roomlin - 1;",
          "4230:     y1 = x1 * shift;",
          "4231:     y2 = x2 * (1 + (1 - smooth) * (shift - 1));",
          "4232:     float sq3x = powf(x1 * x1 * x2, 1.0f / 3.0f);",
          "4233:     float B = (y2 - y1 + shift * (3 * x1 - 3.0f * sq3x)) / (x2 + 2.0f * x1 - 3.0f * sq3x);",
          "4234:     float A = (shift - B) * 3.0f * powf(x1 * x1, 1.0f / 3.0f);",
          "4235:     float CC = y2 - A * powf(x2, 1.0f / 3.0f) - B * x2;",
          "4236:     for (int i = 0; i <= TBLN; i++)",
          "4238:       float X = (float)i;",
          "4239:       float Y = A * powf(X, 1.0f / 3.0f) + B * X + CC;",
          "4240:       if (i < x1)",
          "4241:         lut[i] = (unsigned short)((float)i * shift);",
          "4242:       else",
          "4243:         lut[i] = Y < 0 ? 0 : (Y > TBLN ? TBLN : (unsigned short)(Y));",
          "4245:   }",
          "4246:   for (int i = 0; i < S.height * S.width; i++)",
          "4247:   {",
          "4248:     imgdata.image[i][0] = lut[imgdata.image[i][0]];",
          "4249:     imgdata.image[i][1] = lut[imgdata.image[i][1]];",
          "4250:     imgdata.image[i][2] = lut[imgdata.image[i][2]];",
          "4251:     imgdata.image[i][3] = lut[imgdata.image[i][3]];",
          "4252:   }",
          "4254:   if (C.data_maximum <= TBLN)",
          "4256:   if (C.maximum <= TBLN)",
          "4262: #define MIN(a, b) ((a) < (b) ? (a) : (b))",
          "4263: #define MAX(a, b) ((a) > (b) ? (a) : (b))",
          "4264: #define LIM(x, min, max) MAX(min, MIN(x, max))",
          "4265: #define ULIM(x, y, z) ((y) < (z) ? LIM(x, y, z) : LIM(x, z, y))",
          "4266: #define CLIP(x) LIM(x, 0, 65535)",
          "4270:   int row, col, c;",
          "4273:   memset(libraw_internal_data.output_data.histogram, 0, sizeof(int) * LIBRAW_HISTOGRAM_SIZE * 4);",
          "4274:   for (img = imgdata.image[0], row = 0; row < S.height; row++)",
          "4275:     for (col = 0; col < S.width; col++, img += 4)",
          "4276:     {",
          "4277:       if (!libraw_internal_data.internal_output_params.raw_color)",
          "4278:       {",
          "4280:         for (c = 0; c < imgdata.idata.colors; c++)",
          "4281:         {",
          "4286:         for (c = 0; c < 3; c++)",
          "4287:           img[c] = CLIP((int)out[c]);",
          "4289:       for (c = 0; c < imgdata.idata.colors; c++)",
          "4290:         libraw_internal_data.output_data.histogram[c][img[c] >> 3]++;",
          "4296:   unsigned size = S.iheight * S.iwidth;",
          "4299:   {",
          "4300:     int val;",
          "4301:     for (unsigned i = 0; i < size * 4; i++)",
          "4303:       if (!(val = imgdata.image[0][i]))",
          "4304:         continue;",
          "4305:       val -= C.cblack[6 + i / 4 / S.iwidth % C.cblack[4] * C.cblack[5] + i / 4 % S.iwidth % C.cblack[5]];",
          "4306:       val -= C.cblack[i & 3];",
          "4307:       val *= scale_mul[i & 3];",
          "4308:       imgdata.image[0][i] = CLIP(val);",
          "4310:   }",
          "4311:   else if (C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3])",
          "4312:   {",
          "4313:     for (unsigned i = 0; i < size * 4; i++)",
          "4315:       int val = imgdata.image[0][i];",
          "4316:       if (!val)",
          "4317:         continue;",
          "4318:       val -= C.cblack[i & 3];",
          "4319:       val *= scale_mul[i & 3];",
          "4320:       imgdata.image[0][i] = CLIP(val);",
          "4322:   }",
          "4324:   {",
          "4325:     for (unsigned i = 0; i < size * 4; i++)",
          "4327:       int val = imgdata.image[0][i];",
          "4328:       val *= scale_mul[i & 3];",
          "4329:       imgdata.image[0][i] = CLIP(val);",
          "4331:   }",
          "4336:   int clear_repeat = 0;",
          "4337:   if (O.user_black >= 0)",
          "4338:   {",
          "4339:     C.black = O.user_black;",
          "4340:     clear_repeat = 1;",
          "4341:   }",
          "4342:   for (int i = 0; i < 4; i++)",
          "4343:     if (O.user_cblack[i] > -1000000)",
          "4344:     {",
          "4345:       C.cblack[i] = O.user_cblack[i];",
          "4346:       clear_repeat = 1;",
          "4347:     }",
          "4349:   if (clear_repeat)",
          "4350:     C.cblack[4] = C.cblack[5] = 0;",
          "4353:   if (imgdata.idata.filters > 1000 && (C.cblack[4] + 1) / 2 == 1 && (C.cblack[5] + 1) / 2 == 1)",
          "4354:   {",
          "4355:     int clrs[4];",
          "4356:     int lastg = -1, gcnt = 0;",
          "4357:     for (int c = 0; c < 4; c++)",
          "4358:     {",
          "4359:       clrs[c] = FC(c / 2, c % 2);",
          "4360:       if (clrs[c] == 1)",
          "4361:       {",
          "4362:         gcnt++;",
          "4363:         lastg = c;",
          "4364:       }",
          "4365:     }",
          "4366:     if (gcnt > 1 && lastg >= 0)",
          "4367:       clrs[lastg] = 3;",
          "4368:     for (int c = 0; c < 4; c++)",
          "4369:       C.cblack[clrs[c]] += C.cblack[6 + c / 2 % C.cblack[4] * C.cblack[5] + c % 2 % C.cblack[5]];",
          "4370:     C.cblack[4] = C.cblack[5] = 0;",
          "4372:   }",
          "4373:   else if (imgdata.idata.filters <= 1000 && C.cblack[4] == 1 && C.cblack[5] == 1) // Fuji RAF dng",
          "4374:   {",
          "4375:     for (int c = 0; c < 4; c++)",
          "4376:       C.cblack[c] += C.cblack[6];",
          "4377:     C.cblack[4] = C.cblack[5] = 0;",
          "4378:   }",
          "4382:   for (c = 0; c < 3; c++)",
          "4383:     if (i > C.cblack[c])",
          "4384:       i = C.cblack[c];",
          "4386:   for (c = 0; c < 4; c++)",
          "4387:     C.cblack[c] -= i; // remove common part",
          "4392:   if (C.cblack[4] && C.cblack[5])",
          "4393:   {",
          "4394:     i = C.cblack[6];",
          "4395:     for (c = 1; c < C.cblack[4] * C.cblack[5]; c++)",
          "4396:       if (i > C.cblack[6 + c])",
          "4397:         i = C.cblack[6 + c];",
          "4399:     int nonz = 0;",
          "4400:     for (c = 0; c < C.cblack[4] * C.cblack[5]; c++)",
          "4402:       C.cblack[6 + c] -= i;",
          "4403:       if (C.cblack[6 + c])",
          "4404:         nonz++;",
          "4406:     C.black += i;",
          "4407:     if (!nonz)",
          "4408:       C.cblack[4] = C.cblack[5] = 0;",
          "4409:   }",
          "4410:   for (c = 0; c < 4; c++)",
          "4411:     C.cblack[c] += C.black;",
          "4416:   int quality, i;",
          "4418:   int iterations = -1, dcb_enhance = 1, noiserd = 0;",
          "4419:   int eeci_refine_fl = 0, es_med_passes_fl = 0;",
          "4420:   float cared = 0, cablue = 0;",
          "4421:   float linenoise = 0;",
          "4422:   float lclean = 0, cclean = 0;",
          "4423:   float thresh = 0;",
          "4424:   float preser = 0;",
          "4425:   float expos = 1.0;",
          "4430:   try",
          "4431:   {",
          "4436:       no_crop = 0;",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "4271:     int save_4color = O.four_color_rgb;",
          "4273:     if (IO.zero_is_bad)",
          "4285:     if (O.dark_frame && no_crop)",
          "4291:     if (O.wf_debanding)",
          "4296:     quality = 2 + !IO.fuji_width;",
          "4311:     if (P1.is_foveon)",
          "4312:       {",
          "4319: #ifdef LIBRAW_DEMOSAIC_PACK_GPL2",
          "4331:       }",
          "4334:       {",
          "4336:       }",
          "4338:     if (",
          "4339: #ifdef LIBRAW_DEMOSAIC_PACK_GPL2",
          "4340:         (!P1.is_foveon || (O.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F)) &&",
          "4341: #endif",
          "4342:         !O.no_auto_scale)",
          "4348:     pre_interpolate();",
          "4350:     SET_PROC_FLAG(LIBRAW_PROGRESS_PRE_INTERPOLATE);",
          "4367:       {",
          "4418:       }",
          "4420:       {",
          "4424:       }",
          "4427:       {",
          "4442:       }",
          "4444:     if (O.highlight == 2)",
          "4450:     if (O.highlight > 2)",
          "4456:     if (O.use_fuji_rotate)",
          "4467: #ifndef NO_LCMS",
          "4473: #endif",
          "4475:     convert_to_rgb();",
          "4476:     SET_PROC_FLAG(LIBRAW_PROGRESS_CONVERT_RGB);",
          "4478:     if (O.use_fuji_rotate)",
          "4483:     O.four_color_rgb = save_4color; // also, restore",
          "4485:     return 0;",
          "4486:   }",
          "4488:     EXCEPTION_HANDLER(err);",
          "4489:   }",
          "4490: }",
          "5263: #ifndef NO_JASPER",
          "5265: #endif",
          "5435: {",
          "5483: }",
          "5485: #undef ID",
          "5488: #include \"../internal/libraw_x3f.cpp\"",
          "5495: static char *utf2char(utf16_t *str, char *buffer)",
          "5496: {",
          "5497:   char *b = buffer;",
          "5500:     char *chr = (char *)str;",
          "5502:     str++;",
          "",
          "[Removed Lines]",
          "4274:       {",
          "4275:         remove_zeroes();",
          "4276:         SET_PROC_FLAG(LIBRAW_PROGRESS_REMOVE_ZEROES);",
          "4277:       }",
          "4279:     if(O.bad_pixels && no_crop)",
          "4280:       {",
          "4281:         bad_pixels(O.bad_pixels);",
          "4282:         SET_PROC_FLAG(LIBRAW_PROGRESS_BAD_PIXELS);",
          "4283:       }",
          "4286:       {",
          "4287:         subtract (O.dark_frame);",
          "4288:         SET_PROC_FLAG(LIBRAW_PROGRESS_DARK_FRAME);",
          "4289:       }",
          "4292:       {",
          "4293:         wf_remove_banding();",
          "4294:       }",
          "4298:     if (O.user_qual >= 0) quality = O.user_qual;",
          "4300:     if(!subtract_inline || !C.data_maximum)",
          "4301:       {",
          "4302:         adjust_bl();",
          "4303:         subtract_black_internal();",
          "4304:       }",
          "4306:  if(!(di.decoder_flags & LIBRAW_DECODER_FIXEDMAXC))",
          "4307:   adjust_maximum();",
          "4309:     if (O.user_sat > 0) C.maximum = O.user_sat;",
          "4313:         if(load_raw == &LibRaw::x3f_load_raw)",
          "4314:           {",
          "4316:             for (int i=0; i < S.height*S.width*4; i++)",
          "4317:               if ((short) imgdata.image[0][i] < 0) imgdata.image[0][i] = 0;",
          "4318:           }",
          "4320:         else if(load_raw == &LibRaw::foveon_dp_load_raw)",
          "4321:           {",
          "4322:             for (int i=0; i < S.height*S.width*4; i++)",
          "4323:               if ((short) imgdata.image[0][i] < 0) imgdata.image[0][i] = 0;",
          "4324:           }",
          "4325:         else",
          "4326:           {",
          "4327:             foveon_interpolate();",
          "4328:           }",
          "4329: #endif",
          "4330:         SET_PROC_FLAG(LIBRAW_PROGRESS_FOVEON_INTERPOLATE);",
          "4333:     if (O.green_matching && !O.half_size)",
          "4335:         green_matching();",
          "4343:       {",
          "4344:         scale_colors();",
          "4345:         SET_PROC_FLAG(LIBRAW_PROGRESS_SCALE_COLORS);",
          "4346:       }",
          "4352:     if (O.dcb_iterations >= 0) iterations = O.dcb_iterations;",
          "4353:     if (O.dcb_enhance_fl >=0 ) dcb_enhance = O.dcb_enhance_fl;",
          "4354:     if (O.fbdd_noiserd >=0 ) noiserd = O.fbdd_noiserd;",
          "4355:     if (O.eeci_refine >=0 ) eeci_refine_fl = O.eeci_refine;",
          "4356:     if (O.es_med_passes >0 ) es_med_passes_fl = O.es_med_passes;",
          "4360:     if (!O.half_size && O.cfa_green >0) {thresh=O.green_thresh ;green_equilibrate(thresh);}",
          "4361:     if (O.exp_correc >0) {expos=O.exp_shift ; preser=O.exp_preser; exp_bef(expos,preser);}",
          "4362:     if (O.ca_correc >0 ) {cablue=O.cablue; cared=O.cared; CA_correct_RT(cablue, cared);}",
          "4363:     if (O.cfaline >0 ) {linenoise=O.linenoise; cfa_linedn(linenoise);}",
          "4364:     if (O.cfa_clean >0 ) {lclean=O.lclean; cclean=O.cclean; cfa_impulse_gauss(lclean,cclean);}",
          "4366:     if (P1.filters  && !O.no_interpolation)",
          "4368:         if (noiserd>0 && P1.colors==3 && P1.filters) fbdd(noiserd);",
          "4370:   if(P1.filters>1000 && interpolate_bayer)",
          "4371:    (this->*interpolate_bayer)();",
          "4372:   else if(P1.filters==9 && interpolate_xtrans)",
          "4373:    (this->*interpolate_xtrans)();",
          "4374:         else if (quality == 0)",
          "4375:           lin_interpolate();",
          "4376:         else if (quality == 1 || P1.colors > 3)",
          "4377:           vng_interpolate();",
          "4378:         else if (quality == 2 && P1.filters > 1000)",
          "4379:           ppg_interpolate();",
          "4380:         else if (P1.filters == LIBRAW_XTRANS)",
          "4381:           {",
          "4383:             xtrans_interpolate(quality>2?3:1);",
          "4384:           }",
          "4385:         else if (quality == 3)",
          "4386:           ahd_interpolate(); // really don't need it here due to fallback op",
          "4387:         else if (quality == 4)",
          "4388:           dcb(iterations, dcb_enhance);",
          "4390:         else if (quality == 5)",
          "4391:           ahd_interpolate_mod();",
          "4392:         else if (quality == 6)",
          "4393:           afd_interpolate_pl(2,1);",
          "4394:         else if (quality == 7)",
          "4395:           vcd_interpolate(0);",
          "4396:         else if (quality == 8)",
          "4397:           vcd_interpolate(12);",
          "4398:         else if (quality == 9)",
          "4399:           lmmse_interpolate(1);",
          "4402:         else if (quality == 10)",
          "4403:           amaze_demosaic_RT();",
          "4405:         else if (quality == 11)",
          "4406:           dht_interpolate();",
          "4407:         else if (quality == 12)",
          "4408:           aahd_interpolate();",
          "4410:         else",
          "4411:           {",
          "4412:             ahd_interpolate();",
          "4413:             imgdata.process_warnings |= LIBRAW_WARN_FALLBACK_TO_AHD;",
          "4414:           }",
          "4417:         SET_PROC_FLAG(LIBRAW_PROGRESS_INTERPOLATE);",
          "4419:     if (IO.mix_green)",
          "4421:         for (P1.colors=3, i=0; i < S.height * S.width; i++)",
          "4422:           imgdata.image[i][1] = (imgdata.image[i][1] + imgdata.image[i][3]) >> 1;",
          "4423:         SET_PROC_FLAG(LIBRAW_PROGRESS_MIX_GREEN);",
          "4426:     if(!P1.is_foveon)",
          "4428:         if (P1.colors == 3)",
          "4429:           {",
          "4431:             if (quality == 8)",
          "4432:               {",
          "4433:                 if (eeci_refine_fl == 1) refinement();",
          "4434:                 if (O.med_passes > 0)    median_filter_new();",
          "4435:                 if (es_med_passes_fl > 0) es_median_filter();",
          "4436:               }",
          "4437:             else {",
          "4438:               median_filter();",
          "4439:             }",
          "4440:             SET_PROC_FLAG(LIBRAW_PROGRESS_MEDIAN_FILTER);",
          "4441:           }",
          "4445:       {",
          "4446:         blend_highlights();",
          "4447:         SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);",
          "4448:       }",
          "4451:       {",
          "4452:         recover_highlights();",
          "4453:         SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);",
          "4454:       }",
          "4457:       {",
          "4458:         fuji_rotate();",
          "4459:         SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE);",
          "4460:       }",
          "4462:     if(!libraw_internal_data.output_data.histogram)",
          "4463:       {",
          "4464:         libraw_internal_data.output_data.histogram = (int (*)[LIBRAW_HISTOGRAM_SIZE]) malloc(sizeof(*libraw_internal_data.output_data.histogram)*4);",
          "4465:         merror(libraw_internal_data.output_data.histogram,\"LibRaw::dcraw_process()\");",
          "4466:       }",
          "4468:     if(O.camera_profile)",
          "4469:       {",
          "4470:         apply_profile(O.camera_profile,O.output_profile);",
          "4471:         SET_PROC_FLAG(LIBRAW_PROGRESS_APPLY_PROFILE);",
          "4472:       }",
          "4479:       {",
          "4480:         stretch();",
          "4481:         SET_PROC_FLAG(LIBRAW_PROGRESS_STRETCH);",
          "4482:       }",
          "4487:   catch ( LibRaw_exceptions err) {",
          "4493: static const char  *static_camera_list[] =",
          "4494: {",
          "4495: \"Adobe Digital Negative (DNG)\",",
          "4496: \"AgfaPhoto DC-833m\",",
          "4497: \"Alcatel 5035D\",",
          "4498: \"Apple iPad Pro\",",
          "4499: \"Apple iPhone SE\",",
          "4500: \"Apple iPhone 6s\",",
          "4501: \"Apple iPhone 6 plus\",",
          "4502: \"Apple iPhone 7\",",
          "4503: \"Apple iPhone 7 plus\",",
          "4504: \"Apple QuickTake 100\",",
          "4505: \"Apple QuickTake 150\",",
          "4506: \"Apple QuickTake 200\",",
          "4507: \"ARRIRAW format\",",
          "4508: \"AVT F-080C\",",
          "4509: \"AVT F-145C\",",
          "4510: \"AVT F-201C\",",
          "4511: \"AVT F-510C\",",
          "4512: \"AVT F-810C\",",
          "4513: \"Baumer TXG14\",",
          "4514: \"BlackMagic Cinema Camera\",",
          "4515: \"BlackMagic Micro Cinema Camera\",",
          "4516: \"BlackMagic Pocket Cinema Camera\",",
          "4517: \"BlackMagic Production Camera 4k\",",
          "4518: \"BlackMagic URSA\",",
          "4519: \"BlackMagic URSA Mini\",",
          "4520: \"Canon PowerShot 600\",",
          "4521: \"Canon PowerShot A5\",",
          "4522: \"Canon PowerShot A5 Zoom\",",
          "4523: \"Canon PowerShot A50\",",
          "4524: \"Canon PowerShot A460 (CHDK hack)\",",
          "4525: \"Canon PowerShot A470 (CHDK hack)\",",
          "4526: \"Canon PowerShot A530 (CHDK hack)\",",
          "4527: \"Canon PowerShot A550 (CHDK hack)\",",
          "4528: \"Canon PowerShot A570 (CHDK hack)\",",
          "4529: \"Canon PowerShot A590 (CHDK hack)\",",
          "4530: \"Canon PowerShot A610 (CHDK hack)\",",
          "4531: \"Canon PowerShot A620 (CHDK hack)\",",
          "4532: \"Canon PowerShot A630 (CHDK hack)\",",
          "4533: \"Canon PowerShot A640 (CHDK hack)\",",
          "4534: \"Canon PowerShot A650 (CHDK hack)\",",
          "4535: \"Canon PowerShot A710 IS (CHDK hack)\",",
          "4536: \"Canon PowerShot A720 IS (CHDK hack)\",",
          "4537: \"Canon PowerShot A3300 IS (CHDK hack)\",",
          "4538: \"Canon PowerShot Pro70\",",
          "4539: \"Canon PowerShot Pro90 IS\",",
          "4540: \"Canon PowerShot Pro1\",",
          "4541: \"Canon PowerShot G1\",",
          "4542: \"Canon PowerShot G1 X\",",
          "4543: \"Canon PowerShot G1 X Mark II\",",
          "4544: \"Canon PowerShot G2\",",
          "4545: \"Canon PowerShot G3\",",
          "4546: \"Canon PowerShot G3 X\",",
          "4547: \"Canon PowerShot G5\",",
          "4548: \"Canon PowerShot G5 X\",",
          "4549: \"Canon PowerShot G6\",",
          "4550: \"Canon PowerShot G7 (CHDK hack)\",",
          "4551: \"Canon PowerShot G7 X\",",
          "4552: \"Canon PowerShot G7 X Mark II\",",
          "4553: \"Canon PowerShot G9\",",
          "4554: \"Canon PowerShot G9 X\",",
          "4555: \"Canon PowerShot G10\",",
          "4556: \"Canon PowerShot G11\",",
          "4557: \"Canon PowerShot G12\",",
          "4558: \"Canon PowerShot G15\",",
          "4559: \"Canon PowerShot G16\",",
          "4560: \"Canon PowerShot S2 IS (CHDK hack)\",",
          "4561: \"Canon PowerShot S3 IS (CHDK hack)\",",
          "4562: \"Canon PowerShot S5 IS (CHDK hack)\",",
          "4563: \"Canon PowerShot SD300 (CHDK hack)\",",
          "4564: \"Canon PowerShot SD950 (CHDK hack)\",",
          "4565: \"Canon PowerShot S30\",",
          "4566: \"Canon PowerShot S40\",",
          "4567: \"Canon PowerShot S45\",",
          "4568: \"Canon PowerShot S50\",",
          "4569: \"Canon PowerShot S60\",",
          "4570: \"Canon PowerShot S70\",",
          "4571: \"Canon PowerShot S90\",",
          "4572: \"Canon PowerShot S95\",",
          "4573: \"Canon PowerShot S100\",",
          "4574: \"Canon PowerShot S110\",",
          "4575: \"Canon PowerShot S120\",",
          "4576: \"Canon PowerShot SX1 IS\",",
          "4577: \"Canon PowerShot SX50 HS\",",
          "4578: \"Canon PowerShot SX60 HS\",",
          "4579: \"Canon PowerShot SX110 IS (CHDK hack)\",",
          "4580: \"Canon PowerShot SX120 IS (CHDK hack)\",",
          "4581: \"Canon PowerShot SX220 HS (CHDK hack)\",",
          "4582: \"Canon PowerShot SX20 IS (CHDK hack)\",",
          "4583: \"Canon PowerShot SX30 IS (CHDK hack)\",",
          "4584: \"Canon PowerShot IXUS 160 (CHDK hack)\",",
          "4585: \"Canon EOS D30\",",
          "4586: \"Canon EOS D60\",",
          "4587: \"Canon EOS 5D\",",
          "4588: \"Canon EOS 5DS\",",
          "4589: \"Canon EOS 5DS R\",",
          "4590: \"Canon EOS 5D Mark II\",",
          "4591: \"Canon EOS 5D Mark III\",",
          "4592: \"Canon EOS 5D Mark IV\",",
          "4593: \"Canon EOS 6D\",",
          "4594: \"Canon EOS 7D\",",
          "4595: \"Canon EOS 7D Mark II\",",
          "4596: \"Canon EOS 10D\",",
          "4597: \"Canon EOS 20D\",",
          "4598: \"Canon EOS 20Da\",",
          "4599: \"Canon EOS 30D\",",
          "4600: \"Canon EOS 40D\",",
          "4601: \"Canon EOS 50D\",",
          "4602: \"Canon EOS 60D\",",
          "4603: \"Canon EOS 60Da\",",
          "4604: \"Canon EOS 70D\",",
          "4605: \"Canon EOS 80D\",",
          "4606: \"Canon EOS 300D / Digital Rebel / Kiss Digital\",",
          "4607: \"Canon EOS 350D / Digital Rebel XT / Kiss Digital N\",",
          "4608: \"Canon EOS 400D / Digital Rebel XTi / Kiss Digital X\",",
          "4609: \"Canon EOS 450D / Digital Rebel XSi / Kiss Digital X2\",",
          "4610: \"Canon EOS 500D / Digital Rebel T1i / Kiss Digital X3\",",
          "4611: \"Canon EOS 550D / Digital Rebel T2i / Kiss Digital X4\",",
          "4612: \"Canon EOS 600D / Digital Rebel T3i / Kiss Digital X5\",",
          "4613: \"Canon EOS 650D / Digital Rebel T4i / Kiss Digital X6i\",",
          "4614: \"Canon EOS 700D / Digital Rebel T5i\",",
          "4615: \"Canon EOS 750D / Digital Rebel T6i\",",
          "4616: \"Canon EOS 760D / Digital Rebel T6S\",",
          "4617: \"Canon EOS 100D / Digital Rebel SL1\",",
          "4618: \"Canon EOS 1000D / Digital Rebel XS / Kiss Digital F\",",
          "4619: \"Canon EOS 1100D / Digital Rebel T3 / Kiss Digital X50\",",
          "4620: \"Canon EOS 1200D\",",
          "4621: \"Canon EOS 1300D\",",
          "4622: \"Canon EOS C500\",",
          "4623: \"Canon EOS D2000C\",",
          "4624: \"Canon EOS M\",",
          "4625: \"Canon EOS M2\",",
          "4626: \"Canon EOS M3\",",
          "4627: \"Canon EOS M5\",",
          "4628: \"Canon EOS M10\",",
          "4629: \"Canon EOS-1D\",",
          "4630: \"Canon EOS-1DS\",",
          "4631: \"Canon EOS-1D C\",",
          "4632: \"Canon EOS-1D X\",",
          "4633: \"Canon EOS-1D Mark II\",",
          "4634: \"Canon EOS-1D Mark II N\",",
          "4635: \"Canon EOS-1D Mark III\",",
          "4636: \"Canon EOS-1D Mark IV\",",
          "4637: \"Canon EOS-1Ds Mark II\",",
          "4638: \"Canon EOS-1Ds Mark III\",",
          "4639: \"Canon EOS-1D X Mark II\",",
          "4640: \"Casio QV-2000UX\",",
          "4641: \"Casio QV-3000EX\",",
          "4642: \"Casio QV-3500EX\",",
          "4643: \"Casio QV-4000\",",
          "4644: \"Casio QV-5700\",",
          "4645: \"Casio QV-R41\",",
          "4646: \"Casio QV-R51\",",
          "4647: \"Casio QV-R61\",",
          "4648: \"Casio EX-F1\",",
          "4649: \"Casio EX-FC300S\",",
          "4650: \"Casio EX-FC400S\",",
          "4651: \"Casio EX-FH20\",",
          "4652: \"Casio EX-FH25\",",
          "4653: \"Casio EX-FH100\",",
          "4654: \"Casio EX-S20\",",
          "4655: \"Casio EX-S100\",",
          "4656: \"Casio EX-Z4\",",
          "4657: \"Casio EX-Z50\",",
          "4658: \"Casio EX-Z500\",",
          "4659: \"Casio EX-Z55\",",
          "4660: \"Casio EX-Z60\",",
          "4661: \"Casio EX-Z75\",",
          "4662: \"Casio EX-Z750\",",
          "4663: \"Casio EX-Z8\",",
          "4664: \"Casio EX-Z850\",",
          "4665: \"Casio EX-Z1050\",",
          "4666: \"Casio EX-ZR100\",",
          "4667: \"Casio EX-Z1080\",",
          "4668: \"Casio EX-ZR700\",",
          "4669: \"Casio EX-ZR710\",",
          "4670: \"Casio EX-ZR750\",",
          "4671: \"Casio EX-ZR800\",",
          "4672: \"Casio EX-ZR850\",",
          "4673: \"Casio EX-ZR1000\",",
          "4674: \"Casio EX-ZR1100\",",
          "4675: \"Casio EX-ZR1200\",",
          "4676: \"Casio EX-ZR1300\",",
          "4677: \"Casio EX-ZR1500\",",
          "4678: \"Casio EX-ZR3000\",",
          "4679: \"Casio EX-ZR4000/5000\",",
          "4680: \"Casio EX-100\",",
          "4681: \"Casio EX-100F\",",
          "4682: \"Casio EX-10\",",
          "4683: \"Casio Exlim Pro 505\",",
          "4684: \"Casio Exlim Pro 600\",",
          "4685: \"Casio Exlim Pro 700\",",
          "4686: \"Contax N Digital\",",
          "4687: \"Creative PC-CAM 600\",",
          "4688: \"Digital Bolex D16\",",
          "4689: \"Digital Bolex D16M\",",
          "4690: \"DJI 4384x3288\",",
          "4691: \"DXO One\",",
          "4692: \"Epson R-D1\",",
          "4693: \"Epson R-D1s\",",
          "4694: \"Epson R-D1x\",",
          "4695: \"Foculus 531C\",",
          "4696: \"FujiFilm E505\",",
          "4697: \"FujiFilm E550\",",
          "4698: \"FujiFilm E900\",",
          "4699: \"FujiFilm F700\",",
          "4700: \"FujiFilm F710\",",
          "4701: \"FujiFilm F800\",",
          "4702: \"FujiFilm F810\",",
          "4703: \"FujiFilm S2Pro\",",
          "4704: \"FujiFilm S3Pro\",",
          "4705: \"FujiFilm S5Pro\",",
          "4706: \"FujiFilm S20Pro\",",
          "4707: \"FujiFilm S1\",",
          "4708: \"FujiFilm S100FS\",",
          "4709: \"FujiFilm S5000\",",
          "4710: \"FujiFilm S5100/S5500\",",
          "4711: \"FujiFilm S5200/S5600\",",
          "4712: \"FujiFilm S6000fd\",",
          "4713: \"FujiFilm S7000\",",
          "4714: \"FujiFilm S9000/S9500\",",
          "4715: \"FujiFilm S9100/S9600\",",
          "4716: \"FujiFilm S200EXR\",",
          "4717: \"FujiFilm S205EXR\",",
          "4718: \"FujiFilm SL1000\",",
          "4719: \"FujiFilm HS10/HS11\",",
          "4720: \"FujiFilm HS20EXR\",",
          "4721: \"FujiFilm HS22EXR\",",
          "4722: \"FujiFilm HS30EXR\",",
          "4723: \"FujiFilm HS33EXR\",",
          "4724: \"FujiFilm HS35EXR\",",
          "4725: \"FujiFilm HS50EXR\",",
          "4726: \"FujiFilm F505EXR\",",
          "4727: \"FujiFilm F550EXR\",",
          "4728: \"FujiFilm F600EXR\",",
          "4729: \"FujiFilm F605EXR\",",
          "4730: \"FujiFilm F770EXR\",",
          "4731: \"FujiFilm F775EXR\",",
          "4732: \"FujiFilm F800EXR\",",
          "4733: \"FujiFilm F900EXR\",",
          "4734: \"FujiFilm X-Pro1\",",
          "4735: \"FujiFilm X-Pro2\",",
          "4736: \"FujiFilm X-S1\",",
          "4737: \"FujiFilm XQ1\",",
          "4738: \"FujiFilm XQ2\",",
          "4739: \"FujiFilm X100\",",
          "4740: \"FujiFilm X100S\",",
          "4741: \"FujiFilm X100T\",",
          "4742: \"FujiFilm X10\",",
          "4743: \"FujiFilm X20\",",
          "4744: \"FujiFilm X30\",",
          "4745: \"FujiFilm X70\",",
          "4746: \"FujiFilm X-A1\",",
          "4747: \"FujiFilm X-A2\",",
          "4748: \"FujiFilm X-E1\",",
          "4749: \"FujiFilm X-E2\",",
          "4750: \"FujiFilm X-E2S\",",
          "4751: \"FujiFilm X-M1\",",
          "4752: \"FujiFilm XF1\",",
          "4753: \"FujiFilm X-T1\",",
          "4754: \"FujiFilm X-T1 Graphite Silver\",",
          "4755: \"FujiFilm X-T2\",",
          "4756: \"FujiFilm X-T10\",",
          "4757: \"FujiFilm IS-1\",",
          "4758: \"Gione E7\",",
          "4759: \"GITUP GIT2\",",
          "4760: \"Google Pixel\",",
          "4761: \"Google Pixel XL\",",
          "4762: \"Hasselblad H5D-60\",",
          "4763: \"Hasselblad H5D-50\",",
          "4764: \"Hasselblad H5D-50c\",",
          "4765: \"Hasselblad H5D-40\",",
          "4766: \"Hasselblad H4D-60\",",
          "4767: \"Hasselblad H4D-50\",",
          "4768: \"Hasselblad H4D-40\",",
          "4769: \"Hasselblad H4D-31\",",
          "4770: \"Hasselblad H3DII-22\",",
          "4771: \"Hasselblad H3DII-31\",",
          "4772: \"Hasselblad H3DII-39\",",
          "4773: \"Hasselblad H3DII-50\",",
          "4774: \"Hasselblad H3D-22\",",
          "4775: \"Hasselblad H3D-31\",",
          "4776: \"Hasselblad H3D-39\",",
          "4777: \"Hasselblad H2D-22\",",
          "4778: \"Hasselblad H2D-39\",",
          "4779: \"Hasselblad CFV\",",
          "4780: \"Hasselblad CFH\",",
          "4781: \"Hasselblad CF-22\",",
          "4782: \"Hasselblad CF-31\",",
          "4783: \"Hasselblad CF-39\",",
          "4784: \"Hasselblad V96C\",",
          "4785: \"Hasselblad Lusso\",",
          "4786: \"Hasselblad Lunar\",",
          "4787: \"Hasselblad True Zoom\",",
          "4788: \"Hasselblad Stellar\",",
          "4789: \"Hasselblad Stellar II\",",
          "4790: \"Hasselblad HV\",",
          "4791: \"Hasselblad X1D\",",
          "4792: \"HTC UltraPixel\",",
          "4793: \"HTC MyTouch 4G\",",
          "4794: \"HTC One (A9)\",",
          "4795: \"HTC One (M9)\",",
          "4796: \"HTC 10\",",
          "4797: \"Huawei P9\",",
          "4798: \"Imacon Ixpress 96, 96C\",",
          "4799: \"Imacon Ixpress 384, 384C (single shot only)\",",
          "4800: \"Imacon Ixpress 132C\",",
          "4801: \"Imacon Ixpress 528C (single shot only)\",",
          "4802: \"ISG 2020x1520\",",
          "4803: \"Ikonoskop A-Cam dII Panchromatic\",",
          "4804: \"Ikonoskop A-Cam dII\",",
          "4805: \"Kinefinity KineMINI\",",
          "4806: \"Kinefinity KineRAW Mini\",",
          "4807: \"Kinefinity KineRAW S35\",",
          "4808: \"Kodak DC20\",",
          "4809: \"Kodak DC25\",",
          "4810: \"Kodak DC40\",",
          "4811: \"Kodak DC50\",",
          "4812: \"Kodak DC120\",",
          "4813: \"Kodak DCS200\",",
          "4814: \"Kodak DCS315C\",",
          "4815: \"Kodak DCS330C\",",
          "4816: \"Kodak DCS420\",",
          "4817: \"Kodak DCS460\",",
          "4818: \"Kodak DCS460A\",",
          "4819: \"Kodak DCS460D\",",
          "4820: \"Kodak DCS520C\",",
          "4821: \"Kodak DCS560C\",",
          "4822: \"Kodak DCS620C\",",
          "4823: \"Kodak DCS620X\",",
          "4824: \"Kodak DCS660C\",",
          "4825: \"Kodak DCS660M\",",
          "4826: \"Kodak DCS720X\",",
          "4827: \"Kodak DCS760C\",",
          "4828: \"Kodak DCS760M\",",
          "4829: \"Kodak EOSDCS1\",",
          "4830: \"Kodak EOSDCS3B\",",
          "4831: \"Kodak NC2000F\",",
          "4832: \"Kodak ProBack\",",
          "4833: \"Kodak PB645C\",",
          "4834: \"Kodak PB645H\",",
          "4835: \"Kodak PB645M\",",
          "4836: \"Kodak DCS Pro 14n\",",
          "4837: \"Kodak DCS Pro 14nx\",",
          "4838: \"Kodak DCS Pro SLR/c\",",
          "4839: \"Kodak DCS Pro SLR/n\",",
          "4840: \"Kodak C330\",",
          "4841: \"Kodak C603\",",
          "4842: \"Kodak P850\",",
          "4843: \"Kodak P880\",",
          "4844: \"Kodak S-1\",",
          "4845: \"Kodak Z980\",",
          "4846: \"Kodak Z981\",",
          "4847: \"Kodak Z990\",",
          "4848: \"Kodak Z1015\",",
          "4849: \"Kodak KAI-0340\",",
          "4850: \"Konica KD-400Z\",",
          "4851: \"Konica KD-510Z\",",
          "4852: \"Leaf AFi 5\",",
          "4853: \"Leaf AFi 6\",",
          "4854: \"Leaf AFi 7\",",
          "4855: \"Leaf AFi-II 6\",",
          "4856: \"Leaf AFi-II 7\",",
          "4857: \"Leaf AFi-II 10\",",
          "4858: \"Leaf AFi-II 10R\",",
          "4859: \"Leaf Aptus-II 5\",",
          "4860: \"Leaf Aptus-II 6\",",
          "4861: \"Leaf Aptus-II 7\",",
          "4862: \"Leaf Aptus-II 8\",",
          "4863: \"Leaf Aptus-II 10\",",
          "4864: \"Leaf Aptus-II 12\",",
          "4865: \"Leaf Aptus-II 12R\",",
          "4866: \"Leaf Aptus 17\",",
          "4867: \"Leaf Aptus 22\",",
          "4868: \"Leaf Aptus 54S\",",
          "4869: \"Leaf Aptus 65\",",
          "4870: \"Leaf Aptus 65S\",",
          "4871: \"Leaf Aptus 75\",",
          "4872: \"Leaf Aptus 75S\",",
          "4873: \"Leaf Cantare\",",
          "4874: \"Leaf Cantare XY\",",
          "4875: \"Leaf CatchLight\",",
          "4876: \"Leaf CMost\",",
          "4877: \"Leaf Credo 40\",",
          "4878: \"Leaf Credo 50\",",
          "4879: \"Leaf Credo 60\",",
          "4880: \"Leaf Credo 80 (low compression mode only)\",",
          "4881: \"Leaf DCB-II\",",
          "4882: \"Leaf Valeo 6\",",
          "4883: \"Leaf Valeo 11\",",
          "4884: \"Leaf Valeo 17\",",
          "4885: \"Leaf Valeo 17wi\",",
          "4886: \"Leaf Valeo 22\",",
          "4887: \"Leaf Valeo 22wi\",",
          "4888: \"Leaf Volare\",",
          "4889: \"Lenovo a820\",",
          "4890: \"Leica C (Typ 112)\",",
          "4891: \"Leica Digilux 2\",",
          "4892: \"Leica Digilux 3\",",
          "4893: \"Leica Digital-Modul-R\",",
          "4894: \"Leica D-LUX2\",",
          "4895: \"Leica D-LUX3\",",
          "4896: \"Leica D-LUX4\",",
          "4897: \"Leica D-LUX5\",",
          "4898: \"Leica D-LUX6\",",
          "4899: \"Leica D-Lux (Typ 109)\",",
          "4900: \"Leica M8\",",
          "4901: \"Leica M8.2\",",
          "4902: \"Leica M9\",",
          "4903: \"Leica M (Typ 240)\",",
          "4904: \"Leica M (Typ 262)\",",
          "4905: \"Leica Monochrom (Typ 240)\",",
          "4906: \"Leica Monochrom (Typ 246)\",",
          "4907: \"Leica M-D (Typ 262)\",",
          "4908: \"Leica M-E\",",
          "4909: \"Leica M-P\",",
          "4910: \"Leica R8\",",
          "4911: \"Leica Q (Typ 116)\",",
          "4912: \"Leica S\",",
          "4913: \"Leica S2\",",
          "4914: \"Leica S (Typ 007)\",",
          "4915: \"Leica SL (Typ 601)\",",
          "4916: \"Leica T (Typ 701)\",",
          "4917: \"Leica TL\",",
          "4918: \"Leica X1\",",
          "4919: \"Leica X (Typ 113)\",",
          "4920: \"Leica X2\",",
          "4921: \"Leica X-E (Typ 102)\",",
          "4922: \"Leica X-U (Typ 113)\",",
          "4923: \"Leica V-LUX1\",",
          "4924: \"Leica V-LUX2\",",
          "4925: \"Leica V-LUX3\",",
          "4926: \"Leica V-LUX4\",",
          "4927: \"Leica V-Lux (Typ 114)\",",
          "4928: \"Leica X VARIO (Typ 107)\",",
          "4929: \"LG G3\",",
          "4930: \"LG G4\",",
          "4931: \"Logitech Fotoman Pixtura\",",
          "4932: \"Mamiya ZD\",",
          "4933: \"Matrix 4608x3288\",",
          "4934: \"Meizy MX4\",",
          "4935: \"Micron 2010\",",
          "4936: \"Minolta RD175\",",
          "4937: \"Minolta DiMAGE 5\",",
          "4938: \"Minolta DiMAGE 7\",",
          "4939: \"Minolta DiMAGE 7i\",",
          "4940: \"Minolta DiMAGE 7Hi\",",
          "4941: \"Minolta DiMAGE A1\",",
          "4942: \"Minolta DiMAGE A2\",",
          "4943: \"Minolta DiMAGE A200\",",
          "4944: \"Minolta DiMAGE G400\",",
          "4945: \"Minolta DiMAGE G500\",",
          "4946: \"Minolta DiMAGE G530\",",
          "4947: \"Minolta DiMAGE G600\",",
          "4948: \"Minolta DiMAGE Z2\",",
          "4949: \"Minolta Alpha/Dynax/Maxxum 5D\",",
          "4950: \"Minolta Alpha/Dynax/Maxxum 7D\",",
          "4951: \"Motorola PIXL\",",
          "4952: \"Nikon D1\",",
          "4953: \"Nikon D1H\",",
          "4954: \"Nikon D1X\",",
          "4955: \"Nikon D2H\",",
          "4956: \"Nikon D2Hs\",",
          "4957: \"Nikon D2X\",",
          "4958: \"Nikon D2Xs\",",
          "4959: \"Nikon D3\",",
          "4960: \"Nikon D3s\",",
          "4961: \"Nikon D3X\",",
          "4962: \"Nikon D4\",",
          "4963: \"Nikon D4s\",",
          "4964: \"Nikon D40\",",
          "4965: \"Nikon D40X\",",
          "4966: \"Nikon D5\",",
          "4967: \"Nikon D50\",",
          "4968: \"Nikon D60\",",
          "4969: \"Nikon D70\",",
          "4970: \"Nikon D70s\",",
          "4971: \"Nikon D80\",",
          "4972: \"Nikon D90\",",
          "4973: \"Nikon D100\",",
          "4974: \"Nikon D200\",",
          "4975: \"Nikon D300\",",
          "4976: \"Nikon D300s\",",
          "4977: \"Nikon D500\",",
          "4978: \"Nikon D600\",",
          "4979: \"Nikon D610\",",
          "4980: \"Nikon D700\",",
          "4981: \"Nikon D750\",",
          "4982: \"Nikon D800\",",
          "4983: \"Nikon D800E\",",
          "4984: \"Nikon D810\",",
          "4985: \"Nikon D810A\",",
          "4986: \"Nikon D3000\",",
          "4987: \"Nikon D3100\",",
          "4988: \"Nikon D3200\",",
          "4989: \"Nikon D3300\",",
          "4990: \"Nikon D3400\",",
          "4991: \"Nikon D5000\",",
          "4992: \"Nikon D5100\",",
          "4993: \"Nikon D5200\",",
          "4994: \"Nikon D5300\",",
          "4995: \"Nikon D5500\",",
          "4996: \"Nikon D7000\",",
          "4997: \"Nikon D7100\",",
          "4998: \"Nikon D7200\",",
          "4999: \"Nikon Df\",",
          "5000: \"Nikon 1 AW1\",",
          "5001: \"Nikon 1 J1\",",
          "5002: \"Nikon 1 J2\",",
          "5003: \"Nikon 1 J3\",",
          "5004: \"Nikon 1 J4\",",
          "5005: \"Nikon 1 J5\",",
          "5006: \"Nikon 1 S1\",",
          "5007: \"Nikon 1 S2\",",
          "5008: \"Nikon 1 V1\",",
          "5009: \"Nikon 1 V2\",",
          "5010: \"Nikon 1 V3\",",
          "5011: \"Nikon E700 (\\\"DIAG RAW\\\" hack)\",",
          "5012: \"Nikon E800 (\\\"DIAG RAW\\\" hack)\",",
          "5013: \"Nikon E880 (\\\"DIAG RAW\\\" hack)\",",
          "5014: \"Nikon E900 (\\\"DIAG RAW\\\" hack)\",",
          "5015: \"Nikon E950 (\\\"DIAG RAW\\\" hack)\",",
          "5016: \"Nikon E990 (\\\"DIAG RAW\\\" hack)\",",
          "5017: \"Nikon E995 (\\\"DIAG RAW\\\" hack)\",",
          "5018: \"Nikon E2100 (\\\"DIAG RAW\\\" hack)\",",
          "5019: \"Nikon E2500 (\\\"DIAG RAW\\\" hack)\",",
          "5020: \"Nikon E3200 (\\\"DIAG RAW\\\" hack)\",",
          "5021: \"Nikon E3700 (\\\"DIAG RAW\\\" hack)\",",
          "5022: \"Nikon E4300 (\\\"DIAG RAW\\\" hack)\",",
          "5023: \"Nikon E4500 (\\\"DIAG RAW\\\" hack)\",",
          "5024: \"Nikon E5000\",",
          "5025: \"Nikon E5400\",",
          "5026: \"Nikon E5700\",",
          "5027: \"Nikon E8400\",",
          "5028: \"Nikon E8700\",",
          "5029: \"Nikon E8800\",",
          "5030: \"Nikon Coolpix A\",",
          "5031: \"Nikon Coolpix P330\",",
          "5032: \"Nikon Coolpix P340\",",
          "5033: \"Nikon Coolpix P6000\",",
          "5034: \"Nikon Coolpix P7000\",",
          "5035: \"Nikon Coolpix P7100\",",
          "5036: \"Nikon Coolpix P7700\",",
          "5037: \"Nikon Coolpix P7800\",",
          "5038: \"Nikon Coolpix S6 (\\\"DIAG RAW\\\" hack)\",",
          "5039: \"Nikon Coolscan NEF\",",
          "5040: \"Nokia N95\",",
          "5041: \"Nokia X2\",",
          "5042: \"Nokia 1200x1600\",",
          "5043: \"Nokia Lumia 950 XL\",",
          "5044: \"Nokia Lumia 1020\",",
          "5045: \"Nokia Lumia 1520\",",
          "5046: \"Olympus AIR A01\",",
          "5047: \"Olympus C3030Z\",",
          "5048: \"Olympus C5050Z\",",
          "5049: \"Olympus C5060Z\",",
          "5050: \"Olympus C7070WZ\",",
          "5051: \"Olympus C70Z,C7000Z\",",
          "5052: \"Olympus C740UZ\",",
          "5053: \"Olympus C770UZ\",",
          "5054: \"Olympus C8080WZ\",",
          "5055: \"Olympus X200,D560Z,C350Z\",",
          "5056: \"Olympus E-1\",",
          "5057: \"Olympus E-3\",",
          "5058: \"Olympus E-5\",",
          "5059: \"Olympus E-10\",",
          "5060: \"Olympus E-20\",",
          "5061: \"Olympus E-30\",",
          "5062: \"Olympus E-300\",",
          "5063: \"Olympus E-330\",",
          "5064: \"Olympus E-400\",",
          "5065: \"Olympus E-410\",",
          "5066: \"Olympus E-420\",",
          "5067: \"Olympus E-450\",",
          "5068: \"Olympus E-500\",",
          "5069: \"Olympus E-510\",",
          "5070: \"Olympus E-520\",",
          "5071: \"Olympus E-600\",",
          "5072: \"Olympus E-620\",",
          "5073: \"Olympus E-P1\",",
          "5074: \"Olympus E-P2\",",
          "5075: \"Olympus E-P3\",",
          "5076: \"Olympus E-P5\",",
          "5077: \"Olympus E-PL1\",",
          "5078: \"Olympus E-PL1s\",",
          "5079: \"Olympus E-PL2\",",
          "5080: \"Olympus E-PL3\",",
          "5081: \"Olympus E-PL5\",",
          "5082: \"Olympus E-PL6\",",
          "5083: \"Olympus E-PL7\",",
          "5084: \"Olympus E-PL8\",",
          "5085: \"Olympus E-PM1\",",
          "5086: \"Olympus E-PM2\",",
          "5087: \"Olympus E-M1\",",
          "5088: \"Olympus E-M1 Mark II\",",
          "5089: \"Olympus E-M10\",",
          "5090: \"Olympus E-M10 Mark II\",",
          "5091: \"Olympus E-M5\",",
          "5092: \"Olympus E-M5 Mark II\",",
          "5093: \"Olympus Pen F\",",
          "5094: \"Olympus SP310\",",
          "5095: \"Olympus SP320\",",
          "5096: \"Olympus SP350\",",
          "5097: \"Olympus SP500UZ\",",
          "5098: \"Olympus SP510UZ\",",
          "5099: \"Olympus SP550UZ\",",
          "5100: \"Olympus SP560UZ\",",
          "5101: \"Olympus SP565UZ\",",
          "5102: \"Olympus SP570UZ\",",
          "5103: \"Olympus STYLUS1\",",
          "5104: \"Olympus STYLUS1s\",",
          "5105: \"Olympus SH-2\",",
          "5106: \"Olympus SH-3\",",
          "5107: \"Olympus TG-4\",",
          "5108: \"Olympus XZ-1\",",
          "5109: \"Olympus XZ-2\",",
          "5110: \"Olympus XZ-10\",",
          "5111: \"OmniVision 4688\",",
          "5112: \"OmniVision OV5647\",",
          "5113: \"OmniVision OV5648\",",
          "5114: \"OmniVision OV8850\",",
          "5115: \"OmniVision 13860\",",
          "5116: \"Panasonic DMC-CM1\",",
          "5117: \"Panasonic DMC-FZ8\",",
          "5118: \"Panasonic DMC-FZ18\",",
          "5119: \"Panasonic DMC-FZ28\",",
          "5120: \"Panasonic DMC-FZ30\",",
          "5121: \"Panasonic DMC-FZ35/FZ38\",",
          "5122: \"Panasonic DMC-FZ40\",",
          "5123: \"Panasonic DMC-FZ50\",",
          "5124: \"Panasonic DMC-FZ7\",",
          "5125: \"Panasonic DMC-FZ70\",",
          "5126: \"Panasonic DMC-FZ100\",",
          "5127: \"Panasonic DMC-FZ150\",",
          "5128: \"Panasonic DMC-FZ200\",",
          "5129: \"Panasonic DMC-FZ300/330\",",
          "5130: \"Panasonic DMC-FZ1000\",",
          "5131: \"Panasonic DMC-FZ2000/2500/FZH1\",",
          "5132: \"Panasonic DMC-FX150\",",
          "5133: \"Panasonic DMC-G1\",",
          "5134: \"Panasonic DMC-G10\",",
          "5135: \"Panasonic DMC-G2\",",
          "5136: \"Panasonic DMC-G3\",",
          "5137: \"Panasonic DMC-G5\",",
          "5138: \"Panasonic DMC-G6\",",
          "5139: \"Panasonic DMC-G7/G70\",",
          "5140: \"Panasonic DMC-G8/80/81/85\",",
          "5141: \"Panasonic DMC-GF1\",",
          "5142: \"Panasonic DMC-GF2\",",
          "5143: \"Panasonic DMC-GF3\",",
          "5144: \"Panasonic DMC-GF5\",",
          "5145: \"Panasonic DMC-GF6\",",
          "5146: \"Panasonic DMC-GF7\",",
          "5147: \"Panasonic DMC-GH1\",",
          "5148: \"Panasonic DMC-GH2\",",
          "5149: \"Panasonic DMC-GH3\",",
          "5150: \"Panasonic DMC-GH4\",",
          "5151: \"Panasonic AG-GH4\",",
          "5152: \"Panasonic DMC-GM1\",",
          "5153: \"Panasonic DMC-GM1s\",",
          "5154: \"Panasonic DMC-GM5\",",
          "5155: \"Panasonic DMC-GX1\",",
          "5156: \"Panasonic DMC-GX7\",",
          "5157: \"Panasonic DMC-GX8\",",
          "5158: \"Panasonic DMC-GX80/85\",",
          "5159: \"Panasonic DMC-L1\",",
          "5160: \"Panasonic DMC-L10\",",
          "5161: \"Panasonic DMC-LC1\",",
          "5162: \"Panasonic DMC-LX1\",",
          "5163: \"Panasonic DMC-LF1\",",
          "5164: \"Panasonic DMC-LX2\",",
          "5165: \"Panasonic DMC-LX3\",",
          "5166: \"Panasonic DMC-LX5\",",
          "5167: \"Panasonic DMC-LX7\",",
          "5168: \"Panasonic DMC-LX9/10/15\",",
          "5169: \"Panasonic DMC-LX100\",",
          "5170: \"Panasonic DMC-TZ60/61/SZ40\",",
          "5171: \"Panasonic DMC-TZ70/71/ZS50\",",
          "5172: \"Panasonic DMC-TZ80/81/85/ZS60\",",
          "5173: \"Panasonic DMC-TZ100/101/ZS100\",",
          "5174: \"Pentax *ist D\",",
          "5175: \"Pentax *ist DL\",",
          "5176: \"Pentax *ist DL2\",",
          "5177: \"Pentax *ist DS\",",
          "5178: \"Pentax *ist DS2\",",
          "5179: \"Pentax GR\",",
          "5180: \"Pentax K10D\",",
          "5181: \"Pentax K20D\",",
          "5182: \"Pentax K100D\",",
          "5183: \"Pentax K100D Super\",",
          "5184: \"Pentax K110D\",",
          "5185: \"Pentax K200D\",",
          "5186: \"Pentax K2000/K-m\",",
          "5187: \"Pentax K-x\",",
          "5188: \"Pentax K-r\",",
          "5189: \"Pentax K-01\",",
          "5190: \"Pentax K-1\",",
          "5191: \"Pentax K-3\",",
          "5192: \"Pentax K-3 II\",",
          "5193: \"Pentax K-30\",",
          "5194: \"Pentax K-5\",",
          "5195: \"Pentax K-5 II\",",
          "5196: \"Pentax K-5 IIs\",",
          "5197: \"Pentax K-50\",",
          "5198: \"Pentax K-500\",",
          "5199: \"Pentax K-7\",",
          "5200: \"Pentax K-70\",",
          "5201: \"Pentax K-S1\",",
          "5202: \"Pentax K-S2\",",
          "5203: \"Pentax MX-1\",",
          "5204: \"Pentax Q\",",
          "5205: \"Pentax Q7\",",
          "5206: \"Pentax Q10\",",
          "5207: \"Pentax QS-1\",",
          "5208: \"Pentax Optio S\",",
          "5209: \"Pentax Optio S4\",",
          "5210: \"Pentax Optio 33WR\",",
          "5211: \"Pentax Optio 750Z\",",
          "5212: \"Pentax 645D\",",
          "5213: \"Pentax 645Z\",",
          "5214: \"PhaseOne IQ140\",",
          "5215: \"PhaseOne IQ150\",",
          "5216: \"PhaseOne IQ160\",",
          "5217: \"PhaseOne IQ180\",",
          "5218: \"PhaseOne IQ180 IR\",",
          "5219: \"PhaseOne IQ250\",",
          "5220: \"PhaseOne IQ260\",",
          "5221: \"PhaseOne IQ260 Achromatic\",",
          "5222: \"PhaseOne IQ280\",",
          "5223: \"PhaseOne IQ3 50MP\",",
          "5224: \"PhaseOne IQ3 60MP\",",
          "5225: \"PhaseOne IQ3 80MP\",",
          "5226: \"PhaseOne IQ3 100MP\",",
          "5227: \"PhaseOne LightPhase\",",
          "5228: \"PhaseOne Achromatic+\",",
          "5229: \"PhaseOne H 10\",",
          "5230: \"PhaseOne H 20\",",
          "5231: \"PhaseOne H 25\",",
          "5232: \"PhaseOne P 20\",",
          "5233: \"PhaseOne P 20+\",",
          "5234: \"PhaseOne P 21\",",
          "5235: \"PhaseOne P 25\",",
          "5236: \"PhaseOne P 25+\",",
          "5237: \"PhaseOne P 30\",",
          "5238: \"PhaseOne P 30+\",",
          "5239: \"PhaseOne P 40+\",",
          "5240: \"PhaseOne P 45\",",
          "5241: \"PhaseOne P 45+\",",
          "5242: \"PhaseOne P 65\",",
          "5243: \"PhaseOne P 65+\",",
          "5244: \"Photron BC2-HD\",",
          "5245: \"Pixelink A782\",",
          "5246: \"Polaroid x530\",",
          "5247: \"RaspberryPi Camera\",",
          "5248: \"RaspberryPi Camera V2\",",
          "5249: \"Ricoh GR\",",
          "5250: \"Ricoh GR Digital\",",
          "5251: \"Ricoh GR Digital II\",",
          "5252: \"Ricoh GR Digital III\",",
          "5253: \"Ricoh GR Digital IV\",",
          "5254: \"Ricoh GR II\",",
          "5255: \"Ricoh GX100\",",
          "5256: \"Ricoh GX200\",",
          "5257: \"Ricoh GXR MOUNT A12\",",
          "5258: \"Ricoh GXR MOUNT A16 24-85mm F3.5-5.5\",",
          "5259: \"Ricoh GXR, S10 24-72mm F2.5-4.4 VC\",",
          "5260: \"Ricoh GXR, GR A12 50mm F2.5 MACRO\",",
          "5261: \"Ricoh GXR, GR LENS A12 28mm F2.5\",",
          "5262: \"Ricoh GXR, GXR P10\",",
          "5264: \"Redcode R3D format\",",
          "5266: \"Rollei d530flex\",",
          "5267: \"RoverShot 3320af\",",
          "5268: \"Samsung EX1\",",
          "5269: \"Samsung EX2F\",",
          "5270: \"Samsung GX-1L\",",
          "5271: \"Samsung GX-1S\",",
          "5272: \"Samsung GX10\",",
          "5273: \"Samsung GX20\",",
          "5274: \"Samsung Galaxy NX (EK-GN120)\",",
          "5275: \"Samsung Galaxy S7 (SM-G935F)\",",
          "5276: \"Samsung NX1\",",
          "5277: \"Samsung NX5\",",
          "5278: \"Samsung NX10\",",
          "5279: \"Samsung NX11\",",
          "5280: \"Samsung NX100\",",
          "5281: \"Samsung NX1000\",",
          "5282: \"Samsung NX1100\",",
          "5283: \"Samsung NX20\",",
          "5284: \"Samsung NX200\",",
          "5285: \"Samsung NX210\",",
          "5286: \"Samsung NX2000\",",
          "5287: \"Samsung NX30\",",
          "5288: \"Samsung NX300\",",
          "5289: \"Samsung NX300M\",",
          "5290: \"Samsung NX3000\",",
          "5291: \"Samsung NX500\",",
          "5292: \"Samsung NX mini\",",
          "5293: \"Samsung Pro815\",",
          "5294: \"Samsung WB550\",",
          "5295: \"Samsung WB2000\",",
          "5296: \"Samsung S85 (hacked)\",",
          "5297: \"Samsung S850 (hacked)\",",
          "5298: \"Samsung Galaxy S3\",",
          "5299: \"Samsung Galaxy S7\",",
          "5300: \"Samsung Galaxy S7 Edge\",",
          "5301: \"Samsung Galaxy Nexus\",",
          "5302: \"Sarnoff 4096x5440\",",
          "5303: \"Seitz 6x17\",",
          "5304: \"Seitz Roundshot D3\",",
          "5305: \"Seitz Roundshot D2X\",",
          "5306: \"Seitz Roundshot D2Xs\",",
          "5307: \"Sigma SD9\",",
          "5308: \"Sigma SD10\",",
          "5309: \"Sigma SD14\",",
          "5310: \"Sigma SD15\",",
          "5311: \"Sigma SD1\",",
          "5312: \"Sigma SD1 Merill\",",
          "5313: \"Sigma DP1\",",
          "5314: \"Sigma DP1 Merill\",",
          "5315: \"Sigma DP1S\",",
          "5316: \"Sigma DP1X\",",
          "5317: \"Sigma DP2\",",
          "5318: \"Sigma DP2 Merill\",",
          "5319: \"Sigma DP2S\",",
          "5320: \"Sigma DP2X\",",
          "5321: \"Sigma DP3 Merill\",",
          "5322: \"Sigma dp0 Quattro\",",
          "5323: \"Sigma dp1 Quattro\",",
          "5324: \"Sigma dp2 Quattro\",",
          "5325: \"Sigma dp3 Quattro\",",
          "5326: \"Sigma sd Quattro\",",
          "5327: \"Sinar eMotion 22\",",
          "5328: \"Sinar eMotion 54\",",
          "5329: \"Sinar eSpirit 65\",",
          "5330: \"Sinar eMotion 75\",",
          "5331: \"Sinar eVolution 75\",",
          "5332: \"Sinar 3072x2048\",",
          "5333: \"Sinar 4080x4080\",",
          "5334: \"Sinar 4080x5440\",",
          "5335: \"Sinar STI format\",",
          "5336: \"Sinar Sinarback 54\",",
          "5337: \"SMaL Ultra-Pocket 3\",",
          "5338: \"SMaL Ultra-Pocket 4\",",
          "5339: \"SMaL Ultra-Pocket 5\",",
          "5340: \"Sony A7\",",
          "5341: \"Sony A7 II\",",
          "5342: \"Sony A7R\",",
          "5343: \"Sony A7R II\",",
          "5344: \"Sony A7S\",",
          "5345: \"Sony A7S II\",",
          "5346: \"Sony ILCA-68 (A68)\",",
          "5347: \"Sony ILCA-77M2 (A77-II)\",",
          "5348: \"Sony ILCA-99M2 (A99-II)\",",
          "5349: \"Sony ILCE-3000\",",
          "5350: \"Sony ILCE-5000\",",
          "5351: \"Sony ILCE-5100\",",
          "5352: \"Sony ILCE-6000\",",
          "5353: \"Sony ILCE-6300\",",
          "5354: \"Sony ILCE-6500\",",
          "5355: \"Sony ILCE-QX1\",",
          "5356: \"Sony DSC-F828\",",
          "5357: \"Sony DSC-R1\",",
          "5358: \"Sony DSC-RX1\",",
          "5359: \"Sony DSC-RX1R\",",
          "5360: \"Sony DSC-RX1R II\",",
          "5361: \"Sony DSC-RX10\",",
          "5362: \"Sony DSC-RX10II\",",
          "5363: \"Sony DSC-RX10III\",",
          "5364: \"Sony DSC-RX100\",",
          "5365: \"Sony DSC-RX100II\",",
          "5366: \"Sony DSC-RX100III\",",
          "5367: \"Sony DSC-RX100IV\",",
          "5368: \"Sony DSC-RX100V\",",
          "5369: \"Sony DSC-V3\",",
          "5370: \"Sony DSLR-A100\",",
          "5371: \"Sony DSLR-A200\",",
          "5372: \"Sony DSLR-A230\",",
          "5373: \"Sony DSLR-A290\",",
          "5374: \"Sony DSLR-A300\",",
          "5375: \"Sony DSLR-A330\",",
          "5376: \"Sony DSLR-A350\",",
          "5377: \"Sony DSLR-A380\",",
          "5378: \"Sony DSLR-A390\",",
          "5379: \"Sony DSLR-A450\",",
          "5380: \"Sony DSLR-A500\",",
          "5381: \"Sony DSLR-A550\",",
          "5382: \"Sony DSLR-A560\",",
          "5383: \"Sony DSLR-A580\",",
          "5384: \"Sony DSLR-A700\",",
          "5385: \"Sony DSLR-A850\",",
          "5386: \"Sony DSLR-A900\",",
          "5387: \"Sony NEX-3\",",
          "5388: \"Sony NEX-3N\",",
          "5389: \"Sony NEX-5\",",
          "5390: \"Sony NEX-5N\",",
          "5391: \"Sony NEX-5R\",",
          "5392: \"Sony NEX-5T\",",
          "5393: \"Sony NEX-6\",",
          "5394: \"Sony NEX-7\",",
          "5395: \"Sony NEX-C3\",",
          "5396: \"Sony NEX-F3\",",
          "5397: \"Sony NEX-VG20\",",
          "5398: \"Sony NEX-VG30\",",
          "5399: \"Sony NEX-VG900\",",
          "5400: \"Sony SLT-A33\",",
          "5401: \"Sony SLT-A35\",",
          "5402: \"Sony SLT-A37\",",
          "5403: \"Sony SLT-A55V\",",
          "5404: \"Sony SLT-A57\",",
          "5405: \"Sony SLT-A58\",",
          "5406: \"Sony SLT-A65V\",",
          "5407: \"Sony SLT-A77V\",",
          "5408: \"Sony SLT-A99V\",",
          "5409: \"Sony XCD-SX910CR\",",
          "5410: \"Sony IMX135-mipi 13mp\",",
          "5411: \"Sony IMX135-QCOM\",",
          "5412: \"Sony IMX072-mipi\",",
          "5413: \"Sony IMX214\",",
          "5414: \"Sony IMX219\",",
          "5415: \"Sony IMX230\",",
          "5416: \"Sony IMX298-mipi 16mp\",",
          "5417: \"Sony IMX219-mipi 8mp\",",
          "5418: \"Sony Xperia L\",",
          "5419: \"STV680 VGA\",",
          "5420: \"PtGrey GRAS-50S5C\",",
          "5421: \"JaiPulnix BB-500CL\",",
          "5422: \"JaiPulnix BB-500GE\",",
          "5423: \"SVS SVS625CL\",",
          "5424: \"YUNEEC CGO4\",",
          "5425: \"Xiaomi MI3\",",
          "5426: \"Xiaomi RedMi Note3 Pro\",",
          "5427:    NULL",
          "5428: };",
          "5430: const char** LibRaw::cameraList() { return static_camera_list;}",
          "5431: int LibRaw::cameraCount() { return (sizeof(static_camera_list)/sizeof(static_camera_list[0]))-1; }",
          "5434: const char * LibRaw::strprogress(enum LibRaw_progress p)",
          "5436:   switch(p)",
          "5437:     {",
          "5438:     case LIBRAW_PROGRESS_START:",
          "5439:       return \"Starting\";",
          "5440:     case LIBRAW_PROGRESS_OPEN :",
          "5441:       return \"Opening file\";",
          "5442:     case LIBRAW_PROGRESS_IDENTIFY :",
          "5443:       return \"Reading metadata\";",
          "5444:     case LIBRAW_PROGRESS_SIZE_ADJUST:",
          "5445:       return \"Adjusting size\";",
          "5446:     case LIBRAW_PROGRESS_LOAD_RAW:",
          "5447:       return \"Reading RAW data\";",
          "5448:     case LIBRAW_PROGRESS_REMOVE_ZEROES:",
          "5449:       return \"Clearing zero values\";",
          "5450:     case LIBRAW_PROGRESS_BAD_PIXELS :",
          "5451:       return \"Removing dead pixels\";",
          "5452:     case LIBRAW_PROGRESS_DARK_FRAME:",
          "5453:       return \"Subtracting dark frame data\";",
          "5454:     case LIBRAW_PROGRESS_FOVEON_INTERPOLATE:",
          "5455:       return \"Interpolating Foveon sensor data\";",
          "5456:     case LIBRAW_PROGRESS_SCALE_COLORS:",
          "5457:       return \"Scaling colors\";",
          "5458:     case LIBRAW_PROGRESS_PRE_INTERPOLATE:",
          "5459:       return \"Pre-interpolating\";",
          "5460:     case LIBRAW_PROGRESS_INTERPOLATE:",
          "5461:       return \"Interpolating\";",
          "5462:     case LIBRAW_PROGRESS_MIX_GREEN :",
          "5463:       return \"Mixing green channels\";",
          "5464:     case LIBRAW_PROGRESS_MEDIAN_FILTER   :",
          "5465:       return \"Median filter\";",
          "5466:     case LIBRAW_PROGRESS_HIGHLIGHTS:",
          "5467:       return \"Highlight recovery\";",
          "5468:     case LIBRAW_PROGRESS_FUJI_ROTATE :",
          "5469:       return \"Rotating Fuji diagonal data\";",
          "5470:     case LIBRAW_PROGRESS_FLIP :",
          "5471:       return \"Flipping image\";",
          "5472:     case LIBRAW_PROGRESS_APPLY_PROFILE:",
          "5473:       return \"ICC conversion\";",
          "5474:     case LIBRAW_PROGRESS_CONVERT_RGB:",
          "5475:       return \"Converting to RGB\";",
          "5476:     case LIBRAW_PROGRESS_STRETCH:",
          "5477:       return \"Stretching image\";",
          "5478:     case LIBRAW_PROGRESS_THUMB_LOAD:",
          "5479:       return \"Loading thumbnail\";",
          "5480:     default:",
          "5481:       return \"Some strange things\";",
          "5482:     }",
          "5490: void x3f_clear(void *p)",
          "5491: {",
          "5492:   x3f_delete((x3f_t*)p);",
          "5493: }",
          "5499:   while (*str != 0x00) {",
          "",
          "[Added Lines]",
          "4451:     {",
          "4452:       remove_zeroes();",
          "4453:       SET_PROC_FLAG(LIBRAW_PROGRESS_REMOVE_ZEROES);",
          "4454:     }",
          "4456:     if (O.bad_pixels && no_crop)",
          "4457:     {",
          "4458:       bad_pixels(O.bad_pixels);",
          "4459:       SET_PROC_FLAG(LIBRAW_PROGRESS_BAD_PIXELS);",
          "4460:     }",
          "4463:     {",
          "4464:       subtract(O.dark_frame);",
          "4465:       SET_PROC_FLAG(LIBRAW_PROGRESS_DARK_FRAME);",
          "4466:     }",
          "4469:     {",
          "4470:       wf_remove_banding();",
          "4471:     }",
          "4475:     if (O.user_qual >= 0)",
          "4476:       quality = O.user_qual;",
          "4478:     if (!subtract_inline || !C.data_maximum)",
          "4479:     {",
          "4480:       adjust_bl();",
          "4481:       subtract_black_internal();",
          "4482:     }",
          "4484:     if (!(di.decoder_flags & LIBRAW_DECODER_FIXEDMAXC))",
          "4485:       adjust_maximum();",
          "4487:     if (O.user_sat > 0)",
          "4488:       C.maximum = O.user_sat;",
          "4491:     {",
          "4492:       if (load_raw == &LibRaw::x3f_load_raw)",
          "4495:         for (int i = 0; i < S.height * S.width * 4; i++)",
          "4496:           if ((short)imgdata.image[0][i] < 0)",
          "4497:             imgdata.image[0][i] = 0;",
          "4498:       }",
          "4500:       else if (load_raw == &LibRaw::foveon_dp_load_raw)",
          "4501:       {",
          "4502:         for (int i = 0; i < S.height * S.width * 4; i++)",
          "4503:           if ((short)imgdata.image[0][i] < 0)",
          "4504:             imgdata.image[0][i] = 0;",
          "4506:       else",
          "4508:         foveon_interpolate();",
          "4510: #endif",
          "4511:       SET_PROC_FLAG(LIBRAW_PROGRESS_FOVEON_INTERPOLATE);",
          "4512:     }",
          "4514:     if (O.green_matching && !O.half_size)",
          "4515:     {",
          "4516:       green_matching();",
          "4517:     }",
          "4524:     {",
          "4525:       scale_colors();",
          "4526:       SET_PROC_FLAG(LIBRAW_PROGRESS_SCALE_COLORS);",
          "4527:     }",
          "4533:     if (O.dcb_iterations >= 0)",
          "4534:       iterations = O.dcb_iterations;",
          "4535:     if (O.dcb_enhance_fl >= 0)",
          "4536:       dcb_enhance = O.dcb_enhance_fl;",
          "4537:     if (O.fbdd_noiserd >= 0)",
          "4538:       noiserd = O.fbdd_noiserd;",
          "4539:     if (O.eeci_refine >= 0)",
          "4540:       eeci_refine_fl = O.eeci_refine;",
          "4541:     if (O.es_med_passes > 0)",
          "4542:       es_med_passes_fl = O.es_med_passes;",
          "4546:     if (!O.half_size && O.cfa_green > 0)",
          "4547:     {",
          "4548:       thresh = O.green_thresh;",
          "4549:       green_equilibrate(thresh);",
          "4550:     }",
          "4551:     if (O.exp_correc > 0)",
          "4552:     {",
          "4553:       expos = O.exp_shift;",
          "4554:       preser = O.exp_preser;",
          "4555:       exp_bef(expos, preser);",
          "4556:     }",
          "4557:     if (O.ca_correc > 0)",
          "4558:     {",
          "4559:       cablue = O.cablue;",
          "4560:       cared = O.cared;",
          "4561:       CA_correct_RT(cablue, cared);",
          "4562:     }",
          "4563:     if (O.cfaline > 0)",
          "4564:     {",
          "4565:       linenoise = O.linenoise;",
          "4566:       cfa_linedn(linenoise);",
          "4567:     }",
          "4568:     if (O.cfa_clean > 0)",
          "4569:     {",
          "4570:       lclean = O.lclean;",
          "4571:       cclean = O.cclean;",
          "4572:       cfa_impulse_gauss(lclean, cclean);",
          "4573:     }",
          "4575:     if (P1.filters && !O.no_interpolation)",
          "4576:     {",
          "4577:       if (noiserd > 0 && P1.colors == 3 && P1.filters)",
          "4578:         fbdd(noiserd);",
          "4580:       if (P1.filters > 1000 && interpolate_bayer)",
          "4581:         (this->*interpolate_bayer)();",
          "4582:       else if (P1.filters == 9 && interpolate_xtrans)",
          "4583:         (this->*interpolate_xtrans)();",
          "4584:       else if (quality == 0)",
          "4585:         lin_interpolate();",
          "4586:       else if (quality == 1 || P1.colors > 3)",
          "4587:         vng_interpolate();",
          "4588:       else if (quality == 2 && P1.filters > 1000)",
          "4589:         ppg_interpolate();",
          "4590:       else if (P1.filters == LIBRAW_XTRANS)",
          "4593:         xtrans_interpolate(quality > 2 ? 3 : 1);",
          "4595:       else if (quality == 3)",
          "4596:         ahd_interpolate(); // really don't need it here due to fallback op",
          "4597:       else if (quality == 4)",
          "4598:         dcb(iterations, dcb_enhance);",
          "4600:       else if (quality == 5)",
          "4601:         ahd_interpolate_mod();",
          "4602:       else if (quality == 6)",
          "4603:         afd_interpolate_pl(2, 1);",
          "4604:       else if (quality == 7)",
          "4605:         vcd_interpolate(0);",
          "4606:       else if (quality == 8)",
          "4607:         vcd_interpolate(12);",
          "4608:       else if (quality == 9)",
          "4609:         lmmse_interpolate(1);",
          "4612:       else if (quality == 10)",
          "4613:         amaze_demosaic_RT();",
          "4615:       else if (quality == 11)",
          "4616:         dht_interpolate();",
          "4617:       else if (quality == 12)",
          "4618:         aahd_interpolate();",
          "4620:       else",
          "4622:         ahd_interpolate();",
          "4623:         imgdata.process_warnings |= LIBRAW_WARN_FALLBACK_TO_AHD;",
          "4626:       SET_PROC_FLAG(LIBRAW_PROGRESS_INTERPOLATE);",
          "4627:     }",
          "4628:     if (IO.mix_green)",
          "4629:     {",
          "4630:       for (P1.colors = 3, i = 0; i < S.height * S.width; i++)",
          "4631:         imgdata.image[i][1] = (imgdata.image[i][1] + imgdata.image[i][3]) >> 1;",
          "4632:       SET_PROC_FLAG(LIBRAW_PROGRESS_MIX_GREEN);",
          "4633:     }",
          "4635:     if (!P1.is_foveon)",
          "4636:     {",
          "4637:       if (P1.colors == 3)",
          "4640:         if (quality == 8)",
          "4641:         {",
          "4642:           if (eeci_refine_fl == 1)",
          "4643:             refinement();",
          "4644:           if (O.med_passes > 0)",
          "4645:             median_filter_new();",
          "4646:           if (es_med_passes_fl > 0)",
          "4647:             es_median_filter();",
          "4648:         }",
          "4649:         else",
          "4650:         {",
          "4651:           median_filter();",
          "4652:         }",
          "4653:         SET_PROC_FLAG(LIBRAW_PROGRESS_MEDIAN_FILTER);",
          "4655:     }",
          "4658:     {",
          "4659:       blend_highlights();",
          "4660:       SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);",
          "4661:     }",
          "4664:     {",
          "4665:       recover_highlights();",
          "4666:       SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);",
          "4667:     }",
          "4670:     {",
          "4671:       fuji_rotate();",
          "4672:       SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE);",
          "4673:     }",
          "4675:     if (!libraw_internal_data.output_data.histogram)",
          "4676:     {",
          "4677:       libraw_internal_data.output_data.histogram =",
          "4678:           (int(*)[LIBRAW_HISTOGRAM_SIZE])malloc(sizeof(*libraw_internal_data.output_data.histogram) * 4);",
          "4679:       merror(libraw_internal_data.output_data.histogram, \"LibRaw::dcraw_process()\");",
          "4680:     }",
          "4682:     if (O.camera_profile)",
          "4683:     {",
          "4684:       apply_profile(O.camera_profile, O.output_profile);",
          "4685:       SET_PROC_FLAG(LIBRAW_PROGRESS_APPLY_PROFILE);",
          "4686:     }",
          "4693:     {",
          "4694:       stretch();",
          "4695:       SET_PROC_FLAG(LIBRAW_PROGRESS_STRETCH);",
          "4696:     }",
          "4701:   catch (LibRaw_exceptions err)",
          "4702:   {",
          "4708: static const char *static_camera_list[] = {\"Adobe Digital Negative (DNG)\",",
          "4709:                                            \"AgfaPhoto DC-833m\",",
          "4710:                                            \"Alcatel 5035D\",",
          "4711:                                            \"Apple iPad Pro\",",
          "4712:                                            \"Apple iPhone SE\",",
          "4713:                                            \"Apple iPhone 6s\",",
          "4714:                                            \"Apple iPhone 6 plus\",",
          "4715:                                            \"Apple iPhone 7\",",
          "4716:                                            \"Apple iPhone 7 plus\",",
          "4717:                                            \"Apple QuickTake 100\",",
          "4718:                                            \"Apple QuickTake 150\",",
          "4719:                                            \"Apple QuickTake 200\",",
          "4720:                                            \"ARRIRAW format\",",
          "4721:                                            \"AVT F-080C\",",
          "4722:                                            \"AVT F-145C\",",
          "4723:                                            \"AVT F-201C\",",
          "4724:                                            \"AVT F-510C\",",
          "4725:                                            \"AVT F-810C\",",
          "4726:                                            \"Baumer TXG14\",",
          "4727:                                            \"BlackMagic Cinema Camera\",",
          "4728:                                            \"BlackMagic Micro Cinema Camera\",",
          "4729:                                            \"BlackMagic Pocket Cinema Camera\",",
          "4730:                                            \"BlackMagic Production Camera 4k\",",
          "4731:                                            \"BlackMagic URSA\",",
          "4732:                                            \"BlackMagic URSA Mini\",",
          "4733:                                            \"Canon PowerShot 600\",",
          "4734:                                            \"Canon PowerShot A5\",",
          "4735:                                            \"Canon PowerShot A5 Zoom\",",
          "4736:                                            \"Canon PowerShot A50\",",
          "4737:                                            \"Canon PowerShot A460 (CHDK hack)\",",
          "4738:                                            \"Canon PowerShot A470 (CHDK hack)\",",
          "4739:                                            \"Canon PowerShot A530 (CHDK hack)\",",
          "4740:                                            \"Canon PowerShot A550 (CHDK hack)\",",
          "4741:                                            \"Canon PowerShot A570 (CHDK hack)\",",
          "4742:                                            \"Canon PowerShot A590 (CHDK hack)\",",
          "4743:                                            \"Canon PowerShot A610 (CHDK hack)\",",
          "4744:                                            \"Canon PowerShot A620 (CHDK hack)\",",
          "4745:                                            \"Canon PowerShot A630 (CHDK hack)\",",
          "4746:                                            \"Canon PowerShot A640 (CHDK hack)\",",
          "4747:                                            \"Canon PowerShot A650 (CHDK hack)\",",
          "4748:                                            \"Canon PowerShot A710 IS (CHDK hack)\",",
          "4749:                                            \"Canon PowerShot A720 IS (CHDK hack)\",",
          "4750:                                            \"Canon PowerShot A3300 IS (CHDK hack)\",",
          "4751:                                            \"Canon PowerShot Pro70\",",
          "4752:                                            \"Canon PowerShot Pro90 IS\",",
          "4753:                                            \"Canon PowerShot Pro1\",",
          "4754:                                            \"Canon PowerShot G1\",",
          "4755:                                            \"Canon PowerShot G1 X\",",
          "4756:                                            \"Canon PowerShot G1 X Mark II\",",
          "4757:                                            \"Canon PowerShot G2\",",
          "4758:                                            \"Canon PowerShot G3\",",
          "4759:                                            \"Canon PowerShot G3 X\",",
          "4760:                                            \"Canon PowerShot G5\",",
          "4761:                                            \"Canon PowerShot G5 X\",",
          "4762:                                            \"Canon PowerShot G6\",",
          "4763:                                            \"Canon PowerShot G7 (CHDK hack)\",",
          "4764:                                            \"Canon PowerShot G7 X\",",
          "4765:                                            \"Canon PowerShot G7 X Mark II\",",
          "4766:                                            \"Canon PowerShot G9\",",
          "4767:                                            \"Canon PowerShot G9 X\",",
          "4768:                                            \"Canon PowerShot G10\",",
          "4769:                                            \"Canon PowerShot G11\",",
          "4770:                                            \"Canon PowerShot G12\",",
          "4771:                                            \"Canon PowerShot G15\",",
          "4772:                                            \"Canon PowerShot G16\",",
          "4773:                                            \"Canon PowerShot S2 IS (CHDK hack)\",",
          "4774:                                            \"Canon PowerShot S3 IS (CHDK hack)\",",
          "4775:                                            \"Canon PowerShot S5 IS (CHDK hack)\",",
          "4776:                                            \"Canon PowerShot SD300 (CHDK hack)\",",
          "4777:                                            \"Canon PowerShot SD950 (CHDK hack)\",",
          "4778:                                            \"Canon PowerShot S30\",",
          "4779:                                            \"Canon PowerShot S40\",",
          "4780:                                            \"Canon PowerShot S45\",",
          "4781:                                            \"Canon PowerShot S50\",",
          "4782:                                            \"Canon PowerShot S60\",",
          "4783:                                            \"Canon PowerShot S70\",",
          "4784:                                            \"Canon PowerShot S90\",",
          "4785:                                            \"Canon PowerShot S95\",",
          "4786:                                            \"Canon PowerShot S100\",",
          "4787:                                            \"Canon PowerShot S110\",",
          "4788:                                            \"Canon PowerShot S120\",",
          "4789:                                            \"Canon PowerShot SX1 IS\",",
          "4790:                                            \"Canon PowerShot SX50 HS\",",
          "4791:                                            \"Canon PowerShot SX60 HS\",",
          "4792:                                            \"Canon PowerShot SX110 IS (CHDK hack)\",",
          "4793:                                            \"Canon PowerShot SX120 IS (CHDK hack)\",",
          "4794:                                            \"Canon PowerShot SX220 HS (CHDK hack)\",",
          "4795:                                            \"Canon PowerShot SX20 IS (CHDK hack)\",",
          "4796:                                            \"Canon PowerShot SX30 IS (CHDK hack)\",",
          "4797:                                            \"Canon PowerShot IXUS 160 (CHDK hack)\",",
          "4798:                                            \"Canon EOS D30\",",
          "4799:                                            \"Canon EOS D60\",",
          "4800:                                            \"Canon EOS 5D\",",
          "4801:                                            \"Canon EOS 5DS\",",
          "4802:                                            \"Canon EOS 5DS R\",",
          "4803:                                            \"Canon EOS 5D Mark II\",",
          "4804:                                            \"Canon EOS 5D Mark III\",",
          "4805:                                            \"Canon EOS 5D Mark IV\",",
          "4806:                                            \"Canon EOS 6D\",",
          "4807:                                            \"Canon EOS 7D\",",
          "4808:                                            \"Canon EOS 7D Mark II\",",
          "4809:                                            \"Canon EOS 10D\",",
          "4810:                                            \"Canon EOS 20D\",",
          "4811:                                            \"Canon EOS 20Da\",",
          "4812:                                            \"Canon EOS 30D\",",
          "4813:                                            \"Canon EOS 40D\",",
          "4814:                                            \"Canon EOS 50D\",",
          "4815:                                            \"Canon EOS 60D\",",
          "4816:                                            \"Canon EOS 60Da\",",
          "4817:                                            \"Canon EOS 70D\",",
          "4818:                                            \"Canon EOS 80D\",",
          "4819:                                            \"Canon EOS 300D / Digital Rebel / Kiss Digital\",",
          "4820:                                            \"Canon EOS 350D / Digital Rebel XT / Kiss Digital N\",",
          "4821:                                            \"Canon EOS 400D / Digital Rebel XTi / Kiss Digital X\",",
          "4822:                                            \"Canon EOS 450D / Digital Rebel XSi / Kiss Digital X2\",",
          "4823:                                            \"Canon EOS 500D / Digital Rebel T1i / Kiss Digital X3\",",
          "4824:                                            \"Canon EOS 550D / Digital Rebel T2i / Kiss Digital X4\",",
          "4825:                                            \"Canon EOS 600D / Digital Rebel T3i / Kiss Digital X5\",",
          "4826:                                            \"Canon EOS 650D / Digital Rebel T4i / Kiss Digital X6i\",",
          "4827:                                            \"Canon EOS 700D / Digital Rebel T5i\",",
          "4828:                                            \"Canon EOS 750D / Digital Rebel T6i\",",
          "4829:                                            \"Canon EOS 760D / Digital Rebel T6S\",",
          "4830:                                            \"Canon EOS 100D / Digital Rebel SL1\",",
          "4831:                                            \"Canon EOS 1000D / Digital Rebel XS / Kiss Digital F\",",
          "4832:                                            \"Canon EOS 1100D / Digital Rebel T3 / Kiss Digital X50\",",
          "4833:                                            \"Canon EOS 1200D\",",
          "4834:                                            \"Canon EOS 1300D\",",
          "4835:                                            \"Canon EOS C500\",",
          "4836:                                            \"Canon EOS D2000C\",",
          "4837:                                            \"Canon EOS M\",",
          "4838:                                            \"Canon EOS M2\",",
          "4839:                                            \"Canon EOS M3\",",
          "4840:                                            \"Canon EOS M5\",",
          "4841:                                            \"Canon EOS M10\",",
          "4842:                                            \"Canon EOS-1D\",",
          "4843:                                            \"Canon EOS-1DS\",",
          "4844:                                            \"Canon EOS-1D C\",",
          "4845:                                            \"Canon EOS-1D X\",",
          "4846:                                            \"Canon EOS-1D Mark II\",",
          "4847:                                            \"Canon EOS-1D Mark II N\",",
          "4848:                                            \"Canon EOS-1D Mark III\",",
          "4849:                                            \"Canon EOS-1D Mark IV\",",
          "4850:                                            \"Canon EOS-1Ds Mark II\",",
          "4851:                                            \"Canon EOS-1Ds Mark III\",",
          "4852:                                            \"Canon EOS-1D X Mark II\",",
          "4853:                                            \"Casio QV-2000UX\",",
          "4854:                                            \"Casio QV-3000EX\",",
          "4855:                                            \"Casio QV-3500EX\",",
          "4856:                                            \"Casio QV-4000\",",
          "4857:                                            \"Casio QV-5700\",",
          "4858:                                            \"Casio QV-R41\",",
          "4859:                                            \"Casio QV-R51\",",
          "4860:                                            \"Casio QV-R61\",",
          "4861:                                            \"Casio EX-F1\",",
          "4862:                                            \"Casio EX-FC300S\",",
          "4863:                                            \"Casio EX-FC400S\",",
          "4864:                                            \"Casio EX-FH20\",",
          "4865:                                            \"Casio EX-FH25\",",
          "4866:                                            \"Casio EX-FH100\",",
          "4867:                                            \"Casio EX-S20\",",
          "4868:                                            \"Casio EX-S100\",",
          "4869:                                            \"Casio EX-Z4\",",
          "4870:                                            \"Casio EX-Z50\",",
          "4871:                                            \"Casio EX-Z500\",",
          "4872:                                            \"Casio EX-Z55\",",
          "4873:                                            \"Casio EX-Z60\",",
          "4874:                                            \"Casio EX-Z75\",",
          "4875:                                            \"Casio EX-Z750\",",
          "4876:                                            \"Casio EX-Z8\",",
          "4877:                                            \"Casio EX-Z850\",",
          "4878:                                            \"Casio EX-Z1050\",",
          "4879:                                            \"Casio EX-ZR100\",",
          "4880:                                            \"Casio EX-Z1080\",",
          "4881:                                            \"Casio EX-ZR700\",",
          "4882:                                            \"Casio EX-ZR710\",",
          "4883:                                            \"Casio EX-ZR750\",",
          "4884:                                            \"Casio EX-ZR800\",",
          "4885:                                            \"Casio EX-ZR850\",",
          "4886:                                            \"Casio EX-ZR1000\",",
          "4887:                                            \"Casio EX-ZR1100\",",
          "4888:                                            \"Casio EX-ZR1200\",",
          "4889:                                            \"Casio EX-ZR1300\",",
          "4890:                                            \"Casio EX-ZR1500\",",
          "4891:                                            \"Casio EX-ZR3000\",",
          "4892:                                            \"Casio EX-ZR4000/5000\",",
          "4893:                                            \"Casio EX-100\",",
          "4894:                                            \"Casio EX-100F\",",
          "4895:                                            \"Casio EX-10\",",
          "4896:                                            \"Casio Exlim Pro 505\",",
          "4897:                                            \"Casio Exlim Pro 600\",",
          "4898:                                            \"Casio Exlim Pro 700\",",
          "4899:                                            \"Contax N Digital\",",
          "4900:                                            \"Creative PC-CAM 600\",",
          "4901:                                            \"Digital Bolex D16\",",
          "4902:                                            \"Digital Bolex D16M\",",
          "4903:                                            \"DJI 4384x3288\",",
          "4904:                                            \"DXO One\",",
          "4905:                                            \"Epson R-D1\",",
          "4906:                                            \"Epson R-D1s\",",
          "4907:                                            \"Epson R-D1x\",",
          "4908:                                            \"Foculus 531C\",",
          "4909:                                            \"FujiFilm E505\",",
          "4910:                                            \"FujiFilm E550\",",
          "4911:                                            \"FujiFilm E900\",",
          "4912:                                            \"FujiFilm F700\",",
          "4913:                                            \"FujiFilm F710\",",
          "4914:                                            \"FujiFilm F800\",",
          "4915:                                            \"FujiFilm F810\",",
          "4916:                                            \"FujiFilm S2Pro\",",
          "4917:                                            \"FujiFilm S3Pro\",",
          "4918:                                            \"FujiFilm S5Pro\",",
          "4919:                                            \"FujiFilm S20Pro\",",
          "4920:                                            \"FujiFilm S1\",",
          "4921:                                            \"FujiFilm S100FS\",",
          "4922:                                            \"FujiFilm S5000\",",
          "4923:                                            \"FujiFilm S5100/S5500\",",
          "4924:                                            \"FujiFilm S5200/S5600\",",
          "4925:                                            \"FujiFilm S6000fd\",",
          "4926:                                            \"FujiFilm S7000\",",
          "4927:                                            \"FujiFilm S9000/S9500\",",
          "4928:                                            \"FujiFilm S9100/S9600\",",
          "4929:                                            \"FujiFilm S200EXR\",",
          "4930:                                            \"FujiFilm S205EXR\",",
          "4931:                                            \"FujiFilm SL1000\",",
          "4932:                                            \"FujiFilm HS10/HS11\",",
          "4933:                                            \"FujiFilm HS20EXR\",",
          "4934:                                            \"FujiFilm HS22EXR\",",
          "4935:                                            \"FujiFilm HS30EXR\",",
          "4936:                                            \"FujiFilm HS33EXR\",",
          "4937:                                            \"FujiFilm HS35EXR\",",
          "4938:                                            \"FujiFilm HS50EXR\",",
          "4939:                                            \"FujiFilm F505EXR\",",
          "4940:                                            \"FujiFilm F550EXR\",",
          "4941:                                            \"FujiFilm F600EXR\",",
          "4942:                                            \"FujiFilm F605EXR\",",
          "4943:                                            \"FujiFilm F770EXR\",",
          "4944:                                            \"FujiFilm F775EXR\",",
          "4945:                                            \"FujiFilm F800EXR\",",
          "4946:                                            \"FujiFilm F900EXR\",",
          "4947:                                            \"FujiFilm X-Pro1\",",
          "4948:                                            \"FujiFilm X-Pro2\",",
          "4949:                                            \"FujiFilm X-S1\",",
          "4950:                                            \"FujiFilm XQ1\",",
          "4951:                                            \"FujiFilm XQ2\",",
          "4952:                                            \"FujiFilm X100\",",
          "4953:                                            \"FujiFilm X100S\",",
          "4954:                                            \"FujiFilm X100T\",",
          "4955:                                            \"FujiFilm X10\",",
          "4956:                                            \"FujiFilm X20\",",
          "4957:                                            \"FujiFilm X30\",",
          "4958:                                            \"FujiFilm X70\",",
          "4959:                                            \"FujiFilm X-A1\",",
          "4960:                                            \"FujiFilm X-A2\",",
          "4961:                                            \"FujiFilm X-E1\",",
          "4962:                                            \"FujiFilm X-E2\",",
          "4963:                                            \"FujiFilm X-E2S\",",
          "4964:                                            \"FujiFilm X-M1\",",
          "4965:                                            \"FujiFilm XF1\",",
          "4966:                                            \"FujiFilm X-T1\",",
          "4967:                                            \"FujiFilm X-T1 Graphite Silver\",",
          "4968:                                            \"FujiFilm X-T2\",",
          "4969:                                            \"FujiFilm X-T10\",",
          "4970:                                            \"FujiFilm IS-1\",",
          "4971:                                            \"Gione E7\",",
          "4972:                                            \"GITUP GIT2\",",
          "4973:                                            \"Google Pixel\",",
          "4974:                                            \"Google Pixel XL\",",
          "4975:                                            \"Hasselblad H5D-60\",",
          "4976:                                            \"Hasselblad H5D-50\",",
          "4977:                                            \"Hasselblad H5D-50c\",",
          "4978:                                            \"Hasselblad H5D-40\",",
          "4979:                                            \"Hasselblad H4D-60\",",
          "4980:                                            \"Hasselblad H4D-50\",",
          "4981:                                            \"Hasselblad H4D-40\",",
          "4982:                                            \"Hasselblad H4D-31\",",
          "4983:                                            \"Hasselblad H3DII-22\",",
          "4984:                                            \"Hasselblad H3DII-31\",",
          "4985:                                            \"Hasselblad H3DII-39\",",
          "4986:                                            \"Hasselblad H3DII-50\",",
          "4987:                                            \"Hasselblad H3D-22\",",
          "4988:                                            \"Hasselblad H3D-31\",",
          "4989:                                            \"Hasselblad H3D-39\",",
          "4990:                                            \"Hasselblad H2D-22\",",
          "4991:                                            \"Hasselblad H2D-39\",",
          "4992:                                            \"Hasselblad CFV\",",
          "4993:                                            \"Hasselblad CFH\",",
          "4994:                                            \"Hasselblad CF-22\",",
          "4995:                                            \"Hasselblad CF-31\",",
          "4996:                                            \"Hasselblad CF-39\",",
          "4997:                                            \"Hasselblad V96C\",",
          "4998:                                            \"Hasselblad Lusso\",",
          "4999:                                            \"Hasselblad Lunar\",",
          "5000:                                            \"Hasselblad True Zoom\",",
          "5001:                                            \"Hasselblad Stellar\",",
          "5002:                                            \"Hasselblad Stellar II\",",
          "5003:                                            \"Hasselblad HV\",",
          "5004:                                            \"Hasselblad X1D\",",
          "5005:                                            \"HTC UltraPixel\",",
          "5006:                                            \"HTC MyTouch 4G\",",
          "5007:                                            \"HTC One (A9)\",",
          "5008:                                            \"HTC One (M9)\",",
          "5009:                                            \"HTC 10\",",
          "5010:                                            \"Huawei P9\",",
          "5011:                                            \"Imacon Ixpress 96, 96C\",",
          "5012:                                            \"Imacon Ixpress 384, 384C (single shot only)\",",
          "5013:                                            \"Imacon Ixpress 132C\",",
          "5014:                                            \"Imacon Ixpress 528C (single shot only)\",",
          "5015:                                            \"ISG 2020x1520\",",
          "5016:                                            \"Ikonoskop A-Cam dII Panchromatic\",",
          "5017:                                            \"Ikonoskop A-Cam dII\",",
          "5018:                                            \"Kinefinity KineMINI\",",
          "5019:                                            \"Kinefinity KineRAW Mini\",",
          "5020:                                            \"Kinefinity KineRAW S35\",",
          "5021:                                            \"Kodak DC20\",",
          "5022:                                            \"Kodak DC25\",",
          "5023:                                            \"Kodak DC40\",",
          "5024:                                            \"Kodak DC50\",",
          "5025:                                            \"Kodak DC120\",",
          "5026:                                            \"Kodak DCS200\",",
          "5027:                                            \"Kodak DCS315C\",",
          "5028:                                            \"Kodak DCS330C\",",
          "5029:                                            \"Kodak DCS420\",",
          "5030:                                            \"Kodak DCS460\",",
          "5031:                                            \"Kodak DCS460A\",",
          "5032:                                            \"Kodak DCS460D\",",
          "5033:                                            \"Kodak DCS520C\",",
          "5034:                                            \"Kodak DCS560C\",",
          "5035:                                            \"Kodak DCS620C\",",
          "5036:                                            \"Kodak DCS620X\",",
          "5037:                                            \"Kodak DCS660C\",",
          "5038:                                            \"Kodak DCS660M\",",
          "5039:                                            \"Kodak DCS720X\",",
          "5040:                                            \"Kodak DCS760C\",",
          "5041:                                            \"Kodak DCS760M\",",
          "5042:                                            \"Kodak EOSDCS1\",",
          "5043:                                            \"Kodak EOSDCS3B\",",
          "5044:                                            \"Kodak NC2000F\",",
          "5045:                                            \"Kodak ProBack\",",
          "5046:                                            \"Kodak PB645C\",",
          "5047:                                            \"Kodak PB645H\",",
          "5048:                                            \"Kodak PB645M\",",
          "5049:                                            \"Kodak DCS Pro 14n\",",
          "5050:                                            \"Kodak DCS Pro 14nx\",",
          "5051:                                            \"Kodak DCS Pro SLR/c\",",
          "5052:                                            \"Kodak DCS Pro SLR/n\",",
          "5053:                                            \"Kodak C330\",",
          "5054:                                            \"Kodak C603\",",
          "5055:                                            \"Kodak P850\",",
          "5056:                                            \"Kodak P880\",",
          "5057:                                            \"Kodak S-1\",",
          "5058:                                            \"Kodak Z980\",",
          "5059:                                            \"Kodak Z981\",",
          "5060:                                            \"Kodak Z990\",",
          "5061:                                            \"Kodak Z1015\",",
          "5062:                                            \"Kodak KAI-0340\",",
          "5063:                                            \"Konica KD-400Z\",",
          "5064:                                            \"Konica KD-510Z\",",
          "5065:                                            \"Leaf AFi 5\",",
          "5066:                                            \"Leaf AFi 6\",",
          "5067:                                            \"Leaf AFi 7\",",
          "5068:                                            \"Leaf AFi-II 6\",",
          "5069:                                            \"Leaf AFi-II 7\",",
          "5070:                                            \"Leaf AFi-II 10\",",
          "5071:                                            \"Leaf AFi-II 10R\",",
          "5072:                                            \"Leaf Aptus-II 5\",",
          "5073:                                            \"Leaf Aptus-II 6\",",
          "5074:                                            \"Leaf Aptus-II 7\",",
          "5075:                                            \"Leaf Aptus-II 8\",",
          "5076:                                            \"Leaf Aptus-II 10\",",
          "5077:                                            \"Leaf Aptus-II 12\",",
          "5078:                                            \"Leaf Aptus-II 12R\",",
          "5079:                                            \"Leaf Aptus 17\",",
          "5080:                                            \"Leaf Aptus 22\",",
          "5081:                                            \"Leaf Aptus 54S\",",
          "5082:                                            \"Leaf Aptus 65\",",
          "5083:                                            \"Leaf Aptus 65S\",",
          "5084:                                            \"Leaf Aptus 75\",",
          "5085:                                            \"Leaf Aptus 75S\",",
          "5086:                                            \"Leaf Cantare\",",
          "5087:                                            \"Leaf Cantare XY\",",
          "5088:                                            \"Leaf CatchLight\",",
          "5089:                                            \"Leaf CMost\",",
          "5090:                                            \"Leaf Credo 40\",",
          "5091:                                            \"Leaf Credo 50\",",
          "5092:                                            \"Leaf Credo 60\",",
          "5093:                                            \"Leaf Credo 80 (low compression mode only)\",",
          "5094:                                            \"Leaf DCB-II\",",
          "5095:                                            \"Leaf Valeo 6\",",
          "5096:                                            \"Leaf Valeo 11\",",
          "5097:                                            \"Leaf Valeo 17\",",
          "5098:                                            \"Leaf Valeo 17wi\",",
          "5099:                                            \"Leaf Valeo 22\",",
          "5100:                                            \"Leaf Valeo 22wi\",",
          "5101:                                            \"Leaf Volare\",",
          "5102:                                            \"Lenovo a820\",",
          "5103:                                            \"Leica C (Typ 112)\",",
          "5104:                                            \"Leica Digilux 2\",",
          "5105:                                            \"Leica Digilux 3\",",
          "5106:                                            \"Leica Digital-Modul-R\",",
          "5107:                                            \"Leica D-LUX2\",",
          "5108:                                            \"Leica D-LUX3\",",
          "5109:                                            \"Leica D-LUX4\",",
          "5110:                                            \"Leica D-LUX5\",",
          "5111:                                            \"Leica D-LUX6\",",
          "5112:                                            \"Leica D-Lux (Typ 109)\",",
          "5113:                                            \"Leica M8\",",
          "5114:                                            \"Leica M8.2\",",
          "5115:                                            \"Leica M9\",",
          "5116:                                            \"Leica M (Typ 240)\",",
          "5117:                                            \"Leica M (Typ 262)\",",
          "5118:                                            \"Leica Monochrom (Typ 240)\",",
          "5119:                                            \"Leica Monochrom (Typ 246)\",",
          "5120:                                            \"Leica M-D (Typ 262)\",",
          "5121:                                            \"Leica M-E\",",
          "5122:                                            \"Leica M-P\",",
          "5123:                                            \"Leica R8\",",
          "5124:                                            \"Leica Q (Typ 116)\",",
          "5125:                                            \"Leica S\",",
          "5126:                                            \"Leica S2\",",
          "5127:                                            \"Leica S (Typ 007)\",",
          "5128:                                            \"Leica SL (Typ 601)\",",
          "5129:                                            \"Leica T (Typ 701)\",",
          "5130:                                            \"Leica TL\",",
          "5131:                                            \"Leica X1\",",
          "5132:                                            \"Leica X (Typ 113)\",",
          "5133:                                            \"Leica X2\",",
          "5134:                                            \"Leica X-E (Typ 102)\",",
          "5135:                                            \"Leica X-U (Typ 113)\",",
          "5136:                                            \"Leica V-LUX1\",",
          "5137:                                            \"Leica V-LUX2\",",
          "5138:                                            \"Leica V-LUX3\",",
          "5139:                                            \"Leica V-LUX4\",",
          "5140:                                            \"Leica V-Lux (Typ 114)\",",
          "5141:                                            \"Leica X VARIO (Typ 107)\",",
          "5142:                                            \"LG G3\",",
          "5143:                                            \"LG G4\",",
          "5144:                                            \"Logitech Fotoman Pixtura\",",
          "5145:                                            \"Mamiya ZD\",",
          "5146:                                            \"Matrix 4608x3288\",",
          "5147:                                            \"Meizy MX4\",",
          "5148:                                            \"Micron 2010\",",
          "5149:                                            \"Minolta RD175\",",
          "5150:                                            \"Minolta DiMAGE 5\",",
          "5151:                                            \"Minolta DiMAGE 7\",",
          "5152:                                            \"Minolta DiMAGE 7i\",",
          "5153:                                            \"Minolta DiMAGE 7Hi\",",
          "5154:                                            \"Minolta DiMAGE A1\",",
          "5155:                                            \"Minolta DiMAGE A2\",",
          "5156:                                            \"Minolta DiMAGE A200\",",
          "5157:                                            \"Minolta DiMAGE G400\",",
          "5158:                                            \"Minolta DiMAGE G500\",",
          "5159:                                            \"Minolta DiMAGE G530\",",
          "5160:                                            \"Minolta DiMAGE G600\",",
          "5161:                                            \"Minolta DiMAGE Z2\",",
          "5162:                                            \"Minolta Alpha/Dynax/Maxxum 5D\",",
          "5163:                                            \"Minolta Alpha/Dynax/Maxxum 7D\",",
          "5164:                                            \"Motorola PIXL\",",
          "5165:                                            \"Nikon D1\",",
          "5166:                                            \"Nikon D1H\",",
          "5167:                                            \"Nikon D1X\",",
          "5168:                                            \"Nikon D2H\",",
          "5169:                                            \"Nikon D2Hs\",",
          "5170:                                            \"Nikon D2X\",",
          "5171:                                            \"Nikon D2Xs\",",
          "5172:                                            \"Nikon D3\",",
          "5173:                                            \"Nikon D3s\",",
          "5174:                                            \"Nikon D3X\",",
          "5175:                                            \"Nikon D4\",",
          "5176:                                            \"Nikon D4s\",",
          "5177:                                            \"Nikon D40\",",
          "5178:                                            \"Nikon D40X\",",
          "5179:                                            \"Nikon D5\",",
          "5180:                                            \"Nikon D50\",",
          "5181:                                            \"Nikon D60\",",
          "5182:                                            \"Nikon D70\",",
          "5183:                                            \"Nikon D70s\",",
          "5184:                                            \"Nikon D80\",",
          "5185:                                            \"Nikon D90\",",
          "5186:                                            \"Nikon D100\",",
          "5187:                                            \"Nikon D200\",",
          "5188:                                            \"Nikon D300\",",
          "5189:                                            \"Nikon D300s\",",
          "5190:                                            \"Nikon D500\",",
          "5191:                                            \"Nikon D600\",",
          "5192:                                            \"Nikon D610\",",
          "5193:                                            \"Nikon D700\",",
          "5194:                                            \"Nikon D750\",",
          "5195:                                            \"Nikon D800\",",
          "5196:                                            \"Nikon D800E\",",
          "5197:                                            \"Nikon D810\",",
          "5198:                                            \"Nikon D810A\",",
          "5199:                                            \"Nikon D3000\",",
          "5200:                                            \"Nikon D3100\",",
          "5201:                                            \"Nikon D3200\",",
          "5202:                                            \"Nikon D3300\",",
          "5203:                                            \"Nikon D3400\",",
          "5204:                                            \"Nikon D5000\",",
          "5205:                                            \"Nikon D5100\",",
          "5206:                                            \"Nikon D5200\",",
          "5207:                                            \"Nikon D5300\",",
          "5208:                                            \"Nikon D5500\",",
          "5209:                                            \"Nikon D7000\",",
          "5210:                                            \"Nikon D7100\",",
          "5211:                                            \"Nikon D7200\",",
          "5212:                                            \"Nikon Df\",",
          "5213:                                            \"Nikon 1 AW1\",",
          "5214:                                            \"Nikon 1 J1\",",
          "5215:                                            \"Nikon 1 J2\",",
          "5216:                                            \"Nikon 1 J3\",",
          "5217:                                            \"Nikon 1 J4\",",
          "5218:                                            \"Nikon 1 J5\",",
          "5219:                                            \"Nikon 1 S1\",",
          "5220:                                            \"Nikon 1 S2\",",
          "5221:                                            \"Nikon 1 V1\",",
          "5222:                                            \"Nikon 1 V2\",",
          "5223:                                            \"Nikon 1 V3\",",
          "5224:                                            \"Nikon E700 (\\\"DIAG RAW\\\" hack)\",",
          "5225:                                            \"Nikon E800 (\\\"DIAG RAW\\\" hack)\",",
          "5226:                                            \"Nikon E880 (\\\"DIAG RAW\\\" hack)\",",
          "5227:                                            \"Nikon E900 (\\\"DIAG RAW\\\" hack)\",",
          "5228:                                            \"Nikon E950 (\\\"DIAG RAW\\\" hack)\",",
          "5229:                                            \"Nikon E990 (\\\"DIAG RAW\\\" hack)\",",
          "5230:                                            \"Nikon E995 (\\\"DIAG RAW\\\" hack)\",",
          "5231:                                            \"Nikon E2100 (\\\"DIAG RAW\\\" hack)\",",
          "5232:                                            \"Nikon E2500 (\\\"DIAG RAW\\\" hack)\",",
          "5233:                                            \"Nikon E3200 (\\\"DIAG RAW\\\" hack)\",",
          "5234:                                            \"Nikon E3700 (\\\"DIAG RAW\\\" hack)\",",
          "5235:                                            \"Nikon E4300 (\\\"DIAG RAW\\\" hack)\",",
          "5236:                                            \"Nikon E4500 (\\\"DIAG RAW\\\" hack)\",",
          "5237:                                            \"Nikon E5000\",",
          "5238:                                            \"Nikon E5400\",",
          "5239:                                            \"Nikon E5700\",",
          "5240:                                            \"Nikon E8400\",",
          "5241:                                            \"Nikon E8700\",",
          "5242:                                            \"Nikon E8800\",",
          "5243:                                            \"Nikon Coolpix A\",",
          "5244:                                            \"Nikon Coolpix P330\",",
          "5245:                                            \"Nikon Coolpix P340\",",
          "5246:                                            \"Nikon Coolpix P6000\",",
          "5247:                                            \"Nikon Coolpix P7000\",",
          "5248:                                            \"Nikon Coolpix P7100\",",
          "5249:                                            \"Nikon Coolpix P7700\",",
          "5250:                                            \"Nikon Coolpix P7800\",",
          "5251:                                            \"Nikon Coolpix S6 (\\\"DIAG RAW\\\" hack)\",",
          "5252:                                            \"Nikon Coolscan NEF\",",
          "5253:                                            \"Nokia N95\",",
          "5254:                                            \"Nokia X2\",",
          "5255:                                            \"Nokia 1200x1600\",",
          "5256:                                            \"Nokia Lumia 950 XL\",",
          "5257:                                            \"Nokia Lumia 1020\",",
          "5258:                                            \"Nokia Lumia 1520\",",
          "5259:                                            \"Olympus AIR A01\",",
          "5260:                                            \"Olympus C3030Z\",",
          "5261:                                            \"Olympus C5050Z\",",
          "5262:                                            \"Olympus C5060Z\",",
          "5263:                                            \"Olympus C7070WZ\",",
          "5264:                                            \"Olympus C70Z,C7000Z\",",
          "5265:                                            \"Olympus C740UZ\",",
          "5266:                                            \"Olympus C770UZ\",",
          "5267:                                            \"Olympus C8080WZ\",",
          "5268:                                            \"Olympus X200,D560Z,C350Z\",",
          "5269:                                            \"Olympus E-1\",",
          "5270:                                            \"Olympus E-3\",",
          "5271:                                            \"Olympus E-5\",",
          "5272:                                            \"Olympus E-10\",",
          "5273:                                            \"Olympus E-20\",",
          "5274:                                            \"Olympus E-30\",",
          "5275:                                            \"Olympus E-300\",",
          "5276:                                            \"Olympus E-330\",",
          "5277:                                            \"Olympus E-400\",",
          "5278:                                            \"Olympus E-410\",",
          "5279:                                            \"Olympus E-420\",",
          "5280:                                            \"Olympus E-450\",",
          "5281:                                            \"Olympus E-500\",",
          "5282:                                            \"Olympus E-510\",",
          "5283:                                            \"Olympus E-520\",",
          "5284:                                            \"Olympus E-600\",",
          "5285:                                            \"Olympus E-620\",",
          "5286:                                            \"Olympus E-P1\",",
          "5287:                                            \"Olympus E-P2\",",
          "5288:                                            \"Olympus E-P3\",",
          "5289:                                            \"Olympus E-P5\",",
          "5290:                                            \"Olympus E-PL1\",",
          "5291:                                            \"Olympus E-PL1s\",",
          "5292:                                            \"Olympus E-PL2\",",
          "5293:                                            \"Olympus E-PL3\",",
          "5294:                                            \"Olympus E-PL5\",",
          "5295:                                            \"Olympus E-PL6\",",
          "5296:                                            \"Olympus E-PL7\",",
          "5297:                                            \"Olympus E-PL8\",",
          "5298:                                            \"Olympus E-PM1\",",
          "5299:                                            \"Olympus E-PM2\",",
          "5300:                                            \"Olympus E-M1\",",
          "5301:                                            \"Olympus E-M1 Mark II\",",
          "5302:                                            \"Olympus E-M10\",",
          "5303:                                            \"Olympus E-M10 Mark II\",",
          "5304:                                            \"Olympus E-M5\",",
          "5305:                                            \"Olympus E-M5 Mark II\",",
          "5306:                                            \"Olympus Pen F\",",
          "5307:                                            \"Olympus SP310\",",
          "5308:                                            \"Olympus SP320\",",
          "5309:                                            \"Olympus SP350\",",
          "5310:                                            \"Olympus SP500UZ\",",
          "5311:                                            \"Olympus SP510UZ\",",
          "5312:                                            \"Olympus SP550UZ\",",
          "5313:                                            \"Olympus SP560UZ\",",
          "5314:                                            \"Olympus SP565UZ\",",
          "5315:                                            \"Olympus SP570UZ\",",
          "5316:                                            \"Olympus STYLUS1\",",
          "5317:                                            \"Olympus STYLUS1s\",",
          "5318:                                            \"Olympus SH-2\",",
          "5319:                                            \"Olympus SH-3\",",
          "5320:                                            \"Olympus TG-4\",",
          "5321:                                            \"Olympus XZ-1\",",
          "5322:                                            \"Olympus XZ-2\",",
          "5323:                                            \"Olympus XZ-10\",",
          "5324:                                            \"OmniVision 4688\",",
          "5325:                                            \"OmniVision OV5647\",",
          "5326:                                            \"OmniVision OV5648\",",
          "5327:                                            \"OmniVision OV8850\",",
          "5328:                                            \"OmniVision 13860\",",
          "5329:                                            \"Panasonic DMC-CM1\",",
          "5330:                                            \"Panasonic DMC-FZ8\",",
          "5331:                                            \"Panasonic DMC-FZ18\",",
          "5332:                                            \"Panasonic DMC-FZ28\",",
          "5333:                                            \"Panasonic DMC-FZ30\",",
          "5334:                                            \"Panasonic DMC-FZ35/FZ38\",",
          "5335:                                            \"Panasonic DMC-FZ40\",",
          "5336:                                            \"Panasonic DMC-FZ50\",",
          "5337:                                            \"Panasonic DMC-FZ7\",",
          "5338:                                            \"Panasonic DMC-FZ70\",",
          "5339:                                            \"Panasonic DMC-FZ100\",",
          "5340:                                            \"Panasonic DMC-FZ150\",",
          "5341:                                            \"Panasonic DMC-FZ200\",",
          "5342:                                            \"Panasonic DMC-FZ300/330\",",
          "5343:                                            \"Panasonic DMC-FZ1000\",",
          "5344:                                            \"Panasonic DMC-FZ2000/2500/FZH1\",",
          "5345:                                            \"Panasonic DMC-FX150\",",
          "5346:                                            \"Panasonic DMC-G1\",",
          "5347:                                            \"Panasonic DMC-G10\",",
          "5348:                                            \"Panasonic DMC-G2\",",
          "5349:                                            \"Panasonic DMC-G3\",",
          "5350:                                            \"Panasonic DMC-G5\",",
          "5351:                                            \"Panasonic DMC-G6\",",
          "5352:                                            \"Panasonic DMC-G7/G70\",",
          "5353:                                            \"Panasonic DMC-G8/80/81/85\",",
          "5354:                                            \"Panasonic DMC-GF1\",",
          "5355:                                            \"Panasonic DMC-GF2\",",
          "5356:                                            \"Panasonic DMC-GF3\",",
          "5357:                                            \"Panasonic DMC-GF5\",",
          "5358:                                            \"Panasonic DMC-GF6\",",
          "5359:                                            \"Panasonic DMC-GF7\",",
          "5360:                                            \"Panasonic DMC-GH1\",",
          "5361:                                            \"Panasonic DMC-GH2\",",
          "5362:                                            \"Panasonic DMC-GH3\",",
          "5363:                                            \"Panasonic DMC-GH4\",",
          "5364:                                            \"Panasonic AG-GH4\",",
          "5365:                                            \"Panasonic DMC-GM1\",",
          "5366:                                            \"Panasonic DMC-GM1s\",",
          "5367:                                            \"Panasonic DMC-GM5\",",
          "5368:                                            \"Panasonic DMC-GX1\",",
          "5369:                                            \"Panasonic DMC-GX7\",",
          "5370:                                            \"Panasonic DMC-GX8\",",
          "5371:                                            \"Panasonic DMC-GX80/85\",",
          "5372:                                            \"Panasonic DMC-L1\",",
          "5373:                                            \"Panasonic DMC-L10\",",
          "5374:                                            \"Panasonic DMC-LC1\",",
          "5375:                                            \"Panasonic DMC-LX1\",",
          "5376:                                            \"Panasonic DMC-LF1\",",
          "5377:                                            \"Panasonic DMC-LX2\",",
          "5378:                                            \"Panasonic DMC-LX3\",",
          "5379:                                            \"Panasonic DMC-LX5\",",
          "5380:                                            \"Panasonic DMC-LX7\",",
          "5381:                                            \"Panasonic DMC-LX9/10/15\",",
          "5382:                                            \"Panasonic DMC-LX100\",",
          "5383:                                            \"Panasonic DMC-TZ60/61/SZ40\",",
          "5384:                                            \"Panasonic DMC-TZ70/71/ZS50\",",
          "5385:                                            \"Panasonic DMC-TZ80/81/85/ZS60\",",
          "5386:                                            \"Panasonic DMC-TZ100/101/ZS100\",",
          "5387:                                            \"Pentax *ist D\",",
          "5388:                                            \"Pentax *ist DL\",",
          "5389:                                            \"Pentax *ist DL2\",",
          "5390:                                            \"Pentax *ist DS\",",
          "5391:                                            \"Pentax *ist DS2\",",
          "5392:                                            \"Pentax GR\",",
          "5393:                                            \"Pentax K10D\",",
          "5394:                                            \"Pentax K20D\",",
          "5395:                                            \"Pentax K100D\",",
          "5396:                                            \"Pentax K100D Super\",",
          "5397:                                            \"Pentax K110D\",",
          "5398:                                            \"Pentax K200D\",",
          "5399:                                            \"Pentax K2000/K-m\",",
          "5400:                                            \"Pentax K-x\",",
          "5401:                                            \"Pentax K-r\",",
          "5402:                                            \"Pentax K-01\",",
          "5403:                                            \"Pentax K-1\",",
          "5404:                                            \"Pentax K-3\",",
          "5405:                                            \"Pentax K-3 II\",",
          "5406:                                            \"Pentax K-30\",",
          "5407:                                            \"Pentax K-5\",",
          "5408:                                            \"Pentax K-5 II\",",
          "5409:                                            \"Pentax K-5 IIs\",",
          "5410:                                            \"Pentax K-50\",",
          "5411:                                            \"Pentax K-500\",",
          "5412:                                            \"Pentax K-7\",",
          "5413:                                            \"Pentax K-70\",",
          "5414:                                            \"Pentax K-S1\",",
          "5415:                                            \"Pentax K-S2\",",
          "5416:                                            \"Pentax MX-1\",",
          "5417:                                            \"Pentax Q\",",
          "5418:                                            \"Pentax Q7\",",
          "5419:                                            \"Pentax Q10\",",
          "5420:                                            \"Pentax QS-1\",",
          "5421:                                            \"Pentax Optio S\",",
          "5422:                                            \"Pentax Optio S4\",",
          "5423:                                            \"Pentax Optio 33WR\",",
          "5424:                                            \"Pentax Optio 750Z\",",
          "5425:                                            \"Pentax 645D\",",
          "5426:                                            \"Pentax 645Z\",",
          "5427:                                            \"PhaseOne IQ140\",",
          "5428:                                            \"PhaseOne IQ150\",",
          "5429:                                            \"PhaseOne IQ160\",",
          "5430:                                            \"PhaseOne IQ180\",",
          "5431:                                            \"PhaseOne IQ180 IR\",",
          "5432:                                            \"PhaseOne IQ250\",",
          "5433:                                            \"PhaseOne IQ260\",",
          "5434:                                            \"PhaseOne IQ260 Achromatic\",",
          "5435:                                            \"PhaseOne IQ280\",",
          "5436:                                            \"PhaseOne IQ3 50MP\",",
          "5437:                                            \"PhaseOne IQ3 60MP\",",
          "5438:                                            \"PhaseOne IQ3 80MP\",",
          "5439:                                            \"PhaseOne IQ3 100MP\",",
          "5440:                                            \"PhaseOne LightPhase\",",
          "5441:                                            \"PhaseOne Achromatic+\",",
          "5442:                                            \"PhaseOne H 10\",",
          "5443:                                            \"PhaseOne H 20\",",
          "5444:                                            \"PhaseOne H 25\",",
          "5445:                                            \"PhaseOne P 20\",",
          "5446:                                            \"PhaseOne P 20+\",",
          "5447:                                            \"PhaseOne P 21\",",
          "5448:                                            \"PhaseOne P 25\",",
          "5449:                                            \"PhaseOne P 25+\",",
          "5450:                                            \"PhaseOne P 30\",",
          "5451:                                            \"PhaseOne P 30+\",",
          "5452:                                            \"PhaseOne P 40+\",",
          "5453:                                            \"PhaseOne P 45\",",
          "5454:                                            \"PhaseOne P 45+\",",
          "5455:                                            \"PhaseOne P 65\",",
          "5456:                                            \"PhaseOne P 65+\",",
          "5457:                                            \"Photron BC2-HD\",",
          "5458:                                            \"Pixelink A782\",",
          "5459:                                            \"Polaroid x530\",",
          "5460:                                            \"RaspberryPi Camera\",",
          "5461:                                            \"RaspberryPi Camera V2\",",
          "5462:                                            \"Ricoh GR\",",
          "5463:                                            \"Ricoh GR Digital\",",
          "5464:                                            \"Ricoh GR Digital II\",",
          "5465:                                            \"Ricoh GR Digital III\",",
          "5466:                                            \"Ricoh GR Digital IV\",",
          "5467:                                            \"Ricoh GR II\",",
          "5468:                                            \"Ricoh GX100\",",
          "5469:                                            \"Ricoh GX200\",",
          "5470:                                            \"Ricoh GXR MOUNT A12\",",
          "5471:                                            \"Ricoh GXR MOUNT A16 24-85mm F3.5-5.5\",",
          "5472:                                            \"Ricoh GXR, S10 24-72mm F2.5-4.4 VC\",",
          "5473:                                            \"Ricoh GXR, GR A12 50mm F2.5 MACRO\",",
          "5474:                                            \"Ricoh GXR, GR LENS A12 28mm F2.5\",",
          "5475:                                            \"Ricoh GXR, GXR P10\",",
          "5477:                                            \"Redcode R3D format\",",
          "5479:                                            \"Rollei d530flex\",",
          "5480:                                            \"RoverShot 3320af\",",
          "5481:                                            \"Samsung EX1\",",
          "5482:                                            \"Samsung EX2F\",",
          "5483:                                            \"Samsung GX-1L\",",
          "5484:                                            \"Samsung GX-1S\",",
          "5485:                                            \"Samsung GX10\",",
          "5486:                                            \"Samsung GX20\",",
          "5487:                                            \"Samsung Galaxy NX (EK-GN120)\",",
          "5488:                                            \"Samsung Galaxy S7 (SM-G935F)\",",
          "5489:                                            \"Samsung NX1\",",
          "5490:                                            \"Samsung NX5\",",
          "5491:                                            \"Samsung NX10\",",
          "5492:                                            \"Samsung NX11\",",
          "5493:                                            \"Samsung NX100\",",
          "5494:                                            \"Samsung NX1000\",",
          "5495:                                            \"Samsung NX1100\",",
          "5496:                                            \"Samsung NX20\",",
          "5497:                                            \"Samsung NX200\",",
          "5498:                                            \"Samsung NX210\",",
          "5499:                                            \"Samsung NX2000\",",
          "5500:                                            \"Samsung NX30\",",
          "5501:                                            \"Samsung NX300\",",
          "5502:                                            \"Samsung NX300M\",",
          "5503:                                            \"Samsung NX3000\",",
          "5504:                                            \"Samsung NX500\",",
          "5505:                                            \"Samsung NX mini\",",
          "5506:                                            \"Samsung Pro815\",",
          "5507:                                            \"Samsung WB550\",",
          "5508:                                            \"Samsung WB2000\",",
          "5509:                                            \"Samsung S85 (hacked)\",",
          "5510:                                            \"Samsung S850 (hacked)\",",
          "5511:                                            \"Samsung Galaxy S3\",",
          "5512:                                            \"Samsung Galaxy S7\",",
          "5513:                                            \"Samsung Galaxy S7 Edge\",",
          "5514:                                            \"Samsung Galaxy Nexus\",",
          "5515:                                            \"Sarnoff 4096x5440\",",
          "5516:                                            \"Seitz 6x17\",",
          "5517:                                            \"Seitz Roundshot D3\",",
          "5518:                                            \"Seitz Roundshot D2X\",",
          "5519:                                            \"Seitz Roundshot D2Xs\",",
          "5520:                                            \"Sigma SD9\",",
          "5521:                                            \"Sigma SD10\",",
          "5522:                                            \"Sigma SD14\",",
          "5523:                                            \"Sigma SD15\",",
          "5524:                                            \"Sigma SD1\",",
          "5525:                                            \"Sigma SD1 Merill\",",
          "5526:                                            \"Sigma DP1\",",
          "5527:                                            \"Sigma DP1 Merill\",",
          "5528:                                            \"Sigma DP1S\",",
          "5529:                                            \"Sigma DP1X\",",
          "5530:                                            \"Sigma DP2\",",
          "5531:                                            \"Sigma DP2 Merill\",",
          "5532:                                            \"Sigma DP2S\",",
          "5533:                                            \"Sigma DP2X\",",
          "5534:                                            \"Sigma DP3 Merill\",",
          "5535:                                            \"Sigma dp0 Quattro\",",
          "5536:                                            \"Sigma dp1 Quattro\",",
          "5537:                                            \"Sigma dp2 Quattro\",",
          "5538:                                            \"Sigma dp3 Quattro\",",
          "5539:                                            \"Sigma sd Quattro\",",
          "5540:                                            \"Sinar eMotion 22\",",
          "5541:                                            \"Sinar eMotion 54\",",
          "5542:                                            \"Sinar eSpirit 65\",",
          "5543:                                            \"Sinar eMotion 75\",",
          "5544:                                            \"Sinar eVolution 75\",",
          "5545:                                            \"Sinar 3072x2048\",",
          "5546:                                            \"Sinar 4080x4080\",",
          "5547:                                            \"Sinar 4080x5440\",",
          "5548:                                            \"Sinar STI format\",",
          "5549:                                            \"Sinar Sinarback 54\",",
          "5550:                                            \"SMaL Ultra-Pocket 3\",",
          "5551:                                            \"SMaL Ultra-Pocket 4\",",
          "5552:                                            \"SMaL Ultra-Pocket 5\",",
          "5553:                                            \"Sony A7\",",
          "5554:                                            \"Sony A7 II\",",
          "5555:                                            \"Sony A7R\",",
          "5556:                                            \"Sony A7R II\",",
          "5557:                                            \"Sony A7S\",",
          "5558:                                            \"Sony A7S II\",",
          "5559:                                            \"Sony ILCA-68 (A68)\",",
          "5560:                                            \"Sony ILCA-77M2 (A77-II)\",",
          "5561:                                            \"Sony ILCA-99M2 (A99-II)\",",
          "5562:                                            \"Sony ILCE-3000\",",
          "5563:                                            \"Sony ILCE-5000\",",
          "5564:                                            \"Sony ILCE-5100\",",
          "5565:                                            \"Sony ILCE-6000\",",
          "5566:                                            \"Sony ILCE-6300\",",
          "5567:                                            \"Sony ILCE-6500\",",
          "5568:                                            \"Sony ILCE-QX1\",",
          "5569:                                            \"Sony DSC-F828\",",
          "5570:                                            \"Sony DSC-R1\",",
          "5571:                                            \"Sony DSC-RX1\",",
          "5572:                                            \"Sony DSC-RX1R\",",
          "5573:                                            \"Sony DSC-RX1R II\",",
          "5574:                                            \"Sony DSC-RX10\",",
          "5575:                                            \"Sony DSC-RX10II\",",
          "5576:                                            \"Sony DSC-RX10III\",",
          "5577:                                            \"Sony DSC-RX100\",",
          "5578:                                            \"Sony DSC-RX100II\",",
          "5579:                                            \"Sony DSC-RX100III\",",
          "5580:                                            \"Sony DSC-RX100IV\",",
          "5581:                                            \"Sony DSC-RX100V\",",
          "5582:                                            \"Sony DSC-V3\",",
          "5583:                                            \"Sony DSLR-A100\",",
          "5584:                                            \"Sony DSLR-A200\",",
          "5585:                                            \"Sony DSLR-A230\",",
          "5586:                                            \"Sony DSLR-A290\",",
          "5587:                                            \"Sony DSLR-A300\",",
          "5588:                                            \"Sony DSLR-A330\",",
          "5589:                                            \"Sony DSLR-A350\",",
          "5590:                                            \"Sony DSLR-A380\",",
          "5591:                                            \"Sony DSLR-A390\",",
          "5592:                                            \"Sony DSLR-A450\",",
          "5593:                                            \"Sony DSLR-A500\",",
          "5594:                                            \"Sony DSLR-A550\",",
          "5595:                                            \"Sony DSLR-A560\",",
          "5596:                                            \"Sony DSLR-A580\",",
          "5597:                                            \"Sony DSLR-A700\",",
          "5598:                                            \"Sony DSLR-A850\",",
          "5599:                                            \"Sony DSLR-A900\",",
          "5600:                                            \"Sony NEX-3\",",
          "5601:                                            \"Sony NEX-3N\",",
          "5602:                                            \"Sony NEX-5\",",
          "5603:                                            \"Sony NEX-5N\",",
          "5604:                                            \"Sony NEX-5R\",",
          "5605:                                            \"Sony NEX-5T\",",
          "5606:                                            \"Sony NEX-6\",",
          "5607:                                            \"Sony NEX-7\",",
          "5608:                                            \"Sony NEX-C3\",",
          "5609:                                            \"Sony NEX-F3\",",
          "5610:                                            \"Sony NEX-VG20\",",
          "5611:                                            \"Sony NEX-VG30\",",
          "5612:                                            \"Sony NEX-VG900\",",
          "5613:                                            \"Sony SLT-A33\",",
          "5614:                                            \"Sony SLT-A35\",",
          "5615:                                            \"Sony SLT-A37\",",
          "5616:                                            \"Sony SLT-A55V\",",
          "5617:                                            \"Sony SLT-A57\",",
          "5618:                                            \"Sony SLT-A58\",",
          "5619:                                            \"Sony SLT-A65V\",",
          "5620:                                            \"Sony SLT-A77V\",",
          "5621:                                            \"Sony SLT-A99V\",",
          "5622:                                            \"Sony XCD-SX910CR\",",
          "5623:                                            \"Sony IMX135-mipi 13mp\",",
          "5624:                                            \"Sony IMX135-QCOM\",",
          "5625:                                            \"Sony IMX072-mipi\",",
          "5626:                                            \"Sony IMX214\",",
          "5627:                                            \"Sony IMX219\",",
          "5628:                                            \"Sony IMX230\",",
          "5629:                                            \"Sony IMX298-mipi 16mp\",",
          "5630:                                            \"Sony IMX219-mipi 8mp\",",
          "5631:                                            \"Sony Xperia L\",",
          "5632:                                            \"STV680 VGA\",",
          "5633:                                            \"PtGrey GRAS-50S5C\",",
          "5634:                                            \"JaiPulnix BB-500CL\",",
          "5635:                                            \"JaiPulnix BB-500GE\",",
          "5636:                                            \"SVS SVS625CL\",",
          "5637:                                            \"YUNEEC CGO4\",",
          "5638:                                            \"Xiaomi MI3\",",
          "5639:                                            \"Xiaomi RedMi Note3 Pro\",",
          "5640:                                            NULL};",
          "5642: const char **LibRaw::cameraList() { return static_camera_list; }",
          "5643: int LibRaw::cameraCount() { return (sizeof(static_camera_list) / sizeof(static_camera_list[0])) - 1; }",
          "5645: const char *LibRaw::strprogress(enum LibRaw_progress p)",
          "5647:   switch (p)",
          "5648:   {",
          "5649:   case LIBRAW_PROGRESS_START:",
          "5650:     return \"Starting\";",
          "5651:   case LIBRAW_PROGRESS_OPEN:",
          "5652:     return \"Opening file\";",
          "5653:   case LIBRAW_PROGRESS_IDENTIFY:",
          "5654:     return \"Reading metadata\";",
          "5655:   case LIBRAW_PROGRESS_SIZE_ADJUST:",
          "5656:     return \"Adjusting size\";",
          "5657:   case LIBRAW_PROGRESS_LOAD_RAW:",
          "5658:     return \"Reading RAW data\";",
          "5659:   case LIBRAW_PROGRESS_REMOVE_ZEROES:",
          "5660:     return \"Clearing zero values\";",
          "5661:   case LIBRAW_PROGRESS_BAD_PIXELS:",
          "5662:     return \"Removing dead pixels\";",
          "5663:   case LIBRAW_PROGRESS_DARK_FRAME:",
          "5664:     return \"Subtracting dark frame data\";",
          "5665:   case LIBRAW_PROGRESS_FOVEON_INTERPOLATE:",
          "5666:     return \"Interpolating Foveon sensor data\";",
          "5667:   case LIBRAW_PROGRESS_SCALE_COLORS:",
          "5668:     return \"Scaling colors\";",
          "5669:   case LIBRAW_PROGRESS_PRE_INTERPOLATE:",
          "5670:     return \"Pre-interpolating\";",
          "5671:   case LIBRAW_PROGRESS_INTERPOLATE:",
          "5672:     return \"Interpolating\";",
          "5673:   case LIBRAW_PROGRESS_MIX_GREEN:",
          "5674:     return \"Mixing green channels\";",
          "5675:   case LIBRAW_PROGRESS_MEDIAN_FILTER:",
          "5676:     return \"Median filter\";",
          "5677:   case LIBRAW_PROGRESS_HIGHLIGHTS:",
          "5678:     return \"Highlight recovery\";",
          "5679:   case LIBRAW_PROGRESS_FUJI_ROTATE:",
          "5680:     return \"Rotating Fuji diagonal data\";",
          "5681:   case LIBRAW_PROGRESS_FLIP:",
          "5682:     return \"Flipping image\";",
          "5683:   case LIBRAW_PROGRESS_APPLY_PROFILE:",
          "5684:     return \"ICC conversion\";",
          "5685:   case LIBRAW_PROGRESS_CONVERT_RGB:",
          "5686:     return \"Converting to RGB\";",
          "5687:   case LIBRAW_PROGRESS_STRETCH:",
          "5688:     return \"Stretching image\";",
          "5689:   case LIBRAW_PROGRESS_THUMB_LOAD:",
          "5690:     return \"Loading thumbnail\";",
          "5691:   default:",
          "5692:     return \"Some strange things\";",
          "5693:   }",
          "5700: void x3f_clear(void *p) { x3f_delete((x3f_t *)p); }",
          "5706:   while (*str != 0x00)",
          "5707:   {",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "5508: static void *lr_memmem(const void *l, size_t l_len, const void *s, size_t s_len)",
          "5509: {",
          "5533: }",
          "5535: void LibRaw::parse_x3f()",
          "5536: {",
          "5537:   x3f_t *x3f = x3f_new_from_file(libraw_internal_data.internal_data.input);",
          "5540:   _x3f_data = x3f;",
          "5542:   x3f_header_t *H = NULL;",
          "",
          "[Removed Lines]",
          "5510:  register char *cur, *last;",
          "5511:  const char *cl = (const char *)l;",
          "5512:  const char *cs = (const char *)s;",
          "5515:  if (l_len == 0 || s_len == 0)",
          "5516:   return NULL;",
          "5519:  if (l_len < s_len)",
          "5520:   return NULL;",
          "5523:  if (s_len == 1)",
          "5524:   return (void*)memchr(l, (int)*cs, l_len);",
          "5527:  last = (char *)cl + l_len - s_len;",
          "5529:  for (cur = (char *)cl; cur <= last; cur++)",
          "5530:   if (cur[0] == cs[0] && memcmp(cur, cs, s_len) == 0)",
          "5531:    return cur;",
          "5532:  return NULL;",
          "5538:   if(!x3f)",
          "5539:       return;",
          "",
          "[Added Lines]",
          "5718:   register char *cur, *last;",
          "5719:   const char *cl = (const char *)l;",
          "5720:   const char *cs = (const char *)s;",
          "5723:   if (l_len == 0 || s_len == 0)",
          "5724:     return NULL;",
          "5727:   if (l_len < s_len)",
          "5728:     return NULL;",
          "5731:   if (s_len == 1)",
          "5732:     return (void *)memchr(l, (int)*cs, l_len);",
          "5735:   last = (char *)cl + l_len - s_len;",
          "5737:   for (cur = (char *)cl; cur <= last; cur++)",
          "5738:     if (cur[0] == cs[0] && memcmp(cur, cs, s_len) == 0)",
          "5739:       return cur;",
          "5740:   return NULL;",
          "5746:   if (!x3f)",
          "5747:     return;",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "5545:   H = &x3f->header;",
          "5547:   x3f_directory_entry_t *DE = x3f_get_raw(x3f);",
          "5549:   imgdata.sizes.flip = H->rotation;",
          "5550:   x3f_directory_entry_header_t *DEH = &DE->header;",
          "5551:   x3f_image_data_t *ID = &DEH->data_subsection.image_data;",
          "",
          "[Removed Lines]",
          "5548:   if(!DE) return;",
          "",
          "[Added Lines]",
          "5756:   if (!DE)",
          "5757:     return;",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "5553:   imgdata.sizes.raw_height = ID->rows;",
          "5555:   DE = x3f_get_prop(x3f);",
          "5628:   }",
          "5629:   else",
          "5630:   {",
          "5644: #if 1",
          "5663: #endif",
          "5670:   }",
          "5672:   LibRaw_thumbnail_formats format = LIBRAW_THUMBNAIL_UNKNOWN;",
          "5692: }",
          "5694: INT64 LibRaw::x3f_thumb_size()",
          "5695: {",
          "5713: }",
          "5715: void LibRaw::x3f_thumb_loader()",
          "5716: {",
          "5761: }",
          "5768: }",
          "5770: void LibRaw::x3f_dpq_interpolate_rg()",
          "5771: {",
          "5792: }",
          "5796: #undef CLIP",
          "5799: void LibRaw::x3f_dpq_interpolate_af(int xstep, int ystep, int scale)",
          "5800: {",
          "5853: }",
          "5856: {",
          "5918: void LibRaw::x3f_load_raw()",
          "5919: {",
          "5936:         {",
          "5939:         }",
          "5983: #if 1",
          "6020: #endif",
          "6024:   }",
          "6025:   else",
          "6026:     raise_error = 1;",
          "6027: end:",
          "6029:     throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "6030: }",
          "",
          "[Removed Lines]",
          "5556:   if((x3f_load_data(x3f,DE) == X3F_OK))",
          "5557:   {",
          "5559:    DEH = &DE->header;",
          "5560:    x3f_property_list_t *PL = &DEH->data_subsection.property_list;",
          "5561:    if (PL->property_table.size != 0) {",
          "5562:     int i;",
          "5563:     x3f_property_t *P = PL->property_table.element;",
          "5564:     for (i=0; i<PL->num_properties; i++) {",
          "5565:      char name[100], value[100];",
          "5566:      utf2char(P[i].name,name);",
          "5567:      utf2char(P[i].value,value);",
          "5568:      if (!strcmp (name, \"ISO\"))",
          "5569:       imgdata.other.iso_speed = atoi(value);",
          "5570:      if (!strcmp (name, \"CAMMANUF\"))",
          "5571:       strcpy (imgdata.idata.make, value);",
          "5572:      if (!strcmp (name, \"CAMMODEL\"))",
          "5573:       strcpy (imgdata.idata.model, value);",
          "5574:      if (!strcmp (name, \"CAMSERIAL\"))",
          "5575:       strcpy (imgdata.shootinginfo.BodySerial, value);",
          "5576:      if (!strcmp (name, \"WB_DESC\"))",
          "5577:       strcpy (imgdata.color.model2, value);",
          "5578:      if (!strcmp (name, \"TIME\"))",
          "5579:       imgdata.other.timestamp = atoi(value);",
          "5580:      if (!strcmp (name, \"SHUTTER\"))",
          "5581:       imgdata.other.shutter = atof(value);",
          "5582:      if (!strcmp (name, \"APERTURE\"))",
          "5583:       imgdata.other.aperture = atof(value);",
          "5584:      if (!strcmp (name, \"FLENGTH\"))",
          "5585:       imgdata.other.focal_len = atof(value);",
          "5586:     if (!strcmp (name, \"FLEQ35MM\"))",
          "5587:       imgdata.lens.makernotes.FocalLengthIn35mmFormat = atof(value);",
          "5588:     if (!strcmp (name, \"LENSARANGE\"))",
          "5589:     {",
          "5590:       char *sp;",
          "5591:       imgdata.lens.makernotes.MaxAp4CurFocal = imgdata.lens.makernotes.MinAp4CurFocal = atof(value);",
          "5592:       sp = strrchr (value, ' ');",
          "5593:       if (sp)",
          "5594:         {",
          "5595:           imgdata.lens.makernotes.MinAp4CurFocal = atof(sp);",
          "5596:           if (imgdata.lens.makernotes.MaxAp4CurFocal > imgdata.lens.makernotes.MinAp4CurFocal)",
          "5597:             my_swap (float, imgdata.lens.makernotes.MaxAp4CurFocal, imgdata.lens.makernotes.MinAp4CurFocal);",
          "5598:         }",
          "5599:     }",
          "5600:     if (!strcmp (name, \"LENSFRANGE\"))",
          "5601:     {",
          "5602:      char *sp;",
          "5603:      imgdata.lens.makernotes.MinFocal = imgdata.lens.makernotes.MaxFocal = atof(value);",
          "5604:      sp = strrchr (value, ' ');",
          "5605:      if (sp)",
          "5606:       {",
          "5607:        imgdata.lens.makernotes.MaxFocal = atof(sp);",
          "5608:        if ((imgdata.lens.makernotes.MaxFocal + 0.17f) < imgdata.lens.makernotes.MinFocal)",
          "5609:         my_swap (float, imgdata.lens.makernotes.MaxFocal, imgdata.lens.makernotes.MinFocal);",
          "5610:       }",
          "5611:     }",
          "5612:     if (!strcmp (name, \"LENSMODEL\"))",
          "5613:     {",
          "5614:      char *sp;",
          "5615:                                         imgdata.lens.makernotes.LensID = strtol (value, &sp, 16); // atoi(value);",
          "5616:      if (imgdata.lens.makernotes.LensID)",
          "5617:       imgdata.lens.makernotes.LensMount = Sigma_X3F;",
          "5618:     }",
          "5619:     }",
          "5620:     imgdata.idata.raw_count=1;",
          "5621:     load_raw = &LibRaw::x3f_load_raw;",
          "5622:     imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*6;",
          "5623:     imgdata.idata.is_foveon = 1;",
          "5624:     libraw_internal_data.internal_output_params.raw_color=1; // Force adobe coeff",
          "5625:     imgdata.color.maximum=0x3fff; // To be reset by color table",
          "5626:     libraw_internal_data.unpacker_data.order = 0x4949;",
          "5627:    }",
          "5632:    if(imgdata.sizes.raw_width == 5888 ||imgdata.sizes.raw_width == 2944",
          "5633:     || imgdata.sizes.raw_width == 6656 ||imgdata.sizes.raw_width == 3328",
          "5634:     || imgdata.sizes.raw_width == 5504 ||imgdata.sizes.raw_width == 2752",
          "5635:     ) // Quattro",
          "5636:    {",
          "5637:     imgdata.idata.raw_count=1;",
          "5638:     load_raw = &LibRaw::x3f_load_raw;",
          "5639:     imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*6;",
          "5640:     imgdata.idata.is_foveon = 1;",
          "5641:     libraw_internal_data.internal_output_params.raw_color=1; // Force adobe coeff",
          "5642:     libraw_internal_data.unpacker_data.order = 0x4949;",
          "5643:     strcpy (imgdata.idata.make, \"SIGMA\");",
          "5646:     int pos = libraw_internal_data.internal_data.input->tell();",
          "5647:     libraw_internal_data.internal_data.input->seek(0,SEEK_SET);",
          "5648:     unsigned char buf[2048];",
          "5649:     libraw_internal_data.internal_data.input->read(buf,2048,1);",
          "5650:     libraw_internal_data.internal_data.input->seek(pos,SEEK_SET);",
          "5651:     unsigned char *fnd=(unsigned char*)lr_memmem(buf,2048,\"SIGMA dp\",8);",
          "5652:     unsigned char *fndsd=(unsigned char*)lr_memmem(buf,2048,\"sd Quatt\",8);",
          "5653:     if(fnd)",
          "5654:     {",
          "5655:      unsigned char *nm = fnd+8;",
          "5656:      snprintf(imgdata.idata.model,64,\"dp%c Quattro\",*nm<='9' && *nm >='0' ? *nm: '2');",
          "5657:     }",
          "5658:     else if(fndsd)",
          "5659:     {",
          "5660:      snprintf(imgdata.idata.model,64,\"%s\",fndsd);",
          "5661:     }",
          "5662:     else",
          "5664:     if(imgdata.sizes.raw_width == 6656 ||imgdata.sizes.raw_width == 3328 )",
          "5665:    strcpy (imgdata.idata.model, \"sd Quattro H\");",
          "5666:     else",
          "5667:    strcpy (imgdata.idata.model, \"dp2 Quattro\");",
          "5668:    }",
          "5673:   if( (DE = x3f_get_thumb_jpeg(x3f)))",
          "5674:     {",
          "5675:       format = LIBRAW_THUMBNAIL_JPEG;",
          "5676:     }",
          "5677:   else if( (DE = x3f_get_thumb_plain(x3f)))",
          "5678:     {",
          "5679:       format = LIBRAW_THUMBNAIL_BITMAP;",
          "5680:     }",
          "5681:   if(DE)",
          "5682:     {",
          "5683:       x3f_directory_entry_header_t *DEH = &DE->header;",
          "5684:       x3f_image_data_t *ID = &DEH->data_subsection.image_data;",
          "5685:       imgdata.thumbnail.twidth = ID->columns;",
          "5686:       imgdata.thumbnail.theight = ID->rows;",
          "5687:       imgdata.thumbnail.tcolors = 3;",
          "5688:       imgdata.thumbnail.tformat = format;",
          "5689:       libraw_internal_data.internal_data.toffset = DE->input.offset;",
          "5690:       write_thumb = &LibRaw::x3f_thumb_loader;",
          "5691:     }",
          "5696:  try {",
          "5697:   x3f_t *x3f = (x3f_t*)_x3f_data;",
          "5698:   if (!x3f) return -1; // No data pointer set",
          "5699:   x3f_directory_entry_t *DE = x3f_get_thumb_jpeg(x3f);",
          "5700:   if (!DE)",
          "5701:    DE = x3f_get_thumb_plain(x3f);",
          "5702:   if (!DE)",
          "5703:    return -1;",
          "5704:   int64_t p = x3f_load_data_size(x3f, DE);",
          "5705:   if (p < 0 || p > 0xffffffff)",
          "5706:    return -1;",
          "5707:   return p;",
          "5708:  }",
          "5709:  catch (...)",
          "5710:  {",
          "5711:   return -1;",
          "5712:  }",
          "5717:  try",
          "5718:  {",
          "5719:   x3f_t *x3f = (x3f_t*)_x3f_data;",
          "5720:   if (!x3f) return; // No data pointer set",
          "5721:   x3f_directory_entry_t *DE = x3f_get_thumb_jpeg(x3f);",
          "5722:   if (!DE)",
          "5723:    DE = x3f_get_thumb_plain(x3f);",
          "5724:   if (!DE)",
          "5725:    return;",
          "5726:   if (X3F_OK != x3f_load_data(x3f, DE))",
          "5727:    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "5728:   x3f_directory_entry_header_t *DEH = &DE->header;",
          "5729:   x3f_image_data_t *ID = &DEH->data_subsection.image_data;",
          "5730:   imgdata.thumbnail.twidth = ID->columns;",
          "5731:   imgdata.thumbnail.theight = ID->rows;",
          "5732:   imgdata.thumbnail.tcolors = 3;",
          "5733:   if (imgdata.thumbnail.tformat == LIBRAW_THUMBNAIL_JPEG)",
          "5734:   {",
          "5735:    imgdata.thumbnail.thumb = (char*)malloc(ID->data_size);",
          "5736:    merror(imgdata.thumbnail.thumb, \"LibRaw::x3f_thumb_loader()\");",
          "5737:    memmove(imgdata.thumbnail.thumb, ID->data, ID->data_size);",
          "5738:    imgdata.thumbnail.tlength = ID->data_size;",
          "5739:   }",
          "5740:   else if (imgdata.thumbnail.tformat == LIBRAW_THUMBNAIL_BITMAP)",
          "5741:   {",
          "5742:    imgdata.thumbnail.tlength = ID->columns * ID->rows * 3;",
          "5743:    imgdata.thumbnail.thumb = (char*)malloc(ID->columns * ID->rows * 3);",
          "5744:    merror(imgdata.thumbnail.thumb, \"LibRaw::x3f_thumb_loader()\");",
          "5745:    char *src0 = (char*)ID->data;",
          "5746:    for (int row = 0; row < ID->rows; row++)",
          "5747:    {",
          "5748:     int offset = row * ID->row_stride;",
          "5749:     if (offset + ID->columns * 3 > ID->data_size)",
          "5750:      break;",
          "5751:     char *dest = &imgdata.thumbnail.thumb[row*ID->columns * 3];",
          "5752:     char *src = &src0[offset];",
          "5753:     memmove(dest, src, ID->columns * 3);",
          "5754:    }",
          "5755:   }",
          "5756:  }",
          "5757:  catch (...)",
          "5758:  {",
          "5760:  }",
          "5763: static inline uint32_t _clampbits(int x, uint32_t n) {",
          "5764:  uint32_t _y_temp;",
          "5765:  if( (_y_temp=x>>n) )",
          "5766:   x = ~_y_temp >> (32-n);",
          "5767:  return x;",
          "5772:  int w = imgdata.sizes.raw_width/2;",
          "5773:  int h = imgdata.sizes.raw_height/2;",
          "5774:  unsigned short *image = (ushort*)imgdata.rawdata.color3_image;",
          "5776:  for (int color = 0; color < 2;  color++)",
          "5777:  {",
          "5778:   for (int y = 2; y < (h-2); y++)",
          "5779:   {",
          "5780:    uint16_t* row0 = &image[imgdata.sizes.raw_width*3*(y*2)+color]; // dst[1]",
          "5781:    uint16_t  row0_3 = row0[3];",
          "5782:    uint16_t* row1 = &image[imgdata.sizes.raw_width*3*(y*2+1)+color]; //dst1[1]",
          "5783:    uint16_t  row1_3 = row1[3];",
          "5784:    for (int x = 2; x < (w-2); x++)",
          "5785:    {",
          "5786:     row1[0]=row1[3]=row0[3]=row0[0];",
          "5787:     row0 += 6;",
          "5788:     row1 += 6;",
          "5789:    }",
          "5790:   }",
          "5791:  }",
          "5794: #define _ABS(a) ((a)<0?-(a):(a))",
          "5797: #define CLIP(value,high) ((value)>(high)?(high):(value))",
          "5801:  unsigned short *image = (ushort*)imgdata.rawdata.color3_image;",
          "5802:  unsigned int rowpitch = imgdata.rawdata.sizes.raw_pitch/2; // in 16-bit words",
          "5804:  for(int y = 0;  y < imgdata.rawdata.sizes.height+imgdata.rawdata.sizes.top_margin; y+=ystep)",
          "5805:  {",
          "5806:   if(y<imgdata.rawdata.sizes.top_margin) continue;",
          "5807:   if(y<scale) continue;",
          "5808:   if(y>imgdata.rawdata.sizes.raw_height-scale) break;",
          "5809:   uint16_t* row0 = &image[imgdata.sizes.raw_width*3*y]; // \u041d\u0430\u0448\u0430 \u0441\u0442\u0440\u043e\u043a\u0430",
          "5810:   uint16_t* row_minus = &image[imgdata.sizes.raw_width*3*(y-scale)]; // \u0421\u0442\u0440\u043e\u043a\u0430 \u0432\u044b\u0448\u0435",
          "5811:   uint16_t* row_plus = &image[imgdata.sizes.raw_width*3*(y+scale)]; // \u0421\u0442\u0440\u043e\u043a\u0430 \u043d\u0438\u0436\u0435",
          "5812:   for(int x = 0; x < imgdata.rawdata.sizes.width+imgdata.rawdata.sizes.left_margin; x+= xstep)",
          "5813:    {",
          "5814:     if(x<imgdata.rawdata.sizes.left_margin) continue;",
          "5815:     if(x<scale) continue;",
          "5816:     if(x>imgdata.rawdata.sizes.raw_width-scale) break;",
          "5817:     uint16_t* pixel0 = &row0[x*3];",
          "5818:     uint16_t* pixel_top = &row_minus[x*3];",
          "5819:     uint16_t* pixel_bottom = &row_plus[x*3];",
          "5820:     uint16_t* pixel_left = &row0[(x-scale)*3];",
          "5821:     uint16_t* pixel_right = &row0[(x+scale)*3];",
          "5822:     uint16_t* pixf = pixel_top;",
          "5823:     if(_ABS(pixf[2]-pixel0[2])>_ABS(pixel_bottom[2]-pixel0[2]))",
          "5824:      pixf = pixel_bottom;",
          "5825:     if(_ABS(pixf[2]-pixel0[2])>_ABS(pixel_left[2]-pixel0[2]))",
          "5826:      pixf = pixel_left;",
          "5827:     if(_ABS(pixf[2]-pixel0[2])>_ABS(pixel_right[2]-pixel0[2]))",
          "5828:      pixf = pixel_right;",
          "5829:     int blocal = pixel0[2],bnear = pixf[2];",
          "5830:     if(blocal < imgdata.color.black+16 || bnear < imgdata.color.black+16 )",
          "5831:     {",
          "5832:      if(pixel0[0] < imgdata.color.black) pixel0[0] = imgdata.color.black;",
          "5833:      if(pixel0[1] < imgdata.color.black) pixel0[1] = imgdata.color.black;",
          "5834:      pixel0[0] = CLIP((pixel0[0] - imgdata.color.black)*4 + imgdata.color.black,16383);",
          "5835:      pixel0[1] = CLIP((pixel0[1] - imgdata.color.black)*4 + imgdata.color.black,16383);",
          "5836:     }",
          "5837:     else",
          "5838:     {",
          "5839:      float multip = float(bnear - imgdata.color.black)/float(blocal-imgdata.color.black);",
          "5840:      if(pixel0[0] < imgdata.color.black) pixel0[0] = imgdata.color.black;",
          "5841:      if(pixel0[1] < imgdata.color.black) pixel0[1] = imgdata.color.black;",
          "5842:      float pixf0 = pixf[0];",
          "5843:      if(pixf0 < imgdata.color.black) pixf0 = imgdata.color.black;",
          "5844:      float pixf1 = pixf[1];",
          "5845:      if(pixf1 < imgdata.color.black) pixf1 = imgdata.color.black;",
          "5847:      pixel0[0] = CLIP(((float(pixf0-imgdata.color.black)*multip + imgdata.color.black)+((pixel0[0]-imgdata.color.black)*3.75 + imgdata.color.black))/2,16383);",
          "5848:      pixel0[1] = CLIP(((float(pixf1-imgdata.color.black)*multip + imgdata.color.black)+((pixel0[1]-imgdata.color.black)*3.75 + imgdata.color.black))/2,16383);",
          "5850:     }",
          "5851:    }",
          "5852:   }",
          "5855: void LibRaw::x3f_dpq_interpolate_af_sd(int xstart,int ystart, int xend, int yend, int xstep, int ystep, int scale)",
          "5857:  unsigned short *image = (ushort*)imgdata.rawdata.color3_image;",
          "5858:  unsigned int rowpitch = imgdata.rawdata.sizes.raw_pitch/2; // in 16-bit words",
          "5860:  for(int y = ystart;  y< yend && y < imgdata.rawdata.sizes.height+imgdata.rawdata.sizes.top_margin; y+=ystep)",
          "5861:  {",
          "5862:   uint16_t* row0 = &image[imgdata.sizes.raw_width*3*y]; // \u041d\u0430\u0448\u0430 \u0441\u0442\u0440\u043e\u043a\u0430",
          "5863:   uint16_t* row1 = &image[imgdata.sizes.raw_width*3*(y+1)]; // \u0421\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430",
          "5864:   uint16_t* row_minus = &image[imgdata.sizes.raw_width*3*(y-scale)]; // \u0421\u0442\u0440\u043e\u043a\u0430 \u0432\u044b\u0448\u0435",
          "5865:   uint16_t* row_plus = &image[imgdata.sizes.raw_width*3*(y+scale)]; // \u0421\u0442\u0440\u043e\u043a\u0430 \u043d\u0438\u0436\u0435 AF-point (scale=2 -> \u043d\u0438\u0436\u0435 row1",
          "5866:   uint16_t* row_minus1 = &image[imgdata.sizes.raw_width*3*(y-1)];",
          "5867:   for(int x = xstart; x< xend && x < imgdata.rawdata.sizes.width+imgdata.rawdata.sizes.left_margin; x+= xstep)",
          "5868:   {",
          "5869:    uint16_t* pixel00 = &row0[x*3]; // Current pixel",
          "5870:    float sumR = 0.f,sumG=0.f;",
          "5871:    float cnt = 0.f;",
          "5872:    for(int xx = -scale; xx <= scale; xx+= scale)",
          "5873:    {",
          "5874:     sumR += row_minus[(x+xx)*3];",
          "5875:     sumR += row_plus[(x+xx)*3];",
          "5876:     sumG += row_minus[(x+xx)*3+1];",
          "5877:     sumG += row_plus[(x+xx)*3+1];",
          "5878:     cnt +=1.f;",
          "5879:     if(xx)",
          "5880:     {",
          "5881:      cnt +=1.f;",
          "5882:      sumR += row0[(x+xx)*3];",
          "5883:      sumG += row0[(x+xx)*3+1];",
          "5884:     }",
          "5885:    }",
          "5886:    pixel00[0] = sumR/8.f;",
          "5887:    pixel00[1] = sumG/8.f;",
          "5889:    if(scale == 2)",
          "5890:    {",
          "5891:     uint16_t* pixel0B = &row0[x*3+3]; // right pixel",
          "5892:     uint16_t* pixel1B = &row1[x*3+3]; // right pixel",
          "5893:     float sumG0 = 0, sumG1 = 0.f;",
          "5894:     float cnt = 0.f;",
          "5895:     for(int xx = -scale; xx <= scale; xx+= scale)",
          "5896:     {",
          "5897:      sumG0 += row_minus1[(x+xx)*3+2];",
          "5898:      sumG1 += row_plus[(x+xx)*3+2];",
          "5899:      cnt +=1.f;",
          "5900:      if(xx)",
          "5901:      {",
          "5902:       sumG0 += row0[(x+xx)*3+2];",
          "5903:       sumG1 += row1[(x+xx)*3+2];",
          "5904:       cnt +=1.f;",
          "5905:      }",
          "5906:     }",
          "5907:     pixel0B[2] = sumG0/cnt;",
          "5908:     pixel1B[2] = sumG1/cnt;",
          "5909:    }",
          "5913:   }",
          "5914:  }",
          "5915: }",
          "5921:   int raise_error=0;",
          "5922:   x3f_t *x3f = (x3f_t*)_x3f_data;",
          "5923:   if(!x3f) return; // No data pointer set",
          "5924:   if(X3F_OK == x3f_load_data(x3f, x3f_get_raw(x3f)))",
          "5925:     {",
          "5926:       x3f_directory_entry_t *DE = x3f_get_raw(x3f);",
          "5927:       x3f_directory_entry_header_t *DEH = &DE->header;",
          "5928:       x3f_image_data_t *ID = &DEH->data_subsection.image_data;",
          "5929:    if(!ID)",
          "5930:     throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "5931:    x3f_quattro_t *Q = ID->quattro;",
          "5932:       x3f_huffman_t *HUF = ID->huffman;",
          "5933:       x3f_true_t *TRU = ID->tru;",
          "5934:       uint16_t *data = NULL;",
          "5935:       if(ID->rows != S.raw_height || ID->columns != S.raw_width)",
          "5937:           raise_error = 1;",
          "5938:           goto end;",
          "5940:       if (HUF != NULL)",
          "5941:         data = HUF->x3rgb16.data;",
          "5942:       if (TRU != NULL)",
          "5943:         data = TRU->x3rgb16.data;",
          "5944:       if (data == NULL)",
          "5945:         {",
          "5946:           raise_error = 1;",
          "5947:           goto end;",
          "5948:         }",
          "5950:    size_t datasize = S.raw_height*S.raw_width*3*sizeof(unsigned short);",
          "5951:    S.raw_pitch = S.raw_width*3*sizeof(unsigned short);",
          "5952:    if(!(imgdata.rawdata.raw_alloc = malloc(datasize)))",
          "5953:     throw LIBRAW_EXCEPTION_ALLOC;",
          "5955:       imgdata.rawdata.color3_image = (ushort (*)[3])imgdata.rawdata.raw_alloc;",
          "5956:    if(HUF)",
          "5957:     memmove(imgdata.rawdata.raw_alloc,data,datasize);",
          "5958:    else if(TRU && (!Q || !Q->quattro_layout))",
          "5959:     memmove(imgdata.rawdata.raw_alloc,data,datasize);",
          "5960:    else if(TRU && Q)",
          "5961:    {",
          "5964:     for(int prow = 0; prow < TRU->x3rgb16.rows && prow < S.raw_height/2; prow++)",
          "5965:     {",
          "5966:      ushort (*destrow)[3] = (unsigned short (*)[3]) &imgdata.rawdata.color3_image[prow*2*S.raw_pitch/3/sizeof(ushort)][0];",
          "5967:      ushort (*srcrow)[3] = (unsigned short (*)[3]) &data[prow*TRU->x3rgb16.row_stride];",
          "5968:      for(int pcol = 0; pcol < TRU->x3rgb16.columns && pcol < S.raw_width/2; pcol++)",
          "5969:      {",
          "5970:       destrow[pcol*2][0] = srcrow[pcol][0];",
          "5971:       destrow[pcol*2][1] = srcrow[pcol][1];",
          "5972:      }",
          "5973:     }",
          "5974:     for(int row = 0; row < Q->top16.rows && row < S.raw_height; row++)",
          "5975:     {",
          "5976:      ushort (*destrow)[3] = (unsigned short (*)[3]) &imgdata.rawdata.color3_image[row*S.raw_pitch/3/sizeof(ushort)][0];",
          "5977:      ushort (*srcrow) = (unsigned short *) &Q->top16.data[row * Q->top16.columns];",
          "5978:      for(int col = 0; col < Q->top16.columns && col < S.raw_width; col++)",
          "5979:       destrow[col][2] = srcrow[col];",
          "5980:     }",
          "5981:    }",
          "5984:    if(TRU && Q  && (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_DP2Q_INTERPOLATEAF)",
          "5985:     )",
          "5986:    {",
          "5987:     if(imgdata.sizes.raw_width == 5888 && imgdata.sizes.raw_height == 3672) // dpN Quattro normal",
          "5988:     {",
          "5989:      x3f_dpq_interpolate_af(32,8,2);",
          "5990:     }",
          "5991:     else if(imgdata.sizes.raw_width == 5888 && imgdata.sizes.raw_height == 3776) // sd Quattro normal raw",
          "5992:     {",
          "5993:      x3f_dpq_interpolate_af_sd(216,464,imgdata.sizes.raw_width-1,3312,16,32,2);",
          "5994:     }",
          "5995:     else if(imgdata.sizes.raw_width == 6656 && imgdata.sizes.raw_height == 4480) // sd Quattro H normal raw",
          "5996:     {",
          "5997:      x3f_dpq_interpolate_af_sd(232,592,imgdata.sizes.raw_width-1,3888,16,32,2);",
          "5998:     }",
          "5999:     else if(imgdata.sizes.raw_width == 3328 && imgdata.sizes.raw_height == 2240) // sd Quattro H half size",
          "6000:     {",
          "6001:      x3f_dpq_interpolate_af_sd(116,296,imgdata.sizes.raw_width-1,2200,8,16,1);",
          "6002:     }",
          "6003:     else if(imgdata.sizes.raw_width == 5504 && imgdata.sizes.raw_height == 3680) // sd Quattro H APS-C raw",
          "6004:     {",
          "6005:      x3f_dpq_interpolate_af_sd(8,192,imgdata.sizes.raw_width-1,3185,16,32,2);",
          "6006:     }",
          "6007:     else if(imgdata.sizes.raw_width == 2752 && imgdata.sizes.raw_height == 1840) // sd Quattro H APS-C half size",
          "6008:     {",
          "6009:      x3f_dpq_interpolate_af_sd(4, 96,imgdata.sizes.raw_width-1,1800,8,16,1);",
          "6010:     }",
          "6011:     else if(imgdata.sizes.raw_width == 2944 && imgdata.sizes.raw_height == 1836) // dpN Quattro small raw",
          "6012:     {",
          "6013:      x3f_dpq_interpolate_af(16,4,1);",
          "6014:     }",
          "6015:     else if(imgdata.sizes.raw_width == 2944 && imgdata.sizes.raw_height == 1888) // sd Quattro small",
          "6016:     {",
          "6017:      x3f_dpq_interpolate_af_sd(108,232,imgdata.sizes.raw_width-1,1656,8,16,1);",
          "6018:     }",
          "6019:    }",
          "6021:    if(TRU && Q && Q->quattro_layout  && (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_DP2Q_INTERPOLATERG)  )",
          "6022:    x3f_dpq_interpolate_rg();",
          "6028:   if(raise_error)",
          "",
          "[Added Lines]",
          "5765:   if ((x3f_load_data(x3f, DE) == X3F_OK))",
          "5766:   {",
          "5768:     DEH = &DE->header;",
          "5769:     x3f_property_list_t *PL = &DEH->data_subsection.property_list;",
          "5770:     if (PL->property_table.size != 0)",
          "5771:     {",
          "5772:       int i;",
          "5773:       x3f_property_t *P = PL->property_table.element;",
          "5774:       for (i = 0; i < PL->num_properties; i++)",
          "5775:       {",
          "5776:         char name[100], value[100];",
          "5777:         utf2char(P[i].name, name);",
          "5778:         utf2char(P[i].value, value);",
          "5779:         if (!strcmp(name, \"ISO\"))",
          "5780:           imgdata.other.iso_speed = atoi(value);",
          "5781:         if (!strcmp(name, \"CAMMANUF\"))",
          "5782:           strcpy(imgdata.idata.make, value);",
          "5783:         if (!strcmp(name, \"CAMMODEL\"))",
          "5784:           strcpy(imgdata.idata.model, value);",
          "5785:         if (!strcmp(name, \"CAMSERIAL\"))",
          "5786:           strcpy(imgdata.shootinginfo.BodySerial, value);",
          "5787:         if (!strcmp(name, \"WB_DESC\"))",
          "5788:           strcpy(imgdata.color.model2, value);",
          "5789:         if (!strcmp(name, \"TIME\"))",
          "5790:           imgdata.other.timestamp = atoi(value);",
          "5791:         if (!strcmp(name, \"SHUTTER\"))",
          "5792:           imgdata.other.shutter = atof(value);",
          "5793:         if (!strcmp(name, \"APERTURE\"))",
          "5794:           imgdata.other.aperture = atof(value);",
          "5795:         if (!strcmp(name, \"FLENGTH\"))",
          "5796:           imgdata.other.focal_len = atof(value);",
          "5797:         if (!strcmp(name, \"FLEQ35MM\"))",
          "5798:           imgdata.lens.makernotes.FocalLengthIn35mmFormat = atof(value);",
          "5799:         if (!strcmp(name, \"LENSARANGE\"))",
          "5800:         {",
          "5801:           char *sp;",
          "5802:           imgdata.lens.makernotes.MaxAp4CurFocal = imgdata.lens.makernotes.MinAp4CurFocal = atof(value);",
          "5803:           sp = strrchr(value, ' ');",
          "5804:           if (sp)",
          "5805:           {",
          "5806:             imgdata.lens.makernotes.MinAp4CurFocal = atof(sp);",
          "5807:             if (imgdata.lens.makernotes.MaxAp4CurFocal > imgdata.lens.makernotes.MinAp4CurFocal)",
          "5808:               my_swap(float, imgdata.lens.makernotes.MaxAp4CurFocal, imgdata.lens.makernotes.MinAp4CurFocal);",
          "5809:           }",
          "5810:         }",
          "5811:         if (!strcmp(name, \"LENSFRANGE\"))",
          "5812:         {",
          "5813:           char *sp;",
          "5814:           imgdata.lens.makernotes.MinFocal = imgdata.lens.makernotes.MaxFocal = atof(value);",
          "5815:           sp = strrchr(value, ' ');",
          "5816:           if (sp)",
          "5817:           {",
          "5818:             imgdata.lens.makernotes.MaxFocal = atof(sp);",
          "5819:             if ((imgdata.lens.makernotes.MaxFocal + 0.17f) < imgdata.lens.makernotes.MinFocal)",
          "5820:               my_swap(float, imgdata.lens.makernotes.MaxFocal, imgdata.lens.makernotes.MinFocal);",
          "5821:           }",
          "5822:         }",
          "5823:         if (!strcmp(name, \"LENSMODEL\"))",
          "5824:         {",
          "5825:           char *sp;",
          "5826:           imgdata.lens.makernotes.LensID = strtol(value, &sp, 16); // atoi(value);",
          "5827:           if (imgdata.lens.makernotes.LensID)",
          "5828:             imgdata.lens.makernotes.LensMount = Sigma_X3F;",
          "5829:         }",
          "5830:       }",
          "5831:       imgdata.idata.raw_count = 1;",
          "5832:       load_raw = &LibRaw::x3f_load_raw;",
          "5833:       imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 6;",
          "5834:       imgdata.idata.is_foveon = 1;",
          "5835:       libraw_internal_data.internal_output_params.raw_color = 1; // Force adobe coeff",
          "5836:       imgdata.color.maximum = 0x3fff;                            // To be reset by color table",
          "5837:       libraw_internal_data.unpacker_data.order = 0x4949;",
          "5838:     }",
          "5843:     if (imgdata.sizes.raw_width == 5888 || imgdata.sizes.raw_width == 2944 || imgdata.sizes.raw_width == 6656 ||",
          "5844:         imgdata.sizes.raw_width == 3328 || imgdata.sizes.raw_width == 5504 ||",
          "5845:         imgdata.sizes.raw_width == 2752) // Quattro",
          "5846:     {",
          "5847:       imgdata.idata.raw_count = 1;",
          "5848:       load_raw = &LibRaw::x3f_load_raw;",
          "5849:       imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 6;",
          "5850:       imgdata.idata.is_foveon = 1;",
          "5851:       libraw_internal_data.internal_output_params.raw_color = 1; // Force adobe coeff",
          "5852:       libraw_internal_data.unpacker_data.order = 0x4949;",
          "5853:       strcpy(imgdata.idata.make, \"SIGMA\");",
          "5856:       int pos = libraw_internal_data.internal_data.input->tell();",
          "5857:       libraw_internal_data.internal_data.input->seek(0, SEEK_SET);",
          "5858:       unsigned char buf[2048];",
          "5859:       libraw_internal_data.internal_data.input->read(buf, 2048, 1);",
          "5860:       libraw_internal_data.internal_data.input->seek(pos, SEEK_SET);",
          "5861:       unsigned char *fnd = (unsigned char *)lr_memmem(buf, 2048, \"SIGMA dp\", 8);",
          "5862:       unsigned char *fndsd = (unsigned char *)lr_memmem(buf, 2048, \"sd Quatt\", 8);",
          "5863:       if (fnd)",
          "5864:       {",
          "5865:         unsigned char *nm = fnd + 8;",
          "5866:         snprintf(imgdata.idata.model, 64, \"dp%c Quattro\", *nm <= '9' && *nm >= '0' ? *nm : '2');",
          "5867:       }",
          "5868:       else if (fndsd)",
          "5869:       {",
          "5870:         snprintf(imgdata.idata.model, 64, \"%s\", fndsd);",
          "5871:       }",
          "5872:       else",
          "5874:           if (imgdata.sizes.raw_width == 6656 || imgdata.sizes.raw_width == 3328)",
          "5875:         strcpy(imgdata.idata.model, \"sd Quattro H\");",
          "5876:       else",
          "5877:         strcpy(imgdata.idata.model, \"dp2 Quattro\");",
          "5878:     }",
          "5883:   if ((DE = x3f_get_thumb_jpeg(x3f)))",
          "5884:   {",
          "5885:     format = LIBRAW_THUMBNAIL_JPEG;",
          "5886:   }",
          "5887:   else if ((DE = x3f_get_thumb_plain(x3f)))",
          "5888:   {",
          "5889:     format = LIBRAW_THUMBNAIL_BITMAP;",
          "5890:   }",
          "5891:   if (DE)",
          "5892:   {",
          "5893:     x3f_directory_entry_header_t *DEH = &DE->header;",
          "5894:     x3f_image_data_t *ID = &DEH->data_subsection.image_data;",
          "5895:     imgdata.thumbnail.twidth = ID->columns;",
          "5896:     imgdata.thumbnail.theight = ID->rows;",
          "5897:     imgdata.thumbnail.tcolors = 3;",
          "5898:     imgdata.thumbnail.tformat = format;",
          "5899:     libraw_internal_data.internal_data.toffset = DE->input.offset;",
          "5900:     write_thumb = &LibRaw::x3f_thumb_loader;",
          "5901:   }",
          "5906:   try",
          "5907:   {",
          "5908:     x3f_t *x3f = (x3f_t *)_x3f_data;",
          "5909:     if (!x3f)",
          "5910:       return -1; // No data pointer set",
          "5911:     x3f_directory_entry_t *DE = x3f_get_thumb_jpeg(x3f);",
          "5912:     if (!DE)",
          "5913:       DE = x3f_get_thumb_plain(x3f);",
          "5914:     if (!DE)",
          "5915:       return -1;",
          "5916:     int64_t p = x3f_load_data_size(x3f, DE);",
          "5917:     if (p < 0 || p > 0xffffffff)",
          "5918:       return -1;",
          "5919:     return p;",
          "5920:   }",
          "5921:   catch (...)",
          "5922:   {",
          "5923:     return -1;",
          "5924:   }",
          "5929:   try",
          "5930:   {",
          "5931:     x3f_t *x3f = (x3f_t *)_x3f_data;",
          "5932:     if (!x3f)",
          "5933:       return; // No data pointer set",
          "5934:     x3f_directory_entry_t *DE = x3f_get_thumb_jpeg(x3f);",
          "5935:     if (!DE)",
          "5936:       DE = x3f_get_thumb_plain(x3f);",
          "5937:     if (!DE)",
          "5938:       return;",
          "5939:     if (X3F_OK != x3f_load_data(x3f, DE))",
          "5940:       throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "5941:     x3f_directory_entry_header_t *DEH = &DE->header;",
          "5942:     x3f_image_data_t *ID = &DEH->data_subsection.image_data;",
          "5943:     imgdata.thumbnail.twidth = ID->columns;",
          "5944:     imgdata.thumbnail.theight = ID->rows;",
          "5945:     imgdata.thumbnail.tcolors = 3;",
          "5946:     if (imgdata.thumbnail.tformat == LIBRAW_THUMBNAIL_JPEG)",
          "5947:     {",
          "5948:       imgdata.thumbnail.thumb = (char *)malloc(ID->data_size);",
          "5949:       merror(imgdata.thumbnail.thumb, \"LibRaw::x3f_thumb_loader()\");",
          "5950:       memmove(imgdata.thumbnail.thumb, ID->data, ID->data_size);",
          "5951:       imgdata.thumbnail.tlength = ID->data_size;",
          "5952:     }",
          "5953:     else if (imgdata.thumbnail.tformat == LIBRAW_THUMBNAIL_BITMAP)",
          "5954:     {",
          "5955:       imgdata.thumbnail.tlength = ID->columns * ID->rows * 3;",
          "5956:       imgdata.thumbnail.thumb = (char *)malloc(ID->columns * ID->rows * 3);",
          "5957:       merror(imgdata.thumbnail.thumb, \"LibRaw::x3f_thumb_loader()\");",
          "5958:       char *src0 = (char *)ID->data;",
          "5959:       for (int row = 0; row < ID->rows; row++)",
          "5960:       {",
          "5961:         int offset = row * ID->row_stride;",
          "5962:         if (offset + ID->columns * 3 > ID->data_size)",
          "5963:           break;",
          "5964:         char *dest = &imgdata.thumbnail.thumb[row * ID->columns * 3];",
          "5965:         char *src = &src0[offset];",
          "5966:         memmove(dest, src, ID->columns * 3);",
          "5967:       }",
          "5968:     }",
          "5969:   }",
          "5970:   catch (...)",
          "5971:   {",
          "5973:   }",
          "5976: static inline uint32_t _clampbits(int x, uint32_t n)",
          "5977: {",
          "5978:   uint32_t _y_temp;",
          "5979:   if ((_y_temp = x >> n))",
          "5980:     x = ~_y_temp >> (32 - n);",
          "5981:   return x;",
          "5986:   int w = imgdata.sizes.raw_width / 2;",
          "5987:   int h = imgdata.sizes.raw_height / 2;",
          "5988:   unsigned short *image = (ushort *)imgdata.rawdata.color3_image;",
          "5990:   for (int color = 0; color < 2; color++)",
          "5991:   {",
          "5992:     for (int y = 2; y < (h - 2); y++)",
          "5993:     {",
          "5994:       uint16_t *row0 = &image[imgdata.sizes.raw_width * 3 * (y * 2) + color]; // dst[1]",
          "5995:       uint16_t row0_3 = row0[3];",
          "5996:       uint16_t *row1 = &image[imgdata.sizes.raw_width * 3 * (y * 2 + 1) + color]; // dst1[1]",
          "5997:       uint16_t row1_3 = row1[3];",
          "5998:       for (int x = 2; x < (w - 2); x++)",
          "5999:       {",
          "6000:         row1[0] = row1[3] = row0[3] = row0[0];",
          "6001:         row0 += 6;",
          "6002:         row1 += 6;",
          "6003:       }",
          "6004:     }",
          "6005:   }",
          "6008: #define _ABS(a) ((a) < 0 ? -(a) : (a))",
          "6011: #define CLIP(value, high) ((value) > (high) ? (high) : (value))",
          "6015:   unsigned short *image = (ushort *)imgdata.rawdata.color3_image;",
          "6016:   unsigned int rowpitch = imgdata.rawdata.sizes.raw_pitch / 2; // in 16-bit words",
          "6018:   for (int y = 0; y < imgdata.rawdata.sizes.height + imgdata.rawdata.sizes.top_margin; y += ystep)",
          "6019:   {",
          "6020:     if (y < imgdata.rawdata.sizes.top_margin)",
          "6021:       continue;",
          "6022:     if (y < scale)",
          "6023:       continue;",
          "6024:     if (y > imgdata.rawdata.sizes.raw_height - scale)",
          "6025:       break;",
          "6026:     uint16_t *row0 = &image[imgdata.sizes.raw_width * 3 * y];                // \u041d\u0430\u0448\u0430 \u0441\u0442\u0440\u043e\u043a\u0430",
          "6027:     uint16_t *row_minus = &image[imgdata.sizes.raw_width * 3 * (y - scale)]; // \u0421\u0442\u0440\u043e\u043a\u0430 \u0432\u044b\u0448\u0435",
          "6028:     uint16_t *row_plus = &image[imgdata.sizes.raw_width * 3 * (y + scale)];  // \u0421\u0442\u0440\u043e\u043a\u0430 \u043d\u0438\u0436\u0435",
          "6029:     for (int x = 0; x < imgdata.rawdata.sizes.width + imgdata.rawdata.sizes.left_margin; x += xstep)",
          "6030:     {",
          "6031:       if (x < imgdata.rawdata.sizes.left_margin)",
          "6032:         continue;",
          "6033:       if (x < scale)",
          "6034:         continue;",
          "6035:       if (x > imgdata.rawdata.sizes.raw_width - scale)",
          "6036:         break;",
          "6037:       uint16_t *pixel0 = &row0[x * 3];",
          "6038:       uint16_t *pixel_top = &row_minus[x * 3];",
          "6039:       uint16_t *pixel_bottom = &row_plus[x * 3];",
          "6040:       uint16_t *pixel_left = &row0[(x - scale) * 3];",
          "6041:       uint16_t *pixel_right = &row0[(x + scale) * 3];",
          "6042:       uint16_t *pixf = pixel_top;",
          "6043:       if (_ABS(pixf[2] - pixel0[2]) > _ABS(pixel_bottom[2] - pixel0[2]))",
          "6044:         pixf = pixel_bottom;",
          "6045:       if (_ABS(pixf[2] - pixel0[2]) > _ABS(pixel_left[2] - pixel0[2]))",
          "6046:         pixf = pixel_left;",
          "6047:       if (_ABS(pixf[2] - pixel0[2]) > _ABS(pixel_right[2] - pixel0[2]))",
          "6048:         pixf = pixel_right;",
          "6049:       int blocal = pixel0[2], bnear = pixf[2];",
          "6050:       if (blocal < imgdata.color.black + 16 || bnear < imgdata.color.black + 16)",
          "6051:       {",
          "6052:         if (pixel0[0] < imgdata.color.black)",
          "6053:           pixel0[0] = imgdata.color.black;",
          "6054:         if (pixel0[1] < imgdata.color.black)",
          "6055:           pixel0[1] = imgdata.color.black;",
          "6056:         pixel0[0] = CLIP((pixel0[0] - imgdata.color.black) * 4 + imgdata.color.black, 16383);",
          "6057:         pixel0[1] = CLIP((pixel0[1] - imgdata.color.black) * 4 + imgdata.color.black, 16383);",
          "6058:       }",
          "6059:       else",
          "6060:       {",
          "6061:         float multip = float(bnear - imgdata.color.black) / float(blocal - imgdata.color.black);",
          "6062:         if (pixel0[0] < imgdata.color.black)",
          "6063:           pixel0[0] = imgdata.color.black;",
          "6064:         if (pixel0[1] < imgdata.color.black)",
          "6065:           pixel0[1] = imgdata.color.black;",
          "6066:         float pixf0 = pixf[0];",
          "6067:         if (pixf0 < imgdata.color.black)",
          "6068:           pixf0 = imgdata.color.black;",
          "6069:         float pixf1 = pixf[1];",
          "6070:         if (pixf1 < imgdata.color.black)",
          "6071:           pixf1 = imgdata.color.black;",
          "6073:         pixel0[0] = CLIP(((float(pixf0 - imgdata.color.black) * multip + imgdata.color.black) +",
          "6074:                           ((pixel0[0] - imgdata.color.black) * 3.75 + imgdata.color.black)) /",
          "6075:                              2,",
          "6076:                          16383);",
          "6077:         pixel0[1] = CLIP(((float(pixf1 - imgdata.color.black) * multip + imgdata.color.black) +",
          "6078:                           ((pixel0[1] - imgdata.color.black) * 3.75 + imgdata.color.black)) /",
          "6079:                              2,",
          "6080:                          16383);",
          "6082:       }",
          "6083:     }",
          "6084:   }",
          "6087: void LibRaw::x3f_dpq_interpolate_af_sd(int xstart, int ystart, int xend, int yend, int xstep, int ystep, int scale)",
          "6089:   unsigned short *image = (ushort *)imgdata.rawdata.color3_image;",
          "6090:   unsigned int rowpitch = imgdata.rawdata.sizes.raw_pitch / 2; // in 16-bit words",
          "6092:   for (int y = ystart; y < yend && y < imgdata.rawdata.sizes.height + imgdata.rawdata.sizes.top_margin; y += ystep)",
          "6093:   {",
          "6094:     uint16_t *row0 = &image[imgdata.sizes.raw_width * 3 * y];                // \u041d\u0430\u0448\u0430 \u0441\u0442\u0440\u043e\u043a\u0430",
          "6095:     uint16_t *row1 = &image[imgdata.sizes.raw_width * 3 * (y + 1)];          // \u0421\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430",
          "6096:     uint16_t *row_minus = &image[imgdata.sizes.raw_width * 3 * (y - scale)]; // \u0421\u0442\u0440\u043e\u043a\u0430 \u0432\u044b\u0448\u0435",
          "6097:     uint16_t *row_plus =",
          "6098:         &image[imgdata.sizes.raw_width * 3 * (y + scale)]; // \u0421\u0442\u0440\u043e\u043a\u0430 \u043d\u0438\u0436\u0435 AF-point (scale=2 -> \u043d\u0438\u0436\u0435 row1",
          "6099:     uint16_t *row_minus1 = &image[imgdata.sizes.raw_width * 3 * (y - 1)];",
          "6100:     for (int x = xstart; x < xend && x < imgdata.rawdata.sizes.width + imgdata.rawdata.sizes.left_margin; x += xstep)",
          "6101:     {",
          "6102:       uint16_t *pixel00 = &row0[x * 3]; // Current pixel",
          "6103:       float sumR = 0.f, sumG = 0.f;",
          "6104:       float cnt = 0.f;",
          "6105:       for (int xx = -scale; xx <= scale; xx += scale)",
          "6106:       {",
          "6107:         sumR += row_minus[(x + xx) * 3];",
          "6108:         sumR += row_plus[(x + xx) * 3];",
          "6109:         sumG += row_minus[(x + xx) * 3 + 1];",
          "6110:         sumG += row_plus[(x + xx) * 3 + 1];",
          "6111:         cnt += 1.f;",
          "6112:         if (xx)",
          "6113:         {",
          "6114:           cnt += 1.f;",
          "6115:           sumR += row0[(x + xx) * 3];",
          "6116:           sumG += row0[(x + xx) * 3 + 1];",
          "6117:         }",
          "6118:       }",
          "6119:       pixel00[0] = sumR / 8.f;",
          "6120:       pixel00[1] = sumG / 8.f;",
          "6122:       if (scale == 2)",
          "6123:       {",
          "6124:         uint16_t *pixel0B = &row0[x * 3 + 3]; // right pixel",
          "6125:         uint16_t *pixel1B = &row1[x * 3 + 3]; // right pixel",
          "6126:         float sumG0 = 0, sumG1 = 0.f;",
          "6127:         float cnt = 0.f;",
          "6128:         for (int xx = -scale; xx <= scale; xx += scale)",
          "6129:         {",
          "6130:           sumG0 += row_minus1[(x + xx) * 3 + 2];",
          "6131:           sumG1 += row_plus[(x + xx) * 3 + 2];",
          "6132:           cnt += 1.f;",
          "6133:           if (xx)",
          "6134:           {",
          "6135:             sumG0 += row0[(x + xx) * 3 + 2];",
          "6136:             sumG1 += row1[(x + xx) * 3 + 2];",
          "6137:             cnt += 1.f;",
          "6138:           }",
          "6139:         }",
          "6140:         pixel0B[2] = sumG0 / cnt;",
          "6141:         pixel1B[2] = sumG1 / cnt;",
          "6142:       }",
          "6146:     }",
          "6147:   }",
          "6148: }",
          "6153:   int raise_error = 0;",
          "6154:   x3f_t *x3f = (x3f_t *)_x3f_data;",
          "6155:   if (!x3f)",
          "6156:     return; // No data pointer set",
          "6157:   if (X3F_OK == x3f_load_data(x3f, x3f_get_raw(x3f)))",
          "6158:   {",
          "6159:     x3f_directory_entry_t *DE = x3f_get_raw(x3f);",
          "6160:     x3f_directory_entry_header_t *DEH = &DE->header;",
          "6161:     x3f_image_data_t *ID = &DEH->data_subsection.image_data;",
          "6162:     if (!ID)",
          "6163:       throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "6164:     x3f_quattro_t *Q = ID->quattro;",
          "6165:     x3f_huffman_t *HUF = ID->huffman;",
          "6166:     x3f_true_t *TRU = ID->tru;",
          "6167:     uint16_t *data = NULL;",
          "6168:     if (ID->rows != S.raw_height || ID->columns != S.raw_width)",
          "6169:     {",
          "6170:       raise_error = 1;",
          "6171:       goto end;",
          "6172:     }",
          "6173:     if (HUF != NULL)",
          "6174:       data = HUF->x3rgb16.data;",
          "6175:     if (TRU != NULL)",
          "6176:       data = TRU->x3rgb16.data;",
          "6177:     if (data == NULL)",
          "6178:     {",
          "6179:       raise_error = 1;",
          "6180:       goto end;",
          "6181:     }",
          "6183:     size_t datasize = S.raw_height * S.raw_width * 3 * sizeof(unsigned short);",
          "6184:     S.raw_pitch = S.raw_width * 3 * sizeof(unsigned short);",
          "6185:     if (!(imgdata.rawdata.raw_alloc = malloc(datasize)))",
          "6186:       throw LIBRAW_EXCEPTION_ALLOC;",
          "6188:     imgdata.rawdata.color3_image = (ushort(*)[3])imgdata.rawdata.raw_alloc;",
          "6189:     if (HUF)",
          "6190:       memmove(imgdata.rawdata.raw_alloc, data, datasize);",
          "6191:     else if (TRU && (!Q || !Q->quattro_layout))",
          "6192:       memmove(imgdata.rawdata.raw_alloc, data, datasize);",
          "6193:     else if (TRU && Q)",
          "6194:     {",
          "6197:       for (int prow = 0; prow < TRU->x3rgb16.rows && prow < S.raw_height / 2; prow++)",
          "6198:       {",
          "6199:         ushort(*destrow)[3] =",
          "6200:             (unsigned short(*)[3]) & imgdata.rawdata.color3_image[prow * 2 * S.raw_pitch / 3 / sizeof(ushort)][0];",
          "6201:         ushort(*srcrow)[3] = (unsigned short(*)[3]) & data[prow * TRU->x3rgb16.row_stride];",
          "6202:         for (int pcol = 0; pcol < TRU->x3rgb16.columns && pcol < S.raw_width / 2; pcol++)",
          "6204:           destrow[pcol * 2][0] = srcrow[pcol][0];",
          "6205:           destrow[pcol * 2][1] = srcrow[pcol][1];",
          "6207:       }",
          "6208:       for (int row = 0; row < Q->top16.rows && row < S.raw_height; row++)",
          "6209:       {",
          "6210:         ushort(*destrow)[3] =",
          "6211:             (unsigned short(*)[3]) & imgdata.rawdata.color3_image[row * S.raw_pitch / 3 / sizeof(ushort)][0];",
          "6212:         ushort(*srcrow) = (unsigned short *)&Q->top16.data[row * Q->top16.columns];",
          "6213:         for (int col = 0; col < Q->top16.columns && col < S.raw_width; col++)",
          "6214:           destrow[col][2] = srcrow[col];",
          "6215:       }",
          "6216:     }",
          "6219:     if (TRU && Q && (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_DP2Q_INTERPOLATEAF))",
          "6220:     {",
          "6221:       if (imgdata.sizes.raw_width == 5888 && imgdata.sizes.raw_height == 3672) // dpN Quattro normal",
          "6222:       {",
          "6223:         x3f_dpq_interpolate_af(32, 8, 2);",
          "6224:       }",
          "6225:       else if (imgdata.sizes.raw_width == 5888 && imgdata.sizes.raw_height == 3776) // sd Quattro normal raw",
          "6226:       {",
          "6227:         x3f_dpq_interpolate_af_sd(216, 464, imgdata.sizes.raw_width - 1, 3312, 16, 32, 2);",
          "6228:       }",
          "6229:       else if (imgdata.sizes.raw_width == 6656 && imgdata.sizes.raw_height == 4480) // sd Quattro H normal raw",
          "6230:       {",
          "6231:         x3f_dpq_interpolate_af_sd(232, 592, imgdata.sizes.raw_width - 1, 3888, 16, 32, 2);",
          "6232:       }",
          "6233:       else if (imgdata.sizes.raw_width == 3328 && imgdata.sizes.raw_height == 2240) // sd Quattro H half size",
          "6234:       {",
          "6235:         x3f_dpq_interpolate_af_sd(116, 296, imgdata.sizes.raw_width - 1, 2200, 8, 16, 1);",
          "6236:       }",
          "6237:       else if (imgdata.sizes.raw_width == 5504 && imgdata.sizes.raw_height == 3680) // sd Quattro H APS-C raw",
          "6238:       {",
          "6239:         x3f_dpq_interpolate_af_sd(8, 192, imgdata.sizes.raw_width - 1, 3185, 16, 32, 2);",
          "6240:       }",
          "6241:       else if (imgdata.sizes.raw_width == 2752 && imgdata.sizes.raw_height == 1840) // sd Quattro H APS-C half size",
          "6242:       {",
          "6243:         x3f_dpq_interpolate_af_sd(4, 96, imgdata.sizes.raw_width - 1, 1800, 8, 16, 1);",
          "6244:       }",
          "6245:       else if (imgdata.sizes.raw_width == 2944 && imgdata.sizes.raw_height == 1836) // dpN Quattro small raw",
          "6246:       {",
          "6247:         x3f_dpq_interpolate_af(16, 4, 1);",
          "6248:       }",
          "6249:       else if (imgdata.sizes.raw_width == 2944 && imgdata.sizes.raw_height == 1888) // sd Quattro small",
          "6250:       {",
          "6251:         x3f_dpq_interpolate_af_sd(108, 232, imgdata.sizes.raw_width - 1, 1656, 8, 16, 1);",
          "6252:       }",
          "6253:     }",
          "6255:     if (TRU && Q && Q->quattro_layout && (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_DP2Q_INTERPOLATERG))",
          "6256:       x3f_dpq_interpolate_rg();",
          "6261:   if (raise_error)",
          "",
          "---------------"
        ],
        "src/libraw_datastream.cpp||src/libraw_datastream.cpp": [
          "File: src/libraw_datastream.cpp -> src/libraw_datastream.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #ifdef WIN32",
          "19: #ifdef __MINGW32__",
          "22: #endif",
          "23: #endif",
          "",
          "[Removed Lines]",
          "20:     #define _WIN32_WINNT 0x0500",
          "21:     #include <stdexcept>",
          "",
          "[Added Lines]",
          "20: #define _WIN32_WINNT 0x0500",
          "21: #include <stdexcept>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "38: #define NO_JPEG",
          "39: #endif",
          "42: {",
          "46: }",
          "50: {",
          "53: }",
          "57: LibRaw_file_datastream::~LibRaw_file_datastream()",
          "58: {",
          "60: }",
          "62: LibRaw_file_datastream::LibRaw_file_datastream(const char *fname)",
          "65: #ifdef WIN32",
          "67: #endif",
          "69: {",
          "72: #ifndef WIN32",
          "76: #else",
          "87:     }",
          "88: }",
          "89: #if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)",
          "91: {",
          "93:     {",
          "102:     }",
          "103: }",
          "108: #endif",
          "118: {",
          "122: #if defined(WIN32SECURECALLS) && (_MSC_VER < 1600)",
          "124: #else",
          "187: }",
          "192: }",
          "195: int LibRaw_file_datastream::subfile_open(const char *fn)",
          "196: {",
          "211: }",
          "213: #if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)",
          "214: int LibRaw_file_datastream::subfile_open(const wchar_t *fn)",
          "215: {",
          "230: }",
          "231: #endif",
          "234: void LibRaw_file_datastream::subfile_close()",
          "238: }",
          "240: #undef LR_STREAM_CHK",
          "243: {",
          "244: #ifdef NO_JASPER",
          "246: #else",
          "247: #if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)",
          "254: #endif",
          "258: #endif",
          "259: }",
          "",
          "[Removed Lines]",
          "41: int LibRaw_abstract_datastream::tempbuffer_open(void  *buf, size_t size)",
          "43:     if(substream) return EBUSY;",
          "44:     substream = new LibRaw_buffer_datastream(buf,size);",
          "45:     return substream?0:EINVAL;",
          "49: void LibRaw_abstract_datastream::tempbuffer_close()",
          "51:     if(substream) delete substream;",
          "52:     substream = NULL;",
          "59:   if(jas_file) fclose(jas_file);",
          "63:     :filename(fname)",
          "64:     ,_fsize(0)",
          "66:     ,wfilename()",
          "68:     ,jas_file(NULL)",
          "70:   if (filename.size()>0)",
          "71:     {",
          "73:       struct stat st;",
          "74:       if(!stat(filename.c_str(),&st))",
          "75:         _fsize = st.st_size;",
          "77:       struct _stati64 st;",
          "78:       if(!_stati64(filename.c_str(),&st))",
          "79:         _fsize = st.st_size;",
          "80: #endif",
          "82:       std::auto_ptr<std::filebuf> buf(new std::filebuf());",
          "83:       buf->open(filename.c_str(), std::ios_base::in | std::ios_base::binary);",
          "84:       if (buf->is_open()) {",
          "85:         f = buf;",
          "86:       }",
          "90: LibRaw_file_datastream::LibRaw_file_datastream(const wchar_t *fname) : filename(),wfilename(fname),jas_file(NULL),_fsize(0)",
          "92:   if (wfilename.size()>0)",
          "94:       struct _stati64 st;",
          "95:       if(!_wstati64(wfilename.c_str(),&st))",
          "96:         _fsize = st.st_size;",
          "97:       std::auto_ptr<std::filebuf> buf(new std::filebuf());",
          "98:       buf->open(wfilename.c_str(), std::ios_base::in | std::ios_base::binary);",
          "99:       if (buf->is_open()) {",
          "100:         f = buf;",
          "101:       }",
          "104: const wchar_t *LibRaw_file_datastream::wfname()",
          "105: {",
          "106:   return wfilename.size()>0?wfilename.c_str():NULL;",
          "107: }",
          "110:  int LibRaw_file_datastream::valid()",
          "111: {",
          "112:     return f.get() ? 1 : 0;",
          "113: }",
          "115: #define LR_STREAM_CHK() do {if(!f.get()) throw LIBRAW_EXCEPTION_IO_EOF;}while(0)",
          "117: int LibRaw_file_datastream::read(void * ptr,size_t size, size_t nmemb)",
          "119:     if(substream) return substream->read(ptr,size,nmemb);",
          "123:     LR_STREAM_CHK(); return int(f->_Sgetn_s(static_cast<char*>(ptr), nmemb * size,nmemb * size) / (size>0?size:1));",
          "125:     LR_STREAM_CHK(); return int(f->sgetn(static_cast<char*>(ptr), std::streamsize(nmemb * size)) / (size>0?size:1));",
          "126: #endif",
          "127: }",
          "129: int LibRaw_file_datastream::eof()",
          "130: {",
          "131:     if(substream) return substream->eof();",
          "132:     LR_STREAM_CHK(); return f->sgetc() == EOF;",
          "133: }",
          "135: int LibRaw_file_datastream::seek(INT64 o, int whence)",
          "136: {",
          "137:     if(substream) return substream->seek(o,whence);",
          "138:     LR_STREAM_CHK();",
          "139:     std::ios_base::seekdir dir;",
          "140:     switch (whence)",
          "141:         {",
          "142:         case SEEK_SET: dir = std::ios_base::beg; break;",
          "143:         case SEEK_CUR: dir = std::ios_base::cur; break;",
          "144:         case SEEK_END: dir = std::ios_base::end; break;",
          "145:         default: dir = std::ios_base::beg;",
          "146:         }",
          "147:     return f->pubseekoff((long)o, dir) < 0;",
          "148: }",
          "150: INT64 LibRaw_file_datastream::tell()",
          "151: {",
          "152:     if(substream) return substream->tell();",
          "153:     LR_STREAM_CHK(); return f->pubseekoff(0, std::ios_base::cur);",
          "154: }",
          "156: char* LibRaw_file_datastream::gets(char *str, int sz)",
          "157: {",
          "158:     if(substream) return substream->gets(str,sz);",
          "159:     LR_STREAM_CHK();",
          "160:     std::istream is(f.get());",
          "161:     is.getline(str, sz);",
          "162:     if (is.fail()) return 0;",
          "163:     return str;",
          "164: }",
          "166: int LibRaw_file_datastream::scanf_one(const char *fmt, void*val)",
          "167: {",
          "168:     if(substream) return substream->scanf_one(fmt,val);",
          "169:     LR_STREAM_CHK();",
          "171:     std::istream is(f.get());",
          "174:     if (strcmp(fmt, \"%d\") == 0) {",
          "175:         int d;",
          "176:         is >> d;",
          "177:         if (is.fail()) return EOF;",
          "179:     } else {",
          "180:         float f;",
          "181:         is >> f;",
          "182:         if (is.fail()) return EOF;",
          "184:     }",
          "186:     return 1;",
          "189: const char* LibRaw_file_datastream::fname()",
          "190: {",
          "191:   return filename.size()>0?filename.c_str():NULL;",
          "197:     LR_STREAM_CHK();",
          "198:     if (saved_f.get()) return EBUSY;",
          "199:     saved_f = f;",
          "200:         std::auto_ptr<std::filebuf> buf(new std::filebuf());",
          "202:         buf->open(fn, std::ios_base::in | std::ios_base::binary);",
          "203:         if (!buf->is_open()) {",
          "204:             f = saved_f;",
          "205:             return ENOENT;",
          "206:         } else {",
          "207:             f = buf;",
          "208:         }",
          "210:         return 0;",
          "216:  LR_STREAM_CHK();",
          "217:  if (saved_f.get()) return EBUSY;",
          "218:  saved_f = f;",
          "219:  std::auto_ptr<std::filebuf> buf(new std::filebuf());",
          "221:  buf->open(fn, std::ios_base::in | std::ios_base::binary);",
          "222:  if (!buf->is_open()) {",
          "223:   f = saved_f;",
          "224:   return ENOENT;",
          "225:  } else {",
          "226:   f = buf;",
          "227:  }",
          "229:  return 0;",
          "235: {",
          "236:     if (!saved_f.get()) return;",
          "237:     f = saved_f;",
          "242: void * LibRaw_file_datastream::make_jas_stream()",
          "245:     return NULL;",
          "248:  if(wfname())",
          "249:  {",
          "250:   jas_file = _wfopen(wfname(),L\"rb\");",
          "251:   return jas_stream_fdopen(fileno(jas_file),\"rb\");",
          "252:  }",
          "253:  else",
          "255:  {",
          "256:   return jas_stream_fopen(fname(),\"rb\");",
          "257:  }",
          "",
          "[Added Lines]",
          "41: int LibRaw_abstract_datastream::tempbuffer_open(void *buf, size_t size)",
          "43:   if (substream)",
          "44:     return EBUSY;",
          "45:   substream = new LibRaw_buffer_datastream(buf, size);",
          "46:   return substream ? 0 : EINVAL;",
          "49: void LibRaw_abstract_datastream::tempbuffer_close()",
          "51:   if (substream)",
          "52:     delete substream;",
          "53:   substream = NULL;",
          "60:   if (jas_file)",
          "61:     fclose(jas_file);",
          "65:     : filename(fname), _fsize(0)",
          "67:       ,",
          "68:       wfilename()",
          "70:       ,",
          "71:       jas_file(NULL)",
          "73:   if (filename.size() > 0)",
          "74:   {",
          "76:     struct stat st;",
          "77:     if (!stat(filename.c_str(), &st))",
          "78:       _fsize = st.st_size;",
          "80:     struct _stati64 st;",
          "81:     if (!_stati64(filename.c_str(), &st))",
          "82:       _fsize = st.st_size;",
          "83: #endif",
          "85:     std::auto_ptr<std::filebuf> buf(new std::filebuf());",
          "86:     buf->open(filename.c_str(), std::ios_base::in | std::ios_base::binary);",
          "87:     if (buf->is_open())",
          "88:     {",
          "89:       f = buf;",
          "91:   }",
          "94: LibRaw_file_datastream::LibRaw_file_datastream(const wchar_t *fname)",
          "95:     : filename(), wfilename(fname), jas_file(NULL), _fsize(0)",
          "97:   if (wfilename.size() > 0)",
          "98:   {",
          "99:     struct _stati64 st;",
          "100:     if (!_wstati64(wfilename.c_str(), &st))",
          "101:       _fsize = st.st_size;",
          "102:     std::auto_ptr<std::filebuf> buf(new std::filebuf());",
          "103:     buf->open(wfilename.c_str(), std::ios_base::in | std::ios_base::binary);",
          "104:     if (buf->is_open())",
          "106:       f = buf;",
          "108:   }",
          "110: const wchar_t *LibRaw_file_datastream::wfname() { return wfilename.size() > 0 ? wfilename.c_str() : NULL; }",
          "113: int LibRaw_file_datastream::valid() { return f.get() ? 1 : 0; }",
          "115: #define LR_STREAM_CHK()                                                                                                \\",
          "116:   do                                                                                                                   \\",
          "117:   {                                                                                                                    \\",
          "118:     if (!f.get())                                                                                                      \\",
          "119:       throw LIBRAW_EXCEPTION_IO_EOF;                                                                                   \\",
          "120:   } while (0)",
          "122: int LibRaw_file_datastream::read(void *ptr, size_t size, size_t nmemb)",
          "124:   if (substream)",
          "125:     return substream->read(ptr, size, nmemb);",
          "129:   LR_STREAM_CHK();",
          "130:   return int(f->_Sgetn_s(static_cast<char *>(ptr), nmemb * size, nmemb * size) / (size > 0 ? size : 1));",
          "132:   LR_STREAM_CHK();",
          "133:   return int(f->sgetn(static_cast<char *>(ptr), std::streamsize(nmemb * size)) / (size > 0 ? size : 1));",
          "134: #endif",
          "137: int LibRaw_file_datastream::eof()",
          "138: {",
          "139:   if (substream)",
          "140:     return substream->eof();",
          "141:   LR_STREAM_CHK();",
          "142:   return f->sgetc() == EOF;",
          "145: int LibRaw_file_datastream::seek(INT64 o, int whence)",
          "146: {",
          "147:   if (substream)",
          "148:     return substream->seek(o, whence);",
          "149:   LR_STREAM_CHK();",
          "150:   std::ios_base::seekdir dir;",
          "151:   switch (whence)",
          "152:   {",
          "153:   case SEEK_SET:",
          "154:     dir = std::ios_base::beg;",
          "155:     break;",
          "156:   case SEEK_CUR:",
          "157:     dir = std::ios_base::cur;",
          "158:     break;",
          "159:   case SEEK_END:",
          "160:     dir = std::ios_base::end;",
          "161:     break;",
          "162:   default:",
          "163:     dir = std::ios_base::beg;",
          "164:   }",
          "165:   return f->pubseekoff((long)o, dir) < 0;",
          "166: }",
          "168: INT64 LibRaw_file_datastream::tell()",
          "169: {",
          "170:   if (substream)",
          "171:     return substream->tell();",
          "172:   LR_STREAM_CHK();",
          "173:   return f->pubseekoff(0, std::ios_base::cur);",
          "174: }",
          "176: char *LibRaw_file_datastream::gets(char *str, int sz)",
          "177: {",
          "178:   if (substream)",
          "179:     return substream->gets(str, sz);",
          "180:   LR_STREAM_CHK();",
          "181:   std::istream is(f.get());",
          "182:   is.getline(str, sz);",
          "183:   if (is.fail())",
          "184:     return 0;",
          "185:   return str;",
          "186: }",
          "188: int LibRaw_file_datastream::scanf_one(const char *fmt, void *val)",
          "189: {",
          "190:   if (substream)",
          "191:     return substream->scanf_one(fmt, val);",
          "192:   LR_STREAM_CHK();",
          "194:   std::istream is(f.get());",
          "197:   if (strcmp(fmt, \"%d\") == 0)",
          "198:   {",
          "199:     int d;",
          "200:     is >> d;",
          "201:     if (is.fail())",
          "202:       return EOF;",
          "204:   }",
          "205:   else",
          "206:   {",
          "207:     float f;",
          "208:     is >> f;",
          "209:     if (is.fail())",
          "210:       return EOF;",
          "212:   }",
          "214:   return 1;",
          "215: }",
          "217: const char *LibRaw_file_datastream::fname() { return filename.size() > 0 ? filename.c_str() : NULL; }",
          "222:   LR_STREAM_CHK();",
          "223:   if (saved_f.get())",
          "224:     return EBUSY;",
          "225:   saved_f = f;",
          "226:   std::auto_ptr<std::filebuf> buf(new std::filebuf());",
          "228:   buf->open(fn, std::ios_base::in | std::ios_base::binary);",
          "229:   if (!buf->is_open())",
          "230:   {",
          "231:     f = saved_f;",
          "232:     return ENOENT;",
          "233:   }",
          "234:   else",
          "235:   {",
          "236:     f = buf;",
          "237:   }",
          "239:   return 0;",
          "245:   LR_STREAM_CHK();",
          "246:   if (saved_f.get())",
          "247:     return EBUSY;",
          "248:   saved_f = f;",
          "249:   std::auto_ptr<std::filebuf> buf(new std::filebuf());",
          "251:   buf->open(fn, std::ios_base::in | std::ios_base::binary);",
          "252:   if (!buf->is_open())",
          "253:   {",
          "254:     f = saved_f;",
          "255:     return ENOENT;",
          "256:   }",
          "257:   else",
          "258:   {",
          "259:     f = buf;",
          "260:   }",
          "262:   return 0;",
          "267: {",
          "268:   if (!saved_f.get())",
          "269:     return;",
          "270:   f = saved_f;",
          "275: void *LibRaw_file_datastream::make_jas_stream()",
          "278:   return NULL;",
          "281:   if (wfname())",
          "282:   {",
          "283:     jas_file = _wfopen(wfname(), L\"rb\");",
          "284:     return jas_stream_fdopen(fileno(jas_file), \"rb\");",
          "285:   }",
          "286:   else",
          "288:   {",
          "289:     return jas_stream_fopen(fname(), \"rb\");",
          "290:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "263: #ifdef NO_JPEG",
          "264:   return -1; // not supported",
          "265: #else",
          "267: #if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)",
          "272:   else",
          "273: #endif",
          "284:   return -1;",
          "285: #endif",
          "286: }",
          "290: LibRaw_buffer_datastream::LibRaw_buffer_datastream(void *buffer, size_t bsize)",
          "293: }",
          "308: }",
          "310: int LibRaw_buffer_datastream::seek(INT64 o, int whence)",
          "350: }",
          "352: INT64 LibRaw_buffer_datastream::tell()",
          "389: #ifndef WIN32SECURECALLS",
          "391: #else",
          "410: }",
          "412: int LibRaw_buffer_datastream::eof()",
          "420: }",
          "424: {",
          "425: #ifdef NO_JASPER",
          "427: #else",
          "429: #endif",
          "430: }",
          "432: int LibRaw_buffer_datastream::jpeg_src(void *jpegdata)",
          "433: {",
          "435:   return -1;",
          "436: #else",
          "439:   return 0;",
          "440: #endif",
          "441: }",
          "449: #ifdef WIN32",
          "451: #endif",
          "455: #ifndef WIN32",
          "459: #else",
          "463: #endif",
          "465: #ifndef WIN32SECURECALLS",
          "467: #else",
          "470: #endif",
          "475: }",
          "477: #if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)",
          "485: #ifndef WIN32SECURECALLS",
          "487: #else",
          "490: #endif",
          "502: }",
          "503: #endif",
          "514: }",
          "516: int LibRaw_bigfile_datastream::eof()",
          "520: }",
          "526: #ifdef WIN32SECURECALLS",
          "528: #else",
          "530: #endif",
          "531: #else",
          "533: #endif",
          "534: }",
          "536: INT64 LibRaw_bigfile_datastream::tell()",
          "540: #ifdef WIN32SECURECALLS",
          "542: #else",
          "544: #endif",
          "545: #else",
          "547: #endif",
          "548: }",
          "554: }",
          "562: #else",
          "564: #endif",
          "566: }",
          "573: int LibRaw_bigfile_datastream::subfile_open(const char *fn)",
          "574: {",
          "577: #ifndef WIN32SECURECALLS",
          "579: #else",
          "590: }",
          "591: #if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)",
          "592: int LibRaw_bigfile_datastream::subfile_open(const wchar_t *fn)",
          "593: {",
          "596: #ifndef WIN32SECURECALLS",
          "598: #else",
          "600: #endif",
          "609: }",
          "610: #endif",
          "613: void LibRaw_bigfile_datastream::subfile_close()",
          "614: {",
          "619: }",
          "622: void *LibRaw_bigfile_datastream::make_jas_stream()",
          "623: {",
          "624: #ifdef NO_JASPER",
          "626: #else",
          "628: #endif",
          "629: }",
          "",
          "[Removed Lines]",
          "266:   if(jas_file) { fclose(jas_file); jas_file = NULL;}",
          "268:   if(wfname())",
          "269:     {",
          "270:       jas_file = _wfopen(wfname(),L\"rb\");",
          "271:     }",
          "274:     {",
          "275:       jas_file = fopen(fname(),\"rb\");",
          "276:     }",
          "277:   if(jas_file)",
          "278:     {",
          "279:       fseek(jas_file,tell(),SEEK_SET);",
          "280:       j_decompress_ptr cinfo = (j_decompress_ptr) jpegdata;",
          "281:       jpeg_stdio_src(cinfo,jas_file);",
          "282:       return 0; // OK",
          "283:     }",
          "291: {",
          "292:     buf = (unsigned char*)buffer; streampos = 0; streamsize = bsize;",
          "295: LibRaw_buffer_datastream::~LibRaw_buffer_datastream(){}",
          "297: int LibRaw_buffer_datastream::read(void * ptr,size_t sz, size_t nmemb)",
          "298: {",
          "299:     if(substream) return substream->read(ptr,sz,nmemb);",
          "300:     size_t to_read = sz*nmemb;",
          "301:     if(to_read > streamsize - streampos)",
          "302:         to_read = streamsize-streampos;",
          "303:     if(to_read<1)",
          "304:         return 0;",
          "305:     memmove(ptr,buf+streampos,to_read);",
          "306:     streampos+=to_read;",
          "307:     return int((to_read+sz-1)/(sz>0?sz:1));",
          "311: {",
          "312:     if(substream) return substream->seek(o,whence);",
          "313:     switch(whence)",
          "314:         {",
          "315:         case SEEK_SET:",
          "316:             if(o<0)",
          "317:                 streampos = 0;",
          "318:             else if (size_t(o) > streamsize)",
          "319:                 streampos = streamsize;",
          "320:             else",
          "321:                 streampos = size_t(o);",
          "322:             return 0;",
          "323:         case SEEK_CUR:",
          "324:             if(o<0)",
          "325:                 {",
          "326:                     if(size_t(-o) >= streampos)",
          "327:                         streampos = 0;",
          "328:                     else",
          "329:                         streampos += (size_t)o;",
          "330:                 }",
          "331:             else if (o>0)",
          "332:                 {",
          "333:                     if(o+streampos> streamsize)",
          "334:                         streampos = streamsize;",
          "335:                     else",
          "336:                         streampos += (size_t)o;",
          "337:                 }",
          "338:             return 0;",
          "339:         case SEEK_END:",
          "340:             if(o>0)",
          "341:                 streampos = streamsize;",
          "342:             else if ( size_t(-o) > streamsize)",
          "343:                 streampos = 0;",
          "344:             else",
          "345:                 streampos = streamsize+(size_t)o;",
          "346:             return 0;",
          "347:         default:",
          "348:             return 0;",
          "349:         }",
          "353: {",
          "354:     if(substream) return substream->tell();",
          "355:     return INT64(streampos);",
          "356: }",
          "358: char* LibRaw_buffer_datastream::gets(char *s, int sz)",
          "359: {",
          "360:     if (substream) return substream->gets(s,sz);",
          "361:     unsigned char *psrc,*pdest,*str;",
          "362:     str = (unsigned char *)s;",
          "363:     psrc = buf+streampos;",
          "364:     pdest = str;",
          "365:     while ( (size_t(psrc - buf) < streamsize)",
          "366:             &&",
          "367:             ((pdest-str)<sz)",
          "368:         )",
          "369:         {",
          "371:             if(*psrc == '\\n')",
          "372:                 break;",
          "373:             psrc++;",
          "374:             pdest++;",
          "375:         }",
          "376:     if(size_t(psrc-buf) < streamsize)",
          "377:         psrc++;",
          "378:     if((pdest-str)<sz)",
          "380:     streampos = psrc - buf;",
          "381:     return s;",
          "382: }",
          "384: int LibRaw_buffer_datastream::scanf_one(const char *fmt, void* val)",
          "385: {",
          "386:     if(substream) return substream->scanf_one(fmt,val);",
          "387:     int scanf_res;",
          "388:     if(streampos>streamsize) return 0;",
          "390:     scanf_res = sscanf((char*)(buf+streampos),fmt,val);",
          "392:     scanf_res = sscanf_s((char*)(buf+streampos),fmt,val);",
          "393: #endif",
          "394:     if(scanf_res>0)",
          "395:         {",
          "396:             int xcnt=0;",
          "397:             while(streampos<streamsize)",
          "398:                 {",
          "399:                     streampos++;",
          "400:                     xcnt++;",
          "401:                     if(buf[streampos] == 0",
          "402:                        || buf[streampos]==' '",
          "403:                        || buf[streampos]=='\\t'",
          "404:                        || buf[streampos]=='\\n'",
          "405:                        || xcnt>24)",
          "406:                         break;",
          "407:                 }",
          "408:         }",
          "409:     return scanf_res;",
          "413: {",
          "414:     if(substream) return substream->eof();",
          "415:     return streampos >= streamsize;",
          "416: }",
          "417:  int LibRaw_buffer_datastream::valid()",
          "418: {",
          "419:     return buf?1:0;",
          "423: void * LibRaw_buffer_datastream::make_jas_stream()",
          "426:     return NULL;",
          "428:     return jas_stream_memopen((char*)buf+streampos,streamsize-streampos);",
          "434: #if defined(NO_JPEG) || !defined (USE_JPEG)",
          "437:   j_decompress_ptr cinfo = (j_decompress_ptr) jpegdata;",
          "438:   jpeg_mem_src(cinfo,(unsigned char*)buf+streampos,streamsize-streampos);",
          "448: LibRaw_bigfile_datastream::LibRaw_bigfile_datastream(const char *fname): filename(fname)",
          "450:  ,wfilename()",
          "452: {",
          "453:   if(filename.size()>0)",
          "454:     {",
          "456:       struct stat st;",
          "457:       if(!stat(filename.c_str(),&st))",
          "458:         _fsize = st.st_size;",
          "460:       struct _stati64 st;",
          "461:       if(!_stati64(filename.c_str(),&st))",
          "462:         _fsize = st.st_size;",
          "466:       f = fopen(fname,\"rb\");",
          "468:       if(fopen_s(&f,fname,\"rb\"))",
          "469:         f = 0;",
          "471:     }",
          "472:     else",
          "473:       {filename=std::string();f=0;}",
          "474:     sav=0;",
          "478: LibRaw_bigfile_datastream::LibRaw_bigfile_datastream(const wchar_t *fname) : filename(),wfilename(fname)",
          "479: {",
          "480:   if(wfilename.size()>0)",
          "481:     {",
          "482:       struct _stati64 st;",
          "483:       if(!_wstati64(wfilename.c_str(),&st))",
          "484:         _fsize = st.st_size;",
          "486:       f = _wfopen(wfilename.c_str(),L\"rb\");",
          "488:       if(_wfopen_s(&f,fname,L\"rb\"))",
          "489:         f = 0;",
          "491:     }",
          "492:   else",
          "493:     {",
          "494:       wfilename=std::wstring();",
          "495:       f=0;",
          "496:     }",
          "497:   sav=0;",
          "498: }",
          "499: const wchar_t *LibRaw_bigfile_datastream::wfname()",
          "500: {",
          "501:   return wfilename.size()>0?wfilename.c_str():NULL;",
          "505: LibRaw_bigfile_datastream::~LibRaw_bigfile_datastream() {if(f)fclose(f); if(sav)fclose(sav);}",
          "506: int         LibRaw_bigfile_datastream::valid() { return f?1:0;}",
          "508: #define LR_BF_CHK() do {if(!f) throw LIBRAW_EXCEPTION_IO_EOF;}while(0)",
          "510: int LibRaw_bigfile_datastream::read(void * ptr,size_t size, size_t nmemb)",
          "511: {",
          "512:     LR_BF_CHK();",
          "513:     return substream?substream->read(ptr,size,nmemb):int(fread(ptr,size,nmemb,f));",
          "517: {",
          "518:     LR_BF_CHK();",
          "519:     return substream?substream->eof():feof(f);",
          "522: int     LibRaw_bigfile_datastream:: seek(INT64 o, int whence)",
          "523: {",
          "524:     LR_BF_CHK();",
          "525: #if defined (WIN32)",
          "527:     return substream?substream->seek(o,whence):_fseeki64(f,o,whence);",
          "529:     return substream?substream->seek(o,whence):fseek(f,(long)o,whence);",
          "532:     return substream?substream->seek(o,whence):fseeko(f,o,whence);",
          "537: {",
          "538:     LR_BF_CHK();",
          "539: #if defined (WIN32)",
          "541:     return substream?substream->tell():_ftelli64(f);",
          "543:     return substream?substream->tell():ftell(f);",
          "546:     return substream?substream->tell():ftello(f);",
          "550: char* LibRaw_bigfile_datastream::gets(char *str, int sz)",
          "551: {",
          "552:     LR_BF_CHK();",
          "553:     return substream?substream->gets(str,sz):fgets(str,sz,f);",
          "556: int LibRaw_bigfile_datastream::scanf_one(const char *fmt, void*val)",
          "557: {",
          "558:     LR_BF_CHK();",
          "559:     return substream?substream->scanf_one(fmt,val):",
          "560: #ifndef WIN32SECURECALLS",
          "561:         fscanf(f,fmt,val)",
          "563:         fscanf_s(f,fmt,val)",
          "565:         ;",
          "568: const char *LibRaw_bigfile_datastream::fname()",
          "569: {",
          "570:   return filename.size()>0?filename.c_str():NULL;",
          "571: }",
          "575:     if(sav) return EBUSY;",
          "576:     sav = f;",
          "578:     f = fopen(fn,\"rb\");",
          "580:     fopen_s(&f,fn,\"rb\");",
          "581: #endif",
          "582:     if(!f)",
          "583:         {",
          "584:             f = sav;",
          "585:             sav = NULL;",
          "586:             return ENOENT;",
          "587:         }",
          "588:     else",
          "589:         return 0;",
          "594:  if(sav) return EBUSY;",
          "595:  sav = f;",
          "597:  f = _wfopen(fn,L\"rb\");",
          "599:  _wfopen_s(&f,fn,L\"rb\");",
          "601:  if(!f)",
          "602:  {",
          "603:   f = sav;",
          "604:   sav = NULL;",
          "605:   return ENOENT;",
          "606:  }",
          "607:  else",
          "608:   return 0;",
          "615:     if(!sav) return;",
          "616:     fclose(f);",
          "617:     f = sav;",
          "618:     sav = 0;",
          "625:     return NULL;",
          "627:     return jas_stream_fdopen(fileno(f),\"rb\");",
          "",
          "[Added Lines]",
          "299:   if (jas_file)",
          "300:   {",
          "301:     fclose(jas_file);",
          "302:     jas_file = NULL;",
          "303:   }",
          "305:   if (wfname())",
          "306:   {",
          "307:     jas_file = _wfopen(wfname(), L\"rb\");",
          "308:   }",
          "311:   {",
          "312:     jas_file = fopen(fname(), \"rb\");",
          "313:   }",
          "314:   if (jas_file)",
          "315:   {",
          "316:     fseek(jas_file, tell(), SEEK_SET);",
          "317:     j_decompress_ptr cinfo = (j_decompress_ptr)jpegdata;",
          "318:     jpeg_stdio_src(cinfo, jas_file);",
          "319:     return 0; // OK",
          "320:   }",
          "327: {",
          "328:   buf = (unsigned char *)buffer;",
          "329:   streampos = 0;",
          "330:   streamsize = bsize;",
          "333: LibRaw_buffer_datastream::~LibRaw_buffer_datastream() {}",
          "335: int LibRaw_buffer_datastream::read(void *ptr, size_t sz, size_t nmemb)",
          "336: {",
          "337:   if (substream)",
          "338:     return substream->read(ptr, sz, nmemb);",
          "339:   size_t to_read = sz * nmemb;",
          "340:   if (to_read > streamsize - streampos)",
          "341:     to_read = streamsize - streampos;",
          "342:   if (to_read < 1)",
          "343:     return 0;",
          "344:   memmove(ptr, buf + streampos, to_read);",
          "345:   streampos += to_read;",
          "346:   return int((to_read + sz - 1) / (sz > 0 ? sz : 1));",
          "350: {",
          "351:   if (substream)",
          "352:     return substream->seek(o, whence);",
          "353:   switch (whence)",
          "354:   {",
          "355:   case SEEK_SET:",
          "356:     if (o < 0)",
          "357:       streampos = 0;",
          "358:     else if (size_t(o) > streamsize)",
          "359:       streampos = streamsize;",
          "360:     else",
          "361:       streampos = size_t(o);",
          "362:     return 0;",
          "363:   case SEEK_CUR:",
          "364:     if (o < 0)",
          "365:     {",
          "366:       if (size_t(-o) >= streampos)",
          "367:         streampos = 0;",
          "368:       else",
          "369:         streampos += (size_t)o;",
          "370:     }",
          "371:     else if (o > 0)",
          "372:     {",
          "373:       if (o + streampos > streamsize)",
          "374:         streampos = streamsize;",
          "375:       else",
          "376:         streampos += (size_t)o;",
          "377:     }",
          "378:     return 0;",
          "379:   case SEEK_END:",
          "380:     if (o > 0)",
          "381:       streampos = streamsize;",
          "382:     else if (size_t(-o) > streamsize)",
          "383:       streampos = 0;",
          "384:     else",
          "385:       streampos = streamsize + (size_t)o;",
          "386:     return 0;",
          "387:   default:",
          "388:     return 0;",
          "389:   }",
          "393: {",
          "394:   if (substream)",
          "395:     return substream->tell();",
          "396:   return INT64(streampos);",
          "397: }",
          "399: char *LibRaw_buffer_datastream::gets(char *s, int sz)",
          "400: {",
          "401:   if (substream)",
          "402:     return substream->gets(s, sz);",
          "403:   unsigned char *psrc, *pdest, *str;",
          "404:   str = (unsigned char *)s;",
          "405:   psrc = buf + streampos;",
          "406:   pdest = str;",
          "407:   while ((size_t(psrc - buf) < streamsize) && ((pdest - str) < sz))",
          "408:   {",
          "410:     if (*psrc == '\\n')",
          "411:       break;",
          "412:     psrc++;",
          "413:     pdest++;",
          "414:   }",
          "415:   if (size_t(psrc - buf) < streamsize)",
          "416:     psrc++;",
          "417:   if ((pdest - str) < sz)",
          "419:   streampos = psrc - buf;",
          "420:   return s;",
          "421: }",
          "423: int LibRaw_buffer_datastream::scanf_one(const char *fmt, void *val)",
          "424: {",
          "425:   if (substream)",
          "426:     return substream->scanf_one(fmt, val);",
          "427:   int scanf_res;",
          "428:   if (streampos > streamsize)",
          "429:     return 0;",
          "431:   scanf_res = sscanf((char *)(buf + streampos), fmt, val);",
          "433:   scanf_res = sscanf_s((char *)(buf + streampos), fmt, val);",
          "434: #endif",
          "435:   if (scanf_res > 0)",
          "436:   {",
          "437:     int xcnt = 0;",
          "438:     while (streampos < streamsize)",
          "439:     {",
          "440:       streampos++;",
          "441:       xcnt++;",
          "442:       if (buf[streampos] == 0 || buf[streampos] == ' ' || buf[streampos] == '\\t' || buf[streampos] == '\\n' || xcnt > 24)",
          "443:         break;",
          "444:     }",
          "445:   }",
          "446:   return scanf_res;",
          "450: {",
          "451:   if (substream)",
          "452:     return substream->eof();",
          "453:   return streampos >= streamsize;",
          "455: int LibRaw_buffer_datastream::valid() { return buf ? 1 : 0; }",
          "457: void *LibRaw_buffer_datastream::make_jas_stream()",
          "460:   return NULL;",
          "462:   return jas_stream_memopen((char *)buf + streampos, streamsize - streampos);",
          "468: #if defined(NO_JPEG) || !defined(USE_JPEG)",
          "471:   j_decompress_ptr cinfo = (j_decompress_ptr)jpegdata;",
          "472:   jpeg_mem_src(cinfo, (unsigned char *)buf + streampos, streamsize - streampos);",
          "480: LibRaw_bigfile_datastream::LibRaw_bigfile_datastream(const char *fname)",
          "481:     : filename(fname)",
          "483:       ,",
          "484:       wfilename()",
          "486: {",
          "487:   if (filename.size() > 0)",
          "488:   {",
          "490:     struct stat st;",
          "491:     if (!stat(filename.c_str(), &st))",
          "492:       _fsize = st.st_size;",
          "494:     struct _stati64 st;",
          "495:     if (!_stati64(filename.c_str(), &st))",
          "496:       _fsize = st.st_size;",
          "500:     f = fopen(fname, \"rb\");",
          "502:     if (fopen_s(&f, fname, \"rb\"))",
          "503:       f = 0;",
          "505:   }",
          "506:   else",
          "507:   {",
          "508:     filename = std::string();",
          "509:     f = 0;",
          "510:   }",
          "511:   sav = 0;",
          "515: LibRaw_bigfile_datastream::LibRaw_bigfile_datastream(const wchar_t *fname) : filename(), wfilename(fname)",
          "516: {",
          "517:   if (wfilename.size() > 0)",
          "518:   {",
          "519:     struct _stati64 st;",
          "520:     if (!_wstati64(wfilename.c_str(), &st))",
          "521:       _fsize = st.st_size;",
          "523:     f = _wfopen(wfilename.c_str(), L\"rb\");",
          "525:     if (_wfopen_s(&f, fname, L\"rb\"))",
          "526:       f = 0;",
          "528:   }",
          "529:   else",
          "530:   {",
          "531:     wfilename = std::wstring();",
          "532:     f = 0;",
          "533:   }",
          "534:   sav = 0;",
          "536: const wchar_t *LibRaw_bigfile_datastream::wfname() { return wfilename.size() > 0 ? wfilename.c_str() : NULL; }",
          "539: LibRaw_bigfile_datastream::~LibRaw_bigfile_datastream()",
          "540: {",
          "541:   if (f)",
          "542:     fclose(f);",
          "543:   if (sav)",
          "544:     fclose(sav);",
          "545: }",
          "546: int LibRaw_bigfile_datastream::valid() { return f ? 1 : 0; }",
          "548: #define LR_BF_CHK()                                                                                                    \\",
          "549:   do                                                                                                                   \\",
          "550:   {                                                                                                                    \\",
          "551:     if (!f)                                                                                                            \\",
          "552:       throw LIBRAW_EXCEPTION_IO_EOF;                                                                                   \\",
          "553:   } while (0)",
          "555: int LibRaw_bigfile_datastream::read(void *ptr, size_t size, size_t nmemb)",
          "556: {",
          "557:   LR_BF_CHK();",
          "558:   return substream ? substream->read(ptr, size, nmemb) : int(fread(ptr, size, nmemb, f));",
          "562: {",
          "563:   LR_BF_CHK();",
          "564:   return substream ? substream->eof() : feof(f);",
          "567: int LibRaw_bigfile_datastream::seek(INT64 o, int whence)",
          "568: {",
          "569:   LR_BF_CHK();",
          "570: #if defined(WIN32)",
          "572:   return substream ? substream->seek(o, whence) : _fseeki64(f, o, whence);",
          "574:   return substream ? substream->seek(o, whence) : fseek(f, (long)o, whence);",
          "577:   return substream ? substream->seek(o, whence) : fseeko(f, o, whence);",
          "582: {",
          "583:   LR_BF_CHK();",
          "584: #if defined(WIN32)",
          "586:   return substream ? substream->tell() : _ftelli64(f);",
          "588:   return substream ? substream->tell() : ftell(f);",
          "591:   return substream ? substream->tell() : ftello(f);",
          "595: char *LibRaw_bigfile_datastream::gets(char *str, int sz)",
          "596: {",
          "597:   LR_BF_CHK();",
          "598:   return substream ? substream->gets(str, sz) : fgets(str, sz, f);",
          "601: int LibRaw_bigfile_datastream::scanf_one(const char *fmt, void *val)",
          "602: {",
          "603:   LR_BF_CHK();",
          "604:   return substream ? substream->scanf_one(fmt, val) :",
          "605: #ifndef WIN32SECURECALLS",
          "606:                    fscanf(f, fmt, val)",
          "608:                    fscanf_s(f, fmt, val)",
          "610:       ;",
          "613: const char *LibRaw_bigfile_datastream::fname() { return filename.size() > 0 ? filename.c_str() : NULL; }",
          "617:   if (sav)",
          "618:     return EBUSY;",
          "619:   sav = f;",
          "621:   f = fopen(fn, \"rb\");",
          "623:   fopen_s(&f, fn, \"rb\");",
          "624: #endif",
          "625:   if (!f)",
          "626:   {",
          "627:     f = sav;",
          "628:     sav = NULL;",
          "629:     return ENOENT;",
          "630:   }",
          "631:   else",
          "632:     return 0;",
          "637:   if (sav)",
          "638:     return EBUSY;",
          "639:   sav = f;",
          "641:   f = _wfopen(fn, L\"rb\");",
          "643:   _wfopen_s(&f, fn, L\"rb\");",
          "645:   if (!f)",
          "646:   {",
          "647:     f = sav;",
          "648:     sav = NULL;",
          "649:     return ENOENT;",
          "650:   }",
          "651:   else",
          "652:     return 0;",
          "658:   if (!sav)",
          "659:     return;",
          "660:   fclose(f);",
          "661:   f = sav;",
          "662:   sav = 0;",
          "668:   return NULL;",
          "670:   return jas_stream_fdopen(fileno(f), \"rb\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "633: #ifdef NO_JPEG",
          "634:   return -1;",
          "635: #else",
          "639:   return 0; // OK",
          "640: #endif",
          "641: }",
          "645: #ifdef WIN32",
          "651: {",
          "660: }",
          "663: LibRaw_windows_datastream::LibRaw_windows_datastream(HANDLE hFile)",
          "667: {",
          "670: }",
          "673: LibRaw_windows_datastream::~LibRaw_windows_datastream()",
          "674: {",
          "680: }",
          "682: void LibRaw_windows_datastream::Open(HANDLE hFile)",
          "683: {",
          "",
          "[Removed Lines]",
          "636:   if(!f) return -1;",
          "637:   j_decompress_ptr cinfo = (j_decompress_ptr) jpegdata;",
          "638:   jpeg_stdio_src(cinfo,f);",
          "647: LibRaw_windows_datastream::LibRaw_windows_datastream(const TCHAR* sFile)",
          "648:     : LibRaw_buffer_datastream(NULL, 0)",
          "649:     , hMap_(0)",
          "650:     , pView_(NULL)",
          "652:     HANDLE hFile = CreateFile(sFile, GENERIC_READ, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);",
          "653:     if (hFile == INVALID_HANDLE_VALUE)",
          "654:         throw std::runtime_error(\"failed to open the file\");",
          "656:     try { Open(hFile);  } catch(...) { CloseHandle(hFile); throw; }",
          "658:     CloseHandle(hFile);  // windows will defer the actual closing of this handle until the hMap_ is closed",
          "659:     reconstruct_base();",
          "664:     : LibRaw_buffer_datastream(NULL, 0)",
          "665:     , hMap_(0)",
          "666:     , pView_(NULL)",
          "668:     Open(hFile);",
          "669:     reconstruct_base();",
          "675:     if (pView_ != NULL)",
          "676:         ::UnmapViewOfFile(pView_);",
          "678:     if (hMap_ != 0)",
          "679:         ::CloseHandle(hMap_);",
          "685:     hMap_ = ::CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, 0);",
          "686:     if (hMap_ == NULL) throw std::runtime_error(\"failed to create file mapping\");",
          "689:     if (!::GetFileSizeEx(hFile, (PLARGE_INTEGER)&cbView_))",
          "690:         throw std::runtime_error(\"failed to get the file size\");",
          "692:     pView_ = ::MapViewOfFile(hMap_, FILE_MAP_READ, 0, 0, (size_t)cbView_);",
          "693:     if (pView_ == NULL)",
          "694:         throw std::runtime_error(\"failed to map the file\");",
          "695: }",
          "698: #endif",
          "",
          "[Added Lines]",
          "679:   if (!f)",
          "680:     return -1;",
          "681:   j_decompress_ptr cinfo = (j_decompress_ptr)jpegdata;",
          "682:   jpeg_stdio_src(cinfo, f);",
          "690: LibRaw_windows_datastream::LibRaw_windows_datastream(const TCHAR *sFile)",
          "691:     : LibRaw_buffer_datastream(NULL, 0), hMap_(0), pView_(NULL)",
          "693:   HANDLE hFile = CreateFile(sFile, GENERIC_READ, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);",
          "694:   if (hFile == INVALID_HANDLE_VALUE)",
          "695:     throw std::runtime_error(\"failed to open the file\");",
          "697:   try",
          "698:   {",
          "699:     Open(hFile);",
          "700:   }",
          "701:   catch (...)",
          "702:   {",
          "703:     CloseHandle(hFile);",
          "704:     throw;",
          "705:   }",
          "707:   CloseHandle(hFile); // windows will defer the actual closing of this handle until the hMap_ is closed",
          "708:   reconstruct_base();",
          "713:     : LibRaw_buffer_datastream(NULL, 0), hMap_(0), pView_(NULL)",
          "715:   Open(hFile);",
          "716:   reconstruct_base();",
          "722:   if (pView_ != NULL)",
          "723:     ::UnmapViewOfFile(pView_);",
          "725:   if (hMap_ != 0)",
          "726:     ::CloseHandle(hMap_);",
          "732:   hMap_ = ::CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, 0);",
          "733:   if (hMap_ == NULL)",
          "734:     throw std::runtime_error(\"failed to create file mapping\");",
          "737:   if (!::GetFileSizeEx(hFile, (PLARGE_INTEGER)&cbView_))",
          "738:     throw std::runtime_error(\"failed to get the file size\");",
          "740:   pView_ = ::MapViewOfFile(hMap_, FILE_MAP_READ, 0, 0, (size_t)cbView_);",
          "741:   if (pView_ == NULL)",
          "742:     throw std::runtime_error(\"failed to map the file\");",
          "743: }",
          "745: #endif",
          "",
          "---------------"
        ],
        "src/libraw_xtrans_compressed.cpp||src/libraw_xtrans_compressed.cpp": [
          "File: src/libraw_xtrans_compressed.cpp -> src/libraw_xtrans_compressed.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #undef _min",
          "24: #endif",
          "25: #define _abs(x) (((int)(x) ^ ((int)(x) >> 31)) - ((int)(x) >> 31))",
          "31: };",
          "33: enum _xt_lines",
          "34: {",
          "39: };",
          "55: };",
          "57: static unsigned sgetn(int n, uchar *s)",
          "58: {",
          "63: }",
          "66: {",
          "125: }",
          "127: #define XTRANS_BUF_SIZE 0x10000",
          "129: static inline void fuji_fill_buffer(struct xtrans_block *info)",
          "130: {",
          "135: #ifdef LIBRAW_USE_OPENMP",
          "136: #pragma omp critical",
          "137: #endif",
          "139: #ifndef LIBRAW_USE_OPENMP",
          "141: #endif",
          "144: #ifndef LIBRAW_USE_OPENMP",
          "146: #endif",
          "153: }",
          "156: {",
          "186: }",
          "189: {",
          "236: }",
          "242: {",
          "259: }",
          "262: {",
          "290: }",
          "292: static inline int bitDiff(int value1, int value2)",
          "293: {",
          "301: }",
          "304: {",
          "375: }",
          "378: {",
          "443: }",
          "446: {",
          "461: }",
          "463: static void xtrans_extend_generic(ushort *linebuf[_ltotal], int line_width, int start, int end)",
          "464: {",
          "470: }",
          "472: static void xtrans_extend_red(ushort *linebuf[_ltotal], int line_width)",
          "473: {",
          "475: }",
          "477: static void xtrans_extend_green(ushort *linebuf[_ltotal], int line_width)",
          "478: {",
          "480: }",
          "482: static void xtrans_extend_blue(ushort *linebuf[_ltotal], int line_width)",
          "483: {",
          "485: }",
          "488: {",
          "651: }",
          "654: {",
          "694: }",
          "696: void LibRaw::xtrans_compressed_load_raw()",
          "697: {",
          "738: }",
          "741: {",
          "743: #ifdef LIBRAW_USE_OPENMP",
          "744: #pragma omp parallel for private(cur_block)",
          "745: #endif",
          "750: }",
          "752: void LibRaw::parse_xtrans_header()",
          "753: {",
          "808: }",
          "811: #undef _abs",
          "812: #undef _min",
          "",
          "[Removed Lines]",
          "26: #define _min(a,b) ((a) < (b) ? (a) : (b))",
          "28: struct int_pair {",
          "29:  int value1;",
          "30:  int value2;",
          "35:  _R0=0,_R1,_R2,_R3,_R4,",
          "36:  _G0,_G1,_G2,_G3,_G4,_G5,_G6,_G7,",
          "37:  _B0,_B1,_B2,_B3,_B4,",
          "38:  _ltotal",
          "42: struct xtrans_block {",
          "43:  int         cur_bit;         // current bit being read (from left to right)",
          "44:  int         cur_pos;         // current position in a buffer",
          "45:  INT64       cur_buf_offset;  // offset of this buffer in a file",
          "46:  unsigned max_read_size;  // Amount of data to be read",
          "47:  int         cur_buf_size;    // buffer size",
          "48:  uchar       *cur_buf;        // currently read block",
          "49:  bool  lastlast;",
          "50:  LibRaw_abstract_datastream *input;",
          "51:  struct int_pair grad_even[3][41];    // tables of gradients",
          "52:  struct int_pair grad_odd[3][41];",
          "53:  ushort  *linealloc;",
          "54:  ushort      *linebuf[_ltotal];",
          "59:  unsigned result = 0;",
          "60:  while (n-- > 0)",
          "61:   result = (result<<8) | (*s++);",
          "62:  return result;",
          "65: void LibRaw::init_xtrans(struct xtrans_params* info)",
          "67:  int cur_val, i;",
          "68:  char *qt;",
          "70:  if (libraw_internal_data.unpacker_data.fuji_block_width % 3)",
          "71:   derror();",
          "73:  info->q_table = (char *) malloc(32768);",
          "74:  merror(info->q_table, \"init_xtrans()\");",
          "76:  info->line_width = (libraw_internal_data.unpacker_data.fuji_block_width*2)/3;",
          "78:  info->q_point[0] = 0;",
          "79:  info->q_point[1] = 0x12;",
          "80:  info->q_point[2] = 0x43;",
          "81:  info->q_point[3] = 0x114;",
          "82:  info->q_point[4] = (1 << libraw_internal_data.unpacker_data.fuji_bits) - 1;",
          "83:  info->min_value = 0x40;",
          "85:  cur_val = -info->q_point[4];",
          "86:  for (qt = info->q_table; cur_val<=info->q_point[4]; ++qt, ++cur_val)",
          "87:  {",
          "88:   if (cur_val<= -info->q_point[3])",
          "90:   else if (cur_val<= -info->q_point[2])",
          "92:   else if (cur_val<= -info->q_point[1])",
          "94:   else if (cur_val< 0)",
          "96:   else if (cur_val== 0)",
          "98:   else if (cur_val< info->q_point[1])",
          "100:   else if (cur_val< info->q_point[2])",
          "102:   else if (cur_val< info->q_point[3])",
          "104:   else",
          "106:  }",
          "109:  if (info->q_point[4] == 0x3FFF)",
          "110:  {",
          "111:   info->total_values = 0x4000;",
          "112:   info->raw_bits = 14;",
          "113:   info->max_bits = 56;",
          "114:   info->maxDiff = 256;",
          "115:  }",
          "116:  else if (info->q_point[4] == 0xFFF)",
          "117:  {",
          "118:   info->total_values = 4096;",
          "119:   info->raw_bits = 12;",
          "120:   info->max_bits = 48;",
          "121:   info->maxDiff = 64;",
          "122:  }",
          "123:  else",
          "124:   derror();",
          "131:  if (info->cur_pos >= info->cur_buf_size)",
          "132:  {",
          "133:   info->cur_pos = 0;",
          "134:   info->cur_buf_offset += info->cur_buf_size;",
          "138:   {",
          "140:    info->input->lock();",
          "142:    info->input->seek(info->cur_buf_offset, SEEK_SET);",
          "143:    info->cur_buf_size=info->input->read(info->cur_buf, 1, _min(info->max_read_size,XTRANS_BUF_SIZE));",
          "145:    info->input->unlock();",
          "147:    if(info->cur_buf_size<1 && !info->lastlast) // nothing read",
          "148:     throw LIBRAW_EXCEPTION_IO_EOF;",
          "149:    info->max_read_size -= info->cur_buf_size;",
          "151:   }",
          "152:  }",
          "155: void LibRaw::init_xtrans_block(struct xtrans_block* info, const struct xtrans_params *params, INT64 raw_offset, unsigned dsize)",
          "157:  info->linealloc = (ushort*)calloc(sizeof(ushort),_ltotal*(params->line_width+2));",
          "158:  merror(info->linealloc, \"init_xtrans_block()\");",
          "160:  INT64 fsize = libraw_internal_data.internal_data.input->size();",
          "161:  info->max_read_size = _min(unsigned(fsize-raw_offset),dsize+16); // Data size may be incorrect?",
          "162:  info->lastlast = false;",
          "164:  info->input = libraw_internal_data.internal_data.input;",
          "165:  info->linebuf[_R0] = info->linealloc;",
          "166:  for(int i = _R1; i<=_B4;i++)",
          "167:   info->linebuf[i] = info->linebuf[i-1] + params->line_width + 2;",
          "170:  info->cur_buf = (uchar*)malloc(XTRANS_BUF_SIZE);",
          "171:  merror(info->cur_buf, \"init_xtrans_block()\");",
          "172:  info->cur_bit = 0;",
          "173:  info->cur_pos = 0;",
          "174:  info->cur_buf_offset = raw_offset;",
          "175:  for(int j=0; j < 3; j++)",
          "176:   for (int i=0; i<41; i++)",
          "177:   {",
          "178:    info->grad_even[j][i].value1 = params->maxDiff;",
          "179:    info->grad_even[j][i].value2 = 1;",
          "180:    info->grad_odd[j][i].value1 = params->maxDiff;",
          "181:    info->grad_odd[j][i].value2 = 1;",
          "182:   }",
          "184:  info->cur_buf_size = 0;",
          "185:  fuji_fill_buffer(info);",
          "188: void LibRaw::copy_line_to_xtrans(struct xtrans_block* info, int cur_line, int cur_block, int cur_block_width)",
          "190:  ushort *lineBufB[3];",
          "191:  ushort *lineBufG[6];",
          "192:  ushort *lineBufR[3];",
          "193:  unsigned pixel_count;",
          "194:  ushort* line_buf;",
          "195:  int index;",
          "197:  int offset =libraw_internal_data.unpacker_data.fuji_block_width*cur_block + 6 * imgdata.sizes.raw_width * cur_line;",
          "198:  ushort* raw_block_data = imgdata.rawdata.raw_image + offset;",
          "199:  int row_count = 0;",
          "201:  for(int i = 0; i<3; i++)",
          "202:  {",
          "203:   lineBufR[i] = info->linebuf[_R2+i] + 1;",
          "204:   lineBufB[i] = info->linebuf[_B2+i] + 1;",
          "205:  }",
          "206:  for(int i = 0; i<6; i++)",
          "207:   lineBufG[i] = info->linebuf[_G2+i] + 1;",
          "209:  while (row_count < 6)",
          "210:  {",
          "211:   pixel_count = 0;",
          "212:   while (pixel_count < cur_block_width)",
          "213:   {",
          "214:    switch (imgdata.idata.xtrans_abs[row_count][(pixel_count % 6)])",
          "215:    {",
          "216:    case 0:     // red",
          "217:     line_buf = lineBufR[row_count >> 1];",
          "218:     break;",
          "219:    case 1:     // green",
          "220:    default: // to make static analyzer happy",
          "221:     line_buf = lineBufG[row_count];",
          "222:     break;",
          "223:    case 2:     // blue",
          "224:     line_buf = lineBufB[row_count >> 1];",
          "225:     break;",
          "226:    }",
          "228:    index = (((pixel_count*2/3) & 0x7FFFFFFE) | ((pixel_count % 3) & 1)) + ((pixel_count % 3) >> 1);",
          "229:    raw_block_data[pixel_count] = line_buf[index];",
          "231:    ++pixel_count;",
          "232:   }",
          "233:   ++row_count;",
          "234:   raw_block_data += imgdata.sizes.raw_width;",
          "235:  }",
          "238: #define fuji_quant_gradient(i,v1,v2) (9*i->q_table[i->q_point[4]+(v1)] + i->q_table[i->q_point[4]+(v2)])",
          "241: static inline void fuji_zerobits(struct xtrans_block* info, int *count)",
          "243:  uchar zero = 0;",
          "245:  while (zero == 0)",
          "246:  {",
          "247:   zero = (info->cur_buf[info->cur_pos] >> (7 - info->cur_bit)) & 1;",
          "248:   info->cur_bit++;",
          "249:   info->cur_bit &= 7;",
          "250:   if (!info->cur_bit)",
          "251:   {",
          "252:    ++info->cur_pos;",
          "253:    fuji_fill_buffer(info);",
          "254:   }",
          "255:   if (zero)",
          "256:    break;",
          "257:   ++*count;",
          "258:  }",
          "261: static inline void fuji_read_code(struct xtrans_block* info, int *data, int bits_to_read)",
          "263:  uchar bits_left = bits_to_read;",
          "264:  uchar bits_left_in_byte = 8 - (info->cur_bit & 7);",
          "266:  if (!bits_to_read)",
          "267:   return;",
          "268:  if (bits_to_read >= bits_left_in_byte)",
          "269:  {",
          "270:   do",
          "271:   {",
          "273:    bits_left -= bits_left_in_byte;",
          "275:    ++info->cur_pos;",
          "276:    fuji_fill_buffer(info);",
          "277:    bits_left_in_byte = 8;",
          "278:   }",
          "279:   while (bits_left >= 8);",
          "280:  }",
          "281:  if (!bits_left)",
          "282:  {",
          "283:   info->cur_bit = (8 - (bits_left_in_byte & 7)) & 7;",
          "284:   return;",
          "285:  }",
          "287:  bits_left_in_byte -= bits_left;",
          "289:  info->cur_bit = (8 - (bits_left_in_byte & 7)) & 7;",
          "294:  int decBits = 0;",
          "295:  if ( value2 < value1 )",
          "296:   while (decBits <= 12 &&",
          "297:    (value2 << ++decBits)",
          "298:    <  value1)",
          "299:    ;",
          "300:  return decBits;",
          "303: static inline int fuji_decode_sample_even(struct xtrans_block* info, const struct xtrans_params * params, ushort* line_buf, int pos, struct int_pair* grads)",
          "305:  int interp_val = 0;",
          "307:  int errcnt=0;",
          "309:  int sample=0, code=0;",
          "310:  ushort* line_buf_cur = line_buf + pos;",
          "311:  int Rb = line_buf_cur[-2 - params->line_width];",
          "312:  int Rc = line_buf_cur[-3 - params->line_width];",
          "313:  int Rd = line_buf_cur[-1 - params->line_width];",
          "314:  int Rf = line_buf_cur[-4 - 2*params->line_width];",
          "316:  int grad, gradient, diffRcRb, diffRfRb, diffRdRb;",
          "318:  grad = fuji_quant_gradient(params, Rb - Rf, Rc - Rb);",
          "319:  gradient = _abs(grad);",
          "320:  diffRcRb = _abs(Rc - Rb);",
          "321:  diffRfRb = _abs(Rf - Rb);",
          "322:  diffRdRb = _abs(Rd - Rb);",
          "324:  if ( diffRcRb > diffRfRb && diffRcRb > diffRdRb )",
          "325:   interp_val = Rf + Rd + 2 * Rb;",
          "326:  else if ( diffRdRb > diffRcRb && diffRdRb > diffRfRb )",
          "327:   interp_val = Rf + Rc + 2 * Rb;",
          "328:  else",
          "329:   interp_val = Rd + Rc + 2 * Rb;",
          "332:  fuji_zerobits(info, &sample);",
          "334:  if (sample < params->max_bits - params->raw_bits - 1)",
          "335:  {",
          "336:   int decBits = bitDiff(grads[gradient].value1, grads[gradient].value2);",
          "337:   fuji_read_code(info, &code, decBits);",
          "338:   code += sample << decBits;",
          "339:  }",
          "340:  else",
          "341:  {",
          "342:   fuji_read_code(info, &code, params->raw_bits);",
          "343:   code++;",
          "344:  }",
          "346:  if (code < 0 || code >= params->total_values)",
          "347:   errcnt++;",
          "349:  if (code & 1)",
          "350:   code = -1 - code/2;",
          "351:  else",
          "352:   code /= 2;",
          "354:  grads[gradient].value1 += _abs(code);",
          "355:  if (grads[gradient].value2 == params->min_value )",
          "356:  {",
          "357:   grads[gradient].value1 >>= 1;",
          "358:   grads[gradient].value2 >>= 1;",
          "359:  }",
          "360:  grads[gradient].value2++;",
          "361:  if (grad < 0)",
          "362:   interp_val = (interp_val >> 2) - code;",
          "363:  else",
          "364:   interp_val = (interp_val >> 2) + code;",
          "365:  if ( interp_val < 0 )",
          "366:   interp_val += params->total_values;",
          "367:  else if (interp_val > params->q_point[4])",
          "368:   interp_val -= params->total_values;",
          "370:  if ( interp_val >= 0 )",
          "371:   line_buf_cur[0] = _min(interp_val, params->q_point[4]);",
          "372:  else",
          "373:   line_buf_cur[0] = 0;",
          "374:  return errcnt;",
          "377: static inline int fuji_decode_sample_odd(struct xtrans_block* info, const struct xtrans_params * params, ushort* line_buf, int pos, struct int_pair* grads)",
          "379:  int interp_val = 0;",
          "380:  int errcnt = 0;",
          "382:  int sample=0, code=0;",
          "383:  ushort* line_buf_cur = line_buf + pos;",
          "384:  int Ra = line_buf_cur[-1];",
          "385:  int Rb = line_buf_cur[-2 - params->line_width];",
          "386:  int Rc = line_buf_cur[-3 - params->line_width];",
          "387:  int Rd = line_buf_cur[-1 - params->line_width];",
          "388:  int Rg = line_buf_cur[1];",
          "390:  int grad, gradient;",
          "392:  grad = fuji_quant_gradient(params, Rb - Rc, Rc - Ra);",
          "393:  gradient = _abs(grad);",
          "395:  if ((Rb > Rc && Rb > Rd) || (Rb < Rc && Rb < Rd))",
          "396:   interp_val = (Rg + Ra + 2 * Rb) >> 2;",
          "397:  else",
          "398:   interp_val = (Ra + Rg) >> 1;",
          "400:  fuji_zerobits(info, &sample);",
          "402:  if (sample < params->max_bits - params->raw_bits - 1)",
          "403:  {",
          "404:   int decBits = bitDiff(grads[gradient].value1, grads[gradient].value2);",
          "405:   fuji_read_code(info, &code, decBits);",
          "406:   code += sample << decBits;",
          "407:  }",
          "408:  else",
          "409:  {",
          "410:   fuji_read_code(info, &code, params->raw_bits);",
          "411:   code++;",
          "412:  }",
          "414:  if (code < 0 || code >= params->total_values)",
          "415:   errcnt++;",
          "417:  if (code & 1)",
          "418:   code = -1 - code/2;",
          "419:  else",
          "420:   code /= 2;",
          "422:  grads[gradient].value1 += _abs(code);",
          "423:  if (grads[gradient].value2 == params->min_value)",
          "424:  {",
          "425:   grads[gradient].value1 >>= 1;",
          "426:   grads[gradient].value2 >>= 1;",
          "427:  }",
          "428:  grads[gradient].value2++;",
          "429:  if (grad < 0)",
          "430:   interp_val -= code;",
          "431:  else",
          "432:   interp_val += code;",
          "433:  if ( interp_val < 0 )",
          "434:   interp_val += params->total_values;",
          "435:  else if (interp_val > params->q_point[4])",
          "436:   interp_val -= params->total_values;",
          "438:  if ( interp_val >= 0 )",
          "439:   line_buf_cur[0] = _min(interp_val, params->q_point[4]);",
          "440:  else",
          "441:   line_buf_cur[0] = 0;",
          "442:  return errcnt;",
          "445: static void fuji_decode_interpolation_even(int line_width, ushort* line_buf, int pos)",
          "447:  ushort* line_buf_cur = line_buf + pos;",
          "448:  int Rb = line_buf_cur[-2 - line_width];",
          "449:  int Rc = line_buf_cur[-3 - line_width];",
          "450:  int Rd = line_buf_cur[-1 - line_width];",
          "451:  int Rf = line_buf_cur[-4 - 2*line_width];",
          "452:  int diffRcRb = _abs(Rc - Rb);",
          "453:  int diffRfRb = _abs(Rf - Rb);",
          "454:  int diffRdRb = _abs(Rd - Rb);",
          "455:  if ( diffRcRb > diffRfRb && diffRcRb > diffRdRb )",
          "457:  else if ( diffRdRb > diffRcRb && diffRdRb > diffRfRb )",
          "459:  else",
          "465:  for(int i = start; i<= end; i++)",
          "466:  {",
          "467:   linebuf[i][0]             = linebuf[i-1][1];",
          "468:   linebuf[i][line_width + 1] = linebuf[i-1][line_width];",
          "469:  }",
          "474:  xtrans_extend_generic(linebuf,line_width,_R2,_R4);",
          "479:  xtrans_extend_generic(linebuf,line_width,_G2,_G7);",
          "484:  xtrans_extend_generic(linebuf,line_width,_B2,_B4);",
          "487: void LibRaw::xtrans_decode_block(struct xtrans_block* info, const struct xtrans_params *params, int cur_line)",
          "489:  int r_even_pos = 0, r_odd_pos = 1;",
          "490:  int g_even_pos = 0, g_odd_pos = 1;",
          "491:  int b_even_pos = 0, b_odd_pos = 1;",
          "493:  int errcnt = 0;",
          "495:  const int line_width = params->line_width;",
          "497:  while (g_even_pos < line_width || g_odd_pos < line_width)",
          "498:  {",
          "499:   if (g_even_pos < line_width)",
          "500:   {",
          "501:    fuji_decode_interpolation_even(line_width, info->linebuf[_R2] + 1, r_even_pos);",
          "502:    r_even_pos += 2;",
          "503:    errcnt+=fuji_decode_sample_even(info, params, info->linebuf[_G2] + 1, g_even_pos, info->grad_even[0]);",
          "504:    g_even_pos += 2;",
          "505:   }",
          "506:   if (g_even_pos > 8)",
          "507:   {",
          "508:    errcnt+=fuji_decode_sample_odd(info, params, info->linebuf[_R2] + 1, r_odd_pos, info->grad_odd[0]);",
          "509:    r_odd_pos += 2;",
          "510:    errcnt+=fuji_decode_sample_odd(info, params, info->linebuf[_G2] + 1, g_odd_pos, info->grad_odd[0]);",
          "511:    g_odd_pos += 2;",
          "512:   }",
          "513:  }",
          "515:  xtrans_extend_red(info->linebuf,line_width);",
          "516:  xtrans_extend_green(info->linebuf,line_width);",
          "518:  g_even_pos = 0, g_odd_pos = 1;",
          "520:  while (g_even_pos < line_width || g_odd_pos < line_width)",
          "521:  {",
          "522:   if (g_even_pos < line_width)",
          "523:   {",
          "524:    errcnt+=fuji_decode_sample_even(info, params, info->linebuf[_G3] + 1, g_even_pos, info->grad_even[1]);",
          "525:    g_even_pos += 2;",
          "526:    fuji_decode_interpolation_even(line_width,info->linebuf[_B2] + 1, b_even_pos);",
          "527:    b_even_pos += 2;",
          "528:   }",
          "529:   if (g_even_pos > 8)",
          "530:   {",
          "531:    errcnt+=fuji_decode_sample_odd(info,params, info->linebuf[_G3] + 1, g_odd_pos, info->grad_odd[1]);",
          "532:    g_odd_pos += 2;",
          "533:    errcnt+=fuji_decode_sample_odd(info,params, info->linebuf[_B2] + 1, b_odd_pos, info->grad_odd[1]);",
          "534:    b_odd_pos += 2;",
          "535:   }",
          "536:  }",
          "538:  xtrans_extend_green(info->linebuf,line_width);",
          "539:  xtrans_extend_blue(info->linebuf,line_width);",
          "541:  r_even_pos = 0, r_odd_pos = 1;",
          "542:  g_even_pos = 0, g_odd_pos = 1;",
          "544:  while (g_even_pos < line_width || g_odd_pos < line_width)",
          "545:  {",
          "546:   if (g_even_pos < line_width)",
          "547:   {",
          "548:    if (r_even_pos & 3)",
          "549:     errcnt+=fuji_decode_sample_even(info, params, info->linebuf[_R3] + 1, r_even_pos, info->grad_even[2]);",
          "550:    else",
          "551:     fuji_decode_interpolation_even(line_width, info->linebuf[_R3] + 1, r_even_pos);",
          "552:    r_even_pos += 2;",
          "553:    fuji_decode_interpolation_even(line_width, info->linebuf[_G4] + 1, g_even_pos);",
          "554:    g_even_pos += 2;",
          "555:   }",
          "556:   if (g_even_pos > 8)",
          "557:   {",
          "558:    errcnt+=fuji_decode_sample_odd(info, params,info->linebuf[_R3] + 1, r_odd_pos, info->grad_odd[2]);",
          "559:    r_odd_pos += 2;",
          "560:    errcnt+=fuji_decode_sample_odd(info,params, info->linebuf[_G4] + 1, g_odd_pos, info->grad_odd[2]);",
          "561:    g_odd_pos += 2;",
          "562:   }",
          "563:  }",
          "565:  xtrans_extend_red(info->linebuf,line_width);",
          "566:  xtrans_extend_green(info->linebuf,line_width);",
          "568:  g_even_pos = 0, g_odd_pos = 1;",
          "569:  b_even_pos = 0, b_odd_pos = 1;",
          "571:  while (g_even_pos < line_width || g_odd_pos < line_width)",
          "572:  {",
          "573:   if (g_even_pos < line_width)",
          "574:   {",
          "575:    errcnt+=fuji_decode_sample_even(info,params, info->linebuf[_G5] + 1, g_even_pos, info->grad_even[0]);",
          "576:    g_even_pos += 2;",
          "577:    if ((b_even_pos & 3) == 2)",
          "578:     fuji_decode_interpolation_even(line_width, info->linebuf[_B3] + 1, b_even_pos);",
          "579:    else",
          "580:     errcnt+=fuji_decode_sample_even(info, params,info->linebuf[_B3] + 1, b_even_pos, info->grad_even[0]);",
          "581:    b_even_pos += 2;",
          "582:   }",
          "583:   if (g_even_pos > 8)",
          "584:   {",
          "585:    errcnt+=fuji_decode_sample_odd(info, params,info->linebuf[_G5] + 1, g_odd_pos, info->grad_odd[0]);",
          "586:    g_odd_pos += 2;",
          "587:    errcnt+=fuji_decode_sample_odd(info, params,info->linebuf[_B3] + 1, b_odd_pos, info->grad_odd[0]);",
          "588:    b_odd_pos += 2;",
          "589:   }",
          "590:  }",
          "592:  xtrans_extend_green(info->linebuf,line_width);",
          "593:  xtrans_extend_blue(info->linebuf,line_width);",
          "595:  r_even_pos = 0, r_odd_pos = 1;",
          "596:  g_even_pos = 0, g_odd_pos = 1;",
          "598:  while (g_even_pos < line_width || g_odd_pos < line_width)",
          "599:  {",
          "600:   if (g_even_pos < line_width)",
          "601:   {",
          "602:    if ((r_even_pos & 3) == 2)",
          "603:     fuji_decode_interpolation_even(line_width, info->linebuf[_R4] + 1, r_even_pos);",
          "604:    else",
          "605:     errcnt+=fuji_decode_sample_even(info,params, info->linebuf[_R4] + 1, r_even_pos, info->grad_even[1]);",
          "606:    r_even_pos += 2;",
          "607:    errcnt+=fuji_decode_sample_even(info,params, info->linebuf[_G6] + 1, g_even_pos, info->grad_even[1]);",
          "608:    g_even_pos += 2;",
          "609:   }",
          "610:   if (g_even_pos > 8)",
          "611:   {",
          "612:    errcnt+=fuji_decode_sample_odd(info,params, info->linebuf[_R4] + 1, r_odd_pos, info->grad_odd[1]);",
          "613:    r_odd_pos += 2;",
          "614:    errcnt+=fuji_decode_sample_odd(info,params, info->linebuf[_G6] + 1, g_odd_pos, info->grad_odd[1]);",
          "615:    g_odd_pos += 2;",
          "616:   }",
          "617:  }",
          "619:  xtrans_extend_red(info->linebuf,line_width);",
          "620:  xtrans_extend_green(info->linebuf,line_width);",
          "622:  g_even_pos = 0, g_odd_pos = 1;",
          "623:  b_even_pos = 0, b_odd_pos = 1;",
          "625:  while (g_even_pos < line_width || g_odd_pos < line_width)",
          "626:  {",
          "627:   if (g_even_pos < line_width)",
          "628:   {",
          "629:    fuji_decode_interpolation_even(line_width, info->linebuf[_G7] + 1, g_even_pos);",
          "630:    g_even_pos += 2;",
          "631:    if (b_even_pos & 3)",
          "632:     errcnt+=fuji_decode_sample_even(info,params, info->linebuf[_B4] + 1, b_even_pos, info->grad_even[2]);",
          "633:    else",
          "634:     fuji_decode_interpolation_even(line_width, info->linebuf[_B4] + 1, b_even_pos);",
          "635:    b_even_pos += 2;",
          "636:   }",
          "637:   if (g_even_pos > 8)",
          "638:   {",
          "639:    errcnt+=fuji_decode_sample_odd(info, params,info->linebuf[_G7] + 1, g_odd_pos, info->grad_odd[2]);",
          "640:    g_odd_pos += 2;",
          "641:    errcnt+=fuji_decode_sample_odd(info, params,info->linebuf[_B4] + 1, b_odd_pos, info->grad_odd[2]);",
          "642:    b_odd_pos += 2;",
          "643:   }",
          "644:  }",
          "646:  xtrans_extend_green(info->linebuf,line_width);",
          "647:  xtrans_extend_blue(info->linebuf,line_width);",
          "649:  if(errcnt)",
          "650:   derror();",
          "653: void LibRaw::xtrans_decode_strip(const struct xtrans_params* info_common, int cur_block, INT64 raw_offset, unsigned dsize)",
          "655:  int cur_block_width, cur_line;",
          "656:  unsigned line_size;",
          "657:  struct xtrans_block info;",
          "659:  init_xtrans_block(&info, info_common, raw_offset,dsize);",
          "660:  line_size = sizeof(ushort)*(info_common->line_width+2);",
          "662:  cur_block_width = libraw_internal_data.unpacker_data.fuji_block_width;",
          "663:  if (cur_block+1 == libraw_internal_data.unpacker_data.fuji_total_blocks)",
          "664:   cur_block_width = imgdata.sizes.raw_width % libraw_internal_data.unpacker_data.fuji_block_width;",
          "666:  struct i_pair",
          "667:  {",
          "668:   int a,b;",
          "669:  };",
          "670:  const i_pair mtable[6] = { {_R0,_R3},{_R1,_R4},{_G0,_G6},{_G1,_G7},{_B0,_B3},{_B1,_B4}},",
          "671:   ztable[3]= {{_R2,3},{_G2,6},{_B2,3}};",
          "672:  for  (cur_line = 0; cur_line < libraw_internal_data.unpacker_data.fuji_total_lines; cur_line++)",
          "673:  {",
          "674:   info.lastlast = (cur_block == libraw_internal_data.unpacker_data.fuji_total_blocks-1) && (cur_line ==libraw_internal_data.unpacker_data.fuji_total_lines-1);",
          "675:   xtrans_decode_block(&info, info_common, cur_line);",
          "678:   for(int i=0; i < 6; i++)",
          "679:    memcpy(info.linebuf[mtable[i].a], info.linebuf[mtable[i].b], line_size);",
          "681:   copy_line_to_xtrans(&info, cur_line, cur_block, cur_block_width);",
          "683:   for(int i=0; i < 3; i++)",
          "684:   {",
          "685:    memset(info.linebuf[ztable[i].a], 0, ztable[i].b*line_size);",
          "686:    info.linebuf[ztable[i].a][0]     = info.linebuf[ztable[i].a-1][1];",
          "687:    info.linebuf[ztable[i].a][info_common->line_width + 1] = info.linebuf[ztable[i].a-1][info_common->line_width];",
          "688:   }",
          "689:  }",
          "692:  free(info.linealloc);",
          "693:  free(info.cur_buf);",
          "698:  struct xtrans_params common_info;",
          "699:  int cur_block;",
          "700:  unsigned line_size, *block_sizes;",
          "701:  INT64 raw_offset, *raw_block_offsets;",
          "704:  init_xtrans(&common_info);",
          "705:  line_size = sizeof(ushort)*(common_info.line_width+2);",
          "708:  block_sizes = (unsigned*) malloc(sizeof(unsigned)* libraw_internal_data.unpacker_data.fuji_total_blocks);",
          "709:  merror(block_sizes, \"xtrans_load_raw()\");",
          "710:  raw_block_offsets = (INT64*) malloc(sizeof(INT64)*libraw_internal_data.unpacker_data.fuji_total_blocks);",
          "711:  merror(raw_block_offsets, \"xtrans_load_raw()\");",
          "713:  raw_offset = sizeof(unsigned)*libraw_internal_data.unpacker_data.fuji_total_blocks;",
          "714:  if (raw_offset & 0xC)",
          "715:   raw_offset +=  0x10 - (raw_offset & 0xC);",
          "717:  raw_offset += libraw_internal_data.unpacker_data.data_offset;",
          "719:  libraw_internal_data.internal_data.input->seek (libraw_internal_data.unpacker_data.data_offset, SEEK_SET);",
          "720:  libraw_internal_data.internal_data.input->read (block_sizes, 1, sizeof(unsigned)*libraw_internal_data.unpacker_data.fuji_total_blocks);",
          "722:  raw_block_offsets[0] = raw_offset;",
          "724:  for (cur_block = 0; cur_block < libraw_internal_data.unpacker_data.fuji_total_blocks; cur_block++)",
          "725:  {",
          "726:   unsigned bsize = sgetn(4, (uchar *)(block_sizes+cur_block));",
          "727:   block_sizes[cur_block] = bsize;",
          "728:  }",
          "730:  for (cur_block = 1; cur_block < libraw_internal_data.unpacker_data.fuji_total_blocks; cur_block++)",
          "731:   raw_block_offsets[cur_block] = raw_block_offsets[cur_block-1] + block_sizes[cur_block-1] ;",
          "733:  xtrans_decode_loop(&common_info,libraw_internal_data.unpacker_data.fuji_total_blocks,raw_block_offsets,block_sizes);",
          "735:  free(block_sizes);",
          "736:  free(raw_block_offsets);",
          "737:  free(common_info.q_table);",
          "740: void LibRaw::xtrans_decode_loop(const struct xtrans_params* common_info, int count, INT64* raw_block_offsets, unsigned *block_sizes)",
          "742:  int cur_block;",
          "746:  for (cur_block = 0; cur_block < count ; cur_block++)",
          "747:  {",
          "748:   xtrans_decode_strip(common_info, cur_block, raw_block_offsets[cur_block], block_sizes[cur_block]);",
          "749:  }",
          "754:  unsigned signature, version, h_raw_type, h_raw_bits,",
          "755:   h_raw_height, h_raw_rounded_width, h_raw_width,",
          "756:   h_block_size, h_blocks_in_row, h_total_lines;",
          "758:  uchar header[16];",
          "760:  libraw_internal_data.internal_data.input->seek(libraw_internal_data.unpacker_data.data_offset,SEEK_SET);",
          "761:  libraw_internal_data.internal_data.input->read(header, 1, sizeof(header));",
          "764:  signature = sgetn(2, header);",
          "765:  version = header[2];",
          "766:  h_raw_type = header[3];",
          "767:  h_raw_bits = header[4];",
          "768:  h_raw_height = sgetn(2, header+5);",
          "769:  h_raw_rounded_width = sgetn(2, header+7);",
          "770:  h_raw_width = sgetn(2, header+9);",
          "771:  h_block_size = sgetn(2, header+11);",
          "772:  h_blocks_in_row = header[13];",
          "773:  h_total_lines = sgetn(2, header+14);",
          "776:  if (signature != 0x4953",
          "777:   || version != 1",
          "778:   || h_raw_height > 0x3000",
          "779:   || h_raw_height < 6",
          "780:   || h_raw_height % 6",
          "781:   || h_raw_width > 0x3000",
          "782:   || h_raw_width < 0x300",
          "783:   || h_raw_width % 24",
          "784:   || h_raw_rounded_width > 0x3000",
          "785:   || h_raw_rounded_width < h_block_size",
          "786:   || h_raw_rounded_width % h_block_size",
          "787:   || h_raw_rounded_width - h_raw_width >= h_block_size",
          "788:   || h_block_size != 0x300",
          "789:   || h_blocks_in_row > 0x10",
          "790:   || h_blocks_in_row == 0",
          "791:   || h_blocks_in_row != h_raw_rounded_width / h_block_size",
          "792:   || h_total_lines > 0x800",
          "793:   || h_total_lines == 0",
          "794:   || h_total_lines != h_raw_height / 6",
          "795:   || (h_raw_bits != 12 && h_raw_bits != 14)",
          "796:   || h_raw_type != 16)",
          "797:   return;",
          "800:  libraw_internal_data.unpacker_data.fuji_total_lines  = h_total_lines;",
          "801:  libraw_internal_data.unpacker_data.fuji_total_blocks = h_blocks_in_row;",
          "802:  libraw_internal_data.unpacker_data.fuji_block_width  = h_block_size;",
          "803:  libraw_internal_data.unpacker_data.fuji_bits         = h_raw_bits;",
          "804:  imgdata.sizes.raw_width         = h_raw_width;",
          "805:  imgdata.sizes.raw_height        = h_raw_height;",
          "806:  libraw_internal_data.unpacker_data.data_offset += 16;",
          "807:  load_raw = &LibRaw::xtrans_compressed_load_raw;",
          "",
          "[Added Lines]",
          "26: #define _min(a, b) ((a) < (b) ? (a) : (b))",
          "28: struct int_pair",
          "29: {",
          "30:   int value1;",
          "31:   int value2;",
          "36:   _R0 = 0,",
          "37:   _R1,",
          "38:   _R2,",
          "39:   _R3,",
          "40:   _R4,",
          "41:   _G0,",
          "42:   _G1,",
          "43:   _G2,",
          "44:   _G3,",
          "45:   _G4,",
          "46:   _G5,",
          "47:   _G6,",
          "48:   _G7,",
          "49:   _B0,",
          "50:   _B1,",
          "51:   _B2,",
          "52:   _B3,",
          "53:   _B4,",
          "54:   _ltotal",
          "57: struct xtrans_block",
          "58: {",
          "59:   int cur_bit;            // current bit being read (from left to right)",
          "60:   int cur_pos;            // current position in a buffer",
          "61:   INT64 cur_buf_offset;   // offset of this buffer in a file",
          "62:   unsigned max_read_size; // Amount of data to be read",
          "63:   int cur_buf_size;       // buffer size",
          "64:   uchar *cur_buf;         // currently read block",
          "65:   bool lastlast;",
          "66:   LibRaw_abstract_datastream *input;",
          "67:   struct int_pair grad_even[3][41]; // tables of gradients",
          "68:   struct int_pair grad_odd[3][41];",
          "69:   ushort *linealloc;",
          "70:   ushort *linebuf[_ltotal];",
          "75:   unsigned result = 0;",
          "76:   while (n-- > 0)",
          "77:     result = (result << 8) | (*s++);",
          "78:   return result;",
          "81: void LibRaw::init_xtrans(struct xtrans_params *info)",
          "83:   int cur_val, i;",
          "84:   char *qt;",
          "86:   if (libraw_internal_data.unpacker_data.fuji_block_width % 3)",
          "87:     derror();",
          "89:   info->q_table = (char *)malloc(32768);",
          "90:   merror(info->q_table, \"init_xtrans()\");",
          "92:   info->line_width = (libraw_internal_data.unpacker_data.fuji_block_width * 2) / 3;",
          "94:   info->q_point[0] = 0;",
          "95:   info->q_point[1] = 0x12;",
          "96:   info->q_point[2] = 0x43;",
          "97:   info->q_point[3] = 0x114;",
          "98:   info->q_point[4] = (1 << libraw_internal_data.unpacker_data.fuji_bits) - 1;",
          "99:   info->min_value = 0x40;",
          "101:   cur_val = -info->q_point[4];",
          "102:   for (qt = info->q_table; cur_val <= info->q_point[4]; ++qt, ++cur_val)",
          "103:   {",
          "104:     if (cur_val <= -info->q_point[3])",
          "106:     else if (cur_val <= -info->q_point[2])",
          "108:     else if (cur_val <= -info->q_point[1])",
          "110:     else if (cur_val < 0)",
          "112:     else if (cur_val == 0)",
          "114:     else if (cur_val < info->q_point[1])",
          "116:     else if (cur_val < info->q_point[2])",
          "118:     else if (cur_val < info->q_point[3])",
          "120:     else",
          "122:   }",
          "125:   if (info->q_point[4] == 0x3FFF)",
          "126:   {",
          "127:     info->total_values = 0x4000;",
          "128:     info->raw_bits = 14;",
          "129:     info->max_bits = 56;",
          "130:     info->maxDiff = 256;",
          "131:   }",
          "132:   else if (info->q_point[4] == 0xFFF)",
          "133:   {",
          "134:     info->total_values = 4096;",
          "135:     info->raw_bits = 12;",
          "136:     info->max_bits = 48;",
          "137:     info->maxDiff = 64;",
          "138:   }",
          "139:   else",
          "140:     derror();",
          "147:   if (info->cur_pos >= info->cur_buf_size)",
          "148:   {",
          "149:     info->cur_pos = 0;",
          "150:     info->cur_buf_offset += info->cur_buf_size;",
          "154:     {",
          "156:       info->input->lock();",
          "158:       info->input->seek(info->cur_buf_offset, SEEK_SET);",
          "159:       info->cur_buf_size = info->input->read(info->cur_buf, 1, _min(info->max_read_size, XTRANS_BUF_SIZE));",
          "161:       info->input->unlock();",
          "163:       if (info->cur_buf_size < 1 && !info->lastlast) // nothing read",
          "164:         throw LIBRAW_EXCEPTION_IO_EOF;",
          "165:       info->max_read_size -= info->cur_buf_size;",
          "166:     }",
          "167:   }",
          "170: void LibRaw::init_xtrans_block(struct xtrans_block *info, const struct xtrans_params *params, INT64 raw_offset,",
          "171:                                unsigned dsize)",
          "173:   info->linealloc = (ushort *)calloc(sizeof(ushort), _ltotal * (params->line_width + 2));",
          "174:   merror(info->linealloc, \"init_xtrans_block()\");",
          "176:   INT64 fsize = libraw_internal_data.internal_data.input->size();",
          "177:   info->max_read_size = _min(unsigned(fsize - raw_offset), dsize + 16); // Data size may be incorrect?",
          "178:   info->lastlast = false;",
          "180:   info->input = libraw_internal_data.internal_data.input;",
          "181:   info->linebuf[_R0] = info->linealloc;",
          "182:   for (int i = _R1; i <= _B4; i++)",
          "183:     info->linebuf[i] = info->linebuf[i - 1] + params->line_width + 2;",
          "186:   info->cur_buf = (uchar *)malloc(XTRANS_BUF_SIZE);",
          "187:   merror(info->cur_buf, \"init_xtrans_block()\");",
          "188:   info->cur_bit = 0;",
          "189:   info->cur_pos = 0;",
          "190:   info->cur_buf_offset = raw_offset;",
          "191:   for (int j = 0; j < 3; j++)",
          "192:     for (int i = 0; i < 41; i++)",
          "193:     {",
          "194:       info->grad_even[j][i].value1 = params->maxDiff;",
          "195:       info->grad_even[j][i].value2 = 1;",
          "196:       info->grad_odd[j][i].value1 = params->maxDiff;",
          "197:       info->grad_odd[j][i].value2 = 1;",
          "198:     }",
          "200:   info->cur_buf_size = 0;",
          "201:   fuji_fill_buffer(info);",
          "204: void LibRaw::copy_line_to_xtrans(struct xtrans_block *info, int cur_line, int cur_block, int cur_block_width)",
          "206:   ushort *lineBufB[3];",
          "207:   ushort *lineBufG[6];",
          "208:   ushort *lineBufR[3];",
          "209:   unsigned pixel_count;",
          "210:   ushort *line_buf;",
          "211:   int index;",
          "213:   int offset = libraw_internal_data.unpacker_data.fuji_block_width * cur_block + 6 * imgdata.sizes.raw_width * cur_line;",
          "214:   ushort *raw_block_data = imgdata.rawdata.raw_image + offset;",
          "215:   int row_count = 0;",
          "217:   for (int i = 0; i < 3; i++)",
          "218:   {",
          "219:     lineBufR[i] = info->linebuf[_R2 + i] + 1;",
          "220:     lineBufB[i] = info->linebuf[_B2 + i] + 1;",
          "221:   }",
          "222:   for (int i = 0; i < 6; i++)",
          "223:     lineBufG[i] = info->linebuf[_G2 + i] + 1;",
          "225:   while (row_count < 6)",
          "226:   {",
          "227:     pixel_count = 0;",
          "228:     while (pixel_count < cur_block_width)",
          "229:     {",
          "230:       switch (imgdata.idata.xtrans_abs[row_count][(pixel_count % 6)])",
          "231:       {",
          "232:       case 0: // red",
          "233:         line_buf = lineBufR[row_count >> 1];",
          "234:         break;",
          "235:       case 1:  // green",
          "236:       default: // to make static analyzer happy",
          "237:         line_buf = lineBufG[row_count];",
          "238:         break;",
          "239:       case 2: // blue",
          "240:         line_buf = lineBufB[row_count >> 1];",
          "241:         break;",
          "242:       }",
          "244:       index = (((pixel_count * 2 / 3) & 0x7FFFFFFE) | ((pixel_count % 3) & 1)) + ((pixel_count % 3) >> 1);",
          "245:       raw_block_data[pixel_count] = line_buf[index];",
          "247:       ++pixel_count;",
          "248:     }",
          "249:     ++row_count;",
          "250:     raw_block_data += imgdata.sizes.raw_width;",
          "251:   }",
          "254: #define fuji_quant_gradient(i, v1, v2) (9 * i->q_table[i->q_point[4] + (v1)] + i->q_table[i->q_point[4] + (v2)])",
          "256: static inline void fuji_zerobits(struct xtrans_block *info, int *count)",
          "258:   uchar zero = 0;",
          "260:   while (zero == 0)",
          "261:   {",
          "262:     zero = (info->cur_buf[info->cur_pos] >> (7 - info->cur_bit)) & 1;",
          "263:     info->cur_bit++;",
          "264:     info->cur_bit &= 7;",
          "265:     if (!info->cur_bit)",
          "266:     {",
          "267:       ++info->cur_pos;",
          "268:       fuji_fill_buffer(info);",
          "269:     }",
          "270:     if (zero)",
          "271:       break;",
          "272:     ++*count;",
          "273:   }",
          "276: static inline void fuji_read_code(struct xtrans_block *info, int *data, int bits_to_read)",
          "278:   uchar bits_left = bits_to_read;",
          "279:   uchar bits_left_in_byte = 8 - (info->cur_bit & 7);",
          "281:   if (!bits_to_read)",
          "282:     return;",
          "283:   if (bits_to_read >= bits_left_in_byte)",
          "284:   {",
          "285:     do",
          "286:     {",
          "288:       bits_left -= bits_left_in_byte;",
          "290:       ++info->cur_pos;",
          "291:       fuji_fill_buffer(info);",
          "292:       bits_left_in_byte = 8;",
          "293:     } while (bits_left >= 8);",
          "294:   }",
          "295:   if (!bits_left)",
          "296:   {",
          "297:     info->cur_bit = (8 - (bits_left_in_byte & 7)) & 7;",
          "298:     return;",
          "299:   }",
          "301:   bits_left_in_byte -= bits_left;",
          "303:   info->cur_bit = (8 - (bits_left_in_byte & 7)) & 7;",
          "308:   int decBits = 0;",
          "309:   if (value2 < value1)",
          "310:     while (decBits <= 12 && (value2 << ++decBits) < value1)",
          "311:       ;",
          "312:   return decBits;",
          "315: static inline int fuji_decode_sample_even(struct xtrans_block *info, const struct xtrans_params *params,",
          "316:                                           ushort *line_buf, int pos, struct int_pair *grads)",
          "318:   int interp_val = 0;",
          "320:   int errcnt = 0;",
          "322:   int sample = 0, code = 0;",
          "323:   ushort *line_buf_cur = line_buf + pos;",
          "324:   int Rb = line_buf_cur[-2 - params->line_width];",
          "325:   int Rc = line_buf_cur[-3 - params->line_width];",
          "326:   int Rd = line_buf_cur[-1 - params->line_width];",
          "327:   int Rf = line_buf_cur[-4 - 2 * params->line_width];",
          "329:   int grad, gradient, diffRcRb, diffRfRb, diffRdRb;",
          "331:   grad = fuji_quant_gradient(params, Rb - Rf, Rc - Rb);",
          "332:   gradient = _abs(grad);",
          "333:   diffRcRb = _abs(Rc - Rb);",
          "334:   diffRfRb = _abs(Rf - Rb);",
          "335:   diffRdRb = _abs(Rd - Rb);",
          "337:   if (diffRcRb > diffRfRb && diffRcRb > diffRdRb)",
          "338:     interp_val = Rf + Rd + 2 * Rb;",
          "339:   else if (diffRdRb > diffRcRb && diffRdRb > diffRfRb)",
          "340:     interp_val = Rf + Rc + 2 * Rb;",
          "341:   else",
          "342:     interp_val = Rd + Rc + 2 * Rb;",
          "344:   fuji_zerobits(info, &sample);",
          "346:   if (sample < params->max_bits - params->raw_bits - 1)",
          "347:   {",
          "348:     int decBits = bitDiff(grads[gradient].value1, grads[gradient].value2);",
          "349:     fuji_read_code(info, &code, decBits);",
          "350:     code += sample << decBits;",
          "351:   }",
          "352:   else",
          "353:   {",
          "354:     fuji_read_code(info, &code, params->raw_bits);",
          "355:     code++;",
          "356:   }",
          "358:   if (code < 0 || code >= params->total_values)",
          "359:     errcnt++;",
          "361:   if (code & 1)",
          "362:     code = -1 - code / 2;",
          "363:   else",
          "364:     code /= 2;",
          "366:   grads[gradient].value1 += _abs(code);",
          "367:   if (grads[gradient].value2 == params->min_value)",
          "368:   {",
          "369:     grads[gradient].value1 >>= 1;",
          "370:     grads[gradient].value2 >>= 1;",
          "371:   }",
          "372:   grads[gradient].value2++;",
          "373:   if (grad < 0)",
          "374:     interp_val = (interp_val >> 2) - code;",
          "375:   else",
          "376:     interp_val = (interp_val >> 2) + code;",
          "377:   if (interp_val < 0)",
          "378:     interp_val += params->total_values;",
          "379:   else if (interp_val > params->q_point[4])",
          "380:     interp_val -= params->total_values;",
          "382:   if (interp_val >= 0)",
          "383:     line_buf_cur[0] = _min(interp_val, params->q_point[4]);",
          "384:   else",
          "385:     line_buf_cur[0] = 0;",
          "386:   return errcnt;",
          "389: static inline int fuji_decode_sample_odd(struct xtrans_block *info, const struct xtrans_params *params,",
          "390:                                          ushort *line_buf, int pos, struct int_pair *grads)",
          "392:   int interp_val = 0;",
          "393:   int errcnt = 0;",
          "395:   int sample = 0, code = 0;",
          "396:   ushort *line_buf_cur = line_buf + pos;",
          "397:   int Ra = line_buf_cur[-1];",
          "398:   int Rb = line_buf_cur[-2 - params->line_width];",
          "399:   int Rc = line_buf_cur[-3 - params->line_width];",
          "400:   int Rd = line_buf_cur[-1 - params->line_width];",
          "401:   int Rg = line_buf_cur[1];",
          "403:   int grad, gradient;",
          "405:   grad = fuji_quant_gradient(params, Rb - Rc, Rc - Ra);",
          "406:   gradient = _abs(grad);",
          "408:   if ((Rb > Rc && Rb > Rd) || (Rb < Rc && Rb < Rd))",
          "409:     interp_val = (Rg + Ra + 2 * Rb) >> 2;",
          "410:   else",
          "411:     interp_val = (Ra + Rg) >> 1;",
          "413:   fuji_zerobits(info, &sample);",
          "415:   if (sample < params->max_bits - params->raw_bits - 1)",
          "416:   {",
          "417:     int decBits = bitDiff(grads[gradient].value1, grads[gradient].value2);",
          "418:     fuji_read_code(info, &code, decBits);",
          "419:     code += sample << decBits;",
          "420:   }",
          "421:   else",
          "422:   {",
          "423:     fuji_read_code(info, &code, params->raw_bits);",
          "424:     code++;",
          "425:   }",
          "427:   if (code < 0 || code >= params->total_values)",
          "428:     errcnt++;",
          "430:   if (code & 1)",
          "431:     code = -1 - code / 2;",
          "432:   else",
          "433:     code /= 2;",
          "435:   grads[gradient].value1 += _abs(code);",
          "436:   if (grads[gradient].value2 == params->min_value)",
          "437:   {",
          "438:     grads[gradient].value1 >>= 1;",
          "439:     grads[gradient].value2 >>= 1;",
          "440:   }",
          "441:   grads[gradient].value2++;",
          "442:   if (grad < 0)",
          "443:     interp_val -= code;",
          "444:   else",
          "445:     interp_val += code;",
          "446:   if (interp_val < 0)",
          "447:     interp_val += params->total_values;",
          "448:   else if (interp_val > params->q_point[4])",
          "449:     interp_val -= params->total_values;",
          "451:   if (interp_val >= 0)",
          "452:     line_buf_cur[0] = _min(interp_val, params->q_point[4]);",
          "453:   else",
          "454:     line_buf_cur[0] = 0;",
          "455:   return errcnt;",
          "458: static void fuji_decode_interpolation_even(int line_width, ushort *line_buf, int pos)",
          "460:   ushort *line_buf_cur = line_buf + pos;",
          "461:   int Rb = line_buf_cur[-2 - line_width];",
          "462:   int Rc = line_buf_cur[-3 - line_width];",
          "463:   int Rd = line_buf_cur[-1 - line_width];",
          "464:   int Rf = line_buf_cur[-4 - 2 * line_width];",
          "465:   int diffRcRb = _abs(Rc - Rb);",
          "466:   int diffRfRb = _abs(Rf - Rb);",
          "467:   int diffRdRb = _abs(Rd - Rb);",
          "468:   if (diffRcRb > diffRfRb && diffRcRb > diffRdRb)",
          "470:   else if (diffRdRb > diffRcRb && diffRdRb > diffRfRb)",
          "472:   else",
          "478:   for (int i = start; i <= end; i++)",
          "479:   {",
          "480:     linebuf[i][0] = linebuf[i - 1][1];",
          "481:     linebuf[i][line_width + 1] = linebuf[i - 1][line_width];",
          "482:   }",
          "487:   xtrans_extend_generic(linebuf, line_width, _R2, _R4);",
          "492:   xtrans_extend_generic(linebuf, line_width, _G2, _G7);",
          "497:   xtrans_extend_generic(linebuf, line_width, _B2, _B4);",
          "500: void LibRaw::xtrans_decode_block(struct xtrans_block *info, const struct xtrans_params *params, int cur_line)",
          "502:   int r_even_pos = 0, r_odd_pos = 1;",
          "503:   int g_even_pos = 0, g_odd_pos = 1;",
          "504:   int b_even_pos = 0, b_odd_pos = 1;",
          "506:   int errcnt = 0;",
          "508:   const int line_width = params->line_width;",
          "510:   while (g_even_pos < line_width || g_odd_pos < line_width)",
          "511:   {",
          "512:     if (g_even_pos < line_width)",
          "513:     {",
          "514:       fuji_decode_interpolation_even(line_width, info->linebuf[_R2] + 1, r_even_pos);",
          "515:       r_even_pos += 2;",
          "516:       errcnt += fuji_decode_sample_even(info, params, info->linebuf[_G2] + 1, g_even_pos, info->grad_even[0]);",
          "517:       g_even_pos += 2;",
          "518:     }",
          "519:     if (g_even_pos > 8)",
          "520:     {",
          "521:       errcnt += fuji_decode_sample_odd(info, params, info->linebuf[_R2] + 1, r_odd_pos, info->grad_odd[0]);",
          "522:       r_odd_pos += 2;",
          "523:       errcnt += fuji_decode_sample_odd(info, params, info->linebuf[_G2] + 1, g_odd_pos, info->grad_odd[0]);",
          "524:       g_odd_pos += 2;",
          "525:     }",
          "526:   }",
          "528:   xtrans_extend_red(info->linebuf, line_width);",
          "529:   xtrans_extend_green(info->linebuf, line_width);",
          "531:   g_even_pos = 0, g_odd_pos = 1;",
          "533:   while (g_even_pos < line_width || g_odd_pos < line_width)",
          "534:   {",
          "535:     if (g_even_pos < line_width)",
          "536:     {",
          "537:       errcnt += fuji_decode_sample_even(info, params, info->linebuf[_G3] + 1, g_even_pos, info->grad_even[1]);",
          "538:       g_even_pos += 2;",
          "539:       fuji_decode_interpolation_even(line_width, info->linebuf[_B2] + 1, b_even_pos);",
          "540:       b_even_pos += 2;",
          "541:     }",
          "542:     if (g_even_pos > 8)",
          "543:     {",
          "544:       errcnt += fuji_decode_sample_odd(info, params, info->linebuf[_G3] + 1, g_odd_pos, info->grad_odd[1]);",
          "545:       g_odd_pos += 2;",
          "546:       errcnt += fuji_decode_sample_odd(info, params, info->linebuf[_B2] + 1, b_odd_pos, info->grad_odd[1]);",
          "547:       b_odd_pos += 2;",
          "548:     }",
          "549:   }",
          "551:   xtrans_extend_green(info->linebuf, line_width);",
          "552:   xtrans_extend_blue(info->linebuf, line_width);",
          "554:   r_even_pos = 0, r_odd_pos = 1;",
          "555:   g_even_pos = 0, g_odd_pos = 1;",
          "557:   while (g_even_pos < line_width || g_odd_pos < line_width)",
          "558:   {",
          "559:     if (g_even_pos < line_width)",
          "560:     {",
          "561:       if (r_even_pos & 3)",
          "562:         errcnt += fuji_decode_sample_even(info, params, info->linebuf[_R3] + 1, r_even_pos, info->grad_even[2]);",
          "563:       else",
          "564:         fuji_decode_interpolation_even(line_width, info->linebuf[_R3] + 1, r_even_pos);",
          "565:       r_even_pos += 2;",
          "566:       fuji_decode_interpolation_even(line_width, info->linebuf[_G4] + 1, g_even_pos);",
          "567:       g_even_pos += 2;",
          "568:     }",
          "569:     if (g_even_pos > 8)",
          "570:     {",
          "571:       errcnt += fuji_decode_sample_odd(info, params, info->linebuf[_R3] + 1, r_odd_pos, info->grad_odd[2]);",
          "572:       r_odd_pos += 2;",
          "573:       errcnt += fuji_decode_sample_odd(info, params, info->linebuf[_G4] + 1, g_odd_pos, info->grad_odd[2]);",
          "574:       g_odd_pos += 2;",
          "575:     }",
          "576:   }",
          "578:   xtrans_extend_red(info->linebuf, line_width);",
          "579:   xtrans_extend_green(info->linebuf, line_width);",
          "581:   g_even_pos = 0, g_odd_pos = 1;",
          "582:   b_even_pos = 0, b_odd_pos = 1;",
          "584:   while (g_even_pos < line_width || g_odd_pos < line_width)",
          "585:   {",
          "586:     if (g_even_pos < line_width)",
          "587:     {",
          "588:       errcnt += fuji_decode_sample_even(info, params, info->linebuf[_G5] + 1, g_even_pos, info->grad_even[0]);",
          "589:       g_even_pos += 2;",
          "590:       if ((b_even_pos & 3) == 2)",
          "591:         fuji_decode_interpolation_even(line_width, info->linebuf[_B3] + 1, b_even_pos);",
          "592:       else",
          "593:         errcnt += fuji_decode_sample_even(info, params, info->linebuf[_B3] + 1, b_even_pos, info->grad_even[0]);",
          "594:       b_even_pos += 2;",
          "595:     }",
          "596:     if (g_even_pos > 8)",
          "597:     {",
          "598:       errcnt += fuji_decode_sample_odd(info, params, info->linebuf[_G5] + 1, g_odd_pos, info->grad_odd[0]);",
          "599:       g_odd_pos += 2;",
          "600:       errcnt += fuji_decode_sample_odd(info, params, info->linebuf[_B3] + 1, b_odd_pos, info->grad_odd[0]);",
          "601:       b_odd_pos += 2;",
          "602:     }",
          "603:   }",
          "605:   xtrans_extend_green(info->linebuf, line_width);",
          "606:   xtrans_extend_blue(info->linebuf, line_width);",
          "608:   r_even_pos = 0, r_odd_pos = 1;",
          "609:   g_even_pos = 0, g_odd_pos = 1;",
          "611:   while (g_even_pos < line_width || g_odd_pos < line_width)",
          "612:   {",
          "613:     if (g_even_pos < line_width)",
          "614:     {",
          "615:       if ((r_even_pos & 3) == 2)",
          "616:         fuji_decode_interpolation_even(line_width, info->linebuf[_R4] + 1, r_even_pos);",
          "617:       else",
          "618:         errcnt += fuji_decode_sample_even(info, params, info->linebuf[_R4] + 1, r_even_pos, info->grad_even[1]);",
          "619:       r_even_pos += 2;",
          "620:       errcnt += fuji_decode_sample_even(info, params, info->linebuf[_G6] + 1, g_even_pos, info->grad_even[1]);",
          "621:       g_even_pos += 2;",
          "622:     }",
          "623:     if (g_even_pos > 8)",
          "624:     {",
          "625:       errcnt += fuji_decode_sample_odd(info, params, info->linebuf[_R4] + 1, r_odd_pos, info->grad_odd[1]);",
          "626:       r_odd_pos += 2;",
          "627:       errcnt += fuji_decode_sample_odd(info, params, info->linebuf[_G6] + 1, g_odd_pos, info->grad_odd[1]);",
          "628:       g_odd_pos += 2;",
          "629:     }",
          "630:   }",
          "632:   xtrans_extend_red(info->linebuf, line_width);",
          "633:   xtrans_extend_green(info->linebuf, line_width);",
          "635:   g_even_pos = 0, g_odd_pos = 1;",
          "636:   b_even_pos = 0, b_odd_pos = 1;",
          "638:   while (g_even_pos < line_width || g_odd_pos < line_width)",
          "639:   {",
          "640:     if (g_even_pos < line_width)",
          "641:     {",
          "642:       fuji_decode_interpolation_even(line_width, info->linebuf[_G7] + 1, g_even_pos);",
          "643:       g_even_pos += 2;",
          "644:       if (b_even_pos & 3)",
          "645:         errcnt += fuji_decode_sample_even(info, params, info->linebuf[_B4] + 1, b_even_pos, info->grad_even[2]);",
          "646:       else",
          "647:         fuji_decode_interpolation_even(line_width, info->linebuf[_B4] + 1, b_even_pos);",
          "648:       b_even_pos += 2;",
          "649:     }",
          "650:     if (g_even_pos > 8)",
          "651:     {",
          "652:       errcnt += fuji_decode_sample_odd(info, params, info->linebuf[_G7] + 1, g_odd_pos, info->grad_odd[2]);",
          "653:       g_odd_pos += 2;",
          "654:       errcnt += fuji_decode_sample_odd(info, params, info->linebuf[_B4] + 1, b_odd_pos, info->grad_odd[2]);",
          "655:       b_odd_pos += 2;",
          "656:     }",
          "657:   }",
          "659:   xtrans_extend_green(info->linebuf, line_width);",
          "660:   xtrans_extend_blue(info->linebuf, line_width);",
          "662:   if (errcnt)",
          "663:     derror();",
          "666: void LibRaw::xtrans_decode_strip(const struct xtrans_params *info_common, int cur_block, INT64 raw_offset,",
          "667:                                  unsigned dsize)",
          "669:   int cur_block_width, cur_line;",
          "670:   unsigned line_size;",
          "671:   struct xtrans_block info;",
          "673:   init_xtrans_block(&info, info_common, raw_offset, dsize);",
          "674:   line_size = sizeof(ushort) * (info_common->line_width + 2);",
          "676:   cur_block_width = libraw_internal_data.unpacker_data.fuji_block_width;",
          "677:   if (cur_block + 1 == libraw_internal_data.unpacker_data.fuji_total_blocks)",
          "678:     cur_block_width = imgdata.sizes.raw_width % libraw_internal_data.unpacker_data.fuji_block_width;",
          "680:   struct i_pair",
          "681:   {",
          "682:     int a, b;",
          "683:   };",
          "684:   const i_pair mtable[6] = {{_R0, _R3}, {_R1, _R4}, {_G0, _G6}, {_G1, _G7}, {_B0, _B3}, {_B1, _B4}},",
          "685:                ztable[3] = {{_R2, 3}, {_G2, 6}, {_B2, 3}};",
          "686:   for (cur_line = 0; cur_line < libraw_internal_data.unpacker_data.fuji_total_lines; cur_line++)",
          "687:   {",
          "688:     info.lastlast = (cur_block == libraw_internal_data.unpacker_data.fuji_total_blocks - 1) &&",
          "689:                     (cur_line == libraw_internal_data.unpacker_data.fuji_total_lines - 1);",
          "690:     xtrans_decode_block(&info, info_common, cur_line);",
          "693:     for (int i = 0; i < 6; i++)",
          "694:       memcpy(info.linebuf[mtable[i].a], info.linebuf[mtable[i].b], line_size);",
          "696:     copy_line_to_xtrans(&info, cur_line, cur_block, cur_block_width);",
          "698:     for (int i = 0; i < 3; i++)",
          "699:     {",
          "700:       memset(info.linebuf[ztable[i].a], 0, ztable[i].b * line_size);",
          "701:       info.linebuf[ztable[i].a][0] = info.linebuf[ztable[i].a - 1][1];",
          "702:       info.linebuf[ztable[i].a][info_common->line_width + 1] = info.linebuf[ztable[i].a - 1][info_common->line_width];",
          "703:     }",
          "704:   }",
          "707:   free(info.linealloc);",
          "708:   free(info.cur_buf);",
          "713:   struct xtrans_params common_info;",
          "714:   int cur_block;",
          "715:   unsigned line_size, *block_sizes;",
          "716:   INT64 raw_offset, *raw_block_offsets;",
          "719:   init_xtrans(&common_info);",
          "720:   line_size = sizeof(ushort) * (common_info.line_width + 2);",
          "723:   block_sizes = (unsigned *)malloc(sizeof(unsigned) * libraw_internal_data.unpacker_data.fuji_total_blocks);",
          "724:   merror(block_sizes, \"xtrans_load_raw()\");",
          "725:   raw_block_offsets = (INT64 *)malloc(sizeof(INT64) * libraw_internal_data.unpacker_data.fuji_total_blocks);",
          "726:   merror(raw_block_offsets, \"xtrans_load_raw()\");",
          "728:   raw_offset = sizeof(unsigned) * libraw_internal_data.unpacker_data.fuji_total_blocks;",
          "729:   if (raw_offset & 0xC)",
          "730:     raw_offset += 0x10 - (raw_offset & 0xC);",
          "732:   raw_offset += libraw_internal_data.unpacker_data.data_offset;",
          "734:   libraw_internal_data.internal_data.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);",
          "735:   libraw_internal_data.internal_data.input->read(",
          "736:       block_sizes, 1, sizeof(unsigned) * libraw_internal_data.unpacker_data.fuji_total_blocks);",
          "738:   raw_block_offsets[0] = raw_offset;",
          "740:   for (cur_block = 0; cur_block < libraw_internal_data.unpacker_data.fuji_total_blocks; cur_block++)",
          "741:   {",
          "742:     unsigned bsize = sgetn(4, (uchar *)(block_sizes + cur_block));",
          "743:     block_sizes[cur_block] = bsize;",
          "744:   }",
          "746:   for (cur_block = 1; cur_block < libraw_internal_data.unpacker_data.fuji_total_blocks; cur_block++)",
          "747:     raw_block_offsets[cur_block] = raw_block_offsets[cur_block - 1] + block_sizes[cur_block - 1];",
          "749:   xtrans_decode_loop(&common_info, libraw_internal_data.unpacker_data.fuji_total_blocks, raw_block_offsets,",
          "750:                      block_sizes);",
          "752:   free(block_sizes);",
          "753:   free(raw_block_offsets);",
          "754:   free(common_info.q_table);",
          "757: void LibRaw::xtrans_decode_loop(const struct xtrans_params *common_info, int count, INT64 *raw_block_offsets,",
          "758:                                 unsigned *block_sizes)",
          "760:   int cur_block;",
          "764:   for (cur_block = 0; cur_block < count; cur_block++)",
          "765:   {",
          "766:     xtrans_decode_strip(common_info, cur_block, raw_block_offsets[cur_block], block_sizes[cur_block]);",
          "767:   }",
          "772:   unsigned signature, version, h_raw_type, h_raw_bits, h_raw_height, h_raw_rounded_width, h_raw_width, h_block_size,",
          "773:       h_blocks_in_row, h_total_lines;",
          "775:   uchar header[16];",
          "777:   libraw_internal_data.internal_data.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);",
          "778:   libraw_internal_data.internal_data.input->read(header, 1, sizeof(header));",
          "781:   signature = sgetn(2, header);",
          "782:   version = header[2];",
          "783:   h_raw_type = header[3];",
          "784:   h_raw_bits = header[4];",
          "785:   h_raw_height = sgetn(2, header + 5);",
          "786:   h_raw_rounded_width = sgetn(2, header + 7);",
          "787:   h_raw_width = sgetn(2, header + 9);",
          "788:   h_block_size = sgetn(2, header + 11);",
          "789:   h_blocks_in_row = header[13];",
          "790:   h_total_lines = sgetn(2, header + 14);",
          "793:   if (signature != 0x4953 || version != 1 || h_raw_height > 0x3000 || h_raw_height < 6 || h_raw_height % 6 ||",
          "794:       h_raw_width > 0x3000 || h_raw_width < 0x300 || h_raw_width % 24 || h_raw_rounded_width > 0x3000 ||",
          "795:       h_raw_rounded_width < h_block_size || h_raw_rounded_width % h_block_size ||",
          "796:       h_raw_rounded_width - h_raw_width >= h_block_size || h_block_size != 0x300 || h_blocks_in_row > 0x10 ||",
          "797:       h_blocks_in_row == 0 || h_blocks_in_row != h_raw_rounded_width / h_block_size || h_total_lines > 0x800 ||",
          "798:       h_total_lines == 0 || h_total_lines != h_raw_height / 6 || (h_raw_bits != 12 && h_raw_bits != 14) ||",
          "799:       h_raw_type != 16)",
          "800:     return;",
          "803:   libraw_internal_data.unpacker_data.fuji_total_lines = h_total_lines;",
          "804:   libraw_internal_data.unpacker_data.fuji_total_blocks = h_blocks_in_row;",
          "805:   libraw_internal_data.unpacker_data.fuji_block_width = h_block_size;",
          "806:   libraw_internal_data.unpacker_data.fuji_bits = h_raw_bits;",
          "807:   imgdata.sizes.raw_width = h_raw_width;",
          "808:   imgdata.sizes.raw_height = h_raw_height;",
          "809:   libraw_internal_data.unpacker_data.data_offset += 16;",
          "810:   load_raw = &LibRaw::xtrans_compressed_load_raw;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e404386278c37e887302ecc3f817dc7d3723671a",
      "candidate_info": {
        "commit_hash": "e404386278c37e887302ecc3f817dc7d3723671a",
        "repo": "LibRaw/LibRaw",
        "commit_url": "https://github.com/LibRaw/LibRaw/commit/e404386278c37e887302ecc3f817dc7d3723671a",
        "files": [
          "dcraw/dcraw.c"
        ],
        "message": "Secunia SA75000 advisory: several buffer overruns",
        "before_after_code_files": [
          "dcraw/dcraw.c||dcraw/dcraw.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_message": 1,
        "olp_code_files": {
          "patch": [
            "dcraw/dcraw.c||dcraw/dcraw.c"
          ],
          "candidate": [
            "dcraw/dcraw.c||dcraw/dcraw.c"
          ]
        }
      },
      "candidate_diff": {
        "dcraw/dcraw.c||dcraw/dcraw.c": [
          "File: dcraw/dcraw.c -> dcraw/dcraw.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "11697:  if (!strcmp(model,\"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872) {",
          "11698:    load_raw = &CLASS sony_arw_load_raw;",
          "11699:    data_offset = get4()+base;",
          "11701:  }",
          "11702: #ifdef LIBRAW_LIBRARY_BUILD",
          "11703:  if (!strncmp(make,\"Hasselblad\",10) && libraw_internal_data.unpacker_data.hasselblad_parser_flag) {",
          "",
          "[Removed Lines]",
          "11700:    ifd++;  break;",
          "",
          "[Added Lines]",
          "11700:    ifd++;",
          "11701: #ifdef LIBRAW_LIBRARY_BUILD",
          "11702:           if (ifd >= sizeof tiff_ifd / sizeof tiff_ifd[0])",
          "11703:           throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "11704: #endif",
          "11705:    break;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "11965:  break;",
          "11967:       case 50455:",
          "11969: #ifndef LIBRAW_LIBRARY_BUILD",
          "11970:  fread (cbuf, 1, len, ifp);",
          "11971: #else",
          "",
          "[Removed Lines]",
          "11968:  if (len > 2560000 || !(cbuf = (char *) malloc(len))) break;",
          "",
          "[Added Lines]",
          "11973:  if (len < 1 || len > 2560000 || !(cbuf = (char *) malloc(len))) break;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "13326:     }",
          "13327:     order = get2();",
          "13328:     hlen  = get4();",
          "13330:     {",
          "13331: #ifdef LIBRAW_LIBRARY_BUILD",
          "13332:       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13334:     if (get4() == 0x48454150",
          "13335: #ifdef LIBRAW_LIBRARY_BUILD",
          "13336:         && (save+hlen) >= 0 && (save+hlen)<=ifp->size()",
          "13337: #endif",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-3810",
  "cve_desc": "epan/dissectors/packet-websocket.c in the WebSocket dissector in Wireshark 1.12.x before 1.12.5 uses a recursive algorithm, which allows remote attackers to cause a denial of service (CPU consumption) via a crafted packet.",
  "repo": "wireshark/wireshark",
  "patch_hash": "4ee6bcbd2e03a25f1e6b0239558d9edeaf8040c0",
  "patch_info": {
    "commit_hash": "4ee6bcbd2e03a25f1e6b0239558d9edeaf8040c0",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/4ee6bcbd2e03a25f1e6b0239558d9edeaf8040c0",
    "files": [
      "epan/dissectors/packet-http.c",
      "epan/dissectors/packet-websocket.c"
    ],
    "message": "websocket: avoid recursion, use tcp_dissect_pdus\n\nUse tcp_dissect_pdus to handle reassembly and avoid a recursion in\ndissect_websocket. The HTTP dissector is modified to preserve\ndesegmentation functionality (tested with the capture from bug 8448).\n\nAs tcp_dissect_pdus is used now, the workaround for bug 8448 can be\nremoved and the actual frame dissection logic becomes simpler (the\nlength is checked in get_websocket_frame_length).\n\nBug: 10989\nChange-Id: I67af96a6c7be88c2a77e1c4138abe90bdb880774\nReviewed-on: https://code.wireshark.org/review/7285\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Anders Broman <a.broman58@gmail.com>",
    "before_after_code_files": [
      "epan/dissectors/packet-http.c||epan/dissectors/packet-http.c",
      "epan/dissectors/packet-websocket.c||epan/dissectors/packet-websocket.c"
    ]
  },
  "patch_diff": {
    "epan/dissectors/packet-http.c||epan/dissectors/packet-http.c": [
      "File: epan/dissectors/packet-http.c -> epan/dissectors/packet-http.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2910:  } else {",
      "2911:   while (tvb_reported_length_remaining(tvb, offset) > 0) {",
      "2912:    if (conv_data->upgrade == UPGRADE_WEBSOCKET && pinfo->fd->num >= conv_data->startframe) {",
      "2913:     call_dissector_only(websocket_handle, tvb_new_subset_remaining(tvb, offset), pinfo, tree, NULL);",
      "2914:     break;",
      "2915:    }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2915:     if (pinfo->can_desegment > 0)",
      "2916:      pinfo->can_desegment++;",
      "",
      "---------------"
    ],
    "epan/dissectors/packet-websocket.c||epan/dissectors/packet-websocket.c": [
      "File: epan/dissectors/packet-websocket.c -> epan/dissectors/packet-websocket.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "29: #include <epan/prefs.h>",
      "31: #include \"packet-http.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "32: #include \"packet-tcp.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "155: }",
      "157: static int",
      "159: {",
      "160:   guint               offset = 0;",
      "161:   proto_item         *ti_unmask, *ti;",
      "",
      "[Removed Lines]",
      "158: dissect_websocket_payload(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_tree *ws_tree, guint8 opcode, guint payload_length, guint8 mask, const guint8* masking_key)",
      "",
      "[Added Lines]",
      "159: dissect_websocket_payload(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_tree *ws_tree, guint8 opcode, guint payload_length, gboolean mask, const guint8* masking_key)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "315: static int",
      "317: {",
      "318:   proto_item   *ti, *ti_len;",
      "322:   proto_tree   *ws_tree;",
      "323:   const guint8 *masking_key = NULL;",
      "324:   tvbuff_t     *tvb_payload;",
      "332:   short_length = tvb_get_guint8(tvb, 1) & MASK_WS_PAYLOAD_LEN;",
      "333:   if (short_length == 126) {",
      "338:     payload_length = tvb_get_ntohs(tvb, 2);",
      "347:     payload_length = (guint)tvb_get_ntoh64(tvb, 2);",
      "351:     payload_length = short_length;",
      "353:   }",
      "357:   payload_offset = mask_offset + (mask ? 4 : 0);",
      "374:   col_set_str(pinfo->cinfo, COL_PROTOCOL, \"WebSocket\");",
      "375:   col_set_str(pinfo->cinfo, COL_INFO, \"WebSocket\");",
      "",
      "[Removed Lines]",
      "316: dissect_websocket(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)",
      "319:   guint8        fin, opcode, mask;",
      "320:   guint         length, short_length, payload_length, recurse_length;",
      "321:   guint         payload_offset, mask_offset, recurse_offset;",
      "326:   length = tvb_length(tvb);",
      "327:   if (length < 2) {",
      "328:     pinfo->desegment_len = 2;",
      "329:     return 0;",
      "330:   }",
      "334:     if (length < 2+2) {",
      "335:       pinfo->desegment_len = 2+2;",
      "336:       return 0;",
      "337:     }",
      "339:     mask_offset = 2+2;",
      "340:   }",
      "341:   else if (short_length == 127) {",
      "342:     if (length < 2+8) {",
      "343:       pinfo->desegment_len = 2+8;",
      "344:       return 0;",
      "345:     }",
      "348:     mask_offset = 2+8;",
      "349:   }",
      "350:   else{",
      "352:     mask_offset = 2;",
      "356:   mask = (tvb_get_guint8(tvb, 1) & MASK_WS_MASK) >> 4;",
      "359:   if (payload_offset + payload_length < payload_length) {",
      "363:     payload_length = tvb_reported_length_remaining(tvb, payload_offset);",
      "364:   }",
      "366:   if (length < payload_offset + payload_length) {",
      "368:     pinfo->desegment_len = payload_offset + payload_length - length;",
      "369:     return 0;",
      "370:   }",
      "",
      "[Added Lines]",
      "317: dissect_websocket_frame(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)",
      "320:   guint8        fin, opcode;",
      "321:   gboolean      mask;",
      "322:   guint         short_length, payload_length;",
      "323:   guint         payload_offset, mask_offset;",
      "329:   mask_offset = 2;",
      "332:     mask_offset += 2;",
      "333:   } else if (short_length == 127) {",
      "336:     mask_offset += 8;",
      "337:   } else {",
      "342:   mask = (tvb_get_guint8(tvb, 1) & MASK_WS_MASK) != 0;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "414:     dissect_websocket_payload(tvb_payload, pinfo, tree, ws_tree, opcode, payload_length, mask, masking_key);",
      "415:   }",
      "426:   }",
      "429: }",
      "",
      "[Removed Lines]",
      "419:   recurse_offset = payload_offset + payload_length;",
      "420:   if (length > recurse_offset) {",
      "421:     recurse_length = dissect_websocket(tvb_new_subset_remaining(tvb, recurse_offset), pinfo, tree, data);",
      "422:     if (pinfo->desegment_len)",
      "423:       pinfo->desegment_offset += recurse_offset;",
      "425:     return recurse_offset + recurse_length;",
      "428:   return recurse_offset;",
      "",
      "[Added Lines]",
      "388:   return tvb_captured_length(tvb);",
      "389: }",
      "391: static guint",
      "392: get_websocket_frame_length(packet_info *pinfo _U_, tvbuff_t *tvb, int offset, void *data _U_)",
      "393: {",
      "394:   guint         frame_length, payload_length;",
      "395:   gboolean      mask;",
      "398:   mask = tvb_get_guint8(tvb, offset + 1) & MASK_WS_MASK;",
      "400:   payload_length = tvb_get_guint8(tvb, offset + 1) & MASK_WS_PAYLOAD_LEN;",
      "404:   if (payload_length == 126) {",
      "405:     if (tvb_reported_length_remaining(tvb, offset) < 2)",
      "408:     payload_length = tvb_get_ntohs(tvb, offset);",
      "410:   } else if (payload_length == 127) {",
      "411:     if (tvb_reported_length_remaining(tvb, offset) < 8)",
      "414:     payload_length = (guint)tvb_get_ntoh64(tvb, offset);",
      "418:   if (mask)",
      "421:   return frame_length;",
      "422: }",
      "424: static int",
      "425: dissect_websocket(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)",
      "426: {",
      "428:   tcp_dissect_pdus(tvb, pinfo, tree, TRUE, 2,",
      "429:                    get_websocket_frame_length, dissect_websocket_frame, data);",
      "430:   return tvb_captured_length(tvb);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "51233ad116e907201da5791a12e0ad8e95f31443",
      "candidate_info": {
        "commit_hash": "51233ad116e907201da5791a12e0ad8e95f31443",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/51233ad116e907201da5791a12e0ad8e95f31443",
        "files": [
          "epan/dissectors/packet-http.c",
          "epan/dissectors/packet-websocket.c"
        ],
        "message": "websocket: avoid recursion, use tcp_dissect_pdus\n\nUse tcp_dissect_pdus to handle reassembly and avoid a recursion in\ndissect_websocket. The HTTP dissector is modified to preserve\ndesegmentation functionality (tested with the capture from bug 8448).\n\nAs tcp_dissect_pdus is used now, the workaround for bug 8448 can be\nremoved and the actual frame dissection logic becomes simpler (the\nlength is checked in get_websocket_frame_length).\n\nBug: 10989\nChange-Id: I67af96a6c7be88c2a77e1c4138abe90bdb880774\nReviewed-on: https://code.wireshark.org/review/7285\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Anders Broman <a.broman58@gmail.com>\n(cherry picked from commit 4ee6bcbd2e03a25f1e6b0239558d9edeaf8040c0)\n[conflict resolution: commit f3f736c67f915c7a67176a100fac56d46226cb35\n is not applied as the code was moved; dropped data parameter for\n get_websocket_frame_length; keep ws_tree=NULL in context]\nReviewed-on: https://code.wireshark.org/review/7639\nReviewed-by: Peter Wu <peter@lekensteyn.nl>\nTested-by: Peter Wu <peter@lekensteyn.nl>\n(cherry picked from commit cdb1fc695db45ee603133c9d8250c47fcd46d088)\nReviewed-on: https://code.wireshark.org/review/8635\nPetri-Dish: Peter Wu <peter@lekensteyn.nl>\nReviewed-by: Balint Reczey <balint@balintreczey.hu>",
        "before_after_code_files": [
          "epan/dissectors/packet-http.c||epan/dissectors/packet-http.c",
          "epan/dissectors/packet-websocket.c||epan/dissectors/packet-websocket.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-http.c||epan/dissectors/packet-http.c",
            "epan/dissectors/packet-websocket.c||epan/dissectors/packet-websocket.c"
          ],
          "candidate": [
            "epan/dissectors/packet-http.c||epan/dissectors/packet-http.c",
            "epan/dissectors/packet-websocket.c||epan/dissectors/packet-websocket.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-http.c||epan/dissectors/packet-http.c": [
          "File: epan/dissectors/packet-http.c -> epan/dissectors/packet-http.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2766:  } else {",
          "2767:   while (tvb_reported_length_remaining(tvb, offset) > 0) {",
          "2768:    if (conv_data->upgrade == UPGRADE_WEBSOCKET && pinfo->fd->num >= conv_data->startframe) {",
          "2769:     call_dissector_only(websocket_handle, tvb_new_subset_remaining(tvb, offset), pinfo, tree, NULL);",
          "2770:     break;",
          "2771:    }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2771:     if (pinfo->can_desegment > 0)",
          "2772:      pinfo->can_desegment++;",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-websocket.c||epan/dissectors/packet-websocket.c": [
          "File: epan/dissectors/packet-websocket.c -> epan/dissectors/packet-websocket.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #include <epan/expert.h>",
          "30: #include <epan/prefs.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "32: #include \"packet-tcp.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "155: }",
          "157: static int",
          "159: {",
          "160:   guint               offset = 0;",
          "161:   proto_item         *ti_unmask, *ti;",
          "",
          "[Removed Lines]",
          "158: dissect_websocket_payload(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_tree *ws_tree, guint8 opcode, guint payload_length, guint8 mask, const guint8* masking_key)",
          "",
          "[Added Lines]",
          "159: dissect_websocket_payload(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_tree *ws_tree, guint8 opcode, guint payload_length, gboolean mask, const guint8* masking_key)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "311: static int",
          "313: {",
          "314:   proto_item   *ti, *ti_len;",
          "318:   proto_tree   *ws_tree     = NULL;",
          "319:   const guint8 *masking_key = NULL;",
          "320:   tvbuff_t     *tvb_payload;",
          "328:   short_length = tvb_get_guint8(tvb, 1) & MASK_WS_PAYLOAD_LEN;",
          "329:   if (short_length == 126) {",
          "334:     payload_length = tvb_get_ntohs(tvb, 2);",
          "343:     payload_length = (guint)tvb_get_ntoh64(tvb, 2);",
          "347:     payload_length = short_length;",
          "349:   }",
          "353:   payload_offset = mask_offset + (mask ? 4 : 0);",
          "370:   col_set_str(pinfo->cinfo, COL_PROTOCOL, \"WebSocket\");",
          "371:   col_set_str(pinfo->cinfo, COL_INFO, \"WebSocket\");",
          "",
          "[Removed Lines]",
          "312: dissect_websocket(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)",
          "315:   guint8        fin, opcode, mask;",
          "316:   guint         length, short_length, payload_length, recurse_length;",
          "317:   guint         payload_offset, mask_offset, recurse_offset;",
          "322:   length = tvb_length(tvb);",
          "323:   if (length < 2) {",
          "324:     pinfo->desegment_len = 2;",
          "325:     return 0;",
          "326:   }",
          "330:     if (length < 2+2) {",
          "331:       pinfo->desegment_len = 2+2;",
          "332:       return 0;",
          "333:     }",
          "335:     mask_offset = 2+2;",
          "336:   }",
          "337:   else if (short_length == 127) {",
          "338:     if (length < 2+8) {",
          "339:       pinfo->desegment_len = 2+8;",
          "340:       return 0;",
          "341:     }",
          "344:     mask_offset = 2+8;",
          "345:   }",
          "346:   else{",
          "348:     mask_offset = 2;",
          "352:   mask = (tvb_get_guint8(tvb, 1) & MASK_WS_MASK) >> 4;",
          "355:   if (payload_offset + payload_length < payload_length) {",
          "359:     payload_length = tvb_reported_length_remaining(tvb, payload_offset);",
          "360:   }",
          "362:   if (length < payload_offset + payload_length) {",
          "364:     pinfo->desegment_len = payload_offset + payload_length - length;",
          "365:     return 0;",
          "366:   }",
          "",
          "[Added Lines]",
          "313: dissect_websocket_frame(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)",
          "316:   guint8        fin, opcode;",
          "317:   gboolean      mask;",
          "318:   guint         short_length, payload_length;",
          "319:   guint         payload_offset, mask_offset;",
          "325:   mask_offset = 2;",
          "328:     mask_offset += 2;",
          "329:   } else if (short_length == 127) {",
          "332:     mask_offset += 8;",
          "333:   } else {",
          "338:   mask = (tvb_get_guint8(tvb, 1) & MASK_WS_MASK) != 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "410:   tvb_payload = tvb_new_subset_remaining(tvb, payload_offset);",
          "411:   dissect_websocket_payload(tvb_payload, pinfo, tree, ws_tree, opcode, payload_length, mask, masking_key);",
          "420:   }",
          "422: }",
          "",
          "[Removed Lines]",
          "415:   recurse_offset = payload_offset + payload_length;",
          "416:   if (length > recurse_offset) {",
          "417:     recurse_length = dissect_websocket(tvb_new_subset_remaining(tvb, payload_offset+payload_length), pinfo, tree, data);",
          "418:     if (pinfo->desegment_len) pinfo->desegment_offset += recurse_offset;",
          "419:     return recurse_offset + recurse_length;",
          "421:   return recurse_offset;",
          "",
          "[Added Lines]",
          "384:   return tvb_captured_length(tvb);",
          "385: }",
          "387: static guint",
          "388: get_websocket_frame_length(packet_info *pinfo _U_, tvbuff_t *tvb, int offset)",
          "389: {",
          "390:   guint         frame_length, payload_length;",
          "391:   gboolean      mask;",
          "394:   mask = tvb_get_guint8(tvb, offset + 1) & MASK_WS_MASK;",
          "396:   payload_length = tvb_get_guint8(tvb, offset + 1) & MASK_WS_PAYLOAD_LEN;",
          "400:   if (payload_length == 126) {",
          "401:     if (tvb_reported_length_remaining(tvb, offset) < 2)",
          "404:     payload_length = tvb_get_ntohs(tvb, offset);",
          "406:   } else if (payload_length == 127) {",
          "407:     if (tvb_reported_length_remaining(tvb, offset) < 8)",
          "410:     payload_length = (guint)tvb_get_ntoh64(tvb, offset);",
          "413:   if (mask)",
          "416:   return frame_length;",
          "417: }",
          "419: static int",
          "420: dissect_websocket(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)",
          "421: {",
          "423:   tcp_dissect_pdus(tvb, pinfo, tree, TRUE, 2,",
          "424:                    get_websocket_frame_length, dissect_websocket_frame, data);",
          "425:   return tvb_captured_length(tvb);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cdb1fc695db45ee603133c9d8250c47fcd46d088",
      "candidate_info": {
        "commit_hash": "cdb1fc695db45ee603133c9d8250c47fcd46d088",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/cdb1fc695db45ee603133c9d8250c47fcd46d088",
        "files": [
          "epan/dissectors/packet-http.c",
          "epan/dissectors/packet-websocket.c"
        ],
        "message": "websocket: avoid recursion, use tcp_dissect_pdus\n\nUse tcp_dissect_pdus to handle reassembly and avoid a recursion in\ndissect_websocket. The HTTP dissector is modified to preserve\ndesegmentation functionality (tested with the capture from bug 8448).\n\nAs tcp_dissect_pdus is used now, the workaround for bug 8448 can be\nremoved and the actual frame dissection logic becomes simpler (the\nlength is checked in get_websocket_frame_length).\n\nBug: 10989\nChange-Id: I67af96a6c7be88c2a77e1c4138abe90bdb880774\nReviewed-on: https://code.wireshark.org/review/7285\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Anders Broman <a.broman58@gmail.com>\n(cherry picked from commit 4ee6bcbd2e03a25f1e6b0239558d9edeaf8040c0)\n[conflict resolution: commit f3f736c67f915c7a67176a100fac56d46226cb35\n is not applied as the code was moved; dropped data parameter for\n get_websocket_frame_length; keep ws_tree=NULL in context]\nReviewed-on: https://code.wireshark.org/review/7639\nReviewed-by: Peter Wu <peter@lekensteyn.nl>\nTested-by: Peter Wu <peter@lekensteyn.nl>",
        "before_after_code_files": [
          "epan/dissectors/packet-http.c||epan/dissectors/packet-http.c",
          "epan/dissectors/packet-websocket.c||epan/dissectors/packet-websocket.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-http.c||epan/dissectors/packet-http.c",
            "epan/dissectors/packet-websocket.c||epan/dissectors/packet-websocket.c"
          ],
          "candidate": [
            "epan/dissectors/packet-http.c||epan/dissectors/packet-http.c",
            "epan/dissectors/packet-websocket.c||epan/dissectors/packet-websocket.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-http.c||epan/dissectors/packet-http.c": [
          "File: epan/dissectors/packet-http.c -> epan/dissectors/packet-http.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2790:  } else {",
          "2791:   while (tvb_reported_length_remaining(tvb, offset) > 0) {",
          "2792:    if (conv_data->upgrade == UPGRADE_WEBSOCKET && pinfo->fd->num >= conv_data->startframe) {",
          "2793:     call_dissector_only(websocket_handle, tvb_new_subset_remaining(tvb, offset), pinfo, tree, NULL);",
          "2794:     break;",
          "2795:    }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2795:     if (pinfo->can_desegment > 0)",
          "2796:      pinfo->can_desegment++;",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-websocket.c||epan/dissectors/packet-websocket.c": [
          "File: epan/dissectors/packet-websocket.c -> epan/dissectors/packet-websocket.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #include <epan/expert.h>",
          "30: #include <epan/prefs.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "32: #include \"packet-tcp.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "155: }",
          "157: static int",
          "159: {",
          "160:   guint               offset = 0;",
          "161:   proto_item         *ti_unmask, *ti;",
          "",
          "[Removed Lines]",
          "158: dissect_websocket_payload(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_tree *ws_tree, guint8 opcode, guint payload_length, guint8 mask, const guint8* masking_key)",
          "",
          "[Added Lines]",
          "159: dissect_websocket_payload(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_tree *ws_tree, guint8 opcode, guint payload_length, gboolean mask, const guint8* masking_key)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "311: static int",
          "313: {",
          "314:   proto_item   *ti, *ti_len;",
          "318:   proto_tree   *ws_tree     = NULL;",
          "319:   const guint8 *masking_key = NULL;",
          "320:   tvbuff_t     *tvb_payload;",
          "328:   short_length = tvb_get_guint8(tvb, 1) & MASK_WS_PAYLOAD_LEN;",
          "329:   if (short_length == 126) {",
          "334:     payload_length = tvb_get_ntohs(tvb, 2);",
          "343:     payload_length = (guint)tvb_get_ntoh64(tvb, 2);",
          "347:     payload_length = short_length;",
          "349:   }",
          "353:   payload_offset = mask_offset + (mask ? 4 : 0);",
          "370:   col_set_str(pinfo->cinfo, COL_PROTOCOL, \"WebSocket\");",
          "371:   col_set_str(pinfo->cinfo, COL_INFO, \"WebSocket\");",
          "",
          "[Removed Lines]",
          "312: dissect_websocket(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)",
          "315:   guint8        fin, opcode, mask;",
          "316:   guint         length, short_length, payload_length, recurse_length;",
          "317:   guint         payload_offset, mask_offset, recurse_offset;",
          "322:   length = tvb_length(tvb);",
          "323:   if (length < 2) {",
          "324:     pinfo->desegment_len = 2;",
          "325:     return 0;",
          "326:   }",
          "330:     if (length < 2+2) {",
          "331:       pinfo->desegment_len = 2+2;",
          "332:       return 0;",
          "333:     }",
          "335:     mask_offset = 2+2;",
          "336:   }",
          "337:   else if (short_length == 127) {",
          "338:     if (length < 2+8) {",
          "339:       pinfo->desegment_len = 2+8;",
          "340:       return 0;",
          "341:     }",
          "344:     mask_offset = 2+8;",
          "345:   }",
          "346:   else{",
          "348:     mask_offset = 2;",
          "352:   mask = (tvb_get_guint8(tvb, 1) & MASK_WS_MASK) >> 4;",
          "355:   if (payload_offset + payload_length < payload_length) {",
          "359:     payload_length = tvb_reported_length_remaining(tvb, payload_offset);",
          "360:   }",
          "362:   if (length < payload_offset + payload_length) {",
          "364:     pinfo->desegment_len = payload_offset + payload_length - length;",
          "365:     return 0;",
          "366:   }",
          "",
          "[Added Lines]",
          "313: dissect_websocket_frame(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)",
          "316:   guint8        fin, opcode;",
          "317:   gboolean      mask;",
          "318:   guint         short_length, payload_length;",
          "319:   guint         payload_offset, mask_offset;",
          "325:   mask_offset = 2;",
          "328:     mask_offset += 2;",
          "329:   } else if (short_length == 127) {",
          "332:     mask_offset += 8;",
          "333:   } else {",
          "338:   mask = (tvb_get_guint8(tvb, 1) & MASK_WS_MASK) != 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "412:     dissect_websocket_payload(tvb_payload, pinfo, tree, ws_tree, opcode, payload_length, mask, masking_key);",
          "413:   }",
          "422:   }",
          "424: }",
          "",
          "[Removed Lines]",
          "417:   recurse_offset = payload_offset + payload_length;",
          "418:   if (length > recurse_offset) {",
          "419:     recurse_length = dissect_websocket(tvb_new_subset_remaining(tvb, payload_offset+payload_length), pinfo, tree, data);",
          "420:     if (pinfo->desegment_len) pinfo->desegment_offset += recurse_offset;",
          "421:     return recurse_offset + recurse_length;",
          "423:   return recurse_offset;",
          "",
          "[Added Lines]",
          "386:   return tvb_captured_length(tvb);",
          "387: }",
          "389: static guint",
          "390: get_websocket_frame_length(packet_info *pinfo _U_, tvbuff_t *tvb, int offset)",
          "391: {",
          "392:   guint         frame_length, payload_length;",
          "393:   gboolean      mask;",
          "396:   mask = tvb_get_guint8(tvb, offset + 1) & MASK_WS_MASK;",
          "398:   payload_length = tvb_get_guint8(tvb, offset + 1) & MASK_WS_PAYLOAD_LEN;",
          "402:   if (payload_length == 126) {",
          "403:     if (tvb_reported_length_remaining(tvb, offset) < 2)",
          "406:     payload_length = tvb_get_ntohs(tvb, offset);",
          "408:   } else if (payload_length == 127) {",
          "409:     if (tvb_reported_length_remaining(tvb, offset) < 8)",
          "412:     payload_length = (guint)tvb_get_ntoh64(tvb, offset);",
          "415:   if (mask)",
          "418:   return frame_length;",
          "419: }",
          "421: static int",
          "422: dissect_websocket(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)",
          "423: {",
          "425:   tcp_dissect_pdus(tvb, pinfo, tree, TRUE, 2,",
          "426:                    get_websocket_frame_length, dissect_websocket_frame, data);",
          "427:   return tvb_captured_length(tvb);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d555aa759b9fb3199eb5822c20c86ed80c4608d3",
      "candidate_info": {
        "commit_hash": "d555aa759b9fb3199eb5822c20c86ed80c4608d3",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/d555aa759b9fb3199eb5822c20c86ed80c4608d3",
        "files": [
          "epan/dissectors/packet-websocket.c"
        ],
        "message": "websocket: restructure tree, always unmask payload\n\nChanges:\n - Instead of special-casing masked and unmasked payload data, always\n   unmask the payload before using it. This fixes handling of SIP\n   requests which are masked and would previously not be dissected by\n   the SIP handle. (As a result, many fields are removed).\n - Dissected text protocols (for example SIP) are now shown below the\n   Websocket layer instead of inside the payload tree.\n - Use line-based text dissector as fallback for text decoding, and use\n   data dissector for binary decoding.\n - Treat the optional close reason as UTF-8 instead of ASCII.\n - Group the close fields (status code, reason) in a subtree below close\n   to avoid confusion. Make Close FT_NONE to avoid displaying hex.\n - Split dissection of the payload in separate functions for control and\n   data frames.\n\nChange-Id: I78b0078d51271bef94229d4b7c6c528b5e3a424d\nReviewed-on: https://code.wireshark.org/review/7294\nPetri-Dish: Alexis La Goutte <alexis.lagoutte@gmail.com>\nPetri-Dish: Peter Wu <peter@lekensteyn.nl>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Alexis La Goutte <alexis.lagoutte@gmail.com>",
        "before_after_code_files": [
          "epan/dissectors/packet-websocket.c||epan/dissectors/packet-websocket.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-websocket.c||epan/dissectors/packet-websocket.c"
          ],
          "candidate": [
            "epan/dissectors/packet-websocket.c||epan/dissectors/packet-websocket.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-websocket.c||epan/dissectors/packet-websocket.c": [
          "File: epan/dissectors/packet-websocket.c -> epan/dissectors/packet-websocket.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "41: void proto_register_websocket(void);",
          "42: void proto_reg_handoff_websocket(void);",
          "44: static dissector_handle_t text_lines_handle;",
          "45: static dissector_handle_t json_handle;",
          "46: static dissector_handle_t sip_handle;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "45: static dissector_handle_t data_handle;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "65: static int hf_ws_payload_length_ext_64 = -1;",
          "66: static int hf_ws_masking_key = -1;",
          "67: static int hf_ws_payload = -1;",
          "69: static int hf_ws_payload_continue = -1;",
          "76: static int hf_ws_payload_close = -1;",
          "79: static int hf_ws_payload_close_status_code = -1;",
          "80: static int hf_ws_payload_close_reason = -1;",
          "81: static int hf_ws_payload_ping = -1;",
          "84: static int hf_ws_payload_pong = -1;",
          "87: static int hf_ws_payload_unknown = -1;",
          "89: static gint ett_ws = -1;",
          "90: static gint ett_ws_pl = -1;",
          "91: static gint ett_ws_mask = -1;",
          "93: static expert_field ei_ws_payload_unknown = EI_INIT;",
          "",
          "[Removed Lines]",
          "68: static int hf_ws_payload_unmask = -1;",
          "70: static int hf_ws_payload_text = -1;",
          "71: static int hf_ws_payload_text_mask = -1;",
          "72: static int hf_ws_payload_text_unmask = -1;",
          "73: static int hf_ws_payload_binary = -1;",
          "74: static int hf_ws_payload_binary_mask = -1;",
          "75: static int hf_ws_payload_binary_unmask = -1;",
          "77: static int hf_ws_payload_close_mask = -1;",
          "78: static int hf_ws_payload_close_unmask = -1;",
          "82: static int hf_ws_payload_ping_mask = -1;",
          "83: static int hf_ws_payload_ping_unmask = -1;",
          "85: static int hf_ws_payload_pong_mask = -1;",
          "86: static int hf_ws_payload_pong_unmask = -1;",
          "",
          "[Added Lines]",
          "70: static int hf_ws_masked_payload = -1;",
          "82: static gint ett_ws_control_close = -1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "155:   return tvb_new_real_data(data_unmask, unmasked_length, payload_length);",
          "156: }",
          "160: {",
          "163:   dissector_handle_t  handle = NULL;",
          "166:   heur_dtbl_entry_t  *hdtbl_entry;",
          "167:   conversation_t     *conv;",
          "168:   http_conv_t        *http_conv = NULL;",
          "186:   conv = find_conversation(pinfo->fd->num, &pinfo->src, &pinfo->dst, pinfo->ptype, pinfo->srcport, pinfo->destport, 0);",
          "188:     http_conv = (http_conv_t *)conversation_get_proto_data(conv, proto_http);",
          "202:   switch (opcode) {",
          "218:       const gchar  *saved_match_string = pinfo->match_string;",
          "220:       pinfo->match_string = NULL;",
          "221:       switch (pref_text_type) {",
          "222:       case WEBSOCKET_TEXT:",
          "231:       case WEBSOCKET_NONE:",
          "233:       default:",
          "236:       }",
          "237:       pinfo->match_string = saved_match_string;",
          "238:     }",
          "240:     break;",
          "307:       expert_add_info_format(pinfo, ti, &ei_ws_payload_unknown, \"Dissector for Websocket Opcode (%d)\"",
          "308:         \" code not implemented, Contact Wireshark developers\"",
          "309:         \" if you want this supported\", opcode);",
          "311:   }",
          "313: }",
          "",
          "[Removed Lines]",
          "158: static int",
          "159: dissect_websocket_payload(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_tree *ws_tree, guint8 opcode, guint payload_length, gboolean mask, const guint8* masking_key)",
          "161:   guint               offset = 0;",
          "162:   proto_item         *ti_unmask, *ti;",
          "164:   proto_tree         *pl_tree, *mask_tree = NULL;",
          "165:   tvbuff_t           *payload_tvb         = NULL;",
          "171:   ti = proto_tree_add_item(ws_tree, hf_ws_payload, tvb, offset, payload_length, ENC_NA);",
          "172:   pl_tree = proto_item_add_subtree(ti, ett_ws_pl);",
          "173:   if (mask) {",
          "174:     payload_tvb = tvb_unmasked(tvb, pinfo, offset, payload_length, masking_key);",
          "175:     tvb_set_child_real_data_tvbuff(tvb, payload_tvb);",
          "176:     add_new_data_source(pinfo, payload_tvb, payload_length > tvb_captured_length(payload_tvb) ? \"Unmasked Data (truncated)\" : \"Unmasked Data\");",
          "177:     ti = proto_tree_add_item(ws_tree, hf_ws_payload_unmask, payload_tvb, offset, payload_length, ENC_NA);",
          "178:     if (payload_length > tvb_captured_length(payload_tvb)) {",
          "179:       proto_item_append_text(ti, \" [truncated]\");",
          "180:     }",
          "181:     mask_tree = proto_item_add_subtree(ti, ett_ws_mask);",
          "182:   } else {",
          "183:     payload_tvb = tvb_new_subset(tvb, offset, payload_length, -1);",
          "184:   }",
          "187:   if (conv)",
          "190:   if (http_conv)",
          "191:     handle = dissector_get_uint_handle(port_subdissector_table, http_conv->server_port);",
          "193:   if (handle)",
          "194:     call_dissector_only(handle, payload_tvb, pinfo, tree, NULL);",
          "195:   else",
          "196:     dissector_try_heuristic(heur_subdissector_list, payload_tvb, pinfo, tree, &hdtbl_entry, NULL);",
          "205:       proto_tree_add_item(pl_tree, hf_ws_payload_continue, tvb, offset, payload_length, ENC_NA);",
          "207:     break;",
          "210:     if (mask) {",
          "212:       proto_tree_add_item(pl_tree, hf_ws_payload_text_mask, tvb, offset, payload_length, ENC_NA);",
          "213:       ti_unmask = proto_tree_add_item(mask_tree, hf_ws_payload_text_unmask, payload_tvb, offset, payload_length, ENC_UTF_8|ENC_NA);",
          "214:       PROTO_ITEM_SET_GENERATED(ti_unmask);",
          "215:       ti_unmask = proto_tree_add_item(mask_tree, hf_ws_payload_text, payload_tvb, offset, payload_length, ENC_UTF_8|ENC_NA);",
          "216:       PROTO_ITEM_SET_HIDDEN(ti_unmask);",
          "217:     } else {",
          "223:           call_dissector(text_lines_handle, payload_tvb, pinfo, pl_tree);",
          "224:           break;",
          "225:       case WEBSOCKET_JSON:",
          "226:           call_dissector(json_handle, payload_tvb, pinfo, pl_tree);",
          "227:           break;",
          "228:       case WEBSOCKET_SIP:",
          "229:           call_dissector(sip_handle, payload_tvb, pinfo, pl_tree);",
          "230:           break;",
          "234:           proto_tree_add_item(pl_tree, hf_ws_payload_text, tvb, offset, payload_length, ENC_UTF_8|ENC_NA);",
          "235:           break;",
          "239:     offset += payload_length;",
          "243:     if (mask) {",
          "244:       proto_tree_add_item(pl_tree, hf_ws_payload_binary_mask, tvb, offset, payload_length, ENC_NA);",
          "245:       ti_unmask = proto_tree_add_item(mask_tree, hf_ws_payload_binary_unmask, payload_tvb, offset, payload_length, ENC_NA);",
          "246:       PROTO_ITEM_SET_GENERATED(ti_unmask);",
          "247:       ti_unmask = proto_tree_add_item(mask_tree, hf_ws_payload_binary, payload_tvb, offset, payload_length, ENC_NA);",
          "248:       PROTO_ITEM_SET_HIDDEN(ti_unmask);",
          "249:     } else {",
          "250:       proto_tree_add_item(pl_tree, hf_ws_payload_binary, tvb, offset, payload_length, ENC_NA);",
          "251:     }",
          "252:     offset += payload_length;",
          "253:     break;",
          "256:     if (mask) {",
          "257:       proto_tree_add_item(pl_tree, hf_ws_payload_close_mask, tvb, offset, payload_length, ENC_NA);",
          "258:       ti_unmask = proto_tree_add_item(mask_tree, hf_ws_payload_close_unmask, payload_tvb, offset, payload_length, ENC_NA);",
          "259:       PROTO_ITEM_SET_GENERATED(ti_unmask);",
          "260:       ti_unmask = proto_tree_add_item(mask_tree, hf_ws_payload_close, payload_tvb, offset, payload_length, ENC_NA);",
          "261:       PROTO_ITEM_SET_HIDDEN(ti_unmask);",
          "262:       ti_unmask = proto_tree_add_item(mask_tree, hf_ws_payload_close_status_code, payload_tvb, offset, 2, ENC_BIG_ENDIAN);",
          "263:       PROTO_ITEM_SET_GENERATED(ti_unmask);",
          "265:       if (payload_length > 2) {",
          "266:         ti_unmask = proto_tree_add_item(mask_tree, hf_ws_payload_close_reason, payload_tvb, offset+2, payload_length-2, ENC_ASCII|ENC_NA);",
          "267:         PROTO_ITEM_SET_GENERATED(ti_unmask);",
          "268:       }",
          "269:     } else {",
          "270:       proto_tree_add_item(pl_tree, hf_ws_payload_close, tvb, offset, payload_length, ENC_NA);",
          "271:       proto_tree_add_item(pl_tree, hf_ws_payload_close_status_code, tvb, offset, 2, ENC_BIG_ENDIAN);",
          "272:       if (payload_length > 2) {",
          "273:         proto_tree_add_item(pl_tree, hf_ws_payload_close_reason, tvb, offset+2, payload_length-2, ENC_ASCII|ENC_NA);",
          "274:       }",
          "275:     }",
          "276:     offset += payload_length;",
          "277:     break;",
          "280:     if (mask) {",
          "281:       proto_tree_add_item(pl_tree, hf_ws_payload_ping_mask, tvb, offset, payload_length, ENC_NA);",
          "282:       ti_unmask = proto_tree_add_item(mask_tree, hf_ws_payload_ping_unmask, payload_tvb, offset, payload_length, ENC_NA);",
          "283:       PROTO_ITEM_SET_GENERATED(ti_unmask);",
          "284:       ti_unmask = proto_tree_add_item(mask_tree, hf_ws_payload_ping, payload_tvb, offset, payload_length, ENC_NA);",
          "285:       PROTO_ITEM_SET_HIDDEN(ti_unmask);",
          "286:     } else {",
          "287:       proto_tree_add_item(pl_tree, hf_ws_payload_ping, tvb, offset, payload_length, ENC_NA);",
          "288:     }",
          "289:     offset += payload_length;",
          "290:     break;",
          "293:     if (mask) {",
          "294:       proto_tree_add_item(pl_tree, hf_ws_payload_pong_mask, tvb, offset, payload_length, ENC_NA);",
          "295:       ti_unmask = proto_tree_add_item(mask_tree, hf_ws_payload_pong_unmask, payload_tvb, offset, payload_length, ENC_NA);",
          "296:       PROTO_ITEM_SET_GENERATED(ti_unmask);",
          "297:       ti_unmask = proto_tree_add_item(mask_tree, hf_ws_payload_pong, payload_tvb, offset, payload_length, ENC_NA);",
          "298:       PROTO_ITEM_SET_HIDDEN(ti_unmask);",
          "299:     } else {",
          "300:       proto_tree_add_item(pl_tree, hf_ws_payload_pong, tvb, offset, payload_length, ENC_NA);",
          "301:     }",
          "302:     offset += payload_length;",
          "303:     break;",
          "306:       ti = proto_tree_add_item(pl_tree, hf_ws_payload_unknown, tvb, offset, payload_length, ENC_NA);",
          "310:     break;",
          "312:   return offset;",
          "",
          "[Added Lines]",
          "149: static void",
          "150: dissect_websocket_control_frame(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint8 opcode)",
          "152:   proto_item         *ti;",
          "153:   proto_tree         *subtree;",
          "154:   const guint         offset = 0, length = tvb_reported_length(tvb);",
          "156:   switch (opcode) {",
          "158:       ti = proto_tree_add_item(tree, hf_ws_payload_close, tvb, offset, length, ENC_NA);",
          "159:       subtree = proto_item_add_subtree(ti, ett_ws_control_close);",
          "161:       if (length >= 2) {",
          "162:         proto_tree_add_item(subtree, hf_ws_payload_close_status_code, tvb, offset, 2, ENC_BIG_ENDIAN);",
          "163:         if (length > 2)",
          "164:           proto_tree_add_item(subtree, hf_ws_payload_close_reason, tvb, offset+2, length-2, ENC_UTF_8|ENC_NA);",
          "165:       }",
          "166:       break;",
          "169:       proto_tree_add_item(tree, hf_ws_payload_ping, tvb, offset, length, ENC_NA);",
          "170:       break;",
          "173:       proto_tree_add_item(tree, hf_ws_payload_pong, tvb, offset, length, ENC_NA);",
          "174:       break;",
          "177:       ti = proto_tree_add_item(tree, hf_ws_payload_unknown, tvb, offset, length, ENC_NA);",
          "178:       expert_add_info_format(pinfo, ti, &ei_ws_payload_unknown, \"Dissector for Websocket Opcode (%d)\"",
          "179:         \" code not implemented, Contact Wireshark developers\"",
          "180:         \" if you want this supported\", opcode);",
          "181:       break;",
          "182:   }",
          "183: }",
          "185: static void",
          "186: dissect_websocket_data_frame(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_tree *pl_tree, guint8 opcode)",
          "187: {",
          "188:   proto_item         *ti;",
          "189:   const guint         offset = 0, length = tvb_reported_length(tvb);",
          "197:   if (conv) {",
          "200:     if (http_conv)",
          "201:       handle = dissector_get_uint_handle(port_subdissector_table, http_conv->server_port);",
          "202:   }",
          "204:   if (handle) {",
          "205:     call_dissector_only(handle, tvb, pinfo, tree, NULL);",
          "207:   } else if (dissector_try_heuristic(heur_subdissector_list, tvb, pinfo, tree, &hdtbl_entry, NULL)) {",
          "209:   }",
          "214:     {",
          "223:         call_dissector(text_lines_handle, tvb, pinfo, tree);",
          "224:         break;",
          "225:       case WEBSOCKET_JSON:",
          "226:         call_dissector(json_handle, tvb, pinfo, tree);",
          "227:         break;",
          "228:       case WEBSOCKET_SIP:",
          "229:         call_dissector(sip_handle, tvb, pinfo, tree);",
          "230:         break;",
          "237:       call_dissector(data_handle, tvb, pinfo, tree);",
          "238:       break;",
          "241:       ti = proto_tree_add_item(pl_tree, hf_ws_payload_unknown, tvb, offset, length, ENC_NA);",
          "245:       break;",
          "246:   }",
          "247: }",
          "249: static void",
          "250: dissect_websocket_payload(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_tree *ws_tree, guint8 opcode)",
          "251: {",
          "252:   const guint         offset = 0, length = tvb_reported_length(tvb);",
          "253:   proto_item         *ti;",
          "254:   proto_tree         *pl_tree;",
          "255:   tvbuff_t           *tvb_appdata;",
          "258:   ti = proto_tree_add_item(ws_tree, hf_ws_payload, tvb, offset, length, ENC_NA);",
          "259:   pl_tree = proto_item_add_subtree(ti, ett_ws_pl);",
          "266:   if (opcode == WS_CONTINUE) {",
          "267:     proto_tree_add_item(tree, hf_ws_payload_continue, tvb, offset, length, ENC_NA);",
          "270:     return;",
          "271:   }",
          "273:   tvb_appdata = tvb_new_subset(tvb, offset, length, length);",
          "275:   tvb_appdata = tvb;",
          "278:     dissect_websocket_control_frame(tvb_appdata, pinfo, pl_tree, opcode);",
          "279:   } else {",
          "280:     dissect_websocket_data_frame(tvb_appdata, pinfo, tree, pl_tree, opcode);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "381:   }",
          "383:   if (payload_length > 0) {",
          "386:   }",
          "388:   return tvb_captured_length(tvb);",
          "",
          "[Removed Lines]",
          "384:     tvb_payload = tvb_new_subset_remaining(tvb, payload_offset);",
          "385:     dissect_websocket_payload(tvb_payload, pinfo, tree, ws_tree, opcode, payload_length, mask, masking_key);",
          "",
          "[Added Lines]",
          "354:     if (mask) {",
          "355:       ti = proto_tree_add_item(ws_tree, hf_ws_masked_payload, tvb, payload_offset, payload_length, ENC_NA);",
          "356:       tvb_payload = tvb_unmasked(tvb, pinfo, payload_offset, payload_length, masking_key);",
          "357:       tvb_set_child_real_data_tvbuff(tvb, tvb_payload);",
          "358:       add_new_data_source(pinfo, tvb_payload, \"Unmasked data\");",
          "359:     } else {",
          "360:       tvb_payload = tvb_new_subset(tvb, payload_offset, payload_length, payload_length);",
          "361:     }",
          "362:     dissect_websocket_payload(tvb_payload, pinfo, tree, ws_tree, opcode);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "479:     { &hf_ws_payload,",
          "480:       { \"Payload\", \"websocket.payload\",",
          "481:       FT_NONE, BASE_NONE, NULL, 0x0,",
          "483:     },",
          "486:       FT_NONE, BASE_NONE, NULL, 0x0,",
          "487:       NULL, HFILL }",
          "488:     },",
          "",
          "[Removed Lines]",
          "482:       NULL, HFILL }",
          "484:     { &hf_ws_payload_unmask,",
          "485:       { \"Unmask Payload\", \"websocket.payload.unmask\",",
          "",
          "[Added Lines]",
          "459:       \"Payload (after unmasking)\", HFILL }",
          "461:     { &hf_ws_masked_payload,",
          "462:       { \"Masked payload\", \"websocket.masked_payload\",",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "491:       FT_BYTES, BASE_NONE, NULL, 0x0,",
          "492:       NULL, HFILL }",
          "493:     },",
          "524:     { &hf_ws_payload_close,",
          "525:       { \"Close\", \"websocket.payload.close\",",
          "537:       NULL, HFILL }",
          "538:     },",
          "539:     { &hf_ws_payload_close_status_code,",
          "541:       FT_UINT16, BASE_DEC, VALS(ws_close_status_code_vals), 0x0,",
          "542:       NULL, HFILL }",
          "543:     },",
          "",
          "[Removed Lines]",
          "494:     { &hf_ws_payload_text,",
          "495:       { \"Text\", \"websocket.payload.text\",",
          "496:       FT_STRING, BASE_NONE, NULL, 0x0,",
          "497:       NULL, HFILL }",
          "498:     },",
          "499:     { &hf_ws_payload_text_mask,",
          "500:       { \"Text\", \"websocket.payload.text_mask\",",
          "501:       FT_BYTES, BASE_NONE, NULL, 0x0,",
          "502:       NULL, HFILL }",
          "503:     },",
          "504:     { &hf_ws_payload_text_unmask,",
          "505:       { \"Text unmask\", \"websocket.payload.text_unmask\",",
          "506:       FT_STRING, BASE_NONE, NULL, 0x0,",
          "507:       NULL, HFILL }",
          "508:     },",
          "509:     { &hf_ws_payload_binary,",
          "510:       { \"Binary\", \"websocket.payload.binary\",",
          "511:       FT_BYTES, BASE_NONE, NULL, 0x0,",
          "512:       NULL, HFILL }",
          "513:     },",
          "514:     { &hf_ws_payload_binary_mask,",
          "515:       { \"Binary\", \"websocket.payload.binary_mask\",",
          "516:       FT_BYTES, BASE_NONE, NULL, 0x0,",
          "517:       NULL, HFILL }",
          "518:     },",
          "519:     { &hf_ws_payload_binary_unmask,",
          "520:       { \"Binary\", \"websocket.payload.binary_unmask\",",
          "521:       FT_BYTES, BASE_NONE, NULL, 0x0,",
          "522:       NULL, HFILL }",
          "523:     },",
          "526:       FT_BYTES, BASE_NONE, NULL, 0x0,",
          "527:       NULL, HFILL }",
          "528:     },",
          "529:     { &hf_ws_payload_close_mask,",
          "530:       { \"Close\", \"websocket.payload.close_mask\",",
          "531:       FT_BYTES, BASE_NONE, NULL, 0x0,",
          "532:       NULL, HFILL }",
          "533:     },",
          "534:     { &hf_ws_payload_close_unmask,",
          "535:       { \"Unmask Close\", \"websocket.payload.close_unmask\",",
          "536:       FT_BYTES, BASE_NONE, NULL, 0x0,",
          "540:       { \"Close\", \"websocket.payload.close.status_code\",",
          "",
          "[Added Lines]",
          "473:       FT_NONE, BASE_NONE, NULL, 0x0,",
          "477:       { \"Status code\", \"websocket.payload.close.status_code\",",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "551:       FT_BYTES, BASE_NONE, NULL, 0x0,",
          "552:       NULL, HFILL }",
          "553:     },",
          "564:     { &hf_ws_payload_pong,",
          "565:       { \"Pong\", \"websocket.payload.pong\",",
          "566:       FT_BYTES, BASE_NONE, NULL, 0x0,",
          "567:       NULL, HFILL }",
          "568:     },",
          "579:     { &hf_ws_payload_unknown,",
          "580:       { \"Unknown\", \"websocket.payload.unknown\",",
          "581:       FT_BYTES, BASE_NONE, NULL, 0x0,",
          "",
          "[Removed Lines]",
          "554:     { &hf_ws_payload_ping_mask,",
          "555:       { \"Ping\", \"websocket.payload.ping_mask\",",
          "556:       FT_BYTES, BASE_NONE, NULL, 0x0,",
          "557:       NULL, HFILL }",
          "558:     },",
          "559:     { &hf_ws_payload_ping_unmask,",
          "560:       { \"Ping\", \"websocket.payload.ping_unmask\",",
          "561:       FT_BYTES, BASE_NONE, NULL, 0x0,",
          "562:       NULL, HFILL }",
          "563:     },",
          "569:     { &hf_ws_payload_pong_mask,",
          "570:       { \"Pong\", \"websocket.payload.pong_mask\",",
          "571:       FT_BYTES, BASE_NONE, NULL, 0x0,",
          "572:       NULL, HFILL }",
          "573:     },",
          "574:     { &hf_ws_payload_pong_unmask,",
          "575:       { \"Pong\", \"websocket.payload.pong_unmask\",",
          "576:       FT_BYTES, BASE_NONE, NULL, 0x0,",
          "577:       NULL, HFILL }",
          "578:     },",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "587:   static gint *ett[] = {",
          "588:     &ett_ws,",
          "589:     &ett_ws_pl,",
          "591:   };",
          "593:   static ei_register_info ei[] = {",
          "",
          "[Removed Lines]",
          "590:     &ett_ws_mask",
          "",
          "[Added Lines]",
          "507:     &ett_ws_mask,",
          "508:     &ett_ws_control_close,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "638: void",
          "639: proto_reg_handoff_websocket(void)",
          "640: {",
          "641:   text_lines_handle = find_dissector(\"data-text-lines\");",
          "642:   json_handle = find_dissector(\"json\");",
          "643:   sip_handle = find_dissector(\"sip\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "559:   data_handle = find_dissector(\"data\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d67e20a93383889ee8e0436758d26b7e98d8a200",
      "candidate_info": {
        "commit_hash": "d67e20a93383889ee8e0436758d26b7e98d8a200",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/d67e20a93383889ee8e0436758d26b7e98d8a200",
        "files": [
          "epan/dissectors/packet-http.c"
        ],
        "message": "http: preserve desegmentation functionality for http2\n\nWhen the HTTP dissector passes data to a subdissector, it should also\npropagate the desegmentation ability. Otherwise subdissectors (such as\nHTTP2) will not be able to handle large DATA frames.\n\nReported by Alexis, verified with his capture.\n\nChange-Id: I831a78e8d1ad08536e3d0d870012e427ce289b1b\nReviewed-on: https://code.wireshark.org/review/10544\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>\nPetri-Dish: Alexis La Goutte <alexis.lagoutte@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Alexis La Goutte <alexis.lagoutte@gmail.com>",
        "before_after_code_files": [
          "epan/dissectors/packet-http.c||epan/dissectors/packet-http.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-http.c||epan/dissectors/packet-http.c"
          ],
          "candidate": [
            "epan/dissectors/packet-http.c||epan/dissectors/packet-http.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-http.c||epan/dissectors/packet-http.c": [
          "File: epan/dissectors/packet-http.c -> epan/dissectors/packet-http.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2901:  int  offset = 0;",
          "2902:  int  len;",
          "2903:  conversation_t *conversation;",
          "2905:  conv_data = get_http_conversation_data(pinfo, &conversation);",
          "2908:  if (conversation_get_proto_data(conversation, proto_http2) &&",
          "2909:      conv_data->upgrade != UPGRADE_HTTP2) {",
          "2910:   return call_dissector_only(http2_handle, tvb, pinfo, tree, NULL);",
          "2911:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2904:  dissector_handle_t next_handle = NULL;",
          "2911:   if (pinfo->can_desegment > 0)",
          "2912:    pinfo->can_desegment++;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2925:  } else {",
          "2926:   while (tvb_reported_length_remaining(tvb, offset) > 0) {",
          "2927:    if (conv_data->upgrade == UPGRADE_WEBSOCKET && pinfo->fd->num >= conv_data->startframe) {",
          "2934:    }",
          "2935:    if (conv_data->upgrade == UPGRADE_HTTP2 && pinfo->fd->num >= conv_data->startframe) {",
          "2938:    }",
          "2939:    if (conv_data->upgrade == UPGRADE_SSTP && conv_data->response_code == 200 && pinfo->fd->num >= conv_data->startframe) {",
          "",
          "[Removed Lines]",
          "2930:     if (pinfo->can_desegment > 0)",
          "2931:      pinfo->can_desegment++;",
          "2932:     call_dissector_only(websocket_handle, tvb_new_subset_remaining(tvb, offset), pinfo, tree, NULL);",
          "2933:     break;",
          "2936:     call_dissector_only(http2_handle, tvb_new_subset_remaining(tvb, offset), pinfo, tree, NULL);",
          "2937:     break;",
          "",
          "[Added Lines]",
          "2931:     next_handle = websocket_handle;",
          "2934:     next_handle = http2_handle;",
          "2937:     next_handle = sstp_handle;",
          "2938:    }",
          "2939:    if (next_handle) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2944:     if (pinfo->can_desegment > 0)",
          "2945:      pinfo->can_desegment++;",
          "2948:     break;",
          "2949:    }",
          "2950:    len = dissect_http_message(tvb, offset, pinfo, tree, conv_data);",
          "",
          "[Removed Lines]",
          "2947:     call_dissector_only(sstp_handle, tvb_new_subset_remaining(tvb, offset), pinfo, tree, NULL);",
          "",
          "[Added Lines]",
          "2947:     call_dissector_only(next_handle, tvb_new_subset_remaining(tvb, offset), pinfo, tree, NULL);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1ee43690ae165567d81aba6ba5f94a56c0844b2c",
      "candidate_info": {
        "commit_hash": "1ee43690ae165567d81aba6ba5f94a56c0844b2c",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/1ee43690ae165567d81aba6ba5f94a56c0844b2c",
        "files": [
          "epan/dissectors/packet-websocket.c"
        ],
        "message": "no need for if(tree)\n\nChange-Id: I0b20b66e1b44da0362c13009946a69738a2aa267\nReviewed-on: https://code.wireshark.org/review/6138\nReviewed-by: Martin Kaiser <wireshark@kaiser.cx>\nTested-by: Martin Kaiser <wireshark@kaiser.cx>",
        "before_after_code_files": [
          "epan/dissectors/packet-websocket.c||epan/dissectors/packet-websocket.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-websocket.c||epan/dissectors/packet-websocket.c"
          ],
          "candidate": [
            "epan/dissectors/packet-websocket.c||epan/dissectors/packet-websocket.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-websocket.c||epan/dissectors/packet-websocket.c": [
          "File: epan/dissectors/packet-websocket.c -> epan/dissectors/packet-websocket.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "310:   guint8        fin, opcode, mask;",
          "311:   guint         length, short_length, payload_length, recurse_length;",
          "312:   guint         payload_offset, mask_offset, recurse_offset;",
          "314:   const guint8 *masking_key = NULL;",
          "315:   tvbuff_t     *tvb_payload;",
          "",
          "[Removed Lines]",
          "313:   proto_tree   *ws_tree     = NULL;",
          "",
          "[Added Lines]",
          "313:   proto_tree   *ws_tree;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "365:   col_set_str(pinfo->cinfo, COL_PROTOCOL, \"WebSocket\");",
          "366:   col_set_str(pinfo->cinfo, COL_INFO, \"WebSocket\");",
          "374:   proto_tree_add_item(ws_tree, hf_ws_fin, tvb, 0, 1, ENC_NA);",
          "",
          "[Removed Lines]",
          "368:   if (tree) {",
          "369:     ti = proto_tree_add_item(tree, proto_websocket, tvb, 0, payload_offset, ENC_NA);",
          "370:     ws_tree = proto_item_add_subtree(ti, ett_ws);",
          "371:   }",
          "",
          "[Added Lines]",
          "368:   ti = proto_tree_add_item(tree, proto_websocket, tvb, 0, payload_offset, ENC_NA);",
          "369:   ws_tree = proto_item_add_subtree(ti, ett_ws);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
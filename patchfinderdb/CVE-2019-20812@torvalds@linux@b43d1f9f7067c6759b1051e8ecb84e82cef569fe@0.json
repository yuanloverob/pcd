{
  "cve_id": "CVE-2019-20812",
  "cve_desc": "An issue was discovered in the Linux kernel before 5.4.7. The prb_calc_retire_blk_tmo() function in net/packet/af_packet.c can result in a denial of service (CPU consumption and soft lockup) in a certain failure case involving TPACKET_V3, aka CID-b43d1f9f7067.",
  "repo": "torvalds/linux",
  "patch_hash": "b43d1f9f7067c6759b1051e8ecb84e82cef569fe",
  "patch_info": {
    "commit_hash": "b43d1f9f7067c6759b1051e8ecb84e82cef569fe",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/b43d1f9f7067c6759b1051e8ecb84e82cef569fe",
    "files": [
      "net/packet/af_packet.c"
    ],
    "message": "af_packet: set defaule value for tmo\n\nThere is softlockup when using TPACKET_V3:\n...\nNMI watchdog: BUG: soft lockup - CPU#2 stuck for 60010ms!\n(__irq_svc) from [<c0558a0c>] (_raw_spin_unlock_irqrestore+0x44/0x54)\n(_raw_spin_unlock_irqrestore) from [<c027b7e8>] (mod_timer+0x210/0x25c)\n(mod_timer) from [<c0549c30>]\n(prb_retire_rx_blk_timer_expired+0x68/0x11c)\n(prb_retire_rx_blk_timer_expired) from [<c027a7ac>]\n(call_timer_fn+0x90/0x17c)\n(call_timer_fn) from [<c027ab6c>] (run_timer_softirq+0x2d4/0x2fc)\n(run_timer_softirq) from [<c021eaf4>] (__do_softirq+0x218/0x318)\n(__do_softirq) from [<c021eea0>] (irq_exit+0x88/0xac)\n(irq_exit) from [<c0240130>] (msa_irq_exit+0x11c/0x1d4)\n(msa_irq_exit) from [<c0209cf0>] (handle_IPI+0x650/0x7f4)\n(handle_IPI) from [<c02015bc>] (gic_handle_irq+0x108/0x118)\n(gic_handle_irq) from [<c0558ee4>] (__irq_usr+0x44/0x5c)\n...\n\nIf __ethtool_get_link_ksettings() is failed in\nprb_calc_retire_blk_tmo(), msec and tmo will be zero, so tov_in_jiffies\nis zero and the timer expire for retire_blk_timer is turn to\nmod_timer(&pkc->retire_blk_timer, jiffies + 0),\nwhich will trigger cpu usage of softirq is 100%.\n\nFixes: f6fb8f100b80 (\"af-packet: TPACKET_V3 flexible buffer implementation.\")\nTested-by: Xiao Jiangfeng <xiaojiangfeng@huawei.com>\nSigned-off-by: Mao Wenan <maowenan@huawei.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/packet/af_packet.c||net/packet/af_packet.c"
    ]
  },
  "patch_diff": {
    "net/packet/af_packet.c||net/packet/af_packet.c": [
      "File: net/packet/af_packet.c -> net/packet/af_packet.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "544:    msec = 1;",
      "545:    div = ecmd.base.speed / 1000;",
      "546:   }",
      "549:  mbits = (blk_size_in_bytes * 8) / (1024 * 1024);",
      "",
      "[Removed Lines]",
      "547:  }",
      "",
      "[Added Lines]",
      "547:  } else",
      "548:   return DEFAULT_PRB_RETIRE_TOV;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6f7ac8285371fb0df58aba861eaab387f79ed04d",
      "candidate_info": {
        "commit_hash": "6f7ac8285371fb0df58aba861eaab387f79ed04d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6f7ac8285371fb0df58aba861eaab387f79ed04d",
        "files": [
          "drivers/gpu/drm/i915/gt/intel_lrc.c"
        ],
        "message": "drm/i915/gt: Save irqstate around virtual_context_destroy\n\nAs virtual_context_destroy() may be called from a request signal, it may\nbe called from inside an irq-off section, and so we need to do a full\nsave/restore of the irq state rather than blindly re-enable irqs upon\nunlocking.\n\n<4> [110.024262] WARNING: inconsistent lock state\n<4> [110.024277] 5.4.0-rc8-CI-CI_DRM_7489+ #1 Tainted: G     U\n<4> [110.024292] --------------------------------\n<4> [110.024305] inconsistent {IN-HARDIRQ-W} -> {HARDIRQ-ON-W} usage.\n<4> [110.024323] kworker/0:0/5 [HC0[0]:SC0[0]:HE1:SE1] takes:\n<4> [110.024338] ffff88826a0c7a18 (&(&rq->lock)->rlock){?.-.}, at: i915_request_retire+0x221/0x930 [i915]\n<4> [110.024592] {IN-HARDIRQ-W} state was registered at:\n<4> [110.024612]   lock_acquire+0xa7/0x1c0\n<4> [110.024627]   _raw_spin_lock_irqsave+0x33/0x50\n<4> [110.024788]   intel_engine_breadcrumbs_irq+0x38c/0x600 [i915]\n<4> [110.024808]   irq_work_run_list+0x49/0x70\n<4> [110.024824]   irq_work_run+0x26/0x50\n<4> [110.024839]   smp_irq_work_interrupt+0x44/0x1e0\n<4> [110.024855]   irq_work_interrupt+0xf/0x20\n<4> [110.024871]   __do_softirq+0xb7/0x47f\n<4> [110.024885]   irq_exit+0xba/0xc0\n<4> [110.024898]   do_IRQ+0x83/0x160\n<4> [110.024910]   ret_from_intr+0x0/0x1d\n<4> [110.024922] irq event stamp: 172864\n<4> [110.024938] hardirqs last  enabled at (172863): [<ffffffff819ea214>] _raw_spin_unlock_irq+0x24/0x50\n<4> [110.024963] hardirqs last disabled at (172864): [<ffffffff819e9fba>] _raw_spin_lock_irq+0xa/0x40\n<4> [110.024988] softirqs last  enabled at (172812): [<ffffffff81c00385>] __do_softirq+0x385/0x47f\n<4> [110.025012] softirqs last disabled at (172797): [<ffffffff810b829a>] irq_exit+0xba/0xc0\n<4> [110.025031]\nother info that might help us debug this:\n<4> [110.025049]  Possible unsafe locking scenario:\n\n<4> [110.025065]        CPU0\n<4> [110.025075]        ----\n<4> [110.025084]   lock(&(&rq->lock)->rlock);\n<4> [110.025099]   <Interrupt>\n<4> [110.025109]     lock(&(&rq->lock)->rlock);\n<4> [110.025124]\n *** DEADLOCK ***\n\n<4> [110.025144] 4 locks held by kworker/0:0/5:\n<4> [110.025156]  #0: ffff88827588f528 ((wq_completion)events){+.+.}, at: process_one_work+0x1de/0x620\n<4> [110.025187]  #1: ffffc9000006fe78 ((work_completion)(&engine->retire_work)){+.+.}, at: process_one_work+0x1de/0x620\n<4> [110.025219]  #2: ffff88825605e270 (&kernel#2){+.+.}, at: engine_retire+0x57/0xe0 [i915]\n<4> [110.025405]  #3: ffff88826a0c7a18 (&(&rq->lock)->rlock){?.-.}, at: i915_request_retire+0x221/0x930 [i915]\n<4> [110.025634]\nstack backtrace:\n<4> [110.025653] CPU: 0 PID: 5 Comm: kworker/0:0 Tainted: G     U            5.4.0-rc8-CI-CI_DRM_7489+ #1\n<4> [110.025675] Hardware name:  /NUC7i5BNB, BIOS BNKBL357.86A.0054.2017.1025.1822 10/25/2017\n<4> [110.025856] Workqueue: events engine_retire [i915]\n<4> [110.025872] Call Trace:\n<4> [110.025891]  dump_stack+0x71/0x9b\n<4> [110.025907]  mark_lock+0x49a/0x500\n<4> [110.025926]  ? print_shortest_lock_dependencies+0x200/0x200\n<4> [110.025946]  mark_held_locks+0x49/0x70\n<4> [110.025962]  ? _raw_spin_unlock_irq+0x24/0x50\n<4> [110.025978]  lockdep_hardirqs_on+0xa2/0x1c0\n<4> [110.025995]  _raw_spin_unlock_irq+0x24/0x50\n<4> [110.026171]  virtual_context_destroy+0xc5/0x2e0 [i915]\n<4> [110.026376]  __active_retire+0xb4/0x290 [i915]\n<4> [110.026396]  dma_fence_signal_locked+0x9e/0x1b0\n<4> [110.026613]  i915_request_retire+0x451/0x930 [i915]\n<4> [110.026766]  retire_requests+0x4d/0x60 [i915]\n<4> [110.026919]  engine_retire+0x63/0xe0 [i915]\n\nFixes: b1e3177bd1d8 (\"drm/i915: Coordinate i915_active with its own mutex\")\nFixes: 6d06779e8672 (\"drm/i915: Load balancing across a virtual engine\")\nSigned-off-by: Chris Wilson <chris@chris-wilson.co.uk>\nCc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>\nReviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>\nLink: https://patchwork.freedesktop.org/patch/msgid/20191205145934.663183-1-chris@chris-wilson.co.uk",
        "before_after_code_files": [
          "drivers/gpu/drm/i915/gt/intel_lrc.c||drivers/gpu/drm/i915/gt/intel_lrc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpu/drm/i915/gt/intel_lrc.c||drivers/gpu/drm/i915/gt/intel_lrc.c": [
          "File: drivers/gpu/drm/i915/gt/intel_lrc.c -> drivers/gpu/drm/i915/gt/intel_lrc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4200:  for (n = 0; n < ve->num_siblings; n++) {",
          "4201:   struct intel_engine_cs *sibling = ve->siblings[n];",
          "4202:   struct rb_node *node = &ve->nodes[sibling->id].rb;",
          "4204:   if (RB_EMPTY_NODE(node))",
          "4205:    continue;",
          "4210:   if (!RB_EMPTY_NODE(node))",
          "4211:    rb_erase_cached(node, &sibling->execlists.virtual);",
          "4214:  }",
          "4215:  GEM_BUG_ON(__tasklet_is_scheduled(&ve->base.execlists.tasklet));",
          "",
          "[Removed Lines]",
          "4207:   spin_lock_irq(&sibling->active.lock);",
          "4213:   spin_unlock_irq(&sibling->active.lock);",
          "",
          "[Added Lines]",
          "4203:   unsigned long flags;",
          "4208:   spin_lock_irqsave(&sibling->active.lock, flags);",
          "4214:   spin_unlock_irqrestore(&sibling->active.lock, flags);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b418d660bb9798d2249ac6a46c844389ef50b6a5",
      "candidate_info": {
        "commit_hash": "b418d660bb9798d2249ac6a46c844389ef50b6a5",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b418d660bb9798d2249ac6a46c844389ef50b6a5",
        "files": [
          "drivers/firmware/efi/earlycon.c"
        ],
        "message": "efi/earlycon: Remap entire framebuffer after page initialization\n\nWhen commit:\n\n  69c1f396f25b (\"efi/x86: Convert x86 EFI earlyprintk into generic earlycon implementation\")\n\nmoved the x86 specific EFI earlyprintk implementation to a shared location,\nit also tweaked the behaviour. In particular, it dropped a trick with full\nframebuffer remapping after page initialization, leading to two regressions:\n\n  1) very slow scrolling after page initialization,\n  2) kernel hang when the 'keep_bootcon' command line argument is passed.\n\nPutting the tweak back fixes #2 and mitigates #1, i.e., it limits the slow\nbehavior to the early boot stages, presumably due to eliminating heavy\nmap()/unmap() operations per each pixel line on the screen.\n\n [ ardb: ensure efifb is unmapped again unless keep_bootcon is in effect. ]\n [ mingo: speling fixes. ]\n\nSigned-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>\nSigned-off-by: Ard Biesheuvel <ardb@kernel.org>\nCc: Arvind Sankar <nivedita@alum.mit.edu>\nCc: Bhupesh Sharma <bhsharma@redhat.com>\nCc: Masayoshi Mizuma <m.mizuma@jp.fujitsu.com>\nCc: linux-efi@vger.kernel.org\nFixes: 69c1f396f25b (\"efi/x86: Convert x86 EFI earlyprintk into generic earlycon implementation\")\nLink: https://lkml.kernel.org/r/20191206165542.31469-7-ardb@kernel.org\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "before_after_code_files": [
          "drivers/firmware/efi/earlycon.c||drivers/firmware/efi/earlycon.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/firmware/efi/earlycon.c||drivers/firmware/efi/earlycon.c": [
          "File: drivers/firmware/efi/earlycon.c -> drivers/firmware/efi/earlycon.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: #include <asm/early_ioremap.h>",
          "16: static const struct font_desc *font;",
          "17: static u32 efi_x, efi_y;",
          "18: static u64 fb_base;",
          "19: static pgprot_t fb_prot;",
          "21: static __ref void *efi_earlycon_map(unsigned long start, unsigned long len)",
          "22: {",
          "23:  return early_memremap_prot(fb_base + start, len, pgprot_val(fb_prot));",
          "24: }",
          "26: static __ref void efi_earlycon_unmap(void *addr, unsigned long len)",
          "27: {",
          "28:  early_memunmap(addr, len);",
          "29: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: static const struct console *earlycon_console __initdata;",
          "21: static void *efi_fb;",
          "30: static int __init efi_earlycon_remap_fb(void)",
          "31: {",
          "33:  if (!earlycon_console || !(earlycon_console->flags & CON_ENABLED))",
          "34:   return 0;",
          "36:  if (pgprot_val(fb_prot) == pgprot_val(PAGE_KERNEL))",
          "37:   efi_fb = memremap(fb_base, screen_info.lfb_size, MEMREMAP_WB);",
          "38:  else",
          "39:   efi_fb = memremap(fb_base, screen_info.lfb_size, MEMREMAP_WC);",
          "41:  return efi_fb ? 0 : -ENOMEM;",
          "42: }",
          "43: early_initcall(efi_earlycon_remap_fb);",
          "45: static int __init efi_earlycon_unmap_fb(void)",
          "46: {",
          "48:  if (efi_fb && !(earlycon_console->flags & CON_ENABLED))",
          "49:   memunmap(efi_fb);",
          "50:  return 0;",
          "51: }",
          "52: late_initcall(efi_earlycon_unmap_fb);",
          "56:  if (efi_fb)",
          "57:   return efi_fb + start;",
          "64:  if (efi_fb)",
          "65:   return;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "201:   efi_earlycon_scroll_up();",
          "203:  device->con->write = efi_earlycon_write;",
          "204:  return 0;",
          "205: }",
          "206: EARLYCON_DECLARE(efifb, efi_earlycon_setup);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "243:  earlycon_console = device->con;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d5162f341e9625d00a275d5cbe55432e6627c3bf",
      "candidate_info": {
        "commit_hash": "d5162f341e9625d00a275d5cbe55432e6627c3bf",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d5162f341e9625d00a275d5cbe55432e6627c3bf",
        "files": [
          "net/tipc/name_table.c"
        ],
        "message": "tipc: fix name table rbtree issues\n\nThe current rbtree for service ranges in the name table is built based\non the 'lower' & 'upper' range values resulting in a flaw in the rbtree\nsearching. Some issues have been observed in case of range overlapping:\n\nCase #1: unable to withdraw a name entry:\nAfter some name services are bound, all of them are withdrawn by user\nbut one remains in the name table forever. This corrupts the table and\nthat service becomes dummy i.e. no real port.\nE.g.\n\n                /\n           {22, 22}\n              /\n             /\n   --->  {10, 50}\n           /  \\\n          /    \\\n    {10, 30}  {20, 60}\n\nThe node {10, 30} cannot be removed since the rbtree searching stops at\nthe node's ancestor i.e. {10, 50}, so starting from it will never reach\nthe finding node.\n\nCase #2: failed to send data in some cases:\nE.g. Two service ranges: {20, 60}, {10, 50} are bound. The rbtree for\nthis service will be one of the two cases below depending on the order\nof the bindings:\n\n        {20, 60}             {10, 50} <--\n          /  \\                 /  \\\n         /    \\               /    \\\n    {10, 50}  NIL <--       NIL  {20, 60}\n\n          (a)                    (b)\n\nNow, try to send some data to service {30}, there will be two results:\n(a): Failed, no route to host.\n(b): Ok.\n\nThe reason is that the rbtree searching will stop at the pointing node\nas shown above.\n\nCase #3: Same as case #2b above but if the data sending's scope is\nlocal and the {10, 50} is published by a peer node, then it will result\nin 'no route to host' even though the other {20, 60} is for example on\nthe local node which should be able to get the data.\n\nThe issues are actually due to the way we built the rbtree. This commit\nfixes it by introducing an additional field to each node - named 'max',\nwhich is the largest 'upper' of that node subtree. The 'max' value for\neach subtrees will be propagated correctly whenever a node is inserted/\nremoved or the tree is rebalanced by the augmented rbtree callbacks.\n\nBy this way, we can change the rbtree searching appoarch to solve the\nissues above. Another benefit from this is that we can now improve the\nsearching for a next range matching e.g. in case of multicast, so get\nrid of the unneeded looping over all nodes in the tree.\n\nAcked-by: Jon Maloy <jon.maloy@ericsson.com>\nSigned-off-by: Tuong Lien <tuong.t.lien@dektech.com.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/tipc/name_table.c||net/tipc/name_table.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/tipc/name_table.c||net/tipc/name_table.c": [
          "File: net/tipc/name_table.c -> net/tipc/name_table.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: #include <net/sock.h>",
          "38: #include <linux/list_sort.h>",
          "39: #include \"core.h\"",
          "40: #include \"netlink.h\"",
          "41: #include \"name_table.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "39: #include <linux/rbtree_augmented.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "60:  u32 lower;",
          "61:  u32 upper;",
          "62:  struct rb_node tree_node;",
          "63:  struct list_head local_publ;",
          "64:  struct list_head all_publ;",
          "65: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "65:  u32 max;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "84:  struct rcu_head rcu;",
          "85: };",
          "87: static int hash(int x)",
          "88: {",
          "89:  return x & (TIPC_NAMETBL_SIZE - 1);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "90: #define service_range_upper(sr) ((sr)->upper)",
          "91: RB_DECLARE_CALLBACKS_MAX(static, sr_callbacks,",
          "92:     struct service_range, tree_node, u32, max,",
          "93:     service_range_upper)",
          "95: #define service_range_entry(rbtree_node)    \\",
          "96:  (container_of(rbtree_node, struct service_range, tree_node))",
          "98: #define service_range_overlap(sr, start, end)    \\",
          "99:  ((sr)->lower <= (end) && (sr)->upper >= (start))",
          "108: #define service_range_foreach_match(sr, sc, start, end)   \\",
          "109:  for (sr = service_range_match_first((sc)->ranges.rb_node, \\",
          "110:          start,   \\",
          "111:          end);   \\",
          "112:       sr;       \\",
          "113:       sr = service_range_match_next(&(sr)->tree_node,  \\",
          "114:         start,   \\",
          "115:         end))",
          "125: static struct service_range *service_range_match_first(struct rb_node *n,",
          "126:              u32 start, u32 end)",
          "127: {",
          "128:  struct service_range *sr;",
          "129:  struct rb_node *l, *r;",
          "132:  if (!n || service_range_entry(n)->max < start)",
          "133:   return NULL;",
          "135:  while (n) {",
          "136:   l = n->rb_left;",
          "137:   if (l && service_range_entry(l)->max >= start) {",
          "142:    n = l;",
          "143:    continue;",
          "144:   }",
          "149:   sr = service_range_entry(n);",
          "150:   if (service_range_overlap(sr, start, end))",
          "151:    return sr;",
          "154:   r = n->rb_right;",
          "155:   if (sr->lower <= end &&",
          "156:       r && service_range_entry(r)->max >= start) {",
          "157:    n = r;",
          "158:    continue;",
          "159:   }",
          "160:   break;",
          "161:  }",
          "163:  return NULL;",
          "164: }",
          "174: static struct service_range *service_range_match_next(struct rb_node *n,",
          "175:             u32 start, u32 end)",
          "176: {",
          "177:  struct service_range *sr;",
          "178:  struct rb_node *p, *r;",
          "180:  while (n) {",
          "181:   r = n->rb_right;",
          "182:   if (r && service_range_entry(r)->max >= start)",
          "188:    return service_range_match_first(r, start, end);",
          "193:   while ((p = rb_parent(n)) && n == p->rb_right)",
          "194:    n = p;",
          "195:   if (!p)",
          "196:    break;",
          "199:   sr = service_range_entry(p);",
          "200:   if (service_range_overlap(sr, start, end))",
          "201:    return sr;",
          "204:   if (sr->lower <= end) {",
          "205:    n = p;",
          "206:    continue;",
          "207:   }",
          "208:   break;",
          "209:  }",
          "211:  return NULL;",
          "212: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "139:  return service;",
          "140: }",
          "167: static struct service_range *tipc_service_find_range(struct tipc_service *sc,",
          "168:            u32 lower, u32 upper)",
          "169: {",
          "171:  struct service_range *sr;",
          "182:  }",
          "187: }",
          "189: static struct service_range *tipc_service_create_range(struct tipc_service *sc,",
          "190:              u32 lower, u32 upper)",
          "191: {",
          "192:  struct rb_node **n, *parent = NULL;",
          "195:  n = &sc->ranges.rb_node;",
          "196:  while (*n) {",
          "198:   parent = *n;",
          "208:   else",
          "210:  }",
          "211:  sr = kzalloc(sizeof(*sr), GFP_ATOMIC);",
          "212:  if (!sr)",
          "213:   return NULL;",
          "214:  sr->lower = lower;",
          "215:  sr->upper = upper;",
          "216:  INIT_LIST_HEAD(&sr->local_publ);",
          "217:  INIT_LIST_HEAD(&sr->all_publ);",
          "218:  rb_link_node(&sr->tree_node, parent, n);",
          "220:  return sr;",
          "221: }",
          "",
          "[Removed Lines]",
          "147: static struct service_range *tipc_service_first_range(struct tipc_service *sc,",
          "148:             u32 instance)",
          "149: {",
          "150:  struct rb_node *n = sc->ranges.rb_node;",
          "151:  struct service_range *sr;",
          "153:  while (n) {",
          "154:   sr = container_of(n, struct service_range, tree_node);",
          "155:   if (sr->lower > instance)",
          "156:    n = n->rb_left;",
          "157:   else if (sr->upper < instance)",
          "158:    n = n->rb_right;",
          "159:   else",
          "160:    return sr;",
          "161:  }",
          "162:  return NULL;",
          "163: }",
          "170:  struct rb_node *n = sc->ranges.rb_node;",
          "173:  sr = tipc_service_first_range(sc, lower);",
          "174:  if (!sr)",
          "175:   return NULL;",
          "178:  for (n = &sr->tree_node; n; n = rb_next(n)) {",
          "179:   sr = container_of(n, struct service_range, tree_node);",
          "180:   if (sr->upper == upper)",
          "181:    break;",
          "183:  if (!n || sr->lower != lower || sr->upper != upper)",
          "184:   return NULL;",
          "186:  return sr;",
          "193:  struct service_range *sr, *tmp;",
          "197:   tmp = container_of(*n, struct service_range, tree_node);",
          "199:   tmp = container_of(parent, struct service_range, tree_node);",
          "200:   if (lower < tmp->lower)",
          "201:    n = &(*n)->rb_left;",
          "202:   else if (lower > tmp->lower)",
          "203:    n = &(*n)->rb_right;",
          "204:   else if (upper < tmp->upper)",
          "205:    n = &(*n)->rb_left;",
          "206:   else if (upper > tmp->upper)",
          "207:    n = &(*n)->rb_right;",
          "209:    return tmp;",
          "219:  rb_insert_color(&sr->tree_node, &sc->ranges);",
          "",
          "[Added Lines]",
          "276:  service_range_foreach_match(sr, sc, lower, upper) {",
          "278:   if (sr->lower == lower && sr->upper == upper)",
          "279:    return sr;",
          "282:  return NULL;",
          "289:  struct service_range *sr;",
          "294:   sr = service_range_entry(parent);",
          "295:   if (lower == sr->lower && upper == sr->upper)",
          "296:    return sr;",
          "297:   if (sr->max < upper)",
          "298:    sr->max = upper;",
          "299:   if (lower <= sr->lower)",
          "300:    n = &parent->rb_left;",
          "302:    n = &parent->rb_right;",
          "309:  sr->max = upper;",
          "313:  rb_insert_augmented(&sr->tree_node, &sc->ranges, &sr_callbacks);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "310:  struct list_head publ_list;",
          "311:  struct service_range *sr;",
          "312:  struct tipc_name_seq ns;",
          "314:  u32 filter;",
          "316:  ns.type = tipc_sub_read(sb, seq.type);",
          "",
          "[Removed Lines]",
          "313:  struct rb_node *n;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "325:   return;",
          "327:  INIT_LIST_HEAD(&publ_list);",
          "335:   first = NULL;",
          "336:   list_for_each_entry(p, &sr->all_publ, all_publ) {",
          "337:    if (filter & TIPC_SUB_PORTS)",
          "",
          "[Removed Lines]",
          "328:  for (n = rb_first(&service->ranges); n; n = rb_next(n)) {",
          "329:   sr = container_of(n, struct service_range, tree_node);",
          "330:   if (sr->lower > ns.upper)",
          "331:    break;",
          "332:   if (!tipc_sub_check_overlap(&ns, sr->lower, sr->upper))",
          "333:    continue;",
          "",
          "[Added Lines]",
          "421:  service_range_foreach_match(sr, service, ns.lower, ns.upper) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "427:  if (list_empty(&sr->all_publ)) {",
          "429:   kfree(sr);",
          "430:  }",
          "",
          "[Removed Lines]",
          "428:   rb_erase(&sr->tree_node, &sc->ranges);",
          "",
          "[Added Lines]",
          "515:   rb_erase_augmented(&sr->tree_node, &sc->ranges, &sr_callbacks);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "473:  rcu_read_lock();",
          "474:  sc = tipc_service_find(net, type);",
          "475:  if (unlikely(!sc))",
          "478:  spin_lock_bh(&sc->lock);",
          "498:  }",
          "502:  spin_unlock_bh(&sc->lock);",
          "504:  rcu_read_unlock();",
          "506:  return port;",
          "",
          "[Removed Lines]",
          "476:   goto not_found;",
          "479:  sr = tipc_service_first_range(sc, instance);",
          "480:  if (unlikely(!sr))",
          "481:   goto no_match;",
          "484:  if (*dnode == self) {",
          "485:   list = &sr->local_publ;",
          "486:   if (list_empty(list))",
          "487:    goto no_match;",
          "488:   p = list_first_entry(list, struct publication, local_publ);",
          "489:   list_move_tail(&p->local_publ, &sr->local_publ);",
          "490:  } else if (legacy && !*dnode && !list_empty(&sr->local_publ)) {",
          "491:   list = &sr->local_publ;",
          "492:   p = list_first_entry(list, struct publication, local_publ);",
          "493:   list_move_tail(&p->local_publ, &sr->local_publ);",
          "494:  } else {",
          "495:   list = &sr->all_publ;",
          "496:   p = list_first_entry(list, struct publication, all_publ);",
          "497:   list_move_tail(&p->all_publ, &sr->all_publ);",
          "499:  port = p->port;",
          "500:  node = p->node;",
          "501: no_match:",
          "503: not_found:",
          "",
          "[Added Lines]",
          "563:   goto exit;",
          "566:  service_range_foreach_match(sr, sc, instance, instance) {",
          "568:   if (*dnode == self) {",
          "569:    list = &sr->local_publ;",
          "570:    if (list_empty(list))",
          "571:     continue;",
          "572:    p = list_first_entry(list, struct publication,",
          "573:           local_publ);",
          "574:    list_move_tail(&p->local_publ, &sr->local_publ);",
          "575:   } else if (legacy && !*dnode && !list_empty(&sr->local_publ)) {",
          "576:    list = &sr->local_publ;",
          "577:    p = list_first_entry(list, struct publication,",
          "578:           local_publ);",
          "579:    list_move_tail(&p->local_publ, &sr->local_publ);",
          "580:   } else {",
          "581:    list = &sr->all_publ;",
          "582:    p = list_first_entry(list, struct publication,",
          "583:           all_publ);",
          "584:    list_move_tail(&p->all_publ, &sr->all_publ);",
          "585:   }",
          "586:   port = p->port;",
          "587:   node = p->node;",
          "591:   break;",
          "595: exit:",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "524:  spin_lock_bh(&sc->lock);",
          "527:  if (!sr)",
          "528:   goto no_match;",
          "",
          "[Removed Lines]",
          "526:  sr = tipc_service_first_range(sc, instance);",
          "",
          "[Added Lines]",
          "619:  sr = service_range_match_first(sc->ranges.rb_node, instance, instance);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "552:  struct service_range *sr;",
          "553:  struct tipc_service *sc;",
          "554:  struct publication *p;",
          "557:  rcu_read_lock();",
          "558:  sc = tipc_service_find(net, type);",
          "",
          "[Removed Lines]",
          "555:  struct rb_node *n;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "560:   goto exit;",
          "562:  spin_lock_bh(&sc->lock);",
          "570:   list_for_each_entry(p, &sr->local_publ, local_publ) {",
          "571:    if (p->scope == scope || (!exact && p->scope < scope))",
          "572:     tipc_dest_push(dports, 0, p->port);",
          "",
          "[Removed Lines]",
          "564:  for (n = rb_first(&sc->ranges); n; n = rb_next(n)) {",
          "565:   sr = container_of(n, struct service_range, tree_node);",
          "566:   if (sr->upper < lower)",
          "567:    continue;",
          "568:   if (sr->lower > upper)",
          "569:    break;",
          "",
          "[Added Lines]",
          "655:  service_range_foreach_match(sr, sc, lower, upper) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "587:  struct service_range *sr;",
          "588:  struct tipc_service *sc;",
          "589:  struct publication *p;",
          "592:  rcu_read_lock();",
          "593:  sc = tipc_service_find(net, type);",
          "",
          "[Removed Lines]",
          "590:  struct rb_node *n;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "595:   goto exit;",
          "597:  spin_lock_bh(&sc->lock);",
          "605:   list_for_each_entry(p, &sr->all_publ, all_publ) {",
          "606:    tipc_nlist_add(nodes, p->node);",
          "607:   }",
          "",
          "[Removed Lines]",
          "599:  for (n = rb_first(&sc->ranges); n; n = rb_next(n)) {",
          "600:   sr = container_of(n, struct service_range, tree_node);",
          "601:   if (sr->upper < lower)",
          "602:    continue;",
          "603:   if (sr->lower > upper)",
          "604:    break;",
          "",
          "[Added Lines]",
          "683:  service_range_foreach_match(sr, sc, lower, upper) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "799:    tipc_service_remove_publ(sr, p->node, p->key);",
          "800:    kfree_rcu(p, rcu);",
          "801:   }",
          "803:   kfree(sr);",
          "804:  }",
          "805:  hlist_del_init_rcu(&sc->service_list);",
          "",
          "[Removed Lines]",
          "802:   rb_erase(&sr->tree_node, &sc->ranges);",
          "",
          "[Added Lines]",
          "881:   rb_erase_augmented(&sr->tree_node, &sc->ranges, &sr_callbacks);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4c86b037a6db3ad2922ef3ba8a8989eb7794e040",
      "candidate_info": {
        "commit_hash": "4c86b037a6db3ad2922ef3ba8a8989eb7794e040",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4c86b037a6db3ad2922ef3ba8a8989eb7794e040",
        "files": [
          "drivers/scsi/qla2xxx/qla_init.c",
          "drivers/scsi/qla2xxx/qla_target.c"
        ],
        "message": "scsi: qla2xxx: Initialize free_work before flushing it\n\nTarget creation triggers a new BUG_ON introduced in in commit 4d43d395fed1\n(\"workqueue: Try to catch flush_work() without INIT_WORK().\").  The BUG_ON\nreveals an attempt to flush free_work in qla24xx_do_nack_work before it's\ninitialized in qlt_unreg_sess:\n\n  WARNING: CPU: 7 PID: 211 at kernel/workqueue.c:3031 __flush_work.isra.38+0x40/0x2e0\n  CPU: 7 PID: 211 Comm: kworker/7:1 Kdump: loaded Tainted: G            E     5.3.0-rc7-vanilla+ #2\n  Workqueue: qla2xxx_wq qla2x00_iocb_work_fn [qla2xxx]\n  NIP:  c000000000159620 LR: c0080000009d91b0 CTR: c0000000001598c0\n  REGS: c000000005f3f730 TRAP: 0700   Tainted: G            E      (5.3.0-rc7-vanilla+)\n  MSR:  800000000282b033 <SF,VEC,VSX,EE,FP,ME,IR,DR,RI,LE>  CR: 24002222  XER: 00000000\n  CFAR: c0000000001598d0 IRQMASK: 0\n  GPR00: c0080000009d91b0 c000000005f3f9c0 c000000001670a00 c0000003f8655ca8\n  GPR04: c0000003f8655c00 000000000000ffff 0000000000000011 ffffffffffffffff\n  GPR08: c008000000949228 0000000000000000 0000000000000001 c0080000009e7780\n  GPR12: 0000000000002200 c00000003fff6200 c000000000161bc8 0000000000000004\n  GPR16: c0000003f9d68280 0000000002000000 0000000000000005 0000000000000003\n  GPR20: 0000000000000002 000000000000ffff 0000000000000000 fffffffffffffef7\n  GPR24: c000000004f73848 c000000004f73838 c000000004f73f28 c000000005f3fb60\n  GPR28: c000000004f73e48 c000000004f73c80 c000000004f73818 c0000003f9d68280\n  NIP [c000000000159620] __flush_work.isra.38+0x40/0x2e0\n  LR [c0080000009d91b0] qla24xx_do_nack_work+0x88/0x180 [qla2xxx]\n  Call Trace:\n  [c000000005f3f9c0] [c000000000159644] __flush_work.isra.38+0x64/0x2e0 (unreliable)\n  [c000000005f3fa50] [c0080000009d91a0] qla24xx_do_nack_work+0x78/0x180 [qla2xxx]\n  [c000000005f3fae0] [c0080000009496ec] qla2x00_do_work+0x604/0xb90 [qla2xxx]\n  [c000000005f3fc40] [c008000000949cd8] qla2x00_iocb_work_fn+0x60/0xe0 [qla2xxx]\n  [c000000005f3fc80] [c000000000157bb8] process_one_work+0x2c8/0x5b0\n  [c000000005f3fd10] [c000000000157f28] worker_thread+0x88/0x660\n  [c000000005f3fdb0] [c000000000161d64] kthread+0x1a4/0x1b0\n  [c000000005f3fe20] [c00000000000b960] ret_from_kernel_thread+0x5c/0x7c\n  Instruction dump:\n  3d22001d 892966b1 7d908026 91810008 f821ff71 69290001 0b090000 2e290000\n  40920200 e9230018 7d2a0074 794ad182 <0b0a0000> 2fa90000 419e01e8 7c0802a6\n  ---[ end trace 5ccf335d4f90fcb8 ]---\n\nFixes: 1021f0bc2f3d6 (\"scsi: qla2xxx: allow session delete to finish before create.\")\nCc: Quinn Tran <qutran@marvell.com>\nCc: stable@vger.kernel.org\nLink: https://lore.kernel.org/r/20191125165702.1013-4-r.bolshakov@yadro.com\nAcked-by: Himanshu Madhani <hmadhani@marvell.com>\nReviewed-by: Hannes Reinecke <hare@suse.de>\nTested-by: Hannes Reinecke <hare@suse.de>\nReviewed-by: Bart Van Assche <bvanassche@acm.org>\nSigned-off-by: Roman Bolshakov <r.bolshakov@yadro.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
        "before_after_code_files": [
          "drivers/scsi/qla2xxx/qla_init.c||drivers/scsi/qla2xxx/qla_init.c",
          "drivers/scsi/qla2xxx/qla_target.c||drivers/scsi/qla2xxx/qla_target.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/scsi/qla2xxx/qla_init.c||drivers/scsi/qla2xxx/qla_init.c": [
          "File: drivers/scsi/qla2xxx/qla_init.c -> drivers/scsi/qla2xxx/qla_init.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4852:  }",
          "4854:  INIT_WORK(&fcport->del_work, qla24xx_delete_sess_fn);",
          "4855:  INIT_WORK(&fcport->reg_work, qla_register_fcport_fn);",
          "4856:  INIT_LIST_HEAD(&fcport->gnl_entry);",
          "4857:  INIT_LIST_HEAD(&fcport->list);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4855:  INIT_WORK(&fcport->free_work, qlt_free_session_done);",
          "",
          "---------------"
        ],
        "drivers/scsi/qla2xxx/qla_target.c||drivers/scsi/qla2xxx/qla_target.c": [
          "File: drivers/scsi/qla2xxx/qla_target.c -> drivers/scsi/qla2xxx/qla_target.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1161:  sess->last_rscn_gen = sess->rscn_gen;",
          "1162:  sess->last_login_gen = sess->login_gen;",
          "1165:  queue_work(sess->vha->hw->wq, &sess->free_work);",
          "1166: }",
          "1167: EXPORT_SYMBOL(qlt_unreg_sess);",
          "",
          "[Removed Lines]",
          "1164:  INIT_WORK(&sess->free_work, qlt_free_session_done);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b2bd75f806c49929d7ab5a860c0a69b0a17c59d2",
      "candidate_info": {
        "commit_hash": "b2bd75f806c49929d7ab5a860c0a69b0a17c59d2",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b2bd75f806c49929d7ab5a860c0a69b0a17c59d2",
        "files": [
          "include/linux/soundwire/sdw.h"
        ],
        "message": "soundwire: sdw_slave: track unattach_request to handle all init sequences\n\nThe Slave device initialization can be split in 4 different cases:\n\n1. Master-initiated hardware reset, system suspend-resume and\npm_runtime based on clock-stop mode1. To avoid timeouts and a bad\naudio experience, the Slave device resume operations need to wait for\nthe Slave device to be re-enumerated and its settings restored.\n\n2. Exit from clock-stop mode0. In this case, the Slave device is\nrequired to remain enumerated and its context preserved while the\nclock is stopped, so no re-initialization or wait_for_completion() is\nnecessary.\n\n3. Slave-initiated pm_runtime D3 transition. With the parent child\nrelationship, it is possible that a Slave device becomes 'suspended'\nwhile its parent is still 'active' with the bus clock still\ntoggling. In this case, during the pm_runtime resume operation, there\nis no need to wait for any settings to be restored.\n\n4. Slave reset (sync loss or implementation-defined). In that case the\nbus remains operational and the Slave device will be re-initialized\nwhen it becomes ATTACHED again.\n\nIn previous patches, we suggested the use of wait_for_completion() to\ndeal with the case #1, but case #2 and #3 do not need any wait.\n\nTo account for those differences, this patch adds an unattach_request\nfield. The field is explicitly set by the Master for the case #1, and\nif non-zero the Slave device shall wait on resume. In all other cases,\nthe Slave resume operations can proceed without wait.\n\nThe only request tracked so far is Master HardReset, but the request\nis declared as a bit mask for future extensions (if needed). The\ndefinition for this value is added in bus.h and does not need to be\nexposed in sdw.h\n\nSigned-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>\nLink: https://lore.kernel.org/r/20191212014507.28050-5-pierre-louis.bossart@linux.intel.com\nSigned-off-by: Vinod Koul <vkoul@kernel.org>",
        "before_after_code_files": [
          "include/linux/soundwire/sdw.h||include/linux/soundwire/sdw.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/linux/soundwire/sdw.h||include/linux/soundwire/sdw.h": [
          "File: include/linux/soundwire/sdw.h -> include/linux/soundwire/sdw.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "574:  struct completion probe_complete;",
          "575:  struct completion enumeration_complete;",
          "576:  struct completion initialization_complete;",
          "577: };",
          "579: #define dev_to_sdw_dev(_dev) container_of(_dev, struct sdw_slave, dev)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "582:  u32 unattach_request;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-38383",
  "cve_desc": "OwnTone (aka owntone-server) through 28.1 has a use-after-free in net_bind() in misc.c.",
  "repo": "owntone/owntone-server",
  "patch_hash": "246d8ae0cef27377e5dfe9ee3ad87e864d6b6266",
  "patch_info": {
    "commit_hash": "246d8ae0cef27377e5dfe9ee3ad87e864d6b6266",
    "repo": "owntone/owntone-server",
    "commit_url": "https://github.com/owntone/owntone-server/commit/246d8ae0cef27377e5dfe9ee3ad87e864d6b6266",
    "files": [
      "src/misc.c"
    ],
    "message": "[misc] Fix use-after-free in net_bind()\n\nThanks to Ba Jinsheng for reporting this bug",
    "before_after_code_files": [
      "src/misc.c||src/misc.c"
    ]
  },
  "patch_diff": {
    "src/misc.c||src/misc.c": [
      "File: src/misc.c -> src/misc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "251:   struct addrinfo hints = { 0 };",
      "252:   struct addrinfo *servinfo;",
      "253:   struct addrinfo *ptr;",
      "254:   const char *cfgaddr;",
      "255:   char addr[INET6_ADDRSTRLEN];",
      "256:   char strport[8];",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "254:   union net_sockaddr naddr = { 0 };",
      "255:   socklen_t naddr_len = sizeof(naddr);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "314:       goto error;",
      "315:     }",
      "319:   if (ret < 0)",
      "320:     {",
      "322:       goto error;",
      "323:     }",
      "328:   DPRINTF(E_DBG, L_MISC, \"Service '%s' bound to %s, port %hu, socket %d\\n\", log_service_name, addr, *port, fd);",
      "",
      "[Removed Lines]",
      "318:   ret = getsockname(fd, ptr->ai_addr, &ptr->ai_addrlen);",
      "321:       DPRINTF(E_LOG, L_MISC, \"Could not find address of service '%s': %s\\n\", log_service_name, strerror(errno));",
      "325:   net_port_get(port, (union net_sockaddr *)ptr->ai_addr);",
      "326:   net_address_get(addr, sizeof(addr), (union net_sockaddr *)ptr->ai_addr);",
      "",
      "[Added Lines]",
      "321:   ret = getsockname(fd, &naddr.sa, &naddr_len);",
      "324:       DPRINTF(E_LOG, L_MISC, \"Error finding address of service '%s': %s\\n\", log_service_name, strerror(errno));",
      "325:       goto error;",
      "326:     }",
      "327:   else if (naddr_len > sizeof(naddr))",
      "328:     {",
      "329:       DPRINTF(E_LOG, L_MISC, \"Unexpected address length of service '%s'\\n\", log_service_name);",
      "333:   net_port_get(port, &naddr);",
      "334:   net_address_get(addr, sizeof(addr), &naddr);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7871d71a9c2a495bd2c76e015f739c46a2af2042",
      "candidate_info": {
        "commit_hash": "7871d71a9c2a495bd2c76e015f739c46a2af2042",
        "repo": "owntone/owntone-server",
        "commit_url": "https://github.com/owntone/owntone-server/commit/7871d71a9c2a495bd2c76e015f739c46a2af2042",
        "files": [
          "forked-daapd.conf.in",
          "src/conffile.c",
          "src/httpd.c",
          "src/httpd_daap.c",
          "src/httpd_dacp.c",
          "src/httpd_rsp.c",
          "src/misc.c",
          "src/misc.h",
          "src/mpd.c"
        ],
        "message": "[misc] Add utility network functions, incl configurable addr binding\n\nAlso make misc.c/h a bit less messy.",
        "before_after_code_files": [
          "forked-daapd.conf.in||forked-daapd.conf.in",
          "src/conffile.c||src/conffile.c",
          "src/httpd.c||src/httpd.c",
          "src/httpd_daap.c||src/httpd_daap.c",
          "src/httpd_dacp.c||src/httpd_dacp.c",
          "src/httpd_rsp.c||src/httpd_rsp.c",
          "src/misc.c||src/misc.c",
          "src/misc.h||src/misc.h",
          "src/mpd.c||src/mpd.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/misc.c||src/misc.c"
          ],
          "candidate": [
            "src/misc.c||src/misc.c"
          ]
        }
      },
      "candidate_diff": {
        "forked-daapd.conf.in||forked-daapd.conf.in": [
          "File: forked-daapd.conf.in -> forked-daapd.conf.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "43:  # Enable/disable IPv6",
          "44:  ipv6 = yes",
          "46:  # Location of cache database",
          "47: # cache_path = \"@localstatedir@/cache/@PACKAGE@/cache.db\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46:  # Set this if you want the server to bind to a specific IP address. Can",
          "47:  # be ipv6 or ipv4. Default (commented out or \"::\") is to listen on all",
          "48:  # IP addresses.",
          "49: # bind_address = \"::\"",
          "",
          "---------------"
        ],
        "src/conffile.c||src/conffile.c": [
          "File: src/conffile.c -> src/conffile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "53:     CFG_INT(\"websocket_port\", 3688, CFGF_NONE),",
          "54:     CFG_STR_LIST(\"trusted_networks\", \"{localhost,192.168,fd}\", CFGF_NONE),",
          "55:     CFG_BOOL(\"ipv6\", cfg_true, CFGF_NONE),",
          "56:     CFG_STR(\"cache_path\", STATEDIR \"/cache/\" PACKAGE \"/cache.db\", CFGF_NONE),",
          "57:     CFG_INT(\"cache_daap_threshold\", 1000, CFGF_NONE),",
          "58:     CFG_BOOL(\"speaker_autoselect\", cfg_false, CFGF_NONE),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "56:     CFG_STR(\"bind_address\", NULL, CFGF_NONE),",
          "",
          "---------------"
        ],
        "src/httpd.c||src/httpd.c": [
          "File: src/httpd.c -> src/httpd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1500:   evhttp_connection_get_peer(evcon, &addr, &port);",
          "1503:     return true;",
          "1505:   passwd = cfg_getstr(cfg_getsec(cfg, \"general\"), \"admin_password\");",
          "",
          "[Removed Lines]",
          "1502:   if (peer_address_is_trusted(addr))",
          "",
          "[Added Lines]",
          "1502:   if (net_peer_address_is_trusted(addr))",
          "",
          "---------------"
        ],
        "src/httpd_daap.c||src/httpd_daap.c": [
          "File: src/httpd_daap.c -> src/httpd_daap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "717:   char *passwd;",
          "718:   int ret;",
          "721:     return 0;",
          "",
          "[Removed Lines]",
          "720:   if (peer_address_is_trusted(hreq->peer_address))",
          "",
          "[Added Lines]",
          "720:   if (net_peer_address_is_trusted(hreq->peer_address))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "924:   CHECK_ERR(L_DAAP, evbuffer_expand(hreq->reply, 32));",
          "926:   param = evhttp_find_header(hreq->query, \"pairing-guid\");",
          "928:     {",
          "929:       if (strlen(param) < 3)",
          "930:  {",
          "",
          "[Removed Lines]",
          "927:   if (param && !peer_address_is_trusted(hreq->peer_address))",
          "",
          "[Added Lines]",
          "927:   if (param && !net_peer_address_is_trusted(hreq->peer_address))",
          "",
          "---------------"
        ],
        "src/httpd_dacp.c||src/httpd_dacp.c": [
          "File: src/httpd_dacp.c -> src/httpd_dacp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "609:   int32_t id;",
          "610:   int ret;",
          "613:     return 0;",
          "615:   param = evhttp_find_header(hreq->query, \"session-id\");",
          "",
          "[Removed Lines]",
          "612:   if (peer_address_is_trusted(hreq->peer_address))",
          "",
          "[Added Lines]",
          "612:   if (net_peer_address_is_trusted(hreq->peer_address))",
          "",
          "---------------"
        ],
        "src/httpd_rsp.c||src/httpd_rsp.c": [
          "File: src/httpd_rsp.c -> src/httpd_rsp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "295:   char *passwd;",
          "296:   int ret;",
          "299:     return 0;",
          "301:   passwd = cfg_getstr(cfg_getsec(cfg, \"library\"), \"password\");",
          "",
          "[Removed Lines]",
          "298:   if (peer_address_is_trusted(hreq->peer_address))",
          "",
          "[Added Lines]",
          "298:   if (net_peer_address_is_trusted(hreq->peer_address))",
          "",
          "---------------"
        ],
        "src/misc.c||src/misc.c": [
          "File: src/misc.c -> src/misc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: #include <inttypes.h>",
          "38: #include <limits.h>",
          "39: #include <sys/param.h>",
          "40: #ifndef CLOCK_REALTIME",
          "41: #include <sys/time.h>",
          "42: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40: #include <sys/types.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "44: #include <uuid/uuid.h>",
          "45: #endif",
          "47: #include <unistr.h>",
          "48: #include <uniconv.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "48: #include <netdb.h>",
          "49: #include <arpa/inet.h>",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "107:     NULL",
          "108:   };",
          "112: {",
          "114: }",
          "116: int",
          "117: safe_atoi32(const char *str, int32_t *val)",
          "118: {",
          "",
          "[Removed Lines]",
          "110: char **",
          "111: buildopts_get()",
          "113:   return buildopts;",
          "",
          "[Added Lines]",
          "117: bool",
          "118: net_peer_address_is_trusted(const char *addr)",
          "120:   cfg_t *section;",
          "121:   const char *network;",
          "122:   int i;",
          "123:   int n;",
          "125:   if (!addr)",
          "126:     return false;",
          "128:   if (strncmp(addr, \"::ffff:\", strlen(\"::ffff:\")) == 0)",
          "129:     addr += strlen(\"::ffff:\");",
          "131:   section = cfg_getsec(cfg, \"general\");",
          "133:   n = cfg_size(section, \"trusted_networks\");",
          "134:   for (i = 0; i < n; i++)",
          "135:     {",
          "136:       network = cfg_getnstr(section, \"trusted_networks\", i);",
          "138:       if (!network || network[0] == '\\0')",
          "139:  return false;",
          "141:       if (strncmp(network, addr, strlen(network)) == 0)",
          "142:  return true;",
          "144:       if ((strcmp(network, \"localhost\") == 0) && (strcmp(addr, \"127.0.0.1\") == 0 || strcmp(addr, \"::1\") == 0))",
          "145:  return true;",
          "147:       if (strcmp(network, \"any\") == 0)",
          "148:  return true;",
          "149:     }",
          "151:   return false;",
          "152: }",
          "154: int",
          "155: net_address_get(char *addr, size_t addr_len, union net_sockaddr *naddr)",
          "156: {",
          "157:   const char *s;",
          "159:   memset(addr, 0, addr_len); // Just in case caller doesn't check for errors",
          "161:   if (naddr->sa.sa_family == AF_INET6)",
          "162:      s = inet_ntop(AF_INET6, &naddr->sin6.sin6_addr, addr, addr_len);",
          "163:   else",
          "164:      s = inet_ntop(AF_INET, &naddr->sin.sin_addr, addr, addr_len);",
          "166:   if (!s)",
          "167:     return -1;",
          "169:   return 0;",
          "170: }",
          "172: int",
          "173: net_port_get(short unsigned *port, union net_sockaddr *naddr)",
          "174: {",
          "175:   if (naddr->sa.sa_family == AF_INET6)",
          "177:   else",
          "180:   return 0;",
          "181: }",
          "183: int",
          "184: net_connect(const char *addr, unsigned short port, int type)",
          "185: {",
          "186:   struct addrinfo hints = { 0 };",
          "187:   struct addrinfo *servinfo;",
          "188:   struct addrinfo *ptr;",
          "189:   char strport[8];",
          "190:   int fd;",
          "191:   int ret;",
          "193:   DPRINTF(E_DBG, L_MISC, \"Connecting to %s, port %u\\n\", addr, port);",
          "195:   hints.ai_socktype = type;",
          "196:   hints.ai_family = (cfg_getbool(cfg_getsec(cfg, \"general\"), \"ipv6\")) ? AF_UNSPEC : AF_INET;",
          "198:   snprintf(strport, sizeof(strport), \"%hu\", port);",
          "199:   ret = getaddrinfo(addr, strport, &hints, &servinfo);",
          "200:   if (ret < 0)",
          "201:     {",
          "202:       gai_strerror(ret);",
          "203:       return -1;",
          "204:     }",
          "206:   for (ptr = servinfo; ptr; ptr = ptr->ai_next)",
          "207:     {",
          "208:       fd = socket(ptr->ai_family, ptr->ai_socktype | SOCK_CLOEXEC, ptr->ai_protocol);",
          "209:       if (fd < 0)",
          "210:  {",
          "211:    continue;",
          "212:  }",
          "214:       ret = connect(fd, ptr->ai_addr, ptr->ai_addrlen);",
          "215:       if (ret < 0)",
          "216:  {",
          "217:    close(fd);",
          "218:    continue;",
          "219:  }",
          "221:       break;",
          "222:     }",
          "224:   freeaddrinfo(servinfo);",
          "226:   if (!ptr)",
          "227:     {",
          "228:       DPRINTF(E_LOG, L_MISC, \"Failed to connect to %s, port %u: %s\\n\", addr, port, strerror(errno));",
          "229:       return -1;",
          "230:     }",
          "234:   return fd;",
          "235: }",
          "239: int",
          "240: net_bind(short unsigned *port, int type, const char *log_service_name)",
          "241: {",
          "242:   struct addrinfo hints = { 0 };",
          "243:   struct addrinfo *servinfo;",
          "244:   struct addrinfo *ptr;",
          "245:   const char *cfgaddr;",
          "246:   char addr[INET6_ADDRSTRLEN];",
          "247:   char strport[8];",
          "248:   int yes = 1;",
          "249:   int no = 0;",
          "250:   int fd;",
          "251:   int ret;",
          "253:   cfgaddr = cfg_getstr(cfg_getsec(cfg, \"general\"), \"bind_address\");",
          "255:   hints.ai_socktype = type;",
          "256:   hints.ai_family = (cfg_getbool(cfg_getsec(cfg, \"general\"), \"ipv6\")) ? AF_INET6 : AF_INET;",
          "257:   hints.ai_flags = cfgaddr ? 0 : AI_PASSIVE;",
          "259:   snprintf(strport, sizeof(strport), \"%hu\", *port);",
          "260:   ret = getaddrinfo(cfgaddr, strport, &hints, &servinfo);",
          "261:   if (ret < 0)",
          "262:     {",
          "263:       DPRINTF(E_LOG, L_MISC, \"Failure creating '%s' service, could not resolve '%s' (port %s): %s\\n\", log_service_name, cfgaddr ? cfgaddr : \"(ANY)\", strport, gai_strerror(ret));",
          "264:       return -1;",
          "265:     }",
          "267:   for (ptr = servinfo, fd = -1; ptr != NULL; ptr = ptr->ai_next)",
          "268:     {",
          "269:       if (fd >= 0)",
          "270:  close(fd);",
          "272:       fd = socket(ptr->ai_family, ptr->ai_socktype | SOCK_CLOEXEC, ptr->ai_protocol);",
          "273:       if (fd < 0)",
          "274:  continue;",
          "277:       ret = setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &yes, sizeof(yes));",
          "278:       if (ret < 0)",
          "279:  continue;",
          "281:       ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));",
          "282:       if (ret < 0)",
          "283:  continue;",
          "285:       if (ptr->ai_family == AF_INET6)",
          "286:  {",
          "288:    ret = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &no, sizeof(no));",
          "289:    if (ret < 0)",
          "290:      continue;",
          "291:  }",
          "293:       ret = bind(fd, ptr->ai_addr, ptr->ai_addrlen);",
          "294:       if (ret < 0)",
          "295:  continue;",
          "297:       break;",
          "298:     }",
          "300:   freeaddrinfo(servinfo);",
          "302:   if (!ptr)",
          "303:     {",
          "304:       DPRINTF(E_LOG, L_MISC, \"Could not create service '%s' with address %s, port %hu: %s\\n\", log_service_name, cfgaddr ? cfgaddr : \"(ANY)\", *port, strerror(errno));",
          "305:       goto error;",
          "306:     }",
          "309:   ret = getsockname(fd, ptr->ai_addr, &ptr->ai_addrlen);",
          "310:   if (ret < 0)",
          "311:     {",
          "312:       DPRINTF(E_LOG, L_MISC, \"Could not find address of service '%s': %s\\n\", log_service_name, strerror(errno));",
          "313:       goto error;",
          "314:     }",
          "316:   net_port_get(port, (union net_sockaddr *)ptr->ai_addr);",
          "317:   net_address_get(addr, sizeof(addr), (union net_sockaddr *)ptr->ai_addr);",
          "319:   DPRINTF(E_DBG, L_MISC, \"Service '%s' bound to %s, port %hu, socket %d\\n\", log_service_name, addr, *port, fd);",
          "321:   return fd;",
          "323:  error:",
          "324:   close(fd);",
          "325:   return -1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "441: }",
          "447: {",
          "452:     {",
          "455:       return NULL;",
          "456:     }",
          "459: }",
          "463: {",
          "522: }",
          "526: {",
          "528: }",
          "797: {",
          "798:   const unsigned char *bytes = data;",
          "799:   uint32_t hash = 5381;",
          "",
          "[Removed Lines]",
          "445: struct keyval *",
          "446: keyval_alloc(void)",
          "448:   struct keyval *kv;",
          "450:   kv = calloc(1, sizeof(struct keyval));",
          "451:   if (!kv)",
          "453:       DPRINTF(E_LOG, L_MISC, \"Out of memory for keyval alloc\\n\");",
          "458:   return kv;",
          "461: int",
          "462: keyval_add_size(struct keyval *kv, const char *name, const char *value, size_t size)",
          "464:   struct onekeyval *okv;",
          "465:   const char *val;",
          "467:   if (!kv)",
          "468:     return -1;",
          "471:   val = keyval_get(kv, name);",
          "472:   if (val)",
          "473:     {",
          "475:       if (strcmp(val, value) == 0)",
          "476:         return 0;",
          "478:         return -1;",
          "479:     }",
          "481:   okv = (struct onekeyval *)malloc(sizeof(struct onekeyval));",
          "482:   if (!okv)",
          "483:     {",
          "484:       DPRINTF(E_LOG, L_MISC, \"Out of memory for new keyval\\n\");",
          "486:       return -1;",
          "487:     }",
          "489:   okv->name = strdup(name);",
          "490:   if (!okv->name)",
          "491:     {",
          "492:       DPRINTF(E_LOG, L_MISC, \"Out of memory for new keyval name\\n\");",
          "494:       free(okv);",
          "495:       return -1;",
          "496:     }",
          "498:   okv->value = (char *)malloc(size + 1);",
          "499:   if (!okv->value)",
          "500:     {",
          "501:       DPRINTF(E_LOG, L_MISC, \"Out of memory for new keyval value\\n\");",
          "503:       free(okv->name);",
          "504:       free(okv);",
          "505:       return -1;",
          "506:     }",
          "508:   memcpy(okv->value, value, size);",
          "509:   okv->value[size] = '\\0';",
          "511:   okv->next = NULL;",
          "513:   if (!kv->head)",
          "514:     kv->head = okv;",
          "516:   if (kv->tail)",
          "517:     kv->tail->next = okv;",
          "519:   kv->tail = okv;",
          "521:   return 0;",
          "524: int",
          "525: keyval_add(struct keyval *kv, const char *name, const char *value)",
          "527:   return keyval_add_size(kv, name, value, strlen(value));",
          "530: void",
          "531: keyval_remove(struct keyval *kv, const char *name)",
          "532: {",
          "533:   struct onekeyval *okv;",
          "534:   struct onekeyval *pokv;",
          "536:   if (!kv)",
          "537:     return;",
          "539:   for (pokv = NULL, okv = kv->head; okv; pokv = okv, okv = okv->next)",
          "540:     {",
          "541:       if (strcasecmp(okv->name, name) == 0)",
          "542:         break;",
          "543:     }",
          "545:   if (!okv)",
          "546:     return;",
          "548:   if (okv == kv->head)",
          "549:     kv->head = okv->next;",
          "551:   if (okv == kv->tail)",
          "552:     kv->tail = pokv;",
          "554:   if (pokv)",
          "555:     pokv->next = okv->next;",
          "557:   free(okv->name);",
          "558:   free(okv->value);",
          "559:   free(okv);",
          "560: }",
          "562: const char *",
          "563: keyval_get(struct keyval *kv, const char *name)",
          "564: {",
          "565:   struct onekeyval *okv;",
          "567:   if (!kv)",
          "568:     return NULL;",
          "570:   for (okv = kv->head; okv; okv = okv->next)",
          "571:     {",
          "572:       if (strcasecmp(okv->name, name) == 0)",
          "573:         return okv->value;",
          "574:     }",
          "576:   return NULL;",
          "577: }",
          "579: void",
          "580: keyval_clear(struct keyval *kv)",
          "581: {",
          "582:   struct onekeyval *hokv;",
          "583:   struct onekeyval *okv;",
          "585:   if (!kv)",
          "586:     return;",
          "588:   hokv = kv->head;",
          "590:   for (okv = hokv; hokv; okv = hokv)",
          "591:     {",
          "592:       hokv = okv->next;",
          "594:       free(okv->name);",
          "595:       free(okv->value);",
          "596:       free(okv);",
          "597:     }",
          "599:   kv->head = NULL;",
          "600:   kv->tail = NULL;",
          "601: }",
          "603: void",
          "604: keyval_sort(struct keyval *kv)",
          "605: {",
          "606:   struct onekeyval *head;",
          "607:   struct onekeyval *okv;",
          "608:   struct onekeyval *sokv;",
          "610:   if (!kv || !kv->head)",
          "611:     return;",
          "613:   head = kv->head;",
          "614:   for (okv = kv->head; okv; okv = okv->next)",
          "615:     {",
          "616:       okv->sort = NULL;",
          "617:       for (sokv = kv->head; sokv; sokv = sokv->next)",
          "618:  {",
          "621:    if ( (strcmp(sokv->name, okv->name) > 0) &&",
          "622:         ((okv->sort == NULL) || (strcmp(sokv->name, okv->sort->name) < 0)) )",
          "623:      okv->sort = sokv;",
          "624:  }",
          "627:       if (strcmp(okv->name, head->name) < 0)",
          "628:  head = okv;",
          "629:     }",
          "631:   while ((okv = kv->head))",
          "632:     {",
          "633:       kv->head  = okv->next;",
          "634:       okv->next = okv->sort;",
          "635:     }",
          "637:   kv->head = head;",
          "638:   for (okv = kv->head; okv; okv = okv->next)",
          "639:     kv->tail = okv;",
          "641:   DPRINTF(E_DBG, L_MISC, \"Keyval sorted. New head: %s. New tail: %s.\\n\", kv->head->name, kv->tail->name);",
          "642: }",
          "645: char **",
          "646: m_readfile(const char *path, int num_lines)",
          "647: {",
          "648:   char buf[256];",
          "649:   FILE *fp;",
          "650:   char **lines;",
          "651:   char *line;",
          "652:   int i;",
          "655:   lines = calloc(num_lines, sizeof(char *));",
          "656:   if (!lines)",
          "657:     return NULL;",
          "659:   fp = fopen(path, \"rb\");",
          "660:   if (!fp)",
          "661:     {",
          "662:       DPRINTF(E_LOG, L_MISC, \"Could not open file '%s' for reading: %s\\n\", path, strerror(errno));",
          "663:       free(lines);",
          "664:       return NULL;",
          "665:     }",
          "667:   for (i = 0; i < num_lines; i++)",
          "668:     {",
          "669:       line = fgets(buf, sizeof(buf), fp);",
          "670:       if (!line)",
          "671:  {",
          "672:    DPRINTF(E_LOG, L_MISC, \"File '%s' has fewer lines than expected (found %d, expected %d)\\n\", path, i, num_lines);",
          "673:    goto error;",
          "674:  }",
          "676:       lines[i] = atrim(line);",
          "677:       if (!lines[i] || (strlen(lines[i]) == 0))",
          "678:  {",
          "679:    DPRINTF(E_LOG, L_MISC, \"Line %d in '%s' is invalid\\n\", i+1, path);",
          "680:    goto error;",
          "681:  }",
          "682:     }",
          "684:   fclose(fp);",
          "686:   return lines;",
          "688:  error:",
          "689:   for (i = 0; i < num_lines; i++)",
          "690:     free(lines[i]);",
          "692:   free(lines);",
          "693:   fclose(fp);",
          "694:   return NULL;",
          "695: }",
          "697: char *",
          "698: unicode_fixup_string(char *str, const char *fromcode)",
          "699: {",
          "700:   uint8_t *ret;",
          "701:   size_t len;",
          "703:   if (!str)",
          "704:     return NULL;",
          "706:   len = strlen(str);",
          "709:   if (!u8_check((uint8_t *)str, len))",
          "710:     {",
          "711:       if (len >= 3)",
          "712:  {",
          "714:    if (memcmp(\"\\xef\\xbb\\xbf\", str, 3) == 0)",
          "715:      memmove(str, str + 3, len - 3 + 1);",
          "716:  }",
          "718:       return str;",
          "719:     }",
          "721:   ret = u8_strconv_from_encoding(str, fromcode, iconveh_question_mark);",
          "722:   if (!ret)",
          "723:     {",
          "724:       DPRINTF(E_LOG, L_MISC, \"Could not convert string '%s' to UTF-8: %s\\n\", str, strerror(errno));",
          "726:       return NULL;",
          "727:     }",
          "729:   return (char *)ret;",
          "730: }",
          "732: char *",
          "733: trim(char *str)",
          "734: {",
          "735:   size_t start; // Position of first non-space char",
          "736:   size_t term;  // Position of 0-terminator",
          "738:   if (!str)",
          "739:     return NULL;",
          "741:   start = 0;",
          "742:   term  = strlen(str);",
          "744:   while ((start < term) && isspace(str[start]))",
          "745:     start++;",
          "746:   while ((term > start) && isspace(str[term - 1]))",
          "747:     term--;",
          "749:   str[term] = '\\0';",
          "752:   if (start)",
          "753:     memmove(str, str + start, term - start + 1);",
          "755:   return str;",
          "756: }",
          "758: char *",
          "759: atrim(const char *str)",
          "760: {",
          "761:   size_t start; // Position of first non-space char",
          "762:   size_t term;  // Position of 0-terminator",
          "763:   size_t size;",
          "764:   char *result;",
          "766:   if (!str)",
          "767:     return NULL;",
          "769:   start = 0;",
          "770:   term  = strlen(str);",
          "772:   while ((start < term) && isspace(str[start]))",
          "773:     start++;",
          "774:   while ((term > start) && isspace(str[term - 1]))",
          "775:     term--;",
          "777:   size = term - start + 1;",
          "779:   result = malloc(size);",
          "781:   memcpy(result, str + start, size);",
          "782:   result[size - 1] = '\\0';",
          "784:   return result;",
          "785: }",
          "787: void",
          "788: swap_pointers(char **a, char **b)",
          "789: {",
          "790:   char *t = *a;",
          "793: }",
          "795: uint32_t",
          "796: djb_hash(const void *data, size_t len)",
          "",
          "[Added Lines]",
          "659: char *",
          "660: unicode_fixup_string(char *str, const char *fromcode)",
          "662:   uint8_t *ret;",
          "663:   size_t len;",
          "665:   if (!str)",
          "666:     return NULL;",
          "668:   len = strlen(str);",
          "671:   if (!u8_check((uint8_t *)str, len))",
          "673:       if (len >= 3)",
          "674:  {",
          "676:    if (memcmp(\"\\xef\\xbb\\xbf\", str, 3) == 0)",
          "677:      memmove(str, str + 3, len - 3 + 1);",
          "678:  }",
          "680:       return str;",
          "681:     }",
          "683:   ret = u8_strconv_from_encoding(str, fromcode, iconveh_question_mark);",
          "684:   if (!ret)",
          "685:     {",
          "686:       DPRINTF(E_LOG, L_MISC, \"Could not convert string '%s' to UTF-8: %s\\n\", str, strerror(errno));",
          "691:   return (char *)ret;",
          "694: char *",
          "695: trim(char *str)",
          "697:   size_t start; // Position of first non-space char",
          "698:   size_t term;  // Position of 0-terminator",
          "700:   if (!str)",
          "701:     return NULL;",
          "703:   start = 0;",
          "704:   term  = strlen(str);",
          "706:   while ((start < term) && isspace(str[start]))",
          "707:     start++;",
          "708:   while ((term > start) && isspace(str[term - 1]))",
          "709:     term--;",
          "711:   str[term] = '\\0';",
          "714:   if (start)",
          "715:     memmove(str, str + start, term - start + 1);",
          "717:   return str;",
          "718: }",
          "720: char *",
          "721: atrim(const char *str)",
          "722: {",
          "723:   size_t start; // Position of first non-space char",
          "724:   size_t term;  // Position of 0-terminator",
          "725:   size_t size;",
          "726:   char *result;",
          "728:   if (!str)",
          "729:     return NULL;",
          "731:   start = 0;",
          "732:   term  = strlen(str);",
          "734:   while ((start < term) && isspace(str[start]))",
          "735:     start++;",
          "736:   while ((term > start) && isspace(str[term - 1]))",
          "737:     term--;",
          "739:   size = term - start + 1;",
          "741:   result = malloc(size);",
          "743:   memcpy(result, str + start, size);",
          "744:   result[size - 1] = '\\0';",
          "746:   return result;",
          "749: void",
          "750: swap_pointers(char **a, char **b)",
          "752:   char *t = *a;",
          "757: uint32_t",
          "758: djb_hash(const void *data, size_t len)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1015: # error Platform not supported",
          "1016: #endif",
          "1021: {",
          "1026: }",
          "1030: {",
          "1040:     {",
          "1055:     }",
          "1056: }",
          "1061: {",
          "1097: }",
          "1101: {",
          "1117:     {",
          "1136: int",
          "1137: ringbuffer_init(struct ringbuffer *buf, size_t size)",
          "",
          "[Removed Lines]",
          "1018: #ifdef HAVE_UUID",
          "1019: void",
          "1020: uuid_make(char *str)",
          "1022:   uuid_t uu;",
          "1024:   uuid_generate_random(uu);",
          "1025:   uuid_unparse_upper(uu, str);",
          "1027: #else",
          "1028: void",
          "1029: uuid_make(char *str)",
          "1031:   uint16_t uuid[8];",
          "1032:   time_t now;",
          "1033:   int i;",
          "1035:   now = time(NULL);",
          "1037:   srand((unsigned int)now);",
          "1039:   for (i = 0; i < ARRAY_SIZE(uuid); i++)",
          "1041:       uuid[i] = (uint16_t)rand();",
          "1044:       if (i == 3)",
          "1045:  uuid[i] = (uuid[i] & 0x0FFF) | 0x4000;",
          "1047:       if (i == 4)",
          "1048:  uuid[i] = (uuid[i] & 0x3FFF) | 0x8000;",
          "1051:       if (i == 2 || i == 3 || i == 4 || i == 5)",
          "1052:  str += sprintf(str, \"-\");",
          "1054:       str += sprintf(str, \"%04\" PRIX16, uuid[i]);",
          "1057: #endif",
          "1059: int",
          "1060: linear_regression(double *m, double *b, double *r2, const double *x, const double *y, int n)",
          "1062:   double x_val;",
          "1063:   double sum_x  = 0;",
          "1064:   double sum_x2 = 0;",
          "1065:   double sum_y  = 0;",
          "1066:   double sum_y2 = 0;",
          "1067:   double sum_xy = 0;",
          "1068:   double denom;",
          "1069:   int i;",
          "1071:   for (i = 0; i < n; i++)",
          "1072:     {",
          "1073:       x_val   = x ? x[i] : (double)i;",
          "1074:       sum_x  += x_val;",
          "1075:       sum_x2 += x_val * x_val;",
          "1076:       sum_y  += y[i];",
          "1077:       sum_y2 += y[i] * y[i];",
          "1078:       sum_xy += x_val * y[i];",
          "1079:     }",
          "1081:   denom = (n * sum_x2 - sum_x * sum_x);",
          "1082:   if (denom == 0)",
          "1083:     return -1;",
          "1087:   if (r2)",
          "1090:   return 0;",
          "1091: }",
          "1093: bool",
          "1094: quality_is_equal(struct media_quality *a, struct media_quality *b)",
          "1095: {",
          "1096:   return (a->sample_rate == b->sample_rate && a->bits_per_sample == b->bits_per_sample && a->channels == b->channels && a->bit_rate == b->bit_rate);",
          "1099: bool",
          "1100: peer_address_is_trusted(const char *addr)",
          "1102:   cfg_t *section;",
          "1103:   const char *network;",
          "1104:   int i;",
          "1105:   int n;",
          "1107:   if (!addr)",
          "1108:     return false;",
          "1110:   if (strncmp(addr, \"::ffff:\", strlen(\"::ffff:\")) == 0)",
          "1111:     addr += strlen(\"::ffff:\");",
          "1113:   section = cfg_getsec(cfg, \"general\");",
          "1115:   n = cfg_size(section, \"trusted_networks\");",
          "1116:   for (i = 0; i < n; i++)",
          "1118:       network = cfg_getnstr(section, \"trusted_networks\", i);",
          "1120:       if (!network || network[0] == '\\0')",
          "1121:  return false;",
          "1123:       if (strncmp(network, addr, strlen(network)) == 0)",
          "1124:  return true;",
          "1126:       if ((strcmp(network, \"localhost\") == 0) && (strcmp(addr, \"127.0.0.1\") == 0 || strcmp(addr, \"::1\") == 0))",
          "1127:  return true;",
          "1129:       if (strcmp(network, \"any\") == 0)",
          "1130:  return true;",
          "1131:     }",
          "1133:   return false;",
          "1134: }",
          "",
          "[Added Lines]",
          "983: struct keyval *",
          "984: keyval_alloc(void)",
          "986:   struct keyval *kv;",
          "988:   kv = calloc(1, sizeof(struct keyval));",
          "989:   if (!kv)",
          "990:     {",
          "991:       DPRINTF(E_LOG, L_MISC, \"Out of memory for keyval alloc\\n\");",
          "993:       return NULL;",
          "994:     }",
          "996:   return kv;",
          "999: int",
          "1000: keyval_add_size(struct keyval *kv, const char *name, const char *value, size_t size)",
          "1002:   struct onekeyval *okv;",
          "1003:   const char *val;",
          "1005:   if (!kv)",
          "1006:     return -1;",
          "1009:   val = keyval_get(kv, name);",
          "1010:   if (val)",
          "1011:     {",
          "1013:       if (strcmp(val, value) == 0)",
          "1014:         return 0;",
          "1016:         return -1;",
          "1017:     }",
          "1019:   okv = (struct onekeyval *)malloc(sizeof(struct onekeyval));",
          "1020:   if (!okv)",
          "1022:       DPRINTF(E_LOG, L_MISC, \"Out of memory for new keyval\\n\");",
          "1024:       return -1;",
          "1025:     }",
          "1027:   okv->name = strdup(name);",
          "1028:   if (!okv->name)",
          "1029:     {",
          "1030:       DPRINTF(E_LOG, L_MISC, \"Out of memory for new keyval name\\n\");",
          "1032:       free(okv);",
          "1033:       return -1;",
          "1034:     }",
          "1036:   okv->value = (char *)malloc(size + 1);",
          "1037:   if (!okv->value)",
          "1038:     {",
          "1039:       DPRINTF(E_LOG, L_MISC, \"Out of memory for new keyval value\\n\");",
          "1041:       free(okv->name);",
          "1042:       free(okv);",
          "1043:       return -1;",
          "1044:     }",
          "1046:   memcpy(okv->value, value, size);",
          "1047:   okv->value[size] = '\\0';",
          "1049:   okv->next = NULL;",
          "1051:   if (!kv->head)",
          "1052:     kv->head = okv;",
          "1054:   if (kv->tail)",
          "1055:     kv->tail->next = okv;",
          "1057:   kv->tail = okv;",
          "1059:   return 0;",
          "1060: }",
          "1062: int",
          "1063: keyval_add(struct keyval *kv, const char *name, const char *value)",
          "1064: {",
          "1065:   return keyval_add_size(kv, name, value, strlen(value));",
          "1066: }",
          "1068: void",
          "1069: keyval_remove(struct keyval *kv, const char *name)",
          "1070: {",
          "1071:   struct onekeyval *okv;",
          "1072:   struct onekeyval *pokv;",
          "1074:   if (!kv)",
          "1075:     return;",
          "1077:   for (pokv = NULL, okv = kv->head; okv; pokv = okv, okv = okv->next)",
          "1078:     {",
          "1079:       if (strcasecmp(okv->name, name) == 0)",
          "1080:         break;",
          "1081:     }",
          "1083:   if (!okv)",
          "1084:     return;",
          "1086:   if (okv == kv->head)",
          "1087:     kv->head = okv->next;",
          "1089:   if (okv == kv->tail)",
          "1090:     kv->tail = pokv;",
          "1092:   if (pokv)",
          "1093:     pokv->next = okv->next;",
          "1095:   free(okv->name);",
          "1096:   free(okv->value);",
          "1097:   free(okv);",
          "1098: }",
          "1100: const char *",
          "1101: keyval_get(struct keyval *kv, const char *name)",
          "1102: {",
          "1103:   struct onekeyval *okv;",
          "1105:   if (!kv)",
          "1106:     return NULL;",
          "1108:   for (okv = kv->head; okv; okv = okv->next)",
          "1109:     {",
          "1110:       if (strcasecmp(okv->name, name) == 0)",
          "1111:         return okv->value;",
          "1114:   return NULL;",
          "1117: void",
          "1118: keyval_clear(struct keyval *kv)",
          "1120:   struct onekeyval *hokv;",
          "1121:   struct onekeyval *okv;",
          "1123:   if (!kv)",
          "1124:     return;",
          "1126:   hokv = kv->head;",
          "1128:   for (okv = hokv; hokv; okv = hokv)",
          "1129:     {",
          "1130:       hokv = okv->next;",
          "1132:       free(okv->name);",
          "1133:       free(okv->value);",
          "1134:       free(okv);",
          "1135:     }",
          "1137:   kv->head = NULL;",
          "1138:   kv->tail = NULL;",
          "1141: void",
          "1142: keyval_sort(struct keyval *kv)",
          "1144:   struct onekeyval *head;",
          "1145:   struct onekeyval *okv;",
          "1146:   struct onekeyval *sokv;",
          "1148:   if (!kv || !kv->head)",
          "1149:     return;",
          "1151:   head = kv->head;",
          "1152:   for (okv = kv->head; okv; okv = okv->next)",
          "1153:     {",
          "1154:       okv->sort = NULL;",
          "1155:       for (sokv = kv->head; sokv; sokv = sokv->next)",
          "1156:  {",
          "1159:    if ( (strcmp(sokv->name, okv->name) > 0) &&",
          "1160:         ((okv->sort == NULL) || (strcmp(sokv->name, okv->sort->name) < 0)) )",
          "1161:      okv->sort = sokv;",
          "1162:  }",
          "1165:       if (strcmp(okv->name, head->name) < 0)",
          "1166:  head = okv;",
          "1167:     }",
          "1169:   while ((okv = kv->head))",
          "1171:       kv->head  = okv->next;",
          "1172:       okv->next = okv->sort;",
          "1173:     }",
          "1175:   kv->head = head;",
          "1176:   for (okv = kv->head; okv; okv = okv->next)",
          "1177:     kv->tail = okv;",
          "1179:   DPRINTF(E_DBG, L_MISC, \"Keyval sorted. New head: %s. New tail: %s.\\n\", kv->head->name, kv->tail->name);",
          "1180: }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1414: int",
          "1415: mutex_init(pthread_mutex_t *mutex)",
          "1416: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1469: bool",
          "1470: quality_is_equal(struct media_quality *a, struct media_quality *b)",
          "1471: {",
          "1472:   return (a->sample_rate == b->sample_rate && a->bits_per_sample == b->bits_per_sample && a->channels == b->channels && a->bit_rate == b->bit_rate);",
          "1473: }",
          "1478: char **",
          "1479: buildopts_get()",
          "1480: {",
          "1481:   return buildopts;",
          "1482: }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1425:   return err;",
          "1426: }",
          "1428: void",
          "1429: log_fatal_err(int domain, const char *func, int line, int err)",
          "1430: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1498: #ifdef HAVE_UUID",
          "1499: void",
          "1500: uuid_make(char *str)",
          "1501: {",
          "1502:   uuid_t uu;",
          "1504:   uuid_generate_random(uu);",
          "1505:   uuid_unparse_upper(uu, str);",
          "1506: }",
          "1507: #else",
          "1508: void",
          "1509: uuid_make(char *str)",
          "1510: {",
          "1511:   uint16_t uuid[8];",
          "1512:   time_t now;",
          "1513:   int i;",
          "1515:   now = time(NULL);",
          "1517:   srand((unsigned int)now);",
          "1519:   for (i = 0; i < ARRAY_SIZE(uuid); i++)",
          "1520:     {",
          "1521:       uuid[i] = (uint16_t)rand();",
          "1524:       if (i == 3)",
          "1525:  uuid[i] = (uuid[i] & 0x0FFF) | 0x4000;",
          "1527:       if (i == 4)",
          "1528:  uuid[i] = (uuid[i] & 0x3FFF) | 0x8000;",
          "1531:       if (i == 2 || i == 3 || i == 4 || i == 5)",
          "1532:  str += sprintf(str, \"-\");",
          "1534:       str += sprintf(str, \"%04\" PRIX16, uuid[i]);",
          "1535:     }",
          "1536: }",
          "1537: #endif",
          "1539: int",
          "1540: linear_regression(double *m, double *b, double *r2, const double *x, const double *y, int n)",
          "1541: {",
          "1542:   double x_val;",
          "1543:   double sum_x  = 0;",
          "1544:   double sum_x2 = 0;",
          "1545:   double sum_y  = 0;",
          "1546:   double sum_y2 = 0;",
          "1547:   double sum_xy = 0;",
          "1548:   double denom;",
          "1549:   int i;",
          "1551:   for (i = 0; i < n; i++)",
          "1552:     {",
          "1553:       x_val   = x ? x[i] : (double)i;",
          "1554:       sum_x  += x_val;",
          "1555:       sum_x2 += x_val * x_val;",
          "1556:       sum_y  += y[i];",
          "1557:       sum_y2 += y[i] * y[i];",
          "1558:       sum_xy += x_val * y[i];",
          "1559:     }",
          "1561:   denom = (n * sum_x2 - sum_x * sum_x);",
          "1562:   if (denom == 0)",
          "1563:     return -1;",
          "1567:   if (r2)",
          "1570:   return 0;",
          "1571: }",
          "1573: char **",
          "1574: m_readfile(const char *path, int num_lines)",
          "1575: {",
          "1576:   char buf[256];",
          "1577:   FILE *fp;",
          "1578:   char **lines;",
          "1579:   char *line;",
          "1580:   int i;",
          "1583:   lines = calloc(num_lines, sizeof(char *));",
          "1584:   if (!lines)",
          "1585:     return NULL;",
          "1587:   fp = fopen(path, \"rb\");",
          "1588:   if (!fp)",
          "1589:     {",
          "1590:       DPRINTF(E_LOG, L_MISC, \"Could not open file '%s' for reading: %s\\n\", path, strerror(errno));",
          "1591:       free(lines);",
          "1592:       return NULL;",
          "1593:     }",
          "1595:   for (i = 0; i < num_lines; i++)",
          "1596:     {",
          "1597:       line = fgets(buf, sizeof(buf), fp);",
          "1598:       if (!line)",
          "1599:  {",
          "1600:    DPRINTF(E_LOG, L_MISC, \"File '%s' has fewer lines than expected (found %d, expected %d)\\n\", path, i, num_lines);",
          "1601:    goto error;",
          "1602:  }",
          "1604:       lines[i] = atrim(line);",
          "1605:       if (!lines[i] || (strlen(lines[i]) == 0))",
          "1606:  {",
          "1607:    DPRINTF(E_LOG, L_MISC, \"Line %d in '%s' is invalid\\n\", i+1, path);",
          "1608:    goto error;",
          "1609:  }",
          "1610:     }",
          "1612:   fclose(fp);",
          "1614:   return lines;",
          "1616:  error:",
          "1617:   for (i = 0; i < num_lines; i++)",
          "1618:     free(lines[i]);",
          "1620:   free(lines);",
          "1621:   fclose(fp);",
          "1622:   return NULL;",
          "1623: }",
          "",
          "---------------"
        ],
        "src/misc.h||src/misc.h": [
          "File: src/misc.h -> src/misc.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: #endif",
          "9: #include <stdint.h>",
          "10: #include <stdbool.h>",
          "15: #define STOB(s, bits, c) ((s) * (c) * (bits) / 8)",
          "16: #define BTOS(b, bits, c) ((b) / ((c) * (bits) / 8))",
          "",
          "[Removed Lines]",
          "11: #include <time.h>",
          "12: #include <pthread.h>",
          "",
          "[Added Lines]",
          "9: #include <stddef.h>",
          "15: #include <sys/socket.h>",
          "16: #include <netinet/in.h>",
          "18: union net_sockaddr",
          "19: {",
          "20:   struct sockaddr_in sin;",
          "21:   struct sockaddr_in6 sin6;",
          "22:   struct sockaddr sa;",
          "23:   struct sockaddr_storage ss;",
          "24: };",
          "27: bool",
          "28: net_peer_address_is_trusted(const char *addr);",
          "30: int",
          "31: net_address_get(char *addr, size_t addr_len, union net_sockaddr *naddr);",
          "33: int",
          "34: net_port_get(short unsigned *port, union net_sockaddr *naddr);",
          "36: int",
          "37: net_connect(const char *addr, unsigned short port, int type);",
          "39: int",
          "40: net_bind(short unsigned *port, int type, const char *log_service_name);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "30: #define NTOSTR_HELPER(x) #x",
          "31: #define NTOSTR(x) NTOSTR_HELPER(x)",
          "68: int",
          "69: safe_atoi32(const char *str, int32_t *val);",
          "",
          "[Removed Lines]",
          "35: struct media_quality {",
          "36:   int sample_rate;",
          "37:   int bits_per_sample;",
          "38:   int channels;",
          "39:   int bit_rate;",
          "40: };",
          "42: struct onekeyval {",
          "43:   char *name;",
          "44:   char *value;",
          "46:   struct onekeyval *next;",
          "47:   struct onekeyval *sort;",
          "48: };",
          "50: struct keyval {",
          "51:   struct onekeyval *head;",
          "52:   struct onekeyval *tail;",
          "53: };",
          "55: struct ringbuffer {",
          "56:   uint8_t *buffer;",
          "57:   size_t size;",
          "58:   size_t write_avail;",
          "59:   size_t read_avail;",
          "60:   size_t write_pos;",
          "61:   size_t read_pos;",
          "62: };",
          "65: char **",
          "66: buildopts_get(void);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "95: int",
          "96: safe_snreplace(char *s, size_t sz, const char *pattern, const char *replacement);",
          "124: char *",
          "125: unicode_fixup_string(char *str, const char *fromcode);",
          "",
          "[Removed Lines]",
          "99: struct keyval *",
          "100: keyval_alloc(void);",
          "102: int",
          "103: keyval_add(struct keyval *kv, const char *name, const char *value);",
          "105: int",
          "106: keyval_add_size(struct keyval *kv, const char *name, const char *value, size_t size);",
          "108: void",
          "109: keyval_remove(struct keyval *kv, const char *name);",
          "111: const char *",
          "112: keyval_get(struct keyval *kv, const char *name);",
          "114: void",
          "115: keyval_clear(struct keyval *kv);",
          "117: void",
          "118: keyval_sort(struct keyval *kv);",
          "121: char **",
          "122: m_readfile(const char *path, int num_lines);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "150: uint64_t",
          "151: murmur_hash64(const void *key, int len, uint32_t seed);",
          "156: int",
          "166: int",
          "167: ringbuffer_init(struct ringbuffer *buf, size_t size);",
          "",
          "[Removed Lines]",
          "153: void",
          "154: uuid_make(char *str);",
          "157: linear_regression(double *m, double *b, double *r, const double *x, const double *y, int n);",
          "159: bool",
          "160: quality_is_equal(struct media_quality *a, struct media_quality *b);",
          "163: bool",
          "164: peer_address_is_trusted(const char *addr);",
          "",
          "[Added Lines]",
          "126: struct onekeyval {",
          "127:   char *name;",
          "128:   char *value;",
          "130:   struct onekeyval *next;",
          "131:   struct onekeyval *sort;",
          "132: };",
          "134: struct keyval {",
          "135:   struct onekeyval *head;",
          "136:   struct onekeyval *tail;",
          "137: };",
          "139: struct keyval *",
          "140: keyval_alloc(void);",
          "143: keyval_add(struct keyval *kv, const char *name, const char *value);",
          "145: int",
          "146: keyval_add_size(struct keyval *kv, const char *name, const char *value, size_t size);",
          "148: void",
          "149: keyval_remove(struct keyval *kv, const char *name);",
          "151: const char *",
          "152: keyval_get(struct keyval *kv, const char *name);",
          "154: void",
          "155: keyval_clear(struct keyval *kv);",
          "157: void",
          "158: keyval_sort(struct keyval *kv);",
          "163: struct ringbuffer {",
          "164:   uint8_t *buffer;",
          "165:   size_t size;",
          "166:   size_t write_avail;",
          "167:   size_t read_avail;",
          "168:   size_t write_pos;",
          "169:   size_t read_pos;",
          "170: };",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "176: ringbuffer_read(uint8_t **dst, size_t dstlen, struct ringbuffer *buf);",
          "179: #ifndef HAVE_CLOCK_GETTIME",
          "181: #ifndef CLOCK_REALTIME",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "187: #include <time.h>",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "230: struct timespec",
          "231: timespec_reltoabs(struct timespec relative);",
          "234: int",
          "235: mutex_init(pthread_mutex_t *mutex);",
          "238:    returned error (type errno) if it fails, and aborts the process.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "247: struct media_quality {",
          "248:   int sample_rate;",
          "249:   int bits_per_sample;",
          "250:   int channels;",
          "251:   int bit_rate;",
          "252: };",
          "254: bool",
          "255: quality_is_equal(struct media_quality *a, struct media_quality *b);",
          "260: #include <pthread.h>",
          "262: char **",
          "263: buildopts_get(void);",
          "269: void",
          "270: uuid_make(char *str);",
          "272: int",
          "273: linear_regression(double *m, double *b, double *r, const double *x, const double *y, int n);",
          "275: char **",
          "276: m_readfile(const char *path, int num_lines);",
          "",
          "---------------"
        ],
        "src/mpd.c||src/mpd.c": [
          "File: src/mpd.c -> src/mpd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4511:   if (!client_ctx->authenticated)",
          "4512:     {",
          "4513:       sockaddr_to_string(address, addr_str, sizeof(addr_str));",
          "4515:     }",
          "4517:   client_ctx->next = mpd_clients;",
          "",
          "[Removed Lines]",
          "4514:       client_ctx->authenticated = peer_address_is_trusted(addr_str);",
          "",
          "[Added Lines]",
          "4514:       client_ctx->authenticated = net_peer_address_is_trusted(addr_str);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
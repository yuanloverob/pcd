{
  "cve_id": "CVE-2019-19645",
  "cve_desc": "alter.c in SQLite through 3.30.1 allows attackers to trigger infinite recursion via certain types of self-referential views in conjunction with ALTER TABLE statements.",
  "repo": "sqlite/sqlite",
  "patch_hash": "38096961c7cd109110ac21d3ed7dad7e0cb0ae06",
  "patch_info": {
    "commit_hash": "38096961c7cd109110ac21d3ed7dad7e0cb0ae06",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/38096961c7cd109110ac21d3ed7dad7e0cb0ae06",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/alter.c",
      "src/build.c",
      "src/sqliteInt.h",
      "test/altertab3.test"
    ],
    "message": "Avoid infinite recursion in the ALTER TABLE code when a view contains an unused CTE that references, directly or indirectly, the view itself.\n\nFossilOrigin-Name: 1d2e53a39b87e364685e21de137655b6eee725e4c6d27fc90865072d7c5892b5",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/alter.c||src/alter.c",
      "src/build.c||src/build.c",
      "src/sqliteInt.h||src/sqliteInt.h",
      "test/altertab3.test||test/altertab3.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: c5d44143599f3fe98492b2b900fa3d77925c7be545096251055ceeab899a41f1",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/alter.c||src/alter.c": [
      "File: src/alter.c -> src/alter.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "760:   Parse *pParse = pWalker->pParse;",
      "761:   int i;",
      "762:   if( pParse->nErr ) return WRC_Abort;",
      "763:   if( ALWAYS(p->pEList) ){",
      "764:     ExprList *pList = p->pEList;",
      "765:     for(i=0; i<pList->nExpr; i++){",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "763:   if( p->selFlags & SF_View ) return WRC_Prune;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "853: static int renameColumnSelectCb(Walker *pWalker, Select *p){",
      "854:   renameWalkWith(pWalker, p);",
      "855:   return WRC_Continue;",
      "856: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "855:   if( p->selFlags & SF_View ) return WRC_Prune;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1316:   if( sParse.pNewTable ){",
      "1317:     Select *pSelect = sParse.pNewTable->pSelect;",
      "1318:     if( pSelect ){",
      "1319:       sParse.rc = SQLITE_OK;",
      "1321:       rc = (db->mallocFailed ? SQLITE_NOMEM : sParse.rc);",
      "1322:       if( rc==SQLITE_OK ){",
      "1323:         sqlite3WalkSelect(&sWalker, pSelect);",
      "",
      "[Removed Lines]",
      "1320:       sqlite3SelectPrep(&sParse, sParse.pNewTable->pSelect, 0);",
      "",
      "[Added Lines]",
      "1321:       pSelect->selFlags &= ~SF_View;",
      "1323:       sqlite3SelectPrep(&sParse, pSelect, 0);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1434:   int i;",
      "1435:   RenameCtx *p = pWalker->u.pRename;",
      "1436:   SrcList *pSrc = pSelect->pSrc;",
      "1437:   if( pSrc==0 ){",
      "1438:     assert( pWalker->pParse->db->mallocFailed );",
      "1439:     return WRC_Abort;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1440:   if( pSelect->selFlags & SF_View ) return WRC_Prune;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1514:         if( pTab->pSelect ){",
      "1515:           if( isLegacy==0 ){",
      "1516:             NameContext sNC;",
      "1517:             memset(&sNC, 0, sizeof(sNC));",
      "1518:             sNC.pParse = &sParse;",
      "1520:             sqlite3SelectPrep(&sParse, pTab->pSelect, &sNC);",
      "1521:             if( sParse.nErr ) rc = sParse.rc;",
      "1522:             sqlite3WalkSelect(&sWalker, pTab->pSelect);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1520:             Select *pSelect = pTab->pSelect;",
      "1525:             assert( pSelect->selFlags & SF_View );",
      "1526:             pSelect->selFlags &= ~SF_View;",
      "",
      "---------------"
    ],
    "src/build.c||src/build.c": [
      "File: src/build.c -> src/build.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2488:   if( IN_RENAME_OBJECT ){",
      "2489:     p->pSelect = pSelect;",
      "2490:     pSelect = 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2488:   pSelect->selFlags |= SF_View;",
      "",
      "---------------"
    ],
    "src/sqliteInt.h||src/sqliteInt.h": [
      "File: src/sqliteInt.h -> src/sqliteInt.h"
    ],
    "test/altertab3.test||test/altertab3.test": [
      "File: test/altertab3.test -> test/altertab3.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "487:   ALTER TABLE a RENAME a TO b;",
      "488: }",
      "491: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "490: #------------------------------------------------------------------------",
      "491: #",
      "492: reset_db",
      "493: do_execsql_test 22.1 {",
      "494:   CREATE TABLE t1(a);",
      "495:   CREATE VIEW v2(b) AS SELECT * FROM v2;",
      "496: }",
      "498: do_catchsql_test 22.2 {",
      "499:   ALTER TABLE t1 RENAME TO t4;",
      "500: } {1 {error in view v2: view v2 is circularly defined}}",
      "502: do_execsql_test 22.3 {",
      "503:   DROP VIEW v2;",
      "504:   CREATE VIEW v2(b) AS WITH t3 AS (SELECT b FROM v2) SELECT * FROM t3;",
      "505: }",
      "507: breakpoint",
      "508: do_catchsql_test 22.4 {",
      "509:   ALTER TABLE t1 RENAME TO t4;",
      "510: } {1 {error in view v2: view v2 is circularly defined}}",
      "512: do_execsql_test 22.5 {",
      "513:   DROP VIEW v2;",
      "514:   CREATE VIEW v2(b) AS WITH t3 AS (SELECT b FROM v2) VALUES(1);",
      "515: }",
      "517: do_catchsql_test 22.6 {",
      "518:   ALTER TABLE t1 RENAME TO t4;",
      "519: } {0 {}}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "276d7f78470002e09ede5bd96556cddbc23cd678",
      "candidate_info": {
        "commit_hash": "276d7f78470002e09ede5bd96556cddbc23cd678",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/276d7f78470002e09ede5bd96556cddbc23cd678",
        "files": [
          "manifest",
          "manifest.uuid",
          "tool/lempar.c"
        ],
        "message": "Try to fix a harmless compiler warning reported by ICC.\n\nFossilOrigin-Name: 7f41b44ca2ecb907ea0fd09a974ac9dbdf911463a94f0f77c826cf1b1d9c3e8c",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "tool/lempar.c||tool/lempar.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: b528bdcd45db1b783ecd9739c3d3c890f04de7003f079668970eafaf8e23b2f3",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "tool/lempar.c||tool/lempar.c": [
          "File: tool/lempar.c -> tool/lempar.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1068:   return yyFallback[iToken];",
          "1069: #else",
          "1070:   (void)iToken;",
          "1072:   return 0;",
          "1073: }",
          "",
          "[Removed Lines]",
          "1071: #endif",
          "",
          "[Added Lines]",
          "1072: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a2b6806b3e4dd2d39b2d776e7eaecff17bc2d086",
      "candidate_info": {
        "commit_hash": "a2b6806b3e4dd2d39b2d776e7eaecff17bc2d086",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/a2b6806b3e4dd2d39b2d776e7eaecff17bc2d086",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/build.c"
        ],
        "message": "If the string formatter in sqlite3NestedParse() fails due to an over-length string, make sure this error is recorded by the parser so that it knows to fail.\n\nFossilOrigin-Name: 85e53ff13300132250221de769a2aa7d92d81bb48d60f6e99000bc69a5b1e6fb",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/build.c||src/build.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid",
            "src/build.c||src/build.c"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid",
            "src/build.c||src/build.c"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: bbdbaf84a52937ccf877072a8b01b07f7b9c037c59ba54df72ca888d5404cbad",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "266:     if( !db->mallocFailed ) pParse->rc = SQLITE_TOOBIG;",
          "267:     return;",
          "268:   }",
          "269:   pParse->nested++;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "267:     pParse->nErr++;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0a8d06a93f308e2ad450a62b961a09d43c15bba6",
      "candidate_info": {
        "commit_hash": "0a8d06a93f308e2ad450a62b961a09d43c15bba6",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/0a8d06a93f308e2ad450a62b961a09d43c15bba6",
        "files": [
          "manifest",
          "manifest.uuid",
          "test/view.test",
          "test/window9.test"
        ],
        "message": "Add test cases to this branch.\n\nFossilOrigin-Name: f37317d81cc2864ed57c76a7347351310d61c8056a2a0179218530ba60a44986",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "test/view.test||test/view.test",
          "test/window9.test||test/window9.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 7480db307c39b86bce269583e5917f5e1a3990500552fd98400ef3e7088c0b2a",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/view.test||test/view.test": [
          "File: test/view.test -> test/view.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "724:   1 1 3 3",
          "725: }",
          "727: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "727: #-------------------------------------------------------------------------",
          "728: reset_db",
          "729: do_execsql_test view-27.0 {",
          "730:   CREATE TABLE t0(c0 TEXT, c1);",
          "731:   INSERT INTO t0(c0, c1) VALUES (-1, 0);",
          "732:   CREATE VIEW v0(c0, c1) AS SELECT t0.c0, AVG(t0.c1) FROM t0;",
          "733: }",
          "735: do_execsql_test view-27.1 {",
          "736:   SELECT c0, typeof(c0), affinity(c0), c1, typeof(c1), affinity(c1) FROM v0;",
          "737: } {",
          "738:   -1   text text",
          "739:    0.0 real none",
          "740: }",
          "742: do_execsql_test view-27.2 { SELECT c0<c1 FROM v0 } 1",
          "743: do_execsql_test view-27.3 { SELECT c1<c0 FROM v0 } 0",
          "744: do_execsql_test view-27.4 {",
          "745:   SELECT 1 FROM v0 WHERE c1<c0",
          "746: } {}",
          "747: do_execsql_test view-27.5 {",
          "748:   SELECT 1 FROM v0 WHERE c0<c1",
          "749: } {1}",
          "751: do_execsql_test view-27.6 {",
          "752:   SELECT c0<c1 FROM (SELECT t0.c0 AS c0, AVG(t0.c1) AS c1 FROM t0)",
          "753: } 1",
          "754: do_execsql_test view-27.7 {",
          "755:   SELECT c1<c0 FROM (SELECT t0.c0 AS c0, AVG(t0.c1) AS c1 FROM t0)",
          "756: } 0",
          "757: do_execsql_test view-27.8 {",
          "758:   SELECT 1 FROM (SELECT t0.c0 AS c0, AVG(t0.c1) AS c1 FROM t0) WHERE c1<c0",
          "759: } {}",
          "760: do_execsql_test view-27.9 {",
          "761:   SELECT 1 FROM (SELECT t0.c0 AS c0, AVG(t0.c1) AS c1 FROM t0) WHERE c0<c1",
          "762: } {1}",
          "",
          "---------------"
        ],
        "test/window9.test||test/window9.test": [
          "File: test/window9.test -> test/window9.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "131:       );",
          "132: } {1 {sub-select returns 3 columns - expected 1}}",
          "135: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "134: #-------------------------------------------------------------------------",
          "135: reset_db",
          "136: do_execsql_test 4.0 {",
          "137:   CREATE TABLE t1(a, b TEXT);",
          "138:   INSERT INTO t1 VALUES('A', 1), ('A', 2), ('2', 1), ('2', 2);",
          "139: }",
          "141: do_execsql_test 4.1.1 {",
          "142:   SELECT b, b=count(*), '1,2'                   FROM t1 GROUP BY b;",
          "143: } {1 0 1,2 2 1 1,2}",
          "144: do_execsql_test 4.1.2 {",
          "145:   SELECT b, b=count(*), group_concat(b) OVER () FROM t1 GROUP BY b;",
          "146: } {1 0 1,2 2 1 1,2}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "427b96aedf422b1a8e906e47e8852033c70939c4",
      "candidate_info": {
        "commit_hash": "427b96aedf422b1a8e906e47e8852033c70939c4",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/427b96aedf422b1a8e906e47e8852033c70939c4",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/build.c",
          "src/insert.c",
          "src/sqliteInt.h",
          "src/update.c"
        ],
        "message": "New testcase() macros.  Fix a problem with INSERT when the IPK is to the right of generated columns.\n\nFossilOrigin-Name: 412799fc5527aaca987e4e04b8a4f774dcdb70fb80e3a126dc3a26d48a66935c",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/build.c||src/build.c",
          "src/insert.c||src/insert.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/update.c||src/update.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid",
            "src/build.c||src/build.c",
            "src/sqliteInt.h||src/sqliteInt.h"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid",
            "src/build.c||src/build.c",
            "src/sqliteInt.h||src/sqliteInt.h"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: ba123b8c201053d8f9387de38f3513b06f7721b28d79fab8489f96d336105117",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2207:   }",
          "2209: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "2211:     int ii;",
          "2212:     for(ii=0; ii<p->nCol; ii++){",
          "2213:       u32 colFlags = p->aCol[ii].colFlags;",
          "2215:         sqlite3ResolveSelfReference(pParse, p, NC_GenCol,",
          "2216:                                     p->aCol[ii].pDflt, 0);",
          "2217:       }",
          "",
          "[Removed Lines]",
          "2210:   if( p->tabFlags & (TF_HasVirtual|TF_HasStored) ){",
          "2214:       if( (colFlags & (COLFLAG_STORED|COLFLAG_VIRTUAL))!=0 ){",
          "",
          "[Added Lines]",
          "2210:   if( p->tabFlags & TF_HasGenerated ){",
          "2212:     testcase( p->tabFlags & TF_HasVirtual );",
          "2213:     testcase( p->tabFlags & TF_HasStored );",
          "2216:       if( (colFlags & COLFLAG_GENERATED)!=0 ){",
          "2217:         testcase( colFlags & COLFLAG_VIRTUAL );",
          "2218:         testcase( colFlags & COLFLAG_STORED );",
          "",
          "---------------"
        ],
        "src/insert.c||src/insert.c": [
          "File: src/insert.c -> src/insert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "223:   for(i=0; i<pTab->nCol; i++){",
          "224:     if( pTab->aCol[i].colFlags & COLFLAG_GENERATED ){",
          "225:       pTab->aCol[i].colFlags |= COLFLAG_NOTAVAIL;",
          "226:     }",
          "227:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "225:       testcase( pTab->aCol[i].colflags & COLFLAG_VIRTUAL );",
          "226:       testcase( pTab->aCol[i].colflags & COLFLAG_STORED );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "855:   if( pColumn==0 && nColumn>0 ){",
          "856:     ipkColumn = pTab->iPKey;",
          "857:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "859: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "860:     if( pTab->tabFlags & TF_HasGenerated ){",
          "861:       testcase( pTab->tabFlags & TF_HasVirtual );",
          "862:       testcase( pTab->tabFlags & TF_HasGenerated );",
          "863:       for(i=ipkColumn-1; i>=0; i--){",
          "864:         if( pTab->aCol[i].colFlags & COLFLAG_GENERATED ){",
          "865:           testcase( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL );",
          "866:           testcase( pTab->aCol[i].colFlags & COLFLAG_GENERATED );",
          "867:           ipkColumn--;",
          "868:         }",
          "869:       }",
          "870:     }",
          "871: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1074:       sqlite3ComputeGeneratedColumns(pParse, regCols+1, pTab);",
          "1075:     }",
          "1076: #endif",
          "",
          "[Removed Lines]",
          "1073:     if( pTab->tabFlags & (TF_HasStored|TF_HasVirtual) ){",
          "",
          "[Added Lines]",
          "1088:     if( pTab->tabFlags & TF_HasGenerated ){",
          "1089:       testcase( pTab->tabFlags & TF_HasVirtual );",
          "1090:       testcase( pTab->tabFlags & TF_HasStored );",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1143:       sqlite3ComputeGeneratedColumns(pParse, regRowid+1, pTab);",
          "1144:     }",
          "1145: #endif",
          "",
          "[Removed Lines]",
          "1142:     if( pTab->tabFlags & (TF_HasStored|TF_HasVirtual) ){",
          "",
          "[Added Lines]",
          "1159:     if( pTab->tabFlags & TF_HasGenerated ){",
          "1160:       testcase( pTab->tabFlags & TF_HasVirtual );",
          "1161:       testcase( pTab->tabFlags & TF_HasStored );",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1486:     testcase( i!=sqlite3TableColumnToStorage(pTab, i) );",
          "1487:     testcase( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL );",
          "1488:     testcase( pTab->aCol[i].colFlags & COLFLAG_STORED );",
          "1490:     iReg = sqlite3TableColumnToStorage(pTab, i) + regNewData + 1;",
          "1491:     switch( onError ){",
          "1492:       case OE_Replace: {",
          "",
          "[Removed Lines]",
          "1489:     testcase( pTab->aCol[i].colFlags & COLFLAG_GENERATED );",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2423:     if( (pDestCol->colFlags & COLFLAG_GENERATED)!=0 ){",
          "2424:       if( sqlite3ExprCompare(0, pSrcCol->pDflt, pDestCol->pDflt, -1)!=0 ){",
          "2426:       }",
          "2427:     }",
          "2428:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2443:         testcase( pDestCol->colflags & COLFLAG_VIRTUAL );",
          "2444:         testcase( pDestCol->colflags & COLFLAG_STORED );",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h"
        ],
        "src/update.c||src/update.c": [
          "File: src/update.c -> src/update.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "313:           chngPk = 1;",
          "314:         }",
          "315: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "317:           sqlite3ErrorMsg(pParse,",
          "318:              \"cannot UPDATE generated column \\\"%s\\\"\",",
          "319:              pTab->aCol[j].zName);",
          "",
          "[Removed Lines]",
          "316:         else if( pTab->aCol[j].colFlags & (COLFLAG_STORED|COLFLAG_VIRTUAL) ){",
          "",
          "[Added Lines]",
          "316:         else if( pTab->aCol[j].colFlags & COLFLAG_GENERATED ){",
          "317:           testcase( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL );",
          "318:           testcase( pTab->aCol[i].colFlags & COLFLAG_STORED );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "693:     }",
          "694:   }",
          "695: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "697:     sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);",
          "698:   }",
          "699: #endif",
          "",
          "[Removed Lines]",
          "696:   if( pTab->tabFlags & (TF_HasStored|TF_HasVirtual) ){",
          "",
          "[Added Lines]",
          "698:   if( pTab->tabFlags & TF_HasGenerated ){",
          "699:     testcase( pTab->tabFlags & TF_HasVirtual );",
          "700:     testcase( pTab->tabFlags & TF_HasStored );",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "737:       }",
          "738:     }",
          "739: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "741:       sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);",
          "742:     }",
          "743: #endif",
          "",
          "[Removed Lines]",
          "740:     if( pTab->tabFlags & (TF_HasStored|TF_HasVirtual) ){",
          "",
          "[Added Lines]",
          "744:     if( pTab->tabFlags & TF_HasGenerated ){",
          "745:       testcase( pTab->tabFlags & TF_HasVirtual );",
          "746:       testcase( pTab->tabFlags & TF_HasStored );",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "85bcdce270575e78258148c00f2efff7e81e7bc1",
      "candidate_info": {
        "commit_hash": "85bcdce270575e78258148c00f2efff7e81e7bc1",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/85bcdce270575e78258148c00f2efff7e81e7bc1",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/expr.c",
          "src/sqliteInt.h",
          "src/wherecode.c"
        ],
        "message": "Split the code generation for the RHS of IN operators and for SELECT and EXISTS expressions into two separate subroutines, because there is now little commonality between those to functions. This is intended to help make the code easier to read and maintain.\n\nFossilOrigin-Name: 2b6494b1509f0d0189f98aa34c990eee99c775ff57826e79b2c5b0a12b4c97ad",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/expr.c||src/expr.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/wherecode.c||src/wherecode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid",
            "src/sqliteInt.h||src/sqliteInt.h"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid",
            "src/sqliteInt.h||src/sqliteInt.h"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 6231485114eb07b258cd0e6e163ca05f7e9cf5664e071808fcb1329b33e4c4f5",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "481:   int reg = 0;",
          "482: #ifndef SQLITE_OMIT_SUBQUERY",
          "483:   if( pExpr->op==TK_SELECT ){",
          "485:   }",
          "486: #endif",
          "487:   return reg;",
          "",
          "[Removed Lines]",
          "484:     reg = sqlite3CodeSubselect(pParse, pExpr, 0, 0);",
          "",
          "[Added Lines]",
          "484:     reg = sqlite3CodeSubselect(pParse, pExpr);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2542:     }else if( prRhsHasNull ){",
          "2544:     }",
          "2546:     pParse->nQueryLoop = savedNQueryLoop;",
          "2547:   }else{",
          "2548:     pX->iTable = iTab;",
          "",
          "[Removed Lines]",
          "2545:     sqlite3CodeSubselect(pParse, pX, rMayHaveNull, eType==IN_INDEX_ROWID);",
          "",
          "[Added Lines]",
          "2545:     assert( pX->op==TK_IN );",
          "2546:     sqlite3CodeRhsOfIN(pParse, pX, eType==IN_INDEX_ROWID);",
          "2547:     if( rMayHaveNull ){",
          "2548:       sqlite3SetHasNullFlag(v, pX->iTable, rMayHaveNull);",
          "2549:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2626:   }",
          "2627: }",
          "2664: ){",
          "",
          "[Removed Lines]",
          "2658: #ifndef SQLITE_OMIT_SUBQUERY",
          "2659: int sqlite3CodeSubselect(",
          "2667:   Vdbe *v = sqlite3GetVdbe(pParse);",
          "2668:   if( NEVER(v==0) ) return 0;",
          "",
          "[Added Lines]",
          "2633: #ifndef SQLITE_OMIT_SUBQUERY",
          "2658: void sqlite3CodeRhsOfIN(",
          "2670:   v = sqlite3GetVdbe(pParse);",
          "2671:   assert( v!=0 );",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2681:     jmpIfDynamic = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);",
          "2682:   }",
          "2810:       }",
          "2813:       }",
          "2815:     }",
          "2859:       }",
          "2864:       }else{",
          "2870:       }",
          "2874:     }",
          "2875:   }",
          "2879:   }",
          "2881:   if( jmpIfDynamic>=0 ){",
          "2882:     sqlite3VdbeJumpHere(v, jmpIfDynamic);",
          "",
          "[Removed Lines]",
          "2684:   switch( pExpr->op ){",
          "2685:     case TK_IN: {",
          "2691:       nVal = sqlite3ExprVectorSize(pLeft);",
          "2692:       assert( !isRowid || nVal==1 );",
          "2707:       pExpr->iTable = pParse->nTab++;",
          "2708:       addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral,",
          "2709:           pExpr->iTable, (isRowid?0:nVal));",
          "2710:       pKeyInfo = isRowid ? 0 : sqlite3KeyInfoAlloc(pParse->db, nVal, 1);",
          "2712:       if( ExprHasProperty(pExpr, EP_xIsSelect) ){",
          "2718:         Select *pSelect = pExpr->x.pSelect;",
          "2719:         ExprList *pEList = pSelect->pEList;",
          "2721:         ExplainQueryPlan((pParse, 1, \"%sLIST SUBQUERY\",",
          "2722:             jmpIfDynamic>=0?\"\":\"CORRELATED \"",
          "2723:         ));",
          "2724:         assert( !isRowid );",
          "2727:         if( ALWAYS(pEList->nExpr==nVal) ){",
          "2728:           SelectDest dest;",
          "2729:           int i;",
          "2730:           sqlite3SelectDestInit(&dest, SRT_Set, pExpr->iTable);",
          "2731:           dest.zAffSdst = exprINAffinity(pParse, pExpr);",
          "2732:           pSelect->iLimit = 0;",
          "2733:           testcase( pSelect->selFlags & SF_Distinct );",
          "2735:           if( sqlite3Select(pParse, pSelect, &dest) ){",
          "2736:             sqlite3DbFree(pParse->db, dest.zAffSdst);",
          "2737:             sqlite3KeyInfoUnref(pKeyInfo);",
          "2738:             return 0;",
          "2739:           }",
          "2740:           sqlite3DbFree(pParse->db, dest.zAffSdst);",
          "2742:           assert( pEList!=0 );",
          "2743:           assert( pEList->nExpr>0 );",
          "2744:           assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );",
          "2745:           for(i=0; i<nVal; i++){",
          "2746:             Expr *p = sqlite3VectorFieldSubexpr(pLeft, i);",
          "2747:             pKeyInfo->aColl[i] = sqlite3BinaryCompareCollSeq(",
          "2748:                 pParse, p, pEList->a[i].pExpr",
          "2749:             );",
          "2750:           }",
          "2751:         }",
          "2752:       }else if( ALWAYS(pExpr->x.pList!=0) ){",
          "2761:         int i;",
          "2762:         ExprList *pList = pExpr->x.pList;",
          "2763:         struct ExprList_item *pItem;",
          "2764:         int r1, r2, r3;",
          "2765:         affinity = sqlite3ExprAffinity(pLeft);",
          "2766:         if( !affinity ){",
          "2767:           affinity = SQLITE_AFF_BLOB;",
          "2768:         }",
          "2769:         if( pKeyInfo ){",
          "2770:           assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );",
          "2771:           pKeyInfo->aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft);",
          "2772:         }",
          "2775:         r1 = sqlite3GetTempReg(pParse);",
          "2776:         r2 = sqlite3GetTempReg(pParse);",
          "2777:         if( isRowid ) sqlite3VdbeAddOp4(v, OP_Blob, 0, r2, 0, \"\", P4_STATIC);",
          "2778:         for(i=pList->nExpr, pItem=pList->a; i>0; i--, pItem++){",
          "2779:           Expr *pE2 = pItem->pExpr;",
          "2780:           int iValToIns;",
          "2787:           if( jmpIfDynamic>=0 && !sqlite3ExprIsConstant(pE2) ){",
          "2788:             sqlite3VdbeChangeToNoop(v, jmpIfDynamic);",
          "2789:             jmpIfDynamic = -1;",
          "2790:           }",
          "2793:           if( isRowid && sqlite3ExprIsInteger(pE2, &iValToIns) ){",
          "2794:             sqlite3VdbeAddOp3(v, OP_InsertInt, pExpr->iTable, r2, iValToIns);",
          "2795:           }else{",
          "2796:             r3 = sqlite3ExprCodeTarget(pParse, pE2, r1);",
          "2797:             if( isRowid ){",
          "2798:               sqlite3VdbeAddOp2(v, OP_MustBeInt, r3,",
          "2799:                                 sqlite3VdbeCurrentAddr(v)+2);",
          "2800:               VdbeCoverage(v);",
          "2801:               sqlite3VdbeAddOp3(v, OP_Insert, pExpr->iTable, r2, r3);",
          "2802:             }else{",
          "2803:               sqlite3VdbeAddOp4(v, OP_MakeRecord, r3, 1, r2, &affinity, 1);",
          "2804:               sqlite3VdbeAddOp4Int(v, OP_IdxInsert, pExpr->iTable, r2, r3, 1);",
          "2805:             }",
          "2806:           }",
          "2807:         }",
          "2808:         sqlite3ReleaseTempReg(pParse, r1);",
          "2809:         sqlite3ReleaseTempReg(pParse, r2);",
          "2811:       if( pKeyInfo ){",
          "2812:         sqlite3VdbeChangeP4(v, addr, (void *)pKeyInfo, P4_KEYINFO);",
          "2814:       break;",
          "2817:     case TK_EXISTS:",
          "2818:     case TK_SELECT:",
          "2819:     default: {",
          "2838:       testcase( pExpr->op==TK_EXISTS );",
          "2839:       testcase( pExpr->op==TK_SELECT );",
          "2840:       assert( pExpr->op==TK_EXISTS || pExpr->op==TK_SELECT );",
          "2841:       assert( ExprHasProperty(pExpr, EP_xIsSelect) );",
          "2843:       pSel = pExpr->x.pSelect;",
          "2844:       ExplainQueryPlan((pParse, 1, \"%sSCALAR SUBQUERY\",",
          "2845:             jmpIfDynamic>=0?\"\":\"CORRELATED \"));",
          "2846:       nReg = pExpr->op==TK_SELECT ? pSel->pEList->nExpr : 1;",
          "2847:       sqlite3SelectDestInit(&dest, 0, pParse->nMem+1);",
          "2848:       pParse->nMem += nReg;",
          "2849:       if( pExpr->op==TK_SELECT ){",
          "2850:         dest.eDest = SRT_Mem;",
          "2851:         dest.iSdst = dest.iSDParm;",
          "2852:         dest.nSdst = nReg;",
          "2853:         sqlite3VdbeAddOp3(v, OP_Null, 0, dest.iSDParm, dest.iSDParm+nReg-1);",
          "2854:         VdbeComment((v, \"Init subquery result\"));",
          "2855:       }else{",
          "2856:         dest.eDest = SRT_Exists;",
          "2857:         sqlite3VdbeAddOp2(v, OP_Integer, 0, dest.iSDParm);",
          "2858:         VdbeComment((v, \"Init EXISTS result\"));",
          "2860:       pLimit = sqlite3ExprAlloc(pParse->db, TK_INTEGER,&sqlite3IntTokens[1], 0);",
          "2861:       if( pSel->pLimit ){",
          "2862:         sqlite3ExprDelete(pParse->db, pSel->pLimit->pLeft);",
          "2863:         pSel->pLimit->pLeft = pLimit;",
          "2865:         pSel->pLimit = sqlite3PExpr(pParse, TK_LIMIT, pLimit, 0);",
          "2866:       }",
          "2867:       pSel->iLimit = 0;",
          "2868:       if( sqlite3Select(pParse, pSel, &dest) ){",
          "2869:         return 0;",
          "2871:       rReg = dest.iSDParm;",
          "2872:       ExprSetVVAProperty(pExpr, EP_NoReduce);",
          "2873:       break;",
          "2877:   if( rHasNullFlag ){",
          "2878:     sqlite3SetHasNullFlag(v, pExpr->iTable, rHasNullFlag);",
          "",
          "[Added Lines]",
          "2688:   pLeft = pExpr->pLeft;",
          "2689:   nVal = sqlite3ExprVectorSize(pLeft);",
          "2690:   assert( !isRowid || nVal==1 );",
          "2695:   pExpr->iTable = pParse->nTab++;",
          "2696:   addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral,",
          "2697:       pExpr->iTable, (isRowid?0:nVal));",
          "2698:   pKeyInfo = isRowid ? 0 : sqlite3KeyInfoAlloc(pParse->db, nVal, 1);",
          "2700:   if( ExprHasProperty(pExpr, EP_xIsSelect) ){",
          "2706:     Select *pSelect = pExpr->x.pSelect;",
          "2707:     ExprList *pEList = pSelect->pEList;",
          "2709:     ExplainQueryPlan((pParse, 1, \"%sLIST SUBQUERY\",",
          "2710:         jmpIfDynamic>=0?\"\":\"CORRELATED \"",
          "2711:     ));",
          "2712:     assert( !isRowid );",
          "2715:     if( ALWAYS(pEList->nExpr==nVal) ){",
          "2716:       SelectDest dest;",
          "2717:       int i;",
          "2718:       sqlite3SelectDestInit(&dest, SRT_Set, pExpr->iTable);",
          "2719:       dest.zAffSdst = exprINAffinity(pParse, pExpr);",
          "2720:       pSelect->iLimit = 0;",
          "2721:       testcase( pSelect->selFlags & SF_Distinct );",
          "2723:       if( sqlite3Select(pParse, pSelect, &dest) ){",
          "2724:         sqlite3DbFree(pParse->db, dest.zAffSdst);",
          "2725:         sqlite3KeyInfoUnref(pKeyInfo);",
          "2726:         return;",
          "2728:       sqlite3DbFree(pParse->db, dest.zAffSdst);",
          "2730:       assert( pEList!=0 );",
          "2731:       assert( pEList->nExpr>0 );",
          "2732:       assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );",
          "2733:       for(i=0; i<nVal; i++){",
          "2734:         Expr *p = sqlite3VectorFieldSubexpr(pLeft, i);",
          "2735:         pKeyInfo->aColl[i] = sqlite3BinaryCompareCollSeq(",
          "2736:             pParse, p, pEList->a[i].pExpr",
          "2737:         );",
          "2740:   }else if( ALWAYS(pExpr->x.pList!=0) ){",
          "2749:     int i;",
          "2750:     ExprList *pList = pExpr->x.pList;",
          "2751:     struct ExprList_item *pItem;",
          "2752:     int r1, r2, r3;",
          "2753:     affinity = sqlite3ExprAffinity(pLeft);",
          "2754:     if( !affinity ){",
          "2755:       affinity = SQLITE_AFF_BLOB;",
          "2756:     }",
          "2757:     if( pKeyInfo ){",
          "2758:       assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );",
          "2759:       pKeyInfo->aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft);",
          "2760:     }",
          "2763:     r1 = sqlite3GetTempReg(pParse);",
          "2764:     r2 = sqlite3GetTempReg(pParse);",
          "2765:     if( isRowid ) sqlite3VdbeAddOp4(v, OP_Blob, 0, r2, 0, \"\", P4_STATIC);",
          "2766:     for(i=pList->nExpr, pItem=pList->a; i>0; i--, pItem++){",
          "2767:       Expr *pE2 = pItem->pExpr;",
          "2768:       int iValToIns;",
          "2775:       if( jmpIfDynamic>=0 && !sqlite3ExprIsConstant(pE2) ){",
          "2776:         sqlite3VdbeChangeToNoop(v, jmpIfDynamic);",
          "2777:         jmpIfDynamic = -1;",
          "2781:       if( isRowid && sqlite3ExprIsInteger(pE2, &iValToIns) ){",
          "2782:         sqlite3VdbeAddOp3(v, OP_InsertInt, pExpr->iTable, r2, iValToIns);",
          "2784:         r3 = sqlite3ExprCodeTarget(pParse, pE2, r1);",
          "2785:         if( isRowid ){",
          "2786:           sqlite3VdbeAddOp2(v, OP_MustBeInt, r3,",
          "2787:                             sqlite3VdbeCurrentAddr(v)+2);",
          "2788:           VdbeCoverage(v);",
          "2789:           sqlite3VdbeAddOp3(v, OP_Insert, pExpr->iTable, r2, r3);",
          "2790:         }else{",
          "2791:           sqlite3VdbeAddOp4(v, OP_MakeRecord, r3, 1, r2, &affinity, 1);",
          "2792:           sqlite3VdbeAddOp4Int(v, OP_IdxInsert, pExpr->iTable, r2, r3, 1);",
          "2793:         }",
          "2796:     sqlite3ReleaseTempReg(pParse, r1);",
          "2797:     sqlite3ReleaseTempReg(pParse, r2);",
          "2799:   if( pKeyInfo ){",
          "2800:     sqlite3VdbeChangeP4(v, addr, (void *)pKeyInfo, P4_KEYINFO);",
          "2801:   }",
          "2802:   if( jmpIfDynamic>=0 ){",
          "2803:     sqlite3VdbeJumpHere(v, jmpIfDynamic);",
          "2804:   }",
          "2805: }",
          "2822: #ifndef SQLITE_OMIT_SUBQUERY",
          "2823: int sqlite3CodeSubselect(Parse *pParse, Expr *pExpr){",
          "2830:   Vdbe *v = sqlite3GetVdbe(pParse);",
          "2831:   assert( v!=0 );",
          "2843:   if( !ExprHasProperty(pExpr, EP_VarSelect) ){",
          "2844:     jmpIfDynamic = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);",
          "2845:   }",
          "2857:   testcase( pExpr->op==TK_EXISTS );",
          "2858:   testcase( pExpr->op==TK_SELECT );",
          "2859:   assert( pExpr->op==TK_EXISTS || pExpr->op==TK_SELECT );",
          "2860:   assert( ExprHasProperty(pExpr, EP_xIsSelect) );",
          "2862:   pSel = pExpr->x.pSelect;",
          "2863:   ExplainQueryPlan((pParse, 1, \"%sSCALAR SUBQUERY\",",
          "2864:         jmpIfDynamic>=0?\"\":\"CORRELATED \"));",
          "2865:   nReg = pExpr->op==TK_SELECT ? pSel->pEList->nExpr : 1;",
          "2866:   sqlite3SelectDestInit(&dest, 0, pParse->nMem+1);",
          "2867:   pParse->nMem += nReg;",
          "2868:   if( pExpr->op==TK_SELECT ){",
          "2869:     dest.eDest = SRT_Mem;",
          "2870:     dest.iSdst = dest.iSDParm;",
          "2871:     dest.nSdst = nReg;",
          "2872:     sqlite3VdbeAddOp3(v, OP_Null, 0, dest.iSDParm, dest.iSDParm+nReg-1);",
          "2873:     VdbeComment((v, \"Init subquery result\"));",
          "2874:   }else{",
          "2875:     dest.eDest = SRT_Exists;",
          "2876:     sqlite3VdbeAddOp2(v, OP_Integer, 0, dest.iSDParm);",
          "2877:     VdbeComment((v, \"Init EXISTS result\"));",
          "2878:   }",
          "2879:   pLimit = sqlite3ExprAlloc(pParse->db, TK_INTEGER,&sqlite3IntTokens[1], 0);",
          "2880:   if( pSel->pLimit ){",
          "2881:     sqlite3ExprDelete(pParse->db, pSel->pLimit->pLeft);",
          "2882:     pSel->pLimit->pLeft = pLimit;",
          "2883:   }else{",
          "2884:     pSel->pLimit = sqlite3PExpr(pParse, TK_LIMIT, pLimit, 0);",
          "2885:   }",
          "2886:   pSel->iLimit = 0;",
          "2887:   if( sqlite3Select(pParse, pSel, &dest) ){",
          "2888:     return 0;",
          "2890:   rReg = dest.iSDParm;",
          "2891:   ExprSetVVAProperty(pExpr, EP_NoReduce);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3343: #if SQLITE_OMIT_SUBQUERY",
          "3344:       iResult = 0;",
          "3345: #else",
          "3347: #endif",
          "3348:     }else{",
          "3349:       int i;",
          "",
          "[Removed Lines]",
          "3346:       iResult = sqlite3CodeSubselect(pParse, p, 0, 0);",
          "",
          "[Added Lines]",
          "3358:       iResult = sqlite3CodeSubselect(pParse, p);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3817:       if( op==TK_SELECT && (nCol = pExpr->x.pSelect->pEList->nExpr)!=1 ){",
          "3818:         sqlite3SubselectError(pParse, nCol, 1);",
          "3819:       }else{",
          "3821:       }",
          "3822:       break;",
          "3823:     }",
          "3824:     case TK_SELECT_COLUMN: {",
          "3825:       int n;",
          "3826:       if( pExpr->pLeft->iTable==0 ){",
          "3828:       }",
          "3829:       assert( pExpr->iTable==0 || pExpr->pLeft->op==TK_SELECT );",
          "3830:       if( pExpr->iTable",
          "",
          "[Removed Lines]",
          "3820:         return sqlite3CodeSubselect(pParse, pExpr, 0, 0);",
          "3827:         pExpr->pLeft->iTable = sqlite3CodeSubselect(pParse, pExpr->pLeft, 0, 0);",
          "",
          "[Added Lines]",
          "3832:         return sqlite3CodeSubselect(pParse, pExpr);",
          "3839:         pExpr->pLeft->iTable = sqlite3CodeSubselect(pParse, pExpr->pLeft);",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "4258: int sqlite3GetToken(const unsigned char *, int *);",
          "4259: void sqlite3NestedParse(Parse*, const char*, ...);",
          "4260: void sqlite3ExpirePreparedStatements(sqlite3*, int);",
          "4262: void sqlite3SelectPrep(Parse*, Select*, NameContext*);",
          "4263: void sqlite3SelectWrongNumTermsError(Parse *pParse, Select *p);",
          "4264: int sqlite3MatchSpanName(const char*, const char*, const char*, const char*);",
          "",
          "[Removed Lines]",
          "4261: int sqlite3CodeSubselect(Parse*, Expr *, int, int);",
          "",
          "[Added Lines]",
          "4261: void sqlite3CodeRhsOfIN(Parse*, Expr*, int);",
          "4262: int sqlite3CodeSubselect(Parse*, Expr*);",
          "",
          "---------------"
        ],
        "src/wherecode.c||src/wherecode.c": [
          "File: src/wherecode.c -> src/wherecode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1076: #ifndef SQLITE_OMIT_SUBQUERY",
          "1077:     if( (p->flags & EP_xIsSelect) ){",
          "1078:       Vdbe *v = pParse->pVdbe;",
          "1080:       sqlite3VdbeAddOp3(v, OP_Copy, iSelect, iReg, nReg-1);",
          "1081:     }else",
          "1082: #endif",
          "",
          "[Removed Lines]",
          "1079:       int iSelect = sqlite3CodeSubselect(pParse, p, 0, 0);",
          "",
          "[Added Lines]",
          "1079:       int iSelect;",
          "1080:       assert( p->op==TK_SELECT );",
          "1081:       iSelect = sqlite3CodeSubselect(pParse, p);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
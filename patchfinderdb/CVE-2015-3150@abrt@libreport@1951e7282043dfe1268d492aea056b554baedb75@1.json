{
  "cve_id": "CVE-2015-3150",
  "cve_desc": "abrt-dbus in Automatic Bug Reporting Tool (ABRT) allows local users to delete or change the ownership of arbitrary files via the problem directory argument to the (1) ChownProblemDir, (2) DeleteElement, or (3) DeleteProblem method.",
  "repo": "abrt/libreport",
  "patch_hash": "1951e7282043dfe1268d492aea056b554baedb75",
  "patch_info": {
    "commit_hash": "1951e7282043dfe1268d492aea056b554baedb75",
    "repo": "abrt/libreport",
    "commit_url": "https://github.com/abrt/libreport/commit/1951e7282043dfe1268d492aea056b554baedb75",
    "files": [
      "src/include/dump_dir.h",
      "src/include/internal_libreport.h",
      "src/lib/dump_dir.c",
      "src/lib/problem_data.c",
      "src/lib/xfuncs.c"
    ],
    "message": "lib: fix races in dump directory handling code\n\nFlorian Weimer <fweimer@redhat.com>:\n\n    dd_opendir() should keep a file handle (opened with O_DIRECTORY) and\n    use openat() and similar functions to access files in it.\n\n    ...\n\n    The file system manipulation functions should guard against hard\n    links (check that link count is <= 1, just as in the user coredump\n    code in abrt-hook-ccpp), possibly after opening the file\n    with O_PATH first to avoid side effects on open/close.\n\nRelated: #1214745\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
    "before_after_code_files": [
      "src/include/dump_dir.h||src/include/dump_dir.h",
      "src/include/internal_libreport.h||src/include/internal_libreport.h",
      "src/lib/dump_dir.c||src/lib/dump_dir.c",
      "src/lib/problem_data.c||src/lib/problem_data.c",
      "src/lib/xfuncs.c||src/lib/xfuncs.c"
    ]
  },
  "patch_diff": {
    "src/include/dump_dir.h||src/include/dump_dir.h": [
      "File: src/include/dump_dir.h -> src/include/dump_dir.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "36: int create_symlink_lockfile(const char *filename, const char *pid_str);",
      "38: enum {",
      "39:     DD_FAIL_QUIETLY_ENOENT = (1 << 0),",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "37: int create_symlink_lockfile_at(int dir_fd, const char *filename, const char *pid_str);",
      "42: int secure_openat_read(int dir_fd, const char *filename);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "57:     mode_t mode;",
      "58:     time_t dd_time;",
      "59:     char *dd_type;",
      "60: };",
      "62: void dd_close(struct dump_dir *dd);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "66:     int dd_fd;",
      "",
      "---------------"
    ],
    "src/include/internal_libreport.h||src/include/internal_libreport.h": [
      "File: src/include/internal_libreport.h -> src/include/internal_libreport.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "406: int xopen(const char *pathname, int flags);",
      "407: #define xunlink libreport_xunlink",
      "408: void xunlink(const char *pathname);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "409: #define xunlinkat libreport_xunlinkat",
      "410: void xunlinkat(int dir_fd, const char *pathname, int flags);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "416: #define is_regular_file libreport_is_regular_file",
      "417: int is_regular_file(struct dirent *dent, const char *dirname);",
      "419: #define dot_or_dotdot libreport_dot_or_dotdot",
      "420: bool dot_or_dotdot(const char *filename);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "420: #define is_regular_file_at libreport_is_regular_file_at",
      "421: int is_regular_file_at(struct dirent *dent, int dir_fd);",
      "",
      "---------------"
    ],
    "src/lib/dump_dir.c||src/lib/dump_dir.c": [
      "File: src/lib/dump_dir.c -> src/lib/dump_dir.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "87: static char *load_text_file(const char *path, unsigned flags);",
      "88: static void copy_file_from_chroot(struct dump_dir* dd, const char *name,",
      "89:         const char *chroot_dir, const char *file_path);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "88: static char *load_text_file_at(int dir_fd, const char *name, unsigned flags);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "98:     return true;",
      "99: }",
      "102: {",
      "103:     struct stat buf;",
      "105:     {",
      "106:         if (S_ISDIR(buf.st_mode) || S_ISREG(buf.st_mode))",
      "107:         {",
      "",
      "[Removed Lines]",
      "101: static bool exist_file_dir(const char *path)",
      "104:     if (stat(path, &buf) == 0)",
      "",
      "[Added Lines]",
      "102: static bool exist_file_dir_at(int dir_fd, const char *name)",
      "105:     if (fstatat(dir_fd, name, &buf, AT_SYMLINK_NOFOLLOW) == 0)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "111:     return false;",
      "112: }",
      "120: {",
      "123:     if (fd < 0)",
      "124:     {",
      "125:         VERB2 pwarn_msg(\"Can't open '%s'\", filename);",
      "",
      "[Removed Lines]",
      "119: static time_t parse_time_file(const char *filename)",
      "122:     int fd = open(filename, O_RDONLY | O_NOFOLLOW);",
      "",
      "[Added Lines]",
      "125: int secure_openat_read(int dir_fd, const char *pathname)",
      "126: {",
      "127:     static char reopen_buf[sizeof(\"/proc/self/fd/\") + 3*sizeof(int) + 1];",
      "129:     int path_fd = openat(dir_fd, pathname, O_PATH | O_NOFOLLOW);",
      "130:     if (path_fd < 0)",
      "131:         return -1;",
      "133:     struct stat path_sb;",
      "134:     int r = fstat(path_fd, &path_sb);",
      "135:     if (r < 0)",
      "136:     {",
      "137:         perror_msg(\"stat\");",
      "138:         close(path_fd);",
      "139:         return -1;",
      "140:     }",
      "142:     if (!S_ISREG(path_sb.st_mode) || path_sb.st_nlink > 1)",
      "143:     {",
      "144:         log_notice(\"Path isn't a regular file or has more links (%lu)\", path_sb.st_nlink);",
      "145:         errno = EINVAL;",
      "146:         close(path_fd);",
      "147:         return -1;",
      "148:     }",
      "150:     if (snprintf(reopen_buf, sizeof(reopen_buf), \"/proc/self/fd/%d\", path_fd) >= sizeof(reopen_buf)) {",
      "151:         error_msg(\"BUG: too long path to a file descriptor\");",
      "152:         abort();",
      "153:     }",
      "155:     const int fd = open(reopen_buf, O_RDONLY);",
      "156:     close(path_fd);",
      "158:     return fd;",
      "159: }",
      "166: static time_t parse_time_file_at(int dir_fd, const char *filename)",
      "169:     int fd = secure_openat_read(dir_fd, filename);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "187: {",
      "189:     {",
      "190:         if (errno != EEXIST)",
      "191:         {",
      "",
      "[Removed Lines]",
      "186: int create_symlink_lockfile(const char* lock_file, const char* pid)",
      "188:     while (symlink(pid, lock_file) != 0)",
      "",
      "[Added Lines]",
      "233: int create_symlink_lockfile_at(int dir_fd, const char* lock_file, const char* pid)",
      "235:     while (symlinkat(pid, dir_fd, lock_file) != 0)",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "198:         }",
      "200:         char pid_buf[sizeof(pid_t)*3 + 4];",
      "202:         if (r < 0)",
      "203:         {",
      "204:             if (errno == ENOENT)",
      "",
      "[Removed Lines]",
      "201:         ssize_t r = readlink(lock_file, pid_buf, sizeof(pid_buf) - 1);",
      "",
      "[Added Lines]",
      "248:         ssize_t r = readlinkat(dir_fd, lock_file, pid_buf, sizeof(pid_buf) - 1);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "230:             log(\"Lock file '%s' was locked by process %s, but it crashed?\", lock_file, pid_buf);",
      "231:         }",
      "234:         {",
      "235:             perror_msg(\"Can't remove stale lock file '%s'\", lock_file);",
      "236:             errno = 0;",
      "",
      "[Removed Lines]",
      "233:         if (unlink(lock_file) != 0 && errno != ENOENT)",
      "",
      "[Added Lines]",
      "280:         if (unlinkat(dir_fd, lock_file, /*only files*/0) != 0 && errno != ENOENT)",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "242:     return 1;",
      "243: }",
      "245: static const char *dd_check(struct dump_dir *dd)",
      "246: {",
      "252:     if (dd->dd_time < 0)",
      "253:     {",
      "254:         log_warning(\"Missing file: \"FILENAME_TIME);",
      "255:         return FILENAME_TIME;",
      "256:     }",
      "260:     if (!dd->dd_type || (strlen(dd->dd_type) == 0))",
      "261:     {",
      "262:         log_warning(\"Missing or empty file: \"FILENAME_TYPE);",
      "",
      "[Removed Lines]",
      "247:     unsigned dirname_len = strlen(dd->dd_dirname);",
      "248:     char filename_buf[FILENAME_MAX+1];",
      "249:     strcpy(filename_buf, dd->dd_dirname);",
      "250:     strcpy(filename_buf + dirname_len, \"/\"FILENAME_TIME);",
      "251:     dd->dd_time = parse_time_file(filename_buf);",
      "258:     strcpy(filename_buf + dirname_len, \"/\"FILENAME_TYPE);",
      "259:     dd->dd_type = load_text_file(filename_buf, DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE);",
      "",
      "[Added Lines]",
      "292: int create_symlink_lockfile(const char *filename, const char *pid_str)",
      "293: {",
      "294:     return create_symlink_lockfile_at(AT_FDCWD, filename, pid_str);",
      "295: }",
      "299:     dd->dd_time = parse_time_file_at(dd->dd_fd, FILENAME_TIME);",
      "306:     dd->dd_type = load_text_file_at(dd->dd_fd, FILENAME_TYPE, DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "274:     char pid_buf[sizeof(long)*3 + 2];",
      "275:     snprintf(pid_buf, sizeof(pid_buf), \"%lu\", (long)getpid());",
      "282:     unsigned count = NO_TIME_FILE_COUNT;",
      "284:  retry:",
      "285:     while (1)",
      "286:     {",
      "288:         if (r < 0)",
      "290:         if (r > 0)",
      "",
      "[Removed Lines]",
      "277:     unsigned dirname_len = strlen(dd->dd_dirname);",
      "278:     char lock_buf[dirname_len + sizeof(\"/.lock\")];",
      "279:     strcpy(lock_buf, dd->dd_dirname);",
      "280:     strcpy(lock_buf + dirname_len, \"/.lock\");",
      "287:         int r = create_symlink_lockfile(lock_buf, pid_buf);",
      "",
      "[Added Lines]",
      "329:         int r = create_symlink_lockfile_at(dd->dd_fd, \".lock\", pid_buf);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "305:         if (missing_file)",
      "306:         {",
      "309:             if (--count == 0 || flags & DD_DONT_WAIT_FOR_LOCK)",
      "310:             {",
      "",
      "[Removed Lines]",
      "307:             xunlink(lock_buf);",
      "308:             log_warning(\"Unlocked '%s' (no or corrupted '%s' file)\", lock_buf, missing_file);",
      "",
      "[Added Lines]",
      "349:             xunlinkat(dd->dd_fd, \".lock\", /*only files*/0);",
      "350:             log_warning(\"Unlocked '%s' (no or corrupted '%s' file)\", dd->dd_dirname, missing_file);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "326:     {",
      "327:         dd->locked = 0;",
      "336:     }",
      "337: }",
      "",
      "[Removed Lines]",
      "329:         unsigned dirname_len = strlen(dd->dd_dirname);",
      "330:         char lock_buf[dirname_len + sizeof(\"/.lock\")];",
      "331:         strcpy(lock_buf, dd->dd_dirname);",
      "332:         strcpy(lock_buf + dirname_len, \"/.lock\");",
      "333:         xunlink(lock_buf);",
      "335:         log_info(\"Unlocked '%s'\", lock_buf);",
      "",
      "[Added Lines]",
      "371:         xunlinkat(dd->dd_fd, \".lock\", /*only files*/0);",
      "373:         log_info(\"Unlocked '%s/.lock'\", dd->dd_dirname);",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "340: {",
      "341:     struct dump_dir* dd = (struct dump_dir*)xzalloc(sizeof(struct dump_dir));",
      "342:     dd->dd_time = -1;",
      "343:     return dd;",
      "344: }",
      "347: {",
      "354:     return ret;",
      "355: }",
      "",
      "[Removed Lines]",
      "346: int dd_exist(const struct dump_dir *dd, const char *path)",
      "348:     if (!str_is_correct_filename(path))",
      "349:         error_msg_and_die(\"Cannot test existence. '%s' is not a valid file name\", path);",
      "351:     char *full_path = concat_path_file(dd->dd_dirname, path);",
      "352:     int ret = exist_file_dir(full_path);",
      "353:     free(full_path);",
      "",
      "[Added Lines]",
      "381:     dd->dd_fd = -1;",
      "385: int dd_exist(const struct dump_dir *dd, const char *name)",
      "387:     if (!str_is_correct_filename(name))",
      "388:         error_msg_and_die(\"Cannot test existence. '%s' is not a valid file name\", name);",
      "390:     const int ret = exist_file_dir_at(dd->dd_fd, name);",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "360:         return;",
      "362:     dd_unlock(dd);",
      "363:     if (dd->next_dir)",
      "364:     {",
      "365:         closedir(dd->next_dir);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "400:     close(dd->dd_fd);",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "384:     struct dump_dir *dd = dd_init();",
      "386:     dir = dd->dd_dirname = rm_trailing_slashes(dir);",
      "388:     struct stat stat_buf;",
      "390:         goto cant_access;",
      "392:     dd->mode = (stat_buf.st_mode & 0666);",
      "",
      "[Removed Lines]",
      "389:     if (stat(dir, &stat_buf) != 0)",
      "",
      "[Added Lines]",
      "425:     dd->dd_fd = open(dir, O_DIRECTORY | O_NOFOLLOW);",
      "427:     if (dd->dd_fd < 0)",
      "429:     if (fstat(dd->dd_fd, &stat_buf) != 0)",
      "430:         goto cant_access;",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "397:         if ((flags & DD_OPEN_READONLY) && errno == EACCES)",
      "398:         {",
      "405:                 if(dd_check(dd) != NULL)",
      "406:                 {",
      "407:                     dd_close(dd);",
      "",
      "[Removed Lines]",
      "401:             if (stat(dir, &stat_buf) == 0",
      "402:              && S_ISDIR(stat_buf.st_mode)",
      "403:              && access(dir, R_OK) == 0",
      "404:             ) {",
      "",
      "[Added Lines]",
      "445:             if (faccessat(dd->dd_fd, \".\", R_OK, AT_SYMLINK_NOFOLLOW) == 0)",
      "446:             {",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "444:     if (geteuid() == 0)",
      "445:     {",
      "449:         {",
      "451:             dd_close(dd);",
      "452:             return NULL;",
      "453:         }",
      "",
      "[Removed Lines]",
      "447:         struct stat stat_buf;",
      "448:         if (stat(dir, &stat_buf) != 0 || !S_ISDIR(stat_buf.st_mode))",
      "450:             error_msg(\"Can't stat '%s', or it is not a directory\", dir);",
      "",
      "[Added Lines]",
      "489:         if (fstat(dd->dd_fd, &stat_buf) != 0)",
      "491:             error_msg(\"Can't stat '%s'\", dir);",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "544:         error_msg(\"Bad dir name '%s'\", dir);",
      "547:     }",
      "",
      "[Removed Lines]",
      "545:         dd_close(dd);",
      "546:         return NULL;",
      "",
      "[Added Lines]",
      "586:         goto fail;",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "559:     if (r != 0)",
      "560:     {",
      "561:         perror_msg(\"Can't create directory '%s'\", dir);",
      "564:     }",
      "567:     {",
      "570:     }",
      "574:     {",
      "575:         perror_msg(\"Can't change mode of '%s'\", dir);",
      "578:     }",
      "580:     dd->dd_uid = (uid_t)-1L;",
      "",
      "[Removed Lines]",
      "562:         dd_close(dd);",
      "563:         return NULL;",
      "566:     if (dd_lock(dd, CREATE_LOCK_USLEEP, /*flags:*/ 0) < 0)",
      "568:         dd_close(dd);",
      "569:         return NULL;",
      "573:     if (chmod(dir, dir_mode) == -1)",
      "576:         dd_close(dd);",
      "577:         return NULL;",
      "",
      "[Added Lines]",
      "602:         goto fail;",
      "605:     dd->dd_fd = open(dd->dd_dirname, O_DIRECTORY | O_NOFOLLOW);",
      "606:     if (dd->dd_fd < 0)",
      "608:         perror_msg(\"Can't open newly created directory '%s'\", dir);",
      "609:         goto fail;",
      "612:     struct stat stat_sb;",
      "613:     if (fstat(dd->dd_fd, &stat_sb) < 0)",
      "614:     {",
      "615:         perror_msg(\"stat(%s)\", dd->dd_dirname);",
      "616:         goto fail;",
      "617:     }",
      "619:     if (dd_lock(dd, CREATE_LOCK_USLEEP, /*flags:*/ 0) < 0)",
      "620:         goto fail;",
      "623:     if (fchmod(dd->dd_fd, dir_mode) == -1)",
      "626:         goto fail;",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "616:     }",
      "618:     return dd;",
      "619: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "669: fail:",
      "670:     dd_close(dd);",
      "671:     return NULL;",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "624: int dd_reset_ownership(struct dump_dir *dd)",
      "625: {",
      "627:     if (r < 0)",
      "628:     {",
      "629:         perror_msg(\"Can't change '%s' ownership to %lu:%lu\", dd->dd_dirname,",
      "",
      "[Removed Lines]",
      "626:     const int r =lchown(dd->dd_dirname, dd->dd_uid, dd->dd_gid);",
      "",
      "[Added Lines]",
      "679:     const int r = fchown(dd->dd_fd, dd->dd_uid, dd->dd_gid);",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "740:     if (!dd->locked)",
      "749:     {",
      "789:     }",
      "791: }",
      "794: {",
      "796:     if (!d)",
      "797:     {",
      "",
      "[Removed Lines]",
      "743:     DIR *d = opendir(dd->dd_dirname);",
      "744:     if (!d)",
      "745:         return;",
      "747:     struct dirent *dent;",
      "748:     while ((dent = readdir(d)) != NULL)",
      "751:             continue;",
      "752:         char *full_path = concat_path_file(dd->dd_dirname, dent->d_name);",
      "753:         struct stat statbuf;",
      "754:         if (lstat(full_path, &statbuf) == 0 && S_ISREG(statbuf.st_mode))",
      "755:         {",
      "756:             if ((statbuf.st_mode & 0777) != dd->mode)",
      "757:             {",
      "764:                 int fd = open(full_path, O_RDONLY | O_NOFOLLOW, dd->mode);",
      "765:                 if (fd >= 0)",
      "766:                 {",
      "767:                     if (fchmod(fd, dd->mode) != 0)",
      "768:                     {",
      "769:                         perror_msg(\"Can't change '%s' mode to 0%o\", full_path,",
      "770:                                    (unsigned)dd->mode);",
      "771:                     }",
      "772:                     close(fd);",
      "773:                 }",
      "774:                 else",
      "775:                 {",
      "776:                     perror_msg(\"Can't open regular file '%s'\", full_path);",
      "777:                 }",
      "778:             }",
      "779:             if (statbuf.st_uid != dd->dd_uid || statbuf.st_gid != dd->dd_gid)",
      "780:             {",
      "781:                 if (lchown(full_path, dd->dd_uid, dd->dd_gid) != 0)",
      "782:                 {",
      "783:                     perror_msg(\"Can't change '%s' ownership to %lu:%lu\", full_path,",
      "784:                                (long)dd->dd_uid, (long)dd->dd_gid);",
      "785:                 }",
      "786:             }",
      "787:         }",
      "788:         free(full_path);",
      "790:     closedir(d);",
      "793: static int delete_file_dir(const char *dir, bool skip_lock_file)",
      "795:     DIR *d = opendir(dir);",
      "",
      "[Added Lines]",
      "796:     dd_init_next_file(dd);",
      "797:     char *short_name;",
      "798:     while (dd_get_next_file(dd, &short_name, /*full_name*/ NULL))",
      "801:         int fd = secure_openat_read(dd->dd_fd, short_name);",
      "802:         if (fd < 0)",
      "803:             goto next;",
      "805:         if (fchmod(fd, dd->mode) != 0)",
      "806:             perror_msg(\"Can't change '%s/%s' mode to 0%o\", dd->dd_dirname, short_name,",
      "807:                        (unsigned)dd->mode);",
      "809:         if (fchown(fd, dd->dd_uid, dd->dd_gid) != 0)",
      "810:             perror_msg(\"Can't change '%s/%s' ownership to %lu:%lu\", dd->dd_dirname, short_name,",
      "811:                        (long)dd->dd_uid, (long)dd->dd_gid);",
      "813:         close(fd);",
      "814: next:",
      "815:         free(short_name);",
      "819: static int delete_file_dir(int dir_fd, bool skip_lock_file)",
      "821:     int opendir_fd = dup(dir_fd);",
      "822:     if (opendir_fd < 0)",
      "823:     {",
      "824:         perror_msg(\"delete_file_dir: dup(dir_fd)\");",
      "825:         return -1;",
      "826:     }",
      "828:     DIR *d = fdopendir(opendir_fd);",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "818:             unlink_lock_file = true;",
      "819:             continue;",
      "820:         }",
      "823:         {",
      "824:             int err = 0;",
      "825:             if (errno == EISDIR)",
      "826:             {",
      "827:                 errno = 0;",
      "829:             }",
      "830:             if (errno || err)",
      "831:             {",
      "834:                 closedir(d);",
      "835:                 return -1;",
      "836:             }",
      "837:         }",
      "839:     }",
      "",
      "[Removed Lines]",
      "821:         char *full_path = concat_path_file(dir, dent->d_name);",
      "822:         if (unlink(full_path) == -1 && errno != ENOENT)",
      "828:                 err = delete_file_dir(full_path, /*skip_lock_file:*/ false);",
      "832:                 perror_msg(\"Can't remove '%s'\", full_path);",
      "833:                 free(full_path);",
      "838:         free(full_path);",
      "840:     closedir(d);",
      "",
      "[Added Lines]",
      "854:         if (unlinkat(dir_fd, dent->d_name, /*only files*/0) == -1 && errno != ENOENT)",
      "860:                 int subdir_fd = openat(dir_fd, dent->d_name, O_DIRECTORY);",
      "861:                 if (subdir_fd < 0)",
      "862:                 {",
      "863:                     perror_msg(\"Can't open sub-dir'%s'\", dent->d_name);",
      "864:                     closedir(d);",
      "865:                     return -1;",
      "866:                 }",
      "867:                 else",
      "868:                 {",
      "869:                     err = delete_file_dir(subdir_fd, /*skip_lock_file:*/ false);",
      "870:                     close(subdir_fd);",
      "871:                     if (err == 0)",
      "872:                         unlinkat(dir_fd, dent->d_name, AT_REMOVEDIR);",
      "873:                 }",
      "877:                 perror_msg(\"Can't remove '%s'\", dent->d_name);",
      "",
      "---------------",
      "--- Hunk 22 ---",
      "[Context before]",
      "847:     if (unlink_lock_file)",
      "871: }",
      "873: int dd_delete(struct dump_dir *dd)",
      "",
      "[Removed Lines]",
      "848:     {",
      "849:         char *full_path = concat_path_file(dir, \".lock\");",
      "850:         xunlink(full_path);",
      "851:         free(full_path);",
      "853:         unsigned cnt = RMDIR_FAIL_COUNT;",
      "854:         do {",
      "855:             if (rmdir(dir) == 0)",
      "856:                 return 0;",
      "863:             usleep(RMDIR_FAIL_USLEEP);",
      "864:         } while (--cnt != 0);",
      "865:     }",
      "867:     int r = rmdir(dir);",
      "868:     if (r)",
      "869:         perror_msg(\"Can't remove directory '%s'\", dir);",
      "870:     return r;",
      "",
      "[Added Lines]",
      "890:         xunlinkat(dir_fd, \".lock\", /*only files*/0);",
      "892:     return 0;",
      "",
      "---------------",
      "--- Hunk 23 ---",
      "[Context before]",
      "878:         return -1;",
      "879:     }",
      "883:     dd_close(dd);",
      "885: }",
      "887: int dd_chown(struct dump_dir *dd, uid_t new_uid)",
      "",
      "[Removed Lines]",
      "881:     int r = delete_file_dir(dd->dd_dirname, /*skip_lock_file:*/ true);",
      "884:     return r;",
      "",
      "[Added Lines]",
      "903:     if (delete_file_dir(dd->dd_fd, /*skip_lock_file:*/ true) != 0)",
      "904:     {",
      "905:         perror_msg(\"Can't remove contents of directory '%s'\", dd->dd_dirname);",
      "906:         return -2;",
      "907:     }",
      "909:     unsigned cnt = RMDIR_FAIL_COUNT;",
      "910:     do {",
      "911:         if (rmdir(dd->dd_dirname) == 0)",
      "912:             break;",
      "919:         usleep(RMDIR_FAIL_USLEEP);",
      "920:     } while (--cnt != 0);",
      "922:     if (cnt == 0)",
      "923:     {",
      "924:         perror_msg(\"Can't remove directory '%s'\", dd->dd_dirname);",
      "925:         return -3;",
      "926:     }",
      "930:     return 0;",
      "",
      "---------------",
      "--- Hunk 24 ---",
      "[Context before]",
      "911:     gid_t groups_gid = pw->pw_gid;",
      "912: #endif",
      "915:     if (chown_res)",
      "917:     else",
      "918:     {",
      "919:         dd_init_next_file(dd);",
      "922:         {",
      "925:             if (chown_res)",
      "928:         }",
      "929:     }",
      "931:     return chown_res;",
      "932: }",
      "935: {",
      "937:     if (fd == -1)",
      "938:     {",
      "939:         if (!(flags & DD_FAIL_QUIETLY_ENOENT))",
      "",
      "[Removed Lines]",
      "914:     int chown_res = lchown(dd->dd_dirname, owners_uid, groups_gid);",
      "916:         perror_msg(\"lchown('%s')\", dd->dd_dirname);",
      "920:         char *full_name;",
      "921:         while (chown_res == 0 && dd_get_next_file(dd, /*short_name*/ NULL, &full_name))",
      "923:             log_debug(\"chowning %s\", full_name);",
      "924:             chown_res = lchown(full_name, owners_uid, groups_gid);",
      "926:                 perror_msg(\"lchown('%s')\", full_name);",
      "927:             free(full_name);",
      "934: static char *load_text_file(const char *path, unsigned flags)",
      "936:     int fd = open(path, O_RDONLY | ((flags & DD_OPEN_FOLLOW) ? 0 : O_NOFOLLOW));",
      "",
      "[Added Lines]",
      "960:     int chown_res = fchown(dd->dd_fd, owners_uid, groups_gid);",
      "962:         perror_msg(\"fchown('%s')\", dd->dd_dirname);",
      "966:         char *short_name;",
      "967:         while (chown_res == 0 && dd_get_next_file(dd, &short_name, /*full_name*/ NULL))",
      "970:             int fd = secure_openat_read(dd->dd_fd, short_name);",
      "971:             if (fd < 0)",
      "972:                 goto next;",
      "974:             log_debug(\"chowning %s\", short_name);",
      "976:             chown_res = fchown(fd, owners_uid, groups_gid);",
      "978:                 perror_msg(\"fchownat('%s')\", short_name);",
      "980:             close(fd);",
      "981: next:",
      "982:             free(short_name);",
      "989: static char *load_text_from_file_descriptor(int fd, const char *path, int flags)",
      "",
      "---------------",
      "--- Hunk 25 ---",
      "[Context before]",
      "988:     return strbuf_free_nobuf(buf_content);",
      "989: }",
      "991: static void copy_file_from_chroot(struct dump_dir* dd, const char *name, const char *chroot_dir, const char *file_path)",
      "992: {",
      "993:     char *chrooted_name = concat_path_file(chroot_dir, file_path);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1045: static char *load_text_file_at(int dir_fd, const char *name, unsigned flags)",
      "1046: {",
      "1047:     assert(name[0] != '/');",
      "1049:     const int fd = openat(dir_fd, name, O_RDONLY | ((flags & DD_OPEN_FOLLOW) ? 0 : O_NOFOLLOW));",
      "1050:     return load_text_from_file_descriptor(fd, name, flags);",
      "1051: }",
      "1053: static char *load_text_file(const char *path, unsigned flags)",
      "1054: {",
      "1055:     const int fd = open(path, O_RDONLY | ((flags & DD_OPEN_FOLLOW) ? 0 : O_NOFOLLOW));",
      "1056:     return load_text_from_file_descriptor(fd, path, flags);",
      "1057: }",
      "",
      "---------------",
      "--- Hunk 26 ---",
      "[Context before]",
      "1001:     }",
      "1002: }",
      "1005: {",
      "1009:     if (fd < 0)",
      "1010:     {",
      "1012:         return false;",
      "1013:     }",
      "",
      "[Removed Lines]",
      "1004: static bool save_binary_file(const char *path, const char* data, unsigned size, uid_t uid, gid_t gid, mode_t mode)",
      "1007:     unlink(path);",
      "1008:     int fd = open(path, O_WRONLY | O_TRUNC | O_CREAT | O_NOFOLLOW, mode);",
      "1011:         perror_msg(\"Can't open file '%s'\", path);",
      "",
      "[Added Lines]",
      "1072: static bool save_binary_file_at(int dir_fd, const char *name, const char* data, unsigned size, uid_t uid, gid_t gid, mode_t mode)",
      "1074:     assert(name[0] != '/');",
      "1077:     unlinkat(dir_fd, name, /*remove only files*/0);",
      "1078:     int fd = openat(dir_fd, name, O_WRONLY | O_EXCL | O_CREAT | O_NOFOLLOW, mode);",
      "1081:         perror_msg(\"Can't open file '%s'\", name);",
      "",
      "---------------",
      "--- Hunk 27 ---",
      "[Context before]",
      "1016:     {",
      "1017:         if (fchown(fd, uid, gid) == -1)",
      "1018:         {",
      "1020:         }",
      "1021:     }",
      "",
      "[Removed Lines]",
      "1019:             perror_msg(\"Can't change '%s' ownership to %lu:%lu\", path, (long)uid, (long)gid);",
      "",
      "[Added Lines]",
      "1089:             perror_msg(\"Can't change '%s' ownership to %lu:%lu\", name, (long)uid, (long)gid);",
      "1090:             close(fd);",
      "1091:             return false;",
      "",
      "---------------",
      "--- Hunk 28 ---",
      "[Context before]",
      "1029:     if (fchmod(fd, mode) == -1)",
      "1030:     {",
      "1032:     }",
      "1034:     unsigned r = full_write(fd, data, size);",
      "1035:     close(fd);",
      "1036:     if (r != size)",
      "1037:     {",
      "1039:         return false;",
      "1040:     }",
      "",
      "[Removed Lines]",
      "1031:         perror_msg(\"Can't change mode of '%s'\", path);",
      "1038:         error_msg(\"Can't save file '%s'\", path);",
      "",
      "[Added Lines]",
      "1103:         perror_msg(\"Can't change mode of '%s'\", name);",
      "1104:         close(fd);",
      "1105:         return false;",
      "1112:         error_msg(\"Can't save file '%s'\", name);",
      "",
      "---------------",
      "--- Hunk 29 ---",
      "[Context before]",
      "1058:     if (strcmp(name, \"release\") == 0)",
      "1059:         name = FILENAME_OS_RELEASE;",
      "1066: }",
      "1068: char* dd_load_text(const struct dump_dir *dd, const char *name)",
      "",
      "[Removed Lines]",
      "1061:     char *full_path = concat_path_file(dd->dd_dirname, name);",
      "1062:     char *ret = load_text_file(full_path, flags);",
      "1063:     free(full_path);",
      "1065:     return ret;",
      "",
      "[Added Lines]",
      "1135:     return load_text_file_at(dd->dd_fd, name, flags);",
      "",
      "---------------",
      "--- Hunk 30 ---",
      "[Context before]",
      "1078:     if (!str_is_correct_filename(name))",
      "1079:         error_msg_and_die(\"Cannot save text. '%s' is not a valid file name\", name);",
      "1084: }",
      "1086: void dd_save_binary(struct dump_dir* dd, const char* name, const char* data, unsigned size)",
      "",
      "[Removed Lines]",
      "1081:     char *full_path = concat_path_file(dd->dd_dirname, name);",
      "1082:     save_binary_file(full_path, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);",
      "1083:     free(full_path);",
      "",
      "[Added Lines]",
      "1151:     save_binary_file_at(dd->dd_fd, name, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);",
      "",
      "---------------",
      "--- Hunk 31 ---",
      "[Context before]",
      "1091:     if (!str_is_correct_filename(name))",
      "1092:         error_msg_and_die(\"Cannot save binary. '%s' is not a valid file name\", name);",
      "1097: }",
      "1099: long dd_get_item_size(struct dump_dir *dd, const char *name)",
      "",
      "[Removed Lines]",
      "1094:     char *full_path = concat_path_file(dd->dd_dirname, name);",
      "1095:     save_binary_file(full_path, data, size, dd->dd_uid, dd->dd_gid, dd->mode);",
      "1096:     free(full_path);",
      "",
      "[Added Lines]",
      "1162:     save_binary_file_at(dd->dd_fd, name, data, size, dd->dd_uid, dd->dd_gid, dd->mode);",
      "",
      "---------------",
      "--- Hunk 32 ---",
      "[Context before]",
      "1102:         error_msg_and_die(\"Cannot get item size. '%s' is not a valid file name\", name);",
      "1104:     long size = -1;",
      "1106:     struct stat statbuf;",
      "1109:         size = statbuf.st_size;",
      "1110:     else",
      "1111:     {",
      "1112:         if (errno == ENOENT)",
      "1113:             size = 0;",
      "1114:         else",
      "1116:     }",
      "1120:     return size;",
      "1121: }",
      "",
      "[Removed Lines]",
      "1105:     char *iname = concat_path_file(dd->dd_dirname, name);",
      "1108:     if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))",
      "1115:             perror_msg(\"Can't get size of file '%s'\", iname);",
      "1118:     free(iname);",
      "",
      "[Added Lines]",
      "1172:     int r = fstatat(dd->dd_fd, name, &statbuf, AT_SYMLINK_NOFOLLOW);",
      "1174:     if (r == 0 && S_ISREG(statbuf.st_mode))",
      "1181:             perror_msg(\"Can't get size of file '%s'\", name);",
      "",
      "---------------",
      "--- Hunk 33 ---",
      "[Context before]",
      "1128:     if (!str_is_correct_filename(name))",
      "1129:         error_msg_and_die(\"Cannot delete item. '%s' is not a valid file name\", name);",
      "1134:     if (res < 0)",
      "1135:     {",
      "1136:         if (errno == ENOENT)",
      "1137:             errno = res = 0;",
      "1138:         else",
      "1140:     }",
      "1143:     return res;",
      "1144: }",
      "",
      "[Removed Lines]",
      "1131:     char *path = concat_path_file(dd->dd_dirname, name);",
      "1132:     int res = unlink(path);",
      "1139:             perror_msg(\"Can't delete file '%s'\", path);",
      "1142:     free(path);",
      "",
      "[Added Lines]",
      "1195:     int res = unlinkat(dd->dd_fd, name, /*only files*/0);",
      "1202:             perror_msg(\"Can't delete file '%s'\", name);",
      "",
      "---------------",
      "--- Hunk 34 ---",
      "[Context before]",
      "1147: {",
      "1151:     if (dd->next_dir)",
      "1152:         closedir(dd->next_dir);",
      "1155:     if (!dd->next_dir)",
      "1156:     {",
      "1157:         error_msg(\"Can't open directory '%s'\", dd->dd_dirname);",
      "",
      "[Removed Lines]",
      "1154:     dd->next_dir = opendir(dd->dd_dirname);",
      "",
      "[Added Lines]",
      "1212:     int opendir_fd = dup(dd->dd_fd);",
      "1213:     if (opendir_fd < 0)",
      "1214:     {",
      "1215:         perror_msg(\"dd_init_next_file: dup(dd_fd)\");",
      "1216:         return NULL;",
      "1217:     }",
      "1222:     dd->next_dir = fdopendir(opendir_fd);",
      "",
      "---------------",
      "--- Hunk 35 ---",
      "[Context before]",
      "1168:     struct dirent *dent;",
      "1169:     while ((dent = readdir(dd->next_dir)) != NULL)",
      "1170:     {",
      "1172:         {",
      "1173:             if (short_name)",
      "",
      "[Removed Lines]",
      "1171:         if (is_regular_file(dent, dd->dd_dirname))",
      "",
      "[Added Lines]",
      "1239:         if (is_regular_file_at(dent, dd->dd_fd))",
      "",
      "---------------"
    ],
    "src/lib/problem_data.c||src/lib/problem_data.c": [
      "File: src/lib/problem_data.c -> src/lib/problem_data.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "279:     FILENAME_OS_RELEASE,",
      "280:     NULL",
      "281: };",
      "283: {",
      "290:     if (fd < 0)",
      "",
      "[Removed Lines]",
      "282: static char* is_text_file(const char *name, ssize_t *sz)",
      "289:     int fd = open(name, O_RDONLY);",
      "",
      "[Added Lines]",
      "282: static char* is_text_file_at(int dir_fd, const char *name, ssize_t *sz)",
      "289:     int fd = secure_openat_read(dir_fd, name);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "399:         }",
      "401:         ssize_t sz = 4*1024;",
      "403:         if (!text || text == HUGE_TEXT)",
      "404:         {",
      "405:             int flag = !text ? CD_FLAG_BIN : (CD_FLAG_BIN+CD_FLAG_BIGTXT);",
      "",
      "[Removed Lines]",
      "402:         char *text = is_text_file(full_name, &sz);",
      "",
      "[Added Lines]",
      "402:         char *text = is_text_file_at(dd->dd_fd, short_name, &sz);",
      "",
      "---------------"
    ],
    "src/lib/xfuncs.c||src/lib/xfuncs.c": [
      "File: src/lib/xfuncs.c -> src/lib/xfuncs.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "331:     return xopen3(pathname, flags, 0666);",
      "332: }",
      "334: void xunlink(const char *pathname)",
      "335: {",
      "336:     if (unlink(pathname))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "334: void xunlinkat(int dir_fd, const char *pathname, int flags)",
      "335: {",
      "336:     if (unlinkat(dir_fd, pathname, flags))",
      "337:         perror_msg_and_die(\"Can't remove file '%s'\", pathname);",
      "338: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "363: {",
      "364:     if (dent->d_type == DT_REG)",
      "365:         return 1;",
      "366:     if (dent->d_type != DT_UNKNOWN)",
      "367:         return 0;",
      "370:     struct stat statbuf;",
      "374:     return r == 0 && S_ISREG(statbuf.st_mode);",
      "375: }",
      "379: bool dot_or_dotdot(const char *filename)",
      "",
      "[Removed Lines]",
      "362: int is_regular_file(struct dirent *dent, const char *dirname)",
      "369:     char *fullname = xasprintf(\"%s/%s\", dirname, dent->d_name);",
      "371:     int r = lstat(fullname, &statbuf);",
      "372:     free(fullname);",
      "",
      "[Added Lines]",
      "368: int is_regular_file_at(struct dirent *dent, int dir_fd)",
      "376:     int r = fstatat(dir_fd, dent->d_name, &statbuf, AT_SYMLINK_NOFOLLOW);",
      "381: int is_regular_file(struct dirent *dent, const char *dirname)",
      "382: {",
      "383:     int dir_fd = open(dirname, O_DIRECTORY);",
      "384:     if (dir_fd < 0)",
      "385:         return 0;",
      "386:     int r = is_regular_file_at(dent, dir_fd);",
      "387:     close(dir_fd);",
      "388:     return r;",
      "389: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "54ecf8d017580b495d6501e53ca54e453a73a364",
      "candidate_info": {
        "commit_hash": "54ecf8d017580b495d6501e53ca54e453a73a364",
        "repo": "abrt/libreport",
        "commit_url": "https://github.com/abrt/libreport/commit/54ecf8d017580b495d6501e53ca54e453a73a364",
        "files": [
          "src/include/internal_libreport.h",
          "src/lib/concat_path_file.c",
          "tests/Makefile.am",
          "tests/dump_dir.at",
          "tests/testsuite.at"
        ],
        "message": "lib: add a function checking file names\n\nMove the code from ABRT and extend it a bit:\n* allow only 64 characters\n* allow '.' in names (vmcore_dmesg.txt)\n* forbid '/'\n* forbid \".\"\n* forbid \"..\"\n\nRelated: #1214451\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "src/include/internal_libreport.h||src/include/internal_libreport.h",
          "src/lib/concat_path_file.c||src/lib/concat_path_file.c",
          "tests/Makefile.am||tests/Makefile.am",
          "tests/dump_dir.at||tests/dump_dir.at",
          "tests/testsuite.at||tests/testsuite.at"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/abrt/libreport/pull/343"
        ],
        "olp_code_files": {
          "patch": [
            "src/include/internal_libreport.h||src/include/internal_libreport.h"
          ],
          "candidate": [
            "src/include/internal_libreport.h||src/include/internal_libreport.h"
          ]
        }
      },
      "candidate_diff": {
        "src/include/internal_libreport.h||src/include/internal_libreport.h": [
          "File: src/include/internal_libreport.h -> src/include/internal_libreport.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "132: #define concat_path_basename libreport_concat_path_basename",
          "133: char *concat_path_basename(const char *path, const char *filename);",
          "136: #define xmalloc_fgets libreport_xmalloc_fgets",
          "137: char *xmalloc_fgets(FILE *file);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "138: #define str_is_correct_filename libreport_str_is_correct_filename",
          "139: bool str_is_correct_filename(const char *str);",
          "",
          "---------------"
        ],
        "src/lib/concat_path_file.c||src/lib/concat_path_file.c": [
          "File: src/lib/concat_path_file.c -> src/lib/concat_path_file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "57:     free(abspath);",
          "58:     return name;",
          "59: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "61: bool str_is_correct_filename(const char *str)",
          "62: {",
          "63: #define NOT_PRINTABLE(c) (c < ' ' || c == 0x7f)",
          "65:     if (NOT_PRINTABLE(*str) || *str == '/' || *str == '\\0')",
          "66:         return false;",
          "67:     ++str;",
          "69:     if (NOT_PRINTABLE(*str) || *str =='/' || (*str == '\\0' && *(str-1) == '.'))",
          "70:         return false;",
          "71:     ++str;",
          "73:     if (NOT_PRINTABLE(*str) || *str =='/' || (*str == '\\0' && *(str-1) == '.' && *(str-2) == '.'))",
          "74:         return false;",
          "75:     ++str;",
          "77:     for (unsigned i = 0; *str != '\\0' && i < 61; ++str, ++i)",
          "78:         if (NOT_PRINTABLE(*str) || *str == '/')",
          "79:             return false;",
          "81:     return *str == '\\0';",
          "83: #undef NOT_PRINTABLE",
          "84: }",
          "",
          "---------------"
        ],
        "tests/Makefile.am||tests/Makefile.am": [
          "File: tests/Makefile.am -> tests/Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "42:   report_python.at \\",
          "43:   xfuncs.at \\",
          "44:   string_list.at \\",
          "47: EXTRA_DIST += $(TESTSUITE_AT)",
          "48: TESTSUITE = $(srcdir)/testsuite",
          "",
          "[Removed Lines]",
          "45:   ureport.at",
          "",
          "[Added Lines]",
          "45:   ureport.at \\",
          "46:   dump_dir.at",
          "",
          "---------------"
        ],
        "tests/dump_dir.at||tests/dump_dir.at": [
          "File: tests/dump_dir.at -> tests/dump_dir.at",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # -*- Autotest -*-",
          "3: AT_BANNER([dump directories])",
          "5: ## ----------------------- ##",
          "6: ## str_is_correct_filename ##",
          "7: ## ----------------------- ##",
          "9: AT_TESTFUN([str_is_correct_filename],",
          "10: [[",
          "11: #include \"internal_libreport.h\"",
          "12: #include <assert.h>",
          "13: #",
          "14: int main(void)",
          "15: {",
          "16:     g_verbose = 3;",
          "18:     assert(str_is_correct_filename(\"\") == false);",
          "19:     assert(str_is_correct_filename(\"/\") == false);",
          "20:     assert(str_is_correct_filename(\"//\") == false);",
          "21:     assert(str_is_correct_filename(\".\") == false);",
          "22:     assert(str_is_correct_filename(\".\") == false);",
          "23:     assert(str_is_correct_filename(\"..\") == false);",
          "24:     assert(str_is_correct_filename(\"..\") == false);",
          "25:     assert(str_is_correct_filename(\"/.\") == false);",
          "26:     assert(str_is_correct_filename(\"//.\") == false);",
          "27:     assert(str_is_correct_filename(\"./\") == false);",
          "28:     assert(str_is_correct_filename(\".//\") == false);",
          "29:     assert(str_is_correct_filename(\"/./\") == false);",
          "30:     assert(str_is_correct_filename(\"/..\") == false);",
          "31:     assert(str_is_correct_filename(\"//..\") == false);",
          "32:     assert(str_is_correct_filename(\"../\") == false);",
          "33:     assert(str_is_correct_filename(\"..//\") == false);",
          "34:     assert(str_is_correct_filename(\"/../\") == false);",
          "35:     assert(str_is_correct_filename(\"/.././\") == false);",
          "37:     assert(str_is_correct_filename(\"looks-good-but-evil/\") == false);",
          "38:     assert(str_is_correct_filename(\"looks-good-but-evil/../../\") == false);",
          "40:     assert(str_is_correct_filename(\".meta-data\") == true);",
          "41:     assert(str_is_correct_filename(\"..meta-meta-data\") == true);",
          "42:     assert(str_is_correct_filename(\"meta-..-data\") == true);",
          "44:     assert(str_is_correct_filename(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890+-\") == true);",
          "45:     assert(str_is_correct_filename(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890+-=\") == false);",
          "47:     return 0;",
          "48: }",
          "49: ]])",
          "",
          "---------------"
        ],
        "tests/testsuite.at||tests/testsuite.at": [
          "File: tests/testsuite.at -> tests/testsuite.at",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: m4_include([report_python.at])",
          "18: m4_include([string_list.at])",
          "19: m4_include([ureport.at])",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: m4_include([dump_dir.at])",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b81884dcf41a6ee84c9ef5633acd2193bee60005",
      "candidate_info": {
        "commit_hash": "b81884dcf41a6ee84c9ef5633acd2193bee60005",
        "repo": "abrt/libreport",
        "commit_url": "https://github.com/abrt/libreport/commit/b81884dcf41a6ee84c9ef5633acd2193bee60005",
        "files": [
          "src/include/dump_dir.h",
          "src/lib/dump_dir.c"
        ],
        "message": "dump_dir: allow creating of a new dir w/o chowning it\n\nSplit dd_create() in to dd_create_skeleton() creating the directory and\nintializing struct dd* and dd_reset_ownership() updating UID and GUI to\nthe deemed values.\n\nWe need this because we have to avoid situations where root is using a\ndirectory owned by a regular user.\n\nRelated: #1211835\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "src/include/dump_dir.h||src/include/dump_dir.h",
          "src/lib/dump_dir.c||src/lib/dump_dir.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/abrt/libreport/pull/343"
        ],
        "olp_code_files": {
          "patch": [
            "src/include/dump_dir.h||src/include/dump_dir.h",
            "src/lib/dump_dir.c||src/lib/dump_dir.c"
          ],
          "candidate": [
            "src/include/dump_dir.h||src/include/dump_dir.h",
            "src/lib/dump_dir.c||src/lib/dump_dir.c"
          ]
        }
      },
      "candidate_diff": {
        "src/include/dump_dir.h||src/include/dump_dir.h": [
          "File: src/include/dump_dir.h -> src/include/dump_dir.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "60: void dd_close(struct dump_dir *dd);",
          "62: struct dump_dir *dd_opendir(const char *dir, int flags);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "63: struct dump_dir *dd_create_skeleton(const char *dir, uid_t uid, mode_t mode);",
          "64: int dd_reset_ownership(struct dump_dir *dd);",
          "",
          "---------------"
        ],
        "src/lib/dump_dir.c||src/lib/dump_dir.c": [
          "File: src/lib/dump_dir.c -> src/lib/dump_dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "515: {",
          "517:     mode_t dir_mode = mode | ((mode & 0444) >> 2);",
          "",
          "[Removed Lines]",
          "514: struct dump_dir *dd_create(const char *dir, uid_t uid, mode_t mode)",
          "",
          "[Added Lines]",
          "517: struct dump_dir *dd_create_skeleton(const char *dir, uid_t uid, mode_t mode)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "601:         else",
          "602:             error_msg(\"User %lu does not exist, using gid 0\", (long)uid);",
          "603: #endif",
          "610:     }",
          "612:     return dd;",
          "613: }",
          "",
          "[Removed Lines]",
          "605:         if (lchown(dir, dd->dd_uid, dd->dd_gid) == -1)",
          "606:         {",
          "607:             perror_msg(\"Can't change '%s' ownership to %lu:%lu\", dir,",
          "608:                        (long)dd->dd_uid, (long)dd->dd_gid);",
          "609:         }",
          "",
          "[Added Lines]",
          "607:     }",
          "609:     return dd;",
          "610: }",
          "615: int dd_reset_ownership(struct dump_dir *dd)",
          "616: {",
          "617:     const int r =lchown(dd->dd_dirname, dd->dd_uid, dd->dd_gid);",
          "618:     if (r < 0)",
          "619:     {",
          "620:         perror_msg(\"Can't change '%s' ownership to %lu:%lu\", dd->dd_dirname,",
          "621:                    (long)dd->dd_uid, (long)dd->dd_gid);",
          "623:     return r;",
          "624: }",
          "628: struct dump_dir *dd_create(const char *dir, uid_t uid, mode_t mode)",
          "629: {",
          "630:     struct dump_dir *dd = dd_create_skeleton(dir, uid, mode);",
          "631:     if (dd == NULL)",
          "632:         return NULL;",
          "635:     dd_reset_ownership(dd);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e705c7ff8b6907422753b44ad2bd9d8293578098",
      "candidate_info": {
        "commit_hash": "e705c7ff8b6907422753b44ad2bd9d8293578098",
        "repo": "abrt/libreport",
        "commit_url": "https://github.com/abrt/libreport/commit/e705c7ff8b6907422753b44ad2bd9d8293578098",
        "files": [
          "src/include/internal_libreport.h",
          "src/lib/copyfd.c"
        ],
        "message": "lib: introduce a new function copy_file_ext\n\nThe new function allows to specify UID, GID and open() flags for both\nsource and destination files.\n\nThis function is need to avoid race conditions and symbolic link issues.\n\nRelated: #1211835\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "src/include/internal_libreport.h||src/include/internal_libreport.h",
          "src/lib/copyfd.c||src/lib/copyfd.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/abrt/libreport/pull/343"
        ],
        "olp_code_files": {
          "patch": [
            "src/include/internal_libreport.h||src/include/internal_libreport.h"
          ],
          "candidate": [
            "src/include/internal_libreport.h||src/include/internal_libreport.h"
          ]
        }
      },
      "candidate_diff": {
        "src/include/internal_libreport.h||src/include/internal_libreport.h": [
          "File: src/include/internal_libreport.h -> src/include/internal_libreport.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "153: off_t copyfd_size(int src_fd, int dst_fd, off_t size, int flags);",
          "154: #define copyfd_exact_size libreport_copyfd_exact_size",
          "155: void copyfd_exact_size(int src_fd, int dst_fd, off_t size);",
          "156: #define copy_file libreport_copy_file",
          "157: off_t copy_file(const char *src_name, const char *dst_name, int mode);",
          "158: #define copy_file_recursive libreport_copy_file_recursive",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "156: #define copy_file_ext libreport_copy_file_ext",
          "157: off_t copy_file_ext(const char *src_name, const char *dst_name, int mode, uid_t uid, gid_t gid, int src_flags, int dst_flags);",
          "",
          "---------------"
        ],
        "src/lib/copyfd.c||src/lib/copyfd.c": [
          "File: src/lib/copyfd.c -> src/lib/copyfd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "149:  return full_fd_action(fd1, fd2, 0, flags);",
          "150: }",
          "153: {",
          "154:     off_t r;",
          "156:     if (src < 0)",
          "157:     {",
          "158:         perror_msg(\"Can't open '%s'\", src_name);",
          "159:         return -1;",
          "160:     }",
          "162:     if (dst < 0)",
          "163:     {",
          "164:         close(src);",
          "",
          "[Removed Lines]",
          "152: off_t copy_file(const char *src_name, const char *dst_name, int mode)",
          "155:     int src = open(src_name, O_RDONLY);",
          "161:     int dst = open(dst_name, O_WRONLY | O_TRUNC | O_CREAT, mode);",
          "",
          "[Added Lines]",
          "152: off_t copy_file_ext(const char *src_name, const char *dst_name, int mode, uid_t uid, gid_t gid, int src_flags, int dst_flags)",
          "155:     int src = open(src_name, src_flags);",
          "161:     int dst = open(dst_name, dst_flags, mode);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "167:     }",
          "168:     r = copyfd_eof(src, dst, /*flags:*/ 0);",
          "169:     close(src);",
          "170:     close(dst);",
          "171:     return r;",
          "172: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "170:     if (uid != (uid_t)-1L)",
          "171:     {",
          "172:         if (fchown(dst, uid, gid) == -1)",
          "173:         {",
          "174:             perror_msg(\"Can't change '%s' ownership to %lu:%lu\", dst_name, (long)uid, (long)gid);",
          "175:             close(dst);",
          "176:             unlink(dst_name);",
          "177:             return -1;",
          "178:         }",
          "179:     }",
          "184: off_t copy_file(const char *src_name, const char *dst_name, int mode)",
          "185: {",
          "186:     return copy_file_ext(src_name, dst_name, mode, -1, -1, O_RDONLY, O_WRONLY | O_TRUNC | O_CREAT);",
          "187: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "67899c5a5d4a5f884ac07d691be4495551ad1551",
      "candidate_info": {
        "commit_hash": "67899c5a5d4a5f884ac07d691be4495551ad1551",
        "repo": "abrt/libreport",
        "commit_url": "https://github.com/abrt/libreport/commit/67899c5a5d4a5f884ac07d691be4495551ad1551",
        "files": [
          "src/include/dump_dir.h",
          "src/include/internal_libreport.h",
          "src/lib/dump_dir.c",
          "src/lib/problem_data.c",
          "src/lib/xfuncs.c"
        ],
        "message": "lib: fix races in dump directory handling code\n\nFlorian Weimer <fweimer@redhat.com>:\n\n    dd_opendir() should keep a file handle (opened with O_DIRECTORY) and\n    use openat() and similar functions to access files in it.\n\n    ...\n\n    The file system manipulation functions should guard against hard\n    links (check that link count is <= 1, just as in the user coredump\n    code in abrt-hook-ccpp), possibly after opening the file\n    with O_PATH first to avoid side effects on open/close.\n\nO_PATH is not available in RHEL-6\n\nRelated: #1214745\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "src/include/dump_dir.h||src/include/dump_dir.h",
          "src/include/internal_libreport.h||src/include/internal_libreport.h",
          "src/lib/dump_dir.c||src/lib/dump_dir.c",
          "src/lib/problem_data.c||src/lib/problem_data.c",
          "src/lib/xfuncs.c||src/lib/xfuncs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/include/dump_dir.h||src/include/dump_dir.h",
            "src/include/internal_libreport.h||src/include/internal_libreport.h",
            "src/lib/dump_dir.c||src/lib/dump_dir.c",
            "src/lib/problem_data.c||src/lib/problem_data.c",
            "src/lib/xfuncs.c||src/lib/xfuncs.c"
          ],
          "candidate": [
            "src/include/dump_dir.h||src/include/dump_dir.h",
            "src/include/internal_libreport.h||src/include/internal_libreport.h",
            "src/lib/dump_dir.c||src/lib/dump_dir.c",
            "src/lib/problem_data.c||src/lib/problem_data.c",
            "src/lib/xfuncs.c||src/lib/xfuncs.c"
          ]
        }
      },
      "candidate_diff": {
        "src/include/dump_dir.h||src/include/dump_dir.h": [
          "File: src/include/dump_dir.h -> src/include/dump_dir.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: extern \"C\" {",
          "33: #endif",
          "35: enum {",
          "36:     DD_FAIL_QUIETLY_ENOENT = (1 << 0),",
          "37:     DD_FAIL_QUIETLY_EACCES = (1 << 1),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40: int secure_openat_read(int dir_fd, const char *filename);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "50:     int locked;",
          "51:     uid_t dd_uid;",
          "52:     gid_t dd_gid;",
          "54:     mode_t mode;",
          "55: };",
          "57: void dd_close(struct dump_dir *dd);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "62:     time_t dd_time;",
          "63:     int dd_fd;",
          "",
          "---------------"
        ],
        "src/include/internal_libreport.h||src/include/internal_libreport.h": [
          "File: src/include/internal_libreport.h -> src/include/internal_libreport.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "389: int xopen(const char *pathname, int flags);",
          "390: #define xunlink libreport_xunlink",
          "391: void xunlink(const char *pathname);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "392: #define xunlinkat libreport_xunlinkat",
          "393: void xunlinkat(int dir_fd, const char *pathname, int flags);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "399: #define is_regular_file libreport_is_regular_file",
          "400: int is_regular_file(struct dirent *dent, const char *dirname);",
          "402: #define dot_or_dotdot libreport_dot_or_dotdot",
          "403: bool dot_or_dotdot(const char *filename);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "403: #define is_regular_file_at libreport_is_regular_file_at",
          "404: int is_regular_file_at(struct dirent *dent, int dir_fd);",
          "",
          "---------------"
        ],
        "src/lib/dump_dir.c||src/lib/dump_dir.c": [
          "File: src/lib/dump_dir.c -> src/lib/dump_dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "87: static char *load_text_file(const char *path, unsigned flags);",
          "89: static bool isdigit_str(const char *str)",
          "90: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "88: static char *load_text_file_at(int dir_fd, const char *name, unsigned flags);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "96:     return true;",
          "97: }",
          "100: {",
          "101:     struct stat buf;",
          "103:     {",
          "104:         if (S_ISDIR(buf.st_mode) || S_ISREG(buf.st_mode))",
          "105:         {",
          "",
          "[Removed Lines]",
          "99: static bool exist_file_dir(const char *path)",
          "102:     if (stat(path, &buf) == 0)",
          "",
          "[Added Lines]",
          "100: static bool exist_file_dir_at(int dir_fd, const char *name)",
          "103:     if (fstatat(dir_fd, name, &buf, AT_SYMLINK_NOFOLLOW) == 0)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "109:     return false;",
          "110: }",
          "118: {",
          "120:     {",
          "121:         if (errno != EEXIST)",
          "122:         {",
          "",
          "[Removed Lines]",
          "117: static int get_and_set_lock(const char* lock_file, const char* pid)",
          "119:     while (symlink(pid, lock_file) != 0)",
          "",
          "[Added Lines]",
          "120: int secure_openat_read(int dir_fd, const char *pathname)",
          "121: {",
          "122:     int path_fd = openat(dir_fd, pathname, O_RDONLY | O_NOFOLLOW);",
          "123:     if (path_fd < 0)",
          "124:         return -1;",
          "126:     struct stat path_sb;",
          "127:     int r = fstat(path_fd, &path_sb);",
          "128:     if (r < 0)",
          "129:     {",
          "130:         perror_msg(\"stat\");",
          "131:         close(path_fd);",
          "132:         return -1;",
          "133:     }",
          "135:     if (!S_ISREG(path_sb.st_mode) || path_sb.st_nlink > 1)",
          "136:     {",
          "137:         VERB1 log(\"Path isn't a regular file or has more links (%lu)\", (unsigned long)path_sb.st_nlink);",
          "138:         errno = EINVAL;",
          "139:         close(path_fd);",
          "140:         return -1;",
          "141:     }",
          "143:     return path_fd;",
          "144: }",
          "151: static time_t parse_time_file_at(int dir_fd, const char *filename)",
          "152: {",
          "154:     int fd = secure_openat_read(dir_fd, filename);",
          "155:     if (fd < 0)",
          "156:     {",
          "157:         VERB2 perror_msg(\"Can't open '%s'\", filename);",
          "158:         return -1;",
          "159:     }",
          "162:     char time_buf[sizeof(time_t) * 3 + 1];",
          "163:     ssize_t rdsz = read(fd, time_buf, sizeof(time_buf));",
          "166:     close(fd);",
          "168:     if (rdsz == -1)",
          "169:     {",
          "170:         VERB2 perror_msg(\"Can't read from '%s'\", filename);",
          "171:         return -1;",
          "172:     }",
          "177:     if (rdsz == sizeof(time_buf))",
          "178:     {",
          "179:         VERB2 log(\"File '%s' is too long to be valid unix \"",
          "180:                        \"time stamp (max size %u)\", filename, (int)sizeof(time_buf));",
          "181:         return -1;",
          "182:     }",
          "187:     if (rdsz > 0 && time_buf[rdsz - 1] == '\\n')",
          "188:         rdsz--;",
          "189:     time_buf[rdsz] = '\\0';",
          "194:     char *endptr;",
          "195:     long long val = strtoll(time_buf, &endptr, /* base */ 10);",
          "196:     const long long MAX_TIME_T = (1ULL << (sizeof(time_t)*8 - 1)) - 1;",
          "199:     if (errno",
          "200:      || (*endptr != '\\0')",
          "201:      || val >= MAX_TIME_T",
          "203:     ) {",
          "204:         VERB2 perror_msg(\"File '%s' doesn't contain valid unix \"",
          "205:                         \"time stamp ('%s')\", filename, time_buf);",
          "206:         return -1;",
          "207:     }",
          "210:     return val;",
          "211: }",
          "218: int create_symlink_lockfile_at(int dir_fd, const char* lock_file, const char* pid)",
          "220:     while (symlinkat(pid, dir_fd, lock_file) != 0)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "129:         }",
          "131:         char pid_buf[sizeof(pid_t)*3 + 4];",
          "133:         if (r < 0)",
          "134:         {",
          "135:             if (errno == ENOENT)",
          "",
          "[Removed Lines]",
          "132:         ssize_t r = readlink(lock_file, pid_buf, sizeof(pid_buf) - 1);",
          "",
          "[Added Lines]",
          "233:         ssize_t r = readlinkat(dir_fd, lock_file, pid_buf, sizeof(pid_buf) - 1);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "161:             log(\"Lock file '%s' was locked by process %s, but it crashed?\", lock_file, pid_buf);",
          "162:         }",
          "165:         {",
          "166:             perror_msg(\"Can't remove stale lock file '%s'\", lock_file);",
          "167:             errno = 0;",
          "",
          "[Removed Lines]",
          "164:         if (unlink(lock_file) != 0 && errno != ENOENT)",
          "",
          "[Added Lines]",
          "265:         if (unlinkat(dir_fd, lock_file, /*only files*/0) != 0 && errno != ENOENT)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "173:     return 1;",
          "174: }",
          "176: static int dd_lock(struct dump_dir *dd, unsigned sleep_usec, int flags)",
          "177: {",
          "178:     if (dd->locked)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "277: static const char *dd_check(struct dump_dir *dd)",
          "278: {",
          "279:     dd->dd_time = parse_time_file_at(dd->dd_fd, FILENAME_TIME);",
          "280:     if (dd->dd_time < 0)",
          "281:     {",
          "282:         VERB1 log(\"Missing file: \"FILENAME_TIME);",
          "283:         return FILENAME_TIME;",
          "284:     }",
          "286:     return NULL;",
          "287: }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "181:     char pid_buf[sizeof(long)*3 + 2];",
          "182:     sprintf(pid_buf, \"%lu\", (long)getpid());",
          "189:     unsigned count = NO_TIME_FILE_COUNT;",
          "190:  retry:",
          "191:     while (1)",
          "192:     {",
          "194:         if (r < 0)",
          "196:         if (r > 0)",
          "",
          "[Removed Lines]",
          "184:     unsigned dirname_len = strlen(dd->dd_dirname);",
          "185:     char lock_buf[dirname_len + sizeof(\"/.lock\")];",
          "186:     strcpy(lock_buf, dd->dd_dirname);",
          "187:     strcpy(lock_buf + dirname_len, \"/.lock\");",
          "193:         int r = get_and_set_lock(lock_buf, pid_buf);",
          "",
          "[Added Lines]",
          "301:         int r = create_symlink_lockfile_at(dd->dd_fd, \".lock\", pid_buf);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "204:     {",
          "207:         {",
          "216:             if (--count == 0 || flags & DD_DONT_WAIT_FOR_LOCK)",
          "217:             {",
          "",
          "[Removed Lines]",
          "205:         strcpy(lock_buf + dirname_len, \"/\"FILENAME_TIME);",
          "206:         if (access(lock_buf, F_OK) != 0)",
          "213:             strcpy(lock_buf + dirname_len, \"/.lock\");",
          "214:             xunlink(lock_buf);",
          "215:             VERB1 log(\"Unlocked '%s' (no time file)\", lock_buf);",
          "",
          "[Added Lines]",
          "313:         const char *missing_file = dd_check(dd);",
          "314:         if (missing_file)",
          "321:             xunlinkat(dd->dd_fd, \".lock\", /*only files*/0);",
          "322:             VERB1 log(\"Unlocked '%s' (no or corrupted '%s' file)\", dd->dd_dirname, missing_file);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "233:     {",
          "234:         dd->locked = 0;",
          "243:     }",
          "244: }",
          "246: static inline struct dump_dir *dd_init(void)",
          "247: {",
          "249: }",
          "252: {",
          "259:     return ret;",
          "260: }",
          "",
          "[Removed Lines]",
          "236:         unsigned dirname_len = strlen(dd->dd_dirname);",
          "237:         char lock_buf[dirname_len + sizeof(\"/.lock\")];",
          "238:         strcpy(lock_buf, dd->dd_dirname);",
          "239:         strcpy(lock_buf + dirname_len, \"/.lock\");",
          "240:         xunlink(lock_buf);",
          "242:         VERB1 log(\"Unlocked '%s'\", lock_buf);",
          "248:     return (struct dump_dir*)xzalloc(sizeof(struct dump_dir));",
          "251: int dd_exist(const struct dump_dir *dd, const char *path)",
          "253:     if (!str_is_correct_filename(path))",
          "254:         error_msg_and_die(\"Cannot test existence. '%s' is not a valid file name\", path);",
          "256:     char *full_path = concat_path_file(dd->dd_dirname, path);",
          "257:     int ret = exist_file_dir(full_path);",
          "258:     free(full_path);",
          "",
          "[Added Lines]",
          "343:         xunlinkat(dd->dd_fd, \".lock\", /*only files*/0);",
          "345:         VERB1 log(\"Unlocked '%s/.lock'\", dd->dd_dirname);",
          "351:     struct dump_dir* dd = (struct dump_dir*)xzalloc(sizeof(struct dump_dir));",
          "352:     dd->dd_time = -1;",
          "353:     dd->dd_fd = -1;",
          "354:     return dd;",
          "357: int dd_exist(const struct dump_dir *dd, const char *name)",
          "359:     if (!str_is_correct_filename(name))",
          "360:         error_msg_and_die(\"Cannot test existence. '%s' is not a valid file name\", name);",
          "362:     const int ret = exist_file_dir_at(dd->dd_fd, name);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "265:         return;",
          "267:     dd_unlock(dd);",
          "268:     if (dd->next_dir)",
          "269:     {",
          "270:         closedir(dd->next_dir);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "373:     if (dd->dd_fd >= 0)",
          "374:         close(dd->dd_fd);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "288:     struct dump_dir *dd = dd_init();",
          "290:     dir = dd->dd_dirname = rm_trailing_slashes(dir);",
          "292:     struct stat stat_buf;",
          "294:         goto cant_access;",
          "296:     dd->mode = (stat_buf.st_mode & 0666);",
          "",
          "[Removed Lines]",
          "293:     if (stat(dir, &stat_buf) != 0)",
          "",
          "[Added Lines]",
          "399:     dd->dd_fd = open(dir, O_DIRECTORY | O_NOFOLLOW);",
          "401:     if (dd->dd_fd < 0)",
          "402:         goto cant_access;",
          "403:     if (fstat(dd->dd_fd, &stat_buf) != 0)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "301:         if ((flags & DD_OPEN_READONLY) && errno == EACCES)",
          "302:         {",
          "311:                 {",
          "312:                     dd_close(dd);",
          "313:                     dd = NULL;",
          "314:                 }",
          "316:                 return dd;",
          "317:             }",
          "318:         }",
          "",
          "[Removed Lines]",
          "305:             if (stat(dir, &stat_buf) == 0",
          "306:              && S_ISDIR(stat_buf.st_mode)",
          "307:              && access(dir, R_OK) == 0",
          "308:             ) {",
          "309:                 char *time_file_name = concat_path_file(dir, FILENAME_TIME);",
          "310:                 if (access(time_file_name, R_OK) != 0)",
          "315:                 free(time_file_name);",
          "",
          "[Added Lines]",
          "419:             if (faccessat(dd->dd_fd, \".\", R_OK, AT_SYMLINK_NOFOLLOW) == 0)",
          "420:             {",
          "421:                 if(dd_check(dd) != NULL)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "349:     if (geteuid() == 0)",
          "350:     {",
          "354:         {",
          "356:             dd_close(dd);",
          "357:             return NULL;",
          "358:         }",
          "",
          "[Removed Lines]",
          "352:         struct stat stat_buf;",
          "353:         if (stat(dir, &stat_buf) != 0 || !S_ISDIR(stat_buf.st_mode))",
          "355:             error_msg(\"Can't stat '%s', or it is not a directory\", dir);",
          "",
          "[Added Lines]",
          "462:         if (fstat(dd->dd_fd, &stat_buf) != 0)",
          "464:             error_msg(\"Can't stat '%s'\", dir);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "412:         error_msg(\"Bad dir name '%s'\", dir);",
          "415:     }",
          "",
          "[Removed Lines]",
          "413:         dd_close(dd);",
          "414:         return NULL;",
          "",
          "[Added Lines]",
          "522:         goto fail;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "427:     if (r != 0)",
          "428:     {",
          "429:         perror_msg(\"Can't create directory '%s'\", dir);",
          "432:     }",
          "435:     {",
          "438:     }",
          "442:     {",
          "443:         perror_msg(\"Can't change mode of '%s'\", dir);",
          "446:     }",
          "448:     dd->dd_uid = (uid_t)-1L;",
          "",
          "[Removed Lines]",
          "430:         dd_close(dd);",
          "431:         return NULL;",
          "434:     if (dd_lock(dd, CREATE_LOCK_USLEEP, /*flags:*/ 0) < 0)",
          "436:         dd_close(dd);",
          "437:         return NULL;",
          "441:     if (chmod(dir, dir_mode) == -1)",
          "444:         dd_close(dd);",
          "445:         return NULL;",
          "",
          "[Added Lines]",
          "538:         goto fail;",
          "541:     dd->dd_fd = open(dd->dd_dirname, O_DIRECTORY | O_NOFOLLOW);",
          "542:     if (dd->dd_fd < 0)",
          "544:         perror_msg(\"Can't open newly created directory '%s'\", dir);",
          "545:         goto fail;",
          "546:     }",
          "548:     struct stat stat_sb;",
          "549:     if (fstat(dd->dd_fd, &stat_sb) < 0)",
          "550:     {",
          "551:         perror_msg(\"stat(%s)\", dd->dd_dirname);",
          "552:         goto fail;",
          "555:     if (dd_lock(dd, CREATE_LOCK_USLEEP, /*flags:*/ 0) < 0)",
          "556:         goto fail;",
          "559:     if (fchmod(dd->dd_fd, dir_mode) == -1)",
          "562:         goto fail;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "467:     }",
          "469:     return dd;",
          "470: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "588: fail:",
          "589:     dd_close(dd);",
          "590:     return NULL;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "475: int dd_reset_ownership(struct dump_dir *dd)",
          "476: {",
          "478:     if (r < 0)",
          "479:     {",
          "480:         perror_msg(\"Can't change '%s' ownership to %lu:%lu\", dd->dd_dirname,",
          "",
          "[Removed Lines]",
          "477:     const int r =lchown(dd->dd_dirname, dd->dd_uid, dd->dd_gid);",
          "",
          "[Added Lines]",
          "598:     const int r = fchown(dd->dd_fd, dd->dd_uid, dd->dd_gid);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "573:     if (!dd->locked)",
          "582:     {",
          "622:     }",
          "624: }",
          "627: {",
          "629:     if (!d)",
          "630:     {",
          "",
          "[Removed Lines]",
          "576:     DIR *d = opendir(dd->dd_dirname);",
          "577:     if (!d)",
          "578:         return;",
          "580:     struct dirent *dent;",
          "581:     while ((dent = readdir(d)) != NULL)",
          "584:             continue;",
          "585:         char *full_path = concat_path_file(dd->dd_dirname, dent->d_name);",
          "586:         struct stat statbuf;",
          "587:         if (lstat(full_path, &statbuf) == 0 && S_ISREG(statbuf.st_mode))",
          "588:         {",
          "589:             if ((statbuf.st_mode & 0777) != dd->mode)",
          "590:             {",
          "597:                 int fd = open(full_path, O_RDONLY | O_NOFOLLOW, dd->mode);",
          "598:                 if (fd >= 0)",
          "599:                 {",
          "600:                     if (fchmod(fd, dd->mode) != 0)",
          "601:                     {",
          "602:                         perror_msg(\"Can't change '%s' mode to 0%o\", full_path,",
          "603:                                    (unsigned)dd->mode);",
          "604:                     }",
          "605:                     close(fd);",
          "606:                 }",
          "607:                 else",
          "608:                 {",
          "609:                     perror_msg(\"Can't open regular file '%s'\", full_path);",
          "610:                 }",
          "611:             }",
          "612:             if (statbuf.st_uid != dd->dd_uid || statbuf.st_gid != dd->dd_gid)",
          "613:             {",
          "614:                 if (lchown(full_path, dd->dd_uid, dd->dd_gid) != 0)",
          "615:                 {",
          "616:                     perror_msg(\"Can't change '%s' ownership to %lu:%lu\", full_path,",
          "617:                                (long)dd->dd_uid, (long)dd->dd_gid);",
          "618:                 }",
          "619:             }",
          "620:         }",
          "621:         free(full_path);",
          "623:     closedir(d);",
          "626: static int delete_file_dir(const char *dir, bool skip_lock_file)",
          "628:     DIR *d = opendir(dir);",
          "",
          "[Added Lines]",
          "697:     dd_init_next_file(dd);",
          "698:     char *short_name;",
          "699:     while (dd_get_next_file(dd, &short_name, /*full_name*/ NULL))",
          "702:         int fd = secure_openat_read(dd->dd_fd, short_name);",
          "703:         if (fd < 0)",
          "704:             goto next;",
          "706:         if (fchmod(fd, dd->mode) != 0)",
          "707:             perror_msg(\"Can't change '%s/%s' mode to 0%o\", dd->dd_dirname, short_name,",
          "708:                        (unsigned)dd->mode);",
          "710:         if (fchown(fd, dd->dd_uid, dd->dd_gid) != 0)",
          "711:             perror_msg(\"Can't change '%s/%s' ownership to %lu:%lu\", dd->dd_dirname, short_name,",
          "712:                        (long)dd->dd_uid, (long)dd->dd_gid);",
          "714:         close(fd);",
          "715: next:",
          "716:         free(short_name);",
          "720: static int delete_file_dir(int dir_fd, bool skip_lock_file)",
          "722:     int opendir_fd = dup(dir_fd);",
          "723:     if (opendir_fd < 0)",
          "724:     {",
          "725:         perror_msg(\"delete_file_dir: dup(dir_fd)\");",
          "726:         return -1;",
          "727:     }",
          "729:     DIR *d = fdopendir(opendir_fd);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "651:             unlink_lock_file = true;",
          "652:             continue;",
          "653:         }",
          "656:         {",
          "657:             int err = 0;",
          "658:             if (errno == EISDIR)",
          "659:             {",
          "660:                 errno = 0;",
          "662:             }",
          "663:             if (errno || err)",
          "664:             {",
          "667:                 closedir(d);",
          "668:                 return -1;",
          "669:             }",
          "670:         }",
          "672:     }",
          "",
          "[Removed Lines]",
          "654:         char *full_path = concat_path_file(dir, dent->d_name);",
          "655:         if (unlink(full_path) == -1 && errno != ENOENT)",
          "661:                 err = delete_file_dir(full_path, /*skip_lock_file:*/ false);",
          "665:                 perror_msg(\"Can't remove '%s'\", full_path);",
          "666:                 free(full_path);",
          "671:         free(full_path);",
          "673:     closedir(d);",
          "",
          "[Added Lines]",
          "755:         if (unlinkat(dir_fd, dent->d_name, /*only files*/0) == -1 && errno != ENOENT)",
          "761:                 int subdir_fd = openat(dir_fd, dent->d_name, O_DIRECTORY);",
          "762:                 if (subdir_fd < 0)",
          "763:                 {",
          "764:                     perror_msg(\"Can't open sub-dir'%s'\", dent->d_name);",
          "765:                     closedir(d);",
          "766:                     return -1;",
          "767:                 }",
          "768:                 else",
          "769:                 {",
          "770:                     err = delete_file_dir(subdir_fd, /*skip_lock_file:*/ false);",
          "771:                     close(subdir_fd);",
          "772:                     if (err == 0)",
          "773:                         unlinkat(dir_fd, dent->d_name, AT_REMOVEDIR);",
          "774:                 }",
          "778:                 perror_msg(\"Can't remove '%s'\", dent->d_name);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "680:     if (unlink_lock_file)",
          "704: }",
          "706: int dd_delete(struct dump_dir *dd)",
          "707: {",
          "710:     dd_close(dd);",
          "712: }",
          "715: {",
          "717:     if (fd == -1)",
          "718:     {",
          "719:         if (!(flags & DD_FAIL_QUIETLY_ENOENT))",
          "",
          "[Removed Lines]",
          "681:     {",
          "682:         char *full_path = concat_path_file(dir, \".lock\");",
          "683:         xunlink(full_path);",
          "684:         free(full_path);",
          "686:         unsigned cnt = RMDIR_FAIL_COUNT;",
          "687:         do {",
          "688:             if (rmdir(dir) == 0)",
          "689:                 return 0;",
          "696:             usleep(RMDIR_FAIL_USLEEP);",
          "697:         } while (--cnt != 0);",
          "698:     }",
          "700:     int r = rmdir(dir);",
          "701:     if (r)",
          "702:         perror_msg(\"Can't remove directory '%s'\", dir);",
          "703:     return r;",
          "708:     int r = delete_file_dir(dd->dd_dirname, /*skip_lock_file:*/ true);",
          "711:     return r;",
          "714: static char *load_text_file(const char *path, unsigned flags)",
          "716:     int fd = open(path, O_RDONLY | ((flags & DD_OPEN_FOLLOW) ? 0 : O_NOFOLLOW));",
          "",
          "[Added Lines]",
          "791:         xunlinkat(dir_fd, \".lock\", /*only files*/0);",
          "793:     closedir(d);",
          "794:     return 0;",
          "799:     if (!dd->locked)",
          "800:     {",
          "801:         error_msg(\"unlocked problem directory %s cannot be deleted\", dd->dd_dirname);",
          "802:         return -1;",
          "803:     }",
          "805:     if (delete_file_dir(dd->dd_fd, /*skip_lock_file:*/ true) != 0)",
          "806:     {",
          "807:         perror_msg(\"Can't remove contents of directory '%s'\", dd->dd_dirname);",
          "808:         return -2;",
          "809:     }",
          "811:     unsigned cnt = RMDIR_FAIL_COUNT;",
          "812:     do {",
          "813:         if (rmdir(dd->dd_dirname) == 0)",
          "814:             break;",
          "821:         usleep(RMDIR_FAIL_USLEEP);",
          "822:     } while (--cnt != 0);",
          "824:     if (cnt == 0)",
          "825:     {",
          "826:         perror_msg(\"Can't remove directory '%s'\", dd->dd_dirname);",
          "827:         return -3;",
          "828:     }",
          "832:     return 0;",
          "835: static char *load_text_from_file_descriptor(int fd, const char *path, int flags)",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "768:     return strbuf_free_nobuf(buf_content);",
          "769: }",
          "772: {",
          "776:     if (fd < 0)",
          "777:     {",
          "779:         return false;",
          "780:     }",
          "",
          "[Removed Lines]",
          "771: static bool save_binary_file(const char *path, const char* data, unsigned size, uid_t uid, gid_t gid, mode_t mode)",
          "774:     unlink(path);",
          "775:     int fd = open(path, O_WRONLY | O_TRUNC | O_CREAT | O_NOFOLLOW, mode);",
          "778:         perror_msg(\"Can't open file '%s'\", path);",
          "",
          "[Added Lines]",
          "891: static char *load_text_file_at(int dir_fd, const char *name, unsigned flags)",
          "893:     assert(name[0] != '/');",
          "895:     const int fd = openat(dir_fd, name, O_RDONLY | ((flags & DD_OPEN_FOLLOW) ? 0 : O_NOFOLLOW));",
          "896:     return load_text_from_file_descriptor(fd, name, flags);",
          "897: }",
          "899: static char *load_text_file(const char *path, unsigned flags)",
          "900: {",
          "901:     const int fd = open(path, O_RDONLY | ((flags & DD_OPEN_FOLLOW) ? 0 : O_NOFOLLOW));",
          "902:     return load_text_from_file_descriptor(fd, path, flags);",
          "903: }",
          "905: static bool save_binary_file_at(int dir_fd, const char *name, const char* data, unsigned size, uid_t uid, gid_t gid, mode_t mode)",
          "906: {",
          "907:     assert(name[0] != '/');",
          "910:     unlinkat(dir_fd, name, /*remove only files*/0);",
          "911:     int fd = openat(dir_fd, name, O_WRONLY | O_EXCL | O_CREAT | O_NOFOLLOW, mode);",
          "914:         perror_msg(\"Can't open file '%s'\", name);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "783:     {",
          "784:         if (fchown(fd, uid, gid) == -1)",
          "785:         {",
          "787:         }",
          "788:     }",
          "790:     unsigned r = full_write(fd, data, size);",
          "791:     close(fd);",
          "792:     if (r != size)",
          "793:     {",
          "795:         return false;",
          "796:     }",
          "",
          "[Removed Lines]",
          "786:             perror_msg(\"Can't change '%s' ownership to %lu:%lu\", path, (long)uid, (long)gid);",
          "794:         error_msg(\"Can't save file '%s'\", path);",
          "",
          "[Added Lines]",
          "922:             perror_msg(\"Can't change '%s' ownership to %lu:%lu\", name, (long)uid, (long)gid);",
          "923:             close(fd);",
          "924:             return false;",
          "934:     if (fchmod(fd, mode) == -1)",
          "935:     {",
          "936:         perror_msg(\"Can't change mode of '%s'\", name);",
          "937:         close(fd);",
          "938:         return false;",
          "939:     }",
          "945:         error_msg(\"Can't save file '%s'\", name);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "814:     if (strcmp(name, \"release\") == 0)",
          "815:         name = FILENAME_OS_RELEASE;",
          "822: }",
          "824: char* dd_load_text(const struct dump_dir *dd, const char *name)",
          "",
          "[Removed Lines]",
          "817:     char *full_path = concat_path_file(dd->dd_dirname, name);",
          "818:     char *ret = load_text_file(full_path, flags);",
          "819:     free(full_path);",
          "821:     return ret;",
          "",
          "[Added Lines]",
          "968:     return load_text_file_at(dd->dd_fd, name, flags);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "834:     if (!str_is_correct_filename(name))",
          "835:         error_msg_and_die(\"Cannot save text. '%s' is not a valid file name\", name);",
          "840: }",
          "842: void dd_save_binary(struct dump_dir* dd, const char* name, const char* data, unsigned size)",
          "",
          "[Removed Lines]",
          "837:     char *full_path = concat_path_file(dd->dd_dirname, name);",
          "838:     save_binary_file(full_path, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);",
          "839:     free(full_path);",
          "",
          "[Added Lines]",
          "984:     save_binary_file_at(dd->dd_fd, name, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "847:     if (!str_is_correct_filename(name))",
          "848:         error_msg_and_die(\"Cannot save binary. '%s' is not a valid file name\", name);",
          "853: }",
          "856: int dd_delete_item(struct dump_dir *dd, const char *name)",
          "857: {",
          "858:     if (!dd->locked)",
          "",
          "[Removed Lines]",
          "850:     char *full_path = concat_path_file(dd->dd_dirname, name);",
          "851:     save_binary_file(full_path, data, size, dd->dd_uid, dd->dd_gid, dd->mode);",
          "852:     free(full_path);",
          "",
          "[Added Lines]",
          "995:     save_binary_file_at(dd->dd_fd, name, data, size, dd->dd_uid, dd->dd_gid, dd->mode);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "861:     if (!str_is_correct_filename(name))",
          "862:         error_msg_and_die(\"Cannot delete item. '%s' is not a valid file name\", name);",
          "867:     if (res < 0)",
          "868:     {",
          "869:         if (errno == ENOENT)",
          "870:             res = 0;",
          "871:         else",
          "873:     }",
          "876:     return res;",
          "877: }",
          "",
          "[Removed Lines]",
          "864:     char *path = concat_path_file(dd->dd_dirname, name);",
          "865:     int res = unlink(path);",
          "872:             perror_msg(\"Can't delete file '%s'\", path);",
          "875:     free(path);",
          "",
          "[Added Lines]",
          "1006:     int res = unlinkat(dd->dd_fd, name, /*only files*/0);",
          "1013:             perror_msg(\"Can't delete file '%s'\", name);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "880: {",
          "884:     if (dd->next_dir)",
          "885:         closedir(dd->next_dir);",
          "888:     if (!dd->next_dir)",
          "889:     {",
          "890:         error_msg(\"Can't open directory '%s'\", dd->dd_dirname);",
          "",
          "[Removed Lines]",
          "887:     dd->next_dir = opendir(dd->dd_dirname);",
          "",
          "[Added Lines]",
          "1023:     int opendir_fd = dup(dd->dd_fd);",
          "1024:     if (opendir_fd < 0)",
          "1025:     {",
          "1026:         perror_msg(\"dd_init_next_file: dup(dd_fd)\");",
          "1027:         return NULL;",
          "1028:     }",
          "1033:     dd->next_dir = fdopendir(opendir_fd);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "901:     struct dirent *dent;",
          "902:     while ((dent = readdir(dd->next_dir)) != NULL)",
          "903:     {",
          "905:         {",
          "906:             if (short_name)",
          "",
          "[Removed Lines]",
          "904:         if (is_regular_file(dent, dd->dd_dirname))",
          "",
          "[Added Lines]",
          "1050:         if (is_regular_file_at(dent, dd->dd_fd))",
          "",
          "---------------"
        ],
        "src/lib/problem_data.c||src/lib/problem_data.c": [
          "File: src/lib/problem_data.c -> src/lib/problem_data.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "228:     FILENAME_BACKTRACE,",
          "229:     NULL",
          "230: };",
          "232: {",
          "239:     if (fd < 0)",
          "",
          "[Removed Lines]",
          "231: static char* is_text_file(const char *name, ssize_t *sz)",
          "238:     int fd = open(name, O_RDONLY);",
          "",
          "[Added Lines]",
          "231: static char* is_text_file_at(int dir_fd, const char *name, ssize_t *sz)",
          "238:     int fd = secure_openat_read(dir_fd, name);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "325:         if (!editable)",
          "326:         {",
          "328:             if (!text)",
          "329:             {",
          "330:                 add_to_problem_data_ext(problem_data,",
          "",
          "[Removed Lines]",
          "327:             text = is_text_file(full_name, &sz);",
          "",
          "[Added Lines]",
          "327:             text = is_text_file_at(dd->dd_fd, short_name, &sz);",
          "",
          "---------------"
        ],
        "src/lib/xfuncs.c||src/lib/xfuncs.c": [
          "File: src/lib/xfuncs.c -> src/lib/xfuncs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "331:     return xopen3(pathname, flags, 0666);",
          "332: }",
          "334: void xunlink(const char *pathname)",
          "335: {",
          "336:     if (unlink(pathname))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "334: void xunlinkat(int dir_fd, const char *pathname, int flags)",
          "335: {",
          "336:     if (unlinkat(dir_fd, pathname, flags))",
          "337:         perror_msg_and_die(\"Can't remove file '%s'\", pathname);",
          "338: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "363: {",
          "364:     if (dent->d_type == DT_REG)",
          "365:         return 1;",
          "366:     if (dent->d_type != DT_UNKNOWN)",
          "367:         return 0;",
          "370:     struct stat statbuf;",
          "374:     return r == 0 && S_ISREG(statbuf.st_mode);",
          "375: }",
          "379: bool dot_or_dotdot(const char *filename)",
          "",
          "[Removed Lines]",
          "362: int is_regular_file(struct dirent *dent, const char *dirname)",
          "369:     char *fullname = xasprintf(\"%s/%s\", dirname, dent->d_name);",
          "371:     int r = lstat(fullname, &statbuf);",
          "372:     free(fullname);",
          "",
          "[Added Lines]",
          "368: int is_regular_file_at(struct dirent *dent, int dir_fd)",
          "376:     int r = fstatat(dir_fd, dent->d_name, &statbuf, AT_SYMLINK_NOFOLLOW);",
          "381: int is_regular_file(struct dirent *dent, const char *dirname)",
          "382: {",
          "383:     int dir_fd = open(dirname, O_DIRECTORY);",
          "384:     if (dir_fd < 0)",
          "385:         return 0;",
          "386:     int r = is_regular_file_at(dent, dir_fd);",
          "387:     close(dir_fd);",
          "388:     return r;",
          "389: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "932b7f648cf7ba6861414033e9f07a88fee009f8",
      "candidate_info": {
        "commit_hash": "932b7f648cf7ba6861414033e9f07a88fee009f8",
        "repo": "abrt/libreport",
        "commit_url": "https://github.com/abrt/libreport/commit/932b7f648cf7ba6861414033e9f07a88fee009f8",
        "files": [
          "src/include/dump_dir.h",
          "src/include/internal_libreport.h",
          "src/lib/compress.c",
          "src/lib/copyfd.c",
          "src/lib/dump_dir.c",
          "src/lib/problem_data.c",
          "src/lib/xfuncs.c",
          "tests/dump_dir.at"
        ],
        "message": "lib: fix races in dump directory handling code\n\nFlorian Weimer <fweimer@redhat.com>:\n\n    dd_opendir() should keep a file handle (opened with O_DIRECTORY) and\n    use openat() and similar functions to access files in it.\n\n    ...\n\n    The file system manipulation functions should guard against hard\n    links (check that link count is <= 1, just as in the user coredump\n    code in abrt-hook-ccpp), possibly after opening the file\n    with O_PATH first to avoid side effects on open/close.\n\nRelated: #1214745\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "src/include/dump_dir.h||src/include/dump_dir.h",
          "src/include/internal_libreport.h||src/include/internal_libreport.h",
          "src/lib/compress.c||src/lib/compress.c",
          "src/lib/copyfd.c||src/lib/copyfd.c",
          "src/lib/dump_dir.c||src/lib/dump_dir.c",
          "src/lib/problem_data.c||src/lib/problem_data.c",
          "src/lib/xfuncs.c||src/lib/xfuncs.c",
          "tests/dump_dir.at||tests/dump_dir.at"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/include/dump_dir.h||src/include/dump_dir.h",
            "src/include/internal_libreport.h||src/include/internal_libreport.h",
            "src/lib/dump_dir.c||src/lib/dump_dir.c",
            "src/lib/problem_data.c||src/lib/problem_data.c",
            "src/lib/xfuncs.c||src/lib/xfuncs.c"
          ],
          "candidate": [
            "src/include/dump_dir.h||src/include/dump_dir.h",
            "src/include/internal_libreport.h||src/include/internal_libreport.h",
            "src/lib/dump_dir.c||src/lib/dump_dir.c",
            "src/lib/problem_data.c||src/lib/problem_data.c",
            "src/lib/xfuncs.c||src/lib/xfuncs.c"
          ]
        }
      },
      "candidate_diff": {
        "src/include/dump_dir.h||src/include/dump_dir.h": [
          "File: src/include/dump_dir.h -> src/include/dump_dir.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: int create_symlink_lockfile(const char *filename, const char *pid_str);",
          "38: enum {",
          "39:     DD_FAIL_QUIETLY_ENOENT = (1 << 0),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "37: int create_symlink_lockfile_at(int dir_fd, const char *filename, const char *pid_str);",
          "42: int secure_openat_read(int dir_fd, const char *filename);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "65:     int owns_lock;",
          "66: };",
          "68: void dd_close(struct dump_dir *dd);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "72:     int dd_fd;",
          "",
          "---------------"
        ],
        "src/include/internal_libreport.h||src/include/internal_libreport.h": [
          "File: src/include/internal_libreport.h -> src/include/internal_libreport.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "164: off_t copyfd_size(int src_fd, int dst_fd, off_t size, int flags);",
          "165: #define copyfd_exact_size libreport_copyfd_exact_size",
          "166: void copyfd_exact_size(int src_fd, int dst_fd, off_t size);",
          "169: #define copy_file libreport_copy_file",
          "170: off_t copy_file(const char *src_name, const char *dst_name, int mode);",
          "171: #define copy_file_recursive libreport_copy_file_recursive",
          "172: int copy_file_recursive(const char *source, const char *dest);",
          "",
          "[Removed Lines]",
          "167: #define copy_file_ext libreport_copy_file_ext",
          "168: off_t copy_file_ext(const char *src_name, const char *dst_name, int mode, uid_t uid, gid_t gid, int src_flags, int dst_flags);",
          "",
          "[Added Lines]",
          "167: #define copy_file_ext_at libreport_copy_file_ext_at",
          "168: off_t copy_file_ext_at(const char *src_name, int dir_fd, const char *name, int mode, uid_t uid, gid_t gid, int src_flags, int dst_flags);",
          "169: #define copy_file_ext(src_name, dst_name, mode, uid, gid, src_flags, dst_flags) \\",
          "170:     copy_file_ext_at(src_name, AT_FDCWD, dst_name, mode, uid, gid, src_flags, dst_flags)",
          "173: #define copy_file_at libreport_copy_file_at",
          "174: off_t copy_file_at(const char *src_name, int dir_fd, const char *name, int mode);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "175: int decompress_fd(int fdi, int fdo);",
          "176: #define decompress_file libreport_decompress_file",
          "177: int decompress_file(const char *path_in, const char *path_out, mode_t mode_out);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "182: #define decompress_file_ext_at libreport_decompress_file_ext_at",
          "183: int decompress_file_ext_at(const char *path_in, int dir_fd, const char *path_out,",
          "184:         mode_t mode_out, uid_t uid, gid_t gid, int src_flags, int dst_flags);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "420: int xopen(const char *pathname, int flags);",
          "421: #define xunlink libreport_xunlink",
          "422: void xunlink(const char *pathname);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "430: #define xunlinkat libreport_xunlinkat",
          "431: void xunlinkat(int dir_fd, const char *pathname, int flags);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "430: #define is_regular_file libreport_is_regular_file",
          "431: int is_regular_file(struct dirent *dent, const char *dirname);",
          "433: #define dot_or_dotdot libreport_dot_or_dotdot",
          "434: bool dot_or_dotdot(const char *filename);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "441: #define is_regular_file_at libreport_is_regular_file_at",
          "442: int is_regular_file_at(struct dirent *dent, int dir_fd);",
          "",
          "---------------"
        ],
        "src/lib/compress.c||src/lib/compress.c": [
          "File: src/lib/compress.c -> src/lib/compress.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "124: }",
          "126: int",
          "128: {",
          "130:     if (fdi < 0)",
          "131:     {",
          "132:         perror_msg(\"Could not open file: %s\", path_in);",
          "133:         return -1;",
          "134:     }",
          "137:     if (fdo < 0)",
          "138:     {",
          "139:         close(fdi);",
          "",
          "[Removed Lines]",
          "127: decompress_file(const char *path_in, const char *path_out, mode_t mode_out)",
          "129:     int fdi = open(path_in, O_RDONLY | O_CLOEXEC);",
          "136:     int fdo = open(path_out, O_WRONLY | O_CLOEXEC | O_EXCL | O_CREAT, mode_out);",
          "",
          "[Added Lines]",
          "127: decompress_file_ext_at(const char *path_in, int dir_fd, const char *path_out, mode_t mode_out,",
          "128:                        uid_t uid, gid_t gid, int src_flags, int dst_flags)",
          "130:     int fdi = open(path_in, src_flags);",
          "137:     int fdo = openat(dir_fd, path_out, dst_flags, mode_out);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "144:     int ret = decompress_fd(fdi, fdo);",
          "145:     close(fdi);",
          "146:     close(fdo);",
          "148:     if (ret != 0)",
          "151:     return ret;",
          "152: }",
          "",
          "[Removed Lines]",
          "149:         unlink(path_out);",
          "",
          "[Added Lines]",
          "147:     if (uid != (uid_t)-1L)",
          "148:     {",
          "149:         if (fchown(fdo, uid, gid) == -1)",
          "150:         {",
          "151:             perror_msg(\"Can't change ownership of '%s' to %lu:%lu\", path_out, (long)uid, (long)gid);",
          "152:             ret = -1;",
          "153:         }",
          "154:     }",
          "158:         unlinkat(dir_fd, path_out, /*only files*/0);",
          "163: int decompress_file(const char *path_in, const char *path_out, mode_t mode_out)",
          "164: {",
          "165:     return decompress_file_ext_at(path_in, AT_FDCWD, path_out, mode_out, -1, -1,",
          "166:             O_RDONLY, O_WRONLY | O_CREAT | O_EXCL | O_TRUNC);",
          "167: }",
          "",
          "---------------"
        ],
        "src/lib/copyfd.c||src/lib/copyfd.c": [
          "File: src/lib/copyfd.c -> src/lib/copyfd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "149:  return full_fd_action(fd1, fd2, 0, flags);",
          "150: }",
          "153: {",
          "154:     off_t r;",
          "155:     int src = open(src_name, src_flags);",
          "",
          "[Removed Lines]",
          "152: off_t copy_file_ext(const char *src_name, const char *dst_name, int mode, uid_t uid, gid_t gid, int src_flags, int dst_flags)",
          "",
          "[Added Lines]",
          "152: off_t copy_file_ext_at(const char *src_name, int dir_fd, const char *name, int mode, uid_t uid, gid_t gid, int src_flags, int dst_flags)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "158:         perror_msg(\"Can't open '%s'\", src_name);",
          "159:         return -1;",
          "160:     }",
          "162:     if (dst < 0)",
          "163:     {",
          "164:         close(src);",
          "166:         return -1;",
          "167:     }",
          "168:     r = copyfd_eof(src, dst, /*flags:*/ 0);",
          "",
          "[Removed Lines]",
          "161:     int dst = open(dst_name, dst_flags, mode);",
          "165:         perror_msg(\"Can't open '%s'\", dst_name);",
          "",
          "[Added Lines]",
          "161:     int dst = openat(dir_fd, name, dst_flags, mode);",
          "165:         perror_msg(\"Can't open '%s'\", name);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "171:     {",
          "172:         if (fchown(dst, uid, gid) == -1)",
          "173:         {",
          "175:             close(dst);",
          "177:             return -1;",
          "178:         }",
          "179:     }",
          "180:     close(dst);",
          "181:     return r;",
          "182: }",
          "184: off_t copy_file(const char *src_name, const char *dst_name, int mode)",
          "185: {",
          "187: }",
          "",
          "[Removed Lines]",
          "174:             perror_msg(\"Can't change '%s' ownership to %lu:%lu\", dst_name, (long)uid, (long)gid);",
          "176:             unlink(dst_name);",
          "186:     return copy_file_ext(src_name, dst_name, mode, -1, -1, O_RDONLY, O_WRONLY | O_TRUNC | O_CREAT);",
          "",
          "[Added Lines]",
          "174:             perror_msg(\"Can't change ownership of '%s' to %lu:%lu\", name, (long)uid, (long)gid);",
          "184: off_t copy_file_at(const char *src_name, int dir_fd, const char *name, int mode)",
          "185: {",
          "186:     return copy_file_ext_at(src_name, dir_fd, name, mode, -1, -1,",
          "187:             O_RDONLY, O_WRONLY | O_TRUNC | O_CREAT);",
          "188: }",
          "192:     return copy_file_ext(src_name, dst_name, mode, -1, -1,",
          "193:             O_RDONLY, O_WRONLY | O_TRUNC | O_CREAT);",
          "",
          "---------------"
        ],
        "src/lib/dump_dir.c||src/lib/dump_dir.c": [
          "File: src/lib/dump_dir.c -> src/lib/dump_dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "87: static char *load_text_file(const char *path, unsigned flags);",
          "88: static void copy_file_from_chroot(struct dump_dir* dd, const char *name,",
          "89:         const char *chroot_dir, const char *file_path);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "88: static char *load_text_file_at(int dir_fd, const char *name, unsigned flags);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "98:     return true;",
          "99: }",
          "102: {",
          "103:     struct stat buf;",
          "105:     {",
          "106:         if (S_ISDIR(buf.st_mode) || S_ISREG(buf.st_mode))",
          "107:         {",
          "",
          "[Removed Lines]",
          "101: static bool exist_file_dir(const char *path)",
          "104:     if (stat(path, &buf) == 0)",
          "",
          "[Added Lines]",
          "102: static bool exist_file_dir_at(int dir_fd, const char *name)",
          "105:     if (fstatat(dir_fd, name, &buf, AT_SYMLINK_NOFOLLOW) == 0)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "111:     return false;",
          "112: }",
          "120: {",
          "123:     if (fd < 0)",
          "124:     {",
          "125:         VERB2 pwarn_msg(\"Can't open '%s'\", filename);",
          "",
          "[Removed Lines]",
          "119: static time_t parse_time_file(const char *filename)",
          "122:     int fd = open(filename, O_RDONLY | O_NOFOLLOW);",
          "",
          "[Added Lines]",
          "125: int secure_openat_read(int dir_fd, const char *filename)",
          "126: {",
          "127:     if (strchr(filename, '/'))",
          "128:     {",
          "129:         error_msg(\"Path must be file name without directory: '%s'\", filename);",
          "130:         errno = EFAULT;",
          "131:         return -1;",
          "132:     }",
          "134:     static char reopen_buf[sizeof(\"/proc/self/fd/\") + 3*sizeof(int) + 1];",
          "136:     int path_fd = openat(dir_fd, filename, O_PATH | O_NOFOLLOW);",
          "137:     if (path_fd < 0)",
          "138:         return -1;",
          "140:     struct stat path_sb;",
          "141:     int r = fstat(path_fd, &path_sb);",
          "142:     if (r < 0)",
          "143:     {",
          "144:         perror_msg(\"stat\");",
          "145:         close(path_fd);",
          "146:         return -1;",
          "147:     }",
          "149:     if (!S_ISREG(path_sb.st_mode) || path_sb.st_nlink > 1)",
          "150:     {",
          "151:         log_notice(\"Path isn't a regular file or has more links (%lu)\", (unsigned long)path_sb.st_nlink);",
          "152:         errno = EINVAL;",
          "153:         close(path_fd);",
          "154:         return -1;",
          "155:     }",
          "157:     if (snprintf(reopen_buf, sizeof(reopen_buf), \"/proc/self/fd/%d\", path_fd) >= sizeof(reopen_buf)) {",
          "158:         error_msg(\"BUG: too long path to a file descriptor\");",
          "159:         abort();",
          "160:     }",
          "162:     const int fd = open(reopen_buf, O_RDONLY);",
          "163:     close(path_fd);",
          "165:     return fd;",
          "166: }",
          "173: static time_t parse_time_file_at(int dir_fd, const char *filename)",
          "176:     int fd = secure_openat_read(dir_fd, filename);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "187: {",
          "189:     {",
          "190:         if (errno != EEXIST)",
          "191:         {",
          "",
          "[Removed Lines]",
          "186: int create_symlink_lockfile(const char* lock_file, const char* pid)",
          "188:     while (symlink(pid, lock_file) != 0)",
          "",
          "[Added Lines]",
          "240: int create_symlink_lockfile_at(int dir_fd, const char* lock_file, const char* pid)",
          "242:     while (symlinkat(pid, dir_fd, lock_file) != 0)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "198:         }",
          "200:         char pid_buf[sizeof(pid_t)*3 + 4];",
          "202:         if (r < 0)",
          "203:         {",
          "204:             if (errno == ENOENT)",
          "",
          "[Removed Lines]",
          "201:         ssize_t r = readlink(lock_file, pid_buf, sizeof(pid_buf) - 1);",
          "",
          "[Added Lines]",
          "255:         ssize_t r = readlinkat(dir_fd, lock_file, pid_buf, sizeof(pid_buf) - 1);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "231:             log(\"Lock file '%s' was locked by process %s, but it crashed?\", lock_file, pid_buf);",
          "232:         }",
          "235:         {",
          "236:             perror_msg(\"Can't remove stale lock file '%s'\", lock_file);",
          "237:             errno = 0;",
          "",
          "[Removed Lines]",
          "234:         if (unlink(lock_file) != 0 && errno != ENOENT)",
          "",
          "[Added Lines]",
          "288:         if (unlinkat(dir_fd, lock_file, /*only files*/0) != 0 && errno != ENOENT)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "243:     return 1;",
          "244: }",
          "246: static const char *dd_check(struct dump_dir *dd)",
          "247: {",
          "253:     if (dd->dd_time < 0)",
          "254:     {",
          "255:         log_debug(\"Missing file: \"FILENAME_TIME);",
          "256:         return FILENAME_TIME;",
          "257:     }",
          "261:     if (!dd->dd_type || (strlen(dd->dd_type) == 0))",
          "262:     {",
          "263:         log_debug(\"Missing or empty file: \"FILENAME_TYPE);",
          "",
          "[Removed Lines]",
          "248:     unsigned dirname_len = strlen(dd->dd_dirname);",
          "249:     char filename_buf[FILENAME_MAX+1];",
          "250:     strcpy(filename_buf, dd->dd_dirname);",
          "251:     strcpy(filename_buf + dirname_len, \"/\"FILENAME_TIME);",
          "252:     dd->dd_time = parse_time_file(filename_buf);",
          "259:     strcpy(filename_buf + dirname_len, \"/\"FILENAME_TYPE);",
          "260:     dd->dd_type = load_text_file(filename_buf, DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE);",
          "",
          "[Added Lines]",
          "300: int create_symlink_lockfile(const char *filename, const char *pid_str)",
          "301: {",
          "302:     return create_symlink_lockfile_at(AT_FDCWD, filename, pid_str);",
          "303: }",
          "307:     dd->dd_time = parse_time_file_at(dd->dd_fd, FILENAME_TIME);",
          "314:     dd->dd_type = load_text_file_at(dd->dd_fd, FILENAME_TYPE, DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "275:     char pid_buf[sizeof(long)*3 + 2];",
          "276:     snprintf(pid_buf, sizeof(pid_buf), \"%lu\", (long)getpid());",
          "283:     unsigned count = NO_TIME_FILE_COUNT;",
          "285:  retry:",
          "286:     while (1)",
          "287:     {",
          "289:         if (r < 0)",
          "291:         if (r > 0 || errno == EALREADY)",
          "",
          "[Removed Lines]",
          "278:     unsigned dirname_len = strlen(dd->dd_dirname);",
          "279:     char lock_buf[dirname_len + sizeof(\"/.lock\")];",
          "280:     strcpy(lock_buf, dd->dd_dirname);",
          "281:     strcpy(lock_buf + dirname_len, \"/.lock\");",
          "288:         int r = create_symlink_lockfile(lock_buf, pid_buf);",
          "",
          "[Added Lines]",
          "337:         int r = create_symlink_lockfile_at(dd->dd_fd, \".lock\", pid_buf);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "312:         if (missing_file)",
          "313:         {",
          "314:             if (dd->owns_lock)",
          "318:             if (--count == 0 || flags & DD_DONT_WAIT_FOR_LOCK)",
          "319:             {",
          "",
          "[Removed Lines]",
          "315:                 xunlink(lock_buf);",
          "317:             log_warning(\"Unlocked '%s' (no or corrupted '%s' file)\", lock_buf, missing_file);",
          "",
          "[Added Lines]",
          "364:                 xunlinkat(dd->dd_fd, \".lock\", /*only files*/0);",
          "366:             log_warning(\"Unlocked '%s' (no or corrupted '%s' file)\", dd->dd_dirname, missing_file);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "333: {",
          "334:     if (dd->locked)",
          "335:     {",
          "341:         if (dd->owns_lock)",
          "344:         dd->owns_lock = 0;",
          "345:         dd->locked = 0;",
          "348:     }",
          "349: }",
          "",
          "[Removed Lines]",
          "336:         unsigned dirname_len = strlen(dd->dd_dirname);",
          "337:         char lock_buf[dirname_len + sizeof(\"/.lock\")];",
          "338:         strcpy(lock_buf, dd->dd_dirname);",
          "339:         strcpy(lock_buf + dirname_len, \"/.lock\");",
          "342:             xunlink(lock_buf);",
          "347:         log_info(\"Unlocked '%s'\", lock_buf);",
          "",
          "[Added Lines]",
          "386:             xunlinkat(dd->dd_fd, \".lock\", /*only files*/0);",
          "391:         log_info(\"Unlocked '%s/.lock'\", dd->dd_dirname);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "352: {",
          "353:     struct dump_dir* dd = (struct dump_dir*)xzalloc(sizeof(struct dump_dir));",
          "354:     dd->dd_time = -1;",
          "355:     return dd;",
          "356: }",
          "359: {",
          "366:     return ret;",
          "367: }",
          "",
          "[Removed Lines]",
          "358: int dd_exist(const struct dump_dir *dd, const char *path)",
          "360:     if (!str_is_correct_filename(path))",
          "361:         error_msg_and_die(\"Cannot test existence. '%s' is not a valid file name\", path);",
          "363:     char *full_path = concat_path_file(dd->dd_dirname, path);",
          "364:     int ret = exist_file_dir(full_path);",
          "365:     free(full_path);",
          "",
          "[Added Lines]",
          "399:     dd->dd_fd = -1;",
          "403: int dd_exist(const struct dump_dir *dd, const char *name)",
          "405:     if (!str_is_correct_filename(name))",
          "406:         error_msg_and_die(\"Cannot test existence. '%s' is not a valid file name\", name);",
          "408:     const int ret = exist_file_dir_at(dd->dd_fd, name);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "372:         return;",
          "374:     dd_unlock(dd);",
          "375:     if (dd->next_dir)",
          "376:     {",
          "377:         closedir(dd->next_dir);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "419:     if (dd->dd_fd >= 0)",
          "420:         close(dd->dd_fd);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "396:     struct dump_dir *dd = dd_init();",
          "398:     dir = dd->dd_dirname = rm_trailing_slashes(dir);",
          "400:     struct stat stat_buf;",
          "402:         goto cant_access;",
          "404:     dd->mode = (stat_buf.st_mode & 0666);",
          "",
          "[Removed Lines]",
          "401:     if (stat(dir, &stat_buf) != 0)",
          "",
          "[Added Lines]",
          "446:     dd->dd_fd = open(dir, O_DIRECTORY | O_NOFOLLOW);",
          "448:     if (dd->dd_fd < 0)",
          "450:     if (fstat(dd->dd_fd, &stat_buf) != 0)",
          "451:         goto cant_access;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "409:         if ((flags & DD_OPEN_READONLY) && errno == EACCES)",
          "410:         {",
          "417:                 if(dd_check(dd) != NULL)",
          "418:                 {",
          "419:                     dd_close(dd);",
          "",
          "[Removed Lines]",
          "413:             if (stat(dir, &stat_buf) == 0",
          "414:              && S_ISDIR(stat_buf.st_mode)",
          "415:              && access(dir, R_OK) == 0",
          "416:             ) {",
          "",
          "[Added Lines]",
          "466:             if (faccessat(dd->dd_fd, \".\", R_OK, AT_SYMLINK_NOFOLLOW) == 0)",
          "467:             {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "456:     if (geteuid() == 0)",
          "457:     {",
          "461:         {",
          "463:             dd_close(dd);",
          "464:             return NULL;",
          "465:         }",
          "",
          "[Removed Lines]",
          "459:         struct stat stat_buf;",
          "460:         if (stat(dir, &stat_buf) != 0 || !S_ISDIR(stat_buf.st_mode))",
          "462:             error_msg(\"Can't stat '%s', or it is not a directory\", dir);",
          "",
          "[Added Lines]",
          "510:         if (fstat(dd->dd_fd, &stat_buf) != 0)",
          "512:             error_msg(\"Can't stat '%s'\", dir);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "556:         error_msg(\"Bad dir name '%s'\", dir);",
          "559:     }",
          "",
          "[Removed Lines]",
          "557:         dd_close(dd);",
          "558:         return NULL;",
          "",
          "[Added Lines]",
          "607:         goto fail;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "571:     if (r != 0)",
          "572:     {",
          "573:         perror_msg(\"Can't create directory '%s'\", dir);",
          "576:     }",
          "579:     {",
          "582:     }",
          "586:     {",
          "587:         perror_msg(\"Can't change mode of '%s'\", dir);",
          "590:     }",
          "592:     dd->dd_uid = (uid_t)-1L;",
          "",
          "[Removed Lines]",
          "574:         dd_close(dd);",
          "575:         return NULL;",
          "578:     if (dd_lock(dd, CREATE_LOCK_USLEEP, /*flags:*/ 0) < 0)",
          "580:         dd_close(dd);",
          "581:         return NULL;",
          "585:     if (chmod(dir, dir_mode) == -1)",
          "588:         dd_close(dd);",
          "589:         return NULL;",
          "",
          "[Added Lines]",
          "623:         goto fail;",
          "626:     dd->dd_fd = open(dd->dd_dirname, O_DIRECTORY | O_NOFOLLOW);",
          "627:     if (dd->dd_fd < 0)",
          "629:         perror_msg(\"Can't open newly created directory '%s'\", dir);",
          "630:         goto fail;",
          "631:     }",
          "633:     struct stat stat_sb;",
          "634:     if (fstat(dd->dd_fd, &stat_sb) < 0)",
          "635:     {",
          "636:         perror_msg(\"stat(%s)\", dd->dd_dirname);",
          "637:         goto fail;",
          "640:     if (dd_lock(dd, CREATE_LOCK_USLEEP, /*flags:*/ 0) < 0)",
          "641:         goto fail;",
          "644:     if (fchmod(dd->dd_fd, dir_mode) == -1)",
          "647:         goto fail;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "628:     }",
          "630:     return dd;",
          "631: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "690: fail:",
          "691:     dd_close(dd);",
          "692:     return NULL;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "638:     if (!dd->locked)",
          "642:     if (r < 0)",
          "643:     {",
          "644:         perror_msg(\"Can't change '%s' ownership to %lu:%lu\", dd->dd_dirname,",
          "",
          "[Removed Lines]",
          "641:     const int r =lchown(dd->dd_dirname, dd->dd_uid, dd->dd_gid);",
          "",
          "[Added Lines]",
          "703:     const int r = fchown(dd->dd_fd, dd->dd_uid, dd->dd_gid);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "755:     if (!dd->locked)",
          "764:     {",
          "804:     }",
          "806: }",
          "809: {",
          "811:     if (!d)",
          "812:     {",
          "",
          "[Removed Lines]",
          "758:     DIR *d = opendir(dd->dd_dirname);",
          "759:     if (!d)",
          "760:         return;",
          "762:     struct dirent *dent;",
          "763:     while ((dent = readdir(d)) != NULL)",
          "766:             continue;",
          "767:         char *full_path = concat_path_file(dd->dd_dirname, dent->d_name);",
          "768:         struct stat statbuf;",
          "769:         if (lstat(full_path, &statbuf) == 0 && S_ISREG(statbuf.st_mode))",
          "770:         {",
          "771:             if ((statbuf.st_mode & 0777) != dd->mode)",
          "772:             {",
          "779:                 int fd = open(full_path, O_RDONLY | O_NOFOLLOW, dd->mode);",
          "780:                 if (fd >= 0)",
          "781:                 {",
          "782:                     if (fchmod(fd, dd->mode) != 0)",
          "783:                     {",
          "784:                         perror_msg(\"Can't change '%s' mode to 0%o\", full_path,",
          "785:                                    (unsigned)dd->mode);",
          "786:                     }",
          "787:                     close(fd);",
          "788:                 }",
          "789:                 else",
          "790:                 {",
          "791:                     perror_msg(\"Can't open regular file '%s'\", full_path);",
          "792:                 }",
          "793:             }",
          "794:             if (statbuf.st_uid != dd->dd_uid || statbuf.st_gid != dd->dd_gid)",
          "795:             {",
          "796:                 if (lchown(full_path, dd->dd_uid, dd->dd_gid) != 0)",
          "797:                 {",
          "798:                     perror_msg(\"Can't change '%s' ownership to %lu:%lu\", full_path,",
          "799:                                (long)dd->dd_uid, (long)dd->dd_gid);",
          "800:                 }",
          "801:             }",
          "802:         }",
          "803:         free(full_path);",
          "805:     closedir(d);",
          "808: static int delete_file_dir(const char *dir, bool skip_lock_file)",
          "810:     DIR *d = opendir(dir);",
          "",
          "[Added Lines]",
          "820:     dd_init_next_file(dd);",
          "821:     char *short_name;",
          "822:     while (dd_get_next_file(dd, &short_name, /*full_name*/ NULL))",
          "825:         int fd = secure_openat_read(dd->dd_fd, short_name);",
          "826:         if (fd < 0)",
          "827:             goto next;",
          "829:         if (fchmod(fd, dd->mode) != 0)",
          "830:             perror_msg(\"Can't change '%s/%s' mode to 0%o\", dd->dd_dirname, short_name,",
          "831:                        (unsigned)dd->mode);",
          "833:         if (fchown(fd, dd->dd_uid, dd->dd_gid) != 0)",
          "834:             perror_msg(\"Can't change '%s/%s' ownership to %lu:%lu\", dd->dd_dirname, short_name,",
          "835:                        (long)dd->dd_uid, (long)dd->dd_gid);",
          "837:         close(fd);",
          "838: next:",
          "839:         free(short_name);",
          "843: static int delete_file_dir(int dir_fd, bool skip_lock_file)",
          "845:     int opendir_fd = dup(dir_fd);",
          "846:     if (opendir_fd < 0)",
          "847:     {",
          "848:         perror_msg(\"delete_file_dir: dup(dir_fd)\");",
          "849:         return -1;",
          "850:     }",
          "852:     lseek(opendir_fd, SEEK_SET, 0);",
          "853:     DIR *d = fdopendir(opendir_fd);",
          "856:         close(opendir_fd);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "833:             unlink_lock_file = true;",
          "834:             continue;",
          "835:         }",
          "838:         {",
          "839:             int err = 0;",
          "840:             if (errno == EISDIR)",
          "841:             {",
          "842:                 errno = 0;",
          "844:             }",
          "845:             if (errno || err)",
          "846:             {",
          "849:                 closedir(d);",
          "850:                 return -1;",
          "851:             }",
          "852:         }",
          "854:     }",
          "",
          "[Removed Lines]",
          "836:         char *full_path = concat_path_file(dir, dent->d_name);",
          "837:         if (unlink(full_path) == -1 && errno != ENOENT)",
          "843:                 err = delete_file_dir(full_path, /*skip_lock_file:*/ false);",
          "847:                 perror_msg(\"Can't remove '%s'\", full_path);",
          "848:                 free(full_path);",
          "853:         free(full_path);",
          "855:     closedir(d);",
          "",
          "[Added Lines]",
          "880:         if (unlinkat(dir_fd, dent->d_name, /*only files*/0) == -1 && errno != ENOENT)",
          "886:                 int subdir_fd = openat(dir_fd, dent->d_name, O_DIRECTORY);",
          "887:                 if (subdir_fd < 0)",
          "888:                 {",
          "889:                     perror_msg(\"Can't open sub-dir'%s'\", dent->d_name);",
          "890:                     closedir(d);",
          "891:                     return -1;",
          "892:                 }",
          "893:                 else",
          "894:                 {",
          "895:                     err = delete_file_dir(subdir_fd, /*skip_lock_file:*/ false);",
          "896:                     close(subdir_fd);",
          "897:                     if (err == 0)",
          "898:                         unlinkat(dir_fd, dent->d_name, AT_REMOVEDIR);",
          "899:                 }",
          "903:                 perror_msg(\"Can't remove '%s'\", dent->d_name);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "862:     if (unlink_lock_file)",
          "886: }",
          "888: int dd_delete(struct dump_dir *dd)",
          "",
          "[Removed Lines]",
          "863:     {",
          "864:         char *full_path = concat_path_file(dir, \".lock\");",
          "865:         xunlink(full_path);",
          "866:         free(full_path);",
          "868:         unsigned cnt = RMDIR_FAIL_COUNT;",
          "869:         do {",
          "870:             if (rmdir(dir) == 0)",
          "871:                 return 0;",
          "878:             usleep(RMDIR_FAIL_USLEEP);",
          "879:         } while (--cnt != 0);",
          "880:     }",
          "882:     int r = rmdir(dir);",
          "883:     if (r)",
          "884:         perror_msg(\"Can't remove directory '%s'\", dir);",
          "885:     return r;",
          "",
          "[Added Lines]",
          "916:         xunlinkat(dir_fd, \".lock\", /*only files*/0);",
          "918:     closedir(d);",
          "920:     return 0;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "893:         return -1;",
          "894:     }",
          "898:     dd_close(dd);",
          "900: }",
          "902: int dd_chown(struct dump_dir *dd, uid_t new_uid)",
          "",
          "[Removed Lines]",
          "896:     int r = delete_file_dir(dd->dd_dirname, /*skip_lock_file:*/ true);",
          "899:     return r;",
          "",
          "[Added Lines]",
          "931:     if (delete_file_dir(dd->dd_fd, /*skip_lock_file:*/ true) != 0)",
          "932:     {",
          "933:         perror_msg(\"Can't remove contents of directory '%s'\", dd->dd_dirname);",
          "934:         return -2;",
          "935:     }",
          "937:     unsigned cnt = RMDIR_FAIL_COUNT;",
          "938:     do {",
          "939:         if (rmdir(dd->dd_dirname) == 0)",
          "940:             break;",
          "947:         usleep(RMDIR_FAIL_USLEEP);",
          "948:     } while (--cnt != 0);",
          "950:     if (cnt == 0)",
          "951:     {",
          "952:         perror_msg(\"Can't remove directory '%s'\", dd->dd_dirname);",
          "953:         return -3;",
          "954:     }",
          "958:     return 0;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "907:     struct stat statbuf;",
          "909:     {",
          "910:         perror_msg(\"stat('%s')\", dd->dd_dirname);",
          "911:         return 1;",
          "",
          "[Removed Lines]",
          "908:     if (!(stat(dd->dd_dirname, &statbuf) == 0 && S_ISDIR(statbuf.st_mode)))",
          "",
          "[Added Lines]",
          "967:     if (fstat(dd->dd_fd, &statbuf) != 0)",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "926:     gid_t groups_gid = pw->pw_gid;",
          "927: #endif",
          "930:     if (chown_res)",
          "932:     else",
          "933:     {",
          "934:         dd_init_next_file(dd);",
          "937:         {",
          "940:             if (chown_res)",
          "943:         }",
          "944:     }",
          "946:     return chown_res;",
          "947: }",
          "950: {",
          "952:     if (fd == -1)",
          "953:     {",
          "954:         if (!(flags & DD_FAIL_QUIETLY_ENOENT))",
          "",
          "[Removed Lines]",
          "929:     int chown_res = lchown(dd->dd_dirname, owners_uid, groups_gid);",
          "931:         perror_msg(\"lchown('%s')\", dd->dd_dirname);",
          "935:         char *full_name;",
          "936:         while (chown_res == 0 && dd_get_next_file(dd, /*short_name*/ NULL, &full_name))",
          "938:             log_debug(\"chowning %s\", full_name);",
          "939:             chown_res = lchown(full_name, owners_uid, groups_gid);",
          "941:                 perror_msg(\"lchown('%s')\", full_name);",
          "942:             free(full_name);",
          "949: static char *load_text_file(const char *path, unsigned flags)",
          "951:     int fd = open(path, O_RDONLY | ((flags & DD_OPEN_FOLLOW) ? 0 : O_NOFOLLOW));",
          "",
          "[Added Lines]",
          "988:     int chown_res = fchown(dd->dd_fd, owners_uid, groups_gid);",
          "990:         perror_msg(\"fchown('%s')\", dd->dd_dirname);",
          "994:         char *short_name;",
          "995:         while (chown_res == 0 && dd_get_next_file(dd, &short_name, /*full_name*/ NULL))",
          "998:             int fd = secure_openat_read(dd->dd_fd, short_name);",
          "999:             if (fd < 0)",
          "1000:                 goto next;",
          "1002:             log_debug(\"chowning %s\", short_name);",
          "1004:             chown_res = fchown(fd, owners_uid, groups_gid);",
          "1006:                 perror_msg(\"fchownat('%s')\", short_name);",
          "1008:             close(fd);",
          "1009: next:",
          "1010:             free(short_name);",
          "1017: static char *load_text_from_file_descriptor(int fd, const char *path, int flags)",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1003:     return strbuf_free_nobuf(buf_content);",
          "1004: }",
          "1006: static void copy_file_from_chroot(struct dump_dir* dd, const char *name, const char *chroot_dir, const char *file_path)",
          "1007: {",
          "1008:     char *chrooted_name = concat_path_file(chroot_dir, file_path);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1073: static char *load_text_file_at(int dir_fd, const char *name, unsigned flags)",
          "1074: {",
          "1075:     assert(name[0] != '/');",
          "1077:     const int fd = openat(dir_fd, name, O_RDONLY | ((flags & DD_OPEN_FOLLOW) ? 0 : O_NOFOLLOW));",
          "1078:     return load_text_from_file_descriptor(fd, name, flags);",
          "1079: }",
          "1081: static char *load_text_file(const char *path, unsigned flags)",
          "1082: {",
          "1083:     const int fd = open(path, O_RDONLY | ((flags & DD_OPEN_FOLLOW) ? 0 : O_NOFOLLOW));",
          "1084:     return load_text_from_file_descriptor(fd, path, flags);",
          "1085: }",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1016:     }",
          "1017: }",
          "1020: {",
          "1024:     if (fd < 0)",
          "1025:     {",
          "1027:         return false;",
          "1028:     }",
          "",
          "[Removed Lines]",
          "1019: static bool save_binary_file(const char *path, const char* data, unsigned size, uid_t uid, gid_t gid, mode_t mode)",
          "1022:     unlink(path);",
          "1023:     int fd = open(path, O_WRONLY | O_TRUNC | O_CREAT | O_NOFOLLOW, mode);",
          "1026:         perror_msg(\"Can't open file '%s'\", path);",
          "",
          "[Added Lines]",
          "1100: static bool save_binary_file_at(int dir_fd, const char *name, const char* data, unsigned size, uid_t uid, gid_t gid, mode_t mode)",
          "1102:     assert(name[0] != '/');",
          "1105:     unlinkat(dir_fd, name, /*remove only files*/0);",
          "1106:     int fd = openat(dir_fd, name, O_WRONLY | O_EXCL | O_CREAT | O_NOFOLLOW, mode);",
          "1109:         perror_msg(\"Can't open file '%s'\", name);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1031:     {",
          "1032:         if (fchown(fd, uid, gid) == -1)",
          "1033:         {",
          "1035:         }",
          "1036:     }",
          "",
          "[Removed Lines]",
          "1034:             perror_msg(\"Can't change '%s' ownership to %lu:%lu\", path, (long)uid, (long)gid);",
          "",
          "[Added Lines]",
          "1117:             perror_msg(\"Can't change '%s' ownership to %lu:%lu\", name, (long)uid, (long)gid);",
          "1118:             close(fd);",
          "1119:             return false;",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1044:     if (fchmod(fd, mode) == -1)",
          "1045:     {",
          "1047:     }",
          "1049:     unsigned r = full_write(fd, data, size);",
          "1050:     close(fd);",
          "1051:     if (r != size)",
          "1052:     {",
          "1054:         return false;",
          "1055:     }",
          "",
          "[Removed Lines]",
          "1046:         perror_msg(\"Can't change mode of '%s'\", path);",
          "1053:         error_msg(\"Can't save file '%s'\", path);",
          "",
          "[Added Lines]",
          "1131:         perror_msg(\"Can't change mode of '%s'\", name);",
          "1132:         close(fd);",
          "1133:         return false;",
          "1140:         error_msg(\"Can't save file '%s'\", name);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1075:     if (strcmp(name, \"release\") == 0)",
          "1076:         name = FILENAME_OS_RELEASE;",
          "1083: }",
          "1085: char* dd_load_text(const struct dump_dir *dd, const char *name)",
          "",
          "[Removed Lines]",
          "1078:     char *full_path = concat_path_file(dd->dd_dirname, name);",
          "1079:     char *ret = load_text_file(full_path, flags);",
          "1080:     free(full_path);",
          "1082:     return ret;",
          "",
          "[Added Lines]",
          "1165:     return load_text_file_at(dd->dd_fd, name, flags);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1095:     if (!str_is_correct_filename(name))",
          "1096:         error_msg_and_die(\"Cannot save text. '%s' is not a valid file name\", name);",
          "1101: }",
          "1103: void dd_save_binary(struct dump_dir* dd, const char* name, const char* data, unsigned size)",
          "",
          "[Removed Lines]",
          "1098:     char *full_path = concat_path_file(dd->dd_dirname, name);",
          "1099:     save_binary_file(full_path, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);",
          "1100:     free(full_path);",
          "",
          "[Added Lines]",
          "1181:     save_binary_file_at(dd->dd_fd, name, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1108:     if (!str_is_correct_filename(name))",
          "1109:         error_msg_and_die(\"Cannot save binary. '%s' is not a valid file name\", name);",
          "1114: }",
          "1116: long dd_get_item_size(struct dump_dir *dd, const char *name)",
          "",
          "[Removed Lines]",
          "1111:     char *full_path = concat_path_file(dd->dd_dirname, name);",
          "1112:     save_binary_file(full_path, data, size, dd->dd_uid, dd->dd_gid, dd->mode);",
          "1113:     free(full_path);",
          "",
          "[Added Lines]",
          "1192:     save_binary_file_at(dd->dd_fd, name, data, size, dd->dd_uid, dd->dd_gid, dd->mode);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1119:         error_msg_and_die(\"Cannot get item size. '%s' is not a valid file name\", name);",
          "1121:     long size = -1;",
          "1123:     struct stat statbuf;",
          "1126:         size = statbuf.st_size;",
          "1127:     else",
          "1128:     {",
          "1129:         if (errno == ENOENT)",
          "1130:             size = 0;",
          "1131:         else",
          "1133:     }",
          "1137:     return size;",
          "1138: }",
          "",
          "[Removed Lines]",
          "1122:     char *iname = concat_path_file(dd->dd_dirname, name);",
          "1125:     if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))",
          "1132:             perror_msg(\"Can't get size of file '%s'\", iname);",
          "1135:     free(iname);",
          "",
          "[Added Lines]",
          "1202:     int r = fstatat(dd->dd_fd, name, &statbuf, AT_SYMLINK_NOFOLLOW);",
          "1204:     if (r == 0 && S_ISREG(statbuf.st_mode))",
          "1211:             perror_msg(\"Can't get size of file '%s'\", name);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1145:     if (!str_is_correct_filename(name))",
          "1146:         error_msg_and_die(\"Cannot delete item. '%s' is not a valid file name\", name);",
          "1151:     if (res < 0)",
          "1152:     {",
          "1153:         if (errno == ENOENT)",
          "1154:             errno = res = 0;",
          "1155:         else",
          "1157:     }",
          "1160:     return res;",
          "1161: }",
          "",
          "[Removed Lines]",
          "1148:     char *path = concat_path_file(dd->dd_dirname, name);",
          "1149:     int res = unlink(path);",
          "1156:             perror_msg(\"Can't delete file '%s'\", path);",
          "1159:     free(path);",
          "",
          "[Added Lines]",
          "1225:     int res = unlinkat(dd->dd_fd, name, /*only files*/0);",
          "1232:             perror_msg(\"Can't delete file '%s'\", name);",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1164: {",
          "1168:     if (dd->next_dir)",
          "1169:         closedir(dd->next_dir);",
          "1172:     if (!dd->next_dir)",
          "1173:     {",
          "1174:         error_msg(\"Can't open directory '%s'\", dd->dd_dirname);",
          "1175:     }",
          "1177:     return dd->next_dir;",
          "",
          "[Removed Lines]",
          "1171:     dd->next_dir = opendir(dd->dd_dirname);",
          "",
          "[Added Lines]",
          "1242:     int opendir_fd = dup(dd->dd_fd);",
          "1243:     if (opendir_fd < 0)",
          "1244:     {",
          "1245:         perror_msg(\"dd_init_next_file: dup(dd_fd)\");",
          "1246:         return NULL;",
          "1247:     }",
          "1252:     lseek(opendir_fd, SEEK_SET, 0);",
          "1253:     dd->next_dir = fdopendir(opendir_fd);",
          "1257:         close(opendir_fd);",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1185:     struct dirent *dent;",
          "1186:     while ((dent = readdir(dd->next_dir)) != NULL)",
          "1187:     {",
          "1189:         {",
          "1190:             if (short_name)",
          "",
          "[Removed Lines]",
          "1188:         if (is_regular_file(dent, dd->dd_dirname))",
          "",
          "[Added Lines]",
          "1271:         if (is_regular_file_at(dent, dd->dd_fd))",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1362:     if (!str_is_correct_filename(name))",
          "1363:         error_msg_and_die(\"Cannot test existence. '%s' is not a valid file name\", name);",
          "1370:     if (copied < 0)",
          "1372:     else",
          "1373:         log_debug(\"copied %li bytes\", (unsigned long)copied);",
          "1376:     return copied < 0;",
          "1377: }",
          "",
          "[Removed Lines]",
          "1365:     char *dest = concat_path_file(dd->dd_dirname, name);",
          "1367:     log_debug(\"copying '%s' to '%s'\", source_path, dest);",
          "1369:     off_t copied = copy_file(source_path, dest, DEFAULT_DUMP_DIR_MODE | S_IROTH);",
          "1371:         error_msg(\"Can't copy %s to %s\", source_path, dest);",
          "1375:     free(dest);",
          "",
          "[Added Lines]",
          "1449:     log_debug(\"copying '%s' to '%s' at '%s'\", source_path, name, dd->dd_dirname);",
          "1451:     unlinkat(dd->dd_fd, name, /*remove only files*/0);",
          "1452:     off_t copied = copy_file_ext_at(source_path, dd->dd_fd, name, DEFAULT_DUMP_DIR_MODE,",
          "1453:             dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_TRUNC | O_EXCL | O_CREAT);",
          "1456:         error_msg(\"Can't copy %s to %s at '%s'\", source_path, name, dd->dd_dirname);",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1381:     if (!str_is_correct_filename(name))",
          "1382:         error_msg_and_die(\"Cannot test existence. '%s' is not a valid file name\", name);",
          "1389:     if (copied != 0)",
          "1391:     else",
          "1395:     return copied < 0;",
          "1397: }",
          "",
          "[Removed Lines]",
          "1384:     char *dest = concat_path_file(dd->dd_dirname, name);",
          "1386:     log_debug(\"unpacking '%s' to '%s'\", source_path, dest);",
          "1388:     off_t copied = decompress_file(source_path, dest, DEFAULT_DUMP_DIR_MODE | S_IROTH);",
          "1390:         error_msg(\"Can't copy %s to %s\", source_path, dest);",
          "1392:         log_debug(\"unpackaged file '%s'\", dest);",
          "1394:     free(dest);",
          "",
          "[Added Lines]",
          "1468:     log_debug(\"unpacking '%s' to '%s' at '%s'\", source_path, name, dd->dd_dirname);",
          "1470:     unlinkat(dd->dd_fd, name, /*remove only files*/0);",
          "1471:     off_t copied = decompress_file_ext_at(source_path, dd->dd_fd, name, DEFAULT_DUMP_DIR_MODE,",
          "1472:             dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_TRUNC | O_EXCL | O_CREAT);",
          "1475:         error_msg(\"Can't copy %s to %s at '%s'\", source_path, name, dd->dd_dirname);",
          "1477:         log_debug(\"unpackaged file '%s'\", source_path);",
          "",
          "---------------"
        ],
        "src/lib/problem_data.c||src/lib/problem_data.c": [
          "File: src/lib/problem_data.c -> src/lib/problem_data.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "319:     FILENAME_OS_RELEASE,",
          "320:     NULL",
          "321: };",
          "323: {",
          "330:     if (fd < 0)",
          "",
          "[Removed Lines]",
          "322: static char* is_text_file(const char *name, ssize_t *sz)",
          "329:     int fd = open(name, O_RDONLY);",
          "",
          "[Added Lines]",
          "322: static char* is_text_file_at(int dir_fd, const char *name, ssize_t *sz)",
          "329:     int fd = secure_openat_read(dir_fd, name);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "439:         }",
          "441:         ssize_t sz = 4*1024;",
          "443:         if (!text || text == HUGE_TEXT)",
          "444:         {",
          "445:             int flag = !text ? CD_FLAG_BIN : (CD_FLAG_BIN+CD_FLAG_BIGTXT);",
          "",
          "[Removed Lines]",
          "442:         char *text = is_text_file(full_name, &sz);",
          "",
          "[Added Lines]",
          "442:         char *text = is_text_file_at(dd->dd_fd, short_name, &sz);",
          "",
          "---------------"
        ],
        "src/lib/xfuncs.c||src/lib/xfuncs.c": [
          "File: src/lib/xfuncs.c -> src/lib/xfuncs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "331:     return xopen3(pathname, flags, 0666);",
          "332: }",
          "334: void xunlink(const char *pathname)",
          "335: {",
          "336:     if (unlink(pathname))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "334: void xunlinkat(int dir_fd, const char *pathname, int flags)",
          "335: {",
          "336:     if (unlinkat(dir_fd, pathname, flags))",
          "337:         perror_msg_and_die(\"Can't remove file '%s'\", pathname);",
          "338: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "363: {",
          "364:     if (dent->d_type == DT_REG)",
          "365:         return 1;",
          "366:     if (dent->d_type != DT_UNKNOWN)",
          "367:         return 0;",
          "370:     struct stat statbuf;",
          "374:     return r == 0 && S_ISREG(statbuf.st_mode);",
          "375: }",
          "379: bool dot_or_dotdot(const char *filename)",
          "",
          "[Removed Lines]",
          "362: int is_regular_file(struct dirent *dent, const char *dirname)",
          "369:     char *fullname = xasprintf(\"%s/%s\", dirname, dent->d_name);",
          "371:     int r = lstat(fullname, &statbuf);",
          "372:     free(fullname);",
          "",
          "[Added Lines]",
          "368: int is_regular_file_at(struct dirent *dent, int dir_fd)",
          "376:     int r = fstatat(dir_fd, dent->d_name, &statbuf, AT_SYMLINK_NOFOLLOW);",
          "381: int is_regular_file(struct dirent *dent, const char *dirname)",
          "382: {",
          "383:     int dir_fd = open(dirname, O_DIRECTORY);",
          "384:     if (dir_fd < 0)",
          "385:         return 0;",
          "386:     int r = is_regular_file_at(dent, dir_fd);",
          "387:     close(dir_fd);",
          "388:     return r;",
          "389: }",
          "",
          "---------------"
        ],
        "tests/dump_dir.at||tests/dump_dir.at": [
          "File: tests/dump_dir.at -> tests/dump_dir.at",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: AT_BANNER([dump_dir])",
          "5: ## -------------- ##",
          "6: ## recursive_lock ##",
          "7: ## -------------- ##",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: ## --------- ##",
          "6: ## dd_sanity ##",
          "7: ## --------- ##",
          "9: AT_TESTFUN([dd_sanity],",
          "10: [[",
          "11: #include \"internal_libreport.h\"",
          "12: #include <errno.h>",
          "13: #include <assert.h>",
          "15: void validate_dump_dir_contents(struct dump_dir *dd)",
          "16: {",
          "17:     int items = 0;",
          "18:     assert(dd_exist(dd, FILENAME_TIME));",
          "19:     ++items;",
          "21:     assert(dd_exist(dd, FILENAME_KERNEL));",
          "22:     ++items;",
          "24:     assert(dd_exist(dd, FILENAME_HOSTNAME));",
          "25:     ++items;",
          "27:     assert(dd_exist(dd, FILENAME_ARCHITECTURE));",
          "28:     ++items;",
          "30:     assert(dd_exist(dd, FILENAME_OS_INFO));",
          "31:     ++items;",
          "33:     assert(dd_exist(dd, FILENAME_OS_RELEASE));",
          "34:     ++items;",
          "36:     assert(dd_exist(dd, FILENAME_OS_RELEASE));",
          "37:     ++items;",
          "39:     assert(dd_exist(dd, FILENAME_TYPE));",
          "40:     ++items;",
          "42:     assert(dd_exist(dd, FILENAME_LAST_OCCURRENCE));",
          "43:     ++items;",
          "45:     assert(dd_exist(dd, \"at_test_text\"));",
          "46:     assert(dd_get_item_size(dd, \"at_test_text\") == 3);",
          "47:     ++items;",
          "49:     assert(dd_exist(dd, \"at_test_binary\"));",
          "50:     assert(dd_get_item_size(dd, \"at_test_binary\") == 4);",
          "51:     ++items;",
          "53:     assert(dd_exist(dd, \"at_test_services\"));",
          "54:     ++items;",
          "56:     dd_save_text(dd, \"at_test_to_delete\", \"deleted\");",
          "57:     assert(dd_exist(dd, \"at_test_to_delete\"));",
          "58:     dd_delete_item(dd, \"at_test_to_delete\");",
          "59:     assert(!dd_exist(dd, \"at_test_to_delete\"));",
          "61:     DIR *d1 = dd_init_next_file(dd);",
          "62:     assert(d1 != NULL);",
          "64:     int counter = 0;",
          "65:     char *short_name, *full_name;",
          "66:     while (dd_get_next_file(dd, &short_name, &full_name))",
          "67:     {",
          "68:         ++counter;",
          "71:         printf(\"Iter = %s\\n\", short_name);",
          "73:         assert(short_name != NULL);",
          "74:         assert(full_name != NULL);",
          "75:         assert(strcmp(short_name, strrchr(full_name, '/') + 1) == 0);",
          "76:         assert(strncmp(dd->dd_dirname, full_name, strlen(dd->dd_dirname)) == 0);",
          "77:         assert(full_name[strlen(dd->dd_dirname)] == '/');",
          "78:     }",
          "80:     printf(\"Items = %d, Counter = %d\\n\", items, counter);",
          "81:     assert(items == counter);",
          "83:     DIR *d2 = dd_init_next_file(dd);",
          "84:     assert(d2 != NULL);",
          "86:     while (dd_get_next_file(dd, &short_name, &full_name))",
          "87:         --counter;",
          "89:     assert(counter == 0);",
          "90: }",
          "92: int main(int argc, char **argv)",
          "93: {",
          "94:     g_verbose = 3;",
          "96:     char template[] = \"/tmp/XXXXXX/dump_dir\";",
          "98:     char *last_slash = strrchr(template, '/');",
          "101:     if (mkdtemp(template) == NULL) {",
          "102:         perror(\"mkdtemp()\");",
          "103:         return EXIT_FAILURE;",
          "104:     }",
          "108:     printf(\"Dump dir path: %s\\n\", template);",
          "110:     fprintf(stderr, \"Create new dump directory\\n\");",
          "111:     struct dump_dir *dd = dd_create(template, (uid_t)-1, 0640);",
          "112:     assert(dd != NULL || !\"Cannot create new dump directory\");",
          "114:     dd_create_basic_files(dd, geteuid(), NULL);",
          "115:     dd_save_text(dd, FILENAME_TYPE, \"attest\");",
          "117:     dd_save_text(dd, \"at_test_text\", \"foo\");",
          "118:     assert(dd_exist(dd, \"at_test_text\"));",
          "120:     dd_save_binary(dd, \"at_test_binary\", \"blah\", 4);",
          "121:     assert(dd_exist(dd, \"at_test_binary\"));",
          "123:     dd_copy_file(dd, \"at_test_services\", \"/etc/services\");",
          "125:     fprintf(stderr, \"Test newly created dump directory\\n\");",
          "126:     validate_dump_dir_contents(dd);",
          "127:     dd_close(dd);",
          "130:     fprintf(stderr, \"Test opened dump directory\\n\");",
          "131:     dd = dd_opendir(template, /*for writing*/0);",
          "132:     assert(dd != NULL || !\"Cannot open the dump directory\");",
          "133:     validate_dump_dir_contents(dd);",
          "134:     dd_close(dd);",
          "137:     fprintf(stderr, \"Test renamed dump directory\\n\");",
          "138:     dd = dd_opendir(template, /*for writing*/0);",
          "139:     assert(dd != NULL || !\"Cannot open the dump directory second time\");",
          "142:     assert(dd_rename(dd, template) == 0 || !\"Cannot rename the dump directory\");",
          "144:     validate_dump_dir_contents(dd);",
          "145:     dd_close(dd);",
          "148:     fprintf(stderr, \"Test opened renamed dump directory\\n\");",
          "149:     assert(dd != NULL || !\"Cannot open the renamed dump directory\");",
          "150:     dd = dd_opendir(template, /*for writing*/0);",
          "151:     validate_dump_dir_contents(dd);",
          "153:     assert(dd_delete(dd) == 0);",
          "156:     assert(rmdir(template) == 0);",
          "157:     return EXIT_SUCCESS;",
          "158: }",
          "159: ]])",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2013-7011",
  "cve_desc": "The read_header function in libavcodec/ffv1dec.c in FFmpeg before 2.1 does not prevent changes to global parameters, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted FFV1 data.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "547d690d676064069d44703a1917e0dab7e33445",
  "patch_info": {
    "commit_hash": "547d690d676064069d44703a1917e0dab7e33445",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/547d690d676064069d44703a1917e0dab7e33445",
    "files": [
      "libavcodec/ffv1dec.c"
    ],
    "message": "ffv1dec: check that global parameters dont change in version 0/1\n\nSuch changes are not allowed nor supported\n\nFixes Ticket2906\n\nFound-by: ami_stuff\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
    "before_after_code_files": [
      "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
    ]
  },
  "patch_diff": {
    "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c": [
      "File: libavcodec/ffv1dec.c -> libavcodec/ffv1dec.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "580:     memset(state, 128, sizeof(state));",
      "582:     if (f->version < 2) {",
      "583:         unsigned v= get_symbol(c, state, 0);",
      "584:         if (v >= 2) {",
      "585:             av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "583:         int chroma_planes, chroma_h_shift, chroma_v_shift, transparency;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "597:         if (f->version > 0)",
      "598:             f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);",
      "604:         f->plane_count    = 2 + f->transparency;",
      "605:     }",
      "",
      "[Removed Lines]",
      "600:         f->chroma_planes  = get_rac(c, state);",
      "601:         f->chroma_h_shift = get_symbol(c, state, 0);",
      "602:         f->chroma_v_shift = get_symbol(c, state, 0);",
      "603:         f->transparency   = get_rac(c, state);",
      "",
      "[Added Lines]",
      "601:         chroma_planes  = get_rac(c, state);",
      "602:         chroma_h_shift = get_symbol(c, state, 0);",
      "603:         chroma_v_shift = get_symbol(c, state, 0);",
      "604:         transparency   = get_rac(c, state);",
      "606:         if (f->plane_count) {",
      "607:             if (   chroma_planes != f->chroma_planes",
      "608:                 || chroma_h_shift!= f->chroma_h_shift",
      "609:                 || chroma_v_shift!= f->chroma_v_shift",
      "610:                 || transparency  != f->transparency) {",
      "611:                 av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");",
      "612:                 return AVERROR_INVALIDDATA;",
      "613:             }",
      "614:         }",
      "616:         f->chroma_planes  = chroma_planes;",
      "617:         f->chroma_h_shift = chroma_h_shift;",
      "618:         f->chroma_v_shift = chroma_v_shift;",
      "619:         f->transparency   = transparency;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "71f7b22dba60524b2285643ae0b49d8f64977129",
      "candidate_info": {
        "commit_hash": "71f7b22dba60524b2285643ae0b49d8f64977129",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/71f7b22dba60524b2285643ae0b49d8f64977129",
        "files": [
          "libavcodec/Makefile",
          "libavcodec/ffv1.c",
          "libavcodec/ffv1.h",
          "libavcodec/ffv1dec.c",
          "libavcodec/ffv1enc.c"
        ],
        "message": "ffv1: split decoder and encoder",
        "before_after_code_files": [
          "libavcodec/ffv1.c||libavcodec/ffv1.c",
          "libavcodec/ffv1.h||libavcodec/ffv1.h",
          "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c",
          "libavcodec/ffv1enc.c||libavcodec/ffv1enc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
          ],
          "candidate": [
            "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/ffv1.c||libavcodec/ffv1.c": [
          "File: libavcodec/ffv1.c -> libavcodec/ffv1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: #include \"rangecoder.h\"",
          "34: #include \"golomb.h\"",
          "35: #include \"mathops.h\"",
          "46:      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,",
          "47:      1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,",
          "48:      1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,",
          "",
          "[Removed Lines]",
          "37: #define MAX_PLANES 4",
          "38: #define CONTEXT_SIZE 32",
          "40: #define MAX_QUANT_TABLES 8",
          "41: #define MAX_CONTEXT_INPUTS 5",
          "43: extern const uint8_t ff_log2_run[41];",
          "45: static const int8_t quant5_10bit[256] = {",
          "",
          "[Added Lines]",
          "36: #include \"ffv1.h\"",
          "38: const int8_t ffv1_quant5_10bit[256] = {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "61:     -1, -1, -1, -1, -1, -1, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0,",
          "62: };",
          "65:      0,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "66:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "67:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,",
          "",
          "[Removed Lines]",
          "64: static const int8_t quant5[256] = {",
          "",
          "[Added Lines]",
          "57: const int8_t ffv1_quant5[256] = {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "80:     -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -1, -1, -1,",
          "81: };",
          "84:      0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,",
          "85:      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,",
          "86:      3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,",
          "",
          "[Removed Lines]",
          "83: static const int8_t quant9_10bit[256] = {",
          "",
          "[Added Lines]",
          "76: const int8_t ffv1_quant9_10bit[256] = {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "99:     -2, -2, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -0, -0, -0, -0,",
          "100: };",
          "103:      0,  1,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,",
          "104:      4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,",
          "105:      4,  4,  4,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,",
          "",
          "[Removed Lines]",
          "102: static const int8_t quant11[256] = {",
          "",
          "[Added Lines]",
          "95: const int8_t ffv1_quant11[256] = {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "118:     -4, -4, -4, -4, -4, -3, -3, -3, -3, -3, -3, -3, -2, -2, -2, -1,",
          "119: };",
          "122:       0,  10,  10,  10,  10,  16,  16,  16,  28,  16,  16,  29,  42,  49,  20,  49,",
          "123:      59,  25,  26,  26,  27,  31,  33,  33,  33,  34,  34,  37,  67,  38,  39,  39,",
          "124:      40,  40,  41,  79,  43,  44,  45,  45,  48,  48,  64,  50,  51,  52,  88,  52,",
          "",
          "[Removed Lines]",
          "121: static const uint8_t ver2_state[256] = {",
          "",
          "[Added Lines]",
          "114: const uint8_t ffv1_ver2_state[256] = {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "137:     241, 243, 242, 244, 245, 246, 247, 248, 249, 250, 251, 252, 252, 253, 254, 255,",
          "138: };",
          "695: {",
          "696:     FFV1Context *s = avctx->priv_data;",
          "",
          "[Removed Lines]",
          "140: typedef struct VlcState {",
          "141:     int16_t drift;",
          "142:     uint16_t error_sum;",
          "143:     int8_t bias;",
          "144:     uint8_t count;",
          "145: } VlcState;",
          "147: typedef struct PlaneContext {",
          "148:     int16_t quant_table[MAX_CONTEXT_INPUTS][256];",
          "149:     int quant_table_index;",
          "150:     int context_count;",
          "151:     uint8_t (*state)[CONTEXT_SIZE];",
          "152:     VlcState *vlc_state;",
          "153:     uint8_t interlace_bit_state[2];",
          "154: } PlaneContext;",
          "156: #define MAX_SLICES 256",
          "158: typedef struct FFV1Context {",
          "159:     AVCodecContext *avctx;",
          "160:     RangeCoder c;",
          "161:     GetBitContext gb;",
          "162:     PutBitContext pb;",
          "163:     uint64_t rc_stat[256][2];",
          "164:     uint64_t (*rc_stat2[MAX_QUANT_TABLES])[32][2];",
          "165:     int version;",
          "166:     int width, height;",
          "167:     int chroma_h_shift, chroma_v_shift;",
          "168:     int flags;",
          "169:     int picture_number;",
          "170:     AVFrame picture;",
          "171:     int plane_count;",
          "172:     int ac;     // 1 = range coder <-> 0 = golomb rice",
          "173:     PlaneContext plane[MAX_PLANES];",
          "174:     int16_t quant_table[MAX_CONTEXT_INPUTS][256];",
          "175:     int16_t quant_tables[MAX_QUANT_TABLES][MAX_CONTEXT_INPUTS][256];",
          "176:     int context_count[MAX_QUANT_TABLES];",
          "177:     uint8_t state_transition[256];",
          "178:     uint8_t (*initial_states[MAX_QUANT_TABLES])[32];",
          "179:     int run_index;",
          "180:     int colorspace;",
          "181:     int16_t *sample_buffer;",
          "182:     int gob_count;",
          "184:     int quant_table_count;",
          "186:     DSPContext dsp;",
          "188:     struct FFV1Context *slice_context[MAX_SLICES];",
          "189:     int slice_count;",
          "190:     int num_v_slices;",
          "191:     int num_h_slices;",
          "192:     int slice_width;",
          "193:     int slice_height;",
          "194:     int slice_x;",
          "195:     int slice_y;",
          "196: } FFV1Context;",
          "198: static av_always_inline int fold(int diff, int bits)",
          "199: {",
          "200:     if (bits == 8)",
          "201:         diff = (int8_t)diff;",
          "202:     else {",
          "203:         diff +=  1 << (bits  - 1);",
          "204:         diff &= (1 <<  bits) - 1;",
          "205:         diff -=  1 << (bits  - 1);",
          "206:     }",
          "208:     return diff;",
          "209: }",
          "211: static inline int predict(int16_t *src, int16_t *last)",
          "212: {",
          "213:     const int LT = last[-1];",
          "214:     const int T  = last[0];",
          "215:     const int L  = src[-1];",
          "217:     return mid_pred(L, L + T - LT, T);",
          "218: }",
          "220: static inline int get_context(PlaneContext *p, int16_t *src,",
          "221:                               int16_t *last, int16_t *last2)",
          "222: {",
          "223:     const int LT = last[-1];",
          "224:     const int T  = last[0];",
          "225:     const int RT = last[1];",
          "226:     const int L  = src[-1];",
          "228:     if (p->quant_table[3][127]) {",
          "229:         const int TT = last2[0];",
          "230:         const int LL = src[-2];",
          "231:         return p->quant_table[0][(L - LT) & 0xFF] +",
          "232:                p->quant_table[1][(LT - T) & 0xFF] +",
          "233:                p->quant_table[2][(T - RT) & 0xFF] +",
          "234:                p->quant_table[3][(LL - L) & 0xFF] +",
          "235:                p->quant_table[4][(TT - T) & 0xFF];",
          "236:     } else",
          "237:         return p->quant_table[0][(L - LT) & 0xFF] +",
          "238:                p->quant_table[1][(LT - T) & 0xFF] +",
          "239:                p->quant_table[2][(T - RT) & 0xFF];",
          "240: }",
          "242: static void find_best_state(uint8_t best_state[256][256],",
          "243:                             const uint8_t one_state[256])",
          "244: {",
          "245:     int i, j, k, m;",
          "246:     double l2tab[256];",
          "248:     for (i = 1; i < 256; i++)",
          "249:         l2tab[i] = log2(i / 256.0);",
          "251:     for (i = 0; i < 256; i++) {",
          "252:         double best_len[256];",
          "253:         double p = i / 256.0;",
          "255:         for (j = 0; j < 256; j++)",
          "256:             best_len[j] = 1 << 30;",
          "258:         for (j = FFMAX(i - 10, 1); j < FFMIN(i + 11, 256); j++) {",
          "259:             double occ[256] = { 0 };",
          "260:             double len      = 0;",
          "261:             occ[j] = 1.0;",
          "262:             for (k = 0; k < 256; k++) {",
          "263:                 double newocc[256] = { 0 };",
          "264:                 for (m = 0; m < 256; m++)",
          "265:                     if (occ[m]) {",
          "266:                         len -= occ[m] *     (p  * l2tab[m] +",
          "267:                                         (1 - p) * l2tab[256 - m]);",
          "268:                     }",
          "269:                 if (len < best_len[k]) {",
          "270:                     best_len[k]      = len;",
          "271:                     best_state[i][k] = j;",
          "272:                 }",
          "273:                 for (m = 0; m < 256; m++)",
          "274:                     if (occ[m]) {",
          "275:                         newocc[one_state[m]]             += occ[m] * p;",
          "276:                         newocc[256 - one_state[256 - m]] += occ[m] * (1 - p);",
          "277:                     }",
          "278:                 memcpy(occ, newocc, sizeof(occ));",
          "279:             }",
          "280:         }",
          "281:     }",
          "282: }",
          "284: static av_always_inline av_flatten void put_symbol_inline(RangeCoder *c,",
          "285:                                                           uint8_t *state, int v,",
          "286:                                                           int is_signed,",
          "287:                                                           uint64_t rc_stat[256][2],",
          "288:                                                           uint64_t rc_stat2[32][2])",
          "289: {",
          "290:     int i;",
          "292: #define put_rac(C, S, B)                        \\",
          "293:     do {                                        \\",
          "294:         if (rc_stat) {                          \\",
          "295:             rc_stat[*(S)][B]++;                 \\",
          "296:             rc_stat2[(S) - state][B]++;         \\",
          "297:         }                                       \\",
          "298:         put_rac(C, S, B);                       \\",
          "299:     } while (0)",
          "301:     if (v) {",
          "302:         const int a = FFABS(v);",
          "303:         const int e = av_log2(a);",
          "304:         put_rac(c, state + 0, 0);",
          "305:         if (e <= 9) {",
          "306:             for (i = 0; i < e; i++)",
          "307:                 put_rac(c, state + 1 + i, 1);  // 1..10",
          "308:             put_rac(c, state + 1 + i, 0);",
          "310:             for (i = e - 1; i >= 0; i--)",
          "311:                 put_rac(c, state + 22 + i, (a >> i) & 1);  // 22..31",
          "313:             if (is_signed)",
          "314:                 put_rac(c, state + 11 + e, v < 0);  // 11..21",
          "315:         } else {",
          "316:             for (i = 0; i < e; i++)",
          "317:                 put_rac(c, state + 1 + FFMIN(i, 9), 1);  // 1..10",
          "318:             put_rac(c, state + 1 + 9, 0);",
          "320:             for (i = e - 1; i >= 0; i--)",
          "321:                 put_rac(c, state + 22 + FFMIN(i, 9), (a >> i) & 1);  // 22..31",
          "323:             if (is_signed)",
          "324:                 put_rac(c, state + 11 + 10, v < 0);  // 11..21",
          "325:         }",
          "326:     } else {",
          "327:         put_rac(c, state + 0, 1);",
          "328:     }",
          "329: #undef put_rac",
          "330: }",
          "332: static av_noinline void put_symbol(RangeCoder *c, uint8_t *state,",
          "333:                                    int v, int is_signed)",
          "334: {",
          "335:     put_symbol_inline(c, state, v, is_signed, NULL, NULL);",
          "336: }",
          "338: static inline av_flatten int get_symbol_inline(RangeCoder *c, uint8_t *state,",
          "339:                                                int is_signed)",
          "340: {",
          "341:     if (get_rac(c, state + 0))",
          "342:         return 0;",
          "343:     else {",
          "344:         int i, e, a;",
          "345:         e = 0;",
          "346:         while (get_rac(c, state + 1 + FFMIN(e, 9))) // 1..10",
          "347:             e++;",
          "349:         a = 1;",
          "350:         for (i = e - 1; i >= 0; i--)",
          "351:             a += a + get_rac(c, state + 22 + FFMIN(i, 9));  // 22..31",
          "353:         e = -(is_signed && get_rac(c, state + 11 + FFMIN(e, 10))); // 11..21",
          "354:         return (a ^ e) - e;",
          "355:     }",
          "356: }",
          "358: static av_noinline int get_symbol(RangeCoder *c, uint8_t *state, int is_signed)",
          "359: {",
          "360:     return get_symbol_inline(c, state, is_signed);",
          "361: }",
          "363: static inline void update_vlc_state(VlcState *const state, const int v)",
          "364: {",
          "365:     int drift = state->drift;",
          "366:     int count = state->count;",
          "367:     state->error_sum += FFABS(v);",
          "368:     drift            += v;",
          "370:     if (count == 128) { // FIXME: variable",
          "371:         count            >>= 1;",
          "372:         drift            >>= 1;",
          "373:         state->error_sum >>= 1;",
          "374:     }",
          "375:     count++;",
          "377:     if (drift <= -count) {",
          "378:         if (state->bias > -128)",
          "379:             state->bias--;",
          "381:         drift += count;",
          "382:         if (drift <= -count)",
          "383:             drift = -count + 1;",
          "384:     } else if (drift > 0) {",
          "385:         if (state->bias < 127)",
          "386:             state->bias++;",
          "388:         drift -= count;",
          "389:         if (drift > 0)",
          "390:             drift = 0;",
          "391:     }",
          "393:     state->drift = drift;",
          "394:     state->count = count;",
          "395: }",
          "397: static inline void put_vlc_symbol(PutBitContext *pb, VlcState *const state,",
          "398:                                   int v, int bits)",
          "399: {",
          "400:     int i, k, code;",
          "401:     v = fold(v - state->bias, bits);",
          "403:     i = state->count;",
          "404:     k = 0;",
          "405:     while (i < state->error_sum) { // FIXME: optimize",
          "406:         k++;",
          "407:         i += i;",
          "408:     }",
          "410:     assert(k <= 8);",
          "412: #if 0 // JPEG LS",
          "413:     if (k == 0 && 2 * state->drift <= -state->count)",
          "414:         code = v ^ (-1);",
          "415:     else",
          "416:         code = v;",
          "417: #else",
          "418:     code = v ^ ((2 * state->drift + state->count) >> 31);",
          "419: #endif",
          "421:     av_dlog(NULL, \"v:%d/%d bias:%d error:%d drift:%d count:%d k:%d\\n\", v, code,",
          "422:             state->bias, state->error_sum, state->drift, state->count, k);",
          "423:     set_sr_golomb(pb, code, k, 12, bits);",
          "425:     update_vlc_state(state, v);",
          "426: }",
          "428: static inline int get_vlc_symbol(GetBitContext *gb, VlcState *const state,",
          "429:                                  int bits)",
          "430: {",
          "431:     int k, i, v, ret;",
          "433:     i = state->count;",
          "434:     k = 0;",
          "435:     while (i < state->error_sum) { // FIXME: optimize",
          "436:         k++;",
          "437:         i += i;",
          "438:     }",
          "440:     assert(k <= 8);",
          "442:     v = get_sr_golomb(gb, k, 12, bits);",
          "443:     av_dlog(NULL, \"v:%d bias:%d error:%d drift:%d count:%d k:%d\",",
          "444:             v, state->bias, state->error_sum, state->drift, state->count, k);",
          "446: #if 0 // JPEG LS",
          "447:     if (k == 0 && 2 * state->drift <= -state->count)",
          "448:         v ^= (-1);",
          "449: #else",
          "450:     v ^= ((2 * state->drift + state->count) >> 31);",
          "451: #endif",
          "453:     ret = fold(v + state->bias, bits);",
          "455:     update_vlc_state(state, v);",
          "457:     return ret;",
          "458: }",
          "460: #if CONFIG_FFV1_ENCODER",
          "461: static av_always_inline int encode_line(FFV1Context *s, int w,",
          "462:                                         int16_t *sample[3],",
          "463:                                         int plane_index, int bits)",
          "464: {",
          "465:     PlaneContext *const p = &s->plane[plane_index];",
          "466:     RangeCoder *const c   = &s->c;",
          "467:     int x;",
          "468:     int run_index = s->run_index;",
          "469:     int run_count = 0;",
          "470:     int run_mode  = 0;",
          "472:     if (s->ac) {",
          "473:         if (c->bytestream_end - c->bytestream < w * 20) {",
          "474:             av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");",
          "475:             return -1;",
          "476:         }",
          "477:     } else {",
          "478:         if (s->pb.buf_end - s->pb.buf - (put_bits_count(&s->pb) >> 3) < w * 4) {",
          "479:             av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");",
          "480:             return -1;",
          "481:         }",
          "482:     }",
          "484:     for (x = 0; x < w; x++) {",
          "485:         int diff, context;",
          "487:         context = get_context(p, sample[0] + x, sample[1] + x, sample[2] + x);",
          "488:         diff    = sample[0][x] - predict(sample[0] + x, sample[1] + x);",
          "490:         if (context < 0) {",
          "491:             context = -context;",
          "492:             diff    = -diff;",
          "493:         }",
          "495:         diff = fold(diff, bits);",
          "497:         if (s->ac) {",
          "498:             if (s->flags & CODEC_FLAG_PASS1) {",
          "499:                 put_symbol_inline(c, p->state[context], diff, 1, s->rc_stat,",
          "500:                                   s->rc_stat2[p->quant_table_index][context]);",
          "501:             } else {",
          "502:                 put_symbol_inline(c, p->state[context], diff, 1, NULL, NULL);",
          "503:             }",
          "504:         } else {",
          "505:             if (context == 0)",
          "506:                 run_mode = 1;",
          "508:             if (run_mode) {",
          "509:                 if (diff) {",
          "510:                     while (run_count >= 1 << ff_log2_run[run_index]) {",
          "511:                         run_count -= 1 << ff_log2_run[run_index];",
          "512:                         run_index++;",
          "513:                         put_bits(&s->pb, 1, 1);",
          "514:                     }",
          "516:                     put_bits(&s->pb, 1 + ff_log2_run[run_index], run_count);",
          "517:                     if (run_index)",
          "518:                         run_index--;",
          "519:                     run_count = 0;",
          "520:                     run_mode  = 0;",
          "521:                     if (diff > 0)",
          "522:                         diff--;",
          "523:                 } else {",
          "524:                     run_count++;",
          "525:                 }",
          "526:             }",
          "528:             av_dlog(s->avctx, \"count:%d index:%d, mode:%d, x:%d pos:%d\\n\",",
          "529:                     run_count, run_index, run_mode, x,",
          "530:                     (int)put_bits_count(&s->pb));",
          "532:             if (run_mode == 0)",
          "533:                 put_vlc_symbol(&s->pb, &p->vlc_state[context], diff, bits);",
          "534:         }",
          "535:     }",
          "536:     if (run_mode) {",
          "537:         while (run_count >= 1 << ff_log2_run[run_index]) {",
          "538:             run_count -= 1 << ff_log2_run[run_index];",
          "539:             run_index++;",
          "540:             put_bits(&s->pb, 1, 1);",
          "541:         }",
          "543:         if (run_count)",
          "544:             put_bits(&s->pb, 1, 1);",
          "545:     }",
          "546:     s->run_index = run_index;",
          "548:     return 0;",
          "549: }",
          "551: static void encode_plane(FFV1Context *s, uint8_t *src, int w, int h,",
          "552:                          int stride, int plane_index)",
          "553: {",
          "554:     int x, y, i;",
          "555:     const int ring_size = s->avctx->context_model ? 3 : 2;",
          "556:     int16_t *sample[3];",
          "557:     s->run_index = 0;",
          "559:     memset(s->sample_buffer, 0, ring_size * (w + 6) * sizeof(*s->sample_buffer));",
          "561:     for (y = 0; y < h; y++) {",
          "562:         for (i = 0; i < ring_size; i++)",
          "563:             sample[i] = s->sample_buffer + (w + 6) * ((h + i - y) % ring_size) + 3;",
          "565:         sample[0][-1] = sample[1][0];",
          "566:         sample[1][w]  = sample[1][w - 1];",
          "568:         if (s->avctx->bits_per_raw_sample <= 8) {",
          "569:             for (x = 0; x < w; x++)",
          "570:                 sample[0][x] = src[x + stride * y];",
          "571:             encode_line(s, w, sample, plane_index, 8);",
          "572:         } else {",
          "573:             for (x = 0; x < w; x++)",
          "574:                 sample[0][x] = ((uint16_t *)(src + stride * y))[x] >>",
          "575:                                (16 - s->avctx->bits_per_raw_sample);",
          "576:             encode_line(s, w, sample, plane_index, s->avctx->bits_per_raw_sample);",
          "577:         }",
          "579:     }",
          "580: }",
          "582: static void encode_rgb_frame(FFV1Context *s, uint32_t *src, int w, int h,",
          "583:                              int stride)",
          "584: {",
          "585:     int x, y, p, i;",
          "586:     const int ring_size = s->avctx->context_model ? 3 : 2;",
          "587:     int16_t *sample[3][3];",
          "588:     s->run_index = 0;",
          "590:     memset(s->sample_buffer, 0, ring_size * 3 * (w + 6) * sizeof(*s->sample_buffer));",
          "592:     for (y = 0; y < h; y++) {",
          "593:         for (i = 0; i < ring_size; i++)",
          "594:             for (p = 0; p < 3; p++)",
          "595:                 sample[p][i] = s->sample_buffer + p * ring_size * (w + 6) +",
          "596:                                ((h + i - y) % ring_size) * (w + 6) + 3;",
          "598:         for (x = 0; x < w; x++) {",
          "599:             int v = src[x + stride * y];",
          "600:             int b =  v        & 0xFF;",
          "601:             int g = (v >>  8) & 0xFF;",
          "602:             int r = (v >> 16) & 0xFF;",
          "604:             b -= g;",
          "605:             r -= g;",
          "606:             g += (b + r) >> 2;",
          "607:             b += 0x100;",
          "608:             r += 0x100;",
          "610:             sample[0][0][x] = g;",
          "611:             sample[1][0][x] = b;",
          "612:             sample[2][0][x] = r;",
          "613:         }",
          "614:         for (p = 0; p < 3; p++) {",
          "615:             sample[p][0][-1] = sample[p][1][0];",
          "616:             sample[p][1][w]  = sample[p][1][w - 1];",
          "617:             encode_line(s, w, sample[p], FFMIN(p, 1), 9);",
          "618:         }",
          "619:     }",
          "620: }",
          "622: static void write_quant_table(RangeCoder *c, int16_t *quant_table)",
          "623: {",
          "624:     int last = 0;",
          "625:     int i;",
          "626:     uint8_t state[CONTEXT_SIZE];",
          "627:     memset(state, 128, sizeof(state));",
          "629:     for (i = 1; i < 128; i++)",
          "630:         if (quant_table[i] != quant_table[i - 1]) {",
          "631:             put_symbol(c, state, i - last - 1, 0);",
          "632:             last = i;",
          "633:         }",
          "634:     put_symbol(c, state, i - last - 1, 0);",
          "635: }",
          "637: static void write_quant_tables(RangeCoder *c,",
          "638:                                int16_t quant_table[MAX_CONTEXT_INPUTS][256])",
          "639: {",
          "640:     int i;",
          "641:     for (i = 0; i < 5; i++)",
          "642:         write_quant_table(c, quant_table[i]);",
          "643: }",
          "645: static void write_header(FFV1Context *f)",
          "646: {",
          "647:     uint8_t state[CONTEXT_SIZE];",
          "648:     int i, j;",
          "649:     RangeCoder *const c = &f->slice_context[0]->c;",
          "651:     memset(state, 128, sizeof(state));",
          "653:     if (f->version < 2) {",
          "654:         put_symbol(c, state, f->version, 0);",
          "655:         put_symbol(c, state, f->ac, 0);",
          "656:         if (f->ac > 1) {",
          "657:             for (i = 1; i < 256; i++)",
          "658:                 put_symbol(c, state,",
          "659:                            f->state_transition[i] - c->one_state[i], 1);",
          "660:         }",
          "661:         put_symbol(c, state, f->colorspace, 0); // YUV cs type",
          "662:         if (f->version > 0)",
          "663:             put_symbol(c, state, f->avctx->bits_per_raw_sample, 0);",
          "664:         put_rac(c, state, 1); // chroma planes",
          "665:         put_symbol(c, state, f->chroma_h_shift, 0);",
          "666:         put_symbol(c, state, f->chroma_v_shift, 0);",
          "667:         put_rac(c, state, 0); // no transparency plane",
          "669:         write_quant_tables(c, f->quant_table);",
          "670:     } else {",
          "671:         put_symbol(c, state, f->slice_count, 0);",
          "672:         for (i = 0; i < f->slice_count; i++) {",
          "673:             FFV1Context *fs = f->slice_context[i];",
          "674:             put_symbol(c, state,",
          "675:                        (fs->slice_x      + 1) * f->num_h_slices / f->width, 0);",
          "676:             put_symbol(c, state,",
          "677:                        (fs->slice_y      + 1) * f->num_v_slices / f->height, 0);",
          "678:             put_symbol(c, state,",
          "679:                        (fs->slice_width  + 1) * f->num_h_slices / f->width - 1,",
          "680:                        0);",
          "681:             put_symbol(c, state,",
          "682:                        (fs->slice_height + 1) * f->num_v_slices / f->height - 1,",
          "683:                        0);",
          "684:             for (j = 0; j < f->plane_count; j++) {",
          "685:                 put_symbol(c, state, f->plane[j].quant_table_index, 0);",
          "686:                 av_assert0(f->plane[j].quant_table_index == f->avctx->context_model);",
          "687:             }",
          "688:         }",
          "689:     }",
          "690: }",
          "694: static av_cold int common_init(AVCodecContext *avctx)",
          "",
          "[Added Lines]",
          "134: int ffv1_common_init(AVCodecContext *avctx)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "711:     return 0;",
          "712: }",
          "715: {",
          "716:     int i, j;",
          "",
          "[Removed Lines]",
          "714: static int init_slice_state(FFV1Context *f)",
          "",
          "[Added Lines]",
          "154: int ffv1_init_slice_state(FFV1Context *f)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "746:     return 0;",
          "747: }",
          "750: {",
          "751:     int i;",
          "",
          "[Removed Lines]",
          "749: static av_cold int init_slice_contexts(FFV1Context *f)",
          "",
          "[Added Lines]",
          "189: av_cold int ffv1_init_slice_contexts(FFV1Context *f)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "777:     return 0;",
          "778: }",
          "781: {",
          "782:     int i;",
          "",
          "[Removed Lines]",
          "780: static int allocate_initial_states(FFV1Context *f)",
          "",
          "[Added Lines]",
          "220: int ffv1_allocate_initial_states(FFV1Context *f)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "792:     return 0;",
          "793: }",
          "1089: {",
          "1090:     int i, si, j;",
          "",
          "[Removed Lines]",
          "795: #if CONFIG_FFV1_ENCODER",
          "796: static int write_extra_header(FFV1Context *f)",
          "797: {",
          "798:     RangeCoder *const c = &f->c;",
          "799:     uint8_t state[CONTEXT_SIZE];",
          "800:     int i, j, k;",
          "801:     uint8_t state2[32][CONTEXT_SIZE];",
          "803:     memset(state2, 128, sizeof(state2));",
          "804:     memset(state, 128, sizeof(state));",
          "806:     f->avctx->extradata = av_malloc(f->avctx->extradata_size = 10000 +",
          "807:                                     (11 * 11 * 5 * 5 * 5 + 11 * 11 * 11) * 32);",
          "808:     ff_init_range_encoder(c, f->avctx->extradata, f->avctx->extradata_size);",
          "809:     ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);",
          "811:     put_symbol(c, state, f->version, 0);",
          "812:     put_symbol(c, state, f->ac, 0);",
          "813:     if (f->ac > 1)",
          "814:         for (i = 1; i < 256; i++)",
          "815:             put_symbol(c, state, f->state_transition[i] - c->one_state[i], 1);",
          "816:     put_symbol(c, state, f->colorspace, 0); // YUV cs type",
          "817:     put_symbol(c, state, f->avctx->bits_per_raw_sample, 0);",
          "818:     put_rac(c, state, 1); // chroma planes",
          "819:     put_symbol(c, state, f->chroma_h_shift, 0);",
          "820:     put_symbol(c, state, f->chroma_v_shift, 0);",
          "821:     put_rac(c, state, 0); // no transparency plane",
          "822:     put_symbol(c, state, f->num_h_slices - 1, 0);",
          "823:     put_symbol(c, state, f->num_v_slices - 1, 0);",
          "825:     put_symbol(c, state, f->quant_table_count, 0);",
          "826:     for (i = 0; i < f->quant_table_count; i++)",
          "827:         write_quant_tables(c, f->quant_tables[i]);",
          "829:     for (i = 0; i < f->quant_table_count; i++) {",
          "830:         for (j = 0; j < f->context_count[i] * CONTEXT_SIZE; j++)",
          "831:             if (f->initial_states[i] && f->initial_states[i][0][j] != 128)",
          "832:                 break;",
          "833:         if (j < f->context_count[i] * CONTEXT_SIZE) {",
          "834:             put_rac(c, state, 1);",
          "835:             for (j = 0; j < f->context_count[i]; j++)",
          "836:                 for (k = 0; k < CONTEXT_SIZE; k++) {",
          "837:                     int pred = j ? f->initial_states[i][j - 1][k] : 128;",
          "838:                     put_symbol(c, state2[k],",
          "839:                                (int8_t)(f->initial_states[i][j][k] - pred), 1);",
          "840:                 }",
          "841:         } else {",
          "842:             put_rac(c, state, 0);",
          "843:         }",
          "844:     }",
          "846:     f->avctx->extradata_size = ff_rac_terminate(c);",
          "848:     return 0;",
          "849: }",
          "851: static int sort_stt(FFV1Context *s, uint8_t stt[256])",
          "852: {",
          "853:     int i, i2, changed, print = 0;",
          "855:     do {",
          "856:         changed = 0;",
          "857:         for (i = 12; i < 244; i++) {",
          "858:             for (i2 = i + 1; i2 < 245 && i2 < i + 4; i2++) {",
          "860: #define COST(old, new)                                      \\",
          "861:     s->rc_stat[old][0] * -log2((256 - (new)) / 256.0) +     \\",
          "862:     s->rc_stat[old][1] * -log2((new)         / 256.0)",
          "864: #define COST2(old, new)                         \\",
          "865:     COST(old, new) + COST(256 - (old), 256 - (new))",
          "867:                 double size0 = COST2(i,  i) + COST2(i2, i2);",
          "868:                 double sizeX = COST2(i, i2) + COST2(i2, i);",
          "869:                 if (sizeX < size0 && i != 128 && i2 != 128) {",
          "870:                     int j;",
          "871:                     FFSWAP(int, stt[i], stt[i2]);",
          "872:                     FFSWAP(int, s->rc_stat[i][0], s->rc_stat[i2][0]);",
          "873:                     FFSWAP(int, s->rc_stat[i][1], s->rc_stat[i2][1]);",
          "874:                     if (i != 256 - i2) {",
          "875:                         FFSWAP(int, stt[256 - i], stt[256 - i2]);",
          "876:                         FFSWAP(int, s->rc_stat[256 - i][0], s->rc_stat[256 - i2][0]);",
          "877:                         FFSWAP(int, s->rc_stat[256 - i][1], s->rc_stat[256 - i2][1]);",
          "878:                     }",
          "879:                     for (j = 1; j < 256; j++) {",
          "880:                         if (stt[j] == i)",
          "881:                             stt[j] = i2;",
          "882:                         else if (stt[j] == i2)",
          "883:                             stt[j] = i;",
          "884:                         if (i != 256 - i2) {",
          "885:                             if (stt[256 - j] == 256 - i)",
          "886:                                 stt[256 - j] = 256 - i2;",
          "887:                             else if (stt[256 - j] == 256 - i2)",
          "888:                                 stt[256 - j] = 256 - i;",
          "889:                         }",
          "890:                     }",
          "891:                     print = changed = 1;",
          "892:                 }",
          "893:             }",
          "894:         }",
          "895:     } while (changed);",
          "896:     return print;",
          "897: }",
          "899: static av_cold int encode_init(AVCodecContext *avctx)",
          "900: {",
          "901:     FFV1Context *s = avctx->priv_data;",
          "902:     int i, j, k, m;",
          "904:     common_init(avctx);",
          "906:     s->version = 0;",
          "907:     s->ac      = avctx->coder_type ? 2 : 0;",
          "909:     if (s->ac > 1)",
          "910:         for (i = 1; i < 256; i++)",
          "911:             s->state_transition[i] = ver2_state[i];",
          "913:     s->plane_count = 2;",
          "914:     for (i = 0; i < 256; i++) {",
          "915:         s->quant_table_count = 2;",
          "916:         if (avctx->bits_per_raw_sample <= 8) {",
          "917:             s->quant_tables[0][0][i] = quant11[i];",
          "918:             s->quant_tables[0][1][i] = quant11[i] * 11;",
          "919:             s->quant_tables[0][2][i] = quant11[i] * 11 * 11;",
          "920:             s->quant_tables[1][0][i] = quant11[i];",
          "921:             s->quant_tables[1][1][i] = quant11[i] * 11;",
          "922:             s->quant_tables[1][2][i] = quant5[i]  * 11 * 11;",
          "923:             s->quant_tables[1][3][i] = quant5[i]  *  5 * 11 * 11;",
          "924:             s->quant_tables[1][4][i] = quant5[i]  *  5 *  5 * 11 * 11;",
          "925:         } else {",
          "926:             s->quant_tables[0][0][i] = quant9_10bit[i];",
          "927:             s->quant_tables[0][1][i] = quant9_10bit[i] * 11;",
          "928:             s->quant_tables[0][2][i] = quant9_10bit[i] * 11 * 11;",
          "929:             s->quant_tables[1][0][i] = quant9_10bit[i];",
          "930:             s->quant_tables[1][1][i] = quant9_10bit[i] * 11;",
          "931:             s->quant_tables[1][2][i] = quant5_10bit[i] * 11 * 11;",
          "932:             s->quant_tables[1][3][i] = quant5_10bit[i] *  5 * 11 * 11;",
          "933:             s->quant_tables[1][4][i] = quant5_10bit[i] *  5 *  5 * 11 * 11;",
          "934:         }",
          "935:     }",
          "936:     s->context_count[0] = (11 * 11 * 11        + 1) / 2;",
          "937:     s->context_count[1] = (11 * 11 * 5 * 5 * 5 + 1) / 2;",
          "938:     memcpy(s->quant_table, s->quant_tables[avctx->context_model],",
          "939:            sizeof(s->quant_table));",
          "941:     for (i = 0; i < s->plane_count; i++) {",
          "942:         PlaneContext *const p = &s->plane[i];",
          "944:         memcpy(p->quant_table, s->quant_table, sizeof(p->quant_table));",
          "945:         p->quant_table_index = avctx->context_model;",
          "946:         p->context_count     = s->context_count[p->quant_table_index];",
          "947:     }",
          "949:     if (allocate_initial_states(s) < 0)",
          "950:         return AVERROR(ENOMEM);",
          "952:     avctx->coded_frame = &s->picture;",
          "953:     switch (avctx->pix_fmt) {",
          "954:     case AV_PIX_FMT_YUV444P16:",
          "955:     case AV_PIX_FMT_YUV422P16:",
          "956:     case AV_PIX_FMT_YUV420P16:",
          "957:         if (avctx->bits_per_raw_sample <= 8) {",
          "958:             av_log(avctx, AV_LOG_ERROR, \"bits_per_raw_sample invalid\\n\");",
          "959:             return -1;",
          "960:         }",
          "961:         if (!s->ac) {",
          "962:             av_log(avctx, AV_LOG_ERROR,",
          "963:                    \"bits_per_raw_sample of more than 8 needs -coder 1 currently\\n\");",
          "964:             return -1;",
          "965:         }",
          "966:         s->version = FFMAX(s->version, 1);",
          "967:     case AV_PIX_FMT_YUV444P:",
          "968:     case AV_PIX_FMT_YUV422P:",
          "969:     case AV_PIX_FMT_YUV420P:",
          "970:     case AV_PIX_FMT_YUV411P:",
          "971:     case AV_PIX_FMT_YUV410P:",
          "972:         s->colorspace = 0;",
          "973:         break;",
          "974:     case AV_PIX_FMT_RGB32:",
          "975:         s->colorspace = 1;",
          "976:         break;",
          "977:     default:",
          "978:         av_log(avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "979:         return -1;",
          "980:     }",
          "981:     avcodec_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_h_shift,",
          "982:                                   &s->chroma_v_shift);",
          "984:     s->picture_number = 0;",
          "986:     if (avctx->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2)) {",
          "987:         for (i = 0; i < s->quant_table_count; i++) {",
          "988:             s->rc_stat2[i] = av_mallocz(s->context_count[i] *",
          "989:                                         sizeof(*s->rc_stat2[i]));",
          "990:             if (!s->rc_stat2[i])",
          "991:                 return AVERROR(ENOMEM);",
          "992:         }",
          "993:     }",
          "994:     if (avctx->stats_in) {",
          "995:         char *p = avctx->stats_in;",
          "996:         uint8_t best_state[256][256];",
          "997:         int gob_count = 0;",
          "998:         char *next;",
          "1000:         av_assert0(s->version >= 2);",
          "1002:         for (;; ) {",
          "1003:             for (j = 0; j < 256; j++)",
          "1004:                 for (i = 0; i < 2; i++) {",
          "1005:                     s->rc_stat[j][i] = strtol(p, &next, 0);",
          "1006:                     if (next == p) {",
          "1007:                         av_log(avctx, AV_LOG_ERROR,",
          "1008:                                \"2Pass file invalid at %d %d [%s]\\n\", j, i, p);",
          "1009:                         return -1;",
          "1010:                     }",
          "1011:                     p = next;",
          "1012:                 }",
          "1013:             for (i = 0; i < s->quant_table_count; i++)",
          "1014:                 for (j = 0; j < s->context_count[i]; j++) {",
          "1015:                     for (k = 0; k < 32; k++)",
          "1016:                         for (m = 0; m < 2; m++) {",
          "1017:                             s->rc_stat2[i][j][k][m] = strtol(p, &next, 0);",
          "1018:                             if (next == p) {",
          "1019:                                 av_log(avctx, AV_LOG_ERROR,",
          "1020:                                        \"2Pass file invalid at %d %d %d %d [%s]\\n\",",
          "1021:                                        i, j, k, m, p);",
          "1022:                                 return -1;",
          "1023:                             }",
          "1024:                             p = next;",
          "1025:                         }",
          "1026:                 }",
          "1027:             gob_count = strtol(p, &next, 0);",
          "1028:             if (next == p || gob_count < 0) {",
          "1029:                 av_log(avctx, AV_LOG_ERROR, \"2Pass file invalid\\n\");",
          "1030:                 return -1;",
          "1031:             }",
          "1032:             p = next;",
          "1033:             while (*p == '\\n' || *p == ' ')",
          "1034:                 p++;",
          "1035:             if (p[0] == 0)",
          "1036:                 break;",
          "1037:         }",
          "1038:         sort_stt(s, s->state_transition);",
          "1040:         find_best_state(best_state, s->state_transition);",
          "1042:         for (i = 0; i < s->quant_table_count; i++) {",
          "1043:             for (j = 0; j < s->context_count[i]; j++)",
          "1044:                 for (k = 0; k < 32; k++) {",
          "1045:                     double p = 128;",
          "1046:                     if (s->rc_stat2[i][j][k][0] + s->rc_stat2[i][j][k][1]) {",
          "1047:                         p = 256.0 * s->rc_stat2[i][j][k][1] /",
          "1048:                             (s->rc_stat2[i][j][k][0] + s->rc_stat2[i][j][k][1]);",
          "1049:                     }",
          "1050:                     s->initial_states[i][j][k] =",
          "1051:                         best_state[av_clip(round(p), 1, 255)][av_clip((s->rc_stat2[i][j][k][0] +",
          "1052:                                                                        s->rc_stat2[i][j][k][1]) /",
          "1053:                                                                       gob_count, 0, 255)];",
          "1054:                 }",
          "1055:         }",
          "1056:     }",
          "1058:     if (s->version > 1) {",
          "1059:         s->num_h_slices = 2;",
          "1060:         s->num_v_slices = 2;",
          "1061:         write_extra_header(s);",
          "1062:     }",
          "1064:     if (init_slice_contexts(s) < 0)",
          "1065:         return -1;",
          "1066:     if (init_slice_state(s) < 0)",
          "1067:         return -1;",
          "1069: #define STATS_OUT_SIZE 1024 * 1024 * 6",
          "1070:     if (avctx->flags & CODEC_FLAG_PASS1) {",
          "1071:         avctx->stats_out = av_mallocz(STATS_OUT_SIZE);",
          "1072:         for (i = 0; i < s->quant_table_count; i++)",
          "1073:             for (j = 0; j < s->slice_count; j++) {",
          "1074:                 FFV1Context *sf = s->slice_context[j];",
          "1075:                 av_assert0(!sf->rc_stat2[i]);",
          "1076:                 sf->rc_stat2[i] = av_mallocz(s->context_count[i] *",
          "1077:                                              sizeof(*sf->rc_stat2[i]));",
          "1078:                 if (!sf->rc_stat2[i])",
          "1079:                     return AVERROR(ENOMEM);",
          "1080:             }",
          "1081:     }",
          "1083:     return 0;",
          "1084: }",
          "1088: static void clear_state(FFV1Context *f)",
          "",
          "[Added Lines]",
          "235: void ffv1_clear_state(FFV1Context *f)",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1115:     }",
          "1116: }",
          "1290: {",
          "1291:     FFV1Context *s = avctx->priv_data;",
          "1292:     int i, j;",
          "",
          "[Removed Lines]",
          "1118: #if CONFIG_FFV1_ENCODER",
          "1119: static int encode_slice(AVCodecContext *c, void *arg)",
          "1120: {",
          "1121:     FFV1Context *fs  = *(void **)arg;",
          "1122:     FFV1Context *f   = fs->avctx->priv_data;",
          "1123:     int width        = fs->slice_width;",
          "1124:     int height       = fs->slice_height;",
          "1125:     int x            = fs->slice_x;",
          "1126:     int y            = fs->slice_y;",
          "1127:     AVFrame *const p = &f->picture;",
          "1129:     if (f->colorspace == 0) {",
          "1130:         const int chroma_width  = -((-width) >> f->chroma_h_shift);",
          "1131:         const int chroma_height = -((-height) >> f->chroma_v_shift);",
          "1132:         const int cx            = x >> f->chroma_h_shift;",
          "1133:         const int cy            = y >> f->chroma_v_shift;",
          "1135:         encode_plane(fs, p->data[0] + x + y * p->linesize[0],",
          "1136:                      width, height, p->linesize[0], 0);",
          "1138:         encode_plane(fs, p->data[1] + cx + cy * p->linesize[1],",
          "1139:                      chroma_width, chroma_height, p->linesize[1], 1);",
          "1140:         encode_plane(fs, p->data[2] + cx + cy * p->linesize[2],",
          "1141:                      chroma_width, chroma_height, p->linesize[2], 1);",
          "1142:     } else {",
          "1143:         encode_rgb_frame(fs, (uint32_t *)(p->data[0]) +",
          "1144:                          x + y * (p->linesize[0] / 4),",
          "1145:                          width, height, p->linesize[0] / 4);",
          "1146:     }",
          "1147:     emms_c();",
          "1149:     return 0;",
          "1150: }",
          "1152: static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,",
          "1153:                         const AVFrame *pict, int *got_packet)",
          "1154: {",
          "1155:     FFV1Context *f      = avctx->priv_data;",
          "1156:     RangeCoder *const c = &f->slice_context[0]->c;",
          "1157:     AVFrame *const p    = &f->picture;",
          "1158:     int used_count      = 0;",
          "1159:     uint8_t keystate    = 128;",
          "1160:     uint8_t *buf_p;",
          "1161:     int i, ret;",
          "1163:     if (!pkt->data &&",
          "1164:         (ret = av_new_packet(pkt, avctx->width * avctx->height *",
          "1165:                              ((8 * 2 + 1 + 1) * 4) / 8 + FF_MIN_BUFFER_SIZE)) < 0) {",
          "1166:         av_log(avctx, AV_LOG_ERROR, \"Error getting output packet.\\n\");",
          "1167:         return ret;",
          "1168:     }",
          "1170:     ff_init_range_encoder(c, pkt->data, pkt->size);",
          "1171:     ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);",
          "1174:     p->pict_type = AV_PICTURE_TYPE_I;",
          "1176:     if (avctx->gop_size == 0 || f->picture_number % avctx->gop_size == 0) {",
          "1177:         put_rac(c, &keystate, 1);",
          "1178:         p->key_frame = 1;",
          "1179:         f->gob_count++;",
          "1180:         write_header(f);",
          "1181:         clear_state(f);",
          "1182:     } else {",
          "1183:         put_rac(c, &keystate, 0);",
          "1184:         p->key_frame = 0;",
          "1185:     }",
          "1187:     if (!f->ac) {",
          "1188:         used_count += ff_rac_terminate(c);",
          "1189:         init_put_bits(&f->slice_context[0]->pb, pkt->data + used_count,",
          "1190:                       pkt->size - used_count);",
          "1191:     } else if (f->ac > 1) {",
          "1192:         int i;",
          "1193:         for (i = 1; i < 256; i++) {",
          "1194:             c->one_state[i]        = f->state_transition[i];",
          "1195:             c->zero_state[256 - i] = 256 - c->one_state[i];",
          "1196:         }",
          "1197:     }",
          "1199:     for (i = 1; i < f->slice_count; i++) {",
          "1200:         FFV1Context *fs = f->slice_context[i];",
          "1201:         uint8_t *start  = pkt->data + (pkt->size - used_count) * i / f->slice_count;",
          "1202:         int len         = pkt->size / f->slice_count;",
          "1204:         if (fs->ac)",
          "1205:             ff_init_range_encoder(&fs->c, start, len);",
          "1206:         else",
          "1207:             init_put_bits(&fs->pb, start, len);",
          "1208:     }",
          "1209:     avctx->execute(avctx, encode_slice, &f->slice_context[0], NULL,",
          "1210:                    f->slice_count, sizeof(void *));",
          "1212:     buf_p = pkt->data;",
          "1213:     for (i = 0; i < f->slice_count; i++) {",
          "1214:         FFV1Context *fs = f->slice_context[i];",
          "1215:         int bytes;",
          "1217:         if (fs->ac) {",
          "1218:             uint8_t state = 128;",
          "1219:             put_rac(&fs->c, &state, 0);",
          "1220:             bytes = ff_rac_terminate(&fs->c);",
          "1221:         } else {",
          "1222:             flush_put_bits(&fs->pb); // FIXME: nicer padding",
          "1223:             bytes      = used_count + (put_bits_count(&fs->pb) + 7) / 8;",
          "1224:             used_count = 0;",
          "1225:         }",
          "1226:         if (i > 0) {",
          "1227:             av_assert0(bytes < pkt->size / f->slice_count);",
          "1228:             memmove(buf_p, fs->ac ? fs->c.bytestream_start : fs->pb.buf, bytes);",
          "1229:             av_assert0(bytes < (1 << 24));",
          "1230:             AV_WB24(buf_p + bytes, bytes);",
          "1231:             bytes += 3;",
          "1232:         }",
          "1233:         buf_p += bytes;",
          "1234:     }",
          "1236:     if ((avctx->flags & CODEC_FLAG_PASS1) && (f->picture_number & 31) == 0) {",
          "1237:         int j, k, m;",
          "1238:         char *p   = avctx->stats_out;",
          "1239:         char *end = p + STATS_OUT_SIZE;",
          "1241:         memset(f->rc_stat, 0, sizeof(f->rc_stat));",
          "1242:         for (i = 0; i < f->quant_table_count; i++)",
          "1243:             memset(f->rc_stat2[i], 0, f->context_count[i] * sizeof(*f->rc_stat2[i]));",
          "1245:         for (j = 0; j < f->slice_count; j++) {",
          "1246:             FFV1Context *fs = f->slice_context[j];",
          "1247:             for (i = 0; i < 256; i++) {",
          "1248:                 f->rc_stat[i][0] += fs->rc_stat[i][0];",
          "1249:                 f->rc_stat[i][1] += fs->rc_stat[i][1];",
          "1250:             }",
          "1251:             for (i = 0; i < f->quant_table_count; i++) {",
          "1252:                 for (k = 0; k < f->context_count[i]; k++)",
          "1253:                     for (m = 0; m < 32; m++) {",
          "1254:                         f->rc_stat2[i][k][m][0] += fs->rc_stat2[i][k][m][0];",
          "1255:                         f->rc_stat2[i][k][m][1] += fs->rc_stat2[i][k][m][1];",
          "1256:                     }",
          "1257:             }",
          "1258:         }",
          "1260:         for (j = 0; j < 256; j++) {",
          "1261:             snprintf(p, end - p, \"%\" PRIu64 \" %\" PRIu64 \" \",",
          "1262:                      f->rc_stat[j][0], f->rc_stat[j][1]);",
          "1263:             p += strlen(p);",
          "1264:         }",
          "1265:         snprintf(p, end - p, \"\\n\");",
          "1267:         for (i = 0; i < f->quant_table_count; i++) {",
          "1268:             for (j = 0; j < f->context_count[i]; j++)",
          "1269:                 for (m = 0; m < 32; m++) {",
          "1270:                     snprintf(p, end - p, \"%\" PRIu64 \" %\" PRIu64 \" \",",
          "1271:                              f->rc_stat2[i][j][m][0], f->rc_stat2[i][j][m][1]);",
          "1272:                     p += strlen(p);",
          "1273:                 }",
          "1274:         }",
          "1275:         snprintf(p, end - p, \"%d\\n\", f->gob_count);",
          "1276:     } else if (avctx->flags & CODEC_FLAG_PASS1)",
          "1277:         avctx->stats_out[0] = '\\0';",
          "1279:     f->picture_number++;",
          "1280:     pkt->size   = buf_p - pkt->data;",
          "1281:     pkt->flags |= AV_PKT_FLAG_KEY * p->key_frame;",
          "1284:     return 0;",
          "1285: }",
          "1289: static av_cold int common_end(AVCodecContext *avctx)",
          "",
          "[Added Lines]",
          "265: av_cold int ffv1_close(AVCodecContext *avctx)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1321:     return 0;",
          "1322: }",
          "",
          "[Removed Lines]",
          "1324: static av_always_inline void decode_line(FFV1Context *s, int w,",
          "1325:                                          int16_t *sample[2],",
          "1326:                                          int plane_index, int bits)",
          "1327: {",
          "1328:     PlaneContext *const p = &s->plane[plane_index];",
          "1329:     RangeCoder *const c   = &s->c;",
          "1330:     int x;",
          "1331:     int run_count = 0;",
          "1332:     int run_mode  = 0;",
          "1333:     int run_index = s->run_index;",
          "1335:     for (x = 0; x < w; x++) {",
          "1336:         int diff, context, sign;",
          "1338:         context = get_context(p, sample[1] + x, sample[0] + x, sample[1] + x);",
          "1339:         if (context < 0) {",
          "1340:             context = -context;",
          "1341:             sign    = 1;",
          "1342:         } else",
          "1343:             sign = 0;",
          "1345:         av_assert2(context < p->context_count);",
          "1347:         if (s->ac) {",
          "1348:             diff = get_symbol_inline(c, p->state[context], 1);",
          "1349:         } else {",
          "1350:             if (context == 0 && run_mode == 0)",
          "1351:                 run_mode = 1;",
          "1353:             if (run_mode) {",
          "1354:                 if (run_count == 0 && run_mode == 1) {",
          "1355:                     if (get_bits1(&s->gb)) {",
          "1356:                         run_count = 1 << ff_log2_run[run_index];",
          "1357:                         if (x + run_count <= w)",
          "1358:                             run_index++;",
          "1359:                     } else {",
          "1360:                         if (ff_log2_run[run_index])",
          "1361:                             run_count = get_bits(&s->gb, ff_log2_run[run_index]);",
          "1362:                         else",
          "1363:                             run_count = 0;",
          "1364:                         if (run_index)",
          "1365:                             run_index--;",
          "1366:                         run_mode = 2;",
          "1367:                     }",
          "1368:                 }",
          "1369:                 run_count--;",
          "1370:                 if (run_count < 0) {",
          "1371:                     run_mode  = 0;",
          "1372:                     run_count = 0;",
          "1373:                     diff      = get_vlc_symbol(&s->gb, &p->vlc_state[context],",
          "1374:                                                bits);",
          "1375:                     if (diff >= 0)",
          "1376:                         diff++;",
          "1377:                 } else",
          "1378:                     diff = 0;",
          "1379:             } else",
          "1380:                 diff = get_vlc_symbol(&s->gb, &p->vlc_state[context], bits);",
          "1382:             av_dlog(s->avctx, \"count:%d index:%d, mode:%d, x:%d pos:%d\\n\",",
          "1383:                     run_count, run_index, run_mode, x, get_bits_count(&s->gb));",
          "1384:         }",
          "1386:         if (sign)",
          "1387:             diff = -diff;",
          "1389:         sample[1][x] = (predict(sample[1] + x, sample[0] + x) + diff) &",
          "1390:                        ((1 << bits) - 1);",
          "1391:     }",
          "1392:     s->run_index = run_index;",
          "1393: }",
          "1395: static void decode_plane(FFV1Context *s, uint8_t *src,",
          "1396:                          int w, int h, int stride, int plane_index)",
          "1397: {",
          "1398:     int x, y;",
          "1399:     int16_t *sample[2];",
          "1400:     sample[0] = s->sample_buffer + 3;",
          "1401:     sample[1] = s->sample_buffer + w + 6 + 3;",
          "1403:     s->run_index = 0;",
          "1405:     memset(s->sample_buffer, 0, 2 * (w + 6) * sizeof(*s->sample_buffer));",
          "1407:     for (y = 0; y < h; y++) {",
          "1408:         int16_t *temp = sample[0]; // FIXME: try a normal buffer",
          "1410:         sample[0] = sample[1];",
          "1411:         sample[1] = temp;",
          "1413:         sample[1][-1] = sample[0][0];",
          "1414:         sample[0][w]  = sample[0][w - 1];",
          "1417:         if (s->avctx->bits_per_raw_sample <= 8) {",
          "1418:             decode_line(s, w, sample, plane_index, 8);",
          "1419:             for (x = 0; x < w; x++)",
          "1420:                 src[x + stride * y] = sample[1][x];",
          "1421:         } else {",
          "1422:             decode_line(s, w, sample, plane_index,",
          "1423:                         s->avctx->bits_per_raw_sample);",
          "1424:             for (x = 0; x < w; x++)",
          "1425:                 ((uint16_t *)(src + stride * y))[x] =",
          "1426:                     sample[1][x] << (16 - s->avctx->bits_per_raw_sample);",
          "1427:         }",
          "1429:     }",
          "1430: }",
          "1432: static void decode_rgb_frame(FFV1Context *s, uint32_t *src,",
          "1433:                              int w, int h, int stride)",
          "1434: {",
          "1435:     int x, y, p;",
          "1436:     int16_t *sample[3][2];",
          "1437:     for (x = 0; x < 3; x++) {",
          "1438:         sample[x][0] = s->sample_buffer +  x * 2      * (w + 6) + 3;",
          "1439:         sample[x][1] = s->sample_buffer + (x * 2 + 1) * (w + 6) + 3;",
          "1440:     }",
          "1442:     s->run_index = 0;",
          "1444:     memset(s->sample_buffer, 0, 6 * (w + 6) * sizeof(*s->sample_buffer));",
          "1446:     for (y = 0; y < h; y++) {",
          "1447:         for (p = 0; p < 3; p++) {",
          "1448:             int16_t *temp = sample[p][0]; // FIXME: try a normal buffer",
          "1450:             sample[p][0] = sample[p][1];",
          "1451:             sample[p][1] = temp;",
          "1453:             sample[p][1][-1] = sample[p][0][0];",
          "1454:             sample[p][0][w]  = sample[p][0][w - 1];",
          "1455:             decode_line(s, w, sample[p], FFMIN(p, 1), 9);",
          "1456:         }",
          "1457:         for (x = 0; x < w; x++) {",
          "1458:             int g = sample[0][1][x];",
          "1459:             int b = sample[1][1][x];",
          "1460:             int r = sample[2][1][x];",
          "1465:             b -= 0x100;",
          "1466:             r -= 0x100;",
          "1467:             g -= (b + r) >> 2;",
          "1468:             b += g;",
          "1469:             r += g;",
          "1471:             src[x + stride * y] = b + (g << 8) + (r << 16) + (0xFF << 24);",
          "1472:         }",
          "1473:     }",
          "1474: }",
          "1476: static int decode_slice(AVCodecContext *c, void *arg)",
          "1477: {",
          "1478:     FFV1Context *fs  = *(void **)arg;",
          "1479:     FFV1Context *f   = fs->avctx->priv_data;",
          "1480:     int width        = fs->slice_width;",
          "1481:     int height       = fs->slice_height;",
          "1482:     int x            = fs->slice_x;",
          "1483:     int y            = fs->slice_y;",
          "1484:     AVFrame *const p = &f->picture;",
          "1486:     av_assert1(width && height);",
          "1487:     if (f->colorspace == 0) {",
          "1488:         const int chroma_width  = -((-width)  >> f->chroma_h_shift);",
          "1489:         const int chroma_height = -((-height) >> f->chroma_v_shift);",
          "1490:         const int cx            = x >> f->chroma_h_shift;",
          "1491:         const int cy            = y >> f->chroma_v_shift;",
          "1493:         decode_plane(fs, p->data[0] + x + y * p->linesize[0],",
          "1494:                      width, height, p->linesize[0], 0);",
          "1496:         decode_plane(fs, p->data[1] + cx + cy * p->linesize[1],",
          "1497:                      chroma_width, chroma_height, p->linesize[1], 1);",
          "1498:         decode_plane(fs, p->data[2] + cx + cy * p->linesize[1],",
          "1499:                      chroma_width, chroma_height, p->linesize[2], 1);",
          "1500:     } else {",
          "1501:         decode_rgb_frame(fs,",
          "1502:                          (uint32_t *)p->data[0] + x + y * (p->linesize[0] / 4),",
          "1503:                          width, height, p->linesize[0] / 4);",
          "1504:     }",
          "1506:     emms_c();",
          "1508:     return 0;",
          "1509: }",
          "1511: static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)",
          "1512: {",
          "1513:     int v;",
          "1514:     int i = 0;",
          "1515:     uint8_t state[CONTEXT_SIZE];",
          "1517:     memset(state, 128, sizeof(state));",
          "1519:     for (v = 0; i < 128; v++) {",
          "1520:         int len = get_symbol(c, state, 0) + 1;",
          "1522:         if (len + i > 128)",
          "1523:             return -1;",
          "1525:         while (len--) {",
          "1526:             quant_table[i] = scale * v;",
          "1527:             i++;",
          "1528:         }",
          "1529:     }",
          "1531:     for (i = 1; i < 128; i++)",
          "1532:         quant_table[256 - i] = -quant_table[i];",
          "1533:     quant_table[128] = -quant_table[127];",
          "1535:     return 2 * v - 1;",
          "1536: }",
          "1538: static int read_quant_tables(RangeCoder *c,",
          "1539:                              int16_t quant_table[MAX_CONTEXT_INPUTS][256])",
          "1540: {",
          "1541:     int i;",
          "1542:     int context_count = 1;",
          "1544:     for (i = 0; i < 5; i++) {",
          "1545:         context_count *= read_quant_table(c, quant_table[i], context_count);",
          "1546:         if (context_count > 32768U) {",
          "1547:             return -1;",
          "1548:         }",
          "1549:     }",
          "1550:     return (context_count + 1) / 2;",
          "1551: }",
          "1553: static int read_extra_header(FFV1Context *f)",
          "1554: {",
          "1555:     RangeCoder *const c = &f->c;",
          "1556:     uint8_t state[CONTEXT_SIZE];",
          "1557:     int i, j, k;",
          "1558:     uint8_t state2[32][CONTEXT_SIZE];",
          "1560:     memset(state2, 128, sizeof(state2));",
          "1561:     memset(state, 128, sizeof(state));",
          "1563:     ff_init_range_decoder(c, f->avctx->extradata, f->avctx->extradata_size);",
          "1564:     ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);",
          "1566:     f->version = get_symbol(c, state, 0);",
          "1567:     f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);",
          "1568:     if (f->ac > 1)",
          "1569:         for (i = 1; i < 256; i++)",
          "1570:             f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];",
          "1571:     f->colorspace                 = get_symbol(c, state, 0); // YUV cs type",
          "1572:     f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);",
          "1573:     get_rac(c, state); // no chroma = false",
          "1574:     f->chroma_h_shift = get_symbol(c, state, 0);",
          "1575:     f->chroma_v_shift = get_symbol(c, state, 0);",
          "1576:     get_rac(c, state); // transparency plane",
          "1577:     f->plane_count  = 2;",
          "1578:     f->num_h_slices = 1 + get_symbol(c, state, 0);",
          "1579:     f->num_v_slices = 1 + get_symbol(c, state, 0);",
          "1581:     if (f->num_h_slices > (unsigned)f->width ||",
          "1582:         f->num_v_slices > (unsigned)f->height) {",
          "1583:         av_log(f->avctx, AV_LOG_ERROR, \"too many slices\\n\");",
          "1584:         return -1;",
          "1585:     }",
          "1587:     f->quant_table_count = get_symbol(c, state, 0);",
          "1589:     if (f->quant_table_count > (unsigned)MAX_QUANT_TABLES)",
          "1590:         return -1;",
          "1592:     for (i = 0; i < f->quant_table_count; i++) {",
          "1593:         f->context_count[i] = read_quant_tables(c, f->quant_tables[i]);",
          "1594:         if (f->context_count[i] < 0) {",
          "1595:             av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");",
          "1596:             return -1;",
          "1597:         }",
          "1598:     }",
          "1600:     if (allocate_initial_states(f) < 0)",
          "1601:         return AVERROR(ENOMEM);",
          "1603:     for (i = 0; i < f->quant_table_count; i++)",
          "1604:         if (get_rac(c, state))",
          "1605:             for (j = 0; j < f->context_count[i]; j++)",
          "1606:                 for (k = 0; k < CONTEXT_SIZE; k++) {",
          "1607:                     int pred = j ? f->initial_states[i][j - 1][k] : 128;",
          "1608:                     f->initial_states[i][j][k] =",
          "1609:                         (pred + get_symbol(c, state2[k], 1)) & 0xFF;",
          "1610:                 }",
          "1611:     return 0;",
          "1612: }",
          "1614: static int read_header(FFV1Context *f)",
          "1615: {",
          "1616:     uint8_t state[CONTEXT_SIZE];",
          "1617:     int i, j, context_count;",
          "1618:     RangeCoder *const c = &f->slice_context[0]->c;",
          "1620:     memset(state, 128, sizeof(state));",
          "1622:     if (f->version < 2) {",
          "1623:         f->version = get_symbol(c, state, 0);",
          "1624:         f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);",
          "1625:         if (f->ac > 1)",
          "1626:             for (i = 1; i < 256; i++)",
          "1627:                 f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];",
          "1628:         f->colorspace = get_symbol(c, state, 0); // YUV cs type",
          "1629:         if (f->version > 0)",
          "1630:             f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);",
          "1631:         get_rac(c, state); // no chroma = false",
          "1632:         f->chroma_h_shift = get_symbol(c, state, 0);",
          "1633:         f->chroma_v_shift = get_symbol(c, state, 0);",
          "1634:         get_rac(c, state); // transparency plane",
          "1635:         f->plane_count = 2;",
          "1636:     }",
          "1638:     if (f->colorspace == 0) {",
          "1639:         if (f->avctx->bits_per_raw_sample <= 8) {",
          "1640:             switch (16 * f->chroma_h_shift + f->chroma_v_shift) {",
          "1641:             case 0x00:",
          "1642:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV444P;",
          "1643:                 break;",
          "1644:             case 0x10:",
          "1645:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV422P;",
          "1646:                 break;",
          "1647:             case 0x11:",
          "1648:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV420P;",
          "1649:                 break;",
          "1650:             case 0x20:",
          "1651:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV411P;",
          "1652:                 break;",
          "1653:             case 0x22:",
          "1654:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV410P;",
          "1655:                 break;",
          "1656:             default:",
          "1657:                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "1658:                 return -1;",
          "1659:             }",
          "1660:         } else {",
          "1661:             switch (16 * f->chroma_h_shift + f->chroma_v_shift) {",
          "1662:             case 0x00:",
          "1663:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16;",
          "1664:                 break;",
          "1665:             case 0x10:",
          "1666:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16;",
          "1667:                 break;",
          "1668:             case 0x11:",
          "1669:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16;",
          "1670:                 break;",
          "1671:             default:",
          "1672:                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "1673:                 return -1;",
          "1674:             }",
          "1675:         }",
          "1676:     } else if (f->colorspace == 1) {",
          "1677:         if (f->chroma_h_shift || f->chroma_v_shift) {",
          "1678:             av_log(f->avctx, AV_LOG_ERROR,",
          "1679:                    \"chroma subsampling not supported in this colorspace\\n\");",
          "1680:             return -1;",
          "1681:         }",
          "1682:         f->avctx->pix_fmt = AV_PIX_FMT_RGB32;",
          "1683:     } else {",
          "1684:         av_log(f->avctx, AV_LOG_ERROR, \"colorspace not supported\\n\");",
          "1685:         return -1;",
          "1686:     }",
          "1688:     av_dlog(f->avctx, \"%d %d %d\\n\",",
          "1689:             f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);",
          "1691:     if (f->version < 2) {",
          "1692:         context_count = read_quant_tables(c, f->quant_table);",
          "1693:         if (context_count < 0) {",
          "1694:             av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");",
          "1695:             return -1;",
          "1696:         }",
          "1697:     } else {",
          "1698:         f->slice_count = get_symbol(c, state, 0);",
          "1699:         if (f->slice_count > (unsigned)MAX_SLICES)",
          "1700:             return -1;",
          "1701:     }",
          "1703:     for (j = 0; j < f->slice_count; j++) {",
          "1704:         FFV1Context *fs = f->slice_context[j];",
          "1705:         fs->ac = f->ac;",
          "1707:         if (f->version >= 2) {",
          "1708:             fs->slice_x      = get_symbol(c, state, 0) * f->width;",
          "1709:             fs->slice_y      = get_symbol(c, state, 0) * f->height;",
          "1710:             fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;",
          "1711:             fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;",
          "1713:             fs->slice_x     /= f->num_h_slices;",
          "1714:             fs->slice_y     /= f->num_v_slices;",
          "1715:             fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;",
          "1716:             fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;",
          "1717:             if ((unsigned)fs->slice_width  > f->width ||",
          "1718:                 (unsigned)fs->slice_height > f->height)",
          "1719:                 return -1;",
          "1720:             if ((unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width ||",
          "1721:                 (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)",
          "1722:                 return -1;",
          "1723:         }",
          "1725:         for (i = 0; i < f->plane_count; i++) {",
          "1726:             PlaneContext *const p = &fs->plane[i];",
          "1728:             if (f->version >= 2) {",
          "1729:                 int idx = get_symbol(c, state, 0);",
          "1730:                 if (idx > (unsigned)f->quant_table_count) {",
          "1731:                     av_log(f->avctx, AV_LOG_ERROR,",
          "1732:                            \"quant_table_index out of range\\n\");",
          "1733:                     return -1;",
          "1734:                 }",
          "1735:                 p->quant_table_index = idx;",
          "1736:                 memcpy(p->quant_table, f->quant_tables[idx],",
          "1737:                        sizeof(p->quant_table));",
          "1738:                 context_count = f->context_count[idx];",
          "1739:             } else {",
          "1740:                 memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));",
          "1741:             }",
          "1743:             if (p->context_count < context_count) {",
          "1744:                 av_freep(&p->state);",
          "1745:                 av_freep(&p->vlc_state);",
          "1746:             }",
          "1747:             p->context_count = context_count;",
          "1748:         }",
          "1749:     }",
          "1751:     return 0;",
          "1752: }",
          "1754: static av_cold int decode_init(AVCodecContext *avctx)",
          "1755: {",
          "1756:     FFV1Context *f = avctx->priv_data;",
          "1758:     common_init(avctx);",
          "1760:     if (avctx->extradata && read_extra_header(f) < 0)",
          "1761:         return -1;",
          "1763:     if (init_slice_contexts(f) < 0)",
          "1764:         return -1;",
          "1766:     return 0;",
          "1767: }",
          "1769: static int decode_frame(AVCodecContext *avctx, void *data,",
          "1770:                         int *data_size, AVPacket *avpkt)",
          "1771: {",
          "1772:     const uint8_t *buf  = avpkt->data;",
          "1773:     int buf_size        = avpkt->size;",
          "1774:     FFV1Context *f      = avctx->priv_data;",
          "1775:     RangeCoder *const c = &f->slice_context[0]->c;",
          "1776:     AVFrame *const p    = &f->picture;",
          "1777:     int bytes_read, i;",
          "1778:     uint8_t keystate = 128;",
          "1779:     const uint8_t *buf_p;",
          "1781:     AVFrame *picture = data;",
          "1784:     if (p->data[0])",
          "1785:         avctx->release_buffer(avctx, p);",
          "1787:     ff_init_range_decoder(c, buf, buf_size);",
          "1788:     ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);",
          "1790:     p->pict_type = AV_PICTURE_TYPE_I; // FIXME: I vs. P",
          "1791:     if (get_rac(c, &keystate)) {",
          "1792:         p->key_frame = 1;",
          "1793:         if (read_header(f) < 0)",
          "1794:             return -1;",
          "1795:         if (init_slice_state(f) < 0)",
          "1796:             return -1;",
          "1798:         clear_state(f);",
          "1799:     } else {",
          "1800:         p->key_frame = 0;",
          "1801:     }",
          "1802:     if (f->ac > 1) {",
          "1803:         int i;",
          "1804:         for (i = 1; i < 256; i++) {",
          "1805:             c->one_state[i]        = f->state_transition[i];",
          "1806:             c->zero_state[256 - i] = 256 - c->one_state[i];",
          "1807:         }",
          "1808:     }",
          "1810:     p->reference = 0;",
          "1811:     if (avctx->get_buffer(avctx, p) < 0) {",
          "1812:         av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");",
          "1813:         return -1;",
          "1814:     }",
          "1816:     if (avctx->debug & FF_DEBUG_PICT_INFO)",
          "1817:         av_log(avctx, AV_LOG_ERROR, \"keyframe:%d coder:%d\\n\", p->key_frame, f->ac);",
          "1819:     if (!f->ac) {",
          "1820:         bytes_read = c->bytestream - c->bytestream_start - 1;",
          "1821:         if (bytes_read == 0)",
          "1822:             av_log(avctx, AV_LOG_ERROR, \"error at end of AC stream\\n\"); // FIXME",
          "1823:         init_get_bits(&f->slice_context[0]->gb, buf + bytes_read,",
          "1824:                       (buf_size - bytes_read) * 8);",
          "1825:     } else {",
          "1827:     }",
          "1829:     buf_p = buf + buf_size;",
          "1830:     for (i = f->slice_count - 1; i > 0; i--) {",
          "1831:         FFV1Context *fs = f->slice_context[i];",
          "1832:         int v           = AV_RB24(buf_p - 3) + 3;",
          "1833:         if (buf_p - buf <= v) {",
          "1834:             av_log(avctx, AV_LOG_ERROR, \"Slice pointer chain broken\\n\");",
          "1835:             return -1;",
          "1836:         }",
          "1837:         buf_p -= v;",
          "1838:         if (fs->ac)",
          "1839:             ff_init_range_decoder(&fs->c, buf_p, v);",
          "1840:         else",
          "1841:             init_get_bits(&fs->gb, buf_p, v * 8);",
          "1842:     }",
          "1844:     avctx->execute(avctx, decode_slice, &f->slice_context[0],",
          "1845:                    NULL, f->slice_count, sizeof(void *));",
          "1846:     f->picture_number++;",
          "1851:     return buf_size;",
          "1852: }",
          "1854: AVCodec ff_ffv1_decoder = {",
          "1855:     .name           = \"ffv1\",",
          "1856:     .type           = AVMEDIA_TYPE_VIDEO,",
          "1857:     .id             = AV_CODEC_ID_FFV1,",
          "1858:     .priv_data_size = sizeof(FFV1Context),",
          "1859:     .init           = decode_init,",
          "1860:     .close          = common_end,",
          "1861:     .decode         = decode_frame,",
          "1862:     .capabilities   = CODEC_CAP_DR1 /*| CODEC_CAP_DRAW_HORIZ_BAND*/ |",
          "1863:                       CODEC_CAP_SLICE_THREADS,",
          "1864:     .long_name      = NULL_IF_CONFIG_SMALL(\"FFmpeg video codec #1\"),",
          "1865: };",
          "1867: #if CONFIG_FFV1_ENCODER",
          "1868: AVCodec ff_ffv1_encoder = {",
          "1869:     .name           = \"ffv1\",",
          "1870:     .type           = AVMEDIA_TYPE_VIDEO,",
          "1871:     .id             = AV_CODEC_ID_FFV1,",
          "1872:     .priv_data_size = sizeof(FFV1Context),",
          "1873:     .init           = encode_init,",
          "1874:     .encode2        = encode_frame,",
          "1875:     .close          = common_end,",
          "1876:     .capabilities   = CODEC_CAP_SLICE_THREADS,",
          "1877:     .pix_fmts       = (const enum AVPixelFormat[]) {",
          "1878:         AV_PIX_FMT_YUV420P,   AV_PIX_FMT_YUV422P,   AV_PIX_FMT_YUV444P,",
          "1879:         AV_PIX_FMT_YUV411P,   AV_PIX_FMT_YUV410P,",
          "1880:         AV_PIX_FMT_YUV420P16, AV_PIX_FMT_YUV422P16, AV_PIX_FMT_YUV444P16,",
          "1881:         AV_PIX_FMT_RGB32,",
          "1882:         AV_PIX_FMT_NONE",
          "1883:     },",
          "1884:     .long_name      = NULL_IF_CONFIG_SMALL(\"FFmpeg video codec #1\"),",
          "1885: };",
          "1886: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "libavcodec/ffv1.h||libavcodec/ffv1.h": [
          "File: libavcodec/ffv1.h -> libavcodec/ffv1.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: #ifndef AVCODEC_FFV1_H",
          "24: #define AVCODEC_FFV1_H",
          "25: #include \"avcodec.h\"",
          "27: #define MAX_PLANES 4",
          "28: #define CONTEXT_SIZE 32",
          "30: #define MAX_QUANT_TABLES 8",
          "31: #define MAX_CONTEXT_INPUTS 5",
          "33: extern const uint8_t ff_log2_run[41];",
          "35: extern const int8_t ffv1_quant5_10bit[256];",
          "36: extern const int8_t ffv1_quant5[256];",
          "37: extern const int8_t ffv1_quant9_10bit[256];",
          "38: extern const int8_t ffv1_quant11[256];",
          "39: extern const uint8_t ffv1_ver2_state[256];",
          "41: typedef struct VlcState {",
          "42:     int16_t drift;",
          "43:     uint16_t error_sum;",
          "44:     int8_t bias;",
          "45:     uint8_t count;",
          "46: } VlcState;",
          "48: typedef struct PlaneContext {",
          "49:     int16_t quant_table[MAX_CONTEXT_INPUTS][256];",
          "50:     int quant_table_index;",
          "51:     int context_count;",
          "52:     uint8_t (*state)[CONTEXT_SIZE];",
          "53:     VlcState *vlc_state;",
          "54:     uint8_t interlace_bit_state[2];",
          "55: } PlaneContext;",
          "57: #define MAX_SLICES 256",
          "59: typedef struct FFV1Context {",
          "60:     AVCodecContext *avctx;",
          "61:     RangeCoder c;",
          "62:     GetBitContext gb;",
          "63:     PutBitContext pb;",
          "64:     uint64_t rc_stat[256][2];",
          "65:     uint64_t (*rc_stat2[MAX_QUANT_TABLES])[32][2];",
          "66:     int version;",
          "67:     int width, height;",
          "68:     int chroma_h_shift, chroma_v_shift;",
          "69:     int flags;",
          "70:     int picture_number;",
          "71:     AVFrame picture;",
          "72:     int plane_count;",
          "73:     int ac;     // 1 = range coder <-> 0 = golomb rice",
          "74:     PlaneContext plane[MAX_PLANES];",
          "75:     int16_t quant_table[MAX_CONTEXT_INPUTS][256];",
          "76:     int16_t quant_tables[MAX_QUANT_TABLES][MAX_CONTEXT_INPUTS][256];",
          "77:     int context_count[MAX_QUANT_TABLES];",
          "78:     uint8_t state_transition[256];",
          "79:     uint8_t (*initial_states[MAX_QUANT_TABLES])[32];",
          "80:     int run_index;",
          "81:     int colorspace;",
          "82:     int16_t *sample_buffer;",
          "83:     int gob_count;",
          "85:     int quant_table_count;",
          "87:     DSPContext dsp;",
          "89:     struct FFV1Context *slice_context[MAX_SLICES];",
          "90:     int slice_count;",
          "91:     int num_v_slices;",
          "92:     int num_h_slices;",
          "93:     int slice_width;",
          "94:     int slice_height;",
          "95:     int slice_x;",
          "96:     int slice_y;",
          "97: } FFV1Context;",
          "99: static av_always_inline int fold(int diff, int bits)",
          "100: {",
          "101:     if (bits == 8)",
          "102:         diff = (int8_t)diff;",
          "103:     else {",
          "104:         diff +=  1 << (bits  - 1);",
          "105:         diff &= (1 <<  bits) - 1;",
          "106:         diff -=  1 << (bits  - 1);",
          "107:     }",
          "109:     return diff;",
          "110: }",
          "112: static inline int predict(int16_t *src, int16_t *last)",
          "113: {",
          "114:     const int LT = last[-1];",
          "115:     const int T  = last[0];",
          "116:     const int L  = src[-1];",
          "118:     return mid_pred(L, L + T - LT, T);",
          "119: }",
          "121: static inline int get_context(PlaneContext *p, int16_t *src,",
          "122:                               int16_t *last, int16_t *last2)",
          "123: {",
          "124:     const int LT = last[-1];",
          "125:     const int T  = last[0];",
          "126:     const int RT = last[1];",
          "127:     const int L  = src[-1];",
          "129:     if (p->quant_table[3][127]) {",
          "130:         const int TT = last2[0];",
          "131:         const int LL = src[-2];",
          "132:         return p->quant_table[0][(L - LT) & 0xFF] +",
          "133:                p->quant_table[1][(LT - T) & 0xFF] +",
          "134:                p->quant_table[2][(T - RT) & 0xFF] +",
          "135:                p->quant_table[3][(LL - L) & 0xFF] +",
          "136:                p->quant_table[4][(TT - T) & 0xFF];",
          "137:     } else",
          "138:         return p->quant_table[0][(L - LT) & 0xFF] +",
          "139:                p->quant_table[1][(LT - T) & 0xFF] +",
          "140:                p->quant_table[2][(T - RT) & 0xFF];",
          "141: }",
          "143: static inline void update_vlc_state(VlcState *const state, const int v)",
          "144: {",
          "145:     int drift = state->drift;",
          "146:     int count = state->count;",
          "147:     state->error_sum += FFABS(v);",
          "148:     drift            += v;",
          "150:     if (count == 128) { // FIXME: variable",
          "151:         count            >>= 1;",
          "152:         drift            >>= 1;",
          "153:         state->error_sum >>= 1;",
          "154:     }",
          "155:     count++;",
          "157:     if (drift <= -count) {",
          "158:         if (state->bias > -128)",
          "159:             state->bias--;",
          "161:         drift += count;",
          "162:         if (drift <= -count)",
          "163:             drift = -count + 1;",
          "164:     } else if (drift > 0) {",
          "165:         if (state->bias < 127)",
          "166:             state->bias++;",
          "168:         drift -= count;",
          "169:         if (drift > 0)",
          "170:             drift = 0;",
          "171:     }",
          "173:     state->drift = drift;",
          "174:     state->count = count;",
          "175: }",
          "177: int ffv1_common_init(AVCodecContext *avctx);",
          "178: int ffv1_init_slice_state(FFV1Context *f);",
          "179: int ffv1_init_slice_contexts(FFV1Context *f);",
          "180: int ffv1_allocate_initial_states(FFV1Context *f);",
          "181: void ffv1_clear_state(FFV1Context *f);",
          "182: int ffv1_close(AVCodecContext *avctx);",
          "",
          "---------------"
        ],
        "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c": [
          "File: libavcodec/ffv1dec.c -> libavcodec/ffv1dec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: #include \"libavutil/avassert.h\"",
          "29: #include \"avcodec.h\"",
          "30: #include \"get_bits.h\"",
          "31: #include \"put_bits.h\"",
          "32: #include \"dsputil.h\"",
          "33: #include \"rangecoder.h\"",
          "34: #include \"golomb.h\"",
          "35: #include \"mathops.h\"",
          "36: #include \"ffv1.h\"",
          "38: static inline av_flatten int get_symbol_inline(RangeCoder *c, uint8_t *state,",
          "39:                                                int is_signed)",
          "40: {",
          "41:     if (get_rac(c, state + 0))",
          "42:         return 0;",
          "43:     else {",
          "44:         int i, e, a;",
          "45:         e = 0;",
          "46:         while (get_rac(c, state + 1 + FFMIN(e, 9))) // 1..10",
          "47:             e++;",
          "49:         a = 1;",
          "50:         for (i = e - 1; i >= 0; i--)",
          "51:             a += a + get_rac(c, state + 22 + FFMIN(i, 9));  // 22..31",
          "53:         e = -(is_signed && get_rac(c, state + 11 + FFMIN(e, 10))); // 11..21",
          "54:         return (a ^ e) - e;",
          "55:     }",
          "56: }",
          "58: static av_noinline int get_symbol(RangeCoder *c, uint8_t *state, int is_signed)",
          "59: {",
          "60:     return get_symbol_inline(c, state, is_signed);",
          "61: }",
          "63: static inline int get_vlc_symbol(GetBitContext *gb, VlcState *const state,",
          "64:                                  int bits)",
          "65: {",
          "66:     int k, i, v, ret;",
          "68:     i = state->count;",
          "69:     k = 0;",
          "70:     while (i < state->error_sum) { // FIXME: optimize",
          "71:         k++;",
          "72:         i += i;",
          "73:     }",
          "75:     assert(k <= 8);",
          "77:     v = get_sr_golomb(gb, k, 12, bits);",
          "78:     av_dlog(NULL, \"v:%d bias:%d error:%d drift:%d count:%d k:%d\",",
          "79:             v, state->bias, state->error_sum, state->drift, state->count, k);",
          "81: #if 0 // JPEG LS",
          "82:     if (k == 0 && 2 * state->drift <= -state->count)",
          "83:         v ^= (-1);",
          "84: #else",
          "85:     v ^= ((2 * state->drift + state->count) >> 31);",
          "86: #endif",
          "88:     ret = fold(v + state->bias, bits);",
          "90:     update_vlc_state(state, v);",
          "92:     return ret;",
          "93: }",
          "95: static av_always_inline void decode_line(FFV1Context *s, int w,",
          "96:                                          int16_t *sample[2],",
          "97:                                          int plane_index, int bits)",
          "98: {",
          "99:     PlaneContext *const p = &s->plane[plane_index];",
          "100:     RangeCoder *const c   = &s->c;",
          "101:     int x;",
          "102:     int run_count = 0;",
          "103:     int run_mode  = 0;",
          "104:     int run_index = s->run_index;",
          "106:     for (x = 0; x < w; x++) {",
          "107:         int diff, context, sign;",
          "109:         context = get_context(p, sample[1] + x, sample[0] + x, sample[1] + x);",
          "110:         if (context < 0) {",
          "111:             context = -context;",
          "112:             sign    = 1;",
          "113:         } else",
          "114:             sign = 0;",
          "116:         av_assert2(context < p->context_count);",
          "118:         if (s->ac) {",
          "119:             diff = get_symbol_inline(c, p->state[context], 1);",
          "120:         } else {",
          "121:             if (context == 0 && run_mode == 0)",
          "122:                 run_mode = 1;",
          "124:             if (run_mode) {",
          "125:                 if (run_count == 0 && run_mode == 1) {",
          "126:                     if (get_bits1(&s->gb)) {",
          "127:                         run_count = 1 << ff_log2_run[run_index];",
          "128:                         if (x + run_count <= w)",
          "129:                             run_index++;",
          "130:                     } else {",
          "131:                         if (ff_log2_run[run_index])",
          "132:                             run_count = get_bits(&s->gb, ff_log2_run[run_index]);",
          "133:                         else",
          "134:                             run_count = 0;",
          "135:                         if (run_index)",
          "136:                             run_index--;",
          "137:                         run_mode = 2;",
          "138:                     }",
          "139:                 }",
          "140:                 run_count--;",
          "141:                 if (run_count < 0) {",
          "142:                     run_mode  = 0;",
          "143:                     run_count = 0;",
          "144:                     diff      = get_vlc_symbol(&s->gb, &p->vlc_state[context],",
          "145:                                                bits);",
          "146:                     if (diff >= 0)",
          "147:                         diff++;",
          "148:                 } else",
          "149:                     diff = 0;",
          "150:             } else",
          "151:                 diff = get_vlc_symbol(&s->gb, &p->vlc_state[context], bits);",
          "153:             av_dlog(s->avctx, \"count:%d index:%d, mode:%d, x:%d pos:%d\\n\",",
          "154:                     run_count, run_index, run_mode, x, get_bits_count(&s->gb));",
          "155:         }",
          "157:         if (sign)",
          "158:             diff = -diff;",
          "160:         sample[1][x] = (predict(sample[1] + x, sample[0] + x) + diff) &",
          "161:                        ((1 << bits) - 1);",
          "162:     }",
          "163:     s->run_index = run_index;",
          "164: }",
          "166: static void decode_plane(FFV1Context *s, uint8_t *src,",
          "167:                          int w, int h, int stride, int plane_index)",
          "168: {",
          "169:     int x, y;",
          "170:     int16_t *sample[2];",
          "171:     sample[0] = s->sample_buffer + 3;",
          "172:     sample[1] = s->sample_buffer + w + 6 + 3;",
          "174:     s->run_index = 0;",
          "176:     memset(s->sample_buffer, 0, 2 * (w + 6) * sizeof(*s->sample_buffer));",
          "178:     for (y = 0; y < h; y++) {",
          "179:         int16_t *temp = sample[0]; // FIXME: try a normal buffer",
          "181:         sample[0] = sample[1];",
          "182:         sample[1] = temp;",
          "184:         sample[1][-1] = sample[0][0];",
          "185:         sample[0][w]  = sample[0][w - 1];",
          "188:         if (s->avctx->bits_per_raw_sample <= 8) {",
          "189:             decode_line(s, w, sample, plane_index, 8);",
          "190:             for (x = 0; x < w; x++)",
          "191:                 src[x + stride * y] = sample[1][x];",
          "192:         } else {",
          "193:             decode_line(s, w, sample, plane_index,",
          "194:                         s->avctx->bits_per_raw_sample);",
          "195:             for (x = 0; x < w; x++)",
          "196:                 ((uint16_t *)(src + stride * y))[x] =",
          "197:                     sample[1][x] << (16 - s->avctx->bits_per_raw_sample);",
          "198:         }",
          "200:     }",
          "201: }",
          "203: static void decode_rgb_frame(FFV1Context *s, uint32_t *src,",
          "204:                              int w, int h, int stride)",
          "205: {",
          "206:     int x, y, p;",
          "207:     int16_t *sample[3][2];",
          "208:     for (x = 0; x < 3; x++) {",
          "209:         sample[x][0] = s->sample_buffer +  x * 2      * (w + 6) + 3;",
          "210:         sample[x][1] = s->sample_buffer + (x * 2 + 1) * (w + 6) + 3;",
          "211:     }",
          "213:     s->run_index = 0;",
          "215:     memset(s->sample_buffer, 0, 6 * (w + 6) * sizeof(*s->sample_buffer));",
          "217:     for (y = 0; y < h; y++) {",
          "218:         for (p = 0; p < 3; p++) {",
          "219:             int16_t *temp = sample[p][0]; // FIXME: try a normal buffer",
          "221:             sample[p][0] = sample[p][1];",
          "222:             sample[p][1] = temp;",
          "224:             sample[p][1][-1] = sample[p][0][0];",
          "225:             sample[p][0][w]  = sample[p][0][w - 1];",
          "226:             decode_line(s, w, sample[p], FFMIN(p, 1), 9);",
          "227:         }",
          "228:         for (x = 0; x < w; x++) {",
          "229:             int g = sample[0][1][x];",
          "230:             int b = sample[1][1][x];",
          "231:             int r = sample[2][1][x];",
          "236:             b -= 0x100;",
          "237:             r -= 0x100;",
          "238:             g -= (b + r) >> 2;",
          "239:             b += g;",
          "240:             r += g;",
          "242:             src[x + stride * y] = b + (g << 8) + (r << 16) + (0xFF << 24);",
          "243:         }",
          "244:     }",
          "245: }",
          "247: static int decode_slice(AVCodecContext *c, void *arg)",
          "248: {",
          "249:     FFV1Context *fs  = *(void **)arg;",
          "250:     FFV1Context *f   = fs->avctx->priv_data;",
          "251:     int width        = fs->slice_width;",
          "252:     int height       = fs->slice_height;",
          "253:     int x            = fs->slice_x;",
          "254:     int y            = fs->slice_y;",
          "255:     AVFrame *const p = &f->picture;",
          "257:     av_assert1(width && height);",
          "258:     if (f->colorspace == 0) {",
          "259:         const int chroma_width  = -((-width)  >> f->chroma_h_shift);",
          "260:         const int chroma_height = -((-height) >> f->chroma_v_shift);",
          "261:         const int cx            = x >> f->chroma_h_shift;",
          "262:         const int cy            = y >> f->chroma_v_shift;",
          "264:         decode_plane(fs, p->data[0] + x + y * p->linesize[0],",
          "265:                      width, height, p->linesize[0], 0);",
          "267:         decode_plane(fs, p->data[1] + cx + cy * p->linesize[1],",
          "268:                      chroma_width, chroma_height, p->linesize[1], 1);",
          "269:         decode_plane(fs, p->data[2] + cx + cy * p->linesize[1],",
          "270:                      chroma_width, chroma_height, p->linesize[2], 1);",
          "271:     } else {",
          "272:         decode_rgb_frame(fs,",
          "273:                          (uint32_t *)p->data[0] + x + y * (p->linesize[0] / 4),",
          "274:                          width, height, p->linesize[0] / 4);",
          "275:     }",
          "277:     emms_c();",
          "279:     return 0;",
          "280: }",
          "282: static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)",
          "283: {",
          "284:     int v;",
          "285:     int i = 0;",
          "286:     uint8_t state[CONTEXT_SIZE];",
          "288:     memset(state, 128, sizeof(state));",
          "290:     for (v = 0; i < 128; v++) {",
          "291:         int len = get_symbol(c, state, 0) + 1;",
          "293:         if (len + i > 128)",
          "294:             return -1;",
          "296:         while (len--) {",
          "297:             quant_table[i] = scale * v;",
          "298:             i++;",
          "299:         }",
          "300:     }",
          "302:     for (i = 1; i < 128; i++)",
          "303:         quant_table[256 - i] = -quant_table[i];",
          "304:     quant_table[128] = -quant_table[127];",
          "306:     return 2 * v - 1;",
          "307: }",
          "309: static int read_quant_tables(RangeCoder *c,",
          "310:                              int16_t quant_table[MAX_CONTEXT_INPUTS][256])",
          "311: {",
          "312:     int i;",
          "313:     int context_count = 1;",
          "315:     for (i = 0; i < 5; i++) {",
          "316:         context_count *= read_quant_table(c, quant_table[i], context_count);",
          "317:         if (context_count > 32768U) {",
          "318:             return -1;",
          "319:         }",
          "320:     }",
          "321:     return (context_count + 1) / 2;",
          "322: }",
          "324: static int read_extra_header(FFV1Context *f)",
          "325: {",
          "326:     RangeCoder *const c = &f->c;",
          "327:     uint8_t state[CONTEXT_SIZE];",
          "328:     int i, j, k;",
          "329:     uint8_t state2[32][CONTEXT_SIZE];",
          "331:     memset(state2, 128, sizeof(state2));",
          "332:     memset(state, 128, sizeof(state));",
          "334:     ff_init_range_decoder(c, f->avctx->extradata, f->avctx->extradata_size);",
          "335:     ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);",
          "337:     f->version = get_symbol(c, state, 0);",
          "338:     f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);",
          "339:     if (f->ac > 1)",
          "340:         for (i = 1; i < 256; i++)",
          "341:             f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];",
          "342:     f->colorspace                 = get_symbol(c, state, 0); // YUV cs type",
          "343:     f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);",
          "344:     get_rac(c, state); // no chroma = false",
          "345:     f->chroma_h_shift = get_symbol(c, state, 0);",
          "346:     f->chroma_v_shift = get_symbol(c, state, 0);",
          "347:     get_rac(c, state); // transparency plane",
          "348:     f->plane_count  = 2;",
          "349:     f->num_h_slices = 1 + get_symbol(c, state, 0);",
          "350:     f->num_v_slices = 1 + get_symbol(c, state, 0);",
          "352:     if (f->num_h_slices > (unsigned)f->width ||",
          "353:         f->num_v_slices > (unsigned)f->height) {",
          "354:         av_log(f->avctx, AV_LOG_ERROR, \"too many slices\\n\");",
          "355:         return -1;",
          "356:     }",
          "358:     f->quant_table_count = get_symbol(c, state, 0);",
          "360:     if (f->quant_table_count > (unsigned)MAX_QUANT_TABLES)",
          "361:         return -1;",
          "363:     for (i = 0; i < f->quant_table_count; i++) {",
          "364:         f->context_count[i] = read_quant_tables(c, f->quant_tables[i]);",
          "365:         if (f->context_count[i] < 0) {",
          "366:             av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");",
          "367:             return -1;",
          "368:         }",
          "369:     }",
          "371:     if (ffv1_allocate_initial_states(f) < 0)",
          "372:         return AVERROR(ENOMEM);",
          "374:     for (i = 0; i < f->quant_table_count; i++)",
          "375:         if (get_rac(c, state))",
          "376:             for (j = 0; j < f->context_count[i]; j++)",
          "377:                 for (k = 0; k < CONTEXT_SIZE; k++) {",
          "378:                     int pred = j ? f->initial_states[i][j - 1][k] : 128;",
          "379:                     f->initial_states[i][j][k] =",
          "380:                         (pred + get_symbol(c, state2[k], 1)) & 0xFF;",
          "381:                 }",
          "382:     return 0;",
          "383: }",
          "385: static int read_header(FFV1Context *f)",
          "386: {",
          "387:     uint8_t state[CONTEXT_SIZE];",
          "388:     int i, j, context_count;",
          "389:     RangeCoder *const c = &f->slice_context[0]->c;",
          "391:     memset(state, 128, sizeof(state));",
          "393:     if (f->version < 2) {",
          "394:         f->version = get_symbol(c, state, 0);",
          "395:         f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);",
          "396:         if (f->ac > 1)",
          "397:             for (i = 1; i < 256; i++)",
          "398:                 f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];",
          "399:         f->colorspace = get_symbol(c, state, 0); // YUV cs type",
          "400:         if (f->version > 0)",
          "401:             f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);",
          "402:         get_rac(c, state); // no chroma = false",
          "403:         f->chroma_h_shift = get_symbol(c, state, 0);",
          "404:         f->chroma_v_shift = get_symbol(c, state, 0);",
          "405:         get_rac(c, state); // transparency plane",
          "406:         f->plane_count = 2;",
          "407:     }",
          "409:     if (f->colorspace == 0) {",
          "410:         if (f->avctx->bits_per_raw_sample <= 8) {",
          "411:             switch (16 * f->chroma_h_shift + f->chroma_v_shift) {",
          "412:             case 0x00:",
          "413:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV444P;",
          "414:                 break;",
          "415:             case 0x10:",
          "416:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV422P;",
          "417:                 break;",
          "418:             case 0x11:",
          "419:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV420P;",
          "420:                 break;",
          "421:             case 0x20:",
          "422:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV411P;",
          "423:                 break;",
          "424:             case 0x22:",
          "425:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV410P;",
          "426:                 break;",
          "427:             default:",
          "428:                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "429:                 return -1;",
          "430:             }",
          "431:         } else {",
          "432:             switch (16 * f->chroma_h_shift + f->chroma_v_shift) {",
          "433:             case 0x00:",
          "434:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16;",
          "435:                 break;",
          "436:             case 0x10:",
          "437:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16;",
          "438:                 break;",
          "439:             case 0x11:",
          "440:                 f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16;",
          "441:                 break;",
          "442:             default:",
          "443:                 av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "444:                 return -1;",
          "445:             }",
          "446:         }",
          "447:     } else if (f->colorspace == 1) {",
          "448:         if (f->chroma_h_shift || f->chroma_v_shift) {",
          "449:             av_log(f->avctx, AV_LOG_ERROR,",
          "450:                    \"chroma subsampling not supported in this colorspace\\n\");",
          "451:             return -1;",
          "452:         }",
          "453:         f->avctx->pix_fmt = AV_PIX_FMT_RGB32;",
          "454:     } else {",
          "455:         av_log(f->avctx, AV_LOG_ERROR, \"colorspace not supported\\n\");",
          "456:         return -1;",
          "457:     }",
          "459:     av_dlog(f->avctx, \"%d %d %d\\n\",",
          "460:             f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);",
          "462:     if (f->version < 2) {",
          "463:         context_count = read_quant_tables(c, f->quant_table);",
          "464:         if (context_count < 0) {",
          "465:             av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");",
          "466:             return -1;",
          "467:         }",
          "468:     } else {",
          "469:         f->slice_count = get_symbol(c, state, 0);",
          "470:         if (f->slice_count > (unsigned)MAX_SLICES)",
          "471:             return -1;",
          "472:     }",
          "474:     for (j = 0; j < f->slice_count; j++) {",
          "475:         FFV1Context *fs = f->slice_context[j];",
          "476:         fs->ac = f->ac;",
          "478:         if (f->version >= 2) {",
          "479:             fs->slice_x      = get_symbol(c, state, 0) * f->width;",
          "480:             fs->slice_y      = get_symbol(c, state, 0) * f->height;",
          "481:             fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;",
          "482:             fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;",
          "484:             fs->slice_x     /= f->num_h_slices;",
          "485:             fs->slice_y     /= f->num_v_slices;",
          "486:             fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;",
          "487:             fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;",
          "488:             if ((unsigned)fs->slice_width  > f->width ||",
          "489:                 (unsigned)fs->slice_height > f->height)",
          "490:                 return -1;",
          "491:             if ((unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width ||",
          "492:                 (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)",
          "493:                 return -1;",
          "494:         }",
          "496:         for (i = 0; i < f->plane_count; i++) {",
          "497:             PlaneContext *const p = &fs->plane[i];",
          "499:             if (f->version >= 2) {",
          "500:                 int idx = get_symbol(c, state, 0);",
          "501:                 if (idx > (unsigned)f->quant_table_count) {",
          "502:                     av_log(f->avctx, AV_LOG_ERROR,",
          "503:                            \"quant_table_index out of range\\n\");",
          "504:                     return -1;",
          "505:                 }",
          "506:                 p->quant_table_index = idx;",
          "507:                 memcpy(p->quant_table, f->quant_tables[idx],",
          "508:                        sizeof(p->quant_table));",
          "509:                 context_count = f->context_count[idx];",
          "510:             } else {",
          "511:                 memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));",
          "512:             }",
          "514:             if (p->context_count < context_count) {",
          "515:                 av_freep(&p->state);",
          "516:                 av_freep(&p->vlc_state);",
          "517:             }",
          "518:             p->context_count = context_count;",
          "519:         }",
          "520:     }",
          "522:     return 0;",
          "523: }",
          "525: static av_cold int ffv1_decode_init(AVCodecContext *avctx)",
          "526: {",
          "527:     FFV1Context *f = avctx->priv_data;",
          "529:     ffv1_common_init(avctx);",
          "531:     if (avctx->extradata && read_extra_header(f) < 0)",
          "532:         return -1;",
          "534:     if (ffv1_init_slice_contexts(f) < 0)",
          "535:         return -1;",
          "537:     return 0;",
          "538: }",
          "540: static int ffv1_decode_frame(AVCodecContext *avctx, void *data,",
          "541:                              int *data_size, AVPacket *avpkt)",
          "542: {",
          "543:     const uint8_t *buf  = avpkt->data;",
          "544:     int buf_size        = avpkt->size;",
          "545:     FFV1Context *f      = avctx->priv_data;",
          "546:     RangeCoder *const c = &f->slice_context[0]->c;",
          "547:     AVFrame *const p    = &f->picture;",
          "548:     int bytes_read, i;",
          "549:     uint8_t keystate = 128;",
          "550:     const uint8_t *buf_p;",
          "552:     AVFrame *picture = data;",
          "555:     if (p->data[0])",
          "556:         avctx->release_buffer(avctx, p);",
          "558:     ff_init_range_decoder(c, buf, buf_size);",
          "559:     ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);",
          "561:     p->pict_type = AV_PICTURE_TYPE_I; // FIXME: I vs. P",
          "562:     if (get_rac(c, &keystate)) {",
          "563:         p->key_frame = 1;",
          "564:         if (read_header(f) < 0)",
          "565:             return -1;",
          "566:         if (ffv1_init_slice_state(f) < 0)",
          "567:             return -1;",
          "569:         ffv1_clear_state(f);",
          "570:     } else {",
          "571:         p->key_frame = 0;",
          "572:     }",
          "573:     if (f->ac > 1) {",
          "574:         int i;",
          "575:         for (i = 1; i < 256; i++) {",
          "576:             c->one_state[i]        = f->state_transition[i];",
          "577:             c->zero_state[256 - i] = 256 - c->one_state[i];",
          "578:         }",
          "579:     }",
          "581:     p->reference = 0;",
          "582:     if (avctx->get_buffer(avctx, p) < 0) {",
          "583:         av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");",
          "584:         return -1;",
          "585:     }",
          "587:     if (avctx->debug & FF_DEBUG_PICT_INFO)",
          "588:         av_log(avctx, AV_LOG_ERROR, \"keyframe:%d coder:%d\\n\", p->key_frame, f->ac);",
          "590:     if (!f->ac) {",
          "591:         bytes_read = c->bytestream - c->bytestream_start - 1;",
          "592:         if (bytes_read == 0)",
          "593:             av_log(avctx, AV_LOG_ERROR, \"error at end of AC stream\\n\"); // FIXME",
          "594:         init_get_bits(&f->slice_context[0]->gb, buf + bytes_read,",
          "595:                       (buf_size - bytes_read) * 8);",
          "596:     } else {",
          "598:     }",
          "600:     buf_p = buf + buf_size;",
          "601:     for (i = f->slice_count - 1; i > 0; i--) {",
          "602:         FFV1Context *fs = f->slice_context[i];",
          "603:         int v           = AV_RB24(buf_p - 3) + 3;",
          "604:         if (buf_p - buf <= v) {",
          "605:             av_log(avctx, AV_LOG_ERROR, \"Slice pointer chain broken\\n\");",
          "606:             return -1;",
          "607:         }",
          "608:         buf_p -= v;",
          "609:         if (fs->ac)",
          "610:             ff_init_range_decoder(&fs->c, buf_p, v);",
          "611:         else",
          "612:             init_get_bits(&fs->gb, buf_p, v * 8);",
          "613:     }",
          "615:     avctx->execute(avctx, decode_slice, &f->slice_context[0],",
          "616:                    NULL, f->slice_count, sizeof(void *));",
          "617:     f->picture_number++;",
          "622:     return buf_size;",
          "623: }",
          "625: AVCodec ff_ffv1_decoder = {",
          "626:     .name           = \"ffv1\",",
          "627:     .type           = AVMEDIA_TYPE_VIDEO,",
          "628:     .id             = AV_CODEC_ID_FFV1,",
          "629:     .priv_data_size = sizeof(FFV1Context),",
          "630:     .init           = ffv1_decode_init,",
          "631:     .close          = ffv1_close,",
          "632:     .decode         = ffv1_decode_frame,",
          "633:     .capabilities   = CODEC_CAP_DR1 /*| CODEC_CAP_DRAW_HORIZ_BAND*/ |",
          "634:                       CODEC_CAP_SLICE_THREADS,",
          "635:     .long_name      = NULL_IF_CONFIG_SMALL(\"FFmpeg video codec #1\"),",
          "636: };",
          "",
          "---------------"
        ],
        "libavcodec/ffv1enc.c||libavcodec/ffv1enc.c": [
          "File: libavcodec/ffv1enc.c -> libavcodec/ffv1enc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: #include \"libavutil/avassert.h\"",
          "29: #include \"avcodec.h\"",
          "30: #include \"get_bits.h\"",
          "31: #include \"put_bits.h\"",
          "32: #include \"dsputil.h\"",
          "33: #include \"rangecoder.h\"",
          "34: #include \"golomb.h\"",
          "35: #include \"mathops.h\"",
          "36: #include \"ffv1.h\"",
          "38: static void find_best_state(uint8_t best_state[256][256],",
          "39:                             const uint8_t one_state[256])",
          "40: {",
          "41:     int i, j, k, m;",
          "42:     double l2tab[256];",
          "44:     for (i = 1; i < 256; i++)",
          "45:         l2tab[i] = log2(i / 256.0);",
          "47:     for (i = 0; i < 256; i++) {",
          "48:         double best_len[256];",
          "49:         double p = i / 256.0;",
          "51:         for (j = 0; j < 256; j++)",
          "52:             best_len[j] = 1 << 30;",
          "54:         for (j = FFMAX(i - 10, 1); j < FFMIN(i + 11, 256); j++) {",
          "55:             double occ[256] = { 0 };",
          "56:             double len      = 0;",
          "57:             occ[j] = 1.0;",
          "58:             for (k = 0; k < 256; k++) {",
          "59:                 double newocc[256] = { 0 };",
          "60:                 for (m = 0; m < 256; m++)",
          "61:                     if (occ[m]) {",
          "62:                         len -= occ[m] *     (p  * l2tab[m] +",
          "63:                                         (1 - p) * l2tab[256 - m]);",
          "64:                     }",
          "65:                 if (len < best_len[k]) {",
          "66:                     best_len[k]      = len;",
          "67:                     best_state[i][k] = j;",
          "68:                 }",
          "69:                 for (m = 0; m < 256; m++)",
          "70:                     if (occ[m]) {",
          "71:                         newocc[one_state[m]]             += occ[m] * p;",
          "72:                         newocc[256 - one_state[256 - m]] += occ[m] * (1 - p);",
          "73:                     }",
          "74:                 memcpy(occ, newocc, sizeof(occ));",
          "75:             }",
          "76:         }",
          "77:     }",
          "78: }",
          "80: static av_always_inline av_flatten void put_symbol_inline(RangeCoder *c,",
          "81:                                                           uint8_t *state, int v,",
          "82:                                                           int is_signed,",
          "83:                                                           uint64_t rc_stat[256][2],",
          "84:                                                           uint64_t rc_stat2[32][2])",
          "85: {",
          "86:     int i;",
          "88: #define put_rac(C, S, B)                        \\",
          "89:     do {                                        \\",
          "90:         if (rc_stat) {                          \\",
          "91:             rc_stat[*(S)][B]++;                 \\",
          "92:             rc_stat2[(S) - state][B]++;         \\",
          "93:         }                                       \\",
          "94:         put_rac(C, S, B);                       \\",
          "95:     } while (0)",
          "97:     if (v) {",
          "98:         const int a = FFABS(v);",
          "99:         const int e = av_log2(a);",
          "100:         put_rac(c, state + 0, 0);",
          "101:         if (e <= 9) {",
          "102:             for (i = 0; i < e; i++)",
          "103:                 put_rac(c, state + 1 + i, 1);  // 1..10",
          "104:             put_rac(c, state + 1 + i, 0);",
          "106:             for (i = e - 1; i >= 0; i--)",
          "107:                 put_rac(c, state + 22 + i, (a >> i) & 1);  // 22..31",
          "109:             if (is_signed)",
          "110:                 put_rac(c, state + 11 + e, v < 0);  // 11..21",
          "111:         } else {",
          "112:             for (i = 0; i < e; i++)",
          "113:                 put_rac(c, state + 1 + FFMIN(i, 9), 1);  // 1..10",
          "114:             put_rac(c, state + 1 + 9, 0);",
          "116:             for (i = e - 1; i >= 0; i--)",
          "117:                 put_rac(c, state + 22 + FFMIN(i, 9), (a >> i) & 1);  // 22..31",
          "119:             if (is_signed)",
          "120:                 put_rac(c, state + 11 + 10, v < 0);  // 11..21",
          "121:         }",
          "122:     } else {",
          "123:         put_rac(c, state + 0, 1);",
          "124:     }",
          "125: #undef put_rac",
          "126: }",
          "128: static av_noinline void put_symbol(RangeCoder *c, uint8_t *state,",
          "129:                                    int v, int is_signed)",
          "130: {",
          "131:     put_symbol_inline(c, state, v, is_signed, NULL, NULL);",
          "132: }",
          "134: static inline void put_vlc_symbol(PutBitContext *pb, VlcState *const state,",
          "135:                                   int v, int bits)",
          "136: {",
          "137:     int i, k, code;",
          "138:     v = fold(v - state->bias, bits);",
          "140:     i = state->count;",
          "141:     k = 0;",
          "142:     while (i < state->error_sum) { // FIXME: optimize",
          "143:         k++;",
          "144:         i += i;",
          "145:     }",
          "147:     assert(k <= 8);",
          "149: #if 0 // JPEG LS",
          "150:     if (k == 0 && 2 * state->drift <= -state->count)",
          "151:         code = v ^ (-1);",
          "152:     else",
          "153:         code = v;",
          "154: #else",
          "155:     code = v ^ ((2 * state->drift + state->count) >> 31);",
          "156: #endif",
          "158:     av_dlog(NULL, \"v:%d/%d bias:%d error:%d drift:%d count:%d k:%d\\n\", v, code,",
          "159:             state->bias, state->error_sum, state->drift, state->count, k);",
          "160:     set_sr_golomb(pb, code, k, 12, bits);",
          "162:     update_vlc_state(state, v);",
          "163: }",
          "165: static av_always_inline int encode_line(FFV1Context *s, int w,",
          "166:                                         int16_t *sample[3],",
          "167:                                         int plane_index, int bits)",
          "168: {",
          "169:     PlaneContext *const p = &s->plane[plane_index];",
          "170:     RangeCoder *const c   = &s->c;",
          "171:     int x;",
          "172:     int run_index = s->run_index;",
          "173:     int run_count = 0;",
          "174:     int run_mode  = 0;",
          "176:     if (s->ac) {",
          "177:         if (c->bytestream_end - c->bytestream < w * 20) {",
          "178:             av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");",
          "179:             return -1;",
          "180:         }",
          "181:     } else {",
          "182:         if (s->pb.buf_end - s->pb.buf - (put_bits_count(&s->pb) >> 3) < w * 4) {",
          "183:             av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");",
          "184:             return -1;",
          "185:         }",
          "186:     }",
          "188:     for (x = 0; x < w; x++) {",
          "189:         int diff, context;",
          "191:         context = get_context(p, sample[0] + x, sample[1] + x, sample[2] + x);",
          "192:         diff    = sample[0][x] - predict(sample[0] + x, sample[1] + x);",
          "194:         if (context < 0) {",
          "195:             context = -context;",
          "196:             diff    = -diff;",
          "197:         }",
          "199:         diff = fold(diff, bits);",
          "201:         if (s->ac) {",
          "202:             if (s->flags & CODEC_FLAG_PASS1) {",
          "203:                 put_symbol_inline(c, p->state[context], diff, 1, s->rc_stat,",
          "204:                                   s->rc_stat2[p->quant_table_index][context]);",
          "205:             } else {",
          "206:                 put_symbol_inline(c, p->state[context], diff, 1, NULL, NULL);",
          "207:             }",
          "208:         } else {",
          "209:             if (context == 0)",
          "210:                 run_mode = 1;",
          "212:             if (run_mode) {",
          "213:                 if (diff) {",
          "214:                     while (run_count >= 1 << ff_log2_run[run_index]) {",
          "215:                         run_count -= 1 << ff_log2_run[run_index];",
          "216:                         run_index++;",
          "217:                         put_bits(&s->pb, 1, 1);",
          "218:                     }",
          "220:                     put_bits(&s->pb, 1 + ff_log2_run[run_index], run_count);",
          "221:                     if (run_index)",
          "222:                         run_index--;",
          "223:                     run_count = 0;",
          "224:                     run_mode  = 0;",
          "225:                     if (diff > 0)",
          "226:                         diff--;",
          "227:                 } else {",
          "228:                     run_count++;",
          "229:                 }",
          "230:             }",
          "232:             av_dlog(s->avctx, \"count:%d index:%d, mode:%d, x:%d pos:%d\\n\",",
          "233:                     run_count, run_index, run_mode, x,",
          "234:                     (int)put_bits_count(&s->pb));",
          "236:             if (run_mode == 0)",
          "237:                 put_vlc_symbol(&s->pb, &p->vlc_state[context], diff, bits);",
          "238:         }",
          "239:     }",
          "240:     if (run_mode) {",
          "241:         while (run_count >= 1 << ff_log2_run[run_index]) {",
          "242:             run_count -= 1 << ff_log2_run[run_index];",
          "243:             run_index++;",
          "244:             put_bits(&s->pb, 1, 1);",
          "245:         }",
          "247:         if (run_count)",
          "248:             put_bits(&s->pb, 1, 1);",
          "249:     }",
          "250:     s->run_index = run_index;",
          "252:     return 0;",
          "253: }",
          "255: static void encode_plane(FFV1Context *s, uint8_t *src, int w, int h,",
          "256:                          int stride, int plane_index)",
          "257: {",
          "258:     int x, y, i;",
          "259:     const int ring_size = s->avctx->context_model ? 3 : 2;",
          "260:     int16_t *sample[3];",
          "261:     s->run_index = 0;",
          "263:     memset(s->sample_buffer, 0, ring_size * (w + 6) * sizeof(*s->sample_buffer));",
          "265:     for (y = 0; y < h; y++) {",
          "266:         for (i = 0; i < ring_size; i++)",
          "267:             sample[i] = s->sample_buffer + (w + 6) * ((h + i - y) % ring_size) + 3;",
          "269:         sample[0][-1] = sample[1][0];",
          "270:         sample[1][w]  = sample[1][w - 1];",
          "272:         if (s->avctx->bits_per_raw_sample <= 8) {",
          "273:             for (x = 0; x < w; x++)",
          "274:                 sample[0][x] = src[x + stride * y];",
          "275:             encode_line(s, w, sample, plane_index, 8);",
          "276:         } else {",
          "277:             for (x = 0; x < w; x++)",
          "278:                 sample[0][x] = ((uint16_t *)(src + stride * y))[x] >>",
          "279:                                (16 - s->avctx->bits_per_raw_sample);",
          "280:             encode_line(s, w, sample, plane_index, s->avctx->bits_per_raw_sample);",
          "281:         }",
          "283:     }",
          "284: }",
          "286: static void encode_rgb_frame(FFV1Context *s, uint32_t *src, int w, int h,",
          "287:                              int stride)",
          "288: {",
          "289:     int x, y, p, i;",
          "290:     const int ring_size = s->avctx->context_model ? 3 : 2;",
          "291:     int16_t *sample[3][3];",
          "292:     s->run_index = 0;",
          "294:     memset(s->sample_buffer, 0, ring_size * 3 * (w + 6) * sizeof(*s->sample_buffer));",
          "296:     for (y = 0; y < h; y++) {",
          "297:         for (i = 0; i < ring_size; i++)",
          "298:             for (p = 0; p < 3; p++)",
          "299:                 sample[p][i] = s->sample_buffer + p * ring_size * (w + 6) +",
          "300:                                ((h + i - y) % ring_size) * (w + 6) + 3;",
          "302:         for (x = 0; x < w; x++) {",
          "303:             int v = src[x + stride * y];",
          "304:             int b =  v        & 0xFF;",
          "305:             int g = (v >>  8) & 0xFF;",
          "306:             int r = (v >> 16) & 0xFF;",
          "308:             b -= g;",
          "309:             r -= g;",
          "310:             g += (b + r) >> 2;",
          "311:             b += 0x100;",
          "312:             r += 0x100;",
          "314:             sample[0][0][x] = g;",
          "315:             sample[1][0][x] = b;",
          "316:             sample[2][0][x] = r;",
          "317:         }",
          "318:         for (p = 0; p < 3; p++) {",
          "319:             sample[p][0][-1] = sample[p][1][0];",
          "320:             sample[p][1][w]  = sample[p][1][w - 1];",
          "321:             encode_line(s, w, sample[p], FFMIN(p, 1), 9);",
          "322:         }",
          "323:     }",
          "324: }",
          "326: static void write_quant_table(RangeCoder *c, int16_t *quant_table)",
          "327: {",
          "328:     int last = 0;",
          "329:     int i;",
          "330:     uint8_t state[CONTEXT_SIZE];",
          "331:     memset(state, 128, sizeof(state));",
          "333:     for (i = 1; i < 128; i++)",
          "334:         if (quant_table[i] != quant_table[i - 1]) {",
          "335:             put_symbol(c, state, i - last - 1, 0);",
          "336:             last = i;",
          "337:         }",
          "338:     put_symbol(c, state, i - last - 1, 0);",
          "339: }",
          "341: static void write_quant_tables(RangeCoder *c,",
          "342:                                int16_t quant_table[MAX_CONTEXT_INPUTS][256])",
          "343: {",
          "344:     int i;",
          "345:     for (i = 0; i < 5; i++)",
          "346:         write_quant_table(c, quant_table[i]);",
          "347: }",
          "349: static void write_header(FFV1Context *f)",
          "350: {",
          "351:     uint8_t state[CONTEXT_SIZE];",
          "352:     int i, j;",
          "353:     RangeCoder *const c = &f->slice_context[0]->c;",
          "355:     memset(state, 128, sizeof(state));",
          "357:     if (f->version < 2) {",
          "358:         put_symbol(c, state, f->version, 0);",
          "359:         put_symbol(c, state, f->ac, 0);",
          "360:         if (f->ac > 1) {",
          "361:             for (i = 1; i < 256; i++)",
          "362:                 put_symbol(c, state,",
          "363:                            f->state_transition[i] - c->one_state[i], 1);",
          "364:         }",
          "365:         put_symbol(c, state, f->colorspace, 0); // YUV cs type",
          "366:         if (f->version > 0)",
          "367:             put_symbol(c, state, f->avctx->bits_per_raw_sample, 0);",
          "368:         put_rac(c, state, 1); // chroma planes",
          "369:         put_symbol(c, state, f->chroma_h_shift, 0);",
          "370:         put_symbol(c, state, f->chroma_v_shift, 0);",
          "371:         put_rac(c, state, 0); // no transparency plane",
          "373:         write_quant_tables(c, f->quant_table);",
          "374:     } else {",
          "375:         put_symbol(c, state, f->slice_count, 0);",
          "376:         for (i = 0; i < f->slice_count; i++) {",
          "377:             FFV1Context *fs = f->slice_context[i];",
          "378:             put_symbol(c, state,",
          "379:                        (fs->slice_x      + 1) * f->num_h_slices / f->width, 0);",
          "380:             put_symbol(c, state,",
          "381:                        (fs->slice_y      + 1) * f->num_v_slices / f->height, 0);",
          "382:             put_symbol(c, state,",
          "383:                        (fs->slice_width  + 1) * f->num_h_slices / f->width - 1,",
          "384:                        0);",
          "385:             put_symbol(c, state,",
          "386:                        (fs->slice_height + 1) * f->num_v_slices / f->height - 1,",
          "387:                        0);",
          "388:             for (j = 0; j < f->plane_count; j++) {",
          "389:                 put_symbol(c, state, f->plane[j].quant_table_index, 0);",
          "390:                 av_assert0(f->plane[j].quant_table_index == f->avctx->context_model);",
          "391:             }",
          "392:         }",
          "393:     }",
          "394: }",
          "396: static int write_extra_header(FFV1Context *f)",
          "397: {",
          "398:     RangeCoder *const c = &f->c;",
          "399:     uint8_t state[CONTEXT_SIZE];",
          "400:     int i, j, k;",
          "401:     uint8_t state2[32][CONTEXT_SIZE];",
          "403:     memset(state2, 128, sizeof(state2));",
          "404:     memset(state, 128, sizeof(state));",
          "406:     f->avctx->extradata = av_malloc(f->avctx->extradata_size = 10000 +",
          "407:                                     (11 * 11 * 5 * 5 * 5 + 11 * 11 * 11) * 32);",
          "408:     ff_init_range_encoder(c, f->avctx->extradata, f->avctx->extradata_size);",
          "409:     ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);",
          "411:     put_symbol(c, state, f->version, 0);",
          "412:     put_symbol(c, state, f->ac, 0);",
          "413:     if (f->ac > 1)",
          "414:         for (i = 1; i < 256; i++)",
          "415:             put_symbol(c, state, f->state_transition[i] - c->one_state[i], 1);",
          "416:     put_symbol(c, state, f->colorspace, 0); // YUV cs type",
          "417:     put_symbol(c, state, f->avctx->bits_per_raw_sample, 0);",
          "418:     put_rac(c, state, 1); // chroma planes",
          "419:     put_symbol(c, state, f->chroma_h_shift, 0);",
          "420:     put_symbol(c, state, f->chroma_v_shift, 0);",
          "421:     put_rac(c, state, 0); // no transparency plane",
          "422:     put_symbol(c, state, f->num_h_slices - 1, 0);",
          "423:     put_symbol(c, state, f->num_v_slices - 1, 0);",
          "425:     put_symbol(c, state, f->quant_table_count, 0);",
          "426:     for (i = 0; i < f->quant_table_count; i++)",
          "427:         write_quant_tables(c, f->quant_tables[i]);",
          "429:     for (i = 0; i < f->quant_table_count; i++) {",
          "430:         for (j = 0; j < f->context_count[i] * CONTEXT_SIZE; j++)",
          "431:             if (f->initial_states[i] && f->initial_states[i][0][j] != 128)",
          "432:                 break;",
          "433:         if (j < f->context_count[i] * CONTEXT_SIZE) {",
          "434:             put_rac(c, state, 1);",
          "435:             for (j = 0; j < f->context_count[i]; j++)",
          "436:                 for (k = 0; k < CONTEXT_SIZE; k++) {",
          "437:                     int pred = j ? f->initial_states[i][j - 1][k] : 128;",
          "438:                     put_symbol(c, state2[k],",
          "439:                                (int8_t)(f->initial_states[i][j][k] - pred), 1);",
          "440:                 }",
          "441:         } else {",
          "442:             put_rac(c, state, 0);",
          "443:         }",
          "444:     }",
          "446:     f->avctx->extradata_size = ff_rac_terminate(c);",
          "448:     return 0;",
          "449: }",
          "451: static int sort_stt(FFV1Context *s, uint8_t stt[256])",
          "452: {",
          "453:     int i, i2, changed, print = 0;",
          "455:     do {",
          "456:         changed = 0;",
          "457:         for (i = 12; i < 244; i++) {",
          "458:             for (i2 = i + 1; i2 < 245 && i2 < i + 4; i2++) {",
          "460: #define COST(old, new)                                      \\",
          "461:     s->rc_stat[old][0] * -log2((256 - (new)) / 256.0) +     \\",
          "462:     s->rc_stat[old][1] * -log2((new)         / 256.0)",
          "464: #define COST2(old, new)                         \\",
          "465:     COST(old, new) + COST(256 - (old), 256 - (new))",
          "467:                 double size0 = COST2(i,  i) + COST2(i2, i2);",
          "468:                 double sizeX = COST2(i, i2) + COST2(i2, i);",
          "469:                 if (sizeX < size0 && i != 128 && i2 != 128) {",
          "470:                     int j;",
          "471:                     FFSWAP(int, stt[i], stt[i2]);",
          "472:                     FFSWAP(int, s->rc_stat[i][0], s->rc_stat[i2][0]);",
          "473:                     FFSWAP(int, s->rc_stat[i][1], s->rc_stat[i2][1]);",
          "474:                     if (i != 256 - i2) {",
          "475:                         FFSWAP(int, stt[256 - i], stt[256 - i2]);",
          "476:                         FFSWAP(int, s->rc_stat[256 - i][0], s->rc_stat[256 - i2][0]);",
          "477:                         FFSWAP(int, s->rc_stat[256 - i][1], s->rc_stat[256 - i2][1]);",
          "478:                     }",
          "479:                     for (j = 1; j < 256; j++) {",
          "480:                         if (stt[j] == i)",
          "481:                             stt[j] = i2;",
          "482:                         else if (stt[j] == i2)",
          "483:                             stt[j] = i;",
          "484:                         if (i != 256 - i2) {",
          "485:                             if (stt[256 - j] == 256 - i)",
          "486:                                 stt[256 - j] = 256 - i2;",
          "487:                             else if (stt[256 - j] == 256 - i2)",
          "488:                                 stt[256 - j] = 256 - i;",
          "489:                         }",
          "490:                     }",
          "491:                     print = changed = 1;",
          "492:                 }",
          "493:             }",
          "494:         }",
          "495:     } while (changed);",
          "496:     return print;",
          "497: }",
          "499: static av_cold int ffv1_encode_init(AVCodecContext *avctx)",
          "500: {",
          "501:     FFV1Context *s = avctx->priv_data;",
          "502:     int i, j, k, m;",
          "504:     ffv1_common_init(avctx);",
          "506:     s->version = 0;",
          "507:     s->ac      = avctx->coder_type ? 2 : 0;",
          "509:     if (s->ac > 1)",
          "510:         for (i = 1; i < 256; i++)",
          "511:             s->state_transition[i] = ffv1_ver2_state[i];",
          "513:     s->plane_count = 2;",
          "514:     for (i = 0; i < 256; i++) {",
          "515:         s->quant_table_count = 2;",
          "516:         if (avctx->bits_per_raw_sample <= 8) {",
          "517:             s->quant_tables[0][0][i] = ffv1_quant11[i];",
          "518:             s->quant_tables[0][1][i] = ffv1_quant11[i] * 11;",
          "519:             s->quant_tables[0][2][i] = ffv1_quant11[i] * 11 * 11;",
          "520:             s->quant_tables[1][0][i] = ffv1_quant11[i];",
          "521:             s->quant_tables[1][1][i] = ffv1_quant11[i] * 11;",
          "522:             s->quant_tables[1][2][i] = ffv1_quant5[i]  * 11 * 11;",
          "523:             s->quant_tables[1][3][i] = ffv1_quant5[i]  *  5 * 11 * 11;",
          "524:             s->quant_tables[1][4][i] = ffv1_quant5[i]  *  5 *  5 * 11 * 11;",
          "525:         } else {",
          "526:             s->quant_tables[0][0][i] = ffv1_quant9_10bit[i];",
          "527:             s->quant_tables[0][1][i] = ffv1_quant9_10bit[i] * 11;",
          "528:             s->quant_tables[0][2][i] = ffv1_quant9_10bit[i] * 11 * 11;",
          "529:             s->quant_tables[1][0][i] = ffv1_quant9_10bit[i];",
          "530:             s->quant_tables[1][1][i] = ffv1_quant9_10bit[i] * 11;",
          "531:             s->quant_tables[1][2][i] = ffv1_quant5_10bit[i] * 11 * 11;",
          "532:             s->quant_tables[1][3][i] = ffv1_quant5_10bit[i] *  5 * 11 * 11;",
          "533:             s->quant_tables[1][4][i] = ffv1_quant5_10bit[i] *  5 *  5 * 11 * 11;",
          "534:         }",
          "535:     }",
          "536:     s->context_count[0] = (11 * 11 * 11        + 1) / 2;",
          "537:     s->context_count[1] = (11 * 11 * 5 * 5 * 5 + 1) / 2;",
          "538:     memcpy(s->quant_table, s->quant_tables[avctx->context_model],",
          "539:            sizeof(s->quant_table));",
          "541:     for (i = 0; i < s->plane_count; i++) {",
          "542:         PlaneContext *const p = &s->plane[i];",
          "544:         memcpy(p->quant_table, s->quant_table, sizeof(p->quant_table));",
          "545:         p->quant_table_index = avctx->context_model;",
          "546:         p->context_count     = s->context_count[p->quant_table_index];",
          "547:     }",
          "549:     if (ffv1_allocate_initial_states(s) < 0)",
          "550:         return AVERROR(ENOMEM);",
          "552:     avctx->coded_frame = &s->picture;",
          "553:     switch (avctx->pix_fmt) {",
          "554:     case AV_PIX_FMT_YUV444P16:",
          "555:     case AV_PIX_FMT_YUV422P16:",
          "556:     case AV_PIX_FMT_YUV420P16:",
          "557:         if (avctx->bits_per_raw_sample <= 8) {",
          "558:             av_log(avctx, AV_LOG_ERROR, \"bits_per_raw_sample invalid\\n\");",
          "559:             return -1;",
          "560:         }",
          "561:         if (!s->ac) {",
          "562:             av_log(avctx, AV_LOG_ERROR,",
          "563:                    \"bits_per_raw_sample of more than 8 needs -coder 1 currently\\n\");",
          "564:             return -1;",
          "565:         }",
          "566:         s->version = FFMAX(s->version, 1);",
          "567:     case AV_PIX_FMT_YUV444P:",
          "568:     case AV_PIX_FMT_YUV422P:",
          "569:     case AV_PIX_FMT_YUV420P:",
          "570:     case AV_PIX_FMT_YUV411P:",
          "571:     case AV_PIX_FMT_YUV410P:",
          "572:         s->colorspace = 0;",
          "573:         break;",
          "574:     case AV_PIX_FMT_RGB32:",
          "575:         s->colorspace = 1;",
          "576:         break;",
          "577:     default:",
          "578:         av_log(avctx, AV_LOG_ERROR, \"format not supported\\n\");",
          "579:         return -1;",
          "580:     }",
          "581:     avcodec_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_h_shift,",
          "582:                                   &s->chroma_v_shift);",
          "584:     s->picture_number = 0;",
          "586:     if (avctx->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2)) {",
          "587:         for (i = 0; i < s->quant_table_count; i++) {",
          "588:             s->rc_stat2[i] = av_mallocz(s->context_count[i] *",
          "589:                                         sizeof(*s->rc_stat2[i]));",
          "590:             if (!s->rc_stat2[i])",
          "591:                 return AVERROR(ENOMEM);",
          "592:         }",
          "593:     }",
          "594:     if (avctx->stats_in) {",
          "595:         char *p = avctx->stats_in;",
          "596:         uint8_t best_state[256][256];",
          "597:         int gob_count = 0;",
          "598:         char *next;",
          "600:         av_assert0(s->version >= 2);",
          "602:         for (;; ) {",
          "603:             for (j = 0; j < 256; j++)",
          "604:                 for (i = 0; i < 2; i++) {",
          "605:                     s->rc_stat[j][i] = strtol(p, &next, 0);",
          "606:                     if (next == p) {",
          "607:                         av_log(avctx, AV_LOG_ERROR,",
          "608:                                \"2Pass file invalid at %d %d [%s]\\n\", j, i, p);",
          "609:                         return -1;",
          "610:                     }",
          "611:                     p = next;",
          "612:                 }",
          "613:             for (i = 0; i < s->quant_table_count; i++)",
          "614:                 for (j = 0; j < s->context_count[i]; j++) {",
          "615:                     for (k = 0; k < 32; k++)",
          "616:                         for (m = 0; m < 2; m++) {",
          "617:                             s->rc_stat2[i][j][k][m] = strtol(p, &next, 0);",
          "618:                             if (next == p) {",
          "619:                                 av_log(avctx, AV_LOG_ERROR,",
          "620:                                        \"2Pass file invalid at %d %d %d %d [%s]\\n\",",
          "621:                                        i, j, k, m, p);",
          "622:                                 return -1;",
          "623:                             }",
          "624:                             p = next;",
          "625:                         }",
          "626:                 }",
          "627:             gob_count = strtol(p, &next, 0);",
          "628:             if (next == p || gob_count < 0) {",
          "629:                 av_log(avctx, AV_LOG_ERROR, \"2Pass file invalid\\n\");",
          "630:                 return -1;",
          "631:             }",
          "632:             p = next;",
          "633:             while (*p == '\\n' || *p == ' ')",
          "634:                 p++;",
          "635:             if (p[0] == 0)",
          "636:                 break;",
          "637:         }",
          "638:         sort_stt(s, s->state_transition);",
          "640:         find_best_state(best_state, s->state_transition);",
          "642:         for (i = 0; i < s->quant_table_count; i++) {",
          "643:             for (j = 0; j < s->context_count[i]; j++)",
          "644:                 for (k = 0; k < 32; k++) {",
          "645:                     double p = 128;",
          "646:                     if (s->rc_stat2[i][j][k][0] + s->rc_stat2[i][j][k][1]) {",
          "647:                         p = 256.0 * s->rc_stat2[i][j][k][1] /",
          "648:                             (s->rc_stat2[i][j][k][0] + s->rc_stat2[i][j][k][1]);",
          "649:                     }",
          "650:                     s->initial_states[i][j][k] =",
          "651:                         best_state[av_clip(round(p), 1, 255)][av_clip((s->rc_stat2[i][j][k][0] +",
          "652:                                                                        s->rc_stat2[i][j][k][1]) /",
          "653:                                                                       gob_count, 0, 255)];",
          "654:                 }",
          "655:         }",
          "656:     }",
          "658:     if (s->version > 1) {",
          "659:         s->num_h_slices = 2;",
          "660:         s->num_v_slices = 2;",
          "661:         write_extra_header(s);",
          "662:     }",
          "664:     if (ffv1_init_slice_contexts(s) < 0)",
          "665:         return -1;",
          "666:     if (ffv1_init_slice_state(s) < 0)",
          "667:         return -1;",
          "669: #define STATS_OUT_SIZE 1024 * 1024 * 6",
          "670:     if (avctx->flags & CODEC_FLAG_PASS1) {",
          "671:         avctx->stats_out = av_mallocz(STATS_OUT_SIZE);",
          "672:         for (i = 0; i < s->quant_table_count; i++)",
          "673:             for (j = 0; j < s->slice_count; j++) {",
          "674:                 FFV1Context *sf = s->slice_context[j];",
          "675:                 av_assert0(!sf->rc_stat2[i]);",
          "676:                 sf->rc_stat2[i] = av_mallocz(s->context_count[i] *",
          "677:                                              sizeof(*sf->rc_stat2[i]));",
          "678:                 if (!sf->rc_stat2[i])",
          "679:                     return AVERROR(ENOMEM);",
          "680:             }",
          "681:     }",
          "683:     return 0;",
          "684: }",
          "686: static int encode_slice(AVCodecContext *c, void *arg)",
          "687: {",
          "688:     FFV1Context *fs  = *(void **)arg;",
          "689:     FFV1Context *f   = fs->avctx->priv_data;",
          "690:     int width        = fs->slice_width;",
          "691:     int height       = fs->slice_height;",
          "692:     int x            = fs->slice_x;",
          "693:     int y            = fs->slice_y;",
          "694:     AVFrame *const p = &f->picture;",
          "696:     if (f->colorspace == 0) {",
          "697:         const int chroma_width  = -((-width) >> f->chroma_h_shift);",
          "698:         const int chroma_height = -((-height) >> f->chroma_v_shift);",
          "699:         const int cx            = x >> f->chroma_h_shift;",
          "700:         const int cy            = y >> f->chroma_v_shift;",
          "702:         encode_plane(fs, p->data[0] + x + y * p->linesize[0],",
          "703:                      width, height, p->linesize[0], 0);",
          "705:         encode_plane(fs, p->data[1] + cx + cy * p->linesize[1],",
          "706:                      chroma_width, chroma_height, p->linesize[1], 1);",
          "707:         encode_plane(fs, p->data[2] + cx + cy * p->linesize[2],",
          "708:                      chroma_width, chroma_height, p->linesize[2], 1);",
          "709:     } else {",
          "710:         encode_rgb_frame(fs, (uint32_t *)(p->data[0]) +",
          "711:                          x + y * (p->linesize[0] / 4),",
          "712:                          width, height, p->linesize[0] / 4);",
          "713:     }",
          "714:     emms_c();",
          "716:     return 0;",
          "717: }",
          "719: static int ffv1_encode_frame(AVCodecContext *avctx, AVPacket *pkt,",
          "720:                              const AVFrame *pict, int *got_packet)",
          "721: {",
          "722:     FFV1Context *f      = avctx->priv_data;",
          "723:     RangeCoder *const c = &f->slice_context[0]->c;",
          "724:     AVFrame *const p    = &f->picture;",
          "725:     int used_count      = 0;",
          "726:     uint8_t keystate    = 128;",
          "727:     uint8_t *buf_p;",
          "728:     int i, ret;",
          "730:     if (!pkt->data &&",
          "731:         (ret = av_new_packet(pkt, avctx->width * avctx->height *",
          "732:                              ((8 * 2 + 1 + 1) * 4) / 8 + FF_MIN_BUFFER_SIZE)) < 0) {",
          "733:         av_log(avctx, AV_LOG_ERROR, \"Error getting output packet.\\n\");",
          "734:         return ret;",
          "735:     }",
          "737:     ff_init_range_encoder(c, pkt->data, pkt->size);",
          "738:     ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);",
          "741:     p->pict_type = AV_PICTURE_TYPE_I;",
          "743:     if (avctx->gop_size == 0 || f->picture_number % avctx->gop_size == 0) {",
          "744:         put_rac(c, &keystate, 1);",
          "745:         p->key_frame = 1;",
          "746:         f->gob_count++;",
          "747:         write_header(f);",
          "748:         ffv1_clear_state(f);",
          "749:     } else {",
          "750:         put_rac(c, &keystate, 0);",
          "751:         p->key_frame = 0;",
          "752:     }",
          "754:     if (!f->ac) {",
          "755:         used_count += ff_rac_terminate(c);",
          "756:         init_put_bits(&f->slice_context[0]->pb, pkt->data + used_count,",
          "757:                       pkt->size - used_count);",
          "758:     } else if (f->ac > 1) {",
          "759:         int i;",
          "760:         for (i = 1; i < 256; i++) {",
          "761:             c->one_state[i]        = f->state_transition[i];",
          "762:             c->zero_state[256 - i] = 256 - c->one_state[i];",
          "763:         }",
          "764:     }",
          "766:     for (i = 1; i < f->slice_count; i++) {",
          "767:         FFV1Context *fs = f->slice_context[i];",
          "768:         uint8_t *start  = pkt->data + (pkt->size - used_count) * i / f->slice_count;",
          "769:         int len         = pkt->size / f->slice_count;",
          "771:         if (fs->ac)",
          "772:             ff_init_range_encoder(&fs->c, start, len);",
          "773:         else",
          "774:             init_put_bits(&fs->pb, start, len);",
          "775:     }",
          "776:     avctx->execute(avctx, encode_slice, &f->slice_context[0], NULL,",
          "777:                    f->slice_count, sizeof(void *));",
          "779:     buf_p = pkt->data;",
          "780:     for (i = 0; i < f->slice_count; i++) {",
          "781:         FFV1Context *fs = f->slice_context[i];",
          "782:         int bytes;",
          "784:         if (fs->ac) {",
          "785:             uint8_t state = 128;",
          "786:             put_rac(&fs->c, &state, 0);",
          "787:             bytes = ff_rac_terminate(&fs->c);",
          "788:         } else {",
          "789:             flush_put_bits(&fs->pb); // FIXME: nicer padding",
          "790:             bytes      = used_count + (put_bits_count(&fs->pb) + 7) / 8;",
          "791:             used_count = 0;",
          "792:         }",
          "793:         if (i > 0) {",
          "794:             av_assert0(bytes < pkt->size / f->slice_count);",
          "795:             memmove(buf_p, fs->ac ? fs->c.bytestream_start : fs->pb.buf, bytes);",
          "796:             av_assert0(bytes < (1 << 24));",
          "797:             AV_WB24(buf_p + bytes, bytes);",
          "798:             bytes += 3;",
          "799:         }",
          "800:         buf_p += bytes;",
          "801:     }",
          "803:     if ((avctx->flags & CODEC_FLAG_PASS1) && (f->picture_number & 31) == 0) {",
          "804:         int j, k, m;",
          "805:         char *p   = avctx->stats_out;",
          "806:         char *end = p + STATS_OUT_SIZE;",
          "808:         memset(f->rc_stat, 0, sizeof(f->rc_stat));",
          "809:         for (i = 0; i < f->quant_table_count; i++)",
          "810:             memset(f->rc_stat2[i], 0, f->context_count[i] * sizeof(*f->rc_stat2[i]));",
          "812:         for (j = 0; j < f->slice_count; j++) {",
          "813:             FFV1Context *fs = f->slice_context[j];",
          "814:             for (i = 0; i < 256; i++) {",
          "815:                 f->rc_stat[i][0] += fs->rc_stat[i][0];",
          "816:                 f->rc_stat[i][1] += fs->rc_stat[i][1];",
          "817:             }",
          "818:             for (i = 0; i < f->quant_table_count; i++) {",
          "819:                 for (k = 0; k < f->context_count[i]; k++)",
          "820:                     for (m = 0; m < 32; m++) {",
          "821:                         f->rc_stat2[i][k][m][0] += fs->rc_stat2[i][k][m][0];",
          "822:                         f->rc_stat2[i][k][m][1] += fs->rc_stat2[i][k][m][1];",
          "823:                     }",
          "824:             }",
          "825:         }",
          "827:         for (j = 0; j < 256; j++) {",
          "828:             snprintf(p, end - p, \"%\" PRIu64 \" %\" PRIu64 \" \",",
          "829:                      f->rc_stat[j][0], f->rc_stat[j][1]);",
          "830:             p += strlen(p);",
          "831:         }",
          "832:         snprintf(p, end - p, \"\\n\");",
          "834:         for (i = 0; i < f->quant_table_count; i++) {",
          "835:             for (j = 0; j < f->context_count[i]; j++)",
          "836:                 for (m = 0; m < 32; m++) {",
          "837:                     snprintf(p, end - p, \"%\" PRIu64 \" %\" PRIu64 \" \",",
          "838:                              f->rc_stat2[i][j][m][0], f->rc_stat2[i][j][m][1]);",
          "839:                     p += strlen(p);",
          "840:                 }",
          "841:         }",
          "842:         snprintf(p, end - p, \"%d\\n\", f->gob_count);",
          "843:     } else if (avctx->flags & CODEC_FLAG_PASS1)",
          "844:         avctx->stats_out[0] = '\\0';",
          "846:     f->picture_number++;",
          "847:     pkt->size   = buf_p - pkt->data;",
          "848:     pkt->flags |= AV_PKT_FLAG_KEY * p->key_frame;",
          "851:     return 0;",
          "852: }",
          "854: AVCodec ff_ffv1_encoder = {",
          "855:     .name           = \"ffv1\",",
          "856:     .type           = AVMEDIA_TYPE_VIDEO,",
          "857:     .id             = AV_CODEC_ID_FFV1,",
          "858:     .priv_data_size = sizeof(FFV1Context),",
          "859:     .init           = ffv1_encode_init,",
          "860:     .encode2        = ffv1_encode_frame,",
          "861:     .close          = ffv1_close,",
          "862:     .capabilities   = CODEC_CAP_SLICE_THREADS,",
          "863:     .pix_fmts       = (const enum AVPixelFormat[]) {",
          "864:         AV_PIX_FMT_YUV420P,   AV_PIX_FMT_YUV422P,   AV_PIX_FMT_YUV444P,",
          "865:         AV_PIX_FMT_YUV411P,   AV_PIX_FMT_YUV410P,",
          "866:         AV_PIX_FMT_YUV420P16, AV_PIX_FMT_YUV422P16, AV_PIX_FMT_YUV444P16,",
          "867:         AV_PIX_FMT_RGB32,",
          "868:         AV_PIX_FMT_NONE",
          "869:     },",
          "870:     .long_name      = NULL_IF_CONFIG_SMALL(\"FFmpeg video codec #1\"),",
          "871: };",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b5d7b80a7e43779ca2962ba56442579c2a7e927d",
      "candidate_info": {
        "commit_hash": "b5d7b80a7e43779ca2962ba56442579c2a7e927d",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/b5d7b80a7e43779ca2962ba56442579c2a7e927d",
        "files": [
          "libavcodec/ffv1.c"
        ],
        "message": "ffv1dec: check that global parameters do not change in version 0/1\n\nSuch changes are neither allowed nor supported\n\nFound-by: ami_stuff\nBug-Id: CVE-2013-7020\nCC: libav-stable@libav.org\nSigned-off-by: Anton Khirnov <anton@khirnov.net>\n(cherry picked from commit da7d839a0d3ec40423a665dc85e0cfaed3f92eb8)\nSigned-off-by: Anton Khirnov <anton@khirnov.net>\n\nConflicts:\n\tlibavcodec/ffv1dec.c",
        "before_after_code_files": [
          "libavcodec/ffv1.c||libavcodec/ffv1.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libavcodec/ffv1.c||libavcodec/ffv1.c": [
          "File: libavcodec/ffv1.c -> libavcodec/ffv1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1518:     memset(state, 128, sizeof(state));",
          "1520:     if(f->version < 2){",
          "1527:         }",
          "1531:         get_rac(c, state); //no chroma = false",
          "1534:         get_rac(c, state); //transparency plane",
          "1535:         f->plane_count= 2;",
          "1536:     }",
          "",
          "[Removed Lines]",
          "1521:         f->version= get_symbol(c, state, 0);",
          "1522:         f->ac= f->avctx->coder_type= get_symbol(c, state, 0);",
          "1523:         if(f->ac>1){",
          "1524:             for(i=1; i<256; i++){",
          "1525:                 f->state_transition[i]= get_symbol(c, state, 1) + c->one_state[i];",
          "1526:             }",
          "1528:         f->colorspace= get_symbol(c, state, 0); //YUV cs type",
          "1529:         if(f->version>0)",
          "1530:             f->avctx->bits_per_raw_sample= get_symbol(c, state, 0);",
          "1532:         f->chroma_h_shift= get_symbol(c, state, 0);",
          "1533:         f->chroma_v_shift= get_symbol(c, state, 0);",
          "",
          "[Added Lines]",
          "1521:         int chroma_h_shift, chroma_v_shift, colorspace, bits_per_raw_sample;",
          "1522:         unsigned v = get_symbol(c, state, 0);",
          "1523:         if (v > 1) {",
          "1524:             av_log(f->avctx, AV_LOG_ERROR,",
          "1525:                    \"invalid version %d in version 1 header\\n\", v);",
          "1526:             return AVERROR_INVALIDDATA;",
          "1528:         f->version = v;",
          "1530:         f->ac = f->avctx->coder_type = get_symbol(c, state, 0);",
          "1532:         if (f->ac > 1) {",
          "1533:             for (i = 1; i < 256; i++)",
          "1534:                 f->state_transition[i] =",
          "1535:                     get_symbol(c, state, 1) + c->one_state[i];",
          "1536:         }",
          "1538:         colorspace          = get_symbol(c, state, 0); //YUV cs type",
          "1539:         bits_per_raw_sample = f->version > 0 ? get_symbol(c, state, 0) : f->avctx->bits_per_raw_sample;",
          "1541:         chroma_h_shift      = get_symbol(c, state, 0);",
          "1542:         chroma_v_shift      = get_symbol(c, state, 0);",
          "1545:         if (f->plane_count) {",
          "1546:             if (colorspace          != f->colorspace                 ||",
          "1547:                 bits_per_raw_sample != f->avctx->bits_per_raw_sample ||",
          "1548:                 chroma_h_shift      != f->chroma_h_shift             ||",
          "1549:                 chroma_v_shift      != f->chroma_v_shift) {",
          "1550:                 av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");",
          "1551:                 return AVERROR_INVALIDDATA;",
          "1552:             }",
          "1553:         }",
          "1555:         f->colorspace                 = colorspace;",
          "1556:         f->avctx->bits_per_raw_sample = bits_per_raw_sample;",
          "1557:         f->chroma_h_shift             = chroma_h_shift;",
          "1558:         f->chroma_v_shift             = chroma_v_shift;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e4fb53c73abece15a7c5df0019df9a0371db2297",
      "candidate_info": {
        "commit_hash": "e4fb53c73abece15a7c5df0019df9a0371db2297",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/e4fb53c73abece15a7c5df0019df9a0371db2297",
        "files": [
          "libavcodec/ffv1dec.c"
        ],
        "message": "ffv1dec: check that global parameters do not change in version 0/1\n\nSuch changes are neither allowed nor supported\n\nFound-by: ami_stuff\nBug-Id: CVE-2013-7020\nCC: libav-stable@libav.org\nSigned-off-by: Anton Khirnov <anton@khirnov.net>\n(cherry picked from commit da7d839a0d3ec40423a665dc85e0cfaed3f92eb8)\nSigned-off-by: Anton Khirnov <anton@khirnov.net>",
        "before_after_code_files": [
          "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
          ],
          "candidate": [
            "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/ffv1dec.c||libavcodec/ffv1dec.c": [
          "File: libavcodec/ffv1dec.c -> libavcodec/ffv1dec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "542:     memset(state, 128, sizeof(state));",
          "544:     if (f->version < 2) {",
          "545:         unsigned v = get_symbol(c, state, 0);",
          "546:         if (v > 1) {",
          "547:             av_log(f->avctx, AV_LOG_ERROR,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "545:         int chroma_planes, chroma_h_shift, chroma_v_shift, transparency, colorspace, bits_per_raw_sample;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "558:                     get_symbol(c, state, 1) + c->one_state[i];",
          "559:         }",
          "570:         f->plane_count    = 2 + f->transparency;",
          "571:     }",
          "",
          "[Removed Lines]",
          "561:         f->colorspace = get_symbol(c, state, 0); //YUV cs type",
          "563:         if (f->version > 0)",
          "564:             f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);",
          "566:         f->chroma_planes  = get_rac(c, state);",
          "567:         f->chroma_h_shift = get_symbol(c, state, 0);",
          "568:         f->chroma_v_shift = get_symbol(c, state, 0);",
          "569:         f->transparency   = get_rac(c, state);",
          "",
          "[Added Lines]",
          "562:         colorspace          = get_symbol(c, state, 0); //YUV cs type",
          "563:         bits_per_raw_sample = f->version > 0 ? get_symbol(c, state, 0) : f->avctx->bits_per_raw_sample;",
          "564:         chroma_planes       = get_rac(c, state);",
          "565:         chroma_h_shift      = get_symbol(c, state, 0);",
          "566:         chroma_v_shift      = get_symbol(c, state, 0);",
          "567:         transparency        = get_rac(c, state);",
          "569:         if (f->plane_count) {",
          "570:             if (colorspace          != f->colorspace                 ||",
          "571:                 bits_per_raw_sample != f->avctx->bits_per_raw_sample ||",
          "572:                 chroma_planes       != f->chroma_planes              ||",
          "573:                 chroma_h_shift      != f->chroma_h_shift             ||",
          "574:                 chroma_v_shift      != f->chroma_v_shift             ||",
          "575:                 transparency        != f->transparency) {",
          "576:                 av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");",
          "577:                 return AVERROR_INVALIDDATA;",
          "578:             }",
          "579:         }",
          "581:         f->colorspace                 = colorspace;",
          "582:         f->avctx->bits_per_raw_sample = bits_per_raw_sample;",
          "583:         f->chroma_planes              = chroma_planes;",
          "584:         f->chroma_h_shift             = chroma_h_shift;",
          "585:         f->chroma_v_shift             = chroma_v_shift;",
          "586:         f->transparency               = transparency;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
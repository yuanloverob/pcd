{
  "cve_id": "CVE-2019-19880",
  "cve_desc": "exprListAppendList in window.c in SQLite 3.30.1 allows attackers to trigger an invalid pointer dereference because constant integer values in ORDER BY clauses of window definitions are mishandled.",
  "repo": "sqlite/sqlite",
  "patch_hash": "75e95e1fcd52d3ec8282edb75ac8cd0814095d54",
  "patch_info": {
    "commit_hash": "75e95e1fcd52d3ec8282edb75ac8cd0814095d54",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/75e95e1fcd52d3ec8282edb75ac8cd0814095d54",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/window.c"
    ],
    "message": "When processing constant integer values in ORDER BY clauses of window definitions (see check-in [7e4809eadfe99ebf]) be sure to fully disable the constant value to avoid an invalid pointer dereference if the expression is ever duplicated. This fixes a crash report from Yongheng and Rui.\n\nFossilOrigin-Name: 1ca0bd982ab1183bbafce0d260e4dceda5eb766ed2e7793374a88d1ae0bdd2ca",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/window.c||src/window.c"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 8223e79f987feda5c8e51ec52cec6798cca16d070b10558939e2888ca1a25b8e",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/window.c||src/window.c": [
      "File: src/window.c -> src/window.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "895:     int nInit = pList ? pList->nExpr : 0;",
      "896:     for(i=0; i<pAppend->nExpr; i++){",
      "897:       Expr *pDup = sqlite3ExprDup(pParse->db, pAppend->a[i].pExpr, 0);",
      "898:       if( bIntToNull && pDup && pDup->op==TK_INTEGER ){",
      "899:         pDup->op = TK_NULL;",
      "900:         pDup->flags &= ~(EP_IntValue|EP_IsTrue|EP_IsFalse);",
      "901:       }",
      "902:       pList = sqlite3ExprListAppend(pParse, pList, pDup);",
      "903:       if( pList ) pList->a[nInit+i].sortFlags = pAppend->a[i].sortFlags;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "898:       assert( pDup==0 || !ExprHasProperty(pDup, EP_MemToken) );",
      "902:         pDup->u.zToken = 0;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b0ea9432a12c01597951967a18e530df1b4bffd1",
      "candidate_info": {
        "commit_hash": "b0ea9432a12c01597951967a18e530df1b4bffd1",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/b0ea9432a12c01597951967a18e530df1b4bffd1",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/btree.c",
          "src/btreeInt.h"
        ],
        "message": "Defer computing the MemPage.nFree value of an in-memory btree page until it is actually needed, since for many pages it is never needed. This checkin works sufficiently to prove the concept, but still has issues with exception handling.\n\nFossilOrigin-Name: 1d43ee4000b71f5c6d49244dee96358c567f09ba3451b9d22895a796d3f61ad6",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/btree.c||src/btree.c",
          "src/btreeInt.h||src/btreeInt.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: db74a56af73d92b7a9d43ceda7e4540915c580c68a0266b4ddefb9e0d5cbcbeb",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/btree.c||src/btree.c": [
          "File: src/btree.c -> src/btree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1506:   data[hdr+7] = 0;",
          "1508:  defragment_out:",
          "1509:   if( data[hdr+7]+cbrk-iCellFirst!=pPage->nFree ){",
          "1510:     return SQLITE_CORRUPT_PAGE(pPage);",
          "1511:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1509:   assert( pPage->nFree>=0 );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1657:   testcase( gap+2+nByte==top );",
          "1658:   if( gap+2+nByte>top ){",
          "1659:     assert( pPage->nCell>0 || CORRUPT_DB );",
          "1660:     rc = defragmentPage(pPage, MIN(4, pPage->nFree - (2+nByte)));",
          "1661:     if( rc ) return rc;",
          "1662:     top = get2byteNotZero(&data[hdr+5]);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1661:     assert( pPage->nFree>=0 );",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1845:   return SQLITE_OK;",
          "1846: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1854: static int btreeComputeFreeSpace(MemPage *pPage){",
          "1864:   assert( pPage->pBt!=0 );",
          "1865:   assert( pPage->pBt->db!=0 );",
          "1866:   assert( sqlite3_mutex_held(pPage->pBt->mutex) );",
          "1867:   assert( pPage->pgno==sqlite3PagerPagenumber(pPage->pDbPage) );",
          "1868:   assert( pPage == sqlite3PagerGetExtra(pPage->pDbPage) );",
          "1869:   assert( pPage->aData == sqlite3PagerGetData(pPage->pDbPage) );",
          "1870:   assert( pPage->isInit==1 );",
          "1871:   assert( pPage->nFree<0 );",
          "1873:   usableSize = pPage->pBt->usableSize;",
          "1874:   hdr = pPage->hdrOffset;",
          "1875:   data = pPage->aData;",
          "1879:   top = get2byteNotZero(&data[hdr+5]);",
          "1880:   iCellFirst = hdr + 8 + pPage->childPtrSize + 2*pPage->nCell;",
          "1881:   iCellLast = usableSize - 4;",
          "1887:   pc = get2byte(&data[hdr+1]);",
          "1889:   if( pc>0 ){",
          "1890:     u32 next, size;",
          "1891:     if( pc<iCellFirst ){",
          "1895:       return SQLITE_CORRUPT_PAGE(pPage);",
          "1896:     }",
          "1897:     while( 1 ){",
          "1898:       if( pc>iCellLast ){",
          "1900:         return SQLITE_CORRUPT_PAGE(pPage);",
          "1901:       }",
          "1902:       next = get2byte(&data[pc]);",
          "1903:       size = get2byte(&data[pc+2]);",
          "1904:       nFree = nFree + size;",
          "1905:       if( next<=pc+size+3 ) break;",
          "1906:       pc = next;",
          "1907:     }",
          "1908:     if( next>0 ){",
          "1910:       return SQLITE_CORRUPT_PAGE(pPage);",
          "1911:     }",
          "1912:     if( pc+size>(unsigned int)usableSize ){",
          "1914:       return SQLITE_CORRUPT_PAGE(pPage);",
          "1915:     }",
          "1916:   }",
          "1925:   if( nFree>usableSize ){",
          "1926:     return SQLITE_CORRUPT_PAGE(pPage);",
          "1927:   }",
          "1928:   pPage->nFree = (u16)(nFree - iCellFirst);",
          "1929:   return SQLITE_OK;",
          "1930: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1890:   pPage->aDataEnd = &data[usableSize];",
          "1891:   pPage->aCellIdx = &data[cellOffset];",
          "1892:   pPage->aDataOfst = &data[pPage->childPtrSize];",
          "1899:   pPage->nCell = get2byte(&data[hdr+3]);",
          "",
          "[Removed Lines]",
          "1896:   top = get2byteNotZero(&data[hdr+5]);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1909:   assert( pPage->nCell>0 || top==usableSize || CORRUPT_DB );",
          "",
          "[Added Lines]",
          "1987:   assert( pPage->nCell>0",
          "1988:        || get2byteNotZero(&data[hdr+5])==usableSize",
          "1989:        || CORRUPT_DB );",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1937:     }",
          "1938:     if( !pPage->leaf ) iCellLast++;",
          "1939:   }",
          "1987:   pPage->isInit = 1;",
          "1988:   return SQLITE_OK;",
          "1989: }",
          "",
          "[Removed Lines]",
          "1945:   pc = get2byte(&data[hdr+1]);",
          "1947:   if( pc>0 ){",
          "1948:     u32 next, size;",
          "1949:     if( pc<iCellFirst ){",
          "1953:       return SQLITE_CORRUPT_PAGE(pPage);",
          "1954:     }",
          "1955:     while( 1 ){",
          "1956:       if( pc>iCellLast ){",
          "1958:         return SQLITE_CORRUPT_PAGE(pPage);",
          "1959:       }",
          "1960:       next = get2byte(&data[pc]);",
          "1961:       size = get2byte(&data[pc+2]);",
          "1962:       nFree = nFree + size;",
          "1963:       if( next<=pc+size+3 ) break;",
          "1964:       pc = next;",
          "1965:     }",
          "1966:     if( next>0 ){",
          "1968:       return SQLITE_CORRUPT_PAGE(pPage);",
          "1969:     }",
          "1970:     if( pc+size>(unsigned int)usableSize ){",
          "1972:       return SQLITE_CORRUPT_PAGE(pPage);",
          "1973:     }",
          "1974:   }",
          "1983:   if( nFree>usableSize ){",
          "1984:     return SQLITE_CORRUPT_PAGE(pPage);",
          "1985:   }",
          "1986:   pPage->nFree = (u16)(nFree - iCellFirst);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2128:   if( pgno>btreePagecount(pBt) ){",
          "2129:     rc = SQLITE_CORRUPT_BKPT;",
          "2131:   }",
          "2132:   rc = sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, bReadOnly);",
          "2133:   if( rc ){",
          "2135:   }",
          "2137:   if( (*ppPage)->isInit==0 ){",
          "2138:     btreePageFromDbPage(pDbPage, pgno, pBt);",
          "2139:     rc = btreeInitPage(*ppPage);",
          "2140:     if( rc!=SQLITE_OK ){",
          "2143:     }",
          "2144:   }",
          "2145:   assert( (*ppPage)->pgno==pgno );",
          "",
          "[Removed Lines]",
          "2130:     goto getAndInitPage_error;",
          "2134:     goto getAndInitPage_error;",
          "2141:       releasePage(*ppPage);",
          "2142:       goto getAndInitPage_error;",
          "",
          "[Added Lines]",
          "2164:     goto getAndInitPage_error1;",
          "2168:     goto getAndInitPage_error1;",
          "2175:       goto getAndInitPage_error2;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2150:   if( pCur && ((*ppPage)->nCell<1 || (*ppPage)->intKey!=pCur->curIntKey) ){",
          "2151:     rc = SQLITE_CORRUPT_PGNO(pgno);",
          "2154:   }",
          "2155:   return SQLITE_OK;",
          "2158:   if( pCur ){",
          "2159:     pCur->iPage--;",
          "2160:     pCur->pPage = pCur->apPage[pCur->iPage];",
          "",
          "[Removed Lines]",
          "2152:     releasePage(*ppPage);",
          "2153:     goto getAndInitPage_error;",
          "2157: getAndInitPage_error:",
          "",
          "[Added Lines]",
          "2185:     goto getAndInitPage_error2;",
          "2189: getAndInitPage_error2:",
          "2190:   releasePage(*ppPage);",
          "2191: getAndInitPage_error1:",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "6566:   assert( CORRUPT_DB || sz==cellSize(pPage, idx) );",
          "6567:   assert( sqlite3PagerIswriteable(pPage->pDbPage) );",
          "6568:   assert( sqlite3_mutex_held(pPage->pBt->mutex) );",
          "6569:   data = pPage->aData;",
          "6570:   ptr = &pPage->aCellIdx[2*idx];",
          "6571:   pc = get2byte(ptr);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6603:   assert( pPage->nFree>=0 );",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "6638:   assert( sz==pPage->xCellSize(pPage, pCell) || (sz==8 && iChild>0) );",
          "6639:   if( pPage->nOverflow || sz+2>pPage->nFree ){",
          "6640:     if( pTemp ){",
          "6641:       memcpy(pTemp, pCell, sz);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6674:   assert( pPage->nFree>=0 );",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "7187:   assert( sqlite3_mutex_held(pPage->pBt->mutex) );",
          "7188:   assert( sqlite3PagerIswriteable(pParent->pDbPage) );",
          "7189:   assert( pPage->nOverflow==1 );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7228:   if( pPage->nFree<0 ){",
          "7229:     rc = btreeComputeFreeSpace(pPage);",
          "7230:     if( rc ) return rc;",
          "7231:   }",
          "7232:   if( pParent->nFree<0 ){",
          "7233:     rc = btreeComputeFreeSpace(pParent);",
          "7234:     if( rc ) return rc;",
          "7235:   }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "7466:   if( !aOvflSpace ){",
          "7467:     return SQLITE_NOMEM_BKPT;",
          "7468:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7514:   if( pParent->nFree<0 ){",
          "7515:     rc = btreeComputeFreeSpace(pParent);",
          "7516:     if( rc ) return rc;",
          "7517:   }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "7501:   pgno = get4byte(pRight);",
          "7502:   while( 1 ){",
          "7503:     rc = getAndInitPage(pBt, pgno, &apOld[i], 0, 0);",
          "7504:     if( rc ){",
          "7505:       memset(apOld, 0, (i+1)*sizeof(MemPage*));",
          "7506:       goto balance_cleanup;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7553:     if( rc==0 && apOld[i]->nFree<0 ){",
          "7554:       rc = btreeComputeFreeSpace(apOld[i]);",
          "7555:     }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "7704:       b.apEnd[k] = pParent->aDataEnd;",
          "7705:       b.ixNx[k] = cntOld[i]+1;",
          "7706:     }",
          "7707:     szNew[i] = usableSpace - p->nFree;",
          "7708:     for(j=0; j<p->nOverflow; j++){",
          "7709:       szNew[i] += 2 + p->xCellSize(p, p->apOvfl[j]);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7759:     assert( p->nFree>=0 );",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "8247:     int iPage = pCur->iPage;",
          "8248:     MemPage *pPage = pCur->pPage;",
          "8250:     if( iPage==0 ){",
          "8251:       if( pPage->nOverflow ){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8303:     if( pPage->nFree<0 ){",
          "8304:       rc = btreeComputeFreeSpace(pPage);",
          "8305:       if( rc ) break;",
          "8306:     }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "8621:   pPage = pCur->pPage;",
          "8622:   assert( pPage->intKey || pX->nKey>=0 );",
          "8623:   assert( pPage->leaf || !pPage->intKey );",
          "8625:   TRACE((\"INSERT: table=%d nkey=%lld ndata=%d page=%d %s\\n\",",
          "8626:           pCur->pgnoRoot, pX->nKey, pX->nData, pPage->pgno,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8681:   if( pPage->nFree<0 ){",
          "8682:     rc = btreeComputeFreeSpace(pPage);",
          "8683:     if( rc ) return rc;",
          "8684:   }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "8771:   iCellIdx = pCur->ix;",
          "8772:   pPage = pCur->pPage;",
          "8773:   pCell = findCell(pPage, iCellIdx);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8835:   if( pPage->nFree<0 && btreeComputeFreeSpace(pPage) ) return SQLITE_CORRUPT;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "8841:     Pgno n;",
          "8842:     unsigned char *pTmp;",
          "8844:     if( iCellDepth<pCur->iPage-1 ){",
          "8845:       n = pCur->apPage[iCellDepth+1]->pgno;",
          "8846:     }else{",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8906:     if( pLeaf->nFree<0 ){",
          "8907:       rc = btreeComputeFreeSpace(pLeaf);",
          "8908:       if( rc ) return rc;",
          "8909:     }",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "9732:                    \"btreeInitPage() returns error code %d\", rc);",
          "9733:     goto end_of_check;",
          "9734:   }",
          "9735:   data = pPage->aData;",
          "9736:   hdr = pPage->hdrOffset;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9801:   if( (rc = btreeComputeFreeSpace(pPage))!=0 ){",
          "9802:     assert( rc==SQLITE_CORRUPT );",
          "9803:     checkAppendMsg(pCheck, \"free space corruption\", rc);",
          "9804:     goto end_of_check;",
          "9805:   }",
          "",
          "---------------"
        ],
        "src/btreeInt.h||src/btreeInt.h": [
          "File: src/btreeInt.h -> src/btreeInt.h"
        ]
      }
    },
    {
      "candidate_hash": "41422656450bed94abee2edf1df83660325afc5c",
      "candidate_info": {
        "commit_hash": "41422656450bed94abee2edf1df83660325afc5c",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/41422656450bed94abee2edf1df83660325afc5c",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/btree.c",
          "test/fuzzdata8.db"
        ],
        "message": "Ensure that the BtShared.nPage value is reset correctly on a SAVEPOINT ROLLBACK.\n\nFossilOrigin-Name: e6d5fee8cdbdce8515957e8288e4d1e7b06f417fd3f9deeeb636fbf5b995af51",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/btree.c||src/btree.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 7e4809eadfe99ebfd797a7c63501421021a720bbeed9fba81bebf630c58bb791",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/btree.c||src/btree.c": [
          "File: src/btree.c -> src/btree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4153:   return rc;",
          "4154: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4160: static void btreeSetNPage(BtShared *pBt, MemPage *pPage1){",
          "4161:   int nPage = get4byte(&pPage1->aData[28]);",
          "4162:   testcase( nPage==0 );",
          "4163:   if( nPage==0 ) sqlite3PagerPagecount(pBt->pPager, &nPage);",
          "4164:   testcase( pBt->nPage!=nPage );",
          "4165:   pBt->nPage = nPage;",
          "4166: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4200:     if( btreeGetPage(pBt, 1, &pPage1, 0)==SQLITE_OK ){",
          "4206:       releasePageOne(pPage1);",
          "4207:     }",
          "4208:     assert( countValidCursors(pBt, 1)==0 );",
          "",
          "[Removed Lines]",
          "4201:       int nPage = get4byte(28+(u8*)pPage1->aData);",
          "4202:       testcase( nPage==0 );",
          "4203:       if( nPage==0 ) sqlite3PagerPagecount(pBt->pPager, &nPage);",
          "4204:       testcase( pBt->nPage!=nPage );",
          "4205:       pBt->nPage = nPage;",
          "",
          "[Added Lines]",
          "4213:       btreeSetNPage(pBt, pPage1);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4282:         pBt->nPage = 0;",
          "4283:       }",
          "4284:       rc = newDatabase(pBt);",
          "",
          "[Removed Lines]",
          "4285:       pBt->nPage = get4byte(28 + pBt->pPage1->aData);",
          "",
          "[Added Lines]",
          "4293:       btreeSetNPage(pBt, pBt->pPage1);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7ed6c068f556dd45f705355c3454c1f8af1047d4",
      "candidate_info": {
        "commit_hash": "7ed6c068f556dd45f705355c3454c1f8af1047d4",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/7ed6c068f556dd45f705355c3454c1f8af1047d4",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/build.c",
          "src/vdbeaux.c",
          "test/indexexpr2.test"
        ],
        "message": "Fix a problem in [b5ca442a] causing an assert() to fail in REINDEX commands.\n\nFossilOrigin-Name: a3e77c7776ab01dadb9d30d6067ac97e9d4b09ec54834558a5fa1ffed7b52c72",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/build.c||src/build.c",
          "src/vdbeaux.c||src/vdbeaux.c",
          "test/indexexpr2.test||test/indexexpr2.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: b8071d10cba8f6c19fb8d5df3877f72567dc6d6a94744a39cbc1f58b2e2f343b",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c"
        ],
        "src/vdbeaux.c||src/vdbeaux.c": [
          "File: src/vdbeaux.c -> src/vdbeaux.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "648:       break;",
          "649:     }",
          "650:     if( opcode==OP_CreateBtree && pOp->p3==BTREE_INTKEY ) hasCreateTable = 1;",
          "652:     if( opcode==OP_InitCoroutine ) hasInitCoroutine = 1;",
          "653: #ifndef SQLITE_OMIT_FOREIGN_KEY",
          "654:     if( opcode==OP_FkCounter && pOp->p1==0 && pOp->p2==1 ){",
          "",
          "[Removed Lines]",
          "651:     if( opcode==OP_CreateBtree && pOp->p3==BTREE_BLOBKEY ) hasCreateIndex = 1;",
          "",
          "[Added Lines]",
          "651:     if( mayAbort ){",
          "656:       if( opcode==OP_CreateBtree && pOp->p3==BTREE_BLOBKEY ) hasCreateIndex = 1;",
          "657:       if( opcode==OP_Clear ) hasCreateIndex = 1;",
          "658:     }",
          "",
          "---------------"
        ],
        "test/indexexpr2.test||test/indexexpr2.test": [
          "File: test/indexexpr2.test -> test/indexexpr2.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "291:   SELECT sql FROM sqlite_master WHERE tbl_name = 't0';",
          "292:   CREATE INDEX i0 ON t0(c0);",
          "293: } {{CREATE TABLE t0(c0)}}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "294: do_execsql_test 7.3 {",
          "295:   REINDEX;",
          "296: } {}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a790882d63af27deca8a2cf63577ae909fe08d6c",
      "candidate_info": {
        "commit_hash": "a790882d63af27deca8a2cf63577ae909fe08d6c",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/a790882d63af27deca8a2cf63577ae909fe08d6c",
        "files": [
          "manifest",
          "manifest.uuid",
          "test/dbfuzz2.c"
        ],
        "message": "Add the -memtrace option to dbfuzz2.\n\nFossilOrigin-Name: 67fecbc79d3e927a7e22f3589be3184114322635874e4b3170666e352d0bfe9d",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "test/dbfuzz2.c||test/dbfuzz2.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 3a127ef9f7feafe6ba8c75e4eb29e28aa61a30249082cc8767ada1ec0cc0b7f1",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/dbfuzz2.c||test/dbfuzz2.c": [
          "File: test/dbfuzz2.c -> test/dbfuzz2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "73: static sqlite3_int64 szMax = 104857600;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "77: static sqlite3_mem_methods memtraceBase;",
          "78: static FILE *memtraceOut;",
          "81: static void *memtraceMalloc(int n){",
          "82:   if( memtraceOut ){",
          "83:     fprintf(memtraceOut, \"MEMTRACE: allocate %d bytes\\n\",",
          "84:             memtraceBase.xRoundup(n));",
          "85:   }",
          "86:   return memtraceBase.xMalloc(n);",
          "87: }",
          "88: static void memtraceFree(void *p){",
          "89:   if( p==0 ) return;",
          "90:   if( memtraceOut ){",
          "91:     fprintf(memtraceOut, \"MEMTRACE: free %d bytes\\n\", memtraceBase.xSize(p));",
          "92:   }",
          "93:   memtraceBase.xFree(p);",
          "94: }",
          "95: static void *memtraceRealloc(void *p, int n){",
          "96:   if( p==0 ) return memtraceMalloc(n);",
          "97:   if( n==0 ){",
          "98:     memtraceFree(p);",
          "99:     return 0;",
          "100:   }",
          "101:   if( memtraceOut ){",
          "102:     fprintf(memtraceOut, \"MEMTRACE: resize %d -> %d bytes\\n\",",
          "103:             memtraceBase.xSize(p), memtraceBase.xRoundup(n));",
          "104:   }",
          "105:   return memtraceBase.xRealloc(p, n);",
          "106: }",
          "107: static int memtraceSize(void *p){",
          "108:   return memtraceBase.xSize(p);",
          "109: }",
          "110: static int memtraceRoundup(int n){",
          "111:   return memtraceBase.xRoundup(n);",
          "112: }",
          "113: static int memtraceInit(void *p){",
          "114:   return memtraceBase.xInit(p);",
          "115: }",
          "116: static void memtraceShutdown(void *p){",
          "117:   memtraceBase.xShutdown(p);",
          "118: }",
          "121: static sqlite3_mem_methods ersaztMethods = {",
          "122:   memtraceMalloc,",
          "123:   memtraceFree,",
          "124:   memtraceRealloc,",
          "125:   memtraceSize,",
          "126:   memtraceRoundup,",
          "127:   memtraceInit,",
          "128:   memtraceShutdown",
          "129: };",
          "132: int sqlite3MemTraceActivate(FILE *out){",
          "133:   int rc = SQLITE_OK;",
          "134:   if( memtraceBase.xMalloc==0 ){",
          "135:     rc = sqlite3_config(SQLITE_CONFIG_GETMALLOC, &memtraceBase);",
          "136:     if( rc==SQLITE_OK ){",
          "137:       rc = sqlite3_config(SQLITE_CONFIG_MALLOC, &ersaztMethods);",
          "138:     }",
          "139:   }",
          "140:   memtraceOut = out;",
          "141:   return rc;",
          "142: }",
          "145: int sqlite3MemTraceDeactivate(void){",
          "146:   int rc = SQLITE_OK;",
          "147:   if( memtraceBase.xMalloc!=0 ){",
          "148:     rc = sqlite3_config(SQLITE_CONFIG_MALLOC, &memtraceBase);",
          "149:     if( rc==SQLITE_OK ){",
          "150:       memset(&memtraceBase, 0, sizeof(memtraceBase));",
          "151:     }",
          "152:   }",
          "153:   memtraceOut = 0;",
          "154:   return rc;",
          "155: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "162:         bVdbeDebug = 1;",
          "163:         continue;",
          "164:       }",
          "165:       if( strcmp(z,\"max-db-size\")==0 ){",
          "166:         if( i+1==argc ){",
          "167:           fprintf(stderr, \"missing argument to %s\\n\", argv[i]);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "248:       if( strcmp(z,\"memtrace\")==0 ){",
          "249:         sqlite3MemTraceActivate(stdout);",
          "250:         continue;",
          "251:       }",
          "252:       if( strcmp(z,\"mem\")==0 ){",
          "253:         bVdbeDebug = 1;",
          "254:         continue;",
          "255:       }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9cb02640419614ae3771ebbffce076474380029b",
      "candidate_info": {
        "commit_hash": "9cb02640419614ae3771ebbffce076474380029b",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/9cb02640419614ae3771ebbffce076474380029b",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/shell.c.in"
        ],
        "message": "Add the \".parameter\" command to the CLI.\n\nFossilOrigin-Name: 1f9fa58541dc974989eee9c9a5d453956f7dbcf42965ece2db2cb5dee3f3f5e2",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/shell.c.in||src/shell.c.in"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: c7f70b6d96338dba201e005104e7f7148c1a8cd767ab05e35b44617c4c797bc5",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/shell.c.in||src/shell.c.in": [
          "File: src/shell.c.in -> src/shell.c.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "2751: #define BIND_PARAM_TABLE \"$Parameters\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2754: static void bind_table_init(ShellState *p){",
          "2755:   sqlite3_exec(p->db,",
          "2756:     \"CREATE TABLE IF NOT EXISTS temp.[\" BIND_PARAM_TABLE \"](\\n\"",
          "2757:     \"  key TEXT PRIMARY KEY,\\n\"",
          "2758:     \"  value ANY\\n\"",
          "2759:     \") WITHOUT ROWID;\",",
          "2760:     0, 0, 0);",
          "2761: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3547:   \"        --zip           FILE is a ZIP archive\",",
          "3548:   \".output ?FILE?           Send output to FILE or stdout if FILE is omitted\",",
          "3549:   \"     If FILE begins with '|' then open it as a pipe.\",",
          "3550:   \".print STRING...         Print literal STRING\",",
          "3551: #ifndef SQLITE_OMIT_PROGRESS_CALLBACK",
          "3552:   \".progress N              Invoke progress handler after every N opcodes\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3560:   \".parameter CMD ...       Manage SQL parameter bindings\",",
          "3561:   \"   clear                   Erase all bindings\",",
          "3562:   \"   init                    Initialize the TEMP table that holds bindings\",",
          "3563:   \"   list                    List the current parameter bindings\",",
          "3564:   \"   set PARAMETER VALUE     Given SQL parameter PARAMETER a value of VALUE\",",
          "3565:   \"                           PARAMETER should start with '$', ':', '@', or '?'\",",
          "3566:   \"   unset PARAMETER         Remove PARAMETER from the binding table\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "7078:     }",
          "7079:   }else",
          "7081:   if( c=='p' && n>=3 && strncmp(azArg[0], \"print\", n)==0 ){",
          "7082:     int i;",
          "7083:     for(i=1; i<nArg; i++){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7098:   if( c=='p' && n>=3 && strncmp(azArg[0], \"parameter\", n)==0 ){",
          "7099:     open_db(p,0);",
          "7100:     if( nArg<=1 ) goto parameter_syntax_error;",
          "7105:     if( nArg==2 && strcmp(azArg[1],\"clear\")==0 ){",
          "7106:       sqlite3_exec(p->db, \"DROP TABLE IF EXISTS temp.[\" BIND_PARAM_TABLE \"];\",",
          "7107:                    0, 0, 0);",
          "7108:     }else",
          "7113:     if( nArg==2 && strcmp(azArg[1],\"list\")==0 ){",
          "7114:       sqlite3_stmt *pStmt = 0;",
          "7115:       int rx;",
          "7116:       int len = 0;",
          "7117:       rx = sqlite3_prepare_v2(p->db,",
          "7118:              \"SELECT max(length(key)) \"",
          "7119:              \"FROM temp.[\" BIND_PARAM_TABLE \"];\", -1, &pStmt, 0);",
          "7120:       if( rx==SQLITE_OK && sqlite3_step(pStmt)==SQLITE_ROW ){",
          "7121:         len = sqlite3_column_int(pStmt, 0);",
          "7122:         if( len>40 ) len = 40;",
          "7123:       }",
          "7124:       sqlite3_finalize(pStmt);",
          "7125:       pStmt = 0;",
          "7126:       if( len ){",
          "7127:         rx = sqlite3_prepare_v2(p->db,",
          "7128:              \"SELECT key, quote(value) \"",
          "7129:              \"FROM temp.[\" BIND_PARAM_TABLE \"];\", -1, &pStmt, 0);",
          "7130:         while( sqlite3_step(pStmt)==SQLITE_ROW ){",
          "7131:           utf8_printf(p->out, \"%-*s %s\\n\", len, sqlite3_column_text(pStmt,0),",
          "7132:                       sqlite3_column_text(pStmt,1));",
          "7133:         }",
          "7134:         sqlite3_finalize(pStmt);",
          "7135:       }",
          "7136:     }else",
          "7142:     if( nArg==2 && strcmp(azArg[1],\"init\")==0 ){",
          "7143:       bind_table_init(p);",
          "7144:     }else",
          "7152:     if( nArg==4 && strcmp(azArg[1],\"set\")==0 ){",
          "7153:       int rx;",
          "7154:       char *zSql;",
          "7155:       sqlite3_stmt *pStmt;",
          "7156:       const char *zKey = azArg[2];",
          "7157:       const char *zValue = azArg[3];",
          "7158:       bind_table_init(p);",
          "7159:       zSql = sqlite3_mprintf(",
          "7160:                   \"REPLACE INTO temp.[\" BIND_PARAM_TABLE \"](key,value)\"",
          "7161:                   \"VALUES(%Q,%s);\", zKey, zValue);",
          "7162:       if( zSql==0 ) shell_out_of_memory();",
          "7163:       pStmt = 0;",
          "7164:       rx = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);",
          "7165:       sqlite3_free(zSql);",
          "7166:       if( rx!=SQLITE_OK ){",
          "7167:         sqlite3_finalize(pStmt);",
          "7168:         pStmt = 0;",
          "7169:         zSql = sqlite3_mprintf(",
          "7170:                    \"REPLACE INTO temp.[\" BIND_PARAM_TABLE \"](key,value)\"",
          "7171:                    \"VALUES(%Q,%Q);\", zKey, zValue);",
          "7172:         if( zSql==0 ) shell_out_of_memory();",
          "7173:         rx = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);",
          "7174:         sqlite3_free(zSql);",
          "7175:         if( rx!=SQLITE_OK ){",
          "7176:           utf8_printf(p->out, \"Error: %s\\n\", sqlite3_errmsg(p->db));",
          "7177:           sqlite3_finalize(pStmt);",
          "7178:           pStmt = 0;",
          "7179:           rc = 1;",
          "7180:         }",
          "7181:       }",
          "7182:       sqlite3_step(pStmt);",
          "7183:       sqlite3_finalize(pStmt);",
          "7184:     }else",
          "7190:     if( nArg==3 && strcmp(azArg[1],\"unset\")==0 ){",
          "7191:       char *zSql = sqlite3_mprintf(",
          "7192:           \"DELETE FROM temp.[\" BIND_PARAM_TABLE \"] WHERE key=%Q\", azArg[2]);",
          "7193:       if( zSql==0 ) shell_out_of_memory();",
          "7194:       sqlite3_exec(p->db, zSql, 0, 0, 0);",
          "7195:       sqlite3_free(zSql);",
          "7196:     }else",
          "7198:     parameter_syntax_error:",
          "7199:     showHelp(p->out, \"parameter\");",
          "7200:   }else",
          "",
          "---------------"
        ]
      }
    }
  ]
}
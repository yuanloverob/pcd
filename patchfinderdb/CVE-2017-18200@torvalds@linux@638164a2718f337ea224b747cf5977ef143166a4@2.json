{
  "cve_id": "CVE-2017-18200",
  "cve_desc": "The f2fs implementation in the Linux kernel before 4.14 mishandles reference counts associated with f2fs_wait_discard_bios calls, which allows local users to cause a denial of service (BUG), as demonstrated by fstrim.",
  "repo": "torvalds/linux",
  "patch_hash": "638164a2718f337ea224b747cf5977ef143166a4",
  "patch_info": {
    "commit_hash": "638164a2718f337ea224b747cf5977ef143166a4",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/638164a2718f337ea224b747cf5977ef143166a4",
    "files": [
      "fs/f2fs/f2fs.h",
      "fs/f2fs/segment.c",
      "fs/f2fs/super.c"
    ],
    "message": "f2fs: fix potential panic during fstrim\n\nAs Ju Hyung Park reported:\n\n\"When 'fstrim' is called for manual trim, a BUG() can be triggered\nrandomly with this patch.\n\nI'm seeing this issue on both x86 Desktop and arm64 Android phone.\n\nOn x86 Desktop, this was caused during Ubuntu boot-up. I have a\ncronjob installed which calls 'fstrim -v /' during boot. On arm64\nAndroid, this was caused during GC looping with 1ms gc_min_sleep_time\n& gc_max_sleep_time.\"\n\nRoot cause of this issue is that f2fs_wait_discard_bios can only be\nused by f2fs_put_super, because during put_super there must be no\nother referrers, so it can ignore discard entry's reference count\nwhen removing the entry, otherwise in other caller we will hit bug_on\nin __remove_discard_cmd as there may be other issuer added reference\ncount in discard entry.\n\nThread A\t\t\t\tThread B\n\t\t\t\t\t- issue_discard_thread\n- f2fs_ioc_fitrim\n - f2fs_trim_fs\n  - f2fs_wait_discard_bios\n   - __issue_discard_cmd\n    - __submit_discard_cmd\n\t\t\t\t\t - __wait_discard_cmd\n\t\t\t\t\t  - dc->ref++\n\t\t\t\t\t  - __wait_one_discard_bio\n   - __wait_discard_cmd\n    - __remove_discard_cmd\n     - f2fs_bug_on(sbi, dc->ref)\n\nFixes: 969d1b180d987c2be02de890d0fff0f66a0e80de\nReported-by: Ju Hyung Park <qkrwngud825@gmail.com>\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
    "before_after_code_files": [
      "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
      "fs/f2fs/segment.c||fs/f2fs/segment.c",
      "fs/f2fs/super.c||fs/f2fs/super.c"
    ]
  },
  "patch_diff": {
    "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h": [
      "File: fs/f2fs/f2fs.h -> fs/f2fs/f2fs.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "2525: bool is_checkpointed_data(struct f2fs_sb_info *sbi, block_t blkaddr);",
      "2526: void refresh_sit_entry(struct f2fs_sb_info *sbi, block_t old, block_t new);",
      "2527: void stop_discard_thread(struct f2fs_sb_info *sbi);",
      "2529: void clear_prefree_segments(struct f2fs_sb_info *sbi, struct cp_control *cpc);",
      "2530: void release_discard_addrs(struct f2fs_sb_info *sbi);",
      "2531: int npages_for_summary_flush(struct f2fs_sb_info *sbi, bool for_ra);",
      "",
      "[Removed Lines]",
      "2528: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi);",
      "",
      "[Added Lines]",
      "2528: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi, bool umount);",
      "",
      "---------------"
    ],
    "fs/f2fs/segment.c||fs/f2fs/segment.c": [
      "File: fs/f2fs/segment.c -> fs/f2fs/segment.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1210: }",
      "1214: {",
      "1215:  __issue_discard_cmd(sbi, false);",
      "1216:  __drop_discard_cmd(sbi);",
      "1218: }",
      "1220: static void mark_discard_range_all(struct f2fs_sb_info *sbi)",
      "",
      "[Removed Lines]",
      "1213: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)",
      "1217:  __wait_discard_cmd(sbi, false);",
      "",
      "[Added Lines]",
      "1213: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi, bool umount)",
      "1217:  __wait_discard_cmd(sbi, !umount);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2244:  }",
      "2246:  mark_discard_range_all(sbi);",
      "2248: out:",
      "2249:  range->len = F2FS_BLK_TO_BYTES(cpc.trimmed);",
      "2250:  return err;",
      "",
      "[Removed Lines]",
      "2247:  f2fs_wait_discard_bios(sbi);",
      "",
      "[Added Lines]",
      "2247:  f2fs_wait_discard_bios(sbi, false);",
      "",
      "---------------"
    ],
    "fs/f2fs/super.c||fs/f2fs/super.c": [
      "File: fs/f2fs/super.c -> fs/f2fs/super.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "801:  }",
      "806:  if (f2fs_discard_en(sbi) && !sbi->discard_blks) {",
      "807:   struct cp_control cpc = {",
      "",
      "[Removed Lines]",
      "804:  f2fs_wait_discard_bios(sbi);",
      "",
      "[Added Lines]",
      "804:  f2fs_wait_discard_bios(sbi, true);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5eba8c5d1fb3af28b2073ba5228d4998196c1bcc",
      "candidate_info": {
        "commit_hash": "5eba8c5d1fb3af28b2073ba5228d4998196c1bcc",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5eba8c5d1fb3af28b2073ba5228d4998196c1bcc",
        "files": [
          "fs/f2fs/f2fs.h",
          "fs/f2fs/segment.c",
          "fs/f2fs/super.c"
        ],
        "message": "f2fs: fix to access nullified flush_cmd_control pointer\n\nf2fs_sync_file()             remount_ro\n - f2fs_readonly\n                               - destroy_flush_cmd_control\n - f2fs_issue_flush\n   - no fcc pointer!\n\nSo, this patch doesn't free fcc in this case, but just stop its kernel thread\nwhich sends flush commands.\n\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
          "fs/f2fs/segment.c||fs/f2fs/segment.c",
          "fs/f2fs/super.c||fs/f2fs/super.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
            "fs/f2fs/segment.c||fs/f2fs/segment.c",
            "fs/f2fs/super.c||fs/f2fs/super.c"
          ],
          "candidate": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
            "fs/f2fs/segment.c||fs/f2fs/segment.c",
            "fs/f2fs/super.c||fs/f2fs/super.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h": [
          "File: fs/f2fs/f2fs.h -> fs/f2fs/f2fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2103: void f2fs_balance_fs_bg(struct f2fs_sb_info *);",
          "2104: int f2fs_issue_flush(struct f2fs_sb_info *);",
          "2105: int create_flush_cmd_control(struct f2fs_sb_info *);",
          "2107: void invalidate_blocks(struct f2fs_sb_info *, block_t);",
          "2108: bool is_checkpointed_data(struct f2fs_sb_info *, block_t);",
          "2109: void refresh_sit_entry(struct f2fs_sb_info *, block_t, block_t);",
          "",
          "[Removed Lines]",
          "2106: void destroy_flush_cmd_control(struct f2fs_sb_info *);",
          "",
          "[Added Lines]",
          "2106: void destroy_flush_cmd_control(struct f2fs_sb_info *, bool);",
          "",
          "---------------"
        ],
        "fs/f2fs/segment.c||fs/f2fs/segment.c": [
          "File: fs/f2fs/segment.c -> fs/f2fs/segment.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "489:  if (!fcc->dispatch_list)",
          "490:   wake_up(&fcc->flush_wait_queue);",
          "495:  return cmd.ret;",
          "496: }",
          "",
          "[Removed Lines]",
          "492:  wait_for_completion(&cmd.wait);",
          "493:  atomic_dec(&fcc->submit_flush);",
          "",
          "[Added Lines]",
          "492:  if (fcc->f2fs_issue_flush) {",
          "493:   wait_for_completion(&cmd.wait);",
          "494:   atomic_dec(&fcc->submit_flush);",
          "495:  } else {",
          "496:   llist_del_all(&fcc->issue_list);",
          "497:   atomic_set(&fcc->submit_flush, 0);",
          "498:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "501:  struct flush_cmd_control *fcc;",
          "502:  int err = 0;",
          "504:  fcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);",
          "505:  if (!fcc)",
          "506:   return -ENOMEM;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "509:  if (SM_I(sbi)->cmd_control_info) {",
          "510:   fcc = SM_I(sbi)->cmd_control_info;",
          "511:   goto init_thread;",
          "512:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "508:  init_waitqueue_head(&fcc->flush_wait_queue);",
          "509:  init_llist_head(&fcc->issue_list);",
          "510:  SM_I(sbi)->cmd_control_info = fcc;",
          "511:  fcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,",
          "512:     \"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));",
          "513:  if (IS_ERR(fcc->f2fs_issue_flush)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "521: init_thread:",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "520:  return err;",
          "521: }",
          "524: {",
          "525:  struct flush_cmd_control *fcc = SM_I(sbi)->cmd_control_info;",
          "531: }",
          "533: static void __locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,",
          "",
          "[Removed Lines]",
          "523: void destroy_flush_cmd_control(struct f2fs_sb_info *sbi)",
          "527:  if (fcc && fcc->f2fs_issue_flush)",
          "528:   kthread_stop(fcc->f2fs_issue_flush);",
          "529:  kfree(fcc);",
          "530:  SM_I(sbi)->cmd_control_info = NULL;",
          "",
          "[Added Lines]",
          "534: void destroy_flush_cmd_control(struct f2fs_sb_info *sbi, bool free)",
          "538:  if (fcc && fcc->f2fs_issue_flush) {",
          "539:   struct task_struct *flush_thread = fcc->f2fs_issue_flush;",
          "541:   fcc->f2fs_issue_flush = NULL;",
          "542:   kthread_stop(flush_thread);",
          "543:  }",
          "544:  if (free) {",
          "545:   kfree(fcc);",
          "546:   SM_I(sbi)->cmd_control_info = NULL;",
          "547:  }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2739:  if (!sm_info)",
          "2740:   return;",
          "2742:  destroy_dirty_segmap(sbi);",
          "2743:  destroy_curseg(sbi);",
          "2744:  destroy_free_segmap(sbi);",
          "",
          "[Removed Lines]",
          "2741:  destroy_flush_cmd_control(sbi);",
          "",
          "[Added Lines]",
          "2758:  destroy_flush_cmd_control(sbi, true);",
          "",
          "---------------"
        ],
        "fs/f2fs/super.c||fs/f2fs/super.c": [
          "File: fs/f2fs/super.c -> fs/f2fs/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1104:  if ((*flags & MS_RDONLY) || !test_opt(sbi, FLUSH_MERGE)) {",
          "1107:   err = create_flush_cmd_control(sbi);",
          "1108:   if (err)",
          "1109:    goto restore_gc;",
          "",
          "[Removed Lines]",
          "1105:   destroy_flush_cmd_control(sbi);",
          "1106:  } else if (!SM_I(sbi)->cmd_control_info) {",
          "",
          "[Added Lines]",
          "1105:   clear_opt(sbi, FLUSH_MERGE);",
          "1106:   destroy_flush_cmd_control(sbi, false);",
          "1107:  } else {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5a6154920faf9d3d5a39de1da49c66af9831d270",
      "candidate_info": {
        "commit_hash": "5a6154920faf9d3d5a39de1da49c66af9831d270",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5a6154920faf9d3d5a39de1da49c66af9831d270",
        "files": [
          "fs/f2fs/segment.c"
        ],
        "message": "f2fs: don't issue discard commands in online discard is on\n\nActually, we don't need to issue discard commands, if discard is on, as\nmentioned in the comment.\n\nReviewed-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/segment.c||fs/f2fs/segment.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/segment.c||fs/f2fs/segment.c"
          ],
          "candidate": [
            "fs/f2fs/segment.c||fs/f2fs/segment.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/segment.c||fs/f2fs/segment.c": [
          "File: fs/f2fs/segment.c -> fs/f2fs/segment.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2469:  if (err)",
          "2470:   goto out;",
          "2486:      start_block, end_block);",
          "2489: out:",
          "2490:  return err;",
          "2491: }",
          "",
          "[Removed Lines]",
          "2472:  start_block = START_BLOCK(sbi, start_segno);",
          "2473:  end_block = START_BLOCK(sbi, end_segno + 1);",
          "2475:  __init_discard_policy(sbi, &dpolicy, DPOLICY_FSTRIM, cpc.trim_minlen);",
          "2476:  __issue_discard_cmd_range(sbi, &dpolicy, start_block, end_block);",
          "2484:  if (!test_opt(sbi, DISCARD)) {",
          "2485:   trimmed = __wait_discard_cmd_range(sbi, &dpolicy,",
          "2487:   range->len = F2FS_BLK_TO_BYTES(trimmed);",
          "2488:  }",
          "",
          "[Added Lines]",
          "2478:  if (test_opt(sbi, DISCARD))",
          "2479:   goto out;",
          "2481:  start_block = START_BLOCK(sbi, start_segno);",
          "2482:  end_block = START_BLOCK(sbi, end_segno + 1);",
          "2484:  __init_discard_policy(sbi, &dpolicy, DPOLICY_FSTRIM, cpc.trim_minlen);",
          "2485:  __issue_discard_cmd_range(sbi, &dpolicy, start_block, end_block);",
          "2487:  trimmed = __wait_discard_cmd_range(sbi, &dpolicy,",
          "2489:  range->len = F2FS_BLK_TO_BYTES(trimmed);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8bb4f2535cf7c3e3aeaed8b3c7c7a116844c41db",
      "candidate_info": {
        "commit_hash": "8bb4f2535cf7c3e3aeaed8b3c7c7a116844c41db",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8bb4f2535cf7c3e3aeaed8b3c7c7a116844c41db",
        "files": [
          "fs/f2fs/f2fs.h",
          "fs/f2fs/segment.c"
        ],
        "message": "f2fs: issue discard commands proactively in high fs utilization\n\nIn the high utilization like over 80%, we don't expect huge # of large discard\ncommands, but do many small pending discards which affects FTL GCs a lot.\nLet's issue them in that case.\n\nReviewed-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
          "fs/f2fs/segment.c||fs/f2fs/segment.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
            "fs/f2fs/segment.c||fs/f2fs/segment.c"
          ],
          "candidate": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
            "fs/f2fs/segment.c||fs/f2fs/segment.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h": [
          "File: fs/f2fs/f2fs.h -> fs/f2fs/f2fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2777: void destroy_flush_cmd_control(struct f2fs_sb_info *sbi, bool free);",
          "2778: void invalidate_blocks(struct f2fs_sb_info *sbi, block_t addr);",
          "2779: bool is_checkpointed_data(struct f2fs_sb_info *sbi, block_t blkaddr);",
          "2782: void drop_discard_cmd(struct f2fs_sb_info *sbi);",
          "2783: void stop_discard_thread(struct f2fs_sb_info *sbi);",
          "2784: bool f2fs_wait_discard_bios(struct f2fs_sb_info *sbi);",
          "",
          "[Removed Lines]",
          "2780: void init_discard_policy(struct discard_policy *dpolicy, int discard_type,",
          "2781:       unsigned int granularity);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/f2fs/segment.c||fs/f2fs/segment.c": [
          "File: fs/f2fs/segment.c -> fs/f2fs/segment.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "915: #endif",
          "916: }",
          "919: static void __submit_discard_cmd(struct f2fs_sb_info *sbi,",
          "920:       struct discard_policy *dpolicy,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "918: static void __init_discard_policy(struct f2fs_sb_info *sbi,",
          "919:     struct discard_policy *dpolicy,",
          "920:     int discard_type, unsigned int granularity)",
          "921: {",
          "923:  dpolicy->type = discard_type;",
          "924:  dpolicy->sync = true;",
          "925:  dpolicy->granularity = granularity;",
          "927:  dpolicy->max_requests = DEF_MAX_DISCARD_REQUEST;",
          "928:  dpolicy->io_aware_gran = MAX_PLIST_NUM;",
          "930:  if (discard_type == DPOLICY_BG) {",
          "931:   dpolicy->min_interval = DEF_MIN_DISCARD_ISSUE_TIME;",
          "932:   dpolicy->max_interval = DEF_MAX_DISCARD_ISSUE_TIME;",
          "933:   dpolicy->io_aware = true;",
          "934:   if (utilization(sbi) > DEF_DISCARD_URGENT_UTIL) {",
          "935:    dpolicy->granularity = 1;",
          "936:    dpolicy->max_interval = DEF_MIN_DISCARD_ISSUE_TIME;",
          "937:   }",
          "938:  } else if (discard_type == DPOLICY_FORCE) {",
          "939:   dpolicy->min_interval = DEF_MIN_DISCARD_ISSUE_TIME;",
          "940:   dpolicy->max_interval = DEF_MAX_DISCARD_ISSUE_TIME;",
          "941:   dpolicy->io_aware = false;",
          "942:  } else if (discard_type == DPOLICY_FSTRIM) {",
          "943:   dpolicy->io_aware = false;",
          "944:  } else if (discard_type == DPOLICY_UMOUNT) {",
          "945:   dpolicy->io_aware = false;",
          "946:  }",
          "947: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1278:  }",
          "1282:  __wait_discard_cmd_range(sbi, &dp, 0, UINT_MAX);",
          "1284:  __wait_discard_cmd_range(sbi, &dp, 0, UINT_MAX);",
          "1285: }",
          "",
          "[Removed Lines]",
          "1281:  init_discard_policy(&dp, DPOLICY_FSTRIM, 1);",
          "1283:  init_discard_policy(&dp, DPOLICY_UMOUNT, 1);",
          "",
          "[Added Lines]",
          "1313:  __init_discard_policy(sbi, &dp, DPOLICY_FSTRIM, 1);",
          "1315:  __init_discard_policy(sbi, &dp, DPOLICY_UMOUNT, 1);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1326:  struct discard_policy dpolicy;",
          "1327:  bool dropped;",
          "1330:  __issue_discard_cmd(sbi, &dpolicy);",
          "1331:  dropped = __drop_discard_cmd(sbi);",
          "",
          "[Removed Lines]",
          "1329:  init_discard_policy(&dpolicy, DPOLICY_UMOUNT, dcc->discard_granularity);",
          "",
          "[Added Lines]",
          "1361:  __init_discard_policy(sbi, &dpolicy, DPOLICY_UMOUNT,",
          "1362:      dcc->discard_granularity);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1347:  set_freezable();",
          "1349:  do {",
          "1351:      dcc->discard_granularity);",
          "1353:   wait_event_interruptible_timeout(*q,",
          "",
          "[Removed Lines]",
          "1350:   init_discard_policy(&dpolicy, DPOLICY_BG,",
          "",
          "[Added Lines]",
          "1383:   __init_discard_policy(sbi, &dpolicy, DPOLICY_BG,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1365:    dcc->discard_wake = 0;",
          "1367:   if (sbi->gc_thread && sbi->gc_thread->gc_urgent)",
          "1370:   sb_start_intwrite(sbi->sb);",
          "",
          "[Removed Lines]",
          "1368:    init_discard_policy(&dpolicy, DPOLICY_FORCE, 1);",
          "",
          "[Added Lines]",
          "1401:    __init_discard_policy(sbi, &dpolicy, DPOLICY_FORCE, 1);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1658:  wake_up_discard_thread(sbi, false);",
          "1659: }",
          "1687: static int create_discard_cmd_control(struct f2fs_sb_info *sbi)",
          "1688: {",
          "1689:  dev_t dev = sbi->sb->s_bdev->bd_dev;",
          "",
          "[Removed Lines]",
          "1661: void init_discard_policy(struct discard_policy *dpolicy,",
          "1662:     int discard_type, unsigned int granularity)",
          "1663: {",
          "1665:  dpolicy->type = discard_type;",
          "1666:  dpolicy->sync = true;",
          "1667:  dpolicy->granularity = granularity;",
          "1669:  dpolicy->max_requests = DEF_MAX_DISCARD_REQUEST;",
          "1670:  dpolicy->io_aware_gran = MAX_PLIST_NUM;",
          "1672:  if (discard_type == DPOLICY_BG) {",
          "1673:   dpolicy->min_interval = DEF_MIN_DISCARD_ISSUE_TIME;",
          "1674:   dpolicy->max_interval = DEF_MAX_DISCARD_ISSUE_TIME;",
          "1675:   dpolicy->io_aware = true;",
          "1676:  } else if (discard_type == DPOLICY_FORCE) {",
          "1677:   dpolicy->min_interval = DEF_MIN_DISCARD_ISSUE_TIME;",
          "1678:   dpolicy->max_interval = DEF_MAX_DISCARD_ISSUE_TIME;",
          "1679:   dpolicy->io_aware = false;",
          "1680:  } else if (discard_type == DPOLICY_FSTRIM) {",
          "1681:   dpolicy->io_aware = false;",
          "1682:  } else if (discard_type == DPOLICY_UMOUNT) {",
          "1683:   dpolicy->io_aware = false;",
          "1684:  }",
          "1685: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2442:  start_block = START_BLOCK(sbi, start_segno);",
          "2443:  end_block = START_BLOCK(sbi, min(cur_segno, end_segno) + 1);",
          "2446:  __issue_discard_cmd_range(sbi, &dpolicy, start_block, end_block);",
          "2447:  trimmed = __wait_discard_cmd_range(sbi, &dpolicy,",
          "2448:      start_block, end_block);",
          "",
          "[Removed Lines]",
          "2445:  init_discard_policy(&dpolicy, DPOLICY_FSTRIM, cpc.trim_minlen);",
          "",
          "[Added Lines]",
          "2452:  __init_discard_policy(sbi, &dpolicy, DPOLICY_FSTRIM, cpc.trim_minlen);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "25290fa5591d81767713db304e0d567bf991786f",
      "candidate_info": {
        "commit_hash": "25290fa5591d81767713db304e0d567bf991786f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/25290fa5591d81767713db304e0d567bf991786f",
        "files": [
          "fs/f2fs/checkpoint.c",
          "fs/f2fs/f2fs.h",
          "fs/f2fs/segment.c"
        ],
        "message": "f2fs: return fs_trim if there is no candidate\n\nIf there is no candidate to submit discard command during f2fs_trim_fs, let's\nreturn without checkpoint.\n\nReviewed-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/checkpoint.c||fs/f2fs/checkpoint.c",
          "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
          "fs/f2fs/segment.c||fs/f2fs/segment.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
            "fs/f2fs/segment.c||fs/f2fs/segment.c"
          ],
          "candidate": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
            "fs/f2fs/segment.c||fs/f2fs/segment.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/checkpoint.c||fs/f2fs/checkpoint.c": [
          "File: fs/f2fs/checkpoint.c -> fs/f2fs/checkpoint.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1251:  if (cpc->reason == CP_DISCARD) {",
          "1252:   if (NM_I(sbi)->dirty_nat_cnt == 0 &&",
          "1253:     SIT_I(sbi)->dirty_sentries == 0 &&",
          "1254:     prefree_segments(sbi) == 0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1252:   if (!exist_trim_candidates(sbi, cpc)) {",
          "1253:    unblock_operations(sbi);",
          "1254:    goto out;",
          "1255:   }",
          "",
          "---------------"
        ],
        "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h": [
          "File: fs/f2fs/f2fs.h -> fs/f2fs/f2fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2119: int npages_for_summary_flush(struct f2fs_sb_info *, bool);",
          "2120: void allocate_new_segments(struct f2fs_sb_info *);",
          "2121: int f2fs_trim_fs(struct f2fs_sb_info *, struct fstrim_range *);",
          "2122: struct page *get_sum_page(struct f2fs_sb_info *, unsigned int);",
          "2123: void update_meta_page(struct f2fs_sb_info *, void *, block_t);",
          "2124: void write_meta_page(struct f2fs_sb_info *, struct page *);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2122: bool exist_trim_candidates(struct f2fs_sb_info *, struct cp_control *);",
          "",
          "---------------"
        ],
        "fs/f2fs/segment.c||fs/f2fs/segment.c": [
          "File: fs/f2fs/segment.c -> fs/f2fs/segment.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "834:  SM_I(sbi)->nr_discards += end - start;",
          "835: }",
          "838: {",
          "839:  int entries = SIT_VBLOCK_MAP_SIZE / sizeof(unsigned long);",
          "840:  int max_blocks = sbi->blocks_per_seg;",
          "",
          "[Removed Lines]",
          "837: static void add_discard_addrs(struct f2fs_sb_info *sbi, struct cp_control *cpc)",
          "",
          "[Added Lines]",
          "837: static bool add_discard_addrs(struct f2fs_sb_info *sbi, struct cp_control *cpc,",
          "838:        bool check_only)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "848:  int i;",
          "850:  if (se->valid_blocks == max_blocks || !f2fs_discard_en(sbi))",
          "853:  if (!force) {",
          "854:   if (!test_opt(sbi, DISCARD) || !se->valid_blocks ||",
          "855:       SM_I(sbi)->nr_discards >= SM_I(sbi)->max_discards)",
          "857:  }",
          "",
          "[Removed Lines]",
          "851:   return;",
          "856:    return;",
          "",
          "[Added Lines]",
          "852:   return false;",
          "857:    return false;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "871:      && (end - start) < cpc->trim_minlen)",
          "872:    continue;",
          "874:   __add_discard_entry(sbi, cpc, se, start, end);",
          "875:  }",
          "876: }",
          "878: void release_discard_addrs(struct f2fs_sb_info *sbi)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "875:   if (check_only)",
          "876:    return true;",
          "880:  return false;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1453:  .allocate_segment = allocate_segment_by_default,",
          "1454: };",
          "1456: int f2fs_trim_fs(struct f2fs_sb_info *sbi, struct fstrim_range *range)",
          "1457: {",
          "1458:  __u64 start = F2FS_BYTES_TO_BLK(range->start);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1461: bool exist_trim_candidates(struct f2fs_sb_info *sbi, struct cp_control *cpc)",
          "1462: {",
          "1463:  __u64 trim_start = cpc->trim_start;",
          "1464:  bool has_candidate = false;",
          "1466:  mutex_lock(&SIT_I(sbi)->sentry_lock);",
          "1467:  for (; cpc->trim_start <= cpc->trim_end; cpc->trim_start++) {",
          "1468:   if (add_discard_addrs(sbi, cpc, true)) {",
          "1469:    has_candidate = true;",
          "1470:    break;",
          "1471:   }",
          "1472:  }",
          "1473:  mutex_unlock(&SIT_I(sbi)->sentry_lock);",
          "1475:  cpc->trim_start = trim_start;",
          "1476:  return has_candidate;",
          "1477: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2250:    if (cpc->reason != CP_DISCARD) {",
          "2251:     cpc->trim_start = segno;",
          "2253:    }",
          "2255:    if (to_journal) {",
          "",
          "[Removed Lines]",
          "2252:     add_discard_addrs(sbi, cpc);",
          "",
          "[Added Lines]",
          "2275:     add_discard_addrs(sbi, cpc, false);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2287:   __u64 trim_start = cpc->trim_start;",
          "2289:   for (; cpc->trim_start <= cpc->trim_end; cpc->trim_start++)",
          "2292:   cpc->trim_start = trim_start;",
          "2293:  }",
          "",
          "[Removed Lines]",
          "2290:    add_discard_addrs(sbi, cpc);",
          "",
          "[Added Lines]",
          "2313:    add_discard_addrs(sbi, cpc, false);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "22d375dd9cc6ee9ff6382487fdd6ca4759af82a9",
      "candidate_info": {
        "commit_hash": "22d375dd9cc6ee9ff6382487fdd6ca4759af82a9",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/22d375dd9cc6ee9ff6382487fdd6ca4759af82a9",
        "files": [
          "fs/f2fs/f2fs.h",
          "fs/f2fs/segment.c"
        ],
        "message": "f2fs: split discard_cmd_list\n\nSplit discard_cmd_list to discard_{pend,wait}_list, so while sending/waiting\ndiscard command, we can avoid traversing unneeded entries in original list.\n\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
          "fs/f2fs/segment.c||fs/f2fs/segment.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
            "fs/f2fs/segment.c||fs/f2fs/segment.c"
          ],
          "candidate": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
            "fs/f2fs/segment.c||fs/f2fs/segment.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h": [
          "File: fs/f2fs/f2fs.h -> fs/f2fs/f2fs.h"
        ],
        "fs/f2fs/segment.c||fs/f2fs/segment.c": [
          "File: fs/f2fs/segment.c -> fs/f2fs/segment.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "677:   block_t start, block_t len)",
          "678: {",
          "679:  struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;",
          "681:  struct discard_cmd *dc;",
          "683:  dc = f2fs_kmem_cache_alloc(discard_cmd_slab, GFP_NOFS);",
          "",
          "[Removed Lines]",
          "680:  struct list_head *cmd_list = &(dcc->discard_cmd_list);",
          "",
          "[Added Lines]",
          "680:  struct list_head *pend_list = &(dcc->discard_pend_list);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "691:  init_completion(&dc->wait);",
          "693:  mutex_lock(&dcc->cmd_lock);",
          "695:  mutex_unlock(&dcc->cmd_lock);",
          "697:  atomic_inc(&dcc->discard_cmd_cnt);",
          "",
          "[Removed Lines]",
          "694:  list_add_tail(&dc->list, cmd_list);",
          "",
          "[Added Lines]",
          "694:  list_add_tail(&dc->list, pend_list);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "747:    bio->bi_end_io = f2fs_submit_discard_endio;",
          "748:    bio->bi_opf |= REQ_SYNC;",
          "749:    submit_bio(bio);",
          "750:   }",
          "751:  } else {",
          "752:   __remove_discard_cmd(sbi, dc);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "750:    list_move_tail(&dc->list, &dcc->discard_wait_list);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "793: void f2fs_wait_discard_bio(struct f2fs_sb_info *sbi, block_t blkaddr)",
          "794: {",
          "795:  struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;",
          "797:  struct discard_cmd *dc, *tmp;",
          "798:  struct blk_plug plug;",
          "800:  mutex_lock(&dcc->cmd_lock);",
          "811:   if (dc->lstart <= blkaddr && blkaddr < dc->lstart + dc->len) {",
          "812:    if (dc->state == D_SUBMIT)",
          "813:     wait_for_completion_io(&dc->wait);",
          "814:    __punch_discard_cmd(sbi, dc, blkaddr);",
          "815:   }",
          "816:  }",
          "820:  if (blkaddr == NULL_ADDR) {",
          "821:   list_for_each_entry_safe(dc, tmp, wait_list, list) {",
          "822:    wait_for_completion_io(&dc->wait);",
          "823:    __remove_discard_cmd(sbi, dc);",
          "",
          "[Removed Lines]",
          "796:  struct list_head *wait_list = &(dcc->discard_cmd_list);",
          "802:  blk_start_plug(&plug);",
          "804:  list_for_each_entry_safe(dc, tmp, wait_list, list) {",
          "806:   if (blkaddr == NULL_ADDR) {",
          "807:    __submit_discard_cmd(sbi, dc);",
          "808:    continue;",
          "809:   }",
          "817:  blk_finish_plug(&plug);",
          "",
          "[Added Lines]",
          "797:  struct list_head *pend_list = &(dcc->discard_pend_list);",
          "798:  struct list_head *wait_list = &(dcc->discard_wait_list);",
          "804:  if (blkaddr == NULL_ADDR)",
          "805:   goto release_discard;",
          "807:  list_for_each_entry_safe(dc, tmp, pend_list, list) {",
          "808:   if (dc->lstart <= blkaddr && blkaddr < dc->lstart + dc->len)",
          "809:    __punch_discard_cmd(sbi, dc, blkaddr);",
          "810:  }",
          "812:  list_for_each_entry_safe(dc, tmp, wait_list, list) {",
          "820: release_discard:",
          "823:   blk_start_plug(&plug);",
          "824:   list_for_each_entry_safe(dc, tmp, pend_list, list)",
          "825:    __submit_discard_cmd(sbi, dc);",
          "826:   blk_finish_plug(&plug);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "831:  struct f2fs_sb_info *sbi = data;",
          "832:  struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;",
          "833:  wait_queue_head_t *q = &dcc->discard_wait_queue;",
          "835:  struct discard_cmd *dc, *tmp;",
          "836:  struct blk_plug plug;",
          "837:  int iter = 0;",
          "",
          "[Removed Lines]",
          "834:  struct list_head *cmd_list = &dcc->discard_cmd_list;",
          "",
          "[Added Lines]",
          "841:  struct list_head *pend_list = &dcc->discard_pend_list;",
          "842:  struct list_head *wait_list = &dcc->discard_wait_list;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "842:  blk_start_plug(&plug);",
          "844:  mutex_lock(&dcc->cmd_lock);",
          "847:   if (is_idle(sbi))",
          "848:    __submit_discard_cmd(sbi, dc);",
          "851:    break;",
          "852:   if (dc->state == D_DONE)",
          "853:    __remove_discard_cmd(sbi, dc);",
          "854:  }",
          "",
          "[Removed Lines]",
          "845:  list_for_each_entry_safe(dc, tmp, cmd_list, list) {",
          "850:   if (dc->state == D_PREP && iter++ > DISCARD_ISSUE_RATE)",
          "",
          "[Added Lines]",
          "853:  list_for_each_entry_safe(dc, tmp, pend_list, list) {",
          "854:   f2fs_bug_on(sbi, dc->state != D_PREP);",
          "859:   if (iter++ > DISCARD_ISSUE_RATE)",
          "861:  }",
          "863:  list_for_each_entry_safe(dc, tmp, wait_list, list) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "859:  iter = 0;",
          "860:  congestion_wait(BLK_RW_SYNC, HZ/50);",
          "864:  goto repeat;",
          "865: }",
          "",
          "[Removed Lines]",
          "862:  wait_event_interruptible(*q,",
          "863:   kthread_should_stop() || !list_empty(&dcc->discard_cmd_list));",
          "",
          "[Added Lines]",
          "874:  wait_event_interruptible(*q, kthread_should_stop() ||",
          "875:    !list_empty(pend_list) || !list_empty(wait_list));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1152:   return -ENOMEM;",
          "1154:  INIT_LIST_HEAD(&dcc->discard_entry_list);",
          "1156:  mutex_init(&dcc->cmd_lock);",
          "1157:  atomic_set(&dcc->issued_discard, 0);",
          "1158:  atomic_set(&dcc->issing_discard, 0);",
          "",
          "[Removed Lines]",
          "1155:  INIT_LIST_HEAD(&dcc->discard_cmd_list);",
          "",
          "[Added Lines]",
          "1167:  INIT_LIST_HEAD(&dcc->discard_pend_list);",
          "1168:  INIT_LIST_HEAD(&dcc->discard_wait_list);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
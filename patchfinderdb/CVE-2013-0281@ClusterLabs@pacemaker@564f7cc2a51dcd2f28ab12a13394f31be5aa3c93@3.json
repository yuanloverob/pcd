{
  "cve_id": "CVE-2013-0281",
  "cve_desc": "Pacemaker 1.1.10, when remote Cluster Information Base (CIB) configuration or resource management is enabled, does not limit the duration of connections to the blocking sockets, which allows remote attackers to cause a denial of service (connection blocking).",
  "repo": "ClusterLabs/pacemaker",
  "patch_hash": "564f7cc2a51dcd2f28ab12a13394f31be5aa3c93",
  "patch_info": {
    "commit_hash": "564f7cc2a51dcd2f28ab12a13394f31be5aa3c93",
    "repo": "ClusterLabs/pacemaker",
    "commit_url": "https://github.com/ClusterLabs/pacemaker/commit/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93",
    "files": [
      "cib/callbacks.c",
      "cib/callbacks.h",
      "cib/notify.c",
      "cib/remote.c",
      "include/crm_internal.h",
      "lib/cib/cib_remote.c",
      "lib/common/mainloop.c",
      "lib/common/remote.c",
      "tools/crm_mon.c"
    ],
    "message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend.",
    "before_after_code_files": [
      "cib/callbacks.c||cib/callbacks.c",
      "cib/callbacks.h||cib/callbacks.h",
      "cib/notify.c||cib/notify.c",
      "cib/remote.c||cib/remote.c",
      "include/crm_internal.h||include/crm_internal.h",
      "lib/cib/cib_remote.c||lib/cib/cib_remote.c",
      "lib/common/mainloop.c||lib/common/mainloop.c",
      "lib/common/remote.c||lib/common/remote.c",
      "tools/crm_mon.c||tools/crm_mon.c"
    ]
  },
  "patch_diff": {
    "cib/callbacks.c||cib/callbacks.c": [
      "File: cib/callbacks.c -> cib/callbacks.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "347:         int rid = 0;",
      "349:         if(sync_reply) {",
      "356:                       rid, client_obj->name, from_peer?\"(originator of delegated request)\":\"\");",
      "358:         } else {",
      "359:             crm_trace(\"Sending an event to %s %s\",",
      "",
      "[Removed Lines]",
      "350:             CRM_LOG_ASSERT(client_obj->request_id);",
      "352:             rid = client_obj->request_id;",
      "353:             client_obj->request_id = 0;",
      "355:             crm_trace(\"Sending response %d to %s %s\",",
      "",
      "[Added Lines]",
      "350:             if (client_obj->ipc) {",
      "351:                 CRM_LOG_ASSERT(client_obj->request_id);",
      "353:                 rid = client_obj->request_id;",
      "354:                 client_obj->request_id = 0;",
      "356:                 crm_trace(\"Sending response %d to %s %s\",",
      "358:             } else {",
      "359:                 crm_trace(\"Sending response to %s %s\",",
      "360:                       client_obj->name, from_peer?\"(originator of delegated request)\":\"\");",
      "361:             }",
      "",
      "---------------"
    ],
    "cib/callbacks.h||cib/callbacks.h": [
      "File: cib/callbacks.h -> cib/callbacks.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "41:     char *name;",
      "42:     char *callback_id;",
      "43:     char *user;",
      "44:     int request_id;",
      "46:     qb_ipcs_connection_t *ipc;",
      "48: #ifdef HAVE_GNUTLS_GNUTLS_H",
      "49:     gnutls_session *session;",
      "50: #else",
      "51:     void *session;",
      "52: #endif",
      "53:     gboolean encrypted;",
      "54:     mainloop_io_t *remote;",
      "56:     unsigned long num_calls;",
      "58:     int pre_notify;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "44:     char *recv_buf;",
      "51:     gboolean handshake_complete;",
      "56:     gboolean remote_auth;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "60:     int confirmations;",
      "61:     int replace;",
      "62:     int diffs;",
      "64:     GList *delegated_calls;",
      "65: } cib_client_t;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "66:     int remote_auth_timeout;",
      "",
      "---------------"
    ],
    "cib/notify.c||cib/notify.c": [
      "File: cib/notify.c -> cib/notify.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "83:     CRM_CHECK(client != NULL, return TRUE);",
      "84:     CRM_CHECK(update_msg != NULL, return TRUE);",
      "87:         crm_warn(\"Skipping client with NULL channel\");",
      "88:         return FALSE;",
      "89:     }",
      "",
      "[Removed Lines]",
      "86:     if (client->ipc == NULL) {",
      "",
      "[Added Lines]",
      "86:     if (client->ipc == NULL && client->session == NULL) {",
      "",
      "---------------"
    ],
    "cib/remote.c||cib/remote.c": [
      "File: cib/remote.c -> cib/remote.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "60: #  endif",
      "61: #endif",
      "67: extern int remote_tls_fd;",
      "68: extern gboolean cib_shutdown_flag;",
      "",
      "[Removed Lines]",
      "63: #ifdef HAVE_DECL_NANOSLEEP",
      "64: #  include <time.h>",
      "65: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "73: #ifdef HAVE_GNUTLS_GNUTLS_H",
      "74: #  define DH_BITS 1024",
      "75: gnutls_dh_params dh_params;",
      "77: static void",
      "78: debug_log(int level, const char *str)",
      "79: {",
      "80:     fputs(str, stderr);",
      "81: }",
      "85: #endif",
      "87: int num_clients;",
      "88: int authenticate_user(const char *user, const char *passwd);",
      "89: int cib_remote_listen(gpointer data);",
      "",
      "[Removed Lines]",
      "76: extern gnutls_anon_server_credentials anon_cred_s;",
      "83: extern gnutls_session *create_tls_session(int csock, int type);",
      "",
      "[Added Lines]",
      "72: gnutls_anon_server_credentials anon_cred_s;",
      "80: #define REMOTE_AUTH_TIMEOUT 10000",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "215:     return FALSE;",
      "216: }",
      "218: int",
      "219: cib_remote_listen(gpointer data)",
      "220: {",
      "222:     int csock = 0;",
      "223:     unsigned laddr;",
      "226:     struct sockaddr_in addr;",
      "227:     int ssock = *(int *)data;",
      "229: #ifdef HAVE_GNUTLS_GNUTLS_H",
      "230:     gnutls_session *session = NULL;",
      "231: #endif",
      "232:     cib_client_t *new_client = NULL;",
      "243:     static struct mainloop_fd_callbacks remote_client_fd_callbacks =",
      "244:         {",
      "245:             .dispatch = cib_remote_msg,",
      "246:             .destroy = cib_remote_connection_destroy,",
      "250:     laddr = sizeof(addr);",
      "251:     csock = accept(ssock, (struct sockaddr *)&addr, &laddr);",
      "",
      "[Removed Lines]",
      "221:     int lpc = 0;",
      "224:     time_t now = 0;",
      "225:     time_t start = time(NULL);",
      "234:     xmlNode *login = NULL;",
      "235:     const char *user = NULL;",
      "236:     const char *pass = NULL;",
      "237:     const char *tmp = NULL;",
      "239: #ifdef HAVE_DECL_NANOSLEEP",
      "241: #endif",
      "247:         };",
      "",
      "[Added Lines]",
      "213: static gboolean",
      "214: cib_remote_auth(xmlNode *login)",
      "215: {",
      "216:     const char *user = NULL;",
      "217:     const char *pass = NULL;",
      "218:     const char *tmp = NULL;",
      "220:     crm_log_xml_info(login, \"Login: \");",
      "221:     if (login == NULL) {",
      "222:         return FALSE;",
      "223:     }",
      "225:     tmp = crm_element_name(login);",
      "226:     if (safe_str_neq(tmp, \"cib_command\")) {",
      "227:         crm_err(\"Wrong tag: %s\", tmp);",
      "228:         return FALSE;",
      "229:     }",
      "231:     tmp = crm_element_value(login, \"op\");",
      "232:     if (safe_str_neq(tmp, \"authenticate\")) {",
      "233:         crm_err(\"Wrong operation: %s\", tmp);",
      "234:         return FALSE;",
      "235:     }",
      "237:     user = crm_element_value(login, \"user\");",
      "238:     pass = crm_element_value(login, \"password\");",
      "240:     if (!user || !pass) {",
      "241:         crm_err(\"missing auth credentials\");",
      "242:         return FALSE;",
      "243:     }",
      "248:     if (check_group_membership(user, CRM_DAEMON_GROUP) == FALSE) {",
      "249:         crm_err(\"User is not a member of the required group\");",
      "250:         return FALSE;",
      "252:     } else if (authenticate_user(user, pass) == FALSE) {",
      "253:         crm_err(\"PAM auth failed\");",
      "254:         return FALSE;",
      "255:     }",
      "257:     return TRUE;",
      "258: }",
      "260: static gboolean",
      "261: remote_auth_timeout_cb(gpointer data)",
      "262: {",
      "263:     cib_client_t *client = data;",
      "265:     client->remote_auth_timeout = 0;",
      "267:     if (client->remote_auth == TRUE) {",
      "268:         return FALSE;",
      "269:     }",
      "271:     mainloop_del_fd(client->remote);",
      "272:     crm_err(\"Remote client authentication timed out\");",
      "274:     return FALSE;",
      "275: }",
      "283:     int flag;",
      "294:         };",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "257:         return TRUE;",
      "258:     }",
      "260:     if (ssock == remote_tls_fd) {",
      "261: #ifdef HAVE_GNUTLS_GNUTLS_H",
      "264:         if (session == NULL) {",
      "265:             crm_err(\"TLS session creation failed\");",
      "266:             close(csock);",
      "",
      "[Removed Lines]",
      "263:         session = create_tls_session(csock, GNUTLS_SERVER);",
      "",
      "[Added Lines]",
      "307:     if ((flag = fcntl(csock, F_GETFL)) >= 0) {",
      "308:         if (fcntl(csock, F_SETFL, flag | O_NONBLOCK) < 0) {",
      "309:             crm_err( \"fcntl() write failed\");",
      "310:             close(csock);",
      "311:             return TRUE;",
      "312:         }",
      "313:     } else {",
      "314:         crm_err( \"fcntl() read failed\");",
      "315:         close(csock);",
      "316:         return TRUE;",
      "317:     }",
      "322:         session = crm_create_anon_tls_session(csock, GNUTLS_SERVER, anon_cred_s);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "269: #endif",
      "270:     }",
      "327:     num_clients++;",
      "328:     new_client = calloc(1, sizeof(cib_client_t));",
      "332:     new_client->id = crm_generate_uuid();",
      "338:     new_client->callback_id = NULL;",
      "339:     if (ssock == remote_tls_fd) {",
      "340: #ifdef HAVE_GNUTLS_GNUTLS_H",
      "341:         new_client->encrypted = TRUE;",
      "",
      "[Removed Lines]",
      "272:     do {",
      "273:         crm_trace(\"Iter: %d\", lpc++);",
      "274:         if (ssock == remote_tls_fd) {",
      "275: #ifdef HAVE_GNUTLS_GNUTLS_H",
      "276:             login = crm_recv_remote_msg(session, TRUE);",
      "277: #endif",
      "278:         } else {",
      "279:             login = crm_recv_remote_msg(GINT_TO_POINTER(csock), FALSE);",
      "280:         }",
      "281:         if (login != NULL) {",
      "282:             break;",
      "283:         }",
      "284: #ifdef HAVE_DECL_NANOSLEEP",
      "285:         nanosleep(&sleepfast, NULL);",
      "286: #else",
      "287:         sleep(1);",
      "288: #endif",
      "289:         now = time(NULL);",
      "292:     } while (login == NULL && (start - now) < 4);",
      "294:     crm_log_xml_info(login, \"Login: \");",
      "295:     if (login == NULL) {",
      "296:         goto bail;",
      "297:     }",
      "299:     tmp = crm_element_name(login);",
      "300:     if (safe_str_neq(tmp, \"cib_command\")) {",
      "301:         crm_err(\"Wrong tag: %s\", tmp);",
      "302:         goto bail;",
      "303:     }",
      "305:     tmp = crm_element_value(login, \"op\");",
      "306:     if (safe_str_neq(tmp, \"authenticate\")) {",
      "307:         crm_err(\"Wrong operation: %s\", tmp);",
      "308:         goto bail;",
      "309:     }",
      "311:     user = crm_element_value(login, \"user\");",
      "312:     pass = crm_element_value(login, \"password\");",
      "317:     if (check_group_membership(user, CRM_DAEMON_GROUP) == FALSE) {",
      "318:         crm_err(\"User is not a member of the required group\");",
      "319:         goto bail;",
      "321:     } else if (authenticate_user(user, pass) == FALSE) {",
      "322:         crm_err(\"PAM auth failed\");",
      "323:         goto bail;",
      "324:     }",
      "329:     new_client->name = crm_element_value_copy(login, \"name\");",
      "331:     CRM_CHECK(new_client->id == NULL, free(new_client->id));",
      "334: #if ENABLE_ACL",
      "335:     new_client->user = strdup(user);",
      "336: #endif",
      "",
      "[Added Lines]",
      "336:     new_client->remote_auth_timeout = g_timeout_add(REMOTE_AUTH_TIMEOUT, remote_auth_timeout_cb, new_client);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "345:         new_client->session = GINT_TO_POINTER(csock);",
      "346:     }",
      "355:     new_client->remote = mainloop_add_fd(",
      "356:         \"cib-remote-client\", G_PRIORITY_DEFAULT, csock, new_client, &remote_client_fd_callbacks);",
      "358:     g_hash_table_insert(client_list, new_client->id, new_client);",
      "360:     return TRUE;",
      "373: }",
      "375: void",
      "376: cib_remote_connection_destroy(gpointer user_data)",
      "377: {",
      "378:     cib_client_t *client = user_data;",
      "380:     if (client == NULL) {",
      "381:         return;",
      "",
      "[Removed Lines]",
      "348:     free_xml(login);",
      "349:     login = create_xml_node(NULL, \"cib_result\");",
      "350:     crm_xml_add(login, F_CIB_OPERATION, CRM_OP_REGISTER);",
      "351:     crm_xml_add(login, F_CIB_CLIENTID, new_client->id);",
      "352:     crm_send_remote_msg(new_client->session, login, new_client->encrypted);",
      "353:     free_xml(login);",
      "362:   bail:",
      "363:     if (ssock == remote_tls_fd) {",
      "364: #ifdef HAVE_GNUTLS_GNUTLS_H",
      "365:         gnutls_bye(*session, GNUTLS_SHUT_RDWR);",
      "366:         gnutls_deinit(*session);",
      "367:         gnutls_free(session);",
      "368: #endif",
      "369:     }",
      "370:     close(csock);",
      "371:     free_xml(login);",
      "372:     return TRUE;",
      "",
      "[Added Lines]",
      "359:     int csock = 0;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "393:     crm_trace(\"Destroying %s (%p)\", client->name, user_data);",
      "394:     num_clients--;",
      "395:     crm_trace(\"Num unfree'd clients: %d\", num_clients);",
      "396:     free(client->name);",
      "397:     free(client->callback_id);",
      "398:     free(client->id);",
      "399:     free(client->user);",
      "400:     free(client);",
      "401:     crm_trace(\"Freed the cib client\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "377:     if (client->remote_auth_timeout) {",
      "378:         g_source_remove(client->remote_auth_timeout);",
      "379:     }",
      "381:     if (client->encrypted) {",
      "382: #ifdef HAVE_GNUTLS_GNUTLS_H",
      "383:         if (client->session) {",
      "384:             void *sock_ptr = gnutls_transport_get_ptr(*client->session);",
      "385:             csock = GPOINTER_TO_INT(sock_ptr);",
      "386:             if (client->handshake_complete) {",
      "387:                 gnutls_bye(*client->session, GNUTLS_SHUT_WR);",
      "388:             }",
      "389:             gnutls_deinit(*client->session);",
      "390:             gnutls_free(client->session);",
      "391:         }",
      "392: #endif",
      "393:     } else {",
      "394:         csock = GPOINTER_TO_INT(client->session);",
      "395:     }",
      "396:     client->session = NULL;",
      "398:     if (csock > 0) {",
      "399:         close(csock);",
      "400:     }",
      "406:     free(client->recv_buf);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "406:     return;",
      "407: }",
      "411: {",
      "412:     const char *value = NULL;",
      "423:     value = crm_element_name(command);",
      "424:     if (safe_str_neq(value, \"cib_command\")) {",
      "425:         crm_log_xml_trace(command, \"Bad command: \");",
      "427:     }",
      "429:     if (client->name == NULL) {",
      "",
      "[Removed Lines]",
      "409: int",
      "410: cib_remote_msg(gpointer data)",
      "413:     xmlNode *command = NULL;",
      "414:     cib_client_t *client = data;",
      "416:     crm_trace(\"%s callback\", client->encrypted ? \"secure\" : \"clear-text\");",
      "418:     command = crm_recv_remote_msg(client->session, client->encrypted);",
      "419:     if (command == NULL) {",
      "420:         return -1;",
      "421:     }",
      "426:         goto bail;",
      "",
      "[Added Lines]",
      "416: static void",
      "417: cib_handle_remote_msg(cib_client_t *client, xmlNode *command)",
      "424:         return;",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "473:     crm_log_xml_trace(command, \"Remote command: \");",
      "474:     cib_common_callback_worker(0, 0, command, client, TRUE);",
      "478:     return 0;",
      "479: }",
      "",
      "[Removed Lines]",
      "475:   bail:",
      "476:     free_xml(command);",
      "477:     command = NULL;",
      "",
      "[Added Lines]",
      "473: }",
      "475: int",
      "476: cib_remote_msg(gpointer data)",
      "477: {",
      "478:     xmlNode *command = NULL;",
      "479:     cib_client_t *client = data;",
      "480:     int disconnected = 0;",
      "481:     int timeout = client->remote_auth ? -1 : 1000;",
      "483:     crm_trace(\"%s callback\", client->encrypted ? \"secure\" : \"clear-text\");",
      "485: #ifdef HAVE_GNUTLS_GNUTLS_H",
      "486:     if (client->encrypted && (client->handshake_complete == FALSE)) {",
      "487:         int rc = 0;",
      "491:         do {",
      "492:             rc = gnutls_handshake(*client->session);",
      "494:             if (rc < 0 && rc != GNUTLS_E_AGAIN) {",
      "495:                 crm_err(\"Remote cib tls handshake failed\");",
      "496:                 return -1;",
      "497:             }",
      "498:         } while (rc == GNUTLS_E_INTERRUPTED);",
      "500:         if (rc == 0) {",
      "501:             crm_debug(\"Remote cib tls handshake completed\");",
      "502:             client->handshake_complete = TRUE;",
      "503:             if (client->remote_auth_timeout) {",
      "504:                 g_source_remove(client->remote_auth_timeout);",
      "505:             }",
      "507:             client->remote_auth_timeout = g_timeout_add(REMOTE_AUTH_TIMEOUT, remote_auth_timeout_cb, client);",
      "508:         }",
      "509:         return 0;",
      "510:     }",
      "511: #endif",
      "513:     crm_recv_remote_msg(client->session, &client->recv_buf, client->encrypted, timeout, &disconnected);",
      "516:     if (client->remote_auth == FALSE) {",
      "517:         xmlNode *reg;",
      "518: #if ENABLE_ACL",
      "519:         const char *user = NULL;",
      "520: #endif",
      "521:         command = crm_parse_remote_buffer(&client->recv_buf);",
      "522:         if (cib_remote_auth(command) == FALSE) {",
      "523:             free_xml(command);",
      "524:             return -1;",
      "525:         }",
      "527:         crm_debug(\"remote connection authenticated successfully\");",
      "528:         client->remote_auth = TRUE;",
      "529:         g_source_remove(client->remote_auth_timeout);",
      "530:         client->remote_auth_timeout = 0;",
      "531:         client->name = crm_element_value_copy(command, \"name\");",
      "533: #if ENABLE_ACL",
      "534:         user = crm_element_value(command, \"user\");",
      "535:         if (user) {",
      "536:            new_client->user = strdup(user);",
      "537:         }",
      "538: #endif",
      "541:         reg = create_xml_node(NULL, \"cib_result\");",
      "542:         crm_xml_add(reg, F_CIB_OPERATION, CRM_OP_REGISTER);",
      "543:         crm_xml_add(reg, F_CIB_CLIENTID, client->id);",
      "544:         crm_send_remote_msg(client->session, reg, client->encrypted);",
      "545:         free_xml(reg);",
      "546:         free_xml(command);",
      "547:     }",
      "549:     command = crm_parse_remote_buffer(&client->recv_buf);",
      "550:     while (command) {",
      "551:         crm_trace(\"command received\");",
      "552:         cib_handle_remote_msg(client, command);",
      "553:         free_xml(command);",
      "554:         command = crm_parse_remote_buffer(&client->recv_buf);",
      "555:     }",
      "557:     if (disconnected) {",
      "558:         crm_trace(\"disconnected while receiving remote cib msg.\");",
      "559:         return -1;",
      "560:     }",
      "",
      "---------------"
    ],
    "include/crm_internal.h||include/crm_internal.h": [
      "File: include/crm_internal.h -> include/crm_internal.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "199: long long crm_int_helper(const char *text, char **end_text);",
      "200: char *crm_concat(const char *prefix, const char *suffix, char join);",
      "201: char *generate_hash_key(const char *crm_msg_reference, const char *sys);",
      "205: const char *daemon_option(const char *option);",
      "206: void set_daemon_option(const char *option, const char *value);",
      "",
      "[Removed Lines]",
      "202: xmlNode *crm_recv_remote_msg(void *session, gboolean encrypted);",
      "203: void crm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted);",
      "",
      "[Added Lines]",
      "205: gboolean crm_recv_remote_msg(void *session, char **recv_buf, gboolean encrypted, int total_timeout_ms, int *disconnected);",
      "206: char *crm_recv_remote_raw(void *data, gboolean encrypted, size_t max_recv, size_t *recv_len, int *disconnected);",
      "207: int crm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted);",
      "208: int crm_recv_remote_ready(void *session, gboolean encrypted, int timeout_ms);",
      "209: xmlNode *crm_parse_remote_buffer(char **msg_buf);",
      "210: int crm_remote_tcp_connect(const char *host, int port);",
      "212: #ifdef HAVE_GNUTLS_GNUTLS_H",
      "221: int crm_initiate_client_tls_handshake(void *session_data, int timeout_ms);",
      "232: void *crm_create_anon_tls_session(int sock, int type, void *credentials);",
      "233: #endif",
      "235: #define REMOTE_MSG_TERMINATOR \"\\r\\n\\r\\n\"",
      "",
      "---------------"
    ],
    "lib/cib/cib_remote.c||lib/cib/cib_remote.c": [
      "File: lib/cib/cib_remote.c -> lib/cib/cib_remote.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "38: #ifdef HAVE_GNUTLS_GNUTLS_H",
      "39: #  undef KEYFILE",
      "40: #  include <gnutls/gnutls.h>",
      "44: const int kx_prio[] = {",
      "45:     GNUTLS_KX_ANON_DH,",
      "46:     0",
      "47: };",
      "49: #else",
      "50: typedef void gnutls_session;",
      "51: #endif",
      "",
      "[Removed Lines]",
      "41: extern gnutls_anon_client_credentials anon_cred_c;",
      "42: extern gnutls_session *create_tls_session(int csock, int type);",
      "",
      "[Added Lines]",
      "41: gnutls_anon_client_credentials anon_cred_c;",
      "49: static gboolean remote_gnutls_credentials_init = FALSE;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "61:     gnutls_session *session;",
      "62:     mainloop_io_t *source;",
      "63:     char *token;",
      "64: };",
      "66: typedef struct cib_remote_opaque_s {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "65:     char *recv_buf;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "76: } cib_remote_opaque_t;",
      "78: void cib_remote_connection_destroy(gpointer user_data);",
      "80: int cib_remote_signon(cib_t * cib, const char *name, enum cib_conn_type type);",
      "81: int cib_remote_signoff(cib_t * cib);",
      "82: int cib_remote_free(cib_t * cib);",
      "",
      "[Removed Lines]",
      "79: int cib_remote_dispatch(gpointer user_data);",
      "",
      "[Added Lines]",
      "81: int cib_remote_callback_dispatch(gpointer user_data);",
      "82: int cib_remote_command_dispatch(gpointer user_data);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "158: {",
      "159:     cib_remote_opaque_t *private = cib->variant_opaque;",
      "166: #ifdef HAVE_GNUTLS_GNUTLS_H",
      "167:     if (private->command.encrypted) {",
      "178:     }",
      "179: #endif",
      "180:     return 0;",
      "181: }",
      "183: static int",
      "185: {",
      "186:     int sock;",
      "187:     cib_remote_opaque_t *private = cib->variant_opaque;",
      "189:     int rc = 0;",
      "196:     xmlNode *answer = NULL;",
      "197:     xmlNode *login = NULL;",
      "205:     connection->socket = 0;",
      "206:     connection->session = NULL;",
      "259:     }",
      "261:     if (connection->encrypted) {",
      "263: #ifdef HAVE_GNUTLS_GNUTLS_H",
      "272:             cib_tls_close(cib);",
      "273:             return -1;",
      "274:         }",
      "",
      "[Removed Lines]",
      "163:     close(private->command.socket);",
      "164:     close(private->callback.socket);",
      "168:         gnutls_bye(*(private->command.session), GNUTLS_SHUT_RDWR);",
      "169:         gnutls_deinit(*(private->command.session));",
      "170:         gnutls_free(private->command.session);",
      "172:         gnutls_bye(*(private->callback.session), GNUTLS_SHUT_RDWR);",
      "173:         gnutls_deinit(*(private->callback.session));",
      "174:         gnutls_free(private->callback.session);",
      "176:         gnutls_anon_free_client_credentials(anon_cred_c);",
      "177:         gnutls_global_deinit();",
      "184: cib_tls_signon(cib_t * cib, struct remote_connection_s *connection)",
      "188:     struct sockaddr_in addr;",
      "190:     char *server = private->server;",
      "192:     int ret_ga;",
      "193:     struct addrinfo *res;",
      "194:     struct addrinfo hints;",
      "199:     static struct mainloop_fd_callbacks cib_fd_callbacks =",
      "200:         {",
      "201:             .dispatch = cib_remote_dispatch,",
      "202:             .destroy = cib_remote_connection_destroy,",
      "203:         };",
      "209:     sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);",
      "210:     if (sock == -1) {",
      "211:         crm_perror(LOG_ERR, \"Socket creation failed\");",
      "212:         return -1;",
      "213:     }",
      "216:     bzero(&hints, sizeof(struct addrinfo));",
      "217:     hints.ai_flags = AI_CANONNAME;",
      "218:     hints.ai_family = AF_INET;",
      "219:     hints.ai_socktype = SOCK_RAW;",
      "221:     if (hints.ai_family == AF_INET6) {",
      "222:         hints.ai_protocol = IPPROTO_ICMPV6;",
      "223:     } else {",
      "224:         hints.ai_protocol = IPPROTO_ICMP;",
      "225:     }",
      "227:     crm_debug(\"Looking up %s\", server);",
      "228:     ret_ga = getaddrinfo(server, NULL, &hints, &res);",
      "229:     if (ret_ga) {",
      "230:         crm_err(\"getaddrinfo: %s\", gai_strerror(ret_ga));",
      "231:         close(sock);",
      "232:         return -1;",
      "233:     }",
      "235:     if (res->ai_canonname) {",
      "236:         server = res->ai_canonname;",
      "237:     }",
      "239:     crm_debug(\"Got address %s for %s\", server, private->server);",
      "241:     if (!res->ai_addr) {",
      "242:         fprintf(stderr, \"getaddrinfo failed\");",
      "243:         crm_exit(1);",
      "244:     }",
      "245: #if 1",
      "246:     memcpy(&addr, res->ai_addr, res->ai_addrlen);",
      "247: #else",
      "249:     memset(&addr, 0, sizeof(addr));",
      "250:     addr.sin_family = AF_INET;",
      "251:     addr.sin_addr.s_addr = inet_addr(server);",
      "252: #endif",
      "253:     addr.sin_port = htons(private->port);",
      "255:     if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {",
      "256:         crm_perror(LOG_ERR, \"Connection to %s:%d failed\", server, private->port);",
      "257:         close(sock);",
      "258:         return -1;",
      "264:         gnutls_global_init();",
      "265:         gnutls_anon_allocate_client_credentials(&anon_cred_c);",
      "268:         connection->session = create_tls_session(sock, GNUTLS_CLIENT);",
      "269:         if (connection->session == NULL) {",
      "270:             crm_perror(LOG_ERR, \"Session creation for %s:%d failed\", server, private->port);",
      "271:             close(sock);",
      "",
      "[Added Lines]",
      "166:         if (private->command.session) {",
      "167:             gnutls_bye(*(private->command.session), GNUTLS_SHUT_RDWR);",
      "168:             gnutls_deinit(*(private->command.session));",
      "169:             gnutls_free(private->command.session);",
      "170:         }",
      "172:         if (private->callback.session) {",
      "173:             gnutls_bye(*(private->callback.session), GNUTLS_SHUT_RDWR);",
      "174:             gnutls_deinit(*(private->callback.session));",
      "175:             gnutls_free(private->callback.session);",
      "176:         }",
      "177:         private->command.session = NULL;",
      "178:         private->callback.session = NULL;",
      "179:         if (remote_gnutls_credentials_init) {",
      "180:             gnutls_anon_free_client_credentials(anon_cred_c);",
      "181:             gnutls_global_deinit();",
      "182:             remote_gnutls_credentials_init = FALSE;",
      "183:         }",
      "187:     if (private->command.socket) {",
      "189:         close(private->command.socket);",
      "190:     }",
      "191:     if (private->callback.socket) {",
      "193:         close(private->callback.socket);",
      "194:     }",
      "195:     private->command.socket = 0;",
      "196:     private->callback.socket = 0;",
      "198:     free(private->command.recv_buf);",
      "199:     free(private->callback.recv_buf);",
      "200:     private->command.recv_buf = NULL;",
      "201:     private->callback.recv_buf = NULL;",
      "207: cib_tls_signon(cib_t * cib, struct remote_connection_s *connection, gboolean event_channel)",
      "212:     int disconnected = 0;",
      "217:     static struct mainloop_fd_callbacks cib_fd_callbacks = { 0, };",
      "219:     cib_fd_callbacks.dispatch = event_channel ? cib_remote_callback_dispatch : cib_remote_command_dispatch;",
      "220:     cib_fd_callbacks.destroy = cib_remote_connection_destroy;",
      "225:     sock = crm_remote_tcp_connect(private->server, private->port);",
      "226:     if (sock <= 0) {",
      "227:         crm_perror(LOG_ERR, \"remote tcp connection to %s:%d failed\", private->server, private->port);",
      "230:     connection->socket = sock;",
      "234:         if (remote_gnutls_credentials_init == FALSE) {",
      "235:             gnutls_global_init();",
      "236:             gnutls_anon_allocate_client_credentials(&anon_cred_c);",
      "237:             remote_gnutls_credentials_init = TRUE;",
      "238:         }",
      "241:         connection->session = crm_create_anon_tls_session(sock, GNUTLS_CLIENT, anon_cred_c);",
      "243:         if (crm_initiate_client_tls_handshake(connection->session, DEFAULT_CLIENT_HANDSHAKE_TIMEOUT) != 0) {",
      "244:             crm_err(\"Session creation for %s:%d failed\", private->server, private->port);",
      "246:             gnutls_deinit(*connection->session);",
      "247:             gnutls_free(connection->session);",
      "248:             connection->session = NULL;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "289:     crm_send_remote_msg(connection->session, login, connection->encrypted);",
      "290:     free_xml(login);",
      "293:     crm_log_xml_trace(answer, \"Reply\");",
      "294:     if (answer == NULL) {",
      "295:         rc = -EPROTO;",
      "",
      "[Removed Lines]",
      "292:     answer = crm_recv_remote_msg(connection->session, connection->encrypted);",
      "",
      "[Added Lines]",
      "269:     crm_recv_remote_msg(connection->session, &connection->recv_buf, connection->encrypted, -1, &disconnected);",
      "271:     if (disconnected) {",
      "272:         rc = -ENOTCONN;",
      "273:     }",
      "275:     answer = crm_parse_remote_buffer(&connection->recv_buf);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "310:             connection->token = strdup(tmp_ticket);",
      "311:         }",
      "312:     }",
      "314:     if (rc != 0) {",
      "315:         cib_tls_close(cib);",
      "316:     }",
      "319:     connection->source = mainloop_add_fd(\"cib-remote\", G_PRIORITY_HIGH, connection->socket, cib, &cib_fd_callbacks);",
      "320:     return rc;",
      "321: }",
      "",
      "[Removed Lines]",
      "318:     connection->socket = sock;",
      "",
      "[Added Lines]",
      "297:     free_xml(answer);",
      "298:     answer = NULL;",
      "302:         return rc;",
      "305:     crm_trace(\"remote client connection established\");",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "331: }",
      "333: int",
      "335: {",
      "336:     cib_t *cib = user_data;",
      "337:     cib_remote_opaque_t *private = cib->variant_opaque;",
      "339:     xmlNode *msg = NULL;",
      "342:     crm_info(\"Message on callback channel\");",
      "359:         free_xml(msg);",
      "361:     }",
      "363: }",
      "365: int",
      "",
      "[Removed Lines]",
      "334: cib_remote_dispatch(gpointer user_data)",
      "340:     const char *type = NULL;",
      "343:     msg = crm_recv_remote_msg(private->callback.session, private->callback.encrypted);",
      "345:     type = crm_element_value(msg, F_TYPE);",
      "346:     crm_trace(\"Activating %s callbacks...\", type);",
      "348:     if (safe_str_eq(type, T_CIB)) {",
      "349:         cib_native_callback(cib, msg, 0, 0);",
      "351:     } else if (safe_str_eq(type, T_CIB_NOTIFY)) {",
      "352:         g_list_foreach(cib->notify_list, cib_native_notify, msg);",
      "354:     } else {",
      "355:         crm_err(\"Unknown message type: %s\", type);",
      "356:     }",
      "358:     if (msg != NULL) {",
      "360:         return 0;",
      "362:     return -1;",
      "",
      "[Added Lines]",
      "321: cib_remote_command_dispatch(gpointer user_data)",
      "322: {",
      "323:     int disconnected = 0;",
      "324:     cib_t *cib = user_data;",
      "325:     cib_remote_opaque_t *private = cib->variant_opaque;",
      "327:     crm_recv_remote_msg(private->command.session, &private->command.recv_buf, private->command.encrypted, -1, &disconnected);",
      "329:     free(private->command.recv_buf);",
      "330:     private->command.recv_buf = NULL;",
      "331:     crm_err(\"received late reply for remote cib connection, discarding\");",
      "333:     if (disconnected) {",
      "334:         return -1;",
      "335:     }",
      "336:     return 0;",
      "337: }",
      "339: int",
      "340: cib_remote_callback_dispatch(gpointer user_data)",
      "346:     int disconnected = 0;",
      "350:     crm_recv_remote_msg(private->callback.session, &private->callback.recv_buf, private->callback.encrypted, -1, &disconnected);",
      "352:     msg = crm_parse_remote_buffer(&private->callback.recv_buf);",
      "353:     while (msg) {",
      "354:         const char *type = crm_element_value(msg, F_TYPE);",
      "355:         crm_trace(\"Activating %s callbacks...\", type);",
      "357:         if (safe_str_eq(type, T_CIB)) {",
      "358:             cib_native_callback(cib, msg, 0, 0);",
      "360:         } else if (safe_str_eq(type, T_CIB_NOTIFY)) {",
      "361:             g_list_foreach(cib->notify_list, cib_native_notify, msg);",
      "363:         } else {",
      "364:             crm_err(\"Unknown message type: %s\", type);",
      "365:         }",
      "368:         msg = crm_parse_remote_buffer(&private->callback.recv_buf);",
      "369:     }",
      "371:     if (disconnected) {",
      "372:         return -1;",
      "375:     return 0;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "394:     }",
      "396:     if (rc == pcmk_ok) {",
      "398:     }",
      "400:     if (rc == pcmk_ok) {",
      "402:     }",
      "404:     if (rc == pcmk_ok) {",
      "",
      "[Removed Lines]",
      "397:         rc = cib_tls_signon(cib, &(private->command));",
      "401:         rc = cib_tls_signon(cib, &(private->callback));",
      "",
      "[Added Lines]",
      "410:         rc = cib_tls_signon(cib, &(private->command), FALSE);",
      "414:         rc = cib_tls_signon(cib, &(private->callback), TRUE);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "463:     return rc;",
      "464: }",
      "482: int",
      "483: cib_remote_perform_op(cib_t * cib, const char *op, const char *host, const char *section,",
      "484:                       xmlNode * data, xmlNode ** output_data, int call_options, const char *name)",
      "485: {",
      "486:     int rc = pcmk_ok;",
      "488:     xmlNode *op_msg = NULL;",
      "489:     xmlNode *op_reply = NULL;",
      "491:     cib_remote_opaque_t *private = cib->variant_opaque;",
      "497:     if (cib->state == cib_disconnected) {",
      "498:         return -ENOTCONN;",
      "499:     }",
      "",
      "[Removed Lines]",
      "466: static gboolean timer_expired = FALSE;",
      "467: static struct timer_rec_s *sync_timer = NULL;",
      "468: static gboolean",
      "469: cib_timeout_handler(gpointer data)",
      "470: {",
      "471:     struct timer_rec_s *timer = data;",
      "473:     timer_expired = TRUE;",
      "474:     crm_err(\"Call %d timed out after %ds\", timer->call_id, timer->timeout);",
      "479:     return TRUE;",
      "480: }",
      "493:     if (sync_timer == NULL) {",
      "494:         sync_timer = calloc(1, sizeof(struct timer_rec_s));",
      "495:     }",
      "",
      "[Added Lines]",
      "484:     int disconnected = 0;",
      "485:     int remaining_time = 0;",
      "486:     time_t start_time;",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "524:     }",
      "526:     crm_trace(\"Sending %s message to CIB service\", op);",
      "528:     free_xml(op_msg);",
      "530:     if ((call_options & cib_discard_reply)) {",
      "",
      "[Removed Lines]",
      "527:     crm_send_remote_msg(private->command.session, op_msg, private->command.encrypted);",
      "",
      "[Added Lines]",
      "523:     if (!(call_options & cib_sync_call)) {",
      "524:         crm_send_remote_msg(private->callback.session, op_msg, private->command.encrypted);",
      "525:     } else {",
      "526:         crm_send_remote_msg(private->command.session, op_msg, private->command.encrypted);",
      "527:     }",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "538:     crm_trace(\"Waiting for a syncronous reply\");",
      "551:         int reply_id = -1;",
      "552:         int msg_id = cib->call_id;",
      "556:             break;",
      "557:         }",
      "559:         crm_element_value_int(op_reply, F_CIB_CALLID, &reply_id);",
      "565:         if (reply_id == msg_id) {",
      "566:             break;",
      "",
      "[Removed Lines]",
      "540:     if (cib->call_timeout > 0) {",
      "544:         timer_expired = FALSE;",
      "545:         sync_timer->call_id = cib->call_id;",
      "546:         sync_timer->timeout = cib->call_timeout * 1000;",
      "547:         sync_timer->ref = g_timeout_add(sync_timer->timeout, cib_timeout_handler, sync_timer);",
      "548:     }",
      "550:     while (timer_expired == FALSE) {",
      "554:         op_reply = crm_recv_remote_msg(private->command.session, private->command.encrypted);",
      "555:         if (op_reply == NULL) {",
      "560:         CRM_CHECK(reply_id > 0, free_xml(op_reply);",
      "561:                   if (sync_timer->ref > 0) {",
      "562:                   g_source_remove(sync_timer->ref); sync_timer->ref = 0;}",
      "563:                   return -ENOMSG) ;",
      "",
      "[Added Lines]",
      "540:     start_time = time(NULL);",
      "541:     remaining_time = cib->call_timeout ? cib->call_timeout : 60;",
      "543:     while (remaining_time > 0 && !disconnected) {",
      "547:         crm_recv_remote_msg(private->command.session, &private->command.recv_buf, private->command.encrypted, remaining_time * 1000, &disconnected);",
      "548:         op_reply = crm_parse_remote_buffer(&private->command.recv_buf);",
      "550:         if (!op_reply) {",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "580:         free_xml(op_reply);",
      "581:         op_reply = NULL;",
      "591:     }",
      "",
      "[Removed Lines]",
      "582:     }",
      "584:     if (sync_timer->ref > 0) {",
      "585:         g_source_remove(sync_timer->ref);",
      "586:         sync_timer->ref = 0;",
      "587:     }",
      "589:     if (timer_expired) {",
      "590:         return -ETIME;",
      "",
      "[Added Lines]",
      "575:         remaining_time = time(NULL) - start_time;",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "600:         crm_err(\"No reply message - empty\");",
      "601:         return -ENOMSG;",
      "602:     }",
      "",
      "[Removed Lines]",
      "599:     if (op_reply == NULL) {",
      "",
      "[Added Lines]",
      "584:     if (disconnected) {",
      "585:         crm_err(\"Disconnected while waiting for reply.\");",
      "586:         return -ENOTCONN;",
      "587:     } else if (op_reply == NULL) {",
      "",
      "---------------"
    ],
    "lib/common/mainloop.c||lib/common/mainloop.c": [
      "File: lib/common/mainloop.c -> lib/common/mainloop.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "178:     source->trigger = FALSE;",
      "179:     if (source->id > 0) {",
      "180:         g_source_remove(source->id);",
      "181:     }",
      "182:     return TRUE;",
      "183: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "181:         source->id = 0;",
      "",
      "---------------"
    ],
    "lib/common/remote.c||lib/common/remote.c": [
      "File: lib/common/remote.c -> lib/common/remote.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "25: #include <sys/stat.h>",
      "26: #include <unistd.h>",
      "27: #include <sys/socket.h>",
      "29: #include <netinet/ip.h>",
      "31: #include <stdlib.h>",
      "32: #include <errno.h>",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "28: #include <arpa/inet.h>",
      "30: #include <netdb.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "42: #endif",
      "44: #ifdef HAVE_GNUTLS_GNUTLS_H",
      "46:     GNUTLS_KX_ANON_DH,",
      "47:     GNUTLS_KX_DHE_RSA,",
      "48:     GNUTLS_KX_DHE_DSS,",
      "",
      "[Removed Lines]",
      "45: const int tls_kx_order[] = {",
      "",
      "[Added Lines]",
      "47: const int anon_tls_kx_order[] = {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "50:     0",
      "51: };",
      "67: {",
      "69:     gnutls_session *session = gnutls_malloc(sizeof(gnutls_session));",
      "71:     gnutls_init(session, type);",
      "",
      "[Removed Lines]",
      "53: gnutls_anon_client_credentials anon_cred_c;",
      "54: gnutls_anon_server_credentials anon_cred_s;",
      "55: static char *cib_send_tls(gnutls_session * session, xmlNode * msg);",
      "56: static char *cib_recv_tls(gnutls_session * session);",
      "57: #endif",
      "59: char *cib_recv_plaintext(int sock);",
      "60: char *cib_send_plaintext(int sock, xmlNode * msg);",
      "62: #ifdef HAVE_GNUTLS_GNUTLS_H",
      "63: gnutls_session *create_tls_session(int csock, int type);",
      "65: gnutls_session *",
      "66: create_tls_session(int csock, int type /* GNUTLS_SERVER, GNUTLS_CLIENT */ )",
      "68:     int rc = 0;",
      "",
      "[Added Lines]",
      "55: int",
      "56: crm_initiate_client_tls_handshake(void *session_data, int timeout_ms)",
      "57: {",
      "58:     int rc = 0;",
      "59:     int pollrc = 0;",
      "60:     time_t start = time(NULL);",
      "61:     gnutls_session *session = session_data;",
      "63:     do {",
      "64:         rc = gnutls_handshake(*session);",
      "65:         if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {",
      "66:             pollrc = crm_recv_remote_ready(session, TRUE, 1000);",
      "67:             if (pollrc < 0) {",
      "69:                 rc = -1;",
      "70:             }",
      "71:         }",
      "72:     } while (((time(NULL) - start) < (timeout_ms/1000)) &&",
      "73:             (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN));",
      "75:     return rc;",
      "76: }",
      "78: void *",
      "79: crm_create_anon_tls_session(int csock, int type /* GNUTLS_SERVER, GNUTLS_CLIENT */, void *credentials)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "76: #  else",
      "77:     gnutls_set_default_priority(*session);",
      "79: #  endif",
      "80:     gnutls_transport_set_ptr(*session, (gnutls_transport_ptr) GINT_TO_POINTER(csock));",
      "81:     switch (type) {",
      "88:     }",
      "100:     return session;",
      "101: }",
      "105: {",
      "113:     }",
      "142:         }",
      "144:     }",
      "148: }",
      "150: static char *",
      "152: {",
      "153:     char *buf = NULL;",
      "155:     int rc = 0;",
      "159:     if (session == NULL) {",
      "161:     }",
      "165:     while (TRUE) {",
      "182:             len += rc;",
      "198:         }",
      "199:     }",
      "204: }",
      "205: #endif",
      "209: {",
      "236:             goto retry;",
      "240:         }",
      "241:     }",
      "245: }",
      "249: {",
      "250:     char *buf = NULL;",
      "252:     ssize_t rc = 0;",
      "253:     ssize_t len = 0;",
      "280:             CRM_ASSERT(buf != NULL);",
      "285:             len += rc;",
      "291:         }",
      "292:     }",
      "297: }",
      "301: {",
      "302:     if (encrypted) {",
      "303: #ifdef HAVE_GNUTLS_GNUTLS_H",
      "305: #else",
      "306:         CRM_ASSERT(encrypted == FALSE);",
      "307: #endif",
      "308:     } else {",
      "310:     }",
      "311: }",
      "313: xmlNode *",
      "315: {",
      "317:     xmlNode *xml = NULL;",
      "319:     if (encrypted) {",
      "320: #ifdef HAVE_GNUTLS_GNUTLS_H",
      "322: #else",
      "323:         CRM_ASSERT(encrypted == FALSE);",
      "324: #endif",
      "325:     } else {",
      "327:     }",
      "328:     if (reply == NULL || strlen(reply) == 0) {",
      "329:         crm_trace(\"Empty reply\");",
      "335:         }",
      "336:     }",
      "340: }",
      "",
      "[Removed Lines]",
      "78:     gnutls_kx_set_priority(*session, tls_kx_order);",
      "82:         case GNUTLS_SERVER:",
      "83:             gnutls_credentials_set(*session, GNUTLS_CRD_ANON, anon_cred_s);",
      "84:             break;",
      "85:         case GNUTLS_CLIENT:",
      "86:             gnutls_credentials_set(*session, GNUTLS_CRD_ANON, anon_cred_c);",
      "87:             break;",
      "90:     do {",
      "91:         rc = gnutls_handshake(*session);",
      "92:     } while (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN);",
      "94:     if (rc < 0) {",
      "95:         crm_err(\"Handshake failed: %s\", gnutls_strerror(rc));",
      "96:         gnutls_deinit(*session);",
      "97:         gnutls_free(session);",
      "98:         return NULL;",
      "99:     }",
      "103: static char *",
      "104: cib_send_tls(gnutls_session * session, xmlNode * msg)",
      "106:     char *xml_text = NULL;",
      "108: #  if 0",
      "109:     const char *name = crm_element_name(msg);",
      "111:     if (safe_str_neq(name, \"cib_command\")) {",
      "112:         xmlNodeSetName(msg, \"cib_result\");",
      "114: #  endif",
      "115:     xml_text = dump_xml_unformatted(msg);",
      "116:     if (xml_text != NULL) {",
      "117:         char *unsent = xml_text;",
      "118:         int len = strlen(xml_text);",
      "119:         int rc = 0;",
      "122:         crm_trace(\"Message size: %d\", len);",
      "124:         while (TRUE) {",
      "125:             rc = gnutls_record_send(*session, unsent, len);",
      "126:             crm_debug(\"Sent %d bytes\", rc);",
      "128:             if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {",
      "129:                 crm_debug(\"Retry\");",
      "131:             } else if (rc < 0) {",
      "132:                 crm_debug(\"Connection terminated\");",
      "133:                 break;",
      "135:             } else if (rc < len) {",
      "136:                 crm_debug(\"Only sent %d of %d bytes\", rc, len);",
      "137:                 len -= rc;",
      "138:                 unsent += rc;",
      "139:             } else {",
      "140:                 break;",
      "141:             }",
      "145:     free(xml_text);",
      "146:     return NULL;",
      "151: cib_recv_tls(gnutls_session * session)",
      "156:     int len = 0;",
      "157:     int chunk_size = 1024;",
      "160:         return NULL;",
      "163:     buf = calloc(1, chunk_size);",
      "166:         errno = 0;",
      "167:         rc = gnutls_record_recv(*session, buf + len, chunk_size);",
      "168:         crm_trace(\"Got %d more bytes. errno=%d\", rc, errno);",
      "170:         if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {",
      "171:             crm_trace(\"Retry\");",
      "173:         } else if (rc == GNUTLS_E_UNEXPECTED_PACKET_LENGTH) {",
      "174:             crm_trace(\"Session disconnected\");",
      "175:             goto bail;",
      "177:         } else if (rc < 0) {",
      "178:             crm_err(\"Error receiving message: %s (%d)\", gnutls_strerror(rc), rc);",
      "179:             goto bail;",
      "181:         } else if (rc == chunk_size) {",
      "183:             chunk_size *= 2;",
      "184:             buf = realloc(buf, len + chunk_size);",
      "185:             crm_trace(\"Retry with %d more bytes\", (int)chunk_size);",
      "186:             CRM_ASSERT(buf != NULL);",
      "188:         } else if (buf[len + rc - 1] != 0) {",
      "189:             crm_trace(\"Last char is %d '%c'\", buf[len + rc - 1], buf[len + rc - 1]);",
      "190:             crm_trace(\"Retry with %d more bytes\", (int)chunk_size);",
      "191:             len += rc;",
      "192:             buf = realloc(buf, len + chunk_size);",
      "193:             CRM_ASSERT(buf != NULL);",
      "195:         } else {",
      "196:             crm_trace(\"Got %d more bytes\", (int)rc);",
      "197:             return buf;",
      "200:   bail:",
      "201:     free(buf);",
      "202:     return NULL;",
      "207: char *",
      "208: cib_send_plaintext(int sock, xmlNode * msg)",
      "210:     char *xml_text = dump_xml_unformatted(msg);",
      "212:     if (xml_text != NULL) {",
      "213:         int rc = 0;",
      "214:         char *unsent = xml_text;",
      "215:         int len = strlen(xml_text);",
      "218:         crm_trace(\"Message on socket %d: size=%d\", sock, len);",
      "219:   retry:",
      "220:         rc = write(sock, unsent, len);",
      "221:         if (rc < 0) {",
      "222:             switch (errno) {",
      "223:                 case EINTR:",
      "224:                 case EAGAIN:",
      "225:                     crm_trace(\"Retry\");",
      "226:                     goto retry;",
      "227:                 default:",
      "228:                     crm_perror(LOG_ERR, \"Could only write %d of the remaining %d bytes\", rc, len);",
      "229:                     break;",
      "230:             }",
      "232:         } else if (rc < len) {",
      "233:             crm_trace(\"Only sent %d of %d remaining bytes\", rc, len);",
      "234:             len -= rc;",
      "235:             unsent += rc;",
      "238:         } else {",
      "239:             crm_trace(\"Sent %d bytes: %.100s\", rc, xml_text);",
      "242:     free(xml_text);",
      "243:     return NULL;",
      "247: char *",
      "248: cib_recv_plaintext(int sock)",
      "254:     ssize_t chunk_size = 512;",
      "256:     buf = calloc(1, chunk_size);",
      "258:     while (1) {",
      "259:         errno = 0;",
      "260:         rc = read(sock, buf + len, chunk_size);",
      "261:         crm_trace(\"Got %d more bytes. errno=%d\", (int)rc, errno);",
      "263:         if (errno == EINTR || errno == EAGAIN) {",
      "264:             crm_trace(\"Retry: %d\", (int)rc);",
      "265:             if (rc > 0) {",
      "266:                 len += rc;",
      "267:                 buf = realloc(buf, len + chunk_size);",
      "268:                 CRM_ASSERT(buf != NULL);",
      "269:             }",
      "271:         } else if (rc < 0) {",
      "272:             crm_perror(LOG_ERR, \"Error receiving message: %d\", (int)rc);",
      "273:             goto bail;",
      "275:         } else if (rc == chunk_size) {",
      "276:             len += rc;",
      "277:             chunk_size *= 2;",
      "278:             buf = realloc(buf, len + chunk_size);",
      "279:             crm_trace(\"Retry with %d more bytes\", (int)chunk_size);",
      "282:         } else if (buf[len + rc - 1] != 0) {",
      "283:             crm_trace(\"Last char is %d '%c'\", buf[len + rc - 1], buf[len + rc - 1]);",
      "284:             crm_trace(\"Retry with %d more bytes\", (int)chunk_size);",
      "286:             buf = realloc(buf, len + chunk_size);",
      "287:             CRM_ASSERT(buf != NULL);",
      "289:         } else {",
      "290:             return buf;",
      "293:   bail:",
      "294:     free(buf);",
      "295:     return NULL;",
      "299: void",
      "300: crm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted)",
      "304:         cib_send_tls(session, msg);",
      "309:         cib_send_plaintext(GPOINTER_TO_INT(session), msg);",
      "314: crm_recv_remote_msg(void *session, gboolean encrypted)",
      "316:     char *reply = NULL;",
      "321:         reply = cib_recv_tls(session);",
      "326:         reply = cib_recv_plaintext(GPOINTER_TO_INT(session));",
      "331:     } else {",
      "332:         xml = string2xml(reply);",
      "333:         if (xml == NULL) {",
      "334:             crm_err(\"Couldn't parse: '%.120s'\", reply);",
      "338:     free(reply);",
      "339:     return xml;",
      "",
      "[Added Lines]",
      "90:     gnutls_kx_set_priority(*session, anon_tls_kx_order);",
      "94:     case GNUTLS_SERVER:",
      "95:         gnutls_credentials_set(*session, GNUTLS_CRD_ANON, (gnutls_anon_server_credentials_t) credentials);",
      "96:         break;",
      "97:     case GNUTLS_CLIENT:",
      "98:         gnutls_credentials_set(*session, GNUTLS_CRD_ANON, (gnutls_anon_client_credentials_t) credentials);",
      "99:         break;",
      "105: static int",
      "106: crm_send_tls(gnutls_session * session, const char *buf, size_t len)",
      "108:     const char *unsent = buf;",
      "109:     int rc = 0;",
      "110:     int total_send;",
      "112:     if (buf == NULL) {",
      "113:         return -1;",
      "116:     total_send = len;",
      "117:     crm_trace(\"Message size: %d\", len);",
      "119:     while (TRUE) {",
      "120:         rc = gnutls_record_send(*session, unsent, len);",
      "122:         if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {",
      "123:             crm_debug(\"Retry\");",
      "125:         } else if (rc < 0) {",
      "126:             crm_err(\"Connection terminated rc = %d\", rc);",
      "127:             break;",
      "129:         } else if (rc < len) {",
      "130:             crm_debug(\"Only sent %d of %d bytes\", rc, len);",
      "131:             len -= rc;",
      "132:             unsent += rc;",
      "133:         } else {",
      "134:             crm_debug(\"Sent %d bytes\", rc);",
      "135:             break;",
      "139:     return rc < 0 ? rc : total_send;",
      "157: crm_recv_tls(gnutls_session * session, size_t max_size, size_t *recv_len, int *disconnected)",
      "161:     size_t len = 0;",
      "162:     size_t chunk_size = max_size ? max_size : 1024;",
      "163:     size_t buf_size = 0;",
      "164:     size_t read_size = 0;",
      "167:         if (disconnected) {",
      "169:         }",
      "170:         goto done;",
      "173:     buf = calloc(1, chunk_size + 1);",
      "174:     buf_size = chunk_size;",
      "177:         read_size = buf_size - len;",
      "180:         if (!max_size && (read_size < (chunk_size / 2))) {",
      "181:             buf_size += chunk_size;",
      "182:             crm_trace(\"Grow buffer by %d more bytes. buf is now %d bytes\", (int)chunk_size, buf_size);",
      "183:             buf = realloc(buf, buf_size + 1);",
      "184:             CRM_ASSERT(buf != NULL);",
      "186:             read_size = buf_size - len;",
      "187:         }",
      "189:         rc = gnutls_record_recv(*session, buf + len, read_size);",
      "191:         if (rc > 0) {",
      "192:             crm_trace(\"Got %d more bytes.\", rc);",
      "195:             buf[len] = '\\0';",
      "196:         }",
      "197:         if (max_size && (max_size == read_size)) {",
      "198:             crm_trace(\"Buffer max read size %d met\" , max_size);",
      "199:             goto done;",
      "200:         }",
      "203:         if (rc == GNUTLS_E_INTERRUPTED) {",
      "204:             crm_trace(\"EINTR encoutered, retry tls read\");",
      "205:         } else if (rc == GNUTLS_E_AGAIN) {",
      "206:             crm_trace(\"non-blocking, exiting read on rc = %d\", rc);",
      "207:             goto done;",
      "208:         } else if (rc <= 0) {",
      "209:             if (rc == 0) {",
      "210:                 crm_debug(\"EOF encoutered during TLS read\");",
      "211:             } else {",
      "212:                 crm_debug(\"Error receiving message: %s (%d)\", gnutls_strerror(rc), rc);",
      "213:             }",
      "214:             if (disconnected) {",
      "216:             }",
      "217:             goto done;",
      "221: done:",
      "222:     if (recv_len) {",
      "224:     }",
      "225:     if (!len) {",
      "226:         free(buf);",
      "227:         buf = NULL;",
      "228:     }",
      "229:     return buf;",
      "234: static int",
      "235: crm_send_plaintext(int sock, const char *buf, size_t len)",
      "238:     int rc = 0;",
      "239:     const char *unsent = buf;",
      "240:     int total_send;",
      "242:     if (buf == NULL) {",
      "243:         return -1;",
      "244:     }",
      "245:     total_send = len;",
      "247:     crm_trace(\"Message on socket %d: size=%d\", sock, len);",
      "248:   retry:",
      "249:     rc = write(sock, unsent, len);",
      "250:     if (rc < 0) {",
      "251:         switch (errno) {",
      "252:         case EINTR:",
      "253:         case EAGAIN:",
      "254:             crm_trace(\"Retry\");",
      "256:         default:",
      "257:             crm_perror(LOG_ERR, \"Could only write %d of the remaining %d bytes\", rc, (int) len);",
      "258:             break;",
      "261:     } else if (rc < len) {",
      "262:         crm_trace(\"Only sent %d of %d remaining bytes\", rc, len);",
      "263:         len -= rc;",
      "264:         unsent += rc;",
      "265:         goto retry;",
      "267:      } else {",
      "268:         crm_trace(\"Sent %d bytes: %.100s\", rc, buf);",
      "271:     return rc < 0 ? rc : total_send;",
      "288: static char *",
      "289: crm_recv_plaintext(int sock, size_t max_size, size_t *recv_len, int *disconnected)",
      "294:     ssize_t chunk_size = max_size ? max_size : 1024;",
      "295:     size_t buf_size = 0;",
      "296:     size_t read_size = 0;",
      "298:     if (sock <= 0) {",
      "299:         if (disconnected) {",
      "301:         }",
      "302:         goto done;",
      "303:     }",
      "305:     buf = calloc(1, chunk_size + 1);",
      "306:     buf_size = chunk_size;",
      "308:     while (TRUE) {",
      "309:         errno = 0;",
      "310:         read_size = buf_size - len;",
      "313:         if (!max_size && (read_size < (chunk_size / 2))) {",
      "314:             buf_size += chunk_size;",
      "315:             crm_trace(\"Grow buffer by %d more bytes. buf is now %d bytes\", (int)chunk_size, buf_size);",
      "316:             buf = realloc(buf, buf_size + 1);",
      "319:             read_size = buf_size - len;",
      "320:         }",
      "322:         rc = read(sock, buf + len, chunk_size);",
      "324:         if (rc > 0) {",
      "325:             crm_trace(\"Got %d more bytes. errno=%d\", (int)rc, errno);",
      "328:             buf[len] = '\\0';",
      "329:         }",
      "330:         if (max_size && (max_size == read_size)) {",
      "331:             crm_trace(\"Buffer max read size %d met\" , max_size);",
      "332:             goto done;",
      "333:         }",
      "335:         if (rc > 0) {",
      "336:             continue;",
      "337:         } else if (rc == 0) {",
      "338:             if (disconnected) {",
      "340:             }",
      "341:             crm_trace(\"EOF encoutered during read\");",
      "342:             goto done;",
      "343:         }",
      "346:         if (errno == EINTR) {",
      "347:             crm_trace(\"EINTER encoutered, retry socket read.\");",
      "348:         } else if (errno == EAGAIN) {",
      "349:             crm_trace(\"non-blocking, exiting read on rc = %d\", rc);",
      "350:             goto done;",
      "351:         } else if (errno <= 0) {",
      "352:             if (disconnected) {",
      "354:             }",
      "355:             crm_debug(\"Error receiving message: %d\", (int)rc);",
      "356:             goto done;",
      "360: done:",
      "361:     if (recv_len) {",
      "363:     }",
      "364:     if (!len) {",
      "365:         free(buf);",
      "366:         buf = NULL;",
      "367:     }",
      "368:     return buf;",
      "371: static int",
      "372: crm_send_remote_msg_raw(void *session, const char *buf, size_t len, gboolean encrypted)",
      "374:     int rc = -1;",
      "377:         rc = crm_send_tls(session, buf, len);",
      "382:         rc = crm_send_plaintext(GPOINTER_TO_INT(session), buf, len);",
      "384:     return rc;",
      "387: int",
      "388: crm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted)",
      "389: {",
      "390:     int rc = -1;",
      "391:     char *xml_text = NULL;",
      "392:     int len = 0;",
      "394:     xml_text = dump_xml_unformatted(msg);",
      "395:     if (xml_text) {",
      "396:         len = strlen(xml_text);",
      "397:     } else {",
      "398:         crm_err(\"Invalid XML, can not send msg\");",
      "399:         return -1;",
      "400:     }",
      "402:     rc = crm_send_remote_msg_raw(session, xml_text, len, encrypted);",
      "403:     if (rc < 0) {",
      "404:         goto done;",
      "405:     }",
      "406:     rc = crm_send_remote_msg_raw(session, REMOTE_MSG_TERMINATOR, strlen(REMOTE_MSG_TERMINATOR), encrypted);",
      "408: done:",
      "409:     if (rc < 0) {",
      "410:         crm_err(\"Failed to send remote msg, rc = %d\", rc);",
      "411:     }",
      "413:     free(xml_text);",
      "414:     return rc;",
      "415: }",
      "423: crm_parse_remote_buffer(char **msg_buf)",
      "425:     char *buf = NULL;",
      "426:     char *start = NULL;",
      "427:     char *end = NULL;",
      "430:     if (*msg_buf == NULL) {",
      "431:         return NULL;",
      "432:     }",
      "435:     buf = *msg_buf;",
      "439:     start = buf;",
      "440:     end = strstr(start, REMOTE_MSG_TERMINATOR);",
      "442:     while (!xml && end) {",
      "445:         end[0] = '\\0';",
      "446:         end += strlen(REMOTE_MSG_TERMINATOR);",
      "448:         xml = string2xml(start);",
      "449:         if (xml == NULL) {",
      "450:             crm_err(\"Couldn't parse: '%.120s'\", start);",
      "451:         }",
      "452:         start = end;",
      "453:         end = strstr(start, REMOTE_MSG_TERMINATOR);",
      "454:     }",
      "456:     if (xml && start) {",
      "459:         free(buf);",
      "460:     } else if (!xml) {",
      "463:     }",
      "465:     return xml;",
      "466: }",
      "476: int",
      "477: crm_recv_remote_ready(void *session, gboolean encrypted, int timeout /* ms */)",
      "478: {",
      "479:     struct pollfd fds = { 0, };",
      "480:     int sock = 0;",
      "481:     void *sock_ptr = NULL;",
      "482:     int rc = 0;",
      "483:     time_t start;",
      "485:     if (encrypted) {",
      "486: #ifdef HAVE_GNUTLS_GNUTLS_H",
      "487:         gnutls_session *tls_session = session;",
      "488:         sock_ptr = gnutls_transport_get_ptr(*tls_session);",
      "489: #else",
      "490:         CRM_ASSERT(encrypted == FALSE);",
      "491: #endif",
      "492:     } else {",
      "493:         sock_ptr = session;",
      "494:     }",
      "496:     sock = GPOINTER_TO_INT(sock_ptr);",
      "497:     if (sock <= 0) {",
      "498:         return -ENOTCONN;",
      "499:     }",
      "501:     start = time(NULL);",
      "502:     errno = 0;",
      "503:     do {",
      "504:         fds.fd = sock;",
      "505:         fds.events = POLLIN;",
      "510:         if (errno == EINTR && (timeout > 0)) {",
      "511:             timeout = timeout - ((time(NULL) - start) * 1000);",
      "512:             if (timeout < 1000) {",
      "513:                 timeout = 1000;",
      "514:             }",
      "515:         }",
      "517:         rc = poll(&fds, 1, timeout);",
      "518:     } while (rc < 0 && errno == EINTR);",
      "520:     return rc;",
      "521: }",
      "523: char *",
      "524: crm_recv_remote_raw(void *session, gboolean encrypted, size_t max_recv, size_t *recv_len, int *disconnected)",
      "525: {",
      "526:     char *reply = NULL;",
      "527:     if (recv_len) {",
      "529:     }",
      "531:     if (disconnected) {",
      "533:     }",
      "537:         reply = crm_recv_tls(session, max_recv, recv_len, disconnected);",
      "542:         reply = crm_recv_plaintext(GPOINTER_TO_INT(session), max_recv, recv_len, disconnected);",
      "546:     }",
      "548:     return reply;",
      "549: }",
      "558: gboolean",
      "559: crm_recv_remote_msg(void *session, char **recv_buf, gboolean encrypted, int total_timeout /*ms */, int *disconnected)",
      "560: {",
      "561:     int ret;",
      "562:     size_t request_len = 0;",
      "563:     time_t start = time(NULL);",
      "564:     char *raw_request = NULL;",
      "565:     int remaining_timeout = 0;",
      "567:     if (total_timeout == 0) {",
      "568:         total_timeout = 10000;",
      "569:     } else if (total_timeout < 0) {",
      "570:         total_timeout = 60000;",
      "571:     }",
      "574:     remaining_timeout = total_timeout;",
      "575:     while ((remaining_timeout > 0) && !(*disconnected)) {",
      "578:         crm_trace(\"waiting to receive remote msg, starting timeout %d, remaining_timeout %d\", total_timeout, remaining_timeout);",
      "579:         ret = crm_recv_remote_ready(session, encrypted, remaining_timeout);",
      "580:         raw_request = NULL;",
      "582:         if (ret == 0) {",
      "583:             crm_err(\"poll timed out (%d ms) while waiting to receive msg\", remaining_timeout);",
      "584:             return FALSE;",
      "586:         } else if (ret < 0) {",
      "587:             if (errno != EINTR) {",
      "588:                 crm_debug(\"poll returned error while waiting for msg, rc: %d, errno: %d\", ret, errno);",
      "590:                 return FALSE;",
      "591:             }",
      "592:             crm_debug(\"poll EINTR encountered during poll, retrying\");",
      "593:         } else {",
      "594:             raw_request = crm_recv_remote_raw(session, encrypted, 0, &request_len, disconnected);",
      "595:         }",
      "597:         remaining_timeout = remaining_timeout - ((time(NULL) - start) * 1000);",
      "599:         if (!raw_request) {",
      "600:             crm_debug(\"Empty msg received after poll\");",
      "601:             continue;",
      "602:         }",
      "604:         if (*recv_buf) {",
      "605:             int old_len = strlen(*recv_buf);",
      "607:             crm_trace(\"Expanding recv buffer from %d to %d\", old_len, old_len+request_len);",
      "610:             memcpy(*recv_buf + old_len, raw_request, request_len);",
      "612:             free(raw_request);",
      "613:         } else {",
      "615:         }",
      "617:         if (strstr(*recv_buf, REMOTE_MSG_TERMINATOR)) {",
      "618:             return TRUE;",
      "622:     return FALSE;",
      "631: int",
      "632: crm_remote_tcp_connect(const char *host, int port)",
      "633: {",
      "634:     struct addrinfo *res;",
      "635:     struct addrinfo *rp;",
      "636:     struct addrinfo hints;",
      "637:     const char *server = host;",
      "638:     int ret_ga;",
      "639:     int sock;",
      "642:     memset(&hints, 0, sizeof(struct addrinfo));",
      "644:     hints.ai_socktype = SOCK_STREAM;",
      "645:     hints.ai_flags = AI_CANONNAME;",
      "647:     crm_debug(\"Looking up %s\", server);",
      "648:     ret_ga = getaddrinfo(server, NULL, &hints, &res);",
      "649:     if (ret_ga) {",
      "650:         crm_err(\"getaddrinfo: %s\", gai_strerror(ret_ga));",
      "651:         return -1;",
      "652:     }",
      "654:     if (!res || !res->ai_addr) {",
      "655:         crm_err(\"getaddrinfo failed\");",
      "656:         return -1;",
      "657:     }",
      "659:     for (rp = res; rp != NULL; rp = rp->ai_next) {",
      "660:         struct sockaddr *addr = rp->ai_addr;",
      "661:         int flag = 0;",
      "662:         if (!addr) {",
      "663:             continue;",
      "664:         }",
      "666:         if (rp->ai_canonname) {",
      "667:             server = res->ai_canonname;",
      "668:         }",
      "669:         crm_debug(\"Got address %s for %s\", server, host);",
      "672:         sock = socket(rp->ai_family, SOCK_STREAM, IPPROTO_TCP);",
      "673:         if (sock == -1) {",
      "674:             crm_err(\"Socket creation failed for remote client connection.\");",
      "675:             continue;",
      "676:         }",
      "677:         if (addr->sa_family == AF_INET6) {",
      "678:             struct sockaddr_in6 *addr_in = (struct sockaddr_in6 *) addr;",
      "679:             addr_in->sin6_port = htons(port);",
      "680:         } else {",
      "681:             struct sockaddr_in *addr_in = (struct sockaddr_in *) addr;",
      "682:             addr_in->sin_port = htons(port);",
      "683:             crm_info(\"Attempting to connect to remote server at %s:%d\", inet_ntoa(addr_in->sin_addr), port);",
      "684:         }",
      "686:         if (connect(sock, rp->ai_addr, rp->ai_addrlen) == 0) {",
      "687:             if ((flag = fcntl(sock, F_GETFL)) >= 0) {",
      "688:                 if (fcntl(sock, F_SETFL, flag | O_NONBLOCK) < 0) {",
      "689:                     crm_err( \"fcntl() write failed\");",
      "690:                     close(sock);",
      "691:                     sock = -1;",
      "692:                     continue;",
      "693:                 }",
      "694:             }",
      "696:         }",
      "698:         close(sock);",
      "699:         sock = -1;",
      "700:     }",
      "701:     freeaddrinfo(res);",
      "703:     return sock;",
      "704: }",
      "",
      "---------------"
    ],
    "tools/crm_mon.c||tools/crm_mon.c": [
      "File: tools/crm_mon.c -> tools/crm_mon.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "275:             if (rc == pcmk_ok) {",
      "276:                 rc = cib->cmds->set_connection_dnotify(cib, mon_cib_connection_destroy);",
      "277:                 if (rc == -EPROTONOSUPPORT) {",
      "279:                     if (as_console) {",
      "280:                         sleep(2);",
      "281:                     }",
      "",
      "[Removed Lines]",
      "278:                     print_as(\"Notification setup failed, won't be able to reconnect after failure\");",
      "",
      "[Added Lines]",
      "278:                     print_as(\"Notification setup not supported, won't be able to reconnect after failure\");",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "09477215ec0c006566bcf6e4f853d4d3ced1e1b3",
      "candidate_info": {
        "commit_hash": "09477215ec0c006566bcf6e4f853d4d3ced1e1b3",
        "repo": "ClusterLabs/pacemaker",
        "commit_url": "https://github.com/ClusterLabs/pacemaker/commit/09477215ec0c006566bcf6e4f853d4d3ced1e1b3",
        "files": [
          "crmd/control.c",
          "crmd/tengine.c",
          "lib/common/ipc.c",
          "lib/common/mainloop.c",
          "valgrind-pcmk.suppressions"
        ],
        "message": "Fix: Core: Correctly unreference GSource inputs",
        "before_after_code_files": [
          "crmd/control.c||crmd/control.c",
          "crmd/tengine.c||crmd/tengine.c",
          "lib/common/ipc.c||licommon/ipc.c",
          "lib/common/mainloop.c||licommon/mainloop.c",
          "valgrind-pcmk.suppressions||valgrind-pcmk.suppressions"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "crmd/control.c||crmd/control.c": [
          "File: crmd/control.c -> crmd/control.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "269:     clear_bit(fsa_input_register, R_LRM_CONNECTED);",
          "270:     lrm_state_destroy_all();",
          "272:     mainloop_destroy_trigger(fsa_source);",
          "273:     mainloop_destroy_trigger(config_read);",
          "274:     mainloop_destroy_trigger(stonith_reconnect);",
          "276:     if(stonith_api) {",
          "277:         crm_trace(\"Disconnecting fencing API\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "277:     mainloop_destroy_trigger(transition_trigger);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "376:     fsa_source = mainloop_add_trigger(G_PRIORITY_HIGH, crm_fsa_trigger, NULL);",
          "377:     config_read = mainloop_add_trigger(G_PRIORITY_HIGH, crm_read_options, NULL);",
          "379:     crm_debug(\"Creating CIB and LRM objects\");",
          "380:     fsa_cib_conn = cib_new();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "383:     transition_trigger = mainloop_add_trigger(G_PRIORITY_LOW, te_graph_trigger, NULL);",
          "",
          "---------------"
        ],
        "crmd/tengine.c||crmd/tengine.c": [
          "File: crmd/tengine.c -> crmd/tengine.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "106:     te_uuid = crm_generate_uuid();",
          "107:     crm_info(\"Registering TE UUID: %s\", te_uuid);",
          "113:     if (pcmk_ok !=",
          "114:         fsa_cib_conn->cmds->add_notify_callback(fsa_cib_conn, T_CIB_DIFF_NOTIFY, te_update_diff)) {",
          "115:         crm_err(\"Could not set CIB notification callback\");",
          "",
          "[Removed Lines]",
          "109:     if (transition_trigger == NULL) {",
          "110:         transition_trigger = mainloop_add_trigger(G_PRIORITY_LOW, te_graph_trigger, NULL);",
          "111:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "lib/common/ipc.c||licommon/ipc.c": [
          "File: lib/common/ipc.c -> licommon/ipc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "248: void",
          "249: crm_client_cleanup(void)",
          "250: {",
          "252:         int active = g_hash_table_size(client_connections);",
          "254:         if (active) {",
          "",
          "[Removed Lines]",
          "251:     if (client_connections == NULL) {",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "lib/common/mainloop.c||licommon/mainloop.c": [
          "File: lib/common/mainloop.c -> licommon/mainloop.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "112:     return rc;",
          "113: }",
          "115: static GSourceFuncs crm_trigger_funcs = {",
          "116:     crm_trigger_prepare,",
          "117:     crm_trigger_check,",
          "118:     crm_trigger_dispatch,",
          "120: };",
          "122: static crm_trigger_t *",
          "",
          "[Removed Lines]",
          "119:     NULL",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "138:     g_source_set_priority(source, priority);",
          "139:     g_source_set_can_recurse(source, FALSE);",
          "141:     trigger->id = g_source_attach(source, NULL);",
          "142:     return trigger;",
          "143: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "176: mainloop_destroy_trigger(crm_trigger_t * source)",
          "177: {",
          "178:     GSource *gs = (GSource *)source;",
          "180:     return TRUE;",
          "181: }",
          "",
          "[Removed Lines]",
          "179:     g_source_destroy(gs);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "217:     crm_trigger_prepare,",
          "218:     crm_trigger_check,",
          "219:     crm_signal_dispatch,",
          "221: };",
          "223: gboolean",
          "",
          "[Removed Lines]",
          "220:     NULL",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "valgrind-pcmk.suppressions||valgrind-pcmk.suppressions": [
          "File: valgrind-pcmk.suppressions -> valgrind-pcmk.suppressions",
          "--- Hunk 1 ---",
          "[Context before]",
          "59:    fun:g_quark_from_static_string",
          "60: }",
          "62: {",
          "63:    glib types",
          "64:    Memcheck:Leak",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "62: {",
          "63:    quarks - hashtable 2",
          "64:    Memcheck:Leak",
          "65:    fun:malloc",
          "66:    fun:g_malloc",
          "67:    fun:g_slice_alloc",
          "68:    fun:g_hash_table_new_full",
          "69:    fun:g_quark_from_static_string",
          "70: }",
          "72: {",
          "73:    quarks - hashtable 3",
          "74:    Memcheck:Leak",
          "75:    fun:calloc",
          "76:    fun:g_malloc0",
          "77:    fun:g_hash_table_new_full",
          "78:    fun:g_quark_from_static_string",
          "79: }",
          "81: {",
          "82:    quarks - hashtable 4",
          "83:    Memcheck:Leak",
          "84:    fun:malloc",
          "85:    fun:realloc",
          "86:    fun:g_realloc",
          "87:    fun:g_quark_from_static_string",
          "88: }",
          "90: {",
          "91:    g_mainloop - create",
          "92:    Memcheck:Leak",
          "93:    fun:calloc",
          "94:    fun:g_malloc0",
          "95:    fun:g_main_loop_new",
          "96:    fun:crmd_init",
          "97: }",
          "99: {",
          "100:    g_mainloop - run 1",
          "101:    Memcheck:Leak",
          "102:    fun:malloc",
          "103:    fun:g_malloc",
          "104:    fun:g_slice_alloc",
          "105:    fun:g_slice_alloc0",
          "106:    obj:*/libglib-*",
          "107:    fun:g_main_context_dispatch",
          "108:    obj:*/libglib-*",
          "109:    fun:g_main_loop_run",
          "110: }",
          "112: {",
          "113:    g_mainloop - run 2",
          "114:    Memcheck:Leak",
          "115:    fun:malloc",
          "116:    fun:realloc",
          "117:    fun:g_realloc",
          "118:    obj:*/libglib-*",
          "119:    fun:g_array_set_size",
          "120:    fun:g_static_private_set",
          "121:    obj:*/libglib-*",
          "122:    fun:g_main_context_dispatch",
          "123:    obj:*/libglib-*",
          "124:    fun:g_main_loop_run",
          "125: }",
          "127: {",
          "128:    g_mainloop - run 3",
          "129:    Memcheck:Leak",
          "130:    fun:malloc",
          "131:    fun:g_malloc",
          "132:    fun:g_slice_alloc",
          "133:    fun:g_array_sized_new",
          "134:    fun:g_static_private_set",
          "135:    obj:*/libglib-*",
          "136:    fun:g_main_context_dispatch",
          "137:    obj:*/libglib-*",
          "138:    fun:g_main_loop_run",
          "139: }",
          "141: {",
          "142:    g_mainloop - run 4",
          "143:    Memcheck:Leak",
          "144:    fun:calloc",
          "145:    fun:g_malloc0",
          "146:    fun:g_thread_self",
          "147:    fun:g_main_loop_run",
          "148: }",
          "150: {",
          "151:    g_mainloop - run 5",
          "152:    Memcheck:Leak",
          "153:    fun:malloc",
          "154:    fun:g_malloc",
          "155:    obj:*/libglib-*",
          "156:    fun:g_main_loop_run",
          "157: }",
          "159: {",
          "160:    g_mainloop - run 5",
          "161:    Memcheck:Leak",
          "162:    fun:malloc",
          "163:    fun:realloc",
          "164:    fun:g_realloc",
          "165:    obj:*/libglib-*",
          "166:    fun:g_ptr_array_add",
          "167:    fun:g_main_context_check",
          "168:    obj:*/libglib-*",
          "169:    fun:g_main_loop_run",
          "170: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9d73320eb25f4f5981e4d9667430c687e1428c7f",
      "candidate_info": {
        "commit_hash": "9d73320eb25f4f5981e4d9667430c687e1428c7f",
        "repo": "ClusterLabs/pacemaker",
        "commit_url": "https://github.com/ClusterLabs/pacemaker/commit/9d73320eb25f4f5981e4d9667430c687e1428c7f",
        "files": [
          "crmd/throttle.c",
          "lib/common/remote.c"
        ],
        "message": "Fix: crmd: Prevent memory leak in error paths",
        "before_after_code_files": [
          "crmd/throttle.c||crmd/throttle.c",
          "lib/common/remote.c||lib/common/remote.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/common/remote.c||lib/common/remote.c"
          ],
          "candidate": [
            "lib/common/remote.c||lib/common/remote.c"
          ]
        }
      },
      "candidate_diff": {
        "crmd/throttle.c||crmd/throttle.c": [
          "File: crmd/throttle.c -> crmd/throttle.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "83:         }",
          "84:     }",
          "86:     if(cores == 0) {",
          "87:         crm_warn(\"No processors found in %s, assuming 1\", cpufile);",
          "88:         return 1;",
          "89:     }",
          "92:     return cores;",
          "93: }",
          "",
          "[Removed Lines]",
          "91:     fclose(stream);",
          "",
          "[Added Lines]",
          "86:     fclose(stream);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "242:         if(rc != 15) {",
          "243:             crm_err(\"Only %d of 15 fields found in %s\", rc, loadfile);",
          "244:             return FALSE;",
          "246:         } else if(last_call > 0",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "245:             fclose(stream);",
          "",
          "---------------"
        ],
        "lib/common/remote.c||lib/common/remote.c": [
          "File: lib/common/remote.c -> lib/common/remote.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "330:     char *xml_text = dump_xml_unformatted(msg);",
          "332:     struct iovec iov[2];",
          "335:     if (xml_text == NULL) {",
          "336:         crm_err(\"Invalid XML, can not send msg\");",
          "337:         return -1;",
          "338:     }",
          "340:     iov[0].iov_base = header;",
          "341:     iov[0].iov_len = sizeof(struct crm_remote_header_v0);",
          "",
          "[Removed Lines]",
          "333:     struct crm_remote_header_v0 *header = calloc(1, sizeof(struct crm_remote_header_v0));",
          "",
          "[Added Lines]",
          "333:     struct crm_remote_header_v0 *header;",
          "340:     header = calloc(1, sizeof(struct crm_remote_header_v0));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "89386baa5a23ff76ef08dcd5e72c5bdb412ed048",
      "candidate_info": {
        "commit_hash": "89386baa5a23ff76ef08dcd5e72c5bdb412ed048",
        "repo": "ClusterLabs/pacemaker",
        "commit_url": "https://github.com/ClusterLabs/pacemaker/commit/89386baa5a23ff76ef08dcd5e72c5bdb412ed048",
        "files": [
          "crmd/Makefile.am",
          "crmd/crmd_lrm.h",
          "crmd/lrm.c",
          "crmd/lrm_state.c",
          "crmd/remote_lrmd_ra.c",
          "include/crm/lrmd.h",
          "include/crm_internal.h",
          "lib/common/remote.c",
          "lib/lrmd/lrmd_client.c",
          "lrmd/lrmd.c",
          "lrmd/test.c",
          "lrmd/tls_backend.c"
        ],
        "message": "High: crmd: Introducing remote lrmd connection resources",
        "before_after_code_files": [
          "crmd/Makefile.am||crmd/Makefile.am",
          "crmd/crmd_lrm.h||crmd/crmd_lrm.h",
          "crmd/lrm.c||crmd/lrm.c",
          "crmd/lrm_state.c||crmd/lrm_state.c",
          "crmd/remote_lrmd_ra.c||crmd/remote_lrmd_ra.c",
          "include/crm/lrmd.h||include/crm/lrmd.h",
          "include/crm_internal.h||include/crm_internal.h",
          "lib/common/remote.c||lib/common/remote.c",
          "lib/lrmd/lrmd_client.c||lib/lrmd/lrmd_client.c",
          "lrmd/lrmd.c||lrmd/lrmd.c",
          "lrmd/test.c||lrmd/test.c",
          "lrmd/tls_backend.c||lrmd/tls_backend.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/crm_internal.h||include/crm_internal.h",
            "lib/common/remote.c||lib/common/remote.c"
          ],
          "candidate": [
            "include/crm_internal.h||include/crm_internal.h",
            "lib/common/remote.c||lib/common/remote.c"
          ]
        }
      },
      "candidate_diff": {
        "crmd/Makefile.am||crmd/Makefile.am": [
          "File: crmd/Makefile.am -> crmd/Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: crmd_SOURCES = main.c crmd.c corosync.c     \\",
          "35:   fsa.c control.c messages.c membership.c callbacks.c  \\",
          "36:   election.c join_client.c join_dc.c subsystems.c  \\",
          "38:   utils.c misc.c te_events.c te_actions.c te_utils.c te_callbacks.c",
          "40: if BUILD_HEARTBEAT_SUPPORT",
          "",
          "[Removed Lines]",
          "37:   cib.c pengine.c tengine.c lrm.c lrm_state.c   \\",
          "",
          "[Added Lines]",
          "37:   cib.c pengine.c tengine.c lrm.c lrm_state.c remote_lrmd_ra.c \\",
          "",
          "---------------"
        ],
        "crmd/crmd_lrm.h||crmd/crmd_lrm.h": [
          "File: crmd/crmd_lrm.h -> crmd/crmd_lrm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "47: typedef struct lrm_state_s {",
          "48:     const char *node_name;",
          "51:     GHashTable *resource_history;",
          "52:     GHashTable *pending_ops;",
          "",
          "[Removed Lines]",
          "49:     lrmd_t *conn;",
          "",
          "[Added Lines]",
          "49:     void *conn;",
          "50:     void *remote_ra_data;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "78: void lrm_state_destroy_all(void);",
          "",
          "[Removed Lines]",
          "83: lrm_state_t *lrm_state_create_remote(const char *node_name, const char *server, int port);",
          "",
          "[Added Lines]",
          "84: lrm_state_t *lrm_state_create(const char *node_name);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "93: lrm_state_t *lrm_state_find(const char *node_name);",
          "",
          "[Removed Lines]",
          "99: lrm_state_t *lrm_state_find_or_create_local(const char *node_name);",
          "",
          "[Added Lines]",
          "99: lrm_state_t *lrm_state_find_or_create(const char *node_name);",
          "109: void lrm_state_disconnect(lrm_state_t *lrm_state);",
          "110: int lrm_state_ipc_connect(lrm_state_t *lrm_state);",
          "111: int lrm_state_remote_connect_async(lrm_state_t *lrm_state, const char *server, int port, int timeout);",
          "112: int lrm_state_is_connected(lrm_state_t *lrm_state);",
          "113: int lrm_state_poke_connection(lrm_state_t *lrm_state);",
          "115: int lrm_state_get_metadata (lrm_state_t *lrm_state,",
          "116:         const char *class,",
          "117:         const char *provider,",
          "118:         const char *agent,",
          "119:         char **output,",
          "120:         enum lrmd_call_options options);",
          "121: int lrm_state_cancel(lrm_state_t *lrm_state,",
          "122:     const char *rsc_id,",
          "123:     const char *action,",
          "124:     int interval);",
          "125: int lrm_state_exec(lrm_state_t *lrm_state,",
          "126:     const char *rsc_id,",
          "127:     const char *action,",
          "128:     const char *userdata,",
          "132:     lrmd_key_value_t *params);",
          "133: lrmd_rsc_info_t *lrm_state_get_rsc_info(lrm_state_t *lrm_state,",
          "134:     const char *rsc_id,",
          "135:     enum lrmd_call_options options);",
          "136: int lrm_state_register_rsc(lrm_state_t *lrm_state,",
          "137:     const char *rsc_id,",
          "138:     const char *class,",
          "139:     const char *provider,",
          "140:     const char *agent,",
          "141:     enum lrmd_call_options options);",
          "142: int lrm_state_unregister_rsc(lrm_state_t *lrm_state,",
          "143:     const char *rsc_id,",
          "144:     enum lrmd_call_options options);",
          "147: void remote_lrm_op_callback(lrmd_event_data_t * op);",
          "148: gboolean is_remote_lrmd_ra(const char *agent, const char *provider, const char *id);",
          "149: int remote_ra_get_metadata(char **output);",
          "150: lrmd_rsc_info_t * remote_ra_get_rsc_info(lrm_state_t *lrm_state, const char *rsc_id);",
          "151: int remote_ra_cancel(lrm_state_t *lrm_state, const char *rsc_id, const char *action, int interval);",
          "152: int remote_ra_exec(lrm_state_t *lrm_state,",
          "153:     const char *rsc_id,",
          "154:     const char *action,",
          "155:     const char *userdata,",
          "159:     lrmd_key_value_t *params);",
          "160: void remote_ra_cleanup(lrm_state_t *lrm_state);",
          "",
          "---------------"
        ],
        "crmd/lrm.c||crmd/lrm.c": [
          "File: crmd/lrm.c -> crmd/lrm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "218:     CRM_CHECK(op != NULL, return);",
          "221:     nodename = op->remote_nodename ? op->remote_nodename : fsa_our_uname;",
          "222:     lrm_state = lrm_state_find(nodename);",
          "224:     CRM_ASSERT(lrm_state != NULL);",
          "226:     process_lrm_event(lrm_state, op);",
          "227: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "226:     if (op->type == lrmd_event_disconnect && (safe_str_eq(lrm_state->node_name, fsa_our_uname))) {",
          "227:         lrm_connection_destroy();",
          "228:         return;",
          "229:     } else if (op->type != lrmd_event_exec_complete) {",
          "230:         return;",
          "231:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "240:     lrm_state_t *lrm_state = NULL;",
          "243:     if (lrm_state == NULL) {",
          "244:         register_fsa_error(C_FSA_INTERNAL, I_ERROR, NULL);",
          "245:         return;",
          "",
          "[Removed Lines]",
          "242:     lrm_state = lrm_state_find_or_create_local(fsa_our_uname);",
          "",
          "[Added Lines]",
          "249:     lrm_state = lrm_state_find_or_create(fsa_our_uname);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "254:         }",
          "256:         clear_bit(fsa_input_register, R_LRM_CONNECTED);",
          "258:         lrm_state_reset_tables(lrm_state);",
          "259:         crm_notice(\"Disconnected from the LRM\");",
          "260:     }",
          "",
          "[Removed Lines]",
          "257:         lrm_state->conn->cmds->disconnect(lrm_state->conn);",
          "",
          "[Added Lines]",
          "264:         lrm_state_disconnect(lrm_state);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "263:         int ret = pcmk_ok;",
          "265:         crm_debug(\"Connecting to the LRM\");",
          "268:         if (ret != pcmk_ok) {",
          "270:                 crm_warn(\"Failed to sign on to the LRM %d\"",
          "271:                          \" (%d max) times\", lrm_state->num_lrm_register_fails, MAX_LRM_REG_FAILS);",
          "",
          "[Removed Lines]",
          "266:         ret = lrm_state->conn->cmds->connect(lrm_state->conn, CRM_SYSTEM_CRMD, NULL);",
          "269:             if (++lrm_state->num_lrm_register_fails < MAX_LRM_REG_FAILS) {",
          "",
          "[Added Lines]",
          "273:         ret = lrm_state_ipc_connect(lrm_state);",
          "276:             if (lrm_state->num_lrm_register_fails < MAX_LRM_REG_FAILS) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "349:     }",
          "351:     if (lrm_state->pending_ops) {",
          "355:             g_hash_table_foreach_remove(lrm_state->pending_ops, stop_recurring_actions, NULL);",
          "356:         }",
          "",
          "[Removed Lines]",
          "353:         if (is_set(fsa_input_register, R_LRM_CONNECTED)) {",
          "",
          "[Added Lines]",
          "359:         if (lrm_state_is_connected(lrm_state) == TRUE) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "409:     }",
          "411:     crm_trace(\"Retreiving metadata for %s::%s:%s\", type, class, provider);",
          "414:     if (metadata) {",
          "",
          "[Removed Lines]",
          "412:     lrm_state->conn->cmds->get_metadata(lrm_state->conn, class, provider, type, &metadata, 0);",
          "",
          "[Added Lines]",
          "418:     lrm_state_get_metadata(lrm_state, class, provider, type, &metadata, 0);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "997:     crm_debug(\"Cancelling op %d for %s (%s)\", op, rsc_id, key);",
          "1000:         pending->rsc_id,",
          "1001:         pending->op_type,",
          "1002:         pending->interval);",
          "",
          "[Removed Lines]",
          "999:     rc = lrm_state->conn->cmds->cancel(lrm_state->conn,",
          "",
          "[Added Lines]",
          "1005:     rc = lrm_state_cancel(lrm_state,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1074:     crm_trace(\"Retrieving %s from the LRM.\", id);",
          "1075:     CRM_CHECK(id != NULL, return NULL);",
          "1078:     if (!rsc && long_id) {",
          "1080:     }",
          "1082:     if (!rsc && do_create) {",
          "",
          "[Removed Lines]",
          "1077:     rsc = lrm_state->conn->cmds->get_rsc_info(lrm_state->conn, id, 0);",
          "1079:         rsc = lrm_state->conn->cmds->get_rsc_info(lrm_state->conn, long_id, 0);",
          "",
          "[Added Lines]",
          "1083:     rsc = lrm_state_get_rsc_info(lrm_state, id, 0);",
          "1086:         rsc = lrm_state_get_rsc_info(lrm_state, long_id, 0);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1086:         crm_trace(\"Adding rsc %s before operation\", id);",
          "1089:             id, class, provider, type, lrmd_opt_drop_recurring);",
          "1093:         if (!rsc) {",
          "1094:             fsa_data_t *msg_data = NULL;",
          "",
          "[Removed Lines]",
          "1088:         lrm_state->conn->cmds->register_rsc(lrm_state->conn,",
          "1091:         rsc = lrm_state->conn->cmds->get_rsc_info(lrm_state->conn, id, 0);",
          "",
          "[Added Lines]",
          "1095:         lrm_state_register_rsc(lrm_state,",
          "1098:         rsc = lrm_state_get_rsc_info(lrm_state, id, 0);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1116:     crm_info(\"Removing resource %s for %s (%s) on %s\", id, sys, user ? user : \"internal\", host);",
          "1118:     if (rsc) {",
          "1120:     }",
          "1122:     if (rc == pcmk_ok) {",
          "",
          "[Removed Lines]",
          "1119:         rc = lrm_state->conn->cmds->unregister_rsc(lrm_state->conn, id, 0);",
          "",
          "[Added Lines]",
          "1126:         rc = lrm_state_unregister_rsc(lrm_state, id, 0);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1698:         }",
          "1699:     }",
          "1702:         rsc->id,",
          "1703:         op->op_type,",
          "1704:         op->user_data,",
          "1705:         op->interval,",
          "1706:         op->timeout,",
          "1707:         op->start_delay,",
          "1709:         params);",
          "1711:     if (call_id <= 0) {",
          "",
          "[Removed Lines]",
          "1701:     call_id = lrm_state->conn->cmds->exec(lrm_state->conn,",
          "1708:         lrmd_opt_notify_changes_only,",
          "",
          "[Added Lines]",
          "1708:     call_id = lrm_state_exec(lrm_state,",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1879:     CRM_CHECK(op != NULL, return FALSE);",
          "1888:     CRM_CHECK(op->rsc_id != NULL, return FALSE);",
          "1889:     op_id = make_stop_id(op->rsc_id, op->call_id);",
          "1890:     pending = g_hash_table_lookup(lrm_state->pending_ops, op_id);",
          "1891:     op_key = generate_op_key(op->rsc_id, op->op_type, op->interval);",
          "1894:     switch (op->op_status) {",
          "1895:         case PCMK_LRM_OP_ERROR:",
          "",
          "[Removed Lines]",
          "1881:     if (op->type == lrmd_event_disconnect) {",
          "1882:         lrm_connection_destroy();",
          "1883:         return TRUE;",
          "1884:     } else if (op->type != lrmd_event_exec_complete) {",
          "1885:         return TRUE;",
          "1886:     }",
          "1892:     rsc = lrm_state->conn->cmds->get_rsc_info(lrm_state->conn, op->rsc_id, 0);",
          "",
          "[Added Lines]",
          "1891:     rsc = lrm_state_get_rsc_info(lrm_state, op->rsc_id, 0);",
          "",
          "---------------"
        ],
        "crmd/lrm_state.c||crmd/lrm_state.c": [
          "File: crmd/lrm_state.c -> crmd/lrm_state.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "68: }",
          "73: {",
          "75:     lrm_state_t *state = calloc(1, sizeof(lrm_state_t));",
          "",
          "[Removed Lines]",
          "71: static lrm_state_t *",
          "72: internal_state_create(const char *node_name)",
          "",
          "[Added Lines]",
          "71: lrm_state_t *",
          "72: lrm_state_create(const char *node_name)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "102:     return state;",
          "104: }",
          "136: void lrm_state_destroy(const char *node_name)",
          "137: {",
          "",
          "[Removed Lines]",
          "105: static lrm_state_t *",
          "106: lrm_state_create_local(const char *node_name)",
          "107: {",
          "109:     lrm_state_t *state = internal_state_create(node_name);",
          "111:     if (state) {",
          "112:         state->conn = lrmd_api_new();",
          "113:         state->conn->cmds->set_callback(state->conn, lrm_op_callback);",
          "114:  }",
          "115:     return state;",
          "116: }",
          "118: lrm_state_t *",
          "119: lrm_state_create_remote(const char *node_name, const char *server, int port)",
          "120: {",
          "121:     lrm_state_t *state;",
          "123:     if (!server || !port) {",
          "124:         return NULL;",
          "125:     }",
          "127:     state = internal_state_create(node_name);",
          "129:     if (state) {",
          "130:         state->conn = lrmd_remote_api_new(node_name, server, port);",
          "131:         state->conn->cmds->set_callback(state->conn, lrm_op_callback);",
          "132:     }",
          "133:     return state;",
          "134: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "146:         return;",
          "147:     }",
          "149:     lrmd_api_delete(lrm_state->conn);",
          "151:     if (lrm_state->resource_history) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "119:     remote_ra_cleanup(lrm_state);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "202:     return g_hash_table_lookup(lrm_state_table, node_name);",
          "203: }",
          "206: {",
          "207:     lrm_state_t *lrm_state;",
          "209:     lrm_state = g_hash_table_lookup(lrm_state_table, node_name);",
          "210:     if (!lrm_state) {",
          "212:     }",
          "214:     return lrm_state;",
          "",
          "[Removed Lines]",
          "205: lrm_state_t *lrm_state_find_or_create_local(const char *node_name)",
          "211:         lrm_state = lrm_state_create_local(node_name);",
          "",
          "[Added Lines]",
          "176: lrm_state_t *lrm_state_find_or_create(const char *node_name)",
          "182:         lrm_state = lrm_state_create(node_name);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "218: {",
          "219:     return g_hash_table_get_values(lrm_state_table);",
          "220: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "193: void",
          "194: lrm_state_disconnect(lrm_state_t *lrm_state)",
          "195: {",
          "196:     if (!lrm_state->conn) {",
          "197:         return;",
          "198:     }",
          "199:     ((lrmd_t *) lrm_state->conn)->cmds->disconnect(lrm_state->conn);",
          "200:     lrmd_api_delete(lrm_state->conn);",
          "201:     lrm_state->conn = NULL;",
          "202: }",
          "204: int",
          "205: lrm_state_is_connected(lrm_state_t *lrm_state)",
          "206: {",
          "207:     if (!lrm_state->conn) {",
          "208:         return FALSE;",
          "209:     }",
          "210:     return ((lrmd_t *) lrm_state->conn)->cmds->is_connected(lrm_state->conn);",
          "211: }",
          "213: int lrm_state_poke_connection(lrm_state_t *lrm_state)",
          "214: {",
          "216:     if (!lrm_state->conn) {",
          "217:         return -1;",
          "218:     }",
          "219:     return ((lrmd_t *) lrm_state->conn)->cmds->poke_connection(lrm_state->conn);",
          "220: }",
          "222: int",
          "223: lrm_state_ipc_connect(lrm_state_t *lrm_state)",
          "224: {",
          "225:     int ret;",
          "227:     if (!lrm_state->conn) {",
          "228:         lrm_state->conn = lrmd_api_new();",
          "229:         ((lrmd_t *)lrm_state->conn)->cmds->set_callback(lrm_state->conn, lrm_op_callback);",
          "230:     }",
          "232:     ret = ((lrmd_t *) lrm_state->conn)->cmds->connect(lrm_state->conn, CRM_SYSTEM_CRMD, NULL);",
          "234:     if (ret != pcmk_ok) {",
          "235:         lrm_state->num_lrm_register_fails++;",
          "236:     } else {",
          "237:         lrm_state->num_lrm_register_fails = 0;",
          "238:     }",
          "240:     return ret;",
          "241: }",
          "243: int",
          "244: lrm_state_remote_connect_async(lrm_state_t *lrm_state, const char *server, int port, int timeout_ms)",
          "245: {",
          "246:     int ret;",
          "248:     if (!lrm_state->conn) {",
          "249:         lrm_state->conn = lrmd_remote_api_new(lrm_state->node_name, server, port);",
          "250:         if (!lrm_state->conn) {",
          "251:             return -1;",
          "252:         }",
          "253:         ((lrmd_t *) lrm_state->conn)->cmds->set_callback(lrm_state->conn, remote_lrm_op_callback);",
          "254:     }",
          "256:     crm_trace(\"initiating remote connection to %s at %d with timeout %d\", server, port, timeout_ms);",
          "257:     ret = ((lrmd_t *) lrm_state->conn)->cmds->connect_async(lrm_state->conn, lrm_state->node_name, timeout_ms);",
          "259:     if (ret != pcmk_ok) {",
          "260:         lrm_state->num_lrm_register_fails++;",
          "261:     } else {",
          "262:         lrm_state->num_lrm_register_fails = 0;",
          "263:     }",
          "265:     return ret;",
          "266: }",
          "268: int lrm_state_get_metadata (lrm_state_t *lrm_state,",
          "269:         const char *class,",
          "270:         const char *provider,",
          "271:         const char *agent,",
          "272:         char **output,",
          "273:         enum lrmd_call_options options)",
          "274: {",
          "275:     if (!lrm_state->conn) {",
          "276:         return -ENOTCONN;",
          "277:     }",
          "278:     if (is_remote_lrmd_ra(agent, provider, NULL)) {",
          "279:         return remote_ra_get_metadata(output);",
          "280:     }",
          "284:     return ((lrmd_t *) lrm_state->conn)->cmds->get_metadata(lrm_state->conn, class, provider, agent, output, options);",
          "285: }",
          "287: int lrm_state_cancel(lrm_state_t *lrm_state,",
          "288:     const char *rsc_id,",
          "289:     const char *action,",
          "290:     int interval)",
          "291: {",
          "292:     if (!lrm_state->conn) {",
          "293:         return -ENOTCONN;",
          "294:     }",
          "298:     if (is_remote_lrmd_ra(NULL, NULL, rsc_id)) {",
          "299:         return remote_ra_cancel(lrm_state, rsc_id, action, interval);",
          "300:     }",
          "301:     return ((lrmd_t *) lrm_state->conn)->cmds->cancel(lrm_state->conn, rsc_id, action, interval);",
          "302: }",
          "304: lrmd_rsc_info_t *lrm_state_get_rsc_info(lrm_state_t *lrm_state,",
          "305:     const char *rsc_id,",
          "306:     enum lrmd_call_options options)",
          "307: {",
          "308:     if (!lrm_state->conn) {",
          "309:         return NULL;",
          "310:     }",
          "313:     if (is_remote_lrmd_ra(NULL, NULL, rsc_id)) {",
          "314:         return remote_ra_get_rsc_info(lrm_state, rsc_id);",
          "315:     }",
          "317:     return ((lrmd_t *) lrm_state->conn)->cmds->get_rsc_info(lrm_state->conn, rsc_id, options);",
          "318: }",
          "320: int lrm_state_exec(lrm_state_t *lrm_state,",
          "321:     const char *rsc_id,",
          "322:     const char *action,",
          "323:     const char *userdata,",
          "327:     lrmd_key_value_t *params)",
          "328: {",
          "330:     if (!lrm_state->conn) {",
          "331:         lrmd_key_value_freeall(params);",
          "332:         return -ENOTCONN;",
          "333:     }",
          "335:     if (is_remote_lrmd_ra(NULL, NULL, rsc_id)) {",
          "336:         return remote_ra_exec(lrm_state,",
          "337:             rsc_id,",
          "338:             action,",
          "339:             userdata,",
          "340:             interval,",
          "341:             timeout,",
          "342:             start_delay,",
          "343:             params);",
          "344:     }",
          "346:     return ((lrmd_t *) lrm_state->conn)->cmds->exec(lrm_state->conn,",
          "347:         rsc_id,",
          "348:         action,",
          "349:         userdata,",
          "350:         interval,",
          "351:         timeout,",
          "352:         start_delay,",
          "353:         lrmd_opt_notify_changes_only,",
          "354:         params);",
          "355: }",
          "357: int lrm_state_register_rsc(lrm_state_t *lrm_state,",
          "358:     const char *rsc_id,",
          "359:     const char *class,",
          "360:     const char *provider,",
          "361:     const char *agent,",
          "362:     enum lrmd_call_options options)",
          "363: {",
          "364:     if (!lrm_state->conn) {",
          "365:         return -ENOTCONN;",
          "366:     }",
          "372:     if (is_remote_lrmd_ra(agent, provider, NULL)) {",
          "373:         return lrm_state_find_or_create(rsc_id) ? pcmk_ok : -1;",
          "374:     }",
          "376:     return ((lrmd_t *) lrm_state->conn)->cmds->register_rsc(lrm_state->conn, rsc_id, class, provider, agent, options);",
          "377: }",
          "379: int lrm_state_unregister_rsc(lrm_state_t *lrm_state,",
          "380:     const char *rsc_id,",
          "381:     enum lrmd_call_options options)",
          "382: {",
          "383:     if (!lrm_state->conn) {",
          "384:         return -ENOTCONN;",
          "385:     }",
          "390:     if (is_remote_lrmd_ra(NULL, NULL, rsc_id)) {",
          "391:         lrm_state_destroy(rsc_id);",
          "392:         return pcmk_ok;",
          "393:     }",
          "395:     return ((lrmd_t *) lrm_state->conn)->cmds->unregister_rsc(lrm_state->conn, rsc_id, options);",
          "396: }",
          "",
          "---------------"
        ],
        "crmd/remote_lrmd_ra.c||crmd/remote_lrmd_ra.c": [
          "File: crmd/remote_lrmd_ra.c -> crmd/remote_lrmd_ra.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: #include <crm_internal.h>",
          "20: #include <crm/crm.h>",
          "22: #include <crmd.h>",
          "23: #include <crmd_fsa.h>",
          "24: #include <crmd_messages.h>",
          "25: #include <crmd_callbacks.h>",
          "26: #include <crmd_lrm.h>",
          "27: #include <crm/lrmd.h>",
          "28: #include <crm/services.h>",
          "30: #define REMOTE_LRMD_RA \"remote\"",
          "32: int remote_ra_callid = 0;",
          "34: typedef struct remote_ra_cmd_s {",
          "36:     char *owner;",
          "38:     char *rsc_id;",
          "40:     char *action;",
          "42:     char *userdata;",
          "44:     int start_delay;",
          "46:     int delay_id;",
          "48:     int timeout;",
          "50:     int interval;",
          "52:     int interval_id;",
          "53:     int reported_success;",
          "54:     int monitor_timeout_id;",
          "56:     lrmd_key_value_t *params;",
          "58:     int rc;",
          "59:     int op_status;",
          "60:     int call_id;",
          "61:     gboolean cancel;",
          "62: } remote_ra_cmd_t;",
          "64: typedef struct remote_ra_data_s {",
          "65:     crm_trigger_t *work;",
          "66:     remote_ra_cmd_t *cur_cmd;",
          "67:     GList *cmds;",
          "68:     GList *recurring_cmds;",
          "70: } remote_ra_data_t;",
          "72: static void",
          "73: free_cmd(gpointer user_data)",
          "74: {",
          "75:     remote_ra_cmd_t *cmd = user_data;",
          "77:     if (!cmd) {",
          "78:         return;",
          "79:     }",
          "80:     if (cmd->delay_id) {",
          "81:         g_source_remove(cmd->delay_id);",
          "82:     }",
          "83:     if (cmd->interval_id) {",
          "84:         g_source_remove(cmd->interval_id);",
          "85:     }",
          "86:     if (cmd->monitor_timeout_id) {",
          "87:         g_source_remove(cmd->monitor_timeout_id);",
          "88:     }",
          "89:     free(cmd->owner);",
          "90:     free(cmd->rsc_id);",
          "91:     free(cmd->action);",
          "92:     free(cmd->userdata);",
          "93:     lrmd_key_value_freeall(cmd->params);",
          "94:     free(cmd);",
          "95: }",
          "97: static gboolean",
          "98: recurring_helper(gpointer data)",
          "99: {",
          "100:     remote_ra_cmd_t *cmd = data;",
          "101:     lrm_state_t *connection_rsc = NULL;",
          "103:     cmd->interval_id = 0;",
          "104:     connection_rsc = lrm_state_find(cmd->rsc_id);",
          "105:     if (connection_rsc && connection_rsc->remote_ra_data) {",
          "106:         remote_ra_data_t *ra_data = connection_rsc->remote_ra_data;",
          "108:         ra_data->recurring_cmds = g_list_remove(ra_data->recurring_cmds, cmd);",
          "109:         ra_data->cmds = g_list_append(ra_data->cmds, cmd);",
          "110:         mainloop_set_trigger(ra_data->work);",
          "111:     }",
          "112:     return FALSE;",
          "113: }",
          "115: static gboolean",
          "116: start_delay_helper(gpointer data)",
          "117: {",
          "118:     remote_ra_cmd_t *cmd = data;",
          "119:     lrm_state_t *connection_rsc = NULL;",
          "121:     cmd->delay_id = 0;",
          "122:     connection_rsc = lrm_state_find(cmd->rsc_id);",
          "123:     if (connection_rsc && connection_rsc->remote_ra_data) {",
          "124:         remote_ra_data_t *ra_data = connection_rsc->remote_ra_data;",
          "125:         mainloop_set_trigger(ra_data->work);",
          "126:     }",
          "127:     return FALSE;",
          "128: }",
          "130: static void",
          "131: report_remote_ra_result(remote_ra_cmd_t *cmd)",
          "132: {",
          "133:     lrmd_event_data_t op = { 0, };",
          "135:     op.type = lrmd_event_exec_complete;",
          "136:     op.rsc_id = cmd->rsc_id;",
          "137:     op.op_type = cmd->action;",
          "138:     op.user_data = cmd->userdata;",
          "139:     op.timeout = cmd->timeout;",
          "140:     op.rc = cmd->rc;",
          "141:     op.op_status = cmd->op_status;",
          "142:     if (cmd->params) {",
          "143:         lrmd_key_value_t *tmp;",
          "145:         op.params = g_hash_table_new_full(crm_str_hash,",
          "146:                         g_str_equal, g_hash_destroy_str, g_hash_destroy_str);",
          "147:         for (tmp = cmd->params; tmp; tmp = tmp->next) {",
          "148:             g_hash_table_insert(op.params, strdup(tmp->key), strdup(tmp->value));",
          "149:         }",
          "151:     }",
          "152:     op.call_id = cmd->call_id;",
          "153:     op.remote_nodename = cmd->owner;",
          "155:     lrm_op_callback(&op);",
          "157:     if (op.params) {",
          "158:         g_hash_table_destroy(op.params);",
          "159:     }",
          "160: }",
          "162: static gboolean",
          "163: monitor_timeout_cb(gpointer data)",
          "164: {",
          "165:     lrm_state_t *lrm_state = NULL;",
          "166:     remote_ra_cmd_t *cmd = data;",
          "168:     crm_debug(\"Poke async response timed out for node %s\", cmd->rsc_id);",
          "169:     cmd->monitor_timeout_id = 0;",
          "170:     cmd->op_status = PCMK_LRM_OP_TIMEOUT;",
          "171:     cmd->rc = PCMK_EXECRA_UNKNOWN_ERROR;",
          "173:     lrm_state = lrm_state_find(cmd->rsc_id);",
          "174:     if (lrm_state && lrm_state->remote_ra_data) {",
          "175:         remote_ra_data_t *ra_data = lrm_state->remote_ra_data;",
          "177:         if (ra_data->cur_cmd == cmd) {",
          "178:             ra_data->cur_cmd = NULL;",
          "179:         }",
          "180:         if (ra_data->cmds) {",
          "181:             mainloop_set_trigger(ra_data->work);",
          "182:         }",
          "183:     }",
          "185:     report_remote_ra_result(cmd);",
          "186:     free_cmd(cmd);",
          "187:     return FALSE;",
          "188: }",
          "190: void",
          "191: remote_lrm_op_callback(lrmd_event_data_t * op)",
          "192: {",
          "193:     lrm_state_t *lrm_state = NULL;",
          "194:     remote_ra_data_t *ra_data = NULL;",
          "195:     remote_ra_cmd_t *cmd = NULL;",
          "197:     crm_debug(\"remote connection event - event_type:%s node:%s action:%s rc:%s op_status:%s\",",
          "198:              lrmd_event_type2str(op->type),",
          "199:              op->remote_nodename,",
          "200:              op->op_type ? op->op_type : \"none\",",
          "201:              lrmd_event_rc2str(op->rc),",
          "202:              services_lrm_status_str(op->op_status));",
          "205:     if ((op->type != lrmd_event_connect) && (op->type != lrmd_event_poke)) {",
          "206:         crm_debug(\"not a connection or poke event, pass it up to crmd lrm callback\");",
          "207:         lrm_op_callback(op);",
          "208:         return;",
          "209:     } else if (!op->remote_nodename) {",
          "210:         crm_debug(\"no node name, dropping event.\");",
          "211:         return;",
          "212:     }",
          "214:     lrm_state = lrm_state_find(op->remote_nodename);",
          "215:     if (!lrm_state || !lrm_state->remote_ra_data) {",
          "216:         crm_debug(\"lrm_state info not found for remote lrmd connection event\");",
          "217:         lrm_op_callback(op);",
          "218:         return;",
          "219:     }",
          "221:     ra_data = lrm_state->remote_ra_data;",
          "223:     if (!ra_data->cur_cmd) {",
          "224:         crm_debug(\"no event to match\");",
          "225:         lrm_op_callback(op);",
          "226:         return;",
          "227:     }",
          "229:     cmd = ra_data->cur_cmd;",
          "233:     if (op->type == lrmd_event_connect && (",
          "234:             safe_str_eq(cmd->action, \"start\") ||",
          "235:             safe_str_eq(cmd->action, \"migrate_from\"))) {",
          "237:         if (op->connection_rc == -ETIMEDOUT) {",
          "238:             cmd->op_status = PCMK_LRM_OP_TIMEOUT;",
          "239:             cmd->rc = PCMK_EXECRA_UNKNOWN_ERROR;",
          "240:         } else if (op->connection_rc < 0) {",
          "241:             cmd->rc = PCMK_EXECRA_UNKNOWN_ERROR;",
          "242:             cmd->op_status = PCMK_LRM_OP_ERROR;",
          "243:         } else {",
          "244:             cmd->rc = PCMK_EXECRA_OK;",
          "245:             cmd->op_status = PCMK_LRM_OP_DONE;",
          "246:         }",
          "248:         crm_debug(\"remote lrmd connect event matched %s action. \", cmd->action);",
          "249:         report_remote_ra_result(cmd);",
          "250:         if (ra_data->cmds) {",
          "251:             mainloop_set_trigger(ra_data->work);",
          "252:         }",
          "253:         ra_data->cur_cmd = NULL;",
          "254:         free_cmd(cmd);",
          "255:         return;",
          "256:     } else if (op->type == lrmd_event_poke && safe_str_eq(cmd->action, \"monitor\")) {",
          "258:         if (cmd->monitor_timeout_id) {",
          "259:             g_source_remove(cmd->monitor_timeout_id);",
          "260:             cmd->monitor_timeout_id = 0;",
          "261:         }",
          "266:         if (!cmd->reported_success) {",
          "267:             cmd->rc = PCMK_EXECRA_OK;",
          "268:             cmd->op_status = PCMK_LRM_OP_DONE;",
          "269:             report_remote_ra_result(cmd);",
          "270:             cmd->reported_success = 1;",
          "271:         }",
          "273:         crm_debug(\"remote lrmd poke event matched %s action. \", cmd->action);",
          "276:         if (cmd->interval && (cmd->cancel == FALSE)) {",
          "277:             ra_data->recurring_cmds = g_list_append(ra_data->recurring_cmds, cmd);",
          "278:             cmd->interval_id = g_timeout_add(cmd->interval, recurring_helper, cmd);",
          "280:         }",
          "282:         if (ra_data->cmds) {",
          "283:             mainloop_set_trigger(ra_data->work);",
          "284:         }",
          "285:         ra_data->cur_cmd = NULL;",
          "286:         free_cmd(cmd);",
          "287:         return;",
          "288:     }",
          "290:     crm_debug(\"Event did not match %s action\", ra_data->cur_cmd->action);",
          "291: }",
          "293: static gboolean",
          "294: handle_remote_ra_exec(gpointer user_data)",
          "295: {",
          "296:     int rc = 0;",
          "297:     lrm_state_t *lrm_state = user_data;",
          "298:     remote_ra_data_t *ra_data = lrm_state->remote_ra_data;",
          "299:     remote_ra_cmd_t *cmd;",
          "300:     GList *first = NULL;",
          "301:     if (ra_data->cur_cmd) {",
          "303:         return TRUE;",
          "304:     }",
          "306:     while (ra_data->cmds) {",
          "307:         first = ra_data->cmds;",
          "308:         cmd = first->data;",
          "309:         if (cmd->delay_id) {",
          "311:             return TRUE;",
          "312:         }",
          "314:         ra_data->cmds = g_list_remove_link(ra_data->cmds, first);",
          "315:         g_list_free_1(first);",
          "317:         if (!strcmp(cmd->action, \"start\") || !strcmp(cmd->action, \"migrate_from\")) {",
          "318:             const char *server = NULL;",
          "319:             lrmd_key_value_t *tmp = NULL;",
          "320:             int port = 0;",
          "322:             for (tmp = cmd->params; tmp; tmp = tmp->next) {",
          "323:                 if (safe_str_eq(tmp->key, \"server\")) {",
          "324:                     server = tmp->value;",
          "325:                 }",
          "326:                 if (safe_str_eq(tmp->key, \"port\")) {",
          "327:                     port = atoi(tmp->value);",
          "328:                 }",
          "329:             }",
          "331:             rc = lrm_state_remote_connect_async(lrm_state, server, port, cmd->timeout);",
          "333:             if (rc == 0) {",
          "335:                 crm_debug(\"began remote lrmd connect, waiting for connect event.\");",
          "336:                 ra_data->cur_cmd = cmd;",
          "337:                 return TRUE;",
          "338:             } else {",
          "339:                 crm_debug(\"connect failed, not expecting to match any connection event later\");",
          "340:                 cmd->rc = PCMK_EXECRA_UNKNOWN_ERROR;",
          "341:                 cmd->op_status = PCMK_LRM_OP_ERROR;",
          "342:             }",
          "343:             report_remote_ra_result(cmd);",
          "345:         } else if (!strcmp(cmd->action, \"monitor\")) {",
          "347:             if (lrm_state_is_connected(lrm_state) == TRUE) {",
          "348:                 rc = lrm_state_poke_connection(lrm_state);",
          "349:                 if (rc < 0) {",
          "350:                     cmd->rc = PCMK_EXECRA_UNKNOWN_ERROR;",
          "351:                     cmd->op_status = PCMK_LRM_OP_ERROR;",
          "352:                 }",
          "353:             } else {",
          "354:                 rc = -1;",
          "355:                 cmd->op_status = PCMK_LRM_OP_DONE;",
          "356:                 cmd->rc = PCMK_EXECRA_NOT_RUNNING;",
          "357:             }",
          "359:             if (rc == 0) {",
          "360:                 crm_debug(\"poked remote lrmd at node %s, waiting for async response.\", cmd->rsc_id);",
          "361:                 ra_data->cur_cmd = cmd;",
          "362:                 cmd->monitor_timeout_id = g_timeout_add(cmd->timeout, monitor_timeout_cb, cmd);",
          "363:                 return TRUE;",
          "364:             }",
          "365:             report_remote_ra_result(cmd);",
          "367:         } else if (!strcmp(cmd->action, \"stop\")) {",
          "368:             lrm_state_disconnect(lrm_state);",
          "369:             cmd->rc = PCMK_EXECRA_OK;",
          "370:             cmd->op_status = PCMK_LRM_OP_DONE;",
          "371:             report_remote_ra_result(cmd);",
          "373:         } else if (!strcmp(cmd->action, \"migrate_to\")) {",
          "375:             cmd->rc = PCMK_EXECRA_OK;",
          "376:             cmd->op_status = PCMK_LRM_OP_DONE;",
          "377:             report_remote_ra_result(cmd);",
          "378:         }",
          "380:         free_cmd(cmd);",
          "381:     }",
          "383:     return TRUE;",
          "384: }",
          "386: static void",
          "387: remote_ra_data_init(lrm_state_t *lrm_state)",
          "388: {",
          "389:     remote_ra_data_t *ra_data = NULL;",
          "391:     if (lrm_state->remote_ra_data) {",
          "392:         return;",
          "393:     }",
          "395:     ra_data = calloc(1, sizeof(remote_ra_data_t));",
          "396:     ra_data->work = mainloop_add_trigger(G_PRIORITY_HIGH, handle_remote_ra_exec, lrm_state);",
          "397:     lrm_state->remote_ra_data = ra_data;",
          "398: }",
          "400: void",
          "401: remote_ra_cleanup(lrm_state_t *lrm_state)",
          "402: {",
          "403:     remote_ra_data_t *ra_data = lrm_state->remote_ra_data;",
          "405:     if (!ra_data) {",
          "406:         return;",
          "407:     }",
          "409:     if (ra_data->cmds) {",
          "410:         g_list_free_full(ra_data->cmds, free_cmd);",
          "411:     }",
          "413:     if (ra_data->cmds) {",
          "414:         g_list_free_full(ra_data->recurring_cmds, free_cmd);",
          "415:     }",
          "416:     mainloop_destroy_trigger(ra_data->work);",
          "417:     free(ra_data);",
          "418:     lrm_state->remote_ra_data = NULL;",
          "419: }",
          "421: gboolean",
          "422: is_remote_lrmd_ra(const char *agent, const char *provider, const char *id)",
          "423: {",
          "424:     if (agent && provider && !strcmp(agent, REMOTE_LRMD_RA) && !strcmp(provider, \"pacemaker\")) {",
          "425:         return TRUE;",
          "426:     }",
          "427:     if (id && lrm_state_find(id)) {",
          "428:         return TRUE;",
          "429:     }",
          "431:     return FALSE;",
          "432: }",
          "434: int",
          "435: remote_ra_get_metadata(char **output)",
          "436: {",
          "437: #define remote_metadata  \\",
          "438: \"<?xml version=\\\"1.0\\\"?>\\n\"\\",
          "439: \"<!DOCTYPE resource-agent SYSTEM \\\"ra-api-1.dtd\\\">\\n\"\\",
          "440: \"<resource-agent name=\\\"remote\\\" version=\\\"0.1\\\">\\n\"\\",
          "441: \"  <version>1.0</version>\\n\"\\",
          "442: \"  <parameters>\\n\"\\",
          "443: \"    <parameter name=\\\"server\\\" unique=\\\"1\\\">\\n\"\\",
          "444: \"    <longdesc lang=\\\"en\\\">\\n\"\\",
          "445: \"       Server location to connect to.  This can be an ip address or hostname.\\n\"\\",
          "446: \"    </longdesc>\\n\"\\",
          "447: \"    <shortdesc lang=\\\"en\\\">Server location</shortdesc>\\n\"\\",
          "448: \"    <content type=\\\"string\\\"/>\\n\"\\",
          "449: \"    </parameter>\\n\"\\",
          "450: \"    <parameter name=\\\"port\\\" unique=\\\"1\\\">\\n\"\\",
          "451: \"    <longdesc lang=\\\"en\\\">\\n\"\\",
          "452: \"       tcp port to connect to.\\n\"\\",
          "453: \"    </longdesc>\\n\"\\",
          "454: \"    <shortdesc lang=\\\"en\\\">tcp port</shortdesc>\\n\"\\",
          "455: \"    <content type=\\\"string\\\" default=\\\"1984\\\"/>\\n\"\\",
          "456: \"    </parameter>\\n\"\\",
          "457: \"  </parameters>\\n\"\\",
          "458: \"  <actions>\\n\"\\",
          "459: \"    <action name=\\\"start\\\"   timeout=\\\"15\\\" />\\n\"\\",
          "460: \"    <action name=\\\"stop\\\"    timeout=\\\"15\\\" />\\n\"\\",
          "461: \"    <action name=\\\"monitor\\\"    timeout=\\\"15\\\" />\\n\"\\",
          "462: \"    <action name=\\\"migrate_to\\\"   timeout=\\\"15\\\" />\\n\"\\",
          "463: \"    <action name=\\\"migrate_from\\\" timeout=\\\"15\\\" />\\n\"\\",
          "464: \"    <action name=\\\"meta-data\\\"  timeout=\\\"5\\\" />\\n\"\\",
          "465: \"  </actions>\\n\"\\",
          "466: \"</resource-agent>\\n\"",
          "469:     return 0;",
          "470: }",
          "472: lrmd_rsc_info_t *",
          "473: remote_ra_get_rsc_info(lrm_state_t *lrm_state, const char *rsc_id)",
          "474: {",
          "475:     lrmd_rsc_info_t *info = NULL;",
          "476:     if ((lrm_state_find(rsc_id))) {",
          "477:         info = calloc(1, sizeof(lrmd_rsc_info_t));",
          "479:         info->id = strdup(rsc_id);",
          "480:         info->type = strdup(REMOTE_LRMD_RA);",
          "481:         info->class = strdup(\"ocf\");",
          "482:         info->provider = strdup(\"pacemaker\");",
          "483:     }",
          "485:     return info;",
          "486: }",
          "488: static gboolean",
          "489: is_remote_ra_supported_action(const char *action)",
          "490: {",
          "491:     if (!action) {",
          "492:         return FALSE;",
          "493:     } else if (strcmp(action,\"start\") &&",
          "494:                strcmp(action,\"stop\") &&",
          "495:                strcmp(action,\"migrate_to\") &&",
          "496:                strcmp(action,\"migrate_from\") &&",
          "497:                strcmp(action,\"monitor\")) {",
          "498:         return FALSE;",
          "499:     }",
          "501:     return TRUE;",
          "502: }",
          "504: static GList *",
          "505: remove_cmd(GList *list, const char *action, int interval)",
          "506: {",
          "507:     remote_ra_cmd_t *cmd = NULL;",
          "508:     GListPtr gIter = NULL;",
          "509:     for (gIter = list; gIter != NULL; gIter = gIter->next) {",
          "510:         cmd = gIter->data;",
          "511:         if (cmd->interval == interval && safe_str_eq(cmd->action, action)) {",
          "512:             break;",
          "513:         }",
          "514:         cmd = NULL;",
          "515:     }",
          "516:     if (cmd) {",
          "517:         list = g_list_remove(list, cmd);",
          "518:         free_cmd(cmd);",
          "519:     }",
          "520:     return list;",
          "521: }",
          "523: int remote_ra_cancel(lrm_state_t *lrm_state, const char *rsc_id, const char *action, int interval)",
          "524: {",
          "525:     lrm_state_t *connection_rsc = NULL;",
          "526:     remote_ra_data_t *ra_data = NULL;",
          "528:     connection_rsc = lrm_state_find(rsc_id);",
          "529:     if (!connection_rsc || !connection_rsc->remote_ra_data) {",
          "530:         return -EINVAL;",
          "531:     }",
          "533:     ra_data = connection_rsc->remote_ra_data;",
          "534:     ra_data->cmds = remove_cmd(ra_data->cmds, action, interval);",
          "535:     ra_data->recurring_cmds = remove_cmd(ra_data->cmds, action, interval);",
          "536:     if (ra_data->cur_cmd &&",
          "537:         (ra_data->cur_cmd->interval == interval) &&",
          "538:         (safe_str_eq(ra_data->cur_cmd->action, action))) {",
          "540:         ra_data->cur_cmd->cancel = TRUE;",
          "541:     }",
          "543:     return 0;",
          "544: }",
          "546: int remote_ra_exec(lrm_state_t *lrm_state,",
          "547:     const char *rsc_id,",
          "548:     const char *action,",
          "549:     const char *userdata,",
          "553:     lrmd_key_value_t *params)",
          "554: {",
          "555:     int rc = 0;",
          "556:     lrm_state_t *connection_rsc = NULL;",
          "557:     remote_ra_cmd_t *cmd = NULL;",
          "558:     remote_ra_data_t *ra_data = NULL;",
          "560:     if (is_remote_ra_supported_action(action) == FALSE) {",
          "561:         rc = -EINVAL;",
          "562:         goto exec_done;",
          "563:     }",
          "565:     connection_rsc = lrm_state_find(rsc_id);",
          "566:     if (!connection_rsc) {",
          "567:         rc = -EINVAL;",
          "568:         goto exec_done;",
          "569:     }",
          "571:     remote_ra_data_init(connection_rsc);",
          "573:     cmd = calloc(1, sizeof(remote_ra_cmd_t));",
          "574:     cmd->owner = strdup(lrm_state->node_name);",
          "575:     cmd->rsc_id = strdup(rsc_id);",
          "576:     cmd->action = strdup(action);",
          "577:     cmd->userdata = strdup(userdata);",
          "578:     cmd->interval = interval;",
          "579:     cmd->timeout = timeout;",
          "580:     cmd->start_delay = start_delay;",
          "581:     cmd->params = params;",
          "583:     remote_ra_callid++;",
          "584:     if (remote_ra_callid <=0) {",
          "585:         remote_ra_callid = 1;",
          "586:     }",
          "587:     cmd->call_id = remote_ra_callid;",
          "589:     if (cmd->start_delay) {",
          "590:         cmd->delay_id = g_timeout_add(cmd->start_delay, start_delay_helper, cmd);",
          "591:     }",
          "592:     ra_data = connection_rsc->remote_ra_data;",
          "594:     ra_data->cmds = g_list_append(ra_data->cmds, cmd);",
          "595:     mainloop_set_trigger(ra_data->work);",
          "597:     return cmd->call_id;",
          "598: exec_done:",
          "600:     lrmd_key_value_freeall(params);",
          "601:     return rc;",
          "602: }",
          "",
          "---------------"
        ],
        "include/crm/lrmd.h||include/crm/lrmd.h": [
          "File: include/crm/lrmd.h -> include/crm/lrmd.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "81: #define LRMD_OP_RSC_UNREG         \"lrmd_rsc_unregister\"",
          "82: #define LRMD_OP_RSC_INFO          \"lrmd_rsc_info\"",
          "83: #define LRMD_OP_RSC_METADATA      \"lrmd_rsc_metadata\"",
          "85: #define T_LRMD           \"lrmd\"",
          "86: #define T_LRMD_REPLY     \"lrmd_reply\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "84: #define LRMD_OP_POKE              \"lrmd_rsc_poke\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "150:     lrmd_event_unregister,",
          "151:     lrmd_event_exec_complete,",
          "152:     lrmd_event_disconnect,",
          "153: };",
          "155: enum lrmd_exec_rc {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "154:     lrmd_event_connect,",
          "155:     lrmd_event_poke,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "207:     unsigned int queue_time;",
          "211:     void *params;",
          "215:     const char *remote_nodename;",
          "217: } lrmd_event_data_t;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "213:     int connection_rc;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "237: } lrmd_list_t;",
          "239: void lrmd_list_freeall(lrmd_list_t *head);",
          "241: typedef struct lrmd_api_operations_s",
          "242: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "248: void lrmd_key_value_freeall(lrmd_key_value_t * head);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "249:     int (*connect) (lrmd_t *lrmd, const char *client_name, int *fd);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "270:     int (*connect_async) (lrmd_t *lrmd, const char *client_name, int timeout /*ms */);",
          "278:     int (*is_connected) (lrmd_t *lrmd);",
          "287:     int (*poke_connection) (lrmd_t *lrmd);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "459:         return \"exec_complete\";",
          "460:     case lrmd_event_disconnect:",
          "461:         return \"disconnect\";",
          "462:     }",
          "463:     return \"unknown\";",
          "464: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "500:     case lrmd_event_connect:",
          "501:         return \"connect\";",
          "502:     case lrmd_event_poke:",
          "503:         return \"poke\";",
          "",
          "---------------"
        ],
        "include/crm_internal.h||include/crm_internal.h": [
          "File: include/crm_internal.h -> include/crm_internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "212: gboolean crm_remote_recv(crm_remote_t *remote, int total_timeout /*ms */, int *disconnected);",
          "213: xmlNode *crm_remote_parse_buffer(crm_remote_t *remote);",
          "214: int crm_remote_tcp_connect(const char *host, int port);",
          "216: #ifdef HAVE_GNUTLS_GNUTLS_H",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "215: int crm_remote_tcp_connect_async(const char *host,",
          "216:     int port,",
          "218:     void *userdata,",
          "219:     void (*callback)(void *userdata, int sock));",
          "",
          "---------------"
        ],
        "lib/common/remote.c||lib/common/remote.c": [
          "File: lib/common/remote.c -> lib/common/remote.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: #include <crm/common/ipcs.h>",
          "39: #include <crm/common/xml.h>",
          "41: #ifdef HAVE_GNUTLS_GNUTLS_H",
          "42: #  undef KEYFILE",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40: #include <crm/common/mainloop.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "635:     return FALSE;",
          "636: }",
          "644: int",
          "646: {",
          "647:     struct addrinfo *res;",
          "648:     struct addrinfo *rp;",
          "",
          "[Removed Lines]",
          "645: crm_remote_tcp_connect(const char *host, int port)",
          "",
          "[Added Lines]",
          "639: struct tcp_async_cb_data {",
          "640:     gboolean success;",
          "641:     int sock;",
          "642:     void *userdata;",
          "643:     void (*callback)(void *userdata, int sock);",
          "645:     time_t start;",
          "646: };",
          "648: static gboolean",
          "649: check_connect_finished(gpointer userdata)",
          "650: {",
          "651:     struct tcp_async_cb_data *cb_data = userdata;",
          "652:     int rc = 0;",
          "653:     int sock = cb_data->sock;",
          "654:     int error = 0;",
          "656:     fd_set  rset, wset;",
          "657:     socklen_t len = sizeof(error);",
          "658:     struct timeval  ts = { 0, };",
          "660:     if (cb_data->success == TRUE) {",
          "661:         goto dispatch_done;",
          "662:     }",
          "664:     FD_ZERO(&rset);",
          "665:     FD_SET(sock, &rset);",
          "666:     wset = rset;",
          "668:     crm_trace(\"fd %d: checking to see if connect finished\", sock);",
          "669:     rc = select(sock + 1, &rset, &wset, NULL, &ts);",
          "671:     if (rc < 0) {",
          "672:         rc = errno;",
          "673:         if ((errno == EINPROGRESS) || (errno == EAGAIN)) {",
          "675:             if ((time(NULL) - cb_data->start) < (cb_data->timeout / 1000)) {",
          "676:                 goto reschedule;",
          "677:             } else {",
          "678:                 rc = -ETIMEDOUT;",
          "679:             }",
          "680:         }",
          "681:         crm_trace(\"fd %d: select failed %d connect dispatch \", rc);",
          "682:         goto dispatch_done;",
          "683:     } else if (rc == 0) {",
          "684:         if ((time(NULL) - cb_data->start) < (cb_data->timeout / 1000)) {",
          "685:             goto reschedule;",
          "686:         }",
          "687:         crm_err(\"fd %d: timeout during select\", sock);",
          "688:         rc = -ETIMEDOUT;",
          "689:         goto dispatch_done;",
          "690:     } else {",
          "691:         crm_trace(\"fd %d: select returned success\", sock);",
          "692:         rc = 0;",
          "693:     }",
          "696:     if (FD_ISSET(sock, &rset) || FD_ISSET(sock, &wset)) {",
          "697:         if (getsockopt(sock, SOL_SOCKET, SO_ERROR, &error, &len) < 0) {",
          "698:             crm_trace(\"fd %d: call to getsockopt failed\", sock);",
          "699:             rc = -1;",
          "700:             goto dispatch_done;",
          "701:         }",
          "703:         if (error) {",
          "704:             crm_trace(\"fd %d: error returned from getsockopt: %d\", sock, error);",
          "705:             rc = -1;",
          "706:             goto dispatch_done;",
          "707:         }",
          "708:     } else {",
          "709:         crm_trace(\"neither read nor write set after select\");",
          "710:         rc = -1;",
          "711:         goto dispatch_done;",
          "712:     }",
          "714: dispatch_done:",
          "715:     if (!rc) {",
          "716:         crm_trace(\"fd %d: connected\", sock);",
          "718:         rc = cb_data->sock;",
          "719:         cb_data->sock = 0;",
          "720:     } else {",
          "721:         close(sock);",
          "722:     }",
          "723:     free(cb_data);",
          "725:     if (cb_data->callback) {",
          "726:         cb_data->callback(cb_data->userdata, rc);",
          "727:     }",
          "728:     return FALSE;",
          "730: reschedule:",
          "733:     return TRUE;",
          "734: }",
          "736: static int",
          "737: internal_tcp_connect_async(int sock,",
          "738:     const struct sockaddr *addr,",
          "739:     socklen_t addrlen,",
          "740:     int timeout /* ms */,",
          "741:     void *userdata,",
          "742:     void (*callback)(void *userdata, int sock))",
          "743: {",
          "744:     int rc = 0;",
          "745:     int flag = 0;",
          "746:     int interval;",
          "747:     struct tcp_async_cb_data *cb_data = NULL;",
          "749:     if ((flag = fcntl(sock, F_GETFL)) >= 0) {",
          "750:         if (fcntl(sock, F_SETFL, flag | O_NONBLOCK) < 0) {",
          "751:             crm_err( \"fcntl() write failed\");",
          "752:             return -1;",
          "753:         }",
          "754:     }",
          "756:     rc = connect(sock, addr, addrlen);",
          "758:     if (rc <  0 && (errno != EINPROGRESS) && (errno != EAGAIN)) {",
          "759:         return -1;",
          "760:     }",
          "762:     cb_data = calloc(1, sizeof(struct tcp_async_cb_data));",
          "763:     cb_data->userdata = userdata;",
          "764:     cb_data->callback = callback;",
          "765:     cb_data->sock = sock;",
          "766:     cb_data->timeout = timeout;",
          "767:     cb_data->start = time(NULL);",
          "769:     if (rc == 0) {",
          "774:         cb_data->success = TRUE;",
          "775:         interval = 1;",
          "776:     }",
          "786:     crm_trace(\"fd %d: scheduling to check if connect finished in %dms second\", sock, interval);",
          "787:     g_timeout_add(interval, check_connect_finished, cb_data);",
          "789:     return 0;",
          "790: }",
          "792: static int",
          "793: internal_tcp_connect(int sock,",
          "794:     const struct sockaddr *addr,",
          "795:     socklen_t addrlen)",
          "796: {",
          "797:     int flag = 0;",
          "798:     int rc = connect(sock, addr, addrlen);",
          "800:     if (rc == 0) {",
          "801:        if ((flag = fcntl(sock, F_GETFL)) >= 0) {",
          "802:            if (fcntl(sock, F_SETFL, flag | O_NONBLOCK) < 0) {",
          "803:                crm_err( \"fcntl() write failed\");",
          "804:                return -1;",
          "805:            }",
          "806:         }",
          "807:     }",
          "809:     return rc;",
          "810: }",
          "818: crm_remote_tcp_connect_async(const char *host,",
          "819:     int port,",
          "821:     void *userdata,",
          "822:     void (*callback)(void *userdata, int sock))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "672:     for (rp = res; rp != NULL; rp = rp->ai_next) {",
          "673:         struct sockaddr *addr = rp->ai_addr;",
          "675:         if (!addr) {",
          "676:             continue;",
          "677:         }",
          "",
          "[Removed Lines]",
          "674:         int flag = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "696:             crm_info(\"Attempting to connect to remote server at %s:%d\", inet_ntoa(addr_in->sin_addr), port);",
          "697:         }",
          "707:             }",
          "709:         }",
          "711:         close(sock);",
          "",
          "[Removed Lines]",
          "699:         if (connect(sock, rp->ai_addr, rp->ai_addrlen) == 0) {",
          "700:             if ((flag = fcntl(sock, F_GETFL)) >= 0) {",
          "701:                 if (fcntl(sock, F_SETFL, flag | O_NONBLOCK) < 0) {",
          "702:                     crm_err( \"fcntl() write failed\");",
          "703:                     close(sock);",
          "704:                     sock = -1;",
          "705:                     continue;",
          "706:                 }",
          "",
          "[Added Lines]",
          "875:         if (callback) {",
          "876:             if (internal_tcp_connect_async(sock, rp->ai_addr, rp->ai_addrlen, timeout, userdata, callback) == 0) {",
          "878:             }",
          "880:         } else {",
          "881:             if (internal_tcp_connect(sock, rp->ai_addr, rp->ai_addrlen) == 0) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "716:     return sock;",
          "717: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "894: int",
          "895: crm_remote_tcp_connect(const char *host, int port)",
          "896: {",
          "897:     return crm_remote_tcp_connect_async(host, port, -1, NULL, NULL);",
          "898: }",
          "",
          "---------------"
        ],
        "lib/lrmd/lrmd_client.c||lib/lrmd/lrmd_client.c": [
          "File: lib/lrmd/lrmd_client.c -> lib/lrmd/lrmd_client.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "56: static stonith_t *stonith_api = NULL;",
          "58: static int lrmd_api_disconnect(lrmd_t *lrmd);",
          "61: #ifdef HAVE_GNUTLS_GNUTLS_H",
          "64: gnutls_psk_client_credentials_t psk_cred_s;",
          "65: int lrmd_tls_set_key(gnutls_datum_t *key, const char *location);",
          "",
          "[Removed Lines]",
          "59: static int lrmd_connected(lrmd_t *lrmd);",
          "",
          "[Added Lines]",
          "59: static int lrmd_api_is_connected(lrmd_t *lrmd);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "155:     return head;",
          "156: }",
          "159: lrmd_key_value_freeall(lrmd_key_value_t * head)",
          "160: {",
          "161:     lrmd_key_value_t *p;",
          "",
          "[Removed Lines]",
          "158: static void",
          "",
          "[Added Lines]",
          "157: void",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "265:         event.type = lrmd_event_exec_complete;",
          "267:         event.params = xml2list(msg);",
          "268:     } else {",
          "269:         return 1;",
          "270:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "267:     } else if (crm_str_eq(type, LRMD_OP_POKE, TRUE)) {",
          "268:         event.type = lrmd_event_poke;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "423:             crm_err(\"Unsupported connection type: %d\", private->type);",
          "424:     }",
          "427:         crm_err(\"Connection closed\");",
          "428:         return FALSE;",
          "429:     }",
          "",
          "[Removed Lines]",
          "426:     if (lrmd_connected(lrmd) == FALSE) {",
          "",
          "[Added Lines]",
          "427:     if (lrmd_api_is_connected(lrmd) == FALSE) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "469:     if (native->callback) {",
          "470:         lrmd_event_data_t event = { 0, };",
          "471:         event.type = lrmd_event_disconnect;",
          "472:         native->callback(&event);",
          "473:     }",
          "474: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "473:         event.remote_nodename = native->remote_nodename;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "547:     int reply_id = 0;",
          "548:     int remaining_timeout = 0;",
          "551:         total_timeout = 10000;",
          "554:     }",
          "556:     while (!xml) {",
          "",
          "[Removed Lines]",
          "550:     if (total_timeout == 0) {",
          "552:     } else if (total_timeout == -1) {",
          "553:         total_timeout = 30000;",
          "",
          "[Added Lines]",
          "554:     if (total_timeout <= 0) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "612: }",
          "614: static int",
          "616: {",
          "617:     int rc = 0;",
          "620:     lrmd_private_t *native = lrmd->private;",
          "626:     global_remote_msg_id++;",
          "627:     if (global_remote_msg_id <= 0) {",
          "628:         global_remote_msg_id = 1;",
          "",
          "[Removed Lines]",
          "615: lrmd_tls_send_recv(lrmd_t *lrmd, xmlNode *msg, int timeout, xmlNode **reply)",
          "618:     int disconnected = 0;",
          "619:     xmlNode *xml = NULL;",
          "622:     if (lrmd_tls_connected(lrmd) == FALSE) {",
          "623:         return -1;",
          "624:     }",
          "",
          "[Added Lines]",
          "617: lrmd_tls_send(lrmd_t *lrmd, xmlNode *msg)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "634:         lrmd_tls_disconnect(lrmd);",
          "635:         return -ENOTCONN;",
          "636:     }",
          "638:     xml = lrmd_tls_recv_reply(lrmd, timeout, global_remote_msg_id, &disconnected);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "632:     return pcmk_ok;",
          "633: }",
          "635: static int",
          "636: lrmd_tls_send_recv(lrmd_t *lrmd, xmlNode *msg, int timeout, xmlNode **reply)",
          "637: {",
          "638:     int rc = 0;",
          "639:     int disconnected = 0;",
          "640:     xmlNode *xml = NULL;",
          "642:     if (lrmd_tls_connected(lrmd) == FALSE) {",
          "643:         return -1;",
          "644:     }",
          "646:     rc = lrmd_tls_send(lrmd, msg);",
          "647:     if (rc < 0) {",
          "648:         return rc;",
          "649:     }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "679: }",
          "681: static int",
          "683: {",
          "684:     lrmd_private_t *native = lrmd->private;",
          "",
          "[Removed Lines]",
          "682: lrmd_connected(lrmd_t *lrmd)",
          "",
          "[Added Lines]",
          "695: lrmd_send_xml_no_reply(lrmd_t *lrmd, xmlNode *msg)",
          "696: {",
          "697:     int rc = -1;",
          "698:     lrmd_private_t *native = lrmd->private;",
          "700:     switch (native->type) {",
          "701:     case CRM_CLIENT_IPC:",
          "702:         rc = crm_ipc_send(native->ipc, msg, crm_ipc_client_none, 0, NULL);",
          "703:         break;",
          "704:     case CRM_CLIENT_TLS:",
          "705: #ifdef HAVE_GNUTLS_GNUTLS_H",
          "706:         rc = lrmd_tls_send(lrmd, msg);",
          "707: #endif",
          "708:         break;",
          "709:     default:",
          "710:         crm_err(\"Unsupported connection type: %d\", native->type);",
          "711:     }",
          "713:     return rc;",
          "714: }",
          "716: static int",
          "717: lrmd_api_is_connected(lrmd_t *lrmd)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "700: }",
          "702: static int",
          "705: {",
          "706:     int rc = pcmk_ok;",
          "707:     int reply_id = -1;",
          "",
          "[Removed Lines]",
          "704:                   enum lrmd_call_options options)",
          "",
          "[Added Lines]",
          "738: lrmd_send_command(lrmd_t * lrmd,",
          "739:                   const char *op,",
          "740:                   xmlNode * data,",
          "741:                   xmlNode ** output_data,",
          "743:                   enum lrmd_call_options options,",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "709:     xmlNode *op_msg = NULL;",
          "710:     xmlNode *op_reply = NULL;",
          "713:         return -ENOTCONN;",
          "714:     }",
          "",
          "[Removed Lines]",
          "712:     if (!lrmd_connected(lrmd)) {",
          "",
          "[Added Lines]",
          "752:     if (!lrmd_api_is_connected(lrmd)) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "730:     crm_xml_add_int(op_msg, F_LRMD_TIMEOUT, timeout);",
          "735:     if (rc < 0) {",
          "736:         crm_perror(LOG_ERR, \"Couldn't perform %s operation (timeout=%d): %d\", op, timeout, rc);",
          "",
          "[Removed Lines]",
          "732:     rc = lrmd_send_xml(lrmd, op_msg, timeout, &op_reply);",
          "733:     free_xml(op_msg);",
          "",
          "[Added Lines]",
          "772:     if (expect_reply) {",
          "773:         rc = lrmd_send_xml(lrmd, op_msg, timeout, &op_reply);",
          "774:     } else {",
          "775:         rc = lrmd_send_xml_no_reply(lrmd, op_msg);",
          "776:         goto done;",
          "777:     }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "754:     }",
          "756:   done:",
          "758:         crm_err(\"LRMD disconnected\");",
          "759:     }",
          "761:     free_xml(op_reply);",
          "762:     return rc;",
          "763: }",
          "765: static int",
          "766: lrmd_handshake(lrmd_t *lrmd, const char *name)",
          "767: {",
          "",
          "[Removed Lines]",
          "757:     if (lrmd_connected(lrmd) == FALSE) {",
          "",
          "[Added Lines]",
          "801:     if (lrmd_api_is_connected(lrmd) == FALSE) {",
          "805:     free_xml(op_msg);",
          "810: static int",
          "811: lrmd_api_poke_connection(lrmd_t *lrmd)",
          "812: {",
          "813:     int rc;",
          "814:     xmlNode *data = create_xml_node(NULL, F_LRMD_RSC);",
          "816:     crm_xml_add(data, F_LRMD_ORIGIN, __FUNCTION__);",
          "817:     rc = lrmd_send_command(lrmd, LRMD_OP_POKE, data, NULL, 0, 0, FALSE);",
          "818:     free_xml(data);",
          "820:     return rc;",
          "821: }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "804:     free_xml(reply);",
          "805:     free_xml(hello);",
          "807:     return rc;",
          "808: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "865:     if (rc != pcmk_ok) {",
          "866:         lrmd_api_disconnect(lrmd);",
          "867:     }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "931: }",
          "932: #endif",
          "934: static int",
          "935: lrmd_tls_connect(lrmd_t *lrmd, int *fd)",
          "936: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "995: static void",
          "996: lrmd_gnutls_global_init(void)",
          "997: {",
          "998:     static int gnutls_init = 0;",
          "1000:     if (!gnutls_init) {",
          "1001:         gnutls_global_init();",
          "1002:     }",
          "1003:     gnutls_init = 1;",
          "1004: }",
          "1006: static void",
          "1007: report_async_connection_result(lrmd_t *lrmd, int rc)",
          "1008: {",
          "1009:     lrmd_private_t *native = lrmd->private;",
          "1010:     if (native->callback) {",
          "1011:         lrmd_event_data_t event = { 0, };",
          "1012:         event.type = lrmd_event_connect;",
          "1013:         event.remote_nodename = native->remote_nodename;",
          "1014:         event.connection_rc = rc;",
          "1015:         native->callback(&event);",
          "1016:     }",
          "1017: }",
          "1019: #ifdef HAVE_GNUTLS_GNUTLS_H",
          "1020: static void",
          "1021: lrmd_tcp_connect_cb(void *userdata, int sock)",
          "1022: {",
          "1023:     lrmd_t *lrmd = userdata;",
          "1024:     lrmd_private_t *native = lrmd->private;",
          "1025:     char name[256] = { 0, };",
          "1026:     static struct mainloop_fd_callbacks lrmd_tls_callbacks =",
          "1027:         {",
          "1028:             .dispatch = lrmd_tls_dispatch,",
          "1029:             .destroy = lrmd_tls_connection_destroy,",
          "1030:         };",
          "1031:     int rc = sock;",
          "1033:     if (rc < 0) {",
          "1034:         lrmd_tls_connection_destroy(lrmd);",
          "1035:         crm_info(\"remote lrmd connect to %s at port %d failed\", native->server, native->port);",
          "1036:         report_async_connection_result(lrmd, rc);",
          "1037:         return;",
          "1038:     }",
          "1042:     native->sock = sock;",
          "1043:     gnutls_psk_allocate_client_credentials(&native->psk_cred_c);",
          "1044:     gnutls_psk_set_client_credentials_function(native->psk_cred_c, lrmd_tls_key_cb);",
          "1045:     native->remote->tls_session = create_psk_tls_session(sock, GNUTLS_CLIENT, native->psk_cred_c);",
          "1047:     if (crm_initiate_client_tls_handshake(native->remote, LRMD_CLIENT_HANDSHAKE_TIMEOUT) != 0) {",
          "1048:         crm_warn(\"Client tls handshake failed for server %s:%d. Disconnecting\", native->server, native->port);",
          "1049:         gnutls_deinit(*native->remote->tls_session);",
          "1050:         gnutls_free(native->remote->tls_session);",
          "1051:         native->remote->tls_session = NULL;",
          "1052:         lrmd_tls_connection_destroy(lrmd);",
          "1053:         report_async_connection_result(lrmd, -1);",
          "1054:         return;",
          "1055:     }",
          "1057:     crm_info(\"Remote lrmd client TLS connection established with server %s:%d\", native->server, native->port);",
          "1059:     snprintf(name, 128, \"remote-lrmd-%s:%d\", native->server, native->port);",
          "1061:     native->process_notify = mainloop_add_trigger(G_PRIORITY_HIGH, lrmd_tls_dispatch, lrmd);",
          "1062:     native->source = mainloop_add_fd(name, G_PRIORITY_HIGH, native->sock, lrmd, &lrmd_tls_callbacks);",
          "1064:     rc = lrmd_handshake(lrmd, name);",
          "1065:     report_async_connection_result(lrmd, rc);",
          "1067:     return;",
          "1068: }",
          "1069: #endif",
          "1071: static int",
          "1072: lrmd_tls_connect_async(lrmd_t *lrmd, int timeout /*ms*/)",
          "1073: {",
          "1074: #ifdef HAVE_GNUTLS_GNUTLS_H",
          "1075:     int rc = 0;",
          "1076:     lrmd_private_t *native = lrmd->private;",
          "1078:     lrmd_gnutls_global_init();",
          "1080:     rc = crm_remote_tcp_connect_async(native->server, native->port, timeout, lrmd, lrmd_tcp_connect_cb);",
          "1082:     return rc;",
          "1083: #else",
          "1084:     crm_err(\"TLS not enabled for this build.\");",
          "1085:     return -ENOTCONN;",
          "1086: #endif",
          "1087: }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "942:         };",
          "944:     lrmd_private_t *native = lrmd->private;",
          "946:     int sock;",
          "954:     sock = crm_remote_tcp_connect(native->server, native->port);",
          "955:     if (sock <= 0) {",
          "956:         crm_warn(\"Could not establish remote lrmd connection to %s\", native->server);",
          "",
          "[Removed Lines]",
          "945:     static int gnutls_init = 0;",
          "948:     if (!gnutls_init) {",
          "949:         gnutls_global_init();",
          "950:     }",
          "952:     gnutls_psk_allocate_client_credentials(&native->psk_cred_c);",
          "953:     gnutls_psk_set_client_credentials_function(native->psk_cred_c, lrmd_tls_key_cb);",
          "",
          "[Added Lines]",
          "1102:     lrmd_gnutls_global_init();",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "959:     }",
          "961:     native->sock = sock;",
          "962:     native->remote->tls_session = create_psk_tls_session(sock, GNUTLS_CLIENT, native->psk_cred_c);",
          "964:     if (crm_initiate_client_tls_handshake(native->remote, LRMD_CLIENT_HANDSHAKE_TIMEOUT) != 0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1112:     gnutls_psk_allocate_client_credentials(&native->psk_cred_c);",
          "1113:     gnutls_psk_set_client_credentials_function(native->psk_cred_c, lrmd_tls_key_cb);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1011:         rc = lrmd_handshake(lrmd, name);",
          "1012:     }",
          "1016:     }",
          "1018:     return rc;",
          "",
          "[Removed Lines]",
          "1014:     if (rc != pcmk_ok) {",
          "1015:         lrmd_api_disconnect(lrmd);",
          "",
          "[Added Lines]",
          "1166:     return rc;",
          "1167: }",
          "1169: static int",
          "1170: lrmd_api_connect_async(lrmd_t * lrmd, const char *name, int timeout)",
          "1171: {",
          "1172:     int rc = 0;",
          "1173:     lrmd_private_t *native = lrmd->private;",
          "1175:     if (!native->callback) {",
          "1176:         crm_err(\"Async connect not possible, no lrmd client callback set.\");",
          "1177:         return -1;",
          "1178:     }",
          "1180:     switch (native->type) {",
          "1181:     case CRM_CLIENT_IPC:",
          "1184:         rc = lrmd_api_connect(lrmd, name, NULL);",
          "1185:         if (!rc) {",
          "1186:             report_async_connection_result(lrmd, rc);",
          "1187:         }",
          "1188:         break;",
          "1189:     case CRM_CLIENT_TLS:",
          "1190:         rc = lrmd_tls_connect_async(lrmd, timeout);",
          "1191:         if (rc) {",
          "1193:             report_async_connection_result(lrmd, rc);",
          "1194:         }",
          "1195:         break;",
          "1196:     default:",
          "1197:         crm_err(\"Unsupported connection type: %d\", native->type);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1113:     crm_xml_add(data, F_LRMD_CLASS, class);",
          "1114:     crm_xml_add(data, F_LRMD_PROVIDER, provider);",
          "1115:     crm_xml_add(data, F_LRMD_TYPE, type);",
          "1117:     free_xml(data);",
          "1119:     return rc;",
          "",
          "[Removed Lines]",
          "1116:     rc = lrmd_send_command(lrmd, LRMD_OP_RSC_REG, data, NULL, 0, options);",
          "",
          "[Added Lines]",
          "1298:     rc = lrmd_send_command(lrmd, LRMD_OP_RSC_REG, data, NULL, 0, options, TRUE);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1128:     crm_xml_add(data, F_LRMD_ORIGIN, __FUNCTION__);",
          "1129:     crm_xml_add(data, F_LRMD_RSC_ID, rsc_id);",
          "1131:     free_xml(data);",
          "1133:     return rc;",
          "",
          "[Removed Lines]",
          "1130:     rc = lrmd_send_command(lrmd, LRMD_OP_RSC_UNREG, data, NULL, 0, options);",
          "",
          "[Added Lines]",
          "1312:     rc = lrmd_send_command(lrmd, LRMD_OP_RSC_UNREG, data, NULL, 0, options, TRUE);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1176:     crm_xml_add(data, F_LRMD_ORIGIN, __FUNCTION__);",
          "1177:     crm_xml_add(data, F_LRMD_RSC_ID, rsc_id);",
          "1179:     free_xml(data);",
          "1181:     if (!output) {",
          "",
          "[Removed Lines]",
          "1178:     lrmd_send_command(lrmd, LRMD_OP_RSC_INFO, data, &output, 0, options);",
          "",
          "[Added Lines]",
          "1360:     lrmd_send_command(lrmd, LRMD_OP_RSC_INFO, data, &output, 0, options, TRUE);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1447:         hash2field((gpointer) tmp->key, (gpointer) tmp->value, args);",
          "1448:     }",
          "1451:     free_xml(data);",
          "1453:     lrmd_key_value_freeall(params);",
          "",
          "[Removed Lines]",
          "1450:     rc = lrmd_send_command(lrmd, LRMD_OP_RSC_EXEC, data, NULL, timeout, options);",
          "",
          "[Added Lines]",
          "1632:     rc = lrmd_send_command(lrmd, LRMD_OP_RSC_EXEC, data, NULL, timeout, options, TRUE);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1464:     crm_xml_add(data, F_LRMD_RSC_ACTION, action);",
          "1465:     crm_xml_add(data, F_LRMD_RSC_ID, rsc_id);",
          "1466:     crm_xml_add_int(data, F_LRMD_RSC_INTERVAL, interval);",
          "1468:     free_xml(data);",
          "1469:     return rc;",
          "1470: }",
          "",
          "[Removed Lines]",
          "1467:     rc = lrmd_send_command(lrmd, LRMD_OP_RSC_CANCEL, data, NULL, 0, 0);",
          "",
          "[Added Lines]",
          "1649:     rc = lrmd_send_command(lrmd, LRMD_OP_RSC_CANCEL, data, NULL, 0, 0, TRUE);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1598:     new_lrmd->private = pvt;",
          "1600:     new_lrmd->cmds->connect = lrmd_api_connect;",
          "1601:     new_lrmd->cmds->disconnect = lrmd_api_disconnect;",
          "1602:     new_lrmd->cmds->register_rsc = lrmd_api_register_rsc;",
          "1603:     new_lrmd->cmds->unregister_rsc = lrmd_api_unregister_rsc;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1783:     new_lrmd->cmds->connect_async = lrmd_api_connect_async;",
          "1784:     new_lrmd->cmds->is_connected = lrmd_api_is_connected;",
          "1785:     new_lrmd->cmds->poke_connection = lrmd_api_poke_connection;",
          "",
          "---------------"
        ],
        "lrmd/lrmd.c||lrmd/lrmd.c": [
          "File: lrmd/lrmd.c -> lrmd/lrmd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1198:     } else if (crm_str_eq(op, LRMD_OP_RSC_CANCEL, TRUE)) {",
          "1199:         rc = process_lrmd_rsc_cancel(client, id, request);",
          "1200:         do_reply = 1;",
          "1201:     } else {",
          "1202:         rc = -EOPNOTSUPP;",
          "1203:         do_reply = 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1201:     } else if (crm_str_eq(op, LRMD_OP_POKE, TRUE)) {",
          "1202:         do_notify = 1;",
          "",
          "---------------"
        ],
        "lrmd/test.c||lrmd/test.c": [
          "File: lrmd/test.c -> lrmd/test.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "64: static int exec_call_id = 0;",
          "65: static int exec_call_opts = 0;",
          "66: extern void cleanup_alloc_calculations(pe_working_set_t * data_set);",
          "68: static struct {",
          "69:     int verbose;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "67: static gboolean start_test(gpointer user_data);",
          "68: static void try_connect(void);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "154:     return FALSE;",
          "155: }",
          "157: static void",
          "158: try_connect(void)",
          "159: {",
          "160:     int tries = 10;",
          "162:     int rc = 0;",
          "167:         if (!rc) {",
          "172:         }",
          "173:         sleep(1);",
          "174:     }",
          "",
          "[Removed Lines]",
          "161:     int i = 0;",
          "164:     for (i = 0; i < tries; i++) {",
          "165:         rc = lrmd_conn->cmds->connect(lrmd_conn, \"lrmd\", NULL);",
          "168:             crm_info(\"lrmd client connection established\");",
          "169:             return;",
          "170:         } else {",
          "171:             crm_info(\"lrmd client connection failed\");",
          "",
          "[Added Lines]",
          "159: static void",
          "160: connection_events(lrmd_event_data_t * event)",
          "161: {",
          "162:     int rc = event->connection_rc;",
          "164:     if (event->type != lrmd_event_connect) {",
          "166:         return;",
          "167:     }",
          "169:     if (!rc) {",
          "170:         crm_info(\"lrmd client connection established\");",
          "171:         start_test(NULL);",
          "172:         return;",
          "173:     } else {",
          "174:         sleep(1);",
          "175:         try_connect();",
          "176:         crm_notice(\"lrmd client connection failed\");",
          "177:     }",
          "178: }",
          "184:     static int num_tries = 0;",
          "187:     lrmd_conn->cmds->set_callback(lrmd_conn, connection_events);",
          "188:     for (; num_tries < tries; num_tries++) {",
          "189:         rc = lrmd_conn->cmds->connect_async(lrmd_conn, \"lrmd\", 3000);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "183:     int rc = 0;",
          "185:     if (!options.no_connect) {",
          "187:     }",
          "188:     lrmd_conn->cmds->set_callback(lrmd_conn, read_events);",
          "",
          "[Removed Lines]",
          "186:         try_connect();",
          "",
          "[Added Lines]",
          "207:         if (!lrmd_conn->cmds->is_connected(lrmd_conn)) {",
          "208:             try_connect();",
          "210:             return 0;",
          "211:         }",
          "",
          "---------------"
        ],
        "lrmd/tls_backend.c||lrmd/tls_backend.c": [
          "File: lrmd/tls_backend.c -> lrmd/tls_backend.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "35: #include <arpa/inet.h>",
          "37: #ifdef HAVE_GNUTLS_GNUTLS_H",
          "39: gnutls_psk_server_credentials_t psk_cred_s;",
          "40: gnutls_dh_params_t dh_params;",
          "41: static int ssock = 0;",
          "",
          "[Removed Lines]",
          "38: #define LRMD_REMOTE_AUTH_TIMEOUT 3000",
          "",
          "[Added Lines]",
          "38: #define LRMD_REMOTE_AUTH_TIMEOUT 10000",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7b807b634755a117b1482fb2e5ca387b95dd9092",
      "candidate_info": {
        "commit_hash": "7b807b634755a117b1482fb2e5ca387b95dd9092",
        "repo": "ClusterLabs/pacemaker",
        "commit_url": "https://github.com/ClusterLabs/pacemaker/commit/7b807b634755a117b1482fb2e5ca387b95dd9092",
        "files": [
          "cib/remote.c",
          "lib/cib/cib_remote.c"
        ],
        "message": "Low: cib: Resolve coverity RESOURCE_LEAK in error path",
        "before_after_code_files": [
          "cib/remote.c||cib/remote.c",
          "lib/cib/cib_remote.c||lib/cib/cib_remote.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "cib/remote.c||cib/remote.c",
            "lib/cib/cib_remote.c||lib/cib/cib_remote.c"
          ],
          "candidate": [
            "cib/remote.c||cib/remote.c",
            "lib/cib/cib_remote.c||lib/cib/cib_remote.c"
          ]
        }
      },
      "candidate_diff": {
        "cib/remote.c||cib/remote.c": [
          "File: cib/remote.c -> cib/remote.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "142:     saddr.sin_port = htons(port);",
          "143:     if (bind(ssock, (struct sockaddr *)&saddr, sizeof(saddr)) == -1) {",
          "144:         crm_perror(LOG_ERR, \"Can not bind server socket.\" ERROR_SUFFIX);",
          "145:         return -2;",
          "146:     }",
          "147:     if (listen(ssock, 10) == -1) {",
          "148:         crm_perror(LOG_ERR, \"Can not start listen.\" ERROR_SUFFIX);",
          "149:         return -3;",
          "150:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "145:         close(ssock);",
          "150:         close(ssock);",
          "",
          "---------------"
        ],
        "lib/cib/cib_remote.c||lib/cib/cib_remote.c": [
          "File: lib/cib/cib_remote.c -> lib/cib/cib_remote.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "222:     ret_ga = getaddrinfo(server, NULL, &hints, &res);",
          "223:     if (ret_ga) {",
          "224:         crm_err(\"getaddrinfo: %s\", gai_strerror(ret_ga));",
          "225:         return -1;",
          "226:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "225:         close(sock);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d313c51f7aeb44864647294980c00a64d4b949ab",
      "candidate_info": {
        "commit_hash": "d313c51f7aeb44864647294980c00a64d4b949ab",
        "repo": "ClusterLabs/pacemaker",
        "commit_url": "https://github.com/ClusterLabs/pacemaker/commit/d313c51f7aeb44864647294980c00a64d4b949ab",
        "files": [
          "cib/remote.c",
          "include/crm/common/ipcs.h",
          "include/crm_internal.h",
          "lib/cib/cib_remote.c",
          "lib/common/remote.c",
          "lrmd/tls_backend.c"
        ],
        "message": "Fix: TLS: Remove references to long since deprecated types",
        "before_after_code_files": [
          "cib/remote.c||cib/remote.c",
          "include/crm/common/ipcs.h||include/crm/common/ipcs.h",
          "include/crm_internal.h||include/crm_internal.h",
          "lib/cib/cib_remote.c||lib/cib/cib_remote.c",
          "lib/common/remote.c||lib/common/remote.c",
          "lrmd/tls_backend.c||lrmd/tls_backend.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "cib/remote.c||cib/remote.c",
            "include/crm_internal.h||include/crm_internal.h",
            "lib/cib/cib_remote.c||lib/cib/cib_remote.c",
            "lib/common/remote.c||lib/common/remote.c"
          ],
          "candidate": [
            "cib/remote.c||cib/remote.c",
            "include/crm_internal.h||include/crm_internal.h",
            "lib/cib/cib_remote.c||lib/cib/cib_remote.c",
            "lib/common/remote.c||lib/common/remote.c"
          ]
        }
      },
      "candidate_diff": {
        "cib/remote.c||cib/remote.c": [
          "File: cib/remote.c -> cib/remote.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "70: #ifdef HAVE_GNUTLS_GNUTLS_H",
          "71: #  define DH_BITS 1024",
          "74: static void",
          "75: debug_log(int level, const char *str)",
          "76: {",
          "",
          "[Removed Lines]",
          "72: gnutls_dh_params dh_params;",
          "73: gnutls_anon_server_credentials anon_cred_s;",
          "",
          "[Added Lines]",
          "72: gnutls_dh_params_t dh_params;",
          "73: gnutls_anon_server_credentials_t anon_cred_s;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "99:     int *ssock = NULL;",
          "100:     struct sockaddr_in saddr;",
          "101:     int optval;",
          "103:         {",
          "104:             .dispatch = cib_remote_listen,",
          "105:             .destroy = remote_connection_destroy,",
          "",
          "[Removed Lines]",
          "102:     static struct mainloop_fd_callbacks remote_listen_fd_callbacks =",
          "",
          "[Added Lines]",
          "102:     static struct mainloop_fd_callbacks remote_listen_fd_callbacks =",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "286:     crm_client_t *new_client = NULL;",
          "289:         {",
          "290:             .dispatch = cib_remote_msg,",
          "291:             .destroy = cib_remote_connection_destroy,",
          "",
          "[Removed Lines]",
          "288:     static struct mainloop_fd_callbacks remote_client_fd_callbacks =",
          "",
          "[Added Lines]",
          "288:     static struct mainloop_fd_callbacks remote_client_fd_callbacks =",
          "",
          "---------------"
        ],
        "include/crm/common/ipcs.h||include/crm/common/ipcs.h": [
          "File: include/crm/common/ipcs.h -> include/crm/common/ipcs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "52:         int tcp_socket;",
          "54: #ifdef HAVE_GNUTLS_GNUTLS_H",
          "56:         bool tls_handshake_complete;",
          "57: #endif",
          "58: };",
          "",
          "[Removed Lines]",
          "55:         gnutls_session *tls_session;",
          "",
          "[Added Lines]",
          "55:         gnutls_session_t *tls_session;",
          "",
          "---------------"
        ],
        "include/crm_internal.h||include/crm_internal.h": [
          "File: include/crm_internal.h -> include/crm_internal.h"
        ],
        "lib/cib/cib_remote.c||lib/cib/cib_remote.c": [
          "File: lib/cib/cib_remote.c -> lib/cib/cib_remote.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: #ifdef HAVE_GNUTLS_GNUTLS_H",
          "39: #  undef KEYFILE",
          "40: #  include <gnutls/gnutls.h>",
          "44: const int kx_prio[] = {",
          "",
          "[Removed Lines]",
          "41: gnutls_anon_client_credentials anon_cred_c;",
          "",
          "[Added Lines]",
          "41: gnutls_anon_client_credentials_t anon_cred_c;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "49: static gboolean remote_gnutls_credentials_init = FALSE;",
          "50: #else",
          "52: #endif",
          "54: #include <arpa/inet.h>",
          "",
          "[Removed Lines]",
          "51: typedef void gnutls_session;",
          "",
          "[Added Lines]",
          "51: typedef void gnutls_session_t;",
          "",
          "---------------"
        ],
        "lib/common/remote.c||lib/common/remote.c": [
          "File: lib/common/remote.c -> lib/common/remote.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "86: void *",
          "87: crm_create_anon_tls_session(int csock, int type /* GNUTLS_SERVER, GNUTLS_CLIENT */, void *credentials)",
          "88: {",
          "91:     gnutls_init(session, type);",
          "92: #  ifdef HAVE_GNUTLS_PRIORITY_SET_DIRECT",
          "",
          "[Removed Lines]",
          "89:     gnutls_session *session = gnutls_malloc(sizeof(gnutls_session));",
          "",
          "[Added Lines]",
          "89:     gnutls_session_t *session = gnutls_malloc(sizeof(gnutls_session_t));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "97:     gnutls_set_default_priority(*session);",
          "98:     gnutls_kx_set_priority(*session, anon_tls_kx_order);",
          "99: #  endif",
          "101:     switch (type) {",
          "102:     case GNUTLS_SERVER:",
          "103:         gnutls_credentials_set(*session, GNUTLS_CRD_ANON, (gnutls_anon_server_credentials_t) credentials);",
          "",
          "[Removed Lines]",
          "100:     gnutls_transport_set_ptr(*session, (gnutls_transport_ptr) GINT_TO_POINTER(csock));",
          "",
          "[Added Lines]",
          "100:     gnutls_transport_set_ptr(*session, (gnutls_transport_ptr_t) GINT_TO_POINTER(csock));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "113: void *",
          "114: create_psk_tls_session(int csock, int type /* GNUTLS_SERVER, GNUTLS_CLIENT */, void *credentials)",
          "115: {",
          "118:     gnutls_init(session, type);",
          "119: #  ifdef HAVE_GNUTLS_PRIORITY_SET_DIRECT",
          "",
          "[Removed Lines]",
          "116:     gnutls_session *session = gnutls_malloc(sizeof(gnutls_session));",
          "",
          "[Added Lines]",
          "116:     gnutls_session_t *session = gnutls_malloc(sizeof(gnutls_session_t));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "122:     gnutls_set_default_priority(*session);",
          "123:     gnutls_kx_set_priority(*session, psk_tls_kx_order);",
          "124: #  endif",
          "126:     switch (type) {",
          "127:     case GNUTLS_SERVER:",
          "128:         gnutls_credentials_set(*session, GNUTLS_CRD_PSK, (gnutls_psk_server_credentials_t) credentials);",
          "",
          "[Removed Lines]",
          "125:     gnutls_transport_set_ptr(*session, (gnutls_transport_ptr) GINT_TO_POINTER(csock));",
          "",
          "[Added Lines]",
          "125:     gnutls_transport_set_ptr(*session, (gnutls_transport_ptr_t) GINT_TO_POINTER(csock));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "139: static int",
          "141: {",
          "142:     const char *unsent = buf;",
          "143:     int rc = 0;",
          "",
          "[Removed Lines]",
          "140: crm_send_tls(gnutls_session * session, const char *buf, size_t len)",
          "",
          "[Added Lines]",
          "140: crm_send_tls(gnutls_session_t * session, const char *buf, size_t len)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "190: static char *",
          "192: {",
          "193:     char *buf = NULL;",
          "194:     int rc = 0;",
          "",
          "[Removed Lines]",
          "191: crm_recv_tls(gnutls_session * session, size_t max_size, size_t *recv_len, int *disconnected)",
          "",
          "[Added Lines]",
          "191: crm_recv_tls(gnutls_session_t * session, size_t max_size, size_t *recv_len, int *disconnected)",
          "",
          "---------------"
        ],
        "lrmd/tls_backend.c||lrmd/tls_backend.c": [
          "File: lrmd/tls_backend.c -> lrmd/tls_backend.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "184:     int flag = 0;",
          "185:     unsigned laddr;",
          "186:     struct sockaddr_in addr;",
          "188:     crm_client_t *new_client = NULL;",
          "190:     static struct mainloop_fd_callbacks lrmd_remote_fd_cb =",
          "",
          "[Removed Lines]",
          "187:     gnutls_session *session = NULL;",
          "",
          "[Added Lines]",
          "187:     gnutls_session_t *session = NULL;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
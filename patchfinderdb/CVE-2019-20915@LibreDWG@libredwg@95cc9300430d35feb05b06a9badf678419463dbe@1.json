{
  "cve_id": "CVE-2019-20915",
  "cve_desc": "An issue was discovered in GNU LibreDWG through 0.9.3. Crafted input will lead to a heap-based buffer over-read in bit_write_TF in bits.c.",
  "repo": "LibreDWG/libredwg",
  "patch_hash": "95cc9300430d35feb05b06a9badf678419463dbe",
  "patch_info": {
    "commit_hash": "95cc9300430d35feb05b06a9badf678419463dbe",
    "repo": "LibreDWG/libredwg",
    "commit_url": "https://github.com/LibreDWG/libredwg/commit/95cc9300430d35feb05b06a9badf678419463dbe",
    "files": [
      "src/bits.c"
    ],
    "message": "encode: protect from stack under-flow\n\nFrom GH #178 fuzzing",
    "before_after_code_files": [
      "src/bits.c||src/bits.c"
    ]
  },
  "patch_diff": {
    "src/bits.c||src/bits.c": [
      "File: src/bits.c -> src/bits.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "883:     if (byte[i] & 0x7f)",
      "884:       break;",
      "887:     i--;",
      "888:   byte[i] &= 0x7f;",
      "889:   if (negative)",
      "",
      "[Removed Lines]",
      "886:   if (byte[i] & 0x40)",
      "",
      "[Added Lines]",
      "886:   if (byte[i] & 0x40 && i > 0)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "953:     if (byte[i] & 0x7f)",
      "954:       break;",
      "957:     i--;",
      "958:   byte[i] &= 0x7f;",
      "959:   for (j = 4; j >= i; j--)",
      "",
      "[Removed Lines]",
      "956:   if (byte[i] & 0x40)",
      "",
      "[Added Lines]",
      "956:   if (byte[i] & 0x40 && i > 0)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d7913b893bfa98fab27f05825dc4cab2d3a20c83",
      "candidate_info": {
        "commit_hash": "d7913b893bfa98fab27f05825dc4cab2d3a20c83",
        "repo": "LibreDWG/libredwg",
        "commit_url": "https://github.com/LibreDWG/libredwg/commit/d7913b893bfa98fab27f05825dc4cab2d3a20c83",
        "files": [
          "src/encode.c"
        ],
        "message": "encode: fix empty FIELD_2DD_VECTOR\n\nFixes GH #178 null_pointer1 case",
        "before_after_code_files": [
          "src/encode.c||src/encode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/encode.c||src/encode.c": [
          "File: src/encode.c -> src/encode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "282: #define FIELD_2DD_VECTOR(nam, size, dxf)                                      \\",
          "283:   OVERFLOW_CHECK (nam, _obj->size)                                            \\",
          "285:   for (vcount = 1; vcount < (BITCODE_BL)_obj->size; vcount++)                 \\",
          "286:     {                                                                         \\",
          "287:       FIELD_2DD (nam[vcount], FIELD_VALUE (nam[vcount - 1].x),                \\",
          "",
          "[Removed Lines]",
          "284:   FIELD_2RD (nam[0], dxf);                                                    \\",
          "",
          "[Added Lines]",
          "284:   if (_obj->size)                                                             \\",
          "285:     FIELD_2RD (nam[0], dxf);                                                  \\",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f0ad00da16fd57a4c9fefdab85c3bb0725a9ac74",
      "candidate_info": {
        "commit_hash": "f0ad00da16fd57a4c9fefdab85c3bb0725a9ac74",
        "repo": "LibreDWG/libredwg",
        "commit_url": "https://github.com/LibreDWG/libredwg/commit/f0ad00da16fd57a4c9fefdab85c3bb0725a9ac74",
        "files": [
          "src/in_json.c"
        ],
        "message": "in_json: ignore OBJECTS index field\n\nwe really need to use our own for an reliable objid.\nIt is treated just as a comment.\n\nAlso fixup TableCellContent_Attr.index subclass field.\nFixes GH #178 fuzzing crashes",
        "before_after_code_files": [
          "src/in_json.c||src/in_json.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/in_json.c||src/in_json.c": [
          "File: src/in_json.c -> src/in_json.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1678:               if (!obj->dxfname)",
          "1679:                 obj->dxfname = strdup (name);",
          "1680:             }",
          "1682:             {",
          "1683:               BITCODE_RL index = (BITCODE_RL)json_long (dat, tokens);",
          "1684:               if (obj->index != index)",
          "1686:                           obj->index)",
          "1692:               LOG_TRACE (\"index: %d\\n\", obj->index)",
          "1693:             }",
          "1694:           else if (strEQc (key, \"type\") && !obj->type)",
          "",
          "[Removed Lines]",
          "1681:           else if (strEQc (key, \"index\")) // TODO not TableCellContent_Attr",
          "1685:                 LOG_WARN (\"Unexpected %s.index %d, expected %d\", name, index,",
          "1687:               obj->index = index;",
          "1688:               if (is_entity)",
          "1689:                 obj->tio.entity->objid = obj->index;",
          "1690:               else",
          "1691:                 obj->tio.object->objid = obj->index;",
          "",
          "[Added Lines]",
          "1681:           else if (strEQc (key, \"index\") && strNE (name, \"TableCellContent_Attr\"))",
          "1685:                 LOG_WARN (\"Ignore wrong %s.index %d, expected %d\", name, index,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d931b61ac89337d1f3b6dbe220ce1da13d482b3d",
      "candidate_info": {
        "commit_hash": "d931b61ac89337d1f3b6dbe220ce1da13d482b3d",
        "repo": "LibreDWG/libredwg",
        "commit_url": "https://github.com/LibreDWG/libredwg/commit/d931b61ac89337d1f3b6dbe220ce1da13d482b3d",
        "files": [
          "src/in_json.c"
        ],
        "message": "in_json: Fatal error on missing OBJECTS type\n\nthough theoretically we could search for the type, as\nwe do for our internal fixedtype.\nFixes GH #178 fuzzing crashes",
        "before_after_code_files": [
          "src/in_json.c||src/in_json.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/in_json.c||src/in_json.c": [
          "File: src/in_json.c -> src/in_json.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1751:                   obj->handle.size = hdl->handleref.size;",
          "1752:                   obj->handle.value = hdl->handleref.value;",
          "1753:                 }",
          "1754:             }",
          "1755:           else if (strEQc (key, \"num_unknown_bits\")",
          "1756:                    && memBEGINc (obj->name, \"UNKNOWN_\"))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1754:               if (!obj->type) // TODO: We could eventually relax this",
          "1755:                 {",
          "1756:                   LOG_ERROR (\"Required %s.type missing\", name)",
          "1757:                   return DWG_ERR_INVALIDDWG;",
          "1758:                 }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "784829b23deead8f62fe49cf7d8dd082698a33a9",
      "candidate_info": {
        "commit_hash": "784829b23deead8f62fe49cf7d8dd082698a33a9",
        "repo": "LibreDWG/libredwg",
        "commit_url": "https://github.com/LibreDWG/libredwg/commit/784829b23deead8f62fe49cf7d8dd082698a33a9",
        "files": [
          "src/encode.c"
        ],
        "message": "encode: object.size overflow\n\ndecode fails when it overflows, but encode does not\nknow its final dat->size, so introduce a sensible limit.\nFixes the dos testcase of GH #178",
        "before_after_code_files": [
          "src/encode.c||src/encode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/encode.c||src/encode.c": [
          "File: src/encode.c -> src/encode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1662:   dat->bit = 0;",
          "1664:   LOG_INFO (\"Object number: %lu\", (unsigned long)obj->index);",
          "1665:   while (dat->byte + obj->size >= dat->size)",
          "1666:     bit_chain_alloc (dat);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1665:   if (obj->size > 0x100000)",
          "1666:     {",
          "1667:       LOG_ERROR (\"Object size %u overflow\", obj->size);",
          "1668:       return DWG_ERR_VALUEOUTOFBOUNDS;",
          "1669:     }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
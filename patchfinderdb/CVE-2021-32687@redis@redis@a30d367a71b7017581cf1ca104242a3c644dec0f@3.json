{
  "cve_id": "CVE-2021-32687",
  "cve_desc": "Redis is an open source, in-memory database that persists on disk. An integer overflow bug affecting all versions of Redis can be exploited to corrupt the heap and potentially be used to leak arbitrary contents of the heap or trigger remote code execution. The vulnerability involves changing the default set-max-intset-entries configuration parameter to a very large value and constructing specially crafted commands to manipulate sets. The problem is fixed in Redis versions 6.2.6, 6.0.16 and 5.0.14. An additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from modifying the set-max-intset-entries configuration parameter. This can be done using ACL to restrict unprivileged users from using the CONFIG SET command.",
  "repo": "redis/redis",
  "patch_hash": "a30d367a71b7017581cf1ca104242a3c644dec0f",
  "patch_info": {
    "commit_hash": "a30d367a71b7017581cf1ca104242a3c644dec0f",
    "repo": "redis/redis",
    "commit_url": "https://github.com/redis/redis/commit/a30d367a71b7017581cf1ca104242a3c644dec0f",
    "files": [
      "src/intset.c",
      "src/rdb.c",
      "src/t_set.c"
    ],
    "message": "Fix Integer overflow issue with intsets (CVE-2021-32687)\n\nThe vulnerability involves changing the default set-max-intset-entries\nconfiguration parameter to a very large value and constructing specially\ncrafted commands to manipulate sets",
    "before_after_code_files": [
      "src/intset.c||src/intset.c",
      "src/rdb.c||src/rdb.c",
      "src/t_set.c||src/t_set.c"
    ]
  },
  "patch_diff": {
    "src/intset.c||src/intset.c": [
      "File: src/intset.c -> src/intset.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "34: #include \"intset.h\"",
      "35: #include \"zmalloc.h\"",
      "36: #include \"endianconv.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "37: #include \"redisassert.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "105: static intset *intsetResize(intset *is, uint32_t len) {",
      "107:     is = zrealloc(is,sizeof(intset)+size);",
      "108:     return is;",
      "109: }",
      "",
      "[Removed Lines]",
      "106:     uint32_t size = len*intrev32ifbe(is->encoding);",
      "",
      "[Added Lines]",
      "107:     uint64_t size = (uint64_t)len*intrev32ifbe(is->encoding);",
      "108:     assert(size <= SIZE_MAX - sizeof(intset));",
      "",
      "---------------"
    ],
    "src/rdb.c||src/rdb.c": [
      "File: src/rdb.c -> src/rdb.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1518:         if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;",
      "1522:             o = createSetObject();",
      "",
      "[Removed Lines]",
      "1521:         if (len > server.set_max_intset_entries) {",
      "",
      "[Added Lines]",
      "1521:         size_t max_entries = server.set_max_intset_entries;",
      "1522:         if (max_entries >= 1<<30) max_entries = 1<<30;",
      "1523:         if (len > max_entries) {",
      "",
      "---------------"
    ],
    "src/t_set.c||src/t_set.c": [
      "File: src/t_set.c -> src/t_set.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "66:             if (success) {",
      "70:                     setTypeConvert(subject,OBJ_ENCODING_HT);",
      "71:                 return 1;",
      "72:             }",
      "",
      "[Removed Lines]",
      "69:                 if (intsetLen(subject->ptr) > server.set_max_intset_entries)",
      "",
      "[Added Lines]",
      "69:                 size_t max_entries = server.set_max_intset_entries;",
      "71:                 if (max_entries >= 1<<30) max_entries = 1<<30;",
      "72:                 if (intsetLen(subject->ptr) > max_entries)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c31055db617a7fedb20c28c245ddad8ed2b11931",
      "candidate_info": {
        "commit_hash": "c31055db617a7fedb20c28c245ddad8ed2b11931",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/c31055db617a7fedb20c28c245ddad8ed2b11931",
        "files": [
          "src/cluster.c",
          "src/db.c",
          "src/debug.c",
          "src/intset.c",
          "src/listpack.c",
          "src/lzf_d.c",
          "src/networking.c",
          "src/quicklist.c",
          "src/rdb.c",
          "src/server.c",
          "src/server.h",
          "src/t_list.c",
          "src/t_stream.c",
          "src/valgrind.sup",
          "tests/instances.tcl",
          "tests/integration/corrupt-dump-fuzzer.tcl",
          "tests/integration/corrupt-dump.tcl",
          "tests/integration/psync2.tcl",
          "tests/integration/rdb.tcl",
          "tests/support/server.tcl",
          "tests/support/util.tcl",
          "tests/test_helper.tcl",
          "tests/unit/introspection.tcl"
        ],
        "message": "Sanitize dump payload: fuzz tester and fixes for segfaults and leaks it exposed\n\nThe test creates keys with various encodings, DUMP them, corrupt the payload\nand RESTORES it.\nIt utilizes the recently added use-exit-on-panic config to distinguish between\n asserts and segfaults.\nIf the restore succeeds, it runs random commands on the key to attempt to\ntrigger a crash.\n\nIt runs in two modes, one with deep sanitation enabled and one without.\nIn the first one we don't expect any assertions or segfaults, in the second one\nwe expect assertions, but no segfaults.\nWe also check for leaks and invalid reads using valgrind, and if we find them\nwe print the commands that lead to that issue.\n\nChanges in the code (other than the test):\n- Replace a few NPD (null pointer deference) flows and division by zero with an\n  assertion, so that it doesn't fail the test. (since we set the server to use\n  `exit` rather than `abort` on assertion).\n- Fix quite a lot of flows in rdb.c that could have lead to memory leaks in\n  RESTORE command (since it now responds with an error rather than panic)\n- Add a DEBUG flag for SET-SKIP-CHECKSUM-VALIDATION so that the test don't need\n  to bother with faking a valid checksum\n- Remove a pile of code in serverLogObjectDebugInfo which is actually unsafe to\n  run in the crash report (see comments in the code)\n- fix a missing boundary check in lzf_decompress\n\ntest suite infra improvements:\n- be able to run valgrind checks before the process terminates\n- rotate log files when restarting servers",
        "before_after_code_files": [
          "src/cluster.c||src/cluster.c",
          "src/db.c||src/db.c",
          "src/debug.c||src/debug.c",
          "src/intset.c||src/intset.c",
          "src/listpack.c||src/listpack.c",
          "src/lzf_d.c||src/lzf_d.c",
          "src/networking.c||src/networking.c",
          "src/quicklist.c||src/quicklist.c",
          "src/rdb.c||src/rdb.c",
          "src/server.c||src/server.c",
          "src/server.h||src/server.h",
          "src/t_list.c||src/t_list.c",
          "src/t_stream.c||src/t_stream.c",
          "src/valgrind.sup||src/valgrind.sup",
          "tests/instances.tcl||tests/instances.tcl",
          "tests/integration/corrupt-dump-fuzzer.tcl||tests/integration/corrupt-dump-fuzzer.tcl",
          "tests/integration/corrupt-dump.tcl||tests/integration/corrupt-dump.tcl",
          "tests/integration/psync2.tcl||tests/integration/psync2.tcl",
          "tests/integration/rdb.tcl||tests/integration/rdb.tcl",
          "tests/support/server.tcl||tests/support/server.tcl",
          "tests/support/util.tcl||tests/support/util.tcl",
          "tests/test_helper.tcl||tests/test_helper.tcl",
          "tests/unit/introspection.tcl||tests/unit/introspection.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "src/intset.c||src/intset.c",
            "src/rdb.c||src/rdb.c"
          ],
          "candidate": [
            "src/intset.c||src/intset.c",
            "src/rdb.c||src/rdb.c"
          ]
        }
      },
      "candidate_diff": {
        "src/cluster.c||src/cluster.c": [
          "File: src/cluster.c -> src/cluster.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4981:     rdbver = (footer[1] << 8) | footer[0];",
          "4982:     if (rdbver > RDB_VERSION) return C_ERR;",
          "4985:     crc = crc64(0,p,len-8);",
          "4986:     memrev64ifbe(&crc);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4984:     if (server.skip_checksum_validation)",
          "4985:         return C_OK;",
          "",
          "---------------"
        ],
        "src/db.c||src/db.c": [
          "File: src/db.c -> src/db.c"
        ],
        "src/debug.c||src/debug.c": [
          "File: src/debug.c -> src/debug.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "403: \"SDSLEN <key> -- Show low level SDS string info representing key and value.\",",
          "404: \"SEGFAULT -- Crash the server with sigsegv.\",",
          "405: \"SET-ACTIVE-EXPIRE <0|1> -- Setting it to 0 disables expiring keys in background when they are not accessed (otherwise the Redis behavior). Setting it to 1 reenables back the default.\",",
          "406: \"AOF-FLUSH-SLEEP <microsec> -- Server will sleep before flushing the AOF, this is used for testing\",",
          "407: \"SLEEP <seconds> -- Stop the server for <seconds>. Decimals allowed.\",",
          "408: \"STRUCTSIZE -- Return the size of different Redis core C structures.\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "406: \"SET-SKIP-CHECKSUM-VALIDATION <0|1> -- Enables or disables checksum checks for rdb or RESTORE payload.\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "722:     {",
          "723:         server.active_expire_enabled = atoi(c->argv[2]->ptr);",
          "724:         addReply(c,shared.ok);",
          "725:     } else if (!strcasecmp(c->argv[1]->ptr,\"aof-flush-sleep\") &&",
          "726:                c->argc == 3)",
          "727:     {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "726:     } else if (!strcasecmp(c->argv[1]->ptr,\"set-skip-checksum-validation\") &&",
          "727:                c->argc == 3)",
          "728:     {",
          "729:         server.skip_checksum_validation = atoi(c->argv[2]->ptr);",
          "730:         addReply(c,shared.ok);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "880:     serverLog(LL_WARNING,\"Object type: %d\", o->type);",
          "881:     serverLog(LL_WARNING,\"Object encoding: %d\", o->encoding);",
          "882:     serverLog(LL_WARNING,\"Object refcount: %d\", o->refcount);",
          "883:     if (o->type == OBJ_STRING && sdsEncodedObject(o)) {",
          "884:         serverLog(LL_WARNING,\"Object raw string len: %zu\", sdslen(o->ptr));",
          "885:         if (sdslen(o->ptr) < 4096) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "889: #if UNSAFE_CRASH_REPORT",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "900:     } else if (o->type == OBJ_STREAM) {",
          "901:         serverLog(LL_WARNING,\"Stream size: %d\", (int) streamLength(o));",
          "902:     }",
          "903: }",
          "905: void _serverAssertPrintObject(const robj *o) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "917: #endif",
          "",
          "---------------"
        ],
        "src/intset.c||src/intset.c": [
          "File: src/intset.c -> src/intset.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: #include \"intset.h\"",
          "35: #include \"zmalloc.h\"",
          "36: #include \"endianconv.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "37: #include \"redisassert.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "260: int64_t intsetRandom(intset *is) {",
          "262: }",
          "",
          "[Removed Lines]",
          "261:     return _intsetGet(is,rand()%intrev32ifbe(is->length));",
          "",
          "[Added Lines]",
          "262:     uint32_t len = intrev32ifbe(is->length);",
          "264:     return _intsetGet(is,rand()%len);",
          "",
          "---------------"
        ],
        "src/listpack.c||src/listpack.c": [
          "File: src/listpack.c -> src/listpack.c"
        ],
        "src/lzf_d.c||src/lzf_d.c": [
          "File: src/lzf_d.c -> src/lzf_d.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "65:   u8 const *const in_end  = ip + in_len;",
          "66:   u8       *const out_end = op + out_len;",
          "69:     {",
          "73:         {",
          "",
          "[Removed Lines]",
          "68:   do",
          "70:       unsigned int ctrl = *ip++;",
          "",
          "[Added Lines]",
          "68:   while (ip < in_end)",
          "70:       unsigned int ctrl;",
          "71:       ctrl = *ip++;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "182: #endif",
          "183:         }",
          "184:     }",
          "187:   return op - (u8 *)out_data;",
          "188: }",
          "",
          "[Removed Lines]",
          "185:   while (ip < in_end);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/networking.c||src/networking.c": [
          "File: src/networking.c -> src/networking.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "674: }",
          "676: void addReplyAggregateLen(client *c, long length, int prefix) {",
          "677:     if (prefix == '*' && length < OBJ_SHARED_BULKHDR_LEN)",
          "678:         addReply(c,shared.mbulkhdr[length]);",
          "679:     else",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "677:     serverAssert(length >= 0);",
          "",
          "---------------"
        ],
        "src/quicklist.c||src/quicklist.c": [
          "File: src/quicklist.c -> src/quicklist.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: #include \"ziplist.h\"",
          "36: #include \"lzf.h\"",
          "38: #if defined(REDIS_TEST) || defined(REDIS_TEST_VERBOSE)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "37: #include \"redisassert.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1290:     quicklistDecompressNodeForUse(entry->node);",
          "1291:     entry->zi = ziplistIndex(entry->node->zl, entry->offset);",
          "1295:     return 1;",
          "",
          "[Removed Lines]",
          "1292:     ziplistGet(entry->zi, &entry->value, &entry->sz, &entry->longval);",
          "",
          "[Added Lines]",
          "1293:     if (!ziplistGet(entry->zi, &entry->value, &entry->sz, &entry->longval))",
          "",
          "---------------"
        ],
        "src/rdb.c||src/rdb.c": [
          "File: src/rdb.c -> src/rdb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "401:     if (rioRead(rdb,c,clen) == 0) goto err;",
          "403:         rdbExitReportCorruptRDB(\"Invalid LZF compressed string\");",
          "404:     }",
          "405:     zfree(c);",
          "",
          "[Removed Lines]",
          "402:     if (lzf_decompress(c,clen,val,len) == 0) {",
          "",
          "[Added Lines]",
          "402:     if (lzf_decompress(c,clen,val,len) != len) {",
          "404:         goto err;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "504:     unsigned long long len;",
          "506:     len = rdbLoadLen(rdb,&isencoded);",
          "507:     if (isencoded) {",
          "508:         switch(len) {",
          "509:         case RDB_ENC_INT8:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "508:     if (len == RDB_LENERR) return NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "518:         }",
          "519:     }",
          "522:     if (plain || sds) {",
          "523:         void *buf = plain ? zmalloc(len) : sdsnewlen(SDS_NOINIT,len);",
          "524:         if (lenptr) *lenptr = len;",
          "",
          "[Removed Lines]",
          "521:     if (len == RDB_LENERR) return NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "604:     default:",
          "605:         if (rioRead(rdb,buf,len) == 0) return -1;",
          "606:         buf[len] = '\\0';",
          "608:         return 0;",
          "609:     }",
          "610: }",
          "",
          "[Removed Lines]",
          "607:         sscanf(buf, \"%lg\", val);",
          "",
          "[Added Lines]",
          "609:         if (sscanf(buf, \"%lg\", val)!=1) return -1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1574:             if (o->encoding == OBJ_ENCODING_HT) {",
          "1576:             } else {",
          "1577:                 sdsfree(sdsele);",
          "1578:             }",
          "",
          "[Removed Lines]",
          "1575:                 dictAdd((dict*)o->ptr,sdsele,NULL);",
          "",
          "[Added Lines]",
          "1577:                 if (dictAdd((dict*)o->ptr,sdsele,NULL) != DICT_OK) {",
          "1578:                     rdbExitReportCorruptRDB(\"Duplicate set members detected\");",
          "1579:                     decrRefCount(o);",
          "1580:                     sdsfree(sdsele);",
          "1581:                     return NULL;",
          "1582:                 }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1694:             ret = dictAdd((dict*)o->ptr, field, value);",
          "1695:             if (ret == DICT_ERR) {",
          "1697:             }",
          "1698:         }",
          "",
          "[Removed Lines]",
          "1696:                 rdbExitReportCorruptRDB(\"Duplicate keys detected\");",
          "",
          "[Added Lines]",
          "1703:                 rdbExitReportCorruptRDB(\"Duplicate hash fields detected\");",
          "1704:                 sdsfree(value);",
          "1705:                 sdsfree(field);",
          "1706:                 decrRefCount(o);",
          "1707:                 return NULL;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1843:             if (sdslen(nodekey) != sizeof(streamID)) {",
          "1844:                 rdbExitReportCorruptRDB(\"Stream node key entry is not the \"",
          "1845:                                         \"size of a stream ID\");",
          "1846:             }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1857:                 sdsfree(nodekey);",
          "1858:                 decrRefCount(o);",
          "1859:                 return NULL;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1872:                 rdbExitReportCorruptRDB(\"Empty listpack inside stream\");",
          "1873:             }",
          "1876:             int retval = raxInsert(s->rax,",
          "1877:                 (unsigned char*)nodekey,sizeof(streamID),lp,NULL);",
          "1878:             sdsfree(nodekey);",
          "1880:                 rdbExitReportCorruptRDB(\"Listpack re-added with existing key\");",
          "1881:         }",
          "1883:         s->length = rdbLoadLen(rdb,NULL);",
          "",
          "[Removed Lines]",
          "1879:             if (!retval)",
          "",
          "[Added Lines]",
          "1887:                 sdsfree(nodekey);",
          "1888:                 decrRefCount(o);",
          "1889:                 zfree(lp);",
          "1890:                 return NULL;",
          "1897:             if (!retval) {",
          "1899:                 decrRefCount(o);",
          "1900:                 zfree(lp);",
          "1901:                 return NULL;",
          "1902:             }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1922:             }",
          "1924:             streamCG *cgroup = streamCreateCG(s,cgname,sdslen(cgname),&cg_id);",
          "1926:                 rdbExitReportCorruptRDB(\"Duplicated consumer group name %s\",",
          "1927:                                          cgname);",
          "1928:             sdsfree(cgname);",
          "",
          "[Removed Lines]",
          "1925:             if (cgroup == NULL)",
          "",
          "[Added Lines]",
          "1947:             if (cgroup == NULL) {",
          "1950:                 decrRefCount(o);",
          "1951:                 sdsfree(cgname);",
          "1952:                 return NULL;",
          "1953:             }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1954:                     streamFreeNACK(nack);",
          "1955:                     return NULL;",
          "1956:                 }",
          "1958:                     rdbExitReportCorruptRDB(\"Duplicated global PEL entry \"",
          "1959:                                             \"loading stream consumer group\");",
          "1960:             }",
          "",
          "[Removed Lines]",
          "1957:                 if (!raxInsert(cgroup->pel,rawid,sizeof(rawid),nack,NULL))",
          "",
          "[Added Lines]",
          "1983:                 if (!raxInsert(cgroup->pel,rawid,sizeof(rawid),nack,NULL)) {",
          "1986:                     decrRefCount(o);",
          "1987:                     streamFreeNACK(nack);",
          "1988:                     return NULL;",
          "1989:                 }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2003:                         return NULL;",
          "2004:                     }",
          "2005:                     streamNACK *nack = raxFind(cgroup->pel,rawid,sizeof(rawid));",
          "2007:                         rdbExitReportCorruptRDB(\"Consumer entry not found in \"",
          "2008:                                                 \"group global PEL\");",
          "2013:                     nack->consumer = consumer;",
          "2015:                         rdbExitReportCorruptRDB(\"Duplicated consumer PEL entry \"",
          "2016:                                                 \" loading a stream consumer \"",
          "2017:                                                 \"group\");",
          "2018:                 }",
          "2019:             }",
          "2020:         }",
          "",
          "[Removed Lines]",
          "2006:                     if (nack == raxNotFound)",
          "2014:                     if (!raxInsert(consumer->pel,rawid,sizeof(rawid),nack,NULL))",
          "",
          "[Added Lines]",
          "2036:                     if (nack == raxNotFound) {",
          "2039:                         decrRefCount(o);",
          "2040:                         return NULL;",
          "2041:                     }",
          "2047:                     if (!raxInsert(consumer->pel,rawid,sizeof(rawid),nack,NULL)) {",
          "2051:                         decrRefCount(o);",
          "2052:                         return NULL;",
          "2053:                     }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2035:         if (mt == NULL) {",
          "2036:             moduleTypeNameByID(name,moduleid);",
          "2039:         }",
          "2040:         RedisModuleIO io;",
          "2041:         robj keyobj;",
          "",
          "[Removed Lines]",
          "2037:             serverLog(LL_WARNING,\"The RDB file contains module data I can't load: no matching module '%s'\", name);",
          "2038:             exit(1);",
          "",
          "[Added Lines]",
          "2073:             rdbExitReportCorruptRDB(\"The RDB file contains module data I can't load: no matching module '%s'\", name);",
          "2074:             return NULL;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2054:         if (io.ver == 2) {",
          "2055:             uint64_t eof = rdbLoadLen(rdb,NULL);",
          "2056:             if (eof == RDB_LENERR) {",
          "2059:                 return NULL;",
          "2060:             }",
          "2061:             if (eof != RDB_MODULE_OPCODE_EOF) {",
          "2064:             }",
          "2065:         }",
          "2067:         if (ptr == NULL) {",
          "2068:             moduleTypeNameByID(name,moduleid);",
          "2071:         }",
          "2072:         o = createModuleObject(mt,ptr);",
          "2073:     } else {",
          "",
          "[Removed Lines]",
          "2058:                 decrRefCount(o);",
          "2062:                 serverLog(LL_WARNING,\"The RDB file contains module data for the module '%s' that is not terminated by the proper module value EOF marker\", name);",
          "2063:                 exit(1);",
          "2069:             serverLog(LL_WARNING,\"The RDB file contains module data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.\", name);",
          "2070:             exit(1);",
          "",
          "[Added Lines]",
          "2093:                 if (ptr) {",
          "2095:                     decrRefCount(o);",
          "2096:                 }",
          "2100:                 rdbExitReportCorruptRDB(\"The RDB file contains module data for the module '%s' that is not terminated by the proper module value EOF marker\", name);",
          "2101:                 if (ptr) {",
          "2103:                     decrRefCount(o);",
          "2104:                 }",
          "2105:                 return NULL;",
          "2111:             rdbExitReportCorruptRDB(\"The RDB file contains module data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.\", name);",
          "2112:             return NULL;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2441:         uint64_t cksum, expected = rdb->cksum;",
          "2443:         if (rioRead(rdb,&cksum,8) == 0) goto eoferr;",
          "2445:             memrev64ifbe(&cksum);",
          "2446:             if (cksum == 0) {",
          "2447:                 serverLog(LL_WARNING,\"RDB file was saved with checksum disabled: no check performed.\");",
          "",
          "[Removed Lines]",
          "2444:         if (server.rdb_checksum) {",
          "",
          "[Added Lines]",
          "2486:         if (server.rdb_checksum && !server.skip_checksum_validation) {",
          "",
          "---------------"
        ],
        "src/server.c||src/server.c": [
          "File: src/server.c -> src/server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2506:     server.tlsfd_count = 0;",
          "2507:     server.sofd = -1;",
          "2508:     server.active_expire_enabled = 1;",
          "2509:     server.client_max_querybuf_len = PROTO_MAX_QUERYBUF_LEN;",
          "2510:     server.saveparams = NULL;",
          "2511:     server.loading = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2509:     server.skip_checksum_validation = 0;",
          "",
          "---------------"
        ],
        "src/server.h||src/server.h": [
          "File: src/server.h -> src/server.h"
        ],
        "src/t_list.c||src/t_list.c": [
          "File: src/t_list.c -> src/t_list.c"
        ],
        "src/t_stream.c||src/t_stream.c": [
          "File: src/t_stream.c -> src/t_stream.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "788:                 si->lp_ele = lpNext(si->lp,si->lp_ele);",
          "789:             }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "790:             serverAssert(*numfields>=0);",
          "",
          "---------------"
        ],
        "src/valgrind.sup||src/valgrind.sup": [
          "File: src/valgrind.sup -> src/valgrind.sup",
          "--- Hunk 1 ---",
          "[Context before]",
          "15:    Memcheck:Value8",
          "16:    fun:lzf_compress",
          "17: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: {",
          "20:    <negative size allocatoin, see integration/corrupt-dump>",
          "21:    Memcheck:FishyValue",
          "22:    malloc(size)",
          "23:    fun:malloc",
          "24:    fun:ztrymalloc_usable",
          "25:    fun:ztrymalloc",
          "26: }",
          "",
          "---------------"
        ],
        "tests/instances.tcl||tests/instances.tcl": [
          "File: tests/instances.tcl -> tests/instances.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "156:     set logs [glob */err.txt]",
          "157:     foreach log $logs {",
          "159:         if {$res != \"\"} {",
          "160:             puts $res",
          "161:             incr ::failed",
          "",
          "[Removed Lines]",
          "158:         set res [find_valgrind_errors $log]",
          "",
          "[Added Lines]",
          "158:         set res [find_valgrind_errors $log true]",
          "",
          "---------------"
        ],
        "tests/integration/corrupt-dump-fuzzer.tcl||tests/integration/corrupt-dump-fuzzer.tcl": [
          "File: tests/integration/corrupt-dump-fuzzer.tcl -> tests/integration/corrupt-dump-fuzzer.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # tests of corrupt ziplist payload with valid CRC",
          "3: tags {\"dump\" \"corruption\"} {",
          "5: proc generate_collections {suffix elements} {",
          "6:     set rd [redis_deferring_client]",
          "7:     for {set j 0} {$j < $elements} {incr j} {",
          "8:         # add both string values and integers",
          "9:         if {$j % 2 == 0} {set val $j} else {set val \"_$j\"}",
          "10:         $rd hset hash$suffix $j $val",
          "11:         $rd lpush list$suffix $val",
          "12:         $rd zadd zset$suffix $j $val",
          "13:         $rd sadd set$suffix $val",
          "14:         $rd xadd stream$suffix * item 1 value $val",
          "15:     }",
          "16:     for {set j 0} {$j < $elements * 5} {incr j} {",
          "17:         $rd read ; # Discard replies",
          "18:     }",
          "19:     $rd close",
          "20: }",
          "22: # generate keys with various types and encodings",
          "23: proc generate_types {} {",
          "24:     r config set list-max-ziplist-size 5",
          "25:     r config set hash-max-ziplist-entries 5",
          "26:     r config set zset-max-ziplist-entries 5",
          "27:     r config set stream-node-max-entries 5",
          "29:     # create small (ziplist / listpack encoded) objects with 3 items",
          "30:     generate_collections \"\" 3",
          "32:     # add some metadata to the stream",
          "33:     r xgroup create stream mygroup 0",
          "34:     set records [r xreadgroup GROUP mygroup Alice COUNT 2 STREAMS stream >]",
          "35:     r xack stream mygroup [lindex [lindex [lindex [lindex $records 0] 1] 0] 0]",
          "37:     # create other non-collection types",
          "38:     r incr int",
          "39:     r set string str",
          "41:     # create bigger objects with 10 items (more than a single ziplist / listpack)",
          "42:     generate_collections big 10",
          "44:     # make sure our big stream also has a listpack record that has different",
          "45:     # field names than the master recored",
          "46:     r xadd streambig * item 1 value 1",
          "47:     r xadd streambig * item 1 unique value",
          "48: }",
          "50: proc corrupt_payload {payload} {",
          "51:     set len [string length $payload]",
          "52:     set count 1 ;# usually corrupt only one byte",
          "53:     if {rand() > 0.9} { set count 2 }",
          "54:     while { $count > 0 } {",
          "55:         set idx [expr {int(rand() * $len)}]",
          "56:         set ch [binary format c [expr {int(rand()*255)}]]",
          "57:         set payload [string replace $payload $idx $idx $ch]",
          "58:         incr count -1",
          "59:     }",
          "60:     return $payload",
          "61: }",
          "63: # fuzzy tester for corrupt RESTORE payloads",
          "64: # valgrind will make sure there were no leaks in the rdb loader error handling code",
          "65: foreach sanitize_dump {no yes} {",
          "66:     if {$::accurate} {",
          "67:         set min_duration [expr {60 * 10}] ;# run at least 10 minutes",
          "68:         set min_cycles 1000 ;# run at least 1k cycles (max 16 minutes)",
          "69:     } else {",
          "70:         set min_duration 10 ; # run at least 10 seconds",
          "71:         set min_cycles 10 ; # run at least 10 cycles",
          "72:     }",
          "74:     test \"Fuzzer corrupt restore payloads - sanitize_dump: $sanitize_dump\" {",
          "75:         if {$min_duration * 2 > $::timeout} {",
          "76:             fail \"insufficient timeout\"",
          "77:         }",
          "78:         # start a server, fill with data and save an RDB file once (avoid re-save)",
          "79:         start_server [list overrides [list \"save\" \"\" use-exit-on-panic yes crash-memcheck-enabled no loglevel verbose] ] {",
          "80:             set stdout [srv 0 stdout]",
          "81:             r config set sanitize-dump-payload $sanitize_dump",
          "82:             r debug set-skip-checksum-validation 1",
          "83:             set start_time [clock seconds]",
          "84:             generate_types",
          "85:             r save",
          "86:             set cycle 0",
          "87:             set stat_terminated_in_restore 0",
          "88:             set stat_terminated_in_traffic 0",
          "89:             set stat_terminated_by_signal 0",
          "90:             set stat_successful_restore 0",
          "91:             set stat_rejected_restore 0",
          "92:             set stat_traffic_commands_sent 0",
          "93:             # repeatedly DUMP a random key, corrupt it and try RESTORE into a new key",
          "94:             while true {",
          "95:                 set k [r randomkey]",
          "96:                 set dump [r dump $k]",
          "97:                 set dump [corrupt_payload $dump]",
          "98:                 set printable_dump [string2printable $dump]",
          "99:                 set restore_failed false",
          "100:                 set report_and_restart false",
          "101:                 set sent {}",
          "102:                 # RESTORE can fail, but hopefully not terminate",
          "103:                 if { [catch { r restore \"_$k\" 0 $dump REPLACE } err] } {",
          "104:                     set restore_failed true",
          "105:                     # skip if return failed with an error response.",
          "106:                     if {[string match \"ERR*\" $err]} {",
          "107:                         incr stat_rejected_restore",
          "108:                     } else {",
          "109:                         set report_and_restart true",
          "110:                         incr stat_terminated_in_restore",
          "111:                         write_log_line 0 \"corrupt payload: $printable_dump\"",
          "112:                         if {$sanitize_dump == 1} {",
          "113:                             puts \"Server crashed in RESTORE with payload: $printable_dump\"",
          "114:                         }",
          "115:                     }",
          "116:                 } else {",
          "117:                     r ping ;# an attempt to check if the server didn't terminate (this will throw an error that will terminate the tests)",
          "118:                 }",
          "120:                 set print_commands false",
          "121:                 if {!$restore_failed} {",
          "122:                     # if RESTORE didn't fail or terminate, run some random traffic on the new key",
          "123:                     incr stat_successful_restore",
          "124:                     if { [ catch {",
          "125:                         set sent [generate_fuzzy_traffic_on_key \"_$k\" 1] ;# traffic for 1 second",
          "126:                         incr stat_traffic_commands_sent [llength $sent]",
          "127:                         r del \"_$k\" ;# in case the server terminated, here's where we'll detect it.",
          "128:                     } err ] } {",
          "129:                         # if the server terminated update stats and restart it",
          "130:                         set report_and_restart true",
          "131:                         incr stat_terminated_in_traffic",
          "132:                         set by_signal [count_log_message 0 \"crashed by signal\"]",
          "133:                         incr stat_terminated_by_signal $by_signal",
          "135:                         if {$by_signal != 0 || $sanitize_dump == 1 } {",
          "136:                             puts \"Server crashed (by signal: $by_signal), with payload: $printable_dump\"",
          "137:                             set print_commands true",
          "138:                         }",
          "139:                     }",
          "140:                 }",
          "142:                 # check valgrind report for invalid reads after each RESTORE",
          "143:                 # payload so that we have a report that is easier to reproduce",
          "144:                 set valgrind_errors [find_valgrind_errors [srv 0 stderr] false]",
          "145:                 if {$valgrind_errors != \"\"} {",
          "146:                     puts \"valgrind found an issue for payload: $printable_dump\"",
          "147:                     set report_and_restart true",
          "148:                     set print_commands true",
          "149:                 }",
          "151:                 if {$report_and_restart} {",
          "152:                     if {$print_commands} {",
          "153:                         puts \"violating commands:\"",
          "154:                         foreach cmd $sent {",
          "155:                             foreach arg $cmd {",
          "156:                                 puts -nonewline \"[string2printable $arg] \"",
          "157:                             }",
          "158:                             puts \"\"",
          "159:                         }",
          "160:                     }",
          "162:                     # restart the server and re-apply debug configuration",
          "163:                     write_log_line 0 \"corrupt payload: $printable_dump\"",
          "164:                     restart_server 0 true true",
          "165:                     r config set sanitize-dump-payload $sanitize_dump",
          "166:                     r debug set-skip-checksum-validation 1",
          "167:                 }",
          "169:                 incr cycle",
          "170:                 if { ([clock seconds]-$start_time) >= $min_duration && $cycle >= $min_cycles} {",
          "171:                     break",
          "172:                 }",
          "173:             }",
          "174:             if {$::verbose} {",
          "175:                 puts \"Done $cycle cycles in [expr {[clock seconds]-$start_time}] seconds.\"",
          "176:                 puts \"RESTORE: successful: $stat_successful_restore, rejected: $stat_rejected_restore\"",
          "177:                 puts \"Total commands sent in traffic: $stat_traffic_commands_sent, crashes during traffic: $stat_terminated_in_traffic ($stat_terminated_by_signal by signal).\"",
          "178:             }",
          "179:         }",
          "180:         # if we run sanitization we never expect the server to crash at runtime",
          "181:         if { $sanitize_dump == 1} {",
          "182:             assert_equal $stat_terminated_in_restore 0",
          "183:             assert_equal $stat_terminated_in_traffic 0",
          "184:         }",
          "185:         # make sure all terminations where due to assertion and not a SIGSEGV",
          "186:         assert_equal $stat_terminated_by_signal 0",
          "187:     }",
          "188: }",
          "192: } ;# tags",
          "",
          "---------------"
        ],
        "tests/integration/corrupt-dump.tcl||tests/integration/corrupt-dump.tcl": [
          "File: tests/integration/corrupt-dump.tcl -> tests/integration/corrupt-dump.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: # tests of corrupt ziplist payload with valid CRC",
          "3: tags {\"dump\" \"corruption\"} {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: # * setting crash-memcheck-enabled to no to avoid issues with valgrind",
          "3: # * setting use-exit-on-panic to yes so that valgrind can search for leaks",
          "4: # * settng debug set-skip-checksum-validation to 1 on some tests for which we",
          "5: #   didn't bother to fake a valid checksum",
          "6: # * some tests set sanitize-dump-payload to no and some to yet, depending on",
          "7: #   what we want to test",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "18: test {corrupt payload: #7445 - without sanitize - 1} {",
          "19:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "20:         r config set sanitize-dump-payload no",
          "22:         r restore key 0 $corrupt_payload_7445",
          "23:         catch {r lindex key 2}",
          "25:     }",
          "26: }",
          "28: test {corrupt payload: #7445 - without sanitize - 2} {",
          "29:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "30:         r config set sanitize-dump-payload no",
          "32:         r restore key 0 $corrupt_payload_7445",
          "33:         catch {r lset key 2 \"BEEF\"}",
          "35:     }",
          "36: }",
          "38: test {corrupt payload: hash with valid zip list header, invalid entry len} {",
          "39:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "40:         r restore key 0 \"\\x0D\\x1B\\x1B\\x00\\x00\\x00\\x16\\x00\\x00\\x00\\x04\\x00\\x00\\x02\\x61\\x00\\x04\\x02\\x62\\x00\\x04\\x14\\x63\\x00\\x04\\x02\\x64\\x00\\xFF\\x09\\x00\\xD9\\x10\\x54\\x92\\x15\\xF5\\x5F\\x52\"",
          "42:         r config set hash-max-ziplist-entries 1",
          "43:         catch {r hset key b b}",
          "44:         verify_log_message 0 \"*zipEntrySafe*\" 0",
          "",
          "[Removed Lines]",
          "21:         r config set crash-memcheck-enabled no ;# avoid valgrind issues",
          "24:         verify_log_message 0 \"*ASSERTION FAILED*\" 0",
          "31:         r config set crash-memcheck-enabled no ;# avoid valgrind issues",
          "34:         verify_log_message 0 \"*ASSERTION FAILED*\" 0",
          "41:         r config set crash-memcheck-enabled no ;# avoid valgrind issues",
          "",
          "[Added Lines]",
          "29:         assert_equal [count_log_message 0 \"crashed by signal\"] 0",
          "30:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "39:         assert_equal [count_log_message 0 \"crashed by signal\"] 0",
          "40:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "46:         r config set sanitize-dump-payload no",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "48: test {corrupt payload: invalid zlbytes header} {",
          "49:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "50:         catch {",
          "51:             r restore key 0 \"\\x0D\\x1B\\x25\\x00\\x00\\x00\\x16\\x00\\x00\\x00\\x04\\x00\\x00\\x02\\x61\\x00\\x04\\x02\\x62\\x00\\x04\\x02\\x63\\x00\\x04\\x02\\x64\\x00\\xFF\\x09\\x00\\xB7\\xF7\\x6E\\x9F\\x43\\x43\\x14\\xC6\"",
          "52:         } err",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "56:         r config set sanitize-dump-payload no",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "57: test {corrupt payload: valid zipped hash header, dup records} {",
          "58:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "59:         r restore key 0 \"\\x0D\\x1B\\x1B\\x00\\x00\\x00\\x16\\x00\\x00\\x00\\x04\\x00\\x00\\x02\\x61\\x00\\x04\\x02\\x62\\x00\\x04\\x02\\x61\\x00\\x04\\x02\\x64\\x00\\xFF\\x09\\x00\\xA1\\x98\\x36\\x78\\xCC\\x8E\\x93\\x2E\"",
          "61:         r config set hash-max-ziplist-entries 1",
          "62:         # cause an assertion when converting to hash table",
          "63:         catch {r hset key b b}",
          "",
          "[Removed Lines]",
          "60:         r config set crash-memcheck-enabled no ;# avoid valgrind issues",
          "",
          "[Added Lines]",
          "66:         r config set sanitize-dump-payload no",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "68: test {corrupt payload: quicklist big ziplist prev len} {",
          "69:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "70:         r restore key 0 \"\\x0E\\x01\\x13\\x13\\x00\\x00\\x00\\x0E\\x00\\x00\\x00\\x02\\x00\\x00\\x02\\x61\\x00\\x0E\\x02\\x62\\x00\\xFF\\x09\\x00\\x49\\x97\\x30\\xB2\\x0D\\xA1\\xED\\xAA\"",
          "72:         catch {r lindex key -2}",
          "74:     }",
          "75: }",
          "",
          "[Removed Lines]",
          "71:         r config set crash-memcheck-enabled no ;# avoid valgrind issues",
          "73:         verify_log_message 0 \"*ASSERTION FAILED*\" 0",
          "",
          "[Added Lines]",
          "77:         r config set sanitize-dump-payload no",
          "80:         assert_equal [count_log_message 0 \"crashed by signal\"] 0",
          "81:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "88: test {corrupt payload: quicklist ziplist wrong count} {",
          "89:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "90:         r restore key 0 \"\\x0E\\x01\\x13\\x13\\x00\\x00\\x00\\x0E\\x00\\x00\\x00\\x03\\x00\\x00\\x02\\x61\\x00\\x04\\x02\\x62\\x00\\xFF\\x09\\x00\\x4D\\xE2\\x0A\\x2F\\x08\\x25\\xDF\\x91\"",
          "94:     }",
          "95: }",
          "97: test {corrupt payload: #3080 - quicklist} {",
          "98:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "99:         catch {",
          "100:             r RESTORE key 0 \"\\x0E\\x01\\x80\\x00\\x00\\x00\\x10\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x02\\x00\\x00\\x80\\x41\\x41\\x41\\x41\\x07\\x00\\x03\\xC7\\x1D\\xEF\\x54\\x68\\xCC\\xF3\"",
          "103:         assert_match \"*Bad data format*\" $err",
          "104:         verify_log_message 0 \"*Ziplist integrity check failed*\" 0",
          "105:     }",
          "",
          "[Removed Lines]",
          "91:         r lpush key a",
          "92:         # check that the server didn't crash",
          "93:         r ping",
          "101:             r DUMP key",
          "102:         }",
          "",
          "[Added Lines]",
          "98:         r config set sanitize-dump-payload no",
          "100:         # we'll be able to push, but iterating on the list will assert",
          "101:         r lpush key header",
          "102:         r rpush key footer",
          "103:         catch { [r lrange key -1 -1] }",
          "104:         assert_equal [count_log_message 0 \"crashed by signal\"] 0",
          "105:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "111:         r config set sanitize-dump-payload no",
          "114:             r DUMP key ;# DUMP was used in the original issue, but now even with shallow sanitization restore safely fails, so this is dead code",
          "115:         } err",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "108: test {corrupt payload: #3080 - ziplist} {",
          "109:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "110:         catch {",
          "111:             r RESTORE key 0 \"\\x0A\\x80\\x00\\x00\\x00\\x10\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x02\\x00\\x00\\x80\\x41\\x41\\x41\\x41\\x07\\x00\\x39\\x5B\\x49\\xE0\\xC1\\xC6\\xDD\\x76\"",
          "113:         assert_match \"*Bad data format*\" $err",
          "114:         verify_log_message 0 \"*Ziplist integrity check failed*\" 0",
          "115:     }",
          "",
          "[Removed Lines]",
          "112:         }",
          "",
          "[Added Lines]",
          "123:         # shallow sanitization is enough for restore to safely reject the payload with wrong size",
          "124:         r config set sanitize-dump-payload no",
          "127:         } err",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "118: test {corrupt payload: load corrupted rdb with no CRC - #3505} {",
          "119:     set server_path [tmpdir \"server.rdb-corruption-test\"]",
          "120:     exec cp tests/assets/corrupt_ziplist.rdb $server_path",
          "123:     # wait for termination",
          "124:     wait_for_condition 100 50 {",
          "",
          "[Removed Lines]",
          "121:     set srv [start_server [list overrides [list \"dir\" $server_path \"dbfilename\" \"corrupt_ziplist.rdb\" loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no]]]",
          "",
          "[Added Lines]",
          "136:     set srv [start_server [list overrides [list \"dir\" $server_path \"dbfilename\" \"corrupt_ziplist.rdb\" loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no sanitize-dump-payload no]]]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "136: test {corrupt payload: listpack invalid size header} {",
          "137:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "138:         catch {",
          "139:             r restore key 0 \"\\x0F\\x01\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x40\\x55\\x5F\\x00\\x00\\x00\\x0F\\x00\\x01\\x01\\x00\\x01\\x02\\x01\\x88\\x31\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x32\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x00\\x01\\x00\\x01\\x00\\x01\\x00\\x01\\x02\\x02\\x88\\x31\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x61\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x32\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x62\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x08\\x01\\xFF\\x0A\\x01\\x00\\x00\\x09\\x00\\x45\\x91\\x0A\\x87\\x2F\\xA5\\xF9\\x2E\"",
          "140:         } err",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "153:         r config set sanitize-dump-payload no",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "146: test {corrupt payload: listpack too long entry len} {",
          "147:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "148:         r restore key 0 \"\\x0F\\x01\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x40\\x55\\x55\\x00\\x00\\x00\\x0F\\x00\\x01\\x01\\x00\\x01\\x02\\x01\\x88\\x31\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x32\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x00\\x01\\x00\\x01\\x00\\x01\\x00\\x01\\x02\\x02\\x89\\x31\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x61\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x32\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x62\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x08\\x01\\xFF\\x0A\\x01\\x00\\x00\\x09\\x00\\x40\\x63\\xC9\\x37\\x03\\xA2\\xE5\\x68\"",
          "149:         catch {",
          "150:             r xinfo stream key full",
          "151:         } err",
          "153:     }",
          "154: }",
          "156: test {corrupt payload: listpack very long entry len} {",
          "157:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "158:         r restore key 0 \"\\x0F\\x01\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x40\\x55\\x55\\x00\\x00\\x00\\x0F\\x00\\x01\\x01\\x00\\x01\\x02\\x01\\x88\\x31\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x32\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x00\\x01\\x00\\x01\\x00\\x01\\x00\\x01\\x02\\x02\\x88\\x31\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x61\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x32\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x9C\\x62\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x08\\x01\\xFF\\x0A\\x01\\x00\\x00\\x09\\x00\\x63\\x6F\\x42\\x8E\\x7C\\xB5\\xA2\\x9D\"",
          "159:         catch {",
          "160:             r xinfo stream key full",
          "161:         } err",
          "163:     }",
          "164: }",
          "",
          "[Removed Lines]",
          "152:         verify_log_message 0 \"*ASSERTION FAILED*\" 0",
          "162:         verify_log_message 0 \"*ASSERTION FAILED*\" 0",
          "",
          "[Added Lines]",
          "164:         r config set sanitize-dump-payload no",
          "169:         assert_equal [count_log_message 0 \"crashed by signal\"] 0",
          "170:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "176:         r config set sanitize-dump-payload no",
          "181:         assert_equal [count_log_message 0 \"crashed by signal\"] 0",
          "182:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "174:     }",
          "175: }",
          "177: } ;# tags",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "197: test {corrupt payload: fuzzer findings - NPD in streamIteratorGetID} {",
          "198:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "199:         r config set sanitize-dump-payload no",
          "200:         r debug set-skip-checksum-validation 1",
          "201:         catch {",
          "202:             r RESTORE key 0 \"\\x0F\\x01\\x10\\x00\\x00\\x01\\x73\\xBD\\x68\\x48\\x71\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x42\\x42\\x00\\x00\\x00\\x18\\x00\\x03\\x01\\x00\\x01\\x02\\x01\\x84\\x69\\x74\\x65\\x6D\\x05\\x85\\x76\\x61\\x6C\\x75\\x65\\x06\\x00\\x01\\x02\\x01\\x00\\x01\\x00\\x01\\x01\\x01\\x00\\x01\\x05\\x01\\x02\\x01\\x00\\x01\\x01\\x01\\x01\\x01\\x82\\x5F\\x31\\x03\\x05\\x01\\x02\\x01\\x00\\x01\\x02\\x01\\x01\\x01\\x02\\x01\\x48\\x01\\xFF\\x03\\x81\\x00\\x00\\x01\\x73\\xBD\\x68\\x48\\x71\\x02\\x01\\x07\\x6D\\x79\\x67\\x72\\x6F\\x75\\x70\\x81\\x00\\x00\\x01\\x73\\xBD\\x68\\x48\\x71\\x00\\x01\\x00\\x00\\x01\\x73\\xBD\\x68\\x48\\x71\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x72\\x48\\x68\\xBD\\x73\\x01\\x00\\x00\\x01\\x01\\x05\\x41\\x6C\\x69\\x63\\x65\\x72\\x48\\x68\\xBD\\x73\\x01\\x00\\x00\\x01\\x00\\x00\\x01\\x73\\xBD\\x68\\x48\\x71\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x00\\x80\\xCD\\xB0\\xD5\\x1A\\xCE\\xFF\\x10\"",
          "203:             r XREVRANGE key 725 233",
          "204:         }",
          "205:         assert_equal [count_log_message 0 \"crashed by signal\"] 0",
          "206:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "207:     }",
          "208: }",
          "210: test {corrupt payload: fuzzer findings - listpack NPD on invalid stream} {",
          "211:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "212:         r config set sanitize-dump-payload no",
          "213:         r debug set-skip-checksum-validation 1",
          "214:         catch {",
          "215:             r RESTORE _stream 0 \"\\x0F\\x01\\x10\\x00\\x00\\x01\\x73\\xDC\\xB6\\x6B\\xF1\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x42\\x42\\x00\\x00\\x00\\x18\\x00\\x03\\x01\\x00\\x01\\x02\\x01\\x84\\x69\\x74\\x65\\x6D\\x05\\x85\\x76\\x61\\x6C\\x75\\x65\\x06\\x00\\x01\\x02\\x01\\x00\\x01\\x00\\x01\\x01\\x01\\x00\\x01\\x05\\x01\\x02\\x01\\x1F\\x01\\x00\\x01\\x01\\x01\\x6D\\x5F\\x31\\x03\\x05\\x01\\x02\\x01\\x29\\x01\\x00\\x01\\x01\\x01\\x02\\x01\\x05\\x01\\xFF\\x03\\x81\\x00\\x00\\x01\\x73\\xDC\\xB6\\x6C\\x1A\\x00\\x01\\x07\\x6D\\x79\\x67\\x72\\x6F\\x75\\x70\\x81\\x00\\x00\\x01\\x73\\xDC\\xB6\\x6B\\xF1\\x00\\x01\\x00\\x00\\x01\\x73\\xDC\\xB6\\x6B\\xF1\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x4B\\x6C\\xB6\\xDC\\x73\\x01\\x00\\x00\\x01\\x01\\x05\\x41\\x6C\\x69\\x63\\x65\\x3D\\x6C\\xB6\\xDC\\x73\\x01\\x00\\x00\\x01\\x00\\x00\\x01\\x73\\xDC\\xB6\\x6B\\xF1\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x00\\xC7\\x7D\\x1C\\xD7\\x04\\xFF\\xE6\\x9D\"",
          "216:             r XREAD STREAMS _stream 519389898758",
          "217:         }",
          "218:         assert_equal [count_log_message 0 \"crashed by signal\"] 0",
          "219:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "220:     }",
          "221: }",
          "223: test {corrupt payload: fuzzer findings - NPD in quicklistIndex} {",
          "224:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "225:         r config set sanitize-dump-payload no",
          "226:         r debug set-skip-checksum-validation 1",
          "227:         catch {",
          "228:             r RESTORE key 0 \"\\x0E\\x01\\x13\\x13\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x03\\x12\\x00\\xF3\\x02\\x02\\x5F\\x31\\x04\\xF1\\xFF\\x09\\x00\\xC9\\x4B\\x31\\xFE\\x61\\xC0\\x96\\xFE\"",
          "229:             r LSET key 290 290",
          "230:         }",
          "231:         assert_equal [count_log_message 0 \"crashed by signal\"] 0",
          "232:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "233:     }",
          "234: }",
          "236: test {corrupt payload: fuzzer findings - invalid read in ziplistFind} {",
          "237:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "238:         r config set sanitize-dump-payload no",
          "239:         r debug set-skip-checksum-validation 1",
          "240:         catch {",
          "241:             r RESTORE key 0 \"\\x0D\\x19\\x19\\x00\\x00\\x00\\x16\\x00\\x00\\x00\\x06\\x00\\x00\\xF1\\x02\\xF1\\x02\\xF2\\x02\\x02\\x5F\\x31\\x04\\x99\\x02\\xF3\\xFF\\x09\\x00\\xC5\\xB8\\x10\\xC0\\x8A\\xF9\\x16\\xDF\"",
          "242:             r HEXISTS key -688319650333",
          "243:         }",
          "244:         assert_equal [count_log_message 0 \"crashed by signal\"] 0",
          "245:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "246:     }",
          "247: }",
          "250: test {corrupt payload: fuzzer findings - invalid ziplist encoding} {",
          "251:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "252:         r config set sanitize-dump-payload yes",
          "253:         r debug set-skip-checksum-validation 1",
          "254:         catch {",
          "255:             r RESTORE _listbig 0 \"\\x0E\\x02\\x1B\\x1B\\x00\\x00\\x00\\x16\\x00\\x00\\x00\\x05\\x00\\x00\\x02\\x5F\\x39\\x04\\xF9\\x02\\x86\\x5F\\x37\\x04\\xF7\\x02\\x02\\x5F\\x35\\xFF\\x19\\x19\\x00\\x00\\x00\\x16\\x00\\x00\\x00\\x05\\x00\\x00\\xF5\\x02\\x02\\x5F\\x33\\x04\\xF3\\x02\\x02\\x5F\\x31\\x04\\xF1\\xFF\\x09\\x00\\x0C\\xFC\\x99\\x2C\\x23\\x45\\x15\\x60\"",
          "256:         } err",
          "257:         assert_match \"*Bad data format*\" $err",
          "258:         verify_log_message 0 \"*Ziplist integrity check failed*\" 0",
          "259:     }",
          "260: }",
          "262: test {corrupt payload: fuzzer findings - hash crash} {",
          "263:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "264:         r config set sanitize-dump-payload yes",
          "265:         r debug set-skip-checksum-validation 1",
          "266:         r RESTORE _hash 0 \"\\x0D\\x19\\x19\\x00\\x00\\x00\\x16\\x00\\x00\\x00\\x06\\x00\\x00\\xF1\\x02\\xF1\\x02\\xF2\\x02\\x02\\x5F\\x31\\x04\\xF3\\x02\\xF3\\xFF\\x09\\x00\\x38\\xB8\\x10\\xC0\\x8A\\xF9\\x16\\xDF\"",
          "267:         r HSET _hash 394891450 1635910264",
          "268:         r HMGET _hash 887312884855",
          "269:     }",
          "270: }",
          "272: test {corrupt payload: fuzzer findings - uneven entry count in hash} {",
          "273:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "274:         r config set sanitize-dump-payload no",
          "275:         r debug set-skip-checksum-validation 1",
          "276:         r RESTORE _hashbig 0 \"\\x0D\\x3D\\x3D\\x00\\x00\\x00\\x38\\x00\\x00\\x00\\x14\\x00\\x00\\xF2\\x02\\x02\\x5F\\x31\\x04\\x1C\\x02\\xF7\\x02\\xF1\\x02\\xF1\\x02\\xF5\\x02\\xF5\\x02\\xF4\\x02\\x02\\x5F\\x33\\x04\\xF6\\x02\\x02\\x5F\\x35\\x04\\xF8\\x02\\x02\\x5F\\x37\\x04\\xF9\\x02\\xF9\\x02\\xF3\\x02\\xF3\\x02\\xFA\\x02\\x02\\x5F\\x39\\xFF\\x09\\x00\\x73\\xB7\\x68\\xC8\\x97\\x24\\x8E\\x88\"",
          "277:         catch { r HSCAN _hashbig -250 }",
          "278:         assert_equal [count_log_message 0 \"crashed by signal\"] 0",
          "279:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "280:     }",
          "281: }",
          "283: test {corrupt payload: fuzzer findings - invalid read in lzf_decompress} {",
          "284:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "285:         r config set sanitize-dump-payload no",
          "286:         r debug set-skip-checksum-validation 1",
          "287:         catch { r RESTORE _setbig 0 \"\\x02\\x03\\x02\\x5F\\x31\\xC0\\x02\\xC3\\x00\\x09\\x00\\xE6\\xDC\\x76\\x44\\xFF\\xEB\\x3D\\xFE\" } err",
          "288:         assert_match \"*Bad data format*\" $err",
          "289:     }",
          "290: }",
          "292: test {corrupt payload: fuzzer findings - leak in rdbloading due to dup entry in set} {",
          "293:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "294:         r config set sanitize-dump-payload no",
          "295:         r debug set-skip-checksum-validation 1",
          "296:         catch { r RESTORE _setbig 0 \"\\x02\\x0A\\x02\\x5F\\x39\\xC0\\x06\\x02\\x5F\\x31\\xC0\\x00\\xC0\\x04\\x02\\x5F\\x35\\xC0\\x02\\xC0\\x08\\x02\\x5F\\x31\\x02\\x5F\\x33\\x09\\x00\\x7A\\x5A\\xFB\\x90\\x3A\\xE9\\x3C\\xBE\" } err",
          "297:         assert_match \"*Bad data format*\" $err",
          "298:     }",
          "299: }",
          "301: test {corrupt payload: fuzzer findings - empty intset div by zero} {",
          "302:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "303:         r config set sanitize-dump-payload no",
          "304:         r debug set-skip-checksum-validation 1",
          "305:         r RESTORE _setbig 0 \"\\x02\\xC0\\xC0\\x06\\x02\\x5F\\x39\\xC0\\x02\\x02\\x5F\\x33\\xC0\\x00\\x02\\x5F\\x31\\xC0\\x04\\xC0\\x08\\x02\\x5F\\x37\\x02\\x5F\\x35\\x09\\x00\\xC5\\xD4\\x6D\\xBA\\xAD\\x14\\xB7\\xE7\"",
          "306:         catch {r SRANDMEMBER _setbig }",
          "307:     }",
          "308: }",
          "310: test {corrupt payload: fuzzer findings - valgrind ziplist - crash report prints freed memory} {",
          "311:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "312:         r config set sanitize-dump-payload no",
          "313:         r debug set-skip-checksum-validation 1",
          "314:         r RESTORE _zsetbig 0 \"\\x0C\\x3D\\x3D\\x00\\x00\\x00\\x3A\\x00\\x00\\x00\\x14\\x00\\x00\\xF1\\x02\\xF1\\x02\\x02\\x5F\\x31\\x04\\xF2\\x02\\xF3\\x02\\xF3\\x02\\x02\\x5F\\x33\\x04\\xF4\\x02\\xEE\\x02\\xF5\\x02\\x02\\x5F\\x35\\x04\\xF6\\x02\\xF7\\x02\\xF7\\x02\\x02\\x5F\\x37\\x04\\xF8\\x02\\xF9\\x02\\xF9\\x02\\x02\\x5F\\x39\\x04\\xFA\\xFF\\x09\\x00\\xAE\\xF9\\x77\\x2A\\x47\\x24\\x33\\xF6\"",
          "315:         catch { r ZREMRANGEBYSCORE _zsetbig -1050966020 724 }",
          "316:         assert_equal [count_log_message 0 \"crashed by signal\"] 0",
          "317:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "318:     }",
          "319: }",
          "321: test {corrupt payload: fuzzer findings - valgrind ziplist prevlen reaches outside the ziplist} {",
          "322:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "323:         r config set sanitize-dump-payload no",
          "324:         r debug set-skip-checksum-validation 1",
          "325:         r RESTORE _listbig 0 \"\\x0E\\x02\\x1B\\x1B\\x00\\x00\\x00\\x16\\x00\\x00\\x00\\x05\\x00\\x00\\x02\\x5F\\x39\\x04\\xF9\\x02\\x02\\x5F\\x37\\x04\\xF7\\x02\\x02\\x5F\\x35\\xFF\\x19\\x19\\x00\\x00\\x00\\x16\\x00\\x00\\x00\\x05\\x00\\x00\\xF5\\x02\\x02\\x5F\\x33\\x04\\xF3\\x95\\x02\\x5F\\x31\\x04\\xF1\\xFF\\x09\\x00\\x0C\\xFC\\x99\\x2C\\x23\\x45\\x15\\x60\"",
          "326:         catch { r RPOP _listbig }",
          "327:         catch { r RPOP _listbig }",
          "328:         catch { r RPUSH _listbig 949682325 }",
          "329:         assert_equal [count_log_message 0 \"crashed by signal\"] 0",
          "330:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "331:     }",
          "332: }",
          "334: test {corrupt payload: fuzzer findings - valgrind - bad rdbLoadDoubleValue} {",
          "335:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "336:         r config set sanitize-dump-payload no",
          "337:         r debug set-skip-checksum-validation 1",
          "338:         catch { r RESTORE _list 0 \"\\x03\\x01\\x11\\x11\\x00\\x00\\x00\\x0A\\x00\\x00\\x00\\x01\\x00\\x00\\xD0\\x07\\x1A\\xE9\\x02\\xFF\\x09\\x00\\x1A\\x06\\x07\\x32\\x41\\x28\\x3A\\x46\" } err",
          "339:         assert_match \"*Bad data format*\" $err",
          "340:     }",
          "341: }",
          "343: test {corrupt payload: fuzzer findings - valgrind ziplist prev too big} {",
          "344:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "345:         r config set sanitize-dump-payload no",
          "346:         r debug set-skip-checksum-validation 1",
          "347:         r RESTORE _list 0 \"\\x0E\\x01\\x13\\x13\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x03\\x00\\x00\\xF3\\x02\\x02\\x5F\\x31\\xC1\\xF1\\xFF\\x09\\x00\\xC9\\x4B\\x31\\xFE\\x61\\xC0\\x96\\xFE\"",
          "348:         catch { r RPUSHX _list -45 }",
          "349:         catch { r LREM _list -748 -840}",
          "350:         assert_equal [count_log_message 0 \"crashed by signal\"] 0",
          "351:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "352:     }",
          "353: }",
          "355: test {corrupt payload: fuzzer findings - lzf decompression fails, avoid valgrind invalid read} {",
          "356:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "357:         r config set sanitize-dump-payload no",
          "358:         r debug set-skip-checksum-validation 1",
          "359:         catch {r RESTORE _stream 0 \"\\x0F\\x02\\x10\\x00\\x00\\x01\\x73\\xDD\\xAA\\x2A\\xB9\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xC3\\x40\\x4B\\x40\\x5C\\x18\\x5C\\x00\\x00\\x00\\x24\\x00\\x05\\x01\\x00\\x01\\x02\\x01\\x84\\x69\\x74\\x65\\x6D\\x05\\x85\\x76\\x61\\x6C\\x75\\x65\\x06\\x40\\x10\\x00\\x00\\x20\\x01\\x00\\x01\\x20\\x03\\x00\\x05\\x20\\x1C\\x40\\x07\\x05\\x01\\x01\\x82\\x5F\\x31\\x03\\x80\\x0D\\x40\\x00\\x00\\x02\\x60\\x19\\x40\\x27\\x40\\x19\\x00\\x33\\x60\\x19\\x40\\x29\\x02\\x01\\x01\\x04\\x20\\x19\\x00\\xFF\\x10\\x00\\x00\\x01\\x73\\xDD\\xAA\\x2A\\xBC\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xC3\\x40\\x4D\\x40\\x5E\\x18\\x5E\\x00\\x00\\x00\\x24\\x00\\x05\\x01\\x00\\x01\\x02\\x01\\x84\\x69\\x74\\x65\\x6D\\x05\\x85\\x76\\x61\\x6C\\x75\\x65\\x06\\x40\\x10\\x00\\x00\\x20\\x01\\x06\\x01\\x01\\x82\\x5F\\x35\\x03\\x05\\x20\\x1E\\x17\\x0B\\x03\\x01\\x01\\x06\\x01\\x40\\x0B\\x00\\x01\\x60\\x0D\\x02\\x82\\x5F\\x37\\x60\\x19\\x80\\x00\\x00\\x08\\x60\\x19\\x80\\x27\\x02\\x82\\x5F\\x39\\x20\\x19\\x00\\xFF\\x0A\\x81\\x00\\x00\\x01\\x73\\xDD\\xAA\\x2A\\xBE\\x00\\x00\\x09\\x00\\x21\\x85\\x77\\x43\\x71\\x7B\\x17\\x88\"} err",
          "360:         assert_match \"*Bad data format*\" $err",
          "361:     }",
          "362: }",
          "364: test {corrupt payload: fuzzer findings - stream bad lp_count} {",
          "365:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "366:         r config set sanitize-dump-payload yes",
          "367:         r debug set-skip-checksum-validation 1",
          "368:         catch { r RESTORE _stream 0 \"\\x0F\\x01\\x10\\x00\\x00\\x01\\x73\\xDE\\xDF\\x7D\\x9B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x42\\x42\\x00\\x00\\x00\\x18\\x00\\x03\\x01\\x00\\x01\\x02\\x01\\x84\\x69\\x74\\x65\\x6D\\x05\\x85\\x76\\x61\\x6C\\x75\\x65\\x06\\x00\\x01\\x02\\x01\\x00\\x01\\x00\\x01\\x01\\x01\\x00\\x01\\x56\\x01\\x02\\x01\\x22\\x01\\x00\\x01\\x01\\x01\\x82\\x5F\\x31\\x03\\x05\\x01\\x02\\x01\\x2C\\x01\\x00\\x01\\x01\\x01\\x02\\x01\\x05\\x01\\xFF\\x03\\x81\\x00\\x00\\x01\\x73\\xDE\\xDF\\x7D\\xC7\\x00\\x01\\x07\\x6D\\x79\\x67\\x72\\x6F\\x75\\x70\\x81\\x00\\x00\\x01\\x73\\xDE\\xDF\\x7D\\x9B\\x00\\x01\\x00\\x00\\x01\\x73\\xDE\\xDF\\x7D\\x9B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xF9\\x7D\\xDF\\xDE\\x73\\x01\\x00\\x00\\x01\\x01\\x05\\x41\\x6C\\x69\\x63\\x65\\xEB\\x7D\\xDF\\xDE\\x73\\x01\\x00\\x00\\x01\\x00\\x00\\x01\\x73\\xDE\\xDF\\x7D\\x9B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x00\\xB2\\xA8\\xA7\\x5F\\x1B\\x61\\x72\\xD5\"} err",
          "369:         assert_match \"*Bad data format*\" $err",
          "370:         r ping",
          "371:     }",
          "372: }",
          "374: test {corrupt payload: fuzzer findings - stream bad lp_count - unsanitized} {",
          "375:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "376:         r config set sanitize-dump-payload no",
          "377:         r debug set-skip-checksum-validation 1",
          "378:         r RESTORE _stream 0 \"\\x0F\\x01\\x10\\x00\\x00\\x01\\x73\\xDE\\xDF\\x7D\\x9B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x42\\x42\\x00\\x00\\x00\\x18\\x00\\x03\\x01\\x00\\x01\\x02\\x01\\x84\\x69\\x74\\x65\\x6D\\x05\\x85\\x76\\x61\\x6C\\x75\\x65\\x06\\x00\\x01\\x02\\x01\\x00\\x01\\x00\\x01\\x01\\x01\\x00\\x01\\x56\\x01\\x02\\x01\\x22\\x01\\x00\\x01\\x01\\x01\\x82\\x5F\\x31\\x03\\x05\\x01\\x02\\x01\\x2C\\x01\\x00\\x01\\x01\\x01\\x02\\x01\\x05\\x01\\xFF\\x03\\x81\\x00\\x00\\x01\\x73\\xDE\\xDF\\x7D\\xC7\\x00\\x01\\x07\\x6D\\x79\\x67\\x72\\x6F\\x75\\x70\\x81\\x00\\x00\\x01\\x73\\xDE\\xDF\\x7D\\x9B\\x00\\x01\\x00\\x00\\x01\\x73\\xDE\\xDF\\x7D\\x9B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xF9\\x7D\\xDF\\xDE\\x73\\x01\\x00\\x00\\x01\\x01\\x05\\x41\\x6C\\x69\\x63\\x65\\xEB\\x7D\\xDF\\xDE\\x73\\x01\\x00\\x00\\x01\\x00\\x00\\x01\\x73\\xDE\\xDF\\x7D\\x9B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x00\\xB2\\xA8\\xA7\\x5F\\x1B\\x61\\x72\\xD5\"",
          "379:         catch { r XREVRANGE _stream 638932639 738}",
          "380:         assert_equal [count_log_message 0 \"crashed by signal\"] 0",
          "381:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "382:     }",
          "383: }",
          "385: test {corrupt payload: fuzzer findings - stream integrity check issue} {",
          "386:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "387:         r config set sanitize-dump-payload yes",
          "388:         r debug set-skip-checksum-validation 1",
          "389:         catch { r RESTORE _stream 0 \"\\x0F\\x02\\x10\\x00\\x00\\x01\\x75\\x2D\\xA2\\x90\\x67\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xC3\\x40\\x4F\\x40\\x5C\\x18\\x5C\\x00\\x00\\x00\\x24\\x00\\x05\\x01\\x00\\x01\\x4A\\x01\\x84\\x69\\x74\\x65\\x6D\\x05\\x85\\x76\\x61\\x6C\\x75\\x65\\x06\\x40\\x10\\x00\\x00\\x20\\x01\\x00\\x01\\x20\\x03\\x00\\x05\\x20\\x1C\\x40\\x09\\x05\\x01\\x01\\x82\\x5F\\x31\\x03\\x80\\x0D\\x00\\x02\\x20\\x0D\\x00\\x02\\xA0\\x19\\x00\\x03\\x20\\x0B\\x02\\x82\\x5F\\x33\\xA0\\x19\\x00\\x04\\x20\\x0D\\x00\\x04\\x20\\x19\\x00\\xFF\\x10\\x00\\x00\\x01\\x75\\x2D\\xA2\\x90\\x67\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x05\\xC3\\x40\\x56\\x40\\x60\\x18\\x60\\x00\\x00\\x00\\x24\\x00\\x05\\x01\\x00\\x01\\x02\\x01\\x84\\x69\\x74\\x65\\x6D\\x05\\x85\\x76\\x61\\x6C\\x75\\x65\\x06\\x40\\x10\\x00\\x00\\x20\\x01\\x06\\x01\\x01\\x82\\x5F\\x35\\x03\\x05\\x20\\x1E\\x40\\x0B\\x03\\x01\\x01\\x06\\x01\\x80\\x0B\\x00\\x02\\x20\\x0B\\x02\\x82\\x5F\\x37\\x60\\x19\\x03\\x01\\x01\\xDF\\xFB\\x20\\x05\\x00\\x08\\x60\\x1A\\x20\\x0C\\x00\\xFC\\x20\\x05\\x02\\x82\\x5F\\x39\\x20\\x1B\\x00\\xFF\\x0A\\x81\\x00\\x00\\x01\\x75\\x2D\\xA2\\x90\\x68\\x01\\x00\\x09\\x00\\x1D\\x6F\\xC0\\x69\\x8A\\xDE\\xF7\\x92\" } err",
          "390:         assert_match \"*Bad data format*\" $err",
          "391:     }",
          "392: }",
          "394: test {corrupt payload: fuzzer findings - infinite loop} {",
          "395:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "396:         r config set sanitize-dump-payload no",
          "397:         r debug set-skip-checksum-validation 1",
          "398:         r RESTORE _stream 0 \"\\x0F\\x01\\x10\\x00\\x00\\x01\\x75\\x3A\\xA6\\xD0\\x93\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x42\\x42\\x00\\x00\\x00\\x18\\x00\\x03\\x01\\x00\\x01\\x02\\x01\\x84\\x69\\x74\\x65\\x6D\\x05\\x85\\x76\\x61\\x6C\\x75\\x65\\x06\\x00\\x01\\x02\\x01\\x00\\x01\\x00\\x01\\x01\\x01\\x00\\x01\\x05\\x01\\x02\\x01\\x00\\x01\\x01\\x01\\x01\\x01\\x82\\x5F\\x31\\x03\\xFD\\x01\\x02\\x01\\x00\\x01\\x02\\x01\\x01\\x01\\x02\\x01\\x05\\x01\\xFF\\x03\\x81\\x00\\x00\\x01\\x75\\x3A\\xA6\\xD0\\x93\\x02\\x01\\x07\\x6D\\x79\\x67\\x72\\x6F\\x75\\x70\\x81\\x00\\x00\\x01\\x75\\x3A\\xA6\\xD0\\x93\\x00\\x01\\x00\\x00\\x01\\x75\\x3A\\xA6\\xD0\\x93\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x94\\xD0\\xA6\\x3A\\x75\\x01\\x00\\x00\\x01\\x01\\x05\\x41\\x6C\\x69\\x63\\x65\\x94\\xD0\\xA6\\x3A\\x75\\x01\\x00\\x00\\x01\\x00\\x00\\x01\\x75\\x3A\\xA6\\xD0\\x93\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x00\\xC4\\x09\\xAD\\x69\\x7E\\xEE\\xA6\\x2F\"",
          "399:         catch { r XREVRANGE _stream 288270516 971031845 }",
          "400:         assert_equal [count_log_message 0 \"crashed by signal\"] 0",
          "401:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "402:     }",
          "403: }",
          "405: test {corrupt payload: fuzzer findings - invalid tail offset after removal} {",
          "406:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "407:         r config set sanitize-dump-payload no",
          "408:         r debug set-skip-checksum-validation 1",
          "409:         r RESTORE _zset 0 \"\\x0C\\x19\\x19\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x06\\x00\\x00\\xF1\\x02\\xF1\\x02\\x02\\x5F\\x31\\x04\\xF2\\x02\\xF3\\x02\\xF3\\xFF\\x09\\x00\\x4D\\x72\\x7B\\x97\\xCD\\x9A\\x70\\xC1\"",
          "410:         catch {r ZPOPMIN _zset}",
          "411:         catch {r ZPOPMAX _zset}",
          "412:         assert_equal [count_log_message 0 \"crashed by signal\"] 0",
          "413:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "414:     }",
          "415: }",
          "417: test {corrupt payload: fuzzer findings - negative reply length} {",
          "418:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "419:         r config set sanitize-dump-payload no",
          "420:         r debug set-skip-checksum-validation 1",
          "421:         r RESTORE _stream 0 \"\\x0F\\x01\\x10\\x00\\x00\\x01\\x75\\xCF\\xA1\\x16\\xA7\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x42\\x42\\x00\\x00\\x00\\x18\\x00\\x03\\x01\\x00\\x01\\x02\\x01\\x84\\x69\\x74\\x65\\x6D\\x05\\x85\\x76\\x61\\x6C\\x75\\x65\\x06\\x00\\x01\\x02\\x01\\x00\\x01\\x00\\x01\\x01\\x01\\x00\\x01\\x05\\x01\\x02\\x01\\x00\\x01\\x01\\x01\\x01\\x01\\x14\\x5F\\x31\\x03\\x05\\x01\\x02\\x01\\x00\\x01\\x02\\x01\\x01\\x01\\x02\\x01\\x05\\x01\\xFF\\x03\\x81\\x00\\x00\\x01\\x75\\xCF\\xA1\\x16\\xA7\\x02\\x01\\x07\\x6D\\x79\\x67\\x72\\x6F\\x75\\x70\\x81\\x00\\x00\\x01\\x75\\xCF\\xA1\\x16\\xA7\\x01\\x01\\x00\\x00\\x01\\x75\\xCF\\xA1\\x16\\xA7\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xA7\\x16\\xA1\\xCF\\x75\\x01\\x00\\x00\\x01\\x01\\x05\\x41\\x6C\\x69\\x63\\x65\\xA7\\x16\\xA1\\xCF\\x75\\x01\\x00\\x00\\x01\\x00\\x00\\x01\\x75\\xCF\\xA1\\x16\\xA7\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x09\\x00\\x1B\\x42\\x52\\xB8\\xDD\\x5C\\xE5\\x4E\"",
          "422:         catch {r XADD _stream * -956 -2601503852}",
          "423:         catch {r XINFO STREAM _stream FULL}",
          "424:         assert_equal [count_log_message 0 \"crashed by signal\"] 0",
          "425:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "426:     }",
          "427: }",
          "429: test {corrupt payload: fuzzer findings - valgrind negative malloc} {",
          "430:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "431:         r config set sanitize-dump-payload yes",
          "432:         r debug set-skip-checksum-validation 1",
          "433:         catch {r RESTORE _key 0 \"\\x0E\\x01\\x81\\xD6\\xD6\\x00\\x00\\x00\\x0A\\x00\\x00\\x00\\x01\\x00\\x00\\x40\\xC8\\x6F\\x2F\\x36\\xE2\\xDF\\xE3\\x2E\\x26\\x64\\x8B\\x87\\xD1\\x7A\\xBD\\xFF\\xEF\\xEF\\x63\\x65\\xF6\\xF8\\x8C\\x4E\\xEC\\x96\\x89\\x56\\x88\\xF8\\x3D\\x96\\x5A\\x32\\xBD\\xD1\\x36\\xD8\\x02\\xE6\\x66\\x37\\xCB\\x34\\x34\\xC4\\x52\\xA7\\x2A\\xD5\\x6F\\x2F\\x7E\\xEE\\xA2\\x94\\xD9\\xEB\\xA9\\x09\\x38\\x3B\\xE1\\xA9\\x60\\xB6\\x4E\\x09\\x44\\x1F\\x70\\x24\\xAA\\x47\\xA8\\x6E\\x30\\xE1\\x13\\x49\\x4E\\xA1\\x92\\xC4\\x6C\\xF0\\x35\\x83\\xD9\\x4F\\xD9\\x9C\\x0A\\x0D\\x7A\\xE7\\xB1\\x61\\xF5\\xC1\\x2D\\xDC\\xC3\\x0E\\x87\\xA6\\x80\\x15\\x18\\xBA\\x7F\\x72\\xDD\\x14\\x75\\x46\\x44\\x0B\\xCA\\x9C\\x8F\\x1C\\x3C\\xD7\\xDA\\x06\\x62\\x18\\x7E\\x15\\x17\\x24\\xAB\\x45\\x21\\x27\\xC2\\xBC\\xBB\\x86\\x6E\\xD8\\xBD\\x8E\\x50\\xE0\\xE0\\x88\\xA4\\x9B\\x9D\\x15\\x2A\\x98\\xFF\\x5E\\x78\\x6C\\x81\\xFC\\xA8\\xC9\\xC8\\xE6\\x61\\xC8\\xD1\\x4A\\x7F\\x81\\xD6\\xA6\\x1A\\xAD\\x4C\\xC1\\xA2\\x1C\\x90\\x68\\x15\\x2A\\x8A\\x36\\xC0\\x58\\xC3\\xCC\\xA6\\x54\\x19\\x12\\x0F\\xEB\\x46\\xFF\\x6E\\xE3\\xA7\\x92\\xF8\\xFF\\x09\\x00\\xD0\\x71\\xF7\\x9F\\xF7\\x6A\\xD6\\x2E\"} err",
          "434:         assert_match \"*Bad data format*\" $err",
          "435:         r ping",
          "436:     }",
          "437: }",
          "",
          "---------------"
        ],
        "tests/integration/psync2.tcl||tests/integration/psync2.tcl": [
          "File: tests/integration/psync2.tcl -> tests/integration/psync2.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "280:         set sync_partial_err [status $R($master_id) sync_partial_err]",
          "281:         catch {",
          "282:             $R($slave_id) config rewrite",
          "284:             set R($slave_id) [srv [expr {0-$slave_id}] client]",
          "285:         }",
          "286:         # note: just waiting for connected_slaves==4 has a race condition since",
          "",
          "[Removed Lines]",
          "283:             restart_server [expr {0-$slave_id}] true",
          "",
          "[Added Lines]",
          "283:             restart_server [expr {0-$slave_id}] true false",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "330:         catch {",
          "331:             $R($slave_id) config rewrite",
          "333:             set R($slave_id) [srv [expr {0-$slave_id}] client]",
          "334:         }",
          "",
          "[Removed Lines]",
          "332:             restart_server [expr {0-$slave_id}] true",
          "",
          "[Added Lines]",
          "332:             restart_server [expr {0-$slave_id}] true false",
          "",
          "---------------"
        ],
        "tests/integration/rdb.tcl||tests/integration/rdb.tcl": [
          "File: tests/integration/rdb.tcl -> tests/integration/rdb.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "164:         # 100mb of rdb, 100k keys will load in more than 1 second",
          "165:         r debug populate 100000 key 1000",
          "169:         # make sure it's still loading",
          "170:         assert_equal [s loading] 1",
          "",
          "[Removed Lines]",
          "167:         restart_server 0 false",
          "",
          "[Added Lines]",
          "167:         restart_server 0 false false",
          "",
          "---------------"
        ],
        "tests/support/server.tcl||tests/support/server.tcl": [
          "File: tests/support/server.tcl -> tests/support/server.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: }",
          "15: proc check_valgrind_errors stderr {",
          "17:     if {$res != \"\"} {",
          "18:         send_data_packet $::test_server_fd err \"Valgrind error: $res\\n\"",
          "19:     }",
          "",
          "[Removed Lines]",
          "16:     set res [find_valgrind_errors $stderr]",
          "",
          "[Added Lines]",
          "16:     set res [find_valgrind_errors $stderr true]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "438:         while 1 {",
          "439:             # check that the server actually started and is ready for connections",
          "441:                 break",
          "442:             }",
          "443:             after 10",
          "",
          "[Removed Lines]",
          "440:             if {[exec grep -i \"Ready to accept\" | wc -l < $stdout] > 0} {",
          "",
          "[Added Lines]",
          "440:             if {[count_message_lines $stdout \"Ready to accept\"] > 0} {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "511:     }",
          "512: }",
          "515:     set srv [lindex $::servers end+$level]",
          "516:     kill_server $srv",
          "518:     set stdout [dict get $srv \"stdout\"]",
          "519:     set stderr [dict get $srv \"stderr\"]",
          "522:     # if we're inside a test, write the test name to the server log file",
          "523:     if {[info exists ::cur_test]} {",
          "",
          "[Removed Lines]",
          "514: proc restart_server {level wait_ready} {",
          "520:     set config_file [dict get $srv \"config_file\"]",
          "",
          "[Added Lines]",
          "514: proc restart_server {level wait_ready rotate_logs} {",
          "518:     set pid [dict get $srv \"pid\"]",
          "521:     if {$rotate_logs} {",
          "522:         set ts [clock format [clock seconds] -format %y%m%d%H%M%S]",
          "523:         file rename $stdout $stdout.$ts.$pid",
          "524:         file rename $stderr $stderr.$ts.$pid",
          "525:     }",
          "526:     set prev_ready_count [count_message_lines $stdout \"Ready to accept\"]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "526:         close $fd",
          "527:     }",
          "531:     set pid [spawn_server $config_file $stdout $stderr]",
          "",
          "[Removed Lines]",
          "529:     set prev_ready_count [exec grep -i \"Ready to accept\" | wc -l < $stdout]",
          "",
          "[Added Lines]",
          "535:     set config_file [dict get $srv \"config_file\"]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "541:     if {$wait_ready} {",
          "542:         while 1 {",
          "543:             # check that the server actually started and is ready for connections",
          "545:                 break",
          "546:             }",
          "547:             after 10",
          "",
          "[Removed Lines]",
          "544:             if {[exec grep -i \"Ready to accept\" | wc -l < $stdout] > $prev_ready_count + 1} {",
          "",
          "[Added Lines]",
          "550:             if {[count_message_lines $stdout \"Ready to accept\"] > $prev_ready_count} {",
          "",
          "---------------"
        ],
        "tests/support/util.tcl||tests/support/util.tcl": [
          "File: tests/support/util.tcl -> tests/support/util.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "454:     }",
          "455: }",
          "458:     set fd [open $stderr]",
          "459:     set buf [read $fd]",
          "460:     close $fd",
          "462:     # Look for stack trace (\" at 0x\") and other errors (Invalid, Mismatched, etc).",
          "463:     # Look for \"Warnings\", but not the \"set address range perms\". These don't indicate any real concern.",
          "465:     if {[regexp -- { at 0x} $buf] ||",
          "466:         [regexp -- {^(?=.*Warning)(?:(?!set address range perms).)*$} $buf] ||",
          "467:         [regexp -- {Invalid} $buf] ||",
          "468:         [regexp -- {Mismatched} $buf] ||",
          "469:         [regexp -- {uninitialized} $buf] ||",
          "470:         [regexp -- {has a fishy} $buf] ||",
          "473:          ![regexp -- {no leaks are possible} $buf])} {",
          "474:         return $buf",
          "475:     }",
          "",
          "[Removed Lines]",
          "457: proc find_valgrind_errors {stderr} {",
          "464:     # Look for the absense of a leak free summary (happens when redis isn't terminated properly).",
          "471:         [regexp -- {overlap} $buf] ||",
          "472:         (![regexp -- {definitely lost: 0 bytes} $buf] &&",
          "",
          "[Added Lines]",
          "457: proc find_valgrind_errors {stderr on_termination} {",
          "464:     # corrupt-dump unit, not sure why but it seems they don't indicate any real concern.",
          "471:         [regexp -- {overlap} $buf]} {",
          "472:         return $buf",
          "473:     }",
          "475:     # If the process didn't terminate yet, we can't look for the summary report",
          "476:     if {!$on_termination} {",
          "477:         return \"\"",
          "478:     }",
          "480:     # Look for the absense of a leak free summary (happens when redis isn't terminated properly).",
          "481:     if {(![regexp -- {definitely lost: 0 bytes} $buf] &&",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "547:         set _ $value",
          "548:     }",
          "549: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "560: proc generate_fuzzy_traffic_on_key {key duration} {",
          "561:     # Commands per type, blocking commands removed",
          "562:     # TODO: extract these from help.h or elsewhere, and improve to include other types",
          "563:     set string_commands {APPEND BITCOUNT BITFIELD BITOP BITPOS DECR DECRBY GET GETBIT GETRANGE GETSET INCR INCRBY INCRBYFLOAT MGET MSET MSETNX PSETEX SET SETBIT SETEX SETNX SETRANGE STRALGO STRLEN}",
          "564:     set hash_commands {HDEL HEXISTS HGET HGETALL HINCRBY HINCRBYFLOAT HKEYS HLEN HMGET HMSET HSCAN HSET HSETNX HSTRLEN HVALS}",
          "565:     set zset_commands {ZADD ZCARD ZCOUNT ZINCRBY ZINTERSTORE ZLEXCOUNT ZPOPMAX ZPOPMIN ZRANGE ZRANGEBYLEX ZRANGEBYSCORE ZRANK ZREM ZREMRANGEBYLEX ZREMRANGEBYRANK ZREMRANGEBYSCORE ZREVRANGE ZREVRANGEBYLEX ZREVRANGEBYSCORE ZREVRANK ZSCAN ZSCORE ZUNIONSTORE}",
          "566:     set list_commands {LINDEX LINSERT LLEN LPOP LPOS LPUSH LPUSHX LRANGE LREM LSET LTRIM RPOP RPOPLPUSH RPUSH RPUSHX}",
          "567:     set set_commands {SADD SCARD SDIFF SDIFFSTORE SINTER SINTERSTORE SISMEMBER SMEMBERS SMOVE SPOP SRANDMEMBER SREM SSCAN SUNION SUNIONSTORE}",
          "568:     set stream_commands {XACK XADD XCLAIM XDEL XGROUP XINFO XLEN XPENDING XRANGE XREAD XREADGROUP XREVRANGE XTRIM}",
          "569:     set commands [dict create string $string_commands hash $hash_commands zset $zset_commands list $list_commands set $set_commands stream $stream_commands]",
          "571:     set type [r type $key]",
          "572:     set cmds [dict get $commands $type]",
          "573:     set start_time [clock seconds]",
          "574:     set sent {}",
          "575:     set succeeded 0",
          "576:     while {([clock seconds]-$start_time) < $duration} {",
          "577:         # find a random command for our key type",
          "578:         set cmd_idx [expr {int(rand()*[llength $cmds])}]",
          "579:         set cmd [lindex $cmds $cmd_idx]",
          "580:         # get the command details from redis",
          "581:         if { [ catch {",
          "582:             set cmd_info [lindex [r command info $cmd] 0]",
          "583:         } err ] } {",
          "584:             # if we failed, it means redis crashed after the previous command",
          "585:             return $sent",
          "586:         }",
          "587:         # try to build a valid command argument",
          "588:         set arity [lindex $cmd_info 1]",
          "589:         set arity [expr $arity < 0 ? - $arity: $arity]",
          "590:         set firstkey [lindex $cmd_info 3]",
          "591:         set i 1",
          "592:         if {$cmd == \"XINFO\"} {",
          "593:             lappend cmd \"STREAM\"",
          "594:             lappend cmd $key",
          "595:             lappend cmd \"FULL\"",
          "596:             incr i 3",
          "597:         }",
          "598:         if {$cmd == \"XREAD\"} {",
          "599:             lappend cmd \"STREAMS\"",
          "600:             lappend cmd $key",
          "601:             randpath {",
          "602:                 lappend cmd \\$",
          "603:             } {",
          "604:                 lappend cmd [randomValue]",
          "605:             }",
          "606:             incr i 3",
          "607:         }",
          "608:         if {$cmd == \"XADD\"} {",
          "609:             lappend cmd $key",
          "610:             randpath {",
          "611:                 lappend cmd \"*\"",
          "612:             } {",
          "613:                 lappend cmd [randomValue]",
          "614:             }",
          "615:             lappend cmd [randomValue]",
          "616:             lappend cmd [randomValue]",
          "617:             incr i 4",
          "618:         }",
          "619:         for {} {$i < $arity} {incr i} {",
          "620:             if {$i == $firstkey} {",
          "621:                 lappend cmd $key",
          "622:             } else {",
          "623:                 lappend cmd [randomValue]",
          "624:             }",
          "625:         }",
          "626:         # execute the command, we expect commands to fail on syntax errors",
          "627:         lappend sent $cmd",
          "628:         if { ! [ catch {",
          "629:             r {*}$cmd",
          "630:         } err ] } {",
          "631:             incr succeeded",
          "632:         }",
          "633:     }",
          "635:     # print stats so that we know if we managed to generate commands that actually made senes",
          "636:     #if {$::verbose} {",
          "637:     #    set count [llength $sent]",
          "638:     #    puts \"Fuzzy traffic sent: $count, succeeded: $succeeded\"",
          "639:     #}",
          "641:     # return the list of commands we sent",
          "642:     return $sent",
          "643: }",
          "645: # write line to server log file",
          "646: proc write_log_line {srv_idx msg} {",
          "647:     set logfile [srv $srv_idx stdout]",
          "648:     set fd [open $logfile \"a+\"]",
          "649:     puts $fd \"### $msg\"",
          "650:     close $fd",
          "651: }",
          "653: proc string2printable s {",
          "654:     set res {}",
          "655:     set has_special_chars false",
          "656:     foreach i [split $s {}] {",
          "657:         scan $i %c int",
          "658:         # non printable characters, including space and excluding: \" \\ $ { }",
          "659:         if {$int < 32 || $int > 122 || $int == 34 || $int == 36 || $int == 92} {",
          "660:             set has_special_chars true",
          "661:         }",
          "662:         # TCL8.5 has issues mixing \\x notation and normal chars in the same",
          "663:         # source code string, so we'll convert the entire string.",
          "664:         append res \\\\x[format %02X $int]",
          "665:     }",
          "666:     if {!$has_special_chars} {",
          "667:         return $s",
          "668:     }",
          "669:     set res \"\\\"$res\\\"\"",
          "670:     return $res",
          "671: }",
          "",
          "---------------"
        ],
        "tests/test_helper.tcl||tests/test_helper.tcl": [
          "File: tests/test_helper.tcl -> tests/test_helper.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "45:     integration/aof",
          "46:     integration/rdb",
          "47:     integration/corrupt-dump",
          "48:     integration/convert-zipmap-hash-on-load",
          "49:     integration/logging",
          "50:     integration/psync2",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "48:     integration/corrupt-dump-fuzzer",
          "",
          "---------------"
        ],
        "tests/unit/introspection.tcl||tests/unit/introspection.tcl": [
          "File: tests/unit/introspection.tcl -> tests/unit/introspection.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "160:         # Rewrite entire configuration, restart and confirm the",
          "161:         # server is able to parse it and start.",
          "162:         assert_equal [r debug config-rewrite-force-all] \"OK\"",
          "164:         assert_equal [r ping] \"PONG\"",
          "166:         # Verify no changes were introduced",
          "",
          "[Removed Lines]",
          "163:         restart_server 0 0",
          "",
          "[Added Lines]",
          "163:         restart_server 0 false false",
          "",
          "---------------"
        ]
      }
    }
  ]
}
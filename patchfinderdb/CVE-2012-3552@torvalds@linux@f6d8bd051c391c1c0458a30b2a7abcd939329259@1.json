{
  "cve_id": "CVE-2012-3552",
  "cve_desc": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
  "repo": "torvalds/linux",
  "patch_hash": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
  "patch_info": {
    "commit_hash": "f6d8bd051c391c1c0458a30b2a7abcd939329259",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
    "files": [
      "include/net/inet_sock.h",
      "include/net/ip.h",
      "net/dccp/ipv4.c",
      "net/dccp/ipv6.c",
      "net/ipv4/af_inet.c",
      "net/ipv4/cipso_ipv4.c",
      "net/ipv4/icmp.c",
      "net/ipv4/inet_connection_sock.c",
      "net/ipv4/ip_options.c",
      "net/ipv4/ip_output.c",
      "net/ipv4/ip_sockglue.c",
      "net/ipv4/raw.c",
      "net/ipv4/syncookies.c",
      "net/ipv4/tcp_ipv4.c",
      "net/ipv4/udp.c",
      "net/ipv6/tcp_ipv6.c",
      "net/l2tp/l2tp_ip.c"
    ],
    "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "include/net/inet_sock.h||include/net/inet_sock.h",
      "include/net/ip.h||include/net/ip.h",
      "net/dccp/ipv4.c||net/dccp/ipv4.c",
      "net/dccp/ipv6.c||net/dccp/ipv6.c",
      "net/ipv4/af_inet.c||net/ipv4/af_inet.c",
      "net/ipv4/cipso_ipv4.c||net/ipv4/cipso_ipv4.c",
      "net/ipv4/icmp.c||net/ipv4/icmp.c",
      "net/ipv4/inet_connection_sock.c||net/ipv4/inet_connection_sock.c",
      "net/ipv4/ip_options.c||net/ipv4/ip_options.c",
      "net/ipv4/ip_output.c||net/ipv4/ip_output.c",
      "net/ipv4/ip_sockglue.c||net/ipv4/ip_sockglue.c",
      "net/ipv4/raw.c||net/ipv4/raw.c",
      "net/ipv4/syncookies.c||net/ipv4/syncookies.c",
      "net/ipv4/tcp_ipv4.c||net/ipv4/tcp_ipv4.c",
      "net/ipv4/udp.c||net/ipv4/udp.c",
      "net/ipv6/tcp_ipv6.c||net/ipv6/tcp_ipv6.c",
      "net/l2tp/l2tp_ip.c||net/l2tp/l2tp_ip.c"
    ]
  },
  "patch_diff": {
    "include/net/inet_sock.h||include/net/inet_sock.h": [
      "File: include/net/inet_sock.h -> include/net/inet_sock.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "57:  unsigned char __data[0];",
      "58: };",
      "62: struct inet_request_sock {",
      "63:  struct request_sock req;",
      "",
      "[Removed Lines]",
      "60: #define optlength(opt) (sizeof(struct ip_options) + opt->optlen)",
      "",
      "[Added Lines]",
      "60: struct ip_options_rcu {",
      "61:  struct rcu_head rcu;",
      "62:  struct ip_options opt;",
      "63: };",
      "65: struct ip_options_data {",
      "66:  struct ip_options_rcu opt;",
      "67:  char   data[40];",
      "68: };",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "78:     acked    : 1,",
      "79:     no_srccheck: 1;",
      "80:  kmemcheck_bitfield_end(flags);",
      "82: };",
      "84: static inline struct inet_request_sock *inet_rsk(const struct request_sock *sk)",
      "",
      "[Removed Lines]",
      "81:  struct ip_options *opt;",
      "",
      "[Added Lines]",
      "89:  struct ip_options_rcu *opt;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "140:  __be16   inet_sport;",
      "141:  __u16   inet_id;",
      "144:  __u8   tos;",
      "145:  __u8   min_ttl;",
      "146:  __u8   mc_ttl;",
      "",
      "[Removed Lines]",
      "143:  struct ip_options *opt;",
      "",
      "[Added Lines]",
      "151:  struct ip_options_rcu __rcu *inet_opt;",
      "",
      "---------------"
    ],
    "include/net/ip.h||include/net/ip.h": [
      "File: include/net/ip.h -> include/net/ip.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "52: struct ipcm_cookie {",
      "53:  __be32   addr;",
      "54:  int   oif;",
      "56:  __u8   tx_flags;",
      "57: };",
      "",
      "[Removed Lines]",
      "55:  struct ip_options *opt;",
      "",
      "[Added Lines]",
      "55:  struct ip_options_rcu *opt;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "93: extern int  ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,",
      "94:            __be32 saddr, __be32 daddr,",
      "96: extern int  ip_rcv(struct sk_buff *skb, struct net_device *dev,",
      "97:           struct packet_type *pt, struct net_device *orig_dev);",
      "98: extern int  ip_local_deliver(struct sk_buff *skb);",
      "",
      "[Removed Lines]",
      "95:            struct ip_options *opt);",
      "",
      "[Added Lines]",
      "95:            struct ip_options_rcu *opt);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "420: extern int ip_options_echo(struct ip_options *dopt, struct sk_buff *skb);",
      "421: extern void ip_options_fragment(struct sk_buff *skb);",
      "422: extern int ip_options_compile(struct net *net,",
      "423:          struct ip_options *opt, struct sk_buff *skb);",
      "425:      unsigned char *data, int optlen);",
      "427:         unsigned char __user *data, int optlen);",
      "428: extern void ip_options_undo(struct ip_options * opt);",
      "429: extern void ip_forward_options(struct sk_buff *skb);",
      "",
      "[Removed Lines]",
      "419: extern void ip_options_build(struct sk_buff *skb, struct ip_options *opt, __be32 daddr, struct rtable *rt, int is_frag);",
      "424: extern int ip_options_get(struct net *net, struct ip_options **optp,",
      "426: extern int ip_options_get_from_user(struct net *net, struct ip_options **optp,",
      "",
      "[Added Lines]",
      "419: extern void ip_options_build(struct sk_buff *skb, struct ip_options *opt,",
      "420:         __be32 daddr, struct rtable *rt, int is_frag);",
      "425: extern int ip_options_get(struct net *net, struct ip_options_rcu **optp,",
      "427: extern int ip_options_get_from_user(struct net *net, struct ip_options_rcu **optp,",
      "",
      "---------------"
    ],
    "net/dccp/ipv4.c||net/dccp/ipv4.c": [
      "File: net/dccp/ipv4.c -> net/dccp/ipv4.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "48:  struct flowi4 fl4;",
      "49:  struct rtable *rt;",
      "50:  int err;",
      "52:  dp->dccps_role = DCCP_ROLE_CLIENT;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "51:  struct ip_options_rcu *inet_opt;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "58:   return -EAFNOSUPPORT;",
      "60:  nexthop = daddr = usin->sin_addr.s_addr;",
      "62:   if (daddr == 0)",
      "63:    return -EINVAL;",
      "65:  }",
      "67:  orig_sport = inet->inet_sport;",
      "",
      "[Removed Lines]",
      "61:  if (inet->opt != NULL && inet->opt->srr) {",
      "64:   nexthop = inet->opt->faddr;",
      "",
      "[Added Lines]",
      "63:  inet_opt = rcu_dereference_protected(inet->inet_opt,",
      "64:           sock_owned_by_user(sk));",
      "65:  if (inet_opt != NULL && inet_opt->opt.srr) {",
      "68:   nexthop = inet_opt->opt.faddr;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "78:   return -ENETUNREACH;",
      "79:  }",
      "82:   daddr = rt->rt_dst;",
      "84:  if (inet->inet_saddr == 0)",
      "",
      "[Removed Lines]",
      "81:  if (inet->opt == NULL || !inet->opt->srr)",
      "",
      "[Added Lines]",
      "85:  if (inet_opt == NULL || !inet_opt->opt.srr)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "89:  inet->inet_daddr = daddr;",
      "91:  inet_csk(sk)->icsk_ext_hdr_len = 0;",
      "",
      "[Removed Lines]",
      "92:  if (inet->opt != NULL)",
      "93:   inet_csk(sk)->icsk_ext_hdr_len = inet->opt->optlen;",
      "",
      "[Added Lines]",
      "96:  if (inet_opt)",
      "97:   inet_csk(sk)->icsk_ext_hdr_len = inet_opt->opt.optlen;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "405:  newinet->inet_daddr = ireq->rmt_addr;",
      "406:  newinet->inet_rcv_saddr = ireq->loc_addr;",
      "407:  newinet->inet_saddr = ireq->loc_addr;",
      "409:  ireq->opt    = NULL;",
      "410:  newinet->mc_index  = inet_iif(skb);",
      "411:  newinet->mc_ttl    = ip_hdr(skb)->ttl;",
      "",
      "[Removed Lines]",
      "408:  newinet->opt    = ireq->opt;",
      "",
      "[Added Lines]",
      "412:  newinet->inet_opt = ireq->opt;",
      "",
      "---------------"
    ],
    "net/dccp/ipv6.c||net/dccp/ipv6.c": [
      "File: net/dccp/ipv6.c -> net/dccp/ipv6.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "574:     First: no IPv4 options.",
      "579:  newnp->rxopt.all = np->rxopt.all;",
      "",
      "[Removed Lines]",
      "576:  newinet->opt = NULL;",
      "",
      "[Added Lines]",
      "576:  newinet->inet_opt = NULL;",
      "",
      "---------------"
    ],
    "net/ipv4/af_inet.c||net/ipv4/af_inet.c": [
      "File: net/ipv4/af_inet.c -> net/ipv4/af_inet.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "153:  WARN_ON(sk->sk_wmem_queued);",
      "154:  WARN_ON(sk->sk_forward_alloc);",
      "157:  dst_release(rcu_dereference_check(sk->sk_dst_cache, 1));",
      "158:  sk_refcnt_debug_dec(sk);",
      "159: }",
      "",
      "[Removed Lines]",
      "156:  kfree(inet->opt);",
      "",
      "[Added Lines]",
      "156:  kfree(rcu_dereference_protected(inet->inet_opt, 1));",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1106:  struct flowi4 fl4;",
      "1107:  struct rtable *rt;",
      "1108:  __be32 new_saddr;",
      "1114:  rt = ip_route_connect(&fl4, daddr, 0, RT_CONN_FLAGS(sk),",
      "",
      "[Removed Lines]",
      "1110:  if (inet->opt && inet->opt->srr)",
      "1111:   daddr = inet->opt->faddr;",
      "",
      "[Added Lines]",
      "1109:  struct ip_options_rcu *inet_opt;",
      "1111:  inet_opt = rcu_dereference_protected(inet->inet_opt,",
      "1112:           sock_owned_by_user(sk));",
      "1113:  if (inet_opt && inet_opt->opt.srr)",
      "1114:   daddr = inet_opt->opt.faddr;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1148:  struct inet_sock *inet = inet_sk(sk);",
      "1149:  struct rtable *rt = (struct rtable *)__sk_dst_check(sk, 0);",
      "1150:  __be32 daddr;",
      "1151:  int err;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1154:  struct ip_options_rcu *inet_opt;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1155:   return 0;",
      "1158:  daddr = inet->inet_daddr;",
      "1161:  rt = ip_route_output_ports(sock_net(sk), sk, daddr, inet->inet_saddr,",
      "1162:        inet->inet_dport, inet->inet_sport,",
      "1163:        sk->sk_protocol, RT_CONN_FLAGS(sk),",
      "",
      "[Removed Lines]",
      "1159:  if (inet->opt && inet->opt->srr)",
      "1160:   daddr = inet->opt->faddr;",
      "",
      "[Added Lines]",
      "1162:  rcu_read_lock();",
      "1163:  inet_opt = rcu_dereference(inet->inet_opt);",
      "1165:  if (inet_opt && inet_opt->opt.srr)",
      "1166:   daddr = inet_opt->opt.faddr;",
      "1167:  rcu_read_unlock();",
      "",
      "---------------"
    ],
    "net/ipv4/cipso_ipv4.c||net/ipv4/cipso_ipv4.c": [
      "File: net/ipv4/cipso_ipv4.c -> net/ipv4/cipso_ipv4.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1857:  return CIPSO_V4_HDR_LEN + ret_val;",
      "1858: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1860: static void opt_kfree_rcu(struct rcu_head *head)",
      "1861: {",
      "1862:  kfree(container_of(head, struct ip_options_rcu, rcu));",
      "1863: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1879:  unsigned char *buf = NULL;",
      "1880:  u32 buf_len;",
      "1881:  u32 opt_len;",
      "1883:  struct inet_sock *sk_inet;",
      "1884:  struct inet_connection_sock *sk_conn;",
      "",
      "[Removed Lines]",
      "1882:  struct ip_options *opt = NULL;",
      "",
      "[Added Lines]",
      "1887:  struct ip_options_rcu *old, *opt = NULL;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1915:   ret_val = -ENOMEM;",
      "1916:   goto socket_setattr_failure;",
      "1917:  }",
      "1921:  kfree(buf);",
      "1922:  buf = NULL;",
      "1924:  sk_inet = inet_sk(sk);",
      "1925:  if (sk_inet->is_icsk) {",
      "1926:   sk_conn = inet_csk(sk);",
      "1930:   sk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);",
      "1931:  }",
      "1935:  return 0;",
      "",
      "[Removed Lines]",
      "1918:  memcpy(opt->__data, buf, buf_len);",
      "1919:  opt->optlen = opt_len;",
      "1920:  opt->cipso = sizeof(struct iphdr);",
      "1927:   if (sk_inet->opt)",
      "1928:    sk_conn->icsk_ext_hdr_len -= sk_inet->opt->optlen;",
      "1929:   sk_conn->icsk_ext_hdr_len += opt->optlen;",
      "1932:  opt = xchg(&sk_inet->opt, opt);",
      "1933:  kfree(opt);",
      "",
      "[Added Lines]",
      "1923:  memcpy(opt->opt.__data, buf, buf_len);",
      "1924:  opt->opt.optlen = opt_len;",
      "1925:  opt->opt.cipso = sizeof(struct iphdr);",
      "1931:  old = rcu_dereference_protected(sk_inet->inet_opt, sock_owned_by_user(sk));",
      "1934:   if (old)",
      "1935:    sk_conn->icsk_ext_hdr_len -= old->opt.optlen;",
      "1936:   sk_conn->icsk_ext_hdr_len += opt->opt.optlen;",
      "1939:  rcu_assign_pointer(sk_inet->inet_opt, opt);",
      "1940:  if (old)",
      "1941:   call_rcu(&old->rcu, opt_kfree_rcu);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1960:  unsigned char *buf = NULL;",
      "1961:  u32 buf_len;",
      "1962:  u32 opt_len;",
      "1964:  struct inet_request_sock *req_inet;",
      "",
      "[Removed Lines]",
      "1963:  struct ip_options *opt = NULL;",
      "",
      "[Added Lines]",
      "1971:  struct ip_options_rcu *opt = NULL;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1988:   ret_val = -ENOMEM;",
      "1989:   goto req_setattr_failure;",
      "1990:  }",
      "1994:  kfree(buf);",
      "1995:  buf = NULL;",
      "1997:  req_inet = inet_rsk(req);",
      "1998:  opt = xchg(&req_inet->opt, opt);",
      "2001:  return 0;",
      "",
      "[Removed Lines]",
      "1991:  memcpy(opt->__data, buf, buf_len);",
      "1992:  opt->optlen = opt_len;",
      "1993:  opt->cipso = sizeof(struct iphdr);",
      "1999:  kfree(opt);",
      "",
      "[Added Lines]",
      "1999:  memcpy(opt->opt.__data, buf, buf_len);",
      "2000:  opt->opt.optlen = opt_len;",
      "2001:  opt->opt.cipso = sizeof(struct iphdr);",
      "2007:  if (opt)",
      "2008:   call_rcu(&opt->rcu, opt_kfree_rcu);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2020: {",
      "2021:  int hdr_delta = 0;",
      "2025:   u8 cipso_len;",
      "2026:   u8 cipso_off;",
      "2027:   unsigned char *cipso_ptr;",
      "2028:   int iter;",
      "2029:   int optlen_new;",
      "2033:   cipso_len = cipso_ptr[1];",
      "2045:   memmove(cipso_ptr, cipso_ptr + cipso_len,",
      "",
      "[Removed Lines]",
      "2019: static int cipso_v4_delopt(struct ip_options **opt_ptr)",
      "2022:  struct ip_options *opt = *opt_ptr;",
      "2024:  if (opt->srr || opt->rr || opt->ts || opt->router_alert) {",
      "2031:   cipso_off = opt->cipso - sizeof(struct iphdr);",
      "2032:   cipso_ptr = &opt->__data[cipso_off];",
      "2035:   if (opt->srr > opt->cipso)",
      "2036:    opt->srr -= cipso_len;",
      "2037:   if (opt->rr > opt->cipso)",
      "2038:    opt->rr -= cipso_len;",
      "2039:   if (opt->ts > opt->cipso)",
      "2040:    opt->ts -= cipso_len;",
      "2041:   if (opt->router_alert > opt->cipso)",
      "2042:    opt->router_alert -= cipso_len;",
      "2043:   opt->cipso = 0;",
      "2046:    opt->optlen - cipso_off - cipso_len);",
      "",
      "[Added Lines]",
      "2028: static int cipso_v4_delopt(struct ip_options_rcu **opt_ptr)",
      "2031:  struct ip_options_rcu *opt = *opt_ptr;",
      "2033:  if (opt->opt.srr || opt->opt.rr || opt->opt.ts || opt->opt.router_alert) {",
      "2040:   cipso_off = opt->opt.cipso - sizeof(struct iphdr);",
      "2041:   cipso_ptr = &opt->opt.__data[cipso_off];",
      "2044:   if (opt->opt.srr > opt->opt.cipso)",
      "2045:    opt->opt.srr -= cipso_len;",
      "2046:   if (opt->opt.rr > opt->opt.cipso)",
      "2047:    opt->opt.rr -= cipso_len;",
      "2048:   if (opt->opt.ts > opt->opt.cipso)",
      "2049:    opt->opt.ts -= cipso_len;",
      "2050:   if (opt->opt.router_alert > opt->opt.cipso)",
      "2051:    opt->opt.router_alert -= cipso_len;",
      "2052:   opt->opt.cipso = 0;",
      "2055:    opt->opt.optlen - cipso_off - cipso_len);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "2053:   iter = 0;",
      "2054:   optlen_new = 0;",
      "2058:     optlen_new = iter;",
      "2059:    } else",
      "2060:     iter++;",
      "2064:  } else {",
      "2070:  }",
      "2072:  return hdr_delta;",
      "",
      "[Removed Lines]",
      "2055:   while (iter < opt->optlen)",
      "2056:    if (opt->__data[iter] != IPOPT_NOP) {",
      "2057:     iter += opt->__data[iter + 1];",
      "2061:   hdr_delta = opt->optlen;",
      "2062:   opt->optlen = (optlen_new + 3) & ~3;",
      "2063:   hdr_delta -= opt->optlen;",
      "2068:   hdr_delta = opt->optlen;",
      "2069:   kfree(opt);",
      "",
      "[Added Lines]",
      "2064:   while (iter < opt->opt.optlen)",
      "2065:    if (opt->opt.__data[iter] != IPOPT_NOP) {",
      "2066:     iter += opt->opt.__data[iter + 1];",
      "2070:   hdr_delta = opt->opt.optlen;",
      "2071:   opt->opt.optlen = (optlen_new + 3) & ~3;",
      "2072:   hdr_delta -= opt->opt.optlen;",
      "2077:   hdr_delta = opt->opt.optlen;",
      "2078:   call_rcu(&opt->rcu, opt_kfree_rcu);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "2083: void cipso_v4_sock_delattr(struct sock *sk)",
      "2084: {",
      "2085:  int hdr_delta;",
      "2087:  struct inet_sock *sk_inet;",
      "2089:  sk_inet = inet_sk(sk);",
      "2092:   return;",
      "2095:  if (sk_inet->is_icsk && hdr_delta > 0) {",
      "2096:   struct inet_connection_sock *sk_conn = inet_csk(sk);",
      "2097:   sk_conn->icsk_ext_hdr_len -= hdr_delta;",
      "",
      "[Removed Lines]",
      "2086:  struct ip_options *opt;",
      "2090:  opt = sk_inet->opt;",
      "2091:  if (opt == NULL || opt->cipso == 0)",
      "2094:  hdr_delta = cipso_v4_delopt(&sk_inet->opt);",
      "",
      "[Added Lines]",
      "2095:  struct ip_options_rcu *opt;",
      "2099:  opt = rcu_dereference_protected(sk_inet->inet_opt, 1);",
      "2100:  if (opt == NULL || opt->opt.cipso == 0)",
      "2103:  hdr_delta = cipso_v4_delopt(&sk_inet->inet_opt);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "2110: void cipso_v4_req_delattr(struct request_sock *req)",
      "2111: {",
      "2113:  struct inet_request_sock *req_inet;",
      "2115:  req_inet = inet_rsk(req);",
      "2116:  opt = req_inet->opt;",
      "2118:   return;",
      "2120:  cipso_v4_delopt(&req_inet->opt);",
      "",
      "[Removed Lines]",
      "2112:  struct ip_options *opt;",
      "2117:  if (opt == NULL || opt->cipso == 0)",
      "",
      "[Added Lines]",
      "2121:  struct ip_options_rcu *opt;",
      "2126:  if (opt == NULL || opt->opt.cipso == 0)",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "2185: int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)",
      "2186: {",
      "2195: }",
      "",
      "[Removed Lines]",
      "2187:  struct ip_options *opt;",
      "2189:  opt = inet_sk(sk)->opt;",
      "2190:  if (opt == NULL || opt->cipso == 0)",
      "2191:   return -ENOMSG;",
      "2193:  return cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct iphdr),",
      "2194:     secattr);",
      "",
      "[Added Lines]",
      "2196:  struct ip_options_rcu *opt;",
      "2197:  int res = -ENOMSG;",
      "2199:  rcu_read_lock();",
      "2200:  opt = rcu_dereference(inet_sk(sk)->inet_opt);",
      "2201:  if (opt && opt->opt.cipso)",
      "2202:   res = cipso_v4_getattr(opt->opt.__data +",
      "2203:       opt->opt.cipso -",
      "2204:       sizeof(struct iphdr),",
      "2205:            secattr);",
      "2206:  rcu_read_unlock();",
      "2207:  return res;",
      "",
      "---------------"
    ],
    "net/ipv4/icmp.c||net/ipv4/icmp.c": [
      "File: net/ipv4/icmp.c -> net/ipv4/icmp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "108:   __be32        times[3];",
      "109:  } data;",
      "110:  int head_len;",
      "113: };",
      "",
      "[Removed Lines]",
      "111:  struct ip_options replyopts;",
      "112:  unsigned char  optbuf[40];",
      "",
      "[Added Lines]",
      "111:  struct ip_options_data replyopts;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "333:  struct inet_sock *inet;",
      "334:  __be32 daddr;",
      "337:   return;",
      "339:  sk = icmp_xmit_lock(net);",
      "",
      "[Removed Lines]",
      "336:  if (ip_options_echo(&icmp_param->replyopts, skb))",
      "",
      "[Added Lines]",
      "335:  if (ip_options_echo(&icmp_param->replyopts.opt.opt, skb))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "347:  daddr = ipc.addr = rt->rt_src;",
      "348:  ipc.opt = NULL;",
      "349:  ipc.tx_flags = 0;",
      "354:  }",
      "355:  {",
      "356:   struct flowi4 fl4 = {",
      "",
      "[Removed Lines]",
      "350:  if (icmp_param->replyopts.optlen) {",
      "351:   ipc.opt = &icmp_param->replyopts;",
      "352:   if (ipc.opt->srr)",
      "353:    daddr = icmp_param->replyopts.faddr;",
      "",
      "[Added Lines]",
      "349:  if (icmp_param->replyopts.opt.opt.optlen) {",
      "350:   ipc.opt = &icmp_param->replyopts.opt;",
      "351:   if (ipc.opt->opt.srr)",
      "352:    daddr = icmp_param->replyopts.opt.opt.faddr;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "379:      struct icmp_bxm *param)",
      "380: {",
      "381:  struct flowi4 fl4 = {",
      "384:   .saddr = saddr,",
      "385:   .flowi4_tos = RT_TOS(tos),",
      "386:   .flowi4_proto = IPPROTO_ICMP,",
      "",
      "[Removed Lines]",
      "382:   .daddr = (param->replyopts.srr ?",
      "383:      param->replyopts.faddr : iph->saddr),",
      "",
      "[Added Lines]",
      "381:   .daddr = (param->replyopts.opt.opt.srr ?",
      "382:      param->replyopts.opt.opt.faddr : iph->saddr),",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "581:         IPTOS_PREC_INTERNETCONTROL) :",
      "582:        iph->tos;",
      "585:   goto out_unlock;",
      "",
      "[Removed Lines]",
      "584:  if (ip_options_echo(&icmp_param.replyopts, skb_in))",
      "",
      "[Added Lines]",
      "583:  if (ip_options_echo(&icmp_param.replyopts.opt.opt, skb_in))",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "597:  icmp_param.offset = skb_network_offset(skb_in);",
      "598:  inet_sk(sk)->tos = tos;",
      "599:  ipc.addr = iph->saddr;",
      "601:  ipc.tx_flags = 0;",
      "603:  rt = icmp_route_lookup(net, skb_in, iph, saddr, tos,",
      "",
      "[Removed Lines]",
      "600:  ipc.opt = &icmp_param.replyopts;",
      "",
      "[Added Lines]",
      "599:  ipc.opt = &icmp_param.replyopts.opt;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "613:  room = dst_mtu(&rt->dst);",
      "614:  if (room > 576)",
      "615:   room = 576;",
      "617:  room -= sizeof(struct icmphdr);",
      "619:  icmp_param.data_len = skb_in->len - icmp_param.offset;",
      "",
      "[Removed Lines]",
      "616:  room -= sizeof(struct iphdr) + icmp_param.replyopts.optlen;",
      "",
      "[Added Lines]",
      "615:  room -= sizeof(struct iphdr) + icmp_param.replyopts.opt.opt.optlen;",
      "",
      "---------------"
    ],
    "net/ipv4/inet_connection_sock.c||net/ipv4/inet_connection_sock.c": [
      "File: net/ipv4/inet_connection_sock.c -> net/ipv4/inet_connection_sock.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "354: {",
      "355:  struct rtable *rt;",
      "356:  const struct inet_request_sock *ireq = inet_rsk(req);",
      "358:  struct net *net = sock_net(sk);",
      "359:  struct flowi4 fl4;",
      "361:  flowi4_init_output(&fl4, sk->sk_bound_dev_if, sk->sk_mark,",
      "362:       RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE,",
      "363:       sk->sk_protocol, inet_sk_flowi_flags(sk),",
      "365:       ireq->loc_addr, ireq->rmt_port, inet_sk(sk)->inet_sport);",
      "366:  security_req_classify_flow(req, flowi4_to_flowi(&fl4));",
      "367:  rt = ip_route_output_flow(net, &fl4, sk);",
      "368:  if (IS_ERR(rt))",
      "369:   goto no_route;",
      "371:   goto route_err;",
      "372:  return &rt->dst;",
      "",
      "[Removed Lines]",
      "357:  struct ip_options *opt = inet_rsk(req)->opt;",
      "364:       (opt && opt->srr) ? opt->faddr : ireq->rmt_addr,",
      "370:  if (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway)",
      "",
      "[Added Lines]",
      "357:  struct ip_options_rcu *opt = inet_rsk(req)->opt;",
      "364:       (opt && opt->opt.srr) ? opt->opt.faddr : ireq->rmt_addr,",
      "370:  if (opt && opt->opt.is_strictroute && rt->rt_dst != rt->rt_gateway)",
      "",
      "---------------"
    ],
    "net/ipv4/ip_options.c||net/ipv4/ip_options.c": [
      "File: net/ipv4/ip_options.c -> net/ipv4/ip_options.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "40:        __be32 daddr, struct rtable *rt, int is_frag)",
      "41: {",
      "42:  unsigned char *iph = skb_network_header(skb);",
      "",
      "[Removed Lines]",
      "39: void ip_options_build(struct sk_buff * skb, struct ip_options * opt,",
      "",
      "[Added Lines]",
      "39: void ip_options_build(struct sk_buff *skb, struct ip_options *opt,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "87: {",
      "89:  unsigned char *sptr, *dptr;",
      "90:  int soffset, doffset;",
      "91:  int optlen;",
      "",
      "[Removed Lines]",
      "86: int ip_options_echo(struct ip_options * dopt, struct sk_buff * skb)",
      "88:  struct ip_options *sopt;",
      "",
      "[Added Lines]",
      "86: int ip_options_echo(struct ip_options *dopt, struct sk_buff *skb)",
      "88:  const struct ip_options *sopt;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "96:  sopt = &(IPCB(skb)->opt);",
      "100:   return 0;",
      "103:  sptr = skb_network_header(skb);",
      "104:  dptr = dopt->__data;",
      "",
      "[Removed Lines]",
      "98:  if (sopt->optlen == 0) {",
      "99:   dopt->optlen = 0;",
      "101:  }",
      "",
      "[Added Lines]",
      "98:  if (sopt->optlen == 0)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "157:   dopt->optlen += optlen;",
      "158:  }",
      "159:  if (sopt->srr) {",
      "161:   __be32 faddr;",
      "163:   optlen  = start[1];",
      "",
      "[Removed Lines]",
      "160:   unsigned char * start = sptr+sopt->srr;",
      "",
      "[Added Lines]",
      "158:   unsigned char *start = sptr+sopt->srr;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "499:  }",
      "500: }",
      "503: {",
      "505:          GFP_KERNEL);",
      "506: }",
      "510: {",
      "511:  while (optlen & 3)",
      "515:   kfree(opt);",
      "516:   return -EINVAL;",
      "517:  }",
      "",
      "[Removed Lines]",
      "502: static struct ip_options *ip_options_get_alloc(const int optlen)",
      "504:  return kzalloc(sizeof(struct ip_options) + ((optlen + 3) & ~3),",
      "508: static int ip_options_get_finish(struct net *net, struct ip_options **optp,",
      "509:      struct ip_options *opt, int optlen)",
      "512:   opt->__data[optlen++] = IPOPT_END;",
      "513:  opt->optlen = optlen;",
      "514:  if (optlen && ip_options_compile(net, opt, NULL)) {",
      "",
      "[Added Lines]",
      "500: static struct ip_options_rcu *ip_options_get_alloc(const int optlen)",
      "502:  return kzalloc(sizeof(struct ip_options_rcu) + ((optlen + 3) & ~3),",
      "506: static int ip_options_get_finish(struct net *net, struct ip_options_rcu **optp,",
      "507:      struct ip_options_rcu *opt, int optlen)",
      "510:   opt->opt.__data[optlen++] = IPOPT_END;",
      "511:  opt->opt.optlen = optlen;",
      "512:  if (optlen && ip_options_compile(net, &opt->opt, NULL)) {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "520:  return 0;",
      "521: }",
      "524:         unsigned char __user *data, int optlen)",
      "525: {",
      "528:  if (!opt)",
      "529:   return -ENOMEM;",
      "531:   kfree(opt);",
      "532:   return -EFAULT;",
      "533:  }",
      "534:  return ip_options_get_finish(net, optp, opt, optlen);",
      "535: }",
      "538:      unsigned char *data, int optlen)",
      "539: {",
      "542:  if (!opt)",
      "543:   return -ENOMEM;",
      "544:  if (optlen)",
      "546:  return ip_options_get_finish(net, optp, opt, optlen);",
      "547: }",
      "",
      "[Removed Lines]",
      "523: int ip_options_get_from_user(struct net *net, struct ip_options **optp,",
      "526:  struct ip_options *opt = ip_options_get_alloc(optlen);",
      "530:  if (optlen && copy_from_user(opt->__data, data, optlen)) {",
      "537: int ip_options_get(struct net *net, struct ip_options **optp,",
      "540:  struct ip_options *opt = ip_options_get_alloc(optlen);",
      "545:   memcpy(opt->__data, data, optlen);",
      "",
      "[Added Lines]",
      "521: int ip_options_get_from_user(struct net *net, struct ip_options_rcu **optp,",
      "524:  struct ip_options_rcu *opt = ip_options_get_alloc(optlen);",
      "528:  if (optlen && copy_from_user(opt->opt.__data, data, optlen)) {",
      "535: int ip_options_get(struct net *net, struct ip_options_rcu **optp,",
      "538:  struct ip_options_rcu *opt = ip_options_get_alloc(optlen);",
      "543:   memcpy(opt->opt.__data, data, optlen);",
      "",
      "---------------"
    ],
    "net/ipv4/ip_output.c||net/ipv4/ip_output.c": [
      "File: net/ipv4/ip_output.c -> net/ipv4/ip_output.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "142: int ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,",
      "144: {",
      "145:  struct inet_sock *inet = inet_sk(sk);",
      "146:  struct rtable *rt = skb_rtable(skb);",
      "147:  struct iphdr *iph;",
      "151:  skb_reset_network_header(skb);",
      "152:  iph = ip_hdr(skb);",
      "153:  iph->version  = 4;",
      "",
      "[Removed Lines]",
      "143:      __be32 saddr, __be32 daddr, struct ip_options *opt)",
      "150:  skb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));",
      "",
      "[Added Lines]",
      "143:      __be32 saddr, __be32 daddr, struct ip_options_rcu *opt)",
      "150:  skb_push(skb, sizeof(struct iphdr) + (opt ? opt->opt.optlen : 0));",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "163:  iph->protocol = sk->sk_protocol;",
      "164:  ip_select_ident(iph, &rt->dst, sk);",
      "169:  }",
      "171:  skb->priority = sk->sk_priority;",
      "",
      "[Removed Lines]",
      "166:  if (opt && opt->optlen) {",
      "167:   iph->ihl += opt->optlen>>2;",
      "168:   ip_options_build(skb, opt, daddr, rt, 0);",
      "",
      "[Added Lines]",
      "166:  if (opt && opt->opt.optlen) {",
      "167:   iph->ihl += opt->opt.optlen>>2;",
      "168:   ip_options_build(skb, &opt->opt, daddr, rt, 0);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "316: {",
      "317:  struct sock *sk = skb->sk;",
      "318:  struct inet_sock *inet = inet_sk(sk);",
      "320:  struct rtable *rt;",
      "321:  struct iphdr *iph;",
      "322:  int res;",
      "",
      "[Removed Lines]",
      "319:  struct ip_options *opt = inet->opt;",
      "",
      "[Added Lines]",
      "319:  struct ip_options_rcu *inet_opt;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "327:  rcu_read_lock();",
      "328:  rt = skb_rtable(skb);",
      "329:  if (rt != NULL)",
      "330:   goto packet_routed;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "328:  inet_opt = rcu_dereference(inet->inet_opt);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "338:   daddr = inet->inet_daddr;",
      "",
      "[Removed Lines]",
      "339:   if(opt && opt->srr)",
      "340:    daddr = opt->faddr;",
      "",
      "[Added Lines]",
      "340:   if (inet_opt && inet_opt->opt.srr)",
      "341:    daddr = inet_opt->opt.faddr;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "357:  skb_dst_set_noref(skb, &rt->dst);",
      "359: packet_routed:",
      "361:   goto no_route;",
      "365:  skb_reset_network_header(skb);",
      "366:  iph = ip_hdr(skb);",
      "",
      "[Removed Lines]",
      "360:  if (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway)",
      "364:  skb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));",
      "",
      "[Added Lines]",
      "361:  if (inet_opt && inet_opt->opt.is_strictroute && rt->rt_dst != rt->rt_gateway)",
      "365:  skb_push(skb, sizeof(struct iphdr) + (inet_opt ? inet_opt->opt.optlen : 0));",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "375:  iph->daddr    = rt->rt_dst;",
      "381:  }",
      "383:  ip_select_ident_more(iph, &rt->dst, sk,",
      "",
      "[Removed Lines]",
      "378:  if (opt && opt->optlen) {",
      "379:   iph->ihl += opt->optlen >> 2;",
      "380:   ip_options_build(skb, opt, inet->inet_daddr, rt, 0);",
      "",
      "[Added Lines]",
      "379:  if (inet_opt && inet_opt->opt.optlen) {",
      "380:   iph->ihl += inet_opt->opt.optlen >> 2;",
      "381:   ip_options_build(skb, &inet_opt->opt, inet->inet_daddr, rt, 0);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "1033:     struct ipcm_cookie *ipc, struct rtable **rtp)",
      "1034: {",
      "1035:  struct inet_sock *inet = inet_sk(sk);",
      "1037:  struct rtable *rt;",
      "",
      "[Removed Lines]",
      "1036:  struct ip_options *opt;",
      "",
      "[Added Lines]",
      "1037:  struct ip_options_rcu *opt;",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "1047:    if (unlikely(cork->opt == NULL))",
      "1048:     return -ENOBUFS;",
      "1049:   }",
      "1051:   cork->flags |= IPCORK_OPT;",
      "1052:   cork->addr = ipc->addr;",
      "1053:  }",
      "",
      "[Removed Lines]",
      "1050:   memcpy(cork->opt, opt, sizeof(struct ip_options) + opt->optlen);",
      "",
      "[Added Lines]",
      "1051:   memcpy(cork->opt, &opt->opt, sizeof(struct ip_options) + opt->opt.optlen);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "1451:      unsigned int len)",
      "1452: {",
      "1453:  struct inet_sock *inet = inet_sk(sk);",
      "1458:  struct ipcm_cookie ipc;",
      "1459:  __be32 daddr;",
      "1460:  struct rtable *rt = skb_rtable(skb);",
      "1463:   return;",
      "1465:  daddr = ipc.addr = rt->rt_src;",
      "1466:  ipc.opt = NULL;",
      "1467:  ipc.tx_flags = 0;",
      "1470:   ipc.opt = &replyopts.opt;",
      "1474:  }",
      "1476:  {",
      "",
      "[Removed Lines]",
      "1454:  struct {",
      "1455:   struct ip_options opt;",
      "1456:   char   data[40];",
      "1457:  } replyopts;",
      "1462:  if (ip_options_echo(&replyopts.opt, skb))",
      "1469:  if (replyopts.opt.optlen) {",
      "1472:   if (ipc.opt->srr)",
      "1473:    daddr = replyopts.opt.faddr;",
      "",
      "[Added Lines]",
      "1455:  struct ip_options_data replyopts;",
      "1460:  if (ip_options_echo(&replyopts.opt.opt, skb))",
      "1467:  if (replyopts.opt.opt.optlen) {",
      "1470:   if (replyopts.opt.opt.srr)",
      "1471:    daddr = replyopts.opt.opt.faddr;",
      "",
      "---------------"
    ],
    "net/ipv4/ip_sockglue.c||net/ipv4/ip_sockglue.c": [
      "File: net/ipv4/ip_sockglue.c -> net/ipv4/ip_sockglue.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "451: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "454: static void opt_kfree_rcu(struct rcu_head *head)",
      "455: {",
      "456:  kfree(container_of(head, struct ip_options_rcu, rcu));",
      "457: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "497:  switch (optname) {",
      "498:  case IP_OPTIONS:",
      "499:  {",
      "501:   if (optlen > 40)",
      "502:    goto e_inval;",
      "503:   err = ip_options_get_from_user(sock_net(sk), &opt,",
      "504:             optval, optlen);",
      "505:   if (err)",
      "506:    break;",
      "507:   if (inet->is_icsk) {",
      "508:    struct inet_connection_sock *icsk = inet_csk(sk);",
      "509: #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)",
      "",
      "[Removed Lines]",
      "500:   struct ip_options *opt = NULL;",
      "",
      "[Added Lines]",
      "505:   struct ip_options_rcu *old, *opt = NULL;",
      "513:   old = rcu_dereference_protected(inet->inet_opt,",
      "514:       sock_owned_by_user(sk));",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "512:           (TCPF_LISTEN | TCPF_CLOSE)) &&",
      "513:         inet->inet_daddr != LOOPBACK4_IPV6)) {",
      "514: #endif",
      "517:     if (opt)",
      "519:     icsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);",
      "520: #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)",
      "521:    }",
      "522: #endif",
      "523:   }",
      "526:   break;",
      "527:  }",
      "528:  case IP_PKTINFO:",
      "",
      "[Removed Lines]",
      "515:     if (inet->opt)",
      "516:      icsk->icsk_ext_hdr_len -= inet->opt->optlen;",
      "518:      icsk->icsk_ext_hdr_len += opt->optlen;",
      "524:   opt = xchg(&inet->opt, opt);",
      "525:   kfree(opt);",
      "",
      "[Added Lines]",
      "523:     if (old)",
      "524:      icsk->icsk_ext_hdr_len -= old->opt.optlen;",
      "526:      icsk->icsk_ext_hdr_len += opt->opt.optlen;",
      "532:   rcu_assign_pointer(inet->inet_opt, opt);",
      "533:   if (old)",
      "534:    call_rcu(&old->rcu, opt_kfree_rcu);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1081:  case IP_OPTIONS:",
      "1082:  {",
      "1083:   unsigned char optbuf[sizeof(struct ip_options)+40];",
      "1085:   opt->optlen = 0;",
      "1090:   release_sock(sk);",
      "1092:   if (opt->optlen == 0)",
      "",
      "[Removed Lines]",
      "1084:   struct ip_options * opt = (struct ip_options *)optbuf;",
      "1086:   if (inet->opt)",
      "1087:    memcpy(optbuf, inet->opt,",
      "1088:           sizeof(struct ip_options)+",
      "1089:           inet->opt->optlen);",
      "",
      "[Added Lines]",
      "1093:   struct ip_options *opt = (struct ip_options *)optbuf;",
      "1094:   struct ip_options_rcu *inet_opt;",
      "1096:   inet_opt = rcu_dereference_protected(inet->inet_opt,",
      "1097:            sock_owned_by_user(sk));",
      "1099:   if (inet_opt)",
      "1100:    memcpy(optbuf, &inet_opt->opt,",
      "1101:           sizeof(struct ip_options) +",
      "1102:           inet_opt->opt.optlen);",
      "",
      "---------------"
    ],
    "net/ipv4/raw.c||net/ipv4/raw.c": [
      "File: net/ipv4/raw.c -> net/ipv4/raw.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "460:  __be32 saddr;",
      "461:  u8  tos;",
      "462:  int err;",
      "464:  err = -EMSGSIZE;",
      "465:  if (len > 0xFFFF)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "463:  struct ip_options_data opt_copy;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "520:  saddr = ipc.addr;",
      "521:  ipc.addr = daddr;",
      "526:  if (ipc.opt) {",
      "527:   err = -EINVAL;",
      "",
      "[Removed Lines]",
      "523:  if (!ipc.opt)",
      "524:   ipc.opt = inet->opt;",
      "",
      "[Added Lines]",
      "524:  if (!ipc.opt) {",
      "525:   struct ip_options_rcu *inet_opt;",
      "527:   rcu_read_lock();",
      "528:   inet_opt = rcu_dereference(inet->inet_opt);",
      "529:   if (inet_opt) {",
      "530:    memcpy(&opt_copy, inet_opt,",
      "531:           sizeof(*inet_opt) + inet_opt->opt.optlen);",
      "532:    ipc.opt = &opt_copy.opt;",
      "533:   }",
      "534:   rcu_read_unlock();",
      "535:  }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "531:   if (inet->hdrincl)",
      "532:    goto done;",
      "534:    if (!daddr)",
      "535:     goto done;",
      "537:   }",
      "538:  }",
      "539:  tos = RT_CONN_FLAGS(sk);",
      "",
      "[Removed Lines]",
      "533:   if (ipc.opt->srr) {",
      "536:    daddr = ipc.opt->faddr;",
      "",
      "[Added Lines]",
      "544:   if (ipc.opt->opt.srr) {",
      "547:    daddr = ipc.opt->opt.faddr;",
      "",
      "---------------"
    ],
    "net/ipv4/syncookies.c||net/ipv4/syncookies.c": [
      "File: net/ipv4/syncookies.c -> net/ipv4/syncookies.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "323:  if (opt && opt->optlen) {",
      "326:   ireq->opt = kmalloc(opt_size, GFP_ATOMIC);",
      "328:    kfree(ireq->opt);",
      "329:    ireq->opt = NULL;",
      "330:   }",
      "",
      "[Removed Lines]",
      "324:   int opt_size = sizeof(struct ip_options) + opt->optlen;",
      "327:   if (ireq->opt != NULL && ip_options_echo(ireq->opt, skb)) {",
      "",
      "[Added Lines]",
      "324:   int opt_size = sizeof(struct ip_options_rcu) + opt->optlen;",
      "327:   if (ireq->opt != NULL && ip_options_echo(&ireq->opt->opt, skb)) {",
      "",
      "---------------"
    ],
    "net/ipv4/tcp_ipv4.c||net/ipv4/tcp_ipv4.c": [
      "File: net/ipv4/tcp_ipv4.c -> net/ipv4/tcp_ipv4.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "154:  struct flowi4 fl4;",
      "155:  struct rtable *rt;",
      "156:  int err;",
      "158:  if (addr_len < sizeof(struct sockaddr_in))",
      "159:   return -EINVAL;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "157:  struct ip_options_rcu *inet_opt;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "162:   return -EAFNOSUPPORT;",
      "164:  nexthop = daddr = usin->sin_addr.s_addr;",
      "166:   if (!daddr)",
      "167:    return -EINVAL;",
      "169:  }",
      "171:  orig_sport = inet->inet_sport;",
      "",
      "[Removed Lines]",
      "165:  if (inet->opt && inet->opt->srr) {",
      "168:   nexthop = inet->opt->faddr;",
      "",
      "[Added Lines]",
      "166:  inet_opt = rcu_dereference_protected(inet->inet_opt,",
      "167:           sock_owned_by_user(sk));",
      "168:  if (inet_opt && inet_opt->opt.srr) {",
      "171:   nexthop = inet_opt->opt.faddr;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "186:   return -ENETUNREACH;",
      "187:  }",
      "190:   daddr = rt->rt_dst;",
      "192:  if (!inet->inet_saddr)",
      "",
      "[Removed Lines]",
      "189:  if (!inet->opt || !inet->opt->srr)",
      "",
      "[Added Lines]",
      "192:  if (!inet_opt || !inet_opt->opt.srr)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "222:  inet->inet_daddr = daddr;",
      "224:  inet_csk(sk)->icsk_ext_hdr_len = 0;",
      "228:  tp->rx_opt.mss_clamp = TCP_MSS_DEFAULT;",
      "",
      "[Removed Lines]",
      "225:  if (inet->opt)",
      "226:   inet_csk(sk)->icsk_ext_hdr_len = inet->opt->optlen;",
      "",
      "[Added Lines]",
      "228:  if (inet_opt)",
      "229:   inet_csk(sk)->icsk_ext_hdr_len = inet_opt->opt.optlen;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "825: {",
      "829:  if (opt && opt->optlen) {",
      "831:   dopt = kmalloc(opt_size, GFP_ATOMIC);",
      "832:   if (dopt) {",
      "834:     kfree(dopt);",
      "835:     dopt = NULL;",
      "836:    }",
      "",
      "[Removed Lines]",
      "823: static struct ip_options *tcp_v4_save_options(struct sock *sk,",
      "824:            struct sk_buff *skb)",
      "826:  struct ip_options *opt = &(IPCB(skb)->opt);",
      "827:  struct ip_options *dopt = NULL;",
      "830:   int opt_size = optlength(opt);",
      "833:    if (ip_options_echo(dopt, skb)) {",
      "",
      "[Added Lines]",
      "826: static struct ip_options_rcu *tcp_v4_save_options(struct sock *sk,",
      "827:         struct sk_buff *skb)",
      "829:  const struct ip_options *opt = &(IPCB(skb)->opt);",
      "830:  struct ip_options_rcu *dopt = NULL;",
      "833:   int opt_size = sizeof(*dopt) + opt->optlen;",
      "837:    if (ip_options_echo(&dopt->opt, skb)) {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1411: #ifdef CONFIG_TCP_MD5SIG",
      "1412:  struct tcp_md5sig_key *key;",
      "1413: #endif",
      "1415:  if (sk_acceptq_is_full(sk))",
      "1416:   goto exit_overflow;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1418:  struct ip_options_rcu *inet_opt;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1431:  newinet->inet_daddr   = ireq->rmt_addr;",
      "1432:  newinet->inet_rcv_saddr = ireq->loc_addr;",
      "1433:  newinet->inet_saddr       = ireq->loc_addr;",
      "1435:  ireq->opt       = NULL;",
      "1436:  newinet->mc_index     = inet_iif(skb);",
      "1437:  newinet->mc_ttl       = ip_hdr(skb)->ttl;",
      "1438:  inet_csk(newsk)->icsk_ext_hdr_len = 0;",
      "1441:  newinet->inet_id = newtp->write_seq ^ jiffies;",
      "1443:  tcp_mtup_init(newsk);",
      "",
      "[Removed Lines]",
      "1434:  newinet->opt       = ireq->opt;",
      "1439:  if (newinet->opt)",
      "1440:   inet_csk(newsk)->icsk_ext_hdr_len = newinet->opt->optlen;",
      "",
      "[Added Lines]",
      "1439:  inet_opt       = ireq->opt;",
      "1440:  rcu_assign_pointer(newinet->inet_opt, inet_opt);",
      "1445:  if (inet_opt)",
      "1446:   inet_csk(newsk)->icsk_ext_hdr_len = inet_opt->opt.optlen;",
      "",
      "---------------"
    ],
    "net/ipv4/udp.c||net/ipv4/udp.c": [
      "File: net/ipv4/udp.c -> net/ipv4/udp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "804:  int corkreq = up->corkflag || msg->msg_flags&MSG_MORE;",
      "805:  int (*getfrag)(void *, char *, int, int, int, struct sk_buff *);",
      "806:  struct sk_buff *skb;",
      "808:  if (len > 0xFFFF)",
      "809:   return -EMSGSIZE;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "807:  struct ip_options_data opt_copy;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "877:    free = 1;",
      "878:   connected = 0;",
      "879:  }",
      "883:  saddr = ipc.addr;",
      "884:  ipc.addr = faddr = daddr;",
      "887:   if (!daddr)",
      "888:    return -EINVAL;",
      "890:   connected = 0;",
      "891:  }",
      "892:  tos = RT_TOS(inet->tos);",
      "893:  if (sock_flag(sk, SOCK_LOCALROUTE) ||",
      "894:      (msg->msg_flags & MSG_DONTROUTE) ||",
      "896:   tos |= RTO_ONLINK;",
      "897:   connected = 0;",
      "898:  }",
      "",
      "[Removed Lines]",
      "880:  if (!ipc.opt)",
      "881:   ipc.opt = inet->opt;",
      "886:  if (ipc.opt && ipc.opt->srr) {",
      "889:   faddr = ipc.opt->faddr;",
      "895:      (ipc.opt && ipc.opt->is_strictroute)) {",
      "",
      "[Added Lines]",
      "881:  if (!ipc.opt) {",
      "882:   struct ip_options_rcu *inet_opt;",
      "884:   rcu_read_lock();",
      "885:   inet_opt = rcu_dereference(inet->inet_opt);",
      "886:   if (inet_opt) {",
      "887:    memcpy(&opt_copy, inet_opt,",
      "888:           sizeof(*inet_opt) + inet_opt->opt.optlen);",
      "889:    ipc.opt = &opt_copy.opt;",
      "890:   }",
      "891:   rcu_read_unlock();",
      "892:  }",
      "897:  if (ipc.opt && ipc.opt->opt.srr) {",
      "900:   faddr = ipc.opt->opt.faddr;",
      "906:      (ipc.opt && ipc.opt->opt.is_strictroute)) {",
      "",
      "---------------"
    ],
    "net/ipv6/tcp_ipv6.c||net/ipv6/tcp_ipv6.c": [
      "File: net/ipv6/tcp_ipv6.c -> net/ipv6/tcp_ipv6.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1470:     First: no IPv4 options.",
      "1473:  newnp->ipv6_fl_list = NULL;",
      "",
      "[Removed Lines]",
      "1472:  newinet->opt = NULL;",
      "",
      "[Added Lines]",
      "1472:  newinet->inet_opt = NULL;",
      "",
      "---------------"
    ],
    "net/l2tp/l2tp_ip.c||net/l2tp/l2tp_ip.c": [
      "File: net/l2tp/l2tp_ip.c -> net/l2tp/l2tp_ip.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "416:  int rc;",
      "417:  struct l2tp_ip_sock *lsa = l2tp_ip_sk(sk);",
      "418:  struct inet_sock *inet = inet_sk(sk);",
      "420:  struct rtable *rt = NULL;",
      "421:  int connected = 0;",
      "422:  __be32 daddr;",
      "",
      "[Removed Lines]",
      "419:  struct ip_options *opt = inet->opt;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "471:   rt = (struct rtable *) __sk_dst_check(sk, 0);",
      "473:  if (rt == NULL) {",
      "",
      "[Removed Lines]",
      "475:   if (opt && opt->srr)",
      "476:    daddr = opt->faddr;",
      "",
      "[Added Lines]",
      "473:   struct ip_options_rcu *inet_opt;",
      "475:   inet_opt = rcu_dereference_protected(inet->inet_opt,",
      "476:            sock_owned_by_user(sk));",
      "479:   if (inet_opt && inet_opt->opt.srr)",
      "480:    daddr = inet_opt->opt.faddr;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f6d460cf0ed16d35aec48f823685e7a0e0283d84",
      "candidate_info": {
        "commit_hash": "f6d460cf0ed16d35aec48f823685e7a0e0283d84",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f6d460cf0ed16d35aec48f823685e7a0e0283d84",
        "files": [
          "net/ipv4/icmp.c"
        ],
        "message": "ipv4: Make icmp route lookup code a bit clearer.\n\nThe route lookup code in icmp_send() is slightly tricky as a result of\nhaving to handle all of the requirements of RFC 4301 host relookups.\n\nPull the route resolution into a seperate function, so that the error\nhandling and route reference counting is hopefully easier to see and\ncontained wholly within this new routine.\n\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv4/icmp.c||net/ipv4/icmp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv4/icmp.c||net/ipv4/icmp.c"
          ],
          "candidate": [
            "net/ipv4/icmp.c||net/ipv4/icmp.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ipv4/icmp.c||net/ipv4/icmp.c": [
          "File: net/ipv4/icmp.c -> net/ipv4/icmp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "369:  icmp_xmit_unlock(sk);",
          "370: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "372: static struct rtable *icmp_route_lookup(struct net *net, struct sk_buff *skb_in,",
          "373:      struct iphdr *iph,",
          "374:      __be32 saddr, u8 tos,",
          "375:      int type, int code,",
          "376:      struct icmp_bxm *param)",
          "377: {",
          "378:  struct flowi fl = {",
          "379:   .fl4_dst = (param->replyopts.srr ?",
          "380:        param->replyopts.faddr : iph->saddr),",
          "381:   .fl4_src = saddr,",
          "382:   .fl4_tos = RT_TOS(tos),",
          "383:   .proto = IPPROTO_ICMP,",
          "384:   .fl_icmp_type = type,",
          "385:   .fl_icmp_code = code,",
          "386:  };",
          "387:  struct rtable *rt, *rt2;",
          "388:  int err;",
          "390:  security_skb_classify_flow(skb_in, &fl);",
          "391:  err = __ip_route_output_key(net, &rt, &fl);",
          "392:  if (err)",
          "393:   return ERR_PTR(err);",
          "396:  rt2 = rt;",
          "398:  if (!fl.fl4_src)",
          "399:   fl.fl4_src = rt->rt_src;",
          "401:  err = xfrm_lookup(net, (struct dst_entry **)&rt, &fl, NULL, 0);",
          "402:  switch (err) {",
          "403:  case 0:",
          "404:   if (rt != rt2)",
          "405:    return rt;",
          "406:   break;",
          "407:  case -EPERM:",
          "408:   rt = NULL;",
          "409:   break;",
          "410:  default:",
          "411:   return ERR_PTR(err);",
          "412:  }",
          "414:  err = xfrm_decode_session_reverse(skb_in, &fl, AF_INET);",
          "415:  if (err)",
          "416:   goto relookup_failed;",
          "418:  if (inet_addr_type(net, fl.fl4_src) == RTN_LOCAL) {",
          "419:   err = __ip_route_output_key(net, &rt2, &fl);",
          "420:  } else {",
          "421:   struct flowi fl2 = {};",
          "422:   unsigned long orefdst;",
          "424:   fl2.fl4_dst = fl.fl4_src;",
          "425:   err = ip_route_output_key(net, &rt2, &fl2);",
          "426:   if (err)",
          "427:    goto relookup_failed;",
          "430:   err = ip_route_input(skb_in, fl.fl4_dst, fl.fl4_src,",
          "431:          RT_TOS(tos), rt2->dst.dev);",
          "433:   dst_release(&rt2->dst);",
          "434:   rt2 = skb_rtable(skb_in);",
          "436:  }",
          "438:  if (err)",
          "439:   goto relookup_failed;",
          "441:  err = xfrm_lookup(net, (struct dst_entry **)&rt2, &fl, NULL,",
          "442:      XFRM_LOOKUP_ICMP);",
          "443:  switch (err) {",
          "444:  case 0:",
          "445:   dst_release(&rt->dst);",
          "446:   rt = rt2;",
          "447:   break;",
          "448:  case -EPERM:",
          "449:   return ERR_PTR(err);",
          "450:  default:",
          "451:   if (!rt)",
          "452:    return ERR_PTR(err);",
          "453:   break;",
          "454:  }",
          "457:  return rt;",
          "459: relookup_failed:",
          "460:  if (rt)",
          "461:   return rt;",
          "462:  return ERR_PTR(err);",
          "463: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "506:  ipc.opt = &icmp_param.replyopts;",
          "507:  ipc.tx_flags = 0;",
          "589:  if (!icmpv4_xrlim_allow(net, rt, type, code))",
          "590:   goto ende;",
          "",
          "[Removed Lines]",
          "509:  {",
          "510:   struct flowi fl = {",
          "511:    .fl4_dst = icmp_param.replyopts.srr ?",
          "512:        icmp_param.replyopts.faddr : iph->saddr,",
          "513:    .fl4_src = saddr,",
          "514:    .fl4_tos = RT_TOS(tos),",
          "515:    .proto = IPPROTO_ICMP,",
          "516:    .fl_icmp_type = type,",
          "517:    .fl_icmp_code = code,",
          "518:   };",
          "519:   int err;",
          "520:   struct rtable *rt2;",
          "522:   security_skb_classify_flow(skb_in, &fl);",
          "523:   if (__ip_route_output_key(net, &rt, &fl))",
          "524:    goto out_unlock;",
          "527:   rt2 = rt;",
          "529:   if (!fl.nl_u.ip4_u.saddr)",
          "530:    fl.nl_u.ip4_u.saddr = rt->rt_src;",
          "532:   err = xfrm_lookup(net, (struct dst_entry **)&rt, &fl, NULL, 0);",
          "533:   switch (err) {",
          "534:   case 0:",
          "535:    if (rt != rt2)",
          "536:     goto route_done;",
          "537:    break;",
          "538:   case -EPERM:",
          "539:    rt = NULL;",
          "540:    break;",
          "541:   default:",
          "542:    goto out_unlock;",
          "543:   }",
          "545:   if (xfrm_decode_session_reverse(skb_in, &fl, AF_INET))",
          "546:    goto relookup_failed;",
          "548:   if (inet_addr_type(net, fl.fl4_src) == RTN_LOCAL)",
          "549:    err = __ip_route_output_key(net, &rt2, &fl);",
          "550:   else {",
          "551:    struct flowi fl2 = {};",
          "552:    unsigned long orefdst;",
          "554:    fl2.fl4_dst = fl.fl4_src;",
          "555:    if (ip_route_output_key(net, &rt2, &fl2))",
          "556:     goto relookup_failed;",
          "560:    err = ip_route_input(skb_in, fl.fl4_dst, fl.fl4_src,",
          "561:           RT_TOS(tos), rt2->dst.dev);",
          "563:    dst_release(&rt2->dst);",
          "564:    rt2 = skb_rtable(skb_in);",
          "566:   }",
          "568:   if (err)",
          "569:    goto relookup_failed;",
          "571:   err = xfrm_lookup(net, (struct dst_entry **)&rt2, &fl, NULL,",
          "572:       XFRM_LOOKUP_ICMP);",
          "573:   switch (err) {",
          "574:   case 0:",
          "575:    dst_release(&rt->dst);",
          "576:    rt = rt2;",
          "577:    break;",
          "578:   case -EPERM:",
          "579:    goto ende;",
          "580:   default:",
          "581: relookup_failed:",
          "582:    if (!rt)",
          "583:     goto out_unlock;",
          "584:    break;",
          "585:   }",
          "586:  }",
          "588: route_done:",
          "",
          "[Added Lines]",
          "601:  rt = icmp_route_lookup(net, skb_in, iph, saddr, tos,",
          "602:           type, code, &icmp_param);",
          "603:  if (IS_ERR(rt))",
          "604:   goto out_unlock;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6bd023f3dddfc7c5f660089598c10e1f4167083b",
      "candidate_info": {
        "commit_hash": "6bd023f3dddfc7c5f660089598c10e1f4167083b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6bd023f3dddfc7c5f660089598c10e1f4167083b",
        "files": [
          "include/net/inet_connection_sock.h",
          "net/dccp/ipv4.c",
          "net/ipv4/inet_connection_sock.c",
          "net/ipv4/tcp_ipv4.c"
        ],
        "message": "ipv4: Make caller provide flowi4 key to inet_csk_route_req().\n\nThis way the caller can get at the fully resolved fl4->{daddr,saddr}\netc.\n\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/net/inet_connection_sock.h||include/net/inet_connection_sock.h",
          "net/dccp/ipv4.c||net/dccp/ipv4.c",
          "net/ipv4/inet_connection_sock.c||net/ipv4/inet_connection_sock.c",
          "net/ipv4/tcp_ipv4.c||net/ipv4/tcp_ipv4.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/dccp/ipv4.c||net/dccp/ipv4.c",
            "net/ipv4/inet_connection_sock.c||net/ipv4/inet_connection_sock.c",
            "net/ipv4/tcp_ipv4.c||net/ipv4/tcp_ipv4.c"
          ],
          "candidate": [
            "net/dccp/ipv4.c||net/dccp/ipv4.c",
            "net/ipv4/inet_connection_sock.c||net/ipv4/inet_connection_sock.c",
            "net/ipv4/tcp_ipv4.c||net/ipv4/tcp_ipv4.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/inet_connection_sock.h||include/net/inet_connection_sock.h": [
          "File: include/net/inet_connection_sock.h -> include/net/inet_connection_sock.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "249: extern int inet_csk_get_port(struct sock *sk, unsigned short snum);",
          "251: extern struct dst_entry* inet_csk_route_req(struct sock *sk,",
          "252:          const struct request_sock *req);",
          "253: extern struct dst_entry* inet_csk_route_child_sock(struct sock *sk,",
          "254:          struct sock *newsk,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "252:          struct flowi4 *fl4,",
          "",
          "---------------"
        ],
        "net/dccp/ipv4.c||net/dccp/ipv4.c": [
          "File: net/dccp/ipv4.c -> net/dccp/ipv4.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "497:  int err = -1;",
          "498:  struct sk_buff *skb;",
          "499:  struct dst_entry *dst;",
          "502:  if (dst == NULL)",
          "503:   goto out;",
          "",
          "[Removed Lines]",
          "501:  dst = inet_csk_route_req(sk, req);",
          "",
          "[Added Lines]",
          "500:  struct flowi4 fl4;",
          "502:  dst = inet_csk_route_req(sk, &fl4, req);",
          "",
          "---------------"
        ],
        "net/ipv4/inet_connection_sock.c||net/ipv4/inet_connection_sock.c": [
          "File: net/ipv4/inet_connection_sock.c -> net/ipv4/inet_connection_sock.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "350: EXPORT_SYMBOL(inet_csk_reset_keepalive_timer);",
          "352: struct dst_entry *inet_csk_route_req(struct sock *sk,",
          "353:          const struct request_sock *req)",
          "354: {",
          "355:  struct rtable *rt;",
          "356:  const struct inet_request_sock *ireq = inet_rsk(req);",
          "357:  struct ip_options_rcu *opt = inet_rsk(req)->opt;",
          "358:  struct net *net = sock_net(sk);",
          "362:       RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE,",
          "363:       sk->sk_protocol, inet_sk_flowi_flags(sk),",
          "364:       (opt && opt->opt.srr) ? opt->opt.faddr : ireq->rmt_addr,",
          "365:       ireq->loc_addr, ireq->rmt_port, inet_sk(sk)->inet_sport);",
          "368:  if (IS_ERR(rt))",
          "369:   goto no_route;",
          "371:   goto route_err;",
          "372:  return &rt->dst;",
          "",
          "[Removed Lines]",
          "359:  struct flowi4 fl4;",
          "361:  flowi4_init_output(&fl4, sk->sk_bound_dev_if, sk->sk_mark,",
          "366:  security_req_classify_flow(req, flowi4_to_flowi(&fl4));",
          "367:  rt = ip_route_output_flow(net, &fl4, sk);",
          "370:  if (opt && opt->opt.is_strictroute && fl4.daddr != rt->rt_gateway)",
          "",
          "[Added Lines]",
          "353:          struct flowi4 *fl4,",
          "361:  flowi4_init_output(fl4, sk->sk_bound_dev_if, sk->sk_mark,",
          "366:  security_req_classify_flow(req, flowi4_to_flowi(fl4));",
          "367:  rt = ip_route_output_flow(net, fl4, sk);",
          "370:  if (opt && opt->opt.is_strictroute && fl4->daddr != rt->rt_gateway)",
          "",
          "---------------"
        ],
        "net/ipv4/tcp_ipv4.c||net/ipv4/tcp_ipv4.c": [
          "File: net/ipv4/tcp_ipv4.c -> net/ipv4/tcp_ipv4.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "769:          struct request_values *rvp)",
          "770: {",
          "771:  const struct inet_request_sock *ireq = inet_rsk(req);",
          "772:  int err = -1;",
          "773:  struct sk_buff * skb;",
          "777:   return -1;",
          "779:  skb = tcp_make_synack(sk, dst, req, rvp);",
          "",
          "[Removed Lines]",
          "776:  if (!dst && (dst = inet_csk_route_req(sk, req)) == NULL)",
          "",
          "[Added Lines]",
          "772:  struct flowi4 fl4;",
          "777:  if (!dst && (dst = inet_csk_route_req(sk, &fl4, req)) == NULL)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1338:   req->cookie_ts = tmp_opt.tstamp_ok;",
          "1339:  } else if (!isn) {",
          "1340:   struct inet_peer *peer = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1342:   struct flowi4 fl4;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1351:   if (tmp_opt.saw_tstamp &&",
          "1352:       tcp_death_row.sysctl_tw_recycle &&",
          "1354:       (peer = rt_get_peer((struct rtable *)dst)) != NULL &&",
          "1355:       peer->daddr.addr.a4 == saddr) {",
          "1356:    inet_peer_refcheck(peer);",
          "",
          "[Removed Lines]",
          "1353:       (dst = inet_csk_route_req(sk, req)) != NULL &&",
          "",
          "[Added Lines]",
          "1355:       (dst = inet_csk_route_req(sk, &fl4, req)) != NULL &&",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e79d9bc7ea76e08fc24d7adaad8b6a821d1624c3",
      "candidate_info": {
        "commit_hash": "e79d9bc7ea76e08fc24d7adaad8b6a821d1624c3",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e79d9bc7ea76e08fc24d7adaad8b6a821d1624c3",
        "files": [
          "net/ipv4/inet_connection_sock.c"
        ],
        "message": "ipv4: Use flowi4_init_output() in inet_connection_sock.c\n\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv4/inet_connection_sock.c||net/ipv4/inet_connection_sock.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv4/inet_connection_sock.c||net/ipv4/inet_connection_sock.c"
          ],
          "candidate": [
            "net/ipv4/inet_connection_sock.c||net/ipv4/inet_connection_sock.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ipv4/inet_connection_sock.c||net/ipv4/inet_connection_sock.c": [
          "File: net/ipv4/inet_connection_sock.c -> net/ipv4/inet_connection_sock.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "356:  struct rtable *rt;",
          "357:  const struct inet_request_sock *ireq = inet_rsk(req);",
          "358:  struct ip_options *opt = inet_rsk(req)->opt;",
          "371:  struct net *net = sock_net(sk);",
          "373:  security_req_classify_flow(req, flowi4_to_flowi(&fl4));",
          "374:  rt = ip_route_output_flow(net, &fl4, sk);",
          "375:  if (IS_ERR(rt))",
          "",
          "[Removed Lines]",
          "359:  struct flowi4 fl4 = {",
          "360:   .flowi4_oif = sk->sk_bound_dev_if,",
          "361:   .flowi4_mark = sk->sk_mark,",
          "362:   .daddr = ((opt && opt->srr) ?",
          "363:      opt->faddr : ireq->rmt_addr),",
          "364:   .saddr = ireq->loc_addr,",
          "365:   .flowi4_tos = RT_CONN_FLAGS(sk),",
          "366:   .flowi4_proto = sk->sk_protocol,",
          "367:   .flowi4_flags = inet_sk_flowi_flags(sk),",
          "368:   .fl4_sport = inet_sk(sk)->inet_sport,",
          "369:   .fl4_dport = ireq->rmt_port,",
          "370:  };",
          "",
          "[Added Lines]",
          "360:  struct flowi4 fl4;",
          "362:  flowi4_init_output(&fl4, sk->sk_bound_dev_if, sk->sk_mark,",
          "363:       RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE,",
          "364:       sk->sk_protocol, inet_sk_flowi_flags(sk),",
          "365:       (opt && opt->srr) ? opt->faddr : ireq->rmt_addr,",
          "366:       ireq->loc_addr, ireq->rmt_port, inet_sk(sk)->inet_sport);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "778865a550e7958c1211242cc481f48d46de0f04",
      "candidate_info": {
        "commit_hash": "778865a550e7958c1211242cc481f48d46de0f04",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/778865a550e7958c1211242cc481f48d46de0f04",
        "files": [
          "net/l2tp/l2tp_ip.c"
        ],
        "message": "l2tp: Fix inet_opt conversion.\n\nWe don't actually hold the socket lock at this point, so the\nrcu_dereference_protected() isn't' correct.  Thanks to Eric\nDumazet for pointing this out.\n\nThankfully, we're only interested in fetching the faddr value\nif srr is enabled, so we can simply make this an RCU sequence\nand use plain rcu_dereference().\n\nReported-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/l2tp/l2tp_ip.c||net/l2tp/l2tp_ip.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/l2tp/l2tp_ip.c||net/l2tp/l2tp_ip.c"
          ],
          "candidate": [
            "net/l2tp/l2tp_ip.c||net/l2tp/l2tp_ip.c"
          ]
        }
      },
      "candidate_diff": {
        "net/l2tp/l2tp_ip.c||net/l2tp/l2tp_ip.c": [
          "File: net/l2tp/l2tp_ip.c -> net/l2tp/l2tp_ip.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "472:  if (rt == NULL) {",
          "473:   struct ip_options_rcu *inet_opt;",
          "479:   if (inet_opt && inet_opt->opt.srr)",
          "480:    daddr = inet_opt->opt.faddr;",
          "",
          "[Removed Lines]",
          "475:   inet_opt = rcu_dereference_protected(inet->inet_opt,",
          "476:            sock_owned_by_user(sk));",
          "",
          "[Added Lines]",
          "475:   rcu_read_lock();",
          "476:   inet_opt = rcu_dereference(inet->inet_opt);",
          "482:   rcu_read_unlock();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9d6ec938019c6b16cb9ec96598ebe8f20de435fe",
      "candidate_info": {
        "commit_hash": "9d6ec938019c6b16cb9ec96598ebe8f20de435fe",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9d6ec938019c6b16cb9ec96598ebe8f20de435fe",
        "files": [
          "include/net/route.h",
          "net/dccp/ipv4.c",
          "net/ipv4/icmp.c",
          "net/ipv4/inet_connection_sock.c",
          "net/ipv4/ip_output.c",
          "net/ipv4/netfilter.c",
          "net/ipv4/raw.c",
          "net/ipv4/route.c",
          "net/ipv4/syncookies.c",
          "net/ipv4/udp.c",
          "net/ipv4/xfrm4_policy.c",
          "net/netfilter/ipvs/ip_vs_xmit.c",
          "net/netfilter/xt_TEE.c",
          "net/sctp/protocol.c"
        ],
        "message": "ipv4: Use flowi4 in public route lookup interfaces.\n\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/net/route.h||include/net/route.h",
          "net/dccp/ipv4.c||net/dccp/ipv4.c",
          "net/ipv4/icmp.c||net/ipv4/icmp.c",
          "net/ipv4/inet_connection_sock.c||net/ipv4/inet_connection_sock.c",
          "net/ipv4/ip_output.c||net/ipv4/ip_output.c",
          "net/ipv4/netfilter.c||net/ipv4/netfilter.c",
          "net/ipv4/raw.c||net/ipv4/raw.c",
          "net/ipv4/route.c||net/ipv4/route.c",
          "net/ipv4/syncookies.c||net/ipv4/syncookies.c",
          "net/ipv4/udp.c||net/ipv4/udp.c",
          "net/ipv4/xfrm4_policy.c||net/ipv4/xfrm4_policy.c",
          "net/netfilter/ipvs/ip_vs_xmit.c||net/netfilter/ipvs/ip_vs_xmit.c",
          "net/netfilter/xt_TEE.c||net/netfilter/xt_TEE.c",
          "net/sctp/protocol.c||net/sctp/protocol.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/dccp/ipv4.c||net/dccp/ipv4.c",
            "net/ipv4/icmp.c||net/ipv4/icmp.c",
            "net/ipv4/inet_connection_sock.c||net/ipv4/inet_connection_sock.c",
            "net/ipv4/ip_output.c||net/ipv4/ip_output.c",
            "net/ipv4/raw.c||net/ipv4/raw.c",
            "net/ipv4/syncookies.c||net/ipv4/syncookies.c",
            "net/ipv4/udp.c||net/ipv4/udp.c"
          ],
          "candidate": [
            "net/dccp/ipv4.c||net/dccp/ipv4.c",
            "net/ipv4/icmp.c||net/ipv4/icmp.c",
            "net/ipv4/inet_connection_sock.c||net/ipv4/inet_connection_sock.c",
            "net/ipv4/ip_output.c||net/ipv4/ip_output.c",
            "net/ipv4/raw.c||net/ipv4/raw.c",
            "net/ipv4/syncookies.c||net/ipv4/syncookies.c",
            "net/ipv4/udp.c||net/ipv4/udp.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/route.h||include/net/route.h": [
          "File: include/net/route.h -> include/net/route.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "122:            __be32 src, struct net_device *dev);",
          "123: extern void  rt_cache_flush(struct net *net, int how);",
          "124: extern void  rt_cache_flush_batch(struct net *net);",
          "127:         struct sock *sk);",
          "128: extern struct dst_entry *ipv4_blackhole_route(struct net *net, struct dst_entry *dst_orig);",
          "131: {",
          "132:  return ip_route_output_flow(net, flp, NULL);",
          "133: }",
          "",
          "[Removed Lines]",
          "125: extern struct rtable *__ip_route_output_key(struct net *, const struct flowi *flp);",
          "126: extern struct rtable *ip_route_output_flow(struct net *, struct flowi *flp,",
          "130: static inline struct rtable *ip_route_output_key(struct net *net, struct flowi *flp)",
          "",
          "[Added Lines]",
          "125: extern struct rtable *__ip_route_output_key(struct net *, const struct flowi4 *flp);",
          "126: extern struct rtable *ip_route_output_flow(struct net *, struct flowi4 *flp,",
          "130: static inline struct rtable *ip_route_output_key(struct net *net, struct flowi4 *flp)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "135: static inline struct rtable *ip_route_output(struct net *net, __be32 daddr,",
          "136:           __be32 saddr, u8 tos, int oif)",
          "137: {",
          "143:  };",
          "145: }",
          "147: static inline struct rtable *ip_route_output_ports(struct net *net, struct sock *sk,",
          "",
          "[Removed Lines]",
          "138:  struct flowi fl = {",
          "139:   .flowi_oif = oif,",
          "140:   .fl4_dst = daddr,",
          "141:   .fl4_src = saddr,",
          "142:   .fl4_tos = tos,",
          "144:  return ip_route_output_key(net, &fl);",
          "",
          "[Added Lines]",
          "138:  struct flowi4 fl4 = {",
          "139:   .flowi4_oif = oif,",
          "140:   .daddr = daddr,",
          "141:   .saddr = saddr,",
          "142:   .flowi4_tos = tos,",
          "144:  return ip_route_output_key(net, &fl4);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "149:          __be16 dport, __be16 sport,",
          "150:          __u8 proto, __u8 tos, int oif)",
          "151: {",
          "162:  };",
          "163:  if (sk)",
          "166: }",
          "168: static inline struct rtable *ip_route_output_gre(struct net *net,",
          "169:        __be32 daddr, __be32 saddr,",
          "170:        __be32 gre_key, __u8 tos, int oif)",
          "171: {",
          "179:  };",
          "181: }",
          "183: extern int ip_route_input_common(struct sk_buff *skb, __be32 dst, __be32 src,",
          "",
          "[Removed Lines]",
          "152:  struct flowi fl = {",
          "153:   .flowi_oif = oif,",
          "154:   .flowi_flags = sk ? inet_sk_flowi_flags(sk) : 0,",
          "155:   .flowi_mark = sk ? sk->sk_mark : 0,",
          "156:   .fl4_dst = daddr,",
          "157:   .fl4_src = saddr,",
          "158:   .fl4_tos = tos,",
          "159:   .flowi_proto = proto,",
          "160:   .fl4_dport = dport,",
          "161:   .fl4_sport = sport,",
          "164:   security_sk_classify_flow(sk, &fl);",
          "165:  return ip_route_output_flow(net, &fl, sk);",
          "172:  struct flowi fl = {",
          "173:   .flowi_oif = oif,",
          "174:   .fl4_dst = daddr,",
          "175:   .fl4_src = saddr,",
          "176:   .fl4_tos = tos,",
          "177:   .flowi_proto = IPPROTO_GRE,",
          "178:   .fl4_gre_key = gre_key,",
          "180:  return ip_route_output_key(net, &fl);",
          "",
          "[Added Lines]",
          "152:  struct flowi4 fl4 = {",
          "153:   .flowi4_oif = oif,",
          "154:   .flowi4_flags = sk ? inet_sk_flowi_flags(sk) : 0,",
          "155:   .flowi4_mark = sk ? sk->sk_mark : 0,",
          "156:   .daddr = daddr,",
          "157:   .saddr = saddr,",
          "158:   .flowi4_tos = tos,",
          "159:   .flowi4_proto = proto,",
          "160:   .uli.ports.dport = dport,",
          "161:   .uli.ports.sport = sport,",
          "164:   security_sk_classify_flow(sk, flowi4_to_flowi(&fl4));",
          "165:  return ip_route_output_flow(net, &fl4, sk);",
          "172:  struct flowi4 fl4 = {",
          "173:   .flowi4_oif = oif,",
          "174:   .daddr = daddr,",
          "175:   .saddr = saddr,",
          "176:   .flowi4_tos = tos,",
          "177:   .flowi4_proto = IPPROTO_GRE,",
          "178:   .uli.gre_key = gre_key,",
          "180:  return ip_route_output_key(net, &fl4);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "228:            __be16 sport, __be16 dport,",
          "229:            struct sock *sk, bool can_sleep)",
          "230: {",
          "240:  };",
          "241:  struct net *net = sock_net(sk);",
          "242:  struct rtable *rt;",
          "244:  if (inet_sk(sk)->transparent)",
          "246:  if (protocol == IPPROTO_TCP)",
          "248:  if (can_sleep)",
          "251:  if (!dst || !src) {",
          "253:   if (IS_ERR(rt))",
          "254:    return rt;",
          "257:   ip_rt_put(rt);",
          "258:  }",
          "261: }",
          "263: static inline struct rtable *ip_route_newports(struct rtable *rt,",
          "",
          "[Removed Lines]",
          "231:  struct flowi fl = {",
          "232:   .flowi_oif = oif,",
          "233:   .flowi_mark = sk->sk_mark,",
          "234:   .fl4_dst = dst,",
          "235:   .fl4_src = src,",
          "236:   .fl4_tos = tos,",
          "237:   .flowi_proto = protocol,",
          "238:   .fl4_sport = sport,",
          "239:   .fl4_dport = dport,",
          "245:   fl.flowi_flags |= FLOWI_FLAG_ANYSRC;",
          "247:   fl.flowi_flags |= FLOWI_FLAG_PRECOW_METRICS;",
          "249:   fl.flowi_flags |= FLOWI_FLAG_CAN_SLEEP;",
          "252:   rt = __ip_route_output_key(net, &fl);",
          "255:   fl.fl4_dst = rt->rt_dst;",
          "256:   fl.fl4_src = rt->rt_src;",
          "259:  security_sk_classify_flow(sk, &fl);",
          "260:  return ip_route_output_flow(net, &fl, sk);",
          "",
          "[Added Lines]",
          "231:  struct flowi4 fl4 = {",
          "232:   .flowi4_oif = oif,",
          "233:   .flowi4_mark = sk->sk_mark,",
          "234:   .daddr = dst,",
          "235:   .saddr = src,",
          "236:   .flowi4_tos = tos,",
          "237:   .flowi4_proto = protocol,",
          "238:   .uli.ports.sport = sport,",
          "239:   .uli.ports.dport = dport,",
          "245:   fl4.flowi4_flags |= FLOWI_FLAG_ANYSRC;",
          "247:   fl4.flowi4_flags |= FLOWI_FLAG_PRECOW_METRICS;",
          "249:   fl4.flowi4_flags |= FLOWI_FLAG_CAN_SLEEP;",
          "252:   rt = __ip_route_output_key(net, &fl4);",
          "255:   fl4.daddr = rt->rt_dst;",
          "256:   fl4.saddr = rt->rt_src;",
          "259:  security_sk_classify_flow(sk, flowi4_to_flowi(&fl4));",
          "260:  return ip_route_output_flow(net, &fl4, sk);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "266:             __be16 dport, struct sock *sk)",
          "267: {",
          "268:  if (sport != orig_sport || dport != orig_dport) {",
          "278:   };",
          "279:   if (inet_sk(sk)->transparent)",
          "281:   if (protocol == IPPROTO_TCP)",
          "283:   ip_rt_put(rt);",
          "286:  }",
          "287:  return rt;",
          "288: }",
          "",
          "[Removed Lines]",
          "269:   struct flowi fl = {",
          "270:    .flowi_oif = rt->rt_oif,",
          "271:    .flowi_mark = rt->rt_mark,",
          "272:    .fl4_dst = rt->rt_key_dst,",
          "273:    .fl4_src = rt->rt_key_src,",
          "274:    .fl4_tos = rt->rt_tos,",
          "275:    .flowi_proto = protocol,",
          "276:    .fl4_sport = sport,",
          "277:    .fl4_dport = dport",
          "280:    fl.flowi_flags |= FLOWI_FLAG_ANYSRC;",
          "282:    fl.flowi_flags |= FLOWI_FLAG_PRECOW_METRICS;",
          "284:   security_sk_classify_flow(sk, &fl);",
          "285:   return ip_route_output_flow(sock_net(sk), &fl, sk);",
          "",
          "[Added Lines]",
          "269:   struct flowi4 fl4 = {",
          "270:    .flowi4_oif = rt->rt_oif,",
          "271:    .flowi4_mark = rt->rt_mark,",
          "272:    .daddr = rt->rt_key_dst,",
          "273:    .saddr = rt->rt_key_src,",
          "274:    .flowi4_tos = rt->rt_tos,",
          "275:    .flowi4_proto = protocol,",
          "276:    .uli.ports.sport = sport,",
          "277:    .uli.ports.dport = dport",
          "280:    fl4.flowi4_flags |= FLOWI_FLAG_ANYSRC;",
          "282:    fl4.flowi4_flags |= FLOWI_FLAG_PRECOW_METRICS;",
          "284:   security_sk_classify_flow(sk, flowi4_to_flowi(&fl4));",
          "285:   return ip_route_output_flow(sock_net(sk), &fl4, sk);",
          "",
          "---------------"
        ],
        "net/dccp/ipv4.c||net/dccp/ipv4.c": [
          "File: net/dccp/ipv4.c -> net/dccp/ipv4.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "465:         struct sk_buff *skb)",
          "466: {",
          "467:  struct rtable *rt;",
          "476:  };",
          "480:  if (IS_ERR(rt)) {",
          "481:   IP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES);",
          "482:   return NULL;",
          "",
          "[Removed Lines]",
          "468:  struct flowi fl = {",
          "469:   .flowi_oif = skb_rtable(skb)->rt_iif,",
          "470:   .fl4_dst = ip_hdr(skb)->saddr,",
          "471:   .fl4_src = ip_hdr(skb)->daddr,",
          "472:   .fl4_tos = RT_CONN_FLAGS(sk),",
          "473:   .flowi_proto = sk->sk_protocol,",
          "474:   .fl4_sport = dccp_hdr(skb)->dccph_dport,",
          "475:   .fl4_dport = dccp_hdr(skb)->dccph_sport,",
          "478:  security_skb_classify_flow(skb, &fl);",
          "479:  rt = ip_route_output_flow(net, &fl, sk);",
          "",
          "[Added Lines]",
          "468:  struct flowi4 fl4 = {",
          "469:   .flowi4_oif = skb_rtable(skb)->rt_iif,",
          "470:   .daddr = ip_hdr(skb)->saddr,",
          "471:   .saddr = ip_hdr(skb)->daddr,",
          "472:   .flowi4_tos = RT_CONN_FLAGS(sk),",
          "473:   .flowi4_proto = sk->sk_protocol,",
          "474:   .uli.ports.sport = dccp_hdr(skb)->dccph_dport,",
          "475:   .uli.ports.dport = dccp_hdr(skb)->dccph_sport,",
          "478:  security_skb_classify_flow(skb, flowi4_to_flowi(&fl4));",
          "479:  rt = ip_route_output_flow(net, &fl4, sk);",
          "",
          "---------------"
        ],
        "net/ipv4/icmp.c||net/ipv4/icmp.c": [
          "File: net/ipv4/icmp.c -> net/ipv4/icmp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "353:    daddr = icmp_param->replyopts.faddr;",
          "354:  }",
          "355:  {",
          "361:   };",
          "364:   if (IS_ERR(rt))",
          "365:    goto out_unlock;",
          "366:  }",
          "",
          "[Removed Lines]",
          "356:   struct flowi fl = {",
          "357:    .fl4_dst = daddr,",
          "358:    .fl4_src = rt->rt_spec_dst,",
          "359:    .fl4_tos = RT_TOS(ip_hdr(skb)->tos),",
          "360:    .flowi_proto = IPPROTO_ICMP,",
          "362:   security_skb_classify_flow(skb, &fl);",
          "363:   rt = ip_route_output_key(net, &fl);",
          "",
          "[Added Lines]",
          "356:   struct flowi4 fl4 = {",
          "357:    .daddr = daddr,",
          "358:    .saddr = rt->rt_spec_dst,",
          "359:    .flowi4_tos = RT_TOS(ip_hdr(skb)->tos),",
          "360:    .flowi4_proto = IPPROTO_ICMP,",
          "362:   security_skb_classify_flow(skb, flowi4_to_flowi(&fl4));",
          "363:   rt = ip_route_output_key(net, &fl4);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "378:      int type, int code,",
          "379:      struct icmp_bxm *param)",
          "380: {",
          "389:  };",
          "390:  struct rtable *rt, *rt2;",
          "391:  int err;",
          "395:  if (IS_ERR(rt))",
          "396:   return rt;",
          "399:  rt2 = rt;",
          "405:  if (!IS_ERR(rt)) {",
          "406:   if (rt != rt2)",
          "407:    return rt;",
          "",
          "[Removed Lines]",
          "381:  struct flowi fl = {",
          "382:   .fl4_dst = (param->replyopts.srr ?",
          "383:        param->replyopts.faddr : iph->saddr),",
          "384:   .fl4_src = saddr,",
          "385:   .fl4_tos = RT_TOS(tos),",
          "386:   .flowi_proto = IPPROTO_ICMP,",
          "387:   .fl4_icmp_type = type,",
          "388:   .fl4_icmp_code = code,",
          "393:  security_skb_classify_flow(skb_in, &fl);",
          "394:  rt = __ip_route_output_key(net, &fl);",
          "401:  if (!fl.fl4_src)",
          "402:   fl.fl4_src = rt->rt_src;",
          "404:  rt = (struct rtable *) xfrm_lookup(net, &rt->dst, &fl, NULL, 0);",
          "",
          "[Added Lines]",
          "381:  struct flowi4 fl4 = {",
          "382:   .daddr = (param->replyopts.srr ?",
          "383:      param->replyopts.faddr : iph->saddr),",
          "384:   .saddr = saddr,",
          "385:   .flowi4_tos = RT_TOS(tos),",
          "386:   .flowi4_proto = IPPROTO_ICMP,",
          "387:   .uli.icmpt.type = type,",
          "388:   .uli.icmpt.code = code,",
          "393:  security_skb_classify_flow(skb_in, flowi4_to_flowi(&fl4));",
          "394:  rt = __ip_route_output_key(net, &fl4);",
          "401:  if (!fl4.saddr)",
          "402:   fl4.saddr = rt->rt_src;",
          "404:  rt = (struct rtable *) xfrm_lookup(net, &rt->dst,",
          "405:         flowi4_to_flowi(&fl4), NULL, 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "410:  } else",
          "411:   return rt;",
          "414:  if (err)",
          "415:   goto relookup_failed;",
          "419:   if (IS_ERR(rt2))",
          "420:    err = PTR_ERR(rt2);",
          "421:  } else {",
          "423:   unsigned long orefdst;",
          "427:   if (IS_ERR(rt2)) {",
          "428:    err = PTR_ERR(rt2);",
          "429:    goto relookup_failed;",
          "430:   }",
          "434:          RT_TOS(tos), rt2->dst.dev);",
          "436:   dst_release(&rt2->dst);",
          "",
          "[Removed Lines]",
          "413:  err = xfrm_decode_session_reverse(skb_in, &fl, AF_INET);",
          "417:  if (inet_addr_type(net, fl.fl4_src) == RTN_LOCAL) {",
          "418:   rt2 = __ip_route_output_key(net, &fl);",
          "422:   struct flowi fl2 = {};",
          "425:   fl2.fl4_dst = fl.fl4_src;",
          "426:   rt2 = ip_route_output_key(net, &fl2);",
          "433:   err = ip_route_input(skb_in, fl.fl4_dst, fl.fl4_src,",
          "",
          "[Added Lines]",
          "414:  err = xfrm_decode_session_reverse(skb_in, flowi4_to_flowi(&fl4), AF_INET);",
          "418:  if (inet_addr_type(net, fl4.saddr) == RTN_LOCAL) {",
          "419:   rt2 = __ip_route_output_key(net, &fl4);",
          "423:   struct flowi4 fl4_2 = {};",
          "426:   fl4_2.daddr = fl4.saddr;",
          "427:   rt2 = ip_route_output_key(net, &fl4_2);",
          "434:   err = ip_route_input(skb_in, fl4.daddr, fl4.saddr,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "441:  if (err)",
          "442:   goto relookup_failed;",
          "445:  if (!IS_ERR(rt2)) {",
          "446:   dst_release(&rt->dst);",
          "447:   rt = rt2;",
          "",
          "[Removed Lines]",
          "444:  rt2 = (struct rtable *) xfrm_lookup(net, &rt2->dst, &fl, NULL, XFRM_LOOKUP_ICMP);",
          "",
          "[Added Lines]",
          "445:  rt2 = (struct rtable *) xfrm_lookup(net, &rt2->dst,",
          "446:          flowi4_to_flowi(&fl4), NULL,",
          "447:          XFRM_LOOKUP_ICMP);",
          "",
          "---------------"
        ],
        "net/ipv4/inet_connection_sock.c||net/ipv4/inet_connection_sock.c": [
          "File: net/ipv4/inet_connection_sock.c -> net/ipv4/inet_connection_sock.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "356:  struct rtable *rt;",
          "357:  const struct inet_request_sock *ireq = inet_rsk(req);",
          "358:  struct ip_options *opt = inet_rsk(req)->opt;",
          "370:  };",
          "371:  struct net *net = sock_net(sk);",
          "375:  if (IS_ERR(rt))",
          "376:   goto no_route;",
          "377:  if (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway)",
          "",
          "[Removed Lines]",
          "359:  struct flowi fl = {",
          "360:   .flowi_oif = sk->sk_bound_dev_if,",
          "361:   .flowi_mark = sk->sk_mark,",
          "362:   .fl4_dst = ((opt && opt->srr) ?",
          "363:        opt->faddr : ireq->rmt_addr),",
          "364:   .fl4_src = ireq->loc_addr,",
          "365:   .fl4_tos = RT_CONN_FLAGS(sk),",
          "366:   .flowi_proto = sk->sk_protocol,",
          "367:   .flowi_flags = inet_sk_flowi_flags(sk),",
          "368:   .fl4_sport = inet_sk(sk)->inet_sport,",
          "369:   .fl4_dport = ireq->rmt_port,",
          "373:  security_req_classify_flow(req, &fl);",
          "374:  rt = ip_route_output_flow(net, &fl, sk);",
          "",
          "[Added Lines]",
          "359:  struct flowi4 fl4 = {",
          "360:   .flowi4_oif = sk->sk_bound_dev_if,",
          "361:   .flowi4_mark = sk->sk_mark,",
          "362:   .daddr = ((opt && opt->srr) ?",
          "363:      opt->faddr : ireq->rmt_addr),",
          "364:   .saddr = ireq->loc_addr,",
          "365:   .flowi4_tos = RT_CONN_FLAGS(sk),",
          "366:   .flowi4_proto = sk->sk_protocol,",
          "367:   .flowi4_flags = inet_sk_flowi_flags(sk),",
          "368:   .uli.ports.sport = inet_sk(sk)->inet_sport,",
          "369:   .uli.ports.dport = ireq->rmt_port,",
          "373:  security_req_classify_flow(req, flowi4_to_flowi(&fl4));",
          "374:  rt = ip_route_output_flow(net, &fl4, sk);",
          "",
          "---------------"
        ],
        "net/ipv4/ip_output.c||net/ipv4/ip_output.c": [
          "File: net/ipv4/ip_output.c -> net/ipv4/ip_output.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1474:  }",
          "1476:  {",
          "1486:   };",
          "1489:   if (IS_ERR(rt))",
          "1490:    return;",
          "1491:  }",
          "",
          "[Removed Lines]",
          "1477:   struct flowi fl = {",
          "1478:    .flowi_oif = arg->bound_dev_if,",
          "1479:    .fl4_dst = daddr,",
          "1480:    .fl4_src = rt->rt_spec_dst,",
          "1481:    .fl4_tos = RT_TOS(ip_hdr(skb)->tos),",
          "1482:    .fl4_sport = tcp_hdr(skb)->dest,",
          "1483:    .fl4_dport = tcp_hdr(skb)->source,",
          "1484:    .flowi_proto = sk->sk_protocol,",
          "1485:    .flowi_flags = ip_reply_arg_flowi_flags(arg),",
          "1487:   security_skb_classify_flow(skb, &fl);",
          "1488:   rt = ip_route_output_key(sock_net(sk), &fl);",
          "",
          "[Added Lines]",
          "1477:   struct flowi4 fl4 = {",
          "1478:    .flowi4_oif = arg->bound_dev_if,",
          "1479:    .daddr = daddr,",
          "1480:    .saddr = rt->rt_spec_dst,",
          "1481:    .flowi4_tos = RT_TOS(ip_hdr(skb)->tos),",
          "1482:    .uli.ports.sport = tcp_hdr(skb)->dest,",
          "1483:    .uli.ports.dport = tcp_hdr(skb)->source,",
          "1484:    .flowi4_proto = sk->sk_protocol,",
          "1485:    .flowi4_flags = ip_reply_arg_flowi_flags(arg),",
          "1487:   security_skb_classify_flow(skb, flowi4_to_flowi(&fl4));",
          "1488:   rt = ip_route_output_key(sock_net(sk), &fl4);",
          "",
          "---------------"
        ],
        "net/ipv4/netfilter.c||net/ipv4/netfilter.c": [
          "File: net/ipv4/netfilter.c -> net/ipv4/netfilter.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "16:  struct net *net = dev_net(skb_dst(skb)->dev);",
          "17:  const struct iphdr *iph = ip_hdr(skb);",
          "18:  struct rtable *rt;",
          "20:  unsigned long orefdst;",
          "21:  unsigned int hh_len;",
          "22:  unsigned int type;",
          "",
          "[Removed Lines]",
          "19:  struct flowi fl = {};",
          "",
          "[Added Lines]",
          "19:  struct flowi4 fl4 = {};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "33:  if (addr_type == RTN_LOCAL) {",
          "35:   if (type == RTN_LOCAL)",
          "42:   if (IS_ERR(rt))",
          "43:    return -1;",
          "",
          "[Removed Lines]",
          "34:   fl.fl4_dst = iph->daddr;",
          "36:    fl.fl4_src = iph->saddr;",
          "37:   fl.fl4_tos = RT_TOS(iph->tos);",
          "38:   fl.flowi_oif = skb->sk ? skb->sk->sk_bound_dev_if : 0;",
          "39:   fl.flowi_mark = skb->mark;",
          "40:   fl.flowi_flags = skb->sk ? inet_sk_flowi_flags(skb->sk) : 0;",
          "41:   rt = ip_route_output_key(net, &fl);",
          "",
          "[Added Lines]",
          "34:   fl4.daddr = iph->daddr;",
          "36:    fl4.saddr = iph->saddr;",
          "37:   fl4.flowi4_tos = RT_TOS(iph->tos);",
          "38:   fl4.flowi4_oif = skb->sk ? skb->sk->sk_bound_dev_if : 0;",
          "39:   fl4.flowi4_mark = skb->mark;",
          "40:   fl4.flowi4_flags = skb->sk ? inet_sk_flowi_flags(skb->sk) : 0;",
          "41:   rt = ip_route_output_key(net, &fl4);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "48:  } else {",
          "53:   if (IS_ERR(rt))",
          "54:    return -1;",
          "",
          "[Removed Lines]",
          "51:   fl.fl4_dst = iph->saddr;",
          "52:   rt = ip_route_output_key(net, &fl);",
          "",
          "[Added Lines]",
          "51:   fl4.daddr = iph->saddr;",
          "52:   rt = ip_route_output_key(net, &fl4);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "69: #ifdef CONFIG_XFRM",
          "70:  if (!(IPCB(skb)->flags & IPSKB_XFRM_TRANSFORMED) &&",
          "72:   struct dst_entry *dst = skb_dst(skb);",
          "73:   skb_dst_set(skb, NULL);",
          "75:   if (IS_ERR(dst))",
          "76:    return -1;",
          "77:   skb_dst_set(skb, dst);",
          "",
          "[Removed Lines]",
          "71:      xfrm_decode_session(skb, &fl, AF_INET) == 0) {",
          "74:   dst = xfrm_lookup(net, dst, &fl, skb->sk, 0);",
          "",
          "[Added Lines]",
          "71:      xfrm_decode_session(skb, flowi4_to_flowi(&fl4), AF_INET) == 0) {",
          "74:   dst = xfrm_lookup(net, dst, flowi4_to_flowi(&fl4), skb->sk, 0);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "224: static int nf_ip_route(struct dst_entry **dst, struct flowi *fl)",
          "225: {",
          "227:  if (IS_ERR(rt))",
          "228:   return PTR_ERR(rt);",
          "",
          "[Removed Lines]",
          "226:  struct rtable *rt = ip_route_output_key(&init_net, fl);",
          "",
          "[Added Lines]",
          "226:  struct rtable *rt = ip_route_output_key(&init_net, &fl->u.ip4);",
          "",
          "---------------"
        ],
        "net/ipv4/raw.c||net/ipv4/raw.c": [
          "File: net/ipv4/raw.c -> net/ipv4/raw.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "402:  return err;",
          "403: }",
          "406: {",
          "407:  struct iovec *iov;",
          "408:  u8 __user *type = NULL;",
          "",
          "[Removed Lines]",
          "405: static int raw_probe_proto_opt(struct flowi *fl, struct msghdr *msg)",
          "",
          "[Added Lines]",
          "405: static int raw_probe_proto_opt(struct flowi4 *fl4, struct msghdr *msg)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "418:   if (!iov)",
          "419:    continue;",
          "422:   case IPPROTO_ICMP:",
          "424:    if (iov->iov_base && iov->iov_len < 1)",
          "",
          "[Removed Lines]",
          "421:   switch (fl->flowi_proto) {",
          "",
          "[Added Lines]",
          "421:   switch (fl4->flowi4_proto) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "433:     code = iov->iov_base;",
          "435:    if (type && code) {",
          "438:      return -EFAULT;",
          "439:     probed = 1;",
          "440:    }",
          "",
          "[Removed Lines]",
          "436:     if (get_user(fl->fl4_icmp_type, type) ||",
          "437:         get_user(fl->fl4_icmp_code, code))",
          "",
          "[Added Lines]",
          "436:     if (get_user(fl4->uli.icmpt.type, type) ||",
          "437:         get_user(fl4->uli.icmpt.code, code))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "548:  }",
          "550:  {",
          "559:   };",
          "560:   if (!inet->hdrincl) {",
          "562:    if (err)",
          "563:     goto done;",
          "564:   }",
          "568:   if (IS_ERR(rt)) {",
          "569:    err = PTR_ERR(rt);",
          "570:    goto done;",
          "",
          "[Removed Lines]",
          "551:   struct flowi fl = { .flowi_oif = ipc.oif,",
          "552:         .flowi_mark = sk->sk_mark,",
          "553:         .fl4_dst = daddr,",
          "554:         .fl4_src = saddr,",
          "555:         .fl4_tos = tos,",
          "556:         .flowi_proto = inet->hdrincl ? IPPROTO_RAW :",
          "557:             sk->sk_protocol,",
          "558:         .flowi_flags = FLOWI_FLAG_CAN_SLEEP,",
          "561:    err = raw_probe_proto_opt(&fl, msg);",
          "566:   security_sk_classify_flow(sk, &fl);",
          "567:   rt = ip_route_output_flow(sock_net(sk), &fl, sk);",
          "",
          "[Added Lines]",
          "551:   struct flowi4 fl4 = {",
          "552:    .flowi4_oif = ipc.oif,",
          "553:    .flowi4_mark = sk->sk_mark,",
          "554:    .daddr = daddr,",
          "555:    .saddr = saddr,",
          "556:    .flowi4_tos = tos,",
          "557:    .flowi4_proto = (inet->hdrincl ?",
          "558:       IPPROTO_RAW :",
          "559:       sk->sk_protocol),",
          "560:    .flowi4_flags = FLOWI_FLAG_CAN_SLEEP,",
          "563:    err = raw_probe_proto_opt(&fl4, msg);",
          "568:   security_sk_classify_flow(sk, flowi4_to_flowi(&fl4));",
          "569:   rt = ip_route_output_flow(sock_net(sk), &fl4, sk);",
          "",
          "---------------"
        ],
        "net/ipv4/route.c||net/ipv4/route.c": [
          "File: net/ipv4/route.c -> net/ipv4/route.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2626:  return rth;",
          "2627: }",
          "2630: {",
          "2631:  struct rtable *rth;",
          "2632:  unsigned int hash;",
          "",
          "[Removed Lines]",
          "2629: struct rtable *__ip_route_output_key(struct net *net, const struct flowi *flp)",
          "",
          "[Added Lines]",
          "2629: struct rtable *__ip_route_output_key(struct net *net, const struct flowi4 *flp4)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2634:  if (!rt_caching(net))",
          "2635:   goto slow_output;",
          "2639:  rcu_read_lock_bh();",
          "2640:  for (rth = rcu_dereference_bh(rt_hash_table[hash].chain); rth;",
          "2641:   rth = rcu_dereference_bh(rth->dst.rt_next)) {",
          "2644:       rt_is_output_route(rth) &&",
          "2648:        (IPTOS_RT_MASK | RTO_ONLINK)) &&",
          "2649:       net_eq(dev_net(rth->dst.dev), net) &&",
          "2650:       !rt_is_expired(rth)) {",
          "",
          "[Removed Lines]",
          "2637:  hash = rt_hash(flp->fl4_dst, flp->fl4_src, flp->flowi_oif, rt_genid(net));",
          "2642:   if (rth->rt_key_dst == flp->fl4_dst &&",
          "2643:       rth->rt_key_src == flp->fl4_src &&",
          "2645:       rth->rt_oif == flp->flowi_oif &&",
          "2646:       rth->rt_mark == flp->flowi_mark &&",
          "2647:       !((rth->rt_tos ^ flp->fl4_tos) &",
          "",
          "[Added Lines]",
          "2637:  hash = rt_hash(flp4->daddr, flp4->saddr, flp4->flowi4_oif, rt_genid(net));",
          "2642:   if (rth->rt_key_dst == flp4->daddr &&",
          "2643:       rth->rt_key_src == flp4->saddr &&",
          "2645:       rth->rt_oif == flp4->flowi4_oif &&",
          "2646:       rth->rt_mark == flp4->flowi4_mark &&",
          "2647:       !((rth->rt_tos ^ flp4->flowi4_tos) &",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2658:  rcu_read_unlock_bh();",
          "2660: slow_output:",
          "2662: }",
          "2663: EXPORT_SYMBOL_GPL(__ip_route_output_key);",
          "",
          "[Removed Lines]",
          "2661:  return ip_route_output_slow(net, &flp->u.ip4);",
          "",
          "[Added Lines]",
          "2661:  return ip_route_output_slow(net, flp4);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2733:  return rt ? &rt->dst : ERR_PTR(-ENOMEM);",
          "2734: }",
          "2737:         struct sock *sk)",
          "2738: {",
          "2741:  if (IS_ERR(rt))",
          "2742:   return rt;",
          "2750:  }",
          "2752:  return rt;",
          "",
          "[Removed Lines]",
          "2736: struct rtable *ip_route_output_flow(struct net *net, struct flowi *flp,",
          "2739:  struct rtable *rt = __ip_route_output_key(net, flp);",
          "2744:  if (flp->flowi_proto) {",
          "2745:   if (!flp->fl4_src)",
          "2746:    flp->fl4_src = rt->rt_src;",
          "2747:   if (!flp->fl4_dst)",
          "2748:    flp->fl4_dst = rt->rt_dst;",
          "2749:   rt = (struct rtable *) xfrm_lookup(net, &rt->dst, flp, sk, 0);",
          "",
          "[Added Lines]",
          "2736: struct rtable *ip_route_output_flow(struct net *net, struct flowi4 *flp4,",
          "2739:  struct rtable *rt = __ip_route_output_key(net, flp4);",
          "2744:  if (flp4->flowi4_proto) {",
          "2745:   if (!flp4->saddr)",
          "2746:    flp4->saddr = rt->rt_src;",
          "2747:   if (!flp4->daddr)",
          "2748:    flp4->daddr = rt->rt_dst;",
          "2749:   rt = (struct rtable *) xfrm_lookup(net, &rt->dst,",
          "2750:          flowi4_to_flowi(flp4),",
          "2751:          sk, 0);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2920:    .flowi4_oif = tb[RTA_OIF] ? nla_get_u32(tb[RTA_OIF]) : 0,",
          "2921:    .flowi4_mark = mark,",
          "2922:   };",
          "2925:   err = 0;",
          "2926:   if (IS_ERR(rt))",
          "",
          "[Removed Lines]",
          "2923:   rt = ip_route_output_key(net, flowi4_to_flowi(&fl4));",
          "",
          "[Added Lines]",
          "2925:   rt = ip_route_output_key(net, &fl4);",
          "",
          "---------------"
        ],
        "net/ipv4/syncookies.c||net/ipv4/syncookies.c": [
          "File: net/ipv4/syncookies.c -> net/ipv4/syncookies.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "347:  {",
          "358:   };",
          "361:   if (IS_ERR(rt)) {",
          "362:    reqsk_free(req);",
          "363:    goto out;",
          "",
          "[Removed Lines]",
          "348:   struct flowi fl = {",
          "349:    .flowi_mark = sk->sk_mark,",
          "350:    .fl4_dst = ((opt && opt->srr) ?",
          "351:         opt->faddr : ireq->rmt_addr),",
          "352:    .fl4_src = ireq->loc_addr,",
          "353:    .fl4_tos = RT_CONN_FLAGS(sk),",
          "354:    .flowi_proto = IPPROTO_TCP,",
          "355:    .flowi_flags = inet_sk_flowi_flags(sk),",
          "356:    .fl4_sport = th->dest,",
          "357:    .fl4_dport = th->source,",
          "359:   security_req_classify_flow(req, &fl);",
          "360:   rt = ip_route_output_key(sock_net(sk), &fl);",
          "",
          "[Added Lines]",
          "348:   struct flowi4 fl4 = {",
          "349:    .flowi4_mark = sk->sk_mark,",
          "350:    .daddr = ((opt && opt->srr) ?",
          "351:       opt->faddr : ireq->rmt_addr),",
          "352:    .saddr = ireq->loc_addr,",
          "353:    .flowi4_tos = RT_CONN_FLAGS(sk),",
          "354:    .flowi4_proto = IPPROTO_TCP,",
          "355:    .flowi4_flags = inet_sk_flowi_flags(sk),",
          "356:    .uli.ports.sport = th->dest,",
          "357:    .uli.ports.dport = th->source,",
          "359:   security_req_classify_flow(req, flowi4_to_flowi(&fl4));",
          "360:   rt = ip_route_output_key(sock_net(sk), &fl4);",
          "",
          "---------------"
        ],
        "net/ipv4/udp.c||net/ipv4/udp.c": [
          "File: net/ipv4/udp.c -> net/ipv4/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "908:   rt = (struct rtable *)sk_dst_check(sk, 0);",
          "910:  if (rt == NULL) {",
          "922:   };",
          "923:   struct net *net = sock_net(sk);",
          "927:   if (IS_ERR(rt)) {",
          "928:    err = PTR_ERR(rt);",
          "929:    rt = NULL;",
          "",
          "[Removed Lines]",
          "911:   struct flowi fl = {",
          "912:    .flowi_oif = ipc.oif,",
          "913:    .flowi_mark = sk->sk_mark,",
          "914:    .fl4_dst = faddr,",
          "915:    .fl4_src = saddr,",
          "916:    .fl4_tos = tos,",
          "917:    .flowi_proto = sk->sk_protocol,",
          "918:    .flowi_flags = (inet_sk_flowi_flags(sk) |",
          "919:          FLOWI_FLAG_CAN_SLEEP),",
          "920:    .fl4_sport = inet->inet_sport,",
          "921:    .fl4_dport = dport,",
          "925:   security_sk_classify_flow(sk, &fl);",
          "926:   rt = ip_route_output_flow(net, &fl, sk);",
          "",
          "[Added Lines]",
          "911:   struct flowi4 fl4 = {",
          "912:    .flowi4_oif = ipc.oif,",
          "913:    .flowi4_mark = sk->sk_mark,",
          "914:    .daddr = faddr,",
          "915:    .saddr = saddr,",
          "916:    .flowi4_tos = tos,",
          "917:    .flowi4_proto = sk->sk_protocol,",
          "918:    .flowi4_flags = (inet_sk_flowi_flags(sk) |",
          "919:       FLOWI_FLAG_CAN_SLEEP),",
          "920:    .uli.ports.sport = inet->inet_sport,",
          "921:    .uli.ports.dport = dport,",
          "925:   security_sk_classify_flow(sk, flowi4_to_flowi(&fl4));",
          "926:   rt = ip_route_output_flow(net, &fl4, sk);",
          "",
          "---------------"
        ],
        "net/ipv4/xfrm4_policy.c||net/ipv4/xfrm4_policy.c": [
          "File: net/ipv4/xfrm4_policy.c -> net/ipv4/xfrm4_policy.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "22:        const xfrm_address_t *saddr,",
          "23:        const xfrm_address_t *daddr)",
          "24: {",
          "28:  };",
          "29:  struct rtable *rt;",
          "31:  if (saddr)",
          "35:  if (!IS_ERR(rt))",
          "36:   return &rt->dst;",
          "",
          "[Removed Lines]",
          "25:  struct flowi fl = {",
          "26:   .fl4_dst = daddr->a4,",
          "27:   .fl4_tos = tos,",
          "32:   fl.fl4_src = saddr->a4;",
          "34:  rt = __ip_route_output_key(net, &fl);",
          "",
          "[Added Lines]",
          "25:  struct flowi4 fl4 = {",
          "26:   .daddr = daddr->a4,",
          "27:   .flowi4_tos = tos,",
          "32:   fl4.saddr = saddr->a4;",
          "34:  rt = __ip_route_output_key(net, &fl4);",
          "",
          "---------------"
        ],
        "net/netfilter/ipvs/ip_vs_xmit.c||net/netfilter/ipvs/ip_vs_xmit.c": [
          "File: net/netfilter/ipvs/ip_vs_xmit.c -> net/netfilter/ipvs/ip_vs_xmit.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "165:    return 0;",
          "166:   refdst_drop(orefdst);",
          "167:  } else {",
          "173:   };",
          "176:   if (IS_ERR(rt))",
          "177:    return 0;",
          "178:   if (!(rt->rt_flags & RTCF_LOCAL)) {",
          "",
          "[Removed Lines]",
          "168:   struct flowi fl = {",
          "169:    .fl4_dst = iph->daddr,",
          "170:    .fl4_src = iph->saddr,",
          "171:    .fl4_tos = RT_TOS(iph->tos),",
          "172:    .flowi_mark = skb->mark,",
          "175:   rt = ip_route_output_key(net, &fl);",
          "",
          "[Added Lines]",
          "168:   struct flowi4 fl4 = {",
          "169:    .daddr = iph->daddr,",
          "170:    .saddr = iph->saddr,",
          "171:    .flowi4_tos = RT_TOS(iph->tos),",
          "172:    .flowi4_mark = skb->mark,",
          "175:   rt = ip_route_output_key(net, &fl4);",
          "",
          "---------------"
        ],
        "net/netfilter/xt_TEE.c||net/netfilter/xt_TEE.c": [
          "File: net/netfilter/xt_TEE.c -> net/netfilter/xt_TEE.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "62:  const struct iphdr *iph = ip_hdr(skb);",
          "63:  struct net *net = pick_net(skb);",
          "64:  struct rtable *rt;",
          "68:  if (info->priv) {",
          "69:   if (info->priv->oif == -1)",
          "70:    return false;",
          "72:  }",
          "77:  if (IS_ERR(rt))",
          "78:   return false;",
          "",
          "[Removed Lines]",
          "65:  struct flowi fl;",
          "67:  memset(&fl, 0, sizeof(fl));",
          "71:   fl.flowi_oif = info->priv->oif;",
          "73:  fl.fl4_dst = info->gw.ip;",
          "74:  fl.fl4_tos = RT_TOS(iph->tos);",
          "75:  fl.fl4_scope = RT_SCOPE_UNIVERSE;",
          "76:  rt = ip_route_output_key(net, &fl);",
          "",
          "[Added Lines]",
          "65:  struct flowi4 fl4;",
          "67:  memset(&fl4, 0, sizeof(fl4));",
          "71:   fl4.flowi4_oif = info->priv->oif;",
          "73:  fl4.daddr = info->gw.ip;",
          "74:  fl4.flowi4_tos = RT_TOS(iph->tos);",
          "75:  fl4.flowi4_scope = RT_SCOPE_UNIVERSE;",
          "76:  rt = ip_route_output_key(net, &fl4);",
          "",
          "---------------"
        ],
        "net/sctp/protocol.c||net/sctp/protocol.c": [
          "File: net/sctp/protocol.c -> net/sctp/protocol.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "468:       union sctp_addr *saddr)",
          "469: {",
          "470:  struct rtable *rt;",
          "472:  struct sctp_bind_addr *bp;",
          "473:  struct sctp_sockaddr_entry *laddr;",
          "474:  struct dst_entry *dst = NULL;",
          "475:  union sctp_addr dst_saddr;",
          "481:  if (asoc) {",
          "485:  }",
          "486:  if (saddr) {",
          "489:  }",
          "491:  SCTP_DEBUG_PRINTK(\"%s: DST:%pI4, SRC:%pI4 - \",",
          "495:  if (!IS_ERR(rt))",
          "496:   dst = &rt->dst;",
          "",
          "[Removed Lines]",
          "471:  struct flowi fl;",
          "477:  memset(&fl, 0x0, sizeof(struct flowi));",
          "478:  fl.fl4_dst  = daddr->v4.sin_addr.s_addr;",
          "479:  fl.fl4_dport = daddr->v4.sin_port;",
          "480:  fl.flowi_proto = IPPROTO_SCTP;",
          "482:   fl.fl4_tos = RT_CONN_FLAGS(asoc->base.sk);",
          "483:   fl.flowi_oif = asoc->base.sk->sk_bound_dev_if;",
          "484:   fl.fl4_sport = htons(asoc->base.bind_addr.port);",
          "487:   fl.fl4_src = saddr->v4.sin_addr.s_addr;",
          "488:   fl.fl4_sport = saddr->v4.sin_port;",
          "492:      __func__, &fl.fl4_dst, &fl.fl4_src);",
          "494:  rt = ip_route_output_key(&init_net, &fl);",
          "",
          "[Added Lines]",
          "471:  struct flowi4 fl4;",
          "477:  memset(&fl4, 0x0, sizeof(struct flowi4));",
          "478:  fl4.daddr  = daddr->v4.sin_addr.s_addr;",
          "479:  fl4.uli.ports.dport = daddr->v4.sin_port;",
          "480:  fl4.flowi4_proto = IPPROTO_SCTP;",
          "482:   fl4.flowi4_tos = RT_CONN_FLAGS(asoc->base.sk);",
          "483:   fl4.flowi4_oif = asoc->base.sk->sk_bound_dev_if;",
          "484:   fl4.uli.ports.sport = htons(asoc->base.bind_addr.port);",
          "487:   fl4.saddr = saddr->v4.sin_addr.s_addr;",
          "488:   fl4.uli.ports.sport = saddr->v4.sin_port;",
          "492:      __func__, &fl4.daddr, &fl4.saddr);",
          "494:  rt = ip_route_output_key(&init_net, &fl4);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "533:    continue;",
          "534:   if ((laddr->state == SCTP_ADDR_SRC) &&",
          "535:       (AF_INET == laddr->a.sa.sa_family)) {",
          "539:    if (!IS_ERR(rt)) {",
          "540:     dst = &rt->dst;",
          "541:     goto out_unlock;",
          "",
          "[Removed Lines]",
          "536:    fl.fl4_src = laddr->a.v4.sin_addr.s_addr;",
          "537:    fl.fl4_sport = laddr->a.v4.sin_port;",
          "538:    rt = ip_route_output_key(&init_net, &fl);",
          "",
          "[Added Lines]",
          "536:    fl4.saddr = laddr->a.v4.sin_addr.s_addr;",
          "537:    fl4.uli.ports.sport = laddr->a.v4.sin_port;",
          "538:    rt = ip_route_output_key(&init_net, &fl4);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-37647",
  "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. When a user does not supply arguments that determine a valid sparse tensor, `tf.raw_ops.SparseTensorSliceDataset` implementation can be made to dereference a null pointer. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc#L240-L251) has some argument validation but fails to consider the case when either `indices` or `values` are provided for an empty sparse tensor when the other is not. If `indices` is empty, then [code that performs validation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc#L260-L261) (i.e., checking that the indices are monotonically increasing) results in a null pointer dereference. If `indices` as provided by the user is empty, then `indices` in the C++ code above is backed by an empty `std::vector`, hence calling `indices->dim_size(0)` results in null pointer dereferencing (same as calling `std::vector::at()` on an empty vector). We have patched the issue in GitHub commit 02cc160e29d20631de3859c6653184e3f876b9d7. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
  "repo": "tensorflow/tensorflow",
  "patch_hash": "02cc160e29d20631de3859c6653184e3f876b9d7",
  "patch_info": {
    "commit_hash": "02cc160e29d20631de3859c6653184e3f876b9d7",
    "repo": "tensorflow/tensorflow",
    "commit_url": "https://github.com/tensorflow/tensorflow/commit/02cc160e29d20631de3859c6653184e3f876b9d7",
    "files": [
      "tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc",
      "tensorflow/python/data/kernel_tests/from_sparse_tensor_slices_test.py"
    ],
    "message": "Prevent nullptr deref in SparseTensorSliceDataset\n\nThe arguments must determine a valid sparse tensor. This means that when indices are empty then the values must be empty too (and the reverse).\n\nAlso added test, by modifying existing test with empty sparse tensor to now run with an invalid sparse tensor input.\n\nPiperOrigin-RevId: 388562757\nChange-Id: Id8b54cd7c2316025b4f9a77292c8fb5344d17609",
    "before_after_code_files": [
      "tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc||tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc",
      "tensorflow/python/data/kernel_tests/from_sparse_tensor_slices_test.py||tensorflow/python/data/kernel_tests/from_sparse_tensor_slices_test.py"
    ]
  },
  "patch_diff": {
    "tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc||tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc": [
      "File: tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc -> tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "241:                 errors::InvalidArgument(",
      "242:                     \"Input indices should be a matrix but received shape \",",
      "243:                     indices->shape().DebugString()));",
      "244:     OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()),",
      "245:                 errors::InvalidArgument(",
      "246:                     \"Input values should be a vector but received shape \",",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "245:     const auto num_indices = indices->NumElements();",
      "246:     const auto num_values = values->NumElements();",
      "247:     if (num_indices == 0 || num_values == 0) {",
      "248:       OP_REQUIRES(ctx, num_indices == num_values,",
      "249:                   errors::InvalidArgument(",
      "250:                       \"If indices or values are empty, the other one must also \"",
      "251:                       \"be. Got indices of shape \",",
      "252:                       indices->shape().DebugString(), \" and values of shape \",",
      "253:                       values->shape().DebugString()));",
      "254:     }",
      "",
      "---------------"
    ],
    "tensorflow/python/data/kernel_tests/from_sparse_tensor_slices_test.py||tensorflow/python/data/kernel_tests/from_sparse_tensor_slices_test.py": [
      "File: tensorflow/python/data/kernel_tests/from_sparse_tensor_slices_test.py -> tensorflow/python/data/kernel_tests/from_sparse_tensor_slices_test.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "118:       with self.assertRaises(errors.OutOfRangeError):",
      "119:         sess.run(get_next)",
      "121:   @combinations.generate(combinations.combine(tf_api_version=2, mode=[\"eager\"]))",
      "122:   def testFromSparseTensorSlicesError(self):",
      "123:     with self.assertRaises(AttributeError):",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "121:   @combinations.generate(combinations.combine(tf_api_version=1, mode=[\"graph\"]))",
      "122:   def testEmptySparseTensorSlicesInvalid(self):",
      "123:     \"\"\"Test a dataset based on invalid `tf.sparse.SparseTensor`.\"\"\"",
      "124:     st = array_ops.sparse_placeholder(dtypes.float64)",
      "125:     iterator = dataset_ops.make_initializable_iterator(",
      "126:         dataset_ops.Dataset.from_sparse_tensor_slices(st))",
      "127:     init_op = iterator.initializer",
      "129:     with self.cached_session() as sess:",
      "130:       # Test with an empty sparse tensor but with non empty values.",
      "131:       empty_indices = np.empty((0, 4), dtype=np.int64)",
      "132:       non_empty_values = [1, 2, 3, 4]",
      "133:       empty_dense_shape = [0, 4, 37, 9]",
      "134:       sparse_feed = sparse_tensor.SparseTensorValue(empty_indices,",
      "135:                                                     non_empty_values,",
      "136:                                                     empty_dense_shape)",
      "137:       # Here, we expect the test to fail when running the feed.",
      "138:       with self.assertRaises(errors.InvalidArgumentError):",
      "139:         sess.run(init_op, feed_dict={st: sparse_feed})",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5feb7462a959dad8e5b1b3209344f3f6b4d05323",
      "candidate_info": {
        "commit_hash": "5feb7462a959dad8e5b1b3209344f3f6b4d05323",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/5feb7462a959dad8e5b1b3209344f3f6b4d05323",
        "files": [
          "tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc",
          "tensorflow/python/data/kernel_tests/from_sparse_tensor_slices_test.py"
        ],
        "message": "Prevent nullptr deref in SparseTensorSliceDataset\n\nThe arguments must determine a valid sparse tensor. This means that when indices are empty then the values must be empty too (and the reverse).\n\nAlso added test, by modifying existing test with empty sparse tensor to now run with an invalid sparse tensor input.\n\nPiperOrigin-RevId: 388562757\nChange-Id: Id8b54cd7c2316025b4f9a77292c8fb5344d17609",
        "before_after_code_files": [
          "tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc||tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc",
          "tensorflow/python/data/kernel_tests/from_sparse_tensor_slices_test.py||tensorflow/python/data/kernel_tests/from_sparse_tensor_slices_test.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc||tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc",
            "tensorflow/python/data/kernel_tests/from_sparse_tensor_slices_test.py||tensorflow/python/data/kernel_tests/from_sparse_tensor_slices_test.py"
          ],
          "candidate": [
            "tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc||tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc",
            "tensorflow/python/data/kernel_tests/from_sparse_tensor_slices_test.py||tensorflow/python/data/kernel_tests/from_sparse_tensor_slices_test.py"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc||tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc": [
          "File: tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc -> tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "241:                 errors::InvalidArgument(",
          "242:                     \"Input indices should be a matrix but received shape \",",
          "243:                     indices->shape().DebugString()));",
          "244:     OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()),",
          "245:                 errors::InvalidArgument(",
          "246:                     \"Input values should be a vector but received shape \",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "245:     const auto num_indices = indices->NumElements();",
          "246:     const auto num_values = values->NumElements();",
          "247:     if (num_indices == 0 || num_values == 0) {",
          "248:       OP_REQUIRES(ctx, num_indices == num_values,",
          "249:                   errors::InvalidArgument(",
          "250:                       \"If indices or values are empty, the other one must also \"",
          "251:                       \"be. Got indices of shape \",",
          "252:                       indices->shape().DebugString(), \" and values of shape \",",
          "253:                       values->shape().DebugString()));",
          "254:     }",
          "",
          "---------------"
        ],
        "tensorflow/python/data/kernel_tests/from_sparse_tensor_slices_test.py||tensorflow/python/data/kernel_tests/from_sparse_tensor_slices_test.py": [
          "File: tensorflow/python/data/kernel_tests/from_sparse_tensor_slices_test.py -> tensorflow/python/data/kernel_tests/from_sparse_tensor_slices_test.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "84:       with self.assertRaises(errors.OutOfRangeError):",
          "85:         sess.run(get_next)",
          "87:   @combinations.generate(combinations.combine(tf_api_version=2, mode=[\"eager\"]))",
          "88:   def testFromSparseTensorSlicesError(self):",
          "89:     with self.assertRaises(AttributeError):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "87:   @combinations.generate(combinations.combine(tf_api_version=1, mode=[\"graph\"]))",
          "88:   def testEmptySparseTensorSlicesInvalid(self):",
          "89:     \"\"\"Test a dataset based on invalid `tf.sparse.SparseTensor`.\"\"\"",
          "90:     st = array_ops.sparse_placeholder(dtypes.float64)",
          "91:     iterator = dataset_ops.make_initializable_iterator(",
          "92:         dataset_ops.Dataset.from_sparse_tensor_slices(st))",
          "93:     init_op = iterator.initializer",
          "95:     with self.cached_session() as sess:",
          "96:       # Test with an empty sparse tensor but with non empty values.",
          "97:       empty_indices = np.empty((0, 4), dtype=np.int64)",
          "98:       non_empty_values = [1, 2, 3, 4]",
          "99:       empty_dense_shape = [0, 4, 37, 9]",
          "100:       sparse_feed = sparse_tensor.SparseTensorValue(empty_indices,",
          "101:                                                     non_empty_values,",
          "102:                                                     empty_dense_shape)",
          "103:       # Here, we expect the test to fail when running the feed.",
          "104:       with self.assertRaises(errors.InvalidArgumentError):",
          "105:         sess.run(init_op, feed_dict={st: sparse_feed})",
          "",
          "---------------"
        ]
      }
    }
  ]
}
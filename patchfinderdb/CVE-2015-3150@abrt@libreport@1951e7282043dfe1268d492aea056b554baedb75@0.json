{
  "cve_id": "CVE-2015-3150",
  "cve_desc": "abrt-dbus in Automatic Bug Reporting Tool (ABRT) allows local users to delete or change the ownership of arbitrary files via the problem directory argument to the (1) ChownProblemDir, (2) DeleteElement, or (3) DeleteProblem method.",
  "repo": "abrt/libreport",
  "patch_hash": "1951e7282043dfe1268d492aea056b554baedb75",
  "patch_info": {
    "commit_hash": "1951e7282043dfe1268d492aea056b554baedb75",
    "repo": "abrt/libreport",
    "commit_url": "https://github.com/abrt/libreport/commit/1951e7282043dfe1268d492aea056b554baedb75",
    "files": [
      "src/include/dump_dir.h",
      "src/include/internal_libreport.h",
      "src/lib/dump_dir.c",
      "src/lib/problem_data.c",
      "src/lib/xfuncs.c"
    ],
    "message": "lib: fix races in dump directory handling code\n\nFlorian Weimer <fweimer@redhat.com>:\n\n    dd_opendir() should keep a file handle (opened with O_DIRECTORY) and\n    use openat() and similar functions to access files in it.\n\n    ...\n\n    The file system manipulation functions should guard against hard\n    links (check that link count is <= 1, just as in the user coredump\n    code in abrt-hook-ccpp), possibly after opening the file\n    with O_PATH first to avoid side effects on open/close.\n\nRelated: #1214745\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
    "before_after_code_files": [
      "src/include/dump_dir.h||src/include/dump_dir.h",
      "src/include/internal_libreport.h||src/include/internal_libreport.h",
      "src/lib/dump_dir.c||src/lib/dump_dir.c",
      "src/lib/problem_data.c||src/lib/problem_data.c",
      "src/lib/xfuncs.c||src/lib/xfuncs.c"
    ]
  },
  "patch_diff": {
    "src/include/dump_dir.h||src/include/dump_dir.h": [
      "File: src/include/dump_dir.h -> src/include/dump_dir.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "36: int create_symlink_lockfile(const char *filename, const char *pid_str);",
      "38: enum {",
      "39:     DD_FAIL_QUIETLY_ENOENT = (1 << 0),",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "37: int create_symlink_lockfile_at(int dir_fd, const char *filename, const char *pid_str);",
      "42: int secure_openat_read(int dir_fd, const char *filename);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "57:     mode_t mode;",
      "58:     time_t dd_time;",
      "59:     char *dd_type;",
      "60: };",
      "62: void dd_close(struct dump_dir *dd);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "66:     int dd_fd;",
      "",
      "---------------"
    ],
    "src/include/internal_libreport.h||src/include/internal_libreport.h": [
      "File: src/include/internal_libreport.h -> src/include/internal_libreport.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "406: int xopen(const char *pathname, int flags);",
      "407: #define xunlink libreport_xunlink",
      "408: void xunlink(const char *pathname);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "409: #define xunlinkat libreport_xunlinkat",
      "410: void xunlinkat(int dir_fd, const char *pathname, int flags);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "416: #define is_regular_file libreport_is_regular_file",
      "417: int is_regular_file(struct dirent *dent, const char *dirname);",
      "419: #define dot_or_dotdot libreport_dot_or_dotdot",
      "420: bool dot_or_dotdot(const char *filename);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "420: #define is_regular_file_at libreport_is_regular_file_at",
      "421: int is_regular_file_at(struct dirent *dent, int dir_fd);",
      "",
      "---------------"
    ],
    "src/lib/dump_dir.c||src/lib/dump_dir.c": [
      "File: src/lib/dump_dir.c -> src/lib/dump_dir.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "87: static char *load_text_file(const char *path, unsigned flags);",
      "88: static void copy_file_from_chroot(struct dump_dir* dd, const char *name,",
      "89:         const char *chroot_dir, const char *file_path);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "88: static char *load_text_file_at(int dir_fd, const char *name, unsigned flags);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "98:     return true;",
      "99: }",
      "102: {",
      "103:     struct stat buf;",
      "105:     {",
      "106:         if (S_ISDIR(buf.st_mode) || S_ISREG(buf.st_mode))",
      "107:         {",
      "",
      "[Removed Lines]",
      "101: static bool exist_file_dir(const char *path)",
      "104:     if (stat(path, &buf) == 0)",
      "",
      "[Added Lines]",
      "102: static bool exist_file_dir_at(int dir_fd, const char *name)",
      "105:     if (fstatat(dir_fd, name, &buf, AT_SYMLINK_NOFOLLOW) == 0)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "111:     return false;",
      "112: }",
      "120: {",
      "123:     if (fd < 0)",
      "124:     {",
      "125:         VERB2 pwarn_msg(\"Can't open '%s'\", filename);",
      "",
      "[Removed Lines]",
      "119: static time_t parse_time_file(const char *filename)",
      "122:     int fd = open(filename, O_RDONLY | O_NOFOLLOW);",
      "",
      "[Added Lines]",
      "125: int secure_openat_read(int dir_fd, const char *pathname)",
      "126: {",
      "127:     static char reopen_buf[sizeof(\"/proc/self/fd/\") + 3*sizeof(int) + 1];",
      "129:     int path_fd = openat(dir_fd, pathname, O_PATH | O_NOFOLLOW);",
      "130:     if (path_fd < 0)",
      "131:         return -1;",
      "133:     struct stat path_sb;",
      "134:     int r = fstat(path_fd, &path_sb);",
      "135:     if (r < 0)",
      "136:     {",
      "137:         perror_msg(\"stat\");",
      "138:         close(path_fd);",
      "139:         return -1;",
      "140:     }",
      "142:     if (!S_ISREG(path_sb.st_mode) || path_sb.st_nlink > 1)",
      "143:     {",
      "144:         log_notice(\"Path isn't a regular file or has more links (%lu)\", path_sb.st_nlink);",
      "145:         errno = EINVAL;",
      "146:         close(path_fd);",
      "147:         return -1;",
      "148:     }",
      "150:     if (snprintf(reopen_buf, sizeof(reopen_buf), \"/proc/self/fd/%d\", path_fd) >= sizeof(reopen_buf)) {",
      "151:         error_msg(\"BUG: too long path to a file descriptor\");",
      "152:         abort();",
      "153:     }",
      "155:     const int fd = open(reopen_buf, O_RDONLY);",
      "156:     close(path_fd);",
      "158:     return fd;",
      "159: }",
      "166: static time_t parse_time_file_at(int dir_fd, const char *filename)",
      "169:     int fd = secure_openat_read(dir_fd, filename);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "187: {",
      "189:     {",
      "190:         if (errno != EEXIST)",
      "191:         {",
      "",
      "[Removed Lines]",
      "186: int create_symlink_lockfile(const char* lock_file, const char* pid)",
      "188:     while (symlink(pid, lock_file) != 0)",
      "",
      "[Added Lines]",
      "233: int create_symlink_lockfile_at(int dir_fd, const char* lock_file, const char* pid)",
      "235:     while (symlinkat(pid, dir_fd, lock_file) != 0)",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "198:         }",
      "200:         char pid_buf[sizeof(pid_t)*3 + 4];",
      "202:         if (r < 0)",
      "203:         {",
      "204:             if (errno == ENOENT)",
      "",
      "[Removed Lines]",
      "201:         ssize_t r = readlink(lock_file, pid_buf, sizeof(pid_buf) - 1);",
      "",
      "[Added Lines]",
      "248:         ssize_t r = readlinkat(dir_fd, lock_file, pid_buf, sizeof(pid_buf) - 1);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "230:             log(\"Lock file '%s' was locked by process %s, but it crashed?\", lock_file, pid_buf);",
      "231:         }",
      "234:         {",
      "235:             perror_msg(\"Can't remove stale lock file '%s'\", lock_file);",
      "236:             errno = 0;",
      "",
      "[Removed Lines]",
      "233:         if (unlink(lock_file) != 0 && errno != ENOENT)",
      "",
      "[Added Lines]",
      "280:         if (unlinkat(dir_fd, lock_file, /*only files*/0) != 0 && errno != ENOENT)",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "242:     return 1;",
      "243: }",
      "245: static const char *dd_check(struct dump_dir *dd)",
      "246: {",
      "252:     if (dd->dd_time < 0)",
      "253:     {",
      "254:         log_warning(\"Missing file: \"FILENAME_TIME);",
      "255:         return FILENAME_TIME;",
      "256:     }",
      "260:     if (!dd->dd_type || (strlen(dd->dd_type) == 0))",
      "261:     {",
      "262:         log_warning(\"Missing or empty file: \"FILENAME_TYPE);",
      "",
      "[Removed Lines]",
      "247:     unsigned dirname_len = strlen(dd->dd_dirname);",
      "248:     char filename_buf[FILENAME_MAX+1];",
      "249:     strcpy(filename_buf, dd->dd_dirname);",
      "250:     strcpy(filename_buf + dirname_len, \"/\"FILENAME_TIME);",
      "251:     dd->dd_time = parse_time_file(filename_buf);",
      "258:     strcpy(filename_buf + dirname_len, \"/\"FILENAME_TYPE);",
      "259:     dd->dd_type = load_text_file(filename_buf, DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE);",
      "",
      "[Added Lines]",
      "292: int create_symlink_lockfile(const char *filename, const char *pid_str)",
      "293: {",
      "294:     return create_symlink_lockfile_at(AT_FDCWD, filename, pid_str);",
      "295: }",
      "299:     dd->dd_time = parse_time_file_at(dd->dd_fd, FILENAME_TIME);",
      "306:     dd->dd_type = load_text_file_at(dd->dd_fd, FILENAME_TYPE, DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "274:     char pid_buf[sizeof(long)*3 + 2];",
      "275:     snprintf(pid_buf, sizeof(pid_buf), \"%lu\", (long)getpid());",
      "282:     unsigned count = NO_TIME_FILE_COUNT;",
      "284:  retry:",
      "285:     while (1)",
      "286:     {",
      "288:         if (r < 0)",
      "290:         if (r > 0)",
      "",
      "[Removed Lines]",
      "277:     unsigned dirname_len = strlen(dd->dd_dirname);",
      "278:     char lock_buf[dirname_len + sizeof(\"/.lock\")];",
      "279:     strcpy(lock_buf, dd->dd_dirname);",
      "280:     strcpy(lock_buf + dirname_len, \"/.lock\");",
      "287:         int r = create_symlink_lockfile(lock_buf, pid_buf);",
      "",
      "[Added Lines]",
      "329:         int r = create_symlink_lockfile_at(dd->dd_fd, \".lock\", pid_buf);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "305:         if (missing_file)",
      "306:         {",
      "309:             if (--count == 0 || flags & DD_DONT_WAIT_FOR_LOCK)",
      "310:             {",
      "",
      "[Removed Lines]",
      "307:             xunlink(lock_buf);",
      "308:             log_warning(\"Unlocked '%s' (no or corrupted '%s' file)\", lock_buf, missing_file);",
      "",
      "[Added Lines]",
      "349:             xunlinkat(dd->dd_fd, \".lock\", /*only files*/0);",
      "350:             log_warning(\"Unlocked '%s' (no or corrupted '%s' file)\", dd->dd_dirname, missing_file);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "326:     {",
      "327:         dd->locked = 0;",
      "336:     }",
      "337: }",
      "",
      "[Removed Lines]",
      "329:         unsigned dirname_len = strlen(dd->dd_dirname);",
      "330:         char lock_buf[dirname_len + sizeof(\"/.lock\")];",
      "331:         strcpy(lock_buf, dd->dd_dirname);",
      "332:         strcpy(lock_buf + dirname_len, \"/.lock\");",
      "333:         xunlink(lock_buf);",
      "335:         log_info(\"Unlocked '%s'\", lock_buf);",
      "",
      "[Added Lines]",
      "371:         xunlinkat(dd->dd_fd, \".lock\", /*only files*/0);",
      "373:         log_info(\"Unlocked '%s/.lock'\", dd->dd_dirname);",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "340: {",
      "341:     struct dump_dir* dd = (struct dump_dir*)xzalloc(sizeof(struct dump_dir));",
      "342:     dd->dd_time = -1;",
      "343:     return dd;",
      "344: }",
      "347: {",
      "354:     return ret;",
      "355: }",
      "",
      "[Removed Lines]",
      "346: int dd_exist(const struct dump_dir *dd, const char *path)",
      "348:     if (!str_is_correct_filename(path))",
      "349:         error_msg_and_die(\"Cannot test existence. '%s' is not a valid file name\", path);",
      "351:     char *full_path = concat_path_file(dd->dd_dirname, path);",
      "352:     int ret = exist_file_dir(full_path);",
      "353:     free(full_path);",
      "",
      "[Added Lines]",
      "381:     dd->dd_fd = -1;",
      "385: int dd_exist(const struct dump_dir *dd, const char *name)",
      "387:     if (!str_is_correct_filename(name))",
      "388:         error_msg_and_die(\"Cannot test existence. '%s' is not a valid file name\", name);",
      "390:     const int ret = exist_file_dir_at(dd->dd_fd, name);",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "360:         return;",
      "362:     dd_unlock(dd);",
      "363:     if (dd->next_dir)",
      "364:     {",
      "365:         closedir(dd->next_dir);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "400:     close(dd->dd_fd);",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "384:     struct dump_dir *dd = dd_init();",
      "386:     dir = dd->dd_dirname = rm_trailing_slashes(dir);",
      "388:     struct stat stat_buf;",
      "390:         goto cant_access;",
      "392:     dd->mode = (stat_buf.st_mode & 0666);",
      "",
      "[Removed Lines]",
      "389:     if (stat(dir, &stat_buf) != 0)",
      "",
      "[Added Lines]",
      "425:     dd->dd_fd = open(dir, O_DIRECTORY | O_NOFOLLOW);",
      "427:     if (dd->dd_fd < 0)",
      "429:     if (fstat(dd->dd_fd, &stat_buf) != 0)",
      "430:         goto cant_access;",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "397:         if ((flags & DD_OPEN_READONLY) && errno == EACCES)",
      "398:         {",
      "405:                 if(dd_check(dd) != NULL)",
      "406:                 {",
      "407:                     dd_close(dd);",
      "",
      "[Removed Lines]",
      "401:             if (stat(dir, &stat_buf) == 0",
      "402:              && S_ISDIR(stat_buf.st_mode)",
      "403:              && access(dir, R_OK) == 0",
      "404:             ) {",
      "",
      "[Added Lines]",
      "445:             if (faccessat(dd->dd_fd, \".\", R_OK, AT_SYMLINK_NOFOLLOW) == 0)",
      "446:             {",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "444:     if (geteuid() == 0)",
      "445:     {",
      "449:         {",
      "451:             dd_close(dd);",
      "452:             return NULL;",
      "453:         }",
      "",
      "[Removed Lines]",
      "447:         struct stat stat_buf;",
      "448:         if (stat(dir, &stat_buf) != 0 || !S_ISDIR(stat_buf.st_mode))",
      "450:             error_msg(\"Can't stat '%s', or it is not a directory\", dir);",
      "",
      "[Added Lines]",
      "489:         if (fstat(dd->dd_fd, &stat_buf) != 0)",
      "491:             error_msg(\"Can't stat '%s'\", dir);",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "544:         error_msg(\"Bad dir name '%s'\", dir);",
      "547:     }",
      "",
      "[Removed Lines]",
      "545:         dd_close(dd);",
      "546:         return NULL;",
      "",
      "[Added Lines]",
      "586:         goto fail;",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "559:     if (r != 0)",
      "560:     {",
      "561:         perror_msg(\"Can't create directory '%s'\", dir);",
      "564:     }",
      "567:     {",
      "570:     }",
      "574:     {",
      "575:         perror_msg(\"Can't change mode of '%s'\", dir);",
      "578:     }",
      "580:     dd->dd_uid = (uid_t)-1L;",
      "",
      "[Removed Lines]",
      "562:         dd_close(dd);",
      "563:         return NULL;",
      "566:     if (dd_lock(dd, CREATE_LOCK_USLEEP, /*flags:*/ 0) < 0)",
      "568:         dd_close(dd);",
      "569:         return NULL;",
      "573:     if (chmod(dir, dir_mode) == -1)",
      "576:         dd_close(dd);",
      "577:         return NULL;",
      "",
      "[Added Lines]",
      "602:         goto fail;",
      "605:     dd->dd_fd = open(dd->dd_dirname, O_DIRECTORY | O_NOFOLLOW);",
      "606:     if (dd->dd_fd < 0)",
      "608:         perror_msg(\"Can't open newly created directory '%s'\", dir);",
      "609:         goto fail;",
      "612:     struct stat stat_sb;",
      "613:     if (fstat(dd->dd_fd, &stat_sb) < 0)",
      "614:     {",
      "615:         perror_msg(\"stat(%s)\", dd->dd_dirname);",
      "616:         goto fail;",
      "617:     }",
      "619:     if (dd_lock(dd, CREATE_LOCK_USLEEP, /*flags:*/ 0) < 0)",
      "620:         goto fail;",
      "623:     if (fchmod(dd->dd_fd, dir_mode) == -1)",
      "626:         goto fail;",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "616:     }",
      "618:     return dd;",
      "619: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "669: fail:",
      "670:     dd_close(dd);",
      "671:     return NULL;",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "624: int dd_reset_ownership(struct dump_dir *dd)",
      "625: {",
      "627:     if (r < 0)",
      "628:     {",
      "629:         perror_msg(\"Can't change '%s' ownership to %lu:%lu\", dd->dd_dirname,",
      "",
      "[Removed Lines]",
      "626:     const int r =lchown(dd->dd_dirname, dd->dd_uid, dd->dd_gid);",
      "",
      "[Added Lines]",
      "679:     const int r = fchown(dd->dd_fd, dd->dd_uid, dd->dd_gid);",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "740:     if (!dd->locked)",
      "749:     {",
      "789:     }",
      "791: }",
      "794: {",
      "796:     if (!d)",
      "797:     {",
      "",
      "[Removed Lines]",
      "743:     DIR *d = opendir(dd->dd_dirname);",
      "744:     if (!d)",
      "745:         return;",
      "747:     struct dirent *dent;",
      "748:     while ((dent = readdir(d)) != NULL)",
      "751:             continue;",
      "752:         char *full_path = concat_path_file(dd->dd_dirname, dent->d_name);",
      "753:         struct stat statbuf;",
      "754:         if (lstat(full_path, &statbuf) == 0 && S_ISREG(statbuf.st_mode))",
      "755:         {",
      "756:             if ((statbuf.st_mode & 0777) != dd->mode)",
      "757:             {",
      "764:                 int fd = open(full_path, O_RDONLY | O_NOFOLLOW, dd->mode);",
      "765:                 if (fd >= 0)",
      "766:                 {",
      "767:                     if (fchmod(fd, dd->mode) != 0)",
      "768:                     {",
      "769:                         perror_msg(\"Can't change '%s' mode to 0%o\", full_path,",
      "770:                                    (unsigned)dd->mode);",
      "771:                     }",
      "772:                     close(fd);",
      "773:                 }",
      "774:                 else",
      "775:                 {",
      "776:                     perror_msg(\"Can't open regular file '%s'\", full_path);",
      "777:                 }",
      "778:             }",
      "779:             if (statbuf.st_uid != dd->dd_uid || statbuf.st_gid != dd->dd_gid)",
      "780:             {",
      "781:                 if (lchown(full_path, dd->dd_uid, dd->dd_gid) != 0)",
      "782:                 {",
      "783:                     perror_msg(\"Can't change '%s' ownership to %lu:%lu\", full_path,",
      "784:                                (long)dd->dd_uid, (long)dd->dd_gid);",
      "785:                 }",
      "786:             }",
      "787:         }",
      "788:         free(full_path);",
      "790:     closedir(d);",
      "793: static int delete_file_dir(const char *dir, bool skip_lock_file)",
      "795:     DIR *d = opendir(dir);",
      "",
      "[Added Lines]",
      "796:     dd_init_next_file(dd);",
      "797:     char *short_name;",
      "798:     while (dd_get_next_file(dd, &short_name, /*full_name*/ NULL))",
      "801:         int fd = secure_openat_read(dd->dd_fd, short_name);",
      "802:         if (fd < 0)",
      "803:             goto next;",
      "805:         if (fchmod(fd, dd->mode) != 0)",
      "806:             perror_msg(\"Can't change '%s/%s' mode to 0%o\", dd->dd_dirname, short_name,",
      "807:                        (unsigned)dd->mode);",
      "809:         if (fchown(fd, dd->dd_uid, dd->dd_gid) != 0)",
      "810:             perror_msg(\"Can't change '%s/%s' ownership to %lu:%lu\", dd->dd_dirname, short_name,",
      "811:                        (long)dd->dd_uid, (long)dd->dd_gid);",
      "813:         close(fd);",
      "814: next:",
      "815:         free(short_name);",
      "819: static int delete_file_dir(int dir_fd, bool skip_lock_file)",
      "821:     int opendir_fd = dup(dir_fd);",
      "822:     if (opendir_fd < 0)",
      "823:     {",
      "824:         perror_msg(\"delete_file_dir: dup(dir_fd)\");",
      "825:         return -1;",
      "826:     }",
      "828:     DIR *d = fdopendir(opendir_fd);",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "818:             unlink_lock_file = true;",
      "819:             continue;",
      "820:         }",
      "823:         {",
      "824:             int err = 0;",
      "825:             if (errno == EISDIR)",
      "826:             {",
      "827:                 errno = 0;",
      "829:             }",
      "830:             if (errno || err)",
      "831:             {",
      "834:                 closedir(d);",
      "835:                 return -1;",
      "836:             }",
      "837:         }",
      "839:     }",
      "",
      "[Removed Lines]",
      "821:         char *full_path = concat_path_file(dir, dent->d_name);",
      "822:         if (unlink(full_path) == -1 && errno != ENOENT)",
      "828:                 err = delete_file_dir(full_path, /*skip_lock_file:*/ false);",
      "832:                 perror_msg(\"Can't remove '%s'\", full_path);",
      "833:                 free(full_path);",
      "838:         free(full_path);",
      "840:     closedir(d);",
      "",
      "[Added Lines]",
      "854:         if (unlinkat(dir_fd, dent->d_name, /*only files*/0) == -1 && errno != ENOENT)",
      "860:                 int subdir_fd = openat(dir_fd, dent->d_name, O_DIRECTORY);",
      "861:                 if (subdir_fd < 0)",
      "862:                 {",
      "863:                     perror_msg(\"Can't open sub-dir'%s'\", dent->d_name);",
      "864:                     closedir(d);",
      "865:                     return -1;",
      "866:                 }",
      "867:                 else",
      "868:                 {",
      "869:                     err = delete_file_dir(subdir_fd, /*skip_lock_file:*/ false);",
      "870:                     close(subdir_fd);",
      "871:                     if (err == 0)",
      "872:                         unlinkat(dir_fd, dent->d_name, AT_REMOVEDIR);",
      "873:                 }",
      "877:                 perror_msg(\"Can't remove '%s'\", dent->d_name);",
      "",
      "---------------",
      "--- Hunk 22 ---",
      "[Context before]",
      "847:     if (unlink_lock_file)",
      "871: }",
      "873: int dd_delete(struct dump_dir *dd)",
      "",
      "[Removed Lines]",
      "848:     {",
      "849:         char *full_path = concat_path_file(dir, \".lock\");",
      "850:         xunlink(full_path);",
      "851:         free(full_path);",
      "853:         unsigned cnt = RMDIR_FAIL_COUNT;",
      "854:         do {",
      "855:             if (rmdir(dir) == 0)",
      "856:                 return 0;",
      "863:             usleep(RMDIR_FAIL_USLEEP);",
      "864:         } while (--cnt != 0);",
      "865:     }",
      "867:     int r = rmdir(dir);",
      "868:     if (r)",
      "869:         perror_msg(\"Can't remove directory '%s'\", dir);",
      "870:     return r;",
      "",
      "[Added Lines]",
      "890:         xunlinkat(dir_fd, \".lock\", /*only files*/0);",
      "892:     return 0;",
      "",
      "---------------",
      "--- Hunk 23 ---",
      "[Context before]",
      "878:         return -1;",
      "879:     }",
      "883:     dd_close(dd);",
      "885: }",
      "887: int dd_chown(struct dump_dir *dd, uid_t new_uid)",
      "",
      "[Removed Lines]",
      "881:     int r = delete_file_dir(dd->dd_dirname, /*skip_lock_file:*/ true);",
      "884:     return r;",
      "",
      "[Added Lines]",
      "903:     if (delete_file_dir(dd->dd_fd, /*skip_lock_file:*/ true) != 0)",
      "904:     {",
      "905:         perror_msg(\"Can't remove contents of directory '%s'\", dd->dd_dirname);",
      "906:         return -2;",
      "907:     }",
      "909:     unsigned cnt = RMDIR_FAIL_COUNT;",
      "910:     do {",
      "911:         if (rmdir(dd->dd_dirname) == 0)",
      "912:             break;",
      "919:         usleep(RMDIR_FAIL_USLEEP);",
      "920:     } while (--cnt != 0);",
      "922:     if (cnt == 0)",
      "923:     {",
      "924:         perror_msg(\"Can't remove directory '%s'\", dd->dd_dirname);",
      "925:         return -3;",
      "926:     }",
      "930:     return 0;",
      "",
      "---------------",
      "--- Hunk 24 ---",
      "[Context before]",
      "911:     gid_t groups_gid = pw->pw_gid;",
      "912: #endif",
      "915:     if (chown_res)",
      "917:     else",
      "918:     {",
      "919:         dd_init_next_file(dd);",
      "922:         {",
      "925:             if (chown_res)",
      "928:         }",
      "929:     }",
      "931:     return chown_res;",
      "932: }",
      "935: {",
      "937:     if (fd == -1)",
      "938:     {",
      "939:         if (!(flags & DD_FAIL_QUIETLY_ENOENT))",
      "",
      "[Removed Lines]",
      "914:     int chown_res = lchown(dd->dd_dirname, owners_uid, groups_gid);",
      "916:         perror_msg(\"lchown('%s')\", dd->dd_dirname);",
      "920:         char *full_name;",
      "921:         while (chown_res == 0 && dd_get_next_file(dd, /*short_name*/ NULL, &full_name))",
      "923:             log_debug(\"chowning %s\", full_name);",
      "924:             chown_res = lchown(full_name, owners_uid, groups_gid);",
      "926:                 perror_msg(\"lchown('%s')\", full_name);",
      "927:             free(full_name);",
      "934: static char *load_text_file(const char *path, unsigned flags)",
      "936:     int fd = open(path, O_RDONLY | ((flags & DD_OPEN_FOLLOW) ? 0 : O_NOFOLLOW));",
      "",
      "[Added Lines]",
      "960:     int chown_res = fchown(dd->dd_fd, owners_uid, groups_gid);",
      "962:         perror_msg(\"fchown('%s')\", dd->dd_dirname);",
      "966:         char *short_name;",
      "967:         while (chown_res == 0 && dd_get_next_file(dd, &short_name, /*full_name*/ NULL))",
      "970:             int fd = secure_openat_read(dd->dd_fd, short_name);",
      "971:             if (fd < 0)",
      "972:                 goto next;",
      "974:             log_debug(\"chowning %s\", short_name);",
      "976:             chown_res = fchown(fd, owners_uid, groups_gid);",
      "978:                 perror_msg(\"fchownat('%s')\", short_name);",
      "980:             close(fd);",
      "981: next:",
      "982:             free(short_name);",
      "989: static char *load_text_from_file_descriptor(int fd, const char *path, int flags)",
      "",
      "---------------",
      "--- Hunk 25 ---",
      "[Context before]",
      "988:     return strbuf_free_nobuf(buf_content);",
      "989: }",
      "991: static void copy_file_from_chroot(struct dump_dir* dd, const char *name, const char *chroot_dir, const char *file_path)",
      "992: {",
      "993:     char *chrooted_name = concat_path_file(chroot_dir, file_path);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1045: static char *load_text_file_at(int dir_fd, const char *name, unsigned flags)",
      "1046: {",
      "1047:     assert(name[0] != '/');",
      "1049:     const int fd = openat(dir_fd, name, O_RDONLY | ((flags & DD_OPEN_FOLLOW) ? 0 : O_NOFOLLOW));",
      "1050:     return load_text_from_file_descriptor(fd, name, flags);",
      "1051: }",
      "1053: static char *load_text_file(const char *path, unsigned flags)",
      "1054: {",
      "1055:     const int fd = open(path, O_RDONLY | ((flags & DD_OPEN_FOLLOW) ? 0 : O_NOFOLLOW));",
      "1056:     return load_text_from_file_descriptor(fd, path, flags);",
      "1057: }",
      "",
      "---------------",
      "--- Hunk 26 ---",
      "[Context before]",
      "1001:     }",
      "1002: }",
      "1005: {",
      "1009:     if (fd < 0)",
      "1010:     {",
      "1012:         return false;",
      "1013:     }",
      "",
      "[Removed Lines]",
      "1004: static bool save_binary_file(const char *path, const char* data, unsigned size, uid_t uid, gid_t gid, mode_t mode)",
      "1007:     unlink(path);",
      "1008:     int fd = open(path, O_WRONLY | O_TRUNC | O_CREAT | O_NOFOLLOW, mode);",
      "1011:         perror_msg(\"Can't open file '%s'\", path);",
      "",
      "[Added Lines]",
      "1072: static bool save_binary_file_at(int dir_fd, const char *name, const char* data, unsigned size, uid_t uid, gid_t gid, mode_t mode)",
      "1074:     assert(name[0] != '/');",
      "1077:     unlinkat(dir_fd, name, /*remove only files*/0);",
      "1078:     int fd = openat(dir_fd, name, O_WRONLY | O_EXCL | O_CREAT | O_NOFOLLOW, mode);",
      "1081:         perror_msg(\"Can't open file '%s'\", name);",
      "",
      "---------------",
      "--- Hunk 27 ---",
      "[Context before]",
      "1016:     {",
      "1017:         if (fchown(fd, uid, gid) == -1)",
      "1018:         {",
      "1020:         }",
      "1021:     }",
      "",
      "[Removed Lines]",
      "1019:             perror_msg(\"Can't change '%s' ownership to %lu:%lu\", path, (long)uid, (long)gid);",
      "",
      "[Added Lines]",
      "1089:             perror_msg(\"Can't change '%s' ownership to %lu:%lu\", name, (long)uid, (long)gid);",
      "1090:             close(fd);",
      "1091:             return false;",
      "",
      "---------------",
      "--- Hunk 28 ---",
      "[Context before]",
      "1029:     if (fchmod(fd, mode) == -1)",
      "1030:     {",
      "1032:     }",
      "1034:     unsigned r = full_write(fd, data, size);",
      "1035:     close(fd);",
      "1036:     if (r != size)",
      "1037:     {",
      "1039:         return false;",
      "1040:     }",
      "",
      "[Removed Lines]",
      "1031:         perror_msg(\"Can't change mode of '%s'\", path);",
      "1038:         error_msg(\"Can't save file '%s'\", path);",
      "",
      "[Added Lines]",
      "1103:         perror_msg(\"Can't change mode of '%s'\", name);",
      "1104:         close(fd);",
      "1105:         return false;",
      "1112:         error_msg(\"Can't save file '%s'\", name);",
      "",
      "---------------",
      "--- Hunk 29 ---",
      "[Context before]",
      "1058:     if (strcmp(name, \"release\") == 0)",
      "1059:         name = FILENAME_OS_RELEASE;",
      "1066: }",
      "1068: char* dd_load_text(const struct dump_dir *dd, const char *name)",
      "",
      "[Removed Lines]",
      "1061:     char *full_path = concat_path_file(dd->dd_dirname, name);",
      "1062:     char *ret = load_text_file(full_path, flags);",
      "1063:     free(full_path);",
      "1065:     return ret;",
      "",
      "[Added Lines]",
      "1135:     return load_text_file_at(dd->dd_fd, name, flags);",
      "",
      "---------------",
      "--- Hunk 30 ---",
      "[Context before]",
      "1078:     if (!str_is_correct_filename(name))",
      "1079:         error_msg_and_die(\"Cannot save text. '%s' is not a valid file name\", name);",
      "1084: }",
      "1086: void dd_save_binary(struct dump_dir* dd, const char* name, const char* data, unsigned size)",
      "",
      "[Removed Lines]",
      "1081:     char *full_path = concat_path_file(dd->dd_dirname, name);",
      "1082:     save_binary_file(full_path, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);",
      "1083:     free(full_path);",
      "",
      "[Added Lines]",
      "1151:     save_binary_file_at(dd->dd_fd, name, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);",
      "",
      "---------------",
      "--- Hunk 31 ---",
      "[Context before]",
      "1091:     if (!str_is_correct_filename(name))",
      "1092:         error_msg_and_die(\"Cannot save binary. '%s' is not a valid file name\", name);",
      "1097: }",
      "1099: long dd_get_item_size(struct dump_dir *dd, const char *name)",
      "",
      "[Removed Lines]",
      "1094:     char *full_path = concat_path_file(dd->dd_dirname, name);",
      "1095:     save_binary_file(full_path, data, size, dd->dd_uid, dd->dd_gid, dd->mode);",
      "1096:     free(full_path);",
      "",
      "[Added Lines]",
      "1162:     save_binary_file_at(dd->dd_fd, name, data, size, dd->dd_uid, dd->dd_gid, dd->mode);",
      "",
      "---------------",
      "--- Hunk 32 ---",
      "[Context before]",
      "1102:         error_msg_and_die(\"Cannot get item size. '%s' is not a valid file name\", name);",
      "1104:     long size = -1;",
      "1106:     struct stat statbuf;",
      "1109:         size = statbuf.st_size;",
      "1110:     else",
      "1111:     {",
      "1112:         if (errno == ENOENT)",
      "1113:             size = 0;",
      "1114:         else",
      "1116:     }",
      "1120:     return size;",
      "1121: }",
      "",
      "[Removed Lines]",
      "1105:     char *iname = concat_path_file(dd->dd_dirname, name);",
      "1108:     if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))",
      "1115:             perror_msg(\"Can't get size of file '%s'\", iname);",
      "1118:     free(iname);",
      "",
      "[Added Lines]",
      "1172:     int r = fstatat(dd->dd_fd, name, &statbuf, AT_SYMLINK_NOFOLLOW);",
      "1174:     if (r == 0 && S_ISREG(statbuf.st_mode))",
      "1181:             perror_msg(\"Can't get size of file '%s'\", name);",
      "",
      "---------------",
      "--- Hunk 33 ---",
      "[Context before]",
      "1128:     if (!str_is_correct_filename(name))",
      "1129:         error_msg_and_die(\"Cannot delete item. '%s' is not a valid file name\", name);",
      "1134:     if (res < 0)",
      "1135:     {",
      "1136:         if (errno == ENOENT)",
      "1137:             errno = res = 0;",
      "1138:         else",
      "1140:     }",
      "1143:     return res;",
      "1144: }",
      "",
      "[Removed Lines]",
      "1131:     char *path = concat_path_file(dd->dd_dirname, name);",
      "1132:     int res = unlink(path);",
      "1139:             perror_msg(\"Can't delete file '%s'\", path);",
      "1142:     free(path);",
      "",
      "[Added Lines]",
      "1195:     int res = unlinkat(dd->dd_fd, name, /*only files*/0);",
      "1202:             perror_msg(\"Can't delete file '%s'\", name);",
      "",
      "---------------",
      "--- Hunk 34 ---",
      "[Context before]",
      "1147: {",
      "1151:     if (dd->next_dir)",
      "1152:         closedir(dd->next_dir);",
      "1155:     if (!dd->next_dir)",
      "1156:     {",
      "1157:         error_msg(\"Can't open directory '%s'\", dd->dd_dirname);",
      "",
      "[Removed Lines]",
      "1154:     dd->next_dir = opendir(dd->dd_dirname);",
      "",
      "[Added Lines]",
      "1212:     int opendir_fd = dup(dd->dd_fd);",
      "1213:     if (opendir_fd < 0)",
      "1214:     {",
      "1215:         perror_msg(\"dd_init_next_file: dup(dd_fd)\");",
      "1216:         return NULL;",
      "1217:     }",
      "1222:     dd->next_dir = fdopendir(opendir_fd);",
      "",
      "---------------",
      "--- Hunk 35 ---",
      "[Context before]",
      "1168:     struct dirent *dent;",
      "1169:     while ((dent = readdir(dd->next_dir)) != NULL)",
      "1170:     {",
      "1172:         {",
      "1173:             if (short_name)",
      "",
      "[Removed Lines]",
      "1171:         if (is_regular_file(dent, dd->dd_dirname))",
      "",
      "[Added Lines]",
      "1239:         if (is_regular_file_at(dent, dd->dd_fd))",
      "",
      "---------------"
    ],
    "src/lib/problem_data.c||src/lib/problem_data.c": [
      "File: src/lib/problem_data.c -> src/lib/problem_data.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "279:     FILENAME_OS_RELEASE,",
      "280:     NULL",
      "281: };",
      "283: {",
      "290:     if (fd < 0)",
      "",
      "[Removed Lines]",
      "282: static char* is_text_file(const char *name, ssize_t *sz)",
      "289:     int fd = open(name, O_RDONLY);",
      "",
      "[Added Lines]",
      "282: static char* is_text_file_at(int dir_fd, const char *name, ssize_t *sz)",
      "289:     int fd = secure_openat_read(dir_fd, name);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "399:         }",
      "401:         ssize_t sz = 4*1024;",
      "403:         if (!text || text == HUGE_TEXT)",
      "404:         {",
      "405:             int flag = !text ? CD_FLAG_BIN : (CD_FLAG_BIN+CD_FLAG_BIGTXT);",
      "",
      "[Removed Lines]",
      "402:         char *text = is_text_file(full_name, &sz);",
      "",
      "[Added Lines]",
      "402:         char *text = is_text_file_at(dd->dd_fd, short_name, &sz);",
      "",
      "---------------"
    ],
    "src/lib/xfuncs.c||src/lib/xfuncs.c": [
      "File: src/lib/xfuncs.c -> src/lib/xfuncs.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "331:     return xopen3(pathname, flags, 0666);",
      "332: }",
      "334: void xunlink(const char *pathname)",
      "335: {",
      "336:     if (unlink(pathname))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "334: void xunlinkat(int dir_fd, const char *pathname, int flags)",
      "335: {",
      "336:     if (unlinkat(dir_fd, pathname, flags))",
      "337:         perror_msg_and_die(\"Can't remove file '%s'\", pathname);",
      "338: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "363: {",
      "364:     if (dent->d_type == DT_REG)",
      "365:         return 1;",
      "366:     if (dent->d_type != DT_UNKNOWN)",
      "367:         return 0;",
      "370:     struct stat statbuf;",
      "374:     return r == 0 && S_ISREG(statbuf.st_mode);",
      "375: }",
      "379: bool dot_or_dotdot(const char *filename)",
      "",
      "[Removed Lines]",
      "362: int is_regular_file(struct dirent *dent, const char *dirname)",
      "369:     char *fullname = xasprintf(\"%s/%s\", dirname, dent->d_name);",
      "371:     int r = lstat(fullname, &statbuf);",
      "372:     free(fullname);",
      "",
      "[Added Lines]",
      "368: int is_regular_file_at(struct dirent *dent, int dir_fd)",
      "376:     int r = fstatat(dir_fd, dent->d_name, &statbuf, AT_SYMLINK_NOFOLLOW);",
      "381: int is_regular_file(struct dirent *dent, const char *dirname)",
      "382: {",
      "383:     int dir_fd = open(dirname, O_DIRECTORY);",
      "384:     if (dir_fd < 0)",
      "385:         return 0;",
      "386:     int r = is_regular_file_at(dent, dir_fd);",
      "387:     close(dir_fd);",
      "388:     return r;",
      "389: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "16b2ebdb678b7475bacb80dd59e949055d3f856c",
      "candidate_info": {
        "commit_hash": "16b2ebdb678b7475bacb80dd59e949055d3f856c",
        "repo": "abrt/libreport",
        "commit_url": "https://github.com/abrt/libreport/commit/16b2ebdb678b7475bacb80dd59e949055d3f856c",
        "files": [
          "src/include/dump_dir.h",
          "src/lib/dump_dir.c"
        ],
        "message": "lib: add alternative dd functions accepting fds\n\nFlorian Weimer <fweimer@redhat.com>:\n\n    dump_dir_accessible_by_uid() is fundamentally insecure because it\n    opens up a classic time-of-check-time-of-use race between this\n    function and and dd_opendir().  At least re-checking after\n    dd_opendir() with the stored file descriptor is needed.\n\nRelated: #1214745\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "src/include/dump_dir.h||src/include/dump_dir.h",
          "src/lib/dump_dir.c||src/lib/dump_dir.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/abrt/libreport/pull/343"
        ],
        "olp_code_files": {
          "patch": [
            "src/include/dump_dir.h||src/include/dump_dir.h",
            "src/lib/dump_dir.c||src/lib/dump_dir.c"
          ],
          "candidate": [
            "src/include/dump_dir.h||src/include/dump_dir.h",
            "src/lib/dump_dir.c||src/lib/dump_dir.c"
          ]
        }
      },
      "candidate_diff": {
        "src/include/dump_dir.h||src/include/dump_dir.h": [
          "File: src/include/dump_dir.h -> src/include/dump_dir.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "69: void dd_close(struct dump_dir *dd);",
          "71: struct dump_dir *dd_opendir(const char *dir, int flags);",
          "72: struct dump_dir *dd_create_skeleton(const char *dir, uid_t uid, mode_t mode, int flags);",
          "73: int dd_reset_ownership(struct dump_dir *dd);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "73: int dd_openfd(const char *dir);",
          "77: struct dump_dir *dd_fdopendir(int dir_fd, const char *dir, int flags);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "149: int dump_dir_accessible_by_uid(const char *dirname, uid_t uid);",
          "151: enum {",
          "152:     DD_STAT_ACCESSIBLE_BY_UID = 1,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "156: int fdump_dir_accessible_by_uid(int dir_fd, uid_t uid);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "163: int dump_dir_stat_for_uid(const char *dirname, uid_t uid);",
          "166:    reason to it, which prevents libreport from reporting the problem",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "171: int fdump_dir_stat_for_uid(int dir_fd, uid_t uid);",
          "",
          "---------------"
        ],
        "src/lib/dump_dir.c||src/lib/dump_dir.c": [
          "File: src/lib/dump_dir.c -> src/lib/dump_dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "417:     return xstrndup(dir, len);",
          "418: }",
          "421: {",
          "426:     struct stat stat_buf;",
          "427:     if (dd->dd_fd < 0)",
          "428:         goto cant_access;",
          "",
          "[Removed Lines]",
          "420: struct dump_dir *dd_opendir(const char *dir, int flags)",
          "422:     struct dump_dir *dd = dd_init();",
          "424:     dir = dd->dd_dirname = rm_trailing_slashes(dir);",
          "425:     dd->dd_fd = open(dir, O_DIRECTORY | O_NOFOLLOW);",
          "",
          "[Added Lines]",
          "420: static struct dump_dir *dd_do_open(struct dump_dir *dd, int flags)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "465:         }",
          "466:         else",
          "467:         {",
          "",
          "[Removed Lines]",
          "464:             error_msg(\"'%s' is not a problem directory\", dir);",
          "",
          "[Added Lines]",
          "461:             error_msg(\"'%s' is not a problem directory\", dd->dd_dirname);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "469:             if (errno == ENOENT || errno == ENOTDIR)",
          "470:             {",
          "471:                 if (!(flags & DD_FAIL_QUIETLY_ENOENT))",
          "473:             }",
          "474:             else",
          "475:             {",
          "476:                 if (!(flags & DD_FAIL_QUIETLY_EACCES))",
          "478:             }",
          "479:         }",
          "480:         dd_close(dd);",
          "",
          "[Removed Lines]",
          "472:                     error_msg(\"'%s' does not exist\", dir);",
          "477:                     perror_msg(\"Can't access '%s'\", dir);",
          "",
          "[Added Lines]",
          "469:                     error_msg(\"'%s' does not exist\", dd->dd_dirname);",
          "474:                     perror_msg(\"Can't access '%s'\", dd->dd_dirname);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "489:         if (fstat(dd->dd_fd, &stat_buf) != 0)",
          "490:         {",
          "492:             dd_close(dd);",
          "493:             return NULL;",
          "494:         }",
          "",
          "[Removed Lines]",
          "491:             error_msg(\"Can't stat '%s'\", dir);",
          "",
          "[Added Lines]",
          "488:             error_msg(\"Can't stat '%s'\", dd->dd_dirname);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "499:     return dd;",
          "500: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "499: int dd_openfd(const char *dir)",
          "500: {",
          "501:     return open(dir, O_DIRECTORY | O_NOFOLLOW);",
          "502: }",
          "504: struct dump_dir *dd_fdopendir(int dir_fd, const char *dir, int flags)",
          "505: {",
          "506:     struct dump_dir *dd = dd_init();",
          "508:     dd->dd_dirname = rm_trailing_slashes(dir);",
          "509:     dd->dd_fd = dir_fd;",
          "512:     errno = 0;",
          "513:     return dd_do_open(dd, flags);",
          "514: }",
          "516: struct dump_dir *dd_opendir(const char *dir, int flags)",
          "517: {",
          "518:     struct dump_dir *dd = dd_init();",
          "520:     dd->dd_dirname = rm_trailing_slashes(dir);",
          "522:     dd->dd_fd = dd_openfd(dir);",
          "524:     return dd_do_open(dd, flags);",
          "525: }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "938:     struct stat statbuf;",
          "940:     {",
          "941:         perror_msg(\"stat('%s')\", dd->dd_dirname);",
          "942:         return 1;",
          "",
          "[Removed Lines]",
          "939:     if (!(stat(dd->dd_dirname, &statbuf) == 0 && S_ISDIR(statbuf.st_mode)))",
          "",
          "[Added Lines]",
          "964:     if (!fstat(dd->dd_fd, &statbuf) == 0)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1352: }",
          "1353: #endif",
          "1356: {",
          "1357:     struct stat statbuf;",
          "1359:     {",
          "1361:         errno = ENOTDIR;",
          "1362:         return -1;",
          "1363:     }",
          "",
          "[Removed Lines]",
          "1355: int dump_dir_stat_for_uid(const char *dirname, uid_t uid)",
          "1358:     if (stat(dirname, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))",
          "1360:         log_debug(\"can't get stat of '%s': not a problem directory\", dirname);",
          "",
          "[Added Lines]",
          "1380: int fdump_dir_stat_for_uid(int dir_fd, uid_t uid)",
          "1383:     if (fstat(dir_fd, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))",
          "1385:         log_debug(\"can't get stat: not a problem directory\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1367:     int ddstat = 0;",
          "1368:     if (uid == 0 || (statbuf.st_mode & S_IROTH))",
          "1369:     {",
          "1371:         ddstat |= DD_STAT_ACCESSIBLE_BY_UID;",
          "1372:     }",
          "",
          "[Removed Lines]",
          "1370:         log_debug(\"directory '%s' is accessible by %ld uid\", dirname, (long)uid);",
          "",
          "[Added Lines]",
          "1395:         log_debug(\"directory is accessible by %ld uid\", (long)uid);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1377:     if (uid_in_group(uid, statbuf.st_gid))",
          "1378: #endif",
          "1379:     {",
          "1381:         ddstat |= DD_STAT_ACCESSIBLE_BY_UID;",
          "1382:         ddstat |= DD_STAT_OWNED_BY_UID;",
          "1383:     }",
          "",
          "[Removed Lines]",
          "1380:         log_debug(\"%ld uid owns directory '%s'\", (long)uid, dirname);",
          "",
          "[Added Lines]",
          "1405:         log_debug(\"%ld uid owns directory\", (long)uid);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1385:     return ddstat;",
          "1386: }",
          "1388: int dump_dir_accessible_by_uid(const char *dirname, uid_t uid)",
          "1389: {",
          "1390:     int ddstat = dump_dir_stat_for_uid(dirname, uid);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1413: int dump_dir_stat_for_uid(const char *dirname, uid_t uid)",
          "1414: {",
          "1415:     int dir_fd = open(dirname, O_DIRECTORY | O_NOFOLLOW);",
          "1416:     if (dir_fd < 0)",
          "1417:     {",
          "1418:         log_debug(\"can't open '%s': not a problem directory\", dirname);",
          "1419:         errno = ENOTDIR;",
          "1420:         return -1;",
          "1421:     }",
          "1423:     int r = fdump_dir_stat_for_uid(dir_fd, uid);",
          "1424:     close(dir_fd);",
          "1425:     return r;",
          "1426: }",
          "1428: int fdump_dir_accessible_by_uid(int dir_fd, uid_t uid)",
          "1429: {",
          "1430:     int ddstat = fdump_dir_stat_for_uid(dir_fd, uid);",
          "1432:     if (ddstat >= 0)",
          "1433:         return ddstat & DD_STAT_ACCESSIBLE_BY_UID;",
          "1435:     VERB3 pwarn_msg(\"can't determine accessibility for %ld uid\", (long)uid);",
          "1437:     return 0;",
          "1438: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e76a8655152129de09bd9521ade8158bb07cc8fe",
      "candidate_info": {
        "commit_hash": "e76a8655152129de09bd9521ade8158bb07cc8fe",
        "repo": "abrt/libreport",
        "commit_url": "https://github.com/abrt/libreport/commit/e76a8655152129de09bd9521ade8158bb07cc8fe",
        "files": [
          "src/include/dump_dir.h",
          "src/lib/dump_dir.c"
        ],
        "message": "dump_dir: allow hooks to create dump directory without parents\n\nWith a centralized model of handling problems like ABRT, there is a need\nto ensure that every dump directory is a descendant of some central\ndirectory (database). This commit together with other security commits\nmakes code of the tools creating the dump directories in the central\ndirectory more robust by ensuring that no tool accidentally creates the\ncentral directory and all tools creates exactly one directory.\n\nRelated: #1211835\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "src/include/dump_dir.h||src/include/dump_dir.h",
          "src/lib/dump_dir.c||src/lib/dump_dir.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/abrt/libreport/pull/343"
        ],
        "olp_code_files": {
          "patch": [
            "src/include/dump_dir.h||src/include/dump_dir.h",
            "src/lib/dump_dir.c||src/lib/dump_dir.c"
          ],
          "candidate": [
            "src/include/dump_dir.h||src/include/dump_dir.h",
            "src/lib/dump_dir.c||src/lib/dump_dir.c"
          ]
        }
      },
      "candidate_diff": {
        "src/include/dump_dir.h||src/include/dump_dir.h": [
          "File: src/include/dump_dir.h -> src/include/dump_dir.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "43:     DD_OPEN_READONLY = (1 << 3),",
          "44:     DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE = (1 << 4),",
          "45:     DD_DONT_WAIT_FOR_LOCK = (1 << 5),",
          "46: };",
          "48: struct dump_dir {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47:     DD_CREATE_PARENTS = (1 << 6),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "60: void dd_close(struct dump_dir *dd);",
          "62: struct dump_dir *dd_opendir(const char *dir, int flags);",
          "64: int dd_reset_ownership(struct dump_dir *dd);",
          "",
          "[Removed Lines]",
          "63: struct dump_dir *dd_create_skeleton(const char *dir, uid_t uid, mode_t mode);",
          "",
          "[Added Lines]",
          "65: struct dump_dir *dd_create_skeleton(const char *dir, uid_t uid, mode_t mode, int flags);",
          "",
          "---------------"
        ],
        "src/lib/dump_dir.c||src/lib/dump_dir.c": [
          "File: src/lib/dump_dir.c -> src/lib/dump_dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "518: {",
          "520:     mode_t dir_mode = mode | ((mode & 0444) >> 2);",
          "",
          "[Removed Lines]",
          "517: struct dump_dir *dd_create_skeleton(const char *dir, uid_t uid, mode_t mode)",
          "",
          "[Added Lines]",
          "517: struct dump_dir *dd_create_skeleton(const char *dir, uid_t uid, mode_t mode, int flags)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "551:     {",
          "552:         perror_msg(\"Can't create directory '%s'\", dir);",
          "553:         dd_close(dd);",
          "",
          "[Removed Lines]",
          "550:     if (g_mkdir_with_parents(dd->dd_dirname, dir_mode) != 0)",
          "",
          "[Added Lines]",
          "550:     int r;",
          "551:     if ((flags & DD_CREATE_PARENTS))",
          "552:         r = g_mkdir_with_parents(dd->dd_dirname, dir_mode);",
          "553:     else",
          "554:         r = mkdir(dd->dd_dirname, dir_mode);",
          "556:     if (r != 0)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "628: struct dump_dir *dd_create(const char *dir, uid_t uid, mode_t mode)",
          "629: {",
          "631:     if (dd == NULL)",
          "632:         return NULL;",
          "",
          "[Removed Lines]",
          "630:     struct dump_dir *dd = dd_create_skeleton(dir, uid, mode);",
          "",
          "[Added Lines]",
          "636:     struct dump_dir *dd = dd_create_skeleton(dir, uid, mode, DD_CREATE_PARENTS);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c962918bc70a61a8cc647898ee8b1ff1c14a87c5",
      "candidate_info": {
        "commit_hash": "c962918bc70a61a8cc647898ee8b1ff1c14a87c5",
        "repo": "abrt/libreport",
        "commit_url": "https://github.com/abrt/libreport/commit/c962918bc70a61a8cc647898ee8b1ff1c14a87c5",
        "files": [
          "configure.ac"
        ],
        "message": "build: switch the default dump dir mode to 0640\n\nThe 0660 allows root escalations in ABRT. We don't really need to have\nthe dump directories writable for the group as ABRT processes run under\nroot. We introduced 0x1 for group with the switch to /var/tmp/abrt\nbecause we thought that we will have ABRT processes run under the user\nabrt, but there are no signs that we will ever pursue such a setup.\n\nRelated: #1212861\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "configure.ac||configure.ac"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/abrt/libreport/pull/343"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "configure.ac||configure.ac": [
          "File: configure.ac -> configure.ac",
          "--- Hunk 1 ---",
          "[Context before]",
          "250: AC_ARG_WITH([defaultdumpdirmode],",
          "251:             AS_HELP_STRING([--with-defaultdumpdirmode=OCTAL-MODE],",
          "254: AC_SUBST([DEFAULT_DUMP_DIR_MODE], [$with_defaultdumpdirmode])",
          "256: DUMP_DIR_OWNED_BY_USER=1",
          "",
          "[Removed Lines]",
          "252:                            [Default dump dir mode (default: 0660)]),",
          "253:             [], [with_defaultdumpdirmode=\"0660\"])",
          "",
          "[Added Lines]",
          "252:                            [Default dump dir mode (default: 0640)]),",
          "253:             [], [with_defaultdumpdirmode=\"0640\"])",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "239c4f7d1f47265526b39ad70106767d00805277",
      "candidate_info": {
        "commit_hash": "239c4f7d1f47265526b39ad70106767d00805277",
        "repo": "abrt/libreport",
        "commit_url": "https://github.com/abrt/libreport/commit/239c4f7d1f47265526b39ad70106767d00805277",
        "files": [
          "src/lib/create_dump_dir.c",
          "src/lib/dump_dir.c"
        ],
        "message": "dd: harden functions against directory traversal issues\n\nTest correctness of all accessed dump dir files in all dd* functions.\nBefore this commit, the callers were allowed to pass strings like\n\"../../etc/shadow\" in the filename argument of all dd* functions.\n\nRelated: #1214457\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "src/lib/create_dump_dir.c||src/lib/create_dump_dir.c",
          "src/lib/dump_dir.c||src/lib/dump_dir.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/abrt/libreport/pull/343"
        ],
        "olp_code_files": {
          "patch": [
            "src/lib/dump_dir.c||src/lib/dump_dir.c"
          ],
          "candidate": [
            "src/lib/dump_dir.c||src/lib/dump_dir.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/create_dump_dir.c||src/lib/create_dump_dir.c": [
          "File: src/lib/create_dump_dir.c -> src/lib/create_dump_dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "42:         return NULL;",
          "43:     }",
          "45:     uid_t uid = (uid_t)-1L;",
          "46:     char *uid_str = problem_data_get_content_or_NULL(problem_data, FILENAME_UID);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "45:     if (!str_is_correct_filename(type))",
          "46:     {",
          "47:         error_msg(_(\"'%s' is not correct file name\"), FILENAME_ANALYZER);",
          "48:         return NULL;",
          "49:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "105:     g_hash_table_iter_init(&iter, problem_data);",
          "106:     while (g_hash_table_iter_next(&iter, (void**)&name, (void**)&value))",
          "107:     {",
          "108:         if (value->flags & CD_FLAG_BIN)",
          "109:         {",
          "110:             char *dest = concat_path_file(dd->dd_dirname, name);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "114:         if (!str_is_correct_filename(name))",
          "115:         {",
          "116:             error_msg(\"Problem data field name contains disallowed chars: '%s'\", name);",
          "117:             continue;",
          "118:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "119:             continue;",
          "120:         }",
          "129:         dd_save_text(dd, name, value->content);",
          "130:     }",
          "",
          "[Removed Lines]",
          "123:         if (name[0] == '.' || strchr(name, '/'))",
          "124:         {",
          "125:             error_msg(\"Problem data field name contains disallowed chars: '%s'\", name);",
          "126:             continue;",
          "127:         }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/lib/dump_dir.c||src/lib/dump_dir.c": [
          "File: src/lib/dump_dir.c -> src/lib/dump_dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "346: int dd_exist(const struct dump_dir *dd, const char *path)",
          "347: {",
          "348:     char *full_path = concat_path_file(dd->dd_dirname, path);",
          "349:     int ret = exist_file_dir(full_path);",
          "350:     free(full_path);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "348:     if (!str_is_correct_filename(path))",
          "349:         error_msg_and_die(\"Cannot test existence. '%s' is not a valid file name\", path);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1048:     if (strcmp(name, \"release\") == 0)",
          "1049:         name = FILENAME_OS_RELEASE;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1050:     if (!str_is_correct_filename(name))",
          "1051:     {",
          "1052:         error_msg(\"Cannot load text. '%s' is not a valid file name\", name);",
          "1053:         if (!(flags & DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE))",
          "1054:             xfunc_die();",
          "1055:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1065:     if (!dd->locked)",
          "1068:     char *full_path = concat_path_file(dd->dd_dirname, name);",
          "1069:     save_binary_file(full_path, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);",
          "1070:     free(full_path);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1078:     if (!str_is_correct_filename(name))",
          "1079:         error_msg_and_die(\"Cannot save text. '%s' is not a valid file name\", name);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1075:     if (!dd->locked)",
          "1078:     char *full_path = concat_path_file(dd->dd_dirname, name);",
          "1079:     save_binary_file(full_path, data, size, dd->dd_uid, dd->dd_gid, dd->mode);",
          "1080:     free(full_path);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1091:     if (!str_is_correct_filename(name))",
          "1092:         error_msg_and_die(\"Cannot save binary. '%s' is not a valid file name\", name);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1083: long dd_get_item_size(struct dump_dir *dd, const char *name)",
          "1084: {",
          "1085:     long size = -1;",
          "1086:     char *iname = concat_path_file(dd->dd_dirname, name);",
          "1087:     struct stat statbuf;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1101:     if (!str_is_correct_filename(name))",
          "1102:         error_msg_and_die(\"Cannot get item size. '%s' is not a valid file name\", name);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1106:     if (!dd->locked)",
          "1109:     char *path = concat_path_file(dd->dd_dirname, name);",
          "1110:     int res = unlink(path);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1128:     if (!str_is_correct_filename(name))",
          "1129:         error_msg_and_die(\"Cannot delete item. '%s' is not a valid file name\", name);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "41ec59db3e6e2f19adc128d8fbd4526976ee2ca2",
      "candidate_info": {
        "commit_hash": "41ec59db3e6e2f19adc128d8fbd4526976ee2ca2",
        "repo": "abrt/libreport",
        "commit_url": "https://github.com/abrt/libreport/commit/41ec59db3e6e2f19adc128d8fbd4526976ee2ca2",
        "files": [
          "src/include/problem_data.h",
          "src/lib/create_dump_dir.c"
        ],
        "message": "lib: allow creating root owned problem directories from problem data\n\nWithout this patch libreport sets the owner of new problem directory\naccording to FILENAME_UID. This approach is not sufficient because ABRT\nhas introduced PrivateReports that should ensure that all problem\ndirectories are owned by root. So ABRT needs a way to tell libreport to\ncreate the new problem directory with uid=0.\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "src/include/problem_data.h||src/include/problem_data.h",
          "src/lib/create_dump_dir.c||src/lib/create_dump_dir.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/abrt/libreport/pull/343"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/include/problem_data.h||src/include/problem_data.h": [
          "File: src/include/problem_data.h -> src/include/problem_data.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "131:   @param base_dir_name Location to store the problem data",
          "133: struct dump_dir *create_dump_dir_from_problem_data(problem_data_t *problem_data, const char *base_dir_name);",
          "135: #ifdef __cplusplus",
          "136: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "134: struct dump_dir *create_dump_dir_from_problem_data_ext(problem_data_t *problem_data, const char *base_dir_name, uid_t uid);",
          "",
          "---------------"
        ],
        "src/lib/create_dump_dir.c||src/lib/create_dump_dir.c": [
          "File: src/lib/create_dump_dir.c -> src/lib/create_dump_dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "30:     return dd;",
          "31: }",
          "34: {",
          "35:     INITIALIZE_LIBREPORT();",
          "",
          "[Removed Lines]",
          "33: struct dump_dir *create_dump_dir_from_problem_data(problem_data_t *problem_data, const char *base_dir_name)",
          "",
          "[Added Lines]",
          "33: struct dump_dir *create_dump_dir_from_problem_data_ext(problem_data_t *problem_data, const char *base_dir_name, uid_t uid)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48:         return NULL;",
          "49:     }",
          "69:     struct timeval tv;",
          "70:     if (gettimeofday(&tv, NULL) < 0)",
          "",
          "[Removed Lines]",
          "51:     uid_t uid = (uid_t)-1L;",
          "52:     char *uid_str = problem_data_get_content_or_NULL(problem_data, FILENAME_UID);",
          "54:     if (uid_str)",
          "55:     {",
          "56:         char *endptr;",
          "57:         errno = 0;",
          "58:         long val = strtol(uid_str, &endptr, 10);",
          "60:         if (errno != 0 || endptr == uid_str || *endptr != '\\0' || INT_MAX < val)",
          "61:         {",
          "62:             error_msg(_(\"uid value is not valid: '%s'\"), uid_str);",
          "63:             return NULL;",
          "64:         }",
          "66:         uid = (uid_t)val;",
          "67:     }",
          "",
          "[Added Lines]",
          "51:     if (uid == (uid_t)-1L)",
          "52:         uid = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "144:     problem_id[strlen(problem_id) - strlen(NEW_PD_SUFFIX)] = '\\0';",
          "145:     char* new_path = concat_path_file(base_dir_name, problem_id);",
          "",
          "[Removed Lines]",
          "142:     dd_create_basic_files(dd, uid, NULL);",
          "",
          "[Added Lines]",
          "127:     const uid_t crashed_uid = problem_data_get_content_or_NULL(problem_data, FILENAME_UID) == NULL ? uid : /*uid already saved*/-1;",
          "128:     dd_create_basic_files(dd, crashed_uid, NULL);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "150:     free(problem_id);",
          "151:     return dd;",
          "152: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "140: struct dump_dir *create_dump_dir_from_problem_data(problem_data_t *problem_data, const char *base_dir_name)",
          "141: {",
          "142:     uid_t uid = (uid_t)-1L;",
          "143:     char *uid_str = problem_data_get_content_or_NULL(problem_data, FILENAME_UID);",
          "145:     if (uid_str)",
          "146:     {",
          "147:         char *endptr;",
          "148:         errno = 0;",
          "149:         long val = strtol(uid_str, &endptr, 10);",
          "151:         if (errno != 0 || endptr == uid_str || *endptr != '\\0' || INT_MAX < val)",
          "152:         {",
          "153:             error_msg(_(\"uid value is not valid: '%s'\"), uid_str);",
          "154:             return NULL;",
          "155:         }",
          "157:         uid = (uid_t)val;",
          "158:     }",
          "160:     return create_dump_dir_from_problem_data_ext(problem_data, base_dir_name, uid);",
          "161: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
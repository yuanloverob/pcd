{
  "cve_id": "CVE-2012-6701",
  "cve_desc": "Integer overflow in fs/aio.c in the Linux kernel before 3.4.1 allows local users to cause a denial of service or possibly have unspecified other impact via a large AIO iovec.",
  "repo": "torvalds/linux",
  "patch_hash": "a70b52ec1aaeaf60f4739edb1b422827cb6f3893",
  "patch_info": {
    "commit_hash": "a70b52ec1aaeaf60f4739edb1b422827cb6f3893",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/a70b52ec1aaeaf60f4739edb1b422827cb6f3893",
    "files": [
      "fs/aio.c"
    ],
    "message": "vfs: make AIO use the proper rw_verify_area() area helpers\n\nWe had for some reason overlooked the AIO interface, and it didn't use\nthe proper rw_verify_area() helper function that checks (for example)\nmandatory locking on the file, and that the size of the access doesn't\ncause us to overflow the provided offset limits etc.\n\nInstead, AIO did just the security_file_permission() thing (that\nrw_verify_area() also does) directly.\n\nThis fixes it to do all the proper helper functions, which not only\nmeans that now mandatory file locking works with AIO too, we can\nactually remove lines of code.\n\nReported-by: Manish Honap <manish_honap_vit@yahoo.co.in>\nCc: stable@vger.kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "fs/aio.c||fs/aio.c"
    ]
  },
  "patch_diff": {
    "fs/aio.c||fs/aio.c": [
      "File: fs/aio.c -> fs/aio.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1456:  if (ret < 0)",
      "1457:   goto out;",
      "1459:  kiocb->ki_nr_segs = kiocb->ki_nbytes;",
      "1460:  kiocb->ki_cur_seg = 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1459:  ret = rw_verify_area(type, kiocb->ki_filp, &kiocb->ki_pos, ret);",
      "1460:  if (ret < 0)",
      "1461:   goto out;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1467:  return ret;",
      "1468: }",
      "1471: {",
      "1472:  kiocb->ki_iovec = &kiocb->ki_inline_vec;",
      "1473:  kiocb->ki_iovec->iov_base = kiocb->ki_buf;",
      "1475:  kiocb->ki_nr_segs = 1;",
      "1476:  kiocb->ki_cur_seg = 0;",
      "1477:  return 0;",
      "",
      "[Removed Lines]",
      "1470: static ssize_t aio_setup_single_vector(struct kiocb *kiocb)",
      "1474:  kiocb->ki_iovec->iov_len = kiocb->ki_left;",
      "",
      "[Added Lines]",
      "1474: static ssize_t aio_setup_single_vector(int type, struct file * file, struct kiocb *kiocb)",
      "1476:  int bytes;",
      "1478:  bytes = rw_verify_area(type, file, &kiocb->ki_pos, kiocb->ki_left);",
      "1479:  if (bytes < 0)",
      "1480:   return bytes;",
      "1484:  kiocb->ki_iovec->iov_len = bytes;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1496:   if (unlikely(!access_ok(VERIFY_WRITE, kiocb->ki_buf,",
      "1497:    kiocb->ki_left)))",
      "1498:    break;",
      "1503:   if (ret)",
      "1504:    break;",
      "1505:   ret = -EINVAL;",
      "",
      "[Removed Lines]",
      "1499:   ret = security_file_permission(file, MAY_READ);",
      "1500:   if (unlikely(ret))",
      "1501:    break;",
      "1502:   ret = aio_setup_single_vector(kiocb);",
      "",
      "[Added Lines]",
      "1509:   ret = aio_setup_single_vector(READ, file, kiocb);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1514:   if (unlikely(!access_ok(VERIFY_READ, kiocb->ki_buf,",
      "1515:    kiocb->ki_left)))",
      "1516:    break;",
      "1521:   if (ret)",
      "1522:    break;",
      "1523:   ret = -EINVAL;",
      "",
      "[Removed Lines]",
      "1517:   ret = security_file_permission(file, MAY_WRITE);",
      "1518:   if (unlikely(ret))",
      "1519:    break;",
      "1520:   ret = aio_setup_single_vector(kiocb);",
      "",
      "[Added Lines]",
      "1524:   ret = aio_setup_single_vector(WRITE, file, kiocb);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1528:   ret = -EBADF;",
      "1529:   if (unlikely(!(file->f_mode & FMODE_READ)))",
      "1530:    break;",
      "1534:   ret = aio_setup_vectored_rw(READ, kiocb, compat);",
      "1535:   if (ret)",
      "1536:    break;",
      "",
      "[Removed Lines]",
      "1531:   ret = security_file_permission(file, MAY_READ);",
      "1532:   if (unlikely(ret))",
      "1533:    break;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1542:   ret = -EBADF;",
      "1543:   if (unlikely(!(file->f_mode & FMODE_WRITE)))",
      "1544:    break;",
      "1548:   ret = aio_setup_vectored_rw(WRITE, kiocb, compat);",
      "1549:   if (ret)",
      "1550:    break;",
      "",
      "[Removed Lines]",
      "1545:   ret = security_file_permission(file, MAY_WRITE);",
      "1546:   if (unlikely(ret))",
      "1547:    break;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "41ef4eb8eef8d06bc1399e7b00c940d771554711",
      "candidate_info": {
        "commit_hash": "41ef4eb8eef8d06bc1399e7b00c940d771554711",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/41ef4eb8eef8d06bc1399e7b00c940d771554711",
        "files": [
          "fs/aio.c",
          "include/linux/aio.h"
        ],
        "message": "aio: kill ki_retry\n\nThanks to Zach Brown's work to rip out the retry infrastructure, we don't\nneed this anymore - ki_retry was only called right after the kiocb was\ninitialized.\n\nThis also refactors and trims some duplicated code, as well as cleaning up\nthe refcounting/error handling a bit.\n\n[akpm@linux-foundation.org: use fmode_t in aio_run_iocb()]\n[akpm@linux-foundation.org: fix file_start_write/file_end_write tests]\n[akpm@linux-foundation.org: coding-style fixes]\nSigned-off-by: Kent Overstreet <koverstreet@google.com>\nCc: Zach Brown <zab@redhat.com>\nCc: Felipe Balbi <balbi@ti.com>\nCc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nCc: Mark Fasheh <mfasheh@suse.com>\nCc: Joel Becker <jlbec@evilplan.org>\nCc: Rusty Russell <rusty@rustcorp.com.au>\nCc: Jens Axboe <axboe@kernel.dk>\nCc: Asai Thambi S P <asamymuthupa@micron.com>\nCc: Selvan Mani <smani@micron.com>\nCc: Sam Bradshaw <sbradshaw@micron.com>\nCc: Jeff Moyer <jmoyer@redhat.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Benjamin LaHaise <bcrl@kvack.org>\nReviewed-by: \"Theodore Ts'o\" <tytso@mit.edu>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/aio.c||fs/aio.c",
          "include/linux/aio.h||include/linux/aio.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/aio.c||fs/aio.c"
          ],
          "candidate": [
            "fs/aio.c||fs/aio.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/aio.c||fs/aio.c": [
          "File: fs/aio.c -> fs/aio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "903:  BUG_ON(ret > 0 && iocb->ki_left == 0);",
          "904: }",
          "907: {",
          "908:  struct file *file = iocb->ki_filp;",
          "909:  struct address_space *mapping = file->f_mapping;",
          "910:  struct inode *inode = mapping->host;",
          "913:  ssize_t ret = 0;",
          "926:  if (iocb->ki_pos < 0)",
          "927:   return -EINVAL;",
          "930:   file_start_write(file);",
          "931:  do {",
          "932:   ret = rw_op(iocb, &iocb->ki_iovec[iocb->ki_cur_seg],",
          "",
          "[Removed Lines]",
          "906: static ssize_t aio_rw_vect_retry(struct kiocb *iocb)",
          "911:  ssize_t (*rw_op)(struct kiocb *, const struct iovec *,",
          "912:     unsigned long, loff_t);",
          "914:  unsigned short opcode;",
          "916:  if ((iocb->ki_opcode == IOCB_CMD_PREADV) ||",
          "917:   (iocb->ki_opcode == IOCB_CMD_PREAD)) {",
          "918:   rw_op = file->f_op->aio_read;",
          "919:   opcode = IOCB_CMD_PREADV;",
          "920:  } else {",
          "921:   rw_op = file->f_op->aio_write;",
          "922:   opcode = IOCB_CMD_PWRITEV;",
          "923:  }",
          "929:  if (opcode == IOCB_CMD_PWRITEV)",
          "",
          "[Added Lines]",
          "906: typedef ssize_t (aio_rw_op)(struct kiocb *, const struct iovec *,",
          "907:        unsigned long, loff_t);",
          "909: static ssize_t aio_rw_vect_retry(struct kiocb *iocb, int rw, aio_rw_op *rw_op)",
          "920:  if (rw == WRITE)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "940:  } while (ret > 0 && iocb->ki_left > 0 &&",
          "942:     (!S_ISFIFO(inode->i_mode) && !S_ISSOCK(inode->i_mode))));",
          "944:   file_end_write(file);",
          "",
          "[Removed Lines]",
          "941:    (opcode == IOCB_CMD_PWRITEV ||",
          "943:  if (opcode == IOCB_CMD_PWRITEV)",
          "",
          "[Added Lines]",
          "932:    (rw == WRITE ||",
          "934:  if (rw == WRITE)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "954:      && ret < 0 && ret != -EIOCBQUEUED",
          "955:      && iocb->ki_nbytes - iocb->ki_left)",
          "956:   ret = iocb->ki_nbytes - iocb->ki_left;",
          "",
          "[Removed Lines]",
          "953:  if (opcode == IOCB_CMD_PWRITEV",
          "",
          "[Added Lines]",
          "944:  if (rw == WRITE",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "958:  return ret;",
          "959: }",
          "982: {",
          "983:  ssize_t ret;",
          "985: #ifdef CONFIG_COMPAT",
          "986:  if (compat)",
          "988:     (struct compat_iovec __user *)kiocb->ki_buf,",
          "990:     &kiocb->ki_iovec);",
          "991:  else",
          "992: #endif",
          "994:     (struct iovec __user *)kiocb->ki_buf,",
          "996:     &kiocb->ki_iovec);",
          "997:  if (ret < 0)",
          "1007:  kiocb->ki_nbytes = ret;",
          "1013: }",
          "1016: {",
          "1023:  kiocb->ki_iovec = &kiocb->ki_inline_vec;",
          "1024:  kiocb->ki_iovec->iov_base = kiocb->ki_buf;",
          "1026:  kiocb->ki_nr_segs = 1;",
          "1028:  return 0;",
          "1029: }",
          "",
          "[Removed Lines]",
          "961: static ssize_t aio_fdsync(struct kiocb *iocb)",
          "962: {",
          "963:  struct file *file = iocb->ki_filp;",
          "964:  ssize_t ret = -EINVAL;",
          "966:  if (file->f_op->aio_fsync)",
          "967:   ret = file->f_op->aio_fsync(iocb, 1);",
          "968:  return ret;",
          "969: }",
          "971: static ssize_t aio_fsync(struct kiocb *iocb)",
          "972: {",
          "973:  struct file *file = iocb->ki_filp;",
          "974:  ssize_t ret = -EINVAL;",
          "976:  if (file->f_op->aio_fsync)",
          "977:   ret = file->f_op->aio_fsync(iocb, 0);",
          "978:  return ret;",
          "979: }",
          "981: static ssize_t aio_setup_vectored_rw(int type, struct kiocb *kiocb, bool compat)",
          "987:   ret = compat_rw_copy_check_uvector(type,",
          "989:     kiocb->ki_nbytes, 1, &kiocb->ki_inline_vec,",
          "993:   ret = rw_copy_check_uvector(type,",
          "995:     kiocb->ki_nbytes, 1, &kiocb->ki_inline_vec,",
          "998:   goto out;",
          "1000:  ret = rw_verify_area(type, kiocb->ki_filp, &kiocb->ki_pos, ret);",
          "1001:  if (ret < 0)",
          "1002:   goto out;",
          "1004:  kiocb->ki_nr_segs = kiocb->ki_nbytes;",
          "1005:  kiocb->ki_cur_seg = 0;",
          "1008:  kiocb->ki_left = ret;",
          "1010:  ret = 0;",
          "1011: out:",
          "1012:  return ret;",
          "1015: static ssize_t aio_setup_single_vector(int type, struct file * file, struct kiocb *kiocb)",
          "1017:  int bytes;",
          "1019:  bytes = rw_verify_area(type, file, &kiocb->ki_pos, kiocb->ki_left);",
          "1020:  if (bytes < 0)",
          "1021:   return bytes;",
          "1025:  kiocb->ki_iovec->iov_len = bytes;",
          "1027:  kiocb->ki_cur_seg = 0;",
          "",
          "[Added Lines]",
          "952: static ssize_t aio_setup_vectored_rw(int rw, struct kiocb *kiocb, bool compat)",
          "956:  kiocb->ki_nr_segs = kiocb->ki_nbytes;",
          "960:   ret = compat_rw_copy_check_uvector(rw,",
          "962:     kiocb->ki_nr_segs, 1, &kiocb->ki_inline_vec,",
          "966:   ret = rw_copy_check_uvector(rw,",
          "968:     kiocb->ki_nr_segs, 1, &kiocb->ki_inline_vec,",
          "971:   return ret;",
          "975:  return 0;",
          "978: static ssize_t aio_setup_single_vector(int rw, struct kiocb *kiocb)",
          "980:  if (unlikely(!access_ok(!rw, kiocb->ki_buf, kiocb->ki_nbytes)))",
          "981:   return -EFAULT;",
          "985:  kiocb->ki_iovec->iov_len = kiocb->ki_nbytes;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1037: {",
          "1042:  case IOCB_CMD_PREAD:",
          "1072:  case IOCB_CMD_PREADV:",
          "1083:  case IOCB_CMD_PWRITEV:",
          "1088:   if (ret)",
          "1093:   break;",
          "1094:  case IOCB_CMD_FDSYNC:",
          "1098:   break;",
          "1099:  case IOCB_CMD_FSYNC:",
          "1103:   break;",
          "1104:  default:",
          "1105:   pr_debug(\"EINVAL: no operation provided\\n\");",
          "1107:  }",
          "1112:  return 0;",
          "1113: }",
          "",
          "[Removed Lines]",
          "1036: static ssize_t aio_setup_iocb(struct kiocb *kiocb, bool compat)",
          "1038:  struct file *file = kiocb->ki_filp;",
          "1039:  ssize_t ret = 0;",
          "1041:  switch (kiocb->ki_opcode) {",
          "1043:   ret = -EBADF;",
          "1044:   if (unlikely(!(file->f_mode & FMODE_READ)))",
          "1045:    break;",
          "1046:   ret = -EFAULT;",
          "1047:   if (unlikely(!access_ok(VERIFY_WRITE, kiocb->ki_buf,",
          "1048:    kiocb->ki_left)))",
          "1049:    break;",
          "1050:   ret = aio_setup_single_vector(READ, file, kiocb);",
          "1051:   if (ret)",
          "1052:    break;",
          "1053:   ret = -EINVAL;",
          "1054:   if (file->f_op->aio_read)",
          "1055:    kiocb->ki_retry = aio_rw_vect_retry;",
          "1056:   break;",
          "1057:  case IOCB_CMD_PWRITE:",
          "1058:   ret = -EBADF;",
          "1059:   if (unlikely(!(file->f_mode & FMODE_WRITE)))",
          "1060:    break;",
          "1061:   ret = -EFAULT;",
          "1062:   if (unlikely(!access_ok(VERIFY_READ, kiocb->ki_buf,",
          "1063:    kiocb->ki_left)))",
          "1064:    break;",
          "1065:   ret = aio_setup_single_vector(WRITE, file, kiocb);",
          "1066:   if (ret)",
          "1067:    break;",
          "1068:   ret = -EINVAL;",
          "1069:   if (file->f_op->aio_write)",
          "1070:    kiocb->ki_retry = aio_rw_vect_retry;",
          "1071:   break;",
          "1073:   ret = -EBADF;",
          "1074:   if (unlikely(!(file->f_mode & FMODE_READ)))",
          "1075:    break;",
          "1076:   ret = aio_setup_vectored_rw(READ, kiocb, compat);",
          "1077:   if (ret)",
          "1078:    break;",
          "1079:   ret = -EINVAL;",
          "1080:   if (file->f_op->aio_read)",
          "1081:    kiocb->ki_retry = aio_rw_vect_retry;",
          "1082:   break;",
          "1084:   ret = -EBADF;",
          "1085:   if (unlikely(!(file->f_mode & FMODE_WRITE)))",
          "1086:    break;",
          "1087:   ret = aio_setup_vectored_rw(WRITE, kiocb, compat);",
          "1089:    break;",
          "1090:   ret = -EINVAL;",
          "1091:   if (file->f_op->aio_write)",
          "1092:    kiocb->ki_retry = aio_rw_vect_retry;",
          "1095:   ret = -EINVAL;",
          "1096:   if (file->f_op->aio_fsync)",
          "1097:    kiocb->ki_retry = aio_fdsync;",
          "1100:   ret = -EINVAL;",
          "1101:   if (file->f_op->aio_fsync)",
          "1102:    kiocb->ki_retry = aio_fsync;",
          "1106:   ret = -EINVAL;",
          "1109:  if (!kiocb->ki_retry)",
          "1110:   return ret;",
          "",
          "[Added Lines]",
          "995: static ssize_t aio_run_iocb(struct kiocb *req, bool compat)",
          "997:  struct file *file = req->ki_filp;",
          "998:  ssize_t ret;",
          "999:  int rw;",
          "1000:  fmode_t mode;",
          "1001:  aio_rw_op *rw_op;",
          "1003:  switch (req->ki_opcode) {",
          "1006:   mode = FMODE_READ;",
          "1007:   rw = READ;",
          "1008:   rw_op = file->f_op->aio_read;",
          "1009:   goto rw_common;",
          "1011:  case IOCB_CMD_PWRITE:",
          "1013:   mode = FMODE_WRITE;",
          "1014:   rw = WRITE;",
          "1015:   rw_op = file->f_op->aio_write;",
          "1016:   goto rw_common;",
          "1017: rw_common:",
          "1018:   if (unlikely(!(file->f_mode & mode)))",
          "1019:    return -EBADF;",
          "1021:   if (!rw_op)",
          "1022:    return -EINVAL;",
          "1024:   ret = (req->ki_opcode == IOCB_CMD_PREADV ||",
          "1025:          req->ki_opcode == IOCB_CMD_PWRITEV)",
          "1026:    ? aio_setup_vectored_rw(rw, req, compat)",
          "1027:    : aio_setup_single_vector(rw, req);",
          "1029:    return ret;",
          "1031:   ret = rw_verify_area(rw, file, &req->ki_pos, req->ki_nbytes);",
          "1032:   if (ret < 0)",
          "1033:    return ret;",
          "1035:   req->ki_nbytes = ret;",
          "1036:   req->ki_left = ret;",
          "1038:   ret = aio_rw_vect_retry(req, rw, rw_op);",
          "1042:   if (!file->f_op->aio_fsync)",
          "1043:    return -EINVAL;",
          "1045:   ret = file->f_op->aio_fsync(req, 1);",
          "1049:   if (!file->f_op->aio_fsync)",
          "1050:    return -EINVAL;",
          "1052:   ret = file->f_op->aio_fsync(req, 0);",
          "1057:   return -EINVAL;",
          "1060:  if (ret != -EIOCBQUEUED) {",
          "1065:   if (unlikely(ret == -ERESTARTSYS || ret == -ERESTARTNOINTR ||",
          "1066:         ret == -ERESTARTNOHAND ||",
          "1067:         ret == -ERESTART_RESTARTBLOCK))",
          "1068:    ret = -EINTR;",
          "1069:   aio_complete(req, ret, 0);",
          "1070:  }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1134:   return -EINVAL;",
          "1135:  }",
          "1138:  if (unlikely(!req))",
          "1139:   return -EAGAIN;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1097:  req = aio_get_req(ctx);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1173:  req->ki_left = req->ki_nbytes = iocb->aio_nbytes;",
          "1174:  req->ki_opcode = iocb->aio_lio_opcode;",
          "1177:  if (ret)",
          "1178:   goto out_put_req;",
          "1194:  return 0;",
          "1196: out_put_req:",
          "1197:  atomic_dec(&ctx->reqs_active);",
          "",
          "[Removed Lines]",
          "1176:  ret = aio_setup_iocb(req, compat);",
          "1180:  ret = req->ki_retry(req);",
          "1181:  if (ret != -EIOCBQUEUED) {",
          "1186:   if (unlikely(ret == -ERESTARTSYS || ret == -ERESTARTNOINTR ||",
          "1187:         ret == -ERESTARTNOHAND ||",
          "1188:         ret == -ERESTART_RESTARTBLOCK))",
          "1189:    ret = -EINTR;",
          "1190:   aio_complete(req, ret, 0);",
          "1191:  }",
          "",
          "[Added Lines]",
          "1136:  ret = aio_run_iocb(req, compat);",
          "",
          "---------------"
        ],
        "include/linux/aio.h||include/linux/aio.h": [
          "File: include/linux/aio.h -> include/linux/aio.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: typedef int (kiocb_cancel_fn)(struct kiocb *, struct io_event *);",
          "57: struct kiocb {",
          "58:  atomic_t  ki_users;",
          "60:  struct file  *ki_filp;",
          "62:  kiocb_cancel_fn  *ki_cancel;",
          "64:  void   (*ki_dtor)(struct kiocb *);",
          "66:  union {",
          "",
          "[Removed Lines]",
          "63:  ssize_t   (*ki_retry)(struct kiocb *);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
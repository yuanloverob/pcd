{
  "cve_id": "CVE-2020-13974",
  "cve_desc": "An issue was discovered in the Linux kernel 4.4 through 5.7.1. drivers/tty/vt/keyboard.c has an integer overflow if k_ascii is called several times in a row, aka CID-b86dab054059. NOTE: Members in the community argue that the integer overflow does not lead to a security issue in this case.",
  "repo": "torvalds/linux",
  "patch_hash": "b86dab054059b970111b5516ae548efaae5b3aae",
  "patch_info": {
    "commit_hash": "b86dab054059b970111b5516ae548efaae5b3aae",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/b86dab054059b970111b5516ae548efaae5b3aae",
    "files": [
      "drivers/tty/vt/keyboard.c"
    ],
    "message": "vt: keyboard: avoid signed integer overflow in k_ascii\n\nWhen k_ascii is invoked several times in a row there is a potential for\nsigned integer overflow:\n\nUBSAN: Undefined behaviour in drivers/tty/vt/keyboard.c:888:19 signed integer overflow:\n10 * 1111111111 cannot be represented in type 'int'\nCPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.6.11 #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011\nCall Trace:\n <IRQ>\n __dump_stack lib/dump_stack.c:77 [inline]\n dump_stack+0xce/0x128 lib/dump_stack.c:118\n ubsan_epilogue+0xe/0x30 lib/ubsan.c:154\n handle_overflow+0xdc/0xf0 lib/ubsan.c:184\n __ubsan_handle_mul_overflow+0x2a/0x40 lib/ubsan.c:205\n k_ascii+0xbf/0xd0 drivers/tty/vt/keyboard.c:888\n kbd_keycode drivers/tty/vt/keyboard.c:1477 [inline]\n kbd_event+0x888/0x3be0 drivers/tty/vt/keyboard.c:1495\n\nWhile it can be worked around by using check_mul_overflow()/\ncheck_add_overflow(), it is better to introduce a separate flag to\nsignal that number pad is being used to compose a symbol, and\nchange type of the accumulator from signed to unsigned, thus\navoiding undefined behavior when it overflows.\n\nReported-by: Kyungtae Kim <kt0755@gmail.com>\nSigned-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>\nCc: stable <stable@vger.kernel.org>\nLink: https://lore.kernel.org/r/20200525232740.GA262061@dtor-ws\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
    "before_after_code_files": [
      "drivers/tty/vt/keyboard.c||drivers/tty/vt/keyboard.c"
    ]
  },
  "patch_diff": {
    "drivers/tty/vt/keyboard.c||drivers/tty/vt/keyboard.c": [
      "File: drivers/tty/vt/keyboard.c -> drivers/tty/vt/keyboard.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "129: static bool dead_key_next;",
      "131: static unsigned int diacr;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "132: static bool npadch_active;",
      "133: static unsigned int npadch_value;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "845:   shift_state &= ~(1 << value);",
      "849:   if (kbd->kbdmode == VC_UNICODE)",
      "851:   else",
      "854:  }",
      "855: }",
      "",
      "[Removed Lines]",
      "848:  if (up_flag && shift_state != old_state && npadch != -1) {",
      "850:    to_utf8(vc, npadch);",
      "852:    put_queue(vc, npadch & 0xff);",
      "853:   npadch = -1;",
      "",
      "[Added Lines]",
      "852:  if (up_flag && shift_state != old_state && npadch_active) {",
      "854:    to_utf8(vc, npadch_value);",
      "856:    put_queue(vc, npadch_value & 0xff);",
      "857:   npadch_active = false;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "869: static void k_ascii(struct vc_data *vc, unsigned char value, char up_flag)",
      "870: {",
      "873:  if (up_flag)",
      "874:   return;",
      "",
      "[Removed Lines]",
      "871:  int base;",
      "",
      "[Added Lines]",
      "875:  unsigned int base;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "882:   base = 16;",
      "883:  }",
      "889: }",
      "891: static void k_lock(struct vc_data *vc, unsigned char value, char up_flag)",
      "",
      "[Removed Lines]",
      "885:  if (npadch == -1)",
      "886:   npadch = value;",
      "887:  else",
      "888:   npadch = npadch * base + value;",
      "",
      "[Added Lines]",
      "889:  if (!npadch_active) {",
      "890:   npadch_value = 0;",
      "891:   npadch_active = true;",
      "892:  }",
      "894:  npadch_value = npadch_value * base + value;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e289f03ea79bbc6574b78ac25682555423a91cbb",
      "candidate_info": {
        "commit_hash": "e289f03ea79bbc6574b78ac25682555423a91cbb",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e289f03ea79bbc6574b78ac25682555423a91cbb",
        "files": [
          "fs/btrfs/ctree.h",
          "fs/btrfs/disk-io.c",
          "fs/btrfs/extent-io-tree.h",
          "fs/btrfs/tree-log.c",
          "include/trace/events/btrfs.h"
        ],
        "message": "btrfs: fix corrupt log due to concurrent fsync of inodes with shared extents\n\nWhen we have extents shared amongst different inodes in the same subvolume,\nif we fsync them in parallel we can end up with checksum items in the log\ntree that represent ranges which overlap.\n\nFor example, consider we have inodes A and B, both sharing an extent that\ncovers the logical range from X to X + 64KiB:\n\n1) Task A starts an fsync on inode A;\n\n2) Task B starts an fsync on inode B;\n\n3) Task A calls btrfs_csum_file_blocks(), and the first search in the\n   log tree, through btrfs_lookup_csum(), returns -EFBIG because it\n   finds an existing checksum item that covers the range from X - 64KiB\n   to X;\n\n4) Task A checks that the checksum item has not reached the maximum\n   possible size (MAX_CSUM_ITEMS) and then releases the search path\n   before it does another path search for insertion (through a direct\n   call to btrfs_search_slot());\n\n5) As soon as task A releases the path and before it does the search\n   for insertion, task B calls btrfs_csum_file_blocks() and gets -EFBIG\n   too, because there is an existing checksum item that has an end\n   offset that matches the start offset (X) of the checksum range we want\n   to log;\n\n6) Task B releases the path;\n\n7) Task A does the path search for insertion (through btrfs_search_slot())\n   and then verifies that the checksum item that ends at offset X still\n   exists and extends its size to insert the checksums for the range from\n   X to X + 64KiB;\n\n8) Task A releases the path and returns from btrfs_csum_file_blocks(),\n   having inserted the checksums into an existing checksum item that got\n   its size extended. At this point we have one checksum item in the log\n   tree that covers the logical range from X - 64KiB to X + 64KiB;\n\n9) Task B now does a search for insertion using btrfs_search_slot() too,\n   but it finds that the previous checksum item no longer ends at the\n   offset X, it now ends at an of offset X + 64KiB, so it leaves that item\n   untouched.\n\n   Then it releases the path and calls btrfs_insert_empty_item()\n   that inserts a checksum item with a key offset corresponding to X and\n   a size for inserting a single checksum (4 bytes in case of crc32c).\n   Subsequent iterations end up extending this new checksum item so that\n   it contains the checksums for the range from X to X + 64KiB.\n\n   So after task B returns from btrfs_csum_file_blocks() we end up with\n   two checksum items in the log tree that have overlapping ranges, one\n   for the range from X - 64KiB to X + 64KiB, and another for the range\n   from X to X + 64KiB.\n\nHaving checksum items that represent ranges which overlap, regardless of\nbeing in the log tree or in the chekcsums tree, can lead to problems where\nchecksums for a file range end up not being found. This type of problem\nhas happened a few times in the past and the following commits fixed them\nand explain in detail why having checksum items with overlapping ranges is\nproblematic:\n\n  27b9a8122ff71a \"Btrfs: fix csum tree corruption, duplicate and outdated checksums\"\n  b84b8390d6009c \"Btrfs: fix file read corruption after extent cloning and fsync\"\n  40e046acbd2f36 \"Btrfs: fix missing data checksums after replaying a log tree\"\n\nSince this specific instance of the problem can only happen when logging\ninodes, because it is the only case where concurrent attempts to insert\nchecksums for the same range can happen, fix the issue by using an extent\nio tree as a range lock to serialize checksum insertion during inode\nlogging.\n\nThis issue could often be reproduced by the test case generic/457 from\nfstests. When it happens it produces the following trace:\n\n BTRFS critical (device dm-0): corrupt leaf: root=18446744073709551610 block=30625792 slot=42, csum end range (15020032) goes beyond the start range (15015936) of the next csum item\n BTRFS info (device dm-0): leaf 30625792 gen 7 total ptrs 49 free space 2402 owner 18446744073709551610\n BTRFS info (device dm-0): refs 1 lock (w:0 r:0 bw:0 br:0 sw:0 sr:0) lock_owner 0 current 15884\n      item 0 key (18446744073709551606 128 13979648) itemoff 3991 itemsize 4\n      item 1 key (18446744073709551606 128 13983744) itemoff 3987 itemsize 4\n      item 2 key (18446744073709551606 128 13987840) itemoff 3983 itemsize 4\n      item 3 key (18446744073709551606 128 13991936) itemoff 3979 itemsize 4\n      item 4 key (18446744073709551606 128 13996032) itemoff 3975 itemsize 4\n      item 5 key (18446744073709551606 128 14000128) itemoff 3971 itemsize 4\n (...)\n BTRFS error (device dm-0): block=30625792 write time tree block corruption detected\n ------------[ cut here ]------------\n WARNING: CPU: 1 PID: 15884 at fs/btrfs/disk-io.c:539 btree_csum_one_bio+0x268/0x2d0 [btrfs]\n Modules linked in: btrfs dm_thin_pool ...\n CPU: 1 PID: 15884 Comm: fsx Tainted: G        W         5.6.0-rc7-btrfs-next-58 #1\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.0-59-gc9ba5276e321-prebuilt.qemu.org 04/01/2014\n RIP: 0010:btree_csum_one_bio+0x268/0x2d0 [btrfs]\n Code: c7 c7 ...\n RSP: 0018:ffffbb0109e6f8e0 EFLAGS: 00010296\n RAX: 0000000000000000 RBX: ffffe1c0847b6080 RCX: 0000000000000000\n RDX: 0000000000000000 RSI: ffffffffaa963988 RDI: 0000000000000001\n RBP: ffff956a4f4d2000 R08: 0000000000000000 R09: 0000000000000001\n R10: 0000000000000526 R11: 0000000000000000 R12: ffff956a5cd28bb0\n R13: 0000000000000000 R14: ffff956a649c9388 R15: 000000011ed82000\n FS:  00007fb419959e80(0000) GS:ffff956a7aa00000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000000000fe6d54 CR3: 0000000138696005 CR4: 00000000003606e0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n Call Trace:\n  btree_submit_bio_hook+0x67/0xc0 [btrfs]\n  submit_one_bio+0x31/0x50 [btrfs]\n  btree_write_cache_pages+0x2db/0x4b0 [btrfs]\n  ? __filemap_fdatawrite_range+0xb1/0x110\n  do_writepages+0x23/0x80\n  __filemap_fdatawrite_range+0xd2/0x110\n  btrfs_write_marked_extents+0x15e/0x180 [btrfs]\n  btrfs_sync_log+0x206/0x10a0 [btrfs]\n  ? kmem_cache_free+0x315/0x3b0\n  ? btrfs_log_inode+0x1e8/0xf90 [btrfs]\n  ? __mutex_unlock_slowpath+0x45/0x2a0\n  ? lockref_put_or_lock+0x9/0x30\n  ? dput+0x2d/0x580\n  ? dput+0xb5/0x580\n  ? btrfs_sync_file+0x464/0x4d0 [btrfs]\n  btrfs_sync_file+0x464/0x4d0 [btrfs]\n  do_fsync+0x38/0x60\n  __x64_sys_fsync+0x10/0x20\n  do_syscall_64+0x5c/0x280\n  entry_SYSCALL_64_after_hwframe+0x49/0xbe\n RIP: 0033:0x7fb41953a6d0\n Code: 48 3d ...\n RSP: 002b:00007ffcc86bd218 EFLAGS: 00000246 ORIG_RAX: 000000000000004a\n RAX: ffffffffffffffda RBX: 000000000000000d RCX: 00007fb41953a6d0\n RDX: 0000000000000009 RSI: 0000000000040000 RDI: 0000000000000003\n RBP: 0000000000040000 R08: 0000000000000001 R09: 0000000000000009\n R10: 0000000000000064 R11: 0000000000000246 R12: 0000556cf4b2c060\n R13: 0000000000000100 R14: 0000000000000000 R15: 0000556cf322b420\n irq event stamp: 0\n hardirqs last  enabled at (0): [<0000000000000000>] 0x0\n hardirqs last disabled at (0): [<ffffffffa96bdedf>] copy_process+0x74f/0x2020\n softirqs last  enabled at (0): [<ffffffffa96bdedf>] copy_process+0x74f/0x2020\n softirqs last disabled at (0): [<0000000000000000>] 0x0\n ---[ end trace d543fc76f5ad7fd8 ]---\n\nIn that trace the tree checker detected the overlapping checksum items at\nthe time when we triggered writeback for the log tree when syncing the\nlog.\n\nAnother trace that can happen is due to BUG_ON() when deleting checksum\nitems while logging an inode:\n\n BTRFS critical (device dm-0): slot 81 key (18446744073709551606 128 13635584) new key (18446744073709551606 128 13635584)\n BTRFS info (device dm-0): leaf 30949376 gen 7 total ptrs 98 free space 8527 owner 18446744073709551610\n BTRFS info (device dm-0): refs 4 lock (w:1 r:0 bw:0 br:0 sw:1 sr:0) lock_owner 13473 current 13473\n  item 0 key (257 1 0) itemoff 16123 itemsize 160\n          inode generation 7 size 262144 mode 100600\n  item 1 key (257 12 256) itemoff 16103 itemsize 20\n  item 2 key (257 108 0) itemoff 16050 itemsize 53\n          extent data disk bytenr 13631488 nr 4096\n          extent data offset 0 nr 131072 ram 131072\n (...)\n ------------[ cut here ]------------\n kernel BUG at fs/btrfs/ctree.c:3153!\n invalid opcode: 0000 [#1] PREEMPT SMP DEBUG_PAGEALLOC PTI\n CPU: 1 PID: 13473 Comm: fsx Not tainted 5.6.0-rc7-btrfs-next-58 #1\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.0-59-gc9ba5276e321-prebuilt.qemu.org 04/01/2014\n RIP: 0010:btrfs_set_item_key_safe+0x1ea/0x270 [btrfs]\n Code: 0f b6 ...\n RSP: 0018:ffff95e3889179d0 EFLAGS: 00010282\n RAX: 0000000000000000 RBX: 0000000000000051 RCX: 0000000000000000\n RDX: 0000000000000000 RSI: ffffffffb7763988 RDI: 0000000000000001\n RBP: fffffffffffffff6 R08: 0000000000000000 R09: 0000000000000001\n R10: 00000000000009ef R11: 0000000000000000 R12: ffff8912a8ba5a08\n R13: ffff95e388917a06 R14: ffff89138dcf68c8 R15: ffff95e388917ace\n FS:  00007fe587084e80(0000) GS:ffff8913baa00000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 00007fe587091000 CR3: 0000000126dac005 CR4: 00000000003606e0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n Call Trace:\n  btrfs_del_csums+0x2f4/0x540 [btrfs]\n  copy_items+0x4b5/0x560 [btrfs]\n  btrfs_log_inode+0x910/0xf90 [btrfs]\n  btrfs_log_inode_parent+0x2a0/0xe40 [btrfs]\n  ? dget_parent+0x5/0x370\n  btrfs_log_dentry_safe+0x4a/0x70 [btrfs]\n  btrfs_sync_file+0x42b/0x4d0 [btrfs]\n  __x64_sys_msync+0x199/0x200\n  do_syscall_64+0x5c/0x280\n  entry_SYSCALL_64_after_hwframe+0x49/0xbe\n RIP: 0033:0x7fe586c65760\n Code: 00 f7 ...\n RSP: 002b:00007ffe250f98b8 EFLAGS: 00000246 ORIG_RAX: 000000000000001a\n RAX: ffffffffffffffda RBX: 00000000000040e1 RCX: 00007fe586c65760\n RDX: 0000000000000004 RSI: 0000000000006b51 RDI: 00007fe58708b000\n RBP: 0000000000006a70 R08: 0000000000000003 R09: 00007fe58700cb61\n R10: 0000000000000100 R11: 0000000000000246 R12: 00000000000000e1\n R13: 00007fe58708b000 R14: 0000000000006b51 R15: 0000558de021a420\n Modules linked in: dm_log_writes ...\n ---[ end trace c92a7f447a8515f5 ]---\n\nCC: stable@vger.kernel.org # 4.4+\nSigned-off-by: Filipe Manana <fdmanana@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
        "before_after_code_files": [
          "fs/btrfs/ctree.h||fs/btrfs/ctree.h",
          "fs/btrfs/disk-io.c||fs/btrfs/disk-io.c",
          "fs/btrfs/extent-io-tree.h||fs/btrfs/extent-io-tree.h",
          "fs/btrfs/tree-log.c||fs/btrfs/tree-log.c",
          "include/trace/events/btrfs.h||include/trace/events/btrfs.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/btrfs/ctree.h||fs/btrfs/ctree.h": [
          "File: fs/btrfs/ctree.h -> fs/btrfs/ctree.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1168:  struct btrfs_qgroup_swapped_blocks swapped_blocks;",
          "1170: #ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS",
          "1171:  u64 alloc_bytenr;",
          "1172: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1171:  struct extent_io_tree log_csum_range;",
          "",
          "---------------"
        ],
        "fs/btrfs/disk-io.c||fs/btrfs/disk-io.c": [
          "File: fs/btrfs/disk-io.c -> fs/btrfs/disk-io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1133:  root->log_transid = 0;",
          "1134:  root->log_transid_committed = -1;",
          "1135:  root->last_log_commit = 0;",
          "1137:   extent_io_tree_init(fs_info, &root->dirty_log_pages,",
          "1138:         IO_TREE_ROOT_DIRTY_LOG_PAGES, NULL);",
          "1140:  memset(&root->root_key, 0, sizeof(root->root_key));",
          "1141:  memset(&root->root_item, 0, sizeof(root->root_item));",
          "",
          "[Removed Lines]",
          "1136:  if (!dummy)",
          "",
          "[Added Lines]",
          "1136:  if (!dummy) {",
          "1139:   extent_io_tree_init(fs_info, &root->log_csum_range,",
          "1140:         IO_TREE_LOG_CSUM_RANGE, NULL);",
          "1141:  }",
          "",
          "---------------"
        ],
        "fs/btrfs/extent-io-tree.h||fs/btrfs/extent-io-tree.h": [
          "File: fs/btrfs/extent-io-tree.h -> fs/btrfs/extent-io-tree.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "44:  IO_TREE_TRANS_DIRTY_PAGES,",
          "45:  IO_TREE_ROOT_DIRTY_LOG_PAGES,",
          "46:  IO_TREE_INODE_FILE_EXTENT,",
          "47:  IO_TREE_SELFTEST,",
          "48: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47:  IO_TREE_LOG_CSUM_RANGE,",
          "",
          "---------------"
        ],
        "fs/btrfs/tree-log.c||fs/btrfs/tree-log.c": [
          "File: fs/btrfs/tree-log.c -> fs/btrfs/tree-log.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3291:  clear_extent_bits(&log->dirty_log_pages, 0, (u64)-1,",
          "3292:      EXTENT_DIRTY | EXTENT_NEW | EXTENT_NEED_WAIT);",
          "3293:  btrfs_put_root(log);",
          "3294: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3293:  extent_io_tree_release(&log->log_csum_range);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3903:        struct btrfs_root *log_root,",
          "3904:        struct btrfs_ordered_sum *sums)",
          "3905: {",
          "3906:  int ret;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3907:  const u64 lock_end = sums->bytenr + sums->len - 1;",
          "3908:  struct extent_state *cached_state = NULL;",
          "3917:  ret = lock_extent_bits(&log_root->log_csum_range, sums->bytenr,",
          "3918:           lock_end, &cached_state);",
          "3919:  if (ret)",
          "3920:   return ret;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3917:  ret = btrfs_del_csums(trans, log_root, sums->bytenr, sums->len);",
          "3922: }",
          "3924: static noinline int copy_items(struct btrfs_trans_handle *trans,",
          "",
          "[Removed Lines]",
          "3918:  if (ret)",
          "3919:   return ret;",
          "3921:  return btrfs_csum_file_blocks(trans, log_root, sums);",
          "",
          "[Added Lines]",
          "3931:  if (!ret)",
          "3932:   ret = btrfs_csum_file_blocks(trans, log_root, sums);",
          "3934:  unlock_extent_cached(&log_root->log_csum_range, sums->bytenr, lock_end,",
          "3935:         &cached_state);",
          "3937:  return ret;",
          "",
          "---------------"
        ],
        "include/trace/events/btrfs.h||include/trace/events/btrfs.h": [
          "File: include/trace/events/btrfs.h -> include/trace/events/btrfs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "89:   { IO_TREE_TRANS_DIRTY_PAGES,   \"TRANS_DIRTY_PAGES\" },       \\",
          "90:   { IO_TREE_ROOT_DIRTY_LOG_PAGES,   \"ROOT_DIRTY_LOG_PAGES\" },    \\",
          "91:   { IO_TREE_INODE_FILE_EXTENT,   \"INODE_FILE_EXTENT\" },       \\",
          "92:   { IO_TREE_SELFTEST,    \"SELFTEST\" })",
          "94: #define BTRFS_GROUP_FLAGS \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "92:   { IO_TREE_LOG_CSUM_RANGE,   \"LOG_CSUM_RANGE\" },          \\",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ab8b65be183180c3eef405d449163964ecc4b571",
      "candidate_info": {
        "commit_hash": "ab8b65be183180c3eef405d449163964ecc4b571",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ab8b65be183180c3eef405d449163964ecc4b571",
        "files": [
          "arch/powerpc/kvm/book3s_64_vio.c"
        ],
        "message": "KVM: PPC: Book3S: Fix some RCU-list locks\n\nIt is unsafe to traverse kvm->arch.spapr_tce_tables and\nstt->iommu_tables without the RCU read lock held. Also, add\ncond_resched_rcu() in places with the RCU read lock held that could take\na while to finish.\n\n arch/powerpc/kvm/book3s_64_vio.c:76 RCU-list traversed in non-reader section!!\n\n other info that might help us debug this:\n\n rcu_scheduler_active = 2, debug_locks = 1\n no locks held by qemu-kvm/4265.\n\n stack backtrace:\n CPU: 96 PID: 4265 Comm: qemu-kvm Not tainted 5.7.0-rc4-next-20200508+ #2\n Call Trace:\n [c000201a8690f720] [c000000000715948] dump_stack+0xfc/0x174 (unreliable)\n [c000201a8690f770] [c0000000001d9470] lockdep_rcu_suspicious+0x140/0x164\n [c000201a8690f7f0] [c008000010b9fb48] kvm_spapr_tce_release_iommu_group+0x1f0/0x220 [kvm]\n [c000201a8690f870] [c008000010b8462c] kvm_spapr_tce_release_vfio_group+0x54/0xb0 [kvm]\n [c000201a8690f8a0] [c008000010b84710] kvm_vfio_destroy+0x88/0x140 [kvm]\n [c000201a8690f8f0] [c008000010b7d488] kvm_put_kvm+0x370/0x600 [kvm]\n [c000201a8690f990] [c008000010b7e3c0] kvm_vm_release+0x38/0x60 [kvm]\n [c000201a8690f9c0] [c0000000005223f4] __fput+0x124/0x330\n [c000201a8690fa20] [c000000000151cd8] task_work_run+0xb8/0x130\n [c000201a8690fa70] [c0000000001197e8] do_exit+0x4e8/0xfa0\n [c000201a8690fb70] [c00000000011a374] do_group_exit+0x64/0xd0\n [c000201a8690fbb0] [c000000000132c90] get_signal+0x1f0/0x1200\n [c000201a8690fcc0] [c000000000020690] do_notify_resume+0x130/0x3c0\n [c000201a8690fda0] [c000000000038d64] syscall_exit_prepare+0x1a4/0x280\n [c000201a8690fe20] [c00000000000c8f8] system_call_common+0xf8/0x278\n\n ====\n arch/powerpc/kvm/book3s_64_vio.c:368 RCU-list traversed in non-reader section!!\n\n other info that might help us debug this:\n\n rcu_scheduler_active = 2, debug_locks = 1\n 2 locks held by qemu-kvm/4264:\n  #0: c000201ae2d000d8 (&vcpu->mutex){+.+.}-{3:3}, at: kvm_vcpu_ioctl+0xdc/0x950 [kvm]\n  #1: c000200c9ed0c468 (&kvm->srcu){....}-{0:0}, at: kvmppc_h_put_tce+0x88/0x340 [kvm]\n\n ====\n arch/powerpc/kvm/book3s_64_vio.c:108 RCU-list traversed in non-reader section!!\n\n other info that might help us debug this:\n\n rcu_scheduler_active = 2, debug_locks = 1\n 1 lock held by qemu-kvm/4257:\n  #0: c000200b1b363a40 (&kv->lock){+.+.}-{3:3}, at: kvm_vfio_set_attr+0x598/0x6c0 [kvm]\n\n ====\n arch/powerpc/kvm/book3s_64_vio.c:146 RCU-list traversed in non-reader section!!\n\n other info that might help us debug this:\n\n rcu_scheduler_active = 2, debug_locks = 1\n 1 lock held by qemu-kvm/4257:\n  #0: c000200b1b363a40 (&kv->lock){+.+.}-{3:3}, at: kvm_vfio_set_attr+0x598/0x6c0 [kvm]\n\nSigned-off-by: Qian Cai <cai@lca.pw>\nSigned-off-by: Paul Mackerras <paulus@ozlabs.org>",
        "before_after_code_files": [
          "arch/powerpc/kvm/book3s_64_vio.c||arch/powerpc/kvm/book3s_64_vio.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/powerpc/kvm/book3s_64_vio.c||arch/powerpc/kvm/book3s_64_vio.c": [
          "File: arch/powerpc/kvm/book3s_64_vio.c -> arch/powerpc/kvm/book3s_64_vio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "73:  struct kvmppc_spapr_tce_iommu_table *stit, *tmp;",
          "74:  struct iommu_table_group *table_group = NULL;",
          "76:  list_for_each_entry_rcu(stt, &kvm->arch.spapr_tce_tables, list) {",
          "78:   table_group = iommu_group_get_iommudata(grp);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "76:  rcu_read_lock();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "87:     kref_put(&stit->kref, kvm_spapr_tce_liobn_put);",
          "88:    }",
          "89:   }",
          "90:  }",
          "91: }",
          "93: extern long kvm_spapr_tce_attach_iommu_group(struct kvm *kvm, int tablefd,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "91:   cond_resched_rcu();",
          "93:  rcu_read_unlock();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "105:  if (!f.file)",
          "106:   return -EBADF;",
          "108:  list_for_each_entry_rcu(stt, &kvm->arch.spapr_tce_tables, list) {",
          "109:   if (stt == f.file->private_data) {",
          "110:    found = true;",
          "111:    break;",
          "112:   }",
          "113:  }",
          "115:  fdput(f);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "111:  rcu_read_lock();",
          "118:  rcu_read_unlock();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "143:  if (!tbl)",
          "144:   return -EINVAL;",
          "146:  list_for_each_entry_rcu(stit, &stt->iommu_tables, next) {",
          "147:   if (tbl != stit->tbl)",
          "148:    continue;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "151:  rcu_read_lock();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "150:   if (!kref_get_unless_zero(&stit->kref)) {",
          "152:    iommu_tce_table_put(tbl);",
          "153:    return -ENOTTY;",
          "154:   }",
          "159:   return 0;",
          "160:  }",
          "162:  stit = kzalloc(sizeof(*stit), GFP_KERNEL);",
          "163:  if (!stit) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "159:    rcu_read_unlock();",
          "166:   rcu_read_unlock();",
          "169:  rcu_read_unlock();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "365:  if (kvmppc_tce_to_ua(stt->kvm, tce, &ua))",
          "366:   return H_TOO_HARD;",
          "368:  list_for_each_entry_rcu(stit, &stt->iommu_tables, next) {",
          "369:   unsigned long hpa = 0;",
          "370:   struct mm_iommu_table_group_mem_t *mem;",
          "371:   long shift = stit->tbl->it_page_shift;",
          "373:   mem = mm_iommu_lookup(stt->kvm->mm, ua, 1ULL << shift);",
          "378:    return H_TOO_HARD;",
          "379:  }",
          "381:  return H_SUCCESS;",
          "382: }",
          "",
          "[Removed Lines]",
          "374:   if (!mem)",
          "375:    return H_TOO_HARD;",
          "377:   if (mm_iommu_ua_to_hpa(mem, ua, shift, &hpa))",
          "",
          "[Added Lines]",
          "377:  rcu_read_lock();",
          "384:   if (!mem || mm_iommu_ua_to_hpa(mem, ua, shift, &hpa)) {",
          "385:    rcu_read_unlock();",
          "387:   }",
          "389:  rcu_read_unlock();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0a82e230c68860b7286dad8644d9d9f7cfd755d2",
      "candidate_info": {
        "commit_hash": "0a82e230c68860b7286dad8644d9d9f7cfd755d2",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0a82e230c68860b7286dad8644d9d9f7cfd755d2",
        "files": [
          "net/mptcp/protocol.c"
        ],
        "message": "mptcp: avoid NULL-ptr derefence on fallback\n\nIn the MPTCP receive path we must cope with TCP fallback\non blocking recvmsg(). Currently in such code path we detect\nthe fallback condition, but we don't fetch the struct socket\nrequired for fallback.\n\nThe above allowed syzkaller to trigger a NULL pointer\ndereference:\n\ngeneral protection fault, probably for non-canonical address 0xdffffc0000000004: 0000 [#1] PREEMPT SMP KASAN\nKASAN: null-ptr-deref in range [0x0000000000000020-0x0000000000000027]\nCPU: 1 PID: 7226 Comm: syz-executor523 Not tainted 5.7.0-rc6-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nRIP: 0010:sock_recvmsg_nosec net/socket.c:886 [inline]\nRIP: 0010:sock_recvmsg+0x92/0x110 net/socket.c:904\nCode: 5b 41 5c 41 5d 41 5e 41 5f 5d c3 44 89 6c 24 04 e8 53 18 1d fb 4d 8d 6f 20 4c 89 e8 48 c1 e8 03 48 b9 00 00 00 00 00 fc ff df <80> 3c 08 00 74 08 4c 89 ef e8 20 12 5b fb bd a0 00 00 00 49 03 6d\nRSP: 0018:ffffc90001077b98 EFLAGS: 00010202\nRAX: 0000000000000004 RBX: ffffc90001077dc0 RCX: dffffc0000000000\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000\nRBP: 0000000000000000 R08: ffffffff86565e59 R09: ffffed10115afeaa\nR10: ffffed10115afeaa R11: 0000000000000000 R12: 1ffff9200020efbc\nR13: 0000000000000020 R14: ffffc90001077de0 R15: 0000000000000000\nFS:  00007fc6a3abe700(0000) GS:ffff8880ae900000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00000000004d0050 CR3: 00000000969f0000 CR4: 00000000001406e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n mptcp_recvmsg+0x18d5/0x19b0 net/mptcp/protocol.c:891\n inet_recvmsg+0xf6/0x1d0 net/ipv4/af_inet.c:838\n sock_recvmsg_nosec net/socket.c:886 [inline]\n sock_recvmsg net/socket.c:904 [inline]\n __sys_recvfrom+0x2f3/0x470 net/socket.c:2057\n __do_sys_recvfrom net/socket.c:2075 [inline]\n __se_sys_recvfrom net/socket.c:2071 [inline]\n __x64_sys_recvfrom+0xda/0xf0 net/socket.c:2071\n do_syscall_64+0xf3/0x1b0 arch/x86/entry/common.c:295\n entry_SYSCALL_64_after_hwframe+0x49/0xb3\n\nAddress the issue initializing the struct socket reference\nbefore entering the fallback code.\n\nReported-and-tested-by: syzbot+c6bfc3db991edc918432@syzkaller.appspotmail.com\nSuggested-by: Ondrej Mosnacek <omosnace@redhat.com>\nFixes: 8ab183deb26a (\"mptcp: cope with later TCP fallback\")\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>\nReviewed-by: Mat Martineau <mathew.j.martineau@linux.intel.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/mptcp/protocol.c||net/mptcp/protocol.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/mptcp/protocol.c||net/mptcp/protocol.c": [
          "File: net/mptcp/protocol.c -> net/mptcp/protocol.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "955:   pr_debug(\"block timeout %ld\", timeo);",
          "956:   mptcp_wait_data(sk, &timeo);",
          "958:    goto fallback;",
          "959:  }",
          "",
          "[Removed Lines]",
          "957:   if (unlikely(__mptcp_tcp_fallback(msk)))",
          "",
          "[Added Lines]",
          "957:   ssock = __mptcp_tcp_fallback(msk);",
          "958:   if (unlikely(ssock))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bb2f930d6dd708469a587dc9ed1efe1ef969c0bf",
      "candidate_info": {
        "commit_hash": "bb2f930d6dd708469a587dc9ed1efe1ef969c0bf",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/bb2f930d6dd708469a587dc9ed1efe1ef969c0bf",
        "files": [
          "net/sched/sch_fq_pie.c",
          "tools/testing/selftests/tc-testing/tc-tests/qdiscs/fq_pie.json"
        ],
        "message": "net/sched: fix infinite loop in sch_fq_pie\n\nthis command hangs forever:\n\n # tc qdisc add dev eth0 root fq_pie flows 65536\n\n watchdog: BUG: soft lockup - CPU#1 stuck for 23s! [tc:1028]\n [...]\n CPU: 1 PID: 1028 Comm: tc Not tainted 5.7.0-rc6+ #167\n RIP: 0010:fq_pie_init+0x60e/0x8b7 [sch_fq_pie]\n Code: 4c 89 65 50 48 89 f8 48 c1 e8 03 42 80 3c 30 00 0f 85 2a 02 00 00 48 8d 7d 10 4c 89 65 58 48 89 f8 48 c1 e8 03 42 80 3c 30 00 <0f> 85 a7 01 00 00 48 8d 7d 18 48 c7 45 10 46 c3 23 00 48 89 f8 48\n RSP: 0018:ffff888138d67468 EFLAGS: 00000246 ORIG_RAX: ffffffffffffff13\n RAX: 1ffff9200018d2b2 RBX: ffff888139c1c400 RCX: ffffffffffffffff\n RDX: 000000000000c5e8 RSI: ffffc900000e5000 RDI: ffffc90000c69590\n RBP: ffffc90000c69580 R08: fffffbfff79a9699 R09: fffffbfff79a9699\n R10: 0000000000000700 R11: fffffbfff79a9698 R12: ffffc90000c695d0\n R13: 0000000000000000 R14: dffffc0000000000 R15: 000000002347c5e8\n FS:  00007f01e1850e40(0000) GS:ffff88814c880000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 000000000067c340 CR3: 000000013864c000 CR4: 0000000000340ee0\n Call Trace:\n  qdisc_create+0x3fd/0xeb0\n  tc_modify_qdisc+0x3be/0x14a0\n  rtnetlink_rcv_msg+0x5f3/0x920\n  netlink_rcv_skb+0x121/0x350\n  netlink_unicast+0x439/0x630\n  netlink_sendmsg+0x714/0xbf0\n  sock_sendmsg+0xe2/0x110\n  ____sys_sendmsg+0x5b4/0x890\n  ___sys_sendmsg+0xe9/0x160\n  __sys_sendmsg+0xd3/0x170\n  do_syscall_64+0x9a/0x370\n  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nwe can't accept 65536 as a valid number for 'nflows', because the loop on\n'idx' in fq_pie_init() will never end. The extack message is correct, but\nit doesn't say that 0 is not a valid number for 'flows': while at it, fix\nthis also. Add a tdc selftest to check correct validation of 'flows'.\n\nCC: Ivan Vecera <ivecera@redhat.com>\nFixes: ec97ecf1ebe4 (\"net: sched: add Flow Queue PIE packet scheduler\")\nSigned-off-by: Davide Caratti <dcaratti@redhat.com>\nReviewed-by: Ivan Vecera <ivecera@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/sched/sch_fq_pie.c||net/sched/sch_fq_pie.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/sched/sch_fq_pie.c||net/sched/sch_fq_pie.c": [
          "File: net/sched/sch_fq_pie.c -> net/sched/sch_fq_pie.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "297:    goto flow_error;",
          "298:   }",
          "299:   q->flows_cnt = nla_get_u32(tb[TCA_FQ_PIE_FLOWS]);",
          "301:    NL_SET_ERR_MSG_MOD(extack,",
          "303:    goto flow_error;",
          "304:   }",
          "305:  }",
          "",
          "[Removed Lines]",
          "300:   if (!q->flows_cnt || q->flows_cnt > 65536) {",
          "302:         \"Number of flows must be < 65536\");",
          "",
          "[Added Lines]",
          "300:   if (!q->flows_cnt || q->flows_cnt >= 65536) {",
          "302:         \"Number of flows must range in [1..65535]\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4c04f25dd449a825fbcd7610c7f20be1e51b088d",
      "candidate_info": {
        "commit_hash": "4c04f25dd449a825fbcd7610c7f20be1e51b088d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4c04f25dd449a825fbcd7610c7f20be1e51b088d",
        "files": [
          "drivers/net/wireless/mediatek/mt76/mt7615/init.c"
        ],
        "message": "mt76: mt7615: fix NULL pointer deref in mt7615_register_ext_phy\n\nFix following NULL pointer dereference in mt7615_register_ext_phy routine\n\n[   27.648860] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000060\n[   27.657697] Mem abort info:\n[   27.660495]   ESR = 0x96000046\n[   27.663549]   EC = 0x25: DABT (current EL), IL = 32 bits\n[   27.668857]   SET = 0, FnV = 0\n[   27.671910]   EA = 0, S1PTW = 0\n[   27.675040] Data abort info:\n[   27.677918]   ISV = 0, ISS = 0x00000046\n[   27.681751]   CM = 0, WnR = 1\n[   27.684717] user pgtable: 4k pages, 39-bit VAs, pgdp=000000007d8cc000\n[   27.691156] [0000000000000060] pgd=000000007d281003, pud=000000007d281003, pmd=0000000000000000\n[   27.699857] Internal error: Oops: 96000046 [#1] SMP\n[   27.774939] CPU: 1 PID: 701 Comm: ash Not tainted 5.4.41 #0\n[   27.780500] Hardware name: Bananapi BPI-R64 (DT)\n[   27.785108] pstate: 60000005 (nZCv daif -PAN -UAO)\n[   27.789897] pc : mt7615_register_ext_phy+0x60/0x2c8 [mt7615_common]\n[   27.796156] lr : mt7615_init_debugfs+0x99c/0x18e0 [mt7615_common]\n[   27.802237] sp : ffffffc0115dbcb0\n[   27.805541] x29: ffffffc0115dbcb0 x28: ffffff803e309600\n[   27.810843] x27: 0000000000000000 x26: 0000000000000000\n[   27.816144] x25: ffffff803d936928 x24: ffffff803d936950\n[   27.821447] x23: 0000000000000000 x22: 0000000fffffffe0\n[   27.826749] x21: 0000000000000002 x20: ffffff8001e82620\n[   27.832050] x19: 0000000000000000 x18: 0000000000000000\n[   27.837352] x17: 0000000000000000 x16: 0000000000000000\n[   27.842653] x15: 0000000000000000 x14: 0000000000000000\n[   27.847955] x13: 0000000000000000 x12: 0000000000000000\n[   27.853256] x11: 0000000000000000 x10: 0000000000000040\n[   27.858558] x9 : ffffffc0112b3eb0 x8 : ffffffc0112b3ea8\n[   27.863859] x7 : ffffff803e400048 x6 : 0000000000000000\n[   27.869161] x5 : ffffff803e400000 x4 : 0000000000000000\n[   27.874462] x3 : 0000000000000001 x2 : 0000000000007615\n[   27.879764] x1 : 0000000000000068 x0 : ffffffc0088ccc58\n[   27.885066] Call trace:\n[   27.887505]  mt7615_register_ext_phy+0x60/0x2c8 [mt7615_common]\n[   27.893416]  mt7615_init_debugfs+0x99c/0x18e0 [mt7615_common]\n[   27.899156]  simple_attr_write+0xf0/0x178\n[   27.903158]  debugfs_attr_write+0x4c/0x70\n[   27.907159]  full_proxy_write+0x60/0x90\n[   27.910987]  __vfs_write+0x18/0x40\n[   27.914379]  vfs_write+0xb0/0x1b8\n[   27.917685]  ksys_write+0x4c/0xc8\n[   27.920989]  __arm64_sys_write+0x18/0x20\n\nSigned-off-by: Lorenzo Bianconi <lorenzo@kernel.org>\nSigned-off-by: Felix Fietkau <nbd@nbd.name>",
        "before_after_code_files": [
          "drivers/net/wireless/mediatek/mt76/mt7615/init.c||drivers/net/wireless/mediatek/mt76/mt7615/init.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/wireless/mediatek/mt76/mt7615/init.c||drivers/net/wireless/mediatek/mt76/mt7615/init.c": [
          "File: drivers/net/wireless/mediatek/mt76/mt7615/init.c -> drivers/net/wireless/mediatek/mt76/mt7615/init.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "372:  if (phy)",
          "373:   return 0;",
          "384:  mt7615_cap_dbdc_enable(dev);",
          "385:  mphy = mt76_alloc_phy(&dev->mt76, sizeof(*phy), &mt7615_ops);",
          "386:  if (!mphy)",
          "",
          "[Removed Lines]",
          "375:  INIT_DELAYED_WORK(&phy->mac_work, mt7615_mac_work);",
          "376:  INIT_DELAYED_WORK(&phy->scan_work, mt7615_scan_work);",
          "377:  skb_queue_head_init(&phy->scan_event_list);",
          "379:  INIT_WORK(&phy->ps_work, mt7615_ps_work);",
          "380:  INIT_WORK(&phy->roc_work, mt7615_roc_work);",
          "381:  timer_setup(&phy->roc_timer, mt7615_roc_timer, 0);",
          "382:  init_waitqueue_head(&phy->roc_wait);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "393:  mphy->antenna_mask = BIT(hweight8(phy->chainmask)) - 1;",
          "394:  mt7615_init_wiphy(mphy->hw);",
          "396:  mt7615_mac_set_scs(phy, true);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "387:  INIT_DELAYED_WORK(&phy->mac_work, mt7615_mac_work);",
          "388:  INIT_DELAYED_WORK(&phy->scan_work, mt7615_scan_work);",
          "389:  skb_queue_head_init(&phy->scan_event_list);",
          "391:  INIT_WORK(&phy->ps_work, mt7615_ps_work);",
          "392:  INIT_WORK(&phy->roc_work, mt7615_roc_work);",
          "393:  timer_setup(&phy->roc_timer, mt7615_roc_timer, 0);",
          "394:  init_waitqueue_head(&phy->roc_wait);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
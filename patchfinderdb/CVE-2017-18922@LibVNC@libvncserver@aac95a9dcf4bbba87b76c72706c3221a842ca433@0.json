{
  "cve_id": "CVE-2017-18922",
  "cve_desc": "It was discovered that websockets.c in LibVNCServer prior to 0.9.12 did not properly decode certain WebSocket frames. A malicious attacker could exploit this by sending specially crafted WebSocket frames to a server, causing a heap-based buffer overflow.",
  "repo": "LibVNC/libvncserver",
  "patch_hash": "aac95a9dcf4bbba87b76c72706c3221a842ca433",
  "patch_info": {
    "commit_hash": "aac95a9dcf4bbba87b76c72706c3221a842ca433",
    "repo": "LibVNC/libvncserver",
    "commit_url": "https://github.com/LibVNC/libvncserver/commit/aac95a9dcf4bbba87b76c72706c3221a842ca433",
    "files": [
      "libvncserver/websockets.c"
    ],
    "message": "fix overflow and refactor websockets decode (Hybi)\n\nfix critical heap-based buffer overflow which allowed easy modification\nof a return address via an overwritten function pointer\n\nfix bug causing connections to fail due a \"one websocket frame = one\nws_read\" assumption, which failed with LibVNCServer-0.9.11\n\nrefactor websocket Hybi decode to use a simple state machine for\ndecoding of websocket frames",
    "before_after_code_files": [
      "libvncserver/websockets.c||libvncserver/websockets.c"
    ]
  },
  "patch_diff": {
    "libvncserver/websockets.c||libvncserver/websockets.c": [
      "File: libvncserver/websockets.c -> libvncserver/websockets.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "78: #define B64LEN(__x) (((__x + 2) / 3) * 12 / 3)",
      "81: enum {",
      "82:   WEBSOCKETS_VERSION_HIXIE,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "80: #define WS_HYBI_MASK_LEN 4",
      "82: #define ARRAYSIZE(a) ((sizeof(a) / sizeof((a[0]))) / (size_t)(!(sizeof(a) % sizeof((a[0])))))",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "93: typedef int (*wsEncodeFunc)(rfbClientPtr cl, const char *src, int len, char **dst);",
      "94: typedef int (*wsDecodeFunc)(rfbClientPtr cl, char *dst, int len);",
      "111: typedef union ws_mask_s {",
      "112:   char c[4];",
      "",
      "[Removed Lines]",
      "96: typedef struct ws_ctx_s {",
      "99:  char readbuf[8192];",
      "100:     int readbufstart;",
      "101:     int readbuflen;",
      "102:     int dblen;",
      "104:     int carrylen;",
      "105:     int version;",
      "106:     int base64;",
      "107:     wsEncodeFunc encode;",
      "108:     wsDecodeFunc decode;",
      "109: } ws_ctx_t;",
      "",
      "[Added Lines]",
      "100: enum {",
      "102:   WS_HYBI_STATE_HEADER_PENDING,",
      "104:   WS_HYBI_STATE_DATA_AVAILABLE,",
      "105:   WS_HYBI_STATE_DATA_NEEDED,",
      "107:   WS_HYBI_STATE_FRAME_COMPLETE,",
      "109:   WS_HYBI_STATE_CLOSE_REASON_PENDING,",
      "111:   WS_HYBI_STATE_ERR",
      "112: };",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "146:   } u;",
      "147: } ws_header_t;",
      "149: enum",
      "150: {",
      "151:     WS_OPCODE_CONTINUATION = 0x0,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "152: typedef struct ws_header_data_s {",
      "153:   ws_header_t *data;",
      "155:   int nRead;",
      "157:   ws_mask_t mask;",
      "159:   int headerLen;",
      "161:   int payloadLen;",
      "163:   unsigned char opcode;",
      "164: } ws_header_data_t;",
      "166: typedef struct ws_ctx_s {",
      "169:     char *writePos;",
      "170:     unsigned char *readPos;",
      "171:     int readlen;",
      "172:     int hybiDecodeState;",
      "174:     int carrylen;",
      "175:     int version;",
      "176:     int base64;",
      "177:     ws_header_data_t header;",
      "178:     int nReadRaw;",
      "179:     int nToRead;",
      "180:     wsEncodeFunc encode;",
      "181:     wsDecodeFunc decode;",
      "182: } ws_ctx_t;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "206: static int webSocketsDecodeHybi(rfbClientPtr cl, char *dst, int len);",
      "207: static int webSocketsDecodeHixie(rfbClientPtr cl, char *dst, int len);",
      "209: static int",
      "210: min (int a, int b) {",
      "211:     return a < b ? a : b;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "244: static void hybiDecodeCleanup(ws_ctx_t *wsctx);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "467:  wsctx->decode = webSocketsDecodeHixie;",
      "468:     }",
      "469:     wsctx->base64 = base64;",
      "470:     cl->wsctx = (wsCtx *)wsctx;",
      "471:     return TRUE;",
      "472: }",
      "474: void",
      "475: webSocketsGenMd5(char * target, char *key1, char *key2, char *key3)",
      "476: {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "507:     hybiDecodeCleanup(wsctx);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "662: }",
      "664: static int",
      "666: {",
      "688:       } else {",
      "693:       }",
      "695:     }",
      "714:     }",
      "755:       int olderrno = errno;",
      "756:       rfbErr(\"%s: read; %m\", __func__);",
      "757:       errno = olderrno;",
      "764:     }",
      "770:     }",
      "798:       default:",
      "800:     }",
      "803: spor:",
      "805:     return result;",
      "806: }",
      "",
      "[Removed Lines]",
      "665: webSocketsDecodeHybi(rfbClientPtr cl, char *dst, int len)",
      "667:     char *buf, *payload;",
      "668:     uint32_t *payload32;",
      "669:     int ret = -1, result = -1;",
      "670:     int total = 0;",
      "671:     ws_mask_t mask;",
      "672:     ws_header_t *header;",
      "673:     int i;",
      "674:     unsigned char opcode;",
      "675:     ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;",
      "676:     int flength, fhlen;",
      "681:     if (wsctx->readbuflen) {",
      "683:       if (wsctx->readbuflen > len) {",
      "684:  memcpy(dst, wsctx->readbuf +  wsctx->readbufstart, len);",
      "685:  result = len;",
      "686:  wsctx->readbuflen -= len;",
      "687:  wsctx->readbufstart += len;",
      "689:  memcpy(dst, wsctx->readbuf +  wsctx->readbufstart, wsctx->readbuflen);",
      "690:  result = wsctx->readbuflen;",
      "691:  wsctx->readbuflen = 0;",
      "692:  wsctx->readbufstart = 0;",
      "694:       goto spor;",
      "697:     buf = wsctx->codeBufDecode;",
      "698:     header = (ws_header_t *)wsctx->codeBufDecode;",
      "700:     ret = ws_peek(cl, buf, B64LEN(len) + WSHLENMAX);",
      "702:     if (ret < 2) {",
      "704:         if (-1 == ret) {",
      "705:             int olderrno = errno;",
      "706:             rfbErr(\"%s: peek; %m\\n\", __func__);",
      "707:             errno = olderrno;",
      "708:         } else if (0 == ret) {",
      "709:             result = 0;",
      "710:         } else {",
      "711:             errno = EAGAIN;",
      "712:         }",
      "713:         goto spor;",
      "716:     opcode = header->b0 & 0x0f;",
      "718:     flength = header->b1 & 0x7f;",
      "726:     if (!(header->b1 & 0x80)) {",
      "727:  rfbErr(\"%s: got frame without mask\\n\", __func__, ret);",
      "728:  errno = EIO;",
      "729:  goto spor;",
      "730:     }",
      "732:     if (flength < 126) {",
      "733:  fhlen = 2;",
      "734:  mask = header->u.m;",
      "735:     } else if (flength == 126 && 4 <= ret) {",
      "736:  flength = WS_NTOH16(header->u.s16.l16);",
      "737:  fhlen = 4;",
      "738:  mask = header->u.s16.m16;",
      "739:     } else if (flength == 127 && 10 <= ret) {",
      "740:  flength = WS_NTOH64(header->u.s64.l64);",
      "741:  fhlen = 10;",
      "742:  mask = header->u.s64.m64;",
      "743:     } else {",
      "745:       rfbErr(\"%s: incomplete frame header\\n\", __func__, ret);",
      "746:       errno = EIO;",
      "747:       goto spor;",
      "748:     }",
      "751:     total = fhlen + flength + 4;",
      "754:     if (-1 == (ret = ws_read(cl, buf, total))) {",
      "758:       return ret;",
      "759:     } else if (ret < total) {",
      "761:       rfbLog(\"%s: read; got partial data\\n\", __func__);",
      "762:     } else {",
      "763:       buf[ret] = '\\0';",
      "767:     payload32 = (uint32_t *)payload;",
      "768:     for (i = 0; i < flength / 4; i++) {",
      "769:  payload32[i] ^= mask.u;",
      "772:     for (i*=4; i < flength; i++) {",
      "773:  payload[i] ^= mask.c[i % 4];",
      "774:     }",
      "776:     switch (opcode) {",
      "777:       case WS_OPCODE_CLOSE:",
      "778:  rfbLog(\"got closure, reason %d\\n\", WS_NTOH16(((uint16_t *)payload)[0]));",
      "779:  errno = ECONNRESET;",
      "780:  break;",
      "781:       case WS_OPCODE_TEXT_FRAME:",
      "782:  if (-1 == (flength = b64_pton(payload, (unsigned char *)wsctx->codeBufDecode, sizeof(wsctx->codeBufDecode)))) {",
      "783:    rfbErr(\"%s: Base64 decode error; %m\\n\", __func__);",
      "784:    break;",
      "785:  }",
      "786:  payload = wsctx->codeBufDecode;",
      "788:       case WS_OPCODE_BINARY_FRAME:",
      "789:  if (flength > len) {",
      "790:    memcpy(wsctx->readbuf, payload + len, flength - len);",
      "791:    wsctx->readbufstart = 0;",
      "792:    wsctx->readbuflen = flength - len;",
      "793:    flength = len;",
      "794:  }",
      "795:  memcpy(dst, payload, flength);",
      "796:  result = flength;",
      "797:  break;",
      "799:  rfbErr(\"%s: unhandled opcode %d, b0: %02x, b1: %02x\\n\", __func__, (int)opcode, header->b0, header->b1);",
      "",
      "[Added Lines]",
      "703: hybiRemaining(ws_ctx_t *wsctx)",
      "705:   return wsctx->nToRead - wsctx->nReadRaw;",
      "706: }",
      "708: static void",
      "709: hybiDecodeCleanup(ws_ctx_t *wsctx)",
      "710: {",
      "711:   wsctx->header.payloadLen = 0;",
      "712:   wsctx->header.mask.u = 0;",
      "713:   wsctx->nReadRaw = 0;",
      "714:   wsctx->nToRead= 0;",
      "715:   wsctx->carrylen = 0;",
      "716:   wsctx->readPos = (unsigned char *)wsctx->codeBufDecode;",
      "717:   wsctx->readlen = 0;",
      "718:   wsctx->hybiDecodeState = WS_HYBI_STATE_HEADER_PENDING;",
      "719:   wsctx->writePos = NULL;",
      "720:   rfbLog(\"cleaned up wsctx\\n\");",
      "721: }",
      "733: static int",
      "734: hybiReturnData(char *dst, int len, ws_ctx_t *wsctx, int *nWritten)",
      "735: {",
      "736:   int nextState = WS_HYBI_STATE_ERR;",
      "739:   if (wsctx->readlen > 0) {",
      "741:     if (wsctx->readlen > len) {",
      "742:       rfbLog(\"copy to %d bytes to dst buffer; readPos=%p, readLen=%d\\n\", len, wsctx->readPos, wsctx->readlen);",
      "743:       memcpy(dst, wsctx->readPos, len);",
      "745:       wsctx->readlen -= len;",
      "746:       wsctx->readPos += len;",
      "747:       nextState = WS_HYBI_STATE_DATA_AVAILABLE;",
      "748:     } else {",
      "749:       rfbLog(\"copy to %d bytes to dst buffer; readPos=%p, readLen=%d\\n\", wsctx->readlen, wsctx->readPos, wsctx->readlen);",
      "750:       memcpy(dst, wsctx->readPos, wsctx->readlen);",
      "752:       wsctx->readlen = 0;",
      "753:       wsctx->readPos = NULL;",
      "754:       if (hybiRemaining(wsctx) == 0) {",
      "755:         nextState = WS_HYBI_STATE_FRAME_COMPLETE;",
      "757:         nextState = WS_HYBI_STATE_DATA_NEEDED;",
      "760:     rfbLog(\"after copy: readPos=%p, readLen=%d\\n\", wsctx->readPos, wsctx->readlen);",
      "761:   } else if (wsctx->hybiDecodeState == WS_HYBI_STATE_CLOSE_REASON_PENDING) {",
      "762:     nextState = WS_HYBI_STATE_CLOSE_REASON_PENDING;",
      "763:   }",
      "764:   return nextState;",
      "765: }",
      "778: static int",
      "779: hybiReadHeader(rfbClientPtr cl, int *sockRet)",
      "780: {",
      "781:   int ret;",
      "782:   ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;",
      "783:   char *headerDst = wsctx->codeBufDecode + wsctx->nReadRaw;",
      "784:   int n = WSHLENMAX - wsctx->nReadRaw;",
      "786:   rfbLog(\"header_read to %p with len=%d\\n\", headerDst, n);",
      "787:   ret = ws_read(cl, headerDst, n);",
      "788:   rfbLog(\"read %d bytes from socket\\n\", ret);",
      "789:   if (ret <= 0) {",
      "790:     if (-1 == ret) {",
      "792:       int olderrno = errno;",
      "793:       rfbErr(\"%s: peek; %m\\n\", __func__);",
      "794:       errno = olderrno;",
      "796:     } else {",
      "799:     return WS_HYBI_STATE_ERR;",
      "800:   }",
      "802:   wsctx->nReadRaw += ret;",
      "803:   if (wsctx->nReadRaw < 2) {",
      "805:     errno = EAGAIN;",
      "807:     return WS_HYBI_STATE_HEADER_PENDING;",
      "808:   }",
      "811:   wsctx->header.data = (ws_header_t *)wsctx->codeBufDecode;",
      "813:   wsctx->header.opcode = wsctx->header.data->b0 & 0x0f;",
      "816:   wsctx->header.payloadLen = wsctx->header.data->b1 & 0x7f;",
      "817:   rfbLog(\"first header bytes received; opcode=%d lenbyte=%d\\n\", wsctx->header.opcode, wsctx->header.payloadLen);",
      "825:   if (!(wsctx->header.data->b1 & 0x80)) {",
      "826:     rfbErr(\"%s: got frame without mask ret=%d\\n\", __func__, ret);",
      "827:     errno = EIO;",
      "829:     return WS_HYBI_STATE_ERR;",
      "830:   }",
      "832:   if (wsctx->header.payloadLen < 126 && wsctx->nReadRaw >= 6) {",
      "833:     wsctx->header.headerLen = 2 + WS_HYBI_MASK_LEN;",
      "834:     wsctx->header.mask = wsctx->header.data->u.m;",
      "835:   } else if (wsctx->header.payloadLen == 126 && 8 <= wsctx->nReadRaw) {",
      "836:     wsctx->header.headerLen = 4 + WS_HYBI_MASK_LEN;",
      "837:     wsctx->header.payloadLen = WS_NTOH16(wsctx->header.data->u.s16.l16);",
      "838:     wsctx->header.mask = wsctx->header.data->u.s16.m16;",
      "839:   } else if (wsctx->header.payloadLen == 127 && 14 <= wsctx->nReadRaw) {",
      "840:     wsctx->header.headerLen = 10 + WS_HYBI_MASK_LEN;",
      "841:     wsctx->header.payloadLen = WS_NTOH64(wsctx->header.data->u.s64.l64);",
      "842:     wsctx->header.mask = wsctx->header.data->u.s64.m64;",
      "843:   } else {",
      "845:     rfbErr(\"%s: incomplete frame header; ret=%d\\n\", __func__, ret);",
      "846:     errno = EAGAIN;",
      "848:     return WS_HYBI_STATE_HEADER_PENDING;",
      "849:   }",
      "852:   wsctx->nToRead = wsctx->header.headerLen + wsctx->header.payloadLen;",
      "855:   wsctx->writePos = wsctx->codeBufDecode + wsctx->nReadRaw;",
      "857:   wsctx->readPos = (unsigned char *)(wsctx->codeBufDecode + wsctx->header.headerLen);",
      "859:   rfbLog(\"header complete: state=%d flen=%d writeTo=%p\\n\", wsctx->hybiDecodeState, wsctx->nToRead, wsctx->writePos);",
      "861:   return WS_HYBI_STATE_DATA_NEEDED;",
      "862: }",
      "864: static int",
      "865: hybiWsFrameComplete(ws_ctx_t *wsctx)",
      "866: {",
      "867:   return wsctx != NULL && hybiRemaining(wsctx) == 0;",
      "868: }",
      "870: static char *",
      "871: hybiPayloadStart(ws_ctx_t *wsctx)",
      "872: {",
      "873:   return wsctx->codeBufDecode + wsctx->header.headerLen;",
      "874: }",
      "900: static int",
      "901: hybiReadAndDecode(rfbClientPtr cl, char *dst, int len, int *sockRet)",
      "902: {",
      "903:   int n;",
      "904:   int i;",
      "905:   int toReturn;",
      "906:   int toDecode;",
      "907:   int bufsize;",
      "908:   int nextRead;",
      "909:   unsigned char *data;",
      "910:   uint32_t *data32;",
      "911:   ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;",
      "914:   memcpy(wsctx->writePos, wsctx->carryBuf, wsctx->carrylen);",
      "915:   wsctx->writePos += wsctx->carrylen;",
      "918:   bufsize = wsctx->codeBufDecode + ARRAYSIZE(wsctx->codeBufDecode) - wsctx->writePos - 1;",
      "919:   if (hybiRemaining(wsctx) > bufsize) {",
      "920:     nextRead = bufsize;",
      "921:   } else {",
      "922:     nextRead = hybiRemaining(wsctx);",
      "923:   }",
      "925:   rfbLog(\"calling read with buf=%p and len=%d (decodebuf=%p headerLen=%d\\n)\", wsctx->writePos, nextRead, wsctx->codeBufDecode, wsctx->header.headerLen);",
      "927:   if (wsctx->nReadRaw < wsctx->nToRead) {",
      "929:     if (-1 == (n = ws_read(cl, wsctx->writePos, nextRead))) {",
      "934:       return WS_HYBI_STATE_ERR;",
      "935:     } else if (n == 0) {",
      "937:       return WS_HYBI_STATE_ERR;",
      "939:     wsctx->nReadRaw += n;",
      "940:     rfbLog(\"read %d bytes from socket; nRead=%d\\n\", n, wsctx->nReadRaw);",
      "941:   } else {",
      "942:     n = 0;",
      "943:   }",
      "945:   wsctx->writePos += n;",
      "947:   if (wsctx->nReadRaw >= wsctx->nToRead) {",
      "948:     if (wsctx->nReadRaw > wsctx->nToRead) {",
      "949:       rfbErr(\"%s: internal error, read past websocket frame\", __func__);",
      "950:       errno=EIO;",
      "952:       return WS_HYBI_STATE_ERR;",
      "954:   }",
      "956:   toDecode = wsctx->writePos - hybiPayloadStart(wsctx);",
      "957:   rfbLog(\"toDecode=%d from n=%d carrylen=%d headerLen=%d\\n\", toDecode, n, wsctx->carrylen, wsctx->header.headerLen);",
      "958:   if (toDecode < 0) {",
      "959:     rfbErr(\"%s: internal error; negative number of bytes to decode: %d\", __func__, toDecode);",
      "960:     errno=EIO;",
      "962:     return WS_HYBI_STATE_ERR;",
      "963:   }",
      "967:   data = (unsigned char *)hybiPayloadStart(wsctx);",
      "968:   data32= (uint32_t *)data;",
      "970:   for (i = 0; i < (toDecode >> 2); i++) {",
      "971:     data32[i] ^= wsctx->header.mask.u;",
      "972:   }",
      "973:   rfbLog(\"mask decoding; i=%d toDecode=%d\\n\", i, toDecode);",
      "975:   if (wsctx->hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE) {",
      "977:     for (i*=4; i < toDecode; i++) {",
      "978:       data[i] ^= wsctx->header.mask.c[i % 4];",
      "979:     }",
      "982:     wsctx->carrylen = 0;",
      "983:   } else {",
      "985:     wsctx->carrylen = toDecode - (i * 4);",
      "986:     if (wsctx->carrylen < 0 || wsctx->carrylen > ARRAYSIZE(wsctx->carryBuf)) {",
      "987:       rfbErr(\"%s: internal error, invalid carry over size: carrylen=%d, toDecode=%d, i=%d\", __func__, wsctx->carrylen, toDecode, i);",
      "989:       errno = EIO;",
      "990:       return WS_HYBI_STATE_ERR;",
      "991:     }",
      "992:     rfbLog(\"carrying over %d bytes from %p to %p\\n\", wsctx->carrylen, wsctx->writePos + (i * 4), wsctx->carryBuf);",
      "993:     memcpy(wsctx->carryBuf, data + (i * 4), wsctx->carrylen);",
      "994:   }",
      "996:   toReturn = toDecode - wsctx->carrylen;",
      "998:   switch (wsctx->header.opcode) {",
      "999:     case WS_OPCODE_CLOSE:",
      "1002:       if (hybiWsFrameComplete(wsctx)) {",
      "1003:         rfbLog(\"got closure, reason %d\\n\", WS_NTOH16(((uint16_t *)data)[0]));",
      "1004:         errno = ECONNRESET;",
      "1006:         return WS_HYBI_STATE_FRAME_COMPLETE;",
      "1007:       } else {",
      "1008:         rfbErr(\"%s: close reason with long frame not supported\", __func__);",
      "1009:         errno = EIO;",
      "1011:         return WS_HYBI_STATE_ERR;",
      "1012:       }",
      "1013:       break;",
      "1014:     case WS_OPCODE_TEXT_FRAME:",
      "1015:       data[toReturn] = '\\0';",
      "1016:       rfbLog(\"Initiate Base64 decoding in %p with max size %d and '\\\\0' at %p\\n\", data, bufsize, data + toReturn);",
      "1017:       if (-1 == (wsctx->readlen = b64_pton((char *)data, data, bufsize))) {",
      "1018:         rfbErr(\"Base64 decode error in %s; data=%p bufsize=%d\", __func__, data, bufsize);",
      "1019:         rfbErr(\"%s: Base64 decode error; %m\\n\", __func__);",
      "1020:       }",
      "1021:       wsctx->writePos = hybiPayloadStart(wsctx);",
      "1022:       break;",
      "1023:     case WS_OPCODE_BINARY_FRAME:",
      "1024:       wsctx->readlen = toReturn;",
      "1025:       wsctx->writePos = hybiPayloadStart(wsctx);",
      "1026:       break;",
      "1027:     default:",
      "1028:       rfbErr(\"%s: unhandled opcode %d, b0: %02x, b1: %02x\\n\", __func__, (int)wsctx->header.opcode, wsctx->header.data->b0, wsctx->header.data->b1);",
      "1029:   }",
      "1030:   wsctx->readPos = data;",
      "1032:   return hybiReturnData(dst, len, wsctx, sockRet);",
      "1033: }",
      "1066: static int",
      "1067: webSocketsDecodeHybi(rfbClientPtr cl, char *dst, int len)",
      "1068: {",
      "1069:     int result = -1;",
      "1070:     ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;",
      "1074:     rfbLog(\"%s_enter: len=%d; \"",
      "1075:                       \"CTX: readlen=%d readPos=%p \"",
      "1076:                       \"writeTo=%p \"",
      "1077:                       \"state=%d toRead=%d remaining=%d \"",
      "1078:                       \" nReadRaw=%d carrylen=%d carryBuf=%p\\n\",",
      "1079:                       __func__, len,",
      "1080:                       wsctx->readlen, wsctx->readPos,",
      "1081:                       wsctx->writePos,",
      "1082:                       wsctx->hybiDecodeState, wsctx->nToRead, hybiRemaining(wsctx),",
      "1083:                       wsctx->nReadRaw, wsctx->carrylen, wsctx->carryBuf);",
      "1085:     switch (wsctx->hybiDecodeState){",
      "1086:       case WS_HYBI_STATE_HEADER_PENDING:",
      "1087:         wsctx->hybiDecodeState = hybiReadHeader(cl, &result);",
      "1088:         if (wsctx->hybiDecodeState == WS_HYBI_STATE_ERR) {",
      "1089:           goto spor;",
      "1090:         }",
      "1091:         if (wsctx->hybiDecodeState != WS_HYBI_STATE_HEADER_PENDING) {",
      "1094:           wsctx->hybiDecodeState = hybiReadAndDecode(cl, dst, len, &result);",
      "1095:         }",
      "1096:         break;",
      "1097:       case WS_HYBI_STATE_DATA_AVAILABLE:",
      "1098:         wsctx->hybiDecodeState = hybiReturnData(dst, len, wsctx, &result);",
      "1099:         break;",
      "1100:       case WS_HYBI_STATE_DATA_NEEDED:",
      "1101:         wsctx->hybiDecodeState = hybiReadAndDecode(cl, dst, len, &result);",
      "1102:         break;",
      "1103:       case WS_HYBI_STATE_CLOSE_REASON_PENDING:",
      "1104:         wsctx->hybiDecodeState = hybiReadAndDecode(cl, dst, len, &result);",
      "1105:         break;",
      "1108:         rfbErr(\"%s: called with invalid state %d\\n\", wsctx->hybiDecodeState);",
      "1109:         result = -1;",
      "1110:         errno = EIO;",
      "1111:         wsctx->hybiDecodeState = WS_HYBI_STATE_ERR;",
      "1117:     if (wsctx->hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE) {",
      "1118:       rfbLog(\"frame received successfully, cleaning up: read=%d hlen=%d plen=%d\\n\", wsctx->header.nRead, wsctx->header.headerLen, wsctx->header.payloadLen);",
      "1120:       hybiDecodeCleanup(wsctx);",
      "1121:     } else if (wsctx->hybiDecodeState == WS_HYBI_STATE_ERR) {",
      "1122:       hybiDecodeCleanup(wsctx);",
      "1123:     }",
      "1124:     rfbLog(\"%s_exit: len=%d; \"",
      "1125:                       \"CTX: readlen=%d readPos=%p \"",
      "1126:                       \"writePos=%p \"",
      "1127:                       \"state=%d toRead=%d remaining=%d \"",
      "1128:                       \"nRead=%d carrylen=%d carryBuf=%p \"",
      "1129:                       \"result=%d\\n\",",
      "1130:                       __func__, len,",
      "1131:                       wsctx->readlen, wsctx->readPos,",
      "1132:                       wsctx->writePos,",
      "1133:                       wsctx->hybiDecodeState, wsctx->nToRead, hybiRemaining(wsctx),",
      "1134:                       wsctx->nReadRaw, wsctx->carrylen, wsctx->carryBuf,",
      "1135:                       result);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "951: {",
      "952:     ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;",
      "955:       return TRUE;",
      "957:     return (cl->sslctx && rfbssl_pending(cl) > 0);",
      "",
      "[Removed Lines]",
      "954:     if (wsctx && wsctx->readbuflen)",
      "",
      "[Added Lines]",
      "1285:     if (wsctx && wsctx->readlen)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5d9d6a87124a5439d3432c37a67f9b2babe04407",
      "candidate_info": {
        "commit_hash": "5d9d6a87124a5439d3432c37a67f9b2babe04407",
        "repo": "LibVNC/libvncserver",
        "commit_url": "https://github.com/LibVNC/libvncserver/commit/5d9d6a87124a5439d3432c37a67f9b2babe04407",
        "files": [
          "libvncserver/websockets.c",
          "libvncserver/ws_decode.c",
          "libvncserver/ws_decode.h",
          "test/wsmaketestframe.py",
          "test/wstest.c",
          "test/wstestdata.inc"
        ],
        "message": "add decode support for continuation frames\n\nuse FIN bit and implement opcode 0x00\n\nmake consistent use of uint64_t for big frame sizes",
        "before_after_code_files": [
          "libvncserver/websockets.c||libvncserver/websockets.c",
          "libvncserver/ws_decode.c||libvncserver/ws_decode.c",
          "libvncserver/ws_decode.h||libvncserver/ws_decode.h",
          "test/wsmaketestframe.py||test/wsmaketestframe.py",
          "test/wstest.c||test/wstest.c",
          "test/wstestdata.inc||test/wstestdata.inc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libvncserver/websockets.c||libvncserver/websockets.c"
          ],
          "candidate": [
            "libvncserver/websockets.c||libvncserver/websockets.c"
          ]
        }
      },
      "candidate_diff": {
        "libvncserver/websockets.c||libvncserver/websockets.c": [
          "File: libvncserver/websockets.c -> libvncserver/websockets.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "339:     free(buf);",
          "341:     wsctx = calloc(1, sizeof(ws_ctx_t));",
          "343:     wsctx->encode = webSocketsEncodeHybi;",
          "344:     wsctx->decode = webSocketsDecodeHybi;",
          "345:     wsctx->ctxInfo.readFunc = ws_read;",
          "346:     wsctx->base64 = base64;",
          "348:     cl->wsctx = (wsCtx *)wsctx;",
          "349:     return TRUE;",
          "350: }",
          "",
          "[Removed Lines]",
          "342:     wsctx->version = WEBSOCKETS_VERSION_HYBI;",
          "347:     hybiDecodeCleanup(wsctx);",
          "",
          "[Added Lines]",
          "346:     hybiDecodeCleanupComplete(wsctx);",
          "",
          "---------------"
        ],
        "libvncserver/ws_decode.c||libvncserver/ws_decode.c": [
          "File: libvncserver/ws_decode.c -> libvncserver/ws_decode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #define WS_HYBI_HEADER_LEN_EXTENDED 4 + WS_HYBI_MASK_LEN",
          "9: #define WS_HYBI_HEADER_LEN_LONG 10 + WS_HYBI_MASK_LEN",
          "12: hybiRemaining(ws_ctx_t *wsctx)",
          "13: {",
          "14:   return wsctx->nToRead - wsctx->nReadRaw;",
          "15: }",
          "19: {",
          "20:   wsctx->header.payloadLen = 0;",
          "21:   wsctx->header.mask.u = 0;",
          "22:   wsctx->nReadRaw = 0;",
          "23:   wsctx->nToRead= 0;",
          "24:   wsctx->carrylen = 0;",
          "",
          "[Removed Lines]",
          "11: static int",
          "17: void",
          "18: hybiDecodeCleanup(ws_ctx_t *wsctx)",
          "",
          "[Added Lines]",
          "11: static inline int",
          "12: isControlFrame(ws_ctx_t *wsctx)",
          "13: {",
          "14:   return 0 != (wsctx->header.opcode & 0x08);",
          "15: }",
          "17: static uint64_t",
          "23: static void",
          "24: hybiDecodeCleanupBasics(ws_ctx_t *wsctx)",
          "27:   wsctx->header.opcode = WS_OPCODE_INVALID;",
          "30:   wsctx->header.headerLen = 0;",
          "31:   wsctx->header.data = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "26:   wsctx->readlen = 0;",
          "27:   wsctx->hybiDecodeState = WS_HYBI_STATE_HEADER_PENDING;",
          "28:   wsctx->writePos = NULL;",
          "30: }",
          "",
          "[Removed Lines]",
          "29:   rfbLog(\"cleaned up wsctx\\n\");",
          "",
          "[Added Lines]",
          "41: static void",
          "42: hybiDecodeCleanupForContinuation(ws_ctx_t *wsctx)",
          "43: {",
          "44:   hybiDecodeCleanupBasics(wsctx);",
          "45:   rfbLog(\"clean up frame, but expect continuation with opcode %d\\n\", wsctx->continuation_opcode);",
          "46: }",
          "48: void",
          "49: hybiDecodeCleanupComplete(ws_ctx_t *wsctx)",
          "50: {",
          "51:   hybiDecodeCleanupBasics(wsctx);",
          "52:   wsctx->continuation_opcode = WS_OPCODE_INVALID;",
          "53:   rfbLog(\"cleaned up wsctx completely\\n\");",
          "54: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "94: {",
          "95:   int ret;",
          "96:   char *headerDst = wsctx->codeBufDecode + wsctx->nReadRaw;",
          "99:   rfbLog(\"header_read to %p with len=%d\\n\", headerDst, n);",
          "101:   ret = wsctx->ctxInfo.readFunc(wsctx->ctxInfo.ctxPtr, headerDst, n);",
          "102:   rfbLog(\"read %d bytes from socket\\n\", ret);",
          "103:   if (ret <= 0) {",
          "",
          "[Removed Lines]",
          "97:   int n = WSHLENMAX - wsctx->nReadRaw;",
          "",
          "[Added Lines]",
          "122:   int n = ((uint64_t)WSHLENMAX) - wsctx->nReadRaw;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "106:       int olderrno = errno;",
          "107:       rfbErr(\"%s: read; %s\\n\", __func__, strerror(errno));",
          "108:       errno = olderrno;",
          "110:     } else {",
          "112:     }",
          "114:   }",
          "116:   wsctx->nReadRaw += ret;",
          "117:   if (wsctx->nReadRaw < 2) {",
          "122:   }",
          "125:   wsctx->header.data = (ws_header_t *)wsctx->codeBufDecode;",
          "127:   wsctx->header.opcode = wsctx->header.data->b0 & 0x0f;",
          "",
          "[Removed Lines]",
          "113:     return WS_HYBI_STATE_ERR;",
          "119:     errno = EAGAIN;",
          "121:     return WS_HYBI_STATE_HEADER_PENDING;",
          "130:   wsctx->header.payloadLen = wsctx->header.data->b1 & 0x7f;",
          "131:   rfbLog(\"first header bytes received; opcode=%d lenbyte=%d\\n\", wsctx->header.opcode, wsctx->header.payloadLen);",
          "",
          "[Added Lines]",
          "133:       goto err_cleanup_state;",
          "136:       goto err_cleanup_state_sock_closed;",
          "143:     goto ret_header_pending;",
          "150:   wsctx->header.fin = (wsctx->header.data->b0 & 0x80) >> 7;",
          "151:   if (isControlFrame(wsctx)) {",
          "152:     rfbLog(\"is control frame\\n\");",
          "155:     if (wsctx->header.fin == 0) {",
          "161:       rfbErr(\"control frame with FIN bit cleared received, aborting\\n\");",
          "162:       errno = EPROTO;",
          "163:       goto err_cleanup_state;",
          "164:     }",
          "165:   } else {",
          "166:     rfbLog(\"not a control frame\\n\");",
          "168:     if (wsctx->header.opcode == WS_OPCODE_CONTINUATION) {",
          "169:       rfbLog(\"cont_frame\\n\");",
          "171:       if (wsctx->continuation_opcode == WS_OPCODE_INVALID) {",
          "172:         rfbErr(\"no continuation state\\n\");",
          "173:         errno = EPROTO;",
          "174:         goto err_cleanup_state;",
          "175:       }",
          "178:       wsctx->header.opcode = wsctx->continuation_opcode;",
          "179:       rfbLog(\"set opcode to continuation_opcode: %d\\n\", wsctx->header.opcode);",
          "180:     } else {",
          "181:       if (wsctx->header.fin == 0) {",
          "182:         wsctx->continuation_opcode = wsctx->header.opcode;",
          "183:       } else {",
          "184:         wsctx->continuation_opcode = WS_OPCODE_INVALID;",
          "185:       }",
          "186:       rfbLog(\"set continuation_opcode to %d\\n\", wsctx->continuation_opcode);",
          "187:     }",
          "188:   }",
          "190:   wsctx->header.payloadLen = (uint64_t)(wsctx->header.data->b1 & 0x7f);",
          "191:   rfbLog(\"first header bytes received; opcode=%d lenbyte=%d fin=%d\\n\", wsctx->header.opcode, wsctx->header.payloadLen, wsctx->header.fin);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "139:   if (!(wsctx->header.data->b1 & 0x80)) {",
          "140:     rfbErr(\"%s: got frame without mask; ret=%d\\n\", __func__, ret);",
          "141:     errno = EPROTO;",
          "144:   }",
          "",
          "[Removed Lines]",
          "143:     return WS_HYBI_STATE_ERR;",
          "",
          "[Added Lines]",
          "202:     goto err_cleanup_state;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "158:   } else {",
          "160:     rfbErr(\"%s: incomplete frame header; ret=%d\\n\", __func__, ret);",
          "164:   }",
          "169:   if ((wsctx->header.headerLen > WS_HYBI_HEADER_LEN_SHORT",
          "171:       || (wsctx->header.headerLen > WS_HYBI_HEADER_LEN_EXTENDED",
          "173:     rfbErr(\"%s: invalid length field; headerLen=%d payloadLen=%llu\\n\", __func__, wsctx->header.headerLen, wsctx->header.payloadLen);",
          "174:     errno = EPROTO;",
          "177:   }",
          "",
          "[Removed Lines]",
          "161:     errno = EAGAIN;",
          "163:     return WS_HYBI_STATE_HEADER_PENDING;",
          "170:       && wsctx->header.payloadLen < 126)",
          "172:         && wsctx->header.payloadLen < 65536)) {",
          "176:     return WS_HYBI_STATE_ERR;",
          "",
          "[Added Lines]",
          "220:     goto ret_header_pending;",
          "223:   char *h = wsctx->codeBufDecode;",
          "224:   int i;",
          "225:   rfbLog(\"Header:\\n\");",
          "226:   for (i=0; i <10; i++) {",
          "227:     rfbLog(\"0x%02X\\n\", (unsigned char)h[i]);",
          "228:   }",
          "229:   rfbLog(\"\\n\");",
          "235:       && wsctx->header.payloadLen < (uint64_t)126)",
          "237:         && wsctx->header.payloadLen < (uint64_t)65536)) {",
          "240:     goto err_cleanup_state;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "186:   wsctx->readPos = (unsigned char *)(wsctx->codeBufDecode + wsctx->header.headerLen);",
          "191:   return WS_HYBI_STATE_DATA_NEEDED;",
          "192: }",
          "194: static int",
          "",
          "[Removed Lines]",
          "189:   rfbLog(\"header complete: state=%d flen=%d writeTo=%p nPayload=%d\\n\", wsctx->hybiDecodeState, wsctx->nToRead, wsctx->writePos, *nPayload);",
          "",
          "[Added Lines]",
          "253:   rfbLog(\"header complete: state=%d flen=%llu writeTo=%p nPayload=%d\\n\", wsctx->hybiDecodeState, wsctx->nToRead, wsctx->writePos, *nPayload);",
          "257: ret_header_pending:",
          "258:   errno = EAGAIN;",
          "260:   return WS_HYBI_STATE_HEADER_PENDING;",
          "262: err_cleanup_state:",
          "264: err_cleanup_state_sock_closed:",
          "265:   hybiDecodeCleanupComplete(wsctx);",
          "266:   return WS_HYBI_STATE_ERR;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "250:   bufsize = wsctx->codeBufDecode + ARRAYSIZE(wsctx->codeBufDecode) - wsctx->writePos - 1;",
          "251:   if (hybiRemaining(wsctx) > bufsize) {",
          "252:     nextRead = bufsize;",
          "253:   } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "326:   rfbLog(\"bufsize=%d\\n\", bufsize);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "454:     if (wsctx->hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE) {",
          "455:       rfbLog(\"frame received successfully, cleaning up: read=%d hlen=%d plen=%d\\n\", wsctx->header.nRead, wsctx->header.headerLen, wsctx->header.payloadLen);",
          "458:     } else if (wsctx->hybiDecodeState == WS_HYBI_STATE_ERR) {",
          "460:     }",
          "461:     rfbLog(\"%s_exit: len=%d; \"",
          "462:                       \"CTX: readlen=%d readPos=%p \"",
          "463:                       \"writePos=%p \"",
          "",
          "[Removed Lines]",
          "457:       hybiDecodeCleanup(wsctx);",
          "459:       hybiDecodeCleanup(wsctx);",
          "",
          "[Added Lines]",
          "532:       if (wsctx->header.fin && !isControlFrame(wsctx)) {",
          "534:         hybiDecodeCleanupComplete(wsctx);",
          "535:       } else {",
          "538:         hybiDecodeCleanupForContinuation(wsctx);",
          "539:       }",
          "541:       hybiDecodeCleanupComplete(wsctx);",
          "",
          "---------------"
        ],
        "libvncserver/ws_decode.h||libvncserver/ws_decode.h": [
          "File: libvncserver/ws_decode.h -> libvncserver/ws_decode.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: #endif",
          "29: #define B64LEN(__x) (((__x + 2) / 3) * 12 / 3)",
          "31: #define WS_HYBI_MASK_LEN 4",
          "33: #define ARRAYSIZE(a) ((sizeof(a) / sizeof((a[0]))) / (size_t)(!(sizeof(a) % sizeof((a[0])))))",
          "40: struct ws_ctx_s;",
          "41: typedef struct ws_ctx_s ws_ctx_t;",
          "",
          "[Removed Lines]",
          "35: enum {",
          "36:   WEBSOCKETS_VERSION_HIXIE,",
          "37:   WEBSOCKETS_VERSION_HYBI",
          "38: };",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "112:   int headerLen;",
          "116:   unsigned char opcode;",
          "117: } ws_header_data_t;",
          "119: typedef struct ws_ctx_s {",
          "",
          "[Removed Lines]",
          "114:   int payloadLen;",
          "",
          "[Added Lines]",
          "109:   uint64_t payloadLen;",
          "113:   unsigned char fin;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "125:     int hybiDecodeState;",
          "127:     int carrylen;",
          "129:     int base64;",
          "130:     ws_header_data_t header;",
          "133:     wsEncodeFunc encode;",
          "134:     wsDecodeFunc decode;",
          "135:     ctxInfo_t ctxInfo;",
          "",
          "[Removed Lines]",
          "128:     int version;",
          "131:     int nReadRaw;",
          "132:     int nToRead;",
          "",
          "[Added Lines]",
          "127:     uint64_t nReadRaw;",
          "128:     uint64_t nToRead;",
          "129:     unsigned char continuation_opcode;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "138: enum",
          "139: {",
          "146: };",
          "148: int webSocketsDecodeHybi(ws_ctx_t *wsctx, char *dst, int len);",
          "151: #endif",
          "",
          "[Removed Lines]",
          "140:     WS_OPCODE_CONTINUATION = 0x0,",
          "141:     WS_OPCODE_TEXT_FRAME,",
          "142:     WS_OPCODE_BINARY_FRAME,",
          "143:     WS_OPCODE_CLOSE = 0x8,",
          "144:     WS_OPCODE_PING,",
          "145:     WS_OPCODE_PONG",
          "150: void hybiDecodeCleanup(ws_ctx_t *wsctx);",
          "",
          "[Added Lines]",
          "137:     WS_OPCODE_CONTINUATION = 0x00,",
          "138:     WS_OPCODE_TEXT_FRAME = 0x01,",
          "139:     WS_OPCODE_BINARY_FRAME = 0x02,",
          "140:     WS_OPCODE_CLOSE = 0x08,",
          "141:     WS_OPCODE_PING = 0x09,",
          "142:     WS_OPCODE_PONG = 0x0A,",
          "143:     WS_OPCODE_INVALID = 0xFF",
          "148: void hybiDecodeCleanupComplete(ws_ctx_t *wsctx);",
          "",
          "---------------"
        ],
        "test/wsmaketestframe.py||test/wsmaketestframe.py": [
          "File: test/wsmaketestframe.py -> test/wsmaketestframe.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "44: class Testframe():",
          "46:         self.frame = frame",
          "47:         self.descr = descr",
          "48:         self.modify_bytes = modify_bytes",
          "49:         self.experrno = experrno",
          "51:         self.mask = mask",
          "53:     def to_carray_initializer(self, buf):",
          "",
          "[Removed Lines]",
          "45:     def __init__(self, frame, descr, modify_bytes={}, experrno=0, mask=True):",
          "50:         self.b64 = True if frame.opcode == 1 else False",
          "",
          "[Added Lines]",
          "45:     def __init__(self, frame, descr, modify_bytes={}, experrno=0, mask=True, opcode_overwrite=False):",
          "50:         self.b64 = True if frame.opcode == 1 or opcode_overwrite == 1 else False",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "110: ### invalid header values",
          "111: flist.append(Testframe(websockets.framing.Frame(1, 1, bytearray(\"Testit\", encoding=\"utf-8\")), \"Invalid frame: Wrong masking\", experrno=\"EPROTO\", mask=False))",
          "112: flist.append(Testframe(websockets.framing.Frame(1, 1, bytearray(\"..Lore Ipsum\", encoding=\"utf-8\")), \"Invalid frame: Length of < 126 with add. 16 bit len field\", experrno=\"EPROTO\", modify_bytes={ 1: 0xFE, 2: 0x00, 3: 0x0F}))",
          "115: s = \"struct ws_frame_test tests[] = {\\n\"",
          "116: for i in range(len(flist)):",
          "",
          "[Removed Lines]",
          "113: flist.append(Testframe(websockets.framing.Frame(1, 1, bytearray(\"........Lore Ipsum\", encoding=\"utf-8\")), \"Invalid frame: Length of < 126 with add. 64 bit len field\", experrno=\"EPROTO\", modify_bytes={ 1: 0xFF, 2: 0x00, 3: 0x00, 4: 0x00, 5: 0x00, 6: 0x80, 7: 0x40}))",
          "",
          "[Added Lines]",
          "113: flist.append(Testframe(websockets.framing.Frame(1, 1, bytearray(\"........Lore Ipsum\", encoding=\"utf-8\")), \"Invalid frame: Length of < 126 with add. 64 bit len field\", experrno=\"EPROTO\", modify_bytes={ 1: 0xFF, 2: 0x00, 3: 0x00, 4: 0x00, 5: 0x00, 6: 0x00, 7: 0x00, 8: 0x80, 9: 0x40}))",
          "115: frag1 = websockets.framing.Frame(0, 1, bytearray(\"This is a fragmented websocket...\", encoding=\"utf-8\"))",
          "116: frag2 = websockets.framing.Frame(0, 0, bytearray(\"... and it goes on...\", encoding=\"utf-8\"))",
          "117: frag3 = websockets.framing.Frame(1, 0, bytearray(\"and on and stop\", encoding=\"utf-8\"))",
          "118: flist.append(Testframe(frag1, \"Continuation test frag1\"))",
          "119: flist.append(Testframe(frag2, \"Continuation test frag2\", opcode_overwrite=1))",
          "120: flist.append(Testframe(frag3, \"Continuation test frag3\", opcode_overwrite=1))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "120:     s += \"\\n\"",
          "121: s += \"};\\n\"",
          "124:     cdatafile.write(s)",
          "",
          "[Removed Lines]",
          "123: with open(\"wstestdata.c\", \"w\") as cdatafile:",
          "",
          "[Added Lines]",
          "130: with open(\"wstestdata.inc\", \"w\") as cdatafile:",
          "",
          "---------------"
        ],
        "test/wstest.c||test/wstest.c": [
          "File: test/wstest.c -> test/wstest.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "98:   rfbLog(\"emu_read called with dst=%p and len=%lu\\n\", dst, len);",
          "99:   if (ft->simulate_sock_malfunction_at > 0 && ft->simulate_sock_malfunction_at == ft->i) {",
          "100:     rfbLog(\"simulating IO error with errno=%d\\n\", ft->errno_val);",
          "102:     return -1;",
          "103:   }",
          "106:   r = rand();",
          "107:   modu = (ft->frame + ft->frame_len) - ft->pos;",
          "",
          "[Removed Lines]",
          "101:     errno = ft->errno_val;",
          "",
          "[Added Lines]",
          "101:     errno = ft->errno_val;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "130:   while (nleft > 0) {",
          "131:     rfbLog(\"calling ws_decode with dst=%p, len=%lu\\n\", dst, nleft);",
          "132:     n = ctx->decode(ctx, dst, nleft);",
          "134:     if (n == 0) {",
          "135:       if (ft->close_sock_at > 0) {",
          "136:         return OK;",
          "",
          "[Removed Lines]",
          "133:     rfbLog(\"read n=%ld\\n\", n);",
          "",
          "[Added Lines]",
          "133:     rfbLog(\"read n=%ld\\n\", n);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "170: int main()",
          "172:   ws_ctx_t ctx;",
          "173:   int retall= 0;",
          "174:   int i;",
          "177:   for (i = 0; i < ARRAYSIZE(tests); i++) {",
          "178:     int ret;",
          "180:     el_pos = el_log;",
          "190:     ret = run_test(&tests[i], &ctx);",
          "191:     printf(\"%s: \\\"%s\\\"\\n\", ret == 0 ? \"PASS\" : \"FAIL\", tests[i].descr);",
          "",
          "[Removed Lines]",
          "171: {",
          "175:   srand(RND_SEED);",
          "181:     rfbLog = logtest;",
          "182:     rfbErr = logtest;",
          "184:     hybiDecodeCleanup(&ctx);",
          "185:     ctx.decode = webSocketsDecodeHybi;",
          "186:     ctx.version = WEBSOCKETS_VERSION_HYBI;",
          "188:     ctx.ctxInfo.readFunc = emu_read;",
          "",
          "[Added Lines]",
          "171: {",
          "175:   srand(RND_SEED);",
          "177:   hybiDecodeCleanupComplete(&ctx);",
          "178:   ctx.decode = webSocketsDecodeHybi;",
          "179:   ctx.ctxInfo.readFunc = emu_read;",
          "180:   rfbLog = logtest;",
          "181:   rfbErr = logtest;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "198:   return retall;",
          "199: }",
          "203: int main() {",
          "204:   return 0;",
          "",
          "[Removed Lines]",
          "201: #else",
          "",
          "[Added Lines]",
          "200: #else",
          "",
          "---------------"
        ],
        "test/wstestdata.inc||test/wstestdata.inc": [
          "File: test/wstestdata.inc -> test/wstestdata.inc",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: struct ws_frame_test tests[] = {",
          "2:  {",
          "4:   .expectedDecodeBuf={0X54,0X65,0X73,0X74,0X69,0X74},",
          "5:   .frame_len=14,",
          "6:   .raw_payload_len=6,",
          "",
          "[Removed Lines]",
          "3:   .frame={0X81,0X88,0XB7,0XDB,0X16,0X16,0XE1,0X9C,0X40,0X6C,0XD3,0X9C,0X7A,0X26},",
          "",
          "[Added Lines]",
          "3:   .frame={0X81,0X88,0X2F,0X2A,0X17,0X41,0X79,0X6D,0X41,0X3B,0X4B,0X6D,0X7B,0X71},",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "12:   .close_sock_at=0",
          "13:  },",
          "14:  {",
          "16:   .expectedDecodeBuf={0X46,0X72,0X61,0X6D,0X65,0X32,0X20,0X64,0X6F,0X65,0X73,0X20,0X63,0X6F,0X6E,0X74,0X61,0X69,0X6E,0X20,0X6D,0X75,0X63,0X68,0X20,0X6D,0X6F,0X72,0X65,0X20,0X74,0X65,0X78,0X74,0X20,0X61,0X6E,0X64,0X20,0X65,0X76,0X65,0X6E,0X20,0X67,0X6F,0X65,0X73,0X20,0X62,0X65,0X79,0X6F,0X6E,0X64,0X20,0X74,0X68,0X65,0X20,0X31,0X32,0X36,0X20,0X62,0X79,0X74,0X65,0X20,0X6C,0X65,0X6E,0X20,0X66,0X69,0X65,0X6C,0X64,0X2E,0X20,0X46,0X72,0X61,0X6D,0X65,0X32,0X20,0X64,0X6F,0X65,0X73,0X20,0X63,0X6F,0X6E,0X74,0X61,0X69,0X6E,0X20,0X6D,0X75,0X63,0X68,0X20,0X6D,0X6F,0X72,0X65,0X20,0X74,0X65,0X78,0X74,0X20,0X61,0X6E,0X64,0X20,0X65,0X76,0X65,0X6E,0X20,0X67,0X6F,0X65,0X73,0X20,0X62,0X65,0X79,0X6F,0X6E,0X64,0X20,0X74,0X68,0X65,0X20,0X31,0X32,0X36,0X20,0X62,0X79,0X74,0X65,0X20,0X6C,0X65,0X6E,0X20,0X66,0X69,0X65,0X6C,0X64,0X2E},",
          "17:   .frame_len=220,",
          "18:   .raw_payload_len=159,",
          "",
          "[Removed Lines]",
          "15:   .frame={0X81,0XFE,0X00,0XD4,0X67,0XFE,0X8A,0X31,0X35,0X90,0XC0,0X59,0X05,0XA9,0XDF,0X48,0X2E,0XB9,0XD8,0X47,0X3D,0XA6,0XC7,0X56,0X3E,0XCC,0XB3,0X44,0X03,0XB9,0XCC,0X41,0X05,0X97,0XC8,0X45,0X03,0XA9,0XC4,0X5E,0X2E,0XB9,0XBB,0X47,0X04,0X93,0XDF,0X56,0X03,0XB9,0XDC,0X05,0X03,0XBD,0XC8,0X59,0X05,0X93,0XDB,0X56,0X3D,0XA6,0XD0,0X5D,0X05,0X97,0XC8,0X5F,0X05,0XCC,0XDC,0X4B,0X2E,0XB9,0XC0,0X5D,0X02,0XA9,0XB3,0X44,0X3D,0XBD,0XC8,0X01,0X06,0XB9,0XDF,0X56,0X2A,0XAA,0XC3,0X03,0X2E,0XB9,0XC0,0X04,0X03,0XB9,0XDF,0X56,0X05,0XB9,0XDC,0X44,0X2E,0XB9,0XD0,0X41,0X3D,0XA9,0XF2,0X5A,0X2B,0X97,0XC8,0X76,0X04,0X93,0XCC,0X45,0X3D,0XAA,0XC3,0X56,0X3D,0XB9,0XB3,0X5D,0X04,0X87,0XC8,0X5B,0X05,0XCC,0XBF,0X01,0X3E,0XA9,0XE6,0X44,0X2E,0XB9,0XBB,0X00,0X3E,0XCC,0XED,0X56,0X05,0XA9,0XB3,0X48,0X3D,0XAD,0XC8,0X01,0X3D,0XA6,0XE2,0X01,0X2E,0XB9,0XCC,0X44,0X3D,0XBD,0XC8,0X5D,0X03,0X93,0XDC,0X44,0X2E,0XB9,0XEE,0X47,0X3D,0XA6,0XC7,0X56,0X3E,0X93,0XDC,0X04,0X05,0XCC,0XBF,0X5A,0X2E,0XB6,0XD8,0X5E,0X3D,0XAD,0XCB,0X49,0X2A,0X94,0XD3,0X56,0X3E,0X90,0XE6,0X01,0X3D,0XAD,0XC8,0X42,0X3D,0XA9,0XBE,0X56,0X3D,0X93,0XE6,0X5D,0X05,0XB9,0XDB,0X44},",
          "",
          "[Added Lines]",
          "15:   .frame={0X81,0XFE,0X00,0XD4,0X66,0X27,0XE5,0X24,0X34,0X49,0XAF,0X4C,0X04,0X70,0XB0,0X5D,0X2F,0X60,0XB7,0X52,0X3C,0X7F,0XA8,0X43,0X3F,0X15,0XDC,0X51,0X02,0X60,0XA3,0X54,0X04,0X4E,0XA7,0X50,0X02,0X70,0XAB,0X4B,0X2F,0X60,0XD4,0X52,0X05,0X4A,0XB0,0X43,0X02,0X60,0XB3,0X10,0X02,0X64,0XA7,0X4C,0X04,0X4A,0XB4,0X43,0X3C,0X7F,0XBF,0X48,0X04,0X4E,0XA7,0X4A,0X04,0X15,0XB3,0X5E,0X2F,0X60,0XAF,0X48,0X03,0X70,0XDC,0X51,0X3C,0X64,0XA7,0X14,0X07,0X60,0XB0,0X43,0X2B,0X73,0XAC,0X16,0X2F,0X60,0XAF,0X11,0X02,0X60,0XB0,0X43,0X04,0X60,0XB3,0X51,0X2F,0X60,0XBF,0X54,0X3C,0X70,0X9D,0X4F,0X2A,0X4E,0XA7,0X63,0X05,0X4A,0XA3,0X50,0X3C,0X73,0XAC,0X43,0X3C,0X60,0XDC,0X48,0X05,0X5E,0XA7,0X4E,0X04,0X15,0XD0,0X14,0X3F,0X70,0X89,0X51,0X2F,0X60,0XD4,0X15,0X3F,0X15,0X82,0X43,0X04,0X70,0XDC,0X5D,0X3C,0X74,0XA7,0X14,0X3C,0X7F,0X8D,0X14,0X2F,0X60,0XA3,0X51,0X3C,0X64,0XA7,0X48,0X02,0X4A,0XB3,0X51,0X2F,0X60,0X81,0X52,0X3C,0X7F,0XA8,0X43,0X3F,0X4A,0XB3,0X11,0X04,0X15,0XD0,0X4F,0X2F,0X6F,0XB7,0X4B,0X3C,0X74,0XA4,0X5C,0X2B,0X4D,0XBC,0X43,0X3F,0X49,0X89,0X14,0X3C,0X74,0XA7,0X57,0X3C,0X70,0XD1,0X43,0X3C,0X4A,0X89,0X48,0X04,0X60,0XB4,0X51},",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "24:   .close_sock_at=0",
          "25:  },",
          "26:  {",
          "28:   .expectedDecodeBuf={0X54,0X65,0X73,0X74,0X69,0X74},",
          "29:   .frame_len=12,",
          "30:   .raw_payload_len=6,",
          "",
          "[Removed Lines]",
          "27:   .frame={0X82,0X86,0X90,0X5E,0X2B,0X8E,0XC4,0X3B,0X58,0XFA,0XF9,0X2A},",
          "",
          "[Added Lines]",
          "27:   .frame={0X82,0X86,0XDD,0X9B,0XD8,0X56,0X89,0XFE,0XAB,0X22,0XB4,0XEF},",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "36:   .close_sock_at=0",
          "37:  },",
          "38:  {",
          "40:   .expectedDecodeBuf={0X46,0X72,0X61,0X6D,0X65,0X32,0X20,0X64,0X6F,0X65,0X73,0X20,0X63,0X6F,0X6E,0X74,0X61,0X69,0X6E,0X20,0X6D,0X75,0X63,0X68,0X20,0X6D,0X6F,0X72,0X65,0X20,0X74,0X65,0X78,0X74,0X20,0X61,0X6E,0X64,0X20,0X65,0X76,0X65,0X6E,0X20,0X67,0X6F,0X65,0X73,0X20,0X62,0X65,0X79,0X6F,0X6E,0X64,0X20,0X74,0X68,0X65,0X20,0X31,0X32,0X36,0X20,0X62,0X79,0X74,0X65,0X20,0X6C,0X65,0X6E,0X20,0X66,0X69,0X65,0X6C,0X64,0X2E,0X20,0X46,0X72,0X61,0X6D,0X65,0X32,0X20,0X64,0X6F,0X65,0X73,0X20,0X63,0X6F,0X6E,0X74,0X61,0X69,0X6E,0X20,0X6D,0X75,0X63,0X68,0X20,0X6D,0X6F,0X72,0X65,0X20,0X74,0X65,0X78,0X74,0X20,0X61,0X6E,0X64,0X20,0X65,0X76,0X65,0X6E,0X20,0X67,0X6F,0X65,0X73,0X20,0X62,0X65,0X79,0X6F,0X6E,0X64,0X20,0X74,0X68,0X65,0X20,0X31,0X32,0X36,0X20,0X62,0X79,0X74,0X65,0X20,0X6C,0X65,0X6E,0X20,0X66,0X69,0X65,0X6C,0X64,0X2E},",
          "41:   .frame_len=167,",
          "42:   .raw_payload_len=159,",
          "",
          "[Removed Lines]",
          "39:   .frame={0X82,0XFE,0X00,0X9F,0X7D,0X97,0X6B,0XA2,0X3B,0XE5,0X0A,0XCF,0X18,0XA5,0X4B,0XC6,0X12,0XF2,0X18,0X82,0X1E,0XF8,0X05,0XD6,0X1C,0XFE,0X05,0X82,0X10,0XE2,0X08,0XCA,0X5D,0XFA,0X04,0XD0,0X18,0XB7,0X1F,0XC7,0X05,0XE3,0X4B,0XC3,0X13,0XF3,0X4B,0XC7,0X0B,0XF2,0X05,0X82,0X1A,0XF8,0X0E,0XD1,0X5D,0XF5,0X0E,0XDB,0X12,0XF9,0X0F,0X82,0X09,0XFF,0X0E,0X82,0X4C,0XA5,0X5D,0X82,0X1F,0XEE,0X1F,0XC7,0X5D,0XFB,0X0E,0XCC,0X5D,0XF1,0X02,0XC7,0X11,0XF3,0X45,0X82,0X3B,0XE5,0X0A,0XCF,0X18,0XA5,0X4B,0XC6,0X12,0XF2,0X18,0X82,0X1E,0XF8,0X05,0XD6,0X1C,0XFE,0X05,0X82,0X10,0XE2,0X08,0XCA,0X5D,0XFA,0X04,0XD0,0X18,0XB7,0X1F,0XC7,0X05,0XE3,0X4B,0XC3,0X13,0XF3,0X4B,0XC7,0X0B,0XF2,0X05,0X82,0X1A,0XF8,0X0E,0XD1,0X5D,0XF5,0X0E,0XDB,0X12,0XF9,0X0F,0X82,0X09,0XFF,0X0E,0X82,0X4C,0XA5,0X5D,0X82,0X1F,0XEE,0X1F,0XC7,0X5D,0XFB,0X0E,0XCC,0X5D,0XF1,0X02,0XC7,0X11,0XF3,0X45},",
          "",
          "[Added Lines]",
          "39:   .frame={0X82,0XFE,0X00,0X9F,0XB5,0X6E,0X7F,0X4C,0XF3,0X1C,0X1E,0X21,0XD0,0X5C,0X5F,0X28,0XDA,0X0B,0X0C,0X6C,0XD6,0X01,0X11,0X38,0XD4,0X07,0X11,0X6C,0XD8,0X1B,0X1C,0X24,0X95,0X03,0X10,0X3E,0XD0,0X4E,0X0B,0X29,0XCD,0X1A,0X5F,0X2D,0XDB,0X0A,0X5F,0X29,0XC3,0X0B,0X11,0X6C,0XD2,0X01,0X1A,0X3F,0X95,0X0C,0X1A,0X35,0XDA,0X00,0X1B,0X6C,0XC1,0X06,0X1A,0X6C,0X84,0X5C,0X49,0X6C,0XD7,0X17,0X0B,0X29,0X95,0X02,0X1A,0X22,0X95,0X08,0X16,0X29,0XD9,0X0A,0X51,0X6C,0XF3,0X1C,0X1E,0X21,0XD0,0X5C,0X5F,0X28,0XDA,0X0B,0X0C,0X6C,0XD6,0X01,0X11,0X38,0XD4,0X07,0X11,0X6C,0XD8,0X1B,0X1C,0X24,0X95,0X03,0X10,0X3E,0XD0,0X4E,0X0B,0X29,0XCD,0X1A,0X5F,0X2D,0XDB,0X0A,0X5F,0X29,0XC3,0X0B,0X11,0X6C,0XD2,0X01,0X1A,0X3F,0X95,0X0C,0X1A,0X35,0XDA,0X00,0X1B,0X6C,0XC1,0X06,0X1A,0X6C,0X84,0X5C,0X49,0X6C,0XD7,0X17,0X0B,0X29,0X95,0X02,0X1A,0X22,0X95,0X08,0X16,0X29,0XD9,0X0A,0X51},",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "48:   .close_sock_at=0",
          "49:  },",
          "50:  {",
          "52:   .expectedDecodeBuf={0X03,0XEB},",
          "53:   .frame_len=8,",
          "54:   .raw_payload_len=2,",
          "",
          "[Removed Lines]",
          "51:   .frame={0X88,0X82,0X71,0X1D,0X00,0XFE,0X72,0XF6},",
          "",
          "[Added Lines]",
          "51:   .frame={0X88,0X82,0X6B,0X33,0X77,0X94,0X68,0XD8},",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "60:   .close_sock_at=0",
          "61:  },",
          "62:  {",
          "64:   .expectedDecodeBuf={0X03,0XEB,0X49,0X27,0X6D,0X20,0X61,0X20,0X63,0X6C,0X6F,0X73,0X65,0X20,0X72,0X65,0X61,0X73,0X6F,0X6E,0X20,0X61,0X6E,0X64,0X20,0X6D,0X75,0X63,0X68,0X20,0X6D,0X6F,0X72,0X65,0X20,0X74,0X68,0X61,0X6E,0X20,0X74,0X68,0X61,0X74,0X21},",
          "65:   .frame_len=51,",
          "66:   .raw_payload_len=45,",
          "",
          "[Removed Lines]",
          "63:   .frame={0X88,0XAD,0XD0,0X8D,0X26,0XD8,0XD3,0X66,0X6F,0XFF,0XBD,0XAD,0X47,0XF8,0XB3,0XE1,0X49,0XAB,0XB5,0XAD,0X54,0XBD,0XB1,0XFE,0X49,0XB6,0XF0,0XEC,0X48,0XBC,0XF0,0XE0,0X53,0XBB,0XB8,0XAD,0X4B,0XB7,0XA2,0XE8,0X06,0XAC,0XB8,0XEC,0X48,0XF8,0XA4,0XE5,0X47,0XAC,0XF1},",
          "",
          "[Added Lines]",
          "63:   .frame={0X88,0XAD,0X4B,0XA1,0XCE,0XE8,0X48,0X4A,0X87,0XCF,0X26,0X81,0XAF,0XC8,0X28,0XCD,0XA1,0X9B,0X2E,0X81,0XBC,0X8D,0X2A,0XD2,0XA1,0X86,0X6B,0XC0,0XA0,0X8C,0X6B,0XCC,0XBB,0X8B,0X23,0X81,0XA3,0X87,0X39,0XC4,0XEE,0X9C,0X23,0XC0,0XA0,0XC8,0X3F,0XC9,0XAF,0X9C,0X6A},",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "84:   .close_sock_at=0",
          "85:  },",
          "86:  {",
          "88:   .expectedDecodeBuf={0X2E,0XFE,0X00,0X0F,0X72,0X65,0X20,0X49,0X70,0X73,0X75,0X6D},",
          "89:   .frame_len=22,",
          "90:   .raw_payload_len=12,",
          "",
          "[Removed Lines]",
          "87:   .frame={0X81,0XFE,0X00,0X0F,0X24,0X22,0X8D,0X9C,0X11,0X6F,0XA3,0XC6,0X6E,0X4E,0X88,0XB0,0X48,0X55,0XA2,0XC6,0X72,0X56},",
          "",
          "[Added Lines]",
          "87:   .frame={0X81,0XFE,0X00,0X0F,0X71,0XE9,0X29,0X79,0X44,0XA4,0X07,0X23,0X3B,0X85,0X2C,0X55,0X1D,0X9E,0X06,0X23,0X27,0X9D},",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "96:   .close_sock_at=0",
          "97:  },",
          "98:  {",
          "101:   .frame_len=30,",
          "102:   .raw_payload_len=18,",
          "103:   .expected_errno=EPROTO,",
          "",
          "[Removed Lines]",
          "99:   .frame={0X81,0XFF,0X00,0X00,0X00,0X00,0X80,0X40,0X7D,0XBB,0X03,0X56,0X7D,0XBB,0X03,0X56,0X7C,0X83,0X2D,0X0C,0X03,0XA2,0X06,0X7A,0X25,0XB9,0X2C,0X0C,0X1F,0XBA},",
          "100:   .expectedDecodeBuf={0X2E,0XFF,0X00,0X00,0X00,0X00,0X80,0X40,0X4C,0X6F,0X72,0X65,0X20,0X49,0X70,0X73,0X75,0X6D},",
          "",
          "[Added Lines]",
          "99:   .frame={0X81,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X80,0X40,0X2F,0X40,0XF3,0X5B,0X2F,0X40,0XF2,0X63,0X01,0X1A,0X8D,0X42,0X2A,0X6C,0XAB,0X59,0X00,0X1A,0X91,0X5A},",
          "100:   .expectedDecodeBuf={0X2E,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X80,0X40,0X72,0X65,0X20,0X49,0X70,0X73,0X75,0X6D},",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "106:   .simulate_sock_malfunction_at=0,",
          "107:   .errno_val=0,",
          "108:   .close_sock_at=0",
          "109:  }",
          "110: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "109:  },",
          "110:  {",
          "111:   .frame={0X01,0XAC,0XC9,0X6E,0XC7,0X6E,0X9F,0X29,0XAF,0X1E,0XAA,0X17,0X85,0X1E,0XAA,0X17,0X85,0X06,0X80,0X29,0X9D,0X17,0X90,0X39,0XA3,0X1A,0X93,0X39,0XF2,0X5E,0X93,0X39,0X96,0X09,0XAD,0X5C,0X91,0X07,0XAA,0X5C,0XFE,0X04,0XA8,0X5C,0X91,0X5E,0X85,0X07,0XF3,0X1B},",
          "112:   .expectedDecodeBuf={0X54,0X68,0X69,0X73,0X20,0X69,0X73,0X20,0X61,0X20,0X66,0X72,0X61,0X67,0X6D,0X65,0X6E,0X74,0X65,0X64,0X20,0X77,0X65,0X62,0X73,0X6F,0X63,0X6B,0X65,0X74,0X2E,0X2E,0X2E},",
          "113:   .frame_len=50,",
          "114:   .raw_payload_len=33,",
          "115:   .expected_errno=0,",
          "116:   .descr=\"Continuation test frag1\",",
          "117:   .i=0,",
          "118:   .simulate_sock_malfunction_at=0,",
          "119:   .errno_val=0,",
          "120:   .close_sock_at=0",
          "121:  },",
          "122:  {",
          "123:   .frame={0X00,0X9C,0X52,0XBC,0XD5,0X99,0X1E,0XD5,0XE1,0XEC,0X1B,0XFB,0X93,0XEC,0X08,0XFF,0X97,0XE9,0X36,0XFF,0X97,0XF7,0X30,0X8E,0X83,0XE3,0X1B,0XFB,0XEC,0XEC,0X1E,0XD5,0XE1,0XEC},",
          "124:   .expectedDecodeBuf={0X2E,0X2E,0X2E,0X20,0X61,0X6E,0X64,0X20,0X69,0X74,0X20,0X67,0X6F,0X65,0X73,0X20,0X6F,0X6E,0X2E,0X2E,0X2E},",
          "125:   .frame_len=34,",
          "126:   .raw_payload_len=21,",
          "127:   .expected_errno=0,",
          "128:   .descr=\"Continuation test frag2\",",
          "129:   .i=0,",
          "130:   .simulate_sock_malfunction_at=0,",
          "131:   .errno_val=0,",
          "132:   .close_sock_at=0",
          "133:  },",
          "134:  {",
          "135:   .frame={0X80,0X94,0X3B,0X88,0XA1,0XE9,0X62,0XDF,0X94,0X82,0X72,0XCF,0X98,0X9C,0X72,0XCF,0XE7,0X9C,0X61,0XCB,0XE3,0X93,0X5F,0XCF,0X98,0X9E},",
          "136:   .expectedDecodeBuf={0X61,0X6E,0X64,0X20,0X6F,0X6E,0X20,0X61,0X6E,0X64,0X20,0X73,0X74,0X6F,0X70},",
          "137:   .frame_len=26,",
          "138:   .raw_payload_len=15,",
          "139:   .expected_errno=0,",
          "140:   .descr=\"Continuation test frag3\",",
          "141:   .i=0,",
          "142:   .simulate_sock_malfunction_at=0,",
          "143:   .errno_val=0,",
          "144:   .close_sock_at=0",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2022-3170",
  "cve_desc": "An out-of-bounds access issue was found in the Linux kernel sound subsystem. It could occur when the 'id->name' provided by the user did not end with '\\0'. A privileged local user could pass a specially crafted name through ioctl() interface and crash the system or potentially escalate their privileges on the system.",
  "repo": "torvalds/linux",
  "patch_hash": "6ab55ec0a938c7f943a4edba3d6514f775983887",
  "patch_info": {
    "commit_hash": "6ab55ec0a938c7f943a4edba3d6514f775983887",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/6ab55ec0a938c7f943a4edba3d6514f775983887",
    "files": [
      "sound/core/control.c"
    ],
    "message": "ALSA: control: Fix an out-of-bounds bug in get_ctl_id_hash()\n\nSince the user can control the arguments provided to the kernel by the\nioctl() system call, an out-of-bounds bug occurs when the 'id->name'\nprovided by the user does not end with '\\0'.\n\nThe following log can reveal it:\n\n[    10.002313] BUG: KASAN: stack-out-of-bounds in snd_ctl_find_id+0x36c/0x3a0\n[    10.002895] Read of size 1 at addr ffff888109f5fe28 by task snd/439\n[    10.004934] Call Trace:\n[    10.007140]  snd_ctl_find_id+0x36c/0x3a0\n[    10.007489]  snd_ctl_ioctl+0x6cf/0x10e0\n\nFix this by checking the bound of 'id->name' in the loop.\n\nFixes: c27e1efb61c5 (\"ALSA: control: Use xarray for faster lookups\")\nSigned-off-by: Zheyu Ma <zheyuma97@gmail.com>\nLink: https://lore.kernel.org/r/20220824081654.3767739-1-zheyuma97@gmail.com\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
    "before_after_code_files": [
      "sound/core/control.c||sound/core/control.c"
    ]
  },
  "patch_diff": {
    "sound/core/control.c||sound/core/control.c": [
      "File: sound/core/control.c -> sound/core/control.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "385: #define MULTIPLIER 37",
      "386: static unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id)",
      "387: {",
      "388:  unsigned long h;",
      "391:  h = id->iface;",
      "392:  h = MULTIPLIER * h + id->device;",
      "393:  h = MULTIPLIER * h + id->subdevice;",
      "396:  h = MULTIPLIER * h + id->index;",
      "397:  h &= LONG_MAX;",
      "398:  return h;",
      "",
      "[Removed Lines]",
      "389:  const unsigned char *p;",
      "394:  for (p = id->name; *p; p++)",
      "395:   h = MULTIPLIER * h + *p;",
      "",
      "[Added Lines]",
      "388:  int i;",
      "394:  for (i = 0; id->name[i] && i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN; i++)",
      "395:   h = MULTIPLIER * h + id->name[i];",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c27e1efb61c545f36c450ef60862df9251d239a4",
      "candidate_info": {
        "commit_hash": "c27e1efb61c545f36c450ef60862df9251d239a4",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c27e1efb61c545f36c450ef60862df9251d239a4",
        "files": [
          "include/sound/core.h",
          "sound/core/Kconfig",
          "sound/core/control.c",
          "sound/core/init.c"
        ],
        "message": "ALSA: control: Use xarray for faster lookups\n\nThe control elements are managed in a single linked list and we\ntraverse the whole list for matching each numid or ctl id per every\ninquiry of a control element.  This is OK-ish for a small number of\nelements but obviously it doesn't scale.  Especially the matching with\nthe ctl id takes time because it checks each field of the snd_ctl_id\nelement, e.g. the name string is matched with strcmp().\n\nThis patch adds the hash tables with Xarray for improving the lookup\nspeed of a control element.  There are two xarray tables added to the\ncard; one for numid and another for ctl id.  For the numid, we use the\nnumid as the index, while for the ctl id, we calculate a hash key.\n\nThe lookup is done via a single xa_load() execution.  As long as the\ngiven control element is found on the Xarray table, that's fine, we\ncan give back a quick lookup result.  The problem is when no entry\nhits on the table, and for this case, we have a slight optimization.\nNamely, the driver checks whether we had a collision on Xarray table,\nand do a fallback search (linear lookup of the full entries) only if a\nhash key collision happened beforehand.\nSo, in theory, the inquiry for a non-existing element might take still\ntime even with this patch in a worst case, but this must be pretty\nrare.\n\nThe feature is enabled via CONFIG_SND_CTL_FAST_LOOKUP, which is turned\non as default.  For simplicity, the option can be turned off only when\nCONFIG_EXPERT is set (\"You are expert? Then you manage 1000 knobs\").\n\nLink: https://lore.kernel.org/r/20211028130027.18764-1-tiwai@suse.de\nLink: https://lore.kernel.org/r/20220609180504.775-1-tiwai@suse.de\nLink: https://lore.kernel.org/all/cover.1653813866.git.quic_rbankapu@quicinc.com/\nLink: https://lore.kernel.org/r/20220610064537.18660-1-tiwai@suse.de\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
        "before_after_code_files": [
          "include/sound/core.h||include/sound/core.h",
          "sound/core/control.c||sound/core/control.c",
          "sound/core/init.c||sound/core/init.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "sound/core/control.c||sound/core/control.c"
          ],
          "candidate": [
            "sound/core/control.c||sound/core/control.c"
          ]
        }
      },
      "candidate_diff": {
        "include/sound/core.h||include/sound/core.h": [
          "File: include/sound/core.h -> include/sound/core.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: #include <linux/stringify.h>",
          "16: #include <linux/printk.h>",
          "19: #ifdef CONFIG_SND_DYNAMIC_MINORS",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "17: #include <linux/xarray.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "103:  size_t user_ctl_alloc_size; // current memory allocation by user controls.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "107: #ifdef CONFIG_SND_CTL_FAST_LOOKUP",
          "111: #endif",
          "",
          "---------------"
        ],
        "sound/core/control.c||sound/core/control.c": [
          "File: sound/core/control.c -> sound/core/control.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "364:  return 0;",
          "365: }",
          "367: enum snd_ctl_add_mode {",
          "368:  CTL_ADD_EXCLUSIVE, CTL_REPLACE, CTL_ADD_ON_REPLACE,",
          "369: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "368: static bool elem_id_matches(const struct snd_kcontrol *kctl,",
          "369:        const struct snd_ctl_elem_id *id)",
          "370: {",
          "371:  return kctl->id.iface == id->iface &&",
          "372:   kctl->id.device == id->device &&",
          "373:   kctl->id.subdevice == id->subdevice &&",
          "374:   !strncmp(kctl->id.name, id->name, sizeof(kctl->id.name)) &&",
          "375:   kctl->id.index <= id->index &&",
          "376:   kctl->id.index + kctl->count > id->index;",
          "377: }",
          "379: #ifdef CONFIG_SND_CTL_FAST_LOOKUP",
          "384: #define MULTIPLIER 37",
          "385: static unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id)",
          "386: {",
          "387:  unsigned long h;",
          "388:  const unsigned char *p;",
          "390:  h = id->iface;",
          "391:  h = MULTIPLIER * h + id->device;",
          "392:  h = MULTIPLIER * h + id->subdevice;",
          "393:  for (p = id->name; *p; p++)",
          "394:   h = MULTIPLIER * h + *p;",
          "395:  h = MULTIPLIER * h + id->index;",
          "396:  h &= LONG_MAX;",
          "397:  return h;",
          "398: }",
          "401: static void add_hash_entries(struct snd_card *card,",
          "402:         struct snd_kcontrol *kcontrol)",
          "403: {",
          "404:  struct snd_ctl_elem_id id = kcontrol->id;",
          "405:  int i;",
          "407:  xa_store_range(&card->ctl_numids, kcontrol->id.numid,",
          "408:          kcontrol->id.numid + kcontrol->count - 1,",
          "409:          kcontrol, GFP_KERNEL);",
          "411:  for (i = 0; i < kcontrol->count; i++) {",
          "412:   id.index = kcontrol->id.index + i;",
          "413:   if (xa_insert(&card->ctl_hash, get_ctl_id_hash(&id),",
          "414:          kcontrol, GFP_KERNEL)) {",
          "416:    card->ctl_hash_collision = true;",
          "417:    dev_dbg(card->dev, \"ctl_hash collision %d:%s:%d\\n\",",
          "418:     id.iface, id.name, id.index);",
          "419:   }",
          "420:  }",
          "421: }",
          "424: static void remove_hash_entries(struct snd_card *card,",
          "425:     struct snd_kcontrol *kcontrol)",
          "426: {",
          "427:  struct snd_ctl_elem_id id = kcontrol->id;",
          "428:  struct snd_kcontrol *matched;",
          "429:  unsigned long h;",
          "430:  int i;",
          "432:  for (i = 0; i < kcontrol->count; i++) {",
          "433:   xa_erase(&card->ctl_numids, id.numid);",
          "434:   h = get_ctl_id_hash(&id);",
          "435:   matched = xa_load(&card->ctl_hash, h);",
          "436:   if (matched && (matched == kcontrol ||",
          "437:     elem_id_matches(matched, &id)))",
          "438:    xa_erase(&card->ctl_hash, h);",
          "439:   id.index++;",
          "440:   id.numid++;",
          "441:  }",
          "442: }",
          "444: static inline void add_hash_entries(struct snd_card *card,",
          "445:         struct snd_kcontrol *kcontrol)",
          "446: {",
          "447: }",
          "448: static inline void remove_hash_entries(struct snd_card *card,",
          "449:            struct snd_kcontrol *kcontrol)",
          "450: {",
          "451: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "408:  kcontrol->id.numid = card->last_numid + 1;",
          "409:  card->last_numid += kcontrol->count;",
          "411:  for (idx = 0; idx < kcontrol->count; idx++)",
          "412:   snd_ctl_notify_one(card, SNDRV_CTL_EVENT_MASK_ADD, kcontrol, idx);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "498:  add_hash_entries(card, kcontrol);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "479: }",
          "480: EXPORT_SYMBOL(snd_ctl_replace);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "571: static int __snd_ctl_remove(struct snd_card *card,",
          "572:        struct snd_kcontrol *kcontrol,",
          "573:        bool remove_hash)",
          "574: {",
          "575:  unsigned int idx;",
          "577:  if (snd_BUG_ON(!card || !kcontrol))",
          "578:   return -EINVAL;",
          "579:  list_del(&kcontrol->list);",
          "581:  if (remove_hash)",
          "582:   remove_hash_entries(card, kcontrol);",
          "584:  card->controls_count -= kcontrol->count;",
          "585:  for (idx = 0; idx < kcontrol->count; idx++)",
          "586:   snd_ctl_notify_one(card, SNDRV_CTL_EVENT_MASK_REMOVE, kcontrol, idx);",
          "587:  snd_ctl_free_one(kcontrol);",
          "588:  return 0;",
          "589: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "493: int snd_ctl_remove(struct snd_card *card, struct snd_kcontrol *kcontrol)",
          "494: {",
          "505: }",
          "506: EXPORT_SYMBOL(snd_ctl_remove);",
          "",
          "[Removed Lines]",
          "495:  unsigned int idx;",
          "497:  if (snd_BUG_ON(!card || !kcontrol))",
          "498:   return -EINVAL;",
          "499:  list_del(&kcontrol->list);",
          "500:  card->controls_count -= kcontrol->count;",
          "501:  for (idx = 0; idx < kcontrol->count; idx++)",
          "502:   snd_ctl_notify_one(card, SNDRV_CTL_EVENT_MASK_REMOVE, kcontrol, idx);",
          "503:  snd_ctl_free_one(kcontrol);",
          "504:  return 0;",
          "",
          "[Added Lines]",
          "604:  return __snd_ctl_remove(card, kcontrol, true);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "642:   up_write(&card->controls_rwsem);",
          "643:   return -ENOENT;",
          "644:  }",
          "645:  kctl->id = *dst_id;",
          "646:  kctl->id.numid = card->last_numid + 1;",
          "647:  card->last_numid += kctl->count;",
          "648:  up_write(&card->controls_rwsem);",
          "649:  return 0;",
          "650: }",
          "651: EXPORT_SYMBOL(snd_ctl_rename_id);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "745:  remove_hash_entries(card, kctl);",
          "749:  add_hash_entries(card, kctl);",
          "755: #ifndef CONFIG_SND_CTL_FAST_LOOKUP",
          "756: static struct snd_kcontrol *",
          "757: snd_ctl_find_numid_slow(struct snd_card *card, unsigned int numid)",
          "758: {",
          "759:  struct snd_kcontrol *kctl;",
          "761:  list_for_each_entry(kctl, &card->controls, list) {",
          "762:   if (kctl->id.numid <= numid && kctl->id.numid + kctl->count > numid)",
          "763:    return kctl;",
          "764:  }",
          "765:  return NULL;",
          "766: }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "666: struct snd_kcontrol *snd_ctl_find_numid(struct snd_card *card, unsigned int numid)",
          "667: {",
          "670:  if (snd_BUG_ON(!card || !numid))",
          "671:   return NULL;",
          "677: }",
          "678: EXPORT_SYMBOL(snd_ctl_find_numid);",
          "",
          "[Removed Lines]",
          "668:  struct snd_kcontrol *kctl;",
          "672:  list_for_each_entry(kctl, &card->controls, list) {",
          "673:   if (kctl->id.numid <= numid && kctl->id.numid + kctl->count > numid)",
          "674:    return kctl;",
          "675:  }",
          "676:  return NULL;",
          "",
          "[Added Lines]",
          "786: #ifdef CONFIG_SND_CTL_FAST_LOOKUP",
          "787:  return xa_load(&card->ctl_numids, numid);",
          "788: #else",
          "789:  return snd_ctl_find_numid_slow(card, numid);",
          "790: #endif",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "699:   return NULL;",
          "700:  if (id->numid != 0)",
          "701:   return snd_ctl_find_numid(card, id->numid);",
          "715:   return kctl;",
          "717:  return NULL;",
          "718: }",
          "719: EXPORT_SYMBOL(snd_ctl_find_id);",
          "",
          "[Removed Lines]",
          "702:  list_for_each_entry(kctl, &card->controls, list) {",
          "703:   if (kctl->id.iface != id->iface)",
          "704:    continue;",
          "705:   if (kctl->id.device != id->device)",
          "706:    continue;",
          "707:   if (kctl->id.subdevice != id->subdevice)",
          "708:    continue;",
          "709:   if (strncmp(kctl->id.name, id->name, sizeof(kctl->id.name)))",
          "710:    continue;",
          "711:   if (kctl->id.index > id->index)",
          "712:    continue;",
          "713:   if (kctl->id.index + kctl->count <= id->index)",
          "714:    continue;",
          "716:  }",
          "",
          "[Added Lines]",
          "816: #ifdef CONFIG_SND_CTL_FAST_LOOKUP",
          "817:  kctl = xa_load(&card->ctl_hash, get_ctl_id_hash(id));",
          "818:  if (kctl && elem_id_matches(kctl, id))",
          "820:  if (!card->ctl_hash_collision)",
          "822: #endif",
          "824:  list_for_each_entry(kctl, &card->controls, list)",
          "825:   if (elem_id_matches(kctl, id))",
          "826:    return kctl;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2195:  down_write(&card->controls_rwsem);",
          "2196:  while (!list_empty(&card->controls)) {",
          "2197:   control = snd_kcontrol(card->controls.next);",
          "2199:  }",
          "2200:  up_write(&card->controls_rwsem);",
          "2201:  put_device(&card->ctl_dev);",
          "2202:  return 0;",
          "",
          "[Removed Lines]",
          "2198:   snd_ctl_remove(card, control);",
          "",
          "[Added Lines]",
          "2309:   __snd_ctl_remove(card, control, false);",
          "2312: #ifdef CONFIG_SND_CTL_FAST_LOOKUP",
          "2313:  xa_destroy(&card->ctl_numids);",
          "2314:  xa_destroy(&card->ctl_hash);",
          "2315: #endif",
          "",
          "---------------"
        ],
        "sound/core/init.c||sound/core/init.c": [
          "File: sound/core/init.c -> sound/core/init.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "310:  rwlock_init(&card->ctl_files_rwlock);",
          "311:  INIT_LIST_HEAD(&card->controls);",
          "312:  INIT_LIST_HEAD(&card->ctl_files);",
          "313:  spin_lock_init(&card->files_lock);",
          "314:  INIT_LIST_HEAD(&card->files_list);",
          "315:  mutex_init(&card->memory_mutex);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "313: #ifdef CONFIG_SND_CTL_FAST_LOOKUP",
          "314:  xa_init(&card->ctl_numids);",
          "315:  xa_init(&card->ctl_hash);",
          "316: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5934d9a0383619c14df91af8fd76261dc3de2f5f",
      "candidate_info": {
        "commit_hash": "5934d9a0383619c14df91af8fd76261dc3de2f5f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5934d9a0383619c14df91af8fd76261dc3de2f5f",
        "files": [
          "sound/core/control.c"
        ],
        "message": "ALSA: control: Re-order bounds checking in get_ctl_id_hash()\n\nThese two checks are in the reverse order so it might read one element\nbeyond the end of the array.  First check if the \"i\" is within bounds\nbefore using it.\n\nFixes: 6ab55ec0a938 (\"ALSA: control: Fix an out-of-bounds bug in get_ctl_id_hash()\")\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nLink: https://lore.kernel.org/r/YwjgNh/gkG1hH7po@kili\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
        "before_after_code_files": [
          "sound/core/control.c||sound/core/control.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "sound/core/control.c||sound/core/control.c"
          ],
          "candidate": [
            "sound/core/control.c||sound/core/control.c"
          ]
        }
      },
      "candidate_diff": {
        "sound/core/control.c||sound/core/control.c": [
          "File: sound/core/control.c -> sound/core/control.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "391:  h = id->iface;",
          "392:  h = MULTIPLIER * h + id->device;",
          "393:  h = MULTIPLIER * h + id->subdevice;",
          "395:   h = MULTIPLIER * h + id->name[i];",
          "396:  h = MULTIPLIER * h + id->index;",
          "397:  h &= LONG_MAX;",
          "",
          "[Removed Lines]",
          "394:  for (i = 0; id->name[i] && i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN; i++)",
          "",
          "[Added Lines]",
          "394:  for (i = 0; i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN && id->name[i]; i++)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
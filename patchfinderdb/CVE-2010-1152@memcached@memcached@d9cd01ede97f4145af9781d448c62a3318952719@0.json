{
  "cve_id": "CVE-2010-1152",
  "cve_desc": "memcached.c in memcached before 1.4.3 allows remote attackers to cause a denial of service (daemon hang or crash) via a long line that triggers excessive memory allocation.  NOTE: some of these details are obtained from third party information.",
  "repo": "memcached/memcached",
  "patch_hash": "d9cd01ede97f4145af9781d448c62a3318952719",
  "patch_info": {
    "commit_hash": "d9cd01ede97f4145af9781d448c62a3318952719",
    "repo": "memcached/memcached",
    "commit_url": "https://github.com/memcached/memcached/commit/d9cd01ede97f4145af9781d448c62a3318952719",
    "files": [
      "memcached.c"
    ],
    "message": "Use strncmp when checking for large ascii multigets.",
    "before_after_code_files": [
      "memcached.c||memcached.c"
    ]
  },
  "patch_diff": {
    "memcached.c||memcached.c": [
      "File: memcached.c -> memcached.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3148:                     ++ptr;",
      "3149:                 }",
      "3152:                     conn_set_state(c, conn_closing);",
      "3153:                     return 1;",
      "3154:                 }",
      "",
      "[Removed Lines]",
      "3151:                 if (strcmp(ptr, \"get \") && strcmp(ptr, \"gets \")) {",
      "",
      "[Added Lines]",
      "3151:                 if (ptr - c->rcurr > 100 ||",
      "3152:                     (strncmp(ptr, \"get \", 4) && strncmp(ptr, \"gets \", 5))) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "75cc83685e103bc8ba380a57468c8f04413033f9",
      "candidate_info": {
        "commit_hash": "75cc83685e103bc8ba380a57468c8f04413033f9",
        "repo": "memcached/memcached",
        "commit_url": "https://github.com/memcached/memcached/commit/75cc83685e103bc8ba380a57468c8f04413033f9",
        "files": [
          "memcached.c",
          "testapp.c"
        ],
        "message": "Issue 102: Piping null to the server will crash it",
        "before_after_code_files": [
          "memcached.c||memcached.c",
          "testapp.c||testapp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "memcached.c||memcached.c"
          ],
          "candidate": [
            "memcached.c||memcached.c"
          ]
        }
      },
      "candidate_diff": {
        "memcached.c||memcached.c": [
          "File: memcached.c -> memcached.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3128:         if (c->rbytes == 0)",
          "3129:             return 0;",
          "3130:         el = memchr(c->rcurr, '\\n', c->rbytes);",
          "3132:             return 0;",
          "3133:         cont = el + 1;",
          "3134:         if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {",
          "3135:             el--;",
          "",
          "[Removed Lines]",
          "3131:         if (!el)",
          "",
          "[Added Lines]",
          "3132:         if (!el) {",
          "3133:             if (c->rbytes > 1024) {",
          "3138:                 char *ptr = c->rcurr;",
          "3140:                     ++ptr;",
          "3141:                 }",
          "3143:                 if (strcmp(ptr, \"get \") && strcmp(ptr, \"gets \")) {",
          "3144:                     conn_set_state(c, conn_closing);",
          "3145:                     return 1;",
          "3146:                 }",
          "3147:             }",
          "3150:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3196: static enum try_read_result try_read_network(conn *c) {",
          "3197:     enum try_read_result gotdata = READ_NO_DATA_RECEIVED;",
          "3198:     int res;",
          "3200:     assert(c != NULL);",
          "3202:     if (c->rcurr != c->rbuf) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3222:     int num_allocs = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3208:     while (1) {",
          "3209:         if (c->rbytes >= c->rsize) {",
          "3210:             char *new_rbuf = realloc(c->rbuf, c->rsize * 2);",
          "3211:             if (!new_rbuf) {",
          "3212:                 if (settings.verbose > 0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3233:             if (num_allocs == 4) {",
          "3234:                 return gotdata;",
          "3235:             }",
          "3236:             ++num_allocs;",
          "",
          "---------------"
        ],
        "testapp.c||testapp.c": [
          "File: testapp.c -> testapp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "538:     return TEST_PASS;",
          "539: }",
          "541: static enum test_return start_memcached_server(void) {",
          "542:     server_pid = start_server(&port, false, 600);",
          "543:     sock = connect_server(\"127.0.0.1\", port, false);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "541: static enum test_return test_issue_102(void) {",
          "542:     char buffer[4096];",
          "543:     memset(buffer, ' ', sizeof(buffer));",
          "544:     buffer[sizeof(buffer) - 1] = '\\0';",
          "546:     close(sock);",
          "547:     sock = connect_server(\"127.0.0.1\", port, false);",
          "549:     send_ascii_command(buffer);",
          "551:     assert(read(sock, buffer, sizeof(buffer)) == 0);",
          "552:     close(sock);",
          "553:     sock = connect_server(\"127.0.0.1\", port, false);",
          "554:     return TEST_PASS;",
          "555: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1677:     { \"start_server\", start_memcached_server },",
          "1678:     { \"issue_92\", test_issue_92 },",
          "1679:     { \"binary_noop\", test_binary_noop },",
          "1680:     { \"binary_quit\", test_binary_quit },",
          "1681:     { \"binary_quitq\", test_binary_quitq },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1695:     { \"issue_102\", test_issue_102 },",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f1351f9bbaae4fd923722f5563843f5d1c54a5f7",
      "candidate_info": {
        "commit_hash": "f1351f9bbaae4fd923722f5563843f5d1c54a5f7",
        "repo": "memcached/memcached",
        "commit_url": "https://github.com/memcached/memcached/commit/f1351f9bbaae4fd923722f5563843f5d1c54a5f7",
        "files": [
          "memcached.c",
          "memcached.h"
        ],
        "message": "Syscall optimizations.\n\nI have been using the last two days to test the modifications I have done to\nthe binary protocol, and I have not been able to find any new bugs. From my\ntesting the binary protocol now use the same amount of system calls as the\ntextual protocol.\n\nI have tried to use a common state machine, and branch the execution path as\nlate as possible.\n\ngit-svn-id: http://code.sixapart.com/svn/memcached/branches/binary@775 b0b603af-a30f-0410-a34e-baf09ae79d0b",
        "before_after_code_files": [
          "memcached.c||memcached.c",
          "memcached.h||memcached.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "memcached.c||memcached.c"
          ],
          "candidate": [
            "memcached.c||memcached.c"
          ]
        }
      },
      "candidate_diff": {
        "memcached.c||memcached.c": [
          "File: memcached.c -> memcached.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "298:     return true;",
          "299: }",
          "302:     char *rv = \"unknown\";",
          "303:     switch(prot) {",
          "304:         case ascii_prot:",
          "",
          "[Removed Lines]",
          "301: static char *prot_text(enum protocol prot) {",
          "",
          "[Added Lines]",
          "301: static const char *prot_text(enum protocol prot) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "383:                 prot_text(prot));",
          "384:         } else if (IS_UDP(prot)) {",
          "385:             fprintf(stderr, \"<%d server listening (udp)\\n\", sfd);",
          "390:         } else if (prot == negotiating_prot) {",
          "392:         } else {",
          "393:             fprintf(stderr, \"<%d new unknown (%d) client connection\\n\",",
          "394:                 sfd, prot);",
          "",
          "[Removed Lines]",
          "386:         } else if (prot == binary_prot) {",
          "387:             fprintf(stderr, \"<%d new binary client connection\\n\", sfd);",
          "388:         } else if (prot == ascii_prot) {",
          "389:             fprintf(stderr, \"<%d new ascii client connection\\n\", sfd);",
          "391:             fprintf(stderr, \"<%d new auto-negotiating client connection\\n\", sfd);",
          "",
          "[Added Lines]",
          "387:             fprintf(stderr, \"<%d new auto-negotiating client connection\\n\",",
          "388:                     sfd);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "517:     return;",
          "518: }",
          "",
          "[Removed Lines]",
          "520: static enum conn_states get_init_state(conn *c) {",
          "521:     int rv = 0;",
          "522:     assert(c != NULL);",
          "524:     switch(c->protocol) {",
          "525:         case binary_prot:",
          "526:             rv = conn_bin_init;",
          "527:             break;",
          "528:         case negotiating_prot:",
          "529:             rv = conn_negotiate;",
          "530:             break;",
          "531:         default:",
          "532:             rv = conn_read;",
          "533:     }",
          "534:     return rv;",
          "535: }",
          "539: static void conn_set_init_state(conn *c) {",
          "540:     assert(c != NULL);",
          "542:     conn_set_state(c, get_init_state(c));",
          "543: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "600:     }",
          "601: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "578: static const char *state_text(enum conn_states state) {",
          "579:     const char* const statenames[] = { \"conn_listening\",",
          "580:                                        \"conn_new_cmd\",",
          "581:                                        \"conn_waiting\",",
          "582:                                        \"conn_read\",",
          "583:                                        \"conn_parse_cmd\",",
          "584:                                        \"conn_write\",",
          "585:                                        \"conn_nread\",",
          "586:                                        \"conn_swallow\",",
          "587:                                        \"conn_closing\",",
          "588:                                        \"conn_mwrite\" };",
          "589:     return statenames[state];",
          "590: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "608: static void conn_set_state(conn *c, enum conn_states state) {",
          "609:     assert(c != NULL);",
          "611:     if (state != c->state) {",
          "615:         }",
          "616:         c->state = state;",
          "617:     }",
          "618: }",
          "",
          "[Removed Lines]",
          "612:         if (state == conn_read) {",
          "613:             conn_shrink(c);",
          "614:             assoc_move_next_bucket();",
          "",
          "[Added Lines]",
          "599:     assert(state >= conn_listening && state < conn_max_state);",
          "602:         if (settings.verbose > 2) {",
          "603:             fprintf(stderr, \"%d: going from %s to %s\\n\",",
          "604:                     c->sfd, state_text(c->state),",
          "605:                     state_text(state));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "810:         if (settings.verbose > 1)",
          "811:             fprintf(stderr, \">%d NOREPLY %s\\n\", c->sfd, str);",
          "812:         c->noreply = false;",
          "814:         return;",
          "815:     }",
          "",
          "[Removed Lines]",
          "813:         conn_set_state(c, conn_read);",
          "",
          "[Added Lines]",
          "805:         conn_set_state(c, conn_new_cmd);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "830:     c->wcurr = c->wbuf;",
          "832:     conn_set_state(c, conn_write);",
          "834:     return;",
          "835: }",
          "",
          "[Removed Lines]",
          "833:     c->write_and_go = get_init_state(c);",
          "",
          "[Added Lines]",
          "825:     c->write_and_go = conn_new_cmd;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "908: }",
          "910: static void write_bin_error(conn *c, int err, int swallow) {",
          "912:     switch(err) {",
          "913:         case ERR_UNKNOWN_CMD:",
          "914:             errstr = \"Unknown command\";",
          "915:             break;",
          "",
          "[Removed Lines]",
          "911:     char *errstr = \"Unknown error\";",
          "",
          "[Added Lines]",
          "903:     const char *errstr = \"Unknown error\";",
          "905:         case ERR_OUT_OF_MEMORY:",
          "906:             errstr = \"Out of memory\";",
          "907:             break;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "943:         c->sbytes = swallow;",
          "944:         c->write_and_go = conn_swallow;",
          "945:     } else {",
          "947:     }",
          "948: }",
          "",
          "[Removed Lines]",
          "946:         c->write_and_go = conn_bin_init;",
          "",
          "[Added Lines]",
          "941:         c->write_and_go = conn_new_cmd;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "954:         add_iov(c, d, dlen);",
          "955:     }",
          "956:     conn_set_state(c, conn_mwrite);",
          "958: }",
          "",
          "[Removed Lines]",
          "957:     c->write_and_go = conn_bin_init;",
          "",
          "[Added Lines]",
          "952:     c->write_and_go = conn_new_cmd;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1112:         conn_set_state(c, conn_mwrite);",
          "1113:     } else {",
          "1114:         if(c->cmd == CMD_GETQ) {",
          "1116:         } else {",
          "1117:             write_bin_error(c, ERR_NOT_FOUND, 0);",
          "1118:         }",
          "",
          "[Removed Lines]",
          "1115:             conn_set_state(c, conn_bin_init);",
          "",
          "[Added Lines]",
          "1110:             conn_set_state(c, conn_new_cmd);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1279: static void complete_nread_binary(conn *c) {",
          "1280:     assert(c != NULL);",
          "1349:     c->cmd = -1;",
          "1350:     c->substate = bin_no_state;",
          "1355:     conn_shrink(c);",
          "1384: }",
          "1386: static void complete_nread(conn *c) {",
          "1387:     assert(c != NULL);",
          "1389:     if(c->protocol == ascii_prot) {",
          "1390:         complete_nread_ascii(c);",
          "1392:         complete_nread_binary(c);",
          "1401:     }",
          "1402: }",
          "",
          "[Removed Lines]",
          "1282:     if(c->cmd < 0) {",
          "1284:         int i = 0;",
          "1286:         assert(BIN_PKT_HDR_WORDS == 4);",
          "1287:         for(i = 0; i<BIN_PKT_HDR_WORDS; i++) {",
          "1288:             c->bin_header[i] = ntohl(c->bin_header[i]);",
          "1289:         }",
          "1290:         if(settings.verbose) {",
          "1291:             fprintf(stderr, \"Read binary protocol data:  %08x %08x %08x %08x\\n\",",
          "1292:                 c->bin_header[0], c->bin_header[1], c->bin_header[2],",
          "1293:                 c->bin_header[3]);",
          "1294:         }",
          "1295:         if((c->bin_header[0] >> 24) != BIN_REQ_MAGIC) {",
          "1296:             if(settings.verbose) {",
          "1297:                 fprintf(stderr, \"Invalid magic:  %x\\n\", c->bin_header[0] >> 24);",
          "1298:             }",
          "1299:             conn_set_state(c, conn_closing);",
          "1300:             return;",
          "1301:         }",
          "1303:         c->msgcurr = 0;",
          "1304:         c->msgused = 0;",
          "1305:         c->iovused = 0;",
          "1306:         if (add_msghdr(c) != 0) {",
          "1307:             out_string(c, \"SERVER_ERROR out of memory\");",
          "1308:             return;",
          "1309:         }",
          "1311:         c->cmd = (c->bin_header[0] >> 16) & 0xff;",
          "1312:         c->keylen = c->bin_header[0] & 0xffff;",
          "1313:         c->opaque = c->bin_header[3];",
          "1314:         if(settings.verbose > 1) {",
          "1315:             fprintf(stderr,",
          "1316:                 \"Command: %d, opaque=%08x, keylen=%d, total_len=%d\\n\", c->cmd,",
          "1317:                 c->opaque, c->keylen, c->bin_header[2]);",
          "1318:         }",
          "1319:         dispatch_bin_command(c);",
          "1320:     } else {",
          "1321:         switch(c->substate) {",
          "1322:             case bin_reading_set_header:",
          "1323:                 process_bin_update(c);",
          "1324:                 break;",
          "1325:             case bin_read_set_value:",
          "1326:                 complete_update_bin(c);",
          "1327:                 break;",
          "1328:             case bin_reading_get_key:",
          "1329:                 process_bin_get(c);",
          "1330:                 break;",
          "1331:             case bin_reading_del_header:",
          "1332:                 process_bin_delete(c);",
          "1333:                 break;",
          "1334:             case bin_reading_incr_header:",
          "1335:                 complete_incr_bin(c);",
          "1336:                 break;",
          "1337:             default:",
          "1338:                 fprintf(stderr, \"Not handling substate %d\\n\", c->substate);",
          "1339:                 assert(0);",
          "1340:         }",
          "1341:     }",
          "1342: }",
          "1344: static void reinit_bin_connection(conn *c) {",
          "1345:     if (settings.verbose > 1)",
          "1346:         fprintf(stderr, \"*** Reinitializing binary connection.\\n\");",
          "1347:     c->rlbytes = MIN_BIN_PKT_LENGTH;",
          "1348:     c->write_and_go = conn_bin_init;",
          "1351:     c->rbytes = c->wbytes = 0;",
          "1352:     c->ritem = (char*)c->bin_header;",
          "1353:     c->rcurr = c->rbuf;",
          "1354:     c->wcurr = c->wbuf;",
          "1356:     conn_set_state(c, conn_nread);",
          "1357: }",
          "1361: static void setup_bin_protocol(conn *c) {",
          "1362:     char *loc = (char*)c->bin_header;",
          "1363:     if (settings.verbose > 1)",
          "1364:         fprintf(stderr, \"Negotiated protocol as binary.\\n\");",
          "1366:     c->protocol = binary_prot;",
          "1367:     reinit_bin_connection(c);",
          "1369:     c->ritem[0] = c->rbuf[0];",
          "1370:     c->ritem++;",
          "1371:     c->rlbytes--;",
          "1372: }",
          "1374: static void setup_ascii_protocol(conn *c) {",
          "1375:     if (settings.verbose > 1)",
          "1376:         fprintf(stderr, \"Negotiated protocol as ascii.\\n\");",
          "1377:     c->protocol = ascii_prot;",
          "1381:     c->rcurr = c->rbuf;",
          "1382:     c->rbytes = 1;",
          "1383:     conn_set_state(c, conn_read);",
          "1391:     } else if(c->protocol == binary_prot) {",
          "1393:     } else if(c->protocol == negotiating_prot) {",
          "1395:         if ((c->rbuf[0] & 0xff) == BIN_REQ_MAGIC)",
          "1396:             setup_bin_protocol(c);",
          "1397:         else",
          "1398:             setup_ascii_protocol(c);",
          "1399:     } else {",
          "",
          "[Added Lines]",
          "1276:     assert(c->cmd >= 0);",
          "1278:     switch(c->substate) {",
          "1279:     case bin_reading_set_header:",
          "1280:         process_bin_update(c);",
          "1281:         break;",
          "1282:     case bin_read_set_value:",
          "1283:         complete_update_bin(c);",
          "1284:         break;",
          "1285:     case bin_reading_get_key:",
          "1286:         process_bin_get(c);",
          "1287:         break;",
          "1288:     case bin_reading_del_header:",
          "1289:         process_bin_delete(c);",
          "1290:         break;",
          "1291:     case bin_reading_incr_header:",
          "1292:         complete_incr_bin(c);",
          "1293:         break;",
          "1294:     default:",
          "1295:         fprintf(stderr, \"Not handling substate %d\\n\", c->substate);",
          "1296:         assert(0);",
          "1297:     }",
          "1298: }",
          "1300: static void reset_cmd_handler(conn *c) {",
          "1304:     if (c->rbytes > 0) {",
          "1305:         conn_set_state(c, conn_parse_cmd);",
          "1306:     } else {",
          "1307:         conn_set_state(c, conn_waiting);",
          "1308:     }",
          "1313:     assert(c->protocol == ascii_prot || c->protocol == binary_prot);",
          "1317:     } else if (c->protocol == binary_prot) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1578:         c->wcurr = buf;",
          "1579:         c->wbytes = bytes;",
          "1580:         conn_set_state(c, conn_write);",
          "1582:     } else {",
          "1583:         out_string(c, \"SERVER_ERROR out of memory writing stats\");",
          "1584:     }",
          "",
          "[Removed Lines]",
          "1581:         c->write_and_go = get_init_state(c);",
          "",
          "[Added Lines]",
          "1499:         c->write_and_go = conn_new_cmd;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1869:                 {",
          "1871:                   if (i >= c->suffixsize) {",
          "",
          "[Removed Lines]",
          "1868:                 if(return_cas == true)",
          "",
          "[Added Lines]",
          "1786:                 if (return_cas)",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2361:                 c->bucket = bucket;",
          "2362:                 c->gen = gen;",
          "2363:             }",
          "2365:             return;",
          "2366:         } else {",
          "2367:             out_string(c, \"CLIENT_ERROR bad format\");",
          "",
          "[Removed Lines]",
          "2364:             conn_set_init_state(c);",
          "",
          "[Added Lines]",
          "2282:             conn_set_state(c, conn_new_cmd);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2457: static int try_read_command(conn *c) {",
          "2460:     assert(c != NULL);",
          "2461:     assert(c->rcurr <= (c->rbuf + c->rsize));",
          "2471:     }",
          "2483:     return 1;",
          "2484: }",
          "",
          "[Removed Lines]",
          "2458:     char *el, *cont;",
          "2463:     if (c->rbytes == 0)",
          "2464:         return 0;",
          "2465:     el = memchr(c->rcurr, '\\n', c->rbytes);",
          "2466:     if (!el)",
          "2467:         return 0;",
          "2468:     cont = el + 1;",
          "2469:     if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {",
          "2470:         el--;",
          "2474:     assert(cont <= (c->rcurr + c->rbytes));",
          "2476:     process_command(c, c->rcurr);",
          "2478:     c->rbytes -= (cont - c->rcurr);",
          "2479:     c->rcurr = cont;",
          "2481:     assert(c->rcurr <= (c->rbuf + c->rsize));",
          "",
          "[Added Lines]",
          "2378:     assert(c->rbytes > 0);",
          "2380:     if (c->protocol == negotiating_prot)  {",
          "2381:         if ((c->rbuf[0] & 0xff) == BIN_REQ_MAGIC) {",
          "2382:             c->protocol = binary_prot;",
          "2383:         } else {",
          "2384:             c->protocol = ascii_prot;",
          "2385:         }",
          "2387:         if (settings.verbose) {",
          "2388:             fprintf(stderr, \"%d: Client using the %s protocol\\n\", c->sfd,",
          "2389:                     prot_text(c->protocol));",
          "2390:         }",
          "2393:     if (c->protocol == binary_prot) {",
          "2395:         if (c->rbytes < MIN_BIN_PKT_LENGTH) {",
          "2397:             return 0;",
          "2398:         } else {",
          "2399:             int i = 0;",
          "2400:             memcpy(c->bin_header, c->rcurr, sizeof(c->bin_header));",
          "2401:             assert(BIN_PKT_HDR_WORDS == 4);",
          "2402:             for (i = 0; i<BIN_PKT_HDR_WORDS; i++) {",
          "2403:                 c->bin_header[i] = ntohl(c->bin_header[i]);",
          "2404:             }",
          "2406:             if (settings.verbose) {",
          "2407:                 fprintf(stderr,",
          "2408:                         \"Read binary protocol data:  %08x %08x %08x %08x\\n\",",
          "2409:                         c->bin_header[0], c->bin_header[1], c->bin_header[2],",
          "2410:                         c->bin_header[3]);",
          "2411:             }",
          "2413:             if ((c->bin_header[0] >> 24) != BIN_REQ_MAGIC) {",
          "2414:                 if (settings.verbose) {",
          "2415:                     fprintf(stderr, \"Invalid magic:  %x\\n\",",
          "2416:                             c->bin_header[0] >> 24);",
          "2417:                 }",
          "2418:                 conn_set_state(c, conn_closing);",
          "2419:                 return 0;",
          "2420:             }",
          "2422:             c->msgcurr = 0;",
          "2423:             c->msgused = 0;",
          "2424:             c->iovused = 0;",
          "2425:             if (add_msghdr(c) != 0) {",
          "2426:                 out_string(c, \"SERVER_ERROR out of memory\");",
          "2427:                 return 0;",
          "2428:             }",
          "2430:             c->cmd = (c->bin_header[0] >> 16) & 0xff;",
          "2431:             c->keylen = c->bin_header[0] & 0xffff;",
          "2432:             c->opaque = c->bin_header[3];",
          "2433:             if (settings.verbose > 1) {",
          "2434:                 fprintf(stderr,",
          "2435:                         \"Command: %d, opaque=%08x, keylen=%d, total_len=%d\\n\",",
          "2436:                         c->cmd, c->opaque, c->keylen, c->bin_header[2]);",
          "2437:             }",
          "2439:             dispatch_bin_command(c);",
          "2441:             c->rbytes -= MIN_BIN_PKT_LENGTH;",
          "2442:             c->rcurr += MIN_BIN_PKT_LENGTH;",
          "2443:         }",
          "2444:     } else {",
          "2445:         char *el, *cont;",
          "2447:         if (c->rbytes == 0)",
          "2448:             return 0;",
          "2449:         el = memchr(c->rcurr, '\\n', c->rbytes);",
          "2450:         if (!el)",
          "2451:             return 0;",
          "2452:         cont = el + 1;",
          "2453:         if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {",
          "2454:             el--;",
          "2455:         }",
          "2458:         assert(cont <= (c->rcurr + c->rbytes));",
          "2460:         process_command(c, c->rcurr);",
          "2462:         c->rbytes -= (cont - c->rcurr);",
          "2463:         c->rcurr = cont;",
          "2465:         assert(c->rcurr <= (c->rbuf + c->rsize));",
          "2466:     }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2550:                 out_string(c, \"SERVER_ERROR out of memory reading request\");",
          "2551:                 c->write_and_go = conn_closing;",
          "2553:             }",
          "2554:             c->rcurr = c->rbuf = new_rbuf;",
          "2555:             c->rsize *= 2;",
          "",
          "[Removed Lines]",
          "2552:                 return 1;",
          "",
          "[Added Lines]",
          "2540:                 return -2;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2570:             }",
          "2571:         }",
          "2572:         if (res == 0) {",
          "2576:         }",
          "2577:         if (res == -1) {",
          "2582:         }",
          "2583:     }",
          "2584:     return gotdata;",
          "",
          "[Removed Lines]",
          "2574:             conn_set_state(c, conn_closing);",
          "2575:             return 1;",
          "2578:             if (errno == EAGAIN || errno == EWOULDBLOCK) break;",
          "2580:             conn_set_state(c, conn_closing);",
          "2581:             return 1;",
          "",
          "[Added Lines]",
          "2561:             return -1;",
          "2564:             if (errno == EAGAIN || errno == EWOULDBLOCK) {",
          "2565:                 break;",
          "2566:             }",
          "2567:             return -1;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2726:                 close(sfd);",
          "2727:                 break;",
          "2728:             }",
          "2732:                                      DATA_BUFFER_SIZE, c->protocol);",
          "2744:             break;",
          "2754:             if (!update_event(c, EV_READ | EV_PERSIST)) {",
          "2755:                 if (settings.verbose > 0)",
          "2756:                     fprintf(stderr, \"Couldn't update event\\n\");",
          "2757:                 conn_set_state(c, conn_closing);",
          "2758:                 break;",
          "2759:             }",
          "2760:             stop = true;",
          "2761:             break;",
          "2765:             break;",
          "2767:         case conn_nread:",
          "",
          "[Removed Lines]",
          "2729:             init_state = get_init_state(c);",
          "2731:             dispatch_conn_new(sfd, init_state, EV_READ | EV_PERSIST,",
          "2734:             break;",
          "2736:         case conn_negotiate:",
          "2737:             if (settings.verbose > 1)",
          "2738:                 fprintf(stderr, \"Negotiating protocol for a new connection\\n\");",
          "2739:             c->rlbytes = 1;",
          "2740:             c->ritem = c->rbuf;",
          "2741:             c->rcurr = c->rbuf;",
          "2742:             c->wcurr = c->wbuf;",
          "2743:             conn_set_state(c, conn_nread);",
          "2746:         case conn_read:",
          "2747:             if (try_read_command(c) != 0) {",
          "2748:                 continue;",
          "2749:             }",
          "2750:             if ((IS_UDP(c->protocol) ? try_read_udp(c) : try_read_network(c)) != 0) {",
          "2751:                 continue;",
          "2752:             }",
          "2764:             reinit_bin_connection(c);",
          "",
          "[Added Lines]",
          "2715:             dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,",
          "2717:             stop = true;",
          "2720:         case conn_waiting:",
          "2728:             conn_set_state(c, conn_read);",
          "2732:         case conn_read:",
          "2733:             res = IS_UDP(c->protocol) ? try_read_udp(c) : try_read_network(c);",
          "2734:             switch (res) {",
          "2735:             case 0 :",
          "2736:                 conn_set_state(c, conn_waiting);",
          "2737:                 break;",
          "2738:             case 1:",
          "2739:                 conn_set_state(c, conn_parse_cmd);",
          "2740:                 break;",
          "2741:             case -1:",
          "2742:                 conn_set_state(c, conn_closing);",
          "2743:                 break;",
          "2746:                 break;",
          "2747:             }",
          "2748:             break;",
          "2750:         case conn_parse_cmd :",
          "2751:             if (try_read_command(c) == 0) {",
          "2753:                 conn_set_state(c, conn_waiting);",
          "2754:             }",
          "2756:             break;",
          "2758:         case conn_new_cmd:",
          "2759:             reset_cmd_handler(c);",
          "2760:             assoc_move_next_bucket();",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2773:             if (c->rbytes > 0) {",
          "2774:                 int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;",
          "2776:                 c->ritem += tocopy;",
          "2777:                 c->rlbytes -= tocopy;",
          "2778:                 c->rcurr += tocopy;",
          "2779:                 c->rbytes -= tocopy;",
          "2781:             }",
          "",
          "[Removed Lines]",
          "2775:                 memcpy(c->ritem, c->rcurr, tocopy);",
          "2780:                 break;",
          "",
          "[Added Lines]",
          "2771:                 memmove(c->ritem, c->rcurr, tocopy);",
          "2776:                 if (c->rlbytes == 0) {",
          "2777:                     break;",
          "2778:                 }",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2813:         case conn_swallow:",
          "2815:             if (c->sbytes == 0) {",
          "2817:                 break;",
          "2818:             }",
          "",
          "[Removed Lines]",
          "2816:                 conn_set_init_state(c);",
          "",
          "[Added Lines]",
          "2814:                 conn_set_state(c, conn_new_cmd);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "2897:                     if(c->protocol == binary_prot) {",
          "2898:                         conn_set_state(c, c->write_and_go);",
          "2899:                     } else {",
          "2901:                     }",
          "2902:                 } else if (c->state == conn_write) {",
          "2903:                     if (c->write_and_free) {",
          "",
          "[Removed Lines]",
          "2900:                         conn_set_init_state(c);",
          "",
          "[Added Lines]",
          "2898:                         conn_set_state(c, conn_new_cmd);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "3285:            \"              under sh this is done with 'ulimit -S -l NUM_KB').\\n\"",
          "3286:            \"-v            verbose (print errors/warnings while in event loop)\\n\"",
          "3287:            \"-vv           very verbose (also print client commands/reponses)\\n\"",
          "3288:            \"-h            print this help and exit\\n\"",
          "3289:            \"-i            print memcached and libevent license\\n\"",
          "3290:            \"-b            run a managed instanced (mnemonic: buckets)\\n\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3286:            \"-vvv          extremely verbose (also print internal state transitions)\\n\"",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "3480:     setbuf(stderr, NULL);",
          "3484:         switch (c) {",
          "3485:         case 'a':",
          "",
          "[Removed Lines]",
          "3483:     while ((c = getopt(argc, argv, \"a:bp:B:s:U:m:Mc:khirvdl:u:P:f:s:n:t:D:\")) != -1) {",
          "",
          "[Added Lines]",
          "3482:     while ((c = getopt(argc, argv, \"a:bp:s:U:m:Mc:khirvdl:u:P:f:s:n:t:D:L\")) != -1) {",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "3564:             settings.prefix_delimiter = optarg[0];",
          "3565:             settings.detail_enabled = 1;",
          "3566:             break;",
          "3568:         case 'L' :",
          "3569:             if (enable_large_pages() == 0) {",
          "3570:                 preallocate = true;",
          "3571:             }",
          "3573: #endif",
          "3574:         default:",
          "3575:             fprintf(stderr, \"Illegal argument \\\"%c\\\"\\n\", c);",
          "3576:             return 1;",
          "",
          "[Removed Lines]",
          "3567: #if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)",
          "3572:             break;",
          "",
          "[Added Lines]",
          "3567: #if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)",
          "3572:             break;",
          "",
          "---------------"
        ],
        "memcached.h||memcached.h": [
          "File: memcached.h -> memcached.h"
        ]
      }
    }
  ]
}
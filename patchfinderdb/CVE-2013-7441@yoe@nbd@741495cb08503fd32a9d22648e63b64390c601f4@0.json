{
  "cve_id": "CVE-2013-7441",
  "cve_desc": "The modern style negotiation in Network Block Device (nbd-server) 2.9.22 through 3.3 allows remote attackers to cause a denial of service (root process termination) by (1) closing the connection during negotiation or (2) specifying a name for a non-existent export.",
  "repo": "yoe/nbd",
  "patch_hash": "741495cb08503fd32a9d22648e63b64390c601f4",
  "patch_info": {
    "commit_hash": "741495cb08503fd32a9d22648e63b64390c601f4",
    "repo": "yoe/nbd",
    "commit_url": "https://github.com/yoe/nbd/commit/741495cb08503fd32a9d22648e63b64390c601f4",
    "files": [
      "nbd-server.c"
    ],
    "message": "nbd-server: handle modern-style negotiation in a child process\n\nPreviously, the modern style negotiation was carried out in the root\nserver (listener) process before forking the actual client handler. This\nmade it possible for a malfunctioning or evil client to terminate the\nroot process simply by querying a non-existent export or aborting in the\nmiddle of the negotation process (caused SIGPIPE in the server).\n\nThis commit moves the negotiation process to the child to keep the root\nprocess up and running no matter what happens during the negotiation.\n\nSee http://sourceforge.net/mailarchive/message.php?msg_id=30410146\n\nSigned-off-by: Tuomas R\u00e4s\u00e4nen <tuomasjjrasanen@tjjr.fi>",
    "before_after_code_files": [
      "nbd-server.c||nbd-server.c"
    ]
  },
  "patch_diff": {
    "nbd-server.c||nbd-server.c": [
      "File: nbd-server.c -> nbd-server.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2198:  g_free(data);",
      "2199: }",
      "2201: static void",
      "2202: handle_connection(GArray *servers, int net, SERVER *serve, CLIENT *client)",
      "2203: {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2201: static pid_t",
      "2202: spawn_child()",
      "2203: {",
      "2204:         pid_t pid;",
      "2205:         sigset_t newset;",
      "2206:         sigset_t oldset;",
      "2208:         sigemptyset(&newset);",
      "2209:         sigaddset(&newset, SIGCHLD);",
      "2210:         sigaddset(&newset, SIGTERM);",
      "2211:         sigprocmask(SIG_BLOCK, &newset, &oldset);",
      "2212:         pid = fork();",
      "2213:         if (pid < 0) {",
      "2214:                 msg(LOG_ERR, \"Could not fork (%s)\", strerror(errno));",
      "2215:                 goto out;",
      "2216:         }",
      "2218:                 pid_t *pidp;",
      "2220:                 pidp = g_malloc(sizeof(pid_t));",
      "2222:                 g_hash_table_insert(children, pidp, pidp);",
      "2223:                 goto out;",
      "2224:         }",
      "2226:         signal(SIGCHLD, SIG_DFL);",
      "2227:         signal(SIGTERM, SIG_DFL);",
      "2228:         signal(SIGHUP, SIG_DFL);",
      "2229: out:",
      "2230:         sigprocmask(SIG_SETMASK, &oldset, NULL);",
      "2231:         return pid;",
      "2232: }",
      "2234: static int",
      "2235: socket_accept(const int sock)",
      "2236: {",
      "2237:         struct sockaddr_storage addrin;",
      "2238:         socklen_t addrinlen = sizeof(addrin);",
      "2239:         int net;",
      "2241:         net = accept(sock, (struct sockaddr *) &addrin, &addrinlen);",
      "2242:         if (net < 0) {",
      "2243:                 err_nonfatal(\"Failed to accept socket connection: %m\");",
      "2244:         }",
      "2246:         return net;",
      "2247: }",
      "2249: static void",
      "2250: handle_modern_connection(GArray *const servers, const int sock)",
      "2251: {",
      "2252:         int net;",
      "2253:         pid_t pid;",
      "2254:         CLIENT *client = NULL;",
      "2255:         int sock_flags_old;",
      "2256:         int sock_flags_new;",
      "2258:         net = socket_accept(sock);",
      "2259:         if (net < 0)",
      "2260:                 return;",
      "2262:         if (!dontfork) {",
      "2263:                 pid = spawn_child();",
      "2264:                 if (pid) {",
      "2265:                         if (pid > 0)",
      "2266:                                 msg(LOG_INFO, \"Spawned a child process\");",
      "2267:                         if (pid < 0)",
      "2268:                                 msg(LOG_ERR, \"Failed to spawn a child process\");",
      "2269:                         close(net);",
      "2270:                         return;",
      "2271:                 }",
      "2273:         }",
      "2275:         client = negotiate(net, NULL, servers, NEG_INIT | NEG_MODERN);",
      "2276:         if (!client) {",
      "2277:                 msg(LOG_ERR, \"Modern initial negotiation failed\");",
      "2278:                 goto handler_err;",
      "2279:         }",
      "2281:         if (client->server->max_connections > 0 &&",
      "2282:            g_hash_table_size(children) >= client->server->max_connections) {",
      "2283:                 msg(LOG_ERR, \"Max connections (%d) reached\",",
      "2284:                     client->server->max_connections);",
      "2285:                 goto handler_err;",
      "2286:         }",
      "2288:         sock_flags_old = fcntl(net, F_GETFL, 0);",
      "2289:         if (sock_flags_old == -1) {",
      "2290:                 msg(LOG_ERR, \"Failed to get socket flags\");",
      "2291:                 goto handler_err;",
      "2292:         }",
      "2294:         sock_flags_new = sock_flags_old & ~O_NONBLOCK;",
      "2295:         if (sock_flags_new != sock_flags_old &&",
      "2296:             fcntl(net, F_SETFL, sock_flags_new) == -1) {",
      "2297:                 msg(LOG_ERR, \"Failed to set socket to blocking mode\");",
      "2298:                 goto handler_err;",
      "2299:         }",
      "2301:         if (set_peername(net, client)) {",
      "2302:                 msg(LOG_ERR, \"Failed to set peername\");",
      "2303:                 goto handler_err;",
      "2304:         }",
      "2306:         if (!authorized_client(client)) {",
      "2307:                 msg(LOG_INFO, \"Client '%s' is not authorized to access\",",
      "2308:                     client->clientname);",
      "2309:                 goto handler_err;",
      "2310:         }",
      "2312:         if (!dontfork) {",
      "2313:                 int i;",
      "2318:                 g_hash_table_destroy(children);",
      "2319:                 children = NULL;",
      "2320:                 for (i = 0; i < modernsocks->len; i++) {",
      "2321:                         close(g_array_index(modernsocks, int, i));",
      "2322:                 }",
      "2323:                 g_array_free(modernsocks, TRUE);",
      "2329:                 for (i = 0; i < servers->len; i++) {",
      "2330:                         const SERVER *const server = &g_array_index(servers, SERVER, i);",
      "2331:                         close(server->socket);",
      "2332:                 }",
      "2335:                    actual data. This is required,",
      "2336:                    because the client has a",
      "2337:                    direct reference into that",
      "2338:                    data, and otherwise we get a",
      "2340:                 g_array_free(servers, FALSE);",
      "2341:         }",
      "2343:         msg(LOG_INFO, \"Starting to serve\");",
      "2344:         serveconnection(client);",
      "2345:         exit(EXIT_SUCCESS);",
      "2347: handler_err:",
      "2348:         g_free(client);",
      "2349:         close(net);",
      "2351:         if (!dontfork) {",
      "2352:                 exit(EXIT_FAILURE);",
      "2353:         }",
      "2354: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2426:   memcpy(&rset, &mset, sizeof(fd_set));",
      "2427:   if(select(max+1, &rset, NULL, NULL, NULL)>0) {",
      "2430:    DEBUG(\"accept, \");",
      "2431:    for(i=0; i < modernsocks->len; i++) {",
      "",
      "[Removed Lines]",
      "2428:    int net;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2433:     if(!FD_ISSET(sock, &rset)) {",
      "2434:      continue;",
      "2435:     }",
      "2448:    }",
      "2449:    for(i=0; i < servers->len; i++) {",
      "2450:     SERVER *serve;",
      "2452:     serve=&(g_array_index(servers, SERVER, i));",
      "",
      "[Removed Lines]",
      "2436:     CLIENT *client;",
      "2438:     if((net=accept(sock, (struct sockaddr *) &addrin, &addrinlen)) < 0) {",
      "2439:      err_nonfatal(\"accept: %m\");",
      "2440:      continue;",
      "2441:     }",
      "2442:     client = negotiate(net, NULL, servers, NEG_INIT | NEG_MODERN);",
      "2443:     if(!client) {",
      "2444:      close(net);",
      "2445:      continue;",
      "2446:     }",
      "2447:     handle_connection(servers, net, client->server, client);",
      "",
      "[Added Lines]",
      "2591:     handle_modern_connection(servers, sock);",
      "2594:     int net;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e68de3612ac5b58bf64134216e22b131995e62a7",
      "candidate_info": {
        "commit_hash": "e68de3612ac5b58bf64134216e22b131995e62a7",
        "repo": "yoe/nbd",
        "commit_url": "https://github.com/yoe/nbd/commit/e68de3612ac5b58bf64134216e22b131995e62a7",
        "files": [
          "nbd-server.c"
        ],
        "message": "nbd-server: fix several memory leaks in connection handling code\n\nThis change fixes a CLIENT leak on normal path in the parent process,\nseveral CLIENT leaks on error path in the parent process, a pid_t leak\non error path in the parent process, and a pid_t leak in the child\nprocess.\n\nSigned-off-by: Dmitry V. Levin <ldv@altlinux.org>",
        "before_after_code_files": [
          "nbd-server.c||nbd-server.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "nbd-server.c||nbd-server.c"
          ],
          "candidate": [
            "nbd-server.c||nbd-server.c"
          ]
        }
      },
      "candidate_diff": {
        "nbd-server.c||nbd-server.c": [
          "File: nbd-server.c -> nbd-server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2171:  if(serve->max_connections > 0 &&",
          "2172:     g_hash_table_size(children) >= serve->max_connections) {",
          "2173:   msg2(LOG_INFO, \"Max connections reached\");",
          "2176:  }",
          "2177:  if((sock_flags_old = fcntl(net, F_GETFL, 0)) == -1) {",
          "2178:   err(\"fcntl F_GETFL\");",
          "",
          "[Removed Lines]",
          "2174:   close(net);",
          "2175:   return;",
          "",
          "[Added Lines]",
          "2174:   goto handle_connection_out;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2192:  set_peername(net, client);",
          "2193:  if (!authorized_client(client)) {",
          "2194:   msg2(LOG_INFO,\"Unauthorized client\") ;",
          "2197:  }",
          "2198:  msg2(LOG_INFO,\"Authorized client\") ;",
          "2200:  if (!dontfork) {",
          "2202:   int i;",
          "2206:    msg3(LOG_INFO,\"Could not fork (%s)\",strerror(errno)) ;",
          "2209:   }",
          "2214:   }",
          "2216:   g_hash_table_destroy(children);",
          "",
          "[Removed Lines]",
          "2195:   close(net);",
          "2196:   return;",
          "2201:   pid_t *pid;",
          "2204:   pid=g_malloc(sizeof(pid_t));",
          "2205:   if ((*pid=fork())<0) {",
          "2207:    close(net);",
          "2208:    return;",
          "2211:    close(net);",
          "2212:    g_hash_table_insert(children, pid, pid);",
          "2213:    return;",
          "",
          "[Added Lines]",
          "2194:   goto handle_connection_out;",
          "2199:   pid_t pid;",
          "2202:   if ((pid = fork()) < 0) {",
          "2204:    goto handle_connection_out;",
          "2207:    pid_t *pidp;",
          "2209:    pidp = g_malloc(sizeof(pid_t));",
          "2211:    g_hash_table_insert(children, pidp, pidp);",
          "2212:    goto handle_connection_out;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2232:  msg2(LOG_INFO,\"Starting to serve\");",
          "2233:  serveconnection(client);",
          "2234:  exit(EXIT_SUCCESS);",
          "2235: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2235: handle_connection_out:",
          "2236:  g_free(client);",
          "2237:  close(net);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "43fa145cc7f0b50cd74c318c27bc00415c6a8499",
      "candidate_info": {
        "commit_hash": "43fa145cc7f0b50cd74c318c27bc00415c6a8499",
        "repo": "yoe/nbd",
        "commit_url": "https://github.com/yoe/nbd/commit/43fa145cc7f0b50cd74c318c27bc00415c6a8499",
        "files": [
          "nbd-server.c"
        ],
        "message": "nbd-server: move connection handling code to a separate function\n\nThe serveloop function has grown too much, and the indentation of\nconnection handling code unnecessarily complicates further changes.\n\nSigned-off-by: Dmitry V. Levin <ldv@altlinux.org>",
        "before_after_code_files": [
          "nbd-server.c||nbd-server.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "nbd-server.c||nbd-server.c"
          ],
          "candidate": [
            "nbd-server.c||nbd-server.c"
          ]
        }
      },
      "candidate_diff": {
        "nbd-server.c||nbd-server.c": [
          "File: nbd-server.c -> nbd-server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2162:  g_free(data);",
          "2163: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2165: static void",
          "2166: handle_connection(GArray *servers, int net, SERVER *serve, CLIENT *client)",
          "2167: {",
          "2168:  int sock_flags;",
          "2170:  if(serve->max_connections > 0 &&",
          "2171:     g_hash_table_size(children) >= serve->max_connections) {",
          "2172:   msg2(LOG_INFO, \"Max connections reached\");",
          "2173:   close(net);",
          "2174:   return;",
          "2175:  }",
          "2176:  if((sock_flags = fcntl(net, F_GETFL, 0))==-1) {",
          "2177:   err(\"fcntl F_GETFL\");",
          "2178:  }",
          "2179:  if(fcntl(net, F_SETFL, sock_flags &~O_NONBLOCK)==-1) {",
          "2180:   err(\"fcntl F_SETFL ~O_NONBLOCK\");",
          "2181:  }",
          "2182:  if(!client) {",
          "2183:   client = g_new0(CLIENT, 1);",
          "2184:   client->server=serve;",
          "2185:   client->exportsize=OFFT_MAX;",
          "2186:   client->net=net;",
          "2187:   client->transactionlogfd = -1;",
          "2188:  }",
          "2189:  set_peername(net, client);",
          "2190:  if (!authorized_client(client)) {",
          "2191:   msg2(LOG_INFO,\"Unauthorized client\") ;",
          "2192:   close(net);",
          "2193:   return;",
          "2194:  }",
          "2195:  msg2(LOG_INFO,\"Authorized client\") ;",
          "2197:  if (!dontfork) {",
          "2198:   pid_t *pid;",
          "2199:   int i;",
          "2201:   pid=g_malloc(sizeof(pid_t));",
          "2202:   if ((*pid=fork())<0) {",
          "2203:    msg3(LOG_INFO,\"Could not fork (%s)\",strerror(errno)) ;",
          "2204:    close(net);",
          "2205:    return;",
          "2206:   }",
          "2208:    close(net);",
          "2209:    g_hash_table_insert(children, pid, pid);",
          "2210:    return;",
          "2211:   }",
          "2213:   g_hash_table_destroy(children);",
          "2214:   children = NULL;",
          "2215:   for(i=0;i<servers->len;i++) {",
          "2216:    serve=&g_array_index(servers, SERVER, i);",
          "2217:    close(serve->socket);",
          "2218:   }",
          "2220:      actual data. This is required,",
          "2221:      because the client has a",
          "2222:      direct reference into that",
          "2223:      data, and otherwise we get a",
          "2225:   g_array_free(servers, FALSE);",
          "2226:   close(modernsock);",
          "2227:  }",
          "2229:  msg2(LOG_INFO,\"Starting to serve\");",
          "2230:  serveconnection(client);",
          "2231:  exit(EXIT_SUCCESS);",
          "2232: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2195:  }",
          "2196:  for(;;) {",
          "2197:   CLIENT *client = NULL;",
          "2200:   memcpy(&rset, &mset, sizeof(fd_set));",
          "2201:   if(select(max+1, &rset, NULL, NULL, NULL)>0) {",
          "",
          "[Removed Lines]",
          "2198:   pid_t *pid;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2225:      }",
          "2226:     }",
          "2227:    }",
          "2291:   }",
          "2292:  }",
          "2293: }",
          "",
          "[Removed Lines]",
          "2228:    if(net >= 0) {",
          "2229:     int sock_flags;",
          "2231:     if(serve->max_connections > 0 &&",
          "2232:        g_hash_table_size(children) >= serve->max_connections) {",
          "2233:      msg2(LOG_INFO, \"Max connections reached\");",
          "2234:      close(net);",
          "2235:      continue;",
          "2236:     }",
          "2237:     if((sock_flags = fcntl(net, F_GETFL, 0))==-1) {",
          "2238:      err(\"fcntl F_GETFL\");",
          "2239:     }",
          "2240:     if(fcntl(net, F_SETFL, sock_flags &~O_NONBLOCK)==-1) {",
          "2241:      err(\"fcntl F_SETFL ~O_NONBLOCK\");",
          "2242:     }",
          "2243:     if(!client) {",
          "2244:      client = g_new0(CLIENT, 1);",
          "2245:      client->server=serve;",
          "2246:      client->exportsize=OFFT_MAX;",
          "2247:      client->net=net;",
          "2248:      client->transactionlogfd = -1;",
          "2249:     }",
          "2250:     set_peername(net, client);",
          "2251:     if (!authorized_client(client)) {",
          "2252:      msg2(LOG_INFO,\"Unauthorized client\") ;",
          "2253:      close(net);",
          "2254:      continue;",
          "2255:     }",
          "2256:     msg2(LOG_INFO,\"Authorized client\") ;",
          "2257:     pid=g_malloc(sizeof(pid_t));",
          "2259:     if (!dontfork) {",
          "2260:      if ((*pid=fork())<0) {",
          "2261:       msg3(LOG_INFO,\"Could not fork (%s)\",strerror(errno)) ;",
          "2262:       close(net);",
          "2263:       continue;",
          "2264:      }",
          "2266:       close(net);",
          "2267:       g_hash_table_insert(children, pid, pid);",
          "2268:       continue;",
          "2269:      }",
          "2271:      g_hash_table_destroy(children);",
          "2272:      children = NULL;",
          "2273:      for(i=0;i<servers->len;i++) {",
          "2274:       serve=&g_array_index(servers, SERVER, i);",
          "2275:       close(serve->socket);",
          "2276:      }",
          "2278:         actual data. This is required,",
          "2279:         because the client has a",
          "2280:         direct reference into that",
          "2281:         data, and otherwise we get a",
          "2283:      g_array_free(servers, FALSE);",
          "2284:      close(modernsock);",
          "2285:     }",
          "2287:     msg2(LOG_INFO,\"Starting to serve\");",
          "2288:     serveconnection(client);",
          "2289:     exit(EXIT_SUCCESS);",
          "2290:    }",
          "",
          "[Added Lines]",
          "2296:    if (net >= 0)",
          "2297:     handle_connection(servers, net, serve, client);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0b1fbcd17a4abb284023c277f44a4e055709b0d8",
      "candidate_info": {
        "commit_hash": "0b1fbcd17a4abb284023c277f44a4e055709b0d8",
        "repo": "yoe/nbd",
        "commit_url": "https://github.com/yoe/nbd/commit/0b1fbcd17a4abb284023c277f44a4e055709b0d8",
        "files": [
          "nbd-server.c"
        ],
        "message": "nbd-server: replace msg2(), msg3() and msg4() with variadic msg()\n\nSigned-off-by: Tuomas Jorma Juhani R\u00e4s\u00e4nen <tuomasjjrasanen@tjjr.fi>",
        "before_after_code_files": [
          "nbd-server.c||nbd-server.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "nbd-server.c||nbd-server.c"
          ],
          "candidate": [
            "nbd-server.c||nbd-server.c"
          ]
        }
      },
      "candidate_diff": {
        "nbd-server.c||nbd-server.c": [
          "File: nbd-server.c -> nbd-server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "127: int dontfork = 0;",
          "130: #ifdef ISSERVER",
          "134: #else",
          "138: #endif",
          "",
          "[Removed Lines]",
          "131: #define msg2(a,b) syslog(a,b)",
          "132: #define msg3(a,b,c) syslog(a,b,c)",
          "133: #define msg4(a,b,c,d) syslog(a,b,c,d)",
          "135: #define msg2(a,b) g_message((char*)b)",
          "136: #define msg3(a,b,c) g_message((char*)b,c)",
          "137: #define msg4(a,b,c,d) g_message((char*)b,c,d)",
          "",
          "[Added Lines]",
          "129: static void msg(const int priority, const char *const format, ...) {",
          "130:         va_list ap;",
          "132:         va_start(ap, format);",
          "135:         vsyslog(priority, format, ap);",
          "137:         g_logv(G_LOG_DOMAIN, G_LOG_LEVEL_MESSAGE, format, ap);",
          "139:         va_end(ap);",
          "140: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "328:  int len;",
          "330:  if ((f=fopen(opts->server->authname,\"r\"))==NULL) {",
          "333:   return 1 ;",
          "334:  }",
          "",
          "[Removed Lines]",
          "331:   msg4(LOG_INFO,\"Can't open authorization file %s (%s).\",",
          "332:        opts->server->authname,strerror(errno)) ;",
          "",
          "[Added Lines]",
          "333:                 msg(LOG_INFO, \"Can't open authorization file %s (%s).\",",
          "334:                     opts->server->authname, strerror(errno));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "337:  while (fgets(line,LINELEN,f)!=NULL) {",
          "338:   if((tmp=strchr(line, '/'))) {",
          "339:    if(strlen(line)<=tmp-line) {",
          "341:     return 0;",
          "342:    }",
          "344:    if(!inet_aton(line,&addr)) {",
          "346:     return 0;",
          "347:    }",
          "348:    len=strtol(tmp, NULL, 0);",
          "",
          "[Removed Lines]",
          "340:     msg4(LOG_CRIT, ERRMSG, line, opts->server->authname);",
          "345:     msg4(LOG_CRIT, ERRMSG, line, opts->server->authname);",
          "",
          "[Added Lines]",
          "342:     msg(LOG_CRIT, ERRMSG, line, opts->server->authname);",
          "347:     msg(LOG_CRIT, ERRMSG, line, opts->server->authname);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1065:  while((pid=waitpid(-1, &status, WNOHANG)) > 0) {",
          "1066:   if(WIFEXITED(status)) {",
          "1068:   }",
          "1069:   i=g_hash_table_lookup(children, &pid);",
          "1070:   if(!i) {",
          "1072:   } else {",
          "1073:    DEBUG(\"Removing %d from the list of children\", pid);",
          "1074:    g_hash_table_remove(children, &pid);",
          "",
          "[Removed Lines]",
          "1067:    msg3(LOG_INFO, \"Child exited with %d\", WEXITSTATUS(status));",
          "1071:    msg3(LOG_INFO, \"SIGCHLD received for an unknown child with PID %ld\", (long)pid);",
          "",
          "[Added Lines]",
          "1069:    msg(LOG_INFO, \"Child exited with %d\", WEXITSTATUS(status));",
          "1073:    msg(LOG_INFO, \"SIGCHLD received for an unknown child with PID %ld\", (long)pid);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1760:    if (currlen > BUFSIZE - sizeof(struct nbd_reply)) {",
          "1761:     currlen = BUFSIZE - sizeof(struct nbd_reply);",
          "1762:     if(!logged_oversized) {",
          "1764:      logged_oversized = true;",
          "1765:     }",
          "1766:    }",
          "",
          "[Removed Lines]",
          "1763:      msg2(LOG_DEBUG, \"oversized request (this is not a problem)\");",
          "",
          "[Added Lines]",
          "1765:      msg(LOG_DEBUG, \"oversized request (this is not a problem)\");",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1769:   switch (command) {",
          "1771:   case NBD_CMD_DISC:",
          "1773:                  if (client->server->flags & F_COPYONWRITE) {",
          "1774:     if (client->difmap) g_free(client->difmap) ;",
          "1775:                   close(client->difffile);",
          "",
          "[Removed Lines]",
          "1772:    msg2(LOG_INFO, \"Disconnect request received.\");",
          "",
          "[Added Lines]",
          "1774:    msg(LOG_INFO, \"Disconnect request received.\");",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1962:   client->exportsize = client->server->expected_size;",
          "1963:  }",
          "1966:  if(multifile) {",
          "1968:  }",
          "1969: }",
          "",
          "[Removed Lines]",
          "1965:  msg3(LOG_INFO, \"Size of exported file/device is %llu\", (unsigned long long)client->exportsize);",
          "1967:   msg3(LOG_INFO, \"Total number of files: %d\", i);",
          "",
          "[Added Lines]",
          "1967:  msg(LOG_INFO, \"Size of exported file/device is %llu\", (unsigned long long)client->exportsize);",
          "1969:   msg(LOG_INFO, \"Total number of files: %d\", i);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1975:  snprintf(client->difffilename, 1024, \"%s-%s-%d.diff\",client->exportname,client->clientname,",
          "1976:   (int)getpid()) ;",
          "1977:  client->difffilename[1023]='\\0';",
          "1979:  client->difffile=open(client->difffilename,O_RDWR | O_CREAT | O_TRUNC,0600) ;",
          "1980:  if (client->difffile<0) err(\"Could not create diff file (%m)\") ;",
          "1981:  if ((client->difmap=calloc(client->exportsize/DIFFPAGESIZE,sizeof(u32)))==NULL)",
          "",
          "[Removed Lines]",
          "1978:  msg3(LOG_INFO,\"About to create map and diff file %s\",client->difffilename) ;",
          "",
          "[Added Lines]",
          "1980:  msg(LOG_INFO, \"About to create map and diff file %s\", client->difffilename) ;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2071:  int shift;",
          "2073:  if (getpeername(net, (struct sockaddr *) &addrin, &addrinlen) < 0) {",
          "2075:   return -1;",
          "2076:  }",
          "2078:  if((e = getnameinfo((struct sockaddr *)&addrin, addrinlen,",
          "2079:    peername, sizeof (peername), NULL, 0, NI_NUMERICHOST))) {",
          "2081:   return -1;",
          "2082:  }",
          "",
          "[Removed Lines]",
          "2074:   msg2(LOG_INFO, \"getpeername failed: %m\");",
          "2080:   msg3(LOG_INFO, \"getnameinfo failed: %s\", gai_strerror(e));",
          "",
          "[Added Lines]",
          "2076:   msg(LOG_INFO, \"getpeername failed: %m\");",
          "2082:   msg(LOG_INFO, \"getnameinfo failed: %s\", gai_strerror(e));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2086:  e = getaddrinfo(peername, NULL, &hints, &ai);",
          "2088:  if(e != 0) {",
          "2090:   freeaddrinfo(ai);",
          "2091:   return -1;",
          "2092:  }",
          "2094:  switch(client->server->virtstyle) {",
          "2095:   case VIRT_NONE:",
          "2097:    client->exportname=g_strdup(client->server->exportname);",
          "2098:    break;",
          "2099:   case VIRT_IPHASH:",
          "2101:    for(i=0;i<strlen(peername);i++) {",
          "2102:     if(peername[i]=='.') {",
          "2103:      peername[i]='/';",
          "2104:     }",
          "2105:    }",
          "2106:   case VIRT_IPLIT:",
          "2108:    client->exportname=g_strdup_printf(client->server->exportname, peername);",
          "2109:    break;",
          "2110:   case VIRT_CIDR:",
          "2112:    memcpy(&netaddr, &addrin, addrinlen);",
          "2113:    if(ai->ai_family == AF_INET) {",
          "2114:     netaddr4 = (struct sockaddr_in *)&netaddr;",
          "",
          "[Removed Lines]",
          "2089:   msg3(LOG_INFO, \"getaddrinfo failed: %s\", gai_strerror(e));",
          "2096:    msg2(LOG_DEBUG, \"virtualization is off\");",
          "2100:    msg2(LOG_DEBUG, \"virtstyle iphash\");",
          "2107:    msg2(LOG_DEBUG, \"virststyle ipliteral\");",
          "2111:    msg3(LOG_DEBUG, \"virtstyle cidr %d\", client->server->cidrlen);",
          "",
          "[Added Lines]",
          "2091:   msg(LOG_INFO, \"getaddrinfo failed: %s\", gai_strerror(e));",
          "2098:    msg(LOG_DEBUG, \"virtualization is off\");",
          "2102:    msg(LOG_DEBUG, \"virtstyle iphash\");",
          "2109:    msg(LOG_DEBUG, \"virststyle ipliteral\");",
          "2113:    msg(LOG_DEBUG, \"virtstyle cidr %d\", client->server->cidrlen);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2143:  }",
          "2145:  freeaddrinfo(ai);",
          "2148:  client->clientname=g_strdup(peername);",
          "2149:  return 0;",
          "2150: }",
          "",
          "[Removed Lines]",
          "2146:  msg4(LOG_INFO, \"connect from %s, assigned file is %s\",",
          "2147:       peername, client->exportname);",
          "",
          "[Added Lines]",
          "2148:         msg(LOG_INFO, \"connect from %s, assigned file is %s\",",
          "2149:             peername, client->exportname);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2166:  if(serve->max_connections > 0 &&",
          "2167:     g_hash_table_size(children) >= serve->max_connections) {",
          "2169:   goto handle_connection_out;",
          "2170:  }",
          "2171:  if((sock_flags_old = fcntl(net, F_GETFL, 0)) == -1) {",
          "",
          "[Removed Lines]",
          "2168:   msg2(LOG_INFO, \"Max connections reached\");",
          "",
          "[Added Lines]",
          "2170:   msg(LOG_INFO, \"Max connections reached\");",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2187:   goto handle_connection_out;",
          "2188:  }",
          "2189:  if (!authorized_client(client)) {",
          "2191:   goto handle_connection_out;",
          "2192:  }",
          "2195:  if (!dontfork) {",
          "2196:   pid_t pid;",
          "",
          "[Removed Lines]",
          "2190:   msg2(LOG_INFO,\"Unauthorized client\") ;",
          "2193:  msg2(LOG_INFO,\"Authorized client\") ;",
          "",
          "[Added Lines]",
          "2192:   msg(LOG_INFO, \"Unauthorized client\");",
          "2195:  msg(LOG_INFO, \"Authorized client\");",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2203:   sigaddset(&newset, SIGTERM);",
          "2204:   sigprocmask(SIG_BLOCK, &newset, &oldset);",
          "2205:   if ((pid = fork()) < 0) {",
          "2207:    sigprocmask(SIG_SETMASK, &oldset, NULL);",
          "2208:    goto handle_connection_out;",
          "2209:   }",
          "",
          "[Removed Lines]",
          "2206:    msg3(LOG_INFO,\"Could not fork (%s)\",strerror(errno)) ;",
          "",
          "[Added Lines]",
          "2208:    msg(LOG_INFO, \"Could not fork (%s)\", strerror(errno));",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2237:   close(modernsock);",
          "2238:  }",
          "2241:  serveconnection(client);",
          "2242:  exit(EXIT_SUCCESS);",
          "",
          "[Removed Lines]",
          "2240:  msg2(LOG_INFO,\"Starting to serve\");",
          "",
          "[Added Lines]",
          "2242:  msg(LOG_INFO, \"Starting to serve\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c89a7826b8b26f6a0d820abaed77b88af6b082ce",
      "candidate_info": {
        "commit_hash": "c89a7826b8b26f6a0d820abaed77b88af6b082ce",
        "repo": "yoe/nbd",
        "commit_url": "https://github.com/yoe/nbd/commit/c89a7826b8b26f6a0d820abaed77b88af6b082ce",
        "files": [
          "nbd-server.c"
        ],
        "message": "Open as many modern sockets as needed\n\nSome systems need us to have a socket per address family (e.g.,\nFreeBSD); others need us to have just one (e.g., Linux). Handle both\ncases.",
        "before_after_code_files": [
          "nbd-server.c||nbd-server.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "nbd-server.c||nbd-server.c"
          ],
          "candidate": [
            "nbd-server.c||nbd-server.c"
          ]
        }
      },
      "candidate_diff": {
        "nbd-server.c||nbd-server.c": [
          "File: nbd-server.c -> nbd-server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "182:                                                     reconfiguration",
          "186:           if a client was only specified on the",
          "187:           command line; only port used if",
          "188:           oldstyle is set to false (and then the",
          "",
          "[Removed Lines]",
          "185: int modernsock=-1;   /**< Socket for the modern handler. Not used",
          "",
          "[Added Lines]",
          "185: GArray* modernsocks;   /**< Sockets for the modern handler. Not used",
          "189:           command-line client isn't used, gna gna).",
          "190:           This may be more than one socket on",
          "191:           systems that don't support serving IPv4",
          "192:           and IPv6 from the same socket (like,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2272:      data, and otherwise we get a",
          "2274:   g_array_free(servers, FALSE);",
          "2276:  }",
          "2278:  msg(LOG_INFO, \"Starting to serve\");",
          "",
          "[Removed Lines]",
          "2275:   close(modernsock);",
          "",
          "[Added Lines]",
          "2279:   for(i=0;i<modernsocks->len;i++) {",
          "2280:    close(g_array_index(modernsocks, int, i));",
          "2281:   }",
          "2282:   g_array_free(modernsocks, TRUE);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2377:    max=sock>max?sock:max;",
          "2378:   }",
          "2379:  }",
          "2383:  }",
          "2384:  for(;;) {",
          "",
          "[Removed Lines]",
          "2380:  if(modernsock >= 0) {",
          "2381:   FD_SET(modernsock, &mset);",
          "2382:   max=modernsock>max?modernsock:max;",
          "",
          "[Added Lines]",
          "2387:  for(i=0;i<modernsocks->len;i++) {",
          "2388:   int sock = g_array_index(modernsocks, int, i);",
          "2389:   FD_SET(sock, &mset);",
          "2390:   max=sock>max?sock:max;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2420:    int net;",
          "2422:    DEBUG(\"accept, \");",
          "2424:     CLIENT *client;",
          "2427:      err_nonfatal(\"accept: %m\");",
          "2428:      continue;",
          "2429:     }",
          "",
          "[Removed Lines]",
          "2423:    if(modernsock >= 0 && FD_ISSET(modernsock, &rset)) {",
          "2426:     if((net=accept(modernsock, (struct sockaddr *) &addrin, &addrinlen)) < 0) {",
          "",
          "[Added Lines]",
          "2431:    for(i=0; i < modernsocks->len; i++) {",
          "2432:     int sock = g_array_index(modernsocks, int, i);",
          "2433:     if(!FD_ISSET(sock, &rset)) {",
          "2434:      continue;",
          "2435:     }",
          "2438:     if((net=accept(sock, (struct sockaddr *) &addrin, &addrinlen)) < 0) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2613:  struct sock_flags;",
          "2614:  int e;",
          "2615:         int retval = -1;",
          "2617:  memset(&hints, '\\0', sizeof(hints));",
          "2618:  hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2628:  int i=0;",
          "2629:  int sock = -1;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2628:                 goto out;",
          "2629:  }",
          "2658:  }",
          "2660:         retval = 0;",
          "2661: out:",
          "2666:         }",
          "2667:         freeaddrinfo(ai);",
          "",
          "[Removed Lines]",
          "2631:  if((modernsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol))<0) {",
          "2632:                 g_set_error(gerror, NBDS_ERR, NBDS_ERR_SOCKET,",
          "2633:                             \"failed to open a modern socket: \"",
          "2634:                             \"failed to create a socket: %s\",",
          "2635:                             strerror(errno));",
          "2636:                 goto out;",
          "2637:  }",
          "2639:  if (dosockopts(modernsock, gerror) == -1) {",
          "2640:                 g_prefix_error(gerror, \"failed to open a modern socket: \");",
          "2641:                 goto out;",
          "2642:         }",
          "2644:  if(bind(modernsock, ai->ai_addr, ai->ai_addrlen)) {",
          "2645:                 g_set_error(gerror, NBDS_ERR, NBDS_ERR_BIND,",
          "2646:                             \"failed to open a modern socket: \"",
          "2647:                             \"failed to bind an address to a socket: %s\",",
          "2648:                             strerror(errno));",
          "2649:                 goto out;",
          "2650:  }",
          "2652:  if(listen(modernsock, 10) <0) {",
          "2653:                 g_set_error(gerror, NBDS_ERR, NBDS_ERR_BIND,",
          "2654:                             \"failed to open a modern socket: \"",
          "2655:                             \"failed to start listening on a socket: %s\",",
          "2656:                             strerror(errno));",
          "2657:                 goto out;",
          "2663:         if (retval == -1 && modernsock >= 0) {",
          "2664:                 close(modernsock);",
          "2665:                 modernsock = -1;",
          "",
          "[Added Lines]",
          "2645:  while(ai != NULL) {",
          "2646:   sock = -1;",
          "2648:   if((sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol))<0) {",
          "2649:    g_set_error(gerror, NBDS_ERR, NBDS_ERR_SOCKET,",
          "2650:         \"failed to open a modern socket: \"",
          "2651:         \"failed to create a socket: %s\",",
          "2652:         strerror(errno));",
          "2653:    goto out;",
          "2654:   }",
          "2656:   if (dosockopts(sock, gerror) == -1) {",
          "2657:    g_prefix_error(gerror, \"failed to open a modern socket: \");",
          "2658:    goto out;",
          "2659:   }",
          "2661:   if(bind(sock, ai->ai_addr, ai->ai_addrlen)) {",
          "2674:    if(errno == EADDRINUSE && modernsocks->len > 0) {",
          "2675:     goto next;",
          "2676:    }",
          "2677:    g_set_error(gerror, NBDS_ERR, NBDS_ERR_BIND,",
          "2678:         \"failed to open a modern socket: \"",
          "2679:         \"failed to bind an address to a socket: %s\",",
          "2680:         strerror(errno));",
          "2681:    goto out;",
          "2682:   }",
          "2684:   if(listen(sock, 10) <0) {",
          "2685:    g_set_error(gerror, NBDS_ERR, NBDS_ERR_BIND,",
          "2686:         \"failed to open a modern socket: \"",
          "2687:         \"failed to start listening on a socket: %s\",",
          "2688:         strerror(errno));",
          "2689:    goto out;",
          "2690:   }",
          "2691:   g_array_append_val(modernsocks, sock);",
          "2692:  next:",
          "2693:   ai = ai->ai_next;",
          "2699:         if (retval == -1 && sock >= 0) {",
          "2700:                 close(sock);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2847:  memset(pidftemplate, '\\0', 256);",
          "2849:  logging();",
          "2850:  config_file_pos = g_strdup(CFILE);",
          "2851:  serve=cmdline(argc, argv);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2884:  modernsocks = g_array_new(FALSE, FALSE, sizeof(int));",
          "",
          "---------------"
        ]
      }
    }
  ]
}
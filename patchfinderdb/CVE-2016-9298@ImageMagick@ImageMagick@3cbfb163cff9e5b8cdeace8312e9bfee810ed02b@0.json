{
  "cve_id": "CVE-2016-9298",
  "cve_desc": "Heap overflow in the WaveletDenoiseImage function in MagickCore/fx.c in ImageMagick before 6.9.6-4 and 7.x before 7.0.3-6 allows remote attackers to cause a denial of service (crash) via a crafted image.",
  "repo": "ImageMagick/ImageMagick",
  "patch_hash": "3cbfb163cff9e5b8cdeace8312e9bfee810ed02b",
  "patch_info": {
    "commit_hash": "3cbfb163cff9e5b8cdeace8312e9bfee810ed02b",
    "repo": "ImageMagick/ImageMagick",
    "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/3cbfb163cff9e5b8cdeace8312e9bfee810ed02b",
    "files": [
      "MagickCore/fx.c",
      "PerlMagick/demo/demo.pl"
    ],
    "message": "https://github.com/ImageMagick/ImageMagick/issues/296",
    "before_after_code_files": [
      "MagickCore/fx.c||MagickCore/fx.c",
      "PerlMagick/demo/demo.pl||PerlMagick/demo/demo.pl"
    ]
  },
  "patch_diff": {
    "MagickCore/fx.c||MagickCore/fx.c": [
      "File: MagickCore/fx.c -> MagickCore/fx.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "5866:   if (AcquireMagickResource(WidthResource,4*image->columns) == MagickFalse)",
      "5867:     ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");",
      "5868:   pixels_info=AcquireVirtualMemory(3*image->columns,image->rows*",
      "5870:   kernel=(float *) AcquireQuantumMemory(MagickMax(image->rows,image->columns),",
      "5871:     GetOpenMPMaximumThreads()*sizeof(*kernel));",
      "5872:   if ((pixels_info == (MemoryInfo *) NULL) || (kernel == (float *) NULL))",
      "",
      "[Removed Lines]",
      "5869:     sizeof(*pixels));",
      "",
      "[Added Lines]",
      "5869:     sizeof(*pixels));",
      "",
      "---------------"
    ],
    "PerlMagick/demo/demo.pl||PerlMagick/demo/demo.pl": [
      "File: PerlMagick/demo/demo.pl -> PerlMagick/demo/demo.pl",
      "--- Hunk 1 ---",
      "[Context before]",
      "484: print \"WaveletDenoise...\\n\";",
      "485: $example=$model->Clone();",
      "487: $example->WaveletDenoise('5%');",
      "488: push(@$images,$example);",
      "",
      "[Removed Lines]",
      "486: $example->Label('WaveletDenoise');",
      "",
      "[Added Lines]",
      "486: $example->Label('Wavelet Denoise');",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1a295fe7ffda4878bda19a21162e41f7890a4365",
      "candidate_info": {
        "commit_hash": "1a295fe7ffda4878bda19a21162e41f7890a4365",
        "repo": "ImageMagick/ImageMagick",
        "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/1a295fe7ffda4878bda19a21162e41f7890a4365",
        "files": [
          "MagickCore/fx.c"
        ],
        "message": "...",
        "before_after_code_files": [
          "MagickCore/fx.c||MagickCore/fx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "MagickCore/fx.c||MagickCore/fx.c"
          ],
          "candidate": [
            "MagickCore/fx.c||MagickCore/fx.c"
          ]
        }
      },
      "candidate_diff": {
        "MagickCore/fx.c||MagickCore/fx.c": [
          "File: MagickCore/fx.c -> MagickCore/fx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5765: %",
          "5769:   const size_t stride,const size_t size,const size_t scale,double *kernel)",
          "5770: {",
          "5771:   const float",
          "",
          "[Removed Lines]",
          "5768: static inline void HatTransform(const float *magick_restrict pixels,",
          "",
          "[Added Lines]",
          "5768: static inline void HatTransform(const float *magick_restrict pixels,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5808:   CacheView",
          "5815:   float",
          "",
          "[Removed Lines]",
          "5812:   double",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "5858:   if (AcquireMagickResource(WidthResource,4*image->columns) == MagickFalse)",
          "5859:     ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "5860:   pixels_info=AcquireVirtualMemory(3*image->columns,image->rows*",
          "5862:   kernel=(double *) AcquireQuantumMemory(MagickMax(image->rows,image->columns),",
          "5864:   if ((pixels_info == (MemoryInfo *) NULL) || (kernel == (double *) NULL))",
          "5867:         kernel=(double *) RelinquishMagickMemory(kernel);",
          "5868:       if (pixels_info != (MemoryInfo *) NULL)",
          "5869:         pixels_info=RelinquishVirtualMemory(pixels_info);",
          "",
          "[Removed Lines]",
          "5861:     sizeof(*pixels));",
          "5863:     GetOpenMPMaximumThreads()*sizeof(*kernel));",
          "5865:     {",
          "5866:       if (kernel != (double *) NULL)",
          "",
          "[Added Lines]",
          "5859:     sizeof(*pixels));",
          "5861:     GetOpenMPMaximumThreads()*sizeof(*kernel));",
          "5863:     {",
          "5864:       if (kernel != (float *) NULL)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "6039:       }",
          "6040:   }",
          "6041:   noise_view=DestroyCacheView(noise_view);",
          "6043:   kernel=(double *) RelinquishMagickMemory(kernel);",
          "6044:   pixels_info=RelinquishVirtualMemory(pixels_info);",
          "6045:   if (status == MagickFalse)",
          "",
          "[Removed Lines]",
          "6042:   image_view=DestroyCacheView(image_view);",
          "",
          "[Added Lines]",
          "6040:   image_view=DestroyCacheView(image_view);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "571a5605cbc24e57a6d22dec0fa5ce38dd482465",
      "candidate_info": {
        "commit_hash": "571a5605cbc24e57a6d22dec0fa5ce38dd482465",
        "repo": "ImageMagick/ImageMagick",
        "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/571a5605cbc24e57a6d22dec0fa5ce38dd482465",
        "files": [
          "MagickCore/fx.c"
        ],
        "message": "...",
        "before_after_code_files": [
          "MagickCore/fx.c||MagickCore/fx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "MagickCore/fx.c||MagickCore/fx.c"
          ],
          "candidate": [
            "MagickCore/fx.c||MagickCore/fx.c"
          ]
        }
      },
      "candidate_diff": {
        "MagickCore/fx.c||MagickCore/fx.c": [
          "File: MagickCore/fx.c -> MagickCore/fx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5765: %",
          "5769:   const size_t stride,const size_t size,const size_t scale,float *kernel)",
          "5770: {",
          "5771:   const float",
          "",
          "[Removed Lines]",
          "5768: static inline void HatTransform(const float *magick_restrict pixels,",
          "",
          "[Added Lines]",
          "5768: static inline void HatTransform(const float *magick_restrict pixels,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5808:   CacheView",
          "5812:   float",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5812:   double",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "5855:   if (AcquireMagickResource(WidthResource,4*image->columns) == MagickFalse)",
          "5856:     ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "5857:   pixels_info=AcquireVirtualMemory(3*image->columns,image->rows*",
          "5860:     ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "5861:   pixels=(float *) GetVirtualMemoryBlob(pixels_info);",
          "5862:   status=MagickTrue;",
          "",
          "[Removed Lines]",
          "5858:     sizeof(*pixels));",
          "5859:   if (pixels_info == (MemoryInfo *) NULL)",
          "",
          "[Added Lines]",
          "5861:     sizeof(*pixels));",
          "5862:   kernel=(double *) AcquireQuantumMemory(MagickMax(image->rows,image->columns),",
          "5863:     GetOpenMPMaximumThreads()*sizeof(*kernel));",
          "5864:   if ((pixels_info == (MemoryInfo *) NULL) || (kernel == (double *) NULL))",
          "5865:     {",
          "5866:       if (kernel != (double *) NULL)",
          "5867:         kernel=(double *) RelinquishMagickMemory(kernel);",
          "5868:       if (pixels_info != (MemoryInfo *) NULL)",
          "5869:         pixels_info=RelinquishVirtualMemory(pixels_info);",
          "5870:       ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "5868:     register ssize_t",
          "5869:       i;",
          "5871:     size_t",
          "5872:       low_pass;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5882:     size_t",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "5908:       Low pass filter outputs are called approximation kernel & high pass",
          "5909:       filters are referred to as detail kernel. The detail kernel",
          "5910:       have high values in the noisy parts of the signal.",
          "5912:     low_pass=0;",
          "5913:     for (level=0; level < 5; level++)",
          "5915:       float",
          "5916:         magnitude;",
          "5925:       ssize_t",
          "5926:         x,",
          "5927:         y;",
          "5934:       high_pass=4*(size_t) number_pixels-low_pass;",
          "5935: #if defined(MAGICKCORE_OPENMP_SUPPORT)",
          "5937:         magick_threads(image,image,image->columns,1)",
          "5945: #if defined(MAGICKCORE_OPENMP_SUPPORT)",
          "5947:         magick_threads(image,image,image->rows,1)",
          "5951:           image->columns,(size_t) (1 << level),pixels+pass+y);",
          "5953:         To threshold, each coefficient is compared to a threshold value and",
          "5954:         attenuated / shrunk by some factor.",
          "5961:       for (i=0; i < (ssize_t) number_pixels; i++)",
          "5968:           softness*magnitude,0.0f),difference);",
          "5969:       }",
          "5970:     }",
          "",
          "[Removed Lines]",
          "5914:     {",
          "5918:       register ssize_t",
          "5919:         i;",
          "5921:       size_t",
          "5922:         pass,",
          "5923:         high_pass;",
          "5930:         Filter horizontally and transpose.",
          "5932:       low_pass=(size_t) number_pixels*(2*(level & 0x01)+1),",
          "5933:       pass=2*(size_t) number_pixels,",
          "5936:       #pragma omp parallel for schedule(static,1) \\",
          "5938: #endif",
          "5939:       for (x=0; x < (ssize_t) image->columns; x++)",
          "5940:         HatTransform(pixels+pass+x*image->rows,image->columns,image->rows,",
          "5941:           (size_t) (1 << level),pixels+low_pass+x);",
          "5943:         Filter vertically and transpose.",
          "5946:       #pragma omp parallel for schedule(static,1) \\",
          "5948: #endif",
          "5949:       for (y=0; y < (ssize_t) image->rows; y++)",
          "5950:         HatTransform(pixels+high_pass+y*image->columns,image->rows,",
          "5956:       magnitude=threshold*noise_levels[level];",
          "5957: #if defined(MAGICKCORE_OPENMP_SUPPORT)",
          "5958:       #pragma omp parallel for schedule(static,1) \\",
          "5959:         magick_threads(image,image,image->columns,1)",
          "5960: #endif",
          "5962:       {",
          "5963:         float",
          "5964:           difference;",
          "5966:         difference=pixels[low_pass]-pixels[high_pass];",
          "5967:         pixels[i]+=copysignf(fmaxf(fabsf(difference)-magnitude-",
          "",
          "[Added Lines]",
          "5926:     {",
          "5936:       #pragma omp parallel for schedule(static,1) \\",
          "5938: #endif",
          "5939:       for (y=0; y < (ssize_t) image->rows; y++)",
          "5940:       {",
          "5941:         const int",
          "5942:           id = GetOpenMPThreadId();",
          "5944:         register ssize_t",
          "5945:           x;",
          "5947:         HatTransform(pixels+y*image->columns+high_pass,1,image->columns,",
          "5948:           (size_t) (1 << level),kernel+id*image->columns);",
          "5949:         for (x=0; x < (ssize_t) image->columns; x++)",
          "5950:           pixels[y*image->columns+x+low_pass]=kernel[id*image->columns+x];",
          "5953:       #pragma omp parallel for schedule(static,1) \\",
          "5955: #endif",
          "5956:       for (x=0; x < (ssize_t) image->columns; x++)",
          "5957:       {",
          "5958:         const int",
          "5959:           id = GetOpenMPThreadId();",
          "5961:         register ssize_t",
          "5962:           y;",
          "5964:         HatTransform(pixels+x+low_pass,image->columns,image->rows,(size_t)",
          "5965:           (1 << level),kernel+id*image->rows);",
          "5966:         for (y=0; y < (ssize_t) image->rows; y++)",
          "5967:           pixels[y*image->columns+x+low_pass]=kernel[id*image->rows+y];",
          "5973:       magnitude=threshold*noise_levels[level];",
          "5975:       {",
          "5976:         pixels[high_pass+i]-=pixels[low_pass+i];",
          "5977:         if (pixels[high_pass+i] < -magnitude)",
          "5978:           pixels[high_pass+i]+=magnitude-softness*magnitude;",
          "5979:         else",
          "5980:           if (pixels[high_pass+i] > magnitude)",
          "5981:             pixels[high_pass+i]-=magnitude-softness*magnitude;",
          "5982:           else",
          "5983:             pixels[high_pass+i]*=softness;",
          "5984:         if (high_pass != 0)",
          "5986:       }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "6021:       }",
          "6022:   }",
          "6023:   noise_view=DestroyCacheView(noise_view);",
          "6024:   image_view=DestroyCacheView(image_view);",
          "6025:   pixels_info=RelinquishVirtualMemory(pixels_info);",
          "6026:   if (status == MagickFalse)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6042:   image_view=DestroyCacheView(image_view);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c175941c171b5985ee33a4a9c988b2a4e8767b16",
      "candidate_info": {
        "commit_hash": "c175941c171b5985ee33a4a9c988b2a4e8767b16",
        "repo": "ImageMagick/ImageMagick",
        "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/c175941c171b5985ee33a4a9c988b2a4e8767b16",
        "files": [
          "Magick++/lib/Image.cpp",
          "MagickCore/fx.c",
          "MagickCore/fx.h",
          "MagickWand/mogrify.c",
          "MagickWand/operation.c",
          "PerlMagick/Magick.xs",
          "PerlMagick/demo/demo.pl",
          "PerlMagick/quantum/quantum.xs.in"
        ],
        "message": "Support softness parameter for -wavelet-denoise option",
        "before_after_code_files": [
          "Magick++/lib/Image.cpp||Magick++/lib/Image.cpp",
          "MagickCore/fx.c||MagickCore/fx.c",
          "MagickCore/fx.h||MagickCore/fx.h",
          "MagickWand/mogrify.c||MagickWand/mogrify.c",
          "MagickWand/operation.c||MagickWand/operation.c",
          "PerlMagick/Magick.xs||PerlMagick/Magick.xs",
          "PerlMagick/demo/demo.pl||PerlMagick/demo/demo.pl",
          "PerlMagick/quantum/quantum.xs.in||PerlMagick/quantum/quantum.xs.in"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "MagickCore/fx.c||MagickCore/fx.c",
            "PerlMagick/demo/demo.pl||PerlMagick/demo/demo.pl"
          ],
          "candidate": [
            "MagickCore/fx.c||MagickCore/fx.c",
            "PerlMagick/demo/demo.pl||PerlMagick/demo/demo.pl"
          ]
        }
      },
      "candidate_diff": {
        "Magick++/lib/Image.cpp||Magick++/lib/Image.cpp": [
          "File: Magick++/lib/Image.cpp -> Magick++/lib/Image.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "4810:   GetPPException;",
          "4812:   replaceImage(newImage);",
          "4813:   ThrowImageException;",
          "4814: }",
          "",
          "[Removed Lines]",
          "4811:   newImage=WaveletDenoiseImage(constImage(),threshold_,exceptionInfo);",
          "",
          "[Added Lines]",
          "4811:   newImage=WaveletDenoiseImage(constImage(),threshold_,0.0,exceptionInfo);",
          "",
          "---------------"
        ],
        "MagickCore/fx.c||MagickCore/fx.c": [
          "File: MagickCore/fx.c -> MagickCore/fx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5741: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "5742: %",
          "5743: %  WaveletDenoiseImage() removes noise from the image using a wavelet",
          "5745: %",
          "5746: %  The format of the WaveletDenoiseImage method is:",
          "5747: %",
          "5750: %",
          "5751: %  A description of each parameter follows:",
          "5752: %",
          "5753: %    o image: the image.",
          "5754: %",
          "5756: %",
          "5757: %    o exception: return any errors or warnings in this structure.",
          "5758: %",
          "5763: {",
          "5765:     i;",
          "5773: }",
          "5775: MagickExport Image *WaveletDenoiseImage(const Image *image,",
          "5777: {",
          "5778:   CacheView",
          "5785:   double",
          "5788:   Image",
          "5797:   size_t",
          "5798:     channel;",
          "5808:     Initialize noise image attributes.",
          "",
          "[Removed Lines]",
          "5744: %  transform. Adapted from dcraw.c by David Coffin.",
          "5748: %      Image *WaveletDenoiseImage(const Image *image, const double threshold,",
          "5749: %        ExceptionInfo *exception)",
          "5755: %    o threahold: defines the threshold for smoothing.",
          "5761: static inline void hat_transform(double *temp,double *base,ssize_t st,",
          "5762:   ssize_t size,ssize_t sc)",
          "5764:   ssize_t",
          "5767:   for (i = 0; i < sc; i++)",
          "5768:     temp[i]=2*base[st * i]+base[st*(sc - i)]+base[st*(i+sc)];",
          "5769:   for (; i + sc < size; i++)",
          "5770:     temp[i]=2*base[st*i]+base[st*(i-sc)]+base[st*(i+sc)];",
          "5771:   for (; i < size; i++)",
          "5772:     temp[i]=2*base[st*i]+base[st*(i-sc)]+base[st*(2*size-2-(i+sc))];",
          "5776:   const double threshold,ExceptionInfo *exception)",
          "5782:   const Quantum",
          "5791:   MemoryInfo",
          "5794:   Quantum",
          "5800:   ssize_t",
          "5801:     size,",
          "5802:     thread_count;",
          "5804:   static const double",
          "5805:     noise[]={0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044};",
          "",
          "[Added Lines]",
          "5744: %  WaveletDenoiseImage() removes noise from the image using a wavelet",
          "5745: %  transform.  The wavelet transform is a fast hierarchical scheme for",
          "5746: %  processing an image using a set of consecutive lowpass and high_pass filters,",
          "5747: %  followed by a decimation.  This results in a decomposition into different",
          "5748: %  scales which can be regarded as different \u201cfrequency bands\u201d, determined by",
          "5752: %",
          "5753: %      Image *WaveletDenoiseImage(const Image *image,const double threshold,",
          "5759: %",
          "5760: %    o threshold: set the threshold for smoothing.",
          "5761: %",
          "5768: static inline void HatTransform(const float *restrict pixels,const size_t width,",
          "5770: {",
          "5775:     Lowpass filter outputs are called approximation coefficients & highigh_pass",
          "5776:     filters are referred to as detail coefficients.  The detail coefficients",
          "5777:     have high values in the noisy parts of the signal.",
          "5779:   for (i=0; i < (ssize_t) radius; i++)",
          "5780:     coefficients[i]=2.0*pixels[width*i]+pixels[width*(radius-i)]+",
          "5781:       pixels[width*(i+radius)];",
          "5782:   for ( ; (i+radius) < (ssize_t) height; i++)",
          "5783:     coefficients[i]=2.0*pixels[width*i]+pixels[width*(i-radius)]+",
          "5784:       pixels[width*(i+radius)];",
          "5785:   for ( ; i < (ssize_t) height; i++)",
          "5786:     coefficients[i]=2.0*pixels[width*i]+pixels[width*(i-radius)]+",
          "5790: MagickExport Image *WaveletDenoiseImage(const Image *image,",
          "5800:   float",
          "5806:   MagickBooleanType",
          "5809:   MagickSizeType",
          "5810:     number_pixels;",
          "5812:   MemoryInfo",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5827:       noise_image=DestroyImage(noise_image);",
          "5828:       return((Image *) NULL);",
          "5829:     }",
          "5855:     {",
          "5857:       ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "5858:     }",
          "5862:   {",
          "5870:     size_t",
          "5875:     ssize_t",
          "5878:       y;",
          "5884:     {",
          "5901:         {",
          "5904:         }",
          "5906:     }",
          "5909:     {",
          "5911: #if defined(MAGICKCORE_OPENMP_SUPPORT)",
          "5913:         magick_threads(image,image,image->rows,1)",
          "5914: #endif",
          "5916:       {",
          "5917:         double",
          "5930:       }",
          "5931: #if defined(MAGICKCORE_OPENMP_SUPPORT)",
          "5933:         magick_threads(image,image,image->columns,1)",
          "5934: #endif",
          "5936:       {",
          "5937:         double",
          "5950:       }",
          "5953:       {",
          "5959:         else",
          "5963:       }",
          "5965:     }",
          "5969:     {",
          "5985:     }",
          "5988:   noise_view=DestroyCacheView(noise_view);",
          "5989:   image_view=DestroyCacheView(image_view);",
          "5992:   return(noise_image);",
          "5993: }",
          "",
          "[Removed Lines]",
          "5831:   image_view=AcquireAuthenticCacheView(image,exception);",
          "5832:   noise_view=AcquireAuthenticCacheView(noise_image,exception);",
          "5834:   p=GetCacheViewAuthenticPixels(image_view,0,0,image->columns,image->rows,",
          "5835:     exception);",
          "5836:   q=GetCacheViewAuthenticPixels(noise_view,0,0,noise_image->columns,",
          "5837:     noise_image->rows,exception);",
          "5839:   thread_count=1;",
          "5840: #if defined(MAGICKCORE_OPENMP_SUPPORT)",
          "5841: #pragma omp parallel magick_threads(image,image,image->rows,1)",
          "5842:   {",
          "5843: #pragma omp single",
          "5844:     {",
          "5845:       thread_count = omp_get_num_threads();",
          "5846:     }",
          "5847:   }",
          "5848: #endif",
          "5851:   size=image->columns*image->rows;",
          "5852:   interImage_info=AcquireVirtualMemory((size*3+(image->rows+image->columns)*",
          "5853:     thread_count),sizeof(*interImage));",
          "5854:   if (interImage_info == (MemoryInfo *) NULL)",
          "5856:       interImage_info=RelinquishVirtualMemory(interImage_info);",
          "5859:   interImage=(double *)GetVirtualMemoryBlob(interImage_info);",
          "5861:   for (channel = 0; channel < 3; ++channel)",
          "5863:     double",
          "5864:       thold,",
          "5867:     register const Quantum",
          "5871:       hpass,",
          "5872:       lev,",
          "5873:       lpass;",
          "5876:       i,",
          "5877:       x,",
          "5880:     tmpBase=interImage+3*size;",
          "5882:     pp=p;",
          "5883:     switch (channel)",
          "5885:       case 0:",
          "5886:         for (i = 0; i < (ssize_t) size; ++i)",
          "5887:         {",
          "5888:           interImage[i]=GetPixelRed(image,pp);",
          "5889:           pp+=image->number_channels;",
          "5890:         }",
          "5891:         break;",
          "5892:       case 1:",
          "5893:         for (i = 0; i < (ssize_t) size; ++i)",
          "5894:         {",
          "5895:           interImage[i]=GetPixelGreen(image,pp);",
          "5896:           pp+=image->number_channels;",
          "5897:         }",
          "5898:         break;",
          "5899:       case 2:",
          "5900:         for (i = 0; i < (ssize_t) size; ++i)",
          "5902:           interImage[i]=GetPixelBlue(image,pp);",
          "5903:           pp+=image->number_channels;",
          "5905:         break;",
          "5907:     hpass=0;",
          "5908:     for (lev = 0; lev < 5; lev++)",
          "5910:       lpass=size*((lev & 1)+1);",
          "5912:       #pragma omp parallel for schedule(static,1) private(x,y) \\",
          "5915:       for (y = 0; y < (ssize_t) image->rows; ++y)",
          "5920:         tmp=tmpBase;",
          "5921: #if defined(MAGICKCORE_OPENMP_SUPPORT)",
          "5922:         tmp+=(image->rows+image->columns)*omp_get_thread_num();",
          "5923: #endif",
          "5924:         hat_transform(tmp,interImage+hpass+y*image->columns,1,",
          "5925:           (ssize_t) image->columns,(ssize_t)(1 << lev));",
          "5926:         for (x = 0; x < (ssize_t) image->columns; ++x)",
          "5927:         {",
          "5928:           interImage[lpass+y*image->columns+x]=tmp[x]*0.25;",
          "5929:         }",
          "5932:       #pragma omp parallel for schedule(static,1) private(x,y) \\",
          "5935:       for (x = 0; x < (ssize_t) image->columns; ++x)",
          "5940:         tmp=tmpBase;",
          "5941: #if defined(MAGICKCORE_OPENMP_SUPPORT)",
          "5942:         tmp+=(image->rows+image->columns)*omp_get_thread_num();",
          "5943: #endif",
          "5944:         hat_transform(tmp,interImage+lpass+x,(ssize_t) image->columns,",
          "5945:           (ssize_t) image->rows,(ssize_t)(1 << lev));",
          "5946:         for (y = 0; y < (ssize_t) image->rows; ++y)",
          "5947:         {",
          "5948:           interImage[lpass+y*image->columns+x]=tmp[y]*0.25;",
          "5949:         }",
          "5951:       thold=threshold*noise[lev];",
          "5952:       for (i = 0; i < (ssize_t) size; ++i)",
          "5954:         interImage[hpass+i]-=interImage[lpass+i];",
          "5955:         if (interImage[hpass+i] < -thold)",
          "5956:           interImage[hpass+i]+=thold;",
          "5957:         else if (interImage[hpass+i] > thold)",
          "5958:           interImage[hpass+i]-=thold;",
          "5960:           interImage[hpass+i]=0;",
          "5961:         if (hpass)",
          "5962:           interImage[i]+=interImage[hpass+i];",
          "5964:       hpass=lpass;",
          "5968:     switch (channel)",
          "5970:       case 0:",
          "5971:         for (i = 0; i < (ssize_t) size; ++i)",
          "5972:           SetPixelRed(noise_image,ClampToQuantum(interImage[i]+",
          "5973:             interImage[i+lpass]),q+i*noise_image->number_channels);",
          "5974:         break;",
          "5975:       case 1:",
          "5976:         for (i = 0; i < (ssize_t) size; ++i)",
          "5977:           SetPixelGreen(noise_image,ClampToQuantum(interImage[i]+",
          "5978:             interImage[i+lpass]),q+i*noise_image->number_channels);",
          "5979:         break;",
          "5980:       case 2:",
          "5981:         for (i = 0; i < (ssize_t) size; ++i)",
          "5982:           SetPixelBlue(noise_image,ClampToQuantum(interImage[i]+",
          "5983:             interImage[i+lpass]),q+i*noise_image->number_channels);",
          "5984:         break;",
          "5986:   }",
          "5990:   interImage_info=RelinquishVirtualMemory(interImage_info);",
          "",
          "[Added Lines]",
          "5838:     }",
          "5839:   if (AcquireMagickResource(WidthResource,3*image->columns) == MagickFalse)",
          "5840:     ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "5841:   wavelet_pixels_info=AcquireVirtualMemory(3*image->columns,",
          "5842:     image->rows*sizeof(*wavelet_pixels));",
          "5843:   coefficients=(double *) AcquireQuantumMemory(MagickMax(image->rows,",
          "5844:     image->columns),GetOpenMPMaximumThreads()*sizeof(*coefficients));",
          "5845:   if ((wavelet_pixels_info == (MemoryInfo *) NULL) ||",
          "5847:     {",
          "5848:       if (coefficients != (double *) NULL)",
          "5849:         coefficients=(double *) RelinquishMagickMemory(coefficients);",
          "5850:       if (wavelet_pixels_info != (MemoryInfo *) NULL)",
          "5853:     }",
          "5854:   wavelet_pixels=(float *) GetVirtualMemoryBlob(wavelet_pixels_info);",
          "5855:   status=MagickTrue;",
          "5856:   number_pixels=image->columns*image->rows;",
          "5857:   image_view=AcquireAuthenticCacheView(image,exception);",
          "5858:   noise_view=AcquireAuthenticCacheView(noise_image,exception);",
          "5860:   {",
          "5861:     register ssize_t",
          "5864:     size_t",
          "5865:       high_pass,",
          "5868:     ssize_t",
          "5872:     if (status == MagickFalse)",
          "5873:       continue;",
          "5874:     if (GetPixelChannelTraits(image,channel) == UndefinedPixelTrait)",
          "5875:       continue;",
          "5877:       Copy channel from image to wavelet pixel array.",
          "5879:     i=0;",
          "5881:     {",
          "5882:       register const Quantum",
          "5885:       ssize_t",
          "5886:         x;",
          "5888:       p=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);",
          "5890:         {",
          "5891:           status=MagickFalse;",
          "5893:         }",
          "5894:       for (x=0; x < (ssize_t) image->columns; x++)",
          "5895:       {",
          "5896:         wavelet_pixels[i]=(float) p[channel]; break;",
          "5897:         i++;",
          "5898:         p+=GetPixelChannels(image);",
          "5902:       Low pass filter outputs are called approximation coefficients & high pass",
          "5903:       filters are referred to as detail coefficients. The detail coefficients",
          "5904:       have high values in the noisy parts of the signal.",
          "5906:     high_pass=0;",
          "5908:     {",
          "5909:       double",
          "5910:         magnitude,",
          "5911:         standard_deviation[5];",
          "5913:       ssize_t",
          "5914:         x,",
          "5915:         y;",
          "5917:       size_t",
          "5918:         samples[5];",
          "5921: #if defined(MAGICKCORE_OPENMP_SUPPORT)",
          "5924: #endif",
          "5926:       {",
          "5927:         const int",
          "5928:           id = GetOpenMPThreadId();",
          "5933:         register ssize_t",
          "5934:           x;",
          "5936:         p=coefficients+id*image->columns;",
          "5937:         HatTransform(wavelet_pixels+y*image->columns+high_pass,1,image->columns,",
          "5938:           1UL << level,p);",
          "5939:         for (x=0; x < (ssize_t) image->columns; x++)",
          "5942: #if defined(MAGICKCORE_OPENMP_SUPPORT)",
          "5945: #endif",
          "5947:       {",
          "5948:         const int",
          "5949:           id = GetOpenMPThreadId();",
          "5954:         register ssize_t",
          "5955:           y;",
          "5957:         p=coefficients+id*image->rows;",
          "5958:         HatTransform(wavelet_pixels+x+low_pass,image->columns,image->rows,",
          "5959:           1UL << level,p);",
          "5960:         for (y=0; y < (ssize_t) image->rows; y++)",
          "5964:         Compute standard deviations for all intensities.",
          "5966:       magnitude=5.0/0.8002*(1 << 6)*exp(-2.6*sqrt((double) level+1.0))/",
          "5967:         exp(-2.6);",
          "5968:       (void) ResetMagickMemory(standard_deviation,0,sizeof(standard_deviation));",
          "5969:       (void) ResetMagickMemory(samples,0,sizeof(samples));",
          "5971:       {",
          "5972:         double",
          "5973:           sample_squared;",
          "5975:         wavelet_pixels[high_pass+i]-=wavelet_pixels[low_pass+i];",
          "5976:         if ((wavelet_pixels[high_pass+i] > magnitude) &&",
          "5977:             (wavelet_pixels[high_pass+i] < -magnitude))",
          "5978:           continue;",
          "5979:         sample_squared=wavelet_pixels[high_pass+i]*wavelet_pixels[high_pass+i];",
          "5980:         if (wavelet_pixels[low_pass+i] > 0.8)",
          "5981:           {",
          "5982:             standard_deviation[4]+=sample_squared;",
          "5983:             samples[4]++;",
          "5985:         else",
          "5986:           if (wavelet_pixels[low_pass+i] > 0.6)",
          "5987:             {",
          "5988:               standard_deviation[3]+=sample_squared;",
          "5989:               samples[3]++;",
          "5990:             }",
          "5991:           else",
          "5992:             if (wavelet_pixels[low_pass+i] > 0.4)",
          "5993:               {",
          "5994:                 standard_deviation[2]+=sample_squared;",
          "5995:                 samples[2]++;",
          "5996:               }",
          "5997:             else",
          "5998:               if (wavelet_pixels[low_pass+i] > 0.2)",
          "5999:                 {",
          "6000:                   standard_deviation[1]+=sample_squared;",
          "6001:                   samples[1]++;",
          "6002:                 }",
          "6003:               else",
          "6004:                 {",
          "6005:                   standard_deviation[0]+=sample_squared;",
          "6006:                   samples[0]++;",
          "6008:       }",
          "6009:       for (i=0; i < 5; ++i)",
          "6010:         standard_deviation[i]=sqrt(standard_deviation[i]/(samples[i]+1));",
          "6012:         To threshold, each coefficient is compared to a threshold value and",
          "6013:         attenuated / shrunk by some factor.",
          "6015:       for (i=0; i < (ssize_t) number_pixels; ++i)",
          "6016:       {",
          "6017:         if (wavelet_pixels[low_pass+i] > 0.8)",
          "6018:           magnitude=threshold*standard_deviation[4];",
          "6019:         else",
          "6020:          if (wavelet_pixels[low_pass+i] > 0.6)",
          "6021:            magnitude=threshold*standard_deviation[3];",
          "6022:          else",
          "6023:            if (wavelet_pixels[low_pass+i] > 0.4)",
          "6024:              magnitude=threshold*standard_deviation[2];",
          "6025:            else",
          "6026:              if (wavelet_pixels[low_pass+i] > 0.2)",
          "6027:                magnitude=threshold*standard_deviation[1];",
          "6028:              else",
          "6029:                magnitude=threshold*standard_deviation[0];",
          "6030:         if (wavelet_pixels[high_pass+i] < -magnitude)",
          "6031:           wavelet_pixels[high_pass+i]+=magnitude-softness*magnitude;",
          "6032:         else",
          "6033:           if (wavelet_pixels[high_pass+i] > magnitude)",
          "6034:             wavelet_pixels[high_pass+i]-=magnitude-softness*magnitude;",
          "6035:           else",
          "6036:             wavelet_pixels[high_pass+i]*=softness;",
          "6037:         if (high_pass != 0)",
          "6038:           wavelet_pixels[i]+=wavelet_pixels[high_pass+i];",
          "6039:       }",
          "6043:       Reconstruct image from the thresholded wavelet coefficients.",
          "6045:     i=0;",
          "6047:     {",
          "6048:       MagickBooleanType",
          "6049:         sync;",
          "6051:       register Quantum",
          "6054:       register ssize_t",
          "6055:         x;",
          "6057:       q=GetCacheViewAuthenticPixels(noise_view,0,y,noise_image->columns,1,",
          "6058:         exception);",
          "6059:       if (q == (Quantum *) NULL)",
          "6060:         {",
          "6061:           status=MagickFalse;",
          "6062:           break;",
          "6063:         }",
          "6064:       for (x=0; x < (ssize_t) image->columns; x++)",
          "6065:       {",
          "6066:         float",
          "6067:           pixel;",
          "6069:         pixel=wavelet_pixels[i]+wavelet_pixels[low_pass+i];",
          "6070:         q[channel]=ClampToQuantum(pixel);",
          "6071:         i++;",
          "6072:         q+=GetPixelChannels(noise_image);",
          "6073:       }",
          "6074:       sync=SyncCacheViewAuthenticPixels(noise_view,exception);",
          "6075:       if (sync == MagickFalse)",
          "6077:     }",
          "6078:     if (image->progress_monitor != (MagickProgressMonitor) NULL)",
          "6079:       {",
          "6080:         MagickBooleanType",
          "6083:         proceed=SetImageProgress(image,AddNoiseImageTag,(MagickOffsetType)",
          "6084:           channel,GetPixelChannels(image));",
          "6085:         if (proceed == MagickFalse)",
          "6086:           status=MagickFalse;",
          "6087:       }",
          "6090:   image_view=DestroyCacheView(image_view);",
          "6091:   coefficients=(double *) RelinquishMagickMemory(coefficients);",
          "",
          "---------------"
        ],
        "MagickCore/fx.h||MagickCore/fx.h": [
          "File: MagickCore/fx.h -> MagickCore/fx.h"
        ],
        "MagickWand/mogrify.c||MagickWand/mogrify.c": [
          "File: MagickWand/mogrify.c -> MagickWand/mogrify.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3298:           }",
          "3299:         if (LocaleCompare(\"wavelet-denoise\",option+1) == 0)",
          "3300:           {",
          "3305:             flags=ParseGeometry(argv[i+1],&geometry_info);",
          "3306:             if ((flags & PercentValue) != 0)",
          "3307:               geometry_info.rho*=(double) (QuantumRange/100.0);",
          "",
          "[Removed Lines]",
          "3302:               Wavelet denoise image.",
          "3304:             (void) SyncImageSettings(mogrify_info,*image,exception);",
          "",
          "[Added Lines]",
          "3302:               Wavelet denoise image.",
          "",
          "---------------"
        ],
        "MagickWand/operation.c||MagickWand/operation.c": [
          "File: MagickWand/operation.c -> MagickWand/operation.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3544:           new_image=WaveImage(_image,geometry_info.rho,geometry_info.sigma,",
          "3545:                _image->interpolate,_exception);",
          "3546:           break;",
          "3550:           flags=ParseGeometry(arg1,&geometry_info);",
          "3551:           if ((flags & RhoValue) == 0)",
          "3552:             CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);",
          "",
          "[Removed Lines]",
          "3547:         }",
          "3548:       if (LocaleCompare(\"wavelet-denoise\",option+1) == 0)",
          "3549:         {",
          "",
          "[Added Lines]",
          "3547:         }",
          "3548:       if (LocaleCompare(\"wavelet-denoise\",option+1) == 0)",
          "",
          "---------------"
        ],
        "PerlMagick/Magick.xs||PerlMagick/Magick.xs": [
          "File: PerlMagick/Magick.xs -> PerlMagick/Magick.xs",
          "--- Hunk 1 ---",
          "[Context before]",
          "560:     { \"ConnectedComponents\", { {\"connectivity\", IntegerReference} } },",
          "561:     { \"CopyPixels\", { {\"image\", ImageReference}, {\"geometry\", StringReference},",
          "562:       {\"width\", IntegerReference}, {\"height\", IntegerReference},",
          "564:       {\"gravity\", MagickGravityOptions}, {\"offset\", StringReference},",
          "565:       {\"dx\", IntegerReference}, {\"dy\", IntegerReference} } },",
          "566:     { \"Color\", { {\"color\", StringReference} } },",
          "",
          "[Removed Lines]",
          "563:       {\"x\", IntegerReference}, {\"y\", IntegerReference},",
          "",
          "[Added Lines]",
          "563:       {\"x\", IntegerReference}, {\"y\", IntegerReference},",
          "564:       {\"gravity\", MagickGravityOptions}, {\"offset\", StringReference},",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "11328:           source_image=image;",
          "11329:           if (attribute_flag[0] != 0)",
          "11332:           if (attribute_flag[1] != 0)",
          "11337:           if (attribute_flag[3] != 0)",
          "11339:           if (attribute_flag[4] != 0)",
          "11340:             geometry.x=argument_list[4].integer_reference;",
          "11341:           if (attribute_flag[5] != 0)",
          "",
          "[Removed Lines]",
          "11330:             source_image=argument_list[0].image_reference;",
          "11331:           SetGeometry(source_image,&geometry);",
          "11333:             flags=ParseGravityGeometry(source_image,",
          "11334:               argument_list[1].string_reference,&geometry,exception);",
          "11335:           if (attribute_flag[2] != 0)",
          "11336:             geometry.width=argument_list[2].integer_reference;",
          "11338:             geometry.height=argument_list[3].integer_reference;",
          "",
          "[Added Lines]",
          "11331:             source_image=argument_list[0].image_reference;",
          "11332:           SetGeometry(source_image,&geometry);",
          "11333:           if (attribute_flag[1] != 0)",
          "11334:             flags=ParseGravityGeometry(source_image,",
          "11335:               argument_list[1].string_reference,&geometry,exception);",
          "11337:             geometry.width=argument_list[2].integer_reference;",
          "11338:           if (attribute_flag[3] != 0)",
          "11339:             geometry.height=argument_list[3].integer_reference;",
          "11341:             geometry.x=argument_list[4].integer_reference;",
          "11342:           if (attribute_flag[5] != 0)",
          "",
          "---------------"
        ],
        "PerlMagick/demo/demo.pl||PerlMagick/demo/demo.pl": [
          "File: PerlMagick/demo/demo.pl -> PerlMagick/demo/demo.pl",
          "--- Hunk 1 ---",
          "[Context before]",
          "484: print \"WaveletDenoise...\\n\";",
          "485: $example=$model->Clone();",
          "486: $example->Label('WaveletDenoise');",
          "488: push(@$images,$example);",
          "490: #",
          "",
          "[Removed Lines]",
          "487: $example->WaveletDenoise();",
          "",
          "[Added Lines]",
          "487: $example->WaveletDenoise('0.1x0.1');",
          "",
          "---------------"
        ],
        "PerlMagick/quantum/quantum.xs.in||PerlMagick/quantum/quantum.xs.in": [
          "File: PerlMagick/quantum/quantum.xs.in -> PerlMagick/quantum/quantum.xs.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "560:     { \"ConnectedComponents\", { {\"connectivity\", IntegerReference} } },",
          "561:     { \"CopyPixels\", { {\"image\", ImageReference}, {\"geometry\", StringReference},",
          "562:       {\"width\", IntegerReference}, {\"height\", IntegerReference},",
          "564:       {\"gravity\", MagickGravityOptions}, {\"offset\", StringReference},",
          "565:       {\"dx\", IntegerReference}, {\"dy\", IntegerReference} } },",
          "566:     { \"Color\", { {\"color\", StringReference} } },",
          "",
          "[Removed Lines]",
          "563:       {\"x\", IntegerReference}, {\"y\", IntegerReference},",
          "",
          "[Added Lines]",
          "563:       {\"x\", IntegerReference}, {\"y\", IntegerReference},",
          "564:       {\"gravity\", MagickGravityOptions}, {\"offset\", StringReference},",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "11328:           source_image=image;",
          "11329:           if (attribute_flag[0] != 0)",
          "11332:           if (attribute_flag[1] != 0)",
          "11337:           if (attribute_flag[3] != 0)",
          "11339:           if (attribute_flag[4] != 0)",
          "11340:             geometry.x=argument_list[4].integer_reference;",
          "11341:           if (attribute_flag[5] != 0)",
          "",
          "[Removed Lines]",
          "11330:             source_image=argument_list[0].image_reference;",
          "11331:           SetGeometry(source_image,&geometry);",
          "11333:             flags=ParseGravityGeometry(source_image,",
          "11334:               argument_list[1].string_reference,&geometry,exception);",
          "11335:           if (attribute_flag[2] != 0)",
          "11336:             geometry.width=argument_list[2].integer_reference;",
          "11338:             geometry.height=argument_list[3].integer_reference;",
          "",
          "[Added Lines]",
          "11331:             source_image=argument_list[0].image_reference;",
          "11332:           SetGeometry(source_image,&geometry);",
          "11333:           if (attribute_flag[1] != 0)",
          "11334:             flags=ParseGravityGeometry(source_image,",
          "11335:               argument_list[1].string_reference,&geometry,exception);",
          "11337:             geometry.width=argument_list[2].integer_reference;",
          "11338:           if (attribute_flag[3] != 0)",
          "11339:             geometry.height=argument_list[3].integer_reference;",
          "11341:             geometry.x=argument_list[4].integer_reference;",
          "11342:           if (attribute_flag[5] != 0)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2d830eda5e2bbf51dd93c2ead7e1cd4291530f73",
      "candidate_info": {
        "commit_hash": "2d830eda5e2bbf51dd93c2ead7e1cd4291530f73",
        "repo": "ImageMagick/ImageMagick",
        "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/2d830eda5e2bbf51dd93c2ead7e1cd4291530f73",
        "files": [
          "MagickCore/fx.c",
          "MagickWand/convert.c",
          "MagickWand/mogrify.c",
          "PerlMagick/Magick.xs",
          "PerlMagick/demo/demo.pl",
          "PerlMagick/quantum/quantum.xs.in",
          "utilities/convert.1.in",
          "utilities/mogrify.1.in"
        ],
        "message": "Add WaveletDenoise method to PerlMagick",
        "before_after_code_files": [
          "MagickCore/fx.c||MagickCore/fx.c",
          "MagickWand/convert.c||MagickWand/convert.c",
          "MagickWand/mogrify.c||MagickWand/mogrify.c",
          "PerlMagick/Magick.xs||PerlMagick/Magick.xs",
          "PerlMagick/demo/demo.pl||PerlMagick/demo/demo.pl",
          "PerlMagick/quantum/quantum.xs.in||PerlMagick/quantum/quantum.xs.in",
          "utilities/convert.1.in||utilities/convert.1.in",
          "utilities/mogrify.1.in||utilities/mogrify.1.in"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "MagickCore/fx.c||MagickCore/fx.c",
            "PerlMagick/demo/demo.pl||PerlMagick/demo/demo.pl"
          ],
          "candidate": [
            "MagickCore/fx.c||MagickCore/fx.c",
            "PerlMagick/demo/demo.pl||PerlMagick/demo/demo.pl"
          ]
        }
      },
      "candidate_diff": {
        "MagickCore/fx.c||MagickCore/fx.c": [
          "File: MagickCore/fx.c -> MagickCore/fx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5772:     temp[i]=2*base[st*i]+base[st*(i-sc)]+base[st*(2*size-2-(i+sc))];",
          "5773: }",
          "5777: {",
          "5778:   CacheView",
          "",
          "[Removed Lines]",
          "5775: MagickExport Image *WaveletDenoiseImage(const Image *image, const double threshold,",
          "5776:   ExceptionInfo *exception)",
          "",
          "[Added Lines]",
          "5775: MagickExport Image *WaveletDenoiseImage(const Image *image,",
          "5776:   const double threshold,ExceptionInfo *exception)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5990:   interImage_info=RelinquishVirtualMemory(interImage_info);",
          "5992:   return(noise_image);",
          "",
          "[Removed Lines]",
          "5993: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "MagickWand/convert.c||MagickWand/convert.c": [
          "File: MagickWand/convert.c -> MagickWand/convert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "319:       \"-unique-colors       discard all but one of any pixel color\",",
          "320:       \"-unsharp geometry    sharpen the image\",",
          "321:       \"-vignette geometry   soften the edges of the image in vignette style\",",
          "323:       \"-wavelet-denoise threshold\",",
          "324:       \"                     removes noise from the image using a wavelet transform.\",",
          "325:       \"-white-threshold value\",",
          "",
          "[Removed Lines]",
          "322:       \"-wave geometry       alter an image along a sine wave\",",
          "",
          "[Added Lines]",
          "322:       \"-wave geometry       alter an image along a sine wave\",",
          "",
          "---------------"
        ],
        "MagickWand/mogrify.c||MagickWand/mogrify.c": [
          "File: MagickWand/mogrify.c -> MagickWand/mogrify.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3609:       \"-transpose           flip image vertically and rotate 90 degrees\",",
          "3610:       \"-transverse          flop image horizontally and rotate 270 degrees\",",
          "3611:       \"-trim                trim image edges\",",
          "3613:       \"-unique-colors       discard all but one of any pixel color\",",
          "3614:       \"-unsharp geometry    sharpen the image\",",
          "3615:       \"-vignette geometry   soften the edges of the image in vignette style\",",
          "",
          "[Removed Lines]",
          "3612:       \"-type type           image type\",",
          "",
          "[Added Lines]",
          "3612:       \"-type type           image type\",",
          "",
          "---------------"
        ],
        "PerlMagick/Magick.xs||PerlMagick/Magick.xs": [
          "File: PerlMagick/Magick.xs -> PerlMagick/Magick.xs",
          "--- Hunk 1 ---",
          "[Context before]",
          "560:     { \"ConnectedComponents\", { {\"connectivity\", IntegerReference} } },",
          "561:     { \"CopyPixels\", { {\"image\", ImageReference}, {\"geometry\", StringReference},",
          "562:       {\"width\", IntegerReference}, {\"height\", IntegerReference},",
          "563:       {\"x\", IntegerReference}, {\"y\", IntegerReference},",
          "564:       {\"gravity\", MagickGravityOptions}, {\"offset\", StringReference},",
          "565:       {\"dx\", IntegerReference}, {\"dy\", IntegerReference} } },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "563:       {\"x\", IntegerReference}, {\"y\", IntegerReference},",
          "564:       {\"gravity\", MagickGravityOptions}, {\"offset\", StringReference},",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "7582:     HaldClut           = 243",
          "7583:     HaldClutImage      = 244",
          "7584:     BlueShift          = 245",
          "7585:     BlueShiftImage     = 246",
          "7586:     ForwardFourierTransform  = 247",
          "7587:     ForwardFourierTransformImage = 248",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7587:     BlueShiftImage     = 246",
          "7588:     ForwardFourierTransform  = 247",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "11321:           RectangleInfo",
          "11322:             offset_geometry;",
          "11324:           source_image=image;",
          "11325:           if (attribute_flag[0] != 0)",
          "11326:             source_image=argument_list[0].image_reference;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11329:           if (attribute_flag[0] != 0)",
          "11330:             source_image=argument_list[0].image_reference;",
          "11331:           SetGeometry(source_image,&geometry);",
          "11332:           if (attribute_flag[1] != 0)",
          "11333:             flags=ParseGravityGeometry(source_image,",
          "11334:               argument_list[1].string_reference,&geometry,exception);",
          "11335:           if (attribute_flag[2] != 0)",
          "11336:             geometry.width=argument_list[2].integer_reference;",
          "11337:           if (attribute_flag[3] != 0)",
          "11338:             geometry.height=argument_list[3].integer_reference;",
          "11339:           if (attribute_flag[4] != 0)",
          "11340:             geometry.x=argument_list[4].integer_reference;",
          "",
          "---------------"
        ],
        "PerlMagick/demo/demo.pl||PerlMagick/demo/demo.pl": [
          "File: PerlMagick/demo/demo.pl -> PerlMagick/demo/demo.pl",
          "--- Hunk 1 ---",
          "[Context before]",
          "480: $example->Label('Wave');",
          "481: $example->Wave('25x150');",
          "482: push(@$images,$example);",
          "483: #",
          "484: # Create image montage.",
          "485: #",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "484: print \"WaveletDenoise...\\n\";",
          "485: $example=$model->Clone();",
          "486: $example->Label('WaveletDenoise');",
          "487: $example->WaveletDenoise();",
          "488: push(@$images,$example);",
          "",
          "---------------"
        ],
        "PerlMagick/quantum/quantum.xs.in||PerlMagick/quantum/quantum.xs.in": [
          "File: PerlMagick/quantum/quantum.xs.in -> PerlMagick/quantum/quantum.xs.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "560:     { \"ConnectedComponents\", { {\"connectivity\", IntegerReference} } },",
          "561:     { \"CopyPixels\", { {\"image\", ImageReference}, {\"geometry\", StringReference},",
          "562:       {\"width\", IntegerReference}, {\"height\", IntegerReference},",
          "563:       {\"x\", IntegerReference}, {\"y\", IntegerReference},",
          "564:       {\"gravity\", MagickGravityOptions}, {\"offset\", StringReference},",
          "565:       {\"dx\", IntegerReference}, {\"dy\", IntegerReference} } },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "563:       {\"x\", IntegerReference}, {\"y\", IntegerReference},",
          "564:       {\"gravity\", MagickGravityOptions}, {\"offset\", StringReference},",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "7582:     HaldClut           = 243",
          "7583:     HaldClutImage      = 244",
          "7584:     BlueShift          = 245",
          "7585:     BlueShiftImage     = 246",
          "7586:     ForwardFourierTransform  = 247",
          "7587:     ForwardFourierTransformImage = 248",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7587:     BlueShiftImage     = 246",
          "7588:     ForwardFourierTransform  = 247",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "11321:           RectangleInfo",
          "11322:             offset_geometry;",
          "11324:           source_image=image;",
          "11325:           if (attribute_flag[0] != 0)",
          "11326:             source_image=argument_list[0].image_reference;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11329:           if (attribute_flag[0] != 0)",
          "11330:             source_image=argument_list[0].image_reference;",
          "11331:           SetGeometry(source_image,&geometry);",
          "11332:           if (attribute_flag[1] != 0)",
          "11333:             flags=ParseGravityGeometry(source_image,",
          "11334:               argument_list[1].string_reference,&geometry,exception);",
          "11335:           if (attribute_flag[2] != 0)",
          "11336:             geometry.width=argument_list[2].integer_reference;",
          "11337:           if (attribute_flag[3] != 0)",
          "11338:             geometry.height=argument_list[3].integer_reference;",
          "11339:           if (attribute_flag[4] != 0)",
          "11340:             geometry.x=argument_list[4].integer_reference;",
          "",
          "---------------"
        ],
        "utilities/convert.1.in||utilities/convert.1.in": [
          "File: utilities/convert.1.in -> utilities/convert.1.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "262:   \\-unsharp geometry    sharpen the image",
          "263:   \\-vignette geometry   soften the edges of the image in vignette style",
          "264:   \\-wave geometry       alter an image along a sine wave",
          "265:   \\-white-threshold value",
          "266:                        force all pixels above the threshold into white",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "265:   \\-wavelet-denoise threshold",
          "266:                         removes noise from the image using a wavelet transform",
          "",
          "---------------"
        ],
        "utilities/mogrify.1.in||utilities/mogrify.1.in": [
          "File: utilities/mogrify.1.in -> utilities/mogrify.1.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "261:   \\-unsharp geometry    sharpen the image",
          "262:   \\-vignette geometry   soften the edges of the image in vignette style",
          "263:   \\-wave geometry       alter an image along a sine wave",
          "264:   \\-white-threshold value",
          "265:                        force all pixels above the threshold into white",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "264:   \\-wavelet-denoise threshold",
          "265:                         removes noise from the image using a wavelet transform",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fe01aec2fd9bc649c67d9c941f6e78bcf3c34657",
      "candidate_info": {
        "commit_hash": "fe01aec2fd9bc649c67d9c941f6e78bcf3c34657",
        "repo": "ImageMagick/ImageMagick",
        "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/fe01aec2fd9bc649c67d9c941f6e78bcf3c34657",
        "files": [
          "MagickCore/fx.c"
        ],
        "message": "Optimize wavelet denoise algorithm",
        "before_after_code_files": [
          "MagickCore/fx.c||MagickCore/fx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "MagickCore/fx.c||MagickCore/fx.c"
          ],
          "candidate": [
            "MagickCore/fx.c||MagickCore/fx.c"
          ]
        }
      },
      "candidate_diff": {
        "MagickCore/fx.c||MagickCore/fx.c": [
          "File: MagickCore/fx.c -> MagickCore/fx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5849:     {",
          "5850:       noise_image=DestroyImage(noise_image);",
          "5851:       return((Image *) NULL);",
          "5853:   if (AcquireMagickResource(WidthResource,3*image->columns) == MagickFalse)",
          "5854:     ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "5855:   pixels_info=AcquireVirtualMemory(3*image->columns,image->rows*",
          "5866:     }",
          "5867:   pixels=(float *) GetVirtualMemoryBlob(pixels_info);",
          "5868:   status=MagickTrue;",
          "",
          "[Removed Lines]",
          "5852:     }",
          "5856:     sizeof(*pixels));",
          "5857:   kernel=(double *) AcquireQuantumMemory(MagickMax(image->rows,image->columns),",
          "5858:     GetOpenMPMaximumThreads()*sizeof(*kernel));",
          "5859:   if ((pixels_info == (MemoryInfo *) NULL) || (kernel == (double *) NULL))",
          "5860:     {",
          "5861:       if (kernel != (double *) NULL)",
          "5862:         kernel=(double *) RelinquishMagickMemory(kernel);",
          "5863:       if (pixels_info != (MemoryInfo *) NULL)",
          "5864:         pixels_info=RelinquishVirtualMemory(pixels_info);",
          "5865:       ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "",
          "[Added Lines]",
          "5851:     }",
          "5855:     sizeof(*pixels));",
          "5856:   if (pixels_info == (MemoryInfo *) NULL)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5874:     register ssize_t",
          "5875:       i;",
          "5878:       high_pass,",
          "5879:       low_pass;",
          "",
          "[Removed Lines]",
          "5877:     size_t",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "5915:       Low pass filter outputs are called approximation kernel & high pass",
          "5916:       filters are referred to as detail kernel. The detail kernel",
          "5917:       have high values in the noisy parts of the signal.",
          "5919:     high_pass=0;",
          "5920:     for (level=0; level < 5; level++)",
          "5922:       double",
          "5923:         magnitude;",
          "5929:       ssize_t",
          "5930:         x,",
          "5931:         y;",
          "5933:       low_pass=(size_t) (number_pixels*((level & 0x01)+1));",
          "5934: #if defined(MAGICKCORE_OPENMP_SUPPORT)",
          "5936:         magick_threads(image,image,image->rows,1)",
          "5952:       }",
          "5953: #if defined(MAGICKCORE_OPENMP_SUPPORT)",
          "5955:         magick_threads(image,image,image->columns,1)",
          "5973:       }",
          "5975:         To threshold, each coefficient is compared to a threshold value and",
          "5976:         attenuated / shrunk by some factor.",
          "5979:       for (i=0; i < (ssize_t) number_pixels; ++i)",
          "5990:           pixels[i]+=pixels[high_pass+i];",
          "5992:       high_pass=low_pass;",
          "5993:     }",
          "",
          "[Removed Lines]",
          "5921:     {",
          "5925:       register float",
          "5935:       #pragma omp parallel for schedule(static,1) \\",
          "5937: #endif",
          "5938:       for (y=0; y < (ssize_t) image->rows; y++)",
          "5939:       {",
          "5940:         const int",
          "5941:           id = GetOpenMPThreadId();",
          "5943:         register ssize_t",
          "5944:           x;",
          "5946:         p=kernel+id*image->columns;",
          "5947:         q=pixels+y*image->columns;",
          "5948:         HatTransform(q+high_pass,1,image->columns,1UL << level,p);",
          "5949:         q+=low_pass;",
          "5950:         for (x=0; x < (ssize_t) image->columns; x++)",
          "5954:       #pragma omp parallel for schedule(static,1) \\",
          "5956: #endif",
          "5957:       for (x=0; x < (ssize_t) image->columns; x++)",
          "5958:       {",
          "5959:         const int",
          "5960:           id = GetOpenMPThreadId();",
          "5962:         register ssize_t",
          "5963:           y;",
          "5965:         p=kernel+id*image->rows;",
          "5966:         q=pixels+x+low_pass;",
          "5967:         HatTransform(q,image->columns,image->rows,1UL << level,p);",
          "5968:         for (y=0; y < (ssize_t) image->rows; y++)",
          "5969:         {",
          "5971:           q+=image->columns;",
          "5972:         }",
          "5978:       magnitude=threshold*noise_levels[level];",
          "5980:       {",
          "5981:         pixels[high_pass+i]-=pixels[low_pass+i];",
          "5982:         if (pixels[high_pass+i] < -magnitude)",
          "5983:           pixels[high_pass+i]+=magnitude-softness*magnitude;",
          "5984:         else",
          "5985:           if (pixels[high_pass+i] > magnitude)",
          "5986:             pixels[high_pass+i]-=magnitude-softness*magnitude;",
          "5987:           else",
          "5988:             pixels[high_pass+i]*=softness;",
          "5989:         if (high_pass != 0)",
          "5991:       }",
          "",
          "[Added Lines]",
          "5911:     {",
          "5915:       register ssize_t",
          "5916:         i;",
          "5918:       size_t",
          "5919:         pass,",
          "5927:         Filter horizontally and transpose.",
          "5929:       low_pass=(size_t) number_pixels*(2*(level & 0x01)+1),",
          "5930:       pass=2*(size_t) number_pixels,",
          "5933:       #pragma omp parallel for schedule(static,1) \\",
          "5935: #endif",
          "5936:       for (x=0; x < (ssize_t) image->columns; x++)",
          "5937:         HatTransform(pixels+pass+x*image->rows,image->columns,image->rows,",
          "5938:           1UL << level,pixels+low_pass+x);",
          "5940:         Filter vertically and transpose.",
          "5943:       #pragma omp parallel for schedule(static,1) \\",
          "5945: #endif",
          "5946:       for (y=0; y < (ssize_t) image->rows; y++)",
          "5947:         HatTransform(pixels+high_pass+y*image->columns,image->rows,",
          "5953:       magnitude=threshold*noise_levels[level];",
          "5954: #if defined(MAGICKCORE_OPENMP_SUPPORT)",
          "5955:       #pragma omp parallel for schedule(static,1) \\",
          "5956:         magick_threads(image,image,image->columns,1)",
          "5957: #endif",
          "5959:       {",
          "5960:         float",
          "5961:           difference;",
          "5963:         difference=pixels[low_pass]-pixels[high_pass];",
          "5964:         pixels[i]+=copysignf(fmaxf(fabsf(difference)-magnitude,0.0f),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "6044:       }",
          "6045:   }",
          "6046:   noise_view=DestroyCacheView(noise_view);",
          "6048:   kernel=(double *) RelinquishMagickMemory(kernel);",
          "6049:   pixels_info=RelinquishVirtualMemory(pixels_info);",
          "6050:   if (status == MagickFalse)",
          "",
          "[Removed Lines]",
          "6047:   image_view=DestroyCacheView(image_view);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
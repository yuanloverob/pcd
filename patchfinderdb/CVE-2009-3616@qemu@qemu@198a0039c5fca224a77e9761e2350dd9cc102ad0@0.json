{
  "cve_id": "CVE-2009-3616",
  "cve_desc": "Multiple use-after-free vulnerabilities in vnc.c in the VNC server in QEMU 0.10.6 and earlier might allow guest OS users to execute arbitrary code on the host OS by establishing a connection from a VNC client and then (1) disconnecting during data transfer, (2) sending a message using incorrect integer data types, or (3) using the Fuzzy Screen Mode protocol, related to double free vulnerabilities.",
  "repo": "qemu/qemu",
  "patch_hash": "198a0039c5fca224a77e9761e2350dd9cc102ad0",
  "patch_info": {
    "commit_hash": "198a0039c5fca224a77e9761e2350dd9cc102ad0",
    "repo": "qemu/qemu",
    "commit_url": "https://github.com/qemu/qemu/commit/198a0039c5fca224a77e9761e2350dd9cc102ad0",
    "files": [
      "vnc.c"
    ],
    "message": "vnc: rework VncState release workflow.\n\nSplit socket closing and releasing of VncState into two steps.  First\nclose the socket and set the variable to -1 to indicate shutdown in\nprogress.  Do the actual release in a few places where we can be sure it\ndoesn't cause trouble in form of use-after-free.  Add some checks for a\nvalid socket handle to make sure we don't try to use the closed socket.\n\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\nSigned-off-by: Anthony Liguori <aliguori@us.ibm.com>",
    "before_after_code_files": [
      "vnc.c||vnc.c"
    ]
  },
  "patch_diff": {
    "vnc.c||vnc.c": [
      "File: vnc.c -> vnc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "218: static void vnc_update_client(void *opaque);",
      "220: static void vnc_colordepth(VncState *vs);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "219: static void vnc_disconnect_start(VncState *vs);",
      "220: static void vnc_disconnect_finish(VncState *vs);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "653: static void vnc_copy(VncState *vs, int src_x, int src_y, int dst_x, int dst_y, int w, int h)",
      "654: {",
      "659:     vnc_write_u8(vs, 0);",
      "",
      "[Removed Lines]",
      "655:     vs->force_update = 1;",
      "656:     vnc_update_client(vs);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "667: static void vnc_dpy_copy(DisplayState *ds, int src_x, int src_y, int dst_x, int dst_y, int w, int h)",
      "668: {",
      "669:     VncDisplay *vd = ds->opaque;",
      "672:         if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT))",
      "673:             vnc_copy(vs, src_x, src_y, dst_x, dst_y, w, h);",
      "675:             vnc_update(vs, dst_x, dst_y, w, h);",
      "677:     }",
      "678: }",
      "",
      "[Removed Lines]",
      "670:     VncState *vs = vd->clients;",
      "671:     while (vs != NULL) {",
      "676:         vs = vs->next;",
      "",
      "[Added Lines]",
      "669:     VncState *vs, *vn;",
      "671:     for (vs = vd->clients; vs != NULL; vs = vn) {",
      "672:         vn = vs->next;",
      "673:         if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT)) {",
      "674:             vs->force_update = 1;",
      "675:             vnc_update_client(vs);",
      "677:         }",
      "678:     }",
      "680:     for (vs = vd->clients; vs != NULL; vs = vs->next) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "799:     if (vs->csock != -1) {",
      "800:         qemu_mod_timer(vs->timer, qemu_get_clock(rt_clock) + VNC_REFRESH_INTERVAL);",
      "801:     }",
      "803: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "809:     } else {",
      "810:         vnc_disconnect_finish(vs);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "868:     }",
      "869: }",
      "872: int vnc_client_io_error(VncState *vs, int ret, int last_errno)",
      "873: {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "881: static void vnc_disconnect_start(VncState *vs)",
      "882: {",
      "883:     if (vs->csock == -1)",
      "884:         return;",
      "885:     qemu_set_fd_handler2(vs->csock, NULL, NULL, NULL, NULL);",
      "886:     closesocket(vs->csock);",
      "887:     vs->csock = -1;",
      "888: }",
      "890: static void vnc_disconnect_finish(VncState *vs)",
      "891: {",
      "892:     qemu_del_timer(vs->timer);",
      "893:     qemu_free_timer(vs->timer);",
      "894:     if (vs->input.buffer) qemu_free(vs->input.buffer);",
      "895:     if (vs->output.buffer) qemu_free(vs->output.buffer);",
      "896: #ifdef CONFIG_VNC_TLS",
      "897:     vnc_tls_client_cleanup(vs);",
      "899: #ifdef CONFIG_VNC_SASL",
      "900:     vnc_sasl_client_cleanup(vs);",
      "902:     audio_del(vs);",
      "904:     VncState *p, *parent = NULL;",
      "905:     for (p = vs->vd->clients; p != NULL; p = p->next) {",
      "906:         if (p == vs) {",
      "907:             if (parent)",
      "908:                 parent->next = p->next;",
      "909:             else",
      "910:                 vs->vd->clients = p->next;",
      "911:             break;",
      "912:         }",
      "913:         parent = p;",
      "914:     }",
      "915:     if (!vs->vd->clients)",
      "916:         dcl->idle = 1;",
      "918:     qemu_free(vs->server.ds->data);",
      "919:     qemu_free(vs->server.ds);",
      "920:     qemu_free(vs->guest.ds);",
      "921:     qemu_free(vs);",
      "922: }",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "885:             }",
      "886:         }",
      "922:         return 0;",
      "923:     }",
      "",
      "[Removed Lines]",
      "888:         VNC_DEBUG(\"Closing down client sock %d %d\\n\", ret, ret < 0 ? last_errno : 0);",
      "889:         qemu_set_fd_handler2(vs->csock, NULL, NULL, NULL, NULL);",
      "890:         closesocket(vs->csock);",
      "891:         qemu_del_timer(vs->timer);",
      "892:         qemu_free_timer(vs->timer);",
      "893:         if (vs->input.buffer) qemu_free(vs->input.buffer);",
      "894:         if (vs->output.buffer) qemu_free(vs->output.buffer);",
      "895: #ifdef CONFIG_VNC_TLS",
      "896:         vnc_tls_client_cleanup(vs);",
      "898: #ifdef CONFIG_VNC_SASL",
      "899:         vnc_sasl_client_cleanup(vs);",
      "901:         audio_del(vs);",
      "903:         VncState *p, *parent = NULL;",
      "904:         for (p = vs->vd->clients; p != NULL; p = p->next) {",
      "905:             if (p == vs) {",
      "906:                 if (parent)",
      "907:                     parent->next = p->next;",
      "908:                 else",
      "909:                     vs->vd->clients = p->next;",
      "910:                 break;",
      "911:             }",
      "912:             parent = p;",
      "913:         }",
      "914:         if (!vs->vd->clients)",
      "915:             dcl->idle = 1;",
      "917:         qemu_free(vs->server.ds->data);",
      "918:         qemu_free(vs->server.ds);",
      "919:         qemu_free(vs->guest.ds);",
      "920:         qemu_free(vs);",
      "",
      "[Added Lines]",
      "940:         VNC_DEBUG(\"Closing down client sock: ret %d, errno %d\\n\",",
      "941:                   ret, ret < 0 ? last_errno : 0);",
      "942:         vnc_disconnect_start(vs);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "928: void vnc_client_error(VncState *vs)",
      "929: {",
      "931: }",
      "",
      "[Removed Lines]",
      "930:     vnc_client_io_error(vs, -1, EINVAL);",
      "",
      "[Added Lines]",
      "952:     VNC_DEBUG(\"Closing down client sock: protocol error\\n\");",
      "953:     vnc_disconnect_start(vs);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "1110:     else",
      "1112:         ret = vnc_client_read_plain(vs);",
      "1114:         return;",
      "1116:     while (vs->read_handler && vs->input.offset >= vs->read_handler_expect) {",
      "1117:         size_t len = vs->read_handler_expect;",
      "1118:         int ret;",
      "1120:         ret = vs->read_handler(vs, vs->input.buffer, len);",
      "1122:             return;",
      "1124:         if (!ret) {",
      "1125:             memmove(vs->input.buffer, vs->input.buffer + len, (vs->input.offset - len));",
      "",
      "[Removed Lines]",
      "1113:     if (!ret)",
      "1121:         if (vs->csock == -1)",
      "",
      "[Added Lines]",
      "1136:     if (!ret) {",
      "1137:         if (vs->csock == -1)",
      "1138:             vnc_disconnect_finish(vs);",
      "1140:     }",
      "1147:         if (vs->csock == -1) {",
      "1148:             vnc_disconnect_finish(vs);",
      "1150:         }",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "1134: {",
      "1135:     buffer_reserve(&vs->output, len);",
      "1138:         qemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, vnc_client_write, vs);",
      "1139:     }",
      "",
      "[Removed Lines]",
      "1137:     if (buffer_empty(&vs->output)) {",
      "",
      "[Added Lines]",
      "1165:     if (vs->csock != -1 && buffer_empty(&vs->output)) {",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "1176: void vnc_flush(VncState *vs)",
      "1177: {",
      "1179:         vnc_client_write(vs);",
      "1180: }",
      "",
      "[Removed Lines]",
      "1178:     if (vs->output.offset)",
      "",
      "[Added Lines]",
      "1206:     if (vs->csock != -1 && vs->output.offset)",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "2009:     vnc_write(vs, \"RFB 003.008\\n\", 12);",
      "2010:     vnc_flush(vs);",
      "2011:     vnc_read_when(vs, protocol_version, 12);",
      "2013:     reset_keys(vs);",
      "2015:     vs->next = vd->clients;",
      "2016:     vd->clients = vs;",
      "2017: }",
      "2019: static void vnc_listen_read(void *opaque)",
      "",
      "[Removed Lines]",
      "2012:     vnc_update_client(vs);",
      "",
      "[Added Lines]",
      "2045:     vnc_update_client(vs);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7d957bd8cbcbf56f7916d375e65042d767f544b5",
      "candidate_info": {
        "commit_hash": "7d957bd8cbcbf56f7916d375e65042d767f544b5",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/7d957bd8cbcbf56f7916d375e65042d767f544b5",
        "files": [
          "console.c",
          "console.h",
          "curses.c",
          "hw/cirrus_vga.c",
          "hw/nseries.c",
          "hw/palm.c",
          "hw/vga.c",
          "hw/vga_int.h",
          "qemu-common.h",
          "sdl.c",
          "vl.c",
          "vnc.c"
        ],
        "message": "DisplayState interface change (Stefano Stabellini)\n\nThis patch changes the DisplayState interface adding support for\nmultiple frontends at the same time (sdl and vnc) and implements most\nof the benefit of the shared_buf patch without the added complexity.\n\nCurrently DisplayState is managed by sdl (or vnc) and sdl (or vnc) is\nalso responsible for allocating the data and setting the depth.\nVga.c (or another backend) will do any necessary conversion.\n\nThe idea is to change it so that is vga.c (or another backend) together\nwith console.c that fully manage the DisplayState interface allocating\ndata and setting the depth (either 16 or 32 bit, if the guest uses a\ndifferent resolution or is in text mode, vga.c (or another backend) is\nin charge of doing the conversion seamlessly).\n\nThe other idea is that DisplayState supports *multiple* frontends\nlike sdl and vnc; each of them can register some callbacks to be called\nwhen a display event occurs.\n\nThe interesting changes are:\n\n- the new structures and related functions in console.h and console.c\n\nin particular the following functions are very helpful to manage a\nDisplaySurface:\n\nqemu_create_displaysurface\nqemu_resize_displaysurface\nqemu_create_displaysurface_from\nqemu_free_displaysurface\n\n- console_select and qemu_console_resize in console.c\nthis two functions manage multiple consoles on a single host display\n\n- moving code around in hw/vga.c\nas for the shared_buf patch this is necessary to be able to handle a dynamic\nDisplaySurface bpp\n\n- changes to vga_draw_graphic in hw/vga.c\nthis is the place where the DisplaySurface buffer is shared with the\nvideoram, when possible;\n\n\nCompared to the last version the only changes are:\n\n- do not remove support to dpy_copy in cirrus_vga\n- change the name of the displaysurface handling functions\n\nSigned-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>\nSigned-off-by: Anthony Liguori <aliguori@us.ibm.com>\n\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@6336 c046a42c-6fe2-441c-8c8c-71466251a162",
        "before_after_code_files": [
          "console.c||console.c",
          "console.h||console.h",
          "curses.c||curses.c",
          "hw/cirrus_vga.c||hw/cirrus_vga.c",
          "hw/nseries.c||hw/nseries.c",
          "hw/palm.c||hw/palm.c",
          "hw/vga.c||hw/vga.c",
          "hw/vga_int.h||hw/vga_int.h",
          "qemu-common.h||qemu-common.h",
          "sdl.c||sdl.c",
          "vl.c||vl.c",
          "vnc.c||vnc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "vnc.c||vnc.c"
          ],
          "candidate": [
            "vnc.c||vnc.c"
          ]
        }
      },
      "candidate_diff": {
        "console.c||console.c": [
          "File: console.c -> console.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1045:     if (index >= MAX_CONSOLES)",
          "1046:         return;",
          "1047:     s = consoles[index];",
          "1048:     if (s) {",
          "1049:         active_console = s;",
          "1053:         vga_hw_invalidate();",
          "1054:     }",
          "1055: }",
          "",
          "[Removed Lines]",
          "1050:         if (s->console_type != TEXT_CONSOLE && s->g_width && s->g_height",
          "1051:             && (s->g_width != ds_get_width(s->ds) || s->g_height != ds_get_height(s->ds)))",
          "1052:             dpy_resize(s->ds, s->g_width, s->g_height);",
          "",
          "[Added Lines]",
          "1047:     active_console->g_width = ds_get_width(active_console->ds);",
          "1048:     active_console->g_height = ds_get_height(active_console->ds);",
          "1051:         DisplayState *ds = s->ds;",
          "1053:         ds->surface = qemu_resize_displaysurface(ds->surface, s->g_width,",
          "1054:                                                 s->g_height, 32, 4 * s->g_width);",
          "1055:         dpy_resize(s->ds);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1157: static void text_console_invalidate(void *opaque)",
          "1158: {",
          "1159:     TextConsole *s = (TextConsole *) opaque;",
          "1170:     console_refresh(s);",
          "1171: }",
          "",
          "[Removed Lines]",
          "1161:     if (s->g_width != ds_get_width(s->ds) || s->g_height != ds_get_height(s->ds)) {",
          "1162:         if (s->console_type == TEXT_CONSOLE_FIXED_SIZE)",
          "1163:             dpy_resize(s->ds, s->g_width, s->g_height);",
          "1164:         else {",
          "1165:             s->g_width = ds_get_width(s->ds);",
          "1166:             s->g_height = ds_get_height(s->ds);",
          "1167:             text_console_resize(s);",
          "1168:         }",
          "1169:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1347: void qemu_console_resize(QEMUConsole *console, int width, int height)",
          "1348: {",
          "1356:     }",
          "1357: }",
          "",
          "[Removed Lines]",
          "1349:     if (console->g_width != width || console->g_height != height",
          "1350:         || !ds_get_data(console->ds)) {",
          "1351:         console->g_width = width;",
          "1352:         console->g_height = height;",
          "1353:         if (active_console == console) {",
          "1354:             dpy_resize(console->ds, width, height);",
          "1355:         }",
          "",
          "[Added Lines]",
          "1342:     console->g_width = width;",
          "1343:     console->g_height = height;",
          "1344:     if (active_console == console) {",
          "1345:         DisplayState *ds = console->ds;",
          "1346:         ds->surface = qemu_resize_displaysurface(ds->surface, width, height, 32, 4 * width);",
          "1347:         dpy_resize(console->ds);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1360:                 int dst_x, int dst_y, int w, int h)",
          "1361: {",
          "1362:     if (active_console == console) {",
          "1370:     }",
          "1371: }",
          "",
          "[Removed Lines]",
          "1363:         if (console->ds->dpy_copy)",
          "1364:             console->ds->dpy_copy(console->ds,",
          "1365:                             src_x, src_y, dst_x, dst_y, w, h);",
          "1366:         else {",
          "1368:             console->ds->dpy_update(console->ds, dst_x, dst_y, w, h);",
          "1369:         }",
          "",
          "[Added Lines]",
          "1355:             dpy_copy(console->ds, src_x, src_y, dst_x, dst_y, w, h);",
          "1359: static PixelFormat qemu_default_pixelformat(int bpp)",
          "1360: {",
          "1361:     PixelFormat pf;",
          "1363:     memset(&pf, 0x00, sizeof(PixelFormat));",
          "1365:     pf.bits_per_pixel = bpp;",
          "1366:     pf.bytes_per_pixel = bpp / 8;",
          "1367:     pf.depth = bpp == 32 ? 24 : bpp;",
          "1369:     switch (bpp) {",
          "1370:         case 8:",
          "1371:             pf.rmask = 0x000000E0;",
          "1372:             pf.gmask = 0x0000001C;",
          "1373:             pf.bmask = 0x00000003;",
          "1374:             pf.rmax = 7;",
          "1375:             pf.gmax = 7;",
          "1376:             pf.bmax = 3;",
          "1377:             pf.rshift = 5;",
          "1378:             pf.gshift = 2;",
          "1379:             pf.bshift = 0;",
          "1380:             break;",
          "1381:         case 16:",
          "1382:             pf.rmask = 0x0000F800;",
          "1383:             pf.gmask = 0x000007E0;",
          "1384:             pf.bmask = 0x0000001F;",
          "1385:             pf.rmax = 31;",
          "1386:             pf.gmax = 63;",
          "1387:             pf.bmax = 31;",
          "1388:             pf.rshift = 11;",
          "1389:             pf.gshift = 5;",
          "1390:             pf.bshift = 0;",
          "1391:             break;",
          "1392:         case 24:",
          "1393:         case 32:",
          "1394:             pf.rmask = 0x00FF0000;",
          "1395:             pf.gmask = 0x0000FF00;",
          "1396:             pf.bmask = 0x000000FF;",
          "1397:             pf.rmax = 255;",
          "1398:             pf.gmax = 255;",
          "1399:             pf.bmax = 255;",
          "1400:             pf.rshift = 16;",
          "1401:             pf.gshift = 8;",
          "1402:             pf.bshift = 0;",
          "1403:             break;",
          "1404:         default:",
          "1405:             break;",
          "1406:     }",
          "1407:     return pf;",
          "1408: }",
          "1410: DisplaySurface* qemu_create_displaysurface(int width, int height, int bpp, int linesize)",
          "1411: {",
          "1412:     DisplaySurface *surface = (DisplaySurface*) qemu_mallocz(sizeof(DisplaySurface));",
          "1413:     if (surface == NULL) {",
          "1414:         fprintf(stderr, \"qemu_create_displaysurface: malloc failed\\n\");",
          "1415:         exit(1);",
          "1416:     }",
          "1418:     surface->width = width;",
          "1419:     surface->height = height;",
          "1420:     surface->linesize = linesize;",
          "1421:     surface->pf = qemu_default_pixelformat(bpp);",
          "1422: #ifdef WORDS_BIGENDIAN",
          "1423:     surface->flags = QEMU_ALLOCATED_FLAG | QEMU_BIG_ENDIAN_FLAG;",
          "1424: #else",
          "1425:     surface->flags = QEMU_ALLOCATED_FLAG;",
          "1426: #endif",
          "1427:     surface->data = (uint8_t*) qemu_mallocz(surface->linesize * surface->height);",
          "1428:     if (surface->data == NULL) {",
          "1429:         fprintf(stderr, \"qemu_create_displaysurface: malloc failed\\n\");",
          "1430:         exit(1);",
          "1431:     }",
          "1433:     return surface;",
          "1434: }",
          "1436: DisplaySurface* qemu_resize_displaysurface(DisplaySurface *surface,",
          "1437:                                           int width, int height, int bpp, int linesize)",
          "1438: {",
          "1439:     surface->width = width;",
          "1440:     surface->height = height;",
          "1441:     surface->linesize = linesize;",
          "1442:     surface->pf = qemu_default_pixelformat(bpp);",
          "1443:     if (surface->flags & QEMU_ALLOCATED_FLAG)",
          "1444:         surface->data = (uint8_t*) qemu_realloc(surface->data, surface->linesize * surface->height);",
          "1445:     else",
          "1446:         surface->data = (uint8_t*) qemu_malloc(surface->linesize * surface->height);",
          "1447:     if (surface->data == NULL) {",
          "1448:         fprintf(stderr, \"qemu_resize_displaysurface: malloc failed\\n\");",
          "1449:         exit(1);",
          "1450:     }",
          "1451: #ifdef WORDS_BIGENDIAN",
          "1452:     surface->flags = QEMU_ALLOCATED_FLAG | QEMU_BIG_ENDIAN_FLAG;",
          "1453: #else",
          "1454:     surface->flags = QEMU_ALLOCATED_FLAG;",
          "1455: #endif",
          "1457:     return surface;",
          "1458: }",
          "1460: DisplaySurface* qemu_create_displaysurface_from(int width, int height, int bpp,",
          "1461:                                               int linesize, uint8_t *data)",
          "1462: {",
          "1463:     DisplaySurface *surface = (DisplaySurface*) qemu_mallocz(sizeof(DisplaySurface));",
          "1464:     if (surface == NULL) {",
          "1465:         fprintf(stderr, \"qemu_create_displaysurface_from: malloc failed\\n\");",
          "1466:         exit(1);",
          "1467:     }",
          "1469:     surface->width = width;",
          "1470:     surface->height = height;",
          "1471:     surface->linesize = linesize;",
          "1472:     surface->pf = qemu_default_pixelformat(bpp);",
          "1473: #ifdef WORDS_BIGENDIAN",
          "1474:     surface->flags = QEMU_BIG_ENDIAN_FLAG;",
          "1475: #endif",
          "1476:     surface->data = data;",
          "1478:     return surface;",
          "1479: }",
          "1481: void qemu_free_displaysurface(DisplaySurface *surface)",
          "1482: {",
          "1483:     if (surface == NULL)",
          "1484:         return;",
          "1485:     if (surface->flags & QEMU_ALLOCATED_FLAG)",
          "1486:         qemu_free(surface->data);",
          "1487:     qemu_free(surface);",
          "1488: }",
          "",
          "---------------"
        ],
        "console.h||console.h": [
          "File: console.h -> console.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "81:     int width;",
          "82:     int height;",
          "85:     uint64_t gui_timer_interval;",
          "88:     void (*dpy_update)(struct DisplayState *s, int x, int y, int w, int h);",
          "90:     void (*dpy_refresh)(struct DisplayState *s);",
          "91:     void (*dpy_copy)(struct DisplayState *s, int src_x, int src_y,",
          "92:                      int dst_x, int dst_y, int w, int h);",
          "93:     void (*dpy_fill)(struct DisplayState *s, int x, int y,",
          "94:                      int w, int h, uint32_t c);",
          "95:     void (*dpy_text_cursor)(struct DisplayState *s, int x, int y);",
          "96:     void (*mouse_set)(int x, int y, int on);",
          "97:     void (*cursor_define)(int width, int height, int bpp, int hot_x, int hot_y,",
          "98:                           uint8_t *image, uint8_t *mask);",
          "99: };",
          "101: static inline void dpy_update(DisplayState *s, int x, int y, int w, int h)",
          "102: {",
          "104: }",
          "107: {",
          "109: }",
          "112: {",
          "115: }",
          "117: static inline int ds_get_linesize(DisplayState *ds)",
          "118: {",
          "120: }",
          "122: static inline uint8_t* ds_get_data(DisplayState *ds)",
          "123: {",
          "125: }",
          "127: static inline int ds_get_width(DisplayState *ds)",
          "128: {",
          "130: }",
          "132: static inline int ds_get_height(DisplayState *ds)",
          "133: {",
          "135: }",
          "137: static inline int ds_get_bits_per_pixel(DisplayState *ds)",
          "138: {",
          "140: }",
          "142: static inline int ds_get_bytes_per_pixel(DisplayState *ds)",
          "143: {",
          "145: }",
          "147: typedef unsigned long console_ch_t;",
          "",
          "[Removed Lines]",
          "76: struct DisplayState {",
          "77:     uint8_t *data;",
          "78:     int linesize;",
          "79:     int depth;",
          "83:     void *opaque;",
          "84:     struct QEMUTimer *gui_timer;",
          "89:     void (*dpy_resize)(struct DisplayState *s, int w, int h);",
          "103:     s->dpy_update(s, x, y, w, h);",
          "106: static inline void dpy_resize(DisplayState *s, int w, int h)",
          "108:     s->dpy_resize(s, w, h);",
          "111: static inline void dpy_cursor(DisplayState *s, int x, int y)",
          "113:     if (s->dpy_text_cursor)",
          "114:         s->dpy_text_cursor(s, x, y);",
          "119:     return ds->linesize;",
          "124:     return ds->data;",
          "129:     return ds->width;",
          "134:     return ds->height;",
          "139:     return ds->depth;",
          "144:     return (ds->depth / 8);",
          "",
          "[Added Lines]",
          "76: #define QEMU_BIG_ENDIAN_FLAG    0x01",
          "77: #define QEMU_ALLOCATED_FLAG     0x02",
          "79: struct PixelFormat {",
          "80:     uint8_t bits_per_pixel;",
          "81:     uint8_t bytes_per_pixel;",
          "83:     uint32_t rmask, gmask, bmask, amask;",
          "84:     uint8_t rshift, gshift, bshift, ashift;",
          "85:     uint8_t rmax, gmax, bmax, amax;",
          "86: };",
          "88: struct DisplaySurface {",
          "89:     uint8_t flags;",
          "93:     uint8_t *data;",
          "95:     struct PixelFormat pf;",
          "96: };",
          "98: struct DisplayChangeListener {",
          "99:     int idle;",
          "103:     void (*dpy_resize)(struct DisplayState *s);",
          "104:     void (*dpy_setdata)(struct DisplayState *s);",
          "112:     struct DisplayChangeListener *next;",
          "113: };",
          "115: struct DisplayState {",
          "116:     struct DisplaySurface *surface;",
          "117:     void *opaque;",
          "118:     struct QEMUTimer *gui_timer;",
          "120:     struct DisplayChangeListener* listeners;",
          "127: DisplaySurface* qemu_create_displaysurface(int width, int height, int bpp, int linesize);",
          "128: DisplaySurface* qemu_resize_displaysurface(DisplaySurface *surface,",
          "129:                                            int width, int height, int bpp, int linesize);",
          "130: DisplaySurface* qemu_create_displaysurface_from(int width, int height, int bpp,",
          "131:                                                 int linesize, uint8_t *data);",
          "132: void qemu_free_displaysurface(DisplaySurface *surface);",
          "134: static inline int is_buffer_shared(DisplaySurface *surface)",
          "135: {",
          "136:     return (!(surface->flags & QEMU_ALLOCATED_FLAG));",
          "137: }",
          "139: static inline void register_displaychangelistener(DisplayState *ds, DisplayChangeListener *dcl)",
          "140: {",
          "141:     dcl->next = ds->listeners;",
          "142:     ds->listeners = dcl;",
          "143: }",
          "147:     struct DisplayChangeListener *dcl = s->listeners;",
          "148:     while (dcl != NULL) {",
          "149:         dcl->dpy_update(s, x, y, w, h);",
          "150:         dcl = dcl->next;",
          "151:     }",
          "154: static inline void dpy_resize(DisplayState *s)",
          "156:     struct DisplayChangeListener *dcl = s->listeners;",
          "157:     while (dcl != NULL) {",
          "158:         dcl->dpy_resize(s);",
          "159:         dcl = dcl->next;",
          "160:     }",
          "163: static inline void dpy_setdata(DisplayState *s)",
          "165:     struct DisplayChangeListener *dcl = s->listeners;",
          "166:     while (dcl != NULL) {",
          "167:         if (dcl->dpy_setdata) dcl->dpy_setdata(s);",
          "168:         dcl = dcl->next;",
          "169:     }",
          "170: }",
          "172: static inline void dpy_refresh(DisplayState *s)",
          "173: {",
          "174:     struct DisplayChangeListener *dcl = s->listeners;",
          "175:     while (dcl != NULL) {",
          "176:         if (dcl->dpy_refresh) dcl->dpy_refresh(s);",
          "177:         dcl = dcl->next;",
          "178:     }",
          "179: }",
          "181: static inline void dpy_copy(struct DisplayState *s, int src_x, int src_y,",
          "182:                              int dst_x, int dst_y, int w, int h) {",
          "183:     struct DisplayChangeListener *dcl = s->listeners;",
          "184:     while (dcl != NULL) {",
          "185:         if (dcl->dpy_copy)",
          "186:             dcl->dpy_copy(s, src_x, src_y, dst_x, dst_y, w, h);",
          "188:             dcl->dpy_update(s, dst_x, dst_y, w, h);",
          "189:         dcl = dcl->next;",
          "190:     }",
          "191: }",
          "193: static inline void dpy_fill(struct DisplayState *s, int x, int y,",
          "194:                              int w, int h, uint32_t c) {",
          "195:     struct DisplayChangeListener *dcl = s->listeners;",
          "196:     while (dcl != NULL) {",
          "197:         if (dcl->dpy_fill) dcl->dpy_fill(s, x, y, w, h, c);",
          "198:         dcl = dcl->next;",
          "199:     }",
          "200: }",
          "202: static inline void dpy_cursor(struct DisplayState *s, int x, int y) {",
          "203:     struct DisplayChangeListener *dcl = s->listeners;",
          "204:     while (dcl != NULL) {",
          "205:         if (dcl->dpy_text_cursor) dcl->dpy_text_cursor(s, x, y);",
          "206:         dcl = dcl->next;",
          "207:     }",
          "212:     return ds->surface->linesize;",
          "217:     return ds->surface->data;",
          "222:     return ds->surface->width;",
          "227:     return ds->surface->height;",
          "232:     return ds->surface->pf.bits_per_pixel;",
          "237:     return ds->surface->pf.bytes_per_pixel;",
          "",
          "---------------"
        ],
        "curses.c||curses.c": [
          "File: curses.c -> curses.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "97:     }",
          "98: }",
          "101: {",
          "103:         return;",
          "108:     curses_calc_pad();",
          "109: }",
          "",
          "[Removed Lines]",
          "100: static void curses_resize(DisplayState *ds, int w, int h)",
          "102:     if (w == gwidth && h == gheight)",
          "105:     gwidth = w;",
          "106:     gheight = h;",
          "",
          "[Added Lines]",
          "100: static void curses_resize(DisplayState *ds)",
          "102:     if (ds_get_width(ds) == gwidth && ds_get_height(ds) == gheight)",
          "105:     gwidth = ds_get_width(ds);",
          "106:     gheight = ds_get_height(ds);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "169:         clear();",
          "170:         refresh();",
          "171:         curses_calc_pad();",
          "174:         vga_hw_invalidate();",
          "175:         invalidate = 0;",
          "176:     }",
          "",
          "[Removed Lines]",
          "172:         ds->width = FONT_WIDTH * width;",
          "173:         ds->height = FONT_HEIGHT * height;",
          "",
          "[Added Lines]",
          "172:         ds->surface->width = FONT_WIDTH * width;",
          "173:         ds->surface->height = FONT_HEIGHT * height;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "197:             refresh();",
          "198:             curses_calc_pad();",
          "199:             curses_update(ds, 0, 0, width, height);",
          "202:             continue;",
          "203:         }",
          "204: #endif",
          "",
          "[Removed Lines]",
          "200:             ds->width = FONT_WIDTH * width;",
          "201:             ds->height = FONT_HEIGHT * height;",
          "",
          "[Added Lines]",
          "200:             ds->surface->width = FONT_WIDTH * width;",
          "201:             ds->surface->height = FONT_HEIGHT * height;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "339: void curses_display_init(DisplayState *ds, int full_screen)",
          "340: {",
          "341: #ifndef _WIN32",
          "342:     if (!isatty(1)) {",
          "343:         fprintf(stderr, \"We need a terminal output\\n\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "341:     DisplayChangeListener *dcl;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "357: #endif",
          "358: #endif",
          "370:     invalidate = 1;",
          "374: }",
          "",
          "[Removed Lines]",
          "360:     ds->data = (void *) screen;",
          "361:     ds->linesize = 0;",
          "362:     ds->depth = 0;",
          "363:     ds->width = 640;",
          "364:     ds->height = 400;",
          "365:     ds->dpy_update = curses_update;",
          "366:     ds->dpy_resize = curses_resize;",
          "367:     ds->dpy_refresh = curses_refresh;",
          "368:     ds->dpy_text_cursor = curses_cursor_position;",
          "373:     curses_resize(ds, 80, 25);",
          "",
          "[Added Lines]",
          "361:     dcl = (DisplayChangeListener *) qemu_mallocz(sizeof(DisplayChangeListener));",
          "362:     if (!dcl)",
          "363:         exit(1);",
          "364:     dcl->dpy_update = curses_update;",
          "365:     dcl->dpy_resize = curses_resize;",
          "366:     dcl->dpy_refresh = curses_refresh;",
          "367:     dcl->dpy_text_cursor = curses_cursor_position;",
          "368:     register_displaychangelistener(ds, dcl);",
          "369:     qemu_free_displaysurface(ds->surface);",
          "370:     ds->surface = qemu_create_displaysurface_from(80, 25, 0, 0, (uint8_t*) screen);",
          "375:     curses_resize(ds);",
          "",
          "---------------"
        ],
        "hw/cirrus_vga.c||hw/cirrus_vga.c": [
          "File: hw/cirrus_vga.c -> hw/cirrus_vga.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "793:     if (BLTUNSAFE(s))",
          "794:         return 0;",
          "813:     return 1;",
          "814: }",
          "",
          "[Removed Lines]",
          "796:     if (s->ds->dpy_copy) {",
          "797:  cirrus_do_copy(s, s->cirrus_blt_dstaddr - s->start_addr,",
          "798:          s->cirrus_blt_srcaddr - s->start_addr,",
          "799:          s->cirrus_blt_width, s->cirrus_blt_height);",
          "800:     } else {",
          "801:  (*s->cirrus_rop) (s, s->vram_ptr +",
          "802:                 (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),",
          "803:      s->vram_ptr +",
          "804:                 (s->cirrus_blt_srcaddr & s->cirrus_addr_mask),",
          "805:      s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,",
          "806:      s->cirrus_blt_width, s->cirrus_blt_height);",
          "808:  cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,",
          "809:      s->cirrus_blt_dstpitch, s->cirrus_blt_width,",
          "810:      s->cirrus_blt_height);",
          "811:     }",
          "",
          "[Added Lines]",
          "796:     cirrus_do_copy(s, s->cirrus_blt_dstaddr - s->start_addr,",
          "797:             s->cirrus_blt_srcaddr - s->start_addr,",
          "798:             s->cirrus_blt_width, s->cirrus_blt_height);",
          "",
          "---------------"
        ],
        "hw/nseries.c||hw/nseries.c": [
          "File: hw/nseries.c -> hw/nseries.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1361:        will set the size once configured, so this just sets an initial",
          "1364: }",
          "1366: static struct arm_boot_info n800_binfo = {",
          "",
          "[Removed Lines]",
          "1363:     dpy_resize(ds, 800, 480);",
          "",
          "[Added Lines]",
          "1363:     ds->surface = qemu_resize_displaysurface(ds->surface, 800, 480, 32, 4 * 800);",
          "1364:     dpy_resize(ds);",
          "",
          "---------------"
        ],
        "hw/palm.c||hw/palm.c": [
          "File: hw/palm.c -> hw/palm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "278:        will set the size once configured, so this just sets an initial",
          "281: }",
          "283: QEMUMachine palmte_machine = {",
          "",
          "[Removed Lines]",
          "280:     dpy_resize(ds, 320, 320);",
          "",
          "[Added Lines]",
          "280:     ds->surface = qemu_resize_displaysurface(ds->surface, 320, 320, 32, 4 * 320);",
          "281:     dpy_resize(ds);",
          "",
          "---------------"
        ],
        "hw/vga.c||hw/vga.c": [
          "File: hw/vga.c -> hw/vga.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1244: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1246: typedef unsigned int rgb_to_pixel_dup_func(unsigned int r, unsigned int g, unsigned b);",
          "1248: static rgb_to_pixel_dup_func *rgb_to_pixel_dup_table[NB_DEPTHS];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1267:     vga_dirty_log_stop(s);",
          "1273:     v = s->sr[3];",
          "1274:     offset = (((v >> 4) & 1) | ((v << 1) & 6)) * 8192 * 4 + 2;",
          "",
          "[Removed Lines]",
          "1269:     full_update |= update_palette16(s);",
          "1270:     palette = s->last_palette;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1303:     }",
          "1305:     if (width != s->last_width || height != s->last_height ||",
          "1307:         s->last_scr_width = width * cw;",
          "1308:         s->last_scr_height = height * cheight;",
          "1309:         qemu_console_resize(s->console, s->last_scr_width, s->last_scr_height);",
          "1310:         s->last_width = width;",
          "1311:         s->last_height = height;",
          "1312:         s->last_ch = cheight;",
          "1313:         s->last_cw = cw;",
          "1314:         full_update = 1;",
          "1315:     }",
          "1316:     cursor_offset = ((s->cr[0x0e] << 8) | s->cr[0x0f]) - s->start_addr;",
          "1317:     if (cursor_offset != s->cursor_offset ||",
          "1318:         s->cr[0xa] != s->cursor_start ||",
          "",
          "[Removed Lines]",
          "1306:         cw != s->last_cw || cheight != s->last_ch) {",
          "",
          "[Added Lines]",
          "1307:         cw != s->last_cw || cheight != s->last_ch || s->last_depth) {",
          "1311:         s->last_depth = 0;",
          "1318:     s->rgb_to_pixel =",
          "1319:         rgb_to_pixel_dup_table[get_depth_index(s->ds)];",
          "1320:     full_update |= update_palette16(s);",
          "1321:     palette = s->last_palette;",
          "1322:     x_incr = cw * ((ds_get_bits_per_pixel(s->ds) + 7) >> 3);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1504:     vga_draw_line32_16bgr,",
          "1505: };",
          "1509: static rgb_to_pixel_dup_func *rgb_to_pixel_dup_table[NB_DEPTHS] = {",
          "1510:     rgb_to_pixel8_dup,",
          "1511:     rgb_to_pixel15_dup,",
          "",
          "[Removed Lines]",
          "1507: typedef unsigned int rgb_to_pixel_dup_func(unsigned int r, unsigned int g, unsigned b);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1581: static void vga_draw_graphic(VGAState *s, int full_update)",
          "1582: {",
          "1584:     int width, height, shift_control, line_offset, page0, page1, bwidth, bits;",
          "1585:     int disp_width, multi_scan, multi_run;",
          "1586:     uint8_t *d;",
          "",
          "[Removed Lines]",
          "1583:     int y1, y, update, page_min, page_max, linesize, y_start, double_scan, mask;",
          "",
          "[Added Lines]",
          "1589:     int y1, y, update, page_min, page_max, linesize, y_start, double_scan, mask, depth;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1663:     }",
          "1664:     vga_draw_line = vga_draw_line_table[v * NB_DEPTHS + get_depth_index(s->ds)];",
          "1669:         s->last_scr_width = disp_width;",
          "1670:         s->last_scr_height = height;",
          "1671:         s->last_width = disp_width;",
          "1672:         s->last_height = height;",
          "1673:         full_update = 1;",
          "1674:     }",
          "1676:         s->cursor_invalidate(s);",
          "1678:     line_offset = s->line_offset;",
          "",
          "[Removed Lines]",
          "1666:     if (disp_width != s->last_width ||",
          "1667:         height != s->last_height) {",
          "1668:         qemu_console_resize(s->console, disp_width, height);",
          "1675:     if (s->cursor_invalidate)",
          "",
          "[Added Lines]",
          "1672:     depth = s->get_bpp(s);",
          "1673:     if (s->line_offset != s->last_line_offset ||",
          "1674:         disp_width != s->last_width ||",
          "1675:         height != s->last_height ||",
          "1676:         s->last_depth != depth) {",
          "1677:         if (depth == 16 || depth == 32) {",
          "1678:             if (is_graphic_console()) {",
          "1679:                 qemu_free_displaysurface(s->ds->surface);",
          "1680:                 s->ds->surface = qemu_create_displaysurface_from(disp_width, height, depth,",
          "1681:                                                                s->line_offset,",
          "1682:                                                                s->vram_ptr + (s->start_addr * 4));",
          "1683:                 dpy_resize(s->ds);",
          "1684:             } else {",
          "1685:                 qemu_console_resize(s->console, disp_width, height);",
          "1686:             }",
          "1687:         } else {",
          "1688:             qemu_console_resize(s->console, disp_width, height);",
          "1689:         }",
          "1694:         s->last_line_offset = s->line_offset;",
          "1695:         s->last_depth = depth;",
          "1697:     } else if (is_graphic_console() && is_buffer_shared(s->ds->surface) &&",
          "1698:                (full_update || s->ds->surface->data != s->vram_ptr + (s->start_addr * 4))) {",
          "1699:         s->ds->surface->data = s->vram_ptr + (s->start_addr * 4);",
          "1700:         dpy_setdata(s->ds);",
          "1703:     s->rgb_to_pixel =",
          "1704:         rgb_to_pixel_dup_table[get_depth_index(s->ds)];",
          "1706:     if (!is_buffer_shared(s->ds->surface) && s->cursor_invalidate)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1718:                 page_min = page0;",
          "1719:             if (page1 > page_max)",
          "1720:                 page_max = page1;",
          "1724:         } else {",
          "1725:             if (y_start >= 0) {",
          "",
          "[Removed Lines]",
          "1721:             vga_draw_line(s, d, s->vram_ptr + addr, width);",
          "1722:             if (s->cursor_draw_line)",
          "1723:                 s->cursor_draw_line(s, d, y);",
          "",
          "[Added Lines]",
          "1752:             if (!(is_buffer_shared(s->ds->surface))) {",
          "1753:                 vga_draw_line(s, d, s->vram_ptr + addr, width);",
          "1754:                 if (s->cursor_draw_line)",
          "1755:                     s->cursor_draw_line(s, d, y);",
          "1756:             }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1767:         return;",
          "1768:     vga_dirty_log_stop(s);",
          "1770:     if (ds_get_bits_per_pixel(s->ds) == 8)",
          "1771:         val = s->rgb_to_pixel(0, 0, 0);",
          "1772:     else",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1803:     s->rgb_to_pixel =",
          "1804:         rgb_to_pixel_dup_table[get_depth_index(s->ds)];",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1793:     if (ds_get_bits_per_pixel(s->ds) == 0) {",
          "1795:     } else {",
          "1799:         full_update = 0;",
          "1800:         if (!(s->ar_index & 0x20)) {",
          "1801:             graphic_mode = GMODE_BLANK;",
          "",
          "[Removed Lines]",
          "1796:         s->rgb_to_pixel =",
          "1797:             rgb_to_pixel_dup_table[get_depth_index(s->ds)];",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1966:             cw != s->last_cw || cheight != s->last_ch) {",
          "1967:             s->last_scr_width = width * cw;",
          "1968:             s->last_scr_height = height * cheight;",
          "1970:             s->last_width = width;",
          "1971:             s->last_height = height;",
          "1972:             s->last_ch = cheight;",
          "",
          "[Removed Lines]",
          "1969:             qemu_console_resize(s->console, width, height);",
          "",
          "[Added Lines]",
          "2001:             s->ds->surface->width = width;",
          "2002:             s->ds->surface->height = height;",
          "2003:             dpy_resize(s->ds);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2047:     s->last_width = 60;",
          "2048:     s->last_height = height = 3;",
          "2049:     dpy_cursor(s->ds, -1, -1);",
          "2052:     for (dst = chardata, i = 0; i < s->last_width * height; i ++)",
          "2053:         console_write_ch(dst ++, ' ');",
          "",
          "[Removed Lines]",
          "2050:     qemu_console_resize(s->console, s->last_width, height);",
          "",
          "[Added Lines]",
          "2084:     s->ds->surface->width = s->last_width;",
          "2085:     s->ds->surface->height = height;",
          "2086:     dpy_resize(s->ds);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2505: {",
          "2506: }",
          "2509: {",
          "2514: }",
          "2516: static void vga_save_dpy_refresh(DisplayState *s)",
          "",
          "[Removed Lines]",
          "2508: static void vga_save_dpy_resize(DisplayState *s, int w, int h)",
          "2510:     s->linesize = w * 4;",
          "2511:     s->data = qemu_mallocz(h * s->linesize);",
          "2512:     vga_save_w = w;",
          "2513:     vga_save_h = h;",
          "",
          "[Added Lines]",
          "2544: static void vga_save_dpy_resize(DisplayState *s)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2570:                                    int w, int h)",
          "2571: {",
          "2572:     DisplayState *saved_ds, ds1, *ds = &ds1;",
          "2575:     vga_invalidate_display(s);",
          "2576:     saved_ds = s->ds;",
          "2578:     memset(ds, 0, sizeof(DisplayState));",
          "2586:     s->ds = ds;",
          "2587:     s->graphic_mode = -1;",
          "2588:     vga_update_display(s);",
          "2591:     s->ds = saved_ds;",
          "2592: }",
          "",
          "[Removed Lines]",
          "2579:     ds->dpy_update = vga_save_dpy_update;",
          "2580:     ds->dpy_resize = vga_save_dpy_resize;",
          "2581:     ds->dpy_refresh = vga_save_dpy_refresh;",
          "2582:     ds->depth = 32;",
          "2584:     ds->linesize = w * sizeof(uint32_t);",
          "2585:     ds->data = qemu_mallocz(h * ds->linesize);",
          "2589:     ppm_save(filename, ds->data, w, h, ds->linesize);",
          "2590:     qemu_free(ds->data);",
          "",
          "[Added Lines]",
          "2605:     DisplayChangeListener dcl;",
          "2612:     memset(&dcl, 0, sizeof(DisplayChangeListener));",
          "2613:     dcl.dpy_update = vga_save_dpy_update;",
          "2614:     dcl.dpy_resize = vga_save_dpy_resize;",
          "2615:     dcl.dpy_refresh = vga_save_dpy_refresh;",
          "2616:     register_displaychangelistener(ds, &dcl);",
          "2617:     ds->surface = qemu_create_displaysurface(ds_get_width(saved_ds),",
          "2618:             ds_get_height(saved_ds), 32, 4 * ds_get_width(saved_ds));",
          "2624:     ppm_save(filename, ds_get_data(ds), vga_save_w, vga_save_h,",
          "2625:             ds_get_linesize(ds));",
          "2627:     qemu_free_displaysurface(ds->surface);",
          "",
          "---------------"
        ],
        "hw/vga_int.h||hw/vga_int.h": [
          "File: hw/vga_int.h -> hw/vga_int.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "154:     uint32_t line_compare;                                              \\",
          "155:     uint32_t start_addr;                                                \\",
          "156:     uint32_t plane_updated;                                             \\",
          "157:     uint8_t last_cw, last_ch;                                           \\",
          "158:     uint32_t last_width, last_height; /* in chars or pixels */          \\",
          "159:     uint32_t last_scr_width, last_scr_height; /* in pixels */           \\",
          "160:     uint8_t cursor_start, cursor_end;                                   \\",
          "161:     uint32_t cursor_offset;                                             \\",
          "162:     unsigned int (*rgb_to_pixel)(unsigned int r,                        \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "157:     uint32_t last_line_offset;                                          \\",
          "161:     uint32_t last_depth; /* in bits */                                  \\",
          "",
          "---------------"
        ],
        "qemu-common.h||qemu-common.h": [
          "File: qemu-common.h -> qemu-common.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "166: typedef struct AudioState AudioState;",
          "167: typedef struct BlockDriverState BlockDriverState;",
          "168: typedef struct DisplayState DisplayState;",
          "169: typedef struct TextConsole TextConsole;",
          "170: typedef TextConsole QEMUConsole;",
          "171: typedef struct CharDriverState CharDriverState;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "169: typedef struct DisplayChangeListener DisplayChangeListener;",
          "170: typedef struct DisplaySurface DisplaySurface;",
          "171: typedef struct PixelFormat PixelFormat;",
          "",
          "---------------"
        ],
        "sdl.c||sdl.c": [
          "File: sdl.c -> sdl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: #include <signal.h>",
          "32: #endif",
          "36: static int last_vm_running;",
          "37: static int gui_saved_grab;",
          "",
          "[Removed Lines]",
          "34: static SDL_Surface *screen;",
          "",
          "[Added Lines]",
          "34: static DisplayChangeListener *dcl;",
          "35: static SDL_Surface *real_screen;",
          "36: static SDL_Surface *guest_screen = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "53: static void sdl_update(DisplayState *ds, int x, int y, int w, int h)",
          "54: {",
          "57: }",
          "60: {",
          "61:     int flags;",
          "",
          "[Removed Lines]",
          "56:     SDL_UpdateRect(screen, x, y, w, h);",
          "59: static void sdl_resize(DisplayState *ds, int w, int h)",
          "",
          "[Added Lines]",
          "57:     SDL_Rect rec;",
          "58:     rec.x = x;",
          "59:     rec.y = y;",
          "60:     rec.w = w;",
          "61:     rec.h = h;",
          "64:     SDL_BlitSurface(guest_screen, &rec, real_screen, &rec);",
          "65:     SDL_Flip(real_screen);",
          "66: }",
          "68: static void sdl_setdata(DisplayState *ds)",
          "69: {",
          "70:     SDL_Rect rec;",
          "71:     rec.x = 0;",
          "72:     rec.y = 0;",
          "73:     rec.w = real_screen->w;",
          "74:     rec.h = real_screen->h;",
          "76:     if (guest_screen != NULL) SDL_FreeSurface(guest_screen);",
          "78:     guest_screen = SDL_CreateRGBSurfaceFrom(ds_get_data(ds), ds_get_width(ds), ds_get_height(ds),",
          "79:                                             ds_get_bits_per_pixel(ds), ds_get_linesize(ds),",
          "80:                                             ds->surface->pf.rmask, ds->surface->pf.gmask,",
          "81:                                             ds->surface->pf.bmask, ds->surface->pf.amask);",
          "84: static void sdl_resize(DisplayState *ds)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "68:     if (gui_noframe)",
          "69:         flags |= SDL_NOFRAME;",
          "74:  again:",
          "77:         fprintf(stderr, \"Could not open SDL display\\n\");",
          "78:         exit(1);",
          "79:     }",
          "81:         flags &= ~SDL_HWSURFACE;",
          "82:         goto again;",
          "83:     }",
          "86:         fprintf(stderr, \"Could not open SDL display\\n\");",
          "87:         exit(1);",
          "88:     }",
          "105: }",
          "",
          "[Removed Lines]",
          "71:     width = w;",
          "72:     height = h;",
          "75:     screen = SDL_SetVideoMode(w, h, 0, flags);",
          "76:     if (!screen) {",
          "80:     if (!screen->pixels && (flags & SDL_HWSURFACE) && (flags & SDL_FULLSCREEN)) {",
          "85:     if (!screen->pixels) {",
          "89:     ds->data = screen->pixels;",
          "90:     ds->linesize = screen->pitch;",
          "91:     ds->depth = screen->format->BitsPerPixel;",
          "94:     if (ds->depth == 16) {",
          "95:         uint32_t mask;",
          "97:         mask = screen->format->Rmask;",
          "98:         mask |= screen->format->Gmask;",
          "99:         mask |= screen->format->Bmask;",
          "100:         if ((mask & 0x8000) == 0)",
          "101:             ds->depth = 15;",
          "102:     }",
          "103:     ds->width = w;",
          "104:     ds->height = h;",
          "",
          "[Added Lines]",
          "97:     real_screen = SDL_SetVideoMode(ds_get_width(ds), ds_get_height(ds), 0, flags);",
          "98:     if (!real_screen) {",
          "102:     if (!real_screen->pixels && (flags & SDL_HWSURFACE) && (flags & SDL_FULLSCREEN)) {",
          "107:     if (!real_screen->pixels) {",
          "112:     sdl_setdata(ds);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "337: static void toggle_full_screen(DisplayState *ds)",
          "338: {",
          "339:     gui_fullscreen = !gui_fullscreen;",
          "341:     if (gui_fullscreen) {",
          "342:         gui_saved_grab = gui_grab;",
          "343:         sdl_grab_start();",
          "",
          "[Removed Lines]",
          "340:     sdl_resize(ds, screen->w, screen->h);",
          "",
          "[Added Lines]",
          "348:     sdl_resize(ds);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "366:     while (SDL_PollEvent(ev)) {",
          "367:         switch (ev->type) {",
          "368:         case SDL_VIDEOEXPOSE:",
          "370:             break;",
          "371:         case SDL_KEYDOWN:",
          "372:         case SDL_KEYUP:",
          "",
          "[Removed Lines]",
          "369:             sdl_update(ds, 0, 0, screen->w, screen->h);",
          "",
          "[Added Lines]",
          "377:             sdl_update(ds, 0, 0, real_screen->w, real_screen->h);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "521:             if (ev->active.state & SDL_APPACTIVE) {",
          "522:                 if (ev->active.gain) {",
          "526:                 } else {",
          "530:                 }",
          "531:             }",
          "532:             break;",
          "",
          "[Removed Lines]",
          "524:                     ds->gui_timer_interval = 0;",
          "525:                     ds->idle = 0;",
          "528:                     ds->gui_timer_interval = 500;",
          "529:                     ds->idle = 1;",
          "",
          "[Added Lines]",
          "532:                     dcl->gui_timer_interval = 0;",
          "533:                     dcl->idle = 0;",
          "536:                     dcl->gui_timer_interval = 500;",
          "537:                     dcl->idle = 1;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "539: static void sdl_fill(DisplayState *ds, int x, int y, int w, int h, uint32_t c)",
          "540: {",
          "541:     SDL_Rect dst = { x, y, w, h };",
          "543: }",
          "545: static void sdl_mouse_warp(int x, int y, int on)",
          "",
          "[Removed Lines]",
          "542:     SDL_FillRect(screen, &dst, c);",
          "",
          "[Added Lines]",
          "550:     SDL_FillRect(real_screen, &dst, c);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "635:         exit(1);",
          "636:     }",
          "642:     ds->mouse_set = sdl_mouse_warp;",
          "643:     ds->cursor_define = sdl_mouse_define;",
          "646:     sdl_update_caption();",
          "647:     SDL_EnableKeyRepeat(250, 50);",
          "648:     gui_grab = 0;",
          "",
          "[Removed Lines]",
          "638:     ds->dpy_update = sdl_update;",
          "639:     ds->dpy_resize = sdl_resize;",
          "640:     ds->dpy_refresh = sdl_refresh;",
          "641:     ds->dpy_fill = sdl_fill;",
          "645:     sdl_resize(ds, 640, 400);",
          "",
          "[Added Lines]",
          "646:     dcl = qemu_mallocz(sizeof(DisplayChangeListener));",
          "647:     if (!dcl)",
          "648:         exit(1);",
          "649:     dcl->dpy_update = sdl_update;",
          "650:     dcl->dpy_resize = sdl_resize;",
          "651:     dcl->dpy_refresh = sdl_refresh;",
          "652:     dcl->dpy_setdata = sdl_setdata;",
          "653:     dcl->dpy_fill = sdl_fill;",
          "656:     register_displaychangelistener(ds, dcl);",
          "",
          "---------------"
        ],
        "vl.c||vl.c": [
          "File: vl.c -> vl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "193: DisplayState display_state;",
          "194: int nographic;",
          "195: static int curses;",
          "196: const char* keyboard_layout = NULL;",
          "197: int64_t ticks_per_sec;",
          "198: ram_addr_t ram_size;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "196: static int sdl;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2764: {",
          "2765: }",
          "2768: {",
          "2769: }",
          "2771: static void dumb_display_init(DisplayState *ds)",
          "2772: {",
          "2781: }",
          "",
          "[Removed Lines]",
          "2767: static void dumb_resize(DisplayState *ds, int w, int h)",
          "2773:     ds->data = NULL;",
          "2774:     ds->linesize = 0;",
          "2775:     ds->depth = 0;",
          "2776:     ds->dpy_update = dumb_update;",
          "2777:     ds->dpy_resize = dumb_resize;",
          "2778:     ds->dpy_refresh = NULL;",
          "2779:     ds->gui_timer_interval = 0;",
          "2780:     ds->idle = 1;",
          "",
          "[Added Lines]",
          "2768: static void dumb_resize(DisplayState *ds)",
          "2774:     DisplayChangeListener *dcl = qemu_mallocz(sizeof(DisplayChangeListener));",
          "2775:     if (!dcl)",
          "2776:         exit(1);",
          "2777:     dcl->dpy_update = dumb_update;",
          "2778:     dcl->dpy_resize = dumb_resize;",
          "2779:     dcl->dpy_refresh = NULL;",
          "2780:     dcl->idle = 1;",
          "2781:     dcl->gui_timer_interval = 500;",
          "2782:     register_displaychangelistener(ds, dcl);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3361: static void gui_update(void *opaque)",
          "3362: {",
          "3363:     DisplayState *ds = opaque;",
          "3370: }",
          "3372: struct vm_change_state_entry {",
          "",
          "[Removed Lines]",
          "3364:     ds->dpy_refresh(ds);",
          "3365:     qemu_mod_timer(ds->gui_timer,",
          "3366:         (ds->gui_timer_interval ?",
          "3367:      ds->gui_timer_interval :",
          "3368:      GUI_REFRESH_INTERVAL)",
          "3369:  + qemu_get_clock(rt_clock));",
          "",
          "[Added Lines]",
          "3365:     uint64_t interval = GUI_REFRESH_INTERVAL;",
          "3367:     DisplayChangeListener *dcl = ds->listeners;",
          "3369:     dpy_refresh(ds);",
          "3371:     while (dcl != NULL) {",
          "3372:         if (dcl->gui_timer_interval &&",
          "3373:             dcl->gui_timer_interval < interval)",
          "3374:             interval = dcl->gui_timer_interval;",
          "3375:         dcl = dcl->next;",
          "3376:     }",
          "3377:     qemu_mod_timer(ds->gui_timer, interval + qemu_get_clock(rt_clock));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3848:            \"-no-frame       open SDL window without a frame and window decorations\\n\"",
          "3849:            \"-alt-grab       use Ctrl-Alt-Shift to grab mouse (instead of Ctrl-Alt)\\n\"",
          "3850:            \"-no-quit        disable SDL window close capability\\n\"",
          "3851: #endif",
          "3852: #ifdef TARGET_I386",
          "3853:            \"-no-fd-bootchk  disable boot signature checking for floppy disks\\n\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3859:            \"-sdl            enable SDL\\n\"",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4064:     QEMU_OPTION_no_frame,",
          "4065:     QEMU_OPTION_alt_grab,",
          "4066:     QEMU_OPTION_no_quit,",
          "4067:     QEMU_OPTION_pidfile,",
          "4068:     QEMU_OPTION_no_kqemu,",
          "4069:     QEMU_OPTION_kernel_kqemu,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4076:     QEMU_OPTION_sdl,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4176:     { \"no-frame\", 0, QEMU_OPTION_no_frame },",
          "4177:     { \"alt-grab\", 0, QEMU_OPTION_alt_grab },",
          "4178:     { \"no-quit\", 0, QEMU_OPTION_no_quit },",
          "4179: #endif",
          "4180:     { \"pidfile\", HAS_ARG, QEMU_OPTION_pidfile },",
          "4181:     { \"win2k-hack\", 0, QEMU_OPTION_win2k_hack },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4189:     { \"sdl\", 0, QEMU_OPTION_sdl },",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4495:     const char *kernel_filename, *kernel_cmdline;",
          "4496:     const char *boot_devices = \"\";",
          "4497:     DisplayState *ds = &display_state;",
          "4498:     int cyls, heads, secs, translation;",
          "4499:     const char *net_clients[MAX_NET_CLIENTS];",
          "4500:     int nb_net_clients;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4509:     DisplayChangeListener *dcl;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "5007:             case QEMU_OPTION_no_quit:",
          "5008:                 no_quit = 1;",
          "5009:                 break;",
          "5010: #endif",
          "5011:             case QEMU_OPTION_pidfile:",
          "5012:                 pid_file = optarg;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5022:             case QEMU_OPTION_sdl:",
          "5023:                 sdl = 1;",
          "5024:                 break;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "5406:     memset(&display_state, 0, sizeof(display_state));",
          "5407:     if (nographic) {",
          "5408:         if (curses) {",
          "5409:             fprintf(stderr, \"fatal: -nographic can't be used with -curses\\n\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5422:     ds->surface = qemu_create_displaysurface(640, 480, 32, 640 * 4);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "5411:         }",
          "5413:         dumb_display_init(ds);",
          "5419: #if defined(CONFIG_CURSES)",
          "5423: #endif",
          "5425: #if defined(CONFIG_SDL)",
          "5427: #elif defined(CONFIG_COCOA)",
          "5429: #else",
          "5431: #endif",
          "5432:     }",
          "5434: #ifndef _WIN32",
          "5436:     termsig_setup();",
          "",
          "[Removed Lines]",
          "5414:     } else if (vnc_display != NULL) {",
          "5415:         vnc_display_init(ds);",
          "5416:         if (vnc_display_open(ds, vnc_display) < 0)",
          "5417:             exit(1);",
          "5418:     } else",
          "5420:     if (curses) {",
          "5421:         curses_display_init(ds, full_screen);",
          "5422:     } else",
          "5424:     {",
          "5426:         sdl_display_init(ds, full_screen, no_frame);",
          "5428:         cocoa_display_init(ds, full_screen);",
          "5430:         dumb_display_init(ds);",
          "",
          "[Added Lines]",
          "5430:     } else {",
          "5432:             if (curses) {",
          "5434:                 curses_display_init(ds, full_screen);",
          "5435:             } else",
          "5437:             {",
          "5438:                 if (vnc_display != NULL) {",
          "5439:                     vnc_display_init(ds);",
          "5440:                     if (vnc_display_open(ds, vnc_display) < 0)",
          "5441:                         exit(1);",
          "5442:                 }",
          "5443:                 if (sdl || !vnc_display)",
          "5445:                     sdl_display_init(ds, full_screen, no_frame);",
          "5447:                     cocoa_display_init(ds, full_screen);",
          "5449:                     dumb_display_init(ds);",
          "5451:             }",
          "5453:     dpy_resize(ds);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "5541:         }",
          "5542:     }",
          "5547:     }",
          "5549: #ifdef CONFIG_GDBSTUB",
          "5550:     if (use_gdbstub) {",
          "",
          "[Removed Lines]",
          "5544:     if (display_state.dpy_refresh) {",
          "5545:         display_state.gui_timer = qemu_new_timer(rt_clock, gui_update, &display_state);",
          "5546:         qemu_mod_timer(display_state.gui_timer, qemu_get_clock(rt_clock));",
          "",
          "[Added Lines]",
          "5564:     dcl = ds->listeners;",
          "5565:     while (dcl != NULL) {",
          "5566:         if (dcl->dpy_refresh != NULL) {",
          "5567:             display_state.gui_timer = qemu_new_timer(rt_clock, gui_update, &display_state);",
          "5568:             qemu_mod_timer(display_state.gui_timer, qemu_get_clock(rt_clock));",
          "5569:         }",
          "5570:         dcl = dcl->next;",
          "",
          "---------------"
        ],
        "vnc.c||vnc.c": [
          "File: vnc.c -> vnc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "180: };",
          "184: void do_info_vnc(void)",
          "185: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "183: static DisplayChangeListener *dcl;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "213: static void vnc_update_client(void *opaque);",
          "214: static void vnc_client_read(void *opaque);",
          "218: static inline void vnc_set_bit(uint32_t *d, int k)",
          "219: {",
          "",
          "[Removed Lines]",
          "216: static void vnc_colordepth(DisplayState *ds, int depth);",
          "",
          "[Added Lines]",
          "217: static void vnc_colordepth(DisplayState *ds);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "291:     vnc_write_s32(vs, encoding);",
          "292: }",
          "295: {",
          "296:     int size_changed;",
          "297:     VncState *vs = ds->opaque;",
          "303:  fprintf(stderr, \"vnc: memory allocation failed\\n\");",
          "304:  exit(1);",
          "305:     }",
          "309:         console_color_init(ds);",
          "315:     if (size_changed) {",
          "318:         if (vs->csock != -1 && vs->has_resize) {",
          "320:             vnc_write_u8(vs, 0);",
          "323:             vnc_flush(vs);",
          "324:         }",
          "325:     }",
          "",
          "[Removed Lines]",
          "294: static void vnc_dpy_resize(DisplayState *ds, int w, int h)",
          "299:     ds->data = qemu_realloc(ds->data, w * h * vs->depth);",
          "300:     vs->old_data = qemu_realloc(vs->old_data, w * h * vs->depth);",
          "302:     if (ds->data == NULL || vs->old_data == NULL) {",
          "307:     if (ds->depth != vs->depth * 8) {",
          "308:         ds->depth = vs->depth * 8;",
          "310:     }",
          "311:     size_changed = ds->width != w || ds->height != h;",
          "312:     ds->width = w;",
          "313:     ds->height = h;",
          "314:     ds->linesize = w * vs->depth;",
          "316:         vs->width = ds->width;",
          "317:         vs->height = ds->height;",
          "322:             vnc_framebuffer_update(vs, 0, 0, ds->width, ds->height, -223);",
          "",
          "[Added Lines]",
          "295: static void vnc_dpy_resize(DisplayState *ds)",
          "300:     vs->old_data = qemu_realloc(vs->old_data, ds_get_linesize(ds) * ds_get_height(ds));",
          "302:     if (vs->old_data == NULL) {",
          "307:     if (ds_get_bytes_per_pixel(ds) != vs->depth)",
          "309:     vnc_colordepth(ds);",
          "310:     size_changed = ds_get_width(ds) != vs->width || ds_get_height(ds) != vs->height;",
          "312:         vs->width = ds_get_width(ds);",
          "313:         vs->height = ds_get_height(ds);",
          "318:             vnc_framebuffer_update(vs, 0, 0, ds_get_width(ds), ds_get_height(ds), -223);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "495: static void vnc_copy(DisplayState *ds, int src_x, int src_y, int dst_x, int dst_y, int w, int h)",
          "496: {",
          "503:     VncState *vs = ds->opaque;",
          "505:     vnc_update_client(vs);",
          "528:     vnc_write_u8(vs, 0);",
          "",
          "[Removed Lines]",
          "497:     int src, dst;",
          "498:     uint8_t *src_row;",
          "499:     uint8_t *dst_row;",
          "500:     char *old_row;",
          "501:     int y = 0;",
          "502:     int pitch = ds_get_linesize(ds);",
          "507:     if (dst_y > src_y) {",
          "508:  y = h - 1;",
          "509:  pitch = -pitch;",
          "510:     }",
          "512:     src = (ds_get_linesize(ds) * (src_y + y) + vs->depth * src_x);",
          "513:     dst = (ds_get_linesize(ds) * (dst_y + y) + vs->depth * dst_x);",
          "515:     src_row = ds_get_data(ds) + src;",
          "516:     dst_row = ds_get_data(ds) + dst;",
          "517:     old_row = vs->old_data + dst;",
          "519:     for (y = 0; y < h; y++) {",
          "520:  memmove(old_row, src_row, w * vs->depth);",
          "521:  memmove(dst_row, src_row, w * vs->depth);",
          "522:  src_row += pitch;",
          "523:  dst_row += pitch;",
          "524:  old_row += pitch;",
          "525:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "770:  qemu_set_fd_handler2(vs->csock, NULL, NULL, NULL, NULL);",
          "771:  closesocket(vs->csock);",
          "772:  vs->csock = -1;",
          "774:  buffer_reset(&vs->input);",
          "775:  buffer_reset(&vs->output);",
          "776:  vs->need_update = 0;",
          "",
          "[Removed Lines]",
          "773:  vs->ds->idle = 1;",
          "",
          "[Added Lines]",
          "743:  dcl->idle = 1;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1226:     vs->has_pointer_type_change = 0;",
          "1227:     vs->has_WMVi = 0;",
          "1228:     vs->absolute = -1;",
          "1231:     for (i = n_encodings - 1; i >= 0; i--) {",
          "1232:  switch (encodings[i]) {",
          "",
          "[Removed Lines]",
          "1229:     vs->ds->dpy_copy = NULL;",
          "",
          "[Added Lines]",
          "1199:     dcl->dpy_copy = NULL;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1234:      vs->has_hextile = 0;",
          "1235:      break;",
          "1238:      break;",
          "1240:      vs->has_hextile = 1;",
          "",
          "[Removed Lines]",
          "1237:      vs->ds->dpy_copy = vnc_copy;",
          "",
          "[Added Lines]",
          "1207:      dcl->dpy_copy = vnc_copy;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1388: }",
          "1391: {",
          "1392:     int host_big_endian_flag;",
          "1393:     struct VncState *vs = ds->opaque;",
          "1408: #ifdef WORDS_BIGENDIAN",
          "1409:     host_big_endian_flag = 1;",
          "1410: #else",
          "1411:     host_big_endian_flag = 0;",
          "1412: #endif",
          "1415:         case 8:",
          "1417:             vs->server_red_max = 7;",
          "1418:             vs->server_green_max = 7;",
          "1419:             vs->server_blue_max = 3;",
          "",
          "[Removed Lines]",
          "1390: static void vnc_colordepth(DisplayState *ds, int depth)",
          "1395:     switch (depth) {",
          "1396:         case 24:",
          "1397:             if (ds->depth == 32) return;",
          "1398:             depth = 32;",
          "1399:             break;",
          "1400:         case 15:",
          "1401:         case 8:",
          "1402:         case 0:",
          "1403:             return;",
          "1404:         default:",
          "1405:             break;",
          "1406:     }",
          "1414:     switch (depth) {",
          "1416:             vs->depth = depth / 8;",
          "",
          "[Added Lines]",
          "1360: static void vnc_dpy_setdata(DisplayState *ds)",
          "1361: {",
          "1363: }",
          "1365: static void vnc_colordepth(DisplayState *ds)",
          "1376:     switch (ds_get_bits_per_pixel(ds)) {",
          "1378:             vs->depth = 1;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1422:             vs->server_blue_shift = 0;",
          "1423:             break;",
          "1424:         case 16:",
          "1426:             vs->server_red_max = 31;",
          "1427:             vs->server_green_max = 63;",
          "1428:             vs->server_blue_max = 31;",
          "",
          "[Removed Lines]",
          "1425:             vs->depth = depth / 8;",
          "",
          "[Added Lines]",
          "1387:             vs->depth = 2;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1449:         vnc_write_u8(vs, 0);",
          "1452:         pixel_format_message(vs);",
          "1453:         vnc_flush(vs);",
          "1454:     } else {",
          "",
          "[Removed Lines]",
          "1451:         vnc_framebuffer_update(vs, 0, 0, ds->width, ds->height, 0x574D5669);",
          "",
          "[Added Lines]",
          "1413:         vnc_framebuffer_update(vs, 0, 0, ds_get_width(ds), ds_get_height(ds), 0x574D5669);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2237: static void vnc_connect(VncState *vs)",
          "2238: {",
          "2239:     VNC_DEBUG(\"New client on socket %d\\n\", vs->csock);",
          "2241:     socket_set_nonblock(vs->csock);",
          "2242:     qemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, NULL, vs);",
          "2243:     vnc_write(vs, \"RFB 003.008\\n\", 12);",
          "",
          "[Removed Lines]",
          "2240:     vs->ds->idle = 0;",
          "",
          "[Added Lines]",
          "2202:     dcl->idle = 0;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2247:     memset(vs->dirty_row, 0xFF, sizeof(vs->dirty_row));",
          "2248:     vs->has_resize = 0;",
          "2249:     vs->has_hextile = 0;",
          "2251:     vnc_update_client(vs);",
          "2252:     reset_keys(vs);",
          "2253: }",
          "",
          "[Removed Lines]",
          "2250:     vs->ds->dpy_copy = NULL;",
          "",
          "[Added Lines]",
          "2212:     dcl->dpy_copy = NULL;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2272:     VncState *vs;",
          "2274:     vs = qemu_mallocz(sizeof(VncState));",
          "2276:  exit(1);",
          "2278:     ds->opaque = vs;",
          "2280:     vnc_state = vs;",
          "2281:     vs->display = NULL;",
          "2282:     vs->password = NULL;",
          "",
          "[Removed Lines]",
          "2275:     if (!vs)",
          "2279:     ds->idle = 1;",
          "",
          "[Added Lines]",
          "2237:     dcl = qemu_mallocz(sizeof(DisplayChangeListener));",
          "2238:     if (!vs || !dcl)",
          "2242:     dcl->idle = 1;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2299:     vs->timer = qemu_new_timer(rt_clock, vnc_update_client, vs);",
          "2309:     vs->as.freq = 44100;",
          "2310:     vs->as.nchannels = 2;",
          "",
          "[Removed Lines]",
          "2301:     vs->ds->data = NULL;",
          "2302:     vs->ds->dpy_update = vnc_dpy_update;",
          "2303:     vs->ds->dpy_resize = vnc_dpy_resize;",
          "2304:     vs->ds->dpy_refresh = NULL;",
          "2306:     vnc_colordepth(vs->ds, 32);",
          "2307:     vnc_dpy_resize(vs->ds, 640, 400);",
          "",
          "[Added Lines]",
          "2264:     dcl->dpy_update = vnc_dpy_update;",
          "2265:     dcl->dpy_resize = vnc_dpy_resize;",
          "2266:     dcl->dpy_setdata = vnc_dpy_setdata;",
          "2267:     dcl->dpy_refresh = NULL;",
          "2268:     register_displaychangelistener(ds, dcl);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2f9606b3736c3be4dbd606c46525c7b770ced119",
      "candidate_info": {
        "commit_hash": "2f9606b3736c3be4dbd606c46525c7b770ced119",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/2f9606b3736c3be4dbd606c46525c7b770ced119",
        "files": [
          "Makefile",
          "Makefile.target",
          "configure",
          "qemu-doc.texi",
          "qemu.sasl",
          "vnc-auth-sasl.c",
          "vnc-auth-sasl.h",
          "vnc.c",
          "vnc.h"
        ],
        "message": "Add SASL authentication support (\"Daniel P. Berrange\")\n\nThis patch adds the new SASL authentication protocol to the VNC server.\n\nIt is enabled by setting the 'sasl' flag when launching VNC. SASL can\noptionally provide encryption via its SSF layer, if a suitable mechanism\nis configured (eg, GSSAPI/Kerberos, or Digest-MD5).  If an SSF layer is\nnot available, then it should be combined with the x509 VNC authentication\nprotocol which provides encryption.\n\neg, if using GSSAPI\n\n   qemu -vnc localhost:1,sasl\n\neg if using  TLS/x509 for encryption\n\n   qemu -vnc localhost:1,sasl,tls,x509\n\n\nBy default the Cyrus SASL library will look for its configuration in\nthe file /etc/sasl2/qemu.conf.  For non-root users, this can be overridden\nby setting the SASL_CONF_PATH environment variable, eg to make it look in\n$HOME/.sasl2.  NB unprivileged users may not have access to the full range\nof SASL mechanisms, since some of them require some administrative privileges\nto configure. The patch includes an example SASL configuration file which\nillustrates config for GSSAPI and Digest-MD5, though it should be noted that\nthe latter is not really considered secure any more.\n\nMost of the SASL authentication code is located in a separate source file,\nvnc-auth-sasl.c.  The main vnc.c file only contains minimal integration\nglue, specifically parsing of command line flags / setup, and calls to\nstart the SASL auth process, to do encoding/decoding for data.\n\nThere are several possible stacks for reading & writing of data, depending\non the combo of VNC authentication methods in use\n\n - Clear.    read/write straight to socket\n - TLS.      read/write via GNUTLS helpers\n - SASL.     encode/decode via SASL SSF layer, then read/write to socket\n - SASL+TLS. encode/decode via SASL SSF layer, then read/write via GNUTLS\n\nHence, the vnc_client_read & vnc_client_write methods have been refactored\na little.\n\n   vnc_client_read:  main entry point for reading, calls either\n\n       - vnc_client_read_plain   reading, with no intermediate decoding\n       - vnc_client_read_sasl    reading, with SASL SSF decoding\n\n   These two methods, then call vnc_client_read_buf(). This decides\n   whether to write to the socket directly or write via GNUTLS.\n\nThe situation is the same for writing data. More extensive comments\nhave been added in the code / patch. The vnc_client_read_sasl and\nvnc_client_write_sasl method implementations live in the separate\nvnc-auth-sasl.c file.\n\nThe state required for the SASL auth mechanism is kept in a separate\nVncStateSASL struct, defined in vnc-auth-sasl.h and included in the\nmain VncState.\n\nThe configure script probes for SASL and automatically enables it\nif found, unless --disable-vnc-sasl was given to override it.\n\n\n Makefile            |    7 \n Makefile.target     |    5 \n b/qemu.sasl         |   34 ++\n b/vnc-auth-sasl.c   |  626 ++++++++++++++++++++++++++++++++++++++++++++++++++++\n b/vnc-auth-sasl.h   |   67 +++++\n configure           |   34 ++\n qemu-doc.texi       |   97 ++++++++\n vnc-auth-vencrypt.c |   12 \n vnc.c               |  249 ++++++++++++++++++--\n vnc.h               |   31 ++\n 10 files changed, 1129 insertions(+), 33 deletions(-)\n\n   Signed-off-by: Daniel P. Berrange <berrange@redhat.com>\nSigned-off-by: Anthony Liguori <aliguori@us.ibm.com>\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@6724 c046a42c-6fe2-441c-8c8c-71466251a162",
        "before_after_code_files": [
          "Makefile.target||Makefile.target",
          "qemu-doc.texi||qemu-doc.texi",
          "qemu.sasl||qemu.sasl",
          "vnc-auth-sasl.c||vnc-auth-sasl.c",
          "vnc-auth-sasl.h||vnc-auth-sasl.h",
          "vnc.c||vnc.c",
          "vnc.h||vnc.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "vnc.c||vnc.c"
          ],
          "candidate": [
            "vnc.c||vnc.c"
          ]
        }
      },
      "candidate_diff": {
        "Makefile.target||Makefile.target": [
          "File: Makefile.target -> Makefile.target",
          "--- Hunk 1 ---",
          "[Context before]",
          "554: LIBS += $(CONFIG_VNC_TLS_LIBS)",
          "555: endif",
          "557: ifdef CONFIG_BLUEZ",
          "558: LIBS += $(CONFIG_BLUEZ_LIBS)",
          "559: endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "557: ifdef CONFIG_VNC_SASL",
          "558: CPPFLAGS += $(CONFIG_VNC_SASL_CFLAGS)",
          "559: LIBS += $(CONFIG_VNC_SASL_LIBS)",
          "560: endif",
          "",
          "---------------"
        ],
        "qemu-doc.texi||qemu-doc.texi": [
          "File: qemu-doc.texi -> qemu-doc.texi",
          "--- Hunk 1 ---",
          "[Context before]",
          "616: be loaded from. See the @ref{vnc_security} section for details on generating",
          "617: certificates.",
          "619: @end table",
          "621: @end table",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "619: @item sasl",
          "621: Require that the client use SASL to authenticate with the VNC server.",
          "622: The exact choice of authentication method used is controlled from the",
          "623: system / user's SASL configuration file for the 'qemu' service. This",
          "624: is typically found in /etc/sasl2/qemu.conf. If running QEMU as an",
          "625: unprivileged user, an environment variable SASL_CONF_PATH can be used",
          "626: to make it search alternate locations for the service config.",
          "627: While some SASL auth methods can also provide data encryption (eg GSSAPI),",
          "628: it is recommended that SASL always be combined with the 'tls' and",
          "629: 'x509' settings to enable use of SSL and server certificates. This",
          "630: ensures a data encryption preventing compromise of authentication",
          "631: credentials. See the @ref{vnc_security} section for details on using",
          "632: SASL authentication.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2144: (qemu)",
          "2145: @end example",
          "2147: @node vnc_generate_cert",
          "2148: @subsection Generating certificates for VNC",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2166: @node vnc_sec_sasl",
          "2167: @subsection With SASL authentication",
          "2169: The SASL authentication method is a VNC extension, that provides an",
          "2170: easily extendable, pluggable authentication method. This allows for",
          "2171: integration with a wide range of authentication mechanisms, such as",
          "2172: PAM, GSSAPI/Kerberos, LDAP, SQL databases, one-time keys and more.",
          "2173: The strength of the authentication depends on the exact mechanism",
          "2174: configured. If the chosen mechanism also provides a SSF layer, then",
          "2175: it will encrypt the datastream as well.",
          "2177: Refer to the later docs on how to choose the exact SASL mechanism",
          "2178: used for authentication, but assuming use of one supporting SSF,",
          "2179: then QEMU can be launched with:",
          "2181: @example",
          "2182: qemu [...OPTIONS...] -vnc :1,sasl -monitor stdio",
          "2183: @end example",
          "2185: @node vnc_sec_certificate_sasl",
          "2186: @subsection With x509 certificates and SASL authentication",
          "2188: If the desired SASL authentication mechanism does not supported",
          "2189: SSF layers, then it is strongly advised to run it in combination",
          "2190: with TLS and x509 certificates. This provides securely encrypted",
          "2191: data stream, avoiding risk of compromising of the security",
          "2192: credentials. This can be enabled, by combining the 'sasl' option",
          "2193: with the aforementioned TLS + x509 options:",
          "2195: @example",
          "2196: qemu [...OPTIONS...] -vnc :1,tls,x509,sasl -monitor stdio",
          "2197: @end example",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2255: The @code{client-key.pem} and @code{client-cert.pem} files should now be securely",
          "2256: copied to the client for which they were generated.",
          "2258: @node gdb_usage",
          "2259: @section GDB usage",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2312: @node vnc_setup_sasl",
          "2314: @subsection Configuring SASL mechanisms",
          "2316: The following documentation assumes use of the Cyrus SASL implementation on a",
          "2317: Linux host, but the principals should apply to any other SASL impl. When SASL",
          "2318: is enabled, the mechanism configuration will be loaded from system default",
          "2319: SASL service config /etc/sasl2/qemu.conf. If running QEMU as an",
          "2320: unprivileged user, an environment variable SASL_CONF_PATH can be used",
          "2321: to make it search alternate locations for the service config.",
          "2323: The default configuration might contain",
          "2325: @example",
          "2326: mech_list: digest-md5",
          "2327: sasldb_path: /etc/qemu/passwd.db",
          "2328: @end example",
          "2330: This says to use the 'Digest MD5' mechanism, which is similar to the HTTP",
          "2331: Digest-MD5 mechanism. The list of valid usernames & passwords is maintained",
          "2332: in the /etc/qemu/passwd.db file, and can be updated using the saslpasswd2",
          "2333: command. While this mechanism is easy to configure and use, it is not",
          "2334: considered secure by modern standards, so only suitable for developers /",
          "2335: ad-hoc testing.",
          "2337: A more serious deployment might use Kerberos, which is done with the 'gssapi'",
          "2338: mechanism",
          "2340: @example",
          "2341: mech_list: gssapi",
          "2342: keytab: /etc/qemu/krb5.tab",
          "2343: @end example",
          "2345: For this to work the administrator of your KDC must generate a Kerberos",
          "2346: principal for the server, with a name of  'qemu/somehost.example.com@@EXAMPLE.COM'",
          "2347: replacing 'somehost.example.com' with the fully qualified host name of the",
          "2348: machine running QEMU, and 'EXAMPLE.COM' with the Keberos Realm.",
          "2350: Other configurations will be left as an exercise for the reader. It should",
          "2351: be noted that only Digest-MD5 and GSSAPI provides a SSF layer for data",
          "2352: encryption. For all other mechanisms, VNC should always be configured to",
          "2353: use TLS and x509 certificates to protect security credentials from snooping.",
          "",
          "---------------"
        ],
        "qemu.sasl||qemu.sasl": [
          "File: qemu.sasl -> qemu.sasl",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # If you want to use the non-TLS socket, then you *must* include",
          "2: # the GSSAPI or DIGEST-MD5 mechanisms, because they are the only",
          "3: # ones that can offer session encryption as well as authentication.",
          "4: #",
          "5: # If you're only using TLS, then you can turn on any mechanisms",
          "6: # you like for authentication, because TLS provides the encryption",
          "7: #",
          "8: # Default to a simple username+password mechanism",
          "9: # NB digest-md5 is no longer considered secure by current standards",
          "10: mech_list: digest-md5",
          "12: # Before you can use GSSAPI, you need a service principle on the",
          "13: # KDC server for libvirt, and that to be exported to the keytab",
          "14: # file listed below",
          "15: #mech_list: gssapi",
          "16: #",
          "17: # You can also list many mechanisms at once, then the user can choose",
          "18: # by adding  '?auth=sasl.gssapi' to their libvirt URI, eg",
          "19: #   qemu+tcp://hostname/system?auth=sasl.gssapi",
          "20: #mech_list: digest-md5 gssapi",
          "22: # Some older builds of MIT kerberos on Linux ignore this option &",
          "23: # instead need KRB5_KTNAME env var.",
          "24: # For modern Linux, and other OS, this should be sufficient",
          "25: keytab: /etc/qemu/krb5.tab",
          "27: # If using digest-md5 for username/passwds, then this is the file",
          "28: # containing the passwds. Use 'saslpasswd2 -a qemu [username]'",
          "29: # to add entries, and 'sasldblistusers2 -a qemu' to browse it",
          "30: sasldb_path: /etc/qemu/passwd.db",
          "33: auxprop_plugin: sasldb",
          "",
          "---------------"
        ],
        "vnc-auth-sasl.c||vnc-auth-sasl.c": [
          "File: vnc-auth-sasl.c -> vnc-auth-sasl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #include \"vnc.h\"",
          "28: #define SASL_DATA_MAX_LEN (1024 * 1024)",
          "31: void vnc_sasl_client_cleanup(VncState *vs)",
          "32: {",
          "33:     if (vs->sasl.conn) {",
          "34:  vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;",
          "35:  vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;",
          "36:  vs->sasl.encoded = NULL;",
          "37:  free(vs->sasl.username);",
          "38:  free(vs->sasl.mechlist);",
          "39:  vs->sasl.username = vs->sasl.mechlist = NULL;",
          "40:  sasl_dispose(&vs->sasl.conn);",
          "41:  vs->sasl.conn = NULL;",
          "42:     }",
          "43: }",
          "46: long vnc_client_write_sasl(VncState *vs)",
          "47: {",
          "48:     long ret;",
          "50:     VNC_DEBUG(\"Write SASL: Pending output %p size %d offset %d Encoded: %p size %d offset %d\\n\",",
          "51:        vs->output.buffer, vs->output.capacity, vs->output.offset,",
          "52:        vs->sasl.encoded, vs->sasl.encodedLength, vs->sasl.encodedOffset);",
          "54:     if (!vs->sasl.encoded) {",
          "55:  int err;",
          "56:  err = sasl_encode(vs->sasl.conn,",
          "57:      (char *)vs->output.buffer,",
          "58:      vs->output.offset,",
          "59:      (const char **)&vs->sasl.encoded,",
          "60:      &vs->sasl.encodedLength);",
          "61:  if (err != SASL_OK)",
          "62:      return vnc_client_io_error(vs, -1, EIO);",
          "64:  vs->sasl.encodedOffset = 0;",
          "65:     }",
          "67:     ret = vnc_client_write_buf(vs,",
          "68:           vs->sasl.encoded + vs->sasl.encodedOffset,",
          "69:           vs->sasl.encodedLength - vs->sasl.encodedOffset);",
          "70:     if (!ret)",
          "71:  return 0;",
          "73:     vs->sasl.encodedOffset += ret;",
          "74:     if (vs->sasl.encodedOffset == vs->sasl.encodedLength) {",
          "75:  vs->output.offset = 0;",
          "76:  vs->sasl.encoded = NULL;",
          "77:  vs->sasl.encodedOffset = vs->sasl.encodedLength = 0;",
          "78:     }",
          "85:     if (vs->output.offset == 0) {",
          "86:  qemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, NULL, vs);",
          "87:     }",
          "89:     return ret;",
          "90: }",
          "93: long vnc_client_read_sasl(VncState *vs)",
          "94: {",
          "95:     long ret;",
          "96:     uint8_t encoded[4096];",
          "97:     const char *decoded;",
          "98:     unsigned int decodedLen;",
          "99:     int err;",
          "101:     ret = vnc_client_read_buf(vs, encoded, sizeof(encoded));",
          "102:     if (!ret)",
          "103:  return 0;",
          "105:     err = sasl_decode(vs->sasl.conn,",
          "106:         (char *)encoded, ret,",
          "107:         &decoded, &decodedLen);",
          "109:     if (err != SASL_OK)",
          "110:  return vnc_client_io_error(vs, -1, -EIO);",
          "111:     VNC_DEBUG(\"Read SASL Encoded %p size %ld Decoded %p size %d\\n\",",
          "112:        encoded, ret, decoded, decodedLen);",
          "113:     buffer_reserve(&vs->input, decodedLen);",
          "114:     buffer_append(&vs->input, decoded, decodedLen);",
          "115:     return decodedLen;",
          "116: }",
          "119: static int vnc_auth_sasl_check_access(VncState *vs)",
          "120: {",
          "121:     const void *val;",
          "122:     int err;",
          "124:     err = sasl_getprop(vs->sasl.conn, SASL_USERNAME, &val);",
          "125:     if (err != SASL_OK) {",
          "126:  VNC_DEBUG(\"cannot query SASL username on connection %d (%s)\\n\",",
          "127:     err, sasl_errstring(err, NULL, NULL));",
          "128:  return -1;",
          "129:     }",
          "130:     if (val == NULL) {",
          "131:  VNC_DEBUG(\"no client username was found\\n\");",
          "132:  return -1;",
          "133:     }",
          "134:     VNC_DEBUG(\"SASL client username %s\\n\", (const char *)val);",
          "136:     vs->sasl.username = qemu_strdup((const char*)val);",
          "138:     return 0;",
          "139: }",
          "141: static int vnc_auth_sasl_check_ssf(VncState *vs)",
          "142: {",
          "143:     const void *val;",
          "144:     int err, ssf;",
          "146:     if (!vs->sasl.wantSSF)",
          "147:  return 1;",
          "149:     err = sasl_getprop(vs->sasl.conn, SASL_SSF, &val);",
          "150:     if (err != SASL_OK)",
          "151:  return 0;",
          "153:     ssf = *(const int *)val;",
          "154:     VNC_DEBUG(\"negotiated an SSF of %d\\n\", ssf);",
          "155:     if (ssf < 56)",
          "164:     vs->sasl.runSSF = 1;",
          "167:     return 1;",
          "168: }",
          "185: static int protocol_client_auth_sasl_step_len(VncState *vs, uint8_t *data, size_t len);",
          "187: static int protocol_client_auth_sasl_step(VncState *vs, uint8_t *data, size_t len)",
          "188: {",
          "189:     uint32_t datalen = len;",
          "190:     const char *serverout;",
          "191:     unsigned int serveroutlen;",
          "192:     int err;",
          "193:     char *clientdata = NULL;",
          "196:     if (datalen) {",
          "197:  clientdata = (char*)data;",
          "200:     }",
          "202:     VNC_DEBUG(\"Step using SASL Data %p (%d bytes)\\n\",",
          "203:        clientdata, datalen);",
          "204:     err = sasl_server_step(vs->sasl.conn,",
          "205:       clientdata,",
          "206:       datalen,",
          "207:       &serverout,",
          "208:       &serveroutlen);",
          "209:     if (err != SASL_OK &&",
          "210:  err != SASL_CONTINUE) {",
          "211:  VNC_DEBUG(\"sasl step failed %d (%s)\\n\",",
          "212:     err, sasl_errdetail(vs->sasl.conn));",
          "213:  sasl_dispose(&vs->sasl.conn);",
          "214:  vs->sasl.conn = NULL;",
          "215:  goto authabort;",
          "216:     }",
          "218:     if (serveroutlen > SASL_DATA_MAX_LEN) {",
          "219:  VNC_DEBUG(\"sasl step reply data too long %d\\n\",",
          "220:     serveroutlen);",
          "221:  sasl_dispose(&vs->sasl.conn);",
          "222:  vs->sasl.conn = NULL;",
          "223:  goto authabort;",
          "224:     }",
          "226:     VNC_DEBUG(\"SASL return data %d bytes, nil; %d\\n\",",
          "227:        serveroutlen, serverout ? 0 : 1);",
          "229:     if (serveroutlen) {",
          "230:  vnc_write_u32(vs, serveroutlen + 1);",
          "231:  vnc_write(vs, serverout, serveroutlen + 1);",
          "232:     } else {",
          "233:  vnc_write_u32(vs, 0);",
          "234:     }",
          "237:     vnc_write_u8(vs, err == SASL_CONTINUE ? 0 : 1);",
          "239:     if (err == SASL_CONTINUE) {",
          "240:  VNC_DEBUG(\"%s\", \"Authentication must continue\\n\");",
          "242:  vnc_read_when(vs, protocol_client_auth_sasl_step_len, 4);",
          "243:     } else {",
          "244:  if (!vnc_auth_sasl_check_ssf(vs)) {",
          "245:      VNC_DEBUG(\"Authentication rejected for weak SSF %d\\n\", vs->csock);",
          "246:      goto authreject;",
          "247:  }",
          "250:  if (vnc_auth_sasl_check_access(vs) < 0) {",
          "251:      VNC_DEBUG(\"Authentication rejected for ACL %d\\n\", vs->csock);",
          "252:      goto authreject;",
          "253:  }",
          "255:  VNC_DEBUG(\"Authentication successful %d\\n\", vs->csock);",
          "261:  if (vs->sasl.runSSF)",
          "262:      vs->sasl.waitWriteSSF = vs->output.offset;",
          "263:  start_client_init(vs);",
          "264:     }",
          "266:     return 0;",
          "268:  authreject:",
          "270:     vnc_write_u32(vs, sizeof(\"Authentication failed\"));",
          "271:     vnc_write(vs, \"Authentication failed\", sizeof(\"Authentication failed\"));",
          "272:     vnc_flush(vs);",
          "273:     vnc_client_error(vs);",
          "274:     return -1;",
          "276:  authabort:",
          "277:     vnc_client_error(vs);",
          "278:     return -1;",
          "279: }",
          "281: static int protocol_client_auth_sasl_step_len(VncState *vs, uint8_t *data, size_t len)",
          "282: {",
          "283:     uint32_t steplen = read_u32(data, 0);",
          "284:     VNC_DEBUG(\"Got client step len %d\\n\", steplen);",
          "285:     if (steplen > SASL_DATA_MAX_LEN) {",
          "286:  VNC_DEBUG(\"Too much SASL data %d\\n\", steplen);",
          "287:  vnc_client_error(vs);",
          "288:  return -1;",
          "289:     }",
          "291:     if (steplen == 0)",
          "292:  return protocol_client_auth_sasl_step(vs, NULL, 0);",
          "293:     else",
          "294:  vnc_read_when(vs, protocol_client_auth_sasl_step, steplen);",
          "295:     return 0;",
          "296: }",
          "313: #define SASL_DATA_MAX_LEN (1024 * 1024)",
          "315: static int protocol_client_auth_sasl_start(VncState *vs, uint8_t *data, size_t len)",
          "316: {",
          "317:     uint32_t datalen = len;",
          "318:     const char *serverout;",
          "319:     unsigned int serveroutlen;",
          "320:     int err;",
          "321:     char *clientdata = NULL;",
          "324:     if (datalen) {",
          "325:  clientdata = (char*)data;",
          "328:     }",
          "330:     VNC_DEBUG(\"Start SASL auth with mechanism %s. Data %p (%d bytes)\\n\",",
          "331:        vs->sasl.mechlist, clientdata, datalen);",
          "332:     err = sasl_server_start(vs->sasl.conn,",
          "333:        vs->sasl.mechlist,",
          "334:        clientdata,",
          "335:        datalen,",
          "336:        &serverout,",
          "337:        &serveroutlen);",
          "338:     if (err != SASL_OK &&",
          "339:  err != SASL_CONTINUE) {",
          "340:  VNC_DEBUG(\"sasl start failed %d (%s)\\n\",",
          "341:     err, sasl_errdetail(vs->sasl.conn));",
          "342:  sasl_dispose(&vs->sasl.conn);",
          "343:  vs->sasl.conn = NULL;",
          "344:  goto authabort;",
          "345:     }",
          "346:     if (serveroutlen > SASL_DATA_MAX_LEN) {",
          "347:  VNC_DEBUG(\"sasl start reply data too long %d\\n\",",
          "348:     serveroutlen);",
          "349:  sasl_dispose(&vs->sasl.conn);",
          "350:  vs->sasl.conn = NULL;",
          "351:  goto authabort;",
          "352:     }",
          "354:     VNC_DEBUG(\"SASL return data %d bytes, nil; %d\\n\",",
          "355:        serveroutlen, serverout ? 0 : 1);",
          "357:     if (serveroutlen) {",
          "358:  vnc_write_u32(vs, serveroutlen + 1);",
          "359:  vnc_write(vs, serverout, serveroutlen + 1);",
          "360:     } else {",
          "361:  vnc_write_u32(vs, 0);",
          "362:     }",
          "365:     vnc_write_u8(vs, err == SASL_CONTINUE ? 0 : 1);",
          "367:     if (err == SASL_CONTINUE) {",
          "368:  VNC_DEBUG(\"%s\", \"Authentication must continue\\n\");",
          "370:  vnc_read_when(vs, protocol_client_auth_sasl_step_len, 4);",
          "371:     } else {",
          "372:  if (!vnc_auth_sasl_check_ssf(vs)) {",
          "373:      VNC_DEBUG(\"Authentication rejected for weak SSF %d\\n\", vs->csock);",
          "374:      goto authreject;",
          "375:  }",
          "378:  if (vnc_auth_sasl_check_access(vs) < 0) {",
          "379:      VNC_DEBUG(\"Authentication rejected for ACL %d\\n\", vs->csock);",
          "380:      goto authreject;",
          "381:  }",
          "383:  VNC_DEBUG(\"Authentication successful %d\\n\", vs->csock);",
          "385:  start_client_init(vs);",
          "386:     }",
          "388:     return 0;",
          "390:  authreject:",
          "392:     vnc_write_u32(vs, sizeof(\"Authentication failed\"));",
          "393:     vnc_write(vs, \"Authentication failed\", sizeof(\"Authentication failed\"));",
          "394:     vnc_flush(vs);",
          "395:     vnc_client_error(vs);",
          "396:     return -1;",
          "398:  authabort:",
          "399:     vnc_client_error(vs);",
          "400:     return -1;",
          "401: }",
          "403: static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)",
          "404: {",
          "405:     uint32_t startlen = read_u32(data, 0);",
          "406:     VNC_DEBUG(\"Got client start len %d\\n\", startlen);",
          "407:     if (startlen > SASL_DATA_MAX_LEN) {",
          "408:  VNC_DEBUG(\"Too much SASL data %d\\n\", startlen);",
          "409:  vnc_client_error(vs);",
          "410:  return -1;",
          "411:     }",
          "413:     if (startlen == 0)",
          "414:  return protocol_client_auth_sasl_start(vs, NULL, 0);",
          "416:     vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);",
          "417:     return 0;",
          "418: }",
          "420: static int protocol_client_auth_sasl_mechname(VncState *vs, uint8_t *data, size_t len)",
          "421: {",
          "422:     char *mechname = malloc(len + 1);",
          "423:     if (!mechname) {",
          "424:  VNC_DEBUG(\"Out of memory reading mechname\\n\");",
          "425:  vnc_client_error(vs);",
          "426:     }",
          "427:     strncpy(mechname, (char*)data, len);",
          "428:     mechname[len] = '\\0';",
          "429:     VNC_DEBUG(\"Got client mechname '%s' check against '%s'\\n\",",
          "430:        mechname, vs->sasl.mechlist);",
          "432:     if (strncmp(vs->sasl.mechlist, mechname, len) == 0) {",
          "433:  if (vs->sasl.mechlist[len] != '\\0' &&",
          "434:      vs->sasl.mechlist[len] != ',') {",
          "435:      VNC_DEBUG(\"One %d\", vs->sasl.mechlist[len]);",
          "436:      vnc_client_error(vs);",
          "437:      return -1;",
          "438:  }",
          "439:     } else {",
          "440:  char *offset = strstr(vs->sasl.mechlist, mechname);",
          "441:  VNC_DEBUG(\"Two %p\\n\", offset);",
          "442:  if (!offset) {",
          "443:      vnc_client_error(vs);",
          "444:      return -1;",
          "445:  }",
          "446:  VNC_DEBUG(\"Two '%s'\\n\", offset);",
          "447:  if (offset[-1] != ',' ||",
          "448:      (offset[len] != '\\0'&&",
          "449:       offset[len] != ',')) {",
          "450:      vnc_client_error(vs);",
          "451:      return -1;",
          "452:  }",
          "453:     }",
          "455:     free(vs->sasl.mechlist);",
          "456:     vs->sasl.mechlist = mechname;",
          "458:     VNC_DEBUG(\"Validated mechname '%s'\\n\", mechname);",
          "459:     vnc_read_when(vs, protocol_client_auth_sasl_start_len, 4);",
          "460:     return 0;",
          "461: }",
          "463: static int protocol_client_auth_sasl_mechname_len(VncState *vs, uint8_t *data, size_t len)",
          "464: {",
          "465:     uint32_t mechlen = read_u32(data, 0);",
          "466:     VNC_DEBUG(\"Got client mechname len %d\\n\", mechlen);",
          "467:     if (mechlen > 100) {",
          "468:  VNC_DEBUG(\"Too long SASL mechname data %d\\n\", mechlen);",
          "469:  vnc_client_error(vs);",
          "470:  return -1;",
          "471:     }",
          "472:     if (mechlen < 1) {",
          "473:  VNC_DEBUG(\"Too short SASL mechname %d\\n\", mechlen);",
          "474:  vnc_client_error(vs);",
          "475:  return -1;",
          "476:     }",
          "477:     vnc_read_when(vs, protocol_client_auth_sasl_mechname,mechlen);",
          "478:     return 0;",
          "479: }",
          "481: #define USES_X509_AUTH(vs)         \\",
          "482:     ((vs)->subauth == VNC_AUTH_VENCRYPT_X509NONE ||   \\",
          "483:      (vs)->subauth == VNC_AUTH_VENCRYPT_X509VNC ||    \\",
          "484:      (vs)->subauth == VNC_AUTH_VENCRYPT_X509PLAIN ||  \\",
          "485:      (vs)->subauth == VNC_AUTH_VENCRYPT_X509SASL)",
          "488: void start_auth_sasl(VncState *vs)",
          "489: {",
          "490:     const char *mechlist = NULL;",
          "491:     sasl_security_properties_t secprops;",
          "492:     int err;",
          "493:     char *localAddr, *remoteAddr;",
          "494:     int mechlistlen;",
          "496:     VNC_DEBUG(\"Initialize SASL auth %d\\n\", vs->csock);",
          "499:     if (!(localAddr = vnc_socket_local_addr(\"%s;%s\", vs->csock)))",
          "500:  goto authabort;",
          "502:     if (!(remoteAddr = vnc_socket_remote_addr(\"%s;%s\", vs->csock))) {",
          "503:  free(localAddr);",
          "504:  goto authabort;",
          "505:     }",
          "507:     err = sasl_server_new(\"vnc\",",
          "510:      localAddr,",
          "511:      remoteAddr,",
          "513:      SASL_SUCCESS_DATA,",
          "514:      &vs->sasl.conn);",
          "515:     free(localAddr);",
          "516:     free(remoteAddr);",
          "517:     localAddr = remoteAddr = NULL;",
          "519:     if (err != SASL_OK) {",
          "520:  VNC_DEBUG(\"sasl context setup failed %d (%s)\",",
          "521:     err, sasl_errstring(err, NULL, NULL));",
          "522:  vs->sasl.conn = NULL;",
          "523:  goto authabort;",
          "524:     }",
          "526: #ifdef CONFIG_VNC_TLS",
          "528:     if (vs->vd->auth == VNC_AUTH_VENCRYPT &&",
          "529:  vs->vd->subauth == VNC_AUTH_VENCRYPT_X509SASL) {",
          "530:  gnutls_cipher_algorithm_t cipher;",
          "531:  sasl_ssf_t ssf;",
          "533:  cipher = gnutls_cipher_get(vs->tls.session);",
          "534:  if (!(ssf = (sasl_ssf_t)gnutls_cipher_get_key_size(cipher))) {",
          "535:      VNC_DEBUG(\"%s\", \"cannot TLS get cipher size\\n\");",
          "536:      sasl_dispose(&vs->sasl.conn);",
          "537:      vs->sasl.conn = NULL;",
          "538:      goto authabort;",
          "539:  }",
          "542:  err = sasl_setprop(vs->sasl.conn, SASL_SSF_EXTERNAL, &ssf);",
          "543:  if (err != SASL_OK) {",
          "544:      VNC_DEBUG(\"cannot set SASL external SSF %d (%s)\\n\",",
          "545:         err, sasl_errstring(err, NULL, NULL));",
          "546:      sasl_dispose(&vs->sasl.conn);",
          "547:      vs->sasl.conn = NULL;",
          "548:      goto authabort;",
          "549:  }",
          "550:     } else",
          "552:  vs->sasl.wantSSF = 1;",
          "554:     memset (&secprops, 0, sizeof secprops);",
          "556:     if (strncmp(vs->vd->display, \"unix:\", 5) == 0",
          "557: #ifdef CONFIG_VNC_TLS",
          "560:  || (vs->vd->auth == VNC_AUTH_VENCRYPT &&",
          "561:      vs->vd->subauth == VNC_AUTH_VENCRYPT_X509SASL)",
          "563:  ) {",
          "565:  secprops.min_ssf = 0;",
          "566:  secprops.max_ssf = 0;",
          "567:  secprops.maxbufsize = 8192;",
          "568:  secprops.security_flags = 0;",
          "569:     } else {",
          "573:  secprops.maxbufsize = 8192;",
          "575:  secprops.security_flags =",
          "576:      SASL_SEC_NOANONYMOUS | SASL_SEC_NOPLAINTEXT;",
          "577:     }",
          "579:     err = sasl_setprop(vs->sasl.conn, SASL_SEC_PROPS, &secprops);",
          "580:     if (err != SASL_OK) {",
          "581:  VNC_DEBUG(\"cannot set SASL security props %d (%s)\\n\",",
          "582:     err, sasl_errstring(err, NULL, NULL));",
          "583:  sasl_dispose(&vs->sasl.conn);",
          "584:  vs->sasl.conn = NULL;",
          "585:  goto authabort;",
          "586:     }",
          "588:     err = sasl_listmech(vs->sasl.conn,",
          "593:    &mechlist,",
          "594:    NULL,",
          "595:    NULL);",
          "596:     if (err != SASL_OK) {",
          "597:  VNC_DEBUG(\"cannot list SASL mechanisms %d (%s)\\n\",",
          "598:     err, sasl_errdetail(vs->sasl.conn));",
          "599:  sasl_dispose(&vs->sasl.conn);",
          "600:  vs->sasl.conn = NULL;",
          "601:  goto authabort;",
          "602:     }",
          "603:     VNC_DEBUG(\"Available mechanisms for client: '%s'\\n\", mechlist);",
          "605:     if (!(vs->sasl.mechlist = strdup(mechlist))) {",
          "606:  VNC_DEBUG(\"Out of memory\");",
          "607:  sasl_dispose(&vs->sasl.conn);",
          "608:  vs->sasl.conn = NULL;",
          "609:  goto authabort;",
          "610:     }",
          "611:     mechlistlen = strlen(mechlist);",
          "612:     vnc_write_u32(vs, mechlistlen);",
          "613:     vnc_write(vs, mechlist, mechlistlen);",
          "614:     vnc_flush(vs);",
          "616:     VNC_DEBUG(\"Wait for client mechname length\\n\");",
          "617:     vnc_read_when(vs, protocol_client_auth_sasl_mechname_len, 4);",
          "619:     return;",
          "621:  authabort:",
          "622:     vnc_client_error(vs);",
          "623:     return;",
          "624: }",
          "",
          "---------------"
        ],
        "vnc-auth-sasl.h||vnc-auth-sasl.h": [
          "File: vnc-auth-sasl.h -> vnc-auth-sasl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26: #ifndef __QEMU_VNC_AUTH_SASL_H__",
          "27: #define __QEMU_VNC_AUTH_SASL_H__",
          "30: #include <sasl/sasl.h>",
          "32: typedef struct VncStateSASL VncStateSASL;",
          "34: struct VncStateSASL {",
          "35:     sasl_conn_t *conn;",
          "37:     int wantSSF :1;",
          "39:     int runSSF :1;",
          "46:     unsigned int waitWriteSSF;",
          "52:     const uint8_t *encoded;",
          "53:     unsigned int encodedLength;",
          "54:     unsigned int encodedOffset;",
          "55:     char *username;",
          "56:     char *mechlist;",
          "57: };",
          "59: void vnc_sasl_client_cleanup(VncState *vs);",
          "61: long vnc_client_read_sasl(VncState *vs);",
          "62: long vnc_client_write_sasl(VncState *vs);",
          "64: void start_auth_sasl(VncState *vs);",
          "",
          "---------------"
        ],
        "vnc.c||vnc.c": [
          "File: vnc.c -> vnc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "68:     return addr;",
          "69: }",
          "72:     struct sockaddr_storage sa;",
          "73:     socklen_t salen;",
          "",
          "[Removed Lines]",
          "71: static char *vnc_socket_local_addr(const char *format, int fd) {",
          "",
          "[Added Lines]",
          "72: char *vnc_socket_local_addr(const char *format, int fd) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "79:     return addr_to_string(format, &sa, salen);",
          "80: }",
          "83:     struct sockaddr_storage sa;",
          "84:     socklen_t salen;",
          "",
          "[Removed Lines]",
          "82: static char *vnc_socket_remote_addr(const char *format, int fd) {",
          "",
          "[Added Lines]",
          "84: char *vnc_socket_remote_addr(const char *format, int fd) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "125:             return \"vencrypt+x509+vnc\";",
          "126:         case VNC_AUTH_VENCRYPT_X509PLAIN:",
          "127:             return \"vencrypt+x509+plain\";",
          "128:         default:",
          "129:             return \"vencrypt\";",
          "130:         }",
          "131: #else",
          "132:         return \"vencrypt\";",
          "133: #endif",
          "134:     }",
          "135:     return \"unknown\";",
          "136: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "130:  case VNC_AUTH_VENCRYPT_TLSSASL:",
          "131:      return \"vencrypt+tls+sasl\";",
          "132:  case VNC_AUTH_VENCRYPT_X509SASL:",
          "133:      return \"vencrypt+x509+sasl\";",
          "140:     case VNC_AUTH_SASL:",
          "141:  return \"sasl\";",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "278:     vnc_write_s32(vs, encoding);",
          "279: }",
          "282: {",
          "283:     if ((buffer->capacity - buffer->offset) < len) {",
          "284:  buffer->capacity += (len + 1024);",
          "",
          "[Removed Lines]",
          "281: static void buffer_reserve(Buffer *buffer, size_t len)",
          "",
          "[Added Lines]",
          "289: void buffer_reserve(Buffer *buffer, size_t len)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "290:     }",
          "291: }",
          "294: {",
          "295:     return buffer->offset == 0;",
          "296: }",
          "299: {",
          "300:     return buffer->buffer + buffer->offset;",
          "301: }",
          "304: {",
          "305:  buffer->offset = 0;",
          "306: }",
          "309: {",
          "310:     memcpy(buffer->buffer + buffer->offset, data, len);",
          "311:     buffer->offset += len;",
          "",
          "[Removed Lines]",
          "293: static int buffer_empty(Buffer *buffer)",
          "298: static uint8_t *buffer_end(Buffer *buffer)",
          "303: static void buffer_reset(Buffer *buffer)",
          "308: static void buffer_append(Buffer *buffer, const void *data, size_t len)",
          "",
          "[Added Lines]",
          "301: int buffer_empty(Buffer *buffer)",
          "306: uint8_t *buffer_end(Buffer *buffer)",
          "311: void buffer_reset(Buffer *buffer)",
          "316: void buffer_append(Buffer *buffer, const void *data, size_t len)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "822:     }",
          "823: }",
          "826: {",
          "827:     if (ret == 0 || ret == -1) {",
          "828:         if (ret == -1) {",
          "",
          "[Removed Lines]",
          "825: static int vnc_client_io_error(VncState *vs, int ret, int last_errno)",
          "",
          "[Added Lines]",
          "834: int vnc_client_io_error(VncState *vs, int ret, int last_errno)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "848: #ifdef CONFIG_VNC_TLS",
          "849:  vnc_tls_client_cleanup(vs);",
          "851:         audio_del(vs);",
          "853:         VncState *p, *parent = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "860: #ifdef CONFIG_VNC_SASL",
          "861:         vnc_sasl_client_cleanup(vs);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "878:     vnc_client_io_error(vs, -1, EINVAL);",
          "879: }",
          "882: {",
          "883:     long ret;",
          "886: #ifdef CONFIG_VNC_TLS",
          "887:     if (vs->tls.session) {",
          "889:  if (ret < 0) {",
          "890:      if (ret == GNUTLS_E_AGAIN)",
          "891:   errno = EAGAIN;",
          "",
          "[Removed Lines]",
          "881: void vnc_client_write(void *opaque)",
          "884:     VncState *vs = opaque;",
          "888:  ret = gnutls_write(vs->tls.session, vs->output.buffer, vs->output.offset);",
          "",
          "[Added Lines]",
          "909: long vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)",
          "914:  ret = gnutls_write(vs->tls.session, data, datalen);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "895:  }",
          "896:     } else",
          "900:     if (!ret)",
          "903:     memmove(vs->output.buffer, vs->output.buffer + ret, (vs->output.offset - ret));",
          "904:     vs->output.offset -= ret;",
          "",
          "[Removed Lines]",
          "898:  ret = send(vs->csock, vs->output.buffer, vs->output.offset, 0);",
          "899:     ret = vnc_client_io_error(vs, ret, socket_error());",
          "901:  return;",
          "",
          "[Added Lines]",
          "924:  ret = send(vs->csock, data, datalen, 0);",
          "925:     VNC_DEBUG(\"Wrote wire %p %d -> %ld\\n\", data, datalen, ret);",
          "926:     return vnc_client_io_error(vs, ret, socket_error());",
          "927: }",
          "940: static long vnc_client_write_plain(VncState *vs)",
          "941: {",
          "942:     long ret;",
          "944: #ifdef CONFIG_VNC_SASL",
          "945:     VNC_DEBUG(\"Write Plain: Pending output %p size %d offset %d. Wait SSF %d\\n\",",
          "946:               vs->output.buffer, vs->output.capacity, vs->output.offset,",
          "947:               vs->sasl.waitWriteSSF);",
          "949:     if (vs->sasl.conn &&",
          "950:         vs->sasl.runSSF &&",
          "951:         vs->sasl.waitWriteSSF) {",
          "952:         ret = vnc_client_write_buf(vs, vs->output.buffer, vs->sasl.waitWriteSSF);",
          "953:         if (ret)",
          "954:             vs->sasl.waitWriteSSF -= ret;",
          "955:     } else",
          "957:         ret = vnc_client_write_buf(vs, vs->output.buffer, vs->output.offset);",
          "959:         return 0;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "906:     if (vs->output.offset == 0) {",
          "907:  qemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, NULL, vs);",
          "908:     }",
          "909: }",
          "911: void vnc_read_when(VncState *vs, VncReadEvent *func, size_t expecting)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "968:     return ret;",
          "969: }",
          "977: void vnc_client_write(void *opaque)",
          "978: {",
          "979:     long ret;",
          "980:     VncState *vs = opaque;",
          "982: #ifdef CONFIG_VNC_SASL",
          "983:     if (vs->sasl.conn &&",
          "984:         vs->sasl.runSSF &&",
          "985:         !vs->sasl.waitWriteSSF)",
          "986:         ret = vnc_client_write_sasl(vs);",
          "987:     else",
          "989:         ret = vnc_client_write_plain(vs);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "914:     vs->read_handler_expect = expecting;",
          "915: }",
          "918: {",
          "920:     long ret;",
          "924: #ifdef CONFIG_VNC_TLS",
          "925:     if (vs->tls.session) {",
          "927:  if (ret < 0) {",
          "928:      if (ret == GNUTLS_E_AGAIN)",
          "929:   errno = EAGAIN;",
          "",
          "[Removed Lines]",
          "917: void vnc_client_read(void *opaque)",
          "919:     VncState *vs = opaque;",
          "922:     buffer_reserve(&vs->input, 4096);",
          "926:  ret = gnutls_read(vs->tls.session, buffer_end(&vs->input), 4096);",
          "",
          "[Added Lines]",
          "1014: long vnc_client_read_buf(VncState *vs, uint8_t *data, size_t datalen)",
          "1019:  ret = gnutls_read(vs->tls.session, data, datalen);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "933:  }",
          "934:     } else",
          "941:     vs->input.offset += ret;",
          "943:     while (vs->read_handler && vs->input.offset >= vs->read_handler_expect) {",
          "944:  size_t len = vs->read_handler_expect;",
          "",
          "[Removed Lines]",
          "936:  ret = recv(vs->csock, buffer_end(&vs->input), 4096, 0);",
          "937:     ret = vnc_client_io_error(vs, ret, socket_error());",
          "938:     if (!ret)",
          "939:  return;",
          "",
          "[Added Lines]",
          "1029:  ret = recv(vs->csock, data, datalen, 0);",
          "1030:     VNC_DEBUG(\"Read wire %p %d -> %ld\\n\", data, datalen, ret);",
          "1031:     return vnc_client_io_error(vs, ret, socket_error());",
          "1032: }",
          "1043: static long vnc_client_read_plain(VncState *vs)",
          "1044: {",
          "1045:     int ret;",
          "1046:     VNC_DEBUG(\"Read plain %p size %d offset %d\\n\",",
          "1047:               vs->input.buffer, vs->input.capacity, vs->input.offset);",
          "1048:     buffer_reserve(&vs->input, 4096);",
          "1049:     ret = vnc_client_read_buf(vs, buffer_end(&vs->input), 4096);",
          "1050:     if (!ret)",
          "1051:         return 0;",
          "1053:     return ret;",
          "1054: }",
          "1062: void vnc_client_read(void *opaque)",
          "1063: {",
          "1064:     VncState *vs = opaque;",
          "1065:     long ret;",
          "1067: #ifdef CONFIG_VNC_SASL",
          "1068:     if (vs->sasl.conn && vs->sasl.runSSF)",
          "1069:         ret = vnc_client_read_sasl(vs);",
          "1070:     else",
          "1072:         ret = vnc_client_read_plain(vs);",
          "1073:     if (!ret)",
          "1074:  return;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1723:            break;",
          "1727:            VNC_DEBUG(\"Reject auth %d\\n\", vs->vd->auth);",
          "1728:            vnc_write_u8(vs, 1);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1859: #ifdef CONFIG_VNC_SASL",
          "1860:        case VNC_AUTH_SASL:",
          "1861:            VNC_DEBUG(\"Accept SASL auth\\n\");",
          "1862:            start_auth_sasl(vs);",
          "1863:            break;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1924: #ifdef CONFIG_VNC_TLS",
          "1925:     int tls = 0, x509 = 0;",
          "1926: #endif",
          "1928:     if (!vnc_display)",
          "1929:         return -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2067: #ifdef CONFIG_VNC_SASL",
          "2068:     int sasl = 0;",
          "2069:     int saslErr;",
          "2070: #endif",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1943:      reverse = 1;",
          "1944:  } else if (strncmp(options, \"to=\", 3) == 0) {",
          "1945:             to_port = atoi(options+3) + 5900;",
          "1946: #ifdef CONFIG_VNC_TLS",
          "1947:  } else if (strncmp(options, \"tls\", 3) == 0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2090: #ifdef CONFIG_VNC_SASL",
          "2091:  } else if (strncmp(options, \"sasl\", 4) == 0) {",
          "2093: #endif",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1991:   vs->subauth = VNC_AUTH_VENCRYPT_TLSVNC;",
          "1992:      }",
          "1993:  } else {",
          "1995:      VNC_DEBUG(\"Initializing VNC server with password auth\\n\");",
          "1996:      vs->auth = VNC_AUTH_VNC;",
          "1997: #ifdef CONFIG_VNC_TLS",
          "1998:      vs->subauth = VNC_AUTH_INVALID;",
          "1999:  }",
          "2001:     } else {",
          "2002: #ifdef CONFIG_VNC_TLS",
          "2003:  if (tls) {",
          "",
          "[Removed Lines]",
          "1994: #endif",
          "2000: #endif",
          "",
          "[Added Lines]",
          "2165: #ifdef CONFIG_VNC_SASL",
          "2166:     } else if (sasl) {",
          "2167: #ifdef CONFIG_VNC_TLS",
          "2168:         if (tls) {",
          "2169:             vs->auth = VNC_AUTH_VENCRYPT;",
          "2170:             if (x509) {",
          "2171:   VNC_DEBUG(\"Initializing VNC server with x509 SASL auth\\n\");",
          "2172:                 vs->subauth = VNC_AUTH_VENCRYPT_X509SASL;",
          "2173:             } else {",
          "2174:   VNC_DEBUG(\"Initializing VNC server with TLS SASL auth\\n\");",
          "2175:                 vs->subauth = VNC_AUTH_VENCRYPT_TLSSASL;",
          "2176:             }",
          "2177:         } else {",
          "2179:      VNC_DEBUG(\"Initializing VNC server with SASL auth\\n\");",
          "2180:             vs->auth = VNC_AUTH_SASL;",
          "2181: #ifdef CONFIG_VNC_TLS",
          "2182:             vs->subauth = VNC_AUTH_INVALID;",
          "2183:         }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2019: #endif",
          "2020:     }",
          "2022:     if (reverse) {",
          "2024:         if (strncmp(display, \"unix:\", 5) == 0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2207: #ifdef CONFIG_VNC_SASL",
          "2208:     if ((saslErr = sasl_server_init(NULL, \"qemu\")) != SASL_OK) {",
          "2209:         fprintf(stderr, \"Failed to initialize SASL auth %s\",",
          "2210:                 sasl_errstring(saslErr, NULL, NULL));",
          "2211:         free(vs->display);",
          "2212:         vs->display = NULL;",
          "2213:         return -1;",
          "2214:     }",
          "2215: #endif",
          "",
          "---------------"
        ],
        "vnc.h||vnc.h": [
          "File: vnc.h -> vnc.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "80: #include \"vnc-tls.h\"",
          "81: #include \"vnc-auth-vencrypt.h\"",
          "82: #endif",
          "84: struct VncDisplay",
          "85: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "83: #ifdef CONFIG_VNC_SASL",
          "84: #include \"vnc-auth-sasl.h\"",
          "85: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "119:     int minor;",
          "121:     char challenge[VNC_AUTH_CHALLENGE_SIZE];",
          "123: #ifdef CONFIG_VNC_TLS",
          "124:     VncStateTLS tls;",
          "125: #endif",
          "127:     Buffer output;",
          "128:     Buffer input;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "129: #ifdef CONFIG_VNC_SASL",
          "130:     VncStateSASL sasl;",
          "131: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "161:     VNC_AUTH_RA2NE = 6,",
          "162:     VNC_AUTH_TIGHT = 16,",
          "163:     VNC_AUTH_ULTRA = 17,",
          "166: };",
          "168: enum {",
          "",
          "[Removed Lines]",
          "164:     VNC_AUTH_TLS = 18,",
          "165:     VNC_AUTH_VENCRYPT = 19",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "173:     VNC_AUTH_VENCRYPT_X509NONE = 260,",
          "174:     VNC_AUTH_VENCRYPT_X509VNC = 261,",
          "175:     VNC_AUTH_VENCRYPT_X509PLAIN = 262,",
          "176: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "183:     VNC_AUTH_VENCRYPT_X509SASL = 263,",
          "184:     VNC_AUTH_VENCRYPT_TLSSASL = 264,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "256: void vnc_client_read(void *opaque);",
          "257: void vnc_client_write(void *opaque);",
          "261: void vnc_write(VncState *vs, const void *data, size_t len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "268: long vnc_client_read_buf(VncState *vs, uint8_t *data, size_t datalen);",
          "269: long vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "277: void vnc_client_error(VncState *vs);",
          "279: void start_client_init(VncState *vs);",
          "280: void start_auth_vnc(VncState *vs);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "289: int vnc_client_io_error(VncState *vs, int ret, int last_errno);",
          "295: void buffer_reserve(Buffer *buffer, size_t len);",
          "296: int buffer_empty(Buffer *buffer);",
          "297: uint8_t *buffer_end(Buffer *buffer);",
          "298: void buffer_reset(Buffer *buffer);",
          "299: void buffer_append(Buffer *buffer, const void *data, size_t len);",
          "304: char *vnc_socket_local_addr(const char *format, int fd);",
          "305: char *vnc_socket_remote_addr(const char *format, int fd);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fa0cfdf24a75f3e6aa6c8b6efcbebd09e7f054aa",
      "candidate_info": {
        "commit_hash": "fa0cfdf24a75f3e6aa6c8b6efcbebd09e7f054aa",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/fa0cfdf24a75f3e6aa6c8b6efcbebd09e7f054aa",
        "files": [
          "vnc.c"
        ],
        "message": "vnc: Set invalid buffer pointers to NULL\n\nAfter qemu_free, the pointers for input and output\nbuffers are no longer valid, so set them to NULL\n(most other calls of qemu_free in vnc.c use this\npattern, too).\n\nSigned-off-by: Stefan Weil <weil@mail.berlios.de>\nSigned-off-by: Anthony Liguori <aliguori@us.ibm.com>",
        "before_after_code_files": [
          "vnc.c||vnc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "vnc.c||vnc.c"
          ],
          "candidate": [
            "vnc.c||vnc.c"
          ]
        }
      },
      "candidate_diff": {
        "vnc.c||vnc.c": [
          "File: vnc.c -> vnc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "895: static void vnc_disconnect_finish(VncState *vs)",
          "896: {",
          "899: #ifdef CONFIG_VNC_TLS",
          "900:     vnc_tls_client_cleanup(vs);",
          "",
          "[Removed Lines]",
          "897:     if (vs->input.buffer) qemu_free(vs->input.buffer);",
          "898:     if (vs->output.buffer) qemu_free(vs->output.buffer);",
          "",
          "[Added Lines]",
          "897:     if (vs->input.buffer) {",
          "898:         qemu_free(vs->input.buffer);",
          "899:         vs->input.buffer = NULL;",
          "900:     }",
          "901:     if (vs->output.buffer) {",
          "902:         qemu_free(vs->output.buffer);",
          "903:         vs->output.buffer = NULL;",
          "904:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "41b4bef65f1e2b2f313cae0f88a1c76a9cb3f222",
      "candidate_info": {
        "commit_hash": "41b4bef65f1e2b2f313cae0f88a1c76a9cb3f222",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/41b4bef65f1e2b2f313cae0f88a1c76a9cb3f222",
        "files": [
          "vnc.c",
          "vnc.h"
        ],
        "message": "vnc: Migrate to using QTAILQ instead of custom implementation\n\nJust a 1-1 conversion for now.\n\nSigned-off-by: Amit Shah <amit.shah@redhat.com>\nSigned-off-by: Anthony Liguori <aliguori@us.ibm.com>",
        "before_after_code_files": [
          "vnc.c||vnc.c",
          "vnc.h||vnc.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "vnc.c||vnc.c"
          ],
          "candidate": [
            "vnc.c||vnc.c"
          ]
        }
      },
      "candidate_diff": {
        "vnc.c||vnc.c": [
          "File: vnc.c -> vnc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "357:     } else {",
          "358:         QList *clist;",
          "360:         clist = qlist_new();",
          "370:             }",
          "371:         }",
          "",
          "[Removed Lines]",
          "361:         if (vnc_display->clients) {",
          "362:             VncState *client = vnc_display->clients;",
          "363:             while (client) {",
          "364:                 if (client->info) {",
          "366:                     qobject_incref(client->info);",
          "367:                     qlist_append_obj(clist, client->info);",
          "368:                 }",
          "369:                 client = client->next;",
          "",
          "[Added Lines]",
          "359:         VncState *client;",
          "362:         QTAILQ_FOREACH(client, &vnc_display->clients, next) {",
          "363:             if (client->info) {",
          "365:                 qobject_incref(client->info);",
          "366:                 qlist_append_obj(clist, client->info);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "519: {",
          "520:     int size_changed;",
          "521:     VncDisplay *vd = ds->opaque;",
          "525:     if (!vd->server)",
          "",
          "[Removed Lines]",
          "522:     VncState *vs = vd->clients;",
          "",
          "[Added Lines]",
          "519:     VncState *vs;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "541:     memset(vd->guest.dirty, 0xFF, sizeof(vd->guest.dirty));",
          "544:         vnc_colordepth(vs);",
          "545:         if (size_changed) {",
          "546:             if (vs->csock != -1 && vnc_has_feature(vs, VNC_FEATURE_RESIZE)) {",
          "",
          "[Removed Lines]",
          "543:     while (vs != NULL) {",
          "",
          "[Added Lines]",
          "540:     QTAILQ_FOREACH(vs, &vd->clients, next) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "553:             }",
          "554:         }",
          "555:         memset(vs->dirty, 0xFF, sizeof(vs->dirty));",
          "557:     }",
          "558: }",
          "",
          "[Removed Lines]",
          "556:         vs = vs->next;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "867:     int cmp_bytes;",
          "869:     vnc_refresh_server_surface(vd);",
          "872:         if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT)) {",
          "873:             vs->force_update = 1;",
          "874:             vnc_update_client(vs, 1);",
          "",
          "[Removed Lines]",
          "870:     for (vs = vd->clients; vs != NULL; vs = vn) {",
          "871:         vn = vs->next;",
          "",
          "[Added Lines]",
          "866:     QTAILQ_FOREACH_SAFE(vs, &vd->clients, next, vn) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "912:             if (memcmp(src_row, dst_row, cmp_bytes) == 0)",
          "913:                 continue;",
          "914:             memmove(dst_row, src_row, cmp_bytes);",
          "918:                     vnc_set_bit(vs->dirty[y], ((x + dst_x) / 16));",
          "920:             }",
          "921:         }",
          "922:         src_row += pitch - w * depth;",
          "",
          "[Removed Lines]",
          "915:             vs = vd->clients;",
          "916:             while (vs != NULL) {",
          "917:                 if (!vnc_has_feature(vs, VNC_FEATURE_COPYRECT))",
          "919:                 vs = vs->next;",
          "",
          "[Added Lines]",
          "910:             QTAILQ_FOREACH(vs, &vd->clients, next) {",
          "911:                 if (!vnc_has_feature(vs, VNC_FEATURE_COPYRECT)) {",
          "913:                 }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "924:         y += inc;",
          "925:     }",
          "929:             vnc_copy(vs, src_x, src_y, dst_x, dst_y, w, h);",
          "930:     }",
          "931: }",
          "",
          "[Removed Lines]",
          "927:     for (vs = vd->clients; vs != NULL; vs = vs->next) {",
          "928:         if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT))",
          "",
          "[Added Lines]",
          "921:     QTAILQ_FOREACH(vs, &vd->clients, next) {",
          "922:         if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT)) {",
          "924:         }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1110:     audio_del(vs);",
          "1124:         dcl->idle = 1;",
          "1126:     vnc_remove_timer(vs->vd);",
          "1127:     qemu_free(vs);",
          "",
          "[Removed Lines]",
          "1112:     VncState *p, *parent = NULL;",
          "1113:     for (p = vs->vd->clients; p != NULL; p = p->next) {",
          "1114:         if (p == vs) {",
          "1115:             if (parent)",
          "1116:                 parent->next = p->next;",
          "1117:             else",
          "1118:                 vs->vd->clients = p->next;",
          "1119:             break;",
          "1120:         }",
          "1121:         parent = p;",
          "1122:     }",
          "1123:     if (!vs->vd->clients)",
          "",
          "[Added Lines]",
          "1107:     QTAILQ_REMOVE(&vs->vd->clients, vs, next);",
          "1109:     if (QTAILQ_EMPTY(&vs->vd->clients)) {",
          "1111:     }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2299:     uint8_t *server_row;",
          "2300:     int cmp_bytes;",
          "2301:     uint32_t width_mask[VNC_DIRTY_WORDS];",
          "2303:     int has_dirty = 0;",
          "",
          "[Removed Lines]",
          "2302:     VncState *vs = NULL;",
          "",
          "[Added Lines]",
          "2289:     VncState *vs;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2328:                 if (memcmp(server_ptr, guest_ptr, cmp_bytes) == 0)",
          "2329:                     continue;",
          "2330:                 memcpy(server_ptr, guest_ptr, cmp_bytes);",
          "2333:                     vnc_set_bit(vs->dirty[y], (x / 16));",
          "2335:                 }",
          "2336:                 has_dirty++;",
          "2337:             }",
          "",
          "[Removed Lines]",
          "2331:                 vs = vd->clients;",
          "2332:                 while (vs != NULL) {",
          "2334:                     vs = vs->next;",
          "",
          "[Added Lines]",
          "2318:                 QTAILQ_FOREACH(vs, &vd->clients, next) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2345: static void vnc_refresh(void *opaque)",
          "2346: {",
          "2347:     VncDisplay *vd = opaque;",
          "2351:     vga_hw_update();",
          "2353:     has_dirty = vnc_refresh_server_surface(vd);",
          "2358:         rects += vnc_update_client(vs, has_dirty);",
          "2361:     }",
          "",
          "[Removed Lines]",
          "2348:     VncState *vs = NULL, *vn = NULL;",
          "2349:     int has_dirty = 0, rects = 0;",
          "2355:     vs = vd->clients;",
          "2356:     while (vs != NULL) {",
          "2357:         vn = vs->next;",
          "2360:         vs = vn;",
          "",
          "[Added Lines]",
          "2333:     VncState *vs, *vn;",
          "2334:     int has_dirty, rects = 0;",
          "2340:     QTAILQ_FOREACH_SAFE(vs, &vd->clients, next, vn) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2379: static void vnc_init_timer(VncDisplay *vd)",
          "2380: {",
          "2381:     vd->timer_interval = VNC_REFRESH_INTERVAL_BASE;",
          "2383:         vd->timer = qemu_new_timer(rt_clock, vnc_refresh, vd);",
          "2384:         vnc_refresh(vd);",
          "2385:     }",
          "",
          "[Removed Lines]",
          "2382:     if (vd->timer == NULL && vd->clients != NULL) {",
          "",
          "[Added Lines]",
          "2364:     if (vd->timer == NULL && !QTAILQ_EMPTY(&vd->clients)) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2388: static void vnc_remove_timer(VncDisplay *vd)",
          "2389: {",
          "2391:         qemu_del_timer(vd->timer);",
          "2392:         qemu_free_timer(vd->timer);",
          "2393:         vd->timer = NULL;",
          "",
          "[Removed Lines]",
          "2390:     if (vd->timer != NULL && vd->clients == NULL) {",
          "",
          "[Added Lines]",
          "2372:     if (vd->timer != NULL && QTAILQ_EMPTY(&vd->clients)) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2417:     vs->as.fmt = AUD_FMT_S16;",
          "2418:     vs->as.endianness = 0;",
          "2423:     vga_hw_update();",
          "",
          "[Removed Lines]",
          "2420:     vs->next = vd->clients;",
          "2421:     vd->clients = vs;",
          "",
          "[Added Lines]",
          "2402:     QTAILQ_INSERT_HEAD(&vd->clients, vs, next);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2460:     vs->lsock = -1;",
          "2462:     vs->ds = ds;",
          "2464:     if (keyboard_layout)",
          "2465:         vs->kbd_layout = init_keyboard_layout(name2keysym, keyboard_layout);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2444:     QTAILQ_INIT(&vs->clients);",
          "",
          "---------------"
        ],
        "vnc.h||vnc.h": [
          "File: vnc.h -> vnc.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: #define __QEMU_VNC_H",
          "30: #include \"qemu-common.h\"",
          "31: #include \"console.h\"",
          "32: #include \"monitor.h\"",
          "33: #include \"audio/audio.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "31: #include \"qemu-queue.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "93: struct VncDisplay",
          "94: {",
          "95:     QEMUTimer *timer;",
          "96:     int timer_interval;",
          "97:     int lsock;",
          "98:     DisplayState *ds;",
          "100:     kbd_layout_t *kbd_layout;",
          "",
          "[Removed Lines]",
          "99:     VncState *clients;",
          "",
          "[Added Lines]",
          "96:     QTAILQ_HEAD(, VncState) clients;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "165:     Buffer zlib_tmp;",
          "166:     z_stream zlib_stream[4];",
          "169: };",
          "",
          "[Removed Lines]",
          "168:     VncState *next;",
          "",
          "[Added Lines]",
          "169:     QTAILQ_ENTRY(VncState) next;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5d418e3ba96cfa810e00885a52b55f19cac8f9a6",
      "candidate_info": {
        "commit_hash": "5d418e3ba96cfa810e00885a52b55f19cac8f9a6",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/5d418e3ba96cfa810e00885a52b55f19cac8f9a6",
        "files": [
          "vnc.c",
          "vnc.h"
        ],
        "message": "vnc: add buffer_free()\n\nAdd a buffer_free() helper to free vnc buffers and\nremove some duplicated code in vnc_disconnect_finish().\n\nSigned-off-by: Corentin Chary <corentincj@iksaif.net>\nSigned-off-by: Anthony Liguori <aliguori@us.ibm.com>",
        "before_after_code_files": [
          "vnc.c||vnc.c",
          "vnc.h||vnc.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "vnc.c||vnc.c"
          ],
          "candidate": [
            "vnc.c||vnc.c"
          ]
        }
      },
      "candidate_diff": {
        "vnc.c||vnc.c": [
          "File: vnc.c -> vnc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "508:         buffer->offset = 0;",
          "509: }",
          "511: void buffer_append(Buffer *buffer, const void *data, size_t len)",
          "512: {",
          "513:     memcpy(buffer->buffer + buffer->offset, data, len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "511: void buffer_free(Buffer *buffer)",
          "512: {",
          "513:     qemu_free(buffer->buffer);",
          "514:     buffer->offset = 0;",
          "515:     buffer->capacity = 0;",
          "516:     buffer->buffer = NULL;",
          "517: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "961: {",
          "962:     vnc_qmp_event(vs, QEVENT_VNC_DISCONNECTED);",
          "973:     qobject_decref(vs->info);",
          "",
          "[Removed Lines]",
          "964:     if (vs->input.buffer) {",
          "965:         qemu_free(vs->input.buffer);",
          "966:         vs->input.buffer = NULL;",
          "967:     }",
          "968:     if (vs->output.buffer) {",
          "969:         qemu_free(vs->output.buffer);",
          "970:         vs->output.buffer = NULL;",
          "971:     }",
          "",
          "[Added Lines]",
          "972:     buffer_free(&vs->input);",
          "973:     buffer_free(&vs->output);",
          "",
          "---------------"
        ],
        "vnc.h||vnc.h": [
          "File: vnc.h -> vnc.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "382: int buffer_empty(Buffer *buffer);",
          "383: uint8_t *buffer_end(Buffer *buffer);",
          "384: void buffer_reset(Buffer *buffer);",
          "385: void buffer_append(Buffer *buffer, const void *data, size_t len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "385: void buffer_free(Buffer *buffer);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-19880",
  "cve_desc": "exprListAppendList in window.c in SQLite 3.30.1 allows attackers to trigger an invalid pointer dereference because constant integer values in ORDER BY clauses of window definitions are mishandled.",
  "repo": "sqlite/sqlite",
  "patch_hash": "75e95e1fcd52d3ec8282edb75ac8cd0814095d54",
  "patch_info": {
    "commit_hash": "75e95e1fcd52d3ec8282edb75ac8cd0814095d54",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/75e95e1fcd52d3ec8282edb75ac8cd0814095d54",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/window.c"
    ],
    "message": "When processing constant integer values in ORDER BY clauses of window definitions (see check-in [7e4809eadfe99ebf]) be sure to fully disable the constant value to avoid an invalid pointer dereference if the expression is ever duplicated. This fixes a crash report from Yongheng and Rui.\n\nFossilOrigin-Name: 1ca0bd982ab1183bbafce0d260e4dceda5eb766ed2e7793374a88d1ae0bdd2ca",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/window.c||src/window.c"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 8223e79f987feda5c8e51ec52cec6798cca16d070b10558939e2888ca1a25b8e",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/window.c||src/window.c": [
      "File: src/window.c -> src/window.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "895:     int nInit = pList ? pList->nExpr : 0;",
      "896:     for(i=0; i<pAppend->nExpr; i++){",
      "897:       Expr *pDup = sqlite3ExprDup(pParse->db, pAppend->a[i].pExpr, 0);",
      "898:       if( bIntToNull && pDup && pDup->op==TK_INTEGER ){",
      "899:         pDup->op = TK_NULL;",
      "900:         pDup->flags &= ~(EP_IntValue|EP_IsTrue|EP_IsFalse);",
      "901:       }",
      "902:       pList = sqlite3ExprListAppend(pParse, pList, pDup);",
      "903:       if( pList ) pList->a[nInit+i].sortFlags = pAppend->a[i].sortFlags;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "898:       assert( pDup==0 || !ExprHasProperty(pDup, EP_MemToken) );",
      "902:         pDup->u.zToken = 0;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "de7109e61b4ff3b632250cdcd962a1a440609549",
      "candidate_info": {
        "commit_hash": "de7109e61b4ff3b632250cdcd962a1a440609549",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/de7109e61b4ff3b632250cdcd962a1a440609549",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/vdbeInt.h",
          "src/vdbeapi.c",
          "test/index.test"
        ],
        "message": "Ensure that the typeof() function always returns SQLITE_FLOAT for floating point values even when the value is stored as an integer to save space.\n\nFossilOrigin-Name: 48889530a9de22fee536edfd1627be62396ed18d842d5fd6d91e010b4337be95",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/vdbeInt.h||src/vdbeInt.h",
          "src/vdbeapi.c||src/vdbeapi.c",
          "test/index.test||test/index.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 005a169406ccea6e3cc42271620870d985e8bada1ad49a63656003db4911cb51",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vdbeInt.h||src/vdbeInt.h": [
          "File: src/vdbeInt.h -> src/vdbeInt.h"
        ],
        "src/vdbeapi.c||src/vdbeapi.c": [
          "File: src/vdbeapi.c -> src/vdbeapi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "269:   };",
          "270:   return aType[pVal->flags&MEM_AffMask];",
          "271: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "302: #ifdef SQLITE_DEBUG",
          "303:   {",
          "304:     int eType = SQLITE_BLOB;",
          "305:     if( pVal->flags & MEM_Null ){",
          "306:       eType = SQLITE_NULL;",
          "307:     }else if( pVal->flags & MEM_Int ){",
          "308:       eType = (pVal->flags & MEM_IntReal) ? SQLITE_FLOAT : SQLITE_INTEGER;",
          "309:     }else if( pVal->flags & MEM_Real ){",
          "310:       eType = SQLITE_FLOAT;",
          "311:     }else if( pVal->flags & MEM_Str ){",
          "312:       eType = SQLITE_TEXT;",
          "313:     }",
          "314:     assert( eType == aType[pVal->flags&MEM_AffMask] );",
          "315:   }",
          "316: #endif",
          "",
          "---------------"
        ],
        "test/index.test||test/index.test": [
          "File: test/index.test -> test/index.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "757:   SELECT * FROM t1;",
          "758:   REINDEX;",
          "759: } {0.0 1.0 1.0 1.0}",
          "761: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "760: do_execsql_test index-23.1 {",
          "761:   DROP TABLE t1;",
          "762:   CREATE TABLE t1(a REAL);",
          "763:   CREATE UNIQUE INDEX index_0 ON t1(TYPEOF(a));",
          "764:   INSERT OR IGNORE INTO t1(a) VALUES (0.1),(FALSE);",
          "765:   SELECT * FROM t1;",
          "766:   REINDEX;",
          "767: } {0.1}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "169f077e07f312172cb0e5d6cb291b91b61d9164",
      "candidate_info": {
        "commit_hash": "169f077e07f312172cb0e5d6cb291b91b61d9164",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/169f077e07f312172cb0e5d6cb291b91b61d9164",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/vdbe.c",
          "src/vdbeapi.c",
          "src/vdbeaux.c",
          "src/vdbemem.c",
          "src/vdbetrace.c"
        ],
        "message": "Make MEM_IntReal a completely independent type, meaning a floating point value stored as an integer.  This fixes a problem with arithmetic within arguments to string functions on indexes of expressions.  But it is a big change and needs lots of new testcase() macros for MC/DC and so it is initially put on this branch.\n\nFossilOrigin-Name: dba836e31cb29d339b4520acb06188a892a52e45c50aba9742966b01108e251a",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/vdbe.c||src/vdbe.c",
          "src/vdbeapi.c||src/vdbeapi.c",
          "src/vdbeaux.c||src/vdbeaux.c",
          "src/vdbemem.c||src/vdbemem.c",
          "src/vdbetrace.c||src/vdbetrace.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 48889530a9de22fee536edfd1627be62396ed18d842d5fd6d91e010b4337be95",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "295:   double rValue;",
          "296:   i64 iValue;",
          "297:   u8 enc = pRec->enc;",
          "299:   if( sqlite3AtoF(pRec->z, &rValue, pRec->n, enc)==0 ) return;",
          "300:   if( 0==sqlite3Atoi64(pRec->z, &iValue, pRec->n, enc) ){",
          "301:     pRec->u.i = iValue;",
          "",
          "[Removed Lines]",
          "298:   assert( (pRec->flags & (MEM_Str|MEM_Int|MEM_Real))==MEM_Str );",
          "",
          "[Added Lines]",
          "298:   assert( (pRec->flags & (MEM_Str|MEM_Int|MEM_Real|MEM_IntReal))==MEM_Str );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "356:         sqlite3VdbeMemStringify(pRec, enc, 1);",
          "357:       }",
          "358:     }",
          "360:   }",
          "361: }",
          "",
          "[Removed Lines]",
          "355:       if( (pRec->flags&(MEM_Real|MEM_Int)) ){",
          "359:     pRec->flags &= ~(MEM_Real|MEM_Int);",
          "",
          "[Added Lines]",
          "355:       if( (pRec->flags&(MEM_Real|MEM_Int|MEM_IntReal)) ){",
          "359:     pRec->flags &= ~(MEM_Real|MEM_Int|MEM_IntReal);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "397: static u16 SQLITE_NOINLINE computeNumericType(Mem *pMem){",
          "399:   assert( (pMem->flags & (MEM_Str|MEM_Blob))!=0 );",
          "400:   ExpandBlob(pMem);",
          "401:   if( sqlite3AtoF(pMem->z, &pMem->u.r, pMem->n, pMem->enc)==0 ){",
          "",
          "[Removed Lines]",
          "398:   assert( (pMem->flags & (MEM_Int|MEM_Real))==0 );",
          "",
          "[Added Lines]",
          "398:   assert( (pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal))==0 );",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "417: static u16 numericType(Mem *pMem){",
          "420:   }",
          "421:   if( pMem->flags & (MEM_Str|MEM_Blob) ){",
          "422:     return computeNumericType(pMem);",
          "",
          "[Removed Lines]",
          "418:   if( pMem->flags & (MEM_Int|MEM_Real) ){",
          "419:     return pMem->flags & (MEM_Int|MEM_Real);",
          "",
          "[Added Lines]",
          "418:   if( pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal) ){",
          "419:     return pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "514:     printf(p->flags & MEM_Zero ? \" NULL-nochng\" : \" NULL\");",
          "515:   }else if( (p->flags & (MEM_Int|MEM_Str))==(MEM_Int|MEM_Str) ){",
          "516:     printf(\" si:%lld\", p->u.i);",
          "518:     printf(\" ir:%lld\", p->u.i);",
          "519:   }else if( p->flags & MEM_Int ){",
          "520:     printf(\" i:%lld\", p->u.i);",
          "",
          "[Removed Lines]",
          "517:   }else if( (p->flags & (MEM_Int|MEM_IntReal))==(MEM_Int|MEM_IntReal) ){",
          "",
          "[Added Lines]",
          "517:   }else if( (p->flags & (MEM_IntReal))!=0 ){",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1630:     }",
          "1631:     pOut->u.r = rB;",
          "1632:     MemSetTypeFlag(pOut, MEM_Real);",
          "1634:       sqlite3VdbeIntegerAffinity(pOut);",
          "1635:     }",
          "1636: #endif",
          "",
          "[Removed Lines]",
          "1633:     if( ((type1|type2)&MEM_Real)==0 && !bIntint ){",
          "",
          "[Added Lines]",
          "1633:     if( ((type1|type2)&(MEM_Real|MEM_IntReal))==0 && !bIntint ){",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1803:   pIn1 = &aMem[pOp->p1];",
          "1805:     sqlite3VdbeMemRealify(pIn1);",
          "1806:   }",
          "1807:   break;",
          "",
          "[Removed Lines]",
          "1804:   if( pIn1->flags & MEM_Int ){",
          "",
          "[Added Lines]",
          "1804:   if( pIn1->flags & (MEM_Int|MEM_IntReal) ){",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1993:     affinity = pOp->p5 & SQLITE_AFF_MASK;",
          "1994:     if( affinity>=SQLITE_AFF_NUMERIC ){",
          "1995:       if( (flags1 | flags3)&MEM_Str ){",
          "1997:           applyNumericAffinity(pIn1,0);",
          "1998:           assert( flags3==pIn3->flags );",
          "",
          "[Removed Lines]",
          "1996:         if( (flags1 & (MEM_Int|MEM_Real|MEM_Str))==MEM_Str ){",
          "",
          "[Added Lines]",
          "1996:         if( (flags1 & (MEM_Int|MEM_IntReal|MEM_Real|MEM_Str))==MEM_Str ){",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2004:           flags3 = pIn3->flags;",
          "2005:         }",
          "2007:           applyNumericAffinity(pIn3,0);",
          "2008:         }",
          "2009:       }",
          "",
          "[Removed Lines]",
          "2006:         if( (flags3 & (MEM_Int|MEM_Real|MEM_Str))==MEM_Str ){",
          "",
          "[Added Lines]",
          "2006:         if( (flags3 & (MEM_Int|MEM_IntReal|MEM_Real|MEM_Str))==MEM_Str ){",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2016:         goto compare_op;",
          "2017:       }",
          "2018:     }else if( affinity==SQLITE_AFF_TEXT ){",
          "2020:         testcase( pIn1->flags & MEM_Int );",
          "2021:         testcase( pIn1->flags & MEM_Real );",
          "2022:         sqlite3VdbeMemStringify(pIn1, encoding, 1);",
          "2023:         testcase( (flags1&MEM_Dyn) != (pIn1->flags&MEM_Dyn) );",
          "2024:         flags1 = (pIn1->flags & ~MEM_TypeMask) | (flags1 & MEM_TypeMask);",
          "2025:         assert( pIn1!=pIn3 );",
          "2026:       }",
          "2028:         testcase( pIn3->flags & MEM_Int );",
          "2029:         testcase( pIn3->flags & MEM_Real );",
          "2030:         sqlite3VdbeMemStringify(pIn3, encoding, 1);",
          "2031:         testcase( (flags3&MEM_Dyn) != (pIn3->flags&MEM_Dyn) );",
          "2032:         flags3 = (pIn3->flags & ~MEM_TypeMask) | (flags3 & MEM_TypeMask);",
          "",
          "[Removed Lines]",
          "2019:       if( (flags1 & MEM_Str)==0 && (flags1 & (MEM_Int|MEM_Real))!=0 ){",
          "2027:       if( (flags3 & MEM_Str)==0 && (flags3 & (MEM_Int|MEM_Real))!=0 ){",
          "",
          "[Added Lines]",
          "2019:       if( (flags1 & MEM_Str)==0 && (flags1&(MEM_Int|MEM_Real|MEM_IntReal))!=0 ){",
          "2022:         testcase( pIn1->flags & MEM_IntReal );",
          "2028:       if( (flags3 & MEM_Str)==0 && (flags3&(MEM_Int|MEM_Real|MEM_IntReal))!=0 ){",
          "2031:         testcase( pIn3->flags & MEM_IntReal );",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2792:       pIn1->flags |= MEM_IntReal;",
          "2793:     }",
          "2794:     REGISTER_TRACE((int)(pIn1-aMem), pIn1);",
          "2795:     zAffinity++;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2795:       pIn1->flags &= ~MEM_Int;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "3989:     pIn3 = &aMem[pOp->p3];",
          "3991:       applyNumericAffinity(pIn3, 0);",
          "3992:     }",
          "3993:     iKey = sqlite3VdbeIntValue(pIn3);",
          "3998:       if( (pIn3->flags & MEM_Real)==0 ){",
          "",
          "[Removed Lines]",
          "3990:     if( (pIn3->flags & (MEM_Int|MEM_Real|MEM_Str))==MEM_Str ){",
          "3997:     if( (pIn3->flags & MEM_Int)==0 ){",
          "",
          "[Added Lines]",
          "3993:     if( (pIn3->flags & (MEM_Int|MEM_Real|MEM_IntReal|MEM_Str))==MEM_Str ){",
          "4000:     if( (pIn3->flags & (MEM_Int|MEM_IntReal))==0 ){",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "4379:   u64 iKey;",
          "4381:   pIn3 = &aMem[pOp->p3];",
          "",
          "[Removed Lines]",
          "4382:   if( (pIn3->flags & MEM_Int)==0 ){",
          "",
          "[Added Lines]",
          "4385:   if( (pIn3->flags & (MEM_Int|MEM_IntReal))==0 ){",
          "",
          "---------------"
        ],
        "src/vdbeapi.c||src/vdbeapi.c": [
          "File: src/vdbeapi.c -> src/vdbeapi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "304:     int eType = SQLITE_BLOB;",
          "305:     if( pVal->flags & MEM_Null ){",
          "306:       eType = SQLITE_NULL;",
          "310:       eType = SQLITE_FLOAT;",
          "311:     }else if( pVal->flags & MEM_Str ){",
          "312:       eType = SQLITE_TEXT;",
          "313:     }",
          "",
          "[Removed Lines]",
          "307:     }else if( pVal->flags & MEM_Int ){",
          "308:       eType = (pVal->flags & MEM_IntReal) ? SQLITE_FLOAT : SQLITE_INTEGER;",
          "309:     }else if( pVal->flags & MEM_Real ){",
          "",
          "[Added Lines]",
          "307:     }else if( pVal->flags & (MEM_Real|MEM_IntReal) ){",
          "309:     }else if( pVal->flags & MEM_Int ){",
          "310:       eType = SQLITE_INTEGER;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1849:   }else if( iIdx>=p->pUnpacked->nField ){",
          "1851:   }else if( p->pTab->aCol[iIdx].affinity==SQLITE_AFF_REAL ){",
          "1853:       sqlite3VdbeMemRealify(pMem);",
          "1854:     }",
          "1855:   }",
          "",
          "[Removed Lines]",
          "1852:     if( pMem->flags & MEM_Int ){",
          "",
          "[Added Lines]",
          "1852:     if( pMem->flags & (MEM_Int|MEM_IntReal) ){",
          "",
          "---------------"
        ],
        "src/vdbeaux.c||src/vdbeaux.c": [
          "File: src/vdbeaux.c -> src/vdbeaux.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1534:       Mem *pMem = pOp->p4.pMem;",
          "1535:       if( pMem->flags & MEM_Str ){",
          "1536:         zP4 = pMem->z;",
          "1538:         sqlite3_str_appendf(&x, \"%lld\", pMem->u.i);",
          "1539:       }else if( pMem->flags & MEM_Real ){",
          "1540:         sqlite3_str_appendf(&x, \"%.16g\", pMem->u.r);",
          "",
          "[Removed Lines]",
          "1537:       }else if( pMem->flags & MEM_Int ){",
          "",
          "[Added Lines]",
          "1537:       }else if( pMem->flags & (MEM_Int|MEM_IntReal) ){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3433:     return 0;",
          "3434:   }",
          "3437: #   define MAX_6BYTE ((((i64)0x00008000)<<32)-1)",
          "3438:     i64 i = pMem->u.i;",
          "",
          "[Removed Lines]",
          "3435:   if( flags&MEM_Int ){",
          "",
          "[Added Lines]",
          "3435:   if( flags&(MEM_Int|MEM_IntReal) ){",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4116:       if( pMem1->u.i < pMem2->u.i ) return -1;",
          "4117:       if( pMem1->u.i > pMem2->u.i ) return +1;",
          "4118:       return 0;",
          "",
          "[Removed Lines]",
          "4114:   if( combined_flags&(MEM_Int|MEM_Real) ){",
          "4115:     if( (f1 & f2 & MEM_Int)!=0 ){",
          "",
          "[Added Lines]",
          "4114:   if( combined_flags&(MEM_Int|MEM_Real|MEM_IntReal) ){",
          "4115:     if( (f1 & f2 & (MEM_Int|MEM_IntReal))!=0 ){",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4122:       if( pMem1->u.r > pMem2->u.r ) return +1;",
          "4123:       return 0;",
          "4124:     }",
          "4126:       if( (f2&MEM_Real)!=0 ){",
          "4127:         return sqlite3IntFloatCompare(pMem1->u.i, pMem2->u.r);",
          "4128:       }else{",
          "4129:         return -1;",
          "4130:       }",
          "4131:     }",
          "4132:     if( (f1&MEM_Real)!=0 ){",
          "4134:         return -sqlite3IntFloatCompare(pMem2->u.i, pMem1->u.r);",
          "4135:       }else{",
          "4136:         return -1;",
          "",
          "[Removed Lines]",
          "4125:     if( (f1&MEM_Int)!=0 ){",
          "4133:       if( (f2&MEM_Int)!=0 ){",
          "",
          "[Added Lines]",
          "4125:     if( (f1&(MEM_Int|MEM_IntReal))!=0 ){",
          "4128:       }else if( (f2&(MEM_Int|MEM_IntReal))!=0 ){",
          "4129:         if( pMem1->u.i < pMem2->u.i ) return -1;",
          "4130:         if( pMem1->u.i > pMem2->u.i ) return +1;",
          "4131:         return 0;",
          "4137:       if( (f2&(MEM_Int|MEM_IntReal))!=0 ){",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4279:     u32 serial_type;",
          "4283:       serial_type = aKey1[idx1];",
          "4284:       testcase( serial_type==12 );",
          "4285:       if( serial_type>=10 ){",
          "",
          "[Removed Lines]",
          "4282:     if( pRhs->flags & MEM_Int ){",
          "",
          "[Added Lines]",
          "4286:     if( pRhs->flags & (MEM_Int|MEM_IntReal) ){",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4624:     testcase( flags & MEM_Real );",
          "4625:     testcase( flags & MEM_Null );",
          "4626:     testcase( flags & MEM_Blob );",
          "4628:       assert( flags & MEM_Str );",
          "4629:       return vdbeRecordCompareString;",
          "4630:     }",
          "",
          "[Removed Lines]",
          "4627:     if( (flags & (MEM_Real|MEM_Null|MEM_Blob))==0 && p->pKeyInfo->aColl[0]==0 ){",
          "",
          "[Added Lines]",
          "4631:     if( (flags & (MEM_Real|MEM_IntReal|MEM_Null|MEM_Blob))==0",
          "4632:      && p->pKeyInfo->aColl[0]==0",
          "4633:     ){",
          "",
          "---------------"
        ],
        "src/vdbemem.c||src/vdbemem.c": [
          "File: src/vdbemem.c -> src/vdbemem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #include \"sqliteInt.h\"",
          "19: #include \"vdbeInt.h\"",
          "21: #ifdef SQLITE_DEBUG",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: #define ISPOWEROF2(X)  (((X)&((X)-1))==0)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "38:   assert( (p->flags & MEM_Dyn)==0 || p->szMalloc==0 );",
          "43:   if( p->flags & MEM_Null ){",
          "",
          "[Removed Lines]",
          "41:   assert( (p->flags & (MEM_Int|MEM_Real))!=(MEM_Int|MEM_Real) );",
          "",
          "[Added Lines]",
          "46:   assert( ISPOWEROF2(p->flags & (MEM_Int|MEM_Real|MEM_IntReal)) );",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "93: #endif",
          "99: static void vdbeMemRenderNum(int sz, char *zBuf, Mem *p){",
          "100:   StrAccum acc;",
          "102:   sqlite3StrAccumInit(&acc, 0, zBuf, sz, 0);",
          "106:     sqlite3_str_appendf(&acc, \"%lld\", p->u.i);",
          "107:   }else{",
          "108:     sqlite3_str_appendf(&acc, \"%!.15g\", p->u.r);",
          "109:   }",
          "",
          "[Removed Lines]",
          "101:   assert( p->flags & (MEM_Int|MEM_Real) );",
          "103:   if( p->flags & MEM_IntReal ){",
          "104:     sqlite3_str_appendf(&acc, \"%!.15g\", (double)p->u.i);",
          "105:   }else if( p->flags & MEM_Int ){",
          "",
          "[Added Lines]",
          "106:   assert( p->flags & (MEM_Int|MEM_Real|MEM_IntReal) );",
          "108:   if( p->flags & MEM_Int ){",
          "110:   }else if( p->flags & MEM_IntReal ){",
          "111:     sqlite3_str_appendf(&acc, \"%!.15g\", (double)p->u.i);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "136:   char *z;",
          "137:   int i, j, incr;",
          "138:   if( (p->flags & MEM_Str)==0 ) return 1;",
          "140:   vdbeMemRenderNum(sizeof(zBuf), zBuf, p);",
          "141:   z = p->z;",
          "142:   i = j = 0;",
          "",
          "[Removed Lines]",
          "139:   if( (p->flags & (MEM_Int|MEM_Real))==0 ) return 1;",
          "",
          "[Added Lines]",
          "144:   if( (p->flags & (MEM_Int|MEM_Real|MEM_IntReal))==0 ) return 1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "369:   assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );",
          "370:   assert( !(pMem->flags&MEM_Zero) );",
          "371:   assert( !(pMem->flags&(MEM_Str|MEM_Blob)) );",
          "373:   assert( !sqlite3VdbeMemIsRowSet(pMem) );",
          "374:   assert( EIGHT_BYTE_ALIGNMENT(pMem) );",
          "",
          "[Removed Lines]",
          "372:   assert( pMem->flags&(MEM_Int|MEM_Real) );",
          "",
          "[Added Lines]",
          "377:   assert( pMem->flags&(MEM_Int|MEM_Real|MEM_IntReal) );",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "558:   assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );",
          "559:   assert( EIGHT_BYTE_ALIGNMENT(pMem) );",
          "560:   flags = pMem->flags;",
          "562:     return pMem->u.i;",
          "563:   }else if( flags & MEM_Real ){",
          "564:     return doubleToInt64(pMem->u.r);",
          "",
          "[Removed Lines]",
          "561:   if( flags & MEM_Int ){",
          "",
          "[Added Lines]",
          "566:   if( flags & (MEM_Int|MEM_IntReal) ){",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "587:   assert( EIGHT_BYTE_ALIGNMENT(pMem) );",
          "588:   if( pMem->flags & MEM_Real ){",
          "589:     return pMem->u.r;",
          "591:     return (double)pMem->u.i;",
          "592:   }else if( pMem->flags & (MEM_Str|MEM_Blob) ){",
          "593:     return memRealValue(pMem);",
          "",
          "[Removed Lines]",
          "590:   }else if( pMem->flags & MEM_Int ){",
          "",
          "[Added Lines]",
          "595:   }else if( pMem->flags & (MEM_Int|MEM_IntReal) ){",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "604: int sqlite3VdbeBooleanValue(Mem *pMem, int ifNull){",
          "606:   if( pMem->flags & MEM_Null ) return ifNull;",
          "607:   return sqlite3VdbeRealValue(pMem)!=0.0;",
          "608: }",
          "",
          "[Removed Lines]",
          "605:   if( pMem->flags & MEM_Int ) return pMem->u.i!=0;",
          "",
          "[Added Lines]",
          "610:   if( pMem->flags & (MEM_Int|MEM_IntReal) ) return pMem->u.i!=0;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "685: int sqlite3VdbeMemNumerify(Mem *pMem){",
          "687:     int rc;",
          "688:     assert( (pMem->flags & (MEM_Blob|MEM_Str))!=0 );",
          "689:     assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );",
          "",
          "[Removed Lines]",
          "686:   if( (pMem->flags & (MEM_Int|MEM_Real|MEM_Null))==0 ){",
          "",
          "[Added Lines]",
          "691:   if( (pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal|MEM_Null))==0 ){",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "701:       }",
          "702:     }",
          "703:   }",
          "705:   pMem->flags &= ~(MEM_Str|MEM_Blob|MEM_Zero);",
          "706:   return SQLITE_OK;",
          "707: }",
          "",
          "[Removed Lines]",
          "704:   assert( (pMem->flags & (MEM_Int|MEM_Real|MEM_Null))!=0 );",
          "",
          "[Added Lines]",
          "709:   assert( (pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal|MEM_Null))!=0 );",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "930:       u16 mFlags = pMem->flags & pX->flags & pX->mScopyFlags;",
          "932:       assert( (mFlags&MEM_Real)==0 || pMem->u.r==pX->u.r );",
          "933:       assert( (mFlags&MEM_Str)==0  || (pMem->n==pX->n && pMem->z==pX->z) );",
          "934:       assert( (mFlags&MEM_Blob)==0  || sqlite3BlobCompare(pMem,pX)==0 );",
          "",
          "[Removed Lines]",
          "931:       assert( (mFlags&MEM_Int)==0 || pMem->u.i==pX->u.i );",
          "",
          "[Added Lines]",
          "936:       assert( (mFlags&(MEM_Int|MEM_IntReal))==0 || pMem->u.i==pX->u.i );",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1491:     }else{",
          "1492:       sqlite3ValueApplyAffinity(pVal, affinity, SQLITE_UTF8);",
          "1493:     }",
          "1495:     if( enc!=SQLITE_UTF8 ){",
          "1496:       rc = sqlite3VdbeChangeEncoding(pVal, enc);",
          "1497:     }",
          "",
          "[Removed Lines]",
          "1494:     if( pVal->flags & (MEM_Int|MEM_Real) ) pVal->flags &= ~MEM_Str;",
          "",
          "[Added Lines]",
          "1499:     if( pVal->flags & (MEM_Int|MEM_IntReal|MEM_Real) ) pVal->flags &= ~MEM_Str;",
          "",
          "---------------"
        ],
        "src/vdbetrace.c||src/vdbetrace.c": [
          "File: src/vdbetrace.c -> src/vdbetrace.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "130:       pVar = &p->aVar[idx-1];",
          "131:       if( pVar->flags & MEM_Null ){",
          "132:         sqlite3_str_append(&out, \"NULL\", 4);",
          "134:         sqlite3_str_appendf(&out, \"%lld\", pVar->u.i);",
          "135:       }else if( pVar->flags & MEM_Real ){",
          "136:         sqlite3_str_appendf(&out, \"%!.15g\", pVar->u.r);",
          "",
          "[Removed Lines]",
          "133:       }else if( pVar->flags & MEM_Int ){",
          "",
          "[Added Lines]",
          "133:       }else if( pVar->flags & (MEM_Int|MEM_IntReal) ){",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "247c1b4a0bef2dcefffb96ce228136c63564be75",
      "candidate_info": {
        "commit_hash": "247c1b4a0bef2dcefffb96ce228136c63564be75",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/247c1b4a0bef2dcefffb96ce228136c63564be75",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/update.c",
          "test/update2.test"
        ],
        "message": "Make sure cursors are opened on all indexes for an UPDATE OR REPLACE regardless of whether or not the indexes are partial or contain columns that might need to be updated.\n\nFossilOrigin-Name: e148cdad35520e6684cfeba23b003f60b55f83a6bf621aff16be8aa5612cdcee",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/update.c||src/update.c",
          "test/update2.test||test/update2.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: ba3b8412726548a0716c1a2d67260c3b7e31956474f4cd4ce607cf2cebc667dd",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/update.c||src/update.c": [
          "File: src/update.c -> src/update.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "357:   for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){",
          "358:     int reg;",
          "359:     if( chngKey || hasFK>1 || pIdx==pPk",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "357:   if( onError==OE_Replace ) bReplace = 1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "367:         if( indexColumnIsBeingUpdated(pIdx, i, aXRef, chngRowid) ){",
          "368:           reg = ++pParse->nMem;",
          "369:           pParse->nMem += pIdx->nColumn;",
          "373:             bReplace = 1;",
          "374:           }",
          "375:           break;",
          "",
          "[Removed Lines]",
          "370:           if( (onError==OE_Replace)",
          "371:            || (onError==OE_Default && pIdx->onError==OE_Replace)",
          "372:           ){",
          "",
          "[Added Lines]",
          "371:           if( onError==OE_Default && pIdx->onError==OE_Replace ){",
          "",
          "---------------"
        ],
        "test/update2.test||test/update2.test": [
          "File: test/update2.test -> test/update2.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "216:   SELECT * FROM d1;",
          "217: } {3 2}",
          "219: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "219: # 2019-01-22 Bug in UPDATE OR REPLACE discovered by the",
          "220: # Matt Denton's LPM fuzzer",
          "221: #",
          "222: do_execsql_test 7.100 {",
          "223:   DROP TABLE IF EXISTS t1;",
          "224:   CREATE TABLE t1(x,y);",
          "225:   CREATE UNIQUE INDEX t1x1 ON t1(x) WHERE x IS NOT NULL;",
          "226:   INSERT INTO t1(x) VALUES(NULL),(NULL);",
          "227:   CREATE INDEX t1x2 ON t1(y);",
          "228:   SELECT quote(x), quote(y), '|' FROM t1;",
          "229: } {NULL NULL | NULL NULL |}",
          "230: do_execsql_test 7.110 {",
          "231:   UPDATE OR REPLACE t1 SET x=1;",
          "232:   SELECT quote(x), quote(y), '|' FROM t1;",
          "233: } {1 NULL |}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2046a773658569ad88df4590d808b1ee16c2d14b",
      "candidate_info": {
        "commit_hash": "2046a773658569ad88df4590d808b1ee16c2d14b",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/2046a773658569ad88df4590d808b1ee16c2d14b",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/select.c",
          "src/window.c"
        ],
        "message": "Fix the patch on this branch so that it works with sub-queries, as well as views.\n\nFossilOrigin-Name: 7480db307c39b86bce269583e5917f5e1a3990500552fd98400ef3e7088c0b2a",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/select.c||src/select.c",
          "src/window.c||src/window.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid",
            "src/window.c||src/window.c"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid",
            "src/window.c||src/window.c"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 09cd0c0c6e6c963e0039a733876e5149adb3cd10e9b92699fa1dcb0633e997a4",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/select.c||src/select.c": [
          "File: src/select.c -> src/select.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5196:       Select *pSel = pFrom->pSelect;",
          "5197:       if( pSel ){",
          "5198:         while( pSel->pPrior ) pSel = pSel->pPrior;",
          "5202:       }",
          "5203:     }",
          "5204:   }",
          "",
          "[Removed Lines]",
          "5199:         sqlite3SelectAddColumnTypeAndCollation(",
          "5200:           pParse, pTab, pSel, SQLITE_AFF_BLOB",
          "5201:         );",
          "",
          "[Added Lines]",
          "5199:         sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSel, 0);",
          "",
          "---------------"
        ],
        "src/window.c||src/window.c": [
          "File: src/window.c -> src/window.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "994:       p->pSrc->a[0].pSelect = pSub;",
          "995:       sqlite3SrcListAssignCursors(pParse, p->pSrc);",
          "996:       pSub->selFlags |= SF_Expanded;",
          "998:       if( pTab2==0 ){",
          "999:         rc = SQLITE_NOMEM;",
          "1000:       }else{",
          "",
          "[Removed Lines]",
          "997:       pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, SQLITE_AFF_BLOB);",
          "",
          "[Added Lines]",
          "997:       pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, 0);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b92d7d264ea0b811267a91b0ece3e7170bd57d6a",
      "candidate_info": {
        "commit_hash": "b92d7d264ea0b811267a91b0ece3e7170bd57d6a",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/b92d7d264ea0b811267a91b0ece3e7170bd57d6a",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/wal.c"
        ],
        "message": "Add a defense-in-depth NEVER() test to the WAL cleanup code.\n\nFossilOrigin-Name: 8d3af2010f4f652865f5c0d18e3bc793de05f8e75e75cc77786f61004b2ad28f",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/wal.c||src/wal.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 39225cc77579896214dceb93b7f224b4b3bc95b3505a2e19b41b0b18b184fbc4",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/wal.c||src/wal.c": [
          "File: src/wal.c -> src/wal.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1001:   assert( pWal->nWiData>walFramePage(pWal->hdr.mxFrame) );",
          "1002:   assert( pWal->apWiData[walFramePage(pWal->hdr.mxFrame)] );",
          "",
          "[Removed Lines]",
          "1003:   walHashGet(pWal, walFramePage(pWal->hdr.mxFrame), &sLoc);",
          "",
          "[Added Lines]",
          "1004:   rc = walHashGet(pWal, walFramePage(pWal->hdr.mxFrame), &sLoc);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
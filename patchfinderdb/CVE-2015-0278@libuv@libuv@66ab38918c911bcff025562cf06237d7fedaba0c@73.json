{
  "cve_id": "CVE-2015-0278",
  "cve_desc": "libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.",
  "repo": "libuv/libuv",
  "patch_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
  "patch_info": {
    "commit_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
    "repo": "libuv/libuv",
    "commit_url": "https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c",
    "files": [
      "src/unix/process.c"
    ],
    "message": "unix: call setgoups before calling setuid/setgid\n\nPartial fix for #1093",
    "before_after_code_files": [
      "src/unix/process.c||src/unix/process.c"
    ]
  },
  "patch_diff": {
    "src/unix/process.c||src/unix/process.c": [
      "File: src/unix/process.c -> src/unix/process.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "330:     _exit(127);",
      "331:   }",
      "333:   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {",
      "334:     uv__write_int(error_fd, -errno);",
      "335:     perror(\"setgid()\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "333:   if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {",
      "341:     SAVE_ERRNO(setgroups(0, NULL));",
      "342:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3fba0bf65f091b91a9760530c05c6339c658d88b",
      "candidate_info": {
        "commit_hash": "3fba0bf65f091b91a9760530c05c6339c658d88b",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/3fba0bf65f091b91a9760530c05c6339c658d88b",
        "files": [
          "ChangeLog",
          "src/version.c"
        ],
        "message": "2013.05.11, Version 0.11.2 (Unstable)\n\nChanges since version 0.11.1:\n\n* darwin: look up file path with F_GETPATH (Ben Noordhuis)\n\n* unix, windows: add uv_has_ref() function (Sa\u00fal Ibarra Corretg\u00e9)\n\n* build: avoid double / in paths for dtrace (Timothy J. Fontaine)\n\n* unix: remove src/unix/cygwin.c (Ben Noordhuis)\n\n* windows: deal with the fact that GetTickCount might lag (Bert Belder)\n\n* unix: silence STATIC_ASSERT compiler warnings (Ben Noordhuis)\n\n* linux: don't use fopen() in uv_resident_set_memory() (Ben Noordhuis)",
        "before_after_code_files": [
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: #define UV_VERSION_MAJOR 0",
          "31: #define UV_VERSION_MINOR 11",
          "32: #define UV_VERSION_PATCH 2",
          "36: #define UV_VERSION  ((UV_VERSION_MAJOR << 16) | \\",
          "",
          "[Removed Lines]",
          "33: #define UV_VERSION_IS_RELEASE 0",
          "",
          "[Added Lines]",
          "33: #define UV_VERSION_IS_RELEASE 1",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b2341e77099393bbdb6a00dc92598c5efb0c3545",
      "candidate_info": {
        "commit_hash": "b2341e77099393bbdb6a00dc92598c5efb0c3545",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/b2341e77099393bbdb6a00dc92598c5efb0c3545",
        "files": [
          "src/win/stream.c"
        ],
        "message": "windows: fix typo",
        "before_after_code_files": [
          "src/win/stream.c||src/win/stream.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/win/stream.c||src/win/stream.c": [
          "File: src/win/stream.c -> src/win/stream.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "246: int uv_stream_set_blocking(uv_stream_t* handle, int blocking) {",
          "248:     return UV_EINVAL;",
          "250:   if (blocking != 0)",
          "",
          "[Removed Lines]",
          "247:   if (stream->type != UV_NAMED_PIPE)",
          "",
          "[Added Lines]",
          "247:   if (handle->type != UV_NAMED_PIPE)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d7115f067747c3209ff0559ae62b15dc12038b3a",
      "candidate_info": {
        "commit_hash": "d7115f067747c3209ff0559ae62b15dc12038b3a",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/d7115f067747c3209ff0559ae62b15dc12038b3a",
        "files": [
          "src/unix/stream.c",
          "src/win/handle.c",
          "test/test-active.c",
          "test/test-fs-poll.c",
          "test/test-ipc-send-recv.c",
          "test/test-ipc.c",
          "test/test-ping-pong.c",
          "test/test-poll.c",
          "test/test-shutdown-close.c",
          "test/test-spawn.c",
          "test/test-timer-again.c",
          "test/test-timer.c",
          "test/test-udp-send-and-recv.c"
        ],
        "message": "unix, windows: make uv_is_*() always return 0 or 1\n\nEnsure that the following API functions always return either 0 or 1:\n\n  * uv_is_active()\n  * uv_is_closing()\n  * uv_is_readable()\n  * uv_is_writable()",
        "before_after_code_files": [
          "src/unix/stream.c||src/unix/stream.c",
          "src/win/handle.c||src/win/handle.c",
          "test/test-active.c||test/test-active.c",
          "test/test-fs-poll.c||test/test-fs-poll.c",
          "test/test-ipc-send-recv.c||test/test-ipc-send-recv.c",
          "test/test-ipc.c||test/test-ipc.c",
          "test/test-ping-pong.c||test/test-ping-pong.c",
          "test/test-poll.c||test/test-poll.c",
          "test/test-shutdown-close.c||test/test-shutdown-close.c",
          "test/test-spawn.c||test/test-spawn.c",
          "test/test-timer-again.c||test/test-timer-again.c",
          "test/test-timer.c||test/test-timer.c",
          "test/test-udp-send-and-recv.c||test/test-udp-send-and-recv.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/unix/stream.c||src/unix/stream.c": [
          "File: src/unix/stream.c -> src/unix/stream.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1386: int uv_is_readable(const uv_stream_t* stream) {",
          "1388: }",
          "1391: int uv_is_writable(const uv_stream_t* stream) {",
          "1393: }",
          "",
          "[Removed Lines]",
          "1387:   return stream->flags & UV_STREAM_READABLE;",
          "1392:   return stream->flags & UV_STREAM_WRITABLE;",
          "",
          "[Added Lines]",
          "1387:   return !!(stream->flags & UV_STREAM_READABLE);",
          "1392:   return !!(stream->flags & UV_STREAM_WRITABLE);",
          "",
          "---------------"
        ],
        "src/win/handle.c||src/win/handle.c": [
          "File: src/win/handle.c -> src/win/handle.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "151: int uv_is_closing(const uv_handle_t* handle) {",
          "153: }",
          "",
          "[Removed Lines]",
          "152:   return handle->flags & (UV__HANDLE_CLOSING | UV_HANDLE_CLOSED);",
          "",
          "[Added Lines]",
          "152:   return !!(handle->flags & (UV__HANDLE_CLOSING | UV_HANDLE_CLOSED));",
          "",
          "---------------"
        ],
        "test/test-active.c||test/test-active.c": [
          "File: test/test-active.c -> test/test-active.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "47:   r = uv_timer_init(uv_default_loop(), &timer);",
          "48:   ASSERT(r == 0);",
          "53:   r = uv_timer_start(&timer, timer_cb, 1000, 0);",
          "54:   ASSERT(r == 0);",
          "59:   r = uv_timer_stop(&timer);",
          "60:   ASSERT(r == 0);",
          "65:   r = uv_timer_start(&timer, timer_cb, 1000, 0);",
          "66:   ASSERT(r == 0);",
          "71:   uv_close((uv_handle_t*) &timer, close_cb);",
          "76:   r = uv_run(uv_default_loop(), UV_RUN_DEFAULT);",
          "77:   ASSERT(r == 0);",
          "",
          "[Removed Lines]",
          "50:   ASSERT(!uv_is_active((uv_handle_t*) &timer));",
          "51:   ASSERT(!uv_is_closing((uv_handle_t*) &timer));",
          "56:   ASSERT(uv_is_active((uv_handle_t*) &timer));",
          "57:   ASSERT(!uv_is_closing((uv_handle_t*) &timer));",
          "62:   ASSERT(!uv_is_active((uv_handle_t*) &timer));",
          "63:   ASSERT(!uv_is_closing((uv_handle_t*) &timer));",
          "68:   ASSERT(uv_is_active((uv_handle_t*) &timer));",
          "69:   ASSERT(!uv_is_closing((uv_handle_t*) &timer));",
          "73:   ASSERT(!uv_is_active((uv_handle_t*) &timer));",
          "74:   ASSERT(uv_is_closing((uv_handle_t*) &timer));",
          "",
          "[Added Lines]",
          "51:   ASSERT(0 == uv_is_active((uv_handle_t*) &timer));",
          "52:   ASSERT(0 == uv_is_closing((uv_handle_t*) &timer));",
          "57:   ASSERT(1 == uv_is_active((uv_handle_t*) &timer));",
          "58:   ASSERT(0 == uv_is_closing((uv_handle_t*) &timer));",
          "63:   ASSERT(0 == uv_is_active((uv_handle_t*) &timer));",
          "64:   ASSERT(0 == uv_is_closing((uv_handle_t*) &timer));",
          "69:   ASSERT(1 == uv_is_active((uv_handle_t*) &timer));",
          "70:   ASSERT(0 == uv_is_closing((uv_handle_t*) &timer));",
          "74:   ASSERT(0 == uv_is_active((uv_handle_t*) &timer));",
          "75:   ASSERT(1 == uv_is_closing((uv_handle_t*) &timer));",
          "",
          "---------------"
        ],
        "test/test-fs-poll.c||test/test-fs-poll.c": [
          "File: test/test-fs-poll.c -> test/test-fs-poll.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "81:   memset(&zero_statbuf, 0, sizeof(zero_statbuf));",
          "83:   ASSERT(handle == &poll_handle);",
          "85:   ASSERT(prev != NULL);",
          "86:   ASSERT(curr != NULL);",
          "",
          "[Removed Lines]",
          "84:   ASSERT(uv_is_active((uv_handle_t*)handle));",
          "",
          "[Added Lines]",
          "84:   ASSERT(1 == uv_is_active((uv_handle_t*) handle));",
          "",
          "---------------"
        ],
        "test/test-ipc-send-recv.c||test/test-ipc-send-recv.c": [
          "File: test/test-ipc-send-recv.c -> test/test-ipc-send-recv.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "211:   ASSERT(r == 0);",
          "213:   uv_pipe_open(&ctx.channel, 0);",
          "218:   r = uv_read2_start((uv_stream_t*)&ctx.channel, alloc_cb, read2_cb);",
          "219:   ASSERT(r == 0);",
          "",
          "[Removed Lines]",
          "214:   ASSERT(uv_is_readable((uv_stream_t*)&ctx.channel));",
          "215:   ASSERT(uv_is_writable((uv_stream_t*)&ctx.channel));",
          "216:   ASSERT(!uv_is_closing((uv_handle_t*)&ctx.channel));",
          "",
          "[Added Lines]",
          "214:   ASSERT(1 == uv_is_readable((uv_stream_t*)&ctx.channel));",
          "215:   ASSERT(1 == uv_is_writable((uv_stream_t*)&ctx.channel));",
          "216:   ASSERT(0 == uv_is_closing((uv_handle_t*)&ctx.channel));",
          "",
          "---------------"
        ],
        "test/test-ipc.c||test/test-ipc.c": [
          "File: test/test-ipc.c -> test/test-ipc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "560:   uv_pipe_open(&channel, 0);",
          "566:   r = uv_tcp_init(uv_default_loop(), &tcp_server);",
          "567:   ASSERT(r == 0);",
          "",
          "[Removed Lines]",
          "562:   ASSERT(uv_is_readable((uv_stream_t*) &channel));",
          "563:   ASSERT(uv_is_writable((uv_stream_t*) &channel));",
          "564:   ASSERT(!uv_is_closing((uv_handle_t*) &channel));",
          "",
          "[Added Lines]",
          "562:   ASSERT(1 == uv_is_readable((uv_stream_t*) &channel));",
          "563:   ASSERT(1 == uv_is_writable((uv_stream_t*) &channel));",
          "564:   ASSERT(0 == uv_is_closing((uv_handle_t*) &channel));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "610:   uv_pipe_open(&channel, 0);",
          "616:   r = uv_tcp_init(uv_default_loop(), &tcp_server);",
          "617:   ASSERT(r == 0);",
          "",
          "[Removed Lines]",
          "612:   ASSERT(uv_is_readable((uv_stream_t*)&channel));",
          "613:   ASSERT(uv_is_writable((uv_stream_t*)&channel));",
          "614:   ASSERT(!uv_is_closing((uv_handle_t*)&channel));",
          "",
          "[Added Lines]",
          "612:   ASSERT(1 == uv_is_readable((uv_stream_t*) &channel));",
          "613:   ASSERT(1 == uv_is_writable((uv_stream_t*) &channel));",
          "614:   ASSERT(0 == uv_is_closing((uv_handle_t*) &channel));",
          "",
          "---------------"
        ],
        "test/test-ping-pong.c||test/test-ping-pong.c": [
          "File: test/test-ping-pong.c -> test/test-ping-pong.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "140:   ASSERT(status == 0);",
          "146:   pinger_write_ping(pinger);",
          "",
          "[Removed Lines]",
          "142:   ASSERT(uv_is_readable(req->handle));",
          "143:   ASSERT(uv_is_writable(req->handle));",
          "144:   ASSERT(!uv_is_closing((uv_handle_t *)req->handle));",
          "",
          "[Added Lines]",
          "142:   ASSERT(1 == uv_is_readable(req->handle));",
          "143:   ASSERT(1 == uv_is_writable(req->handle));",
          "144:   ASSERT(0 == uv_is_closing((uv_handle_t *) req->handle));",
          "",
          "---------------"
        ],
        "test/test-poll.c||test/test-poll.c": [
          "File: test/test-poll.c -> test/test-poll.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "408:   if (context->events != 0) {",
          "410:   } else {",
          "412:   }",
          "413: }",
          "",
          "[Removed Lines]",
          "409:     ASSERT(uv_is_active((uv_handle_t*) handle));",
          "411:     ASSERT(!uv_is_active((uv_handle_t*) handle));",
          "",
          "[Added Lines]",
          "409:     ASSERT(1 == uv_is_active((uv_handle_t*) handle));",
          "411:     ASSERT(0 == uv_is_active((uv_handle_t*) handle));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "418:   int r;",
          "424:   ASSERT(context->delayed_events != 0);",
          "",
          "[Removed Lines]",
          "421:   ASSERT(!uv_is_active((uv_handle_t*) timer));",
          "",
          "[Added Lines]",
          "421:   ASSERT(0 == uv_is_active((uv_handle_t*) timer));",
          "",
          "---------------"
        ],
        "test/test-shutdown-close.c||test/test-shutdown-close.c": [
          "File: test/test-shutdown-close.c -> test/test-shutdown-close.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "57:   r = uv_shutdown(&shutdown_req, req->handle, shutdown_cb);",
          "58:   ASSERT(r == 0);",
          "60:   uv_close((uv_handle_t*) req->handle, close_cb);",
          "63:   connect_cb_called++;",
          "64: }",
          "",
          "[Removed Lines]",
          "59:   ASSERT(!uv_is_closing((uv_handle_t*) req->handle));",
          "61:   ASSERT(uv_is_closing((uv_handle_t*) req->handle));",
          "",
          "[Added Lines]",
          "59:   ASSERT(0 == uv_is_closing((uv_handle_t*) req->handle));",
          "61:   ASSERT(1 == uv_is_closing((uv_handle_t*) req->handle));",
          "",
          "---------------"
        ],
        "test/test-spawn.c||test/test-spawn.c": [
          "File: test/test-spawn.c -> test/test-spawn.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "169:   init_process_options(\"\", exit_cb_expect_enoent);",
          "170:   options.file = options.args[0] = \"program-that-had-better-not-exist\";",
          "171:   ASSERT(0 == uv_spawn(uv_default_loop(), &process, &options));",
          "173:   ASSERT(0 == uv_run(uv_default_loop(), UV_RUN_DEFAULT));",
          "174:   ASSERT(1 == exit_cb_called);",
          "",
          "[Removed Lines]",
          "172:   ASSERT(0 != uv_is_active((uv_handle_t*)&process));",
          "",
          "[Added Lines]",
          "172:   ASSERT(1 == uv_is_active((uv_handle_t*) &process));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "962:   ASSERT(0 == uv_is_closing((uv_handle_t*) &process));",
          "963:   uv_close((uv_handle_t*) &process, NULL);",
          "964:   ASSERT(0 == uv_run(uv_default_loop(), UV_RUN_DEFAULT));",
          "966:   MAKE_VALGRIND_HAPPY();",
          "967:   return 0;",
          "968: }",
          "",
          "[Removed Lines]",
          "965:   ASSERT(0 != uv_is_closing((uv_handle_t*) &process));",
          "",
          "[Added Lines]",
          "965:   ASSERT(1 == uv_is_closing((uv_handle_t*) &process));",
          "",
          "---------------"
        ],
        "test/test-timer-again.c||test/test-timer-again.c": [
          "File: test/test-timer-again.c -> test/test-timer-again.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "78:   repeat_2_cb_called++;",
          "80:   if (uv_timer_get_repeat(&repeat_2) == 0) {",
          "82:     uv_close((uv_handle_t*)handle, close_cb);",
          "83:     return;",
          "84:   }",
          "",
          "[Removed Lines]",
          "81:     ASSERT(!uv_is_active((uv_handle_t*)handle));",
          "",
          "[Added Lines]",
          "81:     ASSERT(0 == uv_is_active((uv_handle_t*) handle));",
          "",
          "---------------"
        ],
        "test/test-timer.c||test/test-timer.c": [
          "File: test/test-timer.c -> test/test-timer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "38:   printf(\"ONCE_CLOSE_CB\\n\");",
          "40:   ASSERT(handle != NULL);",
          "43:   once_close_cb_called++;",
          "44: }",
          "",
          "[Removed Lines]",
          "41:   ASSERT(!uv_is_active(handle));",
          "",
          "[Added Lines]",
          "41:   ASSERT(0 == uv_is_active(handle));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "50:   ASSERT(handle != NULL);",
          "51:   ASSERT(status == 0);",
          "54:   once_cb_called++;",
          "",
          "[Removed Lines]",
          "52:   ASSERT(!uv_is_active((uv_handle_t*)handle));",
          "",
          "[Added Lines]",
          "52:   ASSERT(0 == uv_is_active((uv_handle_t*) handle));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "75:   ASSERT(handle != NULL);",
          "76:   ASSERT(status == 0);",
          "79:   repeat_cb_called++;",
          "",
          "[Removed Lines]",
          "77:   ASSERT(uv_is_active((uv_handle_t*)handle));",
          "",
          "[Added Lines]",
          "77:   ASSERT(1 == uv_is_active((uv_handle_t*) handle));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "164:   ASSERT(0 == uv_timer_init(uv_default_loop(), &handle));",
          "165:   ASSERT(0 == uv_timer_get_repeat(&handle));",
          "168:   MAKE_VALGRIND_HAPPY();",
          "169:   return 0;",
          "",
          "[Removed Lines]",
          "166:   ASSERT(!uv_is_active((uv_handle_t*)&handle));",
          "",
          "[Added Lines]",
          "166:   ASSERT(0 == uv_is_active((uv_handle_t*) &handle));",
          "",
          "---------------"
        ],
        "test/test-udp-send-and-recv.c||test/test-udp-send-and-recv.c": [
          "File: test/test-udp-send-and-recv.c -> test/test-udp-send-and-recv.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "55: static void close_cb(uv_handle_t* handle) {",
          "56:   CHECK_HANDLE(handle);",
          "58:   close_cb_called++;",
          "59: }",
          "",
          "[Removed Lines]",
          "57:   ASSERT(uv_is_closing(handle));",
          "",
          "[Added Lines]",
          "57:   ASSERT(1 == uv_is_closing(handle));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4a8ec0c62295394ac4f4cd0959ed458b3632d392",
      "candidate_info": {
        "commit_hash": "4a8ec0c62295394ac4f4cd0959ed458b3632d392",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/4a8ec0c62295394ac4f4cd0959ed458b3632d392",
        "files": [
          "src/unix/sunos.c"
        ],
        "message": "sunos: handle disabled watcher after callback\n\nFix a potential use-after-free bug where the uv__io watcher struct is\nreferenced after being disabled by its callback function. The stress\nis on 'potential' because in practice the watcher's memory is not\nreleased until the next tick of the event loop.",
        "before_after_code_files": [
          "src/unix/sunos.c||src/unix/sunos.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/unix/sunos.c||src/unix/sunos.c": [
          "File: src/unix/sunos.c -> src/unix/sunos.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "189:       w->cb(loop, w, pe->portev_events);",
          "190:       nevents++;",
          "193:       if (w->pevents != 0 && QUEUE_EMPTY(&w->watcher_queue))",
          "194:         QUEUE_INSERT_TAIL(&loop->watcher_queue, &w->watcher_queue);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "192:       if (w != loop->watchers[fd])",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "817c09257d5b842a9efedac72e6ebd9aa313f109",
      "candidate_info": {
        "commit_hash": "817c09257d5b842a9efedac72e6ebd9aa313f109",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/817c09257d5b842a9efedac72e6ebd9aa313f109",
        "files": [
          "Makefile.am",
          "src/unix/udp.c",
          "test/test-list.h",
          "test/test-udp-send-immediate.c",
          "uv.gyp"
        ],
        "message": "unix: remove incorrect assert\n\nAfter 41891222bc landed it's possible that uv__udp_sendmsg is called\neven if there are no pending write nor write completed requests:\n\n1. User calls uv_udp_send and the request is sent immediately. The\n   request is the added to the completed queue and we 'feed' the uv__io\n   handle so that we process the completed request in the next\n   iteration.\n2. User calls uv_udp_send again but the request is not completed\n   immediately, so it's queued in the write_queue.\n3. The uv__io handle gets a UV__POLLOUT event and uv__udp_sendmsg is\n   run, which completes the send request and puts it in the\n   write_completed_queue. Afterwards, uv__udp_run_completed is executed\n   and the write_completed queue is drained.\n4. At this point, the uv__io handle was made pending in step 3, in\n   uv__udp_sendmsg, but we no longer have requests to write or to complete,\n   so we skip processing.",
        "before_after_code_files": [
          "Makefile.am||Makefile.am",
          "src/unix/udp.c||src/unix/udp.c",
          "test/test-list.h||test/test-list.h",
          "test/test-udp-send-immediate.c||test/test-udp-send-immediate.c",
          "uv.gyp||uv.gyp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Makefile.am||Makefile.am": [
          "File: Makefile.am -> Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "214:                          test/test-udp-open.c \\",
          "215:                          test/test-udp-options.c \\",
          "216:                          test/test-udp-send-and-recv.c \\",
          "217:                          test/test-udp-try-send.c \\",
          "218:                          test/test-walk-handles.c \\",
          "219:                          test/test-watcher-cross-stop.c",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "217:                          test/test-udp-send-immediate.c \\",
          "",
          "---------------"
        ],
        "src/unix/udp.c||src/unix/udp.c": [
          "File: src/unix/udp.c -> src/unix/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "210:   struct msghdr h;",
          "211:   ssize_t size;",
          "216:   while (!QUEUE_EMPTY(&handle->write_queue)) {",
          "217:     q = QUEUE_HEAD(&handle->write_queue);",
          "218:     assert(q != NULL);",
          "",
          "[Removed Lines]",
          "213:   assert(!QUEUE_EMPTY(&handle->write_queue)",
          "214:       || !QUEUE_EMPTY(&handle->write_completed_queue));",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/test-list.h||test/test-list.h": [
          "File: test/test-list.h -> test/test-list.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "84: TEST_DECLARE   (udp_bind)",
          "85: TEST_DECLARE   (udp_bind_reuseaddr)",
          "86: TEST_DECLARE   (udp_send_and_recv)",
          "87: TEST_DECLARE   (udp_multicast_join)",
          "88: TEST_DECLARE   (udp_multicast_join6)",
          "89: TEST_DECLARE   (udp_multicast_ttl)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "87: TEST_DECLARE   (udp_send_immediate)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "367:   TEST_ENTRY  (udp_bind)",
          "368:   TEST_ENTRY  (udp_bind_reuseaddr)",
          "369:   TEST_ENTRY  (udp_send_and_recv)",
          "370:   TEST_ENTRY  (udp_dgram_too_big)",
          "371:   TEST_ENTRY  (udp_dual_stack)",
          "372:   TEST_ENTRY  (udp_ipv6_only)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "371:   TEST_ENTRY  (udp_send_immediate)",
          "",
          "---------------"
        ],
        "test/test-udp-send-immediate.c||test/test-udp-send-immediate.c": [
          "File: test/test-udp-send-immediate.c -> test/test-udp-send-immediate.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #include \"uv.h\"",
          "23: #include \"task.h\"",
          "25: #include <stdio.h>",
          "26: #include <stdlib.h>",
          "27: #include <string.h>",
          "29: #define CHECK_HANDLE(handle) \\",
          "30:   ASSERT((uv_udp_t*)(handle) == &server || (uv_udp_t*)(handle) == &client)",
          "32: static uv_udp_t server;",
          "33: static uv_udp_t client;",
          "35: static int cl_send_cb_called;",
          "36: static int sv_recv_cb_called;",
          "37: static int close_cb_called;",
          "40: static void alloc_cb(uv_handle_t* handle,",
          "41:                      size_t suggested_size,",
          "42:                      uv_buf_t* buf) {",
          "43:   static char slab[65536];",
          "44:   CHECK_HANDLE(handle);",
          "45:   ASSERT(suggested_size <= sizeof(slab));",
          "46:   buf->base = slab;",
          "47:   buf->len = sizeof(slab);",
          "48: }",
          "51: static void close_cb(uv_handle_t* handle) {",
          "52:   CHECK_HANDLE(handle);",
          "53:   ASSERT(1 == uv_is_closing(handle));",
          "54:   close_cb_called++;",
          "55: }",
          "58: static void cl_send_cb(uv_udp_send_t* req, int status) {",
          "59:   ASSERT(req != NULL);",
          "60:   ASSERT(status == 0);",
          "61:   CHECK_HANDLE(req->handle);",
          "63:   cl_send_cb_called++;",
          "64: }",
          "67: static void sv_recv_cb(uv_udp_t* handle,",
          "68:                        ssize_t nread,",
          "69:                        const uv_buf_t* rcvbuf,",
          "70:                        const struct sockaddr* addr,",
          "71:                        unsigned flags) {",
          "72:   if (nread < 0) {",
          "73:     ASSERT(0 && \"unexpected error\");",
          "74:   }",
          "76:   if (nread == 0) {",
          "79:     ASSERT(addr == NULL);",
          "80:     return;",
          "81:   }",
          "83:   CHECK_HANDLE(handle);",
          "84:   ASSERT(flags == 0);",
          "86:   ASSERT(addr != NULL);",
          "87:   ASSERT(nread == 4);",
          "88:   ASSERT(memcmp(\"PING\", rcvbuf->base, nread) == 0 ||",
          "89:          memcmp(\"PANG\", rcvbuf->base, nread) == 0);",
          "91:   if (++sv_recv_cb_called == 2) {",
          "92:     uv_close((uv_handle_t*) &server, close_cb);",
          "93:     uv_close((uv_handle_t*) &client, close_cb);",
          "94:   }",
          "95: }",
          "98: TEST_IMPL(udp_send_immediate) {",
          "99:   struct sockaddr_in addr;",
          "100:   uv_udp_send_t req1, req2;",
          "101:   uv_buf_t buf;",
          "102:   int r;",
          "104:   ASSERT(0 == uv_ip4_addr(\"0.0.0.0\", TEST_PORT, &addr));",
          "106:   r = uv_udp_init(uv_default_loop(), &server);",
          "107:   ASSERT(r == 0);",
          "109:   r = uv_udp_bind(&server, (const struct sockaddr*) &addr, 0);",
          "110:   ASSERT(r == 0);",
          "112:   r = uv_udp_recv_start(&server, alloc_cb, sv_recv_cb);",
          "113:   ASSERT(r == 0);",
          "115:   ASSERT(0 == uv_ip4_addr(\"127.0.0.1\", TEST_PORT, &addr));",
          "117:   r = uv_udp_init(uv_default_loop(), &client);",
          "118:   ASSERT(r == 0);",
          "121:   buf = uv_buf_init(\"PING\", 4);",
          "123:   r = uv_udp_send(&req1,",
          "124:                   &client,",
          "125:                   &buf,",
          "126:                   1,",
          "127:                   (const struct sockaddr*) &addr,",
          "128:                   cl_send_cb);",
          "129:   ASSERT(r == 0);",
          "131:   buf = uv_buf_init(\"PANG\", 4);",
          "133:   r = uv_udp_send(&req2,",
          "134:                   &client,",
          "135:                   &buf,",
          "136:                   1,",
          "137:                   (const struct sockaddr*) &addr,",
          "138:                   cl_send_cb);",
          "140:   uv_run(uv_default_loop(), UV_RUN_DEFAULT);",
          "142:   ASSERT(cl_send_cb_called == 2);",
          "143:   ASSERT(sv_recv_cb_called == 2);",
          "144:   ASSERT(close_cb_called == 2);",
          "146:   MAKE_VALGRIND_HAPPY();",
          "147:   return 0;",
          "148: }",
          "",
          "---------------"
        ],
        "uv.gyp||uv.gyp": [
          "File: uv.gyp -> uv.gyp",
          "--- Hunk 1 ---",
          "[Context before]",
          "394:         'test/test-udp-open.c',",
          "395:         'test/test-udp-options.c',",
          "396:         'test/test-udp-send-and-recv.c',",
          "397:         'test/test-udp-multicast-join.c',",
          "398:         'test/test-udp-multicast-join6.c',",
          "399:         'test/test-dlerror.c',",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "397:         'test/test-udp-send-immediate.c',",
          "",
          "---------------"
        ]
      }
    }
  ]
}
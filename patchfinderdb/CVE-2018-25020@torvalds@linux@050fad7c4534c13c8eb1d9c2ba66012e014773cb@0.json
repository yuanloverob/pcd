{
  "cve_id": "CVE-2018-25020",
  "cve_desc": "The BPF subsystem in the Linux kernel before 4.17 mishandles situations with a long jump over an instruction sequence where inner instructions require substantial expansions into multiple BPF instructions, leading to an overflow. This affects kernel/bpf/core.c and net/core/filter.c.",
  "repo": "torvalds/linux",
  "patch_hash": "050fad7c4534c13c8eb1d9c2ba66012e014773cb",
  "patch_info": {
    "commit_hash": "050fad7c4534c13c8eb1d9c2ba66012e014773cb",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/050fad7c4534c13c8eb1d9c2ba66012e014773cb",
    "files": [
      "kernel/bpf/core.c",
      "net/core/filter.c"
    ],
    "message": "bpf: fix truncated jump targets on heavy expansions\n\nRecently during testing, I ran into the following panic:\n\n  [  207.892422] Internal error: Accessing user space memory outside uaccess.h routines: 96000004 [#1] SMP\n  [  207.901637] Modules linked in: binfmt_misc [...]\n  [  207.966530] CPU: 45 PID: 2256 Comm: test_verifier Tainted: G        W         4.17.0-rc3+ #7\n  [  207.974956] Hardware name: FOXCONN R2-1221R-A4/C2U4N_MB, BIOS G31FB18A 03/31/2017\n  [  207.982428] pstate: 60400005 (nZCv daif +PAN -UAO)\n  [  207.987214] pc : bpf_skb_load_helper_8_no_cache+0x34/0xc0\n  [  207.992603] lr : 0xffff000000bdb754\n  [  207.996080] sp : ffff000013703ca0\n  [  207.999384] x29: ffff000013703ca0 x28: 0000000000000001\n  [  208.004688] x27: 0000000000000001 x26: 0000000000000000\n  [  208.009992] x25: ffff000013703ce0 x24: ffff800fb4afcb00\n  [  208.015295] x23: ffff00007d2f5038 x22: ffff00007d2f5000\n  [  208.020599] x21: fffffffffeff2a6f x20: 000000000000000a\n  [  208.025903] x19: ffff000009578000 x18: 0000000000000a03\n  [  208.031206] x17: 0000000000000000 x16: 0000000000000000\n  [  208.036510] x15: 0000ffff9de83000 x14: 0000000000000000\n  [  208.041813] x13: 0000000000000000 x12: 0000000000000000\n  [  208.047116] x11: 0000000000000001 x10: ffff0000089e7f18\n  [  208.052419] x9 : fffffffffeff2a6f x8 : 0000000000000000\n  [  208.057723] x7 : 000000000000000a x6 : 00280c6160000000\n  [  208.063026] x5 : 0000000000000018 x4 : 0000000000007db6\n  [  208.068329] x3 : 000000000008647a x2 : 19868179b1484500\n  [  208.073632] x1 : 0000000000000000 x0 : ffff000009578c08\n  [  208.078938] Process test_verifier (pid: 2256, stack limit = 0x0000000049ca7974)\n  [  208.086235] Call trace:\n  [  208.088672]  bpf_skb_load_helper_8_no_cache+0x34/0xc0\n  [  208.093713]  0xffff000000bdb754\n  [  208.096845]  bpf_test_run+0x78/0xf8\n  [  208.100324]  bpf_prog_test_run_skb+0x148/0x230\n  [  208.104758]  sys_bpf+0x314/0x1198\n  [  208.108064]  el0_svc_naked+0x30/0x34\n  [  208.111632] Code: 91302260 f9400001 f9001fa1 d2800001 (29500680)\n  [  208.117717] ---[ end trace 263cb8a59b5bf29f ]---\n\nThe program itself which caused this had a long jump over the whole\ninstruction sequence where all of the inner instructions required\nheavy expansions into multiple BPF instructions. Additionally, I also\nhad BPF hardening enabled which requires once more rewrites of all\nconstant values in order to blind them. Each time we rewrite insns,\nbpf_adj_branches() would need to potentially adjust branch targets\nwhich cross the patchlet boundary to accommodate for the additional\ndelta. Eventually that lead to the case where the target offset could\nnot fit into insn->off's upper 0x7fff limit anymore where then offset\nwraps around becoming negative (in s16 universe), or vice versa\ndepending on the jump direction.\n\nTherefore it becomes necessary to detect and reject any such occasions\nin a generic way for native eBPF and cBPF to eBPF migrations. For\nthe latter we can simply check bounds in the bpf_convert_filter()'s\nBPF_EMIT_JMP helper macro and bail out once we surpass limits. The\nbpf_patch_insn_single() for native eBPF (and cBPF to eBPF in case\nof subsequent hardening) is a bit more complex in that we need to\ndetect such truncations before hitting the bpf_prog_realloc(). Thus\nthe latter is split into an extra pass to probe problematic offsets\non the original program in order to fail early. With that in place\nand carefully tested I no longer hit the panic and the rewrites are\nrejected properly. The above example panic I've seen on bpf-next,\nthough the issue itself is generic in that a guard against this issue\nin bpf seems more appropriate in this case.\n\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Martin KaFai Lau <kafai@fb.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
    "before_after_code_files": [
      "kernel/bpf/core.c||kernel/bpf/core.c",
      "net/core/filter.c||net/core/filter.c"
    ]
  },
  "patch_diff": {
    "kernel/bpf/core.c||kernel/bpf/core.c": [
      "File: kernel/bpf/core.c -> kernel/bpf/core.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "218:  return 0;",
      "219: }",
      "222: {",
      "223:  struct bpf_insn *insn = prog->insnsi;",
      "229:  for (i = 0; i < insn_cnt; i++, insn++) {",
      "230:   code = insn->code;",
      "234:    continue;",
      "235:   if (BPF_OP(code) == BPF_CALL) {",
      "239:     continue;",
      "240:   } else {",
      "242:   }",
      "255:  }",
      "256: }",
      "258: struct bpf_prog *bpf_patch_insn_single(struct bpf_prog *prog, u32 off,",
      "259:            const struct bpf_insn *patch, u32 len)",
      "260: {",
      "261:  u32 insn_adj_cnt, insn_rest, insn_delta = len - 1;",
      "262:  struct bpf_prog *prog_adj;",
      "",
      "[Removed Lines]",
      "221: static void bpf_adj_branches(struct bpf_prog *prog, u32 pos, u32 delta)",
      "224:  u32 i, insn_cnt = prog->len;",
      "225:  bool pseudo_call;",
      "226:  u8 code;",
      "227:  int off;",
      "231:   if (BPF_CLASS(code) != BPF_JMP)",
      "232:    continue;",
      "233:   if (BPF_OP(code) == BPF_EXIT)",
      "236:    if (insn->src_reg == BPF_PSEUDO_CALL)",
      "237:     pseudo_call = true;",
      "238:    else",
      "241:    pseudo_call = false;",
      "243:   off = pseudo_call ? insn->imm : insn->off;",
      "246:   if (i < pos && i + off + 1 > pos)",
      "247:    off += delta;",
      "248:   else if (i > pos + delta && i + off + 1 <= pos + delta)",
      "249:    off -= delta;",
      "251:   if (pseudo_call)",
      "252:    insn->imm = off;",
      "253:   else",
      "254:    insn->off = off;",
      "",
      "[Added Lines]",
      "221: static int bpf_adj_delta_to_imm(struct bpf_insn *insn, u32 pos, u32 delta,",
      "222:     u32 curr, const bool probe_pass)",
      "224:  const s64 imm_min = S32_MIN, imm_max = S32_MAX;",
      "225:  s64 imm = insn->imm;",
      "227:  if (curr < pos && curr + imm + 1 > pos)",
      "228:   imm += delta;",
      "229:  else if (curr > pos + delta && curr + imm + 1 <= pos + delta)",
      "230:   imm -= delta;",
      "231:  if (imm < imm_min || imm > imm_max)",
      "232:   return -ERANGE;",
      "233:  if (!probe_pass)",
      "234:   insn->imm = imm;",
      "235:  return 0;",
      "236: }",
      "238: static int bpf_adj_delta_to_off(struct bpf_insn *insn, u32 pos, u32 delta,",
      "239:     u32 curr, const bool probe_pass)",
      "240: {",
      "241:  const s32 off_min = S16_MIN, off_max = S16_MAX;",
      "242:  s32 off = insn->off;",
      "244:  if (curr < pos && curr + off + 1 > pos)",
      "245:   off += delta;",
      "246:  else if (curr > pos + delta && curr + off + 1 <= pos + delta)",
      "247:   off -= delta;",
      "248:  if (off < off_min || off > off_max)",
      "249:   return -ERANGE;",
      "250:  if (!probe_pass)",
      "251:   insn->off = off;",
      "252:  return 0;",
      "253: }",
      "255: static int bpf_adj_branches(struct bpf_prog *prog, u32 pos, u32 delta,",
      "256:        const bool probe_pass)",
      "257: {",
      "258:  u32 i, insn_cnt = prog->len + (probe_pass ? delta : 0);",
      "260:  int ret = 0;",
      "263:   u8 code;",
      "269:   if (probe_pass && i == pos) {",
      "270:    i += delta + 1;",
      "271:    insn++;",
      "272:   }",
      "274:   if (BPF_CLASS(code) != BPF_JMP ||",
      "275:       BPF_OP(code) == BPF_EXIT)",
      "279:    if (insn->src_reg != BPF_PSEUDO_CALL)",
      "281:    ret = bpf_adj_delta_to_imm(insn, pos, delta, i,",
      "282:          probe_pass);",
      "284:    ret = bpf_adj_delta_to_off(insn, pos, delta, i,",
      "285:          probe_pass);",
      "287:   if (ret)",
      "288:    break;",
      "291:  return ret;",
      "298:  const u32 cnt_max = S16_MAX;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "270:  insn_adj_cnt = prog->len + insn_delta;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "314:  if (insn_adj_cnt > cnt_max &&",
      "315:      bpf_adj_branches(prog, off, insn_delta, true))",
      "316:   return NULL;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "294:   sizeof(*patch) * insn_rest);",
      "295:  memcpy(prog_adj->insnsi + off, patch, sizeof(*patch) * len);",
      "299:  return prog_adj;",
      "300: }",
      "",
      "[Removed Lines]",
      "297:  bpf_adj_branches(prog_adj, off, insn_delta);",
      "",
      "[Added Lines]",
      "347:  BUG_ON(bpf_adj_branches(prog_adj, off, insn_delta, false));",
      "",
      "---------------"
    ],
    "net/core/filter.c||net/core/filter.c": [
      "File: net/core/filter.c -> net/core/filter.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "482: #define BPF_EMIT_JMP       \\",
      "483:  do {        \\",
      "484:   if (target >= len || target < 0)   \\",
      "485:    goto err;     \\",
      "489:  } while (0)",
      "491:   case BPF_JMP | BPF_JA:",
      "",
      "[Removed Lines]",
      "486:   insn->off = addrs ? addrs[target] - addrs[i] - 1 : 0; \\",
      "488:   insn->off -= insn - tmp_insns;    \\",
      "",
      "[Added Lines]",
      "484:   const s32 off_min = S16_MIN, off_max = S16_MAX;  \\",
      "485:   s32 off;      \\",
      "486:          \\",
      "489:   off = addrs ? addrs[target] - addrs[i] - 1 : 0;  \\",
      "491:   off -= insn - tmp_insns;    \\",
      "493:   if (off < off_min || off > off_max)   \\",
      "494:    goto err;     \\",
      "495:   insn->off = off;     \\",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "44a63b137f7b6e4c7bd6c9cc21615941cb36509d",
      "candidate_info": {
        "commit_hash": "44a63b137f7b6e4c7bd6c9cc21615941cb36509d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/44a63b137f7b6e4c7bd6c9cc21615941cb36509d",
        "files": [
          "net/sched/sch_red.c",
          "net/sched/sch_tbf.c"
        ],
        "message": "net: sched: red: avoid hashing NULL child\n\nHangbin reported an Oops triggered by the syzkaller qdisc rules:\n\n kasan: GPF could be caused by NULL-ptr deref or user memory access\n general protection fault: 0000 [#1] SMP KASAN PTI\n Modules linked in: sch_red\n CPU: 0 PID: 28699 Comm: syz-executor5 Not tainted 4.17.0-rc4.kcov #1\n Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011\n RIP: 0010:qdisc_hash_add+0x26/0xa0\n RSP: 0018:ffff8800589cf470 EFLAGS: 00010203\n RAX: dffffc0000000000 RBX: 0000000000000000 RCX: ffffffff824ad971\n RDX: 0000000000000007 RSI: ffffc9000ce9f000 RDI: 000000000000003c\n RBP: 0000000000000001 R08: ffffed000b139ea2 R09: ffff8800589cf4f0\n R10: ffff8800589cf50f R11: ffffed000b139ea2 R12: ffff880054019fc0\n R13: ffff880054019fb4 R14: ffff88005c0af600 R15: ffff880054019fb0\n FS:  00007fa6edcb1700(0000) GS:ffff88005ce00000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000000020000740 CR3: 000000000fc16000 CR4: 00000000000006f0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n Call Trace:\n  red_change+0x2d2/0xed0 [sch_red]\n  qdisc_create+0x57e/0xef0\n  tc_modify_qdisc+0x47f/0x14e0\n  rtnetlink_rcv_msg+0x6a8/0x920\n  netlink_rcv_skb+0x2a2/0x3c0\n  netlink_unicast+0x511/0x740\n  netlink_sendmsg+0x825/0xc30\n  sock_sendmsg+0xc5/0x100\n  ___sys_sendmsg+0x778/0x8e0\n  __sys_sendmsg+0xf5/0x1b0\n  do_syscall_64+0xbd/0x3b0\n  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n RIP: 0033:0x450869\n RSP: 002b:00007fa6edcb0c48 EFLAGS: 00000246 ORIG_RAX: 000000000000002e\n RAX: ffffffffffffffda RBX: 00007fa6edcb16b4 RCX: 0000000000450869\n RDX: 0000000000000000 RSI: 00000000200000c0 RDI: 0000000000000013\n RBP: 000000000072bea0 R08: 0000000000000000 R09: 0000000000000000\n R10: 0000000000000000 R11: 0000000000000246 R12: 00000000ffffffff\n R13: 0000000000008778 R14: 0000000000702838 R15: 00007fa6edcb1700\n Code: e9 0b fe ff ff 0f 1f 44 00 00 55 53 48 89 fb 89 f5 e8 3f 07 f3 fe 48 8d 7b 3c 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 <0f> b6 14 02 48 89 f8 83 e0 07 83 c0 03 38 d0 7c 04 84 d2 75 51\n RIP: qdisc_hash_add+0x26/0xa0 RSP: ffff8800589cf470\n\nWhen a red qdisc is updated with a 0 limit, the child qdisc is left\nunmodified, no additional scheduler is created in red_change(),\nthe 'child' local variable is rightfully NULL and must not add it\nto the hash table.\n\nThis change addresses the above issue moving qdisc_hash_add() right\nafter the child qdisc creation. It additionally removes unneeded checks\nfor noop_qdisc.\n\nReported-by: Hangbin Liu <liuhangbin@gmail.com>\nFixes: 49b499718fa1 (\"net: sched: make default fifo qdiscs appear in the dump\")\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>\nAcked-by: Jiri Kosina <jkosina@suse.cz>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/sched/sch_red.c||net/sched/sch_red.c",
          "net/sched/sch_tbf.c||net/sched/sch_tbf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/sched/sch_red.c||net/sched/sch_red.c": [
          "File: net/sched/sch_red.c -> net/sched/sch_red.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "222:       extack);",
          "223:   if (IS_ERR(child))",
          "224:    return PTR_ERR(child);",
          "228:   qdisc_hash_add(child, true);",
          "229:  sch_tree_lock(sch);",
          "230:  q->flags = ctl->flags;",
          "231:  q->limit = ctl->limit;",
          "",
          "[Removed Lines]",
          "225:  }",
          "227:  if (child != &noop_qdisc)",
          "",
          "[Added Lines]",
          "228:  }",
          "",
          "---------------"
        ],
        "net/sched/sch_tbf.c||net/sched/sch_tbf.c": [
          "File: net/sched/sch_tbf.c -> net/sched/sch_tbf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "383:    err = PTR_ERR(child);",
          "384:    goto done;",
          "385:   }",
          "386:  }",
          "388:  sch_tree_lock(sch);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "388:   qdisc_hash_add(child, true);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "391:        q->qdisc->qstats.backlog);",
          "392:   qdisc_destroy(q->qdisc);",
          "393:   q->qdisc = child;",
          "396:  }",
          "397:  q->limit = qopt->limit;",
          "398:  if (tb[TCA_TBF_PBURST])",
          "",
          "[Removed Lines]",
          "394:   if (child != &noop_qdisc)",
          "395:    qdisc_hash_add(child, true);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e578a570dc7c20475774d1ff993825e3bd7a7011",
      "candidate_info": {
        "commit_hash": "e578a570dc7c20475774d1ff993825e3bd7a7011",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e578a570dc7c20475774d1ff993825e3bd7a7011",
        "files": [
          "drivers/gpu/drm/i915/intel_lvds.c"
        ],
        "message": "drm/i915/lvds: Move acpi lid notification registration to registration phase\n\nDelay registering ourselves with the acpi lid notification mechanism\nuntil we are registering the connectors after initialisation is\ncomplete. This prevents a possibility of trying to handle the lid\nnotification before we are ready with the danger of chasing\nuninitialised function pointers.\n\n BUG: unable to handle kernel NULL pointer dereference at 0000000000000000\n IP:           (null)\n PGD 0 P4D 0\n Oops: 0010 [#1] PREEMPT SMP PTI\n Modules linked in: arc4(+) iwldvm(+) i915(+) mac80211 i2c_algo_bit coretemp mei_wdt iwlwifi drm_kms_helper kvm_intel wmi_bmof iTCO_wdt iTCO_vendor_support kvm snd_hda_codec_conexant snd_hda_codec_generic drm psmouse cfg80211 irqbypass input_leds pcspkr i2c_i801 snd_hda_intel snd_hda_codec thinkpad_acpi snd_hda_core mei_me lpc_ich snd_hwdep e1000e wmi nvram snd_pcm mei snd_timer shpchp ptp pps_core rfkill syscopyarea snd intel_agp sysfillrect intel_gtt soundcore sysimgblt battery led_class fb_sys_fops ac rtc_cmos agpgart evdev mac_hid acpi_cpufreq ip_tables x_tables ext4 crc32c_generic crc16 mbcache jbd2 fscrypto crypto_simd glue_helper cryptd aes_x86_64 xts algif_skcipher af_alg dm_crypt dm_mod sd_mod uas usb_storage serio_raw atkbd libps2 ahci libahci uhci_hcd libata scsi_mod ehci_pci\n  ehci_hcd usbcore usb_common i8042 serio\n CPU: 1 PID: 378 Comm: systemd-logind Not tainted 4.16.8-1-ARCH #1\n Hardware name: LENOVO 7454CTO/7454CTO, BIOS 6DET72WW (3.22 ) 10/25/2012\n RIP: 0010:          (null)\n RSP: 0018:ffffaf4580c33a18 EFLAGS: 00010287\n RAX: 0000000000000000 RBX: ffff947533558000 RCX: 000000000000003e\n RDX: ffffffffc0aa80c0 RSI: ffffaf4580c33a3c RDI: ffff947534e4c000\n RBP: ffff947533558338 R08: ffff947534598930 R09: ffffffffc0a928b1\n R10: ffffd8f181d5fd40 R11: 0000000000000000 R12: ffffffffc0a928b1\n R13: ffff947533558368 R14: ffffffffc0a928a9 R15: ffff947534e4c000\n FS:  00007f3dc4ddb940(0000) GS:ffff947539280000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000000000000000 CR3: 000000006e214000 CR4: 00000000000406e0\n Call Trace:\n  ?  intel_modeset_setup_hw_state+0x385/0xf60 [i915]\n  ? __intel_display_resume+0x1e/0xc0 [i915]\n  ? intel_display_resume+0xcc/0x120 [i915]\n  ? intel_lid_notify+0xbc/0xc0 [i915]\n  ? notifier_call_chain+0x47/0x70\n  ? blocking_notifier_call_chain+0x3e/0x60\n  ? acpi_lid_notify_state+0x8f/0x1d0\n  ? acpi_lid_update_state+0x49/0x70\n  ? acpi_lid_input_open+0x60/0x90\n  ? input_open_device+0x5d/0xa0\n  ? evdev_open+0x1ba/0x1e0 [evdev]\n  ? chrdev_open+0xa3/0x1b0\n  ? cdev_put.part.0+0x20/0x20\n  ? do_dentry_open+0x14c/0x300\n  ? path_openat+0x30c/0x1240\n  ? current_time+0x16/0x60\n  ? do_filp_open+0x93/0x100\n  ? __check_object_size+0xfb/0x180\n  ? do_sys_open+0x186/0x210\n  ? do_syscall_64+0x74/0x190\n  ?  entry_SYSCALL_64_after_hwframe+0x3d/0xa2\n Code:  Bad RIP value.\n RIP:           (null) RSP: ffffaf4580c33a18\n CR2: 0000000000000000\n\nBugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=106559\nFixes: c1c7af608920 (\"drm/i915: force mode set at lid open time\")\nSigned-off-by: Chris Wilson <chris@chris-wilson.co.uk>\nCc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>\nCc: Ville Syrj\u00e4l\u00e4 <ville.syrjala@linux.intel.com>\nCc: Daniel Vetter <daniel.vetter@ffwll.ch>\nReviewed-by: Jani Nikula <jani.nikula@intel.com>\nLink: https://patchwork.freedesktop.org/patch/msgid/20180518074840.16194-1-chris@chris-wilson.co.uk\nCc: stable@vger.kernel.org",
        "before_after_code_files": [
          "drivers/gpu/drm/i915/intel_lvds.c||drivers/gpu/drm/i915/intel_lvds.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpu/drm/i915/intel_lvds.c||drivers/gpu/drm/i915/intel_lvds.c": [
          "File: drivers/gpu/drm/i915/intel_lvds.c -> drivers/gpu/drm/i915/intel_lvds.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "572:  return NOTIFY_OK;",
          "573: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "575: static int",
          "576: intel_lvds_connector_register(struct drm_connector *connector)",
          "577: {",
          "578:  struct intel_lvds_connector *lvds = to_lvds_connector(connector);",
          "579:  int ret;",
          "581:  ret = intel_connector_register(connector);",
          "582:  if (ret)",
          "583:   return ret;",
          "585:  lvds->lid_notifier.notifier_call = intel_lid_notify;",
          "586:  if (acpi_lid_notifier_register(&lvds->lid_notifier)) {",
          "587:   DRM_DEBUG_KMS(\"lid notifier registration failed\\n\");",
          "588:   lvds->lid_notifier.notifier_call = NULL;",
          "589:  }",
          "591:  return 0;",
          "592: }",
          "594: static void",
          "595: intel_lvds_connector_unregister(struct drm_connector *connector)",
          "596: {",
          "597:  struct intel_lvds_connector *lvds = to_lvds_connector(connector);",
          "599:  if (lvds->lid_notifier.notifier_call)",
          "600:   acpi_lid_notifier_unregister(&lvds->lid_notifier);",
          "602:  intel_connector_unregister(connector);",
          "603: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "584:  struct intel_lvds_connector *lvds_connector =",
          "585:   to_lvds_connector(connector);",
          "590:  if (!IS_ERR_OR_NULL(lvds_connector->base.edid))",
          "591:   kfree(lvds_connector->base.edid);",
          "",
          "[Removed Lines]",
          "587:  if (lvds_connector->lid_notifier.notifier_call)",
          "588:   acpi_lid_notifier_unregister(&lvds_connector->lid_notifier);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "607:  .fill_modes = drm_helper_probe_single_connector_modes,",
          "608:  .atomic_get_property = intel_digital_connector_atomic_get_property,",
          "609:  .atomic_set_property = intel_digital_connector_atomic_set_property,",
          "612:  .destroy = intel_lvds_destroy,",
          "613:  .atomic_destroy_state = drm_atomic_helper_connector_destroy_state,",
          "614:  .atomic_duplicate_state = intel_digital_connector_duplicate_state,",
          "",
          "[Removed Lines]",
          "610:  .late_register = intel_connector_register,",
          "611:  .early_unregister = intel_connector_unregister,",
          "",
          "[Added Lines]",
          "637:  .late_register = intel_lvds_connector_register,",
          "638:  .early_unregister = intel_lvds_connector_unregister,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1161:  lvds_encoder->a3_power = lvds & LVDS_A3_POWER_MASK;",
          "1169:  return;",
          "1171: failed:",
          "",
          "[Removed Lines]",
          "1163:  lvds_connector->lid_notifier.notifier_call = intel_lid_notify;",
          "1164:  if (acpi_lid_notifier_register(&lvds_connector->lid_notifier)) {",
          "1165:   DRM_DEBUG_KMS(\"lid notifier registration failed\\n\");",
          "1166:   lvds_connector->lid_notifier.notifier_call = NULL;",
          "1167:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7c1bd80cc216e7255bfabb94222676b51ab6868e",
      "candidate_info": {
        "commit_hash": "7c1bd80cc216e7255bfabb94222676b51ab6868e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7c1bd80cc216e7255bfabb94222676b51ab6868e",
        "files": [
          "arch/powerpc/kvm/book3s_hv_builtin.c"
        ],
        "message": "KVM: PPC: Book3S HV: Send kvmppc_bad_interrupt NMIs to Linux handlers\n\nIt's possible to take a SRESET or MCE in these paths due to a bug\nin the host code or a NMI IPI, etc. A recent bug attempting to load\na virtual address from real mode gave th complete but cryptic error,\nabridged:\n\n      Oops: Bad interrupt in KVM entry/exit code, sig: 6 [#1]\n      LE SMP NR_CPUS=2048 NUMA PowerNV\n      CPU: 53 PID: 6582 Comm: qemu-system-ppc Not tainted\n      NIP:  c0000000000155ac LR: c0000000000c2430 CTR: c000000000015580\n      REGS: c000000fff76dd80 TRAP: 0200   Not tainted\n      MSR:  9000000000201003 <SF,HV,ME,RI,LE>  CR: 48082222  XER: 00000000\n      CFAR: 0000000102900ef0 DAR: d00017fffd941a28 DSISR: 00000040 SOFTE: 3\n      NIP [c0000000000155ac] perf_trace_tlbie+0x2c/0x1a0\n      LR [c0000000000c2430] do_tlbies+0x230/0x2f0\n\nSending the NMIs through the Linux handlers gives a nicer output:\n\n      Severe Machine check interrupt [Not recovered]\n        NIP [c0000000000155ac]: perf_trace_tlbie+0x2c/0x1a0\n        Initiator: CPU\n        Error type: Real address [Load (bad)]\n          Effective address: d00017fffcc01a28\n      opal: Machine check interrupt unrecoverable: MSR(RI=0)\n      opal: Hardware platform error: Unrecoverable Machine Check exception\n      CPU: 0 PID: 6700 Comm: qemu-system-ppc Tainted: G   M\n      NIP:  c0000000000155ac LR: c0000000000c23c0 CTR: c000000000015580\n      REGS: c000000fff9e9d80 TRAP: 0200   Tainted: G   M\n      MSR:  9000000000201001 <SF,HV,ME,LE>  CR: 48082222  XER: 00000000\n      CFAR: 000000010cbc1a30 DAR: d00017fffcc01a28 DSISR: 00000040 SOFTE: 3\n      NIP [c0000000000155ac] perf_trace_tlbie+0x2c/0x1a0\n      LR [c0000000000c23c0] do_tlbies+0x1c0/0x280\n\nSigned-off-by: Nicholas Piggin <npiggin@gmail.com>\nSigned-off-by: Paul Mackerras <paulus@ozlabs.org>",
        "before_after_code_files": [
          "arch/powerpc/kvm/book3s_hv_builtin.c||arch/powerpc/kvm/book3s_hv_builtin.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/powerpc/kvm/book3s_hv_builtin.c||arch/powerpc/kvm/book3s_hv_builtin.c": [
          "File: arch/powerpc/kvm/book3s_hv_builtin.c -> arch/powerpc/kvm/book3s_hv_builtin.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #include <linux/cma.h>",
          "19: #include <linux/bitops.h>",
          "21: #include <asm/cputable.h>",
          "22: #include <asm/kvm_ppc.h>",
          "23: #include <asm/kvm_book3s.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21: #include <asm/asm-prototypes.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "634: void kvmppc_bad_interrupt(struct pt_regs *regs)",
          "635: {",
          "637:  panic(\"Bad KVM trap\");",
          "638: }",
          "",
          "[Removed Lines]",
          "636:  die(\"Bad interrupt in KVM entry/exit code\", regs, SIGABRT);",
          "",
          "[Added Lines]",
          "641:  if (TRAP(regs) == 0x100) {",
          "642:   get_paca()->in_nmi++;",
          "643:   system_reset_exception(regs);",
          "644:   get_paca()->in_nmi--;",
          "645:  } else if (TRAP(regs) == 0x200) {",
          "646:   machine_check_exception(regs);",
          "647:  } else {",
          "648:   die(\"Bad interrupt in KVM entry/exit code\", regs, SIGABRT);",
          "649:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fd8f58c40b703e47697c9f12bc16c31f14c161f1",
      "candidate_info": {
        "commit_hash": "fd8f58c40b703e47697c9f12bc16c31f14c161f1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/fd8f58c40b703e47697c9f12bc16c31f14c161f1",
        "files": [
          "tools/testing/radix-tree/multiorder.c",
          "tools/testing/radix-tree/test.h"
        ],
        "message": "radix tree test suite: multi-order iteration race\n\nAdd a test which shows a race in the multi-order iteration code.  This\ntest reliably hits the race in under a second on my machine, and is the\nresult of a real bug report against kernel a production v4.15 based\nkernel (4.15.6-300.fc27.x86_64).  With a real kernel this issue is hit\nwhen using order 9 PMD DAX radix tree entries.\n\nThe race has to do with how we tear down multi-order sibling entries\nwhen we are removing an item from the tree.  Remember that an order 2\nentry looks like this:\n\n  struct radix_tree_node.slots[] = [entry][sibling][sibling][sibling]\n\nwhere 'entry' is in some slot in the struct radix_tree_node, and the\nthree slots following 'entry' contain sibling pointers which point back\nto 'entry.'\n\nWhen we delete 'entry' from the tree, we call :\n\n  radix_tree_delete()\n    radix_tree_delete_item()\n      __radix_tree_delete()\n        replace_slot()\n\nreplace_slot() first removes the siblings in order from the first to the\nlast, then at then replaces 'entry' with NULL.  This means that for a\nbrief period of time we end up with one or more of the siblings removed,\nso:\n\n  struct radix_tree_node.slots[] = [entry][NULL][sibling][sibling]\n\nThis causes an issue if you have a reader iterating over the slots in\nthe tree via radix_tree_for_each_slot() while only under\nrcu_read_lock()/rcu_read_unlock() protection.  This is a common case in\nmm/filemap.c.\n\nThe issue is that when __radix_tree_next_slot() => skip_siblings() tries\nto skip over the sibling entries in the slots, it currently does so with\nan exact match on the slot directly preceding our current slot.\nNormally this works:\n\n                                      V preceding slot\n  struct radix_tree_node.slots[] = [entry][sibling][sibling][sibling]\n                                              ^ current slot\n\nThis lets you find the first sibling, and you skip them all in order.\n\nBut in the case where one of the siblings is NULL, that slot is skipped\nand then our sibling detection is interrupted:\n\n                                             V preceding slot\n  struct radix_tree_node.slots[] = [entry][NULL][sibling][sibling]\n                                                    ^ current slot\n\nThis means that the sibling pointers aren't recognized since they point\nall the way back to 'entry', so we think that they are normal internal\nradix tree pointers.  This causes us to think we need to walk down to a\nstruct radix_tree_node starting at the address of 'entry'.\n\nIn a real running kernel this will crash the thread with a GP fault when\nyou try and dereference the slots in your broken node starting at\n'entry'.\n\nIn the radix tree test suite this will be caught by the address\nsanitizer:\n\n  ==27063==ERROR: AddressSanitizer: heap-buffer-overflow on address\n  0x60c0008ae400 at pc 0x00000040ce4f bp 0x7fa89b8fcad0 sp 0x7fa89b8fcac0\n  READ of size 8 at 0x60c0008ae400 thread T3\n      #0 0x40ce4e in __radix_tree_next_slot /home/rzwisler/project/linux/tools/testing/radix-tree/radix-tree.c:1660\n      #1 0x4022cc in radix_tree_next_slot linux/../../../../include/linux/radix-tree.h:567\n      #2 0x4022cc in iterator_func /home/rzwisler/project/linux/tools/testing/radix-tree/multiorder.c:655\n      #3 0x7fa8a088d50a in start_thread (/lib64/libpthread.so.0+0x750a)\n      #4 0x7fa8a03bd16e in clone (/lib64/libc.so.6+0xf516e)\n\nLink: http://lkml.kernel.org/r/20180503192430.7582-5-ross.zwisler@linux.intel.com\nSigned-off-by: Ross Zwisler <ross.zwisler@linux.intel.com>\nCc: Christoph Hellwig <hch@lst.de>\nCc: CR, Sapthagirish <sapthagirish.cr@intel.com>\nCc: Dan Williams <dan.j.williams@intel.com>\nCc: Dave Chinner <david@fromorbit.com>\nCc: Jan Kara <jack@suse.cz>\nCc: Matthew Wilcox <willy@infradead.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "tools/testing/radix-tree/multiorder.c||tools/testing/radix-tree/multiorder.c",
          "tools/testing/radix-tree/test.h||tools/testing/radix-tree/test.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tools/testing/radix-tree/multiorder.c||tools/testing/radix-tree/multiorder.c": [
          "File: tools/testing/radix-tree/multiorder.c -> tools/testing/radix-tree/multiorder.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: #include <linux/radix-tree.h>",
          "17: #include <linux/slab.h>",
          "18: #include <linux/errno.h>",
          "20: #include \"test.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: #include <pthread.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "624:  item_kill_tree(&tree);",
          "625: }",
          "627: void multiorder_checks(void)",
          "628: {",
          "629:  int i;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "628: bool stop_iteration = false;",
          "630: static void *creator_func(void *ptr)",
          "631: {",
          "633:  unsigned int order = RADIX_TREE_MAP_SHIFT - 1;",
          "634:  struct radix_tree_root *tree = ptr;",
          "635:  int i;",
          "637:  for (i = 0; i < 10000; i++) {",
          "638:   item_insert_order(tree, 0, order);",
          "639:   item_delete_rcu(tree, 0);",
          "640:  }",
          "642:  stop_iteration = true;",
          "643:  return NULL;",
          "644: }",
          "646: static void *iterator_func(void *ptr)",
          "647: {",
          "648:  struct radix_tree_root *tree = ptr;",
          "649:  struct radix_tree_iter iter;",
          "650:  struct item *item;",
          "651:  void **slot;",
          "653:  while (!stop_iteration) {",
          "654:   rcu_read_lock();",
          "655:   radix_tree_for_each_slot(slot, tree, &iter, 0) {",
          "656:    item = radix_tree_deref_slot(slot);",
          "658:    if (!item)",
          "659:     continue;",
          "660:    if (radix_tree_deref_retry(item)) {",
          "661:     slot = radix_tree_iter_retry(&iter);",
          "662:     continue;",
          "663:    }",
          "665:    item_sanity(item, iter.index);",
          "666:   }",
          "667:   rcu_read_unlock();",
          "668:  }",
          "669:  return NULL;",
          "670: }",
          "672: static void multiorder_iteration_race(void)",
          "673: {",
          "674:  const int num_threads = sysconf(_SC_NPROCESSORS_ONLN);",
          "675:  pthread_t worker_thread[num_threads];",
          "676:  RADIX_TREE(tree, GFP_KERNEL);",
          "677:  int i;",
          "679:  pthread_create(&worker_thread[0], NULL, &creator_func, &tree);",
          "680:  for (i = 1; i < num_threads; i++)",
          "681:   pthread_create(&worker_thread[i], NULL, &iterator_func, &tree);",
          "683:  for (i = 0; i < num_threads; i++)",
          "684:   pthread_join(worker_thread[i], NULL);",
          "686:  item_kill_tree(&tree);",
          "687: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "644:  multiorder_join();",
          "645:  multiorder_split();",
          "646:  multiorder_account();",
          "648:  radix_tree_cpu_dead(0);",
          "649: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "709:  multiorder_iteration_race();",
          "",
          "---------------"
        ],
        "tools/testing/radix-tree/test.h||tools/testing/radix-tree/test.h": [
          "File: tools/testing/radix-tree/test.h -> tools/testing/radix-tree/test.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: struct item *item_create(unsigned long index, unsigned int order);",
          "14: int __item_insert(struct radix_tree_root *root, struct item *item);",
          "15: int item_insert(struct radix_tree_root *root, unsigned long index);",
          "16: int item_insert_order(struct radix_tree_root *root, unsigned long index,",
          "17:    unsigned order);",
          "18: int item_delete(struct radix_tree_root *root, unsigned long index);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: void item_sanity(struct item *item, unsigned long index);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "69af7e23a6870df2ea6fa79ca16493d59b3eebeb",
      "candidate_info": {
        "commit_hash": "69af7e23a6870df2ea6fa79ca16493d59b3eebeb",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/69af7e23a6870df2ea6fa79ca16493d59b3eebeb",
        "files": [
          "arch/arm/probes/kprobes/opt-arm.c"
        ],
        "message": "ARM: 8769/1: kprobes: Fix to use get_kprobe_ctlblk after irq-disabed\n\nSince get_kprobe_ctlblk() uses smp_processor_id() to access\nper-cpu variable, it hits smp_processor_id sanity check as below.\n\n[    7.006928] BUG: using smp_processor_id() in preemptible [00000000] code: swapper/0/1\n[    7.007859] caller is debug_smp_processor_id+0x20/0x24\n[    7.008438] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.16.0-rc1-00192-g4eb17253e4b5 #1\n[    7.008890] Hardware name: Generic DT based system\n[    7.009917] [<c0313f0c>] (unwind_backtrace) from [<c030e6d8>] (show_stack+0x20/0x24)\n[    7.010473] [<c030e6d8>] (show_stack) from [<c0c64694>] (dump_stack+0x84/0x98)\n[    7.010990] [<c0c64694>] (dump_stack) from [<c071ca5c>] (check_preemption_disabled+0x138/0x13c)\n[    7.011592] [<c071ca5c>] (check_preemption_disabled) from [<c071ca80>] (debug_smp_processor_id+0x20/0x24)\n[    7.012214] [<c071ca80>] (debug_smp_processor_id) from [<c03335e0>] (optimized_callback+0x2c/0xe4)\n[    7.013077] [<c03335e0>] (optimized_callback) from [<bf0021b0>] (0xbf0021b0)\n\nTo fix this issue, call get_kprobe_ctlblk() right after\nirq-disabled since that disables preemption.\n\nFixes: 0dc016dbd820 (\"ARM: kprobes: enable OPTPROBES for ARM 32\")\nSigned-off-by: Masami Hiramatsu <mhiramat@kernel.org>\nCc: stable@vger.kernel.org\nSigned-off-by: Russell King <rmk+kernel@armlinux.org.uk>",
        "before_after_code_files": [
          "arch/arm/probes/kprobes/opt-arm.c||arch/arm/probes/kprobes/opt-arm.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/arm/probes/kprobes/opt-arm.c||arch/arm/probes/kprobes/opt-arm.c": [
          "File: arch/arm/probes/kprobes/opt-arm.c -> arch/arm/probes/kprobes/opt-arm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "165: {",
          "166:  unsigned long flags;",
          "167:  struct kprobe *p = &op->kp;",
          "171:  regs->ARM_pc = (unsigned long)op->kp.addr;",
          "172:  regs->ARM_ORIG_r0 = ~0UL;",
          "174:  local_irq_save(flags);",
          "176:  if (kprobe_running()) {",
          "177:   kprobes_inc_nmissed_count(&op->kp);",
          "",
          "[Removed Lines]",
          "168:  struct kprobe_ctlblk *kcb = get_kprobe_ctlblk();",
          "",
          "[Added Lines]",
          "168:  struct kprobe_ctlblk *kcb;",
          "175:  kcb = get_kprobe_ctlblk();",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-46389",
  "cve_desc": "IIPImage High Resolution Streaming Image Server prior to commit 882925b295a80ec992063deffc2a3b0d803c3195 is affected by an integer overflow in iipsrv.fcgi through malformed HTTP query parameters.",
  "repo": "ruven/iipsrv",
  "patch_hash": "882925b295a80ec992063deffc2a3b0d803c3195",
  "patch_info": {
    "commit_hash": "882925b295a80ec992063deffc2a3b0d803c3195",
    "repo": "ruven/iipsrv",
    "commit_url": "https://github.com/ruven/iipsrv/commit/882925b295a80ec992063deffc2a3b0d803c3195",
    "files": [
      "ChangeLog",
      "src/KakaduImage.cc",
      "src/OpenJPEGImage.cc",
      "src/RawTile.h",
      "src/TileManager.cc",
      "src/Transforms.cc"
    ],
    "message": "- Modified TileManager.cc to verify that malloc() has correctly allocated memory. - Updated numerical types to std::size_t in RawTile.h, TileManager.cc, KakaduImage.cc, OpenJPEG.cc and Transforms.cc when allocating memory via new to avoid integer overflow - fixes remaining problems identified in https://github.com/ruven/iipsrv/issues/223.",
    "before_after_code_files": [
      "src/KakaduImage.cc||src/KakaduImage.cc",
      "src/OpenJPEGImage.cc||src/OpenJPEGImage.cc",
      "src/RawTile.h||src/RawTile.h",
      "src/TileManager.cc||src/TileManager.cc",
      "src/Transforms.cc||src/Transforms.cc"
    ]
  },
  "patch_diff": {
    "src/KakaduImage.cc||src/KakaduImage.cc": [
      "File: src/KakaduImage.cc -> src/KakaduImage.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "448:   RawTile rawtile( 0, res, seq, ang, w, h, channels, obpc );",
      "452:   else throw file_error( \"Kakadu :: Unsupported number of bits\" );",
      "455:   rawtile.filename = getImagePath();",
      "456:   rawtile.timestamp = timestamp;",
      "",
      "[Removed Lines]",
      "450:   if( obpc == 16 ) rawtile.data = new unsigned short[w*h*channels];",
      "451:   else if( obpc == 8 ) rawtile.data = new unsigned char[w*h*channels];",
      "454:   rawtile.dataLength = w*h*channels*(obpc/8);",
      "",
      "[Added Lines]",
      "450:   size_t np = (size_t) w * (size_t) h * (size_t) channels;",
      "451:   if( obpc == 16 ) rawtile.data = new unsigned short[np];",
      "452:   else if( obpc == 8 ) rawtile.data = new unsigned char[np];",
      "455:   rawtile.dataLength = np*(obpc/8);",
      "",
      "---------------"
    ],
    "src/OpenJPEGImage.cc||src/OpenJPEGImage.cc": [
      "File: src/OpenJPEGImage.cc -> src/OpenJPEGImage.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "377:   RawTile rawtile( 0, res, ha, va, w, h, channels, obpc );",
      "381:   else throw file_error( \"OpenJPEG :: Unsupported number of bits\" );",
      "384:   rawtile.filename = getImagePath();",
      "385:   rawtile.timestamp = timestamp;",
      "",
      "[Removed Lines]",
      "379:   if( obpc == 16 ) rawtile.data = new unsigned short[w * h * channels];",
      "380:   else if( obpc == 8 ) rawtile.data = new unsigned char[w * h * channels];",
      "383:   rawtile.dataLength = w*h*channels*(obpc/8);",
      "",
      "[Added Lines]",
      "379:   size_t np = (size_t) w * (size_t) h * (size_t) channels;",
      "380:   if( obpc == 16 ) rawtile.data = new unsigned short[np];",
      "381:   else if( obpc == 8 ) rawtile.data = new unsigned char[np];",
      "384:   rawtile.dataLength = np*(obpc/8);",
      "",
      "---------------"
    ],
    "src/RawTile.h||src/RawTile.h": [
      "File: src/RawTile.h -> src/RawTile.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "79:   int memoryManaged;",
      "85:   unsigned int width;",
      "",
      "[Removed Lines]",
      "82:   unsigned int dataLength;",
      "",
      "[Added Lines]",
      "82:   size_t dataLength;",
      "",
      "---------------"
    ],
    "src/TileManager.cc||src/TileManager.cc": [
      "File: src/TileManager.cc -> src/TileManager.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "9:     This program is free software; you can redistribute it and/or modify",
      "10:     it under the terms of the GNU General Public License as published by",
      "",
      "[Removed Lines]",
      "7:     Copyright (C) 2005-2021 Ruven Pillay.",
      "",
      "[Added Lines]",
      "7:     Copyright (C) 2005-2022 Ruven Pillay.",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "134:   unsigned char* buffer = (unsigned char*) malloc( len );",
      "135:   unsigned char* src_ptr = (unsigned char*) memcpy( buffer, ttt->data, len );",
      "136:   unsigned char* dst_ptr = (unsigned char*) ttt->data;",
      "",
      "[Removed Lines]",
      "133:   int len = tw * th * ttt->channels * (ttt->bpc/8);",
      "",
      "[Added Lines]",
      "133:   unsigned int len = tw * th * ttt->channels * (ttt->bpc/8);",
      "137:   if( buffer == NULL ){",
      "138:     std::bad_alloc e;",
      "139:     throw e;",
      "140:   }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "367:   RawTile region( 0, res, seq, ang, width, height, channels, bpc );",
      "369:   region.sampleType = sampleType;",
      "377:   unsigned int current_height = 0;",
      "380:   for( unsigned int i=starty; i<endy; i++ ){",
      "",
      "[Removed Lines]",
      "368:   region.dataLength = width * height * channels * (bpc/8);",
      "372:   if( bpc == 8 ) region.data = new unsigned char[width*height*channels];",
      "373:   else if( bpc == 16 ) region.data = new unsigned short[width*height*channels];",
      "374:   else if( bpc == 32 && sampleType == FIXEDPOINT ) region.data = new int[width*height*channels];",
      "375:   else if( bpc == 32 && sampleType == FLOATINGPOINT ) region.data = new float[width*height*channels];",
      "382:     unsigned int buffer_index = 0;",
      "",
      "[Added Lines]",
      "374:   size_t np = (size_t) width * (size_t) height * (size_t) channels;",
      "375:   region.dataLength = np * (bpc/8);",
      "379:   if( bpc == 8 ) region.data = new unsigned char[np];",
      "380:   else if( bpc == 16 ) region.data = new unsigned short[np];",
      "381:   else if( bpc == 32 && sampleType == FIXEDPOINT ) region.data = new int[np];",
      "382:   else if( bpc == 32 && sampleType == FLOATINGPOINT ) region.data = new float[np];",
      "389:     unsigned long buffer_index = 0;",
      "",
      "---------------"
    ],
    "src/Transforms.cc||src/Transforms.cc": [
      "File: src/Transforms.cc -> src/Transforms.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "533:   in.width = resampled_width;",
      "534:   in.height = resampled_height;",
      "536:   in.data = output;",
      "537: }",
      "",
      "[Removed Lines]",
      "535:   in.dataLength = resampled_width * resampled_height * channels * (in.bpc/8);",
      "",
      "[Added Lines]",
      "535:   in.dataLength = (size_t)resampled_width * (size_t)resampled_height * (size_t)channels * (size_t)(in.bpc/8);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "619:   in.width = resampled_width;",
      "620:   in.height = resampled_height;",
      "622:   in.data = output;",
      "623: }",
      "",
      "[Removed Lines]",
      "621:   in.dataLength = resampled_width * resampled_height * channels * (in.bpc/8);",
      "",
      "[Added Lines]",
      "621:   in.dataLength = (size_t)resampled_width * (size_t)resampled_height * (size_t)channels * (size_t)(in.bpc/8);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4ed59265fbbd636dc2fbbf325f8ea37ed300a6d9",
      "candidate_info": {
        "commit_hash": "4ed59265fbbd636dc2fbbf325f8ea37ed300a6d9",
        "repo": "ruven/iipsrv",
        "commit_url": "https://github.com/ruven/iipsrv/commit/4ed59265fbbd636dc2fbbf325f8ea37ed300a6d9",
        "files": [
          "ChangeLog",
          "src/JTL.cc",
          "src/SPECTRA.cc"
        ],
        "message": "Added verification that image has been set in SPECTRA.cc and check on the validity of the requested tile resolution in JTL.cc. Fixes a couple of the crash conditions reported in https://github.com/ruven/iipsrv/issues/223",
        "before_after_code_files": [
          "src/JTL.cc||src/JTL.cc",
          "src/SPECTRA.cc||src/SPECTRA.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/JTL.cc||src/JTL.cc": [
          "File: src/JTL.cc -> src/JTL.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "2:     IIP JTL Command Handler Class Member Function: Export a single tile",
          "6:     This program is free software; you can redistribute it and/or modify",
          "7:     it under the terms of the GNU General Public License as published by",
          "",
          "[Removed Lines]",
          "4:     Copyright (C) 2006-2021 Ruven Pillay.",
          "",
          "[Added Lines]",
          "4:     Copyright (C) 2006-2022 Ruven Pillay.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "43:   if( session->loglevel >= 2 ) command_timer.start();",
          "47:   if( (int)((session->view)->getRotation()) % 360 == 90 ){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47:   int num_res = (*session->image)->getNumResolutions();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "52:   }",
          "53:   else if( (int)((session->view)->getRotation()) % 360 == 180 ){",
          "55:     unsigned int im_width = (*session->image)->image_widths[num_res-resolution-1];",
          "56:     unsigned int im_height = (*session->image)->image_heights[num_res-resolution-1];",
          "57:     unsigned int tw = (*session->image)->getTileWidth();",
          "",
          "[Removed Lines]",
          "54:     int num_res = (*session->image)->getNumResolutions();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "66:     ostringstream error;",
          "67:     error << \"JTL :: Invalid resolution/tile number: \" << resolution << \",\" << tile;",
          "68:     throw error.str();",
          "",
          "[Removed Lines]",
          "65:   if( (resolution<0) || (tile<0) ){",
          "",
          "[Added Lines]",
          "68:   if( (resolution<0) || (tile<0) || (resolution>=num_res) ){",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "133:   }",
          "136:   if( session->view->embedICC() && ((*session->image)->getMetadata(\"icc\").size()>0) ){",
          "137:     if( session->loglevel >= 3 ){",
          "",
          "[Removed Lines]",
          "123:   int num_res = (*session->image)->getNumResolutions();",
          "124:   unsigned int im_width = (*session->image)->image_widths[num_res-resolution-1];",
          "125:   unsigned int im_height = (*session->image)->image_heights[num_res-resolution-1];",
          "126:   float dpi_x = (*session->image)->dpi_x * (float) im_width / (float) (*session->image)->getImageWidth();",
          "127:   float dpi_y = (*session->image)->dpi_y * (float) im_height / (float) (*session->image)->getImageHeight();",
          "128:   compressor->setResolution( dpi_x, dpi_y, (*session->image)->dpi_units );",
          "130:   if( session->loglevel >= 5 ){",
          "132:                         << ( ((*session->image)->dpi_units==1) ? \" pixels/inch\" : \" pixels/cm\" ) << endl;",
          "",
          "[Added Lines]",
          "126:   if( (*session->image)->dpi_x > 0 && (*session->image)->dpi_y > 0 ){",
          "127:     unsigned int im_width = (*session->image)->image_widths[num_res-resolution-1];",
          "128:     unsigned int im_height = (*session->image)->image_heights[num_res-resolution-1];",
          "129:     float dpi_x = (*session->image)->dpi_x * ( (float)im_width / (float)(*session->image)->getImageWidth() );",
          "130:     float dpi_y = (*session->image)->dpi_y * ( (float)im_height / (float)(*session->image)->getImageHeight() );",
          "131:     compressor->setResolution( dpi_x, dpi_y, (*session->image)->dpi_units );",
          "133:     if( session->loglevel >= 5 ){",
          "135:      << ( ((*session->image)->dpi_units==1) ? \" pixels/inch\" : \" pixels/cm\" ) << endl;",
          "136:     }",
          "",
          "---------------"
        ],
        "src/SPECTRA.cc||src/SPECTRA.cc": [
          "File: src/SPECTRA.cc -> src/SPECTRA.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "2:     IIP SPECTRA Command Handler Class Member Function",
          "6:     This program is free software; you can redistribute it and/or modify",
          "7:     it under the terms of the GNU General Public License as published by",
          "",
          "[Removed Lines]",
          "4:     Copyright (C) 2009-2021 Ruven Pillay.",
          "",
          "[Added Lines]",
          "4:     Copyright (C) 2009-2022 Ruven Pillay.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "37:   if( session->loglevel >= 3 ) (*session->logfile) << \"SPECTRA handler reached\" << endl;",
          "",
          "[Removed Lines]",
          "39:   int resolution, tile, x, y;",
          "",
          "[Added Lines]",
          "41:   this->session = session;",
          "42:   checkImage();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "47:   string arg = argument;",
          "48:   int delimitter = arg.find( \",\" );",
          "51:   arg = arg.substr( delimitter + 1, arg.length() );",
          "52:   delimitter = arg.find( \",\" );",
          "55:   arg = arg.substr( delimitter + 1, arg.length() );",
          "56:   delimitter = arg.find( \",\" );",
          "59:   arg = arg.substr( delimitter + 1, arg.length() );",
          "60:   delimitter = arg.find( \",\" );",
          "63:   if( session->loglevel >= 5 ){",
          "64:     (*session->logfile) << \"SPECTRA :: resolution: \" << resolution",
          "",
          "[Removed Lines]",
          "49:   resolution = atoi( arg.substr(0,delimitter).c_str() );",
          "53:   tile = atoi( arg.substr(0,delimitter).c_str() );",
          "57:   x = atoi( arg.substr(0,delimitter).c_str() );",
          "61:   y = atoi( arg.substr(0,arg.length()).c_str() );",
          "",
          "[Added Lines]",
          "52:   int resolution = atoi( arg.substr(0,delimitter).c_str() );",
          "56:   int tile = atoi( arg.substr(0,delimitter).c_str() );",
          "60:   int x = atoi( arg.substr(0,delimitter).c_str() );",
          "64:   int y = atoi( arg.substr(0,arg.length()).c_str() );",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2ab4337022fe33279d403378661c4272bd9438a1",
      "candidate_info": {
        "commit_hash": "2ab4337022fe33279d403378661c4272bd9438a1",
        "repo": "ruven/iipsrv",
        "commit_url": "https://github.com/ruven/iipsrv/commit/2ab4337022fe33279d403378661c4272bd9438a1",
        "files": [
          "ChangeLog",
          "src/TileManager.cc"
        ],
        "message": "Minor logging changes to TileManager class to allow improve logging with very detailed logging now moved into higher loglevel",
        "before_after_code_files": [
          "src/TileManager.cc||src/TileManager.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/TileManager.cc||src/TileManager.cc"
          ],
          "candidate": [
            "src/TileManager.cc||src/TileManager.cc"
          ]
        }
      },
      "candidate_diff": {
        "src/TileManager.cc||src/TileManager.cc": [
          "File: src/TileManager.cc -> src/TileManager.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "9:     This program is free software; you can redistribute it and/or modify",
          "10:     it under the terms of the GNU General Public License as published by",
          "",
          "[Removed Lines]",
          "7:     Copyright (C) 2005-2016 Ruven Pillay.",
          "",
          "[Added Lines]",
          "7:     Copyright (C) 2005-2021 Ruven Pillay.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "34: RawTile TileManager::getNewTile( int resolution, int tile, int xangle, int yangle, int layers, CompressionType c ){",
          "37:           << \"TileManager :: Cache Size: \" << tileCache->getNumElements()",
          "38:           << \" tiles, \" << tileCache->getMemorySize() << \" MB\" << endl;",
          "",
          "[Removed Lines]",
          "36:   if( loglevel >= 2 ) *logfile << \"TileManager :: Cache Miss for resolution: \" << resolution << \", tile: \" << tile << endl",
          "",
          "[Added Lines]",
          "36:   if( loglevel >= 4 ) *logfile << \"TileManager :: Cache Miss for resolution: \" << resolution << \", tile: \" << tile << endl",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "49:   if( watermark && watermark->isSet() ){",
          "52:     unsigned int tw = ttt.padded? image->getTileWidth() : ttt.width;",
          "53:     unsigned int th = ttt.padded? image->getTileHeight() : ttt.height;",
          "55:     watermark->apply( ttt.data, tw, th, ttt.channels, ttt.bpc );",
          "57:      << \" microseconds\" << endl;",
          "58:   }",
          "",
          "[Removed Lines]",
          "51:     if( loglevel >= 2 ) insert_timer.start();",
          "56:     if( loglevel >= 2 ) *logfile << \"TileManager :: Watermark applied: \" << insert_timer.getTime()",
          "",
          "[Added Lines]",
          "51:     if( loglevel >= 4 ) insert_timer.start();",
          "56:     if( loglevel >= 4 ) *logfile << \"TileManager :: Watermark applied: \" << insert_timer.getTime()",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "69:   if( c == UNCOMPRESSED ){",
          "72:     tileCache->insert( ttt );",
          "74:      << \" microseconds\" << endl;",
          "75:     return ttt;",
          "76:   }",
          "",
          "[Removed Lines]",
          "71:     if( loglevel >= 2 ) insert_timer.start();",
          "73:     if( loglevel >= 2 ) *logfile << \"TileManager :: Tile cache insertion time: \" << insert_timer.getTime()",
          "",
          "[Added Lines]",
          "71:     if( loglevel >= 4 ) insert_timer.start();",
          "73:     if( loglevel >= 4 ) *logfile << \"TileManager :: Tile cache insertion time: \" << insert_timer.getTime()",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "84:     if( ttt.bpc == 8 && (ttt.channels==1 || ttt.channels==3) ){",
          "86:       jpeg->Compress( ttt );",
          "88:        << compression_timer.getTime() << \" microseconds\" << endl;",
          "89:     }",
          "90:     break;",
          "",
          "[Removed Lines]",
          "85:       if( loglevel >=2 ) compression_timer.start();",
          "87:       if( loglevel >= 2 ) *logfile << \"TileManager :: JPEG Compression Time: \"",
          "",
          "[Added Lines]",
          "85:       if( loglevel >= 4 ) compression_timer.start();",
          "87:       if( loglevel >= 4 ) *logfile << \"TileManager :: JPEG Compression Time: \"",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "93:   case DEFLATE:",
          "97:     break;",
          "",
          "[Removed Lines]",
          "96:     if( loglevel >= 2 ) *logfile << \"TileManager :: DEFLATE Compression requested: Not currently available\" << endl;",
          "",
          "[Added Lines]",
          "96:     if( loglevel >= 4 ) *logfile << \"TileManager :: DEFLATE Compression requested: Not currently available\" << endl;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "109:   tileCache->insert( ttt );",
          "111:           << \" microseconds\" << endl;",
          "",
          "[Removed Lines]",
          "108:   if( loglevel >= 2 ) insert_timer.start();",
          "110:   if( loglevel >= 2 ) *logfile << \"TileManager :: Tile cache insertion time: \" << insert_timer.getTime()",
          "",
          "[Added Lines]",
          "108:   if( loglevel >= 4 ) insert_timer.start();",
          "110:   if( loglevel >= 4 ) *logfile << \"TileManager :: Tile cache insertion time: \" << insert_timer.getTime()",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "122:   int tw = image->getTileWidth();",
          "123:   int th = image->getTileHeight();",
          "127:       << \": This tile: \" << ttt->width << \"x\" << ttt->height",
          "128:       << endl;",
          "",
          "[Removed Lines]",
          "125:   if( loglevel >= 3 ){",
          "",
          "[Added Lines]",
          "125:   if( loglevel >= 5 ){",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "166:   if( loglevel >= 2 ) tile_timer.start();",
          "",
          "[Added Lines]",
          "166:   if( loglevel >= 3 ) tile_timer.start();",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "216:     RawTile newtile = this->getNewTile( resolution, tile, xangle, yangle, layers, c );",
          "219:      << tile_timer.getTime() << \" microseconds\" << endl;",
          "220:     return newtile;",
          "221:   }",
          "",
          "[Removed Lines]",
          "218:     if( loglevel >= 2 ) *logfile << \"TileManager :: Total Tile Access Time: \"",
          "",
          "[Added Lines]",
          "218:     if( loglevel >= 3 ) *logfile << \"TileManager :: Total Tile Access Time: \"",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "229:     default: break;",
          "230:   }",
          "233:           << \", tile: \" << tile",
          "234:           << \", compression: \" << compName << endl",
          "235:           << \"TileManager :: Cache Size: \"",
          "",
          "[Removed Lines]",
          "232:   if( loglevel >= 2 ) *logfile << \"TileManager :: Cache Hit for resolution: \" << resolution",
          "",
          "[Added Lines]",
          "232:   if( loglevel >= 3 ) *logfile << \"TileManager :: Cache Hit for resolution: \" << resolution",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "257:       if( loglevel >=2 ) compression_timer.start();",
          "258:       unsigned int oldlen = rawtile->dataLength;",
          "259:       unsigned int newlen = jpeg->Compress( ttt );",
          "261:        << \"TileManager :: JPEG Compression Time: \"",
          "262:        << compression_timer.getTime() << \" microseconds\" << endl",
          "263:        << \"TileManager :: Compression Ratio: \" << newlen << \"/\" << oldlen << \" = \"",
          "264:        << ( (float)newlen/(float)oldlen ) << endl;",
          "268:       tileCache->insert( ttt );",
          "270:        << \" microseconds\" << endl;",
          "273:        << tile_timer.getTime() << \" microseconds\" << endl;",
          "274:       return RawTile( ttt );",
          "275:     }",
          "276:   }",
          "279:           << tile_timer.getTime() << \" microseconds\" << endl;",
          "281:   return RawTile( *rawtile );",
          "",
          "[Removed Lines]",
          "260:       if( loglevel >= 2 ) *logfile << \"TileManager :: JPEG requested, but UNCOMPRESSED compression found in cache.\" << endl",
          "267:       if( loglevel >= 2 ) insert_timer.start();",
          "269:       if( loglevel >= 2 ) *logfile << \"TileManager :: Tile cache insertion time: \" << insert_timer.getTime()",
          "272:       if( loglevel >= 2 ) *logfile << \"TileManager :: Total Tile Access Time: \"",
          "278:   if( loglevel >= 2 ) *logfile << \"TileManager :: Total Tile Access Time: \"",
          "",
          "[Added Lines]",
          "260:       if( loglevel >= 3 ) *logfile << \"TileManager :: JPEG requested, but UNCOMPRESSED compression found in cache.\" << endl",
          "267:       if( loglevel >= 3 ) insert_timer.start();",
          "269:       if( loglevel >= 3 ) *logfile << \"TileManager :: Tile cache insertion time: \" << insert_timer.getTime()",
          "272:       if( loglevel >= 3 ) *logfile << \"TileManager :: Total Tile Access Time: \"",
          "278:   if( loglevel >= 3 ) *logfile << \"TileManager :: Total Tile Access Time: \"",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "379:     for( unsigned int j=startx; j<endx; j++ ){",
          "385:       RawTile rawtile = this->getTile( res, (i*ntlx) + j, seq, ang, layers, UNCOMPRESSED );",
          "389:    << (i*ntlx) + j << \" at resolution \" << res << endl;",
          "390:       }",
          "396:    << rawtile.bpc << \" bits per channel\" << endl;",
          "397:       }",
          "",
          "[Removed Lines]",
          "382:       if( loglevel >= 2 ) tile_timer.start();",
          "387:       if( loglevel >= 2 ){",
          "394:       if( (loglevel >= 4) && (i==starty) && (j==starty) ){",
          "",
          "[Added Lines]",
          "382:       if( loglevel >= 3 ) tile_timer.start();",
          "387:       if( loglevel >= 5 ){",
          "394:       if( (loglevel >= 5) && (i==starty) && (j==starty) ){",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "440:    if( remainder != 0 ) dst_tile_height = remainder;",
          "441:  }",
          "445:      << \", tile height: \" << dst_tile_height << endl;",
          "446:  }",
          "",
          "[Removed Lines]",
          "443:  if( loglevel >= 4 ){",
          "",
          "[Added Lines]",
          "443:  if( loglevel >= 5 ){",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "19b40a97f6820ad2fb8983555a1fcf970df1ff53",
      "candidate_info": {
        "commit_hash": "19b40a97f6820ad2fb8983555a1fcf970df1ff53",
        "repo": "ruven/iipsrv",
        "commit_url": "https://github.com/ruven/iipsrv/commit/19b40a97f6820ad2fb8983555a1fcf970df1ff53",
        "files": [
          "ChangeLog",
          "src/JPEGCompressor.cc",
          "src/PNGCompressor.cc",
          "src/RawTile.h",
          "src/TPTImage.cc",
          "src/TPTImage.h",
          "src/WebPCompressor.cc"
        ],
        "message": "Major changes to the Rawtile class to enable move assignment and copy operators for C++11 compatible compilers. This eliminates a number of unnecessary memory allocation and copy operations when using Rawtile objects, improving speed and reducing memory usage",
        "before_after_code_files": [
          "src/JPEGCompressor.cc||src/JPEGCompressor.cc",
          "src/PNGCompressor.cc||src/PNGCompressor.cc",
          "src/RawTile.h||src/RawTile.h",
          "src/TPTImage.cc||src/TPTImage.cc",
          "src/TPTImage.h||src/TPTImage.h",
          "src/WebPCompressor.cc||src/WebPCompressor.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/RawTile.h||src/RawTile.h"
          ],
          "candidate": [
            "src/RawTile.h||src/RawTile.h"
          ]
        }
      },
      "candidate_diff": {
        "src/JPEGCompressor.cc||src/JPEGCompressor.cc": [
          "File: src/JPEGCompressor.cc -> src/JPEGCompressor.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "442:   unsigned long dataLength;",
          "443:   dataLength = dest->written;",
          "445:     if( rawtile.memoryManaged ) delete[] (unsigned char*) rawtile.data;",
          "446:     rawtile.data = new unsigned char[dataLength];",
          "447:   }",
          "",
          "[Removed Lines]",
          "444:   if( dataLength > rawtile.dataLength ){",
          "",
          "[Added Lines]",
          "445:   if( dataLength > rawtile.capacity ){",
          "448:     rawtile.capacity = dataLength;",
          "",
          "---------------"
        ],
        "src/PNGCompressor.cc||src/PNGCompressor.cc": [
          "File: src/PNGCompressor.cc -> src/PNGCompressor.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "356:     if( rawtile.memoryManaged ) delete[] (unsigned char*) rawtile.data;",
          "357:     rawtile.data = new unsigned char[dest.written];",
          "358:   }",
          "360:   rawtile.dataLength = dest.written;",
          "",
          "[Removed Lines]",
          "355:   if( dest.written > rawtile.dataLength ){",
          "",
          "[Added Lines]",
          "355:   if( dest.written > rawtile.capacity ){",
          "358:     rawtile.capacity = dest.written;",
          "",
          "---------------"
        ],
        "src/RawTile.h||src/RawTile.h": [
          "File: src/RawTile.h -> src/RawTile.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "44: enum SampleType { FIXEDPOINT, FLOATINGPOINT };",
          "51:  public:",
          "66:   CompressionType compressionType;",
          "",
          "[Removed Lines]",
          "49: class RawTile{",
          "54:   int tileNum;",
          "57:   int resolution;",
          "60:   int hSequence;",
          "63:   int vSequence;",
          "",
          "[Added Lines]",
          "48: class RawTile {",
          "53:   std::string filename;",
          "56:   unsigned int width;",
          "59:   unsigned int height;",
          "62:   int channels;",
          "65:   int bpc;",
          "68:   SampleType sampleType;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "69:   int quality;",
          "75:   time_t timestamp;",
          "",
          "[Removed Lines]",
          "72:   std::string filename;",
          "78:   void *data;",
          "83:   int memoryManaged;",
          "86:   uint32_t dataLength;",
          "89:   unsigned int width;",
          "92:   unsigned int height;",
          "95:   int channels;",
          "98:   int bpc;",
          "101:   SampleType sampleType;",
          "104:   bool padded;",
          "",
          "[Added Lines]",
          "80:   int tileNum;",
          "83:   int resolution;",
          "86:   int hSequence;",
          "89:   int vSequence;",
          "92:   bool padded;",
          "95:   uint32_t capacity;",
          "98:   uint32_t dataLength;",
          "103:   int memoryManaged;",
          "106:   void *data;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "115:       @param b bits per channel per sample",
          "117:   RawTile( int tn = 0, int res = 0, int hs = 0, int vs = 0,",
          "127:   ~RawTile() {",
          "128:     if( data && memoryManaged ){",
          "129:       switch( bpc ){",
          "140:       }",
          "141:     }",
          "142:   }",
          "180:       memoryManaged = 1;",
          "181:     }",
          "182:   }",
          "186:   RawTile& operator= ( const RawTile& tile ) {",
          "205:     switch( bpc ){",
          "206:       case 32:",
          "209:  break;",
          "210:       case 16:",
          "212:  break;",
          "213:       default:",
          "215:  break;",
          "216:     }",
          "",
          "[Removed Lines]",
          "118:     int w = 0, int h = 0, int c = 0, int b = 0 ) {",
          "119:     width = w; height = h; bpc = b; dataLength = 0; data = NULL;",
          "120:     tileNum = tn; resolution = res; hSequence = hs ; vSequence = vs;",
          "121:     memoryManaged = 1; channels = c; compressionType = UNCOMPRESSED; quality = 0;",
          "122:     timestamp = 0; sampleType = FIXEDPOINT; padded = false;",
          "123:   };",
          "130:       case 32:",
          "131:         if( sampleType == FLOATINGPOINT ) delete[] (float*) data;",
          "132:         else delete[] (unsigned int*) data;",
          "133:         break;",
          "134:       case 16:",
          "135:  delete[] (unsigned short*) data;",
          "136:         break;",
          "137:       default:",
          "138:  delete[] (unsigned char*) data;",
          "139:         break;",
          "146:   RawTile( const RawTile& tile ) {",
          "148:     tileNum = tile.tileNum;",
          "149:     resolution = tile.resolution;",
          "150:     hSequence = tile.hSequence;",
          "151:     vSequence = tile.vSequence;",
          "152:     compressionType = tile.compressionType;",
          "153:     quality = tile.quality;",
          "154:     filename = tile.filename;",
          "155:     timestamp = tile.timestamp;",
          "156:     memoryManaged = tile.memoryManaged;",
          "157:     dataLength = tile.dataLength;",
          "158:     width = tile.width;",
          "159:     height = tile.height;",
          "160:     channels = tile.channels;",
          "161:     bpc = tile.bpc;",
          "162:     sampleType = tile.sampleType;",
          "163:     padded = tile.padded;",
          "165:     switch( bpc ){",
          "166:       case 32:",
          "167:  if( sampleType == FLOATINGPOINT ) data = new float[dataLength/4];",
          "168:  else data = new unsigned int[dataLength/4];",
          "169:  break;",
          "170:       case 16:",
          "171:  data = new unsigned short[dataLength/2];",
          "172:  break;",
          "173:       default:",
          "174:  data = new unsigned char[dataLength];",
          "175:  break;",
          "176:     }",
          "178:     if( data && (dataLength > 0) && tile.data ){",
          "179:       memcpy( data, tile.data, dataLength );",
          "188:     tileNum = tile.tileNum;",
          "189:     resolution = tile.resolution;",
          "190:     hSequence = tile.hSequence;",
          "191:     vSequence = tile.vSequence;",
          "192:     compressionType = tile.compressionType;",
          "193:     quality = tile.quality;",
          "194:     filename = tile.filename;",
          "195:     timestamp = tile.timestamp;",
          "196:     memoryManaged = tile.memoryManaged;",
          "197:     dataLength = tile.dataLength;",
          "198:     width = tile.width;",
          "199:     height = tile.height;",
          "200:     channels = tile.channels;",
          "201:     bpc = tile.bpc;",
          "202:     sampleType = tile.sampleType;",
          "203:     padded = tile.padded;",
          "207:  if( sampleType == FLOATINGPOINT ) data = new float[dataLength/4];",
          "208:  else data = new int[dataLength/4];",
          "211:  data = new unsigned short[dataLength/2];",
          "214:  data = new unsigned char[dataLength];",
          "218:     if( data && (dataLength > 0) && tile.data ){",
          "219:       memcpy( data, tile.data, dataLength );",
          "220:       memoryManaged = 1;",
          "221:     }",
          "223:     return *this;",
          "224:   }",
          "228:   unsigned int size() const { return dataLength; }",
          "",
          "[Added Lines]",
          "120:     int w = 0, int h = 0, int c = 0, int b = 0 )",
          "121:     : width( w ),",
          "122:       height( h ),",
          "123:       channels( c ),",
          "124:       bpc( b ),",
          "125:       sampleType( FIXEDPOINT ),",
          "126:       compressionType( UNCOMPRESSED ),",
          "127:       quality( 0 ),",
          "128:       timestamp( 0 ),",
          "129:       tileNum( tn ),",
          "130:       resolution( res ),",
          "131:       hSequence( hs ),",
          "132:       vSequence( vs ),",
          "133:       padded( false ),",
          "134:       capacity( 0 ),",
          "135:       dataLength( 0 ),",
          "136:       memoryManaged( 1 ),",
          "137:       data( NULL ) {};",
          "145:         case 32:",
          "146:    if( sampleType == FLOATINGPOINT ) delete[] (float*) data;",
          "147:    else delete[] (unsigned int*) data;",
          "148:    break;",
          "149:         case 16:",
          "150:    delete[] (unsigned short*) data;",
          "151:    break;",
          "152:         default:",
          "153:    delete[] (unsigned char*) data;",
          "154:    break;",
          "156:       data = NULL;",
          "157:       dataLength = 0;",
          "158:       capacity = 0;",
          "165:   RawTile( const RawTile& tile )",
          "166:     : filename( tile.filename ),",
          "167:       width( tile.width ),",
          "168:       height( tile.height ),",
          "169:       channels( tile.channels ),",
          "170:       bpc( tile.bpc ),",
          "171:       sampleType( tile.sampleType ),",
          "172:       compressionType( tile.compressionType ),",
          "173:       quality( tile.quality ),",
          "174:       timestamp( tile.timestamp ),",
          "175:       tileNum( tile.tileNum ),",
          "176:       resolution( tile.resolution ),",
          "177:       hSequence( tile.hSequence ),",
          "178:       vSequence( tile.vSequence ),",
          "179:       padded( tile.padded ),",
          "180:       capacity( tile.capacity ),",
          "181:       dataLength( tile.dataLength ),",
          "182:       memoryManaged( tile.memoryManaged ),",
          "183:       data( NULL )",
          "184:   {",
          "186:     if( tile.data && tile.dataLength > 0 ){",
          "187:       allocate();",
          "188:       memcpy( data, tile.data, tile.dataLength );",
          "199:     if( this != &tile ){",
          "201:       tileNum = tile.tileNum;",
          "202:       resolution = tile.resolution;",
          "203:       hSequence = tile.hSequence;",
          "204:       vSequence = tile.vSequence;",
          "205:       compressionType = tile.compressionType;",
          "206:       quality = tile.quality;",
          "207:       filename = tile.filename;",
          "208:       timestamp = tile.timestamp;",
          "209:       memoryManaged = tile.memoryManaged;",
          "210:       dataLength = tile.dataLength;",
          "211:       width = tile.width;",
          "212:       height = tile.height;",
          "213:       channels = tile.channels;",
          "214:       bpc = tile.bpc;",
          "215:       sampleType = tile.sampleType;",
          "216:       padded = tile.padded;",
          "217:       capacity = tile.capacity;",
          "219:       if( tile.data && tile.dataLength > 0 ){",
          "220:  allocate();",
          "221:  memcpy( data, tile.data, tile.dataLength );",
          "222:  memoryManaged = 1;",
          "223:       }",
          "224:     }",
          "226:     return *this;",
          "227:   }",
          "234:   void allocate( uint32_t size = 0 ) {",
          "236:     if( size == 0 ) size = (uint32_t) width * height * channels * (bpc/8);",
          "240:  if( sampleType == FLOATINGPOINT ) data = new float[size/4];",
          "241:  else data = new int[size/4];",
          "244:  data = new unsigned short[size/2];",
          "247:  data = new unsigned char[size];",
          "250:     memoryManaged = 1;",
          "251:     capacity = size;",
          "252:   };",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "258:   }",
          "264: #endif",
          "",
          "[Removed Lines]",
          "261: };",
          "",
          "[Added Lines]",
          "289: #if (__cplusplus >= 201103L) || ((defined(_MSC_VER) && _MSC_VER >= 1900))",
          "292:   RawTile( RawTile&& tile ) noexcept",
          "293:     : filename( tile.filename ),",
          "294:       width( tile.width ),",
          "295:       height( tile.height ),",
          "296:       channels( tile.channels ),",
          "297:       bpc( tile.bpc ),",
          "298:       sampleType( tile.sampleType ),",
          "299:       compressionType( tile.compressionType ),",
          "300:       quality( tile.quality ),",
          "301:       timestamp( tile.timestamp ),",
          "302:       tileNum( tile.tileNum ),",
          "303:       resolution( tile.resolution ),",
          "304:       hSequence( tile.hSequence ),",
          "305:       vSequence( tile.vSequence ),",
          "306:       padded( tile.padded ),",
          "307:       capacity( tile.capacity ),",
          "308:       dataLength( tile.dataLength ),",
          "309:       memoryManaged( tile.memoryManaged ),",
          "310:       data( NULL )",
          "311:   {",
          "313:     if( tile.memoryManaged == 1 ){",
          "316:       data = tile.data;",
          "319:       tile.data = nullptr;",
          "320:       tile.dataLength = 0;",
          "321:       tile.capacity = 0;",
          "322:       tile.memoryManaged = 0;",
          "323:     }",
          "325:     else if( tile.data && dataLength>0 ){",
          "326:       allocate();",
          "327:       memcpy( data, tile.data, tile.dataLength );",
          "328:       memoryManaged = 1;",
          "329:     }",
          "330:   }",
          "335:   RawTile& operator= ( RawTile&& tile ) noexcept {",
          "337:     if( this != &tile ){",
          "339:       if( data && dataLength>0 ) delete this;",
          "342:       filename = std::move( tile.filename );",
          "343:       tileNum = tile.tileNum;",
          "344:       resolution = tile.resolution;",
          "345:       hSequence = tile.hSequence;",
          "346:       vSequence = tile.vSequence;",
          "347:       compressionType = tile.compressionType;",
          "348:       quality = tile.quality;",
          "349:       timestamp = tile.timestamp;",
          "350:       memoryManaged = tile.memoryManaged;",
          "351:       capacity = tile.capacity;",
          "352:       dataLength = tile.dataLength;",
          "353:       width = tile.width;",
          "354:       height = tile.height;",
          "355:       channels = tile.channels;",
          "356:       bpc = tile.bpc;",
          "357:       sampleType = tile.sampleType;",
          "358:       padded = tile.padded;",
          "360:       if( tile.memoryManaged == 1 ){",
          "363:  data = tile.data;",
          "366:  tile.data = nullptr;",
          "367:  tile.dataLength = 0;",
          "368:  tile.capacity = 0;",
          "369:  tile.memoryManaged = 0;",
          "370:       }",
          "371:       else if( tile.data && tile.dataLength>0 ){",
          "372:  allocate();",
          "373:  memcpy( data, tile.data, tile.dataLength );",
          "374:  memoryManaged = 1;",
          "375:       }",
          "376:     }",
          "378:     return *this;",
          "379:   }",
          "381: #endif",
          "383: };",
          "",
          "---------------"
        ],
        "src/TPTImage.cc||src/TPTImage.cc": [
          "File: src/TPTImage.cc -> src/TPTImage.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: {",
          "46:   string filename = getFileName( currentX, currentY );",
          "",
          "[Removed Lines]",
          "42:   if( tiff || tile_buf ){",
          "43:     throw file_error( \"TPTImage :: tiff or tile_buf is not NULL\" );",
          "44:   }",
          "",
          "[Added Lines]",
          "42:   if( tiff ) throw file_error( \"TPTImage :: tiff pointer is not NULL\" );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "216:     TIFFClose( tiff );",
          "217:     tiff = NULL;",
          "218:   }",
          "223: }",
          "",
          "[Removed Lines]",
          "219:   if( tile_buf != NULL ){",
          "220:     _TIFFfree( tile_buf );",
          "221:     tile_buf = NULL;",
          "222:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "300:   }",
          "",
          "[Removed Lines]",
          "304:   unsigned int np = tw * th;",
          "",
          "[Added Lines]",
          "298:   size_t np = tw * th;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "345:   else colourspace = sRGB;",
          "363:   RawTile rawtile( tile, res, seq, ang, tw, th, channels, bpc );",
          "366:   rawtile.filename = getImagePath();",
          "367:   rawtile.timestamp = timestamp;",
          "369:   rawtile.padded = true;",
          "370:   rawtile.sampleType = sampleType;",
          "374:   if( bpc==1 && channels==1 ){",
          "",
          "[Removed Lines]",
          "349:   if( !tile_buf ){",
          "350:     if( ( tile_buf = _TIFFmalloc( TIFFTileSize(tiff) ) ) == NULL ){",
          "351:       throw file_error( \"TPTImage :: TIFFmalloc() failed\" );",
          "352:     }",
          "353:   }",
          "356:   int length = TIFFReadEncodedTile( tiff, (ttile_t) tile,",
          "357:         tile_buf, (tsize_t) - 1 );",
          "358:   if( length == -1 ) {",
          "359:     throw file_error( \"TPTImage :: TIFFReadEncodedTile() failed for \" + getFileName( seq, ang ) );",
          "360:   }",
          "364:   rawtile.data = tile_buf;",
          "365:   rawtile.dataLength = length;",
          "368:   rawtile.memoryManaged = 0;",
          "",
          "[Added Lines]",
          "350:   uint32_t bytes = TIFFTileSize( tiff );",
          "351:   rawtile.allocate( bytes );",
          "354:   int length = TIFFReadEncodedTile( tiff, (ttile_t) tile, (tdata_t) rawtile.data, (tsize_t) bytes );",
          "355:   if( length == -1 ){",
          "356:     throw file_error( \"TPTImage :: TIFFReadEncodedTile() failed for \" + getFileName( seq, ang ) );",
          "357:   }",
          "358:   rawtile.dataLength = length;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "392:     for( unsigned int i=0; i<nbytes; i++ ){",
          "395:       for( int k=7; k>=0; k-- ){",
          "",
          "[Removed Lines]",
          "393:       unsigned char t = ((unsigned char*)tile_buf)[i];",
          "",
          "[Added Lines]",
          "381:       unsigned char t = ((unsigned char*)rawtile.data)[i];",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "401:     rawtile.dataLength = n;",
          "402:     rawtile.data = buffer;",
          "403:     rawtile.bpc = 8;",
          "405:   }",
          "410: }",
          "",
          "[Removed Lines]",
          "404:     rawtile.memoryManaged = 1;",
          "408:   return( rawtile );",
          "",
          "[Added Lines]",
          "394:   return rawtile;",
          "",
          "---------------"
        ],
        "src/TPTImage.h||src/TPTImage.h": [
          "File: src/TPTImage.h -> src/TPTImage.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "40:   TIFF *tiff;",
          "46:  public:",
          "",
          "[Removed Lines]",
          "43:   tdata_t tile_buf;",
          "49:   TPTImage():IIPImage(), tiff( NULL ), tile_buf( NULL ) {};",
          "54:   TPTImage( const std::string& path ): IIPImage( path ), tiff( NULL ), tile_buf( NULL ) {};",
          "59:   TPTImage( const TPTImage& image ): IIPImage( image ), tiff( NULL ), tile_buf( NULL ) {};",
          "",
          "[Added Lines]",
          "46:   TPTImage():IIPImage(), tiff( NULL ) {};",
          "51:   TPTImage( const std::string& path ): IIPImage( path ), tiff( NULL ) {};",
          "56:   TPTImage( const TPTImage& image ): IIPImage( image ), tiff( NULL ) {};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "66:       closeImage();",
          "67:       IIPImage::operator=(image);",
          "68:       tiff = image.tiff;",
          "70:     }",
          "71:     return *this;",
          "72:   }",
          "",
          "[Removed Lines]",
          "69:       tile_buf = image.tile_buf;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "77:   TPTImage( const IIPImage& image ): IIPImage( image ) {",
          "79:   };",
          "",
          "[Removed Lines]",
          "78:     tiff = NULL; tile_buf = NULL;",
          "",
          "[Added Lines]",
          "74:     tiff = NULL;",
          "",
          "---------------"
        ],
        "src/WebPCompressor.cc||src/WebPCompressor.cc": [
          "File: src/WebPCompressor.cc -> src/WebPCompressor.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "171:     if( rawtile.memoryManaged ) delete[] (unsigned char*) rawtile.data;",
          "172:     rawtile.data = new unsigned char[size];",
          "173:   }",
          "",
          "[Removed Lines]",
          "170:   if( size > rawtile.dataLength ){",
          "",
          "[Added Lines]",
          "170:   if( size > rawtile.capacity ){",
          "173:     rawtile.capacity = size;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "64d52a9d3ae1c5e70eb90e565f0a502b97c679dd",
      "candidate_info": {
        "commit_hash": "64d52a9d3ae1c5e70eb90e565f0a502b97c679dd",
        "repo": "ruven/iipsrv",
        "commit_url": "https://github.com/ruven/iipsrv/commit/64d52a9d3ae1c5e70eb90e565f0a502b97c679dd",
        "files": [
          "ChangeLog",
          "src/PFL.cc",
          "src/RawTile.h",
          "src/TileManager.cc",
          "src/Transforms.cc",
          "src/Watermark.cc"
        ],
        "message": "Standardized all pixel index counters to type uint32_t in Transforms.cc and RawTile.h with added type-casting when necessary. Fixes CodeQL warnings about potential integer overflow.",
        "before_after_code_files": [
          "src/PFL.cc||src/PFL.cc",
          "src/RawTile.h||src/RawTile.h",
          "src/TileManager.cc||src/TileManager.cc",
          "src/Transforms.cc||src/Transforms.cc",
          "src/Watermark.cc||src/Watermark.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/RawTile.h||src/RawTile.h",
            "src/TileManager.cc||src/TileManager.cc",
            "src/Transforms.cc||src/Transforms.cc"
          ],
          "candidate": [
            "src/RawTile.h||src/RawTile.h",
            "src/TileManager.cc||src/TileManager.cc",
            "src/Transforms.cc||src/Transforms.cc"
          ]
        }
      },
      "candidate_diff": {
        "src/PFL.cc||src/PFL.cc": [
          "File: src/PFL.cc -> src/PFL.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "2:     IIP Profile Command Handler Class Member Function",
          "6:     This program is free software; you can redistribute it and/or modify",
          "7:     it under the terms of the GNU General Public License as published by",
          "",
          "[Removed Lines]",
          "4:     Copyright (C) 2013-2021 Ruven Pillay.",
          "",
          "[Added Lines]",
          "4:     Copyright (C) 2013-2022 Ruven Pillay.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "113:     width = 1;",
          "114:     height = 1;",
          "115:   }",
          "",
          "[Removed Lines]",
          "116:   unsigned long length = width * height;",
          "",
          "[Added Lines]",
          "116:   uint32_t length = (uint32_t) width * height;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "151:     length *= rawtile.channels;",
          "154:       float intensity = 0.0;",
          "155:       void *ptr;",
          "",
          "[Removed Lines]",
          "152:     for( unsigned int j=0; j<length; j++ ){",
          "",
          "[Added Lines]",
          "152:     for( uint32_t j=0; j<length; j++ ){",
          "",
          "---------------"
        ],
        "src/RawTile.h||src/RawTile.h": [
          "File: src/RawTile.h -> src/RawTile.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "79:   int memoryManaged;",
          "85:   unsigned int width;",
          "",
          "[Removed Lines]",
          "82:   size_t dataLength;",
          "",
          "[Added Lines]",
          "82:   uint32_t dataLength;",
          "",
          "---------------"
        ],
        "src/TileManager.cc||src/TileManager.cc": [
          "File: src/TileManager.cc -> src/TileManager.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "491:  if( bpc == 8 ){",
          "492:    unsigned char* ptr = (unsigned char*) rawtile.data;",
          "493:    unsigned char* buf = (unsigned char*) region.data;",
          "495:  }",
          "496:  else if( bpc ==  16 ){",
          "497:    unsigned short* ptr = (unsigned short*) rawtile.data;",
          "498:    unsigned short* buf = (unsigned short*) region.data;",
          "500:  }",
          "501:  else if( bpc == 32 && sampleType == FIXEDPOINT ){",
          "502:    unsigned int* ptr = (unsigned int*) rawtile.data;",
          "503:    unsigned int* buf = (unsigned int*) region.data;",
          "505:  }",
          "506:  else if( bpc == 32 && sampleType == FLOATINGPOINT ){",
          "507:    float* ptr = (float*) rawtile.data;",
          "508:    float* buf = (float*) region.data;",
          "510:  }",
          "511:       }",
          "",
          "[Removed Lines]",
          "494:    memcpy( &buf[buffer_index], &ptr[inx], dst_tile_width*channels );",
          "499:    memcpy( &buf[buffer_index], &ptr[inx], dst_tile_width*channels*2 );",
          "504:    memcpy( &buf[buffer_index], &ptr[inx], dst_tile_width*channels*4 );",
          "509:    memcpy( &buf[buffer_index], &ptr[inx], dst_tile_width*channels*4 );",
          "",
          "[Added Lines]",
          "494:    memcpy( &buf[buffer_index], &ptr[inx], (size_t)dst_tile_width*channels );",
          "499:    memcpy( &buf[buffer_index], &ptr[inx], (size_t)dst_tile_width*channels*2 );",
          "504:    memcpy( &buf[buffer_index], &ptr[inx], (size_t)dst_tile_width*channels*4 );",
          "509:    memcpy( &buf[buffer_index], &ptr[inx], (size_t)dst_tile_width*channels*4 );",
          "",
          "---------------"
        ],
        "src/Transforms.cc||src/Transforms.cc": [
          "File: src/Transforms.cc -> src/Transforms.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "62: void Transform::normalize( RawTile& in, const vector<float>& max, const vector<float>& min ) {",
          "64:   float *normdata;",
          "66:   unsigned int nc = in.channels;",
          "",
          "[Removed Lines]",
          "65:   unsigned int np = in.width * in.height * in.channels;",
          "",
          "[Added Lines]",
          "65:   uint32_t np = (uint32_t) in.width * in.height * in.channels;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "79:   }",
          "84:     float minc = min[c];",
          "85:     float diffc = max[c] - minc;",
          "",
          "[Removed Lines]",
          "82:   for( unsigned int c = 0 ; c<nc ; c++){",
          "",
          "[Added Lines]",
          "82:   for( uint32_t c = 0 ; c<nc ; c++){",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "94: #elif defined(_OPENMP)",
          "95: #pragma omp parallel for",
          "96: #endif",
          "99:       }",
          "100:     }",
          "101:     else if( in.bpc == 32 && in.sampleType == FIXEDPOINT ) {",
          "",
          "[Removed Lines]",
          "97:       for( unsigned int n=c; n<np; n+=nc ){",
          "98:         normdata[n] = isfinite(fptr[n])? (fptr[n] - minc) * invdiffc : 0.0;",
          "",
          "[Added Lines]",
          "97:       for( uint32_t n=c; n<np; n+=nc ){",
          "98:         normdata[n] = isfinite(fptr[n])? (fptr[n] - minc) * invdiffc : 0.0f;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "106: #elif defined(_OPENMP)",
          "107: #pragma omp parallel for",
          "108: #endif",
          "110:         normdata[n] = (uiptr[n] - minc) * invdiffc;",
          "111:       }",
          "112:     }",
          "",
          "[Removed Lines]",
          "109:       for( unsigned int n=c; n<np; n+=nc ){",
          "",
          "[Added Lines]",
          "109:       for( uint32_t n=c; n<np; n+=nc ){",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "118: #elif defined(_OPENMP)",
          "119: #pragma omp parallel for",
          "120: #endif",
          "122:         normdata[n] = (usptr[n] - minc) * invdiffc;",
          "123:       }",
          "124:     }",
          "",
          "[Removed Lines]",
          "121:       for( unsigned int n=c; n<np; n+=nc ){",
          "",
          "[Added Lines]",
          "121:       for( uint32_t n=c; n<np; n+=nc ){",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "130: #elif defined(_OPENMP)",
          "131: #pragma omp parallel for",
          "132: #endif",
          "134:         normdata[n] = (ucptr[n] - minc) * invdiffc;",
          "135:       }",
          "136:     }",
          "",
          "[Removed Lines]",
          "133:       for( unsigned int n=c; n<np; n+=nc ){",
          "",
          "[Added Lines]",
          "133:       for( uint32_t n=c; n<np; n+=nc ){",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "151:   in.data = normdata;",
          "152:   in.bpc = 32;",
          "153:   in.sampleType = FLOATINGPOINT;",
          "156: }",
          "",
          "[Removed Lines]",
          "154:   in.dataLength = np * (in.bpc/8);",
          "",
          "[Added Lines]",
          "154:   in.dataLength = (uint32_t) np * (in.bpc/8);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "183:   float *buffer, *infptr;",
          "187:   infptr= (float*)in.data;",
          "193: #if defined(__ICC) || defined(__INTEL_COMPILER)",
          "",
          "[Removed Lines]",
          "185:   unsigned int ndata = in.dataLength * 8 / in.bpc;",
          "190:   buffer = new float[ndata];",
          "",
          "[Added Lines]",
          "185:   uint32_t np = (uint32_t) in.width * in.height * in.channels;",
          "190:   buffer = new float[np];",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "195: #elif defined(_OPENMP)",
          "196: #pragma omp parallel for",
          "197: #endif",
          "200:     unsigned int n = k*3;",
          "201:     if( infptr[n] == 0.0 && infptr[n+1] == 0.0 && infptr[n+2] == 0.0 ){",
          "",
          "[Removed Lines]",
          "198:   for( unsigned int k=0; k<ndata; k++ ){",
          "",
          "[Added Lines]",
          "198:   for( uint32_t k=0; k<np; k++ ){",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "224:   in.data = buffer;",
          "225:   in.channels = 1;",
          "227: }",
          "",
          "[Removed Lines]",
          "226:   in.dataLength = in.width * in.height * (in.bpc/8);",
          "",
          "[Added Lines]",
          "226:   in.dataLength = (uint32_t) in.width * in.height * (in.bpc/8);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "320: void Transform::LAB2sRGB( RawTile& in ){",
          "325: #if defined(__ICC) || defined(__INTEL_COMPILER)",
          "",
          "[Removed Lines]",
          "322:   unsigned long np = in.width * in.height * in.channels;",
          "",
          "[Added Lines]",
          "322:   uint32_t np = (uint32_t) in.width * in.height * in.channels;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "327: #elif defined(_OPENMP)",
          "328: #pragma omp parallel for",
          "329: #endif",
          "331:     unsigned char* ptr = (unsigned char*) in.data;",
          "332:     unsigned char q[3];",
          "333:     LAB2sRGB( &ptr[n], &q[0] );",
          "",
          "[Removed Lines]",
          "330:   for( unsigned long n=0; n<np; n+=in.channels ){",
          "",
          "[Added Lines]",
          "330:   for( uint32_t n=0; n<np; n+=in.channels ){",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "347:   float value;",
          "348:   unsigned in_chan = in.channels;",
          "349:   unsigned out_chan = 3;",
          "352:   const float max3 = 1.0/3.0;",
          "353:   const float max8 = 1.0/8.0;",
          "355:   float *fptr = (float*)in.data;",
          "357:   float *outv = outptr;",
          "359:   switch(cmap){",
          "",
          "[Removed Lines]",
          "350:   unsigned int ndata = in.dataLength * 8 / in.bpc;",
          "356:   float *outptr = new float[ndata*out_chan];",
          "",
          "[Added Lines]",
          "350:   uint32_t np = (uint32_t) in.width * in.height * in.channels;",
          "356:   float *outptr = new float[np*out_chan];",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "362: #if defined(__ICC) || defined(__INTEL_COMPILER)",
          "363: #pragma ivdep",
          "364: #endif",
          "366:         value = fptr[n];",
          "367:         if(value>1.)",
          "368:           { outv[0]=outv[1]=outv[2]=1.; }",
          "",
          "[Removed Lines]",
          "365:       for( int unsigned n=0; n<ndata; n+=in_chan, outv+=3 ){",
          "",
          "[Added Lines]",
          "365:       for( uint32_t n=0; n<np; n+=in_chan, outv+=3 ){",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "382: #if defined(__ICC) || defined(__INTEL_COMPILER)",
          "383: #pragma ivdep",
          "384: #endif",
          "386:         value = fptr[n];",
          "387:         if(value>1.)",
          "388:           { outv[0]=outv[1]=outv[2]=1.; }",
          "",
          "[Removed Lines]",
          "385:       for( unsigned int n=0; n<ndata; n+=in_chan, outv+=3 ){",
          "",
          "[Added Lines]",
          "385:       for( uint32_t n=0; n<np; n+=in_chan, outv+=3 ){",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "402: #if defined(__ICC) || defined(__INTEL_COMPILER)",
          "403: #pragma ivdep",
          "404: #endif",
          "406:         value = fptr[n];",
          "407:         if(value<0.)",
          "408:           { outv[0]=outv[1]=outv[2]=0.; }",
          "",
          "[Removed Lines]",
          "405:       for( unsigned int n=0; n<ndata; n+=in_chan, outv+=3 ){",
          "",
          "[Added Lines]",
          "405:       for( uint32_t n=0; n<np; n+=in_chan, outv+=3 ){",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "424: #if defined(__ICC) || defined(__INTEL_COMPILER)",
          "425: #pragma ivdep",
          "426: #endif",
          "428:  value = fptr[n];",
          "429:  outv[0] = value;",
          "430:  outv[1] = outv[2] = 0.;",
          "",
          "[Removed Lines]",
          "427:       for( unsigned int n=0; n<ndata; n+=in_chan, outv+=3 ){",
          "",
          "[Added Lines]",
          "427:       for( uint32_t n=0; n<np; n+=in_chan, outv+=3 ){",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "435: #if defined(__ICC) || defined(__INTEL_COMPILER)",
          "436: #pragma ivdep",
          "437: #endif",
          "439:  value = fptr[n];",
          "440:  outv[0] = outv[2] = 0.;",
          "441:  outv[1] = value;",
          "",
          "[Removed Lines]",
          "438:       for( unsigned int n=0; n<ndata; n+=in_chan, outv+=3 ) {",
          "",
          "[Added Lines]",
          "438:       for( uint32_t n=0; n<np; n+=in_chan, outv+=3 ) {",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "446: #if defined(__ICC) || defined(__INTEL_COMPILER)",
          "447: #pragma ivdep",
          "448: #endif",
          "450:  value = fptr[n];",
          "451:  outv[0] = outv[1] = 0;",
          "452:  outv[2] = value;",
          "",
          "[Removed Lines]",
          "449:       for( unsigned int n=0; n<ndata; n+=in_chan, outv+=3 ) {",
          "",
          "[Added Lines]",
          "449:       for( uint32_t n=0; n<np; n+=in_chan, outv+=3 ) {",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "462:   delete[] (float*) in.data;",
          "463:   in.data = outptr;",
          "464:   in.channels = out_chan;",
          "466: }",
          "",
          "[Removed Lines]",
          "465:   in.dataLength = ndata * out_chan * (in.bpc/8);",
          "",
          "[Added Lines]",
          "465:   in.dataLength = (uint32_t) np * out_chan * (in.bpc/8);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "471: void Transform::inv( RawTile& in ){",
          "474:   float *infptr = (float*) in.data;",
          "",
          "[Removed Lines]",
          "473:   unsigned int np = in.dataLength * 8 / in.bpc;",
          "",
          "[Added Lines]",
          "473:   uint32_t np = (uint32_t) in.width * in.height * in.channels;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "479: #elif defined(_OPENMP)",
          "480: #pragma omp parallel for",
          "481: #endif",
          "483:     float v = infptr[n];",
          "484:     infptr[n] = 1.0 - v;",
          "485:   }",
          "",
          "[Removed Lines]",
          "482:   for( unsigned int n=0; n<np; n++ ){",
          "",
          "[Added Lines]",
          "482:   for( uint32_t n=0; n<np; n++ ){",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "504:   bool new_buffer = false;",
          "505:   if( resampled_width*resampled_height > in.width*in.height ){",
          "506:     new_buffer = true;",
          "508:   }",
          "509:   else output = (unsigned char*) in.data;",
          "",
          "[Removed Lines]",
          "507:     output = new unsigned char[(unsigned long long)resampled_width*resampled_height*in.channels];",
          "",
          "[Added Lines]",
          "507:     output = new unsigned char[(uint32_t)resampled_width*resampled_height*in.channels];",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "526:  output[resampled_index+k] = input[pyramid_index+k];",
          "527:       }",
          "528:     }",
          "",
          "[Removed Lines]",
          "520:       unsigned long ii = (unsigned int) floorf(i*xscale);",
          "521:       unsigned long jj = (unsigned int) floorf(j*yscale);",
          "522:       unsigned long pyramid_index = (unsigned int) channels * ( ii + jj*width );",
          "524:       unsigned long long resampled_index = (unsigned long long)(i + j*resampled_width)*channels;",
          "525:       for( int k=0; k<in.channels; k++ ){",
          "",
          "[Added Lines]",
          "520:       uint32_t ii = (uint32_t) floorf(i*xscale);",
          "521:       uint32_t jj = (uint32_t) floorf(j*yscale);",
          "522:       uint32_t pyramid_index = (uint32_t) channels * ( ii + jj*width );",
          "524:       uint32_t resampled_index = (uint32_t)(i + j*resampled_width)*channels;",
          "525:       for( uint32_t k=0; k<(uint32_t)in.channels; k++ ){",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "535:   in.width = resampled_width;",
          "536:   in.height = resampled_height;",
          "538:   in.data = output;",
          "539: }",
          "",
          "[Removed Lines]",
          "537:   in.dataLength = (size_t)resampled_width * (size_t)resampled_height * (size_t)channels * (size_t)(in.bpc/8);",
          "",
          "[Added Lines]",
          "537:   in.dataLength = (uint32_t) resampled_width * resampled_height * channels * (in.bpc/8);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "552:   unsigned int height = in.height;",
          "561:   float xscale = (float)(width) / (float)resampled_width;",
          "",
          "[Removed Lines]",
          "555:   unsigned long max = ( (width*height) - 1 ) * channels;",
          "558:   unsigned char *output = new unsigned char[(unsigned long long)resampled_width*resampled_height*channels];",
          "",
          "[Added Lines]",
          "555:   uint32_t max = (uint32_t) ( (width*height) - 1 ) * channels;",
          "558:   unsigned char *output = new unsigned char[(uint32_t)resampled_width*resampled_height*channels];",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "584:       int ii = (int) floor( i*xscale );",
          "",
          "[Removed Lines]",
          "587:       unsigned long p11, p12, p21, p22;",
          "588:       unsigned long jj_w = jj*width;",
          "589:       p11 = (unsigned long) ( channels * ( ii + jj_w ) );",
          "590:       p12 = (unsigned long) ( channels * ( ii + (jj_w+width) ) );",
          "591:       p21 = (unsigned long) ( channels * ( (ii+1) + jj_w ) );",
          "592:       p22 = (unsigned long) ( channels * ( (ii+1) + (jj_w+width) ) );",
          "",
          "[Added Lines]",
          "587:       uint32_t p11, p12, p21, p22;",
          "588:       uint32_t jj_w = (uint32_t) jj*width;",
          "589:       p11 = (uint32_t) ( channels * ( ii + jj_w ) );",
          "590:       p12 = (uint32_t) ( channels * ( ii + (jj_w+width) ) );",
          "591:       p21 = (uint32_t) ( channels * ( (ii+1) + jj_w ) );",
          "592:       p22 = (uint32_t) ( channels * ( (ii+1) + (jj_w+width) ) );",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "603:       float b = iscale - (float)ii;",
          "609:  float tx = input[p11+k]*a + input[p21+k]*b;",
          "610:  float ty = input[p12+k]*a + input[p22+k]*b;",
          "611:  unsigned char r = (unsigned char)( c*tx + d*ty );",
          "",
          "[Removed Lines]",
          "606:       unsigned long long resampled_index = (unsigned long long)( (j*resampled_width + i) * channels );",
          "608:       for( int k=0; k<channels; k++ ){",
          "",
          "[Added Lines]",
          "606:       uint32_t resampled_index = (uint32_t)( (j*resampled_width + i) * channels );",
          "608:       for( uint32_t k=0; k<(uint32_t)channels; k++ ){",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "621:   in.width = resampled_width;",
          "622:   in.height = resampled_height;",
          "624:   in.data = output;",
          "625: }",
          "",
          "[Removed Lines]",
          "623:   in.dataLength = (size_t)resampled_width * (size_t)resampled_height * (size_t)channels * (size_t)(in.bpc/8);",
          "",
          "[Added Lines]",
          "623:   in.dataLength = (uint32_t) resampled_width * resampled_height * channels * (in.bpc/8);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "633:   if( in.bpc == 8 || in.sampleType == FLOATINGPOINT ) return;",
          "636:   unsigned char* buffer = new unsigned char[np];",
          "",
          "[Removed Lines]",
          "635:   size_t np = in.width * in.height * in.channels;",
          "",
          "[Added Lines]",
          "635:   uint32_t np = (uint32_t) in.width * in.height * in.channels;",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "642: #elif defined(_OPENMP)",
          "643: #pragma omp parallel for if( in.width*in.height > PARALLEL_THRESHOLD )",
          "644: #endif",
          "646:       buffer[n] = (unsigned char)(((unsigned int*)in.data)[n] >> 16);",
          "647:     }",
          "648:     delete[] (unsigned int*) in.data;",
          "",
          "[Removed Lines]",
          "645:     for( size_t n=0; n<np; n++ ){",
          "",
          "[Added Lines]",
          "645:     for( uint32_t n=0; n<np; n++ ){",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "655: #elif defined(_OPENMP)",
          "656: #pragma omp parallel for if( in.width*in.height > PARALLEL_THRESHOLD )",
          "657: #endif",
          "659:       buffer[n] = (unsigned char)(((unsigned short*)in.data)[n] >> 8);",
          "660:     }",
          "661:     delete[] (unsigned short*) in.data;",
          "",
          "[Removed Lines]",
          "658:     for( size_t n=0; n<np; n++ ){",
          "",
          "[Added Lines]",
          "658:     for( uint32_t n=0; n<np; n++ ){",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "674: void Transform::contrast( RawTile& in, float contrast ){",
          "677:   unsigned char* buffer = new unsigned char[np];",
          "678:   float* infptr = (float*)in.data;",
          "679:   const float max8 = 255.0;    // Max pixel value for 8 bit data",
          "",
          "[Removed Lines]",
          "676:   size_t np = in.width * in.height * in.channels;",
          "",
          "[Added Lines]",
          "676:   uint32_t np = (uint32_t) in.width * in.height * in.channels;",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "683: #elif defined(_OPENMP)",
          "684: #pragma omp parallel for if( in.width*in.height > PARALLEL_THRESHOLD )",
          "685: #endif",
          "687:     float v = infptr[n] * max8 * contrast;",
          "689:   }",
          "",
          "[Removed Lines]",
          "686:   for( size_t n=0; n<np; n++ ){",
          "688:     buffer[n] = (unsigned char)( (v<max8) ? (v<0.0? 0.0 : v) : max8 );",
          "",
          "[Added Lines]",
          "686:   for( uint32_t n=0; n<np; n++ ){",
          "688:     buffer[n] = (unsigned char)( (v<max8) ? (v<0.0? 0.0f : v) : max8 );",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "704:   if( g == 1.0 ) return;",
          "707:   float* infptr = (float*)in.data;",
          "",
          "[Removed Lines]",
          "706:   unsigned int np = in.width * in.height * in.channels;",
          "",
          "[Added Lines]",
          "706:   uint32_t np = (uint32_t) in.width * in.height * in.channels;",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "712: #elif defined(_OPENMP)",
          "713: #pragma omp parallel for",
          "714: #endif",
          "716:     float v = infptr[n];",
          "718:   }",
          "719: }",
          "",
          "[Removed Lines]",
          "715:   for( unsigned int n=0; n<np; n++ ){",
          "717:     infptr[n] = powf( v<0.0 ? 0.0 : v, g );",
          "",
          "[Added Lines]",
          "715:   for( uint32_t n=0; n<np; n++ ){",
          "717:     infptr[n] = powf( v<0.0 ? 0.0f : v, g );",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "731:   float scale = 1.0 / logf( max + 1.0 );",
          "735: #if defined(__ICC) || defined(__INTEL_COMPILER)",
          "736: #pragma ivdep",
          "737: #elif defined(_OPENMP)",
          "738: #pragma omp parallel for if( in.width*in.height > PARALLEL_THRESHOLD )",
          "739: #endif",
          "741:     float v = ((float*)in.data)[i] * max;",
          "742:     ((float*)in.data)[i] = scale * logf( 1.0 + v );",
          "743:   }",
          "",
          "[Removed Lines]",
          "733:   unsigned int np = in.width * in.height * in.channels;",
          "740:   for( unsigned int i=0; i<np; i++ ){",
          "",
          "[Added Lines]",
          "733:   uint32_t np = (uint32_t) in.width * in.height * in.channels;",
          "740:   for( uint32_t i=0; i<np; i++ ){",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "828:   if( rawtile.bpc != 8 || rawtile.channels != 3 ) return;",
          "831:   unsigned char* buffer = new unsigned char[rawtile.width * rawtile.height];",
          "",
          "[Removed Lines]",
          "830:   unsigned int np = rawtile.width * rawtile.height;",
          "",
          "[Added Lines]",
          "830:   uint32_t np = (uint32_t) rawtile.width * rawtile.height;",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "837: #elif defined(_OPENMP)",
          "838: #pragma omp parallel for if( rawtile.width*rawtile.height > PARALLEL_THRESHOLD )",
          "839: #endif",
          "841:     unsigned int n = i*rawtile.channels;",
          "842:     unsigned char R = ((unsigned char*)rawtile.data)[n++];",
          "843:     unsigned char G = ((unsigned char*)rawtile.data)[n++];",
          "",
          "[Removed Lines]",
          "840:   for( unsigned int i=0; i<np; i++ ){",
          "",
          "[Added Lines]",
          "840:   for( uint32_t i=0; i<np; i++ ){",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "864: void Transform::twist( RawTile& rawtile, const vector< vector<float> >& matrix ){",
          "869:   int output_channels = matrix.size();",
          "",
          "[Removed Lines]",
          "866:   size_t np = rawtile.width * rawtile.height;",
          "",
          "[Added Lines]",
          "866:   uint32_t np = (uint32_t) rawtile.width * rawtile.height;",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "892: #pragma omp for",
          "899:       for( int k=0; k<output_channels; k++ ){",
          "905:  for( unsigned int j=0; j<row_sizes[k]; j++ ){",
          "",
          "[Removed Lines]",
          "893:     for( size_t i=0; i<np; i++ ){",
          "895:       size_t in = i*rawtile.channels;  // Pixel index in input buffer",
          "896:       size_t on = i*output_channels;   // Pixel index in output buffer",
          "902:  pixel[k] = 0.0;",
          "",
          "[Added Lines]",
          "893:     for( uint32_t i=0; i<np; i++ ){",
          "895:       uint32_t in = (uint32_t) i*rawtile.channels;  // Pixel index in input buffer",
          "896:       uint32_t on = (uint32_t) i*output_channels;   // Pixel index in output buffer",
          "902:  pixel[k] = 0.0f;",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "925:     delete[] (float*) rawtile.data;",
          "926:     rawtile.data = output;",
          "927:     rawtile.channels = output_channels;",
          "929:   }",
          "931: }",
          "",
          "[Removed Lines]",
          "928:     rawtile.dataLength = np * rawtile.channels * (rawtile.bpc/8);",
          "",
          "[Added Lines]",
          "928:     rawtile.dataLength = (uint32_t) np * rawtile.channels * (rawtile.bpc/8);",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "940:   if( bands >= in.channels ) return;",
          "945:   unsigned int gap = in.channels - bands;",
          "949:     for( int k=0; k<bands; k++ ){",
          "950:       ((unsigned char*)in.data)[ni++] = ((unsigned char*)in.data)[no++];",
          "951:     }",
          "",
          "[Removed Lines]",
          "942:   unsigned long np = in.width * in.height;",
          "943:   unsigned long ni = 0;",
          "944:   unsigned long no = 0;",
          "948:   for( unsigned long i=0; i<np; i++ ){",
          "",
          "[Added Lines]",
          "942:   uint32_t np = (uint32_t) in.width * in.height;",
          "943:   uint32_t ni = 0;",
          "944:   uint32_t no = 0;",
          "948:   for( uint32_t i=0; i<np; i++ ){",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "1019:   vector<unsigned int> histogram( (1<<in.bpc), 0 );",
          "1027:     for( int k=0; k<in.channels; k++ ){",
          "",
          "[Removed Lines]",
          "1022:   unsigned int np = in.width * in.height;",
          "1023:   for( unsigned int n=0; n<np; n++ ){",
          "1024:     float value = 0.0;",
          "",
          "[Added Lines]",
          "1022:   uint32_t np = (uint32_t) in.width * in.height;",
          "1023:   for( uint32_t n=0; n<np; n++ ){",
          "1024:     float value = 0.0f;",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "1047:   float sum = 0.0, sumb = 0.0;",
          "1050:     np += histogram[n];",
          "1051:     sum += (float)n * histogram[n];",
          "1052:   }",
          "",
          "[Removed Lines]",
          "1048:   unsigned int np = 0;",
          "1049:   for( unsigned int n=0; n<bits; n++ ){",
          "",
          "[Added Lines]",
          "1048:   uint32_t np = 0;",
          "1049:   for( uint32_t n=0; n<bits; n++ ){",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "1086:   this->greyscale( in );",
          "1090: #if defined(__ICC) || defined(__INTEL_COMPILER)",
          "1091: #pragma ivdep",
          "1092: #elif defined(_OPENMP)",
          "1093: #pragma omp parallel for if( in.width*in.height > PARALLEL_THRESHOLD )",
          "1094: #endif",
          "1096:     ((unsigned char*)in.data)[i] = ( ((unsigned char*)in.data)[i] < threshold ? (unsigned char)0 : (unsigned char)255 );",
          "1097:   }",
          "1098: }",
          "",
          "[Removed Lines]",
          "1088:   unsigned int np = in.width * in.height;",
          "1095:   for( unsigned int i=0; i<np; i++ ){",
          "",
          "[Added Lines]",
          "1088:   uint32_t np = (uint32_t) in.width * in.height;",
          "1095:   for( uint32_t i=0; i<np; i++ ){",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "1102: void Transform::equalize( RawTile& in, vector<unsigned int>& histogram ){",
          "1105:   const unsigned int bits = histogram.size();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1104:   uint32_t np = (uint32_t) in.width * in.height;",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "1136: #elif defined(_OPENMP)",
          "1137: #pragma omp parallel for if( in.width*in.height > PARALLEL_THRESHOLD )",
          "1138: #endif",
          "1140:     for( int j=0; j<in.channels; j++ ){",
          "1142:       unsigned int value = (unsigned int) (((unsigned char*)in.data)[index]);",
          "1143:       ((unsigned char*)in.data)[index] = (unsigned char) cdf[value];",
          "1144:     }",
          "",
          "[Removed Lines]",
          "1139:   for( unsigned int i=0; i<in.width*in.height; i++ ){",
          "1141:       unsigned int index = i*in.channels + j;",
          "",
          "[Added Lines]",
          "1141:   for( uint32_t i=0; i<np; i++ ){",
          "1143:       uint32_t index = (uint32_t) i*in.channels + j;",
          "",
          "---------------"
        ],
        "src/Watermark.cc||src/Watermark.cc": [
          "File: src/Watermark.cc -> src/Watermark.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "7:     Culture of the Czech Republic.",
          "12:     This program is free software; you can redistribute it and/or modify",
          "13:     it under the terms of the GNU General Public License as published by",
          "",
          "[Removed Lines]",
          "10:     Copyright (C) 2010-2021 Ruven Pillay.",
          "",
          "[Added Lines]",
          "10:     Copyright (C) 2010-2022 Ruven Pillay.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "60:       _watermark = new unsigned char[_width*_height*_channels];",
          "64:       for( uint32_t i=0; i<_width*_height; i++ ){",
          "",
          "[Removed Lines]",
          "61:       memset( _watermark, 0, _width*_height*_channels );",
          "",
          "[Added Lines]",
          "61:       memset( _watermark, 0, (size_t) _width*_height*_channels );",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6a23cc6cbffa3bcc1341548d3237a63fec8abda8",
      "candidate_info": {
        "commit_hash": "6a23cc6cbffa3bcc1341548d3237a63fec8abda8",
        "repo": "ruven/iipsrv",
        "commit_url": "https://github.com/ruven/iipsrv/commit/6a23cc6cbffa3bcc1341548d3237a63fec8abda8",
        "files": [
          "ChangeLog",
          "src/TPTImage.cc",
          "src/TileManager.cc"
        ],
        "message": "Modification to TPTImage's getTile() and TileManager's getRegion() to handle images with different numbers of channels or bits within the same image sequence or stack",
        "before_after_code_files": [
          "src/TPTImage.cc||src/TPTImage.cc",
          "src/TileManager.cc||src/TileManager.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/TileManager.cc||src/TileManager.cc"
          ],
          "candidate": [
            "src/TileManager.cc||src/TileManager.cc"
          ]
        }
      },
      "candidate_diff": {
        "src/TPTImage.cc||src/TPTImage.cc": [
          "File: src/TPTImage.cc -> src/TPTImage.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "284:   TIFFGetField( tiff, TIFFTAG_IMAGEWIDTH, &im_width );",
          "285:   TIFFGetField( tiff, TIFFTAG_IMAGELENGTH, &im_height );",
          "286:   TIFFGetField( tiff, TIFFTAG_PHOTOMETRIC, &colour );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "287:   TIFFGetField( tiff, TIFFTAG_SAMPLESPERPIXEL, &channels );",
          "288:   TIFFGetField( tiff, TIFFTAG_BITSPERSAMPLE, &bpc );",
          "",
          "---------------"
        ],
        "src/TileManager.cc||src/TileManager.cc": [
          "File: src/TileManager.cc -> src/TileManager.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "379:   }",
          "394:   unsigned int current_height = 0;",
          "",
          "[Removed Lines]",
          "382:   unsigned int channels = image->getNumChannels();",
          "383:   unsigned int bpc = image->getNumBitsPerPixel();",
          "384:   SampleType sampleType = image->getSampleType();",
          "387:   if( bpc == 1 ) bpc = 8;",
          "390:   RawTile region( 0, res, seq, ang, width, height, channels, bpc );",
          "391:   region.sampleType = sampleType;",
          "392:   region.allocate();",
          "",
          "[Added Lines]",
          "383:   RawTile region( 0, res, seq, ang, width, height, 0, 0 );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "415:    << (i*ntlx) + j << \" at resolution \" << res << endl;",
          "416:       }",
          "423:       }",
          "",
          "[Removed Lines]",
          "420:       if( (loglevel >= 5) && (i==starty) && (j==starty) ){",
          "422:    << rawtile.bpc << \" bits per channel\" << endl;",
          "",
          "[Added Lines]",
          "412:       if( i==starty && j==starty ){",
          "414:  region.channels = rawtile.channels;",
          "415:  region.bpc = rawtile.bpc;",
          "416:  region.sampleType = rawtile.sampleType;",
          "417:  if( region.bpc == 1 ) region.bpc = 8;   // Assume 1 bit data has been unpacked to 8 bits per channel",
          "420:  region.allocate();",
          "422:  if( loglevel >= 5 ){",
          "424:      << rawtile.bpc << \" bits per channel\" << endl;",
          "425:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "478:       for( unsigned int k=0; k<dst_tile_height; k++ ){",
          "485:    unsigned char* ptr = (unsigned char*) rawtile.data;",
          "486:    unsigned char* buf = (unsigned char*) region.data;",
          "488:  }",
          "490:    unsigned short* ptr = (unsigned short*) rawtile.data;",
          "491:    unsigned short* buf = (unsigned short*) region.data;",
          "493:  }",
          "495:    unsigned int* ptr = (unsigned int*) rawtile.data;",
          "496:    unsigned int* buf = (unsigned int*) region.data;",
          "498:  }",
          "500:    float* ptr = (float*) rawtile.data;",
          "501:    float* buf = (float*) region.data;",
          "503:  }",
          "504:       }",
          "",
          "[Removed Lines]",
          "480:  buffer_index = (current_width*channels) + (k*width*channels) + (current_height*width*channels);",
          "481:  unsigned int inx = ((k+yf)*rawtile.width*channels) + (xf*channels);",
          "484:  if( bpc == 8 ){",
          "487:    memcpy( &buf[buffer_index], &ptr[inx], (size_t)dst_tile_width*channels );",
          "489:  else if( bpc ==  16 ){",
          "492:    memcpy( &buf[buffer_index], &ptr[inx], (size_t)dst_tile_width*channels*2 );",
          "494:  else if( bpc == 32 && sampleType == FIXEDPOINT ){",
          "497:    memcpy( &buf[buffer_index], &ptr[inx], (size_t)dst_tile_width*channels*4 );",
          "499:  else if( bpc == 32 && sampleType == FLOATINGPOINT ){",
          "502:    memcpy( &buf[buffer_index], &ptr[inx], (size_t)dst_tile_width*channels*4 );",
          "",
          "[Added Lines]",
          "483:  buffer_index = (current_width*region.channels) + (k*width*region.channels) + (current_height*width*region.channels);",
          "484:  unsigned int inx = ((k+yf)*rawtile.width*rawtile.channels) + (xf*rawtile.channels);",
          "487:  if( region.bpc == 8 ){",
          "490:    memcpy( &buf[buffer_index], &ptr[inx], (size_t)dst_tile_width*region.channels );",
          "492:  else if( region.bpc ==  16 ){",
          "495:    memcpy( &buf[buffer_index], &ptr[inx], (size_t)dst_tile_width*region.channels*2 );",
          "497:  else if( region.bpc == 32 && region.sampleType == FIXEDPOINT ){",
          "500:    memcpy( &buf[buffer_index], &ptr[inx], (size_t)dst_tile_width*region.channels*4 );",
          "502:  else if( region.bpc == 32 && region.sampleType == FLOATINGPOINT ){",
          "505:    memcpy( &buf[buffer_index], &ptr[inx], (size_t)dst_tile_width*region.channels*4 );",
          "",
          "---------------"
        ]
      }
    }
  ]
}
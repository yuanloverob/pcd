{
  "cve_id": "CVE-2017-11143",
  "cve_desc": "In PHP before 5.6.31, an invalid free in the WDDX deserialization of boolean parameters could be used by attackers able to inject XML for deserialization to crash the PHP interpreter, related to an invalid free for an empty boolean element in ext/wddx/wddx.c.",
  "repo": "php/php-src",
  "patch_hash": "2aae60461c2ff7b7fbcdd194c789ac841d0747d7",
  "patch_info": {
    "commit_hash": "2aae60461c2ff7b7fbcdd194c789ac841d0747d7",
    "repo": "php/php-src",
    "commit_url": "https://github.com/php/php-src/commit/2aae60461c2ff7b7fbcdd194c789ac841d0747d7",
    "files": [
      "ext/wddx/tests/bug74145.phpt",
      "ext/wddx/tests/bug74145.xml",
      "ext/wddx/wddx.c"
    ],
    "message": "Fix bug #74145 - wddx parsing empty boolean tag leads to SIGSEGV",
    "before_after_code_files": [
      "ext/wddx/tests/bug74145.phpt||ext/wddx/tests/bug74145.phpt",
      "ext/wddx/wddx.c||ext/wddx/wddx.c"
    ]
  },
  "patch_diff": {
    "ext/wddx/tests/bug74145.phpt||ext/wddx/tests/bug74145.phpt": [
      "File: ext/wddx/tests/bug74145.phpt -> ext/wddx/tests/bug74145.phpt",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: --TEST--",
      "2: Bug #74145 (wddx parsing empty boolean tag leads to SIGSEGV)",
      "3: --SKIPIF--",
      "4: <?php",
      "5: if (!extension_loaded(\"wddx\")) print \"skip\";",
      "6: ?>",
      "7: --FILE--",
      "8: <?php",
      "9: $data = file_get_contents(__DIR__ . '/bug74145.xml');",
      "10: $wddx = wddx_deserialize($data);",
      "11: var_dump($wddx);",
      "12: ?>",
      "13: DONE",
      "14: --EXPECTF--",
      "15: NULL",
      "16: DONE",
      "",
      "---------------"
    ],
    "ext/wddx/wddx.c||ext/wddx/wddx.c": [
      "File: ext/wddx/wddx.c -> ext/wddx/wddx.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "799:  } else if (!strcmp(name, EL_BOOLEAN)) {",
      "800:   int i;",
      "802:   if (atts) for (i = 0; atts[i]; i++) {",
      "803:    if (!strcmp(atts[i], EL_VALUE) && atts[i+1] && atts[i+1][0]) {",
      "810:     wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));",
      "811:     php_wddx_process_data(user_data, atts[i+1], strlen(atts[i+1]));",
      "812:     break;",
      "813:    }",
      "814:   } else {",
      "818:    wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));",
      "819:   }",
      "820:  } else if (!strcmp(name, EL_NULL)) {",
      "",
      "[Removed Lines]",
      "804:     ent.type = ST_BOOLEAN;",
      "805:     SET_STACK_VARNAME;",
      "807:     ALLOC_ZVAL(ent.data);",
      "808:     INIT_PZVAL(ent.data);",
      "809:     Z_TYPE_P(ent.data) = IS_BOOL;",
      "815:    ent.type = ST_BOOLEAN;",
      "816:    SET_STACK_VARNAME;",
      "817:    ZVAL_FALSE(&ent.data);",
      "",
      "[Added Lines]",
      "802:   ALLOC_ZVAL(ent.data);",
      "803:   INIT_PZVAL(ent.data);",
      "804:   Z_TYPE_P(ent.data) = IS_BOOL;",
      "805:   ent.type = ST_BOOLEAN;",
      "806:   SET_STACK_VARNAME;",
      "814:    ZVAL_FALSE(ent.data);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2a286ad5991ba06385b11e31dfdf59a31badb7b6",
      "candidate_info": {
        "commit_hash": "2a286ad5991ba06385b11e31dfdf59a31badb7b6",
        "repo": "php/php-src",
        "commit_url": "https://github.com/php/php-src/commit/2a286ad5991ba06385b11e31dfdf59a31badb7b6",
        "files": [
          "NEWS",
          "Zend/zend_bitset.h",
          "ext/opcache/Optimizer/compact_vars.c",
          "ext/opcache/Optimizer/dce.c",
          "ext/opcache/Optimizer/dfa_pass.c",
          "ext/opcache/Optimizer/sccp.c",
          "ext/opcache/Optimizer/scdf.c",
          "ext/opcache/Optimizer/scdf.h",
          "ext/opcache/Optimizer/ssa_integrity.c",
          "ext/opcache/Optimizer/zend_cfg.c",
          "ext/opcache/Optimizer/zend_cfg.h",
          "ext/opcache/Optimizer/zend_inference.c",
          "ext/opcache/Optimizer/zend_inference.h",
          "ext/opcache/Optimizer/zend_optimizer.c",
          "ext/opcache/Optimizer/zend_optimizer.h",
          "ext/opcache/Optimizer/zend_optimizer_internal.h",
          "ext/opcache/Optimizer/zend_ssa.c",
          "ext/opcache/Optimizer/zend_ssa.h",
          "ext/opcache/config.m4",
          "ext/opcache/config.w32",
          "ext/opcache/tests/ssa_bug_007.phpt"
        ],
        "message": "Added goblal optimisation passes based on data flow analyses using SSA form: SCCP - Sparse Conditional Constant Propagation, DCE - Dead Code Elimination and removing of unused local variablesi.\n\nSquashed commit of the following:\n\ncommit bf5ac05fc0f5f6ab9c7f2e4eaa83a11c84f471d3\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 14 14:26:40 2017 +0300\n\n    Added news entry\n\ncommit 4cfa6984b1f3cd8008a0c0dc82ee3de2da02bf7c\nMerge: 1cdaaac 1f261d7\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 14 13:30:50 2017 +0300\n\n    Merge branch 'sccp' into dce\n\n    * sccp:\n      Bump OCI8 version for recent patch\n      WS\n      Fix test title\n      Ensure that the stream position is kept between reads\n      Turn off EXIF_DEBUG so Travis don't complain at me\n      Don't add a new line to undefined tags in EXIF_DEBUG mode\n      Fix compile error with EXIF_DEBUG\n      update NEWS\n      disable --with-pcre-valgrind on travis\n      fix default args for --with-pcre-valgrind\n      Enable valgrind support for PCRE by default in debug builds\n      add oniguruma.patch to ease future upgrades\n      SIZEOF_SIZE_T doesn't exist on AIX and POWER8 (ppc64le), keep using SIZEOF_LONG\n\ncommit 1f261d77cb1cb966335097f364ace9349269c704\nMerge: a32a3fb b280ba8\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 14 13:30:39 2017 +0300\n\n    Merge branch 'master' into sccp\n\n    * master:\n      Bump OCI8 version for recent patch\n      WS\n      Fix test title\n      Ensure that the stream position is kept between reads\n      Turn off EXIF_DEBUG so Travis don't complain at me\n      Don't add a new line to undefined tags in EXIF_DEBUG mode\n      Fix compile error with EXIF_DEBUG\n      update NEWS\n      disable --with-pcre-valgrind on travis\n      fix default args for --with-pcre-valgrind\n      Enable valgrind support for PCRE by default in debug builds\n      add oniguruma.patch to ease future upgrades\n      SIZEOF_SIZE_T doesn't exist on AIX and POWER8 (ppc64le), keep using SIZEOF_LONG\n\ncommit 1cdaaac601cff37fa729f3e6b31dc584782a1649\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 14 13:27:12 2017 +0300\n\n    Use generic evalution mechanism for constant functions\n\ncommit 75bd92a60928818358686410deec24a48e05d6da\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 14 12:39:05 2017 +0300\n\n    Fixed use-def chain unlinking for \"$a = 1; $a += $a;\"\n\ncommit 7d7746814dc382e468f9016d90c069b88b8b0f0d\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 14 12:38:29 2017 +0300\n\n    Enable duplicate predecessors verification\n\ncommit 6b1667f2062d7c1b55e389b03b155cbe132f5dbf\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 14 11:55:20 2017 +0300\n\n    Removed duplicate definitions\n\ncommit 1415b53014bf5aa1521b779debea6847db8c7940\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 14 11:51:29 2017 +0300\n\n    Enable evaluation of constant functions with 3 arguments\n\ncommit ab367deef99f39dee15c6bbac45cb25eb9d29e00\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 14 11:45:13 2017 +0300\n\n    Removed deprecated check\n\ncommit c51659ea8c62e4e8fbf32a0567d4f541807d6b6d\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 14 11:40:42 2017 +0300\n\n    Reduce limit\n\ncommit b1be5a04d783eb160a71fe26e030386b3e2771ba\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 14 11:38:23 2017 +0300\n\n    Disable constant array_flip() evaluation\n\ncommit 7a5b0596a149a2efc5893ea83be78ef9129009cb\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 14 11:33:20 2017 +0300\n\n    Fixed comments\n\ncommit 377e48b3426f9ccbcd6207acbbed87b9fdbf549d\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 14 11:28:50 2017 +0300\n\n    Cast of string to long/double can not produce exception\n\ncommit 228dd01af3bf6daefbd7d5be82938dec8b55b6a0\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 14 11:24:50 2017 +0300\n\n    Added missed return\n\ncommit 0972a2163643757e7e270b8e1c466800aedf1308\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 14 11:22:36 2017 +0300\n\n    objects may be nested in array operands\n\ncommit bd346bfa5c4c58896fabd9ab2e4d9bb85b3c1402\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 14 11:19:20 2017 +0300\n\n    ~$resource is unsupported.\n\ncommit c77e45610c22e29b5f4ad7234e38a1f4e2498937\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 14 11:15:39 2017 +0300\n\n    ws\n\ncommit 0b64d71109fddfec736c91546b6df978adb1f4fd\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 14 11:14:40 2017 +0300\n\n    Call to zend_ssa_unlink_use_chain() shouldn't be dropped\n\ncommit cb7059fcf6e51616c08d5b8a933401a94ae0b6e0\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 14 11:11:58 2017 +0300\n\n    Safer check for function name. The previous check is incorrect in ZTS build.\n\ncommit 7280aba1e125fc314284d7ef1252e14d04c415a4\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 14 11:02:10 2017 +0300\n\n    Missing warning\n\ncommit 54bc7b576cee33037b7e575c013e3ede726647a2\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 14 10:56:42 2017 +0300\n\n    Proper check for successors count\n\ncommit ea8c004a155453b4e15684e2bd1bdb1dc99e8833\nMerge: 624f76d a32a3fb\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Thu Jul 13 15:56:26 2017 +0300\n\n    Merge branch 'sccp' into dce\n\n    * sccp:\n      fix fold\n      Fixed bug #74866 extension_dir = \"./ext\" now use current directory for base\n      add next vc15 toolset to the list\n      Revert \"Enable whole program optimization for builds without PGO, too\"\n      extend comment\n      cleanup discontinued target\n\ncommit a32a3fb67cd03b9cdab8cd15f133ef55e717408d\nMerge: 2722dbf 5fb2abd\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Thu Jul 13 15:56:14 2017 +0300\n\n    Merge branch 'master' into sccp\n\n    * master:\n      fix fold\n      Fixed bug #74866 extension_dir = \"./ext\" now use current directory for base\n      add next vc15 toolset to the list\n      Revert \"Enable whole program optimization for builds without PGO, too\"\n      extend comment\n      cleanup discontinued target\n\ncommit 624f76df48db42f616bdfd02e9b26515a97c68e2\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Thu Jul 13 12:30:27 2017 +0300\n\n    Set RETURN_VALUE_UNUSED instead of additional FREE opcode, if possible.\n    Keep alive dead instructions that have to free two temporary variables.\n\ncommit 94c9b26695702e863ebeb40fa3cce5f5f2db7744\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Thu Jul 13 11:51:14 2017 +0300\n\n    More accurate \"vararg\" handling in DCE\n\ncommit 665ed8491ca07cd6d3363abf42c5777e132a3da1\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Thu Jul 13 09:31:45 2017 +0300\n\n    Improved DCE performance, by avoiding redundand checks and repeatable iterations.\n\ncommit 3f42ce18ba4420aabb9b07b838096cce340d06b7\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 12 23:03:11 2017 +0300\n\n    Added few more instructions without side effects and exceptions\n\ncommit b17178f991c095d9137c1536b53b933208e575bf\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 12 20:39:02 2017 +0300\n\n    Temprary enable SSA validation in DEBUG build\n\ncommit e238a8dc79debcf2f833e07323f975173aec6205\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 12 20:37:53 2017 +0300\n\n    Inegrate SSA validation developed by Nikita\n\ncommit a247cee80b47ca335162e8bd46d06274f8af5a4d\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 12 20:31:27 2017 +0300\n\n    Perform DCE pass before other DFA optimisations, to properly reconstruct \"no value\" use-def chains.\n\ncommit a651564f299e3b413af1146149de0d7eec0dfb28\nMerge: 06f6eb0 2722dbf\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 12 18:55:05 2017 +0300\n\n    Merge branch 'sccp' into dce\n\n    * sccp:\n      Resources should be closed during object destructioin, not during freeing.\n      Guard against AppVeyor losing deps issue\n      increase poll timeout as false positives mitigation\n      Value of EG(user_exception_handler) should't relive request boundary\n      sodium ext: remove function names before exception messages\n      sodium ext: update the crypto_kx_*() API to the libsodium one\n      Revert \"fix macro redifinitions\"\n\ncommit 2722dbfdf54702c8b429ed792e96f91219031eb6\nMerge: 6595ea3 09d3b73\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 12 18:54:48 2017 +0300\n\n    Merge branch 'master' into sccp\n\n    * master:\n      Resources should be closed during object destructioin, not during freeing.\n      Guard against AppVeyor losing deps issue\n      increase poll timeout as false positives mitigation\n      Value of EG(user_exception_handler) should't relive request boundary\n      sodium ext: remove function names before exception messages\n      sodium ext: update the crypto_kx_*() API to the libsodium one\n      Revert \"fix macro redifinitions\"\n\ncommit 06f6eb0e6877d8b26c621f5627587539ebcc781f\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 12 14:52:28 2017 +0300\n\n    Use zend_ssa_is_no_val_use() instead of zend_has_improper_op1_use()\n\ncommit 4b64dbb30d519be359c44ad4f3802e93a7f5fa65\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 12 13:07:14 2017 +0300\n\n    Check if instruction may throw exception only for instructions without known side effects.\n    Always disable removing ASSIGN and UNSET_VAR that may throw.\n\ncommit c5aa1f47cd16290c77fb988504dc0dd8bad242a3\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 12 11:21:07 2017 +0300\n\n    Use existing bit\n\ncommit c2af153baea6e05401f78a856a8ae436e5f37bf9\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 12 11:10:48 2017 +0300\n\n    Updated Windows build\n\ncommit de5e8fc12971e55c81b0768daa96adcd6074038e\nMerge: 8c0de53 6595ea3\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 12 11:10:12 2017 +0300\n\n    Merge branch 'sccp' into dce\n\n    * sccp: (29 commits)\n      Use existing bit\n      Updated Windows build\n      Fixed compilation error\n      Remove debug code\n      We need to check for the length here too, or we crash and no one likes that! :(\n      * Implemented #65187 (exif_read_data/thumbnail: add support for stream resource) * ext/exif now uses FAST_ZPP\n      Remove extraneous configure flag\n      Revert \"remove excessive checks and fix warnings\"\n      parametrize zip names\n      Upgrade bundled PCRE to 8.41\n      Updated NEWS file with LDAP changes\n      Fixed removing all controls by passing an empty array to ldap_set_option\n      Filled in NEWS file with ext/ldap last modifications\n      change order, allow to build as shared extension\n      restore file deleted by mistake in a merge commit\n      Fix segfault in php_stream_context_get_option call\n      remove excessive checks and fix warnings\n      fix macro redifinitions\n      fix symbol availability and ws\n      Remove this for now, as not found\n      ...\n\ncommit 6595ea3420b686d1bfe49fbd5893b6a42115c60b\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 12 10:27:02 2017 +0300\n\n    Use existing bit\n\ncommit f0bfd36cb822dbbe28df827a53a2ed96aa61051f\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 12 10:21:22 2017 +0300\n\n    Updated Windows build\n\ncommit a9bd7c89f28cf99933a4d3d026a6da5f5e3ca0f7\nMerge: d1eb5ed 2b7d3fb\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 12 09:51:32 2017 +0300\n\n    Merge branch 'master' into sccp\n\n    * master: (27 commits)\n      Fixed compilation error\n      Remove debug code\n      We need to check for the length here too, or we crash and no one likes that! :(\n      * Implemented #65187 (exif_read_data/thumbnail: add support for stream resource) * ext/exif now uses FAST_ZPP\n      Remove extraneous configure flag\n      Revert \"remove excessive checks and fix warnings\"\n      parametrize zip names\n      Upgrade bundled PCRE to 8.41\n      Updated NEWS file with LDAP changes\n      Fixed removing all controls by passing an empty array to ldap_set_option\n      Filled in NEWS file with ext/ldap last modifications\n      change order, allow to build as shared extension\n      restore file deleted by mistake in a merge commit\n      Fix segfault in php_stream_context_get_option call\n      remove excessive checks and fix warnings\n      fix macro redifinitions\n      fix symbol availability and ws\n      Remove this for now, as not found\n      fix authors\n      NEWS for Sodium\n      ...\n\ncommit 8c0de53e5f599c83fa03c78931527ab4ff14cf93\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Tue Jul 11 21:54:36 2017 +0300\n\n    Initial integration of Dead Code Elimination (DCE) and unused variable removing passes, originally developed in https://github.com/nikic/php-src/tree/opt, into DFA optimization pass.\n\ncommit d1eb5ede3a2b9a0bf57e06783f7913a6383f5d6d\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Tue Jul 11 12:19:11 2017 +0300\n\n    Proper SSA reconstruction for \"$a = $a;\"\n\ncommit 4872d139b55c22c2325459dba0ee557c708567b5\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Tue Jul 11 11:57:33 2017 +0300\n\n    Replace conditions, that should be always true, by ZEND_ASSERT()\n\ncommit 9915b1f5cd2bdd92d0cc5e90244a90fbef06740b\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Tue Jul 11 11:56:51 2017 +0300\n\n    Fixed pass name\n\ncommit d26ff1b88d3b3b1e8742f2e7812ae5e2531958a6\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Tue Jul 11 11:55:47 2017 +0300\n\n    Don't create identical predecessors\n\ncommit 0625fbe32bd66b7bcca29e65b131f0cfccd3e074\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Tue Jul 11 09:36:07 2017 +0300\n\n    Update unreachable blocks.\n\ncommit 9d7d409e6abda5c2e13458f01b8133095fb68531\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Tue Jul 11 09:28:49 2017 +0300\n\n    Keep consistent cfg.map[]\n\ncommit 85a86e58b220eaf2012f652b97fbeb2d2f85646d\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Tue Jul 11 02:36:14 2017 +0300\n\n    Remove unusded phi\n\ncommit d5e0f2df4c76656bbe5973e69e12e1b7415de5ee\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Tue Jul 11 02:35:00 2017 +0300\n\n    Don't clear phi->spources[] too early.\n\ncommit a90ed34295a0bab09c00bb7001a368a858a38399\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Mon Jul 10 21:29:39 2017 +0300\n\n    Make SCCP to remove dead live ranges.\n\ncommit 320237f3d84b872dfa096b9a604ae4d5b4d28c8e\nMerge: 63bbed5 7be2637\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Mon Jul 10 17:35:21 2017 +0300\n\n    Merge branch 'master' into sccp\n\n    * master:\n      Fixed memory leak introduced by 7cb5bdf64a95bd70623d33d6ea122c13b01113bd\n      eliminate casts\n      remove checks for eol dependencies\n      improve test\n      Small fix in ext/ldap, Moved vars definitions to the beginning of the block using them\n      ZipArchive implements countable, added ZipArchive::count() method\n\ncommit 63bbed5e71432d14217b591de511f09937a3c00c\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Mon Jul 10 17:01:15 2017 +0300\n\n    Evaluation of few more constant functions\n\ncommit 07f45d8a3dbfa67bc28c9ef4bb14c753816f4e44\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Mon Jul 10 16:22:47 2017 +0300\n\n    Properly unlinking dead blocks from predecessors/successors and dominators\n\ncommit 502002aa6e11452ed27829f7e29604b27fc69ad2\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Mon Jul 10 13:33:14 2017 +0300\n\n    Replacel constant JMPZ/NZ/ZNZ by JMP or NOP\n\ncommit 3253e61b66b3aa324115ec57ff1cb271ca27dc14\nMerge: e7f69f0 161c378\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Mon Jul 10 12:22:39 2017 +0300\n\n    Merge branch 'master' into sccp\n\n    * master:\n      Revert \"Fixed bug #74878\"\n      Upgrading note for #74837\n      Fixed bug #74837 - NEWS\n      Implement Countable for DomNodeList and DOMNamedNodeMap (Request #74837)\n      Fix #49649 - Handle property visibility changes on unserialization\n\ncommit e7f69f07fc649692218d01dab34b8f8555a6f88c\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Mon Jul 10 12:15:08 2017 +0300\n\n    Prevent compile-time evaluation of implode() with arguments causing run-time warnings\n\ncommit 0e882f189a01b6ee648420776fb473c1efd22380\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Mon Jul 10 11:54:04 2017 +0300\n\n    Constant evaluation of ini_get() for some safe cases\n\ncommit 9e36a748b28850bd15ac621879e1d28ed8e36169\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Mon Jul 10 11:13:37 2017 +0300\n\n    Constant evaluation of implode()\n\ncommit e73046e266617ae23caa7f40344fc6e8e41e3c56\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Mon Jul 10 10:51:23 2017 +0300\n\n    Fixed uninitialized value\n\ncommit f5e2e8e68cc46cfc1380d000672d01b243ad7f59\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Mon Jul 10 10:05:37 2017 +0300\n\n    Remove (compact) unused constants after SCCP pass\n\ncommit f0b7bb86ebe93373a02ef36029f76239ba9ec1d4\nMerge: e69d4f6 cfacf84\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Mon Jul 10 09:10:00 2017 +0300\n\n    Merge branch 'master' into sccp\n\n    * master: (37 commits)\n      #73594 tests only check the extra params if dns_get_record is successful\n      Fixed bug #74852 (property_exists returns true on unknown DateInterval property)\n      fix uninitialized var\n      fix comparison warning\n      comply with POSIX signature\n      fix warning\n      remove some casts\n      cleanup casts\n      remove useless cast\n      eliminate casts\n      sync vim mode lines in main\n      [ci skip] update NEWS\n      [ci skip] update NEWS\n      [ci skip] update NEWS\n      Fixed bug #74883 SQLite3::__construct() produces \"out of memory\" exception with invalid flags\n      Silent compiler warning\n      Fix test\n      Deprecated the read_exif_data() alias\n      Add myself as exif maintainer\n      update libs versions\n      ...\n\ncommit e69d4f61409c473ae36d85c3779ad5f786fecdc0\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 7 12:51:41 2017 +0300\n\n    Avoid in-place modification of referenced data\n\ncommit 58f7c17978dec7b5fe6fe80b4efc55e2168bab61\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 7 12:33:24 2017 +0300\n\n    Use arena for temporary data.\n\ncommit 93d3e7ddc22f1bc7323abae2256b0b50bc1f8b29\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 7 11:54:47 2017 +0300\n\n    Made sccp_ctx to be an \"extension\" of scdf_ctx and remove duplicate data.\n\ncommit f810c6f7c47b03412c61878b761e1bb687fbcf28\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 7 11:20:48 2017 +0300\n\n    Improved SSCP integration\n\ncommit d17ed887f304af0f6ccba76a3dbfca888867ea01\nMerge: d90805a 29653da\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Fri Jul 7 10:22:37 2017 +0300\n\n    Merge branch 'master' into sccp\n\n    * master:\n      Fixed bug #74873 (Minor BC break: PCRE_JIT changes output of preg_match()).\n      Fixed bug #72324 (imap_mailboxmsginfo() return wrong size)\n      Fix redefine warnings\n      Expand sb's name and capitalize my own\n      Write the URL on a new line, so that it is easier copyable\n\ncommit d90805a40bd5d75d197f7b95c69680f636932868\nMerge: 2e5e03b fc336c7\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Thu Jul 6 23:07:04 2017 +0300\n\n    Merge branch 'master' into sccp\n\n    * master:\n      Added missed dump of \"main\" script code\n      replace the stack var by a macro\n      [ci skip] sync NEWS\n      minor fix for web announce\n      add missing NEWS entry for #74087 and also fix the formatting\n      move NEWS entry to the correct place, also bump the version\n\ncommit 2e5e03b673cb86ee0fa6be06496553fa6b8c52e7\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Thu Jul 6 23:03:41 2017 +0300\n\n    Call info should be removed, but at least we should prevent incorrect stack adjustment.\n\ncommit 1ee9110b35eab79f74d08278c104c92796740fa7\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Thu Jul 6 19:34:43 2017 +0300\n\n    Remove NOP instructions, introduced bvy SCCP.\n    This commit discloses unrelated issue caused ext/soap/tests/bug70211.phpt failure.\n\ncommit 9a2f50070d1afde8ee4784a1dade2537e1ac30d5\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Thu Jul 6 16:34:02 2017 +0300\n\n    Avoid useless iterations for first SSA variablesi, always marked BOT.\n\ncommit c57dd7c6efb98c89a8c87af0eaad76b71c9cda16\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Thu Jul 6 16:33:46 2017 +0300\n\n    Use reference-counting\n\ncommit 90f822d68ef1cb68befa3fff289c9e8d1b2068c8\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Thu Jul 6 14:00:22 2017 +0300\n\n    Support for few more opcodes\n\ncommit cffee2f7e5bb4198e645e291fafe5690443cf26c\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Thu Jul 6 12:35:13 2017 +0300\n\n    Combined constants substitutaion and dead instruction removing in single pass. This eleminates substitution in dead instructions.\n\ncommit f890375c16052a9d79bf77c9021914cb9c6616f8\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Thu Jul 6 10:34:48 2017 +0300\n\n    Use reference-counting instead of duplication\n\ncommit db0cd64dfa7a2ff809b49a049074b5fa39d37314\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Thu Jul 6 03:04:27 2017 +0300\n\n    Improved SCDF<->SCCP interface\n\n     - \"get_feasible_successors\" callback is changed into \"mark_feasible_successors\" and should mark necessary edges through scdf_mark_edge_feasible()\n     - SCDF takes care about OP_DATA instruction\n     - SCDF code is re-arranged to avoid repeatable checks\n\ncommit e0ad5dd48942c71033fad985c591549a35c21ef3\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Thu Jul 6 00:55:40 2017 +0300\n\n    Changed representation of \"feasible_edges\", using one bit per edge.\n\ncommit afee3138fe49588b3967f54bf66375f880a51924\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Thu Jul 6 00:49:56 2017 +0300\n\n    Revert \"Don't propagate unused values\"\n\n    This reverts commit 84e5bfd4304d34e3a7107db71783882013f8de59.\n\ncommit 84e5bfd4304d34e3a7107db71783882013f8de59\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 5 23:39:42 2017 +0300\n\n    Don't propagate unused values\n\ncommit d4f15b95061a8a2303d90e6e54effeb9733f90b7\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 5 23:39:10 2017 +0300\n\n    Don't visit the same Phi twice\n\ncommit 2558311b4d530fb84539db304d03dfeba5eda789\nMerge: 722a59d 7bb4ae5\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 5 21:51:06 2017 +0300\n\n    Merge branch 'master' into sccp\n\n    * master:\n      Fixed final dump \"after optimizer\"\n\ncommit 722a59ddb12e641aea99ca8853ef921c4fdf9819\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 5 21:09:29 2017 +0300\n\n    SCCP doesn't support VERIFY_RETURN_TYPE (ext/opcache/tests/bug73789.phpt failure)\n\ncommit 7084fade4dcb74415f0644d8e207f0fab6c6509d\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 5 20:37:21 2017 +0300\n\n    Fixed SSA reconstruction\n\ncommit 37ec4e0845a5b25fe2b523452d32dba22605d2e3\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 5 19:34:46 2017 +0300\n\n    Disable constant propagation for variables that can be modified indirectly\n\ncommit 4bb9b6526e44c2f324f9a7c08890ab9bdedd639c\nMerge: 6800460 73d5097\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 5 19:17:04 2017 +0300\n\n    Merge branch 'master' into sccp\n\n    * master: (43 commits)\n      Keep information about SSA variables, that may be modified indirectly.\n      Added constants for known ldap controls OID and tests for ldap_get/set_option for controls\n      Added support for controls to ldap_get_option\n      [ci skip] sync NEWS\n      NEWS for oniguruma\n      Patch from the upstream git https://github.com/kkos/oniguruma/issues/60 (CVE-2017-9228)\n      Patch from the upstream git https://github.com/kkos/oniguruma/issues/59 (CVE-2017-9229) b690371bbf97794b4a1d3f295d4fb9a8b05d402d Modified for onig 5.9.6\n      Patch from the upstream git https://github.com/kkos/oniguruma/issues/58 (CVE-2017-9227)\n      Patch from the upstream git https://github.com/kkos/oniguruma/issues/57 (CVE-2017-9224)\n      Patch from the upstream git https://github.com/kkos/oniguruma/issues/55 (CVE-2017-9226) b4bf968ad52afe14e60a2dc8a95d3555c543353a Modified for onig 5.9.6 f015fbdd95f76438cd86366467bb2b39870dd7c6 Modified for onig 5.9.6\n      valid_symbol_table removed\n      Improve fix for #74145\n      Fix wddx\n      Fix tests\n      Fixed bug #74111\n      Fix bug #74603 - use correct buffer size\n      Fix bug #74651 - check EVP_SealInit as it can return -1\n      Update NEWS\n      Fix bug #74087\n      Fixed parsing of strange formats with mixed month/day and time strings\n      ...\n\ncommit 680046086c17b938e0288fca820668a183b86834\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 5 16:14:38 2017 +0300\n\n    Support for few more internal functions evaluation\n\ncommit 74a29468ef14260ea3c210a2d1e3548806c81339\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 5 13:42:55 2017 +0300\n\n    Disabled evaluation of strpos() with empty needle.\n\ncommit e8908946e52127727da9f0dd22a053befe8bf848\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 5 13:17:30 2017 +0300\n\n    Replace calls to in_array() with constant array by IN_ARRAY instruction after SCCP.\n\ncommit 4e8fa2c3dd087a49ba90a3ef8231cc81f0399548\nAuthor: Dmitry Stogov <dmitry@zend.com>\nDate:   Wed Jul 5 00:58:12 2017 +0300\n\n    Initial integration of Sparse Conditional Constant Propagation (SCCP), originally developed in https://github.com/nikic/php-src/tree/opt, into DFA optimization pass.",
        "before_after_code_files": [
          "Zend/zend_bitset.h||Zend/zend_bitset.h",
          "ext/opcache/Optimizer/compact_vars.c||ext/opcache/Optimizer/compact_vars.c",
          "ext/opcache/Optimizer/dce.c||ext/opcache/Optimizer/dce.c",
          "ext/opcache/Optimizer/dfa_pass.c||ext/opcache/Optimizer/dfa_pass.c",
          "ext/opcache/Optimizer/sccp.c||ext/opcache/Optimizer/sccp.c",
          "ext/opcache/Optimizer/scdf.c||ext/opcache/Optimizer/scdf.c",
          "ext/opcache/Optimizer/scdf.h||ext/opcache/Optimizer/scdf.h",
          "ext/opcache/Optimizer/ssa_integrity.c||ext/opcache/Optimizer/ssa_integrity.c",
          "ext/opcache/Optimizer/zend_cfg.c||ext/opcache/Optimizer/zend_cfg.c",
          "ext/opcache/Optimizer/zend_cfg.h||ext/opcache/Optimizer/zend_cfg.h",
          "ext/opcache/Optimizer/zend_inference.c||ext/opcache/Optimizer/zend_inference.c",
          "ext/opcache/Optimizer/zend_inference.h||ext/opcache/Optimizer/zend_inference.h",
          "ext/opcache/Optimizer/zend_optimizer.c||ext/opcache/Optimizer/zend_optimizer.c",
          "ext/opcache/Optimizer/zend_optimizer.h||ext/opcache/Optimizer/zend_optimizer.h",
          "ext/opcache/Optimizer/zend_optimizer_internal.h||ext/opcache/Optimizer/zend_optimizer_internal.h",
          "ext/opcache/Optimizer/zend_ssa.c||ext/opcache/Optimizer/zend_ssa.c",
          "ext/opcache/Optimizer/zend_ssa.h||ext/opcache/Optimizer/zend_ssa.h",
          "ext/opcache/config.m4||ext/opcache/config.m4",
          "ext/opcache/config.w32||ext/opcache/config.w32",
          "ext/opcache/tests/ssa_bug_007.phpt||ext/opcache/tests/ssa_bug_007.phpt"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Zend/zend_bitset.h||Zend/zend_bitset.h": [
          "File: Zend/zend_bitset.h -> Zend/zend_bitset.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "245:  } \\",
          "246: } while (0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "248: static inline int zend_bitset_pop_first(zend_bitset set, uint32_t len) {",
          "249:  int i = zend_bitset_first(set, len);",
          "250:  if (i >= 0) {",
          "251:   zend_bitset_excl(set, i);",
          "252:  }",
          "253:  return i;",
          "254: }",
          "",
          "---------------"
        ],
        "ext/opcache/Optimizer/compact_vars.c||ext/opcache/Optimizer/compact_vars.c": [
          "File: ext/opcache/Optimizer/compact_vars.c -> ext/opcache/Optimizer/compact_vars.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2:    +----------------------------------------------------------------------+",
          "3:    | Zend Engine, Removing unused variables                               |",
          "4:    +----------------------------------------------------------------------+",
          "5:    | Copyright (c) 1998-2017 The PHP Group                                |",
          "6:    +----------------------------------------------------------------------+",
          "7:    | This source file is subject to version 3.01 of the PHP license,      |",
          "8:    | that is bundled with this package in the file LICENSE, and is        |",
          "9:    | available through the world-wide-web at the following url:           |",
          "10:    | http://www.php.net/license/3_01.txt                                  |",
          "11:    | If you did not receive a copy of the PHP license and are unable to   |",
          "12:    | obtain it through the world-wide-web, please send a note to          |",
          "13:    | license@php.net so we can mail you a copy immediately.               |",
          "14:    +----------------------------------------------------------------------+",
          "15:    | Authors: Nikita Popov <nikic@php.net>                                |",
          "16:    +----------------------------------------------------------------------+",
          "19: #include \"ZendAccelerator.h\"",
          "20: #include \"Optimizer/zend_optimizer_internal.h\"",
          "21: #include \"zend_bitset.h\"",
          "25: void zend_optimizer_compact_vars(zend_op_array *op_array) {",
          "26:  int i;",
          "28:  ALLOCA_FLAG(use_heap1);",
          "29:  ALLOCA_FLAG(use_heap2);",
          "30:  uint32_t used_cvs_len = zend_bitset_len(op_array->last_var);",
          "31:  zend_bitset used_cvs = ZEND_BITSET_ALLOCA(used_cvs_len, use_heap1);",
          "32:  uint32_t *cv_map = do_alloca(op_array->last_var * sizeof(uint32_t), use_heap2);",
          "33:  uint32_t num_cvs, tmp_offset;",
          "36:  zend_bitset_clear(used_cvs, used_cvs_len);",
          "37:  for (i = 0; i < op_array->last; i++) {",
          "38:   zend_op *opline = &op_array->opcodes[i];",
          "39:   if (opline->op1_type == IS_CV) {",
          "40:    zend_bitset_incl(used_cvs, VAR_NUM(opline->op1.var));",
          "41:   }",
          "42:   if (opline->op2_type == IS_CV) {",
          "43:    zend_bitset_incl(used_cvs, VAR_NUM(opline->op2.var));",
          "44:   }",
          "45:   if (opline->result_type == IS_CV) {",
          "46:    zend_bitset_incl(used_cvs, VAR_NUM(opline->result.var));",
          "47:   }",
          "48:  }",
          "50:  num_cvs = 0;",
          "51:  for (i = 0; i < op_array->last_var; i++) {",
          "52:   if (zend_bitset_in(used_cvs, i)) {",
          "53:    cv_map[i] = num_cvs++;",
          "54:   } else {",
          "55:    cv_map[i] = (uint32_t) -1;",
          "56:   }",
          "57:  }",
          "59:  free_alloca(used_cvs, use_heap1);",
          "60:  if (num_cvs == op_array->last_var) {",
          "61:   free_alloca(cv_map, use_heap2);",
          "62:   return;",
          "63:  }",
          "65:  ZEND_ASSERT(num_cvs < op_array->last_var);",
          "66:  tmp_offset = op_array->last_var - num_cvs;",
          "69:  for (i = 0; i < op_array->last; i++) {",
          "70:   zend_op *opline = &op_array->opcodes[i];",
          "71:   if (opline->op1_type == IS_CV) {",
          "72:    opline->op1.var = NUM_VAR(cv_map[VAR_NUM(opline->op1.var)]);",
          "73:   } else if (opline->op1_type & (IS_VAR|IS_TMP_VAR)) {",
          "74:    opline->op1.var -= sizeof(zval) * tmp_offset;",
          "75:   }",
          "76:   if (opline->op2_type == IS_CV) {",
          "77:    opline->op2.var = NUM_VAR(cv_map[VAR_NUM(opline->op2.var)]);",
          "78:   } else if (opline->op2_type & (IS_VAR|IS_TMP_VAR)) {",
          "79:    opline->op2.var -= sizeof(zval) * tmp_offset;",
          "80:   }",
          "81:   if (opline->result_type == IS_CV) {",
          "82:    opline->result.var = NUM_VAR(cv_map[VAR_NUM(opline->result.var)]);",
          "83:   } else if (opline->result_type & (IS_VAR|IS_TMP_VAR)) {",
          "84:    opline->result.var -= sizeof(zval) * tmp_offset;",
          "85:   }",
          "86:  }",
          "89:  if (op_array->live_range) {",
          "90:   for (i = 0; i < op_array->last_live_range; i++) {",
          "91:    op_array->live_range[i].var -= sizeof(zval) * tmp_offset;",
          "92:   }",
          "93:  }",
          "96:  {",
          "97:   zend_string **names = safe_emalloc(sizeof(zend_string *), num_cvs, 0);",
          "98:   for (i = 0; i < op_array->last_var; i++) {",
          "99:    if (cv_map[i] != (uint32_t) -1) {",
          "100:     names[cv_map[i]] = op_array->vars[i];",
          "101:    } else {",
          "102:     zend_string_release(op_array->vars[i]);",
          "103:    }",
          "104:   }",
          "105:   efree(op_array->vars);",
          "106:   op_array->vars = names;",
          "107:  }",
          "109:  op_array->last_var = num_cvs;",
          "111:  free_alloca(cv_map, use_heap2);",
          "112: }",
          "",
          "---------------"
        ],
        "ext/opcache/Optimizer/dce.c||ext/opcache/Optimizer/dce.c": [
          "File: ext/opcache/Optimizer/dce.c -> ext/opcache/Optimizer/dce.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2:    +----------------------------------------------------------------------+",
          "3:    | Zend Engine, DCE - Dead Code Elimination                             |",
          "4:    +----------------------------------------------------------------------+",
          "5:    | Copyright (c) 1998-2017 The PHP Group                                |",
          "6:    +----------------------------------------------------------------------+",
          "7:    | This source file is subject to version 3.01 of the PHP license,      |",
          "8:    | that is bundled with this package in the file LICENSE, and is        |",
          "9:    | available through the world-wide-web at the following url:           |",
          "10:    | http://www.php.net/license/3_01.txt                                  |",
          "11:    | If you did not receive a copy of the PHP license and are unable to   |",
          "12:    | obtain it through the world-wide-web, please send a note to          |",
          "13:    | license@php.net so we can mail you a copy immediately.               |",
          "14:    +----------------------------------------------------------------------+",
          "15:    | Authors: Nikita Popov <nikic@php.net>                                |",
          "16:    +----------------------------------------------------------------------+",
          "19: #include \"ZendAccelerator.h\"",
          "20: #include \"Optimizer/zend_optimizer_internal.h\"",
          "21: #include \"Optimizer/zend_inference.h\"",
          "22: #include \"Optimizer/zend_ssa.h\"",
          "23: #include \"Optimizer/zend_func_info.h\"",
          "24: #include \"Optimizer/zend_call_graph.h\"",
          "25: #include \"zend_bitset.h\"",
          "47: typedef struct {",
          "48:  zend_ssa *ssa;",
          "49:  zend_op_array *op_array;",
          "50:  zend_bitset instr_dead;",
          "51:  zend_bitset phi_dead;",
          "52:  zend_bitset instr_worklist;",
          "53:  zend_bitset phi_worklist;",
          "54:  zend_bitset phi_worklist_no_val;",
          "55:  uint32_t instr_worklist_len;",
          "56:  uint32_t phi_worklist_len;",
          "57:  unsigned reorder_dtor_effects : 1;",
          "58: } context;",
          "60: static inline zend_bool is_bad_mod(const zend_ssa *ssa, int use, int def) {",
          "61:  if (def < 0) {",
          "63:   return 1;",
          "64:  }",
          "65:  if (ssa->var_info[use].type & MAY_BE_REF) {",
          "67:   return 1;",
          "68:  }",
          "69:  return 0;",
          "70: }",
          "72: static inline zend_bool may_have_side_effects(",
          "73:   zend_op_array *op_array, zend_ssa *ssa,",
          "74:   const zend_op *opline, const zend_ssa_op *ssa_op,",
          "75:   zend_bool reorder_dtor_effects) {",
          "76:  switch (opline->opcode) {",
          "77:   case ZEND_NOP:",
          "78:   case ZEND_IS_IDENTICAL:",
          "79:   case ZEND_IS_NOT_IDENTICAL:",
          "80:   case ZEND_QM_ASSIGN:",
          "81:   case ZEND_FREE:",
          "82:   case ZEND_TYPE_CHECK:",
          "83:   case ZEND_DEFINED:",
          "84:   case ZEND_ADD:",
          "85:   case ZEND_SUB:",
          "86:   case ZEND_MUL:",
          "87:   case ZEND_POW:",
          "88:   case ZEND_BW_OR:",
          "89:   case ZEND_BW_AND:",
          "90:   case ZEND_BW_XOR:",
          "91:   case ZEND_CONCAT:",
          "92:   case ZEND_FAST_CONCAT:",
          "93:   case ZEND_DIV:",
          "94:   case ZEND_MOD:",
          "95:   case ZEND_BOOL_XOR:",
          "96:   case ZEND_BOOL:",
          "97:   case ZEND_BOOL_NOT:",
          "98:   case ZEND_BW_NOT:",
          "99:   case ZEND_SL:",
          "100:   case ZEND_SR:",
          "101:   case ZEND_IS_EQUAL:",
          "102:   case ZEND_IS_NOT_EQUAL:",
          "103:   case ZEND_IS_SMALLER:",
          "104:   case ZEND_IS_SMALLER_OR_EQUAL:",
          "105:   case ZEND_CASE:",
          "106:   case ZEND_CAST:",
          "107:   case ZEND_ROPE_INIT:",
          "108:   case ZEND_ROPE_ADD:",
          "109:   case ZEND_ROPE_END:",
          "110:   case ZEND_INIT_ARRAY:",
          "111:   case ZEND_ADD_ARRAY_ELEMENT:",
          "112:   case ZEND_SPACESHIP:",
          "113:   case ZEND_STRLEN:",
          "114:   case ZEND_COUNT:",
          "115:   case ZEND_GET_TYPE:",
          "116:   case ZEND_ISSET_ISEMPTY_THIS:",
          "117:   case ZEND_ISSET_ISEMPTY_DIM_OBJ:",
          "118:   case ZEND_FETCH_DIM_IS:",
          "119:   case ZEND_ISSET_ISEMPTY_VAR:",
          "120:   case ZEND_FETCH_IS:",
          "122:    return 0;",
          "123:   case ZEND_JMP:",
          "124:   case ZEND_JMPZ:",
          "125:   case ZEND_JMPNZ:",
          "126:   case ZEND_JMPZNZ:",
          "127:   case ZEND_JMPZ_EX:",
          "128:   case ZEND_JMPNZ_EX:",
          "129:   case ZEND_JMP_SET:",
          "130:   case ZEND_COALESCE:",
          "131:   case ZEND_ASSERT_CHECK:",
          "133:    return 1;",
          "134:   case ZEND_BEGIN_SILENCE:",
          "135:   case ZEND_END_SILENCE:",
          "136:   case ZEND_ECHO:",
          "137:   case ZEND_INCLUDE_OR_EVAL:",
          "138:   case ZEND_THROW:",
          "139:   case ZEND_EXT_STMT:",
          "140:   case ZEND_EXT_FCALL_BEGIN:",
          "141:   case ZEND_EXT_FCALL_END:",
          "142:   case ZEND_EXT_NOP:",
          "143:   case ZEND_TICKS:",
          "144:   case ZEND_YIELD:",
          "145:   case ZEND_YIELD_FROM:",
          "147:    return 1;",
          "148:   case ZEND_DO_FCALL:",
          "149:   case ZEND_DO_FCALL_BY_NAME:",
          "150:   case ZEND_DO_ICALL:",
          "151:   case ZEND_DO_UCALL:",
          "153:    return 1;",
          "154:   case ZEND_RECV:",
          "155:   case ZEND_RECV_INIT:",
          "158:    return 1;",
          "159:   case ZEND_ASSIGN_REF:",
          "160:    return 1;",
          "161:   case ZEND_ASSIGN:",
          "162:   {",
          "163:    if (is_bad_mod(ssa, ssa_op->op1_use, ssa_op->op1_def)) {",
          "164:     return 1;",
          "165:    }",
          "166:    if (!reorder_dtor_effects) {",
          "167:     if (opline->op2_type != IS_CONST && (OP2_INFO() & MAY_HAVE_DTOR)) {",
          "169:      return 1;",
          "170:     }",
          "171:    }",
          "172:    return 0;",
          "173:   }",
          "174:   case ZEND_UNSET_VAR:",
          "175:   {",
          "176:    uint32_t t1 = OP1_INFO();",
          "177:    if (!(opline->extended_value & ZEND_QUICK_SET)) {",
          "178:     return 1;",
          "179:    }",
          "180:    if (t1 & MAY_BE_REF) {",
          "185:     return 1;",
          "186:    }",
          "187:    return 0;",
          "188:   }",
          "189:   case ZEND_PRE_INC:",
          "190:   case ZEND_POST_INC:",
          "191:   case ZEND_PRE_DEC:",
          "192:   case ZEND_POST_DEC:",
          "193:    return is_bad_mod(ssa, ssa_op->op1_use, ssa_op->op1_def);",
          "194:   case ZEND_ASSIGN_ADD:",
          "195:   case ZEND_ASSIGN_SUB:",
          "196:   case ZEND_ASSIGN_MUL:",
          "197:   case ZEND_ASSIGN_DIV:",
          "198:   case ZEND_ASSIGN_MOD:",
          "199:   case ZEND_ASSIGN_SL:",
          "200:   case ZEND_ASSIGN_SR:",
          "201:   case ZEND_ASSIGN_CONCAT:",
          "202:   case ZEND_ASSIGN_BW_OR:",
          "203:   case ZEND_ASSIGN_BW_AND:",
          "204:   case ZEND_ASSIGN_BW_XOR:",
          "205:   case ZEND_ASSIGN_POW:",
          "206:    if (opline->extended_value) {",
          "208:     return 1;",
          "209:    }",
          "210:    return is_bad_mod(ssa, ssa_op->op1_use, ssa_op->op1_def);",
          "211:   default:",
          "213:    return 1;",
          "214:  }",
          "215: }",
          "217: static zend_always_inline void add_to_worklists(context *ctx, int var_num, int check) {",
          "218:  zend_ssa_var *var = &ctx->ssa->vars[var_num];",
          "219:  if (var->definition >= 0) {",
          "220:   if (!check || zend_bitset_in(ctx->instr_dead, var->definition)) {",
          "221:    zend_bitset_incl(ctx->instr_worklist, var->definition);",
          "222:   }",
          "223:  } else if (var->definition_phi) {",
          "224:   if (!check || zend_bitset_in(ctx->phi_dead, var_num)) {",
          "225:    zend_bitset_incl(ctx->phi_worklist, var_num);",
          "226:   }",
          "227:  }",
          "228: }",
          "230: static inline void add_to_phi_worklist_no_val(context *ctx, int var_num) {",
          "231:  zend_ssa_var *var = &ctx->ssa->vars[var_num];",
          "232:  if (var->definition_phi && zend_bitset_in(ctx->phi_dead, var_num)) {",
          "233:   zend_bitset_incl(ctx->phi_worklist_no_val, var_num);",
          "234:  }",
          "235: }",
          "237: static zend_always_inline void add_operands_to_worklists(context *ctx, zend_op *opline, zend_ssa_op *ssa_op, int check) {",
          "238:  if (ssa_op->result_use >= 0) {",
          "239:   add_to_worklists(ctx, ssa_op->result_use, check);",
          "240:  }",
          "241:  if (ssa_op->op1_use >= 0) {",
          "242:   if (!zend_ssa_is_no_val_use(opline, ssa_op, ssa_op->op1_use)) {",
          "243:    add_to_worklists(ctx, ssa_op->op1_use, check);",
          "244:   } else {",
          "245:    add_to_phi_worklist_no_val(ctx, ssa_op->op1_use);",
          "246:   }",
          "247:  }",
          "248:  if (ssa_op->op2_use >= 0) {",
          "249:   if (!zend_ssa_is_no_val_use(opline, ssa_op, ssa_op->op2_use)) {",
          "250:    add_to_worklists(ctx, ssa_op->op2_use, check);",
          "251:   } else {",
          "252:    add_to_phi_worklist_no_val(ctx, ssa_op->op2_use);",
          "253:   }",
          "254:  }",
          "255: }",
          "257: static zend_always_inline void add_phi_sources_to_worklists(context *ctx, zend_ssa_phi *phi, int check) {",
          "258:  zend_ssa *ssa = ctx->ssa;",
          "259:  int source;",
          "260:  FOREACH_PHI_SOURCE(phi, source) {",
          "261:   add_to_worklists(ctx, source, check);",
          "262:  } FOREACH_PHI_SOURCE_END();",
          "263: }",
          "265: static inline zend_bool is_var_dead(context *ctx, int var_num) {",
          "266:  zend_ssa_var *var = &ctx->ssa->vars[var_num];",
          "267:  if (var->definition_phi) {",
          "268:   return zend_bitset_in(ctx->phi_dead, var_num);",
          "269:  } else if (var->definition >= 0) {",
          "270:   return zend_bitset_in(ctx->instr_dead, var->definition);",
          "271:  } else {",
          "275:   return var_num >= ctx->op_array->last_var;",
          "276:  }",
          "277: }",
          "280: static zend_bool try_remove_var_def(context *ctx, int free_var, int use_chain, zend_op *opline) {",
          "281:  if (use_chain >= 0) {",
          "282:   return 0;",
          "283:  }",
          "284:  zend_ssa_var *var = &ctx->ssa->vars[free_var];",
          "285:  int def = var->definition;",
          "287:  if (def >= 0) {",
          "288:   zend_ssa_op *def_op = &ctx->ssa->ops[def];",
          "290:   if (def_op->result_def == free_var",
          "291:     && var->phi_use_chain == NULL",
          "292:     && var->use_chain == (opline - ctx->op_array->opcodes)) {",
          "293:    zend_op *def_opline = &ctx->op_array->opcodes[def];",
          "295:    switch (def_opline->opcode) {",
          "296:     case ZEND_ASSIGN:",
          "297:     case ZEND_ASSIGN_REF:",
          "298:     case ZEND_ASSIGN_DIM:",
          "299:     case ZEND_ASSIGN_OBJ:",
          "300:     case ZEND_ASSIGN_ADD:",
          "301:     case ZEND_ASSIGN_SUB:",
          "302:     case ZEND_ASSIGN_MUL:",
          "303:     case ZEND_ASSIGN_DIV:",
          "304:     case ZEND_ASSIGN_MOD:",
          "305:     case ZEND_ASSIGN_SL:",
          "306:     case ZEND_ASSIGN_SR:",
          "307:     case ZEND_ASSIGN_CONCAT:",
          "308:     case ZEND_ASSIGN_BW_OR:",
          "309:     case ZEND_ASSIGN_BW_AND:",
          "310:     case ZEND_ASSIGN_BW_XOR:",
          "311:     case ZEND_ASSIGN_POW:",
          "312:     case ZEND_PRE_INC:",
          "313:     case ZEND_POST_INC:",
          "314:     case ZEND_PRE_DEC:",
          "315:     case ZEND_POST_DEC:",
          "316:     case ZEND_PRE_INC_OBJ:",
          "317:     case ZEND_POST_INC_OBJ:",
          "318:     case ZEND_PRE_DEC_OBJ:",
          "319:     case ZEND_POST_DEC_OBJ:",
          "320:     case ZEND_DO_ICALL:",
          "321:     case ZEND_DO_UCALL:",
          "322:     case ZEND_DO_FCALL_BY_NAME:",
          "323:     case ZEND_DO_FCALL:",
          "324:     case ZEND_INCLUDE_OR_EVAL:",
          "325:     case ZEND_YIELD:",
          "326:     case ZEND_YIELD_FROM:",
          "327:     case ZEND_ASSERT_CHECK:",
          "328:      def_opline->result_type = IS_UNUSED;",
          "329:      def_opline->result.var = 0;",
          "330:      def_op->result_def = -1;",
          "331:      var->definition = -1;",
          "332:      return 1;",
          "333:     default:",
          "334:      break;",
          "335:    }",
          "336:   }",
          "337:  }",
          "338:  return 0;",
          "339: }",
          "342: static zend_bool dce_instr(context *ctx, zend_op *opline, zend_ssa_op *ssa_op) {",
          "343:  zend_ssa *ssa = ctx->ssa;",
          "344:  int free_var = -1;",
          "345:  zend_uchar free_var_type;",
          "347:  if (opline->opcode == ZEND_NOP) {",
          "348:   return 0;",
          "349:  }",
          "352:  if (opline->opcode == ZEND_FREE && !is_var_dead(ctx, ssa_op->op1_use)) {",
          "353:   return 0;",
          "354:  }",
          "356:  if ((opline->op1_type & (IS_VAR|IS_TMP_VAR)) && !is_var_dead(ctx, ssa_op->op1_use)) {",
          "357:   if (!try_remove_var_def(ctx, ssa_op->op1_use, ssa_op->op1_use_chain, opline)) {",
          "358:    free_var = ssa_op->op1_use;",
          "359:    free_var_type = opline->op1_type;",
          "360:   }",
          "361:  }",
          "362:  if ((opline->op2_type & (IS_VAR|IS_TMP_VAR)) && !is_var_dead(ctx, ssa_op->op2_use)) {",
          "363:   if (!try_remove_var_def(ctx, ssa_op->op2_use, ssa_op->op2_use_chain, opline)) {",
          "364:    if (free_var >= 0) {",
          "366:     zend_bitset_excl(ctx->instr_dead, opline - ctx->op_array->opcodes);",
          "367:     return 0;",
          "368:    }",
          "369:    free_var = ssa_op->op2_use;",
          "370:    free_var_type = opline->op2_type;",
          "371:   }",
          "372:  }",
          "374:  zend_ssa_rename_defs_of_instr(ctx->ssa, ssa_op);",
          "375:  zend_ssa_remove_instr(ctx->ssa, opline, ssa_op);",
          "377:  if (free_var >= 0) {",
          "378:   opline->opcode = ZEND_FREE;",
          "379:   opline->op1.var = (uintptr_t) ZEND_CALL_VAR_NUM(NULL, ssa->vars[free_var].var);",
          "380:   opline->op1_type = free_var_type;",
          "382:   ssa_op->op1_use = free_var;",
          "383:   ssa_op->op1_use_chain = ssa->vars[free_var].use_chain;",
          "384:   ssa->vars[free_var].use_chain = ssa_op - ssa->ops;",
          "385:   return 0;",
          "386:  }",
          "387:  return 1;",
          "388: }",
          "391: static int simplify_jumps(zend_ssa *ssa, zend_op_array *op_array) {",
          "392:  int removed_ops = 0;",
          "393:  zend_basic_block *block;",
          "394:  FOREACH_BLOCK(block) {",
          "395:   int block_num = block - ssa->cfg.blocks;",
          "396:   zend_op *opline = &op_array->opcodes[block->start + block->len - 1];",
          "397:   zend_ssa_op *ssa_op = &ssa->ops[block->start + block->len - 1];",
          "398:   zval *op1;",
          "400:   if (block->len == 0) {",
          "401:    continue;",
          "402:   }",
          "405:   switch (opline->opcode) {",
          "406:    case ZEND_JMPZ_EX:",
          "407:     ZEND_ASSERT(ssa_op->result_def >= 0);",
          "408:     if (ssa->vars[ssa_op->result_def].use_chain < 0",
          "409:       && ssa->vars[ssa_op->result_def].phi_use_chain == NULL) {",
          "410:      opline->opcode = ZEND_JMPZ;",
          "411:      opline->result_type = IS_UNUSED;",
          "412:      zend_ssa_remove_result_def(ssa, ssa_op);",
          "413:     }",
          "414:     break;",
          "415:    case ZEND_JMPNZ_EX:",
          "416:    case ZEND_JMP_SET:",
          "417:     ZEND_ASSERT(ssa_op->result_def >= 0);",
          "418:     if (ssa->vars[ssa_op->result_def].use_chain < 0",
          "419:       && ssa->vars[ssa_op->result_def].phi_use_chain == NULL) {",
          "420:      opline->opcode = ZEND_JMPNZ;",
          "421:      opline->result_type = IS_UNUSED;",
          "422:      zend_ssa_remove_result_def(ssa, ssa_op);",
          "423:     }",
          "424:     break;",
          "425:   }",
          "428:   switch (opline->opcode) {",
          "429:    case ZEND_JMPZ_EX:",
          "430:    case ZEND_JMPNZ_EX:",
          "431:     if (block->successors_count == 1 && block->successors[0] != block_num + 1) {",
          "432:      opline->opcode = ZEND_BOOL;",
          "433:     }",
          "434:     break;",
          "435:    case ZEND_JMP_SET:",
          "436:    case ZEND_COALESCE:",
          "437:     if (block->successors_count == 1 && block->successors[0] != block_num + 1) {",
          "438:      opline->opcode = ZEND_QM_ASSIGN;",
          "439:     }",
          "440:     break;",
          "441:   }",
          "443:   if (opline->op1_type != IS_CONST) {",
          "444:    continue;",
          "445:   }",
          "448:   op1 = &ZEND_OP1_LITERAL(opline);",
          "449:   switch (opline->opcode) {",
          "450:    case ZEND_JMPZ:",
          "451:     if (!zend_is_true(op1)) {",
          "452:      literal_dtor(op1);",
          "453:      opline->op1_type = IS_UNUSED;",
          "454:      opline->op1.num = opline->op2.num;",
          "455:      opline->opcode = ZEND_JMP;",
          "456:     } else {",
          "457:      MAKE_NOP(opline);",
          "458:      removed_ops++;",
          "459:     }",
          "460:     break;",
          "461:    case ZEND_JMPNZ:",
          "462:     if (zend_is_true(op1)) {",
          "463:      literal_dtor(op1);",
          "464:      opline->op1_type = IS_UNUSED;",
          "465:      opline->op1.num = opline->op2.num;",
          "466:      opline->opcode = ZEND_JMP;",
          "467:     } else {",
          "468:      MAKE_NOP(opline);",
          "469:      removed_ops++;",
          "470:     }",
          "471:     break;",
          "472:    case ZEND_COALESCE:",
          "473:     ZEND_ASSERT(ssa_op->result_def >= 0);",
          "474:     if (ssa->vars[ssa_op->result_def].use_chain >= 0",
          "475:       || ssa->vars[ssa_op->result_def].phi_use_chain != NULL) {",
          "476:      break;",
          "477:     }",
          "479:     zend_ssa_remove_result_def(ssa, ssa_op);",
          "480:     if (Z_TYPE_P(op1) != IS_NULL) {",
          "481:      literal_dtor(op1);",
          "482:      opline->op1_type = IS_UNUSED;",
          "483:      opline->op1.num = opline->op2.num;",
          "484:      opline->opcode = ZEND_JMP;",
          "485:      opline->result_type = IS_UNUSED;",
          "486:     } else {",
          "487:      MAKE_NOP(opline);",
          "488:      removed_ops++;",
          "489:     }",
          "490:     break;",
          "491:   }",
          "492:  } FOREACH_BLOCK_END();",
          "493:  return removed_ops;",
          "494: }",
          "496: static inline int get_common_phi_source(zend_ssa *ssa, zend_ssa_phi *phi) {",
          "497:  int common_source = -1;",
          "498:  int source;",
          "499:  FOREACH_PHI_SOURCE(phi, source) {",
          "500:   if (common_source == -1) {",
          "501:    common_source = source;",
          "502:   } else if (common_source != source && source != phi->ssa_var) {",
          "503:    return -1;",
          "504:   }",
          "505:  } FOREACH_PHI_SOURCE_END();",
          "506:  ZEND_ASSERT(common_source != -1);",
          "507:  return common_source;",
          "508: }",
          "510: static void try_remove_trivial_phi(context *ctx, zend_ssa_phi *phi) {",
          "511:  zend_ssa *ssa = ctx->ssa;",
          "512:  if (phi->pi < 0) {",
          "514:   int common_source = get_common_phi_source(ssa, phi);",
          "515:   if (common_source >= 0) {",
          "516:    zend_ssa_rename_var_uses(ssa, phi->ssa_var, common_source, 1);",
          "517:    zend_ssa_remove_phi(ssa, phi);",
          "518:   }",
          "519:  } else {",
          "523:   if (ssa->vars[phi->ssa_var].use_chain < 0) {",
          "524:    zend_ssa_rename_var_uses_keep_types(ssa, phi->ssa_var, phi->sources[0], 1);",
          "525:    zend_ssa_remove_phi(ssa, phi);",
          "527:  }",
          "528: }",
          "530: static inline zend_bool may_break_varargs(const zend_op_array *op_array, const zend_ssa *ssa, const zend_ssa_op *ssa_op) {",
          "531:  if (ssa_op->op1_def >= 0",
          "532:    && ssa->vars[ssa_op->op1_def].var < op_array->num_args) {",
          "533:   return 1;",
          "534:  }",
          "535:  if (ssa_op->op2_def >= 0",
          "536:    && ssa->vars[ssa_op->op2_def].var < op_array->num_args) {",
          "537:   return 1;",
          "538:  }",
          "539:  if (ssa_op->result_def >= 0",
          "540:    && ssa->vars[ssa_op->result_def].var < op_array->num_args) {",
          "541:   return 1;",
          "542:  }",
          "543:  return 0;",
          "544: }",
          "546: int dce_optimize_op_array(zend_op_array *op_array, zend_ssa *ssa, zend_bool reorder_dtor_effects) {",
          "547:  int i;",
          "548:  zend_ssa_phi *phi;",
          "549:  int removed_ops = 0;",
          "552:  zend_bool has_varargs = ssa->cfg.vararg;",
          "554:  context ctx;",
          "555:  ctx.ssa = ssa;",
          "556:  ctx.op_array = op_array;",
          "557:  ctx.reorder_dtor_effects = reorder_dtor_effects;",
          "560:  ctx.instr_worklist_len = zend_bitset_len(op_array->last);",
          "561:  ctx.instr_worklist = alloca(sizeof(zend_ulong) * ctx.instr_worklist_len);",
          "562:  memset(ctx.instr_worklist, 0, sizeof(zend_ulong) * ctx.instr_worklist_len);",
          "563:  ctx.phi_worklist_len = zend_bitset_len(ssa->vars_count);",
          "564:  ctx.phi_worklist = alloca(sizeof(zend_ulong) * ctx.phi_worklist_len);",
          "565:  memset(ctx.phi_worklist, 0, sizeof(zend_ulong) * ctx.phi_worklist_len);",
          "566:  ctx.phi_worklist_no_val = alloca(sizeof(zend_ulong) * ctx.phi_worklist_len);",
          "567:  memset(ctx.phi_worklist_no_val, 0, sizeof(zend_ulong) * ctx.phi_worklist_len);",
          "570:  ctx.instr_dead = alloca(sizeof(zend_ulong) * ctx.instr_worklist_len);",
          "571:  memset(ctx.instr_dead, 0, sizeof(zend_ulong) * ctx.instr_worklist_len);",
          "572:  ctx.phi_dead = alloca(sizeof(zend_ulong) * ctx.phi_worklist_len);",
          "573:  memset(ctx.phi_dead, 0xff, sizeof(zend_ulong) * ctx.phi_worklist_len);",
          "576:  int b = ssa->cfg.blocks_count;",
          "577:  while (b > 0) {",
          "578:   b--;",
          "579:   zend_basic_block *block = &ssa->cfg.blocks[b];",
          "580:   if (!(block->flags & ZEND_BB_REACHABLE)) {",
          "581:    continue;",
          "582:   }",
          "583:   i = block->start + block->len;",
          "584:   while (i > block->start) {",
          "585:    i--;",
          "587:    if (zend_bitset_in(ctx.instr_worklist, i)) {",
          "588:     zend_bitset_excl(ctx.instr_worklist, i);",
          "589:     add_operands_to_worklists(&ctx, &op_array->opcodes[i], &ssa->ops[i], 0);",
          "590:    } else if (may_have_side_effects(op_array, ssa, &op_array->opcodes[i], &ssa->ops[i], ctx.reorder_dtor_effects)",
          "591:      || zend_may_throw(&op_array->opcodes[i], op_array, ssa)",
          "592:      || (has_varargs && may_break_varargs(op_array, ssa, &ssa->ops[i]))) {",
          "593:     add_operands_to_worklists(&ctx, &op_array->opcodes[i], &ssa->ops[i], 0);",
          "594:    } else {",
          "595:     zend_bitset_incl(ctx.instr_dead, i);",
          "596:    }",
          "598:   }",
          "599:  }",
          "602:  while (!zend_bitset_empty(ctx.instr_worklist, ctx.instr_worklist_len)",
          "603:    || !zend_bitset_empty(ctx.phi_worklist, ctx.phi_worklist_len)) {",
          "604:   while ((i = zend_bitset_pop_first(ctx.instr_worklist, ctx.instr_worklist_len)) >= 0) {",
          "605:    zend_bitset_excl(ctx.instr_dead, i);",
          "606:    add_operands_to_worklists(&ctx, &op_array->opcodes[i], &ssa->ops[i], 1);",
          "607:   }",
          "608:   while ((i = zend_bitset_pop_first(ctx.phi_worklist, ctx.phi_worklist_len)) >= 0) {",
          "609:    zend_bitset_excl(ctx.phi_dead, i);",
          "610:    zend_bitset_excl(ctx.phi_worklist_no_val, i);",
          "611:    add_phi_sources_to_worklists(&ctx, ssa->vars[i].definition_phi, 1);",
          "612:   }",
          "613:  }",
          "616:  ZEND_BITSET_FOREACH(ctx.instr_dead, ctx.instr_worklist_len, i) {",
          "617:   removed_ops += dce_instr(&ctx, &op_array->opcodes[i], &ssa->ops[i]);",
          "618:  } ZEND_BITSET_FOREACH_END();",
          "624:  while ((i = zend_bitset_pop_first(ctx.phi_worklist_no_val, ctx.phi_worklist_len)) >= 0) {",
          "625:   zend_ssa_phi *phi = ssa->vars[i].definition_phi;",
          "626:   int source;",
          "627:   zend_bitset_excl(ctx.phi_dead, i);",
          "628:   FOREACH_PHI_SOURCE(phi, source) {",
          "629:    add_to_phi_worklist_no_val(&ctx, source);",
          "630:   } FOREACH_PHI_SOURCE_END();",
          "631:  }",
          "634:  FOREACH_PHI(phi) {",
          "635:   if (zend_bitset_in(ctx.phi_dead, phi->ssa_var)) {",
          "636:    zend_ssa_remove_uses_of_var(ssa, phi->ssa_var);",
          "637:    zend_ssa_remove_phi(ssa, phi);",
          "638:   } else {",
          "640:    try_remove_trivial_phi(&ctx, phi);",
          "641:   }",
          "642:  } FOREACH_PHI_END();",
          "644:  removed_ops += simplify_jumps(ssa, op_array);",
          "646:  return removed_ops;",
          "647: }",
          "",
          "---------------"
        ],
        "ext/opcache/Optimizer/dfa_pass.c||ext/opcache/Optimizer/dfa_pass.c": [
          "File: ext/opcache/Optimizer/dfa_pass.c -> ext/opcache/Optimizer/dfa_pass.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: #include \"zend_inference.h\"",
          "32: #include \"zend_dump.h\"",
          "34: int zend_dfa_analyze_op_array(zend_op_array *op_array, zend_optimizer_ctx *ctx, zend_ssa *ssa, uint32_t *flags)",
          "35: {",
          "36:  uint32_t build_flags;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "34: #ifndef ZEND_DEBUG_DFA",
          "35: # define ZEND_DEBUG_DFA ZEND_DEBUG",
          "36: #endif",
          "38: #if ZEND_DEBUG_DFA",
          "39: # include \"ssa_integrity.c\"",
          "40: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "87:  }",
          "89:  if (ctx->debug_level & ZEND_DUMP_DFA_SSA) {",
          "91:  }",
          "",
          "[Removed Lines]",
          "90:   zend_dump_op_array(op_array, ZEND_DUMP_SSA, \"before dfa pass\", ssa);",
          "",
          "[Added Lines]",
          "98:   zend_dump_op_array(op_array, ZEND_DUMP_SSA, \"dfa ssa\", ssa);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "153:      if (i != target) {",
          "154:       op_array->opcodes[target] = op_array->opcodes[i];",
          "155:       ssa->ops[target] = ssa->ops[i];",
          "156:      }",
          "157:      target++;",
          "158:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "164:       ssa->cfg.map[target] = b - blocks;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "171:     new_opline = op_array->opcodes + target - 1;",
          "172:     zend_optimizer_migrate_jump(op_array, new_opline, opline);",
          "173:    }",
          "174:   }",
          "175:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "183:   } else {",
          "184:    b->start = target;",
          "185:    b->len = 0;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "319:  return 1;",
          "320: }",
          "323: {",
          "324:  if (ctx->debug_level & ZEND_DUMP_BEFORE_DFA_PASS) {",
          "325:   zend_dump_op_array(op_array, ZEND_DUMP_SSA, \"before dfa pass\", ssa);",
          "",
          "[Removed Lines]",
          "322: void zend_dfa_optimize_op_array(zend_op_array *op_array, zend_optimizer_ctx *ctx, zend_ssa *ssa)",
          "",
          "[Added Lines]",
          "334: int zend_dfa_optimize_calls(zend_op_array *op_array, zend_ssa *ssa)",
          "335: {",
          "336:  zend_func_info *func_info = ZEND_FUNC_INFO(op_array);",
          "337:  int removed_ops = 0;",
          "339:  if (func_info->callee_info) {",
          "340:   zend_call_info *call_info = func_info->callee_info;",
          "342:   do {",
          "343:    if (call_info->caller_call_opline->opcode == ZEND_DO_ICALL",
          "344:     && call_info->callee_func",
          "345:     && ZSTR_LEN(call_info->callee_func->common.function_name) == sizeof(\"in_array\")-1",
          "346:     && memcmp(ZSTR_VAL(call_info->callee_func->common.function_name), \"in_array\", sizeof(\"in_array\")-1) == 0",
          "347:     && (call_info->caller_init_opline->extended_value == 2",
          "348:      || (call_info->caller_init_opline->extended_value == 3",
          "349:       && (call_info->caller_call_opline - 1)->opcode == ZEND_SEND_VAL",
          "350:       && (call_info->caller_call_opline - 1)->op1_type == IS_CONST))) {",
          "352:     zend_op *send_array;",
          "353:     zend_op *send_needly;",
          "354:     zend_bool strict = 0;",
          "356:     if (call_info->caller_init_opline->extended_value == 2) {",
          "357:      send_array = call_info->caller_call_opline - 1;",
          "358:      send_needly = call_info->caller_call_opline - 2;",
          "359:     } else {",
          "360:      if (zend_is_true(CT_CONSTANT_EX(op_array, (call_info->caller_call_opline - 1)->op1.constant))) {",
          "361:       strict = 1;",
          "362:      }",
          "363:      send_array = call_info->caller_call_opline - 2;",
          "364:      send_needly = call_info->caller_call_opline - 3;",
          "365:     }",
          "367:     if (send_array->opcode == ZEND_SEND_VAL",
          "368:      && send_array->op1_type == IS_CONST",
          "369:      && Z_TYPE_P(CT_CONSTANT_EX(op_array, send_array->op1.constant)) == IS_ARRAY",
          "370:      && (send_needly->opcode == ZEND_SEND_VAL",
          "371:       || send_needly->opcode == ZEND_SEND_VAR)",
          "372:        ) {",
          "373:      int ok = 1;",
          "375:      HashTable *src = Z_ARRVAL_P(CT_CONSTANT_EX(op_array, send_array->op1.constant));",
          "376:      HashTable *dst;",
          "377:      zval *val, tmp;",
          "378:      zend_ulong idx;",
          "380:      ZVAL_TRUE(&tmp);",
          "381:      dst = emalloc(sizeof(HashTable));",
          "382:      zend_hash_init(dst, zend_hash_num_elements(src), NULL, ZVAL_PTR_DTOR, 0);",
          "383:      if (strict) {",
          "384:       ZEND_HASH_FOREACH_VAL(src, val) {",
          "385:        if (Z_TYPE_P(val) == IS_STRING) {",
          "386:         zend_hash_add(dst, Z_STR_P(val), &tmp);",
          "387:        } else if (Z_TYPE_P(val) == IS_LONG) {",
          "388:         zend_hash_index_add(dst, Z_LVAL_P(val), &tmp);",
          "389:        } else {",
          "390:         zend_array_destroy(dst);",
          "391:         ok = 0;",
          "392:         break;",
          "393:        }",
          "394:       } ZEND_HASH_FOREACH_END();",
          "395:      } else {",
          "396:       ZEND_HASH_FOREACH_VAL(src, val) {",
          "397:        if (Z_TYPE_P(val) != IS_STRING || ZEND_HANDLE_NUMERIC(Z_STR_P(val), idx)) {",
          "398:         zend_array_destroy(dst);",
          "399:         ok = 0;",
          "400:         break;",
          "401:        }",
          "402:        zend_hash_add(dst, Z_STR_P(val), &tmp);",
          "403:       } ZEND_HASH_FOREACH_END();",
          "404:      }",
          "406:      if (ok) {",
          "407:       uint32_t op_num = send_needly - op_array->opcodes;",
          "408:       zend_ssa_op *ssa_op = ssa->ops + op_num;",
          "410:       if (ssa_op->op1_use >= 0) {",
          "412:        int var_num = ssa_op->op1_use;",
          "413:        zend_ssa_var *var = ssa->vars + var_num;",
          "415:        ZEND_ASSERT(ssa_op->op1_def < 0);",
          "416:        zend_ssa_unlink_use_chain(ssa, op_num, ssa_op->op1_use);",
          "417:        ssa_op->op1_use = -1;",
          "418:        ssa_op->op1_use_chain = -1;",
          "419:        op_num = call_info->caller_call_opline - op_array->opcodes;",
          "420:        ssa_op = ssa->ops + op_num;",
          "421:        ssa_op->op1_use = var_num;",
          "422:        ssa_op->op1_use_chain = var->use_chain;",
          "423:        var->use_chain = op_num;",
          "424:       }",
          "426:       ZVAL_ARR(&tmp, dst);",
          "429:       call_info->caller_call_opline->opcode = ZEND_IN_ARRAY;",
          "430:       call_info->caller_call_opline->extended_value = strict;",
          "431:       call_info->caller_call_opline->op1_type = send_needly->op1_type;",
          "432:       call_info->caller_call_opline->op1.num = send_needly->op1.num;",
          "433:       call_info->caller_call_opline->op2_type = IS_CONST;",
          "434:       call_info->caller_call_opline->op2.constant = zend_optimizer_add_literal(op_array, &tmp);",
          "435:       if (call_info->caller_init_opline->extended_value == 3) {",
          "436:        MAKE_NOP(call_info->caller_call_opline - 1);",
          "437:       }",
          "438:       MAKE_NOP(call_info->caller_init_opline);",
          "439:       MAKE_NOP(send_needly);",
          "440:       MAKE_NOP(send_array);",
          "441:       removed_ops++;",
          "443:      }",
          "444:     }",
          "445:    }",
          "446:    call_info = call_info->next_callee;",
          "447:   } while (call_info);",
          "448:  }",
          "450:  return removed_ops;",
          "451: }",
          "453: void zend_dfa_optimize_op_array(zend_op_array *op_array, zend_optimizer_ctx *ctx, zend_ssa *ssa, zend_call_info **call_map)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "332:   zend_op *opline;",
          "333:   zval tmp;",
          "335:   for (v = op_array->last_var; v < ssa->vars_count; v++) {",
          "337:    op_1 = ssa->vars[v].definition;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "466:   if (ZEND_OPTIMIZER_PASS_8 & ctx->optimization_level) {",
          "467:    if (sccp_optimize_op_array(ctx, op_array, ssa, call_map)) {",
          "468:     remove_nops = 1;",
          "469:    }",
          "470: #if ZEND_DEBUG_DFA",
          "471:    ssa_verify_integrity(op_array, ssa, \"after sccp\");",
          "472: #endif",
          "473:    if (ZEND_FUNC_INFO(op_array)) {",
          "474:     if (zend_dfa_optimize_calls(op_array, ssa)) {",
          "475:      remove_nops = 1;",
          "476:     }",
          "477:    }",
          "478:    if (ctx->debug_level & ZEND_DUMP_AFTER_PASS_8) {",
          "479:     zend_dump_op_array(op_array, ZEND_DUMP_SSA, \"after sccp pass\", ssa);",
          "480:    }",
          "481: #if ZEND_DEBUG_DFA",
          "482:    ssa_verify_integrity(op_array, ssa, \"after calls\");",
          "483: #endif",
          "484:   }",
          "486:   if (ZEND_OPTIMIZER_PASS_14 & ctx->optimization_level) {",
          "487:    if (dce_optimize_op_array(op_array, ssa, 0)) {",
          "488:     remove_nops = 1;",
          "489:    }",
          "490:    if (ctx->debug_level & ZEND_DUMP_AFTER_PASS_14) {",
          "491:     zend_dump_op_array(op_array, ZEND_DUMP_SSA, \"after dce pass\", ssa);",
          "492:    }",
          "493: #if ZEND_DEBUG_DFA",
          "494:    ssa_verify_integrity(op_array, ssa, \"after dce\");",
          "495: #endif",
          "496:   }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "490:       }",
          "491:      }",
          "492:     }",
          "",
          "[Removed Lines]",
          "473:       if (zend_ssa_unlink_use_chain(ssa, op_1, orig_var)) {",
          "475:        ssa->ops[op_1].result_def = v;",
          "476:        ssa->ops[op_1].op1_def = -1;",
          "477:        ssa->ops[op_1].op1_use = ssa->ops[op_1].op2_use;",
          "478:        ssa->ops[op_1].op1_use_chain = ssa->ops[op_1].op2_use_chain;",
          "479:        ssa->ops[op_1].op2_use = -1;",
          "480:        ssa->ops[op_1].op2_use_chain = -1;",
          "483:        opline->result_type = opline->op1_type;",
          "484:        opline->result.var = opline->op1.var;",
          "485:        opline->op1_type = opline->op2_type;",
          "486:        opline->op1.var = opline->op2.var;",
          "487:        opline->op2_type = IS_UNUSED;",
          "488:        opline->op2.var = 0;",
          "489:        opline->opcode = ZEND_QM_ASSIGN;",
          "",
          "[Added Lines]",
          "636:       if (ssa->ops[op_1].op1_use != ssa->ops[op_1].op2_use) {",
          "637:        zend_ssa_unlink_use_chain(ssa, op_1, orig_var);",
          "638:       } else {",
          "639:        ssa->ops[op_1].op2_use_chain = ssa->ops[op_1].op1_use_chain;",
          "643:       ssa->ops[op_1].result_def = v;",
          "644:       ssa->ops[op_1].op1_def = -1;",
          "645:       ssa->ops[op_1].op1_use = ssa->ops[op_1].op2_use;",
          "646:       ssa->ops[op_1].op1_use_chain = ssa->ops[op_1].op2_use_chain;",
          "647:       ssa->ops[op_1].op2_use = -1;",
          "648:       ssa->ops[op_1].op2_use_chain = -1;",
          "651:       opline->result_type = opline->op1_type;",
          "652:       opline->result.var = opline->op1.var;",
          "653:       opline->op1_type = opline->op2_type;",
          "654:       opline->op1.var = opline->op2.var;",
          "655:       opline->op2_type = IS_UNUSED;",
          "656:       opline->op2.var = 0;",
          "657:       opline->opcode = ZEND_QM_ASSIGN;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "577:    }",
          "578:   }",
          "580:   if (remove_nops) {",
          "581:    zend_ssa_remove_nops(op_array, ssa);",
          "582:   }",
          "583:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "747: #if ZEND_DEBUG_DFA",
          "748:   ssa_verify_integrity(op_array, ssa, \"after dfa\");",
          "749: #endif",
          "753: #if ZEND_DEBUG_DFA",
          "754:    ssa_verify_integrity(op_array, ssa, \"after nop\");",
          "755: #endif",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "598:   return;",
          "599:  }",
          "604:  zend_arena_release(&ctx->arena, checkpoint);",
          "",
          "[Removed Lines]",
          "601:  zend_dfa_optimize_op_array(op_array, ctx, &ssa);",
          "",
          "[Added Lines]",
          "775:  zend_dfa_optimize_op_array(op_array, ctx, &ssa, NULL);",
          "",
          "---------------"
        ],
        "ext/opcache/Optimizer/sccp.c||ext/opcache/Optimizer/sccp.c": [
          "File: ext/opcache/Optimizer/sccp.c -> ext/opcache/Optimizer/sccp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2:    +----------------------------------------------------------------------+",
          "3:    | Zend Engine, SCCP - Sparse Conditional Constant Propagation          |",
          "4:    +----------------------------------------------------------------------+",
          "5:    | Copyright (c) 1998-2017 The PHP Group                                |",
          "6:    +----------------------------------------------------------------------+",
          "7:    | This source file is subject to version 3.01 of the PHP license,      |",
          "8:    | that is bundled with this package in the file LICENSE, and is        |",
          "9:    | available through the world-wide-web at the following url:           |",
          "10:    | http://www.php.net/license/3_01.txt                                  |",
          "11:    | If you did not receive a copy of the PHP license and are unable to   |",
          "12:    | obtain it through the world-wide-web, please send a note to          |",
          "13:    | license@php.net so we can mail you a copy immediately.               |",
          "14:    +----------------------------------------------------------------------+",
          "15:    | Authors: Nikita Popov <nikic@php.net>                                |",
          "16:    +----------------------------------------------------------------------+",
          "19: #include \"php.h\"",
          "20: #include \"zend_type_info.h\"",
          "21: #include \"ZendAccelerator.h\"",
          "22: #include \"Optimizer/zend_optimizer_internal.h\"",
          "23: #include \"Optimizer/zend_call_graph.h\"",
          "24: #include \"Optimizer/scdf.h\"",
          "25: #include \"Optimizer/zend_dump.h\"",
          "26: #include \"ext/standard/php_string.h\"",
          "69: #if 0",
          "70: #define SCP_DEBUG(...) php_printf(__VA_ARGS__)",
          "71: #else",
          "72: #define SCP_DEBUG(...)",
          "73: #endif",
          "75: typedef struct _sccp_ctx {",
          "76:  scdf_ctx scdf;",
          "77:  zend_call_info **call_map;",
          "78:  zval *values;",
          "79:  zval top;",
          "80:  zval bot;",
          "81: } sccp_ctx;",
          "83: #define TOP ((zend_uchar)-1)",
          "84: #define BOT ((zend_uchar)-2)",
          "85: #define IS_TOP(zv) (Z_TYPE_P(zv) == TOP)",
          "86: #define IS_BOT(zv) (Z_TYPE_P(zv) == BOT)",
          "88: #define MAKE_TOP(zv) (Z_TYPE_INFO_P(zv) = TOP)",
          "89: #define MAKE_BOT(zv) (Z_TYPE_INFO_P(zv) = BOT)",
          "91: static inline zend_bool value_known(zval *zv) {",
          "92:  return !IS_TOP(zv) && !IS_BOT(zv);",
          "93: }",
          "97: static void set_value(scdf_ctx *scdf, sccp_ctx *ctx, int var, zval *new) {",
          "98:  zval *value = &ctx->values[var];",
          "99:  if (IS_BOT(value) || IS_TOP(new)) {",
          "100:   return;",
          "101:  }",
          "103:  if (IS_BOT(new)) {",
          "104:   SCP_DEBUG(\"Lowering var %d to BOT\\n\", var);",
          "105:  } else {",
          "106:   SCP_DEBUG(\"Lowering var %d to %Z\\n\", var, new);",
          "107:  }",
          "109:  if (IS_TOP(value) || IS_BOT(new)) {",
          "110:   zval_ptr_dtor_nogc(value);",
          "111:   ZVAL_COPY(value, new);",
          "112:   scdf_add_to_worklist(scdf, var);",
          "113:   return;",
          "114:  }",
          "116: #if ZEND_DEBUG",
          "117:  ZEND_ASSERT(zend_is_identical(value, new));",
          "118: #endif",
          "119: }",
          "121: static zval *get_op1_value(sccp_ctx *ctx, zend_op *opline, zend_ssa_op *ssa_op) {",
          "122:  if (opline->op1_type == IS_CONST) {",
          "123:   return CT_CONSTANT_EX(ctx->scdf.op_array, opline->op1.constant);",
          "124:  } else if (ssa_op->op1_use != -1) {",
          "125:   return &ctx->values[ssa_op->op1_use];",
          "126:  } else {",
          "127:   return NULL;",
          "128:  }",
          "129: }",
          "131: static zval *get_op2_value(sccp_ctx *ctx, zend_op *opline, zend_ssa_op *ssa_op) {",
          "132:  if (opline->op2_type == IS_CONST) {",
          "133:   return CT_CONSTANT_EX(ctx->scdf.op_array, opline->op2.constant);",
          "134:  } else if (ssa_op->op2_use != -1) {",
          "135:   return &ctx->values[ssa_op->op2_use];",
          "136:  } else {",
          "137:   return NULL;",
          "138:  }",
          "139: }",
          "141: static zend_bool can_replace_op1(",
          "142:   const zend_op_array *op_array, zend_op *opline, zend_ssa_op *ssa_op) {",
          "143:  switch (opline->opcode) {",
          "144:   case ZEND_PRE_INC:",
          "145:   case ZEND_PRE_DEC:",
          "146:   case ZEND_PRE_INC_OBJ:",
          "147:   case ZEND_PRE_DEC_OBJ:",
          "148:   case ZEND_POST_INC:",
          "149:   case ZEND_POST_DEC:",
          "150:   case ZEND_POST_INC_OBJ:",
          "151:   case ZEND_POST_DEC_OBJ:",
          "152:   case ZEND_ASSIGN:",
          "153:   case ZEND_ASSIGN_REF:",
          "154:   case ZEND_ASSIGN_DIM:",
          "155:   case ZEND_ASSIGN_OBJ:",
          "156:   case ZEND_ASSIGN_ADD:",
          "157:   case ZEND_ASSIGN_SUB:",
          "158:   case ZEND_ASSIGN_MUL:",
          "159:   case ZEND_ASSIGN_DIV:",
          "160:   case ZEND_ASSIGN_MOD:",
          "161:   case ZEND_ASSIGN_SL:",
          "162:   case ZEND_ASSIGN_SR:",
          "163:   case ZEND_ASSIGN_CONCAT:",
          "164:   case ZEND_ASSIGN_BW_OR:",
          "165:   case ZEND_ASSIGN_BW_AND:",
          "166:   case ZEND_ASSIGN_BW_XOR:",
          "167:   case ZEND_ASSIGN_POW:",
          "168:   case ZEND_FETCH_DIM_W:",
          "169:   case ZEND_FETCH_DIM_RW:",
          "170:   case ZEND_FETCH_DIM_UNSET:",
          "171:   case ZEND_FETCH_DIM_FUNC_ARG:",
          "172:   case ZEND_FETCH_OBJ_W:",
          "173:   case ZEND_FETCH_OBJ_RW:",
          "174:   case ZEND_FETCH_OBJ_UNSET:",
          "175:   case ZEND_FETCH_OBJ_FUNC_ARG:",
          "176:   case ZEND_UNSET_DIM:",
          "177:   case ZEND_UNSET_OBJ:",
          "178:   case ZEND_SEND_REF:",
          "179:   case ZEND_SEND_VAR_EX:",
          "180:   case ZEND_SEND_UNPACK:",
          "181:   case ZEND_SEND_ARRAY:",
          "182:   case ZEND_SEND_USER:",
          "183:   case ZEND_FE_RESET_RW:",
          "184:    return 0;",
          "186:   case ZEND_VERIFY_ABSTRACT_CLASS:",
          "187:   case ZEND_ADD_INTERFACE:",
          "188:   case ZEND_ADD_TRAIT:",
          "189:   case ZEND_BIND_TRAITS:",
          "190:   case ZEND_ROPE_ADD:",
          "191:   case ZEND_ROPE_END:",
          "192:   case ZEND_BIND_STATIC:",
          "193:   case ZEND_BIND_GLOBAL:",
          "194:   case ZEND_MAKE_REF:",
          "195:    return 0;",
          "196:   case ZEND_UNSET_VAR:",
          "197:   case ZEND_ISSET_ISEMPTY_VAR:",
          "199:    return (opline->extended_value & ZEND_QUICK_SET) == 0;",
          "200:   case ZEND_INIT_ARRAY:",
          "201:   case ZEND_ADD_ARRAY_ELEMENT:",
          "202:    return !(opline->extended_value & ZEND_ARRAY_ELEMENT_REF);",
          "203:   case ZEND_YIELD:",
          "204:    return !(op_array->fn_flags & ZEND_ACC_RETURN_REFERENCE);",
          "205:   case ZEND_VERIFY_RETURN_TYPE:",
          "207:    return 0;",
          "208:   default:",
          "209:    if (ssa_op->op1_def != -1) {",
          "210:     ZEND_ASSERT(0);",
          "211:     return 0;",
          "212:    }",
          "213:  }",
          "215:  return 1;",
          "216: }",
          "218: static zend_bool can_replace_op2(",
          "219:   const zend_op_array *op_array, zend_op *opline, zend_ssa_op *ssa_op) {",
          "220:  switch (opline->opcode) {",
          "222:   case ZEND_DECLARE_INHERITED_CLASS:",
          "223:   case ZEND_DECLARE_INHERITED_CLASS_DELAYED:",
          "224:   case ZEND_DECLARE_ANON_INHERITED_CLASS:",
          "225:   case ZEND_BIND_LEXICAL:",
          "226:   case ZEND_FE_FETCH_R:",
          "227:   case ZEND_FE_FETCH_RW:",
          "228:    return 0;",
          "229:  }",
          "230:  return 1;",
          "231: }",
          "233: static zend_bool try_replace_op1(",
          "234:   sccp_ctx *ctx, zend_op *opline, zend_ssa_op *ssa_op, int var, zval *value) {",
          "235:  if (ssa_op->op1_use == var && can_replace_op1(ctx->scdf.op_array, opline, ssa_op)) {",
          "236:   zval zv;",
          "237:   ZVAL_COPY(&zv, value);",
          "238:   if (zend_optimizer_update_op1_const(ctx->scdf.op_array, opline, &zv)) {",
          "239:    return 1;",
          "240:   } else {",
          "242:    switch (opline->opcode) {",
          "243:     case ZEND_FETCH_LIST:",
          "244:     case ZEND_CASE:",
          "245:     case ZEND_SWITCH_STRING:",
          "246:     case ZEND_SWITCH_LONG:",
          "247:      if (Z_TYPE(zv) == IS_STRING) {",
          "248:       zend_string_hash_val(Z_STR(zv));",
          "249:      }",
          "250:      opline->op1.constant = zend_optimizer_add_literal(ctx->scdf.op_array, &zv);",
          "251:      opline->op1_type = IS_CONST;",
          "252:      return 1;",
          "253:    }",
          "254:    zval_ptr_dtor_nogc(&zv);",
          "255:   }",
          "256:  }",
          "257:  return 0;",
          "258: }",
          "260: static zend_bool try_replace_op2(",
          "261:   sccp_ctx *ctx, zend_op *opline, zend_ssa_op *ssa_op, int var, zval *value) {",
          "262:  if (ssa_op->op2_use == var && can_replace_op2(ctx->scdf.op_array, opline, ssa_op)) {",
          "263:   zval zv;",
          "264:   ZVAL_COPY(&zv, value);",
          "265:   if (zend_optimizer_update_op2_const(ctx->scdf.op_array, opline, &zv)) {",
          "266:    return 1;",
          "267:   } else {",
          "268:    zval_ptr_dtor_nogc(&zv);",
          "269:   }",
          "270:  }",
          "271:  return 0;",
          "272: }",
          "274: static inline int zval_to_string_offset(zend_long *result, zval *op) {",
          "275:  switch (Z_TYPE_P(op)) {",
          "276:   case IS_LONG:",
          "278:    return SUCCESS;",
          "279:   case IS_STRING:",
          "280:    if (IS_LONG == is_numeric_string(",
          "281:      Z_STRVAL_P(op), Z_STRLEN_P(op), result, NULL, 0)) {",
          "282:     return SUCCESS;",
          "283:    }",
          "284:    return FAILURE;",
          "285:   default:",
          "286:    return FAILURE;",
          "287:  }",
          "288: }",
          "290: static inline int fetch_array_elem(zval **result, zval *op1, zval *op2) {",
          "291:  switch (Z_TYPE_P(op2)) {",
          "292:   case IS_NULL:",
          "294:    return SUCCESS;",
          "295:   case IS_FALSE:",
          "297:    return SUCCESS;",
          "298:   case IS_TRUE:",
          "300:    return SUCCESS;",
          "301:   case IS_LONG:",
          "303:    return SUCCESS;",
          "304:   case IS_DOUBLE:",
          "306:    return SUCCESS;",
          "307:   case IS_STRING:",
          "309:    return SUCCESS;",
          "310:   default:",
          "311:    return FAILURE;",
          "312:  }",
          "313: }",
          "315: static inline int ct_eval_fetch_dim(zval *result, zval *op1, zval *op2, int support_strings) {",
          "316:  if (Z_TYPE_P(op1) == IS_ARRAY) {",
          "317:   zval *value;",
          "318:   if (fetch_array_elem(&value, op1, op2) == SUCCESS && value) {",
          "319:    ZVAL_COPY(result, value);",
          "320:    return SUCCESS;",
          "321:   }",
          "322:  } else if (support_strings && Z_TYPE_P(op1) == IS_STRING) {",
          "323:   zend_long index;",
          "324:   if (zval_to_string_offset(&index, op2) == FAILURE) {",
          "325:    return FAILURE;",
          "326:   }",
          "327:   if (index >= 0 && index < Z_STRLEN_P(op1)) {",
          "328:    ZVAL_STR(result, zend_string_init(&Z_STRVAL_P(op1)[index], 1, 0));",
          "329:    return SUCCESS;",
          "330:   }",
          "331:  }",
          "332:  return FAILURE;",
          "333: }",
          "335: static inline int ct_eval_isset_dim(zval *result, uint32_t extended_value, zval *op1, zval *op2) {",
          "336:  if (Z_TYPE_P(op1) == IS_ARRAY) {",
          "337:   zval *value;",
          "338:   if (fetch_array_elem(&value, op1, op2) == FAILURE) {",
          "339:    return FAILURE;",
          "340:   }",
          "341:   if (extended_value & ZEND_ISSET) {",
          "342:    ZVAL_BOOL(result, value && Z_TYPE_P(value) != IS_NULL);",
          "343:   } else {",
          "344:    ZEND_ASSERT(extended_value & ZEND_ISEMPTY);",
          "345:    ZVAL_BOOL(result, !value || !zend_is_true(value));",
          "346:   }",
          "347:   return SUCCESS;",
          "348:  } else if (Z_TYPE_P(op1) == IS_STRING) {",
          "350:   return FAILURE;",
          "351:  } else {",
          "352:   ZVAL_BOOL(result, extended_value != ZEND_ISSET);",
          "353:   return SUCCESS;",
          "354:  }",
          "355: }",
          "357: static inline int ct_eval_add_array_elem(zval *result, zval *value, zval *key) {",
          "358:  if (!key) {",
          "359:   if ((value = zend_hash_next_index_insert(Z_ARR_P(result), value))) {",
          "360:    Z_TRY_ADDREF_P(value);",
          "361:    return SUCCESS;",
          "362:   }",
          "363:   return FAILURE;",
          "364:  }",
          "366:  switch (Z_TYPE_P(key)) {",
          "367:   case IS_NULL:",
          "368:    value = zend_hash_update(Z_ARR_P(result), ZSTR_EMPTY_ALLOC(), value);",
          "369:    break;",
          "370:   case IS_FALSE:",
          "371:    value = zend_hash_index_update(Z_ARR_P(result), 0, value);",
          "372:    break;",
          "373:   case IS_TRUE:",
          "374:    value = zend_hash_index_update(Z_ARR_P(result), 1, value);",
          "375:    break;",
          "376:   case IS_LONG:",
          "377:    value = zend_hash_index_update(Z_ARR_P(result), Z_LVAL_P(key), value);",
          "378:    break;",
          "379:   case IS_DOUBLE:",
          "380:    value = zend_hash_index_update(",
          "381:     Z_ARR_P(result), zend_dval_to_lval(Z_DVAL_P(key)), value);",
          "382:    break;",
          "383:   case IS_STRING:",
          "384:    value = zend_symtable_update(Z_ARR_P(result), Z_STR_P(key), value);",
          "385:    break;",
          "386:   default:",
          "387:    return FAILURE;",
          "388:  }",
          "390:  Z_TRY_ADDREF_P(value);",
          "391:  return SUCCESS;",
          "392: }",
          "394: static inline int ct_eval_assign_dim(zval *result, zval *value, zval *key) {",
          "395:  switch (Z_TYPE_P(result)) {",
          "396:   case IS_NULL:",
          "397:   case IS_FALSE:",
          "398:    array_init(result);",
          "400:   case IS_ARRAY:",
          "401:    return ct_eval_add_array_elem(result, value, key);",
          "402:   case IS_STRING:",
          "404: #if 0",
          "405:    zend_long index;",
          "406:    zend_string *new_str, *value_str;",
          "407:    if (!key || Z_TYPE_P(value) == IS_ARRAY",
          "408:      || zval_to_string_offset(&index, key) == FAILURE || index < 0) {",
          "409:     return FAILURE;",
          "410:    }",
          "412:    if (index >= Z_STRLEN_P(result)) {",
          "413:     new_str = zend_string_alloc(index + 1, 0);",
          "414:     memcpy(ZSTR_VAL(new_str), Z_STRVAL_P(result), Z_STRLEN_P(result));",
          "415:     memset(ZSTR_VAL(new_str) + Z_STRLEN_P(result), ' ', index - Z_STRLEN_P(result));",
          "416:     ZSTR_VAL(new_str)[index + 1] = 0;",
          "417:    } else {",
          "418:     new_str = zend_string_init(Z_STRVAL_P(result), Z_STRLEN_P(result), 0);",
          "419:    }",
          "421:    value_str = zval_get_string(value);",
          "422:    ZVAL_STR(result, new_str);",
          "423:    Z_STRVAL_P(result)[index] = ZSTR_VAL(value_str)[0];",
          "424:    zend_string_release(value_str);",
          "425: #endif",
          "426:    return FAILURE;",
          "427:   default:",
          "428:    return FAILURE;",
          "429:  }",
          "430: }",
          "432: static inline int ct_eval_incdec(zval *result, zend_uchar opcode, zval *op1) {",
          "433:  ZVAL_COPY(result, op1);",
          "434:  if (opcode == ZEND_PRE_INC || opcode == ZEND_POST_INC) {",
          "435:   increment_function(result);",
          "436:  } else {",
          "437:   decrement_function(result);",
          "438:  }",
          "439:  return SUCCESS;",
          "440: }",
          "442: static inline int ct_eval_isset_isempty(zval *result, uint32_t extended_value, zval *op1) {",
          "443:  if (!(extended_value & ZEND_QUICK_SET)) {",
          "444:   return FAILURE;",
          "445:  }",
          "447:  if (extended_value & ZEND_ISSET) {",
          "448:   ZVAL_BOOL(result, Z_TYPE_P(op1) != IS_NULL);",
          "449:  } else {",
          "450:   ZEND_ASSERT(extended_value & ZEND_ISEMPTY);",
          "451:   ZVAL_BOOL(result, !zend_is_true(op1));",
          "452:  }",
          "453:  return SUCCESS;",
          "454: }",
          "456: static inline void ct_eval_type_check(zval *result, uint32_t type, zval *op1) {",
          "457:  if (type == _IS_BOOL) {",
          "458:   ZVAL_BOOL(result, Z_TYPE_P(op1) == IS_TRUE || Z_TYPE_P(op1) == IS_FALSE);",
          "459:  } else {",
          "460:   ZVAL_BOOL(result, Z_TYPE_P(op1) == type);",
          "461:  }",
          "462: }",
          "467: static inline int ct_eval_func_call(",
          "468:   zval *result, zend_string *name, uint32_t num_args, zval **args) {",
          "469:  uint32_t i;",
          "470:  zend_execute_data *execute_data;",
          "471:  zend_function *func;",
          "472:  int overflow;",
          "474:  if (zend_string_equals_literal(name, \"chr\")) {",
          "475:   zend_long c;",
          "476:   if (num_args != 1 || Z_TYPE_P(args[0]) != IS_LONG) {",
          "477:    return FAILURE;",
          "478:   }",
          "480:   c = Z_LVAL_P(args[0]) & 0xff;",
          "481:   ZVAL_INTERNED_STR(result, ZSTR_CHAR(c));",
          "482:   return SUCCESS;",
          "483:  } else if (zend_string_equals_literal(name, \"count\")) {",
          "484:   if (num_args != 1 || Z_TYPE_P(args[0]) != IS_ARRAY) {",
          "485:    return FAILURE;",
          "486:   }",
          "488:   ZVAL_LONG(result, zend_hash_num_elements(Z_ARRVAL_P(args[0])));",
          "489:   return SUCCESS;",
          "490:  } else if (zend_string_equals_literal(name, \"ini_get\")) {",
          "491:   zend_ini_entry *ini_entry;",
          "493:   if (num_args != 1 || Z_TYPE_P(args[0]) != IS_STRING) {",
          "494:    return FAILURE;",
          "495:   }",
          "497:   ini_entry = zend_hash_find_ptr(EG(ini_directives), Z_STR_P(args[0]));",
          "498:   if (!ini_entry) {",
          "499:    ZVAL_FALSE(result);",
          "500:   } else if (ini_entry->modifiable != ZEND_INI_SYSTEM) {",
          "501:    return FAILURE;",
          "502:   } else if (ini_entry->value) {",
          "503:    ZVAL_STR_COPY(result, ini_entry->value);",
          "504:   } else {",
          "505:    ZVAL_EMPTY_STRING(result);",
          "506:   }",
          "507:   return SUCCESS;",
          "508:  } else if (zend_string_equals_literal(name, \"in_array\")) {",
          "509:   if (num_args != 2 || Z_TYPE_P(args[1]) != IS_ARRAY) {",
          "510:    return FAILURE;",
          "511:   }",
          "513:  } else if (zend_string_equals_literal(name, \"strpos\")) {",
          "514:   if (num_args != 2",
          "515:     || Z_TYPE_P(args[0]) != IS_STRING",
          "516:     || Z_TYPE_P(args[1]) != IS_STRING",
          "517:     || !Z_STRLEN_P(args[1])) {",
          "518:    return FAILURE;",
          "519:   }",
          "521:  } else if (zend_string_equals_literal(name, \"array_key_exists\")) {",
          "522:   if (num_args != 2 || Z_TYPE_P(args[1]) != IS_ARRAY ||",
          "523:     (Z_TYPE_P(args[0]) != IS_LONG && Z_TYPE_P(args[0]) != IS_STRING",
          "524:      && Z_TYPE_P(args[0]) != IS_NULL)) {",
          "525:    return FAILURE;",
          "526:   }",
          "528:  } else if (zend_string_equals_literal(name, \"trim\")",
          "529:    || zend_string_equals_literal(name, \"rtrim\")",
          "530:    || zend_string_equals_literal(name, \"ltrim\")) {",
          "531:   if ((num_args < 1 || num_args > 2) || Z_TYPE_P(args[0]) != IS_STRING",
          "532:     || (num_args == 2 && Z_TYPE_P(args[1]) != IS_STRING)) {",
          "533:    return FAILURE;",
          "534:   }",
          "536:  } else if (zend_string_equals_literal(name, \"array_keys\")",
          "537:    || zend_string_equals_literal(name, \"array_values\")) {",
          "538:   if (num_args != 1 || Z_TYPE_P(args[0]) != IS_ARRAY) {",
          "539:    return FAILURE;",
          "540:   }",
          "542:  } else if (zend_string_equals_literal(name, \"array_flip\")) {",
          "543:   zval *entry;",
          "545:   if (num_args != 1 || Z_TYPE_P(args[0]) != IS_ARRAY) {",
          "546:    return FAILURE;",
          "547:   }",
          "548:   ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(args[0]), entry) {",
          "549:    if (Z_TYPE_P(entry) != IS_LONG && Z_TYPE_P(entry) != IS_STRING) {",
          "550:     return FAILURE;",
          "551:    }",
          "552:   } ZEND_HASH_FOREACH_END();",
          "554:  } else if (zend_string_equals_literal(name, \"str_repeat\")) {",
          "555:   if (num_args != 2",
          "556:     || Z_TYPE_P(args[0]) != IS_STRING",
          "557:     || Z_TYPE_P(args[1]) != IS_LONG",
          "558:     || zend_safe_address(Z_STRLEN_P(args[0]), Z_LVAL_P(args[1]), 0, &overflow) > 64 * 1024",
          "559:     || overflow) {",
          "560:    return FAILURE;",
          "561:   }",
          "563:  } else if ((zend_string_equals_literal(name, \"array_merge\")",
          "564:    || zend_string_equals_literal(name, \"array_replace\")",
          "565:    || zend_string_equals_literal(name, \"array_merge_recursive\")",
          "566:    || zend_string_equals_literal(name, \"array_merge_recursive\")",
          "567:    || zend_string_equals_literal(name, \"array_diff\")",
          "568:    || zend_string_equals_literal(name, \"array_diff_assoc\")",
          "569:    || zend_string_equals_literal(name, \"array_diff_key\"))",
          "570:    && num_args > 0) {",
          "571:   for (i = 0; i < num_args; i++) {",
          "572:    if (Z_TYPE_P(args[i]) != IS_ARRAY) {",
          "573:     return FAILURE;",
          "574:    }",
          "575:   }",
          "577:  } else if (zend_string_equals_literal(name, \"implode\")) {",
          "578:   zval *entry;",
          "580:   if (!(num_args == 1 && Z_TYPE_P(args[0]) == IS_ARRAY)",
          "581:     && !(num_args == 2 && Z_TYPE_P(args[0]) == IS_STRING && Z_TYPE_P(args[1]) == IS_ARRAY)",
          "582:     && !(num_args == 2 && Z_TYPE_P(args[0]) == IS_ARRAY && Z_TYPE_P(args[1]) == IS_STRING)) {",
          "583:    return FAILURE;",
          "584:   }",
          "586:   if (Z_TYPE_P(args[0]) == IS_ARRAY) {",
          "587:    ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(args[0]), entry) {",
          "588:     if (Z_TYPE_P(entry) > IS_STRING) {",
          "589:      return FAILURE;",
          "590:     }",
          "591:    } ZEND_HASH_FOREACH_END();",
          "592:   } else {",
          "593:    ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(args[1]), entry) {",
          "594:     if (Z_TYPE_P(entry) > IS_STRING) {",
          "595:      return FAILURE;",
          "596:     }",
          "597:    } ZEND_HASH_FOREACH_END();",
          "598:   }",
          "600:  } else if (zend_string_equals_literal(name, \"version_comapre\")) {",
          "601:   if ((num_args != 2 && (num_args != 3 || Z_TYPE_P(args[2]) != IS_STRING))",
          "602:     || Z_TYPE_P(args[0]) != IS_STRING",
          "603:     || Z_TYPE_P(args[1]) != IS_STRING) {",
          "604:    return FAILURE;",
          "605:   }",
          "607:  } else {",
          "608:   return FAILURE;",
          "609:  }",
          "611:  func = zend_hash_find_ptr(CG(function_table), name);",
          "612:  if (!func || func->type != ZEND_INTERNAL_FUNCTION) {",
          "613:   return FAILURE;",
          "614:  }",
          "616:  execute_data = safe_emalloc(num_args, sizeof(zval), ZEND_CALL_FRAME_SLOT * sizeof(zval));",
          "617:  memset(execute_data, 0, sizeof(zend_execute_data));",
          "618:  EX(func) = func;",
          "619:  EX_NUM_ARGS() = num_args;",
          "620:  for (i = 0; i < num_args; i++) {",
          "621:   ZVAL_COPY(EX_VAR_NUM(i), args[i]);",
          "622:  }",
          "623:  func->internal_function.handler(execute_data, result);",
          "624:  for (i = 0; i < num_args; i++) {",
          "625:   zval_ptr_dtor_nogc(EX_VAR_NUM(i));",
          "626:  }",
          "627:  efree(execute_data);",
          "628:  return SUCCESS;",
          "629: }",
          "631: #define SET_RESULT(op, zv) do { \\",
          "632:  if (ssa_op->op##_def >= 0) { \\",
          "633:   set_value(scdf, ctx, ssa_op->op##_def, zv); \\",
          "634:  } \\",
          "635: } while (0)",
          "636: #define SET_RESULT_BOT(op) SET_RESULT(op, &ctx->bot)",
          "637: #define SET_RESULT_TOP(op) SET_RESULT(op, &ctx->top)",
          "639: #define SKIP_IF_TOP(op) if (IS_TOP(op)) break;",
          "641: static void sccp_visit_instr(scdf_ctx *scdf, zend_op *opline, zend_ssa_op *ssa_op) {",
          "642:  sccp_ctx *ctx = (sccp_ctx *) scdf;",
          "645:  op1 = get_op1_value(ctx, opline, ssa_op);",
          "646:  op2 = get_op2_value(ctx, opline, ssa_op);",
          "648:  switch (opline->opcode) {",
          "649:   case ZEND_ASSIGN:",
          "652:    if (IS_BOT(op1) && (ctx->scdf.ssa->var_info[ssa_op->op1_use].type & MAY_BE_REF)) {",
          "653:     SET_RESULT_BOT(op1);",
          "654:    } else {",
          "655:     SET_RESULT(op1, op2);",
          "656:    }",
          "658:    SET_RESULT(result, op2);",
          "659:    return;",
          "660:   case ZEND_TYPE_CHECK:",
          "663:    if (!value_known(op1)) {",
          "664:     uint32_t type = ctx->scdf.ssa->var_info[ssa_op->op1_use].type;",
          "665:     uint32_t expected_type = opline->extended_value == _IS_BOOL",
          "666:      ? (MAY_BE_TRUE|MAY_BE_FALSE) : (1 << opline->extended_value);",
          "667:     if (!(type & expected_type) && !(type & MAY_BE_UNDEF)) {",
          "668:      ZVAL_FALSE(&zv);",
          "669:      SET_RESULT(result, &zv);",
          "670:      return;",
          "671:     } else if (!(type & ((MAY_BE_ANY|MAY_BE_UNDEF) - expected_type))",
          "672:          && opline->extended_value != IS_RESOURCE) {",
          "673:      ZVAL_TRUE(&zv);",
          "674:      SET_RESULT(result, &zv);",
          "675:      return;",
          "676:     }",
          "677:    }",
          "678:    break;",
          "679:   case ZEND_ASSIGN_DIM:",
          "681:    if ((ctx->scdf.ssa->var_info[ssa_op->op1_use].type & MAY_BE_ANY) == 0) {",
          "682:     op1 = &EG(uninitialized_zval);",
          "683:    }",
          "684:    break;",
          "685:   case ZEND_SEND_VAL:",
          "686:   case ZEND_SEND_VAR:",
          "687:   {",
          "690:    zend_call_info *call;",
          "691:    if (!ctx->call_map) {",
          "692:     return;",
          "693:    }",
          "695:    call = ctx->call_map[opline - ctx->scdf.op_array->opcodes];",
          "696:    if (IS_TOP(op1) || !call || call->caller_call_opline->opcode != ZEND_DO_ICALL) {",
          "697:     return;",
          "698:    }",
          "700:    opline = call->caller_call_opline;",
          "701:    ssa_op = &ctx->scdf.ssa->ops[opline - ctx->scdf.op_array->opcodes];",
          "702:    break;",
          "703:   }",
          "704:  }",
          "706:  if ((op1 && IS_BOT(op1)) || (op2 && IS_BOT(op2))) {",
          "709:   SET_RESULT_BOT(result);",
          "710:   SET_RESULT_BOT(op1);",
          "711:   SET_RESULT_BOT(op2);",
          "712:   return;",
          "713:  }",
          "715:  switch (opline->opcode) {",
          "716:   case ZEND_ADD:",
          "717:   case ZEND_SUB:",
          "718:   case ZEND_MUL:",
          "719:   case ZEND_DIV:",
          "720:   case ZEND_MOD:",
          "721:   case ZEND_POW:",
          "722:   case ZEND_SL:",
          "723:   case ZEND_SR:",
          "724:   case ZEND_CONCAT:",
          "725:   case ZEND_FAST_CONCAT:",
          "726:   case ZEND_IS_EQUAL:",
          "727:   case ZEND_IS_NOT_EQUAL:",
          "728:   case ZEND_IS_SMALLER:",
          "729:   case ZEND_IS_SMALLER_OR_EQUAL:",
          "730:   case ZEND_IS_IDENTICAL:",
          "731:   case ZEND_IS_NOT_IDENTICAL:",
          "732:   case ZEND_BW_OR:",
          "733:   case ZEND_BW_AND:",
          "734:   case ZEND_BW_XOR:",
          "735:   case ZEND_BOOL_XOR:",
          "736:   case ZEND_CASE:",
          "737:    SKIP_IF_TOP(op1);",
          "738:    SKIP_IF_TOP(op2);",
          "740:    if (zend_optimizer_eval_binary_op(&zv, opline->opcode, op1, op2) == SUCCESS) {",
          "741:     SET_RESULT(result, &zv);",
          "742:     zval_ptr_dtor_nogc(&zv);",
          "743:     break;",
          "744:    }",
          "745:    SET_RESULT_BOT(result);",
          "746:    break;",
          "747:   case ZEND_ASSIGN_ADD:",
          "748:   case ZEND_ASSIGN_SUB:",
          "749:   case ZEND_ASSIGN_MUL:",
          "750:   case ZEND_ASSIGN_DIV:",
          "751:   case ZEND_ASSIGN_MOD:",
          "752:   case ZEND_ASSIGN_SL:",
          "753:   case ZEND_ASSIGN_SR:",
          "754:   case ZEND_ASSIGN_CONCAT:",
          "755:   case ZEND_ASSIGN_BW_OR:",
          "756:   case ZEND_ASSIGN_BW_AND:",
          "757:   case ZEND_ASSIGN_BW_XOR:",
          "758:   case ZEND_ASSIGN_POW:",
          "760:    if (opline->extended_value) {",
          "761:     SET_RESULT_BOT(op1);",
          "762:     SET_RESULT_BOT(result);",
          "763:     break;",
          "764:    }",
          "766:    SKIP_IF_TOP(op1);",
          "767:    SKIP_IF_TOP(op2);",
          "769:    if (zend_optimizer_eval_binary_op(&zv, zend_compound_assign_to_binary_op(opline->opcode), op1, op2) == SUCCESS) {",
          "770:     SET_RESULT(op1, &zv);",
          "771:     SET_RESULT(result, &zv);",
          "772:     zval_ptr_dtor_nogc(&zv);",
          "773:     break;",
          "774:    }",
          "775:    SET_RESULT_BOT(op1);",
          "776:    SET_RESULT_BOT(result);",
          "777:    break;",
          "778:   case ZEND_PRE_INC:",
          "779:   case ZEND_PRE_DEC:",
          "780:    SKIP_IF_TOP(op1);",
          "781:    if (ct_eval_incdec(&zv, opline->opcode, op1) == SUCCESS) {",
          "782:     SET_RESULT(op1, &zv);",
          "783:     SET_RESULT(result, &zv);",
          "784:     zval_ptr_dtor_nogc(&zv);",
          "785:     break;",
          "786:    }",
          "787:    SET_RESULT_BOT(op1);",
          "788:    SET_RESULT_BOT(result);",
          "789:    break;",
          "790:   case ZEND_POST_INC:",
          "791:   case ZEND_POST_DEC:",
          "792:    SKIP_IF_TOP(op1);",
          "793:    SET_RESULT(result, op1);",
          "794:    if (ct_eval_incdec(&zv, opline->opcode, op1) == SUCCESS) {",
          "795:     SET_RESULT(op1, &zv);",
          "796:     zval_ptr_dtor_nogc(&zv);",
          "797:     break;",
          "798:    }",
          "799:    SET_RESULT_BOT(op1);",
          "800:    break;",
          "801:   case ZEND_BW_NOT:",
          "802:   case ZEND_BOOL_NOT:",
          "803:    SKIP_IF_TOP(op1);",
          "804:    if (zend_optimizer_eval_unary_op(&zv, opline->opcode, op1) == SUCCESS) {",
          "805:     SET_RESULT(result, &zv);",
          "806:     zval_ptr_dtor_nogc(&zv);",
          "807:     break;",
          "808:    }",
          "809:    SET_RESULT_BOT(result);",
          "810:    break;",
          "811:   case ZEND_CAST:",
          "812:    SKIP_IF_TOP(op1);",
          "813:    if (zend_optimizer_eval_cast(&zv, opline->extended_value, op1) == SUCCESS) {",
          "814:     SET_RESULT(result, &zv);",
          "815:     zval_ptr_dtor_nogc(&zv);",
          "816:     break;",
          "817:    }",
          "818:    SET_RESULT_BOT(result);",
          "819:    break;",
          "820:   case ZEND_BOOL:",
          "821:   case ZEND_JMPZ_EX:",
          "822:   case ZEND_JMPNZ_EX:",
          "823:    SKIP_IF_TOP(op1);",
          "824:    ZVAL_BOOL(&zv, zend_is_true(op1));",
          "825:    SET_RESULT(result, &zv);",
          "826:    break;",
          "827:   case ZEND_STRLEN:",
          "828:    SKIP_IF_TOP(op1);",
          "829:    if (zend_optimizer_eval_strlen(&zv, op1) == SUCCESS) {",
          "830:     SET_RESULT(result, &zv);",
          "831:     zval_ptr_dtor_nogc(&zv);",
          "832:     break;",
          "833:    }",
          "834:    SET_RESULT_BOT(result);",
          "835:    break;",
          "836:   case ZEND_COUNT:",
          "837:    SKIP_IF_TOP(op1);",
          "838:    if (Z_TYPE_P(op1) == IS_ARRAY) {",
          "839:     ZVAL_LONG(&zv, zend_hash_num_elements(Z_ARRVAL_P(op1)));",
          "840:     SET_RESULT(result, &zv);",
          "841:     zval_ptr_dtor_nogc(&zv);",
          "842:     break;",
          "843:    }",
          "844:    SET_RESULT_BOT(result);",
          "845:    break;",
          "846:   case ZEND_FETCH_DIM_R:",
          "847:   case ZEND_FETCH_DIM_IS:",
          "848:   case ZEND_FETCH_LIST:",
          "849:    SKIP_IF_TOP(op1);",
          "850:    SKIP_IF_TOP(op2);",
          "852:    if (ct_eval_fetch_dim(&zv, op1, op2, (opline->opcode != ZEND_FETCH_LIST)) == SUCCESS) {",
          "853:     SET_RESULT(result, &zv);",
          "854:     zval_ptr_dtor_nogc(&zv);",
          "855:     break;",
          "856:    }",
          "857:    SET_RESULT_BOT(result);",
          "858:    break;",
          "859:   case ZEND_ISSET_ISEMPTY_DIM_OBJ:",
          "860:    SKIP_IF_TOP(op1);",
          "861:    SKIP_IF_TOP(op2);",
          "863:    if (ct_eval_isset_dim(&zv, opline->extended_value, op1, op2) == SUCCESS) {",
          "864:     SET_RESULT(result, &zv);",
          "865:     zval_ptr_dtor_nogc(&zv);",
          "866:     break;",
          "867:    }",
          "868:    SET_RESULT_BOT(result);",
          "869:    break;",
          "870:   case ZEND_QM_ASSIGN:",
          "871:   case ZEND_JMP_SET:",
          "872:   case ZEND_COALESCE:",
          "873:    SET_RESULT(result, op1);",
          "874:    break;",
          "875:   case ZEND_FETCH_CLASS:",
          "876:    if (!op1) {",
          "877:     SET_RESULT_BOT(result);",
          "878:     break;",
          "879:    }",
          "880:    SET_RESULT(result, op1);",
          "881:    break;",
          "882:   case ZEND_ISSET_ISEMPTY_VAR:",
          "883:    SKIP_IF_TOP(op1);",
          "884:    if (ct_eval_isset_isempty(&zv, opline->extended_value, op1) == SUCCESS) {",
          "885:     SET_RESULT(result, &zv);",
          "886:     zval_ptr_dtor_nogc(&zv);",
          "887:     break;",
          "888:    }",
          "889:    SET_RESULT_BOT(result);",
          "890:    break;",
          "891:   case ZEND_TYPE_CHECK:",
          "892:    SKIP_IF_TOP(op1);",
          "893:    ct_eval_type_check(&zv, opline->extended_value, op1);",
          "894:    SET_RESULT(result, &zv);",
          "895:    zval_ptr_dtor_nogc(&zv);",
          "896:    break;",
          "897:   case ZEND_INSTANCEOF:",
          "898:    SKIP_IF_TOP(op1);",
          "899:    ZVAL_FALSE(&zv);",
          "900:    SET_RESULT(result, &zv);",
          "901:    break;",
          "902:   case ZEND_ROPE_INIT:",
          "903:    SKIP_IF_TOP(op2);",
          "904:    if (zend_optimizer_eval_cast(&zv, IS_STRING, op2) == SUCCESS) {",
          "905:     SET_RESULT(result, &zv);",
          "906:     zval_ptr_dtor_nogc(&zv);",
          "907:     break;",
          "908:    }",
          "909:    SET_RESULT_BOT(result);",
          "910:    break;",
          "911:   case ZEND_ROPE_ADD:",
          "912:   case ZEND_ROPE_END:",
          "916:    SKIP_IF_TOP(op1);",
          "917:    SKIP_IF_TOP(op2);",
          "918:    if (zend_optimizer_eval_binary_op(&zv, ZEND_CONCAT, op1, op2) == SUCCESS) {",
          "919:     SET_RESULT(result, &zv);",
          "920:     zval_ptr_dtor_nogc(&zv);",
          "921:     break;",
          "922:    }",
          "923:    SET_RESULT_BOT(result);",
          "924:    break;",
          "925:   case ZEND_INIT_ARRAY:",
          "926:   case ZEND_ADD_ARRAY_ELEMENT:",
          "927:   {",
          "928:    zval *result = NULL;",
          "929:    if (opline->extended_value & ZEND_ARRAY_ELEMENT_REF) {",
          "930:     SET_RESULT_BOT(result);",
          "931:     SET_RESULT_BOT(op1);",
          "932:     break;",
          "933:    }",
          "935:    if (opline->opcode == ZEND_ADD_ARRAY_ELEMENT) {",
          "936:     result = &ctx->values[ssa_op->result_use];",
          "937:     if (IS_BOT(result)) {",
          "938:      SET_RESULT_BOT(result);",
          "939:      break;",
          "940:     }",
          "941:     SKIP_IF_TOP(result);",
          "942:    }",
          "944:    SKIP_IF_TOP(op1);",
          "945:    if (op2) {",
          "946:     SKIP_IF_TOP(op2);",
          "947:    }",
          "952:    if (Z_TYPE(ctx->values[ssa_op->result_def]) == IS_NULL) {",
          "953:     break;",
          "954:    }",
          "956:    if (result) {",
          "957:     ZVAL_COPY_VALUE(&zv, result);",
          "958:     ZVAL_NULL(result);",
          "959:    } else {",
          "960:     array_init(&zv);",
          "961:    }",
          "963:    if (ct_eval_add_array_elem(&zv, op1, op2) == SUCCESS) {",
          "964:     SET_RESULT(result, &zv);",
          "965:     zval_ptr_dtor_nogc(&zv);",
          "966:     break;",
          "967:    }",
          "968:    SET_RESULT_BOT(result);",
          "969:    zval_ptr_dtor_nogc(&zv);",
          "970:    break;",
          "971:   }",
          "972:   case ZEND_ASSIGN_DIM:",
          "973:   {",
          "974:    zval *data = get_op1_value(ctx, opline+1, ssa_op+1);",
          "975:    if (IS_BOT(data)) {",
          "976:     SET_RESULT_BOT(op1);",
          "977:     SET_RESULT_BOT(result);",
          "978:     break;",
          "979:    }",
          "981:    SKIP_IF_TOP(data);",
          "982:    SKIP_IF_TOP(op1);",
          "983:    if (op2) {",
          "984:     SKIP_IF_TOP(op2);",
          "985:    }",
          "987:    ZVAL_DUP(&zv, op1);",
          "988:    if (ct_eval_assign_dim(&zv, data, op2) == SUCCESS) {",
          "989:     SET_RESULT(result, data);",
          "990:     SET_RESULT(op1, &zv);",
          "991:     zval_ptr_dtor_nogc(&zv);",
          "992:     break;",
          "993:    }",
          "994:    SET_RESULT_BOT(result);",
          "995:    SET_RESULT_BOT(op1);",
          "996:    zval_ptr_dtor_nogc(&zv);",
          "997:    break;",
          "998:   }",
          "999:   case ZEND_DO_ICALL:",
          "1000:   {",
          "1001:    zend_call_info *call;",
          "1002:    zval *name, *args[2] = {NULL};",
          "1003:    int i;",
          "1005:    if (!ctx->call_map) {",
          "1006:     SET_RESULT_BOT(result);",
          "1007:     break;",
          "1008:    }",
          "1010:    call = ctx->call_map[opline - ctx->scdf.op_array->opcodes];",
          "1011:    name = CT_CONSTANT_EX(ctx->scdf.op_array, call->caller_init_opline->op2.constant);",
          "1014:    if (ssa_op->result_def < 0 || IS_BOT(&ctx->values[ssa_op->result_def])) {",
          "1015:     break;",
          "1016:    }",
          "1019:    if (call->num_args == 0 || call->num_args > 3) {",
          "1020:     SET_RESULT_BOT(result);",
          "1021:     break;",
          "1022:    }",
          "1024:    for (i = 0; i < call->num_args; i++) {",
          "1025:     zend_op *opline = call->arg_info[i].opline;",
          "1026:     if (opline->opcode != ZEND_SEND_VAL && opline->opcode != ZEND_SEND_VAR) {",
          "1027:      SET_RESULT_BOT(result);",
          "1028:      return;",
          "1029:     }",
          "1031:     args[i] = get_op1_value(ctx, opline,",
          "1032:      &ctx->scdf.ssa->ops[opline - ctx->scdf.op_array->opcodes]);",
          "1033:     if (args[i]) {",
          "1034:      if (IS_BOT(args[i])) {",
          "1035:       SET_RESULT_BOT(result);",
          "1036:       return;",
          "1037:      } else if (IS_TOP(args[i])) {",
          "1038:       return;",
          "1039:      }",
          "1040:     }",
          "1041:    }",
          "1044:    if (!IS_TOP(&ctx->values[ssa_op->result_def])) {",
          "1045:     break;",
          "1046:    }",
          "1048:    if (ct_eval_func_call(&zv, Z_STR_P(name), call->num_args, args) == SUCCESS) {",
          "1049:     SET_RESULT(result, &zv);",
          "1050:     zval_ptr_dtor_nogc(&zv);",
          "1051:     break;",
          "1052:    }",
          "1054: #if 0",
          "1056:    fprintf(stderr, \"%s\\n\", Z_STRVAL_P(name));",
          "1058:     php_printf(\"%s %Z %Z\\n\", Z_STRVAL_P(name), args[0], args[1]);",
          "1059:    } else {",
          "1060:     php_printf(\"%s %Z\\n\", Z_STRVAL_P(name), args[0]);",
          "1062: #endif",
          "1064:    SET_RESULT_BOT(result);",
          "1065:    break;",
          "1066:   }",
          "1067:   default:",
          "1068:   {",
          "1070:    SET_RESULT_BOT(result);",
          "1071:    SET_RESULT_BOT(op1);",
          "1072:    SET_RESULT_BOT(op2);",
          "1073:    break;",
          "1074:   }",
          "1075:  }",
          "1076: }",
          "1079: static void sccp_mark_feasible_successors(",
          "1080:   scdf_ctx *scdf,",
          "1081:   int block_num, zend_basic_block *block,",
          "1082:   zend_op *opline, zend_ssa_op *ssa_op) {",
          "1083:  sccp_ctx *ctx = (sccp_ctx *) scdf;",
          "1084:  zval *op1;",
          "1085:  int s;",
          "1088:  switch (opline->opcode) {",
          "1089:   case ZEND_ASSERT_CHECK:",
          "1090:   case ZEND_CATCH:",
          "1091:   case ZEND_DECLARE_ANON_CLASS:",
          "1092:   case ZEND_DECLARE_ANON_INHERITED_CLASS:",
          "1093:   case ZEND_FE_FETCH_R:",
          "1094:   case ZEND_FE_FETCH_RW:",
          "1095:    scdf_mark_edge_feasible(scdf, block_num, block->successors[0]);",
          "1096:    scdf_mark_edge_feasible(scdf, block_num, block->successors[1]);",
          "1097:    return;",
          "1098:  }",
          "1100:  op1 = get_op1_value(ctx, opline, ssa_op);",
          "1103:  if (!op1 || IS_BOT(op1)) {",
          "1104:   for (s = 0; s < block->successors_count; s++) {",
          "1105:    scdf_mark_edge_feasible(scdf, block_num, block->successors[s]);",
          "1106:   }",
          "1107:   return;",
          "1108:  }",
          "1111:  if (IS_TOP(op1)) {",
          "1112:   return;",
          "1113:  }",
          "1115:  switch (opline->opcode) {",
          "1116:   case ZEND_JMPZ:",
          "1117:   case ZEND_JMPZNZ:",
          "1118:   case ZEND_JMPZ_EX:",
          "1119:    s = zend_is_true(op1);",
          "1120:    break;",
          "1121:   case ZEND_JMPNZ:",
          "1122:   case ZEND_JMPNZ_EX:",
          "1123:   case ZEND_JMP_SET:",
          "1124:    s = !zend_is_true(op1);",
          "1125:    break;",
          "1126:   case ZEND_COALESCE:",
          "1127:    s = (Z_TYPE_P(op1) == IS_NULL);",
          "1128:    break;",
          "1129:   case ZEND_FE_RESET_R:",
          "1130:   case ZEND_FE_RESET_RW:",
          "1131:    if (Z_TYPE_P(op1) != IS_ARRAY) {",
          "1132:     scdf_mark_edge_feasible(scdf, block_num, block->successors[0]);",
          "1133:     scdf_mark_edge_feasible(scdf, block_num, block->successors[1]);",
          "1134:     return;",
          "1135:    }",
          "1136:    s = zend_hash_num_elements(Z_ARR_P(op1)) != 0;",
          "1137:    break;",
          "1138:   default:",
          "1139:    for (s = 0; s < block->successors_count; s++) {",
          "1140:     scdf_mark_edge_feasible(scdf, block_num, block->successors[s]);",
          "1141:    }",
          "1142:    return;",
          "1143:  }",
          "1144:  scdf_mark_edge_feasible(scdf, block_num, block->successors[s]);",
          "1145: }",
          "1147: static void join_phi_values(zval *a, zval *b) {",
          "1148:  if (IS_BOT(a) || IS_TOP(b)) {",
          "1149:   return;",
          "1150:  }",
          "1151:  if (IS_TOP(a)) {",
          "1152:   zval_ptr_dtor_nogc(a);",
          "1153:   ZVAL_COPY(a, b);",
          "1154:   return;",
          "1155:  }",
          "1156:  if (IS_BOT(b) || !zend_is_identical(a, b)) {",
          "1157:   zval_ptr_dtor_nogc(a);",
          "1158:   MAKE_BOT(a);",
          "1159:  }",
          "1160: }",
          "1162: static void sccp_visit_phi(scdf_ctx *scdf, zend_ssa_phi *phi) {",
          "1163:  sccp_ctx *ctx = (sccp_ctx *) scdf;",
          "1164:  zend_ssa *ssa = scdf->ssa;",
          "1165:  ZEND_ASSERT(phi->ssa_var >= 0);",
          "1166:  if (!IS_BOT(&ctx->values[phi->ssa_var])) {",
          "1167:   zend_basic_block *block = &ssa->cfg.blocks[phi->block];",
          "1168:   int *predecessors = &ssa->cfg.predecessors[block->predecessor_offset];",
          "1170:   int i;",
          "1171:   zval result;",
          "1172:   MAKE_TOP(&result);",
          "1173:   SCP_DEBUG(\"Handling PHI(\");",
          "1174:   if (phi->pi >= 0) {",
          "1175:    ZEND_ASSERT(phi->sources[0] >= 0);",
          "1176:    if (scdf_is_edge_feasible(scdf, phi->pi, phi->block)) {",
          "1177:     join_phi_values(&result, &ctx->values[phi->sources[0]]);",
          "1178:    }",
          "1179:   } else {",
          "1180:    for (i = 0; i < block->predecessors_count; i++) {",
          "1181:     ZEND_ASSERT(phi->sources[i] >= 0);",
          "1182:     if (scdf_is_edge_feasible(scdf, predecessors[i], phi->block)) {",
          "1183:      SCP_DEBUG(\"val, \");",
          "1184:      join_phi_values(&result, &ctx->values[phi->sources[i]]);",
          "1185:     } else {",
          "1186:      SCP_DEBUG(\"--, \");",
          "1187:     }",
          "1188:    }",
          "1189:   }",
          "1190:   SCP_DEBUG(\")\\n\");",
          "1192:   set_value(scdf, ctx, phi->ssa_var, &result);",
          "1193:   zval_ptr_dtor_nogc(&result);",
          "1194:  }",
          "1195: }",
          "1197: static zval *value_from_type_and_range(sccp_ctx *ctx, int var_num, zval *tmp) {",
          "1198:  zend_ssa *ssa = ctx->scdf.ssa;",
          "1199:  zend_ssa_var_info *info = &ssa->var_info[var_num];",
          "1201:  if (ssa->vars[var_num].var >= ctx->scdf.op_array->last_var) {",
          "1203:   return NULL;",
          "1204:  }",
          "1206:  if (info->type & MAY_BE_UNDEF) {",
          "1207:   return NULL;",
          "1208:  }",
          "1210:  if (!(info->type & ((MAY_BE_ANY|MAY_BE_UNDEF)-MAY_BE_NULL))) {",
          "1211:   ZVAL_NULL(tmp);",
          "1212:   return tmp;",
          "1213:  }",
          "1214:  if (!(info->type & ((MAY_BE_ANY|MAY_BE_UNDEF)-MAY_BE_FALSE))) {",
          "1215:   ZVAL_FALSE(tmp);",
          "1216:   return tmp;",
          "1217:  }",
          "1218:  if (!(info->type & ((MAY_BE_ANY|MAY_BE_UNDEF)-MAY_BE_TRUE))) {",
          "1219:   ZVAL_TRUE(tmp);",
          "1220:   return tmp;",
          "1221:  }",
          "1223:  if (!(info->type & ((MAY_BE_ANY|MAY_BE_UNDEF)-MAY_BE_LONG))",
          "1224:    && info->has_range",
          "1225:    && !info->range.overflow && !info->range.underflow",
          "1226:    && info->range.min == info->range.max) {",
          "1227:   ZVAL_LONG(tmp, info->range.min);",
          "1228:   return tmp;",
          "1229:  }",
          "1231:  return NULL;",
          "1232: }",
          "1237: static int replace_constant_operands(sccp_ctx *ctx) {",
          "1238:  zend_ssa *ssa = ctx->scdf.ssa;",
          "1239:  zend_op_array *op_array = ctx->scdf.op_array;",
          "1240:  int i;",
          "1241:  zval tmp;",
          "1242:  int removed_ops = 0;",
          "1246:  for (i = ssa->vars_count - 1; i >= op_array->last_var; i--) {",
          "1247:   zend_ssa_var *var = &ssa->vars[i];",
          "1248:   zval *value;",
          "1249:   int use;",
          "1251:   if (value_known(&ctx->values[i])) {",
          "1252:    value = &ctx->values[i];",
          "1253:   } else {",
          "1254:    value = value_from_type_and_range(ctx, i, &tmp);",
          "1255:    if (!value) {",
          "1256:     continue;",
          "1257:    }",
          "1258:   }",
          "1260:   FOREACH_USE(var, use) {",
          "1261:    zend_op *opline = &op_array->opcodes[use];",
          "1262:    zend_ssa_op *ssa_op = &ssa->ops[use];",
          "1263:    if (try_replace_op1(ctx, opline, ssa_op, i, value)) {",
          "1264:     if (opline->opcode == ZEND_NOP) {",
          "1265:      removed_ops++;",
          "1266:     }",
          "1267:     ZEND_ASSERT(ssa_op->op1_def == -1);",
          "1268:     if (ssa_op->op1_use != ssa_op->op2_use) {",
          "1269:      zend_ssa_unlink_use_chain(ssa, use, ssa_op->op1_use);",
          "1270:     } else {",
          "1271:      ssa_op->op2_use_chain = ssa_op->op1_use_chain;",
          "1272:     }",
          "1273:     ssa_op->op1_use = -1;",
          "1274:     ssa_op->op1_use_chain = -1;",
          "1275:    }",
          "1276:    if (try_replace_op2(ctx, opline, ssa_op, i, value)) {",
          "1277:     ZEND_ASSERT(ssa_op->op2_def == -1);",
          "1278:     zend_ssa_unlink_use_chain(ssa, use, ssa_op->op2_use);",
          "1279:     ssa_op->op2_use = -1;",
          "1280:     ssa_op->op2_use_chain = -1;",
          "1281:    }",
          "1282:   } FOREACH_USE_END();",
          "1296:   if (var->definition >= 0 && value_known(&ctx->values[i])) {",
          "1297:    zend_op *opline = &op_array->opcodes[var->definition];",
          "1298:    zend_ssa_op *ssa_op = &ssa->ops[var->definition];",
          "1299:    if (opline->opcode == ZEND_ASSIGN) {",
          "1301:     continue;",
          "1302:    }",
          "1304:    if (ssa_op->result_def == i",
          "1305:      && ssa_op->op1_def < 0",
          "1306:      && ssa_op->op2_def < 0",
          "1307:      && var->use_chain < 0",
          "1308:      && var->phi_use_chain == NULL) {",
          "1309:     if (opline->opcode == ZEND_DO_ICALL) {",
          "1311:      zend_call_info *call;",
          "1312:      int i;",
          "1314:      ZEND_ASSERT(ctx->call_map);",
          "1315:      call = ctx->call_map[var->definition];",
          "1316:      ZEND_ASSERT(call);",
          "1317:      ZEND_ASSERT(call->caller_call_opline == opline);",
          "1318:      if (opline->result_type & (IS_TMP_VAR|IS_VAR)) {",
          "1319:       zend_optimizer_remove_live_range_ex(op_array, opline->result.var, var->definition + 1);",
          "1320:      }",
          "1321:      zend_ssa_remove_result_def(ssa, ssa_op);",
          "1322:      zend_ssa_remove_instr(ssa, opline, ssa_op);",
          "1323:      zend_ssa_remove_instr(ssa, call->caller_init_opline,",
          "1324:       &ssa->ops[call->caller_init_opline - op_array->opcodes]);",
          "1326:      for (i = 0; i < call->num_args; i++) {",
          "1327:       zend_ssa_remove_instr(ssa, call->arg_info[i].opline,",
          "1328:        &ssa->ops[call->arg_info[i].opline - op_array->opcodes]);",
          "1329:      }",
          "1330:      removed_ops = call->num_args + 2;",
          "1333:      call->callee_func = NULL;",
          "1334:     } else {",
          "1336:      if (opline->result_type & (IS_TMP_VAR|IS_VAR)) {",
          "1337:       zend_optimizer_remove_live_range_ex(op_array, opline->result.var, var->definition + 1);",
          "1338:      }",
          "1339:      zend_ssa_remove_result_def(ssa, ssa_op);",
          "1340:      zend_ssa_remove_instr(ssa, opline, ssa_op);",
          "1341:      removed_ops++;",
          "1342:     }",
          "1343:    } else if (ssa_op->op1_def == i) {",
          "1347:     if (opline->op2_type == IS_CONST) {",
          "1348:      literal_dtor(&ZEND_OP2_LITERAL(opline));",
          "1349:     } else if (ssa_op->op2_use >= 0) {",
          "1350:      if (ssa_op->op2_use != ssa_op->op1_use) {",
          "1351:       zend_ssa_unlink_use_chain(ssa, var->definition, ssa_op->op2_use);",
          "1352:      }",
          "1353:      ssa_op->op2_use = -1;",
          "1354:      ssa_op->op2_use_chain = -1;",
          "1355:     }",
          "1358:     if (ssa_op->result_def >= 0",
          "1359:       && ssa->vars[ssa_op->result_def].use_chain < 0",
          "1360:       && ssa->vars[ssa_op->result_def].phi_use_chain == NULL) {",
          "1361:      if (opline->result_type & (IS_TMP_VAR|IS_VAR)) {",
          "1362:       zend_optimizer_remove_live_range_ex(op_array, opline->result.var, var->definition + 1);",
          "1363:      }",
          "1364:      zend_ssa_remove_result_def(ssa, ssa_op);",
          "1365:      opline->result_type = IS_UNUSED;",
          "1366:     }",
          "1369:     if (opline->opcode == ZEND_ASSIGN_DIM) {",
          "1370:      removed_ops++;",
          "1371:      zend_ssa_remove_instr(ssa, opline + 1, ssa_op + 1);",
          "1372:     }",
          "1375:     opline->opcode = ZEND_ASSIGN;",
          "1376:     opline->op2_type = IS_CONST;",
          "1377:     opline->op2.constant = zend_optimizer_add_literal(op_array, value);",
          "1378:     Z_TRY_ADDREF_P(value);",
          "1379:    }",
          "1380:   }",
          "1381:   if (var->definition_phi",
          "1382:     && value_known(&ctx->values[i])",
          "1383:     && var->use_chain < 0",
          "1384:     && var->phi_use_chain == NULL) {",
          "1385:    zend_ssa_remove_phi(ssa, var->definition_phi);",
          "1386:   }",
          "1387:  }",
          "1389:  return removed_ops;",
          "1390: }",
          "1392: static void sccp_context_init(zend_optimizer_ctx *ctx, sccp_ctx *sccp,",
          "1393:   zend_ssa *ssa, zend_op_array *op_array, zend_call_info **call_map) {",
          "1394:  int i;",
          "1395:  sccp->call_map = call_map;",
          "1396:  sccp->values = zend_arena_alloc(&ctx->arena, sizeof(zval) * ssa->vars_count);",
          "1398:  MAKE_TOP(&sccp->top);",
          "1399:  MAKE_BOT(&sccp->bot);",
          "1401:  i = 0;",
          "1402:  for (; i < op_array->last_var; ++i) {",
          "1405:   MAKE_BOT(&sccp->values[i]);",
          "1406:  }",
          "1407:  for (; i < ssa->vars_count; ++i) {",
          "1408:   if (ssa->vars[i].alias) {",
          "1409:    MAKE_BOT(&sccp->values[i]);",
          "1410:   } else {",
          "1411:    MAKE_TOP(&sccp->values[i]);",
          "1412:   }",
          "1413:  }",
          "1414: }",
          "1416: static void sccp_context_free(sccp_ctx *sccp) {",
          "1417:  int i;",
          "1418:  for (i = sccp->scdf.op_array->last_var; i < sccp->scdf.ssa->vars_count; ++i) {",
          "1419:   zval_ptr_dtor_nogc(&sccp->values[i]);",
          "1420:  }",
          "1421: }",
          "1423: int sccp_optimize_op_array(zend_optimizer_ctx *ctx, zend_op_array *op_array, zend_ssa *ssa, zend_call_info **call_map)",
          "1424: {",
          "1425:  sccp_ctx sccp;",
          "1426:  int removed_ops = 0;",
          "1427:  void *checkpoint = zend_arena_checkpoint(ctx->arena);",
          "1429:  sccp_context_init(ctx, &sccp, ssa, op_array, call_map);",
          "1431:  sccp.scdf.handlers.visit_instr = sccp_visit_instr;",
          "1432:  sccp.scdf.handlers.visit_phi = sccp_visit_phi;",
          "1433:  sccp.scdf.handlers.mark_feasible_successors = sccp_mark_feasible_successors;",
          "1435:  scdf_init(ctx, &sccp.scdf, op_array, ssa);",
          "1436:  scdf_solve(&sccp.scdf, \"SCCP\");",
          "1438:  removed_ops += scdf_remove_unreachable_blocks(&sccp.scdf);",
          "1439:  removed_ops += replace_constant_operands(&sccp);",
          "1441:  sccp_context_free(&sccp);",
          "1442:  zend_arena_release(&ctx->arena, checkpoint);",
          "1444:  return removed_ops;",
          "1445: }",
          "",
          "---------------"
        ],
        "ext/opcache/Optimizer/scdf.c||ext/opcache/Optimizer/scdf.c": [
          "File: ext/opcache/Optimizer/scdf.c -> ext/opcache/Optimizer/scdf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2:    +----------------------------------------------------------------------+",
          "3:    | Zend Engine, Sparse Conditional Data Flow Propagation Framework      |",
          "4:    +----------------------------------------------------------------------+",
          "5:    | Copyright (c) 1998-2017 The PHP Group                                |",
          "6:    +----------------------------------------------------------------------+",
          "7:    | This source file is subject to version 3.01 of the PHP license,      |",
          "8:    | that is bundled with this package in the file LICENSE, and is        |",
          "9:    | available through the world-wide-web at the following url:           |",
          "10:    | http://www.php.net/license/3_01.txt                                  |",
          "11:    | If you did not receive a copy of the PHP license and are unable to   |",
          "12:    | obtain it through the world-wide-web, please send a note to          |",
          "13:    | license@php.net so we can mail you a copy immediately.               |",
          "14:    +----------------------------------------------------------------------+",
          "15:    | Authors: Nikita Popov <nikic@php.net>                                |",
          "16:    +----------------------------------------------------------------------+",
          "19: #include \"ZendAccelerator.h\"",
          "20: #include \"Optimizer/zend_optimizer_internal.h\"",
          "21: #include \"Optimizer/scdf.h\"",
          "49: #if 0",
          "50: #define DEBUG_PRINT(...) fprintf(stderr, __VA_ARGS__)",
          "51: #else",
          "52: #define DEBUG_PRINT(...)",
          "53: #endif",
          "55: void scdf_mark_edge_feasible(scdf_ctx *scdf, int from, int to) {",
          "56:  uint32_t edge = scdf_edge(&scdf->ssa->cfg, from, to);",
          "58:  if (zend_bitset_in(scdf->feasible_edges, edge)) {",
          "60:   return;",
          "61:  }",
          "63:  DEBUG_PRINT(\"Marking edge %d->%d feasible\\n\", from, to);",
          "64:  zend_bitset_incl(scdf->feasible_edges, edge);",
          "66:  if (!zend_bitset_in(scdf->executable_blocks, to)) {",
          "67:   if (!zend_bitset_in(scdf->block_worklist, to)) {",
          "68:    DEBUG_PRINT(\"Adding block %d to worklist\\n\", to);",
          "69:   }",
          "70:   zend_bitset_incl(scdf->block_worklist, to);",
          "71:  } else {",
          "74:   zend_ssa_block *ssa_block = &scdf->ssa->blocks[to];",
          "75:   zend_ssa_phi *phi;",
          "76:   for (phi = ssa_block->phis; phi; phi = phi->next) {",
          "77:    zend_bitset_excl(scdf->phi_var_worklist, phi->ssa_var);",
          "78:    scdf->handlers.visit_phi(scdf, phi);",
          "79:   }",
          "80:  }",
          "81: }",
          "83: void scdf_init(zend_optimizer_ctx *ctx, scdf_ctx *scdf, zend_op_array *op_array, zend_ssa *ssa) {",
          "84:  uint32_t edges_count = 0;",
          "85:  int b;",
          "87:  for (b = 0; b < ssa->cfg.blocks_count; b++) {",
          "88:   edges_count += ssa->cfg.blocks[b].predecessors_count;",
          "89:  }",
          "91:  scdf->op_array = op_array;",
          "92:  scdf->ssa = ssa;",
          "94:  scdf->instr_worklist_len = zend_bitset_len(op_array->last);",
          "95:  scdf->phi_var_worklist_len = zend_bitset_len(ssa->vars_count);",
          "96:  scdf->block_worklist_len = zend_bitset_len(ssa->cfg.blocks_count);",
          "98:  scdf->instr_worklist = zend_arena_calloc(&ctx->arena,",
          "99:   scdf->instr_worklist_len + scdf->phi_var_worklist_len + 2 * scdf->block_worklist_len + zend_bitset_len(edges_count),",
          "100:   sizeof(zend_ulong));",
          "102:  scdf->phi_var_worklist = scdf->instr_worklist + scdf->instr_worklist_len;",
          "103:  scdf->block_worklist = scdf->phi_var_worklist + scdf->phi_var_worklist_len;",
          "104:  scdf->executable_blocks = scdf->block_worklist + scdf->block_worklist_len;",
          "105:  scdf->feasible_edges = scdf->executable_blocks + scdf->block_worklist_len;",
          "107:  zend_bitset_incl(scdf->block_worklist, 0);",
          "108:  zend_bitset_incl(scdf->executable_blocks, 0);",
          "109: }",
          "111: void scdf_solve(scdf_ctx *scdf, const char *name) {",
          "112:  zend_ssa *ssa = scdf->ssa;",
          "113:  DEBUG_PRINT(\"Start SCDF solve (%s)\\n\", name);",
          "114:  while (!zend_bitset_empty(scdf->instr_worklist, scdf->instr_worklist_len)",
          "115:   || !zend_bitset_empty(scdf->phi_var_worklist, scdf->phi_var_worklist_len)",
          "116:   || !zend_bitset_empty(scdf->block_worklist, scdf->block_worklist_len)",
          "117:  ) {",
          "118:   int i;",
          "119:   while ((i = zend_bitset_pop_first(scdf->phi_var_worklist, scdf->phi_var_worklist_len)) >= 0) {",
          "120:    zend_ssa_phi *phi = ssa->vars[i].definition_phi;",
          "121:    ZEND_ASSERT(phi);",
          "122:    if (zend_bitset_in(scdf->executable_blocks, phi->block)) {",
          "123:     scdf->handlers.visit_phi(scdf, phi);",
          "124:    }",
          "125:   }",
          "127:   while ((i = zend_bitset_pop_first(scdf->instr_worklist, scdf->instr_worklist_len)) >= 0) {",
          "128:    int block_num = ssa->cfg.map[i];",
          "129:    if (zend_bitset_in(scdf->executable_blocks, block_num)) {",
          "130:     zend_basic_block *block = &ssa->cfg.blocks[block_num];",
          "131:     zend_op *opline = &scdf->op_array->opcodes[i];",
          "132:     zend_ssa_op *ssa_op = &ssa->ops[i];",
          "133:     if (opline->opcode == ZEND_OP_DATA) {",
          "134:      opline--;",
          "135:      ssa_op--;",
          "136:     }",
          "137:     scdf->handlers.visit_instr(scdf, opline, ssa_op);",
          "138:     if (i == block->start + block->len - 1) {",
          "139:      if (block->successors_count == 1) {",
          "140:       scdf_mark_edge_feasible(scdf, block_num, block->successors[0]);",
          "141:      } else if (block->successors_count > 1) {",
          "142:       scdf->handlers.mark_feasible_successors(scdf, block_num, block, opline, ssa_op);",
          "143:      }",
          "144:     }",
          "145:    }",
          "146:   }",
          "148:   while ((i = zend_bitset_pop_first(scdf->block_worklist, scdf->block_worklist_len)) >= 0) {",
          "150:    zend_basic_block *block = &ssa->cfg.blocks[i];",
          "151:    zend_ssa_block *ssa_block = &ssa->blocks[i];",
          "153:    DEBUG_PRINT(\"Pop block %d from worklist\\n\", i);",
          "154:    zend_bitset_incl(scdf->executable_blocks, i);",
          "156:    {",
          "157:     zend_ssa_phi *phi;",
          "158:     for (phi = ssa_block->phis; phi; phi = phi->next) {",
          "159:      zend_bitset_excl(scdf->phi_var_worklist, phi->ssa_var);",
          "160:      scdf->handlers.visit_phi(scdf, phi);",
          "161:     }",
          "162:    }",
          "164:    if (block->len == 0) {",
          "166:     scdf_mark_edge_feasible(scdf, i, block->successors[0]);",
          "167:    } else {",
          "168:     zend_op *opline;",
          "169:     int j, end = block->start + block->len;",
          "170:     for (j = block->start; j < end; j++) {",
          "171:      opline = &scdf->op_array->opcodes[j];",
          "172:      zend_bitset_excl(scdf->instr_worklist, j);",
          "173:      if (opline->opcode != ZEND_OP_DATA) {",
          "174:       scdf->handlers.visit_instr(scdf, opline, &ssa->ops[j]);",
          "175:      }",
          "176:     }",
          "177:     if (block->successors_count == 1) {",
          "178:      scdf_mark_edge_feasible(scdf, i, block->successors[0]);",
          "179:     } else if (block->successors_count > 1) {",
          "180:      if (opline->opcode == ZEND_OP_DATA) {",
          "181:       opline--;",
          "182:       j--;",
          "183:      }",
          "184:      scdf->handlers.mark_feasible_successors(scdf, i, block, opline, &ssa->ops[j-1]);",
          "185:     }",
          "186:    }",
          "187:   }",
          "188:  }",
          "189: }",
          "194: static zend_bool kept_alive_by_live_range(scdf_ctx *scdf, uint32_t block) {",
          "195:  uint32_t i;",
          "196:  const zend_op_array *op_array = scdf->op_array;",
          "197:  const zend_cfg *cfg = &scdf->ssa->cfg;",
          "198:  for (i = 0; i < op_array->last_live_range; i++) {",
          "199:   zend_live_range *live_range = &op_array->live_range[i];",
          "200:   uint32_t start_block = cfg->map[live_range->start];",
          "201:   uint32_t end_block = cfg->map[live_range->end];",
          "203:   if (end_block == block && start_block != block",
          "204:     && zend_bitset_in(scdf->executable_blocks, start_block)) {",
          "205:    return 1;",
          "206:   }",
          "207:  }",
          "208:  return 0;",
          "209: }",
          "214: int scdf_remove_unreachable_blocks(scdf_ctx *scdf) {",
          "215:  zend_ssa *ssa = scdf->ssa;",
          "216:  int i;",
          "217:  int removed_ops = 0;",
          "219:  for (i = 0; i < ssa->cfg.blocks_count; i++) {",
          "220:   if (!zend_bitset_in(scdf->executable_blocks, i)",
          "221:     && (ssa->cfg.blocks[i].flags & ZEND_BB_REACHABLE)",
          "222:     && !kept_alive_by_live_range(scdf, i)) {",
          "223:    removed_ops += ssa->cfg.blocks[i].len;",
          "224:    zend_ssa_remove_block(scdf->op_array, ssa, i);",
          "225:   }",
          "226:  }",
          "227:  return removed_ops;",
          "228: }",
          "",
          "---------------"
        ],
        "ext/opcache/Optimizer/scdf.h||ext/opcache/Optimizer/scdf.h": [
          "File: ext/opcache/Optimizer/scdf.h -> ext/opcache/Optimizer/scdf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2:    +----------------------------------------------------------------------+",
          "3:    | Zend Engine, Call Graph                                              |",
          "4:    +----------------------------------------------------------------------+",
          "5:    | Copyright (c) 1998-2017 The PHP Group                                |",
          "6:    +----------------------------------------------------------------------+",
          "7:    | This source file is subject to version 3.01 of the PHP license,      |",
          "8:    | that is bundled with this package in the file LICENSE, and is        |",
          "9:    | available through the world-wide-web at the following url:           |",
          "10:    | http://www.php.net/license/3_01.txt                                  |",
          "11:    | If you did not receive a copy of the PHP license and are unable to   |",
          "12:    | obtain it through the world-wide-web, please send a note to          |",
          "13:    | license@php.net so we can mail you a copy immediately.               |",
          "14:    +----------------------------------------------------------------------+",
          "15:    | Authors: Nikita Popov <nikic@php.net>                                |",
          "16:    +----------------------------------------------------------------------+",
          "19: #ifndef _SCDF_H",
          "20: #define _SCDF_H",
          "22: #include \"zend_bitset.h\"",
          "24: typedef struct _scdf_ctx {",
          "25:  zend_op_array *op_array;",
          "26:  zend_ssa *ssa;",
          "27:  zend_bitset instr_worklist;",
          "29:  zend_bitset phi_var_worklist;",
          "30:  zend_bitset block_worklist;",
          "31:  zend_bitset executable_blocks;",
          "33:  zend_bitset feasible_edges;",
          "34:  uint32_t instr_worklist_len;",
          "35:  uint32_t phi_var_worklist_len;",
          "36:  uint32_t block_worklist_len;",
          "38:  struct {",
          "39:   void (*visit_instr)(",
          "40:    struct _scdf_ctx *scdf, zend_op *opline, zend_ssa_op *ssa_op);",
          "41:   void (*visit_phi)(",
          "42:    struct _scdf_ctx *scdf, zend_ssa_phi *phi);",
          "43:   void (*mark_feasible_successors)(",
          "44:    struct _scdf_ctx *scdf, int block_num, zend_basic_block *block,",
          "45:    zend_op *opline, zend_ssa_op *ssa_op);",
          "46:  } handlers;",
          "47: } scdf_ctx;",
          "49: void scdf_init(zend_optimizer_ctx *ctx, scdf_ctx *scdf, zend_op_array *op_array, zend_ssa *ssa);",
          "50: void scdf_solve(scdf_ctx *scdf, const char *name);",
          "52: int scdf_remove_unreachable_blocks(scdf_ctx *scdf);",
          "55: static inline void scdf_add_to_worklist(scdf_ctx *scdf, int var_num) {",
          "56:  zend_ssa *ssa = scdf->ssa;",
          "57:  zend_ssa_var *var = &ssa->vars[var_num];",
          "58:  int use;",
          "59:  zend_ssa_phi *phi;",
          "60:  FOREACH_USE(var, use) {",
          "61:   zend_bitset_incl(scdf->instr_worklist, use);",
          "62:  } FOREACH_USE_END();",
          "63:  FOREACH_PHI_USE(var, phi) {",
          "64:   zend_bitset_incl(scdf->phi_var_worklist, phi->ssa_var);",
          "65:  } FOREACH_PHI_USE_END();",
          "66: }",
          "69: static inline void scdf_add_def_to_worklist(scdf_ctx *scdf, int var_num) {",
          "70:  zend_ssa_var *var = &scdf->ssa->vars[var_num];",
          "71:  if (var->definition >= 0) {",
          "72:   zend_bitset_incl(scdf->instr_worklist, var->definition);",
          "73:  } else if (var->definition_phi) {",
          "74:   zend_bitset_incl(scdf->phi_var_worklist, var_num);",
          "75:  }",
          "76: }",
          "78: static inline uint32_t scdf_edge(zend_cfg *cfg, int from, int to) {",
          "79:  zend_basic_block *to_block = cfg->blocks + to;",
          "80:  int i;",
          "82:  for (i = 0; i < to_block->predecessors_count; i++) {",
          "83:   uint32_t edge = to_block->predecessor_offset + i;",
          "85:   if (cfg->predecessors[edge] == from) {",
          "86:    return edge;",
          "87:   }",
          "88:  }",
          "89:  ZEND_ASSERT(0);",
          "90: }",
          "92: static inline zend_bool scdf_is_edge_feasible(scdf_ctx *scdf, int from, int to) {",
          "93:  uint32_t edge = scdf_edge(&scdf->ssa->cfg, from, to);",
          "94:  return zend_bitset_in(scdf->feasible_edges, edge);",
          "95: }",
          "97: void scdf_mark_edge_feasible(scdf_ctx *scdf, int from, int to);",
          "99: #endif",
          "",
          "---------------"
        ],
        "ext/opcache/Optimizer/ssa_integrity.c||ext/opcache/Optimizer/ssa_integrity.c": [
          "File: ext/opcache/Optimizer/ssa_integrity.c -> ext/opcache/Optimizer/ssa_integrity.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2:    +----------------------------------------------------------------------+",
          "3:    | Zend Engine, SSA validation                                          |",
          "4:    +----------------------------------------------------------------------+",
          "5:    | Copyright (c) 1998-2017 The PHP Group                                |",
          "6:    +----------------------------------------------------------------------+",
          "7:    | This source file is subject to version 3.01 of the PHP license,      |",
          "8:    | that is bundled with this package in the file LICENSE, and is        |",
          "9:    | available through the world-wide-web at the following url:           |",
          "10:    | http://www.php.net/license/3_01.txt                                  |",
          "11:    | If you did not receive a copy of the PHP license and are unable to   |",
          "12:    | obtain it through the world-wide-web, please send a note to          |",
          "13:    | license@php.net so we can mail you a copy immediately.               |",
          "14:    +----------------------------------------------------------------------+",
          "15:    | Authors: Nikita Popov <nikic@php.net>                                |",
          "16:    +----------------------------------------------------------------------+",
          "19: #include \"ZendAccelerator.h\"",
          "20: #include \"Optimizer/zend_optimizer_internal.h\"",
          "25: static inline zend_bool is_in_use_chain(zend_ssa *ssa, int var, int check) {",
          "26:  int use;",
          "27:  FOREACH_USE(&ssa->vars[var], use) {",
          "28:   if (use == check) {",
          "29:    return 1;",
          "30:   }",
          "31:  } FOREACH_USE_END();",
          "32:  return 0;",
          "33: }",
          "35: static inline zend_bool is_in_phi_use_chain(zend_ssa *ssa, int var, zend_ssa_phi *check) {",
          "36:  zend_ssa_phi *phi;",
          "37:  FOREACH_PHI_USE(&ssa->vars[var], phi) {",
          "38:   if (phi == check) {",
          "39:    return 1;",
          "40:   }",
          "41:  } FOREACH_PHI_USE_END();",
          "42:  return 0;",
          "43: }",
          "45: static inline zend_bool is_used_by_op(zend_ssa *ssa, int op, int check) {",
          "46:  zend_ssa_op *ssa_op = &ssa->ops[op];",
          "47:  return (ssa_op->op1_use == check)",
          "48:   || (ssa_op->op2_use == check)",
          "49:   || (ssa_op->result_use == check);",
          "50: }",
          "52: static inline zend_bool is_defined_by_op(zend_ssa *ssa, int op, int check) {",
          "53:  zend_ssa_op *ssa_op = &ssa->ops[op];",
          "54:  return (ssa_op->op1_def == check)",
          "55:   || (ssa_op->op2_def == check)",
          "56:   || (ssa_op->result_def == check);",
          "57: }",
          "59: static inline zend_bool is_in_phi_sources(zend_ssa *ssa, zend_ssa_phi *phi, int check) {",
          "60:  int source;",
          "61:  FOREACH_PHI_SOURCE(phi, source) {",
          "62:   if (source == check) {",
          "63:    return 1;",
          "64:   }",
          "65:  } FOREACH_PHI_SOURCE_END();",
          "66:  return 0;",
          "67: }",
          "69: static inline zend_bool is_in_predecessors(zend_cfg *cfg, zend_basic_block *block, int check) {",
          "70:  int i, *predecessors = &cfg->predecessors[block->predecessor_offset];",
          "71:  for (i = 0; i < block->predecessors_count; i++) {",
          "72:   if (predecessors[i] == check) {",
          "73:    return 1;",
          "74:   }",
          "75:  }",
          "76:  return 0;",
          "77: }",
          "79: static inline zend_bool is_in_successors(zend_basic_block *block, int check) {",
          "80:  int s;",
          "81:  for (s = 0; s < block->successors_count; s++) {",
          "82:   if (block->successors[s] == check) {",
          "83:    return 1;",
          "84:   }",
          "85:  }",
          "86:  return 0;",
          "87: }",
          "89: static inline zend_bool is_var_type(zend_uchar type) {",
          "90:  return type == IS_CV || type == IS_VAR || type == IS_TMP_VAR;",
          "91: }",
          "93: #define FAIL(...) do { \\",
          "94:  if (status == SUCCESS) { \\",
          "95:   fprintf(stderr, \"\\nIn function %s::%s (%s):\\n\", \\",
          "96:    op_array->scope ? ZSTR_VAL(op_array->scope->name) : \"\", \\",
          "97:    op_array->function_name ? ZSTR_VAL(op_array->function_name) : \"{main}\", extra); \\",
          "98:  } \\",
          "99:  fprintf(stderr, __VA_ARGS__); \\",
          "100:  status = FAILURE; \\",
          "101: } while (0)",
          "103: #define VARFMT \"%d (%s%s)\"",
          "104: #define VAR(i) \\",
          "105:  (i), (ssa->vars[i].var < op_array->last_var ? \"CV $\" : \"TMP\"), \\",
          "106:  (ssa->vars[i].var < op_array->last_var ? ZSTR_VAL(op_array->vars[ssa->vars[i].var]) : \"\")",
          "108: #define INSTRFMT \"%d (%s)\"",
          "109: #define INSTR(i) \\",
          "110:  (i), (zend_get_opcode_name(op_array->opcodes[i].opcode))",
          "112: int ssa_verify_integrity(zend_op_array *op_array, zend_ssa *ssa, const char *extra) {",
          "113:  zend_cfg *cfg = &ssa->cfg;",
          "114:  zend_ssa_phi *phi;",
          "115:  int i, status = SUCCESS;",
          "118:  for (i = 0; i < ssa->vars_count; i++) {",
          "119:   zend_ssa_var *var = &ssa->vars[i];",
          "120:   int use, c;",
          "121:   uint32_t type = ssa->var_info[i].type;",
          "123:   if (var->definition < 0 && !var->definition_phi && i > op_array->last_var) {",
          "124:    if (var->use_chain >= 0) {",
          "125:     FAIL(\"var \" VARFMT \" without def has op uses\\n\", VAR(i));",
          "126:    }",
          "127:    if (var->phi_use_chain) {",
          "128:     FAIL(\"var \" VARFMT \" without def has phi uses\\n\", VAR(i));",
          "129:    }",
          "130:   }",
          "131:   if (var->definition >= 0 && var->definition_phi) {",
          "132:    FAIL(\"var \" VARFMT \" has both def and def_phi\\n\", VAR(i));",
          "133:   }",
          "134:   if (var->definition >= 0) {",
          "135:    if (!is_defined_by_op(ssa, var->definition, i)) {",
          "136:     FAIL(\"var \" VARFMT \" not defined by op \" INSTRFMT \"\\n\",",
          "137:       VAR(i), INSTR(var->definition));",
          "138:    }",
          "139:   }",
          "140:   if (var->definition_phi) {",
          "141:    if (var->definition_phi->ssa_var != i) {",
          "142:     FAIL(\"var \" VARFMT \" not defined by given phi\\n\", VAR(i));",
          "143:    }",
          "144:   }",
          "146:   c = 0;",
          "147:   FOREACH_USE(var, use) {",
          "148:    if (++c > 10000) {",
          "149:     FAIL(\"cycle in uses of \" VARFMT \"\\n\", VAR(i));",
          "150:     return status;",
          "151:    }",
          "152:    if (!is_used_by_op(ssa, use, i)) {",
          "153:     fprintf(stderr, \"var \" VARFMT \" not in uses of op %d\\n\", VAR(i), use);",
          "154:    }",
          "155:   } FOREACH_USE_END();",
          "157:   c = 0;",
          "158:   FOREACH_PHI_USE(var, phi) {",
          "159:    if (++c > 10000) {",
          "160:     FAIL(\"cycle in phi uses of \" VARFMT \"\\n\", VAR(i));",
          "161:     return status;",
          "162:    }",
          "163:    if (!is_in_phi_sources(ssa, phi, i)) {",
          "164:     FAIL(\"var \" VARFMT \" not in phi sources of %d\\n\", VAR(i), phi->ssa_var);",
          "165:    }",
          "166:   } FOREACH_PHI_USE_END();",
          "168:   if ((type & MAY_BE_ARRAY_KEY_ANY) && !(type & MAY_BE_ARRAY_OF_ANY)) {",
          "169:    FAIL(\"var \" VARFMT \" has array key type but not value type\\n\", VAR(i));",
          "170:   }",
          "171:   if ((type & MAY_BE_ARRAY_OF_ANY) && !(type & MAY_BE_ARRAY_KEY_ANY)) {",
          "172:    FAIL(\"var \" VARFMT \" has array value type but not key type\\n\", VAR(i));",
          "173:   }",
          "174:  }",
          "177:  FOREACH_INSTR_NUM(i) {",
          "178:   zend_ssa_op *ssa_op = &ssa->ops[i];",
          "179:   zend_op *opline = &op_array->opcodes[i];",
          "180:   if (is_var_type(opline->op1_type)) {",
          "181:    if (ssa_op->op1_use < 0 && ssa_op->op1_def < 0) {",
          "182:     FAIL(\"var op1 of \" INSTRFMT \" does not use/def an ssa var\\n\", INSTR(i));",
          "183:    }",
          "184:   } else {",
          "185:    if (ssa_op->op1_use >= 0 || ssa_op->op1_def >= 0) {",
          "186:     FAIL(\"non-var op1 of \" INSTRFMT \" uses or defs an ssa var\\n\", INSTR(i));",
          "187:    }",
          "188:   }",
          "189:   if (is_var_type(opline->op2_type)) {",
          "190:    if (ssa_op->op2_use < 0 && ssa_op->op2_def < 0) {",
          "191:     FAIL(\"var op2 of \" INSTRFMT \" does not use/def an ssa var\\n\", INSTR(i));",
          "192:    }",
          "193:   } else {",
          "194:    if (ssa_op->op2_use >= 0 || ssa_op->op2_def >= 0) {",
          "195:     FAIL(\"non-var op2 of \" INSTRFMT \" uses or defs an ssa var\\n\", INSTR(i));",
          "196:    }",
          "197:   }",
          "198:   if (is_var_type(opline->result_type)) {",
          "199:    if (ssa_op->result_use < 0 && ssa_op->result_def < 0) {",
          "200:     FAIL(\"var result of \" INSTRFMT \" does not use/def an ssa var\\n\", INSTR(i));",
          "201:    }",
          "202:   } else {",
          "203:    if (ssa_op->result_use >= 0 || ssa_op->result_def >= 0) {",
          "204:     FAIL(\"non-var result of \" INSTRFMT \" uses or defs an ssa var\\n\", INSTR(i));",
          "205:    }",
          "206:   }",
          "208:   if (ssa_op->op1_use >= 0) {",
          "209:    if (ssa_op->op1_use >= ssa->vars_count) {",
          "210:     FAIL(\"op1 use %d out of range\\n\", ssa_op->op1_use);",
          "211:    }",
          "212:    if (!is_in_use_chain(ssa, ssa_op->op1_use, i)) {",
          "213:     FAIL(\"op1 use of \" VARFMT \" in \" INSTRFMT \" not in use chain\\n\",",
          "214:       VAR(ssa_op->op1_use), INSTR(i));",
          "215:    }",
          "216:    if (VAR_NUM(opline->op1.var) != ssa->vars[ssa_op->op1_use].var) {",
          "217:     FAIL(\"op1 use of \" VARFMT \" does not match op %d of \" INSTRFMT \"\\n\",",
          "218:       VAR(ssa_op->op1_use), VAR_NUM(opline->op1.var), INSTR(i));",
          "219:    }",
          "220:   }",
          "221:   if (ssa_op->op2_use >= 0) {",
          "222:    if (ssa_op->op2_use >= ssa->vars_count) {",
          "223:     FAIL(\"op2 use %d out of range\\n\", ssa_op->op2_use);",
          "224:    }",
          "225:    if (!is_in_use_chain(ssa, ssa_op->op2_use, i)) {",
          "226:     FAIL(\"op1 use of \" VARFMT \" in \" INSTRFMT \" not in use chain\\n\",",
          "227:       VAR(ssa_op->op2_use), INSTR(i));",
          "228:    }",
          "229:    if (VAR_NUM(opline->op2.var) != ssa->vars[ssa_op->op2_use].var) {",
          "230:     FAIL(\"op2 use of \" VARFMT \" does not match op %d of \" INSTRFMT \"\\n\",",
          "231:       VAR(ssa_op->op2_use), VAR_NUM(opline->op2.var), INSTR(i));",
          "232:    }",
          "233:   }",
          "234:   if (ssa_op->result_use >= 0) {",
          "235:    if (ssa_op->result_use >= ssa->vars_count) {",
          "236:     FAIL(\"result use %d out of range\\n\", ssa_op->result_use);",
          "237:    }",
          "238:    if (!is_in_use_chain(ssa, ssa_op->result_use, i)) {",
          "239:     FAIL(\"result use of \" VARFMT \" in \" INSTRFMT \" not in use chain\\n\",",
          "240:      VAR(ssa_op->result_use), INSTR(i));",
          "241:    }",
          "242:    if (VAR_NUM(opline->result.var) != ssa->vars[ssa_op->result_use].var) {",
          "243:     FAIL(\"result use of \" VARFMT \" does not match op %d of \" INSTRFMT \"\\n\",",
          "244:       VAR(ssa_op->result_use), VAR_NUM(opline->result.var), INSTR(i));",
          "245:    }",
          "246:   }",
          "247:   if (ssa_op->op1_def >= 0) {",
          "248:    if (ssa_op->op1_def >= ssa->vars_count) {",
          "249:     FAIL(\"op1 def %d out of range\\n\", ssa_op->op1_def);",
          "250:    }",
          "251:    if (ssa->vars[ssa_op->op1_def].definition != i) {",
          "252:     FAIL(\"op1 def of \" VARFMT \" in \" INSTRFMT \" invalid\\n\",",
          "253:       VAR(ssa_op->op1_def), INSTR(i));",
          "254:    }",
          "255:    if (VAR_NUM(opline->op1.var) != ssa->vars[ssa_op->op1_def].var) {",
          "256:     FAIL(\"op1 def of \" VARFMT \" does not match op %d of \" INSTRFMT \"\\n\",",
          "257:       VAR(ssa_op->op1_def), VAR_NUM(opline->op1.var), INSTR(i));",
          "258:    }",
          "259:   }",
          "260:   if (ssa_op->op2_def >= 0) {",
          "261:    if (ssa_op->op2_def >= ssa->vars_count) {",
          "262:     FAIL(\"op2 def %d out of range\\n\", ssa_op->op2_def);",
          "263:    }",
          "264:    if (ssa->vars[ssa_op->op2_def].definition != i) {",
          "265:     FAIL(\"op2 def of \" VARFMT \" in \" INSTRFMT \" invalid\\n\",",
          "266:       VAR(ssa_op->op2_def), INSTR(i));",
          "267:    }",
          "268:    if (VAR_NUM(opline->op2.var) != ssa->vars[ssa_op->op2_def].var) {",
          "269:     FAIL(\"op2 def of \" VARFMT \" does not match op %d of \" INSTRFMT \"\\n\",",
          "270:       VAR(ssa_op->op2_def), VAR_NUM(opline->op2.var), INSTR(i));",
          "271:    }",
          "272:   }",
          "273:   if (ssa_op->result_def >= 0) {",
          "274:    if (ssa_op->result_def >= ssa->vars_count) {",
          "275:     FAIL(\"result def %d out of range\\n\", ssa_op->result_def);",
          "276:    }",
          "277:    if (ssa->vars[ssa_op->result_def].definition != i) {",
          "278:     FAIL(\"result def of \" VARFMT \" in \" INSTRFMT \" invalid\\n\",",
          "279:       VAR(ssa_op->result_def), INSTR(i));",
          "280:    }",
          "281:    if (VAR_NUM(opline->result.var) != ssa->vars[ssa_op->result_def].var) {",
          "282:     FAIL(\"result def of \" VARFMT \" does not match op %d of \" INSTRFMT \"\\n\",",
          "283:       VAR(ssa_op->result_def), VAR_NUM(opline->result.var), INSTR(i));",
          "284:    }",
          "285:   }",
          "286:  } FOREACH_INSTR_NUM_END();",
          "289:  FOREACH_PHI(phi) {",
          "290:   int source;",
          "291:   FOREACH_PHI_SOURCE(phi, source) {",
          "292:    if (source < 0) {",
          "293:     FAIL(VARFMT \" negative source\\n\", VAR(phi->ssa_var));",
          "294:    }",
          "295:    if (!is_in_phi_use_chain(ssa, source, phi)) {",
          "296:     FAIL(VARFMT \" not in phi use chain of %d\\n\", VAR(phi->ssa_var), source);",
          "297:    }",
          "298:    if (ssa->vars[source].var != ssa->vars[phi->ssa_var].var) {",
          "299:     FAIL(VARFMT \" source of phi for \" VARFMT \"\\n\", VAR(source), VAR(phi->ssa_var));",
          "300:    }",
          "301:   } FOREACH_PHI_SOURCE_END();",
          "302:   if (ssa->vars[phi->ssa_var].definition_phi != phi) {",
          "303:    FAIL(VARFMT \" does not define this phi\\n\", VAR(phi->ssa_var));",
          "304:   }",
          "305:  } FOREACH_PHI_END();",
          "308:  for (i = 0; i < cfg->blocks_count; i++) {",
          "309:   zend_basic_block *block = &cfg->blocks[i];",
          "310:   int *predecessors = &cfg->predecessors[block->predecessor_offset];",
          "311:   int s, j;",
          "313:   if (i != 0 && block->start < (block-1)->start + (block-1)->len) {",
          "314:    FAIL(\"Block %d start %d smaller previous end %d\\n\",",
          "315:     i, block->start, (block-1)->start + (block-1)->len);",
          "316:   }",
          "317:   if (i != cfg->blocks_count-1 && block->start + block->len > (block+1)->start) {",
          "318:    FAIL(\"Block %d end %d greater next start %d\\n\",",
          "319:     i, block->start + block->len, (block+1)->start);",
          "320:   }",
          "322:   for (j = block->start; j < block->start + block->len; j++) {",
          "323:    if (cfg->map[j] != i) {",
          "324:     FAIL(\"Instr \" INSTRFMT \" not associated with block %d\\n\", INSTR(j), i);",
          "325:    }",
          "326:   }",
          "328:   if (!(block->flags & ZEND_BB_REACHABLE)) {",
          "329:    if (ssa->blocks[i].phis) {",
          "330:     FAIL(\"Unreachable block %d has phis\\n\", i);",
          "331:    }",
          "332:    continue;",
          "333:   }",
          "335:   for (s = 0; s < block->successors_count; s++) {",
          "336:    zend_basic_block *next_block;",
          "337:    if (block->successors[s] < 0) {",
          "338:     FAIL(\"Successor number %d of %d negative\", s, i);",
          "339:    }",
          "340:    next_block = &cfg->blocks[block->successors[s]];",
          "341:    if (!(next_block->flags & ZEND_BB_REACHABLE)) {",
          "342:     FAIL(\"Successor %d of %d not reachable\\n\", block->successors[s], i);",
          "343:    }",
          "344:    if (!is_in_predecessors(cfg, next_block, i)) {",
          "345:     FAIL(\"Block %d predecessors missing %d\\n\", block->successors[s], i);",
          "346:    }",
          "347:   }",
          "349:   for (j = 0; j < block->predecessors_count; j++) {",
          "350:    if (predecessors[j] >= 0) {",
          "351:     int k;",
          "352:     zend_basic_block *prev_block = &cfg->blocks[predecessors[j]];",
          "353:     if (!(prev_block->flags & ZEND_BB_REACHABLE)) {",
          "354:      FAIL(\"Predecessor %d of %d not reachable\\n\", predecessors[j], i);",
          "355:     }",
          "356:     if (!is_in_successors(prev_block, i)) {",
          "357:      FAIL(\"Block %d successors missing %d\\n\", predecessors[j], i);",
          "358:     }",
          "359:     for (k = 0; k < block->predecessors_count; k++) {",
          "360:      if (k != j && predecessors[k] == predecessors[j]) {",
          "361:       FAIL(\"Block %d has duplicate predecessor %d\\n\", i, predecessors[j]);",
          "362:      }",
          "363:     }",
          "364:    }",
          "365:   }",
          "366:  }",
          "368:  return status;",
          "369: }",
          "",
          "---------------"
        ],
        "ext/opcache/Optimizer/zend_cfg.c||ext/opcache/Optimizer/zend_cfg.c": [
          "File: ext/opcache/Optimizer/zend_cfg.c -> ext/opcache/Optimizer/zend_cfg.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "441:      flags |= ZEND_FUNC_INDIRECT_VAR_ACCESS;",
          "442:     }",
          "443:     break;",
          "444:   }",
          "445:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "444:    case ZEND_FUNC_GET_ARGS:",
          "445:     flags |= ZEND_FUNC_VARARG;",
          "446:     break;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "599:  zend_mark_reachable_blocks(op_array, cfg, 0);",
          "603:  if (func_flags) {",
          "",
          "[Removed Lines]",
          "601:  cfg->dynamic = (flags & ZEND_FUNC_INDIRECT_VAR_ACCESS);",
          "",
          "[Added Lines]",
          "604:  cfg->dynamic = (flags & ZEND_FUNC_INDIRECT_VAR_ACCESS) != 0;",
          "605:  cfg->vararg = (flags & ZEND_FUNC_VARARG) != 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "646:  for (j = 0; j < cfg->blocks_count; j++) {",
          "647:   if (blocks[j].flags & ZEND_BB_REACHABLE) {",
          "648:    for (s = 0; s < blocks[j].successors_count; s++) {",
          "652:    }",
          "653:   }",
          "654:  }",
          "",
          "[Removed Lines]",
          "649:     zend_basic_block *b = blocks + blocks[j].successors[s];",
          "650:     predecessors[b->predecessor_offset + b->predecessors_count] = j;",
          "651:     b->predecessors_count++;",
          "",
          "[Added Lines]",
          "654:     if (s == 0 || blocks[j].successors[s-1] != blocks[j].successors[s]) {",
          "655:      zend_basic_block *b = blocks + blocks[j].successors[s];",
          "657:      predecessors[b->predecessor_offset + b->predecessors_count] = j;",
          "658:      b->predecessors_count++;",
          "659:     }",
          "",
          "---------------"
        ],
        "ext/opcache/Optimizer/zend_cfg.h||ext/opcache/Optimizer/zend_cfg.h": [
          "File: ext/opcache/Optimizer/zend_cfg.h -> ext/opcache/Optimizer/zend_cfg.h"
        ],
        "ext/opcache/Optimizer/zend_inference.c||ext/opcache/Optimizer/zend_inference.c": [
          "File: ext/opcache/Optimizer/zend_inference.c -> ext/opcache/Optimizer/zend_inference.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "282:     }",
          "283:    } else {",
          "284:     for (j = 0; j < ssa->cfg.blocks[p->block].predecessors_count; j++) {",
          "287:       zend_bitset_incl(worklist, p->sources[j]);",
          "288:      }",
          "",
          "[Removed Lines]",
          "285:      if (p->sources[j] >= 0 && ssa->vars[p->sources[j]].no_val) {",
          "",
          "[Added Lines]",
          "285:      ZEND_ASSERT(p->sources[j] >= 0);",
          "286:      if (ssa->vars[p->sources[j]].no_val) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "854:    }",
          "855:   } else {",
          "856:    for (i = 0; i < ssa->cfg.blocks[p->block].predecessors_count; i++) {",
          "859:      tmp->underflow |= ssa->var_info[p->sources[i]].range.underflow;",
          "860:      tmp->min = MIN(tmp->min, ssa->var_info[p->sources[i]].range.min);",
          "",
          "[Removed Lines]",
          "857:     if (p->sources[i] >= 0 && ssa->var_info[p->sources[i]].has_range) {",
          "",
          "[Added Lines]",
          "858:     ZEND_ASSERT(p->sources[i] >= 0);",
          "859:     if (ssa->var_info[p->sources[i]].has_range) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3328:     }",
          "3329:     UPDATE_SSA_TYPE(tmp, j);",
          "3330:     for (i = 0; i < blocks[p->block].predecessors_count; i++) {",
          "3342:       }",
          "3343:      }",
          "3344:     }",
          "",
          "[Removed Lines]",
          "3331:      if (p->sources[i] >= 0) {",
          "3332:       zend_ssa_var_info *info = &ssa_var_info[p->sources[i]];",
          "3333:       if (info->type & MAY_BE_OBJECT) {",
          "3334:        if (first) {",
          "3335:         ce = info->ce;",
          "3336:         is_instanceof = info->is_instanceof;",
          "3337:         first = 0;",
          "3338:        } else {",
          "3339:         is_instanceof |= info->is_instanceof;",
          "3340:         ce = join_class_entries(ce, info->ce, &is_instanceof);",
          "3341:        }",
          "",
          "[Added Lines]",
          "3333:      zend_ssa_var_info *info;",
          "3335:      ZEND_ASSERT(p->sources[i] >= 0);",
          "3336:      info = &ssa_var_info[p->sources[i]];",
          "3337:      if (info->type & MAY_BE_OBJECT) {",
          "3338:       if (first) {",
          "3339:        ce = info->ce;",
          "3340:        is_instanceof = info->is_instanceof;",
          "3341:        first = 0;",
          "3342:       } else {",
          "3343:        is_instanceof |= info->is_instanceof;",
          "3344:        ce = join_class_entries(ce, info->ce, &is_instanceof);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3924:  free_alloca(worklist, use_heap);",
          "3925: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3930: int zend_may_throw(const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)",
          "3931: {",
          "3932:  uint32_t t1 = OP1_INFO();",
          "3933:  uint32_t t2 = OP2_INFO();",
          "3935:  if (opline->op1_type == IS_CV) {",
          "3936:   if (t1 & MAY_BE_UNDEF) {",
          "3937:    switch (opline->opcode) {",
          "3938:     case ZEND_UNSET_VAR:",
          "3939:     case ZEND_ISSET_ISEMPTY_VAR:",
          "3940:      if (opline->extended_value & ZEND_QUICK_SET) {",
          "3941:       break;",
          "3942:      }",
          "3943:      return 1;",
          "3944:     case ZEND_ISSET_ISEMPTY_DIM_OBJ:",
          "3945:     case ZEND_ISSET_ISEMPTY_PROP_OBJ:",
          "3946:     case ZEND_ASSIGN:",
          "3947:     case ZEND_ASSIGN_DIM:",
          "3948:     case ZEND_ASSIGN_REF:",
          "3949:     case ZEND_BIND_GLOBAL:",
          "3950:     case ZEND_FETCH_DIM_IS:",
          "3951:     case ZEND_FETCH_OBJ_IS:",
          "3952:     case ZEND_SEND_REF:",
          "3953:      break;",
          "3954:     default:",
          "3956:      return 1;",
          "3957:    }",
          "3958:   }",
          "3959:     } else if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {",
          "3960:   if (t1 & (MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_ARRAY_OF_OBJECT|MAY_BE_ARRAY_OF_RESOURCE|MAY_BE_ARRAY_OF_ARRAY)) {",
          "3961:    switch (opline->opcode) {",
          "3962:     case ZEND_CASE:",
          "3963:     case ZEND_FE_FETCH_R:",
          "3964:     case ZEND_FE_FETCH_RW:",
          "3965:     case ZEND_FETCH_LIST:",
          "3966:     case ZEND_QM_ASSIGN:",
          "3967:     case ZEND_SEND_VAL:",
          "3968:     case ZEND_SEND_VAL_EX:",
          "3969:     case ZEND_SEND_VAR:",
          "3970:     case ZEND_SEND_VAR_EX:",
          "3971:     case ZEND_SEND_VAR_NO_REF:",
          "3972:     case ZEND_SEND_VAR_NO_REF_EX:",
          "3973:     case ZEND_SEND_REF:",
          "3974:     case ZEND_SEPARATE:",
          "3975:     case ZEND_END_SILENCE:",
          "3976:      break;",
          "3977:     default:",
          "3979:      return 1;",
          "3980:    }",
          "3981:   }",
          "3982:     }",
          "3984:     if (opline->op2_type == IS_CV) {",
          "3985:   if (t2 & MAY_BE_UNDEF) {",
          "3986:    switch (opline->opcode) {",
          "3987:     case ZEND_ASSIGN_REF:",
          "3988:      break;",
          "3989:     default:",
          "3991:      return 1;",
          "3992:    }",
          "3993:   }",
          "3994:  } else if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {",
          "3995:   if (t2 & (MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_ARRAY_OF_OBJECT|MAY_BE_ARRAY_OF_RESOURCE|MAY_BE_ARRAY_OF_ARRAY)) {",
          "3996:    switch (opline->opcode) {",
          "3997:     case ZEND_ASSIGN:",
          "3998:      break;",
          "3999:     default:",
          "4001:      return 1;",
          "4002:    }",
          "4003:   }",
          "4004:     }",
          "4006:  switch (opline->opcode) {",
          "4007:   case ZEND_NOP:",
          "4008:   case ZEND_IS_IDENTICAL:",
          "4009:   case ZEND_IS_NOT_IDENTICAL:",
          "4010:   case ZEND_QM_ASSIGN:",
          "4011:   case ZEND_JMP:",
          "4012:   case ZEND_CHECK_VAR:",
          "4013:   case ZEND_MAKE_REF:",
          "4014:   case ZEND_SEND_VAR:",
          "4015:   case ZEND_BEGIN_SILENCE:",
          "4016:   case ZEND_END_SILENCE:",
          "4017:   case ZEND_SEND_VAL:",
          "4018:   case ZEND_SEND_REF:",
          "4019:   case ZEND_SEND_VAR_EX:",
          "4020:   case ZEND_FREE:",
          "4021:   case ZEND_SEPARATE:",
          "4022:   case ZEND_TYPE_CHECK:",
          "4023:   case ZEND_DEFINED:",
          "4024:   case ZEND_ISSET_ISEMPTY_THIS:",
          "4025:   case ZEND_COALESCE:",
          "4026:   case ZEND_SWITCH_LONG:",
          "4027:   case ZEND_SWITCH_STRING:",
          "4028:   case ZEND_ISSET_ISEMPTY_VAR:",
          "4029:    return 0;",
          "4030:   case ZEND_INIT_FCALL:",
          "4032:    return 0;",
          "4033:   case ZEND_BIND_GLOBAL:",
          "4034:    if ((opline+1)->opcode == ZEND_BIND_GLOBAL) {",
          "4035:     return zend_may_throw(opline + 1, op_array, ssa);",
          "4036:    }",
          "4037:    return 0;",
          "4038:   case ZEND_ADD:",
          "4039:    if ((t1 & MAY_BE_ANY) == MAY_BE_ARRAY",
          "4040:     && (t2 & MAY_BE_ANY) == MAY_BE_ARRAY) {",
          "4041:     return 0;",
          "4042:    }",
          "4043:    return (t1 & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT)) ||",
          "4044:     (t2 & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT));",
          "4045:   case ZEND_DIV:",
          "4046:   case ZEND_MOD:",
          "4047:    if (!OP2_HAS_RANGE() ||",
          "4048:     (OP2_MIN_RANGE() <= 0 && OP2_MAX_RANGE() >= 0)) {",
          "4050:     return 1;",
          "4051:    }",
          "4053:   case ZEND_SUB:",
          "4054:   case ZEND_MUL:",
          "4055:   case ZEND_POW:",
          "4056:    return (t1 & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT)) ||",
          "4057:     (t2 & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT));",
          "4058:   case ZEND_SL:",
          "4059:   case ZEND_SR:",
          "4060:    return (t1 & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT)) ||",
          "4061:     (t2 & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT)) ||",
          "4062:     !OP2_HAS_RANGE() ||",
          "4063:     OP2_MIN_RANGE() < 0;",
          "4064:   case ZEND_CONCAT:",
          "4065:   case ZEND_FAST_CONCAT:",
          "4066:    return (t1 & (MAY_BE_ARRAY|MAY_BE_OBJECT)) ||",
          "4067:     (t2 & (MAY_BE_ARRAY|MAY_BE_OBJECT));",
          "4068:   case ZEND_BW_OR:",
          "4069:   case ZEND_BW_AND:",
          "4070:   case ZEND_BW_XOR:",
          "4071:    if ((t1 & MAY_BE_ANY) == MAY_BE_STRING",
          "4072:     && (t2 & MAY_BE_ANY) == MAY_BE_STRING) {",
          "4073:     return 0;",
          "4074:    }",
          "4075:    return (t1 & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT)) ||",
          "4076:     (t2 & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT));",
          "4077:   case ZEND_BW_NOT:",
          "4078:    return (t1 & (MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE));",
          "4079:   case ZEND_BOOL_NOT:",
          "4080:   case ZEND_PRE_INC:",
          "4081:   case ZEND_POST_INC:",
          "4082:   case ZEND_PRE_DEC:",
          "4083:   case ZEND_POST_DEC:",
          "4084:   case ZEND_JMPZ:",
          "4085:   case ZEND_JMPNZ:",
          "4086:   case ZEND_JMPZNZ:",
          "4087:   case ZEND_JMPZ_EX:",
          "4088:   case ZEND_JMPNZ_EX:",
          "4089:   case ZEND_BOOL:",
          "4090:   case ZEND_JMP_SET:",
          "4091:    return (t1 & MAY_BE_OBJECT);",
          "4092:   case ZEND_BOOL_XOR:",
          "4093:    return (t1 & MAY_BE_OBJECT) || (t2 & MAY_BE_OBJECT);",
          "4094:   case ZEND_IS_EQUAL:",
          "4095:   case ZEND_IS_NOT_EQUAL:",
          "4096:   case ZEND_IS_SMALLER:",
          "4097:   case ZEND_IS_SMALLER_OR_EQUAL:",
          "4098:   case ZEND_CASE:",
          "4099:   case ZEND_SPACESHIP:",
          "4100:    if ((t1 & MAY_BE_ANY) == MAY_BE_NULL",
          "4101:     || (t2 & MAY_BE_ANY) == MAY_BE_NULL) {",
          "4102:     return 0;",
          "4103:    }",
          "4104:    return (t1 & (MAY_BE_OBJECT|MAY_BE_ARRAY_OF_ARRAY|MAY_BE_ARRAY_OF_OBJECT)) || (t2 & (MAY_BE_OBJECT|MAY_BE_ARRAY_OF_ARRAY|MAY_BE_ARRAY_OF_OBJECT));",
          "4105:   case ZEND_ASSIGN_ADD:",
          "4106:    if (opline->extended_value != 0) {",
          "4107:     return 1;",
          "4108:    }",
          "4109:    if ((t1 & MAY_BE_ANY) == MAY_BE_ARRAY",
          "4110:     && (t2 & MAY_BE_ANY) == MAY_BE_ARRAY) {",
          "4111:     return 0;",
          "4112:    }",
          "4113:    return (t1 & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT)) ||",
          "4114:     (t2 & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT));",
          "4115:   case ZEND_ASSIGN_DIV:",
          "4116:   case ZEND_ASSIGN_MOD:",
          "4117:    if (opline->extended_value != 0) {",
          "4118:     return 1;",
          "4119:    }",
          "4120:    if (!OP2_HAS_RANGE() ||",
          "4121:     (OP2_MIN_RANGE() <= 0 && OP2_MAX_RANGE() >= 0)) {",
          "4123:     return 1;",
          "4124:    }",
          "4126:   case ZEND_ASSIGN_SUB:",
          "4127:   case ZEND_ASSIGN_MUL:",
          "4128:   case ZEND_ASSIGN_POW:",
          "4129:    if (opline->extended_value != 0) {",
          "4130:     return 1;",
          "4131:    }",
          "4132:    return (t1 & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT)) ||",
          "4133:     (t2 & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT));",
          "4134:   case ZEND_ASSIGN_SL:",
          "4135:   case ZEND_ASSIGN_SR:",
          "4136:    if (opline->extended_value != 0) {",
          "4137:     return 1;",
          "4138:    }",
          "4139:    return (t1 & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT)) ||",
          "4140:     (t2 & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT)) ||",
          "4141:     !OP2_HAS_RANGE() ||",
          "4142:     OP2_MIN_RANGE() < 0;",
          "4143:   case ZEND_ASSIGN_CONCAT:",
          "4144:    if (opline->extended_value != 0) {",
          "4145:     return 1;",
          "4146:    }",
          "4147:    return (t1 & (MAY_BE_ARRAY|MAY_BE_OBJECT)) ||",
          "4148:     (t2 & (MAY_BE_ARRAY|MAY_BE_OBJECT));",
          "4149:   case ZEND_ASSIGN_BW_OR:",
          "4150:   case ZEND_ASSIGN_BW_AND:",
          "4151:   case ZEND_ASSIGN_BW_XOR:",
          "4152:    if (opline->extended_value != 0) {",
          "4153:     return 1;",
          "4154:    }",
          "4155:    if ((t1 & MAY_BE_ANY) == MAY_BE_STRING",
          "4156:     && (t2 & MAY_BE_ANY) == MAY_BE_STRING) {",
          "4157:     return 0;",
          "4158:    }",
          "4159:    return (t1 & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT)) ||",
          "4160:     (t2 & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT));",
          "4161:   case ZEND_ASSIGN:",
          "4162:   case ZEND_UNSET_VAR:",
          "4163:    return (t1 & (MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_ARRAY_OF_OBJECT|MAY_BE_ARRAY_OF_RESOURCE|MAY_BE_ARRAY_OF_ARRAY));",
          "4164:   case ZEND_ASSIGN_DIM:",
          "4165:    return (t1 & (MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_TRUE|MAY_BE_STRING|MAY_BE_LONG|MAY_BE_DOUBLE)) || opline->op2_type == IS_UNUSED ||",
          "4166:     (t2 & (MAY_BE_UNDEF|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE));",
          "4167:   case ZEND_ROPE_INIT:",
          "4168:   case ZEND_ROPE_ADD:",
          "4169:   case ZEND_ROPE_END:",
          "4170:    return t2 & (MAY_BE_ARRAY|MAY_BE_OBJECT);",
          "4171:   case ZEND_INIT_ARRAY:",
          "4172:   case ZEND_ADD_ARRAY_ELEMENT:",
          "4173:    return (opline->op2_type != IS_UNUSED) && (t2 & (MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE));",
          "4174:   case ZEND_STRLEN:",
          "4175:    return (t1 & MAY_BE_ANY) != MAY_BE_STRING;",
          "4176:   case ZEND_COUNT:",
          "4177:    return (t1 & MAY_BE_ANY) != MAY_BE_ARRAY;",
          "4178:   case ZEND_RECV_INIT:",
          "4179:    if (Z_CONSTANT_P(CRT_CONSTANT_EX(op_array, opline->op2, ssa->rt_constants))) {",
          "4180:     return 1;",
          "4181:    }",
          "4182:    if (op_array->fn_flags & ZEND_ACC_HAS_TYPE_HINTS) {",
          "4183:     uint32_t arg_num = opline->op1.num;",
          "4184:     zend_arg_info *cur_arg_info;",
          "4186:     if (EXPECTED(arg_num <= op_array->num_args)) {",
          "4187:      cur_arg_info = &op_array->arg_info[arg_num-1];",
          "4188:     } else if (UNEXPECTED(op_array->fn_flags & ZEND_ACC_VARIADIC)) {",
          "4189:      cur_arg_info = &op_array->arg_info[op_array->num_args];",
          "4190:     } else {",
          "4191:      return 0;",
          "4192:     }",
          "4193:     return ZEND_TYPE_IS_SET(cur_arg_info->type);",
          "4194:    } else {",
          "4195:     return 0;",
          "4196:    }",
          "4197:   case ZEND_FETCH_IS:",
          "4198:    return (t2 & (MAY_BE_ARRAY|MAY_BE_OBJECT));",
          "4199:   case ZEND_ISSET_ISEMPTY_DIM_OBJ:",
          "4200:    return (t1 & MAY_BE_OBJECT) || (t2 & (MAY_BE_ARRAY|MAY_BE_OBJECT));",
          "4201:   case ZEND_FETCH_DIM_IS:",
          "4202:    return (t1 & MAY_BE_OBJECT) || (t2 & (MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE));",
          "4203:   case ZEND_CAST:",
          "4204:    switch (opline->extended_value) {",
          "4205:     case IS_NULL:",
          "4206:      return 0;",
          "4207:     case _IS_BOOL:",
          "4208:      return (t1 & MAY_BE_OBJECT);",
          "4209:     case IS_LONG:",
          "4210:     case IS_DOUBLE:",
          "4211:      return (t1 & MAY_BE_OBJECT);",
          "4212:     case IS_STRING:",
          "4213:      return (t1 & (MAY_BE_ARRAY|MAY_BE_OBJECT));",
          "4214:     case IS_ARRAY:",
          "4215:      return (t1 & MAY_BE_OBJECT);",
          "4216:     case IS_OBJECT:",
          "4217:      return (t1 & MAY_BE_ARRAY);",
          "4218:     default:",
          "4219:      return 1;",
          "4220:    }",
          "4221:   default:",
          "4222:    return 1;",
          "4223:  }",
          "4224: }",
          "",
          "---------------"
        ],
        "ext/opcache/Optimizer/zend_inference.h||ext/opcache/Optimizer/zend_inference.h": [
          "File: ext/opcache/Optimizer/zend_inference.h -> ext/opcache/Optimizer/zend_inference.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: #define DEFINE_SSA_OP_HAS_RANGE(opN) \\",
          "37:  static zend_always_inline zend_bool _ssa_##opN##_has_range(const zend_op_array *op_array, const zend_ssa *ssa, const zend_op *opline) \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "35: #define MAY_HAVE_DTOR \\",
          "36:  (MAY_BE_OBJECT|MAY_BE_RESOURCE \\",
          "37:  |MAY_BE_ARRAY_OF_ARRAY|MAY_BE_ARRAY_OF_OBJECT|MAY_BE_ARRAY_OF_RESOURCE)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "263:                            int                    widening,",
          "264:                            zend_ssa_var_info     *ret);",
          "266: END_EXTERN_C()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "269: int zend_may_throw(const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa);",
          "",
          "---------------"
        ],
        "ext/opcache/Optimizer/zend_optimizer.c||ext/opcache/Optimizer/zend_optimizer.c": [
          "File: ext/opcache/Optimizer/zend_optimizer.c -> ext/opcache/Optimizer/zend_optimizer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "53:  zend_hash_add(ctx->constants, Z_STR_P(name), &val);",
          "54: }",
          "57: {",
          "58:  binary_op_type binary_op = get_binary_op(opcode);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "56: zend_uchar zend_compound_assign_to_binary_op(zend_uchar opcode)",
          "57: {",
          "58:  switch (opcode) {",
          "59:   case ZEND_ASSIGN_ADD: return ZEND_ADD;",
          "60:   case ZEND_ASSIGN_SUB: return ZEND_SUB;",
          "61:   case ZEND_ASSIGN_MUL: return ZEND_MUL;",
          "62:   case ZEND_ASSIGN_DIV: return ZEND_DIV;",
          "63:   case ZEND_ASSIGN_MOD: return ZEND_MOD;",
          "64:   case ZEND_ASSIGN_SL: return ZEND_SL;",
          "65:   case ZEND_ASSIGN_SR: return ZEND_SR;",
          "66:   case ZEND_ASSIGN_CONCAT: return ZEND_CONCAT;",
          "67:   case ZEND_ASSIGN_BW_OR: return ZEND_BW_OR;",
          "68:   case ZEND_ASSIGN_BW_AND: return ZEND_BW_AND;",
          "69:   case ZEND_ASSIGN_BW_XOR: return ZEND_BW_XOR;",
          "70:   case ZEND_ASSIGN_POW: return ZEND_POW;",
          "71:   EMPTY_SWITCH_DEFAULT_CASE()",
          "72:  }",
          "73: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "237:                                     zend_op       *opline,",
          "238:                                     zval          *val)",
          "239: {",
          "240:  switch (opline->opcode) {",
          "241:   case ZEND_FREE:",
          "242:    MAKE_NOP(opline);",
          "243:    zval_ptr_dtor_nogc(val);",
          "244:    return 1;",
          "245:   case ZEND_INIT_STATIC_METHOD_CALL:",
          "246:   case ZEND_CATCH:",
          "247:   case ZEND_FETCH_CONSTANT:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "259:  zend_op *target_opline;",
          "262:   case ZEND_JMPZ:",
          "263:    if (zend_is_true(val)) {",
          "264:     MAKE_NOP(opline);",
          "265:    } else {",
          "266:     opline->opcode = ZEND_JMP;",
          "267:     COPY_NODE(opline->op1, opline->op2);",
          "268:     opline->op2_type = IS_UNUSED;",
          "269:    }",
          "270:    zval_ptr_dtor_nogc(val);",
          "271:    return 1;",
          "272:   case ZEND_JMPNZ:",
          "273:    if (zend_is_true(val)) {",
          "274:     opline->opcode = ZEND_JMP;",
          "275:     COPY_NODE(opline->op1, opline->op2);",
          "276:     opline->op2_type = IS_UNUSED;",
          "277:    } else {",
          "278:     MAKE_NOP(opline);",
          "279:    }",
          "280:    zval_ptr_dtor_nogc(val);",
          "281:    return 1;",
          "282:   case ZEND_JMPZNZ:",
          "283:    if (zend_is_true(val)) {",
          "284:     target_opline = ZEND_OFFSET_TO_OPLINE(opline, opline->extended_value);",
          "285:    } else {",
          "286:     target_opline = ZEND_OP2_JMP_ADDR(opline);",
          "287:    }",
          "288:    ZEND_SET_OP_JMP_ADDR(opline, opline->op1, target_opline);",
          "289:    opline->op1_type = IS_UNUSED;",
          "290:    opline->extended_value = 0;",
          "291:    opline->opcode = ZEND_JMP;",
          "292:    zval_ptr_dtor_nogc(val);",
          "293:    return 1;",
          "298:   case ZEND_SEND_VAR_EX:",
          "299:   case ZEND_FETCH_DIM_W:",
          "300:   case ZEND_FETCH_DIM_RW:",
          "301:   case ZEND_FETCH_DIM_FUNC_ARG:",
          "302:   case ZEND_FETCH_DIM_UNSET:",
          "303:   case ZEND_ASSIGN_DIM:",
          "304:   case ZEND_RETURN_BY_REF:",
          "305:    return 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "305:                                     zend_op       *opline,",
          "306:                                     zval          *val)",
          "307: {",
          "308:  switch (opline->opcode) {",
          "309:   case ZEND_ASSIGN_REF:",
          "310:   case ZEND_FAST_CALL:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "369:  zval tmp;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "331:    break;",
          "332:   case ZEND_INIT_FCALL:",
          "333:    REQUIRES_STRING(val);",
          "335:    opline->op2.constant = zend_optimizer_add_literal(op_array, val);",
          "336:    alloc_cache_slots_op2(op_array, opline, 1);",
          "337:    break;",
          "",
          "[Removed Lines]",
          "334:    zend_str_tolower(Z_STRVAL_P(val), Z_STRLEN_P(val));",
          "",
          "[Added Lines]",
          "397:    if (Z_REFCOUNT_P(val) == 1) {",
          "398:     zend_str_tolower(Z_STRVAL_P(val), Z_STRLEN_P(val));",
          "399:    } else {",
          "400:     ZVAL_STR(&tmp, zend_string_tolower(Z_STR_P(val)));",
          "401:     zval_ptr_dtor_nogc(val);",
          "402:     val = &tmp;",
          "403:    }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "482:  }",
          "483: }",
          "485: int zend_optimizer_replace_by_const(zend_op_array *op_array,",
          "486:                                     zend_op       *opline,",
          "487:                                     zend_uchar     type,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "554: void zend_optimizer_remove_live_range_ex(zend_op_array *op_array, uint32_t var, uint32_t start)",
          "555: {",
          "556:  uint32_t i = 0;",
          "558:  while (i < op_array->last_live_range) {",
          "559:   if (op_array->live_range[i].var == var",
          "560:     && op_array->live_range[i].start == start) {",
          "561:    op_array->last_live_range--;",
          "562:    if (i < op_array->last_live_range) {",
          "563:     memmove(&op_array->live_range[i], &op_array->live_range[i+1], (op_array->last_live_range - i) * sizeof(zend_live_range));",
          "564:    }",
          "565:    break;",
          "566:   }",
          "567:   i++;",
          "568:  }",
          "569: }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "977:   zend_optimizer_compact_literals(op_array, ctx);",
          "978:   if (ctx->debug_level & ZEND_DUMP_AFTER_PASS_11) {",
          "979:    zend_dump_op_array(op_array, 0, \"after pass 11\", NULL);",
          "980:   }",
          "981:  }",
          "983:  if (ZEND_OPTIMIZER_PASS_7 & ctx->optimization_level) {",
          "984:   return;",
          "985:  }",
          "",
          "[Removed Lines]",
          "976:  if (ZEND_OPTIMIZER_PASS_11 & ctx->optimization_level) {",
          "",
          "[Added Lines]",
          "1062:  if ((ZEND_OPTIMIZER_PASS_11 & ctx->optimization_level) &&",
          "1063:      (!(ZEND_OPTIMIZER_PASS_6 & ctx->optimization_level) ||",
          "1064:       !(ZEND_OPTIMIZER_PASS_7 & ctx->optimization_level))) {",
          "1071:  if ((ZEND_OPTIMIZER_PASS_13 & ctx->optimization_level) &&",
          "1072:      (!(ZEND_OPTIMIZER_PASS_6 & ctx->optimization_level) ||",
          "1073:       !(ZEND_OPTIMIZER_PASS_7 & ctx->optimization_level))) {",
          "1074:   zend_optimizer_compact_vars(op_array);",
          "1075:   if (ctx->debug_level & ZEND_DUMP_AFTER_PASS_13) {",
          "1076:    zend_dump_op_array(op_array, 0, \"after pass 13\", NULL);",
          "1077:   }",
          "1078:  }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1176:   for (i = 0; i < call_graph.op_arrays_count; i++) {",
          "1177:    func_info = ZEND_FUNC_INFO(call_graph.op_arrays[i]);",
          "1178:    if (func_info) {",
          "1180:    }",
          "1181:   }",
          "",
          "[Removed Lines]",
          "1179:     zend_dfa_optimize_op_array(call_graph.op_arrays[i], &ctx, &func_info->ssa);",
          "",
          "[Added Lines]",
          "1276:     zend_dfa_optimize_op_array(call_graph.op_arrays[i], &ctx, &func_info->ssa, func_info->call_map);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1186:    }",
          "1187:   }",
          "1189:   if (ZEND_OPTIMIZER_PASS_12 & optimization_level) {",
          "1190:    for (i = 0; i < call_graph.op_arrays_count; i++) {",
          "1191:     zend_adjust_fcall_stack_size_graph(call_graph.op_arrays[i]);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1286:   if (ZEND_OPTIMIZER_PASS_11 & optimization_level) {",
          "1287:    for (i = 0; i < call_graph.op_arrays_count; i++) {",
          "1288:     zend_optimizer_compact_literals(call_graph.op_arrays[i], &ctx);",
          "1289:     if (debug_level & ZEND_DUMP_AFTER_PASS_11) {",
          "1290:      zend_dump_op_array(call_graph.op_arrays[i], 0, \"after pass 11\", NULL);",
          "1291:     }",
          "1292:    }",
          "1293:   }",
          "1295:   if (ZEND_OPTIMIZER_PASS_13 & optimization_level) {",
          "1296:    for (i = 0; i < call_graph.op_arrays_count; i++) {",
          "1297:     zend_optimizer_compact_vars(call_graph.op_arrays[i]);",
          "1298:     if (debug_level & ZEND_DUMP_AFTER_PASS_13) {",
          "1299:      zend_dump_op_array(call_graph.op_arrays[i], 0, \"after pass 13\", NULL);",
          "1300:     }",
          "1301:    }",
          "1302:   }",
          "",
          "---------------"
        ],
        "ext/opcache/Optimizer/zend_optimizer.h||ext/opcache/Optimizer/zend_optimizer.h": [
          "File: ext/opcache/Optimizer/zend_optimizer.h -> ext/opcache/Optimizer/zend_optimizer.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "35: #define ZEND_OPTIMIZER_PASS_8  (1<<7)",
          "40: #define ZEND_OPTIMIZER_PASS_13  (1<<12)",
          "41: #define ZEND_OPTIMIZER_PASS_14  (1<<13)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "ext/opcache/Optimizer/zend_optimizer_internal.h||ext/opcache/Optimizer/zend_optimizer_internal.h": [
          "File: ext/opcache/Optimizer/zend_optimizer_internal.h -> ext/opcache/Optimizer/zend_optimizer_internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #define ZEND_OPTIMIZER_INTERNAL_H",
          "25: #include \"zend_ssa.h\"",
          "27: #define ZEND_OP1_LITERAL(opline)  (op_array)->literals[(opline)->op1.constant]",
          "28: #define ZEND_OP1_JMP_ADDR(opline)  OP_JMP_ADDR(opline, (opline)->op1)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26: #include \"zend_func_info.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "91:                                      zval          *val);",
          "93: void zend_optimizer_remove_live_range(zend_op_array *op_array, uint32_t var);",
          "94: void zend_optimizer_pass1(zend_op_array *op_array, zend_optimizer_ctx *ctx);",
          "95: void zend_optimizer_pass2(zend_op_array *op_array);",
          "96: void zend_optimizer_pass3(zend_op_array *op_array);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "95: void zend_optimizer_remove_live_range_ex(zend_op_array *op_array, uint32_t var, uint32_t start);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "98: void zend_optimize_cfg(zend_op_array *op_array, zend_optimizer_ctx *ctx);",
          "99: void zend_optimize_dfa(zend_op_array *op_array, zend_optimizer_ctx *ctx);",
          "100: int  zend_dfa_analyze_op_array(zend_op_array *op_array, zend_optimizer_ctx *ctx, zend_ssa *ssa, uint32_t *flags);",
          "102: void zend_optimize_temporary_variables(zend_op_array *op_array, zend_optimizer_ctx *ctx);",
          "103: void zend_optimizer_nop_removal(zend_op_array *op_array);",
          "104: void zend_optimizer_compact_literals(zend_op_array *op_array, zend_optimizer_ctx *ctx);",
          "105: int zend_optimizer_is_disabled_func(const char *name, size_t len);",
          "106: zend_function *zend_optimizer_get_called_func(",
          "107:   zend_script *script, zend_op_array *op_array, zend_op *opline, zend_bool rt_constants);",
          "108: uint32_t zend_optimizer_classify_function(zend_string *name, uint32_t num_args);",
          "109: void zend_optimizer_migrate_jump(zend_op_array *op_array, zend_op *new_opline, zend_op *opline);",
          "110: void zend_optimizer_shift_jump(zend_op_array *op_array, zend_op *opline, uint32_t *shiftlist);",
          "112: #endif",
          "",
          "[Removed Lines]",
          "101: void zend_dfa_optimize_op_array(zend_op_array *op_array, zend_optimizer_ctx *ctx, zend_ssa *ssa);",
          "",
          "[Added Lines]",
          "103: void zend_dfa_optimize_op_array(zend_op_array *op_array, zend_optimizer_ctx *ctx, zend_ssa *ssa, zend_call_info **call_map);",
          "107: void zend_optimizer_compact_vars(zend_op_array *op_array);",
          "114: zend_uchar zend_compound_assign_to_binary_op(zend_uchar opcode);",
          "115: int sccp_optimize_op_array(zend_optimizer_ctx *ctx, zend_op_array *op_arrya, zend_ssa *ssa, zend_call_info **call_map);",
          "116: int dce_optimize_op_array(zend_op_array *op_array, zend_ssa *ssa, zend_bool reorder_dtor_effects);",
          "",
          "---------------"
        ],
        "ext/opcache/Optimizer/zend_ssa.c||ext/opcache/Optimizer/zend_ssa.c": [
          "File: ext/opcache/Optimizer/zend_ssa.c -> ext/opcache/Optimizer/zend_ssa.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "13:    | license@php.net so we can mail you a copy immediately.               |",
          "14:    +----------------------------------------------------------------------+",
          "15:    | Authors: Dmitry Stogov <dmitry@zend.com>                             |",
          "16:    +----------------------------------------------------------------------+",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16:    |          Nikita Popov <nikic@php.net>                                |",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "22: #include \"zend_ssa.h\"",
          "23: #include \"zend_dump.h\"",
          "24: #include \"zend_inference.h\"",
          "26: static zend_bool dominates(const zend_basic_block *blocks, int a, int b) {",
          "27:  while (blocks[b].level > blocks[a].level) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26: #include \"Optimizer/zend_optimizer_internal.h\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1059:    ssa_vars[phi->ssa_var].var = phi->var;",
          "1060:    ssa_vars[phi->ssa_var].definition_phi = phi;",
          "1061:    if (phi->pi >= 0) {",
          "1071:     }",
          "1072:     if (phi->has_range_constraint) {",
          "",
          "[Removed Lines]",
          "1062:     if (phi->sources[0] >= 0) {",
          "1063:      zend_ssa_phi *p = ssa_vars[phi->sources[0]].phi_use_chain;",
          "1064:      while (p && p != phi) {",
          "1065:       p = zend_ssa_next_use_phi(ssa, phi->sources[0], p);",
          "1066:      }",
          "1067:      if (!p) {",
          "1068:       phi->use_chains[0] = ssa_vars[phi->sources[0]].phi_use_chain;",
          "1069:       ssa_vars[phi->sources[0]].phi_use_chain = phi;",
          "1070:      }",
          "",
          "[Added Lines]",
          "1064:     zend_ssa_phi *p;",
          "1066:     ZEND_ASSERT(phi->sources[0] >= 0);",
          "1067:     p = ssa_vars[phi->sources[0]].phi_use_chain;",
          "1068:     while (p && p != phi) {",
          "1069:      p = zend_ssa_next_use_phi(ssa, phi->sources[0], p);",
          "1070:     }",
          "1071:     if (!p) {",
          "1072:      phi->use_chains[0] = ssa_vars[phi->sources[0]].phi_use_chain;",
          "1073:      ssa_vars[phi->sources[0]].phi_use_chain = phi;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1084:     int j;",
          "1086:     for (j = 0; j < ssa->cfg.blocks[i].predecessors_count; j++) {",
          "1096:      }",
          "1097:     }",
          "1098:    }",
          "",
          "[Removed Lines]",
          "1087:      if (phi->sources[j] >= 0) {",
          "1088:       zend_ssa_phi *p = ssa_vars[phi->sources[j]].phi_use_chain;",
          "1089:       while (p && p != phi) {",
          "1090:        p = zend_ssa_next_use_phi(ssa, phi->sources[j], p);",
          "1091:       }",
          "1092:       if (!p) {",
          "1093:        phi->use_chains[j] = ssa_vars[phi->sources[j]].phi_use_chain;",
          "1094:        ssa_vars[phi->sources[j]].phi_use_chain = phi;",
          "1095:       }",
          "",
          "[Added Lines]",
          "1090:      zend_ssa_phi *p;",
          "1092:      ZEND_ASSERT(phi->sources[j] >= 0);",
          "1093:      p = ssa_vars[phi->sources[j]].phi_use_chain;",
          "1094:      while (p && p != phi) {",
          "1095:       p = zend_ssa_next_use_phi(ssa, phi->sources[j], p);",
          "1096:      }",
          "1097:      if (!p) {",
          "1098:       phi->use_chains[j] = ssa_vars[phi->sources[j]].phi_use_chain;",
          "1099:       ssa_vars[phi->sources[j]].phi_use_chain = phi;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1161: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1169: {",
          "1170:  if (ssa_op->result_use >= 0) {",
          "1171:   zend_ssa_unlink_use_chain(ssa, ssa_op - ssa->ops, ssa_op->result_use);",
          "1172:   ssa_op->result_use = -1;",
          "1173:   ssa_op->res_use_chain = -1;",
          "1174:  }",
          "1175:  if (ssa_op->op1_use >= 0) {",
          "1176:   if (ssa_op->op1_use != ssa_op->op2_use) {",
          "1177:    zend_ssa_unlink_use_chain(ssa, ssa_op - ssa->ops, ssa_op->op1_use);",
          "1178:   } else {",
          "1179:    ssa_op->op2_use_chain = ssa_op->op1_use_chain;",
          "1180:   }",
          "1181:   ssa_op->op1_use = -1;",
          "1182:   ssa_op->op1_use_chain = -1;",
          "1183:  }",
          "1184:  if (ssa_op->op2_use >= 0) {",
          "1185:   zend_ssa_unlink_use_chain(ssa, ssa_op - ssa->ops, ssa_op->op2_use);",
          "1186:   ssa_op->op2_use = -1;",
          "1187:   ssa_op->op2_use_chain = -1;",
          "1188:  }",
          "1191:  ZEND_ASSERT(ssa_op->result_def == -1);",
          "1192:  ZEND_ASSERT(ssa_op->op1_def == -1);",
          "1193:  ZEND_ASSERT(ssa_op->op2_def == -1);",
          "1195:  MAKE_NOP(opline);",
          "1196: }",
          "1200: {",
          "1201:  if (p->pi >= 0) {",
          "1202:   return &p->use_chains[0];",
          "1203:  } else {",
          "1204:   int j;",
          "1205:   for (j = 0; j < ssa->cfg.blocks[p->block].predecessors_count; j++) {",
          "1206:    if (p->sources[j] == var) {",
          "1207:     return &p->use_chains[j];",
          "1208:    }",
          "1209:   }",
          "1210:  }",
          "1211:  ZEND_ASSERT(0);",
          "1212:  return NULL;",
          "1213: }",
          "1219: {",
          "1220:  zend_ssa_phi **cur = &ssa->vars[source].phi_use_chain;",
          "1221:  while (*cur && *cur != phi) {",
          "1222:   cur = zend_ssa_next_use_phi_ptr(ssa, source, *cur);",
          "1223:  }",
          "1224:  if (*cur) {",
          "1226:  }",
          "1227: }",
          "1231: {",
          "1232:  int source;",
          "1233:  FOREACH_PHI_SOURCE(phi, source) {",
          "1234:   zend_ssa_remove_use_of_phi_source(ssa, phi, source);",
          "1235:  } FOREACH_PHI_SOURCE_END();",
          "1236: }",
          "1240: {",
          "1241:  zend_ssa_block *block = &ssa->blocks[phi->block];",
          "1242:  zend_ssa_phi **cur = &block->phis;",
          "1243:  while (*cur != phi) {",
          "1244:   ZEND_ASSERT(*cur != NULL);",
          "1245:   cur = &(*cur)->next;",
          "1246:  }",
          "1248: }",
          "1252: {",
          "1253:  if (ssa_op->op1_def >= 0) {",
          "1254:   zend_ssa_remove_uses_of_var(ssa, ssa_op->op1_def);",
          "1255:   zend_ssa_remove_op1_def(ssa, ssa_op);",
          "1256:  }",
          "1257:  if (ssa_op->op2_def >= 0) {",
          "1258:   zend_ssa_remove_uses_of_var(ssa, ssa_op->op2_def);",
          "1259:   zend_ssa_remove_op2_def(ssa, ssa_op);",
          "1260:  }",
          "1261:  if (ssa_op->result_def >= 0) {",
          "1262:   zend_ssa_remove_uses_of_var(ssa, ssa_op->result_def);",
          "1263:   zend_ssa_remove_result_def(ssa, ssa_op);",
          "1264:  }",
          "1265: }",
          "1269: {",
          "1270:  int j, var_num = phi->sources[pred_offset];",
          "1272:  predecessors_count--;",
          "1273:  if (pred_offset < predecessors_count) {",
          "1274:   memmove(phi->sources + pred_offset, phi->sources + pred_offset + 1, (predecessors_count - pred_offset) * sizeof(uint32_t));",
          "1275:  }",
          "1279:  for (j = 0; j < predecessors_count; j++) {",
          "1280:   if (phi->sources[j] == var_num) {",
          "1281:    if (j < pred_offset) {",
          "1282:     ZEND_ASSERT(phi->use_chains[pred_offset] == NULL);",
          "1283:     return;",
          "1284:    }",
          "1285:    if (j >= pred_offset) {",
          "1286:     phi->use_chains[j] = phi->use_chains[pred_offset];",
          "1287:     phi->use_chains[pred_offset] = NULL;",
          "1288:     return;",
          "1289:    }",
          "1290:   }",
          "1291:  }",
          "1294:  zend_ssa_remove_use_of_phi_source(ssa, phi, var_num);",
          "1295:  phi->use_chains[pred_offset] = NULL;",
          "1296: }",
          "1300: {",
          "1301:  ZEND_ASSERT(phi->ssa_var >= 0);",
          "1302:  ZEND_ASSERT(ssa->vars[phi->ssa_var].use_chain < 0",
          "1303:   && ssa->vars[phi->ssa_var].phi_use_chain == NULL);",
          "1304:  zend_ssa_remove_uses_of_phi_sources(ssa, phi);",
          "1305:  zend_ssa_remove_phi_from_block(ssa, phi);",
          "1306:  ssa->vars[phi->ssa_var].definition_phi = NULL;",
          "1307:  phi->ssa_var = -1;",
          "1308: }",
          "1312: {",
          "1313:  zend_ssa_var *var = &ssa->vars[var_num];",
          "1314:  zend_ssa_phi *phi;",
          "1315:  int use;",
          "1316:  FOREACH_PHI_USE(var, phi) {",
          "1317:   int i, end = NUM_PHI_SOURCES(phi);",
          "1318:   for (i = 0; i < end; i++) {",
          "1319:    if (phi->sources[i] == var_num) {",
          "1320:     phi->use_chains[i] = NULL;",
          "1321:    }",
          "1322:   }",
          "1323:  } FOREACH_PHI_USE_END();",
          "1324:  var->phi_use_chain = NULL;",
          "1325:  FOREACH_USE(var, use) {",
          "1326:   zend_ssa_op *ssa_op = &ssa->ops[use];",
          "1327:   if (ssa_op->op1_use == var_num) {",
          "1328:    ssa_op->op1_use = -1;",
          "1329:    ssa_op->op1_use_chain = -1;",
          "1330:   }",
          "1331:   if (ssa_op->op2_use == var_num) {",
          "1332:    ssa_op->op2_use = -1;",
          "1333:    ssa_op->op2_use_chain = -1;",
          "1334:   }",
          "1335:   if (ssa_op->result_use == var_num) {",
          "1336:    ssa_op->result_use = -1;",
          "1337:    ssa_op->res_use_chain = -1;",
          "1338:   }",
          "1339:  } FOREACH_USE_END();",
          "1340:  var->use_chain = -1;",
          "1341: }",
          "1345: {",
          "1346:  zend_basic_block *block = &ssa->cfg.blocks[i];",
          "1347:  zend_ssa_block *ssa_block = &ssa->blocks[i];",
          "1348:  int *predecessors;",
          "1349:  zend_ssa_phi *phi;",
          "1350:  int j, s;",
          "1352:  block->flags &= ~ZEND_BB_REACHABLE;",
          "1355:  for (phi = ssa_block->phis; phi; phi = phi->next) {",
          "1356:   zend_ssa_remove_uses_of_var(ssa, phi->ssa_var);",
          "1357:   zend_ssa_remove_phi(ssa, phi);",
          "1358:  }",
          "1361:  for (j = block->start; j < block->start + block->len; j++) {",
          "1362:   if (op_array->opcodes[j].opcode == ZEND_NOP) {",
          "1363:    continue;",
          "1364:   }",
          "1366:   if (op_array->opcodes[j].result_type & (IS_TMP_VAR|IS_VAR)) {",
          "1367:    zend_optimizer_remove_live_range_ex(op_array, op_array->opcodes[j].result.var, j + 1);",
          "1368:   }",
          "1369:   zend_ssa_remove_defs_of_instr(ssa, &ssa->ops[j]);",
          "1370:   zend_ssa_remove_instr(ssa, &op_array->opcodes[j], &ssa->ops[j]);",
          "1371:  }",
          "1373:  for (s = 0; s < block->successors_count; s++) {",
          "1374:   zend_basic_block *next_block = &ssa->cfg.blocks[block->successors[s]];",
          "1375:   zend_ssa_block *next_ssa_block = &ssa->blocks[block->successors[s]];",
          "1376:   zend_ssa_phi *phi;",
          "1379:   int pred_offset = -1;",
          "1380:   predecessors = &ssa->cfg.predecessors[next_block->predecessor_offset];",
          "1381:   for (j = 0; j < next_block->predecessors_count; j++) {",
          "1382:    if (predecessors[j] == i) {",
          "1383:     pred_offset = j;",
          "1384:     break;",
          "1385:    }",
          "1386:   }",
          "1387:   ZEND_ASSERT(pred_offset != -1);",
          "1390:   for (phi = next_ssa_block->phis; phi; phi = phi->next) {",
          "1391:    if (phi->pi >= 0) {",
          "1392:     if (phi->pi == i) {",
          "1393:      zend_ssa_remove_uses_of_var(ssa, phi->ssa_var);",
          "1394:      zend_ssa_remove_phi(ssa, phi);",
          "1395:     }",
          "1396:    } else {",
          "1397:     ZEND_ASSERT(phi->sources[pred_offset] >= 0);",
          "1398:     zend_ssa_remove_phi_source(ssa, phi, pred_offset, next_block->predecessors_count);",
          "1399:    }",
          "1400:   }",
          "1403:   next_block->predecessors_count--;",
          "1404:   if (pred_offset < next_block->predecessors_count) {",
          "1405:    predecessors = &ssa->cfg.predecessors[next_block->predecessor_offset + pred_offset];",
          "1406:    memmove(predecessors, predecessors + 1, (next_block->predecessors_count - pred_offset) * sizeof(uint32_t));",
          "1407:   }",
          "1408:  }",
          "1411:  predecessors = &ssa->cfg.predecessors[block->predecessor_offset];",
          "1412:  for (j = 0; j < block->predecessors_count; j++) {",
          "1413:   if (predecessors[j] >= 0) {",
          "1414:    zend_basic_block *prev_block = &ssa->cfg.blocks[predecessors[j]];",
          "1416:    for (s = 0; s < prev_block->successors_count; s++) {",
          "1417:     if (prev_block->successors[s] == i) {",
          "1418:      memmove(prev_block->successors + s,",
          "1419:        prev_block->successors + s + 1,",
          "1420:        sizeof(int) * (prev_block->successors_count - s - 1));",
          "1421:      prev_block->successors_count--;",
          "1422:      s--;",
          "1423:     }",
          "1424:    }",
          "1425:   }",
          "1426:  }",
          "1428:  block->successors_count = 0;",
          "1429:  block->predecessors_count = 0;",
          "1432:  if (block->idom >= 0) {",
          "1433:   j = ssa->cfg.blocks[block->idom].children;",
          "1434:   if (j == i) {",
          "1435:    ssa->cfg.blocks[block->idom].children = block->next_child;",
          "1436:   } else if (j >= 0) {",
          "1437:    while (ssa->cfg.blocks[j].next_child >= 0) {",
          "1438:     if (ssa->cfg.blocks[j].next_child == i) {",
          "1439:      ssa->cfg.blocks[j].next_child = block->next_child;",
          "1440:      break;",
          "1441:     }",
          "1442:     j = ssa->cfg.blocks[j].next_child;",
          "1443:    }",
          "1444:   }",
          "1445:  }",
          "1446:  block->idom = -1;",
          "1447:  block->level = -1;",
          "1448:  block->children = -1;",
          "1449:  block->next_child = -1;",
          "1450: }",
          "1454: {",
          "1455:  zend_ssa_phi *phi;",
          "1456:  FOREACH_PHI_USE(&ssa->vars[var], phi) {",
          "1457:   if (ssa->var_info[var].type & ~ssa->var_info[phi->ssa_var].type) {",
          "1458:    ssa->var_info[phi->ssa_var].type |= ssa->var_info[var].type;",
          "1459:    propagate_phi_type_widening(ssa, phi->ssa_var);",
          "1460:   }",
          "1461:  } FOREACH_PHI_USE_END();",
          "1462: }",
          "1466: {",
          "1467:  zend_ssa_var *old_var = &ssa->vars[old];",
          "1468:  zend_ssa_var *new_var = &ssa->vars[new];",
          "1469:  int use;",
          "1470:  zend_ssa_phi *phi;",
          "1472:  ZEND_ASSERT(old >= 0 && new >= 0);",
          "1473:  ZEND_ASSERT(old != new);",
          "1476:  new_var->no_val &= old_var->no_val;",
          "1479:  FOREACH_USE(old_var, use) {",
          "1480:   zend_ssa_op *ssa_op = &ssa->ops[use];",
          "1484:   zend_bool add_to_use_chain = 1;",
          "1485:   if (ssa_op->result_use == new) {",
          "1486:    add_to_use_chain = 0;",
          "1487:   } else if (ssa_op->op1_use == new) {",
          "1488:    if (ssa_op->result_use == old) {",
          "1489:     ssa_op->res_use_chain = ssa_op->op1_use_chain;",
          "1490:     ssa_op->op1_use_chain = -1;",
          "1491:    }",
          "1492:    add_to_use_chain = 0;",
          "1493:   } else if (ssa_op->op2_use == new) {",
          "1494:    if (ssa_op->result_use == old) {",
          "1495:     ssa_op->res_use_chain = ssa_op->op2_use_chain;",
          "1496:     ssa_op->op2_use_chain = -1;",
          "1497:    } else if (ssa_op->op1_use == old) {",
          "1498:     ssa_op->op1_use_chain = ssa_op->op2_use_chain;",
          "1499:     ssa_op->op2_use_chain = -1;",
          "1500:    }",
          "1501:    add_to_use_chain = 0;",
          "1502:   }",
          "1505:   if (ssa_op->result_use == old) {",
          "1506:    ssa_op->result_use = new;",
          "1507:   }",
          "1508:   if (ssa_op->op1_use == old) {",
          "1509:    ssa_op->op1_use = new;",
          "1510:   }",
          "1511:   if (ssa_op->op2_use == old) {",
          "1512:    ssa_op->op2_use = new;",
          "1513:   }",
          "1517:   if (add_to_use_chain) {",
          "1518:    if (ssa_op->result_use == new) {",
          "1519:     ssa_op->res_use_chain = new_var->use_chain;",
          "1520:     new_var->use_chain = use;",
          "1521:    } else if (ssa_op->op1_use == new) {",
          "1522:     ssa_op->op1_use_chain = new_var->use_chain;",
          "1523:     new_var->use_chain = use;",
          "1524:    } else {",
          "1525:     ZEND_ASSERT(ssa_op->op2_use == new);",
          "1526:     ssa_op->op2_use_chain = new_var->use_chain;",
          "1527:     new_var->use_chain = use;",
          "1528:    }",
          "1529:   }",
          "1530:  } FOREACH_USE_END();",
          "1531:  old_var->use_chain = -1;",
          "1534:  FOREACH_PHI_USE(old_var, phi) {",
          "1535:   int j;",
          "1536:   zend_bool after_first_new_source = 0;",
          "1540:   zend_ssa_phi **existing_use_chain_ptr = NULL;",
          "1541:   for (j = 0; j < ssa->cfg.blocks[phi->block].predecessors_count; j++) {",
          "1542:    if (phi->sources[j] == new) {",
          "1543:     existing_use_chain_ptr = &phi->use_chains[j];",
          "1544:     break;",
          "1545:    }",
          "1546:   }",
          "1548:   for (j = 0; j < ssa->cfg.blocks[phi->block].predecessors_count; j++) {",
          "1549:    if (phi->sources[j] == new) {",
          "1550:     after_first_new_source = 1;",
          "1551:    } else if (phi->sources[j] == old) {",
          "1552:     phi->sources[j] = new;",
          "1556:     if (!after_first_new_source) {",
          "1557:      if (existing_use_chain_ptr) {",
          "1558:       phi->use_chains[j] = *existing_use_chain_ptr;",
          "1560:      } else {",
          "1561:       phi->use_chains[j] = new_var->phi_use_chain;",
          "1562:       new_var->phi_use_chain = phi;",
          "1563:      }",
          "1564:      after_first_new_source = 1;",
          "1565:     }",
          "1566:    }",
          "1567:   }",
          "1573:   if (update_types && (ssa->var_info[new].type & ~ssa->var_info[phi->ssa_var].type)) {",
          "1574:    ssa->var_info[phi->ssa_var].type |= ssa->var_info[new].type;",
          "1575:    propagate_phi_type_widening(ssa, phi->ssa_var);",
          "1576:   }",
          "1577:  } FOREACH_PHI_USE_END();",
          "1578:  old_var->phi_use_chain = NULL;",
          "1579: }",
          "",
          "---------------"
        ],
        "ext/opcache/Optimizer/zend_ssa.h||ext/opcache/Optimizer/zend_ssa.h": [
          "File: ext/opcache/Optimizer/zend_ssa.h -> ext/opcache/Optimizer/zend_ssa.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "139: int zend_ssa_compute_use_def_chains(zend_arena **arena, const zend_op_array *op_array, zend_ssa *ssa);",
          "140: int zend_ssa_unlink_use_chain(zend_ssa *ssa, int op, int var);",
          "142: END_EXTERN_C()",
          "144: static zend_always_inline int zend_ssa_next_use(const zend_ssa_op *ssa_op, int var, int use)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "142: void zend_ssa_remove_instr(zend_ssa *ssa, zend_op *opline, zend_ssa_op *ssa_op);",
          "143: void zend_ssa_remove_phi(zend_ssa *ssa, zend_ssa_phi *phi);",
          "144: void zend_ssa_remove_uses_of_var(zend_ssa *ssa, int var_num);",
          "145: void zend_ssa_remove_block(zend_op_array *op_array, zend_ssa *ssa, int b);",
          "146: void zend_ssa_rename_var_uses(zend_ssa *ssa, int old_var, int new_var, zend_bool update_types);",
          "148: static zend_always_inline void _zend_ssa_remove_def(zend_ssa_var *var)",
          "149: {",
          "150:  ZEND_ASSERT(var->definition >= 0);",
          "151:  ZEND_ASSERT(var->use_chain < 0);",
          "152:  ZEND_ASSERT(!var->phi_use_chain);",
          "153:  var->definition = -1;",
          "154: }",
          "156: static zend_always_inline void zend_ssa_remove_result_def(zend_ssa *ssa, zend_ssa_op *ssa_op)",
          "157: {",
          "158:  zend_ssa_var *var = &ssa->vars[ssa_op->result_def];",
          "159:  _zend_ssa_remove_def(var);",
          "160:  ssa_op->result_def = -1;",
          "161: }",
          "163: static zend_always_inline void zend_ssa_remove_op1_def(zend_ssa *ssa, zend_ssa_op *ssa_op)",
          "164: {",
          "165:  zend_ssa_var *var = &ssa->vars[ssa_op->op1_def];",
          "166:  _zend_ssa_remove_def(var);",
          "167:  ssa_op->op1_def = -1;",
          "168: }",
          "170: static zend_always_inline void zend_ssa_remove_op2_def(zend_ssa *ssa, zend_ssa_op *ssa_op)",
          "171: {",
          "172:  zend_ssa_var *var = &ssa->vars[ssa_op->op2_def];",
          "173:  _zend_ssa_remove_def(var);",
          "174:  ssa_op->op2_def = -1;",
          "175: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "180:  return 0;",
          "181: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "218: static zend_always_inline void zend_ssa_rename_defs_of_instr(zend_ssa *ssa, zend_ssa_op *ssa_op) {",
          "220:  if (ssa_op->op1_def >= 0) {",
          "221:   if (ssa_op->op1_use >= 0) {",
          "222:    zend_ssa_rename_var_uses(ssa, ssa_op->op1_def, ssa_op->op1_use, 1);",
          "223:   }",
          "224:   ssa->vars[ssa_op->op1_def].definition = -1;",
          "225:   ssa_op->op1_def = -1;",
          "226:  }",
          "227:  if (ssa_op->op2_def >= 0) {",
          "228:   if (ssa_op->op2_use >= 0) {",
          "229:    zend_ssa_rename_var_uses(ssa, ssa_op->op2_def, ssa_op->op2_use, 1);",
          "230:   }",
          "231:   ssa->vars[ssa_op->op2_def].definition = -1;",
          "232:   ssa_op->op2_def = -1;",
          "233:  }",
          "234:  if (ssa_op->result_def >= 0) {",
          "235:   if (ssa_op->result_use >= 0) {",
          "236:    zend_ssa_rename_var_uses(ssa, ssa_op->result_def, ssa_op->result_use, 1);",
          "237:   }",
          "238:   ssa->vars[ssa_op->result_def].definition = -1;",
          "239:   ssa_op->result_def = -1;",
          "240:  }",
          "241: }",
          "243: #define NUM_PHI_SOURCES(phi) \\",
          "244:  ((phi)->pi >= 0 ? 1 : (ssa->cfg.blocks[(phi)->block].predecessors_count))",
          "248: #define FOREACH_USE(var, use) do { \\",
          "249:  int _var_num = (var) - ssa->vars, next; \\",
          "250:  for (use = (var)->use_chain; use >= 0; use = next) { \\",
          "251:   next = zend_ssa_next_use(ssa->ops, _var_num, use);",
          "252: #define FOREACH_USE_END() \\",
          "253:  } \\",
          "254: } while (0)",
          "256: #define FOREACH_PHI_USE(var, phi) do { \\",
          "257:  int _var_num = (var) - ssa->vars; \\",
          "258:  zend_ssa_phi *next_phi; \\",
          "259:  for (phi = (var)->phi_use_chain; phi; phi = next_phi) { \\",
          "260:   next_phi = zend_ssa_next_use_phi(ssa, _var_num, phi);",
          "261: #define FOREACH_PHI_USE_END() \\",
          "262:  } \\",
          "263: } while (0)",
          "265: #define FOREACH_PHI_SOURCE(phi, source) do { \\",
          "266:  zend_ssa_phi *_phi = (phi); \\",
          "267:  int _i, _end = NUM_PHI_SOURCES(phi); \\",
          "268:  for (_i = 0; _i < _end; _i++) { \\",
          "269:   ZEND_ASSERT(_phi->sources[_i] >= 0); \\",
          "270:   source = _phi->sources[_i];",
          "271: #define FOREACH_PHI_SOURCE_END() \\",
          "272:  } \\",
          "273: } while (0)",
          "275: #define FOREACH_PHI(phi) do { \\",
          "276:  int _i; \\",
          "277:  for (_i = 0; _i < ssa->cfg.blocks_count; _i++) { \\",
          "278:   phi = ssa->blocks[_i].phis; \\",
          "279:   for (; phi; phi = phi->next) {",
          "280: #define FOREACH_PHI_END() \\",
          "281:   } \\",
          "282:  } \\",
          "283: } while (0)",
          "285: #define FOREACH_BLOCK(block) do { \\",
          "286:  int _i; \\",
          "287:  for (_i = 0; _i < ssa->cfg.blocks_count; _i++) { \\",
          "288:   (block) = &ssa->cfg.blocks[_i]; \\",
          "289:   if (!((block)->flags & ZEND_BB_REACHABLE)) { \\",
          "290:    continue; \\",
          "291:   }",
          "292: #define FOREACH_BLOCK_END() \\",
          "293:  } \\",
          "294: } while (0)",
          "297: #define FOREACH_INSTR_NUM(i) do { \\",
          "298:  zend_basic_block *_block; \\",
          "299:  FOREACH_BLOCK(_block) { \\",
          "300:   uint32_t _end = _block->start + _block->len; \\",
          "301:   for ((i) = _block->start; (i) < _end; (i)++) {",
          "302: #define FOREACH_INSTR_NUM_END() \\",
          "303:   } \\",
          "304:  } FOREACH_BLOCK_END(); \\",
          "305: } while (0)",
          "",
          "---------------"
        ],
        "ext/opcache/config.m4||ext/opcache/config.m4": [
          "File: ext/opcache/config.m4 -> ext/opcache/config.m4",
          "--- Hunk 1 ---",
          "[Context before]",
          "410:  Optimizer/zend_inference.c \\",
          "411:  Optimizer/zend_func_info.c \\",
          "412:  Optimizer/zend_call_graph.c \\",
          "413:  Optimizer/zend_dump.c,",
          "414:  shared,,-DZEND_ENABLE_STATIC_TSRMLS_CACHE=1,,yes)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "413:  Optimizer/sccp.c \\",
          "414:  Optimizer/scdf.c \\",
          "415:  Optimizer/dce.c \\",
          "416:  Optimizer/compact_vars.c \\",
          "",
          "---------------"
        ],
        "ext/opcache/config.w32||ext/opcache/config.w32": [
          "File: ext/opcache/config.w32 -> ext/opcache/config.w32",
          "--- Hunk 1 ---",
          "[Context before]",
          "23:   zend_shared_alloc.c \\",
          "24:   shared_alloc_win32.c\", true, \"/DZEND_ENABLE_STATIC_TSRMLS_CACHE=1\");",
          "29:  ADD_FLAG('CFLAGS_OPCACHE', \"/I \" + configure_module_dirname);",
          "",
          "[Removed Lines]",
          "26:  ADD_SOURCES(configure_module_dirname + \"/Optimizer\", \"zend_optimizer.c pass1_5.c pass2.c pass3.c optimize_func_calls.c block_pass.c optimize_temp_vars_5.c nop_removal.c compact_literals.c zend_cfg.c zend_dfg.c dfa_pass.c zend_ssa.c zend_inference.c zend_func_info.c zend_call_graph.c zend_dump.c\", \"opcache\", \"OptimizerObj\");",
          "",
          "[Added Lines]",
          "26:  ADD_SOURCES(configure_module_dirname + \"/Optimizer\", \"zend_optimizer.c pass1_5.c pass2.c pass3.c optimize_func_calls.c block_pass.c optimize_temp_vars_5.c nop_removal.c compact_literals.c zend_cfg.c zend_dfg.c dfa_pass.c zend_ssa.c zend_inference.c zend_func_info.c zend_call_graph.c sccp.c scdf.c dce.c compact_vars.c zend_dump.c\", \"opcache\", \"OptimizerObj\");",
          "",
          "---------------"
        ],
        "ext/opcache/tests/ssa_bug_007.phpt||ext/opcache/tests/ssa_bug_007.phpt": [
          "File: ext/opcache/tests/ssa_bug_007.phpt -> ext/opcache/tests/ssa_bug_007.phpt",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: --TEST--",
          "2: Incorrect CFG/SSA construction for SWITCH with few identical successors",
          "3: --FILE--",
          "4: <?php",
          "5: function render($properties) {",
          "6:  foreach ($properties as $key => $value) {",
          "7:   switch ($key) {",
          "8:    case 'Trapped':",
          "9:     if ($value == null) {",
          "10:      $docInfo->$key = 1;",
          "11:     }",
          "12:    case 'CreationDate':",
          "13:    case 'ModDate':",
          "14:     $docInfo->$key = 2;",
          "15:     break;",
          "16:   }",
          "17:  }",
          "18: }",
          "19: ?>",
          "20: OK",
          "21: --EXPECT--",
          "22: OK",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f269cdcd4f76accbecd03884f327cffb9a7f1ca9",
      "candidate_info": {
        "commit_hash": "f269cdcd4f76accbecd03884f327cffb9a7f1ca9",
        "repo": "php/php-src",
        "commit_url": "https://github.com/php/php-src/commit/f269cdcd4f76accbecd03884f327cffb9a7f1ca9",
        "files": [
          "ext/wddx/wddx.c"
        ],
        "message": "Improve fix for #74145",
        "before_after_code_files": [
          "ext/wddx/wddx.c||ext/wddx/wddx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [
            "ext/wddx/wddx.c||ext/wddx/wddx.c"
          ],
          "candidate": [
            "ext/wddx/wddx.c||ext/wddx/wddx.c"
          ]
        }
      },
      "candidate_diff": {
        "ext/wddx/wddx.c||ext/wddx/wddx.c": [
          "File: ext/wddx/wddx.c -> ext/wddx/wddx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "799:  } else if (!strcmp(name, EL_BOOLEAN)) {",
          "800:   int i;",
          "807:   if (atts) for (i = 0; atts[i]; i++) {",
          "808:    if (!strcmp(atts[i], EL_VALUE) && atts[i+1] && atts[i+1][0]) {",
          "809:     wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));",
          "810:     php_wddx_process_data(user_data, atts[i+1], strlen(atts[i+1]));",
          "811:     break;",
          "812:    }",
          "813:   } else {",
          "814:    ZVAL_FALSE(ent.data);",
          "815:    wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));",
          "816:   }",
          "",
          "[Removed Lines]",
          "802:   ALLOC_ZVAL(ent.data);",
          "803:   INIT_PZVAL(ent.data);",
          "804:   Z_TYPE_P(ent.data) = IS_BOOL;",
          "805:   ent.type = ST_BOOLEAN;",
          "806:   SET_STACK_VARNAME;",
          "",
          "[Added Lines]",
          "804:     ALLOC_ZVAL(ent.data);",
          "805:     INIT_PZVAL(ent.data);",
          "806:     Z_TYPE_P(ent.data) = IS_BOOL;",
          "807:     ent.type = ST_BOOLEAN;",
          "808:     SET_STACK_VARNAME;",
          "814:    ALLOC_ZVAL(ent.data);",
          "815:    INIT_PZVAL(ent.data);",
          "816:    Z_TYPE_P(ent.data) = IS_BOOL;",
          "817:    ent.type = ST_BOOLEAN;",
          "818:    SET_STACK_VARNAME;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c4cca4c20e75359c9a13a1f9a36cb7b4e9601d29",
      "candidate_info": {
        "commit_hash": "c4cca4c20e75359c9a13a1f9a36cb7b4e9601d29",
        "repo": "php/php-src",
        "commit_url": "https://github.com/php/php-src/commit/c4cca4c20e75359c9a13a1f9a36cb7b4e9601d29",
        "files": [
          "ext/wddx/tests/bug73065.phpt",
          "ext/wddx/wddx.c"
        ],
        "message": "Fix bug #73065: Out-Of-Bounds Read in php_wddx_push_element of wddx.c",
        "before_after_code_files": [
          "ext/wddx/tests/bug73065.phpt||ext/wddx/tests/bug73065.phpt",
          "ext/wddx/wddx.c||ext/wddx/wddx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ext/wddx/wddx.c||ext/wddx/wddx.c"
          ],
          "candidate": [
            "ext/wddx/wddx.c||ext/wddx/wddx.c"
          ]
        }
      },
      "candidate_diff": {
        "ext/wddx/tests/bug73065.phpt||ext/wddx/tests/bug73065.phpt": [
          "File: ext/wddx/tests/bug73065.phpt -> ext/wddx/tests/bug73065.phpt",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: --TEST--",
          "2: Bug #73065: Out-Of-Bounds Read in php_wddx_push_element of wddx.c",
          "3: --SKIPIF--",
          "4: <?php",
          "5: if (!extension_loaded('wddx')) {",
          "6:     die('skip. wddx not available');",
          "7: }",
          "8: ?>",
          "9: --FILE--",
          "10: <?php",
          "12: $xml1 = <<<XML",
          "13: <?xml version='1.0' ?>",
          "14:     <!DOCTYPE et SYSTEM 'w'>",
          "15:     <wddxPacket ven='1.0'>",
          "16:         <array>",
          "17:             <var Name=\"name\">",
          "18:                 <boolean value=\"keliu\"></boolean>",
          "19:             </var>",
          "20:             <var name=\"1111\">",
          "21:                 <var name=\"2222\">",
          "22:                     <var name=\"3333\"></var>",
          "23:                 </var>",
          "24:             </var>",
          "25:         </array>",
          "26:     </wddxPacket>",
          "27: XML;",
          "29: $xml2 = <<<XML",
          "30: <?xml version='1.0' ?>",
          "31:     <!DOCTYPE et SYSTEM 'w'>",
          "32:     <wddxPacket ven='1.0'>",
          "33:         <array>",
          "34:             <char Name=\"code\">",
          "35:                 <boolean value=\"keliu\"></boolean>",
          "36:             </char>",
          "37:         </array>",
          "38:     </wddxPacket>",
          "39: XML;",
          "41: $xml3 = <<<XML",
          "42: <?xml version='1.0' ?>",
          "43:     <!DOCTYPE et SYSTEM 'w'>",
          "44:     <wddxPacket ven='1.0'>",
          "45:         <array>",
          "46:             <boolean Name=\"value\">",
          "47:                 <boolean value=\"keliu\"></boolean>",
          "48:             </boolean>",
          "49:         </array>",
          "50:     </wddxPacket>",
          "51: XML;",
          "53: $xml4 = <<<XML",
          "54: <?xml version='1.0' ?>",
          "55:     <!DOCTYPE et SYSTEM 'w'>",
          "56:     <wddxPacket ven='1.0'>",
          "57:         <array>",
          "58:             <recordset Name=\"fieldNames\">",
          "59:                 <boolean value=\"keliu\"></boolean>",
          "60:             </recordset>",
          "61:         </array>",
          "62:     </wddxPacket>",
          "63: XML;",
          "65: $xml5 = <<<XML",
          "66: <?xml version='1.0' ?>",
          "67:     <!DOCTYPE et SYSTEM 'w'>",
          "68:     <wddxPacket ven='1.0'>",
          "69:         <array>",
          "70:             <field Name=\"name\">",
          "71:                 <boolean value=\"keliu\"></boolean>",
          "72:             </field>",
          "73:         </array>",
          "74:     </wddxPacket>",
          "75: XML;",
          "77: for($i=1;$i<=5;$i++) {",
          "78:  $xmlvar = \"xml$i\";",
          "79:     $array = wddx_deserialize($$xmlvar);",
          "80:     var_dump($array);",
          "81: }",
          "82: ?>",
          "83: DONE",
          "84: --EXPECTF--",
          "85: array(0) {",
          "86: }",
          "87: array(0) {",
          "88: }",
          "89: array(0) {",
          "90: }",
          "91: array(1) {",
          "92:   [0]=>",
          "93:   array(0) {",
          "94:   }",
          "95: }",
          "96: array(0) {",
          "97: }",
          "98: DONE",
          "",
          "---------------"
        ],
        "ext/wddx/wddx.c||ext/wddx/wddx.c": [
          "File: ext/wddx/wddx.c -> ext/wddx/wddx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "780:   int i;",
          "782:   if (atts) for (i = 0; atts[i]; i++) {",
          "784:     char tmp_buf[2];",
          "787:     php_wddx_process_data(user_data, tmp_buf, strlen(tmp_buf));",
          "788:     break;",
          "789:    }",
          "",
          "[Removed Lines]",
          "783:    if (!strcmp(atts[i], EL_CHAR_CODE) && atts[++i] && atts[i][0]) {",
          "786:     snprintf(tmp_buf, sizeof(tmp_buf), \"%c\", (char)strtol(atts[i], NULL, 16));",
          "",
          "[Added Lines]",
          "783:    if (!strcmp(atts[i], EL_CHAR_CODE) && atts[i+1] && atts[i+1][0]) {",
          "786:     snprintf(tmp_buf, sizeof(tmp_buf), \"%c\", (char)strtol(atts[i+1], NULL, 16));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "801:   int i;",
          "803:   if (atts) for (i = 0; atts[i]; i++) {",
          "805:     ent.type = ST_BOOLEAN;",
          "806:     SET_STACK_VARNAME;",
          "",
          "[Removed Lines]",
          "804:    if (!strcmp(atts[i], EL_VALUE) && atts[++i] && atts[i][0]) {",
          "",
          "[Added Lines]",
          "804:    if (!strcmp(atts[i], EL_VALUE) && atts[i+1] && atts[i+1][0]) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "809:     INIT_PZVAL(ent.data);",
          "810:     Z_TYPE_P(ent.data) = IS_BOOL;",
          "811:     wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));",
          "813:     break;",
          "814:    }",
          "815:   }",
          "",
          "[Removed Lines]",
          "812:     php_wddx_process_data(user_data, atts[i], strlen(atts[i]));",
          "",
          "[Added Lines]",
          "812:     php_wddx_process_data(user_data, atts[i+1], strlen(atts[i+1]));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "842:   int i;",
          "844:   if (atts) for (i = 0; atts[i]; i++) {",
          "846:     if (stack->varname) efree(stack->varname);",
          "848:     break;",
          "849:    }",
          "850:   }",
          "",
          "[Removed Lines]",
          "845:    if (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0]) {",
          "847:     stack->varname = estrdup(atts[i]);",
          "",
          "[Added Lines]",
          "845:    if (!strcmp(atts[i], EL_NAME) && atts[i+1] && atts[i+1][0]) {",
          "847:     stack->varname = estrdup(atts[i+1]);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "857:   array_init(ent.data);",
          "859:   if (atts) for (i = 0; atts[i]; i++) {",
          "861:     zval *tmp;",
          "862:     char *key;",
          "863:     char *p1, *p2, *endp;",
          "865:     endp = (char *)atts[i] + strlen(atts[i]);",
          "866:     p1 = (char *)atts[i];",
          "867:     while ((p2 = php_memnstr(p1, \",\", sizeof(\",\")-1, endp)) != NULL) {",
          "",
          "[Removed Lines]",
          "860:    if (!strcmp(atts[i], \"fieldNames\") && atts[++i] && atts[i][0]) {",
          "",
          "[Added Lines]",
          "860:    if (!strcmp(atts[i], \"fieldNames\") && atts[i+1] && atts[i+1][0]) {",
          "865:     i++;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "893:   ent.data = NULL;",
          "895:   if (atts) for (i = 0; atts[i]; i++) {",
          "897:     st_entry *recordset;",
          "898:     zval **field;",
          "900:     if (wddx_stack_top(stack, (void**)&recordset) == SUCCESS &&",
          "901:      recordset->type == ST_RECORDSET &&",
          "903:      ent.data = *field;",
          "904:     }",
          "",
          "[Removed Lines]",
          "896:    if (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0]) {",
          "902:      zend_hash_find(Z_ARRVAL_P(recordset->data), (char*)atts[i], strlen(atts[i])+1, (void**)&field) == SUCCESS) {",
          "",
          "[Added Lines]",
          "897:    if (!strcmp(atts[i], EL_NAME) && atts[i+1] && atts[i+1][0]) {",
          "903:      zend_hash_find(Z_ARRVAL_P(recordset->data), (char*)atts[i+1], strlen(atts[i+1])+1, (void**)&field) == SUCCESS) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "266ecb6d0a1ab5a37b4d652ca774a8adc4b06578",
      "candidate_info": {
        "commit_hash": "266ecb6d0a1ab5a37b4d652ca774a8adc4b06578",
        "repo": "php/php-src",
        "commit_url": "https://github.com/php/php-src/commit/266ecb6d0a1ab5a37b4d652ca774a8adc4b06578",
        "files": [
          "NEWS",
          "ext/wddx/tests/bug73631.phpt",
          "ext/wddx/wddx.c"
        ],
        "message": "Fix bug #73631 - Invalid read when wddx decodes empty boolean element",
        "before_after_code_files": [
          "ext/wddx/tests/bug73631.phpt||ext/wddx/tests/bug73631.phpt",
          "ext/wddx/wddx.c||ext/wddx/wddx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ext/wddx/wddx.c||ext/wddx/wddx.c"
          ],
          "candidate": [
            "ext/wddx/wddx.c||ext/wddx/wddx.c"
          ]
        }
      },
      "candidate_diff": {
        "ext/wddx/tests/bug73631.phpt||ext/wddx/tests/bug73631.phpt": [
          "File: ext/wddx/tests/bug73631.phpt -> ext/wddx/tests/bug73631.phpt",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: --TEST--",
          "2: Bug #73631 (Memory leak due to invalid wddx stack processing)",
          "3: --SKIPIF--",
          "4: <?php if (!extension_loaded(\"wddx\")) print \"skip\"; ?>",
          "5: --FILE--",
          "6: <?php",
          "7: $xml = <<<EOF",
          "8: <?xml version=\"1.0\" ?>",
          "9: <wddxPacket version=\"1.0\">",
          "10: <number>1234</number>",
          "11: <binary><boolean/></binary>",
          "12: </wddxPacket>",
          "13: EOF;",
          "14: $wddx = wddx_deserialize($xml);",
          "15: var_dump($wddx);",
          "16: ?>",
          "17: --EXPECTF--",
          "18: int(1234)",
          "",
          "---------------"
        ],
        "ext/wddx/wddx.c||ext/wddx/wddx.c": [
          "File: ext/wddx/wddx.c -> ext/wddx/wddx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "811:     php_wddx_process_data(user_data, atts[i+1], strlen(atts[i+1]));",
          "812:     break;",
          "813:    }",
          "814:   }",
          "815:  } else if (!strcmp(name, EL_NULL)) {",
          "816:   ent.type = ST_NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "814:   } else {",
          "815:    ent.type = ST_BOOLEAN;",
          "816:    SET_STACK_VARNAME;",
          "817:    ZVAL_FALSE(&ent.data);",
          "818:    wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6b18d956de38ecd8913c3d82ce96eb0368a1f9e5",
      "candidate_info": {
        "commit_hash": "6b18d956de38ecd8913c3d82ce96eb0368a1f9e5",
        "repo": "php/php-src",
        "commit_url": "https://github.com/php/php-src/commit/6b18d956de38ecd8913c3d82ce96eb0368a1f9e5",
        "files": [
          "ext/wddx/wddx.c"
        ],
        "message": "Fix wddx",
        "before_after_code_files": [
          "ext/wddx/wddx.c||ext/wddx/wddx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ext/wddx/wddx.c||ext/wddx/wddx.c"
          ],
          "candidate": [
            "ext/wddx/wddx.c||ext/wddx/wddx.c"
          ]
        }
      },
      "candidate_diff": {
        "ext/wddx/wddx.c||ext/wddx/wddx.c": [
          "File: ext/wddx/wddx.c -> ext/wddx/wddx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "761:  } else if (!strcmp((char *)name, EL_BOOLEAN)) {",
          "762:   int i;",
          "767:   ent.type = ST_BOOLEAN;",
          "768:   SET_STACK_VARNAME;",
          "769:   if (atts) for (i = 0; atts[i]; i++) {",
          "",
          "[Removed Lines]",
          "764:   ALLOC_ZVAL(ent.data);",
          "765:   INIT_PZVAL(ent.data);",
          "766:   Z_TYPE_P(ent.data) = IS_BOOL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "774:     break;",
          "775:    }",
          "776:   } else {",
          "778:    wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));",
          "779:   }",
          "780:  } else if (!strcmp((char *)name, EL_NULL)) {",
          "",
          "[Removed Lines]",
          "777:    ZVAL_FALSE(ent.data);",
          "",
          "[Added Lines]",
          "774:    ZVAL_FALSE(&ent.data);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
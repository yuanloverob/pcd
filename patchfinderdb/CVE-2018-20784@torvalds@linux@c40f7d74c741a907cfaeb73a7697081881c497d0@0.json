{
  "cve_id": "CVE-2018-20784",
  "cve_desc": "In the Linux kernel before 4.20.2, kernel/sched/fair.c mishandles leaf cfs_rq's, which allows attackers to cause a denial of service (infinite loop in update_blocked_averages) or possibly have unspecified other impact by inducing a high load.",
  "repo": "torvalds/linux",
  "patch_hash": "c40f7d74c741a907cfaeb73a7697081881c497d0",
  "patch_info": {
    "commit_hash": "c40f7d74c741a907cfaeb73a7697081881c497d0",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/c40f7d74c741a907cfaeb73a7697081881c497d0",
    "files": [
      "kernel/sched/fair.c"
    ],
    "message": "sched/fair: Fix infinite loop in update_blocked_averages() by reverting a9e7f6544b9c\n\nZhipeng Xie, Xie XiuQi and Sargun Dhillon reported lockups in the\nscheduler under high loads, starting at around the v4.18 time frame,\nand Zhipeng Xie tracked it down to bugs in the rq->leaf_cfs_rq_list\nmanipulation.\n\nDo a (manual) revert of:\n\n  a9e7f6544b9c (\"sched/fair: Fix O(nr_cgroups) in load balance path\")\n\nIt turns out that the list_del_leaf_cfs_rq() introduced by this commit\nis a surprising property that was not considered in followup commits\nsuch as:\n\n  9c2791f936ef (\"sched/fair: Fix hierarchical order in rq->leaf_cfs_rq_list\")\n\nAs Vincent Guittot explains:\n\n \"I think that there is a bigger problem with commit a9e7f6544b9c and\n  cfs_rq throttling:\n\n  Let take the example of the following topology TG2 --> TG1 --> root:\n\n   1) The 1st time a task is enqueued, we will add TG2 cfs_rq then TG1\n      cfs_rq to leaf_cfs_rq_list and we are sure to do the whole branch in\n      one path because it has never been used and can't be throttled so\n      tmp_alone_branch will point to leaf_cfs_rq_list at the end.\n\n   2) Then TG1 is throttled\n\n   3) and we add TG3 as a new child of TG1.\n\n   4) The 1st enqueue of a task on TG3 will add TG3 cfs_rq just before TG1\n      cfs_rq and tmp_alone_branch will stay  on rq->leaf_cfs_rq_list.\n\n  With commit a9e7f6544b9c, we can del a cfs_rq from rq->leaf_cfs_rq_list.\n  So if the load of TG1 cfs_rq becomes NULL before step 2) above, TG1\n  cfs_rq is removed from the list.\n  Then at step 4), TG3 cfs_rq is added at the beginning of rq->leaf_cfs_rq_list\n  but tmp_alone_branch still points to TG3 cfs_rq because its throttled\n  parent can't be enqueued when the lock is released.\n  tmp_alone_branch doesn't point to rq->leaf_cfs_rq_list whereas it should.\n\n  So if TG3 cfs_rq is removed or destroyed before tmp_alone_branch\n  points on another TG cfs_rq, the next TG cfs_rq that will be added,\n  will be linked outside rq->leaf_cfs_rq_list - which is bad.\n\n  In addition, we can break the ordering of the cfs_rq in\n  rq->leaf_cfs_rq_list but this ordering is used to update and\n  propagate the update from leaf down to root.\"\n\nInstead of trying to work through all these cases and trying to reproduce\nthe very high loads that produced the lockup to begin with, simplify\nthe code temporarily by reverting a9e7f6544b9c - which change was clearly\nnot thought through completely.\n\nThis (hopefully) gives us a kernel that doesn't lock up so people\ncan continue to enjoy their holidays without worrying about regressions. ;-)\n\n[ mingo: Wrote changelog, fixed weird spelling in code comment while at it. ]\n\nAnalyzed-by: Xie XiuQi <xiexiuqi@huawei.com>\nAnalyzed-by: Vincent Guittot <vincent.guittot@linaro.org>\nReported-by: Zhipeng Xie <xiezhipeng1@huawei.com>\nReported-by: Sargun Dhillon <sargun@sargun.me>\nReported-by: Xie XiuQi <xiexiuqi@huawei.com>\nTested-by: Zhipeng Xie <xiezhipeng1@huawei.com>\nTested-by: Sargun Dhillon <sargun@sargun.me>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nAcked-by: Vincent Guittot <vincent.guittot@linaro.org>\nCc: <stable@vger.kernel.org> # v4.13+\nCc: Bin Li <huawei.libin@huawei.com>\nCc: Mike Galbraith <efault@gmx.de>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Tejun Heo <tj@kernel.org>\nCc: Thomas Gleixner <tglx@linutronix.de>\nFixes: a9e7f6544b9c (\"sched/fair: Fix O(nr_cgroups) in load balance path\")\nLink: http://lkml.kernel.org/r/1545879866-27809-1-git-send-email-xiexiuqi@huawei.com\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
    "before_after_code_files": [
      "kernel/sched/fair.c||kernel/sched/fair.c"
    ]
  },
  "patch_diff": {
    "kernel/sched/fair.c||kernel/sched/fair.c": [
      "File: kernel/sched/fair.c -> kernel/sched/fair.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "352:  }",
      "353: }",
      "361: static inline struct cfs_rq *",
      "",
      "[Removed Lines]",
      "356: #define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)   \\",
      "357:  list_for_each_entry_safe(cfs_rq, pos, &rq->leaf_cfs_rq_list, \\",
      "358:      leaf_cfs_rq_list)",
      "",
      "[Added Lines]",
      "356: #define for_each_leaf_cfs_rq(rq, cfs_rq) \\",
      "357:  list_for_each_entry_rcu(cfs_rq, &rq->leaf_cfs_rq_list, leaf_cfs_rq_list)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "447: {",
      "448: }",
      "453: static inline struct sched_entity *parent_entity(struct sched_entity *se)",
      "454: {",
      "",
      "[Removed Lines]",
      "450: #define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) \\",
      "451:   for (cfs_rq = &rq->cfs, pos = NULL; cfs_rq; cfs_rq = pos)",
      "",
      "[Added Lines]",
      "449: #define for_each_leaf_cfs_rq(rq, cfs_rq) \\",
      "450:   for (cfs_rq = &rq->cfs; cfs_rq; cfs_rq = NULL)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "7648: #ifdef CONFIG_FAIR_GROUP_SCHED",
      "7667: static void update_blocked_averages(int cpu)",
      "7668: {",
      "7669:  struct rq *rq = cpu_rq(cpu);",
      "7671:  const struct sched_class *curr_class;",
      "7672:  struct rq_flags rf;",
      "7673:  bool done = true;",
      "",
      "[Removed Lines]",
      "7650: static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)",
      "7651: {",
      "7652:  if (cfs_rq->load.weight)",
      "7653:   return false;",
      "7655:  if (cfs_rq->avg.load_sum)",
      "7656:   return false;",
      "7658:  if (cfs_rq->avg.util_sum)",
      "7659:   return false;",
      "7661:  if (cfs_rq->avg.runnable_load_sum)",
      "7662:   return false;",
      "7664:  return true;",
      "7665: }",
      "7670:  struct cfs_rq *cfs_rq, *pos;",
      "",
      "[Added Lines]",
      "7652:  struct cfs_rq *cfs_rq;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "7683:   struct sched_entity *se;",
      "",
      "[Removed Lines]",
      "7682:  for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {",
      "",
      "[Added Lines]",
      "7664:  for_each_leaf_cfs_rq(rq, cfs_rq) {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "7694:   if (se && !skip_blocked_update(se))",
      "7695:    update_load_avg(cfs_rq_of(se), se, 0);",
      "7705:   if (cfs_rq_has_blocked(cfs_rq))",
      "7706:    done = false;",
      "",
      "[Removed Lines]",
      "7701:   if (cfs_rq_is_decayed(cfs_rq))",
      "7702:    list_del_leaf_cfs_rq(cfs_rq);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "10570: #ifdef CONFIG_SCHED_DEBUG",
      "10571: void print_cfs_stats(struct seq_file *m, int cpu)",
      "10572: {",
      "10575:  rcu_read_lock();",
      "10577:   print_cfs_rq(m, cpu, cfs_rq);",
      "10578:  rcu_read_unlock();",
      "10579: }",
      "",
      "[Removed Lines]",
      "10573:  struct cfs_rq *cfs_rq, *pos;",
      "10576:  for_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)",
      "",
      "[Added Lines]",
      "10548:  struct cfs_rq *cfs_rq;",
      "10551:  for_each_leaf_cfs_rq(cpu_rq(cpu), cfs_rq)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f643ea2207010db26f17fca99db031bad87c8461",
      "candidate_info": {
        "commit_hash": "f643ea2207010db26f17fca99db031bad87c8461",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f643ea2207010db26f17fca99db031bad87c8461",
        "files": [
          "kernel/sched/fair.c",
          "kernel/sched/sched.h"
        ],
        "message": "sched/nohz: Stop NOHZ stats when decayed\n\nStopped the periodic update of blocked load when all idle CPUs have fully\ndecayed. We introduce a new nohz.has_blocked that reflect if some idle\nCPUs has blocked load that have to be periodiccally updated. nohz.has_blocked\nis set everytime that a Idle CPU can have blocked load and it is then clear\nwhen no more blocked load has been detected during an update. We don't need\natomic operation but only to make cure of the right ordering when updating\nnohz.idle_cpus_mask and nohz.has_blocked.\n\nSuggested-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nSigned-off-by: Vincent Guittot <vincent.guittot@linaro.org>\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: brendan.jackman@arm.com\nCc: dietmar.eggemann@arm.com\nCc: morten.rasmussen@foss.arm.com\nCc: valentin.schneider@arm.com\nLink: http://lkml.kernel.org/r/1518517879-2280-2-git-send-email-vincent.guittot@linaro.org\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "before_after_code_files": [
          "kernel/sched/fair.c||kernel/sched/fair.c",
          "kernel/sched/sched.h||kernel/sched/sched.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/sched/fair.c||kernel/sched/fair.c"
          ],
          "candidate": [
            "kernel/sched/fair.c||kernel/sched/fair.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/sched/fair.c||kernel/sched/fair.c": [
          "File: kernel/sched/fair.c -> kernel/sched/fair.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5387: static struct {",
          "5388:  cpumask_var_t idle_cpus_mask;",
          "5389:  atomic_t nr_cpus;",
          "5392: } nohz ____cacheline_aligned;",
          "",
          "[Removed Lines]",
          "5391:  unsigned long next_stats;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "7038: #define LBF_DST_PINNED  0x04",
          "7039: #define LBF_SOME_PINNED 0x08",
          "7040: #define LBF_NOHZ_STATS 0x10",
          "7042: struct lb_env {",
          "7043:  struct sched_domain *sd;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7042: #define LBF_NOHZ_AGAIN 0x20",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "7422:  rq_unlock(env->dst_rq, &rf);",
          "7423: }",
          "7427: static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)",
          "7428: {",
          "7429:  if (cfs_rq->load.weight)",
          "",
          "[Removed Lines]",
          "7425: #ifdef CONFIG_FAIR_GROUP_SCHED",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "7441:  return true;",
          "7442: }",
          "7444: static void update_blocked_averages(int cpu)",
          "7445: {",
          "7446:  struct rq *rq = cpu_rq(cpu);",
          "7447:  struct cfs_rq *cfs_rq, *pos;",
          "7448:  struct rq_flags rf;",
          "7450:  rq_lock_irqsave(rq, &rf);",
          "7451:  update_rq_clock(rq);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7444: #ifdef CONFIG_FAIR_GROUP_SCHED",
          "7451:  bool done = true;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "7476:   if (cfs_rq_is_decayed(cfs_rq))",
          "7477:    list_del_leaf_cfs_rq(cfs_rq);",
          "7478:  }",
          "7480: #ifdef CONFIG_NO_HZ_COMMON",
          "7481:  rq->last_blocked_load_update_tick = jiffies;",
          "7482: #endif",
          "7483:  rq_unlock_irqrestore(rq, &rf);",
          "7484: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7481:   else",
          "7482:    done = false;",
          "7487:  if (done)",
          "7488:   rq->has_blocked_load = 0;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "7541:  update_cfs_rq_load_avg(cfs_rq_clock_task(cfs_rq), cfs_rq);",
          "7542: #ifdef CONFIG_NO_HZ_COMMON",
          "7543:  rq->last_blocked_load_update_tick = jiffies;",
          "7544: #endif",
          "7545:  rq_unlock_irqrestore(rq, &rf);",
          "7546: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7551:  if (cfs_rq_is_decayed(cfs_rq))",
          "7552:   rq->has_blocked_load = 0;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "7876:  return group_other;",
          "7877: }",
          "7880: {",
          "7881: #ifdef CONFIG_NO_HZ_COMMON",
          "7882:  unsigned int cpu = rq->cpu;",
          "7884:  if (!cpumask_test_cpu(cpu, nohz.idle_cpus_mask))",
          "7887:  if (!time_after(jiffies, rq->last_blocked_load_update_tick))",
          "7890:  update_blocked_averages(cpu);",
          "7891: #endif",
          "7892: }",
          "",
          "[Removed Lines]",
          "7879: static void update_nohz_stats(struct rq *rq)",
          "7885:   return;",
          "7888:   return;",
          "",
          "[Added Lines]",
          "7888: static bool update_nohz_stats(struct rq *rq)",
          "7893:  if (!rq->has_blocked_load)",
          "7894:   return false;",
          "7897:   return false;",
          "7900:   return true;",
          "7904:  return rq->has_blocked_load;",
          "7905: #else",
          "7906:  return false;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "7913:  for_each_cpu_and(i, sched_group_span(group), env->cpus) {",
          "7914:   struct rq *rq = cpu_rq(i);",
          "7920:   if (local_group)",
          "",
          "[Removed Lines]",
          "7916:   if (env->flags & LBF_NOHZ_STATS)",
          "7917:    update_nohz_stats(rq);",
          "",
          "[Added Lines]",
          "7932:   if ((env->flags & LBF_NOHZ_STATS) && update_nohz_stats(rq))",
          "7933:    env->flags |= LBF_NOHZ_AGAIN;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "8072:   prefer_sibling = 1;",
          "8074: #ifdef CONFIG_NO_HZ_COMMON",
          "8076:   env->flags |= LBF_NOHZ_STATS;",
          "8081: #endif",
          "8083:  load_idx = get_sd_load_idx(env->sd, env->idle);",
          "",
          "[Removed Lines]",
          "8075:  if (env->idle == CPU_NEWLY_IDLE) {",
          "8078:   if (cpumask_subset(nohz.idle_cpus_mask, sched_domain_span(env->sd)))",
          "8079:    nohz.next_stats = jiffies + msecs_to_jiffies(LOAD_AVG_PERIOD);",
          "8080:  }",
          "",
          "[Added Lines]",
          "8091:  if (env->idle == CPU_NEWLY_IDLE && READ_ONCE(nohz.has_blocked))",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "8133:   sg = sg->next;",
          "8134:  } while (sg != env->sd->groups);",
          "8136:  if (env->sd->flags & SD_NUMA)",
          "8137:   env->fbq_type = fbq_classify_group(&sds->busiest_stat);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8148: #ifdef CONFIG_NO_HZ_COMMON",
          "8149:  if ((env->flags & LBF_NOHZ_AGAIN) &&",
          "8150:      cpumask_subset(nohz.idle_cpus_mask, sched_domain_span(env->sd))) {",
          "8152:   WRITE_ONCE(nohz.next_blocked,",
          "8153:       jiffies + msecs_to_jiffies(LOAD_AVG_PERIOD));",
          "8154:  }",
          "8155: #endif",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "9174:  if (likely(!atomic_read(&nohz.nr_cpus)))",
          "9175:   return;",
          "9178:   flags = NOHZ_STATS_KICK;",
          "9180:  if (time_before(now, nohz.next_balance))",
          "",
          "[Removed Lines]",
          "9177:  if (time_after(now, nohz.next_stats))",
          "",
          "[Added Lines]",
          "9198:  if (READ_ONCE(nohz.has_blocked) &&",
          "9199:      time_after(now, READ_ONCE(nohz.next_blocked)))",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "9293:  if (!housekeeping_cpu(cpu, HK_FLAG_SCHED))",
          "9294:   return;",
          "9296:  if (rq->nohz_tick_stopped)",
          "9300:  if (on_null_domain(rq))",
          "",
          "[Removed Lines]",
          "9297:   return;",
          "",
          "[Added Lines]",
          "9323:  rq->has_blocked_load = 1;",
          "9332:   goto out;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "9305:  cpumask_set_cpu(cpu, nohz.idle_cpus_mask);",
          "9306:  atomic_inc(&nohz.nr_cpus);",
          "9308:  set_cpu_sd_state_idle(cpu);",
          "9309: }",
          "9310: #else",
          "9311: static inline void nohz_balancer_kick(struct rq *rq) { }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9348:  smp_mb__after_atomic();",
          "9352: out:",
          "9357:  WRITE_ONCE(nohz.has_blocked, 1);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "9440:  unsigned long now = jiffies;",
          "9441:  unsigned long next_balance = now + 60*HZ;",
          "9443:  int update_next_balance = 0;",
          "9444:  int this_cpu = this_rq->cpu;",
          "9445:  unsigned int flags;",
          "",
          "[Removed Lines]",
          "9442:  unsigned long next_stats = now + msecs_to_jiffies(LOAD_AVG_PERIOD);",
          "",
          "[Added Lines]",
          "9491:  bool has_blocked_load = false;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "9459:  SCHED_WARN_ON((flags & NOHZ_KICK_MASK) == NOHZ_BALANCE_KICK);",
          "9461:  for_each_cpu(balance_cpu, nohz.idle_cpus_mask) {",
          "9462:   if (balance_cpu == this_cpu || !idle_cpu(balance_cpu))",
          "9463:    continue;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9518:  WRITE_ONCE(nohz.has_blocked, 0);",
          "9524:  smp_mb();",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "9473:   rq = cpu_rq(balance_cpu);",
          "",
          "[Removed Lines]",
          "9470:   if (need_resched())",
          "9471:    break;",
          "",
          "[Added Lines]",
          "9535:   if (need_resched()) {",
          "9536:    has_blocked_load = true;",
          "9537:    goto abort;",
          "9538:   }",
          "9542:   update_blocked_averages(rq->cpu);",
          "9543:   has_blocked_load |= rq->has_blocked_load;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "9484:    cpu_load_update_idle(rq);",
          "9485:    rq_unlock_irq(rq, &rf);",
          "9488:    if (flags & NOHZ_BALANCE_KICK)",
          "9489:     rebalance_domains(rq, CPU_IDLE);",
          "9490:   }",
          "",
          "[Removed Lines]",
          "9487:    update_blocked_averages(rq->cpu);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "9499:  if (flags & NOHZ_BALANCE_KICK)",
          "9500:   rebalance_domains(this_rq, CPU_IDLE);",
          "",
          "[Removed Lines]",
          "9502:  nohz.next_stats = next_stats;",
          "",
          "[Added Lines]",
          "9571:  WRITE_ONCE(nohz.next_blocked,",
          "9572:   now + msecs_to_jiffies(LOAD_AVG_PERIOD));",
          "9574: abort:",
          "9576:  if (has_blocked_load)",
          "9577:   WRITE_ONCE(nohz.has_blocked, 1);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "10136: #ifdef CONFIG_NO_HZ_COMMON",
          "10137:  nohz.next_balance = jiffies;",
          "10138:  zalloc_cpumask_var(&nohz.idle_cpus_mask, GFP_NOWAIT);",
          "10139: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10213:  nohz.next_blocked = jiffies;",
          "",
          "---------------"
        ],
        "kernel/sched/sched.h||kernel/sched/sched.h": [
          "File: kernel/sched/sched.h -> kernel/sched/sched.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "763: #ifdef CONFIG_SMP",
          "764:  unsigned long  last_load_update_tick;",
          "765:  unsigned long  last_blocked_load_update_tick;",
          "767:  unsigned int  nohz_tick_stopped;",
          "768:  atomic_t nohz_flags;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "766:  unsigned int  has_blocked_load;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5d299eabea5a251fbf66e8277704b874bbba92dc",
      "candidate_info": {
        "commit_hash": "5d299eabea5a251fbf66e8277704b874bbba92dc",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5d299eabea5a251fbf66e8277704b874bbba92dc",
        "files": [
          "kernel/sched/fair.c"
        ],
        "message": "sched/fair: Add tmp_alone_branch assertion\n\nThe magic in list_add_leaf_cfs_rq() requires that at the end of\nenqueue_task_fair():\n\n  rq->tmp_alone_branch == &rq->lead_cfs_rq_list\n\nIf this is violated, list integrity is compromised for list entries\nand the tmp_alone_branch pointer might dangle.\n\nAlso, reflow list_add_leaf_cfs_rq() while there. This looses one\nindentation level and generates a form that's convenient for the next\npatch.\n\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Mike Galbraith <efault@gmx.de>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Thomas Gleixner <tglx@linutronix.de>\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "before_after_code_files": [
          "kernel/sched/fair.c||kernel/sched/fair.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/sched/fair.c||kernel/sched/fair.c"
          ],
          "candidate": [
            "kernel/sched/fair.c||kernel/sched/fair.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/sched/fair.c||kernel/sched/fair.c": [
          "File: kernel/sched/fair.c -> kernel/sched/fair.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "278: static inline void list_add_leaf_cfs_rq(struct cfs_rq *cfs_rq)",
          "279: {",
          "337:  }",
          "338: }",
          "340: static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)",
          "",
          "[Removed Lines]",
          "280:  if (!cfs_rq->on_list) {",
          "281:   struct rq *rq = rq_of(cfs_rq);",
          "282:   int cpu = cpu_of(rq);",
          "292:   if (cfs_rq->tg->parent &&",
          "293:       cfs_rq->tg->parent->cfs_rq[cpu]->on_list) {",
          "300:    list_add_tail_rcu(&cfs_rq->leaf_cfs_rq_list,",
          "301:     &(cfs_rq->tg->parent->cfs_rq[cpu]->leaf_cfs_rq_list));",
          "307:    rq->tmp_alone_branch = &rq->leaf_cfs_rq_list;",
          "308:   } else if (!cfs_rq->tg->parent) {",
          "313:    list_add_tail_rcu(&cfs_rq->leaf_cfs_rq_list,",
          "314:     &rq->leaf_cfs_rq_list);",
          "319:    rq->tmp_alone_branch = &rq->leaf_cfs_rq_list;",
          "320:   } else {",
          "327:    list_add_rcu(&cfs_rq->leaf_cfs_rq_list,",
          "328:     rq->tmp_alone_branch);",
          "333:    rq->tmp_alone_branch = &cfs_rq->leaf_cfs_rq_list;",
          "334:   }",
          "336:   cfs_rq->on_list = 1;",
          "",
          "[Added Lines]",
          "280:  struct rq *rq = rq_of(cfs_rq);",
          "281:  int cpu = cpu_of(rq);",
          "283:  if (cfs_rq->on_list)",
          "284:   return;",
          "286:  cfs_rq->on_list = 1;",
          "297:  if (cfs_rq->tg->parent &&",
          "298:      cfs_rq->tg->parent->cfs_rq[cpu]->on_list) {",
          "305:   list_add_tail_rcu(&cfs_rq->leaf_cfs_rq_list,",
          "306:    &(cfs_rq->tg->parent->cfs_rq[cpu]->leaf_cfs_rq_list));",
          "312:   rq->tmp_alone_branch = &rq->leaf_cfs_rq_list;",
          "313:   return;",
          "314:  }",
          "316:  if (!cfs_rq->tg->parent) {",
          "321:   list_add_tail_rcu(&cfs_rq->leaf_cfs_rq_list,",
          "322:    &rq->leaf_cfs_rq_list);",
          "327:   rq->tmp_alone_branch = &rq->leaf_cfs_rq_list;",
          "328:   return;",
          "337:  list_add_rcu(&cfs_rq->leaf_cfs_rq_list, rq->tmp_alone_branch);",
          "342:  rq->tmp_alone_branch = &cfs_rq->leaf_cfs_rq_list;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "345:  }",
          "346: }",
          "349: #define for_each_leaf_cfs_rq(rq, cfs_rq) \\",
          "350:  list_for_each_entry_rcu(cfs_rq, &rq->leaf_cfs_rq_list, leaf_cfs_rq_list)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "353: static inline void assert_list_leaf_cfs_rq(struct rq *rq)",
          "354: {",
          "355:  SCHED_WARN_ON(rq->tmp_alone_branch != &rq->leaf_cfs_rq_list);",
          "356: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "433: {",
          "434: }",
          "436: #define for_each_leaf_cfs_rq(rq, cfs_rq) \\",
          "437:   for (cfs_rq = &rq->cfs; cfs_rq; cfs_rq = NULL)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "446: static inline void assert_list_leaf_cfs_rq(struct rq *rq)",
          "447: {",
          "448: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "5173:  }",
          "5175:  hrtick_update(rq);",
          "5176: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5189:  assert_list_leaf_cfs_rq(rq);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "12b04875d666e83d27511df25580de84505bc758",
      "candidate_info": {
        "commit_hash": "12b04875d666e83d27511df25580de84505bc758",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/12b04875d666e83d27511df25580de84505bc758",
        "files": [
          "kernel/sched/fair.c"
        ],
        "message": "sched/pelt: Fix update_blocked_averages() for RT and DL classes\n\nupdate_blocked_averages() is called to periodiccally decay the stalled load\nof idle CPUs and to sync all loads before running load balance.\n\nWhen cfs rq is idle, it trigs a load balance during pick_next_task_fair()\nin order to potentially pull tasks and to use this newly idle CPU. This\nload balance happens whereas prev task from another class has not been put\nand its utilization updated yet. This may lead to wrongly account running\ntime as idle time for RT or DL classes.\n\nTest that no RT or DL task is running when updating their utilization in\nupdate_blocked_averages().\n\nWe still update RT and DL utilization instead of simply skipping them to\nmake sure that all metrics are synced when used during load balance.\n\nSigned-off-by: Vincent Guittot <vincent.guittot@linaro.org>\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Thomas Gleixner <tglx@linutronix.de>\nFixes: 371bf4273269 (\"sched/rt: Add rt_rq utilization tracking\")\nFixes: 3727e0e16340 (\"sched/dl: Add dl_rq utilization tracking\")\nLink: http://lkml.kernel.org/r/1535728975-22799-1-git-send-email-vincent.guittot@linaro.org\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "before_after_code_files": [
          "kernel/sched/fair.c||kernel/sched/fair.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/sched/fair.c||kernel/sched/fair.c"
          ],
          "candidate": [
            "kernel/sched/fair.c||kernel/sched/fair.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/sched/fair.c||kernel/sched/fair.c": [
          "File: kernel/sched/fair.c -> kernel/sched/fair.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "7263: {",
          "7264:  struct rq *rq = cpu_rq(cpu);",
          "7265:  struct cfs_rq *cfs_rq, *pos;",
          "7266:  struct rq_flags rf;",
          "7267:  bool done = true;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7266:  const struct sched_class *curr_class;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "7299:   if (cfs_rq_has_blocked(cfs_rq))",
          "7300:    done = false;",
          "7301:  }",
          "7304:  update_irq_load_avg(rq, 0);",
          "7306:  if (others_have_blocked(rq))",
          "",
          "[Removed Lines]",
          "7302:  update_rt_rq_load_avg(rq_clock_task(rq), rq, 0);",
          "7303:  update_dl_rq_load_avg(rq_clock_task(rq), rq, 0);",
          "",
          "[Added Lines]",
          "7304:  curr_class = rq->curr->sched_class;",
          "7305:  update_rt_rq_load_avg(rq_clock_task(rq), rq, curr_class == &rt_sched_class);",
          "7306:  update_dl_rq_load_avg(rq_clock_task(rq), rq, curr_class == &dl_sched_class);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "7365: {",
          "7366:  struct rq *rq = cpu_rq(cpu);",
          "7367:  struct cfs_rq *cfs_rq = &rq->cfs;",
          "7368:  struct rq_flags rf;",
          "7370:  rq_lock_irqsave(rq, &rf);",
          "7371:  update_rq_clock(rq);",
          "7372:  update_cfs_rq_load_avg(cfs_rq_clock_task(cfs_rq), cfs_rq);",
          "7375:  update_irq_load_avg(rq, 0);",
          "7376: #ifdef CONFIG_NO_HZ_COMMON",
          "7377:  rq->last_blocked_load_update_tick = jiffies;",
          "",
          "[Removed Lines]",
          "7373:  update_rt_rq_load_avg(rq_clock_task(rq), rq, 0);",
          "7374:  update_dl_rq_load_avg(rq_clock_task(rq), rq, 0);",
          "",
          "[Added Lines]",
          "7371:  const struct sched_class *curr_class;",
          "7378:  curr_class = rq->curr->sched_class;",
          "7379:  update_rt_rq_load_avg(rq_clock_task(rq), rq, curr_class == &rt_sched_class);",
          "7380:  update_dl_rq_load_avg(rq_clock_task(rq), rq, curr_class == &dl_sched_class);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "039ae8bcf7a5f4476f4487e6bf816885fb3fb617",
      "candidate_info": {
        "commit_hash": "039ae8bcf7a5f4476f4487e6bf816885fb3fb617",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/039ae8bcf7a5f4476f4487e6bf816885fb3fb617",
        "files": [
          "kernel/sched/fair.c"
        ],
        "message": "sched/fair: Fix O(nr_cgroups) in the load balancing path\n\nThis re-applies the commit reverted here:\n\n  commit c40f7d74c741 (\"sched/fair: Fix infinite loop in update_blocked_averages() by reverting a9e7f6544b9c\")\n\nI.e. now that cfs_rq can be safely removed/added in the list, we can re-apply:\n\n commit a9e7f6544b9c (\"sched/fair: Fix O(nr_cgroups) in load balance path\")\n\nSigned-off-by: Vincent Guittot <vincent.guittot@linaro.org>\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: sargun@sargun.me\nCc: tj@kernel.org\nCc: xiexiuqi@huawei.com\nCc: xiezhipeng1@huawei.com\nLink: https://lkml.kernel.org/r/1549469662-13614-3-git-send-email-vincent.guittot@linaro.org\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "before_after_code_files": [
          "kernel/sched/fair.c||kernel/sched/fair.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/sched/fair.c||kernel/sched/fair.c"
          ],
          "candidate": [
            "kernel/sched/fair.c||kernel/sched/fair.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/sched/fair.c||kernel/sched/fair.c": [
          "File: kernel/sched/fair.c -> kernel/sched/fair.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "368:  SCHED_WARN_ON(rq->tmp_alone_branch != &rq->leaf_cfs_rq_list);",
          "369: }",
          "376: static inline struct cfs_rq *",
          "",
          "[Removed Lines]",
          "372: #define for_each_leaf_cfs_rq(rq, cfs_rq) \\",
          "373:  list_for_each_entry_rcu(cfs_rq, &rq->leaf_cfs_rq_list, leaf_cfs_rq_list)",
          "",
          "[Added Lines]",
          "372: #define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)   \\",
          "373:  list_for_each_entry_safe(cfs_rq, pos, &rq->leaf_cfs_rq_list, \\",
          "374:      leaf_cfs_rq_list)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "461: {",
          "462: }",
          "467: static inline struct sched_entity *parent_entity(struct sched_entity *se)",
          "468: {",
          "",
          "[Removed Lines]",
          "464: #define for_each_leaf_cfs_rq(rq, cfs_rq) \\",
          "465:   for (cfs_rq = &rq->cfs; cfs_rq; cfs_rq = NULL)",
          "",
          "[Added Lines]",
          "465: #define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) \\",
          "466:   for (cfs_rq = &rq->cfs, pos = NULL; cfs_rq; cfs_rq = pos)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "7703: #ifdef CONFIG_FAIR_GROUP_SCHED",
          "7705: static void update_blocked_averages(int cpu)",
          "7706: {",
          "7707:  struct rq *rq = cpu_rq(cpu);",
          "7709:  const struct sched_class *curr_class;",
          "7710:  struct rq_flags rf;",
          "7711:  bool done = true;",
          "",
          "[Removed Lines]",
          "7708:  struct cfs_rq *cfs_rq;",
          "",
          "[Added Lines]",
          "7706: static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)",
          "7707: {",
          "7708:  if (cfs_rq->load.weight)",
          "7709:   return false;",
          "7711:  if (cfs_rq->avg.load_sum)",
          "7712:   return false;",
          "7714:  if (cfs_rq->avg.util_sum)",
          "7715:   return false;",
          "7717:  if (cfs_rq->avg.runnable_load_sum)",
          "7718:   return false;",
          "7720:  return true;",
          "7721: }",
          "7726:  struct cfs_rq *cfs_rq, *pos;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "7721:   struct sched_entity *se;",
          "7723:   if (update_cfs_rq_load_avg(cfs_rq_clock_pelt(cfs_rq), cfs_rq))",
          "",
          "[Removed Lines]",
          "7720:  for_each_leaf_cfs_rq(rq, cfs_rq) {",
          "",
          "[Added Lines]",
          "7738:  for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "7728:   if (se && !skip_blocked_update(se))",
          "7729:    update_load_avg(cfs_rq_of(se), se, 0);",
          "7732:   if (cfs_rq_has_blocked(cfs_rq))",
          "7733:    done = false;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7753:   if (cfs_rq_is_decayed(cfs_rq))",
          "7754:    list_del_leaf_cfs_rq(cfs_rq);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "10609: #ifdef CONFIG_SCHED_DEBUG",
          "10610: void print_cfs_stats(struct seq_file *m, int cpu)",
          "10611: {",
          "10614:  rcu_read_lock();",
          "10616:   print_cfs_rq(m, cpu, cfs_rq);",
          "10617:  rcu_read_unlock();",
          "10618: }",
          "",
          "[Removed Lines]",
          "10612:  struct cfs_rq *cfs_rq;",
          "10615:  for_each_leaf_cfs_rq(cpu_rq(cpu), cfs_rq)",
          "",
          "[Added Lines]",
          "10637:  struct cfs_rq *cfs_rq, *pos;",
          "10640:  for_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
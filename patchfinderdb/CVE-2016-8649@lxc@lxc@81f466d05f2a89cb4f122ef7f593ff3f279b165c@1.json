{
  "cve_id": "CVE-2016-8649",
  "cve_desc": "lxc-attach in LXC before 1.0.9 and 2.x before 2.0.6 allows an attacker inside of an unprivileged container to use an inherited file descriptor, of the host's /proc, to access the rest of the host's filesystem via the openat() family of syscalls.",
  "repo": "lxc/lxc",
  "patch_hash": "81f466d05f2a89cb4f122ef7f593ff3f279b165c",
  "patch_info": {
    "commit_hash": "81f466d05f2a89cb4f122ef7f593ff3f279b165c",
    "repo": "lxc/lxc",
    "commit_url": "https://github.com/lxc/lxc/commit/81f466d05f2a89cb4f122ef7f593ff3f279b165c",
    "files": [
      "src/lxc/attach.c"
    ],
    "message": "attach: do not send procfd to attached process\n\nSo far, we opened a file descriptor refering to proc on the host inside the\nhost namespace and handed that fd to the attached process in\nattach_child_main(). This was done to ensure that LSM labels were correctly\nsetup. However, by exploiting a potential kernel bug, ptrace could be used to\nprevent the file descriptor from being closed which in turn could be used by an\nunprivileged container to gain access to the host namespace. Aside from this\nneeding an upstream kernel fix, we should make sure that we don't pass the fd\nfor proc itself to the attached process. However, we cannot completely prevent\nthis, as the attached process needs to be able to change its apparmor profile\nby writing to /proc/self/attr/exec or /proc/self/attr/current. To minimize the\nattack surface, we only send the fd for /proc/self/attr/exec or\n/proc/self/attr/current to the attached process. To do this we introduce a\nlittle more IPC between the child and parent:\n\n\t * IPC mechanism: (X is receiver)\n\t *   initial process        intermediate          attached\n\t *        X           <---  send pid of\n\t *                          attached proc,\n\t *                          then exit\n\t *    send 0 ------------------------------------>    X\n\t *                                              [do initialization]\n\t *        X  <------------------------------------  send 1\n\t *   [add to cgroup, ...]\n\t *    send 2 ------------------------------------>    X\n\t *\t\t\t\t\t\t[set LXC_ATTACH_NO_NEW_PRIVS]\n\t *        X  <------------------------------------  send 3\n\t *   [open LSM label fd]\n\t *    send 4 ------------------------------------>    X\n\t *   \t\t\t\t\t\t[set LSM label]\n\t *   close socket                                 close socket\n\t *                                                run program\n\nThe attached child tells the parent when it is ready to have its LSM labels set\nup. The parent then opens an approriate fd for the child PID to\n/proc/<pid>/attr/exec or /proc/<pid>/attr/current and sends it via SCM_RIGHTS\nto the child. The child can then set its LSM laben. Both sides then close the\nsocket fds and the child execs the requested process.\n\nSigned-off-by: Christian Brauner <christian.brauner@canonical.com>",
    "before_after_code_files": [
      "src/lxc/attach.c||src/lxc/attach.c"
    ]
  },
  "patch_diff": {
    "src/lxc/attach.c||src/lxc/attach.c": [
      "File: src/lxc/attach.c -> src/lxc/attach.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "54: #include \"namespace.h\"",
      "55: #include \"log.h\"",
      "56: #include \"attach.h\"",
      "57: #include \"caps.h\"",
      "58: #include \"config.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "56: #include \"af_unix.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "85: lxc_log_define(lxc_attach, lxc);",
      "88:  int labelfd = -1;",
      "90:  const char* name;",
      "93:  name = lsm_name();",
      "95:  if (strcmp(name, \"nop\") == 0)",
      "98:  if (strcmp(name, \"none\") == 0)",
      "102:  if (strcmp(name, \"AppArmor\") == 0)",
      "103:   on_exec = 0;",
      "105:  if (on_exec) {",
      "110:  }",
      "112:  if (labelfd < 0) {",
      "113:   SYSERROR(\"Unable to open LSM label\");",
      "116:  }",
      "118:  if (strcmp(name, \"AppArmor\") == 0) {",
      "119:   int size;",
      "121:   command = malloc(strlen(lsm_label) + strlen(\"changeprofile \") + 1);",
      "122:   if (!command) {",
      "123:    SYSERROR(\"Failed to write apparmor profile\");",
      "125:    goto out;",
      "126:   }",
      "128:   size = sprintf(command, \"changeprofile %s\", lsm_label);",
      "129:   if (size < 0) {",
      "130:    SYSERROR(\"Failed to write apparmor profile\");",
      "132:    goto out;",
      "133:   }",
      "138:    goto out;",
      "139:   }",
      "143:    SYSERROR(\"Unable to set LSM label\");",
      "145:    goto out;",
      "146:   }",
      "149:   ERROR(\"Unable to restore label for unknown LSM: %s\", name);",
      "151:   goto out;",
      "152:  }",
      "154: out:",
      "155:  free(command);",
      "161: }",
      "163: static struct lxc_proc_context_info *lxc_proc_get_context_info(pid_t pid)",
      "",
      "[Removed Lines]",
      "87: int lsm_set_label_at(int procfd, int on_exec, char* lsm_label) {",
      "89:  int ret = 0;",
      "91:  char* command = NULL;",
      "96:   goto out;",
      "99:   goto out;",
      "106:   labelfd = openat(procfd, \"self/attr/exec\", O_RDWR);",
      "107:  }",
      "108:  else {",
      "109:   labelfd = openat(procfd, \"self/attr/current\", O_RDWR);",
      "114:   ret = -1;",
      "115:   goto out;",
      "124:    ret = -1;",
      "131:    ret = -1;",
      "135:   if (write(labelfd, command, size + 1) < 0) {",
      "136:    SYSERROR(\"Unable to set LSM label\");",
      "137:    ret = -1;",
      "140:  }",
      "141:  else if (strcmp(name, \"SELinux\") == 0) {",
      "142:   if (write(labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {",
      "144:    ret = -1;",
      "147:  }",
      "148:  else {",
      "150:   ret = -1;",
      "157:  if (labelfd != -1)",
      "158:   close(labelfd);",
      "160:  return ret;",
      "",
      "[Added Lines]",
      "88: static int lsm_openat(int procfd, pid_t pid, int on_exec)",
      "89: {",
      "90:  int ret = -1;",
      "93: #define __LSMATTRLEN /* /proc */ (5 + /* /pid-to-str */ 21 + /* /current */ 7 + /* \\0 */ 1)",
      "94:  char path[__LSMATTRLEN];",
      "99:   return 0;",
      "102:   return 0;",
      "109:   ret = snprintf(path, __LSMATTRLEN, \"%d/attr/exec\", pid);",
      "110:   if (ret < 0 || ret >= __LSMATTRLEN)",
      "111:    return -1;",
      "112:   labelfd = openat(procfd, path, O_RDWR);",
      "113:  } else {",
      "114:   ret = snprintf(path, __LSMATTRLEN, \"%d/attr/current\", pid);",
      "115:   if (ret < 0 || ret >= __LSMATTRLEN)",
      "116:    return -1;",
      "117:   labelfd = openat(procfd, path, O_RDWR);",
      "122:   return -1;",
      "125:  return labelfd;",
      "126: }",
      "128: static int lsm_set_label_at(int lsm_labelfd, int on_exec, char *lsm_label)",
      "129: {",
      "130:  int fret = -1;",
      "131:  const char* name;",
      "132:  char *command = NULL;",
      "134:  name = lsm_name();",
      "136:  if (strcmp(name, \"nop\") == 0)",
      "137:   return 0;",
      "139:  if (strcmp(name, \"none\") == 0)",
      "140:   return 0;",
      "143:  if (strcmp(name, \"AppArmor\") == 0)",
      "144:   on_exec = 0;",
      "161:   if (write(lsm_labelfd, command, size + 1) < 0) {",
      "162:    SYSERROR(\"Unable to set LSM label: %s.\", command);",
      "165:   INFO(\"Set LSM label to: %s.\", command);",
      "166:  } else if (strcmp(name, \"SELinux\") == 0) {",
      "167:   if (write(lsm_labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {",
      "171:   INFO(\"Set LSM label to: %s.\", lsm_label);",
      "172:  } else {",
      "176:  fret = 0;",
      "181:  if (lsm_labelfd != -1)",
      "182:   close(lsm_labelfd);",
      "184:  return fret;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "646:  struct lxc_proc_context_info* init_ctx;",
      "647:  lxc_attach_exec_t exec_function;",
      "648:  void* exec_payload;",
      "650: };",
      "652: static int attach_child_main(void* data);",
      "",
      "[Removed Lines]",
      "649:  int procfd;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "744:  char* cwd;",
      "745:  char* new_cwd;",
      "746:  int ipc_sockets[2];",
      "748:  signed long personality;",
      "750:  if (!options)",
      "",
      "[Removed Lines]",
      "747:  int procfd;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "854:  }",
      "856:  if (pid) {",
      "857:   pid_t to_cleanup_pid = pid;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "884:   int procfd = -1;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "868:     goto cleanup_error;",
      "869:   }",
      "872:   status = 0;",
      "873:   ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "902:   procfd = open(\"/proc\", O_DIRECTORY | O_RDONLY | O_CLOEXEC);",
      "903:   if (procfd < 0) {",
      "904:    SYSERROR(\"Unable to open /proc.\");",
      "905:    goto cleanup_error;",
      "906:   }",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "911:   ret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);",
      "912:   if (ret <= 0) {",
      "913:    if (ret != 0)",
      "915:    goto cleanup_error;",
      "916:   }",
      "",
      "[Removed Lines]",
      "914:     ERROR(\"error using IPC to receive notification from attached process (1)\");",
      "",
      "[Added Lines]",
      "951:     ERROR(\"error using IPC to receive notification \"",
      "952:           \"from attached process (1)\");",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "919:   status = 2;",
      "920:   ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));",
      "921:   if (ret <= 0) {",
      "923:    goto cleanup_error;",
      "924:   }",
      "927:   shutdown(ipc_sockets[0], SHUT_RDWR);",
      "928:   close(ipc_sockets[0]);",
      "",
      "[Removed Lines]",
      "922:    ERROR(\"error using IPC to notify attached process for initialization (2)\");",
      "",
      "[Added Lines]",
      "960:    ERROR(\"Error using IPC to notify attached process for \"",
      "961:          \"initialization (2): %s.\", strerror(errno));",
      "968:   expected = 3;",
      "969:   ret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);",
      "970:   if (ret <= 0) {",
      "971:    ERROR(\"Error using IPC for the child to tell us to open LSM fd (3): %s.\",",
      "972:          strerror(errno));",
      "973:    goto cleanup_error;",
      "974:   }",
      "977:   if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {",
      "978:    int on_exec, labelfd;",
      "979:    on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;",
      "981:    labelfd = lsm_openat(procfd, attached_pid, on_exec);",
      "982:    if (labelfd < 0)",
      "983:     goto cleanup_error;",
      "986:    ret = lxc_abstract_unix_send_fd(ipc_sockets[0], labelfd, NULL, 0);",
      "987:    if (ret <= 0) {",
      "988:     ERROR(\"Error using IPC to send child LSM fd (4): %s.\",",
      "989:       strerror(errno));",
      "990:     goto cleanup_error;",
      "991:    }",
      "992:   }",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "943:   shutdown(ipc_sockets[0], SHUT_RDWR);",
      "944:   close(ipc_sockets[0]);",
      "945:   if (to_cleanup_pid)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1011:   if (procfd >= 0)",
      "1012:    close(procfd);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "966:  if ((options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) && cgns_supported())",
      "967:   options->namespaces |= CLONE_NEWCGROUP;",
      "",
      "[Removed Lines]",
      "969:  procfd = open(\"/proc\", O_DIRECTORY | O_RDONLY);",
      "970:  if (procfd < 0) {",
      "971:   SYSERROR(\"Unable to open /proc\");",
      "972:   shutdown(ipc_sockets[1], SHUT_RDWR);",
      "973:   rexit(-1);",
      "974:  }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "1001:    .init_ctx = init_ctx,",
      "1002:    .exec_function = exec_function,",
      "1003:    .exec_payload = exec_payload,",
      "1005:   };",
      "",
      "[Removed Lines]",
      "1004:    .procfd = procfd",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "1039: {",
      "1040:  struct attach_clone_payload* payload = (struct attach_clone_payload*)data;",
      "1041:  int ipc_socket = payload->ipc_socket;",
      "1043:  lxc_attach_options_t* options = payload->options;",
      "1044:  struct lxc_proc_context_info* init_ctx = payload->init_ctx;",
      "1045: #if HAVE_SYS_PERSONALITY_H",
      "",
      "[Removed Lines]",
      "1042:  int procfd = payload->procfd;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "1050:  int expected;",
      "1051:  long flags;",
      "1052:  int fd;",
      "1053:  uid_t new_uid;",
      "1054:  gid_t new_gid;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1114:  int lsm_labelfd;",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "1060:  status = -1;",
      "1061:  ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);",
      "1062:  if (ret <= 0) {",
      "1064:   shutdown(ipc_socket, SHUT_RDWR);",
      "1065:   rexit(-1);",
      "1066:  }",
      "",
      "[Removed Lines]",
      "1063:   ERROR(\"error using IPC to receive notification from initial process (0)\");",
      "",
      "[Added Lines]",
      "1125:   ERROR(\"Error using IPC to receive notification from initial process (0): %s.\", strerror(errno));",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "1159:  status = 1;",
      "1160:  ret = lxc_write_nointr(ipc_socket, &status, sizeof(status));",
      "1161:  if (ret != sizeof(status)) {",
      "1163:   shutdown(ipc_socket, SHUT_RDWR);",
      "1164:   rexit(-1);",
      "1165:  }",
      "",
      "[Removed Lines]",
      "1162:   ERROR(\"error using IPC to notify initial process for initialization (1)\");",
      "",
      "[Added Lines]",
      "1224:   ERROR(\"Error using IPC to notify initial process for initialization (1): %s.\", strerror(errno));",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "1171:  status = -1;",
      "1172:  ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);",
      "1173:  if (ret <= 0) {",
      "1175:   shutdown(ipc_socket, SHUT_RDWR);",
      "1176:   rexit(-1);",
      "1177:  }",
      "1182:  if ((init_ctx->container && init_ctx->container->lxc_conf &&",
      "1183:       init_ctx->container->lxc_conf->no_new_privs) ||",
      "1184:      (options->attach_flags & LXC_ATTACH_NO_NEW_PRIVS)) {",
      "",
      "[Removed Lines]",
      "1174:   ERROR(\"error using IPC to receive final notification from initial process (2)\");",
      "1179:  shutdown(ipc_socket, SHUT_RDWR);",
      "1180:  close(ipc_socket);",
      "",
      "[Added Lines]",
      "1236:   ERROR(\"Error using IPC to receive message from initial process \"",
      "1237:         \"that it is done pre-initializing (2): %s\",",
      "1238:         strerror(errno));",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "1186:    SYSERROR(\"PR_SET_NO_NEW_PRIVS could not be set. \"",
      "1187:      \"Process can use execve() gainable \"",
      "1188:      \"privileges.\");",
      "1189:    rexit(-1);",
      "1190:   }",
      "1191:   INFO(\"PR_SET_NO_NEW_PRIVS is set. Process cannot use execve() \"",
      "1192:        \"gainable privileges.\");",
      "1193:  }",
      "1196:  if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {",
      "1197:   int on_exec;",
      "1199:   on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;",
      "1201:    rexit(-1);",
      "1202:   }",
      "1203:  }",
      "1204:  if (init_ctx->container && init_ctx->container->lxc_conf &&",
      "1205:      init_ctx->container->lxc_conf->seccomp &&",
      "1206:      (lxc_seccomp_load(init_ctx->container->lxc_conf) != 0)) {",
      "1207:   ERROR(\"Loading seccomp policy\");",
      "1208:   rexit(-1);",
      "1209:  }",
      "1210:  lxc_proc_put_context_info(init_ctx);",
      "",
      "[Removed Lines]",
      "1200:   if (lsm_set_label_at(procfd, on_exec, init_ctx->lsm_label) < 0) {",
      "",
      "[Added Lines]",
      "1250:    shutdown(ipc_socket, SHUT_RDWR);",
      "1258:  status = 3;",
      "1259:  ret = lxc_write_nointr(ipc_socket, &status, sizeof(status));",
      "1260:  if (ret <= 0) {",
      "1261:   ERROR(\"Error using IPC to tell parent to set up LSM labels (3): %s.\", strerror(errno));",
      "1262:   shutdown(ipc_socket, SHUT_RDWR);",
      "1263:   rexit(-1);",
      "1264:  }",
      "1269:   ret = lxc_abstract_unix_recv_fd(ipc_socket, &lsm_labelfd, NULL, 0);",
      "1270:   if (ret <= 0) {",
      "1271:    ERROR(\"Error using IPC for parent to tell us LSM label fd (4): %s.\", strerror(errno));",
      "1272:    shutdown(ipc_socket, SHUT_RDWR);",
      "1273:    rexit(-1);",
      "1274:   }",
      "1278:   if (lsm_set_label_at(lsm_labelfd, on_exec, init_ctx->lsm_label) < 0) {",
      "1279:    SYSERROR(\"Failed to set LSM label.\");",
      "1280:    shutdown(ipc_socket, SHUT_RDWR);",
      "1281:    close(lsm_labelfd);",
      "1284:   close(lsm_labelfd);",
      "1291:   shutdown(ipc_socket, SHUT_RDWR);",
      "1295:  shutdown(ipc_socket, SHUT_RDWR);",
      "1296:  close(ipc_socket);",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "1245:     SYSERROR(\"Unable to clear CLOEXEC from fd\");",
      "1246:  }",
      "1252:  rexit(payload->exec_function(payload->exec_payload));",
      "1253: }",
      "",
      "[Removed Lines]",
      "1249:  close(procfd);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "82b1f317c8fbf9b81cb68a2c9be8ff36260f8ebc",
      "candidate_info": {
        "commit_hash": "82b1f317c8fbf9b81cb68a2c9be8ff36260f8ebc",
        "repo": "lxc/lxc",
        "commit_url": "https://github.com/lxc/lxc/commit/82b1f317c8fbf9b81cb68a2c9be8ff36260f8ebc",
        "files": [
          "src/lxc/attach.c"
        ],
        "message": "attach: simplify lsm_openat()\n\nSigned-off-by: Christian Brauner <christian.brauner@ubuntu.com>",
        "before_after_code_files": [
          "src/lxc/attach.c||src/lxc/attach.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lxc/attach.c||src/lxc/attach.c"
          ],
          "candidate": [
            "src/lxc/attach.c||src/lxc/attach.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lxc/attach.c||src/lxc/attach.c": [
          "File: src/lxc/attach.c -> src/lxc/attach.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "86: lxc_log_define(lxc_attach, lxc);",
          "88: static int lsm_openat(int procfd, pid_t pid, int on_exec)",
          "89: {",
          "90:  int ret = -1;",
          "91:  int labelfd = -1;",
          "94:  char path[__LSMATTRLEN];",
          "96:  name = lsm_name();",
          "",
          "[Removed Lines]",
          "92:  const char* name;",
          "93: #define __LSMATTRLEN /* /proc */ (5 + /* /pid-to-str */ 21 + /* /current */ 7 + /* \\0 */ 1)",
          "",
          "[Added Lines]",
          "89: #define __LSMATTRLEN (5 + 21 + 7 + 1)",
          "94:  const char *name;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "105:  if (strcmp(name, \"AppArmor\") == 0)",
          "106:   on_exec = 0;",
          "109:   ret = snprintf(path, __LSMATTRLEN, \"%d/attr/exec\", pid);",
          "114:   ret = snprintf(path, __LSMATTRLEN, \"%d/attr/current\", pid);",
          "120:  if (labelfd < 0) {",
          "122:   return -1;",
          "123:  }",
          "",
          "[Removed Lines]",
          "108:  if (on_exec) {",
          "110:   if (ret < 0 || ret >= __LSMATTRLEN)",
          "111:    return -1;",
          "112:   labelfd = openat(procfd, path, O_RDWR);",
          "113:  } else {",
          "115:   if (ret < 0 || ret >= __LSMATTRLEN)",
          "116:    return -1;",
          "117:   labelfd = openat(procfd, path, O_RDWR);",
          "118:  }",
          "121:   SYSERROR(\"Unable to open LSM label\");",
          "",
          "[Added Lines]",
          "109:  if (on_exec)",
          "111:  else",
          "113:  if (ret < 0 || ret >= __LSMATTRLEN)",
          "114:   return -1;",
          "116:  labelfd = openat(procfd, path, O_RDWR);",
          "118:   SYSERROR(\"Unable to open file descriptor to set LSM label.\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fad6ef95ff55e72fa629affef6d31b1e666c995d",
      "candidate_info": {
        "commit_hash": "fad6ef95ff55e72fa629affef6d31b1e666c995d",
        "repo": "lxc/lxc",
        "commit_url": "https://github.com/lxc/lxc/commit/fad6ef95ff55e72fa629affef6d31b1e666c995d",
        "files": [
          "src/lxc/attach.c",
          "src/lxc/conf.c"
        ],
        "message": "conf, attach: save errno across call to close\n\nSave errno across some calls to close() since it can be\ninterrupted.\n\nSigned-off-by: Wolfgang Bumiller <wry.git@bumiller.com>",
        "before_after_code_files": [
          "src/lxc/attach.c||src/lxc/attach.c",
          "src/lxc/conf.c||src/lxc/conf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lxc/attach.c||src/lxc/attach.c"
          ],
          "candidate": [
            "src/lxc/attach.c||src/lxc/attach.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lxc/attach.c||src/lxc/attach.c": [
          "File: src/lxc/attach.c -> src/lxc/attach.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "974:   if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {",
          "976:    int labelfd = -1;",
          "977:    on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;",
          "",
          "[Removed Lines]",
          "975:    int on_exec;",
          "",
          "[Added Lines]",
          "975:    int on_exec, saved_errno;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "984:    ret = lxc_abstract_unix_send_fd(ipc_sockets[0], labelfd, NULL, 0);",
          "985:    close(labelfd);",
          "986:    if (ret <= 0) {",
          "988:     goto on_error;",
          "989:    }",
          "990:   }",
          "",
          "[Removed Lines]",
          "987:     ERROR(\"Intended to send file descriptor %d: %s.\", labelfd, strerror(errno));",
          "",
          "[Added Lines]",
          "985:    saved_errno = errno;",
          "988:     ERROR(\"Intended to send file descriptor %d: %s.\", labelfd, strerror(saved_errno));",
          "",
          "---------------"
        ],
        "src/lxc/conf.c||src/lxc/conf.c": [
          "File: src/lxc/conf.c -> src/lxc/conf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2018:  }",
          "2020:  if (!file) {",
          "2021:   if (fd != -1)",
          "2022:    close(fd);",
          "2024:   return NULL;",
          "2025:  }",
          "",
          "[Removed Lines]",
          "2023:   ERROR(\"Could not create mount entry file: %s.\", strerror(errno));",
          "",
          "[Added Lines]",
          "2021:   int saved_errno = errno;",
          "2024:   ERROR(\"Could not create mount entry file: %s.\", strerror(saved_errno));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2188: {",
          "2189:  struct sockaddr sockaddr;",
          "2190:  struct ifreq ifr;",
          "2193:  ret = lxc_convert_mac(hwaddr, &sockaddr);",
          "2194:  if (ret) {",
          "",
          "[Removed Lines]",
          "2191:  int ret, fd;",
          "",
          "[Added Lines]",
          "2192:  int ret, fd, saved_errno;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2208:  }",
          "2210:  ret = ioctl(fd, SIOCSIFHWADDR, &ifr);",
          "2211:  close(fd);",
          "2212:  if (ret)",
          "2215:  DEBUG(\"mac address '%s' on '%s' has been setup\", hwaddr, ifr.ifr_name);",
          "",
          "[Removed Lines]",
          "2213:   ERROR(\"ioctl failure : %s\", strerror(errno));",
          "",
          "[Added Lines]",
          "2212:  saved_errno = errno;",
          "2215:   ERROR(\"ioctl failure : %s\", strerror(saved_errno));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9f27a4102459c85ce32383f08e08e1c9b5f40119",
      "candidate_info": {
        "commit_hash": "9f27a4102459c85ce32383f08e08e1c9b5f40119",
        "repo": "lxc/lxc",
        "commit_url": "https://github.com/lxc/lxc/commit/9f27a4102459c85ce32383f08e08e1c9b5f40119",
        "files": [
          "src/lxc/attach.c"
        ],
        "message": "attach: do not send procfd to attached process\n\nSo far, we opened a file descriptor refering to proc on the host inside the\nhost namespace and handed that fd to the attached process in\nattach_child_main(). This was done to ensure that LSM labels were correctly\nsetup. However, by exploiting a potential kernel bug, ptrace could be used to\nprevent the file descriptor from being closed which in turn could be used by an\nunprivileged container to gain access to the host namespace. Aside from this\nneeding an upstream kernel fix, we should make sure that we don't pass the fd\nfor proc itself to the attached process. However, we cannot completely prevent\nthis, as the attached process needs to be able to change its apparmor profile\nby writing to /proc/self/attr/exec or /proc/self/attr/current. To minimize the\nattack surface, we only send the fd for /proc/self/attr/exec or\n/proc/self/attr/current to the attached process. To do this we introduce a\nlittle more IPC between the child and parent:\n\n\t * IPC mechanism: (X is receiver)\n\t *   initial process        intermediate          attached\n\t *        X           <---  send pid of\n\t *                          attached proc,\n\t *                          then exit\n\t *    send 0 ------------------------------------>    X\n\t *                                              [do initialization]\n\t *        X  <------------------------------------  send 1\n\t *   [add to cgroup, ...]\n\t *    send 2 ------------------------------------>    X\n\t *\t\t\t\t\t\t[set LXC_ATTACH_NO_NEW_PRIVS]\n\t *        X  <------------------------------------  send 3\n\t *   [open LSM label fd]\n\t *    send 4 ------------------------------------>    X\n\t *   \t\t\t\t\t\t[set LSM label]\n\t *   close socket                                 close socket\n\t *                                                run program\n\nThe attached child tells the parent when it is ready to have its LSM labels set\nup. The parent then opens an approriate fd for the child PID to\n/proc/<pid>/attr/exec or /proc/<pid>/attr/current and sends it via SCM_RIGHTS\nto the child. The child can then set its LSM laben. Both sides then close the\nsocket fds and the child execs the requested process.\n\nSigned-off-by: Christian Brauner <christian.brauner@canonical.com>",
        "before_after_code_files": [
          "src/lxc/attach.c||src/lxc/attach.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_message": 1,
        "olp_code_files": {
          "patch": [
            "src/lxc/attach.c||src/lxc/attach.c"
          ],
          "candidate": [
            "src/lxc/attach.c||src/lxc/attach.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lxc/attach.c||src/lxc/attach.c": [
          "File: src/lxc/attach.c -> src/lxc/attach.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #define _GNU_SOURCE",
          "30: #include <errno.h>",
          "31: #include <fcntl.h>",
          "32: #include <grp.h>",
          "33: #include <sys/param.h>",
          "34: #include <sys/prctl.h>",
          "36: #include <sys/socket.h>",
          "37: #include <sys/syscall.h>",
          "38: #include <sys/wait.h>",
          "42: #if !HAVE_DECL_PR_CAPBSET_DROP",
          "43: #define PR_CAPBSET_DROP 24",
          "44: #endif",
          "48: #include \"attach.h\"",
          "49: #include \"caps.h\"",
          "53: #include \"cgroup.h\"",
          "55: #include \"conf.h\"",
          "56: #include \"lxcseccomp.h\"",
          "58: #include \"lsm/lsm.h\"",
          "61: #if HAVE_SYS_PERSONALITY_H",
          "62: #include <sys/personality.h>",
          "",
          "[Removed Lines]",
          "25: #include <unistd.h>",
          "26: #include <stdio.h>",
          "27: #include <string.h>",
          "28: #include <stdlib.h>",
          "29: #include <signal.h>",
          "35: #include <sys/mount.h>",
          "39: #include <linux/unistd.h>",
          "40: #include <pwd.h>",
          "46: #include \"namespace.h\"",
          "47: #include \"log.h\"",
          "50: #include \"config.h\"",
          "51: #include \"utils.h\"",
          "52: #include \"commands.h\"",
          "54: #include \"lxclock.h\"",
          "57: #include <lxc/lxccontainer.h>",
          "59: #include \"confile.h\"",
          "",
          "[Added Lines]",
          "28: #include <pwd.h>",
          "29: #include <signal.h>",
          "30: #include <stdio.h>",
          "31: #include <stdlib.h>",
          "32: #include <string.h>",
          "33: #include <unistd.h>",
          "34: #include <linux/unistd.h>",
          "35: #include <sys/mount.h>",
          "46: #include \"af_unix.h\"",
          "50: #include \"commands.h\"",
          "52: #include \"config.h\"",
          "53: #include \"confile.h\"",
          "54: #include \"log.h\"",
          "55: #include \"lxclock.h\"",
          "57: #include \"namespace.h\"",
          "58: #include \"utils.h\"",
          "61: #include <lxc/lxccontainer.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "77: lxc_log_define(lxc_attach, lxc);",
          "80:  int labelfd = -1;",
          "82:  const char* name;",
          "85:  name = lsm_name();",
          "87:  if (strcmp(name, \"nop\") == 0)",
          "90:  if (strcmp(name, \"none\") == 0)",
          "94:  if (strcmp(name, \"AppArmor\") == 0)",
          "95:   on_exec = 0;",
          "97:  if (on_exec) {",
          "102:  }",
          "104:  if (labelfd < 0) {",
          "105:   SYSERROR(\"Unable to open LSM label\");",
          "108:  }",
          "110:  if (strcmp(name, \"AppArmor\") == 0) {",
          "111:   int size;",
          "113:   command = malloc(strlen(lsm_label) + strlen(\"changeprofile \") + 1);",
          "114:   if (!command) {",
          "115:    SYSERROR(\"Failed to write apparmor profile\");",
          "117:    goto out;",
          "118:   }",
          "120:   size = sprintf(command, \"changeprofile %s\", lsm_label);",
          "121:   if (size < 0) {",
          "122:    SYSERROR(\"Failed to write apparmor profile\");",
          "124:    goto out;",
          "125:   }",
          "130:    goto out;",
          "131:   }",
          "135:    SYSERROR(\"Unable to set LSM label\");",
          "137:    goto out;",
          "138:   }",
          "141:   ERROR(\"Unable to restore label for unknown LSM: %s\", name);",
          "143:   goto out;",
          "144:  }",
          "146: out:",
          "147:  free(command);",
          "153: }",
          "155: static struct lxc_proc_context_info *lxc_proc_get_context_info(pid_t pid)",
          "",
          "[Removed Lines]",
          "79: int lsm_set_label_at(int procfd, int on_exec, char* lsm_label) {",
          "81:  int ret = 0;",
          "83:  char* command = NULL;",
          "88:   goto out;",
          "91:   goto out;",
          "98:   labelfd = openat(procfd, \"self/attr/exec\", O_RDWR);",
          "99:  }",
          "100:  else {",
          "101:   labelfd = openat(procfd, \"self/attr/current\", O_RDWR);",
          "106:   ret = -1;",
          "107:   goto out;",
          "116:    ret = -1;",
          "123:    ret = -1;",
          "127:   if (write(labelfd, command, size + 1) < 0) {",
          "128:    SYSERROR(\"Unable to set LSM label\");",
          "129:    ret = -1;",
          "132:  }",
          "133:  else if (strcmp(name, \"SELinux\") == 0) {",
          "134:   if (write(labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {",
          "136:    ret = -1;",
          "139:  }",
          "140:  else {",
          "142:   ret = -1;",
          "149:  if (labelfd != -1)",
          "150:   close(labelfd);",
          "152:  return ret;",
          "",
          "[Added Lines]",
          "81: static int lsm_openat(int procfd, pid_t pid, int on_exec)",
          "82: {",
          "83:  int ret = -1;",
          "86: #define __LSMATTRLEN /* /proc */ (5 + /* /pid-to-str */ 21 + /* /current */ 7 + /* \\0 */ 1)",
          "87:  char path[__LSMATTRLEN];",
          "92:   return 0;",
          "95:   return 0;",
          "102:   ret = snprintf(path, __LSMATTRLEN, \"%d/attr/exec\", pid);",
          "103:   if (ret < 0 || ret >= __LSMATTRLEN)",
          "104:    return -1;",
          "105:   labelfd = openat(procfd, path, O_RDWR);",
          "106:  } else {",
          "107:   ret = snprintf(path, __LSMATTRLEN, \"%d/attr/current\", pid);",
          "108:   if (ret < 0 || ret >= __LSMATTRLEN)",
          "109:    return -1;",
          "110:   labelfd = openat(procfd, path, O_RDWR);",
          "115:   return -1;",
          "118:  return labelfd;",
          "119: }",
          "121: static int lsm_set_label_at(int lsm_labelfd, int on_exec, char *lsm_label)",
          "122: {",
          "123:  int fret = -1;",
          "124:  const char* name;",
          "125:  char *command = NULL;",
          "127:  name = lsm_name();",
          "129:  if (strcmp(name, \"nop\") == 0)",
          "130:   return 0;",
          "132:  if (strcmp(name, \"none\") == 0)",
          "133:   return 0;",
          "136:  if (strcmp(name, \"AppArmor\") == 0)",
          "137:   on_exec = 0;",
          "154:   if (write(lsm_labelfd, command, size + 1) < 0) {",
          "155:    SYSERROR(\"Unable to set LSM label: %s.\", command);",
          "158:   INFO(\"Set LSM label to: %s.\", command);",
          "159:  } else if (strcmp(name, \"SELinux\") == 0) {",
          "160:   if (write(lsm_labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {",
          "164:   INFO(\"Set LSM label to: %s.\", lsm_label);",
          "165:  } else {",
          "169:  fret = 0;",
          "174:  if (lsm_labelfd != -1)",
          "175:   close(lsm_labelfd);",
          "177:  return fret;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "646:  struct lxc_proc_context_info* init_ctx;",
          "647:  lxc_attach_exec_t exec_function;",
          "648:  void* exec_payload;",
          "650: };",
          "652: static int attach_child_main(void* data);",
          "",
          "[Removed Lines]",
          "649:  int procfd;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "718:  char* cwd;",
          "719:  char* new_cwd;",
          "720:  int ipc_sockets[2];",
          "722:  signed long personality;",
          "724:  if (!options)",
          "",
          "[Removed Lines]",
          "721:  int procfd;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "821:  }",
          "823:  if (pid) {",
          "824:   pid_t to_cleanup_pid = pid;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "853:   int procfd = -1;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "835:     goto cleanup_error;",
          "836:   }",
          "839:   status = 0;",
          "840:   ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "871:   procfd = open(\"/proc\", O_DIRECTORY | O_RDONLY | O_CLOEXEC);",
          "872:   if (procfd < 0) {",
          "873:    SYSERROR(\"Unable to open /proc.\");",
          "874:    goto cleanup_error;",
          "875:   }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "847:   ret = lxc_read_nointr_expect(ipc_sockets[0], &attached_pid, sizeof(attached_pid), NULL);",
          "848:   if (ret <= 0) {",
          "849:    if (ret != 0)",
          "851:    goto cleanup_error;",
          "852:   }",
          "",
          "[Removed Lines]",
          "850:     ERROR(\"error using IPC to receive pid of attached process\");",
          "",
          "[Added Lines]",
          "889:     ERROR(\"error using IPC to receive notification \"",
          "890:           \"from attached process (1)\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "886:   status = 2;",
          "887:   ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));",
          "888:   if (ret <= 0) {",
          "890:    goto cleanup_error;",
          "891:   }",
          "894:   shutdown(ipc_sockets[0], SHUT_RDWR);",
          "895:   close(ipc_sockets[0]);",
          "",
          "[Removed Lines]",
          "889:    ERROR(\"error using IPC to notify attached process for initialization (2)\");",
          "",
          "[Added Lines]",
          "929:    ERROR(\"Error using IPC to notify attached process for \"",
          "930:          \"initialization (2): %s.\", strerror(errno));",
          "937:   expected = 3;",
          "938:   ret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);",
          "939:   if (ret <= 0) {",
          "940:    ERROR(\"Error using IPC for the child to tell us to open LSM fd (3): %s.\",",
          "941:      strerror(errno));",
          "942:    goto cleanup_error;",
          "943:   }",
          "946:   if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {",
          "947:    int on_exec, labelfd;",
          "948:    on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;",
          "950:    labelfd = lsm_openat(procfd, attached_pid, on_exec);",
          "951:    if (labelfd < 0)",
          "952:     goto cleanup_error;",
          "955:    ret = lxc_abstract_unix_send_fd(ipc_sockets[0], labelfd, NULL, 0);",
          "956:    if (ret <= 0) {",
          "957:     ERROR(\"Error using IPC to send child LSM fd (4): %s.\",",
          "958:       strerror(errno));",
          "959:     goto cleanup_error;",
          "960:    }",
          "961:   }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "910:   shutdown(ipc_sockets[0], SHUT_RDWR);",
          "911:   close(ipc_sockets[0]);",
          "912:   if (to_cleanup_pid)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "980:   if (procfd >= 0)",
          "981:    close(procfd);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "930:   rexit(-1);",
          "931:  }",
          "",
          "[Removed Lines]",
          "933:  procfd = open(\"/proc\", O_DIRECTORY | O_RDONLY);",
          "934:  if (procfd < 0) {",
          "935:   SYSERROR(\"Unable to open /proc\");",
          "936:   shutdown(ipc_sockets[1], SHUT_RDWR);",
          "937:   rexit(-1);",
          "938:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "964:    .options = options,",
          "965:    .init_ctx = init_ctx,",
          "966:    .exec_function = exec_function,",
          "969:   };",
          "",
          "[Removed Lines]",
          "967:    .exec_payload = exec_payload,",
          "968:    .procfd = procfd",
          "",
          "[Added Lines]",
          "1032:    .exec_payload = exec_payload",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1003: {",
          "1004:  struct attach_clone_payload* payload = (struct attach_clone_payload*)data;",
          "1005:  int ipc_socket = payload->ipc_socket;",
          "1007:  lxc_attach_options_t* options = payload->options;",
          "1008:  struct lxc_proc_context_info* init_ctx = payload->init_ctx;",
          "1009: #if HAVE_SYS_PERSONALITY_H",
          "",
          "[Removed Lines]",
          "1006:  int procfd = payload->procfd;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1014:  int expected;",
          "1015:  long flags;",
          "1016:  int fd;",
          "1017:  uid_t new_uid;",
          "1018:  gid_t new_gid;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1080:  int lsm_labelfd;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1024:  status = -1;",
          "1025:  ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);",
          "1026:  if (ret <= 0) {",
          "1028:   shutdown(ipc_socket, SHUT_RDWR);",
          "1029:   rexit(-1);",
          "1030:  }",
          "",
          "[Removed Lines]",
          "1027:   ERROR(\"error using IPC to receive notification from initial process (0)\");",
          "",
          "[Added Lines]",
          "1091:   ERROR(\"Error using IPC to receive notification from initial process (0): %s.\", strerror(errno));",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1123:  status = 1;",
          "1124:  ret = lxc_write_nointr(ipc_socket, &status, sizeof(status));",
          "1125:  if (ret != sizeof(status)) {",
          "1127:   shutdown(ipc_socket, SHUT_RDWR);",
          "1128:   rexit(-1);",
          "1129:  }",
          "",
          "[Removed Lines]",
          "1126:   ERROR(\"error using IPC to notify initial process for initialization (1)\");",
          "",
          "[Added Lines]",
          "1190:   ERROR(\"Error using IPC to notify initial process for initialization (1): %s.\", strerror(errno));",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1135:  status = -1;",
          "1136:  ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);",
          "1137:  if (ret <= 0) {",
          "1139:   shutdown(ipc_socket, SHUT_RDWR);",
          "1140:   rexit(-1);",
          "1141:  }",
          "1147:  if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {",
          "1148:   int on_exec;",
          "1150:   on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;",
          "1152:    rexit(-1);",
          "1153:   }",
          "1154:  }",
          "1156:  if (init_ctx->container && init_ctx->container->lxc_conf &&",
          "1157:    lxc_seccomp_load(init_ctx->container->lxc_conf) != 0) {",
          "1158:   ERROR(\"Loading seccomp policy\");",
          "1159:   rexit(-1);",
          "1160:  }",
          "1162:  lxc_proc_put_context_info(init_ctx);",
          "",
          "[Removed Lines]",
          "1138:   ERROR(\"error using IPC to receive final notification from initial process (2)\");",
          "1143:  shutdown(ipc_socket, SHUT_RDWR);",
          "1144:  close(ipc_socket);",
          "1151:   if (lsm_set_label_at(procfd, on_exec, init_ctx->lsm_label) < 0) {",
          "",
          "[Added Lines]",
          "1202:   ERROR(\"Error using IPC to receive message from initial process \"",
          "1203:         \"that it is done pre-initializing (2): %s\",",
          "1204:         strerror(errno));",
          "1210:  status = 3;",
          "1211:  ret = lxc_write_nointr(ipc_socket, &status, sizeof(status));",
          "1212:  if (ret <= 0) {",
          "1213:   ERROR(\"Error using IPC to tell parent to set up LSM labels (3): %s.\", strerror(errno));",
          "1214:   shutdown(ipc_socket, SHUT_RDWR);",
          "1215:   rexit(-1);",
          "1216:  }",
          "1221:   ret = lxc_abstract_unix_recv_fd(ipc_socket, &lsm_labelfd, NULL, 0);",
          "1222:   if (ret <= 0) {",
          "1223:    ERROR(\"Error using IPC for parent to tell us LSM label fd (4): %s.\", strerror(errno));",
          "1224:    shutdown(ipc_socket, SHUT_RDWR);",
          "1225:    rexit(-1);",
          "1226:   }",
          "1230:   if (lsm_set_label_at(lsm_labelfd, on_exec, init_ctx->lsm_label) < 0) {",
          "1231:    SYSERROR(\"Failed to set LSM label.\");",
          "1232:    shutdown(ipc_socket, SHUT_RDWR);",
          "1233:    close(lsm_labelfd);",
          "1236:   close(lsm_labelfd);",
          "1242:   shutdown(ipc_socket, SHUT_RDWR);",
          "1246:  shutdown(ipc_socket, SHUT_RDWR);",
          "1247:  close(ipc_socket);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1199:   }",
          "1200:  }",
          "1206:  rexit(payload->exec_function(payload->exec_payload));",
          "1207: }",
          "",
          "[Removed Lines]",
          "1203:  close(procfd);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ef7bedf6387d50b04297a6534730078cf9f9d20d",
      "candidate_info": {
        "commit_hash": "ef7bedf6387d50b04297a6534730078cf9f9d20d",
        "repo": "lxc/lxc",
        "commit_url": "https://github.com/lxc/lxc/commit/ef7bedf6387d50b04297a6534730078cf9f9d20d",
        "files": [
          "src/lxc/attach.c"
        ],
        "message": "attach: do not send procfd to attached process\n\nSo far, we opened a file descriptor refering to proc on the host inside the\nhost namespace and handed that fd to the attached process in\nattach_child_main(). This was done to ensure that LSM labels were correctly\nsetup. However, by exploiting a potential kernel bug, ptrace could be used to\nprevent the file descriptor from being closed which in turn could be used by an\nunprivileged container to gain access to the host namespace. Aside from this\nneeding an upstream kernel fix, we should make sure that we don't pass the fd\nfor proc itself to the attached process. However, we cannot completely prevent\nthis, as the attached process needs to be able to change its apparmor profile\nby writing to /proc/self/attr/exec or /proc/self/attr/current. To minimize the\nattack surface, we only send the fd for /proc/self/attr/exec or\n/proc/self/attr/current to the attached process. To do this we introduce a\nlittle more IPC between the child and parent:\n\n\t * IPC mechanism: (X is receiver)\n\t *   initial process        intermediate          attached\n\t *        X           <---  send pid of\n\t *                          attached proc,\n\t *                          then exit\n\t *    send 0 ------------------------------------>    X\n\t *                                              [do initialization]\n\t *        X  <------------------------------------  send 1\n\t *   [add to cgroup, ...]\n\t *    send 2 ------------------------------------>    X\n\t *\t\t\t\t\t\t[set LXC_ATTACH_NO_NEW_PRIVS]\n\t *        X  <------------------------------------  send 3\n\t *   [open LSM label fd]\n\t *    send 4 ------------------------------------>    X\n\t *   \t\t\t\t\t\t[set LSM label]\n\t *   close socket                                 close socket\n\t *                                                run program\n\nThe attached child tells the parent when it is ready to have its LSM labels set\nup. The parent then opens an approriate fd for the child PID to\n/proc/<pid>/attr/exec or /proc/<pid>/attr/current and sends it via SCM_RIGHTS\nto the child. The child can then set its LSM laben. Both sides then close the\nsocket fds and the child execs the requested process.\n\nSigned-off-by: Christian Brauner <christian.brauner@canonical.com>",
        "before_after_code_files": [
          "src/lxc/attach.c||src/lxc/attach.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_message": 1,
        "olp_code_files": {
          "patch": [
            "src/lxc/attach.c||src/lxc/attach.c"
          ],
          "candidate": [
            "src/lxc/attach.c||src/lxc/attach.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lxc/attach.c||src/lxc/attach.c": [
          "File: src/lxc/attach.c -> src/lxc/attach.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #define _GNU_SOURCE",
          "30: #include <errno.h>",
          "31: #include <fcntl.h>",
          "32: #include <grp.h>",
          "33: #include <sys/param.h>",
          "34: #include <sys/prctl.h>",
          "36: #include <sys/socket.h>",
          "37: #include <sys/syscall.h>",
          "38: #include <sys/wait.h>",
          "42: #if !HAVE_DECL_PR_CAPBSET_DROP",
          "43: #define PR_CAPBSET_DROP 24",
          "44: #endif",
          "48: #include \"attach.h\"",
          "49: #include \"caps.h\"",
          "53: #include \"cgroup.h\"",
          "55: #include \"conf.h\"",
          "56: #include \"lxcseccomp.h\"",
          "57: #include <lxc/lxccontainer.h>",
          "61: #if HAVE_SYS_PERSONALITY_H",
          "62: #include <sys/personality.h>",
          "",
          "[Removed Lines]",
          "25: #include <unistd.h>",
          "26: #include <stdio.h>",
          "27: #include <string.h>",
          "28: #include <stdlib.h>",
          "29: #include <signal.h>",
          "35: #include <sys/mount.h>",
          "39: #include <linux/unistd.h>",
          "40: #include <pwd.h>",
          "46: #include \"namespace.h\"",
          "47: #include \"log.h\"",
          "50: #include \"config.h\"",
          "51: #include \"utils.h\"",
          "52: #include \"commands.h\"",
          "54: #include \"lxclock.h\"",
          "58: #include \"lsm/lsm.h\"",
          "59: #include \"confile.h\"",
          "",
          "[Added Lines]",
          "28: #include <pwd.h>",
          "29: #include <signal.h>",
          "30: #include <stdio.h>",
          "31: #include <stdlib.h>",
          "32: #include <string.h>",
          "33: #include <unistd.h>",
          "34: #include <linux/unistd.h>",
          "35: #include <sys/mount.h>",
          "46: #include \"af_unix.h\"",
          "50: #include \"commands.h\"",
          "52: #include \"config.h\"",
          "53: #include \"confile.h\"",
          "54: #include \"log.h\"",
          "55: #include \"lsm/lsm.h\"",
          "56: #include \"lxclock.h\"",
          "58: #include \"namespace.h\"",
          "59: #include \"utils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "77: lxc_log_define(lxc_attach, lxc);",
          "80:  int labelfd = -1;",
          "82:  const char* name;",
          "85:  name = lsm_name();",
          "87:  if (strcmp(name, \"nop\") == 0)",
          "90:  if (strcmp(name, \"none\") == 0)",
          "94:  if (strcmp(name, \"AppArmor\") == 0)",
          "95:   on_exec = 0;",
          "97:  if (on_exec) {",
          "102:  }",
          "104:  if (labelfd < 0) {",
          "105:   SYSERROR(\"Unable to open LSM label\");",
          "108:  }",
          "110:  if (strcmp(name, \"AppArmor\") == 0) {",
          "111:   int size;",
          "113:   command = malloc(strlen(lsm_label) + strlen(\"changeprofile \") + 1);",
          "114:   if (!command) {",
          "115:    SYSERROR(\"Failed to write apparmor profile\");",
          "117:    goto out;",
          "118:   }",
          "120:   size = sprintf(command, \"changeprofile %s\", lsm_label);",
          "121:   if (size < 0) {",
          "122:    SYSERROR(\"Failed to write apparmor profile\");",
          "124:    goto out;",
          "125:   }",
          "130:    goto out;",
          "131:   }",
          "135:    SYSERROR(\"Unable to set LSM label\");",
          "137:    goto out;",
          "138:   }",
          "141:   ERROR(\"Unable to restore label for unknown LSM: %s\", name);",
          "143:   goto out;",
          "144:  }",
          "146: out:",
          "147:  free(command);",
          "153: }",
          "155: static struct lxc_proc_context_info *lxc_proc_get_context_info(pid_t pid)",
          "",
          "[Removed Lines]",
          "79: int lsm_set_label_at(int procfd, int on_exec, char* lsm_label) {",
          "81:  int ret = 0;",
          "83:  char* command = NULL;",
          "88:   goto out;",
          "91:   goto out;",
          "98:   labelfd = openat(procfd, \"self/attr/exec\", O_RDWR);",
          "99:  }",
          "100:  else {",
          "101:   labelfd = openat(procfd, \"self/attr/current\", O_RDWR);",
          "106:   ret = -1;",
          "107:   goto out;",
          "116:    ret = -1;",
          "123:    ret = -1;",
          "127:   if (write(labelfd, command, size + 1) < 0) {",
          "128:    SYSERROR(\"Unable to set LSM label\");",
          "129:    ret = -1;",
          "132:  }",
          "133:  else if (strcmp(name, \"SELinux\") == 0) {",
          "134:   if (write(labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {",
          "136:    ret = -1;",
          "139:  }",
          "140:  else {",
          "142:   ret = -1;",
          "149:  if (labelfd != -1)",
          "150:   close(labelfd);",
          "152:  return ret;",
          "",
          "[Added Lines]",
          "81: static int lsm_openat(int procfd, pid_t pid, int on_exec)",
          "82: {",
          "83:  int ret = -1;",
          "86: #define __LSMATTRLEN /* /proc */ (5 + /* /pid-to-str */ 21 + /* /current */ 7 + /* \\0 */ 1)",
          "87:  char path[__LSMATTRLEN];",
          "92:   return 0;",
          "95:   return 0;",
          "102:   ret = snprintf(path, __LSMATTRLEN, \"%d/attr/exec\", pid);",
          "103:   if (ret < 0 || ret >= __LSMATTRLEN)",
          "104:    return -1;",
          "105:   labelfd = openat(procfd, path, O_RDWR);",
          "106:  } else {",
          "107:   ret = snprintf(path, __LSMATTRLEN, \"%d/attr/current\", pid);",
          "108:   if (ret < 0 || ret >= __LSMATTRLEN)",
          "109:    return -1;",
          "110:   labelfd = openat(procfd, path, O_RDWR);",
          "115:   return -1;",
          "118:  return labelfd;",
          "119: }",
          "121: static int lsm_set_label_at(int lsm_labelfd, int on_exec, char *lsm_label)",
          "122: {",
          "123:  int fret = -1;",
          "124:  const char* name;",
          "125:  char *command = NULL;",
          "127:  name = lsm_name();",
          "129:  if (strcmp(name, \"nop\") == 0)",
          "130:   return 0;",
          "132:  if (strcmp(name, \"none\") == 0)",
          "133:   return 0;",
          "136:  if (strcmp(name, \"AppArmor\") == 0)",
          "137:   on_exec = 0;",
          "154:   if (write(lsm_labelfd, command, size + 1) < 0) {",
          "155:    SYSERROR(\"Unable to set LSM label: %s.\", command);",
          "158:   INFO(\"Set LSM label to: %s.\", command);",
          "159:  } else if (strcmp(name, \"SELinux\") == 0) {",
          "160:   if (write(lsm_labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {",
          "164:   INFO(\"Set LSM label to: %s.\", lsm_label);",
          "165:  } else {",
          "169:  fret = 0;",
          "174:  if (lsm_labelfd != -1)",
          "175:   close(lsm_labelfd);",
          "177:  return fret;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "638:  struct lxc_proc_context_info* init_ctx;",
          "639:  lxc_attach_exec_t exec_function;",
          "640:  void* exec_payload;",
          "642: };",
          "644: static int attach_child_main(void* data);",
          "",
          "[Removed Lines]",
          "641:  int procfd;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "710:  char* cwd;",
          "711:  char* new_cwd;",
          "712:  int ipc_sockets[2];",
          "714:  signed long personality;",
          "716:  if (!options)",
          "",
          "[Removed Lines]",
          "713:  int procfd;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "813:  }",
          "815:  if (pid) {",
          "816:   pid_t to_cleanup_pid = pid;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "844:   int procfd = -1;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "827:     goto cleanup_error;",
          "828:   }",
          "831:   status = 0;",
          "832:   ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "862:   procfd = open(\"/proc\", O_DIRECTORY | O_RDONLY | O_CLOEXEC);",
          "863:   if (procfd < 0) {",
          "864:    SYSERROR(\"Unable to open /proc.\");",
          "865:    goto cleanup_error;",
          "866:   }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "839:   ret = lxc_read_nointr_expect(ipc_sockets[0], &attached_pid, sizeof(attached_pid), NULL);",
          "840:   if (ret <= 0) {",
          "841:    if (ret != 0)",
          "843:    goto cleanup_error;",
          "844:   }",
          "",
          "[Removed Lines]",
          "842:     ERROR(\"error using IPC to receive pid of attached process\");",
          "",
          "[Added Lines]",
          "880:     ERROR(\"error using IPC to receive notification \"",
          "881:       \"from attached process (1)\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "878:   status = 2;",
          "879:   ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));",
          "880:   if (ret <= 0) {",
          "882:    goto cleanup_error;",
          "883:   }",
          "886:   shutdown(ipc_sockets[0], SHUT_RDWR);",
          "887:   close(ipc_sockets[0]);",
          "",
          "[Removed Lines]",
          "881:    ERROR(\"error using IPC to notify attached process for initialization (2)\");",
          "",
          "[Added Lines]",
          "920:    ERROR(\"Error using IPC to notify attached process for \"",
          "921:          \"initialization (2): %s.\", strerror(errno));",
          "928:   expected = 3;",
          "929:   ret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);",
          "930:   if (ret <= 0) {",
          "931:    ERROR(\"Error using IPC for the child to tell us to open LSM fd (3): %s.\",",
          "932:      strerror(errno));",
          "933:    goto cleanup_error;",
          "934:   }",
          "937:   if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {",
          "938:    int on_exec, labelfd;",
          "939:    on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;",
          "941:    labelfd = lsm_openat(procfd, attached_pid, on_exec);",
          "942:    if (labelfd < 0)",
          "943:     goto cleanup_error;",
          "946:    ret = lxc_abstract_unix_send_fd(ipc_sockets[0], labelfd, NULL, 0);",
          "947:    if (ret <= 0) {",
          "948:     ERROR(\"Error using IPC to send child LSM fd (4): %s.\",",
          "949:       strerror(errno));",
          "950:     goto cleanup_error;",
          "951:    }",
          "952:   }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "902:   shutdown(ipc_sockets[0], SHUT_RDWR);",
          "903:   close(ipc_sockets[0]);",
          "904:   if (to_cleanup_pid)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "971:   if (procfd >= 0)",
          "972:    close(procfd);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "925:  if ((options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) && cgns_supported())",
          "926:   options->namespaces |= CLONE_NEWCGROUP;",
          "",
          "[Removed Lines]",
          "928:  procfd = open(\"/proc\", O_DIRECTORY | O_RDONLY);",
          "929:  if (procfd < 0) {",
          "930:   SYSERROR(\"Unable to open /proc\");",
          "931:   shutdown(ipc_sockets[1], SHUT_RDWR);",
          "932:   rexit(-1);",
          "933:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "959:    .options = options,",
          "960:    .init_ctx = init_ctx,",
          "961:    .exec_function = exec_function,",
          "964:   };",
          "",
          "[Removed Lines]",
          "962:    .exec_payload = exec_payload,",
          "963:    .procfd = procfd",
          "",
          "[Added Lines]",
          "1026:    .exec_payload = exec_payload",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "998: {",
          "999:  struct attach_clone_payload* payload = (struct attach_clone_payload*)data;",
          "1000:  int ipc_socket = payload->ipc_socket;",
          "1002:  lxc_attach_options_t* options = payload->options;",
          "1003:  struct lxc_proc_context_info* init_ctx = payload->init_ctx;",
          "1004: #if HAVE_SYS_PERSONALITY_H",
          "",
          "[Removed Lines]",
          "1001:  int procfd = payload->procfd;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1009:  int expected;",
          "1010:  long flags;",
          "1011:  int fd;",
          "1012:  uid_t new_uid;",
          "1013:  gid_t new_gid;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1074:  int lsm_labelfd;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1019:  status = -1;",
          "1020:  ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);",
          "1021:  if (ret <= 0) {",
          "1023:   shutdown(ipc_socket, SHUT_RDWR);",
          "1024:   rexit(-1);",
          "1025:  }",
          "",
          "[Removed Lines]",
          "1022:   ERROR(\"error using IPC to receive notification from initial process (0)\");",
          "",
          "[Added Lines]",
          "1085:   ERROR(\"Error using IPC to receive notification from initial process (0): %s.\", strerror(errno));",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1118:  status = 1;",
          "1119:  ret = lxc_write_nointr(ipc_socket, &status, sizeof(status));",
          "1120:  if (ret != sizeof(status)) {",
          "1122:   shutdown(ipc_socket, SHUT_RDWR);",
          "1123:   rexit(-1);",
          "1124:  }",
          "",
          "[Removed Lines]",
          "1121:   ERROR(\"error using IPC to notify initial process for initialization (1)\");",
          "",
          "[Added Lines]",
          "1184:   ERROR(\"Error using IPC to notify initial process for initialization (1): %s.\", strerror(errno));",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1130:  status = -1;",
          "1131:  ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);",
          "1132:  if (ret <= 0) {",
          "1134:   shutdown(ipc_socket, SHUT_RDWR);",
          "1135:   rexit(-1);",
          "1136:  }",
          "1142:  if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {",
          "1143:   int on_exec;",
          "1145:   on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;",
          "1147:    rexit(-1);",
          "1148:   }",
          "1149:  }",
          "1151:  if (init_ctx->container && init_ctx->container->lxc_conf &&",
          "1152:    lxc_seccomp_load(init_ctx->container->lxc_conf) != 0) {",
          "1153:   ERROR(\"Loading seccomp policy\");",
          "1154:   rexit(-1);",
          "1155:  }",
          "1157:  lxc_proc_put_context_info(init_ctx);",
          "",
          "[Removed Lines]",
          "1133:   ERROR(\"error using IPC to receive final notification from initial process (2)\");",
          "1138:  shutdown(ipc_socket, SHUT_RDWR);",
          "1139:  close(ipc_socket);",
          "1146:   if (lsm_set_label_at(procfd, on_exec, init_ctx->lsm_label) < 0) {",
          "",
          "[Added Lines]",
          "1196:   ERROR(\"Error using IPC to receive message from initial process \"",
          "1197:         \"that it is done pre-initializing (2): %s\",",
          "1198:         strerror(errno));",
          "1205:  status = 3;",
          "1206:  ret = lxc_write_nointr(ipc_socket, &status, sizeof(status));",
          "1207:  if (ret <= 0) {",
          "1208:   ERROR(\"Error using IPC to tell parent to set up LSM labels (3): %s.\", strerror(errno));",
          "1209:   shutdown(ipc_socket, SHUT_RDWR);",
          "1210:   rexit(-1);",
          "1211:  }",
          "1216:   ret = lxc_abstract_unix_recv_fd(ipc_socket, &lsm_labelfd, NULL, 0);",
          "1217:   if (ret <= 0) {",
          "1218:    ERROR(\"Error using IPC for parent to tell us LSM label fd (4): %s.\", strerror(errno));",
          "1219:    shutdown(ipc_socket, SHUT_RDWR);",
          "1220:    rexit(-1);",
          "1221:   }",
          "1225:   if (lsm_set_label_at(lsm_labelfd, on_exec, init_ctx->lsm_label) < 0) {",
          "1226:    SYSERROR(\"Failed to set LSM label.\");",
          "1227:    shutdown(ipc_socket, SHUT_RDWR);",
          "1228:    close(lsm_labelfd);",
          "1231:   close(lsm_labelfd);",
          "1237:   shutdown(ipc_socket, SHUT_RDWR);",
          "1241:  shutdown(ipc_socket, SHUT_RDWR);",
          "1242:  close(ipc_socket);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1192:     SYSERROR(\"Unable to clear CLOEXEC from fd\");",
          "1193:  }",
          "1199:  rexit(payload->exec_function(payload->exec_payload));",
          "1200: }",
          "",
          "[Removed Lines]",
          "1196:  close(procfd);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2018-7322",
  "cve_desc": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-dcm.c had an infinite loop that was addressed by checking for integer wraparound.",
  "repo": "wireshark/wireshark",
  "patch_hash": "b6328eba6a3d33930489709ee1e47140dcc30dfb",
  "patch_info": {
    "commit_hash": "b6328eba6a3d33930489709ee1e47140dcc30dfb",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/b6328eba6a3d33930489709ee1e47140dcc30dfb",
    "files": [
      "epan/dissectors/packet-dcm.c"
    ],
    "message": "DICOM: Prevent infinite loop (dissect_dcm_tag)\n\nuint32 value could wrap around, resulting in infinite loop.\n\nBug: 14411\nChange-Id: I26c73f74adc65c7a5acf22970a54c93a7f7a2344\nReviewed-on: https://code.wireshark.org/review/25873\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nTested-by: Petri Dish Buildbot\nReviewed-by: Michael Mann <mmann78@netscape.net>",
    "before_after_code_files": [
      "epan/dissectors/packet-dcm.c||epan/dissectors/packet-dcm.c"
    ]
  },
  "patch_diff": {
    "epan/dissectors/packet-dcm.c||epan/dissectors/packet-dcm.c": [
      "File: epan/dissectors/packet-dcm.c -> epan/dissectors/packet-dcm.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "6284:                                 ett, &tag_pitem, tag_summary);",
      "6286:         }",
      "6289:                 tag_ptree = proto_tree_add_subtree(tree, tvb, offset_tag, offset + vl - offset_tag,",
      "6290:                                 ett, &tag_pitem, tag_summary);",
      "",
      "[Removed Lines]",
      "6287:         else if (offset + vl <= endpos) {",
      "",
      "[Added Lines]",
      "6287:         else if ((offset + vl <= endpos) &&",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "afc780e2c796e971bb7d164103f4f0d10d3c25b5",
      "candidate_info": {
        "commit_hash": "afc780e2c796e971bb7d164103f4f0d10d3c25b5",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/afc780e2c796e971bb7d164103f4f0d10d3c25b5",
        "files": [
          "epan/dissectors/packet-dcm.c"
        ],
        "message": "DICOM: Prevent infinite loop (dissect_dcm_tag)\n\nuint32 value could wrap around, resulting in infinite loop.\n\nBug: 14411\nChange-Id: I26c73f74adc65c7a5acf22970a54c93a7f7a2344\nReviewed-on: https://code.wireshark.org/review/25873\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nTested-by: Petri Dish Buildbot\nReviewed-by: Michael Mann <mmann78@netscape.net>\n(cherry picked from commit b6328eba6a3d33930489709ee1e47140dcc30dfb)\nReviewed-on: https://code.wireshark.org/review/25877",
        "before_after_code_files": [
          "epan/dissectors/packet-dcm.c||epan/dissectors/packet-dcm.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-dcm.c||epan/dissectors/packet-dcm.c"
          ],
          "candidate": [
            "epan/dissectors/packet-dcm.c||epan/dissectors/packet-dcm.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-dcm.c||epan/dissectors/packet-dcm.c": [
          "File: epan/dissectors/packet-dcm.c -> epan/dissectors/packet-dcm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6310:                                 ett, &tag_pitem, tag_summary);",
          "6312:         }",
          "6315:                 tag_ptree = proto_tree_add_subtree(tree, tvb, offset_tag, offset + vl - offset_tag,",
          "6316:                                 ett, &tag_pitem, tag_summary);",
          "",
          "[Removed Lines]",
          "6313:         else if (offset + vl <= endpos) {",
          "",
          "[Added Lines]",
          "6313:         else if ((offset + vl <= endpos) &&",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dae750dd50612b3efe29da497c2936b4478d7359",
      "candidate_info": {
        "commit_hash": "dae750dd50612b3efe29da497c2936b4478d7359",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/dae750dd50612b3efe29da497c2936b4478d7359",
        "files": [
          "epan/dissectors/packet-dcm.c"
        ],
        "message": "DICOM: Prevent infinite loop (dissect_dcm_tag)\n\nuint32 value could wrap around, resulting in infinite loop.\n\nBug: 14411\nChange-Id: I26c73f74adc65c7a5acf22970a54c93a7f7a2344\nReviewed-on: https://code.wireshark.org/review/25873\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nTested-by: Petri Dish Buildbot\nReviewed-by: Michael Mann <mmann78@netscape.net>\n(cherry picked from commit b6328eba6a3d33930489709ee1e47140dcc30dfb)\nReviewed-on: https://code.wireshark.org/review/25876",
        "before_after_code_files": [
          "epan/dissectors/packet-dcm.c||epan/dissectors/packet-dcm.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-dcm.c||epan/dissectors/packet-dcm.c"
          ],
          "candidate": [
            "epan/dissectors/packet-dcm.c||epan/dissectors/packet-dcm.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-dcm.c||epan/dissectors/packet-dcm.c": [
          "File: epan/dissectors/packet-dcm.c -> epan/dissectors/packet-dcm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6186:                                 ett, &tag_pitem, tag_summary);",
          "6188:         }",
          "6191:                 tag_ptree = proto_tree_add_subtree(tree, tvb, offset_tag, offset + vl - offset_tag,",
          "6192:                                 ett, &tag_pitem, tag_summary);",
          "",
          "[Removed Lines]",
          "6189:         else if (offset + vl <= endpos) {",
          "",
          "[Added Lines]",
          "6189:         else if ((offset + vl <= endpos) &&",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "186714314d546c2155cb0942724e8bafb9bd879f",
      "candidate_info": {
        "commit_hash": "186714314d546c2155cb0942724e8bafb9bd879f",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/186714314d546c2155cb0942724e8bafb9bd879f",
        "files": [
          "epan/dissectors/packet-dcm.c"
        ],
        "message": "dcm: Fixed crash in dissector, and other bugs Some tag descriptions which are added to the parent item (32 tags). If one of those was empty a crash occurred. Mainly the RTPlan modality was affected.\n\nFixed length decoding for OD, OL, UC, UR Fixed hf_dcm_assoc_item_type to be interpreted as 1 byte\nFixed pdu_type to be interpreted as 1 byte\nFixed decoding of AT type, where value length was wrongly reported in capture as 2 (instead of n*4)\nRemoved tailing white spaces\nPlease merge to 2.4 once ok.\n\nBug: 14415\nChange-Id: I7857ef107e7e599c7dd9f8d069daa5b3bfb4122f\nReviewed-on: https://code.wireshark.org/review/26268\nPetri-Dish: Anders Broman <a.broman58@gmail.com>\nTested-by: Petri Dish Buildbot\nReviewed-by: Anders Broman <a.broman58@gmail.com>",
        "before_after_code_files": [
          "epan/dissectors/packet-dcm.c||epan/dissectors/packet-dcm.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-dcm.c||epan/dissectors/packet-dcm.c"
          ],
          "candidate": [
            "epan/dissectors/packet-dcm.c||epan/dissectors/packet-dcm.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-dcm.c||epan/dissectors/packet-dcm.c": [
          "File: epan/dissectors/packet-dcm.c -> epan/dissectors/packet-dcm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "242: static int dicom_eo_tap = -1;",
          "245: static int hf_dcm_pdu_len = -1;",
          "247: static int hf_dcm_assoc_version = -1;",
          "248: static int hf_dcm_assoc_called = -1;",
          "249: static int hf_dcm_assoc_calling = -1;",
          "",
          "[Removed Lines]",
          "244: static int hf_dcm_pdu = -1;",
          "",
          "[Added Lines]",
          "266: static int hf_dcm_pdu_type = -1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "380: typedef struct _dicom_eo_t {",
          "387: } dicom_eo_t;",
          "389: static gboolean",
          "",
          "[Removed Lines]",
          "381:  guint32  pkt_num;",
          "382:  gchar   *hostname;",
          "383:  gchar   *filename;",
          "384:  gchar   *content_type;",
          "385:  guint32  payload_len;",
          "386:  guint8 *payload_data;",
          "",
          "[Added Lines]",
          "402:     guint32  pkt_num;",
          "403:     gchar   *hostname;",
          "404:     gchar   *filename;",
          "405:     gchar   *content_type;",
          "406:     guint32  payload_len;",
          "407:     guint8  *payload_data;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3964: static guint32  dissect_dcm_assoc_detail(tvbuff_t *tvb, packet_info *pinfo, proto_item *ti,   dcm_state_assoc_t *assoc, guint32 offset, guint32 len);",
          "3966: static void",
          "3967: dcm_init(void)",
          "3968: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3987: static guint32 dissect_dcm_tag_value(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, dcm_state_pdv_t * pdv, guint32 offset, guint16 grp, guint16 elm, guint32 vl, guint32 vl_max, const gchar * vr, gchar ** tag_value);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4043:     return assoc;",
          "4044: }",
          "4046: static dcm_state_assoc_t *",
          "4047: dcm_state_assoc_get(dcm_state_t *dcm_data, guint32 packet_no, gboolean create)",
          "4048: {",
          "4053:     dcm_state_assoc_t *assoc = dcm_data->first_assoc;",
          "",
          "[Removed Lines]",
          "4050:       Return NULL, if Association was not found, based on packet number",
          "",
          "[Added Lines]",
          "4070: Find or create association object based on packet number. Return NULL, if association was not found.",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4601:     }",
          "4602: }",
          "4604: static guint32",
          "4605: dissect_dcm_assoc_header(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint32 offset, dcm_state_assoc_t *assoc,",
          "4606:                          guint8 pdu_type, guint32 pdu_len)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4628: For tags with fixed length items, calculate the value multiplicity (VM). String tags use a separator, which is not supported by this function.",
          "4629: Support item count from 0 to n. and handles bad encoding (e.g. an 'AT' tag was reported to be 2 bytes instead of 4 bytes)",
          "4631: static guint32",
          "4632: dcm_vm_item_count(guint32 value_length, guint32 item_length)",
          "4633: {",
          "4637:     if (value_length == 0) {",
          "4638:         return 0;",
          "4639:     }",
          "4640:     else if (value_length <= item_length) {",
          "4642:     }",
          "4643:     else {",
          "4644:         return (value_length / item_length);",
          "4645:     }",
          "4647: }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4653:         buf_desc = wmem_strdup_printf(wmem_packet_scope(), \"A-ASSOCIATE request %s --> %s\",",
          "4654:             g_strstrip(assoc->ae_calling), g_strstrip(assoc->ae_called));",
          "4659:         break;",
          "",
          "[Removed Lines]",
          "4656:         offset = dissect_dcm_assoc_detail(tvb, pinfo, assoc_header_ptree, assoc,",
          "4657:             offset, pdu_len-offset);",
          "",
          "[Added Lines]",
          "4701:         offset = dissect_dcm_assoc_detail(tvb, pinfo, assoc_header_ptree, assoc, offset, pdu_len-offset);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4680:         buf_desc = wmem_strdup_printf(wmem_packet_scope(), \"A-ASSOCIATE accept  %s <-- %s\",",
          "4681:             g_strstrip(assoc->ae_calling_resp), g_strstrip(assoc->ae_called_resp));",
          "4686:         break;",
          "",
          "[Removed Lines]",
          "4683:         offset = dissect_dcm_assoc_detail(tvb, pinfo, assoc_header_ptree, assoc,",
          "4684:             offset, pdu_len-offset);",
          "",
          "[Added Lines]",
          "4727:         offset = dissect_dcm_assoc_detail(tvb, pinfo, assoc_header_ptree, assoc, offset, pdu_len-offset);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4816:     return offset;",
          "4817: }",
          "4819: static void",
          "4820: dissect_dcm_assoc_item(tvbuff_t *tvb, proto_tree *tree, guint32 offset,",
          "4821:                        const gchar *pitem_prefix, int item_value_type,",
          "4822:                        gchar **item_value, const gchar **item_description,",
          "4823:                        int *hf_type, int *hf_len, int *hf_value, int ett_subtree)",
          "4824: {",
          "4836:     proto_item *assoc_item_pitem;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4863: Decode one item in a association request or response. Lookup UIDs if requested.",
          "4864: Create a subtree node with summary and three elements (item_type, item_len, value)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "4839:     guint32 item_number = 0;",
          "",
          "[Removed Lines]",
          "4841:     guint8  item_type = 0;",
          "4842:     guint16 item_len  = 0;",
          "",
          "[Added Lines]",
          "4879:     guint8  item_type;",
          "4880:     guint16 item_len;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "4852:     assoc_item_ptree = proto_tree_add_subtree(tree, tvb, offset, item_len+4, ett_subtree, &assoc_item_pitem, pitem_prefix);",
          "4857:     switch (item_value_type) {",
          "4858:     case DCM_ITEM_VALUE_TYPE_UID:",
          "",
          "[Removed Lines]",
          "4854:     proto_tree_add_uint(assoc_item_ptree, *hf_type, tvb, offset, 1, item_type);",
          "4855:     proto_tree_add_uint(assoc_item_ptree, *hf_len, tvb, offset+2, 2, item_len);",
          "",
          "[Added Lines]",
          "4892:     proto_tree_add_uint(assoc_item_ptree, *hf_type, tvb, offset,   1, item_type);",
          "4893:     proto_tree_add_uint(assoc_item_ptree, *hf_len,  tvb, offset+2, 2, item_len);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "5062:     assoc_item_unknown_item = proto_tree_add_item(tree, hf_dcm_info_unknown, tvb, offset, item_len+4, ENC_NA);",
          "5063:     assoc_item_unknown_tree = proto_item_add_subtree(assoc_item_unknown_item, ett_assoc_info_unknown);",
          "5070: }",
          "",
          "[Removed Lines]",
          "5065:     proto_tree_add_item(assoc_item_unknown_tree, hf_dcm_assoc_item_type, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "5066:     proto_tree_add_item(assoc_item_unknown_tree, hf_dcm_assoc_item_len, tvb, offset+2, 2, ENC_BIG_ENDIAN);",
          "5068:     proto_tree_add_item(assoc_item_unknown_tree, hf_dcm_assoc_item_data, tvb, offset+2+2, item_len, ENC_NA);",
          "",
          "[Added Lines]",
          "5103:     proto_tree_add_item(assoc_item_unknown_tree, hf_dcm_assoc_item_type, tvb, offset,   1, ENC_BIG_ENDIAN);",
          "5104:     proto_tree_add_item(assoc_item_unknown_tree, hf_dcm_assoc_item_len,  tvb, offset+2, 2, ENC_BIG_ENDIAN);",
          "5105:     offset += 4;",
          "5107:     proto_tree_add_item(assoc_item_unknown_tree, hf_dcm_assoc_item_data, tvb, offset, item_len, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "5163:     if (max_num_ops_per==0) proto_item_append_text(assoc_item_asyncneg_item, \"%s\", \" (unlimited)\");",
          "5164: }",
          "5166: static void",
          "5167: dissect_dcm_pctx(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,",
          "5168:                  dcm_state_assoc_t *assoc, guint32 offset, guint32 len,",
          "5169:                  const gchar *pitem_prefix, gboolean is_assoc_request)",
          "5170: {",
          "5177:     proto_item *pctx_pitem;",
          "5179:     dcm_state_pctx_t *pctx = NULL;",
          "",
          "[Removed Lines]",
          "5172:         Decode a presentation context item in a Association Request or Response",
          "5173:         In the response, set the accepted transfer syntax, if any",
          "",
          "[Added Lines]",
          "5206: Decode a presentation context item in a Association Request or Response. In the response, set the accepted transfer syntax, if any.",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "5214:         return;",
          "5215:     }",
          "5218:     proto_tree_add_uint(pctx_ptree, hf_dcm_assoc_item_len,  tvb, offset-2, 2, item_len);",
          "5220:     proto_tree_add_uint_format(pctx_ptree, hf_dcm_pctx_id, tvb, offset, 1, pctx_id, \"Context ID: 0x%02x\", pctx_id);",
          "",
          "[Removed Lines]",
          "5217:     proto_tree_add_uint(pctx_ptree, hf_dcm_assoc_item_type, tvb, offset-4, 2, item_type);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "5349: }",
          "5351: static void",
          "5352: dissect_dcm_userinfo(tvbuff_t *tvb, proto_tree *tree, guint32 offset, guint32 len, const gchar *pitem_prefix)",
          "5353: {",
          "5358:     proto_item *userinfo_pitem = NULL;",
          "",
          "[Removed Lines]",
          "5355:         Decode the user info item in a Association Request or Response",
          "",
          "[Added Lines]",
          "5390: Decode the user info item in a Association Request or Response",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "5379:     proto_item_set_text(userinfo_pitem, \"%s\", pitem_prefix);",
          "5380:     userinfo_ptree = proto_item_add_subtree(userinfo_pitem, ett_assoc_info);",
          "5385:     while (offset < endpos) {",
          "",
          "[Removed Lines]",
          "5382:     proto_tree_add_uint(userinfo_ptree, hf_dcm_assoc_item_type, tvb, offset-4, 2, item_type);",
          "5383:     proto_tree_add_uint(userinfo_ptree, hf_dcm_assoc_item_len, tvb, offset-2, 2, item_len);",
          "",
          "[Added Lines]",
          "5422:     proto_tree_add_uint(userinfo_ptree, hf_dcm_assoc_item_len,  tvb, offset-2, 2, item_len);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "5474: }",
          "5477: static guint32",
          "5478: dissect_dcm_assoc_detail(tvbuff_t *tvb, packet_info *pinfo, proto_item *ti,",
          "5479:                          dcm_state_assoc_t *assoc, guint32 offset, guint32 len)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5517: Create a subtree for association requests or responses",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "5513:             break;",
          "5518:             offset += item_len;",
          "5519:             break;",
          "5524:             offset += item_len;",
          "5525:             break;",
          "",
          "[Removed Lines]",
          "5516:             dissect_dcm_pctx(tvb, pinfo, assoc_tree, assoc, offset, item_len,",
          "5517:                 \"Presentation Context: \", TRUE);",
          "5522:             dissect_dcm_pctx(tvb, pinfo, assoc_tree, assoc, offset, item_len,",
          "5523:                 \"Presentation Context: \", FALSE);",
          "",
          "[Added Lines]",
          "5558:             dissect_dcm_pctx(tvb, pinfo, assoc_tree, assoc, offset, item_len, \"Presentation Context: \", TRUE);",
          "5563:             dissect_dcm_pctx(tvb, pinfo, assoc_tree, assoc, offset, item_len, \"Presentation Context: \", FALSE);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "5728:         (strncmp(vr, \"IS\", 2) == 0) || (strncmp(vr, \"LO\", 2) == 0) || (strncmp(vr, \"LT\", 2) == 0) ||",
          "5729:         (strncmp(vr, \"PN\", 2) == 0) || (strncmp(vr, \"SH\", 2) == 0) || (strncmp(vr, \"ST\", 2) == 0) ||",
          "5730:         (strncmp(vr, \"TM\", 2) == 0) || (strncmp(vr, \"UI\", 2) == 0) || (strncmp(vr, \"UT\", 2) == 0) ) {",
          "5733:         gchar   *vals;",
          "5734:         dcm_uid_t *uid = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5772:             15 ways to represent a string.",
          "5774:             For LT, ST, UT the DICOM standard does not allow multi-value",
          "5775:             For the others, VM is built into 'automatically, because it uses '\\' as separator",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "5769:             pdv->comment = wmem_strdup(wmem_file_scope(), g_strstrip(vals));",
          "5770:         }",
          "5771:     }",
          "5780:     }",
          "5781:     else if (strncmp(vr, \"UN\", 2) == 0) {",
          "5783:         guint8    val8;",
          "5784:         gchar    *vals;",
          "5785:         guint32  i;",
          "",
          "[Removed Lines]",
          "5772:     else if ((strncmp(vr, \"OB\", 2) == 0) || (strncmp(vr, \"OF\", 2) == 0) ||",
          "5773:              (strncmp(vr, \"OW\", 2) == 0)) {",
          "5776:         proto_tree_add_bytes_format_value(tree, hf_dcm_tag_value_byte, tvb, offset, vl_max,",
          "5777:             NULL, \"%s\", \"(binary)\");",
          "",
          "[Added Lines]",
          "5817:     else if ((strncmp(vr, \"OB\", 2) == 0) || (strncmp(vr, \"OW\", 2) == 0) ||",
          "5818:              (strncmp(vr, \"OF\", 2) == 0) || (strncmp(vr, \"OD\", 2) == 0)) {",
          "5822:         proto_tree_add_bytes_format_value(tree, hf_dcm_tag_value_byte, tvb, offset, vl_max, NULL, \"%s\", \"(binary)\");",
          "5829:             Not been able to create UN yet. No need to support VM > 1.",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "5815:         }",
          "5816:         else {",
          "5821:         }",
          "",
          "[Removed Lines]",
          "5817:             proto_tree_add_bytes_format_value(tree, hf_dcm_tag_value_byte, tvb, offset, vl_max,",
          "5818:                 NULL, \"%s\", \"(binary)\");",
          "",
          "[Added Lines]",
          "5866:             proto_tree_add_bytes_format_value(tree, hf_dcm_tag_value_byte, tvb, offset, vl_max, NULL, \"%s\", \"(binary)\");",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "5824:        Smaller types. vl/vl_max are not used. Fixed item length from 2 to 8 bytes",
          "5825:        ---------------------------------------------------------------------------",
          "5830:         guint16 at_grp;",
          "5831:         guint16 at_elm;",
          "5833:         gchar *at_value = \"\";",
          "5840:                 (at_grp << 16) | at_elm, \"%04x,%04x\", at_grp, at_elm);",
          "5842:             at_value = wmem_strdup_printf(wmem_packet_scope(),\"%s(%04x,%04x)\", at_value, at_grp, at_elm);",
          "5845:         }",
          "5847:     }",
          "5850:         gfloat valf = tvb_get_ieee_float(tvb, offset, encoding);",
          "5856:     }",
          "5859:         gdouble vald = tvb_get_ieee_double(tvb, offset, encoding);",
          "5865:     }",
          "5867:         gint32  val32;",
          "5869:         proto_tree_add_item_ret_int(tree, hf_dcm_tag_value_32s, tvb, offset, 4, encoding, &val32);",
          "5872:     }",
          "5874:         gint32  val32;",
          "5876:         proto_tree_add_item_ret_int(tree, hf_dcm_tag_value_16s, tvb, offset, 2, encoding, &val32);",
          "5879:     }",
          "5881:         guint32  val32;",
          "5883:         proto_tree_add_item_ret_uint(tree, hf_dcm_tag_value_32u, tvb, offset, 4, encoding, &val32);",
          "5886:     }",
          "5888:         const gchar *status_message = NULL;",
          "5889:         guint16     val16 = tvb_get_guint16(tvb, offset, encoding);",
          "",
          "[Removed Lines]",
          "5832:         guint32 at_offset = 0;",
          "5835:         while(at_offset < vl_max-3) {",
          "5836:             at_grp = tvb_get_guint16(tvb, offset+at_offset, encoding);",
          "5837:             at_elm = tvb_get_guint16(tvb, offset+at_offset+2, encoding);",
          "5839:             proto_tree_add_uint_format_value(tree, hf_dcm_tag_value_32u, tvb, offset+at_offset, 4,",
          "5844:             at_offset += 4;",
          "5852:         proto_tree_add_bytes_format_value(tree, hf_dcm_tag_value_byte, tvb, offset, 4,",
          "5853:             NULL, \"%f\", valf);",
          "5861:         proto_tree_add_bytes_format_value(tree, hf_dcm_tag_value_byte, tvb, offset, 8,",
          "5862:             NULL, \"%f\", vald);",
          "",
          "[Added Lines]",
          "5875:     else if (strncmp(vr, \"AT\", 2) == 0)  {",
          "5884:            So make it at least one loop so set it to at least 4.",
          "5887:         guint32 vm_item_len = 4;",
          "5888:         guint32 vm_item_count = dcm_vm_item_count(vl_max, vm_item_len);",
          "5890:         guint32 i = 0;",
          "5891:         while (i < vm_item_count) {",
          "5892:             at_grp = tvb_get_guint16(tvb, offset+ i*vm_item_len,   encoding);",
          "5893:             at_elm = tvb_get_guint16(tvb, offset+ i*vm_item_len+2, encoding);",
          "5895:             proto_tree_add_uint_format_value(tree, hf_dcm_tag_value_32u, tvb, offset + i*vm_item_len, vm_item_len,",
          "5900:             i++;",
          "5908:         proto_tree_add_bytes_format_value(tree, hf_dcm_tag_value_byte, tvb, offset, 4, NULL, \"%f\", valf);",
          "5916:         proto_tree_add_bytes_format_value(tree, hf_dcm_tag_value_byte, tvb, offset, 8, NULL, \"%f\", vald);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "6058:     return tag_sum;",
          "6059: }",
          "6061: static guint32",
          "6062: dissect_dcm_tag(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,",
          "6063:                 dcm_state_pdv_t *pdv, guint32 offset, guint32 endpos,",
          "6064:                 gboolean is_first_tag, const gchar **tag_description,",
          "6065:                 gboolean *end_of_seq_or_item)",
          "6066: {",
          "",
          "[Removed Lines]",
          "6068:        Returns new offset.",
          "",
          "[Added Lines]",
          "6116: Decode one tag. If it is a sequence or item start create a subtree. Returns new offset.",
          "6117: http://dicom.nema.org/medical/dicom/current/output/chtml/part05/chapter_7.html",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "6193:             offset += 2;",
          "6195:             g_free(pdv->open_tag.vr);",
          "6197:         }",
          "6203:             is_vl_long = TRUE;",
          "",
          "[Removed Lines]",
          "6200:         if ((strcmp(vr, \"OB\") == 0) || (strcmp(vr, \"OW\") == 0) || (strcmp(vr, \"OF\") == 0) ||",
          "6201:             (strcmp(vr, \"SQ\") == 0) || (strcmp(vr, \"UT\") == 0) || (strcmp(vr, \"UN\") == 0)) {",
          "",
          "[Added Lines]",
          "6255:         if ((strcmp(vr, \"OB\") == 0) || (strcmp(vr, \"OW\") == 0) || (strcmp(vr, \"OF\") == 0) || (strcmp(vr, \"OD\") == 0) || (strcmp(vr, \"OL\") == 0) ||",
          "6256:             (strcmp(vr, \"SQ\") == 0) || (strcmp(vr, \"UC\") == 0) || (strcmp(vr, \"UR\") == 0) || (strcmp(vr, \"UT\") == 0) || (strcmp(vr, \"UN\") == 0)) {",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "6275:     if ((is_sequence | is_item) &&  global_dcm_seq_subtree) {",
          "6276:         ett = is_sequence ? ett_dcm_data_seq : ett_dcm_data_item;",
          "6278:         ett = ett_dcm_data_tag;",
          "6279:     }",
          "6318:         }",
          "6319:         else {",
          "6324:         }",
          "6327:         Tag details as separate items",
          "6328:         ---------------------------------------------------------------",
          "6331:     proto_tree_add_uint_format_value(tag_ptree, hf_dcm_tag, tvb, offset_tag, 4,",
          "6332:         (grp << 16) | elm, \"%04x,%04x (%s)\", grp, elm, tag_def->description);",
          "6335:     if (!is_item)  {",
          "6336:         if (is_implicit) {",
          "",
          "[Removed Lines]",
          "6277:     } else {",
          "6281:         if (vl == 0xFFFFFFFF) {",
          "6283:                 tag_ptree = proto_tree_add_subtree(tree, tvb, offset_tag, offset - offset_tag,",
          "6284:                                 ett, &tag_pitem, tag_summary);",
          "6286:         }",
          "6287:         else if ((offset + vl <= endpos) &&",
          "6290:                 tag_ptree = proto_tree_add_subtree(tree, tvb, offset_tag, offset + vl - offset_tag,",
          "6291:                                 ett, &tag_pitem, tag_summary);",
          "6292:                 vl_max = vl;",
          "6293:         }",
          "6294:         else {",
          "6296:                 tag_ptree = proto_tree_add_subtree(tree, tvb, offset_tag, endpos - offset_tag,",
          "6297:                                 ett, &tag_pitem, tag_summary);",
          "6298:                 vl_max = endpos - offset;",
          "6299:         }",
          "6302:        through both display options and check for proper tree display :-)",
          "6304:         if (is_sequence | is_item) {",
          "6306:                 if (global_dcm_seq_subtree) {",
          "6308:                         seq_ptree = tag_ptree;",
          "6309:                         if (!global_dcm_tag_subtree)",
          "6310:                                 tag_ptree = NULL;",
          "6311:                 }",
          "6312:                 else {",
          "6313:                         seq_ptree = tree;",
          "6314:                         if (!global_dcm_tag_subtree) {",
          "6315:                                 tag_ptree = NULL;",
          "6316:                         }",
          "6317:                 }",
          "6321:                 if (!global_dcm_tag_subtree) {",
          "6322:                         tag_ptree = NULL;",
          "6323:                 }",
          "",
          "[Added Lines]",
          "6334:     }",
          "6335:     else {",
          "6339:     if (vl == 0xFFFFFFFF) {",
          "6341:         tag_ptree = proto_tree_add_subtree(tree, tvb, offset_tag, offset - offset_tag, ett, &tag_pitem, tag_summary);",
          "6343:     }",
          "6344:     else if (offset + vl <= endpos) {",
          "6346:         tag_ptree = proto_tree_add_subtree(tree, tvb, offset_tag, offset + vl - offset_tag, ett, &tag_pitem, tag_summary);",
          "6347:         vl_max = vl;",
          "6348:     }",
          "6349:     else {",
          "6351:         tag_ptree = proto_tree_add_subtree(tree, tvb, offset_tag, endpos - offset_tag, ett, &tag_pitem, tag_summary);",
          "6352:         vl_max = endpos - offset;",
          "6353:     }",
          "6356:         through both display options and check for proper tree display :-)",
          "6358:     if (is_sequence | is_item) {",
          "6360:         if (global_dcm_seq_subtree) {",
          "6362:             seq_ptree = tag_ptree;",
          "6363:             if (!global_dcm_tag_subtree) {",
          "6364:                 tag_ptree = NULL;",
          "6365:             }",
          "6368:             seq_ptree = tree;",
          "6369:             if (!global_dcm_tag_subtree) {",
          "6370:                 tag_ptree = NULL;",
          "6371:             }",
          "6372:         }",
          "6373:     }",
          "6374:     else {",
          "6376:         if (!global_dcm_tag_subtree) {",
          "6377:             tag_ptree = NULL;",
          "6379:     }",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "6365:             while ((!local_end_of_seq_or_item) && (!pdv->open_tag.is_header_fragmented) && (offset < endpos)) {",
          "6370:                 if (item_description && global_dcm_seq_subtree) {",
          "6371:                     proto_item_append_text(tag_pitem, (is_first_desc ? \" %s\" : \", %s\"), item_description);",
          "",
          "[Removed Lines]",
          "6367:                 offset = dissect_dcm_tag(tvb, pinfo, seq_ptree, pdv, offset, endpos, FALSE,",
          "6368:                     &item_description, &local_end_of_seq_or_item);",
          "",
          "[Added Lines]",
          "6422:                 offset = dissect_dcm_tag(tvb, pinfo, seq_ptree, pdv, offset, endpos, FALSE, &item_description, &local_end_of_seq_or_item);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "6380:             while (offset < endpos_item) {",
          "6385:                 if (item_description && global_dcm_seq_subtree) {",
          "6386:                     proto_item_append_text(tag_pitem, (is_first_desc ? \" %s\" : \", %s\"), item_description);",
          "",
          "[Removed Lines]",
          "6382:                 offset = dissect_dcm_tag(tvb, pinfo, seq_ptree, pdv, offset, endpos_item, FALSE,",
          "6383:                     &item_description, &local_end_of_seq_or_item);",
          "",
          "[Added Lines]",
          "6436:                 offset = dissect_dcm_tag(tvb, pinfo, seq_ptree, pdv, offset, endpos_item, FALSE, &item_description, &local_end_of_seq_or_item);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "6399:     }",
          "6400:     else if (vl == 0) {",
          "6403:     }",
          "6404:     else if (vl > vl_max) {",
          "",
          "[Removed Lines]",
          "6402:         tag_value = \"<Empty>\";",
          "",
          "[Added Lines]",
          "6457:             and that one will crash the whole application, when a constant is used.",
          "6460:         tag_value = wmem_strdup(wmem_packet_scope(), \"<Empty>\");",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "6625: }",
          "6628: static guint32",
          "6629: dissect_dcm_pdv_fragmented(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,",
          "6630:                 dcm_state_assoc_t *assoc, guint32 offset, guint32 pdv_len, gchar **pdv_description)",
          "6631: {",
          "6638:     dcm_state_pdv_t *pdv = NULL;",
          "",
          "[Removed Lines]",
          "6633:        Create PDV object when needed",
          "6636:     conversation_t  *conv=NULL;",
          "",
          "[Added Lines]",
          "6686: Handle one PDV inside a data PDU. Perform the necessary reassembly of PDV fragments. Create PDV object when needed.",
          "6687: Return pdv_description to be used e.g. in COL_INFO.",
          "6694:     conversation_t  *conv = NULL;",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "6825:     return offset;",
          "6826: }",
          "6828: static int",
          "6829: dissect_dcm_main(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean is_port_static)",
          "6830: {",
          "6833:     guint8  pdu_type = 0;",
          "6834:     guint32 pdu_start = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6887: Main function to decode DICOM traffic. Supports reassembly of TCP packets.",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "6839:     int offset = 0;",
          "6851:         The heuristic hook requires an association request",
          "6853:         DICOM PDU are nice, but need to be managed",
          "",
          "[Removed Lines]",
          "6842:         Modified original code, which was optimized for a heuristic detection, and therefore",
          "6843:         caused some load and memory consumption, for every non DICOM packet not processed",
          "6844:         by someone else.",
          "6846:         Since tcp packets are now assembled well by wireshark (in conjunction with the dissectors)",
          "6847:         we will only see properly aligned PDUs, at the beginning of the buffer, else it's not DICOM",
          "6848:         traffic.",
          "6850:         Therefore do the byte checking as early as possible",
          "",
          "[Added Lines]",
          "6902:         TCP packets are assembled well by wireshark in conjunction with the dissectors.",
          "6904:         Therefore, we will only see properly aligned PDUs, at the beginning of the buffer.",
          "6905:         So if the buffer does not start with the PDU header, it's not DICOM traffic.",
          "6907:         Do the byte checking as early as possible.",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "6910:         pdu_len = tvb_get_ntohl(tvb, 2);",
          "6911:         vers = tvb_get_ntohs(tvb, 6);",
          "6914:         if (!(pdu_type == 1 && vers == 1)) {",
          "6915:             return 0;",
          "6916:         }",
          "6921:         if (pdu_len+6 < tlen) {",
          "6922:             return 0;",
          "",
          "[Removed Lines]",
          "6919:            OK. for PRESENTATION_DATA, questionable for ASSOCIATION requests",
          "",
          "[Added Lines]",
          "6976:            OK for PRESENTATION_DATA, questionable for ASSOCIATION requests",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "6987:     return dissect_dcm_main(tvb, pinfo, tree, FALSE);",
          "6988: }",
          "6990: static guint32",
          "6991: dissect_dcm_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint32 offset)",
          "6992: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7048: Dissect a single DICOM PDU. Can be an association or a data package",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "7011:     dcm_pitem = proto_tree_add_item(tree, proto_dcm, tvb, offset, -1, ENC_NA);",
          "7012:     dcm_ptree = proto_item_add_subtree(dcm_pitem, ett_dcm);",
          "7014:     pdu_type = tvb_get_guint8(tvb, offset);",
          "7016:     offset += 2;",
          "7018:     pdu_len = tvb_get_ntohl(tvb, offset);",
          "",
          "[Removed Lines]",
          "7015:     proto_tree_add_item(dcm_ptree, hf_dcm_pdu, tvb, offset, 2, ENC_BIG_ENDIAN);",
          "",
          "[Added Lines]",
          "7076:     proto_tree_add_item(dcm_ptree, hf_dcm_pdu_type, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "7051: proto_register_dcm(void)",
          "7052: {",
          "7053:     static hf_register_info hf[] = {",
          "7055:         FT_UINT8, BASE_HEX, VALS(dcm_pdu_ids), 0, NULL, HFILL } },",
          "7056:     { &hf_dcm_pdu_len, { \"PDU Length\", \"dicom.pdu.len\",",
          "7057:         FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } },",
          "7063:     { &hf_dcm_assoc_version, { \"Protocol Version\", \"dicom.assoc.version\",",
          "7064:         FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL } },",
          "",
          "[Removed Lines]",
          "7054:     { &hf_dcm_pdu, { \"PDU Type\", \"dicom.pdu.type\",",
          "7058: #if 0",
          "7059:     { &hf_dcm_pdu_type, { \"PDU Detail\", \"dicom.pdu.detail\",",
          "7060:         FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } },",
          "7061: #endif",
          "",
          "[Added Lines]",
          "7115:     { &hf_dcm_pdu_type, { \"PDU Type\", \"dicom.pdu.type\",",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "7328: {",
          "7330:         Statically defined ports take precedence over a heuristic one,",
          "7332:         We would never be called, by just having the heuristic registration",
          "7334:     dissector_add_uint_range_with_preference(\"tcp.port\", DICOM_DEFAULT_RANGE, dcm_handle);",
          "",
          "[Removed Lines]",
          "7331:         I.e., if an foreign protocol claims a port, where dicom is running on",
          "",
          "[Added Lines]",
          "7388:         I.e., if a foreign protocol claims a port, where DICOM is running on",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-2857",
  "cve_desc": "The net_checksum_calculate function in net/checksum.c in QEMU allows local guest OS users to cause a denial of service (out-of-bounds heap read and crash) via the payload length in a crafted packet.",
  "repo": "qemu/qemu",
  "patch_hash": "362786f14a753d8a5256ef97d7c10ed576d6572b",
  "patch_info": {
    "commit_hash": "362786f14a753d8a5256ef97d7c10ed576d6572b",
    "repo": "qemu/qemu",
    "commit_url": "https://github.com/qemu/qemu/commit/362786f14a753d8a5256ef97d7c10ed576d6572b",
    "files": [
      "net/checksum.c"
    ],
    "message": "net: check packet payload length\n\nWhile computing IP checksum, 'net_checksum_calculate' reads\npayload length from the packet. It could exceed the given 'data'\nbuffer size. Add a check to avoid it.\n\nReported-by: Liu Ling <liuling-it@360.cn>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nSigned-off-by: Jason Wang <jasowang@redhat.com>",
    "before_after_code_files": [
      "net/checksum.c||net/checksum.c"
    ]
  },
  "patch_diff": {
    "net/checksum.c||net/checksum.c": [
      "File: net/checksum.c -> net/checksum.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "60:     int hlen, plen, proto, csum_offset;",
      "61:     uint16_t csum;",
      "63:     if ((data[14] & 0xf0) != 0x40)",
      "65:     hlen  = (data[14] & 0x0f) * 4;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "64:     if (length < 14 + 20) {",
      "65:         return;",
      "66:     }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "77:  return;",
      "78:     }",
      "83:     data[14+hlen+csum_offset]   = 0;",
      "84:     data[14+hlen+csum_offset+1] = 0;",
      "",
      "[Removed Lines]",
      "80:     if (plen < csum_offset+2)",
      "81:  return;",
      "",
      "[Added Lines]",
      "85:     if (plen < csum_offset + 2 || 14 + hlen + plen > length) {",
      "86:         return;",
      "87:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d0ee85b4e4c6cc2c8fac311d6df2ed412ed0df5f",
      "candidate_info": {
        "commit_hash": "d0ee85b4e4c6cc2c8fac311d6df2ed412ed0df5f",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/d0ee85b4e4c6cc2c8fac311d6df2ed412ed0df5f",
        "files": [
          "net/checksum.c"
        ],
        "message": "net: check packet payload length\n\nWhile computing IP checksum, 'net_checksum_calculate' reads\npayload length from the packet. It could exceed the given 'data'\nbuffer size. Add a check to avoid it.\n\nReported-by: Liu Ling <liuling-it@360.cn>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nSigned-off-by: Jason Wang <jasowang@redhat.com>\n(cherry picked from commit 362786f14a753d8a5256ef97d7c10ed576d6572b)\nSigned-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>",
        "before_after_code_files": [
          "net/checksum.c||net/checksum.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "net/checksum.c||net/checksum.c"
          ],
          "candidate": [
            "net/checksum.c||net/checksum.c"
          ]
        }
      },
      "candidate_diff": {
        "net/checksum.c||net/checksum.c": [
          "File: net/checksum.c -> net/checksum.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "59:     int hlen, plen, proto, csum_offset;",
          "60:     uint16_t csum;",
          "62:     if ((data[14] & 0xf0) != 0x40)",
          "64:     hlen  = (data[14] & 0x0f) * 4;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "63:     if (length < 14 + 20) {",
          "64:         return;",
          "65:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "76:  return;",
          "77:     }",
          "82:     data[14+hlen+csum_offset]   = 0;",
          "83:     data[14+hlen+csum_offset+1] = 0;",
          "",
          "[Removed Lines]",
          "79:     if (plen < csum_offset+2)",
          "80:  return;",
          "",
          "[Added Lines]",
          "84:     if (plen < csum_offset + 2 || 14 + hlen + plen > length) {",
          "85:         return;",
          "86:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "50dbce6538d10c8ec9c346fdc0ff76906ae48ebe",
      "candidate_info": {
        "commit_hash": "50dbce6538d10c8ec9c346fdc0ff76906ae48ebe",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/50dbce6538d10c8ec9c346fdc0ff76906ae48ebe",
        "files": [
          "net/checksum.c"
        ],
        "message": "net: improve UDP/TCP checksum computation.\n\n * based on Eth, UDP, TCP struct present in eth.h instead of hardcoded\n   indexes and sizes.\n * based on various macros present in eth.h.\n\nSigned-off-by: Jean-Christophe Dubois <jcd@tribudubois.net>\nSigned-off-by: Jason Wang <jasowang@redhat.com>",
        "before_after_code_files": [
          "net/checksum.c||net/checksum.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/checksum.c||net/checksum.c"
          ],
          "candidate": [
            "net/checksum.c||net/checksum.c"
          ]
        }
      },
      "candidate_diff": {
        "net/checksum.c||net/checksum.c": [
          "File: net/checksum.c -> net/checksum.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #include \"qemu/osdep.h\"",
          "19: #include \"qemu-common.h\"",
          "20: #include \"net/checksum.h\"",
          "25: uint32_t net_checksum_add_cont(int len, uint8_t *buf, int seq)",
          "26: {",
          "",
          "[Removed Lines]",
          "22: #define PROTO_TCP  6",
          "23: #define PROTO_UDP 17",
          "",
          "[Added Lines]",
          "21: #include \"net/eth.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "58: void net_checksum_calculate(uint8_t *data, int length)",
          "59: {",
          "65:         return;",
          "66:     }",
          "83:     }",
          "86:         return;",
          "87:     }",
          "94: }",
          "96: uint32_t",
          "",
          "[Removed Lines]",
          "60:     int hlen, plen, proto, csum_offset;",
          "61:     uint16_t csum;",
          "64:     if (length < 14 + 20) {",
          "68:     if ((data[14] & 0xf0) != 0x40)",
          "70:     hlen  = (data[14] & 0x0f) * 4;",
          "71:     plen  = (data[16] << 8 | data[17]) - hlen;",
          "72:     proto = data[23];",
          "74:     switch (proto) {",
          "75:     case PROTO_TCP:",
          "76:  csum_offset = 16;",
          "77:  break;",
          "78:     case PROTO_UDP:",
          "79:  csum_offset = 6;",
          "80:  break;",
          "81:     default:",
          "82:  return;",
          "85:     if (plen < csum_offset + 2 || 14 + hlen + plen > length) {",
          "89:     data[14+hlen+csum_offset]   = 0;",
          "90:     data[14+hlen+csum_offset+1] = 0;",
          "91:     csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);",
          "92:     data[14+hlen+csum_offset]   = csum >> 8;",
          "93:     data[14+hlen+csum_offset+1] = csum & 0xff;",
          "",
          "[Added Lines]",
          "58:     int ip_len;",
          "59:     struct ip_header *ip;",
          "68:     if (length < (sizeof(struct eth_header) + sizeof(struct ip_header))) {",
          "72:     ip = (struct ip_header *)(data + sizeof(struct eth_header));",
          "74:     if (IP_HEADER_VERSION(ip) != IP_HEADER_VERSION_4) {",
          "78:     ip_len = lduw_be_p(&ip->ip_len);",
          "81:     if (length < ip_len) {",
          "85:     ip_len -= IP_HDR_GET_LEN(ip);",
          "87:     switch (ip->ip_p) {",
          "88:     case IP_PROTO_TCP:",
          "89:     {",
          "90:         uint16_t csum;",
          "91:         tcp_header *tcp = (tcp_header *)(ip + 1);",
          "93:         if (ip_len < sizeof(tcp_header)) {",
          "94:             return;",
          "95:         }",
          "98:         stw_he_p(&tcp->th_sum, 0);",
          "100:         csum = net_checksum_tcpudp(ip_len, ip->ip_p,",
          "101:                                    (uint8_t *)&ip->ip_src,",
          "102:                                    (uint8_t *)tcp);",
          "105:         stw_be_p(&tcp->th_sum, csum);",
          "107:         break;",
          "108:     }",
          "109:     case IP_PROTO_UDP:",
          "110:     {",
          "111:         uint16_t csum;",
          "112:         udp_header *udp = (udp_header *)(ip + 1);",
          "114:         if (ip_len < sizeof(udp_header)) {",
          "115:             return;",
          "116:         }",
          "119:         stw_he_p(&udp->uh_sum, 0);",
          "121:         csum = net_checksum_tcpudp(ip_len, ip->ip_p,",
          "122:                                    (uint8_t *)&ip->ip_src,",
          "123:                                    (uint8_t *)udp);",
          "126:         stw_be_p(&udp->uh_sum, csum);",
          "128:         break;",
          "129:     }",
          "130:     default:",
          "132:         break;",
          "133:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ade6bad111f74e0e0a8f48de8c8955e7b70be7e3",
      "candidate_info": {
        "commit_hash": "ade6bad111f74e0e0a8f48de8c8955e7b70be7e3",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/ade6bad111f74e0e0a8f48de8c8955e7b70be7e3",
        "files": [
          "net/checksum.c"
        ],
        "message": "net: handle optional VLAN header in checksum computation.\n\nSigned-off-by: Jean-Christophe Dubois <jcd@tribudubois.net>\nSigned-off-by: Jason Wang <jasowang@redhat.com>",
        "before_after_code_files": [
          "net/checksum.c||net/checksum.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/checksum.c||net/checksum.c"
          ],
          "candidate": [
            "net/checksum.c||net/checksum.c"
          ]
        }
      },
      "candidate_diff": {
        "net/checksum.c||net/checksum.c": [
          "File: net/checksum.c -> net/checksum.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "56: void net_checksum_calculate(uint8_t *data, int length)",
          "57: {",
          "59:     struct ip_header *ip;",
          "",
          "[Removed Lines]",
          "58:     int ip_len;",
          "",
          "[Added Lines]",
          "58:     int mac_hdr_len, ip_len;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "69:         return;",
          "70:     }",
          "74:     if (IP_HEADER_VERSION(ip) != IP_HEADER_VERSION_4) {",
          "",
          "[Removed Lines]",
          "68:     if (length < (sizeof(struct eth_header) + sizeof(struct ip_header))) {",
          "72:     ip = (struct ip_header *)(data + sizeof(struct eth_header));",
          "",
          "[Added Lines]",
          "68:     if (length < sizeof(struct eth_header)) {",
          "73:     switch (lduw_be_p(&PKT_GET_ETH_HDR(data)->h_proto)) {",
          "74:     case ETH_P_VLAN:",
          "75:         mac_hdr_len = sizeof(struct eth_header) +",
          "76:                      sizeof(struct vlan_header);",
          "77:         break;",
          "78:     case ETH_P_DVLAN:",
          "79:         if (lduw_be_p(&PKT_GET_VLAN_HDR(data)->h_proto) == ETH_P_VLAN) {",
          "80:             mac_hdr_len = sizeof(struct eth_header) +",
          "81:                          2 * sizeof(struct vlan_header);",
          "82:         } else {",
          "83:             mac_hdr_len = sizeof(struct eth_header) +",
          "84:                          sizeof(struct vlan_header);",
          "85:         }",
          "86:         break;",
          "87:     default:",
          "88:         mac_hdr_len = sizeof(struct eth_header);",
          "89:         break;",
          "90:     }",
          "92:     length -= mac_hdr_len;",
          "95:     if (length < sizeof(struct ip_header)) {",
          "96:         return;",
          "97:     }",
          "99:     ip = (struct ip_header *)(data + mac_hdr_len);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-1870",
  "cve_desc": "The event scripts in Automatic Bug Reporting Tool (ABRT) uses world-readable permission on a copy of sosreport file in problem directories, which allows local users to obtain sensitive information from /var/log/messages via unspecified vectors.",
  "repo": "abrt/abrt",
  "patch_hash": "8939398b82006ba1fec4ed491339fc075f43fc7c",
  "patch_info": {
    "commit_hash": "8939398b82006ba1fec4ed491339fc075f43fc7c",
    "repo": "abrt/abrt",
    "commit_url": "https://github.com/abrt/abrt/commit/8939398b82006ba1fec4ed491339fc075f43fc7c",
    "files": [
      "src/daemon/abrt-server.c",
      "src/daemon/abrt.conf",
      "src/hooks/abrt-hook-ccpp.c",
      "src/include/libabrt.h",
      "src/lib/abrt_conf.c",
      "src/lib/hooklib.c",
      "src/plugins/abrt-dump-oops.c",
      "src/plugins/abrt-dump-xorg.c"
    ],
    "message": "make the dump directories owned by root by default\n\nIt was discovered that the abrt event scripts create a user-readable\ncopy of a sosreport file in abrt problem directories, and include\nexcerpts of /var/log/messages selected by the user-controlled process\nname, leading to an information disclosure.\n\nThis issue was discovered by Florian Weimer of Red Hat Product Security.\n\nRelated: #1212868\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
    "before_after_code_files": [
      "src/daemon/abrt-server.c||src/daemon/abrt-server.c",
      "src/daemon/abrt.conf||src/daemon/abrt.conf",
      "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c",
      "src/include/libabrt.h||src/include/libabrt.h",
      "src/lib/abrt_conf.c||src/lib/abrt_conf.c",
      "src/lib/hooklib.c||src/lib/hooklib.c",
      "src/plugins/abrt-dump-oops.c||src/plugins/abrt-dump-oops.c",
      "src/plugins/abrt-dump-xorg.c||src/plugins/abrt-dump-xorg.c"
    ]
  },
  "patch_diff": {
    "src/daemon/abrt-server.c||src/daemon/abrt-server.c": [
      "File: src/daemon/abrt-server.c -> src/daemon/abrt-server.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "15:   with this program; if not, write to the Free Software Foundation, Inc.,",
      "16:   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.",
      "18: #include \"libabrt.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "18: #include \"problem_api.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "153:         error_msg(\"Bad problem directory name '%s', should start with: '%s'\", dirname, g_settings_dump_location);",
      "155:     }",
      "157:     {",
      "158:         if (errno == ENOTDIR)",
      "159:         {",
      "",
      "[Removed Lines]",
      "156:     if (!dump_dir_accessible_by_uid(dirname, client_uid))",
      "",
      "[Added Lines]",
      "157:     if (g_settings_privatereports)",
      "158:     {",
      "159:         struct stat statbuf;",
      "160:         if (lstat(dirname, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))",
      "161:         {",
      "162:             error_msg(\"Path '%s' isn't directory\", dirname);",
      "164:         }",
      "166:         struct group *gr = getgrnam(\"abrt\");",
      "167:         if (!gr)",
      "168:         {",
      "169:             error_msg(\"Group 'abrt' does not exist\");",
      "170:             return 500;",
      "171:         }",
      "172:         if (statbuf.st_uid != 0 || !(statbuf.st_gid == 0 || statbuf.st_gid == gr->gr_gid) || statbuf.st_mode & 07)",
      "173:         {",
      "174:             error_msg(\"Problem directory '%s' isn't owned by root:abrt or others are not restricted from access\", dirname);",
      "175:             return 403;",
      "176:         }",
      "177:         struct dump_dir *dd = dd_opendir(dirname, DD_OPEN_READONLY);",
      "178:         const bool complete = dd && problem_dump_dir_is_complete(dd);",
      "179:         dd_close(dd);",
      "180:         if (complete)",
      "181:         {",
      "182:             error_msg(\"Problem directory '%s' has already been processed\", dirname);",
      "183:             return 403;",
      "184:         }",
      "185:     }",
      "186:     else if (!dump_dir_accessible_by_uid(dirname, client_uid))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "381:     if (!dd)",
      "382:     {",
      "383:         error_msg_and_die(\"Error creating problem directory '%s'\", path);",
      "",
      "[Removed Lines]",
      "380:     struct dump_dir *dd = dd_create(path, client_uid, DEFAULT_DUMP_DIR_MODE);",
      "",
      "[Added Lines]",
      "410:     struct dump_dir *dd = dd_create(path, g_settings_privatereports ? 0 : client_uid, DEFAULT_DUMP_DIR_MODE);",
      "",
      "---------------"
    ],
    "src/daemon/abrt.conf||src/daemon/abrt.conf": [
      "File: src/daemon/abrt.conf -> src/daemon/abrt.conf",
      "--- Hunk 1 ---",
      "[Context before]",
      "43: #                session; otherwise No.",
      "44: #",
      "45: # ShortenedReporting = yes",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "47: # Disable this if you want to regular users to own the problem data colleted by",
      "48: # abrt.",
      "49: #",
      "50: PrivateReports = yes",
      "",
      "---------------"
    ],
    "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c": [
      "File: src/hooks/abrt-hook-ccpp.c -> src/hooks/abrt-hook-ccpp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "682:         }",
      "683:     }",
      "686:     if (setting_MakeCompatCore && ulimit_c != 0)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "686:     const uid_t dduid = g_settings_privatereports ? 0 : fsuid;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "773:         goto create_user_core;",
      "774:     }",
      "784:     if (dd)",
      "785:     {",
      "786:         char *rootdir = get_rootdir(pid);",
      "788:         dd_create_basic_files(dd, fsuid, NULL);",
      "790:         char source_filename[sizeof(\"/proc/%lu/somewhat_long_name\") + sizeof(long)*3];",
      "",
      "[Removed Lines]",
      "783:     dd = dd_create_skeleton(path, fsuid, DEFAULT_DUMP_DIR_MODE, /*no flags*/0);",
      "",
      "[Added Lines]",
      "786:     dd = dd_create_skeleton(path, dduid, DEFAULT_DUMP_DIR_MODE, /*no flags*/0);",
      "",
      "---------------"
    ],
    "src/include/libabrt.h||src/include/libabrt.h": [
      "File: src/include/libabrt.h -> src/include/libabrt.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "62: extern char *        g_settings_autoreporting_event;",
      "63: #define g_settings_shortenedreporting abrt_g_settings_shortenedreporting",
      "64: extern bool          g_settings_shortenedreporting;",
      "67: #define load_abrt_conf abrt_load_abrt_conf",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "65: #define g_settings_privatereports abrt_g_settings_privatereports",
      "66: extern bool          g_settings_privatereports;",
      "",
      "---------------"
    ],
    "src/lib/abrt_conf.c||src/lib/abrt_conf.c": [
      "File: src/lib/abrt_conf.c -> src/lib/abrt_conf.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "27: bool          g_settings_autoreporting = 0;",
      "28: char *        g_settings_autoreporting_event = NULL;",
      "29: bool          g_settings_shortenedreporting = 0;",
      "31: void free_abrt_conf_data()",
      "32: {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "30: bool          g_settings_privatereports = true;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "102:     else",
      "103:         g_settings_shortenedreporting = 0;",
      "105:     GHashTableIter iter;",
      "106:     const char *name;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "106:     value = get_map_string_item_or_NULL(settings, \"PrivateReports\");",
      "107:     if (value)",
      "108:     {",
      "109:         g_settings_privatereports = string_to_bool(value);",
      "110:         remove_map_string_item(settings, \"PrivateReports\");",
      "111:     }",
      "",
      "---------------"
    ],
    "src/lib/hooklib.c||src/lib/hooklib.c": [
      "File: src/lib/hooklib.c -> src/lib/hooklib.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "410: {",
      "411:     load_abrt_conf();",
      "415:     char *problem_id = NULL;",
      "416:     if (dd)",
      "",
      "[Removed Lines]",
      "413:     struct dump_dir *dd = create_dump_dir_from_problem_data(pd, g_settings_dump_location);",
      "",
      "[Added Lines]",
      "413:     struct dump_dir *dd = NULL;",
      "415:     if (g_settings_privatereports)",
      "416:         dd = create_dump_dir_from_problem_data_ext(pd, g_settings_dump_location, 0);",
      "417:     else",
      "418:         dd = create_dump_dir_from_problem_data(pd, g_settings_dump_location);",
      "",
      "---------------"
    ],
    "src/plugins/abrt-dump-oops.c||src/plugins/abrt-dump-oops.c": [
      "File: src/plugins/abrt-dump-oops.c -> src/plugins/abrt-dump-oops.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "189:         mode = DEFAULT_DUMP_DIR_MODE;",
      "190:         my_euid = geteuid();",
      "191:     }",
      "193:     pid_t my_pid = getpid();",
      "194:     unsigned idx = 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "192:     if (g_settings_privatereports)",
      "193:     {",
      "194:         if (world_readable_dump)",
      "195:             log(\"Not going to make dump directories world readable because PrivateReports is on\");",
      "197:         mode = DEFAULT_DUMP_DIR_MODE;",
      "198:         my_euid = 0;",
      "199:     }",
      "",
      "---------------"
    ],
    "src/plugins/abrt-dump-xorg.c||src/plugins/abrt-dump-xorg.c": [
      "File: src/plugins/abrt-dump-xorg.c -> src/plugins/abrt-dump-xorg.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "82:         mode = DEFAULT_DUMP_DIR_MODE;",
      "83:         my_euid = geteuid();",
      "84:     }",
      "86:     pid_t my_pid = getpid();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "85:     if (g_settings_privatereports)",
      "86:     {",
      "87:         if ((g_opts & OPT_x))",
      "88:             log(\"Not going to make dump directories world readable because PrivateReports is on\");",
      "90:         mode = DEFAULT_DUMP_DIR_MODE;",
      "91:         my_euid = 0;",
      "92:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c796c76341ee846cfb897ed645bac211d7d0a932",
      "candidate_info": {
        "commit_hash": "c796c76341ee846cfb897ed645bac211d7d0a932",
        "repo": "abrt/abrt",
        "commit_url": "https://github.com/abrt/abrt/commit/c796c76341ee846cfb897ed645bac211d7d0a932",
        "files": [
          "src/daemon/abrt-server.c"
        ],
        "message": "daemon: use libreport's function checking file name\n\nMove the functions to libreport because we need the same functionality\nthere too.\n\nRelated: #1214451\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "src/daemon/abrt-server.c||src/daemon/abrt-server.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/abrt/abrt/pull/950"
        ],
        "olp_code_files": {
          "patch": [
            "src/daemon/abrt-server.c||src/daemon/abrt-server.c"
          ],
          "candidate": [
            "src/daemon/abrt-server.c||src/daemon/abrt-server.c"
          ]
        }
      },
      "candidate_diff": {
        "src/daemon/abrt-server.c||src/daemon/abrt-server.c": [
          "File: src/daemon/abrt-server.c -> src/daemon/abrt-server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "476:     exit(0);",
          "477: }",
          "495: static gboolean key_value_ok(gchar *key, gchar *value)",
          "496: {",
          "497:     char *i;",
          "",
          "[Removed Lines]",
          "480: static gboolean printable_str(const char *str)",
          "481: {",
          "482:     do {",
          "483:         if ((unsigned char)(*str) < ' ' || *str == 0x7f)",
          "484:             return FALSE;",
          "485:         str++;",
          "486:     } while (*str);",
          "487:     return TRUE;",
          "488: }",
          "490: static gboolean is_correct_filename(const char *value)",
          "491: {",
          "492:     return printable_str(value) && !strchr(value, '/') && !strchr(value, '.');",
          "493: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "510:      || strcmp(key, FILENAME_TYPE) == 0",
          "511:     )",
          "512:     {",
          "514:         {",
          "515:             error_msg(\"Value of '%s' ('%s') is not a valid directory name\",",
          "516:                       key, value);",
          "",
          "[Removed Lines]",
          "513:         if (!is_correct_filename(value))",
          "",
          "[Added Lines]",
          "497:         if (!str_is_correct_filename(value))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f3c2a6af3455b2882e28570e8a04f1c2d4500d5b",
      "candidate_info": {
        "commit_hash": "f3c2a6af3455b2882e28570e8a04f1c2d4500d5b",
        "repo": "abrt/abrt",
        "commit_url": "https://github.com/abrt/abrt/commit/f3c2a6af3455b2882e28570e8a04f1c2d4500d5b",
        "files": [
          "src/dbus/abrt-dbus.c"
        ],
        "message": "dbus: report invalid element names\n\nReturn D-Bus error in case of invalid problem element name.\n\nRelated: #1214451\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "src/dbus/abrt-dbus.c||src/dbus/abrt-dbus.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/abrt/abrt/pull/950"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/dbus/abrt-dbus.c||src/dbus/abrt-dbus.c": [
          "File: src/dbus/abrt-dbus.c -> src/dbus/abrt-dbus.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "600:         g_variant_get(parameters, \"(&s&s&s)\", &problem_id, &element, &value);",
          "603:         {",
          "604:             log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);",
          "605:             char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);",
          "",
          "[Removed Lines]",
          "602:         if (element == NULL || element[0] == '\\0' || strlen(element) > 64)",
          "",
          "[Added Lines]",
          "602:         if (!str_is_correct_filename(element))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "659:         g_variant_get(parameters, \"(&s&s)\", &problem_id, &element);",
          "661:         struct dump_dir *dd = open_directory_for_modification_of_element(",
          "662:                                     invocation, caller_uid, problem_id, element);",
          "663:         if (!dd)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "661:         if (!str_is_correct_filename(element))",
          "662:         {",
          "663:             log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);",
          "664:             char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);",
          "665:             g_dbus_method_invocation_return_dbus_error(invocation,",
          "666:                                               \"org.freedesktop.problems.InvalidElement\",",
          "667:                                               error);",
          "669:             free(error);",
          "670:             return;",
          "671:         }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b7f8bd20b7fb5b72f003ae3fa647c1d75f4218b7",
      "candidate_info": {
        "commit_hash": "b7f8bd20b7fb5b72f003ae3fa647c1d75f4218b7",
        "repo": "abrt/abrt",
        "commit_url": "https://github.com/abrt/abrt/commit/b7f8bd20b7fb5b72f003ae3fa647c1d75f4218b7",
        "files": [
          "src/daemon/abrt-server.c",
          "src/include/libabrt.h",
          "src/lib/hooklib.c",
          "tests/Makefile.am",
          "tests/hooklib.at",
          "tests/testsuite.at"
        ],
        "message": "lib: add functions validating dump dir\n\nMove the code from abrt-server to shared library and fix the condition\nvalidating dump dir's path.\n\nAs of now, abrt is allowed to process only direct sub-directories of the\ndump locations.\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "src/daemon/abrt-server.c||src/daemon/abrt-server.c",
          "src/include/libabrt.h||src/include/libabrt.h",
          "src/lib/hooklib.c||src/lib/hooklib.c",
          "tests/Makefile.am||tests/Makefile.am",
          "tests/hooklib.at||tests/hooklib.at",
          "tests/testsuite.at||tests/testsuite.at"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/abrt/abrt/pull/950"
        ],
        "olp_code_files": {
          "patch": [
            "src/daemon/abrt-server.c||src/daemon/abrt-server.c",
            "src/include/libabrt.h||src/include/libabrt.h",
            "src/lib/hooklib.c||src/lib/hooklib.c"
          ],
          "candidate": [
            "src/daemon/abrt-server.c||src/daemon/abrt-server.c",
            "src/include/libabrt.h||src/include/libabrt.h",
            "src/lib/hooklib.c||src/lib/hooklib.c"
          ]
        }
      },
      "candidate_diff": {
        "src/daemon/abrt-server.c||src/daemon/abrt-server.c": [
          "File: src/daemon/abrt-server.c -> src/daemon/abrt-server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "76: static uid_t client_uid = (uid_t)-1L;",
          "94: static int delete_path(const char *dump_dir_name)",
          "95: {",
          "",
          "[Removed Lines]",
          "79: static bool dir_is_in_dump_location(const char *dump_dir_name)",
          "80: {",
          "81:     unsigned len = strlen(g_settings_dump_location);",
          "83:     if (strncmp(dump_dir_name, g_settings_dump_location, len) == 0",
          "84:      && dump_dir_name[len] == '/'",
          "86:      && !strstr(dump_dir_name + len, \"/.\")",
          "87:     ) {",
          "88:         return 1;",
          "89:     }",
          "90:     return 0;",
          "91: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "100:         error_msg(\"Bad problem directory name '%s', should start with: '%s'\", dump_dir_name, g_settings_dump_location);",
          "102:     }",
          "103:     if (!dump_dir_accessible_by_uid(dump_dir_name, client_uid))",
          "104:     {",
          "105:         if (errno == ENOTDIR)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "89:     if (!dir_has_correct_permissions(dump_dir_name))",
          "90:     {",
          "91:         error_msg(\"Problem directory '%s' isn't owned by root:abrt or others are not restricted from access\", dump_dir_name);",
          "93:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "154:         error_msg(\"Bad problem directory name '%s', should start with: '%s'\", dirname, g_settings_dump_location);",
          "156:     }",
          "157:     if (g_settings_privatereports)",
          "158:     {",
          "177:         struct dump_dir *dd = dd_opendir(dirname, DD_OPEN_READONLY);",
          "178:         const bool complete = dd && problem_dump_dir_is_complete(dd);",
          "179:         dd_close(dd);",
          "",
          "[Removed Lines]",
          "159:         struct stat statbuf;",
          "160:         if (lstat(dirname, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))",
          "161:         {",
          "162:             error_msg(\"Path '%s' isn't directory\", dirname);",
          "164:         }",
          "166:         struct group *gr = getgrnam(\"abrt\");",
          "167:         if (!gr)",
          "168:         {",
          "169:             error_msg(\"Group 'abrt' does not exist\");",
          "170:             return 500;",
          "171:         }",
          "172:         if (statbuf.st_uid != 0 || !(statbuf.st_gid == 0 || statbuf.st_gid == gr->gr_gid) || statbuf.st_mode & 07)",
          "173:         {",
          "174:             error_msg(\"Problem directory '%s' isn't owned by root:abrt or others are not restricted from access\", dirname);",
          "175:             return 403;",
          "176:         }",
          "",
          "[Added Lines]",
          "148:     if (!dir_has_correct_permissions(dirname))",
          "149:     {",
          "150:         error_msg(\"Problem directory '%s' isn't owned by root:abrt or others are not restricted from access\", dirname);",
          "152:     }",
          "",
          "---------------"
        ],
        "src/include/libabrt.h||src/include/libabrt.h": [
          "File: src/include/libabrt.h -> src/include/libabrt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "47: #define get_backtrace abrt_get_backtrace",
          "48: char *get_backtrace(const char *dump_dir_name, unsigned timeout_sec, const char *debuginfo_dirs);",
          "51: #define g_settings_nMaxCrashReportsSize abrt_g_settings_nMaxCrashReportsSize",
          "52: extern unsigned int  g_settings_nMaxCrashReportsSize;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "50: #define dir_is_in_dump_location abrt_dir_is_in_dump_location",
          "51: bool dir_is_in_dump_location(const char *dir_name);",
          "52: #define dir_has_correct_permissions abrt_dir_has_correct_permissions",
          "53: bool dir_has_correct_permissions(const char *dir_name);",
          "",
          "---------------"
        ],
        "src/lib/hooklib.c||src/lib/hooklib.c": [
          "File: src/lib/hooklib.c -> src/lib/hooklib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "427:     log_info(\"problem id: '%s'\", problem_id);",
          "428:     return problem_id;",
          "429: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "431: bool dir_is_in_dump_location(const char *dir_name)",
          "432: {",
          "433:     unsigned len = strlen(g_settings_dump_location);",
          "436:     if (strncmp(dir_name, g_settings_dump_location, len) != 0)",
          "437:     {",
          "438:         log_debug(\"Bad parent directory: '%s' not in '%s'\", g_settings_dump_location, dir_name);",
          "439:         return false;",
          "440:     }",
          "443:     const char *base_name = dir_name + len;",
          "444:     while (*base_name && *base_name == '/')",
          "445:         ++base_name;",
          "447:     if (*(base_name - 1) != '/' || !str_is_correct_filename(base_name))",
          "448:     {",
          "449:         log_debug(\"Invalid dump directory name: '%s'\", base_name);",
          "450:         return false;",
          "451:     }",
          "454:     struct stat sb;",
          "455:     if (lstat(dir_name, &sb) < 0)",
          "456:     {",
          "457:         VERB2 perror_msg(\"stat('%s')\", dir_name);",
          "458:         return errno== ENOENT;",
          "459:     }",
          "461:     return S_ISDIR(sb.st_mode);",
          "462: }",
          "464: bool dir_has_correct_permissions(const char *dir_name)",
          "465: {",
          "466:     if (g_settings_privatereports)",
          "467:     {",
          "468:         struct stat statbuf;",
          "469:         if (lstat(dir_name, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))",
          "470:         {",
          "471:             error_msg(\"Path '%s' isn't directory\", dir_name);",
          "472:             return false;",
          "473:         }",
          "475:         struct group *gr = getgrnam(\"abrt\");",
          "476:         if (!gr)",
          "477:         {",
          "478:             error_msg(\"Group 'abrt' does not exist\");",
          "479:             return false;",
          "480:         }",
          "481:         if (statbuf.st_uid != 0 || !(statbuf.st_gid == 0 || statbuf.st_gid == gr->gr_gid) || statbuf.st_mode & 07)",
          "482:             return false;",
          "483:     }",
          "484:     return true;",
          "485: }",
          "",
          "---------------"
        ],
        "tests/Makefile.am||tests/Makefile.am": [
          "File: tests/Makefile.am -> tests/Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "29:   testsuite.at \\",
          "30:   pyhook.at \\",
          "31:   koops-parser.at \\",
          "34: EXTRA_DIST += $(TESTSUITE_AT)",
          "35: TESTSUITE = $(srcdir)/testsuite",
          "",
          "[Removed Lines]",
          "32:   ignored_problems.at",
          "",
          "[Added Lines]",
          "32:   ignored_problems.at \\",
          "33:   hooklib.at",
          "",
          "---------------"
        ],
        "tests/hooklib.at||tests/hooklib.at": [
          "File: tests/hooklib.at -> tests/hooklib.at",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # -*- Autotest -*-",
          "3: AT_BANNER([hooklib])",
          "5: AT_TESTFUN([dir_is_in_dump_location],",
          "6: [[",
          "7: #include \"libabrt.h\"",
          "8: #include <assert.h>",
          "10: void test(char *name, bool expected)",
          "11: {",
          "12:     if (dir_is_in_dump_location(name) != expected)",
          "13:     {",
          "14:         fprintf(stderr, \"Bad: %s\", name);",
          "15:         abort();",
          "16:     }",
          "18:     free(name);",
          "19: }",
          "21: int main(void)",
          "22: {",
          "23:     g_verbose = 3;",
          "24:     load_abrt_conf();",
          "26:     g_verbose = 3;",
          "28:     char *name;",
          "30:     assert(dir_is_in_dump_location(\"/\") == false);",
          "32:     asprintf(&name, \"%s\", g_settings_dump_location);",
          "33:     test(name, false);",
          "35:     asprintf(&name, \"%s..evil\", g_settings_dump_location);",
          "36:     test(name, false);",
          "38:     asprintf(&name, \"%s/\", g_settings_dump_location);",
          "39:     test(name, false);",
          "41:     asprintf(&name, \"%s///\", g_settings_dump_location);",
          "42:     test(name, false);",
          "44:     asprintf(&name, \"%s/.\", g_settings_dump_location);",
          "45:     test(name, false);",
          "47:     asprintf(&name, \"%s///.\", g_settings_dump_location);",
          "48:     test(name, false);",
          "50:     asprintf(&name, \"%s/./\", g_settings_dump_location);",
          "51:     test(name, false);",
          "53:     asprintf(&name, \"%s/.///\", g_settings_dump_location);",
          "54:     test(name, false);",
          "56:     asprintf(&name, \"%s/..\", g_settings_dump_location);",
          "57:     test(name, false);",
          "59:     asprintf(&name, \"%s///..\", g_settings_dump_location);",
          "60:     test(name, false);",
          "62:     asprintf(&name, \"%s/../\", g_settings_dump_location);",
          "63:     test(name, false);",
          "65:     asprintf(&name, \"%s/..///\", g_settings_dump_location);",
          "66:     test(name, false);",
          "68:     asprintf(&name, \"%s/good/../../../evil\", g_settings_dump_location);",
          "69:     test(name, false);",
          "71:     asprintf(&name, \"%s/good..still\", g_settings_dump_location);",
          "72:     test(name, true);",
          "74:     asprintf(&name, \"%s/good.new\", g_settings_dump_location);",
          "75:     test(name, true);",
          "77:     asprintf(&name, \"%s/.meta\", g_settings_dump_location);",
          "78:     test(name, true);",
          "80:     asprintf(&name, \"%s/..data\", g_settings_dump_location);",
          "81:     test(name, true);",
          "83:     return 0;",
          "84: }",
          "85: ]])",
          "",
          "---------------"
        ],
        "tests/testsuite.at||tests/testsuite.at": [
          "File: tests/testsuite.at -> tests/testsuite.at",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: m4_include([koops-parser.at])",
          "5: m4_include([pyhook.at])",
          "6: m4_include([ignored_problems.at])",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: m4_include([hooklib.at])",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d6e2f6f128cef4c21cb80941ae674c9842681aa7",
      "candidate_info": {
        "commit_hash": "d6e2f6f128cef4c21cb80941ae674c9842681aa7",
        "repo": "abrt/abrt",
        "commit_url": "https://github.com/abrt/abrt/commit/d6e2f6f128cef4c21cb80941ae674c9842681aa7",
        "files": [
          "src/hooks/abrt-hook-ccpp.c"
        ],
        "message": "ccpp: open file for dump_fd_info with O_EXCL\n\nTo avoid possible races.\n\nRelated: #1211835\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/abrt/abrt/pull/950"
        ],
        "olp_code_files": {
          "patch": [
            "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c"
          ],
          "candidate": [
            "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c"
          ]
        }
      },
      "candidate_diff": {
        "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c": [
          "File: src/hooks/abrt-hook-ccpp.c -> src/hooks/abrt-hook-ccpp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "400: static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)",
          "401: {",
          "403:     if (!fp)",
          "404:         return false;",
          "",
          "[Removed Lines]",
          "402:     FILE *fp = fopen(dest_filename, \"w\");",
          "",
          "[Added Lines]",
          "402:     FILE *fp = fopen(dest_filename, \"wx\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "80408e9e24a1c10f85fd969e1853e0f192157f92",
      "candidate_info": {
        "commit_hash": "80408e9e24a1c10f85fd969e1853e0f192157f92",
        "repo": "abrt/abrt",
        "commit_url": "https://github.com/abrt/abrt/commit/80408e9e24a1c10f85fd969e1853e0f192157f92",
        "files": [
          "src/hooks/abrt-hook-ccpp.c"
        ],
        "message": "ccpp: fix symlink race conditions\n\nFix copy & chown race conditions\n\nRelated: #1211835\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/abrt/abrt/pull/950"
        ],
        "olp_code_files": {
          "patch": [
            "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c"
          ],
          "candidate": [
            "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c"
          ]
        }
      },
      "candidate_diff": {
        "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c": [
          "File: src/hooks/abrt-hook-ccpp.c -> src/hooks/abrt-hook-ccpp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "397:     return user_core_fd;",
          "398: }",
          "401: {",
          "402:     FILE *fp = fopen(dest_filename, \"w\");",
          "403:     if (!fp)",
          "",
          "[Removed Lines]",
          "400: static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs)",
          "",
          "[Added Lines]",
          "400: static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "429:         }",
          "430:         fclose(in);",
          "431:     }",
          "432:     fclose(fp);",
          "433:     return true;",
          "434: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "433:     const int dest_fd = fileno(fp);",
          "434:     if (fchown(dest_fd, uid, gid) < 0)",
          "435:     {",
          "436:         perror_msg(\"Can't change '%s' ownership to %lu:%lu\", dest_filename, (long)uid, (long)gid);",
          "437:         fclose(fp);",
          "438:         unlink(dest_filename);",
          "439:         return false;",
          "440:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "684:         strcpy(source_filename + source_base_ofs, \"maps\");",
          "685:         strcpy(dest_base, FILENAME_MAPS);",
          "689:         strcpy(source_filename + source_base_ofs, \"limits\");",
          "690:         strcpy(dest_base, FILENAME_LIMITS);",
          "694:         strcpy(source_filename + source_base_ofs, \"cgroup\");",
          "695:         strcpy(dest_base, FILENAME_CGROUP);",
          "699:         strcpy(dest_base, FILENAME_OPEN_FDS);",
          "703:         free(dest_filename);",
          "",
          "[Removed Lines]",
          "686:         copy_file(source_filename, dest_filename, DEFAULT_DUMP_DIR_MODE);",
          "687:         IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));",
          "691:         copy_file(source_filename, dest_filename, DEFAULT_DUMP_DIR_MODE);",
          "692:         IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));",
          "696:         copy_file(source_filename, dest_filename, DEFAULT_DUMP_DIR_MODE);",
          "697:         IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));",
          "700:         if (dump_fd_info(dest_filename, source_filename, source_base_ofs))",
          "701:             IGNORE_RESULT(chown(dest_filename, dd->dd_uid, dd->dd_gid));",
          "",
          "[Added Lines]",
          "695:         copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);",
          "699:         copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);",
          "703:         copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);",
          "706:         dump_fd_info(dest_filename, source_filename, source_base_ofs, dd->dd_uid, dd->dd_gid);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2013-4162",
  "cve_desc": "The udp_v6_push_pending_frames function in net/ipv6/udp.c in the IPv6 implementation in the Linux kernel through 3.10.3 makes an incorrect function call for pending data, which allows local users to cause a denial of service (BUG and system crash) via a crafted application that uses the UDP_CORK option in a setsockopt system call.",
  "repo": "torvalds/linux",
  "patch_hash": "8822b64a0fa64a5dd1dfcf837c5b0be83f8c05d1",
  "patch_info": {
    "commit_hash": "8822b64a0fa64a5dd1dfcf837c5b0be83f8c05d1",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/8822b64a0fa64a5dd1dfcf837c5b0be83f8c05d1",
    "files": [
      "include/net/udp.h",
      "net/ipv4/udp.c",
      "net/ipv6/udp.c"
    ],
    "message": "ipv6: call udp_push_pending_frames when uncorking a socket with AF_INET pending data\n\nWe accidentally call down to ip6_push_pending_frames when uncorking\npending AF_INET data on a ipv6 socket. This results in the following\nsplat (from Dave Jones):\n\nskbuff: skb_under_panic: text:ffffffff816765f6 len:48 put:40 head:ffff88013deb6df0 data:ffff88013deb6dec tail:0x2c end:0xc0 dev:<NULL>\n------------[ cut here ]------------\nkernel BUG at net/core/skbuff.c:126!\ninvalid opcode: 0000 [#1] PREEMPT SMP DEBUG_PAGEALLOC\nModules linked in: dccp_ipv4 dccp 8021q garp bridge stp dlci mpoa snd_seq_dummy sctp fuse hidp tun bnep nfnetlink scsi_transport_iscsi rfcomm can_raw can_bcm af_802154 appletalk caif_socket can caif ipt_ULOG x25 rose af_key pppoe pppox ipx phonet irda llc2 ppp_generic slhc p8023 psnap p8022 llc crc_ccitt atm bluetooth\n+netrom ax25 nfc rfkill rds af_rxrpc coretemp hwmon kvm_intel kvm crc32c_intel snd_hda_codec_realtek ghash_clmulni_intel microcode pcspkr snd_hda_codec_hdmi snd_hda_intel snd_hda_codec snd_hwdep usb_debug snd_seq snd_seq_device snd_pcm e1000e snd_page_alloc snd_timer ptp snd pps_core soundcore xfs libcrc32c\nCPU: 2 PID: 8095 Comm: trinity-child2 Not tainted 3.10.0-rc7+ #37\ntask: ffff8801f52c2520 ti: ffff8801e6430000 task.ti: ffff8801e6430000\nRIP: 0010:[<ffffffff816e759c>]  [<ffffffff816e759c>] skb_panic+0x63/0x65\nRSP: 0018:ffff8801e6431de8  EFLAGS: 00010282\nRAX: 0000000000000086 RBX: ffff8802353d3cc0 RCX: 0000000000000006\nRDX: 0000000000003b90 RSI: ffff8801f52c2ca0 RDI: ffff8801f52c2520\nRBP: ffff8801e6431e08 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000001 R11: 0000000000000001 R12: ffff88022ea0c800\nR13: ffff88022ea0cdf8 R14: ffff8802353ecb40 R15: ffffffff81cc7800\nFS:  00007f5720a10740(0000) GS:ffff880244c00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000005862000 CR3: 000000022843c000 CR4: 00000000001407e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000600\nStack:\n ffff88013deb6dec 000000000000002c 00000000000000c0 ffffffff81a3f6e4\n ffff8801e6431e18 ffffffff8159a9aa ffff8801e6431e90 ffffffff816765f6\n ffffffff810b756b 0000000700000002 ffff8801e6431e40 0000fea9292aa8c0\nCall Trace:\n [<ffffffff8159a9aa>] skb_push+0x3a/0x40\n [<ffffffff816765f6>] ip6_push_pending_frames+0x1f6/0x4d0\n [<ffffffff810b756b>] ? mark_held_locks+0xbb/0x140\n [<ffffffff81694919>] udp_v6_push_pending_frames+0x2b9/0x3d0\n [<ffffffff81694660>] ? udplite_getfrag+0x20/0x20\n [<ffffffff8162092a>] udp_lib_setsockopt+0x1aa/0x1f0\n [<ffffffff811cc5e7>] ? fget_light+0x387/0x4f0\n [<ffffffff816958a4>] udpv6_setsockopt+0x34/0x40\n [<ffffffff815949f4>] sock_common_setsockopt+0x14/0x20\n [<ffffffff81593c31>] SyS_setsockopt+0x71/0xd0\n [<ffffffff816f5d54>] tracesys+0xdd/0xe2\nCode: 00 00 48 89 44 24 10 8b 87 d8 00 00 00 48 89 44 24 08 48 8b 87 e8 00 00 00 48 c7 c7 c0 04 aa 81 48 89 04 24 31 c0 e8 e1 7e ff ff <0f> 0b 55 48 89 e5 0f 0b 55 48 89 e5 0f 0b 55 48 89 e5 0f 0b 55\nRIP  [<ffffffff816e759c>] skb_panic+0x63/0x65\n RSP <ffff8801e6431de8>\n\nThis patch adds a check if the pending data is of address family AF_INET\nand directly calls udp_push_ending_frames from udp_v6_push_pending_frames\nif that is the case.\n\nThis bug was found by Dave Jones with trinity.\n\n(Also move the initialization of fl6 below the AF_INET check, even if\nnot strictly necessary.)\n\nCc: Dave Jones <davej@redhat.com>\nCc: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "include/net/udp.h||include/net/udp.h",
      "net/ipv4/udp.c||net/ipv4/udp.c",
      "net/ipv6/udp.c||net/ipv6/udp.c"
    ]
  },
  "patch_diff": {
    "include/net/udp.h||include/net/udp.h": [
      "File: include/net/udp.h -> include/net/udp.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "181: extern void udp_err(struct sk_buff *, u32);",
      "182: extern int udp_sendmsg(struct kiocb *iocb, struct sock *sk,",
      "183:        struct msghdr *msg, size_t len);",
      "184: extern void udp_flush_pending_frames(struct sock *sk);",
      "185: extern int udp_rcv(struct sk_buff *skb);",
      "186: extern int udp_ioctl(struct sock *sk, int cmd, unsigned long arg);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "184: extern int udp_push_pending_frames(struct sock *sk);",
      "",
      "---------------"
    ],
    "net/ipv4/udp.c||net/ipv4/udp.c": [
      "File: net/ipv4/udp.c -> net/ipv4/udp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "804: {",
      "805:  struct udp_sock  *up = udp_sk(sk);",
      "806:  struct inet_sock *inet = inet_sk(sk);",
      "",
      "[Removed Lines]",
      "803: static int udp_push_pending_frames(struct sock *sk)",
      "",
      "[Added Lines]",
      "803: int udp_push_pending_frames(struct sock *sk)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "819:  up->pending = 0;",
      "820:  return err;",
      "821: }",
      "823: int udp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,",
      "824:   size_t len)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "822: EXPORT_SYMBOL(udp_push_pending_frames);",
      "",
      "---------------"
    ],
    "net/ipv6/udp.c||net/ipv6/udp.c": [
      "File: net/ipv6/udp.c -> net/ipv6/udp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "959:  struct udphdr *uh;",
      "960:  struct udp_sock  *up = udp_sk(sk);",
      "961:  struct inet_sock *inet = inet_sk(sk);",
      "963:  int err = 0;",
      "964:  int is_udplite = IS_UDPLITE(sk);",
      "965:  __wsum csum = 0;",
      "968:  if ((skb = skb_peek(&sk->sk_write_queue)) == NULL)",
      "969:   goto out;",
      "",
      "[Removed Lines]",
      "962:  struct flowi6 *fl6 = &inet->cork.fl.u.ip6;",
      "",
      "[Added Lines]",
      "962:  struct flowi6 *fl6;",
      "967:  if (up->pending == AF_INET)",
      "968:   return udp_push_pending_frames(sk);",
      "970:  fl6 = &inet->cork.fl.u.ip6;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4008bab7b3969ad9f9dd1d02096a3f0aa5610bd2",
      "candidate_info": {
        "commit_hash": "4008bab7b3969ad9f9dd1d02096a3f0aa5610bd2",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4008bab7b3969ad9f9dd1d02096a3f0aa5610bd2",
        "files": [
          "mm/page_alloc.c"
        ],
        "message": "mm/page_alloc: factor out setting of pcp->high and pcp->batch\n\n\"Problems\" with the current code:\n\n1: there is a lack of synchronization in setting ->high and ->batch in\n   percpu_pagelist_fraction_sysctl_handler()\n\n2: stop_machine() in zone_pcp_update() is unnecissary.\n\n3: zone_pcp_update() does not consider the case where\n   percpu_pagelist_fraction is non-zero\n\nTo fix:\n\n1: add memory barriers, a safe ->batch value, an update side mutex when\n   updating ->high and ->batch, and use ACCESS_ONCE() for ->batch users\n   that expect a stable value.\n\n2: avoid draining pages in zone_pcp_update(), rely upon the memory\n   barriers added to fix #1\n\n3: factor out quite a few functions, and then call the appropriate one.\n\nNote that it results in a change to the behavior of zone_pcp_update(),\nwhich is used by memory_hotplug.  I'm rather certain that I've diserned\n(and preserved) the essential behavior (changing ->high and ->batch), and\nonly eliminated unneeded actions (draining the per cpu pages), but this\nmay not be the case.\n\nFurther note that the draining of pages that previously took place in\nzone_pcp_update() occured after repeated draining when attempting to\noffline a page, and after the offline has \"succeeded\".  It appears that\nthe draining was added to zone_pcp_update() to avoid refactoring\nsetup_pageset() into 2 funtions.\n\nThis patch:\n\nCreates pageset_set_batch() for use in setup_pageset().\npageset_set_batch() imitates the functionality of\nsetup_pagelist_highmark(), but uses the boot time\n(percpu_pagelist_fraction == 0) calculations for determining ->high based\non ->batch.\n\nSigned-off-by: Cody P Schafer <cody@linux.vnet.ibm.com>\nCc: Gilad Ben-Yossef <gilad@benyossef.com>\nCc: KOSAKI Motohiro <kosaki.motohiro@gmail.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Pekka Enberg <penberg@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/page_alloc.c||mm/page_alloc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "mm/page_alloc.c||mm/page_alloc.c": [
          "File: mm/page_alloc.c -> mm/page_alloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4032: #endif",
          "4033: }",
          "4035: static void setup_pageset(struct per_cpu_pageset *p, unsigned long batch)",
          "4036: {",
          "4037:  struct per_cpu_pages *pcp;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4036: static void pageset_set_batch(struct per_cpu_pageset *p, unsigned long batch)",
          "4037: {",
          "4038:  struct per_cpu_pages *pcp = &p->pcp;",
          "4039:  pcp->high = 6 * batch;",
          "4040:  pcp->batch = max(1UL, 1 * batch);",
          "4041: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4042:  pcp = &p->pcp;",
          "4043:  pcp->count = 0;",
          "4046:  for (migratetype = 0; migratetype < MIGRATE_PCPTYPES; migratetype++)",
          "4047:   INIT_LIST_HEAD(&pcp->lists[migratetype]);",
          "4048: }",
          "",
          "[Removed Lines]",
          "4044:  pcp->high = 6 * batch;",
          "4045:  pcp->batch = max(1UL, 1 * batch);",
          "",
          "[Added Lines]",
          "4052:  pageset_set_batch(p, batch);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cce606feb425093c8371089d392e336d186e125b",
      "candidate_info": {
        "commit_hash": "cce606feb425093c8371089d392e336d186e125b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/cce606feb425093c8371089d392e336d186e125b",
        "files": [
          "arch/powerpc/kernel/smp.c"
        ],
        "message": "powerpc: Set cpu sibling mask before online cpu\n\nIt seems following race is possible:\n\n\tcpu0\t\t\t\t\tcpux\nsmp_init->cpu_up->_cpu_up\n\t__cpu_up\n\t\tkick_cpu(1)\n-------------------------------------------------------------------------\n\t\twaiting online\t\t\t...\n\t\t...\t\t\t\tnotify CPU_STARTING\n\t\t\t\t\t\t\tset cpux active\n\t\t\t\t\t\tset cpux online\n-------------------------------------------------------------------------\n\t\tfinish waiting online\n\t\t...\nsched_init_smp\n\tinit_sched_domains(cpu_active_mask)\n\t\tbuild_sched_domains\n\t\t\t\t\t\tset cpux sibling info\n-------------------------------------------------------------------------\n\nExecution of cpu0 and cpux could be concurrent between two separator\nlines.\n\nSo if the cpux sibling information was set too late (normally\nimpossible, but could be triggered by adding some delay in\nstart_secondary, after setting cpu online), build_sched_domains()\nrunning on cpu0 might see cpux active, with an empty sibling mask, then\ncause some bad address accessing like following:\n\n[    0.099855] Unable to handle kernel paging request for data at address 0xc00000038518078f\n[    0.099868] Faulting instruction address: 0xc0000000000b7a64\n[    0.099883] Oops: Kernel access of bad area, sig: 11 [#1]\n[    0.099895] PREEMPT SMP NR_CPUS=16 DEBUG_PAGEALLOC NUMA pSeries\n[    0.099922] Modules linked in:\n[    0.099940] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.10.0-rc1-00120-gb973425-dirty #16\n[    0.099956] task: c0000001fed80000 ti: c0000001fed7c000 task.ti: c0000001fed7c000\n[    0.099971] NIP: c0000000000b7a64 LR: c0000000000b7a40 CTR: c0000000000b4934\n[    0.099985] REGS: c0000001fed7f760 TRAP: 0300   Not tainted  (3.10.0-rc1-00120-gb973425-dirty)\n[    0.099997] MSR: 8000000000009032 <SF,EE,ME,IR,DR,RI>  CR: 24272828  XER: 20000003\n[    0.100045] SOFTE: 1\n[    0.100053] CFAR: c000000000445ee8\n[    0.100064] DAR: c00000038518078f, DSISR: 40000000\n[    0.100073]\nGPR00: 0000000000000080 c0000001fed7f9e0 c000000000c84d48 0000000000000010\nGPR04: 0000000000000010 0000000000000000 c0000001fc55e090 0000000000000000\nGPR08: ffffffffffffffff c000000000b80b30 c000000000c962d8 00000003845ffc5f\nGPR12: 0000000000000000 c00000000f33d000 c00000000000b9e4 0000000000000000\nGPR16: 0000000000000000 0000000000000000 0000000000000001 0000000000000000\nGPR20: c000000000ccf750 0000000000000000 c000000000c94d48 c0000001fc504000\nGPR24: c0000001fc504000 c0000001fecef848 c000000000c94d48 c000000000ccf000\nGPR28: c0000001fc522090 0000000000000010 c0000001fecef848 c0000001fed7fae0\n[    0.100293] NIP [c0000000000b7a64] .get_group+0x84/0xc4\n[    0.100307] LR [c0000000000b7a40] .get_group+0x60/0xc4\n[    0.100318] Call Trace:\n[    0.100332] [c0000001fed7f9e0] [c0000000000dbce4] .lock_is_held+0xa8/0xd0 (unreliable)\n[    0.100354] [c0000001fed7fa70] [c0000000000bf62c] .build_sched_domains+0x728/0xd14\n[    0.100375] [c0000001fed7fbe0] [c000000000af67bc] .sched_init_smp+0x4fc/0x654\n[    0.100394] [c0000001fed7fce0] [c000000000adce24] .kernel_init_freeable+0x17c/0x30c\n[    0.100413] [c0000001fed7fdb0] [c00000000000ba08] .kernel_init+0x24/0x12c\n[    0.100431] [c0000001fed7fe30] [c000000000009f74] .ret_from_kernel_thread+0x5c/0x68\n[    0.100445] Instruction dump:\n[    0.100456] 38800010 38a00000 4838e3f5 60000000 7c6307b4 2fbf0000 419e0040 3d220001\n[    0.100496] 78601f24 39491590 e93e0008 7d6a002a <7d69582a> f97f0000 7d4a002a e93e0010\n[    0.100559] ---[ end trace 31fd0ba7d8756001 ]---\n\nThis patch tries to move the sibling maps updating before\nnotify_cpu_starting() and cpu online, and a write barrier there to make\nsure sibling maps are updated before active and online mask.\n\nSigned-off-by: Li Zhong <zhong@linux.vnet.ibm.com>\nReviewed-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>\nSigned-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>",
        "before_after_code_files": [
          "arch/powerpc/kernel/smp.c||arch/powerpc/kernel/smp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/powerpc/kernel/smp.c||arch/powerpc/kernel/smp.c": [
          "File: arch/powerpc/kernel/smp.c -> arch/powerpc/kernel/smp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "638:  vdso_getcpu_init();",
          "639: #endif",
          "643:  base = cpu_first_thread_sibling(cpu);",
          "644:  for (i = 0; i < threads_per_core; i++) {",
          "646:    continue;",
          "647:   cpumask_set_cpu(cpu, cpu_sibling_mask(base + i));",
          "648:   cpumask_set_cpu(base + i, cpu_sibling_mask(cpu));",
          "",
          "[Removed Lines]",
          "640:  notify_cpu_starting(cpu);",
          "641:  set_cpu_online(cpu, true);",
          "645:   if (cpu_is_offline(base + i))",
          "",
          "[Added Lines]",
          "643:   if (cpu_is_offline(base + i) && (cpu != base + i))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "667:  }",
          "668:  of_node_put(l2_cache);",
          "670:  local_irq_enable();",
          "672:  cpu_startup_entry(CPUHP_ONLINE);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "668:  smp_wmb();",
          "669:  notify_cpu_starting(cpu);",
          "670:  set_cpu_online(cpu, true);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4642aabd21d0491a7d9dcbe789bdf93a596f771c",
      "candidate_info": {
        "commit_hash": "4642aabd21d0491a7d9dcbe789bdf93a596f771c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4642aabd21d0491a7d9dcbe789bdf93a596f771c",
        "files": [
          "sound/soc/codecs/wm8962.c"
        ],
        "message": "ASoC: wm8962: fix NULL pdata pointer\n\nThere is an error in merge commit 384b834 on conflict resolution which\ncauses the following NULL pdata pointer bug.\n\nwm8962 0-001a: customer id 0 revision D\nUnable to handle kernel NULL pointer dereference at virtual address 00000004\npgd = 80004000\n[00000004] *pgd=00000000\nInternal error: Oops: 5 [#1] SMP ARM\nModules linked in:\nCPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.10.0+ #1\ntask: bf870000 ti: bf874000 task.ti: bf874000\nPC is at wm8962_probe+0x134/0x6c8\nLR is at regmap_unlock_mutex+0x10/0x14\npc : [<80452100>]    lr : [<80304cf4>]    psr: a0000113\nsp : bf875c98  ip : 00000000  fp : bf875cd4\nr10: 00000000  r9 : bfb1830c  r8 : 80779bc4\nr7 : 00000000  r6 : 00000001  r5 : bfbac010  r4 : bfb33e00\nr3 : 80304ce4  r2 : 00000000  r1 : 00000001  r0 : fffffffb\nFlags: NzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment kernel\nControl: 10c53c7d  Table: 1000404a  DAC: 00000017\nProcess swapper/0 (pid: 1, stack limit = 0xbf874238)\nStack: (0xbf875c98 to 0xbf876000)\n...\n\nFix the error by assigning pdata a correct pointer.\n\nSigned-off-by: Shawn Guo <shawn.guo@linaro.org>\nSigned-off-by: Mark Brown <broonie@linaro.org>",
        "before_after_code_files": [
          "sound/soc/codecs/wm8962.c||sound/soc/codecs/wm8962.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "sound/soc/codecs/wm8962.c||sound/soc/codecs/wm8962.c": [
          "File: sound/soc/codecs/wm8962.c -> sound/soc/codecs/wm8962.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3377: {",
          "3378:  int ret;",
          "3379:  struct wm8962_priv *wm8962 = snd_soc_codec_get_drvdata(codec);",
          "3381:  int i, trigger, irq_pol;",
          "3382:  bool dmicclk, dmicdat;",
          "",
          "[Removed Lines]",
          "3380:  struct wm8962_pdata *pdata = dev_get_platdata(codec->dev);",
          "",
          "[Added Lines]",
          "3380:  struct wm8962_pdata *pdata = &wm8962->pdata;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ef962df057aaafd714f5c22ba3de1be459571fdf",
      "candidate_info": {
        "commit_hash": "ef962df057aaafd714f5c22ba3de1be459571fdf",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ef962df057aaafd714f5c22ba3de1be459571fdf",
        "files": [
          "fs/ocfs2/xattr.c"
        ],
        "message": "ocfs2: xattr: fix inlined xattr reflink\n\nInlined xattr shared free space of inode block with inlined data or data\nextent record, so the size of the later two should be adjusted when\ninlined xattr is enabled.  See ocfs2_xattr_ibody_init().  But this isn't\ndone well when reflink.  For inode with inlined data, its max inlined\ndata size is adjusted in ocfs2_duplicate_inline_data(), no problem.  But\nfor inode with data extent record, its record count isn't adjusted.  Fix\nit, or data extent record and inlined xattr may overwrite each other,\nthen cause data corruption or xattr failure.\n\nOne panic caused by this bug in our test environment is the following:\n\n  kernel BUG at fs/ocfs2/xattr.c:1435!\n  invalid opcode: 0000 [#1] SMP\n  Pid: 10871, comm: multi_reflink_t Not tainted 2.6.39-300.17.1.el5uek #1\n  RIP: ocfs2_xa_offset_pointer+0x17/0x20 [ocfs2]\n  RSP: e02b:ffff88007a587948  EFLAGS: 00010283\n  RAX: 0000000000000000 RBX: 0000000000000010 RCX: 00000000000051e4\n  RDX: ffff880057092060 RSI: 0000000000000f80 RDI: ffff88007a587a68\n  RBP: ffff88007a587948 R08: 00000000000062f4 R09: 0000000000000000\n  R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000010\n  R13: ffff88007a587a68 R14: 0000000000000001 R15: ffff88007a587c68\n  FS:  00007fccff7f06e0(0000) GS:ffff88007fc00000(0000) knlGS:0000000000000000\n  CS:  e033 DS: 0000 ES: 0000 CR0: 000000008005003b\n  CR2: 00000000015cf000 CR3: 000000007aa76000 CR4: 0000000000000660\n  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\n  Process multi_reflink_t\n  Call Trace:\n    ocfs2_xa_reuse_entry+0x60/0x280 [ocfs2]\n    ocfs2_xa_prepare_entry+0x17e/0x2a0 [ocfs2]\n    ocfs2_xa_set+0xcc/0x250 [ocfs2]\n    ocfs2_xattr_ibody_set+0x98/0x230 [ocfs2]\n    __ocfs2_xattr_set_handle+0x4f/0x700 [ocfs2]\n    ocfs2_xattr_set+0x6c6/0x890 [ocfs2]\n    ocfs2_xattr_user_set+0x46/0x50 [ocfs2]\n    generic_setxattr+0x70/0x90\n    __vfs_setxattr_noperm+0x80/0x1a0\n    vfs_setxattr+0xa9/0xb0\n    setxattr+0xc3/0x120\n    sys_fsetxattr+0xa8/0xd0\n    system_call_fastpath+0x16/0x1b\n\nSigned-off-by: Junxiao Bi <junxiao.bi@oracle.com>\nReviewed-by: Jie Liu <jeff.liu@oracle.com>\nAcked-by: Joel Becker <jlbec@evilplan.org>\nCc: Mark Fasheh <mfasheh@suse.com>\nCc: Sunil Mushran <sunil.mushran@gmail.com>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/ocfs2/xattr.c||fs/ocfs2/xattr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/ocfs2/xattr.c||fs/ocfs2/xattr.c": [
          "File: fs/ocfs2/xattr.c -> fs/ocfs2/xattr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6491:  }",
          "6493:  new_oi = OCFS2_I(args->new_inode);",
          "6494:  spin_lock(&new_oi->ip_lock);",
          "6495:  new_oi->ip_dyn_features |= OCFS2_HAS_XATTR_FL | OCFS2_INLINE_XATTR_FL;",
          "6496:  new_di->i_dyn_features = cpu_to_le16(new_oi->ip_dyn_features);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6498:  if (!(new_oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) &&",
          "6499:      !(ocfs2_inode_is_fast_symlink(args->new_inode))) {",
          "6500:   struct ocfs2_extent_list *el = &new_di->id2.i_list;",
          "6501:   le16_add_cpu(&el->l_count, -(inline_size /",
          "6502:      sizeof(struct ocfs2_extent_rec)));",
          "6503:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8965779d2c0e6ab246c82a405236b1fb2adae6b2",
      "candidate_info": {
        "commit_hash": "8965779d2c0e6ab246c82a405236b1fb2adae6b2",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8965779d2c0e6ab246c82a405236b1fb2adae6b2",
        "files": [
          "include/net/addrconf.h",
          "net/ipv6/addrconf.c",
          "net/ipv6/mcast.c"
        ],
        "message": "ipv6,mcast: always hold idev->lock before mca_lock\n\ndingtianhong reported the following deadlock detected by lockdep:\n\n ======================================================\n [ INFO: possible circular locking dependency detected ]\n 3.4.24.05-0.1-default #1 Not tainted\n -------------------------------------------------------\n ksoftirqd/0/3 is trying to acquire lock:\n  (&ndev->lock){+.+...}, at: [<ffffffff8147f804>] ipv6_get_lladdr+0x74/0x120\n\n but task is already holding lock:\n  (&mc->mca_lock){+.+...}, at: [<ffffffff8149d130>] mld_send_report+0x40/0x150\n\n which lock already depends on the new lock.\n\n the existing dependency chain (in reverse order) is:\n\n -> #1 (&mc->mca_lock){+.+...}:\n        [<ffffffff810a8027>] validate_chain+0x637/0x730\n        [<ffffffff810a8417>] __lock_acquire+0x2f7/0x500\n        [<ffffffff810a8734>] lock_acquire+0x114/0x150\n        [<ffffffff814f691a>] rt_spin_lock+0x4a/0x60\n        [<ffffffff8149e4bb>] igmp6_group_added+0x3b/0x120\n        [<ffffffff8149e5d8>] ipv6_mc_up+0x38/0x60\n        [<ffffffff81480a4d>] ipv6_find_idev+0x3d/0x80\n        [<ffffffff81483175>] addrconf_notify+0x3d5/0x4b0\n        [<ffffffff814fae3f>] notifier_call_chain+0x3f/0x80\n        [<ffffffff81073471>] raw_notifier_call_chain+0x11/0x20\n        [<ffffffff813d8722>] call_netdevice_notifiers+0x32/0x60\n        [<ffffffff813d92d4>] __dev_notify_flags+0x34/0x80\n        [<ffffffff813d9360>] dev_change_flags+0x40/0x70\n        [<ffffffff813ea627>] do_setlink+0x237/0x8a0\n        [<ffffffff813ebb6c>] rtnl_newlink+0x3ec/0x600\n        [<ffffffff813eb4d0>] rtnetlink_rcv_msg+0x160/0x310\n        [<ffffffff814040b9>] netlink_rcv_skb+0x89/0xb0\n        [<ffffffff813eb357>] rtnetlink_rcv+0x27/0x40\n        [<ffffffff81403e20>] netlink_unicast+0x140/0x180\n        [<ffffffff81404a9e>] netlink_sendmsg+0x33e/0x380\n        [<ffffffff813c4252>] sock_sendmsg+0x112/0x130\n        [<ffffffff813c537e>] __sys_sendmsg+0x44e/0x460\n        [<ffffffff813c5544>] sys_sendmsg+0x44/0x70\n        [<ffffffff814feab9>] system_call_fastpath+0x16/0x1b\n\n -> #0 (&ndev->lock){+.+...}:\n        [<ffffffff810a798e>] check_prev_add+0x3de/0x440\n        [<ffffffff810a8027>] validate_chain+0x637/0x730\n        [<ffffffff810a8417>] __lock_acquire+0x2f7/0x500\n        [<ffffffff810a8734>] lock_acquire+0x114/0x150\n        [<ffffffff814f6c82>] rt_read_lock+0x42/0x60\n        [<ffffffff8147f804>] ipv6_get_lladdr+0x74/0x120\n        [<ffffffff8149b036>] mld_newpack+0xb6/0x160\n        [<ffffffff8149b18b>] add_grhead+0xab/0xc0\n        [<ffffffff8149d03b>] add_grec+0x3ab/0x460\n        [<ffffffff8149d14a>] mld_send_report+0x5a/0x150\n        [<ffffffff8149f99e>] igmp6_timer_handler+0x4e/0xb0\n        [<ffffffff8105705a>] call_timer_fn+0xca/0x1d0\n        [<ffffffff81057b9f>] run_timer_softirq+0x1df/0x2e0\n        [<ffffffff8104e8c7>] handle_pending_softirqs+0xf7/0x1f0\n        [<ffffffff8104ea3b>] __do_softirq_common+0x7b/0xf0\n        [<ffffffff8104f07f>] __thread_do_softirq+0x1af/0x210\n        [<ffffffff8104f1c1>] run_ksoftirqd+0xe1/0x1f0\n        [<ffffffff8106c7de>] kthread+0xae/0xc0\n        [<ffffffff814fff74>] kernel_thread_helper+0x4/0x10\n\nactually we can just hold idev->lock before taking pmc->mca_lock,\nand avoid taking idev->lock again when iterating idev->addr_list,\nsince the upper callers of mld_newpack() already take\nread_lock_bh(&idev->lock).\n\nReported-by: dingtianhong <dingtianhong@huawei.com>\nCc: dingtianhong <dingtianhong@huawei.com>\nCc: Hideaki YOSHIFUJI <yoshfuji@linux-ipv6.org>\nCc: David S. Miller <davem@davemloft.net>\nCc: Hannes Frederic Sowa <hannes@stressinduktion.org>\nTested-by: Ding Tianhong <dingtianhong@huawei.com>\nTested-by: Chen Weilong <chenweilong@huawei.com>\nSigned-off-by: Cong Wang <amwang@redhat.com>\nAcked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/net/addrconf.h||include/net/addrconf.h",
          "net/ipv6/addrconf.c||net/ipv6/addrconf.c",
          "net/ipv6/mcast.c||net/ipv6/mcast.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/net/addrconf.h||include/net/addrconf.h": [
          "File: include/net/addrconf.h -> include/net/addrconf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "86:             const struct in6_addr *daddr,",
          "87:             unsigned int srcprefs,",
          "88:             struct in6_addr *saddr);",
          "89: extern int   ipv6_get_lladdr(struct net_device *dev,",
          "90:       struct in6_addr *addr,",
          "91:       unsigned char banned_flags);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "89: extern int   __ipv6_get_lladdr(struct inet6_dev *idev,",
          "90:         struct in6_addr *addr,",
          "91:         unsigned char banned_flags);",
          "",
          "---------------"
        ],
        "net/ipv6/addrconf.c||net/ipv6/addrconf.c": [
          "File: net/ipv6/addrconf.c -> net/ipv6/addrconf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1444: }",
          "1445: EXPORT_SYMBOL(ipv6_dev_get_saddr);",
          "1449: {",
          "1450:  struct inet6_ifaddr *ifp;",
          "1451:  int err = -EADDRNOTAVAIL;",
          "",
          "[Removed Lines]",
          "1447: static int __ipv6_get_lladdr(struct inet6_dev *idev, struct in6_addr *addr,",
          "1448:         unsigned char banned_flags)",
          "",
          "[Added Lines]",
          "1447: int __ipv6_get_lladdr(struct inet6_dev *idev, struct in6_addr *addr,",
          "1448:         unsigned char banned_flags)",
          "",
          "---------------"
        ],
        "net/ipv6/mcast.c||net/ipv6/mcast.c": [
          "File: net/ipv6/mcast.c -> net/ipv6/mcast.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1351:  hdr->daddr = *daddr;",
          "1352: }",
          "1355: {",
          "1356:  struct net *net = dev_net(dev);",
          "1357:  struct sock *sk = net->ipv6.igmp_sk;",
          "1358:  struct sk_buff *skb;",
          "",
          "[Removed Lines]",
          "1354: static struct sk_buff *mld_newpack(struct net_device *dev, int size)",
          "",
          "[Added Lines]",
          "1354: static struct sk_buff *mld_newpack(struct inet6_dev *idev, int size)",
          "1356:  struct net_device *dev = idev->dev;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1378:  skb_reserve(skb, hlen);",
          "",
          "[Removed Lines]",
          "1380:  if (ipv6_get_lladdr(dev, &addr_buf, IFA_F_TENTATIVE)) {",
          "",
          "[Added Lines]",
          "1381:  if (__ipv6_get_lladdr(idev, &addr_buf, IFA_F_TENTATIVE)) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1474:  struct mld2_grec *pgr;",
          "1476:  if (!skb)",
          "1478:  if (!skb)",
          "1479:   return NULL;",
          "1480:  pgr = (struct mld2_grec *)skb_put(skb, sizeof(struct mld2_grec));",
          "",
          "[Removed Lines]",
          "1477:   skb = mld_newpack(dev, dev->mtu);",
          "",
          "[Added Lines]",
          "1478:   skb = mld_newpack(pmc->idev, dev->mtu);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1494: static struct sk_buff *add_grec(struct sk_buff *skb, struct ifmcaddr6 *pmc,",
          "1495:  int type, int gdeleted, int sdeleted)",
          "1496: {",
          "1498:  struct mld2_report *pmr;",
          "1499:  struct mld2_grec *pgr = NULL;",
          "1500:  struct ip6_sf_list *psf, *psf_next, *psf_prev, **psf_list;",
          "",
          "[Removed Lines]",
          "1497:  struct net_device *dev = pmc->idev->dev;",
          "",
          "[Added Lines]",
          "1498:  struct inet6_dev *idev = pmc->idev;",
          "1499:  struct net_device *dev = idev->dev;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1523:       AVAILABLE(skb) < grec_size(pmc, type, gdeleted, sdeleted)) {",
          "1524:    if (skb)",
          "1525:     mld_sendpack(skb);",
          "1527:   }",
          "1528:  }",
          "1529:  first = 1;",
          "",
          "[Removed Lines]",
          "1526:    skb = mld_newpack(dev, dev->mtu);",
          "",
          "[Added Lines]",
          "1528:    skb = mld_newpack(idev, dev->mtu);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1550:     pgr->grec_nsrcs = htons(scount);",
          "1551:    if (skb)",
          "1552:     mld_sendpack(skb);",
          "1554:    first = 1;",
          "1555:    scount = 0;",
          "1556:   }",
          "",
          "[Removed Lines]",
          "1553:    skb = mld_newpack(dev, dev->mtu);",
          "",
          "[Added Lines]",
          "1555:    skb = mld_newpack(idev, dev->mtu);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1605:  struct sk_buff *skb = NULL;",
          "1606:  int type;",
          "1608:  if (!pmc) {",
          "1610:   for (pmc=idev->mc_list; pmc; pmc=pmc->next) {",
          "1611:    if (pmc->mca_flags & MAF_NOREPORT)",
          "1612:     continue;",
          "",
          "[Removed Lines]",
          "1609:   read_lock_bh(&idev->lock);",
          "",
          "[Added Lines]",
          "1610:  read_lock_bh(&idev->lock);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1618:    skb = add_grec(skb, pmc, type, 0, 0);",
          "1619:    spin_unlock_bh(&pmc->mca_lock);",
          "1620:   }",
          "1622:  } else {",
          "1623:   spin_lock_bh(&pmc->mca_lock);",
          "1624:   if (pmc->mca_sfcount[MCAST_EXCLUDE])",
          "",
          "[Removed Lines]",
          "1621:   read_unlock_bh(&idev->lock);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1628:   skb = add_grec(skb, pmc, type, 0, 0);",
          "1629:   spin_unlock_bh(&pmc->mca_lock);",
          "1630:  }",
          "1631:  if (skb)",
          "1632:   mld_sendpack(skb);",
          "1633: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1632:  read_unlock_bh(&idev->lock);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
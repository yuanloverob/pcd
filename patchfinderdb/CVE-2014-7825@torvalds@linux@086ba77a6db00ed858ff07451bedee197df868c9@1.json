{
  "cve_id": "CVE-2014-7825",
  "cve_desc": "kernel/trace/trace_syscalls.c in the Linux kernel through 3.17.2 does not properly handle private syscall numbers during use of the perf subsystem, which allows local users to cause a denial of service (out-of-bounds read and OOPS) or bypass the ASLR protection mechanism via a crafted application.",
  "repo": "torvalds/linux",
  "patch_hash": "086ba77a6db00ed858ff07451bedee197df868c9",
  "patch_info": {
    "commit_hash": "086ba77a6db00ed858ff07451bedee197df868c9",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/086ba77a6db00ed858ff07451bedee197df868c9",
    "files": [
      "kernel/trace/trace_syscalls.c"
    ],
    "message": "tracing/syscalls: Ignore numbers outside NR_syscalls' range\n\nARM has some private syscalls (for example, set_tls(2)) which lie\noutside the range of NR_syscalls.  If any of these are called while\nsyscall tracing is being performed, out-of-bounds array access will\noccur in the ftrace and perf sys_{enter,exit} handlers.\n\n # trace-cmd record -e raw_syscalls:* true && trace-cmd report\n ...\n true-653   [000]   384.675777: sys_enter:            NR 192 (0, 1000, 3, 4000022, ffffffff, 0)\n true-653   [000]   384.675812: sys_exit:             NR 192 = 1995915264\n true-653   [000]   384.675971: sys_enter:            NR 983045 (76f74480, 76f74000, 76f74b28, 76f74480, 76f76f74, 1)\n true-653   [000]   384.675988: sys_exit:             NR 983045 = 0\n ...\n\n # trace-cmd record -e syscalls:* true\n [   17.289329] Unable to handle kernel paging request at virtual address aaaaaace\n [   17.289590] pgd = 9e71c000\n [   17.289696] [aaaaaace] *pgd=00000000\n [   17.289985] Internal error: Oops: 5 [#1] PREEMPT SMP ARM\n [   17.290169] Modules linked in:\n [   17.290391] CPU: 0 PID: 704 Comm: true Not tainted 3.18.0-rc2+ #21\n [   17.290585] task: 9f4dab00 ti: 9e710000 task.ti: 9e710000\n [   17.290747] PC is at ftrace_syscall_enter+0x48/0x1f8\n [   17.290866] LR is at syscall_trace_enter+0x124/0x184\n\nFix this by ignoring out-of-NR_syscalls-bounds syscall numbers.\n\nCommit cd0980fc8add \"tracing: Check invalid syscall nr while tracing syscalls\"\nadded the check for less than zero, but it should have also checked\nfor greater than NR_syscalls.\n\nLink: http://lkml.kernel.org/p/1414620418-29472-1-git-send-email-rabin@rab.in\n\nFixes: cd0980fc8add \"tracing: Check invalid syscall nr while tracing syscalls\"\nCc: stable@vger.kernel.org # 2.6.33+\nSigned-off-by: Rabin Vincent <rabin@rab.in>\nSigned-off-by: Steven Rostedt <rostedt@goodmis.org>",
    "before_after_code_files": [
      "kernel/trace/trace_syscalls.c||kernel/trace/trace_syscalls.c"
    ]
  },
  "patch_diff": {
    "kernel/trace/trace_syscalls.c||kernel/trace/trace_syscalls.c": [
      "File: kernel/trace/trace_syscalls.c -> kernel/trace/trace_syscalls.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "313:  int size;",
      "315:  syscall_nr = trace_get_syscall_nr(current, regs);",
      "317:   return;",
      "",
      "[Removed Lines]",
      "316:  if (syscall_nr < 0)",
      "",
      "[Added Lines]",
      "316:  if (syscall_nr < 0 || syscall_nr >= NR_syscalls)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "360:  int syscall_nr;",
      "362:  syscall_nr = trace_get_syscall_nr(current, regs);",
      "364:   return;",
      "",
      "[Removed Lines]",
      "363:  if (syscall_nr < 0)",
      "",
      "[Added Lines]",
      "363:  if (syscall_nr < 0 || syscall_nr >= NR_syscalls)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "567:  int size;",
      "569:  syscall_nr = trace_get_syscall_nr(current, regs);",
      "571:   return;",
      "572:  if (!test_bit(syscall_nr, enabled_perf_enter_syscalls))",
      "573:   return;",
      "",
      "[Removed Lines]",
      "570:  if (syscall_nr < 0)",
      "",
      "[Added Lines]",
      "570:  if (syscall_nr < 0 || syscall_nr >= NR_syscalls)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "641:  int size;",
      "643:  syscall_nr = trace_get_syscall_nr(current, regs);",
      "645:   return;",
      "646:  if (!test_bit(syscall_nr, enabled_perf_exit_syscalls))",
      "647:   return;",
      "",
      "[Removed Lines]",
      "644:  if (syscall_nr < 0)",
      "",
      "[Added Lines]",
      "644:  if (syscall_nr < 0 || syscall_nr >= NR_syscalls)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "37fa8716e2d4c4155205aa4a904835de09edbb88",
      "candidate_info": {
        "commit_hash": "37fa8716e2d4c4155205aa4a904835de09edbb88",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/37fa8716e2d4c4155205aa4a904835de09edbb88",
        "files": [
          "drivers/media/rc/rc-main.c"
        ],
        "message": "[media] rc-main: fix lockdep splash for rc-main\n\nlockdep reports a potential circular dependecy deadlock when registering input device.\n\nUnlock mutex rc_dev->lock prior to calling ir_raw_event_register to avoid the circular\ndependency since that function also calls input_register_device and rc_open.\n\n ======================================================\n [ INFO: possible circular locking dependency detected ]\n 3.17.0-rc7+ #24 Not tainted\n -------------------------------------------------------\n modprobe/647 is trying to acquire lock:\n  (input_mutex){+.+.+.}, at: [<ffffffff812ed81c>] input_register_device+0x2ba/0x381\n\n but task is already holding lock:\n  (ir_raw_handler_lock){+.+.+.}, at: [<ffffffff813186ed>] ir_raw_event_register+0x102/0x190\n\n which lock already depends on the new lock.\n\n[cut text]\n\n other info that might help us debug this:\n\n Chain exists of:\n   input_mutex --> &dev->lock --> ir_raw_handler_lock\n\n  Possible unsafe locking scenario:\n\n        CPU0                    CPU1\n        ----                    ----\n   lock(ir_raw_handler_lock);\n                                lock(&dev->lock);\n                                lock(ir_raw_handler_lock);\n   lock(input_mutex);\n\n  *** DEADLOCK ***\n\n 4 locks held by modprobe/647:\n  #0:  (&dev->mutex){......}, at: [<ffffffff812d19f3>] device_lock+0xf/0x11\n  #1:  (&dev->mutex){......}, at: [<ffffffff812d19f3>] device_lock+0xf/0x11\n  #2:  (&dev->lock){+.+.+.}, at: [<ffffffff81317fff>] rc_register_device+0x55d/0x58a\n  #3:  (ir_raw_handler_lock){+.+.+.}, at: [<ffffffff813186ed>] ir_raw_event_register+0x102/0x190\n\n stack backtrace:\n CPU: 0 PID: 647 Comm: modprobe Not tainted 3.17.0-rc7+ #24\n\n Call Trace:\n  [<ffffffff81489d6a>] dump_stack+0x46/0x58\n  [<ffffffff81487699>] print_circular_bug+0x1f8/0x209\n  [<ffffffff81074353>] __lock_acquire+0xb54/0xeda\n  [<ffffffff81080f17>] ? console_unlock+0x34d/0x399\n  [<ffffffff81074c01>] lock_acquire+0xd9/0x111\n  [<ffffffff812ed81c>] ? input_register_device+0x2ba/0x381\n  [<ffffffff8148e650>] mutex_lock_interruptible_nested+0x57/0x381\n  [<ffffffff812ed81c>] ? input_register_device+0x2ba/0x381\n  [<ffffffff81124e03>] ? kfree+0x7c/0x96\n  [<ffffffff812ed81c>] ? input_register_device+0x2ba/0x381\n  [<ffffffff81072531>] ? trace_hardirqs_on+0xd/0xf\n  [<ffffffff812ed81c>] input_register_device+0x2ba/0x381\n  [<ffffffff8131a537>] ir_mce_kbd_register+0x109/0x139\n  [<ffffffff81318728>] ir_raw_event_register+0x13d/0x190\n  [<ffffffff81317e40>] rc_register_device+0x39e/0x58a\n  [<ffffffff81072531>] ? trace_hardirqs_on+0xd/0xf\n  [<ffffffffa00cf2e3>] nvt_probe+0x5ad/0xd52 [nuvoton_cir]\n  [<ffffffffa00ced36>] ? nvt_resume+0x80/0x80 [nuvoton_cir]\n  [<ffffffff81296003>] pnp_device_probe+0x8c/0xa9\n  [<ffffffff812d1b94>] ? driver_sysfs_add+0x6e/0x93\n  [<ffffffff812d203a>] driver_probe_device+0xa1/0x1e3\n  [<ffffffff812d217c>] ? driver_probe_device+0x1e3/0x1e3\n  [<ffffffff812d21ca>] __driver_attach+0x4e/0x6f\n  [<ffffffff812d075b>] bus_for_each_dev+0x5a/0x8c\n  [<ffffffff812d1b24>] driver_attach+0x19/0x1b\n  [<ffffffff812d1879>] bus_add_driver+0xf1/0x1d6\n  [<ffffffff812d2817>] driver_register+0x87/0xbe\n  [<ffffffffa0120000>] ? 0xffffffffa0120000\n  [<ffffffff81295da4>] pnp_register_driver+0x1c/0x1e\n  [<ffffffffa0120010>] nvt_init+0x10/0x1000 [nuvoton_cir]\n  [<ffffffff8100030e>] do_one_initcall+0xea/0x18c\n  [<ffffffff8111497f>] ? __vunmap+0x9d/0xc7\n  [<ffffffff810a3ca1>] load_module+0x1c21/0x1f2c\n  [<ffffffff810a0bce>] ? show_initstate+0x44/0x44\n  [<ffffffff810a404e>] SyS_init_module+0xa2/0xb1\n  [<ffffffff81490ed2>] system_call_fastpath+0x16/0x1b\n\nSigned-off-by: Tomas Melin <tomas.melin@iki.fi>\nSigned-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>",
        "before_after_code_files": [
          "drivers/medirc/rc-main.c||drivers/media/rc/rc-main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/medirc/rc-main.c||drivers/media/rc/rc-main.c": [
          "File: drivers/medirc/rc-main.c -> drivers/media/rc/rc-main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1418:   mutex_unlock(&dev->lock);",
          "1420:   mutex_lock(&dev->lock);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2279948735609d0d17d7384e776b674619f792ef",
      "candidate_info": {
        "commit_hash": "2279948735609d0d17d7384e776b674619f792ef",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2279948735609d0d17d7384e776b674619f792ef",
        "files": [
          "drivers/media/usb/dvb-usb/af9005.c"
        ],
        "message": "[media] af9005: fix kernel panic on init if compiled without IR\n\nThis patches fixes an ancient bug in the dvb_usb_af9005 driver, which\nhas been reported at least in the following threads:\nhttps://lkml.org/lkml/2009/2/4/350\nhttps://lkml.org/lkml/2014/9/18/558\n\nIf the driver is compiled in without any IR support (neither\nDVB_USB_AF9005_REMOTE nor custom symbols), the symbol_request calls in\naf9005_usb_module_init() return pointers != NULL although the IR\nsymbols are not available.\n\nThis leads to the following oops:\n...\n[    8.529751] usbcore: registered new interface driver dvb_usb_af9005\n[    8.531584] BUG: unable to handle kernel paging request at 02e00000\n[    8.533385] IP: [<7d9d67c6>] af9005_usb_module_init+0x6b/0x9d\n[    8.535613] *pde = 00000000\n[    8.536416] Oops: 0000 [#1] PREEMPT PREEMPT DEBUG_PAGEALLOCDEBUG_PAGEALLOC\n[    8.537863] CPU: 0 PID: 1 Comm: swapper Not tainted 3.15.0-rc6-00151-ga5c075c #1\n[    8.539827] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.7.5-20140531_083030-gandalf 04/01/2014\n[    8.541519] task: 89c9a670 ti: 89c9c000 task.ti: 89c9c000\n[    8.541519] EIP: 0060:[<7d9d67c6>] EFLAGS: 00010206 CPU: 0\n[    8.541519] EIP is at af9005_usb_module_init+0x6b/0x9d\n[    8.541519] EAX: 02e00000 EBX: 00000000 ECX: 00000006 EDX: 00000000\n[    8.541519] ESI: 00000000 EDI: 7da33ec8 EBP: 89c9df30 ESP: 89c9df2c\n[    8.541519]  DS: 007b ES: 007b FS: 0000 GS: 00e0 SS: 0068\n[    8.541519] CR0: 8005003b CR2: 02e00000 CR3: 05a54000 CR4: 00000690\n[    8.541519] Stack:\n[    8.541519]  7d9d675b 89c9df90 7d992a49 7d7d5914 89c9df4c 7be3a800 7d08c58c 8a4c3968\n[    8.541519]  89c9df80 7be3a966 00000192 00000006 00000006 7d7d3ff4 8a4c397a 00000200\n[    8.541519]  7d6b1280 8a4c3979 00000006 000009a6 7da32db8 b13eec81 00000006 000009a6\n[    8.541519] Call Trace:\n[    8.541519]  [<7d9d675b>] ? ttusb2_driver_init+0x16/0x16\n[    8.541519]  [<7d992a49>] do_one_initcall+0x77/0x106\n[    8.541519]  [<7be3a800>] ? parameqn+0x2/0x35\n[    8.541519]  [<7be3a966>] ? parse_args+0x113/0x25c\n[    8.541519]  [<7d992bc2>] kernel_init_freeable+0xea/0x167\n[    8.541519]  [<7cf01070>] kernel_init+0x8/0xb8\n[    8.541519]  [<7cf27ec0>] ret_from_kernel_thread+0x20/0x30\n[    8.541519]  [<7cf01068>] ? rest_init+0x10c/0x10c\n[    8.541519] Code: 08 c2 c7 05 44 ed f9 7d 00 00 e0 02 c7 05 40 ed f9 7d 00 00 e0 02 c7 05 3c ed f9 7d 00 00 e0 02 75 1f b8 00 00 e0 02 85 c0 74 16 <a1> 00 00 e0 02 c7 05 54 84 8e 7d 00 00 e0 02 a3 58 84 8e 7d eb\n[    8.541519] EIP: [<7d9d67c6>] af9005_usb_module_init+0x6b/0x9d SS:ESP 0068:89c9df2c\n[    8.541519] CR2: 0000000002e00000\n[    8.541519] ---[ end trace 768b6faf51370fc7 ]---\n\nThe prefered fix would be to convert the whole IR code to use the kernel IR\ninfrastructure (which wasn't available at the time this driver had been created).\n\nUntil anyone who still has this old hardware steps up an does the conversion,\nfix it by not calling the symbol_request calls if the driver is compiled in\nwithout the default IR symbols (CONFIG_DVB_USB_AF9005_REMOTE).\nDue to the IR related pointers beeing NULL by default, IR support will then be disabled.\n\nThe downside of this solution is, that it will no longer be possible to\ncompile custom IR symbols (not using CONFIG_DVB_USB_AF9005_REMOTE) in.\n\nPlease note that this patch has NOT been tested with all possible cases.\nI don't have the hardware and could only verify that it fixes the reported\nbug.\n\nReported-by: Fengguag Wu <fengguang.wu@intel.com>\nSigned-off-by: Frank Sch\u00e4fer <fschaefer.oss@googlemail.com>\nCc: <stable@vger.kernel.org>\nAcked-by: Luca Olivetti <luca@ventoso.org>\nSigned-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>",
        "before_after_code_files": [
          "drivers/mediusb/dvb-usb/af9005.c||drivers/media/usdvb-usaf9005.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/mediusb/dvb-usb/af9005.c||drivers/media/usdvb-usaf9005.c": [
          "File: drivers/mediusb/dvb-usb/af9005.c -> drivers/media/usdvb-usaf9005.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4eb2e164872a086f42fb9fe5dfe93856ad740932",
      "candidate_info": {
        "commit_hash": "4eb2e164872a086f42fb9fe5dfe93856ad740932",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4eb2e164872a086f42fb9fe5dfe93856ad740932",
        "files": [
          "drivers/net/wireless/ath/ath10k/mac.c"
        ],
        "message": "ath10k: avoid possible deadlock with scan timeout\n\nThis should prevent deadlock predicted by the\nfollowing splat:\n\n ======================================================\n [ INFO: possible circular locking dependency detected ]\n 3.17.0-wl-ath+ #67 Not tainted\n -------------------------------------------------------\n kworker/u32:1/7230 is trying to acquire lock:\n  (&ar->conf_mutex){+.+.+.}, at: [<ffffffffa040a57d>] ath10k_scan_timeout_work+0x2d/0x50 [ath10k_core]\n\n but task is already holding lock:\n  ((&(&ar->scan.timeout)->work)){+.+...}, at: [<ffffffff8106dae1>] process_one_work+0x151/0x470\n\n which lock already depends on the new lock.\n\n the existing dependency chain (in reverse order) is:\n\n -> #1 ((&(&ar->scan.timeout)->work)){+.+...}:\n        [<ffffffff810a12e5>] lock_acquire+0x85/0x100\n        [<ffffffff8106cb4d>] flush_work+0x3d/0x270\n        [<ffffffff8106e49d>] __cancel_work_timer+0x7d/0x110\n        [<ffffffff8106e543>] cancel_delayed_work_sync+0x13/0x20\n        [<ffffffffa0409f16>] ath10k_cancel_remain_on_channel+0x36/0x60 [ath10k_core]\n        [<ffffffffa028c75c>] ieee80211_cancel_roc+0x1cc/0x2f0 [mac80211]\n        [<ffffffffa028c8a2>] ieee80211_mgmt_tx_cancel_wait+0x22/0x30 [mac80211]\n        [<ffffffffa0132288>] nl80211_tx_mgmt_cancel_wait+0xa8/0x130 [cfg80211]\n        [<ffffffff816654a5>] genl_family_rcv_msg+0x1a5/0x3c0\n        [<ffffffff81665749>] genl_rcv_msg+0x89/0xc0\n        [<ffffffff81664e91>] netlink_rcv_skb+0xb1/0xc0\n        [<ffffffff816650bc>] genl_rcv+0x2c/0x40\n        [<ffffffff8166474d>] netlink_unicast+0x18d/0x200\n        [<ffffffff81664add>] netlink_sendmsg+0x31d/0x430\n        [<ffffffff8161a9ac>] sock_sendmsg+0x9c/0xd0\n        [<ffffffff8161b469>] ___sys_sendmsg+0x389/0x3a0\n        [<ffffffff8161bed9>] __sys_sendmsg+0x49/0x90\n        [<ffffffff8161bf32>] SyS_sendmsg+0x12/0x20\n        [<ffffffff8174c456>] system_call_fastpath+0x1a/0x1f\n\n -> #0 (&ar->conf_mutex){+.+.+.}:\n        [<ffffffff810a0bde>] __lock_acquire+0x1b6e/0x1ce0\n        [<ffffffff810a12e5>] lock_acquire+0x85/0x100\n        [<ffffffff817491eb>] mutex_lock_nested+0x4b/0x370\n        [<ffffffffa040a57d>] ath10k_scan_timeout_work+0x2d/0x50 [ath10k_core]\n        [<ffffffff8106db41>] process_one_work+0x1b1/0x470\n        [<ffffffff8106df63>] worker_thread+0x123/0x460\n        [<ffffffff81073f34>] kthread+0xe4/0x100\n        [<ffffffff8174c3ac>] ret_from_fork+0x7c/0xb0\n\n other info that might help us debug this:\n\n  Possible unsafe locking scenario:\n\n        CPU0                    CPU1\n        ----                    ----\n   lock((&(&ar->scan.timeout)->work));\n                                lock(&ar->conf_mutex);\n                                lock((&(&ar->scan.timeout)->work));\n   lock(&ar->conf_mutex);\n\n  *** DEADLOCK ***\n\nReported-by: Marek Puzyniak <marek.puzyniak@tieto.com>\nSigned-off-by: Michal Kazior <michal.kazior@tieto.com>\nSigned-off-by: Kalle Valo <kvalo@qca.qualcomm.com>",
        "before_after_code_files": [
          "drivers/net/wireless/ath/ath10k/mac.c||drivers/net/wireless/ath/ath10k/mac.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/wireless/ath/ath10k/mac.c||drivers/net/wireless/ath/ath10k/mac.c": [
          "File: drivers/net/wireless/ath/ath10k/mac.c -> drivers/net/wireless/ath/ath10k/mac.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3307:  struct ath10k *ar = hw->priv;",
          "3309:  mutex_lock(&ar->conf_mutex);",
          "3311:  ath10k_scan_abort(ar);",
          "3312:  mutex_unlock(&ar->conf_mutex);",
          "3313: }",
          "3315: static void ath10k_set_key_h_def_keyidx(struct ath10k *ar,",
          "",
          "[Removed Lines]",
          "3310:  cancel_delayed_work_sync(&ar->scan.timeout);",
          "",
          "[Added Lines]",
          "3313:  cancel_delayed_work_sync(&ar->scan.timeout);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3826:  struct ath10k *ar = hw->priv;",
          "3828:  mutex_lock(&ar->conf_mutex);",
          "3830:  ath10k_scan_abort(ar);",
          "3831:  mutex_unlock(&ar->conf_mutex);",
          "3833:  return 0;",
          "3834: }",
          "",
          "[Removed Lines]",
          "3829:  cancel_delayed_work_sync(&ar->scan.timeout);",
          "",
          "[Added Lines]",
          "3833:  cancel_delayed_work_sync(&ar->scan.timeout);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7da89a2a3776442a57e918ca0b8678d1b16a7072",
      "candidate_info": {
        "commit_hash": "7da89a2a3776442a57e918ca0b8678d1b16a7072",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7da89a2a3776442a57e918ca0b8678d1b16a7072",
        "files": [
          "arch/sparc/kernel/pci_schizo.c"
        ],
        "message": "sparc64: Fix crashes in schizo_pcierr_intr_other().\n\nMeelis Roos reports crashes during bootup on a V480 that look like\nthis:\n\n====================\n[   61.300577] PCI: Scanning PBM /pci@9,600000\n[   61.304867] schizo f009b070: PCI host bridge to bus 0003:00\n[   61.310385] pci_bus 0003:00: root bus resource [io  0x7ffe9000000-0x7ffe9ffffff] (bus address [0x0000-0xffffff])\n[   61.320515] pci_bus 0003:00: root bus resource [mem 0x7fb00000000-0x7fbffffffff] (bus address [0x00000000-0xffffffff])\n[   61.331173] pci_bus 0003:00: root bus resource [bus 00]\n[   61.385344] Unable to handle kernel NULL pointer dereference\n[   61.390970] tsk->{mm,active_mm}->context = 0000000000000000\n[   61.396515] tsk->{mm,active_mm}->pgd = fff000b000002000\n[   61.401716]               \\|/ ____ \\|/\n[   61.401716]               \"@'/ .. \\`@\"\n[   61.401716]               /_| \\__/ |_\\\n[   61.401716]                  \\__U_/\n[   61.416362] swapper/0(0): Oops [#1]\n[   61.419837] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 3.18.0-rc1-00422-g2cc9188-dirty #24\n[   61.427975] task: fff000b0fd8e9c40 ti: fff000b0fd928000 task.ti: fff000b0fd928000\n[   61.435426] TSTATE: 0000004480e01602 TPC: 00000000004455e4 TNPC: 00000000004455e8 Y: 00000000    Not tainted\n[   61.445230] TPC: <schizo_pcierr_intr+0x104/0x560>\n[   61.449897] g0: 0000000000000000 g1: 0000000000000000 g2: 0000000000a10f78 g3: 000000000000000a\n[   61.458563] g4: fff000b0fd8e9c40 g5: fff000b0fdd82000 g6: fff000b0fd928000 g7: 000000000000000a\n[   61.467229] o0: 000000000000003d o1: 0000000000000000 o2: 0000000000000006 o3: fff000b0ffa5fc7e\n[   61.475894] o4: 0000000000060000 o5: c000000000000000 sp: fff000b0ffa5f3c1 ret_pc: 00000000004455cc\n[   61.484909] RPC: <schizo_pcierr_intr+0xec/0x560>\n[   61.489500] l0: fff000b0fd8e9c40 l1: 0000000000a20800 l2: 0000000000000000 l3: 000000000119a430\n[   61.498164] l4: 0000000001742400 l5: 00000000011cfbe0 l6: 00000000011319c0 l7: fff000b0fd8ea348\n[   61.506830] i0: 0000000000000000 i1: fff000b0fdb34000 i2: 0000000320000000 i3: 0000000000000000\n[   61.515497] i4: 00060002010b003f i5: 0000040004e02000 i6: fff000b0ffa5f481 i7: 00000000004a9920\n[   61.524175] I7: <handle_irq_event_percpu+0x40/0x140>\n[   61.529099] Call Trace:\n[   61.531531]  [00000000004a9920] handle_irq_event_percpu+0x40/0x140\n[   61.537681]  [00000000004a9a58] handle_irq_event+0x38/0x80\n[   61.543145]  [00000000004ac77c] handle_fasteoi_irq+0xbc/0x200\n[   61.548860]  [00000000004a9084] generic_handle_irq+0x24/0x40\n[   61.554500]  [000000000042be0c] handler_irq+0xac/0x100\n====================\n\nThe problem is that pbm->pci_bus->self is NULL.\n\nThis code is trying to go through the standard PCI config space\ninterfaces to read the PCI controller's PCI_STATUS register.\n\nThis doesn't work, because we more often than not do not enumerate\nthe PCI controller as a bonafide PCI device during the OF device\nnode scan.  Therefore bus->self remains NULL.\n\nExisting common code for PSYCHO and PSYCHO-like PCI controllers\nhandles this properly, by doing the config space access directly.\n\nDo the same here, pbm->pci_ops->{read,write}().\n\nReported-by: Meelis Roos <mroos@linux.ee>\nTested-by: Meelis Roos <mroos@linux.ee>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "arch/sparc/kernel/pci_schizo.c||arch/sparc/kernel/pci_schizo.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/sparc/kernel/pci_schizo.c||arch/sparc/kernel/pci_schizo.c": [
          "File: arch/sparc/kernel/pci_schizo.c -> arch/sparc/kernel/pci_schizo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "581: {",
          "582:  unsigned long csr_reg, csr, csr_error_bits;",
          "583:  irqreturn_t ret = IRQ_NONE;",
          "586:  csr_reg = pbm->pbm_regs + SCHIZO_PCI_CTRL;",
          "587:  csr = upa_readq(csr_reg);",
          "",
          "[Removed Lines]",
          "584:  u16 stat;",
          "",
          "[Added Lines]",
          "584:  u32 stat;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "617:           pbm->name);",
          "618:   ret = IRQ_HANDLED;",
          "619:  }",
          "621:  if (stat & (PCI_STATUS_PARITY |",
          "622:       PCI_STATUS_SIG_TARGET_ABORT |",
          "623:       PCI_STATUS_REC_TARGET_ABORT |",
          "",
          "[Removed Lines]",
          "620:  pci_read_config_word(pbm->pci_bus->self, PCI_STATUS, &stat);",
          "",
          "[Added Lines]",
          "620:  pbm->pci_ops->read(pbm->pci_bus, 0, PCI_STATUS, 2, &stat);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "625:       PCI_STATUS_SIG_SYSTEM_ERROR)) {",
          "626:   printk(\"%s: PCI bus error, PCI_STATUS[%04x]\\n\",",
          "627:          pbm->name, stat);",
          "629:   ret = IRQ_HANDLED;",
          "630:  }",
          "631:  return ret;",
          "",
          "[Removed Lines]",
          "628:   pci_write_config_word(pbm->pci_bus->self, PCI_STATUS, 0xffff);",
          "",
          "[Added Lines]",
          "628:   pbm->pci_ops->write(pbm->pci_bus, 0, PCI_STATUS, 2, 0xffff);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "408cddd96e3b155337f9e3aba2198e92e94c6068",
      "candidate_info": {
        "commit_hash": "408cddd96e3b155337f9e3aba2198e92e94c6068",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/408cddd96e3b155337f9e3aba2198e92e94c6068",
        "files": [
          "arch/powerpc/include/asm/fadump.h",
          "arch/powerpc/kernel/fadump.c",
          "arch/powerpc/platforms/pseries/lpar.c"
        ],
        "message": "powerpc/fadump: Fix endianess issues in firmware assisted dump handling\n\nFirmware-assisted dump (fadump) kernel code is not endian safe. The\nbelow patch fixes this issue. Tested this patch with upstream kernel.\nBelow output shows crash tool successfully opening LE fadump vmcore.\n\n    # crash vmlinux vmcore\n    GNU gdb (GDB) 7.6\n    This GDB was configured as \"powerpc64le-unknown-linux-gnu\"...\n\n          KERNEL: vmlinux\n        DUMPFILE: vmcore\n    \tCPUS: 16\n    \tDATE: Wed Dec 31 19:00:00 1969\n          UPTIME: 00:03:28\n    LOAD AVERAGE: 0.46, 0.86, 0.41\n           TASKS: 268\n        NODENAME: linux-dhr2\n         RELEASE: 3.17.0-rc5-7-default\n         VERSION: #6 SMP Tue Sep 30 01:06:34 EDT 2014\n         MACHINE: ppc64le  (4116 Mhz)\n          MEMORY: 40 GB\n           PANIC: \"Oops: Kernel access of bad area, sig: 11 [#1]\" (check log for details)\n    \t PID: 6223\n         COMMAND: \"bash\"\n    \tTASK: c0000009661b2500  [THREAD_INFO: c000000967ac0000]\n    \t CPU: 2\n           STATE: TASK_RUNNING (PANIC)\n\nSigned-off-by: Hari Bathini <hbathini@linux.vnet.ibm.com>\n[mpe: Make the comment in pSeries_lpar_hptab_clear() clearer]\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>",
        "before_after_code_files": [
          "arch/powerpc/include/asm/fadump.h||arch/powerpc/include/asm/fadump.h",
          "arch/powerpc/kernel/fadump.c||arch/powerpc/kernel/fadump.c",
          "arch/powerpc/platforms/pseries/lpar.c||arch/powerpc/platforms/pseries/lpar.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/powerpc/include/asm/fadump.h||arch/powerpc/include/asm/fadump.h": [
          "File: arch/powerpc/include/asm/fadump.h -> arch/powerpc/include/asm/fadump.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "70: #define CPU_UNKNOWN  (~((u32)0))",
          "78: })",
          "81: struct fadump_section {",
          "89: };",
          "92: struct fadump_section_header {",
          "106: };",
          "",
          "[Removed Lines]",
          "73: #define SKIP_TO_NEXT_CPU(reg_entry)   \\",
          "74: ({       \\",
          "75:  while (reg_entry->reg_id != REG_ID(\"CPUEND\")) \\",
          "76:   reg_entry++;    \\",
          "77:  reg_entry++;     \\",
          "82:  u32 request_flag;",
          "83:  u16 source_data_type;",
          "84:  u16 error_flags;",
          "85:  u64 source_address;",
          "86:  u64 source_len;",
          "87:  u64 bytes_dumped;",
          "88:  u64 destination_address;",
          "93:  u32 dump_format_version;",
          "94:  u16 dump_num_sections;",
          "95:  u16 dump_status_flag;",
          "96:  u32 offset_first_dump_section;",
          "99:  u32 dd_block_size;",
          "100:  u64 dd_block_offset;",
          "101:  u64 dd_num_blocks;",
          "102:  u32 dd_offset_disk_path;",
          "105:  u32 max_time_auto;",
          "",
          "[Added Lines]",
          "73: #define SKIP_TO_NEXT_CPU(reg_entry)     \\",
          "74: ({         \\",
          "75:  while (be64_to_cpu(reg_entry->reg_id) != REG_ID(\"CPUEND\")) \\",
          "76:   reg_entry++;      \\",
          "77:  reg_entry++;       \\",
          "82:  __be32 request_flag;",
          "83:  __be16 source_data_type;",
          "84:  __be16 error_flags;",
          "85:  __be64 source_address;",
          "86:  __be64 source_len;",
          "87:  __be64 bytes_dumped;",
          "88:  __be64 destination_address;",
          "93:  __be32 dump_format_version;",
          "94:  __be16 dump_num_sections;",
          "95:  __be16 dump_status_flag;",
          "96:  __be32 offset_first_dump_section;",
          "99:  __be32 dd_block_size;",
          "100:  __be64 dd_block_offset;",
          "101:  __be64 dd_num_blocks;",
          "102:  __be32 dd_offset_disk_path;",
          "105:  __be32 max_time_auto;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "176: struct fadump_reg_save_area_header {",
          "180: };",
          "183: struct fadump_reg_entry {",
          "186: };",
          "",
          "[Removed Lines]",
          "177:  u64  magic_number;",
          "178:  u32  version;",
          "179:  u32  num_cpu_offset;",
          "184:  u64  reg_id;",
          "185:  u64  reg_value;",
          "",
          "[Added Lines]",
          "177:  __be64  magic_number;",
          "178:  __be32  version;",
          "179:  __be32  num_cpu_offset;",
          "184:  __be64  reg_id;",
          "185:  __be64  reg_value;",
          "",
          "---------------"
        ],
        "arch/powerpc/kernel/fadump.c||arch/powerpc/kernel/fadump.c": [
          "File: arch/powerpc/kernel/fadump.c -> arch/powerpc/kernel/fadump.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "58:  const __be32 *sections;",
          "59:  int i, num_sections;",
          "60:  int size;",
          "63:  if (depth != 1 || strcmp(uname, \"rtas\") != 0)",
          "64:   return 0;",
          "",
          "[Removed Lines]",
          "61:  const int *token;",
          "",
          "[Added Lines]",
          "61:  const __be32 *token;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "72:   return 1;",
          "74:  fw_dump.fadump_supported = 1;",
          "",
          "[Removed Lines]",
          "75:  fw_dump.ibm_configure_kernel_dump = *token;",
          "",
          "[Added Lines]",
          "75:  fw_dump.ibm_configure_kernel_dump = be32_to_cpu(*token);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "147:  memset(fdm, 0, sizeof(struct fadump_mem_struct));",
          "148:  addr = addr & PAGE_MASK;",
          "152:  fdm->header.dump_status_flag = 0;",
          "153:  fdm->header.offset_first_dump_section =",
          "",
          "[Removed Lines]",
          "150:  fdm->header.dump_format_version = 0x00000001;",
          "151:  fdm->header.dump_num_sections = 3;",
          "154:   (u32)offsetof(struct fadump_mem_struct, cpu_state_data);",
          "",
          "[Added Lines]",
          "150:  fdm->header.dump_format_version = cpu_to_be32(0x00000001);",
          "151:  fdm->header.dump_num_sections = cpu_to_be16(3);",
          "154:   cpu_to_be32((u32)offsetof(struct fadump_mem_struct, cpu_state_data));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "172:  fdm->cpu_state_data.source_address = 0;",
          "175:  addr += fw_dump.cpu_state_data_size;",
          "180:  fdm->hpte_region.source_address = 0;",
          "183:  addr += fw_dump.hpte_region_size;",
          "191:  addr += fw_dump.boot_memory_size;",
          "193:  return addr;",
          "",
          "[Removed Lines]",
          "170:  fdm->cpu_state_data.request_flag = FADUMP_REQUEST_FLAG;",
          "171:  fdm->cpu_state_data.source_data_type = FADUMP_CPU_STATE_DATA;",
          "173:  fdm->cpu_state_data.source_len = fw_dump.cpu_state_data_size;",
          "174:  fdm->cpu_state_data.destination_address = addr;",
          "178:  fdm->hpte_region.request_flag = FADUMP_REQUEST_FLAG;",
          "179:  fdm->hpte_region.source_data_type = FADUMP_HPTE_REGION;",
          "181:  fdm->hpte_region.source_len = fw_dump.hpte_region_size;",
          "182:  fdm->hpte_region.destination_address = addr;",
          "186:  fdm->rmr_region.request_flag = FADUMP_REQUEST_FLAG;",
          "187:  fdm->rmr_region.source_data_type = FADUMP_REAL_MODE_REGION;",
          "188:  fdm->rmr_region.source_address = RMA_START;",
          "189:  fdm->rmr_region.source_len = fw_dump.boot_memory_size;",
          "190:  fdm->rmr_region.destination_address = addr;",
          "",
          "[Added Lines]",
          "170:  fdm->cpu_state_data.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);",
          "171:  fdm->cpu_state_data.source_data_type = cpu_to_be16(FADUMP_CPU_STATE_DATA);",
          "173:  fdm->cpu_state_data.source_len = cpu_to_be64(fw_dump.cpu_state_data_size);",
          "174:  fdm->cpu_state_data.destination_address = cpu_to_be64(addr);",
          "178:  fdm->hpte_region.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);",
          "179:  fdm->hpte_region.source_data_type = cpu_to_be16(FADUMP_HPTE_REGION);",
          "181:  fdm->hpte_region.source_len = cpu_to_be64(fw_dump.hpte_region_size);",
          "182:  fdm->hpte_region.destination_address = cpu_to_be64(addr);",
          "186:  fdm->rmr_region.request_flag = cpu_to_be32(FADUMP_REQUEST_FLAG);",
          "187:  fdm->rmr_region.source_data_type = cpu_to_be16(FADUMP_REAL_MODE_REGION);",
          "188:  fdm->rmr_region.source_address = cpu_to_be64(RMA_START);",
          "189:  fdm->rmr_region.source_len = cpu_to_be64(fw_dump.boot_memory_size);",
          "190:  fdm->rmr_region.destination_address = cpu_to_be64(addr);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "274:  if (fdm_active)",
          "276:  else",
          "277:   fw_dump.boot_memory_size = fadump_calculate_reserve_size();",
          "",
          "[Removed Lines]",
          "275:   fw_dump.boot_memory_size = fdm_active->rmr_region.source_len;",
          "",
          "[Added Lines]",
          "275:   fw_dump.boot_memory_size = be64_to_cpu(fdm_active->rmr_region.source_len);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "314:     (unsigned long)(base >> 20));",
          "316:   fw_dump.fadumphdr_addr =",
          "319:   pr_debug(\"fadumphdr_addr = %p\\n\",",
          "320:     (void *) fw_dump.fadumphdr_addr);",
          "321:  } else {",
          "",
          "[Removed Lines]",
          "317:     fdm_active->rmr_region.destination_address +",
          "318:     fdm_active->rmr_region.source_len;",
          "",
          "[Added Lines]",
          "317:     be64_to_cpu(fdm_active->rmr_region.destination_address) +",
          "318:     be64_to_cpu(fdm_active->rmr_region.source_len);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "472: {",
          "473:  memset(regs, 0, sizeof(struct pt_regs));",
          "478:   reg_entry++;",
          "479:  }",
          "480:  reg_entry++;",
          "",
          "[Removed Lines]",
          "475:  while (reg_entry->reg_id != REG_ID(\"CPUEND\")) {",
          "476:   fadump_set_regval(regs, reg_entry->reg_id,",
          "477:      reg_entry->reg_value);",
          "",
          "[Added Lines]",
          "475:  while (be64_to_cpu(reg_entry->reg_id) != REG_ID(\"CPUEND\")) {",
          "476:   fadump_set_regval(regs, be64_to_cpu(reg_entry->reg_id),",
          "477:      be64_to_cpu(reg_entry->reg_value));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "603:  if (!fdm->cpu_state_data.bytes_dumped)",
          "604:   return -EINVAL;",
          "607:  vaddr = __va(addr);",
          "609:  reg_header = vaddr;",
          "611:   printk(KERN_ERR \"Unable to read register save area.\\n\");",
          "612:   return -ENOENT;",
          "613:  }",
          "614:  pr_debug(\"--------CPU State Data------------\\n\");",
          "620:  pr_debug(\"NumCpus     : %u\\n\", num_cpus);",
          "621:  vaddr += sizeof(u32);",
          "622:  reg_entry = (struct fadump_reg_entry *)vaddr;",
          "",
          "[Removed Lines]",
          "606:  addr = fdm->cpu_state_data.destination_address;",
          "610:  if (reg_header->magic_number != REGSAVE_AREA_MAGIC) {",
          "615:  pr_debug(\"Magic Number: %llx\\n\", reg_header->magic_number);",
          "616:  pr_debug(\"NumCpuOffset: %x\\n\", reg_header->num_cpu_offset);",
          "618:  vaddr += reg_header->num_cpu_offset;",
          "619:  num_cpus = *((u32 *)(vaddr));",
          "",
          "[Added Lines]",
          "606:  addr = be64_to_cpu(fdm->cpu_state_data.destination_address);",
          "610:  if (be64_to_cpu(reg_header->magic_number) != REGSAVE_AREA_MAGIC) {",
          "615:  pr_debug(\"Magic Number: %llx\\n\", be64_to_cpu(reg_header->magic_number));",
          "616:  pr_debug(\"NumCpuOffset: %x\\n\", be32_to_cpu(reg_header->num_cpu_offset));",
          "618:  vaddr += be32_to_cpu(reg_header->num_cpu_offset);",
          "619:  num_cpus = be32_to_cpu(*((__be32 *)(vaddr)));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "639:   fdh = __va(fw_dump.fadumphdr_addr);",
          "641:  for (i = 0; i < num_cpus; i++) {",
          "643:    printk(KERN_ERR \"Unable to read CPU state data\\n\");",
          "644:    rc = -ENOENT;",
          "645:    goto error_out;",
          "646:   }",
          "649:   if (fdh && !cpumask_test_cpu(cpu, &fdh->cpu_online_mask)) {",
          "650:    SKIP_TO_NEXT_CPU(reg_entry);",
          "651:    continue;",
          "",
          "[Removed Lines]",
          "642:   if (reg_entry->reg_id != REG_ID(\"CPUSTRT\")) {",
          "648:   cpu = reg_entry->reg_value & FADUMP_CPU_ID_MASK;",
          "",
          "[Added Lines]",
          "642:   if (be64_to_cpu(reg_entry->reg_id) != REG_ID(\"CPUSTRT\")) {",
          "648:   cpu = be64_to_cpu(reg_entry->reg_value) & FADUMP_CPU_ID_MASK;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "692:   return -EINVAL;",
          "696:    (fdm_active->cpu_state_data.error_flags != 0) ||",
          "697:    (fdm_active->rmr_region.error_flags != 0)) {",
          "698:   printk(KERN_ERR \"Dump taken by platform is not valid\\n\");",
          "",
          "[Removed Lines]",
          "695:  if ((fdm_active->header.dump_status_flag == FADUMP_ERROR_FLAG) ||",
          "",
          "[Added Lines]",
          "695:  if ((be16_to_cpu(fdm_active->header.dump_status_flag) == FADUMP_ERROR_FLAG) ||",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "828: static inline unsigned long fadump_relocate(unsigned long paddr)",
          "829: {",
          "830:  if (paddr > RMA_START && paddr < fw_dump.boot_memory_size)",
          "832:  else",
          "833:   return paddr;",
          "834: }",
          "",
          "[Removed Lines]",
          "831:   return fdm.rmr_region.destination_address + paddr;",
          "",
          "[Added Lines]",
          "831:   return be64_to_cpu(fdm.rmr_region.destination_address) + paddr;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "906:   }",
          "908:   phdr->p_paddr = mbase;",
          "",
          "[Removed Lines]",
          "905:    phdr->p_offset = fdm.rmr_region.destination_address;",
          "",
          "[Added Lines]",
          "905:    phdr->p_offset = be64_to_cpu(fdm.rmr_region.destination_address);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "952:  fadump_setup_crash_memory_ranges();",
          "956:  addr = init_fadump_header(addr);",
          "957:  vaddr = __va(addr);",
          "",
          "[Removed Lines]",
          "954:  addr = fdm.rmr_region.destination_address + fdm.rmr_region.source_len;",
          "",
          "[Added Lines]",
          "954:  addr = be64_to_cpu(fdm.rmr_region.destination_address) + be64_to_cpu(fdm.rmr_region.source_len);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1024:  if (fw_dump.dump_active) {",
          "1025:   init_fadump_mem_struct(&fdm,",
          "1027:   fadump_invalidate_dump(&fdm);",
          "1028:  }",
          "1029: }",
          "",
          "[Removed Lines]",
          "1026:    fdm_active->cpu_state_data.destination_address);",
          "",
          "[Added Lines]",
          "1026:    be64_to_cpu(fdm_active->cpu_state_data.destination_address));",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1063:   return;",
          "1064:  }",
          "1067:  fadump_cleanup();",
          "1068:  mutex_unlock(&fadump_mutex);",
          "",
          "[Removed Lines]",
          "1066:  destination_address = fdm_active->cpu_state_data.destination_address;",
          "",
          "[Added Lines]",
          "1066:  destination_address = be64_to_cpu(fdm_active->cpu_state_data.destination_address);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1183:  seq_printf(m,",
          "1184:    \"CPU : [%#016llx-%#016llx] %#llx bytes, \"",
          "1185:    \"Dumped: %#llx\\n\",",
          "1191:  seq_printf(m,",
          "1192:    \"HPTE: [%#016llx-%#016llx] %#llx bytes, \"",
          "1193:    \"Dumped: %#llx\\n\",",
          "1199:  seq_printf(m,",
          "1200:    \"DUMP: [%#016llx-%#016llx] %#llx bytes, \"",
          "1201:    \"Dumped: %#llx\\n\",",
          "1208:  if (!fdm_active ||",
          "1209:   (fw_dump.reserve_dump_area_start ==",
          "1211:   goto out;",
          "",
          "[Removed Lines]",
          "1186:    fdm_ptr->cpu_state_data.destination_address,",
          "1187:    fdm_ptr->cpu_state_data.destination_address +",
          "1188:    fdm_ptr->cpu_state_data.source_len - 1,",
          "1189:    fdm_ptr->cpu_state_data.source_len,",
          "1190:    fdm_ptr->cpu_state_data.bytes_dumped);",
          "1194:    fdm_ptr->hpte_region.destination_address,",
          "1195:    fdm_ptr->hpte_region.destination_address +",
          "1196:    fdm_ptr->hpte_region.source_len - 1,",
          "1197:    fdm_ptr->hpte_region.source_len,",
          "1198:    fdm_ptr->hpte_region.bytes_dumped);",
          "1202:    fdm_ptr->rmr_region.destination_address,",
          "1203:    fdm_ptr->rmr_region.destination_address +",
          "1204:    fdm_ptr->rmr_region.source_len - 1,",
          "1205:    fdm_ptr->rmr_region.source_len,",
          "1206:    fdm_ptr->rmr_region.bytes_dumped);",
          "1210:   fdm_ptr->cpu_state_data.destination_address))",
          "",
          "[Added Lines]",
          "1186:    be64_to_cpu(fdm_ptr->cpu_state_data.destination_address),",
          "1187:    be64_to_cpu(fdm_ptr->cpu_state_data.destination_address) +",
          "1188:    be64_to_cpu(fdm_ptr->cpu_state_data.source_len) - 1,",
          "1189:    be64_to_cpu(fdm_ptr->cpu_state_data.source_len),",
          "1190:    be64_to_cpu(fdm_ptr->cpu_state_data.bytes_dumped));",
          "1194:    be64_to_cpu(fdm_ptr->hpte_region.destination_address),",
          "1195:    be64_to_cpu(fdm_ptr->hpte_region.destination_address) +",
          "1196:    be64_to_cpu(fdm_ptr->hpte_region.source_len) - 1,",
          "1197:    be64_to_cpu(fdm_ptr->hpte_region.source_len),",
          "1198:    be64_to_cpu(fdm_ptr->hpte_region.bytes_dumped));",
          "1202:    be64_to_cpu(fdm_ptr->rmr_region.destination_address),",
          "1203:    be64_to_cpu(fdm_ptr->rmr_region.destination_address) +",
          "1204:    be64_to_cpu(fdm_ptr->rmr_region.source_len) - 1,",
          "1205:    be64_to_cpu(fdm_ptr->rmr_region.source_len),",
          "1206:    be64_to_cpu(fdm_ptr->rmr_region.bytes_dumped));",
          "1210:   be64_to_cpu(fdm_ptr->cpu_state_data.destination_address)))",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1215:    \"    : [%#016llx-%#016llx] %#llx bytes, \"",
          "1216:    \"Dumped: %#llx\\n\",",
          "1217:    (unsigned long long)fw_dump.reserve_dump_area_start,",
          "1220:    fw_dump.reserve_dump_area_start,",
          "1222:    fw_dump.reserve_dump_area_start);",
          "1223: out:",
          "1224:  if (fdm_active)",
          "",
          "[Removed Lines]",
          "1218:    fdm_ptr->cpu_state_data.destination_address - 1,",
          "1219:    fdm_ptr->cpu_state_data.destination_address -",
          "1221:    fdm_ptr->cpu_state_data.destination_address -",
          "",
          "[Added Lines]",
          "1218:    be64_to_cpu(fdm_ptr->cpu_state_data.destination_address) - 1,",
          "1219:    be64_to_cpu(fdm_ptr->cpu_state_data.destination_address) -",
          "1221:    be64_to_cpu(fdm_ptr->cpu_state_data.destination_address) -",
          "",
          "---------------"
        ],
        "arch/powerpc/platforms/pseries/lpar.c||arch/powerpc/platforms/pseries/lpar.c": [
          "File: arch/powerpc/platforms/pseries/lpar.c -> arch/powerpc/platforms/pseries/lpar.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "43: #include <asm/trace.h>",
          "44: #include <asm/firmware.h>",
          "45: #include <asm/plpar_wrappers.h>",
          "47: #include \"pseries.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46: #include <asm/fadump.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "247:  }",
          "249: #ifdef __LITTLE_ENDIAN__",
          "252:   long rc;",
          "254:   rc = pseries_big_endian_exceptions();",
          "",
          "[Removed Lines]",
          "251:  if (firmware_has_feature(FW_FEATURE_SET_MODE)) {",
          "",
          "[Added Lines]",
          "261:  if (firmware_has_feature(FW_FEATURE_SET_MODE) && !is_fadump_active()) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
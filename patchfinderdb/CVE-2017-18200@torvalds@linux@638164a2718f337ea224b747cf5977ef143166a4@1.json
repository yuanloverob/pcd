{
  "cve_id": "CVE-2017-18200",
  "cve_desc": "The f2fs implementation in the Linux kernel before 4.14 mishandles reference counts associated with f2fs_wait_discard_bios calls, which allows local users to cause a denial of service (BUG), as demonstrated by fstrim.",
  "repo": "torvalds/linux",
  "patch_hash": "638164a2718f337ea224b747cf5977ef143166a4",
  "patch_info": {
    "commit_hash": "638164a2718f337ea224b747cf5977ef143166a4",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/638164a2718f337ea224b747cf5977ef143166a4",
    "files": [
      "fs/f2fs/f2fs.h",
      "fs/f2fs/segment.c",
      "fs/f2fs/super.c"
    ],
    "message": "f2fs: fix potential panic during fstrim\n\nAs Ju Hyung Park reported:\n\n\"When 'fstrim' is called for manual trim, a BUG() can be triggered\nrandomly with this patch.\n\nI'm seeing this issue on both x86 Desktop and arm64 Android phone.\n\nOn x86 Desktop, this was caused during Ubuntu boot-up. I have a\ncronjob installed which calls 'fstrim -v /' during boot. On arm64\nAndroid, this was caused during GC looping with 1ms gc_min_sleep_time\n& gc_max_sleep_time.\"\n\nRoot cause of this issue is that f2fs_wait_discard_bios can only be\nused by f2fs_put_super, because during put_super there must be no\nother referrers, so it can ignore discard entry's reference count\nwhen removing the entry, otherwise in other caller we will hit bug_on\nin __remove_discard_cmd as there may be other issuer added reference\ncount in discard entry.\n\nThread A\t\t\t\tThread B\n\t\t\t\t\t- issue_discard_thread\n- f2fs_ioc_fitrim\n - f2fs_trim_fs\n  - f2fs_wait_discard_bios\n   - __issue_discard_cmd\n    - __submit_discard_cmd\n\t\t\t\t\t - __wait_discard_cmd\n\t\t\t\t\t  - dc->ref++\n\t\t\t\t\t  - __wait_one_discard_bio\n   - __wait_discard_cmd\n    - __remove_discard_cmd\n     - f2fs_bug_on(sbi, dc->ref)\n\nFixes: 969d1b180d987c2be02de890d0fff0f66a0e80de\nReported-by: Ju Hyung Park <qkrwngud825@gmail.com>\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
    "before_after_code_files": [
      "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
      "fs/f2fs/segment.c||fs/f2fs/segment.c",
      "fs/f2fs/super.c||fs/f2fs/super.c"
    ]
  },
  "patch_diff": {
    "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h": [
      "File: fs/f2fs/f2fs.h -> fs/f2fs/f2fs.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "2525: bool is_checkpointed_data(struct f2fs_sb_info *sbi, block_t blkaddr);",
      "2526: void refresh_sit_entry(struct f2fs_sb_info *sbi, block_t old, block_t new);",
      "2527: void stop_discard_thread(struct f2fs_sb_info *sbi);",
      "2529: void clear_prefree_segments(struct f2fs_sb_info *sbi, struct cp_control *cpc);",
      "2530: void release_discard_addrs(struct f2fs_sb_info *sbi);",
      "2531: int npages_for_summary_flush(struct f2fs_sb_info *sbi, bool for_ra);",
      "",
      "[Removed Lines]",
      "2528: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi);",
      "",
      "[Added Lines]",
      "2528: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi, bool umount);",
      "",
      "---------------"
    ],
    "fs/f2fs/segment.c||fs/f2fs/segment.c": [
      "File: fs/f2fs/segment.c -> fs/f2fs/segment.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1210: }",
      "1214: {",
      "1215:  __issue_discard_cmd(sbi, false);",
      "1216:  __drop_discard_cmd(sbi);",
      "1218: }",
      "1220: static void mark_discard_range_all(struct f2fs_sb_info *sbi)",
      "",
      "[Removed Lines]",
      "1213: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)",
      "1217:  __wait_discard_cmd(sbi, false);",
      "",
      "[Added Lines]",
      "1213: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi, bool umount)",
      "1217:  __wait_discard_cmd(sbi, !umount);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2244:  }",
      "2246:  mark_discard_range_all(sbi);",
      "2248: out:",
      "2249:  range->len = F2FS_BLK_TO_BYTES(cpc.trimmed);",
      "2250:  return err;",
      "",
      "[Removed Lines]",
      "2247:  f2fs_wait_discard_bios(sbi);",
      "",
      "[Added Lines]",
      "2247:  f2fs_wait_discard_bios(sbi, false);",
      "",
      "---------------"
    ],
    "fs/f2fs/super.c||fs/f2fs/super.c": [
      "File: fs/f2fs/super.c -> fs/f2fs/super.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "801:  }",
      "806:  if (f2fs_discard_en(sbi) && !sbi->discard_blks) {",
      "807:   struct cp_control cpc = {",
      "",
      "[Removed Lines]",
      "804:  f2fs_wait_discard_bios(sbi);",
      "",
      "[Added Lines]",
      "804:  f2fs_wait_discard_bios(sbi, true);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4e6a8d9b224f886362ea6e8f6046b541437c944f",
      "candidate_info": {
        "commit_hash": "4e6a8d9b224f886362ea6e8f6046b541437c944f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4e6a8d9b224f886362ea6e8f6046b541437c944f",
        "files": [
          "fs/f2fs/checkpoint.c",
          "fs/f2fs/f2fs.h",
          "fs/f2fs/segment.c",
          "fs/f2fs/super.c"
        ],
        "message": "f2fs: relax async discard commands more\n\nThis patch relaxes async discard commands to avoid waiting its end_io during\ncheckpoint.\nInstead of waiting them during checkpoint, it will be done when actually reusing\nthem.\n\nTest on initial partition of nvme drive.\n\n # time fstrim /mnt/test\n\nBefore : 6.158s\nAfter : 4.822s\n\nReviewed-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/checkpoint.c||fs/f2fs/checkpoint.c",
          "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
          "fs/f2fs/segment.c||fs/f2fs/segment.c",
          "fs/f2fs/super.c||fs/f2fs/super.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
            "fs/f2fs/segment.c||fs/f2fs/segment.c",
            "fs/f2fs/super.c||fs/f2fs/super.c"
          ],
          "candidate": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
            "fs/f2fs/segment.c||fs/f2fs/segment.c",
            "fs/f2fs/super.c||fs/f2fs/super.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/checkpoint.c||fs/f2fs/checkpoint.c": [
          "File: fs/f2fs/checkpoint.c -> fs/f2fs/checkpoint.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1254:   f2fs_bug_on(sbi, prefree_segments(sbi));",
          "1255:   flush_sit_entries(sbi, cpc);",
          "1256:   clear_prefree_segments(sbi, cpc);",
          "1258:   unblock_operations(sbi);",
          "1259:   goto out;",
          "1260:  }",
          "",
          "[Removed Lines]",
          "1257:   f2fs_wait_all_discard_bio(sbi);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1275:  err = do_checkpoint(sbi, cpc);",
          "1277:   release_discard_addrs(sbi);",
          "1279:   clear_prefree_segments(sbi, cpc);",
          "1283:  unblock_operations(sbi);",
          "1284:  stat_inc_cp_count(sbi->stat_info);",
          "",
          "[Removed Lines]",
          "1276:  if (err) {",
          "1278:  } else {",
          "1280:   f2fs_wait_all_discard_bio(sbi);",
          "1281:  }",
          "",
          "[Added Lines]",
          "1275:  if (err)",
          "1277:  else",
          "",
          "---------------"
        ],
        "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h": [
          "File: fs/f2fs/f2fs.h -> fs/f2fs/f2fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "184: struct bio_entry {",
          "185:  struct list_head list;",
          "186:  struct bio *bio;",
          "187:  struct completion event;",
          "188:  int error;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "186:  block_t lstart;",
          "187:  block_t len;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2111: void invalidate_blocks(struct f2fs_sb_info *, block_t);",
          "2112: bool is_checkpointed_data(struct f2fs_sb_info *, block_t);",
          "2113: void refresh_sit_entry(struct f2fs_sb_info *, block_t, block_t);",
          "2115: void clear_prefree_segments(struct f2fs_sb_info *, struct cp_control *);",
          "2116: void release_discard_addrs(struct f2fs_sb_info *);",
          "2117: int npages_for_summary_flush(struct f2fs_sb_info *, bool);",
          "",
          "[Removed Lines]",
          "2114: void f2fs_wait_all_discard_bio(struct f2fs_sb_info *);",
          "",
          "[Added Lines]",
          "2116: void f2fs_wait_discard_bio(struct f2fs_sb_info *, block_t);",
          "",
          "---------------"
        ],
        "fs/f2fs/segment.c||fs/f2fs/segment.c": [
          "File: fs/f2fs/segment.c -> fs/f2fs/segment.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "625: }",
          "627: static struct bio_entry *__add_bio_entry(struct f2fs_sb_info *sbi,",
          "629: {",
          "630:  struct list_head *wait_list = &(SM_I(sbi)->wait_list);",
          "631:  struct bio_entry *be = f2fs_kmem_cache_alloc(bio_entry_slab, GFP_NOFS);",
          "633:  INIT_LIST_HEAD(&be->list);",
          "634:  be->bio = bio;",
          "635:  init_completion(&be->event);",
          "636:  list_add_tail(&be->list, wait_list);",
          "638:  return be;",
          "639: }",
          "642: {",
          "643:  struct list_head *wait_list = &(SM_I(sbi)->wait_list);",
          "644:  struct bio_entry *be, *tmp;",
          "",
          "[Removed Lines]",
          "628:        struct bio *bio)",
          "641: void f2fs_wait_all_discard_bio(struct f2fs_sb_info *sbi)",
          "",
          "[Added Lines]",
          "628:    struct bio *bio, block_t lstart, block_t len)",
          "635:  be->lstart = lstart;",
          "636:  be->len = len;",
          "644: void f2fs_wait_discard_bio(struct f2fs_sb_info *sbi, block_t blkaddr)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "647:   struct bio *bio = be->bio;",
          "648:   int err;",
          "651:   err = be->error;",
          "652:   if (err == -EOPNOTSUPP)",
          "653:    err = 0;",
          "",
          "[Removed Lines]",
          "650:   wait_for_completion_io(&be->event);",
          "",
          "[Added Lines]",
          "653:   if (!completion_done(&be->event)) {",
          "654:    if ((be->lstart <= blkaddr &&",
          "655:      blkaddr < be->lstart + be->len) ||",
          "656:      blkaddr == NULL_ADDR)",
          "657:     wait_for_completion_io(&be->event);",
          "658:    else",
          "659:     continue;",
          "660:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "675:   struct block_device *bdev, block_t blkstart, block_t blklen)",
          "676: {",
          "677:  struct bio *bio = NULL;",
          "678:  int err;",
          "680:  trace_f2fs_issue_discard(sbi->sb, blkstart, blklen);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "689:  block_t lblkstart = blkstart;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "689:     SECTOR_FROM_BLOCK(blklen),",
          "690:     GFP_NOFS, 0, &bio);",
          "691:  if (!err && bio) {",
          "694:   bio->bi_private = be;",
          "695:   bio->bi_end_io = f2fs_submit_bio_wait_endio;",
          "696:   bio->bi_opf |= REQ_SYNC;",
          "697:   submit_bio(bio);",
          "698:  }",
          "700:  return err;",
          "701: }",
          "",
          "[Removed Lines]",
          "692:   struct bio_entry *be = __add_bio_entry(sbi, bio);",
          "",
          "[Added Lines]",
          "704:   struct bio_entry *be = __add_bio_entry(sbi, bio,",
          "705:       lblkstart, blklen);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1590:  f2fs_wait_discard_bio(sbi, *new_blkaddr);",
          "",
          "---------------"
        ],
        "fs/f2fs/super.c||fs/f2fs/super.c": [
          "File: fs/f2fs/super.c -> fs/f2fs/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "770:   write_checkpoint(sbi, &cpc);",
          "771:  }",
          "774:  f2fs_destroy_stats(sbi);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "774:  f2fs_wait_discard_bio(sbi, NULL_ADDR);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7d20c8abb2edcf962ca857d51f4d0f9cd4b19053",
      "candidate_info": {
        "commit_hash": "7d20c8abb2edcf962ca857d51f4d0f9cd4b19053",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7d20c8abb2edcf962ca857d51f4d0f9cd4b19053",
        "files": [
          "fs/f2fs/debug.c",
          "fs/f2fs/f2fs.h",
          "fs/f2fs/file.c",
          "fs/f2fs/segment.c",
          "fs/f2fs/super.c"
        ],
        "message": "f2fs: fix to avoid NULL pointer dereference on se->discard_map\n\nhttps://bugzilla.kernel.org/show_bug.cgi?id=200951\n\nThese is a NULL pointer dereference issue reported in bugzilla:\n\nHi,\nin the setup there is a SATA SSD connected to a SATA-to-USB bridge.\n\nThe disc is \"Samsung SSD 850 PRO 256G\" which supports TRIM.\nThere are four partitions:\n sda1: FAT  /boot\n sda2: F2FS /\n sda3: F2FS /home\n sda4: F2FS\n\nThe bridge is ASMT1153e which uses the \"uas\" driver.\nThere is no TRIM pass-through, so, when mounting it reports:\n mounting with \"discard\" option, but the device does not support discard\n\nThe USB host is USB3.0 and UASP capable. It is the one on RK3399.\n\nGiven this everything works fine, except there is no TRIM support.\n\nIn order to enable TRIM a new UDEV rule is added [1]:\n /etc/udev/rules.d/10-sata-bridge-trim.rules:\n ACTION==\"add|change\", ATTRS{idVendor}==\"174c\", ATTRS{idProduct}==\"55aa\", SUBSYSTEM==\"scsi_disk\", ATTR{provisioning_mode}=\"unmap\"\nAfter reboot any F2FS write hangs forever and dmesg reports:\n Unable to handle kernel NULL pointer dereference\n\nAlso tested on a x86_64 system: works fine even with TRIM enabled.\n same disc\n same bridge\n different usb host controller\n different cpu architecture\n not root filesystem\n\nRegards,\n  Vicen\u00e7.\n\n[1] Post #5 in https://bbs.archlinux.org/viewtopic.php?id=236280\n\n Unable to handle kernel NULL pointer dereference at virtual address 000000000000003e\n Mem abort info:\n   ESR = 0x96000004\n   Exception class = DABT (current EL), IL = 32 bits\n   SET = 0, FnV = 0\n   EA = 0, S1PTW = 0\n Data abort info:\n   ISV = 0, ISS = 0x00000004\n   CM = 0, WnR = 0\n user pgtable: 4k pages, 48-bit VAs, pgdp = 00000000626e3122\n [000000000000003e] pgd=0000000000000000\n Internal error: Oops: 96000004 [#1] SMP\n Modules linked in: overlay snd_soc_hdmi_codec rc_cec dw_hdmi_i2s_audio dw_hdmi_cec snd_soc_simple_card snd_soc_simple_card_utils snd_soc_rockchip_i2s rockchip_rga snd_soc_rockchip_pcm rockchipdrm videobuf2_dma_sg v4l2_mem2mem rtc_rk808 videobuf2_memops analogix_dp videobuf2_v4l2 videobuf2_common dw_hdmi dw_wdt cec rc_core videodev drm_kms_helper media drm rockchip_thermal rockchip_saradc realtek drm_panel_orientation_quirks syscopyarea sysfillrect sysimgblt fb_sys_fops dwmac_rk stmmac_platform stmmac pwm_bl squashfs loop crypto_user gpio_keys hid_kensington\n CPU: 5 PID: 957 Comm: nvim Not tainted 4.19.0-rc1-1-ARCH #1\n Hardware name: Sapphire-RK3399 Board (DT)\n pstate: 00000005 (nzcv daif -PAN -UAO)\n pc : update_sit_entry+0x304/0x4b0\n lr : update_sit_entry+0x108/0x4b0\n sp : ffff00000ca13bd0\n x29: ffff00000ca13bd0 x28: 000000000000003e\n x27: 0000000000000020 x26: 0000000000080000\n x25: 0000000000000048 x24: ffff8000ebb85cf8\n x23: 0000000000000253 x22: 00000000ffffffff\n x21: 00000000000535f2 x20: 00000000ffffffdf\n x19: ffff8000eb9e6800 x18: ffff8000eb9e6be8\n x17: 0000000007ce6926 x16: 000000001c83ffa8\n x15: 0000000000000000 x14: ffff8000f602df90\n x13: 0000000000000006 x12: 0000000000000040\n x11: 0000000000000228 x10: 0000000000000000\n x9 : 0000000000000000 x8 : 0000000000000000\n x7 : 00000000000535f2 x6 : ffff8000ebff3440\n x5 : ffff8000ebff3440 x4 : ffff8000ebe3a6c8\n x3 : 00000000ffffffff x2 : 0000000000000020\n x1 : 0000000000000000 x0 : ffff8000eb9e5800\n Process nvim (pid: 957, stack limit = 0x0000000063a78320)\n Call trace:\n  update_sit_entry+0x304/0x4b0\n  f2fs_invalidate_blocks+0x98/0x140\n  truncate_node+0x90/0x400\n  f2fs_remove_inode_page+0xe8/0x340\n  f2fs_evict_inode+0x2b0/0x408\n  evict+0xe0/0x1e0\n  iput+0x160/0x260\n  do_unlinkat+0x214/0x298\n  __arm64_sys_unlinkat+0x3c/0x68\n  el0_svc_handler+0x94/0x118\n  el0_svc+0x8/0xc\n Code: f9400800 b9488400 36080140 f9400f01 (387c4820)\n ---[ end trace a0f21a307118c477 ]---\n\nThe reason is it is possible to enable discard flag on block queue via\nUDEV, but during mount, f2fs will initialize se->discard_map only if\nthis flag is set, once the flag is set after mount, f2fs may dereference\nNULL pointer on se->discard_map.\n\nSo this patch does below changes to fix this issue:\n- initialize and update se->discard_map all the time.\n- don't clear DISCARD option if device has no QUEUE_FLAG_DISCARD flag\nduring mount.\n- don't issue small discard on zoned block device.\n- introduce some functions to enhance the readability.\n\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nTested-by: Vicente Bergas <vicencb@gmail.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/debug.c||fs/f2fs/debug.c",
          "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
          "fs/f2fs/file.c||fs/f2fs/file.c",
          "fs/f2fs/segment.c||fs/f2fs/segment.c",
          "fs/f2fs/super.c||fs/f2fs/super.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
            "fs/f2fs/segment.c||fs/f2fs/segment.c",
            "fs/f2fs/super.c||fs/f2fs/super.c"
          ],
          "candidate": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
            "fs/f2fs/segment.c||fs/f2fs/segment.c",
            "fs/f2fs/super.c||fs/f2fs/super.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/debug.c||fs/f2fs/debug.c": [
          "File: fs/f2fs/debug.c -> fs/f2fs/debug.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "190:  si->base_mem += MAIN_SEGS(sbi) * sizeof(struct seg_entry);",
          "191:  si->base_mem += f2fs_bitmap_size(MAIN_SEGS(sbi));",
          "192:  si->base_mem += 2 * SIT_VBLOCK_MAP_SIZE * MAIN_SEGS(sbi);",
          "195:  si->base_mem += SIT_VBLOCK_MAP_SIZE;",
          "196:  if (sbi->segs_per_sec > 1)",
          "197:   si->base_mem += MAIN_SECS(sbi) * sizeof(struct sec_entry);",
          "",
          "[Removed Lines]",
          "193:  if (f2fs_discard_en(sbi))",
          "194:   si->base_mem += SIT_VBLOCK_MAP_SIZE * MAIN_SEGS(sbi);",
          "",
          "[Added Lines]",
          "193:  si->base_mem += SIT_VBLOCK_MAP_SIZE * MAIN_SEGS(sbi);",
          "",
          "---------------"
        ],
        "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h": [
          "File: fs/f2fs/f2fs.h -> fs/f2fs/f2fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "3399: }",
          "3400: #endif",
          "3403: {",
          "3407: }",
          "3409: static inline void set_opt_mode(struct f2fs_sb_info *sbi, unsigned int mt)",
          "",
          "[Removed Lines]",
          "3402: static inline bool f2fs_discard_en(struct f2fs_sb_info *sbi)",
          "3404:  struct request_queue *q = bdev_get_queue(sbi->sb->s_bdev);",
          "3406:  return blk_queue_discard(q) || f2fs_sb_has_blkzoned(sbi->sb);",
          "",
          "[Added Lines]",
          "3402: static inline bool f2fs_hw_should_discard(struct f2fs_sb_info *sbi)",
          "3404:  return f2fs_sb_has_blkzoned(sbi->sb);",
          "3405: }",
          "3407: static inline bool f2fs_hw_support_discard(struct f2fs_sb_info *sbi)",
          "3408: {",
          "3409:  return blk_queue_discard(bdev_get_queue(sbi->sb->s_bdev));",
          "3410: }",
          "3412: static inline bool f2fs_realtime_discard_enable(struct f2fs_sb_info *sbi)",
          "3413: {",
          "3414:  return (test_opt(sbi, DISCARD) && f2fs_hw_support_discard(sbi)) ||",
          "3415:      f2fs_hw_should_discard(sbi);",
          "",
          "---------------"
        ],
        "fs/f2fs/file.c||fs/f2fs/file.c": [
          "File: fs/f2fs/file.c -> fs/f2fs/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1978:  if (!capable(CAP_SYS_ADMIN))",
          "1979:   return -EPERM;",
          "1982:   return -EOPNOTSUPP;",
          "1984:  if (copy_from_user(&range, (struct fstrim_range __user *)arg,",
          "",
          "[Removed Lines]",
          "1981:  if (!blk_queue_discard(q))",
          "",
          "[Added Lines]",
          "1981:  if (!f2fs_hw_support_discard(F2FS_SB(sb)))",
          "",
          "---------------"
        ],
        "fs/f2fs/segment.c||fs/f2fs/segment.c": [
          "File: fs/f2fs/segment.c -> fs/f2fs/segment.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1725:  struct list_head *head = &SM_I(sbi)->dcc_info->entry_list;",
          "1726:  int i;",
          "1729:   return false;",
          "1731:  if (!force) {",
          "1733:    SM_I(sbi)->dcc_info->nr_discards >=",
          "1734:     SM_I(sbi)->dcc_info->max_discards)",
          "1735:    return false;",
          "",
          "[Removed Lines]",
          "1728:  if (se->valid_blocks == max_blocks || !f2fs_discard_en(sbi))",
          "1732:   if (!test_opt(sbi, DISCARD) || !se->valid_blocks ||",
          "",
          "[Added Lines]",
          "1728:  if (se->valid_blocks == max_blocks || !f2fs_hw_support_discard(sbi))",
          "1732:   if (!f2fs_realtime_discard_enable(sbi) || !se->valid_blocks ||",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1835:     dirty_i->nr_dirty[PRE]--;",
          "1836:   }",
          "1839:    continue;",
          "1841:   if (force && start >= cpc->trim_start &&",
          "",
          "[Removed Lines]",
          "1838:   if (!test_opt(sbi, DISCARD))",
          "",
          "[Added Lines]",
          "1838:   if (!f2fs_realtime_discard_enable(sbi))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2025:    del = 0;",
          "2026:   }",
          "2030:    sbi->discard_blks--;",
          "",
          "[Removed Lines]",
          "2028:   if (f2fs_discard_en(sbi) &&",
          "2029:    !f2fs_test_and_set_bit(offset, se->discard_map))",
          "",
          "[Added Lines]",
          "2028:   if (!f2fs_test_and_set_bit(offset, se->discard_map))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2054:    del = 0;",
          "2055:   }",
          "2059:    sbi->discard_blks++;",
          "2060:  }",
          "2061:  if (!f2fs_test_bit(offset, se->ckpt_valid_map))",
          "",
          "[Removed Lines]",
          "2057:   if (f2fs_discard_en(sbi) &&",
          "2058:    f2fs_test_and_clear_bit(offset, se->discard_map))",
          "",
          "[Added Lines]",
          "2056:   if (f2fs_test_and_clear_bit(offset, se->discard_map))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2675:   goto out;",
          "2677:  start_block = START_BLOCK(sbi, start_segno);",
          "",
          "[Removed Lines]",
          "2674:  if (test_opt(sbi, DISCARD))",
          "",
          "[Added Lines]",
          "2672:  if (f2fs_realtime_discard_enable(sbi))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3762:    return -ENOMEM;",
          "3763: #endif",
          "3772:  }",
          "3774:  sit_i->tmp_map = f2fs_kzalloc(sbi, SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);",
          "",
          "[Removed Lines]",
          "3765:   if (f2fs_discard_en(sbi)) {",
          "3766:    sit_i->sentries[start].discard_map",
          "3767:     = f2fs_kzalloc(sbi, SIT_VBLOCK_MAP_SIZE,",
          "3768:         GFP_KERNEL);",
          "3769:    if (!sit_i->sentries[start].discard_map)",
          "3770:     return -ENOMEM;",
          "3771:   }",
          "",
          "[Added Lines]",
          "3763:   sit_i->sentries[start].discard_map",
          "3764:    = f2fs_kzalloc(sbi, SIT_VBLOCK_MAP_SIZE,",
          "3765:        GFP_KERNEL);",
          "3766:   if (!sit_i->sentries[start].discard_map)",
          "3767:    return -ENOMEM;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3916:     total_node_blocks += se->valid_blocks;",
          "3931:    }",
          "3933:    if (sbi->segs_per_sec > 1)",
          "",
          "[Removed Lines]",
          "3919:    if (f2fs_discard_en(sbi)) {",
          "3920:     if (is_set_ckpt_flags(sbi, CP_TRIMMED_FLAG)) {",
          "3921:      memset(se->discard_map, 0xff,",
          "3922:       SIT_VBLOCK_MAP_SIZE);",
          "3923:     } else {",
          "3924:      memcpy(se->discard_map,",
          "3925:       se->cur_valid_map,",
          "3926:       SIT_VBLOCK_MAP_SIZE);",
          "3927:      sbi->discard_blks +=",
          "3928:       sbi->blocks_per_seg -",
          "3929:       se->valid_blocks;",
          "3930:     }",
          "",
          "[Added Lines]",
          "3915:    if (is_set_ckpt_flags(sbi, CP_TRIMMED_FLAG)) {",
          "3916:     memset(se->discard_map, 0xff,",
          "3917:      SIT_VBLOCK_MAP_SIZE);",
          "3918:    } else {",
          "3919:     memcpy(se->discard_map,",
          "3920:      se->cur_valid_map,",
          "3921:      SIT_VBLOCK_MAP_SIZE);",
          "3922:     sbi->discard_blks +=",
          "3923:      sbi->blocks_per_seg -",
          "3924:      se->valid_blocks;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3965:   if (IS_NODESEG(se->type))",
          "3966:    total_node_blocks += se->valid_blocks;",
          "3978:   }",
          "3980:   if (sbi->segs_per_sec > 1) {",
          "",
          "[Removed Lines]",
          "3968:   if (f2fs_discard_en(sbi)) {",
          "3969:    if (is_set_ckpt_flags(sbi, CP_TRIMMED_FLAG)) {",
          "3970:     memset(se->discard_map, 0xff,",
          "3971:        SIT_VBLOCK_MAP_SIZE);",
          "3972:    } else {",
          "3973:     memcpy(se->discard_map, se->cur_valid_map,",
          "3974:        SIT_VBLOCK_MAP_SIZE);",
          "3975:     sbi->discard_blks += old_valid_blocks;",
          "3976:     sbi->discard_blks -= se->valid_blocks;",
          "3977:    }",
          "",
          "[Added Lines]",
          "3962:   if (is_set_ckpt_flags(sbi, CP_TRIMMED_FLAG)) {",
          "3963:    memset(se->discard_map, 0xff, SIT_VBLOCK_MAP_SIZE);",
          "3964:   } else {",
          "3965:    memcpy(se->discard_map, se->cur_valid_map,",
          "3966:       SIT_VBLOCK_MAP_SIZE);",
          "3967:    sbi->discard_blks += old_valid_blocks;",
          "3968:    sbi->discard_blks -= se->valid_blocks;",
          "",
          "---------------"
        ],
        "fs/f2fs/super.c||fs/f2fs/super.c": [
          "File: fs/f2fs/super.c -> fs/f2fs/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "360: static int parse_options(struct super_block *sb, char *options)",
          "361: {",
          "362:  struct f2fs_sb_info *sbi = F2FS_SB(sb);",
          "364:  substring_t args[MAX_OPT_ARGS];",
          "365:  char *p, *name;",
          "366:  int arg = 0;",
          "",
          "[Removed Lines]",
          "363:  struct request_queue *q;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "415:     return -EINVAL;",
          "416:    break;",
          "417:   case Opt_discard:",
          "426:    break;",
          "427:   case Opt_nodiscard:",
          "428:    if (f2fs_sb_has_blkzoned(sb)) {",
          "",
          "[Removed Lines]",
          "418:    q = bdev_get_queue(sb->s_bdev);",
          "419:    if (blk_queue_discard(q)) {",
          "420:     set_opt(sbi, DISCARD);",
          "421:    } else if (!f2fs_sb_has_blkzoned(sb)) {",
          "422:     f2fs_msg(sb, KERN_WARNING,",
          "423:      \"mounting with \\\"discard\\\" option, but \"",
          "424:      \"the device does not support discard\");",
          "425:    }",
          "",
          "[Added Lines]",
          "417:    set_opt(sbi, DISCARD);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1033:  dropped = f2fs_wait_discard_bios(sbi);",
          "1036:   struct cp_control cpc = {",
          "1037:    .reason = CP_UMOUNT | CP_TRIMMED,",
          "1038:   };",
          "",
          "[Removed Lines]",
          "1035:  if (f2fs_discard_en(sbi) && !sbi->discard_blks && !dropped) {",
          "",
          "[Added Lines]",
          "1027:  if ((f2fs_hw_support_discard(sbi) || f2fs_hw_should_discard(sbi)) &&",
          "1028:      !sbi->discard_blks && !dropped) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1399:  set_opt(sbi, NOHEAP);",
          "1400:  sbi->sb->s_flags |= SB_LAZYTIME;",
          "1401:  set_opt(sbi, FLUSH_MERGE);",
          "1404:  if (f2fs_sb_has_blkzoned(sbi->sb))",
          "1405:   set_opt_mode(sbi, F2FS_MOUNT_LFS);",
          "1406:  else",
          "",
          "[Removed Lines]",
          "1402:  if (blk_queue_discard(bdev_get_queue(sbi->sb->s_bdev)))",
          "1403:   set_opt(sbi, DISCARD);",
          "",
          "[Added Lines]",
          "1395:  set_opt(sbi, DISCARD);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cac5a3d8f517cfc7a882ffd4a0eba220f02deee8",
      "candidate_info": {
        "commit_hash": "cac5a3d8f517cfc7a882ffd4a0eba220f02deee8",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/cac5a3d8f517cfc7a882ffd4a0eba220f02deee8",
        "files": [
          "fs/f2fs/f2fs.h"
        ],
        "message": "f2fs: fix 446 coding style warnings in f2fs.h\n\n1) Nine coding style warnings below have been resolved:\n\"Missing a blank line after declarations\"\n\n2) 435 coding style warnings below have been resolved:\n\"function definition argument 'x' should also have an identifier name\"\n\n3) Two coding style warnings below have been resolved:\n\"macros should not use a trailing semicolon\"\n\nSigned-off-by: DongOh Shin <doscode.kr@gmail.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h"
          ],
          "candidate": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h": [
          "File: fs/f2fs/f2fs.h -> fs/f2fs/f2fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "517:  return __is_extent_mergeable(cur, front);",
          "518: }",
          "521: static inline void __try_update_largest_extent(struct inode *inode,",
          "522:    struct extent_tree *et, struct extent_node *en)",
          "523: {",
          "",
          "[Removed Lines]",
          "520: extern void f2fs_mark_inode_dirty_sync(struct inode *, bool);",
          "",
          "[Added Lines]",
          "524: extern void f2fs_mark_inode_dirty_sync(struct inode *inode, bool sync);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1996: int f2fs_sync_file(struct file *, loff_t, loff_t, int);",
          "1997: void truncate_data_blocks(struct dnode_of_data *);",
          "1998: int truncate_blocks(struct inode *, u64, bool);",
          "1999: int f2fs_truncate(struct inode *);",
          "2000: int f2fs_getattr(struct vfsmount *, struct dentry *, struct kstat *);",
          "2001: int f2fs_setattr(struct dentry *, struct iattr *);",
          "2002: int truncate_hole(struct inode *, pgoff_t, pgoff_t);",
          "2003: int truncate_data_blocks_range(struct dnode_of_data *, int);",
          "2004: long f2fs_ioctl(struct file *, unsigned int, unsigned long);",
          "2005: long f2fs_compat_ioctl(struct file *, unsigned int, unsigned long);",
          "2010: void f2fs_set_inode_flags(struct inode *);",
          "2011: struct inode *f2fs_iget(struct super_block *, unsigned long);",
          "2012: struct inode *f2fs_iget_retry(struct super_block *, unsigned long);",
          "2013: int try_to_free_nats(struct f2fs_sb_info *, int);",
          "2014: int update_inode(struct inode *, struct page *);",
          "2015: int update_inode_page(struct inode *);",
          "2016: int f2fs_write_inode(struct inode *, struct writeback_control *);",
          "2017: void f2fs_evict_inode(struct inode *);",
          "2018: void handle_failed_inode(struct inode *);",
          "",
          "[Added Lines]",
          "2005: int f2fs_sync_file(struct file *file, loff_t start, loff_t end, int datasync);",
          "2006: void truncate_data_blocks(struct dnode_of_data *dn);",
          "2007: int truncate_blocks(struct inode *inode, u64 from, bool lock);",
          "2008: int f2fs_truncate(struct inode *inode);",
          "2009: int f2fs_getattr(struct vfsmount *mnt, struct dentry *dentry,",
          "2010:    struct kstat *stat);",
          "2011: int f2fs_setattr(struct dentry *dentry, struct iattr *attr);",
          "2012: int truncate_hole(struct inode *inode, pgoff_t pg_start, pgoff_t pg_end);",
          "2013: int truncate_data_blocks_range(struct dnode_of_data *dn, int count);",
          "2014: long f2fs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);",
          "2015: long f2fs_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg);",
          "2020: void f2fs_set_inode_flags(struct inode *inode);",
          "2021: struct inode *f2fs_iget(struct super_block *sb, unsigned long ino);",
          "2022: struct inode *f2fs_iget_retry(struct super_block *sb, unsigned long ino);",
          "2023: int try_to_free_nats(struct f2fs_sb_info *sbi, int nr_shrink);",
          "2024: int update_inode(struct inode *inode, struct page *node_page);",
          "2025: int update_inode_page(struct inode *inode);",
          "2026: int f2fs_write_inode(struct inode *inode, struct writeback_control *wbc);",
          "2027: void f2fs_evict_inode(struct inode *inode);",
          "2028: void handle_failed_inode(struct inode *inode);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2063: static inline int f2fs_add_link(struct dentry *dentry, struct inode *inode)",
          "2064: {",
          "",
          "[Removed Lines]",
          "2028: void set_de_type(struct f2fs_dir_entry *, umode_t);",
          "2029: unsigned char get_de_type(struct f2fs_dir_entry *);",
          "2030: struct f2fs_dir_entry *find_target_dentry(struct fscrypt_name *,",
          "2031:    f2fs_hash_t, int *, struct f2fs_dentry_ptr *);",
          "2032: int f2fs_fill_dentries(struct dir_context *, struct f2fs_dentry_ptr *,",
          "2033:    unsigned int, struct fscrypt_str *);",
          "2034: void do_make_empty_dir(struct inode *, struct inode *,",
          "2035:    struct f2fs_dentry_ptr *);",
          "2036: struct page *init_inode_metadata(struct inode *, struct inode *,",
          "2037:   const struct qstr *, const struct qstr *, struct page *);",
          "2038: void update_parent_metadata(struct inode *, struct inode *, unsigned int);",
          "2039: int room_for_filename(const void *, int, int);",
          "2040: void f2fs_drop_nlink(struct inode *, struct inode *);",
          "2041: struct f2fs_dir_entry *__f2fs_find_entry(struct inode *, struct fscrypt_name *,",
          "2042:        struct page **);",
          "2043: struct f2fs_dir_entry *f2fs_find_entry(struct inode *, const struct qstr *,",
          "2044:        struct page **);",
          "2045: struct f2fs_dir_entry *f2fs_parent_dir(struct inode *, struct page **);",
          "2046: ino_t f2fs_inode_by_name(struct inode *, const struct qstr *, struct page **);",
          "2047: void f2fs_set_link(struct inode *, struct f2fs_dir_entry *,",
          "2048:     struct page *, struct inode *);",
          "2049: int update_dent_inode(struct inode *, struct inode *, const struct qstr *);",
          "2050: void f2fs_update_dentry(nid_t ino, umode_t mode, struct f2fs_dentry_ptr *,",
          "2051:    const struct qstr *, f2fs_hash_t, unsigned int);",
          "2052: int f2fs_add_regular_entry(struct inode *, const struct qstr *,",
          "2053:    const struct qstr *, struct inode *, nid_t, umode_t);",
          "2054: int __f2fs_do_add_link(struct inode *, struct fscrypt_name*, struct inode *,",
          "2055:    nid_t, umode_t);",
          "2056: int __f2fs_add_link(struct inode *, const struct qstr *, struct inode *, nid_t,",
          "2057:    umode_t);",
          "2058: void f2fs_delete_entry(struct f2fs_dir_entry *, struct page *, struct inode *,",
          "2059:        struct inode *);",
          "2060: int f2fs_do_tmpfile(struct inode *, struct inode *);",
          "2061: bool f2fs_empty_dir(struct inode *);",
          "",
          "[Added Lines]",
          "2038: void set_de_type(struct f2fs_dir_entry *de, umode_t mode);",
          "2039: unsigned char get_de_type(struct f2fs_dir_entry *de);",
          "2040: struct f2fs_dir_entry *find_target_dentry(struct fscrypt_name *fname,",
          "2041:    f2fs_hash_t namehash, int *max_slots,",
          "2042:    struct f2fs_dentry_ptr *d);",
          "2043: int f2fs_fill_dentries(struct dir_context *ctx, struct f2fs_dentry_ptr *d,",
          "2044:    unsigned int start_pos, struct fscrypt_str *fstr);",
          "2045: void do_make_empty_dir(struct inode *inode, struct inode *parent,",
          "2046:    struct f2fs_dentry_ptr *d);",
          "2047: struct page *init_inode_metadata(struct inode *inode, struct inode *dir,",
          "2048:    const struct qstr *new_name,",
          "2049:    const struct qstr *orig_name, struct page *dpage);",
          "2050: void update_parent_metadata(struct inode *dir, struct inode *inode,",
          "2051:    unsigned int current_depth);",
          "2052: int room_for_filename(const void *bitmap, int slots, int max_slots);",
          "2053: void f2fs_drop_nlink(struct inode *dir, struct inode *inode);",
          "2054: struct f2fs_dir_entry *__f2fs_find_entry(struct inode *dir,",
          "2055:    struct fscrypt_name *fname, struct page **res_page);",
          "2056: struct f2fs_dir_entry *f2fs_find_entry(struct inode *dir,",
          "2057:    const struct qstr *child, struct page **res_page);",
          "2058: struct f2fs_dir_entry *f2fs_parent_dir(struct inode *dir, struct page **p);",
          "2059: ino_t f2fs_inode_by_name(struct inode *dir, const struct qstr *qstr,",
          "2060:    struct page **page);",
          "2061: void f2fs_set_link(struct inode *dir, struct f2fs_dir_entry *de,",
          "2062:    struct page *page, struct inode *inode);",
          "2063: int update_dent_inode(struct inode *inode, struct inode *to,",
          "2064:    const struct qstr *name);",
          "2065: void f2fs_update_dentry(nid_t ino, umode_t mode, struct f2fs_dentry_ptr *d,",
          "2066:    const struct qstr *name, f2fs_hash_t name_hash,",
          "2067:    unsigned int bit_pos);",
          "2068: int f2fs_add_regular_entry(struct inode *dir, const struct qstr *new_name,",
          "2069:    const struct qstr *orig_name,",
          "2070:    struct inode *inode, nid_t ino, umode_t mode);",
          "2071: int __f2fs_do_add_link(struct inode *dir, struct fscrypt_name *fname,",
          "2072:    struct inode *inode, nid_t ino, umode_t mode);",
          "2073: int __f2fs_add_link(struct inode *dir, const struct qstr *name,",
          "2074:    struct inode *inode, nid_t ino, umode_t mode);",
          "2075: void f2fs_delete_entry(struct f2fs_dir_entry *dentry, struct page *page,",
          "2076:    struct inode *dir, struct inode *inode);",
          "2077: int f2fs_do_tmpfile(struct inode *inode, struct inode *dir);",
          "2078: bool f2fs_empty_dir(struct inode *dir);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2076: extern __printf(3, 4)",
          "2078: int sanity_check_ckpt(struct f2fs_sb_info *sbi);",
          "",
          "[Removed Lines]",
          "2072: int f2fs_inode_dirtied(struct inode *, bool);",
          "2073: void f2fs_inode_synced(struct inode *);",
          "2074: int f2fs_commit_super(struct f2fs_sb_info *, bool);",
          "2075: int f2fs_sync_fs(struct super_block *, int);",
          "2077: void f2fs_msg(struct super_block *, const char *, const char *, ...);",
          "2083: f2fs_hash_t f2fs_dentry_hash(const struct qstr *);",
          "",
          "[Added Lines]",
          "2089: int f2fs_inode_dirtied(struct inode *inode, bool sync);",
          "2090: void f2fs_inode_synced(struct inode *inode);",
          "2091: int f2fs_commit_super(struct f2fs_sb_info *sbi, bool recover);",
          "2092: int f2fs_sync_fs(struct super_block *sb, int sync);",
          "2094: void f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...);",
          "2100: f2fs_hash_t f2fs_dentry_hash(const struct qstr *name_info);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2088: struct dnode_of_data;",
          "2089: struct node_info;",
          "2124: int __init create_node_manager_caches(void);",
          "2125: void destroy_node_manager_caches(void);",
          "2168: int __init create_segment_manager_caches(void);",
          "2169: void destroy_segment_manager_caches(void);",
          "2198: int __init create_checkpoint_caches(void);",
          "2199: void destroy_checkpoint_caches(void);",
          "2230: #ifdef CONFIG_MIGRATION",
          "2233: #endif",
          "",
          "[Removed Lines]",
          "2091: bool available_free_memory(struct f2fs_sb_info *, int);",
          "2092: int need_dentry_mark(struct f2fs_sb_info *, nid_t);",
          "2093: bool is_checkpointed_node(struct f2fs_sb_info *, nid_t);",
          "2094: bool need_inode_block_update(struct f2fs_sb_info *, nid_t);",
          "2095: void get_node_info(struct f2fs_sb_info *, nid_t, struct node_info *);",
          "2096: pgoff_t get_next_page_offset(struct dnode_of_data *, pgoff_t);",
          "2097: int get_dnode_of_data(struct dnode_of_data *, pgoff_t, int);",
          "2098: int truncate_inode_blocks(struct inode *, pgoff_t);",
          "2099: int truncate_xattr_node(struct inode *, struct page *);",
          "2100: int wait_on_node_pages_writeback(struct f2fs_sb_info *, nid_t);",
          "2101: int remove_inode_page(struct inode *);",
          "2102: struct page *new_inode_page(struct inode *);",
          "2103: struct page *new_node_page(struct dnode_of_data *, unsigned int, struct page *);",
          "2104: void ra_node_page(struct f2fs_sb_info *, nid_t);",
          "2105: struct page *get_node_page(struct f2fs_sb_info *, pgoff_t);",
          "2106: struct page *get_node_page_ra(struct page *, int);",
          "2107: void move_node_page(struct page *, int);",
          "2108: int fsync_node_pages(struct f2fs_sb_info *, struct inode *,",
          "2109:    struct writeback_control *, bool);",
          "2110: int sync_node_pages(struct f2fs_sb_info *, struct writeback_control *);",
          "2111: void build_free_nids(struct f2fs_sb_info *, bool);",
          "2112: bool alloc_nid(struct f2fs_sb_info *, nid_t *);",
          "2113: void alloc_nid_done(struct f2fs_sb_info *, nid_t);",
          "2114: void alloc_nid_failed(struct f2fs_sb_info *, nid_t);",
          "2115: int try_to_free_nids(struct f2fs_sb_info *, int);",
          "2116: void recover_inline_xattr(struct inode *, struct page *);",
          "2117: void recover_xattr_data(struct inode *, struct page *, block_t);",
          "2118: int recover_inode_page(struct f2fs_sb_info *, struct page *);",
          "2119: int restore_node_summary(struct f2fs_sb_info *, unsigned int,",
          "2120:     struct f2fs_summary_block *);",
          "2121: void flush_nat_entries(struct f2fs_sb_info *);",
          "2122: int build_node_manager(struct f2fs_sb_info *);",
          "2123: void destroy_node_manager(struct f2fs_sb_info *);",
          "2130: void register_inmem_page(struct inode *, struct page *);",
          "2131: void drop_inmem_pages(struct inode *);",
          "2132: int commit_inmem_pages(struct inode *);",
          "2133: void f2fs_balance_fs(struct f2fs_sb_info *, bool);",
          "2134: void f2fs_balance_fs_bg(struct f2fs_sb_info *);",
          "2135: int f2fs_issue_flush(struct f2fs_sb_info *);",
          "2136: int create_flush_cmd_control(struct f2fs_sb_info *);",
          "2137: void destroy_flush_cmd_control(struct f2fs_sb_info *, bool);",
          "2138: void invalidate_blocks(struct f2fs_sb_info *, block_t);",
          "2139: bool is_checkpointed_data(struct f2fs_sb_info *, block_t);",
          "2140: void refresh_sit_entry(struct f2fs_sb_info *, block_t, block_t);",
          "2141: void f2fs_wait_discard_bio(struct f2fs_sb_info *, block_t);",
          "2142: void clear_prefree_segments(struct f2fs_sb_info *, struct cp_control *);",
          "2143: void release_discard_addrs(struct f2fs_sb_info *);",
          "2144: int npages_for_summary_flush(struct f2fs_sb_info *, bool);",
          "2145: void allocate_new_segments(struct f2fs_sb_info *);",
          "2146: int f2fs_trim_fs(struct f2fs_sb_info *, struct fstrim_range *);",
          "2147: bool exist_trim_candidates(struct f2fs_sb_info *, struct cp_control *);",
          "2148: struct page *get_sum_page(struct f2fs_sb_info *, unsigned int);",
          "2149: void update_meta_page(struct f2fs_sb_info *, void *, block_t);",
          "2150: void write_meta_page(struct f2fs_sb_info *, struct page *);",
          "2151: void write_node_page(unsigned int, struct f2fs_io_info *);",
          "2152: void write_data_page(struct dnode_of_data *, struct f2fs_io_info *);",
          "2153: void rewrite_data_page(struct f2fs_io_info *);",
          "2154: void __f2fs_replace_block(struct f2fs_sb_info *, struct f2fs_summary *,",
          "2155:      block_t, block_t, bool, bool);",
          "2156: void f2fs_replace_block(struct f2fs_sb_info *, struct dnode_of_data *,",
          "2157:     block_t, block_t, unsigned char, bool, bool);",
          "2158: void allocate_data_block(struct f2fs_sb_info *, struct page *,",
          "2159:   block_t, block_t *, struct f2fs_summary *, int);",
          "2160: void f2fs_wait_on_page_writeback(struct page *, enum page_type, bool);",
          "2161: void f2fs_wait_on_encrypted_page_writeback(struct f2fs_sb_info *, block_t);",
          "2162: void write_data_summaries(struct f2fs_sb_info *, block_t);",
          "2163: void write_node_summaries(struct f2fs_sb_info *, block_t);",
          "2164: int lookup_journal_in_cursum(struct f2fs_journal *, int, unsigned int, int);",
          "2165: void flush_sit_entries(struct f2fs_sb_info *, struct cp_control *);",
          "2166: int build_segment_manager(struct f2fs_sb_info *);",
          "2167: void destroy_segment_manager(struct f2fs_sb_info *);",
          "2174: void f2fs_stop_checkpoint(struct f2fs_sb_info *, bool);",
          "2175: struct page *grab_meta_page(struct f2fs_sb_info *, pgoff_t);",
          "2176: struct page *get_meta_page(struct f2fs_sb_info *, pgoff_t);",
          "2177: struct page *get_tmp_page(struct f2fs_sb_info *, pgoff_t);",
          "2178: bool is_valid_blkaddr(struct f2fs_sb_info *, block_t, int);",
          "2179: int ra_meta_pages(struct f2fs_sb_info *, block_t, int, int, bool);",
          "2180: void ra_meta_pages_cond(struct f2fs_sb_info *, pgoff_t);",
          "2181: long sync_meta_pages(struct f2fs_sb_info *, enum page_type, long);",
          "2182: void add_ino_entry(struct f2fs_sb_info *, nid_t, int type);",
          "2183: void remove_ino_entry(struct f2fs_sb_info *, nid_t, int type);",
          "2184: void release_ino_entry(struct f2fs_sb_info *, bool);",
          "2185: bool exist_written_data(struct f2fs_sb_info *, nid_t, int);",
          "2186: int f2fs_sync_inode_meta(struct f2fs_sb_info *);",
          "2187: int acquire_orphan_inode(struct f2fs_sb_info *);",
          "2188: void release_orphan_inode(struct f2fs_sb_info *);",
          "2189: void add_orphan_inode(struct inode *);",
          "2190: void remove_orphan_inode(struct f2fs_sb_info *, nid_t);",
          "2191: int recover_orphan_inodes(struct f2fs_sb_info *);",
          "2192: int get_valid_checkpoint(struct f2fs_sb_info *);",
          "2193: void update_dirty_page(struct inode *, struct page *);",
          "2194: void remove_dirty_inode(struct inode *);",
          "2195: int sync_dirty_inodes(struct f2fs_sb_info *, enum inode_type);",
          "2196: int write_checkpoint(struct f2fs_sb_info *, struct cp_control *);",
          "2197: void init_ino_entry_info(struct f2fs_sb_info *);",
          "2204: void f2fs_submit_merged_bio(struct f2fs_sb_info *, enum page_type, int);",
          "2205: void f2fs_submit_merged_bio_cond(struct f2fs_sb_info *, struct inode *,",
          "2206:     struct page *, nid_t, enum page_type, int);",
          "2207: void f2fs_flush_merged_bios(struct f2fs_sb_info *);",
          "2208: int f2fs_submit_page_bio(struct f2fs_io_info *);",
          "2209: int f2fs_submit_page_mbio(struct f2fs_io_info *);",
          "2210: struct block_device *f2fs_target_device(struct f2fs_sb_info *,",
          "2211:     block_t, struct bio *);",
          "2212: int f2fs_target_device_index(struct f2fs_sb_info *, block_t);",
          "2213: void set_data_blkaddr(struct dnode_of_data *);",
          "2214: void f2fs_update_data_blkaddr(struct dnode_of_data *, block_t);",
          "2215: int reserve_new_blocks(struct dnode_of_data *, blkcnt_t);",
          "2216: int reserve_new_block(struct dnode_of_data *);",
          "2217: int f2fs_get_block(struct dnode_of_data *, pgoff_t);",
          "2218: int f2fs_preallocate_blocks(struct kiocb *, struct iov_iter *);",
          "2219: int f2fs_reserve_block(struct dnode_of_data *, pgoff_t);",
          "2220: struct page *get_read_data_page(struct inode *, pgoff_t, int, bool);",
          "2221: struct page *find_data_page(struct inode *, pgoff_t);",
          "2222: struct page *get_lock_data_page(struct inode *, pgoff_t, bool);",
          "2223: struct page *get_new_data_page(struct inode *, struct page *, pgoff_t, bool);",
          "2224: int do_write_data_page(struct f2fs_io_info *);",
          "2225: int f2fs_map_blocks(struct inode *, struct f2fs_map_blocks *, int, int);",
          "2226: int f2fs_fiemap(struct inode *inode, struct fiemap_extent_info *, u64, u64);",
          "2227: void f2fs_set_page_dirty_nobuffers(struct page *);",
          "2228: void f2fs_invalidate_page(struct page *, unsigned int, unsigned int);",
          "2229: int f2fs_release_page(struct page *, gfp_t);",
          "2231: int f2fs_migrate_page(struct address_space *, struct page *, struct page *,",
          "2232:     enum migrate_mode);",
          "2238: int start_gc_thread(struct f2fs_sb_info *);",
          "2239: void stop_gc_thread(struct f2fs_sb_info *);",
          "2240: block_t start_bidx_of_node(unsigned int, struct inode *);",
          "2241: int f2fs_gc(struct f2fs_sb_info *, bool, bool);",
          "2242: void build_gc_manager(struct f2fs_sb_info *);",
          "2247: int recover_fsync_data(struct f2fs_sb_info *, bool);",
          "2248: bool space_for_roll_forward(struct f2fs_sb_info *);",
          "",
          "[Added Lines]",
          "2108: bool available_free_memory(struct f2fs_sb_info *sbi, int type);",
          "2109: int need_dentry_mark(struct f2fs_sb_info *sbi, nid_t nid);",
          "2110: bool is_checkpointed_node(struct f2fs_sb_info *sbi, nid_t nid);",
          "2111: bool need_inode_block_update(struct f2fs_sb_info *sbi, nid_t ino);",
          "2112: void get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni);",
          "2113: pgoff_t get_next_page_offset(struct dnode_of_data *dn, pgoff_t pgofs);",
          "2114: int get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode);",
          "2115: int truncate_inode_blocks(struct inode *inode, pgoff_t from);",
          "2116: int truncate_xattr_node(struct inode *inode, struct page *page);",
          "2117: int wait_on_node_pages_writeback(struct f2fs_sb_info *sbi, nid_t ino);",
          "2118: int remove_inode_page(struct inode *inode);",
          "2119: struct page *new_inode_page(struct inode *inode);",
          "2120: struct page *new_node_page(struct dnode_of_data *dn,",
          "2121:    unsigned int ofs, struct page *ipage);",
          "2122: void ra_node_page(struct f2fs_sb_info *sbi, nid_t nid);",
          "2123: struct page *get_node_page(struct f2fs_sb_info *sbi, pgoff_t nid);",
          "2124: struct page *get_node_page_ra(struct page *parent, int start);",
          "2125: void move_node_page(struct page *node_page, int gc_type);",
          "2126: int fsync_node_pages(struct f2fs_sb_info *sbi, struct inode *inode,",
          "2127:    struct writeback_control *wbc, bool atomic);",
          "2128: int sync_node_pages(struct f2fs_sb_info *sbi, struct writeback_control *wbc);",
          "2129: void build_free_nids(struct f2fs_sb_info *sbi, bool sync);",
          "2130: bool alloc_nid(struct f2fs_sb_info *sbi, nid_t *nid);",
          "2131: void alloc_nid_done(struct f2fs_sb_info *sbi, nid_t nid);",
          "2132: void alloc_nid_failed(struct f2fs_sb_info *sbi, nid_t nid);",
          "2133: int try_to_free_nids(struct f2fs_sb_info *sbi, int nr_shrink);",
          "2134: void recover_inline_xattr(struct inode *inode, struct page *page);",
          "2135: void recover_xattr_data(struct inode *inode, struct page *page,",
          "2136:    block_t blkaddr);",
          "2137: int recover_inode_page(struct f2fs_sb_info *sbi, struct page *page);",
          "2138: int restore_node_summary(struct f2fs_sb_info *sbi,",
          "2139:    unsigned int segno, struct f2fs_summary_block *sum);",
          "2140: void flush_nat_entries(struct f2fs_sb_info *sbi);",
          "2141: int build_node_manager(struct f2fs_sb_info *sbi);",
          "2142: void destroy_node_manager(struct f2fs_sb_info *sbi);",
          "2149: void register_inmem_page(struct inode *inode, struct page *page);",
          "2150: void drop_inmem_pages(struct inode *inode);",
          "2151: int commit_inmem_pages(struct inode *inode);",
          "2152: void f2fs_balance_fs(struct f2fs_sb_info *sbi, bool need);",
          "2153: void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi);",
          "2154: int f2fs_issue_flush(struct f2fs_sb_info *sbi);",
          "2155: int create_flush_cmd_control(struct f2fs_sb_info *sbi);",
          "2156: void destroy_flush_cmd_control(struct f2fs_sb_info *sbi, bool free);",
          "2157: void invalidate_blocks(struct f2fs_sb_info *sbi, block_t addr);",
          "2158: bool is_checkpointed_data(struct f2fs_sb_info *sbi, block_t blkaddr);",
          "2159: void refresh_sit_entry(struct f2fs_sb_info *sbi, block_t old, block_t new);",
          "2160: void f2fs_wait_discard_bio(struct f2fs_sb_info *sbi, block_t blkaddr);",
          "2161: void clear_prefree_segments(struct f2fs_sb_info *sbi, struct cp_control *cpc);",
          "2162: void release_discard_addrs(struct f2fs_sb_info *sbi);",
          "2163: int npages_for_summary_flush(struct f2fs_sb_info *sbi, bool for_ra);",
          "2164: void allocate_new_segments(struct f2fs_sb_info *sbi);",
          "2165: int f2fs_trim_fs(struct f2fs_sb_info *sbi, struct fstrim_range *range);",
          "2166: bool exist_trim_candidates(struct f2fs_sb_info *sbi, struct cp_control *cpc);",
          "2167: struct page *get_sum_page(struct f2fs_sb_info *sbi, unsigned int segno);",
          "2168: void update_meta_page(struct f2fs_sb_info *sbi, void *src, block_t blk_addr);",
          "2169: void write_meta_page(struct f2fs_sb_info *sbi, struct page *page);",
          "2170: void write_node_page(unsigned int nid, struct f2fs_io_info *fio);",
          "2171: void write_data_page(struct dnode_of_data *dn, struct f2fs_io_info *fio);",
          "2172: void rewrite_data_page(struct f2fs_io_info *fio);",
          "2173: void __f2fs_replace_block(struct f2fs_sb_info *sbi, struct f2fs_summary *sum,",
          "2174:    block_t old_blkaddr, block_t new_blkaddr,",
          "2175:    bool recover_curseg, bool recover_newaddr);",
          "2176: void f2fs_replace_block(struct f2fs_sb_info *sbi, struct dnode_of_data *dn,",
          "2177:    block_t old_addr, block_t new_addr,",
          "2178:    unsigned char version, bool recover_curseg,",
          "2179:    bool recover_newaddr);",
          "2180: void allocate_data_block(struct f2fs_sb_info *sbi, struct page *page,",
          "2181:    block_t old_blkaddr, block_t *new_blkaddr,",
          "2182:    struct f2fs_summary *sum, int type);",
          "2183: void f2fs_wait_on_page_writeback(struct page *page,",
          "2184:    enum page_type type, bool ordered);",
          "2185: void f2fs_wait_on_encrypted_page_writeback(struct f2fs_sb_info *sbi,",
          "2186:    block_t blkaddr);",
          "2187: void write_data_summaries(struct f2fs_sb_info *sbi, block_t start_blk);",
          "2188: void write_node_summaries(struct f2fs_sb_info *sbi, block_t start_blk);",
          "2189: int lookup_journal_in_cursum(struct f2fs_journal *journal, int type,",
          "2190:    unsigned int val, int alloc);",
          "2191: void flush_sit_entries(struct f2fs_sb_info *sbi, struct cp_control *cpc);",
          "2192: int build_segment_manager(struct f2fs_sb_info *sbi);",
          "2193: void destroy_segment_manager(struct f2fs_sb_info *sbi);",
          "2200: void f2fs_stop_checkpoint(struct f2fs_sb_info *sbi, bool end_io);",
          "2201: struct page *grab_meta_page(struct f2fs_sb_info *sbi, pgoff_t index);",
          "2202: struct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index);",
          "2203: struct page *get_tmp_page(struct f2fs_sb_info *sbi, pgoff_t index);",
          "2204: bool is_valid_blkaddr(struct f2fs_sb_info *sbi, block_t blkaddr, int type);",
          "2205: int ra_meta_pages(struct f2fs_sb_info *sbi, block_t start, int nrpages,",
          "2206:    int type, bool sync);",
          "2207: void ra_meta_pages_cond(struct f2fs_sb_info *sbi, pgoff_t index);",
          "2208: long sync_meta_pages(struct f2fs_sb_info *sbi, enum page_type type,",
          "2209:    long nr_to_write);",
          "2210: void add_ino_entry(struct f2fs_sb_info *sbi, nid_t ino, int type);",
          "2211: void remove_ino_entry(struct f2fs_sb_info *sbi, nid_t ino, int type);",
          "2212: void release_ino_entry(struct f2fs_sb_info *sbi, bool all);",
          "2213: bool exist_written_data(struct f2fs_sb_info *sbi, nid_t ino, int mode);",
          "2214: int f2fs_sync_inode_meta(struct f2fs_sb_info *sbi);",
          "2215: int acquire_orphan_inode(struct f2fs_sb_info *sbi);",
          "2216: void release_orphan_inode(struct f2fs_sb_info *sbi);",
          "2217: void add_orphan_inode(struct inode *inode);",
          "2218: void remove_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino);",
          "2219: int recover_orphan_inodes(struct f2fs_sb_info *sbi);",
          "2220: int get_valid_checkpoint(struct f2fs_sb_info *sbi);",
          "2221: void update_dirty_page(struct inode *inode, struct page *page);",
          "2222: void remove_dirty_inode(struct inode *inode);",
          "2223: int sync_dirty_inodes(struct f2fs_sb_info *sbi, enum inode_type type);",
          "2224: int write_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc);",
          "2225: void init_ino_entry_info(struct f2fs_sb_info *sbi);",
          "2232: void f2fs_submit_merged_bio(struct f2fs_sb_info *sbi, enum page_type type,",
          "2233:    int rw);",
          "2234: void f2fs_submit_merged_bio_cond(struct f2fs_sb_info *sbi,",
          "2235:     struct inode *inode, struct page *page,",
          "2236:     nid_t ino, enum page_type type, int rw);",
          "2237: void f2fs_flush_merged_bios(struct f2fs_sb_info *sbi);",
          "2238: int f2fs_submit_page_bio(struct f2fs_io_info *fio);",
          "2239: int f2fs_submit_page_mbio(struct f2fs_io_info *fio);",
          "2240: struct block_device *f2fs_target_device(struct f2fs_sb_info *sbi,",
          "2241:    block_t blk_addr, struct bio *bio);",
          "2242: int f2fs_target_device_index(struct f2fs_sb_info *sbi, block_t blkaddr);",
          "2243: void set_data_blkaddr(struct dnode_of_data *dn);",
          "2244: void f2fs_update_data_blkaddr(struct dnode_of_data *dn, block_t blkaddr);",
          "2245: int reserve_new_blocks(struct dnode_of_data *dn, blkcnt_t count);",
          "2246: int reserve_new_block(struct dnode_of_data *dn);",
          "2247: int f2fs_get_block(struct dnode_of_data *dn, pgoff_t index);",
          "2248: int f2fs_preallocate_blocks(struct kiocb *iocb, struct iov_iter *from);",
          "2249: int f2fs_reserve_block(struct dnode_of_data *dn, pgoff_t index);",
          "2250: struct page *get_read_data_page(struct inode *inode, pgoff_t index,",
          "2251:    int op_flags, bool for_write);",
          "2252: struct page *find_data_page(struct inode *inode, pgoff_t index);",
          "2253: struct page *get_lock_data_page(struct inode *inode, pgoff_t index,",
          "2254:    bool for_write);",
          "2255: struct page *get_new_data_page(struct inode *inode,",
          "2256:    struct page *ipage, pgoff_t index, bool new_i_size);",
          "2257: int do_write_data_page(struct f2fs_io_info *fio);",
          "2258: int f2fs_map_blocks(struct inode *inode, struct f2fs_map_blocks *map,",
          "2259:    int create, int flag);",
          "2260: int f2fs_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,",
          "2261:    u64 start, u64 len);",
          "2262: void f2fs_set_page_dirty_nobuffers(struct page *page);",
          "2263: void f2fs_invalidate_page(struct page *page, unsigned int offset,",
          "2264:    unsigned int length);",
          "2265: int f2fs_release_page(struct page *page, gfp_t wait);",
          "2267: int f2fs_migrate_page(struct address_space *mapping, struct page *newpage,",
          "2268:    struct page *page, enum migrate_mode mode);",
          "2274: int start_gc_thread(struct f2fs_sb_info *sbi);",
          "2275: void stop_gc_thread(struct f2fs_sb_info *sbi);",
          "2276: block_t start_bidx_of_node(unsigned int node_ofs, struct inode *inode);",
          "2277: int f2fs_gc(struct f2fs_sb_info *sbi, bool sync, bool background);",
          "2278: void build_gc_manager(struct f2fs_sb_info *sbi);",
          "2283: int recover_fsync_data(struct f2fs_sb_info *sbi, bool check_only);",
          "2284: bool space_for_roll_forward(struct f2fs_sb_info *sbi);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2339: #define stat_inc_inplace_blocks(sbi)     \\",
          "2340:   (atomic_inc(&(sbi)->inplace_count))",
          "2341: #define stat_inc_atomic_write(inode)     \\",
          "2343: #define stat_dec_atomic_write(inode)     \\",
          "2345: #define stat_update_max_atomic_write(inode)    \\",
          "2346:  do {        \\",
          "2347:   int cur = atomic_read(&F2FS_I_SB(inode)->aw_cnt); \\",
          "",
          "[Removed Lines]",
          "2342:   (atomic_inc(&F2FS_I_SB(inode)->aw_cnt));",
          "2344:   (atomic_dec(&F2FS_I_SB(inode)->aw_cnt));",
          "",
          "[Added Lines]",
          "2378:   (atomic_inc(&F2FS_I_SB(inode)->aw_cnt))",
          "2380:   (atomic_dec(&F2FS_I_SB(inode)->aw_cnt))",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2381:   si->bg_node_blks += (gc_type == BG_GC) ? (blks) : 0; \\",
          "2382:  } while (0)",
          "2386: int __init f2fs_create_root_stats(void);",
          "2387: void f2fs_destroy_root_stats(void);",
          "2388: #else",
          "",
          "[Removed Lines]",
          "2384: int f2fs_build_stats(struct f2fs_sb_info *);",
          "2385: void f2fs_destroy_stats(struct f2fs_sb_info *);",
          "",
          "[Added Lines]",
          "2420: int f2fs_build_stats(struct f2fs_sb_info *sbi);",
          "2421: void f2fs_destroy_stats(struct f2fs_sb_info *sbi);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2477: void f2fs_update_extent_cache_range(struct dnode_of_data *dn,",
          "2480: int __init create_extent_cache(void);",
          "2481: void destroy_extent_cache(void);",
          "",
          "[Removed Lines]",
          "2437: bool f2fs_may_inline_data(struct inode *);",
          "2438: bool f2fs_may_inline_dentry(struct inode *);",
          "2439: void read_inline_data(struct page *, struct page *);",
          "2440: bool truncate_inline_inode(struct page *, u64);",
          "2441: int f2fs_read_inline_data(struct inode *, struct page *);",
          "2442: int f2fs_convert_inline_page(struct dnode_of_data *, struct page *);",
          "2443: int f2fs_convert_inline_inode(struct inode *);",
          "2444: int f2fs_write_inline_data(struct inode *, struct page *);",
          "2445: bool recover_inline_data(struct inode *, struct page *);",
          "2446: struct f2fs_dir_entry *find_in_inline_dir(struct inode *,",
          "2447:     struct fscrypt_name *, struct page **);",
          "2448: int make_empty_inline_dir(struct inode *inode, struct inode *, struct page *);",
          "2449: int f2fs_add_inline_entry(struct inode *, const struct qstr *,",
          "2450:   const struct qstr *, struct inode *, nid_t, umode_t);",
          "2451: void f2fs_delete_inline_entry(struct f2fs_dir_entry *, struct page *,",
          "2452:       struct inode *, struct inode *);",
          "2453: bool f2fs_empty_inline_dir(struct inode *);",
          "2454: int f2fs_read_inline_dir(struct file *, struct dir_context *,",
          "2455:       struct fscrypt_str *);",
          "2456: int f2fs_inline_data_fiemap(struct inode *,",
          "2457:   struct fiemap_extent_info *, __u64, __u64);",
          "2462: unsigned long f2fs_shrink_count(struct shrinker *, struct shrink_control *);",
          "2463: unsigned long f2fs_shrink_scan(struct shrinker *, struct shrink_control *);",
          "2464: void f2fs_join_shrinker(struct f2fs_sb_info *);",
          "2465: void f2fs_leave_shrinker(struct f2fs_sb_info *);",
          "2470: unsigned int f2fs_shrink_extent_tree(struct f2fs_sb_info *, int);",
          "2471: bool f2fs_init_extent_tree(struct inode *, struct f2fs_extent *);",
          "2472: void f2fs_drop_extent_tree(struct inode *);",
          "2473: unsigned int f2fs_destroy_extent_node(struct inode *);",
          "2474: void f2fs_destroy_extent_tree(struct inode *);",
          "2475: bool f2fs_lookup_extent_cache(struct inode *, pgoff_t, struct extent_info *);",
          "2476: void f2fs_update_extent_cache(struct dnode_of_data *);",
          "2478:       pgoff_t, block_t, unsigned int);",
          "2479: void init_extent_cache_info(struct f2fs_sb_info *);",
          "",
          "[Added Lines]",
          "2473: bool f2fs_may_inline_data(struct inode *inode);",
          "2474: bool f2fs_may_inline_dentry(struct inode *inode);",
          "2475: void read_inline_data(struct page *page, struct page *ipage);",
          "2476: bool truncate_inline_inode(struct page *ipage, u64 from);",
          "2477: int f2fs_read_inline_data(struct inode *inode, struct page *page);",
          "2478: int f2fs_convert_inline_page(struct dnode_of_data *dn, struct page *page);",
          "2479: int f2fs_convert_inline_inode(struct inode *inode);",
          "2480: int f2fs_write_inline_data(struct inode *inode, struct page *page);",
          "2481: bool recover_inline_data(struct inode *inode, struct page *npage);",
          "2482: struct f2fs_dir_entry *find_in_inline_dir(struct inode *dir,",
          "2483:    struct fscrypt_name *fname, struct page **res_page);",
          "2484: int make_empty_inline_dir(struct inode *inode, struct inode *parent,",
          "2485:    struct page *ipage);",
          "2486: int f2fs_add_inline_entry(struct inode *dir, const struct qstr *new_name,",
          "2487:    const struct qstr *orig_name,",
          "2488:    struct inode *inode, nid_t ino, umode_t mode);",
          "2489: void f2fs_delete_inline_entry(struct f2fs_dir_entry *dentry, struct page *page,",
          "2490:    struct inode *dir, struct inode *inode);",
          "2491: bool f2fs_empty_inline_dir(struct inode *dir);",
          "2492: int f2fs_read_inline_dir(struct file *file, struct dir_context *ctx,",
          "2493:    struct fscrypt_str *fstr);",
          "2494: int f2fs_inline_data_fiemap(struct inode *inode,",
          "2495:    struct fiemap_extent_info *fieinfo,",
          "2496:    __u64 start, __u64 len);",
          "2501: unsigned long f2fs_shrink_count(struct shrinker *shrink,",
          "2502:    struct shrink_control *sc);",
          "2503: unsigned long f2fs_shrink_scan(struct shrinker *shrink,",
          "2504:    struct shrink_control *sc);",
          "2505: void f2fs_join_shrinker(struct f2fs_sb_info *sbi);",
          "2506: void f2fs_leave_shrinker(struct f2fs_sb_info *sbi);",
          "2511: unsigned int f2fs_shrink_extent_tree(struct f2fs_sb_info *sbi, int nr_shrink);",
          "2512: bool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext);",
          "2513: void f2fs_drop_extent_tree(struct inode *inode);",
          "2514: unsigned int f2fs_destroy_extent_node(struct inode *inode);",
          "2515: void f2fs_destroy_extent_tree(struct inode *inode);",
          "2516: bool f2fs_lookup_extent_cache(struct inode *inode, pgoff_t pgofs,",
          "2517:    struct extent_info *ei);",
          "2518: void f2fs_update_extent_cache(struct dnode_of_data *dn);",
          "2520:    pgoff_t fofs, block_t blkaddr, unsigned int len);",
          "2521: void init_extent_cache_info(struct f2fs_sb_info *sbi);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d431413f00319919ed2adac0d58225160bd1d8fb",
      "candidate_info": {
        "commit_hash": "d431413f00319919ed2adac0d58225160bd1d8fb",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d431413f00319919ed2adac0d58225160bd1d8fb",
        "files": [
          "fs/f2fs/f2fs.h",
          "fs/f2fs/segment.c",
          "fs/f2fs/super.c"
        ],
        "message": "f2fs: introduce f2fs_wait_discard_bios\n\nSplit f2fs_wait_discard_bios from f2fs_wait_discard_bio, just for cleanup,\nno logic change.\n\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
          "fs/f2fs/segment.c||fs/f2fs/segment.c",
          "fs/f2fs/super.c||fs/f2fs/super.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
            "fs/f2fs/segment.c||fs/f2fs/segment.c",
            "fs/f2fs/super.c||fs/f2fs/super.c"
          ],
          "candidate": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
            "fs/f2fs/segment.c||fs/f2fs/segment.c",
            "fs/f2fs/super.c||fs/f2fs/super.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h": [
          "File: fs/f2fs/f2fs.h -> fs/f2fs/f2fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2193: void invalidate_blocks(struct f2fs_sb_info *sbi, block_t addr);",
          "2194: bool is_checkpointed_data(struct f2fs_sb_info *sbi, block_t blkaddr);",
          "2195: void refresh_sit_entry(struct f2fs_sb_info *sbi, block_t old, block_t new);",
          "2197: void clear_prefree_segments(struct f2fs_sb_info *sbi, struct cp_control *cpc);",
          "2198: void release_discard_addrs(struct f2fs_sb_info *sbi);",
          "2199: int npages_for_summary_flush(struct f2fs_sb_info *sbi, bool for_ra);",
          "",
          "[Removed Lines]",
          "2196: void f2fs_wait_discard_bio(struct f2fs_sb_info *sbi, block_t blkaddr);",
          "",
          "[Added Lines]",
          "2196: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi);",
          "",
          "---------------"
        ],
        "fs/f2fs/segment.c||fs/f2fs/segment.c": [
          "File: fs/f2fs/segment.c -> fs/f2fs/segment.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "797:  struct list_head *pend_list = &(dcc->discard_pend_list);",
          "798:  struct list_head *wait_list = &(dcc->discard_wait_list);",
          "799:  struct discard_cmd *dc, *tmp;",
          "802:  mutex_lock(&dcc->cmd_lock);",
          "807:  list_for_each_entry_safe(dc, tmp, pend_list, list) {",
          "808:   if (dc->lstart <= blkaddr && blkaddr < dc->lstart + dc->len)",
          "809:    __punch_discard_cmd(sbi, dc, blkaddr);",
          "",
          "[Removed Lines]",
          "800:  struct blk_plug plug;",
          "804:  if (blkaddr == NULL_ADDR)",
          "805:   goto release_discard;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "817:   }",
          "818:  }",
          "832:  }",
          "833:  mutex_unlock(&dcc->cmd_lock);",
          "834: }",
          "",
          "[Removed Lines]",
          "820: release_discard:",
          "822:  if (blkaddr == NULL_ADDR) {",
          "823:   blk_start_plug(&plug);",
          "824:   list_for_each_entry_safe(dc, tmp, pend_list, list)",
          "825:    __submit_discard_cmd(sbi, dc);",
          "826:   blk_finish_plug(&plug);",
          "828:   list_for_each_entry_safe(dc, tmp, wait_list, list) {",
          "829:    wait_for_completion_io(&dc->wait);",
          "830:    __remove_discard_cmd(sbi, dc);",
          "831:   }",
          "",
          "[Added Lines]",
          "816:  mutex_unlock(&dcc->cmd_lock);",
          "817: }",
          "820: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)",
          "821: {",
          "822:  struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;",
          "823:  struct list_head *pend_list = &(dcc->discard_pend_list);",
          "824:  struct list_head *wait_list = &(dcc->discard_wait_list);",
          "825:  struct discard_cmd *dc, *tmp;",
          "826:  struct blk_plug plug;",
          "828:  mutex_lock(&dcc->cmd_lock);",
          "830:  blk_start_plug(&plug);",
          "831:  list_for_each_entry_safe(dc, tmp, pend_list, list)",
          "832:   __submit_discard_cmd(sbi, dc);",
          "833:  blk_finish_plug(&plug);",
          "835:  list_for_each_entry_safe(dc, tmp, wait_list, list) {",
          "836:   wait_for_completion_io(&dc->wait);",
          "837:   __remove_discard_cmd(sbi, dc);",
          "",
          "---------------"
        ],
        "fs/f2fs/super.c||fs/f2fs/super.c": [
          "File: fs/f2fs/super.c -> fs/f2fs/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "795:  }",
          "801:  f2fs_destroy_stats(sbi);",
          "",
          "[Removed Lines]",
          "798:  f2fs_wait_discard_bio(sbi, NULL_ADDR);",
          "",
          "[Added Lines]",
          "798:  f2fs_wait_discard_bios(sbi);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0ea805129d1bc5dacb588392d191f686c91a70bb",
      "candidate_info": {
        "commit_hash": "0ea805129d1bc5dacb588392d191f686c91a70bb",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0ea805129d1bc5dacb588392d191f686c91a70bb",
        "files": [
          "fs/f2fs/f2fs.h",
          "fs/f2fs/segment.c"
        ],
        "message": "f2fs: give correct trimmed blocks in fstrim\n\nWe have supported to issue discard in specified range during fstrim,\nit needs to return caller with successfully trimmed bytes in that\nrange instead of bytes of invalid blocks which are scanned in\ncheckpoint.\n\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
          "fs/f2fs/segment.c||fs/f2fs/segment.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
            "fs/f2fs/segment.c||fs/f2fs/segment.c"
          ],
          "candidate": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
            "fs/f2fs/segment.c||fs/f2fs/segment.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h": [
          "File: fs/f2fs/f2fs.h -> fs/f2fs/f2fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "162:  __u64 trim_start;",
          "163:  __u64 trim_end;",
          "164:  __u64 trim_minlen;",
          "166: };",
          "",
          "[Removed Lines]",
          "165:  __u64 trimmed;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/f2fs/segment.c||fs/f2fs/segment.c": [
          "File: fs/f2fs/segment.c -> fs/f2fs/segment.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1256:  return dropped;",
          "1257: }",
          "1260:        struct discard_cmd *dc)",
          "1261: {",
          "1262:  struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;",
          "1264:  wait_for_completion_io(&dc->wait);",
          "1265:  mutex_lock(&dcc->cmd_lock);",
          "1266:  f2fs_bug_on(sbi, dc->state != D_DONE);",
          "1267:  dc->ref--;",
          "1269:   __remove_discard_cmd(sbi, dc);",
          "1270:  mutex_unlock(&dcc->cmd_lock);",
          "1271: }",
          "1274:       struct discard_policy *dpolicy,",
          "1275:       block_t start, block_t end)",
          "1276: {",
          "",
          "[Removed Lines]",
          "1259: static void __wait_one_discard_bio(struct f2fs_sb_info *sbi,",
          "1268:  if (!dc->ref)",
          "1273: static void __wait_discard_cmd_range(struct f2fs_sb_info *sbi,",
          "",
          "[Added Lines]",
          "1259: static unsigned int __wait_one_discard_bio(struct f2fs_sb_info *sbi,",
          "1263:  unsigned int len = 0;",
          "1269:  if (!dc->ref) {",
          "1270:   if (!dc->error)",
          "1271:    len = dc->len;",
          "1273:  }",
          "1276:  return len;",
          "1279: static unsigned int __wait_discard_cmd_range(struct f2fs_sb_info *sbi,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1279:      &(dcc->fstrim_list) : &(dcc->wait_list);",
          "1280:  struct discard_cmd *dc, *tmp;",
          "1281:  bool need_wait;",
          "1283: next:",
          "1284:  need_wait = false;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1288:  unsigned int trimmed = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1291:    continue;",
          "1292:   if (dc->state == D_DONE && !dc->ref) {",
          "1293:    wait_for_completion_io(&dc->wait);",
          "1294:    __remove_discard_cmd(sbi, dc);",
          "1295:   } else {",
          "1296:    dc->ref++;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1301:    if (!dc->error)",
          "1302:     trimmed += dc->len;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1301:  mutex_unlock(&dcc->cmd_lock);",
          "1303:  if (need_wait) {",
          "1305:   goto next;",
          "1306:  }",
          "1307: }",
          "1309: static void __wait_all_discard_cmd(struct f2fs_sb_info *sbi,",
          "",
          "[Removed Lines]",
          "1304:   __wait_one_discard_bio(sbi, dc);",
          "",
          "[Added Lines]",
          "1313:   trimmed += __wait_one_discard_bio(sbi, dc);",
          "1317:  return trimmed;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1665:    f2fs_issue_discard(sbi, entry->start_blkaddr + cur_pos,",
          "1666:          len);",
          "1668:    total_len += len;",
          "1669:   } else {",
          "1670:    next_pos = find_next_bit_le(entry->discard_map,",
          "",
          "[Removed Lines]",
          "1667:    cpc->trimmed += len;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2367:  block_t start_block, end_block;",
          "2368:  struct cp_control cpc;",
          "2369:  struct discard_policy dpolicy;",
          "2370:  int err = 0;",
          "2372:  if (start >= MAX_BLKADDR(sbi) || range->len < sbi->blocksize)",
          "2373:   return -EINVAL;",
          "2376:  if (end <= MAIN_BLKADDR(sbi))",
          "2377:   goto out;",
          "",
          "[Removed Lines]",
          "2375:  cpc.trimmed = 0;",
          "",
          "[Added Lines]",
          "2380:  unsigned long long trimmed = 0;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2420:  init_discard_policy(&dpolicy, DPOLICY_FSTRIM, cpc.trim_minlen);",
          "2421:  __issue_discard_cmd_range(sbi, &dpolicy, start_block, end_block);",
          "2423: out:",
          "2425:  return err;",
          "2426: }",
          "",
          "[Removed Lines]",
          "2422:  __wait_discard_cmd_range(sbi, &dpolicy, start_block, end_block);",
          "2424:  range->len = F2FS_BLK_TO_BYTES(cpc.trimmed);",
          "",
          "[Added Lines]",
          "2432:  trimmed = __wait_discard_cmd_range(sbi, &dpolicy,",
          "2433:      start_block, end_block);",
          "2435:  range->len = F2FS_BLK_TO_BYTES(trimmed);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
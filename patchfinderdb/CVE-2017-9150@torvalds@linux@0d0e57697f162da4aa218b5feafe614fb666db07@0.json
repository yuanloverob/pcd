{
  "cve_id": "CVE-2017-9150",
  "cve_desc": "The do_check function in kernel/bpf/verifier.c in the Linux kernel before 4.11.1 does not make the allow_ptr_leaks value available for restricting the output of the print_bpf_insn function, which allows local users to obtain sensitive address information via crafted bpf system calls.",
  "repo": "torvalds/linux",
  "patch_hash": "0d0e57697f162da4aa218b5feafe614fb666db07",
  "patch_info": {
    "commit_hash": "0d0e57697f162da4aa218b5feafe614fb666db07",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/0d0e57697f162da4aa218b5feafe614fb666db07",
    "files": [
      "kernel/bpf/verifier.c"
    ],
    "message": "bpf: don't let ldimm64 leak map addresses on unprivileged\n\nThe patch fixes two things at once:\n\n1) It checks the env->allow_ptr_leaks and only prints the map address to\n   the log if we have the privileges to do so, otherwise it just dumps 0\n   as we would when kptr_restrict is enabled on %pK. Given the latter is\n   off by default and not every distro sets it, I don't want to rely on\n   this, hence the 0 by default for unprivileged.\n\n2) Printing of ldimm64 in the verifier log is currently broken in that\n   we don't print the full immediate, but only the 32 bit part of the\n   first insn part for ldimm64. Thus, fix this up as well; it's okay to\n   access, since we verified all ldimm64 earlier already (including just\n   constants) through replace_map_fd_with_map_ptr().\n\nFixes: 1be7f75d1668 (\"bpf: enable non-root eBPF programs\")\nFixes: cbd357008604 (\"bpf: verifier (add ability to receive verification log)\")\nReported-by: Jann Horn <jannh@google.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
    ]
  },
  "patch_diff": {
    "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
      "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "298:  [BPF_EXIT >> 4] = \"exit\",",
      "299: };",
      "302: {",
      "303:  u8 class = BPF_CLASS(insn->code);",
      "",
      "[Removed Lines]",
      "301: static void print_bpf_insn(struct bpf_insn *insn)",
      "",
      "[Added Lines]",
      "301: static void print_bpf_insn(const struct bpf_verifier_env *env,",
      "302:       const struct bpf_insn *insn)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "362:     insn->code,",
      "363:     bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
      "364:     insn->src_reg, insn->imm);",
      "368:   } else {",
      "369:    verbose(\"BUG_ld_%02x\\n\", insn->code);",
      "370:    return;",
      "",
      "[Removed Lines]",
      "365:   } else if (BPF_MODE(insn->code) == BPF_IMM) {",
      "366:    verbose(\"(%02x) r%d = 0x%x\\n\",",
      "367:     insn->code, insn->dst_reg, insn->imm);",
      "",
      "[Added Lines]",
      "366:   } else if (BPF_MODE(insn->code) == BPF_IMM &&",
      "367:       BPF_SIZE(insn->code) == BPF_DW) {",
      "371:    u64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;",
      "372:    bool map_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD;",
      "374:    if (map_ptr && !env->allow_ptr_leaks)",
      "375:     imm = 0;",
      "377:    verbose(\"(%02x) r%d = 0x%llx\\n\", insn->code,",
      "378:     insn->dst_reg, (unsigned long long)imm);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2854:   if (log_level) {",
      "2855:    verbose(\"%d: \", insn_idx);",
      "2857:   }",
      "2859:   err = ext_analyzer_insn_hook(env, insn_idx, prev_insn_idx);",
      "",
      "[Removed Lines]",
      "2856:    print_bpf_insn(insn);",
      "",
      "[Added Lines]",
      "2867:    print_bpf_insn(env, insn);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f4ac7e0b5cc8d16004ac57ff679266d573f30f77",
      "candidate_info": {
        "commit_hash": "f4ac7e0b5cc8d16004ac57ff679266d573f30f77",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f4ac7e0b5cc8d16004ac57ff679266d573f30f77",
        "files": [
          "kernel/bpf/Makefile",
          "kernel/bpf/disasm.c",
          "kernel/bpf/disasm.h",
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf: move instruction printing into a separate file\n\nSeparate the instruction printing into a standalone source file.\nThis way sneaky code from tools/ can compile it in directly.\n\nSigned-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>\nReviewed-by: Simon Horman <simon.horman@netronome.com>\nAcked-by: Alexei Starovoitov <ast@kernel.org>\nAcked-by: Daniel Borkmann <daniel@iogearbox.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "kernel/bpf/disasm.c||kernel/bpf/disasm.c",
          "kernel/bpf/disasm.h||kernel/bpf/disasm.h",
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/bpf/disasm.c||kernel/bpf/disasm.c": [
          "File: kernel/bpf/disasm.c -> kernel/bpf/disasm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: #include <linux/bpf.h>",
          "16: #include \"disasm.h\"",
          "18: #define __BPF_FUNC_STR_FN(x) [BPF_FUNC_ ## x] = __stringify(bpf_ ## x)",
          "19: static const char * const func_id_str[] = {",
          "20:  __BPF_FUNC_MAPPER(__BPF_FUNC_STR_FN)",
          "21: };",
          "22: #undef __BPF_FUNC_STR_FN",
          "24: const char *func_id_name(int id)",
          "25: {",
          "26:  BUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);",
          "28:  if (id >= 0 && id < __BPF_FUNC_MAX_ID && func_id_str[id])",
          "29:   return func_id_str[id];",
          "30:  else",
          "31:   return \"unknown\";",
          "32: }",
          "34: const char *const bpf_class_string[8] = {",
          "35:  [BPF_LD]    = \"ld\",",
          "36:  [BPF_LDX]   = \"ldx\",",
          "37:  [BPF_ST]    = \"st\",",
          "38:  [BPF_STX]   = \"stx\",",
          "39:  [BPF_ALU]   = \"alu\",",
          "40:  [BPF_JMP]   = \"jmp\",",
          "41:  [BPF_RET]   = \"BUG\",",
          "42:  [BPF_ALU64] = \"alu64\",",
          "43: };",
          "45: const char *const bpf_alu_string[16] = {",
          "46:  [BPF_ADD >> 4]  = \"+=\",",
          "47:  [BPF_SUB >> 4]  = \"-=\",",
          "48:  [BPF_MUL >> 4]  = \"*=\",",
          "49:  [BPF_DIV >> 4]  = \"/=\",",
          "50:  [BPF_OR  >> 4]  = \"|=\",",
          "51:  [BPF_AND >> 4]  = \"&=\",",
          "52:  [BPF_LSH >> 4]  = \"<<=\",",
          "53:  [BPF_RSH >> 4]  = \">>=\",",
          "54:  [BPF_NEG >> 4]  = \"neg\",",
          "55:  [BPF_MOD >> 4]  = \"%=\",",
          "56:  [BPF_XOR >> 4]  = \"^=\",",
          "57:  [BPF_MOV >> 4]  = \"=\",",
          "58:  [BPF_ARSH >> 4] = \"s>>=\",",
          "59:  [BPF_END >> 4]  = \"endian\",",
          "60: };",
          "62: static const char *const bpf_ldst_string[] = {",
          "63:  [BPF_W >> 3]  = \"u32\",",
          "64:  [BPF_H >> 3]  = \"u16\",",
          "65:  [BPF_B >> 3]  = \"u8\",",
          "66:  [BPF_DW >> 3] = \"u64\",",
          "67: };",
          "69: static const char *const bpf_jmp_string[16] = {",
          "70:  [BPF_JA >> 4]   = \"jmp\",",
          "71:  [BPF_JEQ >> 4]  = \"==\",",
          "72:  [BPF_JGT >> 4]  = \">\",",
          "73:  [BPF_JLT >> 4]  = \"<\",",
          "74:  [BPF_JGE >> 4]  = \">=\",",
          "75:  [BPF_JLE >> 4]  = \"<=\",",
          "76:  [BPF_JSET >> 4] = \"&\",",
          "77:  [BPF_JNE >> 4]  = \"!=\",",
          "78:  [BPF_JSGT >> 4] = \"s>\",",
          "79:  [BPF_JSLT >> 4] = \"s<\",",
          "80:  [BPF_JSGE >> 4] = \"s>=\",",
          "81:  [BPF_JSLE >> 4] = \"s<=\",",
          "82:  [BPF_CALL >> 4] = \"call\",",
          "83:  [BPF_EXIT >> 4] = \"exit\",",
          "84: };",
          "86: static void print_bpf_end_insn(bpf_insn_print_cb verbose,",
          "87:           struct bpf_verifier_env *env,",
          "88:           const struct bpf_insn *insn)",
          "89: {",
          "90:  verbose(env, \"(%02x) r%d = %s%d r%d\\n\", insn->code, insn->dst_reg,",
          "91:   BPF_SRC(insn->code) == BPF_TO_BE ? \"be\" : \"le\",",
          "92:   insn->imm, insn->dst_reg);",
          "93: }",
          "95: void print_bpf_insn(bpf_insn_print_cb verbose, struct bpf_verifier_env *env,",
          "96:       const struct bpf_insn *insn, bool allow_ptr_leaks)",
          "97: {",
          "98:  u8 class = BPF_CLASS(insn->code);",
          "100:  if (class == BPF_ALU || class == BPF_ALU64) {",
          "101:   if (BPF_OP(insn->code) == BPF_END) {",
          "102:    if (class == BPF_ALU64)",
          "103:     verbose(env, \"BUG_alu64_%02x\\n\", insn->code);",
          "104:    else",
          "105:     print_bpf_end_insn(verbose, env, insn);",
          "106:   } else if (BPF_OP(insn->code) == BPF_NEG) {",
          "107:    verbose(env, \"(%02x) r%d = %s-r%d\\n\",",
          "108:     insn->code, insn->dst_reg,",
          "109:     class == BPF_ALU ? \"(u32) \" : \"\",",
          "110:     insn->dst_reg);",
          "111:   } else if (BPF_SRC(insn->code) == BPF_X) {",
          "112:    verbose(env, \"(%02x) %sr%d %s %sr%d\\n\",",
          "113:     insn->code, class == BPF_ALU ? \"(u32) \" : \"\",",
          "114:     insn->dst_reg,",
          "115:     bpf_alu_string[BPF_OP(insn->code) >> 4],",
          "116:     class == BPF_ALU ? \"(u32) \" : \"\",",
          "117:     insn->src_reg);",
          "118:   } else {",
          "119:    verbose(env, \"(%02x) %sr%d %s %s%d\\n\",",
          "120:     insn->code, class == BPF_ALU ? \"(u32) \" : \"\",",
          "121:     insn->dst_reg,",
          "122:     bpf_alu_string[BPF_OP(insn->code) >> 4],",
          "123:     class == BPF_ALU ? \"(u32) \" : \"\",",
          "124:     insn->imm);",
          "125:   }",
          "126:  } else if (class == BPF_STX) {",
          "127:   if (BPF_MODE(insn->code) == BPF_MEM)",
          "128:    verbose(env, \"(%02x) *(%s *)(r%d %+d) = r%d\\n\",",
          "129:     insn->code,",
          "130:     bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "131:     insn->dst_reg,",
          "132:     insn->off, insn->src_reg);",
          "133:   else if (BPF_MODE(insn->code) == BPF_XADD)",
          "134:    verbose(env, \"(%02x) lock *(%s *)(r%d %+d) += r%d\\n\",",
          "135:     insn->code,",
          "136:     bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "137:     insn->dst_reg, insn->off,",
          "138:     insn->src_reg);",
          "139:   else",
          "140:    verbose(env, \"BUG_%02x\\n\", insn->code);",
          "141:  } else if (class == BPF_ST) {",
          "142:   if (BPF_MODE(insn->code) != BPF_MEM) {",
          "143:    verbose(env, \"BUG_st_%02x\\n\", insn->code);",
          "144:    return;",
          "145:   }",
          "146:   verbose(env, \"(%02x) *(%s *)(r%d %+d) = %d\\n\",",
          "147:    insn->code,",
          "148:    bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "149:    insn->dst_reg,",
          "150:    insn->off, insn->imm);",
          "151:  } else if (class == BPF_LDX) {",
          "152:   if (BPF_MODE(insn->code) != BPF_MEM) {",
          "153:    verbose(env, \"BUG_ldx_%02x\\n\", insn->code);",
          "154:    return;",
          "155:   }",
          "156:   verbose(env, \"(%02x) r%d = *(%s *)(r%d %+d)\\n\",",
          "157:    insn->code, insn->dst_reg,",
          "158:    bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "159:    insn->src_reg, insn->off);",
          "160:  } else if (class == BPF_LD) {",
          "161:   if (BPF_MODE(insn->code) == BPF_ABS) {",
          "162:    verbose(env, \"(%02x) r0 = *(%s *)skb[%d]\\n\",",
          "163:     insn->code,",
          "164:     bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "165:     insn->imm);",
          "166:   } else if (BPF_MODE(insn->code) == BPF_IND) {",
          "167:    verbose(env, \"(%02x) r0 = *(%s *)skb[r%d + %d]\\n\",",
          "168:     insn->code,",
          "169:     bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "170:     insn->src_reg, insn->imm);",
          "171:   } else if (BPF_MODE(insn->code) == BPF_IMM &&",
          "172:       BPF_SIZE(insn->code) == BPF_DW) {",
          "176:    u64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;",
          "177:    bool map_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD;",
          "179:    if (map_ptr && !allow_ptr_leaks)",
          "180:     imm = 0;",
          "182:    verbose(env, \"(%02x) r%d = 0x%llx\\n\", insn->code,",
          "183:     insn->dst_reg, (unsigned long long)imm);",
          "184:   } else {",
          "185:    verbose(env, \"BUG_ld_%02x\\n\", insn->code);",
          "186:    return;",
          "187:   }",
          "188:  } else if (class == BPF_JMP) {",
          "189:   u8 opcode = BPF_OP(insn->code);",
          "191:   if (opcode == BPF_CALL) {",
          "192:    verbose(env, \"(%02x) call %s#%d\\n\", insn->code,",
          "193:     func_id_name(insn->imm), insn->imm);",
          "194:   } else if (insn->code == (BPF_JMP | BPF_JA)) {",
          "195:    verbose(env, \"(%02x) goto pc%+d\\n\",",
          "196:     insn->code, insn->off);",
          "197:   } else if (insn->code == (BPF_JMP | BPF_EXIT)) {",
          "198:    verbose(env, \"(%02x) exit\\n\", insn->code);",
          "199:   } else if (BPF_SRC(insn->code) == BPF_X) {",
          "200:    verbose(env, \"(%02x) if r%d %s r%d goto pc%+d\\n\",",
          "201:     insn->code, insn->dst_reg,",
          "202:     bpf_jmp_string[BPF_OP(insn->code) >> 4],",
          "203:     insn->src_reg, insn->off);",
          "204:   } else {",
          "205:    verbose(env, \"(%02x) if r%d %s 0x%x goto pc%+d\\n\",",
          "206:     insn->code, insn->dst_reg,",
          "207:     bpf_jmp_string[BPF_OP(insn->code) >> 4],",
          "208:     insn->imm, insn->off);",
          "209:   }",
          "210:  } else {",
          "211:   verbose(env, \"(%02x) %s\\n\",",
          "212:    insn->code, bpf_class_string[class]);",
          "213:  }",
          "214: }",
          "",
          "---------------"
        ],
        "kernel/bpf/disasm.h||kernel/bpf/disasm.h": [
          "File: kernel/bpf/disasm.h -> kernel/bpf/disasm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: #ifndef __BPF_DISASM_H__",
          "15: #define __BPF_DISASM_H__",
          "17: #include <linux/bpf.h>",
          "18: #include <linux/kernel.h>",
          "19: #include <linux/stringify.h>",
          "21: extern const char *const bpf_alu_string[16];",
          "22: extern const char *const bpf_class_string[8];",
          "24: const char *func_id_name(int id);",
          "26: struct bpf_verifier_env;",
          "27: typedef void (*bpf_insn_print_cb)(struct bpf_verifier_env *env,",
          "28:       const char *, ...);",
          "29: void print_bpf_insn(bpf_insn_print_cb verbose, struct bpf_verifier_env *env,",
          "30:       const struct bpf_insn *insn, bool allow_ptr_leaks);",
          "32: #endif",
          "",
          "---------------"
        ],
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: #include <linux/vmalloc.h>",
          "22: #include <linux/stringify.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: #include \"disasm.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "194:  [PTR_TO_PACKET_END] = \"pkt_end\",",
          "195: };",
          "213: static void print_verifier_state(struct bpf_verifier_env *env,",
          "214:      struct bpf_verifier_state *state)",
          "215: {",
          "",
          "[Removed Lines]",
          "197: #define __BPF_FUNC_STR_FN(x) [BPF_FUNC_ ## x] = __stringify(bpf_ ## x)",
          "198: static const char * const func_id_str[] = {",
          "199:  __BPF_FUNC_MAPPER(__BPF_FUNC_STR_FN)",
          "200: };",
          "201: #undef __BPF_FUNC_STR_FN",
          "203: static const char *func_id_name(int id)",
          "204: {",
          "205:  BUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);",
          "207:  if (id >= 0 && id < __BPF_FUNC_MAX_ID && func_id_str[id])",
          "208:   return func_id_str[id];",
          "209:  else",
          "210:   return \"unknown\";",
          "211: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "278:  verbose(env, \"\\n\");",
          "279: }",
          "462: static int pop_stack(struct bpf_verifier_env *env, int *prev_insn_idx)",
          "463: {",
          "464:  struct bpf_verifier_stack_elem *elem;",
          "",
          "[Removed Lines]",
          "281: static const char *const bpf_class_string[] = {",
          "282:  [BPF_LD]    = \"ld\",",
          "283:  [BPF_LDX]   = \"ldx\",",
          "284:  [BPF_ST]    = \"st\",",
          "285:  [BPF_STX]   = \"stx\",",
          "286:  [BPF_ALU]   = \"alu\",",
          "287:  [BPF_JMP]   = \"jmp\",",
          "288:  [BPF_RET]   = \"BUG\",",
          "289:  [BPF_ALU64] = \"alu64\",",
          "290: };",
          "292: static const char *const bpf_alu_string[16] = {",
          "293:  [BPF_ADD >> 4]  = \"+=\",",
          "294:  [BPF_SUB >> 4]  = \"-=\",",
          "295:  [BPF_MUL >> 4]  = \"*=\",",
          "296:  [BPF_DIV >> 4]  = \"/=\",",
          "297:  [BPF_OR  >> 4]  = \"|=\",",
          "298:  [BPF_AND >> 4]  = \"&=\",",
          "299:  [BPF_LSH >> 4]  = \"<<=\",",
          "300:  [BPF_RSH >> 4]  = \">>=\",",
          "301:  [BPF_NEG >> 4]  = \"neg\",",
          "302:  [BPF_MOD >> 4]  = \"%=\",",
          "303:  [BPF_XOR >> 4]  = \"^=\",",
          "304:  [BPF_MOV >> 4]  = \"=\",",
          "305:  [BPF_ARSH >> 4] = \"s>>=\",",
          "306:  [BPF_END >> 4]  = \"endian\",",
          "307: };",
          "309: static const char *const bpf_ldst_string[] = {",
          "310:  [BPF_W >> 3]  = \"u32\",",
          "311:  [BPF_H >> 3]  = \"u16\",",
          "312:  [BPF_B >> 3]  = \"u8\",",
          "313:  [BPF_DW >> 3] = \"u64\",",
          "314: };",
          "316: static const char *const bpf_jmp_string[16] = {",
          "317:  [BPF_JA >> 4]   = \"jmp\",",
          "318:  [BPF_JEQ >> 4]  = \"==\",",
          "319:  [BPF_JGT >> 4]  = \">\",",
          "320:  [BPF_JLT >> 4]  = \"<\",",
          "321:  [BPF_JGE >> 4]  = \">=\",",
          "322:  [BPF_JLE >> 4]  = \"<=\",",
          "323:  [BPF_JSET >> 4] = \"&\",",
          "324:  [BPF_JNE >> 4]  = \"!=\",",
          "325:  [BPF_JSGT >> 4] = \"s>\",",
          "326:  [BPF_JSLT >> 4] = \"s<\",",
          "327:  [BPF_JSGE >> 4] = \"s>=\",",
          "328:  [BPF_JSLE >> 4] = \"s<=\",",
          "329:  [BPF_CALL >> 4] = \"call\",",
          "330:  [BPF_EXIT >> 4] = \"exit\",",
          "331: };",
          "333: static void print_bpf_end_insn(struct bpf_verifier_env *env,",
          "334:           const struct bpf_insn *insn)",
          "335: {",
          "336:  verbose(env, \"(%02x) r%d = %s%d r%d\\n\", insn->code, insn->dst_reg,",
          "337:   BPF_SRC(insn->code) == BPF_TO_BE ? \"be\" : \"le\",",
          "338:   insn->imm, insn->dst_reg);",
          "339: }",
          "341: static void print_bpf_insn(struct bpf_verifier_env *env,",
          "342:       const struct bpf_insn *insn)",
          "343: {",
          "344:  u8 class = BPF_CLASS(insn->code);",
          "346:  if (class == BPF_ALU || class == BPF_ALU64) {",
          "347:   if (BPF_OP(insn->code) == BPF_END) {",
          "348:    if (class == BPF_ALU64)",
          "349:     verbose(env, \"BUG_alu64_%02x\\n\", insn->code);",
          "350:    else",
          "351:     print_bpf_end_insn(env, insn);",
          "352:   } else if (BPF_OP(insn->code) == BPF_NEG) {",
          "353:    verbose(env, \"(%02x) r%d = %s-r%d\\n\",",
          "354:     insn->code, insn->dst_reg,",
          "355:     class == BPF_ALU ? \"(u32) \" : \"\",",
          "356:     insn->dst_reg);",
          "357:   } else if (BPF_SRC(insn->code) == BPF_X) {",
          "358:    verbose(env, \"(%02x) %sr%d %s %sr%d\\n\",",
          "359:     insn->code, class == BPF_ALU ? \"(u32) \" : \"\",",
          "360:     insn->dst_reg,",
          "361:     bpf_alu_string[BPF_OP(insn->code) >> 4],",
          "362:     class == BPF_ALU ? \"(u32) \" : \"\",",
          "363:     insn->src_reg);",
          "364:   } else {",
          "365:    verbose(env, \"(%02x) %sr%d %s %s%d\\n\",",
          "366:     insn->code, class == BPF_ALU ? \"(u32) \" : \"\",",
          "367:     insn->dst_reg,",
          "368:     bpf_alu_string[BPF_OP(insn->code) >> 4],",
          "369:     class == BPF_ALU ? \"(u32) \" : \"\",",
          "370:     insn->imm);",
          "371:   }",
          "372:  } else if (class == BPF_STX) {",
          "373:   if (BPF_MODE(insn->code) == BPF_MEM)",
          "374:    verbose(env, \"(%02x) *(%s *)(r%d %+d) = r%d\\n\",",
          "375:     insn->code,",
          "376:     bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "377:     insn->dst_reg,",
          "378:     insn->off, insn->src_reg);",
          "379:   else if (BPF_MODE(insn->code) == BPF_XADD)",
          "380:    verbose(env, \"(%02x) lock *(%s *)(r%d %+d) += r%d\\n\",",
          "381:     insn->code,",
          "382:     bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "383:     insn->dst_reg, insn->off,",
          "384:     insn->src_reg);",
          "385:   else",
          "386:    verbose(env, \"BUG_%02x\\n\", insn->code);",
          "387:  } else if (class == BPF_ST) {",
          "388:   if (BPF_MODE(insn->code) != BPF_MEM) {",
          "389:    verbose(env, \"BUG_st_%02x\\n\", insn->code);",
          "390:    return;",
          "391:   }",
          "392:   verbose(env, \"(%02x) *(%s *)(r%d %+d) = %d\\n\",",
          "393:    insn->code,",
          "394:    bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "395:    insn->dst_reg,",
          "396:    insn->off, insn->imm);",
          "397:  } else if (class == BPF_LDX) {",
          "398:   if (BPF_MODE(insn->code) != BPF_MEM) {",
          "399:    verbose(env, \"BUG_ldx_%02x\\n\", insn->code);",
          "400:    return;",
          "401:   }",
          "402:   verbose(env, \"(%02x) r%d = *(%s *)(r%d %+d)\\n\",",
          "403:    insn->code, insn->dst_reg,",
          "404:    bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "405:    insn->src_reg, insn->off);",
          "406:  } else if (class == BPF_LD) {",
          "407:   if (BPF_MODE(insn->code) == BPF_ABS) {",
          "408:    verbose(env, \"(%02x) r0 = *(%s *)skb[%d]\\n\",",
          "409:     insn->code,",
          "410:     bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "411:     insn->imm);",
          "412:   } else if (BPF_MODE(insn->code) == BPF_IND) {",
          "413:    verbose(env, \"(%02x) r0 = *(%s *)skb[r%d + %d]\\n\",",
          "414:     insn->code,",
          "415:     bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "416:     insn->src_reg, insn->imm);",
          "417:   } else if (BPF_MODE(insn->code) == BPF_IMM &&",
          "418:       BPF_SIZE(insn->code) == BPF_DW) {",
          "422:    u64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;",
          "423:    bool map_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD;",
          "425:    if (map_ptr && !env->allow_ptr_leaks)",
          "426:     imm = 0;",
          "428:    verbose(env, \"(%02x) r%d = 0x%llx\\n\", insn->code,",
          "429:     insn->dst_reg, (unsigned long long)imm);",
          "430:   } else {",
          "431:    verbose(env, \"BUG_ld_%02x\\n\", insn->code);",
          "432:    return;",
          "433:   }",
          "434:  } else if (class == BPF_JMP) {",
          "435:   u8 opcode = BPF_OP(insn->code);",
          "437:   if (opcode == BPF_CALL) {",
          "438:    verbose(env, \"(%02x) call %s#%d\\n\", insn->code,",
          "439:     func_id_name(insn->imm), insn->imm);",
          "440:   } else if (insn->code == (BPF_JMP | BPF_JA)) {",
          "441:    verbose(env, \"(%02x) goto pc%+d\\n\",",
          "442:     insn->code, insn->off);",
          "443:   } else if (insn->code == (BPF_JMP | BPF_EXIT)) {",
          "444:    verbose(env, \"(%02x) exit\\n\", insn->code);",
          "445:   } else if (BPF_SRC(insn->code) == BPF_X) {",
          "446:    verbose(env, \"(%02x) if r%d %s r%d goto pc%+d\\n\",",
          "447:     insn->code, insn->dst_reg,",
          "448:     bpf_jmp_string[BPF_OP(insn->code) >> 4],",
          "449:     insn->src_reg, insn->off);",
          "450:   } else {",
          "451:    verbose(env, \"(%02x) if r%d %s 0x%x goto pc%+d\\n\",",
          "452:     insn->code, insn->dst_reg,",
          "453:     bpf_jmp_string[BPF_OP(insn->code) >> 4],",
          "454:     insn->imm, insn->off);",
          "455:   }",
          "456:  } else {",
          "457:   verbose(env, \"(%02x) %s\\n\",",
          "458:    insn->code, bpf_class_string[class]);",
          "459:  }",
          "460: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3768:   if (env->log.level) {",
          "3769:    verbose(env, \"%d: \", insn_idx);",
          "3771:   }",
          "3773:   err = ext_analyzer_insn_hook(env, insn_idx, prev_insn_idx);",
          "",
          "[Removed Lines]",
          "3770:    print_bpf_insn(env, insn);",
          "",
          "[Added Lines]",
          "3575:    print_bpf_insn(verbose, env, insn,",
          "3576:            env->allow_ptr_leaks);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7105e828c087de970fcb5a9509db51bfe6bd7894",
      "candidate_info": {
        "commit_hash": "7105e828c087de970fcb5a9509db51bfe6bd7894",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7105e828c087de970fcb5a9509db51bfe6bd7894",
        "files": [
          "include/linux/filter.h",
          "kernel/bpf/core.c",
          "kernel/bpf/disasm.c",
          "kernel/bpf/disasm.h",
          "kernel/bpf/syscall.c",
          "kernel/bpf/verifier.c",
          "tools/bpf/bpftool/prog.c"
        ],
        "message": "bpf: allow for correlation of maps and helpers in dump\n\nCurrently a dump of an xlated prog (post verifier stage) doesn't\ncorrelate used helpers as well as maps. The prog info lists\ninvolved map ids, however there's no correlation of where in the\nprogram they are used as of today. Likewise, bpftool does not\ncorrelate helper calls with the target functions.\n\nThe latter can be done w/o any kernel changes through kallsyms,\nand also has the advantage that this works with inlined helpers\nand BPF calls.\n\nExample, via interpreter:\n\n  # tc filter show dev foo ingress\n  filter protocol all pref 49152 bpf chain 0\n  filter protocol all pref 49152 bpf chain 0 handle 0x1 foo.o:[ingress] \\\n                      direct-action not_in_hw id 1 tag c74773051b364165   <-- prog id:1\n\n  * Output before patch (calls/maps remain unclear):\n\n  # bpftool prog dump xlated id 1             <-- dump prog id:1\n   0: (b7) r1 = 2\n   1: (63) *(u32 *)(r10 -4) = r1\n   2: (bf) r2 = r10\n   3: (07) r2 += -4\n   4: (18) r1 = 0xffff95c47a8d4800\n   6: (85) call unknown#73040\n   7: (15) if r0 == 0x0 goto pc+18\n   8: (bf) r2 = r10\n   9: (07) r2 += -4\n  10: (bf) r1 = r0\n  11: (85) call unknown#73040\n  12: (15) if r0 == 0x0 goto pc+23\n  [...]\n\n  * Output after patch:\n\n  # bpftool prog dump xlated id 1\n   0: (b7) r1 = 2\n   1: (63) *(u32 *)(r10 -4) = r1\n   2: (bf) r2 = r10\n   3: (07) r2 += -4\n   4: (18) r1 = map[id:2]                     <-- map id:2\n   6: (85) call bpf_map_lookup_elem#73424     <-- helper call\n   7: (15) if r0 == 0x0 goto pc+18\n   8: (bf) r2 = r10\n   9: (07) r2 += -4\n  10: (bf) r1 = r0\n  11: (85) call bpf_map_lookup_elem#73424\n  12: (15) if r0 == 0x0 goto pc+23\n  [...]\n\n  # bpftool map show id 2                     <-- show/dump/etc map id:2\n  2: hash_of_maps  flags 0x0\n        key 4B  value 4B  max_entries 3  memlock 4096B\n\nExample, JITed, same prog:\n\n  # tc filter show dev foo ingress\n  filter protocol all pref 49152 bpf chain 0\n  filter protocol all pref 49152 bpf chain 0 handle 0x1 foo.o:[ingress] \\\n                  direct-action not_in_hw id 3 tag c74773051b364165 jited\n\n  # bpftool prog show id 3\n  3: sched_cls  tag c74773051b364165\n        loaded_at Dec 19/13:48  uid 0\n        xlated 384B  jited 257B  memlock 4096B  map_ids 2\n\n  # bpftool prog dump xlated id 3\n   0: (b7) r1 = 2\n   1: (63) *(u32 *)(r10 -4) = r1\n   2: (bf) r2 = r10\n   3: (07) r2 += -4\n   4: (18) r1 = map[id:2]                      <-- map id:2\n   6: (85) call __htab_map_lookup_elem#77408   <-+ inlined rewrite\n   7: (15) if r0 == 0x0 goto pc+2                |\n   8: (07) r0 += 56                              |\n   9: (79) r0 = *(u64 *)(r0 +0)                <-+\n  10: (15) if r0 == 0x0 goto pc+24\n  11: (bf) r2 = r10\n  12: (07) r2 += -4\n  [...]\n\nExample, same prog, but kallsyms disabled (in that case we are\nalso not allowed to pass any relative offsets, etc, so prog\nbecomes pointer sanitized on dump):\n\n  # sysctl kernel.kptr_restrict=2\n  kernel.kptr_restrict = 2\n\n  # bpftool prog dump xlated id 3\n   0: (b7) r1 = 2\n   1: (63) *(u32 *)(r10 -4) = r1\n   2: (bf) r2 = r10\n   3: (07) r2 += -4\n   4: (18) r1 = map[id:2]\n   6: (85) call bpf_unspec#0\n   7: (15) if r0 == 0x0 goto pc+2\n  [...]\n\nExample, BPF calls via interpreter:\n\n  # bpftool prog dump xlated id 1\n   0: (85) call pc+2#__bpf_prog_run_args32\n   1: (b7) r0 = 1\n   2: (95) exit\n   3: (b7) r0 = 2\n   4: (95) exit\n\nExample, BPF calls via JIT:\n\n  # sysctl net.core.bpf_jit_enable=1\n  net.core.bpf_jit_enable = 1\n  # sysctl net.core.bpf_jit_kallsyms=1\n  net.core.bpf_jit_kallsyms = 1\n\n  # bpftool prog dump xlated id 1\n   0: (85) call pc+2#bpf_prog_3b185187f1855c4c_F\n   1: (b7) r0 = 1\n   2: (95) exit\n   3: (b7) r0 = 2\n   4: (95) exit\n\nAnd finally, an example for tail calls that is now working\nas well wrt correlation:\n\n  # bpftool prog dump xlated id 2\n  [...]\n  10: (b7) r2 = 8\n  11: (85) call bpf_trace_printk#-41312\n  12: (bf) r1 = r6\n  13: (18) r2 = map[id:1]\n  15: (b7) r3 = 0\n  16: (85) call bpf_tail_call#12\n  17: (b7) r1 = 42\n  18: (6b) *(u16 *)(r6 +46) = r1\n  19: (b7) r0 = 0\n  20: (95) exit\n\n  # bpftool map show id 1\n  1: prog_array  flags 0x0\n        key 4B  value 4B  max_entries 1  memlock 4096B\n\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
        "before_after_code_files": [
          "include/linux/filter.h||include/linux/filter.h",
          "kernel/bpf/core.c||kernel/bpf/core.c",
          "kernel/bpf/disasm.c||kernel/bpf/disasm.c",
          "kernel/bpf/disasm.h||kernel/bpf/disasm.h",
          "kernel/bpf/syscall.c||kernel/bpf/syscall.c",
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c",
          "tools/bpf/bpftool/prog.c||tools/bpf/bpftool/prog.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/filter.h||include/linux/filter.h": [
          "File: include/linux/filter.h -> include/linux/filter.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #include <linux/capability.h>",
          "19: #include <linux/cryptohash.h>",
          "20: #include <linux/set_memory.h>",
          "22: #include <net/sch_generic.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21: #include <linux/kallsyms.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "724: void bpf_jit_compile(struct bpf_prog *prog);",
          "725: bool bpf_helper_changes_pkt_data(void *func);",
          "727: struct bpf_prog *bpf_patch_insn_single(struct bpf_prog *prog, u32 off,",
          "728:            const struct bpf_insn *patch, u32 len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "728: static inline bool bpf_dump_raw_ok(void)",
          "729: {",
          "733:  return kallsyms_show_value() == 1;",
          "734: }",
          "",
          "---------------"
        ],
        "kernel/bpf/core.c||kernel/bpf/core.c": [
          "File: kernel/bpf/core.c -> kernel/bpf/core.c"
        ],
        "kernel/bpf/disasm.c||kernel/bpf/disasm.c": [
          "File: kernel/bpf/disasm.c -> kernel/bpf/disasm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: };",
          "22: #undef __BPF_FUNC_STR_FN",
          "25: {",
          "26:  BUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);",
          "28:  if (id >= 0 && id < __BPF_FUNC_MAX_ID && func_id_str[id])",
          "29:   return func_id_str[id];",
          "30:  else",
          "",
          "[Removed Lines]",
          "24: const char *func_id_name(int id)",
          "",
          "[Added Lines]",
          "24: static const char *__func_get_name(const struct bpf_insn_cbs *cbs,",
          "25:        const struct bpf_insn *insn,",
          "26:        char *buff, size_t len)",
          "30:  if (insn->src_reg != BPF_PSEUDO_CALL &&",
          "31:      insn->imm >= 0 && insn->imm < __BPF_FUNC_MAX_ID &&",
          "32:      func_id_str[insn->imm])",
          "33:   return func_id_str[insn->imm];",
          "35:  if (cbs && cbs->cb_call)",
          "36:   return cbs->cb_call(cbs->private_data, insn);",
          "38:  if (insn->src_reg == BPF_PSEUDO_CALL)",
          "39:   snprintf(buff, len, \"%+d\", insn->imm);",
          "41:  return buff;",
          "42: }",
          "44: static const char *__func_imm_name(const struct bpf_insn_cbs *cbs,",
          "45:        const struct bpf_insn *insn,",
          "46:        u64 full_imm, char *buff, size_t len)",
          "47: {",
          "48:  if (cbs && cbs->cb_imm)",
          "49:   return cbs->cb_imm(cbs->private_data, insn, full_imm);",
          "51:  snprintf(buff, len, \"0x%llx\", (unsigned long long)full_imm);",
          "52:  return buff;",
          "53: }",
          "55: const char *func_id_name(int id)",
          "56: {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "83:  [BPF_EXIT >> 4] = \"exit\",",
          "84: };",
          "87:           struct bpf_verifier_env *env,",
          "88:           const struct bpf_insn *insn)",
          "89: {",
          "",
          "[Removed Lines]",
          "86: static void print_bpf_end_insn(bpf_insn_print_cb verbose,",
          "",
          "[Added Lines]",
          "115: static void print_bpf_end_insn(bpf_insn_print_t verbose,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "92:   insn->imm, insn->dst_reg);",
          "93: }",
          "97: {",
          "98:  u8 class = BPF_CLASS(insn->code);",
          "100:  if (class == BPF_ALU || class == BPF_ALU64) {",
          "",
          "[Removed Lines]",
          "95: void print_bpf_insn(bpf_insn_print_cb verbose, struct bpf_verifier_env *env,",
          "96:       const struct bpf_insn *insn, bool allow_ptr_leaks)",
          "",
          "[Added Lines]",
          "124: void print_bpf_insn(const struct bpf_insn_cbs *cbs,",
          "125:       struct bpf_verifier_env *env,",
          "126:       const struct bpf_insn *insn,",
          "127:       bool allow_ptr_leaks)",
          "129:  const bpf_insn_print_t verbose = cbs->cb_print;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "176:    u64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;",
          "177:    bool map_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD;",
          "179:    if (map_ptr && !allow_ptr_leaks)",
          "180:     imm = 0;",
          "184:   } else {",
          "185:    verbose(env, \"BUG_ld_%02x\\n\", insn->code);",
          "186:    return;",
          "",
          "[Removed Lines]",
          "182:    verbose(env, \"(%02x) r%d = 0x%llx\\n\", insn->code,",
          "183:     insn->dst_reg, (unsigned long long)imm);",
          "",
          "[Added Lines]",
          "210:    char tmp[64];",
          "215:    verbose(env, \"(%02x) r%d = %s\\n\",",
          "216:     insn->code, insn->dst_reg,",
          "217:     __func_imm_name(cbs, insn, imm,",
          "218:       tmp, sizeof(tmp)));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "189:   u8 opcode = BPF_OP(insn->code);",
          "191:   if (opcode == BPF_CALL) {",
          "196:     verbose(env, \"(%02x) call %s#%d\\n\", insn->code,",
          "198:   } else if (insn->code == (BPF_JMP | BPF_JA)) {",
          "199:    verbose(env, \"(%02x) goto pc%+d\\n\",",
          "200:     insn->code, insn->off);",
          "",
          "[Removed Lines]",
          "192:    if (insn->src_reg == BPF_PSEUDO_CALL)",
          "193:     verbose(env, \"(%02x) call pc%+d\\n\", insn->code,",
          "194:      insn->imm);",
          "195:    else",
          "197:      func_id_name(insn->imm), insn->imm);",
          "",
          "[Added Lines]",
          "227:    char tmp[64];",
          "229:    if (insn->src_reg == BPF_PSEUDO_CALL) {",
          "230:     verbose(env, \"(%02x) call pc%s\\n\",",
          "231:      insn->code,",
          "232:      __func_get_name(cbs, insn,",
          "233:        tmp, sizeof(tmp)));",
          "234:    } else {",
          "235:     strcpy(tmp, \"unknown\");",
          "237:      __func_get_name(cbs, insn,",
          "238:        tmp, sizeof(tmp)),",
          "239:      insn->imm);",
          "240:    }",
          "",
          "---------------"
        ],
        "kernel/bpf/disasm.h||kernel/bpf/disasm.h": [
          "File: kernel/bpf/disasm.h -> kernel/bpf/disasm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: #include <linux/bpf.h>",
          "18: #include <linux/kernel.h>",
          "19: #include <linux/stringify.h>",
          "21: extern const char *const bpf_alu_string[16];",
          "22: extern const char *const bpf_class_string[8];",
          "24: const char *func_id_name(int id);",
          "32: #endif",
          "",
          "[Removed Lines]",
          "26: struct bpf_verifier_env;",
          "27: typedef void (*bpf_insn_print_cb)(struct bpf_verifier_env *env,",
          "28:       const char *, ...);",
          "29: void print_bpf_insn(bpf_insn_print_cb verbose, struct bpf_verifier_env *env,",
          "30:       const struct bpf_insn *insn, bool allow_ptr_leaks);",
          "",
          "[Added Lines]",
          "20: #ifndef __KERNEL__",
          "21: #include <stdio.h>",
          "22: #include <string.h>",
          "23: #endif",
          "25: struct bpf_verifier_env;",
          "32: typedef void (*bpf_insn_print_t)(struct bpf_verifier_env *env,",
          "33:      const char *, ...);",
          "34: typedef const char *(*bpf_insn_revmap_call_t)(void *private_data,",
          "35:            const struct bpf_insn *insn);",
          "36: typedef const char *(*bpf_insn_print_imm_t)(void *private_data,",
          "37:          const struct bpf_insn *insn,",
          "38:          __u64 full_imm);",
          "40: struct bpf_insn_cbs {",
          "41:  bpf_insn_print_t cb_print;",
          "42:  bpf_insn_revmap_call_t cb_call;",
          "43:  bpf_insn_print_imm_t cb_imm;",
          "44:  void   *private_data;",
          "45: };",
          "47: void print_bpf_insn(const struct bpf_insn_cbs *cbs,",
          "48:       struct bpf_verifier_env *env,",
          "49:       const struct bpf_insn *insn,",
          "50:       bool allow_ptr_leaks);",
          "",
          "---------------"
        ],
        "kernel/bpf/syscall.c||kernel/bpf/syscall.c": [
          "File: kernel/bpf/syscall.c -> kernel/bpf/syscall.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1558:  return fd;",
          "1559: }",
          "1561: static int bpf_prog_get_info_by_fd(struct bpf_prog *prog,",
          "1562:        const union bpf_attr *attr,",
          "1563:        union bpf_attr __user *uattr)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1561: static const struct bpf_map *bpf_map_from_imm(const struct bpf_prog *prog,",
          "1562:            unsigned long addr)",
          "1563: {",
          "1564:  int i;",
          "1566:  for (i = 0; i < prog->aux->used_map_cnt; i++)",
          "1567:   if (prog->aux->used_maps[i] == (void *)addr)",
          "1568:    return prog->aux->used_maps[i];",
          "1569:  return NULL;",
          "1570: }",
          "1572: static struct bpf_insn *bpf_insn_prepare_dump(const struct bpf_prog *prog)",
          "1573: {",
          "1574:  const struct bpf_map *map;",
          "1575:  struct bpf_insn *insns;",
          "1576:  u64 imm;",
          "1577:  int i;",
          "1579:  insns = kmemdup(prog->insnsi, bpf_prog_insn_size(prog),",
          "1580:    GFP_USER);",
          "1581:  if (!insns)",
          "1582:   return insns;",
          "1584:  for (i = 0; i < prog->len; i++) {",
          "1585:   if (insns[i].code == (BPF_JMP | BPF_TAIL_CALL)) {",
          "1586:    insns[i].code = BPF_JMP | BPF_CALL;",
          "1587:    insns[i].imm = BPF_FUNC_tail_call;",
          "1589:   }",
          "1590:   if (insns[i].code == (BPF_JMP | BPF_CALL) ||",
          "1591:       insns[i].code == (BPF_JMP | BPF_CALL_ARGS)) {",
          "1592:    if (insns[i].code == (BPF_JMP | BPF_CALL_ARGS))",
          "1593:     insns[i].code = BPF_JMP | BPF_CALL;",
          "1594:    if (!bpf_dump_raw_ok())",
          "1595:     insns[i].imm = 0;",
          "1596:    continue;",
          "1597:   }",
          "1599:   if (insns[i].code != (BPF_LD | BPF_IMM | BPF_DW))",
          "1600:    continue;",
          "1602:   imm = ((u64)insns[i + 1].imm << 32) | (u32)insns[i].imm;",
          "1603:   map = bpf_map_from_imm(prog, imm);",
          "1604:   if (map) {",
          "1605:    insns[i].src_reg = BPF_PSEUDO_MAP_FD;",
          "1606:    insns[i].imm = map->id;",
          "1607:    insns[i + 1].imm = 0;",
          "1608:    continue;",
          "1609:   }",
          "1611:   if (!bpf_dump_raw_ok() &&",
          "1612:       imm == (unsigned long)prog->aux) {",
          "1613:    insns[i].imm = 0;",
          "1614:    insns[i + 1].imm = 0;",
          "1615:    continue;",
          "1616:   }",
          "1617:  }",
          "1619:  return insns;",
          "1620: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1608:  ulen = info.jited_prog_len;",
          "1609:  info.jited_prog_len = prog->jited_len;",
          "1610:  if (info.jited_prog_len && ulen) {",
          "1615:  }",
          "1617:  ulen = info.xlated_prog_len;",
          "1618:  info.xlated_prog_len = bpf_prog_insn_size(prog);",
          "1619:  if (info.xlated_prog_len && ulen) {",
          "1620:   uinsns = u64_to_user_ptr(info.xlated_prog_insns);",
          "1621:   ulen = min_t(u32, info.xlated_prog_len, ulen);",
          "1623:    return -EFAULT;",
          "1624:  }",
          "",
          "[Removed Lines]",
          "1611:   uinsns = u64_to_user_ptr(info.jited_prog_insns);",
          "1612:   ulen = min_t(u32, info.jited_prog_len, ulen);",
          "1613:   if (copy_to_user(uinsns, prog->bpf_func, ulen))",
          "1614:    return -EFAULT;",
          "1622:   if (copy_to_user(uinsns, prog->insnsi, ulen))",
          "",
          "[Added Lines]",
          "1672:   if (bpf_dump_raw_ok()) {",
          "1673:    uinsns = u64_to_user_ptr(info.jited_prog_insns);",
          "1674:    ulen = min_t(u32, info.jited_prog_len, ulen);",
          "1675:    if (copy_to_user(uinsns, prog->bpf_func, ulen))",
          "1676:     return -EFAULT;",
          "1677:   } else {",
          "1678:    info.jited_prog_insns = 0;",
          "1679:   }",
          "1685:   struct bpf_insn *insns_sanitized;",
          "1686:   bool fault;",
          "1688:   if (prog->blinded && !bpf_dump_raw_ok()) {",
          "1689:    info.xlated_prog_insns = 0;",
          "1690:    goto done;",
          "1691:   }",
          "1692:   insns_sanitized = bpf_insn_prepare_dump(prog);",
          "1693:   if (!insns_sanitized)",
          "1694:    return -ENOMEM;",
          "1697:   fault = copy_to_user(uinsns, insns_sanitized, ulen);",
          "1698:   kfree(insns_sanitized);",
          "1699:   if (fault)",
          "",
          "---------------"
        ],
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4427:   }",
          "4429:   if (env->log.level) {",
          "4430:    verbose(env, \"%d: \", insn_idx);",
          "4433:   }",
          "4435:   err = ext_analyzer_insn_hook(env, insn_idx, prev_insn_idx);",
          "",
          "[Removed Lines]",
          "4431:    print_bpf_insn(verbose, env, insn,",
          "4432:            env->allow_ptr_leaks);",
          "",
          "[Added Lines]",
          "4430:    const struct bpf_insn_cbs cbs = {",
          "4431:     .cb_print = verbose,",
          "4432:    };",
          "4435:    print_bpf_insn(&cbs, env, insn, env->allow_ptr_leaks);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5017: {",
          "5018:  struct bpf_prog *prog = env->prog, **func, *tmp;",
          "5019:  int i, j, subprog_start, subprog_end = 0, len, subprog;",
          "5021:  void *old_bpf_func;",
          "5022:  int err = -ENOMEM;",
          "5024:  if (env->subprog_cnt == 0)",
          "5025:   return 0;",
          "5028:   if (insn->code != (BPF_JMP | BPF_CALL) ||",
          "5029:       insn->src_reg != BPF_PSEUDO_CALL)",
          "5030:    continue;",
          "",
          "[Removed Lines]",
          "5020:  struct bpf_insn *insn = prog->insnsi;",
          "5027:  for (i = 0; i < prog->len; i++, insn++) {",
          "",
          "[Added Lines]",
          "5023:  struct bpf_insn *insn;",
          "5030:  for (i = 0, insn = prog->insnsi; i < prog->len; i++, insn++) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "5116:   bpf_prog_lock_ro(func[i]);",
          "5117:   bpf_prog_kallsyms_add(func[i]);",
          "5118:  }",
          "5119:  prog->jited = 1;",
          "5120:  prog->bpf_func = func[0]->bpf_func;",
          "5121:  prog->aux->func = func;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5127:  for (i = 0, insn = prog->insnsi; i < prog->len; i++, insn++) {",
          "5128:   unsigned long addr;",
          "5130:   if (insn->code != (BPF_JMP | BPF_CALL) ||",
          "5131:       insn->src_reg != BPF_PSEUDO_CALL)",
          "5132:    continue;",
          "5133:   insn->off = env->insn_aux_data[i].call_imm;",
          "5134:   subprog = find_subprog(env, i + insn->off + 1);",
          "5135:   addr  = (unsigned long)func[subprog + 1]->bpf_func;",
          "5136:   addr &= PAGE_MASK;",
          "5137:   insn->imm = (u64 (*)(u64, u64, u64, u64, u64))",
          "5138:        addr - __bpf_call_base;",
          "5139:  }",
          "",
          "---------------"
        ],
        "tools/bpf/bpftool/prog.c||tools/bpf/bpftool/prog.c": [
          "File: tools/bpf/bpftool/prog.c -> tools/bpf/bpftool/prog.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "401:  return err;",
          "402: }",
          "404: static void print_insn(struct bpf_verifier_env *env, const char *fmt, ...)",
          "405: {",
          "406:  va_list args;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "404: #define SYM_MAX_NAME 256",
          "406: struct kernel_sym {",
          "407:  unsigned long address;",
          "408:  char name[SYM_MAX_NAME];",
          "409: };",
          "411: struct dump_data {",
          "412:  unsigned long address_call_base;",
          "413:  struct kernel_sym *sym_mapping;",
          "414:  __u32 sym_count;",
          "415:  char scratch_buff[SYM_MAX_NAME];",
          "416: };",
          "418: static int kernel_syms_cmp(const void *sym_a, const void *sym_b)",
          "419: {",
          "420:  return ((struct kernel_sym *)sym_a)->address -",
          "421:         ((struct kernel_sym *)sym_b)->address;",
          "422: }",
          "424: static void kernel_syms_load(struct dump_data *dd)",
          "425: {",
          "426:  struct kernel_sym *sym;",
          "427:  char buff[256];",
          "428:  void *tmp, *address;",
          "429:  FILE *fp;",
          "431:  fp = fopen(\"/proc/kallsyms\", \"r\");",
          "432:  if (!fp)",
          "433:   return;",
          "435:  while (!feof(fp)) {",
          "436:   if (!fgets(buff, sizeof(buff), fp))",
          "437:    break;",
          "438:   tmp = realloc(dd->sym_mapping,",
          "439:          (dd->sym_count + 1) *",
          "440:          sizeof(*dd->sym_mapping));",
          "441:   if (!tmp) {",
          "442: out:",
          "443:    free(dd->sym_mapping);",
          "444:    dd->sym_mapping = NULL;",
          "445:    fclose(fp);",
          "446:    return;",
          "447:   }",
          "448:   dd->sym_mapping = tmp;",
          "449:   sym = &dd->sym_mapping[dd->sym_count];",
          "450:   if (sscanf(buff, \"%p %*c %s\", &address, sym->name) != 2)",
          "451:    continue;",
          "452:   sym->address = (unsigned long)address;",
          "453:   if (!strcmp(sym->name, \"__bpf_call_base\")) {",
          "454:    dd->address_call_base = sym->address;",
          "456:    if (!sym->address)",
          "457:     goto out;",
          "458:   }",
          "459:   if (sym->address)",
          "460:    dd->sym_count++;",
          "461:  }",
          "463:  fclose(fp);",
          "465:  qsort(dd->sym_mapping, dd->sym_count,",
          "466:        sizeof(*dd->sym_mapping), kernel_syms_cmp);",
          "467: }",
          "469: static void kernel_syms_destroy(struct dump_data *dd)",
          "470: {",
          "471:  free(dd->sym_mapping);",
          "472: }",
          "474: static struct kernel_sym *kernel_syms_search(struct dump_data *dd,",
          "475:           unsigned long key)",
          "476: {",
          "477:  struct kernel_sym sym = {",
          "478:   .address = key,",
          "479:  };",
          "481:  return dd->sym_mapping ?",
          "482:         bsearch(&sym, dd->sym_mapping, dd->sym_count,",
          "483:          sizeof(*dd->sym_mapping), kernel_syms_cmp) : NULL;",
          "484: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "410:  va_end(args);",
          "411: }",
          "414: {",
          "415:  struct bpf_insn *insn = buf;",
          "416:  bool double_insn = false;",
          "417:  unsigned int i;",
          "",
          "[Removed Lines]",
          "413: static void dump_xlated_plain(void *buf, unsigned int len, bool opcodes)",
          "",
          "[Added Lines]",
          "495: static const char *print_call_pcrel(struct dump_data *dd,",
          "496:         struct kernel_sym *sym,",
          "497:         unsigned long address,",
          "498:         const struct bpf_insn *insn)",
          "500:  if (sym)",
          "501:   snprintf(dd->scratch_buff, sizeof(dd->scratch_buff),",
          "502:     \"%+d#%s\", insn->off, sym->name);",
          "503:  else",
          "504:   snprintf(dd->scratch_buff, sizeof(dd->scratch_buff),",
          "505:     \"%+d#0x%lx\", insn->off, address);",
          "506:  return dd->scratch_buff;",
          "507: }",
          "509: static const char *print_call_helper(struct dump_data *dd,",
          "510:          struct kernel_sym *sym,",
          "511:          unsigned long address)",
          "512: {",
          "513:  if (sym)",
          "514:   snprintf(dd->scratch_buff, sizeof(dd->scratch_buff),",
          "515:     \"%s\", sym->name);",
          "516:  else",
          "517:   snprintf(dd->scratch_buff, sizeof(dd->scratch_buff),",
          "518:     \"0x%lx\", address);",
          "519:  return dd->scratch_buff;",
          "520: }",
          "522: static const char *print_call(void *private_data,",
          "523:          const struct bpf_insn *insn)",
          "524: {",
          "525:  struct dump_data *dd = private_data;",
          "526:  unsigned long address = dd->address_call_base + insn->imm;",
          "527:  struct kernel_sym *sym;",
          "529:  sym = kernel_syms_search(dd, address);",
          "530:  if (insn->src_reg == BPF_PSEUDO_CALL)",
          "531:   return print_call_pcrel(dd, sym, address, insn);",
          "532:  else",
          "533:   return print_call_helper(dd, sym, address);",
          "534: }",
          "536: static const char *print_imm(void *private_data,",
          "537:         const struct bpf_insn *insn,",
          "538:         __u64 full_imm)",
          "539: {",
          "540:  struct dump_data *dd = private_data;",
          "542:  if (insn->src_reg == BPF_PSEUDO_MAP_FD)",
          "543:   snprintf(dd->scratch_buff, sizeof(dd->scratch_buff),",
          "544:     \"map[id:%u]\", insn->imm);",
          "545:  else",
          "546:   snprintf(dd->scratch_buff, sizeof(dd->scratch_buff),",
          "547:     \"0x%llx\", (unsigned long long)full_imm);",
          "548:  return dd->scratch_buff;",
          "549: }",
          "551: static void dump_xlated_plain(struct dump_data *dd, void *buf,",
          "552:          unsigned int len, bool opcodes)",
          "553: {",
          "554:  const struct bpf_insn_cbs cbs = {",
          "555:   .cb_print = print_insn,",
          "556:   .cb_call = print_call,",
          "557:   .cb_imm  = print_imm,",
          "558:   .private_data = dd,",
          "559:  };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "425:   double_insn = insn[i].code == (BPF_LD | BPF_IMM | BPF_DW);",
          "427:   printf(\"% 4d: \", i);",
          "430:   if (opcodes) {",
          "431:    printf(\"       \");",
          "",
          "[Removed Lines]",
          "428:   print_bpf_insn(print_insn, NULL, insn + i, true);",
          "",
          "[Added Lines]",
          "573:   print_bpf_insn(&cbs, NULL, insn + i, true);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "454:  va_end(args);",
          "455: }",
          "458: {",
          "459:  struct bpf_insn *insn = buf;",
          "460:  bool double_insn = false;",
          "461:  unsigned int i;",
          "",
          "[Removed Lines]",
          "457: static void dump_xlated_json(void *buf, unsigned int len, bool opcodes)",
          "",
          "[Added Lines]",
          "602: static void dump_xlated_json(struct dump_data *dd, void *buf,",
          "603:         unsigned int len, bool opcodes)",
          "605:  const struct bpf_insn_cbs cbs = {",
          "606:   .cb_print = print_insn_json,",
          "607:   .cb_call = print_call,",
          "608:   .cb_imm  = print_imm,",
          "609:   .private_data = dd,",
          "610:  };",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "471:   jsonw_start_object(json_wtr);",
          "472:   jsonw_name(json_wtr, \"disasm\");",
          "475:   if (opcodes) {",
          "476:    jsonw_name(json_wtr, \"opcodes\");",
          "",
          "[Removed Lines]",
          "473:   print_bpf_insn(print_insn_json, NULL, insn + i, true);",
          "",
          "[Added Lines]",
          "625:   print_bpf_insn(&cbs, NULL, insn + i, true);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "505: static int do_dump(int argc, char **argv)",
          "506: {",
          "507:  struct bpf_prog_info info = {};",
          "508:  __u32 len = sizeof(info);",
          "509:  unsigned int buf_size;",
          "510:  char *filepath = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "660:  struct dump_data dd = {};",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "592:   goto err_free;",
          "593:  }",
          "595:  if (filepath) {",
          "596:   fd = open(filepath, O_WRONLY | O_CREAT | O_TRUNC, 0600);",
          "597:   if (fd < 0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "748:  if ((member_len == &info.jited_prog_len &&",
          "749:       info.jited_prog_insns == 0) ||",
          "750:      (member_len == &info.xlated_prog_len &&",
          "751:       info.xlated_prog_insns == 0)) {",
          "752:   p_err(\"error retrieving insn dump: kernel.kptr_restrict set?\");",
          "753:   goto err_free;",
          "754:  }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "608:    goto err_free;",
          "609:   }",
          "610:  } else {",
          "612:    disasm_print_insn(buf, *member_len, opcodes);",
          "614:    if (json_output)",
          "616:    else",
          "618:  }",
          "620:  free(buf);",
          "622:  return 0;",
          "624: err_free:",
          "",
          "[Removed Lines]",
          "611:   if (member_len == &info.jited_prog_len)",
          "613:   else",
          "615:     dump_xlated_json(buf, *member_len, opcodes);",
          "617:     dump_xlated_plain(buf, *member_len, opcodes);",
          "",
          "[Added Lines]",
          "772:   if (member_len == &info.jited_prog_len) {",
          "774:   } else {",
          "775:    kernel_syms_load(&dd);",
          "777:     dump_xlated_json(&dd, buf, *member_len, opcodes);",
          "779:     dump_xlated_plain(&dd, buf, *member_len, opcodes);",
          "780:    kernel_syms_destroy(&dd);",
          "781:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "abe0884011f1a569bc1254b70c41525b755e8037",
      "candidate_info": {
        "commit_hash": "abe0884011f1a569bc1254b70c41525b755e8037",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/abe0884011f1a569bc1254b70c41525b755e8037",
        "files": [
          "kernel/bpf/disasm.c",
          "kernel/bpf/disasm.h",
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf: Remove struct bpf_verifier_env argument from print_bpf_insn\n\nWe use print_bpf_insn in user space (bpftool and soon perf),\nso it'd be nice to keep it generic and strip it off the kernel\nstruct bpf_verifier_env argument.\n\nThis argument can be safely removed, because its users can\nuse the struct bpf_insn_cbs::private_data to pass it.\n\nBy changing the argument type  we can no longer have clean\n'verbose' alias to 'bpf_verifier_log_write' in verifier.c.\nInstead  we're adding the  'verbose' cb_print callback and\nremoving the alias.\n\nThis way we have new cb_print callback in place, and all\nthe 'verbose(env, ...) calls in verifier.c will cleanly\ncast to 'verbose(void *, ...)' so no other change is\nneeded.\n\nSigned-off-by: Jiri Olsa <jolsa@kernel.org>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>",
        "before_after_code_files": [
          "kernel/bpf/disasm.c||kernel/bpf/disasm.c",
          "kernel/bpf/disasm.h||kernel/bpf/disasm.h",
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/bpf/disasm.c||kernel/bpf/disasm.c": [
          "File: kernel/bpf/disasm.c -> kernel/bpf/disasm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "113: };",
          "115: static void print_bpf_end_insn(bpf_insn_print_t verbose,",
          "117:           const struct bpf_insn *insn)",
          "118: {",
          "120:   BPF_SRC(insn->code) == BPF_TO_BE ? \"be\" : \"le\",",
          "121:   insn->imm, insn->dst_reg);",
          "122: }",
          "124: void print_bpf_insn(const struct bpf_insn_cbs *cbs,",
          "126:       const struct bpf_insn *insn,",
          "127:       bool allow_ptr_leaks)",
          "128: {",
          "",
          "[Removed Lines]",
          "116:           struct bpf_verifier_env *env,",
          "119:  verbose(env, \"(%02x) r%d = %s%d r%d\\n\", insn->code, insn->dst_reg,",
          "125:       struct bpf_verifier_env *env,",
          "",
          "[Added Lines]",
          "116:           void *private_data,",
          "119:  verbose(private_data, \"(%02x) r%d = %s%d r%d\\n\",",
          "120:   insn->code, insn->dst_reg,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "132:  if (class == BPF_ALU || class == BPF_ALU64) {",
          "133:   if (BPF_OP(insn->code) == BPF_END) {",
          "134:    if (class == BPF_ALU64)",
          "136:    else",
          "138:   } else if (BPF_OP(insn->code) == BPF_NEG) {",
          "140:     insn->code, insn->dst_reg,",
          "141:     class == BPF_ALU ? \"(u32) \" : \"\",",
          "142:     insn->dst_reg);",
          "143:   } else if (BPF_SRC(insn->code) == BPF_X) {",
          "145:     insn->code, class == BPF_ALU ? \"(u32) \" : \"\",",
          "146:     insn->dst_reg,",
          "147:     bpf_alu_string[BPF_OP(insn->code) >> 4],",
          "148:     class == BPF_ALU ? \"(u32) \" : \"\",",
          "149:     insn->src_reg);",
          "150:   } else {",
          "152:     insn->code, class == BPF_ALU ? \"(u32) \" : \"\",",
          "153:     insn->dst_reg,",
          "154:     bpf_alu_string[BPF_OP(insn->code) >> 4],",
          "",
          "[Removed Lines]",
          "135:     verbose(env, \"BUG_alu64_%02x\\n\", insn->code);",
          "137:     print_bpf_end_insn(verbose, env, insn);",
          "139:    verbose(env, \"(%02x) r%d = %s-r%d\\n\",",
          "144:    verbose(env, \"(%02x) %sr%d %s %sr%d\\n\",",
          "151:    verbose(env, \"(%02x) %sr%d %s %s%d\\n\",",
          "",
          "[Added Lines]",
          "135:     verbose(cbs->private_data, \"BUG_alu64_%02x\\n\", insn->code);",
          "137:     print_bpf_end_insn(verbose, cbs->private_data, insn);",
          "139:    verbose(cbs->private_data, \"(%02x) r%d = %s-r%d\\n\",",
          "144:    verbose(cbs->private_data, \"(%02x) %sr%d %s %sr%d\\n\",",
          "151:    verbose(cbs->private_data, \"(%02x) %sr%d %s %s%d\\n\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "157:   }",
          "158:  } else if (class == BPF_STX) {",
          "159:   if (BPF_MODE(insn->code) == BPF_MEM)",
          "161:     insn->code,",
          "162:     bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "163:     insn->dst_reg,",
          "164:     insn->off, insn->src_reg);",
          "165:   else if (BPF_MODE(insn->code) == BPF_XADD)",
          "167:     insn->code,",
          "168:     bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "169:     insn->dst_reg, insn->off,",
          "170:     insn->src_reg);",
          "171:   else",
          "173:  } else if (class == BPF_ST) {",
          "174:   if (BPF_MODE(insn->code) != BPF_MEM) {",
          "176:    return;",
          "177:   }",
          "179:    insn->code,",
          "180:    bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "181:    insn->dst_reg,",
          "182:    insn->off, insn->imm);",
          "183:  } else if (class == BPF_LDX) {",
          "184:   if (BPF_MODE(insn->code) != BPF_MEM) {",
          "186:    return;",
          "187:   }",
          "189:    insn->code, insn->dst_reg,",
          "190:    bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "191:    insn->src_reg, insn->off);",
          "192:  } else if (class == BPF_LD) {",
          "193:   if (BPF_MODE(insn->code) == BPF_ABS) {",
          "195:     insn->code,",
          "196:     bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "197:     insn->imm);",
          "198:   } else if (BPF_MODE(insn->code) == BPF_IND) {",
          "200:     insn->code,",
          "201:     bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "202:     insn->src_reg, insn->imm);",
          "",
          "[Removed Lines]",
          "160:    verbose(env, \"(%02x) *(%s *)(r%d %+d) = r%d\\n\",",
          "166:    verbose(env, \"(%02x) lock *(%s *)(r%d %+d) += r%d\\n\",",
          "172:    verbose(env, \"BUG_%02x\\n\", insn->code);",
          "175:    verbose(env, \"BUG_st_%02x\\n\", insn->code);",
          "178:   verbose(env, \"(%02x) *(%s *)(r%d %+d) = %d\\n\",",
          "185:    verbose(env, \"BUG_ldx_%02x\\n\", insn->code);",
          "188:   verbose(env, \"(%02x) r%d = *(%s *)(r%d %+d)\\n\",",
          "194:    verbose(env, \"(%02x) r0 = *(%s *)skb[%d]\\n\",",
          "199:    verbose(env, \"(%02x) r0 = *(%s *)skb[r%d + %d]\\n\",",
          "",
          "[Added Lines]",
          "160:    verbose(cbs->private_data, \"(%02x) *(%s *)(r%d %+d) = r%d\\n\",",
          "166:    verbose(cbs->private_data, \"(%02x) lock *(%s *)(r%d %+d) += r%d\\n\",",
          "172:    verbose(cbs->private_data, \"BUG_%02x\\n\", insn->code);",
          "175:    verbose(cbs->private_data, \"BUG_st_%02x\\n\", insn->code);",
          "178:   verbose(cbs->private_data, \"(%02x) *(%s *)(r%d %+d) = %d\\n\",",
          "185:    verbose(cbs->private_data, \"BUG_ldx_%02x\\n\", insn->code);",
          "188:   verbose(cbs->private_data, \"(%02x) r%d = *(%s *)(r%d %+d)\\n\",",
          "194:    verbose(cbs->private_data, \"(%02x) r0 = *(%s *)skb[%d]\\n\",",
          "199:    verbose(cbs->private_data, \"(%02x) r0 = *(%s *)skb[r%d + %d]\\n\",",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "212:    if (map_ptr && !allow_ptr_leaks)",
          "213:     imm = 0;",
          "216:     insn->code, insn->dst_reg,",
          "217:     __func_imm_name(cbs, insn, imm,",
          "218:       tmp, sizeof(tmp)));",
          "219:   } else {",
          "221:    return;",
          "222:   }",
          "223:  } else if (class == BPF_JMP) {",
          "",
          "[Removed Lines]",
          "215:    verbose(env, \"(%02x) r%d = %s\\n\",",
          "220:    verbose(env, \"BUG_ld_%02x\\n\", insn->code);",
          "",
          "[Added Lines]",
          "215:    verbose(cbs->private_data, \"(%02x) r%d = %s\\n\",",
          "220:    verbose(cbs->private_data, \"BUG_ld_%02x\\n\", insn->code);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "227:    char tmp[64];",
          "229:    if (insn->src_reg == BPF_PSEUDO_CALL) {",
          "231:      insn->code,",
          "232:      __func_get_name(cbs, insn,",
          "233:        tmp, sizeof(tmp)));",
          "234:    } else {",
          "235:     strcpy(tmp, \"unknown\");",
          "237:      __func_get_name(cbs, insn,",
          "238:        tmp, sizeof(tmp)),",
          "239:      insn->imm);",
          "240:    }",
          "241:   } else if (insn->code == (BPF_JMP | BPF_JA)) {",
          "243:     insn->code, insn->off);",
          "244:   } else if (insn->code == (BPF_JMP | BPF_EXIT)) {",
          "246:   } else if (BPF_SRC(insn->code) == BPF_X) {",
          "248:     insn->code, insn->dst_reg,",
          "249:     bpf_jmp_string[BPF_OP(insn->code) >> 4],",
          "250:     insn->src_reg, insn->off);",
          "251:   } else {",
          "253:     insn->code, insn->dst_reg,",
          "254:     bpf_jmp_string[BPF_OP(insn->code) >> 4],",
          "255:     insn->imm, insn->off);",
          "256:   }",
          "257:  } else {",
          "259:    insn->code, bpf_class_string[class]);",
          "260:  }",
          "261: }",
          "",
          "[Removed Lines]",
          "230:     verbose(env, \"(%02x) call pc%s\\n\",",
          "236:     verbose(env, \"(%02x) call %s#%d\\n\", insn->code,",
          "242:    verbose(env, \"(%02x) goto pc%+d\\n\",",
          "245:    verbose(env, \"(%02x) exit\\n\", insn->code);",
          "247:    verbose(env, \"(%02x) if r%d %s r%d goto pc%+d\\n\",",
          "252:    verbose(env, \"(%02x) if r%d %s 0x%x goto pc%+d\\n\",",
          "258:   verbose(env, \"(%02x) %s\\n\",",
          "",
          "[Added Lines]",
          "230:     verbose(cbs->private_data, \"(%02x) call pc%s\\n\",",
          "236:     verbose(cbs->private_data, \"(%02x) call %s#%d\\n\", insn->code,",
          "242:    verbose(cbs->private_data, \"(%02x) goto pc%+d\\n\",",
          "245:    verbose(cbs->private_data, \"(%02x) exit\\n\", insn->code);",
          "247:    verbose(cbs->private_data, \"(%02x) if r%d %s r%d goto pc%+d\\n\",",
          "252:    verbose(cbs->private_data, \"(%02x) if r%d %s 0x%x goto pc%+d\\n\",",
          "258:   verbose(cbs->private_data, \"(%02x) %s\\n\",",
          "",
          "---------------"
        ],
        "kernel/bpf/disasm.h||kernel/bpf/disasm.h": [
          "File: kernel/bpf/disasm.h -> kernel/bpf/disasm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #include <string.h>",
          "23: #endif",
          "27: extern const char *const bpf_alu_string[16];",
          "28: extern const char *const bpf_class_string[8];",
          "30: const char *func_id_name(int id);",
          "33:       const char *, ...);",
          "34: typedef const char *(*bpf_insn_revmap_call_t)(void *private_data,",
          "35:            const struct bpf_insn *insn);",
          "",
          "[Removed Lines]",
          "25: struct bpf_verifier_env;",
          "32: typedef __printf(2, 3) void (*bpf_insn_print_t)(struct bpf_verifier_env *env,",
          "",
          "[Added Lines]",
          "30: typedef __printf(2, 3) void (*bpf_insn_print_t)(void *private_data,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "45: };",
          "47: void print_bpf_insn(const struct bpf_insn_cbs *cbs,",
          "49:       const struct bpf_insn *insn,",
          "50:       bool allow_ptr_leaks);",
          "51: #endif",
          "",
          "[Removed Lines]",
          "48:       struct bpf_verifier_env *env,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "169: static DEFINE_MUTEX(bpf_verifier_lock);",
          "177: {",
          "178:  struct bpf_verifer_log *log = &env->log;",
          "179:  unsigned int n;",
          "182:  if (!log->level || !log->ubuf || bpf_verifier_log_full(log))",
          "183:   return;",
          "186:  n = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);",
          "189:  WARN_ONCE(n >= BPF_VERIFIER_TMP_LOG_SIZE - 1,",
          "190:     \"verifier log line truncated - local buffer too short\\n\");",
          "",
          "[Removed Lines]",
          "175: __printf(2, 3) void bpf_verifier_log_write(struct bpf_verifier_env *env,",
          "176:         const char *fmt, ...)",
          "180:  va_list args;",
          "185:  va_start(args, fmt);",
          "187:  va_end(args);",
          "",
          "[Added Lines]",
          "171: static void log_write(struct bpf_verifier_env *env, const char *fmt,",
          "172:         va_list args)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "197:  else",
          "198:   log->ubuf = NULL;",
          "199: }",
          "209: static bool type_is_pkt_pointer(enum bpf_reg_type type)",
          "210: {",
          "",
          "[Removed Lines]",
          "200: EXPORT_SYMBOL_GPL(bpf_verifier_log_write);",
          "205: static __printf(2, 3) void verbose(struct bpf_verifier_env *env,",
          "206:        const char *fmt, ...)",
          "207:  __attribute__((alias(\"bpf_verifier_log_write\")));",
          "",
          "[Added Lines]",
          "198: __printf(2, 3) void bpf_verifier_log_write(struct bpf_verifier_env *env,",
          "199:         const char *fmt, ...)",
          "200: {",
          "201:  va_list args;",
          "203:  va_start(args, fmt);",
          "204:  log_write(env, fmt, args);",
          "205:  va_end(args);",
          "206: }",
          "207: EXPORT_SYMBOL_GPL(bpf_verifier_log_write);",
          "209: __printf(2, 3) static void verbose(void *private_data, const char *fmt, ...)",
          "210: {",
          "211:  va_list args;",
          "213:  va_start(args, fmt);",
          "214:  log_write(private_data, fmt, args);",
          "215:  va_end(args);",
          "216: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4600:   if (env->log.level) {",
          "4601:    const struct bpf_insn_cbs cbs = {",
          "4602:     .cb_print = verbose,",
          "4603:    };",
          "4605:    verbose(env, \"%d: \", insn_idx);",
          "4607:   }",
          "4609:   if (bpf_prog_is_dev_bound(env->prog->aux)) {",
          "",
          "[Removed Lines]",
          "4606:    print_bpf_insn(&cbs, env, insn, env->allow_ptr_leaks);",
          "",
          "[Added Lines]",
          "4612:     .private_data = env,",
          "4616:    print_bpf_insn(&cbs, insn, env->allow_ptr_leaks);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "61bd5218eef349fcacc4976a251bc83a4748b4af",
      "candidate_info": {
        "commit_hash": "61bd5218eef349fcacc4976a251bc83a4748b4af",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/61bd5218eef349fcacc4976a251bc83a4748b4af",
        "files": [
          "include/linux/bpf_verifier.h",
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf: move global verifier log into verifier environment\n\nThe biggest piece of global state protected by the verifier lock\nis the verifier_log.  Move that log to struct bpf_verifier_env.\nstruct bpf_verifier_env has to be passed now to all invocations\nof verbose().\n\nSigned-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>\nReviewed-by: Simon Horman <simon.horman@netronome.com>\nAcked-by: Alexei Starovoitov <ast@kernel.org>\nAcked-by: Daniel Borkmann <daniel@iogearbox.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h": [
          "File: include/linux/bpf_verifier.h -> include/linux/bpf_verifier.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "152:  bool allow_ptr_leaks;",
          "153:  bool seen_direct_write;",
          "155: };",
          "157: int bpf_analyzer(struct bpf_prog *prog, const struct bpf_ext_analyzer_ops *ops,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "156:  struct bpf_verifer_log log;",
          "",
          "---------------"
        ],
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "153:  int access_size;",
          "154: };",
          "161: static DEFINE_MUTEX(bpf_verifier_lock);",
          "168: {",
          "170:  va_list args;",
          "172:  if (!log->level || bpf_verifier_log_full(log))",
          "",
          "[Removed Lines]",
          "159: static struct bpf_verifer_log verifier_log;",
          "167: static __printf(1, 2) void verbose(const char *fmt, ...)",
          "169:  struct bpf_verifer_log *log = &verifier_log;",
          "",
          "[Added Lines]",
          "162: static __printf(2, 3) void verbose(struct bpf_verifier_env *env,",
          "163:        const char *fmt, ...)",
          "165:  struct bpf_verifer_log *log = &env->log;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "214:   return \"unknown\";",
          "215: }",
          "218: {",
          "219:  struct bpf_reg_state *reg;",
          "220:  enum bpf_reg_type t;",
          "",
          "[Removed Lines]",
          "217: static void print_verifier_state(struct bpf_verifier_state *state)",
          "",
          "[Added Lines]",
          "213: static void print_verifier_state(struct bpf_verifier_env *env,",
          "214:      struct bpf_verifier_state *state)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "225:   t = reg->type;",
          "226:   if (t == NOT_INIT)",
          "227:    continue;",
          "229:   if ((t == SCALAR_VALUE || t == PTR_TO_STACK) &&",
          "230:       tnum_is_const(reg->var_off)) {",
          "233:   } else {",
          "235:    if (t != SCALAR_VALUE)",
          "237:    if (type_is_pkt_pointer(t))",
          "239:    else if (t == CONST_PTR_TO_MAP ||",
          "240:      t == PTR_TO_MAP_VALUE ||",
          "241:      t == PTR_TO_MAP_VALUE_OR_NULL)",
          "243:      reg->map_ptr->key_size,",
          "244:      reg->map_ptr->value_size);",
          "245:    if (tnum_is_const(reg->var_off)) {",
          "",
          "[Removed Lines]",
          "228:   verbose(\" R%d=%s\", i, reg_type_str[t]);",
          "232:    verbose(\"%lld\", reg->var_off.value + reg->off);",
          "234:    verbose(\"(id=%d\", reg->id);",
          "236:     verbose(\",off=%d\", reg->off);",
          "238:     verbose(\",r=%d\", reg->range);",
          "242:     verbose(\",ks=%d,vs=%d\",",
          "",
          "[Added Lines]",
          "225:   verbose(env, \" R%d=%s\", i, reg_type_str[t]);",
          "229:    verbose(env, \"%lld\", reg->var_off.value + reg->off);",
          "231:    verbose(env, \"(id=%d\", reg->id);",
          "233:     verbose(env, \",off=%d\", reg->off);",
          "235:     verbose(env, \",r=%d\", reg->range);",
          "239:     verbose(env, \",ks=%d,vs=%d\",",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "251:    } else {",
          "252:     if (reg->smin_value != reg->umin_value &&",
          "253:         reg->smin_value != S64_MIN)",
          "255:       (long long)reg->smin_value);",
          "256:     if (reg->smax_value != reg->umax_value &&",
          "257:         reg->smax_value != S64_MAX)",
          "259:       (long long)reg->smax_value);",
          "260:     if (reg->umin_value != 0)",
          "262:       (unsigned long long)reg->umin_value);",
          "263:     if (reg->umax_value != U64_MAX)",
          "265:       (unsigned long long)reg->umax_value);",
          "266:     if (!tnum_is_unknown(reg->var_off)) {",
          "267:      char tn_buf[48];",
          "269:      tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "271:     }",
          "272:    }",
          "274:   }",
          "275:  }",
          "276:  for (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {",
          "277:   if (state->stack_slot_type[i] == STACK_SPILL)",
          "279:     reg_type_str[state->spilled_regs[i / BPF_REG_SIZE].type]);",
          "280:  }",
          "282: }",
          "284: static const char *const bpf_class_string[] = {",
          "",
          "[Removed Lines]",
          "250:     verbose(\",imm=%llx\", reg->var_off.value);",
          "254:      verbose(\",smin_value=%lld\",",
          "258:      verbose(\",smax_value=%lld\",",
          "261:      verbose(\",umin_value=%llu\",",
          "264:      verbose(\",umax_value=%llu\",",
          "270:      verbose(\",var_off=%s\", tn_buf);",
          "273:    verbose(\")\");",
          "278:    verbose(\" fp%d=%s\", -MAX_BPF_STACK + i,",
          "281:  verbose(\"\\n\");",
          "",
          "[Added Lines]",
          "247:     verbose(env, \",imm=%llx\", reg->var_off.value);",
          "251:      verbose(env, \",smin_value=%lld\",",
          "255:      verbose(env, \",smax_value=%lld\",",
          "258:      verbose(env, \",umin_value=%llu\",",
          "261:      verbose(env, \",umax_value=%llu\",",
          "267:      verbose(env, \",var_off=%s\", tn_buf);",
          "270:    verbose(env, \")\");",
          "275:    verbose(env, \" fp%d=%s\", -MAX_BPF_STACK + i,",
          "278:  verbose(env, \"\\n\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "333:  [BPF_EXIT >> 4] = \"exit\",",
          "334: };",
          "337:           const struct bpf_insn *insn)",
          "338: {",
          "340:   BPF_SRC(insn->code) == BPF_TO_BE ? \"be\" : \"le\",",
          "341:   insn->imm, insn->dst_reg);",
          "342: }",
          "345:       const struct bpf_insn *insn)",
          "346: {",
          "347:  u8 class = BPF_CLASS(insn->code);",
          "",
          "[Removed Lines]",
          "336: static void print_bpf_end_insn(const struct bpf_verifier_env *env,",
          "339:  verbose(\"(%02x) r%d = %s%d r%d\\n\", insn->code, insn->dst_reg,",
          "344: static void print_bpf_insn(const struct bpf_verifier_env *env,",
          "",
          "[Added Lines]",
          "333: static void print_bpf_end_insn(struct bpf_verifier_env *env,",
          "336:  verbose(env, \"(%02x) r%d = %s%d r%d\\n\", insn->code, insn->dst_reg,",
          "341: static void print_bpf_insn(struct bpf_verifier_env *env,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "349:  if (class == BPF_ALU || class == BPF_ALU64) {",
          "350:   if (BPF_OP(insn->code) == BPF_END) {",
          "351:    if (class == BPF_ALU64)",
          "353:    else",
          "354:     print_bpf_end_insn(env, insn);",
          "355:   } else if (BPF_OP(insn->code) == BPF_NEG) {",
          "357:     insn->code, insn->dst_reg,",
          "358:     class == BPF_ALU ? \"(u32) \" : \"\",",
          "359:     insn->dst_reg);",
          "360:   } else if (BPF_SRC(insn->code) == BPF_X) {",
          "362:     insn->code, class == BPF_ALU ? \"(u32) \" : \"\",",
          "363:     insn->dst_reg,",
          "364:     bpf_alu_string[BPF_OP(insn->code) >> 4],",
          "365:     class == BPF_ALU ? \"(u32) \" : \"\",",
          "366:     insn->src_reg);",
          "367:   } else {",
          "369:     insn->code, class == BPF_ALU ? \"(u32) \" : \"\",",
          "370:     insn->dst_reg,",
          "371:     bpf_alu_string[BPF_OP(insn->code) >> 4],",
          "",
          "[Removed Lines]",
          "352:     verbose(\"BUG_alu64_%02x\\n\", insn->code);",
          "356:    verbose(\"(%02x) r%d = %s-r%d\\n\",",
          "361:    verbose(\"(%02x) %sr%d %s %sr%d\\n\",",
          "368:    verbose(\"(%02x) %sr%d %s %s%d\\n\",",
          "",
          "[Added Lines]",
          "349:     verbose(env, \"BUG_alu64_%02x\\n\", insn->code);",
          "353:    verbose(env, \"(%02x) r%d = %s-r%d\\n\",",
          "358:    verbose(env, \"(%02x) %sr%d %s %sr%d\\n\",",
          "365:    verbose(env, \"(%02x) %sr%d %s %s%d\\n\",",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "374:   }",
          "375:  } else if (class == BPF_STX) {",
          "376:   if (BPF_MODE(insn->code) == BPF_MEM)",
          "378:     insn->code,",
          "379:     bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "380:     insn->dst_reg,",
          "381:     insn->off, insn->src_reg);",
          "382:   else if (BPF_MODE(insn->code) == BPF_XADD)",
          "384:     insn->code,",
          "385:     bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "386:     insn->dst_reg, insn->off,",
          "387:     insn->src_reg);",
          "388:   else",
          "390:  } else if (class == BPF_ST) {",
          "391:   if (BPF_MODE(insn->code) != BPF_MEM) {",
          "393:    return;",
          "394:   }",
          "396:    insn->code,",
          "397:    bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "398:    insn->dst_reg,",
          "399:    insn->off, insn->imm);",
          "400:  } else if (class == BPF_LDX) {",
          "401:   if (BPF_MODE(insn->code) != BPF_MEM) {",
          "403:    return;",
          "404:   }",
          "406:    insn->code, insn->dst_reg,",
          "407:    bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "408:    insn->src_reg, insn->off);",
          "409:  } else if (class == BPF_LD) {",
          "410:   if (BPF_MODE(insn->code) == BPF_ABS) {",
          "412:     insn->code,",
          "413:     bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "414:     insn->imm);",
          "415:   } else if (BPF_MODE(insn->code) == BPF_IND) {",
          "417:     insn->code,",
          "418:     bpf_ldst_string[BPF_SIZE(insn->code) >> 3],",
          "419:     insn->src_reg, insn->imm);",
          "",
          "[Removed Lines]",
          "377:    verbose(\"(%02x) *(%s *)(r%d %+d) = r%d\\n\",",
          "383:    verbose(\"(%02x) lock *(%s *)(r%d %+d) += r%d\\n\",",
          "389:    verbose(\"BUG_%02x\\n\", insn->code);",
          "392:    verbose(\"BUG_st_%02x\\n\", insn->code);",
          "395:   verbose(\"(%02x) *(%s *)(r%d %+d) = %d\\n\",",
          "402:    verbose(\"BUG_ldx_%02x\\n\", insn->code);",
          "405:   verbose(\"(%02x) r%d = *(%s *)(r%d %+d)\\n\",",
          "411:    verbose(\"(%02x) r0 = *(%s *)skb[%d]\\n\",",
          "416:    verbose(\"(%02x) r0 = *(%s *)skb[r%d + %d]\\n\",",
          "",
          "[Added Lines]",
          "374:    verbose(env, \"(%02x) *(%s *)(r%d %+d) = r%d\\n\",",
          "380:    verbose(env, \"(%02x) lock *(%s *)(r%d %+d) += r%d\\n\",",
          "386:    verbose(env, \"BUG_%02x\\n\", insn->code);",
          "389:    verbose(env, \"BUG_st_%02x\\n\", insn->code);",
          "392:   verbose(env, \"(%02x) *(%s *)(r%d %+d) = %d\\n\",",
          "399:    verbose(env, \"BUG_ldx_%02x\\n\", insn->code);",
          "402:   verbose(env, \"(%02x) r%d = *(%s *)(r%d %+d)\\n\",",
          "408:    verbose(env, \"(%02x) r0 = *(%s *)skb[%d]\\n\",",
          "413:    verbose(env, \"(%02x) r0 = *(%s *)skb[r%d + %d]\\n\",",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "428:    if (map_ptr && !env->allow_ptr_leaks)",
          "429:     imm = 0;",
          "432:     insn->dst_reg, (unsigned long long)imm);",
          "433:   } else {",
          "435:    return;",
          "436:   }",
          "437:  } else if (class == BPF_JMP) {",
          "438:   u8 opcode = BPF_OP(insn->code);",
          "440:   if (opcode == BPF_CALL) {",
          "442:     func_id_name(insn->imm), insn->imm);",
          "443:   } else if (insn->code == (BPF_JMP | BPF_JA)) {",
          "445:     insn->code, insn->off);",
          "446:   } else if (insn->code == (BPF_JMP | BPF_EXIT)) {",
          "448:   } else if (BPF_SRC(insn->code) == BPF_X) {",
          "450:     insn->code, insn->dst_reg,",
          "451:     bpf_jmp_string[BPF_OP(insn->code) >> 4],",
          "452:     insn->src_reg, insn->off);",
          "453:   } else {",
          "455:     insn->code, insn->dst_reg,",
          "456:     bpf_jmp_string[BPF_OP(insn->code) >> 4],",
          "457:     insn->imm, insn->off);",
          "458:   }",
          "459:  } else {",
          "461:  }",
          "462: }",
          "",
          "[Removed Lines]",
          "431:    verbose(\"(%02x) r%d = 0x%llx\\n\", insn->code,",
          "434:    verbose(\"BUG_ld_%02x\\n\", insn->code);",
          "441:    verbose(\"(%02x) call %s#%d\\n\", insn->code,",
          "444:    verbose(\"(%02x) goto pc%+d\\n\",",
          "447:    verbose(\"(%02x) exit\\n\", insn->code);",
          "449:    verbose(\"(%02x) if r%d %s r%d goto pc%+d\\n\",",
          "454:    verbose(\"(%02x) if r%d %s 0x%x goto pc%+d\\n\",",
          "460:   verbose(\"(%02x) %s\\n\", insn->code, bpf_class_string[class]);",
          "",
          "[Added Lines]",
          "428:    verbose(env, \"(%02x) r%d = 0x%llx\\n\", insn->code,",
          "431:    verbose(env, \"BUG_ld_%02x\\n\", insn->code);",
          "438:    verbose(env, \"(%02x) call %s#%d\\n\", insn->code,",
          "441:    verbose(env, \"(%02x) goto pc%+d\\n\",",
          "444:    verbose(env, \"(%02x) exit\\n\", insn->code);",
          "446:    verbose(env, \"(%02x) if r%d %s r%d goto pc%+d\\n\",",
          "451:    verbose(env, \"(%02x) if r%d %s 0x%x goto pc%+d\\n\",",
          "457:   verbose(env, \"(%02x) %s\\n\",",
          "458:    insn->code, bpf_class_string[class]);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "496:  env->head = elem;",
          "497:  env->stack_size++;",
          "498:  if (env->stack_size > BPF_COMPLEXITY_LIMIT_STACK) {",
          "500:   goto err;",
          "501:  }",
          "502:  return &elem->st;",
          "",
          "[Removed Lines]",
          "499:   verbose(\"BPF program is too complex\\n\");",
          "",
          "[Added Lines]",
          "497:   verbose(env, \"BPF program is too complex\\n\");",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "534:  __mark_reg_known(reg, 0);",
          "535: }",
          "538: {",
          "539:  if (WARN_ON(regno >= MAX_BPF_REG)) {",
          "542:   for (regno = 0; regno < MAX_BPF_REG; regno++)",
          "543:    __mark_reg_not_init(regs + regno);",
          "",
          "[Removed Lines]",
          "537: static void mark_reg_known_zero(struct bpf_reg_state *regs, u32 regno)",
          "540:   verbose(\"mark_reg_known_zero(regs, %u)\\n\", regno);",
          "",
          "[Added Lines]",
          "535: static void mark_reg_known_zero(struct bpf_verifier_env *env,",
          "536:     struct bpf_reg_state *regs, u32 regno)",
          "539:   verbose(env, \"mark_reg_known_zero(regs, %u)\\n\", regno);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "647:  __mark_reg_unbounded(reg);",
          "648: }",
          "651: {",
          "652:  if (WARN_ON(regno >= MAX_BPF_REG)) {",
          "655:   for (regno = 0; regno < MAX_BPF_REG; regno++)",
          "656:    __mark_reg_not_init(regs + regno);",
          "",
          "[Removed Lines]",
          "650: static void mark_reg_unknown(struct bpf_reg_state *regs, u32 regno)",
          "653:   verbose(\"mark_reg_unknown(regs, %u)\\n\", regno);",
          "",
          "[Added Lines]",
          "649: static void mark_reg_unknown(struct bpf_verifier_env *env,",
          "650:         struct bpf_reg_state *regs, u32 regno)",
          "653:   verbose(env, \"mark_reg_unknown(regs, %u)\\n\", regno);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "665:  reg->type = NOT_INIT;",
          "666: }",
          "669: {",
          "670:  if (WARN_ON(regno >= MAX_BPF_REG)) {",
          "673:   for (regno = 0; regno < MAX_BPF_REG; regno++)",
          "674:    __mark_reg_not_init(regs + regno);",
          "",
          "[Removed Lines]",
          "668: static void mark_reg_not_init(struct bpf_reg_state *regs, u32 regno)",
          "671:   verbose(\"mark_reg_not_init(regs, %u)\\n\", regno);",
          "",
          "[Added Lines]",
          "668: static void mark_reg_not_init(struct bpf_verifier_env *env,",
          "669:          struct bpf_reg_state *regs, u32 regno)",
          "672:   verbose(env, \"mark_reg_not_init(regs, %u)\\n\", regno);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "677:  __mark_reg_not_init(regs + regno);",
          "678: }",
          "681: {",
          "682:  int i;",
          "684:  for (i = 0; i < MAX_BPF_REG; i++) {",
          "686:   regs[i].live = REG_LIVE_NONE;",
          "687:  }",
          "690:  regs[BPF_REG_FP].type = PTR_TO_STACK;",
          "694:  regs[BPF_REG_1].type = PTR_TO_CTX;",
          "696: }",
          "698: enum reg_arg_type {",
          "",
          "[Removed Lines]",
          "680: static void init_reg_state(struct bpf_reg_state *regs)",
          "685:   mark_reg_not_init(regs, i);",
          "691:  mark_reg_known_zero(regs, BPF_REG_FP);",
          "695:  mark_reg_known_zero(regs, BPF_REG_1);",
          "",
          "[Added Lines]",
          "681: static void init_reg_state(struct bpf_verifier_env *env,",
          "682:       struct bpf_reg_state *regs)",
          "687:   mark_reg_not_init(env, regs, i);",
          "693:  mark_reg_known_zero(env, regs, BPF_REG_FP);",
          "697:  mark_reg_known_zero(env, regs, BPF_REG_1);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "726:  struct bpf_reg_state *regs = env->cur_state.regs;",
          "728:  if (regno >= MAX_BPF_REG) {",
          "730:   return -EINVAL;",
          "731:  }",
          "733:  if (t == SRC_OP) {",
          "735:   if (regs[regno].type == NOT_INIT) {",
          "737:    return -EACCES;",
          "738:   }",
          "739:   mark_reg_read(&env->cur_state, regno);",
          "740:  } else {",
          "742:   if (regno == BPF_REG_FP) {",
          "744:    return -EACCES;",
          "745:   }",
          "746:   regs[regno].live |= REG_LIVE_WRITTEN;",
          "747:   if (t == DST_OP)",
          "749:  }",
          "750:  return 0;",
          "751: }",
          "",
          "[Removed Lines]",
          "729:   verbose(\"R%d is invalid\\n\", regno);",
          "736:    verbose(\"R%d !read_ok\\n\", regno);",
          "743:    verbose(\"frame pointer is read only\\n\");",
          "748:    mark_reg_unknown(regs, regno);",
          "",
          "[Added Lines]",
          "731:   verbose(env, \"R%d is invalid\\n\", regno);",
          "738:    verbose(env, \"R%d !read_ok\\n\", regno);",
          "745:    verbose(env, \"frame pointer is read only\\n\");",
          "750:    mark_reg_unknown(env, regs, regno);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "774:         int size, int value_regno)",
          "775: {",
          "776:  int i, spi = (MAX_BPF_STACK + off) / BPF_REG_SIZE;",
          "",
          "[Removed Lines]",
          "773: static int check_stack_write(struct bpf_verifier_state *state, int off,",
          "",
          "[Added Lines]",
          "775: static int check_stack_write(struct bpf_verifier_env *env,",
          "776:         struct bpf_verifier_state *state, int off,",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "785:   if (size != BPF_REG_SIZE) {",
          "787:    return -EACCES;",
          "788:   }",
          "",
          "[Removed Lines]",
          "786:    verbose(\"invalid size of register spill\\n\");",
          "",
          "[Added Lines]",
          "789:    verbose(env, \"invalid size of register spill\\n\");",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "818:  }",
          "819: }",
          "822:        int value_regno)",
          "823: {",
          "824:  u8 *slot_type;",
          "",
          "[Removed Lines]",
          "821: static int check_stack_read(struct bpf_verifier_state *state, int off, int size,",
          "",
          "[Added Lines]",
          "824: static int check_stack_read(struct bpf_verifier_env *env,",
          "825:        struct bpf_verifier_state *state, int off, int size,",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "829:  if (slot_type[0] == STACK_SPILL) {",
          "830:   if (size != BPF_REG_SIZE) {",
          "832:    return -EACCES;",
          "833:   }",
          "834:   for (i = 1; i < BPF_REG_SIZE; i++) {",
          "835:    if (slot_type[i] != STACK_SPILL) {",
          "837:     return -EACCES;",
          "838:    }",
          "839:   }",
          "",
          "[Removed Lines]",
          "831:    verbose(\"invalid size of register spill\\n\");",
          "836:     verbose(\"corrupted spill memory\\n\");",
          "",
          "[Added Lines]",
          "835:    verbose(env, \"invalid size of register spill\\n\");",
          "840:     verbose(env, \"corrupted spill memory\\n\");",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "849:  } else {",
          "850:   for (i = 0; i < size; i++) {",
          "851:    if (slot_type[i] != STACK_MISC) {",
          "853:      off, i, size);",
          "854:     return -EACCES;",
          "855:    }",
          "856:   }",
          "857:   if (value_regno >= 0)",
          "860:   return 0;",
          "861:  }",
          "862: }",
          "",
          "[Removed Lines]",
          "852:     verbose(\"invalid read from stack off %d+%d size %d\\n\",",
          "859:    mark_reg_unknown(state->regs, value_regno);",
          "",
          "[Added Lines]",
          "856:     verbose(env, \"invalid read from stack off %d+%d size %d\\n\",",
          "863:    mark_reg_unknown(env, state->regs, value_regno);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "868:  struct bpf_map *map = env->cur_state.regs[regno].map_ptr;",
          "870:  if (off < 0 || size <= 0 || off + size > map->value_size) {",
          "872:    map->value_size, off, size);",
          "873:   return -EACCES;",
          "874:  }",
          "",
          "[Removed Lines]",
          "871:   verbose(\"invalid access to map value, value_size=%d off=%d size=%d\\n\",",
          "",
          "[Added Lines]",
          "875:   verbose(env, \"invalid access to map value, value_size=%d off=%d size=%d\\n\",",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "890:  if (verifier_log.level)",
          "891:   print_verifier_state(state);",
          "",
          "[Added Lines]",
          "894:  if (env->log.level)",
          "895:   print_verifier_state(env, state);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "898:  if (reg->smin_value < 0) {",
          "900:    regno);",
          "901:   return -EACCES;",
          "902:  }",
          "903:  err = __check_map_access(env, regno, reg->smin_value + off, size);",
          "904:  if (err) {",
          "906:   return err;",
          "907:  }",
          "",
          "[Removed Lines]",
          "899:   verbose(\"R%d min value is negative, either use unsigned index or do a if (index >=0) check.\\n\",",
          "905:   verbose(\"R%d min value is outside of the array range\\n\", regno);",
          "",
          "[Added Lines]",
          "903:   verbose(env, \"R%d min value is negative, either use unsigned index or do a if (index >=0) check.\\n\",",
          "909:   verbose(env, \"R%d min value is outside of the array range\\n\",",
          "910:    regno);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "913:  if (reg->umax_value >= BPF_MAX_VAR_OFF) {",
          "915:    regno);",
          "916:   return -EACCES;",
          "917:  }",
          "918:  err = __check_map_access(env, regno, reg->umax_value + off, size);",
          "919:  if (err)",
          "921:  return err;",
          "922: }",
          "",
          "[Removed Lines]",
          "914:   verbose(\"R%d unbounded memory access, make sure to bounds check any array access into a map\\n\",",
          "920:   verbose(\"R%d max value is outside of the array range\\n\", regno);",
          "",
          "[Added Lines]",
          "919:   verbose(env, \"R%d unbounded memory access, make sure to bounds check any array access into a map\\n\",",
          "925:   verbose(env, \"R%d max value is outside of the array range\\n\",",
          "926:    regno);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "956:  struct bpf_reg_state *reg = &regs[regno];",
          "958:  if (off < 0 || size <= 0 || (u64)off + size > reg->range) {",
          "960:    off, size, regno, reg->id, reg->off, reg->range);",
          "961:   return -EACCES;",
          "962:  }",
          "",
          "[Removed Lines]",
          "959:   verbose(\"invalid access to packet, off=%d size=%d, R%d(id=%d,off=%d,r=%d)\\n\",",
          "",
          "[Added Lines]",
          "965:   verbose(env, \"invalid access to packet, off=%d size=%d, R%d(id=%d,off=%d,r=%d)\\n\",",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "981:  if (reg->smin_value < 0) {",
          "983:    regno);",
          "984:   return -EACCES;",
          "985:  }",
          "986:  err = __check_packet_access(env, regno, off, size);",
          "987:  if (err) {",
          "989:   return err;",
          "990:  }",
          "991:  return err;",
          "",
          "[Removed Lines]",
          "982:   verbose(\"R%d min value is negative, either use unsigned index or do a if (index >=0) check.\\n\",",
          "988:   verbose(\"R%d offset is outside of the packet\\n\", regno);",
          "",
          "[Added Lines]",
          "988:   verbose(env, \"R%d min value is negative, either use unsigned index or do a if (index >=0) check.\\n\",",
          "994:   verbose(env, \"R%d offset is outside of the packet\\n\", regno);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1021:   return 0;",
          "1022:  }",
          "1025:  return -EACCES;",
          "1026: }",
          "",
          "[Removed Lines]",
          "1024:  verbose(\"invalid bpf_context access off=%d size=%d\\n\", off, size);",
          "",
          "[Added Lines]",
          "1030:  verbose(env, \"invalid bpf_context access off=%d size=%d\\n\", off, size);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1039:  return __is_pointer_value(env->allow_ptr_leaks, &env->cur_state.regs[regno]);",
          "1040: }",
          "1043:        int off, int size, bool strict)",
          "1044: {",
          "1045:  struct tnum reg_off;",
          "",
          "[Removed Lines]",
          "1042: static int check_pkt_ptr_alignment(const struct bpf_reg_state *reg,",
          "",
          "[Added Lines]",
          "1048: static int check_pkt_ptr_alignment(struct bpf_verifier_env *env,",
          "1049:        const struct bpf_reg_state *reg,",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1064:   char tn_buf[48];",
          "1066:   tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "1068:    ip_align, tn_buf, reg->off, off, size);",
          "1069:   return -EACCES;",
          "1070:  }",
          "",
          "[Removed Lines]",
          "1067:   verbose(\"misaligned packet access off %d+%s+%d+%d size %d\\n\",",
          "",
          "[Added Lines]",
          "1074:   verbose(env,",
          "1075:    \"misaligned packet access off %d+%s+%d+%d size %d\\n\",",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1072:  return 0;",
          "1073: }",
          "1076:            const char *pointer_desc,",
          "1077:            int off, int size, bool strict)",
          "1078: {",
          "",
          "[Removed Lines]",
          "1075: static int check_generic_ptr_alignment(const struct bpf_reg_state *reg,",
          "",
          "[Added Lines]",
          "1083: static int check_generic_ptr_alignment(struct bpf_verifier_env *env,",
          "1084:            const struct bpf_reg_state *reg,",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1087:   char tn_buf[48];",
          "1089:   tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "1091:    pointer_desc, tn_buf, reg->off, off, size);",
          "1092:   return -EACCES;",
          "1093:  }",
          "",
          "[Removed Lines]",
          "1090:   verbose(\"misaligned %saccess off %s+%d+%d size %d\\n\",",
          "",
          "[Added Lines]",
          "1099:   verbose(env, \"misaligned %saccess off %s+%d+%d size %d\\n\",",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1112:  case PTR_TO_MAP_VALUE:",
          "1113:   pointer_desc = \"value \";",
          "1114:   break;",
          "",
          "[Removed Lines]",
          "1111:   return check_pkt_ptr_alignment(reg, off, size, strict);",
          "",
          "[Added Lines]",
          "1120:   return check_pkt_ptr_alignment(env, reg, off, size, strict);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1121:  default:",
          "1122:   break;",
          "1123:  }",
          "1125: }",
          "",
          "[Removed Lines]",
          "1124:  return check_generic_ptr_alignment(reg, pointer_desc, off, size, strict);",
          "",
          "[Added Lines]",
          "1133:  return check_generic_ptr_alignment(env, reg, pointer_desc, off, size,",
          "1134:         strict);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1153:  if (reg->type == PTR_TO_MAP_VALUE) {",
          "1154:   if (t == BPF_WRITE && value_regno >= 0 &&",
          "1155:       is_pointer_value(env, value_regno)) {",
          "1157:    return -EACCES;",
          "1158:   }",
          "1160:   err = check_map_access(env, regno, off, size);",
          "1161:   if (!err && t == BPF_READ && value_regno >= 0)",
          "1164:  } else if (reg->type == PTR_TO_CTX) {",
          "1165:   enum bpf_reg_type reg_type = SCALAR_VALUE;",
          "1167:   if (t == BPF_WRITE && value_regno >= 0 &&",
          "1168:       is_pointer_value(env, value_regno)) {",
          "1170:    return -EACCES;",
          "1171:   }",
          "",
          "[Removed Lines]",
          "1156:    verbose(\"R%d leaks addr into map\\n\", value_regno);",
          "1162:    mark_reg_unknown(state->regs, value_regno);",
          "1169:    verbose(\"R%d leaks addr into ctx\\n\", value_regno);",
          "",
          "[Added Lines]",
          "1166:    verbose(env, \"R%d leaks addr into map\\n\", value_regno);",
          "1172:    mark_reg_unknown(env, state->regs, value_regno);",
          "1179:    verbose(env, \"R%d leaks addr into ctx\\n\", value_regno);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1176:    char tn_buf[48];",
          "1178:    tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "1180:     tn_buf, off, size);",
          "1181:    return -EACCES;",
          "1182:   }",
          "",
          "[Removed Lines]",
          "1179:    verbose(\"variable ctx access var_off=%s off=%d size=%d\",",
          "",
          "[Added Lines]",
          "1189:    verbose(env,",
          "1190:     \"variable ctx access var_off=%s off=%d size=%d\",",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1190:    if (reg_type == SCALAR_VALUE)",
          "1192:    else",
          "1194:    state->regs[value_regno].id = 0;",
          "1195:    state->regs[value_regno].off = 0;",
          "1196:    state->regs[value_regno].range = 0;",
          "",
          "[Removed Lines]",
          "1191:     mark_reg_unknown(state->regs, value_regno);",
          "1193:     mark_reg_known_zero(state->regs, value_regno);",
          "",
          "[Added Lines]",
          "1202:     mark_reg_unknown(env, state->regs, value_regno);",
          "1204:     mark_reg_known_zero(env, state->regs,",
          "1205:           value_regno);",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1206:    char tn_buf[48];",
          "1208:    tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "1210:     tn_buf, off, size);",
          "1211:    return -EACCES;",
          "1212:   }",
          "1213:   off += reg->var_off.value;",
          "1214:   if (off >= 0 || off < -MAX_BPF_STACK) {",
          "1216:    return -EACCES;",
          "1217:   }",
          "",
          "[Removed Lines]",
          "1209:    verbose(\"variable stack access var_off=%s off=%d size=%d\",",
          "1215:    verbose(\"invalid stack off=%d size=%d\\n\", off, size);",
          "",
          "[Added Lines]",
          "1221:    verbose(env, \"variable stack access var_off=%s off=%d size=%d\",",
          "1227:    verbose(env, \"invalid stack off=%d size=%d\\n\", off,",
          "1228:     size);",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1223:    if (!env->allow_ptr_leaks &&",
          "1224:        state->stack_slot_type[MAX_BPF_STACK + off] == STACK_SPILL &&",
          "1225:        size != BPF_REG_SIZE) {",
          "1227:     return -EACCES;",
          "1228:    }",
          "1230:   } else {",
          "1232:   }",
          "1233:  } else if (reg_is_pkt_pointer(reg)) {",
          "1234:   if (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {",
          "1236:    return -EACCES;",
          "1237:   }",
          "1238:   if (t == BPF_WRITE && value_regno >= 0 &&",
          "1239:       is_pointer_value(env, value_regno)) {",
          "1241:    return -EACCES;",
          "1242:   }",
          "1243:   err = check_packet_access(env, regno, off, size);",
          "1244:   if (!err && t == BPF_READ && value_regno >= 0)",
          "1246:  } else {",
          "1249:   return -EACCES;",
          "1250:  }",
          "",
          "[Removed Lines]",
          "1226:     verbose(\"attempt to corrupt spilled pointer on stack\\n\");",
          "1229:    err = check_stack_write(state, off, size, value_regno);",
          "1231:    err = check_stack_read(state, off, size, value_regno);",
          "1235:    verbose(\"cannot write into packet\\n\");",
          "1240:    verbose(\"R%d leaks addr into packet\\n\", value_regno);",
          "1245:    mark_reg_unknown(state->regs, value_regno);",
          "1247:   verbose(\"R%d invalid mem access '%s'\\n\",",
          "1248:    regno, reg_type_str[reg->type]);",
          "",
          "[Added Lines]",
          "1239:     verbose(env, \"attempt to corrupt spilled pointer on stack\\n\");",
          "1242:    err = check_stack_write(env, state, off, size,",
          "1243:       value_regno);",
          "1245:    err = check_stack_read(env, state, off, size,",
          "1246:             value_regno);",
          "1250:    verbose(env, \"cannot write into packet\\n\");",
          "1255:    verbose(env, \"R%d leaks addr into packet\\n\",",
          "1256:     value_regno);",
          "1261:    mark_reg_unknown(env, state->regs, value_regno);",
          "1263:   verbose(env, \"R%d invalid mem access '%s'\\n\", regno,",
          "1264:    reg_type_str[reg->type]);",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1266:  if ((BPF_SIZE(insn->code) != BPF_W && BPF_SIZE(insn->code) != BPF_DW) ||",
          "1267:      insn->imm != 0) {",
          "1269:   return -EINVAL;",
          "1270:  }",
          "",
          "[Removed Lines]",
          "1268:   verbose(\"BPF_XADD uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "1284:   verbose(env, \"BPF_XADD uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1280:   return err;",
          "1282:  if (is_pointer_value(env, insn->src_reg)) {",
          "1284:   return -EACCES;",
          "1285:  }",
          "",
          "[Removed Lines]",
          "1283:   verbose(\"R%d leaks addr into mem\\n\", insn->src_reg);",
          "",
          "[Added Lines]",
          "1299:   verbose(env, \"R%d leaks addr into mem\\n\", insn->src_reg);",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1321:       register_is_null(regs[regno]))",
          "1322:    return 0;",
          "1325:    reg_type_str[regs[regno].type],",
          "1326:    reg_type_str[PTR_TO_STACK]);",
          "1327:   return -EACCES;",
          "",
          "[Removed Lines]",
          "1324:   verbose(\"R%d type=%s expected=%s\\n\", regno,",
          "",
          "[Added Lines]",
          "1340:   verbose(env, \"R%d type=%s expected=%s\\n\", regno,",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "1332:   char tn_buf[48];",
          "1334:   tnum_strn(tn_buf, sizeof(tn_buf), regs[regno].var_off);",
          "1336:    regno, tn_buf);",
          "1337:  }",
          "1338:  off = regs[regno].off + regs[regno].var_off.value;",
          "1339:  if (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||",
          "1340:      access_size <= 0) {",
          "1342:    regno, off, access_size);",
          "1343:   return -EACCES;",
          "1344:  }",
          "",
          "[Removed Lines]",
          "1335:   verbose(\"invalid variable stack read R%d var_off=%s\\n\",",
          "1341:   verbose(\"invalid stack type R%d off=%d access_size=%d\\n\",",
          "",
          "[Added Lines]",
          "1351:   verbose(env, \"invalid variable stack read R%d var_off=%s\\n\",",
          "1357:   verbose(env, \"invalid stack type R%d off=%d access_size=%d\\n\",",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "1355:  for (i = 0; i < access_size; i++) {",
          "1356:   if (state->stack_slot_type[MAX_BPF_STACK + off + i] != STACK_MISC) {",
          "1358:     off, i, access_size);",
          "1359:    return -EACCES;",
          "1360:   }",
          "",
          "[Removed Lines]",
          "1357:    verbose(\"invalid indirect read from stack off %d+%d size %d\\n\",",
          "",
          "[Added Lines]",
          "1373:    verbose(env, \"invalid indirect read from stack off %d+%d size %d\\n\",",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "1398:  if (arg_type == ARG_ANYTHING) {",
          "1399:   if (is_pointer_value(env, regno)) {",
          "1401:    return -EACCES;",
          "1402:   }",
          "1403:   return 0;",
          "",
          "[Removed Lines]",
          "1400:    verbose(\"R%d leaks addr into helper function\\n\", regno);",
          "",
          "[Added Lines]",
          "1416:    verbose(env, \"R%d leaks addr into helper function\\n\",",
          "1417:     regno);",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "1406:  if (type_is_pkt_pointer(type) &&",
          "1407:      !may_access_direct_pkt_data(env, meta, BPF_READ)) {",
          "1409:   return -EACCES;",
          "1410:  }",
          "",
          "[Removed Lines]",
          "1408:   verbose(\"helper access to the packet is not allowed\\n\");",
          "",
          "[Added Lines]",
          "1425:   verbose(env, \"helper access to the packet is not allowed\\n\");",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "1443:    goto err_type;",
          "1444:   meta->raw_mode = arg_type == ARG_PTR_TO_UNINIT_MEM;",
          "1445:  } else {",
          "1447:   return -EFAULT;",
          "1448:  }",
          "",
          "[Removed Lines]",
          "1446:   verbose(\"unsupported arg_type %d\\n\", arg_type);",
          "",
          "[Added Lines]",
          "1463:   verbose(env, \"unsupported arg_type %d\\n\", arg_type);",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "1465:    return -EACCES;",
          "1466:   }",
          "1467:   if (type_is_pkt_pointer(type))",
          "",
          "[Removed Lines]",
          "1464:    verbose(\"invalid map_ptr to access map->key\\n\");",
          "",
          "[Added Lines]",
          "1481:    verbose(env, \"invalid map_ptr to access map->key\\n\");",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "1478:   if (!meta->map_ptr) {",
          "1481:    return -EACCES;",
          "1482:   }",
          "1483:   if (type_is_pkt_pointer(type))",
          "",
          "[Removed Lines]",
          "1480:    verbose(\"invalid map_ptr to access map->value\\n\");",
          "",
          "[Added Lines]",
          "1497:    verbose(env, \"invalid map_ptr to access map->value\\n\");",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "1498:   if (regno == 0) {",
          "1501:    return -EACCES;",
          "1502:   }",
          "",
          "[Removed Lines]",
          "1500:    verbose(\"ARG_CONST_SIZE cannot be first argument\\n\");",
          "",
          "[Added Lines]",
          "1517:    verbose(env,",
          "1518:     \"ARG_CONST_SIZE cannot be first argument\\n\");",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "1514:    meta = NULL;",
          "1516:   if (reg->smin_value < 0) {",
          "1518:     regno);",
          "1519:    return -EACCES;",
          "1520:   }",
          "",
          "[Removed Lines]",
          "1517:    verbose(\"R%d min value is negative, either use unsigned or 'var &= const'\\n\",",
          "",
          "[Added Lines]",
          "1535:    verbose(env, \"R%d min value is negative, either use unsigned or 'var &= const'\\n\",",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "1528:   }",
          "1530:   if (reg->umax_value >= BPF_MAX_VAR_SIZ) {",
          "1532:     regno);",
          "1533:    return -EACCES;",
          "1534:   }",
          "",
          "[Removed Lines]",
          "1531:    verbose(\"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",",
          "",
          "[Added Lines]",
          "1549:    verbose(env, \"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "1540:  return err;",
          "1541: err_type:",
          "1543:   reg_type_str[type], reg_type_str[expected_type]);",
          "1544:  return -EACCES;",
          "1545: }",
          "1548: {",
          "1549:  if (!map)",
          "1550:   return 0;",
          "",
          "[Removed Lines]",
          "1542:  verbose(\"R%d type=%s expected=%s\\n\", regno,",
          "1547: static int check_map_func_compatibility(struct bpf_map *map, int func_id)",
          "",
          "[Added Lines]",
          "1560:  verbose(env, \"R%d type=%s expected=%s\\n\", regno,",
          "1565: static int check_map_func_compatibility(struct bpf_verifier_env *env,",
          "1566:      struct bpf_map *map, int func_id)",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "1633:  return 0;",
          "1634: error:",
          "1636:   map->map_type, func_id_name(func_id), func_id);",
          "1637:  return -EINVAL;",
          "1638: }",
          "",
          "[Removed Lines]",
          "1635:  verbose(\"cannot pass map_type %d into func %s#%d\\n\",",
          "",
          "[Added Lines]",
          "1654:  verbose(env, \"cannot pass map_type %d into func %s#%d\\n\",",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "1667:  for (i = 0; i < MAX_BPF_REG; i++)",
          "1668:   if (reg_is_pkt_pointer_any(&regs[i]))",
          "1671:  for (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {",
          "1672:   if (state->stack_slot_type[i] != STACK_SPILL)",
          "",
          "[Removed Lines]",
          "1669:    mark_reg_unknown(regs, i);",
          "",
          "[Added Lines]",
          "1688:    mark_reg_unknown(env, regs, i);",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "1690:  if (func_id < 0 || func_id >= __BPF_FUNC_MAX_ID) {",
          "1692:   return -EINVAL;",
          "1693:  }",
          "",
          "[Removed Lines]",
          "1691:   verbose(\"invalid func %s#%d\\n\", func_id_name(func_id), func_id);",
          "",
          "[Added Lines]",
          "1710:   verbose(env, \"invalid func %s#%d\\n\", func_id_name(func_id),",
          "1711:    func_id);",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "1696:   fn = env->prog->aux->ops->get_func_proto(func_id);",
          "1698:  if (!fn) {",
          "1700:   return -EINVAL;",
          "1701:  }",
          "1704:  if (!env->prog->gpl_compatible && fn->gpl_only) {",
          "1706:   return -EINVAL;",
          "1707:  }",
          "",
          "[Removed Lines]",
          "1699:   verbose(\"unknown func %s#%d\\n\", func_id_name(func_id), func_id);",
          "1705:   verbose(\"cannot call GPL only function from proprietary program\\n\");",
          "",
          "[Added Lines]",
          "1719:   verbose(env, \"unknown func %s#%d\\n\", func_id_name(func_id),",
          "1720:    func_id);",
          "1726:   verbose(env, \"cannot call GPL only function from proprietary program\\n\");",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "1717:  err = check_raw_mode(fn);",
          "1718:  if (err) {",
          "1720:    func_id_name(func_id), func_id);",
          "1721:   return err;",
          "1722:  }",
          "",
          "[Removed Lines]",
          "1719:   verbose(\"kernel subsystem misconfigured func %s#%d\\n\",",
          "",
          "[Added Lines]",
          "1740:   verbose(env, \"kernel subsystem misconfigured func %s#%d\\n\",",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "1751:  for (i = 0; i < CALLER_SAVED_REGS; i++) {",
          "1753:   check_reg_arg(env, caller_saved[i], DST_OP_NO_MARK);",
          "1754:  }",
          "1757:  if (fn->ret_type == RET_INTEGER) {",
          "1760:  } else if (fn->ret_type == RET_VOID) {",
          "1761:   regs[BPF_REG_0].type = NOT_INIT;",
          "1762:  } else if (fn->ret_type == RET_PTR_TO_MAP_VALUE_OR_NULL) {",
          "",
          "[Removed Lines]",
          "1752:   mark_reg_not_init(regs, caller_saved[i]);",
          "1759:   mark_reg_unknown(regs, BPF_REG_0);",
          "",
          "[Added Lines]",
          "1773:   mark_reg_not_init(env, regs, caller_saved[i]);",
          "1780:   mark_reg_unknown(env, regs, BPF_REG_0);",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "1765:   regs[BPF_REG_0].type = PTR_TO_MAP_VALUE_OR_NULL;",
          "1768:   regs[BPF_REG_0].off = 0;",
          "1773:   if (meta.map_ptr == NULL) {",
          "1775:    return -EINVAL;",
          "1776:   }",
          "1777:   regs[BPF_REG_0].map_ptr = meta.map_ptr;",
          "",
          "[Removed Lines]",
          "1767:   mark_reg_known_zero(regs, BPF_REG_0);",
          "1774:    verbose(\"kernel subsystem misconfigured verifier\\n\");",
          "",
          "[Added Lines]",
          "1788:   mark_reg_known_zero(env, regs, BPF_REG_0);",
          "1795:    verbose(env,",
          "1796:     \"kernel subsystem misconfigured verifier\\n\");",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "1782:   else if (insn_aux->map_ptr != meta.map_ptr)",
          "1783:    insn_aux->map_ptr = BPF_MAP_PTR_POISON;",
          "1784:  } else {",
          "1786:    fn->ret_type, func_id_name(func_id), func_id);",
          "1787:   return -EINVAL;",
          "1788:  }",
          "1791:  if (err)",
          "1792:   return err;",
          "",
          "[Removed Lines]",
          "1785:   verbose(\"unknown return type %d of func %s#%d\\n\",",
          "1790:  err = check_map_func_compatibility(meta.map_ptr, func_id);",
          "",
          "[Added Lines]",
          "1807:   verbose(env, \"unknown return type %d of func %s#%d\\n\",",
          "1812:  err = check_map_func_compatibility(env, meta.map_ptr, func_id);",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "1846:  dst_reg = &regs[dst];",
          "1848:  if (WARN_ON_ONCE(known && (smin_val != smax_val))) {",
          "1851:   return -EINVAL;",
          "1852:  }",
          "1853:  if (WARN_ON_ONCE(known && (umin_val != umax_val))) {",
          "1856:   return -EINVAL;",
          "1857:  }",
          "1859:  if (BPF_CLASS(insn->code) != BPF_ALU64) {",
          "1861:   if (!env->allow_ptr_leaks)",
          "1863:     dst);",
          "1864:   return -EACCES;",
          "1865:  }",
          "1867:  if (ptr_reg->type == PTR_TO_MAP_VALUE_OR_NULL) {",
          "1868:   if (!env->allow_ptr_leaks)",
          "1870:     dst);",
          "1871:   return -EACCES;",
          "1872:  }",
          "1873:  if (ptr_reg->type == CONST_PTR_TO_MAP) {",
          "1874:   if (!env->allow_ptr_leaks)",
          "1876:     dst);",
          "1877:   return -EACCES;",
          "1878:  }",
          "1879:  if (ptr_reg->type == PTR_TO_PACKET_END) {",
          "1880:   if (!env->allow_ptr_leaks)",
          "1882:     dst);",
          "1883:   return -EACCES;",
          "1884:  }",
          "",
          "[Removed Lines]",
          "1849:   print_verifier_state(&env->cur_state);",
          "1850:   verbose(\"verifier internal error: known but bad sbounds\\n\");",
          "1854:   print_verifier_state(&env->cur_state);",
          "1855:   verbose(\"verifier internal error: known but bad ubounds\\n\");",
          "1862:    verbose(\"R%d 32-bit pointer arithmetic prohibited\\n\",",
          "1869:    verbose(\"R%d pointer arithmetic on PTR_TO_MAP_VALUE_OR_NULL prohibited, null-check it first\\n\",",
          "1875:    verbose(\"R%d pointer arithmetic on CONST_PTR_TO_MAP prohibited\\n\",",
          "1881:    verbose(\"R%d pointer arithmetic on PTR_TO_PACKET_END prohibited\\n\",",
          "",
          "[Added Lines]",
          "1871:   print_verifier_state(env, &env->cur_state);",
          "1872:   verbose(env,",
          "1873:    \"verifier internal error: known but bad sbounds\\n\");",
          "1877:   print_verifier_state(env, &env->cur_state);",
          "1878:   verbose(env,",
          "1879:    \"verifier internal error: known but bad ubounds\\n\");",
          "1886:    verbose(env,",
          "1887:     \"R%d 32-bit pointer arithmetic prohibited\\n\",",
          "1894:    verbose(env, \"R%d pointer arithmetic on PTR_TO_MAP_VALUE_OR_NULL prohibited, null-check it first\\n\",",
          "1900:    verbose(env, \"R%d pointer arithmetic on CONST_PTR_TO_MAP prohibited\\n\",",
          "1906:    verbose(env, \"R%d pointer arithmetic on PTR_TO_PACKET_END prohibited\\n\",",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "1943:   if (dst_reg == off_reg) {",
          "1945:    if (!env->allow_ptr_leaks)",
          "1947:      dst);",
          "1948:    return -EACCES;",
          "1949:   }",
          "",
          "[Removed Lines]",
          "1946:     verbose(\"R%d tried to subtract pointer from scalar\\n\",",
          "",
          "[Added Lines]",
          "1971:     verbose(env, \"R%d tried to subtract pointer from scalar\\n\",",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "1954:   if (ptr_reg->type == PTR_TO_STACK) {",
          "1955:    if (!env->allow_ptr_leaks)",
          "1957:      dst);",
          "1958:    return -EACCES;",
          "1959:   }",
          "",
          "[Removed Lines]",
          "1956:     verbose(\"R%d subtraction from stack pointer prohibited\\n\",",
          "",
          "[Added Lines]",
          "1981:     verbose(env, \"R%d subtraction from stack pointer prohibited\\n\",",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "2010:   if (!env->allow_ptr_leaks)",
          "2012:     dst, bpf_alu_string[opcode >> 4]);",
          "2013:   return -EACCES;",
          "2014:  default:",
          "2016:   if (!env->allow_ptr_leaks)",
          "2018:     dst, bpf_alu_string[opcode >> 4]);",
          "2019:   return -EACCES;",
          "2020:  }",
          "",
          "[Removed Lines]",
          "2011:    verbose(\"R%d bitwise operator %s on pointer prohibited\\n\",",
          "2017:    verbose(\"R%d pointer arithmetic with %s operator prohibited\\n\",",
          "",
          "[Added Lines]",
          "2036:    verbose(env, \"R%d bitwise operator %s on pointer prohibited\\n\",",
          "2042:    verbose(env, \"R%d pointer arithmetic with %s operator prohibited\\n\",",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "2184:    break;",
          "2185:   }",
          "",
          "[Removed Lines]",
          "2183:    mark_reg_unknown(regs, insn->dst_reg);",
          "",
          "[Added Lines]",
          "2208:    mark_reg_unknown(env, regs, insn->dst_reg);",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "2212:    break;",
          "2213:   }",
          "",
          "[Removed Lines]",
          "2211:    mark_reg_unknown(regs, insn->dst_reg);",
          "",
          "[Added Lines]",
          "2236:    mark_reg_unknown(env, regs, insn->dst_reg);",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "2236:   __update_reg_bounds(dst_reg);",
          "2237:   break;",
          "2238:  default:",
          "2240:   break;",
          "2241:  }",
          "",
          "[Removed Lines]",
          "2239:   mark_reg_unknown(regs, insn->dst_reg);",
          "",
          "[Added Lines]",
          "2264:   mark_reg_unknown(env, regs, insn->dst_reg);",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "2270:     if (!env->allow_ptr_leaks) {",
          "2272:       insn->dst_reg,",
          "2273:       bpf_alu_string[opcode >> 4]);",
          "2274:      return -EACCES;",
          "2275:     }",
          "2277:     return 0;",
          "2278:    } else {",
          "",
          "[Removed Lines]",
          "2271:      verbose(\"R%d pointer %s pointer prohibited\\n\",",
          "2276:     mark_reg_unknown(regs, insn->dst_reg);",
          "",
          "[Added Lines]",
          "2296:      verbose(env, \"R%d pointer %s pointer prohibited\\n\",",
          "2301:     mark_reg_unknown(env, regs, insn->dst_reg);",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "2327:  if (WARN_ON_ONCE(ptr_reg)) {",
          "2330:   return -EINVAL;",
          "2331:  }",
          "2332:  if (WARN_ON(!src_reg)) {",
          "2335:   return -EINVAL;",
          "2336:  }",
          "2337:  return adjust_scalar_min_max_vals(env, insn, dst_reg, *src_reg);",
          "",
          "[Removed Lines]",
          "2328:   print_verifier_state(&env->cur_state);",
          "2329:   verbose(\"verifier internal error: unexpected ptr_reg\\n\");",
          "2333:   print_verifier_state(&env->cur_state);",
          "2334:   verbose(\"verifier internal error: no src_reg\\n\");",
          "",
          "[Added Lines]",
          "2353:   print_verifier_state(env, &env->cur_state);",
          "2354:   verbose(env, \"verifier internal error: unexpected ptr_reg\\n\");",
          "2358:   print_verifier_state(env, &env->cur_state);",
          "2359:   verbose(env, \"verifier internal error: no src_reg\\n\");",
          "",
          "---------------",
          "--- Hunk 69 ---",
          "[Context before]",
          "2349:    if (BPF_SRC(insn->code) != 0 ||",
          "2350:        insn->src_reg != BPF_REG_0 ||",
          "2351:        insn->off != 0 || insn->imm != 0) {",
          "2353:     return -EINVAL;",
          "2354:    }",
          "2355:   } else {",
          "2356:    if (insn->src_reg != BPF_REG_0 || insn->off != 0 ||",
          "2357:        (insn->imm != 16 && insn->imm != 32 && insn->imm != 64) ||",
          "2358:        BPF_CLASS(insn->code) == BPF_ALU64) {",
          "2360:     return -EINVAL;",
          "2361:    }",
          "2362:   }",
          "",
          "[Removed Lines]",
          "2352:     verbose(\"BPF_NEG uses reserved fields\\n\");",
          "2359:     verbose(\"BPF_END uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "2377:     verbose(env, \"BPF_NEG uses reserved fields\\n\");",
          "2384:     verbose(env, \"BPF_END uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 70 ---",
          "[Context before]",
          "2367:    return err;",
          "2369:   if (is_pointer_value(env, insn->dst_reg)) {",
          "2371:     insn->dst_reg);",
          "2372:    return -EACCES;",
          "2373:   }",
          "",
          "[Removed Lines]",
          "2370:    verbose(\"R%d pointer arithmetic prohibited\\n\",",
          "",
          "[Added Lines]",
          "2395:    verbose(env, \"R%d pointer arithmetic prohibited\\n\",",
          "",
          "---------------",
          "--- Hunk 71 ---",
          "[Context before]",
          "2382:   if (BPF_SRC(insn->code) == BPF_X) {",
          "2383:    if (insn->imm != 0 || insn->off != 0) {",
          "2385:     return -EINVAL;",
          "2386:    }",
          "",
          "[Removed Lines]",
          "2384:     verbose(\"BPF_MOV uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "2409:     verbose(env, \"BPF_MOV uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 72 ---",
          "[Context before]",
          "2391:     return err;",
          "2392:   } else {",
          "2393:    if (insn->src_reg != BPF_REG_0 || insn->off != 0) {",
          "2395:     return -EINVAL;",
          "2396:    }",
          "2397:   }",
          "",
          "[Removed Lines]",
          "2394:     verbose(\"BPF_MOV uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "2419:     verbose(env, \"BPF_MOV uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 73 ---",
          "[Context before]",
          "2411:    } else {",
          "2413:     if (is_pointer_value(env, insn->src_reg)) {",
          "2415:       insn->src_reg);",
          "2416:      return -EACCES;",
          "2417:     }",
          "2420:     regs[insn->dst_reg].var_off = tnum_cast(",
          "2421:       regs[insn->dst_reg].var_off, 4);",
          "",
          "[Removed Lines]",
          "2414:      verbose(\"R%d partial copy of pointer\\n\",",
          "2418:     mark_reg_unknown(regs, insn->dst_reg);",
          "",
          "[Added Lines]",
          "2439:      verbose(env,",
          "2440:       \"R%d partial copy of pointer\\n\",",
          "2444:     mark_reg_unknown(env, regs, insn->dst_reg);",
          "",
          "---------------",
          "--- Hunk 74 ---",
          "[Context before]",
          "2430:   }",
          "2432:  } else if (opcode > BPF_END) {",
          "2434:   return -EINVAL;",
          "2438:   if (BPF_SRC(insn->code) == BPF_X) {",
          "2439:    if (insn->imm != 0 || insn->off != 0) {",
          "2441:     return -EINVAL;",
          "2442:    }",
          "",
          "[Removed Lines]",
          "2433:   verbose(\"invalid BPF_ALU opcode %x\\n\", opcode);",
          "2440:     verbose(\"BPF_ALU uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "2459:   verbose(env, \"invalid BPF_ALU opcode %x\\n\", opcode);",
          "2466:     verbose(env, \"BPF_ALU uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 75 ---",
          "[Context before]",
          "2446:     return err;",
          "2447:   } else {",
          "2448:    if (insn->src_reg != BPF_REG_0 || insn->off != 0) {",
          "2450:     return -EINVAL;",
          "2451:    }",
          "2452:   }",
          "",
          "[Removed Lines]",
          "2449:     verbose(\"BPF_ALU uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "2475:     verbose(env, \"BPF_ALU uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 76 ---",
          "[Context before]",
          "2459:   if ((opcode == BPF_MOD || opcode == BPF_DIV) &&",
          "2460:       BPF_SRC(insn->code) == BPF_K && insn->imm == 0) {",
          "2462:    return -EINVAL;",
          "2463:   }",
          "",
          "[Removed Lines]",
          "2461:    verbose(\"div by zero\\n\");",
          "",
          "[Added Lines]",
          "2487:    verbose(env, \"div by zero\\n\");",
          "",
          "---------------",
          "--- Hunk 77 ---",
          "[Context before]",
          "2467:    int size = BPF_CLASS(insn->code) == BPF_ALU64 ? 64 : 32;",
          "2469:    if (insn->imm < 0 || insn->imm >= size) {",
          "2471:     return -EINVAL;",
          "2472:    }",
          "2473:   }",
          "",
          "[Removed Lines]",
          "2470:     verbose(\"invalid shift %d\\n\", insn->imm);",
          "",
          "[Added Lines]",
          "2496:     verbose(env, \"invalid shift %d\\n\", insn->imm);",
          "",
          "---------------",
          "--- Hunk 78 ---",
          "[Context before]",
          "2820:  int err;",
          "2822:  if (opcode > BPF_JSLE) {",
          "2824:   return -EINVAL;",
          "2825:  }",
          "2827:  if (BPF_SRC(insn->code) == BPF_X) {",
          "2828:   if (insn->imm != 0) {",
          "2830:    return -EINVAL;",
          "2831:   }",
          "",
          "[Removed Lines]",
          "2823:   verbose(\"invalid BPF_JMP opcode %x\\n\", opcode);",
          "2829:    verbose(\"BPF_JMP uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "2849:   verbose(env, \"invalid BPF_JMP opcode %x\\n\", opcode);",
          "2855:    verbose(env, \"BPF_JMP uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 79 ---",
          "[Context before]",
          "2836:    return err;",
          "2838:   if (is_pointer_value(env, insn->src_reg)) {",
          "2840:     insn->src_reg);",
          "2841:    return -EACCES;",
          "2842:   }",
          "2843:  } else {",
          "2844:   if (insn->src_reg != BPF_REG_0) {",
          "2846:    return -EINVAL;",
          "2847:   }",
          "2848:  }",
          "",
          "[Removed Lines]",
          "2839:    verbose(\"R%d pointer comparison prohibited\\n\",",
          "2845:    verbose(\"BPF_JMP uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "2865:    verbose(env, \"R%d pointer comparison prohibited\\n\",",
          "2871:    verbose(env, \"BPF_JMP uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 80 ---",
          "[Context before]",
          "2954:   find_good_pkt_pointers(this_branch, &regs[insn->src_reg],",
          "2955:            PTR_TO_PACKET_META);",
          "2956:  } else if (is_pointer_value(env, insn->dst_reg)) {",
          "2958:   return -EACCES;",
          "2959:  }",
          "2962:  return 0;",
          "2963: }",
          "",
          "[Removed Lines]",
          "2957:   verbose(\"R%d pointer comparison prohibited\\n\", insn->dst_reg);",
          "2960:  if (verifier_log.level)",
          "2961:   print_verifier_state(this_branch);",
          "",
          "[Added Lines]",
          "2983:   verbose(env, \"R%d pointer comparison prohibited\\n\",",
          "2984:    insn->dst_reg);",
          "2987:  if (env->log.level)",
          "2988:   print_verifier_state(env, this_branch);",
          "",
          "---------------",
          "--- Hunk 81 ---",
          "[Context before]",
          "2977:  int err;",
          "2979:  if (BPF_SIZE(insn->code) != BPF_DW) {",
          "2981:   return -EINVAL;",
          "2982:  }",
          "2983:  if (insn->off != 0) {",
          "2985:   return -EINVAL;",
          "2986:  }",
          "",
          "[Removed Lines]",
          "2980:   verbose(\"invalid BPF_LD_IMM insn\\n\");",
          "2984:   verbose(\"BPF_LD_IMM64 uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "3007:   verbose(env, \"invalid BPF_LD_IMM insn\\n\");",
          "3011:   verbose(env, \"BPF_LD_IMM64 uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 82 ---",
          "[Context before]",
          "3039:  int i, err;",
          "3041:  if (!may_access_skb(env->prog->type)) {",
          "3043:   return -EINVAL;",
          "3044:  }",
          "3046:  if (insn->dst_reg != BPF_REG_0 || insn->off != 0 ||",
          "3047:      BPF_SIZE(insn->code) == BPF_DW ||",
          "3048:      (mode == BPF_ABS && insn->src_reg != BPF_REG_0)) {",
          "3050:   return -EINVAL;",
          "3051:  }",
          "",
          "[Removed Lines]",
          "3042:   verbose(\"BPF_LD_[ABS|IND] instructions not allowed for this program type\\n\");",
          "3049:   verbose(\"BPF_LD_[ABS|IND] uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "3069:   verbose(env, \"BPF_LD_[ABS|IND] instructions not allowed for this program type\\n\");",
          "3076:   verbose(env, \"BPF_LD_[ABS|IND] uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 83 ---",
          "[Context before]",
          "3056:   return err;",
          "3058:  if (regs[BPF_REG_6].type != PTR_TO_CTX) {",
          "3060:   return -EINVAL;",
          "3061:  }",
          "",
          "[Removed Lines]",
          "3059:   verbose(\"at the time of BPF_LD_ABS|IND R6 != pointer to skb\\n\");",
          "",
          "[Added Lines]",
          "3086:   verbose(env,",
          "3087:    \"at the time of BPF_LD_ABS|IND R6 != pointer to skb\\n\");",
          "",
          "---------------",
          "--- Hunk 84 ---",
          "[Context before]",
          "3071:  for (i = 0; i < CALLER_SAVED_REGS; i++) {",
          "3073:   check_reg_arg(env, caller_saved[i], DST_OP_NO_MARK);",
          "3074:  }",
          "",
          "[Removed Lines]",
          "3072:   mark_reg_not_init(regs, caller_saved[i]);",
          "",
          "[Added Lines]",
          "3100:   mark_reg_not_init(env, regs, caller_saved[i]);",
          "",
          "---------------",
          "--- Hunk 85 ---",
          "[Context before]",
          "3081:  return 0;",
          "3082: }",
          "",
          "[Removed Lines]",
          "3080:  mark_reg_unknown(regs, BPF_REG_0);",
          "",
          "[Added Lines]",
          "3108:  mark_reg_unknown(env, regs, BPF_REG_0);",
          "",
          "---------------",
          "--- Hunk 86 ---",
          "[Context before]",
          "3098:  reg = &env->cur_state.regs[BPF_REG_0];",
          "3099:  if (reg->type != SCALAR_VALUE) {",
          "3101:    reg_type_str[reg->type]);",
          "3102:   return -EINVAL;",
          "3103:  }",
          "3105:  if (!tnum_in(range, reg->var_off)) {",
          "3107:   if (!tnum_is_unknown(reg->var_off)) {",
          "3108:    char tn_buf[48];",
          "3110:    tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "3112:   } else {",
          "3114:   }",
          "3116:   return -EINVAL;",
          "3117:  }",
          "3118:  return 0;",
          "",
          "[Removed Lines]",
          "3100:   verbose(\"At program exit the register R0 is not a known value (%s)\\n\",",
          "3106:   verbose(\"At program exit the register R0 \");",
          "3111:    verbose(\"has value %s\", tn_buf);",
          "3113:    verbose(\"has unknown scalar value\");",
          "3115:   verbose(\" should have been 0 or 1\\n\");",
          "",
          "[Added Lines]",
          "3128:   verbose(env, \"At program exit the register R0 is not a known value (%s)\\n\",",
          "3134:   verbose(env, \"At program exit the register R0 \");",
          "3139:    verbose(env, \"has value %s\", tn_buf);",
          "3141:    verbose(env, \"has unknown scalar value\");",
          "3143:   verbose(env, \" should have been 0 or 1\\n\");",
          "",
          "---------------",
          "--- Hunk 87 ---",
          "[Context before]",
          "3178:   return 0;",
          "3180:  if (w < 0 || w >= env->prog->len) {",
          "3182:   return -EINVAL;",
          "3183:  }",
          "",
          "[Removed Lines]",
          "3181:   verbose(\"jump out of range from insn %d to %d\\n\", t, w);",
          "",
          "[Added Lines]",
          "3209:   verbose(env, \"jump out of range from insn %d to %d\\n\", t, w);",
          "",
          "---------------",
          "--- Hunk 88 ---",
          "[Context before]",
          "3195:   insn_stack[cur_stack++] = w;",
          "3196:   return 1;",
          "3197:  } else if ((insn_state[w] & 0xF0) == DISCOVERED) {",
          "3199:   return -EINVAL;",
          "3200:  } else if (insn_state[w] == EXPLORED) {",
          "3202:   insn_state[t] = DISCOVERED | e;",
          "3203:  } else {",
          "3205:   return -EFAULT;",
          "3206:  }",
          "3207:  return 0;",
          "",
          "[Removed Lines]",
          "3198:   verbose(\"back-edge from insn %d to %d\\n\", t, w);",
          "3204:   verbose(\"insn state internal bug\\n\");",
          "",
          "[Added Lines]",
          "3226:   verbose(env, \"back-edge from insn %d to %d\\n\", t, w);",
          "3232:   verbose(env, \"insn state internal bug\\n\");",
          "",
          "---------------",
          "--- Hunk 89 ---",
          "[Context before]",
          "3295: mark_explored:",
          "3296:  insn_state[t] = EXPLORED;",
          "3297:  if (cur_stack-- <= 0) {",
          "3299:   ret = -EFAULT;",
          "3300:   goto err_free;",
          "3301:  }",
          "",
          "[Removed Lines]",
          "3298:   verbose(\"pop stack internal bug\\n\");",
          "",
          "[Added Lines]",
          "3326:   verbose(env, \"pop stack internal bug\\n\");",
          "",
          "---------------",
          "--- Hunk 90 ---",
          "[Context before]",
          "3304: check_state:",
          "3305:  for (i = 0; i < insn_cnt; i++) {",
          "3306:   if (insn_state[i] != EXPLORED) {",
          "3308:    ret = -EINVAL;",
          "3309:    goto err_free;",
          "3310:   }",
          "",
          "[Removed Lines]",
          "3307:    verbose(\"unreachable insn %d\\n\", i);",
          "",
          "[Added Lines]",
          "3335:    verbose(env, \"unreachable insn %d\\n\", i);",
          "",
          "---------------",
          "--- Hunk 91 ---",
          "[Context before]",
          "3685:  int insn_processed = 0;",
          "3686:  bool do_print_state = false;",
          "3689:  state->parent = NULL;",
          "3690:  insn_idx = 0;",
          "3691:  for (;;) {",
          "",
          "[Removed Lines]",
          "3688:  init_reg_state(regs);",
          "",
          "[Added Lines]",
          "3716:  init_reg_state(env, regs);",
          "",
          "---------------",
          "--- Hunk 92 ---",
          "[Context before]",
          "3694:   int err;",
          "3696:   if (insn_idx >= insn_cnt) {",
          "3698:     insn_idx, insn_cnt);",
          "3699:    return -EFAULT;",
          "3700:   }",
          "",
          "[Removed Lines]",
          "3697:    verbose(\"invalid insn idx %d insn_cnt %d\\n\",",
          "",
          "[Added Lines]",
          "3725:    verbose(env, \"invalid insn idx %d insn_cnt %d\\n\",",
          "",
          "---------------",
          "--- Hunk 93 ---",
          "[Context before]",
          "3703:   class = BPF_CLASS(insn->code);",
          "3705:   if (++insn_processed > BPF_COMPLEXITY_LIMIT_INSNS) {",
          "3707:     insn_processed);",
          "3708:    return -E2BIG;",
          "3709:   }",
          "",
          "[Removed Lines]",
          "3706:    verbose(\"BPF program is too large. Processed %d insn\\n\",",
          "",
          "[Added Lines]",
          "3734:    verbose(env,",
          "3735:     \"BPF program is too large. Processed %d insn\\n\",",
          "",
          "---------------",
          "--- Hunk 94 ---",
          "[Context before]",
          "3713:    return err;",
          "3714:   if (err == 1) {",
          "3717:     if (do_print_state)",
          "3719:       prev_insn_idx, insn_idx);",
          "3720:     else",
          "3722:    }",
          "3723:    goto process_bpf_exit;",
          "3724:   }",
          "",
          "[Removed Lines]",
          "3716:    if (verifier_log.level) {",
          "3718:      verbose(\"\\nfrom %d to %d: safe\\n\",",
          "3721:      verbose(\"%d: safe\\n\", insn_idx);",
          "",
          "[Added Lines]",
          "3745:    if (env->log.level) {",
          "3747:      verbose(env, \"\\nfrom %d to %d: safe\\n\",",
          "3750:      verbose(env, \"%d: safe\\n\", insn_idx);",
          "",
          "---------------",
          "--- Hunk 95 ---",
          "[Context before]",
          "3726:   if (need_resched())",
          "3727:    cond_resched();",
          "3733:    else",
          "3735:      prev_insn_idx, insn_idx);",
          "3737:    do_print_state = false;",
          "3738:   }",
          "3742:    print_bpf_insn(env, insn);",
          "3743:   }",
          "",
          "[Removed Lines]",
          "3729:   if (verifier_log.level > 1 ||",
          "3730:       (verifier_log.level && do_print_state)) {",
          "3731:    if (verifier_log.level > 1)",
          "3732:     verbose(\"%d:\", insn_idx);",
          "3734:     verbose(\"\\nfrom %d to %d:\",",
          "3736:    print_verifier_state(&env->cur_state);",
          "3740:   if (verifier_log.level) {",
          "3741:    verbose(\"%d: \", insn_idx);",
          "",
          "[Added Lines]",
          "3758:   if (env->log.level > 1 || (env->log.level && do_print_state)) {",
          "3759:    if (env->log.level > 1)",
          "3760:     verbose(env, \"%d:\", insn_idx);",
          "3762:     verbose(env, \"\\nfrom %d to %d:\",",
          "3764:    print_verifier_state(env, &env->cur_state);",
          "3768:   if (env->log.level) {",
          "3769:    verbose(env, \"%d: \", insn_idx);",
          "",
          "---------------",
          "--- Hunk 96 ---",
          "[Context before]",
          "3799:     return -EINVAL;",
          "3800:    }",
          "",
          "[Removed Lines]",
          "3798:     verbose(\"same insn cannot be used with different pointers\\n\");",
          "",
          "[Added Lines]",
          "3826:     verbose(env, \"same insn cannot be used with different pointers\\n\");",
          "",
          "---------------",
          "--- Hunk 97 ---",
          "[Context before]",
          "3835:    } else if (dst_reg_type != *prev_dst_type &&",
          "3836:        (dst_reg_type == PTR_TO_CTX ||",
          "3839:     return -EINVAL;",
          "3840:    }",
          "3842:   } else if (class == BPF_ST) {",
          "3843:    if (BPF_MODE(insn->code) != BPF_MEM ||",
          "3844:        insn->src_reg != BPF_REG_0) {",
          "3846:     return -EINVAL;",
          "3847:    }",
          "",
          "[Removed Lines]",
          "3838:     verbose(\"same insn cannot be used with different pointers\\n\");",
          "3845:     verbose(\"BPF_ST uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "3866:     verbose(env, \"same insn cannot be used with different pointers\\n\");",
          "3873:     verbose(env, \"BPF_ST uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 98 ---",
          "[Context before]",
          "3865:         insn->off != 0 ||",
          "3866:         insn->src_reg != BPF_REG_0 ||",
          "3867:         insn->dst_reg != BPF_REG_0) {",
          "3869:      return -EINVAL;",
          "3870:     }",
          "",
          "[Removed Lines]",
          "3868:      verbose(\"BPF_CALL uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "3896:      verbose(env, \"BPF_CALL uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 99 ---",
          "[Context before]",
          "3878:         insn->imm != 0 ||",
          "3879:         insn->src_reg != BPF_REG_0 ||",
          "3880:         insn->dst_reg != BPF_REG_0) {",
          "3882:      return -EINVAL;",
          "3883:     }",
          "",
          "[Removed Lines]",
          "3881:      verbose(\"BPF_JA uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "3909:      verbose(env, \"BPF_JA uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 100 ---",
          "[Context before]",
          "3890:         insn->imm != 0 ||",
          "3891:         insn->src_reg != BPF_REG_0 ||",
          "3892:         insn->dst_reg != BPF_REG_0) {",
          "3894:      return -EINVAL;",
          "3895:     }",
          "",
          "[Removed Lines]",
          "3893:      verbose(\"BPF_EXIT uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "3921:      verbose(env, \"BPF_EXIT uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 101 ---",
          "[Context before]",
          "3905:      return err;",
          "3907:     if (is_pointer_value(env, BPF_REG_0)) {",
          "3909:      return -EACCES;",
          "3910:     }",
          "",
          "[Removed Lines]",
          "3908:      verbose(\"R0 leaks addr as return value\\n\");",
          "",
          "[Added Lines]",
          "3936:      verbose(env, \"R0 leaks addr as return value\\n\");",
          "",
          "---------------",
          "--- Hunk 102 ---",
          "[Context before]",
          "3941:     insn_idx++;",
          "3942:    } else {",
          "3944:     return -EINVAL;",
          "3945:    }",
          "3946:   } else {",
          "3948:    return -EINVAL;",
          "3949:   }",
          "3951:   insn_idx++;",
          "3952:  }",
          "3956:  return 0;",
          "3957: }",
          "",
          "[Removed Lines]",
          "3943:     verbose(\"invalid BPF_LD mode\\n\");",
          "3947:    verbose(\"unknown insn class %d\\n\", class);",
          "3954:  verbose(\"processed %d insns, stack depth %d\\n\",",
          "3955:   insn_processed, env->prog->aux->stack_depth);",
          "",
          "[Added Lines]",
          "3971:     verbose(env, \"invalid BPF_LD mode\\n\");",
          "3975:    verbose(env, \"unknown insn class %d\\n\", class);",
          "3982:  verbose(env, \"processed %d insns, stack depth %d\\n\", insn_processed,",
          "3983:   env->prog->aux->stack_depth);",
          "",
          "---------------",
          "--- Hunk 103 ---",
          "[Context before]",
          "3964:   !(map->map_flags & BPF_F_NO_PREALLOC);",
          "3965: }",
          "3968:      struct bpf_prog *prog)",
          "3970: {",
          "",
          "[Removed Lines]",
          "3967: static int check_map_prog_compatibility(struct bpf_map *map,",
          "",
          "[Added Lines]",
          "3995: static int check_map_prog_compatibility(struct bpf_verifier_env *env,",
          "3996:      struct bpf_map *map,",
          "",
          "---------------",
          "--- Hunk 104 ---",
          "[Context before]",
          "3976:  if (prog->type == BPF_PROG_TYPE_PERF_EVENT) {",
          "3977:   if (!check_map_prealloc(map)) {",
          "3979:    return -EINVAL;",
          "3980:   }",
          "3981:   if (map->inner_map_meta &&",
          "3982:       !check_map_prealloc(map->inner_map_meta)) {",
          "3984:    return -EINVAL;",
          "3985:   }",
          "3986:  }",
          "",
          "[Removed Lines]",
          "3978:    verbose(\"perf_event programs can only use preallocated hash map\\n\");",
          "3983:    verbose(\"perf_event programs can only use preallocated inner hash map\\n\");",
          "",
          "[Added Lines]",
          "4007:    verbose(env, \"perf_event programs can only use preallocated hash map\\n\");",
          "4012:    verbose(env, \"perf_event programs can only use preallocated inner hash map\\n\");",
          "",
          "---------------",
          "--- Hunk 105 ---",
          "[Context before]",
          "4003:  for (i = 0; i < insn_cnt; i++, insn++) {",
          "4004:   if (BPF_CLASS(insn->code) == BPF_LDX &&",
          "4005:       (BPF_MODE(insn->code) != BPF_MEM || insn->imm != 0)) {",
          "4007:    return -EINVAL;",
          "4008:   }",
          "4010:   if (BPF_CLASS(insn->code) == BPF_STX &&",
          "4011:       ((BPF_MODE(insn->code) != BPF_MEM &&",
          "4012:         BPF_MODE(insn->code) != BPF_XADD) || insn->imm != 0)) {",
          "4014:    return -EINVAL;",
          "4015:   }",
          "",
          "[Removed Lines]",
          "4006:    verbose(\"BPF_LDX uses reserved fields\\n\");",
          "4013:    verbose(\"BPF_STX uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "4035:    verbose(env, \"BPF_LDX uses reserved fields\\n\");",
          "4042:    verbose(env, \"BPF_STX uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 106 ---",
          "[Context before]",
          "4021:    if (i == insn_cnt - 1 || insn[1].code != 0 ||",
          "4022:        insn[1].dst_reg != 0 || insn[1].src_reg != 0 ||",
          "4023:        insn[1].off != 0) {",
          "4025:     return -EINVAL;",
          "4026:    }",
          "",
          "[Removed Lines]",
          "4024:     verbose(\"invalid bpf_ld_imm64 insn\\n\");",
          "",
          "[Added Lines]",
          "4053:     verbose(env, \"invalid bpf_ld_imm64 insn\\n\");",
          "",
          "---------------",
          "--- Hunk 107 ---",
          "[Context before]",
          "4030:     goto next_insn;",
          "4032:    if (insn->src_reg != BPF_PSEUDO_MAP_FD) {",
          "4034:     return -EINVAL;",
          "4035:    }",
          "4037:    f = fdget(insn->imm);",
          "4038:    map = __bpf_map_get(f);",
          "4039:    if (IS_ERR(map)) {",
          "4041:      insn->imm);",
          "4042:     return PTR_ERR(map);",
          "4043:    }",
          "4046:    if (err) {",
          "4047:     fdput(f);",
          "4048:     return err;",
          "",
          "[Removed Lines]",
          "4033:     verbose(\"unrecognized bpf_ld_imm64 insn\\n\");",
          "4040:     verbose(\"fd %d is not pointing to valid bpf_map\\n\",",
          "4045:    err = check_map_prog_compatibility(map, env->prog);",
          "",
          "[Added Lines]",
          "4062:     verbose(env,",
          "4063:      \"unrecognized bpf_ld_imm64 insn\\n\");",
          "4070:     verbose(env, \"fd %d is not pointing to valid bpf_map\\n\",",
          "4075:    err = check_map_prog_compatibility(env, map, env->prog);",
          "",
          "---------------",
          "--- Hunk 108 ---",
          "[Context before]",
          "4164:   cnt = ops->gen_prologue(insn_buf, env->seen_direct_write,",
          "4165:      env->prog);",
          "4166:   if (cnt >= ARRAY_SIZE(insn_buf)) {",
          "4168:    return -EINVAL;",
          "4169:   } else if (cnt) {",
          "4170:    new_prog = bpf_patch_insn_data(env, 0, insn_buf, cnt);",
          "",
          "[Removed Lines]",
          "4167:    verbose(\"bpf verifier is misconfigured\\n\");",
          "",
          "[Added Lines]",
          "4197:    verbose(env, \"bpf verifier is misconfigured\\n\");",
          "",
          "---------------",
          "--- Hunk 109 ---",
          "[Context before]",
          "4212:    u8 size_code;",
          "4214:    if (type == BPF_WRITE) {",
          "4216:     return -EINVAL;",
          "4217:    }",
          "",
          "[Removed Lines]",
          "4215:     verbose(\"bpf verifier narrow ctx access misconfigured\\n\");",
          "",
          "[Added Lines]",
          "4245:     verbose(env, \"bpf verifier narrow ctx access misconfigured\\n\");",
          "",
          "---------------",
          "--- Hunk 110 ---",
          "[Context before]",
          "4231:            &target_size);",
          "4232:   if (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf) ||",
          "4233:       (ctx_field_size && !target_size)) {",
          "4235:    return -EINVAL;",
          "4236:   }",
          "",
          "[Removed Lines]",
          "4234:    verbose(\"bpf verifier is misconfigured\\n\");",
          "",
          "[Added Lines]",
          "4264:    verbose(env, \"bpf verifier is misconfigured\\n\");",
          "",
          "---------------",
          "--- Hunk 111 ---",
          "[Context before]",
          "4314:    cnt = map_ptr->ops->map_gen_lookup(map_ptr, insn_buf);",
          "4315:    if (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {",
          "4317:     return -EINVAL;",
          "4318:    }",
          "",
          "[Removed Lines]",
          "4316:     verbose(\"bpf verifier is misconfigured\\n\");",
          "",
          "[Added Lines]",
          "4346:     verbose(env, \"bpf verifier is misconfigured\\n\");",
          "",
          "---------------",
          "--- Hunk 112 ---",
          "[Context before]",
          "4359:   if (!fn->func) {",
          "4361:     func_id_name(insn->imm), insn->imm);",
          "4362:    return -EFAULT;",
          "4363:   }",
          "",
          "[Removed Lines]",
          "4360:    verbose(\"kernel subsystem misconfigured func %s#%d\\n\",",
          "",
          "[Added Lines]",
          "4390:    verbose(env,",
          "4391:     \"kernel subsystem misconfigured func %s#%d\\n\",",
          "",
          "---------------",
          "--- Hunk 113 ---",
          "[Context before]",
          "4392: int bpf_check(struct bpf_prog **prog, union bpf_attr *attr)",
          "4393: {",
          "4395:  struct bpf_verifier_env *env;",
          "4396:  int ret = -EINVAL;",
          "",
          "[Removed Lines]",
          "4394:  struct bpf_verifer_log *log = &verifier_log;",
          "",
          "[Added Lines]",
          "4426:  struct bpf_verifer_log *log;",
          "",
          "---------------",
          "--- Hunk 114 ---",
          "[Context before]",
          "4401:  env = kzalloc(sizeof(struct bpf_verifier_env), GFP_KERNEL);",
          "4402:  if (!env)",
          "4403:   return -ENOMEM;",
          "4405:  env->insn_aux_data = vzalloc(sizeof(struct bpf_insn_aux_data) *",
          "4406:          (*prog)->len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4435:  log = &env->log;",
          "",
          "---------------",
          "--- Hunk 115 ---",
          "[Context before]",
          "4419:   log->level = attr->log_level;",
          "4420:   log->ubuf = (char __user *) (unsigned long) attr->log_buf;",
          "4421:   log->len_total = attr->log_size;",
          "4424:   ret = -EINVAL;",
          "",
          "[Removed Lines]",
          "4422:   log->len_used = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 116 ---",
          "[Context before]",
          "4431:   log->kbuf = vmalloc(log->len_total);",
          "4432:   if (!log->kbuf)",
          "4433:    goto err_unlock;",
          "4436:  }",
          "4438:  env->strict_alignment = !!(attr->prog_flags & BPF_F_STRICT_ALIGNMENT);",
          "",
          "[Removed Lines]",
          "4434:  } else {",
          "4435:   log->level = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 117 ---",
          "[Context before]",
          "4544:  mutex_lock(&bpf_verifier_lock);",
          "4548:  env->strict_alignment = false;",
          "4549:  if (!IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS))",
          "4550:   env->strict_alignment = true;",
          "",
          "[Removed Lines]",
          "4546:  verifier_log.level = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
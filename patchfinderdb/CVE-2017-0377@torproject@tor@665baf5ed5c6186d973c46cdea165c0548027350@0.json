{
  "cve_id": "CVE-2017-0377",
  "cve_desc": "Tor 0.3.x before 0.3.0.9 has a guard-selection algorithm that only considers the exit relay (not the exit relay's family), which might allow remote attackers to defeat intended anonymity properties by leveraging the existence of large families.",
  "repo": "torproject/tor",
  "patch_hash": "665baf5ed5c6186d973c46cdea165c0548027350",
  "patch_info": {
    "commit_hash": "665baf5ed5c6186d973c46cdea165c0548027350",
    "repo": "torproject/tor",
    "commit_url": "https://github.com/torproject/tor/commit/665baf5ed5c6186d973c46cdea165c0548027350",
    "files": [
      "changes/bug22753",
      "src/or/entrynodes.c",
      "src/or/entrynodes.h",
      "src/or/nodelist.c",
      "src/or/nodelist.h"
    ],
    "message": "Consider the exit family when applying guard restrictions.\n\nWhen the new path selection logic went into place, I accidentally\ndropped the code that considered the _family_ of the exit node when\ndeciding if the guard was usable, and we didn't catch that during\ncode review.\n\nThis patch makes the guard_restriction_t code consider the exit\nfamily as well, and adds some (hopefully redundant) checks for the\ncase where we lack a node_t for a guard but we have a bridge_info_t\nfor it.\n\nFixes bug 22753; bugfix on 0.3.0.1-alpha. Tracked as TROVE-2016-006\nand CVE-2017-0377.",
    "before_after_code_files": [
      "src/or/entrynodes.c||src/or/entrynodes.c",
      "src/or/entrynodes.h||src/or/entrynodes.h",
      "src/or/nodelist.c||src/or/nodelist.c",
      "src/or/nodelist.h||src/or/nodelist.h"
    ]
  },
  "patch_diff": {
    "src/or/entrynodes.c||src/or/entrynodes.c": [
      "File: src/or/entrynodes.c -> src/or/entrynodes.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1428:   }",
      "1429: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1433: static int",
      "1434: guard_in_node_family(const entry_guard_t *guard, const node_t *node)",
      "1435: {",
      "1436:   const node_t *guard_node = node_get_by_id(guard->identity);",
      "1437:   if (guard_node) {",
      "1438:     return nodes_in_same_family(guard_node, node);",
      "1439:   } else {",
      "1451:     if (get_options()->EnforceDistinctSubnets && guard->bridge_addr) {",
      "1452:       tor_addr_t node_addr;",
      "1453:       node_get_addr(node, &node_addr);",
      "1454:       if (addrs_in_same_network_family(&node_addr,",
      "1455:                                        &guard->bridge_addr->addr)) {",
      "1456:         return 1;",
      "1457:       }",
      "1458:     }",
      "1459:     return 0;",
      "1460:   }",
      "1461: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1440:   if (! rst)",
      "1441:     return 1; // No restriction?  No problem.",
      "1444:   return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN);",
      "1445: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1477:   const node_t *node = node_get_by_id((const char*)rst->exclude_id);",
      "1478:   if (node && guard_in_node_family(guard, node))",
      "1479:     return 0;",
      "",
      "---------------"
    ],
    "src/or/entrynodes.h||src/or/entrynodes.h": [
      "File: src/or/entrynodes.h -> src/or/entrynodes.h"
    ],
    "src/or/nodelist.c||src/or/nodelist.c": [
      "File: src/or/nodelist.c -> src/or/nodelist.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1347: addrs_in_same_network_family(const tor_addr_t *a1,",
      "1348:                              const tor_addr_t *a2)",
      "1349: {",
      "",
      "[Removed Lines]",
      "1346: static inline int",
      "",
      "[Added Lines]",
      "1346: int",
      "",
      "---------------"
    ],
    "src/or/nodelist.h||src/or/nodelist.h": [
      "File: src/or/nodelist.h -> src/or/nodelist.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "94: int router_exit_policy_all_nodes_reject(const tor_addr_t *addr, uint16_t port,",
      "95:                                         int need_uptime);",
      "96: void router_set_status(const char *digest, int up);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "97: int addrs_in_same_network_family(const tor_addr_t *a1,",
      "98:                                  const tor_addr_t *a2);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f61e3090fb2975ad8c2a5e138b87c62428c5f46b",
      "candidate_info": {
        "commit_hash": "f61e3090fb2975ad8c2a5e138b87c62428c5f46b",
        "repo": "torproject/tor",
        "commit_url": "https://github.com/torproject/tor/commit/f61e3090fb2975ad8c2a5e138b87c62428c5f46b",
        "files": [
          "changes/bug23817",
          "src/or/directory.c",
          "src/or/entrynodes.c",
          "src/or/entrynodes.h"
        ],
        "message": "Introduce new guard restriction and use it to skip outdated dirs.",
        "before_after_code_files": [
          "src/or/directory.c||src/or/directory.c",
          "src/or/entrynodes.c||src/or/entrynodes.c",
          "src/or/entrynodes.h||src/or/entrynodes.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/or/entrynodes.c||src/or/entrynodes.c",
            "src/or/entrynodes.h||src/or/entrynodes.h"
          ],
          "candidate": [
            "src/or/entrynodes.c||src/or/entrynodes.c",
            "src/or/entrynodes.h||src/or/entrynodes.h"
          ]
        }
      },
      "candidate_diff": {
        "src/or/directory.c||src/or/directory.c": [
          "File: src/or/directory.c -> src/or/directory.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "464:     log_warn(LD_BUG, \"Called when we have UseBridges set.\");",
          "466:   if (should_use_directory_guards(options)) {",
          "468:     if (node)",
          "469:       rs = node->rs;",
          "470:   } else {",
          "",
          "[Removed Lines]",
          "467:     const node_t *node = guards_choose_dirguard(guard_state_out);",
          "",
          "[Added Lines]",
          "467:     const node_t *node = guards_choose_dirguard(dir_purpose, guard_state_out);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "602:       if (node && node->ri) {",
          "604:         routerinfo_t *ri = node->ri;",
          "",
          "[Removed Lines]",
          "601:       const node_t *node = guards_choose_dirguard(&guard_state);",
          "",
          "[Added Lines]",
          "601:       const node_t *node = guards_choose_dirguard(dir_purpose, &guard_state);",
          "",
          "---------------"
        ],
        "src/or/entrynodes.c||src/or/entrynodes.c": [
          "File: src/or/entrynodes.c -> src/or/entrynodes.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1460:   }",
          "1461: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1465: STATIC entry_guard_restriction_t *",
          "1466: guard_create_exit_restriction(const uint8_t *exit_id)",
          "1467: {",
          "1468:   entry_guard_restriction_t *rst = NULL;",
          "1469:   rst = tor_malloc_zero(sizeof(entry_guard_restriction_t));",
          "1470:   rst->type = RST_EXIT_NODE;",
          "1471:   memcpy(rst->exclude_id, exit_id, DIGEST_LEN);",
          "1472:   return rst;",
          "1473: }",
          "1476: STATIC entry_guard_restriction_t *",
          "1477: guard_create_dirserver_md_restriction(void)",
          "1478: {",
          "1479:   entry_guard_restriction_t *rst = NULL;",
          "1481:   rst = tor_malloc_zero(sizeof(entry_guard_restriction_t));",
          "1482:   rst->type = RST_OUTDATED_MD_DIRSERVER;",
          "1484:   return rst;",
          "1485: }",
          "1488: static int",
          "1489: guard_obeys_exit_restriction(const entry_guard_t *guard,",
          "1490:                              const entry_guard_restriction_t *rst)",
          "1491: {",
          "1492:   tor_assert(rst->type == RST_EXIT_NODE);",
          "1495:   const node_t *node = node_get_by_id((const char*)rst->exclude_id);",
          "1496:   if (node && guard_in_node_family(guard, node))",
          "1497:     return 0;",
          "1499:   return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN);",
          "1500: }",
          "1504: static int",
          "1505: guard_obeys_md_dirserver_restriction(const entry_guard_t *guard)",
          "1506: {",
          "1510:   if (guard->bridge_addr) {",
          "1511:     return 1;",
          "1512:   }",
          "1515:   if (microdesc_relay_is_outdated_dirserver(guard->identity)) {",
          "1516:     log_info(LD_GENERAL, \"Skipping %s dirserver: outdated\",",
          "1517:              hex_str(guard->identity, DIGEST_LEN));",
          "1518:     return 0;",
          "1519:   }",
          "1521:   log_debug(LD_GENERAL, \"%s dirserver obeys md restrictions\",",
          "1522:             hex_str(guard->identity, DIGEST_LEN));",
          "1524:   return 1;",
          "1525: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1472:   if (! rst)",
          "1473:     return 1; // No restriction?  No problem.",
          "1482: }",
          "",
          "[Removed Lines]",
          "1477:   const node_t *node = node_get_by_id((const char*)rst->exclude_id);",
          "1478:   if (node && guard_in_node_family(guard, node))",
          "1479:     return 0;",
          "1481:   return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN);",
          "",
          "[Added Lines]",
          "1539:   if (rst->type == RST_EXIT_NODE) {",
          "1540:     return guard_obeys_exit_restriction(guard, rst);",
          "1541:   } else if (rst->type == RST_OUTDATED_MD_DIRSERVER) {",
          "1542:     return guard_obeys_md_dirserver_restriction(guard);",
          "1543:   }",
          "1545:   tor_assert_nonfatal_unreached();",
          "1546:   return 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2105: }",
          "2109: entry_guard_restriction_free(entry_guard_restriction_t *rst)",
          "2110: {",
          "2111:   tor_free(rst);",
          "",
          "[Removed Lines]",
          "2108: static void",
          "",
          "[Added Lines]",
          "2173: STATIC void",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3363:   }",
          "3364:   if (entry_guard_pick_for_circuit(get_guard_selection_info(),",
          "3365:                                    GUARD_USAGE_TRAFFIC,",
          "",
          "[Removed Lines]",
          "3361:     rst = tor_malloc_zero(sizeof(entry_guard_restriction_t));",
          "3362:     memcpy(rst->exclude_id, exit_id, DIGEST_LEN);",
          "",
          "[Added Lines]",
          "3426:     rst = guard_create_exit_restriction(exit_id);",
          "3427:     tor_assert(rst);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3413: const node_t *",
          "3415: {",
          "3416:   const node_t *r = NULL;",
          "3417:   if (entry_guard_pick_for_circuit(get_guard_selection_info(),",
          "3418:                                    GUARD_USAGE_DIRGUARD,",
          "3420:                                    &r,",
          "3421:                                    guard_state_out) < 0) {",
          "3422:     tor_assert(r == NULL);",
          "",
          "[Removed Lines]",
          "3414: guards_choose_dirguard(circuit_guard_state_t **guard_state_out)",
          "3419:                                    NULL,",
          "",
          "[Added Lines]",
          "3479: guards_choose_dirguard(uint8_t dir_purpose,",
          "3480:                        circuit_guard_state_t **guard_state_out)",
          "3483:   entry_guard_restriction_t *rst = NULL;",
          "3486:   if (dir_purpose == DIR_PURPOSE_FETCH_MICRODESC) {",
          "3487:     rst = guard_create_dirserver_md_restriction();",
          "3488:   }",
          "3492:                                    rst,",
          "",
          "---------------"
        ],
        "src/or/entrynodes.h||src/or/entrynodes.h": [
          "File: src/or/entrynodes.h -> src/or/entrynodes.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "273: struct entry_guard_handle_t;",
          "286: struct entry_guard_restriction_t {",
          "291:   uint8_t exclude_id[DIGEST_LEN];",
          "292: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "276: typedef enum guard_restriction_type_t {",
          "278:   RST_EXIT_NODE = 0,",
          "280:   RST_OUTDATED_MD_DIRSERVER = 1",
          "281: } guard_restriction_type_t;",
          "292:   guard_restriction_type_t type;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "316: int guards_update_all(void);",
          "317: const node_t *guards_choose_guard(cpath_build_state_t *state,",
          "318:                                   circuit_guard_state_t **guard_state_out);",
          "321: #if 1",
          "",
          "[Removed Lines]",
          "319: const node_t *guards_choose_dirguard(circuit_guard_state_t **guard_state_out);",
          "",
          "[Added Lines]",
          "325: const node_t *guards_choose_dirguard(uint8_t dir_purpose,",
          "326:                                      circuit_guard_state_t **guard_state_out);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "550:                                                 unsigned old_state);",
          "551: STATIC int entry_guard_has_higher_priority(entry_guard_t *a, entry_guard_t *b);",
          "552: STATIC char *getinfo_helper_format_single_entry_guard(const entry_guard_t *e);",
          "555: void remove_all_entry_guards_for_guard_selection(guard_selection_t *gs);",
          "556: void remove_all_entry_guards(void);",
          "",
          "[Removed Lines]",
          "553: #endif",
          "",
          "[Added Lines]",
          "561: STATIC entry_guard_restriction_t *",
          "562: guard_create_exit_restriction(const uint8_t *exit_id);",
          "564: STATIC entry_guard_restriction_t *",
          "565: guard_create_dirserver_md_restriction(void);",
          "567: STATIC void",
          "568: entry_guard_restriction_free(entry_guard_restriction_t *rst);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
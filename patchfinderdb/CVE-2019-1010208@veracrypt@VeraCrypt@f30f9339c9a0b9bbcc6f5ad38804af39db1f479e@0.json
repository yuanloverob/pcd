{
  "cve_id": "CVE-2019-1010208",
  "cve_desc": "IDRIX, Truecrypt Veracrypt, Truecrypt Prior to 1.23-Hotfix-1 (Veracrypt), all versions (Truecrypt) is affected by: Buffer Overflow. The impact is: Minor information disclosure of kernel stack. The component is: Veracrypt NT Driver (veracrypt.sys). The attack vector is: Locally executed code, IOCTL request to driver. The fixed version is: 1.23-Hotfix-1.",
  "repo": "veracrypt/VeraCrypt",
  "patch_hash": "f30f9339c9a0b9bbcc6f5ad38804af39db1f479e",
  "patch_info": {
    "commit_hash": "f30f9339c9a0b9bbcc6f5ad38804af39db1f479e",
    "repo": "veracrypt/VeraCrypt",
    "commit_url": "https://github.com/veracrypt/VeraCrypt/commit/f30f9339c9a0b9bbcc6f5ad38804af39db1f479e",
    "files": [
      "src/Driver/Ntdriver.c"
    ],
    "message": "Windows: fix low severity vulnerability in driver that allowed reading 3 bytes of kernel stack memory (with a rare possibility of 25 additional bytes). Reported by Tim Harrison.",
    "before_after_code_files": [
      "src/Driver/Ntdriver.c||src/Driver/Ntdriver.c"
    ]
  },
  "patch_diff": {
    "src/Driver/Ntdriver.c||src/Driver/Ntdriver.c": [
      "File: src/Driver/Ntdriver.c -> src/Driver/Ntdriver.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1902:    UNICODE_STRING FullFileName;",
      "1903:    IO_STATUS_BLOCK IoStatus;",
      "1904:    LARGE_INTEGER offset;",
      "1907:    if (!ValidateIOBufferSize (Irp, sizeof (GetSystemDriveConfigurationRequest), ValidateInputOutput))",
      "1908:     break;",
      "1910:    EnsureNullTerminatedString (request->DevicePath, sizeof (request->DevicePath));",
      "1911:    RtlInitUnicodeString (&FullFileName, request->DevicePath);",
      "",
      "[Removed Lines]",
      "1905:    byte readBuffer [TC_SECTOR_SIZE_BIOS];",
      "",
      "[Added Lines]",
      "1905:    size_t devicePathLen = 0;",
      "1911:    if ( !NT_SUCCESS (RtlUnalignedStringCchLengthW (request->DevicePath, TC_MAX_PATH, &devicePathLen))",
      "1912:     || (devicePathLen < 28) // 28 is the length of \"\\\\Device\\\\Harddisk0\\\\Partition0\" which is the minimum",
      "1913:     || (devicePathLen > 30) // 30 is the length of \"\\\\Device\\\\Harddisk255\\\\Partition0\" which is the maximum",
      "1914:     || (memcmp (request->DevicePath, L\"\\\\Device\\\\Harddisk\", 16 * sizeof (WCHAR)))",
      "1915:     || (memcmp (&request->DevicePath[devicePathLen - 11], L\"\\\\Partition0\", 11 * sizeof (WCHAR)))",
      "1916:     )",
      "1917:    {",
      "1918:     Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;",
      "1919:     Irp->IoStatus.Information = 0;",
      "1920:     break;",
      "1921:    }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1919:    if (NT_SUCCESS (ntStatus))",
      "1920:    {",
      "1935:     {",
      "1942:      {",
      "1945:       {",
      "1947:        {",
      "1950:        }",
      "1968:        {",
      "1971:        }",
      "1973:       }",
      "1974:      }",
      "1983:     }",
      "1985:     ZwClose (NtFileHandle);",
      "",
      "[Removed Lines]",
      "1922:     offset.QuadPart = 0; // MBR",
      "1924:     ntStatus = ZwReadFile (NtFileHandle,",
      "1925:      NULL,",
      "1926:      NULL,",
      "1927:      NULL,",
      "1928:      &IoStatus,",
      "1929:      readBuffer,",
      "1930:      sizeof(readBuffer),",
      "1931:      &offset,",
      "1932:      NULL);",
      "1934:     if (NT_SUCCESS (ntStatus))",
      "1936:      size_t i;",
      "1939:      request->DriveIsDynamic = FALSE;",
      "1941:      if (readBuffer[510] == 0x55 && readBuffer[511] == 0xaa)",
      "1943:       int i;",
      "1944:       for (i = 0; i < 4; ++i)",
      "1946:        if (readBuffer[446 + i * 16 + 4] == PARTITION_LDM)",
      "1948:         request->DriveIsDynamic = TRUE;",
      "1949:         break;",
      "1951:       }",
      "1952:      }",
      "1954:      request->BootLoaderVersion = 0;",
      "1955:      request->Configuration = 0;",
      "1956:      request->UserConfiguration = 0;",
      "1957:      request->CustomUserMessage[0] = 0;",
      "1960:      for (i = 0; i < sizeof (readBuffer) - strlen (TC_APP_NAME); ++i)",
      "1961:      {",
      "1962:       if (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)",
      "1963:       {",
      "1964:        request->BootLoaderVersion = BE16 (*(uint16 *) (readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET));",
      "1965:        request->Configuration = readBuffer[TC_BOOT_SECTOR_CONFIG_OFFSET];",
      "1967:        if (request->BootLoaderVersion != 0 && request->BootLoaderVersion <= VERSION_NUM)",
      "1969:         request->UserConfiguration = readBuffer[TC_BOOT_SECTOR_USER_CONFIG_OFFSET];",
      "1970:         memcpy (request->CustomUserMessage, readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET, TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH);",
      "1972:        break;",
      "1976:      Irp->IoStatus.Status = STATUS_SUCCESS;",
      "1977:      Irp->IoStatus.Information = sizeof (*request);",
      "1978:     }",
      "1979:     else",
      "1980:     {",
      "1981:      Irp->IoStatus.Status = ntStatus;",
      "1982:      Irp->IoStatus.Information = 0;",
      "",
      "[Added Lines]",
      "1934:     byte *readBuffer = TCalloc (TC_MAX_VOLUME_SECTOR_SIZE);",
      "1935:     if (!readBuffer)",
      "1937:      Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;",
      "1938:      Irp->IoStatus.Information = 0;",
      "1939:     }",
      "1940:     else",
      "1941:     {",
      "1943:      offset.QuadPart = 0; // MBR",
      "1945:      ntStatus = ZwReadFile (NtFileHandle,",
      "1946:       NULL,",
      "1947:       NULL,",
      "1948:       NULL,",
      "1949:       &IoStatus,",
      "1950:       readBuffer,",
      "1951:       TC_MAX_VOLUME_SECTOR_SIZE,",
      "1952:       &offset,",
      "1953:       NULL);",
      "1955:      if (NT_SUCCESS (ntStatus))",
      "1958:       if (IoStatus.Information >= TC_SECTOR_SIZE_BIOS)",
      "1960:        size_t i;",
      "1963:        request->DriveIsDynamic = FALSE;",
      "1965:        if (readBuffer[510] == 0x55 && readBuffer[511] == 0xaa)",
      "1967:         int i;",
      "1968:         for (i = 0; i < 4; ++i)",
      "1969:         {",
      "1970:          if (readBuffer[446 + i * 16 + 4] == PARTITION_LDM)",
      "1971:          {",
      "1972:           request->DriveIsDynamic = TRUE;",
      "1973:           break;",
      "1974:          }",
      "1975:         }",
      "1978:        request->BootLoaderVersion = 0;",
      "1979:        request->Configuration = 0;",
      "1980:        request->UserConfiguration = 0;",
      "1981:        request->CustomUserMessage[0] = 0;",
      "1984:        for (i = 0; i < sizeof (readBuffer) - strlen (TC_APP_NAME); ++i)",
      "1986:         if (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)",
      "1987:         {",
      "1988:          request->BootLoaderVersion = BE16 (*(uint16 *) (readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET));",
      "1989:          request->Configuration = readBuffer[TC_BOOT_SECTOR_CONFIG_OFFSET];",
      "1991:          if (request->BootLoaderVersion != 0 && request->BootLoaderVersion <= VERSION_NUM)",
      "1992:          {",
      "1993:           request->UserConfiguration = readBuffer[TC_BOOT_SECTOR_USER_CONFIG_OFFSET];",
      "1994:           memcpy (request->CustomUserMessage, readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET, TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH);",
      "1995:          }",
      "1996:          break;",
      "1997:         }",
      "2000:        Irp->IoStatus.Status = STATUS_SUCCESS;",
      "2001:        Irp->IoStatus.Information = sizeof (*request);",
      "2002:       }",
      "2003:       else",
      "2004:       {",
      "2005:        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;",
      "2006:        Irp->IoStatus.Information = 0;",
      "2009:      else",
      "2010:      {",
      "2011:       Irp->IoStatus.Status = ntStatus;",
      "2012:       Irp->IoStatus.Information = 0;",
      "2013:      }",
      "2015:      TCfree (readBuffer);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "162d3b5f64d0e1849c566898854cb9fbc0d8ebc2",
      "candidate_info": {
        "commit_hash": "162d3b5f64d0e1849c566898854cb9fbc0d8ebc2",
        "repo": "veracrypt/VeraCrypt",
        "commit_url": "https://github.com/veracrypt/VeraCrypt/commit/162d3b5f64d0e1849c566898854cb9fbc0d8ebc2",
        "files": [
          "src/Driver/Ntdriver.c"
        ],
        "message": "Windows Driver: fix regression that was causing BSOD.",
        "before_after_code_files": [
          "src/Driver/Ntdriver.c||src/Driver/Ntdriver.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/Driver/Ntdriver.c||src/Driver/Ntdriver.c"
          ],
          "candidate": [
            "src/Driver/Ntdriver.c||src/Driver/Ntdriver.c"
          ]
        }
      },
      "candidate_diff": {
        "src/Driver/Ntdriver.c||src/Driver/Ntdriver.c": [
          "File: src/Driver/Ntdriver.c -> src/Driver/Ntdriver.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2043:        request->CustomUserMessage[0] = 0;",
          "2047:        {",
          "2048:         if (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)",
          "2049:         {",
          "",
          "[Removed Lines]",
          "2046:        for (i = 0; i < sizeof (readBuffer) - strlen (TC_APP_NAME); ++i)",
          "",
          "[Added Lines]",
          "2046:        for (i = 0; i < TC_SECTOR_SIZE_BIOS - strlen (TC_APP_NAME); ++i)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0b5dc7910b4be2631f3c6ddcb08903879ec9a544",
      "candidate_info": {
        "commit_hash": "0b5dc7910b4be2631f3c6ddcb08903879ec9a544",
        "repo": "veracrypt/VeraCrypt",
        "commit_url": "https://github.com/veracrypt/VeraCrypt/commit/0b5dc7910b4be2631f3c6ddcb08903879ec9a544",
        "files": [
          "src/Driver/Ntdriver.c"
        ],
        "message": "Windows Driver: replace system functions RtlUpcaseUnicodeChar/RtlUnalignedStringCchLengthW by our own code for better clarity",
        "before_after_code_files": [
          "src/Driver/Ntdriver.c||src/Driver/Ntdriver.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/Driver/Ntdriver.c||src/Driver/Ntdriver.c"
          ],
          "candidate": [
            "src/Driver/Ntdriver.c||src/Driver/Ntdriver.c"
          ]
        }
      },
      "candidate_diff": {
        "src/Driver/Ntdriver.c||src/Driver/Ntdriver.c": [
          "File: src/Driver/Ntdriver.c -> src/Driver/Ntdriver.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "289:  return TRUE;",
          "290: }",
          "292: static BOOL StringNoCaseCompare (const wchar_t* str1, const wchar_t* str2, size_t len)",
          "293: {",
          "294:  if (str1 && str2)",
          "295:  {",
          "296:   while (len)",
          "297:   {",
          "299:     return FALSE;",
          "300:    str1++;",
          "301:    str2++;",
          "",
          "[Removed Lines]",
          "298:    if (RtlUpcaseUnicodeChar (*str1) != RtlUpcaseUnicodeChar (*str2))",
          "",
          "[Added Lines]",
          "292: static wchar_t UpperCaseUnicodeChar (wchar_t c)",
          "293: {",
          "294:  if (c >= L'a' && c <= L'z')",
          "295:   return (c - L'a') + L'A';",
          "296:  return c;",
          "297: }",
          "305:    if (UpperCaseUnicodeChar (*str1) != UpperCaseUnicodeChar (*str2))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "306:  return TRUE;",
          "307: }",
          "309: BOOL ValidateIOBufferSize (PIRP irp, size_t requiredBufferSize, ValidateIOBufferSizeType type)",
          "310: {",
          "311:  PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (irp);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "316: static BOOL CheckStringLength (const wchar_t* str, size_t cchSize, size_t minLength, size_t maxLength, size_t* pcchLength)",
          "317: {",
          "318:  size_t actualLength;",
          "319:  for (actualLength = 0; actualLength < cchSize; actualLength++)",
          "320:  {",
          "321:   if (str[actualLength] == 0)",
          "322:    break;",
          "323:  }",
          "325:  if (pcchLength)",
          "328:  if (actualLength == cchSize)",
          "329:   return FALSE;",
          "331:  if ((minLength != ((size_t) -1)) && (actualLength < minLength))",
          "332:   return FALSE;",
          "334:  if ((maxLength != ((size_t) -1)) && (actualLength > maxLength))",
          "335:   return FALSE;",
          "337:  return TRUE;",
          "338: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1762:    IO_STATUS_BLOCK IoStatus;",
          "1763:    LARGE_INTEGER offset;",
          "1764:    ACCESS_MASK access = FILE_READ_ATTRIBUTES;",
          "1767:    if (!ValidateIOBufferSize (Irp, sizeof (OPEN_TEST_STRUCT), ValidateInputOutput))",
          "1768:     break;",
          "1773:     || (!StringNoCaseCompare (opentest->wszFileName, L\"\\\\Device\\\\Harddisk\", 16))",
          "1774:     )",
          "1775:    {",
          "",
          "[Removed Lines]",
          "1765:    size_t devicePathLen = 0;",
          "1771:    if ( !NT_SUCCESS (RtlUnalignedStringCchLengthW (opentest->wszFileName, TC_MAX_PATH, &devicePathLen))",
          "1772:     || (devicePathLen < 16) // 16 is the length of \"\\\\Device\\\\Harddisk\" which is the minimum",
          "",
          "[Added Lines]",
          "1802:    if ( !CheckStringLength (opentest->wszFileName, TC_MAX_PATH, 16, (size_t) -1, NULL)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1933:    IO_STATUS_BLOCK IoStatus;",
          "1934:    LARGE_INTEGER offset;",
          "1935:    size_t devicePathLen = 0;",
          "1937:    if (!ValidateIOBufferSize (Irp, sizeof (GetSystemDriveConfigurationRequest), ValidateInputOutput))",
          "1938:     break;",
          "1946:     )",
          "1947:    {",
          "1948:     Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;",
          "",
          "[Removed Lines]",
          "1941:    if ( !NT_SUCCESS (RtlUnalignedStringCchLengthW (request->DevicePath, TC_MAX_PATH, &devicePathLen))",
          "1942:     || (devicePathLen < 28) // 28 is the length of \"\\\\Device\\\\Harddisk0\\\\Partition0\" which is the minimum",
          "1943:     || (devicePathLen > 30) // 30 is the length of \"\\\\Device\\\\Harddisk255\\\\Partition0\" which is the maximum",
          "1944:     || (memcmp (request->DevicePath, L\"\\\\Device\\\\Harddisk\", 16 * sizeof (WCHAR)))",
          "1945:     || (memcmp (&request->DevicePath[devicePathLen - 11], L\"\\\\Partition0\", 11 * sizeof (WCHAR)))",
          "",
          "[Added Lines]",
          "1966:    WCHAR* wszPath = NULL;",
          "1974:    wszPath = request->DevicePath;",
          "1975:    if ( !CheckStringLength (wszPath, TC_MAX_PATH, 28, 30, &devicePathLen)",
          "1976:     || (memcmp (wszPath, L\"\\\\Device\\\\Harddisk\", 16 * sizeof (WCHAR)))",
          "1977:     || (memcmp (wszPath + (devicePathLen - 11), L\"\\\\Partition0\", 11 * sizeof (WCHAR)))",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2022-1899",
  "cve_desc": "Out-of-bounds Read in GitHub repository radareorg/radare2 prior to 5.7.0.",
  "repo": "radareorg/radare2",
  "patch_hash": "193f4fe01d7f626e2ea937450f2e0c4604420e9d",
  "patch_info": {
    "commit_hash": "193f4fe01d7f626e2ea937450f2e0c4604420e9d",
    "repo": "radareorg/radare2",
    "commit_url": "https://github.com/radareorg/radare2/commit/193f4fe01d7f626e2ea937450f2e0c4604420e9d",
    "files": [
      "libr/bin/bfile.c"
    ],
    "message": "Fix integer overflow in string search causing oobread ##crash\n\n* Reported by @greatergoodest via huntrdev\n* BountyID: 8a3dc5cb-08b3-4807-82b2-77f08c137a04\n* Reproducer bfileovf",
    "before_after_code_files": [
      "libr/bin/bfile.c||libr/bin/bfile.c"
    ]
  },
  "patch_diff": {
    "libr/bin/bfile.c||libr/bin/bfile.c": [
      "File: libr/bin/bfile.c -> libr/bin/bfile.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "178:  free (charset);",
      "179:  RConsIsBreaked is_breaked = (bin && bin->consb.is_breaked)? bin->consb.is_breaked: NULL;",
      "182:   if (is_breaked && is_breaked ()) {",
      "183:    break;",
      "184:   }",
      "188:    if (!n1) {",
      "189:     needle += 4;",
      "190:     continue;",
      "191:    }",
      "192:   }",
      "194:   if (!rc) {",
      "195:    needle++;",
      "196:    continue;",
      "",
      "[Removed Lines]",
      "181:  while (needle < to) {",
      "186:   if (needle + 4 < to) {",
      "187:    ut32 n1 = r_read_le32 (buf + needle - from);",
      "193:   rc = r_utf8_decode (buf + needle - from, to - needle, NULL);",
      "",
      "[Added Lines]",
      "181:  while (needle < to && needle < UT64_MAX - 4) {",
      "186:   if (needle < to - 4) {",
      "187:    ut32 n1 = r_read_le32 (buf + (needle - from));",
      "193:   rc = r_utf8_decode (buf + (needle - from), to - needle, NULL);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "198:   bool addr_aligned = !(needle % 4);",
      "200:   if (type == R_STRING_TYPE_DETECT) {",
      "202:    if (((to - needle) > 8 + rc)) {",
      "204:     bool is_wide32le = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);",
      "",
      "[Removed Lines]",
      "201:    char *w = (char *)buf + needle + rc - from;",
      "",
      "[Added Lines]",
      "201:    char *w = (char *)buf + (needle + rc - from);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "248:      rc = 2;",
      "249:     }",
      "250:    } else {",
      "252:     if (rc > 1) {",
      "253:      str_type = R_STRING_TYPE_UTF8;",
      "254:     }",
      "",
      "[Removed Lines]",
      "251:     rc = r_utf8_decode (buf + needle - from, to - needle, &r);",
      "",
      "[Added Lines]",
      "251:     rc = r_utf8_decode (buf + (needle - from), to - needle, &r);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c7f89529a72a2ad13368e5b7e44f8914a3d08134",
      "candidate_info": {
        "commit_hash": "c7f89529a72a2ad13368e5b7e44f8914a3d08134",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/c7f89529a72a2ad13368e5b7e44f8914a3d08134",
        "files": [
          "libr/bin/bfile.c"
        ],
        "message": "Check bounds when skipping words in string scan",
        "before_after_code_files": [
          "libr/bin/bfile.c||libr/bin/bfile.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/bfile.c||libr/bin/bfile.c"
          ],
          "candidate": [
            "libr/bin/bfile.c||libr/bin/bfile.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/bfile.c||libr/bin/bfile.c": [
          "File: libr/bin/bfile.c -> libr/bin/bfile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "184:    }",
          "185:   }",
          "191:   }",
          "192:   rc = r_utf8_decode (buf + needle - from, to - needle, NULL);",
          "193:   if (!rc) {",
          "",
          "[Removed Lines]",
          "187:   ut32 n1 = r_read_le32 (buf+needle-from);",
          "188:   if (!n1) {",
          "189:    needle += 4;",
          "190:    continue;",
          "",
          "[Added Lines]",
          "187:   if (needle + 4 < to) {",
          "188:    ut32 n1 = r_read_le32 (buf + needle - from);",
          "189:    if (!n1) {",
          "190:     needle += 4;",
          "191:     continue;",
          "192:    }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "61c2a5b9ba8f8d51d52a018126136530062ff885",
      "candidate_info": {
        "commit_hash": "61c2a5b9ba8f8d51d52a018126136530062ff885",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/61c2a5b9ba8f8d51d52a018126136530062ff885",
        "files": [
          "libr/bin/bfile.c",
          "test/db/cmd/cmd_i",
          "test/db/cmd/cmd_iz",
          "test/db/formats/mdmp",
          "test/db/tools/rabin2"
        ],
        "message": "Fix wide32 string detection that caused to miss other ascii strings ##bin\n\n* Update tests with more good strings and less false positives\n* Ticket: https://github.com/radareorg/radare2/issues/19727\n* Reproducer: rev.exe",
        "before_after_code_files": [
          "libr/bin/bfile.c||libr/bin/bfile.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/bfile.c||libr/bin/bfile.c"
          ],
          "candidate": [
            "libr/bin/bfile.c||libr/bin/bfile.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/bfile.c||libr/bin/bfile.c": [
          "File: libr/bin/bfile.c -> libr/bin/bfile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "34:  r_return_if_fail (bf && string);",
          "36:  int mode = bf->strmode;",
          "38:  RBin *bin = bf->rbin;",
          "39:  if (!bin) {",
          "40:   return;",
          "41:  }",
          "43:  RIO *io = bin->iob.io;",
          "44:  if (!io) {",
          "45:   return;",
          "",
          "[Removed Lines]",
          "37:  ut64 addr, vaddr;",
          "42:  const char *section_name, *type_string;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48:  if (s) {",
          "49:   string->vaddr = s->vaddr + (string->paddr - s->paddr);",
          "50:  }",
          "",
          "[Removed Lines]",
          "51:  section_name = s ? s->name : \"\";",
          "52:  type_string = r_bin_string_type (string->type);",
          "53:  vaddr = addr = r_bin_get_vaddr (bin, string->paddr, string->vaddr);",
          "",
          "[Added Lines]",
          "49:  const char *section_name = s ? s->name : \"\";",
          "50:  const char *type_string = r_bin_string_type (string->type);",
          "51:  ut64 vaddr = r_bin_get_vaddr (bin, string->paddr, string->vaddr);",
          "52:  ut64 addr = vaddr;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "129:   eprintf (\"Invalid range to find strings 0x%\"PFMT64x\" .. 0x%\"PFMT64x\"\\n\", from, to);",
          "130:   return -1;",
          "131:  }",
          "133:  ut8 *buf = calloc (len, 1);",
          "134:  if (!buf || !min) {",
          "135:   free (buf);",
          "",
          "[Removed Lines]",
          "132:  int len = to - from;",
          "",
          "[Added Lines]",
          "131:  st64 len = (st64)(to - from);",
          "132:  if (len > ST32_MAX) {",
          "133:   eprintf (\"String scan range is too large\\n\");",
          "134:   return -1;",
          "135:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "163:     }",
          "164:     len = res;",
          "165:     free (buf);",
          "167:     buf = out;",
          "171:    } else {",
          "172:     eprintf (\"Cannot allocate\\n\");",
          "173:    }",
          "",
          "[Removed Lines]",
          "166: #if 1",
          "168: #else",
          "170: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "184:     break;",
          "185:    }",
          "186:   }",
          "187:   rc = r_utf8_decode (buf + needle - from, to - needle, NULL);",
          "188:   if (!rc) {",
          "189:    needle++;",
          "190:    continue;",
          "191:   }",
          "192:   if (type == R_STRING_TYPE_DETECT) {",
          "193:    char *w = (char *)buf + needle + rc - from;",
          "198:     } else {",
          "199:      bool is_wide = needle + rc + 4 < to && !w[0] && w[1] && !w[2] && w[3] && !w[4];",
          "200:      str_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;",
          "201:     }",
          "202:    } else {",
          "204:    }",
          "205:   } else if (type == R_STRING_TYPE_UTF8) {",
          "206:    str_type = R_STRING_TYPE_ASCII; // initial assumption",
          "",
          "[Removed Lines]",
          "194:    if ((to - needle) > 5 + rc) {",
          "195:     bool is_wide32 = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);",
          "196:     if (is_wide32) {",
          "197:      str_type = R_STRING_TYPE_WIDE32;",
          "203:     str_type = R_STRING_TYPE_ASCII;",
          "",
          "[Added Lines]",
          "187:   ut32 n1 = r_read_le32 (buf+needle-from);",
          "188:   if (!n1) {",
          "189:    needle += 4;",
          "190:    continue;",
          "191:   }",
          "197:   bool addr_aligned = !(needle % 4);",
          "201:    if (((to - needle) > 8 + rc)) {",
          "203:     bool is_wide32le = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);",
          "205:     if (is_wide32le) {",
          "206:      if (!w[5] && !w[6] && w[7] && w[8]) {",
          "207:       is_wide32le = false;",
          "208:      }",
          "209:     }",
          "210:     if (!addr_aligned) {",
          "211:      is_wide32le = false;",
          "212:     }",
          "214:     if (is_wide32le  && addr_aligned) {",
          "215:      str_type = R_STRING_TYPE_WIDE32; // asume big endian,is there little endian w32?",
          "222:     if (rc > 1) {",
          "223:      str_type = R_STRING_TYPE_UTF8; // could be charset if set :?",
          "224:     } else {",
          "225:      str_type = R_STRING_TYPE_ASCII;",
          "226:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ea087c0ca6f987afaab954d0b2551b2213e947f4",
      "candidate_info": {
        "commit_hash": "ea087c0ca6f987afaab954d0b2551b2213e947f4",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/ea087c0ca6f987afaab954d0b2551b2213e947f4",
        "files": [
          "libr/bin/bfile.c"
        ],
        "message": "Fix overflow check introduced in 193f4fe01d7f626e2ea937450f2e0c4604420e9d",
        "before_after_code_files": [
          "libr/bin/bfile.c||libr/bin/bfile.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/bfile.c||libr/bin/bfile.c"
          ],
          "candidate": [
            "libr/bin/bfile.c||libr/bin/bfile.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/bfile.c||libr/bin/bfile.c": [
          "File: libr/bin/bfile.c -> libr/bin/bfile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "183:    break;",
          "184:   }",
          "187:    ut32 n1 = r_read_le32 (buf + (needle - from));",
          "188:    if (!n1) {",
          "189:     needle += 4;",
          "",
          "[Removed Lines]",
          "186:   if (needle < to - 4) {",
          "",
          "[Added Lines]",
          "186:   if (to > 4 && needle < to - 4) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
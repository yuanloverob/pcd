{
  "cve_id": "CVE-2015-1805",
  "cve_desc": "The (1) pipe_read and (2) pipe_write implementations in fs/pipe.c in the Linux kernel before 3.16 do not properly consider the side effects of failed __copy_to_user_inatomic and __copy_from_user_inatomic calls, which allows local users to cause a denial of service (system crash) or possibly gain privileges via a crafted application, aka an \"I/O vector array overrun.\"",
  "repo": "torvalds/linux",
  "patch_hash": "f0d1bec9d58d4c038d0ac958c9af82be6eb18045",
  "patch_info": {
    "commit_hash": "f0d1bec9d58d4c038d0ac958c9af82be6eb18045",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/f0d1bec9d58d4c038d0ac958c9af82be6eb18045",
    "files": [
      "fs/pipe.c",
      "include/linux/uio.h",
      "mm/iov_iter.c"
    ],
    "message": "new helper: copy_page_from_iter()\n\nparallel to copy_page_to_iter().  pipe_write() switched to it (and became\n->write_iter()).\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
    "before_after_code_files": [
      "fs/pipe.c||fs/pipe.c",
      "include/linux/uio.h||include/linux/uio.h",
      "mm/iov_iter.c||mm/iov_iter.c"
    ]
  },
  "patch_diff": {
    "fs/pipe.c||fs/pipe.c": [
      "File: fs/pipe.c -> fs/pipe.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "116:  pipe_lock(pipe);",
      "117: }",
      "163: static void anon_pipe_buf_release(struct pipe_inode_info *pipe,",
      "164:       struct pipe_buffer *buf)",
      "165: {",
      "",
      "[Removed Lines]",
      "119: static int",
      "120: pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,",
      "121:    int atomic)",
      "122: {",
      "123:  unsigned long copy;",
      "125:  while (len > 0) {",
      "126:   while (!iov->iov_len)",
      "127:    iov++;",
      "128:   copy = min_t(unsigned long, len, iov->iov_len);",
      "130:   if (atomic) {",
      "131:    if (__copy_from_user_inatomic(to, iov->iov_base, copy))",
      "132:     return -EFAULT;",
      "133:   } else {",
      "134:    if (copy_from_user(to, iov->iov_base, copy))",
      "135:     return -EFAULT;",
      "136:   }",
      "137:   to += copy;",
      "138:   len -= copy;",
      "139:   iov->iov_base += copy;",
      "140:   iov->iov_len -= copy;",
      "141:  }",
      "142:  return 0;",
      "143: }",
      "148: static void iov_fault_in_pages_read(struct iovec *iov, unsigned long len)",
      "149: {",
      "150:  while (!iov->iov_len)",
      "151:   iov++;",
      "153:  while (len > 0) {",
      "154:   unsigned long this_len;",
      "156:   this_len = min_t(unsigned long, len, iov->iov_len);",
      "157:   fault_in_pages_readable(iov->iov_base, this_len);",
      "158:   len -= this_len;",
      "159:   iov++;",
      "160:  }",
      "161: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "380: }",
      "382: static ssize_t",
      "385: {",
      "386:  struct file *filp = iocb->ki_filp;",
      "387:  struct pipe_inode_info *pipe = filp->private_data;",
      "392:  ssize_t chars;",
      "396:  if (unlikely(total_len == 0))",
      "397:   return 0;",
      "401:  __pipe_lock(pipe);",
      "403:  if (!pipe->readers) {",
      "",
      "[Removed Lines]",
      "383: pipe_write(struct kiocb *iocb, const struct iovec *_iov,",
      "384:      unsigned long nr_segs, loff_t ppos)",
      "388:  ssize_t ret;",
      "389:  int do_wakeup;",
      "390:  struct iovec *iov = (struct iovec *)_iov;",
      "391:  size_t total_len;",
      "394:  total_len = iov_length(iov, nr_segs);",
      "399:  do_wakeup = 0;",
      "400:  ret = 0;",
      "",
      "[Added Lines]",
      "339: pipe_write(struct kiocb *iocb, struct iov_iter *from)",
      "343:  ssize_t ret = 0;",
      "344:  int do_wakeup = 0;",
      "345:  size_t total_len = iov_iter_count(from);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "416:   int offset = buf->offset + buf->len;",
      "418:   if (ops->can_merge && offset + chars <= PAGE_SIZE) {",
      "423:    if (error)",
      "424:     goto out;",
      "445:     goto out;",
      "446:    }",
      "447:    buf->len += chars;",
      "449:    ret = chars;",
      "451:     goto out;",
      "452:   }",
      "453:  }",
      "",
      "[Removed Lines]",
      "419:    int error, atomic = 1;",
      "420:    void *addr;",
      "422:    error = ops->confirm(pipe, buf);",
      "426:    iov_fault_in_pages_read(iov, chars);",
      "427: redo1:",
      "428:    if (atomic)",
      "429:     addr = kmap_atomic(buf->page);",
      "430:    else",
      "431:     addr = kmap(buf->page);",
      "432:    error = pipe_iov_copy_from_user(offset + addr, iov,",
      "433:        chars, atomic);",
      "434:    if (atomic)",
      "435:     kunmap_atomic(addr);",
      "436:    else",
      "437:     kunmap(buf->page);",
      "438:    ret = error;",
      "439:    do_wakeup = 1;",
      "440:    if (error) {",
      "441:     if (atomic) {",
      "442:      atomic = 0;",
      "443:      goto redo1;",
      "444:     }",
      "448:    total_len -= chars;",
      "450:    if (!total_len)",
      "",
      "[Added Lines]",
      "370:    int error = ops->confirm(pipe, buf);",
      "374:    ret = copy_page_from_iter(buf->page, offset, chars, from);",
      "375:    if (unlikely(ret < chars)) {",
      "376:     error = -EFAULT;",
      "379:    do_wakeup = 1;",
      "382:    if (!iov_iter_count(from))",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "466:    int newbuf = (pipe->curbuf + bufs) & (pipe->buffers-1);",
      "467:    struct pipe_buffer *buf = pipe->bufs + newbuf;",
      "468:    struct page *page = pipe->tmp_page;",
      "472:    if (!page) {",
      "473:     page = alloc_page(GFP_HIGHUSER);",
      "",
      "[Removed Lines]",
      "469:    char *src;",
      "470:    int error, atomic = 1;",
      "",
      "[Added Lines]",
      "401:    int copied;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "485:    do_wakeup = 1;",
      "509:     if (!ret)",
      "511:     break;",
      "512:    }",
      "516:    buf->page = page;",
      "517:    buf->ops = &anon_pipe_buf_ops;",
      "518:    buf->offset = 0;",
      "520:    buf->flags = 0;",
      "521:    if (is_packetized(filp)) {",
      "522:     buf->ops = &packet_pipe_buf_ops;",
      "",
      "[Removed Lines]",
      "486:    chars = PAGE_SIZE;",
      "487:    if (chars > total_len)",
      "488:     chars = total_len;",
      "490:    iov_fault_in_pages_read(iov, chars);",
      "491: redo2:",
      "492:    if (atomic)",
      "493:     src = kmap_atomic(page);",
      "494:    else",
      "495:     src = kmap(page);",
      "497:    error = pipe_iov_copy_from_user(src, iov, chars,",
      "498:        atomic);",
      "499:    if (atomic)",
      "500:     kunmap_atomic(src);",
      "501:    else",
      "502:     kunmap(page);",
      "504:    if (unlikely(error)) {",
      "505:     if (atomic) {",
      "506:      atomic = 0;",
      "507:      goto redo2;",
      "508:     }",
      "510:      ret = error;",
      "513:    ret += chars;",
      "519:    buf->len = chars;",
      "",
      "[Added Lines]",
      "417:    copied = copy_page_from_iter(page, 0, PAGE_SIZE, from);",
      "418:    if (unlikely(copied < PAGE_SIZE && iov_iter_count(from))) {",
      "420:      ret = -EFAULT;",
      "423:    ret += copied;",
      "429:    buf->len = copied;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "525:    pipe->nrbufs = ++bufs;",
      "526:    pipe->tmp_page = NULL;",
      "530:     break;",
      "531:   }",
      "532:   if (bufs < pipe->buffers)",
      "",
      "[Removed Lines]",
      "528:    total_len -= chars;",
      "529:    if (!total_len)",
      "",
      "[Added Lines]",
      "438:    if (!iov_iter_count(from))",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1040:  .llseek  = no_llseek,",
      "1041:  .read  = new_sync_read,",
      "1042:  .read_iter = pipe_read,",
      "1045:  .poll  = pipe_poll,",
      "1046:  .unlocked_ioctl = pipe_ioctl,",
      "1047:  .release = pipe_release,",
      "",
      "[Removed Lines]",
      "1043:  .write  = do_sync_write,",
      "1044:  .aio_write = pipe_write,",
      "",
      "[Added Lines]",
      "952:  .write  = new_sync_write,",
      "953:  .write_iter = pipe_write,",
      "",
      "---------------"
    ],
    "include/linux/uio.h||include/linux/uio.h": [
      "File: include/linux/uio.h -> include/linux/uio.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "68: size_t iov_iter_single_seg_count(const struct iov_iter *i);",
      "69: size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,",
      "70:     struct iov_iter *i);",
      "71: unsigned long iov_iter_alignment(const struct iov_iter *i);",
      "72: void iov_iter_init(struct iov_iter *i, int direction, const struct iovec *iov,",
      "73:    unsigned long nr_segs, size_t count);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "71: size_t copy_page_from_iter(struct page *page, size_t offset, size_t bytes,",
      "72:     struct iov_iter *i);",
      "",
      "---------------"
    ],
    "mm/iov_iter.c||mm/iov_iter.c": [
      "File: mm/iov_iter.c -> mm/iov_iter.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "82: }",
      "83: EXPORT_SYMBOL(copy_page_to_iter);",
      "85: static size_t __iovec_copy_from_user_inatomic(char *vaddr,",
      "86:    const struct iovec *iov, size_t base, size_t bytes)",
      "87: {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "85: size_t copy_page_from_iter(struct page *page, size_t offset, size_t bytes,",
      "86:     struct iov_iter *i)",
      "87: {",
      "88:  size_t skip, copy, left, wanted;",
      "89:  const struct iovec *iov;",
      "90:  char __user *buf;",
      "91:  void *kaddr, *to;",
      "93:  if (unlikely(bytes > i->count))",
      "94:   bytes = i->count;",
      "96:  if (unlikely(!bytes))",
      "97:   return 0;",
      "99:  wanted = bytes;",
      "100:  iov = i->iov;",
      "101:  skip = i->iov_offset;",
      "102:  buf = iov->iov_base + skip;",
      "103:  copy = min(bytes, iov->iov_len - skip);",
      "105:  if (!fault_in_pages_readable(buf, copy)) {",
      "106:   kaddr = kmap_atomic(page);",
      "107:   to = kaddr + offset;",
      "110:   left = __copy_from_user_inatomic(to, buf, copy);",
      "111:   copy -= left;",
      "112:   skip += copy;",
      "113:   to += copy;",
      "114:   bytes -= copy;",
      "116:   while (unlikely(!left && bytes)) {",
      "117:    iov++;",
      "118:    buf = iov->iov_base;",
      "119:    copy = min(bytes, iov->iov_len);",
      "120:    left = __copy_from_user_inatomic(to, buf, copy);",
      "121:    copy -= left;",
      "122:    skip = copy;",
      "123:    to += copy;",
      "124:    bytes -= copy;",
      "125:   }",
      "126:   if (likely(!bytes)) {",
      "127:    kunmap_atomic(kaddr);",
      "128:    goto done;",
      "129:   }",
      "130:   offset = to - kaddr;",
      "131:   buf += copy;",
      "132:   kunmap_atomic(kaddr);",
      "133:   copy = min(bytes, iov->iov_len - skip);",
      "134:  }",
      "136:  kaddr = kmap(page);",
      "137:  to = kaddr + offset;",
      "138:  left = __copy_from_user(to, buf, copy);",
      "139:  copy -= left;",
      "140:  skip += copy;",
      "141:  to += copy;",
      "142:  bytes -= copy;",
      "143:  while (unlikely(!left && bytes)) {",
      "144:   iov++;",
      "145:   buf = iov->iov_base;",
      "146:   copy = min(bytes, iov->iov_len);",
      "147:   left = __copy_from_user(to, buf, copy);",
      "148:   copy -= left;",
      "149:   skip = copy;",
      "150:   to += copy;",
      "151:   bytes -= copy;",
      "152:  }",
      "153:  kunmap(page);",
      "154: done:",
      "155:  i->count -= wanted - bytes;",
      "156:  i->nr_segs -= iov - i->iov;",
      "157:  i->iov = iov;",
      "158:  i->iov_offset = skip;",
      "159:  return wanted - bytes;",
      "160: }",
      "161: EXPORT_SYMBOL(copy_page_from_iter);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "fbb32750a62df75d1ffea547f3908b21c5496d9f",
      "candidate_info": {
        "commit_hash": "fbb32750a62df75d1ffea547f3908b21c5496d9f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/fbb32750a62df75d1ffea547f3908b21c5496d9f",
        "files": [
          "drivers/char/virtio_console.c",
          "fs/fuse/dev.c",
          "fs/pipe.c",
          "fs/splice.c",
          "include/linux/pipe_fs_i.h",
          "kernel/relay.c",
          "kernel/trace/trace.c"
        ],
        "message": "pipe: kill ->map() and ->unmap()\n\nall pipe_buffer_operations have the same instances of those...\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "drivers/char/virtio_console.c||drivers/char/virtio_console.c",
          "fs/fuse/dev.c||fs/fuse/dev.c",
          "fs/pipe.c||fs/pipe.c",
          "fs/splice.c||fs/splice.c",
          "include/linux/pipe_fs_i.h||include/linux/pipe_fs_i.h",
          "kernel/relay.c||kernel/relay.c",
          "kernel/trace/trace.c||kernel/trace/trace.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/pipe.c||fs/pipe.c"
          ],
          "candidate": [
            "fs/pipe.c||fs/pipe.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/char/virtio_console.c||drivers/char/virtio_console.c": [
          "File: drivers/char/virtio_console.c -> drivers/char/virtio_console.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "901:   if (len + offset > PAGE_SIZE)",
          "902:    len = PAGE_SIZE - offset;",
          "905:   memcpy(page_address(page) + offset, src + buf->offset, len);",
          "908:   sg_set_page(&(sgl->sg[sgl->n]), page, len, offset);",
          "909:  }",
          "",
          "[Removed Lines]",
          "904:   src = buf->ops->map(pipe, buf, 1);",
          "906:   buf->ops->unmap(pipe, buf, src);",
          "",
          "[Added Lines]",
          "904:   src = kmap_atomic(buf->page);",
          "906:   kunmap_atomic(src);",
          "",
          "---------------"
        ],
        "fs/fuse/dev.c||fs/fuse/dev.c": [
          "File: fs/fuse/dev.c -> fs/fuse/dev.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "667:   struct pipe_buffer *buf = cs->currbuf;",
          "669:   if (!cs->write) {",
          "671:   } else {",
          "672:    kunmap_atomic(cs->mapaddr);",
          "673:    buf->len = PAGE_SIZE - cs->len;",
          "",
          "[Removed Lines]",
          "670:    buf->ops->unmap(cs->pipe, buf, cs->mapaddr);",
          "",
          "[Added Lines]",
          "670:    kunmap_atomic(cs->mapaddr);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "707:    BUG_ON(!cs->nr_segs);",
          "708:    cs->currbuf = buf;",
          "710:    cs->len = buf->len;",
          "711:    cs->buf = cs->mapaddr + buf->offset;",
          "712:    cs->pipebufs++;",
          "",
          "[Removed Lines]",
          "709:    cs->mapaddr = buf->ops->map(cs->pipe, buf, 1);",
          "",
          "[Added Lines]",
          "709:    cs->mapaddr = kmap_atomic(buf->page);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "874: out_fallback_unlock:",
          "875:  unlock_page(newpage);",
          "876: out_fallback:",
          "878:  cs->buf = cs->mapaddr + buf->offset;",
          "880:  err = lock_request(cs->fc, cs->req);",
          "",
          "[Removed Lines]",
          "877:  cs->mapaddr = buf->ops->map(cs->pipe, buf, 1);",
          "",
          "[Added Lines]",
          "877:  cs->mapaddr = kmap_atomic(buf->page);",
          "",
          "---------------"
        ],
        "fs/pipe.c||fs/pipe.c": [
          "File: fs/pipe.c -> fs/pipe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "225:   page_cache_release(page);",
          "226: }",
          "",
          "[Removed Lines]",
          "242: void *generic_pipe_buf_map(struct pipe_inode_info *pipe,",
          "243:       struct pipe_buffer *buf, int atomic)",
          "244: {",
          "245:  if (atomic) {",
          "246:   buf->flags |= PIPE_BUF_FLAG_ATOMIC;",
          "247:   return kmap_atomic(buf->page);",
          "248:  }",
          "250:  return kmap(buf->page);",
          "251: }",
          "252: EXPORT_SYMBOL(generic_pipe_buf_map);",
          "263: void generic_pipe_buf_unmap(struct pipe_inode_info *pipe,",
          "264:        struct pipe_buffer *buf, void *map_data)",
          "265: {",
          "266:  if (buf->flags & PIPE_BUF_FLAG_ATOMIC) {",
          "267:   buf->flags &= ~PIPE_BUF_FLAG_ATOMIC;",
          "268:   kunmap_atomic(map_data);",
          "269:  } else",
          "270:   kunmap(buf->page);",
          "271: }",
          "272: EXPORT_SYMBOL(generic_pipe_buf_unmap);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "352: static const struct pipe_buf_operations anon_pipe_buf_ops = {",
          "353:  .can_merge = 1,",
          "356:  .confirm = generic_pipe_buf_confirm,",
          "357:  .release = anon_pipe_buf_release,",
          "358:  .steal = generic_pipe_buf_steal,",
          "",
          "[Removed Lines]",
          "354:  .map = generic_pipe_buf_map,",
          "355:  .unmap = generic_pipe_buf_unmap,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "362: static const struct pipe_buf_operations packet_pipe_buf_ops = {",
          "363:  .can_merge = 0,",
          "366:  .confirm = generic_pipe_buf_confirm,",
          "367:  .release = anon_pipe_buf_release,",
          "368:  .steal = generic_pipe_buf_steal,",
          "",
          "[Removed Lines]",
          "364:  .map = generic_pipe_buf_map,",
          "365:  .unmap = generic_pipe_buf_unmap,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "411:    atomic = !iov_fault_in_pages_write(iov, chars);",
          "412: redo:",
          "414:    error = pipe_iov_copy_to_user(iov, addr + buf->offset, chars, atomic);",
          "416:    if (unlikely(error)) {",
          "",
          "[Removed Lines]",
          "413:    addr = ops->map(pipe, buf, atomic);",
          "415:    ops->unmap(pipe, buf, addr);",
          "",
          "[Added Lines]",
          "363:    if (atomic)",
          "364:     addr = kmap_atomic(buf->page);",
          "365:    else",
          "366:     addr = kmap(buf->page);",
          "368:    if (atomic)",
          "369:     kunmap_atomic(addr);",
          "370:    else",
          "371:     kunmap(buf->page);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "539:    iov_fault_in_pages_read(iov, chars);",
          "540: redo1:",
          "542:    error = pipe_iov_copy_from_user(offset + addr, iov,",
          "543:        chars, atomic);",
          "545:    ret = error;",
          "546:    do_wakeup = 1;",
          "547:    if (error) {",
          "",
          "[Removed Lines]",
          "541:    addr = ops->map(pipe, buf, atomic);",
          "544:    ops->unmap(pipe, buf, addr);",
          "",
          "[Added Lines]",
          "497:    if (atomic)",
          "498:     addr = kmap_atomic(buf->page);",
          "499:    else",
          "500:     addr = kmap(buf->page);",
          "503:    if (atomic)",
          "504:     kunmap_atomic(addr);",
          "505:    else",
          "506:     kunmap(buf->page);",
          "",
          "---------------"
        ],
        "fs/splice.c||fs/splice.c": [
          "File: fs/splice.c -> fs/splice.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "137: const struct pipe_buf_operations page_cache_pipe_buf_ops = {",
          "138:  .can_merge = 0,",
          "141:  .confirm = page_cache_pipe_buf_confirm,",
          "142:  .release = page_cache_pipe_buf_release,",
          "143:  .steal = page_cache_pipe_buf_steal,",
          "",
          "[Removed Lines]",
          "139:  .map = generic_pipe_buf_map,",
          "140:  .unmap = generic_pipe_buf_unmap,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "157: static const struct pipe_buf_operations user_page_pipe_buf_ops = {",
          "158:  .can_merge = 0,",
          "161:  .confirm = generic_pipe_buf_confirm,",
          "162:  .release = page_cache_pipe_buf_release,",
          "163:  .steal = user_page_pipe_buf_steal,",
          "",
          "[Removed Lines]",
          "159:  .map = generic_pipe_buf_map,",
          "160:  .unmap = generic_pipe_buf_unmap,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "548: static const struct pipe_buf_operations default_pipe_buf_ops = {",
          "549:  .can_merge = 0,",
          "552:  .confirm = generic_pipe_buf_confirm,",
          "553:  .release = generic_pipe_buf_release,",
          "554:  .steal = generic_pipe_buf_steal,",
          "",
          "[Removed Lines]",
          "550:  .map = generic_pipe_buf_map,",
          "551:  .unmap = generic_pipe_buf_unmap,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "565: const struct pipe_buf_operations nosteal_pipe_buf_ops = {",
          "566:  .can_merge = 0,",
          "569:  .confirm = generic_pipe_buf_confirm,",
          "570:  .release = generic_pipe_buf_release,",
          "571:  .steal = generic_pipe_buf_nosteal,",
          "",
          "[Removed Lines]",
          "567:  .map = generic_pipe_buf_map,",
          "568:  .unmap = generic_pipe_buf_unmap,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "767:   goto out;",
          "769:  if (buf->page != page) {",
          "771:   char *dst = kmap_atomic(page);",
          "773:   memcpy(dst + offset, src + buf->offset, this_len);",
          "774:   flush_dcache_page(page);",
          "775:   kunmap_atomic(dst);",
          "777:  }",
          "778:  ret = pagecache_write_end(file, mapping, sd->pos, this_len, this_len,",
          "779:     page, fsdata);",
          "",
          "[Removed Lines]",
          "770:   char *src = buf->ops->map(pipe, buf, 1);",
          "776:   buf->ops->unmap(pipe, buf, src);",
          "",
          "[Added Lines]",
          "762:   char *src = kmap_atomic(buf->page);",
          "768:   kunmap_atomic(src);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1067:  void *data;",
          "1068:  loff_t tmp = sd->pos;",
          "1071:  ret = __kernel_write(sd->u.file, data + buf->offset, sd->len, &tmp);",
          "1074:  return ret;",
          "1075: }",
          "",
          "[Removed Lines]",
          "1070:  data = buf->ops->map(pipe, buf, 0);",
          "1072:  buf->ops->unmap(pipe, buf, data);",
          "",
          "[Added Lines]",
          "1062:  data = kmap(buf->page);",
          "1064:  kunmap(buf->page);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1538:  if (!fault_in_pages_writeable(sd->u.userptr, sd->len)) {",
          "1540:   ret = __copy_to_user_inatomic(sd->u.userptr, src + buf->offset,",
          "1541:        sd->len);",
          "1543:   if (!ret) {",
          "1544:    ret = sd->len;",
          "1545:    goto out;",
          "",
          "[Removed Lines]",
          "1539:   src = buf->ops->map(pipe, buf, 1);",
          "1542:   buf->ops->unmap(pipe, buf, src);",
          "",
          "[Added Lines]",
          "1531:   src = kmap_atomic(buf->page);",
          "1534:   kunmap_atomic(src);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1554:  ret = sd->len;",
          "1555:  if (copy_to_user(sd->u.userptr, src + buf->offset, sd->len))",
          "1556:   ret = -EFAULT;",
          "1559: out:",
          "1560:  if (ret > 0)",
          "1561:   sd->u.userptr += ret;",
          "",
          "[Removed Lines]",
          "1552:  src = buf->ops->map(pipe, buf, 0);",
          "1558:  buf->ops->unmap(pipe, buf, src);",
          "",
          "[Added Lines]",
          "1544:  src = kmap(buf->page);",
          "1550:  kunmap(buf->page);",
          "",
          "---------------"
        ],
        "include/linux/pipe_fs_i.h||include/linux/pipe_fs_i.h": [
          "File: include/linux/pipe_fs_i.h -> include/linux/pipe_fs_i.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "83:  int can_merge;",
          "",
          "[Removed Lines]",
          "95:  void * (*map)(struct pipe_inode_info *, struct pipe_buffer *, int);",
          "100:  void (*unmap)(struct pipe_inode_info *, struct pipe_buffer *, void *);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "150: void free_pipe_info(struct pipe_inode_info *);",
          "155: void generic_pipe_buf_get(struct pipe_inode_info *, struct pipe_buffer *);",
          "156: int generic_pipe_buf_confirm(struct pipe_inode_info *, struct pipe_buffer *);",
          "157: int generic_pipe_buf_steal(struct pipe_inode_info *, struct pipe_buffer *);",
          "",
          "[Removed Lines]",
          "153: void *generic_pipe_buf_map(struct pipe_inode_info *, struct pipe_buffer *, int);",
          "154: void generic_pipe_buf_unmap(struct pipe_inode_info *, struct pipe_buffer *, void *);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "kernel/relay.c||kernel/relay.c": [
          "File: kernel/relay.c -> kernel/relay.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1196: static const struct pipe_buf_operations relay_pipe_buf_ops = {",
          "1197:  .can_merge = 0,",
          "1200:  .confirm = generic_pipe_buf_confirm,",
          "1201:  .release = relay_pipe_buf_release,",
          "1202:  .steal = generic_pipe_buf_steal,",
          "",
          "[Removed Lines]",
          "1198:  .map = generic_pipe_buf_map,",
          "1199:  .unmap = generic_pipe_buf_unmap,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "kernel/trace/trace.c||kernel/trace/trace.c": [
          "File: kernel/trace/trace.c -> kernel/trace/trace.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4317: static const struct pipe_buf_operations tracing_pipe_buf_ops = {",
          "4318:  .can_merge  = 0,",
          "4321:  .confirm  = generic_pipe_buf_confirm,",
          "4322:  .release  = generic_pipe_buf_release,",
          "4323:  .steal   = generic_pipe_buf_steal,",
          "",
          "[Removed Lines]",
          "4319:  .map   = generic_pipe_buf_map,",
          "4320:  .unmap   = generic_pipe_buf_unmap,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5195: static const struct pipe_buf_operations buffer_pipe_buf_ops = {",
          "5196:  .can_merge  = 0,",
          "5199:  .confirm  = generic_pipe_buf_confirm,",
          "5200:  .release  = buffer_pipe_buf_release,",
          "5201:  .steal   = generic_pipe_buf_steal,",
          "",
          "[Removed Lines]",
          "5197:  .map   = generic_pipe_buf_map,",
          "5198:  .unmap   = generic_pipe_buf_unmap,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "62a8067a7f35dba2de501c9cb00e4cf36da90bc0",
      "candidate_info": {
        "commit_hash": "62a8067a7f35dba2de501c9cb00e4cf36da90bc0",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/62a8067a7f35dba2de501c9cb00e4cf36da90bc0",
        "files": [
          "fs/fuse/file.c",
          "include/linux/blk_types.h",
          "include/linux/uio.h",
          "mm/iov_iter.c",
          "mm/page_io.c"
        ],
        "message": "bio_vec-backed iov_iter\n\nNew variant of iov_iter - ITER_BVEC in iter->type, backed with\nbio_vec array instead of iovec one.  Primitives taught to deal\nwith such beasts, __swap_write() switched to using that kind\nof iov_iter.\n\nNote that bio_vec is just a <page, offset, length> triple - there's\nnothing block-specific about it.  I've left the definition where it\nwas, but took it from under ifdef CONFIG_BLOCK.\n\nNext target: ->splice_write()...\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "fs/fuse/file.c||fs/fuse/file.c",
          "include/linux/blk_types.h||include/linux/blk_types.h",
          "include/linux/uio.h||include/linux/uio.h",
          "mm/iov_iter.c||mm/iov_iter.c",
          "mm/page_io.c||mm/page_io.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/linux/uio.h||include/linux/uio.h",
            "mm/iov_iter.c||mm/iov_iter.c"
          ],
          "candidate": [
            "include/linux/uio.h||include/linux/uio.h",
            "mm/iov_iter.c||mm/iov_iter.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/fuse/file.c||fs/fuse/file.c": [
          "File: fs/fuse/file.c -> fs/fuse/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1292:   unsigned long user_addr = fuse_get_user_addr(ii);",
          "1293:   size_t frag_size = fuse_get_frag_size(ii, *nbytesp);",
          "",
          "[Removed Lines]",
          "1291:  if (ii->type & REQ_KERNEL) {",
          "",
          "[Added Lines]",
          "1291:  if (ii->type & ITER_KVEC) {",
          "",
          "---------------"
        ],
        "include/linux/blk_types.h||include/linux/blk_types.h": [
          "File: include/linux/blk_types.h -> include/linux/blk_types.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #ifndef __LINUX_BLK_TYPES_H",
          "6: #define __LINUX_BLK_TYPES_H",
          "10: #include <linux/types.h>",
          "12: struct bio_set;",
          "",
          "[Removed Lines]",
          "8: #ifdef CONFIG_BLOCK",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "28:  unsigned int bv_offset;",
          "29: };",
          "31: struct bvec_iter {",
          "32:  sector_t  bi_sector; /* device address in 512 byte",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #ifdef CONFIG_BLOCK",
          "",
          "---------------"
        ],
        "include/linux/uio.h||include/linux/uio.h": [
          "File: include/linux/uio.h -> include/linux/uio.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "19:  size_t iov_len;",
          "20: };",
          "22: struct iov_iter {",
          "23:  int type;",
          "26:  size_t iov_offset;",
          "27:  size_t count;",
          "28: };",
          "",
          "[Removed Lines]",
          "24:  const struct iovec *iov;",
          "25:  unsigned long nr_segs;",
          "",
          "[Added Lines]",
          "22: enum {",
          "23:  ITER_IOVEC = 0,",
          "24:  ITER_KVEC = 2,",
          "25:  ITER_BVEC = 4,",
          "26: };",
          "32:  union {",
          "33:   const struct iovec *iov;",
          "34:   const struct bio_vec *bvec;",
          "35:  };",
          "36:  unsigned long nr_segs;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "54: }",
          "56: #define iov_for_each(iov, iter, start)    \\",
          "57:  for (iter = (start);     \\",
          "58:       (iter).count &&     \\",
          "59:       ((iov = iov_iter_iovec(&(iter))), 1);  \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66:  if (!((start).type & ITER_BVEC))   \\",
          "",
          "---------------"
        ],
        "mm/iov_iter.c||mm/iov_iter.c": [
          "File: mm/iov_iter.c -> mm/iov_iter.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: #include <linux/slab.h>",
          "5: #include <linux/vmalloc.h>",
          "8:     struct iov_iter *i)",
          "9: {",
          "10:  size_t skip, copy, left, wanted;",
          "",
          "[Removed Lines]",
          "7: size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,",
          "",
          "[Added Lines]",
          "7: static size_t copy_page_to_iter_iovec(struct page *page, size_t offset, size_t bytes,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "84:  i->iov_offset = skip;",
          "85:  return wanted - bytes;",
          "86: }",
          "90:     struct iov_iter *i)",
          "91: {",
          "92:  size_t skip, copy, left, wanted;",
          "",
          "[Removed Lines]",
          "87: EXPORT_SYMBOL(copy_page_to_iter);",
          "89: size_t copy_page_from_iter(struct page *page, size_t offset, size_t bytes,",
          "",
          "[Added Lines]",
          "88: static size_t copy_page_from_iter_iovec(struct page *page, size_t offset, size_t bytes,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "166:  i->iov_offset = skip;",
          "167:  return wanted - bytes;",
          "168: }",
          "171: static size_t __iovec_copy_from_user_inatomic(char *vaddr,",
          "172:    const struct iovec *iov, size_t base, size_t bytes)",
          "",
          "[Removed Lines]",
          "169: EXPORT_SYMBOL(copy_page_from_iter);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "199:   struct iov_iter *i, unsigned long offset, size_t bytes)",
          "200: {",
          "201:  char *kaddr;",
          "",
          "[Removed Lines]",
          "198: size_t iov_iter_copy_from_user_atomic(struct page *page,",
          "",
          "[Added Lines]",
          "196: static size_t copy_from_user_atomic_iovec(struct page *page,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "216:  return copied;",
          "217: }",
          "221: {",
          "222:  BUG_ON(i->count < bytes);",
          "",
          "[Removed Lines]",
          "218: EXPORT_SYMBOL(iov_iter_copy_from_user_atomic);",
          "220: void iov_iter_advance(struct iov_iter *i, size_t bytes)",
          "",
          "[Added Lines]",
          "217: static void advance_iovec(struct iov_iter *i, size_t bytes)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "252:   i->nr_segs = nr_segs;",
          "253:  }",
          "254: }",
          "",
          "[Removed Lines]",
          "255: EXPORT_SYMBOL(iov_iter_advance);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "266: int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes)",
          "267: {",
          "271: }",
          "272: EXPORT_SYMBOL(iov_iter_fault_in_readable);",
          "288: {",
          "289:  const struct iovec *iov = i->iov;",
          "290:  unsigned long res;",
          "",
          "[Removed Lines]",
          "268:  char __user *buf = i->iov->iov_base + i->iov_offset;",
          "269:  bytes = min(bytes, i->iov->iov_len - i->iov_offset);",
          "270:  return fault_in_pages_readable(buf, bytes);",
          "277: size_t iov_iter_single_seg_count(const struct iov_iter *i)",
          "278: {",
          "279:  const struct iovec *iov = i->iov;",
          "280:  if (i->nr_segs == 1)",
          "281:   return i->count;",
          "282:  else",
          "283:   return min(i->count, iov->iov_len - i->iov_offset);",
          "284: }",
          "285: EXPORT_SYMBOL(iov_iter_single_seg_count);",
          "287: unsigned long iov_iter_alignment(const struct iov_iter *i)",
          "",
          "[Added Lines]",
          "264:  if (!(i->type & ITER_BVEC)) {",
          "265:   char __user *buf = i->iov->iov_base + i->iov_offset;",
          "266:   bytes = min(bytes, i->iov->iov_len - i->iov_offset);",
          "267:   return fault_in_pages_readable(buf, bytes);",
          "268:  }",
          "269:  return 0;",
          "273: static unsigned long alignment_iovec(const struct iov_iter *i)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "307:  res |= (unsigned long)iov->iov_base | size;",
          "308:  return res;",
          "309: }",
          "312: void iov_iter_init(struct iov_iter *i, int direction,",
          "313:    const struct iovec *iov, unsigned long nr_segs,",
          "",
          "[Removed Lines]",
          "310: EXPORT_SYMBOL(iov_iter_alignment);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "315: {",
          "317:  if (segment_eq(get_fs(), KERNEL_DS))",
          "319:  i->type = direction;",
          "320:  i->iov = iov;",
          "321:  i->nr_segs = nr_segs;",
          "",
          "[Removed Lines]",
          "318:   direction |= REQ_KERNEL;",
          "",
          "[Added Lines]",
          "303:   direction |= ITER_KVEC;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "324: }",
          "325: EXPORT_SYMBOL(iov_iter_init);",
          "328:      struct page **pages, size_t maxsize,",
          "329:      size_t *start)",
          "330: {",
          "",
          "[Removed Lines]",
          "327: ssize_t iov_iter_get_pages(struct iov_iter *i,",
          "",
          "[Added Lines]",
          "312: static ssize_t get_pages_iovec(struct iov_iter *i,",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "349:   return res;",
          "350:  return (res == n ? len : res * PAGE_SIZE) - *start;",
          "351: }",
          "355:      struct page ***pages, size_t maxsize,",
          "356:      size_t *start)",
          "357: {",
          "",
          "[Removed Lines]",
          "352: EXPORT_SYMBOL(iov_iter_get_pages);",
          "354: ssize_t iov_iter_get_pages_alloc(struct iov_iter *i,",
          "",
          "[Added Lines]",
          "338: static ssize_t get_pages_alloc_iovec(struct iov_iter *i,",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "388:  return (res == n ? len : res * PAGE_SIZE) - *start;",
          "389: }",
          "393: {",
          "394:  size_t offset = i->iov_offset;",
          "395:  size_t size = i->count;",
          "",
          "[Removed Lines]",
          "390: EXPORT_SYMBOL(iov_iter_get_pages_alloc);",
          "392: int iov_iter_npages(const struct iov_iter *i, int maxpages)",
          "",
          "[Added Lines]",
          "375: static int iov_iter_npages_iovec(const struct iov_iter *i, int maxpages)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "414:  }",
          "415:  return min(npages, maxpages);",
          "416: }",
          "417: EXPORT_SYMBOL(iov_iter_npages);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "401: static void memcpy_from_page(char *to, struct page *page, size_t offset, size_t len)",
          "402: {",
          "403:  char *from = kmap_atomic(page);",
          "404:  memcpy(to, from + offset, len);",
          "405:  kunmap_atomic(from);",
          "406: }",
          "408: static void memcpy_to_page(struct page *page, size_t offset, char *from, size_t len)",
          "409: {",
          "410:  char *to = kmap_atomic(page);",
          "411:  memcpy(to + offset, from, len);",
          "412:  kunmap_atomic(to);",
          "413: }",
          "415: static size_t copy_page_to_iter_bvec(struct page *page, size_t offset, size_t bytes,",
          "416:     struct iov_iter *i)",
          "417: {",
          "418:  size_t skip, copy, wanted;",
          "419:  const struct bio_vec *bvec;",
          "420:  void *kaddr, *from;",
          "422:  if (unlikely(bytes > i->count))",
          "423:   bytes = i->count;",
          "425:  if (unlikely(!bytes))",
          "426:   return 0;",
          "428:  wanted = bytes;",
          "429:  bvec = i->bvec;",
          "430:  skip = i->iov_offset;",
          "431:  copy = min_t(size_t, bytes, bvec->bv_len - skip);",
          "433:  kaddr = kmap_atomic(page);",
          "434:  from = kaddr + offset;",
          "435:  memcpy_to_page(bvec->bv_page, skip + bvec->bv_offset, from, copy);",
          "436:  skip += copy;",
          "437:  from += copy;",
          "438:  bytes -= copy;",
          "439:  while (bytes) {",
          "440:   bvec++;",
          "441:   copy = min(bytes, (size_t)bvec->bv_len);",
          "442:   memcpy_to_page(bvec->bv_page, bvec->bv_offset, from, copy);",
          "443:   skip = copy;",
          "444:   from += copy;",
          "445:   bytes -= copy;",
          "446:  }",
          "447:  kunmap_atomic(kaddr);",
          "448:  if (skip == bvec->bv_len) {",
          "449:   bvec++;",
          "450:   skip = 0;",
          "451:  }",
          "452:  i->count -= wanted - bytes;",
          "453:  i->nr_segs -= bvec - i->bvec;",
          "454:  i->bvec = bvec;",
          "455:  i->iov_offset = skip;",
          "456:  return wanted - bytes;",
          "457: }",
          "459: static size_t copy_page_from_iter_bvec(struct page *page, size_t offset, size_t bytes,",
          "460:     struct iov_iter *i)",
          "461: {",
          "462:  size_t skip, copy, wanted;",
          "463:  const struct bio_vec *bvec;",
          "464:  void *kaddr, *to;",
          "466:  if (unlikely(bytes > i->count))",
          "467:   bytes = i->count;",
          "469:  if (unlikely(!bytes))",
          "470:   return 0;",
          "472:  wanted = bytes;",
          "473:  bvec = i->bvec;",
          "474:  skip = i->iov_offset;",
          "476:  kaddr = kmap_atomic(page);",
          "478:  to = kaddr + offset;",
          "480:  copy = min(bytes, bvec->bv_len - skip);",
          "482:  memcpy_from_page(to, bvec->bv_page, bvec->bv_offset + skip, copy);",
          "484:  to += copy;",
          "485:  skip += copy;",
          "486:  bytes -= copy;",
          "488:  while (bytes) {",
          "489:   bvec++;",
          "490:   copy = min(bytes, (size_t)bvec->bv_len);",
          "491:   memcpy_from_page(to, bvec->bv_page, bvec->bv_offset, copy);",
          "492:   skip = copy;",
          "493:   to += copy;",
          "494:   bytes -= copy;",
          "495:  }",
          "496:  kunmap_atomic(kaddr);",
          "497:  if (skip == bvec->bv_len) {",
          "498:   bvec++;",
          "499:   skip = 0;",
          "500:  }",
          "501:  i->count -= wanted;",
          "502:  i->nr_segs -= bvec - i->bvec;",
          "503:  i->bvec = bvec;",
          "504:  i->iov_offset = skip;",
          "505:  return wanted;",
          "506: }",
          "508: static size_t copy_from_user_bvec(struct page *page,",
          "509:   struct iov_iter *i, unsigned long offset, size_t bytes)",
          "510: {",
          "511:  char *kaddr;",
          "512:  size_t left;",
          "513:  const struct bio_vec *bvec;",
          "514:  size_t base = i->iov_offset;",
          "516:  kaddr = kmap_atomic(page);",
          "517:  for (left = bytes, bvec = i->bvec; left; bvec++, base = 0) {",
          "518:   size_t copy = min(left, bvec->bv_len - base);",
          "519:   if (!bvec->bv_len)",
          "520:    continue;",
          "521:   memcpy_from_page(kaddr + offset, bvec->bv_page,",
          "522:      bvec->bv_offset + base, copy);",
          "523:   offset += copy;",
          "524:   left -= copy;",
          "525:  }",
          "526:  kunmap_atomic(kaddr);",
          "527:  return bytes;",
          "528: }",
          "530: static void advance_bvec(struct iov_iter *i, size_t bytes)",
          "531: {",
          "532:  BUG_ON(i->count < bytes);",
          "534:  if (likely(i->nr_segs == 1)) {",
          "535:   i->iov_offset += bytes;",
          "536:   i->count -= bytes;",
          "537:  } else {",
          "538:   const struct bio_vec *bvec = i->bvec;",
          "539:   size_t base = i->iov_offset;",
          "540:   unsigned long nr_segs = i->nr_segs;",
          "546:   while (bytes || unlikely(i->count && !bvec->bv_len)) {",
          "547:    int copy;",
          "549:    copy = min(bytes, bvec->bv_len - base);",
          "550:    BUG_ON(!i->count || i->count < copy);",
          "551:    i->count -= copy;",
          "552:    bytes -= copy;",
          "553:    base += copy;",
          "554:    if (bvec->bv_len == base) {",
          "555:     bvec++;",
          "556:     nr_segs--;",
          "557:     base = 0;",
          "558:    }",
          "559:   }",
          "560:   i->bvec = bvec;",
          "561:   i->iov_offset = base;",
          "562:   i->nr_segs = nr_segs;",
          "563:  }",
          "564: }",
          "566: static unsigned long alignment_bvec(const struct iov_iter *i)",
          "567: {",
          "568:  const struct bio_vec *bvec = i->bvec;",
          "569:  unsigned long res;",
          "570:  size_t size = i->count;",
          "571:  size_t n;",
          "573:  if (!size)",
          "574:   return 0;",
          "576:  res = bvec->bv_offset + i->iov_offset;",
          "577:  n = bvec->bv_len - i->iov_offset;",
          "578:  if (n >= size)",
          "579:   return res | size;",
          "580:  size -= n;",
          "581:  res |= n;",
          "582:  while (size > (++bvec)->bv_len) {",
          "583:   res |= bvec->bv_offset | bvec->bv_len;",
          "584:   size -= bvec->bv_len;",
          "585:  }",
          "586:  res |= bvec->bv_offset | size;",
          "587:  return res;",
          "588: }",
          "590: static ssize_t get_pages_bvec(struct iov_iter *i,",
          "591:      struct page **pages, size_t maxsize,",
          "592:      size_t *start)",
          "593: {",
          "594:  const struct bio_vec *bvec = i->bvec;",
          "595:  size_t len = bvec->bv_len - i->iov_offset;",
          "596:  if (len > i->count)",
          "597:   len = i->count;",
          "598:  if (len > maxsize)",
          "599:   len = maxsize;",
          "602:  get_page(*pages = bvec->bv_page);",
          "604:  return len;",
          "605: }",
          "607: static ssize_t get_pages_alloc_bvec(struct iov_iter *i,",
          "608:      struct page ***pages, size_t maxsize,",
          "609:      size_t *start)",
          "610: {",
          "611:  const struct bio_vec *bvec = i->bvec;",
          "612:  size_t len = bvec->bv_len - i->iov_offset;",
          "613:  if (len > i->count)",
          "614:   len = i->count;",
          "615:  if (len > maxsize)",
          "616:   len = maxsize;",
          "620:  if (!*pages)",
          "621:   return -ENOMEM;",
          "623:  get_page(**pages = bvec->bv_page);",
          "625:  return len;",
          "626: }",
          "628: static int iov_iter_npages_bvec(const struct iov_iter *i, int maxpages)",
          "629: {",
          "630:  size_t offset = i->iov_offset;",
          "631:  size_t size = i->count;",
          "632:  const struct bio_vec *bvec = i->bvec;",
          "633:  int npages = 0;",
          "634:  int n;",
          "636:  for (n = 0; size && n < i->nr_segs; n++, bvec++) {",
          "637:   size_t len = bvec->bv_len - offset;",
          "638:   offset = 0;",
          "640:    continue;",
          "641:   if (len > size)",
          "642:    len = size;",
          "643:   npages++;",
          "645:    return maxpages;",
          "646:   size -= len;",
          "647:   offset = 0;",
          "648:  }",
          "649:  return min(npages, maxpages);",
          "650: }",
          "652: size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,",
          "653:     struct iov_iter *i)",
          "654: {",
          "655:  if (i->type & ITER_BVEC)",
          "656:   return copy_page_to_iter_bvec(page, offset, bytes, i);",
          "657:  else",
          "658:   return copy_page_to_iter_iovec(page, offset, bytes, i);",
          "659: }",
          "660: EXPORT_SYMBOL(copy_page_to_iter);",
          "662: size_t copy_page_from_iter(struct page *page, size_t offset, size_t bytes,",
          "663:     struct iov_iter *i)",
          "664: {",
          "665:  if (i->type & ITER_BVEC)",
          "666:   return copy_page_from_iter_bvec(page, offset, bytes, i);",
          "667:  else",
          "668:   return copy_page_from_iter_iovec(page, offset, bytes, i);",
          "669: }",
          "670: EXPORT_SYMBOL(copy_page_from_iter);",
          "672: size_t iov_iter_copy_from_user_atomic(struct page *page,",
          "673:   struct iov_iter *i, unsigned long offset, size_t bytes)",
          "674: {",
          "675:  if (i->type & ITER_BVEC)",
          "676:   return copy_from_user_bvec(page, i, offset, bytes);",
          "677:  else",
          "678:   return copy_from_user_atomic_iovec(page, i, offset, bytes);",
          "679: }",
          "680: EXPORT_SYMBOL(iov_iter_copy_from_user_atomic);",
          "682: void iov_iter_advance(struct iov_iter *i, size_t size)",
          "683: {",
          "684:  if (i->type & ITER_BVEC)",
          "685:   advance_bvec(i, size);",
          "686:  else",
          "687:   advance_iovec(i, size);",
          "688: }",
          "689: EXPORT_SYMBOL(iov_iter_advance);",
          "694: size_t iov_iter_single_seg_count(const struct iov_iter *i)",
          "695: {",
          "696:  if (i->nr_segs == 1)",
          "697:   return i->count;",
          "698:  else if (i->type & ITER_BVEC)",
          "699:   return min(i->count, i->iov->iov_len - i->iov_offset);",
          "700:  else",
          "701:   return min(i->count, i->bvec->bv_len - i->iov_offset);",
          "702: }",
          "703: EXPORT_SYMBOL(iov_iter_single_seg_count);",
          "705: unsigned long iov_iter_alignment(const struct iov_iter *i)",
          "706: {",
          "707:  if (i->type & ITER_BVEC)",
          "708:   return alignment_bvec(i);",
          "709:  else",
          "710:   return alignment_iovec(i);",
          "711: }",
          "712: EXPORT_SYMBOL(iov_iter_alignment);",
          "714: ssize_t iov_iter_get_pages(struct iov_iter *i,",
          "715:      struct page **pages, size_t maxsize,",
          "716:      size_t *start)",
          "717: {",
          "718:  if (i->type & ITER_BVEC)",
          "719:   return get_pages_bvec(i, pages, maxsize, start);",
          "720:  else",
          "721:   return get_pages_iovec(i, pages, maxsize, start);",
          "722: }",
          "723: EXPORT_SYMBOL(iov_iter_get_pages);",
          "725: ssize_t iov_iter_get_pages_alloc(struct iov_iter *i,",
          "726:      struct page ***pages, size_t maxsize,",
          "727:      size_t *start)",
          "728: {",
          "729:  if (i->type & ITER_BVEC)",
          "730:   return get_pages_alloc_bvec(i, pages, maxsize, start);",
          "731:  else",
          "732:   return get_pages_alloc_iovec(i, pages, maxsize, start);",
          "733: }",
          "734: EXPORT_SYMBOL(iov_iter_get_pages_alloc);",
          "736: int iov_iter_npages(const struct iov_iter *i, int maxpages)",
          "737: {",
          "738:  if (i->type & ITER_BVEC)",
          "739:   return iov_iter_npages_bvec(i, maxpages);",
          "740:  else",
          "741:   return iov_iter_npages_iovec(i, maxpages);",
          "742: }",
          "",
          "---------------"
        ],
        "mm/page_io.c||mm/page_io.c": [
          "File: mm/page_io.c -> mm/page_io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "259:   struct kiocb kiocb;",
          "260:   struct file *swap_file = sis->swap_file;",
          "261:   struct address_space *mapping = swap_file->f_mapping;",
          "265:   };",
          "268:   init_sync_kiocb(&kiocb, swap_file);",
          "269:   kiocb.ki_pos = page_file_offset(page);",
          "270:   kiocb.ki_nbytes = PAGE_SIZE;",
          "273:   set_page_writeback(page);",
          "274:   unlock_page(page);",
          "276:       &kiocb, &from,",
          "277:       kiocb.ki_pos);",
          "279:   if (ret == PAGE_SIZE) {",
          "280:    count_vm_event(PSWPOUT);",
          "281:    ret = 0;",
          "",
          "[Removed Lines]",
          "262:   struct iovec iov = {",
          "263:    .iov_base = kmap(page),",
          "264:    .iov_len  = PAGE_SIZE,",
          "266:   struct iov_iter from;",
          "271:   iov_iter_init(&from, KERNEL_WRITE, &iov, 1, PAGE_SIZE);",
          "275:   ret = mapping->a_ops->direct_IO(KERNEL_WRITE,",
          "278:   kunmap(page);",
          "",
          "[Added Lines]",
          "262:   struct bio_vec bv = {",
          "263:    .bv_page = page,",
          "264:    .bv_len  = PAGE_SIZE,",
          "265:    .bv_offset = 0",
          "266:   };",
          "267:   struct iov_iter from = {",
          "268:    .type = ITER_BVEC | WRITE,",
          "269:    .count = PAGE_SIZE,",
          "270:    .iov_offset = 0,",
          "271:    .nr_segs = 1,",
          "272:    .bvec = &bv",
          "281:   ret = mapping->a_ops->direct_IO(ITER_BVEC | WRITE,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
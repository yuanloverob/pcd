{
  "cve_id": "CVE-2015-3150",
  "cve_desc": "abrt-dbus in Automatic Bug Reporting Tool (ABRT) allows local users to delete or change the ownership of arbitrary files via the problem directory argument to the (1) ChownProblemDir, (2) DeleteElement, or (3) DeleteProblem method.",
  "repo": "abrt/libreport",
  "patch_hash": "1951e7282043dfe1268d492aea056b554baedb75",
  "patch_info": {
    "commit_hash": "1951e7282043dfe1268d492aea056b554baedb75",
    "repo": "abrt/libreport",
    "commit_url": "https://github.com/abrt/libreport/commit/1951e7282043dfe1268d492aea056b554baedb75",
    "files": [
      "src/include/dump_dir.h",
      "src/include/internal_libreport.h",
      "src/lib/dump_dir.c",
      "src/lib/problem_data.c",
      "src/lib/xfuncs.c"
    ],
    "message": "lib: fix races in dump directory handling code\n\nFlorian Weimer <fweimer@redhat.com>:\n\n    dd_opendir() should keep a file handle (opened with O_DIRECTORY) and\n    use openat() and similar functions to access files in it.\n\n    ...\n\n    The file system manipulation functions should guard against hard\n    links (check that link count is <= 1, just as in the user coredump\n    code in abrt-hook-ccpp), possibly after opening the file\n    with O_PATH first to avoid side effects on open/close.\n\nRelated: #1214745\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
    "before_after_code_files": [
      "src/include/dump_dir.h||src/include/dump_dir.h",
      "src/include/internal_libreport.h||src/include/internal_libreport.h",
      "src/lib/dump_dir.c||src/lib/dump_dir.c",
      "src/lib/problem_data.c||src/lib/problem_data.c",
      "src/lib/xfuncs.c||src/lib/xfuncs.c"
    ]
  },
  "patch_diff": {
    "src/include/dump_dir.h||src/include/dump_dir.h": [
      "File: src/include/dump_dir.h -> src/include/dump_dir.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "36: int create_symlink_lockfile(const char *filename, const char *pid_str);",
      "38: enum {",
      "39:     DD_FAIL_QUIETLY_ENOENT = (1 << 0),",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "37: int create_symlink_lockfile_at(int dir_fd, const char *filename, const char *pid_str);",
      "42: int secure_openat_read(int dir_fd, const char *filename);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "57:     mode_t mode;",
      "58:     time_t dd_time;",
      "59:     char *dd_type;",
      "60: };",
      "62: void dd_close(struct dump_dir *dd);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "66:     int dd_fd;",
      "",
      "---------------"
    ],
    "src/include/internal_libreport.h||src/include/internal_libreport.h": [
      "File: src/include/internal_libreport.h -> src/include/internal_libreport.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "406: int xopen(const char *pathname, int flags);",
      "407: #define xunlink libreport_xunlink",
      "408: void xunlink(const char *pathname);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "409: #define xunlinkat libreport_xunlinkat",
      "410: void xunlinkat(int dir_fd, const char *pathname, int flags);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "416: #define is_regular_file libreport_is_regular_file",
      "417: int is_regular_file(struct dirent *dent, const char *dirname);",
      "419: #define dot_or_dotdot libreport_dot_or_dotdot",
      "420: bool dot_or_dotdot(const char *filename);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "420: #define is_regular_file_at libreport_is_regular_file_at",
      "421: int is_regular_file_at(struct dirent *dent, int dir_fd);",
      "",
      "---------------"
    ],
    "src/lib/dump_dir.c||src/lib/dump_dir.c": [
      "File: src/lib/dump_dir.c -> src/lib/dump_dir.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "87: static char *load_text_file(const char *path, unsigned flags);",
      "88: static void copy_file_from_chroot(struct dump_dir* dd, const char *name,",
      "89:         const char *chroot_dir, const char *file_path);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "88: static char *load_text_file_at(int dir_fd, const char *name, unsigned flags);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "98:     return true;",
      "99: }",
      "102: {",
      "103:     struct stat buf;",
      "105:     {",
      "106:         if (S_ISDIR(buf.st_mode) || S_ISREG(buf.st_mode))",
      "107:         {",
      "",
      "[Removed Lines]",
      "101: static bool exist_file_dir(const char *path)",
      "104:     if (stat(path, &buf) == 0)",
      "",
      "[Added Lines]",
      "102: static bool exist_file_dir_at(int dir_fd, const char *name)",
      "105:     if (fstatat(dir_fd, name, &buf, AT_SYMLINK_NOFOLLOW) == 0)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "111:     return false;",
      "112: }",
      "120: {",
      "123:     if (fd < 0)",
      "124:     {",
      "125:         VERB2 pwarn_msg(\"Can't open '%s'\", filename);",
      "",
      "[Removed Lines]",
      "119: static time_t parse_time_file(const char *filename)",
      "122:     int fd = open(filename, O_RDONLY | O_NOFOLLOW);",
      "",
      "[Added Lines]",
      "125: int secure_openat_read(int dir_fd, const char *pathname)",
      "126: {",
      "127:     static char reopen_buf[sizeof(\"/proc/self/fd/\") + 3*sizeof(int) + 1];",
      "129:     int path_fd = openat(dir_fd, pathname, O_PATH | O_NOFOLLOW);",
      "130:     if (path_fd < 0)",
      "131:         return -1;",
      "133:     struct stat path_sb;",
      "134:     int r = fstat(path_fd, &path_sb);",
      "135:     if (r < 0)",
      "136:     {",
      "137:         perror_msg(\"stat\");",
      "138:         close(path_fd);",
      "139:         return -1;",
      "140:     }",
      "142:     if (!S_ISREG(path_sb.st_mode) || path_sb.st_nlink > 1)",
      "143:     {",
      "144:         log_notice(\"Path isn't a regular file or has more links (%lu)\", path_sb.st_nlink);",
      "145:         errno = EINVAL;",
      "146:         close(path_fd);",
      "147:         return -1;",
      "148:     }",
      "150:     if (snprintf(reopen_buf, sizeof(reopen_buf), \"/proc/self/fd/%d\", path_fd) >= sizeof(reopen_buf)) {",
      "151:         error_msg(\"BUG: too long path to a file descriptor\");",
      "152:         abort();",
      "153:     }",
      "155:     const int fd = open(reopen_buf, O_RDONLY);",
      "156:     close(path_fd);",
      "158:     return fd;",
      "159: }",
      "166: static time_t parse_time_file_at(int dir_fd, const char *filename)",
      "169:     int fd = secure_openat_read(dir_fd, filename);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "187: {",
      "189:     {",
      "190:         if (errno != EEXIST)",
      "191:         {",
      "",
      "[Removed Lines]",
      "186: int create_symlink_lockfile(const char* lock_file, const char* pid)",
      "188:     while (symlink(pid, lock_file) != 0)",
      "",
      "[Added Lines]",
      "233: int create_symlink_lockfile_at(int dir_fd, const char* lock_file, const char* pid)",
      "235:     while (symlinkat(pid, dir_fd, lock_file) != 0)",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "198:         }",
      "200:         char pid_buf[sizeof(pid_t)*3 + 4];",
      "202:         if (r < 0)",
      "203:         {",
      "204:             if (errno == ENOENT)",
      "",
      "[Removed Lines]",
      "201:         ssize_t r = readlink(lock_file, pid_buf, sizeof(pid_buf) - 1);",
      "",
      "[Added Lines]",
      "248:         ssize_t r = readlinkat(dir_fd, lock_file, pid_buf, sizeof(pid_buf) - 1);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "230:             log(\"Lock file '%s' was locked by process %s, but it crashed?\", lock_file, pid_buf);",
      "231:         }",
      "234:         {",
      "235:             perror_msg(\"Can't remove stale lock file '%s'\", lock_file);",
      "236:             errno = 0;",
      "",
      "[Removed Lines]",
      "233:         if (unlink(lock_file) != 0 && errno != ENOENT)",
      "",
      "[Added Lines]",
      "280:         if (unlinkat(dir_fd, lock_file, /*only files*/0) != 0 && errno != ENOENT)",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "242:     return 1;",
      "243: }",
      "245: static const char *dd_check(struct dump_dir *dd)",
      "246: {",
      "252:     if (dd->dd_time < 0)",
      "253:     {",
      "254:         log_warning(\"Missing file: \"FILENAME_TIME);",
      "255:         return FILENAME_TIME;",
      "256:     }",
      "260:     if (!dd->dd_type || (strlen(dd->dd_type) == 0))",
      "261:     {",
      "262:         log_warning(\"Missing or empty file: \"FILENAME_TYPE);",
      "",
      "[Removed Lines]",
      "247:     unsigned dirname_len = strlen(dd->dd_dirname);",
      "248:     char filename_buf[FILENAME_MAX+1];",
      "249:     strcpy(filename_buf, dd->dd_dirname);",
      "250:     strcpy(filename_buf + dirname_len, \"/\"FILENAME_TIME);",
      "251:     dd->dd_time = parse_time_file(filename_buf);",
      "258:     strcpy(filename_buf + dirname_len, \"/\"FILENAME_TYPE);",
      "259:     dd->dd_type = load_text_file(filename_buf, DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE);",
      "",
      "[Added Lines]",
      "292: int create_symlink_lockfile(const char *filename, const char *pid_str)",
      "293: {",
      "294:     return create_symlink_lockfile_at(AT_FDCWD, filename, pid_str);",
      "295: }",
      "299:     dd->dd_time = parse_time_file_at(dd->dd_fd, FILENAME_TIME);",
      "306:     dd->dd_type = load_text_file_at(dd->dd_fd, FILENAME_TYPE, DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "274:     char pid_buf[sizeof(long)*3 + 2];",
      "275:     snprintf(pid_buf, sizeof(pid_buf), \"%lu\", (long)getpid());",
      "282:     unsigned count = NO_TIME_FILE_COUNT;",
      "284:  retry:",
      "285:     while (1)",
      "286:     {",
      "288:         if (r < 0)",
      "290:         if (r > 0)",
      "",
      "[Removed Lines]",
      "277:     unsigned dirname_len = strlen(dd->dd_dirname);",
      "278:     char lock_buf[dirname_len + sizeof(\"/.lock\")];",
      "279:     strcpy(lock_buf, dd->dd_dirname);",
      "280:     strcpy(lock_buf + dirname_len, \"/.lock\");",
      "287:         int r = create_symlink_lockfile(lock_buf, pid_buf);",
      "",
      "[Added Lines]",
      "329:         int r = create_symlink_lockfile_at(dd->dd_fd, \".lock\", pid_buf);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "305:         if (missing_file)",
      "306:         {",
      "309:             if (--count == 0 || flags & DD_DONT_WAIT_FOR_LOCK)",
      "310:             {",
      "",
      "[Removed Lines]",
      "307:             xunlink(lock_buf);",
      "308:             log_warning(\"Unlocked '%s' (no or corrupted '%s' file)\", lock_buf, missing_file);",
      "",
      "[Added Lines]",
      "349:             xunlinkat(dd->dd_fd, \".lock\", /*only files*/0);",
      "350:             log_warning(\"Unlocked '%s' (no or corrupted '%s' file)\", dd->dd_dirname, missing_file);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "326:     {",
      "327:         dd->locked = 0;",
      "336:     }",
      "337: }",
      "",
      "[Removed Lines]",
      "329:         unsigned dirname_len = strlen(dd->dd_dirname);",
      "330:         char lock_buf[dirname_len + sizeof(\"/.lock\")];",
      "331:         strcpy(lock_buf, dd->dd_dirname);",
      "332:         strcpy(lock_buf + dirname_len, \"/.lock\");",
      "333:         xunlink(lock_buf);",
      "335:         log_info(\"Unlocked '%s'\", lock_buf);",
      "",
      "[Added Lines]",
      "371:         xunlinkat(dd->dd_fd, \".lock\", /*only files*/0);",
      "373:         log_info(\"Unlocked '%s/.lock'\", dd->dd_dirname);",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "340: {",
      "341:     struct dump_dir* dd = (struct dump_dir*)xzalloc(sizeof(struct dump_dir));",
      "342:     dd->dd_time = -1;",
      "343:     return dd;",
      "344: }",
      "347: {",
      "354:     return ret;",
      "355: }",
      "",
      "[Removed Lines]",
      "346: int dd_exist(const struct dump_dir *dd, const char *path)",
      "348:     if (!str_is_correct_filename(path))",
      "349:         error_msg_and_die(\"Cannot test existence. '%s' is not a valid file name\", path);",
      "351:     char *full_path = concat_path_file(dd->dd_dirname, path);",
      "352:     int ret = exist_file_dir(full_path);",
      "353:     free(full_path);",
      "",
      "[Added Lines]",
      "381:     dd->dd_fd = -1;",
      "385: int dd_exist(const struct dump_dir *dd, const char *name)",
      "387:     if (!str_is_correct_filename(name))",
      "388:         error_msg_and_die(\"Cannot test existence. '%s' is not a valid file name\", name);",
      "390:     const int ret = exist_file_dir_at(dd->dd_fd, name);",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "360:         return;",
      "362:     dd_unlock(dd);",
      "363:     if (dd->next_dir)",
      "364:     {",
      "365:         closedir(dd->next_dir);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "400:     close(dd->dd_fd);",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "384:     struct dump_dir *dd = dd_init();",
      "386:     dir = dd->dd_dirname = rm_trailing_slashes(dir);",
      "388:     struct stat stat_buf;",
      "390:         goto cant_access;",
      "392:     dd->mode = (stat_buf.st_mode & 0666);",
      "",
      "[Removed Lines]",
      "389:     if (stat(dir, &stat_buf) != 0)",
      "",
      "[Added Lines]",
      "425:     dd->dd_fd = open(dir, O_DIRECTORY | O_NOFOLLOW);",
      "427:     if (dd->dd_fd < 0)",
      "429:     if (fstat(dd->dd_fd, &stat_buf) != 0)",
      "430:         goto cant_access;",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "397:         if ((flags & DD_OPEN_READONLY) && errno == EACCES)",
      "398:         {",
      "405:                 if(dd_check(dd) != NULL)",
      "406:                 {",
      "407:                     dd_close(dd);",
      "",
      "[Removed Lines]",
      "401:             if (stat(dir, &stat_buf) == 0",
      "402:              && S_ISDIR(stat_buf.st_mode)",
      "403:              && access(dir, R_OK) == 0",
      "404:             ) {",
      "",
      "[Added Lines]",
      "445:             if (faccessat(dd->dd_fd, \".\", R_OK, AT_SYMLINK_NOFOLLOW) == 0)",
      "446:             {",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "444:     if (geteuid() == 0)",
      "445:     {",
      "449:         {",
      "451:             dd_close(dd);",
      "452:             return NULL;",
      "453:         }",
      "",
      "[Removed Lines]",
      "447:         struct stat stat_buf;",
      "448:         if (stat(dir, &stat_buf) != 0 || !S_ISDIR(stat_buf.st_mode))",
      "450:             error_msg(\"Can't stat '%s', or it is not a directory\", dir);",
      "",
      "[Added Lines]",
      "489:         if (fstat(dd->dd_fd, &stat_buf) != 0)",
      "491:             error_msg(\"Can't stat '%s'\", dir);",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "544:         error_msg(\"Bad dir name '%s'\", dir);",
      "547:     }",
      "",
      "[Removed Lines]",
      "545:         dd_close(dd);",
      "546:         return NULL;",
      "",
      "[Added Lines]",
      "586:         goto fail;",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "559:     if (r != 0)",
      "560:     {",
      "561:         perror_msg(\"Can't create directory '%s'\", dir);",
      "564:     }",
      "567:     {",
      "570:     }",
      "574:     {",
      "575:         perror_msg(\"Can't change mode of '%s'\", dir);",
      "578:     }",
      "580:     dd->dd_uid = (uid_t)-1L;",
      "",
      "[Removed Lines]",
      "562:         dd_close(dd);",
      "563:         return NULL;",
      "566:     if (dd_lock(dd, CREATE_LOCK_USLEEP, /*flags:*/ 0) < 0)",
      "568:         dd_close(dd);",
      "569:         return NULL;",
      "573:     if (chmod(dir, dir_mode) == -1)",
      "576:         dd_close(dd);",
      "577:         return NULL;",
      "",
      "[Added Lines]",
      "602:         goto fail;",
      "605:     dd->dd_fd = open(dd->dd_dirname, O_DIRECTORY | O_NOFOLLOW);",
      "606:     if (dd->dd_fd < 0)",
      "608:         perror_msg(\"Can't open newly created directory '%s'\", dir);",
      "609:         goto fail;",
      "612:     struct stat stat_sb;",
      "613:     if (fstat(dd->dd_fd, &stat_sb) < 0)",
      "614:     {",
      "615:         perror_msg(\"stat(%s)\", dd->dd_dirname);",
      "616:         goto fail;",
      "617:     }",
      "619:     if (dd_lock(dd, CREATE_LOCK_USLEEP, /*flags:*/ 0) < 0)",
      "620:         goto fail;",
      "623:     if (fchmod(dd->dd_fd, dir_mode) == -1)",
      "626:         goto fail;",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "616:     }",
      "618:     return dd;",
      "619: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "669: fail:",
      "670:     dd_close(dd);",
      "671:     return NULL;",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "624: int dd_reset_ownership(struct dump_dir *dd)",
      "625: {",
      "627:     if (r < 0)",
      "628:     {",
      "629:         perror_msg(\"Can't change '%s' ownership to %lu:%lu\", dd->dd_dirname,",
      "",
      "[Removed Lines]",
      "626:     const int r =lchown(dd->dd_dirname, dd->dd_uid, dd->dd_gid);",
      "",
      "[Added Lines]",
      "679:     const int r = fchown(dd->dd_fd, dd->dd_uid, dd->dd_gid);",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "740:     if (!dd->locked)",
      "749:     {",
      "789:     }",
      "791: }",
      "794: {",
      "796:     if (!d)",
      "797:     {",
      "",
      "[Removed Lines]",
      "743:     DIR *d = opendir(dd->dd_dirname);",
      "744:     if (!d)",
      "745:         return;",
      "747:     struct dirent *dent;",
      "748:     while ((dent = readdir(d)) != NULL)",
      "751:             continue;",
      "752:         char *full_path = concat_path_file(dd->dd_dirname, dent->d_name);",
      "753:         struct stat statbuf;",
      "754:         if (lstat(full_path, &statbuf) == 0 && S_ISREG(statbuf.st_mode))",
      "755:         {",
      "756:             if ((statbuf.st_mode & 0777) != dd->mode)",
      "757:             {",
      "764:                 int fd = open(full_path, O_RDONLY | O_NOFOLLOW, dd->mode);",
      "765:                 if (fd >= 0)",
      "766:                 {",
      "767:                     if (fchmod(fd, dd->mode) != 0)",
      "768:                     {",
      "769:                         perror_msg(\"Can't change '%s' mode to 0%o\", full_path,",
      "770:                                    (unsigned)dd->mode);",
      "771:                     }",
      "772:                     close(fd);",
      "773:                 }",
      "774:                 else",
      "775:                 {",
      "776:                     perror_msg(\"Can't open regular file '%s'\", full_path);",
      "777:                 }",
      "778:             }",
      "779:             if (statbuf.st_uid != dd->dd_uid || statbuf.st_gid != dd->dd_gid)",
      "780:             {",
      "781:                 if (lchown(full_path, dd->dd_uid, dd->dd_gid) != 0)",
      "782:                 {",
      "783:                     perror_msg(\"Can't change '%s' ownership to %lu:%lu\", full_path,",
      "784:                                (long)dd->dd_uid, (long)dd->dd_gid);",
      "785:                 }",
      "786:             }",
      "787:         }",
      "788:         free(full_path);",
      "790:     closedir(d);",
      "793: static int delete_file_dir(const char *dir, bool skip_lock_file)",
      "795:     DIR *d = opendir(dir);",
      "",
      "[Added Lines]",
      "796:     dd_init_next_file(dd);",
      "797:     char *short_name;",
      "798:     while (dd_get_next_file(dd, &short_name, /*full_name*/ NULL))",
      "801:         int fd = secure_openat_read(dd->dd_fd, short_name);",
      "802:         if (fd < 0)",
      "803:             goto next;",
      "805:         if (fchmod(fd, dd->mode) != 0)",
      "806:             perror_msg(\"Can't change '%s/%s' mode to 0%o\", dd->dd_dirname, short_name,",
      "807:                        (unsigned)dd->mode);",
      "809:         if (fchown(fd, dd->dd_uid, dd->dd_gid) != 0)",
      "810:             perror_msg(\"Can't change '%s/%s' ownership to %lu:%lu\", dd->dd_dirname, short_name,",
      "811:                        (long)dd->dd_uid, (long)dd->dd_gid);",
      "813:         close(fd);",
      "814: next:",
      "815:         free(short_name);",
      "819: static int delete_file_dir(int dir_fd, bool skip_lock_file)",
      "821:     int opendir_fd = dup(dir_fd);",
      "822:     if (opendir_fd < 0)",
      "823:     {",
      "824:         perror_msg(\"delete_file_dir: dup(dir_fd)\");",
      "825:         return -1;",
      "826:     }",
      "828:     DIR *d = fdopendir(opendir_fd);",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "818:             unlink_lock_file = true;",
      "819:             continue;",
      "820:         }",
      "823:         {",
      "824:             int err = 0;",
      "825:             if (errno == EISDIR)",
      "826:             {",
      "827:                 errno = 0;",
      "829:             }",
      "830:             if (errno || err)",
      "831:             {",
      "834:                 closedir(d);",
      "835:                 return -1;",
      "836:             }",
      "837:         }",
      "839:     }",
      "",
      "[Removed Lines]",
      "821:         char *full_path = concat_path_file(dir, dent->d_name);",
      "822:         if (unlink(full_path) == -1 && errno != ENOENT)",
      "828:                 err = delete_file_dir(full_path, /*skip_lock_file:*/ false);",
      "832:                 perror_msg(\"Can't remove '%s'\", full_path);",
      "833:                 free(full_path);",
      "838:         free(full_path);",
      "840:     closedir(d);",
      "",
      "[Added Lines]",
      "854:         if (unlinkat(dir_fd, dent->d_name, /*only files*/0) == -1 && errno != ENOENT)",
      "860:                 int subdir_fd = openat(dir_fd, dent->d_name, O_DIRECTORY);",
      "861:                 if (subdir_fd < 0)",
      "862:                 {",
      "863:                     perror_msg(\"Can't open sub-dir'%s'\", dent->d_name);",
      "864:                     closedir(d);",
      "865:                     return -1;",
      "866:                 }",
      "867:                 else",
      "868:                 {",
      "869:                     err = delete_file_dir(subdir_fd, /*skip_lock_file:*/ false);",
      "870:                     close(subdir_fd);",
      "871:                     if (err == 0)",
      "872:                         unlinkat(dir_fd, dent->d_name, AT_REMOVEDIR);",
      "873:                 }",
      "877:                 perror_msg(\"Can't remove '%s'\", dent->d_name);",
      "",
      "---------------",
      "--- Hunk 22 ---",
      "[Context before]",
      "847:     if (unlink_lock_file)",
      "871: }",
      "873: int dd_delete(struct dump_dir *dd)",
      "",
      "[Removed Lines]",
      "848:     {",
      "849:         char *full_path = concat_path_file(dir, \".lock\");",
      "850:         xunlink(full_path);",
      "851:         free(full_path);",
      "853:         unsigned cnt = RMDIR_FAIL_COUNT;",
      "854:         do {",
      "855:             if (rmdir(dir) == 0)",
      "856:                 return 0;",
      "863:             usleep(RMDIR_FAIL_USLEEP);",
      "864:         } while (--cnt != 0);",
      "865:     }",
      "867:     int r = rmdir(dir);",
      "868:     if (r)",
      "869:         perror_msg(\"Can't remove directory '%s'\", dir);",
      "870:     return r;",
      "",
      "[Added Lines]",
      "890:         xunlinkat(dir_fd, \".lock\", /*only files*/0);",
      "892:     return 0;",
      "",
      "---------------",
      "--- Hunk 23 ---",
      "[Context before]",
      "878:         return -1;",
      "879:     }",
      "883:     dd_close(dd);",
      "885: }",
      "887: int dd_chown(struct dump_dir *dd, uid_t new_uid)",
      "",
      "[Removed Lines]",
      "881:     int r = delete_file_dir(dd->dd_dirname, /*skip_lock_file:*/ true);",
      "884:     return r;",
      "",
      "[Added Lines]",
      "903:     if (delete_file_dir(dd->dd_fd, /*skip_lock_file:*/ true) != 0)",
      "904:     {",
      "905:         perror_msg(\"Can't remove contents of directory '%s'\", dd->dd_dirname);",
      "906:         return -2;",
      "907:     }",
      "909:     unsigned cnt = RMDIR_FAIL_COUNT;",
      "910:     do {",
      "911:         if (rmdir(dd->dd_dirname) == 0)",
      "912:             break;",
      "919:         usleep(RMDIR_FAIL_USLEEP);",
      "920:     } while (--cnt != 0);",
      "922:     if (cnt == 0)",
      "923:     {",
      "924:         perror_msg(\"Can't remove directory '%s'\", dd->dd_dirname);",
      "925:         return -3;",
      "926:     }",
      "930:     return 0;",
      "",
      "---------------",
      "--- Hunk 24 ---",
      "[Context before]",
      "911:     gid_t groups_gid = pw->pw_gid;",
      "912: #endif",
      "915:     if (chown_res)",
      "917:     else",
      "918:     {",
      "919:         dd_init_next_file(dd);",
      "922:         {",
      "925:             if (chown_res)",
      "928:         }",
      "929:     }",
      "931:     return chown_res;",
      "932: }",
      "935: {",
      "937:     if (fd == -1)",
      "938:     {",
      "939:         if (!(flags & DD_FAIL_QUIETLY_ENOENT))",
      "",
      "[Removed Lines]",
      "914:     int chown_res = lchown(dd->dd_dirname, owners_uid, groups_gid);",
      "916:         perror_msg(\"lchown('%s')\", dd->dd_dirname);",
      "920:         char *full_name;",
      "921:         while (chown_res == 0 && dd_get_next_file(dd, /*short_name*/ NULL, &full_name))",
      "923:             log_debug(\"chowning %s\", full_name);",
      "924:             chown_res = lchown(full_name, owners_uid, groups_gid);",
      "926:                 perror_msg(\"lchown('%s')\", full_name);",
      "927:             free(full_name);",
      "934: static char *load_text_file(const char *path, unsigned flags)",
      "936:     int fd = open(path, O_RDONLY | ((flags & DD_OPEN_FOLLOW) ? 0 : O_NOFOLLOW));",
      "",
      "[Added Lines]",
      "960:     int chown_res = fchown(dd->dd_fd, owners_uid, groups_gid);",
      "962:         perror_msg(\"fchown('%s')\", dd->dd_dirname);",
      "966:         char *short_name;",
      "967:         while (chown_res == 0 && dd_get_next_file(dd, &short_name, /*full_name*/ NULL))",
      "970:             int fd = secure_openat_read(dd->dd_fd, short_name);",
      "971:             if (fd < 0)",
      "972:                 goto next;",
      "974:             log_debug(\"chowning %s\", short_name);",
      "976:             chown_res = fchown(fd, owners_uid, groups_gid);",
      "978:                 perror_msg(\"fchownat('%s')\", short_name);",
      "980:             close(fd);",
      "981: next:",
      "982:             free(short_name);",
      "989: static char *load_text_from_file_descriptor(int fd, const char *path, int flags)",
      "",
      "---------------",
      "--- Hunk 25 ---",
      "[Context before]",
      "988:     return strbuf_free_nobuf(buf_content);",
      "989: }",
      "991: static void copy_file_from_chroot(struct dump_dir* dd, const char *name, const char *chroot_dir, const char *file_path)",
      "992: {",
      "993:     char *chrooted_name = concat_path_file(chroot_dir, file_path);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1045: static char *load_text_file_at(int dir_fd, const char *name, unsigned flags)",
      "1046: {",
      "1047:     assert(name[0] != '/');",
      "1049:     const int fd = openat(dir_fd, name, O_RDONLY | ((flags & DD_OPEN_FOLLOW) ? 0 : O_NOFOLLOW));",
      "1050:     return load_text_from_file_descriptor(fd, name, flags);",
      "1051: }",
      "1053: static char *load_text_file(const char *path, unsigned flags)",
      "1054: {",
      "1055:     const int fd = open(path, O_RDONLY | ((flags & DD_OPEN_FOLLOW) ? 0 : O_NOFOLLOW));",
      "1056:     return load_text_from_file_descriptor(fd, path, flags);",
      "1057: }",
      "",
      "---------------",
      "--- Hunk 26 ---",
      "[Context before]",
      "1001:     }",
      "1002: }",
      "1005: {",
      "1009:     if (fd < 0)",
      "1010:     {",
      "1012:         return false;",
      "1013:     }",
      "",
      "[Removed Lines]",
      "1004: static bool save_binary_file(const char *path, const char* data, unsigned size, uid_t uid, gid_t gid, mode_t mode)",
      "1007:     unlink(path);",
      "1008:     int fd = open(path, O_WRONLY | O_TRUNC | O_CREAT | O_NOFOLLOW, mode);",
      "1011:         perror_msg(\"Can't open file '%s'\", path);",
      "",
      "[Added Lines]",
      "1072: static bool save_binary_file_at(int dir_fd, const char *name, const char* data, unsigned size, uid_t uid, gid_t gid, mode_t mode)",
      "1074:     assert(name[0] != '/');",
      "1077:     unlinkat(dir_fd, name, /*remove only files*/0);",
      "1078:     int fd = openat(dir_fd, name, O_WRONLY | O_EXCL | O_CREAT | O_NOFOLLOW, mode);",
      "1081:         perror_msg(\"Can't open file '%s'\", name);",
      "",
      "---------------",
      "--- Hunk 27 ---",
      "[Context before]",
      "1016:     {",
      "1017:         if (fchown(fd, uid, gid) == -1)",
      "1018:         {",
      "1020:         }",
      "1021:     }",
      "",
      "[Removed Lines]",
      "1019:             perror_msg(\"Can't change '%s' ownership to %lu:%lu\", path, (long)uid, (long)gid);",
      "",
      "[Added Lines]",
      "1089:             perror_msg(\"Can't change '%s' ownership to %lu:%lu\", name, (long)uid, (long)gid);",
      "1090:             close(fd);",
      "1091:             return false;",
      "",
      "---------------",
      "--- Hunk 28 ---",
      "[Context before]",
      "1029:     if (fchmod(fd, mode) == -1)",
      "1030:     {",
      "1032:     }",
      "1034:     unsigned r = full_write(fd, data, size);",
      "1035:     close(fd);",
      "1036:     if (r != size)",
      "1037:     {",
      "1039:         return false;",
      "1040:     }",
      "",
      "[Removed Lines]",
      "1031:         perror_msg(\"Can't change mode of '%s'\", path);",
      "1038:         error_msg(\"Can't save file '%s'\", path);",
      "",
      "[Added Lines]",
      "1103:         perror_msg(\"Can't change mode of '%s'\", name);",
      "1104:         close(fd);",
      "1105:         return false;",
      "1112:         error_msg(\"Can't save file '%s'\", name);",
      "",
      "---------------",
      "--- Hunk 29 ---",
      "[Context before]",
      "1058:     if (strcmp(name, \"release\") == 0)",
      "1059:         name = FILENAME_OS_RELEASE;",
      "1066: }",
      "1068: char* dd_load_text(const struct dump_dir *dd, const char *name)",
      "",
      "[Removed Lines]",
      "1061:     char *full_path = concat_path_file(dd->dd_dirname, name);",
      "1062:     char *ret = load_text_file(full_path, flags);",
      "1063:     free(full_path);",
      "1065:     return ret;",
      "",
      "[Added Lines]",
      "1135:     return load_text_file_at(dd->dd_fd, name, flags);",
      "",
      "---------------",
      "--- Hunk 30 ---",
      "[Context before]",
      "1078:     if (!str_is_correct_filename(name))",
      "1079:         error_msg_and_die(\"Cannot save text. '%s' is not a valid file name\", name);",
      "1084: }",
      "1086: void dd_save_binary(struct dump_dir* dd, const char* name, const char* data, unsigned size)",
      "",
      "[Removed Lines]",
      "1081:     char *full_path = concat_path_file(dd->dd_dirname, name);",
      "1082:     save_binary_file(full_path, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);",
      "1083:     free(full_path);",
      "",
      "[Added Lines]",
      "1151:     save_binary_file_at(dd->dd_fd, name, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);",
      "",
      "---------------",
      "--- Hunk 31 ---",
      "[Context before]",
      "1091:     if (!str_is_correct_filename(name))",
      "1092:         error_msg_and_die(\"Cannot save binary. '%s' is not a valid file name\", name);",
      "1097: }",
      "1099: long dd_get_item_size(struct dump_dir *dd, const char *name)",
      "",
      "[Removed Lines]",
      "1094:     char *full_path = concat_path_file(dd->dd_dirname, name);",
      "1095:     save_binary_file(full_path, data, size, dd->dd_uid, dd->dd_gid, dd->mode);",
      "1096:     free(full_path);",
      "",
      "[Added Lines]",
      "1162:     save_binary_file_at(dd->dd_fd, name, data, size, dd->dd_uid, dd->dd_gid, dd->mode);",
      "",
      "---------------",
      "--- Hunk 32 ---",
      "[Context before]",
      "1102:         error_msg_and_die(\"Cannot get item size. '%s' is not a valid file name\", name);",
      "1104:     long size = -1;",
      "1106:     struct stat statbuf;",
      "1109:         size = statbuf.st_size;",
      "1110:     else",
      "1111:     {",
      "1112:         if (errno == ENOENT)",
      "1113:             size = 0;",
      "1114:         else",
      "1116:     }",
      "1120:     return size;",
      "1121: }",
      "",
      "[Removed Lines]",
      "1105:     char *iname = concat_path_file(dd->dd_dirname, name);",
      "1108:     if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))",
      "1115:             perror_msg(\"Can't get size of file '%s'\", iname);",
      "1118:     free(iname);",
      "",
      "[Added Lines]",
      "1172:     int r = fstatat(dd->dd_fd, name, &statbuf, AT_SYMLINK_NOFOLLOW);",
      "1174:     if (r == 0 && S_ISREG(statbuf.st_mode))",
      "1181:             perror_msg(\"Can't get size of file '%s'\", name);",
      "",
      "---------------",
      "--- Hunk 33 ---",
      "[Context before]",
      "1128:     if (!str_is_correct_filename(name))",
      "1129:         error_msg_and_die(\"Cannot delete item. '%s' is not a valid file name\", name);",
      "1134:     if (res < 0)",
      "1135:     {",
      "1136:         if (errno == ENOENT)",
      "1137:             errno = res = 0;",
      "1138:         else",
      "1140:     }",
      "1143:     return res;",
      "1144: }",
      "",
      "[Removed Lines]",
      "1131:     char *path = concat_path_file(dd->dd_dirname, name);",
      "1132:     int res = unlink(path);",
      "1139:             perror_msg(\"Can't delete file '%s'\", path);",
      "1142:     free(path);",
      "",
      "[Added Lines]",
      "1195:     int res = unlinkat(dd->dd_fd, name, /*only files*/0);",
      "1202:             perror_msg(\"Can't delete file '%s'\", name);",
      "",
      "---------------",
      "--- Hunk 34 ---",
      "[Context before]",
      "1147: {",
      "1151:     if (dd->next_dir)",
      "1152:         closedir(dd->next_dir);",
      "1155:     if (!dd->next_dir)",
      "1156:     {",
      "1157:         error_msg(\"Can't open directory '%s'\", dd->dd_dirname);",
      "",
      "[Removed Lines]",
      "1154:     dd->next_dir = opendir(dd->dd_dirname);",
      "",
      "[Added Lines]",
      "1212:     int opendir_fd = dup(dd->dd_fd);",
      "1213:     if (opendir_fd < 0)",
      "1214:     {",
      "1215:         perror_msg(\"dd_init_next_file: dup(dd_fd)\");",
      "1216:         return NULL;",
      "1217:     }",
      "1222:     dd->next_dir = fdopendir(opendir_fd);",
      "",
      "---------------",
      "--- Hunk 35 ---",
      "[Context before]",
      "1168:     struct dirent *dent;",
      "1169:     while ((dent = readdir(dd->next_dir)) != NULL)",
      "1170:     {",
      "1172:         {",
      "1173:             if (short_name)",
      "",
      "[Removed Lines]",
      "1171:         if (is_regular_file(dent, dd->dd_dirname))",
      "",
      "[Added Lines]",
      "1239:         if (is_regular_file_at(dent, dd->dd_fd))",
      "",
      "---------------"
    ],
    "src/lib/problem_data.c||src/lib/problem_data.c": [
      "File: src/lib/problem_data.c -> src/lib/problem_data.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "279:     FILENAME_OS_RELEASE,",
      "280:     NULL",
      "281: };",
      "283: {",
      "290:     if (fd < 0)",
      "",
      "[Removed Lines]",
      "282: static char* is_text_file(const char *name, ssize_t *sz)",
      "289:     int fd = open(name, O_RDONLY);",
      "",
      "[Added Lines]",
      "282: static char* is_text_file_at(int dir_fd, const char *name, ssize_t *sz)",
      "289:     int fd = secure_openat_read(dir_fd, name);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "399:         }",
      "401:         ssize_t sz = 4*1024;",
      "403:         if (!text || text == HUGE_TEXT)",
      "404:         {",
      "405:             int flag = !text ? CD_FLAG_BIN : (CD_FLAG_BIN+CD_FLAG_BIGTXT);",
      "",
      "[Removed Lines]",
      "402:         char *text = is_text_file(full_name, &sz);",
      "",
      "[Added Lines]",
      "402:         char *text = is_text_file_at(dd->dd_fd, short_name, &sz);",
      "",
      "---------------"
    ],
    "src/lib/xfuncs.c||src/lib/xfuncs.c": [
      "File: src/lib/xfuncs.c -> src/lib/xfuncs.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "331:     return xopen3(pathname, flags, 0666);",
      "332: }",
      "334: void xunlink(const char *pathname)",
      "335: {",
      "336:     if (unlink(pathname))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "334: void xunlinkat(int dir_fd, const char *pathname, int flags)",
      "335: {",
      "336:     if (unlinkat(dir_fd, pathname, flags))",
      "337:         perror_msg_and_die(\"Can't remove file '%s'\", pathname);",
      "338: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "363: {",
      "364:     if (dent->d_type == DT_REG)",
      "365:         return 1;",
      "366:     if (dent->d_type != DT_UNKNOWN)",
      "367:         return 0;",
      "370:     struct stat statbuf;",
      "374:     return r == 0 && S_ISREG(statbuf.st_mode);",
      "375: }",
      "379: bool dot_or_dotdot(const char *filename)",
      "",
      "[Removed Lines]",
      "362: int is_regular_file(struct dirent *dent, const char *dirname)",
      "369:     char *fullname = xasprintf(\"%s/%s\", dirname, dent->d_name);",
      "371:     int r = lstat(fullname, &statbuf);",
      "372:     free(fullname);",
      "",
      "[Added Lines]",
      "368: int is_regular_file_at(struct dirent *dent, int dir_fd)",
      "376:     int r = fstatat(dir_fd, dent->d_name, &statbuf, AT_SYMLINK_NOFOLLOW);",
      "381: int is_regular_file(struct dirent *dent, const char *dirname)",
      "382: {",
      "383:     int dir_fd = open(dirname, O_DIRECTORY);",
      "384:     if (dir_fd < 0)",
      "385:         return 0;",
      "386:     int r = is_regular_file_at(dent, dir_fd);",
      "387:     close(dir_fd);",
      "388:     return r;",
      "389: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1951e7282043dfe1268d492aea056b554baedb75",
      "candidate_info": {
        "commit_hash": "1951e7282043dfe1268d492aea056b554baedb75",
        "repo": "abrt/libreport",
        "commit_url": "https://github.com/abrt/libreport/commit/1951e7282043dfe1268d492aea056b554baedb75",
        "files": [
          "src/include/dump_dir.h",
          "src/include/internal_libreport.h",
          "src/lib/dump_dir.c",
          "src/lib/problem_data.c",
          "src/lib/xfuncs.c"
        ],
        "message": "lib: fix races in dump directory handling code\n\nFlorian Weimer <fweimer@redhat.com>:\n\n    dd_opendir() should keep a file handle (opened with O_DIRECTORY) and\n    use openat() and similar functions to access files in it.\n\n    ...\n\n    The file system manipulation functions should guard against hard\n    links (check that link count is <= 1, just as in the user coredump\n    code in abrt-hook-ccpp), possibly after opening the file\n    with O_PATH first to avoid side effects on open/close.\n\nRelated: #1214745\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "src/include/dump_dir.h||src/include/dump_dir.h",
          "src/include/internal_libreport.h||src/include/internal_libreport.h",
          "src/lib/dump_dir.c||src/lib/dump_dir.c",
          "src/lib/problem_data.c||src/lib/problem_data.c",
          "src/lib/xfuncs.c||src/lib/xfuncs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/include/dump_dir.h||src/include/dump_dir.h",
            "src/include/internal_libreport.h||src/include/internal_libreport.h",
            "src/lib/dump_dir.c||src/lib/dump_dir.c",
            "src/lib/problem_data.c||src/lib/problem_data.c",
            "src/lib/xfuncs.c||src/lib/xfuncs.c"
          ],
          "candidate": [
            "src/include/dump_dir.h||src/include/dump_dir.h",
            "src/include/internal_libreport.h||src/include/internal_libreport.h",
            "src/lib/dump_dir.c||src/lib/dump_dir.c",
            "src/lib/problem_data.c||src/lib/problem_data.c",
            "src/lib/xfuncs.c||src/lib/xfuncs.c"
          ]
        }
      },
      "candidate_diff": {
        "src/include/dump_dir.h||src/include/dump_dir.h": [
          "File: src/include/dump_dir.h -> src/include/dump_dir.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: int create_symlink_lockfile(const char *filename, const char *pid_str);",
          "38: enum {",
          "39:     DD_FAIL_QUIETLY_ENOENT = (1 << 0),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "37: int create_symlink_lockfile_at(int dir_fd, const char *filename, const char *pid_str);",
          "42: int secure_openat_read(int dir_fd, const char *filename);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "57:     mode_t mode;",
          "58:     time_t dd_time;",
          "59:     char *dd_type;",
          "60: };",
          "62: void dd_close(struct dump_dir *dd);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66:     int dd_fd;",
          "",
          "---------------"
        ],
        "src/include/internal_libreport.h||src/include/internal_libreport.h": [
          "File: src/include/internal_libreport.h -> src/include/internal_libreport.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "406: int xopen(const char *pathname, int flags);",
          "407: #define xunlink libreport_xunlink",
          "408: void xunlink(const char *pathname);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "409: #define xunlinkat libreport_xunlinkat",
          "410: void xunlinkat(int dir_fd, const char *pathname, int flags);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "416: #define is_regular_file libreport_is_regular_file",
          "417: int is_regular_file(struct dirent *dent, const char *dirname);",
          "419: #define dot_or_dotdot libreport_dot_or_dotdot",
          "420: bool dot_or_dotdot(const char *filename);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "420: #define is_regular_file_at libreport_is_regular_file_at",
          "421: int is_regular_file_at(struct dirent *dent, int dir_fd);",
          "",
          "---------------"
        ],
        "src/lib/dump_dir.c||src/lib/dump_dir.c": [
          "File: src/lib/dump_dir.c -> src/lib/dump_dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "87: static char *load_text_file(const char *path, unsigned flags);",
          "88: static void copy_file_from_chroot(struct dump_dir* dd, const char *name,",
          "89:         const char *chroot_dir, const char *file_path);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "88: static char *load_text_file_at(int dir_fd, const char *name, unsigned flags);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "98:     return true;",
          "99: }",
          "102: {",
          "103:     struct stat buf;",
          "105:     {",
          "106:         if (S_ISDIR(buf.st_mode) || S_ISREG(buf.st_mode))",
          "107:         {",
          "",
          "[Removed Lines]",
          "101: static bool exist_file_dir(const char *path)",
          "104:     if (stat(path, &buf) == 0)",
          "",
          "[Added Lines]",
          "102: static bool exist_file_dir_at(int dir_fd, const char *name)",
          "105:     if (fstatat(dir_fd, name, &buf, AT_SYMLINK_NOFOLLOW) == 0)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "111:     return false;",
          "112: }",
          "120: {",
          "123:     if (fd < 0)",
          "124:     {",
          "125:         VERB2 pwarn_msg(\"Can't open '%s'\", filename);",
          "",
          "[Removed Lines]",
          "119: static time_t parse_time_file(const char *filename)",
          "122:     int fd = open(filename, O_RDONLY | O_NOFOLLOW);",
          "",
          "[Added Lines]",
          "125: int secure_openat_read(int dir_fd, const char *pathname)",
          "126: {",
          "127:     static char reopen_buf[sizeof(\"/proc/self/fd/\") + 3*sizeof(int) + 1];",
          "129:     int path_fd = openat(dir_fd, pathname, O_PATH | O_NOFOLLOW);",
          "130:     if (path_fd < 0)",
          "131:         return -1;",
          "133:     struct stat path_sb;",
          "134:     int r = fstat(path_fd, &path_sb);",
          "135:     if (r < 0)",
          "136:     {",
          "137:         perror_msg(\"stat\");",
          "138:         close(path_fd);",
          "139:         return -1;",
          "140:     }",
          "142:     if (!S_ISREG(path_sb.st_mode) || path_sb.st_nlink > 1)",
          "143:     {",
          "144:         log_notice(\"Path isn't a regular file or has more links (%lu)\", path_sb.st_nlink);",
          "145:         errno = EINVAL;",
          "146:         close(path_fd);",
          "147:         return -1;",
          "148:     }",
          "150:     if (snprintf(reopen_buf, sizeof(reopen_buf), \"/proc/self/fd/%d\", path_fd) >= sizeof(reopen_buf)) {",
          "151:         error_msg(\"BUG: too long path to a file descriptor\");",
          "152:         abort();",
          "153:     }",
          "155:     const int fd = open(reopen_buf, O_RDONLY);",
          "156:     close(path_fd);",
          "158:     return fd;",
          "159: }",
          "166: static time_t parse_time_file_at(int dir_fd, const char *filename)",
          "169:     int fd = secure_openat_read(dir_fd, filename);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "187: {",
          "189:     {",
          "190:         if (errno != EEXIST)",
          "191:         {",
          "",
          "[Removed Lines]",
          "186: int create_symlink_lockfile(const char* lock_file, const char* pid)",
          "188:     while (symlink(pid, lock_file) != 0)",
          "",
          "[Added Lines]",
          "233: int create_symlink_lockfile_at(int dir_fd, const char* lock_file, const char* pid)",
          "235:     while (symlinkat(pid, dir_fd, lock_file) != 0)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "198:         }",
          "200:         char pid_buf[sizeof(pid_t)*3 + 4];",
          "202:         if (r < 0)",
          "203:         {",
          "204:             if (errno == ENOENT)",
          "",
          "[Removed Lines]",
          "201:         ssize_t r = readlink(lock_file, pid_buf, sizeof(pid_buf) - 1);",
          "",
          "[Added Lines]",
          "248:         ssize_t r = readlinkat(dir_fd, lock_file, pid_buf, sizeof(pid_buf) - 1);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "230:             log(\"Lock file '%s' was locked by process %s, but it crashed?\", lock_file, pid_buf);",
          "231:         }",
          "234:         {",
          "235:             perror_msg(\"Can't remove stale lock file '%s'\", lock_file);",
          "236:             errno = 0;",
          "",
          "[Removed Lines]",
          "233:         if (unlink(lock_file) != 0 && errno != ENOENT)",
          "",
          "[Added Lines]",
          "280:         if (unlinkat(dir_fd, lock_file, /*only files*/0) != 0 && errno != ENOENT)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "242:     return 1;",
          "243: }",
          "245: static const char *dd_check(struct dump_dir *dd)",
          "246: {",
          "252:     if (dd->dd_time < 0)",
          "253:     {",
          "254:         log_warning(\"Missing file: \"FILENAME_TIME);",
          "255:         return FILENAME_TIME;",
          "256:     }",
          "260:     if (!dd->dd_type || (strlen(dd->dd_type) == 0))",
          "261:     {",
          "262:         log_warning(\"Missing or empty file: \"FILENAME_TYPE);",
          "",
          "[Removed Lines]",
          "247:     unsigned dirname_len = strlen(dd->dd_dirname);",
          "248:     char filename_buf[FILENAME_MAX+1];",
          "249:     strcpy(filename_buf, dd->dd_dirname);",
          "250:     strcpy(filename_buf + dirname_len, \"/\"FILENAME_TIME);",
          "251:     dd->dd_time = parse_time_file(filename_buf);",
          "258:     strcpy(filename_buf + dirname_len, \"/\"FILENAME_TYPE);",
          "259:     dd->dd_type = load_text_file(filename_buf, DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE);",
          "",
          "[Added Lines]",
          "292: int create_symlink_lockfile(const char *filename, const char *pid_str)",
          "293: {",
          "294:     return create_symlink_lockfile_at(AT_FDCWD, filename, pid_str);",
          "295: }",
          "299:     dd->dd_time = parse_time_file_at(dd->dd_fd, FILENAME_TIME);",
          "306:     dd->dd_type = load_text_file_at(dd->dd_fd, FILENAME_TYPE, DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "274:     char pid_buf[sizeof(long)*3 + 2];",
          "275:     snprintf(pid_buf, sizeof(pid_buf), \"%lu\", (long)getpid());",
          "282:     unsigned count = NO_TIME_FILE_COUNT;",
          "284:  retry:",
          "285:     while (1)",
          "286:     {",
          "288:         if (r < 0)",
          "290:         if (r > 0)",
          "",
          "[Removed Lines]",
          "277:     unsigned dirname_len = strlen(dd->dd_dirname);",
          "278:     char lock_buf[dirname_len + sizeof(\"/.lock\")];",
          "279:     strcpy(lock_buf, dd->dd_dirname);",
          "280:     strcpy(lock_buf + dirname_len, \"/.lock\");",
          "287:         int r = create_symlink_lockfile(lock_buf, pid_buf);",
          "",
          "[Added Lines]",
          "329:         int r = create_symlink_lockfile_at(dd->dd_fd, \".lock\", pid_buf);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "305:         if (missing_file)",
          "306:         {",
          "309:             if (--count == 0 || flags & DD_DONT_WAIT_FOR_LOCK)",
          "310:             {",
          "",
          "[Removed Lines]",
          "307:             xunlink(lock_buf);",
          "308:             log_warning(\"Unlocked '%s' (no or corrupted '%s' file)\", lock_buf, missing_file);",
          "",
          "[Added Lines]",
          "349:             xunlinkat(dd->dd_fd, \".lock\", /*only files*/0);",
          "350:             log_warning(\"Unlocked '%s' (no or corrupted '%s' file)\", dd->dd_dirname, missing_file);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "326:     {",
          "327:         dd->locked = 0;",
          "336:     }",
          "337: }",
          "",
          "[Removed Lines]",
          "329:         unsigned dirname_len = strlen(dd->dd_dirname);",
          "330:         char lock_buf[dirname_len + sizeof(\"/.lock\")];",
          "331:         strcpy(lock_buf, dd->dd_dirname);",
          "332:         strcpy(lock_buf + dirname_len, \"/.lock\");",
          "333:         xunlink(lock_buf);",
          "335:         log_info(\"Unlocked '%s'\", lock_buf);",
          "",
          "[Added Lines]",
          "371:         xunlinkat(dd->dd_fd, \".lock\", /*only files*/0);",
          "373:         log_info(\"Unlocked '%s/.lock'\", dd->dd_dirname);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "340: {",
          "341:     struct dump_dir* dd = (struct dump_dir*)xzalloc(sizeof(struct dump_dir));",
          "342:     dd->dd_time = -1;",
          "343:     return dd;",
          "344: }",
          "347: {",
          "354:     return ret;",
          "355: }",
          "",
          "[Removed Lines]",
          "346: int dd_exist(const struct dump_dir *dd, const char *path)",
          "348:     if (!str_is_correct_filename(path))",
          "349:         error_msg_and_die(\"Cannot test existence. '%s' is not a valid file name\", path);",
          "351:     char *full_path = concat_path_file(dd->dd_dirname, path);",
          "352:     int ret = exist_file_dir(full_path);",
          "353:     free(full_path);",
          "",
          "[Added Lines]",
          "381:     dd->dd_fd = -1;",
          "385: int dd_exist(const struct dump_dir *dd, const char *name)",
          "387:     if (!str_is_correct_filename(name))",
          "388:         error_msg_and_die(\"Cannot test existence. '%s' is not a valid file name\", name);",
          "390:     const int ret = exist_file_dir_at(dd->dd_fd, name);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "360:         return;",
          "362:     dd_unlock(dd);",
          "363:     if (dd->next_dir)",
          "364:     {",
          "365:         closedir(dd->next_dir);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "400:     close(dd->dd_fd);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "384:     struct dump_dir *dd = dd_init();",
          "386:     dir = dd->dd_dirname = rm_trailing_slashes(dir);",
          "388:     struct stat stat_buf;",
          "390:         goto cant_access;",
          "392:     dd->mode = (stat_buf.st_mode & 0666);",
          "",
          "[Removed Lines]",
          "389:     if (stat(dir, &stat_buf) != 0)",
          "",
          "[Added Lines]",
          "425:     dd->dd_fd = open(dir, O_DIRECTORY | O_NOFOLLOW);",
          "427:     if (dd->dd_fd < 0)",
          "429:     if (fstat(dd->dd_fd, &stat_buf) != 0)",
          "430:         goto cant_access;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "397:         if ((flags & DD_OPEN_READONLY) && errno == EACCES)",
          "398:         {",
          "405:                 if(dd_check(dd) != NULL)",
          "406:                 {",
          "407:                     dd_close(dd);",
          "",
          "[Removed Lines]",
          "401:             if (stat(dir, &stat_buf) == 0",
          "402:              && S_ISDIR(stat_buf.st_mode)",
          "403:              && access(dir, R_OK) == 0",
          "404:             ) {",
          "",
          "[Added Lines]",
          "445:             if (faccessat(dd->dd_fd, \".\", R_OK, AT_SYMLINK_NOFOLLOW) == 0)",
          "446:             {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "444:     if (geteuid() == 0)",
          "445:     {",
          "449:         {",
          "451:             dd_close(dd);",
          "452:             return NULL;",
          "453:         }",
          "",
          "[Removed Lines]",
          "447:         struct stat stat_buf;",
          "448:         if (stat(dir, &stat_buf) != 0 || !S_ISDIR(stat_buf.st_mode))",
          "450:             error_msg(\"Can't stat '%s', or it is not a directory\", dir);",
          "",
          "[Added Lines]",
          "489:         if (fstat(dd->dd_fd, &stat_buf) != 0)",
          "491:             error_msg(\"Can't stat '%s'\", dir);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "544:         error_msg(\"Bad dir name '%s'\", dir);",
          "547:     }",
          "",
          "[Removed Lines]",
          "545:         dd_close(dd);",
          "546:         return NULL;",
          "",
          "[Added Lines]",
          "586:         goto fail;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "559:     if (r != 0)",
          "560:     {",
          "561:         perror_msg(\"Can't create directory '%s'\", dir);",
          "564:     }",
          "567:     {",
          "570:     }",
          "574:     {",
          "575:         perror_msg(\"Can't change mode of '%s'\", dir);",
          "578:     }",
          "580:     dd->dd_uid = (uid_t)-1L;",
          "",
          "[Removed Lines]",
          "562:         dd_close(dd);",
          "563:         return NULL;",
          "566:     if (dd_lock(dd, CREATE_LOCK_USLEEP, /*flags:*/ 0) < 0)",
          "568:         dd_close(dd);",
          "569:         return NULL;",
          "573:     if (chmod(dir, dir_mode) == -1)",
          "576:         dd_close(dd);",
          "577:         return NULL;",
          "",
          "[Added Lines]",
          "602:         goto fail;",
          "605:     dd->dd_fd = open(dd->dd_dirname, O_DIRECTORY | O_NOFOLLOW);",
          "606:     if (dd->dd_fd < 0)",
          "608:         perror_msg(\"Can't open newly created directory '%s'\", dir);",
          "609:         goto fail;",
          "612:     struct stat stat_sb;",
          "613:     if (fstat(dd->dd_fd, &stat_sb) < 0)",
          "614:     {",
          "615:         perror_msg(\"stat(%s)\", dd->dd_dirname);",
          "616:         goto fail;",
          "617:     }",
          "619:     if (dd_lock(dd, CREATE_LOCK_USLEEP, /*flags:*/ 0) < 0)",
          "620:         goto fail;",
          "623:     if (fchmod(dd->dd_fd, dir_mode) == -1)",
          "626:         goto fail;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "616:     }",
          "618:     return dd;",
          "619: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "669: fail:",
          "670:     dd_close(dd);",
          "671:     return NULL;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "624: int dd_reset_ownership(struct dump_dir *dd)",
          "625: {",
          "627:     if (r < 0)",
          "628:     {",
          "629:         perror_msg(\"Can't change '%s' ownership to %lu:%lu\", dd->dd_dirname,",
          "",
          "[Removed Lines]",
          "626:     const int r =lchown(dd->dd_dirname, dd->dd_uid, dd->dd_gid);",
          "",
          "[Added Lines]",
          "679:     const int r = fchown(dd->dd_fd, dd->dd_uid, dd->dd_gid);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "740:     if (!dd->locked)",
          "749:     {",
          "789:     }",
          "791: }",
          "794: {",
          "796:     if (!d)",
          "797:     {",
          "",
          "[Removed Lines]",
          "743:     DIR *d = opendir(dd->dd_dirname);",
          "744:     if (!d)",
          "745:         return;",
          "747:     struct dirent *dent;",
          "748:     while ((dent = readdir(d)) != NULL)",
          "751:             continue;",
          "752:         char *full_path = concat_path_file(dd->dd_dirname, dent->d_name);",
          "753:         struct stat statbuf;",
          "754:         if (lstat(full_path, &statbuf) == 0 && S_ISREG(statbuf.st_mode))",
          "755:         {",
          "756:             if ((statbuf.st_mode & 0777) != dd->mode)",
          "757:             {",
          "764:                 int fd = open(full_path, O_RDONLY | O_NOFOLLOW, dd->mode);",
          "765:                 if (fd >= 0)",
          "766:                 {",
          "767:                     if (fchmod(fd, dd->mode) != 0)",
          "768:                     {",
          "769:                         perror_msg(\"Can't change '%s' mode to 0%o\", full_path,",
          "770:                                    (unsigned)dd->mode);",
          "771:                     }",
          "772:                     close(fd);",
          "773:                 }",
          "774:                 else",
          "775:                 {",
          "776:                     perror_msg(\"Can't open regular file '%s'\", full_path);",
          "777:                 }",
          "778:             }",
          "779:             if (statbuf.st_uid != dd->dd_uid || statbuf.st_gid != dd->dd_gid)",
          "780:             {",
          "781:                 if (lchown(full_path, dd->dd_uid, dd->dd_gid) != 0)",
          "782:                 {",
          "783:                     perror_msg(\"Can't change '%s' ownership to %lu:%lu\", full_path,",
          "784:                                (long)dd->dd_uid, (long)dd->dd_gid);",
          "785:                 }",
          "786:             }",
          "787:         }",
          "788:         free(full_path);",
          "790:     closedir(d);",
          "793: static int delete_file_dir(const char *dir, bool skip_lock_file)",
          "795:     DIR *d = opendir(dir);",
          "",
          "[Added Lines]",
          "796:     dd_init_next_file(dd);",
          "797:     char *short_name;",
          "798:     while (dd_get_next_file(dd, &short_name, /*full_name*/ NULL))",
          "801:         int fd = secure_openat_read(dd->dd_fd, short_name);",
          "802:         if (fd < 0)",
          "803:             goto next;",
          "805:         if (fchmod(fd, dd->mode) != 0)",
          "806:             perror_msg(\"Can't change '%s/%s' mode to 0%o\", dd->dd_dirname, short_name,",
          "807:                        (unsigned)dd->mode);",
          "809:         if (fchown(fd, dd->dd_uid, dd->dd_gid) != 0)",
          "810:             perror_msg(\"Can't change '%s/%s' ownership to %lu:%lu\", dd->dd_dirname, short_name,",
          "811:                        (long)dd->dd_uid, (long)dd->dd_gid);",
          "813:         close(fd);",
          "814: next:",
          "815:         free(short_name);",
          "819: static int delete_file_dir(int dir_fd, bool skip_lock_file)",
          "821:     int opendir_fd = dup(dir_fd);",
          "822:     if (opendir_fd < 0)",
          "823:     {",
          "824:         perror_msg(\"delete_file_dir: dup(dir_fd)\");",
          "825:         return -1;",
          "826:     }",
          "828:     DIR *d = fdopendir(opendir_fd);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "818:             unlink_lock_file = true;",
          "819:             continue;",
          "820:         }",
          "823:         {",
          "824:             int err = 0;",
          "825:             if (errno == EISDIR)",
          "826:             {",
          "827:                 errno = 0;",
          "829:             }",
          "830:             if (errno || err)",
          "831:             {",
          "834:                 closedir(d);",
          "835:                 return -1;",
          "836:             }",
          "837:         }",
          "839:     }",
          "",
          "[Removed Lines]",
          "821:         char *full_path = concat_path_file(dir, dent->d_name);",
          "822:         if (unlink(full_path) == -1 && errno != ENOENT)",
          "828:                 err = delete_file_dir(full_path, /*skip_lock_file:*/ false);",
          "832:                 perror_msg(\"Can't remove '%s'\", full_path);",
          "833:                 free(full_path);",
          "838:         free(full_path);",
          "840:     closedir(d);",
          "",
          "[Added Lines]",
          "854:         if (unlinkat(dir_fd, dent->d_name, /*only files*/0) == -1 && errno != ENOENT)",
          "860:                 int subdir_fd = openat(dir_fd, dent->d_name, O_DIRECTORY);",
          "861:                 if (subdir_fd < 0)",
          "862:                 {",
          "863:                     perror_msg(\"Can't open sub-dir'%s'\", dent->d_name);",
          "864:                     closedir(d);",
          "865:                     return -1;",
          "866:                 }",
          "867:                 else",
          "868:                 {",
          "869:                     err = delete_file_dir(subdir_fd, /*skip_lock_file:*/ false);",
          "870:                     close(subdir_fd);",
          "871:                     if (err == 0)",
          "872:                         unlinkat(dir_fd, dent->d_name, AT_REMOVEDIR);",
          "873:                 }",
          "877:                 perror_msg(\"Can't remove '%s'\", dent->d_name);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "847:     if (unlink_lock_file)",
          "871: }",
          "873: int dd_delete(struct dump_dir *dd)",
          "",
          "[Removed Lines]",
          "848:     {",
          "849:         char *full_path = concat_path_file(dir, \".lock\");",
          "850:         xunlink(full_path);",
          "851:         free(full_path);",
          "853:         unsigned cnt = RMDIR_FAIL_COUNT;",
          "854:         do {",
          "855:             if (rmdir(dir) == 0)",
          "856:                 return 0;",
          "863:             usleep(RMDIR_FAIL_USLEEP);",
          "864:         } while (--cnt != 0);",
          "865:     }",
          "867:     int r = rmdir(dir);",
          "868:     if (r)",
          "869:         perror_msg(\"Can't remove directory '%s'\", dir);",
          "870:     return r;",
          "",
          "[Added Lines]",
          "890:         xunlinkat(dir_fd, \".lock\", /*only files*/0);",
          "892:     return 0;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "878:         return -1;",
          "879:     }",
          "883:     dd_close(dd);",
          "885: }",
          "887: int dd_chown(struct dump_dir *dd, uid_t new_uid)",
          "",
          "[Removed Lines]",
          "881:     int r = delete_file_dir(dd->dd_dirname, /*skip_lock_file:*/ true);",
          "884:     return r;",
          "",
          "[Added Lines]",
          "903:     if (delete_file_dir(dd->dd_fd, /*skip_lock_file:*/ true) != 0)",
          "904:     {",
          "905:         perror_msg(\"Can't remove contents of directory '%s'\", dd->dd_dirname);",
          "906:         return -2;",
          "907:     }",
          "909:     unsigned cnt = RMDIR_FAIL_COUNT;",
          "910:     do {",
          "911:         if (rmdir(dd->dd_dirname) == 0)",
          "912:             break;",
          "919:         usleep(RMDIR_FAIL_USLEEP);",
          "920:     } while (--cnt != 0);",
          "922:     if (cnt == 0)",
          "923:     {",
          "924:         perror_msg(\"Can't remove directory '%s'\", dd->dd_dirname);",
          "925:         return -3;",
          "926:     }",
          "930:     return 0;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "911:     gid_t groups_gid = pw->pw_gid;",
          "912: #endif",
          "915:     if (chown_res)",
          "917:     else",
          "918:     {",
          "919:         dd_init_next_file(dd);",
          "922:         {",
          "925:             if (chown_res)",
          "928:         }",
          "929:     }",
          "931:     return chown_res;",
          "932: }",
          "935: {",
          "937:     if (fd == -1)",
          "938:     {",
          "939:         if (!(flags & DD_FAIL_QUIETLY_ENOENT))",
          "",
          "[Removed Lines]",
          "914:     int chown_res = lchown(dd->dd_dirname, owners_uid, groups_gid);",
          "916:         perror_msg(\"lchown('%s')\", dd->dd_dirname);",
          "920:         char *full_name;",
          "921:         while (chown_res == 0 && dd_get_next_file(dd, /*short_name*/ NULL, &full_name))",
          "923:             log_debug(\"chowning %s\", full_name);",
          "924:             chown_res = lchown(full_name, owners_uid, groups_gid);",
          "926:                 perror_msg(\"lchown('%s')\", full_name);",
          "927:             free(full_name);",
          "934: static char *load_text_file(const char *path, unsigned flags)",
          "936:     int fd = open(path, O_RDONLY | ((flags & DD_OPEN_FOLLOW) ? 0 : O_NOFOLLOW));",
          "",
          "[Added Lines]",
          "960:     int chown_res = fchown(dd->dd_fd, owners_uid, groups_gid);",
          "962:         perror_msg(\"fchown('%s')\", dd->dd_dirname);",
          "966:         char *short_name;",
          "967:         while (chown_res == 0 && dd_get_next_file(dd, &short_name, /*full_name*/ NULL))",
          "970:             int fd = secure_openat_read(dd->dd_fd, short_name);",
          "971:             if (fd < 0)",
          "972:                 goto next;",
          "974:             log_debug(\"chowning %s\", short_name);",
          "976:             chown_res = fchown(fd, owners_uid, groups_gid);",
          "978:                 perror_msg(\"fchownat('%s')\", short_name);",
          "980:             close(fd);",
          "981: next:",
          "982:             free(short_name);",
          "989: static char *load_text_from_file_descriptor(int fd, const char *path, int flags)",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "988:     return strbuf_free_nobuf(buf_content);",
          "989: }",
          "991: static void copy_file_from_chroot(struct dump_dir* dd, const char *name, const char *chroot_dir, const char *file_path)",
          "992: {",
          "993:     char *chrooted_name = concat_path_file(chroot_dir, file_path);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1045: static char *load_text_file_at(int dir_fd, const char *name, unsigned flags)",
          "1046: {",
          "1047:     assert(name[0] != '/');",
          "1049:     const int fd = openat(dir_fd, name, O_RDONLY | ((flags & DD_OPEN_FOLLOW) ? 0 : O_NOFOLLOW));",
          "1050:     return load_text_from_file_descriptor(fd, name, flags);",
          "1051: }",
          "1053: static char *load_text_file(const char *path, unsigned flags)",
          "1054: {",
          "1055:     const int fd = open(path, O_RDONLY | ((flags & DD_OPEN_FOLLOW) ? 0 : O_NOFOLLOW));",
          "1056:     return load_text_from_file_descriptor(fd, path, flags);",
          "1057: }",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1001:     }",
          "1002: }",
          "1005: {",
          "1009:     if (fd < 0)",
          "1010:     {",
          "1012:         return false;",
          "1013:     }",
          "",
          "[Removed Lines]",
          "1004: static bool save_binary_file(const char *path, const char* data, unsigned size, uid_t uid, gid_t gid, mode_t mode)",
          "1007:     unlink(path);",
          "1008:     int fd = open(path, O_WRONLY | O_TRUNC | O_CREAT | O_NOFOLLOW, mode);",
          "1011:         perror_msg(\"Can't open file '%s'\", path);",
          "",
          "[Added Lines]",
          "1072: static bool save_binary_file_at(int dir_fd, const char *name, const char* data, unsigned size, uid_t uid, gid_t gid, mode_t mode)",
          "1074:     assert(name[0] != '/');",
          "1077:     unlinkat(dir_fd, name, /*remove only files*/0);",
          "1078:     int fd = openat(dir_fd, name, O_WRONLY | O_EXCL | O_CREAT | O_NOFOLLOW, mode);",
          "1081:         perror_msg(\"Can't open file '%s'\", name);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1016:     {",
          "1017:         if (fchown(fd, uid, gid) == -1)",
          "1018:         {",
          "1020:         }",
          "1021:     }",
          "",
          "[Removed Lines]",
          "1019:             perror_msg(\"Can't change '%s' ownership to %lu:%lu\", path, (long)uid, (long)gid);",
          "",
          "[Added Lines]",
          "1089:             perror_msg(\"Can't change '%s' ownership to %lu:%lu\", name, (long)uid, (long)gid);",
          "1090:             close(fd);",
          "1091:             return false;",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1029:     if (fchmod(fd, mode) == -1)",
          "1030:     {",
          "1032:     }",
          "1034:     unsigned r = full_write(fd, data, size);",
          "1035:     close(fd);",
          "1036:     if (r != size)",
          "1037:     {",
          "1039:         return false;",
          "1040:     }",
          "",
          "[Removed Lines]",
          "1031:         perror_msg(\"Can't change mode of '%s'\", path);",
          "1038:         error_msg(\"Can't save file '%s'\", path);",
          "",
          "[Added Lines]",
          "1103:         perror_msg(\"Can't change mode of '%s'\", name);",
          "1104:         close(fd);",
          "1105:         return false;",
          "1112:         error_msg(\"Can't save file '%s'\", name);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1058:     if (strcmp(name, \"release\") == 0)",
          "1059:         name = FILENAME_OS_RELEASE;",
          "1066: }",
          "1068: char* dd_load_text(const struct dump_dir *dd, const char *name)",
          "",
          "[Removed Lines]",
          "1061:     char *full_path = concat_path_file(dd->dd_dirname, name);",
          "1062:     char *ret = load_text_file(full_path, flags);",
          "1063:     free(full_path);",
          "1065:     return ret;",
          "",
          "[Added Lines]",
          "1135:     return load_text_file_at(dd->dd_fd, name, flags);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1078:     if (!str_is_correct_filename(name))",
          "1079:         error_msg_and_die(\"Cannot save text. '%s' is not a valid file name\", name);",
          "1084: }",
          "1086: void dd_save_binary(struct dump_dir* dd, const char* name, const char* data, unsigned size)",
          "",
          "[Removed Lines]",
          "1081:     char *full_path = concat_path_file(dd->dd_dirname, name);",
          "1082:     save_binary_file(full_path, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);",
          "1083:     free(full_path);",
          "",
          "[Added Lines]",
          "1151:     save_binary_file_at(dd->dd_fd, name, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1091:     if (!str_is_correct_filename(name))",
          "1092:         error_msg_and_die(\"Cannot save binary. '%s' is not a valid file name\", name);",
          "1097: }",
          "1099: long dd_get_item_size(struct dump_dir *dd, const char *name)",
          "",
          "[Removed Lines]",
          "1094:     char *full_path = concat_path_file(dd->dd_dirname, name);",
          "1095:     save_binary_file(full_path, data, size, dd->dd_uid, dd->dd_gid, dd->mode);",
          "1096:     free(full_path);",
          "",
          "[Added Lines]",
          "1162:     save_binary_file_at(dd->dd_fd, name, data, size, dd->dd_uid, dd->dd_gid, dd->mode);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1102:         error_msg_and_die(\"Cannot get item size. '%s' is not a valid file name\", name);",
          "1104:     long size = -1;",
          "1106:     struct stat statbuf;",
          "1109:         size = statbuf.st_size;",
          "1110:     else",
          "1111:     {",
          "1112:         if (errno == ENOENT)",
          "1113:             size = 0;",
          "1114:         else",
          "1116:     }",
          "1120:     return size;",
          "1121: }",
          "",
          "[Removed Lines]",
          "1105:     char *iname = concat_path_file(dd->dd_dirname, name);",
          "1108:     if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))",
          "1115:             perror_msg(\"Can't get size of file '%s'\", iname);",
          "1118:     free(iname);",
          "",
          "[Added Lines]",
          "1172:     int r = fstatat(dd->dd_fd, name, &statbuf, AT_SYMLINK_NOFOLLOW);",
          "1174:     if (r == 0 && S_ISREG(statbuf.st_mode))",
          "1181:             perror_msg(\"Can't get size of file '%s'\", name);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1128:     if (!str_is_correct_filename(name))",
          "1129:         error_msg_and_die(\"Cannot delete item. '%s' is not a valid file name\", name);",
          "1134:     if (res < 0)",
          "1135:     {",
          "1136:         if (errno == ENOENT)",
          "1137:             errno = res = 0;",
          "1138:         else",
          "1140:     }",
          "1143:     return res;",
          "1144: }",
          "",
          "[Removed Lines]",
          "1131:     char *path = concat_path_file(dd->dd_dirname, name);",
          "1132:     int res = unlink(path);",
          "1139:             perror_msg(\"Can't delete file '%s'\", path);",
          "1142:     free(path);",
          "",
          "[Added Lines]",
          "1195:     int res = unlinkat(dd->dd_fd, name, /*only files*/0);",
          "1202:             perror_msg(\"Can't delete file '%s'\", name);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1147: {",
          "1151:     if (dd->next_dir)",
          "1152:         closedir(dd->next_dir);",
          "1155:     if (!dd->next_dir)",
          "1156:     {",
          "1157:         error_msg(\"Can't open directory '%s'\", dd->dd_dirname);",
          "",
          "[Removed Lines]",
          "1154:     dd->next_dir = opendir(dd->dd_dirname);",
          "",
          "[Added Lines]",
          "1212:     int opendir_fd = dup(dd->dd_fd);",
          "1213:     if (opendir_fd < 0)",
          "1214:     {",
          "1215:         perror_msg(\"dd_init_next_file: dup(dd_fd)\");",
          "1216:         return NULL;",
          "1217:     }",
          "1222:     dd->next_dir = fdopendir(opendir_fd);",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1168:     struct dirent *dent;",
          "1169:     while ((dent = readdir(dd->next_dir)) != NULL)",
          "1170:     {",
          "1172:         {",
          "1173:             if (short_name)",
          "",
          "[Removed Lines]",
          "1171:         if (is_regular_file(dent, dd->dd_dirname))",
          "",
          "[Added Lines]",
          "1239:         if (is_regular_file_at(dent, dd->dd_fd))",
          "",
          "---------------"
        ],
        "src/lib/problem_data.c||src/lib/problem_data.c": [
          "File: src/lib/problem_data.c -> src/lib/problem_data.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "279:     FILENAME_OS_RELEASE,",
          "280:     NULL",
          "281: };",
          "283: {",
          "290:     if (fd < 0)",
          "",
          "[Removed Lines]",
          "282: static char* is_text_file(const char *name, ssize_t *sz)",
          "289:     int fd = open(name, O_RDONLY);",
          "",
          "[Added Lines]",
          "282: static char* is_text_file_at(int dir_fd, const char *name, ssize_t *sz)",
          "289:     int fd = secure_openat_read(dir_fd, name);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "399:         }",
          "401:         ssize_t sz = 4*1024;",
          "403:         if (!text || text == HUGE_TEXT)",
          "404:         {",
          "405:             int flag = !text ? CD_FLAG_BIN : (CD_FLAG_BIN+CD_FLAG_BIGTXT);",
          "",
          "[Removed Lines]",
          "402:         char *text = is_text_file(full_name, &sz);",
          "",
          "[Added Lines]",
          "402:         char *text = is_text_file_at(dd->dd_fd, short_name, &sz);",
          "",
          "---------------"
        ],
        "src/lib/xfuncs.c||src/lib/xfuncs.c": [
          "File: src/lib/xfuncs.c -> src/lib/xfuncs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "331:     return xopen3(pathname, flags, 0666);",
          "332: }",
          "334: void xunlink(const char *pathname)",
          "335: {",
          "336:     if (unlink(pathname))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "334: void xunlinkat(int dir_fd, const char *pathname, int flags)",
          "335: {",
          "336:     if (unlinkat(dir_fd, pathname, flags))",
          "337:         perror_msg_and_die(\"Can't remove file '%s'\", pathname);",
          "338: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "363: {",
          "364:     if (dent->d_type == DT_REG)",
          "365:         return 1;",
          "366:     if (dent->d_type != DT_UNKNOWN)",
          "367:         return 0;",
          "370:     struct stat statbuf;",
          "374:     return r == 0 && S_ISREG(statbuf.st_mode);",
          "375: }",
          "379: bool dot_or_dotdot(const char *filename)",
          "",
          "[Removed Lines]",
          "362: int is_regular_file(struct dirent *dent, const char *dirname)",
          "369:     char *fullname = xasprintf(\"%s/%s\", dirname, dent->d_name);",
          "371:     int r = lstat(fullname, &statbuf);",
          "372:     free(fullname);",
          "",
          "[Added Lines]",
          "368: int is_regular_file_at(struct dirent *dent, int dir_fd)",
          "376:     int r = fstatat(dir_fd, dent->d_name, &statbuf, AT_SYMLINK_NOFOLLOW);",
          "381: int is_regular_file(struct dirent *dent, const char *dirname)",
          "382: {",
          "383:     int dir_fd = open(dirname, O_DIRECTORY);",
          "384:     if (dir_fd < 0)",
          "385:         return 0;",
          "386:     int r = is_regular_file_at(dent, dir_fd);",
          "387:     close(dir_fd);",
          "388:     return r;",
          "389: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8f9fa454bd8c653758cddf07597f0a5a17ff5793",
      "candidate_info": {
        "commit_hash": "8f9fa454bd8c653758cddf07597f0a5a17ff5793",
        "repo": "abrt/libreport",
        "commit_url": "https://github.com/abrt/libreport/commit/8f9fa454bd8c653758cddf07597f0a5a17ff5793",
        "files": [
          "src/include/dump_dir.h",
          "src/lib/dump_dir.c",
          "tests/Makefile.am",
          "tests/dump_dir.at",
          "tests/testsuite.at"
        ],
        "message": "dump_dir: allow (semi)recursive locking\n\nThis patch only tries to mitigate the consequences of a bug in code\nwhere someone tries to lock a dump directory while it is already locked\nby the same process. This usually happens when a callee accepts a path\nto directory and opens it on its own or when someone forgets to call\ndd_unlock() or in all the unpredictable circumstance we usually have to\nface in ABRT.\n\nIt is not possible to implement the lock counter using only a symbolic\nlink and file system functions, thus I've decided to put the\nresponsibility of unlocking to the first dd_lock() caller and disallow\nthe consecutive callers to unlock the dump directory.\n\nRelated to abrt/abrt#898\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "src/include/dump_dir.h||src/include/dump_dir.h",
          "src/lib/dump_dir.c||src/lib/dump_dir.c",
          "tests/Makefile.am||tests/Makefile.am",
          "tests/dump_dir.at||tests/dump_dir.at",
          "tests/testsuite.at||tests/testsuite.at"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "src/include/dump_dir.h||src/include/dump_dir.h",
            "src/lib/dump_dir.c||src/lib/dump_dir.c"
          ],
          "candidate": [
            "src/include/dump_dir.h||src/include/dump_dir.h",
            "src/lib/dump_dir.c||src/lib/dump_dir.c"
          ]
        }
      },
      "candidate_diff": {
        "src/include/dump_dir.h||src/include/dump_dir.h": [
          "File: src/include/dump_dir.h -> src/include/dump_dir.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "55:     mode_t mode;",
          "56:     time_t dd_time;",
          "57:     char *dd_type;",
          "58: };",
          "60: void dd_close(struct dump_dir *dd);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "63:     int owns_lock;",
          "",
          "---------------"
        ],
        "src/lib/dump_dir.c||src/lib/dump_dir.c": [
          "File: src/lib/dump_dir.c -> src/lib/dump_dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "216:         if (strcmp(pid_buf, pid) == 0)",
          "217:         {",
          "218:             log(\"Lock file '%s' is already locked by us\", lock_file);",
          "219:             return 0;",
          "220:         }",
          "221:         if (isdigit_str(pid_buf))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "219:             errno = EALREADY;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "287:         int r = create_symlink_lockfile(lock_buf, pid_buf);",
          "288:         if (r < 0)",
          "293:         usleep(sleep_usec);",
          "294:     }",
          "298:     {",
          "",
          "[Removed Lines]",
          "290:         if (r > 0)",
          "",
          "[Added Lines]",
          "292:         if (r > 0 || errno == EALREADY)",
          "301:     if (!(dd->owns_lock = (errno != EALREADY)))",
          "302:         errno = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "305:         if (missing_file)",
          "306:         {",
          "309:             if (--count == 0 || flags & DD_DONT_WAIT_FOR_LOCK)",
          "310:             {",
          "",
          "[Removed Lines]",
          "307:             xunlink(lock_buf);",
          "308:             log_notice(\"Unlocked '%s' (no or corrupted '%s' file)\", lock_buf, missing_file);",
          "",
          "[Added Lines]",
          "315:             if (dd->owns_lock)",
          "316:                 xunlink(lock_buf);",
          "318:             log_warning(\"Unlocked '%s' (no or corrupted '%s' file)\", lock_buf, missing_file);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "324: {",
          "325:     if (dd->locked)",
          "326:     {",
          "329:         unsigned dirname_len = strlen(dd->dd_dirname);",
          "330:         char lock_buf[dirname_len + sizeof(\"/.lock\")];",
          "331:         strcpy(lock_buf, dd->dd_dirname);",
          "332:         strcpy(lock_buf + dirname_len, \"/.lock\");",
          "335:         log_info(\"Unlocked '%s'\", lock_buf);",
          "336:     }",
          "",
          "[Removed Lines]",
          "327:         dd->locked = 0;",
          "333:         xunlink(lock_buf);",
          "",
          "[Added Lines]",
          "342:         if (dd->owns_lock)",
          "343:             xunlink(lock_buf);",
          "345:         dd->owns_lock = 0;",
          "346:         dd->locked = 0;",
          "",
          "---------------"
        ],
        "tests/Makefile.am||tests/Makefile.am": [
          "File: tests/Makefile.am -> tests/Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "43:   xfuncs.at \\",
          "44:   string_list.at \\",
          "45:   ureport.at \\",
          "48: EXTRA_DIST += $(TESTSUITE_AT)",
          "49: TESTSUITE = $(srcdir)/testsuite",
          "",
          "[Removed Lines]",
          "46:   problem_report.at",
          "",
          "[Added Lines]",
          "46:   problem_report.at \\",
          "47:   dump_dir.at",
          "",
          "---------------"
        ],
        "tests/dump_dir.at||tests/dump_dir.at": [
          "File: tests/dump_dir.at -> tests/dump_dir.at",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # -*- Autotest -*-",
          "3: AT_BANNER([dump_dir])",
          "5: ## -------------- ##",
          "6: ## recursive_lock ##",
          "7: ## -------------- ##",
          "9: AT_TESTFUN([recursive_lock],",
          "10: [[",
          "11: #include \"internal_libreport.h\"",
          "12: #include <errno.h>",
          "13: #include <assert.h>",
          "15: int main(int argc, char **argv)",
          "16: {",
          "17:     g_verbose = 3;",
          "19:     char *path = tmpnam(NULL);",
          "20:     struct dump_dir *dd = dd_create(path, -1L, DEFAULT_DUMP_DIR_MODE);",
          "22:     char *lock_path = concat_path_file(path, \".lock\");",
          "23:     struct stat buf;",
          "25:     assert(dd);",
          "27:     assert(lstat(lock_path, &buf) == 0 && S_ISLNK(buf.st_mode));",
          "29:     dd_create_basic_files(dd, -1L, \"/\");",
          "30:     dd_save_text(dd, \"type\", \"custom\");",
          "32:     struct dump_dir *dd2 = dd_opendir(path, DD_OPEN_READONLY);",
          "33:     assert(dd2->owns_lock == 0);",
          "35:     struct dump_dir *dd3 = dd_opendir(path, 0);",
          "36:     assert(dd3->owns_lock == 0);",
          "38:     dd_close(dd2);",
          "39:     assert(lstat(lock_path, &buf) == 0 && S_ISLNK(buf.st_mode));",
          "41:     dd_close(dd3);",
          "42:     assert(lstat(lock_path, &buf) == 0 && S_ISLNK(buf.st_mode));",
          "44:     dd_close(dd);",
          "46:     assert(stat(lock_path, &buf) != 0 && errno == ENOENT);",
          "47:     free(lock_path);",
          "49:     return 0;",
          "50: }",
          "51: ]])",
          "",
          "---------------"
        ],
        "tests/testsuite.at||tests/testsuite.at": [
          "File: tests/testsuite.at -> tests/testsuite.at",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: m4_include([string_list.at])",
          "19: m4_include([ureport.at])",
          "20: m4_include([problem_report.at])",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21: m4_include([dump_dir.at])",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2020-25866",
  "cve_desc": "In Wireshark 3.2.0 to 3.2.6 and 3.0.0 to 3.0.13, the BLIP protocol dissector has a NULL pointer dereference because a buffer was sized for compressed (not uncompressed) messages. This was addressed in epan/dissectors/packet-blip.c by allowing reasonable compression ratios and rejecting ZIP bombs.",
  "repo": "wireshark/wireshark",
  "patch_hash": "4a948427100b6c109f4ec7b4361f0d2aec5e5c3f",
  "patch_info": {
    "commit_hash": "4a948427100b6c109f4ec7b4361f0d2aec5e5c3f",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/4a948427100b6c109f4ec7b4361f0d2aec5e5c3f",
    "files": [
      "epan/dissectors/packet-blip.c"
    ],
    "message": "BLIP: Fix decompression buffer bug\n\nUntil now, mistakenly, the buffer for decompressing compressed BLIP messages\nhas been statically allocated as 16 Kb, but that is not valid behavior.\n16 Kb is the maximum size of a _compressed_ frame.  In theory, due to the\nability to zipbomb, there is virtually no upper bound on what the maximum\nsize of an uncompressed frame could be.  However, to keep sanity, it has\nbeen made into a preference with a reasonable default that is not likely to\nbe exceeded (64 Kb).  The behavior before for this was that wireshark would\ncrash because the dissector would return NULL for a decompressed buffer due\nto error and then try to deference it later.  A null check has been added,\nso that the behavior is now that the packet will show\n'<Error decompressing message>' instead, and log why it couldn't handle the\ncompressed message.  Closes #16866.",
    "before_after_code_files": [
      "epan/dissectors/packet-blip.c||epan/dissectors/packet-blip.c"
    ]
  },
  "patch_diff": {
    "epan/dissectors/packet-blip.c||epan/dissectors/packet-blip.c": [
      "File: epan/dissectors/packet-blip.c -> epan/dissectors/packet-blip.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "19: #include <epan/packet.h>",
      "20: #include <epan/conversation.h>",
      "21: #include \"proto_data.h\"",
      "23: #ifdef HAVE_ZLIB",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "21: #include <epan/prefs.h>",
      "22: #include <epan/expert.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "28: void proto_register_blip(void);",
      "30: #define BLIP_BODY_CHECKSUM_SIZE 4",
      "34: typedef struct {",
      "",
      "[Removed Lines]",
      "31: #define BLIP_INFLATE_BUFFER_SIZE 16384",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "49: } blip_conversation_entry_t;",
      "51: #ifdef HAVE_ZLIB",
      "52: typedef struct",
      "53: {",
      "54:  size_t size;",
      "55:  void* buf;",
      "57: #endif",
      "",
      "[Removed Lines]",
      "56: } slice_t;",
      "",
      "[Added Lines]",
      "53: typedef enum",
      "54: {",
      "55:  no_error = 0,",
      "56:  zlib_error,",
      "57:  overflow_error",
      "58: } decompress_error_t;",
      "62:  decompress_error_t domain;",
      "63:  int code;",
      "66: } decompress_result_t;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "66: static int hf_blip_message_body = -1;",
      "67: static int hf_blip_ack_size = -1;",
      "68: static int hf_blip_checksum = -1;",
      "69: static gint ett_blip = -1;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "82: static expert_field ei_blip_decompress_buffer_too_small = EI_INIT;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "105:  { 0, NULL }",
      "106: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "122: #ifdef HAVE_ZLIB",
      "123: static guint max_uncompressed_size = 64; // Max uncompressed body size in Kb",
      "124: #endif",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "267: }",
      "269: static tvbuff_t*",
      "271: {",
      "272:  if(PINFO_FD_VISITED(pinfo)) {",
      "278:  }",
      "280:  const guint8* buf = tvb_get_ptr(tvb, offset, length);",
      "281:  z_stream* decompress_stream = get_decompress_stream(pinfo);",
      "282:  static Byte trailer[4] = { 0x00, 0x00, 0xff, 0xff };",
      "",
      "[Removed Lines]",
      "270: decompress(packet_info* pinfo, tvbuff_t* tvb, gint offset, gint length)",
      "273:   const slice_t* saved_data = (slice_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_blip, 0);",
      "274:   tvbuff_t* decompressedChild = tvb_new_child_real_data(tvb, (guint8 *)saved_data->buf,",
      "275:    (gint)saved_data->size, (gint)saved_data->size);",
      "276:   add_new_data_source(pinfo, decompressedChild, \"Decompressed Payload\");",
      "277:   return decompressedChild;",
      "",
      "[Added Lines]",
      "288: decompress(packet_info* pinfo, proto_tree* tree, tvbuff_t* tvb, gint offset, gint length)",
      "291:   const decompress_result_t* saved_data = (decompress_result_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_blip, 0);",
      "292:   if(!saved_data) {",
      "293:    proto_tree_add_string(tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<Error decompressing data>\");",
      "294:    return NULL;",
      "295:   }",
      "297:   if(saved_data->domain) {",
      "298:    proto_item* field = proto_tree_add_string(tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<Error decompressing data>\");",
      "299:    if(saved_data->domain == zlib_error) {",
      "300:     expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, got zlib error %d\", saved_data->code);",
      "301:    } else {",
      "302:     expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, buffer too small (%u Kb).  Please adjust in settings.\", max_uncompressed_size);",
      "303:    }",
      "305:    return NULL;",
      "306:   } else {",
      "307:    tvbuff_t* decompressedChild = tvb_new_child_real_data(tvb, (guint8 *)saved_data->buf,",
      "308:     (gint)saved_data->size, (gint)saved_data->size);",
      "309:    add_new_data_source(pinfo, decompressedChild, \"Decompressed Payload\");",
      "310:    return decompressedChild;",
      "311:   }",
      "314:  static gboolean size_overflow = FALSE;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "292:   }",
      "293:  }",
      "296:  decompress_stream->next_in = (Bytef*)buf;",
      "297:  decompress_stream->avail_in = length;",
      "298:  decompress_stream->next_out = decompress_buffer;",
      "300:  uLong start = decompress_stream->total_out;",
      "301:  int err = inflate(decompress_stream, Z_NO_FLUSH);",
      "303:   return NULL;",
      "304:  }",
      "306:  decompress_stream->next_in = trailer;",
      "307:  decompress_stream->avail_in = 4;",
      "308:  err = inflate(decompress_stream, Z_SYNC_FLUSH);",
      "310:   return NULL;",
      "311:  }",
      "313:  uLong bodyLength = decompress_stream->total_out - start;",
      "315:  add_new_data_source(pinfo, decompressedChild, \"Decompressed Payload\");",
      "317:  data_to_save->size = (size_t)bodyLength;",
      "319:  p_add_proto_data(wmem_file_scope(), pinfo, proto_blip, 0, data_to_save);",
      "321:  return decompressedChild;",
      "",
      "[Removed Lines]",
      "295:  Bytef* decompress_buffer = (Bytef*)wmem_alloc(wmem_file_scope(), BLIP_INFLATE_BUFFER_SIZE);",
      "299:  decompress_stream->avail_out = BLIP_INFLATE_BUFFER_SIZE;",
      "302:  if(err < 0) {",
      "309:  if(err < 0) {",
      "314:  tvbuff_t* decompressedChild = tvb_new_child_real_data(tvb, decompress_buffer, (guint)bodyLength, (gint)bodyLength);",
      "316:  slice_t* data_to_save = wmem_new0(wmem_file_scope(), slice_t);",
      "318:  data_to_save->buf = decompress_buffer;",
      "",
      "[Added Lines]",
      "332:  uInt buffer_size = max_uncompressed_size * 1024;",
      "333:  Bytef* decompress_buffer = (Bytef*)wmem_alloc(wmem_packet_scope(), buffer_size);",
      "337:  decompress_stream->avail_out = buffer_size;",
      "340:  if(err != Z_OK) {",
      "341:   proto_item* field = proto_tree_add_string(tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<Error decompressing data>\");",
      "342:   decompress_result_t* data_to_save = wmem_new0(wmem_file_scope(), decompress_result_t);",
      "343:   if(size_overflow && err == Z_DATA_ERROR) {",
      "344:    data_to_save->domain = overflow_error;",
      "345:    expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, buffer too small (%u Kb).  Please adjust in settings.\", max_uncompressed_size);",
      "346:   } else {",
      "347:    data_to_save->domain = zlib_error;",
      "348:    data_to_save->code = err;",
      "349:    expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, got zlib error %d\", err);",
      "350:   }",
      "352:   p_add_proto_data(wmem_file_scope(), pinfo, proto_blip, 0, data_to_save);",
      "359:  if(err != Z_OK) {",
      "360:   proto_item* field = proto_tree_add_string(tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<Error decompressing data>\");",
      "361:   decompress_result_t* data_to_save = wmem_new0(wmem_file_scope(), decompress_result_t);",
      "362:   if(err == Z_BUF_ERROR) {",
      "363:    data_to_save->domain = overflow_error;",
      "364:    size_overflow = TRUE;",
      "365:    expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, buffer too small (%u Kb).  Please adjust in settings.\", max_uncompressed_size);",
      "366:   } else {",
      "367:    data_to_save->domain = zlib_error;",
      "368:    data_to_save->code = err;",
      "369:    expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, got zlib error %d\", err);",
      "370:   }",
      "372:   p_add_proto_data(wmem_file_scope(), pinfo, proto_blip, 0, data_to_save);",
      "379:  Bytef* shortened_buffer = (Bytef *)wmem_memdup(wmem_file_scope(), decompress_buffer, bodyLength);",
      "381:  tvbuff_t* decompressedChild = tvb_new_child_real_data(tvb, shortened_buffer, (guint)bodyLength, (gint)bodyLength);",
      "383:  decompress_result_t* data_to_save = wmem_new0(wmem_file_scope(), decompress_result_t);",
      "385:  data_to_save->buf = shortened_buffer;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "402:  tvbuff_t* tvb_to_use = tvb;",
      "403:  gboolean compressed = is_compressed(value_frame_flags);",
      "404:  if(compressed) {",
      "405: #ifdef HAVE_ZLIB",
      "407:   if(!tvb_to_use) {",
      "409:    return tvb_reported_length(tvb);",
      "410:   }",
      "413:   return tvb_reported_length(tvb);",
      "",
      "[Removed Lines]",
      "406:   tvb_to_use = decompress(pinfo, tvb, offset, tvb_reported_length_remaining(tvb, offset) - BLIP_BODY_CHECKSUM_SIZE);",
      "408:    proto_tree_add_string(blip_tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<Error decompressing message>\");",
      "412:   proto_tree_add_string(blip_tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<decompression support is not available>\");",
      "",
      "[Added Lines]",
      "474:   tvb_to_use = decompress(pinfo, blip_tree, tvb, offset, tvb_reported_length_remaining(tvb, offset) - BLIP_BODY_CHECKSUM_SIZE);",
      "479:   proto_tree_add_string(tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<decompression support is not available>\");",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "525:   &ett_blip",
      "526:  };",
      "528:  proto_blip = proto_register_protocol(\"BLIP Couchbase Mobile\", \"BLIP\", \"blip\");",
      "530:  proto_register_field_array(proto_blip, hf, array_length(hf));",
      "531:  proto_register_subtree_array(ett, array_length(ett));",
      "533:  blip_handle = register_dissector(\"blip\", dissect_blip, proto_blip);",
      "534: }",
      "536: void",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "596:  static ei_register_info ei[] = {",
      "597:   { &ei_blip_decompress_buffer_too_small, { \"blip.decompress_buffer_too_small\", PI_UNDECODED, PI_WARN, \"Decompression buffer size too small\", EXPFILL }}",
      "598:  };",
      "601:  expert_module_t* expert_blip = expert_register_protocol(proto_blip);",
      "605:  expert_register_field_array(expert_blip, ei, array_length(ei));",
      "609: #ifdef HAVE_ZLIB",
      "610:  module_t *blip_module = prefs_register_protocol(proto_blip, NULL);",
      "611:  prefs_register_uint_preference(blip_module, \"max_uncompressed_size\",",
      "612:       \"Maximum uncompressed message size (Kb)\",",
      "613:       \"The maximum size of the buffer for uncompressed messages. \"",
      "614:       \"If a message is larger than this, then the packet containing \"",
      "615:       \"the message, as well as subsequent packets, will fail to \"",
      "616:       \"decompress\", 10, &max_uncompressed_size);",
      "617: #endif",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "594d312b12b2eebd06290e1292434d1e01389761",
      "candidate_info": {
        "commit_hash": "594d312b12b2eebd06290e1292434d1e01389761",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/594d312b12b2eebd06290e1292434d1e01389761",
        "files": [
          "epan/dissectors/packet-blip.c"
        ],
        "message": "BLIP: Fix decompression buffer bug\n\nUntil now, mistakenly, the buffer for decompressing compressed BLIP messages\nhas been statically allocated as 16 Kb, but that is not valid behavior.\n16 Kb is the maximum size of a _compressed_ frame.  In theory, due to the\nability to zipbomb, there is virtually no upper bound on what the maximum\nsize of an uncompressed frame could be.  However, to keep sanity, it has\nbeen made into a preference with a reasonable default that is not likely to\nbe exceeded (64 Kb).  The behavior before for this was that wireshark would\ncrash because the dissector would return NULL for a decompressed buffer due\nto error and then try to deference it later.  A null check has been added,\nso that the behavior is now that the packet will show\n'<Error decompressing message>' instead, and log why it couldn't handle the\ncompressed message.  Closes #16866.\n\n(cherry picked from commit 4a948427100b6c109f4ec7b4361f0d2aec5e5c3f)",
        "before_after_code_files": [
          "epan/dissectors/packet-blip.c||epan/dissectors/packet-blip.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-blip.c||epan/dissectors/packet-blip.c"
          ],
          "candidate": [
            "epan/dissectors/packet-blip.c||epan/dissectors/packet-blip.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-blip.c||epan/dissectors/packet-blip.c": [
          "File: epan/dissectors/packet-blip.c -> epan/dissectors/packet-blip.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: #include <epan/packet.h>",
          "20: #include <epan/conversation.h>",
          "21: #include \"proto_data.h\"",
          "23: #ifdef HAVE_ZLIB",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21: #include <epan/prefs.h>",
          "22: #include <epan/expert.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "28: void proto_register_blip(void);",
          "30: #define BLIP_BODY_CHECKSUM_SIZE 4",
          "34: typedef struct {",
          "",
          "[Removed Lines]",
          "31: #define BLIP_INFLATE_BUFFER_SIZE 16384",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "49: } blip_conversation_entry_t;",
          "51: #ifdef HAVE_ZLIB",
          "52: typedef struct",
          "53: {",
          "54:  size_t size;",
          "55:  void* buf;",
          "57: #endif",
          "",
          "[Removed Lines]",
          "56: } slice_t;",
          "",
          "[Added Lines]",
          "53: typedef enum",
          "54: {",
          "55:  no_error = 0,",
          "56:  zlib_error,",
          "57:  overflow_error",
          "58: } decompress_error_t;",
          "62:  decompress_error_t domain;",
          "63:  int code;",
          "66: } decompress_result_t;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "66: static int hf_blip_message_body = -1;",
          "67: static int hf_blip_ack_size = -1;",
          "68: static int hf_blip_checksum = -1;",
          "69: static gint ett_blip = -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "82: static expert_field ei_blip_decompress_buffer_too_small = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "105:  { 0, NULL }",
          "106: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "122: #ifdef HAVE_ZLIB",
          "123: static guint max_uncompressed_size = 64; // Max uncompressed body size in Kb",
          "124: #endif",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "267: }",
          "269: static tvbuff_t*",
          "271: {",
          "272:  if(PINFO_FD_VISITED(pinfo)) {",
          "278:  }",
          "280:  const guint8* buf = tvb_get_ptr(tvb, offset, length);",
          "281:  z_stream* decompress_stream = get_decompress_stream(pinfo);",
          "282:  static Byte trailer[4] = { 0x00, 0x00, 0xff, 0xff };",
          "",
          "[Removed Lines]",
          "270: decompress(packet_info* pinfo, tvbuff_t* tvb, gint offset, gint length)",
          "273:   const slice_t* saved_data = (slice_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_blip, 0);",
          "274:   tvbuff_t* decompressedChild = tvb_new_child_real_data(tvb, (guint8 *)saved_data->buf,",
          "275:    (gint)saved_data->size, (gint)saved_data->size);",
          "276:   add_new_data_source(pinfo, decompressedChild, \"Decompressed Payload\");",
          "277:   return decompressedChild;",
          "",
          "[Added Lines]",
          "288: decompress(packet_info* pinfo, proto_tree* tree, tvbuff_t* tvb, gint offset, gint length)",
          "291:   const decompress_result_t* saved_data = (decompress_result_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_blip, 0);",
          "292:   if(!saved_data) {",
          "293:    proto_tree_add_string(tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<Error decompressing data>\");",
          "294:    return NULL;",
          "295:   }",
          "297:   if(saved_data->domain) {",
          "298:    proto_item* field = proto_tree_add_string(tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<Error decompressing data>\");",
          "299:    if(saved_data->domain == zlib_error) {",
          "300:     expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, got zlib error %d\", saved_data->code);",
          "301:    } else {",
          "302:     expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, buffer too small (%u Kb).  Please adjust in settings.\", max_uncompressed_size);",
          "303:    }",
          "305:    return NULL;",
          "306:   } else {",
          "307:    tvbuff_t* decompressedChild = tvb_new_child_real_data(tvb, (guint8 *)saved_data->buf,",
          "308:     (gint)saved_data->size, (gint)saved_data->size);",
          "309:    add_new_data_source(pinfo, decompressedChild, \"Decompressed Payload\");",
          "310:    return decompressedChild;",
          "311:   }",
          "314:  static gboolean size_overflow = FALSE;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "292:   }",
          "293:  }",
          "296:  decompress_stream->next_in = (Bytef*)buf;",
          "297:  decompress_stream->avail_in = length;",
          "298:  decompress_stream->next_out = decompress_buffer;",
          "300:  uLong start = decompress_stream->total_out;",
          "301:  int err = inflate(decompress_stream, Z_NO_FLUSH);",
          "303:   return NULL;",
          "304:  }",
          "306:  decompress_stream->next_in = trailer;",
          "307:  decompress_stream->avail_in = 4;",
          "308:  err = inflate(decompress_stream, Z_SYNC_FLUSH);",
          "310:   return NULL;",
          "311:  }",
          "313:  uLong bodyLength = decompress_stream->total_out - start;",
          "315:  add_new_data_source(pinfo, decompressedChild, \"Decompressed Payload\");",
          "317:  data_to_save->size = (size_t)bodyLength;",
          "319:  p_add_proto_data(wmem_file_scope(), pinfo, proto_blip, 0, data_to_save);",
          "321:  return decompressedChild;",
          "",
          "[Removed Lines]",
          "295:  Bytef* decompress_buffer = (Bytef*)wmem_alloc(wmem_file_scope(), BLIP_INFLATE_BUFFER_SIZE);",
          "299:  decompress_stream->avail_out = BLIP_INFLATE_BUFFER_SIZE;",
          "302:  if(err < 0) {",
          "309:  if(err < 0) {",
          "314:  tvbuff_t* decompressedChild = tvb_new_child_real_data(tvb, decompress_buffer, (guint)bodyLength, (gint)bodyLength);",
          "316:  slice_t* data_to_save = wmem_new0(wmem_file_scope(), slice_t);",
          "318:  data_to_save->buf = decompress_buffer;",
          "",
          "[Added Lines]",
          "332:  uInt buffer_size = max_uncompressed_size * 1024;",
          "333:  Bytef* decompress_buffer = (Bytef*)wmem_alloc(wmem_packet_scope(), buffer_size);",
          "337:  decompress_stream->avail_out = buffer_size;",
          "340:  if(err != Z_OK) {",
          "341:   proto_item* field = proto_tree_add_string(tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<Error decompressing data>\");",
          "342:   decompress_result_t* data_to_save = wmem_new0(wmem_file_scope(), decompress_result_t);",
          "343:   if(size_overflow && err == Z_DATA_ERROR) {",
          "344:    data_to_save->domain = overflow_error;",
          "345:    expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, buffer too small (%u Kb).  Please adjust in settings.\", max_uncompressed_size);",
          "346:   } else {",
          "347:    data_to_save->domain = zlib_error;",
          "348:    data_to_save->code = err;",
          "349:    expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, got zlib error %d\", err);",
          "350:   }",
          "352:   p_add_proto_data(wmem_file_scope(), pinfo, proto_blip, 0, data_to_save);",
          "359:  if(err != Z_OK) {",
          "360:   proto_item* field = proto_tree_add_string(tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<Error decompressing data>\");",
          "361:   decompress_result_t* data_to_save = wmem_new0(wmem_file_scope(), decompress_result_t);",
          "362:   if(err == Z_BUF_ERROR) {",
          "363:    data_to_save->domain = overflow_error;",
          "364:    size_overflow = TRUE;",
          "365:    expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, buffer too small (%u Kb).  Please adjust in settings.\", max_uncompressed_size);",
          "366:   } else {",
          "367:    data_to_save->domain = zlib_error;",
          "368:    data_to_save->code = err;",
          "369:    expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, got zlib error %d\", err);",
          "370:   }",
          "372:   p_add_proto_data(wmem_file_scope(), pinfo, proto_blip, 0, data_to_save);",
          "379:  Bytef* shortened_buffer = (Bytef *)wmem_memdup(wmem_file_scope(), decompress_buffer, bodyLength);",
          "381:  tvbuff_t* decompressedChild = tvb_new_child_real_data(tvb, shortened_buffer, (guint)bodyLength, (gint)bodyLength);",
          "383:  decompress_result_t* data_to_save = wmem_new0(wmem_file_scope(), decompress_result_t);",
          "385:  data_to_save->buf = shortened_buffer;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "402:  tvbuff_t* tvb_to_use = tvb;",
          "403:  gboolean compressed = is_compressed(value_frame_flags);",
          "404:  if(compressed) {",
          "405: #ifdef HAVE_ZLIB",
          "407:   if(!tvb_to_use) {",
          "409:    return tvb_reported_length(tvb);",
          "410:   }",
          "413:   return tvb_reported_length(tvb);",
          "",
          "[Removed Lines]",
          "406:   tvb_to_use = decompress(pinfo, tvb, offset, tvb_reported_length_remaining(tvb, offset) - BLIP_BODY_CHECKSUM_SIZE);",
          "408:    proto_tree_add_string(blip_tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<Error decompressing message>\");",
          "412:   proto_tree_add_string(blip_tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<decompression support is not available>\");",
          "",
          "[Added Lines]",
          "474:   tvb_to_use = decompress(pinfo, blip_tree, tvb, offset, tvb_reported_length_remaining(tvb, offset) - BLIP_BODY_CHECKSUM_SIZE);",
          "479:   proto_tree_add_string(tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<decompression support is not available>\");",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "525:   &ett_blip",
          "526:  };",
          "528:  proto_blip = proto_register_protocol(\"BLIP Couchbase Mobile\", \"BLIP\", \"blip\");",
          "530:  proto_register_field_array(proto_blip, hf, array_length(hf));",
          "531:  proto_register_subtree_array(ett, array_length(ett));",
          "533:  blip_handle = register_dissector(\"blip\", dissect_blip, proto_blip);",
          "534: }",
          "536: void",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "596:  static ei_register_info ei[] = {",
          "597:   { &ei_blip_decompress_buffer_too_small, { \"blip.decompress_buffer_too_small\", PI_UNDECODED, PI_WARN, \"Decompression buffer size too small\", EXPFILL }}",
          "598:  };",
          "601:  expert_module_t* expert_blip = expert_register_protocol(proto_blip);",
          "605:  expert_register_field_array(expert_blip, ei, array_length(ei));",
          "609: #ifdef HAVE_ZLIB",
          "610:  module_t *blip_module = prefs_register_protocol(proto_blip, NULL);",
          "611:  prefs_register_uint_preference(blip_module, \"max_uncompressed_size\",",
          "612:       \"Maximum uncompressed message size (Kb)\",",
          "613:       \"The maximum size of the buffer for uncompressed messages. \"",
          "614:       \"If a message is larger than this, then the packet containing \"",
          "615:       \"the message, as well as subsequent packets, will fail to \"",
          "616:       \"decompress\", 10, &max_uncompressed_size);",
          "617: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f1bab46d0610ab279ea1c7c52ad0771003169bfb",
      "candidate_info": {
        "commit_hash": "f1bab46d0610ab279ea1c7c52ad0771003169bfb",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/f1bab46d0610ab279ea1c7c52ad0771003169bfb",
        "files": [
          "epan/dissectors/packet-blip.c"
        ],
        "message": "BLIP: Fix decompression buffer bug\n\nUntil now, mistakenly, the buffer for decompressing compressed BLIP messages\nhas been statically allocated as 16 Kb, but that is not valid behavior.\n16 Kb is the maximum size of a _compressed_ frame.  In theory, due to the\nability to zipbomb, there is virtually no upper bound on what the maximum\nsize of an uncompressed frame could be.  However, to keep sanity, it has\nbeen made into a preference with a reasonable default that is not likely to\nbe exceeded (64 Kb).  The behavior before for this was that wireshark would\ncrash because the dissector would return NULL for a decompressed buffer due\nto error and then try to deference it later.  A null check has been added,\nso that the behavior is now that the packet will show\n'<Error decompressing message>' instead, and log why it couldn't handle the\ncompressed message.  Closes #16866.\n\n(cherry picked from commit 4a948427100b6c109f4ec7b4361f0d2aec5e5c3f)",
        "before_after_code_files": [
          "epan/dissectors/packet-blip.c||epan/dissectors/packet-blip.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-blip.c||epan/dissectors/packet-blip.c"
          ],
          "candidate": [
            "epan/dissectors/packet-blip.c||epan/dissectors/packet-blip.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-blip.c||epan/dissectors/packet-blip.c": [
          "File: epan/dissectors/packet-blip.c -> epan/dissectors/packet-blip.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: #include <epan/packet.h>",
          "20: #include <epan/conversation.h>",
          "21: #include \"proto_data.h\"",
          "23: #ifdef HAVE_ZLIB",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21: #include <epan/prefs.h>",
          "22: #include <epan/expert.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "28: void proto_register_blip(void);",
          "30: #define BLIP_BODY_CHECKSUM_SIZE 4",
          "34: typedef struct {",
          "",
          "[Removed Lines]",
          "31: #define BLIP_INFLATE_BUFFER_SIZE 16384",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "49: } blip_conversation_entry_t;",
          "51: #ifdef HAVE_ZLIB",
          "52: typedef struct",
          "53: {",
          "54:  size_t size;",
          "55:  void* buf;",
          "57: #endif",
          "",
          "[Removed Lines]",
          "56: } slice_t;",
          "",
          "[Added Lines]",
          "53: typedef enum",
          "54: {",
          "55:  no_error = 0,",
          "56:  zlib_error,",
          "57:  overflow_error",
          "58: } decompress_error_t;",
          "62:  decompress_error_t domain;",
          "63:  int code;",
          "66: } decompress_result_t;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "66: static int hf_blip_message_body = -1;",
          "67: static int hf_blip_ack_size = -1;",
          "68: static int hf_blip_checksum = -1;",
          "69: static gint ett_blip = -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "82: static expert_field ei_blip_decompress_buffer_too_small = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "105:  { 0, NULL }",
          "106: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "122: #ifdef HAVE_ZLIB",
          "123: static guint max_uncompressed_size = 64; // Max uncompressed body size in Kb",
          "124: #endif",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "269: }",
          "271: static tvbuff_t*",
          "273: {",
          "274:  if(PINFO_FD_VISITED(pinfo)) {",
          "280:  }",
          "282:  const guint8* buf = tvb_get_ptr(tvb, offset, length);",
          "283:  z_stream* decompress_stream = get_decompress_stream(pinfo);",
          "284:  static Byte trailer[4] = { 0x00, 0x00, 0xff, 0xff };",
          "",
          "[Removed Lines]",
          "272: decompress(packet_info* pinfo, tvbuff_t* tvb, gint offset, gint length)",
          "275:   const slice_t* saved_data = (slice_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_blip, 0);",
          "276:   tvbuff_t* decompressedChild = tvb_new_child_real_data(tvb, (guint8 *)saved_data->buf,",
          "277:    (gint)saved_data->size, (gint)saved_data->size);",
          "278:   add_new_data_source(pinfo, decompressedChild, \"Decompressed Payload\");",
          "279:   return decompressedChild;",
          "",
          "[Added Lines]",
          "290: decompress(packet_info* pinfo, proto_tree* tree, tvbuff_t* tvb, gint offset, gint length)",
          "293:   const decompress_result_t* saved_data = (decompress_result_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_blip, 0);",
          "294:   if(!saved_data) {",
          "295:    proto_tree_add_string(tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<Error decompressing data>\");",
          "296:    return NULL;",
          "297:   }",
          "299:   if(saved_data->domain) {",
          "300:    proto_item* field = proto_tree_add_string(tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<Error decompressing data>\");",
          "301:    if(saved_data->domain == zlib_error) {",
          "302:     expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, got zlib error %d\", saved_data->code);",
          "303:    } else {",
          "304:     expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, buffer too small (%u Kb).  Please adjust in settings.\", max_uncompressed_size);",
          "305:    }",
          "307:    return NULL;",
          "308:   } else {",
          "309:    tvbuff_t* decompressedChild = tvb_new_child_real_data(tvb, (guint8 *)saved_data->buf,",
          "310:     (gint)saved_data->size, (gint)saved_data->size);",
          "311:    add_new_data_source(pinfo, decompressedChild, \"Decompressed Payload\");",
          "312:    return decompressedChild;",
          "313:   }",
          "316:  static gboolean size_overflow = FALSE;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "294:   }",
          "295:  }",
          "298:  decompress_stream->next_in = (Bytef*)buf;",
          "299:  decompress_stream->avail_in = length;",
          "300:  decompress_stream->next_out = decompress_buffer;",
          "302:  uLong start = decompress_stream->total_out;",
          "303:  int err = inflate(decompress_stream, Z_NO_FLUSH);",
          "305:   return NULL;",
          "306:  }",
          "308:  decompress_stream->next_in = trailer;",
          "309:  decompress_stream->avail_in = 4;",
          "310:  err = inflate(decompress_stream, Z_SYNC_FLUSH);",
          "312:   return NULL;",
          "313:  }",
          "315:  uLong bodyLength = decompress_stream->total_out - start;",
          "317:  add_new_data_source(pinfo, decompressedChild, \"Decompressed Payload\");",
          "319:  data_to_save->size = (size_t)bodyLength;",
          "321:  p_add_proto_data(wmem_file_scope(), pinfo, proto_blip, 0, data_to_save);",
          "323:  return decompressedChild;",
          "",
          "[Removed Lines]",
          "297:  Bytef* decompress_buffer = (Bytef*)wmem_alloc(wmem_file_scope(), BLIP_INFLATE_BUFFER_SIZE);",
          "301:  decompress_stream->avail_out = BLIP_INFLATE_BUFFER_SIZE;",
          "304:  if(err < 0) {",
          "311:  if(err < 0) {",
          "316:  tvbuff_t* decompressedChild = tvb_new_child_real_data(tvb, decompress_buffer, (guint)bodyLength, (gint)bodyLength);",
          "318:  slice_t* data_to_save = wmem_new0(wmem_file_scope(), slice_t);",
          "320:  data_to_save->buf = decompress_buffer;",
          "",
          "[Added Lines]",
          "334:  uInt buffer_size = max_uncompressed_size * 1024;",
          "335:  Bytef* decompress_buffer = (Bytef*)wmem_alloc(wmem_packet_scope(), buffer_size);",
          "339:  decompress_stream->avail_out = buffer_size;",
          "342:  if(err != Z_OK) {",
          "343:   proto_item* field = proto_tree_add_string(tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<Error decompressing data>\");",
          "344:   decompress_result_t* data_to_save = wmem_new0(wmem_file_scope(), decompress_result_t);",
          "345:   if(size_overflow && err == Z_DATA_ERROR) {",
          "346:    data_to_save->domain = overflow_error;",
          "347:    expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, buffer too small (%u Kb).  Please adjust in settings.\", max_uncompressed_size);",
          "348:   } else {",
          "349:    data_to_save->domain = zlib_error;",
          "350:    data_to_save->code = err;",
          "351:    expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, got zlib error %d\", err);",
          "352:   }",
          "354:   p_add_proto_data(wmem_file_scope(), pinfo, proto_blip, 0, data_to_save);",
          "361:  if(err != Z_OK) {",
          "362:   proto_item* field = proto_tree_add_string(tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<Error decompressing data>\");",
          "363:   decompress_result_t* data_to_save = wmem_new0(wmem_file_scope(), decompress_result_t);",
          "364:   if(err == Z_BUF_ERROR) {",
          "365:    data_to_save->domain = overflow_error;",
          "366:    size_overflow = TRUE;",
          "367:    expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, buffer too small (%u Kb).  Please adjust in settings.\", max_uncompressed_size);",
          "368:   } else {",
          "369:    data_to_save->domain = zlib_error;",
          "370:    data_to_save->code = err;",
          "371:    expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, got zlib error %d\", err);",
          "372:   }",
          "374:   p_add_proto_data(wmem_file_scope(), pinfo, proto_blip, 0, data_to_save);",
          "381:  Bytef* shortened_buffer = (Bytef *)wmem_memdup(wmem_file_scope(), decompress_buffer, bodyLength);",
          "383:  tvbuff_t* decompressedChild = tvb_new_child_real_data(tvb, shortened_buffer, (guint)bodyLength, (gint)bodyLength);",
          "385:  decompress_result_t* data_to_save = wmem_new0(wmem_file_scope(), decompress_result_t);",
          "387:  data_to_save->buf = shortened_buffer;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "404:  tvbuff_t* tvb_to_use = tvb;",
          "405:  gboolean compressed = is_compressed(value_frame_flags);",
          "406:  if(compressed) {",
          "407: #ifdef HAVE_ZLIB",
          "409:   if(!tvb_to_use) {",
          "411:    return tvb_reported_length(tvb);",
          "412:   }",
          "415:   return tvb_reported_length(tvb);",
          "",
          "[Removed Lines]",
          "408:   tvb_to_use = decompress(pinfo, tvb, offset, tvb_reported_length_remaining(tvb, offset) - BLIP_BODY_CHECKSUM_SIZE);",
          "410:    proto_tree_add_string(blip_tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<Error decompressing message>\");",
          "414:   proto_tree_add_string(blip_tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<decompression support is not available>\");",
          "",
          "[Added Lines]",
          "476:   tvb_to_use = decompress(pinfo, blip_tree, tvb, offset, tvb_reported_length_remaining(tvb, offset) - BLIP_BODY_CHECKSUM_SIZE);",
          "481:   proto_tree_add_string(tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<decompression support is not available>\");",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "527:   &ett_blip",
          "528:  };",
          "530:  proto_blip = proto_register_protocol(\"BLIP Couchbase Mobile\", \"BLIP\", \"blip\");",
          "532:  proto_register_field_array(proto_blip, hf, array_length(hf));",
          "533:  proto_register_subtree_array(ett, array_length(ett));",
          "535:  blip_handle = register_dissector(\"blip\", dissect_blip, proto_blip);",
          "536: }",
          "538: void",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "598:  static ei_register_info ei[] = {",
          "599:   { &ei_blip_decompress_buffer_too_small, { \"blip.decompress_buffer_too_small\", PI_UNDECODED, PI_WARN, \"Decompression buffer size too small\", EXPFILL }}",
          "600:  };",
          "603:  expert_module_t* expert_blip = expert_register_protocol(proto_blip);",
          "607:  expert_register_field_array(expert_blip, ei, array_length(ei));",
          "611: #ifdef HAVE_ZLIB",
          "612:  module_t *blip_module = prefs_register_protocol(proto_blip, NULL);",
          "613:  prefs_register_uint_preference(blip_module, \"max_uncompressed_size\",",
          "614:       \"Maximum uncompressed message size (Kb)\",",
          "615:       \"The maximum size of the buffer for uncompressed messages. \"",
          "616:       \"If a message is larger than this, then the packet containing \"",
          "617:       \"the message, as well as subsequent packets, will fail to \"",
          "618:       \"decompress\", 10, &max_uncompressed_size);",
          "619: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dcc8bbaf9b9689a25e059de5f45ed7e857b4d799",
      "candidate_info": {
        "commit_hash": "dcc8bbaf9b9689a25e059de5f45ed7e857b4d799",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/dcc8bbaf9b9689a25e059de5f45ed7e857b4d799",
        "files": [
          "epan/dissectors/packet-blip.c"
        ],
        "message": "BLIP: Update an expert item.\n\nGeneralize the decompression error field name and description.",
        "before_after_code_files": [
          "epan/dissectors/packet-blip.c||epan/dissectors/packet-blip.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-blip.c||epan/dissectors/packet-blip.c"
          ],
          "candidate": [
            "epan/dissectors/packet-blip.c||epan/dissectors/packet-blip.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-blip.c||epan/dissectors/packet-blip.c": [
          "File: epan/dissectors/packet-blip.c -> epan/dissectors/packet-blip.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "80: static gint ett_blip = -1;",
          "",
          "[Removed Lines]",
          "82: static expert_field ei_blip_decompress_buffer_too_small = EI_INIT;",
          "",
          "[Added Lines]",
          "82: static expert_field ei_blip_decompress_buffer_error = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "297:   if(saved_data->domain) {",
          "298:    proto_item* field = proto_tree_add_string(tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<Error decompressing data>\");",
          "299:    if(saved_data->domain == zlib_error) {",
          "301:    } else {",
          "303:    }",
          "305:    return NULL;",
          "",
          "[Removed Lines]",
          "300:     expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, got zlib error %d\", saved_data->code);",
          "302:     expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, buffer too small (%u Kb).  Please adjust in settings.\", max_uncompressed_size);",
          "",
          "[Added Lines]",
          "300:     expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_error, \"Unable to decompress message, got zlib error %d\", saved_data->code);",
          "302:     expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_error, \"Unable to decompress message, buffer too small (%u Kb).  Please adjust in settings.\", max_uncompressed_size);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "342:   decompress_result_t* data_to_save = wmem_new0(wmem_file_scope(), decompress_result_t);",
          "343:   if(size_overflow && err == Z_DATA_ERROR) {",
          "344:    data_to_save->domain = overflow_error;",
          "346:   } else {",
          "347:    data_to_save->domain = zlib_error;",
          "348:    data_to_save->code = err;",
          "350:   }",
          "352:   p_add_proto_data(wmem_file_scope(), pinfo, proto_blip, 0, data_to_save);",
          "",
          "[Removed Lines]",
          "345:    expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, buffer too small (%u Kb).  Please adjust in settings.\", max_uncompressed_size);",
          "349:    expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, got zlib error %d\", err);",
          "",
          "[Added Lines]",
          "345:    expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_error, \"Unable to decompress message, buffer too small (%u Kb).  Please adjust in settings.\", max_uncompressed_size);",
          "349:    expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_error, \"Unable to decompress message, got zlib error %d\", err);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "362:   if(err == Z_BUF_ERROR) {",
          "363:    data_to_save->domain = overflow_error;",
          "364:    size_overflow = TRUE;",
          "366:   } else {",
          "367:    data_to_save->domain = zlib_error;",
          "368:    data_to_save->code = err;",
          "370:   }",
          "372:   p_add_proto_data(wmem_file_scope(), pinfo, proto_blip, 0, data_to_save);",
          "",
          "[Removed Lines]",
          "365:    expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, buffer too small (%u Kb).  Please adjust in settings.\", max_uncompressed_size);",
          "369:    expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, got zlib error %d\", err);",
          "",
          "[Added Lines]",
          "365:    expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_error, \"Unable to decompress message, buffer too small (%u Kb).  Please adjust in settings.\", max_uncompressed_size);",
          "369:    expert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_error, \"Unable to decompress message, got zlib error %d\", err);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "596:  static ei_register_info ei[] = {",
          "598:  };",
          "600:  proto_blip = proto_register_protocol(\"BLIP Couchbase Mobile\", \"BLIP\", \"blip\");",
          "",
          "[Removed Lines]",
          "597:   { &ei_blip_decompress_buffer_too_small, { \"blip.decompress_buffer_too_small\", PI_UNDECODED, PI_WARN, \"Decompression buffer size too small\", EXPFILL }}",
          "",
          "[Added Lines]",
          "597:   { &ei_blip_decompress_buffer_error, { \"blip.decompress_buffer_error\", PI_UNDECODED, PI_WARN, \"Decompression error\", EXPFILL }}",
          "",
          "---------------"
        ]
      }
    }
  ]
}
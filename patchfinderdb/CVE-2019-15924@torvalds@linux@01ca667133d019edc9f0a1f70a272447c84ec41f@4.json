{
  "cve_id": "CVE-2019-15924",
  "cve_desc": "An issue was discovered in the Linux kernel before 5.0.11. fm10k_init_module in drivers/net/ethernet/intel/fm10k/fm10k_main.c has a NULL pointer dereference because there is no -ENOMEM upon an alloc_workqueue failure.",
  "repo": "torvalds/linux",
  "patch_hash": "01ca667133d019edc9f0a1f70a272447c84ec41f",
  "patch_info": {
    "commit_hash": "01ca667133d019edc9f0a1f70a272447c84ec41f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/01ca667133d019edc9f0a1f70a272447c84ec41f",
    "files": [
      "drivers/net/ethernet/intel/fm10k/fm10k_main.c"
    ],
    "message": "fm10k: Fix a potential NULL pointer dereference\n\nSyzkaller report this:\n\nkasan: GPF could be caused by NULL-ptr deref or user memory access\ngeneral protection fault: 0000 [#1] SMP KASAN PTI\nCPU: 0 PID: 4378 Comm: syz-executor.0 Tainted: G         C        5.0.0+ #5\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nRIP: 0010:__lock_acquire+0x95b/0x3200 kernel/locking/lockdep.c:3573\nCode: 00 0f 85 28 1e 00 00 48 81 c4 08 01 00 00 5b 5d 41 5c 41 5d 41 5e 41 5f c3 4c 89 ea 48 b8 00 00 00 00 00 fc ff df 48 c1 ea 03 <80> 3c 02 00 0f 85 cc 24 00 00 49 81 7d 00 e0 de 03 a6 41 bc 00 00\nRSP: 0018:ffff8881e3c07a40 EFLAGS: 00010002\nRAX: dffffc0000000000 RBX: 0000000000000000 RCX: 0000000000000000\nRDX: 0000000000000010 RSI: 0000000000000000 RDI: 0000000000000080\nRBP: 0000000000000000 R08: 0000000000000001 R09: 0000000000000000\nR10: ffff8881e3c07d98 R11: ffff8881c7f21f80 R12: 0000000000000001\nR13: 0000000000000080 R14: 0000000000000000 R15: 0000000000000001\nFS:  00007fce2252e700(0000) GS:ffff8881f2400000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007fffc7eb0228 CR3: 00000001e5bea002 CR4: 00000000007606f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nPKRU: 55555554\nCall Trace:\n lock_acquire+0xff/0x2c0 kernel/locking/lockdep.c:4211\n __mutex_lock_common kernel/locking/mutex.c:925 [inline]\n __mutex_lock+0xdf/0x1050 kernel/locking/mutex.c:1072\n drain_workqueue+0x24/0x3f0 kernel/workqueue.c:2934\n destroy_workqueue+0x23/0x630 kernel/workqueue.c:4319\n __do_sys_delete_module kernel/module.c:1018 [inline]\n __se_sys_delete_module kernel/module.c:961 [inline]\n __x64_sys_delete_module+0x30c/0x480 kernel/module.c:961\n do_syscall_64+0x9f/0x450 arch/x86/entry/common.c:290\n entry_SYSCALL_64_after_hwframe+0x49/0xbe\nRIP: 0033:0x462e99\nCode: f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fce2252dc58 EFLAGS: 00000246 ORIG_RAX: 00000000000000b0\nRAX: ffffffffffffffda RBX: 000000000073bf00 RCX: 0000000000462e99\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000020000140\nRBP: 0000000000000002 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 00007fce2252e6bc\nR13: 00000000004bcca9 R14: 00000000006f6b48 R15: 00000000ffffffff\n\nIf alloc_workqueue fails, it should return -ENOMEM, otherwise may\ntrigger this NULL pointer dereference while unloading drivers.\n\nReported-by: Hulk Robot <hulkci@huawei.com>\nFixes: 0a38c17a21a0 (\"fm10k: Remove create_workqueue\")\nSigned-off-by: Yue Haibing <yuehaibing@huawei.com>\nTested-by: Andrew Bowers <andrewx.bowers@intel.com>\nSigned-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>",
    "before_after_code_files": [
      "drivers/net/ethernet/intel/fm10k/fm10k_main.c||drivers/net/ethernet/intel/fm10k/fm10k_main.c"
    ]
  },
  "patch_diff": {
    "drivers/net/ethernet/intel/fm10k/fm10k_main.c||drivers/net/ethernet/intel/fm10k/fm10k_main.c": [
      "File: drivers/net/ethernet/intel/fm10k/fm10k_main.c -> drivers/net/ethernet/intel/fm10k/fm10k_main.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "42:  fm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0,",
      "43:        fm10k_driver_name);",
      "45:  fm10k_dbg_init();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "44:  if (!fm10k_workqueue)",
      "45:   return -ENOMEM;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e8c87c643ef3603c6e63bdecb67b03d794648493",
      "candidate_info": {
        "commit_hash": "e8c87c643ef3603c6e63bdecb67b03d794648493",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e8c87c643ef3603c6e63bdecb67b03d794648493",
        "files": [
          "net/sched/act_sample.c",
          "tools/testing/selftests/tc-testing/tc-tests/actions/sample.json"
        ],
        "message": "net/sched: act_sample: validate the control action inside init()\n\nthe following script:\n\n # tc qdisc add dev crash0 clsact\n # tc filter add dev crash0 egress matchall \\\n > action sample rate 1024 group 4 pass index 90\n # tc actions replace action sample \\\n > rate 1024 group 4 goto chain 42 index 90 cookie c1a0c1a0\n # tc actions show action sample\n\nhad the following output:\n\n Error: Failed to init TC action chain.\n We have an error talking to the kernel\n total acts 1\n\n         action order 0: sample rate 1/1024 group 4 goto chain 42\n          index 90 ref 2 bind 1\n         cookie c1a0c1a0\n\nThen, the first packet transmitted by crash0 made the kernel crash:\n\n BUG: unable to handle kernel NULL pointer dereference at 0000000000000000\n #PF error: [normal kernel read fault]\n PGD 8000000079966067 P4D 8000000079966067 PUD 7987b067 PMD 0\n Oops: 0000 [#1] SMP PTI\n CPU: 0 PID: 5 Comm: kworker/0:0 Not tainted 5.0.0-rc4.gotochain_crash+ #536\n Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011\n Workqueue: ipv6_addrconf addrconf_dad_work\n RIP: 0010:tcf_action_exec+0xb8/0x100\n Code: 00 00 00 20 74 1d 83 f8 03 75 09 49 83 c4 08 4d 39 ec 75 bc 48 83 c4 10 5b 5d 41 5c 41 5d 41 5e 41 5f c3 49 8b 97 a8 00 00 00 <48> 8b 12 48 89 55 00 48 83 c4 10 5b 5d 41 5c 41 5d 41 5e 41 5f c3\n RSP: 0018:ffffbee60033fad0 EFLAGS: 00010246\n RAX: 000000002000002a RBX: ffff99d7ae6e3b00 RCX: 00000000e555df9b\n RDX: 0000000000000000 RSI: 00000000b0352718 RDI: ffff99d7fda1fcf0\n RBP: ffffbee60033fb70 R08: 0000000070731ab1 R09: 0000000000000400\n R10: 0000000000000000 R11: ffff99d7ac733838 R12: ffff99d7f3c2be00\n R13: ffff99d7f3c2be08 R14: 0000000000000001 R15: ffff99d7f3c2b600\n FS:  0000000000000000(0000) GS:ffff99d7fda00000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000000000000000 CR3: 00000000797de006 CR4: 00000000001606f0\n Call Trace:\n  tcf_classify+0x58/0x120\n  __dev_queue_xmit+0x40a/0x890\n  ? ndisc_next_option+0x50/0x50\n  ? ___neigh_create+0x4d5/0x680\n  ? ip6_finish_output2+0x1b5/0x590\n  ip6_finish_output2+0x1b5/0x590\n  ? ip6_output+0x68/0x110\n  ip6_output+0x68/0x110\n  ? nf_hook.constprop.28+0x79/0xc0\n  ndisc_send_skb+0x248/0x2e0\n  ndisc_send_ns+0xf8/0x200\n  ? addrconf_dad_work+0x389/0x4b0\n  addrconf_dad_work+0x389/0x4b0\n  ? __switch_to_asm+0x34/0x70\n  ? process_one_work+0x195/0x380\n  ? addrconf_dad_completed+0x370/0x370\n  process_one_work+0x195/0x380\n  worker_thread+0x30/0x390\n  ? process_one_work+0x380/0x380\n  kthread+0x113/0x130\n  ? kthread_park+0x90/0x90\n  ret_from_fork+0x35/0x40\n Modules linked in: act_sample psample veth ip6table_filter ip6_tables iptable_filter binfmt_misc ext4 crct10dif_pclmul crc32_pclmul ghash_clmulni_intel mbcache jbd2 snd_hda_codec_generic snd_hda_intel snd_hda_codec snd_hwdep snd_hda_core snd_seq snd_seq_device aesni_intel crypto_simd snd_pcm cryptd glue_helper snd_timer joydev snd pcspkr virtio_balloon i2c_piix4 soundcore nfsd auth_rpcgss nfs_acl lockd grace sunrpc ip_tables xfs ata_generic pata_acpi qxl drm_kms_helper syscopyarea sysfillrect virtio_net sysimgblt fb_sys_fops net_failover ttm failover virtio_blk virtio_console drm ata_piix serio_raw crc32c_intel libata virtio_pci virtio_ring virtio floppy dm_mirror dm_region_hash dm_log dm_mod\n CR2: 0000000000000000\n\nValidating the control action within tcf_sample_init() proved to fix the\nabove issue. A TDC selftest is added to verify the correct behavior.\n\nFixes: db50514f9a9c (\"net: sched: add termination action to allow goto chain\")\nFixes: 97763dc0f401 (\"net_sched: reject unknown tcfa_action values\")\nSigned-off-by: Davide Caratti <dcaratti@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/sched/act_sample.c||net/sched/act_sample.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/sched/act_sample.c||net/sched/act_sample.c": [
          "File: net/sched/act_sample.c -> net/sched/act_sample.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #include <linux/tc_act/tc_sample.h>",
          "23: #include <net/tc_act/tc_sample.h>",
          "24: #include <net/psample.h>",
          "26: #include <linux/if_arp.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #include <net/pkt_cls.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "43:  struct tc_action_net *tn = net_generic(net, sample_net_id);",
          "44:  struct nlattr *tb[TCA_SAMPLE_MAX + 1];",
          "45:  struct psample_group *psample_group;",
          "46:  struct tc_sample *parm;",
          "47:  u32 psample_group_num;",
          "48:  struct tcf_sample *s;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47:  struct tcf_chain *goto_ch = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "79:   tcf_idr_release(*a, bind);",
          "80:   return -EEXIST;",
          "81:  }",
          "83:  psample_group_num = nla_get_u32(tb[TCA_SAMPLE_PSAMPLE_GROUP]);",
          "84:  psample_group = psample_group_get(net, psample_group_num);",
          "85:  if (!psample_group) {",
          "88:  }",
          "90:  s = to_sample(*a);",
          "92:  spin_lock_bh(&s->tcf_lock);",
          "94:  s->rate = nla_get_u32(tb[TCA_SAMPLE_RATE]);",
          "95:  s->psample_group_num = psample_group_num;",
          "96:  RCU_INIT_POINTER(s->psample_group, psample_group);",
          "",
          "[Removed Lines]",
          "86:   tcf_idr_release(*a, bind);",
          "87:   return -ENOMEM;",
          "93:  s->tcf_action = parm->action;",
          "",
          "[Added Lines]",
          "84:  err = tcf_action_check_ctrlact(parm->action, tp, &goto_ch, extack);",
          "85:  if (err < 0)",
          "86:   goto release_idr;",
          "91:   err = -ENOMEM;",
          "92:   goto put_chain;",
          "98:  goto_ch = tcf_action_set_ctrlact(*a, parm->action, goto_ch);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "100:   s->trunc_size = nla_get_u32(tb[TCA_SAMPLE_TRUNC_SIZE]);",
          "101:  }",
          "102:  spin_unlock_bh(&s->tcf_lock);",
          "104:  if (ret == ACT_P_CREATED)",
          "105:   tcf_idr_insert(tn, *a);",
          "106:  return ret;",
          "107: }",
          "109: static void tcf_sample_cleanup(struct tc_action *a)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "108:  if (goto_ch)",
          "109:   tcf_chain_put_by_act(goto_ch);",
          "114: put_chain:",
          "115:  if (goto_ch)",
          "116:   tcf_chain_put_by_act(goto_ch);",
          "117: release_idr:",
          "118:  tcf_idr_release(*a, bind);",
          "119:  return err;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "23da9588037ecdd4901db76a5b79a42b529c4ec3",
      "candidate_info": {
        "commit_hash": "23da9588037ecdd4901db76a5b79a42b529c4ec3",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/23da9588037ecdd4901db76a5b79a42b529c4ec3",
        "files": [
          "fs/proc/proc_sysctl.c"
        ],
        "message": "fs/proc/proc_sysctl.c: fix NULL pointer dereference in put_links\n\nSyzkaller reports:\n\nkasan: GPF could be caused by NULL-ptr deref or user memory access\ngeneral protection fault: 0000 [#1] SMP KASAN PTI\nCPU: 1 PID: 5373 Comm: syz-executor.0 Not tainted 5.0.0-rc8+ #3\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nRIP: 0010:put_links+0x101/0x440 fs/proc/proc_sysctl.c:1599\nCode: 00 0f 85 3a 03 00 00 48 8b 43 38 48 89 44 24 20 48 83 c0 38 48 89 c2 48 89 44 24 28 48 b8 00 00 00 00 00 fc ff df 48 c1 ea 03 <80> 3c 02 00 0f 85 fe 02 00 00 48 8b 74 24 20 48 c7 c7 60 2a 9d 91\nRSP: 0018:ffff8881d828f238 EFLAGS: 00010202\nRAX: dffffc0000000000 RBX: ffff8881e01b1140 RCX: ffffffff8ee98267\nRDX: 0000000000000007 RSI: ffffc90001479000 RDI: ffff8881e01b1178\nRBP: dffffc0000000000 R08: ffffed103ee27259 R09: ffffed103ee27259\nR10: 0000000000000001 R11: ffffed103ee27258 R12: fffffffffffffff4\nR13: 0000000000000006 R14: ffff8881f59838c0 R15: dffffc0000000000\nFS:  00007f072254f700(0000) GS:ffff8881f7100000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007fff8b286668 CR3: 00000001f0542002 CR4: 00000000007606e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nPKRU: 55555554\nCall Trace:\n drop_sysctl_table+0x152/0x9f0 fs/proc/proc_sysctl.c:1629\n get_subdir fs/proc/proc_sysctl.c:1022 [inline]\n __register_sysctl_table+0xd65/0x1090 fs/proc/proc_sysctl.c:1335\n br_netfilter_init+0xbc/0x1000 [br_netfilter]\n do_one_initcall+0xfa/0x5ca init/main.c:887\n do_init_module+0x204/0x5f6 kernel/module.c:3460\n load_module+0x66b2/0x8570 kernel/module.c:3808\n __do_sys_finit_module+0x238/0x2a0 kernel/module.c:3902\n do_syscall_64+0x147/0x600 arch/x86/entry/common.c:290\n entry_SYSCALL_64_after_hwframe+0x49/0xbe\nRIP: 0033:0x462e99\nCode: f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f072254ec58 EFLAGS: 00000246 ORIG_RAX: 0000000000000139\nRAX: ffffffffffffffda RBX: 000000000073bf00 RCX: 0000000000462e99\nRDX: 0000000000000000 RSI: 0000000020000280 RDI: 0000000000000003\nRBP: 00007f072254ec70 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 00007f072254f6bc\nR13: 00000000004bcefa R14: 00000000006f6fb0 R15: 0000000000000004\nModules linked in: br_netfilter(+) dvb_usb_dibusb_mc_common dib3000mc dibx000_common dvb_usb_dibusb_common dvb_usb_dw2102 dvb_usb classmate_laptop palmas_regulator cn videobuf2_v4l2 v4l2_common snd_soc_bd28623 mptbase snd_usb_usx2y snd_usbmidi_lib snd_rawmidi wmi libnvdimm lockd sunrpc grace rc_kworld_pc150u rc_core rtc_da9063 sha1_ssse3 i2c_cros_ec_tunnel adxl34x_spi adxl34x nfnetlink lib80211 i5500_temp dvb_as102 dvb_core videobuf2_common videodev media videobuf2_vmalloc videobuf2_memops udc_core lnbp22 leds_lp3952 hid_roccat_ryos s1d13xxxfb mtd vport_geneve openvswitch nf_conncount nf_nat_ipv6 nsh geneve udp_tunnel ip6_udp_tunnel snd_soc_mt6351 sis_agp phylink snd_soc_adau1761_spi snd_soc_adau1761 snd_soc_adau17x1 snd_soc_core snd_pcm_dmaengine ac97_bus snd_compress snd_soc_adau_utils snd_soc_sigmadsp_regmap snd_soc_sigmadsp raid_class hid_roccat_konepure hid_roccat_common hid_roccat c2port_duramar2150 core mdio_bcm_unimac iptable_security iptable_raw iptable_mangle\n iptable_nat nf_nat_ipv4 nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 iptable_filter bpfilter ip6_vti ip_vti ip_gre ipip sit tunnel4 ip_tunnel hsr veth netdevsim devlink vxcan batman_adv cfg80211 rfkill chnl_net caif nlmon dummy team bonding vcan bridge stp llc ip6_gre gre ip6_tunnel tunnel6 tun crct10dif_pclmul crc32_pclmul crc32c_intel ghash_clmulni_intel joydev mousedev ide_pci_generic piix aesni_intel aes_x86_64 ide_core crypto_simd atkbd cryptd glue_helper serio_raw ata_generic pata_acpi i2c_piix4 floppy sch_fq_codel ip_tables x_tables ipv6 [last unloaded: lm73]\nDumping ftrace buffer:\n   (ftrace buffer empty)\n---[ end trace 770020de38961fd0 ]---\n\nA new dir entry can be created in get_subdir and its 'header->parent' is\nset to NULL.  Only after insert_header success, it will be set to 'dir',\notherwise 'header->parent' is set to NULL and drop_sysctl_table is called.\nHowever in err handling path of get_subdir, drop_sysctl_table also be\ncalled on 'new->header' regardless its value of parent pointer.  Then\nput_links is called, which triggers NULL-ptr deref when access member of\nheader->parent.\n\nIn fact we have multiple error paths which call drop_sysctl_table() there,\nupon failure on insert_links() we also call drop_sysctl_table().And even\nin the successful case on __register_sysctl_table() we still always call\ndrop_sysctl_table().This patch fix it.\n\nLink: http://lkml.kernel.org/r/20190314085527.13244-1-yuehaibing@huawei.com\nFixes: 0e47c99d7fe25 (\"sysctl: Replace root_list with links between sysctl_table_sets\")\nSigned-off-by: YueHaibing <yuehaibing@huawei.com>\nReported-by: Hulk Robot <hulkci@huawei.com>\nAcked-by: Luis Chamberlain <mcgrof@kernel.org>\nCc: Kees Cook <keescook@chromium.org>\nCc: Alexey Dobriyan <adobriyan@gmail.com>\nCc: Alexei Starovoitov <ast@kernel.org>\nCc: Daniel Borkmann <daniel@iogearbox.net>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Eric W. Biederman <ebiederm@xmission.com>\nCc: <stable@vger.kernel.org>    [3.4+]\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/proc/proc_sysctl.c||fs/proc/proc_sysctl.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/proc/proc_sysctl.c||fs/proc/proc_sysctl.c": [
          "File: fs/proc/proc_sysctl.c -> fs/proc/proc_sysctl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1626:  if (--header->nreg)",
          "1627:   return;",
          "1630:  start_unregistering(header);",
          "1631:  if (!--header->count)",
          "1632:   kfree_rcu(header, rcu);",
          "",
          "[Removed Lines]",
          "1629:  put_links(header);",
          "",
          "[Added Lines]",
          "1629:  if (parent)",
          "1630:   put_links(header);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d9470757398a700d9450a43508000bcfd010c7a4",
      "candidate_info": {
        "commit_hash": "d9470757398a700d9450a43508000bcfd010c7a4",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d9470757398a700d9450a43508000bcfd010c7a4",
        "files": [
          "arch/powerpc/lib/memcmp_64.S"
        ],
        "message": "powerpc/64: Fix memcmp reading past the end of src/dest\n\nChandan reported that fstests' generic/026 test hit a crash:\n\n  BUG: Unable to handle kernel data access at 0xc00000062ac40000\n  Faulting instruction address: 0xc000000000092240\n  Oops: Kernel access of bad area, sig: 11 [#1]\n  LE SMP NR_CPUS=2048 DEBUG_PAGEALLOC NUMA pSeries\n  CPU: 0 PID: 27828 Comm: chacl Not tainted 5.0.0-rc2-next-20190115-00001-g6de6dba64dda #1\n  NIP:  c000000000092240 LR: c00000000066a55c CTR: 0000000000000000\n  REGS: c00000062c0c3430 TRAP: 0300   Not tainted  (5.0.0-rc2-next-20190115-00001-g6de6dba64dda)\n  MSR:  8000000002009033 <SF,VEC,EE,ME,IR,DR,RI,LE>  CR: 44000842  XER: 20000000\n  CFAR: 00007fff7f3108ac DAR: c00000062ac40000 DSISR: 40000000 IRQMASK: 0\n  GPR00: 0000000000000000 c00000062c0c36c0 c0000000017f4c00 c00000000121a660\n  GPR04: c00000062ac3fff9 0000000000000004 0000000000000020 00000000275b19c4\n  GPR08: 000000000000000c 46494c4500000000 5347495f41434c5f c0000000026073a0\n  GPR12: 0000000000000000 c0000000027a0000 0000000000000000 0000000000000000\n  GPR16: 0000000000000000 0000000000000000 0000000000000000 0000000000000000\n  GPR20: c00000062ea70020 c00000062c0c38d0 0000000000000002 0000000000000002\n  GPR24: c00000062ac3ffe8 00000000275b19c4 0000000000000001 c00000062ac30000\n  GPR28: c00000062c0c38d0 c00000062ac30050 c00000062ac30058 0000000000000000\n  NIP memcmp+0x120/0x690\n  LR  xfs_attr3_leaf_lookup_int+0x53c/0x5b0\n  Call Trace:\n    xfs_attr3_leaf_lookup_int+0x78/0x5b0 (unreliable)\n    xfs_da3_node_lookup_int+0x32c/0x5a0\n    xfs_attr_node_addname+0x170/0x6b0\n    xfs_attr_set+0x2ac/0x340\n    __xfs_set_acl+0xf0/0x230\n    xfs_set_acl+0xd0/0x160\n    set_posix_acl+0xc0/0x130\n    posix_acl_xattr_set+0x68/0x110\n    __vfs_setxattr+0xa4/0x110\n    __vfs_setxattr_noperm+0xac/0x240\n    vfs_setxattr+0x128/0x130\n    setxattr+0x248/0x600\n    path_setxattr+0x108/0x120\n    sys_setxattr+0x28/0x40\n    system_call+0x5c/0x70\n  Instruction dump:\n  7d201c28 7d402428 7c295040 38630008 38840008 408201f0 4200ffe8 2c050000\n  4182ff6c 20c50008 54c61838 7d201c28 <7d402428> 7d293436 7d4a3436 7c295040\n\nThe instruction dump decodes as:\n  subfic  r6,r5,8\n  rlwinm  r6,r6,3,0,28\n  ldbrx   r9,0,r3\n  ldbrx   r10,0,r4      <-\n\nWhich shows us doing an 8 byte load from c00000062ac3fff9, which\ncrosses the page boundary at c00000062ac40000 and faults.\n\nIt's not OK for memcmp to read past the end of the source or\ndestination buffers if that would cross a page boundary, because we\ndon't know that the next page is mapped.\n\nAs pointed out by Segher, we can read past the end of the source or\ndestination as long as we don't cross a 4K boundary, because that's\nour minimum page size on all platforms.\n\nThe bug is in the code at the .Lcmp_rest_lt8bytes label. When we get\nthere we know that s1 is 8-byte aligned and we have at least 1 byte to\nread, so a single 8-byte load won't read past the end of s1 and cross\na page boundary.\n\nBut we have to be more careful with s2. So check if it's within 8\nbytes of a 4K boundary and if so go to the byte-by-byte loop.\n\nFixes: 2d9ee327adce (\"powerpc/64: Align bytes before fall back to .Lshort in powerpc64 memcmp()\")\nCc: stable@vger.kernel.org # v4.19+\nReported-by: Chandan Rajendra <chandan@linux.ibm.com>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>\nReviewed-by: Segher Boessenkool <segher@kernel.crashing.org>\nTested-by: Chandan Rajendra <chandan@linux.ibm.com>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>",
        "before_after_code_files": [
          "arch/powerpc/lib/memcmp_64.S||arch/powerpc/limemcmp_64.S"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/powerpc/lib/memcmp_64.S||arch/powerpc/limemcmp_64.S": [
          "File: arch/powerpc/lib/memcmp_64.S -> arch/powerpc/limemcmp_64.S",
          "--- Hunk 1 ---",
          "[Context before]",
          "215:  beq .Lzero",
          "217: .Lcmp_rest_lt8bytes:",
          "223:  subfic  r6,r5,8",
          "224:  slwi r6,r6,3",
          "225:  LD rA,0,r3",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c5e06ba2f76809ad1492fdad312e81335df46bc5",
      "candidate_info": {
        "commit_hash": "c5e06ba2f76809ad1492fdad312e81335df46bc5",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c5e06ba2f76809ad1492fdad312e81335df46bc5",
        "files": [
          "drivers/scsi/qedf/qedf_io.c"
        ],
        "message": "scsi: qedf: Add missing return in qedf_post_io_req() in the fcport offload check\n\nFixes the following crash as the return was missing from the check if an\nfcport is offloaded. If we hit this code we continue to try to post an\ninvalid task which can lead to the crash:\n\n[30259.616411] [0000:61:00.3]:[qedf_post_io_req:989]:3: Session not offloaded yet.\n[30259.616413] [0000:61:00.3]:[qedf_upload_connection:1340]:3: Uploading connection port_id=490020.\n[30259.623769] BUG: unable to handle kernel NULL pointer dereference at 0000000000000198\n[30259.631645] IP: [<ffffffffc035b1ed>] qedf_init_task.isra.16+0x3d/0x450 [qedf]\n[30259.638816] PGD 0\n[30259.640841] Oops: 0000 [#1] SMP\n[30259.644098] Modules linked in: fuse xt_CHECKSUM iptable_mangle ipt_MASQUERADE nf_nat_masquerade_ipv4 iptable_nat nf_nat_ipv4 nf_nat nf_conntrack_ipv4 nf_defrag_ipv4 xt_conntrack nf_conntrack ipt_REJECT nf_reject_ipv4 tun bridge stp llc ebtable_filter ebtables devlink ip6table_filter ip6_tables iptable_filter vfat fat ib_isert iscsi_target_mod ib_srpt target_core_mod ib_srp scsi_transport_srp ib_ipoib ib_ucm ib_umad dm_service_time skx_edac intel_powerclamp coretemp intel_rapl iosf_mbi kvm_intel kvm irqbypass crc32_pclmul ghash_clmulni_intel aesni_intel rpcrdma sunrpc rdma_ucm ib_uverbs lrw gf128mul ib_iser rdma_cm iw_cm ib_cm libiscsi scsi_transport_iscsi qedr(OE) glue_helper ablk_helper cryptd ib_core dm_round_robin joydev pcspkr ipmi_ssif ses enclosure ipmi_si ipmi_devintf ipmi_msghandler mei_me\n[30259.715529]  mei sg hpilo hpwdt shpchp wmi lpc_ich acpi_power_meter dm_multipath ip_tables xfs libcrc32c sd_mod crc_t10dif crct10dif_generic uas usb_storage mgag200 qedf(OE) i2c_algo_bit libfcoe drm_kms_helper libfc syscopyarea sysfillrect scsi_transport_fc qede(OE) sysimgblt fb_sys_fops ptp ttm pps_core drm qed(OE) smartpqi crct10dif_pclmul crct10dif_common crc32c_intel i2c_core scsi_transport_sas scsi_tgt dm_mirror dm_region_hash dm_log dm_mod\n[30259.754237] CPU: 9 PID: 977 Comm: kdmwork-253:7 Kdump: loaded Tainted: G        W  OE  ------------   3.10.0-862.el7.x86_64 #1\n[30259.765664] Hardware name: HPE Synergy 480 Gen10/Synergy 480 Gen10 Compute Module, BIOS I42 04/04/2018\n[30259.775000] task: ffff8c801efd0000 ti: ffff8c801efd8000 task.ti: ffff8c801efd8000\n[30259.782505] RIP: 0010:[<ffffffffc035b1ed>]  [<ffffffffc035b1ed>] qedf_init_task.isra.16+0x3d/0x450 [qedf]\n[30259.792116] RSP: 0018:ffff8c801efdbbb0  EFLAGS: 00010046\n[30259.797444] RAX: 0000000000000000 RBX: ffffa7f1450948d8 RCX: ffff8c7fe5bc40c8\n[30259.804600] RDX: ffff8c800715b300 RSI: ffffa7f1450948d8 RDI: ffff8c80169c2480\n[30259.811755] RBP: ffff8c801efdbc30 R08: 00000000000000ae R09: ffff8c800a314540\n[30259.818911] R10: ffff8c7fe5bc40c8 R11: ffff8c801efdb8ae R12: 0000000000000000\n[30259.826068] R13: ffff8c800715b300 R14: ffff8c80169c2480 R15: ffff8c8005da28e0\n[30259.833223] FS:  0000000000000000(0000) GS:ffff8c803f840000(0000) knlGS:0000000000000000\n[30259.841338] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[30259.847100] CR2: 0000000000000198 CR3: 000000081242e000 CR4: 00000000007607e0\n[30259.854256] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[30259.861412] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[30259.868568] PKRU: 00000000\n[30259.871278] Call Trace:\n[30259.873737]  [<ffffffffc035c948>] qedf_post_io_req+0x148/0x680 [qedf]\n[30259.880201]  [<ffffffffc035d070>] qedf_queuecommand+0x1f0/0x240 [qedf]\n[30259.886749]  [<ffffffffa329b050>] scsi_dispatch_cmd+0xb0/0x240\n[30259.892600]  [<ffffffffa32a45bc>] scsi_request_fn+0x4cc/0x680\n[30259.898364]  [<ffffffffa3118ad9>] __blk_run_queue+0x39/0x50\n[30259.903954]  [<ffffffffa3114393>] __elv_add_request+0xd3/0x260\n[30259.909805]  [<ffffffffa311baf0>] blk_insert_cloned_request+0xf0/0x1b0\n[30259.916358]  [<ffffffffc010b622>] map_request+0x142/0x220 [dm_mod]\n[30259.922560]  [<ffffffffc010b716>] map_tio_request+0x16/0x40 [dm_mod]\n[30259.928932]  [<ffffffffa2ebb1f5>] kthread_worker_fn+0x85/0x180\n[30259.934782]  [<ffffffffa2ebb170>] ? kthread_stop+0xf0/0xf0\n[30259.940284]  [<ffffffffa2ebae31>] kthread+0xd1/0xe0\n[30259.945176]  [<ffffffffa2ebad60>] ? insert_kthread_work+0x40/0x40\n[30259.951290]  [<ffffffffa351f61d>] ret_from_fork_nospec_begin+0x7/0x21\n[30259.957750]  [<ffffffffa2ebad60>] ? insert_kthread_work+0x40/0x40\n[30259.963860] Code: fe 41 55 49 89 d5 41 54 53 48 89 f3 48 83 ec 58 4c 8b 67 28 4c 8b 4e 18 65 48 8b 04 25 28 00 00 00 48 89 45 d0 31 c0 4c 8b 7e 58 <49> 8b 84 24 98 01 00 00 48 8b 00 f6 80 31 01 00 00 10 0f 85 0b\n[30259.983372] RIP  [<ffffffffc035b1ed>] qedf_init_task.isra.16+0x3d/0x450 [qedf]\n[30259.990630]  RSP <ffff8c801efdbbb0>\n[30259.994127] CR2: 0000000000000198\n\nSigned-off-by: Chad Dupuis <cdupuis@marvell.com>\nSigned-off-by: Saurav Kashyap <skashyap@marvell.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
        "before_after_code_files": [
          "drivers/scsi/qedf/qedf_io.c||drivers/scsi/qedf/qedf_io.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/scsi/qedf/qedf_io.c||drivers/scsi/qedf/qedf_io.c": [
          "File: drivers/scsi/qedf/qedf_io.c -> drivers/scsi/qedf/qedf_io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "902:  if (!test_bit(QEDF_RPORT_SESSION_READY, &fcport->flags)) {",
          "903:   QEDF_ERR(&(qedf->dbg_ctx), \"Session not offloaded yet.\\n\");",
          "904:   kref_put(&io_req->refcount, qedf_release_cmd);",
          "905:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "905:   return -EINVAL;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ff9721d32b1aba8bf46a06df20827d0a5d52ec48",
      "candidate_info": {
        "commit_hash": "ff9721d32b1aba8bf46a06df20827d0a5d52ec48",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ff9721d32b1aba8bf46a06df20827d0a5d52ec48",
        "files": [
          "net/sched/act_mirred.c",
          "tools/testing/selftests/tc-testing/tc-tests/actions/mirred.json"
        ],
        "message": "net/sched: act_mirred: validate the control action inside init()\n\nthe following script:\n\n # tc qdisc add dev crash0 clsact\n # tc filter add dev crash0 egress matchall \\\n > action mirred ingress mirror dev lo pass\n # tc actions replace action mirred \\\n > ingress mirror dev lo goto chain 42 index 90 cookie c1a0c1a0\n # tc actions show action mirred\n\nhad the following output:\n\n Error: Failed to init TC action chain.\n We have an error talking to the kernel\n total acts 1\n\n         action order 0: mirred (Ingress Mirror to device lo) goto chain 42\n         index 90 ref 2 bind 1\n         cookie c1a0c1a0\n\nThen, the first packet transmitted by crash0 made the kernel crash:\n\n Mirror/redirect action on\n BUG: unable to handle kernel NULL pointer dereference at 0000000000000000\n #PF error: [normal kernel read fault]\n PGD 0 P4D 0\n Oops: 0000 [#1] SMP PTI\n CPU: 3 PID: 47 Comm: kworker/3:1 Not tainted 5.0.0-rc4.gotochain_crash+ #533\n Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011\n Workqueue: ipv6_addrconf addrconf_dad_work\n RIP: 0010:tcf_action_exec+0xb8/0x100\n Code: 00 00 00 20 74 1d 83 f8 03 75 09 49 83 c4 08 4d 39 ec 75 bc 48 83 c4 10 5b 5d 41 5c 41 5d 41 5e 41 5f c3 49 8b 97 a8 00 00 00 <48> 8b 12 48 89 55 00 48 83 c4 10 5b 5d 41 5c 41 5d 41 5e 41 5f c3\n RSP: 0018:ffffa772404b7ad0 EFLAGS: 00010246\n RAX: 000000002000002a RBX: ffff9c5afc3f4300 RCX: 0000000000000000\n RDX: 0000000000000000 RSI: ffff9c5afdba9380 RDI: 0000000000029380\n RBP: ffffa772404b7b70 R08: ffff9c5af7010028 R09: ffff9c5af7010029\n R10: 0000000000000000 R11: ffff9c5af94c6a38 R12: ffff9c5af7953000\n R13: ffff9c5af7953008 R14: 0000000000000001 R15: ffff9c5af7953d00\n FS:  0000000000000000(0000) GS:ffff9c5afdb80000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000000000000000 CR3: 000000007c514004 CR4: 00000000001606e0\n Call Trace:\n  tcf_classify+0x58/0x120\n  __dev_queue_xmit+0x40a/0x890\n  ? ndisc_next_option+0x50/0x50\n  ? ___neigh_create+0x4d5/0x680\n  ? ip6_finish_output2+0x1b5/0x590\n  ip6_finish_output2+0x1b5/0x590\n  ? ip6_output+0x68/0x110\n  ip6_output+0x68/0x110\n  ? nf_hook.constprop.28+0x79/0xc0\n  ndisc_send_skb+0x248/0x2e0\n  ndisc_send_ns+0xf8/0x200\n  ? addrconf_dad_work+0x389/0x4b0\n  addrconf_dad_work+0x389/0x4b0\n  ? __switch_to_asm+0x34/0x70\n  ? process_one_work+0x195/0x380\n  ? addrconf_dad_completed+0x370/0x370\n  process_one_work+0x195/0x380\n  worker_thread+0x30/0x390\n  ? process_one_work+0x380/0x380\n  kthread+0x113/0x130\n  ? kthread_park+0x90/0x90\n  ret_from_fork+0x35/0x40\n Modules linked in: act_mirred veth ip6table_filter ip6_tables iptable_filter binfmt_misc ext4 crct10dif_pclmul snd_hda_codec_generic crc32_pclmul snd_hda_intel snd_hda_codec mbcache ghash_clmulni_intel jbd2 snd_hwdep snd_hda_core snd_seq snd_seq_device snd_pcm aesni_intel snd_timer snd crypto_simd cryptd glue_helper soundcore virtio_balloon joydev pcspkr i2c_piix4 nfsd auth_rpcgss nfs_acl lockd grace sunrpc ip_tables xfs ata_generic pata_acpi qxl drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops virtio_net ttm virtio_blk net_failover virtio_console failover drm ata_piix crc32c_intel virtio_pci serio_raw libata virtio_ring virtio floppy dm_mirror dm_region_hash dm_log dm_mod\n CR2: 0000000000000000\n\nValidating the control action within tcf_mirred_init() proved to fix the\nabove issue. For the same reason, postpone the assignment of tcfa_action\nand tcfm_eaction to avoid partial reconfiguration of a mirred rule when\nit's replaced by another one that mirrors to a device that does not\nexist. A TDC selftest is added to verify the correct behavior.\n\nFixes: db50514f9a9c (\"net: sched: add termination action to allow goto chain\")\nFixes: 97763dc0f401 (\"net_sched: reject unknown tcfa_action values\")\nSigned-off-by: Davide Caratti <dcaratti@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/sched/act_mirred.c||net/sched/act_mirred.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/sched/act_mirred.c||net/sched/act_mirred.c": [
          "File: net/sched/act_mirred.c -> net/sched/act_mirred.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "99: {",
          "100:  struct tc_action_net *tn = net_generic(net, mirred_net_id);",
          "101:  struct nlattr *tb[TCA_MIRRED_MAX + 1];",
          "102:  bool mac_header_xmit = false;",
          "103:  struct tc_mirred *parm;",
          "104:  struct tcf_mirred *m;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "102:  struct tcf_chain *goto_ch = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "158:   tcf_idr_release(*a, bind);",
          "159:   return -EEXIST;",
          "160:  }",
          "161:  m = to_mirred(*a);",
          "163:  spin_lock_bh(&m->tcf_lock);",
          "167:  if (parm->ifindex) {",
          "168:   dev = dev_get_by_index(net, parm->ifindex);",
          "169:   if (!dev) {",
          "170:    spin_unlock_bh(&m->tcf_lock);",
          "173:   }",
          "174:   mac_header_xmit = dev_is_mac_header_xmit(dev);",
          "175:   rcu_swap_protected(m->tcfm_dev, dev,",
          "",
          "[Removed Lines]",
          "164:  m->tcf_action = parm->action;",
          "165:  m->tcfm_eaction = parm->eaction;",
          "171:    tcf_idr_release(*a, bind);",
          "172:    return -ENODEV;",
          "",
          "[Added Lines]",
          "162:  err = tcf_action_check_ctrlact(parm->action, tp, &goto_ch, extack);",
          "163:  if (err < 0)",
          "164:   goto release_idr;",
          "174:    err = -ENODEV;",
          "175:    goto put_chain;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "178:    dev_put(dev);",
          "179:   m->tcfm_mac_header_xmit = mac_header_xmit;",
          "180:  }",
          "181:  spin_unlock_bh(&m->tcf_lock);",
          "183:  if (ret == ACT_P_CREATED) {",
          "184:   spin_lock(&mirred_list_lock);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "184:  goto_ch = tcf_action_set_ctrlact(*a, parm->action, goto_ch);",
          "185:  m->tcfm_eaction = parm->eaction;",
          "187:  if (goto_ch)",
          "188:   tcf_chain_put_by_act(goto_ch);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "189:  }",
          "191:  return ret;",
          "192: }",
          "194: static int tcf_mirred_act(struct sk_buff *skb, const struct tc_action *a,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "199: put_chain:",
          "200:  if (goto_ch)",
          "201:   tcf_chain_put_by_act(goto_ch);",
          "202: release_idr:",
          "203:  tcf_idr_release(*a, bind);",
          "204:  return err;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
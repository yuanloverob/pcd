{
  "cve_id": "CVE-2018-6346",
  "cve_desc": "A potential denial-of-service issue in the Proxygen handling of invalid HTTP2 priority settings (specifically a circular dependency). This affects Proxygen prior to v2018.12.31.00.",
  "repo": "facebook/proxygen",
  "patch_hash": "52cf331743ebd74194d6343a6c2ec52bb917c982",
  "patch_info": {
    "commit_hash": "52cf331743ebd74194d6343a6c2ec52bb917c982",
    "repo": "facebook/proxygen",
    "commit_url": "https://github.com/facebook/proxygen/commit/52cf331743ebd74194d6343a6c2ec52bb917c982",
    "files": [
      "proxygen/lib/http/codec/HTTP2Codec.cpp",
      "proxygen/lib/http/codec/test/HTTP2CodecTest.cpp"
    ],
    "message": "Fix h2 codec state after bad priority header.\n\nSummary:\nIt's possible for the http2 codec to enter an invalid state after processing a http2 header with invalid priorities.\nCVE-2018-6346\n\nReviewed By: maxgeorg\n\nDifferential Revision: D13510025\n\nfbshipit-source-id: 7c4e42daf1cd2b912454d13a66ab8488d1863263",
    "before_after_code_files": [
      "proxygen/lib/http/codec/HTTP2Codec.cpp||proxygen/lib/http/codec/HTTP2Codec.cpp",
      "proxygen/lib/http/codec/test/HTTP2CodecTest.cpp||proxygen/lib/http/codec/test/HTTP2CodecTest.cpp"
    ]
  },
  "patch_diff": {
    "proxygen/lib/http/codec/HTTP2Codec.cpp||proxygen/lib/http/codec/HTTP2Codec.cpp": [
      "File: proxygen/lib/http/codec/HTTP2Codec.cpp -> proxygen/lib/http/codec/HTTP2Codec.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "514:     isReq = transportDirection_ == TransportDirection::DOWNSTREAM;",
      "515:   }",
      "517:   decodeInfo_.init(isReq, parsingDownstreamTrailers_);",
      "518:   if (priority) {",
      "527:     decodeInfo_.msg->setHTTP2Priority(",
      "528:         std::make_tuple(priority->streamDependency,",
      "529:                         priority->exclusive,",
      "530:                         priority->weight));",
      "531:   }",
      "532:   headerCodec_.decodeStreaming(",
      "533:       headerCursor, curHeaderBlock_.chainLength(), this);",
      "534:   msg = std::move(decodeInfo_.msg);",
      "",
      "[Removed Lines]",
      "519:     if (curHeader_.stream == priority->streamDependency) {",
      "520:       streamError(folly::to<string>(\"Circular dependency for txn=\",",
      "521:                                     curHeader_.stream),",
      "522:                   ErrorCode::PROTOCOL_ERROR,",
      "523:                   curHeader_.type == http2::FrameType::HEADERS);",
      "524:       return ErrorCode::NO_ERROR;",
      "525:     }",
      "",
      "[Added Lines]",
      "518:   if (priority && (curHeader_.stream == priority->streamDependency)) {",
      "519:     streamError(",
      "520:         folly::to<string>(\"Circular dependency for txn=\", curHeader_.stream),",
      "521:         ErrorCode::PROTOCOL_ERROR,",
      "522:         curHeader_.type == http2::FrameType::HEADERS);",
      "523:     return ErrorCode::NO_ERROR;",
      "524:   }",
      "",
      "---------------"
    ],
    "proxygen/lib/http/codec/test/HTTP2CodecTest.cpp||proxygen/lib/http/codec/test/HTTP2CodecTest.cpp": [
      "File: proxygen/lib/http/codec/test/HTTP2CodecTest.cpp -> proxygen/lib/http/codec/test/HTTP2CodecTest.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "1377:   EXPECT_EQ(callbacks_.sessionErrors, 0);",
      "1378: }",
      "1380: TEST_F(HTTP2CodecTest, BadPriority) {",
      "1381:   auto pri = HTTPMessage::HTTPPriority(0, true, 1);",
      "1382:   upstreamCodec_.generatePriority(output_, 1, pri);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1380: TEST_F(HTTP2CodecTest, DuplicateBadHeaderPriority) {",
      "1382:   HTTPMessage req = getGetRequest();",
      "1383:   req.setHTTP2Priority(HTTPMessage::HTTPPriority(0, false, 7));",
      "1384:   upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);",
      "1387:   EXPECT_TRUE(parse([&](IOBuf* ingress) {",
      "1388:     folly::io::RWPrivateCursor c(ingress);",
      "1389:     c.skip(http2::kFrameHeaderSize + http2::kConnectionPreface.length());",
      "1390:     c.writeBE<uint32_t>(1);",
      "1391:   }));",
      "1393:   EXPECT_EQ(callbacks_.streamErrors, 1);",
      "1394:   EXPECT_EQ(callbacks_.sessionErrors, 0);",
      "1397:   HTTPMessage nextRequest = getGetRequest();",
      "1398:   upstreamCodec_.generateHeader(output_, 1, nextRequest, true /* eom */);",
      "1399:   parse();",
      "1400:   EXPECT_EQ(callbacks_.streamErrors, 2);",
      "1401:   EXPECT_EQ(callbacks_.sessionErrors, 0);",
      "1402: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5a20145bdf542f0bb745095360cb1b838a14ce4f",
      "candidate_info": {
        "commit_hash": "5a20145bdf542f0bb745095360cb1b838a14ce4f",
        "repo": "facebook/proxygen",
        "commit_url": "https://github.com/facebook/proxygen/commit/5a20145bdf542f0bb745095360cb1b838a14ce4f",
        "files": [
          "proxygen/lib/http/HTTPMessage.h",
          "proxygen/lib/http/codec/CodecUtil.cpp",
          "proxygen/lib/http/codec/CodecUtil.h",
          "proxygen/lib/http/codec/HTTP2Codec.cpp",
          "proxygen/lib/http/codec/HTTP2Codec.h",
          "proxygen/lib/http/codec/HeaderDecodeInfo.cpp",
          "proxygen/lib/http/codec/HeaderDecodeInfo.h",
          "proxygen/lib/http/codec/test/HTTP2CodecTest.cpp",
          "proxygen/lib/http/codec/test/TestUtils.h",
          "proxygen/lib/http/session/test/HTTPDownstreamSessionTest.cpp"
        ],
        "message": "proxygen trailers - http2 codec\n\nSummary:\nAdding trailers support in http2 codec. To distinguish between headers and trailers, using heuristic that Allan suggested:\n1) for response, check for status code presence\n2) for request check if new stream\n\nReviewed By: afrind\n\nDifferential Revision: D10173609\n\nfbshipit-source-id: d03299dc7fd86affc41b351bbbc0a1d34ecbac50",
        "before_after_code_files": [
          "proxygen/lib/http/HTTPMessage.h||proxygen/lib/http/HTTPMessage.h",
          "proxygen/lib/http/codec/CodecUtil.cpp||proxygen/lib/http/codec/CodecUtil.cpp",
          "proxygen/lib/http/codec/CodecUtil.h||proxygen/lib/http/codec/CodecUtil.h",
          "proxygen/lib/http/codec/HTTP2Codec.cpp||proxygen/lib/http/codec/HTTP2Codec.cpp",
          "proxygen/lib/http/codec/HTTP2Codec.h||proxygen/lib/http/codec/HTTP2Codec.h",
          "proxygen/lib/http/codec/HeaderDecodeInfo.cpp||proxygen/lib/http/codec/HeaderDecodeInfo.cpp",
          "proxygen/lib/http/codec/HeaderDecodeInfo.h||proxygen/lib/http/codec/HeaderDecodeInfo.h",
          "proxygen/lib/http/codec/test/HTTP2CodecTest.cpp||proxygen/lib/http/codec/test/HTTP2CodecTest.cpp",
          "proxygen/lib/http/codec/test/TestUtils.h||proxygen/lib/http/codec/test/TestUtils.h",
          "proxygen/lib/http/session/test/HTTPDownstreamSessionTest.cpp||proxygen/lib/http/session/test/HTTPDownstreamSessionTest.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "proxygen/lib/http/codec/HTTP2Codec.cpp||proxygen/lib/http/codec/HTTP2Codec.cpp",
            "proxygen/lib/http/codec/test/HTTP2CodecTest.cpp||proxygen/lib/http/codec/test/HTTP2CodecTest.cpp"
          ],
          "candidate": [
            "proxygen/lib/http/codec/HTTP2Codec.cpp||proxygen/lib/http/codec/HTTP2Codec.cpp",
            "proxygen/lib/http/codec/test/HTTP2CodecTest.cpp||proxygen/lib/http/codec/test/HTTP2CodecTest.cpp"
          ]
        }
      },
      "candidate_diff": {
        "proxygen/lib/http/HTTPMessage.h||proxygen/lib/http/HTTPMessage.h": [
          "File: proxygen/lib/http/HTTPMessage.h -> proxygen/lib/http/HTTPMessage.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "273:   HTTPHeaders& getHeaders() { return headers_; }",
          "274:   const HTTPHeaders& getHeaders() const { return headers_; }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "279:   HTTPHeaders&& extractHeaders() {",
          "280:     return std::move(headers_);",
          "281:   }",
          "",
          "---------------"
        ],
        "proxygen/lib/http/codec/CodecUtil.cpp||proxygen/lib/http/codec/CodecUtil.cpp": [
          "File: proxygen/lib/http/codec/CodecUtil.cpp -> proxygen/lib/http/codec/CodecUtil.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "119:   }",
          "163:   if (msg.isResponse() && !hasDateHeader) {",
          "164:     temps.emplace_back(HTTPMessage::formatDateHeader());",
          "",
          "[Removed Lines]",
          "121:   bool hasDateHeader = false;",
          "124:   msg.getHeaders().forEachWithCode(",
          "125:     [&] (HTTPHeaderCode code,",
          "126:          const std::string& name,",
          "127:          const std::string& value) {",
          "128:       static const std::bitset<256> s_perHopHeaderCodes{",
          "129:         [] {",
          "130:           std::bitset<256> bs;",
          "132:           bs[HTTP_HEADER_CONNECTION] = true;",
          "133:           bs[HTTP_HEADER_HOST] = true;",
          "134:           bs[HTTP_HEADER_KEEP_ALIVE] = true;",
          "135:           bs[HTTP_HEADER_PROXY_CONNECTION] = true;",
          "136:           bs[HTTP_HEADER_TRANSFER_ENCODING] = true;",
          "137:           bs[HTTP_HEADER_UPGRADE] = true;",
          "138:           bs[HTTP_HEADER_SEC_WEBSOCKET_KEY] = true;",
          "139:           bs[HTTP_HEADER_SEC_WEBSOCKET_ACCEPT] = true;",
          "140:           return bs;",
          "141:         }()",
          "142:       };",
          "144:       if (s_perHopHeaderCodes[code] || name.size() == 0 || name[0] == ':') {",
          "145:         DCHECK_GT(name.size(), 0) << \"Empty header\";",
          "146:         DCHECK_NE(name[0], ':') << \"Invalid header=\" << name;",
          "147:         return;",
          "148:       }",
          "153:       DCHECK(name != \"TE\" || value == \"trailers\");",
          "154:       if ((name.size() > 0 && name[0] != ':') &&",
          "155:           code != HTTP_HEADER_HOST) {",
          "156:         allHeaders.emplace_back(code, name, value);",
          "157:       }",
          "158:       if (code == HTTP_HEADER_DATE) {",
          "159:         hasDateHeader = true;",
          "160:       }",
          "161:     });",
          "",
          "[Added Lines]",
          "121:   bool hasDateHeader =",
          "122:       appendHeaders(msg.getHeaders(), allHeaders, HTTP_HEADER_DATE);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "167:   return allHeaders;",
          "168: }",
          "170: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "131: bool CodecUtil::appendHeaders(const HTTPHeaders& inputHeaders,",
          "132:                               std::vector<compress::Header>& headers,",
          "133:                               HTTPHeaderCode headerToCheck) {",
          "134:   bool headerToCheckExists = false;",
          "137:   inputHeaders.forEachWithCode([&](HTTPHeaderCode code,",
          "138:                                    const std::string& name,",
          "139:                                    const std::string& value) {",
          "140:     static const std::bitset<256> s_perHopHeaderCodes{[] {",
          "141:       std::bitset<256> bs;",
          "143:       bs[HTTP_HEADER_CONNECTION] = true;",
          "144:       bs[HTTP_HEADER_HOST] = true;",
          "145:       bs[HTTP_HEADER_KEEP_ALIVE] = true;",
          "146:       bs[HTTP_HEADER_PROXY_CONNECTION] = true;",
          "147:       bs[HTTP_HEADER_TRANSFER_ENCODING] = true;",
          "148:       bs[HTTP_HEADER_UPGRADE] = true;",
          "149:       bs[HTTP_HEADER_SEC_WEBSOCKET_KEY] = true;",
          "150:       bs[HTTP_HEADER_SEC_WEBSOCKET_ACCEPT] = true;",
          "151:       return bs;",
          "152:     }()};",
          "154:     if (s_perHopHeaderCodes[code] || name.size() == 0 || name[0] == ':') {",
          "155:       DCHECK_GT(name.size(), 0) << \"Empty header\";",
          "156:       DCHECK_NE(name[0], ':') << \"Invalid header=\" << name;",
          "157:       return;",
          "158:     }",
          "163:     DCHECK(name != \"TE\" || value == \"trailers\");",
          "164:     if ((name.size() > 0 && name[0] != ':') && code != HTTP_HEADER_HOST) {",
          "165:       headers.emplace_back(code, name, value);",
          "166:     }",
          "167:     if (code == headerToCheck) {",
          "168:       headerToCheckExists = true;",
          "169:     }",
          "170:   });",
          "172:   return headerToCheckExists;",
          "173: }",
          "",
          "---------------"
        ],
        "proxygen/lib/http/codec/CodecUtil.h||proxygen/lib/http/codec/CodecUtil.h": [
          "File: proxygen/lib/http/codec/CodecUtil.h -> proxygen/lib/http/codec/CodecUtil.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "144:       const HTTPMessage& msg,",
          "145:       std::vector<std::string>& temps);",
          "147: };",
          "148: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "147:   static bool appendHeaders(const HTTPHeaders& inputHeaders,",
          "148:                             std::vector<compress::Header>& headers,",
          "149:                             HTTPHeaderCode headerToCheck);",
          "",
          "---------------"
        ],
        "proxygen/lib/http/codec/HTTP2Codec.cpp||proxygen/lib/http/codec/HTTP2Codec.cpp": [
          "File: proxygen/lib/http/codec/HTTP2Codec.cpp -> proxygen/lib/http/codec/HTTP2Codec.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "384:   auto err = http2::parseHeaders(cursor, curHeader_, priority, headerBuf);",
          "385:   RETURN_IF_ERROR(err);",
          "386:   if (transportDirection_ == TransportDirection::DOWNSTREAM) {",
          "388:   }",
          "389:   err = parseHeadersImpl(cursor, std::move(headerBuf), priority, folly::none,",
          "390:                          folly::none);",
          "",
          "[Removed Lines]",
          "387:     RETURN_IF_ERROR(checkNewStream(curHeader_.stream));",
          "",
          "[Added Lines]",
          "387:     RETURN_IF_ERROR(",
          "388:         checkNewStream(curHeader_.stream, true /* trailersAllowed */));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "402:       cursor, curHeader_, exAttributes, priority, headerBuf);",
          "403:   RETURN_IF_ERROR(err);",
          "404:   if (isRequest(curHeader_.stream)) {",
          "406:   }",
          "407:   return parseHeadersImpl(cursor, std::move(headerBuf), priority, folly::none,",
          "408:                           exAttributes);",
          "",
          "[Removed Lines]",
          "405:     RETURN_IF_ERROR(checkNewStream(curHeader_.stream));",
          "",
          "[Added Lines]",
          "406:     RETURN_IF_ERROR(",
          "407:         checkNewStream(curHeader_.stream, false /* trailersAllowed */));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "428:   curHeaderBlock_.append(std::move(headerBuf));",
          "429:   std::unique_ptr<HTTPMessage> msg;",
          "430:   if (curHeader_.flags & http2::END_HEADERS) {",
          "456:     }",
          "500:   }",
          "503:   if (callback_) {",
          "504:     uint32_t headersCompleteStream = curHeader_.stream;",
          "519:       }",
          "536:       }",
          "537:     } else if (curHeader_.type == http2::FrameType::PUSH_PROMISE) {",
          "538:       DCHECK(promisedStream);",
          "",
          "[Removed Lines]",
          "432:     Cursor headerCursor(curHeaderBlock_.front());",
          "433:     bool isReq = false;",
          "434:     if (promisedStream) {",
          "435:       isReq = true;",
          "436:     } else if (exAttributes) {",
          "437:       isReq = isRequest(curHeader_.stream);",
          "438:     } else {",
          "439:       isReq = transportDirection_ == TransportDirection::DOWNSTREAM;",
          "440:     }",
          "442:     decodeInfo_.init(isReq);",
          "443:     if (priority) {",
          "444:       if (curHeader_.stream == priority->streamDependency) {",
          "445:         streamError(folly::to<string>(\"Circular dependency for txn=\",",
          "446:                                       curHeader_.stream),",
          "447:                     ErrorCode::PROTOCOL_ERROR,",
          "448:                     curHeader_.type == http2::FrameType::HEADERS);",
          "449:         return ErrorCode::NO_ERROR;",
          "450:       }",
          "452:       decodeInfo_.msg->setHTTP2Priority(",
          "453:           std::make_tuple(priority->streamDependency,",
          "454:                           priority->exclusive,",
          "455:                           priority->weight));",
          "457:     headerCodec_.decodeStreaming(headerCursor,",
          "458:                                  curHeaderBlock_.chainLength(),",
          "459:                                  this);",
          "460:     msg = std::move(decodeInfo_.msg);",
          "462:     auto g = folly::makeGuard([this] {",
          "463:         curHeaderBlock_.move();",
          "464:       });",
          "466:     if (decodeInfo_.decodeError != HPACK::DecodeError::NONE) {",
          "467:       static const std::string decodeErrorMessage =",
          "468:           \"Failed decoding header block for stream=\";",
          "471:       if (decodeInfo_.decodeError != HPACK::DecodeError::HEADERS_TOO_LARGE) {",
          "472:         LOG(ERROR) << decodeErrorMessage << curHeader_.stream",
          "473:                    << \" header block=\";",
          "474:         VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);",
          "475:       } else {",
          "476:         LOG(ERROR) << decodeErrorMessage << curHeader_.stream;",
          "477:       }",
          "479:       if (msg) {",
          "481:         msg->dumpMessage(3);",
          "482:       }",
          "483:       return ErrorCode::COMPRESSION_ERROR;",
          "484:     }",
          "486:     if (decodeInfo_.parsingError != \"\") {",
          "487:       LOG(ERROR) << \"Failed parsing header list for stream=\"",
          "488:                  << curHeader_.stream << \", error=\" << decodeInfo_.parsingError",
          "489:                  << \", header block=\";",
          "490:       VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);",
          "491:       HTTPException err(HTTPException::Direction::INGRESS,",
          "492:                         folly::to<std::string>(\"HTTP2Codec stream error: \",",
          "493:                                                \"stream=\", curHeader_.stream,",
          "494:                                                \" status=\", 400, \" error: \",",
          "495:                                                decodeInfo_.parsingError));",
          "496:       err.setHttpStatusCode(400);",
          "497:       callback_->onError(curHeader_.stream, err, true);",
          "498:       return ErrorCode::NO_ERROR;",
          "499:     }",
          "505:     if (curHeader_.type == http2::FrameType::HEADERS ||",
          "506:         curHeader_.type == http2::FrameType::EX_HEADERS) {",
          "507:       if (curHeader_.flags & http2::PRIORITY) {",
          "508:         DCHECK(priority);",
          "510:       }",
          "513:       if (callback_->numIncomingStreams() >=",
          "514:           egressSettings_.getSetting(SettingsId::MAX_CONCURRENT_STREAMS,",
          "515:                                      std::numeric_limits<int32_t>::max())) {",
          "516:         streamError(folly::to<string>(\"Exceeded max_concurrent_streams\"),",
          "517:                     ErrorCode::REFUSED_STREAM, true);",
          "518:         return ErrorCode::NO_ERROR;",
          "521:       if (curHeader_.type == http2::FrameType::HEADERS) {",
          "522:         if (!deliverCallbackIfAllowed(&HTTPCodec::Callback::onMessageBegin,",
          "523:                                       \"onMessageBegin\", curHeader_.stream,",
          "524:                                       msg.get())) {",
          "525:           return handleEndStream();",
          "526:         }",
          "527:       } else if (curHeader_.type == http2::FrameType::EX_HEADERS) {",
          "528:         if (!deliverCallbackIfAllowed(&HTTPCodec::Callback::onExMessageBegin,",
          "529:                                       \"onExMessageBegin\",",
          "530:                                       curHeader_.stream,",
          "531:                                       exAttributes->controlStream,",
          "532:                                       exAttributes->unidirectional,",
          "533:                                       msg.get())) {",
          "534:           return handleEndStream();",
          "535:         }",
          "",
          "[Added Lines]",
          "433:     auto errorCode =",
          "434:         parseHeadersDecodeFrames(priority, promisedStream, exAttributes, msg);",
          "435:     if (errorCode.hasValue()) {",
          "436:       return errorCode.value();",
          "438:   }",
          "441:   if (curHeader_.type != http2::FrameType::CONTINUATION) {",
          "442:     headerBlockFrameType_ = curHeader_.type;",
          "447:     auto concurError = parseHeadersCheckConcurrentStreams(priority);",
          "448:     if (concurError.hasValue()) {",
          "449:       return concurError.value();",
          "450:     }",
          "452:     bool trailers = parsingTrailers();",
          "453:     bool allHeaderFramesReceived =",
          "454:         (curHeader_.flags & http2::END_HEADERS) &&",
          "455:         (headerBlockFrameType_ == http2::FrameType::HEADERS);",
          "456:     if (allHeaderFramesReceived && !trailers) {",
          "460:       if (!deliverCallbackIfAllowed(&HTTPCodec::Callback::onMessageBegin,",
          "461:                                     \"onMessageBegin\",",
          "462:                                     curHeader_.stream,",
          "463:                                     msg.get())) {",
          "464:         return handleEndStream();",
          "466:    } else if (curHeader_.type == http2::FrameType::EX_HEADERS) {",
          "467:       if (!deliverCallbackIfAllowed(&HTTPCodec::Callback::onExMessageBegin,",
          "468:                                     \"onExMessageBegin\",",
          "469:                                     curHeader_.stream,",
          "470:                                     exAttributes->controlStream,",
          "471:                                     exAttributes->unidirectional,",
          "472:                                     msg.get())) {",
          "473:         return handleEndStream();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "543:       }",
          "544:       headersCompleteStream = *promisedStream;",
          "545:     }",
          "546:     if (curHeader_.flags & http2::END_HEADERS && msg) {",
          "547:       if (!(curHeader_.flags & http2::END_STREAM)) {",
          "549:         msg->setIsChunked(true);",
          "550:       }",
          "552:     }",
          "553:     return handleEndStream();",
          "554:   }",
          "555:   return ErrorCode::NO_ERROR;",
          "556: }",
          "558: void HTTP2Codec::onHeader(const folly::fbstring& name,",
          "559:                           const folly::fbstring& value) {",
          "560:   if (decodeInfo_.onHeader(name, value)) {",
          "",
          "[Removed Lines]",
          "551:       callback_->onHeadersComplete(headersCompleteStream, std::move(msg));",
          "",
          "[Added Lines]",
          "490:       if (trailers) {",
          "491:         VLOG(4) << \"Trailers complete for streamId=\" << headersCompleteStream",
          "492:                 << \" direction=\" << transportDirection_;",
          "493:         auto trailerHeaders =",
          "494:             std::make_unique<HTTPHeaders>(msg->extractHeaders());",
          "495:         msg.reset();",
          "496:         callback_->onTrailersComplete(headersCompleteStream,",
          "497:                                       std::move(trailerHeaders));",
          "498:       } else {",
          "499:         callback_->onHeadersComplete(headersCompleteStream, std::move(msg));",
          "500:       }",
          "507: folly::Optional<ErrorCode> HTTP2Codec::parseHeadersDecodeFrames(",
          "508:     folly::Optional<http2::PriorityUpdate> priority,",
          "509:     folly::Optional<uint32_t> promisedStream,",
          "510:     folly::Optional<ExAttributes> exAttributes,",
          "511:     std::unique_ptr<HTTPMessage>& msg) {",
          "513:   Cursor headerCursor(curHeaderBlock_.front());",
          "514:   bool isReq = false;",
          "515:   if (promisedStream) {",
          "516:     isReq = true;",
          "517:   } else if (exAttributes) {",
          "518:     isReq = isRequest(curHeader_.stream);",
          "519:   } else {",
          "520:     isReq = transportDirection_ == TransportDirection::DOWNSTREAM;",
          "521:   }",
          "523:   decodeInfo_.init(isReq, parsingDownstreamTrailers_);",
          "524:   if (priority) {",
          "525:     if (curHeader_.stream == priority->streamDependency) {",
          "526:       streamError(folly::to<string>(\"Circular dependency for txn=\",",
          "527:                                     curHeader_.stream),",
          "528:                   ErrorCode::PROTOCOL_ERROR,",
          "529:                   curHeader_.type == http2::FrameType::HEADERS);",
          "530:       return ErrorCode::NO_ERROR;",
          "531:     }",
          "533:     decodeInfo_.msg->setHTTP2Priority(",
          "534:         std::make_tuple(priority->streamDependency,",
          "535:                         priority->exclusive,",
          "536:                         priority->weight));",
          "537:   }",
          "538:   headerCodec_.decodeStreaming(",
          "539:       headerCursor, curHeaderBlock_.chainLength(), this);",
          "540:   msg = std::move(decodeInfo_.msg);",
          "542:   auto g = folly::makeGuard([this] { curHeaderBlock_.move(); });",
          "544:   if (decodeInfo_.decodeError != HPACK::DecodeError::NONE) {",
          "545:     static const std::string decodeErrorMessage =",
          "546:         \"Failed decoding header block for stream=\";",
          "549:     if (decodeInfo_.decodeError != HPACK::DecodeError::HEADERS_TOO_LARGE) {",
          "550:       LOG(ERROR) << decodeErrorMessage << curHeader_.stream",
          "551:                  << \" header block=\";",
          "552:       VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);",
          "553:     } else {",
          "554:       LOG(ERROR) << decodeErrorMessage << curHeader_.stream;",
          "555:     }",
          "557:     if (msg) {",
          "559:       msg->dumpMessage(3);",
          "560:     }",
          "561:     return ErrorCode::COMPRESSION_ERROR;",
          "562:   }",
          "565:   if (decodeInfo_.parsingError != \"\") {",
          "566:     LOG(ERROR) << \"Failed parsing header list for stream=\" << curHeader_.stream",
          "567:                << \", error=\" << decodeInfo_.parsingError << \", header block=\";",
          "568:     VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);",
          "569:     HTTPException err(HTTPException::Direction::INGRESS,",
          "570:                       folly::to<std::string>(\"HTTP2Codec stream error: \",",
          "571:                                              \"stream=\",",
          "572:                                              curHeader_.stream,",
          "573:                                              \" status=\",",
          "574:                                              400,",
          "575:                                              \" error: \",",
          "576:                                              decodeInfo_.parsingError));",
          "577:     err.setHttpStatusCode(400);",
          "578:     callback_->onError(curHeader_.stream, err, true);",
          "579:     return ErrorCode::NO_ERROR;",
          "580:   }",
          "582:   return folly::Optional<ErrorCode>();",
          "583: }",
          "585: folly::Optional<ErrorCode> HTTP2Codec::parseHeadersCheckConcurrentStreams(",
          "586:     folly::Optional<http2::PriorityUpdate> priority) {",
          "587:   if (curHeader_.type == http2::FrameType::HEADERS ||",
          "588:       curHeader_.type == http2::FrameType::EX_HEADERS) {",
          "589:     if (curHeader_.flags & http2::PRIORITY) {",
          "590:       DCHECK(priority);",
          "592:     }",
          "595:     if (callback_->numIncomingStreams() >=",
          "596:         egressSettings_.getSetting(SettingsId::MAX_CONCURRENT_STREAMS,",
          "597:                                    std::numeric_limits<int32_t>::max())) {",
          "598:       streamError(folly::to<string>(\"Exceeded max_concurrent_streams\"),",
          "599:                   ErrorCode::REFUSED_STREAM, true);",
          "600:       return ErrorCode::NO_ERROR;",
          "601:     }",
          "602:   }",
          "603:   return folly::Optional<ErrorCode>();",
          "604: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "797:   auto err = http2::parsePushPromise(cursor, curHeader_, promisedStream,",
          "798:                                      headerBlockFragment);",
          "799:   RETURN_IF_ERROR(err);",
          "801:   err = parseHeadersImpl(cursor, std::move(headerBlockFragment), folly::none,",
          "802:                          promisedStream, folly::none);",
          "803:   return err;",
          "",
          "[Removed Lines]",
          "800:   RETURN_IF_ERROR(checkNewStream(promisedStream));",
          "",
          "[Added Lines]",
          "848:   RETURN_IF_ERROR(checkNewStream(promisedStream, false /* trailersAllowed */));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "922:   return ErrorCode::NO_ERROR;",
          "923: }",
          "927:     goawayErrorMessage_ = folly::to<string>(",
          "928:         \"GOAWAY error: received streamID=\", streamId,",
          "929:         \" as invalid new stream for lastStreamID_=\", lastStreamID_);",
          "930:     VLOG(4) << goawayErrorMessage_;",
          "931:     return ErrorCode::PROTOCOL_ERROR;",
          "932:   }",
          "933:   if (sessionClosing_ != ClosingState::CLOSED) {",
          "934:     lastStreamID_ = streamId;",
          "935:   }",
          "",
          "[Removed Lines]",
          "925: ErrorCode HTTP2Codec::checkNewStream(uint32_t streamId) {",
          "926:   if (streamId == 0 || streamId <= lastStreamID_) {",
          "",
          "[Added Lines]",
          "973: ErrorCode HTTP2Codec::checkNewStream(uint32_t streamId, bool trailersAllowed) {",
          "974:   if (streamId == 0) {",
          "981:   parsingDownstreamTrailers_ = trailersAllowed && (streamId <= lastStreamID_);",
          "982:   if (parsingDownstreamTrailers_) {",
          "983:     VLOG(4) << \"Parsing downstream trailers streamId=\" << streamId;",
          "984:   }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1087:   std::vector<std::string> temps;",
          "1088:   auto allHeaders = CodecUtil::prepareMessageForCompression(msg, temps);",
          "1112:   IOBufQueue queue(IOBufQueue::cacheChainLength());",
          "1113:   queue.append(std::move(out));",
          "1114:   auto maxFrameSize = maxSendFrameSize();",
          "",
          "[Removed Lines]",
          "1089:   headerCodec_.setEncodeHeadroom(http2::kFrameHeaderSize +",
          "1090:                                  http2::kFrameHeadersBaseMaxSize);",
          "1091:   auto out = headerCodec_.encode(allHeaders);",
          "1092:   if (size) {",
          "1094:   }",
          "1096:   if (headerCodec_.getEncodedSize().uncompressed >",
          "1097:       ingressSettings_.getSetting(SettingsId::MAX_HEADER_LIST_SIZE,",
          "1098:                                   std::numeric_limits<uint32_t>::max())) {",
          "1101:     string serializedHeaders;",
          "1102:     msg.getHeaders().forEach(",
          "1103:       [&serializedHeaders] (const string& name, const string& value) {",
          "1104:         serializedHeaders = folly::to<string>(serializedHeaders, \"\\\\n\", name,",
          "1105:                                               \":\", value);",
          "1106:       });",
          "1107:     LOG(ERROR) << \"generating HEADERS frame larger than peer maximum nHeaders=\"",
          "1108:                << msg.getHeaders().size() << \" all headers=\"",
          "1109:                << serializedHeaders;",
          "1110:   }",
          "",
          "[Added Lines]",
          "1142:   auto out = encodeHeaders(msg.getHeaders(), allHeaders, size);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1160:                                                         endHeaders));",
          "1161:     }",
          "1172:     }",
          "1173:   }",
          "1174: }",
          "1176: size_t HTTP2Codec::generateHeaderCallbackWrapper(StreamID stream,",
          "1177:                                                  http2::FrameType type,",
          "1178:                                                  size_t length) {",
          "",
          "[Removed Lines]",
          "1163:     while (!endHeaders) {",
          "1164:       chunk = queue.split(std::min(maxFrameSize, queue.chainLength()));",
          "1165:       endHeaders = queue.chainLength() == 0;",
          "1166:       VLOG(4) << \"generating CONTINUATION for stream=\" << stream;",
          "1167:       generateHeaderCallbackWrapper(stream, http2::FrameType::CONTINUATION,",
          "1168:                                     http2::writeContinuation(writeBuf,",
          "1169:                                                              stream,",
          "1170:                                                              endHeaders,",
          "1171:                                                              std::move(chunk)));",
          "",
          "[Added Lines]",
          "1194:     if (!endHeaders) {",
          "1195:       generateContinuation(writeBuf, queue, stream, maxFrameSize);",
          "1200: void HTTP2Codec::generateContinuation(folly::IOBufQueue& writeBuf,",
          "1201:                                       folly::IOBufQueue& queue,",
          "1202:                                       StreamID stream,",
          "1203:                                       size_t maxFrameSize) {",
          "1204:   bool endHeaders = false;",
          "1205:   while (!endHeaders) {",
          "1206:     auto chunk = queue.split(std::min(maxFrameSize, queue.chainLength()));",
          "1207:     endHeaders = (queue.chainLength() == 0);",
          "1208:     VLOG(4) << \"generating CONTINUATION for stream=\" << stream;",
          "1209:     generateHeaderCallbackWrapper(",
          "1210:         stream,",
          "1211:         http2::FrameType::CONTINUATION,",
          "1212:         http2::writeContinuation(",
          "1213:             writeBuf, stream, endHeaders, std::move(chunk)));",
          "1214:   }",
          "1215: }",
          "1217: std::unique_ptr<folly::IOBuf> HTTP2Codec::encodeHeaders(",
          "1218:     const HTTPHeaders& headers,",
          "1219:     std::vector<compress::Header>& allHeaders,",
          "1220:     HTTPHeaderSize* size) {",
          "1221:   headerCodec_.setEncodeHeadroom(http2::kFrameHeaderSize +",
          "1222:                                  http2::kFrameHeadersBaseMaxSize);",
          "1223:   auto out = headerCodec_.encode(allHeaders);",
          "1224:   if (size) {",
          "1226:   }",
          "1228:   if (headerCodec_.getEncodedSize().uncompressed >",
          "1229:       ingressSettings_.getSetting(SettingsId::MAX_HEADER_LIST_SIZE,",
          "1230:                                   std::numeric_limits<uint32_t>::max())) {",
          "1233:     string serializedHeaders;",
          "1234:     headers.forEach(",
          "1235:       [&serializedHeaders] (const string& name, const string& value) {",
          "1236:         serializedHeaders = folly::to<string>(serializedHeaders, \"\\\\n\", name,",
          "1237:                                               \":\", value);",
          "1238:       });",
          "1239:     LOG(ERROR) << \"generating HEADERS frame larger than peer maximum nHeaders=\"",
          "1240:                << headers.size() << \" all headers=\"",
          "1241:                << serializedHeaders;",
          "1242:   }",
          "1243:   return out;",
          "1244: }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1236:   return 0;",
          "1237: }",
          "1243: }",
          "1245: size_t HTTP2Codec::generateEOM(folly::IOBufQueue& writeBuf,",
          "",
          "[Removed Lines]",
          "1239: size_t HTTP2Codec::generateTrailers(folly::IOBufQueue& /*writeBuf*/,",
          "1240:                                     StreamID /*stream*/,",
          "1241:                                     const HTTPHeaders& /*trailers*/) {",
          "1242:   return 0;",
          "",
          "[Added Lines]",
          "1309: size_t HTTP2Codec::generateTrailers(folly::IOBufQueue& writeBuf,",
          "1310:                                     StreamID stream,",
          "1311:                                     const HTTPHeaders& trailers) {",
          "1312:   std::vector<compress::Header> allHeaders;",
          "1313:   CodecUtil::appendHeaders(trailers, allHeaders, HTTP_HEADER_NONE);",
          "1315:   HTTPHeaderSize size;",
          "1316:   auto out = encodeHeaders(trailers, allHeaders, &size);",
          "1318:   IOBufQueue queue(IOBufQueue::cacheChainLength());",
          "1319:   queue.append(std::move(out));",
          "1320:   auto maxFrameSize = maxSendFrameSize();",
          "1321:   if (queue.chainLength() > 0) {",
          "1322:     folly::Optional<http2::PriorityUpdate> pri;",
          "1323:     auto remainingFrameSize = maxFrameSize;",
          "1324:     auto chunk = queue.split(std::min(remainingFrameSize, queue.chainLength()));",
          "1325:     bool endHeaders = queue.chainLength() == 0;",
          "1326:     generateHeaderCallbackWrapper(stream,",
          "1327:                                   http2::FrameType::HEADERS,",
          "1328:                                   http2::writeHeaders(writeBuf,",
          "1329:                                                       std::move(chunk),",
          "1330:                                                       stream,",
          "1331:                                                       pri,",
          "1332:                                                       http2::kNoPadding,",
          "1333:                                                       true /*eom*/,",
          "1334:                                                       endHeaders));",
          "1336:     if (!endHeaders) {",
          "1337:       generateContinuation(writeBuf, queue, stream, maxFrameSize);",
          "1338:     }",
          "1339:   }",
          "1341:   return size.compressed;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1535:         std::min(priority, uint8_t(virtualPriorityNodes_.size() - 1))];",
          "1536: }",
          "1538: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1637: bool HTTP2Codec::parsingTrailers() const {",
          "1647:   if (curHeader_.type == http2::FrameType::HEADERS ||",
          "1648:       curHeader_.type == http2::FrameType::CONTINUATION) {",
          "1649:     if (transportDirection_ == TransportDirection::DOWNSTREAM) {",
          "1650:       return parsingDownstreamTrailers_;",
          "1651:     } else {",
          "1652:       return !decodeInfo_.hasStatus();",
          "1653:     }",
          "1654:   }",
          "1655:   return false;",
          "1656: }",
          "",
          "---------------"
        ],
        "proxygen/lib/http/codec/HTTP2Codec.h||proxygen/lib/http/codec/HTTP2Codec.h": [
          "File: proxygen/lib/http/codec/HTTP2Codec.h -> proxygen/lib/http/codec/HTTP2Codec.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "53:                       const HTTPMessage& msg,",
          "54:                       bool eom = false,",
          "55:                       HTTPHeaderSize* size = nullptr) override;",
          "56:   void generatePushPromise(folly::IOBufQueue& writeBuf,",
          "57:                            StreamID stream,",
          "58:                            const HTTPMessage& msg,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "56:   void generateContinuation(folly::IOBufQueue& writeBuf,",
          "57:                             folly::IOBufQueue& queue,",
          "58:                             StreamID stream,",
          "59:                             size_t maxFrameSize);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "179:                           folly::Optional<ExAttributes> exAttributes,",
          "180:                           bool eom,",
          "181:                           HTTPHeaderSize* size);",
          "183:   size_t generateHeaderCallbackWrapper(StreamID stream, http2::FrameType type, size_t length);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "186:   std::unique_ptr<folly::IOBuf> encodeHeaders(",
          "187:       const HTTPHeaders& headers,",
          "188:       std::vector<compress::Header>& allHeaders,",
          "189:       HTTPHeaderSize* size);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "206:     folly::Optional<http2::PriorityUpdate> priority,",
          "207:     folly::Optional<uint32_t> promisedStream,",
          "208:     folly::Optional<ExAttributes> exAttributes);",
          "210:   ErrorCode handleEndStream();",
          "212:   bool checkConnectionError(ErrorCode, const folly::IOBuf* buf);",
          "213:   ErrorCode handleSettings(const std::deque<SettingPair>& settings);",
          "214:   size_t maxSendFrameSize() const {",
          "",
          "[Removed Lines]",
          "211:   ErrorCode checkNewStream(uint32_t stream);",
          "",
          "[Added Lines]",
          "217:   folly::Optional<ErrorCode> parseHeadersDecodeFrames(",
          "218:       folly::Optional<http2::PriorityUpdate> priority,",
          "219:       folly::Optional<uint32_t> promisedStream,",
          "220:       folly::Optional<ExAttributes> exAttributes,",
          "221:       std::unique_ptr<HTTPMessage>& msg);",
          "222:   folly::Optional<ErrorCode> parseHeadersCheckConcurrentStreams(",
          "223:       folly::Optional<http2::PriorityUpdate> priority);",
          "226:   ErrorCode checkNewStream(uint32_t stream, bool trailersAllowed);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "220:                                       http2::kMaxFramePayloadLengthMin);",
          "221:   }",
          "222:   void streamError(const std::string& msg, ErrorCode error, bool newTxn=false);",
          "224:   HPACKCodec headerCodec_;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "238:   bool parsingTrailers() const;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "266:   HeaderDecodeInfo decodeInfo_;",
          "267:   std::vector<StreamID> virtualPriorityNodes_;",
          "268:   bool reuseIOBufHeadroomForData_{true};",
          "269: };",
          "271: } // proxygen",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "292:   bool parsingDownstreamTrailers_{false};",
          "296:   http2::FrameType headerBlockFrameType_{http2::FrameType::DATA};",
          "",
          "---------------"
        ],
        "proxygen/lib/http/codec/HeaderDecodeInfo.cpp||proxygen/lib/http/codec/HeaderDecodeInfo.cpp": [
          "File: proxygen/lib/http/codec/HeaderDecodeInfo.cpp -> proxygen/lib/http/codec/HeaderDecodeInfo.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "27:   folly::StringPiece valueSp(value);",
          "29:   if (nameSp.startsWith(':')) {",
          "30:     if (regularHeaderSeen_) {",
          "31:       parsingError = folly::to<string>(\"Illegal pseudo header name=\", nameSp);",
          "32:       return false;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30:     pseudoHeaderSeen_ = true;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "110: void HeaderDecodeInfo::onHeadersComplete(HTTPHeaderSize decodedSize) {",
          "111:   HTTPHeaders& headers = msg->getHeaders();",
          "114:     auto combinedCookie = headers.combine(HTTP_HEADER_COOKIE, \"; \");",
          "115:     if (!combinedCookie.empty()) {",
          "116:       headers.set(HTTP_HEADER_COOKIE, combinedCookie);",
          "",
          "[Removed Lines]",
          "113:   if (isRequest_) {",
          "",
          "[Added Lines]",
          "114:   if (isRequest_ && !isRequestTrailers_) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "119:       parsingError = verifier.error;",
          "120:       return;",
          "121:     }",
          "124:     return;",
          "125:   }",
          "127:   msg->setHTTPVersion(1, 1);",
          "128:   msg->setIngressHeaderSize(decodedSize);",
          "129: }",
          "130: }",
          "",
          "[Removed Lines]",
          "122:   } else if (!hasStatus_) {",
          "123:     parsingError = string(\"Malformed response, missing :status\");",
          "",
          "[Added Lines]",
          "123:   }",
          "125:   bool isResponseTrailers = (!isRequest_ && !hasStatus_);",
          "126:   if ((isRequestTrailers_ || isResponseTrailers) && pseudoHeaderSeen_) {",
          "127:     parsingError = \"Pseudo headers forbidden in trailers.\";",
          "135: bool HeaderDecodeInfo::hasStatus() const {",
          "136:   return hasStatus_;",
          "137: }",
          "",
          "---------------"
        ],
        "proxygen/lib/http/codec/HeaderDecodeInfo.h||proxygen/lib/http/codec/HeaderDecodeInfo.h": [
          "File: proxygen/lib/http/codec/HeaderDecodeInfo.h -> proxygen/lib/http/codec/HeaderDecodeInfo.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: class HeaderDecodeInfo {",
          "20:  public:",
          "22:     CHECK(!msg);",
          "23:     msg.reset(new HTTPMessage());",
          "24:     isRequest_ = isRequestIn;",
          "25:     hasStatus_ = false;",
          "26:     contentLength_ = folly::none;",
          "27:     regularHeaderSeen_ = false;",
          "28:     parsingError = \"\";",
          "29:     decodeError = HPACK::DecodeError::NONE;",
          "30:     verifier.reset(msg.get());",
          "",
          "[Removed Lines]",
          "21:   void init(bool isRequestIn) {",
          "",
          "[Added Lines]",
          "21:   void init(bool isRequestIn, bool isRequestTrailers) {",
          "25:     isRequestTrailers_ = isRequestTrailers;",
          "29:     pseudoHeaderSeen_ = false;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "35:   void onHeadersComplete(HTTPHeaderSize decodedSize);",
          "39:   std::unique_ptr<HTTPMessage> msg;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "39:   bool hasStatus() const;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "44:  private:",
          "45:   bool isRequest_{false};",
          "46:   bool hasStatus_{false};",
          "47:   bool regularHeaderSeen_{false};",
          "48:   folly::Optional<uint32_t> contentLength_;",
          "49: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "50:   bool isRequestTrailers_{false};",
          "53:   bool pseudoHeaderSeen_{false};",
          "",
          "---------------"
        ],
        "proxygen/lib/http/codec/test/HTTP2CodecTest.cpp||proxygen/lib/http/codec/test/HTTP2CodecTest.cpp": [
          "File: proxygen/lib/http/codec/test/HTTP2CodecTest.cpp -> proxygen/lib/http/codec/test/HTTP2CodecTest.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "416:   EXPECT_EQ(callbacks_.sessionErrors, 0);",
          "417: }",
          "",
          "[Removed Lines]",
          "419: TEST_F(HTTP2CodecTest, DuplicateHeaders) {",
          "420:   HTTPMessage req = getGetRequest(\"/guacamole\");",
          "421:   req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");",
          "422:   req.setSecure(true);",
          "423:   upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);",
          "424:   writeFrameHeaderManual(output_, 0, (uint8_t)http2::FrameType::HEADERS,",
          "425:                          http2::END_STREAM, 1);",
          "427:   parse();",
          "428:   EXPECT_EQ(callbacks_.messageBegin, 1);",
          "429:   EXPECT_EQ(callbacks_.headersComplete, 1);",
          "430:   EXPECT_EQ(callbacks_.messageComplete, 1);",
          "431:   EXPECT_EQ(callbacks_.streamErrors, 0);",
          "432:   EXPECT_EQ(callbacks_.sessionErrors, 1);",
          "433: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "734:   http2::writeGoaway(output_, 17, ErrorCode::ENHANCE_YOUR_CALM);",
          "736:   parse();",
          "738:   EXPECT_EQ(callbacks_.headersComplete, 0);",
          "739:   EXPECT_EQ(callbacks_.messageComplete, 0);",
          "740:   EXPECT_EQ(callbacks_.streamErrors, 0);",
          "",
          "[Removed Lines]",
          "737:   EXPECT_EQ(callbacks_.messageBegin, 1);",
          "",
          "[Added Lines]",
          "720:   EXPECT_EQ(callbacks_.messageBegin, 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "758:   output_.append(std::move(frame));",
          "760:   parse();",
          "762:   EXPECT_EQ(callbacks_.headersComplete, 0);",
          "763:   EXPECT_EQ(callbacks_.messageComplete, 0);",
          "764:   EXPECT_EQ(callbacks_.streamErrors, 0);",
          "",
          "[Removed Lines]",
          "761:   EXPECT_EQ(callbacks_.messageBegin, 1);",
          "",
          "[Added Lines]",
          "744:   EXPECT_EQ(callbacks_.messageBegin, 0);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "778:   http2::writeContinuation(output_, 3, true, std::move(fakeHeaders));",
          "780:   parse();",
          "782:   EXPECT_EQ(callbacks_.headersComplete, 0);",
          "783:   EXPECT_EQ(callbacks_.messageComplete, 0);",
          "784:   EXPECT_EQ(callbacks_.streamErrors, 0);",
          "",
          "[Removed Lines]",
          "781:   EXPECT_EQ(callbacks_.messageBegin, 1);",
          "",
          "[Added Lines]",
          "764:   EXPECT_EQ(callbacks_.messageBegin, 0);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1813:   EXPECT_TRUE(callbackTypeTracker.isAllFrameTypesReceived());",
          "1814: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1799: TEST_F(HTTP2CodecTest, Trailers) {",
          "1800:   HTTPMessage req = getGetRequest(\"/guacamole\");",
          "1801:   req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");",
          "1802:   upstreamCodec_.generateHeader(output_, 1, req);",
          "1804:   string data(\"abcde\");",
          "1805:   auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());",
          "1806:   upstreamCodec_.generateBody(",
          "1807:       output_, 1, std::move(buf), HTTPCodec::NoPadding, false /* eom */);",
          "1809:   HTTPHeaders trailers;",
          "1810:   trailers.add(\"x-trailer-1\", \"pico-de-gallo\");",
          "1811:   upstreamCodec_.generateTrailers(output_, 1, trailers);",
          "1813:   parse();",
          "1815:   EXPECT_EQ(callbacks_.messageBegin, 1);",
          "1816:   EXPECT_EQ(callbacks_.headersComplete, 1);",
          "1817:   EXPECT_EQ(callbacks_.bodyCalls, 1);",
          "1818:   EXPECT_EQ(callbacks_.bodyLength, 5);",
          "1819:   EXPECT_EQ(callbacks_.trailers, 1);",
          "1820:   EXPECT_NE(nullptr, callbacks_.msg->getTrailers());",
          "1821:   EXPECT_EQ(\"pico-de-gallo\",",
          "1822:             callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));",
          "1823:   EXPECT_EQ(callbacks_.messageComplete, 1);",
          "1824:   EXPECT_EQ(callbacks_.streamErrors, 0);",
          "1825:   EXPECT_EQ(callbacks_.sessionErrors, 0);",
          "1826: #ifndef NDEBUG",
          "1827:   EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 3);",
          "1828: #endif",
          "1829: }",
          "1831: TEST_F(HTTP2CodecTest, TrailersWithPseudoHeaders) {",
          "1832:   HTTPMessage req = getGetRequest(\"/guacamole\");",
          "1833:   req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");",
          "1834:   upstreamCodec_.generateHeader(output_, 1, req);",
          "1836:   string data(\"abcde\");",
          "1837:   auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());",
          "1838:   upstreamCodec_.generateBody(",
          "1839:       output_, 1, std::move(buf), HTTPCodec::NoPadding, false /* eom */);",
          "1841:   HPACKCodec headerCodec(TransportDirection::UPSTREAM);",
          "1842:   std::string post(\"POST\");",
          "1843:   std::vector<proxygen::compress::Header> trailers = {",
          "1844:       Header::makeHeaderForTest(headers::kMethod, post)};",
          "1845:   auto encodedTrailers = headerCodec.encode(trailers);",
          "1846:   http2::writeHeaders(output_,",
          "1847:                       std::move(encodedTrailers),",
          "1848:                       1,",
          "1849:                       folly::none,",
          "1850:                       http2::kNoPadding,",
          "1851:                       true,",
          "1852:                       true);",
          "1854:   parse();",
          "1856:   EXPECT_EQ(callbacks_.messageBegin, 1);",
          "1857:   EXPECT_EQ(callbacks_.headersComplete, 1);",
          "1858:   EXPECT_EQ(callbacks_.bodyCalls, 1);",
          "1859:   EXPECT_EQ(callbacks_.bodyLength, 5);",
          "1860:   EXPECT_EQ(callbacks_.trailers, 0);",
          "1861:   EXPECT_EQ(nullptr, callbacks_.msg->getTrailers());",
          "1862:   EXPECT_EQ(callbacks_.messageComplete, 0);",
          "1863:   EXPECT_EQ(callbacks_.streamErrors, 1);",
          "1864: }",
          "1866: TEST_F(HTTP2CodecTest, TrailersNoBody) {",
          "1867:   HTTPMessage req = getGetRequest(\"/guacamole\");",
          "1868:   req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");",
          "1869:   upstreamCodec_.generateHeader(output_, 1, req);",
          "1871:   HTTPHeaders trailers;",
          "1872:   trailers.add(\"x-trailer-1\", \"pico-de-gallo\");",
          "1873:   upstreamCodec_.generateTrailers(output_, 1, trailers);",
          "1875:   parse();",
          "1877:   EXPECT_EQ(callbacks_.messageBegin, 1);",
          "1878:   EXPECT_EQ(callbacks_.headersComplete, 1);",
          "1879:   EXPECT_EQ(callbacks_.bodyCalls, 0);",
          "1880:   EXPECT_EQ(callbacks_.bodyLength, 0);",
          "1881:   EXPECT_EQ(callbacks_.trailers, 1);",
          "1882:   EXPECT_NE(nullptr, callbacks_.msg->getTrailers());",
          "1883:   EXPECT_EQ(\"pico-de-gallo\",",
          "1884:             callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));",
          "1885:   EXPECT_EQ(callbacks_.messageComplete, 1);",
          "1886:   EXPECT_EQ(callbacks_.streamErrors, 0);",
          "1887:   EXPECT_EQ(callbacks_.sessionErrors, 0);",
          "1888: #ifndef NDEBUG",
          "1889:   EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 2);",
          "1890: #endif",
          "1891: }",
          "1893: TEST_F(HTTP2CodecTest, TrailersContinuation) {",
          "1894:   HTTPMessage req = getGetRequest(\"/guacamole\");",
          "1895:   upstreamCodec_.generateHeader(output_, 1, req);",
          "1897:   HTTPHeaders trailers;",
          "1898:   trailers.add(\"x-trailer-1\", \"pico-de-gallo\");",
          "1899:   trailers.add(\"x-huge-trailer\",",
          "1900:                std::string(http2::kMaxFramePayloadLengthMin, '!'));",
          "1901:   upstreamCodec_.generateTrailers(output_, 1, trailers);",
          "1903:   parse();",
          "1905:   EXPECT_EQ(callbacks_.messageBegin, 1);",
          "1906:   EXPECT_EQ(callbacks_.headersComplete, 1);",
          "1907:   EXPECT_EQ(callbacks_.messageComplete, 1);",
          "1908:   EXPECT_EQ(callbacks_.streamErrors, 0);",
          "1909:   EXPECT_EQ(callbacks_.sessionErrors, 0);",
          "1910:   EXPECT_NE(callbacks_.msg, nullptr);",
          "1911:   EXPECT_EQ(callbacks_.trailers, 1);",
          "1912:   EXPECT_NE(callbacks_.msg->getTrailers(), nullptr);",
          "1913:   EXPECT_EQ(\"pico-de-gallo\",",
          "1914:             callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));",
          "1915:   EXPECT_EQ(std::string(http2::kMaxFramePayloadLengthMin, '!'),",
          "1916:             callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-huge-trailer\"));",
          "1917: #ifndef NDEBUG",
          "1918:   EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 3);",
          "1919: #endif",
          "1920: }",
          "1922: TEST_F(HTTP2CodecTest, TrailersReply) {",
          "1923:   SetUpUpstreamTest();",
          "1924:   HTTPMessage resp;",
          "1925:   resp.setStatusCode(200);",
          "1926:   resp.setStatusMessage(\"nifty-nice\");",
          "1927:   resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");",
          "1928:   downstreamCodec_.generateHeader(output_, 1, resp);",
          "1930:   string data(\"abcde\");",
          "1931:   auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());",
          "1932:   downstreamCodec_.generateBody(",
          "1933:       output_, 1, std::move(buf), HTTPCodec::NoPadding, false);",
          "1935:   HTTPHeaders trailers;",
          "1936:   trailers.add(\"x-trailer-1\", \"pico-de-gallo\");",
          "1937:   trailers.add(\"x-trailer-2\", \"chicken-kyiv\");",
          "1938:   downstreamCodec_.generateTrailers(output_, 1, trailers);",
          "1940:   parseUpstream();",
          "1942:   callbacks_.expectMessage(true, 2, 200);",
          "1943:   EXPECT_EQ(callbacks_.bodyCalls, 1);",
          "1944:   EXPECT_EQ(callbacks_.bodyLength, 5);",
          "1945:   const auto& headers = callbacks_.msg->getHeaders();",
          "1946:   EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));",
          "1947:   EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));",
          "1948:   EXPECT_EQ(1, callbacks_.trailers);",
          "1949:   EXPECT_NE(nullptr, callbacks_.msg->getTrailers());",
          "1950:   EXPECT_EQ(\"pico-de-gallo\",",
          "1951:             callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));",
          "1952:   EXPECT_EQ(\"chicken-kyiv\",",
          "1953:             callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-2\"));",
          "1954: #ifndef NDEBUG",
          "1955:   EXPECT_EQ(upstreamCodec_.getReceivedFrameCount(), 4);",
          "1956: #endif",
          "1957: }",
          "1959: TEST_F(HTTP2CodecTest, TrailersReplyWithNoData) {",
          "1960:   SetUpUpstreamTest();",
          "1961:   HTTPMessage resp;",
          "1962:   resp.setStatusCode(200);",
          "1963:   resp.setStatusMessage(\"nifty-nice\");",
          "1964:   resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");",
          "1965:   downstreamCodec_.generateHeader(output_, 1, resp);",
          "1967:   HTTPHeaders trailers;",
          "1968:   trailers.add(\"x-trailer-1\", \"pico-de-gallo\");",
          "1969:   downstreamCodec_.generateTrailers(output_, 1, trailers);",
          "1971:   parseUpstream();",
          "1973:   callbacks_.expectMessage(true, 2, 200);",
          "1974:   EXPECT_EQ(callbacks_.bodyCalls, 0);",
          "1975:   EXPECT_EQ(callbacks_.bodyLength, 0);",
          "1976:   const auto& headers = callbacks_.msg->getHeaders();",
          "1977:   EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));",
          "1978:   EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));",
          "1979:   EXPECT_EQ(1, callbacks_.trailers);",
          "1980:   EXPECT_NE(nullptr, callbacks_.msg->getTrailers());",
          "1981:   EXPECT_EQ(\"pico-de-gallo\",",
          "1982:             callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));",
          "1983: #ifndef NDEBUG",
          "1984:   EXPECT_EQ(upstreamCodec_.getReceivedFrameCount(), 3);",
          "1985: #endif",
          "1986: }",
          "1988: TEST_F(HTTP2CodecTest, TrailersReplyWithPseudoHeaders) {",
          "1989:   SetUpUpstreamTest();",
          "1990:   HTTPMessage resp;",
          "1991:   resp.setStatusCode(200);",
          "1992:   resp.setStatusMessage(\"nifty-nice\");",
          "1993:   resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");",
          "1994:   downstreamCodec_.generateHeader(output_, 1, resp);",
          "1996:   string data(\"abcde\");",
          "1997:   auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());",
          "1998:   downstreamCodec_.generateBody(",
          "1999:       output_, 1, std::move(buf), HTTPCodec::NoPadding, false);",
          "2001:   HPACKCodec headerCodec(TransportDirection::DOWNSTREAM);",
          "2002:   std::string post(\"POST\");",
          "2003:   std::vector<proxygen::compress::Header> trailers = {",
          "2004:       Header::makeHeaderForTest(headers::kMethod, post)};",
          "2005:   auto encodedTrailers = headerCodec.encode(trailers);",
          "2006:   http2::writeHeaders(output_,",
          "2007:                       std::move(encodedTrailers),",
          "2008:                       1,",
          "2009:                       folly::none,",
          "2010:                       http2::kNoPadding,",
          "2011:                       true,",
          "2012:                       true);",
          "2013:   parseUpstream();",
          "2015:   EXPECT_EQ(callbacks_.messageBegin, 1);",
          "2016:   EXPECT_EQ(callbacks_.headersComplete, 1);",
          "2017:   EXPECT_EQ(callbacks_.trailers, 0);",
          "2018:   EXPECT_EQ(nullptr, callbacks_.msg->getTrailers());",
          "2019:   EXPECT_EQ(callbacks_.streamErrors, 1);",
          "2020:   EXPECT_EQ(callbacks_.sessionErrors, 0);",
          "2021: }",
          "2023: TEST_F(HTTP2CodecTest, TrailersReplyContinuation) {",
          "2024:   SetUpUpstreamTest();",
          "2025:   HTTPMessage resp;",
          "2026:   resp.setStatusCode(200);",
          "2027:   downstreamCodec_.generateHeader(output_, 1, resp);",
          "2029:   HTTPHeaders trailers;",
          "2030:   trailers.add(\"x-trailer-1\", \"pico-de-gallo\");",
          "2031:   trailers.add(\"x-huge-trailer\",",
          "2032:                std::string(http2::kMaxFramePayloadLengthMin, '!'));",
          "2033:   downstreamCodec_.generateTrailers(output_, 1, trailers);",
          "2035:   parseUpstream();",
          "2037:   EXPECT_EQ(callbacks_.messageBegin, 1);",
          "2038:   EXPECT_EQ(callbacks_.headersComplete, 1);",
          "2039:   EXPECT_EQ(callbacks_.messageComplete, 1);",
          "2040:   EXPECT_EQ(callbacks_.streamErrors, 0);",
          "2041:   EXPECT_EQ(callbacks_.sessionErrors, 0);",
          "2042:   EXPECT_NE(callbacks_.msg, nullptr);",
          "2043:   EXPECT_EQ(callbacks_.msg->getStatusCode(), 200);",
          "2044:   EXPECT_EQ(1, callbacks_.trailers);",
          "2045:   EXPECT_NE(nullptr, callbacks_.msg->getTrailers());",
          "2046:   EXPECT_EQ(\"pico-de-gallo\",",
          "2047:             callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));",
          "2048:   EXPECT_EQ(std::string(http2::kMaxFramePayloadLengthMin, '!'),",
          "2049:             callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-huge-trailer\"));",
          "2050: #ifndef NDEBUG",
          "2051:   EXPECT_EQ(upstreamCodec_.getReceivedFrameCount(), 4);",
          "2052: #endif",
          "2053: }",
          "2055: TEST_F(HTTP2CodecTest, TrailersReplyMissingContinuation) {",
          "2056:   SetUpUpstreamTest();",
          "2057:   HTTPMessage resp;",
          "2058:   resp.setStatusCode(200);",
          "2059:   downstreamCodec_.generateHeader(output_, 1, resp);",
          "2061:   HTTPHeaders trailers;",
          "2062:   trailers.add(\"x-trailer-1\", \"pico-de-gallo\");",
          "2063:   trailers.add(\"x-huge-trailer\",",
          "2064:                std::string(http2::kMaxFramePayloadLengthMin, '!'));",
          "2065:   downstreamCodec_.generateTrailers(output_, 1, trailers);",
          "2067:   output_.trimEnd(http2::kFrameHeaderSize + 4132);",
          "2070:   http2::writeGoaway(output_, 17, ErrorCode::ENHANCE_YOUR_CALM);",
          "2072:   parseUpstream();",
          "2074:   EXPECT_EQ(callbacks_.messageBegin, 1);",
          "2075:   EXPECT_EQ(callbacks_.headersComplete, 1);",
          "2076:   EXPECT_EQ(callbacks_.messageComplete, 0);",
          "2077:   EXPECT_EQ(callbacks_.streamErrors, 0);",
          "2078:   EXPECT_EQ(callbacks_.sessionErrors, 1);",
          "2079: #ifndef NDEBUG",
          "2080:   EXPECT_EQ(upstreamCodec_.getReceivedFrameCount(), 4);",
          "2081: #endif",
          "2082: }",
          "",
          "---------------"
        ],
        "proxygen/lib/http/codec/test/TestUtils.h||proxygen/lib/http/codec/test/TestUtils.h": [
          "File: proxygen/lib/http/codec/test/TestUtils.h -> proxygen/lib/http/codec/test/TestUtils.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "146:   void onChunkComplete(HTTPCodec::StreamID /*stream*/) override {",
          "147:     chunkComplete++;",
          "148:   }",
          "152:     trailers++;",
          "153:   }",
          "154:   void onMessageComplete(HTTPCodec::StreamID /*stream*/,",
          "155:                          bool /*upgrade*/) override {",
          "",
          "[Removed Lines]",
          "149:   void onTrailersComplete(",
          "150:       HTTPCodec::StreamID /*stream*/,",
          "151:       std::unique_ptr<HTTPHeaders> /*inTrailers*/) override {",
          "",
          "[Added Lines]",
          "149:   void onTrailersComplete(HTTPCodec::StreamID /*stream*/,",
          "150:                           std::unique_ptr<HTTPHeaders> inTrailers) override {",
          "152:     if (msg) {",
          "153:       msg->setTrailers(std::move(inTrailers));",
          "154:     }",
          "",
          "---------------"
        ],
        "proxygen/lib/http/session/test/HTTPDownstreamSessionTest.cpp||proxygen/lib/http/session/test/HTTPDownstreamSessionTest.cpp": [
          "File: proxygen/lib/http/session/test/HTTPDownstreamSessionTest.cpp -> proxygen/lib/http/session/test/HTTPDownstreamSessionTest.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "3116:   eventBase_.loop();",
          "3117: }",
          "3142: TEST_F(HTTP2DownstreamSessionTest, TestPriorityWeights) {",
          "3144:   auto priGroupID = clientCodec_->createStream();",
          "",
          "[Removed Lines]",
          "3119: TEST_F(HTTP2DownstreamSessionTest, ContinuationTimeout) {",
          "3121:   auto req = getBigGetRequest();",
          "3122:   sendRequest(req);",
          "3124:   HTTPSession::DestructorGuard g(httpSession_);",
          "3126:   auto buf = requests_.split(40);",
          "3127:   buf->coalesce();",
          "3128:   transport_->addReadEvent(buf->data(), buf->length(), milliseconds(0));",
          "3130:   flushRequestsAndLoop(false, milliseconds(0),",
          "3131:                        transactionTimeouts_->getDefaultTimeout());",
          "3133:   EXPECT_CALL(callbacks_, onSettings(_));",
          "3135:   EXPECT_CALL(callbacks_, onAbort(1, ErrorCode::INTERNAL_ERROR));",
          "3137:   EXPECT_CALL(callbacks_, onAbort(1, ErrorCode::STREAM_CLOSED));",
          "3138:   parseOutput(*clientCodec_);",
          "3139:   cleanup();",
          "3140: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
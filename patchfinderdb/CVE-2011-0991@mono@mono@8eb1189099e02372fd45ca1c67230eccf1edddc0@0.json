{
  "cve_id": "CVE-2011-0991",
  "cve_desc": "Use-after-free vulnerability in Mono, when Moonlight 2.x before 2.4.1 or 3.x before 3.99.3 is used, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to finalizing and then resurrecting a DynamicMethod instance.",
  "repo": "mono/mono",
  "patch_hash": "8eb1189099e02372fd45ca1c67230eccf1edddc0",
  "patch_info": {
    "commit_hash": "8eb1189099e02372fd45ca1c67230eccf1edddc0",
    "repo": "mono/mono",
    "commit_url": "https://github.com/mono/mono/commit/8eb1189099e02372fd45ca1c67230eccf1edddc0",
    "files": [
      "mono/metadata/gc-internal.h",
      "mono/metadata/gc.c"
    ],
    "message": "Implement a reference queue API.\n\n\t* gc.c: A reference queue allows one to queue\n\tcallbcks for when objects are collected.\n\tIt allows for safe cleanup of objects that can\n\tonly be done when it is effectively collected.\n\tThe major difference with regular finalization\n\tis that the collector makes sure the object\n\twas collected - and can't be resurrected.\n\n\t* gc-internal.h: Export entrypoints for the\n\tnew API.",
    "before_after_code_files": [
      "mono/metadata/gc-internal.h||mono/metadata/gc-internal.h",
      "mono/metadata/gc.c||mono/metadata/gc.c"
    ]
  },
  "patch_diff": {
    "mono/metadata/gc-internal.h||mono/metadata/gc-internal.h": [
      "File: mono/metadata/gc-internal.h -> mono/metadata/gc-internal.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "336: FILE *mono_gc_get_logfile (void) MONO_INTERNAL;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "338: typedef void (*mono_reference_queue_callback) (void *user_data);",
      "340: typedef struct _MonoReferenceQueue MonoReferenceQueue;",
      "341: typedef struct _RefQueueEntry RefQueueEntry;",
      "343: struct _RefQueueEntry {",
      "344:  void *dis_link;",
      "345:  void *user_data;",
      "346:  RefQueueEntry *next;",
      "347: };",
      "349: struct _MonoReferenceQueue {",
      "350:  RefQueueEntry *queue;",
      "351:  mono_reference_queue_callback callback;",
      "352:  MonoReferenceQueue *next;",
      "353:  gboolean should_be_deleted;",
      "354: };",
      "356: MonoReferenceQueue* mono_gc_reference_queue_new (mono_reference_queue_callback callback) MONO_INTERNAL;",
      "357: void mono_gc_reference_queue_free (MonoReferenceQueue *queue) MONO_INTERNAL;",
      "358: gboolean mono_gc_reference_queue_add (MonoReferenceQueue *queue, MonoObject *obj, void *user_data) MONO_INTERNAL;",
      "",
      "---------------"
    ],
    "mono/metadata/gc.c||mono/metadata/gc.c": [
      "File: mono/metadata/gc.c -> mono/metadata/gc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "54: #define mono_finalizer_lock() EnterCriticalSection (&finalizer_mutex)",
      "55: #define mono_finalizer_unlock() LeaveCriticalSection (&finalizer_mutex)",
      "56: static CRITICAL_SECTION finalizer_mutex;",
      "58: static GSList *domains_to_finalize= NULL;",
      "59: static MonoMList *threads_to_finalize = NULL;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "57: static CRITICAL_SECTION reference_queue_mutex;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "65: static void mono_gchandle_set_target (guint32 gchandle, MonoObject *obj);",
      "67: #ifndef HAVE_NULL_GC",
      "68: static HANDLE pending_done_event;",
      "69: static HANDLE shutdown_event;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "68: static void reference_queue_proccess_all (void);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1065:   mono_attach_maybe_start ();",
      "1066: #endif",
      "1068:   if (domains_to_finalize) {",
      "1069:    mono_finalizer_lock ();",
      "1070:    if (domains_to_finalize) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1070:   reference_queue_proccess_all ();",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1097:  InitializeCriticalSection (&allocator_section);",
      "1099:  InitializeCriticalSection (&finalizer_mutex);",
      "1101:  MONO_GC_REGISTER_ROOT_FIXED (gc_handles [HANDLE_NORMAL].entries);",
      "1102:  MONO_GC_REGISTER_ROOT_FIXED (gc_handles [HANDLE_PINNED].entries);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1105:  InitializeCriticalSection (&reference_queue_mutex);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1174:  DeleteCriticalSection (&handle_section);",
      "1175:  DeleteCriticalSection (&allocator_section);",
      "1176:  DeleteCriticalSection (&finalizer_mutex);",
      "1177: }",
      "1179: #else",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1183:  DeleteCriticalSection (&reference_queue_mutex);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1292:  return mono_object_new_specific (vtable);",
      "1293: }",
      "1294: #endif",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1304: static MonoReferenceQueue *ref_queues;",
      "1306: static void",
      "1307: ref_list_remove_element (RefQueueEntry **prev, RefQueueEntry *element)",
      "1308: {",
      "1309:  do {",
      "1311:   while (*prev != element)",
      "1312:    prev = &(*prev)->next;",
      "1313:  } while (prev && InterlockedCompareExchangePointer ((void*)prev, element->next, element) != element);",
      "1314: }",
      "1316: static void",
      "1317: ref_list_push (RefQueueEntry **head, RefQueueEntry *value)",
      "1318: {",
      "1319:  RefQueueEntry *current;",
      "1320:  do {",
      "1321:   current = *head;",
      "1322:   value->next = current;",
      "1323:  } while (InterlockedCompareExchangePointer ((void*)head, value, current) != current);",
      "1324: }",
      "1326: static void",
      "1327: reference_queue_proccess (MonoReferenceQueue *queue)",
      "1328: {",
      "1329:  RefQueueEntry **iter = &queue->queue;",
      "1330:  RefQueueEntry *entry;",
      "1331:  while ((entry = *iter)) {",
      "1332:   if (queue->should_be_deleted || !mono_gc_weak_link_get (&entry->dis_link)) {",
      "1333:    ref_list_remove_element (iter, entry);",
      "1334:    mono_gc_weak_link_remove (&entry->dis_link);",
      "1335:    queue->callback (entry->user_data);",
      "1336:    g_free (entry);",
      "1337:   } else {",
      "1338:    iter = &entry->next;",
      "1339:   }",
      "1340:  }",
      "1341: }",
      "1343: static void",
      "1344: reference_queue_proccess_all (void)",
      "1345: {",
      "1346:  MonoReferenceQueue **iter;",
      "1347:  MonoReferenceQueue *queue = ref_queues;",
      "1348:  for (; queue; queue = queue->next)",
      "1349:   reference_queue_proccess (queue);",
      "1351: restart:",
      "1352:  EnterCriticalSection (&reference_queue_mutex);",
      "1353:  for (iter = &ref_queues; *iter;) {",
      "1354:   queue = *iter;",
      "1355:   if (!queue->should_be_deleted) {",
      "1356:    iter = &queue->next;",
      "1357:    continue;",
      "1358:   }",
      "1359:   if (queue->queue) {",
      "1360:    LeaveCriticalSection (&reference_queue_mutex);",
      "1361:    reference_queue_proccess (queue);",
      "1362:    goto restart;",
      "1363:   }",
      "1365:   g_free (queue);",
      "1366:  }",
      "1367:  LeaveCriticalSection (&reference_queue_mutex);",
      "1368: }",
      "1381: MonoReferenceQueue*",
      "1382: mono_gc_reference_queue_new (mono_reference_queue_callback callback)",
      "1383: {",
      "1384:  MonoReferenceQueue *res = g_new0 (MonoReferenceQueue, 1);",
      "1385:  res->callback = callback;",
      "1387:  EnterCriticalSection (&reference_queue_mutex);",
      "1388:  res->next = ref_queues;",
      "1389:  ref_queues = res;",
      "1390:  LeaveCriticalSection (&reference_queue_mutex);",
      "1392:  return res;",
      "1393: }",
      "1405: gboolean",
      "1406: mono_gc_reference_queue_add (MonoReferenceQueue *queue, MonoObject *obj, void *user_data)",
      "1407: {",
      "1408:  RefQueueEntry *head;",
      "1409:  RefQueueEntry *entry;",
      "1410:  if (queue->should_be_deleted)",
      "1411:   return FALSE;",
      "1413:  entry = g_new0 (RefQueueEntry, 1);",
      "1414:  entry->user_data = user_data;",
      "1415:  mono_gc_weak_link_add (&entry->dis_link, obj, TRUE);",
      "1416:  ref_list_push (&queue->queue, entry);",
      "1417:  return TRUE;",
      "1418: }",
      "1430: void",
      "1431: mono_gc_reference_queue_free (MonoReferenceQueue *queue)",
      "1432: {",
      "1433:  queue->should_be_deleted = TRUE;",
      "1434: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a9c7a7361d70e9742c2e17742815111eaf4938fa",
      "candidate_info": {
        "commit_hash": "a9c7a7361d70e9742c2e17742815111eaf4938fa",
        "repo": "mono/mono",
        "commit_url": "https://github.com/mono/mono/commit/a9c7a7361d70e9742c2e17742815111eaf4938fa",
        "files": [
          "mono/metadata/gc-internal.h",
          "mono/metadata/gc.c"
        ],
        "message": "Implement a reference queue API.\n\n\t* gc.c: A reference queue allows one to queue\n\tcallbcks for when objects are collected.\n\tIt allows for safe cleanup of objects that can\n\tonly be done when it is effectively collected.\n\tThe major difference with regular finalization\n\tis that the collector makes sure the object\n\twas collected - and can't be resurrected.\n\n\t* gc-internal.h: Export entrypoints for the\n\tnew API.",
        "before_after_code_files": [
          "mono/metadata/gc-internal.h||mono/metadata/gc-internal.h",
          "mono/metadata/gc.c||mono/metadata/gc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_message": 1,
        "olp_code_files": {
          "patch": [
            "mono/metadata/gc-internal.h||mono/metadata/gc-internal.h",
            "mono/metadata/gc.c||mono/metadata/gc.c"
          ],
          "candidate": [
            "mono/metadata/gc-internal.h||mono/metadata/gc-internal.h",
            "mono/metadata/gc.c||mono/metadata/gc.c"
          ]
        }
      },
      "candidate_diff": {
        "mono/metadata/gc-internal.h||mono/metadata/gc-internal.h": [
          "File: mono/metadata/gc-internal.h -> mono/metadata/gc-internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "199: gsize* mono_gc_get_bitmap_for_descr (void *descr, int *numbits) MONO_INTERNAL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "203: int mono_gc_get_suspend_signal (void) MONO_INTERNAL;",
          "208: char* mono_gc_get_description (void) MONO_INTERNAL;",
          "213: void mono_gc_set_desktop_mode (void) MONO_INTERNAL;",
          "218: gboolean mono_gc_is_moving (void) MONO_INTERNAL;",
          "220: typedef void* (*MonoGCLockedCallbackFunc) (void *data);",
          "222: void* mono_gc_invoke_with_gc_lock (MonoGCLockedCallbackFunc func, void *data) MONO_INTERNAL;",
          "224: int mono_gc_get_los_limit (void) MONO_INTERNAL;",
          "226: guint8* mono_gc_get_card_table (int *shift_bits, gpointer *card_mask) MONO_INTERNAL;",
          "228: void* mono_gc_get_nursery (int *shift_bits, size_t *size) MONO_INTERNAL;",
          "233: gboolean mono_gc_is_disabled (void) MONO_INTERNAL;",
          "235: #if defined(__MACH__)",
          "236: void mono_gc_register_mach_exception_thread (pthread_t thread) MONO_INTERNAL;",
          "237: pthread_t mono_gc_get_mach_exception_thread (void) MONO_INTERNAL;",
          "238: #endif",
          "240: gboolean mono_gc_parse_environment_string_extract_number (const char *str, glong *out) MONO_INTERNAL;",
          "242: gboolean mono_gc_precise_stack_mark_enabled (void) MONO_INTERNAL;",
          "244: FILE *mono_gc_get_logfile (void) MONO_INTERNAL;",
          "246: typedef void (*mono_reference_queue_callback) (void *user_data);",
          "248: typedef struct _MonoReferenceQueue MonoReferenceQueue;",
          "249: typedef struct _RefQueueEntry RefQueueEntry;",
          "251: struct _RefQueueEntry {",
          "252:  void *dis_link;",
          "253:  void *user_data;",
          "254:  RefQueueEntry *next;",
          "255: };",
          "257: struct _MonoReferenceQueue {",
          "258:  RefQueueEntry *queue;",
          "259:  mono_reference_queue_callback callback;",
          "260:  MonoReferenceQueue *next;",
          "261:  gboolean should_be_deleted;",
          "262: };",
          "264: MonoReferenceQueue* mono_gc_reference_queue_new (mono_reference_queue_callback callback) MONO_INTERNAL;",
          "265: void mono_gc_reference_queue_free (MonoReferenceQueue *queue) MONO_INTERNAL;",
          "266: gboolean mono_gc_reference_queue_add (MonoReferenceQueue *queue, MonoObject *obj, void *user_data) MONO_INTERNAL;",
          "",
          "---------------"
        ],
        "mono/metadata/gc.c||mono/metadata/gc.c": [
          "File: mono/metadata/gc.c -> mono/metadata/gc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "52: #define mono_finalizer_lock() EnterCriticalSection (&finalizer_mutex)",
          "53: #define mono_finalizer_unlock() LeaveCriticalSection (&finalizer_mutex)",
          "54: static CRITICAL_SECTION finalizer_mutex;",
          "56: static GSList *domains_to_finalize= NULL;",
          "57: static MonoMList *threads_to_finalize = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "55: static CRITICAL_SECTION reference_queue_mutex;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "63: static void mono_gchandle_set_target (guint32 gchandle, MonoObject *obj);",
          "65: #ifndef HAVE_NULL_GC",
          "66: static HANDLE pending_done_event;",
          "67: static HANDLE shutdown_event;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66: static void reference_queue_proccess_all (void);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1029:   mono_attach_maybe_start ();",
          "1030: #endif",
          "1032:   if (domains_to_finalize) {",
          "1033:    mono_finalizer_lock ();",
          "1034:    if (domains_to_finalize) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1034:   reference_queue_proccess_all ();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1065:  InitializeCriticalSection (&allocator_section);",
          "1067:  InitializeCriticalSection (&finalizer_mutex);",
          "1069:  MONO_GC_REGISTER_ROOT (gc_handles [HANDLE_NORMAL].entries);",
          "1070:  MONO_GC_REGISTER_ROOT (gc_handles [HANDLE_PINNED].entries);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1073:  InitializeCriticalSection (&reference_queue_mutex);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1141:  DeleteCriticalSection (&handle_section);",
          "1142:  DeleteCriticalSection (&allocator_section);",
          "1143:  DeleteCriticalSection (&finalizer_mutex);",
          "1144: }",
          "1146: #else",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1150:  DeleteCriticalSection (&reference_queue_mutex);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1177: {",
          "1178:  return thread == gc_thread;",
          "1179: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1189: static MonoReferenceQueue *ref_queues;",
          "1191: static void",
          "1192: ref_list_remove_element (RefQueueEntry **prev, RefQueueEntry *element)",
          "1193: {",
          "1194:  do {",
          "1196:   while (*prev != element)",
          "1197:    prev = &(*prev)->next;",
          "1198:  } while (prev && InterlockedCompareExchangePointer ((void*)prev, element->next, element) != element);",
          "1199: }",
          "1201: static void",
          "1202: ref_list_push (RefQueueEntry **head, RefQueueEntry *value)",
          "1203: {",
          "1204:  RefQueueEntry *current;",
          "1205:  do {",
          "1206:   current = *head;",
          "1207:   value->next = current;",
          "1208:  } while (InterlockedCompareExchangePointer ((void*)head, value, current) != current);",
          "1209: }",
          "1211: static void",
          "1212: reference_queue_proccess (MonoReferenceQueue *queue)",
          "1213: {",
          "1214:  RefQueueEntry **iter = &queue->queue;",
          "1215:  RefQueueEntry *entry;",
          "1216:  while ((entry = *iter)) {",
          "1217:   if (queue->should_be_deleted || !mono_gc_weak_link_get (&entry->dis_link)) {",
          "1218:    ref_list_remove_element (iter, entry);",
          "1219:    mono_gc_weak_link_remove (&entry->dis_link);",
          "1220:    queue->callback (entry->user_data);",
          "1221:    g_free (entry);",
          "1222:   } else {",
          "1223:    iter = &entry->next;",
          "1224:   }",
          "1225:  }",
          "1226: }",
          "1228: static void",
          "1229: reference_queue_proccess_all (void)",
          "1230: {",
          "1231:  MonoReferenceQueue **iter;",
          "1232:  MonoReferenceQueue *queue = ref_queues;",
          "1233:  for (; queue; queue = queue->next)",
          "1234:   reference_queue_proccess (queue);",
          "1236: restart:",
          "1237:  EnterCriticalSection (&reference_queue_mutex);",
          "1238:  for (iter = &ref_queues; *iter;) {",
          "1239:   queue = *iter;",
          "1240:   if (!queue->should_be_deleted) {",
          "1241:    iter = &queue->next;",
          "1242:    continue;",
          "1243:   }",
          "1244:   if (queue->queue) {",
          "1245:    LeaveCriticalSection (&reference_queue_mutex);",
          "1246:    reference_queue_proccess (queue);",
          "1247:    goto restart;",
          "1248:   }",
          "1250:   g_free (queue);",
          "1251:  }",
          "1252:  LeaveCriticalSection (&reference_queue_mutex);",
          "1253: }",
          "1266: MonoReferenceQueue*",
          "1267: mono_gc_reference_queue_new (mono_reference_queue_callback callback)",
          "1268: {",
          "1269:  MonoReferenceQueue *res = g_new0 (MonoReferenceQueue, 1);",
          "1270:  res->callback = callback;",
          "1272:  EnterCriticalSection (&reference_queue_mutex);",
          "1273:  res->next = ref_queues;",
          "1274:  ref_queues = res;",
          "1275:  LeaveCriticalSection (&reference_queue_mutex);",
          "1277:  return res;",
          "1278: }",
          "1290: gboolean",
          "1291: mono_gc_reference_queue_add (MonoReferenceQueue *queue, MonoObject *obj, void *user_data)",
          "1292: {",
          "1293:  RefQueueEntry *head;",
          "1294:  RefQueueEntry *entry;",
          "1295:  if (queue->should_be_deleted)",
          "1296:   return FALSE;",
          "1298:  entry = g_new0 (RefQueueEntry, 1);",
          "1299:  entry->user_data = user_data;",
          "1300:  mono_gc_weak_link_add (&entry->dis_link, obj, TRUE);",
          "1301:  ref_list_push (&queue->queue, entry);",
          "1302:  return TRUE;",
          "1303: }",
          "1315: void",
          "1316: mono_gc_reference_queue_free (MonoReferenceQueue *queue)",
          "1317: {",
          "1318:  queue->should_be_deleted = TRUE;",
          "1319: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a3422f4ed469774b0557a7ee14a633a8bea18388",
      "candidate_info": {
        "commit_hash": "a3422f4ed469774b0557a7ee14a633a8bea18388",
        "repo": "mono/mono",
        "commit_url": "https://github.com/mono/mono/commit/a3422f4ed469774b0557a7ee14a633a8bea18388",
        "files": [
          "mono/metadata/gc-internal.h",
          "mono/metadata/gc.c"
        ],
        "message": "Implement a reference queue API.\n\n\t* gc.c: A reference queue allows one to queue\n\tcallbcks for when objects are collected.\n\tIt allows for safe cleanup of objects that can\n\tonly be done when it is effectively collected.\n\tThe major difference with regular finalization\n\tis that the collector makes sure the object\n\twas collected - and can't be resurrected.\n\n\t* gc-internal.h: Export entrypoints for the\n\tnew API.",
        "before_after_code_files": [
          "mono/metadata/gc-internal.h||mono/metadata/gc-internal.h",
          "mono/metadata/gc.c||mono/metadata/gc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_message": 1,
        "olp_code_files": {
          "patch": [
            "mono/metadata/gc-internal.h||mono/metadata/gc-internal.h",
            "mono/metadata/gc.c||mono/metadata/gc.c"
          ],
          "candidate": [
            "mono/metadata/gc-internal.h||mono/metadata/gc-internal.h",
            "mono/metadata/gc.c||mono/metadata/gc.c"
          ]
        }
      },
      "candidate_diff": {
        "mono/metadata/gc-internal.h||mono/metadata/gc-internal.h": [
          "File: mono/metadata/gc-internal.h -> mono/metadata/gc-internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "199: gsize* mono_gc_get_bitmap_for_descr (void *descr, int *numbits) MONO_INTERNAL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "203: int mono_gc_get_suspend_signal (void) MONO_INTERNAL;",
          "208: char* mono_gc_get_description (void) MONO_INTERNAL;",
          "213: void mono_gc_set_desktop_mode (void) MONO_INTERNAL;",
          "218: gboolean mono_gc_is_moving (void) MONO_INTERNAL;",
          "220: typedef void* (*MonoGCLockedCallbackFunc) (void *data);",
          "222: void* mono_gc_invoke_with_gc_lock (MonoGCLockedCallbackFunc func, void *data) MONO_INTERNAL;",
          "224: int mono_gc_get_los_limit (void) MONO_INTERNAL;",
          "226: guint8* mono_gc_get_card_table (int *shift_bits, gpointer *card_mask) MONO_INTERNAL;",
          "228: void* mono_gc_get_nursery (int *shift_bits, size_t *size) MONO_INTERNAL;",
          "233: gboolean mono_gc_is_disabled (void) MONO_INTERNAL;",
          "235: #if defined(__MACH__)",
          "236: void mono_gc_register_mach_exception_thread (pthread_t thread) MONO_INTERNAL;",
          "237: pthread_t mono_gc_get_mach_exception_thread (void) MONO_INTERNAL;",
          "238: #endif",
          "240: gboolean mono_gc_parse_environment_string_extract_number (const char *str, glong *out) MONO_INTERNAL;",
          "242: gboolean mono_gc_precise_stack_mark_enabled (void) MONO_INTERNAL;",
          "244: FILE *mono_gc_get_logfile (void) MONO_INTERNAL;",
          "246: typedef void (*mono_reference_queue_callback) (void *user_data);",
          "248: typedef struct _MonoReferenceQueue MonoReferenceQueue;",
          "249: typedef struct _RefQueueEntry RefQueueEntry;",
          "251: struct _RefQueueEntry {",
          "252:  void *dis_link;",
          "253:  void *user_data;",
          "254:  RefQueueEntry *next;",
          "255: };",
          "257: struct _MonoReferenceQueue {",
          "258:  RefQueueEntry *queue;",
          "259:  mono_reference_queue_callback callback;",
          "260:  MonoReferenceQueue *next;",
          "261:  gboolean should_be_deleted;",
          "262: };",
          "264: MonoReferenceQueue* mono_gc_reference_queue_new (mono_reference_queue_callback callback) MONO_INTERNAL;",
          "265: void mono_gc_reference_queue_free (MonoReferenceQueue *queue) MONO_INTERNAL;",
          "266: gboolean mono_gc_reference_queue_add (MonoReferenceQueue *queue, MonoObject *obj, void *user_data) MONO_INTERNAL;",
          "",
          "---------------"
        ],
        "mono/metadata/gc.c||mono/metadata/gc.c": [
          "File: mono/metadata/gc.c -> mono/metadata/gc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "52: #define mono_finalizer_lock() EnterCriticalSection (&finalizer_mutex)",
          "53: #define mono_finalizer_unlock() LeaveCriticalSection (&finalizer_mutex)",
          "54: static CRITICAL_SECTION finalizer_mutex;",
          "56: static GSList *domains_to_finalize= NULL;",
          "57: static MonoMList *threads_to_finalize = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "55: static CRITICAL_SECTION reference_queue_mutex;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "63: static void mono_gchandle_set_target (guint32 gchandle, MonoObject *obj);",
          "65: #ifndef HAVE_NULL_GC",
          "66: static HANDLE pending_done_event;",
          "67: static HANDLE shutdown_event;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66: static void reference_queue_proccess_all (void);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1029:   mono_attach_maybe_start ();",
          "1030: #endif",
          "1032:   if (domains_to_finalize) {",
          "1033:    mono_finalizer_lock ();",
          "1034:    if (domains_to_finalize) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1034:   reference_queue_proccess_all ();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1065:  InitializeCriticalSection (&allocator_section);",
          "1067:  InitializeCriticalSection (&finalizer_mutex);",
          "1069:  MONO_GC_REGISTER_ROOT (gc_handles [HANDLE_NORMAL].entries);",
          "1070:  MONO_GC_REGISTER_ROOT (gc_handles [HANDLE_PINNED].entries);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1073:  InitializeCriticalSection (&reference_queue_mutex);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1141:  DeleteCriticalSection (&handle_section);",
          "1142:  DeleteCriticalSection (&allocator_section);",
          "1143:  DeleteCriticalSection (&finalizer_mutex);",
          "1144: }",
          "1146: #else",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1150:  DeleteCriticalSection (&reference_queue_mutex);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1177: {",
          "1178:  return thread == gc_thread;",
          "1179: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1189: static MonoReferenceQueue *ref_queues;",
          "1191: static void",
          "1192: ref_list_remove_element (RefQueueEntry **prev, RefQueueEntry *element)",
          "1193: {",
          "1194:  do {",
          "1196:   while (*prev != element)",
          "1197:    prev = &(*prev)->next;",
          "1198:  } while (prev && InterlockedCompareExchangePointer ((void*)prev, element->next, element) != element);",
          "1199: }",
          "1201: static void",
          "1202: ref_list_push (RefQueueEntry **head, RefQueueEntry *value)",
          "1203: {",
          "1204:  RefQueueEntry *current;",
          "1205:  do {",
          "1206:   current = *head;",
          "1207:   value->next = current;",
          "1208:  } while (InterlockedCompareExchangePointer ((void*)head, value, current) != current);",
          "1209: }",
          "1211: static void",
          "1212: reference_queue_proccess (MonoReferenceQueue *queue)",
          "1213: {",
          "1214:  RefQueueEntry **iter = &queue->queue;",
          "1215:  RefQueueEntry *entry;",
          "1216:  while ((entry = *iter)) {",
          "1217:   if (queue->should_be_deleted || !mono_gc_weak_link_get (&entry->dis_link)) {",
          "1218:    ref_list_remove_element (iter, entry);",
          "1219:    mono_gc_weak_link_remove (&entry->dis_link);",
          "1220:    queue->callback (entry->user_data);",
          "1221:    g_free (entry);",
          "1222:   } else {",
          "1223:    iter = &entry->next;",
          "1224:   }",
          "1225:  }",
          "1226: }",
          "1228: static void",
          "1229: reference_queue_proccess_all (void)",
          "1230: {",
          "1231:  MonoReferenceQueue **iter;",
          "1232:  MonoReferenceQueue *queue = ref_queues;",
          "1233:  for (; queue; queue = queue->next)",
          "1234:   reference_queue_proccess (queue);",
          "1236: restart:",
          "1237:  EnterCriticalSection (&reference_queue_mutex);",
          "1238:  for (iter = &ref_queues; *iter;) {",
          "1239:   queue = *iter;",
          "1240:   if (!queue->should_be_deleted) {",
          "1241:    iter = &queue->next;",
          "1242:    continue;",
          "1243:   }",
          "1244:   if (queue->queue) {",
          "1245:    LeaveCriticalSection (&reference_queue_mutex);",
          "1246:    reference_queue_proccess (queue);",
          "1247:    goto restart;",
          "1248:   }",
          "1250:   g_free (queue);",
          "1251:  }",
          "1252:  LeaveCriticalSection (&reference_queue_mutex);",
          "1253: }",
          "1266: MonoReferenceQueue*",
          "1267: mono_gc_reference_queue_new (mono_reference_queue_callback callback)",
          "1268: {",
          "1269:  MonoReferenceQueue *res = g_new0 (MonoReferenceQueue, 1);",
          "1270:  res->callback = callback;",
          "1272:  EnterCriticalSection (&reference_queue_mutex);",
          "1273:  res->next = ref_queues;",
          "1274:  ref_queues = res;",
          "1275:  LeaveCriticalSection (&reference_queue_mutex);",
          "1277:  return res;",
          "1278: }",
          "1290: gboolean",
          "1291: mono_gc_reference_queue_add (MonoReferenceQueue *queue, MonoObject *obj, void *user_data)",
          "1292: {",
          "1293:  RefQueueEntry *head;",
          "1294:  RefQueueEntry *entry;",
          "1295:  if (queue->should_be_deleted)",
          "1296:   return FALSE;",
          "1298:  entry = g_new0 (RefQueueEntry, 1);",
          "1299:  entry->user_data = user_data;",
          "1300:  mono_gc_weak_link_add (&entry->dis_link, obj, TRUE);",
          "1301:  ref_list_push (&queue->queue, entry);",
          "1302:  return TRUE;",
          "1303: }",
          "1315: void",
          "1316: mono_gc_reference_queue_free (MonoReferenceQueue *queue)",
          "1317: {",
          "1318:  queue->should_be_deleted = TRUE;",
          "1319: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fd57b963ad3e43cc1d7c6a5bad87d9342d9038e0",
      "candidate_info": {
        "commit_hash": "fd57b963ad3e43cc1d7c6a5bad87d9342d9038e0",
        "repo": "mono/mono",
        "commit_url": "https://github.com/mono/mono/commit/fd57b963ad3e43cc1d7c6a5bad87d9342d9038e0",
        "files": [
          "mono/metadata/gc-internal.h",
          "mono/metadata/gc.c"
        ],
        "message": "Implement a reference queue API.\n\n\t* gc.c: A reference queue allows one to queue\n\tcallbcks for when objects are collected.\n\tIt allows for safe cleanup of objects that can\n\tonly be done when it is effectively collected.\n\tThe major difference with regular finalization\n\tis that the collector makes sure the object\n\twas collected - and can't be resurrected.\n\n\t* gc-internal.h: Export entrypoints for the\n\tnew API.",
        "before_after_code_files": [
          "mono/metadata/gc-internal.h||mono/metadata/gc-internal.h",
          "mono/metadata/gc.c||mono/metadata/gc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_message": 1,
        "olp_code_files": {
          "patch": [
            "mono/metadata/gc-internal.h||mono/metadata/gc-internal.h",
            "mono/metadata/gc.c||mono/metadata/gc.c"
          ],
          "candidate": [
            "mono/metadata/gc-internal.h||mono/metadata/gc-internal.h",
            "mono/metadata/gc.c||mono/metadata/gc.c"
          ]
        }
      },
      "candidate_diff": {
        "mono/metadata/gc-internal.h||mono/metadata/gc-internal.h": [
          "File: mono/metadata/gc-internal.h -> mono/metadata/gc-internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "332: gboolean mono_gc_parse_environment_string_extract_number (const char *str, glong *out) MONO_INTERNAL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "334: gboolean mono_gc_precise_stack_mark_enabled (void) MONO_INTERNAL;",
          "336: FILE *mono_gc_get_logfile (void) MONO_INTERNAL;",
          "338: typedef void (*mono_reference_queue_callback) (void *user_data);",
          "340: typedef struct _MonoReferenceQueue MonoReferenceQueue;",
          "341: typedef struct _RefQueueEntry RefQueueEntry;",
          "343: struct _RefQueueEntry {",
          "344:  void *dis_link;",
          "345:  void *user_data;",
          "346:  RefQueueEntry *next;",
          "347: };",
          "349: struct _MonoReferenceQueue {",
          "350:  RefQueueEntry *queue;",
          "351:  mono_reference_queue_callback callback;",
          "352:  MonoReferenceQueue *next;",
          "353:  gboolean should_be_deleted;",
          "354: };",
          "356: MonoReferenceQueue* mono_gc_reference_queue_new (mono_reference_queue_callback callback) MONO_INTERNAL;",
          "357: void mono_gc_reference_queue_free (MonoReferenceQueue *queue) MONO_INTERNAL;",
          "358: gboolean mono_gc_reference_queue_add (MonoReferenceQueue *queue, MonoObject *obj, void *user_data) MONO_INTERNAL;",
          "",
          "---------------"
        ],
        "mono/metadata/gc.c||mono/metadata/gc.c": [
          "File: mono/metadata/gc.c -> mono/metadata/gc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "54: #define mono_finalizer_lock() EnterCriticalSection (&finalizer_mutex)",
          "55: #define mono_finalizer_unlock() LeaveCriticalSection (&finalizer_mutex)",
          "56: static CRITICAL_SECTION finalizer_mutex;",
          "58: static GSList *domains_to_finalize= NULL;",
          "59: static MonoMList *threads_to_finalize = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "57: static CRITICAL_SECTION reference_queue_mutex;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "65: static void mono_gchandle_set_target (guint32 gchandle, MonoObject *obj);",
          "67: #ifndef HAVE_NULL_GC",
          "68: static HANDLE pending_done_event;",
          "69: static HANDLE shutdown_event;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68: static void reference_queue_proccess_all (void);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1059:   mono_attach_maybe_start ();",
          "1060: #endif",
          "1062:   if (domains_to_finalize) {",
          "1063:    mono_finalizer_lock ();",
          "1064:    if (domains_to_finalize) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1064:   reference_queue_proccess_all ();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1091:  InitializeCriticalSection (&allocator_section);",
          "1093:  InitializeCriticalSection (&finalizer_mutex);",
          "1095:  MONO_GC_REGISTER_ROOT_FIXED (gc_handles [HANDLE_NORMAL].entries);",
          "1096:  MONO_GC_REGISTER_ROOT_FIXED (gc_handles [HANDLE_PINNED].entries);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1099:  InitializeCriticalSection (&reference_queue_mutex);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1168:  DeleteCriticalSection (&handle_section);",
          "1169:  DeleteCriticalSection (&allocator_section);",
          "1170:  DeleteCriticalSection (&finalizer_mutex);",
          "1171: }",
          "1173: #else",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1177:  DeleteCriticalSection (&reference_queue_mutex);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1286:  return mono_object_new_specific (vtable);",
          "1287: }",
          "1288: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1298: static MonoReferenceQueue *ref_queues;",
          "1300: static void",
          "1301: ref_list_remove_element (RefQueueEntry **prev, RefQueueEntry *element)",
          "1302: {",
          "1303:  do {",
          "1305:   while (*prev != element)",
          "1306:    prev = &(*prev)->next;",
          "1307:  } while (prev && InterlockedCompareExchangePointer ((void*)prev, element->next, element) != element);",
          "1308: }",
          "1310: static void",
          "1311: ref_list_push (RefQueueEntry **head, RefQueueEntry *value)",
          "1312: {",
          "1313:  RefQueueEntry *current;",
          "1314:  do {",
          "1315:   current = *head;",
          "1316:   value->next = current;",
          "1317:  } while (InterlockedCompareExchangePointer ((void*)head, value, current) != current);",
          "1318: }",
          "1320: static void",
          "1321: reference_queue_proccess (MonoReferenceQueue *queue)",
          "1322: {",
          "1323:  RefQueueEntry **iter = &queue->queue;",
          "1324:  RefQueueEntry *entry;",
          "1325:  while ((entry = *iter)) {",
          "1326:   if (queue->should_be_deleted || !mono_gc_weak_link_get (&entry->dis_link)) {",
          "1327:    ref_list_remove_element (iter, entry);",
          "1328:    mono_gc_weak_link_remove (&entry->dis_link);",
          "1329:    queue->callback (entry->user_data);",
          "1330:    g_free (entry);",
          "1331:   } else {",
          "1332:    iter = &entry->next;",
          "1333:   }",
          "1334:  }",
          "1335: }",
          "1337: static void",
          "1338: reference_queue_proccess_all (void)",
          "1339: {",
          "1340:  MonoReferenceQueue **iter;",
          "1341:  MonoReferenceQueue *queue = ref_queues;",
          "1342:  for (; queue; queue = queue->next)",
          "1343:   reference_queue_proccess (queue);",
          "1345: restart:",
          "1346:  EnterCriticalSection (&reference_queue_mutex);",
          "1347:  for (iter = &ref_queues; *iter;) {",
          "1348:   queue = *iter;",
          "1349:   if (!queue->should_be_deleted) {",
          "1350:    iter = &queue->next;",
          "1351:    continue;",
          "1352:   }",
          "1353:   if (queue->queue) {",
          "1354:    LeaveCriticalSection (&reference_queue_mutex);",
          "1355:    reference_queue_proccess (queue);",
          "1356:    goto restart;",
          "1357:   }",
          "1359:   g_free (queue);",
          "1360:  }",
          "1361:  LeaveCriticalSection (&reference_queue_mutex);",
          "1362: }",
          "1375: MonoReferenceQueue*",
          "1376: mono_gc_reference_queue_new (mono_reference_queue_callback callback)",
          "1377: {",
          "1378:  MonoReferenceQueue *res = g_new0 (MonoReferenceQueue, 1);",
          "1379:  res->callback = callback;",
          "1381:  EnterCriticalSection (&reference_queue_mutex);",
          "1382:  res->next = ref_queues;",
          "1383:  ref_queues = res;",
          "1384:  LeaveCriticalSection (&reference_queue_mutex);",
          "1386:  return res;",
          "1387: }",
          "1399: gboolean",
          "1400: mono_gc_reference_queue_add (MonoReferenceQueue *queue, MonoObject *obj, void *user_data)",
          "1401: {",
          "1402:  RefQueueEntry *head;",
          "1403:  RefQueueEntry *entry;",
          "1404:  if (queue->should_be_deleted)",
          "1405:   return FALSE;",
          "1407:  entry = g_new0 (RefQueueEntry, 1);",
          "1408:  entry->user_data = user_data;",
          "1409:  mono_gc_weak_link_add (&entry->dis_link, obj, TRUE);",
          "1410:  ref_list_push (&queue->queue, entry);",
          "1411:  return TRUE;",
          "1412: }",
          "1424: void",
          "1425: mono_gc_reference_queue_free (MonoReferenceQueue *queue)",
          "1426: {",
          "1427:  queue->should_be_deleted = TRUE;",
          "1428: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
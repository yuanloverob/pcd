{
  "cve_id": "CVE-2017-15127",
  "cve_desc": "A flaw was found in the hugetlb_mcopy_atomic_pte function in mm/hugetlb.c in the Linux kernel before 4.13. A superfluous implicit page unlock for VM_SHARED hugetlbfs mapping could trigger a local denial of service (BUG).",
  "repo": "torvalds/linux",
  "patch_hash": "5af10dfd0afc559bb4b0f7e3e8227a1578333995",
  "patch_info": {
    "commit_hash": "5af10dfd0afc559bb4b0f7e3e8227a1578333995",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/5af10dfd0afc559bb4b0f7e3e8227a1578333995",
    "files": [
      "mm/hugetlb.c"
    ],
    "message": "userfaultfd: hugetlbfs: remove superfluous page unlock in VM_SHARED case\n\nhuge_add_to_page_cache->add_to_page_cache implicitly unlocks the page\nbefore returning in case of errors.\n\nThe error returned was -EEXIST by running UFFDIO_COPY on a non-hole\noffset of a VM_SHARED hugetlbfs mapping.  It was an userland bug that\ntriggered it and the kernel must cope with it returning -EEXIST from\nioctl(UFFDIO_COPY) as expected.\n\n  page dumped because: VM_BUG_ON_PAGE(!PageLocked(page))\n  kernel BUG at mm/filemap.c:964!\n  invalid opcode: 0000 [#1] SMP\n  CPU: 1 PID: 22582 Comm: qemu-system-x86 Not tainted 4.11.11-300.fc26.x86_64 #1\n  RIP: unlock_page+0x4a/0x50\n  Call Trace:\n    hugetlb_mcopy_atomic_pte+0xc0/0x320\n    mcopy_atomic+0x96f/0xbe0\n    userfaultfd_ioctl+0x218/0xe90\n    do_vfs_ioctl+0xa5/0x600\n    SyS_ioctl+0x79/0x90\n    entry_SYSCALL_64_fastpath+0x1a/0xa9\n\nLink: http://lkml.kernel.org/r/20170802165145.22628-2-aarcange@redhat.com\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nTested-by: Maxime Coquelin <maxime.coquelin@redhat.com>\nReviewed-by: Mike Kravetz <mike.kravetz@oracle.com>\nCc: \"Dr. David Alan Gilbert\" <dgilbert@redhat.com>\nCc: Mike Rapoport <rppt@linux.vnet.ibm.com>\nCc: Alexey Perevalov <a.perevalov@samsung.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "mm/hugetlb.c||mm/hugetlb.c"
    ]
  },
  "patch_diff": {
    "mm/hugetlb.c||mm/hugetlb.c": [
      "File: mm/hugetlb.c -> mm/hugetlb.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4062:  return ret;",
      "4063: out_release_unlock:",
      "4064:  spin_unlock(ptl);",
      "4066:  if (vm_shared)",
      "4067:   unlock_page(page);",
      "4068:  put_page(page);",
      "4069:  goto out;",
      "4070: }",
      "",
      "[Removed Lines]",
      "4065: out_release_nounlock:",
      "",
      "[Added Lines]",
      "4067: out_release_nounlock:",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "bbae08e592706dc32e5c7c97827b13c1c178668b",
      "candidate_info": {
        "commit_hash": "bbae08e592706dc32e5c7c97827b13c1c178668b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/bbae08e592706dc32e5c7c97827b13c1c178668b",
        "files": [
          "drivers/net/usb/qmi_wwan.c"
        ],
        "message": "qmi_wwan: fix NULL deref on disconnect\n\nqmi_wwan_disconnect is called twice when disconnecting devices with\nseparate control and data interfaces.  The first invocation will set\nthe interface data to NULL for both interfaces to flag that the\ndisconnect has been handled.  But the matching NULL check was left\nout when qmi_wwan_disconnect was added, resulting in this oops:\n\n  usb 2-1.4: USB disconnect, device number 4\n  qmi_wwan 2-1.4:1.6 wwp0s29u1u4i6: unregister 'qmi_wwan' usb-0000:00:1d.0-1.4, WWAN/QMI device\n  BUG: unable to handle kernel NULL pointer dereference at 00000000000000e0\n  IP: qmi_wwan_disconnect+0x25/0xc0 [qmi_wwan]\n  PGD 0\n  P4D 0\n  Oops: 0000 [#1] SMP\n  Modules linked in: <stripped irrelevant module list>\n  CPU: 2 PID: 33 Comm: kworker/2:1 Tainted: G            E   4.12.3-nr44-normandy-r1500619820+ #1\n  Hardware name: LENOVO 4291LR7/4291LR7, BIOS CBET4000 4.6-810-g50522254fb 07/21/2017\n  Workqueue: usb_hub_wq hub_event [usbcore]\n  task: ffff8c882b716040 task.stack: ffffb8e800d84000\n  RIP: 0010:qmi_wwan_disconnect+0x25/0xc0 [qmi_wwan]\n  RSP: 0018:ffffb8e800d87b38 EFLAGS: 00010246\n  RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000\n  RDX: 0000000000000001 RSI: ffff8c8824f3f1d0 RDI: ffff8c8824ef6400\n  RBP: ffff8c8824ef6400 R08: 0000000000000000 R09: 0000000000000000\n  R10: ffffb8e800d87780 R11: 0000000000000011 R12: ffffffffc07ea0e8\n  R13: ffff8c8824e2e000 R14: ffff8c8824e2e098 R15: 0000000000000000\n  FS:  0000000000000000(0000) GS:ffff8c8835300000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 00000000000000e0 CR3: 0000000229ca5000 CR4: 00000000000406e0\n  Call Trace:\n   ? usb_unbind_interface+0x71/0x270 [usbcore]\n   ? device_release_driver_internal+0x154/0x210\n   ? qmi_wwan_unbind+0x6d/0xc0 [qmi_wwan]\n   ? usbnet_disconnect+0x6c/0xf0 [usbnet]\n   ? qmi_wwan_disconnect+0x87/0xc0 [qmi_wwan]\n   ? usb_unbind_interface+0x71/0x270 [usbcore]\n   ? device_release_driver_internal+0x154/0x210\n\nReported-and-tested-by: Nathaniel Roach <nroach44@gmail.com>\nFixes: c6adf77953bc (\"net: usb: qmi_wwan: add qmap mux protocol support\")\nCc: Daniele Palmas <dnlplm@gmail.com>\nSigned-off-by: Bj\u00f8rn Mork <bjorn@mork.no>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/usb/qmi_wwan.c||drivers/net/usb/qmi_wwan.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/usb/qmi_wwan.c||drivers/net/usb/qmi_wwan.c": [
          "File: drivers/net/usb/qmi_wwan.c -> drivers/net/usb/qmi_wwan.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1341: static void qmi_wwan_disconnect(struct usb_interface *intf)",
          "1342: {",
          "1343:  struct usbnet *dev = usb_get_intfdata(intf);",
          "1345:  struct list_head *iter;",
          "1346:  struct net_device *ldev;",
          "1348:  if (info->flags & QMI_WWAN_FLAG_MUX) {",
          "1349:   if (!rtnl_trylock()) {",
          "1350:    restart_syscall();",
          "",
          "[Removed Lines]",
          "1344:  struct qmi_wwan_state *info = (void *)&dev->data;",
          "",
          "[Added Lines]",
          "1344:  struct qmi_wwan_state *info;",
          "1349:  if (!dev)",
          "1350:   return;",
          "1351:  info = (void *)&dev->data;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "48fb6f4db940e92cfb16cd878cddd59ea6120d06",
      "candidate_info": {
        "commit_hash": "48fb6f4db940e92cfb16cd878cddd59ea6120d06",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/48fb6f4db940e92cfb16cd878cddd59ea6120d06",
        "files": [
          "kernel/futex.c"
        ],
        "message": "futex: Remove unnecessary warning from get_futex_key\n\nCommit 65d8fc777f6d (\"futex: Remove requirement for lock_page() in\nget_futex_key()\") removed an unnecessary lock_page() with the\nside-effect that page->mapping needed to be treated very carefully.\n\nTwo defensive warnings were added in case any assumption was missed and\nthe first warning assumed a correct application would not alter a\nmapping backing a futex key.  Since merging, it has not triggered for\nany unexpected case but Mark Rutland reported the following bug\ntriggering due to the first warning.\n\n  kernel BUG at kernel/futex.c:679!\n  Internal error: Oops - BUG: 0 [#1] PREEMPT SMP\n  Modules linked in:\n  CPU: 0 PID: 3695 Comm: syz-executor1 Not tainted 4.13.0-rc3-00020-g307fec773ba3 #3\n  Hardware name: linux,dummy-virt (DT)\n  task: ffff80001e271780 task.stack: ffff000010908000\n  PC is at get_futex_key+0x6a4/0xcf0 kernel/futex.c:679\n  LR is at get_futex_key+0x6a4/0xcf0 kernel/futex.c:679\n  pc : [<ffff00000821ac14>] lr : [<ffff00000821ac14>] pstate: 80000145\n\nThe fact that it's a bug instead of a warning was due to an unrelated\narm64 problem, but the warning itself triggered because the underlying\nmapping changed.\n\nThis is an application issue but from a kernel perspective it's a\nrecoverable situation and the warning is unnecessary so this patch\nremoves the warning.  The warning may potentially be triggered with the\nfollowing test program from Mark although it may be necessary to adjust\nNR_FUTEX_THREADS to be a value smaller than the number of CPUs in the\nsystem.\n\n    #include <linux/futex.h>\n    #include <pthread.h>\n    #include <stdio.h>\n    #include <stdlib.h>\n    #include <sys/mman.h>\n    #include <sys/syscall.h>\n    #include <sys/time.h>\n    #include <unistd.h>\n\n    #define NR_FUTEX_THREADS 16\n    pthread_t threads[NR_FUTEX_THREADS];\n\n    void *mem;\n\n    #define MEM_PROT  (PROT_READ | PROT_WRITE)\n    #define MEM_SIZE  65536\n\n    static int futex_wrapper(int *uaddr, int op, int val,\n                             const struct timespec *timeout,\n                             int *uaddr2, int val3)\n    {\n        syscall(SYS_futex, uaddr, op, val, timeout, uaddr2, val3);\n    }\n\n    void *poll_futex(void *unused)\n    {\n        for (;;) {\n            futex_wrapper(mem, FUTEX_CMP_REQUEUE_PI, 1, NULL, mem + 4, 1);\n        }\n    }\n\n    int main(int argc, char *argv[])\n    {\n        int i;\n\n        mem = mmap(NULL, MEM_SIZE, MEM_PROT,\n               MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n\n        printf(\"Mapping @ %p\\n\", mem);\n\n        printf(\"Creating futex threads...\\n\");\n\n        for (i = 0; i < NR_FUTEX_THREADS; i++)\n            pthread_create(&threads[i], NULL, poll_futex, NULL);\n\n        printf(\"Flipping mapping...\\n\");\n        for (;;) {\n            mmap(mem, MEM_SIZE, MEM_PROT,\n                 MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n        }\n\n        return 0;\n    }\n\nReported-and-tested-by: Mark Rutland <mark.rutland@arm.com>\nSigned-off-by: Mel Gorman <mgorman@suse.de>\nAcked-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: stable@vger.kernel.org # 4.7+\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "kernel/futex.c||kernel/futex.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "kernel/futex.c||kernel/futex.c": [
          "File: kernel/futex.c -> kernel/futex.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "680:    rcu_read_unlock();",
          "681:    put_page(page);",
          "",
          "[Removed Lines]",
          "679:   if (WARN_ON_ONCE(!atomic_inc_not_zero(&inode->i_count))) {",
          "",
          "[Added Lines]",
          "680:   if (!atomic_inc_not_zero(&inode->i_count)) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0fa375e6bc9023211eead30a6a79963c45a563da",
      "candidate_info": {
        "commit_hash": "0fa375e6bc9023211eead30a6a79963c45a563da",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0fa375e6bc9023211eead30a6a79963c45a563da",
        "files": [
          "drivers/gpu/drm/rockchip/rockchip_drm_drv.c"
        ],
        "message": "drm/rockchip: Fix suspend crash when drm is not bound\n\nCurrently we are allocating drm_device in rockchip_drm_bind, so if the\nsuspend/resume code access it when drm is not bound, we would hit this\ncrash:\n\n[  253.402836] Unable to handle kernel NULL pointer dereference at virtual address 00000028\n[  253.402837] pgd = ffffffc06c9b0000\n[  253.402841] [00000028] *pgd=0000000000000000, *pud=0000000000000000\n[  253.402844] Internal error: Oops: 96000005 [#1] PREEMPT SMP\n[  253.402859] Modules linked in: btusb btrtl btbcm btintel bluetooth ath10k_pci ath10k_core ar10k_ath ar10k_mac80211 cfg80211 ip6table_filter asix usbnet mii\n[  253.402864] CPU: 4 PID: 1331 Comm: cat Not tainted 4.4.70 #15\n[  253.402865] Hardware name: Google Scarlet (DT)\n[  253.402867] task: ffffffc076c0ce00 ti: ffffffc06c2c8000 task.ti: ffffffc06c2c8000\n[  253.402871] PC is at rockchip_drm_sys_suspend+0x20/0x5c\n\nAdd sanity checks to prevent that.\n\nReported-by: Brian Norris <briannorris@chromium.com>\nSigned-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>\nSigned-off-by: Sean Paul <seanpaul@chromium.org>\nLink: https://patchwork.kernel.org/patch/9890297/",
        "before_after_code_files": [
          "drivers/gpu/drm/rockchip/rockchip_drm_drv.c||drivers/gpu/drm/rockchip/rockchip_drm_drv.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpu/drm/rockchip/rockchip_drm_drv.c||drivers/gpu/drm/rockchip/rockchip_drm_drv.c": [
          "File: drivers/gpu/drm/rockchip/rockchip_drm_drv.c -> drivers/gpu/drm/rockchip/rockchip_drm_drv.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "275: static int rockchip_drm_sys_suspend(struct device *dev)",
          "276: {",
          "277:  struct drm_device *drm = dev_get_drvdata(dev);",
          "280:  drm_kms_helper_poll_disable(drm);",
          "281:  rockchip_drm_fb_suspend(drm);",
          "283:  priv->state = drm_atomic_helper_suspend(drm);",
          "284:  if (IS_ERR(priv->state)) {",
          "285:   rockchip_drm_fb_resume(drm);",
          "",
          "[Removed Lines]",
          "278:  struct rockchip_drm_private *priv = drm->dev_private;",
          "",
          "[Added Lines]",
          "278:  struct rockchip_drm_private *priv;",
          "280:  if (!drm)",
          "281:   return 0;",
          "286:  priv = drm->dev_private;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "293: static int rockchip_drm_sys_resume(struct device *dev)",
          "294: {",
          "295:  struct drm_device *drm = dev_get_drvdata(dev);",
          "298:  drm_atomic_helper_resume(drm, priv->state);",
          "299:  rockchip_drm_fb_resume(drm);",
          "300:  drm_kms_helper_poll_enable(drm);",
          "",
          "[Removed Lines]",
          "296:  struct rockchip_drm_private *priv = drm->dev_private;",
          "",
          "[Added Lines]",
          "300:  struct rockchip_drm_private *priv;",
          "302:  if (!drm)",
          "303:   return 0;",
          "305:  priv = drm->dev_private;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3df3ba2d4dc12be2788f9d6ec6943ba3eccb7add",
      "candidate_info": {
        "commit_hash": "3df3ba2d4dc12be2788f9d6ec6943ba3eccb7add",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3df3ba2d4dc12be2788f9d6ec6943ba3eccb7add",
        "files": [
          "drivers/net/usb/qmi_wwan.c"
        ],
        "message": "qmi_wwan: fix NULL deref on disconnect\n\nqmi_wwan_disconnect is called twice when disconnecting devices with\nseparate control and data interfaces.  The first invocation will set\nthe interface data to NULL for both interfaces to flag that the\ndisconnect has been handled.  But the matching NULL check was left\nout when qmi_wwan_disconnect was added, resulting in this oops:\n\n  usb 2-1.4: USB disconnect, device number 4\n  qmi_wwan 2-1.4:1.6 wwp0s29u1u4i6: unregister 'qmi_wwan' usb-0000:00:1d.0-1.4, WWAN/QMI device\n  BUG: unable to handle kernel NULL pointer dereference at 00000000000000e0\n  IP: qmi_wwan_disconnect+0x25/0xc0 [qmi_wwan]\n  PGD 0\n  P4D 0\n  Oops: 0000 [#1] SMP\n  Modules linked in: <stripped irrelevant module list>\n  CPU: 2 PID: 33 Comm: kworker/2:1 Tainted: G            E   4.12.3-nr44-normandy-r1500619820+ #1\n  Hardware name: LENOVO 4291LR7/4291LR7, BIOS CBET4000 4.6-810-g50522254fb 07/21/2017\n  Workqueue: usb_hub_wq hub_event [usbcore]\n  task: ffff8c882b716040 task.stack: ffffb8e800d84000\n  RIP: 0010:qmi_wwan_disconnect+0x25/0xc0 [qmi_wwan]\n  RSP: 0018:ffffb8e800d87b38 EFLAGS: 00010246\n  RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000\n  RDX: 0000000000000001 RSI: ffff8c8824f3f1d0 RDI: ffff8c8824ef6400\n  RBP: ffff8c8824ef6400 R08: 0000000000000000 R09: 0000000000000000\n  R10: ffffb8e800d87780 R11: 0000000000000011 R12: ffffffffc07ea0e8\n  R13: ffff8c8824e2e000 R14: ffff8c8824e2e098 R15: 0000000000000000\n  FS:  0000000000000000(0000) GS:ffff8c8835300000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 00000000000000e0 CR3: 0000000229ca5000 CR4: 00000000000406e0\n  Call Trace:\n   ? usb_unbind_interface+0x71/0x270 [usbcore]\n   ? device_release_driver_internal+0x154/0x210\n   ? qmi_wwan_unbind+0x6d/0xc0 [qmi_wwan]\n   ? usbnet_disconnect+0x6c/0xf0 [usbnet]\n   ? qmi_wwan_disconnect+0x87/0xc0 [qmi_wwan]\n   ? usb_unbind_interface+0x71/0x270 [usbcore]\n   ? device_release_driver_internal+0x154/0x210\n\nReported-and-tested-by: Nathaniel Roach <nroach44@gmail.com>\nFixes: c6adf77953bc (\"net: usb: qmi_wwan: add qmap mux protocol support\")\nCc: Daniele Palmas <dnlplm@gmail.com>\nSigned-off-by: Bj\u00f8rn Mork <bjorn@mork.no>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/usb/qmi_wwan.c||drivers/net/usb/qmi_wwan.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/usb/qmi_wwan.c||drivers/net/usb/qmi_wwan.c": [
          "File: drivers/net/usb/qmi_wwan.c -> drivers/net/usb/qmi_wwan.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1340: static void qmi_wwan_disconnect(struct usb_interface *intf)",
          "1341: {",
          "1342:  struct usbnet *dev = usb_get_intfdata(intf);",
          "1344:  struct list_head *iter;",
          "1345:  struct net_device *ldev;",
          "1347:  if (info->flags & QMI_WWAN_FLAG_MUX) {",
          "1348:   if (!rtnl_trylock()) {",
          "1349:    restart_syscall();",
          "",
          "[Removed Lines]",
          "1343:  struct qmi_wwan_state *info = (void *)&dev->data;",
          "",
          "[Added Lines]",
          "1343:  struct qmi_wwan_state *info;",
          "1348:  if (!dev)",
          "1349:   return;",
          "1350:  info = (void *)&dev->data;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1cd65d17612e8b64989f7af20213d4bb7a7f4d91",
      "candidate_info": {
        "commit_hash": "1cd65d17612e8b64989f7af20213d4bb7a7f4d91",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1cd65d17612e8b64989f7af20213d4bb7a7f4d91",
        "files": [
          "drivers/thunderbolt/eeprom.c"
        ],
        "message": "thunderbolt: Do not enumerate more ports from DROM than the controller has\n\nSome Alpine Ridge LP DROMs (there might be others) erroneusly list more\nports than the controller actually has. Most probably because DROM of\nthe full Dual/Single port Thunderbolt controller was reused for LP\nversion. The current DROM parser does not check the upper bound thus it\nleads to crash when sw->ports[] is accessed over bounds:\n\n BUG: unable to handle kernel NULL pointer dereference at 00000000000002ec\n IP: tb_drom_read+0x383/0x890 [thunderbolt]\n PGD 0\n P4D 0\n Oops: 0000 [#1] SMP\n CPU: 3 PID: 12248 Comm: systemd-udevd Not tainted 4.13.0-rc1-next-20170719 #1\n Hardware name: LENOVO 20HF000YGE/20HF000YGE, BIOS N1WET32W (1.11 ) 05/23/2017\n task: ffff8a293e4bcd80 task.stack: ffffa698027a8000\n RIP: 0010:tb_drom_read+0x383/0x890 [thunderbolt]\n RSP: 0018:ffffa698027ab990 EFLAGS: 00010246\n RAX: 0000000000000000 RBX: ffff8a2940af7800 RCX: 0000000000000000\n RDX: ffff8a2940ebb400 RSI: 0000000000000000 RDI: ffffa698027ab9a0\n RBP: ffffa698027ab9d0 R08: 0000000000000001 R09: 0000000000000002\n R10: ffff8a2940ebb5b0 R11: 0000000000000000 R12: ffff8a293bfa968c\n R13: 000000000000002c R14: 0000000000000056 R15: 0000000000000056\n FS:  00007f0a945a38c0(0000) GS:ffff8a2961580000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 00000000000002ec CR3: 000000043e785000 CR4: 00000000003606e0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n Call Trace:\n  tb_switch_add+0x9d/0x730 [thunderbolt]\n  ? tb_switch_alloc+0x3cd/0x4d0 [thunderbolt]\n  icm_start+0x5a/0xa0 [thunderbolt]\n  tb_domain_add+0xc3/0xf0 [thunderbolt]\n  nhi_probe+0x19e/0x310 [thunderbolt]\n  local_pci_probe+0x42/0xa0\n  pci_device_probe+0x18d/0x1a0\n  driver_probe_device+0x2ff/0x450\n  __driver_attach+0xa4/0xe0\n  ? driver_probe_device+0x450/0x450\n  bus_for_each_dev+0x6e/0xb0\n  driver_attach+0x1e/0x20\n  bus_add_driver+0x1d0/0x270\n  ? 0xffffffffc0bbb000\n  driver_register+0x60/0xe0\n  ? 0xffffffffc0bbb000\n  __pci_register_driver+0x4c/0x50\n  nhi_init+0x28/0x1000 [thunderbolt]\n  do_one_initcall+0x50/0x190\n  ? __vunmap+0x81/0xb0\n  ? _cond_resched+0x1a/0x50\n  ? kmem_cache_alloc_trace+0x15f/0x1c0\n  ? do_init_module+0x27/0x1e9\n  do_init_module+0x5f/0x1e9\n  load_module+0x24e7/0x2a60\n  ? vfs_read+0x115/0x130\n  SYSC_finit_module+0xfc/0x120\n  ? SYSC_finit_module+0xfc/0x120\n  SyS_finit_module+0xe/0x10\n  do_syscall_64+0x67/0x170\n  entry_SYSCALL64_slow_path+0x25/0x25\n\nFix this by making sure we only enumerate DROM port entries the hardware\nactually has.\n\nReported-by: Christian Kellner <ckellner@redhat.com>\nSigned-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>\nReviewed-by: Lukas Wunner <lukas@wunner.de>\nTested-by: Christian Kellner <ckellner@redhat.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "before_after_code_files": [
          "drivers/thunderbolt/eeprom.c||drivers/thunderbolt/eeprom.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/thunderbolt/eeprom.c||drivers/thunderbolt/eeprom.c": [
          "File: drivers/thunderbolt/eeprom.c -> drivers/thunderbolt/eeprom.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "333:  int res;",
          "334:  enum tb_port_type type;",
          "336:  port = &sw->ports[header->index];",
          "337:  port->disabled = header->port_disabled;",
          "338:  if (port->disabled)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "340:  if (header->index > sw->config.max_port_number) {",
          "341:   dev_info_once(&sw->dev, \"ignoring unnecessary extra entries in DROM\\n\");",
          "342:   return 0;",
          "343:  }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
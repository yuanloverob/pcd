{
  "cve_id": "CVE-2014-0143",
  "cve_desc": "Multiple integer overflows in the block drivers in QEMU, possibly before 2.0.0, allow local users to cause a denial of service (crash) via a crafted catalog size in (1) the parallels_open function in block/parallels.c or (2) bochs_open function in bochs.c, a large L1 table in the (3) qcow2_snapshot_load_tmp in qcow2-snapshot.c or (4) qcow2_grow_l1_table function in qcow2-cluster.c, (5) a large request in the bdrv_check_byte_request function in block.c and other block drivers, (6) crafted cluster indexes in the get_refcount function in qcow2-refcount.c, or (7) a large number of blocks in the cloop_open function in cloop.c, which trigger buffer overflows, memory corruption, large memory allocations and out-of-bounds read and writes.",
  "repo": "qemu/qemu",
  "patch_hash": "509a41bab5306181044b5fff02eadf96d9c8676a",
  "patch_info": {
    "commit_hash": "509a41bab5306181044b5fff02eadf96d9c8676a",
    "repo": "qemu/qemu",
    "commit_url": "https://github.com/qemu/qemu/commit/509a41bab5306181044b5fff02eadf96d9c8676a",
    "files": [
      "block/cloop.c",
      "tests/qemu-iotests/075",
      "tests/qemu-iotests/075.out"
    ],
    "message": "block/cloop: prevent offsets_size integer overflow (CVE-2014-0143)\n\nThe following integer overflow in offsets_size can lead to out-of-bounds\nmemory stores when n_blocks has a huge value:\n\n    uint32_t n_blocks, offsets_size;\n    [...]\n    ret = bdrv_pread(bs->file, 128 + 4, &s->n_blocks, 4);\n    [...]\n    s->n_blocks = be32_to_cpu(s->n_blocks);\n\n    /* read offsets */\n    offsets_size = s->n_blocks * sizeof(uint64_t);\n    s->offsets = g_malloc(offsets_size);\n\n    [...]\n\n    for(i=0;i<s->n_blocks;i++) {\n        s->offsets[i] = be64_to_cpu(s->offsets[i]);\n\noffsets_size can be smaller than n_blocks due to integer overflow.\nTherefore s->offsets[] is too small when the for loop byteswaps offsets.\n\nThis patch refuses to open files if offsets_size would overflow.\n\nNote that changing the type of offsets_size is not a fix since 32-bit\nhosts still only have 32-bit size_t.\n\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>\nReviewed-by: Max Reitz <mreitz@redhat.com>\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>",
    "before_after_code_files": [
      "block/cloop.c||block/cloop.c"
    ]
  },
  "patch_diff": {
    "block/cloop.c||block/cloop.c": [
      "File: block/cloop.c -> block/cloop.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "99:     s->n_blocks = be32_to_cpu(s->n_blocks);",
      "102:     offsets_size = s->n_blocks * sizeof(uint64_t);",
      "103:     s->offsets = g_malloc(offsets_size);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "102:     if (s->n_blocks > UINT32_MAX / sizeof(uint64_t)) {",
      "104:         error_setg(errp, \"n_blocks %u must be %zu or less\",",
      "105:                    s->n_blocks,",
      "106:                    UINT32_MAX / sizeof(uint64_t));",
      "107:         return -EINVAL;",
      "108:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d723971b5d0c22c5c8bd1b8bdba94bc17cc8f36d",
      "candidate_info": {
        "commit_hash": "d723971b5d0c22c5c8bd1b8bdba94bc17cc8f36d",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/d723971b5d0c22c5c8bd1b8bdba94bc17cc8f36d",
        "files": [
          "block/cloop.c",
          "tests/qemu-iotests/075",
          "tests/qemu-iotests/075.out"
        ],
        "message": "block/cloop: prevent offsets_size integer overflow (CVE-2014-0143)\n\nThe following integer overflow in offsets_size can lead to out-of-bounds\nmemory stores when n_blocks has a huge value:\n\n    uint32_t n_blocks, offsets_size;\n    [...]\n    ret = bdrv_pread(bs->file, 128 + 4, &s->n_blocks, 4);\n    [...]\n    s->n_blocks = be32_to_cpu(s->n_blocks);\n\n    /* read offsets */\n    offsets_size = s->n_blocks * sizeof(uint64_t);\n    s->offsets = g_malloc(offsets_size);\n\n    [...]\n\n    for(i=0;i<s->n_blocks;i++) {\n        s->offsets[i] = be64_to_cpu(s->offsets[i]);\n\noffsets_size can be smaller than n_blocks due to integer overflow.\nTherefore s->offsets[] is too small when the for loop byteswaps offsets.\n\nThis patch refuses to open files if offsets_size would overflow.\n\nNote that changing the type of offsets_size is not a fix since 32-bit\nhosts still only have 32-bit size_t.\n\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>\nReviewed-by: Max Reitz <mreitz@redhat.com>\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>\n(cherry picked from commit 509a41bab5306181044b5fff02eadf96d9c8676a)\nSigned-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>",
        "before_after_code_files": [
          "block/cloop.c||block/cloop.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "block/cloop.c||block/cloop.c"
          ],
          "candidate": [
            "block/cloop.c||block/cloop.c"
          ]
        }
      },
      "candidate_diff": {
        "block/cloop.c||block/cloop.c": [
          "File: block/cloop.c -> block/cloop.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "99:     s->n_blocks = be32_to_cpu(s->n_blocks);",
          "102:     offsets_size = s->n_blocks * sizeof(uint64_t);",
          "103:     s->offsets = g_malloc(offsets_size);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "102:     if (s->n_blocks > UINT32_MAX / sizeof(uint64_t)) {",
          "104:         error_setg(errp, \"n_blocks %u must be %zu or less\",",
          "105:                    s->n_blocks,",
          "106:                    UINT32_MAX / sizeof(uint64_t));",
          "107:         return -EINVAL;",
          "108:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "370e681629da587af7592a7b83ebc7ec4955461e",
      "candidate_info": {
        "commit_hash": "370e681629da587af7592a7b83ebc7ec4955461e",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/370e681629da587af7592a7b83ebc7ec4955461e",
        "files": [
          "block/cloop.c"
        ],
        "message": "block/cloop: use PRIu32 format specifier for uint32_t\n\nPRIu32 is the format string specifier for uint32_t, let's use it.\nVariables ->block_size, ->n_blocks, and i are all uint32_t.\n\nSuggested-by: Max Reitz <mreitz@redhat.com>\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>",
        "before_after_code_files": [
          "block/cloop.c||block/cloop.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "block/cloop.c||block/cloop.c"
          ],
          "candidate": [
            "block/cloop.c||block/cloop.c"
          ]
        }
      },
      "candidate_diff": {
        "block/cloop.c||block/cloop.c": [
          "File: block/cloop.c -> block/cloop.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "72:     }",
          "73:     s->block_size = be32_to_cpu(s->block_size);",
          "74:     if (s->block_size % 512) {",
          "76:                    s->block_size);",
          "77:         return -EINVAL;",
          "78:     }",
          "",
          "[Removed Lines]",
          "75:         error_setg(errp, \"block_size %u must be a multiple of 512\",",
          "",
          "[Added Lines]",
          "75:         error_setg(errp, \"block_size %\" PRIu32 \" must be a multiple of 512\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "88:     if (s->block_size > MAX_BLOCK_SIZE) {",
          "90:                    s->block_size,",
          "91:                    MAX_BLOCK_SIZE / (1024 * 1024));",
          "92:         return -EINVAL;",
          "",
          "[Removed Lines]",
          "89:         error_setg(errp, \"block_size %u must be %u MB or less\",",
          "",
          "[Added Lines]",
          "89:         error_setg(errp, \"block_size %\" PRIu32 \" must be %u MB or less\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "102:     if (s->n_blocks > (UINT32_MAX - 1) / sizeof(uint64_t)) {",
          "105:                    s->n_blocks,",
          "106:                    (UINT32_MAX - 1) / sizeof(uint64_t));",
          "107:         return -EINVAL;",
          "",
          "[Removed Lines]",
          "104:         error_setg(errp, \"n_blocks %u must be %zu or less\",",
          "",
          "[Added Lines]",
          "104:         error_setg(errp, \"n_blocks %\" PRIu32 \" must be %zu or less\",",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "134:         if (s->offsets[i] < s->offsets[i - 1]) {",
          "135:             error_setg(errp, \"offsets not monotonically increasing at \"",
          "137:             ret = -EINVAL;",
          "138:             goto fail;",
          "139:         }",
          "",
          "[Removed Lines]",
          "136:                        \"index %u, image file is corrupt\", i);",
          "",
          "[Added Lines]",
          "136:                        \"index %\" PRIu32 \", image file is corrupt\", i);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "148:         if (size > 2 * MAX_BLOCK_SIZE) {",
          "151:             ret = -EINVAL;",
          "152:             goto fail;",
          "153:         }",
          "",
          "[Removed Lines]",
          "149:             error_setg(errp, \"invalid compressed block size at index %u, \"",
          "150:                        \"image file is corrupt\", i);",
          "",
          "[Added Lines]",
          "149:             error_setg(errp, \"invalid compressed block size at index %\" PRIu32",
          "150:                        \", image file is corrupt\", i);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "42d43d35d907579179a39c924d169da924786f65",
      "candidate_info": {
        "commit_hash": "42d43d35d907579179a39c924d169da924786f65",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/42d43d35d907579179a39c924d169da924786f65",
        "files": [
          "block/cloop.c",
          "tests/qemu-iotests/075",
          "tests/qemu-iotests/075.out"
        ],
        "message": "block/cloop: fix offsets[] size off-by-one\n\ncloop stores the number of compressed blocks in the n_blocks header\nfield.  The file actually contains n_blocks + 1 offsets, where the extra\noffset is the end-of-file offset.\n\nThe following line in cloop_read_block() results in an out-of-bounds\noffsets[] access:\n\n    uint32_t bytes = s->offsets[block_num + 1] - s->offsets[block_num];\n\nThis patch allocates and loads the extra offset so that\ncloop_read_block() works correctly when the last block is accessed.\n\nNotice that we must free s->offsets[] unconditionally now since there is\nalways an end-of-file offset.\n\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>\nReviewed-by: Max Reitz <mreitz@redhat.com>\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>",
        "before_after_code_files": [
          "block/cloop.c||block/cloop.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "block/cloop.c||block/cloop.c"
          ],
          "candidate": [
            "block/cloop.c||block/cloop.c"
          ]
        }
      },
      "candidate_diff": {
        "block/cloop.c||block/cloop.c": [
          "File: block/cloop.c -> block/cloop.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "99:     s->n_blocks = be32_to_cpu(s->n_blocks);",
          "104:         error_setg(errp, \"n_blocks %u must be %zu or less\",",
          "105:                    s->n_blocks,",
          "107:         return -EINVAL;",
          "108:     }",
          "110:     if (offsets_size > 512 * 1024 * 1024) {",
          "",
          "[Removed Lines]",
          "102:     if (s->n_blocks > UINT32_MAX / sizeof(uint64_t)) {",
          "106:                    UINT32_MAX / sizeof(uint64_t));",
          "109:     offsets_size = s->n_blocks * sizeof(uint64_t);",
          "",
          "[Added Lines]",
          "102:     if (s->n_blocks > (UINT32_MAX - 1) / sizeof(uint64_t)) {",
          "106:                    (UINT32_MAX - 1) / sizeof(uint64_t));",
          "109:     offsets_size = (s->n_blocks + 1) * sizeof(uint64_t);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "123:         goto fail;",
          "124:     }",
          "127:         uint64_t size;",
          "129:         s->offsets[i] = be64_to_cpu(s->offsets[i]);",
          "",
          "[Removed Lines]",
          "126:     for(i=0;i<s->n_blocks;i++) {",
          "",
          "[Added Lines]",
          "126:     for (i = 0; i < s->n_blocks + 1; i++) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "243: static void cloop_close(BlockDriverState *bs)",
          "244: {",
          "245:     BDRVCloopState *s = bs->opaque;",
          "249:     g_free(s->compressed_block);",
          "250:     g_free(s->uncompressed_block);",
          "251:     inflateEnd(&s->zstream);",
          "",
          "[Removed Lines]",
          "246:     if (s->n_blocks > 0) {",
          "247:         g_free(s->offsets);",
          "248:     }",
          "",
          "[Added Lines]",
          "246:     g_free(s->offsets);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-1335",
  "cve_desc": "lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.",
  "repo": "lxc/lxc",
  "patch_hash": "592fd47a6245508b79fe6ac819fe6d3b2c1289be",
  "patch_info": {
    "commit_hash": "592fd47a6245508b79fe6ac819fe6d3b2c1289be",
    "repo": "lxc/lxc",
    "commit_url": "https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be",
    "files": [
      "doc/lxc.container.conf.sgml.in",
      "src/lxc/cgfs.c",
      "src/lxc/cgmanager.c",
      "src/lxc/conf.c",
      "src/lxc/utils.c",
      "src/lxc/utils.h",
      "src/tests/Makefile.am",
      "src/tests/lxc-test-symlink"
    ],
    "message": "CVE-2015-1335: Protect container mounts against symlinks\n\nWhen a container starts up, lxc sets up the container's inital fstree\nby doing a bunch of mounting, guided by the container configuration\nfile.  The container config is owned by the admin or user on the host,\nso we do not try to guard against bad entries.  However, since the\nmount target is in the container, it's possible that the container admin\ncould divert the mount with symbolic links.  This could bypass proper\ncontainer startup (i.e. confinement of a root-owned container by the\nrestrictive apparmor policy, by diverting the required write to\n/proc/self/attr/current), or bypass the (path-based) apparmor policy\nby diverting, say, /proc to /mnt in the container.\n\nTo prevent this,\n\n1. do not allow mounts to paths containing symbolic links\n\n2. do not allow bind mounts from relative paths containing symbolic\nlinks.\n\nDetails:\n\nDefine safe_mount which ensures that the container has not inserted any\nsymbolic links into any mount targets for mounts to be done during\ncontainer setup.\n\nThe host's mount path may contain symbolic links.  As it is under the\ncontrol of the administrator, that's ok.  So safe_mount begins the check\nfor symbolic links after the rootfs->mount, by opening that directory.\n\nIt opens each directory along the path using openat() relative to the\nparent directory using O_NOFOLLOW.  When the target is reached, it\nmounts onto /proc/self/fd/<targetfd>.\n\nUse safe_mount() in mount_entry(), when mounting container proc,\nand when needed.  In particular, safe_mount() need not be used in\nany case where:\n\n1. the mount is done in the container's namespace\n2. the mount is for the container's rootfs\n3. the mount is relative to a tmpfs or proc/sysfs which we have\n   just safe_mount()ed ourselves\n\nSince we were using proc/net as a temporary placeholder for /proc/sys/net\nduring container startup, and proc/net is a symbolic link, use proc/tty\ninstead.\n\nUpdate the lxc.container.conf manpage with details about the new\nrestrictions.\n\nFinally, add a testcase to test some symbolic link possibilities.\n\nReported-by: Roman Fiedler\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>\nAcked-by: St\u00e9phane Graber <stgraber@ubuntu.com>",
    "before_after_code_files": [
      "src/lxc/cgfs.c||src/lxc/cgfs.c",
      "src/lxc/cgmanager.c||src/lxc/cgmanager.c",
      "src/lxc/conf.c||src/lxc/conf.c",
      "src/lxc/utils.c||src/lxc/utils.c",
      "src/lxc/utils.h||src/lxc/utils.h",
      "src/tests/Makefile.am||src/tests/Makefile.am"
    ]
  },
  "patch_diff": {
    "src/lxc/cgfs.c||src/lxc/cgfs.c": [
      "File: src/lxc/cgfs.c -> src/lxc/cgfs.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1363:  if (!path)",
      "1364:   return false;",
      "1365:  snprintf(path, bufsz, \"%s/sys/fs/cgroup\", root);",
      "1367:  if (r < 0) {",
      "1368:   SYSERROR(\"could not mount tmpfs to /sys/fs/cgroup in the container\");",
      "1369:   return false;",
      "",
      "[Removed Lines]",
      "1366:  r = mount(\"cgroup_root\", path, \"tmpfs\", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, \"size=10240k,mode=755\");",
      "",
      "[Added Lines]",
      "1366:  r = safe_mount(\"cgroup_root\", path, \"tmpfs\",",
      "1367:    MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,",
      "1368:    \"size=10240k,mode=755\",",
      "1369:    root);",
      "",
      "---------------"
    ],
    "src/lxc/cgmanager.c||src/lxc/cgmanager.c": [
      "File: src/lxc/cgmanager.c -> src/lxc/cgmanager.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1477:  }",
      "1481:   SYSERROR(\"Failed to mount tmpfs at %s\", cgpath);",
      "1482:   return false;",
      "1483:  }",
      "",
      "[Removed Lines]",
      "1480:  if (mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\")) {",
      "",
      "[Added Lines]",
      "1480:  if (safe_mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\", root)) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1488:   return false;",
      "1489:  }",
      "1492:   SYSERROR(\"Failed to bind mount %s to %s\", dirname, cgpath);",
      "1493:   return false;",
      "1494:  }",
      "",
      "[Removed Lines]",
      "1491:  if (mount(dirname, cgpath, \"none\", MS_BIND, 0)) {",
      "",
      "[Added Lines]",
      "1491:  if (safe_mount(dirname, cgpath, \"none\", MS_BIND, 0, root)) {",
      "",
      "---------------"
    ],
    "src/lxc/conf.c||src/lxc/conf.c": [
      "File: src/lxc/conf.c -> src/lxc/conf.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "771:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },",
      "773:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys\",                                       \"%r/proc/sys\",                  NULL,       MS_BIND,                        NULL },",
      "774:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sys\",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },",
      "776:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sysrq-trigger\",                             \"%r/proc/sysrq-trigger\",        NULL,       MS_BIND,                        NULL },",
      "777:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sysrq-trigger\",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },",
      "778:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },",
      "",
      "[Removed Lines]",
      "772:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys/net\",                                   \"%r/proc/net\",                  NULL,       MS_BIND,                        NULL },",
      "775:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/net\",                                       \"%r/proc/sys/net\",              NULL,       MS_MOVE,                        NULL },",
      "",
      "[Added Lines]",
      "773:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys/net\",                                   \"%r/proc/tty\",                  NULL,       MS_BIND,                        NULL },",
      "776:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/tty\",                                       \"%r/proc/sys/net\",              NULL,       MS_MOVE,                        NULL },",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "815:    }",
      "816:    mflags = add_required_remount_flags(source, destination,",
      "817:      default_mounts[i].flags);",
      "819:    saved_errno = errno;",
      "820:    if (r < 0 && errno == ENOENT) {",
      "821:     INFO(\"Mount source or target for %s on %s doesn't exist. Skipping.\", source, destination);",
      "",
      "[Removed Lines]",
      "818:    r = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);",
      "",
      "[Added Lines]",
      "819:    r = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1167:   return 0;",
      "1168:  }",
      "1171:   SYSERROR(\"Failed mounting tmpfs onto %s\\n\", path);",
      "1172:   return false;",
      "1173:  }",
      "",
      "[Removed Lines]",
      "1170:  if (mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\")) {",
      "",
      "[Added Lines]",
      "1171:  if (safe_mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\",",
      "1172:     rootfs->path ? rootfs->mount : NULL)) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1252:     return -1;",
      "1253:    }",
      "1254:    fclose(pathfile);",
      "1256:     SYSERROR(\"Failed bind mounting device %s from host into container\",",
      "1257:      d->name);",
      "1258:     return -1;",
      "",
      "[Removed Lines]",
      "1255:    if (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {",
      "",
      "[Added Lines]",
      "1257:    if (safe_mount(hostpath, path, 0, MS_BIND, NULL,",
      "1258:       rootfs->path ? rootfs->mount : NULL) != 0) {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1505:   return -1;",
      "1506:  }",
      "1509:   ERROR(\"failed to mount '%s' on '%s'\", console->name, path);",
      "1510:   return -1;",
      "1511:  }",
      "",
      "[Removed Lines]",
      "1508:  if (mount(console->name, path, \"none\", MS_BIND, 0)) {",
      "",
      "[Added Lines]",
      "1511:  if (safe_mount(console->name, path, \"none\", MS_BIND, 0, rootfs->mount)) {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1560:   return 0;",
      "1561:  }",
      "1564:   ERROR(\"failed to mount '%s' on '%s'\", console->name, lxcpath);",
      "1565:   return -1;",
      "1566:  }",
      "",
      "[Removed Lines]",
      "1563:  if (mount(console->name, lxcpath, \"none\", MS_BIND, 0)) {",
      "",
      "[Added Lines]",
      "1566:  if (safe_mount(console->name, lxcpath, \"none\", MS_BIND, 0, rootfs->mount)) {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1711: static int mount_entry(const char *fsname, const char *target,",
      "1712:          const char *fstype, unsigned long mountflags,",
      "1714: {",
      "1715: #ifdef HAVE_STATVFS",
      "1716:  struct statvfs sb;",
      "1717: #endif",
      "1720:   if (optional) {",
      "1721:    INFO(\"failed to mount '%s' on '%s' (optional): %s\", fsname,",
      "1722:         target, strerror(errno));",
      "",
      "[Removed Lines]",
      "1713:          const char *data, int optional)",
      "1719:  if (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {",
      "",
      "[Added Lines]",
      "1716:          const char *data, int optional, const char *rootfs)",
      "1722:  if (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "1763: #endif",
      "1765:   if (mount(fsname, target, fstype,",
      "1767:    if (optional) {",
      "1768:     INFO(\"failed to mount '%s' on '%s' (optional): %s\",",
      "1769:       fsname, target, strerror(errno));",
      "",
      "[Removed Lines]",
      "1766:      mountflags | MS_REMOUNT, data)) {",
      "",
      "[Added Lines]",
      "1769:      mountflags | MS_REMOUNT, data) < 0) {",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "1843: }",
      "1845: static inline int mount_entry_on_generic(struct mntent *mntent,",
      "1847: {",
      "1848:  unsigned long mntflags;",
      "1849:  char *mntdata;",
      "",
      "[Removed Lines]",
      "1846:                  const char* path)",
      "",
      "[Added Lines]",
      "1849:                  const char* path, const char *rootfs)",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "1863:  }",
      "1865:  ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,",
      "1868:  free(mntdata);",
      "",
      "[Removed Lines]",
      "1866:      mntflags, mntdata, optional);",
      "",
      "[Added Lines]",
      "1869:      mntflags, mntdata, optional, rootfs);",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "1873: static inline int mount_entry_on_systemfs(struct mntent *mntent)",
      "1874: {",
      "1876: }",
      "1878: static int mount_entry_on_absolute_rootfs(struct mntent *mntent,",
      "",
      "[Removed Lines]",
      "1875:   return mount_entry_on_generic(mntent, mntent->mnt_dir);",
      "",
      "[Added Lines]",
      "1878:   return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "1919:   return -1;",
      "1920:  }",
      "1923: }",
      "1925: static int mount_entry_on_relative_rootfs(struct mntent *mntent,",
      "",
      "[Removed Lines]",
      "1922:  return mount_entry_on_generic(mntent, path);",
      "",
      "[Added Lines]",
      "1925:  return mount_entry_on_generic(mntent, path, rootfs->mount);",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "1935:   return -1;",
      "1936:  }",
      "1939: }",
      "1941: static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,",
      "",
      "[Removed Lines]",
      "1938:  return mount_entry_on_generic(mntent, path);",
      "",
      "[Added Lines]",
      "1941:  return mount_entry_on_generic(mntent, path, rootfs);",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "3602:   fclose(pathfile);",
      "3603:  }",
      "3606:  if (ret < 0)",
      "3607:   SYSERROR(\"Failed to bind lxc.init.static into container\");",
      "3608:  INFO(\"lxc.init.static bound into container at %s\", path);",
      "",
      "[Removed Lines]",
      "3605:  ret = mount(path, destpath, \"none\", MS_BIND, NULL);",
      "",
      "[Added Lines]",
      "3608:  ret = safe_mount(path, destpath, \"none\", MS_BIND, NULL, conf->rootfs.mount);",
      "",
      "---------------"
    ],
    "src/lxc/utils.c||src/lxc/utils.c": [
      "File: src/lxc/utils.c -> src/lxc/utils.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1404:  return ret;",
      "1405: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1414: static char *get_nextpath(char *path, int *offsetp, int fulllen)",
      "1415: {",
      "1416:  int offset = *offsetp;",
      "1418:  if (offset >= fulllen)",
      "1419:   return NULL;",
      "1421:  while (path[offset] != '\\0' && offset < fulllen)",
      "1422:   offset++;",
      "1423:  while (path[offset] == '\\0' && offset < fulllen)",
      "1424:   offset++;",
      "1427:  return (offset < fulllen) ? &path[offset] : NULL;",
      "1428: }",
      "1434: static bool is_subdir(const char *subdir, const char *dir, size_t len)",
      "1435: {",
      "1436:  size_t subdirlen = strlen(subdir);",
      "1438:  if (subdirlen < len)",
      "1439:   return false;",
      "1440:  if (strncmp(subdir, dir, len) != 0)",
      "1441:   return false;",
      "1442:  if (dir[len-1] == '/')",
      "1443:   return true;",
      "1444:  if (subdir[len] == '/' || subdirlen == len)",
      "1445:   return true;",
      "1446:  return false;",
      "1447: }",
      "1453: static int check_symlink(int fd)",
      "1454: {",
      "1455:  struct stat sb;",
      "1456:  int ret = fstat(fd, &sb);",
      "1457:  if (ret < 0)",
      "1458:   return -ENOENT;",
      "1459:  if (S_ISLNK(sb.st_mode))",
      "1460:   return -ELOOP;",
      "1461:  return 0;",
      "1462: }",
      "1470: static int open_if_safe(int dirfd, const char *nextpath)",
      "1471: {",
      "1472:  int newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);",
      "1473:  if (newfd >= 0) // was not a symlink, all good",
      "1474:   return newfd;",
      "1476:  if (errno == ELOOP)",
      "1477:   return newfd;",
      "1479:  if (errno == EPERM || errno == EACCES) {",
      "1482:   newfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);",
      "1483:   if (newfd >= 0) {",
      "1488:    int ret = check_symlink(newfd);",
      "1489:    if (ret < 0) {",
      "1490:     close(newfd);",
      "1491:     newfd = ret;",
      "1492:    }",
      "1493:   }",
      "1494:  }",
      "1496:  return newfd;",
      "1497: }",
      "1512: static int open_without_symlink(const char *target, const char *prefix_skip)",
      "1513: {",
      "1514:  int curlen = 0, dirfd, fulllen, i;",
      "1515:  char *dup = NULL;",
      "1517:  fulllen = strlen(target);",
      "1520:  if (prefix_skip) {",
      "1521:   curlen = strlen(prefix_skip);",
      "1522:   if (!is_subdir(target, prefix_skip, curlen)) {",
      "1523:    ERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",",
      "1524:     target, prefix_skip);",
      "1525:    return -EINVAL;",
      "1526:   }",
      "1532:   if (curlen)",
      "1533:    curlen--;",
      "1534:  } else {",
      "1535:   prefix_skip = \"/\";",
      "1536:   curlen = 0;",
      "1537:  }",
      "1540:  if ((dup = strdup(target)) == NULL) {",
      "1541:   SYSERROR(\"Out of memory checking for symbolic link\");",
      "1542:   return -ENOMEM;",
      "1543:  }",
      "1544:  for (i = 0; i < fulllen; i++) {",
      "1545:   if (dup[i] == '/')",
      "1546:    dup[i] = '\\0';",
      "1547:  }",
      "1549:  dirfd = open(prefix_skip, O_RDONLY);",
      "1550:  if (dirfd < 0)",
      "1551:   goto out;",
      "1552:  while (1) {",
      "1553:   int newfd, saved_errno;",
      "1554:   char *nextpath;",
      "1556:   if ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)",
      "1557:    goto out;",
      "1558:   newfd = open_if_safe(dirfd, nextpath);",
      "1559:   saved_errno = errno;",
      "1560:   close(dirfd);",
      "1561:   dirfd = newfd;",
      "1562:   if (newfd < 0) {",
      "1563:    errno = saved_errno;",
      "1564:    if (errno == ELOOP)",
      "1565:     SYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);",
      "1566:    else",
      "1567:     SYSERROR(\"Error examining %s in %s\", nextpath, target);",
      "1568:    goto out;",
      "1569:   }",
      "1570:  }",
      "1572: out:",
      "1573:  free(dup);",
      "1574:  return dirfd;",
      "1575: }",
      "1585: int safe_mount(const char *src, const char *dest, const char *fstype,",
      "1586:   unsigned long flags, const void *data, const char *rootfs)",
      "1587: {",
      "1588:  int srcfd = -1, destfd, ret, saved_errno;",
      "1589:  char srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>",
      "1590:  const char *mntsrc = src;",
      "1592:  if (!rootfs)",
      "1593:   rootfs = \"\";",
      "1596:  if (flags & MS_BIND && src && src[0] != '/') {",
      "1597:   INFO(\"this is a relative bind mount\");",
      "1598:   srcfd = open_without_symlink(src, NULL);",
      "1599:   if (srcfd < 0)",
      "1600:    return srcfd;",
      "1601:   ret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);",
      "1602:   if (ret < 0 || ret > 50) {",
      "1603:    close(srcfd);",
      "1604:    ERROR(\"Out of memory\");",
      "1605:    return -EINVAL;",
      "1606:   }",
      "1607:   mntsrc = srcbuf;",
      "1608:  }",
      "1610:  destfd = open_without_symlink(dest, rootfs);",
      "1611:  if (destfd < 0) {",
      "1612:   if (srcfd != -1)",
      "1613:    close(srcfd);",
      "1614:   return destfd;",
      "1615:  }",
      "1617:  ret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);",
      "1618:  if (ret < 0 || ret > 50) {",
      "1619:   if (srcfd != -1)",
      "1620:    close(srcfd);",
      "1621:   close(destfd);",
      "1622:   ERROR(\"Out of memory\");",
      "1623:   return -EINVAL;",
      "1624:  }",
      "1626:  ret = mount(mntsrc, destbuf, fstype, flags, data);",
      "1627:  saved_errno = errno;",
      "1628:  if (srcfd != -1)",
      "1629:   close(srcfd);",
      "1630:  close(destfd);",
      "1631:  if (ret < 0) {",
      "1632:   errno = saved_errno;",
      "1633:   SYSERROR(\"Failed to mount %s onto %s\", src, dest);",
      "1634:   return ret;",
      "1635:  }",
      "1637:  return 0;",
      "1638: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1446:  return 0;",
      "1448: domount:",
      "1450:   return -1;",
      "1451:  INFO(\"Mounted /proc in container for security transition\");",
      "1452:  return 1;",
      "",
      "[Removed Lines]",
      "1449:  if (mount(\"proc\", path, \"proc\", 0, NULL))",
      "",
      "[Added Lines]",
      "1682:  if (safe_mount(\"proc\", path, \"proc\", 0, NULL, rootfs) < 0)",
      "",
      "---------------"
    ],
    "src/lxc/utils.h||src/lxc/utils.h": [
      "File: src/lxc/utils.h -> src/lxc/utils.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "279: int is_dir(const char *path);",
      "280: char *get_template_path(const char *t);",
      "281: int setproctitle(char *title);",
      "282: int mount_proc_if_needed(const char *rootfs);",
      "283: int null_stdfds(void);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "282: int safe_mount(const char *src, const char *dest, const char *fstype,",
      "283:   unsigned long flags, const void *data, const char *rootfs);",
      "",
      "---------------"
    ],
    "src/tests/Makefile.am||src/tests/Makefile.am": [
      "File: src/tests/Makefile.am -> src/tests/Makefile.am",
      "--- Hunk 1 ---",
      "[Context before]",
      "55:  lxc-test-apparmor-mount \\",
      "56:  lxc-test-checkpoint-restore \\",
      "57:  lxc-test-snapdeps \\",
      "58:  lxc-test-ubuntu \\",
      "59:  lxc-test-unpriv \\",
      "60:  lxc-test-usernic",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "58:  lxc-test-symlink \\",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "82:  lxc-test-cloneconfig \\",
      "83:  lxc-test-createconfig \\",
      "84:  lxc-test-snapdeps \\",
      "85:  lxc-test-ubuntu \\",
      "86:  lxc-test-unpriv \\",
      "87:  may_control.c \\",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "86:  lxc-test-symlink \\",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1433c9f9b688005e86c58ecaca5c02ad96554435",
      "candidate_info": {
        "commit_hash": "1433c9f9b688005e86c58ecaca5c02ad96554435",
        "repo": "lxc/lxc",
        "commit_url": "https://github.com/lxc/lxc/commit/1433c9f9b688005e86c58ecaca5c02ad96554435",
        "files": [
          "src/lxc/conf.c"
        ],
        "message": "no rootfs => mounts are always relative to hosts /\n\nAll lxc.mount.entry entries will be relative to the hosts / when a container\ndoes not specify a lxc.rootfs.\n\nSigned-off-by: Christian Brauner <christian.brauner@mailbox.org>",
        "before_after_code_files": [
          "src/lxc/conf.c||src/lxc/conf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lxc/conf.c||src/lxc/conf.c"
          ],
          "candidate": [
            "src/lxc/conf.c||src/lxc/conf.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lxc/conf.c||src/lxc/conf.c": [
          "File: src/lxc/conf.c -> src/lxc/conf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1808: static inline int mount_entry_on_systemfs(struct mntent *mntent)",
          "1809: {",
          "1811: }",
          "1813: static int mount_entry_on_absolute_rootfs(struct mntent *mntent,",
          "",
          "[Removed Lines]",
          "1810:  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL, NULL, NULL);",
          "",
          "[Added Lines]",
          "1810:  char path[MAXPATHLEN];",
          "1811:  int ret;",
          "1815:  if (mntent->mnt_dir[0] != '/')",
          "1816:   ret = snprintf(path, sizeof(path), \"/%s\", mntent->mnt_dir);",
          "1817:  else",
          "1818:   ret = snprintf(path, sizeof(path), \"%s\", mntent->mnt_dir);",
          "1820:  if (ret < 0 || ret >= sizeof(path)) {",
          "1821:   ERROR(\"path name too long\");",
          "1822:   return -1;",
          "1823:  }",
          "1825:  return mount_entry_on_generic(mntent, path, NULL, NULL, NULL);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1870:  ret = snprintf(path, sizeof(path), \"%s/%s\", rootfs->mount, mntent->mnt_dir);",
          "1872:   ERROR(\"path name too long\");",
          "1873:   return -1;",
          "1874:  }",
          "",
          "[Removed Lines]",
          "1871:  if (ret >= sizeof(path)) {",
          "",
          "[Added Lines]",
          "1886:  if (ret < 0 || ret >= sizeof(path)) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "01074e5b34719537cef474c6b81d4f55e6427639",
      "candidate_info": {
        "commit_hash": "01074e5b34719537cef474c6b81d4f55e6427639",
        "repo": "lxc/lxc",
        "commit_url": "https://github.com/lxc/lxc/commit/01074e5b34719537cef474c6b81d4f55e6427639",
        "files": [
          "src/lxc/utils.c"
        ],
        "message": "open_without_symlink: Account when prefix is empty string\n\nIn the current implementation, the open_without_symlink function\nwill default to opening the root mount only if the passed rootfs\nprefix is null. It doesn't account for the case where this prefix\nis passed as an empty string.\n\nProperly handle this second case as well.\n\nSigned-off-by: Bogdan Purcareata <bogdan.purcareata@nxp.com>\nAcked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>",
        "before_after_code_files": [
          "src/lxc/utils.c||src/lxc/utils.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lxc/utils.c||src/lxc/utils.c"
          ],
          "candidate": [
            "src/lxc/utils.c||src/lxc/utils.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lxc/utils.c||src/lxc/utils.c": [
          "File: src/lxc/utils.c -> src/lxc/utils.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1575:  fulllen = strlen(target);",
          "1579:   curlen = strlen(prefix_skip);",
          "1580:   if (!is_subdir(target, prefix_skip, curlen)) {",
          "1581:    ERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",",
          "",
          "[Removed Lines]",
          "1578:  if (prefix_skip) {",
          "",
          "[Added Lines]",
          "1578:  if (prefix_skip && strlen(prefix_skip) > 0) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9cb4d183559d7f0b1008ea077be8e7793a7ba72d",
      "candidate_info": {
        "commit_hash": "9cb4d183559d7f0b1008ea077be8e7793a7ba72d",
        "repo": "lxc/lxc",
        "commit_url": "https://github.com/lxc/lxc/commit/9cb4d183559d7f0b1008ea077be8e7793a7ba72d",
        "files": [
          "src/lxc/conf.c"
        ],
        "message": "fill_autodev: bind-mount if mknod fails (v3)\n\nFirst, rename setup_autodev to fill_autodev, since all it\ndoes is populate it, not fully set it up.\n\nSecondly, if mknod of a device fails, then try bind-mounting\nit from the host rather than failing immediately.\n\nNote that this isn't an urgent patch because the common.userns\nconfiguration hook already specifies bind,create=file mount\nentries for all the devices we would want.\n\nChangelog (v3): ignore if /dev doesn't exist\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>\nAcked-by: St\u00e9phane Graber <stgraber@ubuntu.com>",
        "before_after_code_files": [
          "src/lxc/conf.c||src/lxc/conf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lxc/conf.c||src/lxc/conf.c"
          ],
          "candidate": [
            "src/lxc/conf.c||src/lxc/conf.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lxc/conf.c||src/lxc/conf.c": [
          "File: src/lxc/conf.c -> src/lxc/conf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1155:  { \"console\", S_IFCHR | S_IRUSR | S_IWUSR,        5, 1 },",
          "1156: };",
          "1159: {",
          "1160:  int ret;",
          "1161:  char path[MAXPATHLEN];",
          "",
          "[Removed Lines]",
          "1158: static int setup_autodev(const char *root)",
          "",
          "[Added Lines]",
          "1158: static int fill_autodev(const char *root)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1170:   return -1;",
          "1171:  }",
          "1173:  INFO(\"Populating /dev under %s\", root);",
          "1174:  cmask = umask(S_IXUSR | S_IXGRP | S_IXOTH);",
          "1175:  for (i = 0; i < sizeof(lxc_devs) / sizeof(lxc_devs[0]); i++) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1173:  if (!dir_exists(path))  // ignore, just don't try to fill in",
          "1174:   return 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1179:    return -1;",
          "1180:   ret = mknod(path, d->mode, makedev(d->maj, d->min));",
          "1181:   if (ret && errno != EEXIST) {",
          "1184:   }",
          "1185:  }",
          "1186:  umask(cmask);",
          "",
          "[Removed Lines]",
          "1182:    SYSERROR(\"Error creating %s\", d->name);",
          "1183:    return -1;",
          "",
          "[Added Lines]",
          "1185:    char hostpath[MAXPATHLEN];",
          "1186:    FILE *pathfile;",
          "1190:    ret = snprintf(hostpath, MAXPATHLEN, \"/dev/%s\", d->name);",
          "1191:    if (ret < 0 || ret >= MAXPATHLEN)",
          "1192:     return -1;",
          "1193:    pathfile = fopen(path, \"wb\");",
          "1194:    if (!pathfile) {",
          "1195:     SYSERROR(\"Failed to create device mount target '%s'\", path);",
          "1196:     return -1;",
          "1197:    }",
          "1198:    fclose(pathfile);",
          "1199:    if (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {",
          "1200:     SYSERROR(\"Failed bind mounting device %s from host into container\",",
          "1201:      d->name);",
          "1202:     return -1;",
          "1203:    }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3847:    ERROR(\"failed to run autodev hooks for container '%s'.\", name);",
          "3848:    return -1;",
          "3849:   }",
          "3851:    ERROR(\"failed to populate /dev in the container\");",
          "3852:    return -1;",
          "3853:   }",
          "",
          "[Removed Lines]",
          "3850:   if (setup_autodev(lxc_conf->rootfs.mount)) {",
          "",
          "[Added Lines]",
          "3870:   if (fill_autodev(lxc_conf->rootfs.mount)) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0a2dddd479a815fbbca427c5b5418a303c0b1c1f",
      "candidate_info": {
        "commit_hash": "0a2dddd479a815fbbca427c5b5418a303c0b1c1f",
        "repo": "lxc/lxc",
        "commit_url": "https://github.com/lxc/lxc/commit/0a2dddd479a815fbbca427c5b5418a303c0b1c1f",
        "files": [
          "src/lxc/conf.c"
        ],
        "message": "Make mount_entry_create_*_dirs() more robust\n\nThe mount_entry_create_*_dirs() functions currently assume that the rootfs of\nthe container is actually named \"rootfs\". This has the consequence that\n\n\tdel = strstr(lxcpath, \"/rootfs\");\n\tif (!del) {\n\t\tfree(lxcpath);\n\t\tlxc_free_array((void **)opts, free);\n\t\treturn -1;\n\t}\n\t*del = '\\0';\n\nwill return NULL when the rootfs of a container is not actually named \"rootfs\".\nThis means the we return -1 and do not create the necessary upperdir/workdir\ndirectories required for the overlay/aufs mount to work. Hence, let's not make\nthat assumption. We now pass lxc_path and lxc_name to\nmount_entry_create_*_dirs() and create the path directly. To prevent failure we\nalso have mount_entry_create_*_dirs() check that lxc_name and lxc_path are not\nempty when they are passed in.\n\nSigned-off-by: Christian Brauner <christianvanbrauner@gmail.com>\nAcked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>",
        "before_after_code_files": [
          "src/lxc/conf.c||src/lxc/conf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lxc/conf.c||src/lxc/conf.c"
          ],
          "candidate": [
            "src/lxc/conf.c||src/lxc/conf.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lxc/conf.c||src/lxc/conf.c": [
          "File: src/lxc/conf.c -> src/lxc/conf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1816: }",
          "1818: static int mount_entry_create_overlay_dirs(const struct mntent *mntent,",
          "1820: {",
          "1823:  char *upperdir = NULL;",
          "1824:  char *workdir = NULL;",
          "1825:  char **opts = NULL;",
          "1826:  size_t arrlen = 0;",
          "1827:  size_t dirlen = 0;",
          "1828:  size_t i;",
          "1829:  size_t len = 0;",
          "1830:  size_t rootfslen = 0;",
          "1833:   return -1;",
          "1835:  opts = lxc_string_split(mntent->mnt_opts, ',');",
          "",
          "[Removed Lines]",
          "1819:         const struct lxc_rootfs *rootfs)",
          "1821:  char *del = NULL;",
          "1822:  char *lxcpath = NULL;",
          "1832:  if (!rootfs->path)",
          "",
          "[Added Lines]",
          "1819:         const struct lxc_rootfs *rootfs,",
          "1820:         const char *lxc_name,",
          "1821:         const char *lxc_path)",
          "1823:  char lxcpath[MAXPATHLEN];",
          "1827:  int ret = 0;",
          "1834:  if (!rootfs->path || !lxc_name || !lxc_path)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1845:    workdir = opts[i] + len;",
          "1846:  }",
          "1857:   lxc_free_array((void **)opts, free);",
          "1858:   return -1;",
          "1859:  }",
          "1862:  dirlen = strlen(lxcpath);",
          "1863:  rootfslen = strlen(rootfs->path);",
          "",
          "[Removed Lines]",
          "1848:  lxcpath = strdup(rootfs->path);",
          "1849:  if (!lxcpath) {",
          "1850:   lxc_free_array((void **)opts, free);",
          "1851:   return -1;",
          "1852:  }",
          "1854:  del = strstr(lxcpath, \"/rootfs\");",
          "1855:  if (!del) {",
          "1856:   free(lxcpath);",
          "",
          "[Added Lines]",
          "1850:  ret = snprintf(lxcpath, MAXPATHLEN, \"%s/%s\", lxc_path, lxc_name);",
          "1851:  if (ret < 0 || ret >= MAXPATHLEN) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1877:     WARN(\"Failed to create workdir\");",
          "1878:    }",
          "1881:  lxc_free_array((void **)opts, free);",
          "1882:  return 0;",
          "1883: }",
          "1885: static int mount_entry_create_aufs_dirs(const struct mntent *mntent,",
          "1887: {",
          "1890:  char *scratch = NULL;",
          "1891:  char *tmp = NULL;",
          "1892:  char *upperdir = NULL;",
          "1893:  char **opts = NULL;",
          "1894:  size_t arrlen = 0;",
          "1895:  size_t i;",
          "1896:  size_t len = 0;",
          "1899:   return -1;",
          "1901:  opts = lxc_string_split(mntent->mnt_opts, ',');",
          "",
          "[Removed Lines]",
          "1880:  free(lxcpath);",
          "1886:      const struct lxc_rootfs *rootfs)",
          "1888:  char *del = NULL;",
          "1889:  char *lxcpath = NULL;",
          "1898:  if (!rootfs->path)",
          "",
          "[Added Lines]",
          "1879:      const struct lxc_rootfs *rootfs,",
          "1880:      const char *lxc_name,",
          "1881:      const char *lxc_path)",
          "1883:  char lxcpath[MAXPATHLEN];",
          "1888:  int ret = 0;",
          "1893:  if (!rootfs->path || !lxc_name || !lxc_path)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1919:   return -1;",
          "1920:  }",
          "1931:   lxc_free_array((void **)opts, free);",
          "1932:   return -1;",
          "1933:  }",
          "",
          "[Removed Lines]",
          "1922:  lxcpath = strdup(rootfs->path);",
          "1923:  if (!lxcpath) {",
          "1924:   lxc_free_array((void **)opts, free);",
          "1925:   return -1;",
          "1926:  }",
          "1928:  del = strstr(lxcpath, \"/rootfs\");",
          "1929:  if (!del) {",
          "1930:   free(lxcpath);",
          "",
          "[Added Lines]",
          "1917:  ret = snprintf(lxcpath, MAXPATHLEN, \"%s/%s\", lxc_path, lxc_name);",
          "1918:  if (ret < 0 || ret >= MAXPATHLEN) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1940:    WARN(\"Failed to create upperdir\");",
          "1941:   }",
          "1944:  lxc_free_array((void **)opts, free);",
          "1945:  return 0;",
          "1946: }",
          "1948: static int mount_entry_create_dir_file(const struct mntent *mntent,",
          "1950: {",
          "1951:  char *pathdirname = NULL;",
          "1952:  int ret = 0;",
          "1953:  FILE *pathfile = NULL;",
          "1955:  if (strncmp(mntent->mnt_type, \"overlay\", 7) == 0) {",
          "1957:    return -1;",
          "1958:  } else if (strncmp(mntent->mnt_type, \"aufs\", 4) == 0) {",
          "1960:    return -1;",
          "1961:  }",
          "",
          "[Removed Lines]",
          "1943:  free(lxcpath);",
          "1949:            const char* path, const struct lxc_rootfs *rootfs)",
          "1956:   if (mount_entry_create_overlay_dirs(mntent, rootfs) < 0)",
          "1959:   if (mount_entry_create_aufs_dirs(mntent, rootfs) < 0)",
          "",
          "[Added Lines]",
          "1936:            const char* path, const struct lxc_rootfs *rootfs,",
          "1937:            const char *lxc_name, const char *lxc_path)",
          "1944:   if (mount_entry_create_overlay_dirs(mntent, rootfs, lxc_name, lxc_path) < 0)",
          "1947:   if (mount_entry_create_aufs_dirs(mntent, rootfs, lxc_name, lxc_path) < 0)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1986: }",
          "1988: static inline int mount_entry_on_generic(struct mntent *mntent,",
          "1990: {",
          "1991:  unsigned long mntflags;",
          "1992:  char *mntdata;",
          "1993:  int ret;",
          "1994:  bool optional = hasmntopt(mntent, \"optional\") != NULL;",
          "1998:  if (ret < 0)",
          "1999:   return optional ? 0 : -1;",
          "",
          "[Removed Lines]",
          "1989:                  const char* path, const struct lxc_rootfs *rootfs)",
          "1996:  ret = mount_entry_create_dir_file(mntent, path, rootfs);",
          "",
          "[Added Lines]",
          "1977:                  const char* path, const struct lxc_rootfs *rootfs,",
          "1978:    const char *lxc_name, const char *lxc_path)",
          "1985:  ret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2016: static inline int mount_entry_on_systemfs(struct mntent *mntent)",
          "2017: {",
          "2019: }",
          "2021: static int mount_entry_on_absolute_rootfs(struct mntent *mntent,",
          "2022:        const struct lxc_rootfs *rootfs,",
          "2024: {",
          "2025:  char *aux;",
          "2026:  char path[MAXPATHLEN];",
          "",
          "[Removed Lines]",
          "2018:   return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);",
          "2023:        const char *lxc_name)",
          "",
          "[Added Lines]",
          "2007:   return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL, NULL, NULL);",
          "2012:        const char *lxc_name,",
          "2013:        const char *lxc_path)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2062:   return -1;",
          "2063:  }",
          "2066: }",
          "2068: static int mount_entry_on_relative_rootfs(struct mntent *mntent,",
          "2070: {",
          "2071:  char path[MAXPATHLEN];",
          "2072:  int ret;",
          "",
          "[Removed Lines]",
          "2065:  return mount_entry_on_generic(mntent, path, rootfs);",
          "2069:        const struct lxc_rootfs *rootfs)",
          "",
          "[Added Lines]",
          "2055:  return mount_entry_on_generic(mntent, path, rootfs, lxc_name, lxc_path);",
          "2059:        const struct lxc_rootfs *rootfs,",
          "2060:        const char *lxc_name,",
          "2061:        const char *lxc_path)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2078:   return -1;",
          "2079:  }",
          "2082: }",
          "2084: static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,",
          "2086: {",
          "2087:  struct mntent mntent;",
          "2088:  char buf[4096];",
          "",
          "[Removed Lines]",
          "2081:  return mount_entry_on_generic(mntent, path, rootfs);",
          "2085:  const char *lxc_name)",
          "",
          "[Added Lines]",
          "2073:  return mount_entry_on_generic(mntent, path, rootfs, lxc_name, lxc_path);",
          "2077:  const char *lxc_name, const char *lxc_path)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2100:   if (mntent.mnt_dir[0] != '/') {",
          "2103:     goto out;",
          "2104:    continue;",
          "2105:   }",
          "2108:    goto out;",
          "2109:  }",
          "",
          "[Removed Lines]",
          "2101:    if (mount_entry_on_relative_rootfs(&mntent,",
          "2102:           rootfs))",
          "2107:   if (mount_entry_on_absolute_rootfs(&mntent, rootfs, lxc_name))",
          "",
          "[Added Lines]",
          "2093:    if (mount_entry_on_relative_rootfs(&mntent, rootfs, lxc_name, lxc_path))",
          "2098:   if (mount_entry_on_absolute_rootfs(&mntent, rootfs, lxc_name, lxc_path))",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2116: }",
          "2118: static int setup_mount(const struct lxc_rootfs *rootfs, const char *fstab,",
          "2120: {",
          "2121:  FILE *file;",
          "2122:  int ret;",
          "",
          "[Removed Lines]",
          "2119:  const char *lxc_name)",
          "",
          "[Added Lines]",
          "2110:  const char *lxc_name, const char *lxc_path)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2130:   return -1;",
          "2131:  }",
          "2135:  endmntent(file);",
          "2136:  return ret;",
          "",
          "[Removed Lines]",
          "2133:  ret = mount_file_entries(rootfs, file, lxc_name);",
          "",
          "[Added Lines]",
          "2124:  ret = mount_file_entries(rootfs, file, lxc_name, lxc_path);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2158: }",
          "2160: static int setup_mount_entries(const struct lxc_rootfs *rootfs, struct lxc_list *mount,",
          "2162: {",
          "2163:  FILE *file;",
          "2164:  int ret;",
          "",
          "[Removed Lines]",
          "2161:  const char *lxc_name)",
          "",
          "[Added Lines]",
          "2152:  const char *lxc_name, const char *lxc_path)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2167:  if (!file)",
          "2168:   return -1;",
          "2172:  fclose(file);",
          "2173:  return ret;",
          "",
          "[Removed Lines]",
          "2170:  ret = mount_file_entries(rootfs, file, lxc_name);",
          "",
          "[Added Lines]",
          "2161:  ret = mount_file_entries(rootfs, file, lxc_name, lxc_path);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "3891:   return -1;",
          "3892:  }",
          "3895:   ERROR(\"failed to setup the mounts for '%s'\", name);",
          "3896:   return -1;",
          "3897:  }",
          "3900:   ERROR(\"failed to setup the mount entries for '%s'\", name);",
          "3901:   return -1;",
          "3902:  }",
          "",
          "[Removed Lines]",
          "3894:  if (setup_mount(&lxc_conf->rootfs, lxc_conf->fstab, name)) {",
          "3899:  if (!lxc_list_empty(&lxc_conf->mount_list) && setup_mount_entries(&lxc_conf->rootfs, &lxc_conf->mount_list, name)) {",
          "",
          "[Added Lines]",
          "3885:  if (setup_mount(&lxc_conf->rootfs, lxc_conf->fstab, name, lxcpath)) {",
          "3890:  if (!lxc_list_empty(&lxc_conf->mount_list) && setup_mount_entries(&lxc_conf->rootfs, &lxc_conf->mount_list, name, lxcpath)) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ae7a770e0a73aa3c413d6b6c10a65eb2c7897c26",
      "candidate_info": {
        "commit_hash": "ae7a770e0a73aa3c413d6b6c10a65eb2c7897c26",
        "repo": "lxc/lxc",
        "commit_url": "https://github.com/lxc/lxc/commit/ae7a770e0a73aa3c413d6b6c10a65eb2c7897c26",
        "files": [
          "src/lxc/conf.c"
        ],
        "message": "Add flag in mount_entry to skip NODEV in case of a persistent dev entry\n\nSigned-off-by: Rodrigo Vaz <rodrigo@heroku.com>",
        "before_after_code_files": [
          "src/lxc/conf.c||src/lxc/conf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lxc/conf.c||src/lxc/conf.c"
          ],
          "candidate": [
            "src/lxc/conf.c||src/lxc/conf.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lxc/conf.c||src/lxc/conf.c": [
          "File: src/lxc/conf.c -> src/lxc/conf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1635: static int mount_entry(const char *fsname, const char *target,",
          "1636:          const char *fstype, unsigned long mountflags,",
          "1638: {",
          "1639: #ifdef HAVE_STATVFS",
          "1640:  struct statvfs sb;",
          "",
          "[Removed Lines]",
          "1637:          const char *data, int optional, const char *rootfs)",
          "",
          "[Added Lines]",
          "1637:          const char *data, int optional, int dev, const char *rootfs)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1663:    unsigned long required_flags = rqd_flags;",
          "1664:    if (sb.f_flag & MS_NOSUID)",
          "1665:     required_flags |= MS_NOSUID;",
          "1667:     required_flags |= MS_NODEV;",
          "1668:    if (sb.f_flag & MS_RDONLY)",
          "1669:     required_flags |= MS_RDONLY;",
          "",
          "[Removed Lines]",
          "1666:    if (sb.f_flag & MS_NODEV)",
          "",
          "[Added Lines]",
          "1666:    if (sb.f_flag & MS_NODEV && !dev)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1785:  char *mntdata;",
          "1786:  int ret;",
          "1787:  bool optional = hasmntopt(mntent, \"optional\") != NULL;",
          "1789:  char *rootfs_path = NULL;",
          "1790:  if (rootfs && rootfs->path)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1788:  bool dev = hasmntopt(mntent, \"dev\") != NULL;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1803:  }",
          "1805:  ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,",
          "1808:  free(mntdata);",
          "1809:  return ret;",
          "",
          "[Removed Lines]",
          "1806:      mntdata, optional, rootfs_path);",
          "",
          "[Added Lines]",
          "1807:      mntdata, optional, dev, rootfs_path);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-8746",
  "cve_desc": "fs/nfs/nfs4proc.c in the NFS client in the Linux kernel before 4.2.2 does not properly initialize memory for migration recovery operations, which allows remote NFS servers to cause a denial of service (NULL pointer dereference and panic) via crafted network traffic.",
  "repo": "torvalds/linux",
  "patch_hash": "18e3b739fdc826481c6a1335ce0c5b19b3d415da",
  "patch_info": {
    "commit_hash": "18e3b739fdc826481c6a1335ce0c5b19b3d415da",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/18e3b739fdc826481c6a1335ce0c5b19b3d415da",
    "files": [
      "fs/nfs/nfs4proc.c"
    ],
    "message": "NFS: Fix a NULL pointer dereference of migration recovery ops for v4.2 client\n\n---Steps to Reproduce--\n<nfs-server>\n# cat /etc/exports\n/nfs/referal  *(rw,insecure,no_subtree_check,no_root_squash,crossmnt)\n/nfs/old      *(ro,insecure,subtree_check,root_squash,crossmnt)\n\n<nfs-client>\n# mount -t nfs nfs-server:/nfs/ /mnt/\n# ll /mnt/*/\n\n<nfs-server>\n# cat /etc/exports\n/nfs/referal   *(rw,insecure,no_subtree_check,no_root_squash,crossmnt,refer=/nfs/old/@nfs-server)\n/nfs/old       *(ro,insecure,subtree_check,root_squash,crossmnt)\n# service nfs restart\n\n<nfs-client>\n# ll /mnt/*/    --->>>>> oops here\n\n[ 5123.102925] BUG: unable to handle kernel NULL pointer dereference at           (null)\n[ 5123.103363] IP: [<ffffffffa03ed38b>] nfs4_proc_get_locations+0x9b/0x120 [nfsv4]\n[ 5123.103752] PGD 587b9067 PUD 3cbf5067 PMD 0\n[ 5123.104131] Oops: 0000 [#1]\n[ 5123.104529] Modules linked in: nfsv4(OE) nfs(OE) fscache(E) nfsd(OE) xfs libcrc32c iscsi_tcp libiscsi_tcp libiscsi scsi_transport_iscsi coretemp crct10dif_pclmul crc32_pclmul crc32c_intel ghash_clmulni_intel ppdev vmw_balloon parport_pc parport i2c_piix4 shpchp auth_rpcgss nfs_acl vmw_vmci lockd grace sunrpc vmwgfx drm_kms_helper ttm drm mptspi serio_raw scsi_transport_spi e1000 mptscsih mptbase ata_generic pata_acpi [last unloaded: nfsd]\n[ 5123.105887] CPU: 0 PID: 15853 Comm: ::1-manager Tainted: G           OE   4.2.0-rc6+ #214\n[ 5123.106358] Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 05/20/2014\n[ 5123.106860] task: ffff88007620f300 ti: ffff88005877c000 task.ti: ffff88005877c000\n[ 5123.107363] RIP: 0010:[<ffffffffa03ed38b>]  [<ffffffffa03ed38b>] nfs4_proc_get_locations+0x9b/0x120 [nfsv4]\n[ 5123.107909] RSP: 0018:ffff88005877fdb8  EFLAGS: 00010246\n[ 5123.108435] RAX: ffff880053f3bc00 RBX: ffff88006ce6c908 RCX: ffff880053a0d240\n[ 5123.108968] RDX: ffffea0000e6d940 RSI: ffff8800399a0000 RDI: ffff88006ce6c908\n[ 5123.109503] RBP: ffff88005877fe28 R08: ffffffff81c708a0 R09: 0000000000000000\n[ 5123.110045] R10: 00000000000001a2 R11: ffff88003ba7f5c8 R12: ffff880054c55800\n[ 5123.110618] R13: 0000000000000000 R14: ffff880053a0d240 R15: ffff880053a0d240\n[ 5123.111169] FS:  0000000000000000(0000) GS:ffffffff81c27000(0000) knlGS:0000000000000000\n[ 5123.111726] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ 5123.112286] CR2: 0000000000000000 CR3: 0000000054cac000 CR4: 00000000001406f0\n[ 5123.112888] Stack:\n[ 5123.113458]  ffffea0000e6d940 ffff8800399a0000 00000000000167d0 0000000000000000\n[ 5123.114049]  0000000000000000 0000000000000000 0000000000000000 00000000a7ec82c6\n[ 5123.114662]  ffff88005877fe18 ffffea0000e6d940 ffff8800399a0000 ffff880054c55800\n[ 5123.115264] Call Trace:\n[ 5123.115868]  [<ffffffffa03fb44b>] nfs4_try_migration+0xbb/0x220 [nfsv4]\n[ 5123.116487]  [<ffffffffa03fcb3b>] nfs4_run_state_manager+0x4ab/0x7b0 [nfsv4]\n[ 5123.117104]  [<ffffffffa03fc690>] ? nfs4_do_reclaim+0x510/0x510 [nfsv4]\n[ 5123.117813]  [<ffffffff810a4527>] kthread+0xd7/0xf0\n[ 5123.118456]  [<ffffffff810a4450>] ? kthread_worker_fn+0x160/0x160\n[ 5123.119108]  [<ffffffff816d9cdf>] ret_from_fork+0x3f/0x70\n[ 5123.119723]  [<ffffffff810a4450>] ? kthread_worker_fn+0x160/0x160\n[ 5123.120329] Code: 4c 8b 6a 58 74 17 eb 52 48 8d 55 a8 89 c6 4c 89 e7 e8 4a b5 ff ff 8b 45 b0 85 c0 74 1c 4c 89 f9 48 8b 55 90 48 8b 75 98 48 89 df <41> ff 55 00 3d e8 d8 ff ff 41 89 c6 74 cf 48 8b 4d c8 65 48 33\n[ 5123.121643] RIP  [<ffffffffa03ed38b>] nfs4_proc_get_locations+0x9b/0x120 [nfsv4]\n[ 5123.122308]  RSP <ffff88005877fdb8>\n[ 5123.122942] CR2: 0000000000000000\n\nFixes: ec011fe847 (\"NFS: Introduce a vector of migration recovery ops\")\nCc: stable@vger.kernel.org # v3.13+\nSigned-off-by: Kinglong Mee <kinglongmee@gmail.com>\nSigned-off-by: Trond Myklebust <trond.myklebust@primarydata.com>",
    "before_after_code_files": [
      "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c"
    ]
  },
  "patch_diff": {
    "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c": [
      "File: fs/nfs/nfs4proc.c -> fs/nfs/nfs4proc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "8661:  .reboot_recovery_ops = &nfs41_reboot_recovery_ops,",
      "8662:  .nograce_recovery_ops = &nfs41_nograce_recovery_ops,",
      "8663:  .state_renewal_ops = &nfs41_state_renewal_ops,",
      "8664: };",
      "8665: #endif",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "8664:  .mig_recovery_ops = &nfs41_mig_recovery_ops,",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5fc960380ea44ba529c78b558b6cd4250e5e1958",
      "candidate_info": {
        "commit_hash": "5fc960380ea44ba529c78b558b6cd4250e5e1958",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5fc960380ea44ba529c78b558b6cd4250e5e1958",
        "files": [
          "arch/x86/kernel/fpu/init.c"
        ],
        "message": "x86/fpu/math-emu: Fix math-emu boot crash\n\nOn a math-emu bootup the following crash occurs:\n\n\tInitializing CPU#0\n\t------------[ cut here ]------------\n\tkernel BUG at arch/x86/kernel/traps.c:779!\n\tinvalid opcode: 0000 [#1] SMP\n\t[...]\n\tEIP is at do_device_not_available+0xe/0x70\n\t[...]\n\tCall Trace:\n\t [<c18238e6>] error_code+0x5a/0x60\n\t [<c1002bd0>] ? math_error+0x140/0x140\n\t [<c100bbd9>] ? fpu__init_cpu+0x59/0xa0\n\t [<c1012322>] cpu_init+0x202/0x330\n\t [<c104509f>] ? __native_set_fixmap+0x1f/0x30\n\t [<c1b56ab0>] trap_init+0x305/0x346\n\t [<c1b548af>] start_kernel+0x1a5/0x35d\n\t [<c1b542b4>] i386_start_kernel+0x82/0x86\n\nThe reason is that in the following commit:\n\n  b1276c48e91b (\"x86/fpu: Initialize fpregs in fpu__init_cpu_generic()\")\n\nI failed to consider math-emu's limitation that it cannot execute the\nFNINIT instruction in kernel mode.\n\nThe long term fix might be to allow math-emu to execute (certain) kernel\nmode FPU instructions, but for now apply the safe (albeit somewhat ugly)\nfix: initialize the emulation state explicitly without trapping out to\nthe FPU emulator.\n\nCc: Andy Lutomirski <luto@amacapital.net>\nCc: Borislav Petkov <bp@alien8.de>\nCc: Brian Gerst <brgerst@gmail.com>\nCc: Dave Hansen <dave.hansen@linux.intel.com>\nCc: Denys Vlasenko <dvlasenk@redhat.com>\nCc: Fenghua Yu <fenghua.yu@intel.com>\nCc: H. Peter Anvin <hpa@zytor.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Oleg Nesterov <oleg@redhat.com>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Quentin Casasnovas <quentin.casasnovas@oracle.com>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: linux-kernel@vger.kernel.org\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "before_after_code_files": [
          "arch/x86/kernel/fpu/init.c||arch/x86/kernel/fpu/init.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/x86/kernel/fpu/init.c||arch/x86/kernel/fpu/init.c": [
          "File: arch/x86/kernel/fpu/init.c -> arch/x86/kernel/fpu/init.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "40:  write_cr0(cr0);",
          "44: }",
          "",
          "[Removed Lines]",
          "43:  asm volatile (\"fninit\");",
          "",
          "[Added Lines]",
          "43: #ifdef CONFIG_MATH_EMULATION",
          "44:  if (!cpu_has_fpu)",
          "45:   fpstate_init_soft(&current->thread.fpu.state.soft);",
          "46:  else",
          "47: #endif",
          "48:   asm volatile (\"fninit\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7f98ca454ad373fc1b76be804fa7138ff68c1d27",
      "candidate_info": {
        "commit_hash": "7f98ca454ad373fc1b76be804fa7138ff68c1d27",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7f98ca454ad373fc1b76be804fa7138ff68c1d27",
        "files": [
          "drivers/gpu/drm/radeon/radeon_irq_kms.c"
        ],
        "message": "drm/radeon: fix hotplug race at startup\n\nWe apparantly get a hotplug irq before we've initialised\nmodesetting,\n\n[drm] Loading R100 Microcode\nBUG: unable to handle kernel NULL pointer dereference at   (null)\nIP: [<c125f56f>] __mutex_lock_slowpath+0x23/0x91\n*pde = 00000000\nOops: 0002 [#1]\nModules linked in: radeon(+) drm_kms_helper ttm drm i2c_algo_bit backlight pcspkr psmouse evdev sr_mod input_leds led_class cdrom sg parport_pc parport floppy intel_agp intel_gtt lpc_ich acpi_cpufreq processor button mfd_core agpgart uhci_hcd ehci_hcd rng_core snd_intel8x0 snd_ac97_codec ac97_bus snd_pcm usbcore usb_common i2c_i801 i2c_core snd_timer snd soundcore thermal_sys\nCPU: 0 PID: 15 Comm: kworker/0:1 Not tainted 4.2.0-rc7-00015-gbf67402 #111\nHardware name: MicroLink                               /D850MV                         , BIOS MV85010A.86A.0067.P24.0304081124 04/08/2003\nWorkqueue: events radeon_hotplug_work_func [radeon]\ntask: f6ca5900 ti: f6d3e000 task.ti: f6d3e000\nEIP: 0060:[<c125f56f>] EFLAGS: 00010282 CPU: 0\nEIP is at __mutex_lock_slowpath+0x23/0x91\nEAX: 00000000 EBX: f5e900fc ECX: 00000000 EDX: fffffffe\nESI: f6ca5900 EDI: f5e90100 EBP: f5e90000 ESP: f6d3ff0c\n DS: 007b ES: 007b FS: 0000 GS: 0000 SS: 0068\nCR0: 8005003b CR2: 00000000 CR3: 36f61000 CR4: 000006d0\nStack:\n f5e90100 00000000 c103c4c1 f6d2a5a0 f5e900fc f6df394c c125f162 f8b0faca\n f6d2a5a0 c138ca00 f6df394c f7395600 c1034741 00d40000 00000000 f6d2a5a0\n c138ca00 f6d2a5b8 c138ca10 c1034b58 00000001 f6d40000 f6ca5900 f6d0c940\nCall Trace:\n [<c103c4c1>] ? dequeue_task_fair+0xa4/0xb7\n [<c125f162>] ? mutex_lock+0x9/0xa\n [<f8b0faca>] ? radeon_hotplug_work_func+0x17/0x57 [radeon]\n [<c1034741>] ? process_one_work+0xfc/0x194\n [<c1034b58>] ? worker_thread+0x18d/0x218\n [<c10349cb>] ? rescuer_thread+0x1d5/0x1d5\n [<c103742a>] ? kthread+0x7b/0x80\n [<c12601c0>] ? ret_from_kernel_thread+0x20/0x30\n [<c10373af>] ? init_completion+0x18/0x18\nCode: 42 08 e8 8e a6 dd ff c3 57 56 53 83 ec 0c 8b 35 48 f7 37 c1 8b 10 4a 74 1a 89 c3 8d 78 04 8b 40 08 89 63\n\nReported-and-Tested-by: Meelis Roos <mroos@linux.ee>\nSigned-off-by: Dave Airlie <airlied@redhat.com>",
        "before_after_code_files": [
          "drivers/gpu/drm/radeon/radeon_irq_kms.c||drivers/gpu/drm/radeon/radeon_irq_kms.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpu/drm/radeon/radeon_irq_kms.c||drivers/gpu/drm/radeon/radeon_irq_kms.c": [
          "File: drivers/gpu/drm/radeon/radeon_irq_kms.c -> drivers/gpu/drm/radeon/radeon_irq_kms.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "79:  struct drm_mode_config *mode_config = &dev->mode_config;",
          "80:  struct drm_connector *connector;",
          "82:  mutex_lock(&mode_config->mutex);",
          "83:  if (mode_config->num_connector) {",
          "84:   list_for_each_entry(connector, &mode_config->connector_list, head)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "84:  if (!rdev->mode_info.mode_config_initialized)",
          "85:   return;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "02373d7c69b4270bbab930f8a81b0721be794347",
      "candidate_info": {
        "commit_hash": "02373d7c69b4270bbab930f8a81b0721be794347",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/02373d7c69b4270bbab930f8a81b0721be794347",
        "files": [
          "drivers/thermal/cpu_cooling.c"
        ],
        "message": "thermal: cpu_cooling: fix lockdep problems in cpu_cooling\n\nA recent change to the cpu_cooling code introduced a AB-BA deadlock\nscenario between the cpufreq_policy_notifier_list rwsem and the\ncooling_cpufreq_lock.  This is caused by cooling_cpufreq_lock being held\nbefore the registration/removal of the notifier block (an operation\nwhich takes the rwsem), and the notifier code itself which takes the\nlocks in the reverse order:\n\n======================================================\n[ INFO: possible circular locking dependency detected ]\n3.18.0+ #1453 Not tainted\n-------------------------------------------------------\nrc.local/770 is trying to acquire lock:\n (cooling_cpufreq_lock){+.+.+.}, at: [<c04abfc4>] cpufreq_thermal_notifier+0x34/0xfc\n\nbut task is already holding lock:\n ((cpufreq_policy_notifier_list).rwsem){++++.+}, at: [<c0042f04>]  __blocking_notifier_call_chain+0x34/0x68\n\nwhich lock already depends on the new lock.\n\nthe existing dependency chain (in reverse order) is:\n\n-> #1 ((cpufreq_policy_notifier_list).rwsem){++++.+}:\n       [<c06bc3b0>] down_write+0x44/0x9c\n       [<c0043444>] blocking_notifier_chain_register+0x28/0xd8\n       [<c04ad610>] cpufreq_register_notifier+0x68/0x90\n       [<c04abe4c>] __cpufreq_cooling_register.part.1+0x120/0x180\n       [<c04abf44>] __cpufreq_cooling_register+0x98/0xa4\n       [<c04abf8c>] cpufreq_cooling_register+0x18/0x1c\n       [<bf0046f8>] imx_thermal_probe+0x1c0/0x470 [imx_thermal]\n       [<c037cef8>] platform_drv_probe+0x50/0xac\n       [<c037b710>] driver_probe_device+0x114/0x234\n       [<c037b8cc>] __driver_attach+0x9c/0xa0\n       [<c0379d68>] bus_for_each_dev+0x5c/0x90\n       [<c037b204>] driver_attach+0x24/0x28\n       [<c037ae7c>] bus_add_driver+0xe0/0x1d8\n       [<c037c0cc>] driver_register+0x80/0xfc\n       [<c037cd80>] __platform_driver_register+0x50/0x64\n       [<bf007018>] 0xbf007018\n       [<c0008a5c>] do_one_initcall+0x88/0x1d8\n       [<c0095da4>] load_module+0x1768/0x1ef8\n       [<c0096614>] SyS_init_module+0xe0/0xf4\n       [<c000ec00>] ret_fast_syscall+0x0/0x48\n\n-> #0 (cooling_cpufreq_lock){+.+.+.}:\n       [<c00619f8>] lock_acquire+0xb0/0x124\n       [<c06ba3b4>] mutex_lock_nested+0x5c/0x3d8\n       [<c04abfc4>] cpufreq_thermal_notifier+0x34/0xfc\n       [<c0042bf4>] notifier_call_chain+0x4c/0x8c\n       [<c0042f20>] __blocking_notifier_call_chain+0x50/0x68\n       [<c0042f58>] blocking_notifier_call_chain+0x20/0x28\n       [<c04ae62c>] cpufreq_set_policy+0x7c/0x1d0\n       [<c04af3cc>] store_scaling_governor+0x74/0x9c\n       [<c04ad418>] store+0x90/0xc0\n       [<c0175384>] sysfs_kf_write+0x54/0x58\n       [<c01746b4>] kernfs_fop_write+0xdc/0x190\n       [<c010dcc0>] vfs_write+0xac/0x1b4\n       [<c010dfec>] SyS_write+0x44/0x90\n       [<c000ec00>] ret_fast_syscall+0x0/0x48\n\nother info that might help us debug this:\n\n Possible unsafe locking scenario:\n\n       CPU0                    CPU1\n       ----                    ----\n  lock((cpufreq_policy_notifier_list).rwsem);\n                               lock(cooling_cpufreq_lock);\n                               lock((cpufreq_policy_notifier_list).rwsem);\n  lock(cooling_cpufreq_lock);\n\n *** DEADLOCK ***\n\n7 locks held by rc.local/770:\n #0:  (sb_writers#6){.+.+.+}, at: [<c010dda0>] vfs_write+0x18c/0x1b4\n #1:  (&of->mutex){+.+.+.}, at: [<c0174678>] kernfs_fop_write+0xa0/0x190\n #2:  (s_active#52){.+.+.+}, at: [<c0174680>] kernfs_fop_write+0xa8/0x190\n #3:  (cpu_hotplug.lock){++++++}, at: [<c0026a60>] get_online_cpus+0x34/0x90\n #4:  (cpufreq_rwsem){.+.+.+}, at: [<c04ad3e0>] store+0x58/0xc0\n #5:  (&policy->rwsem){+.+.+.}, at: [<c04ad3f8>] store+0x70/0xc0\n #6:  ((cpufreq_policy_notifier_list).rwsem){++++.+}, at: [<c0042f04>] __blocking_notifier_call_chain+0x34/0x68\n\nstack backtrace:\nCPU: 0 PID: 770 Comm: rc.local Not tainted 3.18.0+ #1453\nHardware name: Freescale i.MX6 Quad/DualLite (Device Tree)\nBacktrace:\n[<c00121c8>] (dump_backtrace) from [<c0012360>] (show_stack+0x18/0x1c)\n r6:c0b85a80 r5:c0b75630 r4:00000000 r3:00000000\n[<c0012348>] (show_stack) from [<c06b6c48>] (dump_stack+0x7c/0x98)\n[<c06b6bcc>] (dump_stack) from [<c06b42a4>] (print_circular_bug+0x28c/0x2d8)\n r4:c0b85a80 r3:d0071d40\n[<c06b4018>] (print_circular_bug) from [<c00613b0>] (__lock_acquire+0x1acc/0x1bb0)\n r10:c0b50660 r8:c09e6d80 r7:d0071d40 r6:c11d0f0c r5:00000007 r4:d0072240\n[<c005f8e4>] (__lock_acquire) from [<c00619f8>] (lock_acquire+0xb0/0x124)\n r10:00000000 r9:c04abfc4 r8:00000000 r7:00000000 r6:00000000 r5:c0a06f0c\n r4:00000000\n[<c0061948>] (lock_acquire) from [<c06ba3b4>] (mutex_lock_nested+0x5c/0x3d8)\n r10:ec853800 r9:c0a06ed4 r8:d0071d40 r7:c0a06ed4 r6:c11d0f0c r5:00000000\n r4:c04abfc4\n[<c06ba358>] (mutex_lock_nested) from [<c04abfc4>] (cpufreq_thermal_notifier+0x34/0xfc)\n r10:ec853800 r9:ec85380c r8:d00d7d3c r7:c0a06ed4 r6:d00d7d3c r5:00000000\n r4:fffffffe\n[<c04abf90>] (cpufreq_thermal_notifier) from [<c0042bf4>] (notifier_call_chain+0x4c/0x8c)\n r7:00000000 r6:00000000 r5:00000000 r4:fffffffe\n[<c0042ba8>] (notifier_call_chain) from [<c0042f20>] (__blocking_notifier_call_chain+0x50/0x68)\n r8:c0a072a4 r7:00000000 r6:d00d7d3c r5:ffffffff r4:c0a06fc8 r3:ffffffff\n[<c0042ed0>] (__blocking_notifier_call_chain) from [<c0042f58>] (blocking_notifier_call_chain+0x20/0x28)\n r7:ec98b540 r6:c13ebc80 r5:ed76e600 r4:d00d7d3c\n[<c0042f38>] (blocking_notifier_call_chain) from [<c04ae62c>] (cpufreq_set_policy+0x7c/0x1d0)\n[<c04ae5b0>] (cpufreq_set_policy) from [<c04af3cc>] (store_scaling_governor+0x74/0x9c)\n r7:ec98b540 r6:0000000c r5:ec98b540 r4:ed76e600\n[<c04af358>] (store_scaling_governor) from [<c04ad418>] (store+0x90/0xc0)\n r6:0000000c r5:ed76e6d4 r4:ed76e600\n[<c04ad388>] (store) from [<c0175384>] (sysfs_kf_write+0x54/0x58)\n r8:0000000c r7:d00d7f78 r6:ec98b540 r5:0000000c r4:ec853800 r3:0000000c\n[<c0175330>] (sysfs_kf_write) from [<c01746b4>] (kernfs_fop_write+0xdc/0x190)\n r6:ec98b540 r5:00000000 r4:00000000 r3:c0175330\n[<c01745d8>] (kernfs_fop_write) from [<c010dcc0>] (vfs_write+0xac/0x1b4)\n r10:0162aa70 r9:d00d6000 r8:0000000c r7:d00d7f78 r6:0162aa70 r5:0000000c\n r4:eccde500\n[<c010dc14>] (vfs_write) from [<c010dfec>] (SyS_write+0x44/0x90)\n r10:0162aa70 r8:0000000c r7:eccde500 r6:eccde500 r5:00000000 r4:00000000\n[<c010dfa8>] (SyS_write) from [<c000ec00>] (ret_fast_syscall+0x0/0x48)\n r10:00000000 r8:c000edc4 r7:00000004 r6:000216cc r5:0000000c r4:0162aa70\n\nSolve this by moving to finer grained locking - use one mutex to protect\nthe cpufreq_dev_list as a whole, and a separate lock to ensure correct\nordering of cpufreq notifier registration and removal.\n\ncooling_list_lock is taken within cooling_cpufreq_lock on\n(un)registration to preserve the behavior of the code, i.e. to\natomically add/remove to the list and (un)register the notifier.\n\nFixes: 2dcd851fe4b4 (\"thermal: cpu_cooling: Update always cpufreq policy with\nReviewed-by: Viresh Kumar <viresh.kumar@linaro.org>\nSigned-off-by: Russell King <rmk+kernel@arm.linux.org.uk>\nSigned-off-by: Viresh Kumar <viresh.kumar@linaro.org>\nSigned-off-by: Eduardo Valentin <edubezval@gmail.com>",
        "before_after_code_files": [
          "drivers/thermal/cpu_cooling.c||drivers/thermal/cpu_cooling.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/thermal/cpu_cooling.c||drivers/thermal/cpu_cooling.c": [
          "File: drivers/thermal/cpu_cooling.c -> drivers/thermal/cpu_cooling.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "107: static DEFINE_IDR(cpufreq_idr);",
          "108: static DEFINE_MUTEX(cooling_cpufreq_lock);",
          "110: static LIST_HEAD(cpufreq_dev_list);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "110: static unsigned int cpufreq_dev_count;",
          "112: static DEFINE_MUTEX(cooling_list_lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "185: {",
          "186:  struct cpufreq_cooling_device *cpufreq_dev;",
          "189:  list_for_each_entry(cpufreq_dev, &cpufreq_dev_list, node) {",
          "190:   if (cpumask_test_cpu(cpu, &cpufreq_dev->allowed_cpus)) {",
          "192:    return get_level(cpufreq_dev, freq);",
          "193:   }",
          "194:  }",
          "197:  pr_err(\"%s: cpu:%d not part of any cooling device\\n\", __func__, cpu);",
          "198:  return THERMAL_CSTATE_INVALID;",
          "",
          "[Removed Lines]",
          "188:  mutex_lock(&cooling_cpufreq_lock);",
          "191:    mutex_unlock(&cooling_cpufreq_lock);",
          "195:  mutex_unlock(&cooling_cpufreq_lock);",
          "",
          "[Added Lines]",
          "191:  mutex_lock(&cooling_list_lock);",
          "194:    mutex_unlock(&cooling_list_lock);",
          "198:  mutex_unlock(&cooling_list_lock);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "221:  switch (event) {",
          "223:  case CPUFREQ_ADJUST:",
          "225:   list_for_each_entry(cpufreq_dev, &cpufreq_dev_list, node) {",
          "226:    if (!cpumask_test_cpu(policy->cpu,",
          "227:            &cpufreq_dev->allowed_cpus))",
          "",
          "[Removed Lines]",
          "224:   mutex_lock(&cooling_cpufreq_lock);",
          "",
          "[Added Lines]",
          "227:   mutex_lock(&cooling_list_lock);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "233:     cpufreq_verify_within_limits(policy, 0,",
          "234:             max_freq);",
          "235:   }",
          "237:   break;",
          "238:  default:",
          "239:   return NOTIFY_DONE;",
          "",
          "[Removed Lines]",
          "236:   mutex_unlock(&cooling_cpufreq_lock);",
          "",
          "[Added Lines]",
          "239:   mutex_unlock(&cooling_list_lock);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "867:  mutex_lock(&cooling_cpufreq_lock);",
          "871:   cpufreq_register_notifier(&thermal_cpufreq_notifier_block,",
          "872:        CPUFREQ_POLICY_NOTIFIER);",
          "875:  mutex_unlock(&cooling_cpufreq_lock);",
          "877:  return cool_dev;",
          "",
          "[Removed Lines]",
          "870:  if (list_empty(&cpufreq_dev_list))",
          "873:  list_add(&cpufreq_dev->node, &cpufreq_dev_list);",
          "",
          "[Added Lines]",
          "872:  mutex_lock(&cooling_list_lock);",
          "873:  list_add(&cpufreq_dev->node, &cpufreq_dev_list);",
          "874:  mutex_unlock(&cooling_list_lock);",
          "877:  if (!cpufreq_dev_count++)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1013:   return;",
          "1015:  cpufreq_dev = cdev->devdata;",
          "1021:   cpufreq_unregister_notifier(&thermal_cpufreq_notifier_block,",
          "1022:          CPUFREQ_POLICY_NOTIFIER);",
          "1023:  mutex_unlock(&cooling_cpufreq_lock);",
          "1025:  thermal_cooling_device_unregister(cpufreq_dev->cool_dev);",
          "",
          "[Removed Lines]",
          "1016:  mutex_lock(&cooling_cpufreq_lock);",
          "1017:  list_del(&cpufreq_dev->node);",
          "1020:  if (list_empty(&cpufreq_dev_list))",
          "",
          "[Added Lines]",
          "1023:  mutex_lock(&cooling_cpufreq_lock);",
          "1024:  if (!--cpufreq_dev_count)",
          "1028:  mutex_lock(&cooling_list_lock);",
          "1029:  list_del(&cpufreq_dev->node);",
          "1030:  mutex_unlock(&cooling_list_lock);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "046be74da8f257c4f1925ed4b5d4ee4c822ef9c6",
      "candidate_info": {
        "commit_hash": "046be74da8f257c4f1925ed4b5d4ee4c822ef9c6",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/046be74da8f257c4f1925ed4b5d4ee4c822ef9c6",
        "files": [
          "fs/nfs/pnfs_nfs.c"
        ],
        "message": "NFS41: fix list splice type\n\nWe want to move commiting pages to pages list instead.\nOtherwise it causes pnfs small writes crash like:\n\n[34560.037692] BUG: unable to handle kernel NULL pointer dereference at 0000000000000068\n[34560.038557] IP: [<ffffffffa05423d6>] nfs_init_commit+0x26/0x130 [nfs]\n[34560.039400] PGD 69f5a067 PUD 69f59067 PMD 0\n[34560.040207] Oops: 0000 [#1] SMP\n[34560.041014] Modules linked in: nfsv3(OE) nfs_layout_flexfiles(OE) nfsv4(OE) nfs(OE) fscache(E) rpcsec_gss_krb5(E) xt_addrtype(E) xt_conntrack(E) ipt_MASQUERADE(E) nf_nat_masquerade_ipv4(E) iptable_nat(E) nf_conntrack_ipv4(E) nf_defrag_ipv4(E) nf_nat_ipv4(E) iptable_filter(E) ip_tables(E) x_tables(E) nf_nat(E) nf_conntrack(E) bridge(E) stp(E) llc(E) dm_thin_pool(E) dm_persistent_data(E) dm_bio_prison(E) dm_bufio(E) ppdev(E) vmw_balloon(E) coretemp(E) crc32_pclmul(E) ghash_clmulni_intel(E) aesni_intel(E) aes_x86_64(E) glue_helper(E) lrw(E) gf128mul(E) ablk_helper(E) cryptd(E) psmouse(E) serio_raw(E) vmw_vmci(E) i2c_piix4(E) shpchp(E) parport_pc(E) parport(E) mac_hid(E) nfsd(E) auth_rpcgss(E) nfs_acl(E) lockd(E) grace(E) sunrpc(E) xfs(E) libcrc32c(E) hid_generic(E) usbhid(E) hid(E) e1000(E) mptspi(E)\n[34560.045106]  mptscsih(E) mptbase(E) vmwgfx(E) drm_kms_helper(E) ttm(E) drm(E) autofs4(E) [last unloaded: fscache]\n[34560.045897] CPU: 0 PID: 130543 Comm: bash Tainted: G           OE   4.2.0-rc5-dp-00057-gf993a93 #11\n[34560.046699] Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 05/20/2014\n[34560.047525] task: ffff880031b0a980 ti: ffff880045fec000 task.ti: ffff880045fec000\n[34560.048264] RIP: 0010:[<ffffffffa05423d6>]  [<ffffffffa05423d6>] nfs_init_commit+0x26/0x130 [nfs]\n[34560.049000] RSP: 0018:ffff880045fefc18  EFLAGS: 00010246\n[34560.049717] RAX: 0000000000000000 RBX: ffff8800208fbc80 RCX: ffff880045fefd50\n[34560.050396] RDX: ffff880031c19ec0 RSI: ffff880045fefc88 RDI: ffff8800208fbc80\n[34560.051041] RBP: ffff880045fefc28 R08: ffff8800208fbe68 R09: ffff880045fefc88\n[34560.051666] R10: 0000000000000000 R11: 0000000000000000 R12: ffff880045fefc78\n[34560.052247] R13: ffff880045fefc88 R14: ffff880045fefa90 R15: ffff880045fefd50\n[34560.052825] FS:  00007fa02d58c740(0000) GS:ffff88006d600000(0000) knlGS:0000000000000000\n[34560.053410] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[34560.053992] CR2: 0000000000000068 CR3: 000000003b37a000 CR4: 00000000001406f0\n[34560.054615] Stack:\n[34560.055200]  ffff8800208fbc80 ffff8800208fbc80 ffff880045fefcc8 ffffffffa05c1a5b\n[34560.055800]  ffff880045fefcc8 ffff880045fefd50 0000000045fefcb8 ffff880045fefd40\n[34560.056418]  ffff8800420608e0 ffffffffa04f3910 0000000100000001 ffff880045fefd50\n[34560.057013] Call Trace:\n[34560.057672]  [<ffffffffa05c1a5b>] pnfs_generic_commit_pagelist+0x1cb/0x300 [nfsv4]\n[34560.058277]  [<ffffffffa04f3910>] ? ff_layout_commit_pagelist+0x20/0x20 [nfs_layout_flexfiles]\n[34560.058907]  [<ffffffffa04f3905>] ff_layout_commit_pagelist+0x15/0x20 [nfs_layout_flexfiles]\n[34560.059557]  [<ffffffffa0543fc1>] nfs_generic_commit_list+0xb1/0xf0 [nfs]\n[34560.060214]  [<ffffffffa0543e47>] ? nfs_scan_commit+0x37/0xa0 [nfs]\n[34560.060825]  [<ffffffffa0544081>] nfs_commit_inode+0x81/0x150 [nfs]\n[34560.061432]  [<ffffffffa05443ae>] nfs_wb_all+0x1ae/0x400 [nfs]\n[34560.062035]  [<ffffffffa05380ad>] nfs_getattr+0x33d/0x510 [nfs]\n[34560.062630]  [<ffffffff8122499c>] vfs_getattr_nosec+0x2c/0x40\n[34560.063223]  [<ffffffff81224a66>] vfs_getattr+0x26/0x30\n[34560.063818]  [<ffffffff81224b35>] vfs_fstatat+0x65/0xa0\n[34560.064413]  [<ffffffff81224f3f>] SYSC_newstat+0x1f/0x40\n[34560.065016]  [<ffffffff8102b176>] ? do_audit_syscall_entry+0x66/0x70\n[34560.065626]  [<ffffffff8102c773>] ? syscall_trace_enter_phase1+0x113/0x170\n[34560.066245]  [<ffffffff81003017>] ? trace_hardirqs_on_thunk+0x17/0x19\n[34560.066868]  [<ffffffff812251ae>] SyS_newstat+0xe/0x10\n[34560.067533]  [<ffffffff817a5df2>] entry_SYSCALL_64_fastpath+0x16/0x7a\n[34560.068173] Code: 0f 1f 44 00 00 0f 1f 44 00 00 55 4c 8d 87 e8 01 00 00 48 89 e5 53 48 89 fb 48 83 ec 08 4c 8b 0e 49 8b 41 18 4c 39 ce 48 8b 40 40 <4c> 8b 50 68 74 24 48 8b 87 e8 01 00 00 48 8b 7e 08 4d 89 41 08\n[34560.069609] RIP  [<ffffffffa05423d6>] nfs_init_commit+0x26/0x130 [nfs]\n[34560.070295]  RSP <ffff880045fefc18>\n[34560.071008] CR2: 0000000000000068\n[34560.073207] ---[ end trace f85f873260977406 ]---\n\n[fixes 27571297a7e(pNFS: Tighten up locking around DS commit buckets)]\nSigned-off-by: Peng Tao <tao.peng@primarydata.com>\nSigned-off-by: Trond Myklebust <trond.myklebust@primarydata.com>",
        "before_after_code_files": [
          "fs/nfs/pnfs_nfs.c||fs/nfs/pnfs_nfs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/nfs/pnfs_nfs.c||fs/nfs/pnfs_nfs.c": [
          "File: fs/nfs/pnfs_nfs.c -> fs/nfs/pnfs_nfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "240:  bucket = &cinfo->ds->buckets[data->ds_commit_index];",
          "241:  spin_lock(cinfo->lock);",
          "243:  data->lseg = bucket->clseg;",
          "244:  bucket->clseg = NULL;",
          "245:  spin_unlock(cinfo->lock);",
          "",
          "[Removed Lines]",
          "242:  list_splice_init(pages, &bucket->committing);",
          "",
          "[Added Lines]",
          "242:  list_splice_init(&bucket->committing, pages);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "602b8593d2b4138c10e922eeaafe306f6b51817b",
      "candidate_info": {
        "commit_hash": "602b8593d2b4138c10e922eeaafe306f6b51817b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/602b8593d2b4138c10e922eeaafe306f6b51817b",
        "files": [
          "ipc/sem.c"
        ],
        "message": "ipc,sem: fix use after free on IPC_RMID after a task using same semaphore set exits\n\nThe current semaphore code allows a potential use after free: in\nexit_sem we may free the task's sem_undo_list while there is still\nanother task looping through the same semaphore set and cleaning the\nsem_undo list at freeary function (the task called IPC_RMID for the same\nsemaphore set).\n\nFor example, with a test program [1] running which keeps forking a lot\nof processes (which then do a semop call with SEM_UNDO flag), and with\nthe parent right after removing the semaphore set with IPC_RMID, and a\nkernel built with CONFIG_SLAB, CONFIG_SLAB_DEBUG and\nCONFIG_DEBUG_SPINLOCK, you can easily see something like the following\nin the kernel log:\n\n   Slab corruption (Not tainted): kmalloc-64 start=ffff88003b45c1c0, len=64\n   000: 6b 6b 6b 6b 6b 6b 6b 6b 00 6b 6b 6b 6b 6b 6b 6b  kkkkkkkk.kkkkkkk\n   010: ff ff ff ff 6b 6b 6b 6b ff ff ff ff ff ff ff ff  ....kkkk........\n   Prev obj: start=ffff88003b45c180, len=64\n   000: 00 00 00 00 ad 4e ad de ff ff ff ff 5a 5a 5a 5a  .....N......ZZZZ\n   010: ff ff ff ff ff ff ff ff c0 fb 01 37 00 88 ff ff  ...........7....\n   Next obj: start=ffff88003b45c200, len=64\n   000: 00 00 00 00 ad 4e ad de ff ff ff ff 5a 5a 5a 5a  .....N......ZZZZ\n   010: ff ff ff ff ff ff ff ff 68 29 a7 3c 00 88 ff ff  ........h).<....\n   BUG: spinlock wrong CPU on CPU#2, test/18028\n   general protection fault: 0000 [#1] SMP\n   Modules linked in: 8021q mrp garp stp llc nf_conntrack_ipv4 nf_defrag_ipv4 ip6t_REJECT nf_reject_ipv6 nf_conntrack_ipv6 nf_defrag_ipv6 xt_state nf_conntrack ip6table_filter ip6_tables binfmt_misc ppdev input_leds joydev parport_pc parport floppy serio_raw virtio_balloon virtio_rng virtio_console virtio_net iosf_mbi crct10dif_pclmul crc32_pclmul ghash_clmulni_intel pcspkr qxl ttm drm_kms_helper drm snd_hda_codec_generic i2c_piix4 snd_hda_intel snd_hda_codec snd_hda_core snd_hwdep snd_seq snd_seq_device snd_pcm snd_timer snd soundcore crc32c_intel virtio_pci virtio_ring virtio pata_acpi ata_generic [last unloaded: speedstep_lib]\n   CPU: 2 PID: 18028 Comm: test Not tainted 4.2.0-rc5+ #1\n   Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.8.1-20150318_183358- 04/01/2014\n   RIP: spin_dump+0x53/0xc0\n   Call Trace:\n     spin_bug+0x30/0x40\n     do_raw_spin_unlock+0x71/0xa0\n     _raw_spin_unlock+0xe/0x10\n     freeary+0x82/0x2a0\n     ? _raw_spin_lock+0xe/0x10\n     semctl_down.clone.0+0xce/0x160\n     ? __do_page_fault+0x19a/0x430\n     ? __audit_syscall_entry+0xa8/0x100\n     SyS_semctl+0x236/0x2c0\n     ? syscall_trace_leave+0xde/0x130\n     entry_SYSCALL_64_fastpath+0x12/0x71\n   Code: 8b 80 88 03 00 00 48 8d 88 60 05 00 00 48 c7 c7 a0 2c a4 81 31 c0 65 8b 15 eb 40 f3 7e e8 08 31 68 00 4d 85 e4 44 8b 4b 08 74 5e <45> 8b 84 24 88 03 00 00 49 8d 8c 24 60 05 00 00 8b 53 04 48 89\n   RIP  [<ffffffff810d6053>] spin_dump+0x53/0xc0\n    RSP <ffff88003750fd68>\n   ---[ end trace 783ebb76612867a0 ]---\n   NMI watchdog: BUG: soft lockup - CPU#3 stuck for 22s! [test:18053]\n   Modules linked in: 8021q mrp garp stp llc nf_conntrack_ipv4 nf_defrag_ipv4 ip6t_REJECT nf_reject_ipv6 nf_conntrack_ipv6 nf_defrag_ipv6 xt_state nf_conntrack ip6table_filter ip6_tables binfmt_misc ppdev input_leds joydev parport_pc parport floppy serio_raw virtio_balloon virtio_rng virtio_console virtio_net iosf_mbi crct10dif_pclmul crc32_pclmul ghash_clmulni_intel pcspkr qxl ttm drm_kms_helper drm snd_hda_codec_generic i2c_piix4 snd_hda_intel snd_hda_codec snd_hda_core snd_hwdep snd_seq snd_seq_device snd_pcm snd_timer snd soundcore crc32c_intel virtio_pci virtio_ring virtio pata_acpi ata_generic [last unloaded: speedstep_lib]\n   CPU: 3 PID: 18053 Comm: test Tainted: G      D         4.2.0-rc5+ #1\n   Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.8.1-20150318_183358- 04/01/2014\n   RIP: native_read_tsc+0x0/0x20\n   Call Trace:\n     ? delay_tsc+0x40/0x70\n     __delay+0xf/0x20\n     do_raw_spin_lock+0x96/0x140\n     _raw_spin_lock+0xe/0x10\n     sem_lock_and_putref+0x11/0x70\n     SYSC_semtimedop+0x7bf/0x960\n     ? handle_mm_fault+0xbf6/0x1880\n     ? dequeue_task_fair+0x79/0x4a0\n     ? __do_page_fault+0x19a/0x430\n     ? kfree_debugcheck+0x16/0x40\n     ? __do_page_fault+0x19a/0x430\n     ? __audit_syscall_entry+0xa8/0x100\n     ? do_audit_syscall_entry+0x66/0x70\n     ? syscall_trace_enter_phase1+0x139/0x160\n     SyS_semtimedop+0xe/0x10\n     SyS_semop+0x10/0x20\n     entry_SYSCALL_64_fastpath+0x12/0x71\n   Code: 47 10 83 e8 01 85 c0 89 47 10 75 08 65 48 89 3d 1f 74 ff 7e c9 c3 0f 1f 44 00 00 55 48 89 e5 e8 87 17 04 00 66 90 c9 c3 0f 1f 00 <55> 48 89 e5 0f 31 89 c1 48 89 d0 48 c1 e0 20 89 c9 48 09 c8 c9\n   Kernel panic - not syncing: softlockup: hung tasks\n\nI wasn't able to trigger any badness on a recent kernel without the\nproper config debugs enabled, however I have softlockup reports on some\nkernel versions, in the semaphore code, which are similar as above (the\nscenario is seen on some servers running IBM DB2 which uses semaphore\nsyscalls).\n\nThe patch here fixes the race against freeary, by acquiring or waiting\non the sem_undo_list lock as necessary (exit_sem can race with freeary,\nwhile freeary sets un->semid to -1 and removes the same sem_undo from\nlist_proc or when it removes the last sem_undo).\n\nAfter the patch I'm unable to reproduce the problem using the test case\n[1].\n\n[1] Test case used below:\n\n    #include <stdio.h>\n    #include <sys/types.h>\n    #include <sys/ipc.h>\n    #include <sys/sem.h>\n    #include <sys/wait.h>\n    #include <stdlib.h>\n    #include <time.h>\n    #include <unistd.h>\n    #include <errno.h>\n\n    #define NSEM 1\n    #define NSET 5\n\n    int sid[NSET];\n\n    void thread()\n    {\n            struct sembuf op;\n            int s;\n            uid_t pid = getuid();\n\n            s = rand() % NSET;\n            op.sem_num = pid % NSEM;\n            op.sem_op = 1;\n            op.sem_flg = SEM_UNDO;\n\n            semop(sid[s], &op, 1);\n            exit(EXIT_SUCCESS);\n    }\n\n    void create_set()\n    {\n            int i, j;\n            pid_t p;\n            union {\n                    int val;\n                    struct semid_ds *buf;\n                    unsigned short int *array;\n                    struct seminfo *__buf;\n            } un;\n\n            /* Create and initialize semaphore set */\n            for (i = 0; i < NSET; i++) {\n                    sid[i] = semget(IPC_PRIVATE , NSEM, 0644 | IPC_CREAT);\n                    if (sid[i] < 0) {\n                            perror(\"semget\");\n                            exit(EXIT_FAILURE);\n                    }\n            }\n            un.val = 0;\n            for (i = 0; i < NSET; i++) {\n                    for (j = 0; j < NSEM; j++) {\n                            if (semctl(sid[i], j, SETVAL, un) < 0)\n                                    perror(\"semctl\");\n                    }\n            }\n\n            /* Launch threads that operate on semaphore set */\n            for (i = 0; i < NSEM * NSET * NSET; i++) {\n                    p = fork();\n                    if (p < 0)\n                            perror(\"fork\");\n                    if (p == 0)\n                            thread();\n            }\n\n            /* Free semaphore set */\n            for (i = 0; i < NSET; i++) {\n                    if (semctl(sid[i], NSEM, IPC_RMID))\n                            perror(\"IPC_RMID\");\n            }\n\n            /* Wait for forked processes to exit */\n            while (wait(NULL)) {\n                    if (errno == ECHILD)\n                            break;\n            };\n    }\n\n    int main(int argc, char **argv)\n    {\n            pid_t p;\n\n            srand(time(NULL));\n\n            while (1) {\n                    p = fork();\n                    if (p < 0) {\n                            perror(\"fork\");\n                            exit(EXIT_FAILURE);\n                    }\n                    if (p == 0) {\n                            create_set();\n                            goto end;\n                    }\n\n                    /* Wait for forked processes to exit */\n                    while (wait(NULL)) {\n                            if (errno == ECHILD)\n                                    break;\n                    };\n            }\n    end:\n            return 0;\n    }\n\n[akpm@linux-foundation.org: use normal comment layout]\nSigned-off-by: Herton R. Krzesinski <herton@redhat.com>\nAcked-by: Manfred Spraul <manfred@colorfullife.com>\nCc: Davidlohr Bueso <dave@stgolabs.net>\nCc: Rafael Aquini <aquini@redhat.com>\nCC: Aristeu Rozanski <aris@redhat.com>\nCc: David Jeffery <djeffery@redhat.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\n\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "ipc/sem.c||ipc/sem.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ipc/sem.c||ipc/sem.c": [
          "File: ipc/sem.c -> ipc/sem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2074:   rcu_read_lock();",
          "2075:   un = list_entry_rcu(ulp->list_proc.next,",
          "2076:         struct sem_undo, list_proc);",
          "2082:   if (semid == -1) {",
          "2083:    rcu_read_unlock();",
          "2085:   }",
          "2089:   if (IS_ERR(sma)) {",
          "2090:    rcu_read_unlock();",
          "",
          "[Removed Lines]",
          "2077:   if (&un->list_proc == &ulp->list_proc)",
          "2078:    semid = -1;",
          "2079:    else",
          "2080:    semid = un->semid;",
          "2084:    break;",
          "2087:   sma = sem_obtain_object_check(tsk->nsproxy->ipc_ns, un->semid);",
          "",
          "[Added Lines]",
          "2077:   if (&un->list_proc == &ulp->list_proc) {",
          "2084:    spin_unlock_wait(&ulp->lock);",
          "2085:    rcu_read_unlock();",
          "2086:    break;",
          "2087:   }",
          "2088:   spin_lock(&ulp->lock);",
          "2089:   semid = un->semid;",
          "2090:   spin_unlock(&ulp->lock);",
          "2095:    continue;",
          "2098:   sma = sem_obtain_object_check(tsk->nsproxy->ipc_ns, semid);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-8215",
  "cve_desc": "net/ipv6/addrconf.c in the IPv6 stack in the Linux kernel before 4.0 does not validate attempted changes to the MTU value, which allows context-dependent attackers to cause a denial of service (packet loss) via a value that is (1) smaller than the minimum compliant value or (2) larger than the MTU of an interface, as demonstrated by a Router Advertisement (RA) message that is not validated by a daemon, a different vulnerability than CVE-2015-0272.  NOTE: the scope of CVE-2015-0272 is limited to the NetworkManager product.",
  "repo": "torvalds/linux",
  "patch_hash": "77751427a1ff25b27d47a4c36b12c3c8667855ac",
  "patch_info": {
    "commit_hash": "77751427a1ff25b27d47a4c36b12c3c8667855ac",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/77751427a1ff25b27d47a4c36b12c3c8667855ac",
    "files": [
      "net/ipv6/addrconf.c"
    ],
    "message": "ipv6: addrconf: validate new MTU before applying it\n\nCurrently we don't check if the new MTU is valid or not and this allows\none to configure a smaller than minimum allowed by RFCs or even bigger\nthan interface own MTU, which is a problem as it may lead to packet\ndrops.\n\nIf you have a daemon like NetworkManager running, this may be exploited\nby remote attackers by forging RA packets with an invalid MTU, possibly\nleading to a DoS. (NetworkManager currently only validates for values\ntoo small, but not for too big ones.)\n\nThe fix is just to make sure the new value is valid. That is, between\nIPV6_MIN_MTU and interface's MTU.\n\nNote that similar check is already performed at\nndisc_router_discovery(), for when kernel itself parses the RA.\n\nSigned-off-by: Marcelo Ricardo Leitner <mleitner@redhat.com>\nSigned-off-by: Sabrina Dubroca <sd@queasysnail.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/ipv6/addrconf.c||net/ipv6/addrconf.c"
    ]
  },
  "patch_diff": {
    "net/ipv6/addrconf.c||net/ipv6/addrconf.c": [
      "File: net/ipv6/addrconf.c -> net/ipv6/addrconf.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4903:  return ret;",
      "4904: }",
      "4906: static void dev_disable_change(struct inet6_dev *idev)",
      "4907: {",
      "4908:  struct netdev_notifier_info info;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4906: static",
      "4907: int addrconf_sysctl_mtu(struct ctl_table *ctl, int write,",
      "4908:    void __user *buffer, size_t *lenp, loff_t *ppos)",
      "4909: {",
      "4910:  struct inet6_dev *idev = ctl->extra1;",
      "4911:  int min_mtu = IPV6_MIN_MTU;",
      "4912:  struct ctl_table lctl;",
      "4914:  lctl = *ctl;",
      "4915:  lctl.extra1 = &min_mtu;",
      "4916:  lctl.extra2 = idev ? &idev->dev->mtu : NULL;",
      "4918:  return proc_dointvec_minmax(&lctl, write, buffer, lenp, ppos);",
      "4919: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "5054:    .data  = &ipv6_devconf.mtu6,",
      "5055:    .maxlen  = sizeof(int),",
      "5056:    .mode  = 0644,",
      "5058:   },",
      "5059:   {",
      "5060:    .procname = \"accept_ra\",",
      "",
      "[Removed Lines]",
      "5057:    .proc_handler = proc_dointvec,",
      "",
      "[Added Lines]",
      "5072:    .proc_handler = addrconf_sysctl_mtu,",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d6df198d924775e4751561cf60ef0294e95f74df",
      "candidate_info": {
        "commit_hash": "d6df198d924775e4751561cf60ef0294e95f74df",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d6df198d924775e4751561cf60ef0294e95f74df",
        "files": [
          "net/ipv6/addrconf.c"
        ],
        "message": "net: ipv6: restrict hop_limit sysctl setting to range [1; 255]\n\nSetting a value bigger than 255 resulted in using only the lower eight\nbits of that value as it is assigned to the u8 header field. To avoid\nthis unexpected result, reject such values.\n\nSetting a value of zero is technically possible, but hosts receiving\nsuch a packet have to treat it like hop_limit was set to one, according\nto RFC2460. Therefore I don't see a use-case for that.\n\nSetting a route's hop_limit to zero in iproute2 means to use the sysctl\ndefault, which is not the case here: Setting e.g.\nnet.conf.eth0.hop_limit=0 will not make the kernel use\nnet.conf.all.hop_limit for outgoing packets on eth0. To avoid these\nkinds of confusion, reject zero.\n\nSigned-off-by: Phil Sutter <phil@nwl.cc>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv6/addrconf.c||net/ipv6/addrconf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv6/addrconf.c||net/ipv6/addrconf.c"
          ],
          "candidate": [
            "net/ipv6/addrconf.c||net/ipv6/addrconf.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ipv6/addrconf.c||net/ipv6/addrconf.c": [
          "File: net/ipv6/addrconf.c -> net/ipv6/addrconf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5199:  return ret;",
          "5200: }",
          "5202: static",
          "5203: int addrconf_sysctl_mtu(struct ctl_table *ctl, int write,",
          "5204:    void __user *buffer, size_t *lenp, loff_t *ppos)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5202: static",
          "5203: int addrconf_sysctl_hop_limit(struct ctl_table *ctl, int write,",
          "5204:                               void __user *buffer, size_t *lenp, loff_t *ppos)",
          "5205: {",
          "5206:  struct ctl_table lctl;",
          "5207:  int min_hl = 1, max_hl = 255;",
          "5209:  lctl = *ctl;",
          "5210:  lctl.extra1 = &min_hl;",
          "5211:  lctl.extra2 = &max_hl;",
          "5213:  return proc_dointvec_minmax(&lctl, write, buffer, lenp, ppos);",
          "5214: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5454:    .data  = &ipv6_devconf.hop_limit,",
          "5455:    .maxlen  = sizeof(int),",
          "5456:    .mode  = 0644,",
          "5458:   },",
          "5459:   {",
          "5460:    .procname = \"mtu\",",
          "",
          "[Removed Lines]",
          "5457:    .proc_handler = proc_dointvec,",
          "",
          "[Added Lines]",
          "5471:    .proc_handler = addrconf_sysctl_hop_limit,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2020-6016",
  "cve_desc": "Valve's Game Networking Sockets prior to version v1.2.0 improperly handles unreliable segments with negative offsets in function SNP_ReceiveUnreliableSegment(), leading to a Heap-Based Buffer Underflow and a free() of memory not from the heap, resulting in a memory corruption and probably even a remote code execution.",
  "repo": "ValveSoftware/GameNetworkingSockets",
  "patch_hash": "e0c86dcb9139771db3db0cfdb1fb8bef0af19c43",
  "patch_info": {
    "commit_hash": "e0c86dcb9139771db3db0cfdb1fb8bef0af19c43",
    "repo": "ValveSoftware/GameNetworkingSockets",
    "commit_url": "https://github.com/ValveSoftware/GameNetworkingSockets/commit/e0c86dcb9139771db3db0cfdb1fb8bef0af19c43",
    "files": [
      "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp",
      "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h"
    ],
    "message": "Drop unreliable segments with weird offset/size.\n\nAnd be more deliberate about limits of unreliable message/segment sizes.",
    "before_after_code_files": [
      "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp",
      "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h"
    ]
  },
  "patch_diff": {
    "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp": [
      "File: src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp -> src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "234:  }",
      "238:  {",
      "239:   SpewWarningRateLimited( usecNow, \"Trying to send a very large (%d bytes) unreliable message.  Sending as reliable instead.\\n\", cbData );",
      "240:   pSendMessage->m_nFlags |= k_nSteamNetworkingSend_Reliable;",
      "",
      "[Removed Lines]",
      "237:  if ( cbData > k_cbMaxUnreliableMsgSize && !( pSendMessage->m_nFlags & k_nSteamNetworkingSend_Reliable )  )",
      "",
      "[Added Lines]",
      "237:  if ( cbData > k_cbMaxUnreliableMsgSizeSend && !( pSendMessage->m_nFlags & k_nSteamNetworkingSend_Reliable )  )",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "579:    READ_SEGMENT_DATA_SIZE( unreliable )",
      "585:   }",
      "586:   else if ( ( nFrameType & 0xe0 ) == 0x40 )",
      "587:   {",
      "",
      "[Removed Lines]",
      "580:    Assert( cbSegmentSize > 0 ); // !TEST! Bogus assert, zero byte messages are OK.  Remove after testing",
      "583:    bool bLastSegmentInMessage = ( nFrameType & 0x20 ) != 0;",
      "584:    SNP_ReceiveUnreliableSegment( nCurMsgNum, nOffset, pSegmentData, cbSegmentSize, bLastSegmentInMessage, usecNow );",
      "",
      "[Added Lines]",
      "583:    if ( (int64)nOffset + cbSegmentSize > k_cbMaxUnreliableMsgSizeRecv || cbSegmentSize > k_cbMaxUnreliableSegmentSizeRecv )",
      "584:    {",
      "587:     SpewWarningRateLimited( usecNow, \"[%s] Ignoring unreliable segment with invalid offset %u size %d\\n\",",
      "588:      GetDescription(), nOffset, cbSegmentSize );",
      "589:    }",
      "590:    else",
      "591:    {",
      "594:     bool bLastSegmentInMessage = ( nFrameType & 0x20 ) != 0;",
      "595:     SNP_ReceiveUnreliableSegment( nCurMsgNum, nOffset, pSegmentData, cbSegmentSize, bLastSegmentInMessage, usecNow );",
      "596:    }",
      "",
      "---------------"
    ],
    "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h": [
      "File: src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h -> src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "95: class CSteamNetworkConnectionBase;",
      "96: class CConnectionTransport;",
      "",
      "[Removed Lines]",
      "93: constexpr int k_cbMaxUnreliableMsgSize = 15*1100;",
      "",
      "[Added Lines]",
      "93: constexpr int k_cbMaxUnreliableMsgSizeSend = 15*1100;",
      "96: constexpr int k_cbMaxUnreliableSegmentSizeRecv = k_cbSteamNetworkingSocketsMaxPlaintextPayloadRecv;",
      "99: constexpr int k_cbMaxUnreliableMsgSizeRecv = k_nMaxBufferedUnreliableSegments*k_cbMaxUnreliableSegmentSizeRecv;",
      "100: COMPILE_TIME_ASSERT( k_cbMaxUnreliableMsgSizeRecv > k_cbMaxUnreliableMsgSizeSend + 4096 ); // Postel's law; confirm how much slack we have here",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "468: {",
      "469:  int m_cbSegSize = -1;",
      "470:  bool m_bLast = false;",
      "472: };",
      "474: struct SSNPPacketGap",
      "",
      "[Removed Lines]",
      "471:  char m_buf[ k_cbSteamNetworkingSocketsMaxPlaintextPayloadRecv ];",
      "",
      "[Added Lines]",
      "478:  char m_buf[ k_cbMaxUnreliableSegmentSizeRecv ];",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "dc2b2c444c7da85d2ff6b25ce06f2c296cfecc8a",
      "candidate_info": {
        "commit_hash": "dc2b2c444c7da85d2ff6b25ce06f2c296cfecc8a",
        "repo": "ValveSoftware/GameNetworkingSockets",
        "commit_url": "https://github.com/ValveSoftware/GameNetworkingSockets/commit/dc2b2c444c7da85d2ff6b25ce06f2c296cfecc8a",
        "files": [
          "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_connections.cpp",
          "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_connections.h",
          "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp",
          "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h"
        ],
        "message": "Use public message structure internally.\n\n- Get rid of SNPSendMessage_t, and just use CSteamNetworkingMessage for the send\nmessage queue.\n- Combined SteamNetworkingMessageQueue and SSNPSendMessageList.\n- I realized that reference counting would not work, so I deleted the reference\ncount.  We need to be able to be able to modify the message structure immediately,\nand so the original use case I had for reference counting didn't actually work.\n(I had imagined that you could send a message and keep a reference to the message,\nand then you could examine it.  But I realized this get complicated, and so I\nabandoned this approach, and instead will use a more explicit mechanism.)\n- Renamed some stuff since the purpose of those variables had changed.",
        "before_after_code_files": [
          "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_connections.cpp||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_connections.cpp",
          "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_connections.h||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_connections.h",
          "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp",
          "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp",
            "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h"
          ],
          "candidate": [
            "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp",
            "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h"
          ]
        }
      },
      "candidate_diff": {
        "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_connections.cpp||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_connections.cpp": [
          "File: src/steamnetworkingsockets/clientlib/steamnetworkingsockets_connections.cpp -> src/steamnetworkingsockets/clientlib/steamnetworkingsockets_connections.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "81: {",
          "82:  CSteamNetworkingMessage *pMsg = static_cast<CSteamNetworkingMessage *>( pIMsg );",
          "91:  if ( pMsg->m_pData && pMsg->m_pfnFreeData )",
          "92:   (*pMsg->m_pfnFreeData)( pMsg );",
          "",
          "[Removed Lines]",
          "85:  int nOldRefCount = pMsg->m_nRefCount.fetch_sub(1);",
          "86:  AssertMsg( nOldRefCount > 0, \"CSteamNetworkingMessage refcount bug or use-after-free!\" );",
          "87:  if ( nOldRefCount != 1 )",
          "88:   return;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "100:  Assert( !pMsg->m_linksSecondaryQueue.m_pQueue );",
          "101:  Assert( !pMsg->m_linksSecondaryQueue.m_pPrev );",
          "102:  Assert( !pMsg->m_linksSecondaryQueue.m_pNext );",
          "",
          "[Removed Lines]",
          "97:  Assert( !pMsg->m_linksSameConnection.m_pQueue );",
          "98:  Assert( !pMsg->m_linksSameConnection.m_pPrev );",
          "99:  Assert( !pMsg->m_linksSameConnection.m_pNext );",
          "",
          "[Added Lines]",
          "91:  Assert( !pMsg->m_links.m_pQueue );",
          "92:  Assert( !pMsg->m_links.m_pPrev );",
          "93:  Assert( !pMsg->m_links.m_pNext );",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "132:  pMsg->m_pfnRelease = ReleaseFunc;",
          "136:  return pMsg;",
          "137: }",
          "",
          "[Removed Lines]",
          "135:  pMsg->m_nRefCount = 1;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "230: void CSteamNetworkingMessage::Unlink()",
          "231: {",
          "234:  UnlinkFromQueue( &CSteamNetworkingMessage::m_linksSecondaryQueue );",
          "235: }",
          "237: void SteamNetworkingMessageQueue::PurgeMessages()",
          "238: {",
          "241:  {",
          "242:   CSteamNetworkingMessage *pMsg = m_pFirst;",
          "243:   pMsg->Unlink();",
          "",
          "[Removed Lines]",
          "233:  UnlinkFromQueue( &CSteamNetworkingMessage::m_linksSameConnection );",
          "240:  while ( !IsEmpty() )",
          "",
          "[Added Lines]",
          "225:  UnlinkFromQueue( &CSteamNetworkingMessage::m_links );",
          "232:  while ( !empty() )",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "250: {",
          "251:  int nMessagesReturned = 0;",
          "254:  {",
          "256:   CSteamNetworkingMessage *pMsg = m_pFirst;",
          "",
          "[Removed Lines]",
          "253:  while ( !IsEmpty() && nMessagesReturned < nMaxMessages )",
          "",
          "[Added Lines]",
          "245:  while ( !empty() && nMessagesReturned < nMaxMessages )",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "462: {",
          "463:  Assert( m_hConnectionSelf == k_HSteamNetConnection_Invalid );",
          "464:  Assert( m_eConnectionState == k_ESteamNetworkingConnectionState_Dead );",
          "466:  Assert( m_pParentListenSocket == nullptr );",
          "467:  Assert( m_pMessagesSession == nullptr );",
          "468: }",
          "",
          "[Removed Lines]",
          "465:  Assert( m_queueRecvMessages.IsEmpty() );",
          "",
          "[Added Lines]",
          "457:  Assert( m_queueRecvMessages.empty() );",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1338:  {",
          "1341:  }",
          "1342: }",
          "",
          "[Removed Lines]",
          "1337:  for ( CSteamNetworkingMessage *m = m_queueRecvMessages.m_pFirst ; m ; m = m->m_linksSameConnection.m_pNext )",
          "1339:   Assert( m->GetConnection() == m_hConnectionSelf );",
          "1340:   m->SetConnectionUserData( m_nUserData );",
          "",
          "[Added Lines]",
          "1329:  for ( CSteamNetworkingMessage *m = m_queueRecvMessages.m_pFirst ; m ; m = m->m_links.m_pNext )",
          "1331:   Assert( m->m_conn == m_hConnectionSelf );",
          "1332:   m->m_nConnUserData = m_nUserData;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1447:    return k_EResultNoConnection;",
          "1448:  }",
          "1452: }",
          "1455: {",
          "1459:  {",
          "1461:   return k_EResultInvalidParam;",
          "1462:  }",
          "1465:  SteamNetworkingMicroseconds usecNow = SteamNetworkingSockets_GetLocalTimestamp();",
          "1467: }",
          "",
          "[Removed Lines]",
          "1451:  return _APISendMessageToConnection( pData, cbData, nSendFlags );",
          "1454: EResult CSteamNetworkConnectionBase::_APISendMessageToConnection( const void *pData, uint32 cbData, int nSendFlags )",
          "1458:  if ( cbData > k_cbMaxSteamNetworkingSocketsMessageSizeSend )",
          "1460:   AssertMsg2( false, \"Message size %d is too big.  Max is %d\", cbData, k_cbMaxSteamNetworkingSocketsMessageSizeSend );",
          "1466:  return SNP_SendMessage( usecNow, pData, cbData, nSendFlags );",
          "",
          "[Added Lines]",
          "1443:  CSteamNetworkingMessage *pMsg = CSteamNetworkingMessage::New( cbData );",
          "1444:  if ( !pMsg )",
          "1445:   return k_EResultFail;",
          "1446:  pMsg->m_nFlags = nSendFlags;",
          "1449:  memcpy( pMsg->m_pData, pData, cbData );",
          "1452:  return _APISendMessageToConnection( pMsg );",
          "1455: EResult CSteamNetworkConnectionBase::_APISendMessageToConnection( CSteamNetworkingMessage *pMsg )",
          "1459:  if ( pMsg->m_cbSize > k_cbMaxSteamNetworkingSocketsMessageSizeSend )",
          "1461:   AssertMsg2( false, \"Message size %d is too big.  Max is %d\", pMsg->m_cbSize, k_cbMaxSteamNetworkingSocketsMessageSizeSend );",
          "1462:   pMsg->Release();",
          "1468:  return SNP_SendMessage( pMsg, usecNow );",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1903:  }",
          "1909:  if ( m_pParentListenSocket )",
          "",
          "[Removed Lines]",
          "1906:  pMsg->LinkToQueueTail( &CSteamNetworkingMessage::m_linksSameConnection, &m_queueRecvMessages );",
          "",
          "[Added Lines]",
          "1908:  pMsg->LinkToQueueTail( &CSteamNetworkingMessage::m_links, &m_queueRecvMessages );",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2599:  return k_EUnsignedCert_Allow;",
          "2600: }",
          "2603: {",
          "2604:  if ( !m_pPartner )",
          "2605:  {",
          "2607:   AssertMsg( false, \"No partner pipe?\" );",
          "2608:   return k_EResultFail;",
          "2609:  }",
          "2610:  SteamNetworkingMicroseconds usecNow = SteamNetworkingSockets_GetLocalTimestamp();",
          "2620:  return k_EResultOK;",
          "2621: }",
          "",
          "[Removed Lines]",
          "2602: EResult CSteamNetworkConnectionPipe::_APISendMessageToConnection( const void *pData, uint32 cbData, int nSendFlags )",
          "2613:  FakeSendStats( usecNow, cbData );",
          "2615:  int64 nMsgNum = ++m_senderState.m_nLastSentMsgNum;",
          "2618:  m_pPartner->ReceivedMessage( pData, cbData, nMsgNum, nSendFlags, usecNow );",
          "",
          "[Added Lines]",
          "2604: EResult CSteamNetworkConnectionPipe::_APISendMessageToConnection( CSteamNetworkingMessage *pMsg )",
          "2610:   pMsg->Release();",
          "2616:  FakeSendStats( usecNow, pMsg->m_cbSize );",
          "2622:  pMsg->m_nMessageNumber = ++m_senderState.m_nLastSentMsgNum;",
          "2623:  pMsg->m_conn = m_pPartner->m_hConnectionSelf;",
          "2624:  pMsg->m_identityPeer = m_pPartner->m_identityRemote;",
          "2625:  pMsg->m_nConnUserData = m_pPartner->m_nUserData;",
          "2626:  pMsg->m_usecTimeReceived = usecNow;",
          "2629:  m_pPartner->ReceivedMessage( pMsg );",
          "",
          "---------------"
        ],
        "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_connections.h||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_connections.h": [
          "File: src/steamnetworkingsockets/clientlib/steamnetworkingsockets_connections.h -> src/steamnetworkingsockets/clientlib/steamnetworkingsockets_connections.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: class CSteamNetworkConnectionBase;",
          "37: class CSharedSocket;",
          "38: class CConnectionTransport;",
          "40: struct SNPAckSerializerHelper;",
          "41: struct CertAuthScope;",
          "",
          "[Removed Lines]",
          "39: struct SteamNetworkingMessageQueue;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "136:  void CalcMaxEncryptedPayloadSize( size_t cbHdrReserve, CSteamNetworkConnectionBase *pConnection );",
          "137: };",
          "222: class ISteamNetworkingMessagesSession",
          "",
          "[Removed Lines]",
          "148: class CSteamNetworkingMessage : public SteamNetworkingMessage_t",
          "149: {",
          "150: public:",
          "151:  static CSteamNetworkingMessage *New( CSteamNetworkConnectionBase *pParent, uint32 cbSize, int64 nMsgNum, int nFlags, SteamNetworkingMicroseconds usecNow );",
          "152:  static CSteamNetworkingMessage *New( uint32 cbSize );",
          "153:  static void DefaultFreeData( SteamNetworkingMessage_t *pMsg );",
          "156:  void Unlink();",
          "158:  struct Links",
          "159:  {",
          "160:   SteamNetworkingMessageQueue *m_pQueue = nullptr;",
          "161:   CSteamNetworkingMessage *m_pPrev = nullptr;",
          "162:   CSteamNetworkingMessage *m_pNext = nullptr;",
          "163:  };",
          "166:  std::atomic<int> m_nRefCount;",
          "169:  Links m_linksSameConnection;",
          "172:  Links m_linksSecondaryQueue;",
          "175:  inline void SetConnection( HSteamNetConnection hConn ) { m_conn = hConn; }",
          "178:  inline void SetConnectionUserData( int64 nUserData )",
          "179:  {",
          "180:   m_nConnUserData = nUserData;",
          "181:  }",
          "184:  inline void SetChannel( int nChannel )",
          "185:  {",
          "186:   m_nChannel = nChannel;",
          "187:  }",
          "189:  void LinkToQueueTail( Links CSteamNetworkingMessage::*pMbrLinks, SteamNetworkingMessageQueue *pQueue );",
          "190:  void UnlinkFromQueue( Links CSteamNetworkingMessage::*pMbrLinks );",
          "192: private:",
          "193:  static void ReleaseFunc( SteamNetworkingMessage_t *pIMsg );",
          "194: };",
          "197: struct SteamNetworkingMessageQueue",
          "198: {",
          "199:  CSteamNetworkingMessage *m_pFirst = nullptr;",
          "200:  CSteamNetworkingMessage *m_pLast = nullptr;",
          "202:  inline bool IsEmpty() const",
          "203:  {",
          "204:   if ( m_pFirst )",
          "205:   {",
          "206:    Assert( m_pLast );",
          "207:    return false;",
          "208:   }",
          "209:   Assert( !m_pLast );",
          "210:   return true;",
          "211:  }",
          "214:  int RemoveMessages( SteamNetworkingMessage_t **ppOutMessages, int nMaxMessages );",
          "217:  void PurgeMessages();",
          "218: };",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "589:  bool ReceivedMessage( const void *pData, int cbData, int64 nMsgNum, int nFlags, SteamNetworkingMicroseconds usecNow );",
          "",
          "[Removed Lines]",
          "586:  virtual EResult _APISendMessageToConnection( const void *pData, uint32 cbData, int nSendFlags );",
          "",
          "[Added Lines]",
          "504:  virtual EResult _APISendMessageToConnection( CSteamNetworkingMessage *pMsg );",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "651:  void SNP_InitializeConnection( SteamNetworkingMicroseconds usecNow );",
          "652:  void SNP_ShutdownConnection();",
          "654:  SteamNetworkingMicroseconds SNP_ThinkSendState( SteamNetworkingMicroseconds usecNow );",
          "655:  SteamNetworkingMicroseconds SNP_GetNextThinkTime( SteamNetworkingMicroseconds usecNow );",
          "656:  SteamNetworkingMicroseconds SNP_TimeWhenWantToSendNextPacket() const;",
          "",
          "[Removed Lines]",
          "653:  EResult SNP_SendMessage( SteamNetworkingMicroseconds usecNow, const void *pData, int cbData, int nSendFlags );",
          "",
          "[Added Lines]",
          "571:  EResult SNP_SendMessage( CSteamNetworkingMessage *pSendMessage, SteamNetworkingMicroseconds usecNow );",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "796:  CSteamNetworkConnectionPipe *m_pPartner;",
          "800:  virtual void PostConnectionStateChangedCallback( ESteamNetworkingConnectionState eOldAPIState, ESteamNetworkingConnectionState eNewAPIState ) override;",
          "801:  virtual void InitConnectionCrypto( SteamNetworkingMicroseconds usecNow ) override;",
          "802:  virtual EUnsignedCert AllowRemoteUnsignedCert() override;",
          "",
          "[Removed Lines]",
          "799:  virtual EResult _APISendMessageToConnection( const void *pData, uint32 cbData, int nSendFlags ) override;",
          "",
          "[Added Lines]",
          "717:  virtual EResult _APISendMessageToConnection( CSteamNetworkingMessage *pMsg ) override;",
          "",
          "---------------"
        ],
        "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp": [
          "File: src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp -> src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "118:  float R = (double)rtt / k_nMillion;",
          "121:  return static_cast< int >( static_cast<float>( s ) /",
          "122:   ( R * sqrt( 2 * p / 3 ) + ( t_RTO * ( 3 * sqrt( 3 * p / 8 ) * p * ( 1 + 32 * ( p * p ) ) ) ) ) );",
          "",
          "[Removed Lines]",
          "119:  float t_RTO = MAX( 4 * R, 1.0f );",
          "",
          "[Added Lines]",
          "119:  float t_RTO = std::max( 4 * R, 1.0f );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "139: void SSNPSenderState::Shutdown()",
          "140: {",
          "143:  m_mapInFlightPacketsByPktNum.clear();",
          "144:  m_listInFlightReliableRange.clear();",
          "145:  m_cbPendingUnreliable = 0;",
          "",
          "[Removed Lines]",
          "141:  m_unackedReliableMessages.delete_all();",
          "142:  m_messagesQueued.delete_all();",
          "",
          "[Added Lines]",
          "141:  m_unackedReliableMessages.PurgeMessages();",
          "142:  m_messagesQueued.PurgeMessages();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "159:  while ( !m_unackedReliableMessages.empty() )",
          "160:  {",
          "167:   if ( !m_listInFlightReliableRange.empty() )",
          "168:   {",
          "169:    auto head = m_listInFlightReliableRange.begin();",
          "171:    if ( head->second == pMsg )",
          "172:    {",
          "173:     Assert( head->first.m_nBegin < nReliableEnd );",
          "",
          "[Removed Lines]",
          "161:   SNPSendMessage_t *pMsg = m_unackedReliableMessages.m_pFirst;",
          "162:   Assert( pMsg->m_nReliableStreamPos > 0 );",
          "163:   int64 nReliableEnd = pMsg->m_nReliableStreamPos + pMsg->m_cbSize;",
          "170:    Assert( head->first.m_nBegin >= pMsg->m_nReliableStreamPos );",
          "",
          "[Added Lines]",
          "161:   CSteamNetworkingMessage *pMsg = m_unackedReliableMessages.m_pFirst;",
          "162:   Assert( pMsg->SNPSend_ReliableStreamPos() > 0 );",
          "163:   int64 nReliableEnd = pMsg->SNPSend_ReliableStreamPos() + pMsg->m_cbSize;",
          "170:    Assert( head->first.m_nBegin >= pMsg->SNPSend_ReliableStreamPos() );",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "180:   if ( !m_listReadyRetryReliableRange.empty() )",
          "181:   {",
          "182:    auto head = m_listReadyRetryReliableRange.begin();",
          "184:    if ( head->second == pMsg )",
          "185:    {",
          "186:     Assert( head->first.m_nBegin < nReliableEnd );",
          "",
          "[Removed Lines]",
          "183:    Assert( head->first.m_nBegin >= pMsg->m_nReliableStreamPos );",
          "",
          "[Added Lines]",
          "183:    Assert( head->first.m_nBegin >= pMsg->SNPSend_ReliableStreamPos() );",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "193:   DbgVerify( m_unackedReliableMessages.pop_front() == pMsg );",
          "195:  }",
          "196: }",
          "",
          "[Removed Lines]",
          "194:   delete pMsg;",
          "",
          "[Added Lines]",
          "194:   pMsg->Release();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "261: }",
          "265: {",
          "268:  {",
          "269:   SpewWarning( \"Connection already has %u bytes pending, cannot queue any more messages\\n\", m_senderState.PendingBytesTotal() );",
          "270:   return k_EResultLimitExceeded;",
          "271:  }",
          "275:  {",
          "276:   SpewWarningRateLimited( usecNow, \"Trying to send a very large (%d bytes) unreliable message.  Sending as reliable instead.\\n\", cbData );",
          "278:  }",
          "281:  {",
          "",
          "[Removed Lines]",
          "264: EResult CSteamNetworkConnectionBase::SNP_SendMessage( SteamNetworkingMicroseconds usecNow, const void *pData, int cbData, int nSendFlags )",
          "267:  if ( m_senderState.PendingBytesTotal() + (int)cbData > m_connectionConfig.m_SendBufferSize.Get() )",
          "274:  if ( cbData > k_cbMaxUnreliableMsgSize && !( nSendFlags & k_nSteamNetworkingSend_Reliable )  )",
          "277:   nSendFlags |= k_nSteamNetworkingSend_Reliable;",
          "280:  if ( nSendFlags & k_nSteamNetworkingSend_NoDelay )",
          "",
          "[Added Lines]",
          "264: EResult CSteamNetworkConnectionBase::SNP_SendMessage( CSteamNetworkingMessage *pSendMessage, SteamNetworkingMicroseconds usecNow )",
          "266:  int cbData = (int)pSendMessage->m_cbSize;",
          "269:  if ( m_senderState.PendingBytesTotal() + cbData > m_connectionConfig.m_SendBufferSize.Get() )",
          "272:   pSendMessage->Release();",
          "277:  if ( cbData > k_cbMaxUnreliableMsgSize && !( pSendMessage->m_nFlags & k_nSteamNetworkingSend_Reliable )  )",
          "280:   pSendMessage->m_nFlags |= k_nSteamNetworkingSend_Reliable;",
          "283:  if ( pSendMessage->m_nFlags & k_nSteamNetworkingSend_NoDelay )",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "289:  SNP_ClampSendRate();",
          "290:  SNP_TokenBucket_Accumulate( usecNow );",
          "300:  {",
          "304:   byte hdr[ 32 ];",
          "305:   hdr[0] = 0;",
          "306:   byte *hdrEnd = hdr+1;",
          "308:   Assert( nMsgNumGap >= 1 );",
          "309:   if ( nMsgNumGap > 1 )",
          "310:   {",
          "",
          "[Removed Lines]",
          "293:  SNPSendMessage_t *pSendMessage = new SNPSendMessage_t();",
          "296:  pSendMessage->m_nMsgNum = ++m_senderState.m_nLastSentMsgNum;",
          "299:  if ( nSendFlags & k_nSteamNetworkingSend_Reliable )",
          "301:   pSendMessage->m_nReliableStreamPos = m_senderState.m_nReliableStreamPos;",
          "307:   int64 nMsgNumGap = pSendMessage->m_nMsgNum - m_senderState.m_nLastSendMsgNumReliable;",
          "",
          "[Added Lines]",
          "296:  pSendMessage->m_nMessageNumber = ++m_senderState.m_nLastSentMsgNum;",
          "299:  if ( pSendMessage->m_nFlags & k_nSteamNetworkingSend_Reliable )",
          "301:   pSendMessage->SNPSend_SetReliableStreamPos( m_senderState.m_nReliableStreamPos );",
          "302:   Assert( pSendMessage->SNPSend_IsReliable() );",
          "308:   int64 nMsgNumGap = pSendMessage->m_nMessageNumber - m_senderState.m_nLastSendMsgNumReliable;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "323:   int cbHdr = hdrEnd - hdr;",
          "332:   m_senderState.m_nReliableStreamPos += pSendMessage->m_cbSize;",
          "",
          "[Removed Lines]",
          "326:   pSendMessage->m_cbSize = cbHdr+cbData;",
          "327:   pSendMessage->m_pData = new uint8[ pSendMessage->m_cbSize ];",
          "328:   memcpy( pSendMessage->m_pData, hdr, cbHdr );",
          "329:   memcpy( pSendMessage->m_pData+cbHdr, pData, cbData );",
          "",
          "[Added Lines]",
          "328:   int cbNewSize = cbHdr+cbData;",
          "329:   void *pNewData = malloc( cbNewSize );",
          "330:   memcpy( pNewData, hdr, cbHdr );",
          "331:   memcpy( (char*)pNewData + cbHdr, pSendMessage->m_pData, cbData );",
          "333:   pSendMessage->m_cbSize = cbNewSize;",
          "334:   pSendMessage->m_pData = pNewData;",
          "335:   pSendMessage->m_pfnFreeData = CSteamNetworkingMessage::DefaultFreeData;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "341:  }",
          "342:  else",
          "343:  {",
          "352:   ++m_senderState.m_nMessagesSentUnreliable;",
          "353:   m_senderState.m_cbPendingUnreliable += pSendMessage->m_cbSize;",
          "",
          "[Removed Lines]",
          "340:   m_senderState.m_nLastSendMsgNumReliable = pSendMessage->m_nMsgNum;",
          "346:   pSendMessage->m_pData = new uint8[ cbData ];",
          "347:   pSendMessage->m_cbSize = cbData;",
          "348:   memcpy( pSendMessage->m_pData, pData, cbData );",
          "350:   pSendMessage->m_nReliableStreamPos = 0;",
          "",
          "[Added Lines]",
          "346:   m_senderState.m_nLastSendMsgNumReliable = pSendMessage->m_nMessageNumber;",
          "350:   pSendMessage->SNPSend_SetReliableStreamPos( 0 );",
          "351:   Assert( !pSendMessage->SNPSend_IsReliable() );",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "357:  m_senderState.m_messagesQueued.push_back( pSendMessage );",
          "358:  SpewType( m_connectionConfig.m_LogLevel_Message.Get(), \"[%s] SendMessage %s: MsgNum=%lld sz=%d\\n\",",
          "359:      GetDescription(),",
          "362:      pSendMessage->m_cbSize );",
          "370:   m_senderState.ClearNagleTimers();",
          "",
          "[Removed Lines]",
          "360:      ( nSendFlags & k_nSteamNetworkingSend_Reliable ) ? \"RELIABLE\" : \"UNRELIABLE\",",
          "361:      (long long)pSendMessage->m_nMsgNum,",
          "368:  pSendMessage->m_usecNagle = usecNow + m_connectionConfig.m_NagleTime.Get();",
          "369:  if ( nSendFlags & k_nSteamNetworkingSend_NoNagle )",
          "",
          "[Added Lines]",
          "361:      pSendMessage->SNPSend_IsReliable() ? \"RELIABLE\" : \"UNRELIABLE\",",
          "362:      (long long)pSendMessage->m_nMessageNumber,",
          "372:  pSendMessage->SNPSend_SetUsecNagle( usecNow + m_connectionConfig.m_NagleTime.Get() );",
          "373:  if ( pSendMessage->m_nFlags & k_nSteamNetworkingSend_NoNagle )",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "376:   SteamNetworkingMicroseconds usecNextThink = SNP_GetNextThinkTime( usecNow );",
          "380:   {",
          "381:    SpewVerbose( \"[%s] RATELIM QueueTime is %.1fms, SendRate=%.1fk, BytesQueued=%d\\n\",",
          "382:     GetDescription(),",
          "",
          "[Removed Lines]",
          "379:   if ( m_senderState.m_messagesQueued.m_pFirst->m_usecNagle == 0 && usecNextThink > usecNow )",
          "",
          "[Added Lines]",
          "383:   if ( m_senderState.m_messagesQueued.m_pFirst->SNPSend_UsecNagle() == 0 && usecNextThink > usecNow )",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "415:   return k_EResultOK;",
          "",
          "[Removed Lines]",
          "414:  if ( m_senderState.m_messagesQueued.m_pLast->m_usecNagle == 0 )",
          "",
          "[Added Lines]",
          "418:  if ( m_senderState.m_messagesQueued.m_pLast->SNPSend_UsecNagle() == 0 )",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1172:  static constexpr int k_cbMaxHdr = 16;",
          "1173:  uint8 m_hdr[ k_cbMaxHdr ];",
          "1174:  int m_cbHdr; // Doesn't include any size byte",
          "1177:  int m_nOffset;",
          "1180:  {",
          "1181:   Assert( nBegin < nEnd );",
          "",
          "[Removed Lines]",
          "1175:  SNPSendMessage_t *m_pMsg;",
          "1176:  int m_cbSize;",
          "1179:  inline void SetupReliable( SNPSendMessage_t *pMsg, int64 nBegin, int64 nEnd, int64 nLastReliableStreamPosEnd )",
          "",
          "[Added Lines]",
          "1179:  CSteamNetworkingMessage *m_pMsg;",
          "1180:  int m_cbSegSize;",
          "1183:  inline void SetupReliable( CSteamNetworkingMessage *pMsg, int64 nBegin, int64 nEnd, int64 nLastReliableStreamPosEnd )",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1229:   int cbSegData = nEnd - nBegin;",
          "1230:   Assert( cbSegData > 0 );",
          "1234:   m_pMsg = pMsg;",
          "1237:  }",
          "1240:  {",
          "",
          "[Removed Lines]",
          "1231:   Assert( nBegin >= pMsg->m_nReliableStreamPos );",
          "1232:   Assert( nEnd <= pMsg->m_nReliableStreamPos + pMsg->m_cbSize );",
          "1235:   m_nOffset = nBegin - pMsg->m_nReliableStreamPos;",
          "1236:   m_cbSize = cbSegData;",
          "1239:  inline void SetupUnreliable( SNPSendMessage_t *pMsg, int nOffset, int64 nLastMsgNum )",
          "",
          "[Added Lines]",
          "1235:   Assert( nBegin >= pMsg->SNPSend_ReliableStreamPos() );",
          "1236:   Assert( nEnd <= pMsg->SNPSend_ReliableStreamPos() + pMsg->m_cbSize );",
          "1239:   m_nOffset = nBegin - pMsg->SNPSend_ReliableStreamPos();",
          "1240:   m_cbSegSize = cbSegData;",
          "1243:  inline void SetupUnreliable( CSteamNetworkingMessage *pMsg, int nOffset, int64 nLastMsgNum )",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1254:    m_hdr[0] |= 0x10;",
          "1255:   }",
          "1256:   else",
          "1257:   {",
          "1261:    if ( nDelta == 1 )",
          "1262:    {",
          "",
          "[Removed Lines]",
          "1259:    Assert( pMsg->m_nMsgNum > nLastMsgNum );",
          "1260:    uint64 nDelta = pMsg->m_nMsgNum - nLastMsgNum;",
          "",
          "[Added Lines]",
          "1263:    Assert( pMsg->m_nMessageNumber > nLastMsgNum );",
          "1264:    uint64 nDelta = pMsg->m_nMessageNumber - nLastMsgNum;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1285:   Assert( cbSegData > 0 || ( cbSegData == 0 && pMsg->m_cbSize == 0 ) ); // We should only send zero-byte segments if the message itself is zero bytes.  (Which is legitimate!)",
          "1287:   m_pMsg = pMsg;",
          "1289:   m_nOffset = nOffset;",
          "1290:  }",
          "",
          "[Removed Lines]",
          "1288:   m_cbSize = cbSegData;",
          "",
          "[Added Lines]",
          "1292:   m_cbSegSize = cbSegData;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1426:   EncodedSegment &seg = *push_back_get_ptr( vecSegments );",
          "1427:   seg.SetupReliable( h->second, h->first.m_nBegin, h->first.m_nEnd, nLastReliableStreamPosEnd );",
          "1429:   if ( cbSegTotalWithoutSizeField > cbBytesRemainingForSegments )",
          "1430:   {",
          "",
          "[Removed Lines]",
          "1428:   int cbSegTotalWithoutSizeField = seg.m_cbHdr + seg.m_cbSize;",
          "",
          "[Added Lines]",
          "1432:   int cbSegTotalWithoutSizeField = seg.m_cbHdr + seg.m_cbSegSize;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1490:     m_senderState.m_cbCurrentSendMessageSent = 0;",
          "1491:     break;",
          "1492:    }",
          "1497:    EncodedSegment &seg = *push_back_get_ptr( vecSegments );",
          "1500:    bool bLastSegment = false;",
          "1502:    {",
          "1514:     if ( cbDesiredSegSize > m_cbMaxReliableMessageSegment )",
          "1515:     {",
          "1516:      cbDesiredSegSize = m_cbMaxReliableMessageSegment;",
          "",
          "[Removed Lines]",
          "1493:    SNPSendMessage_t *pSendMsg = m_senderState.m_messagesQueued.m_pFirst;",
          "1494:    Assert( m_senderState.m_cbCurrentSendMessageSent < pSendMsg->m_cbSize );",
          "1501:    if ( pSendMsg->m_nReliableStreamPos )",
          "1506:     int64 nBegin = pSendMsg->m_nReliableStreamPos + m_senderState.m_cbCurrentSendMessageSent;",
          "1513:     int cbDesiredSegSize = pSendMsg->m_cbSize - m_senderState.m_cbCurrentSendMessageSent;",
          "",
          "[Added Lines]",
          "1497:    CSteamNetworkingMessage *pSendMsg = m_senderState.m_messagesQueued.m_pFirst;",
          "1498:    Assert( m_senderState.m_cbCurrentSendMessageSent < pSendMsg->SNPSend_Size() );",
          "1505:    if ( pSendMsg->SNPSend_IsReliable() )",
          "1510:     int64 nBegin = pSendMsg->SNPSend_ReliableStreamPos() + m_senderState.m_cbCurrentSendMessageSent;",
          "1517:     int cbDesiredSegSize = pSendMsg->SNPSend_Size() - m_senderState.m_cbCurrentSendMessageSent;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1529:    }",
          "1533:    {",
          "",
          "[Removed Lines]",
          "1532:    if ( bLastSegment || seg.m_cbHdr + seg.m_cbSize > cbBytesRemainingForSegments )",
          "",
          "[Added Lines]",
          "1536:    if ( bLastSegment || seg.m_cbHdr + seg.m_cbSegSize > cbBytesRemainingForSegments )",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1542:     if ( seg.m_cbHdr + cbMinSegDataSizeToSend > cbBytesRemainingForSegments )",
          "1543:     {",
          "",
          "[Removed Lines]",
          "1541:     int cbMinSegDataSizeToSend = std::min( 16, seg.m_cbSize );",
          "",
          "[Added Lines]",
          "1545:     int cbMinSegDataSizeToSend = std::min( 16, seg.m_cbSegSize );",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1551:     #endif",
          "1558:     break;",
          "1559:    }",
          "1564:    m_senderState.m_cbCurrentSendMessageSent = 0;",
          "",
          "[Removed Lines]",
          "1554:     seg.m_cbSize = std::min( seg.m_cbSize, cbBytesRemainingForSegments - seg.m_cbHdr );",
          "1555:     m_senderState.m_cbCurrentSendMessageSent += seg.m_cbSize;",
          "1556:     Assert( m_senderState.m_cbCurrentSendMessageSent < pSendMsg->m_cbSize );",
          "1557:     cbBytesRemainingForSegments -= seg.m_cbHdr + seg.m_cbSize;",
          "1563:    Assert( m_senderState.m_cbCurrentSendMessageSent + seg.m_cbSize == pSendMsg->m_cbSize );",
          "",
          "[Added Lines]",
          "1558:     seg.m_cbSegSize = std::min( seg.m_cbSegSize, cbBytesRemainingForSegments - seg.m_cbHdr );",
          "1559:     m_senderState.m_cbCurrentSendMessageSent += seg.m_cbSegSize;",
          "1560:     Assert( m_senderState.m_cbCurrentSendMessageSent < pSendMsg->SNPSend_Size() );",
          "1561:     cbBytesRemainingForSegments -= seg.m_cbHdr + seg.m_cbSegSize;",
          "1567:    Assert( m_senderState.m_cbCurrentSendMessageSent + seg.m_cbSegSize == pSendMsg->SNPSend_Size() );",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1568:    m_senderState.m_messagesQueued.pop_front();",
          "",
          "[Removed Lines]",
          "1571:    cbBytesRemainingForSegments -= seg.m_cbHdr + seg.m_cbSize;",
          "",
          "[Added Lines]",
          "1575:    cbBytesRemainingForSegments -= seg.m_cbHdr + seg.m_cbSegSize;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1576:    cbBytesRemainingForSegments -= 1;",
          "1580:    {",
          "",
          "[Removed Lines]",
          "1579:    if ( pSendMsg->m_nReliableStreamPos > 0 )",
          "",
          "[Added Lines]",
          "1583:    if ( pSendMsg->SNPSend_IsReliable() )",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1588:    }",
          "1589:    else",
          "1590:    {",
          "1594:     seg.m_hdr[0] |= 0x20;",
          "",
          "[Removed Lines]",
          "1591:     nLastMsgNum = pSendMsg->m_nMsgNum;",
          "",
          "[Added Lines]",
          "1595:     nLastMsgNum = pSendMsg->m_nMessageNumber;",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1656:   if ( idx < nSegments-1 )",
          "1657:   {",
          "1660:    Assert( nUpper3Bits <= 4 ); // The values 5 and 6 are reserved and shouldn't be needed due to the MTU we support",
          "1661:    seg.m_hdr[0] |= nUpper3Bits;",
          "1665:   }",
          "1666:   else",
          "1667:   {",
          "",
          "[Removed Lines]",
          "1659:    int nUpper3Bits = ( seg.m_cbSize>>8 );",
          "1664:    seg.m_hdr[ seg.m_cbHdr++ ] = uint8( seg.m_cbSize );",
          "",
          "[Added Lines]",
          "1663:    int nUpper3Bits = ( seg.m_cbSegSize>>8 );",
          "1668:    seg.m_hdr[ seg.m_cbHdr++ ] = uint8( seg.m_cbSegSize );",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1676:   memcpy( pPayloadPtr, seg.m_hdr, seg.m_cbHdr ); pPayloadPtr += seg.m_cbHdr;",
          "1684:   {",
          "1690:    SNPRange_t range;",
          "",
          "[Removed Lines]",
          "1679:   Assert( pPayloadPtr+seg.m_cbSize <= pPayloadEnd );",
          "1680:   memcpy( pPayloadPtr, seg.m_pMsg->m_pData + seg.m_nOffset, seg.m_cbSize ); pPayloadPtr += seg.m_cbSize;",
          "1683:   if ( seg.m_pMsg->m_nReliableStreamPos > 0 )",
          "1687:    Assert( seg.m_cbSize > 0 );",
          "1691:    range.m_nBegin = seg.m_pMsg->m_nReliableStreamPos + seg.m_nOffset;",
          "1692:    range.m_nEnd = range.m_nBegin + seg.m_cbSize;",
          "",
          "[Added Lines]",
          "1683:   Assert( pPayloadPtr+seg.m_cbSegSize <= pPayloadEnd );",
          "1684:   memcpy( pPayloadPtr, (char*)seg.m_pMsg->m_pData + seg.m_nOffset, seg.m_cbSegSize ); pPayloadPtr += seg.m_cbSegSize;",
          "1687:   if ( seg.m_pMsg->SNPSend_IsReliable() )",
          "1691:    Assert( seg.m_cbSegSize > 0 );",
          "1695:    range.m_nBegin = seg.m_pMsg->SNPSend_ReliableStreamPos() + seg.m_nOffset;",
          "1696:    range.m_nEnd = range.m_nBegin + seg.m_cbSegSize;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1701:    SpewType( nLogLevelPacketDecode+1, \"[%s]   encode pkt %lld reliable msg %lld offset %d+%d=%d range [%lld,%lld)\\n\",",
          "1704:     (long long)range.m_nBegin, (long long)range.m_nEnd );",
          "",
          "[Removed Lines]",
          "1702:     GetDescription(), (long long)m_statsEndToEnd.m_nNextSendSequenceNumber, (long long)seg.m_pMsg->m_nMsgNum,",
          "1703:     seg.m_nOffset, seg.m_cbSize, seg.m_nOffset+seg.m_cbSize,",
          "",
          "[Added Lines]",
          "1706:     GetDescription(), (long long)m_statsEndToEnd.m_nNextSendSequenceNumber, (long long)seg.m_pMsg->m_nMessageNumber,",
          "1707:     seg.m_nOffset, seg.m_cbSegSize, seg.m_nOffset+seg.m_cbSegSize,",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1710:    inFlightPkt.m_vecReliableSegments.push_back( range );",
          "1714:    Assert( m_senderState.m_cbPendingReliable >= 0 );",
          "1715:   }",
          "1716:   else",
          "1717:   {",
          "1723:    Assert( bStillInQueue == ( ( seg.m_hdr[0] & 0x20 ) == 0 ) );",
          "1728:    SpewType( nLogLevelPacketDecode+1, \"[%s]   encode pkt %lld unreliable msg %lld offset %d+%d=%d\\n\",",
          "1734:    Assert( m_senderState.m_cbPendingUnreliable >= 0 );",
          "1737:    if ( !bStillInQueue )",
          "1739:   }",
          "1740:  }",
          "",
          "[Removed Lines]",
          "1713:    m_senderState.m_cbPendingReliable -= seg.m_cbSize;",
          "1719:    Assert( seg.m_cbSize > 0 || ( seg.m_cbSize == 0 && seg.m_pMsg->m_cbSize == 0 ) );",
          "1722:    Assert( bStillInQueue == ( seg.m_nOffset + seg.m_cbSize < seg.m_pMsg->m_cbSize ) ); // If we ended the message, we should have removed it from the queue",
          "1724:    Assert( bStillInQueue || seg.m_pMsg->m_pNext == nullptr ); // If not in the queue, we should be detached",
          "1725:    Assert( seg.m_pMsg->m_pPrev == nullptr ); // We should either be at the head of the queue, or detached",
          "1729:     GetDescription(), (long long)m_statsEndToEnd.m_nNextSendSequenceNumber, (long long)seg.m_pMsg->m_nMsgNum,",
          "1730:     seg.m_nOffset, seg.m_cbSize, seg.m_nOffset+seg.m_cbSize );",
          "1733:    m_senderState.m_cbPendingUnreliable -= seg.m_cbSize;",
          "1738:     delete seg.m_pMsg;",
          "",
          "[Added Lines]",
          "1717:    m_senderState.m_cbPendingReliable -= seg.m_cbSegSize;",
          "1723:    Assert( seg.m_cbSegSize > 0 || ( seg.m_cbSegSize == 0 && seg.m_pMsg->SNPSend_Size() == 0 ) );",
          "1726:    Assert( bStillInQueue == ( seg.m_nOffset + seg.m_cbSegSize < seg.m_pMsg->SNPSend_Size() ) ); // If we ended the message, we should have removed it from the queue",
          "1728:    Assert( bStillInQueue || seg.m_pMsg->m_links.m_pNext == nullptr ); // If not in the queue, we should be detached",
          "1729:    Assert( seg.m_pMsg->m_links.m_pPrev == nullptr ); // We should either be at the head of the queue, or detached",
          "1733:     GetDescription(), (long long)m_statsEndToEnd.m_nNextSendSequenceNumber, (long long)seg.m_pMsg->m_nMessageNumber,",
          "1734:     seg.m_nOffset, seg.m_cbSegSize, seg.m_nOffset+seg.m_cbSegSize );",
          "1737:    m_senderState.m_cbPendingUnreliable -= seg.m_cbSegSize;",
          "1742:     seg.m_pMsg->Release();",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "2269:  key.m_nMsgNum = nMsgNum;",
          "2270:  key.m_nOffset = nOffset;",
          "2271:  SSNPRecvUnreliableSegmentData &data = m_receiverState.m_mapUnreliableSegments[ key ];",
          "2273:  {",
          "2279:  }",
          "2282:  {",
          "",
          "[Removed Lines]",
          "2272:  if ( data.m_cbSize >= 0 )",
          "2278:   SpewMsg( \"Received unreliable msg %lld offset %d twice.  Sizes %d,%d\\n\", nMsgNum, nOffset, data.m_cbSize, cbSegmentSize );",
          "2281:  if ( data.m_cbSize >= cbSegmentSize )",
          "",
          "[Added Lines]",
          "2276:  if ( data.m_cbSegSize >= 0 )",
          "2282:   SpewMsg( \"Received unreliable msg %lld offset %d twice.  Sizes %d,%d\\n\", nMsgNum, nOffset, data.m_cbSegSize, cbSegmentSize );",
          "2285:  if ( data.m_cbSegSize >= cbSegmentSize )",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "2292:  Assert( !data.m_bLast ); // sender is doing weird stuff or we have a bug",
          "2293:  data.m_bLast = bLastSegmentInMessage;",
          "2294:  memcpy( data.m_buf, pSegmentData, cbSegmentSize );",
          "",
          "[Removed Lines]",
          "2291:  data.m_cbSize = cbSegmentSize;",
          "",
          "[Added Lines]",
          "2295:  data.m_cbSegSize = cbSegmentSize;",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "2314:   if ( itMsgLast->second.m_bLast )",
          "",
          "[Removed Lines]",
          "2311:   cbMessageSize = Max( cbMessageSize, itMsgLast->first.m_nOffset + itMsgLast->second.m_cbSize );",
          "",
          "[Added Lines]",
          "2315:   cbMessageSize = std::max( cbMessageSize, itMsgLast->first.m_nOffset + itMsgLast->second.m_cbSegSize );",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "2329:  for (;;)",
          "2330:  {",
          "2331:   Assert( itMsgStart->first.m_nMsgNum == nMsgNum );",
          "2335:   if ( itMsgStart->second.m_bLast )",
          "",
          "[Removed Lines]",
          "2332:   memcpy( (char *)pMsg->m_pData + itMsgStart->first.m_nOffset, itMsgStart->second.m_buf, itMsgStart->second.m_cbSize );",
          "",
          "[Added Lines]",
          "2336:   memcpy( (char *)pMsg->m_pData + itMsgStart->first.m_nOffset, itMsgStart->second.m_buf, itMsgStart->second.m_cbSegSize );",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "3158:  }",
          "",
          "[Removed Lines]",
          "3157:   usecNextSend = m_senderState.m_messagesQueued.m_pFirst->m_usecNagle;",
          "",
          "[Added Lines]",
          "3161:   usecNextSend = m_senderState.m_messagesQueued.m_pFirst->SNPSend_UsecNagle();",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "3276: {",
          "3277:  info.m_nBytesQueuedForSend = 0;",
          "3278:  info.m_nPacketsQueuedForSend = 0;",
          "3280:  {",
          "3281:   info.m_nBytesQueuedForSend += pMsg->m_cbSize;",
          "3282:   info.m_nPacketsQueuedForSend += 1;",
          "",
          "[Removed Lines]",
          "3279:  for ( SNPSendMessage_t *pMsg = m_senderState.m_messagesQueued.m_pFirst ; pMsg ; pMsg = pMsg->m_pNext )",
          "",
          "[Added Lines]",
          "3283:  for ( CSteamNetworkingMessage *pMsg = m_senderState.m_messagesQueued.m_pFirst ; pMsg ; pMsg = pMsg->m_links.m_pNext )",
          "",
          "---------------"
        ],
        "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h": [
          "File: src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h -> src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "12: namespace SteamNetworkingSocketsLib {",
          "14: class CSteamNetworkConnectionBase;",
          "17: const int k_nMaxPacketsPerThink = 16;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "15: struct SteamNetworkingMessageQueue;",
          "20: class CSteamNetworkingMessage : public SteamNetworkingMessage_t",
          "21: {",
          "22: public:",
          "23:  static CSteamNetworkingMessage *New( CSteamNetworkConnectionBase *pParent, uint32 cbSize, int64 nMsgNum, int nFlags, SteamNetworkingMicroseconds usecNow );",
          "24:  static CSteamNetworkingMessage *New( uint32 cbSize );",
          "25:  static void DefaultFreeData( SteamNetworkingMessage_t *pMsg );",
          "31:  inline SteamNetworkingMicroseconds SNPSend_UsecNagle() const { return m_usecTimeReceived; }",
          "32:  inline void SNPSend_SetUsecNagle( SteamNetworkingMicroseconds x ) { m_usecTimeReceived = x; }",
          "35:  inline int64 SNPSend_ReliableStreamPos() const { return m_nConnUserData; }",
          "36:  inline void SNPSend_SetReliableStreamPos( int64 x ) { m_nConnUserData = x; }",
          "38:  inline bool SNPSend_IsReliable() const",
          "39:  {",
          "40:   if ( m_nFlags & k_nSteamNetworkingSend_Reliable )",
          "41:   {",
          "42:    Assert( m_nConnUserData > 0 );",
          "43:    return true;",
          "44:   }",
          "45:   Assert( m_nConnUserData == 0 );",
          "46:   return false;",
          "47:  }",
          "49:  inline int SNPSend_Size() const { return m_cbSize; }",
          "52:  void Unlink();",
          "54:  struct Links",
          "55:  {",
          "56:   SteamNetworkingMessageQueue *m_pQueue;",
          "57:   CSteamNetworkingMessage *m_pPrev ;",
          "58:   CSteamNetworkingMessage *m_pNext;",
          "59:  };",
          "62:  Links m_links;",
          "66:  Links m_linksSecondaryQueue;",
          "68:  void LinkToQueueTail( Links CSteamNetworkingMessage::*pMbrLinks, SteamNetworkingMessageQueue *pQueue );",
          "69:  void UnlinkFromQueue( Links CSteamNetworkingMessage::*pMbrLinks );",
          "71: private:",
          "73:  inline CSteamNetworkingMessage() {}",
          "74:  inline ~CSteamNetworkingMessage() {}",
          "75:  static void ReleaseFunc( SteamNetworkingMessage_t *pIMsg );",
          "76: };",
          "79: struct SteamNetworkingMessageQueue",
          "80: {",
          "81:  CSteamNetworkingMessage *m_pFirst = nullptr;",
          "82:  CSteamNetworkingMessage *m_pLast = nullptr;",
          "84:  inline bool empty() const",
          "85:  {",
          "86:   if ( m_pFirst )",
          "87:   {",
          "88:    Assert( m_pLast );",
          "89:    return false;",
          "90:   }",
          "91:   Assert( !m_pLast );",
          "92:   return true;",
          "93:  }",
          "96:  int RemoveMessages( SteamNetworkingMessage_t **ppOutMessages, int nMaxMessages );",
          "99:  void PurgeMessages();",
          "100: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "68:  vstd::small_vector<SNPRange_t,1> m_vecReliableSegments;",
          "69: };",
          "106: {",
          "134:  {",
          "136:   if ( pResult )",
          "137:   {",
          "138:    Assert( m_pLast );",
          "141:    if ( m_pFirst )",
          "142:    {",
          "146:    }",
          "147:    else",
          "148:    {",
          "149:     Assert( m_pLast == pResult );",
          "150:     m_pLast = nullptr;",
          "151:    }",
          "153:   }",
          "154:   return pResult;",
          "155:  }",
          "159:  {",
          "160:   if ( m_pFirst == nullptr )",
          "161:   {",
          "",
          "[Removed Lines]",
          "72: struct SNPSendMessage_t",
          "73: {",
          "77:  ~SNPSendMessage_t()",
          "78:  {",
          "79:   delete [] m_pData;",
          "80:  }",
          "83:  int64 m_nMsgNum;",
          "86:  SNPSendMessage_t *m_pNext;",
          "87:  SNPSendMessage_t *m_pPrev;",
          "93:  SteamNetworkingMicroseconds m_usecNagle;",
          "98:  int m_cbSize;",
          "99:  byte *m_pData;",
          "102:  int64 m_nReliableStreamPos;",
          "103: };",
          "105: struct SSNPSendMessageList",
          "107:  SNPSendMessage_t *m_pFirst = nullptr;",
          "108:  SNPSendMessage_t *m_pLast = nullptr;",
          "111:  inline bool empty() const",
          "112:  {",
          "113:   if ( m_pFirst == nullptr )",
          "114:   {",
          "115:    Assert( m_pLast == nullptr );",
          "116:    return true;",
          "117:   }",
          "118:   Assert( m_pLast != nullptr );",
          "119:   return false;",
          "120:  }",
          "123:  void delete_all()",
          "124:  {",
          "125:   while ( m_pFirst )",
          "126:    delete pop_front();",
          "127:   Assert( m_pLast == nullptr );",
          "128:  }",
          "133:  SNPSendMessage_t *pop_front()",
          "135:   SNPSendMessage_t *pResult = m_pFirst;",
          "139:    Assert( pResult->m_pPrev == nullptr );",
          "140:    m_pFirst = pResult->m_pNext;",
          "143:     Assert( m_pFirst->m_pPrev == pResult );",
          "144:     Assert( m_pFirst->m_nMsgNum > pResult->m_nMsgNum );",
          "145:     m_pFirst->m_pPrev = nullptr;",
          "152:    pResult->m_pNext = nullptr;",
          "158:  void push_back( SNPSendMessage_t *pMsg )",
          "",
          "[Added Lines]",
          "157: struct SSNPSendMessageList : public SteamNetworkingMessageQueue",
          "163:  CSteamNetworkingMessage *pop_front()",
          "165:   CSteamNetworkingMessage *pResult = m_pFirst;",
          "169:    Assert( pResult->m_links.m_pQueue == this );",
          "170:    Assert( pResult->m_links.m_pPrev == nullptr );",
          "171:    m_pFirst = pResult->m_links.m_pNext;",
          "174:     Assert( m_pFirst->m_links.m_pPrev == pResult );",
          "175:     Assert( m_pFirst->m_nMessageNumber > pResult->m_nMessageNumber );",
          "176:     m_pFirst->m_links.m_pPrev = nullptr;",
          "183:    pResult->m_links.m_pQueue = nullptr;",
          "184:    pResult->m_links.m_pNext = nullptr;",
          "190:  void push_back( CSteamNetworkingMessage *pMsg )",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "165:   else",
          "166:   {",
          "171:   }",
          "174:   m_pLast = pMsg;",
          "175:  }",
          "",
          "[Removed Lines]",
          "168:    Assert( pMsg->m_nMsgNum > m_pLast->m_nMsgNum );",
          "169:    Assert( m_pLast->m_pNext == nullptr );",
          "170:    m_pLast->m_pNext = pMsg;",
          "172:   pMsg->m_pNext = nullptr;",
          "173:   pMsg->m_pPrev = m_pLast;",
          "",
          "[Added Lines]",
          "200:    Assert( pMsg->m_nMessageNumber > m_pLast->m_nMessageNumber );",
          "201:    Assert( m_pLast->m_links.m_pNext == nullptr );",
          "202:    m_pLast->m_links.m_pNext = pMsg;",
          "204:   pMsg->m_links.m_pQueue = this;",
          "205:   pMsg->m_links.m_pNext = nullptr;",
          "206:   pMsg->m_links.m_pPrev = m_pLast;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "234:  void ClearNagleTimers()",
          "235:  {",
          "238:   {",
          "241:   }",
          "242:  }",
          "",
          "[Removed Lines]",
          "236:   SNPSendMessage_t *pMsg = m_messagesQueued.m_pLast;",
          "237:   while ( pMsg && pMsg->m_usecNagle )",
          "239:    pMsg->m_usecNagle = 0;",
          "240:    pMsg = pMsg->m_pPrev;",
          "",
          "[Added Lines]",
          "269:   CSteamNetworkingMessage *pMsg = m_messagesQueued.m_pLast;",
          "270:   while ( pMsg && pMsg->SNPSend_UsecNagle() )",
          "272:    pMsg->SNPSend_SetUsecNagle( 0 );",
          "273:    pMsg = pMsg->m_links.m_pPrev;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "291:  std::map<SNPRange_t,SNPSendMessage_t*,SNPRange_t::NonOverlappingLess> m_listInFlightReliableRange;",
          "295:  std::map<SNPRange_t,SNPSendMessage_t*,SNPRange_t::NonOverlappingLess> m_listReadyRetryReliableRange;",
          "",
          "[Added Lines]",
          "324:  std::map<SNPRange_t,CSteamNetworkingMessage*,SNPRange_t::NonOverlappingLess> m_listInFlightReliableRange;",
          "328:  std::map<SNPRange_t,CSteamNetworkingMessage*,SNPRange_t::NonOverlappingLess> m_listReadyRetryReliableRange;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "318: struct SSNPRecvUnreliableSegmentData",
          "319: {",
          "321:  bool m_bLast = false;",
          "322:  char m_buf[ k_cbSteamNetworkingSocketsMaxPlaintextPayloadRecv ];",
          "323: };",
          "",
          "[Removed Lines]",
          "320:  int m_cbSize = -1;",
          "",
          "[Added Lines]",
          "353:  int m_cbSegSize = -1;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "559c64978656b94222a63ac6f5a2b3fa4c0aab94",
      "candidate_info": {
        "commit_hash": "559c64978656b94222a63ac6f5a2b3fa4c0aab94",
        "repo": "ValveSoftware/GameNetworkingSockets",
        "commit_url": "https://github.com/ValveSoftware/GameNetworkingSockets/commit/559c64978656b94222a63ac6f5a2b3fa4c0aab94",
        "files": [
          "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp",
          "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h"
        ],
        "message": "Move constants to header\n\nNo functional change here.  Intended to make the next change easier to parse.",
        "before_after_code_files": [
          "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp",
          "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp",
            "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h"
          ],
          "candidate": [
            "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp",
            "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h"
          ]
        }
      },
      "candidate_diff": {
        "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp": [
          "File: src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp -> src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: #include \"steamnetworkingsockets_connections.h\"",
          "5: #include \"crypto.h\"",
          "55: #include \"tier0/memdbgon.h\"",
          "",
          "[Removed Lines]",
          "8: constexpr int k_nAckDelayPrecisionShift = 5;",
          "9: constexpr SteamNetworkingMicroseconds k_usecAckDelayPrecision = (1 << k_nAckDelayPrecisionShift );",
          "24: constexpr SteamNetworkingMicroseconds k_usecNackFlush = 3*1000;",
          "27: constexpr int k_cbMaxMessageSizeRecv = k_cbMaxSteamNetworkingSocketsMessageSizeSend*2;",
          "32: constexpr int k_cbMaxBufferedReceiveReliableData = k_cbMaxMessageSizeRecv + 64*1024;",
          "33: constexpr int k_nMaxReliableStreamGaps_Extend = 30; // Discard reliable data past the end of the stream, if it would cause us to get too many gaps",
          "34: constexpr int k_nMaxReliableStreamGaps_Fragment = 20; // Discard reliable data that is filling in the middle of a hole, if it would cause the number of gaps to exceed this number",
          "35: constexpr int k_nMaxPacketGaps = 62; // Don't bother tracking more than N gaps.  Instead, we will end up NACKing some packets that we actually did receive.  This should not break the protocol, but it protects us from malicious sender",
          "47: constexpr int k_nMaxBufferedUnreliableSegments = 20;",
          "52: constexpr int k_cbMaxUnreliableMsgSize = 15*1100;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h||src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h": [
          "File: src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h -> src/steamnetworkingsockets/clientlib/steamnetworkingsockets_snp.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: namespace SteamNetworkingSocketsLib {",
          "48: class CSteamNetworkConnectionBase;",
          "49: class CConnectionTransport;",
          "50: struct SteamNetworkingMessageQueue;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "49: constexpr int k_nAckDelayPrecisionShift = 5;",
          "50: constexpr SteamNetworkingMicroseconds k_usecAckDelayPrecision = (1 << k_nAckDelayPrecisionShift );",
          "65: constexpr SteamNetworkingMicroseconds k_usecNackFlush = 3*1000;",
          "68: constexpr int k_cbMaxMessageSizeRecv = k_cbMaxSteamNetworkingSocketsMessageSizeSend*2;",
          "73: constexpr int k_cbMaxBufferedReceiveReliableData = k_cbMaxMessageSizeRecv + 64*1024;",
          "74: constexpr int k_nMaxReliableStreamGaps_Extend = 30; // Discard reliable data past the end of the stream, if it would cause us to get too many gaps",
          "75: constexpr int k_nMaxReliableStreamGaps_Fragment = 20; // Discard reliable data that is filling in the middle of a hole, if it would cause the number of gaps to exceed this number",
          "76: constexpr int k_nMaxPacketGaps = 62; // Don't bother tracking more than N gaps.  Instead, we will end up NACKing some packets that we actually did receive.  This should not break the protocol, but it protects us from malicious sender",
          "88: constexpr int k_nMaxBufferedUnreliableSegments = 20;",
          "93: constexpr int k_cbMaxUnreliableMsgSize = 15*1100;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-8787",
  "cve_desc": "The nf_nat_redirect_ipv4 function in net/netfilter/nf_nat_redirect.c in the Linux kernel before 4.4 allows remote attackers to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by sending certain IPv4 packets to an incompletely configured interface, a related issue to CVE-2003-1604.",
  "repo": "torvalds/linux",
  "patch_hash": "94f9cd81436c85d8c3a318ba92e236ede73752fc",
  "patch_info": {
    "commit_hash": "94f9cd81436c85d8c3a318ba92e236ede73752fc",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/94f9cd81436c85d8c3a318ba92e236ede73752fc",
    "files": [
      "net/netfilter/nf_nat_redirect.c"
    ],
    "message": "netfilter: nf_nat_redirect: add missing NULL pointer check\n\nCommit 8b13eddfdf04cbfa561725cfc42d6868fe896f56 (\"netfilter: refactor NAT\nredirect IPv4 to use it from nf_tables\") has introduced a trivial logic\nchange which can result in the following crash.\n\nBUG: unable to handle kernel NULL pointer dereference at 0000000000000030\nIP: [<ffffffffa033002d>] nf_nat_redirect_ipv4+0x2d/0xa0 [nf_nat_redirect]\nPGD 3ba662067 PUD 3ba661067 PMD 0\nOops: 0000 [#1] SMP\nModules linked in: ipv6(E) xt_REDIRECT(E) nf_nat_redirect(E) xt_tcpudp(E) iptable_nat(E) nf_conntrack_ipv4(E) nf_defrag_ipv4(E) nf_nat_ipv4(E) nf_nat(E) nf_conntrack(E) ip_tables(E) x_tables(E) binfmt_misc(E) xfs(E) libcrc32c(E) evbug(E) evdev(E) psmouse(E) i2c_piix4(E) i2c_core(E) acpi_cpufreq(E) button(E) ext4(E) crc16(E) jbd2(E) mbcache(E) dm_mirror(E) dm_region_hash(E) dm_log(E) dm_mod(E)\nCPU: 0 PID: 2536 Comm: ip Tainted: G            E   4.1.7-15.23.amzn1.x86_64 #1\nHardware name: Xen HVM domU, BIOS 4.2.amazon 05/06/2015\ntask: ffff8800eb438000 ti: ffff8803ba664000 task.ti: ffff8803ba664000\n[...]\nCall Trace:\n <IRQ>\n [<ffffffffa0334065>] redirect_tg4+0x15/0x20 [xt_REDIRECT]\n [<ffffffffa02e2e99>] ipt_do_table+0x2b9/0x5e1 [ip_tables]\n [<ffffffffa0328045>] iptable_nat_do_chain+0x25/0x30 [iptable_nat]\n [<ffffffffa031777d>] nf_nat_ipv4_fn+0x13d/0x1f0 [nf_nat_ipv4]\n [<ffffffffa0328020>] ? iptable_nat_ipv4_fn+0x20/0x20 [iptable_nat]\n [<ffffffffa031785e>] nf_nat_ipv4_in+0x2e/0x90 [nf_nat_ipv4]\n [<ffffffffa03280a5>] iptable_nat_ipv4_in+0x15/0x20 [iptable_nat]\n [<ffffffff81449137>] nf_iterate+0x57/0x80\n [<ffffffff814491f7>] nf_hook_slow+0x97/0x100\n [<ffffffff814504d4>] ip_rcv+0x314/0x400\n\nunsigned int\nnf_nat_redirect_ipv4(struct sk_buff *skb,\n...\n{\n...\n\t\trcu_read_lock();\n\t\tindev = __in_dev_get_rcu(skb->dev);\n\t\tif (indev != NULL) {\n\t\t\tifa = indev->ifa_list;\n\t\t\tnewdst = ifa->ifa_local; <---\n\t\t}\n\t\trcu_read_unlock();\n...\n}\n\nBefore the commit, 'ifa' had been always checked before access. After the\ncommit, however, it could be accessed even if it's NULL. Interestingly,\nthis was once fixed in 2003.\n\nhttp://marc.info/?l=netfilter-devel&m=106668497403047&w=2\n\nIn addition to the original one, we have seen the crash when packets that\nneed to be redirected somehow arrive on an interface which hasn't been\nyet fully configured.\n\nThis change just reverts the logic to the old behavior to avoid the crash.\n\nFixes: 8b13eddfdf04 (\"netfilter: refactor NAT redirect IPv4 to use it from nf_tables\")\nSigned-off-by: Munehisa Kamata <kamatam@amazon.com>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",
    "before_after_code_files": [
      "net/netfilter/nf_nat_redirect.c||net/netfilter/nf_nat_redirect.c"
    ]
  },
  "patch_diff": {
    "net/netfilter/nf_nat_redirect.c||net/netfilter/nf_nat_redirect.c": [
      "File: net/netfilter/nf_nat_redirect.c -> net/netfilter/nf_nat_redirect.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "56:   rcu_read_lock();",
      "57:   indev = __in_dev_get_rcu(skb->dev);",
      "59:    ifa = indev->ifa_list;",
      "60:    newdst = ifa->ifa_local;",
      "61:   }",
      "",
      "[Removed Lines]",
      "58:   if (indev != NULL) {",
      "",
      "[Added Lines]",
      "58:   if (indev && indev->ifa_list) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0a0e8b89389266bed9cc074c57ea662e4b9b2621",
      "candidate_info": {
        "commit_hash": "0a0e8b89389266bed9cc074c57ea662e4b9b2621",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0a0e8b89389266bed9cc074c57ea662e4b9b2621",
        "files": [
          "fs/btrfs/qgroup.c"
        ],
        "message": "btrfs: qgroup: Don't copy extent buffer to do qgroup rescan\n\nAncient qgroup code call memcpy() on a extent buffer and use it for leaf\niteration.\n\nAs extent buffer contains lock, pointers to pages, it's never sane to do\nsuch copy.\n\nThe following bug may be caused by this insane operation:\n[92098.841309] general protection fault: 0000 [#1] SMP\n[92098.841338] Modules linked in: ...\n[92098.841814] CPU: 1 PID: 24655 Comm: kworker/u4:12 Not tainted\n4.3.0-rc1 #1\n[92098.841868] Workqueue: btrfs-qgroup-rescan btrfs_qgroup_rescan_helper\n[btrfs]\n[92098.842261] Call Trace:\n[92098.842277]  [<ffffffffc035a5d8>] ? read_extent_buffer+0xb8/0x110\n[btrfs]\n[92098.842304]  [<ffffffffc0396d00>] ? btrfs_find_all_roots+0x60/0x70\n[btrfs]\n[92098.842329]  [<ffffffffc039af3d>]\nbtrfs_qgroup_rescan_worker+0x28d/0x5a0 [btrfs]\n\nWhere btrfs_qgroup_rescan_worker+0x28d is btrfs_disk_key_to_cpu(),\ncalled in reading key from the copied extent_buffer.\n\nThis patch will use btrfs_clone_extent_buffer() to a better copy of\nextent buffer to deal such case.\n\nReported-by: Stephane Lesimple <stephane_btrfs@lesimple.fr>\nSuggested-by: Filipe Manana <fdmanana@kernel.org>\nSigned-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>\nReviewed-by: Filipe Manana <fdmanana@suse.com>\nSigned-off-by: Chris Mason <clm@fb.com>",
        "before_after_code_files": [
          "fs/btrfs/qgroup.c||fs/btrfs/qgroup.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/btrfs/qgroup.c||fs/btrfs/qgroup.c": [
          "File: fs/btrfs/qgroup.c -> fs/btrfs/qgroup.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2193: static int",
          "2194: qgroup_rescan_leaf(struct btrfs_fs_info *fs_info, struct btrfs_path *path,",
          "2197: {",
          "2198:  struct btrfs_key found;",
          "2199:  struct ulist *roots = NULL;",
          "2200:  struct seq_list tree_mod_seq_elem = SEQ_LIST_INIT(tree_mod_seq_elem);",
          "2201:  u64 num_bytes;",
          "",
          "[Removed Lines]",
          "2195:      struct btrfs_trans_handle *trans,",
          "2196:      struct extent_buffer *scratch_leaf)",
          "",
          "[Added Lines]",
          "2195:      struct btrfs_trans_handle *trans)",
          "2198:  struct extent_buffer *scratch_leaf = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2233:  fs_info->qgroup_rescan_progress.objectid = found.objectid + 1;",
          "2235:  btrfs_get_tree_mod_seq(fs_info, &tree_mod_seq_elem);",
          "2237:  slot = path->slots[0];",
          "2238:  btrfs_release_path(path);",
          "2239:  mutex_unlock(&fs_info->qgroup_rescan_lock);",
          "",
          "[Removed Lines]",
          "2236:  memcpy(scratch_leaf, path->nodes[0], sizeof(*scratch_leaf));",
          "",
          "[Added Lines]",
          "2236:  scratch_leaf = btrfs_clone_extent_buffer(path->nodes[0]);",
          "2237:  if (!scratch_leaf) {",
          "2238:   ret = -ENOMEM;",
          "2239:   mutex_unlock(&fs_info->qgroup_rescan_lock);",
          "2240:   goto out;",
          "2241:  }",
          "2242:  extent_buffer_get(scratch_leaf);",
          "2243:  btrfs_tree_read_lock(scratch_leaf);",
          "2244:  btrfs_set_lock_blocking_rw(scratch_leaf, BTRFS_READ_LOCK);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2259:    goto out;",
          "2260:  }",
          "2261: out:",
          "2262:  btrfs_put_tree_mod_seq(fs_info, &tree_mod_seq_elem);",
          "2264:  return ret;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2270:  if (scratch_leaf) {",
          "2271:   btrfs_tree_read_unlock_blocking(scratch_leaf);",
          "2272:   free_extent_buffer(scratch_leaf);",
          "2273:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2270:            qgroup_rescan_work);",
          "2271:  struct btrfs_path *path;",
          "2272:  struct btrfs_trans_handle *trans = NULL;",
          "2274:  int err = -ENOMEM;",
          "2275:  int ret = 0;",
          "2277:  path = btrfs_alloc_path();",
          "2278:  if (!path)",
          "2279:   goto out;",
          "2284:  err = 0;",
          "2285:  while (!err) {",
          "",
          "[Removed Lines]",
          "2273:  struct extent_buffer *scratch_leaf = NULL;",
          "2280:  scratch_leaf = kmalloc(sizeof(*scratch_leaf), GFP_NOFS);",
          "2281:  if (!scratch_leaf)",
          "2282:   goto out;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2291:   if (!fs_info->quota_enabled) {",
          "2292:    err = -EINTR;",
          "2293:   } else {",
          "2296:   }",
          "2297:   if (err > 0)",
          "2298:    btrfs_commit_transaction(trans, fs_info->fs_root);",
          "",
          "[Removed Lines]",
          "2294:    err = qgroup_rescan_leaf(fs_info, path, trans,",
          "2295:        scratch_leaf);",
          "",
          "[Added Lines]",
          "2302:    err = qgroup_rescan_leaf(fs_info, path, trans);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2301:  }",
          "2303: out:",
          "2305:  btrfs_free_path(path);",
          "2307:  mutex_lock(&fs_info->qgroup_rescan_lock);",
          "",
          "[Removed Lines]",
          "2304:  kfree(scratch_leaf);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0b7c874348ea14ec3c358fe95e56d6f830540248",
      "candidate_info": {
        "commit_hash": "0b7c874348ea14ec3c358fe95e56d6f830540248",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0b7c874348ea14ec3c358fe95e56d6f830540248",
        "files": [
          "drivers/net/ethernet/nvidia/forcedeth.c"
        ],
        "message": "forcedeth: fix unilateral interrupt disabling in netpoll path\n\nForcedeth currently uses disable_irq_lockdep and enable_irq_lockdep, which in\nsome configurations simply calls local_irq_disable.  This causes errant warnings\nin the netpoll path as in netpoll_send_skb_on_dev, where we disable irqs using\nlocal_irq_save, leading to the following warning:\n\nWARNING: at net/core/netpoll.c:352 netpoll_send_skb_on_dev+0x243/0x250() (Not\ntainted)\nHardware name:\nnetpoll_send_skb_on_dev(): eth0 enabled interrupts in poll\n(nv_start_xmit_optimized+0x0/0x860 [forcedeth])\nModules linked in: netconsole(+) configfs ipv6 iptable_filter ip_tables ppdev\nparport_pc parport sg microcode serio_raw edac_core edac_mce_amd k8temp\nsnd_hda_codec_realtek snd_hda_codec_generic forcedeth snd_hda_intel\nsnd_hda_codec snd_hwdep snd_seq snd_seq_device snd_pcm snd_timer snd soundcore\nsnd_page_alloc i2c_nforce2 i2c_core shpchp ext4 jbd2 mbcache sr_mod cdrom sd_mod\ncrc_t10dif pata_amd ata_generic pata_acpi sata_nv dm_mirror dm_region_hash\ndm_log dm_mod [last unloaded: scsi_wait_scan]\nPid: 1940, comm: modprobe Not tainted 2.6.32-573.7.1.el6.x86_64.debug #1\nCall Trace:\n [<ffffffff8107bbc1>] ? warn_slowpath_common+0x91/0xe0\n [<ffffffff8107bcc6>] ? warn_slowpath_fmt+0x46/0x60\n [<ffffffffa00fe5b0>] ? nv_start_xmit_optimized+0x0/0x860 [forcedeth]\n [<ffffffff814b3593>] ? netpoll_send_skb_on_dev+0x243/0x250\n [<ffffffff814b37c9>] ? netpoll_send_udp+0x229/0x270\n [<ffffffffa02e3299>] ? write_msg+0x39/0x110 [netconsole]\n [<ffffffffa02e331b>] ? write_msg+0xbb/0x110 [netconsole]\n [<ffffffff8107bd55>] ? __call_console_drivers+0x75/0x90\n [<ffffffff8107bdba>] ? _call_console_drivers+0x4a/0x80\n [<ffffffff8107c445>] ? release_console_sem+0xe5/0x250\n [<ffffffff8107d200>] ? register_console+0x190/0x3e0\n [<ffffffffa02e71a6>] ? init_netconsole+0x1a6/0x216 [netconsole]\n [<ffffffffa02e7000>] ? init_netconsole+0x0/0x216 [netconsole]\n [<ffffffff810020d0>] ? do_one_initcall+0xc0/0x280\n [<ffffffff810d4933>] ? sys_init_module+0xe3/0x260\n [<ffffffff8100b0d2>] ? system_call_fastpath+0x16/0x1b\n---[ end trace f349c7af88e6a6d5 ]---\nconsole [netcon0] enabled\nnetconsole: network logging started\n\nFix it by modifying the forcedeth code to use\ndisable_irq_nosync_lockdep_irqsavedisable_irq_nosync_lockdep_irqsave instead,\nwhich saves and restores irq state properly.  This also saves us a little code\nin the process\n\nTested by the reporter, with successful restuls\n\nPatch applies to the head of the net tree\n\nSigned-off-by: Neil Horman <nhorman@tuxdriver.com>\nCC: \"David S. Miller\" <davem@davemloft.net>\nReported-by: Vasily Averin <vvs@sw.ru>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/ethernet/nvidiforcedeth.c||drivers/net/ethernet/nvidia/forcedeth.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/ethernet/nvidiforcedeth.c||drivers/net/ethernet/nvidia/forcedeth.c": [
          "File: drivers/net/ethernet/nvidiforcedeth.c -> drivers/net/ethernet/nvidia/forcedeth.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4079:  unsigned long flags;",
          "4080:  unsigned int irq = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4090:    irq = np->msi_x_entry[NV_MSI_X_VECTOR_ALL].vector;",
          "4092:    irq = np->pci_dev->irq;",
          "4096:    irq = np->msi_x_entry[NV_MSI_X_VECTOR_RX].vector;",
          "4100:    irq = np->msi_x_entry[NV_MSI_X_VECTOR_TX].vector;",
          "4104:    irq = np->msi_x_entry[NV_MSI_X_VECTOR_OTHER].vector;",
          "4109:  disable_irq_nosync_lockdep_irqsave(irq, &flags);",
          "4110:  synchronize_irq(irq);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4178:  enable_irq_lockdep_irqrestore(irq, &flags);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1da5537eccd865b83fedbbb7ea704669f6d255fd",
      "candidate_info": {
        "commit_hash": "1da5537eccd865b83fedbbb7ea704669f6d255fd",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1da5537eccd865b83fedbbb7ea704669f6d255fd",
        "files": [
          "net/bluetooth/sco.c"
        ],
        "message": "Bluetooth: Fix locking issue during fast SCO reconnection.\n\nWhen SCO connection is requested and disconnected fast, there is a change\nthat sco_sock_shutdown is going to preempt thread started in sco_connect_cfm.\nWhen this happens struct sock sk may be removed but a pointer to it is still\nheld in sco_conn_ready, where embedded spinlock is used. If it is used, but\nstruct sock has been removed, it will crash.\n\nBlock connection object, which will prevent struct sock from being removed\nand give connection process chance to finish.\n\nBUG: spinlock bad magic on CPU#0, kworker/u:2H/319\n lock: 0xe3e99434, .magic: f3000000, .owner: (\ufffd\ufffd\ufffd/0, .owner_cpu: -203804160\nPid: 319, comm: kworker/u:2H Tainted: G           O 3.8.0-115.1-plk-adaptation-byt-ivi-brd #1\nCall Trace:\n [<c1155659>] ? do_raw_spin_lock+0x19/0xe9\n [<fb75354f>] ? sco_connect_cfm+0x92/0x236 [bluetooth]\n [<fb731dbc>] ? hci_sync_conn_complete_evt.clone.101+0x18b/0x1cb [bluetooth]\n [<fb734ee7>] ? hci_event_packet+0x1acd/0x21a6 [bluetooth]\n [<c1041095>] ? finish_task_switch+0x50/0x89\n [<c1349a2e>] ? __schedule+0x638/0x6b8\n [<fb727918>] ? hci_rx_work+0xb9/0x2b8 [bluetooth]\n [<c103760a>] ? queue_delayed_work_on+0x21/0x2a\n [<c1035df9>] ? process_one_work+0x157/0x21b\n [<fb72785f>] ? hci_cmd_work+0xef/0xef [bluetooth]\n [<c1036217>] ? worker_thread+0x16e/0x20a\n [<c10360a9>] ? manage_workers+0x1cf/0x1cf\n [<c103a0ef>] ? kthread+0x8d/0x92\n [<c134adf7>] ? ret_from_kernel_thread+0x1b/0x28\n [<c103a062>] ? __init_kthread_worker+0x24/0x24\nBUG: unable to handle kernel NULL pointer dereference at   (null)\nIP: [<  (null)>]   (null)\n*pdpt = 00000000244e1001 *pde = 0000000000000000\nOops: 0010 [#1] PREEMPT SMP\nModules linked in: evdev ecb rfcomm(O) libcomposite usb2380 udc_core bnep(O) btusb(O) btbcm(O) cdc_acm btintel(O) bluetooth(O) arc4 uinput hid_multitouch usbhid hid iwlmvm(O)e\nPid: 319, comm: kworker/u:2H Tainted: G           O 3.8.0-115.1-plk-adaptation-byt-ivi-brd #1\nEIP: 0060:[<00000000>] EFLAGS: 00010246 CPU: 0\nEIP is at 0x0\nEAX: e3e99400 EBX: e3e99400 ECX: 00000100 EDX: 00000000\nESI: e3e99434 EDI: fb763ce0 EBP: e49b9e44 ESP: e49b9e14\n DS: 007b ES: 007b FS: 00d8 GS: 0000 SS: 0068\nCR0: 8005003b CR2: 00000000 CR3: 24444000 CR4: 001007f0\nDR0: 00000000 DR1: 00000000 DR2: 00000000 DR3: 00000000\nDR6: ffff0ff0 DR7: 00000400\nProcess kworker/u:2H (pid: 319, ti=e49b8000 task=e4ab9030 task.ti=e49b8000)\nStack:\n fb75355b 00000246 fb763900 22222222 22222222 22222222 e3f94460 e3ca7c0a\n e49b9e4c e3f34c00 e3ca7c0a fb763ce0 e49b9e6c fb731dbc 02000246 e4cec85c\n e4cec008 00000000 e3f34c00 e4cec000 e3c2ce00 0000002c e49b9ed0 fb734ee7\nCall Trace:\n [<fb75355b>] ? sco_connect_cfm+0x9e/0x236 [bluetooth]\n [<fb731dbc>] ? hci_sync_conn_complete_evt.clone.101+0x18b/0x1cb [bluetooth]\n [<fb734ee7>] ? hci_event_packet+0x1acd/0x21a6 [bluetooth]\n [<c1041095>] ? finish_task_switch+0x50/0x89\n [<c1349a2e>] ? __schedule+0x638/0x6b8\n [<fb727918>] ? hci_rx_work+0xb9/0x2b8 [bluetooth]\n [<c103760a>] ? queue_delayed_work_on+0x21/0x2a\n [<c1035df9>] ? process_one_work+0x157/0x21b\n [<fb72785f>] ? hci_cmd_work+0xef/0xef [bluetooth]\n [<c1036217>] ? worker_thread+0x16e/0x20a\n [<c10360a9>] ? manage_workers+0x1cf/0x1cf\n [<c103a0ef>] ? kthread+0x8d/0x92\n [<c134adf7>] ? ret_from_kernel_thread+0x1b/0x28\n [<c103a062>] ? __init_kthread_worker+0x24/0x24\nCode:  Bad EIP value.\nEIP: [<00000000>] 0x0 SS:ESP 0068:e49b9e14\nCR2: 0000000000000000\n---[ end trace 942a6577c0abd725 ]---\n\nSigned-off-by: Kuba Pawlak <kubax.t.pawlak@intel.com>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>",
        "before_after_code_files": [
          "net/bluetooth/sco.c||net/bluetooth/sco.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/bluetooth/sco.c||net/bluetooth/sco.c": [
          "File: net/bluetooth/sco.c -> net/bluetooth/sco.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "965:  if (!sk)",
          "966:   return 0;",
          "968:  lock_sock(sk);",
          "969:  if (!sk->sk_shutdown) {",
          "970:   sk->sk_shutdown = SHUTDOWN_MASK;",
          "971:   sco_sock_clear_timer(sk);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "968:  sock_hold(sk);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "976:    err = bt_sock_wait_state(sk, BT_CLOSED,",
          "977:        sk->sk_lingertime);",
          "978:  }",
          "979:  release_sock(sk);",
          "980:  return err;",
          "981: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "983:  sock_put(sk);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fe326c5cc07cd265abad29c35c142cfae09889e4",
      "candidate_info": {
        "commit_hash": "fe326c5cc07cd265abad29c35c142cfae09889e4",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/fe326c5cc07cd265abad29c35c142cfae09889e4",
        "files": [
          "drivers/clocksource/sh_mtu2.c"
        ],
        "message": "clocksource/drivers/sh_mtu2: Fix multiple shutdown call issue\n\nOn the r7s72100 Genmai board the MTU2 driver currently triggers a common\nclock framework WARN_ON(enable_count) when disabling the clock due to\nthe MTU2 driver after recent callback rework may call ->set_state_shutdown()\nmultiple times. A similar issue was spotted for the TMU driver and fixed in:\n452b132 clocksource/drivers/sh_tmu: Fix traceback spotted in -next\n\nOn r7s72100 Genmai v4.3-rc7 built with shmobile_defconfig spits out the\nfollowing during boot:\n\nsh_mtu2 fcff0000.timer: ch0: used for clock events\n------------[ cut here ]------------\nWARNING: CPU: 0 PID: 1 at drivers/clk/clk.c:675 clk_core_disable+0x2c/0x6c()\nCPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.3.0-rc7 #1\nHardware name: Generic R7S72100 (Flattened Device Tree)\nBacktrace:\n[<c00133d4>] (dump_backtrace) from [<c0013570>] (show_stack+0x18/0x1c)\n[<c0013558>] (show_stack) from [<c01c7aac>] (dump_stack+0x74/0x90)\n[<c01c7a38>] (dump_stack) from [<c00272fc>] (warn_slowpath_common+0x88/0xb4)\n[<c0027274>] (warn_slowpath_common) from [<c0027400>] (warn_slowpath_null+0x24/0x2c)\n[<c00273dc>] (warn_slowpath_null) from [<c03a9320>] (clk_core_disable+0x2c/0x6c)\n[<c03a92f4>] (clk_core_disable) from [<c03aa0a0>] (clk_disable+0x40/0x4c)\n[<c03aa060>] (clk_disable) from [<c0395d2c>] (sh_mtu2_disable+0x24/0x50)\n[<c0395d08>] (sh_mtu2_disable) from [<c0395d6c>] (sh_mtu2_clock_event_shutdown+0x14/0x1c)\n[<c0395d58>] (sh_mtu2_clock_event_shutdown) from [<c007d7d0>] (clockevents_switch_state+0xc8/0x114)\n[<c007d708>] (clockevents_switch_state) from [<c007d834>] (clockevents_shutdown+0x18/0x28)\n[<c007d81c>] (clockevents_shutdown) from [<c007dd58>] (clockevents_exchange_device+0x70/0x78)\n[<c007dce8>] (clockevents_exchange_device) from [<c007e578>] (tick_check_new_device+0x88/0xe0)\n[<c007e4f0>] (tick_check_new_device) from [<c007daf0>] (clockevents_register_device+0xac/0x120)\n[<c007da44>] (clockevents_register_device) from [<c0395be8>] (sh_mtu2_probe+0x230/0x350)\n[<c03959b8>] (sh_mtu2_probe) from [<c028b6f0>] (platform_drv_probe+0x50/0x98)\n\nReported-by: Chris Brandt <chris.brandt@renesas.com>\nFixes: 19a9ffb (\"clockevents/drivers/sh_mtu2: Migrate to new 'set-state' interface\")\nCc: Viresh Kumar <viresh.kumar@linaro.org>\nCc: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>\nSigned-off-by: Magnus Damm <damm+renesas@opensource.se>\nSigned-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>\nReviewed-by: Viresh Kumar <viresh.kumar@linaro.org>",
        "before_after_code_files": [
          "drivers/clocksource/sh_mtu2.c||drivers/clocksource/sh_mtu2.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/clocksource/sh_mtu2.c||drivers/clocksource/sh_mtu2.c": [
          "File: drivers/clocksource/sh_mtu2.c -> drivers/clocksource/sh_mtu2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "280: {",
          "281:  struct sh_mtu2_channel *ch = ced_to_sh_mtu2(ced);",
          "284:  return 0;",
          "285: }",
          "",
          "[Removed Lines]",
          "283:  sh_mtu2_disable(ch);",
          "",
          "[Added Lines]",
          "283:  if (clockevent_state_periodic(ced))",
          "284:   sh_mtu2_disable(ch);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2c3cf7d5f6105bb957df125dfce61d4483b8742d",
      "candidate_info": {
        "commit_hash": "2c3cf7d5f6105bb957df125dfce61d4483b8742d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2c3cf7d5f6105bb957df125dfce61d4483b8742d",
        "files": [
          "fs/btrfs/delayed-ref.c",
          "fs/btrfs/extent-tree.c"
        ],
        "message": "Btrfs: fix regression when running delayed references\n\nIn the kernel 4.2 merge window we had a refactoring/rework of the delayed\nreferences implementation in order to fix certain problems with qgroups.\nHowever that rework introduced one more regression that leads to the\nfollowing trace when running delayed references for metadata:\n\n[35908.064664] kernel BUG at fs/btrfs/extent-tree.c:1832!\n[35908.065201] invalid opcode: 0000 [#1] PREEMPT SMP DEBUG_PAGEALLOC\n[35908.065201] Modules linked in: dm_flakey dm_mod btrfs crc32c_generic xor raid6_pq nfsd auth_rpcgss oid_registry nfs_acl nfs lockd grace fscache sunrpc loop fuse parport_pc psmouse i2\n[35908.065201] CPU: 14 PID: 15014 Comm: kworker/u32:9 Tainted: G        W       4.3.0-rc5-btrfs-next-17+ #1\n[35908.065201] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.8.1-0-g4adadbd-20150316_085822-nilsson.home.kraxel.org 04/01/2014\n[35908.065201] Workqueue: btrfs-extent-refs btrfs_extent_refs_helper [btrfs]\n[35908.065201] task: ffff880114b7d780 ti: ffff88010c4c8000 task.ti: ffff88010c4c8000\n[35908.065201] RIP: 0010:[<ffffffffa04928b5>]  [<ffffffffa04928b5>] insert_inline_extent_backref+0x52/0xb1 [btrfs]\n[35908.065201] RSP: 0018:ffff88010c4cbb08  EFLAGS: 00010293\n[35908.065201] RAX: 0000000000000000 RBX: ffff88008a661000 RCX: 0000000000000000\n[35908.065201] RDX: ffffffffa04dd58f RSI: 0000000000000001 RDI: 0000000000000000\n[35908.065201] RBP: ffff88010c4cbb40 R08: 0000000000001000 R09: ffff88010c4cb9f8\n[35908.065201] R10: 0000000000000000 R11: 000000000000002c R12: 0000000000000000\n[35908.065201] R13: ffff88020a74c578 R14: 0000000000000000 R15: 0000000000000000\n[35908.065201] FS:  0000000000000000(0000) GS:ffff88023edc0000(0000) knlGS:0000000000000000\n[35908.065201] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\n[35908.065201] CR2: 00000000015e8708 CR3: 0000000102185000 CR4: 00000000000006e0\n[35908.065201] Stack:\n[35908.065201]  ffff88010c4cbb18 0000000000000f37 ffff88020a74c578 ffff88015a408000\n[35908.065201]  ffff880154a44000 0000000000000000 0000000000000005 ffff88010c4cbbd8\n[35908.065201]  ffffffffa0492b9a 0000000000000005 0000000000000000 0000000000000000\n[35908.065201] Call Trace:\n[35908.065201]  [<ffffffffa0492b9a>] __btrfs_inc_extent_ref+0x8b/0x208 [btrfs]\n[35908.065201]  [<ffffffffa0497117>] ? __btrfs_run_delayed_refs+0x4d4/0xd33 [btrfs]\n[35908.065201]  [<ffffffffa049773d>] __btrfs_run_delayed_refs+0xafa/0xd33 [btrfs]\n[35908.065201]  [<ffffffffa04a976a>] ? join_transaction.isra.10+0x25/0x41f [btrfs]\n[35908.065201]  [<ffffffffa04a97ed>] ? join_transaction.isra.10+0xa8/0x41f [btrfs]\n[35908.065201]  [<ffffffffa049914d>] btrfs_run_delayed_refs+0x75/0x1dd [btrfs]\n[35908.065201]  [<ffffffffa04992f1>] delayed_ref_async_start+0x3c/0x7b [btrfs]\n[35908.065201]  [<ffffffffa04d4b4f>] normal_work_helper+0x14c/0x32a [btrfs]\n[35908.065201]  [<ffffffffa04d4e93>] btrfs_extent_refs_helper+0x12/0x14 [btrfs]\n[35908.065201]  [<ffffffff81063b23>] process_one_work+0x24a/0x4ac\n[35908.065201]  [<ffffffff81064285>] worker_thread+0x206/0x2c2\n[35908.065201]  [<ffffffff8106407f>] ? rescuer_thread+0x2cb/0x2cb\n[35908.065201]  [<ffffffff8106407f>] ? rescuer_thread+0x2cb/0x2cb\n[35908.065201]  [<ffffffff8106904d>] kthread+0xef/0xf7\n[35908.065201]  [<ffffffff81068f5e>] ? kthread_parkme+0x24/0x24\n[35908.065201]  [<ffffffff8147d10f>] ret_from_fork+0x3f/0x70\n[35908.065201]  [<ffffffff81068f5e>] ? kthread_parkme+0x24/0x24\n[35908.065201] Code: 6a 01 41 56 41 54 ff 75 10 41 51 4d 89 c1 49 89 c8 48 8d 4d d0 e8 f6 f1 ff ff 48 83 c4 28 85 c0 75 2c 49 81 fc ff 00 00 00 77 02 <0f> 0b 4c 8b 45 30 8b 4d 28 45 31\n[35908.065201] RIP  [<ffffffffa04928b5>] insert_inline_extent_backref+0x52/0xb1 [btrfs]\n[35908.065201]  RSP <ffff88010c4cbb08>\n[35908.310885] ---[ end trace fe4299baf0666457 ]---\n\nThis happens because the new delayed references code no longer merges\ndelayed references that have different sequence values. The following\nsteps are an example sequence leading to this issue:\n\n1) Transaction N starts, fs_info->tree_mod_seq has value 0;\n\n2) Extent buffer (btree node) A is allocated, delayed reference Ref1 for\n   bytenr A is created, with a value of 1 and a seq value of 0;\n\n3) fs_info->tree_mod_seq is incremented to 1;\n\n4) Extent buffer A is deleted through btrfs_del_items(), which calls\n   btrfs_del_leaf(), which in turn calls btrfs_free_tree_block(). The\n   later returns the metadata extent associated to extent buffer A to\n   the free space cache (the range is not pinned), because the extent\n   buffer was created in the current transaction (N) and writeback never\n   happened for the extent buffer (flag BTRFS_HEADER_FLAG_WRITTEN not set\n   in the extent buffer).\n   This creates the delayed reference Ref2 for bytenr A, with a value\n   of -1 and a seq value of 1;\n\n5) Delayed reference Ref2 is not merged with Ref1 when we create it,\n   because they have different sequence numbers (decided at\n   add_delayed_ref_tail_merge());\n\n6) fs_info->tree_mod_seq is incremented to 2;\n\n7) Some task attempts to allocate a new extent buffer (done at\n   extent-tree.c:find_free_extent()), but due to heavy fragmentation\n   and running low on metadata space the clustered allocation fails\n   and we fall back to unclustered allocation, which finds the\n   extent at offset A, so a new extent buffer at offset A is allocated.\n   This creates delayed reference Ref3 for bytenr A, with a value of 1\n   and a seq value of 2;\n\n8) Ref3 is not merged neither with Ref2 nor Ref1, again because they\n   all have different seq values;\n\n9) We start running the delayed references (__btrfs_run_delayed_refs());\n\n10) The delayed Ref1 is the first one being applied, which ends up\n    creating an inline extent backref in the extent tree;\n\n10) Next the delayed reference Ref3 is selected for execution, and not\n    Ref2, because select_delayed_ref() always gives a preference for\n    positive references (that have an action of BTRFS_ADD_DELAYED_REF);\n\n11) When running Ref3 we encounter alreay the inline extent backref\n    in the extent tree at insert_inline_extent_backref(), which makes\n    us hit the following BUG_ON:\n\n        BUG_ON(owner < BTRFS_FIRST_FREE_OBJECTID);\n\n    This is always true because owner corresponds to the level of the\n    extent buffer/btree node in the btree.\n\nFor the scenario described above we hit the BUG_ON because we never merge\nreferences that have different seq values.\n\nWe used to do the merging before the 4.2 kernel, more specifically, before\nthe commmits:\n\n  c6fc24549960 (\"btrfs: delayed-ref: Use list to replace the ref_root in ref_head.\")\n  c43d160fcd5e (\"btrfs: delayed-ref: Cleanup the unneeded functions.\")\n\nThis issue became more exposed after the following change that was added\nto 4.2 as well:\n\n  cffc3374e567 (\"Btrfs: fix order by which delayed references are run\")\n\nWhich in turn fixed another regression by the two commits previously\nmentioned.\n\nSo fix this by bringing back the delayed reference merge code, with the\nproper adaptations so that it operates against the new data structure\n(linked list vs old red black tree implementation).\n\nThis issue was hit running fstest btrfs/063 in a loop. Several people have\nreported this issue in the mailing list when running on kernels 4.2+.\n\nVery special thanks to St\u00e9phane Lesimple for helping debugging this issue\nand testing this fix on his multi terabyte filesystem (which took more\nthan one day to balance alone, plus fsck, etc).\n\nFixes: c6fc24549960 (\"btrfs: delayed-ref: Use list to replace the ref_root in ref_head.\")\nReported-by: Peter Becker <floyd.net@gmail.com>\nReported-by: St\u00e9phane Lesimple <stephane_btrfs@lesimple.fr>\nTested-by: St\u00e9phane Lesimple <stephane_btrfs@lesimple.fr>\nReported-by: Malte Schr\u00f6der <malte@tnxip.de>\nReported-by: Derek Dongray <derek@valedon.co.uk>\nReported-by: Erkki Seppala <flux-btrfs@inside.org>\nCc: stable@vger.kernel.org  # 4.2+\nSigned-off-by: Filipe Manana <fdmanana@suse.com>\nReviewed-by: Liu Bo <bo.li.liu@oracle.com>",
        "before_after_code_files": [
          "fs/btrfs/delayed-ref.c||fs/btrfs/delayed-ref.c",
          "fs/btrfs/extent-tree.c||fs/btrfs/extent-tree.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/btrfs/delayed-ref.c||fs/btrfs/delayed-ref.c": [
          "File: fs/btrfs/delayed-ref.c -> fs/btrfs/delayed-ref.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "197:   trans->delayed_ref_updates--;",
          "198: }",
          "200: int btrfs_check_delayed_seq(struct btrfs_fs_info *fs_info,",
          "201:        struct btrfs_delayed_ref_root *delayed_refs,",
          "202:        u64 seq)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "200: static bool merge_ref(struct btrfs_trans_handle *trans,",
          "201:         struct btrfs_delayed_ref_root *delayed_refs,",
          "202:         struct btrfs_delayed_ref_head *head,",
          "203:         struct btrfs_delayed_ref_node *ref,",
          "204:         u64 seq)",
          "205: {",
          "206:  struct btrfs_delayed_ref_node *next;",
          "207:  bool done = false;",
          "209:  next = list_first_entry(&head->ref_list, struct btrfs_delayed_ref_node,",
          "210:     list);",
          "211:  while (!done && &next->list != &head->ref_list) {",
          "212:   int mod;",
          "213:   struct btrfs_delayed_ref_node *next2;",
          "215:   next2 = list_next_entry(next, list);",
          "217:   if (next == ref)",
          "218:    goto next;",
          "220:   if (seq && next->seq >= seq)",
          "221:    goto next;",
          "223:   if (next->type != ref->type || next->no_quota != ref->no_quota)",
          "224:    goto next;",
          "226:   if ((ref->type == BTRFS_TREE_BLOCK_REF_KEY ||",
          "227:        ref->type == BTRFS_SHARED_BLOCK_REF_KEY) &&",
          "228:       comp_tree_refs(btrfs_delayed_node_to_tree_ref(ref),",
          "229:        btrfs_delayed_node_to_tree_ref(next),",
          "230:        ref->type))",
          "231:    goto next;",
          "232:   if ((ref->type == BTRFS_EXTENT_DATA_REF_KEY ||",
          "233:        ref->type == BTRFS_SHARED_DATA_REF_KEY) &&",
          "234:       comp_data_refs(btrfs_delayed_node_to_data_ref(ref),",
          "235:        btrfs_delayed_node_to_data_ref(next)))",
          "236:    goto next;",
          "238:   if (ref->action == next->action) {",
          "239:    mod = next->ref_mod;",
          "240:   } else {",
          "241:    if (ref->ref_mod < next->ref_mod) {",
          "242:     swap(ref, next);",
          "243:     done = true;",
          "244:    }",
          "245:    mod = -next->ref_mod;",
          "246:   }",
          "248:   drop_delayed_ref(trans, delayed_refs, head, next);",
          "249:   ref->ref_mod += mod;",
          "250:   if (ref->ref_mod == 0) {",
          "251:    drop_delayed_ref(trans, delayed_refs, head, ref);",
          "252:    done = true;",
          "253:   } else {",
          "257:    WARN_ON(ref->type == BTRFS_TREE_BLOCK_REF_KEY ||",
          "258:     ref->type == BTRFS_SHARED_BLOCK_REF_KEY);",
          "259:   }",
          "260: next:",
          "261:   next = next2;",
          "262:  }",
          "264:  return done;",
          "265: }",
          "267: void btrfs_merge_delayed_refs(struct btrfs_trans_handle *trans,",
          "268:          struct btrfs_fs_info *fs_info,",
          "269:          struct btrfs_delayed_ref_root *delayed_refs,",
          "270:          struct btrfs_delayed_ref_head *head)",
          "271: {",
          "272:  struct btrfs_delayed_ref_node *ref;",
          "273:  u64 seq = 0;",
          "275:  assert_spin_locked(&head->lock);",
          "277:  if (list_empty(&head->ref_list))",
          "278:   return;",
          "281:  if (head->is_data)",
          "282:   return;",
          "284:  spin_lock(&fs_info->tree_mod_seq_lock);",
          "285:  if (!list_empty(&fs_info->tree_mod_seq_list)) {",
          "286:   struct seq_list *elem;",
          "288:   elem = list_first_entry(&fs_info->tree_mod_seq_list,",
          "289:      struct seq_list, list);",
          "290:   seq = elem->seq;",
          "291:  }",
          "292:  spin_unlock(&fs_info->tree_mod_seq_lock);",
          "294:  ref = list_first_entry(&head->ref_list, struct btrfs_delayed_ref_node,",
          "295:           list);",
          "296:  while (&ref->list != &head->ref_list) {",
          "297:   if (seq && ref->seq >= seq)",
          "298:    goto next;",
          "300:   if (merge_ref(trans, delayed_refs, head, ref, seq)) {",
          "301:    if (list_empty(&head->ref_list))",
          "302:     break;",
          "303:    ref = list_first_entry(&head->ref_list,",
          "304:             struct btrfs_delayed_ref_node,",
          "305:             list);",
          "306:    continue;",
          "307:   }",
          "308: next:",
          "309:   ref = list_next_entry(ref, list);",
          "310:  }",
          "311: }",
          "",
          "---------------"
        ],
        "fs/btrfs/extent-tree.c||fs/btrfs/extent-tree.c": [
          "File: fs/btrfs/extent-tree.c -> fs/btrfs/extent-tree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2502:    }",
          "2503:   }",
          "2505:   spin_lock(&locked_ref->lock);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2518:   btrfs_merge_delayed_refs(trans, fs_info, delayed_refs,",
          "2519:       locked_ref);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
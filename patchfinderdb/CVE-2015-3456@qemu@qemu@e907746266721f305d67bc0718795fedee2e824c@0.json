{
  "cve_id": "CVE-2015-3456",
  "cve_desc": "The Floppy Disk Controller (FDC) in QEMU, as used in Xen 4.5.x and earlier and KVM, allows local guest users to cause a denial of service (out-of-bounds write and guest crash) or possibly execute arbitrary code via the (1) FD_CMD_READ_ID, (2) FD_CMD_DRIVE_SPECIFICATION_COMMAND, or other unspecified commands, aka VENOM.",
  "repo": "qemu/qemu",
  "patch_hash": "e907746266721f305d67bc0718795fedee2e824c",
  "patch_info": {
    "commit_hash": "e907746266721f305d67bc0718795fedee2e824c",
    "repo": "qemu/qemu",
    "commit_url": "https://github.com/qemu/qemu/commit/e907746266721f305d67bc0718795fedee2e824c",
    "files": [
      "hw/block/fdc.c"
    ],
    "message": "fdc: force the fifo access to be in bounds of the allocated buffer\n\nDuring processing of certain commands such as FD_CMD_READ_ID and\nFD_CMD_DRIVE_SPECIFICATION_COMMAND the fifo memory access could\nget out of bounds leading to memory corruption with values coming\nfrom the guest.\n\nFix this by making sure that the index is always bounded by the\nallocated memory.\n\nThis is CVE-2015-3456.\n\nSigned-off-by: Petr Matousek <pmatouse@redhat.com>\nReviewed-by: John Snow <jsnow@redhat.com>\nSigned-off-by: John Snow <jsnow@redhat.com>",
    "before_after_code_files": [
      "hw/block/fdc.c||hw/block/fdc.c"
    ]
  },
  "patch_diff": {
    "hw/block/fdc.c||hw/block/fdc.c": [
      "File: hw/block/fdc.c -> hw/block/fdc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1497: {",
      "1498:     FDrive *cur_drv;",
      "1499:     uint32_t retval = 0;",
      "1502:     cur_drv = get_cur_drv(fdctrl);",
      "1503:     fdctrl->dsr &= ~FD_DSR_PWRDOWN;",
      "",
      "[Removed Lines]",
      "1500:     int pos;",
      "",
      "[Added Lines]",
      "1500:     uint32_t pos;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1506:         return 0;",
      "1507:     }",
      "1508:     pos = fdctrl->data_pos;",
      "1509:     if (fdctrl->msr & FD_MSR_NONDMA) {",
      "1511:         if (pos == 0) {",
      "1512:             if (fdctrl->data_pos != 0)",
      "1513:                 if (!fdctrl_seek_to_next_sect(fdctrl, cur_drv)) {",
      "",
      "[Removed Lines]",
      "1510:         pos %= FD_SECTOR_LEN;",
      "",
      "[Added Lines]",
      "1509:     pos %= FD_SECTOR_LEN;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1852: static void fdctrl_handle_drive_specification_command(FDCtrl *fdctrl, int direction)",
      "1853: {",
      "1854:     FDrive *cur_drv = get_cur_drv(fdctrl);",
      "1859:             fdctrl->fifo[0] = fdctrl->fifo[1];",
      "1860:             fdctrl->fifo[2] = 0;",
      "1861:             fdctrl->fifo[3] = 0;",
      "",
      "[Removed Lines]",
      "1856:     if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x80) {",
      "1858:         if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x40) {",
      "",
      "[Added Lines]",
      "1855:     uint32_t pos;",
      "1857:     pos = fdctrl->data_pos - 1;",
      "1858:     pos %= FD_SECTOR_LEN;",
      "1859:     if (fdctrl->fifo[pos] & 0x80) {",
      "1861:         if (fdctrl->fifo[pos] & 0x40) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1955: static void fdctrl_write_data(FDCtrl *fdctrl, uint32_t value)",
      "1956: {",
      "1957:     FDrive *cur_drv;",
      "1961:     if (!(fdctrl->dor & FD_DOR_nRESET)) {",
      "",
      "[Removed Lines]",
      "1958:     int pos;",
      "",
      "[Added Lines]",
      "1961:     uint32_t pos;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2004:     }",
      "2006:     FLOPPY_DPRINTF(\"%s: %02x\\n\", __func__, value);",
      "2008:     if (fdctrl->data_pos == fdctrl->data_len) {",
      "",
      "[Removed Lines]",
      "2007:     fdctrl->fifo[fdctrl->data_pos++] = value;",
      "",
      "[Added Lines]",
      "2010:     pos = fdctrl->data_pos++;",
      "2011:     pos %= FD_SECTOR_LEN;",
      "2012:     fdctrl->fifo[pos] = value;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "959fad0ff11837d299e22b0f148c608b50eec457",
      "candidate_info": {
        "commit_hash": "959fad0ff11837d299e22b0f148c608b50eec457",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/959fad0ff11837d299e22b0f148c608b50eec457",
        "files": [
          "hw/block/fdc.c"
        ],
        "message": "fdc: force the fifo access to be in bounds of the allocated buffer\n\nDuring processing of certain commands such as FD_CMD_READ_ID and\nFD_CMD_DRIVE_SPECIFICATION_COMMAND the fifo memory access could\nget out of bounds leading to memory corruption with values coming\nfrom the guest.\n\nFix this by making sure that the index is always bounded by the\nallocated memory.\n\nThis is CVE-2015-3456.\n\nSigned-off-by: Petr Matousek <pmatouse@redhat.com>\nReviewed-by: John Snow <jsnow@redhat.com>\nSigned-off-by: John Snow <jsnow@redhat.com>\n(cherry picked from commit e907746266721f305d67bc0718795fedee2e824c)\nSigned-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>",
        "before_after_code_files": [
          "hw/block/fdc.c||hw/block/fdc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "hw/block/fdc.c||hw/block/fdc.c"
          ],
          "candidate": [
            "hw/block/fdc.c||hw/block/fdc.c"
          ]
        }
      },
      "candidate_diff": {
        "hw/block/fdc.c||hw/block/fdc.c": [
          "File: hw/block/fdc.c -> hw/block/fdc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1512: {",
          "1513:     FDrive *cur_drv;",
          "1514:     uint32_t retval = 0;",
          "1517:     cur_drv = get_cur_drv(fdctrl);",
          "1518:     fdctrl->dsr &= ~FD_DSR_PWRDOWN;",
          "",
          "[Removed Lines]",
          "1515:     int pos;",
          "",
          "[Added Lines]",
          "1515:     uint32_t pos;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1521:         return 0;",
          "1522:     }",
          "1523:     pos = fdctrl->data_pos;",
          "1524:     if (fdctrl->msr & FD_MSR_NONDMA) {",
          "1526:         if (pos == 0) {",
          "1527:             if (fdctrl->data_pos != 0)",
          "1528:                 if (!fdctrl_seek_to_next_sect(fdctrl, cur_drv)) {",
          "",
          "[Removed Lines]",
          "1525:         pos %= FD_SECTOR_LEN;",
          "",
          "[Added Lines]",
          "1524:     pos %= FD_SECTOR_LEN;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1867: static void fdctrl_handle_drive_specification_command(FDCtrl *fdctrl, int direction)",
          "1868: {",
          "1869:     FDrive *cur_drv = get_cur_drv(fdctrl);",
          "1874:             fdctrl->fifo[0] = fdctrl->fifo[1];",
          "1875:             fdctrl->fifo[2] = 0;",
          "1876:             fdctrl->fifo[3] = 0;",
          "",
          "[Removed Lines]",
          "1871:     if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x80) {",
          "1873:         if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x40) {",
          "",
          "[Added Lines]",
          "1870:     uint32_t pos;",
          "1872:     pos = fdctrl->data_pos - 1;",
          "1873:     pos %= FD_SECTOR_LEN;",
          "1874:     if (fdctrl->fifo[pos] & 0x80) {",
          "1876:         if (fdctrl->fifo[pos] & 0x40) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1970: static void fdctrl_write_data(FDCtrl *fdctrl, uint32_t value)",
          "1971: {",
          "1972:     FDrive *cur_drv;",
          "1976:     if (!(fdctrl->dor & FD_DOR_nRESET)) {",
          "",
          "[Removed Lines]",
          "1973:     int pos;",
          "",
          "[Added Lines]",
          "1976:     uint32_t pos;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2019:     }",
          "2021:     FLOPPY_DPRINTF(\"%s: %02x\\n\", __func__, value);",
          "2023:     if (fdctrl->data_pos == fdctrl->data_len) {",
          "",
          "[Removed Lines]",
          "2022:     fdctrl->fifo[fdctrl->data_pos++] = value;",
          "",
          "[Added Lines]",
          "2025:     pos = fdctrl->data_pos++;",
          "2026:     pos %= FD_SECTOR_LEN;",
          "2027:     fdctrl->fifo[pos] = value;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "85d291a08c91c07927bbbd29f72a27d3ad7478f3",
      "candidate_info": {
        "commit_hash": "85d291a08c91c07927bbbd29f72a27d3ad7478f3",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/85d291a08c91c07927bbbd29f72a27d3ad7478f3",
        "files": [
          "hw/block/fdc.c"
        ],
        "message": "fdc: Introduce fdctrl->phase\n\nThe floppy controller spec describes three different controller phases,\nwhich are currently not explicitly modelled in our emulation. Instead,\neach phase is represented by a combination of flags in registers.\n\nThis patch makes explicit in which phase the controller currently is.\n\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>\nAcked-by: John Snow <jsnow@redhat.com>\nMessage-id: 1432214378-31891-4-git-send-email-kwolf@redhat.com\nSigned-off-by: John Snow <jsnow@redhat.com>",
        "before_after_code_files": [
          "hw/block/fdc.c||hw/block/fdc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "hw/block/fdc.c||hw/block/fdc.c"
          ],
          "candidate": [
            "hw/block/fdc.c||hw/block/fdc.c"
          ]
        }
      },
      "candidate_diff": {
        "hw/block/fdc.c||hw/block/fdc.c": [
          "File: hw/block/fdc.c -> hw/block/fdc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "495:     FD_DIR_DSKCHG   = 0x80,",
          "496: };",
          "498: #define FD_MULTI_TRACK(state) ((state) & FD_STATE_MULTI)",
          "499: #define FD_FORMAT_CMD(state) ((state) & FD_STATE_FORMAT)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "516: enum {",
          "518:     FD_PHASE_RECONSTRUCT    = 0,",
          "520:     FD_PHASE_COMMAND        = 1,",
          "521:     FD_PHASE_EXECUTION      = 2,",
          "522:     FD_PHASE_RESULT         = 3,",
          "523: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "505:     QEMUTimer *result_timer;",
          "506:     int dma_chann;",
          "508:     uint8_t version;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "534:     uint8_t phase;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "744:     }",
          "745: };",
          "747: static void fdc_pre_save(void *opaque)",
          "748: {",
          "749:     FDCtrl *s = opaque;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "783: static int reconstruct_phase(FDCtrl *fdctrl)",
          "784: {",
          "785:     if (fdctrl->msr & FD_MSR_NONDMA) {",
          "786:         return FD_PHASE_EXECUTION;",
          "787:     } else if ((fdctrl->msr & FD_MSR_RQM) == 0) {",
          "789:         return FD_PHASE_EXECUTION;",
          "790:     } else if (fdctrl->msr & FD_MSR_DIO) {",
          "791:         return FD_PHASE_RESULT;",
          "792:     } else {",
          "793:         return FD_PHASE_COMMAND;",
          "794:     }",
          "795: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "751:     s->dor_vmstate = s->dor | GET_CUR_DRV(s);",
          "752: }",
          "754: static int fdc_post_load(void *opaque, int version_id)",
          "755: {",
          "756:     FDCtrl *s = opaque;",
          "758:     SET_CUR_DRV(s, s->dor_vmstate & FD_DOR_SELMASK);",
          "759:     s->dor = s->dor_vmstate & ~FD_DOR_SELMASK;",
          "760:     return 0;",
          "761: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "804: static int fdc_pre_load(void *opaque)",
          "805: {",
          "806:     FDCtrl *s = opaque;",
          "807:     s->phase = FD_PHASE_RECONSTRUCT;",
          "808:     return 0;",
          "809: }",
          "818:     if (s->phase == FD_PHASE_RECONSTRUCT) {",
          "819:         s->phase = reconstruct_phase(s);",
          "820:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "794:     }",
          "795: };",
          "797: static const VMStateDescription vmstate_fdc = {",
          "798:     .name = \"fdc\",",
          "799:     .version_id = 2,",
          "800:     .minimum_version_id = 2,",
          "801:     .pre_save = fdc_pre_save,",
          "802:     .post_load = fdc_post_load,",
          "803:     .fields = (VMStateField[]) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "859: static bool fdc_phase_needed(void *opaque)",
          "860: {",
          "861:     FDCtrl *fdctrl = opaque;",
          "863:     return reconstruct_phase(fdctrl) != fdctrl->phase;",
          "864: }",
          "866: static const VMStateDescription vmstate_fdc_phase = {",
          "867:     .name = \"fdc/phase\",",
          "868:     .version_id = 1,",
          "869:     .minimum_version_id = 1,",
          "870:     .fields = (VMStateField[]) {",
          "871:         VMSTATE_UINT8(phase, FDCtrl),",
          "872:         VMSTATE_END_OF_LIST()",
          "873:     }",
          "874: };",
          "881:     .pre_load = fdc_pre_load,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "838:         } , {",
          "839:             .vmsd = &vmstate_fdc_result_timer,",
          "840:             .needed = fdc_result_timer_needed,",
          "841:         } , {",
          "843:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "921:         } , {",
          "922:             .vmsd = &vmstate_fdc_phase,",
          "923:             .needed = fdc_phase_needed,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1138: static void fdctrl_to_command_phase(FDCtrl *fdctrl)",
          "1139: {",
          "1140:     fdctrl->data_dir = FD_DIR_WRITE;",
          "1141:     fdctrl->data_pos = 0;",
          "1142:     fdctrl->msr &= ~(FD_MSR_CMDBUSY | FD_MSR_DIO);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1223:     fdctrl->phase = FD_PHASE_COMMAND;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1147: static void fdctrl_to_result_phase(FDCtrl *fdctrl, int fifo_len)",
          "1148: {",
          "1149:     fdctrl->data_dir = FD_DIR_READ;",
          "1150:     fdctrl->data_len = fifo_len;",
          "1151:     fdctrl->data_pos = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1233:     fdctrl->phase = FD_PHASE_RESULT;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2018:         if (fdctrl->data_state & FD_STATE_FORMAT) {",
          "2019:             fdctrl_format_sector(fdctrl);",
          "2020:             return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2106:         fdctrl->phase = FD_PHASE_EXECUTION;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5b0a25e8d2f15f89255c745c71d297b5b24d138c",
      "candidate_info": {
        "commit_hash": "5b0a25e8d2f15f89255c745c71d297b5b24d138c",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/5b0a25e8d2f15f89255c745c71d297b5b24d138c",
        "files": [
          "hw/block/fdc.c"
        ],
        "message": "fdc: Use phase in fdctrl_write_data()\n\nInstead of relying on a flag in the MSR to distinguish controller phases,\nuse the explicit phase that we store now. Assertions of the right MSR\nflags are added.\n\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>\nReviewed-by: John Snow <jsnow@redhat.com>\nMessage-id: 1432214378-31891-5-git-send-email-kwolf@redhat.com\nSigned-off-by: John Snow <jsnow@redhat.com>",
        "before_after_code_files": [
          "hw/block/fdc.c||hw/block/fdc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "hw/block/fdc.c||hw/block/fdc.c"
          ],
          "candidate": [
            "hw/block/fdc.c||hw/block/fdc.c"
          ]
        }
      },
      "candidate_diff": {
        "hw/block/fdc.c||hw/block/fdc.c": [
          "File: hw/block/fdc.c -> hw/block/fdc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2059:         return;",
          "2060:     }",
          "2061:     fdctrl->dsr &= ~FD_DSR_PWRDOWN;",
          "2065:         pos = fdctrl->data_pos++;",
          "2066:         pos %= FD_SECTOR_LEN;",
          "",
          "[Removed Lines]",
          "2063:     if (fdctrl->msr & FD_MSR_NONDMA) {",
          "",
          "[Added Lines]",
          "2063:     switch (fdctrl->phase) {",
          "2064:     case FD_PHASE_EXECUTION:",
          "2067:         assert(fdctrl->msr & FD_MSR_NONDMA);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2072:                 < 0) {",
          "2073:                 FLOPPY_DPRINTF(\"error writing sector %d\\n\",",
          "2074:                                fd_sector(cur_drv));",
          "2076:             }",
          "2077:             if (!fdctrl_seek_to_next_sect(fdctrl, cur_drv)) {",
          "2078:                 FLOPPY_DPRINTF(\"error seeking to next sector %d\\n\",",
          "2079:                                fd_sector(cur_drv));",
          "2081:             }",
          "2082:         }",
          "",
          "[Removed Lines]",
          "2075:                 return;",
          "2080:                 return;",
          "",
          "[Added Lines]",
          "2079:                 break;",
          "2084:                 break;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2086:         if (fdctrl->data_pos == fdctrl->data_len)",
          "2087:             fdctrl_stop_transfer(fdctrl, 0x00, 0x00, 0x00);",
          "2110:         }",
          "2115:     }",
          "2116: }",
          "",
          "[Removed Lines]",
          "2088:         return;",
          "2089:     }",
          "2090:     if (fdctrl->data_pos == 0) {",
          "2092:         pos = command_to_handler[value & 0xff];",
          "2093:         FLOPPY_DPRINTF(\"%s command\\n\", handlers[pos].name);",
          "2094:         fdctrl->data_len = handlers[pos].parameters + 1;",
          "2095:         fdctrl->msr |= FD_MSR_CMDBUSY;",
          "2096:     }",
          "2098:     FLOPPY_DPRINTF(\"%s: %02x\\n\", __func__, value);",
          "2099:     pos = fdctrl->data_pos++;",
          "2100:     pos %= FD_SECTOR_LEN;",
          "2101:     fdctrl->fifo[pos] = value;",
          "2102:     if (fdctrl->data_pos == fdctrl->data_len) {",
          "2106:         fdctrl->phase = FD_PHASE_EXECUTION;",
          "2107:         if (fdctrl->data_state & FD_STATE_FORMAT) {",
          "2108:             fdctrl_format_sector(fdctrl);",
          "2109:             return;",
          "2112:         pos = command_to_handler[fdctrl->fifo[0] & 0xff];",
          "2113:         FLOPPY_DPRINTF(\"treat %s command\\n\", handlers[pos].name);",
          "2114:         (*handlers[pos].handler)(fdctrl, handlers[pos].direction);",
          "",
          "[Added Lines]",
          "2092:         break;",
          "2094:     case FD_PHASE_COMMAND:",
          "2095:         assert(!(fdctrl->msr & FD_MSR_NONDMA));",
          "2097:         if (fdctrl->data_pos == 0) {",
          "2099:             pos = command_to_handler[value & 0xff];",
          "2100:             FLOPPY_DPRINTF(\"%s command\\n\", handlers[pos].name);",
          "2101:             fdctrl->data_len = handlers[pos].parameters + 1;",
          "2102:             fdctrl->msr |= FD_MSR_CMDBUSY;",
          "2105:         FLOPPY_DPRINTF(\"%s: %02x\\n\", __func__, value);",
          "2106:         pos = fdctrl->data_pos++;",
          "2107:         pos %= FD_SECTOR_LEN;",
          "2108:         fdctrl->fifo[pos] = value;",
          "2109:         if (fdctrl->data_pos == fdctrl->data_len) {",
          "2113:             fdctrl->phase = FD_PHASE_EXECUTION;",
          "2114:             if (fdctrl->data_state & FD_STATE_FORMAT) {",
          "2115:                 fdctrl_format_sector(fdctrl);",
          "2116:                 break;",
          "2117:             }",
          "2119:             pos = command_to_handler[fdctrl->fifo[0] & 0xff];",
          "2120:             FLOPPY_DPRINTF(\"treat %s command\\n\", handlers[pos].name);",
          "2121:             (*handlers[pos].handler)(fdctrl, handlers[pos].direction);",
          "2122:         }",
          "2123:         break;",
          "2125:     case FD_PHASE_RESULT:",
          "2126:     default:",
          "2127:         abort();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d275b33d76c8ed9d5a3dca22ea0fdec8d5a5c8e6",
      "candidate_info": {
        "commit_hash": "d275b33d76c8ed9d5a3dca22ea0fdec8d5a5c8e6",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/d275b33d76c8ed9d5a3dca22ea0fdec8d5a5c8e6",
        "files": [
          "hw/block/fdc.c"
        ],
        "message": "fdc: Code cleanup in fdctrl_write_data()\n\nFactor out a few common lines of code, reformat, improve comments.\n\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>\nReviewed-by: John Snow <jsnow@redhat.com>\nMessage-id: 1432214378-31891-6-git-send-email-kwolf@redhat.com\nSigned-off-by: John Snow <jsnow@redhat.com>",
        "before_after_code_files": [
          "hw/block/fdc.c||hw/block/fdc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "hw/block/fdc.c||hw/block/fdc.c"
          ],
          "candidate": [
            "hw/block/fdc.c||hw/block/fdc.c"
          ]
        }
      },
      "candidate_diff": {
        "hw/block/fdc.c||hw/block/fdc.c": [
          "File: hw/block/fdc.c -> hw/block/fdc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2004:     uint8_t value;",
          "2005:     uint8_t mask;",
          "2006:     const char* name;",
          "2007:     int parameters;",
          "2008:     void (*handler)(FDCtrl *fdctrl, int direction);",
          "2009:     int direction;",
          "2011:     { FD_CMD_READ, 0x1f, \"READ\", 8, fdctrl_start_transfer, FD_DIR_READ },",
          "2012:     { FD_CMD_WRITE, 0x3f, \"WRITE\", 8, fdctrl_start_transfer, FD_DIR_WRITE },",
          "2013:     { FD_CMD_SEEK, 0xff, \"SEEK\", 2, fdctrl_handle_seek },",
          "",
          "[Removed Lines]",
          "2003: static const struct {",
          "2010: } handlers[] = {",
          "",
          "[Added Lines]",
          "2003: typedef struct FDCtrlCommand {",
          "2010: } FDCtrlCommand;",
          "2012: static const FDCtrlCommand handlers[] = {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2045: static uint8_t command_to_handler[256];",
          "2047: static void fdctrl_write_data(FDCtrl *fdctrl, uint32_t value)",
          "2048: {",
          "2049:     FDrive *cur_drv;",
          "2050:     uint32_t pos;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2049: static const FDCtrlCommand *get_command(uint8_t cmd)",
          "2050: {",
          "2051:     int idx;",
          "2053:     idx = command_to_handler[cmd];",
          "2054:     FLOPPY_DPRINTF(\"%s command\\n\", handlers[idx].name);",
          "2055:     return &handlers[idx];",
          "2056: }",
          "2061:     const FDCtrlCommand *cmd;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2060:     }",
          "2061:     fdctrl->dsr &= ~FD_DSR_PWRDOWN;",
          "2063:     switch (fdctrl->phase) {",
          "2064:     case FD_PHASE_EXECUTION:",
          "2067:         assert(fdctrl->msr & FD_MSR_NONDMA);",
          "2072:         if (pos == FD_SECTOR_LEN - 1 ||",
          "2073:             fdctrl->data_pos == fdctrl->data_len) {",
          "2074:             cur_drv = get_cur_drv(fdctrl);",
          "",
          "[Removed Lines]",
          "2069:         pos = fdctrl->data_pos++;",
          "2070:         pos %= FD_SECTOR_LEN;",
          "2071:         fdctrl->fifo[pos] = value;",
          "",
          "[Added Lines]",
          "2075:     FLOPPY_DPRINTF(\"%s: %02x\\n\", __func__, value);",
          "2080:     pos = fdctrl->data_pos++;",
          "2081:     pos %= FD_SECTOR_LEN;",
          "2082:     fdctrl->fifo[pos] = value;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2084:                 break;",
          "2085:             }",
          "2086:         }",
          "2091:             fdctrl_stop_transfer(fdctrl, 0x00, 0x00, 0x00);",
          "2092:         break;",
          "2094:     case FD_PHASE_COMMAND:",
          "2095:         assert(!(fdctrl->msr & FD_MSR_NONDMA));",
          "2102:             fdctrl->msr |= FD_MSR_CMDBUSY;",
          "2103:         }",
          "2109:         if (fdctrl->data_pos == fdctrl->data_len) {",
          "2113:             fdctrl->phase = FD_PHASE_EXECUTION;",
          "2114:             if (fdctrl->data_state & FD_STATE_FORMAT) {",
          "2115:                 fdctrl_format_sector(fdctrl);",
          "2116:                 break;",
          "2117:             }",
          "2122:         }",
          "2123:         break;",
          "",
          "[Removed Lines]",
          "2090:         if (fdctrl->data_pos == fdctrl->data_len)",
          "2097:         if (fdctrl->data_pos == 0) {",
          "2099:             pos = command_to_handler[value & 0xff];",
          "2100:             FLOPPY_DPRINTF(\"%s command\\n\", handlers[pos].name);",
          "2101:             fdctrl->data_len = handlers[pos].parameters + 1;",
          "2105:         FLOPPY_DPRINTF(\"%s: %02x\\n\", __func__, value);",
          "2106:         pos = fdctrl->data_pos++;",
          "2107:         pos %= FD_SECTOR_LEN;",
          "2108:         fdctrl->fifo[pos] = value;",
          "2119:             pos = command_to_handler[fdctrl->fifo[0] & 0xff];",
          "2120:             FLOPPY_DPRINTF(\"treat %s command\\n\", handlers[pos].name);",
          "2121:             (*handlers[pos].handler)(fdctrl, handlers[pos].direction);",
          "",
          "[Added Lines]",
          "2108:         if (fdctrl->data_pos == fdctrl->data_len) {",
          "2110:         }",
          "2115:         assert(fdctrl->data_pos < FD_SECTOR_LEN);",
          "2117:         if (pos == 0) {",
          "2120:             cmd = get_command(value);",
          "2121:             fdctrl->data_len = cmd->parameters + 1;",
          "2134:             cmd = get_command(fdctrl->fifo[0]);",
          "2135:             FLOPPY_DPRINTF(\"Calling handler for '%s'\\n\", cmd->name);",
          "2136:             cmd->handler(fdctrl, cmd->direction);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
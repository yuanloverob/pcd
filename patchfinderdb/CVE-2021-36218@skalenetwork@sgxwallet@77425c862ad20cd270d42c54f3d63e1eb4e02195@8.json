{
  "cve_id": "CVE-2021-36218",
  "cve_desc": "An issue was discovered in SKALE sgxwallet 1.58.3. sgx_disp_ippsAES_GCMEncrypt allows an out-of-bounds write, resulting in a segfault and compromised enclave. This issue describes a buffer overflow, which was resolved prior to v1.77.0 and not reproducible in latest sgxwallet v1.77.0",
  "repo": "skalenetwork/sgxwallet",
  "patch_hash": "77425c862ad20cd270d42c54f3d63e1eb4e02195",
  "patch_info": {
    "commit_hash": "77425c862ad20cd270d42c54f3d63e1eb4e02195",
    "repo": "skalenetwork/sgxwallet",
    "commit_url": "https://github.com/skalenetwork/sgxwallet/commit/77425c862ad20cd270d42c54f3d63e1eb4e02195",
    "files": [
      "BLSCrypto.cpp",
      "DKGCrypto.cpp",
      "ECDSACrypto.cpp",
      "SEKManager.cpp",
      "SGXWalletServer.cpp",
      "secure_enclave/AESUtils.c",
      "secure_enclave/AESUtils.h",
      "secure_enclave/secure_enclave.c",
      "secure_enclave/secure_enclave.edl",
      "testw.cpp"
    ],
    "message": "SKALE-3205-restart",
    "before_after_code_files": [
      "BLSCrypto.cpp||BLSCrypto.cpp",
      "DKGCrypto.cpp||DKGCrypto.cpp",
      "ECDSACrypto.cpp||ECDSACrypto.cpp",
      "SEKManager.cpp||SEKManager.cpp",
      "SGXWalletServer.cpp||SGXWalletServer.cpp",
      "secure_enclave/AESUtils.c||secure_enclave/AESUtils.c",
      "secure_enclave/AESUtils.h||secure_enclave/AESUtils.h",
      "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c",
      "secure_enclave/secure_enclave.edl||secure_enclave/secure_enclave.edl",
      "testw.cpp||testw.cpp"
    ]
  },
  "patch_diff": {
    "BLSCrypto.cpp||BLSCrypto.cpp": [
      "File: BLSCrypto.cpp -> BLSCrypto.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "87:     CHECK_STATE(_hexArrayLen > 2 * _len);",
      "90:         _hexArray[j * 2] = hexval[((d[j] >> 4) & 0xF)];",
      "91:         _hexArray[j * 2 + 1] = hexval[(d[j]) & 0x0F];",
      "92:     }",
      "",
      "[Removed Lines]",
      "89:     for (int j = 0; j < _len; j++) {",
      "",
      "[Added Lines]",
      "89:     for (uint64_t j = 0; j < _len; j++) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "105:     CHECK_STATE(_bin_len)",
      "110:     CHECK_STATE(len != 2 * _max_length + 1);",
      "",
      "[Removed Lines]",
      "108:     int len = strnlen(_hex, 2 * _max_length + 1);",
      "",
      "[Added Lines]",
      "108:     uint64_t len = strnlen(_hex, 2 * _max_length + 1);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "121:         int high = char2int((char) _hex[i * 2]);",
      "122:         int low = char2int((char) _hex[i * 2 + 1]);",
      "",
      "[Removed Lines]",
      "120:     for (int i = 0; i < len / 2; i++) {",
      "",
      "[Added Lines]",
      "120:     for (uint64_t i = 0; i < len / 2; i++) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "248:     strncpy(keyArray->data(), _key, BUF_LEN);",
      "252:     sgx_status_t status = trustedEncryptKeyAES(eid, errStatus, errMsg.data(), keyArray->data(), encryptedKey->data(), &encryptedLen);",
      "",
      "[Removed Lines]",
      "250:     unsigned int encryptedLen = 0;",
      "",
      "[Added Lines]",
      "251:     uint64_t encryptedLen = 0;",
      "",
      "---------------"
    ],
    "DKGCrypto.cpp||DKGCrypto.cpp": [
      "File: DKGCrypto.cpp -> DKGCrypto.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "135: string gen_dkg_poly(int _t) {",
      "136:     vector<char> errMsg(BUF_LEN, 0);",
      "137:     int errStatus = 0;",
      "140:     vector <uint8_t> encrypted_dkg_secret(BUF_LEN, 0);",
      "145:     HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());",
      "147:     uint64_t length = enc_len;;",
      "",
      "[Removed Lines]",
      "138:     uint32_t enc_len = 0;",
      "144:     sgx_status_t status = trustedGenDkgSecretAES(eid, &errStatus, errMsg.data(), encrypted_dkg_secret.data(), &enc_len, _t);",
      "",
      "[Added Lines]",
      "138:     uint64_t enc_len = 0;",
      "142:     sgx_status_t status = trustedGenDkgSecretAES(",
      "143:             eid, &errStatus,errMsg.data(), encrypted_dkg_secret.data(), &enc_len, _t);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "215:     for (int i = 0; i < _n; i++) {",
      "216:         vector <uint8_t> encryptedSkey(BUF_LEN, 0);",
      "218:         vector<char> currentShare(193, 0);",
      "219:         vector<char> sShareG2(320, 0);",
      "",
      "[Removed Lines]",
      "217:         uint32_t decLen;",
      "",
      "[Added Lines]",
      "217:         uint64_t decLen;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "300:         throw SGXException(INVALID_HEX, \"Invalid encryptedKeyHex\");",
      "301:     }",
      "305:     sgx_status_t status = trustedCreateBlsKeyAES(eid, &errStatus, errMsg.data(), s_shares, encr_key, decKeyLen, encr_bls_key,",
      "306:                                                  &enc_bls_len);",
      "",
      "[Removed Lines]",
      "303:     uint32_t enc_bls_len = 0;",
      "",
      "[Added Lines]",
      "303:     uint64_t enc_bls_len = 0;",
      "",
      "---------------"
    ],
    "ECDSACrypto.cpp||ECDSACrypto.cpp": [
      "File: ECDSACrypto.cpp -> ECDSACrypto.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "54:     vector<char> pub_key_x(BUF_LEN, 0);",
      "55:     vector<char> pub_key_y(BUF_LEN, 0);",
      "59:     sgx_status_t status = trustedGenerateEcdsaKeyAES(eid, &errStatus,",
      "60:                                         errMsg.data(), encr_pr_key.data(), &enc_len,",
      "",
      "[Removed Lines]",
      "57:     uint32_t enc_len = 0;",
      "",
      "[Added Lines]",
      "57:     uint64_t enc_len = 0;",
      "",
      "---------------"
    ],
    "SEKManager.cpp||SEKManager.cpp": [
      "File: SEKManager.cpp -> SEKManager.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "52: void create_test_key() {",
      "53:     int errStatus = 0;",
      "54:     vector<char> errMsg(1024, 0);",
      "57:     SAFE_UINT8_BUF(encrypted_key, BUF_LEN);",
      "",
      "[Removed Lines]",
      "55:     uint32_t enc_len;",
      "",
      "[Added Lines]",
      "55:     uint64_t enc_len;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "110:     auto encrypted_SEK = make_shared < vector < uint8_t >> (BUF_LEN, 0);",
      "114:     sgx_status_t status = trustedSetSEK_backup(eid, &err_status, errMsg.data(), encrypted_SEK->data(), &l,",
      "115:                                                SEK.c_str());",
      "",
      "[Removed Lines]",
      "112:     uint32_t l = 0;",
      "",
      "[Added Lines]",
      "112:     uint64_t l = 0;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "127:     vector<char> errMsg(1024, 0);",
      "128:     int err_status = 0;",
      "129:     vector <uint8_t> encrypted_SEK(1024, 0);",
      "132:     SAFE_CHAR_BUF(SEK, 65);",
      "",
      "[Removed Lines]",
      "130:     uint32_t enc_len = 0;",
      "",
      "[Added Lines]",
      "130:     uint64_t enc_len = 0;",
      "",
      "---------------"
    ],
    "SGXWalletServer.cpp||SGXWalletServer.cpp": [
      "File: SGXWalletServer.cpp -> SGXWalletServer.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "564:         vector<string> public_keys = calculateAllBlsPublicKeys(public_shares);",
      "567:             throw SGXException(UNKNOWN_ERROR, \"\");",
      "568:         }",
      "",
      "[Removed Lines]",
      "566:         if (public_keys.size() != n) {",
      "",
      "[Added Lines]",
      "566:         if (public_keys.size() != (uint64_t)n) {",
      "",
      "---------------"
    ],
    "secure_enclave/AESUtils.c||secure_enclave/AESUtils.c": [
      "File: secure_enclave/AESUtils.c -> secure_enclave/AESUtils.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "27: #include \"stdlib.h\"",
      "28: #include <string.h>",
      "30: #include \"AESUtils.h\"",
      "32: sgx_aes_gcm_128bit_key_t AES_key;",
      "33: sgx_aes_gcm_128bit_key_t AES_DH_key;",
      "37:     if (!message) {",
      "38:         LOG_ERROR(\"Null message in AES_encrypt\");",
      "",
      "[Removed Lines]",
      "35: int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrLen) {",
      "",
      "[Added Lines]",
      "37: #define SAFE_CHAR_BUF(__X__, __Y__)  ;char __X__ [ __Y__ ]; memset(__X__, 0, __Y__);",
      "39: int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrBufLen, unsigned  char type,",
      "40:                 unsigned char decryptable, uint64_t* resultLen) {",
      "44:     if (!type) {",
      "45:         LOG_ERROR(\"Null type in AES_encrypt\");",
      "46:         return -1;",
      "47:     }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "47:     uint64_t len = strlen(message) + 1;",
      "50:         LOG_ERROR(\"Output buffer too small\");",
      "51:         return -3;",
      "52:     }",
      "54:     sgx_read_rand(encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE);",
      "57:                                                      encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE,",
      "58:                                                      encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,",
      "59:                                                      NULL, 0,",
      "60:                                                      (sgx_aes_gcm_128bit_tag_t *) encr_message);",
      "62:     return status;",
      "63: }",
      "",
      "[Removed Lines]",
      "49:     if (len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrLen ) {",
      "56:     sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_key, (uint8_t*)message, strlen(message),",
      "",
      "[Added Lines]",
      "61:     if (2 + len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrBufLen ) {",
      "66:     SAFE_CHAR_BUF(fullMessage, len + 2);",
      "68:     fullMessage[0] = type;",
      "69:     fullMessage[1] = decryptable;",
      "71:     strncpy(fullMessage + 2, message, len );",
      "73:     len = len + 2;",
      "74:     message = fullMessage;",
      "78:     sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_key, (uint8_t*)message, len,",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "96:                                                    NULL, 0,",
      "97:                                                    (sgx_aes_gcm_128bit_tag_t *)encr_message);",
      "133: }",
      "",
      "[Removed Lines]",
      "99:   return status;",
      "100: }",
      "105: int AES_encrypt_DH(char *message, uint8_t *encr_message, uint64_t encrLen) {",
      "107:     if (!message) {",
      "108:         LOG_ERROR(\"Null message in AES_encrypt_DH\");",
      "109:         return -1;",
      "110:     }",
      "112:     if (!encr_message) {",
      "113:         LOG_ERROR(\"Null encr message in AES_encrypt_DH\");",
      "114:         return -2;",
      "115:     }",
      "117:     uint64_t len = strlen(message) + 1;",
      "119:     if (len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrLen ) {",
      "120:         LOG_ERROR(\"Output buffer too small\");",
      "121:         return -3;",
      "122:     }",
      "124:     sgx_read_rand(encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE);",
      "126:     sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_DH_key, (uint8_t*)message, strlen(message),",
      "127:                                                      encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE,",
      "128:                                                      encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,",
      "129:                                                      NULL, 0,",
      "130:                                                      (sgx_aes_gcm_128bit_tag_t *) encr_message);",
      "132:     return status;",
      "135: int AES_decrypt_DH(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen) {",
      "137:     if (!message) {",
      "138:         LOG_ERROR(\"Null message in AES_encrypt_DH\");",
      "139:         return -1;",
      "140:     }",
      "142:     if (!encr_message) {",
      "143:         LOG_ERROR(\"Null encr message in AES_encrypt_DH\");",
      "144:         return -2;",
      "145:     }",
      "148:     if (length < SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE) {",
      "149:         LOG_ERROR(\"length < SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE\");",
      "150:         return -1;",
      "151:     }",
      "155:     uint64_t len = length - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE;",
      "157:     if (msgLen < len) {",
      "158:         LOG_ERROR(\"Output buffer not large enough\");",
      "159:         return -2;",
      "160:     }",
      "162:     sgx_status_t status = sgx_rijndael128GCM_decrypt(&AES_DH_key,",
      "163:                                                      encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE, len,",
      "164:                                                      (unsigned char*) message,",
      "165:                                                      encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,",
      "166:                                                      NULL, 0,",
      "167:                                                      (sgx_aes_gcm_128bit_tag_t *)encr_message);",
      "169:     return status;",
      "170: }",
      "",
      "[Added Lines]",
      "123:   for (int i = 2; i < strlen(message) + 1; i++) {",
      "124:       message[i - 2 ] = message[i];",
      "125:   }",
      "127:   return status;",
      "",
      "---------------"
    ],
    "secure_enclave/AESUtils.h||secure_enclave/AESUtils.h": [
      "File: secure_enclave/AESUtils.h -> secure_enclave/AESUtils.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "27: extern sgx_aes_gcm_128bit_key_t AES_key;",
      "28: extern sgx_aes_gcm_128bit_key_t AES_DH_key;",
      "31: int AES_decrypt(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen) ;",
      "33: int AES_encrypt_DH(char *message, uint8_t *encr_message, uint64_t encrLen);",
      "",
      "[Removed Lines]",
      "30: int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrLen);",
      "",
      "[Added Lines]",
      "30: int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrLen,",
      "31:                 unsigned char type, unsigned char decryptable, uint64_t* resultLen);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "36: void derive_DH_Key();",
      "39: #endif //SGXD_AESUTILS_H",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "39: #define ECDSA '1'",
      "40: #define BLS '2'",
      "41: #define DKG '3'",
      "43: #define DECRYPTABLE '1'",
      "44: #define NON_DECRYPTABLE '2'",
      "",
      "---------------"
    ],
    "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c": [
      "File: secure_enclave/secure_enclave.c -> secure_enclave/secure_enclave.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "122:         abort(); \\",
      "123:     } else {called = true;};",
      "126:     CALL_ONCE",
      "127:     LOG_INFO(__FUNCTION__);",
      "",
      "[Removed Lines]",
      "125: void trustedEnclaveInit(uint32_t _logLevel) {",
      "",
      "[Added Lines]",
      "125: void trustedEnclaveInit(uint64_t _logLevel) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "234: void sealHexSEK(int *errStatus, char *errString,",
      "236:     CALL_ONCE",
      "237:     LOG_INFO(__FUNCTION__);",
      "238:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "235:                         uint8_t *encrypted_sek, uint32_t *enc_len, char *sek_hex) {",
      "",
      "[Added Lines]",
      "235:                         uint8_t *encrypted_sek, uint64_t *enc_len, char *sek_hex) {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "255:                                            (sgx_sealed_data_t *) encrypted_sek);",
      "256:     CHECK_STATUS(\"seal SEK failed after SEK generation\");",
      "260:     CHECK_STATE(encrypt_text_length = plaintextLen);",
      "",
      "[Removed Lines]",
      "258:     uint32_t encrypt_text_length = sgx_get_encrypt_txt_len((const sgx_sealed_data_t *)encrypted_sek);",
      "",
      "[Added Lines]",
      "258:     uint64_t encrypt_text_length = sgx_get_encrypt_txt_len((const sgx_sealed_data_t *)encrypted_sek);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "263:     SAFE_CHAR_BUF(unsealedKey, BUF_LEN);",
      "264:     uint32_t decLen = BUF_LEN;",
      "267:     CHECK_STATE(add_text_length == 0);",
      "268:     CHECK_STATE(sgx_is_within_enclave(encrypted_sek,sizeof(sgx_sealed_data_t)));",
      "269:     status = sgx_unseal_data((const sgx_sealed_data_t *)encrypted_sek, NULL, NULL,",
      "",
      "[Removed Lines]",
      "266:     uint32_t add_text_length = sgx_get_add_mac_txt_len((const sgx_sealed_data_t *)encrypted_sek);",
      "",
      "[Added Lines]",
      "266:     uint64_t add_text_length = sgx_get_add_mac_txt_len((const sgx_sealed_data_t *)encrypted_sek);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "279: }",
      "281: void trustedGenerateSEK(int *errStatus, char *errString,",
      "283:     CALL_ONCE",
      "284:     LOG_INFO(__FUNCTION__);",
      "285:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "282:                         uint8_t *encrypted_sek, uint32_t *enc_len, char *sek_hex) {",
      "",
      "[Added Lines]",
      "282:                         uint8_t *encrypted_sek, uint64_t *enc_len, char *sek_hex) {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "341: }",
      "343: void trustedSetSEK_backup(int *errStatus, char *errString,",
      "345:     CALL_ONCE",
      "346:     LOG_INFO(__FUNCTION__);",
      "347:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "344:                           uint8_t *encrypted_sek, uint32_t *enc_len, const char *sek_hex) {",
      "",
      "[Added Lines]",
      "344:                           uint8_t *encrypted_sek, uint64_t *enc_len, const char *sek_hex) {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "372: void trustedGenerateEcdsaKeyAES(int *errStatus, char *errString,",
      "374:     LOG_INFO(__FUNCTION__);",
      "375:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "373:                                 uint8_t *encryptedPrivateKey, uint32_t *enc_len, char *pub_key_x, char *pub_key_y) {",
      "",
      "[Added Lines]",
      "373:                                 uint8_t *encryptedPrivateKey, uint64_t *enc_len, char *pub_key_x, char *pub_key_y) {",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "410:     }",
      "411:     strncpy(pub_key_y + n_zeroes, arr_y, 1024 - n_zeroes);",
      "414:     mpz_get_str(arr_skey_str, ECDSA_SKEY_BASE, skey);",
      "415:     n_zeroes = 64 - strlen(arr_skey_str);",
      "416:     for (int i = 0; i < n_zeroes; i++) {",
      "417:         skey_str[i] = '0';",
      "418:     }",
      "419:     strncpy(skey_str + n_zeroes, arr_skey_str, 65 - n_zeroes);",
      "421:     snprintf(errString, BUF_LEN, \"skey len is %d\\n\", (int) strlen(skey_str));",
      "424:     CHECK_STATUS(\"ecdsa private key encryption failed\");",
      "430:     CHECK_STATUS2(\"ecdsa private key decr failed with status %d\");",
      "",
      "[Removed Lines]",
      "413:     SAFE_CHAR_BUF(skey_str, ECDSA_SKEY_LEN);SAFE_CHAR_BUF(arr_skey_str, mpz_sizeinbase(skey, ECDSA_SKEY_BASE) + 2);",
      "420:     skey_str[ECDSA_SKEY_LEN - 1] = 0;",
      "423:     int status = AES_encrypt((char *) skey_str, encryptedPrivateKey, BUF_LEN);",
      "428:     status = AES_decrypt(encryptedPrivateKey, *enc_len, skey_str, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "413:     SAFE_CHAR_BUF(skey_str, BUF_LEN);",
      "414:     SAFE_CHAR_BUF(arr_skey_str, mpz_sizeinbase(skey, ECDSA_SKEY_BASE) + 2);",
      "423:     int status = AES_encrypt((char *) skey_str, encryptedPrivateKey, BUF_LEN,",
      "424:                              ECDSA, NON_DECRYPTABLE, enc_len);",
      "427:     status = AES_decrypt(encryptedPrivateKey, *enc_len, skey_str, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "439: }",
      "441: void trustedGetPublicEcdsaKeyAES(int *errStatus, char *errString,",
      "443:     LOG_DEBUG(__FUNCTION__);",
      "444:     INIT_ERROR_STATE",
      "448:     mpz_t privateKeyMpz;",
      "449:     mpz_init(privateKeyMpz);",
      "",
      "[Removed Lines]",
      "442:                                  uint8_t *encryptedPrivateKey, uint32_t enc_len, char *pub_key_x, char *pub_key_y) {",
      "446:     SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "441:                                  uint8_t *encryptedPrivateKey, uint64_t enc_len, char *pub_key_x, char *pub_key_y) {",
      "445:     SAFE_CHAR_BUF(skey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "455:     CHECK_STATE(pub_key_x);",
      "456:     CHECK_STATE(pub_key_y);",
      "459:     CHECK_STATUS2(\"AES_decrypt failed with status %d\");",
      "461:     skey[enc_len - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE] = '\\0';",
      "",
      "[Removed Lines]",
      "458:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "457:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "516: static uint64_t sigCounter = 0;",
      "519:                          const char *hash, char *sigR, char *sigS, uint8_t *sig_v, int base) {",
      "520:     LOG_DEBUG(__FUNCTION__);",
      "",
      "[Removed Lines]",
      "518: void trustedEcdsaSignAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint32_t enc_len,",
      "",
      "[Added Lines]",
      "517: void trustedEcdsaSignAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint64_t enc_len,",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "526:     CHECK_STATE(sigR);",
      "527:     CHECK_STATE(sigS);",
      "531:     mpz_t privateKeyMpz;",
      "532:     mpz_init(privateKeyMpz);",
      "",
      "[Removed Lines]",
      "529:     SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "528:     SAFE_CHAR_BUF(skey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "534:     mpz_init(msgMpz);",
      "535:     signature sign = signature_init();",
      "539:     CHECK_STATUS2(\"aes decrypt failed with status %d\");",
      "",
      "[Removed Lines]",
      "537:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "536:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "602: void trustedDecryptKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,",
      "605:     LOG_DEBUG(__FUNCTION__);",
      "606:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "603:                           uint32_t enc_len, char *key) {",
      "",
      "[Added Lines]",
      "602:                           uint64_t enc_len, char *key) {",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "615:     if (status != 0) {",
      "",
      "[Removed Lines]",
      "613:     int status = AES_decrypt_DH(encryptedPrivateKey, enc_len, key, 3072);",
      "",
      "[Added Lines]",
      "612:     int status = AES_decrypt(encryptedPrivateKey, enc_len, key, 3072);",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "638: void trustedEncryptKeyAES(int *errStatus, char *errString, const char *key,",
      "640:     LOG_INFO(__FUNCTION__);",
      "",
      "[Removed Lines]",
      "639:                           uint8_t *encryptedPrivateKey, uint32_t *enc_len) {",
      "",
      "[Added Lines]",
      "638:                           uint8_t *encryptedPrivateKey, uint64_t *enc_len) {",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "652:     CHECK_STATUS2(\"AES encrypt failed with status %d\");",
      "656:     SAFE_CHAR_BUF(decryptedKey, BUF_LEN);",
      "660:     CHECK_STATUS2(\"trustedDecryptKey failed with status %d\");",
      "",
      "[Removed Lines]",
      "650:     int status = AES_encrypt_DH((char *)key, encryptedPrivateKey, BUF_LEN);",
      "658:     status = AES_decrypt_DH(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN);",
      "",
      "[Added Lines]",
      "649:     int status = AES_encrypt((char *)key, encryptedPrivateKey, BUF_LEN,",
      "650:                              DKG, DECRYPTABLE, enc_len);",
      "656:     status = AES_decrypt(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "672:     if (strncmp(key, decryptedKey, MAX_KEY_LENGTH) != 0) {",
      "673:         snprintf(errString, BUF_LEN, \"Decrypted key does not match original key\");",
      "674:         LOG_ERROR(errString);",
      "675:         goto clean;",
      "676:     }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "672:         LOG_ERROR(key);",
      "673:         LOG_ERROR(decryptedKey);",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "686: void trustedBlsSignMessageAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,",
      "688:                               char *_hashY, char *signature) {",
      "689:     LOG_DEBUG(__FUNCTION__);",
      "690:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "687:                               uint32_t enc_len, char *_hashX,",
      "",
      "[Added Lines]",
      "687:                               uint64_t enc_len, char *_hashX,",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "726: }",
      "728: void",
      "730:     LOG_INFO(__FUNCTION__);",
      "731:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "729: trustedGenDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t *enc_len, size_t _t) {",
      "",
      "[Added Lines]",
      "729: trustedGenDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint64_t *enc_len, size_t _t) {",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "739:     CHECK_STATUS(\"gen_dkg_poly failed\")",
      "743:     CHECK_STATUS(\"SGX AES encrypt DKG poly failed\");",
      "747:     SAFE_CHAR_BUF(decr_dkg_secret, DKG_BUFER_LENGTH);",
      "",
      "[Removed Lines]",
      "741:     status = AES_encrypt(dkg_secret, encrypted_dkg_secret, 3 * BUF_LEN);",
      "",
      "[Added Lines]",
      "741:     status = AES_encrypt(dkg_secret, encrypted_dkg_secret, 3 * BUF_LEN,",
      "742:                          DKG, DECRYPTABLE, enc_len);",
      "",
      "---------------",
      "--- Hunk 22 ---",
      "[Context before]",
      "769: void",
      "770: trustedDecryptDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret,",
      "772:                            uint8_t *decrypted_dkg_secret) {",
      "773:     LOG_INFO(__FUNCTION__);",
      "774:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "771:                            uint32_t enc_len,",
      "",
      "[Added Lines]",
      "772:                            uint64_t enc_len,",
      "",
      "---------------",
      "--- Hunk 23 ---",
      "[Context before]",
      "790: }",
      "794:     LOG_INFO(__FUNCTION__);",
      "795:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "793: void trustedSetEncryptedDkgPolyAES(int *errStatus, char *errString, uint8_t *encrypted_poly, uint32_t enc_len) {",
      "",
      "[Added Lines]",
      "794: void trustedSetEncryptedDkgPolyAES(int *errStatus, char *errString, uint8_t *encrypted_poly, uint64_t enc_len) {",
      "",
      "---------------",
      "--- Hunk 24 ---",
      "[Context before]",
      "810:     LOG_INFO(\"SGX call completed\");",
      "811: }",
      "814:                                        char *result_str, char *s_shareG2, char *pub_keyB, uint8_t _t, uint8_t _n,",
      "815:                                        uint8_t ind) {",
      "817:     LOG_INFO(__FUNCTION__);",
      "818:     INIT_ERROR_STATE",
      "821:     int status;",
      "823:     CHECK_STATE(encrypted_skey);",
      "",
      "[Removed Lines]",
      "813: void trustedGetEncryptedSecretShareAES(int *errStatus, char *errString, uint8_t *encrypted_skey, uint32_t *dec_len,",
      "820:     uint32_t enc_len;",
      "",
      "[Added Lines]",
      "814: void trustedGetEncryptedSecretShareAES(int *errStatus, char *errString, uint8_t *encrypted_skey, uint64_t *dec_len,",
      "821:     uint64_t enc_len;",
      "",
      "---------------",
      "--- Hunk 25 ---",
      "[Context before]",
      "828:     LOG_DEBUG(__FUNCTION__);",
      "832:     SAFE_CHAR_BUF(pub_key_x, BUF_LEN);SAFE_CHAR_BUF(pub_key_y, BUF_LEN);",
      "",
      "[Removed Lines]",
      "830:     SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "831:     SAFE_CHAR_BUF(skey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 26 ---",
      "[Context before]",
      "836:     CHECK_STATUS(\"trustedGenerateEcdsaKeyAES failed\");",
      "840:     skey[ECDSA_SKEY_LEN - 1] = 0;",
      "",
      "[Removed Lines]",
      "838:     status = AES_decrypt(encrypted_skey, enc_len, skey, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "839:     status = AES_decrypt(encrypted_skey, enc_len, skey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 27 ---",
      "[Context before]",
      "848:     status = gen_session_key(skey, pub_keyB, common_key);",
      "850:     CHECK_STATUS(\"gen_session_key failed\")",
      "854:     status = calc_secret_share(getThreadLocalDecryptedDkgPoly(), s_share, _t, _n, ind);",
      "855:     CHECK_STATUS(\"calc secret share failed\")",
      "",
      "[Removed Lines]",
      "846:     SAFE_CHAR_BUF(common_key, ECDSA_SKEY_LEN);",
      "852:     SAFE_CHAR_BUF(s_share, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "847:     SAFE_CHAR_BUF(common_key, BUF_LEN);",
      "853:     SAFE_CHAR_BUF(s_share, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 28 ---",
      "[Context before]",
      "858:     status = calc_secret_shareG2(s_share, s_shareG2);",
      "859:     CHECK_STATUS(\"invalid decr secret share\");",
      "862:     status=xor_encrypt(common_key, s_share, cypher);",
      "864:     CHECK_STATUS(\"xor_encrypt failed\")",
      "",
      "[Removed Lines]",
      "861:     SAFE_CHAR_BUF(cypher, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "862:     SAFE_CHAR_BUF(cypher, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 29 ---",
      "[Context before]",
      "875:     LOG_INFO(\"SGX call completed\");",
      "876: }",
      "879:                                char *public_shares,",
      "880:                                unsigned _t, unsigned _n) {",
      "881:     LOG_INFO(__FUNCTION__);",
      "",
      "[Removed Lines]",
      "878: void trustedGetPublicSharesAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t enc_len,",
      "",
      "[Added Lines]",
      "879: void trustedGetPublicSharesAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint64_t enc_len,",
      "",
      "---------------",
      "--- Hunk 30 ---",
      "[Context before]",
      "913:     CHECK_STATE(s_share);",
      "914:     CHECK_STATE(encryptedPrivateKey);",
      "918:     mpz_t s;",
      "919:     mpz_init(s);",
      "923:     CHECK_STATUS2(\"AES_decrypt failed (in trustedDkgVerifyAES) with status %d\");",
      "927:     strncpy(encr_sshare, s_share, ECDSA_SKEY_LEN - 1);",
      "931:     status = session_key_recover(skey, s_share, common_key);",
      "933:     CHECK_STATUS(\"session_key_recover failed\");",
      "937:     status=xor_decrypt(common_key, encr_sshare, decr_sshare);",
      "",
      "[Removed Lines]",
      "916:     SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);",
      "921:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);",
      "925:     SAFE_CHAR_BUF(encr_sshare, ECDSA_SKEY_LEN);",
      "929:     SAFE_CHAR_BUF(common_key, ECDSA_SKEY_LEN);",
      "935:     SAFE_CHAR_BUF(decr_sshare, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "917:     SAFE_CHAR_BUF(skey,BUF_LEN);",
      "922:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);",
      "926:     SAFE_CHAR_BUF(encr_sshare, BUF_LEN);",
      "930:     SAFE_CHAR_BUF(common_key, BUF_LEN);",
      "936:     SAFE_CHAR_BUF(decr_sshare, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 31 ---",
      "[Context before]",
      "955: void trustedCreateBlsKeyAES(int *errStatus, char *errString, const char *s_shares,",
      "956:                             uint8_t *encryptedPrivateKey, uint64_t key_len, uint8_t *encr_bls_key,",
      "959:     LOG_INFO(__FUNCTION__);",
      "",
      "[Removed Lines]",
      "957:                             uint32_t *enc_bls_key_len) {",
      "",
      "[Added Lines]",
      "958:                             uint64_t *enc_bls_key_len) {",
      "",
      "---------------",
      "--- Hunk 32 ---",
      "[Context before]",
      "964:     CHECK_STATE(encryptedPrivateKey);",
      "965:     CHECK_STATE(encr_bls_key);",
      "969:     mpz_t sum;",
      "970:     mpz_init(sum);",
      "",
      "[Removed Lines]",
      "967:     SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "968:     SAFE_CHAR_BUF(skey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 33 ---",
      "[Context before]",
      "978:     mpz_init(bls_key);",
      "982:     CHECK_STATUS2(\"aes decrypt failed with status %d\");",
      "984:     skey[ECDSA_SKEY_LEN - 1] = 0;",
      "",
      "[Removed Lines]",
      "981:     int status = AES_decrypt(encryptedPrivateKey, key_len, skey, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "982:     int status = AES_decrypt(encryptedPrivateKey, key_len, skey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 34 ---",
      "[Context before]",
      "1038:     strncpy(key_share + n_zeroes, arr_skey_str, 65 - n_zeroes);",
      "1039:     key_share[BLS_KEY_LENGTH - 1] = 0;",
      "1043:     CHECK_STATUS2(\"aes encrypt bls private key failed with status %d \");",
      "1047:     SET_SUCCESS",
      "1048:     clean:",
      "",
      "[Removed Lines]",
      "1041:     status = AES_encrypt(key_share, encr_bls_key, BUF_LEN);",
      "",
      "[Added Lines]",
      "1042:     status = AES_encrypt(key_share, encr_bls_key, BUF_LEN, BLS, NON_DECRYPTABLE, enc_bls_key_len);",
      "",
      "---------------",
      "--- Hunk 35 ---",
      "[Context before]",
      "1064:     CHECK_STATE(bls_pub_key);",
      "1065:     CHECK_STATE(encryptedPrivateKey);",
      "1071:     CHECK_STATUS2(\"AES decrypt failed %d\");",
      "",
      "[Removed Lines]",
      "1067:     SAFE_CHAR_BUF(skey_hex, ECDSA_SKEY_LEN);",
      "1069:     int status = AES_decrypt(encryptedPrivateKey, key_len, skey_hex, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "1066:     SAFE_CHAR_BUF(skey_hex, BUF_LEN);",
      "1068:     int status = AES_decrypt(encryptedPrivateKey, key_len, skey_hex, BUF_LEN);",
      "",
      "---------------"
    ],
    "secure_enclave/secure_enclave.edl||secure_enclave/secure_enclave.edl": [
      "File: secure_enclave/secure_enclave.edl -> secure_enclave/secure_enclave.edl",
      "--- Hunk 1 ---",
      "[Context before]",
      "11:  trusted {",
      "12:   include \"sgx_tgmp.h\"",
      "17:         public void trustedGenerateSEK(",
      "18:                                 [out] int *errStatus,",
      "19:                                 [out, count = SMALL_BUF_SIZE] char *err_string,",
      "20:                                 [out, count = SMALL_BUF_SIZE] uint8_t *encrypted_SEK,",
      "22:                                 [out, count = 65] char* hex_SEK);",
      "24:         public void trustedSetSEK(",
      "",
      "[Removed Lines]",
      "14:   public void trustedEnclaveInit(uint32_t _logLevel);",
      "21:                                 [out] uint32_t *enc_len,",
      "",
      "[Added Lines]",
      "14:   public void trustedEnclaveInit(uint64_t _logLevel);",
      "21:                                 [out] uint64_t *enc_len,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "30:                                 [out] int *errStatus,",
      "31:                                 [out, count = SMALL_BUF_SIZE] char *err_string,",
      "32:                                 [out, count = SMALL_BUF_SIZE] uint8_t *encrypted_SEK,",
      "34:                                 [in, string] const char* SEK_hex);",
      "36:         public void trustedGenerateEcdsaKeyAES (",
      "37:                                 [out] int *errStatus,",
      "38:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "39:                                 [out, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,",
      "41:                                 [out, count = SMALL_BUF_SIZE] char * pub_key_x,",
      "42:                                 [out, count = SMALL_BUF_SIZE] char * pub_key_y);",
      "",
      "[Removed Lines]",
      "33:                                 [out] uint32_t *enc_len,",
      "40:                                 [out] uint32_t *enc_len,",
      "",
      "[Added Lines]",
      "33:                                 [out] uint64_t *enc_len,",
      "40:                                 [out] uint64_t *enc_len,",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "45:                                 [out] int *errStatus,",
      "46:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "47:                                 [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,",
      "49:                                 [out, count = SMALL_BUF_SIZE] char * pub_key_x,",
      "50:                                 [out, count = SMALL_BUF_SIZE] char * pub_key_y);",
      "",
      "[Removed Lines]",
      "48:                                 uint32_t dec_len,",
      "",
      "[Added Lines]",
      "48:                                 uint64_t dec_len,",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "53:                                 [out] int *errStatus,",
      "54:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "55:                                 [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,",
      "57:                                 [in, string] const char* hash,",
      "58:                                 [out, count = SMALL_BUF_SIZE] char* sig_r,",
      "59:                                 [out, count = SMALL_BUF_SIZE] char* sig_s,",
      "",
      "[Removed Lines]",
      "56:                                 uint32_t enc_len,",
      "",
      "[Added Lines]",
      "56:                                 uint64_t enc_len,",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "65:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "66:                                 [in, count = SMALL_BUF_SIZE] const char* key,",
      "67:                                 [out, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,",
      "70:         public void trustedDecryptKeyAES (",
      "71:                                 [out] int *errStatus,",
      "72:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "73:                                 [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,",
      "75:                                 [out, count = SMALL_BUF_SIZE] char* key );",
      "77:         public void trustedGenDkgSecretAES (",
      "78:                                 [out] int *errStatus,",
      "79:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "80:                                 [out, count = 3072] uint8_t* encrypted_dkg_secret,",
      "83:         public void trustedDecryptDkgSecretAES (",
      "84:                                 [out] int *errStatus,",
      "85:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "86:                                 [in, count = 3050] uint8_t* encrypted_dkg_secret,",
      "88:                                 [out, count = 3072] uint8_t* decrypted_dkg_secret",
      "89:                                 );",
      "",
      "[Removed Lines]",
      "68:                                 [out] uint32_t *enc_len);",
      "74:                                 uint32_t enc_len,",
      "81:                                 [out] uint32_t * enc_len, size_t _t);",
      "87:                                 uint32_t enc_len,",
      "",
      "[Added Lines]",
      "68:                                 [out] uint64_t *enc_len);",
      "74:                                 uint64_t enc_len,",
      "81:                                 [out] uint64_t * enc_len, size_t _t);",
      "87:                                 uint64_t enc_len,",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "92:                                 [out] int *errStatus,",
      "93:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "94:                                 [in, count = 3050] uint8_t* encrypted_poly,",
      "97:         public void trustedGetEncryptedSecretShareAES(",
      "98:                                 [out]int *errStatus,",
      "99:                                 [out, count = SMALL_BUF_SIZE] char *err_string,",
      "100:                                 [out, count = SMALL_BUF_SIZE] uint8_t *encrypted_skey,",
      "102:                                 [out, count = 193] char* result_str,",
      "103:                                 [out, count = 320] char* s_shareG2,",
      "104:                                 [in, string] char* pub_keyB,",
      "",
      "[Removed Lines]",
      "95:                                 uint32_t enc_len);",
      "101:                                 [out] uint32_t* dec_len,",
      "",
      "[Added Lines]",
      "95:                                 uint64_t enc_len);",
      "101:                                 [out] uint64_t* dec_len,",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "110:                                 [out] int *errStatus,",
      "111:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "112:                                 [in, count = 3050] uint8_t* encrypted_dkg_secret,",
      "114:                                 [out, count = 10000] char* public_shares,",
      "115:                                 unsigned _t,",
      "116:                                 unsigned _n);",
      "",
      "[Removed Lines]",
      "113:                                 uint32_t enc_len,",
      "",
      "[Added Lines]",
      "113:                                 uint64_t enc_len,",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "133:                                 [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,",
      "134:                                 uint64_t key_len,",
      "135:                                 [out, count = SMALL_BUF_SIZE] uint8_t * encr_bls_key,",
      "138:         public void trustedBlsSignMessageAES (",
      "139:                                 [out] int *errStatus,",
      "140:                                 [out, count = TINY_BUF_SIZE] char* err_string,",
      "141:                                 [in, count = TINY_BUF_SIZE] uint8_t* encrypted_key,",
      "143:                                 [in, string] char* hashX ,",
      "144:                                 [in, string] char* hashY,",
      "145:                                 [out, count = SMALL_BUF_SIZE] char* signature);",
      "",
      "[Removed Lines]",
      "136:                                 [out] uint32_t *enc_bls_key_len);",
      "142:                                 uint32_t enc_len,",
      "",
      "[Added Lines]",
      "136:                                 [out] uint64_t *enc_bls_key_len);",
      "142:                                 uint64_t enc_len,",
      "",
      "---------------"
    ],
    "testw.cpp||testw.cpp": [
      "File: testw.cpp -> testw.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "127:     vector<char> pubKeyX(BUF_LEN, 0);",
      "128:     vector<char> pubKeyY(BUF_LEN, 0);",
      "131:     PRINT_SRC_LINE",
      "132:     auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encrPrivKey.data(), &encLen,",
      "133:                                              pubKeyX.data(),",
      "",
      "[Removed Lines]",
      "130:     uint32_t encLen = 0;",
      "",
      "[Added Lines]",
      "130:     uint64_t encLen = 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "160:     vector <uint8_t> encrPrivKey(BUF_LEN, 0);",
      "161:     vector<char> pubKeyX(BUF_LEN, 0);",
      "162:     vector<char> pubKeyY(BUF_LEN, 0);",
      "164:     PRINT_SRC_LINE",
      "165:     auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encrPrivKey.data(), &encLen,",
      "166:                                              pubKeyX.data(),",
      "",
      "[Removed Lines]",
      "163:     uint32_t encLen = 0;",
      "",
      "[Added Lines]",
      "163:     uint64_t encLen = 0;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "177:     vector <uint8_t> encPrivKey(BUF_LEN, 0);",
      "178:     vector<char> pubKeyX(BUF_LEN, 0);",
      "179:     vector<char> pubKeyY(BUF_LEN, 0);",
      "182:     PRINT_SRC_LINE",
      "183:     auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encPrivKey.data(), &encLen, pubKeyX.data(),",
      "",
      "[Removed Lines]",
      "180:     uint32_t encLen = 0;",
      "",
      "[Added Lines]",
      "181:     uint64_t encLen = 0;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "291:     vector<char> errMsg(BUF_LEN, 0);",
      "293:     int errStatus = 0;",
      "296:     PRINT_SRC_LINE",
      "297:     auto status = trustedGenDkgSecretAES(eid, &errStatus, errMsg.data(), encryptedDKGSecret.data(), &encLen, 32);",
      "",
      "[Removed Lines]",
      "294:     uint32_t encLen = 0;",
      "",
      "[Added Lines]",
      "295:     uint64_t encLen = 0;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "314:     vector<char> errMsg(BUF_LEN, 0);",
      "316:     int errStatus = 0;",
      "319:     unsigned t = 32, n = 32;",
      "320:     PRINT_SRC_LINE",
      "",
      "[Removed Lines]",
      "317:     uint32_t encLen = 0;",
      "",
      "[Added Lines]",
      "318:     uint64_t encLen = 0;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "363:     vector<char> result(BUF_LEN, 0);",
      "365:     int errStatus = 0;",
      "368:     vector <uint8_t> encryptedDKGSecret(BUF_LEN, 0);",
      "369:     PRINT_SRC_LINE",
      "",
      "[Removed Lines]",
      "366:     uint32_t encLen = 0;",
      "",
      "[Added Lines]",
      "367:     uint64_t encLen = 0;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "694: TEST_CASE_METHOD(TestFixture, \"AES encrypt/decrypt\", \"[aes-encrypt-decrypt]\") {",
      "695:     int errStatus = 0;",
      "696:     vector<char> errMsg(BUF_LEN, 0);",
      "698:     string key = SAMPLE_AES_KEY;",
      "699:     vector <uint8_t> encrypted_key(BUF_LEN, 0);",
      "",
      "[Removed Lines]",
      "697:     uint32_t encLen;",
      "",
      "[Added Lines]",
      "698:     uint64_t encLen;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f0203c2509cf6841a7064a4f4717f0a98d7251ae",
      "candidate_info": {
        "commit_hash": "f0203c2509cf6841a7064a4f4717f0a98d7251ae",
        "repo": "skalenetwork/sgxwallet",
        "commit_url": "https://github.com/skalenetwork/sgxwallet/commit/f0203c2509cf6841a7064a4f4717f0a98d7251ae",
        "files": [
          "BLSCrypto.cpp",
          "BLSPrivateKeyShareSGX.cpp",
          "DKGCrypto.cpp",
          "ECDSACrypto.cpp",
          "SEKManager.cpp",
          "ServerInit.cpp",
          "secure_enclave/secure_enclave.c"
        ],
        "message": "SKALE-3205",
        "before_after_code_files": [
          "BLSCrypto.cpp||BLSCrypto.cpp",
          "BLSPrivateKeyShareSGX.cpp||BLSPrivateKeyShareSGX.cpp",
          "DKGCrypto.cpp||DKGCrypto.cpp",
          "ECDSACrypto.cpp||ECDSACrypto.cpp",
          "SEKManager.cpp||SEKManager.cpp",
          "ServerInit.cpp||ServerInit.cpp",
          "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "BLSCrypto.cpp||BLSCrypto.cpp",
            "DKGCrypto.cpp||DKGCrypto.cpp",
            "ECDSACrypto.cpp||ECDSACrypto.cpp",
            "SEKManager.cpp||SEKManager.cpp",
            "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c"
          ],
          "candidate": [
            "BLSCrypto.cpp||BLSCrypto.cpp",
            "DKGCrypto.cpp||DKGCrypto.cpp",
            "ECDSACrypto.cpp||ECDSACrypto.cpp",
            "SEKManager.cpp||SEKManager.cpp",
            "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c"
          ]
        }
      },
      "candidate_diff": {
        "BLSCrypto.cpp||BLSCrypto.cpp": [
          "File: BLSCrypto.cpp -> BLSCrypto.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "58:     _fq->as_bigint().to_mpz(t);",
          "62:     mpz_get_str(arr, 10, t);",
          "63:     mpz_clear(t);",
          "",
          "[Removed Lines]",
          "60:     SAFE_CHAR_BUF(arr,mpz_sizeinbase(t, 10) + 2);",
          "",
          "[Added Lines]",
          "58:     SAFE_CHAR_BUF(arr, mpz_sizeinbase(t, 10) + 2);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "95: }",
          "99: bool hex2carray(const char *_hex, uint64_t *_bin_len,",
          "103:     CHECK_STATE(_hex);",
          "",
          "[Removed Lines]",
          "100:                  uint8_t *_bin, uint64_t _max_length) {",
          "",
          "[Added Lines]",
          "97:                 uint8_t *_bin, uint64_t _max_length) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "110:     CHECK_STATE(len != 2 * _max_length + 1);",
          "115:     if (len == 0 && len % 2 == 1)",
          "",
          "[Removed Lines]",
          "112:     CHECK_STATE(len <= 2 * _max_length );",
          "",
          "[Added Lines]",
          "109:     CHECK_STATE(len <= 2 * _max_length);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "142:     auto keyStr = make_shared<string>(_encryptedKeyHex);",
          "146:     uint64_t binLen;",
          "",
          "[Removed Lines]",
          "144:     auto hash = make_shared<array<uint8_t, 32>>();",
          "",
          "[Added Lines]",
          "141:     auto hash = make_shared < array < uint8_t,",
          "142:     32 >> ();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "166:     CHECK_STATE(_hashHex);",
          "167:     CHECK_STATE(_sig);",
          "171:     uint64_t binLen;",
          "",
          "[Removed Lines]",
          "169:     auto hash = make_shared<array<uint8_t, 32>>();",
          "",
          "[Added Lines]",
          "167:     auto hash = make_shared < array < uint8_t,",
          "168:     32 >> ();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "174:         throw SGXException(INVALID_HEX, \"Invalid hash\");",
          "175:     }",
          "178:     obj = make_shared<signatures::Bls>(signatures::Bls(_t, _n));",
          "182:     string *xStr = FqToString(&(hash_with_hint.first.X));",
          "",
          "[Removed Lines]",
          "177:     shared_ptr<signatures::Bls> obj;",
          "180:     pair<libff::alt_bn128_G1, string> hash_with_hint = obj->HashtoG1withHint(hash);",
          "",
          "[Added Lines]",
          "176:     shared_ptr <signatures::Bls> obj;",
          "179:     pair <libff::alt_bn128_G1, string> hash_with_hint = obj->HashtoG1withHint(hash);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "190:         BOOST_THROW_EXCEPTION(runtime_error(\"Null yStr\"));",
          "191:     }",
          "199:     strncpy(xStrArg, xStr->c_str(), BUF_LEN);",
          "200:     strncpy(yStrArg, yStr->c_str(), BUF_LEN);",
          "",
          "[Removed Lines]",
          "193:     vector<char> errMsg(BUF_LEN,0);",
          "195:     SAFE_CHAR_BUF(xStrArg,BUF_LEN);",
          "196:     SAFE_CHAR_BUF(yStrArg,BUF_LEN);",
          "197:     SAFE_CHAR_BUF(signature,BUF_LEN);",
          "",
          "[Added Lines]",
          "192:     vector<char> errMsg(BUF_LEN, 0);",
          "194:     SAFE_CHAR_BUF(xStrArg, BUF_LEN);SAFE_CHAR_BUF(yStrArg, BUF_LEN);SAFE_CHAR_BUF(signature, BUF_LEN);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "205:     size_t sz = 0;",
          "209:     bool result = hex2carray(_encryptedKeyHex, &sz, encryptedKey, BUF_LEN);",
          "",
          "[Removed Lines]",
          "207:     SAFE_UINT8_BUF(encryptedKey,BUF_LEN);",
          "",
          "[Added Lines]",
          "204:     SAFE_UINT8_BUF(encryptedKey, BUF_LEN);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "213:     }",
          "215:     int errStatus = 0;",
          "219:     HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());",
          "221:     string hint = BLSutils::ConvertToString(hash_with_hint.first.Y) + \":\" + hash_with_hint.second;",
          "",
          "[Removed Lines]",
          "216:     sgx_status_t status =",
          "217:             trustedBlsSignMessageAES(eid, &errStatus, errMsg.data(), encryptedKey,",
          "218:                                  sz, xStrArg, yStrArg, signature);",
          "",
          "[Added Lines]",
          "215:     sgx_status_t status = SGX_SUCCESS;",
          "217:     {",
          "218:         READ_LOCK(initMutex);",
          "219:         status = trustedBlsSignMessageAES(eid, &errStatus, errMsg.data(), encryptedKey,",
          "220:                                           sz, xStrArg, yStrArg, signature);",
          "221:     }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "240:     CHECK_STATE(errStatus);",
          "241:     CHECK_STATE(err_string);",
          "242:     CHECK_STATE(_key);",
          "246:     vector<char> errMsg(BUF_LEN, 0);",
          "",
          "[Removed Lines]",
          "243:     auto keyArray = make_shared<vector<char>>(BUF_LEN, 0);",
          "244:     auto encryptedKey = make_shared<vector<uint8_t>>(BUF_LEN, 0);",
          "",
          "[Added Lines]",
          "246:     auto keyArray = make_shared < vector < char >> (BUF_LEN, 0);",
          "247:     auto encryptedKey = make_shared < vector < uint8_t >> (BUF_LEN, 0);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "251:     uint64_t encryptedLen = 0;",
          "255:     HANDLE_TRUSTED_FUNCTION_ERROR(status, *errStatus, errMsg.data());",
          "257:     SAFE_CHAR_BUF(resultBuf, 2 * BUF_LEN + 1);",
          "",
          "[Removed Lines]",
          "253:     sgx_status_t status = trustedEncryptKeyAES(eid, errStatus, errMsg.data(), keyArray->data(), encryptedKey->data(), &encryptedLen);",
          "",
          "[Added Lines]",
          "256:     sgx_status_t status = SGX_SUCCESS;",
          "257:     {",
          "258:         READ_LOCK(initMutex);",
          "259:         status = trustedEncryptKeyAES(eid, errStatus, errMsg.data(), keyArray->data(), encryptedKey->data(),",
          "260:                                       &encryptedLen);",
          "262:     }",
          "",
          "---------------"
        ],
        "BLSPrivateKeyShareSGX.cpp||BLSPrivateKeyShareSGX.cpp": [
          "File: BLSPrivateKeyShareSGX.cpp -> BLSPrivateKeyShareSGX.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "148:         BOOST_THROW_EXCEPTION(invalid_argument(\"Invalid hex encrypted key\"));",
          "149:     }",
          "155:     HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());",
          "",
          "[Removed Lines]",
          "151:     sgx_status_t status =",
          "152:             trustedBlsSignMessageAES(eid, &errStatus, errMsg.data(), encryptedKey,",
          "153:                                      encryptedKeyHex->size() / 2, xStrArg, yStrArg, signature);",
          "",
          "[Added Lines]",
          "151:     sgx_status_t status = SGX_SUCCESS;",
          "152:     {",
          "153:         READ_LOCK(initMutex);",
          "154:         status = trustedBlsSignMessageAES(eid, &errStatus, errMsg.data(), encryptedKey,",
          "155:                                           encryptedKeyHex->size() / 2, xStrArg, yStrArg, signature);",
          "156:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "162:     }",
          "164:     string hint = BLSutils::ConvertToString(hash_with_hint.first.Y) + \":\" +",
          "167:     string sig = signature;",
          "",
          "[Removed Lines]",
          "165:                        hash_with_hint.second;",
          "",
          "[Added Lines]",
          "168:                   hash_with_hint.second;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "183:     auto sig = make_shared<string>(signature);",
          "185:     shared_ptr <BLSSigShare> s = make_shared<BLSSigShare>(sig, _signerIndex, requiredSigners,",
          "188:     return s;",
          "189: }",
          "",
          "[Removed Lines]",
          "186:                                                                     totalSigners);",
          "",
          "[Added Lines]",
          "189:                                                           totalSigners);",
          "",
          "---------------"
        ],
        "DKGCrypto.cpp||DKGCrypto.cpp": [
          "File: DKGCrypto.cpp -> DKGCrypto.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "72:     field_elem.as_bigint().to_mpz(t);",
          "76:     mpz_get_str(arr, base, t);",
          "77:     mpz_clear(t);",
          "",
          "[Removed Lines]",
          "74:     SAFE_CHAR_BUF(arr,mpz_sizeinbase(t, base) + 2);",
          "",
          "[Added Lines]",
          "68:     SAFE_CHAR_BUF(arr, mpz_sizeinbase(t, base) + 2);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "93:             return ret;",
          "94:         }",
          "97:         mpz_get_str(arr, 10, dec);",
          "98:         ret = arr;",
          "99:     } catch (exception &e) {",
          "",
          "[Removed Lines]",
          "96:         SAFE_CHAR_BUF(arr,mpz_sizeinbase(dec, 10) + 2);",
          "",
          "[Added Lines]",
          "90:         SAFE_CHAR_BUF(arr, mpz_sizeinbase(dec, 10) + 2);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "140:     vector <uint8_t> encrypted_dkg_secret(BUF_LEN, 0);",
          "145:     HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());",
          "",
          "[Removed Lines]",
          "142:     sgx_status_t status = trustedGenDkgSecretAES(",
          "143:             eid, &errStatus,errMsg.data(), encrypted_dkg_secret.data(), &enc_len, _t);",
          "",
          "[Added Lines]",
          "136:     sgx_status_t status = SGX_SUCCESS;",
          "137:     {",
          "138:         READ_LOCK(initMutex);",
          "139:         status = trustedGenDkgSecretAES(",
          "140:                 eid, &errStatus, errMsg.data(), encrypted_dkg_secret.data(), &enc_len, _t);",
          "141:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "173:     }",
          "179:     HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());",
          "181:     vector <string> g2Strings = splitString(pubShares.data(), ',');",
          "",
          "[Removed Lines]",
          "177:     sgx_status_t status = trustedGetPublicSharesAES(eid, &errStatus, errMsg.data(), encrDKGPoly.data(), encLen,",
          "178:                                        pubShares.data(), t, n);",
          "",
          "[Added Lines]",
          "174:     sgx_status_t status = SGX_SUCCESS;",
          "176:     {",
          "177:         READ_LOCK(initMutex);",
          "178:         status = trustedGetPublicSharesAES(eid, &errStatus, errMsg.data(), encrDKGPoly.data(), encLen,",
          "179:                                            pubShares.data(), t, n);",
          "180:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "191: string",
          "192: getSecretShares(const string &_polyName, const char *_encryptedPolyHex, const vector <string> &_publicKeys,",
          "196:     CHECK_STATE(_encryptedPolyHex);",
          "",
          "[Removed Lines]",
          "193:                        int _t,",
          "194:                        int _n) {",
          "",
          "[Added Lines]",
          "195:                 int _t,",
          "196:                 int _n) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "202:     uint64_t encLen = 0;",
          "206:     if (!hex2carray(_encryptedPolyHex, &encLen, encrDKGPoly.data(), BUF_LEN)) {",
          "207:         throw SGXException(INVALID_HEX, \"Invalid encryptedPolyHex\");",
          "208:     }",
          "211:     HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg1.data());",
          "213:     string result;",
          "",
          "[Removed Lines]",
          "210:     sgx_status_t status = trustedSetEncryptedDkgPolyAES(eid, &errStatus, errMsg1.data(), encrDKGPoly.data(), encLen);",
          "",
          "[Added Lines]",
          "211:     sgx_status_t status = SGX_SUCCESS;",
          "212:     {",
          "213:         READ_LOCK(initMutex);",
          "214:         status = trustedSetEncryptedDkgPolyAES(eid, &errStatus, errMsg1.data(), encrDKGPoly.data(), encLen);",
          "215:     }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "227:         spdlog::debug(\"pubKeyB is {}\", pub_keyB);",
          "231:         HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg1.data());",
          "233:         spdlog::debug(\"cur_share is {}\", currentShare.data());",
          "",
          "[Removed Lines]",
          "229:         sgx_status_t status = trustedGetEncryptedSecretShareAES(eid, &errStatus, errMsg1.data(), encryptedSkey.data(), &decLen,",
          "230:                                           currentShare.data(), sShareG2.data(), pubKeyB.data(), _t, _n, i + 1);",
          "",
          "[Added Lines]",
          "234:         sgx_status_t status = SGX_SUCCESS;",
          "235:         {",
          "236:             READ_LOCK(initMutex);",
          "237:             status = trustedGetEncryptedSecretShareAES(eid, &errStatus, errMsg1.data(), encryptedSkey.data(), &decLen,",
          "238:                                                        currentShare.data(), sShareG2.data(), pubKeyB.data(), _t, _n,",
          "239:                                                        i + 1);",
          "240:         }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "271:         throw SGXException(INVALID_HEX, \"Invalid encryptedPolyHex\");",
          "272:     }",
          "275:     strncpy(pshares, publicShares, strlen(publicShares));",
          "279:     HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());",
          "281:     if (result == 2) {",
          "",
          "[Removed Lines]",
          "274:     SAFE_CHAR_BUF(pshares,8193);",
          "277:     sgx_status_t status = trustedDkgVerifyAES(eid, &errStatus, errMsg.data(), pshares, encr_sshare, encr_key, decKeyLen, t,",
          "278:                                               ind, &result);",
          "",
          "[Added Lines]",
          "284:     SAFE_CHAR_BUF(pshares, 8193);",
          "287:     sgx_status_t status = SGX_SUCCESS;",
          "288:     {",
          "289:         READ_LOCK(initMutex);",
          "290:         status = trustedDkgVerifyAES(eid, &errStatus, errMsg.data(), pshares, encr_sshare, encr_key, decKeyLen, t,",
          "291:                                      ind, &result);",
          "292:     }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "290:     CHECK_STATE(s_shares);",
          "291:     CHECK_STATE(encryptedKeyHex);",
          "294:     int errStatus = 0;",
          "299:     if (!hex2carray(encryptedKeyHex, &decKeyLen, encr_key, BUF_LEN)) {",
          "300:         throw SGXException(INVALID_HEX, \"Invalid encryptedKeyHex\");",
          "301:     }",
          "303:     uint64_t enc_bls_len = 0;",
          "308:     HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());",
          "312:     carray2Hex(encr_bls_key, enc_bls_len, hexBLSKey, 2 * BUF_LEN);",
          "",
          "[Removed Lines]",
          "293:     vector<char> errMsg(BUF_LEN,0);",
          "296:     uint64_t decKeyLen;",
          "297:     SAFE_UINT8_BUF(encr_bls_key,BUF_LEN);",
          "298:     SAFE_UINT8_BUF(encr_key,BUF_LEN);",
          "305:     sgx_status_t status = trustedCreateBlsKeyAES(eid, &errStatus, errMsg.data(), s_shares, encr_key, decKeyLen, encr_bls_key,",
          "306:                                                  &enc_bls_len);",
          "310:     SAFE_CHAR_BUF(hexBLSKey,2 * BUF_LEN)",
          "",
          "[Added Lines]",
          "307:     vector<char> errMsg(BUF_LEN, 0);",
          "310:     uint64_t decKeyLen;SAFE_UINT8_BUF(encr_bls_key, BUF_LEN);SAFE_UINT8_BUF(encr_key, BUF_LEN);",
          "317:     sgx_status_t status = SGX_SUCCESS;",
          "319:     {",
          "320:         READ_LOCK(initMutex);",
          "321:         status = trustedCreateBlsKeyAES(eid, &errStatus, errMsg.data(), s_shares, encr_key, decKeyLen, encr_bls_key,",
          "322:                                         &enc_bls_len);",
          "323:     }",
          "327:     SAFE_CHAR_BUF(hexBLSKey, 2 * BUF_LEN)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "331:         throw SGXException(INVALID_HEX, \"Invalid encryptedKeyHex\");",
          "332:     }",
          "337:     HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg1.data());",
          "339:     vector <string> pubKeyVect = splitString(pubKey, ':');",
          "",
          "[Removed Lines]",
          "334:     SAFE_CHAR_BUF(pubKey,320)",
          "336:     sgx_status_t status = trustedGetBlsPubKeyAES(eid, &errStatus, errMsg1.data(), encrKey, decKeyLen, pubKey);",
          "",
          "[Added Lines]",
          "351:     SAFE_CHAR_BUF(pubKey, 320)",
          "354:     sgx_status_t status = SGX_SUCCESS;",
          "355:     {",
          "356:         READ_LOCK(initMutex);",
          "357:         status = trustedGetBlsPubKeyAES(eid, &errStatus, errMsg1.data(), encrKey, decKeyLen, pubKey);",
          "358:     }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "406:     vector<char> hexEncrKey(2 * BUF_LEN, 0);",
          "410:     if (!hex2carray(hexEncrKeyPtr->c_str(), &dhEncLen, encryptedDHKey, BUF_LEN)) {",
          "411:         throw SGXException(INVALID_HEX, \"Invalid hexEncrKey\");",
          "412:     }",
          "",
          "[Removed Lines]",
          "408:     uint64_t dhEncLen = 0;",
          "409:     SAFE_UINT8_BUF(encryptedDHKey, BUF_LEN);",
          "",
          "[Added Lines]",
          "430:     uint64_t dhEncLen = 0;SAFE_UINT8_BUF(encryptedDHKey, BUF_LEN);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "416:     SAFE_CHAR_BUF(DHKey, ECDSA_SKEY_LEN);",
          "419:     HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg1.data());",
          "421:     return DHKey;",
          "",
          "[Removed Lines]",
          "418:     sgx_status_t status = trustedDecryptKeyAES(eid, &errStatus, errMsg1.data(), encryptedDHKey, dhEncLen, DHKey);",
          "",
          "[Added Lines]",
          "439:     sgx_status_t status = SGX_SUCCESS;",
          "440:     {",
          "441:         READ_LOCK(initMutex);",
          "442:         status = trustedDecryptKeyAES(eid, &errStatus, errMsg1.data(), encryptedDHKey, dhEncLen, DHKey);",
          "443:     }",
          "",
          "---------------"
        ],
        "ECDSACrypto.cpp||ECDSACrypto.cpp": [
          "File: ECDSACrypto.cpp -> ECDSACrypto.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "57:     uint64_t enc_len = 0;",
          "63:     HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus,errMsg.data());",
          "",
          "[Removed Lines]",
          "59:     sgx_status_t status = trustedGenerateEcdsaKeyAES(eid, &errStatus,",
          "60:                                         errMsg.data(), encr_pr_key.data(), &enc_len,",
          "61:                                         pub_key_x.data(), pub_key_y.data());",
          "",
          "[Added Lines]",
          "59:     sgx_status_t status = SGX_SUCCESS;",
          "61:     {",
          "62:         READ_LOCK(initMutex);",
          "63:         status = trustedGenerateEcdsaKeyAES(eid, &errStatus,",
          "64:                                    errMsg.data(), encr_pr_key.data(), &enc_len,",
          "65:                                    pub_key_x.data(), pub_key_y.data());",
          "66:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "99:         throw SGXException(INVALID_HEX, \"Invalid encryptedKeyHex\");",
          "100:     }",
          "105:     HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data())",
          "",
          "[Removed Lines]",
          "102:     sgx_status_t status = trustedGetPublicEcdsaKeyAES(eid, &errStatus,",
          "103:                                          errMsg.data(), encrPrKey.data(), enc_len, pubKeyX.data(), pubKeyY.data());",
          "",
          "[Added Lines]",
          "107:     sgx_status_t status = SGX_SUCCESS;",
          "109:     {",
          "110:         READ_LOCK(initMutex);",
          "111:         status = trustedGetPublicEcdsaKeyAES(eid, &errStatus,",
          "112:                                              errMsg.data(), encrPrKey.data(), enc_len, pubKeyX.data(), pubKeyY.data());",
          "113:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "184:         throw SGXException(INVALID_HEX, \"Invalid encryptedKeyHex\");",
          "185:     }",
          "192:     HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());",
          "",
          "[Removed Lines]",
          "187:     sgx_status_t status = trustedEcdsaSignAES(eid, &errStatus,",
          "188:             errMsg.data(), encryptedKey.data(), decLen, hashHex,",
          "189:                                  signatureR.data(),",
          "190:                                  signatureS.data(), &signatureV, base);",
          "",
          "[Added Lines]",
          "197:     sgx_status_t status = SGX_SUCCESS;",
          "199:     {",
          "200:         READ_LOCK(initMutex);",
          "201:         status = trustedEcdsaSignAES(eid, &errStatus,",
          "202:                             errMsg.data(), encryptedKey.data(), decLen, hashHex,",
          "203:                             signatureR.data(),",
          "204:                             signatureS.data(), &signatureV, base);",
          "205:     }",
          "",
          "---------------"
        ],
        "SEKManager.cpp||SEKManager.cpp": [
          "File: SEKManager.cpp -> SEKManager.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "59:     string key = TEST_VALUE;",
          "63:     HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());",
          "",
          "[Removed Lines]",
          "61:     sgx_status_t status = trustedEncryptKeyAES(eid, &errStatus, errMsg.data(), key.c_str(), encrypted_key, &enc_len);",
          "",
          "[Added Lines]",
          "61:     sgx_status_t status =  SGX_SUCCESS;",
          "63:     {",
          "64:         READ_LOCK(initMutex);",
          "65:         status = trustedEncryptKeyAES(eid, &errStatus, errMsg.data(), key.c_str(), encrypted_key, &enc_len);",
          "66:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "86:         exit(-1);",
          "87:     }",
          "91:     HANDLE_TRUSTED_FUNCTION_ERROR(status, err_status, errMsg.data());",
          "",
          "[Removed Lines]",
          "89:     sgx_status_t status = trustedDecryptKeyAES(eid, &err_status, errMsg.data(), encr_test_key.data(), len, decr_key.data());",
          "",
          "[Added Lines]",
          "94:     sgx_status_t status = SGX_SUCCESS;",
          "96:     {",
          "97:         READ_LOCK(initMutex);",
          "98:         status = trustedDecryptKeyAES(eid, &err_status, errMsg.data(), encr_test_key.data(), len, decr_key.data());",
          "99:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "112:     uint64_t l = 0;",
          "119:     HANDLE_TRUSTED_FUNCTION_ERROR(status, err_status, errMsg.data());",
          "121:     validate_SEK();",
          "123:     return encrypted_SEK;",
          "",
          "[Removed Lines]",
          "114:     sgx_status_t status = trustedSetSEK_backup(eid, &err_status, errMsg.data(), encrypted_SEK->data(), &l,",
          "115:                                                SEK.c_str());",
          "117:     encrypted_SEK->resize(l);",
          "",
          "[Added Lines]",
          "124:     sgx_status_t status = SGX_SUCCESS;",
          "126:     {",
          "127:         READ_LOCK(initMutex);",
          "128:         status = trustedSetSEK_backup(eid, &err_status, errMsg.data(), encrypted_SEK->data(), &l,",
          "129:                              SEK.c_str());",
          "130:     }",
          "135:     encrypted_SEK->resize(l);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "134:     spdlog::info(\"Generating backup key. Will be stored in backup_key.txt ... \");",
          "138:     HANDLE_TRUSTED_FUNCTION_ERROR(status, err_status, errMsg.data());",
          "",
          "[Removed Lines]",
          "136:     sgx_status_t status = trustedGenerateSEK(eid, &err_status, errMsg.data(), encrypted_SEK.data(), &enc_len, SEK);",
          "",
          "[Added Lines]",
          "153:     sgx_status_t status = SGX_SUCCESS;",
          "154:     {",
          "155:         READ_LOCK(initMutex);",
          "156:         status = trustedGenerateSEK(eid, &err_status, errMsg.data(), encrypted_SEK.data(), &enc_len, SEK);",
          "157:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "200:         throw SGXException(INVALID_HEX, \"Invalid encrypted SEK Hex\");",
          "201:     }",
          "205:     HANDLE_TRUSTED_FUNCTION_ERROR(status, err_status, errMsg.data());",
          "",
          "[Removed Lines]",
          "203:     sgx_status_t status = trustedSetSEK(eid, &err_status, errMsg.data(), encrypted_SEK);",
          "",
          "[Added Lines]",
          "224:     sgx_status_t status = SGX_SUCCESS;",
          "225:     {",
          "226:         READ_LOCK(initMutex);",
          "227:         status = trustedSetSEK(eid, &err_status, errMsg.data(), encrypted_SEK);",
          "228:     }",
          "",
          "---------------"
        ],
        "ServerInit.cpp||ServerInit.cpp": [
          "File: ServerInit.cpp -> ServerInit.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "67: }",
          "69: void initEnclave(uint32_t _logLevel) {",
          "73: #ifndef SGX_HW_SIM",
          "74:     unsigned long support;",
          "",
          "[Removed Lines]",
          "70:     eid = 0;",
          "71:     updated = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "82:     spdlog::info(\"SGX_DEBUG_FLAG = {}\", SGX_DEBUG_FLAG);",
          "93:         }",
          "101:     if (status != SGX_SUCCESS) {",
          "102:         spdlog::error(\"trustedEnclaveInit failed: {}\", status);",
          "",
          "[Removed Lines]",
          "84:     sgx_status_t status = sgx_create_enclave_search(ENCLAVE_NAME, SGX_DEBUG_FLAG, &token,",
          "85:                                        &updated, &eid, 0);",
          "87:     if (status != SGX_SUCCESS) {",
          "88:         if (status == SGX_ERROR_ENCLAVE_FILE_ACCESS) {",
          "89:             spdlog::error(\"sgx_create_enclave: {}: file not found\", ENCLAVE_NAME);",
          "90:             spdlog::error(\"Did you forget to set LD_LIBRARY_PATH?\");",
          "91:         } else {",
          "92:             spdlog::error(\"sgx_create_enclave_search failed {} {}\", ENCLAVE_NAME, status);",
          "94:         exit(1);",
          "95:     }",
          "97:     spdlog::info(\"Enclave created and started successfully\");",
          "99:     status = trustedEnclaveInit(eid, _logLevel);",
          "",
          "[Added Lines]",
          "82:     sgx_status_t status = SGX_SUCCESS;",
          "84:     {",
          "85:         READ_LOCK(initMutex);",
          "87:         eid = 0;",
          "88:         updated = 0;",
          "90:         status = sgx_create_enclave_search(ENCLAVE_NAME, SGX_DEBUG_FLAG, &token,",
          "91:                                            &updated, &eid, 0);",
          "93:         if (status != SGX_SUCCESS) {",
          "94:             if (status == SGX_ERROR_ENCLAVE_FILE_ACCESS) {",
          "95:                 spdlog::error(\"sgx_create_enclave: {}: file not found\", ENCLAVE_NAME);",
          "96:                 spdlog::error(\"Did you forget to set LD_LIBRARY_PATH?\");",
          "97:             } else {",
          "98:                 spdlog::error(\"sgx_create_enclave_search failed {} {}\", ENCLAVE_NAME, status);",
          "99:             }",
          "100:             exit(1);",
          "103:         spdlog::info(\"Enclave created and started successfully\");",
          "106:         status = trustedEnclaveInit(eid, _logLevel);",
          "107:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "146:         exception_ptr p = current_exception();",
          "147:         printf(\"Exception %s \\n\", p.__cxa_exception_type()->name());",
          "148:         spdlog::error(\"Unknown exception\");",
          "150:     }",
          "151: };",
          "",
          "[Removed Lines]",
          "149:         exit (-1);",
          "",
          "[Added Lines]",
          "157:         exit(-1);",
          "",
          "---------------"
        ],
        "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c": [
          "File: secure_enclave/secure_enclave.c -> secure_enclave/secure_enclave.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "293:     carray2Hex((uint8_t*) SEK_raw, SGX_AESGCM_KEY_SIZE, sek_hex);",
          "294:     memcpy(AES_key, SEK_raw, SGX_AESGCM_KEY_SIZE);",
          "297:     sealHexSEK(errStatus, errString, encrypted_sek, enc_len, sek_hex);",
          "",
          "[Removed Lines]",
          "295:     derive_DH_Key();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "334:     hex2carray(aes_key_hex, &len, (uint8_t *) AES_key);",
          "337:     SET_SUCCESS",
          "338:     clean:",
          "",
          "[Removed Lines]",
          "335:     derive_DH_Key();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "352:     uint64_t len;",
          "353:     hex2carray(sek_hex, &len, (uint8_t *) AES_key);",
          "356:     sealHexSEK(errStatus, errString, encrypted_sek, enc_len, (char *)sek_hex);",
          "",
          "[Removed Lines]",
          "354:     derive_DH_Key();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f0f043ad2d97e830032f7882a373703420ba66be",
      "candidate_info": {
        "commit_hash": "f0f043ad2d97e830032f7882a373703420ba66be",
        "repo": "skalenetwork/sgxwallet",
        "commit_url": "https://github.com/skalenetwork/sgxwallet/commit/f0f043ad2d97e830032f7882a373703420ba66be",
        "files": [
          "BLSCrypto.cpp",
          "DKGCrypto.cpp",
          "ECDSACrypto.cpp",
          "LevelDB.cpp",
          "SEKManager.cpp",
          "SGXRegistrationServer.cpp",
          "SGXRegistrationServer.h",
          "SGXWalletServer.cpp",
          "SGXWalletServer.h",
          "SGXWalletServer.hpp",
          "ServerInit.cpp",
          "docker/start.sh",
          "sgxwallet.c",
          "sgxwallet_common.h",
          "testw.cpp"
        ],
        "message": "Fix test",
        "before_after_code_files": [
          "BLSCrypto.cpp||BLSCrypto.cpp",
          "DKGCrypto.cpp||DKGCrypto.cpp",
          "ECDSACrypto.cpp||ECDSACrypto.cpp",
          "LevelDB.cpp||LevelDB.cpp",
          "SEKManager.cpp||SEKManager.cpp",
          "SGXRegistrationServer.cpp||SGXRegistrationServer.cpp",
          "SGXRegistrationServer.h||SGXRegistrationServer.h",
          "SGXWalletServer.cpp||SGXWalletServer.cpp",
          "SGXWalletServer.h||SGXWalletServer.h",
          "SGXWalletServer.hpp||SGXWalletServer.hpp",
          "ServerInit.cpp||ServerInit.cpp",
          "docker/start.sh||docker/start.sh",
          "sgxwallet.c||sgxwallet.c",
          "sgxwallet_common.h||sgxwallet_common.h",
          "testw.cpp||testw.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "BLSCrypto.cpp||BLSCrypto.cpp",
            "DKGCrypto.cpp||DKGCrypto.cpp",
            "ECDSACrypto.cpp||ECDSACrypto.cpp",
            "SEKManager.cpp||SEKManager.cpp",
            "SGXWalletServer.cpp||SGXWalletServer.cpp",
            "testw.cpp||testw.cpp"
          ],
          "candidate": [
            "BLSCrypto.cpp||BLSCrypto.cpp",
            "DKGCrypto.cpp||DKGCrypto.cpp",
            "ECDSACrypto.cpp||ECDSACrypto.cpp",
            "SEKManager.cpp||SEKManager.cpp",
            "SGXWalletServer.cpp||SGXWalletServer.cpp",
            "testw.cpp||testw.cpp"
          ]
        }
      },
      "candidate_diff": {
        "BLSCrypto.cpp||BLSCrypto.cpp": [
          "File: BLSCrypto.cpp -> BLSCrypto.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "306: bool bls_sign(const char* _encryptedKeyHex, const char* _hashHex, size_t _t, size_t _n, size_t _signerIndex,",
          "307:               char* _sig) {",
          "310:     return sign(_encryptedKeyHex, _hashHex, _t, _n, _signerIndex, _sig);",
          "311:   }",
          "312:   else{",
          "",
          "[Removed Lines]",
          "309:   if (!is_aes){",
          "",
          "[Added Lines]",
          "309:   if (!encryptKeys){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "327:     status = encrypt_key_aes(eid, errStatus, errMsg->data(), keyArray->data(), encryptedKey->data(), &encryptedLen);",
          "330:       spdlog::info(\"errStatus is {}\",*errStatus);",
          "331:       spdlog::info(\" errMsg is \", errMsg->data() );",
          "332:     }",
          "",
          "[Removed Lines]",
          "329:     if (DEBUG_PRINT) {",
          "",
          "[Added Lines]",
          "329:     if (printDebugInfo) {",
          "",
          "---------------"
        ],
        "DKGCrypto.cpp||DKGCrypto.cpp": [
          "File: DKGCrypto.cpp -> DKGCrypto.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "84:     uint32_t enc_len = 0;",
          "87:       status = gen_dkg_secret (eid, &err_status, errMsg.data(), encrypted_dkg_secret.data(), &enc_len, _t);",
          "88:     else",
          "89:       status = gen_dkg_secret_aes (eid, &err_status, errMsg.data(), encrypted_dkg_secret.data(), &enc_len, _t);",
          "",
          "[Removed Lines]",
          "86:     if (!is_aes)",
          "",
          "[Added Lines]",
          "86:     if (!encryptKeys)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "91:         throw RPCException(-666, errMsg.data() ) ;",
          "92:     }",
          "95:       spdlog::info(\"gen_dkg_secret, status {}\", err_status, \" err msg \", errMsg.data());",
          "96:       spdlog::info(\"in DKGCrypto encr len is {}\", enc_len);",
          "97:     }",
          "99:     uint64_t length = DKG_MAX_SEALED_LEN;",
          "101:       length = enc_len;",
          "102:     }",
          "",
          "[Removed Lines]",
          "94:     if (DEBUG_PRINT) {",
          "100:     if (is_aes){",
          "",
          "[Added Lines]",
          "94:     if (printDebugInfo) {",
          "100:     if (encryptKeys){",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "119:   int err_status = 0;",
          "123:     spdlog::info(\"got encr poly size {}\", char_traits<char>::length(encryptedPolyHex));",
          "124:   }",
          "",
          "[Removed Lines]",
          "121:   if (DEBUG_PRINT) {",
          "",
          "[Added Lines]",
          "121:   if (printDebugInfo) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "137:       throw RPCException(INVALID_HEX, \"Invalid encryptedPolyHex\");",
          "138:   }",
          "142:     spdlog::info(\"hex_encr_poly length is {}\", strlen(encryptedPolyHex));",
          "143:     spdlog::info(\"enc len {}\", enc_len);",
          "",
          "[Removed Lines]",
          "140:   if (DEBUG_PRINT) {",
          "",
          "[Added Lines]",
          "140:   if (printDebugInfo) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "149:   uint32_t len = 0;",
          "152:     status = get_public_shares(eid, &err_status, errMsg1, encr_dkg_poly, len, public_shares, t, n);",
          "153:   else {",
          "",
          "[Removed Lines]",
          "151:   if (!is_aes)",
          "",
          "[Added Lines]",
          "151:   if (!encryptKeys)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "158:     throw RPCException(-666, errMsg1 );",
          "159:   }",
          "162:     spdlog::info(\"err msg is {}\", errMsg1);",
          "164:     spdlog::info(\"public_shares:\");",
          "",
          "[Removed Lines]",
          "161:   if (DEBUG_PRINT) {",
          "",
          "[Added Lines]",
          "161:   if (printDebugInfo) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "201:   std::cerr << \"enc_len is \" << enc_len << std::endl;",
          "204:     status = set_encrypted_dkg_poly(eid, &err_status, errMsg1, encr_dkg_poly);",
          "205:   else",
          "206:     status = set_encrypted_dkg_poly_aes(eid, &err_status, errMsg1, encr_dkg_poly, &enc_len);",
          "",
          "[Removed Lines]",
          "203:   if (!is_aes)",
          "",
          "[Added Lines]",
          "203:   if (!encryptKeys)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "226:     char pubKeyB[129];",
          "227:     strncpy(pubKeyB, pub_keyB.c_str(), 128);",
          "228:     pubKeyB[128] = 0;",
          "230:       spdlog::info(\"pubKeyB is {}\", pub_keyB);",
          "231:     }",
          "234:       get_encr_sshare(eid, &err_status, errMsg1, encrypted_skey, &dec_len,",
          "235:                    cur_share, s_shareG2, pubKeyB, t, n, i + 1 );",
          "236:     else",
          "",
          "[Removed Lines]",
          "229:     if (DEBUG_PRINT) {",
          "233:     if (!is_aes)",
          "",
          "[Added Lines]",
          "229:     if (printDebugInfo) {",
          "233:     if (!encryptKeys)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "239:     if (err_status != 0){",
          "240:       throw RPCException(-666, errMsg1);",
          "241:     }",
          "243:       spdlog::info(\"cur_share is {}\", cur_share);",
          "244:     }",
          "246:     result += cur_share;",
          "250:       spdlog::info(\"dec len is {}\", dec_len);",
          "251:     }",
          "",
          "[Removed Lines]",
          "242:     if (DEBUG_PRINT) {",
          "249:     if (DEBUG_PRINT) {",
          "",
          "[Added Lines]",
          "242:     if (printDebugInfo) {",
          "249:     if (printDebugInfo) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "257:     string DHKey_name = \"DKG_DH_KEY_\" + polyName + \"_\" + to_string(i) + \":\";",
          "259:     cerr << \"hexEncr DH Key: \" << hexEncrKey << endl;",
          "262:     string shareG2_name = \"shareG2_\" + polyName + \"_\" + to_string(i) + \":\";",
          "264:       spdlog::info(\"name to write to db is {}\", DHKey_name);",
          "265:       spdlog::info(\"name to write to db is {}\", shareG2_name);",
          "266:       spdlog::info(\"s_shareG2: {}\", s_shareG2);",
          "267:     }",
          "271:       spdlog::info(\"errMsg: {}\", errMsg1);",
          "",
          "[Removed Lines]",
          "260:     writeDataToDB(DHKey_name, hexEncrKey);",
          "263:     if (DEBUG_PRINT) {",
          "268:     writeDataToDB(shareG2_name, s_shareG2);",
          "270:     if (DEBUG_PRINT) {",
          "",
          "[Added Lines]",
          "260:     SGXWalletServer::writeDataToDB(DHKey_name, hexEncrKey);",
          "263:     if (printDebugInfo) {",
          "268:     SGXWalletServer::writeDataToDB(shareG2_name, s_shareG2);",
          "270:     if (printDebugInfo) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "295:         throw RPCException(INVALID_HEX, \"Invalid encryptedPolyHex\");",
          "296:     }",
          "297:     int result;",
          "299:       cerr << \"encryptedKeyHex \" << encryptedKeyHex << endl;",
          "300:       cerr << \"dec_key_len \" << dec_key_len << endl;",
          "301:       cerr << \"encr_sshare length is \" << strlen(encr_sshare) << endl;",
          "",
          "[Removed Lines]",
          "298:     if (DEBUG_PRINT) {",
          "",
          "[Added Lines]",
          "298:     if (printDebugInfo) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "307:     strncpy(pshares, publicShares, strlen(publicShares) );",
          "311:       dkg_verification(eid, &err_status, errMsg1, pshares, encr_sshare, encr_key, dec_key_len, t, ind, &result);",
          "312:     else",
          "313:       dkg_verification_aes(eid, &err_status, errMsg1, pshares, encr_sshare, encr_key, dec_key_len, t, ind, &result);",
          "",
          "[Removed Lines]",
          "310:     if (!is_aes)",
          "",
          "[Added Lines]",
          "310:     if (!encryptKeys)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "316:       throw RPCException(INVALID_HEX, \"Invalid public shares\");",
          "317:     }",
          "320:       spdlog::info(\"errMsg1: {}\", errMsg1);",
          "321:       spdlog::info(\"result is: {}\", result);",
          "322:     }",
          "",
          "[Removed Lines]",
          "319:     if (DEBUG_PRINT) {",
          "",
          "[Added Lines]",
          "319:     if (printDebugInfo) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "327: }",
          "329: bool CreateBLSShare( const string& blsKeyName, const char * s_shares, const char * encryptedKeyHex){",
          "331:     spdlog::info(\"ENTER CreateBLSShare\");",
          "332:   }",
          "",
          "[Removed Lines]",
          "330:   if (DEBUG_PRINT) {",
          "",
          "[Added Lines]",
          "330:   if (printDebugInfo) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "346:   uint32_t enc_bls_len = 0;",
          "350:     create_bls_key(eid, &err_status, errMsg1, s_shares, encr_key, dec_key_len, encr_bls_key, &enc_bls_len);",
          "351:   else",
          "352:     create_bls_key_aes(eid, &err_status, errMsg1, s_shares, encr_key, dec_key_len, encr_bls_key, &enc_bls_len);",
          "",
          "[Removed Lines]",
          "349:   if (!is_aes)",
          "",
          "[Added Lines]",
          "349:   if (!encryptKeys)",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "366:     carray2Hex(encr_bls_key, enc_bls_len, hexBLSKey);",
          "370:       spdlog::info(\"hexBLSKey length is {}\", char_traits<char>::length(hexBLSKey));",
          "371:       spdlog::info(\"bls key {}\", blsKeyName, \" is \", hexBLSKey );",
          "372:     }",
          "",
          "[Removed Lines]",
          "368:     writeDataToDB(blsKeyName, hexBLSKey);",
          "369:     if (DEBUG_PRINT) {",
          "",
          "[Added Lines]",
          "368:     SGXWalletServer::writeDataToDB(blsKeyName, hexBLSKey);",
          "369:     if (printDebugInfo) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "389:     }",
          "391:     char pub_key[320];",
          "393:       spdlog::info(\"dec_key_len is {}\", dec_key_len);",
          "394:     }",
          "397:       get_bls_pub_key(eid, &err_status, errMsg1, encr_key, dec_key_len, pub_key);",
          "398:     else",
          "399:       get_bls_pub_key_aes(eid, &err_status, errMsg1, encr_key, dec_key_len, pub_key);",
          "",
          "[Removed Lines]",
          "392:     if (DEBUG_PRINT) {",
          "396:     if (!is_aes)",
          "",
          "[Added Lines]",
          "392:     if (printDebugInfo) {",
          "396:     if (!encryptKeys)",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "403:     }",
          "404:     vector<string> pub_key_vect = SplitString(pub_key, ':');",
          "407:       spdlog::info(\"errMsg1 is {}\", errMsg1);",
          "408:       spdlog::info(\"pub key is \");",
          "409:       for (int i = 0; i < 4; i++)",
          "",
          "[Removed Lines]",
          "406:     if (DEBUG_PRINT) {",
          "",
          "[Added Lines]",
          "406:     if (printDebugInfo) {",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "418:   int err_status = 0;",
          "420:   string DH_key_name = polyName + \"_\" + to_string(ind) + \":\";",
          "423:     spdlog::info(\"encr DH key is {}\", *hexEncrKey_ptr);",
          "424:   }",
          "",
          "[Removed Lines]",
          "421:   shared_ptr<string> hexEncrKey_ptr = readFromDb(DH_key_name, \"DKG_DH_KEY_\");",
          "422:   if (DEBUG_PRINT) {",
          "",
          "[Added Lines]",
          "421:   shared_ptr<string> hexEncrKey_ptr = SGXWalletServer::readFromDb(DH_key_name, \"DKG_DH_KEY_\");",
          "422:   if (printDebugInfo) {",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "430:   if (!hex2carray(hexEncrKey_ptr->c_str(), &DH_enc_len, encrypted_DHkey)){",
          "431:      throw RPCException(INVALID_HEX, \"Invalid hexEncrKey\");",
          "432:   }",
          "434:     spdlog::info(\"encr DH key length is {}\", DH_enc_len);",
          "435:     spdlog::info(\"hex encr DH key length is {}\", hexEncrKey_ptr->length());",
          "436:   }",
          "438:   char DHKey[ECDSA_SKEY_LEN];",
          "441:     decrypt_key(eid, &err_status, errMsg1.data(), encrypted_DHkey, DH_enc_len, DHKey);",
          "442:   else",
          "443:     decrypt_key_aes(eid, &err_status, errMsg1.data(), encrypted_DHkey, DH_enc_len, DHKey);",
          "",
          "[Removed Lines]",
          "433:   if (DEBUG_PRINT) {",
          "440:   if ( !is_aes)",
          "",
          "[Added Lines]",
          "433:   if (printDebugInfo) {",
          "440:   if ( !encryptKeys)",
          "",
          "---------------"
        ],
        "ECDSACrypto.cpp||ECDSACrypto.cpp": [
          "File: ECDSACrypto.cpp -> ECDSACrypto.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "51:   char *pub_key_y = (char *)calloc(1024, 1);",
          "52:   uint32_t enc_len = 0;",
          "55:      status = generate_ecdsa_key(eid, &err_status, errMsg, encr_pr_key, &enc_len, pub_key_x, pub_key_y );",
          "56:   else",
          "57:      status = generate_ecdsa_key_aes(eid, &err_status, errMsg, encr_pr_key, &enc_len, pub_key_x, pub_key_y );",
          "",
          "[Removed Lines]",
          "54:   if ( !is_aes)",
          "",
          "[Added Lines]",
          "54:   if ( !encryptKeys)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "61:     throw RPCException(status, errMsg) ;",
          "62:   }",
          "63:   std::vector<std::string> keys(3);",
          "65:     std::cerr << \"account key is \" << errMsg << std::endl;",
          "66:     std::cerr << \"enc_len is \" << enc_len << std::endl;",
          "",
          "[Removed Lines]",
          "64:   if (DEBUG_PRINT) {",
          "",
          "[Added Lines]",
          "64:   if (printDebugInfo) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "79:   unsigned long seed = rand_gen();",
          "81:     spdlog::info(\"seed is {}\", seed);",
          "82:     std::cerr << \"strlen is \" << strlen(hexEncrKey) << std::endl;",
          "83:   }",
          "",
          "[Removed Lines]",
          "80:   if (DEBUG_PRINT) {",
          "",
          "[Added Lines]",
          "80:   if (printDebugInfo) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "122:     throw RPCException(INVALID_HEX, \"Invalid encryptedKeyHex\");",
          "123:   }",
          "126:    status = get_public_ecdsa_key(eid, &err_status, errMsg, encr_pr_key, enc_len, pub_key_x, pub_key_y );",
          "127:   else status = get_public_ecdsa_key_aes(eid, &err_status, errMsg, encr_pr_key, enc_len, pub_key_x, pub_key_y );",
          "128:   if (err_status != 0){",
          "",
          "[Removed Lines]",
          "125:   if ( !is_aes)",
          "",
          "[Added Lines]",
          "125:   if ( !encryptKeys)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "130:   }",
          "131:   std::string pubKey = std::string(pub_key_x) + std::string(pub_key_y);//concatPubKeyWith0x(pub_key_x, pub_key_y);//",
          "134:     spdlog::info(\"enc_len is {}\", enc_len);",
          "135:     spdlog::info(\"pubkey is {}\", pubKey);",
          "136:     spdlog::info(\"pubkey length is {}\", pubKey.length());",
          "",
          "[Removed Lines]",
          "133:   if (DEBUG_PRINT) {",
          "",
          "[Added Lines]",
          "133:   if (printDebugInfo) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "162:       throw RPCException(INVALID_HEX, \"Invalid encryptedKeyHex\");",
          "163:   }",
          "166:     spdlog::info(\"encryptedKeyHex: {}\", encryptedKeyHex);",
          "167:     spdlog::info(\"HASH: {}\", hashHex);",
          "168:     spdlog::info(\"encrypted len: {}\", dec_len);",
          "169:   }",
          "172:    status = ecdsa_sign1(eid, &err_status, errMsg, encr_key, ECDSA_ENCR_LEN, (unsigned char*)hashHex, signature_r, signature_s, &signature_v, base );",
          "173:   else status = ecdsa_sign_aes(eid, &err_status, errMsg, encr_key, dec_len, (unsigned char*)hashHex, signature_r, signature_s, &signature_v, base );",
          "174:   if ( err_status != 0){",
          "175:     throw RPCException(-666, errMsg ) ;",
          "176:   }",
          "179:     spdlog::info(\"signature r in  ecdsa_sign_hash: {}\", signature_r);",
          "180:     spdlog::info(\"signature s in  ecdsa_sign_hash: {}\", signature_s);",
          "181:   }",
          "",
          "[Removed Lines]",
          "165:   if (DEBUG_PRINT) {",
          "171:   if (!is_aes)",
          "178:   if (DEBUG_PRINT) {",
          "",
          "[Added Lines]",
          "165:   if (printDebugInfo) {",
          "171:   if (!encryptKeys)",
          "178:   if (printDebugInfo) {",
          "",
          "---------------"
        ],
        "LevelDB.cpp||LevelDB.cpp": [
          "File: LevelDB.cpp -> LevelDB.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "63:     auto status = db->Get(readOptions, _key, &*result);",
          "66:       spdlog::info(\"key to read from db: {}\",_key );",
          "68:     }",
          "",
          "[Removed Lines]",
          "65:     if (DEBUG_PRINT) {",
          "",
          "[Added Lines]",
          "65:     if (printDebugInfo) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "84:     throwExceptionOnError(status);",
          "87:         spdlog::info(\"written key: {}\",_key );",
          "89:     }",
          "",
          "[Removed Lines]",
          "86:     if (DEBUG_PRINT) {",
          "",
          "[Added Lines]",
          "86:     if (printDebugInfo) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "101:     throwExceptionOnError(status);",
          "104:       spdlog::info(\"key deleted: {}\",full_key );",
          "106:     }",
          "",
          "[Removed Lines]",
          "103:     if (DEBUG_PRINT) {",
          "",
          "[Added Lines]",
          "103:     if (printDebugInfo) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "131:     throwExceptionOnError(status);",
          "134:       spdlog::info(\"key deleted: {}\",_key );",
          "136:     }",
          "",
          "[Removed Lines]",
          "133:     if (DEBUG_PRINT) {",
          "",
          "[Added Lines]",
          "133:     if (printDebugInfo) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "219:   }",
          "221:   writeString(key, value);",
          "223:       spdlog::info(\"{}\",Name, \" is written to db\");",
          "225:   }",
          "",
          "[Removed Lines]",
          "222:   if (DEBUG_PRINT) {",
          "",
          "[Added Lines]",
          "222:   if (printDebugInfo) {",
          "",
          "---------------"
        ],
        "SEKManager.cpp||SEKManager.cpp": [
          "File: SEKManager.cpp -> SEKManager.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "231:     gen_SEK();",
          "232:   }",
          "233:   else{",
          "235:       spdlog::info(\"going to set SEK from db\" );",
          "236:     set_SEK(encr_SEK_ptr);",
          "237:   }",
          "",
          "[Removed Lines]",
          "234:     if (DEBUG_PRINT)",
          "",
          "[Added Lines]",
          "234:     if (printDebugInfo)",
          "",
          "---------------"
        ],
        "SGXRegistrationServer.cpp||SGXRegistrationServer.cpp": [
          "File: SGXRegistrationServer.cpp -> SGXRegistrationServer.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: #include \"spdlog/spdlog.h\"",
          "47: #include \"common.h\"",
          "52: bool autoconfirm = false;",
          "64: SGXRegistrationServer::SGXRegistrationServer(AbstractServerConnector &connector,",
          "105:     }",
          "121: }",
          "161:     }",
          "173: }",
          "180: }",
          "185: }",
          "190: }",
          "",
          "[Removed Lines]",
          "49: int DEBUG_PRINT = 0;",
          "50: int is_sgx_https = 1;",
          "51: int is_aes = 1;",
          "54: SGXRegistrationServer *regs = nullptr;",
          "55: HttpServer *hs2 = nullptr;",
          "57: bool cert_created = false;",
          "59: void set_cert_created1(bool b){",
          "60:   sleep(10);",
          "61:   cert_created = b;",
          "62: }",
          "65:                                  serverVersion_t type, bool auto_sign)",
          "66:     : AbstractRegServer(connector, type), is_cert_created(false), cert_auto_sign(auto_sign) {}",
          "69: Json::Value signCertificateImpl(const string& csr, bool auto_sign = false){",
          "70:   Json::Value result;",
          "71:   result[\"status\"] = 0;",
          "72:   result[\"errorMessage\"] = \"\";",
          "73:   try{",
          "74:     spdlog::info(\"enter signCertificateImpl\");",
          "76:     string status = \"1\";",
          "77:     string hash = cryptlite::sha256::hash_hex(csr);",
          "78:     if ( !auto_sign) {",
          "79:       string db_key = \"CSR:HASH:\" + hash;",
          "80:       LevelDB::getCsrStatusDb()->writeDataUnique(db_key, csr);",
          "81:     }",
          "83:     if (auto_sign) {",
          "84:       string csr_name = \"cert/\" + hash + \".csr\";",
          "85:       ofstream outfile(csr_name);",
          "86:       outfile << csr << endl;",
          "87:       outfile.close();",
          "88:       if (access(csr_name.c_str(), F_OK) != 0) {",
          "89:         throw RPCException(FILE_NOT_FOUND, \"Csr does not exist\");",
          "90:       }",
          "92:       string genCert = \"cd cert && ./create_client_cert \" + hash;",
          "94:       if (system(genCert.c_str()) == 0){",
          "95:           spdlog::info(\"CLIENT CERTIFICATE IS SUCCESSFULLY GENERATED\");",
          "96:           status = \"0\";",
          "97:       }",
          "98:       else{",
          "99:           spdlog::info(\"CLIENT CERTIFICATE GENERATION FAILED\");",
          "100:           string status_db_key = \"CSR:HASH:\" + hash + \"STATUS:\";",
          "101:           LevelDB::getCsrStatusDb()->writeDataUnique(status_db_key, to_string(FAIL_TO_CREATE_CERTIFICATE));",
          "102:           throw RPCException(FAIL_TO_CREATE_CERTIFICATE, \"CLIENT CERTIFICATE GENERATION FAILED\");",
          "104:       }",
          "107:     result[\"result\"] = true;",
          "108:     result[\"hash\"] = hash;",
          "110:     string db_key = \"CSR:HASH:\" + hash + \"STATUS:\";",
          "111:     LevelDB::getCsrStatusDb()->writeDataUnique(db_key, status);",
          "113:   } catch (RPCException &_e) {",
          "114:     cerr << \" err str \" << _e.errString << endl;",
          "115:     result[\"status\"] = _e.status;",
          "116:     result[\"errorMessage\"] = _e.errString;",
          "117:     result[\"result\"] = false;",
          "118:   }",
          "120:   return result;",
          "123: Json::Value GetSertificateImpl(const string& hash){",
          "124:   Json::Value result;",
          "126:   string cert;",
          "127:   try{",
          "128:     string db_key = \"CSR:HASH:\" + hash + \"STATUS:\";",
          "129:     shared_ptr<string> status_str_ptr = LevelDB::getCsrStatusDb()->readString(db_key);",
          "130:     if (status_str_ptr == nullptr){",
          "131:        throw RPCException(KEY_SHARE_DOES_NOT_EXIST, \"Data with this name does not exist in csr db\");",
          "132:     }",
          "133:     int status = atoi(status_str_ptr->c_str());",
          "135:     if ( status == 0){",
          "136:       string crt_name = \"cert/\" + hash + \".crt\";",
          "138:         ifstream infile(crt_name);",
          "139:         if (!infile.is_open()) {",
          "140:           string status_db_key = \"CSR:HASH:\" + hash + \"STATUS:\";",
          "141:           LevelDB::getCsrStatusDb()->deleteKey(status_db_key);",
          "142:           LevelDB::getCsrStatusDb()->writeDataUnique(status_db_key, to_string(FILE_NOT_FOUND));",
          "143:           throw RPCException(FILE_NOT_FOUND, \"Certificate does not exist\");",
          "144:         } else {",
          "145:           ostringstream ss;",
          "146:           ss << infile.rdbuf();",
          "147:           cert = ss.str();",
          "149:           infile.close();",
          "150:           string remove_crt = \"cd cert && rm -rf \" + hash + \".crt && rm -rf \" + hash + \".csr\";",
          "151:           if(system(remove_crt.c_str()) == 0){",
          "153:               spdlog::info(\" cert removed \");",
          "155:           }",
          "156:           else{",
          "157:               spdlog::info(\" cert was not removed \");",
          "158:           }",
          "160:       }",
          "163:     result[\"status\"] = status;",
          "164:     result[\"cert\"] = cert;",
          "166:   } catch (RPCException &_e) {",
          "167:     cerr << \" err str \" << _e.errString << endl;",
          "168:     result[\"status\"] = _e.status;",
          "169:     result[\"errorMessage\"] = _e.errString;",
          "170:   }",
          "172:   return result;",
          "176: Json::Value SGXRegistrationServer::signCertificate(const string& csr){",
          "177:   spdlog::info(\"Enter signCertificate \");",
          "178:   lock_guard<recursive_mutex> lock(m);",
          "179:   return signCertificateImpl(csr, cert_auto_sign);",
          "182: Json::Value SGXRegistrationServer::getCertificate(const string& hash){",
          "183:   lock_guard<recursive_mutex> lock(m);",
          "184:   return GetSertificateImpl(hash);",
          "187: void SGXRegistrationServer::set_cert_created(bool b){",
          "188:   sleep(100);",
          "189:   is_cert_created = b;",
          "194: int init_registration_server(bool sign_automatically) {",
          "",
          "[Added Lines]",
          "49: int printDebugInfo = 0;",
          "50: int useHTTPS = 1;",
          "51: int encryptKeys = 0;",
          "54: SGXRegistrationServer *registrationServer = nullptr;",
          "55: HttpServer *httpServer2 = nullptr;",
          "58:                                              serverVersion_t type, bool _autoSign)",
          "59:         : AbstractRegServer(connector, type), isCertCreated(false), autoSign(_autoSign) {}",
          "62: Json::Value signCertificateImpl(const string &_csr, bool _autoSign = false) {",
          "63:     Json::Value result;",
          "64:     result[\"status\"] = 0;",
          "65:     result[\"errorMessage\"] = \"\";",
          "66:     try {",
          "67:         spdlog::info(\"enter signCertificateImpl\");",
          "69:         string status = \"1\";",
          "70:         string hash = cryptlite::sha256::hash_hex(_csr);",
          "71:         if (!_autoSign) {",
          "72:             string db_key = \"CSR:HASH:\" + hash;",
          "73:             LevelDB::getCsrStatusDb()->writeDataUnique(db_key, _csr);",
          "74:         }",
          "76:         if (_autoSign) {",
          "77:             string csr_name = \"cert/\" + hash + \".csr\";",
          "78:             ofstream outfile(csr_name);",
          "79:             outfile << _csr << endl;",
          "80:             outfile.close();",
          "81:             if (access(csr_name.c_str(), F_OK) != 0) {",
          "82:                 throw RPCException(FILE_NOT_FOUND, \"Csr does not exist\");",
          "83:             }",
          "85:             string genCert = \"cd cert && ./create_client_cert \" + hash;",
          "87:             if (system(genCert.c_str()) == 0) {",
          "88:                 spdlog::info(\"CLIENT CERTIFICATE IS SUCCESSFULLY GENERATED\");",
          "89:                 status = \"0\";",
          "90:             } else {",
          "91:                 spdlog::info(\"CLIENT CERTIFICATE GENERATION FAILED\");",
          "92:                 string status_db_key = \"CSR:HASH:\" + hash + \"STATUS:\";",
          "93:                 LevelDB::getCsrStatusDb()->writeDataUnique(status_db_key, to_string(FAIL_TO_CREATE_CERTIFICATE));",
          "94:                 throw RPCException(FAIL_TO_CREATE_CERTIFICATE, \"CLIENT CERTIFICATE GENERATION FAILED\");",
          "96:             }",
          "97:         }",
          "99:         result[\"result\"] = true;",
          "100:         result[\"hash\"] = hash;",
          "102:         string db_key = \"CSR:HASH:\" + hash + \"STATUS:\";",
          "103:         LevelDB::getCsrStatusDb()->writeDataUnique(db_key, status);",
          "105:     } catch (RPCException &_e) {",
          "106:         cerr << \" err str \" << _e.errString << endl;",
          "107:         result[\"status\"] = _e.status;",
          "108:         result[\"errorMessage\"] = _e.errString;",
          "109:         result[\"result\"] = false;",
          "112:     return result;",
          "115: Json::Value GetSertificateImpl(const string &hash) {",
          "116:     Json::Value result;",
          "118:     string cert;",
          "119:     try {",
          "120:         string db_key = \"CSR:HASH:\" + hash + \"STATUS:\";",
          "121:         shared_ptr<string> status_str_ptr = LevelDB::getCsrStatusDb()->readString(db_key);",
          "122:         if (status_str_ptr == nullptr) {",
          "123:             throw RPCException(KEY_SHARE_DOES_NOT_EXIST, \"Data with this name does not exist in csr db\");",
          "124:         }",
          "125:         int status = atoi(status_str_ptr->c_str());",
          "127:         if (status == 0) {",
          "128:             string crt_name = \"cert/\" + hash + \".crt\";",
          "130:             ifstream infile(crt_name);",
          "131:             if (!infile.is_open()) {",
          "132:                 string status_db_key = \"CSR:HASH:\" + hash + \"STATUS:\";",
          "133:                 LevelDB::getCsrStatusDb()->deleteKey(status_db_key);",
          "134:                 LevelDB::getCsrStatusDb()->writeDataUnique(status_db_key, to_string(FILE_NOT_FOUND));",
          "135:                 throw RPCException(FILE_NOT_FOUND, \"Certificate does not exist\");",
          "136:             } else {",
          "137:                 ostringstream ss;",
          "138:                 ss << infile.rdbuf();",
          "139:                 cert = ss.str();",
          "141:                 infile.close();",
          "142:                 string remove_crt = \"cd cert && rm -rf \" + hash + \".crt && rm -rf \" + hash + \".csr\";",
          "143:                 if (system(remove_crt.c_str()) == 0) {",
          "145:                     spdlog::info(\" cert removed \");",
          "147:                 } else {",
          "148:                     spdlog::info(\" cert was not removed \");",
          "149:                 }",
          "151:             }",
          "152:         }",
          "154:         result[\"status\"] = status;",
          "155:         result[\"cert\"] = cert;",
          "157:     } catch (RPCException &_e) {",
          "158:         cerr << \" err str \" << _e.errString << endl;",
          "159:         result[\"status\"] = _e.status;",
          "160:         result[\"errorMessage\"] = _e.errString;",
          "163:     return result;",
          "167: Json::Value SGXRegistrationServer::signCertificate(const string &csr) {",
          "168:     spdlog::info(\"Enter signCertificate \");",
          "169:     lock_guard<recursive_mutex> lock(m);",
          "170:     return signCertificateImpl(csr, autoSign);",
          "173: Json::Value SGXRegistrationServer::getCertificate(const string &hash) {",
          "174:     lock_guard<recursive_mutex> lock(m);",
          "175:     return GetSertificateImpl(hash);",
          "178: void SGXRegistrationServer::set_cert_created(bool b) {",
          "179:     sleep(100);",
          "180:     isCertCreated = b;",
          "184: int initRegistrationServer(bool _autoSign) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "228: }",
          "",
          "[Removed Lines]",
          "213:   hs2 = new HttpServer(BASE_PORT + 1);",
          "214:   regs = new SGXRegistrationServer(*hs2,",
          "215:                                  JSONRPC_SERVER_V2, sign_automatically); // hybrid server (json-rpc 1.0 & 2.0)",
          "217:   if (!regs->StartListening()) {",
          "218:     spdlog::info(\"Registration server could not start listening\");",
          "219:     exit(-1);",
          "220:   }",
          "221:   else {",
          "222:     spdlog::info(\"Registration server started on port {}\", BASE_PORT + 1);",
          "223:   }",
          "227:   return 0;",
          "",
          "[Added Lines]",
          "203:     httpServer2 = new HttpServer(BASE_PORT + 1);",
          "204:     registrationServer = new SGXRegistrationServer(*httpServer2,",
          "205:                                                    JSONRPC_SERVER_V2,",
          "206:                                                    _autoSign); // hybrid server (json-rpc 1.0 & 2.0)",
          "208:     if (!registrationServer->StartListening()) {",
          "209:         spdlog::info(\"Registration server could not start listening\");",
          "210:         exit(-1);",
          "211:     } else {",
          "212:         spdlog::info(\"Registration server started on port {}\", BASE_PORT + 1);",
          "213:     }",
          "216:     return 0;",
          "",
          "---------------"
        ],
        "SGXRegistrationServer.h||SGXRegistrationServer.h": [
          "File: SGXRegistrationServer.h -> SGXRegistrationServer.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: class SGXRegistrationServer: public AbstractRegServer {",
          "35:   std::recursive_mutex m;",
          "41: public:",
          "45:   void set_cert_created(bool b);",
          "",
          "[Removed Lines]",
          "36:   bool is_cert_created;",
          "37:   bool cert_auto_sign;",
          "43:   SGXRegistrationServer(AbstractServerConnector &connector, serverVersion_t type, bool auto_sign = false);",
          "",
          "[Added Lines]",
          "36:   bool isCertCreated;",
          "37:   bool autoSign;",
          "41:   SGXRegistrationServer(AbstractServerConnector &connector, serverVersion_t type, bool _autoSign = false);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "50: };",
          "",
          "[Removed Lines]",
          "53: extern int init_registration_server(bool sign_automatically = false);",
          "",
          "[Added Lines]",
          "51: extern int initRegistrationServer(bool _autoSign = false);",
          "",
          "---------------"
        ],
        "SGXWalletServer.cpp||SGXWalletServer.cpp": [
          "File: SGXWalletServer.cpp -> SGXWalletServer.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: #include \"common.h\"",
          "55: }",
          "58: SGXWalletServer *s = nullptr;",
          "77: }",
          "96:     }",
          "114:     }",
          "129: }",
          "142: }",
          "144: Json::Value",
          "146:     Json::Value result;",
          "148:     int errStatus = UNKNOWN_ERROR;",
          "",
          "[Removed Lines]",
          "50: bool isStringDec( string & str){",
          "51:   auto res = find_if_not(str.begin(), str.end(), [](char c)->bool{",
          "52:     return isdigit(c);",
          "53:   });",
          "54:   return !str.empty() && res == str.end();",
          "59: HttpServer *hs = nullptr;",
          "61: SGXWalletServer::SGXWalletServer(AbstractServerConnector &connector,",
          "62:                                  serverVersion_t type)",
          "63:         : AbstractStubServer(connector, type) {}",
          "65: void debug_print(){",
          "66:   cout << \"HERE ARE YOUR KEYS: \" << endl;",
          "67:   class MyVisitor: public LevelDB::KeyVisitor {",
          "68:   public:",
          "69:     virtual void visitDBKey(const char* _data){",
          "70:       cout << _data << endl;",
          "71:     }",
          "72:   };",
          "74:   MyVisitor v;",
          "76:   LevelDB::getLevelDb()->visitKeys(&v, 100000000);",
          "79: int init_https_server(bool check_certs) {",
          "81:   string rootCAPath = string(SGXDATA_FOLDER) + \"cert_data/rootCA.pem\";",
          "82:   string keyCAPath = string(SGXDATA_FOLDER) + \"cert_data/rootCA.key\";",
          "84:   if (access(rootCAPath.c_str(), F_OK) != 0 || access(keyCAPath.c_str(), F_OK) != 0){",
          "85:     spdlog::info(\"YOU DO NOT HAVE ROOT CA CERTIFICATE\");",
          "86:     spdlog::info(\"ROOT CA CERTIFICATE IS GOING TO BE CREATED\");",
          "88:     string genRootCACert = \"cd cert && ./create_CA\";",
          "90:     if (system(genRootCACert.c_str()) == 0){",
          "91:       spdlog::info(\"ROOT CA CERTIFICATE IS SUCCESSFULLY GENERATED\");",
          "92:     }",
          "93:     else{",
          "94:       spdlog::info(\"ROOT CA CERTIFICATE GENERATION FAILED\");",
          "95:       exit(-1);",
          "97:   }",
          "99:   string certPath = string(SGXDATA_FOLDER) + \"cert_data/SGXServerCert.crt\";",
          "100:   string keyPath = string(SGXDATA_FOLDER) + \"cert_data/SGXServerCert.key\";",
          "102:   if (access(certPath.c_str(), F_OK) != 0 || access(certPath.c_str(), F_OK) != 0){",
          "103:     spdlog::info(\"YOU DO NOT HAVE SERVER CERTIFICATE\");",
          "104:     spdlog::info(\"SERVER CERTIFICATE IS GOING TO BE CREATED\");",
          "106:     string genCert = \"cd cert && ./create_server_cert\";",
          "108:     if (system(genCert.c_str()) == 0){",
          "109:       spdlog::info(\"SERVER CERTIFICATE IS SUCCESSFULLY GENERATED\");",
          "110:     }",
          "111:     else{",
          "112:       spdlog::info(\"SERVER CERTIFICATE GENERATION FAILED\");",
          "113:       exit(-1);",
          "115:   }",
          "117:   hs = new HttpServer(BASE_PORT, certPath, keyPath, rootCAPath, check_certs, 64);",
          "118:   s = new SGXWalletServer(*hs,",
          "119:                       JSONRPC_SERVER_V2); // hybrid server (json-rpc 1.0 & 2.0)",
          "121:   if (!s->StartListening()) {",
          "122:     spdlog::info(\"SGX Server could not start listening\");",
          "123:     exit(-1);",
          "124:   }",
          "125:   else{",
          "126:     spdlog::info(\"SGX Server started on port {}\", BASE_PORT);",
          "127:   }",
          "128:   return 0;",
          "132: int init_http_server() { //without ssl",
          "134:   hs = new HttpServer(BASE_PORT + 3);",
          "135:   s = new SGXWalletServer(*hs,",
          "136:                           JSONRPC_SERVER_V2); // hybrid server (json-rpc 1.0 & 2.0)",
          "137:   if (!s->StartListening()) {",
          "138:     spdlog::info(\"Server could not start listening\");",
          "139:     exit(-1);",
          "140:   }",
          "141:   return 0;",
          "145: importBLSKeyShareImpl(const string &_keyShare, const string &_keyShareName, int t, int n, int index) {",
          "",
          "[Added Lines]",
          "49: bool isStringDec(string &_str) {",
          "50:     auto res = find_if_not(_str.begin(), _str.end(), [](char c) -> bool {",
          "51:         return isdigit(c);",
          "52:     });",
          "53:     return !_str.empty() && res == _str.end();",
          "58: HttpServer *httpServer = nullptr;",
          "60: SGXWalletServer::SGXWalletServer(AbstractServerConnector &_connector,",
          "61:                                  serverVersion_t _type)",
          "62:         : AbstractStubServer(_connector, _type) {}",
          "64: void SGXWalletServer::printDB() {",
          "65:     cout << \"HERE ARE YOUR KEYS: \" << endl;",
          "66:     class MyVisitor : public LevelDB::KeyVisitor {",
          "67:     public:",
          "68:         virtual void visitDBKey(const char *_data) {",
          "69:             cout << _data << endl;",
          "70:         }",
          "71:     };",
          "73:     MyVisitor v;",
          "75:     LevelDB::getLevelDb()->visitKeys(&v, 100000000);",
          "78: int SGXWalletServer::initHttpsServer(bool _checkCerts) {",
          "80:     string rootCAPath = string(SGXDATA_FOLDER) + \"cert_data/rootCA.pem\";",
          "81:     string keyCAPath = string(SGXDATA_FOLDER) + \"cert_data/rootCA.key\";",
          "83:     if (access(rootCAPath.c_str(), F_OK) != 0 || access(keyCAPath.c_str(), F_OK) != 0) {",
          "84:         spdlog::info(\"YOU DO NOT HAVE ROOT CA CERTIFICATE\");",
          "85:         spdlog::info(\"ROOT CA CERTIFICATE IS GOING TO BE CREATED\");",
          "87:         string genRootCACert = \"cd cert && ./create_CA\";",
          "89:         if (system(genRootCACert.c_str()) == 0) {",
          "90:             spdlog::info(\"ROOT CA CERTIFICATE IS SUCCESSFULLY GENERATED\");",
          "91:         } else {",
          "92:             spdlog::info(\"ROOT CA CERTIFICATE GENERATION FAILED\");",
          "93:             exit(-1);",
          "94:         }",
          "97:     string certPath = string(SGXDATA_FOLDER) + \"cert_data/SGXServerCert.crt\";",
          "98:     string keyPath = string(SGXDATA_FOLDER) + \"cert_data/SGXServerCert.key\";",
          "100:     if (access(certPath.c_str(), F_OK) != 0 || access(certPath.c_str(), F_OK) != 0) {",
          "101:         spdlog::info(\"YOU DO NOT HAVE SERVER CERTIFICATE\");",
          "102:         spdlog::info(\"SERVER CERTIFICATE IS GOING TO BE CREATED\");",
          "104:         string genCert = \"cd cert && ./create_server_cert\";",
          "106:         if (system(genCert.c_str()) == 0) {",
          "107:             spdlog::info(\"SERVER CERTIFICATE IS SUCCESSFULLY GENERATED\");",
          "108:         } else {",
          "109:             spdlog::info(\"SERVER CERTIFICATE GENERATION FAILED\");",
          "110:             exit(-1);",
          "111:         }",
          "114:     httpServer = new HttpServer(BASE_PORT, certPath, keyPath, rootCAPath, _checkCerts, 64);",
          "115:     s = new SGXWalletServer(*httpServer,",
          "116:                             JSONRPC_SERVER_V2); // hybrid server (json-rpc 1.0 & 2.0)",
          "118:     if (!s->StartListening()) {",
          "119:         spdlog::info(\"SGX Server could not start listening\");",
          "120:         exit(-1);",
          "121:     } else {",
          "122:         spdlog::info(\"SGX Server started on port {}\", BASE_PORT);",
          "123:     }",
          "124:     return 0;",
          "128: int SGXWalletServer::initHttpServer() { //without ssl",
          "130:     httpServer = new HttpServer(BASE_PORT + 3);",
          "131:     s = new SGXWalletServer(*httpServer,",
          "132:                             JSONRPC_SERVER_V2); // hybrid server (json-rpc 1.0 & 2.0)",
          "133:     if (!s->StartListening()) {",
          "134:         spdlog::info(\"Server could not start listening\");",
          "135:         exit(-1);",
          "136:     }",
          "137:     return 0;",
          "141: SGXWalletServer::importBLSKeyShareImpl(const string &_keyShare, const string &_keyShareName, int t, int n, int index) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "171:         result[\"encryptedKeyShare\"] = string(encryptedKeyShareHex);",
          "175:     } catch (RPCException &_e) {",
          "176:         result[\"status\"] = _e.status;",
          "",
          "[Removed Lines]",
          "173:         writeKeyShare(_keyShareName, encryptedKeyShareHex, index, n , t);",
          "",
          "[Added Lines]",
          "167:         writeKeyShare(_keyShareName, encryptedKeyShareHex, index, n, t);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "184:     return result;",
          "185: }",
          "188:     Json::Value result;",
          "189:     result[\"status\"] = -1;",
          "190:     result[\"errorMessage\"] = \"Unknown server error\";",
          "",
          "[Removed Lines]",
          "187: Json::Value blsSignMessageHashImpl(const string &keyShareName, const string &messageHash,int t, int n, int signerIndex) {",
          "",
          "[Added Lines]",
          "181: Json::Value",
          "182: SGXWalletServer::blsSignMessageHashImpl(const string &keyShareName, const string &messageHash, int t, int n, int signerIndex) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "193:     char *signature = (char *) calloc(BUF_LEN, 1);",
          "197:     try {",
          "214:     } catch (RPCException _e) {",
          "215:         result[\"status\"] = _e.status;",
          "216:         result[\"errorMessage\"] = _e.errString;",
          "",
          "[Removed Lines]",
          "195:     shared_ptr <string> value = nullptr;",
          "198:       if ( !checkName(keyShareName, \"BLS_KEY\")){",
          "199:         throw RPCException(INVALID_POLY_NAME, \"Invalid BLSKey name\");",
          "200:       }",
          "201:       string cutHash = messageHash;",
          "202:       if (cutHash[0] == '0' && (cutHash[1] == 'x'||cutHash[1] == 'X')){",
          "203:         cutHash.erase(cutHash.begin(), cutHash.begin() + 2);",
          "204:       }",
          "205:       while (cutHash[0] == '0'){",
          "206:         cutHash.erase(cutHash.begin(), cutHash.begin() + 1);",
          "207:       }",
          "209:       if ( !checkHex(cutHash)){",
          "210:         throw RPCException(INVALID_HEX, \"Invalid hash\");",
          "211:       }",
          "213:       value = readFromDb(keyShareName);",
          "",
          "[Added Lines]",
          "190:     shared_ptr<string> value = nullptr;",
          "193:         if (!checkName(keyShareName, \"BLS_KEY\")) {",
          "194:             throw RPCException(INVALID_POLY_NAME, \"Invalid BLSKey name\");",
          "195:         }",
          "196:         string cutHash = messageHash;",
          "197:         if (cutHash[0] == '0' && (cutHash[1] == 'x' || cutHash[1] == 'X')) {",
          "198:             cutHash.erase(cutHash.begin(), cutHash.begin() + 2);",
          "199:         }",
          "200:         while (cutHash[0] == '0') {",
          "201:             cutHash.erase(cutHash.begin(), cutHash.begin() + 1);",
          "202:         }",
          "204:         if (!checkHex(cutHash)) {",
          "205:             throw RPCException(INVALID_HEX, \"Invalid hash\");",
          "206:         }",
          "208:         value = readFromDb(keyShareName);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "242: }",
          "246:     Json::Value result;",
          "247:     result[\"status\"] = 0;",
          "248:     result[\"errorMessage\"] = \"\";",
          "",
          "[Removed Lines]",
          "245: Json::Value importECDSAKeyImpl(const string &key, const string &keyName) {",
          "",
          "[Added Lines]",
          "240: Json::Value SGXWalletServer::importECDSAKeyImpl(const string &_key, const string &_keyName) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "251: }",
          "256:     Json::Value result;",
          "257:     result[\"status\"] = 0;",
          "",
          "[Removed Lines]",
          "254: Json::Value generateECDSAKeyImpl() {",
          "",
          "[Added Lines]",
          "249: Json::Value SGXWalletServer::generateECDSAKeyImpl() {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "261:     spdlog::info(\"Calling method generateECDSAKey\");",
          "265:     try {",
          "266:         keys = gen_ecdsa_key();",
          "269:             throw RPCException(UNKNOWN_ERROR, \"key was not generated\");",
          "270:         }",
          "272:         string keyName = \"NEK:\" + keys.at(2);",
          "278:         }",
          "280:         writeDataToDB(keyName, keys.at(0));",
          "",
          "[Removed Lines]",
          "263:     vector<string>keys;",
          "268:         if (keys.size() == 0 ) {",
          "274:         if (DEBUG_PRINT) {",
          "275:           spdlog::info(\"write encr key {}\", keys.at(0));",
          "276:           spdlog::info(\"keyname length is {}\", keyName.length());",
          "277:           spdlog::info(\"key name generated: {}\", keyName);",
          "",
          "[Added Lines]",
          "258:     vector<string> keys;",
          "263:         if (keys.size() == 0) {",
          "269:         if (printDebugInfo) {",
          "270:             spdlog::info(\"write encr key {}\", keys.at(0));",
          "271:             spdlog::info(\"keyname length is {}\", keyName.length());",
          "272:             spdlog::info(\"key name generated: {}\", keyName);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "292:     return result;",
          "293: }",
          "328: }",
          "332:     Json::Value result;",
          "333:     result[\"status\"] = 0;",
          "334:     result[\"errorMessage\"] = \"\";",
          "",
          "[Removed Lines]",
          "295: Json::Value renameECDSAKeyImpl(const string& KeyName, const string& tempKeyName){",
          "296:   Json::Value result;",
          "297:   result[\"status\"] = 0;",
          "298:   result[\"errorMessage\"] = \"\";",
          "299:   result[\"encryptedKey\"] = \"\";",
          "301:   try {",
          "303:     string prefix = tempKeyName.substr(0,8);",
          "304:     if (prefix != \"tmp_NEK:\") {",
          "305:      throw RPCException(UNKNOWN_ERROR, \"wrong temp key name\");",
          "306:     }",
          "307:     prefix = KeyName.substr(0,12);",
          "308:     if (prefix != \"NEK_NODE_ID:\") {",
          "309:       throw RPCException(UNKNOWN_ERROR, \"wrong key name\");",
          "310:     }",
          "311:     string postfix = KeyName.substr(12, KeyName.length());",
          "312:     if (!isStringDec(postfix)){",
          "313:       throw RPCException(UNKNOWN_ERROR, \"wrong key name\");",
          "314:     }",
          "316:     shared_ptr<string> key_ptr = readFromDb(tempKeyName);",
          "317:     cerr << \"new key name is \" << KeyName <<endl;",
          "318:     writeDataToDB(KeyName, *key_ptr);",
          "319:     LevelDB::getLevelDb()->deleteTempNEK(tempKeyName);",
          "321:   } catch (RPCException &_e) {",
          "322:     cerr << \" err str \" << _e.errString << endl;",
          "323:     result[\"status\"] = _e.status;",
          "324:     result[\"errorMessage\"] = _e.errString;",
          "325:   }",
          "327:   return result;",
          "331: Json::Value ecdsaSignMessageHashImpl(int base, const string &_keyName, const string &messageHash) {",
          "",
          "[Added Lines]",
          "290: Json::Value SGXWalletServer::renameECDSAKeyImpl(const string &KeyName, const string &tempKeyName) {",
          "291:     Json::Value result;",
          "292:     result[\"status\"] = 0;",
          "293:     result[\"errorMessage\"] = \"\";",
          "294:     result[\"encryptedKey\"] = \"\";",
          "296:     try {",
          "298:         string prefix = tempKeyName.substr(0, 8);",
          "299:         if (prefix != \"tmp_NEK:\") {",
          "300:             throw RPCException(UNKNOWN_ERROR, \"wrong temp key name\");",
          "301:         }",
          "302:         prefix = KeyName.substr(0, 12);",
          "303:         if (prefix != \"NEK_NODE_ID:\") {",
          "304:             throw RPCException(UNKNOWN_ERROR, \"wrong key name\");",
          "305:         }",
          "306:         string postfix = KeyName.substr(12, KeyName.length());",
          "307:         if (!isStringDec(postfix)) {",
          "308:             throw RPCException(UNKNOWN_ERROR, \"wrong key name\");",
          "309:         }",
          "311:         shared_ptr<string> key_ptr = readFromDb(tempKeyName);",
          "312:         cerr << \"new key name is \" << KeyName << endl;",
          "313:         writeDataToDB(KeyName, *key_ptr);",
          "314:         LevelDB::getLevelDb()->deleteTempNEK(tempKeyName);",
          "316:     } catch (RPCException &_e) {",
          "317:         cerr << \" err str \" << _e.errString << endl;",
          "318:         result[\"status\"] = _e.status;",
          "319:         result[\"errorMessage\"] = _e.errString;",
          "320:     }",
          "322:     return result;",
          "326: Json::Value SGXWalletServer::ecdsaSignMessageHashImpl(int base, const string &_keyName, const string &messageHash) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "339:     vector<string> sign_vect(3);",
          "343:     }",
          "345:     try {",
          "384:     } catch (RPCException &_e) {",
          "385:         cerr << \"err str \" << _e.errString << endl;",
          "",
          "[Removed Lines]",
          "341:     if (DEBUG_PRINT) {",
          "342:       spdlog::info(\"entered ecdsaSignMessageHashImpl {}\", messageHash, \"length {}\", messageHash.length());",
          "347:       string cutHash = messageHash;",
          "348:       if (cutHash[0] == '0' && (cutHash[1] == 'x'||cutHash[1] == 'X')){",
          "349:         cutHash.erase(cutHash.begin(), cutHash.begin() + 2);",
          "350:       }",
          "351:       while (cutHash[0] == '0'){",
          "352:         cutHash.erase(cutHash.begin(), cutHash.begin() + 1);",
          "353:       }",
          "355:       if (DEBUG_PRINT) {",
          "356:         spdlog::info(\"Hash handled  {}\", cutHash);",
          "357:       }",
          "359:       if ( !checkECDSAKeyName(_keyName)){",
          "360:         throw RPCException(INVALID_ECDSA_KEY_NAME, \"Invalid ECDSA key name\");",
          "361:       }",
          "362:       if ( !checkHex(cutHash)){",
          "363:         throw RPCException(INVALID_HEX, \"Invalid hash\");",
          "364:       }",
          "365:       if ( base <= 0 || base > 32){",
          "366:         throw RPCException(-22, \"Invalid base\");",
          "367:       }",
          "369:       shared_ptr<string> key_ptr = readFromDb(_keyName,\"\");",
          "371:       sign_vect = ecdsa_sign_hash(key_ptr->c_str(), cutHash.c_str(), base);",
          "372:       if (sign_vect.size() != 3 ){",
          "373:         throw RPCException(INVALID_ECSDA_SIGNATURE, \"Invalid ecdsa signature\");",
          "374:       }",
          "376:       if (DEBUG_PRINT) {",
          "377:         spdlog::info(\"got signature_s  {}\", sign_vect.at(2));",
          "378:       }",
          "380:       result[\"signature_v\"] = sign_vect.at(0);",
          "381:       result[\"signature_r\"] = sign_vect.at(1);",
          "382:       result[\"signature_s\"] = sign_vect.at(2);",
          "",
          "[Added Lines]",
          "336:     if (printDebugInfo) {",
          "337:         spdlog::info(\"entered ecdsaSignMessageHashImpl {}\", messageHash, \"length {}\", messageHash.length());",
          "342:         string cutHash = messageHash;",
          "343:         if (cutHash[0] == '0' && (cutHash[1] == 'x' || cutHash[1] == 'X')) {",
          "344:             cutHash.erase(cutHash.begin(), cutHash.begin() + 2);",
          "345:         }",
          "346:         while (cutHash[0] == '0') {",
          "347:             cutHash.erase(cutHash.begin(), cutHash.begin() + 1);",
          "348:         }",
          "350:         if (printDebugInfo) {",
          "351:             spdlog::info(\"Hash handled  {}\", cutHash);",
          "352:         }",
          "354:         if (!checkECDSAKeyName(_keyName)) {",
          "355:             throw RPCException(INVALID_ECDSA_KEY_NAME, \"Invalid ECDSA key name\");",
          "356:         }",
          "357:         if (!checkHex(cutHash)) {",
          "358:             throw RPCException(INVALID_HEX, \"Invalid hash\");",
          "359:         }",
          "360:         if (base <= 0 || base > 32) {",
          "361:             throw RPCException(-22, \"Invalid base\");",
          "362:         }",
          "364:         shared_ptr<string> key_ptr = readFromDb(_keyName, \"\");",
          "366:         sign_vect = ecdsa_sign_hash(key_ptr->c_str(), cutHash.c_str(), base);",
          "367:         if (sign_vect.size() != 3) {",
          "368:             throw RPCException(INVALID_ECSDA_SIGNATURE, \"Invalid ecdsa signature\");",
          "369:         }",
          "371:         if (printDebugInfo) {",
          "372:             spdlog::info(\"got signature_s  {}\", sign_vect.at(2));",
          "373:         }",
          "375:         result[\"signature_v\"] = sign_vect.at(0);",
          "376:         result[\"signature_r\"] = sign_vect.at(1);",
          "377:         result[\"signature_s\"] = sign_vect.at(2);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "390:     return result;",
          "391: }",
          "394:     Json::Value result;",
          "395:     result[\"status\"] = 0;",
          "396:     result[\"errorMessage\"] = \"\";",
          "",
          "[Removed Lines]",
          "393: Json::Value getPublicECDSAKeyImpl(const string& keyName){",
          "",
          "[Added Lines]",
          "388: Json::Value SGXWalletServer::getPublicECDSAKeyImpl(const string &keyName) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "401:     string Pkey;",
          "403:     try {",
          "415:     } catch (RPCException &_e) {",
          "416:         result[\"status\"] = _e.status;",
          "",
          "[Removed Lines]",
          "404:          if ( !checkECDSAKeyName(keyName)){",
          "405:            throw RPCException(INVALID_ECDSA_KEY_NAME, \"Invalid ECDSA key name\");",
          "406:          }",
          "407:          shared_ptr<string> key_ptr = readFromDb(keyName);",
          "408:          Pkey = get_ecdsa_pubkey( key_ptr->c_str());",
          "409:          if (DEBUG_PRINT) {",
          "410:            spdlog::info(\"PublicKey {}\", Pkey);",
          "411:            spdlog::info(\"PublicKey length {}\", Pkey.length());",
          "412:          }",
          "413:          result[\"publicKey\"] = Pkey;",
          "",
          "[Added Lines]",
          "399:         if (!checkECDSAKeyName(keyName)) {",
          "400:             throw RPCException(INVALID_ECDSA_KEY_NAME, \"Invalid ECDSA key name\");",
          "401:         }",
          "402:         shared_ptr<string> key_ptr = readFromDb(keyName);",
          "403:         Pkey = get_ecdsa_pubkey(key_ptr->c_str());",
          "404:         if (printDebugInfo) {",
          "405:             spdlog::info(\"PublicKey {}\", Pkey);",
          "406:             spdlog::info(\"PublicKey length {}\", Pkey.length());",
          "407:         }",
          "408:         result[\"publicKey\"] = Pkey;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "420:     return result;",
          "421: }",
          "425:     Json::Value result;",
          "426:     result[\"status\"] = 0;",
          "",
          "[Removed Lines]",
          "423: Json::Value generateDKGPolyImpl(const string& polyName, int t) {",
          "",
          "[Added Lines]",
          "418: Json::Value SGXWalletServer::generateDKGPolyImpl(const string &polyName, int t) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "430:     string encrPolyHex;",
          "432:     try {",
          "443:     } catch (RPCException &_e) {",
          "444:         cerr << \" err str \" << _e.errString << endl;",
          "445:         result[\"status\"] = _e.status;",
          "",
          "[Removed Lines]",
          "433:       if ( !checkName(polyName, \"POLY\")){",
          "434:         throw RPCException(INVALID_POLY_NAME, \"Invalid polynomial name, it should be like POLY:SCHAIN_ID:1:NODE_ID:1:DKG_ID:1\");",
          "435:       }",
          "436:       if ( t <= 0 || t > 32){",
          "437:         throw RPCException(INVALID_DKG_PARAMS, \"Invalid parameter t \");",
          "438:       }",
          "439:       encrPolyHex = gen_dkg_poly(t);",
          "440:       writeDataToDB(polyName, encrPolyHex);",
          "",
          "[Added Lines]",
          "428:         if (!checkName(polyName, \"POLY\")) {",
          "429:             throw RPCException(INVALID_POLY_NAME,",
          "430:                                \"Invalid polynomial name, it should be like POLY:SCHAIN_ID:1:NODE_ID:1:DKG_ID:1\");",
          "431:         }",
          "432:         if (t <= 0 || t > 32) {",
          "433:             throw RPCException(INVALID_DKG_PARAMS, \"Invalid parameter t \");",
          "434:         }",
          "435:         encrPolyHex = gen_dkg_poly(t);",
          "436:         writeDataToDB(polyName, encrPolyHex);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "449:     return result;",
          "450: }",
          "487: }",
          "490:     spdlog::info(\"enter getSecretShareImpl\");",
          "491:     Json::Value result;",
          "492:     result[\"status\"] = 0;",
          "493:     result[\"errorMessage\"] = \"\";",
          "495:     try {",
          "498:         }",
          "501:         }",
          "504:         }",
          "506:         shared_ptr<string> encr_poly_ptr = readFromDb(polyName);",
          "508:         vector<string> pubKeys_vect;",
          "513:             }",
          "514:             pubKeys_vect.push_back(publicKeys[i].asString());",
          "515:         }",
          "",
          "[Removed Lines]",
          "452: Json::Value getVerificationVectorImpl(const string& polyName, int t, int n) {",
          "454:   Json::Value result;",
          "455:   result[\"status\"] = 0;",
          "456:   result[\"errorMessage\"] = \"\";",
          "458:   vector <vector<string>> verifVector;",
          "459:   try {",
          "460:     if ( !checkName(polyName, \"POLY\")){",
          "461:       throw RPCException(INVALID_POLY_NAME, \"Invalid polynomial name\");",
          "462:     }",
          "463:     if( !check_n_t(t, n)){",
          "464:       throw RPCException(INVALID_DKG_PARAMS, \"Invalid parameters: n or t \");",
          "465:     }",
          "467:     shared_ptr<string> encr_poly_ptr = readFromDb(polyName);",
          "469:     verifVector = get_verif_vect(encr_poly_ptr->c_str(), t, n);",
          "472:     for ( int i = 0; i < t; i++){",
          "473:       vector<string> cur_coef = verifVector.at(i);",
          "474:       for ( int j = 0; j < 4; j++ ){",
          "475:         result[\"verificationVector\"][i][j] = cur_coef.at(j);",
          "476:       }",
          "477:     }",
          "479:   } catch (RPCException &_e) {",
          "480:     cerr << \" err str \" << _e.errString << endl;",
          "481:     result[\"status\"] = _e.status;",
          "482:     result[\"errorMessage\"] = _e.errString;",
          "483:     result[\"verificationVector\"] = \"\";",
          "484:   }",
          "486:   return result;",
          "489: Json::Value getSecretShareImpl(const string& polyName, const Json::Value& publicKeys, int t, int n){",
          "496:         if (publicKeys.size() != (uint64_t) n){",
          "497:           throw RPCException(INVALID_DKG_PARAMS, \"wrong number of public keys\");",
          "499:         if ( !checkName(polyName, \"POLY\")){",
          "500:           throw RPCException(INVALID_POLY_NAME, \"Invalid polynomial name\");",
          "502:         if( !check_n_t(t, n)){",
          "503:           throw RPCException(INVALID_DKG_PARAMS, \"Invalid DKG parameters: n or t \");",
          "509:         for ( int i = 0; i < n ; i++) {",
          "510:             std::cerr << \"publicKeys \" << i << \" is \" << publicKeys[i].asString() <<std::endl;",
          "511:             if ( !checkHex(publicKeys[i].asString(), 64)){",
          "512:               throw RPCException(INVALID_HEX, \"Invalid public key\");",
          "",
          "[Added Lines]",
          "448: Json::Value SGXWalletServer::getVerificationVectorImpl(const string &polyName, int t, int n) {",
          "450:     Json::Value result;",
          "451:     result[\"status\"] = 0;",
          "452:     result[\"errorMessage\"] = \"\";",
          "454:     vector<vector<string>> verifVector;",
          "455:     try {",
          "456:         if (!checkName(polyName, \"POLY\")) {",
          "457:             throw RPCException(INVALID_POLY_NAME, \"Invalid polynomial name\");",
          "458:         }",
          "459:         if (!check_n_t(t, n)) {",
          "460:             throw RPCException(INVALID_DKG_PARAMS, \"Invalid parameters: n or t \");",
          "461:         }",
          "463:         shared_ptr<string> encr_poly_ptr = readFromDb(polyName);",
          "465:         verifVector = get_verif_vect(encr_poly_ptr->c_str(), t, n);",
          "468:         for (int i = 0; i < t; i++) {",
          "469:             vector<string> cur_coef = verifVector.at(i);",
          "470:             for (int j = 0; j < 4; j++) {",
          "471:                 result[\"verificationVector\"][i][j] = cur_coef.at(j);",
          "472:             }",
          "473:         }",
          "475:     } catch (RPCException &_e) {",
          "476:         cerr << \" err str \" << _e.errString << endl;",
          "477:         result[\"status\"] = _e.status;",
          "478:         result[\"errorMessage\"] = _e.errString;",
          "479:         result[\"verificationVector\"] = \"\";",
          "480:     }",
          "482:     return result;",
          "485: Json::Value SGXWalletServer::getSecretShareImpl(const string &polyName, const Json::Value &publicKeys, int t, int n) {",
          "492:         if (publicKeys.size() != (uint64_t) n) {",
          "493:             throw RPCException(INVALID_DKG_PARAMS, \"wrong number of public keys\");",
          "495:         if (!checkName(polyName, \"POLY\")) {",
          "496:             throw RPCException(INVALID_POLY_NAME, \"Invalid polynomial name\");",
          "498:         if (!check_n_t(t, n)) {",
          "499:             throw RPCException(INVALID_DKG_PARAMS, \"Invalid DKG parameters: n or t \");",
          "505:         for (int i = 0; i < n; i++) {",
          "506:             std::cerr << \"publicKeys \" << i << \" is \" << publicKeys[i].asString() << std::endl;",
          "507:             if (!checkHex(publicKeys[i].asString(), 64)) {",
          "508:                 throw RPCException(INVALID_HEX, \"Invalid public key\");",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "528:     return result;",
          "529: }",
          "570: }",
          "629: }",
          "633:     Json::Value result;",
          "634:     result[\"status\"] = 0;",
          "635:     result[\"errorMessage\"] = \"\";",
          "637:     try {",
          "653:     } catch (RPCException &_e) {",
          "654:         cerr << \" err str \" << _e.errString << endl;",
          "",
          "[Removed Lines]",
          "531: Json::Value dkgVerificationImpl(const string& publicShares, const string& ethKeyName,",
          "532:                                   const string& SecretShare, int t, int n, int ind){",
          "534:   spdlog::info(\"enter dkgVerificationImpl\");",
          "536:   Json::Value result;",
          "537:   result[\"status\"] = 0;",
          "538:   result[\"errorMessage\"] = \"\";",
          "539:   result[\"result\"] = true;",
          "541:   try {",
          "543:     if ( !checkECDSAKeyName(ethKeyName)){",
          "544:       throw RPCException(INVALID_ECDSA_KEY_NAME, \"Invalid ECDSA key name\");",
          "545:     }",
          "546:     if( !check_n_t(t, n) || ind > n || ind < 0){",
          "547:       throw RPCException(INVALID_DKG_PARAMS, \"Invalid DKG parameters: n or t \");",
          "548:     }",
          "549:     if ( !checkHex(SecretShare, SECRET_SHARE_NUM_BYTES)){",
          "550:       throw RPCException(INVALID_HEX, \"Invalid Secret share\");",
          "551:     }",
          "552:     if (publicShares.length() != (uint64_t ) 256 * t){",
          "553:       throw RPCException(INVALID_DKG_PARAMS, \"Invalid length of public shares\");",
          "554:     }",
          "556:     shared_ptr<string> encryptedKeyHex_ptr = readFromDb(ethKeyName);",
          "558:     if ( !VerifyShares(publicShares.c_str(), SecretShare.c_str(), encryptedKeyHex_ptr->c_str(), t, n, ind )){",
          "559:       result[\"result\"] = false;",
          "560:     }",
          "562:   } catch (RPCException &_e) {",
          "564:     result[\"status\"] = _e.status;",
          "565:     result[\"errorMessage\"] = _e.errString;",
          "566:     result[\"result\"] = false;",
          "567:   }",
          "569:   return result;",
          "572: Json::Value createBLSPrivateKeyImpl(const string & blsKeyName, const string& ethKeyName, const string& polyName, const string & SecretShare, int t, int n){",
          "574:   spdlog::info(\"createBLSPrivateKeyImpl entered\");",
          "576:   Json::Value result;",
          "577:   result[\"status\"] = 0;",
          "578:   result[\"errorMessage\"] = \"\";",
          "580:   try {",
          "582:     if (SecretShare.length() != (uint64_t ) n * 192){",
          "583:       spdlog::info(\"wrong length of secret shares - {}\", SecretShare.length());",
          "584:       spdlog::info(\"secret shares - {}\", SecretShare);",
          "585:       throw RPCException(INVALID_SECRET_SHARES_LENGTH, \"Invalid secret share length\");",
          "586:     }",
          "587:     if ( !checkECDSAKeyName(ethKeyName)){",
          "588:       throw RPCException(INVALID_ECDSA_KEY_NAME, \"Invalid ECDSA key name\");",
          "589:     }",
          "590:     if ( !checkName(polyName, \"POLY\")){",
          "591:       throw RPCException(INVALID_POLY_NAME, \"Invalid polynomial name\");",
          "592:     }",
          "593:     if ( !checkName(blsKeyName, \"BLS_KEY\")){",
          "594:       throw RPCException(INVALID_POLY_NAME, \"Invalid BLS key name\");",
          "595:     }",
          "596:     if( !check_n_t(t, n)){",
          "597:       throw RPCException(INVALID_DKG_PARAMS, \"Invalid DKG parameters: n or t \");",
          "598:     }",
          "599:     vector<string> sshares_vect;",
          "600:     if (DEBUG_PRINT) {",
          "601:       spdlog::info(\"secret shares from json are - {}\", SecretShare);",
          "602:     }",
          "604:     shared_ptr<string> encryptedKeyHex_ptr = readFromDb(ethKeyName);",
          "606:     bool res = CreateBLSShare(blsKeyName, SecretShare.c_str(), encryptedKeyHex_ptr->c_str());",
          "607:      if (res){",
          "608:          spdlog::info(\"BLS KEY SHARE CREATED \");",
          "609:      }",
          "610:      else {",
          "611:        throw RPCException(-122, \"Error while creating BLS key share\");",
          "612:      }",
          "614:      for ( int i = 0; i < n; i++){",
          "615:        string name = polyName + \"_\" + to_string(i) + \":\";",
          "616:        LevelDB::getLevelDb() -> deleteDHDKGKey(name);",
          "617:        string shareG2_name = \"shareG2_\" + polyName + \"_\" + to_string(i) + \":\";",
          "618:        LevelDB::getLevelDb() -> deleteKey(shareG2_name);",
          "619:      }",
          "621:   } catch (RPCException &_e) {",
          "623:     result[\"status\"] = _e.status;",
          "624:     result[\"errorMessage\"] = _e.errString;",
          "626:   }",
          "628:   return result;",
          "631: Json::Value getBLSPublicKeyShareImpl(const string & blsKeyName){",
          "638:       if ( !checkName(blsKeyName, \"BLS_KEY\")){",
          "639:         throw RPCException(INVALID_POLY_NAME, \"Invalid BLSKey name\");",
          "640:       }",
          "641:       shared_ptr<string> encryptedKeyHex_ptr = readFromDb(blsKeyName);",
          "642:       if (DEBUG_PRINT) {",
          "643:         spdlog::info(\"encr_bls_key_share is {}\", *encryptedKeyHex_ptr);",
          "644:         spdlog::info(\"length is {}\", encryptedKeyHex_ptr->length());",
          "647:       }",
          "648:       vector<string> public_key_vect = GetBLSPubKey(encryptedKeyHex_ptr->c_str());",
          "649:       for ( uint8_t i = 0; i < 4; i++) {",
          "650:         result[\"blsPublicKeyShare\"][i] = public_key_vect.at(i);",
          "651:       }",
          "",
          "[Added Lines]",
          "527: Json::Value SGXWalletServer::dkgVerificationImpl(const string &publicShares, const string &ethKeyName,",
          "528:                                 const string &SecretShare, int t, int n, int ind) {",
          "530:     spdlog::info(\"enter dkgVerificationImpl\");",
          "532:     Json::Value result;",
          "533:     result[\"status\"] = 0;",
          "534:     result[\"errorMessage\"] = \"\";",
          "535:     result[\"result\"] = true;",
          "537:     try {",
          "539:         if (!checkECDSAKeyName(ethKeyName)) {",
          "540:             throw RPCException(INVALID_ECDSA_KEY_NAME, \"Invalid ECDSA key name\");",
          "541:         }",
          "542:         if (!check_n_t(t, n) || ind > n || ind < 0) {",
          "543:             throw RPCException(INVALID_DKG_PARAMS, \"Invalid DKG parameters: n or t \");",
          "544:         }",
          "545:         if (!checkHex(SecretShare, SECRET_SHARE_NUM_BYTES)) {",
          "546:             throw RPCException(INVALID_HEX, \"Invalid Secret share\");",
          "547:         }",
          "548:         if (publicShares.length() != (uint64_t) 256 * t) {",
          "549:             throw RPCException(INVALID_DKG_PARAMS, \"Invalid length of public shares\");",
          "550:         }",
          "552:         shared_ptr<string> encryptedKeyHex_ptr = readFromDb(ethKeyName);",
          "554:         if (!VerifyShares(publicShares.c_str(), SecretShare.c_str(), encryptedKeyHex_ptr->c_str(), t, n, ind)) {",
          "555:             result[\"result\"] = false;",
          "556:         }",
          "558:     } catch (RPCException &_e) {",
          "560:         result[\"status\"] = _e.status;",
          "561:         result[\"errorMessage\"] = _e.errString;",
          "562:         result[\"result\"] = false;",
          "563:     }",
          "565:     return result;",
          "568: Json::Value SGXWalletServer::createBLSPrivateKeyImpl(const string &blsKeyName, const string &ethKeyName, const string &polyName,",
          "569:                                     const string &SecretShare, int t, int n) {",
          "571:     spdlog::info(\"createBLSPrivateKeyImpl entered\");",
          "573:     Json::Value result;",
          "574:     result[\"status\"] = 0;",
          "575:     result[\"errorMessage\"] = \"\";",
          "577:     try {",
          "579:         if (SecretShare.length() != (uint64_t) n * 192) {",
          "580:             spdlog::info(\"wrong length of secret shares - {}\", SecretShare.length());",
          "581:             spdlog::info(\"secret shares - {}\", SecretShare);",
          "582:             throw RPCException(INVALID_SECRET_SHARES_LENGTH, \"Invalid secret share length\");",
          "583:         }",
          "584:         if (!checkECDSAKeyName(ethKeyName)) {",
          "585:             throw RPCException(INVALID_ECDSA_KEY_NAME, \"Invalid ECDSA key name\");",
          "586:         }",
          "587:         if (!checkName(polyName, \"POLY\")) {",
          "588:             throw RPCException(INVALID_POLY_NAME, \"Invalid polynomial name\");",
          "589:         }",
          "590:         if (!checkName(blsKeyName, \"BLS_KEY\")) {",
          "591:             throw RPCException(INVALID_POLY_NAME, \"Invalid BLS key name\");",
          "592:         }",
          "593:         if (!check_n_t(t, n)) {",
          "594:             throw RPCException(INVALID_DKG_PARAMS, \"Invalid DKG parameters: n or t \");",
          "595:         }",
          "596:         vector<string> sshares_vect;",
          "597:         if (printDebugInfo) {",
          "598:             spdlog::info(\"secret shares from json are - {}\", SecretShare);",
          "599:         }",
          "601:         shared_ptr<string> encryptedKeyHex_ptr = readFromDb(ethKeyName);",
          "603:         bool res = CreateBLSShare(blsKeyName, SecretShare.c_str(), encryptedKeyHex_ptr->c_str());",
          "604:         if (res) {",
          "605:             spdlog::info(\"BLS KEY SHARE CREATED \");",
          "606:         } else {",
          "607:             throw RPCException(-122, \"Error while creating BLS key share\");",
          "608:         }",
          "610:         for (int i = 0; i < n; i++) {",
          "611:             string name = polyName + \"_\" + to_string(i) + \":\";",
          "612:             LevelDB::getLevelDb()->deleteDHDKGKey(name);",
          "613:             string shareG2_name = \"shareG2_\" + polyName + \"_\" + to_string(i) + \":\";",
          "614:             LevelDB::getLevelDb()->deleteKey(shareG2_name);",
          "615:         }",
          "617:     } catch (RPCException &_e) {",
          "619:         result[\"status\"] = _e.status;",
          "620:         result[\"errorMessage\"] = _e.errString;",
          "622:     }",
          "624:     return result;",
          "627: Json::Value SGXWalletServer::getBLSPublicKeyShareImpl(const string &blsKeyName) {",
          "634:         if (!checkName(blsKeyName, \"BLS_KEY\")) {",
          "635:             throw RPCException(INVALID_POLY_NAME, \"Invalid BLSKey name\");",
          "636:         }",
          "637:         shared_ptr<string> encryptedKeyHex_ptr = readFromDb(blsKeyName);",
          "638:         if (printDebugInfo) {",
          "639:             spdlog::info(\"encr_bls_key_share is {}\", *encryptedKeyHex_ptr);",
          "640:             spdlog::info(\"length is {}\", encryptedKeyHex_ptr->length());",
          "643:         }",
          "644:         vector<string> public_key_vect = GetBLSPubKey(encryptedKeyHex_ptr->c_str());",
          "645:         for (uint8_t i = 0; i < 4; i++) {",
          "646:             result[\"blsPublicKeyShare\"][i] = public_key_vect.at(i);",
          "647:         }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "661:     return result;",
          "662: }",
          "688: }",
          "691:     Json::Value result;",
          "692:     result[\"status\"] = 0;",
          "693:     result[\"errorMessage\"] = \"\";",
          "694:     try {",
          "695:         spdlog::info(\"multG2Impl try \");",
          "696:         vector<string> xG2_vect = mult_G2(x);",
          "698:             result[\"x*G2\"][i] = xG2_vect.at(i);",
          "699:         }",
          "",
          "[Removed Lines]",
          "664: Json::Value complaintResponseImpl(const string& polyName, int ind){",
          "665:   Json::Value result;",
          "666:   result[\"status\"] = 0;",
          "667:   result[\"errorMessage\"] = \"\";",
          "668:   try {",
          "669:     if ( !checkName(polyName, \"POLY\")){",
          "670:       throw RPCException(INVALID_POLY_NAME, \"Invalid polynomial name\");",
          "671:     }",
          "672:     string shareG2_name = \"shareG2_\" + polyName + \"_\" + to_string(ind) + \":\";",
          "673:     shared_ptr<string> shareG2_ptr = readFromDb(shareG2_name);",
          "675:     string DHKey = decrypt_DHKey(polyName, ind);",
          "677:     result[\"share*G2\"] = *shareG2_ptr;",
          "678:     result[\"dhKey\"] = DHKey;",
          "680:   } catch (RPCException &_e) {",
          "681:     cerr << \" err str \" << _e.errString << endl;",
          "682:     result[\"status\"] = _e.status;",
          "683:     result[\"errorMessage\"] = _e.errString;",
          "684:   }",
          "686:   return result;",
          "690: Json::Value multG2Impl(const string& x){",
          "697:         for ( uint8_t i = 0; i < 4; i++) {",
          "",
          "[Added Lines]",
          "660: Json::Value SGXWalletServer::complaintResponseImpl(const string &polyName, int ind) {",
          "661:     Json::Value result;",
          "662:     result[\"status\"] = 0;",
          "663:     result[\"errorMessage\"] = \"\";",
          "664:     try {",
          "665:         if (!checkName(polyName, \"POLY\")) {",
          "666:             throw RPCException(INVALID_POLY_NAME, \"Invalid polynomial name\");",
          "667:         }",
          "668:         string shareG2_name = \"shareG2_\" + polyName + \"_\" + to_string(ind) + \":\";",
          "669:         shared_ptr<string> shareG2_ptr = readFromDb(shareG2_name);",
          "671:         string DHKey = decrypt_DHKey(polyName, ind);",
          "673:         result[\"share*G2\"] = *shareG2_ptr;",
          "674:         result[\"dhKey\"] = DHKey;",
          "676:     } catch (RPCException &_e) {",
          "677:         cerr << \" err str \" << _e.errString << endl;",
          "678:         result[\"status\"] = _e.status;",
          "679:         result[\"errorMessage\"] = _e.errString;",
          "680:     }",
          "682:     return result;",
          "686: Json::Value SGXWalletServer::multG2Impl(const string &x) {",
          "693:         for (uint8_t i = 0; i < 4; i++) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "707:     return result;",
          "708: }",
          "711:     Json::Value result;",
          "712:     try {",
          "719:         result[\"status\"] = 0;",
          "720:         result[\"errorMessage\"] = \"\";",
          "722:     } catch (RPCException &_e) {",
          "727:     }",
          "729:     return result;",
          "730: }",
          "739: }",
          "746: }",
          "751: }",
          "754:     lock_guard<recursive_mutex> lock(m);",
          "755:     return getSecretShareImpl(polyName, publicKeys, t, n);",
          "756: }",
          "761: }",
          "766: }",
          "769:     lock_guard<recursive_mutex> lock(m);",
          "770:     return getBLSPublicKeyShareImpl(blsKeyName);",
          "771: }",
          "775: Json::Value SGXWalletServer::generateECDSAKey() {",
          "777:     return generateECDSAKeyImpl();",
          "778: }",
          "783: }",
          "785: Json::Value SGXWalletServer::getPublicECDSAKey(const string &_keyName) {",
          "788: }",
          "798: }",
          "801: Json::Value",
          "804:     lock_guard<recursive_mutex> lock(m);",
          "806: }",
          "808: Json::Value SGXWalletServer::blsSignMessageHash(const string &keyShareName, const string &messageHash, int t, int n,",
          "810:     lock_guard<recursive_mutex> lock(m);",
          "811:     return blsSignMessageHashImpl(keyShareName, messageHash, t, n, signerIndex);",
          "812: }",
          "814: Json::Value SGXWalletServer::importECDSAKey(const string &key, const string &keyName) {",
          "817: }",
          "822: }",
          "825:     lock_guard<recursive_mutex> lock(m);",
          "826:     return multG2Impl(x);",
          "827: }",
          "830:     lock_guard<recursive_mutex> lock(m);",
          "831:     return isPolyExistsImpl(polyName);",
          "832: }",
          "834: Json::Value SGXWalletServer::getServerStatus() {",
          "837: }",
          "848: }",
          "852:     auto keyShareStr = LevelDB::getLevelDb()->readString(\"BLSKEYSHARE:\" + _keyShareName);",
          "",
          "[Removed Lines]",
          "710: Json::Value isPolyExistsImpl(const string& polyName){",
          "713:     std::shared_ptr<std::string> poly_str_ptr = LevelDB::getLevelDb()->readString(polyName);",
          "714:     result[\"IsExist\"] = true;",
          "715:     result[\"status\"] = 0;",
          "716:     result[\"errorMessage\"] = \"\";",
          "717:     if (poly_str_ptr == nullptr){",
          "718:         result[\"IsExist\"] = false;",
          "721:     }",
          "723:       std::cerr << \" err str \" << _e.errString << std::endl;",
          "724:       result[\"status\"] = _e.status;",
          "725:       result[\"errorMessage\"] = _e.errString;",
          "726:       result[\"IsExist\"] = false;",
          "732: Json::Value getServerStatusImpl() {",
          "734:   Json::Value result;",
          "735:   result[\"status\"] = 0;",
          "736:   result[\"errorMessage\"] = \"\";",
          "738:   return result;",
          "742: Json::Value SGXWalletServer::generateDKGPoly(const string& polyName, int t){",
          "743:   spdlog::info(\"entered generateDKGPoly\");",
          "744:   lock_guard<recursive_mutex> lock(m);",
          "745:   return generateDKGPolyImpl(polyName, t);",
          "748: Json::Value SGXWalletServer::getVerificationVector(const string& polyName, int t, int n){",
          "749:   lock_guard<recursive_mutex> lock(m);",
          "750:   return getVerificationVectorImpl(polyName, t, n);",
          "753: Json::Value SGXWalletServer::getSecretShare(const string& polyName, const Json::Value& publicKeys, int t, int n){",
          "758: Json::Value  SGXWalletServer::dkgVerification( const string& publicShares, const string& ethKeyName, const string& SecretShare, int t, int n, int index){",
          "759:   lock_guard<recursive_mutex> lock(m);",
          "760:   return dkgVerificationImpl(publicShares, ethKeyName, SecretShare, t, n, index);",
          "763: Json::Value SGXWalletServer::createBLSPrivateKey(const string & blsKeyName, const string& ethKeyName, const string& polyName, const string& SecretShare, int t, int n){",
          "764:   lock_guard<recursive_mutex> lock(m);",
          "765:   return createBLSPrivateKeyImpl(blsKeyName, ethKeyName, polyName, SecretShare, t, n);",
          "768: Json::Value SGXWalletServer::getBLSPublicKeyShare(const string & blsKeyName){",
          "776:   lock_guard<recursive_mutex> lock(m);",
          "780: Json::Value SGXWalletServer::renameECDSAKey(const string& KeyName, const string& tempKeyName){",
          "781:   lock_guard<recursive_mutex> lock(m);",
          "782:   return renameECDSAKeyImpl(KeyName, tempKeyName);",
          "786:   lock_guard<recursive_mutex> lock(m);",
          "787:   return getPublicECDSAKeyImpl(_keyName);",
          "791: Json::Value SGXWalletServer::ecdsaSignMessageHash(int base, const string &_keyName, const string &messageHash ) {",
          "792:   lock_guard<recursive_mutex> lock(m);",
          "793:   spdlog::info(\"entered ecdsaSignMessageHash\");",
          "794:   if (DEBUG_PRINT) {",
          "795:     spdlog::info(\"MessageHash first {}\", messageHash);",
          "796:   }",
          "797:   return ecdsaSignMessageHashImpl(base,_keyName, messageHash);",
          "802: SGXWalletServer::importBLSKeyShare(const string &_keyShare, const string &_keyShareName, int t, int n,",
          "803:                                     int index) {",
          "805:     return importBLSKeyShareImpl(_keyShare, _keyShareName, t, n, index );",
          "809:                                         int signerIndex) {",
          "815:   lock_guard<recursive_mutex> lock(m);",
          "816:   return importECDSAKeyImpl(key, keyName);",
          "819: Json::Value SGXWalletServer::complaintResponse(const string& polyName, int ind){",
          "820:   lock_guard<recursive_mutex> lock(m);",
          "821:   return complaintResponseImpl(polyName, ind);",
          "824: Json::Value SGXWalletServer::multG2(const string& x){",
          "829: Json::Value SGXWalletServer::isPolyExists(const string& polyName){",
          "835:   lock_guard<recursive_mutex> lock(m);",
          "836:   return getServerStatusImpl();",
          "839: shared_ptr<string> readFromDb(const string & name, const string & prefix) {",
          "841:   auto dataStr = LevelDB::getLevelDb()->readString(prefix + name);",
          "843:   if (dataStr == nullptr) {",
          "844:     throw RPCException(KEY_SHARE_DOES_NOT_EXIST, \"Data with this name does not exist\");",
          "845:   }",
          "847:   return dataStr;",
          "850: shared_ptr<string> readKeyShare(const string &_keyShareName) {",
          "",
          "[Added Lines]",
          "706: Json::Value SGXWalletServer::isPolyExistsImpl(const string &polyName) {",
          "709:         std::shared_ptr<std::string> poly_str_ptr = LevelDB::getLevelDb()->readString(polyName);",
          "710:         result[\"IsExist\"] = true;",
          "713:         if (poly_str_ptr == nullptr) {",
          "714:             result[\"IsExist\"] = false;",
          "715:             result[\"status\"] = 0;",
          "716:             result[\"errorMessage\"] = \"\";",
          "717:         }",
          "719:         std::cerr << \" err str \" << _e.errString << std::endl;",
          "720:         result[\"status\"] = _e.status;",
          "721:         result[\"errorMessage\"] = _e.errString;",
          "722:         result[\"IsExist\"] = false;",
          "728: Json::Value SGXWalletServer::getServerStatusImpl() {",
          "730:     Json::Value result;",
          "731:     result[\"status\"] = 0;",
          "732:     result[\"errorMessage\"] = \"\";",
          "734:     return result;",
          "738: Json::Value SGXWalletServer::generateDKGPoly(const string &polyName, int t) {",
          "739:     spdlog::info(\"entered generateDKGPoly\");",
          "740:     lock_guard<recursive_mutex> lock(m);",
          "741:     return generateDKGPolyImpl(polyName, t);",
          "744: Json::Value SGXWalletServer::getVerificationVector(const string &polyName, int t, int n) {",
          "745:     lock_guard<recursive_mutex> lock(m);",
          "746:     return getVerificationVectorImpl(polyName, t, n);",
          "749: Json::Value SGXWalletServer::getSecretShare(const string &polyName, const Json::Value &publicKeys, int t, int n) {",
          "754: Json::Value",
          "755: SGXWalletServer::dkgVerification(const string &publicShares, const string &ethKeyName, const string &SecretShare, int t,",
          "756:                                  int n, int index) {",
          "757:     lock_guard<recursive_mutex> lock(m);",
          "758:     return dkgVerificationImpl(publicShares, ethKeyName, SecretShare, t, n, index);",
          "761: Json::Value",
          "762: SGXWalletServer::createBLSPrivateKey(const string &blsKeyName, const string &ethKeyName, const string &polyName,",
          "763:                                      const string &SecretShare, int t, int n) {",
          "764:     lock_guard<recursive_mutex> lock(m);",
          "765:     return createBLSPrivateKeyImpl(blsKeyName, ethKeyName, polyName, SecretShare, t, n);",
          "768: Json::Value SGXWalletServer::getBLSPublicKeyShare(const string &blsKeyName) {",
          "775:     lock_guard<recursive_mutex> lock(m);",
          "779: Json::Value SGXWalletServer::renameECDSAKey(const string &KeyName, const string &tempKeyName) {",
          "780:     lock_guard<recursive_mutex> lock(m);",
          "781:     return renameECDSAKeyImpl(KeyName, tempKeyName);",
          "785:     lock_guard<recursive_mutex> lock(m);",
          "786:     return getPublicECDSAKeyImpl(_keyName);",
          "790: Json::Value SGXWalletServer::ecdsaSignMessageHash(int base, const string &_keyName, const string &messageHash) {",
          "791:     lock_guard<recursive_mutex> lock(m);",
          "792:     spdlog::info(\"entered ecdsaSignMessageHash\");",
          "793:     if (printDebugInfo) {",
          "794:         spdlog::info(\"MessageHash first {}\", messageHash);",
          "795:     }",
          "796:     return ecdsaSignMessageHashImpl(base, _keyName, messageHash);",
          "801: SGXWalletServer::importBLSKeyShare(const string &_keyShare, const string &_keyShareName, int _t, int _n,",
          "802:                                    int index) {",
          "804:     return importBLSKeyShareImpl(_keyShare, _keyShareName, _t, _n, index);",
          "808:                                                 int signerIndex) {",
          "814:     lock_guard<recursive_mutex> lock(m);",
          "815:     return importECDSAKeyImpl(key, keyName);",
          "818: Json::Value SGXWalletServer::complaintResponse(const string &polyName, int ind) {",
          "819:     lock_guard<recursive_mutex> lock(m);",
          "820:     return complaintResponseImpl(polyName, ind);",
          "823: Json::Value SGXWalletServer::multG2(const string &x) {",
          "828: Json::Value SGXWalletServer::isPolyExists(const string &polyName) {",
          "834:     lock_guard<recursive_mutex> lock(m);",
          "835:     return getServerStatusImpl();",
          "838: shared_ptr<string> SGXWalletServer::readFromDb(const string &name, const string &prefix) {",
          "840:     auto dataStr = LevelDB::getLevelDb()->readString(prefix + name);",
          "842:     if (dataStr == nullptr) {",
          "843:         throw RPCException(KEY_SHARE_DOES_NOT_EXIST, \"Data with this name does not exist\");",
          "844:     }",
          "846:     return dataStr;",
          "849: shared_ptr<string> SGXWalletServer::readKeyShare(const string &_keyShareName) {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "860: }",
          "864:     Json::Value val;",
          "865:     Json::FastWriter writer;",
          "",
          "[Removed Lines]",
          "862: void writeKeyShare(const string &_keyShareName, const string &value, int index, int n, int t) {",
          "",
          "[Added Lines]",
          "861: void SGXWalletServer::writeKeyShare(const string &_keyShareName, const string &value, int index, int n, int t) {",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "880:     LevelDB::getLevelDb()->writeString(key, value);",
          "881: }",
          "901: }",
          "",
          "[Removed Lines]",
          "883: void writeDataToDB(const string & Name, const string &value) {",
          "884:   Json::Value val;",
          "885:   Json::FastWriter writer;",
          "887:   val[\"value\"] = value;",
          "888:   string json = writer.write(val);",
          "890:   auto key = Name;",
          "892:   if (LevelDB::getLevelDb()->readString(Name) != nullptr) {",
          "893:     spdlog::info(\"name {}\", Name, \" already exists\");",
          "894:     throw RPCException(KEY_SHARE_ALREADY_EXISTS, \"Data with this name already exists\");",
          "895:   }",
          "897:   LevelDB::getLevelDb()->writeString(key, value);",
          "898:   if (DEBUG_PRINT) {",
          "899:     spdlog::info(\"{} \", Name, \" is written to db \");",
          "900:   }",
          "",
          "[Added Lines]",
          "882: void SGXWalletServer::writeDataToDB(const string &Name, const string &value) {",
          "883:     Json::Value val;",
          "884:     Json::FastWriter writer;",
          "886:     val[\"value\"] = value;",
          "887:     string json = writer.write(val);",
          "889:     auto key = Name;",
          "891:     if (LevelDB::getLevelDb()->readString(Name) != nullptr) {",
          "892:         spdlog::info(\"name {}\", Name, \" already exists\");",
          "893:         throw RPCException(KEY_SHARE_ALREADY_EXISTS, \"Data with this name already exists\");",
          "894:     }",
          "896:     LevelDB::getLevelDb()->writeString(key, value);",
          "897:     if (printDebugInfo) {",
          "898:         spdlog::info(\"{} \", Name, \" is written to db \");",
          "899:     }",
          "",
          "---------------"
        ],
        "SGXWalletServer.h||SGXWalletServer.h": [
          "File: SGXWalletServer.h -> SGXWalletServer.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: #endif",
          "",
          "[Removed Lines]",
          "34: EXTERNC int init_https_server(bool check_certs );",
          "35: EXTERNC int init_http_server();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "SGXWalletServer.hpp||SGXWalletServer.hpp": [
          "File: SGXWalletServer.hpp -> SGXWalletServer.hpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: #define SGXWALLET_SGXWALLETSERVER_HPP",
          "30: #include \"abstractstubserver.h\"",
          "31: #include <mutex>",
          "35: using namespace jsonrpc;",
          "36: using namespace std;",
          "38: class SGXWalletServer : public AbstractStubServer {",
          "42:     std::recursive_mutex m;",
          "44: public:",
          "51:     virtual Json::Value generateECDSAKey();",
          "65:     virtual Json::Value getServerStatus();",
          "96: #endif //SGXWALLET_SGXWALLETSERVER_HPP",
          "",
          "[Removed Lines]",
          "41:     SGXWalletServer* server = nullptr;",
          "45:     SGXWalletServer(AbstractServerConnector &connector, serverVersion_t type);",
          "47:     virtual Json::Value importBLSKeyShare(const std::string& keyShare, const std::string& keyShareName, int t, int n, int index);",
          "48:     virtual Json::Value blsSignMessageHash(const std::string& keyShareName, const std::string& messageHash, int t, int n, int signerIndex);",
          "50:     virtual Json::Value importECDSAKey(const std::string& key, const std::string& keyName);",
          "52:     virtual Json::Value renameECDSAKey(const std::string& KeyName, const std::string& tempKeyName);",
          "53:     virtual Json::Value ecdsaSignMessageHash(int base, const std::string& keyShareName, const std::string& messageHash);",
          "54:     virtual Json::Value getPublicECDSAKey(const std::string& keyName);",
          "56:     virtual Json::Value generateDKGPoly(const std::string& polyName, int t);",
          "57:     virtual Json::Value getVerificationVector(const std::string& polyName, int t, int n);",
          "58:     virtual Json::Value getSecretShare(const std::string& polyName, const Json::Value& publicKeys, int t, int n);",
          "59:     virtual Json::Value dkgVerification(const std::string& publicShares, const std::string& ethKeyName, const std::string& SecretShare, int t, int n, int index);",
          "60:     virtual Json::Value createBLSPrivateKey(const std::string & blsKeyName, const std::string& ethKeyName, const std::string& polyName, const std::string & SecretShare, int t, int n);",
          "61:     virtual Json::Value getBLSPublicKeyShare(const std::string & blsKeyName);",
          "62:     virtual Json::Value complaintResponse(const std::string& polyName, int ind);",
          "63:     virtual Json::Value multG2(const std::string & x);",
          "64:     virtual Json::Value isPolyExists(const std::string& polyName);",
          "67: };",
          "69: shared_ptr<string> readFromDb(const string & name, const string & prefix = \"\");",
          "70: void writeDataToDB(const string & Name, const string &value);",
          "72: void writeKeyShare(const string &_keyShareName, const string &value, int index, int n, int t);",
          "73: shared_ptr<std::string> readKeyShare(const string& _keyShare);",
          "75: Json::Value importBLSKeyShareImpl(const std::string& keyShare, const std::string& keyShareName, int t, int n, int index);",
          "76: Json::Value blsSignMessageHashImpl(const std::string& keyShareName, const std::string& messageHash, int t, int n, int signerIndex);",
          "78: Json::Value importECDSAKeyImpl(const std::string& key, const std::string& keyName);",
          "79: Json::Value generateECDSAKeyImpl();",
          "80: Json::Value renameECDSAKeyImpl(const std::string& KeyName, const std::string& tempKeyName);",
          "81: Json::Value ecdsaSignMessageHashImpl(int base, const std::string& keyName, const std::string& messageHash);",
          "82: Json::Value getPublicECDSAKeyImpl(const std::string& keyName);",
          "84: Json::Value generateDKGPolyImpl(const std::string& polyName, int t);",
          "85: Json::Value getVerificationVectorImpl(const std::string& polyName, int t, int n);",
          "86: Json::Value getSecretShareImpl(const std::string& polyName, const Json::Value& publicKeys, int t, int n);",
          "87: Json::Value dkgVerificationImpl(const std::string& publicShares, const std::string& ethKeyName, const std::string& SecretShare, int t, int n, int index);",
          "88: Json::Value createBLSPrivateKeyImpl(const std::string & blsKeyName, const std::string& ethKeyName, const std::string& polyName, const std::string & SecretShare, int t, int n);",
          "89: Json::Value getBLSPublicKeyShareImpl(const std::string & blsKeyName);",
          "90: Json::Value complaintResponseImpl(const std::string& polyName, int ind);",
          "91: Json::Value multG2Impl(const std::string & x);",
          "92: Json::Value isPolyExistsImpl(const std::string& polyName);",
          "94: Json::Value getServerStatusImpl();",
          "",
          "[Added Lines]",
          "38:     SGXWalletServer *server = nullptr;",
          "42:     SGXWalletServer(AbstractServerConnector &_connector, serverVersion_t _type);",
          "44:     virtual Json::Value",
          "45:     importBLSKeyShare(const std::string &_keyShare, const std::string &_keyShareName, int _t, int _n, int index);",
          "47:     virtual Json::Value",
          "48:     blsSignMessageHash(const std::string &keyShareName, const std::string &messageHash, int t, int n, int signerIndex);",
          "50:     virtual Json::Value importECDSAKey(const std::string &key, const std::string &keyName);",
          "54:     virtual Json::Value renameECDSAKey(const std::string &KeyName, const std::string &tempKeyName);",
          "56:     virtual Json::Value ecdsaSignMessageHash(int base, const std::string &keyShareName, const std::string &messageHash);",
          "58:     virtual Json::Value getPublicECDSAKey(const std::string &keyName);",
          "60:     virtual Json::Value generateDKGPoly(const std::string &polyName, int t);",
          "62:     virtual Json::Value getVerificationVector(const std::string &polyName, int t, int n);",
          "64:     virtual Json::Value getSecretShare(const std::string &polyName, const Json::Value &publicKeys, int t, int n);",
          "66:     virtual Json::Value",
          "67:     dkgVerification(const std::string &publicShares, const std::string &ethKeyName, const std::string &SecretShare,",
          "68:                     int t, int n, int index);",
          "70:     virtual Json::Value",
          "71:     createBLSPrivateKey(const std::string &blsKeyName, const std::string &ethKeyName, const std::string &polyName,",
          "72:                         const std::string &SecretShare, int t, int n);",
          "74:     virtual Json::Value getBLSPublicKeyShare(const std::string &blsKeyName);",
          "76:     virtual Json::Value complaintResponse(const std::string &polyName, int ind);",
          "78:     virtual Json::Value multG2(const std::string &x);",
          "80:     virtual Json::Value isPolyExists(const std::string &polyName);",
          "84:     static shared_ptr<string> readFromDb(const string &name, const string &prefix = \"\");",
          "86:     static void writeDataToDB(const string &Name, const string &value);",
          "88:     static void writeKeyShare(const string &_keyShareName, const string &value, int index, int n, int t);",
          "90:     static shared_ptr<std::string> readKeyShare(const string &_keyShare);",
          "92:     static Json::Value",
          "93:     importBLSKeyShareImpl(const std::string &keyShare, const std::string &keyShareName, int t, int n, int index);",
          "95:     static Json::Value",
          "96:     blsSignMessageHashImpl(const std::string &keyShareName, const std::string &messageHash, int t, int n,",
          "97:                            int signerIndex);",
          "99:     static Json::Value importECDSAKeyImpl(const std::string &_key, const std::string &_keyName);",
          "101:     static Json::Value generateECDSAKeyImpl();",
          "103:     static Json::Value renameECDSAKeyImpl(const std::string &KeyName, const std::string &tempKeyName);",
          "105:     static Json::Value ecdsaSignMessageHashImpl(int base, const std::string &keyName, const std::string &messageHash);",
          "107:     static Json::Value getPublicECDSAKeyImpl(const std::string &keyName);",
          "109:     static Json::Value generateDKGPolyImpl(const std::string &polyName, int t);",
          "111:     static Json::Value getVerificationVectorImpl(const std::string &polyName, int t, int n);",
          "113:     static Json::Value getSecretShareImpl(const std::string &polyName, const Json::Value &publicKeys, int t, int n);",
          "115:     static Json::Value",
          "116:     dkgVerificationImpl(const std::string &publicShares, const std::string &ethKeyName, const std::string &SecretShare,",
          "117:                         int t, int n, int index);",
          "119:     static Json::Value",
          "120:     createBLSPrivateKeyImpl(const std::string &blsKeyName, const std::string &ethKeyName, const std::string &polyName,",
          "121:                             const std::string &SecretShare, int t, int n);",
          "123:     static Json::Value getBLSPublicKeyShareImpl(const std::string &blsKeyName);",
          "125:     static Json::Value complaintResponseImpl(const std::string &polyName, int ind);",
          "127:     static Json::Value multG2Impl(const std::string &x);",
          "129:     static Json::Value isPolyExistsImpl(const std::string &polyName);",
          "131:     static Json::Value getServerStatusImpl();",
          "133:     static void printDB();",
          "135:     static int initHttpServer();",
          "137:     static int initHttpsServer(bool _checkCerts);",
          "138: };",
          "",
          "---------------"
        ],
        "ServerInit.cpp||ServerInit.cpp": [
          "File: ServerInit.cpp -> ServerInit.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "65: #include <sys/types.h>",
          "66: #include <sys/stat.h>",
          "67: #include \"SGXWALLET_VERSION\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "67: #include \"SGXWalletServer.hpp\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "95:     }",
          "96: #endif",
          "99:       spdlog::info(\"SGX_DEBUG_FLAG = {}\", SGX_DEBUG_FLAG);",
          "100:     }",
          "",
          "[Removed Lines]",
          "98:     if ( DEBUG_PRINT) {",
          "",
          "[Added Lines]",
          "99:     if ( printDebugInfo) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "121:         exit(1);",
          "122:     }",
          "125:       spdlog::info(\"libtgmp initialized\");",
          "127:     }",
          "",
          "[Removed Lines]",
          "124:     if (DEBUG_PRINT) {",
          "",
          "[Added Lines]",
          "125:     if (printDebugInfo) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "145:     sgxServerInited = 1;",
          "150:       init_csrmanager_server();",
          "151:     }",
          "152:     else {",
          "154:     }",
          "",
          "[Removed Lines]",
          "147:     if (is_sgx_https) {",
          "148:       init_https_server(check_cert);",
          "149:       init_registration_server(sign_automatically);",
          "153:       init_http_server();",
          "",
          "[Added Lines]",
          "148:     if (useHTTPS) {",
          "149:         SGXWalletServer::initHttpsServer(check_cert);",
          "150:         initRegistrationServer(sign_automatically);",
          "154:         SGXWalletServer::initHttpServer();",
          "",
          "---------------"
        ],
        "docker/start.sh||docker/start.sh": [
          "File: docker/start.sh -> docker/start.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "20:   ./testw [is_poly_test]",
          "21:   ./testw [AES-encrypt-decrypt]",
          "22: ./testw [ecdsa_api_test]",
          "24:  ./testw [bls_sign]",
          "25: ./testw [many_threads_test]",
          "26:   ./testw [aes_dkg]",
          "",
          "[Removed Lines]",
          "23: ./testw [dkg-encr_sshares]",
          "",
          "[Added Lines]",
          "23: #./testw [dkg-encr_sshares]",
          "",
          "---------------"
        ],
        "sgxwallet.c||sgxwallet.c": [
          "File: sgxwallet.c -> sgxwallet.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "67:     exit(1);",
          "68:   }",
          "72:   while ((opt = getopt(argc, argv, \"cshd0aby\")) != -1) {",
          "73:     switch (opt) {",
          "",
          "[Removed Lines]",
          "70:   is_aes = 0;",
          "",
          "[Added Lines]",
          "70:     encryptKeys = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "91:       sign_automatically = true;",
          "92:       break;",
          "93:     case 'd':",
          "95:       break;",
          "96:     case '0':",
          "98:      break;",
          "99:     case 'a':",
          "101:       break;",
          "102:     case 'b':",
          "103:       SEK_initializer = enter_SEK;",
          "",
          "[Removed Lines]",
          "94:       DEBUG_PRINT = 1;",
          "97:       is_sgx_https = 0;",
          "100:       is_aes = 0;",
          "",
          "[Added Lines]",
          "94:         printDebugInfo = 1;",
          "97:         useHTTPS = 0;",
          "100:         encryptKeys = 0;",
          "",
          "---------------"
        ],
        "sgxwallet_common.h||sgxwallet_common.h": [
          "File: sgxwallet_common.h -> sgxwallet_common.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "41: extern bool autoconfirm;",
          "43: #define BUF_LEN 1024",
          "",
          "[Removed Lines]",
          "38: extern int DEBUG_PRINT;",
          "39: extern int is_sgx_https;",
          "40: extern int is_aes;",
          "",
          "[Added Lines]",
          "38: extern int printDebugInfo;",
          "39: extern int useHTTPS;",
          "40: extern int encryptKeys;",
          "",
          "---------------"
        ],
        "testw.cpp||testw.cpp": [
          "File: testw.cpp -> testw.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "123: TEST_CASE(\"BLS key encrypt\", \"[bls-key-encrypt]\") {",
          "126:     autoconfirm = true;",
          "127:     init_all(false, true, init_SEK);",
          "128:     auto key = encryptTestKey();",
          "",
          "[Removed Lines]",
          "124:     DEBUG_PRINT = 1;",
          "125:     is_sgx_https = 0;",
          "",
          "[Added Lines]",
          "124:     printDebugInfo = 1;",
          "125:     useHTTPS = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "134: TEST_CASE(\"BLS key encrypt/decrypt\", \"[bls-key-encrypt-decrypt]\") {",
          "135:     {",
          "139:         autoconfirm = true;",
          "141:         init_all(false, true, init_SEK);",
          "",
          "[Removed Lines]",
          "137:         DEBUG_PRINT = 1;",
          "138:         is_sgx_https = 0;",
          "",
          "[Added Lines]",
          "137:         printDebugInfo = 1;",
          "138:         useHTTPS = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "551: TEST_CASE(\"BLS_DKG test\", \"[bls_dkg]\") {",
          "554:     cerr << \"test started\" << endl;",
          "555:     init_all(false, true, init_SEK);",
          "556:     cerr << \"Server inited\" << endl;",
          "",
          "[Removed Lines]",
          "552:     is_sgx_https = 0;",
          "553:     DEBUG_PRINT = 1;",
          "",
          "[Added Lines]",
          "552:     useHTTPS = 0;",
          "553:     printDebugInfo = 1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "683: TEST_CASE(\"API test\", \"[api_test]\") {",
          "684:     autoconfirm = true;",
          "688:     cerr << \"API test started\" << endl;",
          "689:     init_all(false, true, init_SEK);",
          "",
          "[Removed Lines]",
          "686:     is_sgx_https = 0;",
          "",
          "[Added Lines]",
          "686:     useHTTPS = 0;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "790: TEST_CASE(\"getServerStatus test\", \"[getServerStatus_test]\") {",
          "791:     autoconfirm = true;",
          "793:     init_all(false, true, init_SEK);",
          "794:     HttpClient client(\"http://localhost:1029\");",
          "795:     StubClient c(client, JSONRPC_CLIENT_V2);",
          "",
          "[Removed Lines]",
          "792:     is_sgx_https = 0;",
          "",
          "[Added Lines]",
          "792:     useHTTPS = 0;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "912: TEST_CASE(\"ManySimultaneousThreads\", \"[many_threads_test]\") {",
          "913:     autoconfirm = true;",
          "918:     init_all(false, true, init_SEK);",
          "",
          "[Removed Lines]",
          "914:     is_sgx_https = 0;",
          "915:     DEBUG_PRINT = 1;",
          "916:     is_aes = 1;",
          "",
          "[Added Lines]",
          "914:     useHTTPS = 0;",
          "915:     printDebugInfo = 1;",
          "916:     encryptKeys = 1;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "933: TEST_CASE(\"ecdsa API test\", \"[ecdsa_api_test]\") {",
          "934:     autoconfirm = true;",
          "939:     cerr << \"ecdsa_api_test started\" << endl;",
          "940:     init_all(false, true, init_SEK);",
          "",
          "[Removed Lines]",
          "935:     DEBUG_PRINT = 1;",
          "936:     is_sgx_https = 0;",
          "937:     is_aes = 1;",
          "",
          "[Added Lines]",
          "935:     printDebugInfo = 1;",
          "936:     useHTTPS = 0;",
          "937:     encryptKeys = 1;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "985: TEST_CASE(\"dkg API test\", \"[dkg_api_test]\") {",
          "986:     autoconfirm = true;",
          "990:     cerr << \"dkg_api_test started\" << endl;",
          "991:     init_all(false, true, init_SEK);",
          "",
          "[Removed Lines]",
          "987:     DEBUG_PRINT = 1;",
          "988:     is_sgx_https = 0;",
          "",
          "[Added Lines]",
          "987:     printDebugInfo = 1;",
          "988:     useHTTPS = 0;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1063: TEST_CASE(\"isPolyExists test\", \"[is_poly_test]\") {",
          "1064:     autoconfirm = true;",
          "1068:     cerr << \"is_poly_test started\" << endl;",
          "1069:     init_all(false, true, init_SEK);",
          "",
          "[Removed Lines]",
          "1065:     DEBUG_PRINT = 1;",
          "1066:     is_sgx_https = 0;",
          "",
          "[Added Lines]",
          "1065:     printDebugInfo = 1;",
          "1066:     useHTTPS = 0;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1092: TEST_CASE(\"AES_DKG test\", \"[aes_dkg]\") {",
          "1093:     autoconfirm = true;",
          "1098:     reset_db();",
          "",
          "[Removed Lines]",
          "1094:     is_sgx_https = 0;",
          "1095:     DEBUG_PRINT = 1;",
          "1096:     is_aes = 1;",
          "",
          "[Added Lines]",
          "1094:     useHTTPS = 0;",
          "1095:     printDebugInfo = 1;",
          "1096:     encryptKeys = 1;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1224: TEST_CASE(\"bls_sign_api test\", \"[bls_sign]\") {",
          "1225:     autoconfirm = true;",
          "1230:     cerr << \"test started\" << endl;",
          "1231:     init_all(false, true, init_SEK);",
          "",
          "[Removed Lines]",
          "1226:     is_sgx_https = 0;",
          "1227:     DEBUG_PRINT = 1;",
          "1228:     is_aes = 1;",
          "",
          "[Added Lines]",
          "1226:     useHTTPS = 0;",
          "1227:     printDebugInfo = 1;",
          "1228:     encryptKeys = 1;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1258: TEST_CASE(\"AES encrypt/decrypt\", \"[AES-encrypt-decrypt]\") {",
          "1259:     {",
          "1260:         autoconfirm = true;",
          "1264:         init_all(false, true, init_SEK);",
          "",
          "[Removed Lines]",
          "1261:         DEBUG_PRINT = 1;",
          "1262:         is_sgx_https = 0;",
          "",
          "[Added Lines]",
          "1261:         printDebugInfo = 1;",
          "1262:         useHTTPS = 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a8ae2db02cff1fe490ac01821d3ed37c80aced6e",
      "candidate_info": {
        "commit_hash": "a8ae2db02cff1fe490ac01821d3ed37c80aced6e",
        "repo": "skalenetwork/sgxwallet",
        "commit_url": "https://github.com/skalenetwork/sgxwallet/commit/a8ae2db02cff1fe490ac01821d3ed37c80aced6e",
        "files": [
          "secure_enclave/AESUtils.c",
          "secure_enclave/AESUtils.h"
        ],
        "message": "SKALE-4262 cleanup",
        "before_after_code_files": [
          "secure_enclave/AESUtils.c||secure_enclave/AESUtils.c",
          "secure_enclave/AESUtils.h||secure_enclave/AESUtils.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "secure_enclave/AESUtils.c||secure_enclave/AESUtils.c",
            "secure_enclave/AESUtils.h||secure_enclave/AESUtils.h"
          ],
          "candidate": [
            "secure_enclave/AESUtils.c||secure_enclave/AESUtils.c",
            "secure_enclave/AESUtils.h||secure_enclave/AESUtils.h"
          ]
        }
      },
      "candidate_diff": {
        "secure_enclave/AESUtils.c||secure_enclave/AESUtils.c": [
          "File: secure_enclave/AESUtils.c -> secure_enclave/AESUtils.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:     @date 2020",
          "25: #include \"sgx_trts.h\"",
          "26: #include \"sgx_tcrypto.h\"",
          "27: #include \"stdlib.h\"",
          "28: #include <string.h>",
          "31: #include \"AESUtils.h\"",
          "33: sgx_aes_gcm_128bit_key_t AES_key[1024];",
          "36: #define SAFE_CHAR_BUF(__X__, __Y__)  ;char __X__ [ __Y__ ]; memset(__X__, 0, __Y__);",
          "39:                 unsigned char exportable, uint64_t* resultLen) {",
          "43:     if (!type) {",
          "44:         LOG_ERROR(\"Null type in AES_encrypt\");",
          "45:         return -1;",
          "",
          "[Removed Lines]",
          "38: int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrBufLen, unsigned  char type,",
          "",
          "[Added Lines]",
          "35: int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrBufLen, unsigned char type,",
          "",
          "---------------"
        ],
        "secure_enclave/AESUtils.h||secure_enclave/AESUtils.h": [
          "File: secure_enclave/AESUtils.h -> secure_enclave/AESUtils.h"
        ]
      }
    },
    {
      "candidate_hash": "bb63afeb3b7fb90790e7af08747176f042a1f43b",
      "candidate_info": {
        "commit_hash": "bb63afeb3b7fb90790e7af08747176f042a1f43b",
        "repo": "skalenetwork/sgxwallet",
        "commit_url": "https://github.com/skalenetwork/sgxwallet/commit/bb63afeb3b7fb90790e7af08747176f042a1f43b",
        "files": [
          "DKGCrypto.cpp",
          "DKGCrypto.h",
          "Makefile.am",
          "SGXWalletServer.cpp",
          "SGXWalletServer.hpp",
          "abstractstubserver.h",
          "secure_enclave/.deps/alt_bn128_init.Po",
          "secure_enclave/.deps/secure_enclave.Po",
          "secure_enclave/.deps/signature.Po",
          "secure_enclave/DKGUtils.cpp",
          "secure_enclave/Makefile.am.orig",
          "secure_enclave/drive_key_dkg.c",
          "secure_enclave/drive_key_dkg.h",
          "secure_enclave/secure_enclave.c",
          "secure_enclave/secure_enclave.c.orig",
          "secure_enclave/secure_enclave.edl",
          "sgxwallet_common.h",
          "spec.json",
          "stubclient.h",
          "testw.cpp"
        ],
        "message": "SKALE-1512-add-DKG-to-SGX Changes",
        "before_after_code_files": [
          "DKGCrypto.cpp||DKGCrypto.cpp",
          "DKGCrypto.h||DKGCrypto.h",
          "Makefile.am||Makefile.am",
          "SGXWalletServer.cpp||SGXWalletServer.cpp",
          "SGXWalletServer.hpp||SGXWalletServer.hpp",
          "abstractstubserver.h||abstractstubserver.h",
          "secure_enclave/.deps/alt_bn128_init.Po||secure_enclave/.deps/alt_bn128_init.Po",
          "secure_enclave/.deps/secure_enclave.Po||secure_enclave/.deps/secure_enclave.Po",
          "secure_enclave/.deps/signature.Po||secure_enclave/.deps/signature.Po",
          "secure_enclave/DKGUtils.cpp||secure_enclave/DKGUtils.cpp",
          "secure_enclave/Makefile.am.orig||secure_enclave/Makefile.am.orig",
          "secure_enclave/drive_key_dkg.c||secure_enclave/drive_key_dkg.c",
          "secure_enclave/drive_key_dkg.h||secure_enclave/drive_key_dkg.h",
          "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c",
          "secure_enclave/secure_enclave.c.orig||secure_enclave/secure_enclave.c.orig",
          "secure_enclave/secure_enclave.edl||secure_enclave/secure_enclave.edl",
          "sgxwallet_common.h||sgxwallet_common.h",
          "stubclient.h||stubclient.h",
          "testw.cpp||testw.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "DKGCrypto.cpp||DKGCrypto.cpp",
            "SGXWalletServer.cpp||SGXWalletServer.cpp",
            "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c",
            "secure_enclave/secure_enclave.edl||secure_enclave/secure_enclave.edl",
            "testw.cpp||testw.cpp"
          ],
          "candidate": [
            "DKGCrypto.cpp||DKGCrypto.cpp",
            "SGXWalletServer.cpp||SGXWalletServer.cpp",
            "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c",
            "secure_enclave/secure_enclave.edl||secure_enclave/secure_enclave.edl",
            "testw.cpp||testw.cpp"
          ]
        }
      },
      "candidate_diff": {
        "DKGCrypto.cpp||DKGCrypto.cpp": [
          "File: DKGCrypto.cpp -> DKGCrypto.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: #include \"DKGCrypto.h\"",
          "6: #include \"BLSCrypto.h\"",
          "7: #include \"sgxwallet.h\"",
          "8: #include <iostream>",
          "10: std::string gen_dkg_poly( int _t){",
          "11:     char *errMsg = (char *)calloc(1024, 1);",
          "12:     int err_status = 0;",
          "13:     uint8_t* encrypted_dkg_secret = (uint8_t *)calloc(2000, 1);",
          "15:     uint32_t enc_len = 0;",
          "17:     status = gen_dkg_secret (eid, &err_status, errMsg, encrypted_dkg_secret, &enc_len, _t);",
          "19:     char *hexEncrPoly = (char *) calloc(4*BUF_LEN, 1);",
          "20:     carray2Hex(encrypted_dkg_secret, enc_len, hexEncrPoly);",
          "21:     std::string result(hexEncrPoly);",
          "25:     free(errMsg);",
          "26:     free(encrypted_dkg_secret);",
          "27:     free(hexEncrPoly);",
          "29:     return result;",
          "30: }",
          "",
          "---------------"
        ],
        "DKGCrypto.h||DKGCrypto.h": [
          "File: DKGCrypto.h -> DKGCrypto.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #ifndef SGXD_DKGCRYPTO_H",
          "6: #define SGXD_DKGCRYPTO_H",
          "8: #endif //SGXD_DKGCRYPTO_H",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8: #include <string>",
          "10: std::string gen_dkg_poly( int _t);",
          "",
          "---------------"
        ],
        "Makefile.am||Makefile.am": [
          "File: Makefile.am -> Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "65: COMMON_SRC = sgx_stub.c sgx_detect_linux.c create_enclave.c oc_alloc.c",
          "66: COMMON_ENCLAVE_SRC = secure_enclave_u.c secure_enclave_u.h",
          "71: nodist_sgxwallet_SOURCES = $(COMMON_ENCLAVE_SRC)",
          "",
          "[Removed Lines]",
          "68: sgxwallet_SOURCES = sgxwallet.c SGXWalletServer.cpp RPCException.cpp  BLSCrypto.cpp ECDSACrypto.cpp ServerInit.cpp BLSPrivateKeyShareSGX.cpp LevelDB.cpp $(COMMON_SRC)",
          "",
          "[Added Lines]",
          "68: sgxwallet_SOURCES = sgxwallet.c SGXWalletServer.cpp RPCException.cpp  BLSCrypto.cpp ECDSACrypto.cpp \\",
          "69: DKGCrypto.cpp ServerInit.cpp BLSPrivateKeyShareSGX.cpp LevelDB.cpp $(COMMON_SRC)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "99: testw_SOURCES=testw.cpp stubclient.cpp SGXWalletServer.cpp  RPCException.cpp BLSCrypto.cpp ServerInit.cpp LevelDB.cpp \\",
          "101: nodist_testw_SOURCES=${nodist_sgxwallet_SOURCES}",
          "102: EXTRA_testw_DEPENDENCIES=${EXTRA_sgxwallet_DEPENDENCIES}",
          "103: testw_LDADD= ${sgxwallet_LDADD}",
          "",
          "[Removed Lines]",
          "100:     BLSPrivateKeyShareSGX.cpp ECDSACrypto.cpp $(COMMON_SRC)",
          "",
          "[Added Lines]",
          "101:  DKGCrypto.cpp BLSPrivateKeyShareSGX.cpp ECDSACrypto.cpp $(COMMON_SRC)",
          "",
          "---------------"
        ],
        "SGXWalletServer.cpp||SGXWalletServer.cpp": [
          "File: SGXWalletServer.cpp -> SGXWalletServer.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #include \"LevelDB.h\"",
          "25: #include \"BLSCrypto.h\"",
          "26: #include \"ECDSACrypto.h\"",
          "27: #include \"SGXWalletServer.h\"",
          "28: #include \"SGXWalletServer.hpp\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: #include \"DKGCrypto.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "232:     std::cerr << \"PublicKey\" << Pkey << std::endl;",
          "233:     result[\"PublicKey\"] = Pkey;",
          "238:     return result;",
          "239: }",
          "241: Json::Value SGXWalletServer::generateECDSAKey(const std::string &_keyName) {",
          "242:     return generateECDSAKeyImpl(_keyName);",
          "243: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "242: Json::Value generateDKGPolyImpl(const std::string& polyName, int t) {",
          "244:     Json::Value result;",
          "245:     result[\"status\"] = 0;",
          "246:     result[\"errorMessage\"] = \"\";",
          "250:     std::string encrPolyHex;",
          "252:     try {",
          "253:       encrPolyHex = gen_dkg_poly(t);",
          "254:       writeDKGPoly(polyName, encrPolyHex);",
          "255:     } catch (RPCException &_e) {",
          "256:         std::cerr << \" err str \" << _e.errString << std::endl;",
          "257:         result[\"status\"] = _e.status;",
          "258:         result[\"errorMessage\"] = _e.errString;",
          "259:     }",
          "263:     return result;",
          "264: }",
          "266: Json::Value SGXWalletServer::generateDKGPoly(const std::string& polyName, int t){",
          "267:     return generateDKGPolyImpl(polyName, t);",
          "268: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "296:     auto key = \"BLSKEYSHARE:\" + _keyShareName;",
          "298:     if (levelDb->readString(_keyShareName) != nullptr) {",
          "300:     }",
          "302:     levelDb->writeString(key, value);",
          "",
          "[Removed Lines]",
          "299:         throw new RPCException(KEY_SHARE_DOES_NOT_EXIST, \"Key share with this name already exists\");",
          "",
          "[Added Lines]",
          "328:         throw new RPCException(KEY_SHARE_ALREADY_EXISTS, \"Key share with this name already exists\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "322:     auto key = \"ECDSAKEY:\" + _keyName;",
          "324:     if (levelDb->readString(_keyName) != nullptr) {",
          "326:     }",
          "328:     levelDb->writeString(key, value);",
          "329: }",
          "",
          "[Removed Lines]",
          "325:         throw new RPCException(KEY_SHARE_DOES_NOT_EXIST, \"Key with this name already exists\");",
          "",
          "[Added Lines]",
          "354:         throw new RPCException(KEY_SHARE_ALREADY_EXISTS, \"Key with this name already exists\");",
          "358: }",
          "360: void writeDKGPoly(const string &_polyName, const string &value) {",
          "361:   Json::Value val;",
          "362:   Json::FastWriter writer;",
          "364:   val[\"value\"] = value;",
          "365:   std::string json = writer.write(val);",
          "367:   auto key = \"DKGPoly:\" + _polyName;",
          "369:   if (levelDb->readString(_polyName) != nullptr) {",
          "370:     throw new RPCException(KEY_SHARE_ALREADY_EXISTS, \"Poly with this name already exists\");",
          "371:   }",
          "373:   levelDb->writeString(key, value);",
          "",
          "---------------"
        ],
        "SGXWalletServer.hpp||SGXWalletServer.hpp": [
          "File: SGXWalletServer.hpp -> SGXWalletServer.hpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:     virtual Json::Value importBLSKeyShare(int index, const std::string& keyShare, const std::string& keyShareName, int n, int t);",
          "22:     virtual Json::Value blsSignMessageHash(const std::string& keyShareName, const std::string& messageHash);",
          "23:     virtual Json::Value importECDSAKey(const std::string& key, const std::string& keyName);",
          "24:     virtual Json::Value generateECDSAKey(const std::string& keyName);",
          "25:     virtual Json::Value ecdsaSignMessageHash(int base, const std::string& keyShareName, const std::string& messageHash );",
          "26:     virtual Json::Value getPublicECDSAKey(const std::string& keyName);",
          "27: };",
          "30: void writeKeyShare(const string &_keyShareName, const string &value, int index, int n, int t);",
          "32: shared_ptr<std::string> readKeyShare(const string& _keyShare);",
          "34: void writeECDSAKey(const string& _keyName, const string& value);",
          "36: shared_ptr<std::string> readECDSAKey(const string& _key);",
          "39: Json::Value importBLSKeyShareImpl(int index, const std::string& keyShare, const std::string& keyShareName, int n, int t);",
          "40: Json::Value blsSignMessageHashImpl(const std::string& keyShareName, const std::string& messageHash);",
          "41: Json::Value importECDSAKeyImpl(const std::string& key, const std::string& keyName);",
          "42: Json::Value generateECDSAKeyImpl(const std::string& keyName);",
          "43: Json::Value ecdsaSignMessageHashImpl(int base, const std::string& keyName, const std::string& messageHash);",
          "44: Json::Value getPublicECDSAKeyImpl(const std::string& keyName);",
          "48: #endif //SGXWALLET_SGXWALLETSERVER_HPP",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29:     virtual Json::Value generateDKGPoly(const std::string& polyName, int t);",
          "41: void writeDKGPoly(const string &_polyName, const string &value);",
          "52: Json::Value generateDKGPolyImpl(const std::string& polyName, int t);",
          "",
          "---------------"
        ],
        "abstractstubserver.h||abstractstubserver.h": [
          "File: abstractstubserver.h -> abstractstubserver.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "18:             this->bindAndAddMethod(jsonrpc::Procedure(\"generateECDSAKey\", jsonrpc::PARAMS_BY_NAME, jsonrpc::JSON_OBJECT, \"keyName\",jsonrpc::JSON_STRING, NULL), &AbstractStubServer::generateECDSAKeyI);",
          "19:             this->bindAndAddMethod(jsonrpc::Procedure(\"getPublicECDSAKey\", jsonrpc::PARAMS_BY_NAME, jsonrpc::JSON_OBJECT, \"keyName\",jsonrpc::JSON_STRING, NULL), &AbstractStubServer::getPublicECDSAKeyI);",
          "20:             this->bindAndAddMethod(jsonrpc::Procedure(\"ecdsaSignMessageHash\", jsonrpc::PARAMS_BY_NAME, jsonrpc::JSON_OBJECT, \"base\",jsonrpc::JSON_INTEGER,\"keyName\",jsonrpc::JSON_STRING,\"messageHash\",jsonrpc::JSON_STRING, NULL), &AbstractStubServer::ecdsaSignMessageHashI);",
          "21:         }",
          "23:         inline virtual void importBLSKeyShareI(const Json::Value &request, Json::Value &response)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21:             this->bindAndAddMethod(jsonrpc::Procedure(\"generateDKGPoly\", jsonrpc::PARAMS_BY_NAME, jsonrpc::JSON_OBJECT, \"keyName\",jsonrpc::JSON_STRING,\"t\",jsonrpc::JSON_INTEGER, NULL), &AbstractStubServer::generateDKGPolyI);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "44:         {",
          "45:             response = this->ecdsaSignMessageHash(request[\"base\"].asInt(), request[\"keyName\"].asString(), request[\"messageHash\"].asString());",
          "46:         }",
          "47:         virtual Json::Value importBLSKeyShare(int index, const std::string& keyShare, const std::string& keyShareName, int n, int t) = 0;",
          "48:         virtual Json::Value blsSignMessageHash(const std::string& keyShareName, const std::string& messageHash) = 0;",
          "49:         virtual Json::Value importECDSAKey(const std::string& key, const std::string& keyName) = 0;",
          "50:         virtual Json::Value generateECDSAKey(const std::string& keyName) = 0;",
          "51:         virtual Json::Value getPublicECDSAKey(const std::string& keyName) = 0;",
          "52:         virtual Json::Value ecdsaSignMessageHash(int base, const std::string& keyName, const std::string& messageHash) = 0;",
          "53: };",
          "55: #endif //JSONRPC_CPP_STUB_ABSTRACTSTUBSERVER_H_",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "48:         inline virtual void generateDKGPolyI(const Json::Value &request, Json::Value &response)",
          "49:         {",
          "50:             response = this->generateDKGPoly(request[\"keyName\"].asString(), request[\"t\"].asInt());",
          "51:         }",
          "58:         virtual Json::Value generateDKGPoly(const std::string& keyName, int t) = 0;",
          "",
          "---------------"
        ],
        "secure_enclave/.deps/alt_bn128_init.Po||secure_enclave/.deps/alt_bn128_init.Po": [
          "File: secure_enclave/.deps/alt_bn128_init.Po -> secure_enclave/.deps/alt_bn128_init.Po",
          "--- Hunk 1 ---",
          "[Context before]",
          "88:  ../trusted_libff/libff/algebra/fields/fp2.hpp \\",
          "89:  ../trusted_libff/libff/algebra/fields/fp2.tcc \\",
          "90:  ../trusted_libff/libff/algebra/curves/curve_utils.hpp \\",
          "93: ../trusted_libff/libff/algebra/curves/alt_bn128/alt_bn128_g1.hpp:",
          "",
          "[Removed Lines]",
          "91:  ../trusted_libff/libff/algebra/curves/curve_utils.tcc",
          "",
          "[Added Lines]",
          "91:  ../trusted_libff/libff/algebra/curves/curve_utils.tcc \\",
          "92:  ../trusted_libff/libff/algebra/curves/alt_bn128/alt_bn128_g2.hpp",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "267: ../trusted_libff/libff/algebra/curves/curve_utils.hpp:",
          "269: ../trusted_libff/libff/algebra/curves/curve_utils.tcc:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "272: ../trusted_libff/libff/algebra/curves/alt_bn128/alt_bn128_g2.hpp:",
          "",
          "---------------"
        ],
        "secure_enclave/.deps/secure_enclave.Po||secure_enclave/.deps/secure_enclave.Po": [
          "File: secure_enclave/.deps/secure_enclave.Po -> secure_enclave/.deps/secure_enclave.Po",
          "--- Hunk 1 ---",
          "[Context before]",
          "27:  /home/kladko/sgxwallet/sgx-sdk-build/sgxsdk/include/tlibc/stdio.h \\",
          "28:  /home/kladko/sgxwallet/sgx-sdk-build/sgxsdk/include/tlibc/stdarg.h \\",
          "29:  /home/kladko/sgxwallet/sgx-sdk-build/sgxsdk/include/tlibc/stdbool.h \\",
          "31:  /home/kladko/sgxwallet/sgx-sdk-build/sgxsdk/include/tlibc/unistd.h \\",
          "32:  /home/kladko/sgxwallet/sgx-sdk-build/sgxsdk/include/tlibc/sys/types.h \\",
          "33:  /home/kladko/sgxwallet/sgx-sdk-build/sgxsdk/include/tlibc/sys/endian.h",
          "",
          "[Removed Lines]",
          "30:  domain_parameters.h point.h signature.h curves.h ../sgxwallet_common.h \\",
          "",
          "[Added Lines]",
          "30:  domain_parameters.h point.h signature.h curves.h drive_key_dkg.h \\",
          "31:  ../sgxwallet_common.h \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "99: curves.h:",
          "101: ../sgxwallet_common.h:",
          "103: /home/kladko/sgxwallet/sgx-sdk-build/sgxsdk/include/tlibc/unistd.h:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "102: drive_key_dkg.h:",
          "",
          "---------------"
        ],
        "secure_enclave/.deps/signature.Po||secure_enclave/.deps/signature.Po": [
          "File: secure_enclave/.deps/signature.Po -> secure_enclave/.deps/signature.Po",
          "--- Hunk 1 ---",
          "[Context before]",
          "10:  /home/kladko/sgxwallet/sgx-sdk-build/sgxsdk/include/tlibc/sys/limits.h \\",
          "11:  /home/kladko/sgxwallet/sgx-sdk-build/sgxsdk/include/tlibc/stdbool.h \\",
          "12:  /home/kladko/sgxwallet/sgx-sdk-build/sgxsdk/include/tlibc/assert.h \\",
          "15: /home/kladko/sgxwallet/sgx-sdk-build/sgxsdk/include/tlibc/stdlib.h:",
          "",
          "[Removed Lines]",
          "13:  domain_parameters.h point.h signature.h numbertheory.h random.h",
          "",
          "[Added Lines]",
          "13:  domain_parameters.h point.h signature.h numbertheory.h",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "41: signature.h:",
          "43: numbertheory.h:",
          "",
          "[Removed Lines]",
          "45: random.h:",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "secure_enclave/DKGUtils.cpp||secure_enclave/DKGUtils.cpp": [
          "File: secure_enclave/DKGUtils.cpp -> secure_enclave/DKGUtils.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "111:     result += ConvertToString(secret_share);//stringFromFr(secret_share);",
          "112:     result += \":\";",
          "113:   }",
          "115: }",
          "117: void calc_public_shares(const char* decrypted_koefs, char * public_shares,",
          "",
          "[Removed Lines]",
          "114:   strncpy(secret_shares, result.c_str(), 2000);//result.length());",
          "",
          "[Added Lines]",
          "114:   strncpy(secret_shares, result.c_str(), result.length());",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "120:   std::string result;",
          "121:   char symbol = ':';",
          "122:   std::vector<libff::alt_bn128_Fr> poly =  SplitStringToFr(decrypted_koefs, symbol);",
          "124:   for (size_t i = 0; i < _t; ++i) {",
          "125:     libff::alt_bn128_G2 pub_share = poly.at(i) * libff::alt_bn128_G2::one() ;",
          "126:     pub_share.to_affine_coordinates();",
          "",
          "[Removed Lines]",
          "123:   libff::alt_bn128_Fr three = 3;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "secure_enclave/Makefile.am.orig||secure_enclave/Makefile.am.orig": [
          "File: secure_enclave/Makefile.am.orig -> secure_enclave/Makefile.am.orig",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "secure_enclave/drive_key_dkg.c||secure_enclave/drive_key_dkg.c": [
          "File: secure_enclave/drive_key_dkg.c -> secure_enclave/drive_key_dkg.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #include \"point.h\"",
          "11: #include \"numbertheory.h\"",
          "15:     domain_parameters curve = domain_parameters_init();",
          "16:     domain_parameters_load_curve(curve, secp256k1);",
          "19:     sgx_read_rand( rand_char, 32);",
          "21:     mpz_t seed;",
          "",
          "[Removed Lines]",
          "13: void gen_session_keys(mpz_t skey, char* pb_key){",
          "18:     unsigned char* rand_char = (unsigned char*)malloc(32);",
          "",
          "[Added Lines]",
          "14: void gen_session_key(char *skey_str, char* pb_keyB, char* common_key){",
          "16:     char* pb_keyB_x = (char*)malloc(64);",
          "17:     strncpy(pb_keyB_x, pb_keyB, 64);",
          "19:     char* pb_keyB_y = (char*)malloc(64);",
          "20:     strncpy(pb_keyB_y, pb_keyB + 64, 64);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "43:     domain_parameters_clear(curve);",
          "44: }",
          "",
          "[Removed Lines]",
          "36:     mpz_set(skey, skey_mpz);",
          "38:     point pub_key = point_init();",
          "39:     point_multiplication(pub_key, skey, curve->G, curve);",
          "41:     mpz_clear(skey_mpz);",
          "42:     point_clear(pub_key);",
          "",
          "[Added Lines]",
          "45:     mpz_t skey;",
          "46:     mpz_init(skey);",
          "47:     mpz_set_str(skey, skey_str, 16);",
          "49:     point pub_keyB = point_init();",
          "50:     point_set_hex(pub_keyB, pb_keyB_x, pb_keyB_y);",
          "52:     point session_key = point_init();",
          "53:     point_multiplication(session_key, skey, pub_keyB, curve);",
          "55:     char arr_x[mpz_sizeinbase (session_key->x, 16) + 2];",
          "56:     char* x = mpz_get_str(arr_x, 16, session_key->x);",
          "57:     strncpy(common_key, arr_x, 64);",
          "59:     mpz_clear(skey);",
          "60:     point_clear(pub_keyB);",
          "62:     free(pb_keyB_x);",
          "63:     free(pb_keyB_y);",
          "64: }",
          "66: void xor_encrypt(char* key, char* message, char* cypher){",
          "67:     for (int i = 0; i < 32; i++){",
          "68:         cypher[i] = message[i] ^ key[i];",
          "69:     }",
          "",
          "---------------"
        ],
        "secure_enclave/drive_key_dkg.h||secure_enclave/drive_key_dkg.h": [
          "File: secure_enclave/drive_key_dkg.h -> secure_enclave/drive_key_dkg.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #ifndef SGXD_DRIVE_KEY_DKG_H",
          "6: #define SGXD_DRIVE_KEY_DKG_H",
          "12: #endif //SGXD_DRIVE_KEY_DKG_H",
          "",
          "[Removed Lines]",
          "8: void gen_session_keys(mpz_t skey, char* pub_key);",
          "",
          "[Added Lines]",
          "9: void gen_session_key(char* skey, char* pub_keyB, char* common_key);",
          "11: void xor_encrypt(char* key, char* message, char* cypher);",
          "",
          "---------------"
        ],
        "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c": [
          "File: secure_enclave/secure_enclave.c -> secure_enclave/secure_enclave.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "533: }",
          "538:   char* pub_key = (char*)malloc(1024);",
          "540:   mpz_t skey;",
          "",
          "[Removed Lines]",
          "535: void drive_key(int *err_status, char *err_string, uint8_t *encrypted_skey, uint32_t* enc_len, char* result_str, char* pub_keyB ){",
          "",
          "[Added Lines]",
          "534: void drive_key(int *err_status, char *err_string, uint8_t *encrypted_skey, uint32_t* dec_len, char* result_str, char* pub_keyB ){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "551:   if(  status !=  SGX_SUCCESS) {",
          "552:     snprintf(err_string, BUF_LEN,\"SGX seal data failed\");",
          "556:   char* r = mpz_get_str(arr_r, base, sign->r);",
          "",
          "[Removed Lines]",
          "553:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "560:   char* s = mpz_get_str(arr_s, base, sign->s);",
          "564:   mpz_clear(skey);",
          "568: }",
          "",
          "[Removed Lines]",
          "566:  free(pub_key);",
          "",
          "[Added Lines]",
          "562:   char skey[ECDSA_SKEY_LEN];",
          "564:   sgx_status_t status = sgx_unseal_data(",
          "565:       (const sgx_sealed_data_t *)encrypted_skey, NULL, 0, skey, dec_len);",
          "566:   if (status != SGX_SUCCESS) {",
          "567:     snprintf(err_string, BUF_LEN,\"sgx_unseal_data failed with status %d\", status);",
          "568:     return;",
          "569:   }",
          "571:   char * common_key = malloc(64*2);",
          "573:   gen_session_key(skey, pub_keyB, common_key);",
          "",
          "---------------"
        ],
        "secure_enclave/secure_enclave.c.orig||secure_enclave/secure_enclave.c.orig": [
          "File: secure_enclave/secure_enclave.c.orig -> secure_enclave/secure_enclave.c.orig",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "secure_enclave/secure_enclave.edl||secure_enclave/secure_enclave.edl": [
          "File: secure_enclave/secure_enclave.edl -> secure_enclave/secure_enclave.edl",
          "--- Hunk 1 ---",
          "[Context before]",
          "41:       [user_check] int *err_status,",
          "42:       [out, count = 1024] char* err_string,",
          "43:       [in, count = 1024] char* key,",
          "46:         public void decrypt_key (",
          "47:       [user_check] int *err_status,",
          "",
          "[Removed Lines]",
          "44:       [out, count = 1024] uint8_t* encrypted_key, [user_check] uint32_t *enc_len);",
          "",
          "[Added Lines]",
          "44:       [out, count = 1024] uint8_t* encrypted_key,",
          "45:       [user_check] uint32_t *enc_len);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "62:         public void gen_dkg_secret (",
          "63:                      [user_check] int *err_status,",
          "64:                      [out, count = 1024] char* err_string,",
          "66:                      [user_check] uint32_t * enc_len,",
          "67:                      size_t _t);",
          "69:         public void decrypt_dkg_secret (",
          "70:                              [user_check] int *err_status,",
          "71:                              [out, count = 1024] char* err_string,",
          "74:                              uint32_t enc_len);",
          "76:         public void get_secret_shares (",
          "77:                                 [user_check] int *err_status,",
          "78:                                 [out, count = 1024] char* err_string,",
          "80:                                 uint32_t enc_len,",
          "82:                                 unsigned _t,",
          "83:                                 unsigned _n);",
          "85:          public void get_public_shares (",
          "86:                                 [user_check] int *err_status,",
          "87:                                 [out, count = 1024] char* err_string,",
          "89:                                 uint32_t enc_len,",
          "91:                                 unsigned _t,",
          "92:                                 unsigned _n);",
          "",
          "[Removed Lines]",
          "65:                      [out, count = 2000] uint8_t* encrypted_dkg_secret,",
          "72:                              [in, count = 2000] uint8_t* encrypted_dkg_secret,",
          "73:                              [out, count = 2000] uint8_t* decrypted_dkg_secret,",
          "79:                                 [in, count = 2000] uint8_t* encrypted_dkg_secret,",
          "81:                                 [out, count = 2000] char* secret_shares,",
          "88:                                 [in, count = 2000] uint8_t* decrypted_dkg_secret,",
          "90:                                 [out, count = 4000] char* public_shares,",
          "",
          "[Added Lines]",
          "66:                      [out, count = 3650] uint8_t* encrypted_dkg_secret,",
          "73:                              [in, count = 3650] uint8_t* encrypted_dkg_secret,",
          "74:                              [out, count = 3650] uint8_t* decrypted_dkg_secret,",
          "80:                                 [in, count = 3650] uint8_t* encrypted_dkg_secret,",
          "82:                                 [out, count = 3650] char* secret_shares,",
          "89:                                 [in, count = 3650] uint8_t* decrypted_dkg_secret,",
          "91:                                 [out, count = 10000] char* public_shares,",
          "",
          "---------------"
        ],
        "sgxwallet_common.h||sgxwallet_common.h": [
          "File: sgxwallet_common.h -> sgxwallet_common.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: #define ADD_ENTROPY_SIZE 32",
          "32: #define ECDSA_SKEY_LEN 65",
          "33: #define ECDSA_SKEY_BASE 16",
          "",
          "[Removed Lines]",
          "29: #define  DKG_BUFER_LENGTH 1250",
          "30: #define  DKG_MAX_SEALED_LEN 2000",
          "",
          "[Added Lines]",
          "29: #define  DKG_BUFER_LENGTH 3060",
          "30: #define  DKG_MAX_SEALED_LEN 3650",
          "",
          "---------------"
        ],
        "stubclient.h||stubclient.h": [
          "File: stubclient.h -> stubclient.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "80:             else",
          "81:                 throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());",
          "82:         }",
          "83: };",
          "85: #endif //JSONRPC_CPP_STUB_STUBCLIENT_H_",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "83:         Json::Value generateDKGPoly(const std::string& keyName, int t) throw (jsonrpc::JsonRpcException)",
          "84:         {",
          "85:             Json::Value p;",
          "86:             p[\"keyName\"] = keyName;",
          "87:             p[\"t\"] = t;",
          "88:             Json::Value result = this->CallMethod(\"generateDKGPoly\",p);",
          "89:             if (result.isObject())",
          "90:                 return result;",
          "91:             else",
          "92:                 throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());",
          "93:         }",
          "",
          "---------------"
        ],
        "testw.cpp||testw.cpp": [
          "File: testw.cpp -> testw.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "57: #include <sgx_tcrypto.h>",
          "59: #define CATCH_CONFIG_MAIN  // This tells Catch to provide a main() - only do this in one cpp file",
          "61: #include \"catch.hpp\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "59: #include <dkg/dkg.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "251: TEST_CASE( \"DKG gen test\", \"[dkg-gen]\" ) {",
          "255:   uint8_t* encrypted_dkg_secret = (uint8_t*) calloc(DKG_MAX_SEALED_LEN, 1);",
          "257:   char* errMsg = (char*) calloc(1024,1);",
          "258:   int err_status = 0;",
          "259:   uint32_t enc_len = 0;",
          "262:   REQUIRE(status == SGX_SUCCESS);",
          "263:   printf(\"gen_dkg_secret completed with status: %d %s \\n\", err_status, errMsg);",
          "264:   printf(\"\\n Length: %d \\n\", enc_len);",
          "",
          "[Removed Lines]",
          "253:   init_all();",
          "261:   status = gen_dkg_secret (eid, &err_status, errMsg, encrypted_dkg_secret, &enc_len, 16);",
          "",
          "[Added Lines]",
          "257:   init_enclave();",
          "264:   status = gen_dkg_secret (eid, &err_status, errMsg, encrypted_dkg_secret, &enc_len, 32);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "351:   int err_status = 0;",
          "352:   uint32_t enc_len = 0;",
          "356:   status = gen_dkg_secret (eid, &err_status, errMsg, encrypted_dkg_secret, &enc_len, n);",
          "357:   REQUIRE(status == SGX_SUCCESS);",
          "",
          "[Removed Lines]",
          "354:   unsigned t = 3, n = 4;",
          "",
          "[Added Lines]",
          "357:   unsigned t = 32, n = 32;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "379:   std::vector < libff::alt_bn128_Fr> poly = SplitStringToFr((char*)secret, colon);",
          "380:   std::vector < libff::alt_bn128_Fr> s_shares_dkg = dkg_obj.SecretKeyContribution(SplitStringToFr((char*)secret, colon));",
          "382:   for ( int  i = 0; i < s_shares_dkg.size(); i++){",
          "383:     libff::alt_bn128_Fr cur_share = s_shares_dkg.at(i);",
          "384:     mpz_t(sshare);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "384:   printf(\"calculated secret length %d : \\n\", s_shares_dkg.size());",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "388:     char* share_str = mpz_get_str(arr, 10, sshare);",
          "389:     printf(\" %s \\n\", share_str);",
          "390:     mpz_clear(sshare);",
          "394:   REQUIRE(s_shares == s_shares_dkg);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "394:   }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "411:   int err_status = 0;",
          "412:   uint32_t enc_len = 0;",
          "416:   status = gen_dkg_secret (eid, &err_status, errMsg, encrypted_dkg_secret, &enc_len, n);",
          "417:   REQUIRE(status == SGX_SUCCESS);",
          "",
          "[Removed Lines]",
          "414:   unsigned t = 3, n = 4;",
          "",
          "[Added Lines]",
          "416:   unsigned t = 32, n = 32;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "421:   char* errMsg1 = (char*) calloc(1024,1);",
          "423:   char colon = ':';",
          "425:   status = get_public_shares(eid, &err_status, errMsg1, encrypted_dkg_secret, enc_len, public_shares, t, n);",
          "426:   REQUIRE(status == SGX_SUCCESS);",
          "",
          "[Removed Lines]",
          "424:   char* public_shares = (char*)calloc(4000, 1);",
          "",
          "[Added Lines]",
          "426:   char* public_shares = (char*)calloc(10000, 1);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "439:   char* secret = (char*)calloc(DKG_MAX_SEALED_LEN, sizeof(char));",
          "440:   status = decrypt_dkg_secret(eid, &err_status, errMsg1, encrypted_dkg_secret, (uint8_t*)secret, enc_len);",
          "441:   REQUIRE(status == SGX_SUCCESS);",
          "444:   signatures::Dkg dkg_obj(t,n);",
          "446:   std::vector < libff::alt_bn128_Fr> poly = SplitStringToFr((char*)secret, colon);",
          "447:   std::vector < libff::alt_bn128_G2> pub_shares_dkg = dkg_obj.VerificationVector(poly);",
          "449:   for ( int  i = 0; i < pub_shares_dkg.size(); i++){",
          "450:     libff::alt_bn128_G2 el = pub_shares_dkg.at(i);",
          "451:     el.to_affine_coordinates();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "444:   printf(\"\\ndecrypt_dkg_secret completed with status: %d %s \\n\", err_status, errMsg1);",
          "450:   printf(\"calculated public shares (X.c0): \\n\");",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "457:     char* share_str = mpz_get_str(arr, 10, x_c0);",
          "458:     printf(\" %s \\n\", share_str);",
          "459:     mpz_clear(x_c0);",
          "462:   bool res = (pub_shares_G2 == pub_shares_dkg);",
          "463:   REQUIRE( res == true);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "462:   }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "516:   for ( int i = 0; i < 1024 ; i++)",
          "521:   printf(\"hash length %d \", strlen(hex));",
          "522:   char* signature_r = (char *)calloc(1024, 1);",
          "523:   char* signature_s = (char *)calloc(1024, 1);",
          "",
          "[Removed Lines]",
          "520:   char* hex = \"0x09c6137b97cdf159b9950f1492ee059d1e2b10eaf7d51f3a97d61f2eee2e81db\";",
          "",
          "[Added Lines]",
          "521:   char* hex = \"3F891FDA3704F0368DAB65FA81EBE616F4AA2A0854995DA4DC0B59D2CADBD64F\";",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "629:     try {",
          "633:     } catch (JsonRpcException &e) {",
          "634:         cerr << e.what() << endl;",
          "635:     }",
          "",
          "[Removed Lines]",
          "632:         cout << c.ecdsaSignMessageHash(16, \"known_key1\",\"0x09c6137b97cdf159b9950f1492ee059d1e2b10eaf7d51f3a97d61f2eee2e81db\" );",
          "",
          "[Added Lines]",
          "636:         cout << c.generateDKGPoly(\"poly\", 3);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "76216f0d11b63cd5076443837bc79547ba9d3bf8",
      "candidate_info": {
        "commit_hash": "76216f0d11b63cd5076443837bc79547ba9d3bf8",
        "repo": "skalenetwork/sgxwallet",
        "commit_url": "https://github.com/skalenetwork/sgxwallet/commit/76216f0d11b63cd5076443837bc79547ba9d3bf8",
        "files": [
          "secure_enclave/AESUtils.c"
        ],
        "message": "SKALE-4523 format code",
        "before_after_code_files": [
          "secure_enclave/AESUtils.c||secure_enclave/AESUtils.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "secure_enclave/AESUtils.c||secure_enclave/AESUtils.c"
          ],
          "candidate": [
            "secure_enclave/AESUtils.c||secure_enclave/AESUtils.c"
          ]
        }
      },
      "candidate_diff": {
        "secure_enclave/AESUtils.c||secure_enclave/AESUtils.c": [
          "File: secure_enclave/AESUtils.c -> secure_enclave/AESUtils.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "108:         return -4;",
          "109:     }",
          "120:         LOG_ERROR(\"Output buffer not large enough\");",
          "138: }",
          "",
          "[Removed Lines]",
          "112:   if (length < SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE) {",
          "113:       LOG_ERROR(\"length < SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE\");",
          "114:       return -1;",
          "115:   }",
          "117:   uint64_t len = length - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE;",
          "119:   if (msgLen < len) {",
          "121:         return -2;",
          "122:   }",
          "124:   sgx_status_t status = sgx_rijndael128GCM_decrypt(&(AES_key[512]),",
          "125:                                                    encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE, len,",
          "126:                                                    (unsigned char*) message,",
          "127:                                                    encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,",
          "128:                                                    NULL, 0,",
          "129:                                                    (sgx_aes_gcm_128bit_tag_t *)encr_message);",
          "133:   for (int i = 2; i < strlen(message) + 1; i++) {",
          "134:       message[i - 2 ] = message[i];",
          "135:   }",
          "137:   return status;",
          "",
          "[Added Lines]",
          "111:     if (length < SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE) {",
          "112:         LOG_ERROR(\"length < SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE\");",
          "113:         return -5;",
          "114:     }",
          "116:     uint64_t len = length - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE;",
          "118:     if (msgLen < len) {",
          "120:         return -6;",
          "121:     }",
          "123:     sgx_status_t status = sgx_rijndael128GCM_decrypt(&(AES_key[512]),",
          "124:                                                     encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE, len,",
          "125:                                                     (unsigned char*) message,",
          "126:                                                     encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,",
          "127:                                                     NULL, 0,",
          "128:                                                     (sgx_aes_gcm_128bit_tag_t *)encr_message);",
          "132:     for (int i = 2; i < strlen(message) + 1; i++) {",
          "133:         message[i - 2 ] = message[i];",
          "134:     }",
          "136:     return status;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-1245",
  "cve_desc": "It was discovered that the zebra daemon in Quagga before 1.0.20161017 suffered from a stack-based buffer overflow when processing IPv6 Neighbor Discovery messages. The root cause was relying on BUFSIZ to be compatible with a message size; however, BUFSIZ is system-dependent.",
  "repo": "Quagga/quagga",
  "patch_hash": "cfb1fae25f8c092e0d17073eaf7bd428ce1cd546",
  "patch_info": {
    "commit_hash": "cfb1fae25f8c092e0d17073eaf7bd428ce1cd546",
    "repo": "Quagga/quagga",
    "commit_url": "https://github.com/Quagga/quagga/commit/cfb1fae25f8c092e0d17073eaf7bd428ce1cd546",
    "files": [
      "zebra/rtadv.c"
    ],
    "message": "zebra: stack overrun in IPv6 RA receive code (CVE-2016-1245)\n\nThe IPv6 RA code also receives ICMPv6 RS and RA messages.\nUnfortunately, by bad coding practice, the buffer size specified on\nreceiving such messages mixed up 2 constants that in fact have\ndifferent values.\n\nThe code itself has:\n #define RTADV_MSG_SIZE 4096\nWhile BUFSIZ is system-dependent, in my case (x86_64 glibc):\n /usr/include/_G_config.h:#define _G_BUFSIZ 8192\n /usr/include/libio.h:#define _IO_BUFSIZ _G_BUFSIZ\n /usr/include/stdio.h:# define BUFSIZ _IO_BUFSIZ\n\nFreeBSD, OpenBSD, NetBSD and Illumos are not affected, since all of them\nhave BUFSIZ == 1024.\n\nAs the latter is passed to the kernel on recvmsg(), it's possible to\noverwrite 4kB of stack -- with ICMPv6 packets that can be globally sent\nto any of the system's addresses (using fragmentation to get to 8k).\n\n(The socket has filters installed limiting this to RS and RA packets,\nbut does not have a filter for source address or TTL.)\n\nIssue discovered by trying to test other stuff, which randomly caused\nthe stack to be smaller than 8kB in that code location, which then\ncauses the kernel to report EFAULT (Bad address).\n\nSigned-off-by: David Lamparter <equinox@opensourcerouting.org>\nReviewed-by: Donald Sharp <sharpd@cumulusnetworks.com>",
    "before_after_code_files": [
      "zebra/rtadv.c||zebra/rtadv.c"
    ]
  },
  "patch_diff": {
    "zebra/rtadv.c||zebra/rtadv.c": [
      "File: zebra/rtadv.c -> zebra/rtadv.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "483:   rtadv_event (zvrf, RTADV_READ, sock);",
      "487:   if (len < 0)",
      "488:     {",
      "",
      "[Removed Lines]",
      "485:   len = rtadv_recv_packet (sock, buf, BUFSIZ, &from, &ifindex, &hoplimit);",
      "",
      "[Added Lines]",
      "485:   len = rtadv_recv_packet (sock, buf, sizeof (buf), &from, &ifindex, &hoplimit);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "23ed2c2fb49b8a15ad125b16278e535719d64e7d",
      "candidate_info": {
        "commit_hash": "23ed2c2fb49b8a15ad125b16278e535719d64e7d",
        "repo": "Quagga/quagga",
        "commit_url": "https://github.com/Quagga/quagga/commit/23ed2c2fb49b8a15ad125b16278e535719d64e7d",
        "files": [
          "zebra/rtadv.c"
        ],
        "message": "zebra: stack overrun in IPv6 RA receive code (CVE-2016-1245)\n\nThe IPv6 RA code also receives ICMPv6 RS and RA messages.\nUnfortunately, by bad coding practice, the buffer size specified on\nreceiving such messages mixed up 2 constants that in fact have\ndifferent values.\n\nThe code itself has:\n #define RTADV_MSG_SIZE 4096\nWhile BUFSIZ is system-dependent, in my case (x86_64 glibc):\n /usr/include/_G_config.h:#define _G_BUFSIZ 8192\n /usr/include/libio.h:#define _IO_BUFSIZ _G_BUFSIZ\n /usr/include/stdio.h:# define BUFSIZ _IO_BUFSIZ\n\nFreeBSD, OpenBSD, NetBSD and Illumos are not affected, since all of them\nhave BUFSIZ == 1024.\n\nAs the latter is passed to the kernel on recvmsg(), it's possible to\noverwrite 4kB of stack -- with ICMPv6 packets that can be globally sent\nto any of the system's addresses (using fragmentation to get to 8k).\n\n(The socket has filters installed limiting this to RS and RA packets,\nbut does not have a filter for source address or TTL.)\n\nIssue discovered by trying to test other stuff, which randomly caused\nthe stack to be smaller than 8kB in that code location, which then\ncauses the kernel to report EFAULT (Bad address).\n\nSigned-off-by: David Lamparter <equinox@opensourcerouting.org>\nReviewed-by: Donald Sharp <sharpd@cumulusnetworks.com>",
        "before_after_code_files": [
          "zebra/rtadv.c||zebra/rtadv.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "zebra/rtadv.c||zebra/rtadv.c"
          ],
          "candidate": [
            "zebra/rtadv.c||zebra/rtadv.c"
          ]
        }
      },
      "candidate_diff": {
        "zebra/rtadv.c||zebra/rtadv.c": [
          "File: zebra/rtadv.c -> zebra/rtadv.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "483:   rtadv_event (zvrf, RTADV_READ, sock);",
          "487:   if (len < 0)",
          "488:     {",
          "",
          "[Removed Lines]",
          "485:   len = rtadv_recv_packet (sock, buf, BUFSIZ, &from, &ifindex, &hoplimit);",
          "",
          "[Added Lines]",
          "485:   len = rtadv_recv_packet (sock, buf, sizeof (buf), &from, &ifindex, &hoplimit);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-29464",
  "cve_desc": "Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. A heap buffer overflow was found in Exiv2 versions v0.27.3 and earlier. The heap overflow is triggered when Exiv2 is used to write metadata into a crafted image file. An attacker could potentially exploit the vulnerability to gain code execution, if they can trick the victim into running Exiv2 on a crafted image file. Note that this bug is only triggered when writing the metadata, which is a less frequently used Exiv2 operation than reading the metadata. For example, to trigger the bug in the Exiv2 command-line application, you need to add an extra command-line argument such as `insert`. The bug is fixed in version v0.27.4.",
  "repo": "Exiv2/exiv2",
  "patch_hash": "f9308839198aca5e68a65194f151a1de92398f54",
  "patch_info": {
    "commit_hash": "f9308839198aca5e68a65194f151a1de92398f54",
    "repo": "Exiv2/exiv2",
    "commit_url": "https://github.com/Exiv2/exiv2/commit/f9308839198aca5e68a65194f151a1de92398f54",
    "files": [
      "src/jp2image.cpp"
    ],
    "message": "Better bounds checking in Jp2Image::encodeJp2Header()",
    "before_after_code_files": [
      "src/jp2image.cpp||src/jp2image.cpp"
    ]
  },
  "patch_diff": {
    "src/jp2image.cpp||src/jp2image.cpp": [
      "File: src/jp2image.cpp -> src/jp2image.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "646:     void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf)",
      "647:     {",
      "648:         DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100); // allocate sufficient space",
      "651:         Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_;",
      "654:         char*         p      = (char*) boxBuf.pData_;",
      "655:         bool          bWroteColor = false ;",
      "",
      "[Removed Lines]",
      "649:         int     outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?",
      "650:         int      inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?",
      "652:         int32_t       length = getLong((byte*)&pBox->length, bigEndian);",
      "653:         int32_t       count  = sizeof (Jp2BoxHeader);",
      "",
      "[Added Lines]",
      "649:         long    outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?",
      "650:         long    inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?",
      "652:         uint32_t      length = getLong((byte*)&pBox->length, bigEndian);",
      "653:         uint32_t      count  = sizeof (Jp2BoxHeader);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "667: #ifdef EXIV2_DEBUG_MESSAGES",
      "668:                 std::cout << \"Jp2Image::encodeJp2Header subbox: \"<< toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;",
      "669: #endif",
      "670:                 count        += subBox.length;",
      "671:                 newBox.type   = subBox.type;",
      "672:             } else {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "670:                 enforce(subBox.length <= length - count, Exiv2::kerCorruptedMetadata);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "675:                 count = length;",
      "676:             }",
      "679:             if ( newBox.type == kJp2BoxTypeColorHeader ) {",
      "680:                 bWroteColor = true ;",
      "681:                 if ( ! iccProfileDefined() ) {",
      "682:                     const char* pad   = \"\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid\";",
      "683:                     uint32_t    psize = 15;",
      "684:                     newlen            = sizeof(newBox) + psize ;",
      "685:                     ul2Data((byte*)&newBox.length,psize      ,bigEndian);",
      "686:                     ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian);",
      "687:                     ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox));",
      "",
      "[Removed Lines]",
      "678:             int32_t newlen = subBox.length;",
      "",
      "[Added Lines]",
      "679:             uint32_t newlen = subBox.length;",
      "686:                     enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "690:                     const char* pad   = \"\\x02\\x00\\x00\";",
      "691:                     uint32_t    psize = 3;",
      "692:                     newlen            = sizeof(newBox) + psize + iccProfile_.size_;",
      "693:                     ul2Data((byte*)&newBox.length,newlen,bigEndian);",
      "694:                     ul2Data((byte*)&newBox.type,newBox.type,bigEndian);",
      "695:                     ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  );",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "695:                     enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "697:                     ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_);",
      "698:                 }",
      "699:             } else {",
      "700:                 ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length);",
      "701:             }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "703:                 enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0357f341e43f6e14123f227946574231ba379637",
      "candidate_info": {
        "commit_hash": "0357f341e43f6e14123f227946574231ba379637",
        "repo": "Exiv2/exiv2",
        "commit_url": "https://github.com/Exiv2/exiv2/commit/0357f341e43f6e14123f227946574231ba379637",
        "files": [
          "src/jp2image.cpp"
        ],
        "message": "Better bounds checking in Jp2Image::encodeJp2Header()",
        "before_after_code_files": [
          "src/jp2image.cpp||src/jp2image.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/jp2image.cpp||src/jp2image.cpp"
          ],
          "candidate": [
            "src/jp2image.cpp||src/jp2image.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/jp2image.cpp||src/jp2image.cpp": [
          "File: src/jp2image.cpp -> src/jp2image.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "646:     void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf)",
          "647:     {",
          "648:         DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100); // allocate sufficient space",
          "651:         Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_;",
          "654:         char*         p      = (char*) boxBuf.pData_;",
          "655:         bool          bWroteColor = false ;",
          "",
          "[Removed Lines]",
          "649:         int     outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?",
          "650:         int      inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?",
          "652:         int32_t       length = getLong((byte*)&pBox->length, bigEndian);",
          "653:         int32_t       count  = sizeof (Jp2BoxHeader);",
          "",
          "[Added Lines]",
          "649:         long    outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?",
          "650:         long    inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?",
          "652:         uint32_t      length = getLong((byte*)&pBox->length, bigEndian);",
          "653:         uint32_t      count  = sizeof (Jp2BoxHeader);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "667: #ifdef EXIV2_DEBUG_MESSAGES",
          "668:                 std::cout << \"Jp2Image::encodeJp2Header subbox: \"<< toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;",
          "669: #endif",
          "670:                 count        += subBox.length;",
          "671:                 newBox.type   = subBox.type;",
          "672:             } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "670:                 enforce(subBox.length <= length - count, Exiv2::kerCorruptedMetadata);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "675:                 count = length;",
          "676:             }",
          "679:             if ( newBox.type == kJp2BoxTypeColorHeader ) {",
          "680:                 bWroteColor = true ;",
          "681:                 if ( ! iccProfileDefined() ) {",
          "682:                     const char* pad   = \"\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid\";",
          "683:                     uint32_t    psize = 15;",
          "684:                     newlen            = sizeof(newBox) + psize ;",
          "685:                     ul2Data((byte*)&newBox.length,psize      ,bigEndian);",
          "686:                     ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian);",
          "687:                     ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox));",
          "",
          "[Removed Lines]",
          "678:             int32_t newlen = subBox.length;",
          "",
          "[Added Lines]",
          "679:             uint32_t newlen = subBox.length;",
          "686:                     enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "690:                     const char* pad   = \"\\x02\\x00\\x00\";",
          "691:                     uint32_t    psize = 3;",
          "692:                     newlen            = sizeof(newBox) + psize + iccProfile_.size_;",
          "693:                     ul2Data((byte*)&newBox.length,newlen,bigEndian);",
          "694:                     ul2Data((byte*)&newBox.type,newBox.type,bigEndian);",
          "695:                     ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "695:                     enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "697:                     ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_);",
          "698:                 }",
          "699:             } else {",
          "700:                 ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length);",
          "701:             }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "703:                 enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
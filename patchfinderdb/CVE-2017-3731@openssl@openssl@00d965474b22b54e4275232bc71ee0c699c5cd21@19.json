{
  "cve_id": "CVE-2017-3731",
  "cve_desc": "If an SSL/TLS server or client is running on a 32-bit host, and a specific cipher is being used, then a truncated packet can cause that server or client to perform an out-of-bounds read, usually resulting in a crash. For OpenSSL 1.1.0, the crash can be triggered when using CHACHA20/POLY1305; users should upgrade to 1.1.0d. For Openssl 1.0.2, the crash can be triggered when using RC4-MD5; users who have not disabled that algorithm should update to 1.0.2k.",
  "repo": "openssl/openssl",
  "patch_hash": "00d965474b22b54e4275232bc71ee0c699c5cd21",
  "patch_info": {
    "commit_hash": "00d965474b22b54e4275232bc71ee0c699c5cd21",
    "repo": "openssl/openssl",
    "commit_url": "https://github.com/openssl/openssl/commit/00d965474b22b54e4275232bc71ee0c699c5cd21",
    "files": [
      "crypto/evp/e_aes.c",
      "crypto/evp/e_chacha20_poly1305.c"
    ],
    "message": "crypto/evp: harden AEAD ciphers.\n\nOriginally a crash in 32-bit build was reported CHACHA20-POLY1305\ncipher. The crash is triggered by truncated packet and is result\nof excessive hashing to the edge of accessible memory. Since hash\noperation is read-only it is not considered to be exploitable\nbeyond a DoS condition. Other ciphers were hardened.\n\nThanks to Robert \u015awi\u0119cki for report.\n\nCVE-2017-3731\n\nReviewed-by: Rich Salz <rsalz@openssl.org>",
    "before_after_code_files": [
      "crypto/evp/e_aes.c||crypto/evp/e_aes.c",
      "crypto/evp/e_chacha20_poly1305.c||crypto/evp/e_chacha20_poly1305.c"
    ]
  },
  "patch_diff": {
    "crypto/evp/e_aes.c||crypto/evp/e_aes.c": [
      "File: crypto/evp/e_aes.c -> crypto/evp/e_aes.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1388:                 EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] << 8",
      "1389:                 | EVP_CIPHER_CTX_buf_noconst(c)[arg - 1];",
      "1391:             len -= EVP_GCM_TLS_EXPLICIT_IV_LEN;",
      "1394:                 len -= EVP_GCM_TLS_TAG_LEN;",
      "1395:             EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] = len >> 8;",
      "1396:             EVP_CIPHER_CTX_buf_noconst(c)[arg - 1] = len & 0xff;",
      "1397:         }",
      "",
      "[Removed Lines]",
      "1393:             if (!EVP_CIPHER_CTX_encrypting(c))",
      "",
      "[Added Lines]",
      "1391:             if (len < EVP_GCM_TLS_EXPLICIT_IV_LEN)",
      "1392:                 return 0;",
      "1395:             if (!EVP_CIPHER_CTX_encrypting(c)) {",
      "1396:                 if (len < EVP_GCM_TLS_TAG_LEN)",
      "1397:                     return 0;",
      "1399:             }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1946:                 EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] << 8",
      "1947:                 | EVP_CIPHER_CTX_buf_noconst(c)[arg - 1];",
      "1949:             len -= EVP_CCM_TLS_EXPLICIT_IV_LEN;",
      "1952:                 len -= cctx->M;",
      "1953:             EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] = len >> 8;",
      "1954:             EVP_CIPHER_CTX_buf_noconst(c)[arg - 1] = len & 0xff;",
      "1955:         }",
      "",
      "[Removed Lines]",
      "1951:             if (!EVP_CIPHER_CTX_encrypting(c))",
      "",
      "[Added Lines]",
      "1954:             if (len < EVP_CCM_TLS_EXPLICIT_IV_LEN)",
      "1955:                 return 0;",
      "1958:             if (!EVP_CIPHER_CTX_encrypting(c)) {",
      "1959:                 if (len < cctx->M)",
      "1960:                     return 0;",
      "1962:             }",
      "",
      "---------------"
    ],
    "crypto/evp/e_chacha20_poly1305.c||crypto/evp/e_chacha20_poly1305.c": [
      "File: crypto/evp/e_chacha20_poly1305.c -> crypto/evp/e_chacha20_poly1305.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "398:             len = aad[EVP_AEAD_TLS1_AAD_LEN - 2] << 8 |",
      "399:                   aad[EVP_AEAD_TLS1_AAD_LEN - 1];",
      "400:             if (!ctx->encrypt) {",
      "402:                 memcpy(temp, aad, EVP_AEAD_TLS1_AAD_LEN - 2);",
      "403:                 aad = temp;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "401:                 if (len < POLY1305_BLOCK_SIZE)",
      "402:                     return 0;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c088325b42cee1236f7b4996dd71f93ecc95bd5d",
      "candidate_info": {
        "commit_hash": "c088325b42cee1236f7b4996dd71f93ecc95bd5d",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/c088325b42cee1236f7b4996dd71f93ecc95bd5d",
        "files": [
          "ssl/statem/statem_srvr.c"
        ],
        "message": "Fix SSL_get0_raw_cipherlist()\n\nSSL_get0_raw_cipherlist() was a little too \"raw\" in the case of an SSLv2\ncompat ClientHello. In 1.0.2 and below, during version negotiation, if\nwe received an SSLv2 compat ClientHello but actually wanted to do SSLv3+\nthen we would construct a \"fake\" SSLv3+ ClientHello. This \"fake\" ClientHello\nwould have its ciphersuite list converted to the SSLv3+ format. It was\nthis \"fake\" raw list that got saved away to later be returned by a call to\nSSL_get0_raw_cipherlist().\n\nIn 1.1.0+ version negotiation works differently and we process an SSLv2\ncompat ClientHello directly without the need for an intermediary \"fake\"\nClientHello. This meant that the raw ciphersuite list being saved was in\nthe SSLv2 format. Any caller of this function would not expect that and\npotentially overread the returned buffer by one byte.\n\nFixes #2189\n\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/2280)\n(cherry picked from commit 07afdf3c3ac97af4f2b4eec22a97f7230f8227e0)",
        "before_after_code_files": [
          "ssl/statem/statem_srvr.c||ssl/statem/statem_srvr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ssl/statem/statem_srvr.c||ssl/statem/statem_srvr.c": [
          "File: ssl/statem/statem_srvr.c -> ssl/statem/statem_srvr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3256:         return NULL;",
          "3257:     }",
          "3269:     }",
          "3274:         goto err;",
          "3275:     }",
          "",
          "[Removed Lines]",
          "3259:     if ((skp == NULL) || (*skp == NULL)) {",
          "3261:         if (sk == NULL) {",
          "3262:             SSLerr(SSL_F_SSL_BYTES_TO_CIPHER_LIST, ERR_R_MALLOC_FAILURE);",
          "3264:             return NULL;",
          "3265:         }",
          "3266:     } else {",
          "3267:         sk = *skp;",
          "3268:         sk_SSL_CIPHER_zero(sk);",
          "3271:     if (!PACKET_memdup(cipher_suites, &s->s3->tmp.ciphers_raw,",
          "3272:                        &s->s3->tmp.ciphers_rawlen)) {",
          "",
          "[Added Lines]",
          "3259:     sk = sk_SSL_CIPHER_new_null();",
          "3260:     if (sk == NULL) {",
          "3261:         SSLerr(SSL_F_SSL_BYTES_TO_CIPHER_LIST, ERR_R_MALLOC_FAILURE);",
          "3263:         return NULL;",
          "3266:     if (sslv2format) {",
          "3267:         size_t numciphers = PACKET_remaining(cipher_suites) / n;",
          "3268:         PACKET sslv2ciphers = *cipher_suites;",
          "3269:         unsigned int leadbyte;",
          "3270:         unsigned char *raw;",
          "3279:         raw = s->s3->tmp.ciphers_raw = OPENSSL_malloc(numciphers * n);",
          "3280:         if (raw == NULL) {",
          "3282:             goto err;",
          "3283:         }",
          "3284:         for (s->s3->tmp.ciphers_rawlen = 0;",
          "3285:              PACKET_remaining(&sslv2ciphers) > 0;",
          "3286:              raw += TLS_CIPHER_LEN) {",
          "3287:             if (!PACKET_get_1(&sslv2ciphers, &leadbyte)",
          "3288:                     || (leadbyte == 0",
          "3289:                         && !PACKET_copy_bytes(&sslv2ciphers, raw,",
          "3290:                                               TLS_CIPHER_LEN))",
          "3291:                     || (leadbyte != 0",
          "3292:                         && !PACKET_forward(&sslv2ciphers, TLS_CIPHER_LEN))) {",
          "3294:                 OPENSSL_free(raw);",
          "3295:                 s->s3->tmp.ciphers_raw = NULL;",
          "3296:                 s->s3->tmp.ciphers_rawlen = 0;",
          "3297:                 goto err;",
          "3298:             }",
          "3299:             if (leadbyte == 0)",
          "3300:                 s->s3->tmp.ciphers_rawlen += TLS_CIPHER_LEN;",
          "3301:         }",
          "3302:     } else if (!PACKET_memdup(cipher_suites, &s->s3->tmp.ciphers_raw,",
          "3303:                            &s->s3->tmp.ciphers_rawlen)) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3330:         goto err;",
          "3331:     }",
          "3336:  err:",
          "3339:     return NULL;",
          "3340: }",
          "",
          "[Removed Lines]",
          "3333:     if (skp != NULL)",
          "3335:     return (sk);",
          "3337:     if ((skp == NULL) || (*skp == NULL))",
          "3338:         sk_SSL_CIPHER_free(sk);",
          "",
          "[Added Lines]",
          "3365:     return sk;",
          "3367:     sk_SSL_CIPHER_free(sk);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f4cdd19a6a8a0845c08c8101538347f2d5a0d96c",
      "candidate_info": {
        "commit_hash": "f4cdd19a6a8a0845c08c8101538347f2d5a0d96c",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/f4cdd19a6a8a0845c08c8101538347f2d5a0d96c",
        "files": [
          "test/recipes/80-test_ssl_new.t"
        ],
        "message": "VMS fix of test/recipes/80-test_ssl_new.t\n\nOn VMS, file names with more than one period get all but the last get\nescaped with a ^, so 21-key-update.conf.in becomes 21-key-update^.conf.in\nThat means that %conf_dependent_tests and %skip become useless unless\nwe massage the file names that are used as indexes.\n\nReviewed-by: Andy Polyakov <appro@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/2678)\n(cherry picked from commit d89f66412ba5168e7d6fd9dd88619d927d716f55)",
        "before_after_code_files": [
          "test/recipes/80-test_ssl_new.t||test/recipes/80-test_ssl_new.t"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "test/recipes/80-test_ssl_new.t||test/recipes/80-test_ssl_new.t": [
          "File: test/recipes/80-test_ssl_new.t -> test/recipes/80-test_ssl_new.t",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: my @conf_srcs =  glob(srctop_file(\"test\", \"ssl-tests\", \"*.conf.in\"));",
          "26: map { s/;.*// } @conf_srcs if $^O eq \"VMS\";",
          "30: # We hard-code the number of tests to double-check that the globbing above",
          "31: # finds all files as expected.",
          "",
          "[Removed Lines]",
          "27: my @conf_files = map { basename($_) } @conf_srcs;",
          "28: map { s/\\.in// } @conf_files;",
          "",
          "[Added Lines]",
          "27: my @conf_files = map { basename($_, \".in\") } @conf_srcs;",
          "28: map { s/\\^// } @conf_files if $^O eq \"VMS\";",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "feb879b098f90745a0394005f38b481c68b74ad4",
      "candidate_info": {
        "commit_hash": "feb879b098f90745a0394005f38b481c68b74ad4",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/feb879b098f90745a0394005f38b481c68b74ad4",
        "files": [
          "crypto/ui/ui_openssl.c"
        ],
        "message": "VMS UI_OpenSSL: if the TT device isn't a tty, flag instead of error\n\nOn all platforms, if the controlling tty isn't an actual tty, this is\nflagged by setting is_a_tty to zero...  except on VMS, where this was\ntreated as an error.  Change this to behave like the other platforms.\n\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/2063)\n(cherry picked from commit 18edbe6519bd5b738bf410b23f437df3005526e3)",
        "before_after_code_files": [
          "crypto/ui/ui_openssl.c||crypto/ui/ui_openssl.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "crypto/ui/ui_openssl.c||crypto/ui/ui_openssl.c": [
          "File: crypto/ui/ui_openssl.c -> crypto/ui/ui_openssl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "445: #endif",
          "446: #ifdef OPENSSL_SYS_VMS",
          "447:     status = sys$assign(&terminal, &channel, 0, 0);",
          "448:     if (status != SS$_NORMAL)",
          "449:         return 0;",
          "453:     if ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))",
          "455: #endif",
          "456:     return 1;",
          "457: }",
          "",
          "[Removed Lines]",
          "450:     status =",
          "451:         sys$qiow(0, channel, IO$_SENSEMODE, &iosb, 0, 0, tty_orig, 12, 0, 0,",
          "452:                  0, 0);",
          "454:         return 0;",
          "",
          "[Added Lines]",
          "453:     status = sys$qiow(0, channel, IO$_SENSEMODE, &iosb, 0, 0, tty_orig, 12,",
          "454:                       0, 0, 0, 0);",
          "458:         is_a_tty = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "468:         return 0;",
          "469: #endif",
          "470: #ifdef OPENSSL_SYS_VMS",
          "479: #endif",
          "480: #if defined(_WIN32) && !defined(_WIN32_WCE)",
          "481:     if (is_a_tty) {",
          "",
          "[Removed Lines]",
          "471:     tty_new[0] = tty_orig[0];",
          "472:     tty_new[1] = tty_orig[1] | TT$M_NOECHO;",
          "473:     tty_new[2] = tty_orig[2];",
          "474:     status =",
          "475:         sys$qiow(0, channel, IO$_SETMODE, &iosb, 0, 0, tty_new, 12, 0, 0, 0,",
          "476:                  0);",
          "477:     if ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))",
          "478:         return 0;",
          "",
          "[Added Lines]",
          "475:     if (is_a_tty) {",
          "476:         tty_new[0] = tty_orig[0];",
          "477:         tty_new[1] = tty_orig[1] | TT$M_NOECHO;",
          "478:         tty_new[2] = tty_orig[2];",
          "479:         status = sys$qiow(0, channel, IO$_SETMODE, &iosb, 0, 0, tty_new, 12,",
          "480:                           0, 0, 0, 0);",
          "481:         if ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))",
          "482:             return 0;",
          "483:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "499:         return 0;",
          "500: #endif",
          "501: #ifdef OPENSSL_SYS_VMS",
          "510: #endif",
          "511: #if defined(_WIN32) && !defined(_WIN32_WCE)",
          "512:     if (is_a_tty) {",
          "",
          "[Removed Lines]",
          "502:     tty_new[0] = tty_orig[0];",
          "503:     tty_new[1] = tty_orig[1] & ~TT$M_NOECHO;",
          "504:     tty_new[2] = tty_orig[2];",
          "505:     status =",
          "506:         sys$qiow(0, channel, IO$_SETMODE, &iosb, 0, 0, tty_new, 12, 0, 0, 0,",
          "507:                  0);",
          "508:     if ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))",
          "509:         return 0;",
          "",
          "[Added Lines]",
          "507:     if (is_a_tty) {",
          "508:         tty_new[0] = tty_orig[0];",
          "509:         tty_new[1] = tty_orig[1] & ~TT$M_NOECHO;",
          "510:         tty_new[2] = tty_orig[2];",
          "511:         status = sys$qiow(0, channel, IO$_SETMODE, &iosb, 0, 0, tty_new, 12,",
          "512:                           0, 0, 0, 0);",
          "513:         if ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))",
          "514:             return 0;",
          "515:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "526:         fclose(tty_out);",
          "527: #ifdef OPENSSL_SYS_VMS",
          "528:     status = sys$dassgn(channel);",
          "529: #endif",
          "530:     CRYPTO_THREAD_unlock(ui->lock);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "535:     if (status != SS$_NORMAL)",
          "536:         return 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bf1c92faf6d3adba62165432164f5732da3d99c9",
      "candidate_info": {
        "commit_hash": "bf1c92faf6d3adba62165432164f5732da3d99c9",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/bf1c92faf6d3adba62165432164f5732da3d99c9",
        "files": [
          "apps/pkcs8.c"
        ],
        "message": "Increase the password buffer size to APP_PASS_LEN.\n\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/2868)\n(cherry picked from commit bf580d5f30368f7ebc4c44f10575b5f0b411d594)",
        "before_after_code_files": [
          "apps/pkcs8.c||apps/pkcs8.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "apps/pkcs8.c||apps/pkcs8.c": [
          "File: apps/pkcs8.c -> apps/pkcs8.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "66:     char *infile = NULL, *outfile = NULL;",
          "67:     char *passinarg = NULL, *passoutarg = NULL, *prog;",
          "68: #ifndef OPENSSL_NO_UI",
          "70: #endif",
          "71:     char *passin = NULL, *passout = NULL, *p8pass = NULL;",
          "72:     OPTION_CHOICE o;",
          "",
          "[Removed Lines]",
          "69:     char pass[50];",
          "",
          "[Added Lines]",
          "69:     char pass[APP_PASS_LEN];",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f5d82af6ef4e300784f3e59346030cd30bcce30e",
      "candidate_info": {
        "commit_hash": "f5d82af6ef4e300784f3e59346030cd30bcce30e",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/f5d82af6ef4e300784f3e59346030cd30bcce30e",
        "files": [
          "engines/e_capi.c"
        ],
        "message": "engines/e_capi.c: formatting and styling fixes.\n\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(cherry picked from commit e08b444ac097825b10d3b90dbdb0d7197567cc4d)",
        "before_after_code_files": [
          "engines/e_capi.c||engines/e_capi.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "engines/e_capi.c||engines/e_capi.c": [
          "File: engines/e_capi.c -> engines/e_capi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "69: # endif",
          "71: # ifndef ALG_SID_SHA_256",
          "73: # endif",
          "74: # ifndef ALG_SID_SHA_384",
          "76: # endif",
          "77: # ifndef ALG_SID_SHA_512",
          "79: # endif",
          "81: # ifndef CALG_SHA_256",
          "83: # endif",
          "84: # ifndef CALG_SHA_384",
          "86: # endif",
          "87: # ifndef CALG_SHA_512",
          "89: # endif",
          "91: # ifndef PROV_RSA_AES",
          "",
          "[Removed Lines]",
          "72: #  define ALG_SID_SHA_256                 12",
          "75: #  define ALG_SID_SHA_384                 13",
          "78: #  define ALG_SID_SHA_512                 14",
          "82: #  define CALG_SHA_256            (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA_256)",
          "85: #  define CALG_SHA_384            (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA_384)",
          "88: #  define CALG_SHA_512            (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA_512)",
          "",
          "[Added Lines]",
          "72: #  define ALG_SID_SHA_256   12",
          "75: #  define ALG_SID_SHA_384   13",
          "78: #  define ALG_SID_SHA_512   14",
          "82: #  define CALG_SHA_256      (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA_256)",
          "85: #  define CALG_SHA_384      (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA_384)",
          "88: #  define CALG_SHA_512      (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA_512)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "151: void engine_load_capi_int(void);",
          "",
          "[Removed Lines]",
          "153: typedef PCCERT_CONTEXT(WINAPI *CERTDLG) (HCERTSTORE, HWND, LPCWSTR,",
          "154:                                          LPCWSTR, DWORD, DWORD, void *);",
          "155: typedef HWND(WINAPI *GETCONSWIN) (void);",
          "",
          "[Added Lines]",
          "153: typedef PCCERT_CONTEXT(WINAPI *CERTDLG)(HCERTSTORE, HWND, LPCWSTR,",
          "154:                                         LPCWSTR, DWORD, DWORD, void *);",
          "155: typedef HWND(WINAPI *GETCONSWIN)(void);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "176:     DWORD store_flags;",
          "184:     int lookup_method;",
          "198:     DWORD dump_flags;",
          "199:     int (*client_cert_select) (ENGINE *e, SSL *ssl, STACK_OF(X509) *certs);",
          "200:     CERTDLG certselectdlg;",
          "",
          "[Removed Lines]",
          "179: # define CAPI_LU_SUBSTR          1",
          "181: # define CAPI_LU_FNAME           2",
          "183: # define CAPI_LU_CONTNAME        3",
          "187: # define CAPI_DMP_SUMMARY        0x1",
          "189: # define CAPI_DMP_FNAME          0x2",
          "191: # define CAPI_DMP_FULL           0x4",
          "193: # define CAPI_DMP_PEM            0x8",
          "195: # define CAPI_DMP_PSKEY          0x10",
          "197: # define CAPI_DMP_PKEYINFO       0x20",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "961:         capi_addlasterror();",
          "962:         OPENSSL_free(tmpbuf);",
          "963:         return -1;",
          "965:         memcpy(to, tmpbuf, (flen = (int)dlen));",
          "967:     OPENSSL_free(tmpbuf);",
          "969:     return flen;",
          "",
          "[Removed Lines]",
          "964:     } else",
          "",
          "[Added Lines]",
          "955:     } else {",
          "957:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1154:         OPENSSL_free(name);",
          "1155:         if (*pname == NULL)",
          "1156:             return 0;",
          "1159:     CAPI_trace(ctx, \"capi_get_provname, returned name=%s, type=%d\\n\", *pname,",
          "",
          "[Removed Lines]",
          "1157:     } else",
          "",
          "[Added Lines]",
          "1148:     } else {",
          "1150:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1192:     CAPI_trace(ctx, \"Listing containers CSP=%s, type = %d\\n\", ctx->cspname,",
          "1193:                ctx->csptype);",
          "1194:     if (ctx->cspname && sizeof(TCHAR) != sizeof(char)) {",
          "1197:             cspname = alloca(clen * sizeof(WCHAR));",
          "1198:             MultiByteToWideChar(CP_ACP, 0, ctx->cspname, -1, (WCHAR *)cspname,",
          "1199:                                 clen);",
          "",
          "[Removed Lines]",
          "1195:         if ((clen =",
          "1196:              MultiByteToWideChar(CP_ACP, 0, ctx->cspname, -1, NULL, 0))) {",
          "",
          "[Added Lines]",
          "1187:         if ((clen = MultiByteToWideChar(CP_ACP, 0, ctx->cspname, -1,",
          "1188:                                         NULL, 0))) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1203:             capi_addlasterror();",
          "1204:             return 0;",
          "1205:         }",
          "1207:         cspname = (TCHAR *)ctx->cspname;",
          "1210:         CAPIerr(CAPI_F_CAPI_LIST_CONTAINERS,",
          "1211:                 CAPI_R_CRYPTACQUIRECONTEXT_ERROR);",
          "1212:         capi_addlasterror();",
          "1213:         return 0;",
          "1214:     }",
          "1217:         CAPIerr(CAPI_F_CAPI_LIST_CONTAINERS, CAPI_R_ENUMCONTAINERS_ERROR);",
          "1218:         capi_addlasterror();",
          "1219:         CryptReleaseContext(hprov, 0);",
          "",
          "[Removed Lines]",
          "1206:     } else",
          "1208:     if (!CryptAcquireContext",
          "1209:         (&hprov, NULL, cspname, ctx->csptype, CRYPT_VERIFYCONTEXT)) {",
          "1215:     if (!CryptGetProvParam",
          "1216:         (hprov, PP_ENUMCONTAINERS, NULL, &buflen, CRYPT_FIRST)) {",
          "",
          "[Added Lines]",
          "1198:     } else {",
          "1200:     }",
          "1201:     if (!CryptAcquireContext(&hprov, NULL, cspname, ctx->csptype,",
          "1202:                              CRYPT_VERIFYCONTEXT)) {",
          "1208:     if (!CryptGetProvParam(hprov, PP_ENUMCONTAINERS, NULL, &buflen,",
          "1209:                            CRYPT_FIRST)) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1236:             flags = CRYPT_FIRST;",
          "1237:         else",
          "1238:             flags = 0;",
          "1241:             err = GetLastError();",
          "1242:             if (err == ERROR_NO_MORE_ITEMS)",
          "1243:                 goto done;",
          "",
          "[Removed Lines]",
          "1239:         if (!CryptGetProvParam",
          "1240:             (hprov, PP_ENUMCONTAINERS, (BYTE *) cname, &clen, flags)) {",
          "",
          "[Added Lines]",
          "1232:         if (!CryptGetProvParam(hprov, PP_ENUMCONTAINERS, (BYTE *)cname,",
          "1233:                                &clen, flags)) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1264:     return ret;",
          "1265: }",
          "1268: {",
          "1269:     DWORD len;",
          "1270:     CRYPT_KEY_PROV_INFO *pinfo;",
          "1274:         return NULL;",
          "1275:     pinfo = OPENSSL_malloc(len);",
          "1276:     if (pinfo == NULL) {",
          "1277:         CAPIerr(CAPI_F_CAPI_GET_PROV_INFO, ERR_R_MALLOC_FAILURE);",
          "1278:         return NULL;",
          "1279:     }",
          "1282:         CAPIerr(CAPI_F_CAPI_GET_PROV_INFO,",
          "1283:                 CAPI_R_ERROR_GETTING_KEY_PROVIDER_INFO);",
          "1284:         capi_addlasterror();",
          "",
          "[Removed Lines]",
          "1267: static CRYPT_KEY_PROV_INFO *capi_get_prov_info(CAPI_CTX * ctx, PCCERT_CONTEXT cert)",
          "1272:     if (!CertGetCertificateContextProperty",
          "1273:         (cert, CERT_KEY_PROV_INFO_PROP_ID, NULL, &len))",
          "1280:     if (!CertGetCertificateContextProperty",
          "1281:         (cert, CERT_KEY_PROV_INFO_PROP_ID, pinfo, &len)) {",
          "",
          "[Added Lines]",
          "1260: static CRYPT_KEY_PROV_INFO *capi_get_prov_info(CAPI_CTX * ctx,",
          "1261:                                                PCCERT_CONTEXT cert)",
          "1266:     if (!CertGetCertificateContextProperty(cert, CERT_KEY_PROV_INFO_PROP_ID,",
          "1267:                                            NULL, &len))",
          "1274:     if (!CertGetCertificateContextProperty(cert, CERT_KEY_PROV_INFO_PROP_ID,",
          "1275:                                            pinfo, &len)) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1317:     DWORD dlen;",
          "1319:     CAPI_trace(ctx, \"capi_cert_get_fname\\n\");",
          "1322:         return NULL;",
          "1323:     wfname = OPENSSL_malloc(dlen);",
          "1324:     if (wfname == NULL)",
          "1325:         return NULL;",
          "1328:         char *fname = wide_to_asc(wfname);",
          "1329:         OPENSSL_free(wfname);",
          "1330:         return fname;",
          "",
          "[Removed Lines]",
          "1320:     if (!CertGetCertificateContextProperty",
          "1321:         (cert, CERT_FRIENDLY_NAME_PROP_ID, NULL, &dlen))",
          "1326:     if (CertGetCertificateContextProperty",
          "1327:         (cert, CERT_FRIENDLY_NAME_PROP_ID, wfname, &dlen)) {",
          "",
          "[Added Lines]",
          "1314:     if (!CertGetCertificateContextProperty(cert, CERT_FRIENDLY_NAME_PROP_ID,",
          "1315:                                            NULL, &dlen))",
          "1320:     if (CertGetCertificateContextProperty(cert, CERT_FRIENDLY_NAME_PROP_ID,",
          "1321:                                           wfname, &dlen)) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1347:         if (fname) {",
          "1348:             BIO_printf(out, \"  Friendly Name \\\"%s\\\"\\n\", fname);",
          "1349:             OPENSSL_free(fname);",
          "1351:             BIO_printf(out, \"  <No Friendly Name>\\n\");",
          "1352:     }",
          "1354:     p = cert->pbCertEncoded;",
          "",
          "[Removed Lines]",
          "1350:         } else",
          "",
          "[Added Lines]",
          "1344:         } else {",
          "1346:         }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1442:     int match;",
          "1443:     switch (ctx->lookup_method) {",
          "1444:     case CAPI_LU_SUBSTR:",
          "1447:                                           CERT_FIND_SUBJECT_STR_A, id, NULL);",
          "1448:     case CAPI_LU_FNAME:",
          "1449:         for (;;) {",
          "",
          "[Removed Lines]",
          "1445:         return CertFindCertificateInStore(hstore,",
          "1446:                                           X509_ASN_ENCODING, 0,",
          "",
          "[Added Lines]",
          "1440:         return CertFindCertificateInStore(hstore, X509_ASN_ENCODING, 0,",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1569:             if ((len = MultiByteToWideChar(CP_ACP, 0, id, -1, NULL, 0)) &&",
          "1570:                 (contname = alloca(len * sizeof(WCHAR)),",
          "1571:                  MultiByteToWideChar(CP_ACP, 0, id, -1, contname, len)) &&",
          "1587:                                ctx->csptype, ctx->keytype);",
          "1588:         break;",
          "1589:     }",
          "",
          "[Removed Lines]",
          "1572:                 (len =",
          "1573:                  MultiByteToWideChar(CP_ACP, 0, ctx->cspname, -1, NULL, 0))",
          "1574:                 && (provname =",
          "1575:                     alloca(len * sizeof(WCHAR)), MultiByteToWideChar(CP_ACP,",
          "1576:                                                                      0,",
          "1577:                                                                      ctx->cspname,",
          "1578:                                                                      -1,",
          "1579:                                                                      provname,",
          "1580:                                                                      len)))",
          "1581:                 key =",
          "1582:                     capi_get_key(ctx, (TCHAR *)contname, (TCHAR *)provname,",
          "1583:                                  ctx->csptype, ctx->keytype);",
          "1584:         } else",
          "1585:             key = capi_get_key(ctx, (TCHAR *)id,",
          "1586:                                (TCHAR *)ctx->cspname,",
          "",
          "[Added Lines]",
          "1566:                 (len = MultiByteToWideChar(CP_ACP, 0, ctx->cspname, -1,",
          "1567:                                            NULL, 0)) &&",
          "1568:                 (provname = alloca(len * sizeof(WCHAR)),",
          "1569:                  MultiByteToWideChar(CP_ACP, 0, ctx->cspname, -1,",
          "1570:                                      provname, len)))",
          "1571:                 key = capi_get_key(ctx, (TCHAR *)contname, (TCHAR *)provname,",
          "1572:                                    ctx->csptype, ctx->keytype);",
          "1573:         } else {",
          "1574:             key = capi_get_key(ctx, (TCHAR *)id, (TCHAR *)ctx->cspname,",
          "1576:         }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1650:                 name = alloca(len * sizeof(WCHAR));",
          "1651:                 MultiByteToWideChar(CP_ACP, 0, pname, -1, (WCHAR *)name, len);",
          "1652:             }",
          "1654:             name = (TCHAR *)pname;",
          "1656:         if (!name || !CryptAcquireContext(&hprov, NULL, name, type,",
          "1657:                                           CRYPT_VERIFYCONTEXT)) {",
          "1658:             CAPIerr(CAPI_F_CAPI_CTX_SET_PROVNAME,",
          "",
          "[Removed Lines]",
          "1653:         } else",
          "",
          "[Added Lines]",
          "1642:         } else {",
          "1644:         }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1757:                 certs = sk_X509_new_null();",
          "1759:             sk_X509_push(certs, x);",
          "1761:             X509_free(x);",
          "1763:     }",
          "1765:     if (cert)",
          "",
          "[Removed Lines]",
          "1760:         } else",
          "",
          "[Added Lines]",
          "1749:         } else {",
          "1751:         }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
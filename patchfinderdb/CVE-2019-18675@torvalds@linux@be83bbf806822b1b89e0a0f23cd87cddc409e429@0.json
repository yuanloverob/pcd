{
  "cve_id": "CVE-2019-18675",
  "cve_desc": "The Linux kernel through 5.3.13 has a start_offset+size Integer Overflow in cpia2_remap_buffer in drivers/media/usb/cpia2/cpia2_core.c because cpia2 has its own mmap implementation. This allows local users (with /dev/video0 access) to obtain read and write permissions on kernel physical pages, which can possibly result in a privilege escalation.",
  "repo": "torvalds/linux",
  "patch_hash": "be83bbf806822b1b89e0a0f23cd87cddc409e429",
  "patch_info": {
    "commit_hash": "be83bbf806822b1b89e0a0f23cd87cddc409e429",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/be83bbf806822b1b89e0a0f23cd87cddc409e429",
    "files": [
      "mm/mmap.c"
    ],
    "message": "mmap: introduce sane default mmap limits\n\nThe internal VM \"mmap()\" interfaces are based on the mmap target doing\neverything using page indexes rather than byte offsets, because\ntraditionally (ie 32-bit) we had the situation that the byte offset\ndidn't fit in a register.  So while the mmap virtual address was limited\nby the word size of the architecture, the backing store was not.\n\nSo we're basically passing \"pgoff\" around as a page index, in order to\nbe able to describe backing store locations that are much bigger than\nthe word size (think files larger than 4GB etc).\n\nBut while this all makes a ton of sense conceptually, we've been dogged\nby various drivers that don't really understand this, and internally\nwork with byte offsets, and then try to work with the page index by\nturning it into a byte offset with \"pgoff << PAGE_SHIFT\".\n\nWhich obviously can overflow.\n\nAdding the size of the mapping to it to get the byte offset of the end\nof the backing store just exacerbates the problem, and if you then use\nthis overflow-prone value to check various limits of your device driver\nmmap capability, you're just setting yourself up for problems.\n\nThe correct thing for drivers to do is to do their limit math in page\nindices, the way the interface is designed.  Because the generic mmap\ncode _does_ test that the index doesn't overflow, since that's what the\nmmap code really cares about.\n\nHOWEVER.\n\nFinding and fixing various random drivers is a sisyphean task, so let's\njust see if we can just make the core mmap() code do the limiting for\nus.  Realistically, the only \"big\" backing stores we need to care about\nare regular files and block devices, both of which are known to do this\nproperly, and which have nice well-defined limits for how much data they\ncan access.\n\nSo let's special-case just those two known cases, and then limit other\nrandom mmap users to a backing store that still fits in \"unsigned long\".\nRealistically, that's not much of a limit at all on 64-bit, and on\n32-bit architectures the only worry might be the GPU drivers, which can\nhave big physical address spaces.\n\nTo make it possible for drivers like that to say that they are 64-bit\nclean, this patch does repurpose the \"FMODE_UNSIGNED_OFFSET\" bit in the\nfile flags to allow drivers to mark their file descriptors as safe in\nthe full 64-bit mmap address space.\n\n[ The timing for doing this is less than optimal, and this should really\n  go in a merge window. But realistically, this needs wide testing more\n  than it needs anything else, and being main-line is the only way to do\n  that.\n\n  So the earlier the better, even if it's outside the proper development\n  cycle        - Linus ]\n\nCc: Kees Cook <keescook@chromium.org>\nCc: Dan Carpenter <dan.carpenter@oracle.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Willy Tarreau <w@1wt.eu>\nCc: Dave Airlie <airlied@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "mm/mmap.c||mm/mmap.c"
    ]
  },
  "patch_diff": {
    "mm/mmap.c||mm/mmap.c": [
      "File: mm/mmap.c -> mm/mmap.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1324:  return 0;",
      "1325: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1327: static inline u64 file_mmap_size_max(struct file *file, struct inode *inode)",
      "1328: {",
      "1329:  if (S_ISREG(inode->i_mode))",
      "1330:   return inode->i_sb->s_maxbytes;",
      "1332:  if (S_ISBLK(inode->i_mode))",
      "1333:   return MAX_LFS_FILESIZE;",
      "1336:  if (file->f_mode & FMODE_UNSIGNED_OFFSET)",
      "1337:   return 0;",
      "1340:  return ULONG_MAX;",
      "1341: }",
      "1343: static inline bool file_mmap_ok(struct file *file, struct inode *inode,",
      "1344:     unsigned long pgoff, unsigned long len)",
      "1345: {",
      "1346:  u64 maxsize = file_mmap_size_max(file, inode);",
      "1348:  if (maxsize && len > maxsize)",
      "1349:   return false;",
      "1350:  maxsize -= len;",
      "1351:  if (pgoff > maxsize >> PAGE_SHIFT)",
      "1352:   return false;",
      "1353:  return true;",
      "1354: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1409:   struct inode *inode = file_inode(file);",
      "1410:   unsigned long flags_mask;",
      "1412:   flags_mask = LEGACY_MAP_MASK | file->f_op->mmap_supported_flags;",
      "1414:   switch (flags & MAP_TYPE) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1441:   if (!file_mmap_ok(file, inode, pgoff, len))",
      "1442:    return -EOVERFLOW;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "423913ad4ae5b3e8fb8983f70969fb522261ba26",
      "candidate_info": {
        "commit_hash": "423913ad4ae5b3e8fb8983f70969fb522261ba26",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/423913ad4ae5b3e8fb8983f70969fb522261ba26",
        "files": [
          "mm/mmap.c"
        ],
        "message": "mmap: relax file size limit for regular files\n\nCommit be83bbf80682 (\"mmap: introduce sane default mmap limits\") was\nintroduced to catch problems in various ad-hoc character device drivers\ndoing mmap and getting the size limits wrong.  In the process, it used\n\"known good\" limits for the normal cases of mapping regular files and\nblock device drivers.\n\nIt turns out that the \"s_maxbytes\" limit was less \"known good\" than I\nthought.  In particular, /proc doesn't set it, but exposes one regular\nfile to mmap: /proc/vmcore.  As a result, that file got limited to the\ndefault MAX_INT s_maxbytes value.\n\nThis went unnoticed for a while, because apparently the only thing that\nneeds it is the s390 kernel zfcpdump, but there might be other tools\nthat use this too.\n\nVasily suggested just changing s_maxbytes for all of /proc, which isn't\nwrong, but makes me nervous at this stage.  So instead, just make the\nnew mmap limit always be MAX_LFS_FILESIZE for regular files, which won't\naffect anything else.  It wasn't the regular file case I was worried\nabout.\n\nI'd really prefer for maxsize to have been per-inode, but that is not\nhow things are today.\n\nFixes: be83bbf80682 (\"mmap: introduce sane default mmap limits\")\nReported-by: Vasily Gorbik <gor@linux.ibm.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/mmap.c||mm/mmap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/mmap.c||mm/mmap.c"
          ],
          "candidate": [
            "mm/mmap.c||mm/mmap.c"
          ]
        }
      },
      "candidate_diff": {
        "mm/mmap.c||mm/mmap.c": [
          "File: mm/mmap.c -> mm/mmap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1327: static inline u64 file_mmap_size_max(struct file *file, struct inode *inode)",
          "1328: {",
          "1329:  if (S_ISREG(inode->i_mode))",
          "1332:  if (S_ISBLK(inode->i_mode))",
          "1333:   return MAX_LFS_FILESIZE;",
          "",
          "[Removed Lines]",
          "1330:   return inode->i_sb->s_maxbytes;",
          "",
          "[Added Lines]",
          "1330:   return MAX_LFS_FILESIZE;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
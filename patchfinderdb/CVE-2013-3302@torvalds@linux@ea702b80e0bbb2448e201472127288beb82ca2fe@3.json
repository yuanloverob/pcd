{
  "cve_id": "CVE-2013-3302",
  "cve_desc": "Race condition in the smb_send_rqst function in fs/cifs/transport.c in the Linux kernel before 3.7.2 allows local users to cause a denial of service (NULL pointer dereference and OOPS) or possibly have unspecified other impact via vectors involving a reconnection event.",
  "repo": "torvalds/linux",
  "patch_hash": "ea702b80e0bbb2448e201472127288beb82ca2fe",
  "patch_info": {
    "commit_hash": "ea702b80e0bbb2448e201472127288beb82ca2fe",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/ea702b80e0bbb2448e201472127288beb82ca2fe",
    "files": [
      "fs/cifs/transport.c"
    ],
    "message": "cifs: move check for NULL socket into smb_send_rqst\n\nCai reported this oops:\n\n[90701.616664] BUG: unable to handle kernel NULL pointer dereference at 0000000000000028\n[90701.625438] IP: [<ffffffff814a343e>] kernel_setsockopt+0x2e/0x60\n[90701.632167] PGD fea319067 PUD 103fda4067 PMD 0\n[90701.637255] Oops: 0000 [#1] SMP\n[90701.640878] Modules linked in: des_generic md4 nls_utf8 cifs dns_resolver binfmt_misc tun sg igb iTCO_wdt iTCO_vendor_support lpc_ich pcspkr i2c_i801 i2c_core i7core_edac edac_core ioatdma dca mfd_core coretemp kvm_intel kvm crc32c_intel microcode sr_mod cdrom ata_generic sd_mod pata_acpi crc_t10dif ata_piix libata megaraid_sas dm_mirror dm_region_hash dm_log dm_mod\n[90701.677655] CPU 10\n[90701.679808] Pid: 9627, comm: ls Tainted: G        W    3.7.1+ #10 QCI QSSC-S4R/QSSC-S4R\n[90701.688950] RIP: 0010:[<ffffffff814a343e>]  [<ffffffff814a343e>] kernel_setsockopt+0x2e/0x60\n[90701.698383] RSP: 0018:ffff88177b431bb8  EFLAGS: 00010206\n[90701.704309] RAX: ffff88177b431fd8 RBX: 00007ffffffff000 RCX: ffff88177b431bec\n[90701.712271] RDX: 0000000000000003 RSI: 0000000000000006 RDI: 0000000000000000\n[90701.720223] RBP: ffff88177b431bc8 R08: 0000000000000004 R09: 0000000000000000\n[90701.728185] R10: 0000000000000001 R11: 0000000000000000 R12: 0000000000000001\n[90701.736147] R13: ffff88184ef92000 R14: 0000000000000023 R15: ffff88177b431c88\n[90701.744109] FS:  00007fd56a1a47c0(0000) GS:ffff88105fc40000(0000) knlGS:0000000000000000\n[90701.753137] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\n[90701.759550] CR2: 0000000000000028 CR3: 000000104f15f000 CR4: 00000000000007e0\n[90701.767512] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[90701.775465] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\n[90701.783428] Process ls (pid: 9627, threadinfo ffff88177b430000, task ffff88185ca4cb60)\n[90701.792261] Stack:\n[90701.794505]  0000000000000023 ffff88177b431c50 ffff88177b431c38 ffffffffa014fcb1\n[90701.802809]  ffff88184ef921bc 0000000000000000 00000001ffffffff ffff88184ef921c0\n[90701.811123]  ffff88177b431c08 ffffffff815ca3d9 ffff88177b431c18 ffff880857758000\n[90701.819433] Call Trace:\n[90701.822183]  [<ffffffffa014fcb1>] smb_send_rqst+0x71/0x1f0 [cifs]\n[90701.828991]  [<ffffffff815ca3d9>] ? schedule+0x29/0x70\n[90701.834736]  [<ffffffffa014fe6d>] smb_sendv+0x3d/0x40 [cifs]\n[90701.841062]  [<ffffffffa014fe96>] smb_send+0x26/0x30 [cifs]\n[90701.847291]  [<ffffffffa015801f>] send_nt_cancel+0x6f/0xd0 [cifs]\n[90701.854102]  [<ffffffffa015075e>] SendReceive+0x18e/0x360 [cifs]\n[90701.860814]  [<ffffffffa0134a78>] CIFSFindFirst+0x1a8/0x3f0 [cifs]\n[90701.867724]  [<ffffffffa013f731>] ? build_path_from_dentry+0xf1/0x260 [cifs]\n[90701.875601]  [<ffffffffa013f731>] ? build_path_from_dentry+0xf1/0x260 [cifs]\n[90701.883477]  [<ffffffffa01578e6>] cifs_query_dir_first+0x26/0x30 [cifs]\n[90701.890869]  [<ffffffffa015480d>] initiate_cifs_search+0xed/0x250 [cifs]\n[90701.898354]  [<ffffffff81195970>] ? fillonedir+0x100/0x100\n[90701.904486]  [<ffffffffa01554cb>] cifs_readdir+0x45b/0x8f0 [cifs]\n[90701.911288]  [<ffffffff81195970>] ? fillonedir+0x100/0x100\n[90701.917410]  [<ffffffff81195970>] ? fillonedir+0x100/0x100\n[90701.923533]  [<ffffffff81195970>] ? fillonedir+0x100/0x100\n[90701.929657]  [<ffffffff81195848>] vfs_readdir+0xb8/0xe0\n[90701.935490]  [<ffffffff81195b9f>] sys_getdents+0x8f/0x110\n[90701.941521]  [<ffffffff815d3b99>] system_call_fastpath+0x16/0x1b\n[90701.948222] Code: 66 90 55 65 48 8b 04 25 f0 c6 00 00 48 89 e5 53 48 83 ec 08 83 fe 01 48 8b 98 48 e0 ff ff 48 c7 80 48 e0 ff ff ff ff ff ff 74 22 <48> 8b 47 28 ff 50 68 65 48 8b 14 25 f0 c6 00 00 48 89 9a 48 e0\n[90701.970313] RIP  [<ffffffff814a343e>] kernel_setsockopt+0x2e/0x60\n[90701.977125]  RSP <ffff88177b431bb8>\n[90701.981018] CR2: 0000000000000028\n[90701.984809] ---[ end trace 24bd602971110a43 ]---\n\nThis is likely due to a race vs. a reconnection event.\n\nThe current code checks for a NULL socket in smb_send_kvec, but that's\ntoo late. By the time that check is done, the socket will already have\nbeen passed to kernel_setsockopt. Move the check into smb_send_rqst, so\nthat it's checked earlier.\n\nIn truth, this is a bit of a half-assed fix. The -ENOTSOCK error\nreturn here looks like it could bubble back up to userspace. The locking\nrules around the ssocket pointer are really unclear as well. There are\ncases where the ssocket pointer is changed without holding the srv_mutex,\nbut I'm not clear whether there's a potential race here yet or not.\n\nThis code seems like it could benefit from some fundamental re-think of\nhow the socket handling should behave. Until then though, this patch\nshould at least fix the above oops in most cases.\n\nCc: <stable@vger.kernel.org> # 3.7+\nReported-and-Tested-by: CAI Qian <caiqian@redhat.com>\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <smfrench@gmail.com>",
    "before_after_code_files": [
      "fs/cifs/transport.c||fs/cifs/transport.c"
    ]
  },
  "patch_diff": {
    "fs/cifs/transport.c||fs/cifs/transport.c": [
      "File: fs/cifs/transport.c -> fs/cifs/transport.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "150:  smb_msg.msg_name = (struct sockaddr *) &server->dstaddr;",
      "151:  smb_msg.msg_namelen = sizeof(struct sockaddr);",
      "152:  smb_msg.msg_control = NULL;",
      "",
      "[Removed Lines]",
      "147:  if (ssocket == NULL)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "291:  struct socket *ssocket = server->ssocket;",
      "292:  int val = 1;",
      "294:  cFYI(1, \"Sending smb: smb_len=%u\", smb_buf_length);",
      "295:  dump_smb(iov[0].iov_base, iov[0].iov_len);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "291:  if (ssocket == NULL)",
      "292:   return -ENOTSOCK;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5413dfba88d6f6090c8cdf181ab9172d24752f8f",
      "candidate_info": {
        "commit_hash": "5413dfba88d6f6090c8cdf181ab9172d24752f8f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5413dfba88d6f6090c8cdf181ab9172d24752f8f",
        "files": [
          "mm/slub.c"
        ],
        "message": "slub: drop mutex before deleting sysfs entry\n\nSasha Levin recently reported a lockdep problem resulting from the new\nattribute propagation introduced by kmemcg series.  In short, slab_mutex\nwill be called from within the sysfs attribute store function.  This will\ncreate a dependency, that will later be held backwards when a cache is\ndestroyed - since destruction occurs with the slab_mutex held, and then\ncalls in to the sysfs directory removal function.\n\nIn this patch, I propose to adopt a strategy close to what\n__kmem_cache_create does before calling sysfs_slab_add, and release the\nlock before the call to sysfs_slab_remove.  This is pretty much the last\noperation in the kmem_cache_shutdown() path, so we could do better by\nsplitting this and moving this call alone to later on.  This will fit\nnicely when sysfs handling is consistent between all caches, but will look\nweird now.\n\nLockdep info:\n\n  ======================================================\n  [ INFO: possible circular locking dependency detected ]\n  3.7.0-rc4-next-20121106-sasha-00008-g353b62f #117 Tainted: G        W\n  -------------------------------------------------------\n  trinity-child13/6961 is trying to acquire lock:\n   (s_active#43){++++.+}, at:  sysfs_addrm_finish+0x31/0x60\n\n  but task is already holding lock:\n   (slab_mutex){+.+.+.}, at:  kmem_cache_destroy+0x22/0xe0\n\n  which lock already depends on the new lock.\n\n  the existing dependency chain (in reverse order) is:\n  -> #1 (slab_mutex){+.+.+.}:\n          lock_acquire+0x1aa/0x240\n          __mutex_lock_common+0x59/0x5a0\n          mutex_lock_nested+0x3f/0x50\n          slab_attr_store+0xde/0x110\n          sysfs_write_file+0xfa/0x150\n          vfs_write+0xb0/0x180\n          sys_pwrite64+0x60/0xb0\n          tracesys+0xe1/0xe6\n  -> #0 (s_active#43){++++.+}:\n          __lock_acquire+0x14df/0x1ca0\n          lock_acquire+0x1aa/0x240\n          sysfs_deactivate+0x122/0x1a0\n          sysfs_addrm_finish+0x31/0x60\n          sysfs_remove_dir+0x89/0xd0\n          kobject_del+0x16/0x40\n          __kmem_cache_shutdown+0x40/0x60\n          kmem_cache_destroy+0x40/0xe0\n          mon_text_release+0x78/0xe0\n          __fput+0x122/0x2d0\n          ____fput+0x9/0x10\n          task_work_run+0xbe/0x100\n          do_exit+0x432/0xbd0\n          do_group_exit+0x84/0xd0\n          get_signal_to_deliver+0x81d/0x930\n          do_signal+0x3a/0x950\n          do_notify_resume+0x3e/0x90\n          int_signal+0x12/0x17\n\n  other info that might help us debug this:\n\n   Possible unsafe locking scenario:\n\n         CPU0                    CPU1\n         ----                    ----\n    lock(slab_mutex);\n                                 lock(s_active#43);\n                                 lock(slab_mutex);\n    lock(s_active#43);\n\n   *** DEADLOCK ***\n\n  2 locks held by trinity-child13/6961:\n   #0:  (mon_lock){+.+.+.}, at:  mon_text_release+0x25/0xe0\n   #1:  (slab_mutex){+.+.+.}, at:  kmem_cache_destroy+0x22/0xe0\n\n  stack backtrace:\n  Pid: 6961, comm: trinity-child13 Tainted: G        W    3.7.0-rc4-next-20121106-sasha-00008-g353b62f #117\n  Call Trace:\n    print_circular_bug+0x1fb/0x20c\n    __lock_acquire+0x14df/0x1ca0\n    lock_acquire+0x1aa/0x240\n    sysfs_deactivate+0x122/0x1a0\n    sysfs_addrm_finish+0x31/0x60\n    sysfs_remove_dir+0x89/0xd0\n    kobject_del+0x16/0x40\n    __kmem_cache_shutdown+0x40/0x60\n    kmem_cache_destroy+0x40/0xe0\n    mon_text_release+0x78/0xe0\n    __fput+0x122/0x2d0\n    ____fput+0x9/0x10\n    task_work_run+0xbe/0x100\n    do_exit+0x432/0xbd0\n    do_group_exit+0x84/0xd0\n    get_signal_to_deliver+0x81d/0x930\n    do_signal+0x3a/0x950\n    do_notify_resume+0x3e/0x90\n    int_signal+0x12/0x17\n\nSigned-off-by: Glauber Costa <glommer@parallels.com>\nReported-by: Sasha Levin <sasha.levin@oracle.com>\nCc: Michal Hocko <mhocko@suse.cz>\nCc: Kamezawa Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: Johannes Weiner <hannes@cmpxchg.org>\nCc: Christoph Lameter <cl@linux-foundation.org>\nCc: Pekka Enberg <penberg@kernel.org>\nAcked-by: David Rientjes <rientjes@google.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/slub.c||mm/slub.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "mm/slub.c||mm/slub.c": [
          "File: mm/slub.c -> mm/slub.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3153: {",
          "3154:  int rc = kmem_cache_close(s);",
          "3157:   sysfs_slab_remove(s);",
          "3159:  return rc;",
          "3160: }",
          "",
          "[Removed Lines]",
          "3156:  if (!rc)",
          "",
          "[Added Lines]",
          "3156:  if (!rc) {",
          "3165:   mutex_unlock(&slab_mutex);",
          "3167:   mutex_lock(&slab_mutex);",
          "3168:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "de242c0b8b365a9e348bf53143e18e9d8c9cfae8",
      "candidate_info": {
        "commit_hash": "de242c0b8b365a9e348bf53143e18e9d8c9cfae8",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/de242c0b8b365a9e348bf53143e18e9d8c9cfae8",
        "files": [
          "fs/nfs/fscache.h",
          "fs/nfs/inode.c",
          "fs/nfs/nfs4proc.c"
        ],
        "message": "NFS: Use FS-Cache invalidation\n\nUse the new FS-Cache invalidation facility from NFS to deal with foreign\nchanges being detected on the server rather than attempting to retire the old\ncookie and get a new one.\n\nThe problem with the old method was that NFS did not wait for all outstanding\nstorage and retrieval ops on the cache to complete.  There was no automatic\nwait between the calls to ->readpages() and calls to invalidate_inode_pages2()\nas the latter can only wait on locked pages that have been added to the\npagecache (which they haven't yet on entry to ->readpages()).\n\nThis was leading to oopses like the one below when an outstanding read got cut\noff from its cookie by a premature release.\n\nBUG: unable to handle kernel NULL pointer dereference at 00000000000000a8\nIP: [<ffffffffa0075118>] __fscache_read_or_alloc_pages+0x1dd/0x315 [fscache]\nPGD 15889067 PUD 15890067 PMD 0\nOops: 0000 [#1] SMP\nCPU 0\nModules linked in: cachefiles nfs fscache auth_rpcgss nfs_acl lockd sunrpc\n\nPid: 4544, comm: tar Not tainted 3.1.0-rc4-fsdevel+ #1064                  /DG965RY\nRIP: 0010:[<ffffffffa0075118>]  [<ffffffffa0075118>] __fscache_read_or_alloc_pages+0x1dd/0x315 [fscache]\nRSP: 0018:ffff8800158799e8  EFLAGS: 00010246\nRAX: 0000000000000000 RBX: ffff8800070d41e0 RCX: ffff8800083dc1b0\nRDX: 0000000000000000 RSI: ffff880015879960 RDI: ffff88003e627b90\nRBP: ffff880015879a28 R08: 0000000000000002 R09: 0000000000000002\nR10: 0000000000000001 R11: ffff880015879950 R12: ffff880015879aa4\nR13: 0000000000000000 R14: ffff8800083dc158 R15: ffff880015879be8\nFS:  00007f671e9d87c0(0000) GS:ffff88003bc00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\nCR2: 00000000000000a8 CR3: 000000001587f000 CR4: 00000000000006f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\nProcess tar (pid: 4544, threadinfo ffff880015878000, task ffff880015875040)\nStack:\n ffffffffa00b1759 ffff8800070dc158 ffff8800000213da ffff88002a286508\n ffff880015879aa4 ffff880015879be8 0000000000000001 ffff88002a2866e8\n ffff880015879a88 ffffffffa00b20be 00000000000200da ffff880015875040\nCall Trace:\n [<ffffffffa00b1759>] ? nfs_fscache_wait_bit+0xd/0xd [nfs]\n [<ffffffffa00b20be>] __nfs_readpages_from_fscache+0x7e/0x13f [nfs]\n [<ffffffff81095fe7>] ? __alloc_pages_nodemask+0x156/0x662\n [<ffffffffa0098763>] nfs_readpages+0xee/0x187 [nfs]\n [<ffffffff81098a5e>] __do_page_cache_readahead+0x1be/0x267\n [<ffffffff81098942>] ? __do_page_cache_readahead+0xa2/0x267\n [<ffffffff81098d7b>] ra_submit+0x1c/0x20\n [<ffffffff8109900a>] ondemand_readahead+0x28b/0x29a\n [<ffffffff810990ce>] page_cache_sync_readahead+0x38/0x3a\n [<ffffffff81091d8a>] generic_file_aio_read+0x2ab/0x67e\n [<ffffffffa008cfbe>] nfs_file_read+0xa4/0xc9 [nfs]\n [<ffffffff810c22c4>] do_sync_read+0xba/0xfa\n [<ffffffff810a62c9>] ? might_fault+0x4e/0x9e\n [<ffffffff81177a47>] ? security_file_permission+0x7b/0x84\n [<ffffffff810c25dd>] ? rw_verify_area+0xab/0xc8\n [<ffffffff810c29a4>] vfs_read+0xaa/0x13a\n [<ffffffff810c2a79>] sys_read+0x45/0x6c\n [<ffffffff813ac37b>] system_call_fastpath+0x16/0x1b\n\nReported-by: Mark Moseley <moseleymark@gmail.com>\nSigned-off-by: David Howells <dhowells@redhat.com>",
        "before_after_code_files": [
          "fs/nfs/fscache.h||fs/nfs/fscache.h",
          "fs/nfs/inode.c||fs/nfs/inode.c",
          "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/nfs/fscache.h||fs/nfs/fscache.h": [
          "File: fs/nfs/fscache.h -> fs/nfs/fscache.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "152:   __nfs_readpage_to_fscache(inode, page, sync);",
          "153: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "158: static inline void nfs_fscache_invalidate(struct inode *inode)",
          "159: {",
          "160:  fscache_invalidate(NFS_I(inode)->fscache);",
          "161: }",
          "166: static inline void nfs_fscache_wait_on_invalidate(struct inode *inode)",
          "167: {",
          "168:  fscache_wait_on_invalidate(NFS_I(inode)->fscache);",
          "169: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "205: static inline void nfs_readpage_to_fscache(struct inode *inode,",
          "206:         struct page *page, int sync) {}",
          "208: static inline const char *nfs_server_fscache_state(struct nfs_server *server)",
          "209: {",
          "210:  return \"no \";",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "224: static inline void nfs_fscache_invalidate(struct inode *inode) {}",
          "",
          "---------------"
        ],
        "fs/nfs/inode.c||fs/nfs/inode.c": [
          "File: fs/nfs/inode.c -> fs/nfs/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "161:  nfsi->attrtimeo_timestamp = jiffies;",
          "163:  memset(NFS_I(inode)->cookieverf, 0, sizeof(NFS_I(inode)->cookieverf));",
          "165:   nfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_DATA|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL|NFS_INO_REVAL_PAGECACHE;",
          "167:   nfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL|NFS_INO_REVAL_PAGECACHE;",
          "168: }",
          "170: void nfs_zap_caches(struct inode *inode)",
          "",
          "[Removed Lines]",
          "164:  if (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode))",
          "166:  else",
          "",
          "[Added Lines]",
          "164:  if (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)) {",
          "166:   nfs_fscache_invalidate(inode);",
          "167:  } else {",
          "169:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "179:  if (mapping->nrpages != 0) {",
          "180:   spin_lock(&inode->i_lock);",
          "181:   NFS_I(inode)->cache_validity |= NFS_INO_INVALID_DATA;",
          "182:   spin_unlock(&inode->i_lock);",
          "183:  }",
          "184: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "184:   nfs_fscache_invalidate(inode);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "881:   memset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));",
          "882:  spin_unlock(&inode->i_lock);",
          "883:  nfs_inc_stats(inode, NFSIOS_DATAINVALIDATE);",
          "885:  dfprintk(PAGECACHE, \"NFS: (%s/%Ld) data cache invalidated\\n\",",
          "886:    inode->i_sb->s_id, (long long)NFS_FILEID(inode));",
          "887:  return 0;",
          "",
          "[Removed Lines]",
          "884:  nfs_fscache_reset_inode_cookie(inode);",
          "",
          "[Added Lines]",
          "887:  nfs_fscache_wait_on_invalidate(inode);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "957:   i_size_write(inode, nfs_size_to_loff_t(fattr->size));",
          "958:   ret |= NFS_INO_INVALID_ATTR;",
          "959:  }",
          "960:  return ret;",
          "961: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "964:  if (nfsi->cache_validity & NFS_INO_INVALID_DATA)",
          "965:   nfs_fscache_invalidate(inode);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1205:  struct nfs_inode *nfsi = NFS_I(inode);",
          "1207:  nfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_REVAL_PAGECACHE;",
          "1209:   nfsi->cache_validity |= NFS_INO_INVALID_DATA;",
          "1210:  if ((fattr->valid & NFS_ATTR_FATTR) == 0)",
          "1211:   return 0;",
          "1212:  return nfs_refresh_inode_locked(inode, fattr);",
          "",
          "[Removed Lines]",
          "1208:  if (S_ISDIR(inode->i_mode))",
          "",
          "[Added Lines]",
          "1215:  if (S_ISDIR(inode->i_mode)) {",
          "1217:   nfs_fscache_invalidate(inode);",
          "1218:  }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1494:    (save_cache_validity & NFS_INO_REVAL_FORCED))",
          "1495:   nfsi->cache_validity |= invalid;",
          "1497:  return 0;",
          "1498:  out_err:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1506:  if (invalid & NFS_INO_INVALID_DATA)",
          "1507:   nfs_fscache_invalidate(inode);",
          "",
          "---------------"
        ],
        "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c": [
          "File: fs/nfs/nfs4proc.c -> fs/nfs/nfs4proc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "64: #include \"pnfs.h\"",
          "65: #include \"netns.h\"",
          "66: #include \"nfs4session.h\"",
          "69: #define NFSDBG_FACILITY  NFSDBG_PROC",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "67: #include \"fscache.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "734:  if (!cinfo->atomic || cinfo->before != dir->i_version)",
          "735:   nfs_force_lookup_revalidate(dir);",
          "736:  dir->i_version = cinfo->after;",
          "737:  spin_unlock(&dir->i_lock);",
          "738: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "737:  nfs_fscache_invalidate(dir);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ac4989874af56435c308bdde9ad9c837a26f8b23",
      "candidate_info": {
        "commit_hash": "ac4989874af56435c308bdde9ad9c837a26f8b23",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ac4989874af56435c308bdde9ad9c837a26f8b23",
        "files": [
          "drivers/dma/ioat/dma_v3.c"
        ],
        "message": "ioat: Fix DMA memory sync direction correct flag\n\nioat does DMA memory sync with DMA_TO_DEVICE direction on a buffer allocated\nfor DMA_FROM_DEVICE dma, resulting in the following warning from dma debug.\nFixed the dma_sync_single_for_device() call to use the correct direction.\n\n[  226.288947] WARNING: at lib/dma-debug.c:990 check_sync+0x132/0x550()\n[  226.288948] Hardware name: ProLiant DL380p Gen8\n[  226.288951] ioatdma 0000:00:04.0: DMA-API: device driver syncs DMA memory with different direction [device address=0x00000000ffff7000] [size=4096 bytes] [mapped with DMA_FROM_DEVICE] [synced with DMA_TO_DEVICE]\n[  226.288953] Modules linked in: iTCO_wdt(+) sb_edac(+) ioatdma(+) microcode serio_raw pcspkr edac_core hpwdt(+) iTCO_vendor_support hpilo(+) dca acpi_power_meter ata_generic pata_acpi sd_mod crc_t10dif ata_piix libata hpsa tg3 netxen_nic(+) sunrpc dm_mirror dm_region_hash dm_log dm_mod\n[  226.288967] Pid: 1055, comm: work_for_cpu Tainted: G        W    3.3.0-0.20.el7.x86_64 #1\n[  226.288968] Call Trace:\n[  226.288974]  [<ffffffff810644cf>] warn_slowpath_common+0x7f/0xc0\n[  226.288977]  [<ffffffff810645c6>] warn_slowpath_fmt+0x46/0x50\n[  226.288980]  [<ffffffff81345502>] check_sync+0x132/0x550\n[  226.288983]  [<ffffffff81345c9f>] debug_dma_sync_single_for_device+0x3f/0x50\n[  226.288988]  [<ffffffff81661002>] ? wait_for_common+0x72/0x180\n[  226.288995]  [<ffffffffa019590f>] ioat_xor_val_self_test+0x3e5/0x832 [ioatdma]\n[  226.288999]  [<ffffffff811a5739>] ? kfree+0x259/0x270\n[  226.289004]  [<ffffffffa0195d77>] ioat3_dma_self_test+0x1b/0x20 [ioatdma]\n[  226.289008]  [<ffffffffa01952c3>] ioat_probe+0x2f8/0x348 [ioatdma]\n[  226.289011]  [<ffffffffa0195f51>] ioat3_dma_probe+0x1d5/0x2aa [ioatdma]\n[  226.289016]  [<ffffffffa0194d12>] ioat_pci_probe+0x139/0x17c [ioatdma]\n[  226.289020]  [<ffffffff81354b8c>] local_pci_probe+0x5c/0xd0\n[  226.289023]  [<ffffffff81083e50>] ? destroy_work_on_stack+0x20/0x20\n[  226.289025]  [<ffffffff81083e68>] do_work_for_cpu+0x18/0x30\n[  226.289029]  [<ffffffff8108d997>] kthread+0xb7/0xc0\n[  226.289033]  [<ffffffff8166cef4>] kernel_thread_helper+0x4/0x10\n[  226.289036]  [<ffffffff81662d20>] ? _raw_spin_unlock_irq+0x30/0x50\n[  226.289038]  [<ffffffff81663234>] ? retint_restore_args+0x13/0x13\n[  226.289041]  [<ffffffff8108d8e0>] ? kthread_worker_fn+0x1a0/0x1a0\n[  226.289044]  [<ffffffff8166cef0>] ? gs_change+0x13/0x13\n[  226.289045] ---[ end trace e1618afc7a606089 ]---\n[  226.289047] Mapped at:\n[  226.289048]  [<ffffffff81345307>] debug_dma_map_page+0x87/0x150\n[  226.289050]  [<ffffffffa019653c>] dma_map_page.constprop.18+0x70/0xb34 [ioatdma]\n[  226.289054]  [<ffffffffa0195702>] ioat_xor_val_self_test+0x1d8/0x832 [ioatdma]\n[  226.289058]  [<ffffffffa0195d77>] ioat3_dma_self_test+0x1b/0x20 [ioatdma]\n[  226.289061]  [<ffffffffa01952c3>] ioat_probe+0x2f8/0x348 [ioatdma]\n\nSigned-off-by: Shuah Khan <shuah.khan@hp.com>\nCC: <stable@vger.kernel.org>\nSigned-off-by: Vinod Koul <vinod.koul@linux.intel.com>",
        "before_after_code_files": [
          "drivers/dmioat/dma_v3.c||drivers/dma/ioat/dma_v3.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/dmioat/dma_v3.c||drivers/dma/ioat/dma_v3.c": [
          "File: drivers/dmioat/dma_v3.c -> drivers/dma/ioat/dma_v3.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "954:  dma_sync_single_for_device(dev, dest_dma, PAGE_SIZE, DMA_FROM_DEVICE);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e6449c9b2d90c1bd9a5985bf05ddebfd1631cd6b",
      "candidate_info": {
        "commit_hash": "e6449c9b2d90c1bd9a5985bf05ddebfd1631cd6b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e6449c9b2d90c1bd9a5985bf05ddebfd1631cd6b",
        "files": [
          "arch/powerpc/platforms/40x/ppc40x_simple.c"
        ],
        "message": "powerpc: Add missing NULL terminator to avoid boot panic on PPC40x\n\nThe missing NULL terminator can cause a panic on\nPPC405 boards during boot:\n\n  Linux/PowerPC load: console=ttyS0,115200 root=/dev/mtdblock1 rootfstype=squashfs,jffs2 noinitrd init=/etc/preinit\n  Finalizing device tree... flat tree at 0x6a5160\n  bootconsole [udbg0] enabled\n  Page fault in user mode with in_atomic() = 1 mm = (null)\n  NIP = c0275f50  MSR = fffffffe\n  Oops: Weird page fault, sig: 11 [#1]\n  PowerPC 40x Platform\n  Modules linked in:\n  NIP: c0275f50 LR: c0275f60 CTR: c0280000\n  REGS: c0275eb0 TRAP: 636f7265   Not tainted  (3.7.1)\n  MSR: fffffffe <VEC,VSX,EE,PR,FP,ME,SE,BE,IR,DR,PMM,RI> CR: c06a6190  XER: 00000001\n  TASK = c02662a8[0] 'swapper' THREAD: c0274000\n  GPR00: c0275ec0 c000c658 c027c4bf 00000000 c0275ee0 c000a0ec c020a1a8 c020a1f0\n  GPR08: c020f631 c020f404 c025f078 c025f080 c0275f10\n   Call Trace:\n   ---[ end trace 31fd0ba7d8756001 ]---\n\n  Kernel panic - not syncing: Attempted to kill the idle task!\n\nThe panic happens since commit 9597abe00c1bab2aedce6b49866bf6d1e81c9eed\n(sections: fix section conflicts in arch/powerpc), however the root\ncause of this is that the NULL terminator were not added in commit\na4f740cf33f7f6c164bbde3c0cdbcc77b0c4997c (of/flattree: Add of_flat_dt_match()\nhelper function).\n\nCc: Grant Likely <grant.likely@secretlab.ca>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Gabor Juhos <juhosg@openwrt.org>\nSigned-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>",
        "before_after_code_files": [
          "arch/powerpc/platforms/40x/ppc40x_simple.c||arch/powerpc/platforms/40x/ppc40x_simple.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/powerpc/platforms/40x/ppc40x_simple.c||arch/powerpc/platforms/40x/ppc40x_simple.c": [
          "File: arch/powerpc/platforms/40x/ppc40x_simple.c -> arch/powerpc/platforms/40x/ppc40x_simple.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "57:  \"amcc,makalu\",",
          "58:  \"apm,klondike\",",
          "59:  \"est,hotfoot\",",
          "61: };",
          "63: static int __init ppc40x_probe(void)",
          "",
          "[Removed Lines]",
          "60:  \"plathome,obs600\"",
          "",
          "[Added Lines]",
          "60:  \"plathome,obs600\",",
          "61:  NULL",
          "",
          "---------------"
        ]
      }
    }
  ]
}
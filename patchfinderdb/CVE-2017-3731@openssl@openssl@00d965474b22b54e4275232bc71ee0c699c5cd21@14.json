{
  "cve_id": "CVE-2017-3731",
  "cve_desc": "If an SSL/TLS server or client is running on a 32-bit host, and a specific cipher is being used, then a truncated packet can cause that server or client to perform an out-of-bounds read, usually resulting in a crash. For OpenSSL 1.1.0, the crash can be triggered when using CHACHA20/POLY1305; users should upgrade to 1.1.0d. For Openssl 1.0.2, the crash can be triggered when using RC4-MD5; users who have not disabled that algorithm should update to 1.0.2k.",
  "repo": "openssl/openssl",
  "patch_hash": "00d965474b22b54e4275232bc71ee0c699c5cd21",
  "patch_info": {
    "commit_hash": "00d965474b22b54e4275232bc71ee0c699c5cd21",
    "repo": "openssl/openssl",
    "commit_url": "https://github.com/openssl/openssl/commit/00d965474b22b54e4275232bc71ee0c699c5cd21",
    "files": [
      "crypto/evp/e_aes.c",
      "crypto/evp/e_chacha20_poly1305.c"
    ],
    "message": "crypto/evp: harden AEAD ciphers.\n\nOriginally a crash in 32-bit build was reported CHACHA20-POLY1305\ncipher. The crash is triggered by truncated packet and is result\nof excessive hashing to the edge of accessible memory. Since hash\noperation is read-only it is not considered to be exploitable\nbeyond a DoS condition. Other ciphers were hardened.\n\nThanks to Robert \u015awi\u0119cki for report.\n\nCVE-2017-3731\n\nReviewed-by: Rich Salz <rsalz@openssl.org>",
    "before_after_code_files": [
      "crypto/evp/e_aes.c||crypto/evp/e_aes.c",
      "crypto/evp/e_chacha20_poly1305.c||crypto/evp/e_chacha20_poly1305.c"
    ]
  },
  "patch_diff": {
    "crypto/evp/e_aes.c||crypto/evp/e_aes.c": [
      "File: crypto/evp/e_aes.c -> crypto/evp/e_aes.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1388:                 EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] << 8",
      "1389:                 | EVP_CIPHER_CTX_buf_noconst(c)[arg - 1];",
      "1391:             len -= EVP_GCM_TLS_EXPLICIT_IV_LEN;",
      "1394:                 len -= EVP_GCM_TLS_TAG_LEN;",
      "1395:             EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] = len >> 8;",
      "1396:             EVP_CIPHER_CTX_buf_noconst(c)[arg - 1] = len & 0xff;",
      "1397:         }",
      "",
      "[Removed Lines]",
      "1393:             if (!EVP_CIPHER_CTX_encrypting(c))",
      "",
      "[Added Lines]",
      "1391:             if (len < EVP_GCM_TLS_EXPLICIT_IV_LEN)",
      "1392:                 return 0;",
      "1395:             if (!EVP_CIPHER_CTX_encrypting(c)) {",
      "1396:                 if (len < EVP_GCM_TLS_TAG_LEN)",
      "1397:                     return 0;",
      "1399:             }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1946:                 EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] << 8",
      "1947:                 | EVP_CIPHER_CTX_buf_noconst(c)[arg - 1];",
      "1949:             len -= EVP_CCM_TLS_EXPLICIT_IV_LEN;",
      "1952:                 len -= cctx->M;",
      "1953:             EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] = len >> 8;",
      "1954:             EVP_CIPHER_CTX_buf_noconst(c)[arg - 1] = len & 0xff;",
      "1955:         }",
      "",
      "[Removed Lines]",
      "1951:             if (!EVP_CIPHER_CTX_encrypting(c))",
      "",
      "[Added Lines]",
      "1954:             if (len < EVP_CCM_TLS_EXPLICIT_IV_LEN)",
      "1955:                 return 0;",
      "1958:             if (!EVP_CIPHER_CTX_encrypting(c)) {",
      "1959:                 if (len < cctx->M)",
      "1960:                     return 0;",
      "1962:             }",
      "",
      "---------------"
    ],
    "crypto/evp/e_chacha20_poly1305.c||crypto/evp/e_chacha20_poly1305.c": [
      "File: crypto/evp/e_chacha20_poly1305.c -> crypto/evp/e_chacha20_poly1305.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "398:             len = aad[EVP_AEAD_TLS1_AAD_LEN - 2] << 8 |",
      "399:                   aad[EVP_AEAD_TLS1_AAD_LEN - 1];",
      "400:             if (!ctx->encrypt) {",
      "402:                 memcpy(temp, aad, EVP_AEAD_TLS1_AAD_LEN - 2);",
      "403:                 aad = temp;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "401:                 if (len < POLY1305_BLOCK_SIZE)",
      "402:                     return 0;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4c8b3b5c5a509af641bdb1de688f3e6a7476ddb5",
      "candidate_info": {
        "commit_hash": "4c8b3b5c5a509af641bdb1de688f3e6a7476ddb5",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/4c8b3b5c5a509af641bdb1de688f3e6a7476ddb5",
        "files": [
          "test/asynctest.c"
        ],
        "message": "asynctest: don't depend on apps\n\nRemove unnecessary include of apps.h. Tests shouldn't take a\ndependency on apps. In this case, there is no dependency, the include\nis unnecessary.\n\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>",
        "before_after_code_files": [
          "test/asynctest.c||test/asynctest.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "test/asynctest.c||test/asynctest.c": [
          "File: test/asynctest.c -> test/asynctest.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: #include <string.h>",
          "16: #include <openssl/async.h>",
          "17: #include <openssl/crypto.h>",
          "20: static int ctr = 0;",
          "21: static ASYNC_JOB *currjob = NULL;",
          "",
          "[Removed Lines]",
          "18: #include <../apps/apps.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b5c8f42c9b9fce5d1b14866306e7a11e16275942",
      "candidate_info": {
        "commit_hash": "b5c8f42c9b9fce5d1b14866306e7a11e16275942",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/b5c8f42c9b9fce5d1b14866306e7a11e16275942",
        "files": [
          "doc/ssl/SSL_COMP_add_compression_method.pod",
          "include/openssl/ssl.h",
          "ssl/ssl_ciph.c",
          "test/ssltest_old.c",
          "util/libssl.num"
        ],
        "message": "Remove a hack from ssl_test_old\n\nssl_test_old was reaching inside the SSL structure and changing the internal\nBIO values. This is completely unneccessary, and was causing an abort in the\ntest when enabling TLSv1.3.\n\nI also removed the need for ssl_test_old to include ssl_locl.h. This\nrequired the addition of some missing accessors for SSL_COMP name and id\nfields.\n\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(cherry picked from commit e304d3e20f45243f9e643607edfe4db49c329596)",
        "before_after_code_files": [
          "include/openssl/ssl.h||include/openssl/ssl.h",
          "ssl/ssl_ciph.c||ssl/ssl_ciph.c",
          "test/ssltest_old.c||test/ssltest_old.c",
          "util/libssl.num||util/libssl.num"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/openssl/ssl.h||include/openssl/ssl.h": [
          "File: include/openssl/ssl.h -> include/openssl/ssl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1777: __owur const COMP_METHOD *SSL_get_current_compression(SSL *s);",
          "1778: __owur const COMP_METHOD *SSL_get_current_expansion(SSL *s);",
          "1779: __owur const char *SSL_COMP_get_name(const COMP_METHOD *comp);",
          "1780: STACK_OF(SSL_COMP) *SSL_COMP_get_compression_methods(void);",
          "1781: __owur STACK_OF(SSL_COMP) *SSL_COMP_set0_compression_methods(STACK_OF(SSL_COMP)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1780: __owur const char *SSL_COMP_get0_name(const SSL_COMP *comp);",
          "1781: __owur int SSL_COMP_get_id(const SSL_COMP *comp);",
          "",
          "---------------"
        ],
        "ssl/ssl_ciph.c||ssl/ssl_ciph.c": [
          "File: ssl/ssl_ciph.c -> ssl/ssl_ciph.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1868: #endif",
          "1869: }",
          "1872: int ssl_cipher_get_cert_index(const SSL_CIPHER *c)",
          "1873: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1871: const char *SSL_COMP_get0_name(const SSL_COMP *comp)",
          "1872: {",
          "1873: #ifndef OPENSSL_NO_COMP",
          "1874:     return comp->name;",
          "1875: #else",
          "1876:     return NULL;",
          "1877: #endif",
          "1878: }",
          "1880: int SSL_COMP_get_id(const SSL_COMP *comp)",
          "1881: {",
          "1882: #ifndef OPENSSL_NO_COMP",
          "1883:     return comp->id;",
          "1884: #else",
          "1885:     return -1;",
          "1886: #endif",
          "1887: }",
          "",
          "---------------"
        ],
        "test/ssltest_old.c||test/ssltest_old.c": [
          "File: test/ssltest_old.c -> test/ssltest_old.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "92: # include <openssl/ct.h>",
          "93: #endif",
          "",
          "[Removed Lines]",
          "95: #include \"../ssl/ssl_locl.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1421:         printf(\"Available compression methods:\");",
          "1422:         for (j = 0; j < n; j++) {",
          "1423:             SSL_COMP *c = sk_SSL_COMP_value(ssl_comp_methods, j);",
          "1425:         }",
          "1426:         printf(\"\\n\");",
          "1427:     }",
          "",
          "[Removed Lines]",
          "1424:             printf(\"  %s:%d\", c->name, c->id);",
          "",
          "[Added Lines]",
          "1422:             printf(\"  %s:%d\", SSL_COMP_get0_name(c), SSL_COMP_get_id(c));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2664:     SSL_set_max_send_fragment(c_ssl, max_frag);",
          "2665:     BIO_set_ssl(c_bio, c_ssl, BIO_NOCLOSE);",
          "2667:     SSL_set_accept_state(s_ssl);",
          "2668:     SSL_set_bio(s_ssl, c_to_s, s_to_c);",
          "2669:     SSL_set_max_send_fragment(s_ssl, max_frag);",
          "2670:     BIO_set_ssl(s_bio, s_ssl, BIO_NOCLOSE);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2669:     if (!BIO_up_ref(c_to_s)) {",
          "2671:         c_to_s = NULL;",
          "2672:         s_to_c = NULL;",
          "2673:         goto err;",
          "2674:     }",
          "2675:     if (!BIO_up_ref(s_to_c)) {",
          "2677:         s_to_c = NULL;",
          "2678:         goto err;",
          "2679:     }",
          "2685:     c_to_s = NULL;",
          "2686:     s_to_c = NULL;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2878:     }",
          "2879:     ret = 0;",
          "2880:  err:",
          "2898:     BIO_free(c_to_s);",
          "2899:     BIO_free(s_to_c);",
          "2900:     BIO_free_all(c_bio);",
          "",
          "[Removed Lines]",
          "2889:     if (s_ssl != NULL) {",
          "2890:         s_ssl->rbio = NULL;",
          "2891:         s_ssl->wbio = NULL;",
          "2892:     }",
          "2893:     if (c_ssl != NULL) {",
          "2894:         c_ssl->rbio = NULL;",
          "2895:         c_ssl->wbio = NULL;",
          "2896:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "util/libssl.num||util/libssl.num": [
          "File: util/libssl.num -> util/libssl.num",
          "--- Hunk 1 ---",
          "[Context before]",
          "403: SSL_SESSION_get0_cipher                 404 1_1_0 EXIST::FUNCTION:",
          "404: SSL_SESSION_get0_id_context             405 1_1_0 EXIST::FUNCTION:",
          "405: SSL_SESSION_set1_id                     406 1_1_0 EXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "406: SSL_COMP_get_id                         412 1_1_0d EXIST::FUNCTION:",
          "407: SSL_COMP_get0_name                      413 1_1_0d EXIST::FUNCTION:",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cc0a813f23136fb1f1aff8bf4cdc831ae3d360d4",
      "candidate_info": {
        "commit_hash": "cc0a813f23136fb1f1aff8bf4cdc831ae3d360d4",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/cc0a813f23136fb1f1aff8bf4cdc831ae3d360d4",
        "files": [
          "crypto/pkcs12/p12_mutl.c"
        ],
        "message": "Fix memory leak in pkcs12 -export\n\nReviewed-by: Andy Polyakov <appro@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/2676)\n(cherry picked from commit 1b8f19379a521ec11ce37e12316dd3edc0acfb82)",
        "before_after_code_files": [
          "crypto/pkcs12/p12_mutl.c||crypto/pkcs12/p12_mutl.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "crypto/pkcs12/p12_mutl.c||crypto/pkcs12/p12_mutl.c": [
          "File: crypto/pkcs12/p12_mutl.c -> crypto/pkcs12/p12_mutl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "204: {",
          "205:     X509_ALGOR *macalg;",
          "207:     if ((p12->mac = PKCS12_MAC_DATA_new()) == NULL)",
          "208:         return PKCS12_ERROR;",
          "209:     if (iter > 1) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "207:     PKCS12_MAC_DATA_free(p12->mac);",
          "208:     p12->mac = NULL;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4e7a0fa104b0eb60a60f2d4cc4d7f8d9852a910c",
      "candidate_info": {
        "commit_hash": "4e7a0fa104b0eb60a60f2d4cc4d7f8d9852a910c",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/4e7a0fa104b0eb60a60f2d4cc4d7f8d9852a910c",
        "files": [
          "test/build.info",
          "test/recipes/80-test_sslcorrupt.t",
          "test/sslcorrupttest.c",
          "test/ssltestlib.c"
        ],
        "message": "test: add TLS application data corruption test.\n\nReviewed-by: Emilia K\u00e4sper <emilia@openssl.org>",
        "before_after_code_files": [
          "test/build.info||test/build.info",
          "test/recipes/80-test_sslcorrupt.t||test/recipes/80-test_sslcorrupt.t",
          "test/sslcorrupttest.c||test/sslcorrupttest.c",
          "test/ssltestlib.c||test/ssltestlib.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "test/build.info||test/build.info": [
          "File: test/build.info -> test/build.info",
          "--- Hunk 1 ---",
          "[Context before]",
          "16:           packettest asynctest secmemtest srptest memleaktest \\",
          "17:           dtlsv1listentest ct_test threadstest afalgtest d2i_test \\",
          "18:           ssl_test_ctx_test ssl_test x509aux cipherlist_test asynciotest \\",
          "21:   SOURCE[aborttest]=aborttest.c",
          "22:   INCLUDE[aborttest]=../include",
          "",
          "[Removed Lines]",
          "19:           bioprinttest sslapitest dtlstest bio_enc_test",
          "",
          "[Added Lines]",
          "19:           bioprinttest sslapitest dtlstest sslcorrupttest bio_enc_test",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "271:   INCLUDE[dtlstest]=../include .",
          "272:   DEPEND[dtlstest]=../libcrypto ../libssl",
          "274:   SOURCE[bio_enc_test]=bio_enc_test.c",
          "275:   INCLUDE[bio_enc_test]=../include",
          "276:   DEPEND[bio_enc_test]=../libcrypto",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "274:   SOURCE[sslcorrupttest]=sslcorrupttest.c ssltestlib.c testutil.c",
          "275:   INCLUDE[sslcorrupttest]=../include .",
          "276:   DEPEND[sslcorrupttest]=../libcrypto ../libssl",
          "",
          "---------------"
        ],
        "test/recipes/80-test_sslcorrupt.t||test/recipes/80-test_sslcorrupt.t": [
          "File: test/recipes/80-test_sslcorrupt.t -> test/recipes/80-test_sslcorrupt.t",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #! /usr/bin/env perl",
          "2: # Copyright 2016 The OpenSSL Project Authors. All Rights Reserved.",
          "3: #",
          "4: # Licensed under the OpenSSL license (the \"License\").  You may not use",
          "5: # this file except in compliance with the License.  You can obtain a copy",
          "6: # in the file LICENSE in the source distribution or at",
          "7: # https://www.openssl.org/source/license.html",
          "9: use OpenSSL::Test qw/:DEFAULT srctop_file/;",
          "11: setup(\"test_sslcorrupt\");",
          "13: plan tests => 1;",
          "15: ok(run(test([\"sslcorrupttest\", srctop_file(\"apps\", \"server.pem\"),",
          "16:              srctop_file(\"apps\", \"server.pem\")])), \"running sslcorrupttest\");",
          "",
          "---------------"
        ],
        "test/sslcorrupttest.c||test/sslcorrupttest.c": [
          "File: test/sslcorrupttest.c -> test/sslcorrupttest.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10: #include \"ssltestlib.h\"",
          "11: #include \"testutil.h\"",
          "13: static void copy_flags(BIO *bio)",
          "14: {",
          "15:     int flags;",
          "16:     BIO *next = BIO_next(bio);",
          "18:     flags = BIO_test_flags(next, BIO_FLAGS_SHOULD_RETRY | BIO_FLAGS_RWS);",
          "19:     BIO_clear_flags(bio, BIO_FLAGS_SHOULD_RETRY | BIO_FLAGS_RWS);",
          "20:     BIO_set_flags(bio, flags);",
          "21: }",
          "23: static int tls_corrupt_read(BIO *bio, char *out, int outl)",
          "24: {",
          "25:     int ret;",
          "26:     BIO *next = BIO_next(bio);",
          "28:     ret = BIO_read(next, out, outl);",
          "29:     copy_flags(bio);",
          "31:     return ret;",
          "32: }",
          "34: static int tls_corrupt_write(BIO *bio, const char *in, int inl)",
          "35: {",
          "36:     int ret;",
          "37:     BIO *next = BIO_next(bio);",
          "38:     char *copy;",
          "40:     if (in[0] == SSL3_RT_APPLICATION_DATA) {",
          "41:         copy = BUF_memdup(in, inl);",
          "42:         TEST_check(copy != NULL);",
          "44:         copy[inl-1] ^= 1;",
          "45:         ret = BIO_write(next, copy, inl);",
          "46:         OPENSSL_free(copy);",
          "47:     } else {",
          "48:         ret = BIO_write(next, in, inl);",
          "49:     }",
          "50:     copy_flags(bio);",
          "52:     return ret;",
          "53: }",
          "55: static long tls_corrupt_ctrl(BIO *bio, int cmd, long num, void *ptr)",
          "56: {",
          "57:     long ret;",
          "58:     BIO *next = BIO_next(bio);",
          "60:     if (next == NULL)",
          "61:         return 0;",
          "63:     switch (cmd) {",
          "64:     case BIO_CTRL_DUP:",
          "65:         ret = 0L;",
          "66:         break;",
          "67:     default:",
          "68:         ret = BIO_ctrl(next, cmd, num, ptr);",
          "69:         break;",
          "70:     }",
          "71:     return ret;",
          "72: }",
          "74: static int tls_corrupt_gets(BIO *bio, char *buf, int size)",
          "75: {",
          "77:     return -1;",
          "78: }",
          "80: static int tls_corrupt_puts(BIO *bio, const char *str)",
          "81: {",
          "83:     return -1;",
          "84: }",
          "86: static int tls_corrupt_new(BIO *bio)",
          "87: {",
          "88:     BIO_set_init(bio, 1);",
          "90:     return 1;",
          "91: }",
          "93: static int tls_corrupt_free(BIO *bio)",
          "94: {",
          "95:     BIO_set_init(bio, 0);",
          "97:     return 1;",
          "98: }",
          "100: #define BIO_TYPE_CUSTOM_FILTER  (0x80 | BIO_TYPE_FILTER)",
          "102: static BIO_METHOD *method_tls_corrupt = NULL;",
          "105: static const BIO_METHOD *bio_f_tls_corrupt_filter(void)",
          "106: {",
          "107:     if (method_tls_corrupt == NULL) {",
          "108:         method_tls_corrupt = BIO_meth_new(BIO_TYPE_CUSTOM_FILTER,",
          "109:                                           \"TLS corrupt filter\");",
          "110:         if (   method_tls_corrupt == NULL",
          "111:             || !BIO_meth_set_write(method_tls_corrupt, tls_corrupt_write)",
          "112:             || !BIO_meth_set_read(method_tls_corrupt, tls_corrupt_read)",
          "113:             || !BIO_meth_set_puts(method_tls_corrupt, tls_corrupt_puts)",
          "114:             || !BIO_meth_set_gets(method_tls_corrupt, tls_corrupt_gets)",
          "115:             || !BIO_meth_set_ctrl(method_tls_corrupt, tls_corrupt_ctrl)",
          "116:             || !BIO_meth_set_create(method_tls_corrupt, tls_corrupt_new)",
          "117:             || !BIO_meth_set_destroy(method_tls_corrupt, tls_corrupt_free))",
          "118:             return NULL;",
          "119:     }",
          "120:     return method_tls_corrupt;",
          "121: }",
          "123: static void bio_f_tls_corrupt_filter_free(void)",
          "124: {",
          "125:     BIO_meth_free(method_tls_corrupt);",
          "126: }",
          "135: static const char **cipher_list = NULL;",
          "137: static int setup_cipher_list()",
          "138: {",
          "139:     SSL_CTX *ctx = NULL;",
          "140:     SSL *ssl = NULL;",
          "141:     static STACK_OF(SSL_CIPHER) *sk_ciphers = NULL;",
          "142:     int i, numciphers;",
          "144:     ctx = SSL_CTX_new(TLS_server_method());",
          "145:     TEST_check(ctx != NULL);",
          "146:     ssl = SSL_new(ctx);",
          "147:     TEST_check(ssl != NULL);",
          "148:     sk_ciphers = SSL_get1_supported_ciphers(ssl);",
          "149:     TEST_check(sk_ciphers != NULL);",
          "156:     cipher_list = OPENSSL_malloc(sk_SSL_CIPHER_num(sk_ciphers) *",
          "157:                                  sizeof(cipher_list[0]));",
          "158:     TEST_check(cipher_list != NULL);",
          "160:     for (numciphers = 0, i = 0; i < sk_SSL_CIPHER_num(sk_ciphers); i++) {",
          "161:         const SSL_CIPHER *cipher = sk_SSL_CIPHER_value(sk_ciphers, i);",
          "163:         if (SSL_CIPHER_get_auth_nid(cipher) == NID_auth_rsa)",
          "164:             cipher_list[numciphers++] = SSL_CIPHER_get_name(cipher);",
          "165:     }",
          "166:     TEST_check(numciphers != 0);",
          "168:     sk_SSL_CIPHER_free(sk_ciphers);",
          "169:     SSL_free(ssl);",
          "170:     SSL_CTX_free(ctx);",
          "172:     return numciphers;",
          "173: }",
          "175: static char *cert = NULL;",
          "176: static char *privkey = NULL;",
          "178: static int test_ssl_corrupt(int testidx)",
          "179: {",
          "180:     SSL_CTX *sctx = NULL, *cctx = NULL;",
          "181:     SSL *server = NULL, *client = NULL;",
          "182:     BIO *c_to_s_fbio;",
          "183:     int testresult = 0;",
          "184:     static unsigned char junk[16000] = { 0 };",
          "186:     printf(\"Starting Test %d, %s\\n\", testidx, cipher_list[testidx]);",
          "188:     if (!create_ssl_ctx_pair(TLS_server_method(), TLS_client_method(), &sctx,",
          "189:                              &cctx, cert, privkey)) {",
          "190:         printf(\"Unable to create SSL_CTX pair\\n\");",
          "191:         return 0;",
          "192:     }",
          "194:     if (!SSL_CTX_set_cipher_list(cctx, cipher_list[testidx])) {",
          "195:         printf(\"Failed setting cipher list\\n\");",
          "196:         goto end;",
          "197:     }",
          "199:     c_to_s_fbio = BIO_new(bio_f_tls_corrupt_filter());",
          "200:     if (c_to_s_fbio == NULL) {",
          "201:         printf(\"Failed to create filter BIO\\n\");",
          "202:         goto end;",
          "203:     }",
          "206:     if (!create_ssl_objects(sctx, cctx, &server, &client, NULL,",
          "207:                             c_to_s_fbio)) {",
          "208:         printf(\"Unable to create SSL objects\\n\");",
          "209:         ERR_print_errors_fp(stdout);",
          "210:         goto end;",
          "211:     }",
          "213:     if (!create_ssl_connection(server, client)) {",
          "214:         printf(\"Unable to create SSL connection\\n\");",
          "215:         ERR_print_errors_fp(stdout);",
          "216:         goto end;",
          "217:     }",
          "219:     if (SSL_write(client, junk, sizeof(junk)) < 0) {",
          "220:         printf(\"Unable to SSL_write\\n\");",
          "221:         ERR_print_errors_fp(stdout);",
          "222:         goto end;",
          "223:     }",
          "225:     if (SSL_read(server, junk, sizeof(junk)) >= 0) {",
          "226:         printf(\"Read should have failed with \\\"bad record mac\\\"\\n\");",
          "227:         goto end;",
          "228:     }",
          "230:     if (ERR_GET_REASON(ERR_peek_error()) !=",
          "231:         SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC) {",
          "232:         ERR_print_errors_fp(stdout);",
          "233:         goto end;",
          "234:     }",
          "236:     testresult = 1;",
          "237:  end:",
          "238:     SSL_free(server);",
          "239:     SSL_free(client);",
          "240:     SSL_CTX_free(sctx);",
          "241:     SSL_CTX_free(cctx);",
          "243:     return testresult;",
          "244: }",
          "246: int main(int argc, char *argv[])",
          "247: {",
          "248:     BIO *err = NULL;",
          "249:     int testresult = 1;",
          "251:     if (argc != 3) {",
          "252:         printf(\"Invalid argument count\\n\");",
          "253:         return 1;",
          "254:     }",
          "256:     cert = argv[1];",
          "257:     privkey = argv[2];",
          "259:     err = BIO_new_fp(stderr, BIO_NOCLOSE | BIO_FP_TEXT);",
          "261:     CRYPTO_set_mem_debug(1);",
          "262:     CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);",
          "264:     ADD_ALL_TESTS(test_ssl_corrupt, setup_cipher_list());",
          "266:     testresult = run_tests(argv[0]);",
          "268:     bio_f_tls_corrupt_filter_free();",
          "270:     OPENSSL_free(cipher_list);",
          "272: #ifndef OPENSSL_NO_CRYPTO_MDEBUG",
          "273:     if (CRYPTO_mem_leaks(err) <= 0)",
          "274:         testresult = 1;",
          "275: #endif",
          "276:     BIO_free(err);",
          "278:     if (!testresult)",
          "279:         printf(\"PASS\\n\");",
          "281:     return testresult;",
          "282: }",
          "",
          "---------------"
        ],
        "test/ssltestlib.c||test/ssltestlib.c": [
          "File: test/ssltestlib.c -> test/ssltestlib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "550:         goto err;",
          "551:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "553: #ifndef OPENSSL_NO_DH",
          "554:     SSL_CTX_set_dh_auto(serverctx, 1);",
          "555: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b71079a375116a8a52ed493afcd8f69cb08c195a",
      "candidate_info": {
        "commit_hash": "b71079a375116a8a52ed493afcd8f69cb08c195a",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/b71079a375116a8a52ed493afcd8f69cb08c195a",
        "files": [
          "crypto/rsa/rsa_err.c",
          "crypto/rsa/rsa_sign.c",
          "include/openssl/rsa.h",
          "test/evptests.txt"
        ],
        "message": "Implement RSASSA-PKCS1-v1_5 as specified.\n\nRFC 3447, section 8.2.2, steps 3 and 4 states that verifiers must encode\nthe DigestInfo struct and then compare the result against the public key\noperation result. This implies that one and only one encoding is legal.\n\nOpenSSL instead parses with crypto/asn1, then checks that the encoding\nround-trips, and allows some variations for the parameter. Sufficient\nlaxness in this area can allow signature forgeries, as described in\nhttps://www.imperialviolet.org/2014/09/26/pkcs1.html\n\nAlthough there aren't known attacks against OpenSSL's current scheme,\nthis change makes OpenSSL implement the algorithm as specified. This\navoids the uncertainty and, more importantly, helps grow a healthy\necosystem. Laxness beyond the spec, particularly in implementations\nwhich enjoy wide use, risks harm to the ecosystem for all. A signature\nproducer which only tests against OpenSSL may not notice bugs and\naccidentally become widely deployed. Thus implementations have a\nresponsibility to honor the specification as tightly as is practical.\n\nIn some cases, the damage is permanent and the spec deviation and\nsecurity risk becomes a tax all implementors must forever pay, but not\nhere. Both BoringSSL and Go successfully implemented and deployed\nRSASSA-PKCS1-v1_5 as specified since their respective beginnings, so\nthis change should be compatible enough to pin down in future OpenSSL\nreleases.\n\nSee also https://tools.ietf.org/html/draft-thomson-postel-was-wrong-00\n\nAs a bonus, by not having to deal with sign/verify differences, this\nversion is also somewhat clearer. It also more consistently enforces\ndigest lengths in the verify_recover codepath. The NID_md5_sha1 codepath\nwasn't quite doing this right.\n\nReviewed-by: Kurt Roeckx <kurt@roeckx.be>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n\nGH: #1474\n(cherry picked from commit 608a026494c1e7a14f6d6cfcc5e4994fe2728836)",
        "before_after_code_files": [
          "crypto/rsrsa_err.c||crypto/rsa/rsa_err.c",
          "crypto/rsrsa_sign.c||crypto/rsa/rsa_sign.c",
          "include/openssl/rsa.h||include/openssl/rsa.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "crypto/rsrsa_err.c||crypto/rsa/rsa_err.c": [
          "File: crypto/rsrsa_err.c -> crypto/rsa/rsa_err.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23:     {ERR_FUNC(RSA_F_ENCODE_PKCS1), \"encode_pkcs1\"},",
          "",
          "---------------"
        ],
        "crypto/rsrsa_sign.c||crypto/rsa/rsa_sign.c": [
          "File: crypto/rsrsa_sign.c -> crypto/rsa/rsa_sign.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "31: static int encode_pkcs1(unsigned char **out, int *out_len, int type,",
          "32:                         const unsigned char *m, unsigned int m_len)",
          "36:     ASN1_TYPE parameter;",
          "38:     uint8_t *der = NULL;",
          "39:     int len;",
          "41:     sig.algor = &algor;",
          "42:     sig.algor->algorithm = OBJ_nid2obj(type);",
          "43:     if (sig.algor->algorithm == NULL) {",
          "44:         RSAerr(RSA_F_ENCODE_PKCS1, RSA_R_UNKNOWN_ALGORITHM_TYPE);",
          "45:         return 0;",
          "46:     }",
          "47:     if (OBJ_length(sig.algor->algorithm) == 0) {",
          "48:         RSAerr(RSA_F_ENCODE_PKCS1,",
          "49:                RSA_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD);",
          "50:         return 0;",
          "51:     }",
          "52:     parameter.type = V_ASN1_NULL;",
          "53:     parameter.value.ptr = NULL;",
          "54:     sig.algor->parameter = &parameter;",
          "56:     sig.digest = &digest;",
          "57:     sig.digest->data = (unsigned char *)m;",
          "58:     sig.digest->length = m_len;",
          "60:     len = i2d_X509_SIG(&sig, &der);",
          "61:     if (len < 0)",
          "62:         return 0;",
          "66:     return 1;",
          "67: }",
          "69: int RSA_sign(int type, const unsigned char *m, unsigned int m_len,",
          "70:              unsigned char *sigret, unsigned int *siglen, RSA *rsa)",
          "71: {",
          "72:     int encrypt_len, encoded_len = 0, ret = 0;",
          "73:     unsigned char *tmps = NULL;",
          "74:     const unsigned char *encoded = NULL;",
          "89:             return 0;",
          "91:         encoded_len = SSL_SIG_LENGTH;",
          "92:         encoded = m;",
          "94:         if (!encode_pkcs1(&tmps, &encoded_len, type, m, m_len))",
          "95:             goto err;",
          "96:         encoded = tmps;",
          "99:     if (encoded_len > RSA_size(rsa) - RSA_PKCS1_PADDING_SIZE) {",
          "101:         goto err;",
          "103:     encrypt_len = RSA_private_encrypt(encoded_len, encoded, sigret, rsa,",
          "104:                                       RSA_PKCS1_PADDING);",
          "105:     if (encrypt_len <= 0)",
          "106:         goto err;",
          "109:     ret = 1;",
          "111: err:",
          "112:     OPENSSL_clear_free(tmps, (size_t)encoded_len);",
          "124: int int_rsa_verify(int type, const unsigned char *m, unsigned int m_len,",
          "128:     int decrypt_len, ret = 0, encoded_len = 0;",
          "129:     unsigned char *decrypt_buf = NULL, *encoded = NULL;",
          "131:     if (siglen != (size_t)RSA_size(rsa)) {",
          "133:         return 0;",
          "137:     decrypt_buf = OPENSSL_malloc(siglen);",
          "138:     if (decrypt_buf == NULL) {",
          "143:     decrypt_len = RSA_public_decrypt((int)siglen, sigbuf, decrypt_buf, rsa,",
          "144:                                      RSA_PKCS1_PADDING);",
          "145:     if (decrypt_len <= 0)",
          "148:     if (type == NID_md5_sha1) {",
          "154:         if (decrypt_len != SSL_SIG_LENGTH) {",
          "156:             goto err;",
          "159:         if (rm != NULL) {",
          "160:             memcpy(rm, decrypt_buf, SSL_SIG_LENGTH);",
          "162:         } else {",
          "163:             if (m_len != SSL_SIG_LENGTH) {",
          "164:                 RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_INVALID_MESSAGE_LENGTH);",
          "165:                 goto err;",
          "166:             }",
          "168:             if (memcmp(decrypt_buf, m, SSL_SIG_LENGTH) != 0) {",
          "169:                 RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_BAD_SIGNATURE);",
          "170:                 goto err;",
          "171:             }",
          "173:     } else if (type == NID_mdc2 && decrypt_len == 2 + 16",
          "174:                && decrypt_buf[0] == 0x04 && decrypt_buf[1] == 0x10) {",
          "179:         if (rm != NULL) {",
          "180:             memcpy(rm, decrypt_buf + 2, 16);",
          "182:         } else {",
          "183:             if (m_len != 16) {",
          "184:                 RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_INVALID_MESSAGE_LENGTH);",
          "185:                 goto err;",
          "186:             }",
          "188:             if (memcmp(m, decrypt_buf + 2, 16) != 0) {",
          "189:                 RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_BAD_SIGNATURE);",
          "190:                 goto err;",
          "191:             }",
          "192:         }",
          "193:     } else {",
          "199:         if (rm != NULL) {",
          "200:             const EVP_MD *md = EVP_get_digestbynid(type);",
          "201:             if (md == NULL) {",
          "202:                 RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_UNKNOWN_ALGORITHM_TYPE);",
          "203:                 goto err;",
          "204:             }",
          "206:             m_len = EVP_MD_size(md);",
          "207:             if (m_len > (size_t)decrypt_len) {",
          "208:                 RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_INVALID_DIGEST_LENGTH);",
          "209:                 goto err;",
          "210:             }",
          "211:             m = decrypt_buf + decrypt_len - m_len;",
          "215:         if (!encode_pkcs1(&encoded, &encoded_len, type, m, m_len))",
          "216:             goto err;",
          "218:         if (encoded_len != decrypt_len",
          "219:             || memcmp(encoded, decrypt_buf, encoded_len) != 0) {",
          "220:             RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_BAD_SIGNATURE);",
          "225:         if (rm != NULL) {",
          "226:             memcpy(rm, m, m_len);",
          "228:         }",
          "231:     ret = 1;",
          "233: err:",
          "234:     OPENSSL_clear_free(encoded, (size_t)encoded_len);",
          "235:     OPENSSL_clear_free(decrypt_buf, siglen);",
          "236:     return ret;",
          "239: int RSA_verify(int type, const unsigned char *m, unsigned int m_len,",
          "244:         return rsa->meth->rsa_verify(type, m, m_len, sigbuf, siglen, rsa);",
          "247:     return int_rsa_verify(type, m, m_len, NULL, NULL, sigbuf, siglen, rsa);",
          "",
          "---------------"
        ],
        "include/openssl/rsa.h||include/openssl/rsa.h": [
          "File: include/openssl/rsa.h -> include/openssl/rsa.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "464: # define RSA_F_CHECK_PADDING_MD                           140",
          "465: # define RSA_F_INT_RSA_VERIFY                             145",
          "466: # define RSA_F_OLD_RSA_PRIV_DECODE                        147",
          "467: # define RSA_F_PKEY_RSA_CTRL                              143",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "465: # define RSA_F_ENCODE_PKCS1                               146",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-15924",
  "cve_desc": "An issue was discovered in the Linux kernel before 5.0.11. fm10k_init_module in drivers/net/ethernet/intel/fm10k/fm10k_main.c has a NULL pointer dereference because there is no -ENOMEM upon an alloc_workqueue failure.",
  "repo": "torvalds/linux",
  "patch_hash": "01ca667133d019edc9f0a1f70a272447c84ec41f",
  "patch_info": {
    "commit_hash": "01ca667133d019edc9f0a1f70a272447c84ec41f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/01ca667133d019edc9f0a1f70a272447c84ec41f",
    "files": [
      "drivers/net/ethernet/intel/fm10k/fm10k_main.c"
    ],
    "message": "fm10k: Fix a potential NULL pointer dereference\n\nSyzkaller report this:\n\nkasan: GPF could be caused by NULL-ptr deref or user memory access\ngeneral protection fault: 0000 [#1] SMP KASAN PTI\nCPU: 0 PID: 4378 Comm: syz-executor.0 Tainted: G         C        5.0.0+ #5\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nRIP: 0010:__lock_acquire+0x95b/0x3200 kernel/locking/lockdep.c:3573\nCode: 00 0f 85 28 1e 00 00 48 81 c4 08 01 00 00 5b 5d 41 5c 41 5d 41 5e 41 5f c3 4c 89 ea 48 b8 00 00 00 00 00 fc ff df 48 c1 ea 03 <80> 3c 02 00 0f 85 cc 24 00 00 49 81 7d 00 e0 de 03 a6 41 bc 00 00\nRSP: 0018:ffff8881e3c07a40 EFLAGS: 00010002\nRAX: dffffc0000000000 RBX: 0000000000000000 RCX: 0000000000000000\nRDX: 0000000000000010 RSI: 0000000000000000 RDI: 0000000000000080\nRBP: 0000000000000000 R08: 0000000000000001 R09: 0000000000000000\nR10: ffff8881e3c07d98 R11: ffff8881c7f21f80 R12: 0000000000000001\nR13: 0000000000000080 R14: 0000000000000000 R15: 0000000000000001\nFS:  00007fce2252e700(0000) GS:ffff8881f2400000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007fffc7eb0228 CR3: 00000001e5bea002 CR4: 00000000007606f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nPKRU: 55555554\nCall Trace:\n lock_acquire+0xff/0x2c0 kernel/locking/lockdep.c:4211\n __mutex_lock_common kernel/locking/mutex.c:925 [inline]\n __mutex_lock+0xdf/0x1050 kernel/locking/mutex.c:1072\n drain_workqueue+0x24/0x3f0 kernel/workqueue.c:2934\n destroy_workqueue+0x23/0x630 kernel/workqueue.c:4319\n __do_sys_delete_module kernel/module.c:1018 [inline]\n __se_sys_delete_module kernel/module.c:961 [inline]\n __x64_sys_delete_module+0x30c/0x480 kernel/module.c:961\n do_syscall_64+0x9f/0x450 arch/x86/entry/common.c:290\n entry_SYSCALL_64_after_hwframe+0x49/0xbe\nRIP: 0033:0x462e99\nCode: f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fce2252dc58 EFLAGS: 00000246 ORIG_RAX: 00000000000000b0\nRAX: ffffffffffffffda RBX: 000000000073bf00 RCX: 0000000000462e99\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000020000140\nRBP: 0000000000000002 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 00007fce2252e6bc\nR13: 00000000004bcca9 R14: 00000000006f6b48 R15: 00000000ffffffff\n\nIf alloc_workqueue fails, it should return -ENOMEM, otherwise may\ntrigger this NULL pointer dereference while unloading drivers.\n\nReported-by: Hulk Robot <hulkci@huawei.com>\nFixes: 0a38c17a21a0 (\"fm10k: Remove create_workqueue\")\nSigned-off-by: Yue Haibing <yuehaibing@huawei.com>\nTested-by: Andrew Bowers <andrewx.bowers@intel.com>\nSigned-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>",
    "before_after_code_files": [
      "drivers/net/ethernet/intel/fm10k/fm10k_main.c||drivers/net/ethernet/intel/fm10k/fm10k_main.c"
    ]
  },
  "patch_diff": {
    "drivers/net/ethernet/intel/fm10k/fm10k_main.c||drivers/net/ethernet/intel/fm10k/fm10k_main.c": [
      "File: drivers/net/ethernet/intel/fm10k/fm10k_main.c -> drivers/net/ethernet/intel/fm10k/fm10k_main.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "42:  fm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0,",
      "43:        fm10k_driver_name);",
      "45:  fm10k_dbg_init();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "44:  if (!fm10k_workqueue)",
      "45:   return -ENOMEM;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f1c43590365bac054d753d808dbbd207d09e088d",
      "candidate_info": {
        "commit_hash": "f1c43590365bac054d753d808dbbd207d09e088d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f1c43590365bac054d753d808dbbd207d09e088d",
        "files": [
          "drivers/scsi/qedf/qedf_els.c"
        ],
        "message": "scsi: qedf: Do not retry ELS request if qedf_alloc_cmd fails\n\nIf we cannot allocate an ELS middlepath request, simply fail instead of\ntrying to delay and then reallocate.  This delay logic is causing soft\nlockup messages:\n\nNMI watchdog: BUG: soft lockup - CPU#2 stuck for 22s! [kworker/2:1:7639]\nModules linked in: xt_CHECKSUM ipt_MASQUERADE nf_nat_masquerade_ipv4 tun devlink ip6t_rpfilter ipt_REJECT nf_reject_ipv4 ip6t_REJECT nf_reject_ipv6 xt_conntrack ip_set nfnetlink ebtable_nat ebtable_broute bridge stp llc ip6table_nat nf_conntrack_ipv6 nf_defrag_ipv6 nf_nat_ipv6 ip6table_mangle ip6table_security ip6table_raw iptable_nat nf_conntrack_ipv4 nf_defrag_ipv4 nf_nat_ipv4 nf_nat nf_conntrack iptable_mangle iptable_security iptable_raw ebtable_filter ebtables ip6table_filter ip6_tables iptable_filter dm_service_time vfat fat rpcrdma sunrpc ib_isert iscsi_target_mod ib_iser libiscsi scsi_transport_iscsi ib_srpt target_core_mod ib_srp scsi_transport_srp ib_ipoib rdma_ucm ib_ucm ib_uverbs ib_umad rdma_cm ib_cm iw_cm sb_edac intel_powerclamp coretemp intel_rapl iosf_mbi kvm_intel kvm\nirqbypass crc32_pclmul ghash_clmulni_intel aesni_intel lrw gf128mul glue_helper ablk_helper cryptd iTCO_wdt iTCO_vendor_support qedr(OE) ib_core joydev ipmi_ssif pcspkr hpilo hpwdt sg ipmi_si ipmi_devintf ipmi_msghandler ioatdma shpchp lpc_ich wmi dca acpi_power_meter dm_multipath ip_tables xfs libcrc32c sd_mod crc_t10dif crct10dif_generic qedf(OE) libfcoe mgag200 libfc i2c_algo_bit drm_kms_helper scsi_transport_fc qede(OE) syscopyarea sysfillrect sysimgblt fb_sys_fops ttm qed(OE) drm crct10dif_pclmul e1000e crct10dif_common crc32c_intel scsi_tgt hpsa i2c_core ptp scsi_transport_sas pps_core dm_mirror dm_region_hash dm_log dm_mod\nCPU: 2 PID: 7639 Comm: kworker/2:1 Kdump: loaded Tainted: G           OEL ------------   3.10.0-861.el7.x86_64 #1\nHardware name: HP ProLiant DL580 Gen9/ProLiant DL580 Gen9, BIOS U17 07/21/2016\nWorkqueue: qedf_2_dpc qedf_handle_rrq [qedf]\ntask: ffff959edd628fd0 ti: ffff959ed6f08000 task.ti: ffff959ed6f08000\nRIP: 0010:[<ffffffff8355913a>]  [<ffffffff8355913a>] delay_tsc+0x3a/0x60\nRSP: 0018:ffff959ed6f0bd30  EFLAGS: 00000246\nRAX: 000000008ef5f791 RBX: 5f646d635f666465 RCX: 0000025b8ededa2f\nRDX: 000000000000025b RSI: 0000000000000002 RDI: 0000000000217d1e\nRBP: ffff959ed6f0bd30 R08: ffffffffc079aae8 R09: 0000000000000200\nR10: ffffffffc07952c6 R11: 0000000000000000 R12: 6c6c615f66646571\nR13: ffff959ed6f0bcc8 R14: ffff959ed6f0bd08 R15: ffff959e00000028\nFS:  0000000000000000(0000) GS:ffff959eff480000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f4117fa1eb0 CR3: 0000002039e66000 CR4: 00000000003607e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n[<ffffffff8355907d>] __const_udelay+0x2d/0x30\n[<ffffffffc079444a>] qedf_initiate_els+0x13a/0x450 [qedf]\n[<ffffffffc0794210>] ? qedf_srr_compl+0x2a0/0x2a0 [qedf]\n[<ffffffffc0795337>] qedf_send_rrq+0x127/0x230 [qedf]\n[<ffffffffc078ed55>] qedf_handle_rrq+0x15/0x20 [qedf]\n[<ffffffff832b2dff>] process_one_work+0x17f/0x440\n[<ffffffff832b3ac6>] worker_thread+0x126/0x3c0\n[<ffffffff832b39a0>] ? manage_workers.isra.24+0x2a0/0x2a0\n[<ffffffff832bae31>] kthread+0xd1/0xe0\n[<ffffffff832bad60>] ? insert_kthread_work+0x40/0x40\n[<ffffffff8391f637>] ret_from_fork_nospec_begin+0x21/0x21\n[<ffffffff832bad60>] ? insert_kthread_work+0x40/0x40\n\nSigned-off-by: Chad Dupuis <cdupuis@marvell.com>\nSigned-off-by: Saurav Kashyap <skashyap@marvell.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
        "before_after_code_files": [
          "drivers/scsi/qedf/qedf_els.c||drivers/scsi/qedf/qedf_els.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/scsi/qedf/qedf_els.c||drivers/scsi/qedf/qedf_els.c": [
          "File: drivers/scsi/qedf/qedf_els.c -> drivers/scsi/qedf/qedf_els.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "23:  int rc = 0;",
          "24:  uint32_t did, sid;",
          "25:  uint16_t xid;",
          "28:  struct fcoe_wqe *sqe;",
          "29:  unsigned long flags;",
          "30:  u16 sqe_idx;",
          "",
          "[Removed Lines]",
          "26:  uint32_t start_time = jiffies / HZ;",
          "27:  uint32_t current_time;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "59:   goto els_err;",
          "60:  }",
          "63:  els_req = qedf_alloc_cmd(fcport, QEDF_ELS);",
          "64:  if (!els_req) {",
          "74:  }",
          "76:  QEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS, \"initiate_els els_req = \"",
          "",
          "[Removed Lines]",
          "62: retry_els:",
          "65:   current_time = jiffies / HZ;",
          "66:   if ((current_time - start_time) > 10) {",
          "67:    QEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS,",
          "68:        \"els: Failed els 0x%x\\n\", op);",
          "69:    rc = -ENOMEM;",
          "70:    goto els_err;",
          "71:   }",
          "72:   mdelay(20 * USEC_PER_MSEC);",
          "73:   goto retry_els;",
          "",
          "[Added Lines]",
          "62:   QEDF_INFO(&qedf->dbg_ctx, QEDF_LOG_ELS,",
          "63:      \"Failed to alloc ELS request 0x%x\\n\", op);",
          "64:   rc = -ENOMEM;",
          "65:   goto els_err;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2011fccfb61bbd1d7c8864b2b3ed7012342e9ba3",
      "candidate_info": {
        "commit_hash": "2011fccfb61bbd1d7c8864b2b3ed7012342e9ba3",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2011fccfb61bbd1d7c8864b2b3ed7012342e9ba3",
        "files": [
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf: Support variable offset stack access from helpers\n\nCurrently there is a difference in how verifier checks memory access for\nhelper arguments for PTR_TO_MAP_VALUE and PTR_TO_STACK with regard to\nvariable part of offset.\n\ncheck_map_access, that is used for PTR_TO_MAP_VALUE, can handle variable\noffsets just fine, so that BPF program can call a helper like this:\n\n  some_helper(map_value_ptr + off, size);\n\n, where offset is unknown at load time, but is checked by program to be\nin a safe rage (off >= 0 && off + size < map_value_size).\n\nBut it's not the case for check_stack_boundary, that is used for\nPTR_TO_STACK, and same code with pointer to stack is rejected by\nverifier:\n\n  some_helper(stack_value_ptr + off, size);\n\nFor example:\n  0: (7a) *(u64 *)(r10 -16) = 0\n  1: (7a) *(u64 *)(r10 -8) = 0\n  2: (61) r2 = *(u32 *)(r1 +0)\n  3: (57) r2 &= 4\n  4: (17) r2 -= 16\n  5: (0f) r2 += r10\n  6: (18) r1 = 0xffff888111343a80\n  8: (85) call bpf_map_lookup_elem#1\n  invalid variable stack read R2 var_off=(0xfffffffffffffff0; 0x4)\n\nAdd support for variable offset access to check_stack_boundary so that\nif offset is checked by program to be in a safe range it's accepted by\nverifier.\n\nSigned-off-by: Andrey Ignatov <rdna@fb.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
        "before_after_code_files": [
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2157:     BPF_SIZE(insn->code), BPF_WRITE, -1, true);",
          "2158: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2160: static int __check_stack_boundary(struct bpf_verifier_env *env, u32 regno,",
          "2161:       int off, int access_size,",
          "2162:       bool zero_size_allowed)",
          "2163: {",
          "2164:  struct bpf_reg_state *reg = reg_state(env, regno);",
          "2166:  if (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||",
          "2167:      access_size < 0 || (access_size == 0 && !zero_size_allowed)) {",
          "2168:   if (tnum_is_const(reg->var_off)) {",
          "2169:    verbose(env, \"invalid stack type R%d off=%d access_size=%d\\n\",",
          "2170:     regno, off, access_size);",
          "2171:   } else {",
          "2172:    char tn_buf[48];",
          "2174:    tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "2175:    verbose(env, \"invalid stack type R%d var_off=%s access_size=%d\\n\",",
          "2176:     regno, tn_buf, access_size);",
          "2177:   }",
          "2178:   return -EACCES;",
          "2179:  }",
          "2180:  return 0;",
          "2181: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2169: {",
          "2170:  struct bpf_reg_state *reg = reg_state(env, regno);",
          "2171:  struct bpf_func_state *state = func(env, reg);",
          "2174:  if (reg->type != PTR_TO_STACK) {",
          "",
          "[Removed Lines]",
          "2172:  int off, i, slot, spi;",
          "",
          "[Added Lines]",
          "2195:  int err, min_off, max_off, i, slot, spi;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2183:   return -EACCES;",
          "2184:  }",
          "2201:  }",
          "2203:  if (meta && meta->raw_mode) {",
          "",
          "[Removed Lines]",
          "2187:  if (!tnum_is_const(reg->var_off)) {",
          "2188:   char tn_buf[48];",
          "2190:   tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "2191:   verbose(env, \"invalid variable stack read R%d var_off=%s\\n\",",
          "2192:    regno, tn_buf);",
          "2193:   return -EACCES;",
          "2194:  }",
          "2195:  off = reg->off + reg->var_off.value;",
          "2196:  if (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||",
          "2197:      access_size < 0 || (access_size == 0 && !zero_size_allowed)) {",
          "2198:   verbose(env, \"invalid stack type R%d off=%d access_size=%d\\n\",",
          "2199:    regno, off, access_size);",
          "2200:   return -EACCES;",
          "",
          "[Added Lines]",
          "2209:  if (tnum_is_const(reg->var_off)) {",
          "2210:   min_off = max_off = reg->var_off.value + reg->off;",
          "2211:   err = __check_stack_boundary(env, regno, min_off, access_size,",
          "2212:           zero_size_allowed);",
          "2213:   if (err)",
          "2214:    return err;",
          "2215:  } else {",
          "2216:   min_off = reg->smin_value + reg->off;",
          "2217:   max_off = reg->umax_value + reg->off;",
          "2218:   err = __check_stack_boundary(env, regno, min_off, access_size,",
          "2219:           zero_size_allowed);",
          "2220:   if (err)",
          "2221:    return err;",
          "2222:   err = __check_stack_boundary(env, regno, max_off, access_size,",
          "2223:           zero_size_allowed);",
          "2224:   if (err)",
          "2225:    return err;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2206:   return 0;",
          "2207:  }",
          "2210:   u8 *stype;",
          "2213:   spi = slot / BPF_REG_SIZE;",
          "2214:   if (state->allocated_stack <= slot)",
          "2215:    goto err;",
          "",
          "[Removed Lines]",
          "2209:  for (i = 0; i < access_size; i++) {",
          "2212:   slot = -(off + i) - 1;",
          "",
          "[Added Lines]",
          "2234:  for (i = min_off; i < max_off + access_size; i++) {",
          "2237:   slot = -i - 1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2222:    goto mark;",
          "2223:   }",
          "2224: err:",
          "2227:   return -EACCES;",
          "2228: mark:",
          "",
          "[Removed Lines]",
          "2225:   verbose(env, \"invalid indirect read from stack off %d+%d size %d\\n\",",
          "2226:    off, i, access_size);",
          "",
          "[Added Lines]",
          "2250:   if (tnum_is_const(reg->var_off)) {",
          "2251:    verbose(env, \"invalid indirect read from stack off %d+%d size %d\\n\",",
          "2252:     min_off, i - min_off, access_size);",
          "2253:   } else {",
          "2254:    char tn_buf[48];",
          "2256:    tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "2257:    verbose(env, \"invalid indirect read from stack var_off %s+%d size %d\\n\",",
          "2258:     tn_buf, i - min_off, access_size);",
          "2259:   }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2232:   mark_reg_read(env, &state->stack[spi].spilled_ptr,",
          "2233:          state->stack[spi].spilled_ptr.parent);",
          "2234:  }",
          "2236: }",
          "2238: static int check_helper_mem_access(struct bpf_verifier_env *env, int regno,",
          "",
          "[Removed Lines]",
          "2235:  return update_stack_depth(env, state, off);",
          "",
          "[Added Lines]",
          "2268:  return update_stack_depth(env, state, min_off);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9de2640b06ecf0e6ef4b24b07a5573a2804d77d0",
      "candidate_info": {
        "commit_hash": "9de2640b06ecf0e6ef4b24b07a5573a2804d77d0",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9de2640b06ecf0e6ef4b24b07a5573a2804d77d0",
        "files": [
          "tools/testing/selftests/bpf/test_btf.c"
        ],
        "message": "bpf: add bpffs multi-dimensional array tests in test_btf\n\nFor multiple dimensional arrays like below,\n  int a[2][3]\nboth llvm and pahole generated one BTF_KIND_ARRAY type like\n  . element_type: int\n  . index_type: unsigned int\n  . number of elements: 6\n\nSuch a collapsed BTF_KIND_ARRAY type will cause the divergence\nin BTF vs. the user code. In the compile-once-run-everywhere\nproject, the header file is generated from BTF and used for bpf\nprogram, and the definition in the header file will be different\nfrom what user expects.\n\nBut the kernel actually supports chained multi-dimensional array\ntypes properly. The above \"int a[2][3]\" can be represented as\n  Type #n:\n    . element_type: int\n    . index_type: unsigned int\n    . number of elements: 3\n  Type #(n+1):\n    . element_type: type #n\n    . index_type: unsigned int\n    . number of elements: 2\n\nThe following llvm commit\n  https://reviews.llvm.org/rL357215\nalso enables llvm to generated proper chained multi-dimensional arrays.\n\nThe test_btf already has a raw test (\"struct test #1\") for chained\nmulti-dimensional arrays. This patch added amended bpffs test for\nchained multi-dimensional arrays.\n\nAcked-by: Martin KaFai Lau <kafai@fb.com>\nSigned-off-by: Yonghong Song <yhs@fb.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>",
        "before_after_code_files": [
          "tools/testing/selftests/bpf/test_btf.c||tools/testing/selftests/bpf/test_btf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tools/testing/selftests/bpf/test_btf.c||tools/testing/selftests/bpf/test_btf.c": [
          "File: tools/testing/selftests/bpf/test_btf.c -> tools/testing/selftests/bpf/test_btf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3677:  } aenum;",
          "3678:  uint32_t ui32b;",
          "3679:  uint32_t bits2c:2;",
          "3680: };",
          "3682: #ifdef __SIZEOF_INT128__",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3680:  uint8_t si8_4[2][2];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3729:   BTF_ENUM_ENC(NAME_TBD, 2),",
          "3730:   BTF_ENUM_ENC(NAME_TBD, 3),",
          "",
          "[Removed Lines]",
          "3732:   BTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 10), 40),",
          "",
          "[Added Lines]",
          "3733:   BTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 11), 40),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3743:   BTF_END_RAW,",
          "3744:  },",
          "3746:  .key_size = sizeof(unsigned int),",
          "3747:  .value_size = sizeof(struct pprint_mapv),",
          "",
          "[Removed Lines]",
          "3745:  BTF_STR_SEC(\"\\0unsigned char\\0unsigned short\\0unsigned int\\0int\\0unsigned long long\\0uint8_t\\0uint16_t\\0uint32_t\\0int32_t\\0uint64_t\\0ui64\\0ui8a\\0ENUM_ZERO\\0ENUM_ONE\\0ENUM_TWO\\0ENUM_THREE\\0pprint_mapv\\0ui32\\0ui16\\0si32\\0unused_bits2a\\0bits28\\0unused_bits2b\\0aenum\\0ui32b\\0bits2c\"),",
          "",
          "[Added Lines]",
          "3749:  BTF_STR_SEC(\"\\0unsigned char\\0unsigned short\\0unsigned int\\0int\\0unsigned long long\\0uint8_t\\0uint16_t\\0uint32_t\\0int32_t\\0uint64_t\\0ui64\\0ui8a\\0ENUM_ZERO\\0ENUM_ONE\\0ENUM_TWO\\0ENUM_THREE\\0pprint_mapv\\0ui32\\0ui16\\0si32\\0unused_bits2a\\0bits28\\0unused_bits2b\\0aenum\\0ui32b\\0bits2c\\0si8_4\"),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3791:   BTF_ENUM_ENC(NAME_TBD, 2),",
          "3792:   BTF_ENUM_ENC(NAME_TBD, 3),",
          "",
          "[Removed Lines]",
          "3794:   BTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 1, 10), 40),",
          "",
          "[Added Lines]",
          "3798:   BTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 1, 11), 40),",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3805:   BTF_END_RAW,",
          "3806:  },",
          "3808:  .key_size = sizeof(unsigned int),",
          "3809:  .value_size = sizeof(struct pprint_mapv),",
          "",
          "[Removed Lines]",
          "3807:  BTF_STR_SEC(\"\\0unsigned char\\0unsigned short\\0unsigned int\\0int\\0unsigned long long\\0uint8_t\\0uint16_t\\0uint32_t\\0int32_t\\0uint64_t\\0ui64\\0ui8a\\0ENUM_ZERO\\0ENUM_ONE\\0ENUM_TWO\\0ENUM_THREE\\0pprint_mapv\\0ui32\\0ui16\\0si32\\0unused_bits2a\\0bits28\\0unused_bits2b\\0aenum\\0ui32b\\0bits2c\"),",
          "",
          "[Added Lines]",
          "3814:  BTF_STR_SEC(\"\\0unsigned char\\0unsigned short\\0unsigned int\\0int\\0unsigned long long\\0uint8_t\\0uint16_t\\0uint32_t\\0int32_t\\0uint64_t\\0ui64\\0ui8a\\0ENUM_ZERO\\0ENUM_ONE\\0ENUM_TWO\\0ENUM_THREE\\0pprint_mapv\\0ui32\\0ui16\\0si32\\0unused_bits2a\\0bits28\\0unused_bits2b\\0aenum\\0ui32b\\0bits2c\\0si8_4\"),",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3855:   BTF_ENUM_ENC(NAME_TBD, 2),",
          "3856:   BTF_ENUM_ENC(NAME_TBD, 3),",
          "",
          "[Removed Lines]",
          "3858:   BTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 1, 10), 40),",
          "",
          "[Added Lines]",
          "3865:   BTF_TYPE_ENC(NAME_TBD, BTF_INFO_ENC(BTF_KIND_STRUCT, 1, 11), 40),",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3870:   BTF_TYPEDEF_ENC(NAME_TBD, 18),",
          "3873:   BTF_END_RAW,",
          "3874:  },",
          "3876:  .key_size = sizeof(unsigned int),",
          "3877:  .value_size = sizeof(struct pprint_mapv),",
          "",
          "[Removed Lines]",
          "3875:  BTF_STR_SEC(\"\\0unsigned char\\0unsigned short\\0unsigned int\\0int\\0unsigned long long\\0uint8_t\\0uint16_t\\0uint32_t\\0int32_t\\0uint64_t\\0ui64\\0ui8a\\0ENUM_ZERO\\0ENUM_ONE\\0ENUM_TWO\\0ENUM_THREE\\0pprint_mapv\\0ui32\\0ui16\\0si32\\0unused_bits2a\\0bits28\\0unused_bits2b\\0aenum\\0ui32b\\0bits2c\\0___int\"),",
          "",
          "[Added Lines]",
          "3885:  BTF_STR_SEC(\"\\0unsigned char\\0unsigned short\\0unsigned int\\0int\\0unsigned long long\\0uint8_t\\0uint16_t\\0uint32_t\\0int32_t\\0uint64_t\\0ui64\\0ui8a\\0ENUM_ZERO\\0ENUM_ONE\\0ENUM_TWO\\0ENUM_THREE\\0pprint_mapv\\0ui32\\0ui16\\0si32\\0unused_bits2a\\0bits28\\0unused_bits2b\\0aenum\\0ui32b\\0bits2c\\0___int\\0si8_4\"),",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4007:    v->aenum = i & 0x03;",
          "4008:    v->ui32b = 4;",
          "4009:    v->bits2c = 1;",
          "4010:    v = (void *)v + rounded_value_size;",
          "4011:   }",
          "4012:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4020:    v->si8_4[0][0] = (cpu + i) & 0xff;",
          "4021:    v->si8_4[0][1] = (cpu + i + 1) & 0xff;",
          "4022:    v->si8_4[1][0] = (cpu + i + 2) & 0xff;",
          "4023:    v->si8_4[1][1] = (cpu + i + 3) & 0xff;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "4040:   nexpected_line = snprintf(expected_line, line_size,",
          "4041:        \"%s%u: {%u,0,%d,0x%x,0x%x,0x%x,\"",
          "4042:        \"{%lu|[%u,%u,%u,%u,%u,%u,%u,%u]},%s,\"",
          "4044:        percpu_map ? \"\\tcpu\" : \"\",",
          "4045:        percpu_map ? cpu : next_key,",
          "4046:        v->ui32, v->si32,",
          "",
          "[Removed Lines]",
          "4043:        \"%u,0x%x}\\n\",",
          "",
          "[Added Lines]",
          "4057:        \"%u,0x%x,[[%d,%d],[%d,%d]]}\\n\",",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "4054:        v->ui8a[6], v->ui8a[7],",
          "4055:        pprint_enum_str[v->aenum],",
          "4056:        v->ui32b,",
          "4058:  }",
          "4060: #ifdef __SIZEOF_INT128__",
          "",
          "[Removed Lines]",
          "4057:        v->bits2c);",
          "",
          "[Added Lines]",
          "4071:        v->bits2c,",
          "4072:        v->si8_4[0][0], v->si8_4[0][1],",
          "4073:        v->si8_4[1][0], v->si8_4[1][1]);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a3eec13b8fd2b9791a21fa16e38dfea8111579bf",
      "candidate_info": {
        "commit_hash": "a3eec13b8fd2b9791a21fa16e38dfea8111579bf",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/a3eec13b8fd2b9791a21fa16e38dfea8111579bf",
        "files": [
          "arch/arm64/boot/dts/rockchip/rk3399.dtsi"
        ],
        "message": "arm64: dts: rockchip: Disable DCMDs on RK3399's eMMC controller.\n\nWhen using direct commands (DCMDs) on an RK3399, we get spurious\nCQE completion interrupts for the DCMD transaction slot (#31):\n\n[  931.196520] ------------[ cut here ]------------\n[  931.201702] mmc1: cqhci: spurious TCN for tag 31\n[  931.206906] WARNING: CPU: 0 PID: 1433 at /usr/src/kernel/drivers/mmc/host/cqhci.c:725 cqhci_irq+0x2e4/0x490\n[  931.206909] Modules linked in:\n[  931.206918] CPU: 0 PID: 1433 Comm: irq/29-mmc1 Not tainted 4.19.8-rt6-funkadelic #1\n[  931.206920] Hardware name: Theobroma Systems RK3399-Q7 SoM (DT)\n[  931.206924] pstate: 40000005 (nZcv daif -PAN -UAO)\n[  931.206927] pc : cqhci_irq+0x2e4/0x490\n[  931.206931] lr : cqhci_irq+0x2e4/0x490\n[  931.206933] sp : ffff00000e54bc80\n[  931.206934] x29: ffff00000e54bc80 x28: 0000000000000000\n[  931.206939] x27: 0000000000000001 x26: ffff000008f217e8\n[  931.206944] x25: ffff8000f02ef030 x24: ffff0000091417b0\n[  931.206948] x23: ffff0000090aa000 x22: ffff8000f008b000\n[  931.206953] x21: 0000000000000002 x20: 000000000000001f\n[  931.206957] x19: ffff8000f02ef018 x18: ffffffffffffffff\n[  931.206961] x17: 0000000000000000 x16: 0000000000000000\n[  931.206966] x15: ffff0000090aa6c8 x14: 0720072007200720\n[  931.206970] x13: 0720072007200720 x12: 0720072007200720\n[  931.206975] x11: 0720072007200720 x10: 0720072007200720\n[  931.206980] x9 : 0720072007200720 x8 : 0720072007200720\n[  931.206984] x7 : 0720073107330720 x6 : 00000000000005a0\n[  931.206988] x5 : ffff00000860d4b0 x4 : 0000000000000000\n[  931.206993] x3 : 0000000000000001 x2 : 0000000000000001\n[  931.206997] x1 : 1bde3a91b0d4d900 x0 : 0000000000000000\n[  931.207001] Call trace:\n[  931.207005]  cqhci_irq+0x2e4/0x490\n[  931.207009]  sdhci_arasan_cqhci_irq+0x5c/0x90\n[  931.207013]  sdhci_irq+0x98/0x930\n[  931.207019]  irq_forced_thread_fn+0x2c/0xa0\n[  931.207023]  irq_thread+0x114/0x1c0\n[  931.207027]  kthread+0x128/0x130\n[  931.207032]  ret_from_fork+0x10/0x20\n[  931.207035] ---[ end trace 0000000000000002 ]---\n\nThe driver shows this message only for the first spurious interrupt\nby using WARN_ONCE(). Changing this to WARN() shows, that this is\nhappening quite frequently (up to once a second).\n\nSince the eMMC 5.1 specification, where CQE and CQHCI are specified,\ndoes not mention that spurious TCN interrupts for DCMDs can be simply\nignored, we must assume that using this feature is not working reliably.\n\nThe current implementation uses DCMD for REQ_OP_FLUSH only, and\nI could not see any performance/power impact when disabling\nthis optional feature for RK3399.\n\nTherefore this patch disables DCMDs for RK3399.\n\nSigned-off-by: Christoph Muellner <christoph.muellner@theobroma-systems.com>\nSigned-off-by: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>\nFixes: 84362d79f436 (\"mmc: sdhci-of-arasan: Add CQHCI support for arasan,sdhci-5.1\")\nCc: stable@vger.kernel.org\n[the corresponding code changes are queued for 5.2 so doing that as well]\nSigned-off-by: Heiko Stuebner <heiko@sntech.de>",
        "before_after_code_files": [
          "arch/arm64/boot/dts/rockchip/rk3399.dtsi||arch/arm64/boot/dts/rockchip/rk3399.dtsi"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/arm64/boot/dts/rockchip/rk3399.dtsi||arch/arm64/boot/dts/rockchip/rk3399.dtsi": [
          "File: arch/arm64/boot/dts/rockchip/rk3399.dtsi -> arch/arm64/boot/dts/rockchip/rk3399.dtsi",
          "--- Hunk 1 ---",
          "[Context before]",
          "339:   phys = <&emmc_phy>;",
          "340:   phy-names = \"phy_arasan\";",
          "341:   power-domains = <&power RK3399_PD_EMMC>;",
          "342:   status = \"disabled\";",
          "343:  };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "342:   disable-cqe-dcmd;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8f71370f4b02730e8c27faf460af7a3586e24e1f",
      "candidate_info": {
        "commit_hash": "8f71370f4b02730e8c27faf460af7a3586e24e1f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8f71370f4b02730e8c27faf460af7a3586e24e1f",
        "files": [
          "sound/soc/intel/atom/sst-mfld-platform-pcm.c"
        ],
        "message": "ASoC: intel: Fix crash at suspend/resume after failed codec registration\n\nIf codec registration fails after the ASoC Intel SST driver has been probed,\nthe kernel will Oops and crash at suspend/resume.\n\ngeneral protection fault: 0000 [#1] PREEMPT SMP KASAN PTI\nCPU: 1 PID: 2811 Comm: cat Tainted: G        W         4.19.30 #15\nHardware name: GOOGLE Clapper, BIOS Google_Clapper.5216.199.7 08/22/2014\nRIP: 0010:snd_soc_suspend+0x5a/0xd21\nCode: 03 80 3c 10 00 49 89 d7 74 0b 48 89 df e8 71 72 c4 fe 4c 89\nfa 48 8b 03 48 89 45 d0 48 8d 98 a0 01 00 00 48 89 d8 48 c1 e8 03\n<8a> 04 10 84 c0 0f 85 85 0c 00 00 80 3b 00 0f 84 6b 0c 00 00 48 8b\nRSP: 0018:ffff888035407750 EFLAGS: 00010202\nRAX: 0000000000000034 RBX: 00000000000001a0 RCX: 0000000000000000\nRDX: dffffc0000000000 RSI: 0000000000000008 RDI: ffff88805c417098\nRBP: ffff8880354077b0 R08: dffffc0000000000 R09: ffffed100b975718\nR10: 0000000000000001 R11: ffffffff949ea4a3 R12: 1ffff1100b975746\nR13: dffffc0000000000 R14: ffff88805cba4588 R15: dffffc0000000000\nFS:  0000794a78e91b80(0000) GS:ffff888068d00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007bd5283ccf58 CR3: 000000004b7aa000 CR4: 00000000001006e0\nCall Trace:\n? dpm_complete+0x67b/0x67b\n? i915_gem_suspend+0x14d/0x1ad\nsst_soc_prepare+0x91/0x1dd\n? sst_be_hw_params+0x7e/0x7e\ndpm_prepare+0x39a/0x88b\ndpm_suspend_start+0x13/0x9d\nsuspend_devices_and_enter+0x18f/0xbd7\n? arch_suspend_enable_irqs+0x11/0x11\n? printk+0xd9/0x12d\n? lock_release+0x95f/0x95f\n? log_buf_vmcoreinfo_setup+0x131/0x131\n? rcu_read_lock_sched_held+0x140/0x22a\n? __bpf_trace_rcu_utilization+0xa/0xa\n? __pm_pr_dbg+0x186/0x190\n? pm_notifier_call_chain+0x39/0x39\n? suspend_test+0x9d/0x9d\npm_suspend+0x2f4/0x728\n? trace_suspend_resume+0x3da/0x3da\n? lock_release+0x95f/0x95f\n? kernfs_fop_write+0x19f/0x32d\nstate_store+0xd8/0x147\n? sysfs_kf_read+0x155/0x155\nkernfs_fop_write+0x23e/0x32d\n__vfs_write+0x108/0x608\n? vfs_read+0x2e9/0x2e9\n? rcu_read_lock_sched_held+0x140/0x22a\n? __bpf_trace_rcu_utilization+0xa/0xa\n? debug_smp_processor_id+0x10/0x10\n? selinux_file_permission+0x1c5/0x3c8\n? rcu_sync_lockdep_assert+0x6a/0xad\n? __sb_start_write+0x129/0x2ac\nvfs_write+0x1aa/0x434\nksys_write+0xfe/0x1be\n? __ia32_sys_read+0x82/0x82\ndo_syscall_64+0xcd/0x120\nentry_SYSCALL_64_after_hwframe+0x49/0xbe\n\nIn the observed situation, the problem is seen because the codec driver\nfailed to probe due to a hardware problem.\n\nmax98090 i2c-193C9890:00: Failed to read device revision: -1\nmax98090 i2c-193C9890:00: ASoC: failed to probe component -1\ncht-bsw-max98090 cht-bsw-max98090: ASoC: failed to instantiate card -1\ncht-bsw-max98090 cht-bsw-max98090: snd_soc_register_card failed -1\ncht-bsw-max98090: probe of cht-bsw-max98090 failed with error -1\n\nThe problem is similar to the problem solved with commit 2fc995a87f2e\n(\"ASoC: intel: Fix crash at suspend/resume without card registration\"),\nbut codec registration fails at a later point. At that time, the pointer\nchecked with the above mentioned commit is already set, but it is not\ncleared if the device is subsequently removed. Adding a remove function\nto clear the pointer fixes the problem.\n\nCc: stable@vger.kernel.org\nCc: Jarkko Nikula <jarkko.nikula@linux.intel.com>\nCc: Curtis Malainey <cujomalainey@chromium.org>\nSigned-off-by: Guenter Roeck <linux@roeck-us.net>\nAcked-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>\nSigned-off-by: Mark Brown <broonie@kernel.org>",
        "before_after_code_files": [
          "sound/soc/intel/atom/sst-mfld-platform-pcm.c||sound/soc/intel/atom/sst-mfld-platform-pcm.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "sound/soc/intel/atom/sst-mfld-platform-pcm.c||sound/soc/intel/atom/sst-mfld-platform-pcm.c": [
          "File: sound/soc/intel/atom/sst-mfld-platform-pcm.c -> sound/soc/intel/atom/sst-mfld-platform-pcm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "706:  return sst_dsp_init_v2_dpcm(component);",
          "707: }",
          "709: static const struct snd_soc_component_driver sst_soc_platform_drv  = {",
          "710:  .name  = DRV_NAME,",
          "711:  .probe  = sst_soc_probe,",
          "712:  .ops  = &sst_platform_ops,",
          "713:  .compr_ops = &sst_platform_compr_ops,",
          "714:  .pcm_new = sst_pcm_new,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "709: static void sst_soc_remove(struct snd_soc_component *component)",
          "710: {",
          "711:  struct sst_data *drv = dev_get_drvdata(component->dev);",
          "713:  drv->soc_card = NULL;",
          "714: }",
          "719:  .remove  = sst_soc_remove,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-4077",
  "cve_desc": "epan/reassemble.c in TShark in Wireshark 2.0.x before 2.0.3 relies on incorrect special-case handling of truncated Tvb data structures, which allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted packet.",
  "repo": "wireshark/wireshark",
  "patch_hash": "c5b2c1e8f40cee913bd70fcc00284483b3c92fcd",
  "patch_info": {
    "commit_hash": "c5b2c1e8f40cee913bd70fcc00284483b3c92fcd",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/c5b2c1e8f40cee913bd70fcc00284483b3c92fcd",
    "files": [
      "epan/reassemble.c",
      "epan/reassemble.h",
      "epan/reassemble_test.c"
    ],
    "message": "reassemble: remove special treatment for truncated data\n\nDo not try to recover from truncated tvbs for fragment_add_seq-like\nfunctions:\n\n - If it is the first block and the dissector requested frag_data_len\n   number of bytes, we should not lie and pretend that we are fully\n   reassembled.\n - For other blocks, returning NULL as no reassembly was possible makes\n   sense. But other fragments in the list should not be cleared as there\n   may be partial fragments which were returned before.\n\nIt seems that this special behavior was introduced in\nb2c11b5e13248b1c98ee5104eab411e842911e19 (freeing fragments and\nreturning NULL as an optimization when fragments are deemed not needed\nanymore) and faeb2c2ee16e61e54c880163e98d6528dd0c5619 (for returning\nfd_head for the first fragment, \"so the first fragment gets dissected as\nfragmented packet\").\n\nNow in theory unused fragments could stick around, but that also\npossible with the normal fragment_add functions.\n\nBug: 11799\nChange-Id: I20829c54e1b2eee25a91fe4de51b19b1458c7789\nReviewed-on: https://code.wireshark.org/review/14082\nPetri-Dish: Peter Wu <peter@lekensteyn.nl>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Peter Wu <peter@lekensteyn.nl>\nReviewed-by: Michael Mann <mmann78@netscape.net>",
    "before_after_code_files": [
      "epan/reassemble.c||epan/reassemble.c",
      "epan/reassemble.h||epan/reassemble.h",
      "epan/reassemble_test.c||epan/reassemble_test.c"
    ]
  },
  "patch_diff": {
    "epan/reassemble.c||epan/reassemble.c": [
      "File: epan/reassemble.c -> epan/reassemble.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1894:   }",
      "1895:  }",
      "1931:  if (fragment_add_seq_work(fd_head, tvb, offset, pinfo,",
      "1932:       frag_number, frag_data_len, more_frags)) {",
      "",
      "[Removed Lines]",
      "1911:  if ((flags & REASSEMBLE_FLAGS_CHECK_DATA_PRESENT) &&",
      "1912:   !tvb_bytes_exist(tvb, offset, frag_data_len)) {",
      "1913:   fd_head -> flags |= FD_DATA_NOT_PRESENT;",
      "1914:   if (frag_number == 0) {",
      "1915:    return fd_head;",
      "1916:   }",
      "1917:   else {",
      "1918:    if (!more_frags) {",
      "1924:     fragment_unhash(table, *orig_keyp);",
      "1925:     free_all_fragments(NULL, fd_head, NULL);",
      "1926:    }",
      "1927:    return NULL;",
      "1928:   }",
      "1929:  }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2012:  fd_head = fragment_add_seq_common(table, tvb, offset, pinfo, id, data,",
      "2013:        frag_number, frag_data_len,",
      "2014:        more_frags,",
      "2016:        &orig_key);",
      "2017:  if (fd_head) {",
      "",
      "[Removed Lines]",
      "2015:        flags|REASSEMBLE_FLAGS_CHECK_DATA_PRESENT,",
      "2018:   if(fd_head->flags & FD_DATA_NOT_PRESENT) {",
      "2022:    return fd_head;",
      "2023:   }",
      "",
      "[Added Lines]",
      "1981:        flags,",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2139:  fd_head = lookup_fd_head(table, pinfo, id, data, &orig_key);",
      "2141:  if (fd_head) {",
      "2147:   fd_head->datalen = fd_head->offset;",
      "2148:   fd_head->flags |= FD_DATALEN_SET;",
      "",
      "[Removed Lines]",
      "2142:   if (fd_head->flags & FD_DATA_NOT_PRESENT) {",
      "2144:    return NULL;",
      "2145:   }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "epan/reassemble.h||epan/reassemble.h": [
      "File: epan/reassemble.h -> epan/reassemble.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "56: #define FD_BLOCKSEQUENCE        0x0100",
      "",
      "[Removed Lines]",
      "63: #define FD_DATA_NOT_PRESENT 0x0200",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "118: #define REASSEMBLE_FLAGS_802_11_HACK  0x0002",
      "",
      "[Removed Lines]",
      "122: #define REASSEMBLE_FLAGS_CHECK_DATA_PRESENT 0x0004",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "epan/reassemble_test.c||epan/reassemble_test.c": [
      "File: epan/reassemble_test.c -> epan/reassemble_test.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "110:     {FD_DATALEN_SET          ,\"DS\"},",
      "111:     {FD_SUBSET_TVB,          ,\"ST\"},",
      "112:     {FD_BLOCKSEQUENCE        ,\"BS\"},",
      "114:     {FD_PARTIAL_REASSEMBLY   ,\"PR\"},",
      "115:     {FD_OVERLAP              ,\"OL\"},",
      "116:     {FD_OVERLAPCONFLICT      ,\"OC\"},",
      "",
      "[Removed Lines]",
      "113:     {FD_DATA_NOT_PRESENT     ,\"NP\"},",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1341: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1343: #if 0",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1513:     ASSERT_EQ(NULL,fd_head->tvb_data);",
      "1514:     ASSERT_EQ(NULL,fd_head->next);",
      "1515: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1518: #endif",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1539:         test_fragment_add_seq_802_11_0,",
      "1540:         test_fragment_add_seq_802_11_1,",
      "1541:         test_simple_fragment_add_seq_next,",
      "1542:         test_missing_data_fragment_add_seq_next,",
      "1543:         test_missing_data_fragment_add_seq_next_2,",
      "1544:         test_missing_data_fragment_add_seq_next_3,",
      "1545: #if 0",
      "1546:         test_fragment_add_seq_check_multiple",
      "1547: #endif",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1545: #if 0",
      "1549: #endif",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c2f85b6925365365926d3654e01dc53a95c80d37",
      "candidate_info": {
        "commit_hash": "c2f85b6925365365926d3654e01dc53a95c80d37",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/c2f85b6925365365926d3654e01dc53a95c80d37",
        "files": [
          "docbook/wsdg_src/WSDG_chapter_dissection.asciidoc",
          "epan/reassemble.c",
          "epan/reassemble.h"
        ],
        "message": "Extend reassembly documentation\n\nDocumentation changes only (comments and docbook).\n\nUpdate WSDG with the fragment_add_seq_check API that was introduced in\nWireshark 1.10.\n\nFix typos and clarify the many functions we have for adding reassembling\nfragments.\n\nChange-Id: I38715a8f58e9cf1fe3e34ee4b1a4ae339630282b\nReviewed-on: https://code.wireshark.org/review/14066\nPetri-Dish: Peter Wu <peter@lekensteyn.nl>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Anders Broman <a.broman58@gmail.com>",
        "before_after_code_files": [
          "docbook/wsdg_src/WSDG_chapter_dissection.asciidoc||docbook/wsdg_src/WSDG_chapter_dissection.asciidoc",
          "epan/reassemble.c||epan/reassemble.c",
          "epan/reassemble.h||epan/reassemble.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/reassemble.c||epan/reassemble.c",
            "epan/reassemble.h||epan/reassemble.h"
          ],
          "candidate": [
            "epan/reassemble.c||epan/reassemble.c",
            "epan/reassemble.h||epan/reassemble.h"
          ]
        }
      },
      "candidate_diff": {
        "docbook/wsdg_src/WSDG_chapter_dissection.asciidoc||docbook/wsdg_src/WSDG_chapter_dissection.asciidoc": [
          "File: docbook/wsdg_src/WSDG_chapter_dissection.asciidoc -> docbook/wsdg_src/WSDG_chapter_dissection.asciidoc",
          "--- Hunk 1 ---",
          "[Context before]",
          "653: To dissect these packets you need to wait until all the parts have",
          "654: arrived and then start the dissection.",
          "656: [[ChDissectReassembleUdp]]",
          "658: ==== How to reassemble split UDP packets",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "656: The following sections will guide you through two common cases. For a",
          "657: description of all possible functions, structures and parameters, see",
          "658: 'epan/reassemble.h'.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "699:     guint16 msg_num = tvb_get_ntohs(tvb, offset); offset += 2;",
          "701:     pinfo->fragmented = TRUE;",
          "",
          "[Removed Lines]",
          "702:     frag_msg = fragment_add_seq_check(tvb, offset, pinfo,",
          "",
          "[Added Lines]",
          "706:     frag_msg = fragment_add_seq_check(msg_reassembly_table,",
          "707:         tvb, offset, pinfo,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "713: later. Next comes some protocol specific stuff, to dig the fragment data out of",
          "714: the stream if it's present. Having decided it is present, we let the function",
          "715: +fragment_add_seq_check()+ do its work. We need to provide this with a certain",
          "",
          "[Removed Lines]",
          "716: amount of data.",
          "",
          "[Added Lines]",
          "719: amount of parameters:",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "725:   fragments in flight, and this is used to key the relevant one to be used for",
          "726:   reassembly.",
          "",
          "[Removed Lines]",
          "729:   to declare. We'll consider these in detail later.",
          "",
          "[Added Lines]",
          "734:   (as is done in the example) for most dissectors.",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "781: .Reassembling fragments - Initialisation",
          "782: ====",
          "783: ----",
          "787: static void",
          "788: msg_init_protocol(void)",
          "789: {",
          "792: }",
          "793: ----",
          "794: ====",
          "804: .Reassembling fragments - Data",
          "805: ====",
          "",
          "[Removed Lines]",
          "784: static GHashTable *msg_fragment_table = NULL;",
          "785: static GHashTable *msg_reassembled_table = NULL;",
          "790:     fragment_table_init(&msg_fragment_table);",
          "791:     reassembled_table_init(&msg_reassembled_table);",
          "796: First a couple of hash tables are declared, and these are initialised in the",
          "797: protocol initialisation routine. Following that, a +fragment_items+ structure is",
          "798: allocated and filled in with a series of ett items, hf data items, and a string",
          "799: tag. The ett and hf values should be included in the relevant tables like all",
          "800: the other variables your protocol may use. The hf variables need to be placed in",
          "801: the structure something like the following. Of course the names may need to be",
          "802: adjusted.",
          "",
          "[Added Lines]",
          "789: static reassembly_table reassembly_table;",
          "794:     reassembly_table_init(&msg_reassemble_table,",
          "795:         &addresses_ports_reassembly_table_functions);",
          "800: First a +reassembly_table+ structure is declared and initialised in the protocol",
          "801: initialisation routine. The second parameter specifies the functions that should",
          "802: be used for identifying fragments. We will use",
          "803: +addresses_ports_reassembly_table_functions+ in order to identify fragments by",
          "804: the given sequence number (+msg_seqid+), the source and destination addresses",
          "805: and ports from the packet.",
          "807: Following that, a +fragment_items+ structure is allocated and filled in with a",
          "808: series of ett items, hf data items, and a string tag. The ett and hf values",
          "809: should be included in the relevant tables like all the other variables your",
          "810: protocol may use. The hf variables need to be placed in the structure something",
          "811: like the following. Of course the names may need to be adjusted.",
          "",
          "---------------"
        ],
        "epan/reassemble.c||epan/reassemble.c": [
          "File: epan/reassemble.c -> epan/reassemble.c"
        ],
        "epan/reassemble.h||epan/reassemble.h": [
          "File: epan/reassemble.h -> epan/reassemble.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "84:  guint32 reassembled_in;   /**< frame where this PDU was reassembled,",
          "85:            only valid in the first item of the list",
          "",
          "[Removed Lines]",
          "80:  guint32 datalen;    /**< Only valid in first item of list and when",
          "",
          "[Added Lines]",
          "80:  guint32 datalen;    /**< When flags&FD_BLOCKSEQUENCE is set, the",
          "81:            index of the last block (segments in",
          "82:            datagram + 1); otherwise the number of",
          "83:            bytes of the full datagram. Only valid in",
          "84:            the first item of the fragments list when",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ca2c9c868b9390ca09b008c885bc37de284e9eb9",
      "candidate_info": {
        "commit_hash": "ca2c9c868b9390ca09b008c885bc37de284e9eb9",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/ca2c9c868b9390ca09b008c885bc37de284e9eb9",
        "files": [
          "epan/reassemble.c",
          "epan/reassemble.h",
          "epan/reassemble_test.c"
        ],
        "message": "reassemble: remove special treatment for truncated data\n\nDo not try to recover from truncated tvbs for fragment_add_seq-like\nfunctions:\n\n - If it is the first block and the dissector requested frag_data_len\n   number of bytes, we should not lie and pretend that we are fully\n   reassembled.\n - For other blocks, returning NULL as no reassembly was possible makes\n   sense. But other fragments in the list should not be cleared as there\n   may be partial fragments which were returned before.\n\nIt seems that this special behavior was introduced in\nb2c11b5e13248b1c98ee5104eab411e842911e19 (freeing fragments and\nreturning NULL as an optimization when fragments are deemed not needed\nanymore) and faeb2c2ee16e61e54c880163e98d6528dd0c5619 (for returning\nfd_head for the first fragment, \"so the first fragment gets dissected as\nfragmented packet\").\n\nNow in theory unused fragments could stick around, but that also\npossible with the normal fragment_add functions.\n\nBug: 11799\nChange-Id: I20829c54e1b2eee25a91fe4de51b19b1458c7789\nReviewed-on: https://code.wireshark.org/review/14082\nPetri-Dish: Peter Wu <peter@lekensteyn.nl>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Peter Wu <peter@lekensteyn.nl>\nReviewed-by: Michael Mann <mmann78@netscape.net>\n(cherry picked from commit c5b2c1e8f40cee913bd70fcc00284483b3c92fcd)\nReviewed-on: https://code.wireshark.org/review/14923",
        "before_after_code_files": [
          "epan/reassemble.c||epan/reassemble.c",
          "epan/reassemble.h||epan/reassemble.h",
          "epan/reassemble_test.c||epan/reassemble_test.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/reassemble.c||epan/reassemble.c",
            "epan/reassemble.h||epan/reassemble.h",
            "epan/reassemble_test.c||epan/reassemble_test.c"
          ],
          "candidate": [
            "epan/reassemble.c||epan/reassemble.c",
            "epan/reassemble.h||epan/reassemble.h",
            "epan/reassemble_test.c||epan/reassemble_test.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/reassemble.c||epan/reassemble.c": [
          "File: epan/reassemble.c -> epan/reassemble.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1886:   }",
          "1887:  }",
          "1923:  if (fragment_add_seq_work(fd_head, tvb, offset, pinfo,",
          "1924:       frag_number, frag_data_len, more_frags)) {",
          "",
          "[Removed Lines]",
          "1903:  if ((flags & REASSEMBLE_FLAGS_CHECK_DATA_PRESENT) &&",
          "1904:   !tvb_bytes_exist(tvb, offset, frag_data_len)) {",
          "1905:   fd_head -> flags |= FD_DATA_NOT_PRESENT;",
          "1906:   if (frag_number == 0) {",
          "1907:    return fd_head;",
          "1908:   }",
          "1909:   else {",
          "1910:    if (!more_frags) {",
          "1916:     fragment_unhash(table, *orig_keyp);",
          "1917:     free_all_fragments(NULL, fd_head, NULL);",
          "1918:    }",
          "1919:    return NULL;",
          "1920:   }",
          "1921:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2004:  fd_head = fragment_add_seq_common(table, tvb, offset, pinfo, id, data,",
          "2005:        frag_number, frag_data_len,",
          "2006:        more_frags,",
          "2008:        &orig_key);",
          "2009:  if (fd_head) {",
          "",
          "[Removed Lines]",
          "2007:        flags|REASSEMBLE_FLAGS_CHECK_DATA_PRESENT,",
          "2010:   if(fd_head->flags & FD_DATA_NOT_PRESENT) {",
          "2014:    return fd_head;",
          "2015:   }",
          "",
          "[Added Lines]",
          "1973:        flags,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2131:  fd_head = lookup_fd_head(table, pinfo, id, data, &orig_key);",
          "2133:  if (fd_head) {",
          "2139:   fd_head->datalen = fd_head->offset;",
          "2140:   fd_head->flags |= FD_DATALEN_SET;",
          "",
          "[Removed Lines]",
          "2134:   if (fd_head->flags & FD_DATA_NOT_PRESENT) {",
          "2136:    return NULL;",
          "2137:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "epan/reassemble.h||epan/reassemble.h": [
          "File: epan/reassemble.h -> epan/reassemble.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "56: #define FD_BLOCKSEQUENCE        0x0100",
          "",
          "[Removed Lines]",
          "63: #define FD_DATA_NOT_PRESENT 0x0200",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "118: #define REASSEMBLE_FLAGS_802_11_HACK  0x0002",
          "",
          "[Removed Lines]",
          "122: #define REASSEMBLE_FLAGS_CHECK_DATA_PRESENT 0x0004",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "epan/reassemble_test.c||epan/reassemble_test.c": [
          "File: epan/reassemble_test.c -> epan/reassemble_test.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "110:     {FD_DATALEN_SET          ,\"DS\"},",
          "111:     {FD_SUBSET_TVB,          ,\"ST\"},",
          "112:     {FD_BLOCKSEQUENCE        ,\"BS\"},",
          "114:     {FD_PARTIAL_REASSEMBLY   ,\"PR\"},",
          "115:     {FD_OVERLAP              ,\"OL\"},",
          "116:     {FD_OVERLAPCONFLICT      ,\"OC\"},",
          "",
          "[Removed Lines]",
          "113:     {FD_DATA_NOT_PRESENT     ,\"NP\"},",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1341: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1343: #if 0",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1513:     ASSERT_EQ(NULL,fd_head->tvb_data);",
          "1514:     ASSERT_EQ(NULL,fd_head->next);",
          "1515: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1518: #endif",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1539:         test_fragment_add_seq_802_11_0,",
          "1540:         test_fragment_add_seq_802_11_1,",
          "1541:         test_simple_fragment_add_seq_next,",
          "1542:         test_missing_data_fragment_add_seq_next,",
          "1543:         test_missing_data_fragment_add_seq_next_2,",
          "1544:         test_missing_data_fragment_add_seq_next_3,",
          "1545: #if 0",
          "1546:         test_fragment_add_seq_check_multiple",
          "1547: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1545: #if 0",
          "1549: #endif",
          "",
          "---------------"
        ]
      }
    }
  ]
}
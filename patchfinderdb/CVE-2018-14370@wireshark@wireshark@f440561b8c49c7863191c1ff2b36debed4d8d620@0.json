{
  "cve_id": "CVE-2018-14370",
  "cve_desc": "In Wireshark 2.6.0 to 2.6.1 and 2.4.0 to 2.4.7, the IEEE 802.11 protocol dissector could crash. This was addressed in epan/crypt/airpdcap.c via bounds checking that prevents a buffer over-read.",
  "repo": "wireshark/wireshark",
  "patch_hash": "f440561b8c49c7863191c1ff2b36debed4d8d620",
  "patch_info": {
    "commit_hash": "f440561b8c49c7863191c1ff2b36debed4d8d620",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/f440561b8c49c7863191c1ff2b36debed4d8d620",
    "files": [
      "epan/crypt/dot11decrypt.c"
    ],
    "message": "dot11crypt: add bounds check for TDLS elements\n\nFixes a buffer overrun (read) of at most 255 bytes which could occur\nwhile processing FTE in Dot11DecryptTDLSDeriveKey.\n\nWhile at it, according to 802.11-2016 9.4.1.9, \"A status code of\nSUCCESS_POWER_SAVE_MODE also indicates a successful operation.\". No idea\nwhen it makes a difference, but let's implement it too.\n\nBug: 14686\nChange-Id: Ia7a41cd965704a4d51fb5a4dc4d01885fc17375c\nFixes: v2.1.0rc0-1825-g6991149557 (\"[airpdcap] Add support to decrypt TDLS traffic\")\nLink: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=8189\nReviewed-on: https://code.wireshark.org/review/27618\nPetri-Dish: Peter Wu <peter@lekensteyn.nl>\nTested-by: Petri Dish Buildbot\nReviewed-by: Anders Broman <a.broman58@gmail.com>",
    "before_after_code_files": [
      "epan/crypt/dot11decrypt.c||epan/crypt/dot11decrypt.c"
    ]
  },
  "patch_diff": {
    "epan/crypt/dot11decrypt.c||epan/crypt/dot11decrypt.c": [
      "File: epan/crypt/dot11decrypt.c -> epan/crypt/dot11decrypt.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "529: #endif",
      "530:     DOT11DECRYPT_DEBUG_TRACE_START(\"Dot11DecryptScanForKeys\");",
      "533:     offset = mac_header_len;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "534:     DISSECTOR_ASSERT(tot_len >= mac_header_len + DOT11DECRYPT_CRYPTED_DATA_MINLEN);",
      "535:     DISSECTOR_ASSERT(tot_len <= DOT11DECRYPT_MAX_CAPLEN);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "642:             DOT11DECRYPT_DEBUG_PRINT_LINE(\"Dot11DecryptScanForKeys\", \"Not Response nor confirm\", DOT11DECRYPT_DEBUG_LEVEL_3);",
      "643:             return DOT11DECRYPT_RET_NO_VALID_HANDSHAKE;",
      "644:         }",
      "647:         offset++;",
      "648:         status=pntoh16(data+offset);",
      "650:             DOT11DECRYPT_DEBUG_PRINT_LINE(\"Dot11DecryptScanForKeys\", \"TDLS setup not successfull\", DOT11DECRYPT_DEBUG_LEVEL_3);",
      "651:             return DOT11DECRYPT_RET_NO_VALID_HANDSHAKE;",
      "652:         }",
      "",
      "[Removed Lines]",
      "649:         if (status!=0) {",
      "",
      "[Added Lines]",
      "656:         if (status != 0 && status != 85) {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "659:         while(offset < (tot_len - 2)) {",
      "661:                 offset_rsne = offset;",
      "663:                 offset_fte = offset;",
      "665:                 offset_timeout = offset;",
      "667:                 offset_link = offset;",
      "668:             }",
      "671:                 return DOT11DECRYPT_RET_NO_VALID_HANDSHAKE;",
      "672:             }",
      "674:         }",
      "676:         if (offset_rsne == 0 || offset_fte == 0 ||",
      "",
      "[Removed Lines]",
      "660:             if (data[offset] == 48) {",
      "662:             } else if (data[offset] == 55) {",
      "664:             } else if (data[offset] == 56) {",
      "666:             } else if (data[offset] == 101) {",
      "670:             if (tot_len < offset + data[offset + 1] + 2) {",
      "673:             offset += data[offset + 1] + 2;",
      "",
      "[Added Lines]",
      "667:             guint8 element_id = data[offset];",
      "668:             guint8 length = data[offset + 1];",
      "669:             guint min_length = length;",
      "670:             switch (element_id) {",
      "673:                 min_length = 1;",
      "674:                 break;",
      "678:                 min_length = 2 + 16 + 32 + 32;",
      "679:                 break;",
      "682:                 min_length = 1 + 4;",
      "683:                 break;",
      "686:                 min_length = 6 + 6 + 6;",
      "687:                 break;",
      "690:             if (length < min_length || tot_len < offset + 2 + length) {",
      "693:             offset += 2 + length;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1b52f9929238ce3948ec924ae4f9456b5e9df558",
      "candidate_info": {
        "commit_hash": "1b52f9929238ce3948ec924ae4f9456b5e9df558",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/1b52f9929238ce3948ec924ae4f9456b5e9df558",
        "files": [
          "epan/crypt/dot11decrypt.c"
        ],
        "message": "dot11crypt: add bounds check for TDLS elements\n\nFixes a buffer overrun (read) of at most 255 bytes which could occur\nwhile processing FTE in Dot11DecryptTDLSDeriveKey.\n\nWhile at it, according to 802.11-2016 9.4.1.9, \"A status code of\nSUCCESS_POWER_SAVE_MODE also indicates a successful operation.\". No idea\nwhen it makes a difference, but let's implement it too.\n\nBug: 14686\nChange-Id: Ia7a41cd965704a4d51fb5a4dc4d01885fc17375c\nFixes: v2.1.0rc0-1825-g6991149557 (\"[airpdcap] Add support to decrypt TDLS traffic\")\nLink: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=8189\nReviewed-on: https://code.wireshark.org/review/27618\nPetri-Dish: Peter Wu <peter@lekensteyn.nl>\nTested-by: Petri Dish Buildbot\nReviewed-by: Anders Broman <a.broman58@gmail.com>\n(cherry picked from commit f440561b8c49c7863191c1ff2b36debed4d8d620)\nReviewed-on: https://code.wireshark.org/review/27640\nReviewed-by: Peter Wu <peter@lekensteyn.nl>",
        "before_after_code_files": [
          "epan/crypt/dot11decrypt.c||epan/crypt/dot11decrypt.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/crypt/dot11decrypt.c||epan/crypt/dot11decrypt.c"
          ],
          "candidate": [
            "epan/crypt/dot11decrypt.c||epan/crypt/dot11decrypt.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/crypt/dot11decrypt.c||epan/crypt/dot11decrypt.c": [
          "File: epan/crypt/dot11decrypt.c -> epan/crypt/dot11decrypt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "529: #endif",
          "530:     DOT11DECRYPT_DEBUG_TRACE_START(\"Dot11DecryptScanForKeys\");",
          "533:     offset = mac_header_len;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "534:     DISSECTOR_ASSERT(tot_len >= mac_header_len + DOT11DECRYPT_CRYPTED_DATA_MINLEN);",
          "535:     DISSECTOR_ASSERT(tot_len <= DOT11DECRYPT_MAX_CAPLEN);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "642:             DOT11DECRYPT_DEBUG_PRINT_LINE(\"Dot11DecryptScanForKeys\", \"Not Response nor confirm\", DOT11DECRYPT_DEBUG_LEVEL_3);",
          "643:             return DOT11DECRYPT_RET_NO_VALID_HANDSHAKE;",
          "644:         }",
          "647:         offset++;",
          "648:         status=pntoh16(data+offset);",
          "650:             DOT11DECRYPT_DEBUG_PRINT_LINE(\"Dot11DecryptScanForKeys\", \"TDLS setup not successfull\", DOT11DECRYPT_DEBUG_LEVEL_3);",
          "651:             return DOT11DECRYPT_RET_NO_VALID_HANDSHAKE;",
          "652:         }",
          "",
          "[Removed Lines]",
          "649:         if (status!=0) {",
          "",
          "[Added Lines]",
          "656:         if (status != 0 && status != 85) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "659:         while(offset < (tot_len - 2)) {",
          "661:                 offset_rsne = offset;",
          "663:                 offset_fte = offset;",
          "665:                 offset_timeout = offset;",
          "667:                 offset_link = offset;",
          "668:             }",
          "671:                 return DOT11DECRYPT_RET_NO_VALID_HANDSHAKE;",
          "672:             }",
          "674:         }",
          "676:         if (offset_rsne == 0 || offset_fte == 0 ||",
          "",
          "[Removed Lines]",
          "660:             if (data[offset] == 48) {",
          "662:             } else if (data[offset] == 55) {",
          "664:             } else if (data[offset] == 56) {",
          "666:             } else if (data[offset] == 101) {",
          "670:             if (tot_len < offset + data[offset + 1] + 2) {",
          "673:             offset += data[offset + 1] + 2;",
          "",
          "[Added Lines]",
          "667:             guint8 element_id = data[offset];",
          "668:             guint8 length = data[offset + 1];",
          "669:             guint min_length = length;",
          "670:             switch (element_id) {",
          "673:                 min_length = 1;",
          "674:                 break;",
          "678:                 min_length = 2 + 16 + 32 + 32;",
          "679:                 break;",
          "682:                 min_length = 1 + 4;",
          "683:                 break;",
          "686:                 min_length = 6 + 6 + 6;",
          "687:                 break;",
          "690:             if (length < min_length || tot_len < offset + 2 + length) {",
          "693:             offset += 2 + length;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b1446124eebc3ea5591d18e719c2a5cff3630638",
      "candidate_info": {
        "commit_hash": "b1446124eebc3ea5591d18e719c2a5cff3630638",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/b1446124eebc3ea5591d18e719c2a5cff3630638",
        "files": [
          "epan/crypt/airpdcap.c"
        ],
        "message": "dot11crypt: add bounds check for TDLS elements\n\nFixes a buffer overrun (read) of at most 255 bytes which could occur\nwhile processing FTE in Dot11DecryptTDLSDeriveKey.\n\nWhile at it, according to 802.11-2016 9.4.1.9, \"A status code of\nSUCCESS_POWER_SAVE_MODE also indicates a successful operation.\". No idea\nwhen it makes a difference, but let's implement it too.\n\nBug: 14686\nChange-Id: Ia7a41cd965704a4d51fb5a4dc4d01885fc17375c\nFixes: v2.1.0rc0-1825-g6991149557 (\"[airpdcap] Add support to decrypt TDLS traffic\")\nLink: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=8189\nReviewed-on: https://code.wireshark.org/review/27618\nPetri-Dish: Peter Wu <peter@lekensteyn.nl>\nTested-by: Petri Dish Buildbot\nReviewed-by: Anders Broman <a.broman58@gmail.com>\n(cherry picked from commit f440561b8c49c7863191c1ff2b36debed4d8d620)\nReviewed-on: https://code.wireshark.org/review/27640\nReviewed-by: Peter Wu <peter@lekensteyn.nl>\n(cherry picked from commit 1b52f9929238ce3948ec924ae4f9456b5e9df558)\nReviewed-on: https://code.wireshark.org/review/28344\nReviewed-by: Guy Harris <guy@alum.mit.edu>",
        "before_after_code_files": [
          "epan/crypt/airpdcap.c||epan/crypt/airpdcap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "epan/crypt/airpdcap.c||epan/crypt/airpdcap.c": [
          "File: epan/crypt/airpdcap.c -> epan/crypt/airpdcap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "563: #endif",
          "564:     AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapScanForKeys\");",
          "567:     offset = mac_header_len;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "568:     DISSECTOR_ASSERT(tot_len <= AIRPDCAP_MAX_CAPLEN);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "707:             return AIRPDCAP_RET_NO_VALID_HANDSHAKE;",
          "708:         }",
          "709:         status=pntoh16(data+offset);",
          "711:             AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"TDLS setup not successfull\", AIRPDCAP_DEBUG_LEVEL_3);",
          "712:             return AIRPDCAP_RET_NO_VALID_HANDSHAKE;",
          "713:         }",
          "",
          "[Removed Lines]",
          "710:         if (status!=0) {",
          "",
          "[Added Lines]",
          "714:         if (status!=0 && status != 85) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "721:         while(offset < (tot_len - 2)) {",
          "723:                 offset_rsne = offset;",
          "725:                 offset_fte = offset;",
          "727:                 offset_timeout = offset;",
          "729:                 offset_link = offset;",
          "730:             }",
          "733:                 return AIRPDCAP_RET_NO_VALID_HANDSHAKE;",
          "734:             }",
          "736:         }",
          "738:         if (offset_rsne == 0 || offset_fte == 0 ||",
          "",
          "[Removed Lines]",
          "722:             if (data[offset] == 48) {",
          "724:             } else if (data[offset] == 55) {",
          "726:             } else if (data[offset] == 56) {",
          "728:             } else if (data[offset] == 101) {",
          "732:             if (tot_len < offset + data[offset + 1] + 2) {",
          "735:             offset += data[offset + 1] + 2;",
          "",
          "[Added Lines]",
          "726:             guint8 element_id = data[offset];",
          "727:             guint8 length = data[offset + 1];",
          "728:             guint min_length = length;",
          "729:             switch (element_id) {",
          "732:                 min_length = 1;",
          "733:                 break;",
          "737:                 min_length = 2 + 16 + 32 + 32;",
          "738:                 break;",
          "741:                 min_length = 1 + 4;",
          "742:                 break;",
          "745:                 min_length = 6 + 6 + 6;",
          "746:                 break;",
          "749:             if (length < min_length || tot_len < offset + 2 + length) {",
          "752:             offset += 2 + length;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
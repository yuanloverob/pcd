{
  "cve_id": "CVE-2022-36042",
  "cve_desc": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting data from dyld cache files. A user opening a malicious dyld cache file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commit number 556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810 contains a patch.",
  "repo": "rizinorg/rizin",
  "patch_hash": "556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810",
  "patch_info": {
    "commit_hash": "556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810",
    "repo": "rizinorg/rizin",
    "commit_url": "https://github.com/rizinorg/rizin/commit/556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810",
    "files": [
      "librz/bin/format/mach0/dyldcache.c"
    ],
    "message": "Fix oob write in dyldcache\n\nWhen the individual n_slide_infos were too high, the sum would overflow\nand too few entries would be allocated.",
    "before_after_code_files": [
      "librz/bin/format/mach0/dyldcache.c||librz/bin/format/mach0/dyldcache.c"
    ]
  },
  "patch_diff": {
    "librz/bin/format/mach0/dyldcache.c||librz/bin/format/mach0/dyldcache.c": [
      "File: librz/bin/format/mach0/dyldcache.c -> librz/bin/format/mach0/dyldcache.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "995:  }",
      "997:  if (!cache->hdr->slideInfoOffset || !cache->hdr->slideInfoSize) {",
      "999:   ut32 n_slide_infos[MAX_N_HDR];",
      "1001:   ut32 i;",
      "",
      "[Removed Lines]",
      "998:   ut32 total_slide_infos = 0;",
      "",
      "[Added Lines]",
      "998:   size_t total_slide_infos = 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1004:    if (!rz_buf_read_le32_at(cache->buf, 0x13c + hdr_offset, &n_slide_infos[i])) {",
      "1005:     goto beach;",
      "1006:    }",
      "1008:   }",
      "1010:   if (!total_slide_infos) {",
      "",
      "[Removed Lines]",
      "1007:    total_slide_infos += n_slide_infos[i];",
      "",
      "[Added Lines]",
      "1007:    ut32 total = total_slide_infos + n_slide_infos[i];",
      "1008:    if (total < total_slide_infos) {",
      "1010:     goto beach;",
      "1011:    }",
      "1012:    total_slide_infos = total;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e5ad689fc9407ad6f3b53de80c7102c0b1f9d017",
      "candidate_info": {
        "commit_hash": "e5ad689fc9407ad6f3b53de80c7102c0b1f9d017",
        "repo": "rizinorg/rizin",
        "commit_url": "https://github.com/rizinorg/rizin/commit/e5ad689fc9407ad6f3b53de80c7102c0b1f9d017",
        "files": [
          "librz/bin/bobj.c",
          "librz/bin/format/luac/luac_bin.c",
          "librz/bin/p/bin_luac.c",
          "librz/core/cbin.c"
        ],
        "message": "Fix strdup on nullptr in rz_core_bin_apply_strings",
        "before_after_code_files": [
          "librz/bin/bobj.c||librz/bin/bobj.c",
          "librz/bin/format/luac/luac_bin.c||librz/bin/format/luac/luac_bin.c",
          "librz/bin/p/bin_luac.c||librz/bin/p/bin_luac.c",
          "librz/core/cbin.c||librz/core/cbin.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/rizinorg/rizin/pull/2930"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "librz/bin/bobj.c||librz/bin/bobj.c": [
          "File: librz/bin/bobj.c -> librz/bin/bobj.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "454:  if (p->symbols) {",
          "455:   o->symbols = p->symbols(bf);",
          "456:   if (o->symbols) {",
          "458:    REBASE_PADDR(o, o->symbols, RzBinSymbol);",
          "459:    if (bin->filter) {",
          "460:     rz_bin_filter_symbols(bf, o->symbols);",
          "",
          "[Removed Lines]",
          "457:    rz_warn_if_fail(o->symbols->free);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "librz/bin/format/luac/luac_bin.c||librz/bin/format/luac/luac_bin.c": [
          "File: librz/bin/format/luac/luac_bin.c -> librz/bin/format/luac/luac_bin.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: void luac_add_section(RzList *section_list, char *name, ut64 offset, ut32 size, bool is_func) {",
          "7:  RzBinSection *bin_sec = RZ_NEW0(RzBinSection);",
          "9:   return;",
          "10:  }",
          "",
          "[Removed Lines]",
          "8:  if (!bin_sec) {",
          "",
          "[Added Lines]",
          "8:  if (!bin_sec || !name) {",
          "9:   free(bin_sec);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "16:  bin_sec->bits = is_func ? sizeof(LUA_INSTRUCTION) * 8 : 8;",
          "18:  bin_sec->has_strings = false;",
          "21:  if (is_func) {",
          "22:   bin_sec->perm = RZ_PERM_R | RZ_PERM_X;",
          "",
          "[Removed Lines]",
          "19:  bin_sec->arch = rz_str_new(\"luac\");",
          "",
          "[Added Lines]",
          "20:  bin_sec->arch = \"luac\";",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "24:   bin_sec->perm = RZ_PERM_R;",
          "25:  }",
          "28: }",
          "30: void luac_add_symbol(RzList *symbol_list, char *name, ut64 offset, ut64 size, const char *type) {",
          "",
          "[Removed Lines]",
          "27:  rz_list_append(section_list, bin_sec);",
          "",
          "[Added Lines]",
          "28:  if (!rz_list_append(section_list, bin_sec)) {",
          "29:   rz_bin_section_free(bin_sec);",
          "30:  }",
          "",
          "---------------"
        ],
        "librz/bin/p/bin_luac.c||librz/bin/p/bin_luac.c": [
          "File: librz/bin/p/bin_luac.c -> librz/bin/p/bin_luac.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: }",
          "19: static bool load_buffer(RzBinFile *bf, RzBinObject *obj, RzBuffer *buf, Sdb *sdb) {",
          "21:  LuacBinInfo *bin_info_obj = NULL;",
          "22:  LuaProto *proto = NULL;",
          "23:  RzBinInfo *general_info = NULL;",
          "24:  st32 major;",
          "25:  st32 minor;",
          "34:  if (major != 5) {",
          "35:   RZ_LOG_ERROR(\"currently support lua 5.x only\\n\");",
          "36:   return false;",
          "37:  }",
          "39:  switch (minor) {",
          "40:  case 4:",
          "41:   proto = lua_parse_body_54(buf, 0x20, bf->size);",
          "",
          "[Removed Lines]",
          "20:  ut8 MAJOR_MINOR_VERSION;",
          "28:  if ((bin_info_obj = RZ_NEW(LuacBinInfo)) == NULL) {",
          "29:   return false;",
          "30:  }",
          "31:  major = (MAJOR_MINOR_VERSION & 0xF0) >> 4;",
          "32:  minor = (MAJOR_MINOR_VERSION & 0x0F);",
          "",
          "[Added Lines]",
          "20:  ut8 major_minor_version;",
          "28:  major = (major_minor_version & 0xF0) >> 4;",
          "29:  minor = (major_minor_version & 0x0F);",
          "36:  bin_info_obj = RZ_NEW(LuacBinInfo);",
          "37:  if (!bin_info_obj) {",
          "38:   return false;",
          "39:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "47:   break;",
          "48:  default:",
          "49:   RZ_LOG_ERROR(\"lua 5.%c not support now\\n\", minor + '0');",
          "50:   return false;",
          "51:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "52:   free(bin_info_obj);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "54:  if (bin_info_obj == NULL) {",
          "55:   lua_free_proto_entry(proto);",
          "56:   rz_bin_info_free(general_info);",
          "57:   return false;",
          "58:  }",
          "59:  bin_info_obj->general_info = general_info;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "60:   free(bin_info_obj);",
          "",
          "---------------"
        ],
        "librz/core/cbin.c||librz/core/cbin.c": [
          "File: librz/core/cbin.c -> librz/core/cbin.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "555:    break;",
          "556:   }",
          "557:   rz_meta_set_with_subtype(r->analysis, RZ_META_TYPE_STRING, string->type, vaddr, string->size, string->string);",
          "559:   rz_name_filter(f_name, -1, true);",
          "560:   char *str;",
          "561:   if (r->bin->prefix) {",
          "",
          "[Removed Lines]",
          "558:   char *f_name = strdup(string->string);",
          "",
          "[Added Lines]",
          "558:   char *f_name = rz_str_new(string->string);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d4134cb58c2504846320a1e4d56c9137cf95efc2",
      "candidate_info": {
        "commit_hash": "d4134cb58c2504846320a1e4d56c9137cf95efc2",
        "repo": "rizinorg/rizin",
        "commit_url": "https://github.com/rizinorg/rizin/commit/d4134cb58c2504846320a1e4d56c9137cf95efc2",
        "files": [
          "librz/util/bitmap.c"
        ],
        "message": "Add extra check on RzBitmap.",
        "before_after_code_files": [
          "librz/util/bitmap.c||librz/util/bitmap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/rizinorg/rizin/pull/2930"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "librz/util/bitmap.c||librz/util/bitmap.c": [
          "File: librz/util/bitmap.c -> librz/util/bitmap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: }",
          "35: RZ_API void rz_bitmap_set_bytes(RZ_NONNULL RzBitmap *b, RZ_NONNULL const ut8 *buf, size_t len) {",
          "37:  if (b->length < len) {",
          "38:   len = b->length;",
          "39:  }",
          "",
          "[Removed Lines]",
          "36:  rz_return_if_fail(b && buf);",
          "",
          "[Added Lines]",
          "36:  rz_return_if_fail(b && buf && len >= 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "49: }",
          "51: RZ_API void rz_bitmap_set(RZ_NONNULL RzBitmap *b, size_t bit) {",
          "53:  if (bit < b->length) {",
          "54:   b->bitmap[(bit >> BITWORD_BITS_SHIFT)] |=",
          "55:    ((RBitword)1 << (bit & BITWORD_BITS_MASK));",
          "",
          "[Removed Lines]",
          "52:  rz_return_if_fail(b);",
          "",
          "[Added Lines]",
          "52:  rz_return_if_fail(b && bit >= 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "57: }",
          "59: RZ_API void rz_bitmap_unset(RZ_NONNULL RzBitmap *b, size_t bit) {",
          "61:  if (bit < b->length) {",
          "62:   b->bitmap[(bit >> BITWORD_BITS_SHIFT)] &=",
          "63:    ~((RBitword)1 << (bit & BITWORD_BITS_MASK));",
          "",
          "[Removed Lines]",
          "60:  rz_return_if_fail(b);",
          "",
          "[Added Lines]",
          "60:  rz_return_if_fail(b && bit >= 0);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "65: }",
          "67: RZ_API int rz_bitmap_test(RZ_NONNULL RzBitmap *b, size_t bit) {",
          "69:  if (bit < b->length) {",
          "70:   RBitword bword = b->bitmap[(bit >> BITWORD_BITS_SHIFT)];",
          "71:   return BITWORD_TEST(bword, (bit & BITWORD_BITS_MASK));",
          "",
          "[Removed Lines]",
          "68:  rz_return_val_if_fail(b, -1);",
          "",
          "[Added Lines]",
          "68:  rz_return_val_if_fail(b && bit >= 0, -1);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c19eaa88431505f267093aca7feead37ce804d49",
      "candidate_info": {
        "commit_hash": "c19eaa88431505f267093aca7feead37ce804d49",
        "repo": "rizinorg/rizin",
        "commit_url": "https://github.com/rizinorg/rizin/commit/c19eaa88431505f267093aca7feead37ce804d49",
        "files": [
          "librz/bin/format/mach0/dyldcache.c",
          "librz/bin/format/mach0/dyldcache.h",
          "librz/bin/format/mach0/mach0.c",
          "librz/bin/format/mach0/mach0.h",
          "librz/bin/format/mach0/mach0_specs.h",
          "librz/bin/format/objc/mach0_classes.c",
          "librz/bin/format/objc/mach0_classes.h",
          "librz/bin/p/bin_dyldcache.c",
          "librz/bin/p/bin_mach0.c",
          "librz/bin/p/bin_mach064.c"
        ],
        "message": "Add Support For dyld4 Atlas-style Shared Library Caches\n\noriginal radare2 commit: 09e20cd53d00a1497bf50349fe6eb812b4f54ac5\n\nSigned-off-by: Florian M\u00e4rkl <info@florianmaerkl.de>",
        "before_after_code_files": [
          "librz/bin/format/mach0/dyldcache.c||librz/bin/format/mach0/dyldcache.c",
          "librz/bin/format/mach0/dyldcache.h||librz/bin/format/mach0/dyldcache.h",
          "librz/bin/format/mach0/mach0.c||librz/bin/format/mach0/mach0.c",
          "librz/bin/format/mach0/mach0.h||librz/bin/format/mach0/mach0.h",
          "librz/bin/format/mach0/mach0_specs.h||librz/bin/format/mach0/mach0_specs.h",
          "librz/bin/format/objc/mach0_classes.c||librz/bin/format/objc/mach0_classes.c",
          "librz/bin/format/objc/mach0_classes.h||librz/bin/format/objc/mach0_classes.h",
          "librz/bin/p/bin_dyldcache.c||librz/bin/p/bin_dyldcache.c",
          "librz/bin/p/bin_mach0.c||librz/bin/p/bin_mach0.c",
          "librz/bin/p/bin_mach064.c||librz/bin/p/bin_mach064.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "librz/bin/format/mach0/dyldcache.c||librz/bin/format/mach0/dyldcache.c"
          ],
          "candidate": [
            "librz/bin/format/mach0/dyldcache.c||librz/bin/format/mach0/dyldcache.c"
          ]
        }
      },
      "candidate_diff": {
        "librz/bin/format/mach0/dyldcache.c||librz/bin/format/mach0/dyldcache.c": [
          "File: librz/bin/format/mach0/dyldcache.c -> librz/bin/format/mach0/dyldcache.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: #include <ht_pu.h>",
          "14:  ut64 res = UT64_MAX;",
          "17:  addr -= slide;",
          "20:   if (addr >= maps[i].address && addr < maps[i].address + maps[i].size) {",
          "21:    res = maps[i].fileOffset + addr - maps[i].address;",
          "22:    if (offset) {",
          "",
          "[Removed Lines]",
          "11: static RzDyldLocSym *rz_dyld_locsym_new(RzBuffer *cache_buf, cache_hdr_t *hdr);",
          "13: static ut64 va2pa(uint64_t addr, cache_hdr_t *hdr, cache_map_t *maps, RzBuffer *cache_buf, ut64 slide, ut32 *offset, ut32 *left) {",
          "15:  uint32_t i;",
          "19:  for (i = 0; i < hdr->mappingCount; i++) {",
          "",
          "[Added Lines]",
          "11: #define MAX_N_HDR 16",
          "13: static RzDyldLocSym *rz_dyld_locsym_new(RzDyldCache *cache);",
          "18: RZ_API bool rz_dyldcache_check_magic(const char *magic) {",
          "19:  return !strcmp(magic, \"dyld_v1   arm64\") || !strcmp(magic, \"dyld_v1  arm64e\") || !strcmp(magic, \"dyld_v1  x86_64\") || !strcmp(magic, \"dyld_v1 x86_64h\");",
          "20: }",
          "22: static ut64 va2pa(uint64_t addr, ut32 n_maps, cache_map_t *maps, RzBuffer *cache_buf, ut64 slide, ut32 *offset, ut32 *left) {",
          "24:  ut32 i;",
          "28:  for (i = 0; i < n_maps; i++) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "40:  free(bin);",
          "41: }",
          "44:  if (!cache_buf) {",
          "45:   return NULL;",
          "46:  }",
          "",
          "[Removed Lines]",
          "43: static cache_hdr_t *read_cache_header(RzBuffer *cache_buf) {",
          "",
          "[Added Lines]",
          "52: static cache_hdr_t *read_cache_header(RzBuffer *cache_buf, ut64 offset) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "51:  }",
          "53:  ut64 size = sizeof(cache_hdr_t);",
          "55:   free(hdr);",
          "56:   return NULL;",
          "57:  }",
          "59:  return hdr;",
          "60: }",
          "65:  }",
          "69:  if (!maps) {",
          "71:  }",
          "76:  }",
          "79: }",
          "81: static cache_accel_t *read_cache_accel(RzBuffer *cache_buf, cache_hdr_t *hdr, cache_map_t *maps) {",
          "",
          "[Removed Lines]",
          "54:  if (rz_buf_fread_at(cache_buf, 0, (ut8 *)hdr, \"16c4i7l16clii4l\", 1) != size) {",
          "62: static cache_map_t *read_cache_maps(RzBuffer *cache_buf, cache_hdr_t *hdr) {",
          "63:  if (!cache_buf || !hdr || !hdr->mappingCount || !hdr->mappingOffset) {",
          "64:   return NULL;",
          "67:  ut64 size = sizeof(cache_map_t) * hdr->mappingCount;",
          "68:  cache_map_t *maps = RZ_NEWS0(cache_map_t, hdr->mappingCount);",
          "70:   return NULL;",
          "73:  if (rz_buf_fread_at(cache_buf, hdr->mappingOffset, (ut8 *)maps, \"3l2i\", hdr->mappingCount) != size) {",
          "74:   RZ_FREE(maps);",
          "75:   return NULL;",
          "78:  return maps;",
          "",
          "[Added Lines]",
          "63:  if (rz_buf_fread_at(cache_buf, offset, (ut8 *)hdr, \"16c4i7l16clii4l\", 1) != size) {",
          "64:   free(hdr);",
          "65:   return NULL;",
          "66:  }",
          "67:  if (!rz_dyldcache_check_magic(hdr->magic)) {",
          "72:  if (!hdr->imagesCount && !hdr->imagesOffset) {",
          "73:   if (!rz_buf_read_le32_at(cache_buf, 0x1c0 + offset, &hdr->imagesOffset) || !rz_buf_read_le32_at(cache_buf, 0x1c4 + offset, &hdr->imagesCount)) {",
          "74:    free(hdr);",
          "75:    return NULL;",
          "76:   }",
          "77:  }",
          "81: static void populate_cache_headers(RzDyldCache *cache) {",
          "82:  cache->n_hdr = 0;",
          "83:  RzList *hdrs = rz_list_newf(NULL);",
          "84:  if (!hdrs) {",
          "85:   return;",
          "86:  }",
          "88:  cache_hdr_t *h;",
          "89:  ut64 offsets[MAX_N_HDR];",
          "90:  ut64 offset = 0;",
          "91:  do {",
          "92:   offsets[cache->n_hdr] = offset;",
          "93:   h = read_cache_header(cache->buf, offset);",
          "94:   if (!h) {",
          "95:    break;",
          "96:   }",
          "97:   rz_list_append(hdrs, h);",
          "99:   ut64 size = h->codeSignatureOffset + h->codeSignatureSize;",
          "101: #define SHIFT_MAYBE(x) \\",
          "102:  if (x) { \\",
          "103:   x += offset; \\",
          "104:  }",
          "106:   SHIFT_MAYBE(h->mappingOffset);",
          "107:   SHIFT_MAYBE(h->imagesOffset);",
          "108:   SHIFT_MAYBE(h->codeSignatureOffset);",
          "109:   SHIFT_MAYBE(h->slideInfoOffset);",
          "110:   SHIFT_MAYBE(h->localSymbolsOffset);",
          "111:   SHIFT_MAYBE(h->branchPoolsOffset);",
          "112:   SHIFT_MAYBE(h->imagesTextOffset);",
          "114:   offset += size;",
          "115:   cache->n_hdr++;",
          "116:  } while (cache->n_hdr < MAX_N_HDR);",
          "118:  if (!cache->n_hdr) {",
          "119:   goto beach;",
          "120:  }",
          "122:  cache->hdr = RZ_NEWS0(cache_hdr_t, cache->n_hdr);",
          "123:  if (!cache->hdr) {",
          "124:   cache->n_hdr = 0;",
          "125:   goto beach;",
          "126:  }",
          "128:  cache->hdr_offset = RZ_NEWS0(ut64, cache->n_hdr);",
          "129:  if (!cache->hdr_offset) {",
          "130:   cache->n_hdr = 0;",
          "131:   RZ_FREE(cache->hdr);",
          "132:   goto beach;",
          "133:  }",
          "135:  memcpy(cache->hdr_offset, offsets, cache->n_hdr * sizeof(ut64));",
          "137:  ut32 i = 0;",
          "138:  RzListIter *iter;",
          "139:  cache_hdr_t *item;",
          "140:  rz_list_foreach (hdrs, iter, item) {",
          "141:   if (i >= cache->n_hdr) {",
          "142:    break;",
          "143:   }",
          "144:   memcpy(&cache->hdr[i++], item, sizeof(cache_hdr_t));",
          "145:  }",
          "147: beach:",
          "148:  rz_list_free(hdrs);",
          "149: }",
          "151: static void populate_cache_maps(RzDyldCache *cache) {",
          "152:  rz_return_if_fail(cache && cache->buf);",
          "154:  ut32 i;",
          "155:  ut32 n_maps = 0;",
          "156:  for (i = 0; i < cache->n_hdr; i++) {",
          "157:   cache_hdr_t *hdr = &cache->hdr[i];",
          "158:   if (!hdr->mappingCount || !hdr->mappingOffset) {",
          "159:    continue;",
          "160:   }",
          "161:   n_maps += hdr->mappingCount;",
          "164:  cache_map_t *maps = NULL;",
          "165:  if (n_maps != 0) {",
          "166:   cache->maps_index = RZ_NEWS0(ut32, cache->n_hdr);",
          "167:   if (!cache->maps_index) {",
          "168:    return;",
          "169:   }",
          "170:   maps = RZ_NEWS0(cache_map_t, n_maps);",
          "171:  }",
          "173:   cache->maps = NULL;",
          "174:   cache->n_maps = 0;",
          "175:   return;",
          "178:  ut32 next_map = 0;",
          "179:  ut32 last_idx = UT32_MAX;",
          "180:  ut64 max_address = 0;",
          "181:  for (i = 0; i < cache->n_hdr; i++) {",
          "182:   cache_hdr_t *hdr = &cache->hdr[i];",
          "183:   cache->maps_index[i] = next_map;",
          "185:   if (!hdr->mappingCount || !hdr->mappingOffset) {",
          "186:    continue;",
          "187:   }",
          "188:   ut64 size = sizeof(cache_map_t) * hdr->mappingCount;",
          "189:   if (rz_buf_fread_at(cache->buf, hdr->mappingOffset, (ut8 *)&maps[next_map], \"3l2i\", hdr->mappingCount) != size) {",
          "190:    continue;",
          "191:   }",
          "192:   ut32 j;",
          "193:   ut64 hdr_offset = cache->hdr_offset[i];",
          "194:   for (j = 0; j < hdr->mappingCount; j++) {",
          "195:    cache_map_t *map = &maps[next_map + j];",
          "196:    map->fileOffset += hdr_offset;",
          "197:    if (map->address > max_address) {",
          "198:     last_idx = i;",
          "199:     max_address = map->address;",
          "200:    }",
          "201:   }",
          "202:   next_map += hdr->mappingCount;",
          "205:  cache->maps = maps;",
          "206:  cache->n_maps = next_map;",
          "207:  if (last_idx == UT32_MAX) {",
          "208:   cache->symbols_off_base = 0;",
          "209:  } else {",
          "210:   cache->symbols_off_base = cache->hdr_offset[last_idx];",
          "211:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "83:   return NULL;",
          "84:  }",
          "87:  if (!offset) {",
          "88:   return NULL;",
          "89:  }",
          "",
          "[Removed Lines]",
          "86:  ut64 offset = va2pa(hdr->accelerateInfoAddr, hdr, maps, cache_buf, 0, NULL, NULL);",
          "",
          "[Added Lines]",
          "219:  ut64 offset = va2pa(hdr->accelerateInfoAddr, hdr->mappingCount, maps, cache_buf, 0, NULL, NULL);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "111:  return accel;",
          "112: }",
          "116:   return NULL;",
          "117:  }",
          "",
          "[Removed Lines]",
          "114: static cache_img_t *read_cache_images(RzBuffer *cache_buf, cache_hdr_t *hdr) {",
          "115:  if (!cache_buf || !hdr || !hdr->imagesCount || !hdr->imagesOffset) {",
          "",
          "[Added Lines]",
          "247: objc_cache_opt_info *rz_dyldcache_get_objc_opt_info(RzBinFile *bf, RzDyldCache *cache) {",
          "248:  objc_cache_opt_info *result = NULL;",
          "249:  RzListIter *iter;",
          "250:  RzDyldBinImage *bin;",
          "251:  rz_list_foreach (cache->bins, iter, bin) {",
          "252:   if (strcmp(bin->file, \"lib/libobjc.A.dylib\")) {",
          "253:    continue;",
          "254:   }",
          "256:   struct MACH0_(opts_t) opts;",
          "257:   opts.verbose = bf->rbin->verbose;",
          "258:   opts.header_at = bin->header_at;",
          "260:   struct MACH0_(obj_t) *mach0 = MACH0_(new_buf)(cache->buf, &opts);",
          "261:   if (!mach0) {",
          "262:    goto beach;",
          "263:   }",
          "265:   struct section_t *sections = NULL;",
          "266:   if (!(sections = MACH0_(get_sections)(mach0))) {",
          "267:    MACH0_(mach0_free)",
          "268:    (mach0);",
          "269:    goto beach;",
          "270:   }",
          "272:   int i;",
          "273:   ut64 scoffs_offset = 0;",
          "274:   ut64 scoffs_size = 0;",
          "275:   ut64 slide = rz_dyldcache_get_slide(cache);",
          "276:   for (i = 0; !sections[i].last; i++) {",
          "277:    if (sections[i].size == 0) {",
          "278:     continue;",
          "279:    }",
          "280:    if (strstr(sections[i].name, \"__objc_scoffs\")) {",
          "281:     scoffs_offset = va2pa(sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);",
          "282:     scoffs_size = sections[i].size;",
          "283:     break;",
          "284:    }",
          "285:   }",
          "287:   MACH0_(mach0_free)",
          "288:   (mach0);",
          "289:   RZ_FREE(sections);",
          "291:   if (!scoffs_offset || scoffs_size < 40) {",
          "292:    break;",
          "293:   }",
          "294:   ut64 check;",
          "295:   if (!rz_buf_read_le64_at(cache->buf, scoffs_offset, &check) || check != 2) {",
          "296:    break;",
          "297:   }",
          "298:   ut64 sel_string_base;",
          "299:   if (!rz_buf_read_le64_at(cache->buf, scoffs_offset + 8, &sel_string_base)) {",
          "300:    break;",
          "301:   }",
          "302:   ut64 sel_string_end;",
          "303:   if (!rz_buf_read_le64_at(cache->buf, scoffs_offset + 16, &sel_string_end) || sel_string_end == sel_string_base) {",
          "304:    break;",
          "305:   }",
          "306:   result = RZ_NEW0(objc_cache_opt_info);",
          "307:   if (!result) {",
          "308:    break;",
          "309:   }",
          "310:   result->sel_string_base = sel_string_base;",
          "311:  }",
          "312: beach:",
          "313:  return result;",
          "314: }",
          "316: static cache_img_t *read_cache_images(RzBuffer *cache_buf, cache_hdr_t *hdr, ut64 hdr_offset) {",
          "317:  if (!cache_buf || !hdr) {",
          "318:   return NULL;",
          "319:  }",
          "320:  if (!hdr->imagesCount || !hdr->imagesOffset || hdr->imagesOffset == UT32_MAX || hdr->imagesCount == UT32_MAX) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "127:   return NULL;",
          "128:  }",
          "130:  return images;",
          "131: }",
          "133: static cache_imgxtr_t *read_cache_imgextra(RzBuffer *cache_buf, cache_hdr_t *hdr, cache_accel_t *accel) {",
          "134:  if (!cache_buf || !hdr || !hdr->imagesCount || !accel || !accel->imageExtrasCount || !accel->imagesExtrasOffset) {",
          "135:   return NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "335:  if (hdr_offset) {",
          "336:   ut32 i;",
          "337:   for (i = 0; i < hdr->imagesCount; i++) {",
          "338:    cache_img_t *img = &images[i];",
          "339:    img->pathFileOffset += hdr_offset;",
          "340:   }",
          "341:  }",
          "346: static void match_bin_entries(RzDyldCache *cache, void *entries) {",
          "347:  rz_return_if_fail(cache && cache->bins && entries);",
          "349:  cache_img_t *imgs = read_cache_images(cache->buf, cache->hdr, 0);",
          "350:  if (!imgs) {",
          "351:   return;",
          "352:  }",
          "354:  RzDyldBinImage *bin = NULL;",
          "355:  RzListIter *it = rz_list_iterator(cache->bins);",
          "357:  bool has_large_entries = cache->n_hdr > 1;",
          "359:  ut32 i;",
          "360:  for (i = 0; i < cache->hdr->imagesCount; i++) {",
          "361:   cache_img_t *img = &imgs[i];",
          "362:   if (!it) {",
          "363:    break;",
          "364:   }",
          "365:   bin = it->data;",
          "366:   if (!bin) {",
          "367:    break;",
          "368:   }",
          "369:   if (bin && bin->va == img->address) {",
          "370:    if (has_large_entries) {",
          "371:     cache_locsym_entry_large_t *e = &((cache_locsym_entry_large_t *)entries)[i];",
          "372:     bin->nlist_start_index = e->nlistStartIndex;",
          "373:     bin->nlist_count = e->nlistCount;",
          "374:    } else {",
          "375:     cache_locsym_entry_t *e = &((cache_locsym_entry_t *)entries)[i];",
          "376:     bin->nlist_start_index = e->nlistStartIndex;",
          "377:     bin->nlist_count = e->nlistCount;",
          "378:    }",
          "379:    it = it->n;",
          "380:   }",
          "381:  }",
          "383:  RZ_FREE(imgs);",
          "384: }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "180:  return path_to_idx;",
          "181: }",
          "185:  if (pa == UT64_MAX) {",
          "186:   return;",
          "187:  }",
          "188:  struct MACH0_(mach_header) mh;",
          "190:   return;",
          "191:  }",
          "192:  if (mh.magic != MH_MAGIC_64 || mh.sizeofcmds == 0) {",
          "",
          "[Removed Lines]",
          "183: static void carve_deps_at_address(RzBuffer *cache_buf, cache_img_t *img, cache_hdr_t *hdr, cache_map_t *maps, HtPU *path_to_idx, ut64 address, int *deps) {",
          "184:  ut64 pa = va2pa(address, hdr, maps, cache_buf, 0, NULL, NULL);",
          "189:  if (rz_buf_fread_at(cache_buf, pa, (ut8 *)&mh, \"8i\", 1) != sizeof(struct MACH0_(mach_header))) {",
          "",
          "[Added Lines]",
          "436: static void carve_deps_at_address(RzDyldCache *cache, cache_img_t *img, HtPU *path_to_idx, ut64 address, int *deps, bool printing) {",
          "437:  ut64 pa = va2pa(address, cache->n_maps, cache->maps, cache->buf, 0, NULL, NULL);",
          "442:  if (rz_buf_fread_at(cache->buf, pa, (ut8 *)&mh, \"8i\", 1) != sizeof(struct MACH0_(mach_header))) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "194:  }",
          "195:  ut64 cmds_at = pa + sizeof(struct MACH0_(mach_header));",
          "196:  ut8 *cmds = malloc(mh.sizeofcmds + 1);",
          "198:   goto beach;",
          "199:  }",
          "200:  cmds[mh.sizeofcmds] = 0;",
          "",
          "[Removed Lines]",
          "197:  if (!cmds || rz_buf_read_at(cache_buf, cmds_at, cmds, mh.sizeofcmds) != mh.sizeofcmds) {",
          "",
          "[Added Lines]",
          "450:  if (!cmds || rz_buf_read_at(cache->buf, cmds_at, cmds, mh.sizeofcmds) != mh.sizeofcmds) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "213:    }",
          "214:    const char *key = (const char *)cursor + 24;",
          "215:    size_t dep_index = (size_t)ht_pu_find(path_to_idx, key, &found);",
          "218:     continue;",
          "219:    }",
          "220:    deps[dep_index]++;",
          "222:   }",
          "223:   cursor += cmdsize;",
          "224:  }",
          "",
          "[Removed Lines]",
          "216:    if (!found || dep_index >= hdr->imagesCount) {",
          "217:     eprintf(\"WARNING: alien dep '%s'\\n\", key);",
          "221:    eprintf(\"-> %s\\n\", key);",
          "",
          "[Added Lines]",
          "469:    if (!found || dep_index >= cache->hdr->imagesCount) {",
          "470:     RZ_LOG_WARN(\"alien dep '%s'\\n\", key);",
          "474:    if (printing) {",
          "475:     RZ_LOG_INFO(\"-> %s\\n\", key);",
          "476:    }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "227:  free(cmds);",
          "228: }",
          "231:  RzList *bins = rz_list_newf((RzListFree)free_bin);",
          "232:  if (!bins) {",
          "233:   return NULL;",
          "234:  }",
          "244:  char *target_libs = NULL;",
          "246:  RzList *target_lib_names = NULL;",
          "249:  if (target_libs) {",
          "250:   target_lib_names = rz_str_split_list(target_libs, \":\", 0);",
          "251:   if (!target_lib_names) {",
          "253:   }",
          "256:   if (!deps) {",
          "258:   }",
          "274:    }",
          "288:     RZ_FREE(lib_name);",
          "304:      }",
          "307:     }",
          "310:    }",
          "324:   }",
          "341:    }",
          "354:       } else {",
          "355:        bin->file = strdup(last_slash + 1);",
          "356:       }",
          "357:      } else {",
          "359:      }",
          "362:     }",
          "363:    }",
          "370:   }",
          "371:  }",
          "376:   rz_list_free(bins);",
          "385:  }",
          "386:  RZ_FREE(deps);",
          "388:  return bins;",
          "389: }",
          "",
          "[Removed Lines]",
          "230: static RzList *create_cache_bins(RzBuffer *cache_buf, cache_hdr_t *hdr, cache_map_t *maps, cache_accel_t *accel) {",
          "236:  cache_img_t *img = read_cache_images(cache_buf, hdr);",
          "237:  if (!img) {",
          "238:   rz_list_free(bins);",
          "239:   return NULL;",
          "240:  }",
          "242:  int i;",
          "243:  int *deps = NULL;",
          "245:  target_libs = rz_sys_getenv(\"RZ_DYLDCACHE_FILTER\");",
          "247:  ut16 *depArray = NULL;",
          "248:  cache_imgxtr_t *extras = NULL;",
          "252:    goto error;",
          "255:   deps = RZ_NEWS0(int, hdr->imagesCount);",
          "257:    goto error;",
          "260:   HtPU *path_to_idx = NULL;",
          "261:   if (accel) {",
          "262:    depArray = RZ_NEWS0(ut16, accel->depListCount);",
          "263:    if (!depArray) {",
          "264:     goto error;",
          "265:    }",
          "267:    if (rz_buf_fread_at(cache_buf, accel->depListOffset, (ut8 *)depArray, \"s\", accel->depListCount) != accel->depListCount * 2) {",
          "268:     goto error;",
          "269:    }",
          "271:    extras = read_cache_imgextra(cache_buf, hdr, accel);",
          "272:    if (!extras) {",
          "273:     goto error;",
          "275:   } else {",
          "276:    path_to_idx = create_path_to_index(cache_buf, img, hdr);",
          "277:   }",
          "279:   for (i = 0; i < hdr->imagesCount; i++) {",
          "280:    char *lib_name = get_lib_name(cache_buf, &img[i]);",
          "281:    if (!lib_name) {",
          "282:     break;",
          "283:    }",
          "284:    if (strstr(lib_name, \"libobjc.A.dylib\")) {",
          "285:     deps[i]++;",
          "286:    }",
          "287:    if (!rz_list_find(target_lib_names, lib_name, string_contains)) {",
          "289:     continue;",
          "290:    }",
          "291:    eprintf(\"FILTER: %s\\n\", lib_name);",
          "292:    RZ_FREE(lib_name);",
          "293:    deps[i]++;",
          "295:    if (extras && depArray) {",
          "296:     ut32 j;",
          "297:     for (j = extras[i].dependentsStartArrayIndex; depArray[j] != 0xffff; j++) {",
          "298:      ut16 dep_index = depArray[j] & 0x7fff;",
          "299:      deps[dep_index]++;",
          "301:      char *dep_name = get_lib_name(cache_buf, &img[dep_index]);",
          "302:      if (!dep_name) {",
          "303:       break;",
          "305:      eprintf(\"-> %s\\n\", dep_name);",
          "306:      free(dep_name);",
          "308:    } else if (path_to_idx) {",
          "309:     carve_deps_at_address(cache_buf, img, hdr, maps, path_to_idx, img[i].address, deps);",
          "311:   }",
          "313:   ht_pu_free(path_to_idx);",
          "314:   RZ_FREE(depArray);",
          "315:   RZ_FREE(extras);",
          "316:   RZ_FREE(target_libs);",
          "317:   rz_list_free(target_lib_names);",
          "318:   target_lib_names = NULL;",
          "319:  }",
          "321:  for (i = 0; i < hdr->imagesCount; i++) {",
          "322:   if (deps && !deps[i]) {",
          "323:    continue;",
          "325:   ut64 pa = va2pa(img[i].address, hdr, maps, cache_buf, 0, NULL, NULL);",
          "326:   if (pa == UT64_MAX) {",
          "327:    continue;",
          "328:   }",
          "329:   ut8 magicbytes[4];",
          "330:   rz_buf_read_at(cache_buf, pa, magicbytes, 4);",
          "331:   int magic = rz_read_le32(magicbytes);",
          "332:   switch (magic) {",
          "333:   case MH_MAGIC:",
          "335:    break;",
          "336:   case MH_MAGIC_64: {",
          "337:    char file[256];",
          "338:    RzDyldBinImage *bin = RZ_NEW0(RzDyldBinImage);",
          "339:    if (!bin) {",
          "340:     goto error;",
          "342:    bin->header_at = pa;",
          "343:    if (rz_buf_read_at(cache_buf, img[i].pathFileOffset, (ut8 *)&file, sizeof(file)) == sizeof(file)) {",
          "344:     file[255] = 0;",
          "345:     char *last_slash = strrchr(file, '/');",
          "346:     if (last_slash && *last_slash) {",
          "347:      if (last_slash > file) {",
          "348:       char *scan = last_slash - 1;",
          "349:       while (scan > file && *scan != '/') {",
          "350:        scan--;",
          "351:       }",
          "352:       if (*scan == '/') {",
          "353:        bin->file = strdup(scan + 1);",
          "358:       bin->file = strdup(last_slash + 1);",
          "360:     } else {",
          "361:      bin->file = strdup(file);",
          "364:    rz_list_append(bins, bin);",
          "365:    break;",
          "366:   }",
          "367:   default:",
          "368:    eprintf(\"Unknown sub-bin\\n\");",
          "369:    break;",
          "373:  goto beach;",
          "374: error:",
          "375:  if (bins) {",
          "377:  }",
          "378:  bins = NULL;",
          "379: beach:",
          "380:  RZ_FREE(depArray);",
          "381:  RZ_FREE(extras);",
          "382:  RZ_FREE(target_libs);",
          "383:  if (target_lib_names) {",
          "384:   rz_list_free(target_lib_names);",
          "387:  RZ_FREE(img);",
          "",
          "[Added Lines]",
          "485: static RzList *create_cache_bins(RzDyldCache *cache) {",
          "493:  int *deps = NULL;",
          "494:  target_libs = rz_sys_getenv(\"RZ_DYLDCACHE_FILTER\");",
          "498:    rz_list_free(bins);",
          "499:    return NULL;",
          "501:   deps = RZ_NEWS0(int, cache->hdr->imagesCount);",
          "503:    rz_list_free(bins);",
          "504:    rz_list_free(target_lib_names);",
          "505:    return NULL;",
          "506:   }",
          "507:  }",
          "509:  ut32 i;",
          "510:  for (i = 0; i < cache->n_hdr; i++) {",
          "511:   cache_hdr_t *hdr = &cache->hdr[i];",
          "512:   ut64 hdr_offset = cache->hdr_offset[i];",
          "513:   ut64 symbols_off = cache->symbols_off_base - hdr_offset;",
          "514:   ut32 maps_index = cache->maps_index[i];",
          "515:   cache_img_t *img = read_cache_images(cache->buf, hdr, hdr_offset);",
          "516:   if (!img) {",
          "517:    goto next;",
          "520:   ut32 j;",
          "521:   ut16 *depArray = NULL;",
          "522:   cache_imgxtr_t *extras = NULL;",
          "523:   if (target_libs) {",
          "524:    HtPU *path_to_idx = NULL;",
          "525:    if (cache->accel) {",
          "526:     depArray = RZ_NEWS0(ut16, cache->accel->depListCount);",
          "527:     if (!depArray) {",
          "528:      goto next;",
          "529:     }",
          "531:     if (rz_buf_fread_at(cache->buf, cache->accel->depListOffset, (ut8 *)depArray, \"s\", cache->accel->depListCount) != cache->accel->depListCount * 2) {",
          "532:      goto next;",
          "533:     }",
          "535:     extras = read_cache_imgextra(cache->buf, hdr, cache->accel);",
          "536:     if (!extras) {",
          "537:      goto next;",
          "538:     }",
          "539:    } else {",
          "540:     path_to_idx = create_path_to_index(cache->buf, img, hdr);",
          "543:    for (j = 0; j < hdr->imagesCount; j++) {",
          "544:     bool printing = !deps[j];",
          "545:     char *lib_name = get_lib_name(cache->buf, &img[j]);",
          "546:     if (!lib_name) {",
          "547:      break;",
          "548:     }",
          "549:     if (strstr(lib_name, \"libobjc.A.dylib\")) {",
          "550:      deps[j]++;",
          "551:     }",
          "552:     if (!rz_list_find(target_lib_names, lib_name, string_contains)) {",
          "553:      RZ_FREE(lib_name);",
          "554:      continue;",
          "555:     }",
          "556:     if (printing) {",
          "557:      RZ_LOG_INFO(\"FILTER: %s\\n\", lib_name);",
          "558:     }",
          "560:     deps[j]++;",
          "562:     if (extras && depArray) {",
          "563:      ut32 k;",
          "564:      for (k = extras[j].dependentsStartArrayIndex; depArray[k] != 0xffff; k++) {",
          "565:       ut16 dep_index = depArray[k] & 0x7fff;",
          "566:       deps[dep_index]++;",
          "568:       char *dep_name = get_lib_name(cache->buf, &img[dep_index]);",
          "569:       if (!dep_name) {",
          "570:        break;",
          "571:       }",
          "572:       if (printing) {",
          "573:        RZ_LOG_INFO(\"-> %s\\n\", dep_name);",
          "574:       }",
          "575:       free(dep_name);",
          "577:     } else if (path_to_idx) {",
          "578:      carve_deps_at_address(cache, img, path_to_idx, img[j].address, deps, printing);",
          "582:    ht_pu_free(path_to_idx);",
          "583:    RZ_FREE(depArray);",
          "584:    RZ_FREE(extras);",
          "587:   for (j = 0; j < hdr->imagesCount; j++) {",
          "588:    if (deps && !deps[j]) {",
          "589:     continue;",
          "591:    ut64 pa = va2pa(img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);",
          "592:    if (pa == UT64_MAX) {",
          "593:     continue;",
          "594:    }",
          "595:    ut8 magicbytes[4];",
          "596:    rz_buf_read_at(cache->buf, pa, magicbytes, 4);",
          "597:    int magic = rz_read_le32(magicbytes);",
          "598:    switch (magic) {",
          "599:    case MH_MAGIC_64: {",
          "600:     char file[256];",
          "601:     RzDyldBinImage *bin = RZ_NEW0(RzDyldBinImage);",
          "602:     if (!bin) {",
          "603:      goto next;",
          "604:     }",
          "605:     bin->header_at = pa;",
          "606:     bin->hdr_offset = hdr_offset;",
          "607:     bin->symbols_off = symbols_off;",
          "608:     bin->va = img[j].address;",
          "609:     if (rz_buf_read_at(cache->buf, img[j].pathFileOffset, (ut8 *)&file, sizeof(file)) == sizeof(file)) {",
          "610:      file[255] = 0;",
          "611:      char *last_slash = strrchr(file, '/');",
          "612:      if (last_slash && *last_slash) {",
          "613:       if (last_slash > file) {",
          "614:        char *scan = last_slash - 1;",
          "615:        while (scan > file && *scan != '/') {",
          "616:         scan--;",
          "617:        }",
          "618:        if (*scan == '/') {",
          "619:         bin->file = strdup(scan + 1);",
          "620:        } else {",
          "621:         bin->file = strdup(last_slash + 1);",
          "622:        }",
          "627:       bin->file = strdup(file);",
          "630:     rz_list_append(bins, bin);",
          "631:     break;",
          "632:    }",
          "633:    default:",
          "634:     RZ_LOG_WARN(\"Unknown sub-bin\\n\");",
          "635:     break;",
          "638:  next:",
          "639:   RZ_FREE(depArray);",
          "640:   RZ_FREE(extras);",
          "641:   RZ_FREE(img);",
          "643:  if (rz_list_empty(bins)) {",
          "645:   bins = NULL;",
          "648:  RZ_FREE(target_libs);",
          "649:  rz_list_free(target_lib_names);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "412: static ut64 estimate_slide(RzDyldCache *cache, ut64 value_mask, ut64 value_add) {",
          "413:  ut64 slide = 0;",
          "414:  ut64 *classlist = malloc(64);",
          "415:  if (!classlist) {",
          "416:   goto beach;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "676:  if (cache->n_hdr > 1) {",
          "677:   return slide;",
          "678:  }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "462:   int classlist_sample_size = RZ_MIN(64, sections[classlist_idx].size);",
          "463:   int n_classes = classlist_sample_size / 8;",
          "466:    goto next_bin;",
          "467:   }",
          "",
          "[Removed Lines]",
          "465:   if (rz_buf_fread_at(cache->buf, sections[classlist_idx].offset, (ut8 *)classlist, \"l\", n_classes) < classlist_sample_size) {",
          "",
          "[Added Lines]",
          "729:   ut64 sect_offset = sections[classlist_idx].offset + bin->hdr_offset;",
          "731:   if (rz_buf_fread_at(cache->buf, sect_offset, (ut8 *)classlist, \"l\", n_classes) < classlist_sample_size) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "723: }",
          "725: static RzDyldRebaseInfos *get_rebase_infos(RzDyldCache *cache) {",
          "728:  RzDyldRebaseInfos *result = RZ_NEW0(RzDyldRebaseInfos);",
          "729:  if (!result) {",
          "730:   return NULL;",
          "731:  }",
          "733:  if (!cache->hdr->slideInfoOffset || !cache->hdr->slideInfoSize) {",
          "737:   }",
          "741:    goto beach;",
          "742:   }",
          "745:   if (!infos) {",
          "746:    goto beach;",
          "747:   }",
          "757:    }",
          "766:    }",
          "767:   }",
          "770:    free(infos);",
          "771:    goto beach;",
          "772:   }",
          "776:    if (!pruned_infos) {",
          "777:     free(infos);",
          "778:     goto beach;",
          "779:    }",
          "782:    free(infos);",
          "783:    infos = pruned_infos;",
          "784:   }",
          "786:   result->entries = infos;",
          "788:   return result;",
          "789:  }",
          "",
          "[Removed Lines]",
          "726:  RzBuffer *cache_buf = cache->buf;",
          "734:   ut32 slide_infos_offset;",
          "735:   if (!rz_buf_read_le32_at(cache_buf, 0x138, &slide_infos_offset)) {",
          "736:    goto beach;",
          "739:   ut32 n_slide_infos;",
          "740:   if (!rz_buf_read_le32_at(cache_buf, 0x13c, &n_slide_infos)) {",
          "744:   RzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, n_slide_infos);",
          "749:   size_t i, j;",
          "750:   RzDyldRebaseInfo *prev_info = NULL;",
          "751:   for (i = 0, j = 0; i < n_slide_infos; i++) {",
          "752:    ut64 offset = slide_infos_offset + i * sizeof(cache_mapping_slide);",
          "753:    cache_mapping_slide entry;",
          "754:    if (rz_buf_fread_at(cache_buf, offset, (ut8 *)&entry, \"6lii\", 1) != sizeof(cache_mapping_slide)) {",
          "755:     free(infos);",
          "756:     goto beach;",
          "759:    if (entry.slideInfoOffset && entry.slideInfoSize) {",
          "760:     infos[j].start = entry.fileOffset;",
          "761:     infos[j].end = entry.fileOffset + entry.size;",
          "762:     ut64 slide = prev_info ? prev_info->slide : UT64_MAX;",
          "763:     infos[j].info = get_rebase_info(cache, entry.slideInfoOffset, entry.slideInfoSize, entry.fileOffset, slide);",
          "764:     prev_info = infos[j].info;",
          "765:     j++;",
          "769:   if (!j) {",
          "774:   if (j != n_slide_infos) {",
          "775:    RzDyldRebaseInfosEntry *pruned_infos = RZ_NEWS0(RzDyldRebaseInfosEntry, j);",
          "781:    memcpy(pruned_infos, infos, sizeof(RzDyldRebaseInfosEntry) * j);",
          "787:   result->length = j;",
          "",
          "[Added Lines]",
          "998:   ut32 total_slide_infos = 0;",
          "999:   ut32 n_slide_infos[MAX_N_HDR];",
          "1001:   ut32 i;",
          "1002:   for (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {",
          "1003:    ut64 hdr_offset = cache->hdr_offset[i];",
          "1004:    if (!rz_buf_read_le32_at(cache->buf, 0x13c + hdr_offset, &n_slide_infos[i])) {",
          "1005:     goto beach;",
          "1006:    }",
          "1007:    total_slide_infos += n_slide_infos[i];",
          "1010:   if (!total_slide_infos) {",
          "1014:   RzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, total_slide_infos);",
          "1019:   ut32 k = 0;",
          "1020:   for (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {",
          "1021:    ut64 hdr_offset = cache->hdr_offset[i];",
          "1022:    if (!n_slide_infos[i]) {",
          "1023:     continue;",
          "1025:    ut32 sio;",
          "1026:    if (!rz_buf_read_le32_at(cache->buf, 0x138 + hdr_offset, &sio)) {",
          "1027:     continue;",
          "1028:    }",
          "1029:    ut64 slide_infos_offset = sio;",
          "1030:    if (!slide_infos_offset) {",
          "1031:     continue;",
          "1032:    }",
          "1033:    slide_infos_offset += hdr_offset;",
          "1035:    ut32 j;",
          "1036:    RzDyldRebaseInfo *prev_info = NULL;",
          "1037:    for (j = 0; j < n_slide_infos[i]; j++) {",
          "1038:     ut64 offset = slide_infos_offset + j * sizeof(cache_mapping_slide);",
          "1039:     cache_mapping_slide entry;",
          "1040:     if (rz_buf_fread_at(cache->buf, offset, (ut8 *)&entry, \"6lii\", 1) != sizeof(cache_mapping_slide)) {",
          "1041:      break;",
          "1042:     }",
          "1044:     if (entry.slideInfoOffset && entry.slideInfoSize) {",
          "1045:      infos[k].start = entry.fileOffset + hdr_offset;",
          "1046:      infos[k].end = infos[k].start + entry.size;",
          "1047:      ut64 slide = prev_info ? prev_info->slide : UT64_MAX;",
          "1048:      infos[k].info = get_rebase_info(cache, entry.slideInfoOffset + hdr_offset, entry.slideInfoSize, entry.fileOffset + hdr_offset, slide);",
          "1049:      prev_info = infos[k].info;",
          "1050:      k++;",
          "1051:     }",
          "1055:   if (!k) {",
          "1060:   if (k < total_slide_infos) {",
          "1061:    RzDyldRebaseInfosEntry *pruned_infos = RZ_NEWS0(RzDyldRebaseInfosEntry, k);",
          "1067:    memcpy(pruned_infos, infos, sizeof(RzDyldRebaseInfosEntry) * k);",
          "1073:   result->length = k;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "824:  return 0;",
          "825: }",
          "827: RZ_API RzDyldCache *rz_dyldcache_new_buf(RzBuffer *buf) {",
          "828:  RzDyldCache *cache = RZ_NEW0(RzDyldCache);",
          "829:  if (!cache) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1113: RZ_API void rz_dyldcache_symbols_from_locsym(RzDyldCache *cache, RzDyldBinImage *bin, RzList *symbols, SetU *hash) {",
          "1114:  RzDyldLocSym *locsym = cache->locsym;",
          "1115:  if (!locsym) {",
          "1116:   return;",
          "1117:  }",
          "1119:  if (bin->nlist_start_index >= locsym->nlists_count ||",
          "1120:   bin->nlist_start_index + bin->nlist_count > locsym->nlists_count) {",
          "1121:   eprintf(\"dyldcache: malformed local symbol entry\\n\");",
          "1122:   return;",
          "1123:  }",
          "1125:  ut64 nlists_size = sizeof(struct MACH0_(nlist)) * bin->nlist_count;",
          "1126:  struct MACH0_(nlist) *nlists = RZ_NEWS0(struct MACH0_(nlist), bin->nlist_count);",
          "1127:  if (!nlists) {",
          "1128:   return;",
          "1129:  }",
          "1130:  ut64 nlists_offset = locsym->local_symbols_offset + locsym->nlists_offset +",
          "1131:   bin->nlist_start_index * sizeof(struct MACH0_(nlist));",
          "1132:  if (rz_buf_fread_at(cache->buf, nlists_offset, (ut8 *)nlists, \"iccsl\", bin->nlist_count) != nlists_size) {",
          "1133:   free(nlists);",
          "1134:   return;",
          "1135:  }",
          "1137:  ut32 j;",
          "1138:  for (j = 0; j != bin->nlist_count; j++) {",
          "1139:   struct MACH0_(nlist) *nlist = &nlists[j];",
          "1140:   if (set_u_contains(hash, (ut64)nlist->n_value)) {",
          "1141:    continue;",
          "1142:   }",
          "1143:   set_u_add(hash, (ut64)nlist->n_value);",
          "1144:   if (nlist->n_strx >= locsym->strings_size) {",
          "1145:    continue;",
          "1146:   }",
          "1147:   RzBinSymbol *sym = RZ_NEW0(RzBinSymbol);",
          "1148:   if (!sym) {",
          "1149:    break;",
          "1150:   }",
          "1151:   sym->type = \"LOCAL\";",
          "1152:   sym->vaddr = nlist->n_value;",
          "1153:   ut64 slide = rz_dyldcache_get_slide(cache);",
          "1154:   sym->paddr = va2pa(nlist->n_value, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);",
          "1156:   char *symstr = rz_buf_get_string(cache->buf, locsym->local_symbols_offset + locsym->strings_offset + nlist->n_strx);",
          "1157:   if (symstr) {",
          "1158:    sym->name = symstr;",
          "1159:   } else {",
          "1160:    static ut32 k = 0;",
          "1161:    sym->name = rz_str_newf(\"unk_local%d\", k++);",
          "1162:   }",
          "1164:   rz_list_append(symbols, sym);",
          "1165:  }",
          "1167:  free(nlists);",
          "1168: }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "831:  }",
          "832:  memcpy(cache->magic, \"dyldcac\", 7);",
          "833:  cache->buf = rz_buf_ref(buf);",
          "835:  if (!cache->hdr) {",
          "836:   goto cupertino;",
          "837:  }",
          "839:  if (!cache->maps) {",
          "840:   goto cupertino;",
          "841:  }",
          "842:  cache->accel = read_cache_accel(cache->buf, cache->hdr, cache->maps);",
          "845:  if (!cache->bins) {",
          "846:   goto cupertino;",
          "847:  }",
          "848:  cache->rebase_infos = get_rebase_infos(cache);",
          "849:  return cache;",
          "850: cupertino:",
          "",
          "[Removed Lines]",
          "834:  cache->hdr = read_cache_header(cache->buf);",
          "838:  cache->maps = read_cache_maps(cache->buf, cache->hdr);",
          "843:  cache->locsym = rz_dyld_locsym_new(cache->buf, cache->hdr);",
          "844:  cache->bins = create_cache_bins(cache->buf, cache->hdr, cache->maps, cache->accel);",
          "",
          "[Added Lines]",
          "1177:  populate_cache_headers(cache);",
          "1181:  populate_cache_maps(cache);",
          "1186:  cache->bins = create_cache_bins(cache);",
          "1190:  cache->locsym = rz_dyld_locsym_new(cache);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "898:  }",
          "899: }",
          "978:  }",
          "983: }",
          "985: RZ_API void rz_dyldcache_free(RzDyldCache *cache) {",
          "",
          "[Removed Lines]",
          "901: static RzDyldLocSym *rz_dyld_locsym_new(RzBuffer *cache_buf, cache_hdr_t *hdr) {",
          "902:  if (!cache_buf || !hdr || !hdr->localSymbolsSize || !hdr->localSymbolsOffset) {",
          "903:   return NULL;",
          "904:  }",
          "906:  cache_locsym_info_t *info = NULL;",
          "907:  char *strings = NULL;",
          "908:  cache_locsym_entry_t *entries = NULL;",
          "909:  struct MACH0_(nlist) *nlists = NULL;",
          "911:  ut64 info_size = sizeof(cache_locsym_info_t);",
          "912:  info = RZ_NEW0(cache_locsym_info_t);",
          "913:  if (!info) {",
          "914:   goto beach;",
          "915:  }",
          "916:  if (rz_buf_fread_at(cache_buf, hdr->localSymbolsOffset, (ut8 *)info, \"6i\", 1) != info_size) {",
          "917:   goto beach;",
          "918:  }",
          "920:  ut64 nlists_size = sizeof(struct MACH0_(nlist)) * info->nlistCount;",
          "921:  nlists = RZ_NEWS0(struct MACH0_(nlist), info->nlistCount);",
          "922:  if (!nlists) {",
          "923:   goto beach;",
          "924:  }",
          "925:  if (rz_buf_fread_at(cache_buf, hdr->localSymbolsOffset + info->nlistOffset, (ut8 *)nlists, \"iccsl\",",
          "926:       info->nlistCount) != nlists_size) {",
          "927:   goto beach;",
          "928:  }",
          "930:  strings = malloc(info->stringsSize);",
          "931:  if (!strings) {",
          "932:   goto beach;",
          "933:  }",
          "934:  if (rz_buf_read_at(cache_buf, hdr->localSymbolsOffset + info->stringsOffset, (ut8 *)strings,",
          "935:       info->stringsSize) != info->stringsSize) {",
          "936:   goto beach;",
          "937:  }",
          "939:  ut64 entries_size = sizeof(cache_locsym_entry_t) * info->entriesCount;",
          "940:  entries = RZ_NEWS0(cache_locsym_entry_t, info->entriesCount);",
          "941:  if (!entries) {",
          "942:   goto beach;",
          "943:  }",
          "944:  if (rz_buf_fread_at(cache_buf, hdr->localSymbolsOffset + info->entriesOffset, (ut8 *)entries, \"3i\",",
          "945:       info->entriesCount) != entries_size) {",
          "946:   goto beach;",
          "947:  }",
          "949:  RzDyldLocSym *locsym = RZ_NEW0(RzDyldLocSym);",
          "950:  if (!locsym) {",
          "951:   goto beach;",
          "952:  }",
          "954:  locsym->nlists = nlists;",
          "955:  locsym->nlists_count = info->nlistCount;",
          "956:  locsym->strings = strings;",
          "957:  locsym->strings_size = info->stringsSize;",
          "958:  locsym->entries = entries;",
          "959:  locsym->entries_count = info->entriesCount;",
          "961:  free(info);",
          "963:  return locsym;",
          "965: beach:",
          "966:  free(info);",
          "967:  free(strings);",
          "968:  free(entries);",
          "969:  free(nlists);",
          "971:  eprintf(\"dyldcache: malformed local symbols metadata\\n\");",
          "972:  return NULL;",
          "973: }",
          "975: static void rz_dyld_locsym_free(RzDyldLocSym *locsym) {",
          "976:  if (!locsym) {",
          "977:   return;",
          "979:  free(locsym->strings);",
          "980:  free(locsym->entries);",
          "981:  free(locsym->nlists);",
          "982:  free(locsym);",
          "",
          "[Added Lines]",
          "1244: static RzDyldLocSym *rz_dyld_locsym_new(RzDyldCache *cache) {",
          "1245:  rz_return_val_if_fail(cache && cache->buf, NULL);",
          "1247:  ut32 i;",
          "1248:  for (i = 0; i < cache->n_hdr; i++) {",
          "1249:   cache_hdr_t *hdr = &cache->hdr[i];",
          "1250:   if (!hdr || !hdr->localSymbolsSize || !hdr->localSymbolsOffset) {",
          "1251:    continue;",
          "1252:   }",
          "1254:   cache_locsym_info_t *info = NULL;",
          "1255:   void *entries = NULL;",
          "1257:   ut64 info_size = sizeof(cache_locsym_info_t);",
          "1258:   info = RZ_NEW0(cache_locsym_info_t);",
          "1259:   if (!info) {",
          "1260:    goto beach;",
          "1261:   }",
          "1262:   if (rz_buf_fread_at(cache->buf, hdr->localSymbolsOffset, (ut8 *)info, \"6i\", 1) != info_size) {",
          "1263:    eprintf(\"locsym err 01\\n\");",
          "1264:    goto beach;",
          "1265:   }",
          "1266:   if (info->entriesCount != cache->hdr->imagesCount) {",
          "1267:    eprintf(\"locsym err 02\\n\");",
          "1268:    goto beach;",
          "1269:   }",
          "1271:   bool has_large_entries = cache->n_hdr > 1;",
          "1272:   if (has_large_entries) {",
          "1273:    ut64 entries_size = sizeof(cache_locsym_entry_large_t) * info->entriesCount;",
          "1274:    cache_locsym_entry_large_t *large_entries = RZ_NEWS0(cache_locsym_entry_large_t, info->entriesCount);",
          "1275:    if (!large_entries) {",
          "1276:     goto beach;",
          "1277:    }",
          "1278:    if (rz_buf_fread_at(cache->buf, hdr->localSymbolsOffset + info->entriesOffset, (ut8 *)large_entries, \"lii\",",
          "1279:         info->entriesCount) != entries_size) {",
          "1280:     eprintf(\"locsym err 03\\n\");",
          "1281:     goto beach;",
          "1282:    }",
          "1283:    entries = large_entries;",
          "1284:   } else {",
          "1285:    ut64 entries_size = sizeof(cache_locsym_entry_t) * info->entriesCount;",
          "1286:    cache_locsym_entry_t *regular_entries = RZ_NEWS0(cache_locsym_entry_t, info->entriesCount);",
          "1287:    if (!regular_entries) {",
          "1288:     goto beach;",
          "1289:    }",
          "1290:    if (rz_buf_fread_at(cache->buf, hdr->localSymbolsOffset + info->entriesOffset, (ut8 *)regular_entries, \"iii\",",
          "1291:         info->entriesCount) != entries_size) {",
          "1292:     eprintf(\"locsym err 04\\n\");",
          "1293:     goto beach;",
          "1294:    }",
          "1295:    entries = regular_entries;",
          "1296:   }",
          "1297:   RzDyldLocSym *locsym = RZ_NEW0(RzDyldLocSym);",
          "1298:   if (!locsym) {",
          "1299:    goto beach;",
          "1300:   }",
          "1302:   match_bin_entries(cache, entries);",
          "1304:   locsym->local_symbols_offset = hdr->localSymbolsOffset;",
          "1305:   locsym->nlists_offset = info->nlistOffset;",
          "1306:   locsym->nlists_count = info->nlistCount;",
          "1307:   locsym->strings_offset = info->stringsOffset;",
          "1308:   locsym->strings_size = info->stringsSize;",
          "1310:   free(info);",
          "1311:   free(entries);",
          "1313:   return locsym;",
          "1315:  beach:",
          "1316:   free(info);",
          "1317:   free(entries);",
          "1319:   eprintf(\"dyldcache: malformed local symbols metadata\\n\");",
          "1320:   break;",
          "1322:  return NULL;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1002:  }",
          "1003:  free(cache->hdr);",
          "1004:  free(cache->maps);",
          "1005:  free(cache->accel);",
          "1007:  free(cache);",
          "1008: }",
          "1010: RZ_API ut64 rz_dyldcache_va2pa(RzDyldCache *cache, uint64_t vaddr, ut32 *offset, ut32 *left) {",
          "1011:  rz_return_val_if_fail(cache, UT64_MAX);",
          "1012:  ut64 slide = rz_dyldcache_get_slide(cache);",
          "1014:  if (res == UT64_MAX) {",
          "1015:   res = 0;",
          "1016:  }",
          "1017:  return res;",
          "1018: }",
          "",
          "[Removed Lines]",
          "1006:  rz_dyld_locsym_free(cache->locsym);",
          "1013:  ut64 res = va2pa(vaddr, cache->hdr, cache->maps, cache->buf, slide, offset, left);",
          "1020: RZ_API void rz_dyldcache_locsym_entries_by_offset(RzDyldCache *cache, RzList *symbols, SetU *hash, ut64 bin_header_offset) {",
          "1021:  RzDyldLocSym *locsym = cache->locsym;",
          "1022:  if (!locsym || !locsym->entries) {",
          "1023:   return;",
          "1024:  }",
          "1026:  ut64 i;",
          "1027:  for (i = 0; i != locsym->entries_count; i++) {",
          "1028:   cache_locsym_entry_t *entry = &locsym->entries[i];",
          "1029:   if (entry->dylibOffset != bin_header_offset) {",
          "1030:    continue;",
          "1031:   }",
          "1033:   if (entry->nlistStartIndex >= locsym->nlists_count ||",
          "1034:    entry->nlistStartIndex + entry->nlistCount > locsym->nlists_count) {",
          "1035:    eprintf(\"dyldcache: malformed local symbol entry\\n\");",
          "1036:    break;",
          "1037:   }",
          "1039:   ut32 j;",
          "1040:   for (j = 0; j != entry->nlistCount; j++) {",
          "1041:    struct MACH0_(nlist) *nlist = &locsym->nlists[j + entry->nlistStartIndex];",
          "1042:    if (set_u_contains(hash, (ut64)nlist->n_value)) {",
          "1043:     continue;",
          "1044:    }",
          "1045:    set_u_add(hash, (ut64)nlist->n_value);",
          "1046:    if (nlist->n_strx >= locsym->strings_size) {",
          "1047:     continue;",
          "1048:    }",
          "1049:    char *symstr = &locsym->strings[nlist->n_strx];",
          "1050:    RzBinSymbol *sym = RZ_NEW0(RzBinSymbol);",
          "1051:    if (!sym) {",
          "1052:     return;",
          "1053:    }",
          "1054:    sym->type = \"LOCAL\";",
          "1055:    sym->vaddr = nlist->n_value;",
          "1056:    ut64 slide = rz_dyldcache_get_slide(cache);",
          "1057:    sym->paddr = va2pa(nlist->n_value, cache->hdr, cache->maps, cache->buf, slide, NULL, NULL);",
          "1059:    int len = locsym->strings_size - nlist->n_strx;",
          "1060:    ut32 k;",
          "1061:    for (k = 0; k < len; k++) {",
          "1062:     if (((ut8)symstr[k] & 0xff) == 0xff || !symstr[k]) {",
          "1063:      len = k;",
          "1064:      break;",
          "1065:     }",
          "1066:    }",
          "1067:    if (len > 0) {",
          "1068:     sym->name = rz_str_ndup(symstr, len);",
          "1069:    } else {",
          "1070:     sym->name = rz_str_newf(\"unk_local%d\", k);",
          "1071:    }",
          "1073:    rz_list_append(symbols, sym);",
          "1074:   }",
          "1075:   break;",
          "1076:  }",
          "1077: }",
          "",
          "[Added Lines]",
          "1345:  free(cache->maps_index);",
          "1346:  free(cache->hdr_offset);",
          "1348:  free(cache->locsym);",
          "1349:  free(cache->oi);",
          "1356:  ut64 res = va2pa(vaddr, cache->n_maps, cache->maps, cache->buf, slide, offset, left);",
          "",
          "---------------"
        ],
        "librz/bin/format/mach0/dyldcache.h||librz/bin/format/mach0/dyldcache.h": [
          "File: librz/bin/format/mach0/dyldcache.h -> librz/bin/format/mach0/dyldcache.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "73: } RzDyldRebaseInfo1;",
          "75: typedef struct rz_dyld_loc_sym_t {",
          "79:  ut64 nlists_count;",
          "82: } RzDyldLocSym;",
          "84: typedef struct rz_bin_dyld_image_t {",
          "85:  char *file;",
          "86:  ut64 header_at;",
          "87: } RzDyldBinImage;",
          "89: typedef struct rz_dyldcache_t {",
          "90:  ut8 magic[8];",
          "91:  RzList *bins;",
          "92:  RzBuffer *buf;",
          "93:  RzDyldRebaseInfos *rebase_infos;",
          "96:  cache_accel_t *accel;",
          "97:  RzDyldLocSym *locsym;",
          "98: } RzDyldCache;",
          "100: RZ_API RzDyldCache *rz_dyldcache_new_buf(RzBuffer *buf);",
          "101: RZ_API void rz_dyldcache_free(RzDyldCache *cache);",
          "102: RZ_API ut64 rz_dyldcache_va2pa(RzDyldCache *cache, uint64_t vaddr, ut32 *offset, ut32 *left);",
          "104: RZ_API ut64 rz_dyldcache_get_slide(RzDyldCache *cache);",
          "106: RZ_API RzBuffer *rz_dyldcache_new_rebasing_buf(RzDyldCache *cache);",
          "107: RZ_API bool rz_dyldcache_needs_rebasing(RzDyldCache *cache);",
          "",
          "[Removed Lines]",
          "76:  char *strings;",
          "77:  ut64 strings_size;",
          "78:  struct MACH0_(nlist) * nlists;",
          "80:  cache_locsym_entry_t *entries;",
          "81:  ut64 entries_count;",
          "94:  cache_hdr_t *hdr;",
          "95:  cache_map_t *maps;",
          "103: RZ_API void rz_dyldcache_locsym_entries_by_offset(RzDyldCache *cache, RzList *symbols, SetU *hash, ut64 bin_header_offset);",
          "",
          "[Added Lines]",
          "76:  ut64 local_symbols_offset;",
          "77:  ut64 nlists_offset;",
          "79:  ut64 strings_offset;",
          "80:  ut64 strings_size;",
          "86:  ut64 hdr_offset;",
          "87:  ut64 symbols_off;",
          "88:  ut64 va;",
          "89:  ut32 nlist_start_index;",
          "90:  ut32 nlist_count;",
          "96:  cache_hdr_t *hdr;",
          "97:  ut64 *hdr_offset;",
          "98:  ut64 symbols_off_base;",
          "99:  ut32 *maps_index;",
          "100:  ut32 n_hdr;",
          "101:  cache_map_t *maps;",
          "102:  ut32 n_maps;",
          "109:  objc_cache_opt_info *oi;",
          "110:  bool objc_opt_info_loaded;",
          "113: RZ_API bool rz_dyldcache_check_magic(const char *magic);",
          "118: RZ_API objc_cache_opt_info *rz_dyldcache_get_objc_opt_info(RzBinFile *bf, RzDyldCache *cache);",
          "119: RZ_API void rz_dyldcache_symbols_from_locsym(RzDyldCache *cache, RzDyldBinImage *bin, RzList *symbols, SetU *hash);",
          "",
          "---------------"
        ],
        "librz/bin/format/mach0/mach0.c||librz/bin/format/mach0/mach0.c": [
          "File: librz/bin/format/mach0/mach0.c -> librz/bin/format/mach0/mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "458:  }",
          "459:  st.cmd = rz_read_ble32(symt, be);",
          "460:  st.cmdsize = rz_read_ble32(symt + 4, be);",
          "462:  st.nsyms = rz_read_ble32(symt + 12, be);",
          "464:  st.strsize = rz_read_ble32(symt + 20, be);",
          "466:  mo->symtab = NULL;",
          "",
          "[Removed Lines]",
          "461:  st.symoff = rz_read_ble32(symt + 8, be);",
          "463:  st.stroff = rz_read_ble32(symt + 16, be);",
          "",
          "[Added Lines]",
          "461:  st.symoff = rz_read_ble32(symt + 8, be) + mo->options.symbols_off;",
          "463:  st.stroff = rz_read_ble32(symt + 16, be) + mo->options.symbols_off;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1925:      bin->dyld_info->weak_bind_size = rz_read_ble32(&dyldi[28], bin->big_endian);",
          "1926:      bin->dyld_info->lazy_bind_off = rz_read_ble32(&dyldi[32], bin->big_endian);",
          "1927:      bin->dyld_info->lazy_bind_size = rz_read_ble32(&dyldi[36], bin->big_endian);",
          "1929:      bin->dyld_info->export_size = rz_read_ble32(&dyldi[44], bin->big_endian);",
          "1930:     }",
          "1931:    }",
          "",
          "[Removed Lines]",
          "1928:      bin->dyld_info->export_off = rz_read_ble32(&dyldi[40], bin->big_endian);",
          "",
          "[Added Lines]",
          "1928:      bin->dyld_info->export_off = rz_read_ble32(&dyldi[40], bin->big_endian) + bin->options.symbols_off;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2104: void MACH0_(opts_set_default)(struct MACH0_(opts_t) * options, RzBinFile *bf) {",
          "2105:  rz_return_if_fail(options && bf && bf->rbin);",
          "2106:  options->header_at = 0;",
          "2107:  options->verbose = bf->rbin->verbose;",
          "2108:  options->patch_relocs = true;",
          "2109: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2107:  options->symbols_off = 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2703:      }",
          "2704:      name = rz_str_append(name, s->label);",
          "2705:     }",
          "2708:      goto beach;",
          "2709:     }",
          "2710:     if (hasResolver) {",
          "",
          "[Removed Lines]",
          "2706:     if (name == NULL) {",
          "2707:      eprintf(\"malformed export trie\\n\");",
          "",
          "[Added Lines]",
          "2707:     if (!name) {",
          "2708:      RZ_LOG_ERROR(\"malformed export trie\\n\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2744:   next->label = (char *)p;",
          "2745:   p += strlen(next->label) + 1;",
          "2746:   if (p >= end) {",
          "2748:    RZ_FREE(next);",
          "2749:    goto beach;",
          "2750:   }",
          "",
          "[Removed Lines]",
          "2747:    eprintf(\"malformed export trie\\n\");",
          "",
          "[Added Lines]",
          "2748:    RZ_LOG_ERROR(\"malformed export trie\\n\");",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2754:    goto beach;",
          "2755:   }",
          "2756:   if (UT64_ADD_OVFCHK(tr, (ut64)trie) || tr + (ut64)trie >= (ut64)end) {",
          "2758:    RZ_FREE(next);",
          "2759:    goto beach;",
          "2760:   }",
          "",
          "[Removed Lines]",
          "2757:    eprintf(\"malformed export trie\\n\");",
          "",
          "[Added Lines]",
          "2758:    RZ_LOG_ERROR(\"malformed export trie\\n\");",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2765:    RTrieState *s;",
          "2766:    rz_list_foreach (states, it, s) {",
          "2767:     if (s->node == next->node) {",
          "2769:      RZ_FREE(next);",
          "2770:      goto beach;",
          "2771:     }",
          "",
          "[Removed Lines]",
          "2768:      eprintf(\"malformed export trie\\n\");",
          "",
          "[Added Lines]",
          "2769:      RZ_LOG_ERROR(\"malformed export trie\\n\");",
          "",
          "---------------"
        ],
        "librz/bin/format/mach0/mach0.h||librz/bin/format/mach0/mach0.h": [
          "File: librz/bin/format/mach0/mach0.h -> librz/bin/format/mach0/mach0.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "113: struct MACH0_(opts_t) {",
          "114:  bool verbose;",
          "115:  ut64 header_at;",
          "116:  bool patch_relocs;",
          "117: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "116:  ut64 symbols_off;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "128:  int nsects;",
          "129:  struct MACH0_(nlist) * symtab;",
          "130:  ut8 *symstr;",
          "132:  int symstrlen;",
          "133:  int nsymtab;",
          "134:  ut32 *indirectsyms;",
          "",
          "[Removed Lines]",
          "131:  ut8 *func_start; //buffer that hold the data from LC_FUNCTION_STARTS",
          "",
          "[Added Lines]",
          "132:  ut8 *func_start; // buffer that hold the data from LC_FUNCTION_STARTS",
          "",
          "---------------"
        ],
        "librz/bin/format/mach0/mach0_specs.h||librz/bin/format/mach0/mach0_specs.h": [
          "File: librz/bin/format/mach0/mach0_specs.h -> librz/bin/format/mach0/mach0_specs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "194: struct cache_header {",
          "195:  char version[16];",
          "197:  ut32 mappingCount;",
          "198:  ut32 startaddr;",
          "199:  ut32 numlibs;",
          "",
          "[Removed Lines]",
          "196:  ut32 baseaddroff; //mappingOffset",
          "",
          "[Added Lines]",
          "196:  ut32 baseaddroff; // mappingOffset",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "325:  uint32_t nlistCount;",
          "326: } cache_locsym_entry_t;",
          "328: typedef struct {",
          "329:  uint64_t address;",
          "330:  uint64_t size;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "328: typedef struct {",
          "329:  uint64_t dylibOffset;",
          "330:  uint32_t nlistStartIndex;",
          "331:  uint32_t nlistCount;",
          "332: } cache_locsym_entry_large_t;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "336:  uint32_t initProt;",
          "337: } cache_mapping_slide;",
          "339: #define DYLD_CACHE_SLIDE_PAGE_ATTRS             0xC000",
          "340: #define DYLD_CACHE_SLIDE_PAGE_ATTR_EXTRA        0x8000",
          "341: #define DYLD_CACHE_SLIDE_PAGE_ATTR_NO_REBASE    0x4000",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "345: typedef struct {",
          "346:  uint64_t sel_string_base;",
          "347: } objc_cache_opt_info;",
          "",
          "---------------"
        ],
        "librz/bin/format/objc/mach0_classes.c||librz/bin/format/objc/mach0_classes.c": [
          "File: librz/bin/format/objc/mach0_classes.c -> librz/bin/format/objc/mach0_classes.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "110: static void copy_sym_name_with_namespace(char *class_name, char *read_name, RzBinSymbol *sym);",
          "111: static void get_ivar_list_t(mach0_ut p, RzBinFile *bf, RzBuffer *buf, RzBinClass *klass);",
          "112: static void get_objc_property_list(mach0_ut p, RzBinFile *bf, RzBuffer *buf, RzBinClass *klass);",
          "117: static bool read_ptr_pa(RzBinFile *bf, RzBuffer *buf, ut64 paddr, mach0_ut *out);",
          "118: static bool read_ptr_va(RzBinFile *bf, RzBuffer *buf, ut64 vaddr, mach0_ut *out);",
          "119: static char *read_str(RzBinFile *bf, RzBuffer *buf, mach0_ut p, ut32 *offset, ut32 *left);",
          "",
          "[Removed Lines]",
          "113: static void get_method_list_t(mach0_ut p, RzBinFile *bf, RzBuffer *buf, char *class_name, RzBinClass *klass, bool is_static);",
          "114: static void get_protocol_list_t(mach0_ut p, RzBinFile *bf, RzBuffer *buf, RzBinClass *klass);",
          "115: static void get_class_ro_t(mach0_ut p, RzBinFile *bf, RzBuffer *buf, ut32 *is_meta_class, RzBinClass *klass);",
          "116: static RzList *MACH0_(parse_categories)(RzBinFile *bf, RzBuffer *buf, RzSkipList *relocs);",
          "",
          "[Added Lines]",
          "113: static void get_method_list_t(mach0_ut p, RzBinFile *bf, RzBuffer *buf, char *class_name, RzBinClass *klass, bool is_static, objc_cache_opt_info *oi);",
          "114: static void get_protocol_list_t(mach0_ut p, RzBinFile *bf, RzBuffer *buf, RzBinClass *klass, objc_cache_opt_info *oi);",
          "115: static void get_class_ro_t(mach0_ut p, RzBinFile *bf, RzBuffer *buf, ut32 *is_meta_class, RzBinClass *klass, objc_cache_opt_info *oi);",
          "116: static RzList *MACH0_(parse_categories)(RzBinFile *bf, RzBuffer *buf, RzSkipList *relocs, objc_cache_opt_info *oi);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "517: }",
          "521:  struct MACH0_(SMethodList) ml;",
          "522:  mach0_ut r;",
          "523:  ut32 offset, left, i;",
          "",
          "[Removed Lines]",
          "520: static void get_method_list_t(mach0_ut p, RzBinFile *bf, RzBuffer *buf, char *class_name, RzBinClass *klass, bool is_static) {",
          "",
          "[Added Lines]",
          "520: static void get_method_list_t(mach0_ut p, RzBinFile *bf, RzBuffer *buf, char *class_name, RzBinClass *klass, bool is_static, objc_cache_opt_info *oi) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "614:    m.imp = rz_read_ble(&sm[2 * sizeof(mach0_ut)], bigendian, 8 * sizeof(mach0_ut));",
          "615:   } else {",
          "616:    st64 name_offset = (st32)rz_read_ble(&sm[0], bigendian, 8 * sizeof(ut32));",
          "618:    if (mlflags != METHOD_LIST_FLAG_IS_PREOPT) {",
          "619:     r = va2pa(name, &offset, &left, bf);",
          "620:     if (!r) {",
          "",
          "[Removed Lines]",
          "617:    mach0_ut name = p + name_offset;",
          "",
          "[Added Lines]",
          "617:    mach0_ut name;",
          "618:    if (oi && oi->sel_string_base) {",
          "619:     name = oi->sel_string_base + name_offset;",
          "620:    } else {",
          "621:     name = p + name_offset;",
          "622:    }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "716: }",
          "720:  struct MACH0_(SProtocolList) pl = { 0 };",
          "721:  struct MACH0_(SProtocol) pc;",
          "722:  char *class_name = NULL;",
          "",
          "[Removed Lines]",
          "719: static void get_protocol_list_t(mach0_ut p, RzBinFile *bf, RzBuffer *buf, RzBinClass *klass) {",
          "",
          "[Added Lines]",
          "724: static void get_protocol_list_t(mach0_ut p, RzBinFile *bf, RzBuffer *buf, RzBinClass *klass, objc_cache_opt_info *oi) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "853:   }",
          "855:   if (pc.instanceMethods > 0) {",
          "857:   }",
          "858:   if (pc.classMethods > 0) {",
          "860:   }",
          "861:   RZ_FREE(class_name);",
          "862:   p += sizeof(ut32);",
          "",
          "[Removed Lines]",
          "856:    get_method_list_t(pc.instanceMethods, bf, buf, class_name, klass, false);",
          "859:    get_method_list_t(pc.classMethods, bf, buf, class_name, klass, true);",
          "",
          "[Added Lines]",
          "861:    get_method_list_t(pc.instanceMethods, bf, buf, class_name, klass, false, oi);",
          "864:    get_method_list_t(pc.classMethods, bf, buf, class_name, klass, true, oi);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1005: }",
          "1009:  struct MACH0_(obj_t) * bin;",
          "1010:  struct MACH0_(SClassRoT) cro = { 0 };",
          "1011:  ut32 offset, left, i;",
          "",
          "[Removed Lines]",
          "1008: static void get_class_ro_t(mach0_ut p, RzBinFile *bf, RzBuffer *buf, ut32 *is_meta_class, RzBinClass *klass) {",
          "",
          "[Added Lines]",
          "1013: static void get_class_ro_t(mach0_ut p, RzBinFile *bf, RzBuffer *buf, ut32 *is_meta_class, RzBinClass *klass, objc_cache_opt_info *oi) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1103: #endif",
          "1105:  if (cro.baseMethods > 0) {",
          "1107:  }",
          "1109:  if (cro.baseProtocols > 0) {",
          "1111:  }",
          "1113:  if (cro.ivars > 0) {",
          "",
          "[Removed Lines]",
          "1106:   get_method_list_t(cro.baseMethods, bf, buf, klass->name, klass, (cro.flags & RO_META) ? true : false);",
          "1110:   get_protocol_list_t(cro.baseProtocols, bf, buf, klass);",
          "",
          "[Added Lines]",
          "1111:   get_method_list_t(cro.baseMethods, bf, buf, klass->name, klass, (cro.flags & RO_META) ? true : false, oi);",
          "1115:   get_protocol_list_t(cro.baseProtocols, bf, buf, klass, oi);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1128:  return 0;",
          "1129: }",
          "1132:  struct MACH0_(SClass) c = { 0 };",
          "1133:  const int size = sizeof(struct MACH0_(SClass));",
          "1134:  mach0_ut r = 0;",
          "",
          "[Removed Lines]",
          "1131: void MACH0_(get_class_t)(mach0_ut p, RzBinFile *bf, RzBuffer *buf, RzBinClass *klass, bool dupe, RzSkipList *relocs) {",
          "",
          "[Added Lines]",
          "1136: void MACH0_(get_class_t)(mach0_ut p, RzBinFile *bf, RzBuffer *buf, RzBinClass *klass, bool dupe, RzSkipList *relocs, objc_cache_opt_info *oi) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1192:    }",
          "1193:   }",
          "1194:  }",
          "1197: #if SWIFT_SUPPORT",
          "1198:  if (q(c.data + n_value) & 7) {",
          "",
          "[Removed Lines]",
          "1195:  get_class_ro_t(RO_DATA_PTR(c.data), bf, buf, &is_meta_class, klass);",
          "",
          "[Added Lines]",
          "1200:  get_class_ro_t(RO_DATA_PTR(c.data), bf, buf, &is_meta_class, klass, oi);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1203:   mach0_ut isa_n_value = get_isa_value();",
          "1204:   ut64 tmp = klass->addr;",
          "1205:   MACH0_(get_class_t)",
          "1207:   klass->addr = tmp;",
          "1208:  }",
          "1209: }",
          "",
          "[Removed Lines]",
          "1206:   (c.isa + isa_n_value, bf, buf, klass, true, relocs);",
          "",
          "[Added Lines]",
          "1211:   (c.isa + isa_n_value, bf, buf, klass, true, relocs, oi);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1244: }",
          "1245: #endif",
          "1248:  RzList /*<RzBinClass>*/ *ret = NULL;",
          "1249:  ut64 num_of_unnamed_class = 0;",
          "1250:  RzBinClass *klass = NULL;",
          "",
          "[Removed Lines]",
          "1247: RzList *MACH0_(parse_classes)(RzBinFile *bf) {",
          "",
          "[Added Lines]",
          "1252: RzList *MACH0_(parse_classes)(RzBinFile *bf, objc_cache_opt_info *oi) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1279:  RzSkipList *relocs = MACH0_(get_relocs)(bf->o->bin_obj);",
          "",
          "[Removed Lines]",
          "1281:  ret = MACH0_(parse_categories)(bf, buf, relocs);",
          "",
          "[Added Lines]",
          "1286:  ret = MACH0_(parse_categories)(bf, buf, relocs, oi);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1349:   }",
          "1350:   p = rz_read_ble(&pp[0], bigendian, 8 * sizeof(mach0_ut));",
          "1351:   MACH0_(get_class_t)",
          "1353:   if (!klass->name) {",
          "1354:    klass->name = rz_str_newf(\"UnnamedClass%\" PFMT64d, num_of_unnamed_class);",
          "1355:    if (!klass->name) {",
          "",
          "[Removed Lines]",
          "1352:   (p, bf, buf, klass, false, relocs);",
          "",
          "[Added Lines]",
          "1357:   (p, bf, buf, klass, false, relocs, oi);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1369:  return NULL;",
          "1370: }",
          "1373:  rz_return_val_if_fail(bf && bf->o && bf->o->bin_obj && bf->o->info, NULL);",
          "1375:  RzList /*<RzBinClass>*/ *ret = NULL;",
          "",
          "[Removed Lines]",
          "1372: static RzList *MACH0_(parse_categories)(RzBinFile *bf, RzBuffer *buf, RzSkipList *relocs) {",
          "",
          "[Added Lines]",
          "1377: static RzList *MACH0_(parse_categories)(RzBinFile *bf, RzBuffer *buf, RzSkipList *relocs, objc_cache_opt_info *oi) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1432:    goto error;",
          "1433:   }",
          "1434:   MACH0_(get_category_t)",
          "1436:   if (!klass->name) {",
          "1437:    RZ_FREE(klass);",
          "1438:    continue;",
          "",
          "[Removed Lines]",
          "1435:   (p, bf, buf, klass, relocs);",
          "",
          "[Added Lines]",
          "1440:   (p, bf, buf, klass, relocs, oi);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1446:  return NULL;",
          "1447: }",
          "1450:  rz_return_if_fail(bf && bf->o && bf->o->info);",
          "1452:  struct MACH0_(SCategory) c = { 0 };",
          "",
          "[Removed Lines]",
          "1449: void MACH0_(get_category_t)(mach0_ut p, RzBinFile *bf, RzBuffer *buf, RzBinClass *klass, RzSkipList *relocs) {",
          "",
          "[Added Lines]",
          "1454: void MACH0_(get_category_t)(mach0_ut p, RzBinFile *bf, RzBuffer *buf, RzBinClass *klass, RzSkipList *relocs, objc_cache_opt_info *oi) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1555:  RZ_FREE(category_name);",
          "1557:  if (c.instanceMethods > 0) {",
          "1559:  }",
          "1561:  if (c.classMethods > 0) {",
          "1563:  }",
          "1565:  if (c.protocols > 0) {",
          "1567:  }",
          "1569:  if (c.properties > 0) {",
          "",
          "[Removed Lines]",
          "1558:   get_method_list_t(c.instanceMethods, bf, buf, klass->name, klass, false);",
          "1562:   get_method_list_t(c.classMethods, bf, buf, klass->name, klass, true);",
          "1566:   get_protocol_list_t(c.protocols, bf, buf, klass);",
          "",
          "[Added Lines]",
          "1563:   get_method_list_t(c.instanceMethods, bf, buf, klass->name, klass, false, oi);",
          "1567:   get_method_list_t(c.classMethods, bf, buf, klass->name, klass, true, oi);",
          "1571:   get_protocol_list_t(c.protocols, bf, buf, klass, oi);",
          "",
          "---------------"
        ],
        "librz/bin/format/objc/mach0_classes.h||librz/bin/format/objc/mach0_classes.h": [
          "File: librz/bin/format/objc/mach0_classes.h -> librz/bin/format/objc/mach0_classes.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: #ifndef MACH0_CLASSES_H",
          "22: #define MACH0_CLASSES_H",
          "28: #endif // MACH0_CLASSES_H",
          "",
          "[Removed Lines]",
          "24: RZ_API RzList *MACH0_(parse_classes)(RzBinFile *bf);",
          "25: RZ_API void MACH0_(get_class_t)(mach0_ut p, RzBinFile *bf, RzBuffer *buf, RzBinClass *klass, bool dupe, RzSkipList *relocs);",
          "26: RZ_API void MACH0_(get_category_t)(mach0_ut p, RzBinFile *bf, RzBuffer *buf, RzBinClass *klass, RzSkipList *relocs);",
          "",
          "[Added Lines]",
          "24: RZ_API RzList *MACH0_(parse_classes)(RzBinFile *bf, objc_cache_opt_info *oi);",
          "25: RZ_API void MACH0_(get_class_t)(mach0_ut p, RzBinFile *bf, RzBuffer *buf, RzBinClass *klass, bool dupe, RzSkipList *relocs, objc_cache_opt_info *oi);",
          "26: RZ_API void MACH0_(get_category_t)(mach0_ut p, RzBinFile *bf, RzBuffer *buf, RzBinClass *klass, RzSkipList *relocs, objc_cache_opt_info *oi);",
          "",
          "---------------"
        ],
        "librz/bin/p/bin_dyldcache.c||librz/bin/p/bin_dyldcache.c": [
          "File: librz/bin/p/bin_dyldcache.c -> librz/bin/p/bin_dyldcache.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "34:   return NULL;",
          "35:  }",
          "37:  struct MACH0_(opts_t) opts;",
          "38:  MACH0_(opts_set_default)",
          "39:  (&opts, bf);",
          "42:  mach0->user = cache;",
          "43:  mach0->va2pa = &bin_obj_va2pa;",
          "44:  return mach0;",
          "45: }",
          "",
          "[Removed Lines]",
          "40:  opts.header_at = bin->header_at;",
          "41:  struct MACH0_(obj_t) *mach0 = MACH0_(new_buf)(cache->buf, &opts);",
          "",
          "[Added Lines]",
          "37:  RzBuffer *buf = rz_buf_new_slice(cache->buf, bin->hdr_offset, rz_buf_size(cache->buf) - bin->hdr_offset);",
          "38:  if (!buf) {",
          "39:   return NULL;",
          "40:  }",
          "45:  opts.header_at = bin->header_at - bin->hdr_offset;",
          "46:  opts.symbols_off = bin->symbols_off;",
          "48:  struct MACH0_(obj_t) *mach0 = MACH0_(new_buf)(buf, &opts);",
          "53:  rz_buf_free(buf);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "55:   return false;",
          "56:  }",
          "59: }",
          "61: static bool load_buffer(RzBinFile *bf, RzBinObject *obj, RzBuffer *buf, Sdb *sdb) {",
          "",
          "[Removed Lines]",
          "58:  return !strcmp(hdr, \"dyld_v1   arm64\") || !strcmp(hdr, \"dyld_v1  arm64e\") || !strcmp(hdr, \"dyld_v1  x86_64\") || !strcmp(hdr, \"dyld_v1 x86_64h\");",
          "",
          "[Added Lines]",
          "69:  return rz_dyldcache_check_magic(hdr);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "119:  return 0x180000000;",
          "120: }",
          "123:  struct MACH0_(obj_t) *mach0 = bin_to_mach0(bf, bin);",
          "124:  if (!mach0) {",
          "125:   return;",
          "",
          "[Removed Lines]",
          "122: void symbols_from_bin(RzList *ret, RzBinFile *bf, RzDyldBinImage *bin, SetU *hash) {",
          "",
          "[Added Lines]",
          "133: void symbols_from_bin(RzDyldCache *cache, RzList *ret, RzBinFile *bf, RzDyldBinImage *bin, SetU *hash) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "132:  }",
          "133:  int i;",
          "134:  for (i = 0; !symbols[i].last; i++) {",
          "136:    continue;",
          "137:   }",
          "138:   if (strstr(symbols[i].name, \"<redacted>\")) {",
          "",
          "[Removed Lines]",
          "135:   if (!symbols[i].name[0] || symbols[i].addr < 100) {",
          "",
          "[Added Lines]",
          "146:   if (!symbols[i].name || !symbols[i].name[0] || symbols[i].addr < 100) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "178: }",
          "180: static void sections_from_bin(RzList *ret, RzBinFile *bf, RzDyldBinImage *bin) {",
          "181:  struct MACH0_(obj_t) *mach0 = bin_to_mach0(bf, bin);",
          "182:  if (!mach0) {",
          "183:   return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "192:  RzDyldCache *cache = (RzDyldCache *)bf->o->bin_obj;",
          "193:  if (!cache) {",
          "194:   return;",
          "195:  }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "206:   ptr->is_data = __is_data_section(ptr->name);",
          "207:   ptr->size = sections[i].size;",
          "208:   ptr->vsize = sections[i].vsize;",
          "210:   ptr->vaddr = sections[i].addr;",
          "211:   if (!ptr->vaddr) {",
          "212:    ptr->vaddr = ptr->paddr;",
          "213:   }",
          "",
          "[Removed Lines]",
          "209:   ptr->paddr = sections[i].offset + bf->o->boffset;",
          "",
          "[Added Lines]",
          "226:   ptr->paddr = rz_dyldcache_va2pa(cache, sections[i].addr, NULL, NULL);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "262:   return NULL;",
          "263:  }",
          "264:  ut64 slide = rz_dyldcache_get_slide(cache);",
          "266:   RzBinMap *map = RZ_NEW0(RzBinMap);",
          "267:   if (!map) {",
          "268:    rz_list_free(ret);",
          "",
          "[Removed Lines]",
          "265:  for (ut32 i = 0; i < cache->hdr->mappingCount; i++) {",
          "",
          "[Added Lines]",
          "281:  for (ut32 i = 0; i < cache->n_maps; i++) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "325:    rz_list_free(ret);",
          "326:    return NULL;",
          "327:   }",
          "330:   set_u_free(hash);",
          "331:  }",
          "",
          "[Removed Lines]",
          "328:   symbols_from_bin(ret, bf, bin, hash);",
          "329:   rz_dyldcache_locsym_entries_by_offset(cache, ret, hash, bin->header_at);",
          "",
          "[Added Lines]",
          "344:   symbols_from_bin(cache, ret, bf, bin, hash);",
          "345:   rz_dyldcache_symbols_from_locsym(cache, bin, ret, hash);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "357:   return NULL;",
          "358:  }",
          "360:  RzListIter *iter;",
          "361:  RzDyldBinImage *bin;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "376:  if (!cache->objc_opt_info_loaded) {",
          "377:   cache->oi = rz_dyldcache_get_objc_opt_info(bf, cache);",
          "378:   cache->objc_opt_info_loaded = true;",
          "379:  }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "398:    }",
          "400:    ut8 *pointers = malloc(sections[i].size);",
          "402:     RZ_FREE(pointers);",
          "403:     continue;",
          "404:    }",
          "",
          "[Removed Lines]",
          "401:    if (rz_buf_read_at(buf, sections[i].offset, pointers, sections[i].size) < sections[i].size) {",
          "",
          "[Added Lines]",
          "422:    if (!pointers) {",
          "423:     continue;",
          "424:    }",
          "426:    ut64 offset = rz_dyldcache_va2pa(cache, sections[i].addr, NULL, NULL);",
          "427:    if (rz_buf_read_at(buf, offset, pointers, sections[i].size) < sections[i].size) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "423:     bf->o->bin_obj = mach0;",
          "424:     if (is_classlist) {",
          "425:      MACH0_(get_class_t)",
          "427:     } else {",
          "428:      MACH0_(get_category_t)",
          "430:     }",
          "431:     bf->o->bin_obj = cache;",
          "433:     if (!klass->name) {",
          "434:      klass->name = rz_str_newf(\"UnnamedClass%u\", num_of_unnamed_class);",
          "435:      if (!klass->name) {",
          "436:       RZ_FREE(klass);",
          "",
          "[Removed Lines]",
          "426:      ((ut64)pointer_to_class, bf, buf, klass, false, NULL);",
          "429:      ((ut64)pointer_to_class, bf, buf, klass, NULL);",
          "",
          "[Added Lines]",
          "452:      (pointer_to_class, bf, buf, klass, false, NULL, cache->oi);",
          "455:      (pointer_to_class, bf, buf, klass, NULL, cache->oi);",
          "460:      RZ_LOG_ERROR(\"CLASS ERROR AT 0x%llx, is_classlist %d\\n\", pointer_to_class, is_classlist);",
          "",
          "---------------"
        ],
        "librz/bin/p/bin_mach0.c||librz/bin/p/bin_mach0.c": [
          "File: librz/bin/p/bin_mach0.c -> librz/bin/p/bin_mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "522:  return ret;",
          "523: }",
          "525: #if !RZ_BIN_MACH064",
          "527: static bool check_buffer(RzBuffer *b) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "525: static RzList *classes(RzBinFile *bf) {",
          "526:  return MACH0_(parse_classes)(bf, NULL);",
          "527: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "867:  .libs = &libs,",
          "868:  .relocs = &relocs,",
          "869:  .create = &create,",
          "871:  .section_type_to_string = &MACH0_(section_type_to_string),",
          "873: };",
          "875: #ifndef RZ_PLUGIN_INCORE",
          "",
          "[Removed Lines]",
          "870:  .classes = &MACH0_(parse_classes),",
          "872:  .section_flag_to_rzlist = &MACH0_(section_flag_to_rzlist),",
          "",
          "[Added Lines]",
          "875:  .classes = &classes,",
          "877:  .section_flag_to_rzlist = &MACH0_(section_flag_to_rzlist)",
          "",
          "---------------"
        ],
        "librz/bin/p/bin_mach064.c||librz/bin/p/bin_mach064.c": [
          "File: librz/bin/p/bin_mach064.c -> librz/bin/p/bin_mach064.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "74:  D(ncmds); // ncmds",
          "75:  p_cmdsize = rz_buf_size(buf);",
          "76:  D(-1); // headsize // cmdsize?",
          "78:  D(0); // reserved -- only found in x86-64",
          "80:  magiclen = rz_buf_size(buf);",
          "",
          "[Removed Lines]",
          "77:  D(0); //0x85); // flags",
          "",
          "[Added Lines]",
          "77:  D(0); // 0x85); // flags",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "310:  .relocs = &relocs,",
          "311:  .fields = &MACH0_(mach_fields),",
          "312:  .create = &create,",
          "314:  .section_type_to_string = &MACH0_(section_type_to_string),",
          "315:  .section_flag_to_rzlist = &MACH0_(section_flag_to_rzlist),",
          "317: };",
          "319: #ifndef RZ_PLUGIN_INCORE",
          "",
          "[Removed Lines]",
          "313:  .classes = &MACH0_(parse_classes),",
          "",
          "[Added Lines]",
          "313:  .classes = &classes,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2011-2699",
  "cve_desc": "The IPv6 implementation in the Linux kernel before 3.1 does not generate Fragment Identification values separately for each destination, which makes it easier for remote attackers to cause a denial of service (disrupted networking) by predicting these values and sending crafted packets.",
  "repo": "torvalds/linux",
  "patch_hash": "87c48fa3b4630905f98268dde838ee43626a060c",
  "patch_info": {
    "commit_hash": "87c48fa3b4630905f98268dde838ee43626a060c",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/87c48fa3b4630905f98268dde838ee43626a060c",
    "files": [
      "drivers/char/random.c",
      "include/linux/random.h",
      "include/net/inetpeer.h",
      "include/net/ipv6.h",
      "net/ipv4/inetpeer.c",
      "net/ipv6/ip6_output.c",
      "net/ipv6/udp.c"
    ],
    "message": "ipv6: make fragment identifications less predictable\n\nIPv6 fragment identification generation is way beyond what we use for\nIPv4 : It uses a single generator. Its not scalable and allows DOS\nattacks.\n\nNow inetpeer is IPv6 aware, we can use it to provide a more secure and\nscalable frag ident generator (per destination, instead of system wide)\n\nThis patch :\n1) defines a new secure_ipv6_id() helper\n2) extends inet_getid() to provide 32bit results\n3) extends ipv6_select_ident() with a new dest parameter\n\nReported-by: Fernando Gont <fernando@gont.com.ar>\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "drivers/char/random.c||drivers/char/random.c",
      "include/linux/random.h||include/linux/random.h",
      "include/net/inetpeer.h||include/net/inetpeer.h",
      "include/net/ipv6.h||include/net/ipv6.h",
      "net/ipv4/inetpeer.c||net/ipv4/inetpeer.c",
      "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c",
      "net/ipv6/udp.c||net/ipv6/udp.c"
    ]
  },
  "patch_diff": {
    "drivers/char/random.c||drivers/char/random.c": [
      "File: drivers/char/random.c -> drivers/char/random.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1523:  return half_md4_transform(hash, keyptr->secret);",
      "1524: }",
      "1526: #ifdef CONFIG_INET",
      "1528: __u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1526: __u32 secure_ipv6_id(const __be32 daddr[4])",
      "1527: {",
      "1528:  const struct keydata *keyptr;",
      "1529:  __u32 hash[4];",
      "1531:  keyptr = get_keyptr();",
      "1533:  hash[0] = (__force __u32)daddr[0];",
      "1534:  hash[1] = (__force __u32)daddr[1];",
      "1535:  hash[2] = (__force __u32)daddr[2];",
      "1536:  hash[3] = (__force __u32)daddr[3];",
      "1538:  return half_md4_transform(hash, keyptr->secret);",
      "1539: }",
      "",
      "---------------"
    ],
    "include/linux/random.h||include/linux/random.h": [
      "File: include/linux/random.h -> include/linux/random.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "58: void generate_random_uuid(unsigned char uuid_out[16]);",
      "60: extern __u32 secure_ip_id(__be32 daddr);",
      "61: extern u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport);",
      "62: extern u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,",
      "63:           __be16 dport);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "61: extern __u32 secure_ipv6_id(const __be32 daddr[4]);",
      "",
      "---------------"
    ],
    "include/net/inetpeer.h||include/net/inetpeer.h": [
      "File: include/net/inetpeer.h -> include/net/inetpeer.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "71: }",
      "76: static inline struct inet_peer *inet_getpeer_v4(__be32 v4daddr, int create)",
      "77: {",
      "",
      "[Removed Lines]",
      "74: struct inet_peer *inet_getpeer(struct inetpeer_addr *daddr, int create);",
      "",
      "[Added Lines]",
      "74: struct inet_peer *inet_getpeer(const struct inetpeer_addr *daddr, int create);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "110: {",
      "111:  more++;",
      "112:  inet_peer_refcheck(p);",
      "114: }",
      "",
      "[Removed Lines]",
      "109: static inline __u16 inet_getid(struct inet_peer *p, int more)",
      "113:  return atomic_add_return(more, &p->ip_id_count) - more;",
      "",
      "[Added Lines]",
      "109: static inline int inet_getid(struct inet_peer *p, int more)",
      "111:  int old, new;",
      "114:  do {",
      "115:   old = atomic_read(&p->ip_id_count);",
      "116:   new = old + more;",
      "117:   if (!new)",
      "118:    new = 1;",
      "119:  } while (atomic_cmpxchg(&p->ip_id_count, old, new) != old);",
      "120:  return new;",
      "",
      "---------------"
    ],
    "include/net/ipv6.h||include/net/ipv6.h": [
      "File: include/net/ipv6.h -> include/net/ipv6.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "463:  return __ipv6_addr_diff(a1, a2, sizeof(struct in6_addr));",
      "464: }",
      "",
      "[Removed Lines]",
      "466: static __inline__ void ipv6_select_ident(struct frag_hdr *fhdr)",
      "467: {",
      "468:  static u32 ipv6_fragmentation_id = 1;",
      "469:  static DEFINE_SPINLOCK(ip6_id_lock);",
      "471:  spin_lock_bh(&ip6_id_lock);",
      "472:  fhdr->identification = htonl(ipv6_fragmentation_id);",
      "473:  if (++ipv6_fragmentation_id == 0)",
      "474:   ipv6_fragmentation_id = 1;",
      "475:  spin_unlock_bh(&ip6_id_lock);",
      "476: }",
      "",
      "[Added Lines]",
      "466: extern void ipv6_select_ident(struct frag_hdr *fhdr, struct rt6_info *rt);",
      "",
      "---------------"
    ],
    "net/ipv4/inetpeer.c||net/ipv4/inetpeer.c": [
      "File: net/ipv4/inetpeer.c -> net/ipv4/inetpeer.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "391:  return cnt;",
      "392: }",
      "395: {",
      "396:  struct inet_peer __rcu **stack[PEER_MAXDEPTH], ***stackptr;",
      "397:  struct inet_peer_base *base = family_to_base(daddr->family);",
      "",
      "[Removed Lines]",
      "394: struct inet_peer *inet_getpeer(struct inetpeer_addr *daddr, int create)",
      "",
      "[Added Lines]",
      "394: struct inet_peer *inet_getpeer(const struct inetpeer_addr *daddr, int create)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "436:   p->daddr = *daddr;",
      "437:   atomic_set(&p->refcnt, 1);",
      "438:   atomic_set(&p->rid, 0);",
      "440:   p->tcp_ts_stamp = 0;",
      "441:   p->metrics[RTAX_LOCK-1] = INETPEER_METRICS_NEW;",
      "442:   p->rate_tokens = 0;",
      "",
      "[Removed Lines]",
      "439:   atomic_set(&p->ip_id_count, secure_ip_id(daddr->addr.a4));",
      "",
      "[Added Lines]",
      "439:   atomic_set(&p->ip_id_count,",
      "440:     (daddr->family == AF_INET) ?",
      "441:      secure_ip_id(daddr->addr.a4) :",
      "442:      secure_ipv6_id(daddr->addr.a6));",
      "",
      "---------------"
    ],
    "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c": [
      "File: net/ipv6/ip6_output.c -> net/ipv6/ip6_output.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "596:  return offset;",
      "597: }",
      "599: int ip6_fragment(struct sk_buff *skb, int (*output)(struct sk_buff *))",
      "600: {",
      "601:  struct sk_buff *frag;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "599: void ipv6_select_ident(struct frag_hdr *fhdr, struct rt6_info *rt)",
      "600: {",
      "601:  static atomic_t ipv6_fragmentation_id;",
      "602:  int old, new;",
      "604:  if (rt) {",
      "605:   struct inet_peer *peer;",
      "607:   if (!rt->rt6i_peer)",
      "608:    rt6_bind_peer(rt, 1);",
      "609:   peer = rt->rt6i_peer;",
      "610:   if (peer) {",
      "611:    fhdr->identification = htonl(inet_getid(peer, 0));",
      "612:    return;",
      "613:   }",
      "614:  }",
      "615:  do {",
      "616:   old = atomic_read(&ipv6_fragmentation_id);",
      "617:   new = old + 1;",
      "618:   if (!new)",
      "619:    new = 1;",
      "620:  } while (atomic_cmpxchg(&ipv6_fragmentation_id, old, new) != old);",
      "621:  fhdr->identification = htonl(new);",
      "622: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "680:   skb_reset_network_header(skb);",
      "681:   memcpy(skb_network_header(skb), tmp_hdr, hlen);",
      "684:   fh->nexthdr = nexthdr;",
      "685:   fh->reserved = 0;",
      "686:   fh->frag_off = htons(IP6_MF);",
      "",
      "[Removed Lines]",
      "683:   ipv6_select_ident(fh);",
      "",
      "[Added Lines]",
      "708:   ipv6_select_ident(fh, rt);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "826:   fh->nexthdr = nexthdr;",
      "827:   fh->reserved = 0;",
      "828:   if (!frag_id) {",
      "830:    frag_id = fh->identification;",
      "831:   } else",
      "832:    fh->identification = frag_id;",
      "",
      "[Removed Lines]",
      "829:    ipv6_select_ident(fh);",
      "",
      "[Added Lines]",
      "854:    ipv6_select_ident(fh, rt);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1076:    int getfrag(void *from, char *to, int offset, int len,",
      "1077:    int odd, struct sk_buff *skb),",
      "1078:    void *from, int length, int hh_len, int fragheaderlen,",
      "1081: {",
      "1082:  struct sk_buff *skb;",
      "",
      "[Removed Lines]",
      "1079:    int transhdrlen, int mtu,unsigned int flags)",
      "",
      "[Added Lines]",
      "1104:    int transhdrlen, int mtu,unsigned int flags,",
      "1105:    struct rt6_info *rt)",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1120:   skb_shinfo(skb)->gso_size = (mtu - fragheaderlen -",
      "1121:           sizeof(struct frag_hdr)) & ~7;",
      "1122:   skb_shinfo(skb)->gso_type = SKB_GSO_UDP;",
      "1124:   skb_shinfo(skb)->ip6_frag_id = fhdr.identification;",
      "1125:   __skb_queue_tail(&sk->sk_write_queue, skb);",
      "",
      "[Removed Lines]",
      "1123:   ipv6_select_ident(&fhdr);",
      "",
      "[Added Lines]",
      "1149:   ipv6_select_ident(&fhdr, rt);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1287:    err = ip6_ufo_append_data(sk, getfrag, from, length,",
      "1288:         hh_len, fragheaderlen,",
      "1290:    if (err)",
      "1291:     goto error;",
      "1292:    return 0;",
      "",
      "[Removed Lines]",
      "1289:         transhdrlen, mtu, flags);",
      "",
      "[Added Lines]",
      "1315:         transhdrlen, mtu, flags, rt);",
      "",
      "---------------"
    ],
    "net/ipv6/udp.c||net/ipv6/udp.c": [
      "File: net/ipv6/udp.c -> net/ipv6/udp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1359:  fptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);",
      "1360:  fptr->nexthdr = nexthdr;",
      "1361:  fptr->reserved = 0;",
      "",
      "[Removed Lines]",
      "1362:  ipv6_select_ident(fptr);",
      "",
      "[Added Lines]",
      "1362:  ipv6_select_ident(fptr, (struct rt6_info *)skb_dst(skb));",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "fbfe95a42e90b3dd079cc9019ba7d7700feee0f6",
      "candidate_info": {
        "commit_hash": "fbfe95a42e90b3dd079cc9019ba7d7700feee0f6",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/fbfe95a42e90b3dd079cc9019ba7d7700feee0f6",
        "files": [
          "include/net/ip6_route.h",
          "include/net/route.h",
          "net/ipv4/icmp.c",
          "net/ipv4/route.c",
          "net/ipv4/tcp_ipv4.c",
          "net/ipv6/icmp.c",
          "net/ipv6/ip6_output.c",
          "net/ipv6/ndisc.c",
          "net/ipv6/route.c",
          "net/ipv6/tcp_ipv6.c"
        ],
        "message": "inet: Create and use rt{,6}_get_peer_create().\n\nThere's a lot of places that open-code rt{,6}_get_peer() only because\nthey want to set 'create' to one.  So add an rt{,6}_get_peer_create()\nfor their sake.\n\nThere were also a few spots open-coding plain rt{,6}_get_peer() and\nthose are transformed here as well.\n\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/net/ip6_route.h||include/net/ip6_route.h",
          "include/net/route.h||include/net/route.h",
          "net/ipv4/icmp.c||net/ipv4/icmp.c",
          "net/ipv4/route.c||net/ipv4/route.c",
          "net/ipv4/tcp_ipv4.c||net/ipv4/tcp_ipv4.c",
          "net/ipv6/icmp.c||net/ipv6/icmp.c",
          "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c",
          "net/ipv6/ndisc.c||net/ipv6/ndisc.c",
          "net/ipv6/route.c||net/ipv6/route.c",
          "net/ipv6/tcp_ipv6.c||net/ipv6/tcp_ipv6.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c"
          ],
          "candidate": [
            "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/ip6_route.h||include/net/ip6_route.h": [
          "File: include/net/ip6_route.h -> include/net/ip6_route.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "53:  return (flags >> 3) & 7;",
          "54: }",
          "60: {",
          "61:  if (rt->rt6i_peer)",
          "62:   return rt->rt6i_peer;",
          "65:  return rt->rt6i_peer;",
          "66: }",
          "68: extern void   ip6_route_input(struct sk_buff *skb);",
          "70: extern struct dst_entry * ip6_route_output(struct net *net,",
          "",
          "[Removed Lines]",
          "56: extern void   rt6_bind_peer(struct rt6_info *rt,",
          "57:            int create);",
          "59: static inline struct inet_peer *rt6_get_peer(struct rt6_info *rt)",
          "64:  rt6_bind_peer(rt, 0);",
          "",
          "[Added Lines]",
          "56: extern void rt6_bind_peer(struct rt6_info *rt, int create);",
          "58: static inline struct inet_peer *__rt6_get_peer(struct rt6_info *rt, int create)",
          "63:  rt6_bind_peer(rt, create);",
          "67: static inline struct inet_peer *rt6_get_peer(struct rt6_info *rt)",
          "68: {",
          "69:  return __rt6_get_peer(rt, 0);",
          "70: }",
          "72: static inline struct inet_peer *rt6_get_peer_create(struct rt6_info *rt)",
          "73: {",
          "74:  return __rt6_get_peer(rt, 1);",
          "75: }",
          "",
          "---------------"
        ],
        "include/net/route.h||include/net/route.h": [
          "File: include/net/route.h -> include/net/route.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "297: extern void rt_bind_peer(struct rtable *rt, __be32 daddr, int create);",
          "300: {",
          "301:  if (rt->peer)",
          "302:   return rt->peer;",
          "305:  return rt->peer;",
          "306: }",
          "308: static inline int inet_iif(const struct sk_buff *skb)",
          "309: {",
          "310:  return skb_rtable(skb)->rt_iif;",
          "",
          "[Removed Lines]",
          "299: static inline struct inet_peer *rt_get_peer(struct rtable *rt, __be32 daddr)",
          "304:  rt_bind_peer(rt, daddr, 0);",
          "",
          "[Added Lines]",
          "299: static inline struct inet_peer *__rt_get_peer(struct rtable *rt, __be32 daddr, int create)",
          "304:  rt_bind_peer(rt, daddr, create);",
          "308: static inline struct inet_peer *rt_get_peer(struct rtable *rt, __be32 daddr)",
          "309: {",
          "310:  return __rt_get_peer(rt, daddr, 0);",
          "311: }",
          "313: static inline struct inet_peer *rt_get_peer_create(struct rtable *rt, __be32 daddr)",
          "314: {",
          "315:  return __rt_get_peer(rt, daddr, 1);",
          "316: }",
          "",
          "---------------"
        ],
        "net/ipv4/icmp.c||net/ipv4/icmp.c": [
          "File: net/ipv4/icmp.c -> net/ipv4/icmp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "255:  if ((1 << type) & net->ipv4.sysctl_icmp_ratemask) {",
          "259:         net->ipv4.sysctl_icmp_ratelimit);",
          "260:  }",
          "261: out:",
          "",
          "[Removed Lines]",
          "256:   if (!rt->peer)",
          "257:    rt_bind_peer(rt, fl4->daddr, 1);",
          "258:   rc = inet_peer_xrlim_allow(rt->peer,",
          "",
          "[Added Lines]",
          "256:   struct inet_peer *peer = rt_get_peer_create(rt, fl4->daddr);",
          "257:   rc = inet_peer_xrlim_allow(peer,",
          "",
          "---------------"
        ],
        "net/ipv4/route.c||net/ipv4/route.c": [
          "File: net/ipv4/route.c -> net/ipv4/route.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "162:  struct inet_peer *peer;",
          "163:  u32 *p = NULL;",
          "169:  if (peer) {",
          "170:   u32 *old_p = __DST_METRICS_PTR(old);",
          "171:   unsigned long prev, new;",
          "",
          "[Removed Lines]",
          "165:  if (!rt->peer)",
          "166:   rt_bind_peer(rt, rt->rt_dst, 1);",
          "168:  peer = rt->peer;",
          "",
          "[Added Lines]",
          "165:  peer = rt_get_peer_create(rt, rt->rt_dst);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1364:  struct rtable *rt = (struct rtable *) dst;",
          "1366:  if (rt && !(rt->dst.flags & DST_NOPEER)) {",
          "1371:      so that we need not to grab a lock to dereference it.",
          "1375:    return;",
          "1376:   }",
          "1377:  } else if (!rt)",
          "",
          "[Removed Lines]",
          "1367:   if (rt->peer == NULL)",
          "1368:    rt_bind_peer(rt, rt->rt_dst, 1);",
          "1373:   if (rt->peer) {",
          "1374:    iph->id = htons(inet_getid(rt->peer, more));",
          "",
          "[Added Lines]",
          "1364:   struct inet_peer *peer = rt_get_peer_create(rt, rt->rt_dst);",
          "1369:   if (peer) {",
          "1370:    iph->id = htons(inet_getid(peer, more));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1481:         rt->rt_gateway != old_gw)",
          "1482:      continue;",
          "1488:     if (peer) {",
          "1489:      if (peer->redirect_learned.a4 != new_gw) {",
          "1490:       peer->redirect_learned.a4 = new_gw;",
          "",
          "[Removed Lines]",
          "1484:     if (!rt->peer)",
          "1485:      rt_bind_peer(rt, rt->rt_dst, 1);",
          "1487:     peer = rt->peer;",
          "",
          "[Added Lines]",
          "1480:     peer = rt_get_peer_create(rt, rt->rt_dst);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1579:  log_martians = IN_DEV_LOG_MARTIANS(in_dev);",
          "1580:  rcu_read_unlock();",
          "1585:  if (!peer) {",
          "1586:   icmp_send(skb, ICMP_REDIRECT, ICMP_REDIR_HOST, rt->rt_gateway);",
          "1587:   return;",
          "",
          "[Removed Lines]",
          "1582:  if (!rt->peer)",
          "1583:   rt_bind_peer(rt, rt->rt_dst, 1);",
          "1584:  peer = rt->peer;",
          "",
          "[Added Lines]",
          "1575:  peer = rt_get_peer_create(rt, rt->rt_dst);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1646:   break;",
          "1647:  }",
          "1653:  send = true;",
          "1654:  if (peer) {",
          "",
          "[Removed Lines]",
          "1649:  if (!rt->peer)",
          "1650:   rt_bind_peer(rt, rt->rt_dst, 1);",
          "1651:  peer = rt->peer;",
          "",
          "[Added Lines]",
          "1640:  peer = rt_get_peer_create(rt, rt->rt_dst);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1755:  dst_confirm(dst);",
          "1760:  if (peer) {",
          "1761:   unsigned long pmtu_expires = ACCESS_ONCE(peer->pmtu_expires);",
          "",
          "[Removed Lines]",
          "1757:  if (!rt->peer)",
          "1758:   rt_bind_peer(rt, rt->rt_dst, 1);",
          "1759:  peer = rt->peer;",
          "",
          "[Added Lines]",
          "1746:  peer = rt_get_peer_create(rt, rt->rt_dst);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1782: static void ipv4_validate_peer(struct rtable *rt)",
          "1783: {",
          "1784:  if (rt->rt_peer_genid != rt_peer_genid()) {",
          "1791:   if (peer) {",
          "1792:    check_peer_pmtu(&rt->dst, peer);",
          "",
          "[Removed Lines]",
          "1785:   struct inet_peer *peer;",
          "1787:   if (!rt->peer)",
          "1788:    rt_bind_peer(rt, rt->rt_dst, 0);",
          "1790:   peer = rt->peer;",
          "",
          "[Added Lines]",
          "1772:   struct inet_peer *peer = rt_get_peer(rt, rt->rt_dst);",
          "",
          "---------------"
        ],
        "net/ipv4/tcp_ipv4.c||net/ipv4/tcp_ipv4.c": [
          "File: net/ipv4/tcp_ipv4.c -> net/ipv4/tcp_ipv4.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1832:   peer = inet_getpeer_v4(net, inet->inet_daddr, 1);",
          "1834:  } else {",
          "1839:  }",
          "",
          "[Removed Lines]",
          "1835:   if (!rt->peer)",
          "1836:    rt_bind_peer(rt, inet->inet_daddr, 1);",
          "1837:   peer = rt->peer;",
          "",
          "[Added Lines]",
          "1835:   peer = rt_get_peer_create(rt, inet->inet_daddr);",
          "",
          "---------------"
        ],
        "net/ipv6/icmp.c||net/ipv6/icmp.c": [
          "File: net/ipv6/icmp.c -> net/ipv6/icmp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "188:  } else {",
          "189:   struct rt6_info *rt = (struct rt6_info *)dst;",
          "190:   int tmo = net->ipv6.sysctl.icmpv6_time;",
          "193:   if (rt->rt6i_dst.plen < 128)",
          "194:    tmo >>= ((128 - rt->rt6i_dst.plen)>>5);",
          "199:  }",
          "200:  dst_release(dst);",
          "201:  return res;",
          "",
          "[Removed Lines]",
          "196:   if (!rt->rt6i_peer)",
          "197:    rt6_bind_peer(rt, 1);",
          "198:   res = inet_peer_xrlim_allow(rt->rt6i_peer, tmo);",
          "",
          "[Added Lines]",
          "191:   struct inet_peer *peer;",
          "197:   peer = rt6_get_peer_create(rt);",
          "198:   res = inet_peer_xrlim_allow(peer, tmo);",
          "",
          "---------------"
        ],
        "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c": [
          "File: net/ipv6/ip6_output.c -> net/ipv6/ip6_output.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "464:  if (skb->dev == dst->dev && opt->srcrt == 0 && !skb_sec_path(skb)) {",
          "465:   struct in6_addr *target = NULL;",
          "466:   struct rt6_info *rt;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "466:   struct inet_peer *peer;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "476:   else",
          "477:    target = &hdr->daddr;",
          "483:      and by source (inside ndisc_send_redirect)",
          "486:    ndisc_send_redirect(skb, target);",
          "487:  } else {",
          "488:   int addrtype = ipv6_addr_type(&hdr->saddr);",
          "",
          "[Removed Lines]",
          "479:   if (!rt->rt6i_peer)",
          "480:    rt6_bind_peer(rt, 1);",
          "485:   if (inet_peer_xrlim_allow(rt->rt6i_peer, 1*HZ))",
          "",
          "[Added Lines]",
          "480:   peer = rt6_get_peer_create(rt);",
          "485:   if (inet_peer_xrlim_allow(peer, 1*HZ))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "602:  int old, new;",
          "604:  if (rt && !(rt->dst.flags & DST_NOPEER)) {",
          "610:   if (peer) {",
          "611:    fhdr->identification = htonl(inet_getid(peer, 0));",
          "612:    return;",
          "",
          "[Removed Lines]",
          "605:   struct inet_peer *peer;",
          "607:   if (!rt->rt6i_peer)",
          "608:    rt6_bind_peer(rt, 1);",
          "609:   peer = rt->rt6i_peer;",
          "",
          "[Added Lines]",
          "605:   struct inet_peer *peer = rt6_get_peer_create(rt);",
          "",
          "---------------"
        ],
        "net/ipv6/ndisc.c||net/ipv6/ndisc.c": [
          "File: net/ipv6/ndisc.c -> net/ipv6/ndisc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1472:  struct net *net = dev_net(dev);",
          "1473:  struct sock *sk = net->ipv6.ndisc_sk;",
          "1474:  int len = sizeof(struct icmp6hdr) + 2 * sizeof(struct in6_addr);",
          "1475:  struct sk_buff *buff;",
          "1476:  struct icmp6hdr *icmph;",
          "1477:  struct in6_addr saddr_buf;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1475:  struct inet_peer *peer;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1518:      \"Redirect: destination is not a neighbour\\n\");",
          "1519:   goto release;",
          "1520:  }",
          "1524:   goto release;",
          "1526:  if (dev->addr_len) {",
          "",
          "[Removed Lines]",
          "1521:  if (!rt->rt6i_peer)",
          "1522:   rt6_bind_peer(rt, 1);",
          "1523:  if (!inet_peer_xrlim_allow(rt->rt6i_peer, 1*HZ))",
          "",
          "[Added Lines]",
          "1522:  peer = rt6_get_peer_create(rt);",
          "1523:  if (!inet_peer_xrlim_allow(peer, 1*HZ))",
          "",
          "---------------"
        ],
        "net/ipv6/route.c||net/ipv6/route.c": [
          "File: net/ipv6/route.c -> net/ipv6/route.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "99:  if (!(rt->dst.flags & DST_HOST))",
          "100:   return NULL;",
          "106:  if (peer) {",
          "107:   u32 *old_p = __DST_METRICS_PTR(old);",
          "108:   unsigned long prev, new;",
          "",
          "[Removed Lines]",
          "102:  if (!rt->rt6i_peer)",
          "103:   rt6_bind_peer(rt, 1);",
          "105:  peer = rt->rt6i_peer;",
          "",
          "[Added Lines]",
          "102:  peer = rt6_get_peer_create(rt);",
          "",
          "---------------"
        ],
        "net/ipv6/tcp_ipv6.c||net/ipv6/tcp_ipv6.c": [
          "File: net/ipv6/tcp_ipv6.c -> net/ipv6/tcp_ipv6.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1744:   peer = inet_getpeer_v6(net, &np->daddr, 1);",
          "1746:  } else {",
          "1751:  }",
          "",
          "[Removed Lines]",
          "1747:   if (!rt->rt6i_peer)",
          "1748:    rt6_bind_peer(rt, 1);",
          "1749:   peer = rt->rt6i_peer;",
          "",
          "[Added Lines]",
          "1747:   peer = rt6_get_peer_create(rt);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1d861aa4b3fb08822055345f480850205ffe6170",
      "candidate_info": {
        "commit_hash": "1d861aa4b3fb08822055345f480850205ffe6170",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1d861aa4b3fb08822055345f480850205ffe6170",
        "files": [
          "net/ipv4/icmp.c",
          "net/ipv4/route.c",
          "net/ipv6/icmp.c",
          "net/ipv6/ip6_output.c",
          "net/ipv6/ndisc.c"
        ],
        "message": "inet: Minimize use of cached route inetpeer.\n\nOnly use it in the absolutely required cases:\n\n1) COW'ing metrics\n\n2) ipv4 PMTU\n\n3) ipv4 redirects\n\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv4/icmp.c||net/ipv4/icmp.c",
          "net/ipv4/route.c||net/ipv4/route.c",
          "net/ipv6/icmp.c||net/ipv6/icmp.c",
          "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c",
          "net/ipv6/ndisc.c||net/ipv6/ndisc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c"
          ],
          "candidate": [
            "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ipv4/icmp.c||net/ipv4/icmp.c": [
          "File: net/ipv4/icmp.c -> net/ipv4/icmp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "256:  if ((1 << type) & net->ipv4.sysctl_icmp_ratemask) {",
          "258:   rc = inet_peer_xrlim_allow(peer,",
          "259:         net->ipv4.sysctl_icmp_ratelimit);",
          "260:  }",
          "261: out:",
          "262:  return rc;",
          "",
          "[Removed Lines]",
          "257:   struct inet_peer *peer = rt_get_peer_create(rt, fl4->daddr);",
          "",
          "[Added Lines]",
          "257:   struct inet_peer *peer = inet_getpeer_v4(net->ipv4.peers, fl4->daddr, 1);",
          "260:   inet_putpeer(peer);",
          "",
          "---------------"
        ],
        "net/ipv4/route.c||net/ipv4/route.c": [
          "File: net/ipv4/route.c -> net/ipv4/route.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1290: void __ip_select_ident(struct iphdr *iph, struct dst_entry *dst, int more)",
          "1291: {",
          "1307:  ip_select_fb_ident(iph);",
          "1308: }",
          "",
          "[Removed Lines]",
          "1292:  struct rtable *rt = (struct rtable *) dst;",
          "1294:  if (rt && !(rt->dst.flags & DST_NOPEER)) {",
          "1295:   struct inet_peer *peer = rt_get_peer_create(rt, rt->rt_dst);",
          "1298:      so that we need not to grab a lock to dereference it.",
          "1300:   if (peer) {",
          "1301:    iph->id = htons(inet_getid(peer, more));",
          "1302:    return;",
          "1303:   }",
          "1304:  } else if (!rt)",
          "1305:   pr_debug(\"rt_bind_peer(0) @%p\\n\", __builtin_return_address(0));",
          "",
          "[Added Lines]",
          "1292:  struct net *net = dev_net(dst->dev);",
          "1293:  struct inet_peer *peer;",
          "1295:  peer = inet_getpeer_v4(net->ipv4.peers, iph->daddr, 1);",
          "1296:  if (peer) {",
          "1297:   iph->id = htons(inet_getid(peer, more));",
          "1298:   inet_putpeer(peer);",
          "1299:   return;",
          "1300:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1492:  struct rtable *rt = skb_rtable(skb);",
          "1493:  struct in_device *in_dev;",
          "1494:  struct inet_peer *peer;",
          "1495:  int log_martians;",
          "1497:  rcu_read_lock();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1490:  struct net *net;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1503:  log_martians = IN_DEV_LOG_MARTIANS(in_dev);",
          "1504:  rcu_read_unlock();",
          "1507:  if (!peer) {",
          "1508:   icmp_send(skb, ICMP_REDIRECT, ICMP_REDIR_HOST, rt->rt_gateway);",
          "1509:   return;",
          "",
          "[Removed Lines]",
          "1506:  peer = rt_get_peer_create(rt, rt->rt_dst);",
          "",
          "[Added Lines]",
          "1502:  net = dev_net(rt->dst.dev);",
          "1503:  peer = inet_getpeer_v4(net->ipv4.peers, ip_hdr(skb)->saddr, 1);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1521:  if (peer->rate_tokens >= ip_rt_redirect_number) {",
          "1522:   peer->rate_last = jiffies;",
          "1524:  }",
          "",
          "[Removed Lines]",
          "1523:   return;",
          "",
          "[Added Lines]",
          "1520:   goto out_put_peer;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1541:           &rt->rt_dst, &rt->rt_gateway);",
          "1542: #endif",
          "1543:  }",
          "1544: }",
          "1546: static int ip_error(struct sk_buff *skb)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1541: out_put_peer:",
          "1542:  inet_putpeer(peer);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1583:   break;",
          "1584:  }",
          "1588:  send = true;",
          "1589:  if (peer) {",
          "",
          "[Removed Lines]",
          "1586:  peer = rt_get_peer_create(rt, rt->rt_dst);",
          "",
          "[Added Lines]",
          "1585:  peer = inet_getpeer_v4(net->ipv4.peers, ip_hdr(skb)->saddr, 1);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1596:    peer->rate_tokens -= ip_rt_error_cost;",
          "1597:   else",
          "1598:    send = false;",
          "1599:  }",
          "1600:  if (send)",
          "1601:   icmp_send(skb, ICMP_DEST_UNREACH, code, 0);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1598:   inet_putpeer(peer);",
          "",
          "---------------"
        ],
        "net/ipv6/icmp.c||net/ipv6/icmp.c": [
          "File: net/ipv6/icmp.c -> net/ipv6/icmp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "194:   if (rt->rt6i_dst.plen < 128)",
          "195:    tmo >>= ((128 - rt->rt6i_dst.plen)>>5);",
          "198:   res = inet_peer_xrlim_allow(peer, tmo);",
          "199:  }",
          "200:  dst_release(dst);",
          "201:  return res;",
          "",
          "[Removed Lines]",
          "197:   peer = rt6_get_peer_create(rt);",
          "",
          "[Added Lines]",
          "197:   peer = inet_getpeer_v6(net->ipv6.peers, &rt->rt6i_dst.addr, 1);",
          "199:   if (peer)",
          "200:    inet_putpeer(peer);",
          "",
          "---------------"
        ],
        "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c": [
          "File: net/ipv6/ip6_output.c -> net/ipv6/ip6_output.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "466:   else",
          "467:    target = &hdr->daddr;",
          "472:      and by source (inside ndisc_send_redirect)",
          "474:   if (inet_peer_xrlim_allow(peer, 1*HZ))",
          "475:    ndisc_send_redirect(skb, target);",
          "476:  } else {",
          "477:   int addrtype = ipv6_addr_type(&hdr->saddr);",
          "",
          "[Removed Lines]",
          "469:   peer = rt6_get_peer_create(rt);",
          "",
          "[Added Lines]",
          "469:   peer = inet_getpeer_v6(net->ipv6.peers, &rt->rt6i_dst.addr, 1);",
          "476:   if (peer)",
          "477:    inet_putpeer(peer);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "592:  int old, new;",
          "594:  if (rt && !(rt->dst.flags & DST_NOPEER)) {",
          "597:   if (peer) {",
          "598:    fhdr->identification = htonl(inet_getid(peer, 0));",
          "599:    return;",
          "600:   }",
          "601:  }",
          "",
          "[Removed Lines]",
          "595:   struct inet_peer *peer = rt6_get_peer_create(rt);",
          "",
          "[Added Lines]",
          "597:   struct inet_peer *peer;",
          "598:   struct net *net;",
          "600:   net = dev_net(rt->dst.dev);",
          "601:   peer = inet_getpeer_v6(net->ipv6.peers, &rt->rt6i_dst.addr, 1);",
          "604:    inet_putpeer(peer);",
          "",
          "---------------"
        ],
        "net/ipv6/ndisc.c||net/ipv6/ndisc.c": [
          "File: net/ipv6/ndisc.c -> net/ipv6/ndisc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1486:  int rd_len;",
          "1487:  int err;",
          "1488:  u8 ha_buf[MAX_ADDR_LEN], *ha = NULL;",
          "1490:  if (ipv6_get_lladdr(dev, &saddr_buf, IFA_F_TENTATIVE)) {",
          "1491:   ND_PRINTK(2, warn, \"Redirect: no link-local address on %s\\n\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1489:  bool ret;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1519:      \"Redirect: destination is not a neighbour\\n\");",
          "1520:   goto release;",
          "1521:  }",
          "1524:   goto release;",
          "1526:  if (dev->addr_len) {",
          "",
          "[Removed Lines]",
          "1522:  peer = rt6_get_peer_create(rt);",
          "1523:  if (!inet_peer_xrlim_allow(peer, 1*HZ))",
          "",
          "[Added Lines]",
          "1523:  peer = inet_getpeer_v6(net->ipv6.peers, &rt->rt6i_dst.addr, 1);",
          "1524:  ret = inet_peer_xrlim_allow(peer, 1*HZ);",
          "1525:  if (peer)",
          "1526:   inet_putpeer(peer);",
          "1527:  if (!ret)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c0efc887dcadbdbfe171f028acfab9c7c00e9dde",
      "candidate_info": {
        "commit_hash": "c0efc887dcadbdbfe171f028acfab9c7c00e9dde",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c0efc887dcadbdbfe171f028acfab9c7c00e9dde",
        "files": [
          "include/net/inetpeer.h",
          "net/ipv4/inetpeer.c",
          "net/ipv4/ip_fragment.c",
          "net/ipv4/route.c",
          "net/ipv6/route.c"
        ],
        "message": "inet: Pass inetpeer root into inet_getpeer*() interfaces.\n\nOtherwise we reference potentially non-existing members when\nipv6 is disabled.\n\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/net/inetpeer.h||include/net/inetpeer.h",
          "net/ipv4/inetpeer.c||net/ipv4/inetpeer.c",
          "net/ipv4/ip_fragment.c||net/ipv4/ip_fragment.c",
          "net/ipv4/route.c||net/ipv4/route.c",
          "net/ipv6/route.c||net/ipv6/route.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/net/inetpeer.h||include/net/inetpeer.h",
            "net/ipv4/inetpeer.c||net/ipv4/inetpeer.c"
          ],
          "candidate": [
            "include/net/inetpeer.h||include/net/inetpeer.h",
            "net/ipv4/inetpeer.c||net/ipv4/inetpeer.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/inetpeer.h||include/net/inetpeer.h": [
          "File: include/net/inetpeer.h -> include/net/inetpeer.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "83: }",
          "87:           const struct inetpeer_addr *daddr,",
          "88:           int create);",
          "91:       __be32 v4daddr,",
          "92:       int create)",
          "93: {",
          "",
          "[Removed Lines]",
          "86: struct inet_peer *inet_getpeer(struct net *net,",
          "90: static inline struct inet_peer *inet_getpeer_v4(struct net *net,",
          "",
          "[Added Lines]",
          "86: struct inet_peer *inet_getpeer(struct inet_peer_base *base,",
          "90: static inline struct inet_peer *inet_getpeer_v4(struct inet_peer_base *base,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "96:  daddr.addr.a4 = v4daddr;",
          "97:  daddr.family = AF_INET;",
          "99: }",
          "102:       const struct in6_addr *v6daddr,",
          "103:       int create)",
          "104: {",
          "",
          "[Removed Lines]",
          "98:  return inet_getpeer(net, &daddr, create);",
          "101: static inline struct inet_peer *inet_getpeer_v6(struct net *net,",
          "",
          "[Added Lines]",
          "98:  return inet_getpeer(base, &daddr, create);",
          "101: static inline struct inet_peer *inet_getpeer_v6(struct inet_peer_base *base,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "108:  daddr.family = AF_INET6;",
          "110: }",
          "",
          "[Removed Lines]",
          "109:  return inet_getpeer(net, &daddr, create);",
          "",
          "[Added Lines]",
          "109:  return inet_getpeer(base, &daddr, create);",
          "",
          "---------------"
        ],
        "net/ipv4/inetpeer.c||net/ipv4/inetpeer.c": [
          "File: net/ipv4/inetpeer.c -> net/ipv4/inetpeer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "391:  call_rcu(&p->rcu, inetpeer_free_rcu);",
          "392: }",
          "401: static int inet_peer_gc(struct inet_peer_base *base,",
          "402:    struct inet_peer __rcu **stack[PEER_MAXDEPTH],",
          "",
          "[Removed Lines]",
          "394: static struct inet_peer_base *family_to_base(struct net *net,",
          "395:           int family)",
          "396: {",
          "397:  return family == AF_INET ? net->ipv4.peers : net->ipv6.peers;",
          "398: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "434:  return cnt;",
          "435: }",
          "438:           const struct inetpeer_addr *daddr,",
          "439:           int create)",
          "440: {",
          "441:  struct inet_peer __rcu **stack[PEER_MAXDEPTH], ***stackptr;",
          "443:  struct inet_peer *p;",
          "444:  unsigned int sequence;",
          "445:  int invalidated, gccnt = 0;",
          "",
          "[Removed Lines]",
          "437: struct inet_peer *inet_getpeer(struct net *net,",
          "442:  struct inet_peer_base *base = family_to_base(net, daddr->family);",
          "",
          "[Added Lines]",
          "431: struct inet_peer *inet_getpeer(struct inet_peer_base *base,",
          "",
          "---------------"
        ],
        "net/ipv4/ip_fragment.c||net/ipv4/ip_fragment.c": [
          "File: net/ipv4/ip_fragment.c -> net/ipv4/ip_fragment.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "184:  qp->daddr = arg->iph->daddr;",
          "185:  qp->user = arg->user;",
          "186:  qp->peer = sysctl_ipfrag_max_dist ?",
          "188: }",
          "190: static __inline__ void ip4_frag_free(struct inet_frag_queue *q)",
          "",
          "[Removed Lines]",
          "187:   inet_getpeer_v4(net, arg->iph->saddr, 1) : NULL;",
          "",
          "[Added Lines]",
          "187:   inet_getpeer_v4(net->ipv4.peers, arg->iph->saddr, 1) : NULL;",
          "",
          "---------------"
        ],
        "net/ipv4/route.c||net/ipv4/route.c": [
          "File: net/ipv4/route.c -> net/ipv4/route.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1328:  struct net *net = dev_net(rt->dst.dev);",
          "1329:  struct inet_peer *peer;",
          "1333:  if (peer && cmpxchg(&rt->peer, NULL, peer) != NULL)",
          "1334:   inet_putpeer(peer);",
          "",
          "[Removed Lines]",
          "1331:  peer = inet_getpeer_v4(net, daddr, create);",
          "",
          "[Added Lines]",
          "1331:  peer = inet_getpeer_v4(net->ipv4.peers, daddr, create);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1684:  unsigned short est_mtu = 0;",
          "1685:  struct inet_peer *peer;",
          "1688:  if (peer) {",
          "1689:   unsigned short mtu = new_mtu;",
          "",
          "[Removed Lines]",
          "1687:  peer = inet_getpeer_v4(net, iph->daddr, 1);",
          "",
          "[Added Lines]",
          "1687:  peer = inet_getpeer_v4(net->ipv4.peers, iph->daddr, 1);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1929:  if (fl4 && (fl4->flowi4_flags & FLOWI_FLAG_PRECOW_METRICS))",
          "1930:   create = 1;",
          "1933:  if (peer) {",
          "1934:   rt->rt_peer_genid = rt_peer_genid();",
          "1935:   if (inet_metrics_new(peer))",
          "",
          "[Removed Lines]",
          "1932:  rt->peer = peer = inet_getpeer_v4(net, rt->rt_dst, create);",
          "",
          "[Added Lines]",
          "1932:  rt->peer = peer = inet_getpeer_v4(net->ipv4.peers, rt->rt_dst, create);",
          "",
          "---------------"
        ],
        "net/ipv6/route.c||net/ipv6/route.c": [
          "File: net/ipv6/route.c -> net/ipv6/route.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "306:  struct net *net = dev_net(rt->dst.dev);",
          "307:  struct inet_peer *peer;",
          "310:  if (peer && cmpxchg(&rt->rt6i_peer, NULL, peer) != NULL)",
          "311:   inet_putpeer(peer);",
          "312:  else",
          "",
          "[Removed Lines]",
          "309:  peer = inet_getpeer_v6(net, &rt->rt6i_dst.addr, create);",
          "",
          "[Added Lines]",
          "309:  peer = inet_getpeer_v6(net->ipv6.peers, &rt->rt6i_dst.addr, create);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "68d0c6d34d586a893292d4fb633a3bf8c547b222",
      "candidate_info": {
        "commit_hash": "68d0c6d34d586a893292d4fb633a3bf8c547b222",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/68d0c6d34d586a893292d4fb633a3bf8c547b222",
        "files": [
          "include/net/ipv6.h",
          "net/dccp/ipv6.c",
          "net/ipv6/af_inet6.c",
          "net/ipv6/datagram.c",
          "net/ipv6/inet6_connection_sock.c",
          "net/ipv6/ip6_output.c",
          "net/ipv6/raw.c",
          "net/ipv6/syncookies.c",
          "net/ipv6/tcp_ipv6.c",
          "net/ipv6/udp.c"
        ],
        "message": "ipv6: Consolidate route lookup sequences.\n\nRoute lookups follow a general pattern in the ipv6 code wherein\nwe first find the non-IPSEC route, potentially override the\nflow destination address due to ipv6 options settings, and then\nfinally make an IPSEC search using either xfrm_lookup() or\n__xfrm_lookup().\n\n__xfrm_lookup() is used when we want to generate a blackhole route\nif the key manager needs to resolve the IPSEC rules (in this case\n-EREMOTE is returned and the original 'dst' is left unchanged).\n\nOtherwise plain xfrm_lookup() is used and when asynchronous IPSEC\nresolution is necessary, we simply fail the lookup completely.\n\nAll of these cases are encapsulated into two routines,\nip6_dst_lookup_flow and ip6_sk_dst_lookup_flow.  The latter of which\nhandles unconnected UDP datagram sockets.\n\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/net/ipv6.h||include/net/ipv6.h",
          "net/dccp/ipv6.c||net/dccp/ipv6.c",
          "net/ipv6/af_inet6.c||net/ipv6/af_inet6.c",
          "net/ipv6/datagram.c||net/ipv6/datagram.c",
          "net/ipv6/inet6_connection_sock.c||net/ipv6/inet6_connection_sock.c",
          "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c",
          "net/ipv6/raw.c||net/ipv6/raw.c",
          "net/ipv6/syncookies.c||net/ipv6/syncookies.c",
          "net/ipv6/tcp_ipv6.c||net/ipv6/tcp_ipv6.c",
          "net/ipv6/udp.c||net/ipv6/udp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/net/ipv6.h||include/net/ipv6.h",
            "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c",
            "net/ipv6/udp.c||net/ipv6/udp.c"
          ],
          "candidate": [
            "include/net/ipv6.h||include/net/ipv6.h",
            "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c",
            "net/ipv6/udp.c||net/ipv6/udp.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/ipv6.h||include/net/ipv6.h": [
          "File: include/net/ipv6.h -> include/net/ipv6.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "512: extern int   ip6_dst_lookup(struct sock *sk,",
          "513:             struct dst_entry **dst,",
          "514:             struct flowi *fl);",
          "515: extern int   ip6_dst_blackhole(struct sock *sk,",
          "516:         struct dst_entry **dst,",
          "517:         struct flowi *fl);",
          "",
          "[Removed Lines]",
          "518: extern int   ip6_sk_dst_lookup(struct sock *sk,",
          "519:         struct dst_entry **dst,",
          "520:         struct flowi *fl);",
          "",
          "[Added Lines]",
          "515: extern struct dst_entry * ip6_dst_lookup_flow(struct sock *sk,",
          "516:           struct flowi *fl,",
          "517:           const struct in6_addr *final_dst,",
          "518:           bool want_blackhole);",
          "519: extern struct dst_entry * ip6_sk_dst_lookup_flow(struct sock *sk,",
          "520:              struct flowi *fl,",
          "521:              const struct in6_addr *final_dst,",
          "522:              bool want_blackhole);",
          "",
          "---------------"
        ],
        "net/dccp/ipv6.c||net/dccp/ipv6.c": [
          "File: net/dccp/ipv6.c -> net/dccp/ipv6.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "162:    fl.fl_ip_sport = inet->inet_sport;",
          "163:    security_sk_classify_flow(sk, &fl);",
          "174:     goto out;",
          "175:    }",
          "176:   } else",
          "",
          "[Removed Lines]",
          "165:    err = ip6_dst_lookup(sk, &dst, &fl);",
          "166:    if (err) {",
          "167:     sk->sk_err_soft = -err;",
          "168:     goto out;",
          "169:    }",
          "171:    err = xfrm_lookup(net, &dst, &fl, sk, 0);",
          "172:    if (err < 0) {",
          "173:     sk->sk_err_soft = -err;",
          "",
          "[Added Lines]",
          "165:    dst = ip6_dst_lookup_flow(sk, &fl, NULL, false);",
          "166:    if (IS_ERR(dst)) {",
          "167:     sk->sk_err_soft = -PTR_ERR(dst);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "268:  final_p = fl6_update_dst(&fl, opt, &final);",
          "279:   goto done;",
          "281:  skb = dccp_make_response(sk, dst, req);",
          "282:  if (skb != NULL) {",
          "",
          "[Removed Lines]",
          "270:  err = ip6_dst_lookup(sk, &dst, &fl);",
          "271:  if (err)",
          "272:   goto done;",
          "274:  if (final_p)",
          "275:   ipv6_addr_copy(&fl.fl6_dst, final_p);",
          "277:  err = xfrm_lookup(sock_net(sk), &dst, &fl, sk, 0);",
          "278:  if (err < 0)",
          "",
          "[Added Lines]",
          "264:  dst = ip6_dst_lookup_flow(sk, &fl, final_p, false);",
          "265:  if (IS_ERR(dst)) {",
          "266:   err = PTR_ERR(dst);",
          "267:   dst = NULL;",
          "269:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "338:  security_skb_classify_flow(rxskb, &fl);",
          "349:  }",
          "351:  kfree_skb(skb);",
          "",
          "[Removed Lines]",
          "341:  if (!ip6_dst_lookup(ctl_sk, &dst, &fl)) {",
          "342:   if (xfrm_lookup(net, &dst, &fl, NULL, 0) >= 0) {",
          "343:    skb_dst_set(skb, dst);",
          "344:    ip6_xmit(ctl_sk, skb, &fl, NULL);",
          "345:    DCCP_INC_STATS_BH(DCCP_MIB_OUTSEGS);",
          "346:    DCCP_INC_STATS_BH(DCCP_MIB_OUTRSTS);",
          "347:    return;",
          "348:   }",
          "",
          "[Added Lines]",
          "331:  dst = ip6_dst_lookup_flow(ctl_sk, &fl, NULL, false);",
          "332:  if (!IS_ERR(dst)) {",
          "333:   skb_dst_set(skb, dst);",
          "334:   ip6_xmit(ctl_sk, skb, &fl, NULL);",
          "335:   DCCP_INC_STATS_BH(DCCP_MIB_OUTSEGS);",
          "336:   DCCP_INC_STATS_BH(DCCP_MIB_OUTRSTS);",
          "337:   return;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "550:   fl.fl_ip_sport = inet_rsk(req)->loc_port;",
          "551:   security_sk_classify_flow(sk, &fl);",
          "560:    goto out;",
          "561:  }",
          "",
          "[Removed Lines]",
          "553:   if (ip6_dst_lookup(sk, &dst, &fl))",
          "554:    goto out;",
          "556:   if (final_p)",
          "557:    ipv6_addr_copy(&fl.fl6_dst, final_p);",
          "559:   if ((xfrm_lookup(sock_net(sk), &dst, &fl, sk, 0)) < 0)",
          "",
          "[Added Lines]",
          "542:   dst = ip6_dst_lookup_flow(sk, &fl, final_p, false);",
          "543:   if (IS_ERR(dst))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "980:  final_p = fl6_update_dst(&fl, np->opt, &final);",
          "984:   goto failure;",
          "995:  }",
          "997:  if (saddr == NULL) {",
          "",
          "[Removed Lines]",
          "982:  err = ip6_dst_lookup(sk, &dst, &fl);",
          "983:  if (err)",
          "986:  if (final_p)",
          "987:   ipv6_addr_copy(&fl.fl6_dst, final_p);",
          "989:  err = __xfrm_lookup(sock_net(sk), &dst, &fl, sk, XFRM_LOOKUP_WAIT);",
          "990:  if (err < 0) {",
          "991:   if (err == -EREMOTE)",
          "992:    err = ip6_dst_blackhole(sk, &dst, &fl);",
          "993:   if (err < 0)",
          "994:    goto failure;",
          "",
          "[Added Lines]",
          "966:  dst = ip6_dst_lookup_flow(sk, &fl, final_p, true);",
          "967:  if (IS_ERR(dst)) {",
          "968:   err = PTR_ERR(dst);",
          "",
          "---------------"
        ],
        "net/ipv6/af_inet6.c||net/ipv6/af_inet6.c": [
          "File: net/ipv6/af_inet6.c -> net/ipv6/af_inet6.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "645: int inet6_sk_rebuild_header(struct sock *sk)",
          "646: {",
          "649:  struct ipv6_pinfo *np = inet6_sk(sk);",
          "651:  dst = __sk_dst_check(sk, np->dst_cookie);",
          "",
          "[Removed Lines]",
          "647:  int err;",
          "648:  struct dst_entry *dst;",
          "",
          "[Added Lines]",
          "648:  struct dst_entry *dst;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "669:   final_p = fl6_update_dst(&fl, np->opt, &final);",
          "673:    sk->sk_route_caps = 0;",
          "682:   }",
          "684:   __ip6_dst_store(sk, dst, NULL, NULL);",
          "",
          "[Removed Lines]",
          "671:   err = ip6_dst_lookup(sk, &dst, &fl);",
          "672:   if (err) {",
          "674:    return err;",
          "675:   }",
          "676:   if (final_p)",
          "677:    ipv6_addr_copy(&fl.fl6_dst, final_p);",
          "679:   if ((err = xfrm_lookup(sock_net(sk), &dst, &fl, sk, 0)) < 0) {",
          "680:    sk->sk_err_soft = -err;",
          "681:    return err;",
          "",
          "[Added Lines]",
          "670:   dst = ip6_dst_lookup_flow(sk, &fl, final_p, false);",
          "671:   if (IS_ERR(dst)) {",
          "673:    sk->sk_err_soft = -PTR_ERR(dst);",
          "674:    return PTR_ERR(dst);",
          "",
          "---------------"
        ],
        "net/ipv6/datagram.c||net/ipv6/datagram.c": [
          "File: net/ipv6/datagram.c -> net/ipv6/datagram.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "162:  opt = flowlabel ? flowlabel->opt : np->opt;",
          "163:  final_p = fl6_update_dst(&fl, opt, &final);",
          "167:   goto out;",
          "177:  }",
          "",
          "[Removed Lines]",
          "165:  err = ip6_dst_lookup(sk, &dst, &fl);",
          "166:  if (err)",
          "168:  if (final_p)",
          "169:   ipv6_addr_copy(&fl.fl6_dst, final_p);",
          "171:  err = __xfrm_lookup(sock_net(sk), &dst, &fl, sk, XFRM_LOOKUP_WAIT);",
          "172:  if (err < 0) {",
          "173:   if (err == -EREMOTE)",
          "174:    err = ip6_dst_blackhole(sk, &dst, &fl);",
          "175:   if (err < 0)",
          "176:    goto out;",
          "",
          "[Added Lines]",
          "165:  dst = ip6_dst_lookup_flow(sk, &fl, final_p, true);",
          "166:  err = 0;",
          "167:  if (IS_ERR(dst)) {",
          "168:   err = PTR_ERR(dst);",
          "",
          "---------------"
        ],
        "net/ipv6/inet6_connection_sock.c||net/ipv6/inet6_connection_sock.c": [
          "File: net/ipv6/inet6_connection_sock.c -> net/ipv6/inet6_connection_sock.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "74:  fl.fl_ip_sport = inet_rsk(req)->loc_port;",
          "75:  security_req_classify_flow(req, &fl);",
          "84:   return NULL;",
          "86:  return dst;",
          "",
          "[Removed Lines]",
          "77:  if (ip6_dst_lookup(sk, &dst, &fl))",
          "78:   return NULL;",
          "80:  if (final_p)",
          "81:   ipv6_addr_copy(&fl.fl6_dst, final_p);",
          "83:  if ((xfrm_lookup(sock_net(sk), &dst, &fl, sk, 0)) < 0)",
          "",
          "[Added Lines]",
          "77:  dst = ip6_dst_lookup_flow(sk, &fl, final_p, false);",
          "78:  if (IS_ERR(dst))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "234:  dst = __inet6_csk_dst_check(sk, np->dst_cookie);",
          "236:  if (dst == NULL) {",
          "249:    sk->sk_route_caps = 0;",
          "250:    kfree_skb(skb);",
          "252:   }",
          "254:   __inet6_csk_dst_store(sk, dst, NULL, NULL);",
          "",
          "[Removed Lines]",
          "237:   int err = ip6_dst_lookup(sk, &dst, &fl);",
          "239:   if (err) {",
          "240:    sk->sk_err_soft = -err;",
          "241:    kfree_skb(skb);",
          "242:    return err;",
          "243:   }",
          "245:   if (final_p)",
          "246:    ipv6_addr_copy(&fl.fl6_dst, final_p);",
          "248:   if ((err = xfrm_lookup(sock_net(sk), &dst, &fl, sk, 0)) < 0) {",
          "251:    return err;",
          "",
          "[Added Lines]",
          "232:   dst = ip6_dst_lookup_flow(sk, &fl, final_p, false);",
          "234:   if (IS_ERR(dst)) {",
          "235:    sk->sk_err_soft = -PTR_ERR(dst);",
          "238:    return PTR_ERR(dst);",
          "",
          "---------------"
        ],
        "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c": [
          "File: net/ipv6/ip6_output.c -> net/ipv6/ip6_output.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1002: EXPORT_SYMBOL_GPL(ip6_dst_lookup);",
          "1018: {",
          "1026: }",
          "1029: static inline int ip6_ufo_append_data(struct sock *sk,",
          "1030:    int getfrag(void *from, char *to, int offset, int len,",
          "",
          "[Removed Lines]",
          "1017: int ip6_sk_dst_lookup(struct sock *sk, struct dst_entry **dst, struct flowi *fl)",
          "1020:  if (sk) {",
          "1023:  }",
          "1025:  return ip6_dst_lookup_tail(sk, dst, fl);",
          "1027: EXPORT_SYMBOL_GPL(ip6_sk_dst_lookup);",
          "",
          "[Added Lines]",
          "1016: struct dst_entry *ip6_dst_lookup_flow(struct sock *sk, struct flowi *fl,",
          "1017:           const struct in6_addr *final_dst,",
          "1018:           bool want_blackhole)",
          "1019: {",
          "1020:  struct dst_entry *dst = NULL;",
          "1021:  int err;",
          "1023:  err = ip6_dst_lookup_tail(sk, &dst, fl);",
          "1024:  if (err)",
          "1025:   return ERR_PTR(err);",
          "1026:  if (final_dst)",
          "1027:   ipv6_addr_copy(&fl->fl6_dst, final_dst);",
          "1028:  if (want_blackhole) {",
          "1029:   err = __xfrm_lookup(sock_net(sk), &dst, fl, sk, XFRM_LOOKUP_WAIT);",
          "1030:   if (err == -EREMOTE)",
          "1031:    err = ip6_dst_blackhole(sk, &dst, fl);",
          "1032:   if (err)",
          "1033:    return ERR_PTR(err);",
          "1034:  } else {",
          "1035:   err = xfrm_lookup(sock_net(sk), &dst, fl, sk, 0);",
          "1036:   if (err)",
          "1037:    return ERR_PTR(err);",
          "1038:  }",
          "1039:  return dst;",
          "1040: }",
          "1041: EXPORT_SYMBOL_GPL(ip6_dst_lookup_flow);",
          "1058: struct dst_entry *ip6_sk_dst_lookup_flow(struct sock *sk, struct flowi *fl,",
          "1059:       const struct in6_addr *final_dst,",
          "1060:       bool want_blackhole)",
          "1062:  struct dst_entry *dst = sk_dst_check(sk, inet6_sk(sk)->dst_cookie);",
          "1063:  int err;",
          "1065:  dst = ip6_sk_dst_check(sk, dst, fl);",
          "1067:  err = ip6_dst_lookup_tail(sk, &dst, fl);",
          "1068:  if (err)",
          "1069:   return ERR_PTR(err);",
          "1070:  if (final_dst)",
          "1071:   ipv6_addr_copy(&fl->fl6_dst, final_dst);",
          "1072:  if (want_blackhole) {",
          "1073:   err = __xfrm_lookup(sock_net(sk), &dst, fl, sk, XFRM_LOOKUP_WAIT);",
          "1074:   if (err == -EREMOTE)",
          "1075:    err = ip6_dst_blackhole(sk, &dst, fl);",
          "1076:   if (err)",
          "1077:    return ERR_PTR(err);",
          "1078:  } else {",
          "1079:   err = xfrm_lookup(sock_net(sk), &dst, fl, sk, 0);",
          "1080:   if (err)",
          "1081:    return ERR_PTR(err);",
          "1082:  }",
          "1083:  return dst;",
          "1085: EXPORT_SYMBOL_GPL(ip6_sk_dst_lookup_flow);",
          "",
          "---------------"
        ],
        "net/ipv6/raw.c||net/ipv6/raw.c": [
          "File: net/ipv6/raw.c -> net/ipv6/raw.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "856:   fl.oif = np->mcast_oif;",
          "857:  security_sk_classify_flow(sk, &fl);",
          "861:   goto out;",
          "871:  }",
          "873:  if (hlimit < 0) {",
          "874:   if (ipv6_addr_is_multicast(&fl.fl6_dst))",
          "875:    hlimit = np->mcast_hops;",
          "",
          "[Removed Lines]",
          "859:  err = ip6_dst_lookup(sk, &dst, &fl);",
          "860:  if (err)",
          "862:  if (final_p)",
          "863:   ipv6_addr_copy(&fl.fl6_dst, final_p);",
          "865:  err = __xfrm_lookup(sock_net(sk), &dst, &fl, sk, XFRM_LOOKUP_WAIT);",
          "866:  if (err < 0) {",
          "867:   if (err == -EREMOTE)",
          "868:    err = ip6_dst_blackhole(sk, &dst, &fl);",
          "869:   if (err < 0)",
          "870:    goto out;",
          "",
          "[Added Lines]",
          "859:  dst = ip6_dst_lookup_flow(sk, &fl, final_p, true);",
          "860:  if (IS_ERR(dst)) {",
          "861:   err = PTR_ERR(dst);",
          "",
          "---------------"
        ],
        "net/ipv6/syncookies.c||net/ipv6/syncookies.c": [
          "File: net/ipv6/syncookies.c -> net/ipv6/syncookies.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "243:   fl.fl_ip_dport = inet_rsk(req)->rmt_port;",
          "244:   fl.fl_ip_sport = inet_sk(sk)->inet_sport;",
          "245:   security_req_classify_flow(req, &fl);",
          "252:    goto out_free;",
          "253:  }",
          "",
          "[Removed Lines]",
          "246:   if (ip6_dst_lookup(sk, &dst, &fl))",
          "247:    goto out_free;",
          "249:   if (final_p)",
          "250:    ipv6_addr_copy(&fl.fl6_dst, final_p);",
          "251:   if ((xfrm_lookup(sock_net(sk), &dst, &fl, sk, 0)) < 0)",
          "",
          "[Added Lines]",
          "247:   dst = ip6_dst_lookup_flow(sk, &fl, final_p, false);",
          "248:   if (IS_ERR(dst))",
          "",
          "---------------"
        ],
        "net/ipv6/tcp_ipv6.c||net/ipv6/tcp_ipv6.c": [
          "File: net/ipv6/tcp_ipv6.c -> net/ipv6/tcp_ipv6.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "256:  security_sk_classify_flow(sk, &fl);",
          "260:   goto failure;",
          "270:  }",
          "272:  if (saddr == NULL) {",
          "",
          "[Removed Lines]",
          "258:  err = ip6_dst_lookup(sk, &dst, &fl);",
          "259:  if (err)",
          "261:  if (final_p)",
          "262:   ipv6_addr_copy(&fl.fl6_dst, final_p);",
          "264:  err = __xfrm_lookup(sock_net(sk), &dst, &fl, sk, XFRM_LOOKUP_WAIT);",
          "265:  if (err < 0) {",
          "266:   if (err == -EREMOTE)",
          "267:    err = ip6_dst_blackhole(sk, &dst, &fl);",
          "268:   if (err < 0)",
          "269:    goto failure;",
          "",
          "[Added Lines]",
          "258:  dst = ip6_dst_lookup_flow(sk, &fl, final_p, true);",
          "259:  if (IS_ERR(dst)) {",
          "260:   err = PTR_ERR(dst);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "385:  np = inet6_sk(sk);",
          "387:  if (type == ICMPV6_PKT_TOOBIG) {",
          "390:   if (sock_owned_by_user(sk))",
          "391:    goto out;",
          "",
          "[Removed Lines]",
          "388:   struct dst_entry *dst = NULL;",
          "",
          "[Added Lines]",
          "380:   struct dst_entry *dst;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "413:    fl.fl_ip_sport = inet->inet_sport;",
          "414:    security_skb_classify_flow(skb, &fl);",
          "423:     goto out;",
          "424:    }",
          "",
          "[Removed Lines]",
          "416:    if ((err = ip6_dst_lookup(sk, &dst, &fl))) {",
          "417:     sk->sk_err_soft = -err;",
          "418:     goto out;",
          "419:    }",
          "421:    if ((err = xfrm_lookup(net, &dst, &fl, sk, 0)) < 0) {",
          "422:     sk->sk_err_soft = -err;",
          "",
          "[Added Lines]",
          "408:    dst = ip6_dst_lookup_flow(sk, &fl, NULL, false);",
          "409:    if (IS_ERR(dst)) {",
          "410:     sk->sk_err_soft = -PTR_ERR(dst);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "496:  struct in6_addr * final_p, final;",
          "497:  struct flowi fl;",
          "498:  struct dst_entry *dst;",
          "501:  memset(&fl, 0, sizeof(fl));",
          "502:  fl.proto = IPPROTO_TCP;",
          "",
          "[Removed Lines]",
          "499:  int err = -1;",
          "",
          "[Added Lines]",
          "487:  int err;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "512:  opt = np->opt;",
          "513:  final_p = fl6_update_dst(&fl, opt, &final);",
          "517:   goto done;",
          "523:  skb = tcp_make_synack(sk, dst, req, rvp);",
          "524:  if (skb) {",
          "525:   __tcp_v6_send_check(skb, &treq->loc_addr, &treq->rmt_addr);",
          "",
          "[Removed Lines]",
          "515:  err = ip6_dst_lookup(sk, &dst, &fl);",
          "516:  if (err)",
          "518:  if (final_p)",
          "519:   ipv6_addr_copy(&fl.fl6_dst, final_p);",
          "520:  if ((err = xfrm_lookup(sock_net(sk), &dst, &fl, sk, 0)) < 0)",
          "521:   goto done;",
          "",
          "[Added Lines]",
          "503:  dst = ip6_dst_lookup_flow(sk, &fl, final_p, false);",
          "504:  if (IS_ERR(dst)) {",
          "505:   err = PTR_ERR(dst);",
          "507:  }",
          "509:  err = -ENOMEM;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1091:  }",
          "1093:  kfree_skb(buff);",
          "",
          "[Removed Lines]",
          "1082:  if (!ip6_dst_lookup(ctl_sk, &dst, &fl)) {",
          "1083:   if (xfrm_lookup(net, &dst, &fl, NULL, 0) >= 0) {",
          "1084:    skb_dst_set(buff, dst);",
          "1085:    ip6_xmit(ctl_sk, buff, &fl, NULL);",
          "1086:    TCP_INC_STATS_BH(net, TCP_MIB_OUTSEGS);",
          "1087:    if (rst)",
          "1088:     TCP_INC_STATS_BH(net, TCP_MIB_OUTRSTS);",
          "1089:    return;",
          "1090:   }",
          "",
          "[Added Lines]",
          "1068:  dst = ip6_dst_lookup_flow(ctl_sk, &fl, NULL, false);",
          "1069:  if (!IS_ERR(dst)) {",
          "1070:   skb_dst_set(buff, dst);",
          "1071:   ip6_xmit(ctl_sk, buff, &fl, NULL);",
          "1072:   TCP_INC_STATS_BH(net, TCP_MIB_OUTSEGS);",
          "1073:   if (rst)",
          "1074:    TCP_INC_STATS_BH(net, TCP_MIB_OUTRSTS);",
          "1075:   return;",
          "",
          "---------------"
        ],
        "net/ipv6/udp.c||net/ipv6/udp.c": [
          "File: net/ipv6/udp.c -> net/ipv6/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1126:  security_sk_classify_flow(sk, &fl);",
          "1130:   goto out;",
          "1140:  }",
          "1142:  if (hlimit < 0) {",
          "",
          "[Removed Lines]",
          "1128:  err = ip6_sk_dst_lookup(sk, &dst, &fl);",
          "1129:  if (err)",
          "1131:  if (final_p)",
          "1132:   ipv6_addr_copy(&fl.fl6_dst, final_p);",
          "1134:  err = __xfrm_lookup(sock_net(sk), &dst, &fl, sk, XFRM_LOOKUP_WAIT);",
          "1135:  if (err < 0) {",
          "1136:   if (err == -EREMOTE)",
          "1137:    err = ip6_dst_blackhole(sk, &dst, &fl);",
          "1138:   if (err < 0)",
          "1139:    goto out;",
          "",
          "[Added Lines]",
          "1128:  dst = ip6_sk_dst_lookup_flow(sk, &fl, final_p, true);",
          "1129:  if (IS_ERR(dst)) {",
          "1130:   err = PTR_ERR(dst);",
          "1131:   dst = NULL;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c8a627ed06d6d49bf65015a2185c519335c4c83f",
      "candidate_info": {
        "commit_hash": "c8a627ed06d6d49bf65015a2185c519335c4c83f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c8a627ed06d6d49bf65015a2185c519335c4c83f",
        "files": [
          "include/net/inetpeer.h",
          "include/net/netns/ipv4.h",
          "include/net/netns/ipv6.h",
          "net/ipv4/inetpeer.c",
          "net/ipv4/route.c"
        ],
        "message": "inetpeer: add namespace support for inetpeer\n\nnow inetpeer doesn't support namespace,the information will\nbe leaking across namespace.\n\nthis patch move the global vars v4_peers and v6_peers to\nnetns_ipv4 and netns_ipv6 as a field peers.\n\nadd struct pernet_operations inetpeer_ops to initial pernet\ninetpeer data.\n\nand change family_to_base and inet_getpeer to support namespace.\n\nSigned-off-by: Gao feng <gaofeng@cn.fujitsu.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/net/inetpeer.h||include/net/inetpeer.h",
          "include/net/netns/ipv4.h||include/net/netns/ipv4.h",
          "include/net/netns/ipv6.h||include/net/netns/ipv6.h",
          "net/ipv4/inetpeer.c||net/ipv4/inetpeer.c",
          "net/ipv4/route.c||net/ipv4/route.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/net/inetpeer.h||include/net/inetpeer.h",
            "net/ipv4/inetpeer.c||net/ipv4/inetpeer.c"
          ],
          "candidate": [
            "include/net/inetpeer.h||include/net/inetpeer.h",
            "net/ipv4/inetpeer.c||net/ipv4/inetpeer.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/inetpeer.h||include/net/inetpeer.h": [
          "File: include/net/inetpeer.h -> include/net/inetpeer.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "75: }",
          "80: static inline struct inet_peer *inet_getpeer_v4(__be32 v4daddr, int create)",
          "81: {",
          "",
          "[Removed Lines]",
          "78: struct inet_peer *inet_getpeer(const struct inetpeer_addr *daddr, int create);",
          "",
          "[Added Lines]",
          "78: struct inet_peer *inet_getpeer(struct net *net,",
          "79:           const struct inetpeer_addr *daddr,",
          "80:           int create);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "84:  daddr.addr.a4 = v4daddr;",
          "85:  daddr.family = AF_INET;",
          "87: }",
          "89: static inline struct inet_peer *inet_getpeer_v6(const struct in6_addr *v6daddr, int create)",
          "",
          "[Removed Lines]",
          "86:  return inet_getpeer(&daddr, create);",
          "",
          "[Added Lines]",
          "88:  return inet_getpeer(&init_net, &daddr, create);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "94:  daddr.family = AF_INET6;",
          "96: }",
          "99: extern void inet_putpeer(struct inet_peer *p);",
          "100: extern bool inet_peer_xrlim_allow(struct inet_peer *peer, int timeout);",
          "",
          "[Removed Lines]",
          "95:  return inet_getpeer(&daddr, create);",
          "102: extern void inetpeer_invalidate_tree(int family);",
          "",
          "[Added Lines]",
          "97:  return inet_getpeer(&init_net, &daddr, create);",
          "104: extern void inetpeer_invalidate_tree(struct net *net, int family);",
          "",
          "---------------"
        ],
        "include/net/netns/ipv4.h||include/net/netns/ipv4.h": [
          "File: include/net/netns/ipv4.h -> include/net/netns/ipv4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "31:  struct sock  **icmp_sk;",
          "32:  struct sock  *tcp_sock;",
          "34:  struct netns_frags frags;",
          "35: #ifdef CONFIG_NETFILTER",
          "36:  struct xt_table  *iptable_filter;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "33:  struct inet_peer_base *peers;",
          "",
          "---------------"
        ],
        "include/net/netns/ipv6.h||include/net/netns/ipv6.h": [
          "File: include/net/netns/ipv6.h -> include/net/netns/ipv6.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:  struct netns_sysctl_ipv6 sysctl;",
          "34:  struct ipv6_devconf *devconf_all;",
          "35:  struct ipv6_devconf *devconf_dflt;",
          "36:  struct netns_frags frags;",
          "37: #ifdef CONFIG_NETFILTER",
          "38:  struct xt_table  *ip6table_filter;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "36:  struct inet_peer_base *peers;",
          "",
          "---------------"
        ],
        "net/ipv4/inetpeer.c||net/ipv4/inetpeer.c": [
          "File: net/ipv4/inetpeer.c -> net/ipv4/inetpeer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "88:  int  total;",
          "89: };",
          "",
          "[Removed Lines]",
          "91: static struct inet_peer_base v4_peers = {",
          "92:  .root  = peer_avl_empty_rcu,",
          "93:  .lock  = __SEQLOCK_UNLOCKED(v4_peers.lock),",
          "94:  .total  = 0,",
          "95: };",
          "97: static struct inet_peer_base v6_peers = {",
          "98:  .root  = peer_avl_empty_rcu,",
          "99:  .lock  = __SEQLOCK_UNLOCKED(v6_peers.lock),",
          "100:  .total  = 0,",
          "101: };",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "153:  schedule_delayed_work(&gc_work, gc_delay);",
          "154: }",
          "157: void __init inet_initpeers(void)",
          "158: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "144: static int __net_init inetpeer_net_init(struct net *net)",
          "145: {",
          "146:  net->ipv4.peers = kzalloc(sizeof(struct inet_peer_base),",
          "147:       GFP_KERNEL);",
          "148:  if (net->ipv4.peers == NULL)",
          "149:   return -ENOMEM;",
          "151:  net->ipv4.peers->root = peer_avl_empty_rcu;",
          "152:  seqlock_init(&net->ipv4.peers->lock);",
          "154:  net->ipv6.peers = kzalloc(sizeof(struct inet_peer_base),",
          "155:       GFP_KERNEL);",
          "156:  if (net->ipv6.peers == NULL)",
          "157:   goto out_ipv6;",
          "159:  net->ipv6.peers->root = peer_avl_empty_rcu;",
          "160:  seqlock_init(&net->ipv6.peers->lock);",
          "162:  return 0;",
          "163: out_ipv6:",
          "164:  kfree(net->ipv4.peers);",
          "165:  return -ENOMEM;",
          "166: }",
          "168: static void __net_exit inetpeer_net_exit(struct net *net)",
          "169: {",
          "170:  inetpeer_invalidate_tree(net, AF_INET);",
          "171:  kfree(net->ipv4.peers);",
          "172:  net->ipv4.peers = NULL;",
          "174:  inetpeer_invalidate_tree(net, AF_INET6);",
          "175:  kfree(net->ipv6.peers);",
          "176:  net->ipv6.peers = NULL;",
          "177: }",
          "179: static struct pernet_operations inetpeer_ops = {",
          "180:  .init = inetpeer_net_init,",
          "181:  .exit = inetpeer_net_exit,",
          "182: };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "177:    NULL);",
          "179:  INIT_DELAYED_WORK_DEFERRABLE(&gc_work, inetpeer_gc_worker);",
          "180: }",
          "182: static int addr_compare(const struct inetpeer_addr *a,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "208:  register_pernet_subsys(&inetpeer_ops);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "401:  call_rcu(&p->rcu, inetpeer_free_rcu);",
          "402: }",
          "405: {",
          "407: }",
          "",
          "[Removed Lines]",
          "404: static struct inet_peer_base *family_to_base(int family)",
          "406:  return family == AF_INET ? &v4_peers : &v6_peers;",
          "",
          "[Added Lines]",
          "433: static struct inet_peer_base *family_to_base(struct net *net,",
          "434:           int family)",
          "436:  return family == AF_INET ? net->ipv4.peers : net->ipv6.peers;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "443:  return cnt;",
          "444: }",
          "447: {",
          "448:  struct inet_peer __rcu **stack[PEER_MAXDEPTH], ***stackptr;",
          "450:  struct inet_peer *p;",
          "451:  unsigned int sequence;",
          "452:  int invalidated, gccnt = 0;",
          "",
          "[Removed Lines]",
          "446: struct inet_peer *inet_getpeer(const struct inetpeer_addr *daddr, int create)",
          "449:  struct inet_peer_base *base = family_to_base(daddr->family);",
          "",
          "[Added Lines]",
          "476: struct inet_peer *inet_getpeer(struct net *net,",
          "477:           const struct inetpeer_addr *daddr,",
          "478:           int create)",
          "481:  struct inet_peer_base *base = family_to_base(net, daddr->family);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "571:  schedule_delayed_work(&gc_work, gc_delay);",
          "572: }",
          "575: {",
          "576:  struct inet_peer *old, *new, *prev;",
          "579:  write_seqlock_bh(&base->lock);",
          "",
          "[Removed Lines]",
          "574: void inetpeer_invalidate_tree(int family)",
          "577:  struct inet_peer_base *base = family_to_base(family);",
          "",
          "[Added Lines]",
          "606: void inetpeer_invalidate_tree(struct net *net, int family)",
          "609:  struct inet_peer_base *base = family_to_base(net, family);",
          "",
          "---------------"
        ],
        "net/ipv4/route.c||net/ipv4/route.c": [
          "File: net/ipv4/route.c -> net/ipv4/route.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "939:  get_random_bytes(&shuffle, sizeof(shuffle));",
          "940:  atomic_add(shuffle + 1U, &net->ipv4.rt_genid);",
          "942: }",
          "",
          "[Removed Lines]",
          "941:  inetpeer_invalidate_tree(AF_INET);",
          "",
          "[Added Lines]",
          "941:  inetpeer_invalidate_tree(net, AF_INET);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
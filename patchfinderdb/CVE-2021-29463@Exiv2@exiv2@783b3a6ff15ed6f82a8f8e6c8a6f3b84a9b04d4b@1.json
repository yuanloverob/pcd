{
  "cve_id": "CVE-2021-29463",
  "cve_desc": "Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. An out-of-bounds read was found in Exiv2 versions v0.27.3 and earlier. The out-of-bounds read is triggered when Exiv2 is used to write metadata into a crafted image file. An attacker could potentially exploit the vulnerability to cause a denial of service by crashing Exiv2, if they can trick the victim into running Exiv2 on a crafted image file. Note that this bug is only triggered when writing the metadata, which is a less frequently used Exiv2 operation than reading the metadata. For example, to trigger the bug in the Exiv2 command-line application, you need to add an extra command-line argument such as `insert`. The bug is fixed in version v0.27.4.",
  "repo": "Exiv2/exiv2",
  "patch_hash": "783b3a6ff15ed6f82a8f8e6c8a6f3b84a9b04d4b",
  "patch_info": {
    "commit_hash": "783b3a6ff15ed6f82a8f8e6c8a6f3b84a9b04d4b",
    "repo": "Exiv2/exiv2",
    "commit_url": "https://github.com/Exiv2/exiv2/commit/783b3a6ff15ed6f82a8f8e6c8a6f3b84a9b04d4b",
    "files": [
      "src/webpimage.cpp"
    ],
    "message": "Improve bound checking in WebPImage::doWriteMetadata()",
    "before_after_code_files": [
      "src/webpimage.cpp||src/webpimage.cpp"
    ]
  },
  "patch_diff": {
    "src/webpimage.cpp||src/webpimage.cpp": [
      "File: src/webpimage.cpp -> src/webpimage.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "145:         DataBuf chunkId(WEBP_TAG_SIZE+1);",
      "146:         chunkId.pData_ [WEBP_TAG_SIZE] = '\\0';",
      "149:         uint64_t filesize = Exiv2::getULong(data + WEBP_TAG_SIZE, littleEndian);",
      "",
      "[Removed Lines]",
      "148:         io_->read(data, WEBP_TAG_SIZE * 3);",
      "",
      "[Added Lines]",
      "148:         readOrThrow(*io_, data, WEBP_TAG_SIZE * 3, Exiv2::kerCorruptedMetadata);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "185:          case we have any exif or xmp data, also check",
      "187:         while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {",
      "191:             DataBuf payload(size);",
      "",
      "[Removed Lines]",
      "188:             io_->read(chunkId.pData_, WEBP_TAG_SIZE);",
      "189:             io_->read(size_buff, WEBP_TAG_SIZE);",
      "190:             long size = Exiv2::getULong(size_buff, littleEndian);",
      "192:             io_->read(payload.pData_, payload.size_);",
      "193:             byte c;",
      "194:             if ( payload.size_ % 2 ) io_->read(&c,1);",
      "",
      "[Added Lines]",
      "188:             readOrThrow(*io_, chunkId.pData_, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);",
      "189:             readOrThrow(*io_, size_buff, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);",
      "190:             const uint32_t size_u32 = Exiv2::getULong(size_buff, littleEndian);",
      "193:             enforce(size_u32 <= static_cast<size_t>(std::numeric_limits<unsigned int>::max()),",
      "194:                     Exiv2::kerCorruptedMetadata);",
      "195:             const long size = static_cast<long>(size_u32);",
      "197:             readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);",
      "198:             if ( payload.size_ % 2 ) {",
      "199:               byte c;",
      "200:               readOrThrow(*io_, &c, 1, Exiv2::kerCorruptedMetadata);",
      "201:             }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "199:                 has_vp8x = true;",
      "200:             }",
      "201:             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_size) {",
      "202:                 has_size = true;",
      "203:                 byte size_buf[WEBP_TAG_SIZE];",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "209:                 enforce(size >= 10, Exiv2::kerCorruptedMetadata);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "227:             }",
      "228: #endif",
      "229:             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_size) {",
      "230:                 has_size = true;",
      "231:                 byte size_buf[2];",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "238:                 enforce(size >= 10, Exiv2::kerCorruptedMetadata);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "246:             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_alpha) {",
      "247:                 if ((payload.pData_[4] & WEBP_VP8X_ALPHA_BIT) == WEBP_VP8X_ALPHA_BIT) {",
      "248:                     has_alpha = true;",
      "249:                 }",
      "250:             }",
      "251:             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_size) {",
      "252:                 has_size = true;",
      "253:                 byte size_buf_w[2];",
      "254:                 byte size_buf_h[3];",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "256:                 enforce(size >= 5, Exiv2::kerCorruptedMetadata);",
      "262:                 enforce(size >= 5, Exiv2::kerCorruptedMetadata);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "278:             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_alpha) {",
      "279:                 if ((payload.pData_[5] & 0x2) == 0x2) {",
      "280:                     has_alpha = true;",
      "281:                 }",
      "282:             }",
      "283:             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_size) {",
      "284:                 has_size = true;",
      "285:                 byte size_buf[WEBP_TAG_SIZE];",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "290:                 enforce(size >= 6, Exiv2::kerCorruptedMetadata);",
      "296:                 enforce(size >= 12, Exiv2::kerCorruptedMetadata);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "310:         io_->seek(12, BasicIo::beg);",
      "311:         while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {",
      "317:             DataBuf payload(size);",
      "319:             if ( io_->tell() % 2 ) io_->seek(+1,BasicIo::cur); // skip pad",
      "321:             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X)) {",
      "322:                 if (has_icc){",
      "323:                     payload.pData_[0] |= WEBP_VP8X_ICC_BIT;",
      "324:                 } else {",
      "",
      "[Removed Lines]",
      "312:             io_->read(chunkId.pData_, 4);",
      "313:             io_->read(size_buff, 4);",
      "315:             long size = Exiv2::getULong(size_buff, littleEndian);",
      "318:             io_->read(payload.pData_, size);",
      "",
      "[Added Lines]",
      "325:             readOrThrow(*io_, chunkId.pData_, 4, Exiv2::kerCorruptedMetadata);",
      "326:             readOrThrow(*io_, size_buff, 4, Exiv2::kerCorruptedMetadata);",
      "328:             const uint32_t size_u32 = Exiv2::getULong(size_buff, littleEndian);",
      "331:             enforce(size_u32 <= static_cast<size_t>(std::numeric_limits<unsigned int>::max()),",
      "332:                     Exiv2::kerCorruptedMetadata);",
      "333:             const long size = static_cast<long>(size_u32);",
      "336:             readOrThrow(*io_, payload.pData_, size, Exiv2::kerCorruptedMetadata);",
      "340:                 enforce(size >= 1, Exiv2::kerCorruptedMetadata);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d639e45c2cdc18b9b49b1307c6e4315277fa8cc4",
      "candidate_info": {
        "commit_hash": "d639e45c2cdc18b9b49b1307c6e4315277fa8cc4",
        "repo": "Exiv2/exiv2",
        "commit_url": "https://github.com/Exiv2/exiv2/commit/d639e45c2cdc18b9b49b1307c6e4315277fa8cc4",
        "files": [
          "src/webpimage.cpp"
        ],
        "message": "Improve bound checking in WebPImage::doWriteMetadata()",
        "before_after_code_files": [
          "src/webpimage.cpp||src/webpimage.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/webpimage.cpp||src/webpimage.cpp"
          ],
          "candidate": [
            "src/webpimage.cpp||src/webpimage.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/webpimage.cpp||src/webpimage.cpp": [
          "File: src/webpimage.cpp -> src/webpimage.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "145:         DataBuf chunkId(WEBP_TAG_SIZE+1);",
          "146:         chunkId.pData_ [WEBP_TAG_SIZE] = '\\0';",
          "149:         uint64_t filesize = Exiv2::getULong(data + WEBP_TAG_SIZE, littleEndian);",
          "",
          "[Removed Lines]",
          "148:         io_->read(data, WEBP_TAG_SIZE * 3);",
          "",
          "[Added Lines]",
          "148:         readOrThrow(*io_, data, WEBP_TAG_SIZE * 3, Exiv2::kerCorruptedMetadata);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "185:          case we have any exif or xmp data, also check",
          "187:         while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {",
          "191:             DataBuf payload(size);",
          "",
          "[Removed Lines]",
          "188:             io_->read(chunkId.pData_, WEBP_TAG_SIZE);",
          "189:             io_->read(size_buff, WEBP_TAG_SIZE);",
          "190:             long size = Exiv2::getULong(size_buff, littleEndian);",
          "192:             io_->read(payload.pData_, payload.size_);",
          "193:             byte c;",
          "194:             if ( payload.size_ % 2 ) io_->read(&c,1);",
          "",
          "[Added Lines]",
          "188:             readOrThrow(*io_, chunkId.pData_, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);",
          "189:             readOrThrow(*io_, size_buff, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);",
          "190:             const uint32_t size_u32 = Exiv2::getULong(size_buff, littleEndian);",
          "193:             enforce(size_u32 <= static_cast<size_t>(std::numeric_limits<unsigned int>::max()),",
          "194:                     Exiv2::kerCorruptedMetadata);",
          "195:             const long size = static_cast<long>(size_u32);",
          "197:             readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);",
          "198:             if ( payload.size_ % 2 ) {",
          "199:               byte c;",
          "200:               readOrThrow(*io_, &c, 1, Exiv2::kerCorruptedMetadata);",
          "201:             }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "199:                 has_vp8x = true;",
          "200:             }",
          "201:             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_size) {",
          "202:                 has_size = true;",
          "203:                 byte size_buf[WEBP_TAG_SIZE];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "209:                 enforce(size >= 10, Exiv2::kerCorruptedMetadata);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "227:             }",
          "228: #endif",
          "229:             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_size) {",
          "230:                 has_size = true;",
          "231:                 byte size_buf[2];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "238:                 enforce(size >= 10, Exiv2::kerCorruptedMetadata);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "246:             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_alpha) {",
          "247:                 if ((payload.pData_[4] & WEBP_VP8X_ALPHA_BIT) == WEBP_VP8X_ALPHA_BIT) {",
          "248:                     has_alpha = true;",
          "249:                 }",
          "250:             }",
          "251:             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_size) {",
          "252:                 has_size = true;",
          "253:                 byte size_buf_w[2];",
          "254:                 byte size_buf_h[3];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "256:                 enforce(size >= 5, Exiv2::kerCorruptedMetadata);",
          "262:                 enforce(size >= 5, Exiv2::kerCorruptedMetadata);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "278:             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_alpha) {",
          "279:                 if ((payload.pData_[5] & 0x2) == 0x2) {",
          "280:                     has_alpha = true;",
          "281:                 }",
          "282:             }",
          "283:             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_size) {",
          "284:                 has_size = true;",
          "285:                 byte size_buf[WEBP_TAG_SIZE];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "290:                 enforce(size >= 6, Exiv2::kerCorruptedMetadata);",
          "296:                 enforce(size >= 12, Exiv2::kerCorruptedMetadata);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "310:         io_->seek(12, BasicIo::beg);",
          "311:         while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {",
          "317:             DataBuf payload(size);",
          "319:             if ( io_->tell() % 2 ) io_->seek(+1,BasicIo::cur); // skip pad",
          "321:             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X)) {",
          "322:                 if (has_icc){",
          "323:                     payload.pData_[0] |= WEBP_VP8X_ICC_BIT;",
          "324:                 } else {",
          "",
          "[Removed Lines]",
          "312:             io_->read(chunkId.pData_, 4);",
          "313:             io_->read(size_buff, 4);",
          "315:             long size = Exiv2::getULong(size_buff, littleEndian);",
          "318:             io_->read(payload.pData_, size);",
          "",
          "[Added Lines]",
          "325:             readOrThrow(*io_, chunkId.pData_, 4, Exiv2::kerCorruptedMetadata);",
          "326:             readOrThrow(*io_, size_buff, 4, Exiv2::kerCorruptedMetadata);",
          "328:             const uint32_t size_u32 = Exiv2::getULong(size_buff, littleEndian);",
          "331:             enforce(size_u32 <= static_cast<size_t>(std::numeric_limits<unsigned int>::max()),",
          "332:                     Exiv2::kerCorruptedMetadata);",
          "333:             const long size = static_cast<long>(size_u32);",
          "336:             readOrThrow(*io_, payload.pData_, size, Exiv2::kerCorruptedMetadata);",
          "340:                 enforce(size >= 1, Exiv2::kerCorruptedMetadata);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
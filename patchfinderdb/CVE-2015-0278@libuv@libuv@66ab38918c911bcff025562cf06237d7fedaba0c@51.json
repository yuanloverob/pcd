{
  "cve_id": "CVE-2015-0278",
  "cve_desc": "libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.",
  "repo": "libuv/libuv",
  "patch_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
  "patch_info": {
    "commit_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
    "repo": "libuv/libuv",
    "commit_url": "https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c",
    "files": [
      "src/unix/process.c"
    ],
    "message": "unix: call setgoups before calling setuid/setgid\n\nPartial fix for #1093",
    "before_after_code_files": [
      "src/unix/process.c||src/unix/process.c"
    ]
  },
  "patch_diff": {
    "src/unix/process.c||src/unix/process.c": [
      "File: src/unix/process.c -> src/unix/process.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "330:     _exit(127);",
      "331:   }",
      "333:   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {",
      "334:     uv__write_int(error_fd, -errno);",
      "335:     perror(\"setgid()\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "333:   if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {",
      "341:     SAVE_ERRNO(setgroups(0, NULL));",
      "342:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "92040eb7123e892261c8da71c3eedb97c00e4b88",
      "candidate_info": {
        "commit_hash": "92040eb7123e892261c8da71c3eedb97c00e4b88",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/92040eb7123e892261c8da71c3eedb97c00e4b88",
        "files": [
          "include/uv.h",
          "src/unix/stream.c",
          "src/win/internal.h",
          "src/win/pipe.c",
          "src/win/stream.c"
        ],
        "message": "stream: add an API to make streams do blocking writes\n\nThis patch adds the `uv_stream_set_blocking` API which makes all\nuv_write calls to that stream blocking. It currently only works for\npipes, on windows.",
        "before_after_code_files": [
          "include/uv.h||include/uv.h",
          "src/unix/stream.c||src/unix/stream.c",
          "src/win/internal.h||src/win/internal.h",
          "src/win/pipe.c||src/win/pipe.c",
          "src/win/stream.c||src/win/stream.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/uv.h||include/uv.h": [
          "File: include/uv.h -> include/uv.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "675: UV_EXTERN int uv_is_writable(const uv_stream_t* handle);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "700: UV_EXTERN int uv_stream_set_blocking(uv_stream_t* handle, int blocking);",
          "",
          "---------------"
        ],
        "src/unix/stream.c||src/unix/stream.c": [
          "File: src/unix/stream.c -> src/unix/stream.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1431:   assert(!uv__io_active(&handle->io_watcher, UV__POLLIN | UV__POLLOUT));",
          "1432: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1435: int uv_stream_set_blocking(uv_stream_t* handle, int blocking) {",
          "1436:   assert(0 && \"implement me\");",
          "1437: }",
          "",
          "---------------"
        ],
        "src/win/internal.h||src/win/internal.h": [
          "File: src/win/internal.h -> src/win/internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "58: #define UV_HANDLE_SYNC_BYPASS_IOCP              0x00040000",
          "59: #define UV_HANDLE_ZERO_READ                     0x00080000",
          "60: #define UV_HANDLE_EMULATE_IOCP                  0x00100000",
          "63: #define UV_HANDLE_IPV6                          0x01000000",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "61: #define UV_HANDLE_BLOCKING_WRITES               0x00200000",
          "",
          "---------------"
        ],
        "src/win/pipe.c||src/win/pipe.c": [
          "File: src/win/pipe.c -> src/win/pipe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1129:     memset(&ipc_header_req->overlapped, 0, sizeof(ipc_header_req->overlapped));",
          "1131:     result = WriteFile(handle->handle,",
          "1132:                         &ipc_frame,",
          "1133:                         ipc_frame.header.flags & UV_IPC_TCP_SERVER ?",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1133:     ipc_header_req->overlapped.hEvent = CreateEvent(NULL, 1, 0, NULL);",
          "1134:     if (!ipc_header_req->overlapped.hEvent) {",
          "1135:       uv_fatal_error(GetLastError(), \"CreateEvent\");",
          "1136:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1136:                         &ipc_header_req->overlapped);",
          "1137:     if (!result && GetLastError() != ERROR_IO_PENDING) {",
          "1138:       uv__set_sys_error(loop, GetLastError());",
          "1139:       return -1;",
          "1140:     }",
          "1150:     }",
          "1152:     REGISTER_HANDLE_REQ(loop, handle, ipc_header_req);",
          "1153:     handle->reqs_pending++;",
          "",
          "[Removed Lines]",
          "1142:     if (result) {",
          "1144:       ipc_header_req->queued_bytes = 0;",
          "1145:     } else {",
          "1147:       ipc_header_req->queued_bytes = ipc_frame.header.flags & UV_IPC_TCP_SERVER ?",
          "1148:         sizeof(ipc_frame) : sizeof(ipc_frame.header);",
          "1149:       handle->write_queue_size += ipc_header_req->queued_bytes;",
          "",
          "[Added Lines]",
          "1146:       CloseHandle(ipc_header_req->overlapped.hEvent);",
          "1150:     if (!result) {",
          "1152:       if (WaitForSingleObject(ipc_header_req->overlapped.hEvent, INFINITE) !=",
          "1153:           WAIT_OBJECT_0) {",
          "1154:         uv__set_sys_error(loop, GetLastError());",
          "1155:         CloseHandle(ipc_header_req->overlapped.hEvent);",
          "1156:         return -1;",
          "1157:       }",
          "1159:     ipc_header_req->queued_bytes = 0;",
          "1160:     CloseHandle(ipc_header_req->overlapped.hEvent);",
          "1161:     ipc_header_req->overlapped.hEvent = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1159:     }",
          "1160:   }",
          "1163:     req->write_buffer = bufs[0];",
          "1164:     uv_insert_non_overlapped_write_req(handle, req);",
          "1165:     if (handle->write_reqs_pending == 0) {",
          "",
          "[Removed Lines]",
          "1162:   if (handle->flags & UV_HANDLE_NON_OVERLAPPED_PIPE) {",
          "",
          "[Added Lines]",
          "1173:   if ((handle->flags &",
          "1174:       (UV_HANDLE_BLOCKING_WRITES | UV_HANDLE_NON_OVERLAPPED_PIPE)) ==",
          "1175:       (UV_HANDLE_BLOCKING_WRITES | UV_HANDLE_NON_OVERLAPPED_PIPE)) {",
          "1176:     DWORD bytes;",
          "1177:     result = WriteFile(handle->handle,",
          "1178:                        bufs[0].base,",
          "1179:                        bufs[0].len,",
          "1180:                        &bytes,",
          "1181:                        NULL);",
          "1183:     if (!result) {",
          "1184:       return uv__set_sys_error(loop, GetLastError());",
          "1185:     } else {",
          "1187:       req->queued_bytes = 0;",
          "1188:     }",
          "1190:     REGISTER_HANDLE_REQ(loop, handle, req);",
          "1191:     handle->reqs_pending++;",
          "1192:     handle->write_reqs_pending++;",
          "1193:     POST_COMPLETION_FOR_REQ(loop, req);",
          "1194:     return 0;",
          "1195:   } else if (handle->flags & UV_HANDLE_NON_OVERLAPPED_PIPE) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1170:     req->queued_bytes = uv_count_bufs(bufs, bufcnt);",
          "1171:     handle->write_queue_size += req->queued_bytes;",
          "1172:   } else {",
          "1173:     result = WriteFile(handle->handle,",
          "1174:                        bufs[0].base,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1205:   } else if (handle->flags & UV_HANDLE_BLOCKING_WRITES) {",
          "1207:     req->overlapped.hEvent = CreateEvent(NULL, 1, 0, NULL);",
          "1208:     if (!req->overlapped.hEvent) {",
          "1209:       uv_fatal_error(GetLastError(), \"CreateEvent\");",
          "1210:     }",
          "1212:     result = WriteFile(handle->handle,",
          "1213:                        bufs[0].base,",
          "1214:                        bufs[0].len,",
          "1215:                        NULL,",
          "1216:                        &req->overlapped);",
          "1218:     if (!result && GetLastError() != ERROR_IO_PENDING) {",
          "1219:       uv__set_sys_error(loop, GetLastError());",
          "1220:       CloseHandle(req->overlapped.hEvent);",
          "1221:       return -1;",
          "1222:     }",
          "1224:     if (result) {",
          "1226:       req->queued_bytes = 0;",
          "1227:     } else {",
          "1229:       if (WaitForSingleObject(ipc_header_req->overlapped.hEvent, INFINITE) !=",
          "1230:           WAIT_OBJECT_0) {",
          "1231:         uv__set_sys_error(loop, GetLastError());",
          "1232:         CloseHandle(ipc_header_req->overlapped.hEvent);",
          "1233:         return -1;",
          "1234:       }",
          "1235:     }",
          "1236:     CloseHandle(req->overlapped.hEvent);",
          "1238:     REGISTER_HANDLE_REQ(loop, handle, req);",
          "1239:     handle->reqs_pending++;",
          "1240:     handle->write_reqs_pending++;",
          "1241:     POST_COMPLETION_FOR_REQ(loop, req);",
          "1242:     return 0;",
          "",
          "---------------"
        ],
        "src/win/stream.c||src/win/stream.c": [
          "File: src/win/stream.c -> src/win/stream.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "196: int uv_is_writable(const uv_stream_t* handle) {",
          "197:   return !!(handle->flags & UV_HANDLE_WRITABLE);",
          "198: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "201: int uv_stream_set_blocking(uv_stream_t* handle, int blocking) {",
          "202:   if (blocking != 0)",
          "203:     handle->flags |= UV_HANDLE_BLOCKING_WRITES;",
          "204:   else",
          "205:     handle->flags &= ~UV_HANDLE_BLOCKING_WRITES;",
          "207:   return 0;",
          "208: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "585b6b7d1f2b1744fe14659533b7bd9a755a8c93",
      "candidate_info": {
        "commit_hash": "585b6b7d1f2b1744fe14659533b7bd9a755a8c93",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/585b6b7d1f2b1744fe14659533b7bd9a755a8c93",
        "files": [
          "src/win/tty.c"
        ],
        "message": "windows: remove unused variable in tty.c",
        "before_after_code_files": [
          "src/win/tty.c||src/win/tty.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/win/tty.c||src/win/tty.c": [
          "File: src/win/tty.c -> src/win/tty.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "832: int uv_tty_read_stop(uv_tty_t* handle) {",
          "835:   handle->flags &= ~UV_HANDLE_READING;",
          "839:   if ((handle->flags & UV_HANDLE_READ_PENDING) &&",
          "",
          "[Removed Lines]",
          "833:   uv_loop_t* loop = handle->loop;",
          "836:   DECREASE_ACTIVE_COUNT(loop, handle);",
          "",
          "[Added Lines]",
          "834:   DECREASE_ACTIVE_COUNT(handle->loop, handle);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "97bb41f35cb95a51269c169c3bf6e165e75b1ff2",
      "candidate_info": {
        "commit_hash": "97bb41f35cb95a51269c169c3bf6e165e75b1ff2",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/97bb41f35cb95a51269c169c3bf6e165e75b1ff2",
        "files": [
          "src/win/util.c",
          "src/win/winsock.h"
        ],
        "message": "win: add missing IP_ADAPTER_UNICAST_ADDRESS_LH definition for MinGW",
        "before_after_code_files": [
          "src/win/util.c||src/win/util.c",
          "src/win/winsock.h||src/win/winsock.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/win/util.c||src/win/util.c": [
          "File: src/win/util.c -> src/win/util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1039:       if (is_vista_or_greater) {",
          "1041:       } else {",
          "",
          "[Removed Lines]",
          "1040:         prefix_len = unicast_address->OnLinkPrefixLength;",
          "",
          "[Added Lines]",
          "1040:         prefix_len =",
          "1041:           ((IP_ADAPTER_UNICAST_ADDRESS_LH*) unicast_address)->OnLinkPrefixLength;",
          "",
          "---------------"
        ],
        "src/win/winsock.h||src/win/winsock.h": [
          "File: src/win/winsock.h -> src/win/winsock.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "166:   ULONG LeaseLifetime;",
          "167: } IP_ADAPTER_UNICAST_ADDRESS_XP,*PIP_ADAPTER_UNICAST_ADDRESS_XP;",
          "169: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "169: typedef struct _IP_ADAPTER_UNICAST_ADDRESS_LH {",
          "170:   union {",
          "171:     ULONGLONG Alignment;",
          "172:     struct {",
          "173:       ULONG Length;",
          "174:       DWORD Flags;",
          "175:     };",
          "176:   };",
          "177:   struct _IP_ADAPTER_UNICAST_ADDRESS_LH *Next;",
          "178:   SOCKET_ADDRESS Address;",
          "179:   IP_PREFIX_ORIGIN PrefixOrigin;",
          "180:   IP_SUFFIX_ORIGIN SuffixOrigin;",
          "181:   IP_DAD_STATE DadState;",
          "182:   ULONG ValidLifetime;",
          "183:   ULONG PreferredLifetime;",
          "184:   ULONG LeaseLifetime;",
          "185:   UINT8 OnLinkPrefixLength;",
          "186: } IP_ADAPTER_UNICAST_ADDRESS_LH,*PIP_ADAPTER_UNICAST_ADDRESS_LH;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "96f32a206b2cc6784a65a6a62addb074e4b72f45",
      "candidate_info": {
        "commit_hash": "96f32a206b2cc6784a65a6a62addb074e4b72f45",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/96f32a206b2cc6784a65a6a62addb074e4b72f45",
        "files": [
          "test/test-ip6-addr.c"
        ],
        "message": "test: replace sprintf() with snprintf()\n\nThere is zero risk of overflowing the buffer, it's just a good habit.",
        "before_after_code_files": [
          "test/test-ip6-addr.c||test/test-ip6-addr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "test/test-ip6-addr.c||test/test-ip6-addr.c": [
          "File: test/test-ip6-addr.c -> test/test-ip6-addr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "76:   if (strncmp(ip6_addr, \"fe80::\", 6) != 0) return;",
          "78: #ifdef _WIN32",
          "80: #else",
          "82: #endif",
          "84:   LOGF(\"Testing link-local address %s (iface_index: 0x%02x, device_name: %s)\\n\",",
          "",
          "[Removed Lines]",
          "79:   sprintf(scoped_addr, \"%s%%%d\", ip6_addr, iface_index);",
          "81:   sprintf(scoped_addr, \"%s%%%s\", ip6_addr, device_name);",
          "",
          "[Added Lines]",
          "79:   snprintf(scoped_addr, sizeof(scoped_addr), \"%s%%%d\", ip6_addr, iface_index);",
          "81:   snprintf(scoped_addr, sizeof(scoped_addr), \"%s%%%s\", ip6_addr, device_name);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bf6e90f4d6fa3439babf748b70e33c48cfa8d80e",
      "candidate_info": {
        "commit_hash": "bf6e90f4d6fa3439babf748b70e33c48cfa8d80e",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/bf6e90f4d6fa3439babf748b70e33c48cfa8d80e",
        "files": [
          "include/uv.h"
        ],
        "message": "doc: cleanup API documentation in uv.h",
        "before_after_code_files": [
          "include/uv.h||include/uv.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/uv.h||include/uv.h": [
          "File: include/uv.h -> include/uv.h"
        ]
      }
    }
  ]
}
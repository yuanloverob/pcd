{
  "cve_id": "CVE-2019-13225",
  "cve_desc": "A NULL Pointer Dereference in match_at() in regexec.c in Oniguruma 6.9.2 allows attackers to potentially cause denial of service by providing a crafted regular expression. Oniguruma issues often affect Ruby, as well as common optional libraries for PHP and Rust.",
  "repo": "kkos/oniguruma",
  "patch_hash": "c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c",
  "patch_info": {
    "commit_hash": "c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c",
    "repo": "kkos/oniguruma",
    "commit_url": "https://github.com/kkos/oniguruma/commit/c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c",
    "files": [
      "src/regcomp.c"
    ],
    "message": "Fix CVE-2019-13225: problem in converting if-then-else pattern to bytecode.",
    "before_after_code_files": [
      "src/regcomp.c||src/regcomp.c"
    ]
  },
  "patch_diff": {
    "src/regcomp.c||src/regcomp.c": [
      "File: src/regcomp.c -> src/regcomp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1307:         len += tlen;",
      "1308:       }",
      "1310:       if (IS_NOT_NULL(Else)) {",
      "1312:         tlen = compile_length_tree(Else, reg);",
      "1313:         if (tlen < 0) return tlen;",
      "1314:         len += tlen;",
      "",
      "[Removed Lines]",
      "1311:         len += SIZE_OP_JUMP;",
      "",
      "[Added Lines]",
      "1310:       len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1456:   case BAG_IF_ELSE:",
      "1457:     {",
      "1459:       Node* cond = NODE_BAG_BODY(node);",
      "1460:       Node* Then = node->te.Then;",
      "1461:       Node* Else = node->te.Else;",
      "",
      "[Removed Lines]",
      "1458:       int cond_len, then_len, jump_len;",
      "",
      "[Added Lines]",
      "1459:       int cond_len, then_len, else_len, jump_len;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1472:       else",
      "1473:         then_len = 0;",
      "1478:       r = add_op(reg, OP_PUSH);",
      "1479:       if (r != 0) return r;",
      "",
      "[Removed Lines]",
      "1475:       jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END;",
      "1476:       if (IS_NOT_NULL(Else)) jump_len += SIZE_OP_JUMP;",
      "",
      "[Added Lines]",
      "1476:       jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1490:       }",
      "1492:       if (IS_NOT_NULL(Else)) {",
      "1498:         r = compile_tree(Else, reg, env);",
      "1499:       }",
      "1500:     }",
      "",
      "[Removed Lines]",
      "1493:         int else_len = compile_length_tree(Else, reg);",
      "1494:         r = add_op(reg, OP_JUMP);",
      "1495:         if (r != 0) return r;",
      "1496:         COP(reg)->jump.addr = else_len + SIZE_INC_OP;",
      "",
      "[Added Lines]",
      "1493:         else_len = compile_length_tree(Else, reg);",
      "1494:         if (else_len < 0) return else_len;",
      "1495:       }",
      "1496:       else",
      "1497:         else_len = 0;",
      "1499:       r = add_op(reg, OP_JUMP);",
      "1500:       if (r != 0) return r;",
      "1501:       COP(reg)->jump.addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP;",
      "1503:       r = add_op(reg, OP_ATOMIC_END);",
      "1504:       if (r != 0) return r;",
      "1506:       if (IS_NOT_NULL(Else)) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0a2d7c9e70404b1d9837c881634e3a4aefd50641",
      "candidate_info": {
        "commit_hash": "0a2d7c9e70404b1d9837c881634e3a4aefd50641",
        "repo": "kkos/oniguruma",
        "commit_url": "https://github.com/kkos/oniguruma/commit/0a2d7c9e70404b1d9837c881634e3a4aefd50641",
        "files": [
          "src/regcomp.c"
        ],
        "message": "use MARK and CUT operators instead of ATOMIC_START and ATOMIC_END",
        "before_after_code_files": [
          "src/regcomp.c||src/regcomp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/regcomp.c||src/regcomp.c"
          ],
          "candidate": [
            "src/regcomp.c||src/regcomp.c"
          ]
        }
      },
      "candidate_diff": {
        "src/regcomp.c||src/regcomp.c": [
          "File: src/regcomp.c -> src/regcomp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1654:       len = v + OPSIZE_PUSH + tlen + OPSIZE_POP_OUT + OPSIZE_JUMP;",
          "1655:     }",
          "1656:     else {",
          "1658:     }",
          "1659:     break;",
          "",
          "[Removed Lines]",
          "1657:       len = OPSIZE_ATOMIC_START + tlen + OPSIZE_ATOMIC_END;",
          "",
          "[Added Lines]",
          "1657:       len = OPSIZE_MARK + tlen + OPSIZE_CUT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1667:       len = compile_length_tree(cond, reg);",
          "1668:       if (len < 0) return len;",
          "1672:       if (IS_NOT_NULL(Then)) {",
          "1673:         tlen = compile_length_tree(Then, reg);",
          "",
          "[Removed Lines]",
          "1669:       len += OPSIZE_PUSH;",
          "1670:       len += OPSIZE_ATOMIC_START + OPSIZE_ATOMIC_END;",
          "",
          "[Added Lines]",
          "1669:       len += OPSIZE_PUSH + OPSIZE_MARK + OPSIZE_CUT;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1675:         len += tlen;",
          "1676:       }",
          "1680:       if (IS_NOT_NULL(Else)) {",
          "1681:         tlen = compile_length_tree(Else, reg);",
          "",
          "[Removed Lines]",
          "1678:       len += OPSIZE_JUMP + OPSIZE_ATOMIC_END;",
          "",
          "[Added Lines]",
          "1677:       len += OPSIZE_JUMP + OPSIZE_CUT;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1812:       COP(reg)->jump.addr = -((int )OPSIZE_PUSH + len + (int )OPSIZE_POP_OUT);",
          "1813:     }",
          "1814:     else {",
          "1816:       if (r != 0) return r;",
          "1817:       r = compile_tree(NODE_BAG_BODY(node), reg, env);",
          "1818:       if (r != 0) return r;",
          "1820:     }",
          "1821:     break;",
          "1823:   case BAG_IF_ELSE:",
          "1824:     {",
          "1825:       int cond_len, then_len, else_len, jump_len;",
          "1826:       Node* cond = NODE_BAG_BODY(node);",
          "1827:       Node* Then = node->te.Then;",
          "1828:       Node* Else = node->te.Else;",
          "1831:       if (r != 0) return r;",
          "1833:       cond_len = compile_length_tree(cond, reg);",
          "1834:       if (cond_len < 0) return cond_len;",
          "",
          "[Removed Lines]",
          "1815:       r = add_op(reg, OP_ATOMIC_START);",
          "1819:       r = add_op(reg, OP_ATOMIC_END);",
          "1830:       r = add_op(reg, OP_ATOMIC_START);",
          "",
          "[Added Lines]",
          "1814:       MemNumType mid;",
          "1816:       ID_ENTRY(env, mid);",
          "1817:       r = add_op(reg, OP_MARK);",
          "1819:       COP(reg)->mark.id = mid;",
          "1820:       COP(reg)->mark.save_pos = 0;",
          "1824:       r = add_op(reg, OP_CUT);",
          "1825:       if (r != 0) return r;",
          "1826:       COP(reg)->cut.id = mid;",
          "1827:       COP(reg)->cut.restore_pos = 0;",
          "1834:       MemNumType mid;",
          "1839:       ID_ENTRY(env, mid);",
          "1841:       r = add_op(reg, OP_MARK);",
          "1843:       COP(reg)->mark.id = mid;",
          "1844:       COP(reg)->mark.save_pos = 0;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1839:       else",
          "1840:         then_len = 0;",
          "1844:       r = add_op(reg, OP_PUSH);",
          "1845:       if (r != 0) return r;",
          "",
          "[Removed Lines]",
          "1842:       jump_len = cond_len + then_len + OPSIZE_ATOMIC_END + OPSIZE_JUMP;",
          "",
          "[Added Lines]",
          "1855:       jump_len = cond_len + then_len + OPSIZE_CUT + OPSIZE_JUMP;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1848:       r = compile_tree(cond, reg, env);",
          "1849:       if (r != 0) return r;",
          "1851:       if (r != 0) return r;",
          "1853:       if (IS_NOT_NULL(Then)) {",
          "1854:         r = compile_tree(Then, reg, env);",
          "",
          "[Removed Lines]",
          "1850:       r = add_op(reg, OP_ATOMIC_END);",
          "",
          "[Added Lines]",
          "1863:       r = add_op(reg, OP_CUT);",
          "1865:       COP(reg)->cut.id = mid;",
          "1866:       COP(reg)->cut.restore_pos = 0;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1865:       r = add_op(reg, OP_JUMP);",
          "1866:       if (r != 0) return r;",
          "1870:       if (r != 0) return r;",
          "1872:       if (IS_NOT_NULL(Else)) {",
          "1873:         r = compile_tree(Else, reg, env);",
          "",
          "[Removed Lines]",
          "1867:       COP(reg)->jump.addr = OPSIZE_ATOMIC_END + else_len + SIZE_INC;",
          "1869:       r = add_op(reg, OP_ATOMIC_END);",
          "",
          "[Added Lines]",
          "1882:       COP(reg)->jump.addr = OPSIZE_CUT + else_len + SIZE_INC;",
          "1884:       r = add_op(reg, OP_CUT);",
          "1886:       COP(reg)->cut.id = mid;",
          "1887:       COP(reg)->cut.restore_pos = 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6259ab82762f071af00c8e48f22d7dd79acbc7f2",
      "candidate_info": {
        "commit_hash": "6259ab82762f071af00c8e48f22d7dd79acbc7f2",
        "repo": "kkos/oniguruma",
        "commit_url": "https://github.com/kkos/oniguruma/commit/6259ab82762f071af00c8e48f22d7dd79acbc7f2",
        "files": [
          "src/regcomp.c",
          "src/regint.h"
        ],
        "message": "refactoring",
        "before_after_code_files": [
          "src/regcomp.c||src/regcomp.c",
          "src/regint.h||src/regint.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/regcomp.c||src/regcomp.c"
          ],
          "candidate": [
            "src/regcomp.c||src/regcomp.c"
          ]
        }
      },
      "candidate_diff": {
        "src/regcomp.c||src/regcomp.c": [
          "File: src/regcomp.c -> src/regcomp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "932:   if (r != 0) return r;",
          "934:   COP(reg)->repeat.id   = num_repeat;",
          "937:   r = entry_repeat_range(reg, num_repeat, qn->lower, qn->upper);",
          "938:   if (r != 0) return r;",
          "",
          "[Removed Lines]",
          "935:   COP(reg)->repeat.addr = SIZE_INC_OP + target_len + SIZE_OP_REPEAT_INC;",
          "",
          "[Added Lines]",
          "935:   COP(reg)->repeat.addr = SIZE_INC + target_len + OPSIZE_REPEAT_INC;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "985:     if (qn->lower <= 1 ||",
          "986:         int_multiply_cmp(tlen, qn->lower, QUANTIFIER_EXPAND_LIMIT_SIZE) <= 0) {",
          "987:       if (IS_NOT_NULL(qn->next_head_exact))",
          "989:       else",
          "991:     }",
          "992:   }",
          "994:   mod_tlen = tlen;",
          "995:   if (emptiness != BODY_IS_NOT_EMPTY)",
          "998:   if (infinite &&",
          "999:       (qn->lower <= 1 ||",
          "1000:        int_multiply_cmp(tlen, qn->lower, QUANTIFIER_EXPAND_LIMIT_SIZE) <= 0)) {",
          "1001:     if (qn->lower == 1 && tlen > QUANTIFIER_EXPAND_LIMIT_SIZE) {",
          "1003:     }",
          "1004:     else {",
          "1005:       len = tlen * qn->lower;",
          "",
          "[Removed Lines]",
          "988:         return SIZE_OP_ANYCHAR_STAR_PEEK_NEXT + tlen * qn->lower;",
          "990:         return SIZE_OP_ANYCHAR_STAR + tlen * qn->lower;",
          "996:     mod_tlen += SIZE_OP_EMPTY_CHECK_START + SIZE_OP_EMPTY_CHECK_END;",
          "1002:       len = SIZE_OP_JUMP;",
          "",
          "[Added Lines]",
          "988:         return OPSIZE_ANYCHAR_STAR_PEEK_NEXT + tlen * qn->lower;",
          "990:         return OPSIZE_ANYCHAR_STAR + tlen * qn->lower;",
          "996:     mod_tlen += OPSIZE_EMPTY_CHECK_START + OPSIZE_EMPTY_CHECK_END;",
          "1002:       len = OPSIZE_JUMP;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1008:     if (qn->greedy) {",
          "1009: #ifdef USE_OP_PUSH_OR_JUMP_EXACT",
          "1010:       if (IS_NOT_NULL(qn->head_exact))",
          "1012:       else",
          "1013: #endif",
          "1014:       if (IS_NOT_NULL(qn->next_head_exact))",
          "1016:       else",
          "1018:     }",
          "1019:     else",
          "1021:   }",
          "1022:   else if (qn->upper == 0) {",
          "1025:     }",
          "1026:     else",
          "1027:       len = 0;",
          "1028:   }",
          "1029:   else if (!infinite && qn->greedy &&",
          "1030:            (qn->upper == 1 ||",
          "1032:                              QUANTIFIER_EXPAND_LIMIT_SIZE) <= 0)) {",
          "1033:     len = tlen * qn->lower;",
          "1035:   }",
          "1038:   }",
          "1039:   else {",
          "1041:   }",
          "1043:   return len;",
          "",
          "[Removed Lines]",
          "1011:         len += SIZE_OP_PUSH_OR_JUMP_EXACT1 + mod_tlen + SIZE_OP_JUMP;",
          "1015:         len += SIZE_OP_PUSH_IF_PEEK_NEXT + mod_tlen + SIZE_OP_JUMP;",
          "1017:         len += SIZE_OP_PUSH + mod_tlen + SIZE_OP_JUMP;",
          "1020:       len += SIZE_OP_JUMP + mod_tlen + SIZE_OP_PUSH;",
          "1024:       len = SIZE_OP_JUMP + tlen;",
          "1031:             int_multiply_cmp(tlen + SIZE_OP_PUSH, qn->upper,",
          "1034:     len += (SIZE_OP_PUSH + tlen) * (qn->upper - qn->lower);",
          "1037:     len = SIZE_OP_PUSH + SIZE_OP_JUMP + tlen;",
          "1040:     len = SIZE_OP_REPEAT_INC + mod_tlen + SIZE_OP_REPEAT;",
          "",
          "[Added Lines]",
          "1011:         len += OPSIZE_PUSH_OR_JUMP_EXACT1 + mod_tlen + OPSIZE_JUMP;",
          "1015:         len += OPSIZE_PUSH_IF_PEEK_NEXT + mod_tlen + OPSIZE_JUMP;",
          "1017:         len += OPSIZE_PUSH + mod_tlen + OPSIZE_JUMP;",
          "1020:       len += OPSIZE_JUMP + mod_tlen + OPSIZE_PUSH;",
          "1024:       len = OPSIZE_JUMP + tlen;",
          "1031:             int_multiply_cmp(tlen + OPSIZE_PUSH, qn->upper,",
          "1034:     len += (OPSIZE_PUSH + tlen) * (qn->upper - qn->lower);",
          "1037:     len = OPSIZE_PUSH + OPSIZE_JUMP + tlen;",
          "1040:     len = OPSIZE_REPEAT_INC + mod_tlen + OPSIZE_REPEAT;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1079:   mod_tlen = tlen;",
          "1080:   if (emptiness != BODY_IS_NOT_EMPTY)",
          "1083:   if (infinite &&",
          "1084:       (qn->lower <= 1 ||",
          "",
          "[Removed Lines]",
          "1081:     mod_tlen += SIZE_OP_EMPTY_CHECK_START + SIZE_OP_EMPTY_CHECK_END;",
          "",
          "[Added Lines]",
          "1081:     mod_tlen += OPSIZE_EMPTY_CHECK_START + OPSIZE_EMPTY_CHECK_END;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1091:       if (qn->greedy) {",
          "1092: #ifdef USE_OP_PUSH_OR_JUMP_EXACT",
          "1093:         if (IS_NOT_NULL(qn->head_exact))",
          "1095:         else",
          "1096: #endif",
          "1097:         if (IS_NOT_NULL(qn->next_head_exact))",
          "1099:         else",
          "1101:       }",
          "1102:       else {",
          "1104:       }",
          "1105:     }",
          "1106:     else {",
          "",
          "[Removed Lines]",
          "1094:           COP(reg)->jump.addr = SIZE_OP_PUSH_OR_JUMP_EXACT1 + SIZE_INC_OP;",
          "1098:           COP(reg)->jump.addr = SIZE_OP_PUSH_IF_PEEK_NEXT + SIZE_INC_OP;",
          "1100:           COP(reg)->jump.addr = SIZE_OP_PUSH + SIZE_INC_OP;",
          "1103:         COP(reg)->jump.addr = SIZE_OP_JUMP + SIZE_INC_OP;",
          "",
          "[Added Lines]",
          "1094:           COP(reg)->jump.addr = OPSIZE_PUSH_OR_JUMP_EXACT1 + SIZE_INC;",
          "1098:           COP(reg)->jump.addr = OPSIZE_PUSH_IF_PEEK_NEXT + SIZE_INC;",
          "1100:           COP(reg)->jump.addr = OPSIZE_PUSH + SIZE_INC;",
          "1103:         COP(reg)->jump.addr = OPSIZE_JUMP + SIZE_INC;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1113:       if (IS_NOT_NULL(qn->head_exact)) {",
          "1114:         r = add_op(reg, OP_PUSH_OR_JUMP_EXACT1);",
          "1115:         if (r != 0) return r;",
          "1117:         COP(reg)->push_or_jump_exact1.c    = STR_(qn->head_exact)->s[0];",
          "1119:         r = compile_tree_empty_check(NODE_QUANT_BODY(qn), reg, emptiness, env);",
          "1120:         if (r != 0) return r;",
          "1123:       }",
          "1124:       else",
          "1125: #endif",
          "1126:       if (IS_NOT_NULL(qn->next_head_exact)) {",
          "1127:         r = add_op(reg, OP_PUSH_IF_PEEK_NEXT);",
          "1128:         if (r != 0) return r;",
          "1130:         COP(reg)->push_if_peek_next.c    = STR_(qn->next_head_exact)->s[0];",
          "1132:         r = compile_tree_empty_check(NODE_QUANT_BODY(qn), reg, emptiness, env);",
          "1133:         if (r != 0) return r;",
          "1136:       }",
          "1137:       else {",
          "1138:         r = add_op(reg, OP_PUSH);",
          "1139:         if (r != 0) return r;",
          "1142:         r = compile_tree_empty_check(NODE_QUANT_BODY(qn), reg, emptiness, env);",
          "1143:         if (r != 0) return r;",
          "1146:       }",
          "1148:       r = add_op(reg, OP_JUMP);",
          "",
          "[Removed Lines]",
          "1116:         COP(reg)->push_or_jump_exact1.addr = SIZE_INC_OP + mod_tlen + SIZE_OP_JUMP;",
          "1122:         addr = -(mod_tlen + (int )SIZE_OP_PUSH_OR_JUMP_EXACT1);",
          "1129:         COP(reg)->push_if_peek_next.addr = SIZE_INC_OP + mod_tlen + SIZE_OP_JUMP;",
          "1135:         addr = -(mod_tlen + (int )SIZE_OP_PUSH_IF_PEEK_NEXT);",
          "1140:         COP(reg)->push.addr = SIZE_INC_OP + mod_tlen + SIZE_OP_JUMP;",
          "1145:         addr = -(mod_tlen + (int )SIZE_OP_PUSH);",
          "",
          "[Added Lines]",
          "1116:         COP(reg)->push_or_jump_exact1.addr = SIZE_INC + mod_tlen + OPSIZE_JUMP;",
          "1122:         addr = -(mod_tlen + (int )OPSIZE_PUSH_OR_JUMP_EXACT1);",
          "1129:         COP(reg)->push_if_peek_next.addr = SIZE_INC + mod_tlen + OPSIZE_JUMP;",
          "1135:         addr = -(mod_tlen + (int )OPSIZE_PUSH_IF_PEEK_NEXT);",
          "1140:         COP(reg)->push.addr = SIZE_INC + mod_tlen + OPSIZE_JUMP;",
          "1145:         addr = -(mod_tlen + (int )OPSIZE_PUSH);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1152:     else {",
          "1153:       r = add_op(reg, OP_JUMP);",
          "1154:       if (r != 0) return r;",
          "1157:       r = compile_tree_empty_check(NODE_QUANT_BODY(qn), reg, emptiness, env);",
          "1158:       if (r != 0) return r;",
          "",
          "[Removed Lines]",
          "1155:       COP(reg)->jump.addr = mod_tlen + SIZE_INC_OP;",
          "",
          "[Added Lines]",
          "1155:       COP(reg)->jump.addr = mod_tlen + SIZE_INC;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1167:       r = add_op(reg, OP_JUMP);",
          "1168:       if (r != 0) return r;",
          "1171:       r = compile_tree(NODE_QUANT_BODY(qn), reg, env);",
          "1172:     }",
          "",
          "[Removed Lines]",
          "1169:       COP(reg)->jump.addr = tlen + SIZE_INC_OP;",
          "",
          "[Added Lines]",
          "1169:       COP(reg)->jump.addr = tlen + SIZE_INC;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1177:   }",
          "1178:   else if (! infinite && qn->greedy &&",
          "1179:            (qn->upper == 1 ||",
          "1181:                              QUANTIFIER_EXPAND_LIMIT_SIZE) <= 0)) {",
          "1182:     int n = qn->upper - qn->lower;",
          "",
          "[Removed Lines]",
          "1180:             int_multiply_cmp(tlen + SIZE_OP_PUSH, qn->upper,",
          "",
          "[Added Lines]",
          "1180:             int_multiply_cmp(tlen + OPSIZE_PUSH, qn->upper,",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1185:     if (r != 0) return r;",
          "1187:     for (i = 0; i < n; i++) {",
          "1189:       if (v < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;",
          "1191:       r = add_op(reg, OP_PUSH);",
          "",
          "[Removed Lines]",
          "1188:       int v = onig_positive_int_multiply(n - i, tlen + SIZE_OP_PUSH);",
          "",
          "[Added Lines]",
          "1188:       int v = onig_positive_int_multiply(n - i, tlen + OPSIZE_PUSH);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1200:     r = add_op(reg, OP_PUSH);",
          "1201:     if (r != 0) return r;",
          "1204:     r = add_op(reg, OP_JUMP);",
          "1205:     if (r != 0) return r;",
          "1208:     r = compile_tree(NODE_QUANT_BODY(qn), reg, env);",
          "1209:   }",
          "",
          "[Removed Lines]",
          "1202:     COP(reg)->push.addr = SIZE_INC_OP + SIZE_OP_JUMP;",
          "1206:     COP(reg)->jump.addr = tlen + SIZE_INC_OP;",
          "",
          "[Added Lines]",
          "1202:     COP(reg)->push.addr = SIZE_INC + OPSIZE_JUMP;",
          "1206:     COP(reg)->jump.addr = tlen + SIZE_INC;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1260: #ifdef USE_CALL",
          "1262:     if (node->m.regnum == 0 && NODE_IS_CALLED(node)) {",
          "1264:       return len;",
          "1265:     }",
          "1267:     if (NODE_IS_CALLED(node)) {",
          "1270:       if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))",
          "1271:         len += (NODE_IS_RECURSION(node)",
          "1273:       else",
          "1274:         len += (NODE_IS_RECURSION(node)",
          "1276:     }",
          "1277:     else if (NODE_IS_RECURSION(node)) {",
          "1279:       len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)",
          "1281:     }",
          "1282:     else",
          "1283: #endif",
          "1284:     {",
          "1285:       if (MEM_STATUS_AT0(reg->bt_mem_start, node->m.regnum))",
          "1287:       else",
          "1290:       len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)",
          "1292:     }",
          "1293:     break;",
          "",
          "[Removed Lines]",
          "1263:       len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;",
          "1268:       len = SIZE_OP_MEMORY_START_PUSH + tlen",
          "1269:         + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;",
          "1272:                 ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH);",
          "1275:                 ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END);",
          "1278:       len = SIZE_OP_MEMORY_START_PUSH;",
          "1280:                      ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC);",
          "1286:         len = SIZE_OP_MEMORY_START_PUSH;",
          "1288:         len = SIZE_OP_MEMORY_START;",
          "1291:                      ? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END);",
          "",
          "[Added Lines]",
          "1263:       len = tlen + OPSIZE_CALL + OPSIZE_JUMP + OPSIZE_RETURN;",
          "1268:       len = OPSIZE_MEMORY_START_PUSH + tlen",
          "1269:         + OPSIZE_CALL + OPSIZE_JUMP + OPSIZE_RETURN;",
          "1272:                 ? OPSIZE_MEMORY_END_PUSH_REC : OPSIZE_MEMORY_END_PUSH);",
          "1275:                 ? OPSIZE_MEMORY_END_REC : OPSIZE_MEMORY_END);",
          "1278:       len = OPSIZE_MEMORY_START_PUSH;",
          "1280:                      ? OPSIZE_MEMORY_END_PUSH_REC : OPSIZE_MEMORY_END_REC);",
          "1286:         len = OPSIZE_MEMORY_START_PUSH;",
          "1288:         len = OPSIZE_MEMORY_START;",
          "1291:                      ? OPSIZE_MEMORY_END_PUSH : OPSIZE_MEMORY_END);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1304:       v = onig_positive_int_multiply(qn->lower, tlen);",
          "1305:       if (v < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;",
          "1307:     }",
          "1308:     else {",
          "1310:     }",
          "1311:     break;",
          "",
          "[Removed Lines]",
          "1306:       len = v + SIZE_OP_PUSH + tlen + SIZE_OP_POP_OUT + SIZE_OP_JUMP;",
          "1309:       len = SIZE_OP_ATOMIC_START + tlen + SIZE_OP_ATOMIC_END;",
          "",
          "[Added Lines]",
          "1306:       len = v + OPSIZE_PUSH + tlen + OPSIZE_POP_OUT + OPSIZE_JUMP;",
          "1309:       len = OPSIZE_ATOMIC_START + tlen + OPSIZE_ATOMIC_END;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1319:       len = compile_length_tree(cond, reg);",
          "1320:       if (len < 0) return len;",
          "1324:       if (IS_NOT_NULL(Then)) {",
          "1325:         tlen = compile_length_tree(Then, reg);",
          "",
          "[Removed Lines]",
          "1321:       len += SIZE_OP_PUSH;",
          "1322:       len += SIZE_OP_ATOMIC_START + SIZE_OP_ATOMIC_END;",
          "",
          "[Added Lines]",
          "1321:       len += OPSIZE_PUSH;",
          "1322:       len += OPSIZE_ATOMIC_START + OPSIZE_ATOMIC_END;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1327:         len += tlen;",
          "1328:       }",
          "1332:       if (IS_NOT_NULL(Else)) {",
          "1333:         tlen = compile_length_tree(Else, reg);",
          "",
          "[Removed Lines]",
          "1330:       len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END;",
          "",
          "[Added Lines]",
          "1330:       len += OPSIZE_JUMP + OPSIZE_ATOMIC_END;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1359:     r = add_op(reg, OP_CALL);",
          "1360:     if (r != 0) return r;",
          "1363:     NODE_STATUS_ADD(node, ADDR_FIXED);",
          "1364:     COP(reg)->call.addr = (int )node->m.called_addr;",
          "1366:     if (node->m.regnum == 0) {",
          "1367:       len = compile_length_tree(NODE_BAG_BODY(node), reg);",
          "1370:       r = add_op(reg, OP_JUMP);",
          "1371:       if (r != 0) return r;",
          "1374:       r = compile_tree(NODE_BAG_BODY(node), reg, env);",
          "1375:       if (r != 0) return r;",
          "",
          "[Removed Lines]",
          "1362:     node->m.called_addr = COP_CURR_OFFSET(reg) + 1 + SIZE_OP_JUMP;",
          "1368:       len += SIZE_OP_RETURN;",
          "1372:       COP(reg)->jump.addr = len + SIZE_INC_OP;",
          "",
          "[Added Lines]",
          "1362:     node->m.called_addr = COP_CURR_OFFSET(reg) + 1 + OPSIZE_JUMP;",
          "1368:       len += OPSIZE_RETURN;",
          "1372:       COP(reg)->jump.addr = len + SIZE_INC;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1379:     }",
          "1380:     else {",
          "1381:       len = compile_length_tree(NODE_BAG_BODY(node), reg);",
          "1383:       if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))",
          "1384:         len += (NODE_IS_RECURSION(node)",
          "1386:       else",
          "1387:         len += (NODE_IS_RECURSION(node)",
          "1390:       r = add_op(reg, OP_JUMP);",
          "1391:       if (r != 0) return r;",
          "1393:     }",
          "1394:   }",
          "1395: #endif",
          "",
          "[Removed Lines]",
          "1382:       len += (SIZE_OP_MEMORY_START_PUSH + SIZE_OP_RETURN);",
          "1385:                 ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH);",
          "1388:                 ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END);",
          "1392:       COP(reg)->jump.addr = len + SIZE_INC_OP;",
          "",
          "[Added Lines]",
          "1382:       len += (OPSIZE_MEMORY_START_PUSH + OPSIZE_RETURN);",
          "1385:                 ? OPSIZE_MEMORY_END_PUSH_REC : OPSIZE_MEMORY_END_PUSH);",
          "1388:                 ? OPSIZE_MEMORY_END_REC : OPSIZE_MEMORY_END);",
          "1392:       COP(reg)->jump.addr = len + SIZE_INC;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1455:       r = add_op(reg, OP_PUSH);",
          "1456:       if (r != 0) return r;",
          "1459:       r = compile_tree(NODE_QUANT_BODY(qn), reg, env);",
          "1460:       if (r != 0) return r;",
          "",
          "[Removed Lines]",
          "1457:       COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP;",
          "",
          "[Added Lines]",
          "1457:       COP(reg)->push.addr = SIZE_INC + len + OPSIZE_POP_OUT + OPSIZE_JUMP;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1464:       r = add_op(reg, OP_JUMP);",
          "1465:       if (r != 0) return r;",
          "1467:     }",
          "1468:     else {",
          "1469:       r = add_op(reg, OP_ATOMIC_START);",
          "",
          "[Removed Lines]",
          "1466:       COP(reg)->jump.addr = -((int )SIZE_OP_PUSH + len + (int )SIZE_OP_POP_OUT);",
          "",
          "[Added Lines]",
          "1466:       COP(reg)->jump.addr = -((int )OPSIZE_PUSH + len + (int )OPSIZE_POP_OUT);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1493:       else",
          "1494:         then_len = 0;",
          "1498:       r = add_op(reg, OP_PUSH);",
          "1499:       if (r != 0) return r;",
          "1502:       r = compile_tree(cond, reg, env);",
          "1503:       if (r != 0) return r;",
          "",
          "[Removed Lines]",
          "1496:       jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP;",
          "1500:       COP(reg)->push.addr = SIZE_INC_OP + jump_len;",
          "",
          "[Added Lines]",
          "1496:       jump_len = cond_len + then_len + OPSIZE_ATOMIC_END + OPSIZE_JUMP;",
          "1500:       COP(reg)->push.addr = SIZE_INC + jump_len;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1519:       r = add_op(reg, OP_JUMP);",
          "1520:       if (r != 0) return r;",
          "1523:       r = add_op(reg, OP_ATOMIC_END);",
          "1524:       if (r != 0) return r;",
          "",
          "[Removed Lines]",
          "1521:       COP(reg)->jump.addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP;",
          "",
          "[Added Lines]",
          "1521:       COP(reg)->jump.addr = OPSIZE_ATOMIC_END + else_len + SIZE_INC;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1547:   switch (node->type) {",
          "1548:   case ANCR_PREC_READ:",
          "1550:     break;",
          "1551:   case ANCR_PREC_READ_NOT:",
          "1553:     break;",
          "1554:   case ANCR_LOOK_BEHIND:",
          "1556:     break;",
          "1557:   case ANCR_LOOK_BEHIND_NOT:",
          "1559:     break;",
          "1561:   case ANCR_WORD_BOUNDARY:",
          "",
          "[Removed Lines]",
          "1549:     len = SIZE_OP_PREC_READ_START + tlen + SIZE_OP_PREC_READ_END;",
          "1552:     len = SIZE_OP_PREC_READ_NOT_START + tlen + SIZE_OP_PREC_READ_NOT_END;",
          "1555:     len = SIZE_OP_LOOK_BEHIND + tlen;",
          "1558:     len = SIZE_OP_LOOK_BEHIND_NOT_START + tlen + SIZE_OP_LOOK_BEHIND_NOT_END;",
          "",
          "[Added Lines]",
          "1549:     len = OPSIZE_PREC_READ_START + tlen + OPSIZE_PREC_READ_END;",
          "1552:     len = OPSIZE_PREC_READ_NOT_START + tlen + OPSIZE_PREC_READ_NOT_END;",
          "1555:     len = OPSIZE_LOOK_BEHIND + tlen;",
          "1558:     len = OPSIZE_LOOK_BEHIND_NOT_START + tlen + OPSIZE_LOOK_BEHIND_NOT_END;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1564:   case ANCR_WORD_BEGIN:",
          "1565:   case ANCR_WORD_END:",
          "1566: #endif",
          "1568:     break;",
          "1570:   case ANCR_TEXT_SEGMENT_BOUNDARY:",
          "",
          "[Removed Lines]",
          "1567:     len = SIZE_OP_WORD_BOUNDARY;",
          "",
          "[Added Lines]",
          "1567:     len = OPSIZE_WORD_BOUNDARY;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1649:     r = add_op(reg, OP_PREC_READ_NOT_START);",
          "1650:     if (r != 0) return r;",
          "1652:     r = compile_tree(NODE_ANCHOR_BODY(node), reg, env);",
          "1653:     if (r != 0) return r;",
          "1654:     r = add_op(reg, OP_PREC_READ_NOT_END);",
          "",
          "[Removed Lines]",
          "1651:     COP(reg)->prec_read_not_start.addr = SIZE_INC_OP + len + SIZE_OP_PREC_READ_NOT_END;",
          "",
          "[Added Lines]",
          "1651:     COP(reg)->prec_read_not_start.addr = SIZE_INC + len + OPSIZE_PREC_READ_NOT_END;",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1678:       len = compile_length_tree(NODE_ANCHOR_BODY(node), reg);",
          "1679:       r = add_op(reg, OP_LOOK_BEHIND_NOT_START);",
          "1680:       if (r != 0) return r;",
          "1683:       if (node->char_len < 0) {",
          "1684:         r = get_char_len_node(NODE_ANCHOR_BODY(node), reg, &n);",
          "",
          "[Removed Lines]",
          "1681:       COP(reg)->look_behind_not_start.addr = SIZE_INC_OP + len + SIZE_OP_LOOK_BEHIND_NOT_END;",
          "",
          "[Added Lines]",
          "1681:       COP(reg)->look_behind_not_start.addr = SIZE_INC + len + OPSIZE_LOOK_BEHIND_NOT_END;",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1765:   switch (node->type) {",
          "1766:   case GIMMICK_FAIL:",
          "1768:     break;",
          "1770:   case GIMMICK_SAVE:",
          "1772:     break;",
          "1774:   case GIMMICK_UPDATE_VAR:",
          "1776:     break;",
          "1778: #ifdef USE_CALLOUT",
          "1779:   case GIMMICK_CALLOUT:",
          "1780:     switch (node->detail_type) {",
          "1781:     case ONIG_CALLOUT_OF_CONTENTS:",
          "1783:       break;",
          "1784:     case ONIG_CALLOUT_OF_NAME:",
          "1786:       break;",
          "1788:     default:",
          "",
          "[Removed Lines]",
          "1767:     len = SIZE_OP_FAIL;",
          "1771:     len = SIZE_OP_PUSH_SAVE_VAL;",
          "1775:     len = SIZE_OP_UPDATE_VAR;",
          "1782:       len = SIZE_OP_CALLOUT_CONTENTS;",
          "1785:       len = SIZE_OP_CALLOUT_NAME;",
          "",
          "[Added Lines]",
          "1767:     len = OPSIZE_FAIL;",
          "1771:     len = OPSIZE_PUSH_SAVE_VAL;",
          "1775:     len = OPSIZE_UPDATE_VAR;",
          "1782:       len = OPSIZE_CALLOUT_CONTENTS;",
          "1785:       len = OPSIZE_CALLOUT_NAME;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1821:         r += compile_length_tree(NODE_CAR(node), reg);",
          "1822:         n++;",
          "1823:       } while (IS_NOT_NULL(node = NODE_CDR(node)));",
          "1825:     }",
          "1826:     break;",
          "",
          "[Removed Lines]",
          "1824:       r += (SIZE_OP_PUSH + SIZE_OP_JUMP) * (n - 1);",
          "",
          "[Added Lines]",
          "1824:       r += (OPSIZE_PUSH + OPSIZE_JUMP) * (n - 1);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1841:     break;",
          "1843:   case NODE_BACKREF:",
          "1845:     break;",
          "1847: #ifdef USE_CALL",
          "1848:   case NODE_CALL:",
          "1850:     break;",
          "1851: #endif",
          "",
          "[Removed Lines]",
          "1844:     r = SIZE_OP_BACKREF;",
          "1849:     r = SIZE_OP_CALL;",
          "",
          "[Added Lines]",
          "1844:     r = OPSIZE_BACKREF;",
          "1849:     r = OPSIZE_CALL;",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1893:       do {",
          "1894:         len += compile_length_tree(NODE_CAR(x), reg);",
          "1895:         if (IS_NOT_NULL(NODE_CDR(x))) {",
          "1897:         }",
          "1898:       } while (IS_NOT_NULL(x = NODE_CDR(x)));",
          "",
          "[Removed Lines]",
          "1896:           len += SIZE_OP_PUSH + SIZE_OP_JUMP;",
          "",
          "[Added Lines]",
          "1896:           len += OPSIZE_PUSH + OPSIZE_JUMP;",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1904:           enum OpCode push = NODE_IS_SUPER(node) ? OP_PUSH_SUPER : OP_PUSH;",
          "1905:           r = add_op(reg, push);",
          "1906:           if (r != 0) break;",
          "1908:         }",
          "1909:         r = compile_tree(NODE_CAR(node), reg, env);",
          "1910:         if (r != 0) break;",
          "",
          "[Removed Lines]",
          "1907:           COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_JUMP;",
          "",
          "[Added Lines]",
          "1907:           COP(reg)->push.addr = SIZE_INC + len + OPSIZE_JUMP;",
          "",
          "---------------"
        ],
        "src/regint.h||src/regint.h": [
          "File: src/regint.h -> src/regint.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "665: #ifdef USE_OP_PUSH_OR_JUMP_EXACT",
          "667: #endif",
          "697: #ifdef USE_CALLOUT",
          "700: #endif",
          "",
          "[Removed Lines]",
          "657: #define SIZE_INC_OP                     1",
          "659: #define SIZE_OP_ANYCHAR_STAR            1",
          "660: #define SIZE_OP_ANYCHAR_STAR_PEEK_NEXT  1",
          "661: #define SIZE_OP_JUMP                    1",
          "662: #define SIZE_OP_PUSH                    1",
          "663: #define SIZE_OP_PUSH_SUPER              1",
          "664: #define SIZE_OP_POP_OUT                 1",
          "666: #define SIZE_OP_PUSH_OR_JUMP_EXACT1     1",
          "668: #define SIZE_OP_PUSH_IF_PEEK_NEXT       1",
          "669: #define SIZE_OP_REPEAT                  1",
          "670: #define SIZE_OP_REPEAT_INC              1",
          "671: #define SIZE_OP_REPEAT_INC_NG           1",
          "672: #define SIZE_OP_WORD_BOUNDARY           1",
          "673: #define SIZE_OP_PREC_READ_START         1",
          "674: #define SIZE_OP_PREC_READ_NOT_START     1",
          "675: #define SIZE_OP_PREC_READ_END           1",
          "676: #define SIZE_OP_PREC_READ_NOT_END       1",
          "677: #define SIZE_OP_BACKREF                 1",
          "678: #define SIZE_OP_FAIL                    1",
          "679: #define SIZE_OP_MEMORY_START            1",
          "680: #define SIZE_OP_MEMORY_START_PUSH       1",
          "681: #define SIZE_OP_MEMORY_END_PUSH         1",
          "682: #define SIZE_OP_MEMORY_END_PUSH_REC     1",
          "683: #define SIZE_OP_MEMORY_END              1",
          "684: #define SIZE_OP_MEMORY_END_REC          1",
          "685: #define SIZE_OP_ATOMIC_START            1",
          "686: #define SIZE_OP_ATOMIC_END              1",
          "687: #define SIZE_OP_EMPTY_CHECK_START       1",
          "688: #define SIZE_OP_EMPTY_CHECK_END         1",
          "689: #define SIZE_OP_LOOK_BEHIND             1",
          "690: #define SIZE_OP_LOOK_BEHIND_NOT_START   1",
          "691: #define SIZE_OP_LOOK_BEHIND_NOT_END     1",
          "692: #define SIZE_OP_CALL                    1",
          "693: #define SIZE_OP_RETURN                  1",
          "694: #define SIZE_OP_PUSH_SAVE_VAL           1",
          "695: #define SIZE_OP_UPDATE_VAR              1",
          "698: #define SIZE_OP_CALLOUT_CONTENTS        1",
          "699: #define SIZE_OP_CALLOUT_NAME            1",
          "",
          "[Added Lines]",
          "659: #define SIZE_INC                       1",
          "661: #define OPSIZE_ANYCHAR_STAR            1",
          "662: #define OPSIZE_ANYCHAR_STAR_PEEK_NEXT  1",
          "663: #define OPSIZE_JUMP                    1",
          "664: #define OPSIZE_PUSH                    1",
          "665: #define OPSIZE_PUSH_SUPER              1",
          "666: #define OPSIZE_POP_OUT                 1",
          "668: #define OPSIZE_PUSH_OR_JUMP_EXACT1     1",
          "670: #define OPSIZE_PUSH_IF_PEEK_NEXT       1",
          "671: #define OPSIZE_REPEAT                  1",
          "672: #define OPSIZE_REPEAT_INC              1",
          "673: #define OPSIZE_REPEAT_INC_NG           1",
          "674: #define OPSIZE_WORD_BOUNDARY           1",
          "675: #define OPSIZE_PREC_READ_START         1",
          "676: #define OPSIZE_PREC_READ_NOT_START     1",
          "677: #define OPSIZE_PREC_READ_END           1",
          "678: #define OPSIZE_PREC_READ_NOT_END       1",
          "679: #define OPSIZE_BACKREF                 1",
          "680: #define OPSIZE_FAIL                    1",
          "681: #define OPSIZE_MEMORY_START            1",
          "682: #define OPSIZE_MEMORY_START_PUSH       1",
          "683: #define OPSIZE_MEMORY_END_PUSH         1",
          "684: #define OPSIZE_MEMORY_END_PUSH_REC     1",
          "685: #define OPSIZE_MEMORY_END              1",
          "686: #define OPSIZE_MEMORY_END_REC          1",
          "687: #define OPSIZE_ATOMIC_START            1",
          "688: #define OPSIZE_ATOMIC_END              1",
          "689: #define OPSIZE_EMPTY_CHECK_START       1",
          "690: #define OPSIZE_EMPTY_CHECK_END         1",
          "691: #define OPSIZE_LOOK_BEHIND             1",
          "692: #define OPSIZE_LOOK_BEHIND_NOT_START   1",
          "693: #define OPSIZE_LOOK_BEHIND_NOT_END     1",
          "694: #define OPSIZE_CALL                    1",
          "695: #define OPSIZE_RETURN                  1",
          "696: #define OPSIZE_PUSH_SAVE_VAL           1",
          "697: #define OPSIZE_UPDATE_VAR              1",
          "700: #define OPSIZE_CALLOUT_CONTENTS        1",
          "701: #define OPSIZE_CALLOUT_NAME            1",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f000bbb7729bd250c6de006880c0cbbeaca6efb3",
      "candidate_info": {
        "commit_hash": "f000bbb7729bd250c6de006880c0cbbeaca6efb3",
        "repo": "kkos/oniguruma",
        "commit_url": "https://github.com/kkos/oniguruma/commit/f000bbb7729bd250c6de006880c0cbbeaca6efb3",
        "files": [
          "src/regcomp.c",
          "src/regexec.c",
          "src/regint.h"
        ],
        "message": "re-implement bytecode by using Operation struct",
        "before_after_code_files": [
          "src/regcomp.c||src/regcomp.c",
          "src/regexec.c||src/regexec.c",
          "src/regint.h||src/regint.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/regcomp.c||src/regcomp.c"
          ],
          "candidate": [
            "src/regcomp.c||src/regcomp.c"
          ]
        }
      },
      "candidate_diff": {
        "src/regcomp.c||src/regcomp.c": [
          "File: src/regcomp.c -> src/regcomp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "108: }",
          "109: #endif",
          "111: extern OnigCaseFoldType",
          "112: onig_get_default_case_fold_flag(void)",
          "113: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "111: static int",
          "112: ops_init(regex_t* reg, int init_alloc_size)",
          "113: {",
          "114:   Operation* p;",
          "115:   size_t size = sizeof(Operation) * init_alloc_size;",
          "117:   if (init_alloc_size > 0) {",
          "118:     p = (Operation* )xrealloc(reg->ops, size);",
          "119:     CHECK_NULL_RETURN_MEMERR(p);",
          "120:   }",
          "121:   else {",
          "122:     p = (Operation* )0;",
          "123:   }",
          "125:   reg->ops = p;",
          "127:   reg->ops_alloc = init_alloc_size;",
          "128:   reg->ops_used  = 0;",
          "130:   return ONIG_NORMAL;",
          "131: }",
          "133: static int",
          "134: ops_expand(regex_t* reg, int n)",
          "135: {",
          "136: #define MIN_OPS_EXPAND_SIZE   4",
          "138:   Operation* p;",
          "139:   size_t size;",
          "141:   if (n <= 0) n = MIN_OPS_EXPAND_SIZE;",
          "143:   n += reg->ops_alloc;",
          "144:   size = sizeof(Operation) * n;",
          "146:   p = (Operation* )xrealloc(reg->ops, size);",
          "147:   CHECK_NULL_RETURN_MEMERR(p);",
          "149:   reg->ops = p;",
          "150:   reg->ops_alloc = n;",
          "151:   if (reg->ops_used == 0)",
          "152:     reg->ops_curr = 0;",
          "153:   else",
          "154:     reg->ops_curr = reg->ops + (reg->ops_used - 1);",
          "156:   return ONIG_NORMAL;",
          "157: }",
          "159: static int",
          "160: ops_new(regex_t* reg)",
          "161: {",
          "162:   int r;",
          "164:   if (reg->ops_used >= reg->ops_alloc) {",
          "165:     r = ops_expand(reg, reg->ops_alloc);",
          "166:     if (r != ONIG_NORMAL) return r;",
          "167:   }",
          "169:   reg->ops_curr = reg->ops + reg->ops_used;",
          "170:   reg->ops_used++;",
          "172:   xmemset(reg->ops_curr, 0, sizeof(Operation));",
          "173:   return ONIG_NORMAL;",
          "174: }",
          "176: static void",
          "177: ops_free(regex_t* reg)",
          "178: {",
          "179:   int i;",
          "181:   if (IS_NULL(reg->ops)) return ;",
          "183:   for (i = 0; i < reg->ops_used; i++) {",
          "184:     Operation* op = reg->ops + i;",
          "185:     switch (op->opcode) {",
          "186:     case OP_EXACTMBN:",
          "187:       xfree(op->exact_len_n.s);",
          "188:       break;",
          "189:     case OP_EXACTN: case OP_EXACTMB2N: case OP_EXACTMB3N: case OP_EXACTN_IC:",
          "190:       xfree(op->exact_n.s);",
          "191:       break;",
          "192:     case OP_EXACT1: case OP_EXACT2: case OP_EXACT3: case OP_EXACT4:",
          "193:     case OP_EXACT5: case OP_EXACTMB2N1: case OP_EXACTMB2N2:",
          "194:     case OP_EXACTMB2N3: case OP_EXACT1_IC:",
          "195:       xfree(op->exact.s);",
          "196:       break;",
          "198:     case OP_CCLASS_MB_NOT: case OP_CCLASS_MB:",
          "199:       xfree(op->cclass_mb.mb);",
          "200:       break;",
          "201:     case OP_CCLASS_MIX_NOT: case OP_CCLASS_MIX:",
          "202:       xfree(op->cclass_mix.mb);",
          "203:       break;",
          "205:     case OP_BACKREF1: case OP_BACKREF2: case OP_BACKREF_N: case OP_BACKREF_N_IC:",
          "206:       break;",
          "207:     case OP_BACKREF_MULTI:      case OP_BACKREF_MULTI_IC:",
          "208:     case OP_BACKREF_WITH_LEVEL: case OP_BACKREF_CHECK:",
          "209:     case OP_BACKREF_CHECK_WITH_LEVEL:",
          "210:       if (op->backref_general.num != 1)",
          "211:         xfree(op->backref_general.ns);",
          "212:       break;",
          "214:     default:",
          "215:       break;",
          "216:     }",
          "217:   }",
          "219:   xfree(reg->ops);",
          "221:   reg->ops = 0;",
          "222:   reg->ops_curr  = 0;",
          "223:   reg->ops_alloc = 0;",
          "224:   reg->ops_used  = 0;",
          "225: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "277: static int",
          "365: {",
          "366:   int r;",
          "385:   return 0;",
          "386: }",
          "",
          "[Removed Lines]",
          "278: add_opcode(regex_t* reg, int opcode)",
          "279: {",
          "280:   BB_ADD1(reg, opcode);",
          "281:   return 0;",
          "282: }",
          "284: static int",
          "285: add_rel_addr(regex_t* reg, int addr)",
          "286: {",
          "287:   RelAddrType ra = (RelAddrType )addr;",
          "289:   BB_ADD(reg, &ra, SIZE_RELADDR);",
          "290:   return 0;",
          "291: }",
          "293: static int",
          "294: add_abs_addr(regex_t* reg, int addr)",
          "295: {",
          "296:   AbsAddrType ra = (AbsAddrType )addr;",
          "298:   BB_ADD(reg, &ra, SIZE_ABSADDR);",
          "299:   return 0;",
          "300: }",
          "302: static int",
          "303: add_length(regex_t* reg, int len)",
          "304: {",
          "305:   LengthType l = (LengthType )len;",
          "307:   BB_ADD(reg, &l, SIZE_LENGTH);",
          "308:   return 0;",
          "309: }",
          "311: static int",
          "312: add_mem_num(regex_t* reg, int num)",
          "313: {",
          "314:   MemNumType n = (MemNumType )num;",
          "316:   BB_ADD(reg, &n, SIZE_MEMNUM);",
          "317:   return 0;",
          "318: }",
          "320: #if 0",
          "321: static int",
          "322: add_pointer(regex_t* reg, void* addr)",
          "323: {",
          "324:   PointerType ptr = (PointerType )addr;",
          "326:   BB_ADD(reg, &ptr, SIZE_POINTER);",
          "327:   return 0;",
          "328: }",
          "329: #endif",
          "331: static int",
          "332: add_option(regex_t* reg, OnigOptionType option)",
          "333: {",
          "334:   BB_ADD(reg, &option, SIZE_OPTION);",
          "335:   return 0;",
          "336: }",
          "338: static int",
          "339: add_save_type(regex_t* reg, enum SaveType type)",
          "340: {",
          "341:   SaveType t = (SaveType )type;",
          "343:   BB_ADD(reg, &t, SIZE_SAVE_TYPE);",
          "344:   return 0;",
          "345: }",
          "347: static int",
          "348: add_update_var_type(regex_t* reg, enum UpdateVarType type)",
          "349: {",
          "350:   UpdateVarType t = (UpdateVarType )type;",
          "352:   BB_ADD(reg, &t, SIZE_UPDATE_VAR_TYPE);",
          "353:   return 0;",
          "354: }",
          "356: static int",
          "357: add_mode(regex_t* reg, ModeType mode)",
          "358: {",
          "359:   BB_ADD(reg, &mode, SIZE_MODE);",
          "360:   return 0;",
          "361: }",
          "363: static int",
          "364: add_opcode_rel_addr(regex_t* reg, int opcode, int addr)",
          "368:   r = add_opcode(reg, opcode);",
          "369:   if (r != 0) return r;",
          "370:   r = add_rel_addr(reg, addr);",
          "371:   return r;",
          "372: }",
          "374: static int",
          "375: add_bytes(regex_t* reg, UChar* bytes, int len)",
          "376: {",
          "377:   BB_ADD(reg, bytes, len);",
          "378:   return 0;",
          "379: }",
          "381: static int",
          "382: add_bitset(regex_t* reg, BitSetRef bs)",
          "383: {",
          "384:   BB_ADD(reg, bs, SIZE_BITSET);",
          "",
          "[Added Lines]",
          "394: add_op(regex_t* reg, int opcode)",
          "398:   r = ops_new(reg);",
          "399:   if (r != ONIG_NORMAL) return r;",
          "401:   reg->ops_curr->opcode = opcode;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "445:   int saved_num_null_check = reg->num_null_check;",
          "447:   if (empty_info != QUANT_BODY_IS_NOT_EMPTY) {",
          "451:     if (r != 0) return r;",
          "452:     reg->num_null_check++;",
          "453:   }",
          "",
          "[Removed Lines]",
          "448:     r = add_opcode(reg, OP_EMPTY_CHECK_START);",
          "449:     if (r != 0) return r;",
          "",
          "[Added Lines]",
          "465:     r = add_op(reg, OP_EMPTY_CHECK_START);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "458:   if (empty_info != QUANT_BODY_IS_NOT_EMPTY) {",
          "459:     if (empty_info == QUANT_BODY_IS_EMPTY)",
          "461:     else if (empty_info == QUANT_BODY_IS_EMPTY_MEM)",
          "463:     else if (empty_info == QUANT_BODY_IS_EMPTY_REC)",
          "466:     if (r != 0) return r;",
          "468:   }",
          "469:   return r;",
          "470: }",
          "",
          "[Removed Lines]",
          "460:       r = add_opcode(reg, OP_EMPTY_CHECK_END);",
          "462:       r = add_opcode(reg, OP_EMPTY_CHECK_END_MEMST);",
          "464:       r = add_opcode(reg, OP_EMPTY_CHECK_END_MEMST_PUSH);",
          "",
          "[Added Lines]",
          "476:       r = add_op(reg, OP_EMPTY_CHECK_END);",
          "478:       r = add_op(reg, OP_EMPTY_CHECK_END_MEMST);",
          "480:       r = add_op(reg, OP_EMPTY_CHECK_END_MEMST_PUSH);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "474: compile_call(CallNode* node, regex_t* reg, ScanEnv* env)",
          "475: {",
          "476:   int r;",
          "482:   if (r != 0) return r;",
          "484:   return r;",
          "485: }",
          "486: #endif",
          "",
          "[Removed Lines]",
          "478:   r = add_opcode(reg, OP_CALL);",
          "479:   if (r != 0) return r;",
          "480:   r = unset_addr_list_add(env->unset_addr_list, BB_GET_OFFSET_POS(reg),",
          "481:                           NODE_CALL_BODY(node));",
          "483:   r = add_abs_addr(reg, 0 /*dummy addr.*/);",
          "",
          "[Added Lines]",
          "493:   int offset;",
          "495:   r = add_op(reg, OP_CALL);",
          "500:   offset = COP_CURR_OFFSET_BYTES(reg, call.addr);",
          "501:   r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "501: add_compile_string_length(UChar* s ARG_UNUSED, int mb_len, int str_len,",
          "502:                           regex_t* reg ARG_UNUSED, int ignore_case)",
          "503: {",
          "515: }",
          "517: static int",
          "518: add_compile_string(UChar* s, int mb_len, int str_len,",
          "519:                    regex_t* reg, int ignore_case)",
          "520: {",
          "528:     if (op == OP_EXACTN_IC)",
          "530:     else",
          "532:   }",
          "535:   return 0;",
          "536: }",
          "539: static int",
          "540: compile_length_string_node(Node* node, regex_t* reg)",
          "541: {",
          "",
          "[Removed Lines]",
          "504:   int len;",
          "505:   int op = select_str_opcode(mb_len, str_len, ignore_case);",
          "507:   len = SIZE_OPCODE;",
          "509:   if (op == OP_EXACTMBN)  len += SIZE_LENGTH;",
          "510:   if (IS_NEED_STR_LEN_OP_EXACT(op))",
          "511:     len += SIZE_LENGTH;",
          "513:   len += mb_len * str_len;",
          "514:   return len;",
          "521:   int op = select_str_opcode(mb_len, str_len, ignore_case);",
          "522:   add_opcode(reg, op);",
          "524:   if (op == OP_EXACTMBN)",
          "525:     add_length(reg, mb_len);",
          "527:   if (IS_NEED_STR_LEN_OP_EXACT(op)) {",
          "529:       add_length(reg, mb_len * str_len);",
          "531:       add_length(reg, str_len);",
          "534:   add_bytes(reg, s, mb_len * str_len);",
          "",
          "[Added Lines]",
          "522:   return 1;",
          "529:   int op;",
          "530:   int r;",
          "531:   UChar* p;",
          "532:   UChar* end;",
          "534:   op = select_str_opcode(mb_len, str_len, ignore_case);",
          "535:   r = add_op(reg, op);",
          "536:   if (r != 0) return r;",
          "538:   end = s + (mb_len * str_len);",
          "539:   p = onigenc_strdup(reg->enc, s, end);",
          "540:   CHECK_NULL_RETURN_MEMERR(p);",
          "542:   if (op == OP_EXACTMBN) {",
          "543:     COP(reg)->exact_len_n.len = mb_len;",
          "544:     COP(reg)->exact_len_n.n   = str_len;",
          "545:     COP(reg)->exact_len_n.s   = p;",
          "546:   }",
          "547:   else if (IS_NEED_STR_LEN_OP_EXACT(op)) {",
          "549:       COP(reg)->exact_n.n = mb_len * str_len;",
          "551:       COP(reg)->exact_n.n = str_len;",
          "553:     COP(reg)->exact_n.s = p;",
          "554:   }",
          "555:   else {",
          "556:     COP(reg)->exact.s = p;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "635:   return add_compile_string(sn->s, 1 /* sb */, (int )(sn->end - sn->s), reg, 0);",
          "636: }",
          "638: static int",
          "639: add_multi_byte_cclass(BBuf* mbuf, regex_t* reg)",
          "640: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "661: #if 0",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "657:   return r;",
          "658: #endif",
          "659: }",
          "663: {",
          "684: }",
          "686: static int",
          "",
          "[Removed Lines]",
          "661: static int",
          "662: compile_length_cclass_node(CClassNode* cc, regex_t* reg)",
          "664:   int len;",
          "666:   if (IS_NULL(cc->mbuf)) {",
          "667:     len = SIZE_OPCODE + SIZE_BITSET;",
          "668:   }",
          "669:   else {",
          "670:     if (ONIGENC_MBC_MINLEN(reg->enc) > 1 || bitset_is_empty(cc->bs)) {",
          "671:       len = SIZE_OPCODE;",
          "672:     }",
          "673:     else {",
          "674:       len = SIZE_OPCODE + SIZE_BITSET;",
          "675:     }",
          "676: #ifdef PLATFORM_UNALIGNED_WORD_ACCESS",
          "677:     len += SIZE_LENGTH + cc->mbuf->used;",
          "678: #else",
          "679:     len += SIZE_LENGTH + cc->mbuf->used + (WORD_ALIGNMENT_SIZE - 1);",
          "680: #endif",
          "681:   }",
          "683:   return len;",
          "",
          "[Added Lines]",
          "684: #endif",
          "686: static void*",
          "687: set_multi_byte_cclass(BBuf* mbuf, regex_t* reg)",
          "689:   size_t len;",
          "690:   void* p;",
          "692:   len = (size_t )mbuf->used;",
          "693:   p = xmalloc(len);",
          "694:   if (IS_NULL(p)) return NULL;",
          "696:   xmemcpy(p, mbuf->p, len);",
          "697:   return p;",
          "698: }",
          "700: static int",
          "701: compile_length_cclass_node(CClassNode* cc, regex_t* reg)",
          "702: {",
          "703:   return 1;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "689:   int r;",
          "691:   if (IS_NULL(cc->mbuf)) {",
          "698:   }",
          "699:   else {",
          "700:     if (ONIGENC_MBC_MINLEN(reg->enc) > 1 || bitset_is_empty(cc->bs)) {",
          "707:     }",
          "708:     else {",
          "715:       if (r != 0) return r;",
          "717:     }",
          "718:   }",
          "721: }",
          "723: static int",
          "",
          "[Removed Lines]",
          "692:     if (IS_NCCLASS_NOT(cc))",
          "693:       add_opcode(reg, OP_CCLASS_NOT);",
          "694:     else",
          "695:       add_opcode(reg, OP_CCLASS);",
          "697:     r = add_bitset(reg, cc->bs);",
          "701:       if (IS_NCCLASS_NOT(cc))",
          "702:         add_opcode(reg, OP_CCLASS_MB_NOT);",
          "703:       else",
          "704:         add_opcode(reg, OP_CCLASS_MB);",
          "706:       r = add_multi_byte_cclass(cc->mbuf, reg);",
          "709:       if (IS_NCCLASS_NOT(cc))",
          "710:         add_opcode(reg, OP_CCLASS_MIX_NOT);",
          "711:       else",
          "712:         add_opcode(reg, OP_CCLASS_MIX);",
          "714:       r = add_bitset(reg, cc->bs);",
          "716:       r = add_multi_byte_cclass(cc->mbuf, reg);",
          "720:   return r;",
          "",
          "[Added Lines]",
          "712:     r = add_op(reg, IS_NCCLASS_NOT(cc) ? OP_CCLASS_NOT : OP_CCLASS);",
          "713:     if (r != 0) return r;",
          "715:     xmemcpy(COP(reg)->cclass.bs, cc->bs, SIZE_BITSET);",
          "718:     void* p;",
          "721:       r = add_op(reg, IS_NCCLASS_NOT(cc) ? OP_CCLASS_MB_NOT : OP_CCLASS_MB);",
          "722:       if (r != 0) return r;",
          "724:       p = set_multi_byte_cclass(cc->mbuf, reg);",
          "725:       CHECK_NULL_RETURN_MEMERR(p);",
          "726:       COP(reg)->cclass_mb.mb = p;",
          "729:       r = add_op(reg, IS_NCCLASS_NOT(cc) ? OP_CCLASS_MIX_NOT : OP_CCLASS_MIX);",
          "732:       xmemcpy(COP(reg)->cclass_mix.bs, cc->bs, SIZE_BITSET);",
          "734:       p = set_multi_byte_cclass(cc->mbuf, reg);",
          "735:       CHECK_NULL_RETURN_MEMERR(p);",
          "736:       COP(reg)->cclass_mix.mb = p;",
          "740:   return 0;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "736:   else if (reg->repeat_range_alloc <= id) {",
          "737:     int n;",
          "738:     n = reg->repeat_range_alloc + REPEAT_RANGE_ALLOC;",
          "741:     CHECK_NULL_RETURN_MEMERR(p);",
          "742:     reg->repeat_range = p;",
          "743:     reg->repeat_range_alloc = n;",
          "",
          "[Removed Lines]",
          "739:     p = (OnigRepeatRange* )xrealloc(reg->repeat_range,",
          "740:                                     sizeof(OnigRepeatRange) * n);",
          "",
          "[Added Lines]",
          "759:     p = (OnigRepeatRange* )xrealloc(reg->repeat_range, sizeof(OnigRepeatRange) * n);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "756:                           regex_t* reg, ScanEnv* env)",
          "757: {",
          "758:   int r;",
          "767:   if (r != 0) return r;",
          "769:   r = entry_repeat_range(reg, num_repeat, qn->lower, qn->upper);",
          "770:   if (r != 0) return r;",
          "",
          "[Removed Lines]",
          "759:   int num_repeat = reg->num_repeat;",
          "761:   r = add_opcode(reg, qn->greedy ? OP_REPEAT : OP_REPEAT_NG);",
          "762:   if (r != 0) return r;",
          "764:   reg->num_repeat++;",
          "765:   if (r != 0) return r;",
          "766:   r = add_rel_addr(reg, target_len + SIZE_OP_REPEAT_INC);",
          "",
          "[Added Lines]",
          "778:   int num_repeat = reg->num_repeat++;",
          "780:   r = add_op(reg, qn->greedy ? OP_REPEAT : OP_REPEAT_NG);",
          "783:   COP(reg)->repeat.id   = num_repeat;",
          "784:   COP(reg)->repeat.addr = SIZE_INC_OP + target_len + SIZE_OP_REPEAT_INC;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "777:       NODE_IS_IN_MULTI_ENTRY(qn) ||",
          "778: #endif",
          "779:       NODE_IS_IN_REAL_REPEAT(qn)) {",
          "781:   }",
          "782:   else {",
          "784:   }",
          "785:   if (r != 0) return r;",
          "787:   return r;",
          "788: }",
          "",
          "[Removed Lines]",
          "780:     r = add_opcode(reg, qn->greedy ? OP_REPEAT_INC_SG : OP_REPEAT_INC_NG_SG);",
          "783:     r = add_opcode(reg, qn->greedy ? OP_REPEAT_INC : OP_REPEAT_INC_NG);",
          "",
          "[Added Lines]",
          "797:     r = add_op(reg, qn->greedy ? OP_REPEAT_INC_SG : OP_REPEAT_INC_NG_SG);",
          "800:     r = add_op(reg, qn->greedy ? OP_REPEAT_INC : OP_REPEAT_INC_NG);",
          "804:   COP(reg)->repeat_inc.id = num_repeat;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "797:     return 0;",
          "798: }",
          "801: #define CKN_ON   (ckn > 0)",
          "803: static int",
          "",
          "[Removed Lines]",
          "800: #define QUANTIFIER_EXPAND_LIMIT_SIZE   50",
          "",
          "[Added Lines]",
          "818: #define QUANTIFIER_EXPAND_LIMIT_SIZE   10",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "862:     len = SIZE_OP_PUSH + SIZE_OP_JUMP + tlen;",
          "863:   }",
          "864:   else {",
          "867:   }",
          "869:   return len;",
          "",
          "[Removed Lines]",
          "865:     len = SIZE_OP_REPEAT_INC",
          "866:         + mod_tlen + SIZE_OPCODE + SIZE_RELADDR + SIZE_MEMNUM;",
          "",
          "[Added Lines]",
          "883:     len = SIZE_OP_REPEAT_INC + mod_tlen + SIZE_OP_REPEAT;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "886:     r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);",
          "887:     if (r != 0) return r;",
          "888:     if (IS_NOT_NULL(qn->next_head_exact)) {",
          "893:       if (r != 0) return r;",
          "895:     }",
          "896:     else {",
          "901:     }",
          "902:   }",
          "",
          "[Removed Lines]",
          "889:       if (IS_MULTILINE(CTYPE_OPTION(NODE_QUANT_BODY(qn), reg)))",
          "890:         r = add_opcode(reg, OP_ANYCHAR_ML_STAR_PEEK_NEXT);",
          "891:       else",
          "892:         r = add_opcode(reg, OP_ANYCHAR_STAR_PEEK_NEXT);",
          "894:       return add_bytes(reg, STR_(qn->next_head_exact)->s, 1);",
          "897:       if (IS_MULTILINE(CTYPE_OPTION(NODE_QUANT_BODY(qn), reg)))",
          "898:         return add_opcode(reg, OP_ANYCHAR_ML_STAR);",
          "899:       else",
          "900:         return add_opcode(reg, OP_ANYCHAR_STAR);",
          "",
          "[Added Lines]",
          "906:       r = add_op(reg,",
          "907:                  IS_MULTILINE(CTYPE_OPTION(NODE_QUANT_BODY(qn), reg)) ?",
          "908:                  OP_ANYCHAR_ML_STAR_PEEK_NEXT : OP_ANYCHAR_STAR_PEEK_NEXT);",
          "911:       COP(reg)->anychar_star_peek_next.c = STR_(qn->next_head_exact)->s[0];",
          "912:       return 0;",
          "915:       r = add_op(reg,",
          "916:                  IS_MULTILINE(CTYPE_OPTION(NODE_QUANT_BODY(qn), reg)) ?",
          "917:                  OP_ANYCHAR_ML_STAR : OP_ANYCHAR_STAR);",
          "918:       return r;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "909:   if (infinite &&",
          "910:       (qn->lower <= 1 ||",
          "911:        int_multiply_cmp(tlen, qn->lower, QUANTIFIER_EXPAND_LIMIT_SIZE) <= 0)) {",
          "912:     if (qn->lower == 1 && tlen > QUANTIFIER_EXPAND_LIMIT_SIZE) {",
          "913:       if (qn->greedy) {",
          "914:         if (IS_NOT_NULL(qn->head_exact))",
          "916:         else if (IS_NOT_NULL(qn->next_head_exact))",
          "918:         else",
          "920:       }",
          "921:       else {",
          "923:       }",
          "925:     }",
          "926:     else {",
          "927:       r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);",
          "",
          "[Removed Lines]",
          "915:           r = add_opcode_rel_addr(reg, OP_JUMP, SIZE_OP_PUSH_OR_JUMP_EXACT1);",
          "917:           r = add_opcode_rel_addr(reg, OP_JUMP, SIZE_OP_PUSH_IF_PEEK_NEXT);",
          "919:           r = add_opcode_rel_addr(reg, OP_JUMP, SIZE_OP_PUSH);",
          "922:         r = add_opcode_rel_addr(reg, OP_JUMP, SIZE_OP_JUMP);",
          "924:       if (r != 0) return r;",
          "",
          "[Added Lines]",
          "930:     int addr;",
          "933:       r = add_op(reg, OP_JUMP);",
          "934:       if (r != 0) return r;",
          "937:           COP(reg)->jump.addr = SIZE_OP_PUSH_OR_JUMP_EXACT1 + SIZE_INC_OP;",
          "939:           COP(reg)->jump.addr = SIZE_OP_PUSH_IF_PEEK_NEXT + SIZE_INC_OP;",
          "941:           COP(reg)->jump.addr = SIZE_OP_PUSH + SIZE_INC_OP;",
          "944:         COP(reg)->jump.addr = SIZE_OP_JUMP + SIZE_INC_OP;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "931:     if (qn->greedy) {",
          "932:       if (IS_NOT_NULL(qn->head_exact)) {",
          "935:         if (r != 0) return r;",
          "937:         r = compile_tree_empty_check(NODE_QUANT_BODY(qn), reg, empty_info, env);",
          "938:         if (r != 0) return r;",
          "941:       }",
          "942:       else if (IS_NOT_NULL(qn->next_head_exact)) {",
          "945:         if (r != 0) return r;",
          "947:         r = compile_tree_empty_check(NODE_QUANT_BODY(qn), reg, empty_info, env);",
          "948:         if (r != 0) return r;",
          "951:       }",
          "952:       else {",
          "954:         if (r != 0) return r;",
          "955:         r = compile_tree_empty_check(NODE_QUANT_BODY(qn), reg, empty_info, env);",
          "956:         if (r != 0) return r;",
          "959:       }",
          "960:     }",
          "961:     else {",
          "963:       if (r != 0) return r;",
          "964:       r = compile_tree_empty_check(NODE_QUANT_BODY(qn), reg, empty_info, env);",
          "965:       if (r != 0) return r;",
          "967:     }",
          "968:   }",
          "971:     if (r != 0) return r;",
          "972:     r = compile_tree(NODE_QUANT_BODY(qn), reg, env);",
          "973:   }",
          "974:   else if (! infinite && qn->greedy &&",
          "",
          "[Removed Lines]",
          "933:         r = add_opcode_rel_addr(reg, OP_PUSH_OR_JUMP_EXACT1,",
          "934:                                 mod_tlen + SIZE_OP_JUMP);",
          "936:         add_bytes(reg, STR_(qn->head_exact)->s, 1);",
          "939:         r = add_opcode_rel_addr(reg, OP_JUMP,",
          "940:            -(mod_tlen + (int )SIZE_OP_JUMP + (int )SIZE_OP_PUSH_OR_JUMP_EXACT1));",
          "943:         r = add_opcode_rel_addr(reg, OP_PUSH_IF_PEEK_NEXT,",
          "944:                                 mod_tlen + SIZE_OP_JUMP);",
          "946:         add_bytes(reg, STR_(qn->next_head_exact)->s, 1);",
          "949:         r = add_opcode_rel_addr(reg, OP_JUMP,",
          "950:            -(mod_tlen + (int )SIZE_OP_JUMP + (int )SIZE_OP_PUSH_IF_PEEK_NEXT));",
          "953:         r = add_opcode_rel_addr(reg, OP_PUSH, mod_tlen + SIZE_OP_JUMP);",
          "957:         r = add_opcode_rel_addr(reg, OP_JUMP,",
          "958:                    -(mod_tlen + (int )SIZE_OP_JUMP + (int )SIZE_OP_PUSH));",
          "962:       r = add_opcode_rel_addr(reg, OP_JUMP, mod_tlen);",
          "966:       r = add_opcode_rel_addr(reg, OP_PUSH, -(mod_tlen + (int )SIZE_OP_PUSH));",
          "970:     r = add_opcode_rel_addr(reg, OP_JUMP, tlen);",
          "",
          "[Added Lines]",
          "954:         r = add_op(reg, OP_PUSH_OR_JUMP_EXACT1);",
          "956:         COP(reg)->push_or_jump_exact1.addr = SIZE_INC_OP + mod_tlen + SIZE_OP_JUMP;",
          "957:         COP(reg)->push_or_jump_exact1.c    = STR_(qn->head_exact)->s[0];",
          "962:         addr = -(mod_tlen + (int )SIZE_OP_PUSH_OR_JUMP_EXACT1);",
          "965:         r = add_op(reg, OP_PUSH_IF_PEEK_NEXT);",
          "967:         COP(reg)->push_if_peek_next.addr = SIZE_INC_OP + mod_tlen + SIZE_OP_JUMP;",
          "968:         COP(reg)->push_if_peek_next.c    = STR_(qn->next_head_exact)->s[0];",
          "973:         addr = -(mod_tlen + (int )SIZE_OP_PUSH_IF_PEEK_NEXT);",
          "976:         r = add_op(reg, OP_PUSH);",
          "978:         COP(reg)->push.addr = SIZE_INC_OP + mod_tlen + SIZE_OP_JUMP;",
          "983:         addr = -(mod_tlen + (int )SIZE_OP_PUSH);",
          "986:       r = add_op(reg, OP_JUMP);",
          "987:       if (r != 0) return r;",
          "988:       COP(reg)->jump.addr = addr;",
          "991:       r = add_op(reg, OP_JUMP);",
          "993:       COP(reg)->jump.addr = mod_tlen + SIZE_INC_OP;",
          "998:       r = add_op(reg, OP_PUSH);",
          "999:       if (r != 0) return r;",
          "1000:       COP(reg)->push.addr = -mod_tlen;",
          "1004:     r = add_op(reg, OP_JUMP);",
          "1006:     COP(reg)->jump.addr = tlen + SIZE_INC_OP;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "981:     if (r != 0) return r;",
          "983:     for (i = 0; i < n; i++) {",
          "985:       if (v < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;",
          "987:       if (r != 0) return r;",
          "988:       r = compile_tree(NODE_QUANT_BODY(qn), reg, env);",
          "989:       if (r != 0) return r;",
          "990:     }",
          "991:   }",
          "994:     if (r != 0) return r;",
          "996:     if (r != 0) return r;",
          "997:     r = compile_tree(NODE_QUANT_BODY(qn), reg, env);",
          "998:   }",
          "999:   else {",
          "",
          "[Removed Lines]",
          "984:       int v = onig_positive_int_multiply(n - i, tlen);",
          "986:       r = add_opcode_rel_addr(reg, OP_PUSH, v + (n - i - 1) * SIZE_OP_PUSH);",
          "993:     r = add_opcode_rel_addr(reg, OP_PUSH, SIZE_OP_JUMP);",
          "995:     r = add_opcode_rel_addr(reg, OP_JUMP, tlen);",
          "",
          "[Added Lines]",
          "1020:       int v = onig_positive_int_multiply(n - i, tlen + SIZE_OP_PUSH);",
          "1023:       r = add_op(reg, OP_PUSH);",
          "1025:       COP(reg)->push.addr = v;",
          "1032:     r = add_op(reg, OP_PUSH);",
          "1034:     COP(reg)->push.addr = SIZE_INC_OP + SIZE_OP_JUMP;",
          "1036:     r = add_op(reg, OP_JUMP);",
          "1038:     COP(reg)->jump.addr = tlen + SIZE_INC_OP;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1142:   int len;",
          "1144: #ifdef USE_CALL",
          "1147:     if (r != 0) return r;",
          "1149:     NODE_STATUS_ADD(node, ADDR_FIXED);",
          "1181:   }",
          "1182: #endif",
          "1184:   if (MEM_STATUS_AT0(reg->bt_mem_start, node->m.regnum))",
          "1186:   else",
          "1190:   if (r != 0) return r;",
          "1191:   r = compile_tree(NODE_BAG_BODY(node), reg, env);",
          "1192:   if (r != 0) return r;",
          "1194: #ifdef USE_CALL",
          "1195:   if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))",
          "1198:   else",
          "1201:   if (r != 0) return r;",
          "1203:   if (NODE_IS_CALLED(node)) {",
          "1204:     if (r != 0) return r;",
          "1206:   }",
          "1207: #else",
          "1208:   if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))",
          "1210:   else",
          "1212:   if (r != 0) return r;",
          "1214: #endif",
          "1216:   return r;",
          "",
          "[Removed Lines]",
          "1145:   if (node->m.regnum == 0 && NODE_IS_CALLED(node)) {",
          "1146:     r = add_opcode(reg, OP_CALL);",
          "1148:     node->m.called_addr = BB_GET_OFFSET_POS(reg) + SIZE_ABSADDR + SIZE_OP_JUMP;",
          "1150:     r = add_abs_addr(reg, (int )node->m.called_addr);",
          "1151:     if (r != 0) return r;",
          "1152:     len = compile_length_tree(NODE_BAG_BODY(node), reg);",
          "1153:     len += SIZE_OP_RETURN;",
          "1154:     r = add_opcode_rel_addr(reg, OP_JUMP, len);",
          "1155:     if (r != 0) return r;",
          "1157:     r = compile_tree(NODE_BAG_BODY(node), reg, env);",
          "1158:     if (r != 0) return r;",
          "1159:     r = add_opcode(reg, OP_RETURN);",
          "1160:     return r;",
          "1161:   }",
          "1163:   if (NODE_IS_CALLED(node)) {",
          "1164:     r = add_opcode(reg, OP_CALL);",
          "1165:     if (r != 0) return r;",
          "1166:     node->m.called_addr = BB_GET_OFFSET_POS(reg) + SIZE_ABSADDR + SIZE_OP_JUMP;",
          "1167:     NODE_STATUS_ADD(node, ADDR_FIXED);",
          "1168:     r = add_abs_addr(reg, (int )node->m.called_addr);",
          "1169:     if (r != 0) return r;",
          "1170:     len = compile_length_tree(NODE_BAG_BODY(node), reg);",
          "1171:     len += (SIZE_OP_MEMORY_START_PUSH + SIZE_OP_RETURN);",
          "1172:     if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))",
          "1173:       len += (NODE_IS_RECURSION(node)",
          "1174:               ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH);",
          "1175:     else",
          "1176:       len += (NODE_IS_RECURSION(node)",
          "1177:               ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END);",
          "1179:     r = add_opcode_rel_addr(reg, OP_JUMP, len);",
          "1180:     if (r != 0) return r;",
          "1185:     r = add_opcode(reg, OP_MEMORY_START_PUSH);",
          "1187:     r = add_opcode(reg, OP_MEMORY_START);",
          "1188:   if (r != 0) return r;",
          "1189:   r = add_mem_num(reg, node->m.regnum);",
          "1196:     r = add_opcode(reg, (NODE_IS_RECURSION(node)",
          "1197:                          ? OP_MEMORY_END_PUSH_REC : OP_MEMORY_END_PUSH));",
          "1199:     r = add_opcode(reg, (NODE_IS_RECURSION(node)",
          "1200:                          ? OP_MEMORY_END_REC : OP_MEMORY_END));",
          "1202:   r = add_mem_num(reg, node->m.regnum);",
          "1205:     r = add_opcode(reg, OP_RETURN);",
          "1209:     r = add_opcode(reg, OP_MEMORY_END_PUSH);",
          "1211:     r = add_opcode(reg, OP_MEMORY_END);",
          "1213:   r = add_mem_num(reg, node->m.regnum);",
          "",
          "[Added Lines]",
          "1188:   if (NODE_IS_CALLED(node)) {",
          "1189:     r = add_op(reg, OP_CALL);",
          "1192:     node->m.called_addr = COP_CURR_OFFSET(reg) + 1 + SIZE_OP_JUMP;",
          "1194:     COP(reg)->call.addr = (int )node->m.called_addr;",
          "1196:     if (node->m.regnum == 0) {",
          "1197:       len = compile_length_tree(NODE_BAG_BODY(node), reg);",
          "1198:       len += SIZE_OP_RETURN;",
          "1200:       r = add_op(reg, OP_JUMP);",
          "1201:       if (r != 0) return r;",
          "1202:       COP(reg)->jump.addr = len + SIZE_INC_OP;",
          "1204:       r = compile_tree(NODE_BAG_BODY(node), reg, env);",
          "1205:       if (r != 0) return r;",
          "1207:       r = add_op(reg, OP_RETURN);",
          "1208:       return r;",
          "1209:     }",
          "1210:     else {",
          "1211:       len = compile_length_tree(NODE_BAG_BODY(node), reg);",
          "1212:       len += (SIZE_OP_MEMORY_START_PUSH + SIZE_OP_RETURN);",
          "1213:       if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))",
          "1214:         len += (NODE_IS_RECURSION(node)",
          "1215:                 ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH);",
          "1216:       else",
          "1217:         len += (NODE_IS_RECURSION(node)",
          "1218:                 ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END);",
          "1220:       r = add_op(reg, OP_JUMP);",
          "1221:       if (r != 0) return r;",
          "1222:       COP(reg)->jump.addr = len + SIZE_INC_OP;",
          "1223:     }",
          "1228:     r = add_op(reg, OP_MEMORY_START_PUSH);",
          "1230:     r = add_op(reg, OP_MEMORY_START);",
          "1232:   COP(reg)->memory_start.num = node->m.regnum;",
          "1239:     r = add_op(reg, (NODE_IS_RECURSION(node)",
          "1240:                      ? OP_MEMORY_END_PUSH_REC : OP_MEMORY_END_PUSH));",
          "1242:     r = add_op(reg, (NODE_IS_RECURSION(node) ? OP_MEMORY_END_REC : OP_MEMORY_END));",
          "1244:   COP(reg)->memory_end.num = node->m.regnum;",
          "1248:     r = add_op(reg, OP_RETURN);",
          "1252:     r = add_op(reg, OP_MEMORY_END_PUSH);",
          "1254:     r = add_op(reg, OP_MEMORY_END);",
          "1256:   COP(reg)->memory_end.num = node->m.regnum;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1239:       len = compile_length_tree(NODE_QUANT_BODY(qn), reg);",
          "1240:       if (len < 0) return len;",
          "1243:       if (r != 0) return r;",
          "1244:       r = compile_tree(NODE_QUANT_BODY(qn), reg, env);",
          "1245:       if (r != 0) return r;",
          "1247:       if (r != 0) return r;",
          "1250:     }",
          "1251:     else {",
          "1253:       if (r != 0) return r;",
          "1254:       r = compile_tree(NODE_BAG_BODY(node), reg, env);",
          "1255:       if (r != 0) return r;",
          "1257:     }",
          "1258:     break;",
          "",
          "[Removed Lines]",
          "1242:       r = add_opcode_rel_addr(reg, OP_PUSH, len + SIZE_OP_POP_OUT + SIZE_OP_JUMP);",
          "1246:       r = add_opcode(reg, OP_POP_OUT);",
          "1248:       r = add_opcode_rel_addr(reg, OP_JUMP,",
          "1249:            -((int )SIZE_OP_PUSH + len + (int )SIZE_OP_POP_OUT + (int )SIZE_OP_JUMP));",
          "1252:       r = add_opcode(reg, OP_ATOMIC_START);",
          "1256:       r = add_opcode(reg, OP_ATOMIC_END);",
          "",
          "[Added Lines]",
          "1285:       r = add_op(reg, OP_PUSH);",
          "1287:       COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP;",
          "1291:       r = add_op(reg, OP_POP_OUT);",
          "1292:       if (r != 0) return r;",
          "1294:       r = add_op(reg, OP_JUMP);",
          "1296:       COP(reg)->jump.addr = -((int )SIZE_OP_PUSH + len + (int )SIZE_OP_POP_OUT);",
          "1299:       r = add_op(reg, OP_ATOMIC_START);",
          "1303:       r = add_op(reg, OP_ATOMIC_END);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1264:       Node* Then = node->te.Then;",
          "1265:       Node* Else = node->te.Else;",
          "1268:       if (r != 0) return r;",
          "1270:       cond_len = compile_length_tree(cond, reg);",
          "",
          "[Removed Lines]",
          "1267:       r = add_opcode(reg, OP_ATOMIC_START);",
          "",
          "[Added Lines]",
          "1314:       r = add_op(reg, OP_ATOMIC_START);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1279:       jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END;",
          "1280:       if (IS_NOT_NULL(Else)) jump_len += SIZE_OP_JUMP;",
          "1283:       if (r != 0) return r;",
          "1284:       r = compile_tree(cond, reg, env);",
          "1285:       if (r != 0) return r;",
          "1287:       if (r != 0) return r;",
          "1289:       if (IS_NOT_NULL(Then)) {",
          "",
          "[Removed Lines]",
          "1282:       r = add_opcode_rel_addr(reg, OP_PUSH, jump_len);",
          "1286:       r = add_opcode(reg, OP_ATOMIC_END);",
          "",
          "[Added Lines]",
          "1329:       r = add_op(reg, OP_PUSH);",
          "1331:       COP(reg)->push.addr = SIZE_INC_OP + jump_len;",
          "1335:       r = add_op(reg, OP_ATOMIC_END);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1294:       if (IS_NOT_NULL(Else)) {",
          "1295:         int else_len = compile_length_tree(Else, reg);",
          "1297:         if (r != 0) return r;",
          "1298:         r = compile_tree(Else, reg, env);",
          "1299:       }",
          "1300:     }",
          "",
          "[Removed Lines]",
          "1296:         r = add_opcode_rel_addr(reg, OP_JUMP, else_len);",
          "",
          "[Added Lines]",
          "1345:         r = add_op(reg, OP_JUMP);",
          "1347:         COP(reg)->jump.addr = else_len + SIZE_INC_OP;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1358:   enum OpCode op;",
          "1360:   switch (node->type) {",
          "1368:   case ANCR_WORD_BOUNDARY:",
          "1369:     op = OP_WORD_BOUNDARY;",
          "1370:   word:",
          "1372:     if (r != 0) return r;",
          "1374:     break;",
          "1376:   case ANCR_NO_WORD_BOUNDARY:",
          "",
          "[Removed Lines]",
          "1361:   case ANCR_BEGIN_BUF:      r = add_opcode(reg, OP_BEGIN_BUF);      break;",
          "1362:   case ANCR_END_BUF:        r = add_opcode(reg, OP_END_BUF);        break;",
          "1363:   case ANCR_BEGIN_LINE:     r = add_opcode(reg, OP_BEGIN_LINE);     break;",
          "1364:   case ANCR_END_LINE:       r = add_opcode(reg, OP_END_LINE);       break;",
          "1365:   case ANCR_SEMI_END_BUF:   r = add_opcode(reg, OP_SEMI_END_BUF);   break;",
          "1366:   case ANCR_BEGIN_POSITION: r = add_opcode(reg, OP_BEGIN_POSITION); break;",
          "1371:     r = add_opcode(reg, op);",
          "1373:     r = add_mode(reg, (ModeType )node->ascii_mode);",
          "",
          "[Added Lines]",
          "1412:   case ANCR_BEGIN_BUF:      r = add_op(reg, OP_BEGIN_BUF);      break;",
          "1413:   case ANCR_END_BUF:        r = add_op(reg, OP_END_BUF);        break;",
          "1414:   case ANCR_BEGIN_LINE:     r = add_op(reg, OP_BEGIN_LINE);     break;",
          "1415:   case ANCR_END_LINE:       r = add_op(reg, OP_END_LINE);       break;",
          "1416:   case ANCR_SEMI_END_BUF:   r = add_op(reg, OP_SEMI_END_BUF);   break;",
          "1417:   case ANCR_BEGIN_POSITION: r = add_op(reg, OP_BEGIN_POSITION); break;",
          "1422:     r = add_op(reg, op);",
          "1424:     COP(reg)->word_boundary.mode = (ModeType )node->ascii_mode;",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1386: #endif",
          "1388:   case ANCR_EXTENDED_GRAPHEME_CLUSTER_BOUNDARY:",
          "1390:     break;",
          "1392:   case ANCR_NO_EXTENDED_GRAPHEME_CLUSTER_BOUNDARY:",
          "1394:     break;",
          "1396:   case ANCR_PREC_READ:",
          "1398:     if (r != 0) return r;",
          "1399:     r = compile_tree(NODE_ANCHOR_BODY(node), reg, env);",
          "1400:     if (r != 0) return r;",
          "1402:     break;",
          "1404:   case ANCR_PREC_READ_NOT:",
          "1405:     len = compile_length_tree(NODE_ANCHOR_BODY(node), reg);",
          "1406:     if (len < 0) return len;",
          "1408:     if (r != 0) return r;",
          "1409:     r = compile_tree(NODE_ANCHOR_BODY(node), reg, env);",
          "1410:     if (r != 0) return r;",
          "1412:     break;",
          "1414:   case ANCR_LOOK_BEHIND:",
          "1415:     {",
          "1416:       int n;",
          "1418:       if (r != 0) return r;",
          "1419:       if (node->char_len < 0) {",
          "1420:         r = get_char_len_node(NODE_ANCHOR_BODY(node), reg, &n);",
          "",
          "[Removed Lines]",
          "1389:     r = add_opcode(reg, OP_EXTENDED_GRAPHEME_CLUSTER_BOUNDARY);",
          "1393:     r = add_opcode(reg, OP_NO_EXTENDED_GRAPHEME_CLUSTER_BOUNDARY);",
          "1397:     r = add_opcode(reg, OP_PREC_READ_START);",
          "1401:     r = add_opcode(reg, OP_PREC_READ_END);",
          "1407:     r = add_opcode_rel_addr(reg, OP_PREC_READ_NOT_START, len + SIZE_OP_PREC_READ_NOT_END);",
          "1411:     r = add_opcode(reg, OP_PREC_READ_NOT_END);",
          "1417:       r = add_opcode(reg, OP_LOOK_BEHIND);",
          "",
          "[Added Lines]",
          "1440:     r = add_op(reg, OP_EXTENDED_GRAPHEME_CLUSTER_BOUNDARY);",
          "1444:     r = add_op(reg, OP_NO_EXTENDED_GRAPHEME_CLUSTER_BOUNDARY);",
          "1448:     r = add_op(reg, OP_PREC_READ_START);",
          "1452:     r = add_op(reg, OP_PREC_READ_END);",
          "1459:     r = add_op(reg, OP_PREC_READ_NOT_START);",
          "1461:     COP(reg)->prec_read_not_start.addr = SIZE_INC_OP + len + SIZE_OP_PREC_READ_NOT_END;",
          "1464:     r = add_op(reg, OP_PREC_READ_NOT_END);",
          "1470:       r = add_op(reg, OP_LOOK_BEHIND);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1423:       else",
          "1424:         n = node->char_len;",
          "1428:       r = compile_tree(NODE_ANCHOR_BODY(node), reg, env);",
          "1429:     }",
          "1430:     break;",
          "",
          "[Removed Lines]",
          "1426:       r = add_length(reg, n);",
          "1427:       if (r != 0) return r;",
          "",
          "[Added Lines]",
          "1479:       COP(reg)->look_behind.len = n;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1434:       int n;",
          "1436:       len = compile_length_tree(NODE_ANCHOR_BODY(node), reg);",
          "1439:       if (r != 0) return r;",
          "1440:       if (node->char_len < 0) {",
          "1441:         r = get_char_len_node(NODE_ANCHOR_BODY(node), reg, &n);",
          "1442:         if (r != 0) return ONIGERR_INVALID_LOOK_BEHIND_PATTERN;",
          "1443:       }",
          "1444:       else",
          "1445:         n = node->char_len;",
          "1448:       r = compile_tree(NODE_ANCHOR_BODY(node), reg, env);",
          "1449:       if (r != 0) return r;",
          "1451:     }",
          "1452:     break;",
          "",
          "[Removed Lines]",
          "1437:       r = add_opcode_rel_addr(reg, OP_LOOK_BEHIND_NOT_START,",
          "1438:                               len + SIZE_OP_LOOK_BEHIND_NOT_END);",
          "1446:       r = add_length(reg, n);",
          "1447:       if (r != 0) return r;",
          "1450:       r = add_opcode(reg, OP_LOOK_BEHIND_NOT_END);",
          "",
          "[Added Lines]",
          "1489:       r = add_op(reg, OP_LOOK_BEHIND_NOT_START);",
          "1491:       COP(reg)->look_behind_not_start.addr = SIZE_INC_OP + len + SIZE_OP_LOOK_BEHIND_NOT_END;",
          "1500:       COP(reg)->look_behind_not_start.len = n;",
          "1504:       r = add_op(reg, OP_LOOK_BEHIND_NOT_END);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1467:   switch (node->type) {",
          "1468:   case GIMMICK_FAIL:",
          "1470:     break;",
          "1472:   case GIMMICK_KEEP:",
          "1476:     if (r != 0) return r;",
          "1478:     break;",
          "1480:   case GIMMICK_SAVE:",
          "1482:     if (r != 0) return r;",
          "1486:     break;",
          "1488:   case GIMMICK_UPDATE_VAR:",
          "1492:     if (r != 0) return r;",
          "1494:     break;",
          "1496: #ifdef USE_CALLOUT",
          "",
          "[Removed Lines]",
          "1469:     r = add_opcode(reg, OP_FAIL);",
          "1473:     r = add_opcode(reg, OP_PUSH_SAVE_VAL);",
          "1474:     if (r != 0) return r;",
          "1475:     r = add_save_type(reg, SAVE_KEEP);",
          "1477:     r = add_mem_num(reg, node->id);",
          "1481:     r = add_opcode(reg, OP_PUSH_SAVE_VAL);",
          "1483:     r = add_save_type(reg, node->detail_type);",
          "1484:     if (r != 0) return r;",
          "1485:     r = add_mem_num(reg, node->id);",
          "1489:     r = add_opcode(reg, OP_UPDATE_VAR);",
          "1490:     if (r != 0) return r;",
          "1491:     r = add_update_var_type(reg, node->detail_type);",
          "1493:     r = add_mem_num(reg, node->id);",
          "",
          "[Added Lines]",
          "1523:     r = add_op(reg, OP_FAIL);",
          "1527:     r = add_op(reg, OP_PUSH_SAVE_VAL);",
          "1529:     COP(reg)->push_save_val.type = SAVE_KEEP;",
          "1530:     COP(reg)->push_save_val.id   = node->id;",
          "1534:     r = add_op(reg, OP_PUSH_SAVE_VAL);",
          "1536:     COP(reg)->push_save_val.type = node->detail_type;",
          "1537:     COP(reg)->push_save_val.id   = node->id;",
          "1541:     r = add_op(reg, OP_UPDATE_VAR);",
          "1543:     COP(reg)->update_var.type = node->detail_type;",
          "1544:     COP(reg)->update_var.id   = node->id;",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1499:     case ONIG_CALLOUT_OF_CONTENTS:",
          "1500:     case ONIG_CALLOUT_OF_NAME:",
          "1501:       {",
          "1505:         if (node->detail_type == ONIG_CALLOUT_OF_NAME) {",
          "1507:           if (r != 0) return r;",
          "1508:         }",
          "1511:       }",
          "1512:       break;",
          "",
          "[Removed Lines]",
          "1502:         r = add_opcode(reg, (node->detail_type == ONIG_CALLOUT_OF_CONTENTS) ?",
          "1503:                                   OP_CALLOUT_CONTENTS : OP_CALLOUT_NAME);",
          "1504:         if (r != 0) return r;",
          "1506:           r = add_mem_num(reg, node->id);",
          "1509:         r = add_mem_num(reg, node->num);",
          "1510:         if (r != 0) return r;",
          "",
          "[Added Lines]",
          "1554:           r = add_op(reg, OP_CALLOUT_NAME);",
          "1556:           COP(reg)->callout_name.id  = node->id;",
          "1557:           COP(reg)->callout_name.num = node->num;",
          "1558:         }",
          "1559:         else {",
          "1560:           r = add_op(reg, OP_CALLOUT_CONTENTS);",
          "1561:           if (r != 0) return r;",
          "1562:           COP(reg)->callout_contents.num = node->num;",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1606:     break;",
          "1608:   case NODE_BACKREF:",
          "1638:     break;",
          "1640: #ifdef USE_CALL",
          "",
          "[Removed Lines]",
          "1609:     {",
          "1610:       BackRefNode* br = BACKREF_(node);",
          "1612:       if (NODE_IS_CHECKER(node)) {",
          "1613: #ifdef USE_BACKREF_WITH_LEVEL",
          "1614:         if (NODE_IS_NEST_LEVEL(node)) {",
          "1615:           r = SIZE_OPCODE + SIZE_LENGTH + SIZE_LENGTH + (SIZE_MEMNUM * br->back_num);",
          "1616:         }",
          "1617:         else",
          "1618: #endif",
          "1619:           r = SIZE_OPCODE + SIZE_LENGTH + (SIZE_MEMNUM * br->back_num);",
          "1620:       }",
          "1621:       else {",
          "1622: #ifdef USE_BACKREF_WITH_LEVEL",
          "1623:         if (NODE_IS_NEST_LEVEL(node)) {",
          "1624:           r = SIZE_OPCODE + SIZE_OPTION + SIZE_LENGTH +",
          "1625:             SIZE_LENGTH + (SIZE_MEMNUM * br->back_num);",
          "1626:         }",
          "1627:         else",
          "1628: #endif",
          "1629:         if (br->back_num == 1) {",
          "1630:           r = ((!IS_IGNORECASE(reg->options) && br->back_static[0] <= 2)",
          "1631:                ? SIZE_OPCODE : (SIZE_OPCODE + SIZE_MEMNUM));",
          "1632:         }",
          "1633:         else {",
          "1634:           r = SIZE_OPCODE + SIZE_LENGTH + (SIZE_MEMNUM * br->back_num);",
          "1635:         }",
          "1636:       }",
          "1637:     }",
          "",
          "[Added Lines]",
          "1662:     r = SIZE_OP_BACKREF;",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1689:           len += SIZE_OP_PUSH + SIZE_OP_JUMP;",
          "1690:         }",
          "1691:       } while (IS_NOT_NULL(x = NODE_CDR(x)));",
          "1694:       do {",
          "1695:         len = compile_length_tree(NODE_CAR(node), reg);",
          "1696:         if (IS_NOT_NULL(NODE_CDR(node))) {",
          "1697:           enum OpCode push = NODE_IS_SUPER(node) ? OP_PUSH_SUPER : OP_PUSH;",
          "1699:           if (r != 0) break;",
          "1700:         }",
          "1701:         r = compile_tree(NODE_CAR(node), reg, env);",
          "1702:         if (r != 0) break;",
          "1703:         if (IS_NOT_NULL(NODE_CDR(node))) {",
          "1706:           if (r != 0) break;",
          "1707:         }",
          "1708:       } while (IS_NOT_NULL(node = NODE_CDR(node)));",
          "1709:     }",
          "",
          "[Removed Lines]",
          "1698:           r = add_opcode_rel_addr(reg, push, len + SIZE_OP_JUMP);",
          "1704:           len = pos - (reg->used + SIZE_OP_JUMP);",
          "1705:           r = add_opcode_rel_addr(reg, OP_JUMP, len);",
          "",
          "[Added Lines]",
          "1723:           r = add_op(reg, push);",
          "1725:           COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_JUMP;",
          "1730:           len = pos - (COP_CURR_OFFSET(reg) + 1);",
          "1731:           r = add_op(reg, OP_JUMP);",
          "1733:           COP(reg)->jump.addr = len;",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1727:       switch (CTYPE_(node)->ctype) {",
          "1728:       case CTYPE_ANYCHAR:",
          "1733:         break;",
          "1735:       case ONIGENC_CTYPE_WORD:",
          "",
          "[Removed Lines]",
          "1729:         if (IS_MULTILINE(CTYPE_OPTION(node, reg)))",
          "1730:           r = add_opcode(reg, OP_ANYCHAR_ML);",
          "1731:         else",
          "1732:           r = add_opcode(reg, OP_ANYCHAR);",
          "",
          "[Added Lines]",
          "1756:         r = add_op(reg, IS_MULTILINE(CTYPE_OPTION(node, reg)) ?",
          "1757:                    OP_ANYCHAR_ML : OP_ANYCHAR);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1739:         else {",
          "1740:           op = CTYPE_(node)->not != 0 ? OP_NO_WORD_ASCII : OP_WORD_ASCII;",
          "1741:         }",
          "1743:         break;",
          "1745:       default:",
          "",
          "[Removed Lines]",
          "1742:         r = add_opcode(reg, op);",
          "",
          "[Added Lines]",
          "1767:         r = add_op(reg, op);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1756:       if (NODE_IS_CHECKER(node)) {",
          "1757: #ifdef USE_BACKREF_WITH_LEVEL",
          "1758:         if (NODE_IS_NEST_LEVEL(node)) {",
          "1762:           if (r != 0) return r;",
          "1763:         }",
          "1764:         else",
          "1765: #endif",
          "1766:           {",
          "1768:             if (r != 0) return r;",
          "1769:           }",
          "1771:         goto add_bacref_mems;",
          "1772:       }",
          "1773:       else {",
          "1774: #ifdef USE_BACKREF_WITH_LEVEL",
          "1775:         if (NODE_IS_NEST_LEVEL(node)) {",
          "1779:           if (r != 0) return r;",
          "1783:           goto add_bacref_mems;",
          "1784:         }",
          "1785:         else",
          "",
          "[Removed Lines]",
          "1759:           r = add_opcode(reg, OP_BACKREF_CHECK_WITH_LEVEL);",
          "1760:           if (r != 0) return r;",
          "1761:           r = add_length(reg, br->nest_level);",
          "1767:             r = add_opcode(reg, OP_BACKREF_CHECK);",
          "1776:           r = add_opcode(reg, OP_BACKREF_WITH_LEVEL);",
          "1777:           if (r != 0) return r;",
          "1778:           r = add_option(reg, (reg->options & ONIG_OPTION_IGNORECASE));",
          "1780:           r = add_length(reg, br->nest_level);",
          "1781:           if (r != 0) return r;",
          "",
          "[Added Lines]",
          "1784:           r = add_op(reg, OP_BACKREF_CHECK_WITH_LEVEL);",
          "1786:           COP(reg)->backref_general.nest_level = br->nest_level;",
          "1791:             r = add_op(reg, OP_BACKREF_CHECK);",
          "1799:           r = add_op(reg, OP_BACKREF_WITH_LEVEL);",
          "1801:           COP(reg)->backref_general.options =",
          "1802:             (reg->options & ONIG_OPTION_IGNORECASE);",
          "1803:           COP(reg)->backref_general.nest_level = br->nest_level;",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1787:         if (br->back_num == 1) {",
          "1788:           n = br->back_static[0];",
          "1789:           if (IS_IGNORECASE(reg->options)) {",
          "1791:             if (r != 0) return r;",
          "1793:           }",
          "1794:           else {",
          "1795:             switch (n) {",
          "1798:             default:",
          "1800:               if (r != 0) return r;",
          "1802:               break;",
          "1803:             }",
          "1804:           }",
          "1805:         }",
          "1806:         else {",
          "1808:           int* p;",
          "1816:           if (r != 0) return r;",
          "1818:         add_bacref_mems:",
          "1825:           }",
          "1826:         }",
          "1827:       }",
          "",
          "[Removed Lines]",
          "1790:             r = add_opcode(reg, OP_BACKREF_N_IC);",
          "1792:             r = add_mem_num(reg, n);",
          "1796:             case 1:  r = add_opcode(reg, OP_BACKREF1); break;",
          "1797:             case 2:  r = add_opcode(reg, OP_BACKREF2); break;",
          "1799:               r = add_opcode(reg, OP_BACKREF_N);",
          "1801:               r = add_mem_num(reg, n);",
          "1807:           int i;",
          "1810:           if (IS_IGNORECASE(reg->options)) {",
          "1811:             r = add_opcode(reg, OP_BACKREF_MULTI_IC);",
          "1812:           }",
          "1813:           else {",
          "1814:             r = add_opcode(reg, OP_BACKREF_MULTI);",
          "1815:           }",
          "1819:           r = add_length(reg, br->back_num);",
          "1820:           if (r != 0) return r;",
          "1821:           p = BACKREFS_P(br);",
          "1822:           for (i = br->back_num - 1; i >= 0; i--) {",
          "1823:             r = add_mem_num(reg, p[i]);",
          "1824:             if (r != 0) return r;",
          "",
          "[Added Lines]",
          "1811:             r = add_op(reg, OP_BACKREF_N_IC);",
          "1813:             COP(reg)->backref_n.n1 = n;",
          "1817:             case 1:  r = add_op(reg, OP_BACKREF1); break;",
          "1818:             case 2:  r = add_op(reg, OP_BACKREF2); break;",
          "1820:               r = add_op(reg, OP_BACKREF_N);",
          "1822:               COP(reg)->backref_n.n1 = n;",
          "1828:           int num;",
          "1831:           r = add_op(reg, IS_IGNORECASE(reg->options) ?",
          "1832:                      OP_BACKREF_MULTI_IC : OP_BACKREF_MULTI);",
          "1836:           num = br->back_num;",
          "1837:           COP(reg)->backref_general.num = num;",
          "1838:           if (num == 1) {",
          "1839:             COP(reg)->backref_general.n1 = br->back_static[0];",
          "1840:           }",
          "1841:           else {",
          "1842:             int i, j;",
          "1843:             MemNumType* ns;",
          "1845:             ns = xmalloc(sizeof(MemNumType) * num);",
          "1846:             CHECK_NULL_RETURN_MEMERR(ns);",
          "1847:             COP(reg)->backref_general.ns = ns;",
          "1848:             p = BACKREFS_P(br);",
          "1849:             for (i = num - 1, j = 0; i >= 0; i--, j++) {",
          "1850:               ns[j] = p[i];",
          "1851:             }",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "2113:   int i, offset;",
          "2114:   BagNode* en;",
          "2115:   AbsAddrType addr;",
          "2117:   for (i = 0; i < uslist->num; i++) {",
          "2118:     if (! NODE_IS_ADDR_FIXED(uslist->us[i].target))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2143:   AbsAddrType* paddr;",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "2122:     addr   = en->m.called_addr;",
          "2123:     offset = uslist->us[i].offset;",
          "2126:   }",
          "2127:   return 0;",
          "2128: }",
          "",
          "[Removed Lines]",
          "2125:     BB_WRITE(reg, offset, &addr, SIZE_ABSADDR);",
          "",
          "[Added Lines]",
          "2153:     paddr = (AbsAddrType* )((void* )reg->ops + offset);",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "2598:   case NODE_LIST:",
          "2599:   case NODE_ALT:",
          "2600:     do {",
          "2603:     } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));",
          "2604:     break;",
          "",
          "[Removed Lines]",
          "2601:       r = check_type_tree(NODE_CAR(node), type_mask, bag_mask,",
          "2602:                           anchor_mask);",
          "",
          "[Added Lines]",
          "2630:       r = check_type_tree(NODE_CAR(node), type_mask, bag_mask, anchor_mask);",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "6052:   return ONIG_NORMAL;",
          "6053: }",
          "6056: extern void",
          "6057: onig_free_body(regex_t* reg)",
          "6058: {",
          "6059:   if (IS_NOT_NULL(reg)) {",
          "6061:     if (IS_NOT_NULL(reg->exact))            xfree(reg->exact);",
          "6062:     if (IS_NOT_NULL(reg->repeat_range))     xfree(reg->repeat_range);",
          "6063:     if (IS_NOT_NULL(reg->extp)) {",
          "",
          "[Removed Lines]",
          "6060:     if (IS_NOT_NULL(reg->p))                xfree(reg->p);",
          "",
          "[Added Lines]",
          "6087:     ops_free(reg);",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "6099: onig_compile(regex_t* reg, const UChar* pattern, const UChar* pattern_end,",
          "6100:              OnigErrorInfo* einfo)",
          "6101: {",
          "6105:   Node*  root;",
          "6106:   ScanEnv  scan_env;",
          "6107: #ifdef USE_CALL",
          "",
          "[Removed Lines]",
          "6102: #define COMPILE_INIT_SIZE  20",
          "6104:   int r, init_size;",
          "",
          "[Added Lines]",
          "6129: #define OPS_INIT_SIZE  8",
          "6131:   int r;",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "6118:   print_enc_string(stderr, reg->enc, pattern, pattern_end);",
          "6119: #endif",
          "6125:     if (r != 0) goto end;",
          "6126:   }",
          "6127:   else",
          "6130:   reg->num_mem            = 0;",
          "6131:   reg->num_repeat         = 0;",
          "",
          "[Removed Lines]",
          "6121:   if (reg->alloc == 0) {",
          "6122:     init_size = (int )(pattern_end - pattern) * 2;",
          "6123:     if (init_size <= 0) init_size = COMPILE_INIT_SIZE;",
          "6124:     r = BB_INIT(reg, init_size);",
          "6128:     reg->used = 0;",
          "",
          "[Added Lines]",
          "6148:   if (reg->ops_alloc == 0) {",
          "6149:     r = ops_init(reg, OPS_INIT_SIZE);",
          "6153:     reg->ops_used = 0;",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "6203:   r = compile_tree(root, reg, &scan_env);",
          "6204:   if (r == 0) {",
          "6205:     if (scan_env.keep_num > 0) {",
          "6211:       if (r != 0) goto err;",
          "6212:     }",
          "6215: #ifdef USE_CALL",
          "6216:     if (scan_env.num_call > 0) {",
          "6217:       r = fix_unset_addr_list(&uslist, reg);",
          "",
          "[Removed Lines]",
          "6206:       r = add_opcode(reg, OP_UPDATE_VAR);",
          "6207:       if (r != 0) goto err;",
          "6208:       r = add_update_var_type(reg, UPDATE_VAR_KEEP_FROM_STACK_LAST);",
          "6209:       if (r != 0) goto err;",
          "6210:       r = add_mem_num(reg, 0 /* not used */);",
          "6214:     r = add_opcode(reg, OP_END);",
          "",
          "[Added Lines]",
          "6231:       r = add_op(reg, OP_UPDATE_VAR);",
          "6234:       COP(reg)->update_var.type = UPDATE_VAR_KEEP_FROM_STACK_LAST;",
          "6238:     r = add_op(reg, OP_END);",
          "6239:     if (r != 0) goto err;",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "6316:   (reg)->exact            = (UChar* )NULL;",
          "6317:   (reg)->extp             = (RegexExt* )NULL;",
          "6322:   (reg)->name_table       = (void* )NULL;",
          "6324:   (reg)->case_fold_flag   = case_fold_flag;",
          "",
          "[Removed Lines]",
          "6319:   (reg)->p                = (UChar* )NULL;",
          "6320:   (reg)->alloc            = 0;",
          "6321:   (reg)->used             = 0;",
          "",
          "[Added Lines]",
          "6345:   (reg)->ops              = (Operation* )NULL;",
          "6346:   (reg)->ops_curr         = (Operation* )NULL;",
          "6347:   (reg)->ops_used         = 0;",
          "6348:   (reg)->ops_alloc        = 0;",
          "",
          "---------------"
        ],
        "src/regexec.c||src/regexec.c": [
          "File: src/regexec.c -> src/regexec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "262:   return \"\";",
          "263: }",
          "265: static int",
          "266: op2arg_type(int opcode)",
          "267: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "265: #if 0",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "273:   }",
          "274:   return ARG_SPECIAL;",
          "275: }",
          "277: static void",
          "278: p_string(FILE* f, int len, UChar* s)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "277: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "291: }",
          "293: static void",
          "295: {",
          "296:   RelAddrType curr = (RelAddrType )(p - start);",
          "",
          "[Removed Lines]",
          "294: p_rel_addr(FILE* f, RelAddrType rel_addr, UChar* p, UChar* start)",
          "",
          "[Added Lines]",
          "296: p_rel_addr(FILE* f, RelAddrType rel_addr, Operation* p, Operation* start)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "311: }",
          "313: extern void",
          "316: {",
          "317:   int i, n;",
          "319:   RelAddrType addr;",
          "320:   LengthType  len;",
          "321:   MemNumType  mem;",
          "",
          "[Removed Lines]",
          "314: onig_print_compiled_byte_code(FILE* f, UChar* bp, UChar** nextp, UChar* start,",
          "315:                               OnigEncoding enc)",
          "318:   OpArgType   arg_type;",
          "",
          "[Added Lines]",
          "316: onig_print_compiled_byte_code(FILE* f, Operation* p, Operation* start, OnigEncoding enc)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "324:   ModeType mode;",
          "325:   UChar *q;",
          "366:     }",
          "486:       fputs(\" \", f);",
          "490:         if (i > 0) fputs(\", \", f);",
          "491:         fprintf(f, \"%d\", mem);",
          "492:       }",
          "567: #ifdef USE_CALLOUT",
          "589:     }",
          "590:   }",
          "592: }",
          "",
          "[Removed Lines]",
          "327:   fprintf(f, \"%s\", op2name(*bp));",
          "328:   arg_type = op2arg_type(*bp);",
          "329:   if (arg_type != ARG_SPECIAL) {",
          "330:     bp++;",
          "331:     switch (arg_type) {",
          "332:     case ARG_NON:",
          "333:       break;",
          "334:     case ARG_RELADDR:",
          "335:       GET_RELADDR_INC(addr, bp);",
          "336:       fputc(':', f);",
          "337:       p_rel_addr(f, addr, bp, start);",
          "338:       break;",
          "339:     case ARG_ABSADDR:",
          "340:       GET_ABSADDR_INC(addr, bp);",
          "341:       fprintf(f, \":{/%d}\", addr);",
          "342:       break;",
          "343:     case ARG_LENGTH:",
          "344:       GET_LENGTH_INC(len, bp);",
          "345:       fprintf(f, \":%d\", len);",
          "346:       break;",
          "347:     case ARG_MEMNUM:",
          "348:       mem = *((MemNumType* )bp);",
          "349:       bp += SIZE_MEMNUM;",
          "350:       fprintf(f, \":%d\", mem);",
          "351:       break;",
          "352:     case ARG_OPTION:",
          "353:       {",
          "354:         OnigOptionType option = *((OnigOptionType* )bp);",
          "355:         bp += SIZE_OPTION;",
          "356:         fprintf(f, \":%d\", option);",
          "357:       }",
          "358:       break;",
          "359:     case ARG_MODE:",
          "360:       mode = *((ModeType* )bp);",
          "361:       bp += SIZE_MODE;",
          "362:       fprintf(f, \":%d\", mode);",
          "363:       break;",
          "364:     default:",
          "365:       break;",
          "367:   }",
          "368:   else {",
          "369:     switch (*bp++) {",
          "370:     case OP_EXACT1:",
          "371:     case OP_ANYCHAR_STAR_PEEK_NEXT:",
          "372:     case OP_ANYCHAR_ML_STAR_PEEK_NEXT:",
          "373:       p_string(f, 1, bp++); break;",
          "374:     case OP_EXACT2:",
          "375:       p_string(f, 2, bp); bp += 2; break;",
          "376:     case OP_EXACT3:",
          "377:       p_string(f, 3, bp); bp += 3; break;",
          "378:     case OP_EXACT4:",
          "379:       p_string(f, 4, bp); bp += 4; break;",
          "380:     case OP_EXACT5:",
          "381:       p_string(f, 5, bp); bp += 5; break;",
          "382:     case OP_EXACTN:",
          "383:       GET_LENGTH_INC(len, bp);",
          "384:       p_len_string(f, len, 1, bp);",
          "385:       bp += len;",
          "386:       break;",
          "388:     case OP_EXACTMB2N1:",
          "389:       p_string(f, 2, bp); bp += 2; break;",
          "390:     case OP_EXACTMB2N2:",
          "391:       p_string(f, 4, bp); bp += 4; break;",
          "392:     case OP_EXACTMB2N3:",
          "393:       p_string(f, 6, bp); bp += 6; break;",
          "394:     case OP_EXACTMB2N:",
          "395:       GET_LENGTH_INC(len, bp);",
          "396:       p_len_string(f, len, 2, bp);",
          "397:       bp += len * 2;",
          "398:       break;",
          "399:     case OP_EXACTMB3N:",
          "400:       GET_LENGTH_INC(len, bp);",
          "401:       p_len_string(f, len, 3, bp);",
          "402:       bp += len * 3;",
          "403:       break;",
          "404:     case OP_EXACTMBN:",
          "405:       {",
          "406:         int mb_len;",
          "408:         GET_LENGTH_INC(mb_len, bp);",
          "409:         GET_LENGTH_INC(len, bp);",
          "410:         fprintf(f, \":%d:%d:\", mb_len, len);",
          "411:         n = len * mb_len;",
          "412:         while (n-- > 0) { fputc(*bp++, f); }",
          "413:       }",
          "414:       break;",
          "416:     case OP_EXACT1_IC:",
          "417:       len = enclen(enc, bp);",
          "418:       p_string(f, len, bp);",
          "419:       bp += len;",
          "420:       break;",
          "421:     case OP_EXACTN_IC:",
          "422:       GET_LENGTH_INC(len, bp);",
          "423:       p_len_string(f, len, 1, bp);",
          "424:       bp += len;",
          "425:       break;",
          "427:     case OP_CCLASS:",
          "428:       n = bitset_on_num((BitSetRef )bp);",
          "429:       bp += SIZE_BITSET;",
          "430:       fprintf(f, \":%d\", n);",
          "431:       break;",
          "433:     case OP_CCLASS_NOT:",
          "434:       n = bitset_on_num((BitSetRef )bp);",
          "435:       bp += SIZE_BITSET;",
          "436:       fprintf(f, \":%d\", n);",
          "437:       break;",
          "439:     case OP_CCLASS_MB:",
          "440:     case OP_CCLASS_MB_NOT:",
          "441:       GET_LENGTH_INC(len, bp);",
          "442:       q = bp;",
          "443: #ifndef PLATFORM_UNALIGNED_WORD_ACCESS",
          "444:       ALIGNMENT_RIGHT(q);",
          "445: #endif",
          "446:       GET_CODE_POINT(code, q);",
          "447:       bp += len;",
          "448:       fprintf(f, \":%d:%d\", (int )code, len);",
          "449:       break;",
          "451:     case OP_CCLASS_MIX:",
          "452:     case OP_CCLASS_MIX_NOT:",
          "453:       n = bitset_on_num((BitSetRef )bp);",
          "454:       bp += SIZE_BITSET;",
          "455:       GET_LENGTH_INC(len, bp);",
          "456:       q = bp;",
          "457: #ifndef PLATFORM_UNALIGNED_WORD_ACCESS",
          "458:       ALIGNMENT_RIGHT(q);",
          "459: #endif",
          "460:       GET_CODE_POINT(code, q);",
          "461:       bp += len;",
          "462:       fprintf(f, \":%d:%d:%d\", n, (int )code, len);",
          "463:       break;",
          "465: #ifdef USE_OP_CCLASS_NODE",
          "466:     case OP_CCLASS_NODE:",
          "467:       {",
          "468:         CClassNode *cc;",
          "470:         GET_POINTER_INC(cc, bp);",
          "471:         n = bitset_on_num(cc->bs);",
          "472:         fprintf(f, \":%p:%d\", cc, n);",
          "473:       }",
          "474:       break;",
          "475: #endif",
          "477:     case OP_BACKREF_N_IC:",
          "478:       mem = *((MemNumType* )bp);",
          "479:       bp += SIZE_MEMNUM;",
          "480:       fprintf(f, \":%d\", mem);",
          "481:       break;",
          "483:     case OP_BACKREF_MULTI_IC:",
          "484:     case OP_BACKREF_MULTI:",
          "485:     case OP_BACKREF_CHECK:",
          "487:       GET_LENGTH_INC(len, bp);",
          "488:       for (i = 0; i < len; i++) {",
          "489:         GET_MEMNUM_INC(mem, bp);",
          "493:       break;",
          "495:     case OP_BACKREF_WITH_LEVEL:",
          "496:       GET_OPTION_INC(option, bp);",
          "497:       fprintf(f, \":%d\", option);",
          "499:     case OP_BACKREF_CHECK_WITH_LEVEL:",
          "500:       {",
          "501:         LengthType level;",
          "503:         GET_LENGTH_INC(level, bp);",
          "504:         fprintf(f, \":%d\", level);",
          "506:         fputs(\" \", f);",
          "507:         GET_LENGTH_INC(len, bp);",
          "508:         for (i = 0; i < len; i++) {",
          "509:           GET_MEMNUM_INC(mem, bp);",
          "510:           if (i > 0) fputs(\", \", f);",
          "511:           fprintf(f, \"%d\", mem);",
          "512:         }",
          "513:       }",
          "514:       break;",
          "516:     case OP_REPEAT:",
          "517:     case OP_REPEAT_NG:",
          "518:       {",
          "519:         mem = *((MemNumType* )bp);",
          "520:         bp += SIZE_MEMNUM;",
          "521:         addr = *((RelAddrType* )bp);",
          "522:         bp += SIZE_RELADDR;",
          "523:         fprintf(f, \":%d:%d\", mem, addr);",
          "524:       }",
          "525:       break;",
          "527:     case OP_PUSH_OR_JUMP_EXACT1:",
          "528:     case OP_PUSH_IF_PEEK_NEXT:",
          "529:       addr = *((RelAddrType* )bp);",
          "530:       bp += SIZE_RELADDR;",
          "531:       fputc(':', f);",
          "532:       p_rel_addr(f, addr, bp, start);",
          "533:       p_string(f, 1, bp);",
          "534:       bp += 1;",
          "535:       break;",
          "537:     case OP_LOOK_BEHIND:",
          "538:       GET_LENGTH_INC(len, bp);",
          "539:       fprintf(f, \":%d\", len);",
          "540:       break;",
          "542:     case OP_LOOK_BEHIND_NOT_START:",
          "543:       GET_RELADDR_INC(addr, bp);",
          "544:       GET_LENGTH_INC(len, bp);",
          "545:       fprintf(f, \":%d:\", len);",
          "546:       p_rel_addr(f, addr, bp, start);",
          "547:       break;",
          "549:     case OP_PUSH_SAVE_VAL:",
          "550:       {",
          "551:         SaveType type;",
          "552:         GET_SAVE_TYPE_INC(type, bp);",
          "553:         GET_MEMNUM_INC(mem, bp);",
          "554:         fprintf(f, \":%d:%d\", type, mem);",
          "555:       }",
          "556:       break;",
          "558:     case OP_UPDATE_VAR:",
          "559:       {",
          "560:         UpdateVarType type;",
          "561:         GET_UPDATE_VAR_TYPE_INC(type, bp);",
          "562:         GET_MEMNUM_INC(mem, bp);",
          "563:         fprintf(f, \":%d:%d\", type, mem);",
          "564:       }",
          "565:       break;",
          "568:     case OP_CALLOUT_CONTENTS:",
          "569:       {",
          "571:         fprintf(f, \":%d\", mem);",
          "572:       }",
          "573:       break;",
          "575:     case OP_CALLOUT_NAME:",
          "576:       {",
          "577:         int id;",
          "582:         fprintf(f, \":%d:%d\", id, mem);",
          "583:       }",
          "584:       break;",
          "585: #endif",
          "587:     default:",
          "588:       fprintf(stderr, \"onig_print_compiled_byte_code: undefined code %d\\n\", *--bp);",
          "591:   if (nextp) *nextp = bp;",
          "",
          "[Added Lines]",
          "327:   fprintf(f, \"%s\", op2name(p->opcode));",
          "328:   switch (p->opcode) {",
          "329:   case OP_EXACT1:",
          "330:     p_string(f, 1, p->exact.s); break;",
          "331:   case OP_EXACT2:",
          "332:     p_string(f, 2, p->exact.s); break;",
          "333:   case OP_EXACT3:",
          "334:     p_string(f, 3, p->exact.s); break;",
          "335:   case OP_EXACT4:",
          "336:     p_string(f, 4, p->exact.s); break;",
          "337:   case OP_EXACT5:",
          "338:     p_string(f, 5, p->exact.s); break;",
          "339:   case OP_EXACTN:",
          "340:     len = p->exact_n.n;",
          "341:     p_string(f, len, p->exact_n.s); break;",
          "342:   case OP_EXACTMB2N1:",
          "343:     p_string(f, 2, p->exact.s); break;",
          "344:   case OP_EXACTMB2N2:",
          "345:     p_string(f, 4, p->exact.s); break;",
          "346:   case OP_EXACTMB2N3:",
          "347:     p_string(f, 3, p->exact.s); break;",
          "348:   case OP_EXACTMB2N:",
          "349:     len = p->exact_n.n;",
          "350:     p_len_string(f, len, 2, p->exact_n.s); break;",
          "351:   case OP_EXACTMB3N:",
          "352:     len = p->exact_n.n;",
          "353:     p_len_string(f, len, 3, p->exact_n.s); break;",
          "354:   case OP_EXACTMBN:",
          "355:     {",
          "356:       int mb_len;",
          "358:       mb_len = p->exact_len_n.len;",
          "359:       len    = p->exact_len_n.n;",
          "360:       q      = p->exact_len_n.s;",
          "361:       fprintf(f, \":%d:%d:\", mb_len, len);",
          "362:       n = len * mb_len;",
          "363:       while (n-- > 0) { fputc(*q++, f); }",
          "365:     break;",
          "366:   case OP_EXACT1_IC:",
          "367:     len = enclen(enc, p->exact.s);",
          "368:     p_string(f, len, p->exact.s);",
          "369:     break;",
          "370:   case OP_EXACTN_IC:",
          "371:     len = p->exact_n.n;",
          "372:     p_len_string(f, len, 1, p->exact_n.s);",
          "373:     break;",
          "375:   case OP_CCLASS:",
          "376:   case OP_CCLASS_NOT:",
          "377:     n = bitset_on_num(p->cclass.bs);",
          "378:     fprintf(f, \":%d\", n);",
          "379:     break;",
          "380:   case OP_CCLASS_MB:",
          "381:   case OP_CCLASS_MB_NOT:",
          "382:     {",
          "383:       OnigCodePoint ncode;",
          "384:       OnigCodePoint* codes;",
          "386:       codes = (OnigCodePoint* )p->cclass_mb.mb;",
          "387:       GET_CODE_POINT(ncode, codes);",
          "388:       codes++;",
          "389:       GET_CODE_POINT(code, codes);",
          "390:       fprintf(f, \":%u:%u\", code, ncode);",
          "391:     }",
          "392:     break;",
          "393:   case OP_CCLASS_MIX:",
          "394:   case OP_CCLASS_MIX_NOT:",
          "395:     {",
          "396:       OnigCodePoint ncode;",
          "397:       OnigCodePoint* codes;",
          "399:       codes = (OnigCodePoint* )p->cclass_mix.mb;",
          "400:       n = bitset_on_num(p->cclass_mix.bs);",
          "402:       GET_CODE_POINT(ncode, codes);",
          "403:       codes++;",
          "404:       GET_CODE_POINT(code, codes);",
          "405:       fprintf(f, \":%d:%u:%u\", n, code, ncode);",
          "406:     }",
          "407:     break;",
          "409:   case OP_ANYCHAR_STAR_PEEK_NEXT:",
          "410:   case OP_ANYCHAR_ML_STAR_PEEK_NEXT:",
          "411:     p_string(f, 1, &(p->anychar_star_peek_next.c));",
          "412:     break;",
          "414:   case OP_WORD_BOUNDARY:",
          "415:   case OP_NO_WORD_BOUNDARY:",
          "416:   case OP_WORD_BEGIN:",
          "417:   case OP_WORD_END:",
          "418:     mode = p->word_boundary.mode;",
          "419:     fprintf(f, \":%d\", mode);",
          "420:     break;",
          "422:   case OP_BACKREF_N:",
          "423:   case OP_BACKREF_N_IC:",
          "424:     mem = p->backref_n.n1;",
          "425:     fprintf(f, \":%d\", mem);",
          "426:     break;",
          "427:   case OP_BACKREF_MULTI_IC:",
          "428:   case OP_BACKREF_MULTI:",
          "429:   case OP_BACKREF_CHECK:",
          "430:     fputs(\" \", f);",
          "431:     n = p->backref_general.num;",
          "432:     for (i = 0; i < n; i++) {",
          "433:       mem = (n == 1) ? p->backref_general.n1 : p->backref_general.ns[i];",
          "434:       if (i > 0) fputs(\", \", f);",
          "435:       fprintf(f, \"%d\", mem);",
          "436:     }",
          "437:     break;",
          "438:   case OP_BACKREF_WITH_LEVEL:",
          "439:     option = p->backref_general.options;",
          "440:     fprintf(f, \":%d\", option);",
          "442:   case OP_BACKREF_CHECK_WITH_LEVEL:",
          "443:     {",
          "444:       LengthType level;",
          "446:       level = p->backref_general.nest_level;",
          "447:       fprintf(f, \":%d\", level);",
          "449:       n = p->backref_general.num;",
          "450:       for (i = 0; i < n; i++) {",
          "451:         mem = (n == 1) ? p->backref_general.n1 : p->backref_general.ns[i];",
          "455:     }",
          "456:     break;",
          "458:   case OP_MEMORY_START:",
          "459:   case OP_MEMORY_START_PUSH:",
          "460:     mem = p->memory_start.num;",
          "461:     fprintf(f, \":%d\", mem);",
          "462:     break;",
          "463:   case OP_MEMORY_END_PUSH:",
          "464:   case OP_MEMORY_END_PUSH_REC:",
          "465:   case OP_MEMORY_END:",
          "466:   case OP_MEMORY_END_REC:",
          "467:     mem = p->memory_end.num;",
          "468:     fprintf(f, \":%d\", mem);",
          "469:     break;",
          "471:   case OP_JUMP:",
          "472:     addr = p->jump.addr;",
          "473:     fputc(':', f);",
          "474:     p_rel_addr(f, addr, p, start);",
          "475:     break;",
          "477:   case OP_PUSH:",
          "478:   case OP_PUSH_SUPER:",
          "479:     addr = p->push.addr;",
          "480:     fputc(':', f);",
          "481:     p_rel_addr(f, addr, p, start);",
          "482:     break;",
          "484:   case OP_PUSH_OR_JUMP_EXACT1:",
          "485:     addr = p->push_or_jump_exact1.addr;",
          "486:     fputc(':', f);",
          "487:     p_rel_addr(f, addr, p, start);",
          "488:     p_string(f, 1, &(p->push_or_jump_exact1.c));",
          "489:     break;",
          "491:   case OP_PUSH_IF_PEEK_NEXT:",
          "492:     addr = p->push_if_peek_next.addr;",
          "493:     fputc(':', f);",
          "494:     p_rel_addr(f, addr, p, start);",
          "495:     p_string(f, 1, &(p->push_if_peek_next.c));",
          "496:     break;",
          "498:   case OP_REPEAT:",
          "499:   case OP_REPEAT_NG:",
          "500:     mem = p->repeat.id;",
          "501:     addr = p->repeat.addr;",
          "502:     fprintf(f, \":%d:%d\", mem, addr);",
          "503:     break;",
          "505:   case OP_REPEAT_INC:",
          "506:   case OP_REPEAT_INC_NG:",
          "507:   case OP_REPEAT_INC_SG:",
          "508:   case OP_REPEAT_INC_NG_SG:",
          "509:     mem = p->repeat.id;",
          "510:     fprintf(f, \":%d\", mem);",
          "511:     break;",
          "513:   case OP_EMPTY_CHECK_START:",
          "514:     mem = p->empty_check_start.mem;",
          "515:     fprintf(f, \":%d\", mem);",
          "516:     break;",
          "517:   case OP_EMPTY_CHECK_END:",
          "518:   case OP_EMPTY_CHECK_END_MEMST:",
          "519:   case OP_EMPTY_CHECK_END_MEMST_PUSH:",
          "520:     mem = p->empty_check_end.mem;",
          "521:     fprintf(f, \":%d\", mem);",
          "522:     break;",
          "524:   case OP_PREC_READ_NOT_START:",
          "525:     addr = p->prec_read_not_start.addr;",
          "526:     fputc(':', f);",
          "527:     p_rel_addr(f, addr, p, start);",
          "528:     break;",
          "530:   case OP_LOOK_BEHIND:",
          "531:     len = p->look_behind.len;",
          "532:     fprintf(f, \":%d\", len);",
          "533:     break;",
          "535:   case OP_LOOK_BEHIND_NOT_START:",
          "536:     addr = p->look_behind_not_start.addr;",
          "537:     len  = p->look_behind_not_start.len;",
          "538:     fprintf(f, \":%d:\", len);",
          "539:     p_rel_addr(f, addr, p, start);",
          "540:     break;",
          "542:   case OP_CALL:",
          "543:     addr = p->call.addr;",
          "544:     fprintf(f, \":{/%d}\", addr);",
          "545:     break;",
          "547:   case OP_PUSH_SAVE_VAL:",
          "548:     {",
          "549:       SaveType type;",
          "551:       type = p->push_save_val.type;",
          "552:       mem  = p->push_save_val.id;",
          "553:       fprintf(f, \":%d:%d\", type, mem);",
          "554:     }",
          "555:     break;",
          "557:   case OP_UPDATE_VAR:",
          "558:     {",
          "559:       UpdateVarType type;",
          "561:       type = p->update_var.type;",
          "562:       mem  = p->update_var.id;",
          "563:       fprintf(f, \":%d:%d\", type, mem);",
          "564:     }",
          "565:     break;",
          "568:   case OP_CALLOUT_CONTENTS:",
          "569:     mem = p->callout_contents.num;",
          "570:     fprintf(f, \":%d\", mem);",
          "571:     break;",
          "573:   case OP_CALLOUT_NAME:",
          "574:     {",
          "575:       int id;",
          "577:       id  = p->callout_name.id;",
          "578:       mem = p->callout_name.num;",
          "579:       fprintf(f, \":%d:%d\", id, mem);",
          "581:     break;",
          "582: #endif",
          "584:   case OP_FINISH:",
          "585:   case OP_END:",
          "586:   case OP_ANYCHAR:",
          "587:   case OP_ANYCHAR_ML:",
          "588:   case OP_ANYCHAR_STAR:",
          "589:   case OP_ANYCHAR_ML_STAR:",
          "590:   case OP_WORD:",
          "591:   case OP_WORD_ASCII:",
          "592:   case OP_NO_WORD:",
          "593:   case OP_NO_WORD_ASCII:",
          "594:   case OP_EXTENDED_GRAPHEME_CLUSTER_BOUNDARY:",
          "595:   case OP_NO_EXTENDED_GRAPHEME_CLUSTER_BOUNDARY:",
          "596:   case OP_BEGIN_BUF:",
          "597:   case OP_END_BUF:",
          "598:   case OP_BEGIN_LINE:",
          "599:   case OP_END_LINE:",
          "600:   case OP_SEMI_END_BUF:",
          "601:   case OP_BEGIN_POSITION:",
          "602:   case OP_BACKREF1:",
          "603:   case OP_BACKREF2:",
          "604:   case OP_FAIL:",
          "605:   case OP_POP_OUT:",
          "606:   case OP_PREC_READ_START:",
          "607:   case OP_PREC_READ_END:",
          "608:   case OP_PREC_READ_NOT_END:",
          "609:   case OP_ATOMIC_START:",
          "610:   case OP_ATOMIC_END:",
          "611:   case OP_LOOK_BEHIND_NOT_END:",
          "612:   case OP_RETURN:",
          "613:     break;",
          "615:   default:",
          "616:     fprintf(stderr, \"onig_print_compiled_byte_code: undefined code %d\\n\", p->opcode);",
          "617:     break;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "596: extern void",
          "597: onig_print_compiled_byte_code_list(FILE* f, regex_t* reg)",
          "598: {",
          "603:   fprintf(f, \"bt_mem_start: 0x%x, bt_mem_end: 0x%x\\n\",",
          "604:           reg->bt_mem_start, reg->bt_mem_end);",
          "607:   bp = start;",
          "608:   while (bp < end) {",
          "609:     int pos = bp - start;",
          "611:     fprintf(f, \"%4d: \", pos);",
          "613:     fprintf(f, \"\\n\");",
          "614:   }",
          "615:   fprintf(f, \"\\n\");",
          "616: }",
          "",
          "[Removed Lines]",
          "599:   UChar* bp;",
          "600:   UChar* start = reg->p;",
          "601:   UChar* end   = reg->p + reg->used;",
          "605:   fprintf(f, \"code-length: %d\\n\", reg->used);",
          "612:     onig_print_compiled_byte_code(f, bp, &bp, start, reg->enc);",
          "",
          "[Added Lines]",
          "626:   Operation* bp;",
          "627:   Operation* start = reg->ops;",
          "628:   Operation* end   = reg->ops + reg->ops_used;",
          "632:   fprintf(f, \"code-length: %d\\n\", reg->ops_used);",
          "639:     onig_print_compiled_byte_code(f, bp, start, reg->enc);",
          "641:     bp++;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1516: #define STACK_PUSH_ALT(pat,s,sprev)       STACK_PUSH(STK_ALT,pat,s,sprev)",
          "1517: #define STACK_PUSH_SUPER_ALT(pat,s,sprev) STACK_PUSH(STK_SUPER_ALT,pat,s,sprev)",
          "1518: #define STACK_PUSH_POS(s,sprev) \\",
          "1520: #define STACK_PUSH_ALT_PREC_READ_NOT(pat,s,sprev) \\",
          "1521:   STACK_PUSH(STK_ALT_PREC_READ_NOT,pat,s,sprev)",
          "1522: #define STACK_PUSH_TO_VOID_START        STACK_PUSH_TYPE(STK_TO_VOID_START)",
          "",
          "[Removed Lines]",
          "1519:   STACK_PUSH(STK_TO_VOID_START,NULL_UCHARP,s,sprev)",
          "",
          "[Added Lines]",
          "1547:   STACK_PUSH(STK_TO_VOID_START,(Operation* )0,s,sprev)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2141: #endif",
          "2143: #ifdef USE_BACKREF_WITH_LEVEL",
          "2145: {",
          "2146:   int i;",
          "2149:   for (i = 0; i < num; i++) {",
          "2152:   }",
          "2153:   return 0;",
          "2154: }",
          "",
          "[Removed Lines]",
          "2144: static int mem_is_in_memp(int mem, int num, UChar* memp)",
          "2147:   MemNumType m;",
          "2150:     GET_MEMNUM_INC(m, memp);",
          "2151:     if (mem == (int )m) return 1;",
          "",
          "[Added Lines]",
          "2172: static int mem_is_in_memp(int mem, int num, MemNumType* memp)",
          "2177:     if (mem == (int )memp[i]) return 1;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2157: backref_match_at_nested_level(regex_t* reg,",
          "2158:                               StackType* top, StackType* stk_base,",
          "2159:                               int ignore_case, int case_fold_flag,",
          "2161:                               UChar** s, const UChar* send)",
          "2162: {",
          "2163:   UChar *ss, *p, *pstart, *pend = NULL_UCHARP;",
          "",
          "[Removed Lines]",
          "2160:                               int nest, int mem_num, UChar* memp,",
          "",
          "[Added Lines]",
          "2186:                               int nest, int mem_num, MemNumType* memp,",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2214: static int",
          "2215: backref_check_at_nested_level(regex_t* reg,",
          "2216:                               StackType* top, StackType* stk_base,",
          "2218: {",
          "2219:   int level;",
          "2220:   StackType* k;",
          "",
          "[Removed Lines]",
          "2217:                               int nest, int mem_num, UChar* memp)",
          "",
          "[Added Lines]",
          "2243:                               int nest, int mem_num, MemNumType* memp)",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2347: #ifdef USE_THREADED_CODE",
          "2350: #define BYTECODE_INTERPRETER_END",
          "2351: #define CASE_OP(x)   L_##x: SOP_IN(OP_##x); sbegin = s; MATCH_DEBUG_OUT(1)",
          "2353: #define NEXT_OP      sprev = sbegin; JUMP_OP",
          "2357: #else",
          "",
          "[Removed Lines]",
          "2349: #define BYTECODE_INTERPRETER_START      JUMP_OP;",
          "2354: #define JUMP_OP      goto *opcode_to_label[*p++]",
          "",
          "[Added Lines]",
          "2375: #define BYTECODE_INTERPRETER_START      GOTO_OP;",
          "2380: #define JUMP_OP      GOTO_OP",
          "2381: #define GOTO_OP      goto *opcode_to_label[p->opcode]",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2365: #define CASE_OP(x)   case OP_##x: SOP_IN(OP_##x);",
          "2366: #define DEFAULT_OP   default:",
          "2367: #define NEXT_OP      break",
          "2369: #define BREAK_OP     break",
          "2373: #define NEXT_OUT     SOP_OUT; NEXT_OP",
          "2374: #define JUMP_OUT     SOP_OUT; JUMP_OP",
          "2375: #define BREAK_OUT    SOP_OUT; BREAK_OP",
          "",
          "[Removed Lines]",
          "2368: #define JUMP_OP      continue; break",
          "",
          "[Added Lines]",
          "2395: #define JUMP_OP      GOTO_OP",
          "2396: #define GOTO_OP      continue; break",
          "2401: #define INC_OP       p++",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2404:         fprintf(stderr, \"----: \");\\",
          "2405:       else\\",
          "2406:         fprintf(stderr, \"%4d: \", (int )(xp - reg->p));\\",
          "2408:       fprintf(stderr, \"\\n\");\\",
          "2409:   } while(0);",
          "2410: #else",
          "",
          "[Removed Lines]",
          "2407:       onig_print_compiled_byte_code(stderr, xp, NULL, reg->p, encode);\\",
          "",
          "[Added Lines]",
          "2436:       onig_print_compiled_byte_code(stderr, xp, reg->p, encode);\\",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2419:          const UChar* in_right_range, const UChar* sstart, UChar* sprev,",
          "2420:          MatchArg* msa)",
          "2421: {",
          "2424: #ifdef USE_THREADED_CODE",
          "2425:   static const void *opcode_to_label[] = {",
          "",
          "[Removed Lines]",
          "2422:   static UChar FinishCode[] = { OP_FINISH };",
          "",
          "[Added Lines]",
          "2451:   static Operation FinishCode[] = { { OP_FINISH } };",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2526:   LengthType tlen, tlen2;",
          "2527:   MemNumType mem;",
          "2528:   RelAddrType addr;",
          "2530:   UChar *right_range;",
          "2531:   int is_alloca;",
          "2532:   char *alloc_base;",
          "",
          "[Removed Lines]",
          "2529:   UChar *s, *q, *sbegin;",
          "",
          "[Added Lines]",
          "2558:   UChar *s, *q, *ps, *sbegin;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2545:   int of;",
          "2546: #endif",
          "2549:   OnigOptionType option = reg->options;",
          "2550:   OnigEncoding encode = reg->enc;",
          "2551:   OnigCaseFoldType case_fold_flag = reg->case_fold_flag;",
          "",
          "[Removed Lines]",
          "2548:   UChar *p = reg->p;",
          "",
          "[Added Lines]",
          "2577:   Operation* p = reg->ops;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2703:     CASE_OP(EXACT1)",
          "2704:       DATA_ENSURE(1);",
          "2707:       NEXT_OUT;",
          "2709:     CASE_OP(EXACT1_IC)",
          "",
          "[Removed Lines]",
          "2705:       if (*p != *s) goto fail;",
          "2706:       p++; s++;",
          "",
          "[Added Lines]",
          "2734:       ps = p->exact.s;",
          "2735:       if (*ps != *s) goto fail;",
          "2736:       s++;",
          "2737:       INC_OP;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2718:                                     &s, end, lowbuf);",
          "2719:         DATA_ENSURE(0);",
          "2720:         q = lowbuf;",
          "2721:         while (len-- > 0) {",
          "2726:         }",
          "2727:       }",
          "2728:       NEXT_OUT;",
          "2730:     CASE_OP(EXACT2)",
          "2731:       DATA_ENSURE(2);",
          "2735:       sprev = s;",
          "2737:       JUMP_OUT;",
          "2739:     CASE_OP(EXACT3)",
          "2740:       DATA_ENSURE(3);",
          "2746:       sprev = s;",
          "2748:       JUMP_OUT;",
          "2750:     CASE_OP(EXACT4)",
          "2751:       DATA_ENSURE(4);",
          "2759:       sprev = s;",
          "2761:       JUMP_OUT;",
          "2763:     CASE_OP(EXACT5)",
          "2764:       DATA_ENSURE(5);",
          "2774:       sprev = s;",
          "2776:       JUMP_OUT;",
          "2778:     CASE_OP(EXACTN)",
          "2780:       DATA_ENSURE(tlen);",
          "2781:       while (tlen-- > 0) {",
          "2783:       }",
          "2784:       sprev = s - 1;",
          "2785:       JUMP_OUT;",
          "2787:     CASE_OP(EXACTN_IC)",
          "",
          "[Removed Lines]",
          "2722:           if (*p != *q) {",
          "2723:             goto fail;",
          "2724:           }",
          "2725:           p++; q++;",
          "2732:       if (*p != *s) goto fail;",
          "2733:       p++; s++;",
          "2734:       if (*p != *s) goto fail;",
          "2736:       p++; s++;",
          "2741:       if (*p != *s) goto fail;",
          "2742:       p++; s++;",
          "2743:       if (*p != *s) goto fail;",
          "2744:       p++; s++;",
          "2745:       if (*p != *s) goto fail;",
          "2747:       p++; s++;",
          "2752:       if (*p != *s) goto fail;",
          "2753:       p++; s++;",
          "2754:       if (*p != *s) goto fail;",
          "2755:       p++; s++;",
          "2756:       if (*p != *s) goto fail;",
          "2757:       p++; s++;",
          "2758:       if (*p != *s) goto fail;",
          "2760:       p++; s++;",
          "2765:       if (*p != *s) goto fail;",
          "2766:       p++; s++;",
          "2767:       if (*p != *s) goto fail;",
          "2768:       p++; s++;",
          "2769:       if (*p != *s) goto fail;",
          "2770:       p++; s++;",
          "2771:       if (*p != *s) goto fail;",
          "2772:       p++; s++;",
          "2773:       if (*p != *s) goto fail;",
          "2775:       p++; s++;",
          "2779:       GET_LENGTH_INC(tlen, p);",
          "2782:         if (*p++ != *s++) goto fail;",
          "",
          "[Added Lines]",
          "2752:         ps = p->exact.s;",
          "2754:           if (*ps != *q) goto fail;",
          "2755:           ps++; q++;",
          "2758:       INC_OP;",
          "2763:       ps = p->exact.s;",
          "2764:       if (*ps != *s) goto fail;",
          "2765:       ps++; s++;",
          "2766:       if (*ps != *s) goto fail;",
          "2768:       s++;",
          "2769:       INC_OP;",
          "2774:       ps = p->exact.s;",
          "2775:       if (*ps != *s) goto fail;",
          "2776:       ps++; s++;",
          "2777:       if (*ps != *s) goto fail;",
          "2778:       ps++; s++;",
          "2779:       if (*ps != *s) goto fail;",
          "2781:       s++;",
          "2782:       INC_OP;",
          "2787:       ps = p->exact.s;",
          "2788:       if (*ps != *s) goto fail;",
          "2789:       ps++; s++;",
          "2790:       if (*ps != *s) goto fail;",
          "2791:       ps++; s++;",
          "2792:       if (*ps != *s) goto fail;",
          "2793:       ps++; s++;",
          "2794:       if (*ps != *s) goto fail;",
          "2796:       s++;",
          "2797:       INC_OP;",
          "2802:       ps = p->exact.s;",
          "2803:       if (*ps != *s) goto fail;",
          "2804:       ps++; s++;",
          "2805:       if (*ps != *s) goto fail;",
          "2806:       ps++; s++;",
          "2807:       if (*ps != *s) goto fail;",
          "2808:       ps++; s++;",
          "2809:       if (*ps != *s) goto fail;",
          "2810:       ps++; s++;",
          "2811:       if (*ps != *s) goto fail;",
          "2813:       s++;",
          "2814:       INC_OP;",
          "2818:       tlen = p->exact_n.n;",
          "2820:       ps = p->exact_n.s;",
          "2822:         if (*ps++ != *s++) goto fail;",
          "2825:       INC_OP;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2789:         int len;",
          "2790:         UChar *q, *endp, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];",
          "2796:           sprev = s;",
          "2797:           DATA_ENSURE(1);",
          "2798:           len = ONIGENC_MBC_CASE_FOLD(encode,",
          "",
          "[Removed Lines]",
          "2792:         GET_LENGTH_INC(tlen, p);",
          "2793:         endp = p + tlen;",
          "2795:         while (p < endp) {",
          "",
          "[Added Lines]",
          "2833:         tlen = p->exact_n.n;",
          "2834:         ps   = p->exact_n.s;",
          "2835:         endp = ps + tlen;",
          "2836:         while (ps < endp) {",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2802:           DATA_ENSURE(0);",
          "2803:           q = lowbuf;",
          "2804:           while (len-- > 0) {",
          "2807:           }",
          "2808:         }",
          "2809:       }",
          "2811:       JUMP_OUT;",
          "2813:     CASE_OP(EXACTMB2N1)",
          "2814:       DATA_ENSURE(2);",
          "2819:       NEXT_OUT;",
          "2821:     CASE_OP(EXACTMB2N2)",
          "2822:       DATA_ENSURE(4);",
          "2827:       sprev = s;",
          "2832:       JUMP_OUT;",
          "2834:     CASE_OP(EXACTMB2N3)",
          "2835:       DATA_ENSURE(6);",
          "2844:       sprev = s;",
          "2849:       JUMP_OUT;",
          "2851:     CASE_OP(EXACTMB2N)",
          "2853:       DATA_ENSURE(tlen * 2);",
          "2854:       while (tlen-- > 0) {",
          "2859:       }",
          "2860:       sprev = s - 2;",
          "2861:       JUMP_OUT;",
          "2863:     CASE_OP(EXACTMB3N)",
          "2865:       DATA_ENSURE(tlen * 3);",
          "2866:       while (tlen-- > 0) {",
          "2873:       }",
          "2874:       sprev = s - 3;",
          "2875:       JUMP_OUT;",
          "2877:     CASE_OP(EXACTMBN)",
          "2880:       tlen2 *= tlen;",
          "2881:       DATA_ENSURE(tlen2);",
          "2882:       while (tlen2-- > 0) {",
          "2885:       }",
          "2886:       sprev = s - tlen;",
          "2887:       JUMP_OUT;",
          "2889:     CASE_OP(CCLASS)",
          "2890:       DATA_ENSURE(1);",
          "2894:       NEXT_OUT;",
          "2896:     CASE_OP(CCLASS_MB)",
          "2897:       if (! ONIGENC_IS_MBC_HEAD(encode, s)) goto fail;",
          "2899:     cclass_mb:",
          "2901:       {",
          "2902:         OnigCodePoint code;",
          "2903:         UChar *ss;",
          "",
          "[Removed Lines]",
          "2805:             if (*p != *q) goto fail;",
          "2806:             p++; q++;",
          "2815:       if (*p != *s) goto fail;",
          "2816:       p++; s++;",
          "2817:       if (*p != *s) goto fail;",
          "2818:       p++; s++;",
          "2823:       if (*p != *s) goto fail;",
          "2824:       p++; s++;",
          "2825:       if (*p != *s) goto fail;",
          "2826:       p++; s++;",
          "2828:       if (*p != *s) goto fail;",
          "2829:       p++; s++;",
          "2830:       if (*p != *s) goto fail;",
          "2831:       p++; s++;",
          "2836:       if (*p != *s) goto fail;",
          "2837:       p++; s++;",
          "2838:       if (*p != *s) goto fail;",
          "2839:       p++; s++;",
          "2840:       if (*p != *s) goto fail;",
          "2841:       p++; s++;",
          "2842:       if (*p != *s) goto fail;",
          "2843:       p++; s++;",
          "2845:       if (*p != *s) goto fail;",
          "2846:       p++; s++;",
          "2847:       if (*p != *s) goto fail;",
          "2848:       p++; s++;",
          "2852:       GET_LENGTH_INC(tlen, p);",
          "2855:         if (*p != *s) goto fail;",
          "2856:         p++; s++;",
          "2857:         if (*p != *s) goto fail;",
          "2858:         p++; s++;",
          "2864:       GET_LENGTH_INC(tlen, p);",
          "2867:         if (*p != *s) goto fail;",
          "2868:         p++; s++;",
          "2869:         if (*p != *s) goto fail;",
          "2870:         p++; s++;",
          "2871:         if (*p != *s) goto fail;",
          "2872:         p++; s++;",
          "2883:         if (*p != *s) goto fail;",
          "2884:         p++; s++;",
          "2891:       if (BITSET_AT(((BitSetRef )p), *s) == 0) goto fail;",
          "2892:       p += SIZE_BITSET;",
          "2900:       GET_LENGTH_INC(tlen, p);",
          "",
          "[Added Lines]",
          "2846:             if (*ps != *q) goto fail;",
          "2847:             ps++; q++;",
          "2852:       INC_OP;",
          "2857:       ps = p->exact.s;",
          "2858:       if (*ps != *s) goto fail;",
          "2859:       ps++; s++;",
          "2860:       if (*ps != *s) goto fail;",
          "2861:       s++;",
          "2862:       INC_OP;",
          "2867:       ps = p->exact.s;",
          "2868:       if (*ps != *s) goto fail;",
          "2869:       ps++; s++;",
          "2870:       if (*ps != *s) goto fail;",
          "2871:       ps++; s++;",
          "2873:       if (*ps != *s) goto fail;",
          "2874:       ps++; s++;",
          "2875:       if (*ps != *s) goto fail;",
          "2876:       s++;",
          "2877:       INC_OP;",
          "2882:       ps = p->exact.s;",
          "2883:       if (*ps != *s) goto fail;",
          "2884:       ps++; s++;",
          "2885:       if (*ps != *s) goto fail;",
          "2886:       ps++; s++;",
          "2887:       if (*ps != *s) goto fail;",
          "2888:       ps++; s++;",
          "2889:       if (*ps != *s) goto fail;",
          "2890:       ps++; s++;",
          "2892:       if (*ps != *s) goto fail;",
          "2893:       ps++; s++;",
          "2894:       if (*ps != *s) goto fail;",
          "2895:       ps++; s++;",
          "2896:       INC_OP;",
          "2900:       tlen = p->exact_n.n;",
          "2902:       ps = p->exact_n.s;",
          "2904:         if (*ps != *s) goto fail;",
          "2905:         ps++; s++;",
          "2906:         if (*ps != *s) goto fail;",
          "2907:         ps++; s++;",
          "2910:       INC_OP;",
          "2914:       tlen = p->exact_n.n;",
          "2916:       ps = p->exact_n.s;",
          "2918:         if (*ps != *s) goto fail;",
          "2919:         ps++; s++;",
          "2920:         if (*ps != *s) goto fail;",
          "2921:         ps++; s++;",
          "2922:         if (*ps != *s) goto fail;",
          "2923:         ps++; s++;",
          "2926:       INC_OP;",
          "2934:       ps = p->exact_len_n.s;",
          "2936:         if (*ps != *s) goto fail;",
          "2937:         ps++; s++;",
          "2940:       INC_OP;",
          "2945:       if (BITSET_AT(p->cclass.bs, *s) == 0) goto fail;",
          "2947:       INC_OP;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2909:         ss = s;",
          "2910:         s += mb_len;",
          "2911:         code = ONIGENC_MBC_TO_CODE(encode, ss, s);",
          "2920:       }",
          "2922:       NEXT_OUT;",
          "2924:     CASE_OP(CCLASS_MIX)",
          "2925:       DATA_ENSURE(1);",
          "2926:       if (ONIGENC_IS_MBC_HEAD(encode, s)) {",
          "2928:         goto cclass_mb;",
          "2929:       }",
          "2930:       else {",
          "2932:           goto fail;",
          "2937:         s++;",
          "2938:       }",
          "2939:       NEXT_OUT;",
          "2941:     CASE_OP(CCLASS_NOT)",
          "2942:       DATA_ENSURE(1);",
          "2945:       s += enclen(encode, s);",
          "2946:       NEXT_OUT;",
          "2948:     CASE_OP(CCLASS_MB_NOT)",
          "2949:       DATA_ENSURE(1);",
          "2950:       if (! ONIGENC_IS_MBC_HEAD(encode, s)) {",
          "2951:         s++;",
          "2954:         goto cc_mb_not_success;",
          "2955:       }",
          "2957:     cclass_mb_not:",
          "2959:       {",
          "2960:         OnigCodePoint code;",
          "2961:         UChar *ss;",
          "",
          "[Removed Lines]",
          "2913: #ifdef PLATFORM_UNALIGNED_WORD_ACCESS",
          "2914:         if (! onig_is_in_code_range(p, code)) goto fail;",
          "2915: #else",
          "2916:         q = p;",
          "2917:         ALIGNMENT_RIGHT(q);",
          "2918:         if (! onig_is_in_code_range(q, code)) goto fail;",
          "2919: #endif",
          "2921:       p += tlen;",
          "2927:         p += SIZE_BITSET;",
          "2931:         if (BITSET_AT(((BitSetRef )p), *s) == 0)",
          "2934:         p += SIZE_BITSET;",
          "2935:         GET_LENGTH_INC(tlen, p);",
          "2936:         p += tlen;",
          "2943:       if (BITSET_AT(((BitSetRef )p), *s) != 0) goto fail;",
          "2944:       p += SIZE_BITSET;",
          "2952:         GET_LENGTH_INC(tlen, p);",
          "2953:         p += tlen;",
          "2958:       GET_LENGTH_INC(tlen, p);",
          "",
          "[Added Lines]",
          "2965:         if (! onig_is_in_code_range(p->cclass_mb.mb, code)) goto fail;",
          "2967:       INC_OP;",
          "2976:         if (BITSET_AT(p->cclass_mix.bs, *s) == 0)",
          "2981:       INC_OP;",
          "2986:       if (BITSET_AT(p->cclass.bs, *s) != 0) goto fail;",
          "2988:       INC_OP;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "2964:         if (! DATA_ENSURE_CHECK(mb_len)) {",
          "2965:           DATA_ENSURE(1);",
          "2966:           s = (UChar* )end;",
          "2968:           goto cc_mb_not_success;",
          "2969:         }",
          "2971:         ss = s;",
          "2972:         s += mb_len;",
          "2973:         code = ONIGENC_MBC_TO_CODE(encode, ss, s);",
          "2982:       }",
          "2985:     cc_mb_not_success:",
          "2986:       NEXT_OUT;",
          "2988:     CASE_OP(CCLASS_MIX_NOT)",
          "2989:       DATA_ENSURE(1);",
          "2990:       if (ONIGENC_IS_MBC_HEAD(encode, s)) {",
          "2992:         goto cclass_mb_not;",
          "2993:       }",
          "2994:       else {",
          "2996:           goto fail;",
          "3001:         s++;",
          "3002:       }",
          "3003:       NEXT_OUT;",
          "3005: #ifdef USE_OP_CCLASS_NODE",
          "",
          "[Removed Lines]",
          "2967:           p += tlen;",
          "2975: #ifdef PLATFORM_UNALIGNED_WORD_ACCESS",
          "2976:         if (onig_is_in_code_range(p, code)) goto fail;",
          "2977: #else",
          "2978:         q = p;",
          "2979:         ALIGNMENT_RIGHT(q);",
          "2980:         if (onig_is_in_code_range(q, code)) goto fail;",
          "2981: #endif",
          "2983:       p += tlen;",
          "2991:         p += SIZE_BITSET;",
          "2995:         if (BITSET_AT(((BitSetRef )p), *s) != 0)",
          "2998:         p += SIZE_BITSET;",
          "2999:         GET_LENGTH_INC(tlen, p);",
          "3000:         p += tlen;",
          "",
          "[Added Lines]",
          "3013:         if (onig_is_in_code_range(p->cclass_mb.mb, code)) goto fail;",
          "3017:       INC_OP;",
          "3026:         if (BITSET_AT(p->cclass_mix.bs, *s) != 0)",
          "3031:       INC_OP;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "3019:         code = ONIGENC_MBC_TO_CODE(encode, ss, s);",
          "3020:         if (onig_is_code_in_cc_len(mb_len, code, node) == 0) goto fail;",
          "3021:       }",
          "3022:       NEXT_OUT;",
          "3023: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3051:       INC_OP;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "3028:       DATA_ENSURE(n);",
          "3029:       if (ONIGENC_IS_MBC_NEWLINE(encode, s, end)) goto fail;",
          "3030:       s += n;",
          "3031:       NEXT_OUT;",
          "3033:     CASE_OP(ANYCHAR_ML)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3061:       INC_OP;",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "3035:       n = enclen(encode, s);",
          "3036:       DATA_ENSURE(n);",
          "3037:       s += n;",
          "3038:       NEXT_OUT;",
          "3040:     CASE_OP(ANYCHAR_STAR)",
          "3041:       while (DATA_ENSURE_CHECK1) {",
          "3042:         STACK_PUSH_ALT(p, s, sprev);",
          "3043:         n = enclen(encode, s);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3069:       INC_OP;",
          "3073:       INC_OP;",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "3049:       JUMP_OUT;",
          "3051:     CASE_OP(ANYCHAR_ML_STAR)",
          "3052:       while (DATA_ENSURE_CHECK1) {",
          "3053:         STACK_PUSH_ALT(p, s, sprev);",
          "3054:         n = enclen(encode, s);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3085:       INC_OP;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "3065:       JUMP_OUT;",
          "3067:     CASE_OP(ANYCHAR_STAR_PEEK_NEXT)",
          "3088:           DATA_ENSURE(n);",
          "3089:           sprev = s;",
          "3090:           s += n;",
          "3091:         }",
          "3095:         }",
          "3096:       }",
          "3098:       NEXT_OUT;",
          "3100:     CASE_OP(WORD)",
          "",
          "[Removed Lines]",
          "3068:       while (DATA_ENSURE_CHECK1) {",
          "3069:         if (*p == *s) {",
          "3070:           STACK_PUSH_ALT(p + 1, s, sprev);",
          "3071:         }",
          "3072:         n = enclen(encode, s);",
          "3073:         DATA_ENSURE(n);",
          "3074:         if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;",
          "3075:         sprev = s;",
          "3076:         s += n;",
          "3077:       }",
          "3078:       p++;",
          "3079:       NEXT_OUT;",
          "3081:     CASE_OP(ANYCHAR_ML_STAR_PEEK_NEXT)",
          "3082:       while (DATA_ENSURE_CHECK1) {",
          "3083:         if (*p == *s) {",
          "3084:           STACK_PUSH_ALT(p + 1, s, sprev);",
          "3085:         }",
          "3086:         n = enclen(encode, s);",
          "3087:         if (n > 1) {",
          "3092:         else {",
          "3093:           sprev = s;",
          "3094:           s++;",
          "3097:       p++;",
          "",
          "[Added Lines]",
          "3102:       {",
          "3103:         UChar c;",
          "3105:         c = p->anychar_star_peek_next.c;",
          "3106:         INC_OP;",
          "3107:         while (DATA_ENSURE_CHECK1) {",
          "3108:           if (c == *s) {",
          "3109:             STACK_PUSH_ALT(p, s, sprev);",
          "3110:           }",
          "3111:           n = enclen(encode, s);",
          "3113:           if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;",
          "3117:       }",
          "3118:       NEXT_OUT;",
          "3120:     CASE_OP(ANYCHAR_ML_STAR_PEEK_NEXT)",
          "3121:       {",
          "3122:         UChar c;",
          "3124:         c = p->anychar_star_peek_next.c;",
          "3125:         INC_OP;",
          "3126:         while (DATA_ENSURE_CHECK1) {",
          "3127:           if (c == *s) {",
          "3128:             STACK_PUSH_ALT(p, s, sprev);",
          "3129:           }",
          "3130:           n = enclen(encode, s);",
          "3131:           if (n > 1) {",
          "3132:             DATA_ENSURE(n);",
          "3133:             sprev = s;",
          "3134:             s += n;",
          "3135:           }",
          "3136:           else {",
          "3137:             sprev = s;",
          "3138:             s++;",
          "3139:           }",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "3103:         goto fail;",
          "3105:       s += enclen(encode, s);",
          "3106:       NEXT_OUT;",
          "3108:     CASE_OP(WORD_ASCII)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3150:       INC_OP;",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "3111:         goto fail;",
          "3113:       s += enclen(encode, s);",
          "3114:       NEXT_OUT;",
          "3116:     CASE_OP(NO_WORD)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3159:       INC_OP;",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "3119:         goto fail;",
          "3121:       s += enclen(encode, s);",
          "3122:       NEXT_OUT;",
          "3124:     CASE_OP(NO_WORD_ASCII)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3168:       INC_OP;",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "3127:         goto fail;",
          "3129:       s += enclen(encode, s);",
          "3130:       NEXT_OUT;",
          "3132:     CASE_OP(WORD_BOUNDARY)",
          "3133:       {",
          "3134:         ModeType mode;",
          "3137:         if (ON_STR_BEGIN(s)) {",
          "3138:           DATA_ENSURE(1);",
          "3139:           if (! IS_MBC_WORD_ASCII_MODE(encode, s, end, mode))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3177:       INC_OP;",
          "3184:         mode = p->word_boundary.mode;",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "3149:             goto fail;",
          "3150:         }",
          "3151:       }",
          "3152:       JUMP_OUT;",
          "3154:     CASE_OP(NO_WORD_BOUNDARY)",
          "3155:       {",
          "3156:         ModeType mode;",
          "3159:         if (ON_STR_BEGIN(s)) {",
          "3160:           if (DATA_ENSURE_CHECK1 && IS_MBC_WORD_ASCII_MODE(encode, s, end, mode))",
          "3161:             goto fail;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3200:       INC_OP;",
          "3207:         mode = p->word_boundary.mode;",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "3170:             goto fail;",
          "3171:         }",
          "3172:       }",
          "3173:       JUMP_OUT;",
          "3175: #ifdef USE_WORD_BEGIN_END",
          "3176:     CASE_OP(WORD_BEGIN)",
          "3177:       {",
          "3178:         ModeType mode;",
          "3181:         if (DATA_ENSURE_CHECK1 && IS_MBC_WORD_ASCII_MODE(encode, s, end, mode)) {",
          "3182:           if (ON_STR_BEGIN(s) || !IS_MBC_WORD_ASCII_MODE(encode, sprev, end, mode)) {",
          "3183:             JUMP_OUT;",
          "3184:           }",
          "3185:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3222:       INC_OP;",
          "3230:         mode = p->word_boundary.mode;",
          "3233:             INC_OP;",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "3189:     CASE_OP(WORD_END)",
          "3190:       {",
          "3191:         ModeType mode;",
          "3194:         if (!ON_STR_BEGIN(s) && IS_MBC_WORD_ASCII_MODE(encode, sprev, end, mode)) {",
          "3195:           if (ON_STR_END(s) || ! IS_MBC_WORD_ASCII_MODE(encode, s, end, mode)) {",
          "3196:             JUMP_OUT;",
          "3197:           }",
          "3198:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3244:         mode = p->word_boundary.mode;",
          "3247:             INC_OP;",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "3203:     CASE_OP(EXTENDED_GRAPHEME_CLUSTER_BOUNDARY)",
          "3204:       if (onigenc_egcb_is_break_position(encode, s, sprev, str, end)) {",
          "3205:         JUMP_OUT;",
          "3206:       }",
          "3207:       goto fail;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3257:         INC_OP;",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "3210:       if (onigenc_egcb_is_break_position(encode, s, sprev, str, end))",
          "3211:         goto fail;",
          "3213:       JUMP_OUT;",
          "3215:     CASE_OP(BEGIN_BUF)",
          "3216:       if (! ON_STR_BEGIN(s)) goto fail;",
          "3218:       JUMP_OUT;",
          "3220:     CASE_OP(END_BUF)",
          "3221:       if (! ON_STR_END(s)) goto fail;",
          "3223:       JUMP_OUT;",
          "3225:     CASE_OP(BEGIN_LINE)",
          "3226:       if (ON_STR_BEGIN(s)) {",
          "3227:         if (IS_NOTBOL(msa->options)) goto fail;",
          "3228:         JUMP_OUT;",
          "3229:       }",
          "3230:       else if (ONIGENC_IS_MBC_NEWLINE(encode, sprev, end) && !ON_STR_END(s)) {",
          "3231:         JUMP_OUT;",
          "3232:       }",
          "3233:       goto fail;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3266:       INC_OP;",
          "3272:       INC_OP;",
          "3278:       INC_OP;",
          "3284:         INC_OP;",
          "3288:         INC_OP;",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "3238:         if (IS_EMPTY_STR || !ONIGENC_IS_MBC_NEWLINE(encode, sprev, end)) {",
          "3239: #endif",
          "3240:           if (IS_NOTEOL(msa->options)) goto fail;",
          "3241:           JUMP_OUT;",
          "3242: #ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE",
          "3243:         }",
          "3244: #endif",
          "3245:       }",
          "3246:       else if (ONIGENC_IS_MBC_NEWLINE(encode, s, end)) {",
          "3247:         JUMP_OUT;",
          "3248:       }",
          "3249: #ifdef USE_CRNL_AS_LINE_TERMINATOR",
          "3250:       else if (ONIGENC_IS_MBC_CRNL(encode, s, end)) {",
          "3251:         JUMP_OUT;",
          "3252:       }",
          "3253: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3299:           INC_OP;",
          "3306:         INC_OP;",
          "3311:         INC_OP;",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "3259:         if (IS_EMPTY_STR || !ONIGENC_IS_MBC_NEWLINE(encode, sprev, end)) {",
          "3260: #endif",
          "3261:           if (IS_NOTEOL(msa->options)) goto fail;",
          "3262:           JUMP_OUT;",
          "3263: #ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE",
          "3264:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3323:           INC_OP;",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "3266:       }",
          "3267:       else if (ONIGENC_IS_MBC_NEWLINE(encode, s, end) &&",
          "3268:                ON_STR_END(s + enclen(encode, s))) {",
          "3269:         JUMP_OUT;",
          "3270:       }",
          "3271: #ifdef USE_CRNL_AS_LINE_TERMINATOR",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3331:         INC_OP;",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "3273:         UChar* ss = s + enclen(encode, s);",
          "3274:         ss += enclen(encode, ss);",
          "3275:         if (ON_STR_END(ss)) {",
          "3276:           JUMP_OUT;",
          "3277:         }",
          "3278:       }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3339:           INC_OP;",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "3283:       if (s != msa->start)",
          "3284:         goto fail;",
          "3286:       JUMP_OUT;",
          "3288:     CASE_OP(MEMORY_START_PUSH)",
          "3290:       STACK_PUSH_MEM_START(mem, s);",
          "3291:       JUMP_OUT;",
          "3293:     CASE_OP(MEMORY_START)",
          "3295:       mem_start_stk[mem] = (StackIndex )((void* )s);",
          "3296:       JUMP_OUT;",
          "3298:     CASE_OP(MEMORY_END_PUSH)",
          "3300:       STACK_PUSH_MEM_END(mem, s);",
          "3301:       JUMP_OUT;",
          "3303:     CASE_OP(MEMORY_END)",
          "3305:       mem_end_stk[mem] = (StackIndex )((void* )s);",
          "3306:       JUMP_OUT;",
          "3308: #ifdef USE_CALL",
          "3309:     CASE_OP(MEMORY_END_PUSH_REC)",
          "3312:       STACK_PUSH_MEM_END(mem, s);",
          "3313:       mem_start_stk[mem] = GET_STACK_INDEX(stkp);",
          "3314:       JUMP_OUT;",
          "3316:     CASE_OP(MEMORY_END_REC)",
          "3318:       mem_end_stk[mem] = (StackIndex )((void* )s);",
          "3319:       STACK_GET_MEM_START(mem, stkp);",
          "",
          "[Removed Lines]",
          "3289:       GET_MEMNUM_INC(mem, p);",
          "3294:       GET_MEMNUM_INC(mem, p);",
          "3299:       GET_MEMNUM_INC(mem, p);",
          "3304:       GET_MEMNUM_INC(mem, p);",
          "3310:       GET_MEMNUM_INC(mem, p);",
          "3317:       GET_MEMNUM_INC(mem, p);",
          "",
          "[Added Lines]",
          "3350:       INC_OP;",
          "3354:       mem = p->memory_start.num;",
          "3356:       INC_OP;",
          "3360:       mem = p->memory_start.num;",
          "3362:       INC_OP;",
          "3366:       mem = p->memory_end.num;",
          "3368:       INC_OP;",
          "3372:       mem = p->memory_end.num;",
          "3374:       INC_OP;",
          "3379:       mem = p->memory_end.num;",
          "3383:       INC_OP;",
          "3387:       mem = p->memory_end.num;",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "3324:         mem_start_stk[mem] = (StackIndex )((void* )stkp->u.mem.pstr);",
          "3326:       STACK_PUSH_MEM_END_MARK(mem);",
          "3327:       JUMP_OUT;",
          "3328: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3397:       INC_OP;",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "3336:       goto backref;",
          "3338:     CASE_OP(BACKREF_N)",
          "3340:     backref:",
          "3341:       {",
          "3342:         int len;",
          "",
          "[Removed Lines]",
          "3339:       GET_MEMNUM_INC(mem, p);",
          "",
          "[Added Lines]",
          "3410:       mem = p->backref_n.n1;",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "3360:         while (sprev + (len = enclen(encode, sprev)) < s)",
          "3361:           sprev += len;",
          "3362:       }",
          "3363:       JUMP_OUT;",
          "3365:     CASE_OP(BACKREF_N_IC)",
          "3367:       {",
          "3368:         int len;",
          "3369:         UChar *pstart, *pend;",
          "",
          "[Removed Lines]",
          "3366:       GET_MEMNUM_INC(mem, p);",
          "",
          "[Added Lines]",
          "3434:       INC_OP;",
          "3438:       mem = p->backref_n.n1;",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "3386:         while (sprev + (len = enclen(encode, sprev)) < s)",
          "3387:           sprev += len;",
          "3388:       }",
          "3389:       JUMP_OUT;",
          "3391:     CASE_OP(BACKREF_MULTI)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3461:       INC_OP;",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "3393:         int len, is_fail;",
          "3394:         UChar *pstart, *pend, *swork;",
          "3397:         for (i = 0; i < tlen; i++) {",
          "3400:           if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;",
          "3401:           if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;",
          "",
          "[Removed Lines]",
          "3396:         GET_LENGTH_INC(tlen, p);",
          "3398:           GET_MEMNUM_INC(mem, p);",
          "",
          "[Added Lines]",
          "3469:         tlen = p->backref_general.num;",
          "3471:           mem = tlen == 1 ? p->backref_general.n1 : p->backref_general.ns[i];",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "3418:           while (sprev + (len = enclen(encode, sprev)) < s)",
          "3419:             sprev += len;",
          "3423:         }",
          "3424:         if (i == tlen) goto fail;",
          "3425:       }",
          "3426:       JUMP_OUT;",
          "3428:     CASE_OP(BACKREF_MULTI_IC)",
          "",
          "[Removed Lines]",
          "3421:           p += (SIZE_MEMNUM * (tlen - i - 1));",
          "",
          "[Added Lines]",
          "3498:       INC_OP;",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "3430:         int len, is_fail;",
          "3431:         UChar *pstart, *pend, *swork;",
          "3434:         for (i = 0; i < tlen; i++) {",
          "3437:           if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;",
          "3438:           if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;",
          "",
          "[Removed Lines]",
          "3433:         GET_LENGTH_INC(tlen, p);",
          "3435:           GET_MEMNUM_INC(mem, p);",
          "",
          "[Added Lines]",
          "3506:         tlen = p->backref_general.num;",
          "3508:           mem = tlen == 1 ? p->backref_general.n1 : p->backref_general.ns[i];",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "3455:           while (sprev + (len = enclen(encode, sprev)) < s)",
          "3456:             sprev += len;",
          "3460:         }",
          "3461:         if (i == tlen) goto fail;",
          "3462:       }",
          "3463:       JUMP_OUT;",
          "3465: #ifdef USE_BACKREF_WITH_LEVEL",
          "",
          "[Removed Lines]",
          "3458:           p += (SIZE_MEMNUM * (tlen - i - 1));",
          "",
          "[Added Lines]",
          "3535:       INC_OP;",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "3467:       {",
          "3468:         int len;",
          "3469:         OnigOptionType ic;",
          "3476:         sprev = s;",
          "3477:         if (backref_match_at_nested_level(reg, stk, stk_base, ic",
          "3479:           if (sprev < end) {",
          "3480:             while (sprev + (len = enclen(encode, sprev)) < s)",
          "3481:               sprev += len;",
          "3482:           }",
          "3484:         }",
          "3485:         else",
          "3486:           goto fail;",
          "3487:       }",
          "3488:       JUMP_OUT;",
          "3489: #endif",
          "3491:     CASE_OP(BACKREF_CHECK)",
          "3492:       {",
          "3497:           if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;",
          "3498:           if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;",
          "3502:         }",
          "3503:         if (i == tlen) goto fail;",
          "3504:       }",
          "3505:       JUMP_OUT;",
          "3507: #ifdef USE_BACKREF_WITH_LEVEL",
          "3508:     CASE_OP(BACKREF_CHECK_WITH_LEVEL)",
          "3509:       {",
          "3510:         LengthType level;",
          "3515:         if (backref_check_at_nested_level(reg, stk, stk_base,",
          "3518:         }",
          "3519:         else",
          "3520:           goto fail;",
          "3521:       }",
          "3522:       JUMP_OUT;",
          "3523: #endif",
          "3525:     CASE_OP(EMPTY_CHECK_START)",
          "3527:       STACK_PUSH_EMPTY_CHECK_START(mem, s);",
          "3528:       JUMP_OUT;",
          "3530:     CASE_OP(EMPTY_CHECK_END)",
          "3531:       {",
          "3532:         int is_empty;",
          "3535:         STACK_EMPTY_CHECK(is_empty, mem, s);",
          "3536:         if (is_empty) {",
          "3537: #ifdef ONIG_DEBUG_MATCH",
          "3538:           fprintf(stderr, \"EMPTY_CHECK_END: skip  id:%d, s:%p\\n\", (int )mem, s);",
          "3539: #endif",
          "3540:         empty_check_found:",
          "3543:           case OP_JUMP:",
          "3544:           case OP_PUSH:",
          "3547:           case OP_REPEAT_INC:",
          "3548:           case OP_REPEAT_INC_NG:",
          "3549:           case OP_REPEAT_INC_SG:",
          "3550:           case OP_REPEAT_INC_NG_SG:",
          "3552:             break;",
          "3553:           default:",
          "3554:             goto unexpected_bytecode_error;",
          "",
          "[Removed Lines]",
          "3470:         LengthType level;",
          "3472:         GET_OPTION_INC(ic,    p);",
          "3473:         GET_LENGTH_INC(level, p);",
          "3474:         GET_LENGTH_INC(tlen,  p);",
          "3478:                      , case_fold_flag, (int )level, (int )tlen, p, &s, end)) {",
          "3483:           p += (SIZE_MEMNUM * tlen);",
          "3493:         GET_LENGTH_INC(tlen, p);",
          "3494:         for (i = 0; i < tlen; i++) {",
          "3495:           GET_MEMNUM_INC(mem, p);",
          "3500:           p += (SIZE_MEMNUM * (tlen - i - 1));",
          "3512:         GET_LENGTH_INC(level, p);",
          "3513:         GET_LENGTH_INC(tlen,  p);",
          "3516:                                           (int )level, (int )tlen, p) != 0) {",
          "3517:           p += (SIZE_MEMNUM * tlen);",
          "3542:           switch (*p++) {",
          "3545:             p += SIZE_RELADDR;",
          "3546:             break;",
          "3551:             p += SIZE_MEMNUM;",
          "",
          "[Added Lines]",
          "3543:         int level;",
          "3544:         MemNumType* mems;",
          "3546:         ic    = p->backref_general.options;",
          "3547:         level = p->backref_general.nest_level;",
          "3548:         tlen  = p->backref_general.num;",
          "3549:         mems = tlen == 1 ? &(p->backref_general.n1) : p->backref_general.ns;",
          "3553:                      , case_fold_flag, level, (int )tlen, mems, &s, end)) {",
          "3562:       INC_OP;",
          "3568:         MemNumType* mems;",
          "3570:         tlen  = p->backref_general.num;",
          "3571:         mems = tlen == 1 ? &(p->backref_general.n1) : p->backref_general.ns;",
          "3573:         for (i = 0; i < tlen; i++) {",
          "3574:           mem = mems[i];",
          "3581:       INC_OP;",
          "3588:         MemNumType* mems;",
          "3590:         level = p->backref_general.nest_level;",
          "3591:         tlen  = p->backref_general.num;",
          "3592:         mems = tlen == 1 ? &(p->backref_general.n1) : p->backref_general.ns;",
          "3595:                                           (int )level, (int )tlen, mems) != 0) {",
          "3600:       INC_OP;",
          "3607:       INC_OP;",
          "3616:         INC_OP;",
          "3623:           switch (p->opcode) {",
          "3630:             INC_OP;",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "3563:       {",
          "3564:         int is_empty;",
          "3567:         STACK_EMPTY_CHECK_MEM(is_empty, mem, s, reg);",
          "3568:         if (is_empty) {",
          "3569: #ifdef ONIG_DEBUG_MATCH",
          "3570:           fprintf(stderr, \"EMPTY_CHECK_END_MEM: skip  id:%d, s:%p\\n\", (int)mem, s);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3647:         INC_OP;",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "3581:       {",
          "3582:         int is_empty;",
          "3585: #ifdef USE_INSISTENT_CHECK_CAPTURES_IN_EMPTY_REPEAT",
          "3586:         STACK_EMPTY_CHECK_MEM_REC(is_empty, mem, s, reg);",
          "3587: #else",
          "3588:         STACK_EMPTY_CHECK_REC(is_empty, mem, s);",
          "3589: #endif",
          "3590:         if (is_empty) {",
          "3591: #ifdef ONIG_DEBUG_MATCH",
          "3592:           fprintf(stderr, \"EMPTY_CHECK_END_MEM_PUSH: skip  id:%d, s:%p\\n\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3670:         INC_OP;",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "3603: #endif",
          "3605:     CASE_OP(JUMP)",
          "3607:       p += addr;",
          "3608:       CHECK_INTERRUPT_JUMP_OUT;",
          "3610:     CASE_OP(PUSH)",
          "3612:       STACK_PUSH_ALT(p + addr, s, sprev);",
          "3613:       JUMP_OUT;",
          "3615:     CASE_OP(PUSH_SUPER)",
          "3617:       STACK_PUSH_SUPER_ALT(p + addr, s, sprev);",
          "3618:       JUMP_OUT;",
          "3620:     CASE_OP(POP_OUT)",
          "3621:       STACK_POP_ONE;",
          "3624:       JUMP_OUT;",
          "3626:     CASE_OP(PUSH_OR_JUMP_EXACT1)",
          "3632:       }",
          "3634:       JUMP_OUT;",
          "3636:     CASE_OP(PUSH_IF_PEEK_NEXT)",
          "3642:       }",
          "3644:       JUMP_OUT;",
          "3646:     CASE_OP(REPEAT)",
          "3658:       }",
          "3659:       JUMP_OUT;",
          "3661:     CASE_OP(REPEAT_NG)",
          "3674:       }",
          "3675:       JUMP_OUT;",
          "3677:     CASE_OP(REPEAT_INC)",
          "3680:       stkp = STACK_AT(si);",
          "3682:     repeat_inc:",
          "3683:       stkp->u.repeat.count++;",
          "3684:       if (stkp->u.repeat.count >= reg->repeat_range[mem].upper) {",
          "3686:       }",
          "3687:       else if (stkp->u.repeat.count >= reg->repeat_range[mem].lower) {",
          "3688:         STACK_PUSH_ALT(p, s, sprev);",
          "",
          "[Removed Lines]",
          "3606:       GET_RELADDR_INC(addr, p);",
          "3611:       GET_RELADDR_INC(addr, p);",
          "3616:       GET_RELADDR_INC(addr, p);",
          "3627:       GET_RELADDR_INC(addr, p);",
          "3628:       if (*p == *s && DATA_ENSURE_CHECK1) {",
          "3629:         p++;",
          "3630:         STACK_PUSH_ALT(p + addr, s, sprev);",
          "3631:         JUMP_OUT;",
          "3633:       p += (addr + 1);",
          "3637:       GET_RELADDR_INC(addr, p);",
          "3638:       if (*p == *s) {",
          "3639:         p++;",
          "3640:         STACK_PUSH_ALT(p + addr, s, sprev);",
          "3641:         JUMP_OUT;",
          "3643:       p++;",
          "3647:       {",
          "3649:         GET_RELADDR_INC(addr, p);",
          "3651:         STACK_ENSURE(1);",
          "3652:         repeat_stk[mem] = GET_STACK_INDEX(stk);",
          "3653:         STACK_PUSH_REPEAT(mem, p);",
          "3655:         if (reg->repeat_range[mem].lower == 0) {",
          "3656:           STACK_PUSH_ALT(p + addr, s, sprev);",
          "3657:         }",
          "3662:       {",
          "3664:         GET_RELADDR_INC(addr, p);",
          "3666:         STACK_ENSURE(1);",
          "3667:         repeat_stk[mem] = GET_STACK_INDEX(stk);",
          "3668:         STACK_PUSH_REPEAT(mem, p);",
          "3670:         if (reg->repeat_range[mem].lower == 0) {",
          "3671:           STACK_PUSH_ALT(p, s, sprev);",
          "3672:           p += addr;",
          "3673:         }",
          "3679:       si = repeat_stk[mem];",
          "",
          "[Added Lines]",
          "3687:       addr = p->jump.addr;",
          "3692:       addr = p->push.addr;",
          "3694:       INC_OP;",
          "3698:       addr = p->push.addr;",
          "3700:       INC_OP;",
          "3707:       INC_OP;",
          "3711:       {",
          "3712:         UChar c;",
          "3714:         addr = p->push_or_jump_exact1.addr;",
          "3715:         c    = p->push_or_jump_exact1.c;",
          "3716:         if (DATA_ENSURE_CHECK1 && c == *s) {",
          "3717:           STACK_PUSH_ALT(p + addr, s, sprev);",
          "3718:           INC_OP;",
          "3719:           JUMP_OUT;",
          "3720:         }",
          "3722:       p += addr;",
          "3726:       {",
          "3727:         UChar c;",
          "3729:         addr = p->push_if_peek_next.addr;",
          "3730:         c    = p->push_if_peek_next.c;",
          "3731:         if (c == *s) {",
          "3732:           STACK_PUSH_ALT(p + addr, s, sprev);",
          "3733:           INC_OP;",
          "3734:           JUMP_OUT;",
          "3735:         }",
          "3737:       INC_OP;",
          "3742:       addr = p->repeat.addr;",
          "3744:       STACK_ENSURE(1);",
          "3745:       repeat_stk[mem] = GET_STACK_INDEX(stk);",
          "3746:       STACK_PUSH_REPEAT(mem, p + 1);",
          "3748:       if (reg->repeat_range[mem].lower == 0) {",
          "3749:         STACK_PUSH_ALT(p + addr, s, sprev);",
          "3751:       INC_OP;",
          "3756:       addr = p->repeat.addr;",
          "3758:       STACK_ENSURE(1);",
          "3759:       repeat_stk[mem] = GET_STACK_INDEX(stk);",
          "3760:       STACK_PUSH_REPEAT(mem, p + 1);",
          "3762:       if (reg->repeat_range[mem].lower == 0) {",
          "3763:         STACK_PUSH_ALT(p + 1, s, sprev);",
          "3764:         p += addr;",
          "3766:       else",
          "3767:         INC_OP;",
          "3772:       si   = repeat_stk[mem];",
          "3779:         INC_OP;",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "3709:       stkp->u.repeat.count++;",
          "3710:       if (stkp->u.repeat.count < reg->repeat_range[mem].upper) {",
          "3711:         if (stkp->u.repeat.count >= reg->repeat_range[mem].lower) {",
          "3714:           STACK_PUSH_REPEAT_INC(si);",
          "3715:           STACK_PUSH_ALT(pcode, s, sprev);",
          "3716:         }",
          "3717:         else {",
          "3718:           p = stkp->u.repeat.pcode;",
          "",
          "[Removed Lines]",
          "3712:           UChar* pcode = stkp->u.repeat.pcode;",
          "",
          "[Added Lines]",
          "3806:           Operation* pcode = stkp->u.repeat.pcode;",
          "3810:           INC_OP;",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "3721:       }",
          "3722:       else if (stkp->u.repeat.count == reg->repeat_range[mem].upper) {",
          "3723:         STACK_PUSH_REPEAT_INC(si);",
          "3724:       }",
          "3725:       CHECK_INTERRUPT_JUMP_OUT;",
          "3727:     CASE_OP(REPEAT_INC_NG_SG)",
          "3729:       STACK_GET_REPEAT(mem, stkp);",
          "3730:       si = GET_STACK_INDEX(stkp);",
          "3731:       goto repeat_inc_ng;",
          "3733:     CASE_OP(PREC_READ_START)",
          "3734:       STACK_PUSH_POS(s, sprev);",
          "3735:       JUMP_OUT;",
          "3737:     CASE_OP(PREC_READ_END)",
          "3743:       JUMP_OUT;",
          "3745:     CASE_OP(PREC_READ_NOT_START)",
          "3747:       STACK_PUSH_ALT_PREC_READ_NOT(p + addr, s, sprev);",
          "3748:       JUMP_OUT;",
          "3750:     CASE_OP(PREC_READ_NOT_END)",
          "",
          "[Removed Lines]",
          "3738:       {",
          "3739:         STACK_EXEC_TO_VOID(stkp);",
          "3740:         s     = stkp->u.state.pstr;",
          "3741:         sprev = stkp->u.state.pstr_prev;",
          "3742:       }",
          "3746:       GET_RELADDR_INC(addr, p);",
          "",
          "[Added Lines]",
          "3819:         INC_OP;",
          "3831:       INC_OP;",
          "3835:       STACK_EXEC_TO_VOID(stkp);",
          "3836:       s     = stkp->u.state.pstr;",
          "3837:       sprev = stkp->u.state.pstr_prev;",
          "3838:       INC_OP;",
          "3842:       addr = p->prec_read_not_start.addr;",
          "3844:       INC_OP;",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "3754:     CASE_OP(ATOMIC_START)",
          "3755:       STACK_PUSH_TO_VOID_START;",
          "3756:       JUMP_OUT;",
          "3758:     CASE_OP(ATOMIC_END)",
          "3759:       STACK_EXEC_TO_VOID(stkp);",
          "3760:       JUMP_OUT;",
          "3762:     CASE_OP(LOOK_BEHIND)",
          "3764:       s = (UChar* )ONIGENC_STEP_BACK(encode, str, s, (int )tlen);",
          "3765:       if (IS_NULL(s)) goto fail;",
          "3766:       sprev = (UChar* )onigenc_get_prev_char_head(encode, str, s);",
          "3767:       JUMP_OUT;",
          "3769:     CASE_OP(LOOK_BEHIND_NOT_START)",
          "3772:       q = (UChar* )ONIGENC_STEP_BACK(encode, str, s, (int )tlen);",
          "3773:       if (IS_NULL(q)) {",
          "",
          "[Removed Lines]",
          "3763:       GET_LENGTH_INC(tlen, p);",
          "3770:       GET_RELADDR_INC(addr, p);",
          "3771:       GET_LENGTH_INC(tlen, p);",
          "",
          "[Added Lines]",
          "3853:       INC_OP;",
          "3858:       INC_OP;",
          "3862:       tlen = p->look_behind.len;",
          "3866:       INC_OP;",
          "3870:       addr = p->look_behind_not_start.addr;",
          "3871:       tlen = p->look_behind_not_start.len;",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "3780:         STACK_PUSH_ALT_LOOK_BEHIND_NOT(p + addr, s, sprev);",
          "3781:         s = q;",
          "3782:         sprev = (UChar* )onigenc_get_prev_char_head(encode, str, s);",
          "3783:       }",
          "3784:       JUMP_OUT;",
          "3786:     CASE_OP(LOOK_BEHIND_NOT_END)",
          "3787:       STACK_POP_TIL_ALT_LOOK_BEHIND_NOT;",
          "3788:       goto fail;",
          "3790: #ifdef USE_CALL",
          "3791:     CASE_OP(CALL)",
          "3795:       JUMP_OUT;",
          "3797:     CASE_OP(RETURN)",
          "",
          "[Removed Lines]",
          "3792:       GET_ABSADDR_INC(addr, p);",
          "3793:       STACK_PUSH_CALL_FRAME(p);",
          "3794:       p = reg->p + addr;",
          "",
          "[Added Lines]",
          "3883:         INC_OP;",
          "3889:       INC_OP;",
          "3894:       addr = p->call.addr;",
          "3895:       INC_OP; STACK_PUSH_CALL_FRAME(p);",
          "3896:       p = reg->ops + addr;",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "3803:     CASE_OP(PUSH_SAVE_VAL)",
          "3804:       {",
          "3805:         SaveType type;",
          "3808:         switch ((enum SaveType )type) {",
          "3809:         case SAVE_KEEP:",
          "3810:           STACK_PUSH_SAVE_VAL(mem, type, s);",
          "",
          "[Removed Lines]",
          "3806:         GET_SAVE_TYPE_INC(type, p);",
          "",
          "[Added Lines]",
          "3909:         type = p->push_save_val.type;",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "3819:           break;",
          "3820:         }",
          "3821:       }",
          "3822:       JUMP_OUT;",
          "3824:     CASE_OP(UPDATE_VAR)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3925:       INC_OP;",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "3826:         UpdateVarType type;",
          "3827:         enum SaveType save_type;",
          "3831:         switch ((enum UpdateVarType )type) {",
          "3832:         case UPDATE_VAR_KEEP_FROM_STACK_LAST:",
          "3833:           STACK_GET_SAVE_VAL_TYPE_LAST(SAVE_KEEP, keep);",
          "",
          "[Removed Lines]",
          "3829:         GET_UPDATE_VAR_TYPE_INC(type, p);",
          "",
          "[Added Lines]",
          "3933:         type = p->update_var.type;",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "3849:           break;",
          "3850:         }",
          "3851:       }",
          "3852:       JUMP_OUT;",
          "3854: #ifdef USE_CALLOUT",
          "3855:     CASE_OP(CALLOUT_CONTENTS)",
          "3856:       of = ONIG_CALLOUT_OF_CONTENTS;",
          "3857:       goto callout_common_entry;",
          "3858:       BREAK_OUT;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3957:       INC_OP;",
          "3963:       mem = p->callout_contents.num;",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "3861:       {",
          "3862:         int call_result;",
          "3863:         int name_id;",
          "3865:         int in;",
          "3866:         CalloutListEntry* e;",
          "3867:         OnigCalloutFunc func;",
          "3868:         OnigCalloutArgs args;",
          "3870:         of = ONIG_CALLOUT_OF_NAME;",
          "3873:       callout_common_entry:",
          "3876:         in = e->in;",
          "3877:         if (of == ONIG_CALLOUT_OF_NAME) {",
          "3879:         }",
          "3880:         else {",
          "3881:           name_id = ONIG_NON_NAME_ID;",
          "",
          "[Removed Lines]",
          "3864:         int num;",
          "3871:         GET_MEMNUM_INC(name_id, p);",
          "3874:         GET_MEMNUM_INC(num, p);",
          "3875:         e = onig_reg_callout_list_at(reg, num);",
          "3878:           func = onig_get_callout_start_func(reg, num);",
          "",
          "[Added Lines]",
          "3977:         name_id = p->callout_name.id;",
          "3978:         mem     = p->callout_name.num;",
          "3981:         e = onig_reg_callout_list_at(reg, mem);",
          "3984:           func = onig_get_callout_start_func(reg, mem);",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "3885:         if (IS_NOT_NULL(func) && (in & ONIG_CALLOUT_IN_PROGRESS) != 0) {",
          "3886:           CALLOUT_BODY(func, ONIG_CALLOUT_IN_PROGRESS, name_id,",
          "3888:           switch (call_result) {",
          "3889:           case ONIG_CALLOUT_FAIL:",
          "3890:             goto fail;",
          "",
          "[Removed Lines]",
          "3887:                        num, msa->mp->callout_user_data, args, call_result);",
          "",
          "[Added Lines]",
          "3993:                        (int )mem, msa->mp->callout_user_data, args, call_result);",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "3906:           if ((in & ONIG_CALLOUT_IN_RETRACTION) != 0) {",
          "3907:             if (of == ONIG_CALLOUT_OF_NAME) {",
          "3908:               if (IS_NOT_NULL(func)) {",
          "3910:               }",
          "3911:             }",
          "3912:             else {",
          "3913:               func = msa->mp->retraction_callout_of_contents;",
          "3914:               if (IS_NOT_NULL(func)) {",
          "3916:               }",
          "3917:             }",
          "3918:           }",
          "3919:         }",
          "3920:       }",
          "3921:       JUMP_OUT;",
          "3922: #endif",
          "",
          "[Removed Lines]",
          "3909:                 STACK_PUSH_CALLOUT_NAME(name_id, num, func);",
          "3915:                 STACK_PUSH_CALLOUT_CONTENTS(num, func);",
          "",
          "[Added Lines]",
          "4015:                 STACK_PUSH_CALLOUT_NAME(name_id, mem, func);",
          "4021:                 STACK_PUSH_CALLOUT_CONTENTS(mem, func);",
          "4027:       INC_OP;",
          "",
          "---------------"
        ],
        "src/regint.h||src/regint.h": [
          "File: src/regint.h -> src/regint.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "33: #define ONIG_DEBUG_PARSE",
          "34: #define ONIG_DEBUG_COMPILE",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "653: #define SIZE_OP_ANYCHAR_STAR            SIZE_OPCODE",
          "654: #define SIZE_OP_ANYCHAR_STAR_PEEK_NEXT (SIZE_OPCODE + 1)",
          "655: #define SIZE_OP_JUMP                   (SIZE_OPCODE + SIZE_RELADDR)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "653: #if 0",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "689: #define SIZE_OP_CALLOUT_NAME           (SIZE_OPCODE + SIZE_MEMNUM + SIZE_MEMNUM)",
          "690: #endif",
          "692: #define MC_ESC(syn)               (syn)->meta_char_table.esc",
          "693: #define MC_ANYCHAR(syn)           (syn)->meta_char_table.anychar",
          "694: #define MC_ANYTIME(syn)           (syn)->meta_char_table.anytime",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "696: #define SIZE_INC_OP                     1",
          "698: #define SIZE_OP_ANYCHAR_STAR            1",
          "699: #define SIZE_OP_ANYCHAR_STAR_PEEK_NEXT  1",
          "700: #define SIZE_OP_JUMP                    1",
          "701: #define SIZE_OP_PUSH                    1",
          "702: #define SIZE_OP_PUSH_SUPER              1",
          "703: #define SIZE_OP_POP_OUT                 1",
          "704: #define SIZE_OP_PUSH_OR_JUMP_EXACT1     1",
          "705: #define SIZE_OP_PUSH_IF_PEEK_NEXT       1",
          "706: #define SIZE_OP_REPEAT                  1",
          "707: #define SIZE_OP_REPEAT_INC              1",
          "708: #define SIZE_OP_REPEAT_INC_NG           1",
          "709: #define SIZE_OP_WORD_BOUNDARY           1",
          "710: #define SIZE_OP_PREC_READ_START         1",
          "711: #define SIZE_OP_PREC_READ_NOT_START     1",
          "712: #define SIZE_OP_PREC_READ_END           1",
          "713: #define SIZE_OP_PREC_READ_NOT_END       1",
          "714: #define SIZE_OP_BACKREF                 1",
          "715: #define SIZE_OP_FAIL                    1",
          "716: #define SIZE_OP_MEMORY_START            1",
          "717: #define SIZE_OP_MEMORY_START_PUSH       1",
          "718: #define SIZE_OP_MEMORY_END_PUSH         1",
          "719: #define SIZE_OP_MEMORY_END_PUSH_REC     1",
          "720: #define SIZE_OP_MEMORY_END              1",
          "721: #define SIZE_OP_MEMORY_END_REC          1",
          "722: #define SIZE_OP_ATOMIC_START            1",
          "723: #define SIZE_OP_ATOMIC_END              1",
          "724: #define SIZE_OP_EMPTY_CHECK_START       1",
          "725: #define SIZE_OP_EMPTY_CHECK_END         1",
          "726: #define SIZE_OP_LOOK_BEHIND             1",
          "727: #define SIZE_OP_LOOK_BEHIND_NOT_START   1",
          "728: #define SIZE_OP_LOOK_BEHIND_NOT_END     1",
          "729: #define SIZE_OP_CALL                    1",
          "730: #define SIZE_OP_RETURN                  1",
          "731: #define SIZE_OP_PUSH_SAVE_VAL           1",
          "732: #define SIZE_OP_UPDATE_VAR              1",
          "734: #ifdef USE_CALLOUT",
          "735: #define SIZE_OP_CALLOUT_CONTENTS        1",
          "736: #define SIZE_OP_CALLOUT_NAME            1",
          "737: #endif",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "741: #define IS_NCCLASS_NOT(nd)      IS_NCCLASS_FLAG_ON(nd, FLAG_NCCLASS_NOT)",
          "744: typedef struct {",
          "745:   const UChar* pattern;",
          "746:   const UChar* pattern_end;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "793: typedef struct {",
          "794:   enum OpCode opcode;",
          "795:   union {",
          "796:     struct {",
          "797:       UChar* s;",
          "798:     } exact;",
          "799:     struct {",
          "800:       UChar* s;",
          "803:     struct {",
          "804:       UChar* s;",
          "808:     struct {",
          "809:       BitSet bs;",
          "810:     } cclass;",
          "811:     struct {",
          "812:       void*  mb;",
          "813:     } cclass_mb;",
          "814:     struct {",
          "816:       BitSet bs;",
          "817:     } cclass_mix;",
          "818:     struct {",
          "819:       UChar c;",
          "820:     } anychar_star_peek_next;",
          "821:     struct {",
          "822:       ModeType mode;",
          "824:     struct {",
          "825:       int num;",
          "826:       union {",
          "829:       };",
          "830:       int nest_level;",
          "831:       OnigOptionType options;",
          "833:     struct {",
          "834:       MemNumType n1;",
          "836:     struct {",
          "837:       MemNumType num;",
          "839:     struct {",
          "840:       MemNumType num;",
          "842:     struct {",
          "843:       RelAddrType addr;",
          "844:     } jump;",
          "845:     struct {",
          "846:       RelAddrType addr;",
          "847:     } push;",
          "848:     struct {",
          "849:       RelAddrType addr;",
          "850:       UChar c;",
          "851:     } push_or_jump_exact1;",
          "852:     struct {",
          "853:       RelAddrType addr;",
          "854:       UChar c;",
          "855:     } push_if_peek_next;",
          "856:     struct {",
          "857:       MemNumType  id;",
          "858:       RelAddrType addr;",
          "860:     struct {",
          "861:       MemNumType  id;",
          "863:     struct {",
          "864:       MemNumType mem;",
          "865:     } empty_check_start;",
          "866:     struct {",
          "867:       MemNumType mem;",
          "869:     struct {",
          "870:       RelAddrType addr;",
          "871:     } prec_read_not_start;",
          "872:     struct {",
          "873:       LengthType len;",
          "874:     } look_behind;",
          "875:     struct {",
          "876:       LengthType  len;",
          "877:       RelAddrType addr;",
          "878:     } look_behind_not_start;",
          "879:     struct {",
          "880:       AbsAddrType addr;",
          "881:     } call;",
          "882:     struct {",
          "883:       SaveType   type;",
          "884:       MemNumType id;",
          "885:     } push_save_val;",
          "886:     struct {",
          "887:       UpdateVarType type;",
          "888:       MemNumType id;",
          "889:     } update_var;",
          "890: #ifdef USE_CALLOUT",
          "891:     struct {",
          "892:       MemNumType num;",
          "893:     } callout_contents;",
          "894:     struct {",
          "895:       MemNumType num;",
          "896:       MemNumType id;",
          "897:     } callout_name;",
          "898: #endif",
          "900:   };",
          "901: } Operation;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "755: struct re_pattern_buffer {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "916: #if 0",
          "920: #else",
          "921:   Operation*   ops;",
          "922:   Operation*   ops_curr;",
          "925: #endif",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "791:   RegexExt*      extp;",
          "792: };",
          "795: extern void onig_add_end_call(void (*func)(void));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "960: #define COP(reg)            ((reg)->ops_curr)",
          "961: #define COP_CURR_OFFSET(reg)  ((reg)->ops_used - 1)",
          "962: #define COP_CURR_OFFSET_BYTES(reg, p)  \\",
          "963:   ((int )((void* )(&((reg)->ops_curr->p)) - (void* )((reg)->ops)))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c782579c211473c8107d3a9c54a8b51def5f6705",
      "candidate_info": {
        "commit_hash": "c782579c211473c8107d3a9c54a8b51def5f6705",
        "repo": "kkos/oniguruma",
        "commit_url": "https://github.com/kkos/oniguruma/commit/c782579c211473c8107d3a9c54a8b51def5f6705",
        "files": [
          "src/regcomp.c",
          "src/regexec.c",
          "src/regint.h"
        ],
        "message": "refactoring",
        "before_after_code_files": [
          "src/regcomp.c||src/regcomp.c",
          "src/regexec.c||src/regexec.c",
          "src/regint.h||src/regint.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/regcomp.c||src/regcomp.c"
          ],
          "candidate": [
            "src/regcomp.c||src/regcomp.c"
          ]
        }
      },
      "candidate_diff": {
        "src/regcomp.c||src/regcomp.c": [
          "File: src/regcomp.c -> src/regcomp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1654:       len = v + OPSIZE_PUSH + tlen + OPSIZE_POP + OPSIZE_JUMP;",
          "1655:     }",
          "1656:     else {",
          "1658:     }",
          "1659:     break;",
          "",
          "[Removed Lines]",
          "1657:       len = OPSIZE_MARK + tlen + OPSIZE_CUT;",
          "",
          "[Added Lines]",
          "1657:       len = OPSIZE_MARK + tlen + OPSIZE_CUT_TO_MARK;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1667:       len = compile_length_tree(cond, reg);",
          "1668:       if (len < 0) return len;",
          "1671:       if (IS_NOT_NULL(Then)) {",
          "1672:         tlen = compile_length_tree(Then, reg);",
          "",
          "[Removed Lines]",
          "1669:       len += OPSIZE_PUSH + OPSIZE_MARK + OPSIZE_CUT;",
          "",
          "[Added Lines]",
          "1669:       len += OPSIZE_PUSH + OPSIZE_MARK + OPSIZE_CUT_TO_MARK;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1674:         len += tlen;",
          "1675:       }",
          "1679:       if (IS_NOT_NULL(Else)) {",
          "1680:         tlen = compile_length_tree(Else, reg);",
          "",
          "[Removed Lines]",
          "1677:       len += OPSIZE_JUMP + OPSIZE_CUT;",
          "",
          "[Added Lines]",
          "1677:       len += OPSIZE_JUMP + OPSIZE_CUT_TO_MARK;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1822:       r = compile_tree(NODE_BAG_BODY(node), reg, env);",
          "1823:       if (r != 0) return r;",
          "1825:       if (r != 0) return r;",
          "1828:     }",
          "1829:     break;",
          "",
          "[Removed Lines]",
          "1824:       r = add_op(reg, OP_CUT);",
          "1826:       COP(reg)->cut.id = mid;",
          "1827:       COP(reg)->cut.restore_pos = 0;",
          "",
          "[Added Lines]",
          "1824:       r = add_op(reg, OP_CUT_TO_MARK);",
          "1826:       COP(reg)->cut_to_mark.id = mid;",
          "1827:       COP(reg)->cut_to_mark.restore_pos = 0;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1852:       else",
          "1853:         then_len = 0;",
          "1857:       r = add_op(reg, OP_PUSH);",
          "1858:       if (r != 0) return r;",
          "",
          "[Removed Lines]",
          "1855:       jump_len = cond_len + then_len + OPSIZE_CUT + OPSIZE_JUMP;",
          "",
          "[Added Lines]",
          "1855:       jump_len = cond_len + then_len + OPSIZE_CUT_TO_MARK + OPSIZE_JUMP;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1861:       r = compile_tree(cond, reg, env);",
          "1862:       if (r != 0) return r;",
          "1864:       if (r != 0) return r;",
          "1868:       if (IS_NOT_NULL(Then)) {",
          "1869:         r = compile_tree(Then, reg, env);",
          "",
          "[Removed Lines]",
          "1863:       r = add_op(reg, OP_CUT);",
          "1865:       COP(reg)->cut.id = mid;",
          "1866:       COP(reg)->cut.restore_pos = 0;",
          "",
          "[Added Lines]",
          "1863:       r = add_op(reg, OP_CUT_TO_MARK);",
          "1865:       COP(reg)->cut_to_mark.id = mid;",
          "1866:       COP(reg)->cut_to_mark.restore_pos = 0;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1880:       r = add_op(reg, OP_JUMP);",
          "1881:       if (r != 0) return r;",
          "1885:       if (r != 0) return r;",
          "1889:       if (IS_NOT_NULL(Else)) {",
          "1890:         r = compile_tree(Else, reg, env);",
          "",
          "[Removed Lines]",
          "1882:       COP(reg)->jump.addr = OPSIZE_CUT + else_len + SIZE_INC;",
          "1884:       r = add_op(reg, OP_CUT);",
          "1886:       COP(reg)->cut.id = mid;",
          "1887:       COP(reg)->cut.restore_pos = 0;",
          "",
          "[Added Lines]",
          "1882:       COP(reg)->jump.addr = OPSIZE_CUT_TO_MARK + else_len + SIZE_INC;",
          "1884:       r = add_op(reg, OP_CUT_TO_MARK);",
          "1886:       COP(reg)->cut_to_mark.id = mid;",
          "1887:       COP(reg)->cut_to_mark.restore_pos = 0;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1910:   switch (node->type) {",
          "1911:   case ANCR_PREC_READ:",
          "1913:     break;",
          "1914:   case ANCR_PREC_READ_NOT:",
          "1915:     len = OPSIZE_PUSH + OPSIZE_MARK + tlen + OPSIZE_POP_TO_MARK + OPSIZE_POP + OPSIZE_FAIL;",
          "",
          "[Removed Lines]",
          "1912:     len = OPSIZE_MARK + tlen + OPSIZE_CUT;",
          "",
          "[Added Lines]",
          "1912:     len = OPSIZE_MARK + tlen + OPSIZE_CUT_TO_MARK;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2010:       r = compile_tree(NODE_ANCHOR_BODY(node), reg, env);",
          "2011:       if (r != 0) return r;",
          "2014:       if (r != 0) return r;",
          "2017:     }",
          "2018:     break;",
          "",
          "[Removed Lines]",
          "2013:       r = add_op(reg, OP_CUT);",
          "2015:       COP(reg)->cut.id = mid;",
          "2016:       COP(reg)->cut.restore_pos = TRUE;",
          "",
          "[Added Lines]",
          "2013:       r = add_op(reg, OP_CUT_TO_MARK);",
          "2015:       COP(reg)->cut_to_mark.id = mid;",
          "2016:       COP(reg)->cut_to_mark.restore_pos = TRUE;",
          "",
          "---------------"
        ],
        "src/regexec.c||src/regexec.c": [
          "File: src/regexec.c -> src/regexec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "247:   { OP_LOOK_BEHIND,           \"look-behind\"},",
          "248:   { OP_LOOK_BEHIND_NOT_START, \"look-behind-not-start\"},",
          "249:   { OP_LOOK_BEHIND_NOT_END,   \"look-behind-not-end\"},",
          "251:   { OP_MARK,                  \"mark\"},",
          "252:   { OP_SAVE_VAL,              \"save-val\"},",
          "253:   { OP_UPDATE_VAR,            \"update-var\"},",
          "",
          "[Removed Lines]",
          "250:   { OP_CUT,                   \"cut\"},",
          "",
          "[Added Lines]",
          "250:   { OP_CUT_TO_MARK,           \"cut-to-mark\"},",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2646:   &&L_LOOK_BEHIND,",
          "2647:   &&L_LOOK_BEHIND_NOT_START,",
          "2648:   &&L_LOOK_BEHIND_NOT_END,",
          "2650:   &&L_MARK,",
          "2651:   &&L_SAVE_VAL,",
          "2652:   &&L_UPDATE_VAR,",
          "",
          "[Removed Lines]",
          "2649:   &&L_CUT,",
          "",
          "[Added Lines]",
          "2649:   &&L_CUT_TO_MARK,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3897:       JUMP_OUT;",
          "3898: #endif",
          "3902:       STACK_TO_VOID_TO_MARK(stkp, mem);",
          "3904:         s     = stkp->u.val.v;",
          "3905:         sprev = stkp->u.val.v2;",
          "3906:       }",
          "",
          "[Removed Lines]",
          "3900:     CASE_OP(CUT)",
          "3903:       if (p->cut.restore_pos != 0) {",
          "",
          "[Added Lines]",
          "3900:     CASE_OP(CUT_TO_MARK)",
          "3903:       if (p->cut_to_mark.restore_pos != 0) {",
          "",
          "---------------"
        ],
        "src/regint.h||src/regint.h": [
          "File: src/regint.h -> src/regint.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "553:   OP_MARK,",
          "554:   OP_SAVE_VAL,",
          "555:   OP_UPDATE_VAR,",
          "",
          "[Removed Lines]",
          "552:   OP_CUT,",
          "",
          "[Added Lines]",
          "552:   OP_CUT_TO_MARK,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "644: #define OPSIZE_LOOK_BEHIND_NOT_END     1",
          "645: #define OPSIZE_CALL                    1",
          "646: #define OPSIZE_RETURN                  1",
          "648: #define OPSIZE_MARK                    1",
          "649: #define OPSIZE_SAVE_VAL                1",
          "650: #define OPSIZE_UPDATE_VAR              1",
          "",
          "[Removed Lines]",
          "647: #define OPSIZE_CUT                     1",
          "",
          "[Added Lines]",
          "647: #define OPSIZE_CUT_TO_MARK             1",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "809:     struct {",
          "810:       MemNumType id;",
          "813:     struct {",
          "814:       MemNumType id;",
          "",
          "[Removed Lines]",
          "812:     } cut;",
          "",
          "[Added Lines]",
          "812:     } cut_to_mark;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
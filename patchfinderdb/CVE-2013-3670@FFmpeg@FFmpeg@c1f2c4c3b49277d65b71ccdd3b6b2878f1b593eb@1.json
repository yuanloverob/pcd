{
  "cve_id": "CVE-2013-3670",
  "cve_desc": "The rle_unpack function in vmdav.c in libavcodec in FFmpeg git 20130328 through 20130501 does not properly use the bytestream2 API, which allows remote attackers to cause a denial of service (out-of-bounds array access and application crash) via crafted RLE data.  NOTE: the vendor has listed this as an issue fixed in 1.2.1, but the issue is actually in new code that was not shipped with the 1.2.1 release or any earlier release.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "c1f2c4c3b49277d65b71ccdd3b6b2878f1b593eb",
  "patch_info": {
    "commit_hash": "c1f2c4c3b49277d65b71ccdd3b6b2878f1b593eb",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/c1f2c4c3b49277d65b71ccdd3b6b2878f1b593eb",
    "files": [
      "libavcodec/vmdav.c"
    ],
    "message": "vmdav: Try to fix unpack_rle()\n\nThis fixes out of array accesses\nThe code prior to this commit could not have worked, thus obviously\nwas untested. I was also not able to find a valid sample that uses this\ncode.\nThis fix is thus only based on the description of the format\n\nIf someone has a sample that uses unpack_rle(), please mail me.\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
    "before_after_code_files": [
      "libavcodec/vmdav.c||libavcodec/vmdav.c"
    ]
  },
  "patch_diff": {
    "libavcodec/vmdav.c||libavcodec/vmdav.c": [
      "File: libavcodec/vmdav.c -> libavcodec/vmdav.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "151:                       int src_count, int src_size, int dest_len)",
      "152: {",
      "153:     unsigned char *pd;",
      "155:     unsigned char *dest_end = dest + dest_len;",
      "156:     GetByteContext gb;",
      "",
      "[Removed Lines]",
      "154:     int i, l;",
      "",
      "[Added Lines]",
      "154:     int i, j, l;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "176:             bytestream2_get_bufferu(&gb, pd, l);",
      "177:             pd += l;",
      "178:         } else {",
      "180:                 return bytestream2_tell(&gb);",
      "184:             }",
      "186:         }",
      "187:         i += l;",
      "188:     } while (i < src_count);",
      "",
      "[Removed Lines]",
      "179:             if (dest_end - pd < i || bytestream2_get_bytes_left(&gb) < 2)",
      "181:             for (i = 0; i < l; i++) {",
      "185:             bytestream2_skip(&gb, 2);",
      "",
      "[Added Lines]",
      "179:             int ps[2];",
      "180:             if (dest_end - pd < 2*l || bytestream2_get_bytes_left(&gb) < 2)",
      "182:             ps[0] = bytestream2_get_byteu(&gb);",
      "183:             ps[1] = bytestream2_get_byteu(&gb);",
      "184:             for (j = 0; j < l; j++) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4749e074987d45cb98935a683a7ee8e1ee376d86",
      "candidate_info": {
        "commit_hash": "4749e074987d45cb98935a683a7ee8e1ee376d86",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/4749e074987d45cb98935a683a7ee8e1ee376d86",
        "files": [
          "libavcodec/vmdav.c"
        ],
        "message": "Fix out of bound reads in rle_unpack() of vmd video decoder.\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavcodec/vmdav.c||libavcodec/vmdav.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/vmdav.c||libavcodec/vmdav.c"
          ],
          "candidate": [
            "libavcodec/vmdav.c||libavcodec/vmdav.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/vmdav.c||libavcodec/vmdav.c": [
          "File: libavcodec/vmdav.c -> libavcodec/vmdav.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "153:     }",
          "154: }",
          "158: {",
          "159:     const unsigned char *ps;",
          "160:     unsigned char *pd;",
          "161:     int i, l;",
          "162:     unsigned char *dest_end = dest + dest_len;",
          "164:     ps = src;",
          "165:     pd = dest;",
          "170:     i = 0;",
          "171:     do {",
          "172:         l = *ps++;",
          "173:         if (l & 0x80) {",
          "174:             l = (l & 0x7F) * 2;",
          "176:                 return ps - src;",
          "177:             memcpy(pd, ps, l);",
          "178:             ps += l;",
          "179:             pd += l;",
          "180:         } else {",
          "182:                 return ps - src;",
          "183:             for (i = 0; i < l; i++) {",
          "",
          "[Removed Lines]",
          "156: static int rle_unpack(const unsigned char *src, unsigned char *dest,",
          "157:     int src_len, int dest_len)",
          "166:     if (src_len & 1)",
          "169:     src_len >>= 1;",
          "175:             if (pd + l > dest_end)",
          "181:             if (pd + i > dest_end)",
          "",
          "[Added Lines]",
          "156: static int rle_unpack(const unsigned char *src, int src_len, int src_count,",
          "157:                       unsigned char *dest, int dest_len)",
          "160:     const unsigned char *ps_end;",
          "166:     ps_end = src + src_len;",
          "168:     if (src_count & 1) {",
          "169:         if (ps_end - ps < 1)",
          "170:             return 0;",
          "172:     }",
          "174:     src_count >>= 1;",
          "177:         if (ps_end - ps < 1)",
          "178:             break;",
          "182:             if (pd + l > dest_end || ps_end - ps < l)",
          "188:             if (pd + i > dest_end || ps_end - ps < 2)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "187:             ps += 2;",
          "188:         }",
          "189:         i += l;",
          "192:     return ps - src;",
          "193: }",
          "",
          "[Removed Lines]",
          "190:     } while (i < src_len);",
          "",
          "[Added Lines]",
          "197:     } while (i < src_count);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "330:                         if (pb_end - pb < 1)",
          "331:                             return;",
          "332:                         if (*pb++ == 0xFF)",
          "334:                         else {",
          "335:                         if (pb_end - pb < len)",
          "336:                             return;",
          "",
          "[Removed Lines]",
          "333:                             len = rle_unpack(pb, &dp[ofs], len, frame_width - ofs);",
          "",
          "[Added Lines]",
          "340:                             len = rle_unpack(pb, pb_end - pb, len, &dp[ofs], frame_width - ofs);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0afcf97e1ece51d29bb791698b00cd1b7ba97dcf",
      "candidate_info": {
        "commit_hash": "0afcf97e1ece51d29bb791698b00cd1b7ba97dcf",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/0afcf97e1ece51d29bb791698b00cd1b7ba97dcf",
        "files": [
          "libavcodec/vmdav.c"
        ],
        "message": "vmdav: convert to bytestream2\n\nSigned-off-by: Anton Khirnov <anton@khirnov.net>",
        "before_after_code_files": [
          "libavcodec/vmdav.c||libavcodec/vmdav.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/vmdav.c||libavcodec/vmdav.c"
          ],
          "candidate": [
            "libavcodec/vmdav.c||libavcodec/vmdav.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/vmdav.c||libavcodec/vmdav.c": [
          "File: libavcodec/vmdav.c -> libavcodec/vmdav.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "48: #include \"libavutil/intreadwrite.h\"",
          "49: #include \"avcodec.h\"",
          "50: #include \"internal.h\"",
          "52: #define VMD_HEADER_SIZE 0x330",
          "53: #define PALETTE_COUNT 256",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "51: #include \"bytestream.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "77: static void lz_unpack(const unsigned char *src, int src_len,",
          "78:                       unsigned char *dest, int dest_len)",
          "79: {",
          "82:     unsigned char *d;",
          "83:     unsigned char *d_end;",
          "84:     unsigned char queue[QUEUE_SIZE];",
          "",
          "[Removed Lines]",
          "80:     const unsigned char *s;",
          "81:     unsigned int s_len;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "89:     unsigned int speclen;",
          "90:     unsigned char tag;",
          "91:     unsigned int i, j;",
          "95:     d = dest;",
          "96:     d_end = d + dest_len;",
          "99:     memset(queue, 0x20, QUEUE_SIZE);",
          "101:         return;",
          "104:         qpos = 0x111;",
          "105:         speclen = 0xF + 3;",
          "106:     } else {",
          "",
          "[Removed Lines]",
          "93:     s = src;",
          "94:     s_len = src_len;",
          "97:     dataleft = AV_RL32(s);",
          "98:     s += 4; s_len -= 4;",
          "100:     if (s_len < 4)",
          "102:     if (AV_RL32(s) == 0x56781234) {",
          "103:         s += 4; s_len -= 4;",
          "",
          "[Added Lines]",
          "91:     GetByteContext gb;",
          "93:     bytestream2_init(&gb, src, src_len);",
          "96:     dataleft = bytestream2_get_le32(&gb);",
          "98:     if (bytestream2_get_bytes_left(&gb) < 4)",
          "100:     if (bytestream2_peek_le32(&gb) == 0x56781234) {",
          "101:         bytestream2_get_le32(&gb);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "109:     }",
          "113:         if ((tag == 0xFF) && (dataleft > 8)) {",
          "115:                 return;",
          "116:             for (i = 0; i < 8; i++) {",
          "118:                 qpos &= QUEUE_MASK;",
          "119:             }",
          "121:             dataleft -= 8;",
          "122:         } else {",
          "123:             for (i = 0; i < 8; i++) {",
          "124:                 if (dataleft == 0)",
          "125:                     break;",
          "126:                 if (tag & 0x01) {",
          "128:                         return;",
          "130:                     qpos &= QUEUE_MASK;",
          "131:                     dataleft--;",
          "133:                 } else {",
          "140:                     if (chainlen == speclen) {",
          "145:                     }",
          "146:                     if (d + chainlen > d_end)",
          "147:                         return;",
          "",
          "[Removed Lines]",
          "111:     while (dataleft > 0 && s_len > 0) {",
          "112:         tag = *s++; s_len--;",
          "114:             if (d + 8 > d_end || s_len < 8)",
          "117:                 queue[qpos++] = *d++ = *s++;",
          "120:             s_len -= 8;",
          "127:                     if (d + 1 > d_end || s_len < 1)",
          "129:                     queue[qpos++] = *d++ = *s++;",
          "132:                     s_len--;",
          "134:                     if (s_len < 2)",
          "135:                         return;",
          "136:                     chainofs = *s++;",
          "137:                     chainofs |= ((*s & 0xF0) << 4);",
          "138:                     chainlen = (*s++ & 0x0F) + 3;",
          "139:                     s_len -= 2;",
          "141:                         if (s_len < 1)",
          "142:                             return;",
          "143:                         chainlen = *s++ + 0xF + 3;",
          "144:                         s_len--;",
          "",
          "[Added Lines]",
          "109:     while (dataleft > 0 && bytestream2_get_bytes_left(&gb) > 0) {",
          "110:         tag = bytestream2_get_byteu(&gb);",
          "112:             if (d + 8 > d_end || bytestream2_get_bytes_left(&gb) < 8)",
          "115:                 queue[qpos++] = *d++ = bytestream2_get_byteu(&gb);",
          "124:                     if (d + 1 > d_end || bytestream2_get_bytes_left(&gb) < 1)",
          "126:                     queue[qpos++] = *d++ = bytestream2_get_byte(&gb);",
          "130:                     chainofs = bytestream2_get_byte(&gb);",
          "131:                     chainofs |= ((bytestream2_peek_byte(&gb) & 0xF0) << 4);",
          "132:                     chainlen = (bytestream2_get_byte(&gb) & 0x0F) + 3;",
          "134:                         chainlen = bytestream2_get_byte(&gb) + 0xF + 3;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "161: static int rle_unpack(const unsigned char *src, unsigned char *dest,",
          "162:     int src_count, int src_size, int dest_len)",
          "163: {",
          "165:     unsigned char *pd;",
          "166:     int i, l;",
          "167:     unsigned char *dest_end = dest + dest_len;",
          "170:     pd = dest;",
          "171:     if (src_count & 1) {",
          "173:             return 0;",
          "176:     }",
          "178:     src_count >>= 1;",
          "179:     i = 0;",
          "180:     do {",
          "182:             break;",
          "185:         if (l & 0x80) {",
          "186:             l = (l & 0x7F) * 2;",
          "192:             pd += l;",
          "193:         } else {",
          "196:             for (i = 0; i < l; i++) {",
          "199:             }",
          "202:         }",
          "203:         i += l;",
          "204:     } while (i < src_count);",
          "207: }",
          "209: static void vmd_decode(VmdVideoContext *s, AVFrame *frame)",
          "",
          "[Removed Lines]",
          "164:     const unsigned char *ps;",
          "169:     ps = src;",
          "172:         if (src_size < 1)",
          "175:         src_size--;",
          "181:         if (src_size < 1)",
          "183:         l = *ps++;",
          "184:         src_size--;",
          "187:             if (pd + l > dest_end || src_size < l)",
          "188:                 return ps - src;",
          "189:             memcpy(pd, ps, l);",
          "190:             ps += l;",
          "191:             src_size -= l;",
          "194:             if (pd + i > dest_end || src_size < 2)",
          "195:                 return ps - src;",
          "200:             ps += 2;",
          "201:             src_size -= 2;",
          "206:     return ps - src;",
          "",
          "[Added Lines]",
          "157:     GetByteContext gb;",
          "159:     bytestream2_init(&gb, src, src_size);",
          "162:         if (bytestream2_get_bytes_left(&gb) < 1)",
          "170:         if (bytestream2_get_bytes_left(&gb) < 1)",
          "172:         l = bytestream2_get_byteu(&gb);",
          "175:             if (pd + l > dest_end || bytestream2_get_bytes_left(&gb) < l)",
          "176:                 return bytestream2_tell(&gb);",
          "177:             bytestream2_get_buffer(&gb, pd, l);",
          "180:             if (pd + i > dest_end || bytestream2_get_bytes_left(&gb) < 2)",
          "181:                 return bytestream2_tell(&gb);",
          "186:             bytestream2_skip(&gb, 2);",
          "191:     return bytestream2_tell(&gb);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "212:     unsigned int *palette32;",
          "213:     unsigned char r, g, b;",
          "220:     unsigned char meth;",
          "",
          "[Removed Lines]",
          "216:     const unsigned char *p = s->buf + 16;",
          "218:     const unsigned char *pb;",
          "219:     unsigned int pb_size;",
          "",
          "[Added Lines]",
          "200:     GetByteContext gb;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "261:     }",
          "264:     if (s->buf[15] & 0x02) {",
          "266:         palette32 = (unsigned int *)s->palette;",
          "272:         }",
          "273:         s->size -= (256 * 3 + 2);",
          "274:     }",
          "275:     if (s->size > 0) {",
          "280:             return;",
          "282:         if (meth & 0x80) {",
          "284:                       s->unpack_buffer, s->unpack_buffer_size);",
          "285:             meth &= 0x7F;",
          "288:         }",
          "290:         dp = &frame->data[0][frame_y * frame->linesize[0] + frame_x];",
          "",
          "[Removed Lines]",
          "265:         p += 2;",
          "267:         for (i = 0; i < PALETTE_COUNT; i++) {",
          "268:             r = *p++ * 4;",
          "269:             g = *p++ * 4;",
          "270:             b = *p++ * 4;",
          "271:             palette32[i] = (r << 16) | (g << 8) | (b);",
          "277:         pb = p;",
          "278:         pb_size = s->buf + s->size - pb;",
          "279:         if (pb_size < 1)",
          "281:         meth = *pb++; pb_size--;",
          "283:             lz_unpack(pb, pb_size,",
          "286:             pb = s->unpack_buffer;",
          "287:             pb_size = s->unpack_buffer_size;",
          "",
          "[Added Lines]",
          "246:     bytestream2_init(&gb, s->buf + 16, s->size - 16);",
          "248:         bytestream2_skip(&gb, 2);",
          "250:         if (bytestream2_get_bytes_left(&gb) >= PALETTE_COUNT * 3) {",
          "251:             for (i = 0; i < PALETTE_COUNT; i++) {",
          "252:                 r = bytestream2_get_byteu(&gb) * 4;",
          "253:                 g = bytestream2_get_byteu(&gb) * 4;",
          "254:                 b = bytestream2_get_byteu(&gb) * 4;",
          "255:                 palette32[i] = (r << 16) | (g << 8) | (b);",
          "256:             }",
          "262:         bytestream2_init(&gb, gb.buffer, s->buf + s->size - gb.buffer);",
          "263:         if (bytestream2_get_bytes_left(&gb) < 1)",
          "265:         meth = bytestream2_get_byteu(&gb);",
          "267:             lz_unpack(gb.buffer, bytestream2_get_bytes_left(&gb),",
          "270:             bytestream2_init(&gb, s->unpack_buffer, s->unpack_buffer_size);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "294:             for (i = 0; i < frame_height; i++) {",
          "295:                 ofs = 0;",
          "296:                 do {",
          "301:                     if (len & 0x80) {",
          "302:                         len = (len & 0x7F) + 1;",
          "304:                             return;",
          "308:                         ofs += len;",
          "309:                     } else {",
          "",
          "[Removed Lines]",
          "297:                     if (pb_size < 1)",
          "298:                         return;",
          "299:                     len = *pb++;",
          "300:                     pb_size--;",
          "303:                         if (ofs + len > frame_width || pb_size < len)",
          "305:                         memcpy(&dp[ofs], pb, len);",
          "306:                         pb += len;",
          "307:                         pb_size -= len;",
          "",
          "[Added Lines]",
          "280:                     len = bytestream2_get_byte(&gb);",
          "283:                         if (ofs + len > frame_width || bytestream2_get_bytes_left(&gb) < len)",
          "285:                         bytestream2_get_buffer(&gb, &dp[ofs], len);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "327:         case 2:",
          "328:             for (i = 0; i < frame_height; i++) {",
          "334:                 dp += frame->linesize[0];",
          "335:                 pp += s->prev_frame.linesize[0];",
          "336:             }",
          "",
          "[Removed Lines]",
          "329:                 if (pb_size < frame_width)",
          "330:                     return;",
          "331:                 memcpy(dp, pb, frame_width);",
          "332:                 pb += frame_width;",
          "333:                 pb_size -= frame_width;",
          "",
          "[Added Lines]",
          "307:                 bytestream2_get_buffer(&gb, dp, frame_width);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "340:             for (i = 0; i < frame_height; i++) {",
          "341:                 ofs = 0;",
          "342:                 do {",
          "347:                     if (len & 0x80) {",
          "348:                         len = (len & 0x7F) + 1;",
          "361:                     } else {",
          "363:                         if (ofs + len + 1 > frame_width || !s->prev_frame.data[0])",
          "",
          "[Removed Lines]",
          "343:                     if (pb_size < 1)",
          "344:                         return;",
          "345:                     len = *pb++;",
          "346:                     pb_size--;",
          "349:                         if (pb_size < 1)",
          "350:                             return;",
          "351:                         if (*pb++ == 0xFF)",
          "352:                             len = rle_unpack(pb, &dp[ofs], len, pb_size, frame_width - ofs);",
          "353:                         else {",
          "354:                             if (pb_size < len)",
          "355:                                 return;",
          "356:                             memcpy(&dp[ofs], pb, len);",
          "357:                         }",
          "358:                         pb += len;",
          "359:                         pb_size -= 1 + len;",
          "360:                         ofs += len;",
          "",
          "[Added Lines]",
          "317:                     len = bytestream2_get_byte(&gb);",
          "320:                         if (bytestream2_get_byte(&gb) == 0xFF)",
          "321:                             len = rle_unpack(gb.buffer, &dp[ofs],",
          "322:                                              len, bytestream2_get_bytes_left(&gb),",
          "323:                                              frame_width - ofs);",
          "324:                         else",
          "325:                             bytestream2_get_buffer(&gb, &dp[ofs], len);",
          "326:                         bytestream2_skip(&gb, len);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "37bdf33cffd2f3bb4d4c07ef38a5649fd980639f",
      "candidate_info": {
        "commit_hash": "37bdf33cffd2f3bb4d4c07ef38a5649fd980639f",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/37bdf33cffd2f3bb4d4c07ef38a5649fd980639f",
        "files": [
          "libavcodec/vmdav.c",
          "tests/fate/filter.mak"
        ],
        "message": "Merge remote-tracking branch 'qatar/master'\n\n* qatar/master:\n  vmdav: convert to bytestream2\n  FATE: add a test for the join filter\n  FATE: add a test for the volume filter\n\nConflicts:\n\tlibavcodec/vmdav.c\n\nMerged-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavcodec/vmdav.c||libavcodec/vmdav.c",
          "tests/fate/filter.mak||tests/fate/filter.mak"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/vmdav.c||libavcodec/vmdav.c"
          ],
          "candidate": [
            "libavcodec/vmdav.c||libavcodec/vmdav.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/vmdav.c||libavcodec/vmdav.c": [
          "File: libavcodec/vmdav.c -> libavcodec/vmdav.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "48: #include \"libavutil/intreadwrite.h\"",
          "49: #include \"avcodec.h\"",
          "50: #include \"internal.h\"",
          "52: #define VMD_HEADER_SIZE 0x330",
          "53: #define PALETTE_COUNT 256",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "51: #include \"bytestream.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "77: static void lz_unpack(const unsigned char *src, int src_len,",
          "78:                       unsigned char *dest, int dest_len)",
          "79: {",
          "82:     unsigned char *d;",
          "83:     unsigned char *d_end;",
          "84:     unsigned char queue[QUEUE_SIZE];",
          "",
          "[Removed Lines]",
          "80:     const unsigned char *s;",
          "81:     const unsigned char *s_end;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "89:     unsigned int speclen;",
          "90:     unsigned char tag;",
          "91:     unsigned int i, j;",
          "95:     d = dest;",
          "96:     d_end = d + dest_len;",
          "102:     memset(queue, 0x20, QUEUE_SIZE);",
          "105:         qpos = 0x111;",
          "106:         speclen = 0xF + 3;",
          "107:     } else {",
          "",
          "[Removed Lines]",
          "93:     s = src;",
          "94:     s_end = src + src_len;",
          "98:     if (s_end - s < 8)",
          "99:         return;",
          "100:     dataleft = AV_RL32(s);",
          "101:     s += 4;",
          "103:     if (AV_RL32(s) == 0x56781234) {",
          "104:         s += 4;",
          "",
          "[Added Lines]",
          "91:     GetByteContext gb;",
          "93:     bytestream2_init(&gb, src, src_len);",
          "96:     dataleft = bytestream2_get_le32(&gb);",
          "98:     if (bytestream2_get_bytes_left(&gb) < 4)",
          "99:         return;",
          "100:     if (bytestream2_peek_le32(&gb) == 0x56781234) {",
          "101:         bytestream2_get_le32(&gb);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "110:     }",
          "114:         if ((tag == 0xFF) && (dataleft > 8)) {",
          "116:                 return;",
          "117:             for (i = 0; i < 8; i++) {",
          "119:                 qpos &= QUEUE_MASK;",
          "120:             }",
          "121:             dataleft -= 8;",
          "",
          "[Removed Lines]",
          "112:     while (s_end - s > 0 && dataleft > 0) {",
          "113:         tag = *s++;",
          "115:             if (d_end - d < 8 || s_end - s < 8)",
          "118:                 queue[qpos++] = *d++ = *s++;",
          "",
          "[Added Lines]",
          "109:     while (dataleft > 0 && bytestream2_get_bytes_left(&gb) > 0) {",
          "110:         tag = bytestream2_get_byteu(&gb);",
          "112:             if (d_end - d < 8 || bytestream2_get_bytes_left(&gb) < 8)",
          "115:                 queue[qpos++] = *d++ = bytestream2_get_byteu(&gb);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "124:                 if (dataleft == 0)",
          "125:                     break;",
          "126:                 if (tag & 0x01) {",
          "128:                         return;",
          "130:                     qpos &= QUEUE_MASK;",
          "131:                     dataleft--;",
          "132:                 } else {",
          "138:                     if (chainlen == speclen) {",
          "142:                     }",
          "143:                     if (d_end - d < chainlen)",
          "144:                         return;",
          "",
          "[Removed Lines]",
          "127:                     if (d_end - d < 1 || s_end - s < 1)",
          "129:                     queue[qpos++] = *d++ = *s++;",
          "133:                     if (s_end - s < 2)",
          "134:                         return;",
          "135:                     chainofs = *s++;",
          "136:                     chainofs |= ((*s & 0xF0) << 4);",
          "137:                     chainlen = (*s++ & 0x0F) + 3;",
          "139:                         if (s_end - s < 1)",
          "140:                             return;",
          "141:                         chainlen = *s++ + 0xF + 3;",
          "",
          "[Added Lines]",
          "124:                     if (d_end - d < 1 || bytestream2_get_bytes_left(&gb) < 1)",
          "126:                     queue[qpos++] = *d++ = bytestream2_get_byte(&gb);",
          "130:                     chainofs = bytestream2_get_byte(&gb);",
          "131:                     chainofs |= ((bytestream2_peek_byte(&gb) & 0xF0) << 4);",
          "132:                     chainlen = (bytestream2_get_byte(&gb) & 0x0F) + 3;",
          "134:                         chainlen = bytestream2_get_byte(&gb) + 0xF + 3;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "154:         }",
          "155:     }",
          "156: }",
          "160: {",
          "163:     unsigned char *pd;",
          "164:     int i, l;",
          "165:     unsigned char *dest_end = dest + dest_len;",
          "169:     pd = dest;",
          "170:     if (src_count & 1) {",
          "172:             return 0;",
          "174:     }",
          "176:     src_count >>= 1;",
          "177:     i = 0;",
          "178:     do {",
          "180:             break;",
          "182:         if (l & 0x80) {",
          "183:             l = (l & 0x7F) * 2;",
          "188:             pd += l;",
          "189:         } else {",
          "192:             for (i = 0; i < l; i++) {",
          "195:             }",
          "197:         }",
          "198:         i += l;",
          "199:     } while (i < src_count);",
          "202: }",
          "204: static void vmd_decode(VmdVideoContext *s, AVFrame *frame)",
          "",
          "[Removed Lines]",
          "158: static int rle_unpack(const unsigned char *src, int src_len, int src_count,",
          "159:                       unsigned char *dest, int dest_len)",
          "161:     const unsigned char *ps;",
          "162:     const unsigned char *ps_end;",
          "167:     ps = src;",
          "168:     ps_end = src + src_len;",
          "171:         if (ps_end - ps < 1)",
          "179:         if (ps_end - ps < 1)",
          "181:         l = *ps++;",
          "184:             if (dest_end - pd < l || ps_end - ps < l)",
          "185:                 return ps - src;",
          "186:             memcpy(pd, ps, l);",
          "187:             ps += l;",
          "190:             if (dest_end - pd < i || ps_end - ps < 2)",
          "191:                 return ps - src;",
          "196:             ps += 2;",
          "201:     return ps - src;",
          "",
          "[Added Lines]",
          "150: static int rle_unpack(const unsigned char *src, unsigned char *dest,",
          "151:                       int src_count, int src_size, int dest_len)",
          "156:     GetByteContext gb;",
          "158:     bytestream2_init(&gb, src, src_size);",
          "161:         if (bytestream2_get_bytes_left(&gb) < 1)",
          "169:         if (bytestream2_get_bytes_left(&gb) < 1)",
          "171:         l = bytestream2_get_byteu(&gb);",
          "174:             if (dest_end - pd < l || bytestream2_get_bytes_left(&gb) < l)",
          "175:                 return bytestream2_tell(&gb);",
          "176:             bytestream2_get_buffer(&gb, pd, l);",
          "179:             if (dest_end - pd < i || bytestream2_get_bytes_left(&gb) < 2)",
          "180:                 return bytestream2_tell(&gb);",
          "185:             bytestream2_skip(&gb, 2);",
          "190:     return bytestream2_tell(&gb);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "207:     unsigned int *palette32;",
          "208:     unsigned char r, g, b;",
          "216:     unsigned char meth;",
          "",
          "[Removed Lines]",
          "211:     const unsigned char *p = s->buf + 16;",
          "212:     const unsigned char *p_end = s->buf + s->size;",
          "214:     const unsigned char *pb;",
          "215:     const unsigned char *pb_end;",
          "",
          "[Added Lines]",
          "199:     GetByteContext gb;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "257:     }",
          "260:     if (s->buf[15] & 0x02) {",
          "264:         palette32 = (unsigned int *)s->palette;",
          "271:         }",
          "272:     }",
          "278:         if (meth & 0x80) {",
          "280:             meth &= 0x7F;",
          "283:         }",
          "285:         dp = &frame->data[0][frame_y * frame->linesize[0] + frame_x];",
          "",
          "[Removed Lines]",
          "261:         if (p_end - p < 2 + 3 * PALETTE_COUNT)",
          "262:             return;",
          "263:         p += 2;",
          "265:         for (i = 0; i < PALETTE_COUNT; i++) {",
          "266:             r = *p++ * 4;",
          "267:             g = *p++ * 4;",
          "268:             b = *p++ * 4;",
          "269:             palette32[i] = 0xFFU << 24 | r << 16 | g << 8 | b;",
          "270:             palette32[i] |= palette32[i] >> 6 & 0x30303;",
          "273:     if (p < p_end) {",
          "275:         pb = p;",
          "276:         pb_end = p_end;",
          "277:         meth = *pb++;",
          "279:             lz_unpack(pb, p_end - pb, s->unpack_buffer, s->unpack_buffer_size);",
          "281:             pb = s->unpack_buffer;",
          "282:             pb_end = s->unpack_buffer + s->unpack_buffer_size;",
          "",
          "[Added Lines]",
          "245:     bytestream2_init(&gb, s->buf + 16, s->size - 16);",
          "247:         bytestream2_skip(&gb, 2);",
          "249:         if (bytestream2_get_bytes_left(&gb) >= PALETTE_COUNT * 3) {",
          "250:             for (i = 0; i < PALETTE_COUNT; i++) {",
          "251:                 r = bytestream2_get_byteu(&gb) * 4;",
          "252:                 g = bytestream2_get_byteu(&gb) * 4;",
          "253:                 b = bytestream2_get_byteu(&gb) * 4;",
          "254:                 palette32[i] = 0xFFU << 24 | (r << 16) | (g << 8) | (b);",
          "255:                 palette32[i] |= palette32[i] >> 6 & 0x30303;",
          "256:             }",
          "259:     if (s->size > 0) {",
          "261:         bytestream2_init(&gb, gb.buffer, s->buf + s->size - gb.buffer);",
          "262:         if (bytestream2_get_bytes_left(&gb) < 1)",
          "263:             return;",
          "264:         meth = bytestream2_get_byteu(&gb);",
          "266:             lz_unpack(gb.buffer, bytestream2_get_bytes_left(&gb),",
          "267:                       s->unpack_buffer, s->unpack_buffer_size);",
          "269:             bytestream2_init(&gb, s->unpack_buffer, s->unpack_buffer_size);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "289:             for (i = 0; i < frame_height; i++) {",
          "290:                 ofs = 0;",
          "291:                 do {",
          "295:                     if (len & 0x80) {",
          "296:                         len = (len & 0x7F) + 1;",
          "298:                             return;",
          "301:                         ofs += len;",
          "302:                     } else {",
          "",
          "[Removed Lines]",
          "292:                     if (pb_end - pb < 1)",
          "293:                         return;",
          "294:                     len = *pb++;",
          "297:                         if (ofs + len > frame_width || pb_end - pb < len)",
          "299:                         memcpy(&dp[ofs], pb, len);",
          "300:                         pb += len;",
          "",
          "[Added Lines]",
          "279:                     len = bytestream2_get_byte(&gb);",
          "282:                         if (ofs + len > frame_width || bytestream2_get_bytes_left(&gb) < len)",
          "284:                         bytestream2_get_buffer(&gb, &dp[ofs], len);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "320:         case 2:",
          "321:             for (i = 0; i < frame_height; i++) {",
          "326:                 dp += frame->linesize[0];",
          "327:                 pp += s->prev_frame.linesize[0];",
          "328:             }",
          "",
          "[Removed Lines]",
          "322:                 if (pb_end -pb < frame_width)",
          "323:                     return;",
          "324:                 memcpy(dp, pb, frame_width);",
          "325:                 pb += frame_width;",
          "",
          "[Added Lines]",
          "306:                 bytestream2_get_buffer(&gb, dp, frame_width);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "332:             for (i = 0; i < frame_height; i++) {",
          "333:                 ofs = 0;",
          "334:                 do {",
          "338:                     if (len & 0x80) {",
          "339:                         len = (len & 0x7F) + 1;",
          "351:                     } else {",
          "353:                         if (ofs + len + 1 > frame_width || !s->prev_frame.data[0])",
          "",
          "[Removed Lines]",
          "335:                     if (pb_end - pb < 1)",
          "336:                         return;",
          "337:                     len = *pb++;",
          "340:                         if (pb_end - pb < 1)",
          "341:                             return;",
          "342:                         if (*pb++ == 0xFF)",
          "343:                             len = rle_unpack(pb, pb_end - pb, len, &dp[ofs], frame_width - ofs);",
          "344:                         else {",
          "345:                         if (pb_end - pb < len)",
          "346:                             return;",
          "347:                             memcpy(&dp[ofs], pb, len);",
          "348:                         }",
          "349:                         pb += len;",
          "350:                         ofs += len;",
          "",
          "[Added Lines]",
          "316:                     len = bytestream2_get_byte(&gb);",
          "319:                         if (bytestream2_get_byte(&gb) == 0xFF)",
          "320:                             len = rle_unpack(gb.buffer, &dp[ofs],",
          "321:                                              len, bytestream2_get_bytes_left(&gb),",
          "322:                                              frame_width - ofs);",
          "323:                         else",
          "324:                             bytestream2_get_buffer(&gb, &dp[ofs], len);",
          "325:                         bytestream2_skip(&gb, len);",
          "",
          "---------------"
        ],
        "tests/fate/filter.mak||tests/fate/filter.mak": [
          "File: tests/fate/filter.mak -> tests/fate/filter.mak",
          "--- Hunk 1 ---",
          "[Context before]",
          "69: FATE_FILTER_VSYNTH-$(CONFIG_HQDN3D_FILTER) += fate-filter-hqdn3d",
          "70: fate-filter-hqdn3d: CMD = framecrc -c:v pgmyuv -i $(SRC) -vf hqdn3d",
          "72: FATE_FILTER_VSYNTH-$(CONFIG_NEGATE_FILTER) += fate-filter-negate",
          "73: fate-filter-negate: CMD = framecrc -c:v pgmyuv -i $(SRC) -vf negate",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "72: FATE_FILTER-$(call FILTERDEMDECENCMUX, JOIN, WAV, PCM_S16LE, PCM_S16LE, PCM_S16LE) += fate-filter-join",
          "73: fate-filter-join: SRC1 = $(TARGET_PATH)/tests/data/asynth-44100-2.wav",
          "74: fate-filter-join: SRC2 = $(TARGET_PATH)/tests/data/asynth-44100-3.wav",
          "75: fate-filter-join: tests/data/asynth-44100-2.wav tests/data/asynth-44100-3.wav",
          "76: fate-filter-join: CMD = md5 -i $(SRC1) -i $(SRC2) -filter_complex join=channel_layout=5 -f s16le",
          "77: fate-filter-join: CMP = oneline",
          "78: fate-filter-join: REF = 38fa1b18b0c46d77df6f17bfc4f078dd",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "84: FATE_FILTER_VSYNTH-$(CONFIG_UNSHARP_FILTER) += fate-filter-unsharp",
          "85: fate-filter-unsharp: CMD = framecrc -c:v pgmyuv -i $(SRC) -vf unsharp",
          "87: FATE_YADIF += fate-filter-yadif-mode0",
          "88: fate-filter-yadif-mode0: CMD = framecrc -flags bitexact -idct simple -i $(SAMPLES)/mpeg2/mpeg2_field_encoding.ts -vframes 30 -vf yadif=0",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "95: FATE_FILTER-$(call FILTERDEMDECENCMUX, VOLUME, WAV, PCM_S16LE, PCM_S16LE, PCM_S16LE) += fate-filter-volume",
          "96: fate-filter-volume: SRC = $(TARGET_PATH)/tests/data/asynth-44100-2.wav",
          "97: fate-filter-volume: tests/data/asynth-44100-2.wav",
          "98: fate-filter-volume: CMD = md5 -i $(SRC) -af volume=precision=fixed:volume=0.5 -f s16le",
          "99: fate-filter-volume: CMP = oneline",
          "100: fate-filter-volume: REF = 4d6ba75ef3e32d305d066b9bc771d6f4",
          "",
          "---------------"
        ]
      }
    }
  ]
}
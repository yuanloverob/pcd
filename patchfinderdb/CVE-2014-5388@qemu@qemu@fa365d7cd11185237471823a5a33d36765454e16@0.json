{
  "cve_id": "CVE-2014-5388",
  "cve_desc": "Off-by-one error in the pci_read function in the ACPI PCI hotplug interface (hw/acpi/pcihp.c) in QEMU allows local guest users to obtain sensitive information and have other unspecified impact related to a crafted PCI device that triggers memory corruption.",
  "repo": "qemu/qemu",
  "patch_hash": "fa365d7cd11185237471823a5a33d36765454e16",
  "patch_info": {
    "commit_hash": "fa365d7cd11185237471823a5a33d36765454e16",
    "repo": "qemu/qemu",
    "commit_url": "https://github.com/qemu/qemu/commit/fa365d7cd11185237471823a5a33d36765454e16",
    "files": [
      "hw/acpi/pcihp.c"
    ],
    "message": "pcihp: fix possible array out of bounds\n\nPrevent out-of-bounds array access on\nacpi_pcihp_pci_status.\n\nSigned-off-by: Gonglei <arei.gonglei@huawei.com>\nReviewed-by: Peter Crosthwaite <peter.crosthwaite@xilinx.com>\nReviewed-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nCc: qemu-stable@nongnu.org\nReviewed-by: Marcel Apfelbaum <marcel@redhat.com>",
    "before_after_code_files": [
      "hw/acpi/pcihp.c||hw/acpi/pcihp.c"
    ]
  },
  "patch_diff": {
    "hw/acpi/pcihp.c||hw/acpi/pcihp.c": [
      "File: hw/acpi/pcihp.c -> hw/acpi/pcihp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "231:     uint32_t val = 0;",
      "232:     int bsel = s->hotplug_select;",
      "235:         return 0;",
      "236:     }",
      "",
      "[Removed Lines]",
      "234:     if (bsel < 0 || bsel > ACPI_PCIHP_MAX_HOTPLUG_BUS) {",
      "",
      "[Added Lines]",
      "234:     if (bsel < 0 || bsel >= ACPI_PCIHP_MAX_HOTPLUG_BUS) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "bfe3e6f5e3f23cc73dc83b0f4badecd5db175575",
      "candidate_info": {
        "commit_hash": "bfe3e6f5e3f23cc73dc83b0f4badecd5db175575",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/bfe3e6f5e3f23cc73dc83b0f4badecd5db175575",
        "files": [
          "hw/acpi/pcihp.c"
        ],
        "message": "pcihp: fix possible array out of bounds\n\nPrevent out-of-bounds array access on\nacpi_pcihp_pci_status.\n\nSigned-off-by: Gonglei <arei.gonglei@huawei.com>\nReviewed-by: Peter Crosthwaite <peter.crosthwaite@xilinx.com>\nReviewed-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nCc: qemu-stable@nongnu.org\nReviewed-by: Marcel Apfelbaum <marcel@redhat.com>\n(cherry picked from commit fa365d7cd11185237471823a5a33d36765454e16)\nSigned-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>",
        "before_after_code_files": [
          "hw/acpi/pcihp.c||hw/acpi/pcihp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "hw/acpi/pcihp.c||hw/acpi/pcihp.c"
          ],
          "candidate": [
            "hw/acpi/pcihp.c||hw/acpi/pcihp.c"
          ]
        }
      },
      "candidate_diff": {
        "hw/acpi/pcihp.c||hw/acpi/pcihp.c": [
          "File: hw/acpi/pcihp.c -> hw/acpi/pcihp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "231:     uint32_t val = 0;",
          "232:     int bsel = s->hotplug_select;",
          "235:         return 0;",
          "236:     }",
          "",
          "[Removed Lines]",
          "234:     if (bsel < 0 || bsel > ACPI_PCIHP_MAX_HOTPLUG_BUS) {",
          "",
          "[Added Lines]",
          "234:     if (bsel < 0 || bsel >= ACPI_PCIHP_MAX_HOTPLUG_BUS) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "db4728e6fec0364b866d3106125974eedc00e091",
      "candidate_info": {
        "commit_hash": "db4728e6fec0364b866d3106125974eedc00e091",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/db4728e6fec0364b866d3106125974eedc00e091",
        "files": [
          "hw/acpi/Makefile.objs",
          "hw/acpi/pcihp.c",
          "include/hw/acpi/pcihp.h"
        ],
        "message": "pcihp: generalization of piix4 acpi\n\nAdd ACPI based PCI hotplug library with bridge hotplug\nsupport.\nDesign\n   - each bus gets assigned \"bsel\" property.\n   - ACPI code writes this number\n     to a new BNUM register, then uses existing\n     UP/DOWN registers to probe slot status;\n     to eject, write number to BNUM register,\n     then slot into existing EJ.\n\nThe interface is actually backwards-compatible with\nexisting PIIX4 ACPI (though not migration compatible).\n\nThis is split out from PIIX4 codebase so we can\nreuse it for Q35 as well.\n\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>",
        "before_after_code_files": [
          "hw/acpi/Makefile.objs||hw/acpi/Makefile.objs",
          "hw/acpi/pcihp.c||hw/acpi/pcihp.c",
          "include/hw/acpi/pcihp.h||include/hw/acpi/pcihp.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "hw/acpi/pcihp.c||hw/acpi/pcihp.c"
          ],
          "candidate": [
            "hw/acpi/pcihp.c||hw/acpi/pcihp.c"
          ]
        }
      },
      "candidate_diff": {
        "hw/acpi/Makefile.objs||hw/acpi/Makefile.objs": [
          "File: hw/acpi/Makefile.objs -> hw/acpi/Makefile.objs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: common-obj-$(CONFIG_ACPI) += core.o piix4.o ich9.o",
          "",
          "[Added Lines]",
          "1: common-obj-$(CONFIG_ACPI) += core.o piix4.o ich9.o pcihp.o",
          "",
          "---------------"
        ],
        "hw/acpi/pcihp.c||hw/acpi/pcihp.c": [
          "File: hw/acpi/pcihp.c -> hw/acpi/pcihp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: #include \"hw/acpi/pcihp.h\"",
          "29: #include \"hw/hw.h\"",
          "30: #include \"hw/i386/pc.h\"",
          "31: #include \"hw/pci/pci.h\"",
          "32: #include \"hw/acpi/acpi.h\"",
          "33: #include \"sysemu/sysemu.h\"",
          "34: #include \"qemu/range.h\"",
          "35: #include \"exec/ioport.h\"",
          "36: #include \"exec/address-spaces.h\"",
          "37: #include \"hw/pci/pci_bus.h\"",
          "38: #include \"qom/qom-qobject.h\"",
          "39: #include \"qapi/qmp/qint.h\"",
          "43: #ifdef DEBUG",
          "44: # define ACPI_PCIHP_DPRINTF(format, ...)     printf(format, ## __VA_ARGS__)",
          "45: #else",
          "46: # define ACPI_PCIHP_DPRINTF(format, ...)     do { } while (0)",
          "47: #endif",
          "49: #define PCI_HOTPLUG_ADDR 0xae00",
          "50: #define PCI_HOTPLUG_SIZE 0x0014",
          "51: #define PCI_UP_BASE 0xae00",
          "52: #define PCI_DOWN_BASE 0xae04",
          "53: #define PCI_EJ_BASE 0xae08",
          "54: #define PCI_RMV_BASE 0xae0c",
          "55: #define PCI_SEL_BASE 0xae10",
          "57: typedef struct AcpiPciHpFind {",
          "58:     int bsel;",
          "59:     PCIBus *bus;",
          "60: } AcpiPciHpFind;",
          "62: static int acpi_pcihp_get_bsel(PCIBus *bus)",
          "63: {",
          "64:     QObject *o = object_property_get_qobject(OBJECT(bus),",
          "65:                                              ACPI_PCIHP_PROP_BSEL, NULL);",
          "66:     int64_t bsel = -1;",
          "67:     if (o) {",
          "68:         bsel = qint_get_int(qobject_to_qint(o));",
          "69:     }",
          "70:     if (bsel < 0) {",
          "71:         return -1;",
          "72:     }",
          "73:     return bsel;",
          "74: }",
          "76: static void acpi_pcihp_test_hotplug_bus(PCIBus *bus, void *opaque)",
          "77: {",
          "78:     AcpiPciHpFind *find = opaque;",
          "79:     if (find->bsel == acpi_pcihp_get_bsel(bus)) {",
          "80:         find->bus = bus;",
          "81:     }",
          "82: }",
          "84: static PCIBus *acpi_pcihp_find_hotplug_bus(AcpiPciHpState *s, int bsel)",
          "85: {",
          "86:     AcpiPciHpFind find = { .bsel = bsel, .bus = NULL };",
          "88:     if (bsel < 0) {",
          "89:         return NULL;",
          "90:     }",
          "92:     pci_for_each_bus(s->root, acpi_pcihp_test_hotplug_bus, &find);",
          "98:     if (!bsel && !find.bus) {",
          "99:         find.bus = s->root;",
          "100:     }",
          "101:     return find.bus;",
          "102: }",
          "104: static bool acpi_pcihp_pc_no_hotplug(AcpiPciHpState *s, PCIDevice *dev)",
          "105: {",
          "106:     PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(dev);",
          "112:     return (pc->is_bridge && !dev->qdev.hotplugged) || pc->no_hotplug;",
          "113: }",
          "115: static void acpi_pcihp_eject_slot(AcpiPciHpState *s, unsigned bsel, unsigned slots)",
          "116: {",
          "117:     BusChild *kid, *next;",
          "118:     int slot = ffs(slots) - 1;",
          "119:     bool slot_free = true;",
          "120:     PCIBus *bus = acpi_pcihp_find_hotplug_bus(s, bsel);",
          "122:     if (!bus) {",
          "123:         return;",
          "124:     }",
          "127:     s->acpi_pcihp_pci_status[bsel].down &= ~(1U << slot);",
          "129:     QTAILQ_FOREACH_SAFE(kid, &bus->qbus.children, sibling, next) {",
          "130:         DeviceState *qdev = kid->child;",
          "131:         PCIDevice *dev = PCI_DEVICE(qdev);",
          "132:         if (PCI_SLOT(dev->devfn) == slot) {",
          "133:             if (acpi_pcihp_pc_no_hotplug(s, dev)) {",
          "134:                 slot_free = false;",
          "135:             } else {",
          "136:                 object_unparent(OBJECT(qdev));",
          "137:             }",
          "138:         }",
          "139:     }",
          "140:     if (slot_free) {",
          "141:         s->acpi_pcihp_pci_status[bsel].device_present &= ~(1U << slot);",
          "142:     }",
          "143: }",
          "145: static void acpi_pcihp_update_hotplug_bus(AcpiPciHpState *s, int bsel)",
          "146: {",
          "147:     BusChild *kid, *next;",
          "148:     PCIBus *bus = acpi_pcihp_find_hotplug_bus(s, bsel);",
          "151:     while (s->acpi_pcihp_pci_status[bsel].down) {",
          "152:         acpi_pcihp_eject_slot(s, bsel, s->acpi_pcihp_pci_status[bsel].down);",
          "153:     }",
          "155:     s->acpi_pcihp_pci_status[bsel].hotplug_enable = ~0;",
          "156:     s->acpi_pcihp_pci_status[bsel].device_present = 0;",
          "158:     if (!bus) {",
          "159:         return;",
          "160:     }",
          "161:     QTAILQ_FOREACH_SAFE(kid, &bus->qbus.children, sibling, next) {",
          "162:         DeviceState *qdev = kid->child;",
          "163:         PCIDevice *pdev = PCI_DEVICE(qdev);",
          "164:         int slot = PCI_SLOT(pdev->devfn);",
          "166:         if (acpi_pcihp_pc_no_hotplug(s, pdev)) {",
          "167:             s->acpi_pcihp_pci_status[bsel].hotplug_enable &= ~(1U << slot);",
          "168:         }",
          "170:         s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);",
          "171:     }",
          "172: }",
          "174: static void acpi_pcihp_update(AcpiPciHpState *s)",
          "175: {",
          "176:     int i;",
          "178:     for (i = 0; i < ACPI_PCIHP_MAX_HOTPLUG_BUS; ++i) {",
          "179:         acpi_pcihp_update_hotplug_bus(s, i);",
          "180:     }",
          "181: }",
          "183: void acpi_pcihp_reset(AcpiPciHpState *s)",
          "184: {",
          "185:     acpi_pcihp_update(s);",
          "186: }",
          "188: static void enable_device(AcpiPciHpState *s, unsigned bsel, int slot)",
          "189: {",
          "190:     s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);",
          "191: }",
          "193: static void disable_device(AcpiPciHpState *s, unsigned bsel, int slot)",
          "194: {",
          "195:     s->acpi_pcihp_pci_status[bsel].down |= (1U << slot);",
          "196: }",
          "198: int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,",
          "199:                               PCIHotplugState state)",
          "200: {",
          "201:     int slot = PCI_SLOT(dev->devfn);",
          "202:     int bsel = acpi_pcihp_get_bsel(dev->bus);",
          "203:     if (bsel < 0) {",
          "204:         return -1;",
          "205:     }",
          "210:     if (state == PCI_COLDPLUG_ENABLED) {",
          "211:         s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);",
          "212:         return 0;",
          "213:     }",
          "215:     if (state == PCI_HOTPLUG_ENABLED) {",
          "216:         enable_device(s, bsel, slot);",
          "217:     } else {",
          "218:         disable_device(s, bsel, slot);",
          "219:     }",
          "221:     return 0;",
          "222: }",
          "224: static uint64_t pci_read(void *opaque, hwaddr addr, unsigned int size)",
          "225: {",
          "226:     AcpiPciHpState *s = opaque;",
          "227:     uint32_t val = 0;",
          "228:     int bsel = s->hotplug_select;",
          "230:     if (bsel < 0 || bsel > ACPI_PCIHP_MAX_HOTPLUG_BUS) {",
          "231:         return 0;",
          "232:     }",
          "234:     switch (addr) {",
          "235:     case PCI_UP_BASE - PCI_HOTPLUG_ADDR:",
          "238:         val = s->acpi_pcihp_pci_status[bsel].device_present &",
          "239:             s->acpi_pcihp_pci_status[bsel].hotplug_enable;",
          "240:         ACPI_PCIHP_DPRINTF(\"pci_up_read %\" PRIu32 \"\\n\", val);",
          "241:         break;",
          "242:     case PCI_DOWN_BASE - PCI_HOTPLUG_ADDR:",
          "243:         val = s->acpi_pcihp_pci_status[bsel].down;",
          "244:         ACPI_PCIHP_DPRINTF(\"pci_down_read %\" PRIu32 \"\\n\", val);",
          "245:         break;",
          "246:     case PCI_EJ_BASE - PCI_HOTPLUG_ADDR:",
          "248:         ACPI_PCIHP_DPRINTF(\"pci_features_read %\" PRIu32 \"\\n\", val);",
          "249:         break;",
          "250:     case PCI_RMV_BASE - PCI_HOTPLUG_ADDR:",
          "251:         val = s->acpi_pcihp_pci_status[bsel].hotplug_enable;",
          "252:         ACPI_PCIHP_DPRINTF(\"pci_rmv_read %\" PRIu32 \"\\n\", val);",
          "253:         break;",
          "254:     case PCI_SEL_BASE - PCI_HOTPLUG_ADDR:",
          "255:         val = s->hotplug_select;",
          "256:         ACPI_PCIHP_DPRINTF(\"pci_sel_read %\" PRIu32 \"\\n\", val);",
          "257:     default:",
          "258:         break;",
          "259:     }",
          "261:     return val;",
          "262: }",
          "264: static void pci_write(void *opaque, hwaddr addr, uint64_t data,",
          "265:                       unsigned int size)",
          "266: {",
          "267:     AcpiPciHpState *s = opaque;",
          "268:     switch (addr) {",
          "269:     case PCI_EJ_BASE - PCI_HOTPLUG_ADDR:",
          "270:         if (s->hotplug_select >= ACPI_PCIHP_MAX_HOTPLUG_BUS) {",
          "271:             break;",
          "272:         }",
          "273:         acpi_pcihp_eject_slot(s, s->hotplug_select, data);",
          "274:         ACPI_PCIHP_DPRINTF(\"pciej write %\" HWADDR_PRIx \" <== %\" PRIu64 \"\\n\",",
          "275:                       addr, data);",
          "276:         break;",
          "277:     case PCI_SEL_BASE - PCI_HOTPLUG_ADDR:",
          "278:         s->hotplug_select = data;",
          "279:         ACPI_PCIHP_DPRINTF(\"pcisel write %\" HWADDR_PRIx \" <== %\" PRIu64 \"\\n\",",
          "280:                       addr, data);",
          "281:     default:",
          "282:         break;",
          "283:     }",
          "284: }",
          "286: static const MemoryRegionOps acpi_pcihp_io_ops = {",
          "287:     .read = pci_read,",
          "288:     .write = pci_write,",
          "289:     .endianness = DEVICE_LITTLE_ENDIAN,",
          "290:     .valid = {",
          "291:         .min_access_size = 4,",
          "292:         .max_access_size = 4,",
          "293:     },",
          "294: };",
          "296: void acpi_pcihp_init(AcpiPciHpState *s, PCIBus *root_bus,",
          "297:                      MemoryRegion *address_space_io)",
          "298: {",
          "299:     s->root= root_bus;",
          "300:     memory_region_init_io(&s->io, NULL, &acpi_pcihp_io_ops, s,",
          "301:                           \"acpi-pci-hotplug\",",
          "302:                           PCI_HOTPLUG_SIZE);",
          "303:     memory_region_add_subregion(address_space_io, PCI_HOTPLUG_ADDR, &s->io);",
          "304: }",
          "306: const VMStateDescription vmstate_acpi_pcihp_pci_status = {",
          "307:     .name = \"acpi_pcihp_pci_status\",",
          "308:     .version_id = 1,",
          "309:     .minimum_version_id = 1,",
          "310:     .minimum_version_id_old = 1,",
          "311:     .fields      = (VMStateField []) {",
          "312:         VMSTATE_UINT32(up, AcpiPciHpPciStatus),",
          "313:         VMSTATE_UINT32(down, AcpiPciHpPciStatus),",
          "314:         VMSTATE_END_OF_LIST()",
          "315:     }",
          "316: };",
          "",
          "---------------"
        ],
        "include/hw/acpi/pcihp.h||include/hw/acpi/pcihp.h": [
          "File: include/hw/acpi/pcihp.h -> include/hw/acpi/pcihp.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: #ifndef HW_ACPI_PCIHP_H",
          "28: #define HW_ACPI_PCIHP_H",
          "30: #include <inttypes.h>",
          "31: #include <qemu/typedefs.h>",
          "34: typedef struct AcpiPciHpPciStatus {",
          "36:     uint32_t down;",
          "37:     uint32_t hotplug_enable;",
          "38:     uint32_t device_present;",
          "39: } AcpiPciHpPciStatus;",
          "41: #define ACPI_PCIHP_PROP_BSEL \"acpi-pcihp-bsel\"",
          "42: #define ACPI_PCIHP_MAX_HOTPLUG_BUS 256",
          "44: typedef struct AcpiPciHpState {",
          "45:     AcpiPciHpPciStatus acpi_pcihp_pci_status[ACPI_PCIHP_MAX_HOTPLUG_BUS];",
          "46:     uint32_t hotplug_select;",
          "47:     PCIBus *root;",
          "48:     MemoryRegion io;",
          "49: } AcpiPciHpState;",
          "51: void acpi_pcihp_init(AcpiPciHpState *, PCIBus *root,",
          "52:                      MemoryRegion *address_space_io);",
          "55: int acpi_pcihp_device_hotplug(AcpiPciHpState *, PCIDevice *,",
          "56:                               PCIHotplugState state);",
          "59: void acpi_pcihp_reset(AcpiPciHpState *s);",
          "61: extern const VMStateDescription vmstate_acpi_pcihp_pci_status;",
          "63: #define VMSTATE_PCI_HOTPLUG(pcihp, state, test_pcihp) \\",
          "64:         VMSTATE_UINT32_TEST(pcihp.hotplug_select, state, \\",
          "65:                             test_pcihp), \\",
          "66:         VMSTATE_STRUCT_ARRAY_TEST(pcihp.acpi_pcihp_pci_status, state, \\",
          "67:                                   ACPI_PCIHP_MAX_HOTPLUG_BUS, \\",
          "68:                                   test_pcihp, 1, \\",
          "69:                                   vmstate_acpi_pcihp_pci_status, \\",
          "70:                                   AcpiPciHpPciStatus)",
          "72: #endif",
          "",
          "---------------"
        ]
      }
    }
  ]
}
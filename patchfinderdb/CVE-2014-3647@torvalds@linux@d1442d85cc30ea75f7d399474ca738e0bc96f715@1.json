{
  "cve_id": "CVE-2014-3647",
  "cve_desc": "arch/x86/kvm/emulate.c in the KVM subsystem in the Linux kernel through 3.17.2 does not properly perform RIP changes, which allows guest OS users to cause a denial of service (guest OS crash) via a crafted application.",
  "repo": "torvalds/linux",
  "patch_hash": "d1442d85cc30ea75f7d399474ca738e0bc96f715",
  "patch_info": {
    "commit_hash": "d1442d85cc30ea75f7d399474ca738e0bc96f715",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/d1442d85cc30ea75f7d399474ca738e0bc96f715",
    "files": [
      "arch/x86/kvm/emulate.c"
    ],
    "message": "KVM: x86: Handle errors when RIP is set during far jumps\n\nFar jmp/call/ret may fault while loading a new RIP.  Currently KVM does not\nhandle this case, and may result in failed vm-entry once the assignment is\ndone.  The tricky part of doing so is that loading the new CS affects the\nVMCS/VMCB state, so if we fail during loading the new RIP, we are left in\nunconsistent state.  Therefore, this patch saves on 64-bit the old CS\ndescriptor and restores it if loading RIP failed.\n\nThis fixes CVE-2014-3647.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Nadav Amit <namit@cs.technion.ac.il>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
    "before_after_code_files": [
      "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
    ]
  },
  "patch_diff": {
    "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c": [
      "File: arch/x86/kvm/emulate.c -> arch/x86/kvm/emulate.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1445: static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,",
      "1447: {",
      "1448:  struct desc_struct seg_desc, old_desc;",
      "1449:  u8 dpl, rpl;",
      "",
      "[Removed Lines]",
      "1446:          u16 selector, int seg, u8 cpl, bool in_task_switch)",
      "",
      "[Added Lines]",
      "1446:          u16 selector, int seg, u8 cpl,",
      "1447:          bool in_task_switch,",
      "1448:          struct desc_struct *desc)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1584:  }",
      "1585: load:",
      "1586:  ctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);",
      "1587:  return X86EMUL_CONTINUE;",
      "1588: exception:",
      "1589:  return emulate_exception(ctxt, err_vec, err_code, true);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1589:  if (desc)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1593:        u16 selector, int seg)",
      "1594: {",
      "1595:  u8 cpl = ctxt->ops->cpl(ctxt);",
      "1597: }",
      "1599: static void write_register_operand(struct operand *op)",
      "",
      "[Removed Lines]",
      "1596:  return __load_segment_descriptor(ctxt, selector, seg, cpl, false);",
      "",
      "[Added Lines]",
      "1600:  return __load_segment_descriptor(ctxt, selector, seg, cpl, false, NULL);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1987: static int em_jmp_far(struct x86_emulate_ctxt *ctxt)",
      "1988: {",
      "1989:  int rc;",
      "1992:  memcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);",
      "1995:  if (rc != X86EMUL_CONTINUE)",
      "1996:   return rc;",
      "2001: }",
      "2003: static int em_grp45(struct x86_emulate_ctxt *ctxt)",
      "",
      "[Removed Lines]",
      "1990:  unsigned short sel;",
      "1994:  rc = load_segment_descriptor(ctxt, sel, VCPU_SREG_CS);",
      "1998:  ctxt->_eip = 0;",
      "1999:  memcpy(&ctxt->_eip, ctxt->src.valptr, ctxt->op_bytes);",
      "2000:  return X86EMUL_CONTINUE;",
      "",
      "[Added Lines]",
      "1994:  unsigned short sel, old_sel;",
      "1995:  struct desc_struct old_desc, new_desc;",
      "1996:  const struct x86_emulate_ops *ops = ctxt->ops;",
      "1997:  u8 cpl = ctxt->ops->cpl(ctxt);",
      "2000:  if (ctxt->mode == X86EMUL_MODE_PROT64)",
      "2001:   ops->get_segment(ctxt, &old_sel, &old_desc, NULL,",
      "2002:      VCPU_SREG_CS);",
      "2006:  rc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl, false,",
      "2007:            &new_desc);",
      "2011:  rc = assign_eip_far(ctxt, ctxt->src.val, new_desc.l);",
      "2012:  if (rc != X86EMUL_CONTINUE) {",
      "2013:   WARN_ON(!ctxt->mode != X86EMUL_MODE_PROT64);",
      "2015:   ops->set_segment(ctxt, old_sel, &old_desc, 0, VCPU_SREG_CS);",
      "2016:   return rc;",
      "2017:  }",
      "2018:  return rc;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2064: static int em_ret_far(struct x86_emulate_ctxt *ctxt)",
      "2065: {",
      "2066:  int rc;",
      "2068:  int cpl = ctxt->ops->cpl(ctxt);",
      "2071:  if (rc != X86EMUL_CONTINUE)",
      "2072:   return rc;",
      "2075:  rc = emulate_pop(ctxt, &cs, ctxt->op_bytes);",
      "2076:  if (rc != X86EMUL_CONTINUE)",
      "2077:   return rc;",
      "2079:  if (ctxt->mode >= X86EMUL_MODE_PROT16 && (cs & 3) > cpl)",
      "2080:   return X86EMUL_UNHANDLEABLE;",
      "2082:  return rc;",
      "2083: }",
      "",
      "[Removed Lines]",
      "2067:  unsigned long cs;",
      "2070:  rc = emulate_pop(ctxt, &ctxt->_eip, ctxt->op_bytes);",
      "2073:  if (ctxt->op_bytes == 4)",
      "2074:   ctxt->_eip = (u32)ctxt->_eip;",
      "2081:  rc = load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS);",
      "",
      "[Added Lines]",
      "2085:  unsigned long eip, cs;",
      "2086:  u16 old_cs;",
      "2088:  struct desc_struct old_desc, new_desc;",
      "2089:  const struct x86_emulate_ops *ops = ctxt->ops;",
      "2091:  if (ctxt->mode == X86EMUL_MODE_PROT64)",
      "2092:   ops->get_segment(ctxt, &old_cs, &old_desc, NULL,",
      "2093:      VCPU_SREG_CS);",
      "2095:  rc = emulate_pop(ctxt, &eip, ctxt->op_bytes);",
      "2104:  rc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, 0, false,",
      "2105:            &new_desc);",
      "2106:  if (rc != X86EMUL_CONTINUE)",
      "2107:   return rc;",
      "2108:  rc = assign_eip_far(ctxt, eip, new_desc.l);",
      "2109:  if (rc != X86EMUL_CONTINUE) {",
      "2110:   WARN_ON(!ctxt->mode != X86EMUL_MODE_PROT64);",
      "2111:   ops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);",
      "2112:  }",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2509:  if (ret != X86EMUL_CONTINUE)",
      "2510:   return ret;",
      "2512:  if (ret != X86EMUL_CONTINUE)",
      "2513:   return ret;",
      "2515:  if (ret != X86EMUL_CONTINUE)",
      "2516:   return ret;",
      "2518:  if (ret != X86EMUL_CONTINUE)",
      "2519:   return ret;",
      "2521:  if (ret != X86EMUL_CONTINUE)",
      "2522:   return ret;",
      "",
      "[Removed Lines]",
      "2508:  ret = __load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR, cpl, true);",
      "2511:  ret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl, true);",
      "2514:  ret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl, true);",
      "2517:  ret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl, true);",
      "2520:  ret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl, true);",
      "",
      "[Added Lines]",
      "2539:  ret = __load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR, cpl,",
      "2540:      true, NULL);",
      "2543:  ret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl,",
      "2544:      true, NULL);",
      "2547:  ret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl,",
      "2548:      true, NULL);",
      "2551:  ret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl,",
      "2552:      true, NULL);",
      "2555:  ret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl,",
      "2556:      true, NULL);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "2646:  if (ret != X86EMUL_CONTINUE)",
      "2647:   return ret;",
      "2649:  if (ret != X86EMUL_CONTINUE)",
      "2650:   return ret;",
      "2652:  if (ret != X86EMUL_CONTINUE)",
      "2653:   return ret;",
      "2655:  if (ret != X86EMUL_CONTINUE)",
      "2656:   return ret;",
      "2658:  if (ret != X86EMUL_CONTINUE)",
      "2659:   return ret;",
      "2661:  if (ret != X86EMUL_CONTINUE)",
      "2662:   return ret;",
      "2664:  if (ret != X86EMUL_CONTINUE)",
      "2665:   return ret;",
      "",
      "[Removed Lines]",
      "2645:  ret = __load_segment_descriptor(ctxt, tss->ldt_selector, VCPU_SREG_LDTR, cpl, true);",
      "2648:  ret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl, true);",
      "2651:  ret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl, true);",
      "2654:  ret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl, true);",
      "2657:  ret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl, true);",
      "2660:  ret = __load_segment_descriptor(ctxt, tss->fs, VCPU_SREG_FS, cpl, true);",
      "2663:  ret = __load_segment_descriptor(ctxt, tss->gs, VCPU_SREG_GS, cpl, true);",
      "",
      "[Added Lines]",
      "2681:  ret = __load_segment_descriptor(ctxt, tss->ldt_selector, VCPU_SREG_LDTR,",
      "2682:      cpl, true, NULL);",
      "2685:  ret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl,",
      "2686:      true, NULL);",
      "2689:  ret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl,",
      "2690:      true, NULL);",
      "2693:  ret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl,",
      "2694:      true, NULL);",
      "2697:  ret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl,",
      "2698:      true, NULL);",
      "2701:  ret = __load_segment_descriptor(ctxt, tss->fs, VCPU_SREG_FS, cpl,",
      "2702:      true, NULL);",
      "2705:  ret = __load_segment_descriptor(ctxt, tss->gs, VCPU_SREG_GS, cpl,",
      "2706:      true, NULL);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "2942:  u16 sel, old_cs;",
      "2943:  ulong old_eip;",
      "2944:  int rc;",
      "2947:  old_eip = ctxt->_eip;",
      "2949:  memcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);",
      "2951:   return X86EMUL_CONTINUE;",
      "2956:  ctxt->src.val = old_cs;",
      "2957:  rc = em_push(ctxt);",
      "2958:  if (rc != X86EMUL_CONTINUE)",
      "2961:  ctxt->src.val = old_eip;",
      "2963: }",
      "2965: static int em_ret_near_imm(struct x86_emulate_ctxt *ctxt)",
      "",
      "[Removed Lines]",
      "2946:  old_cs = get_segment_selector(ctxt, VCPU_SREG_CS);",
      "2950:  if (load_segment_descriptor(ctxt, sel, VCPU_SREG_CS))",
      "2953:  ctxt->_eip = 0;",
      "2954:  memcpy(&ctxt->_eip, ctxt->src.valptr, ctxt->op_bytes);",
      "2959:   return rc;",
      "2962:  return em_push(ctxt);",
      "",
      "[Added Lines]",
      "2988:  struct desc_struct old_desc, new_desc;",
      "2989:  const struct x86_emulate_ops *ops = ctxt->ops;",
      "2990:  int cpl = ctxt->ops->cpl(ctxt);",
      "2993:  ops->get_segment(ctxt, &old_cs, &old_desc, NULL, VCPU_SREG_CS);",
      "2996:  rc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl, false,",
      "2997:            &new_desc);",
      "2998:  if (rc != X86EMUL_CONTINUE)",
      "3001:  rc = assign_eip_far(ctxt, ctxt->src.val, new_desc.l);",
      "3002:  if (rc != X86EMUL_CONTINUE)",
      "3003:   goto fail;",
      "3008:   goto fail;",
      "3011:  rc = em_push(ctxt);",
      "3014:  if (rc != X86EMUL_CONTINUE)",
      "3015:   goto fail;",
      "3016:  return rc;",
      "3017: fail:",
      "3018:  ops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);",
      "3019:  return rc;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5045b468037dfe1c848827ce10e99d87f5669160",
      "candidate_info": {
        "commit_hash": "5045b468037dfe1c848827ce10e99d87f5669160",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5045b468037dfe1c848827ce10e99d87f5669160",
        "files": [
          "arch/x86/kvm/emulate.c"
        ],
        "message": "KVM: x86: check CS.DPL against RPL during task switch\n\nTable 7-1 of the SDM mentions a check that the code segment's\nDPL must match the selector's RPL.  This was not done by KVM,\nfix it.\n\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
          ],
          "candidate": [
            "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c": [
          "File: arch/x86/kvm/emulate.c -> arch/x86/kvm/emulate.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1413: static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,",
          "1415: {",
          "1416:  struct desc_struct seg_desc, old_desc;",
          "1417:  u8 dpl, rpl;",
          "",
          "[Removed Lines]",
          "1414:          u16 selector, int seg, u8 cpl)",
          "",
          "[Added Lines]",
          "1414:          u16 selector, int seg, u8 cpl, bool in_task_switch)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1486:    goto exception;",
          "1487:   break;",
          "1488:  case VCPU_SREG_CS:",
          "1489:   if (!(seg_desc.type & 8))",
          "1490:    goto exception;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1489:   if (in_task_switch && rpl != dpl)",
          "1490:    goto exception;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1547:        u16 selector, int seg)",
          "1548: {",
          "1549:  u8 cpl = ctxt->ops->cpl(ctxt);",
          "1551: }",
          "1553: static void write_register_operand(struct operand *op)",
          "",
          "[Removed Lines]",
          "1550:  return __load_segment_descriptor(ctxt, selector, seg, cpl);",
          "",
          "[Added Lines]",
          "1553:  return __load_segment_descriptor(ctxt, selector, seg, cpl, false);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2444:  if (ret != X86EMUL_CONTINUE)",
          "2445:   return ret;",
          "2447:  if (ret != X86EMUL_CONTINUE)",
          "2448:   return ret;",
          "2450:  if (ret != X86EMUL_CONTINUE)",
          "2451:   return ret;",
          "2453:  if (ret != X86EMUL_CONTINUE)",
          "2454:   return ret;",
          "2456:  if (ret != X86EMUL_CONTINUE)",
          "2457:   return ret;",
          "",
          "[Removed Lines]",
          "2443:  ret = __load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR, cpl);",
          "2446:  ret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl);",
          "2449:  ret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl);",
          "2452:  ret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl);",
          "2455:  ret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl);",
          "",
          "[Added Lines]",
          "2446:  ret = __load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR, cpl, true);",
          "2449:  ret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl, true);",
          "2452:  ret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl, true);",
          "2455:  ret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl, true);",
          "2458:  ret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl, true);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2581:  if (ret != X86EMUL_CONTINUE)",
          "2582:   return ret;",
          "2584:  if (ret != X86EMUL_CONTINUE)",
          "2585:   return ret;",
          "2587:  if (ret != X86EMUL_CONTINUE)",
          "2588:   return ret;",
          "2590:  if (ret != X86EMUL_CONTINUE)",
          "2591:   return ret;",
          "2593:  if (ret != X86EMUL_CONTINUE)",
          "2594:   return ret;",
          "2596:  if (ret != X86EMUL_CONTINUE)",
          "2597:   return ret;",
          "2599:  if (ret != X86EMUL_CONTINUE)",
          "2600:   return ret;",
          "",
          "[Removed Lines]",
          "2580:  ret = __load_segment_descriptor(ctxt, tss->ldt_selector, VCPU_SREG_LDTR, cpl);",
          "2583:  ret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl);",
          "2586:  ret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl);",
          "2589:  ret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl);",
          "2592:  ret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl);",
          "2595:  ret = __load_segment_descriptor(ctxt, tss->fs, VCPU_SREG_FS, cpl);",
          "2598:  ret = __load_segment_descriptor(ctxt, tss->gs, VCPU_SREG_GS, cpl);",
          "",
          "[Added Lines]",
          "2583:  ret = __load_segment_descriptor(ctxt, tss->ldt_selector, VCPU_SREG_LDTR, cpl, true);",
          "2586:  ret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl, true);",
          "2589:  ret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl, true);",
          "2592:  ret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl, true);",
          "2595:  ret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl, true);",
          "2598:  ret = __load_segment_descriptor(ctxt, tss->fs, VCPU_SREG_FS, cpl, true);",
          "2601:  ret = __load_segment_descriptor(ctxt, tss->gs, VCPU_SREG_GS, cpl, true);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ab646f54f4fd1a8b9671b8707f0739fdd28ce2b1",
      "candidate_info": {
        "commit_hash": "ab646f54f4fd1a8b9671b8707f0739fdd28ce2b1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ab646f54f4fd1a8b9671b8707f0739fdd28ce2b1",
        "files": [
          "arch/x86/kvm/emulate.c"
        ],
        "message": "KVM: x86: em_ret_far overrides cpl\n\ncommit d50eaa18039b (\"KVM: x86: Perform limit checks when assigning EIP\")\nmistakenly used zero as cpl on em_ret_far. Use the actual one.\n\nFixes: d50eaa18039b8b848c2285478d0775335ad5e930\nCc: stable@vger.kernel.org\nSigned-off-by: Nadav Amit <namit@cs.technion.ac.il>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
          ],
          "candidate": [
            "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c": [
          "File: arch/x86/kvm/emulate.c -> arch/x86/kvm/emulate.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2131:  if (ctxt->mode >= X86EMUL_MODE_PROT16 && (cs & 3) > cpl)",
          "2132:   return X86EMUL_UNHANDLEABLE;",
          "2134:            &new_desc);",
          "2135:  if (rc != X86EMUL_CONTINUE)",
          "2136:   return rc;",
          "",
          "[Removed Lines]",
          "2133:  rc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, 0, false,",
          "",
          "[Added Lines]",
          "2133:  rc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, cpl, false,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2356aaeb2f58f491679dc0c38bc3f6dbe54e7ded",
      "candidate_info": {
        "commit_hash": "2356aaeb2f58f491679dc0c38bc3f6dbe54e7ded",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2356aaeb2f58f491679dc0c38bc3f6dbe54e7ded",
        "files": [
          "arch/x86/kvm/emulate.c"
        ],
        "message": "KVM: x86: use new CS.RPL as CPL during task switch\n\nDuring task switch, all of CS.DPL, CS.RPL, SS.DPL must match (in addition\nto all the other requirements) and will be the new CPL.  So far this\nworked by carefully setting the CS selector and flag before doing the\ntask switch; setting CS.selector will already change the CPL.\n\nHowever, this will not work once we get the CPL from SS.DPL, because\nthen you will have to set the full segment descriptor cache to change\nthe CPL.  ctxt->ops->cpl(ctxt) will then return the old CPL during the\ntask switch, and the check that SS.DPL == CPL will fail.\n\nTemporarily assume that the CPL comes from CS.RPL during task switch\nto a protected-mode task.  This is the same approach used in QEMU's\nemulation code, which (until version 2.0) manually tracks the CPL.\n\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
          ],
          "candidate": [
            "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c": [
          "File: arch/x86/kvm/emulate.c -> arch/x86/kvm/emulate.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1410: }",
          "1415: {",
          "1416:  struct desc_struct seg_desc, old_desc;",
          "1418:  unsigned err_vec = GP_VECTOR;",
          "1419:  u32 err_code = 0;",
          "",
          "[Removed Lines]",
          "1413: static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,",
          "1414:        u16 selector, int seg)",
          "1417:  u8 dpl, rpl, cpl;",
          "",
          "[Added Lines]",
          "1413: static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,",
          "1414:          u16 selector, int seg, u8 cpl)",
          "1417:  u8 dpl, rpl;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1442:  }",
          "1444:  rpl = selector & 3;",
          "1448:  if ((seg == VCPU_SREG_CS",
          "",
          "[Removed Lines]",
          "1445:  cpl = ctxt->ops->cpl(ctxt);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1544:  return X86EMUL_PROPAGATE_FAULT;",
          "1545: }",
          "1547: static void write_register_operand(struct operand *op)",
          "1548: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1546: static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,",
          "1547:        u16 selector, int seg)",
          "1548: {",
          "1549:  u8 cpl = ctxt->ops->cpl(ctxt);",
          "1550:  return __load_segment_descriptor(ctxt, selector, seg, cpl);",
          "1551: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2405:      struct tss_segment_16 *tss)",
          "2406: {",
          "2407:  int ret;",
          "2409:  ctxt->_eip = tss->ip;",
          "2410:  ctxt->eflags = tss->flag | 2;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2414:  u8 cpl;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2427:  set_segment_selector(ctxt, tss->ss, VCPU_SREG_SS);",
          "2428:  set_segment_selector(ctxt, tss->ds, VCPU_SREG_DS);",
          "2435:  if (ret != X86EMUL_CONTINUE)",
          "2436:   return ret;",
          "2438:  if (ret != X86EMUL_CONTINUE)",
          "2439:   return ret;",
          "2441:  if (ret != X86EMUL_CONTINUE)",
          "2442:   return ret;",
          "2444:  if (ret != X86EMUL_CONTINUE)",
          "2445:   return ret;",
          "2447:  if (ret != X86EMUL_CONTINUE)",
          "2448:   return ret;",
          "",
          "[Removed Lines]",
          "2434:  ret = load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR);",
          "2437:  ret = load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES);",
          "2440:  ret = load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS);",
          "2443:  ret = load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS);",
          "2446:  ret = load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS);",
          "",
          "[Added Lines]",
          "2437:  cpl = tss->cs & 3;",
          "2443:  ret = __load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR, cpl);",
          "2446:  ret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl);",
          "2449:  ret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl);",
          "2452:  ret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl);",
          "2455:  ret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2521:      struct tss_segment_32 *tss)",
          "2522: {",
          "2523:  int ret;",
          "2525:  if (ctxt->ops->set_cr(ctxt, 3, tss->cr3))",
          "2526:   return emulate_gp(ctxt, 0);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2533:  u8 cpl;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2564:   ctxt->mode = X86EMUL_MODE_VM86;",
          "2566:   ctxt->mode = X86EMUL_MODE_PROT32;",
          "2575:  if (ret != X86EMUL_CONTINUE)",
          "2576:   return ret;",
          "2578:  if (ret != X86EMUL_CONTINUE)",
          "2579:   return ret;",
          "2581:  if (ret != X86EMUL_CONTINUE)",
          "2582:   return ret;",
          "2584:  if (ret != X86EMUL_CONTINUE)",
          "2585:   return ret;",
          "2587:  if (ret != X86EMUL_CONTINUE)",
          "2588:   return ret;",
          "2590:  if (ret != X86EMUL_CONTINUE)",
          "2591:   return ret;",
          "2593:  if (ret != X86EMUL_CONTINUE)",
          "2594:   return ret;",
          "",
          "[Removed Lines]",
          "2563:  if (ctxt->eflags & X86_EFLAGS_VM)",
          "2565:  else",
          "2568:  ctxt->ops->set_rflags(ctxt, ctxt->eflags);",
          "2574:  ret = load_segment_descriptor(ctxt, tss->ldt_selector, VCPU_SREG_LDTR);",
          "2577:  ret = load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES);",
          "2580:  ret = load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS);",
          "2583:  ret = load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS);",
          "2586:  ret = load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS);",
          "2589:  ret = load_segment_descriptor(ctxt, tss->fs, VCPU_SREG_FS);",
          "2592:  ret = load_segment_descriptor(ctxt, tss->gs, VCPU_SREG_GS);",
          "",
          "[Added Lines]",
          "2568:  if (ctxt->eflags & X86_EFLAGS_VM) {",
          "2570:   cpl = 3;",
          "2571:  } else {",
          "2573:   cpl = tss->cs & 3;",
          "2574:  }",
          "2580:  ret = __load_segment_descriptor(ctxt, tss->ldt_selector, VCPU_SREG_LDTR, cpl);",
          "2583:  ret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl);",
          "2586:  ret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl);",
          "2589:  ret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl);",
          "2592:  ret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl);",
          "2595:  ret = __load_segment_descriptor(ctxt, tss->fs, VCPU_SREG_FS, cpl);",
          "2598:  ret = __load_segment_descriptor(ctxt, tss->gs, VCPU_SREG_GS, cpl);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cd9b8e2c48b241be084dc794440e0e69267ef8e1",
      "candidate_info": {
        "commit_hash": "cd9b8e2c48b241be084dc794440e0e69267ef8e1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/cd9b8e2c48b241be084dc794440e0e69267ef8e1",
        "files": [
          "arch/x86/kvm/emulate.c"
        ],
        "message": "KVM: x86: Fix far-jump to non-canonical check\n\nCommit d1442d85cc30 (\"KVM: x86: Handle errors when RIP is set during far\njumps\") introduced a bug that caused the fix to be incomplete.  Due to\nincorrect evaluation, far jump to segment with L bit cleared (i.e., 32-bit\nsegment) and RIP with any of the high bits set (i.e, RIP[63:32] != 0) set may\nnot trigger #GP.  As we know, this imposes a security problem.\n\nIn addition, the condition for two warnings was incorrect.\n\nReported-by: Dan Carpenter <dan.carpenter@oracle.com>\nSigned-off-by: Nadav Amit <namit@cs.technion.ac.il>\n[Add #ifdef CONFIG_X86_64 to avoid complaints of undefined behavior. - Paolo]\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
          ],
          "candidate": [
            "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c": [
          "File: arch/x86/kvm/emulate.c -> arch/x86/kvm/emulate.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "574:  case 4:",
          "575:   ctxt->_eip = (u32)dst;",
          "576:   break;",
          "577:  case 8:",
          "578:   if ((cs_l && is_noncanonical_address(dst)) ||",
          "580:    return emulate_gp(ctxt, 0);",
          "581:   ctxt->_eip = dst;",
          "582:   break;",
          "583:  default:",
          "584:   WARN(1, \"unsupported eip assignment size\\n\");",
          "585:  }",
          "",
          "[Removed Lines]",
          "579:       (!cs_l && (dst & ~(u32)-1)))",
          "",
          "[Added Lines]",
          "577: #ifdef CONFIG_X86_64",
          "580:       (!cs_l && (dst >> 32) != 0))",
          "584: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2036:  rc = assign_eip_far(ctxt, ctxt->src.val, new_desc.l);",
          "2037:  if (rc != X86EMUL_CONTINUE) {",
          "2040:   ops->set_segment(ctxt, old_sel, &old_desc, 0, VCPU_SREG_CS);",
          "2041:   return rc;",
          "",
          "[Removed Lines]",
          "2038:   WARN_ON(!ctxt->mode != X86EMUL_MODE_PROT64);",
          "",
          "[Added Lines]",
          "2040:   WARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2132:   return rc;",
          "2133:  rc = assign_eip_far(ctxt, eip, new_desc.l);",
          "2134:  if (rc != X86EMUL_CONTINUE) {",
          "2136:   ops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);",
          "2137:  }",
          "2138:  return rc;",
          "",
          "[Removed Lines]",
          "2135:   WARN_ON(!ctxt->mode != X86EMUL_MODE_PROT64);",
          "",
          "[Added Lines]",
          "2137:   WARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
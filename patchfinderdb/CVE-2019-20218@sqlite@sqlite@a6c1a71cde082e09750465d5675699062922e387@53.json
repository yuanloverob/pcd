{
  "cve_id": "CVE-2019-20218",
  "cve_desc": "selectExpander in select.c in SQLite 3.30.1 proceeds with WITH stack unwinding even after a parsing error.",
  "repo": "sqlite/sqlite",
  "patch_hash": "a6c1a71cde082e09750465d5675699062922e387",
  "patch_info": {
    "commit_hash": "a6c1a71cde082e09750465d5675699062922e387",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/a6c1a71cde082e09750465d5675699062922e387",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/select.c",
      "test/altertab3.test"
    ],
    "message": "Do not attempt to unwind the WITH stack in the Parse object following an error. This fixes a separate case to [de6e6d68].\n\nFossilOrigin-Name: d29edef93451cc67a5d69c1cce1b1832d9ca8fff1f600afdd51338b74d077b92",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/select.c||src/select.c",
      "test/altertab3.test||test/altertab3.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 597896ed0ae9e2960a8f39576bd7f77a11dccc1da84b6a44ebb5c38d90ebc330",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/select.c||src/select.c": [
      "File: src/select.c -> src/select.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4982:     return WRC_Abort;",
      "4983:   }",
      "",
      "[Removed Lines]",
      "4981:   if( db->mallocFailed || sqliteProcessJoin(pParse, p) ){",
      "",
      "[Added Lines]",
      "4981:   if( pParse->nErr || db->mallocFailed || sqliteProcessJoin(pParse, p) ){",
      "",
      "---------------"
    ],
    "test/altertab3.test||test/altertab3.test": [
      "File: test/altertab3.test -> test/altertab3.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "531:   ALTER TABLE t1 RENAME TO t1x;",
      "532: } {1 {error in trigger r1: no such table: main.t2}}",
      "534: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "534: #------------------------------------------------------------------------",
      "535: #",
      "536: reset_db",
      "537: do_execsql_test 23.1 {",
      "538:   CREATE TABLE v0 (a);",
      "539:   CREATE VIEW v2 (v3) AS",
      "540:     WITH x1 AS (SELECT * FROM v2)",
      "541:     SELECT v3 AS x, v3 AS y FROM v2;",
      "542: }",
      "544: do_catchsql_test 23.2 {",
      "545:   SELECT * FROM v2",
      "546: } {1 {view v2 is circularly defined}}",
      "548: db close",
      "549: sqlite3 db test.db",
      "551: do_catchsql_test 23.3 {",
      "552:   ALTER TABLE v0 RENAME TO t3 ;",
      "553: } {1 {error in view v2: view v2 is circularly defined}}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5f0dfc00de8f0755545310de3c940ccb2ed9e624",
      "candidate_info": {
        "commit_hash": "5f0dfc00de8f0755545310de3c940ccb2ed9e624",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/5f0dfc00de8f0755545310de3c940ccb2ed9e624",
        "files": [
          "ext/rtree/geopoly.c",
          "ext/rtree/rtree.c",
          "manifest",
          "manifest.uuid"
        ],
        "message": "Thoroughly reset the rtree cursor at the start of each VFilter operation, including clearing its cache.  This prevents left over pages in the cache which can cause problems on shutdown after a LEFT JOIN. Ticket [5eadca17c4dde90c]\n\nFossilOrigin-Name: 4c50afafce8416369f89477ba7fe7d9b047399a5ee5754c73d0e67bbea8d877c",
        "before_after_code_files": [
          "ext/rtree/geopoly.c||ext/rtree/geopoly.c",
          "ext/rtree/rtree.c||ext/rtree/rtree.c",
          "manifest.uuid||manifest.uuid"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/rtree/geopoly.c||ext/rtree/geopoly.c": [
          "File: ext/rtree/geopoly.c -> ext/rtree/geopoly.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1345:   RtreeNode *pRoot = 0;",
          "1346:   int rc = SQLITE_OK;",
          "1347:   int iCell = 0;",
          "1350:   rtreeReference(pRtree);",
          "1360:   pCsr->iStrategy = idxNum;",
          "1361:   if( idxNum==1 ){",
          "",
          "[Removed Lines]",
          "1348:   sqlite3_stmt *pStmt;",
          "1353:   freeCursorConstraints(pCsr);",
          "1354:   sqlite3_free(pCsr->aPoint);",
          "1355:   pStmt = pCsr->pReadAux;",
          "1356:   memset(pCsr, 0, sizeof(RtreeCursor));",
          "1357:   pCsr->base.pVtab = (sqlite3_vtab*)pRtree;",
          "1358:   pCsr->pReadAux = pStmt;",
          "",
          "[Added Lines]",
          "1352:   resetCursor(pCsr);",
          "",
          "---------------"
        ],
        "ext/rtree/rtree.c||ext/rtree/rtree.c": [
          "File: ext/rtree/rtree.c -> ext/rtree/rtree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1071:   if( pCsr->aConstraint ){",
          "1073:     for(i=0; i<pCsr->nConstraint; i++){",
          "",
          "[Removed Lines]",
          "1070: static void freeCursorConstraints(RtreeCursor *pCsr){",
          "",
          "[Added Lines]",
          "1070: static void resetCursor(RtreeCursor *pCsr){",
          "1071:   Rtree *pRtree = (Rtree *)(pCsr->base.pVtab);",
          "1072:   int ii;",
          "1073:   sqlite3_stmt *pStmt;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1080:     sqlite3_free(pCsr->aConstraint);",
          "1081:     pCsr->aConstraint = 0;",
          "1082:   }",
          "1083: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1086:   for(ii=0; ii<RTREE_CACHE_SZ; ii++) nodeRelease(pRtree, pCsr->aNode[ii]);",
          "1087:   sqlite3_free(pCsr->aPoint);",
          "1088:   pStmt = pCsr->pReadAux;",
          "1089:   memset(pCsr, 0, sizeof(RtreeCursor));",
          "1090:   pCsr->base.pVtab = (sqlite3_vtab*)pRtree;",
          "1091:   pCsr->pReadAux = pStmt;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1088: static int rtreeClose(sqlite3_vtab_cursor *cur){",
          "1089:   Rtree *pRtree = (Rtree *)(cur->pVtab);",
          "1091:   RtreeCursor *pCsr = (RtreeCursor *)cur;",
          "1092:   assert( pRtree->nCursor>0 );",
          "1094:   sqlite3_finalize(pCsr->pReadAux);",
          "1097:   sqlite3_free(pCsr);",
          "1098:   pRtree->nCursor--;",
          "1099:   nodeBlobReset(pRtree);",
          "",
          "[Removed Lines]",
          "1090:   int ii;",
          "1093:   freeCursorConstraints(pCsr);",
          "1095:   sqlite3_free(pCsr->aPoint);",
          "1096:   for(ii=0; ii<RTREE_CACHE_SZ; ii++) nodeRelease(pRtree, pCsr->aNode[ii]);",
          "",
          "[Added Lines]",
          "1102:   resetCursor(pCsr);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1799:   int ii;",
          "1800:   int rc = SQLITE_OK;",
          "1801:   int iCell = 0;",
          "1804:   rtreeReference(pRtree);",
          "1814:   pCsr->iStrategy = idxNum;",
          "1815:   if( idxNum==1 ){",
          "",
          "[Removed Lines]",
          "1802:   sqlite3_stmt *pStmt;",
          "1807:   freeCursorConstraints(pCsr);",
          "1808:   sqlite3_free(pCsr->aPoint);",
          "1809:   pStmt = pCsr->pReadAux;",
          "1810:   memset(pCsr, 0, sizeof(RtreeCursor));",
          "1811:   pCsr->base.pVtab = (sqlite3_vtab*)pRtree;",
          "1812:   pCsr->pReadAux = pStmt;",
          "",
          "[Added Lines]",
          "1813:   resetCursor(pCsr);",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 953e6aa6d9ca09e549c88bc728c322fabdcef581f3b4a7763d95488dddbbd6a5",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9c9c70920bae0ccd6216ea7fa61f387fdeb0b6ae",
      "candidate_info": {
        "commit_hash": "9c9c70920bae0ccd6216ea7fa61f387fdeb0b6ae",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/9c9c70920bae0ccd6216ea7fa61f387fdeb0b6ae",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/test_vfs.c"
        ],
        "message": "Fix a recently introduced memory leak in the test code in test_vfs.c.\n\nFossilOrigin-Name: 2d53a30cc23e53033af8e8666457654db5dcc453ed6cd176ce1d0bff4f528159",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/test_vfs.c||src/test_vfs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 2eb997327c2c369c10b7835be80112d77cb2a7cfa9fe4d564042984c21d94698",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/test_vfs.c||src/test_vfs.c": [
          "File: src/test_vfs.c -> src/test_vfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1392:   if( p->pScript ) Tcl_DecrRefCount(p->pScript);",
          "1393:   sqlite3_vfs_unregister(p->pVfs);",
          "1394:   memset(p->pVfs, 0, sizeof(sqlite3_vfs));",
          "1396:   ckfree((char *)p->pVfs);",
          "1397:   ckfree((char *)p);",
          "1398: }",
          "",
          "[Removed Lines]",
          "1395:   memset(p, 0, sizeof(Testvfs));",
          "",
          "[Added Lines]",
          "1396:   memset(p, 0, sizeof(Testvfs));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3e7800a9dbfc516a4041dbea010830f75cae617d",
      "candidate_info": {
        "commit_hash": "3e7800a9dbfc516a4041dbea010830f75cae617d",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/3e7800a9dbfc516a4041dbea010830f75cae617d",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/btree.c",
          "src/btreeInt.h",
          "test/corrupt2.test",
          "test/corruptD.test",
          "test/corruptK.test"
        ],
        "message": "Defer computing the number of bytes of free space on a btree page until that value is actually needed.\n\nFossilOrigin-Name: 177f5f40eabfcfd229ac7f291dfed9e9ee35762e86923a0f356915f389da177d",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/btree.c||src/btree.c",
          "src/btreeInt.h||src/btreeInt.h",
          "test/corrupt2.test||test/corrupt2.test",
          "test/corruptD.test||test/corruptD.test",
          "test/corruptK.test||test/corruptK.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 09e337386beb2008eba969f79601d1b8ed953951ce6e43782586e168140d78d2",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/btree.c||src/btree.c": [
          "File: src/btree.c -> src/btree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1506:   data[hdr+7] = 0;",
          "1508:  defragment_out:",
          "1509:   if( data[hdr+7]+cbrk-iCellFirst!=pPage->nFree ){",
          "1510:     return SQLITE_CORRUPT_PAGE(pPage);",
          "1511:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1509:   assert( pPage->nFree>=0 );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1657:   testcase( gap+2+nByte==top );",
          "1658:   if( gap+2+nByte>top ){",
          "1659:     assert( pPage->nCell>0 || CORRUPT_DB );",
          "1660:     rc = defragmentPage(pPage, MIN(4, pPage->nFree - (2+nByte)));",
          "1661:     if( rc ) return rc;",
          "1662:     top = get2byteNotZero(&data[hdr+5]);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1661:     assert( pPage->nFree>=0 );",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1845:   return SQLITE_OK;",
          "1846: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1854: static int btreeComputeFreeSpace(MemPage *pPage){",
          "1864:   assert( pPage->pBt!=0 );",
          "1865:   assert( pPage->pBt->db!=0 );",
          "1866:   assert( sqlite3_mutex_held(pPage->pBt->mutex) );",
          "1867:   assert( pPage->pgno==sqlite3PagerPagenumber(pPage->pDbPage) );",
          "1868:   assert( pPage == sqlite3PagerGetExtra(pPage->pDbPage) );",
          "1869:   assert( pPage->aData == sqlite3PagerGetData(pPage->pDbPage) );",
          "1870:   assert( pPage->isInit==1 );",
          "1871:   assert( pPage->nFree<0 );",
          "1873:   usableSize = pPage->pBt->usableSize;",
          "1874:   hdr = pPage->hdrOffset;",
          "1875:   data = pPage->aData;",
          "1879:   top = get2byteNotZero(&data[hdr+5]);",
          "1880:   iCellFirst = hdr + 8 + pPage->childPtrSize + 2*pPage->nCell;",
          "1881:   iCellLast = usableSize - 4;",
          "1887:   pc = get2byte(&data[hdr+1]);",
          "1889:   if( pc>0 ){",
          "1890:     u32 next, size;",
          "1891:     if( pc<iCellFirst ){",
          "1895:       return SQLITE_CORRUPT_PAGE(pPage);",
          "1896:     }",
          "1897:     while( 1 ){",
          "1898:       if( pc>iCellLast ){",
          "1900:         return SQLITE_CORRUPT_PAGE(pPage);",
          "1901:       }",
          "1902:       next = get2byte(&data[pc]);",
          "1903:       size = get2byte(&data[pc+2]);",
          "1904:       nFree = nFree + size;",
          "1905:       if( next<=pc+size+3 ) break;",
          "1906:       pc = next;",
          "1907:     }",
          "1908:     if( next>0 ){",
          "1910:       return SQLITE_CORRUPT_PAGE(pPage);",
          "1911:     }",
          "1912:     if( pc+size>(unsigned int)usableSize ){",
          "1914:       return SQLITE_CORRUPT_PAGE(pPage);",
          "1915:     }",
          "1916:   }",
          "1925:   if( nFree>usableSize ){",
          "1926:     return SQLITE_CORRUPT_PAGE(pPage);",
          "1927:   }",
          "1928:   pPage->nFree = (u16)(nFree - iCellFirst);",
          "1929:   return SQLITE_OK;",
          "1930: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1890:   pPage->aDataEnd = &data[usableSize];",
          "1891:   pPage->aCellIdx = &data[cellOffset];",
          "1892:   pPage->aDataOfst = &data[pPage->childPtrSize];",
          "1899:   pPage->nCell = get2byte(&data[hdr+3]);",
          "",
          "[Removed Lines]",
          "1896:   top = get2byteNotZero(&data[hdr+5]);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1909:   assert( pPage->nCell>0 || top==usableSize || CORRUPT_DB );",
          "",
          "[Added Lines]",
          "1987:   assert( pPage->nCell>0",
          "1988:        || get2byteNotZero(&data[hdr+5])==usableSize",
          "1989:        || CORRUPT_DB );",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1937:     }",
          "1938:     if( !pPage->leaf ) iCellLast++;",
          "1939:   }",
          "1987:   pPage->isInit = 1;",
          "1988:   return SQLITE_OK;",
          "1989: }",
          "",
          "[Removed Lines]",
          "1945:   pc = get2byte(&data[hdr+1]);",
          "1947:   if( pc>0 ){",
          "1948:     u32 next, size;",
          "1949:     if( pc<iCellFirst ){",
          "1953:       return SQLITE_CORRUPT_PAGE(pPage);",
          "1954:     }",
          "1955:     while( 1 ){",
          "1956:       if( pc>iCellLast ){",
          "1958:         return SQLITE_CORRUPT_PAGE(pPage);",
          "1959:       }",
          "1960:       next = get2byte(&data[pc]);",
          "1961:       size = get2byte(&data[pc+2]);",
          "1962:       nFree = nFree + size;",
          "1963:       if( next<=pc+size+3 ) break;",
          "1964:       pc = next;",
          "1965:     }",
          "1966:     if( next>0 ){",
          "1968:       return SQLITE_CORRUPT_PAGE(pPage);",
          "1969:     }",
          "1970:     if( pc+size>(unsigned int)usableSize ){",
          "1972:       return SQLITE_CORRUPT_PAGE(pPage);",
          "1973:     }",
          "1974:   }",
          "1983:   if( nFree>usableSize ){",
          "1984:     return SQLITE_CORRUPT_PAGE(pPage);",
          "1985:   }",
          "1986:   pPage->nFree = (u16)(nFree - iCellFirst);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2128:   if( pgno>btreePagecount(pBt) ){",
          "2129:     rc = SQLITE_CORRUPT_BKPT;",
          "2131:   }",
          "2132:   rc = sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, bReadOnly);",
          "2133:   if( rc ){",
          "2135:   }",
          "2137:   if( (*ppPage)->isInit==0 ){",
          "2138:     btreePageFromDbPage(pDbPage, pgno, pBt);",
          "2139:     rc = btreeInitPage(*ppPage);",
          "2140:     if( rc!=SQLITE_OK ){",
          "2143:     }",
          "2144:   }",
          "2145:   assert( (*ppPage)->pgno==pgno );",
          "",
          "[Removed Lines]",
          "2130:     goto getAndInitPage_error;",
          "2134:     goto getAndInitPage_error;",
          "2141:       releasePage(*ppPage);",
          "2142:       goto getAndInitPage_error;",
          "",
          "[Added Lines]",
          "2164:     goto getAndInitPage_error1;",
          "2168:     goto getAndInitPage_error1;",
          "2175:       goto getAndInitPage_error2;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2150:   if( pCur && ((*ppPage)->nCell<1 || (*ppPage)->intKey!=pCur->curIntKey) ){",
          "2151:     rc = SQLITE_CORRUPT_PGNO(pgno);",
          "2154:   }",
          "2155:   return SQLITE_OK;",
          "2158:   if( pCur ){",
          "2159:     pCur->iPage--;",
          "2160:     pCur->pPage = pCur->apPage[pCur->iPage];",
          "",
          "[Removed Lines]",
          "2152:     releasePage(*ppPage);",
          "2153:     goto getAndInitPage_error;",
          "2157: getAndInitPage_error:",
          "",
          "[Added Lines]",
          "2185:     goto getAndInitPage_error2;",
          "2189: getAndInitPage_error2:",
          "2190:   releasePage(*ppPage);",
          "2191: getAndInitPage_error1:",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "6566:   assert( CORRUPT_DB || sz==cellSize(pPage, idx) );",
          "6567:   assert( sqlite3PagerIswriteable(pPage->pDbPage) );",
          "6568:   assert( sqlite3_mutex_held(pPage->pBt->mutex) );",
          "6569:   data = pPage->aData;",
          "6570:   ptr = &pPage->aCellIdx[2*idx];",
          "6571:   pc = get2byte(ptr);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6603:   assert( pPage->nFree>=0 );",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "6638:   assert( sz==pPage->xCellSize(pPage, pCell) || (sz==8 && iChild>0) );",
          "6639:   if( pPage->nOverflow || sz+2>pPage->nFree ){",
          "6640:     if( pTemp ){",
          "6641:       memcpy(pTemp, pCell, sz);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6674:   assert( pPage->nFree>=0 );",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "7187:   assert( sqlite3_mutex_held(pPage->pBt->mutex) );",
          "7188:   assert( sqlite3PagerIswriteable(pParent->pDbPage) );",
          "7189:   assert( pPage->nOverflow==1 );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7228:   assert( pPage->nFree>=0 );",
          "7229:   assert( pParent->nFree>=0 );",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "7359:     pTo->isInit = 0;",
          "7360:     rc = btreeInitPage(pTo);",
          "7361:     if( rc!=SQLITE_OK ){",
          "7363:       return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7399:     if( rc==SQLITE_OK ) rc = btreeComputeFreeSpace(pTo);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "7466:   if( !aOvflSpace ){",
          "7467:     return SQLITE_NOMEM_BKPT;",
          "7468:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7508:   assert( pParent->nFree>=0 );",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "7505:       memset(apOld, 0, (i+1)*sizeof(MemPage*));",
          "7506:       goto balance_cleanup;",
          "7507:     }",
          "7508:     nMaxCells += 1+apOld[i]->nCell+apOld[i]->nOverflow;",
          "7509:     if( (i--)==0 ) break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7548:     if( apOld[i]->nFree<0 ){",
          "7549:       rc = btreeComputeFreeSpace(apOld[i]);",
          "7550:       if( rc ){",
          "7551:         memset(apOld, 0, (i)*sizeof(MemPage*));",
          "7552:         goto balance_cleanup;",
          "7553:       }",
          "7554:     }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "7704:       b.apEnd[k] = pParent->aDataEnd;",
          "7705:       b.ixNx[k] = cntOld[i]+1;",
          "7706:     }",
          "7707:     szNew[i] = usableSpace - p->nFree;",
          "7708:     for(j=0; j<p->nOverflow; j++){",
          "7709:       szNew[i] += 2 + p->xCellSize(p, p->apOvfl[j]);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7754:     assert( p->nFree>=0 );",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "8247:     int iPage = pCur->iPage;",
          "8248:     MemPage *pPage = pCur->pPage;",
          "8250:     if( iPage==0 ){",
          "8251:       if( pPage->nOverflow ){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8298:     if( NEVER(pPage->nFree<0) && btreeComputeFreeSpace(pPage) ) break;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "8275:       int const iIdx = pCur->aiIdx[iPage-1];",
          "8277:       rc = sqlite3PagerWrite(pParent->pDbPage);",
          "8278:       if( rc==SQLITE_OK ){",
          "8279: #ifndef SQLITE_OMIT_QUICKBALANCE",
          "8280:         if( pPage->intKeyLeaf",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8327:       if( rc==SQLITE_OK && pParent->nFree<0 ){",
          "8328:         rc = btreeComputeFreeSpace(pParent);",
          "8329:       }",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "8621:   pPage = pCur->pPage;",
          "8622:   assert( pPage->intKey || pX->nKey>=0 );",
          "8623:   assert( pPage->leaf || !pPage->intKey );",
          "8625:   TRACE((\"INSERT: table=%d nkey=%lld ndata=%d page=%d %s\\n\",",
          "8626:           pCur->pgnoRoot, pX->nKey, pX->nData, pPage->pgno,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8676:   if( pPage->nFree<0 ){",
          "8677:     rc = btreeComputeFreeSpace(pPage);",
          "8678:     if( rc ) return rc;",
          "8679:   }",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "8771:   iCellIdx = pCur->ix;",
          "8772:   pPage = pCur->pPage;",
          "8773:   pCell = findCell(pPage, iCellIdx);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8830:   if( pPage->nFree<0 && btreeComputeFreeSpace(pPage) ) return SQLITE_CORRUPT;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "8841:     Pgno n;",
          "8842:     unsigned char *pTmp;",
          "8844:     if( iCellDepth<pCur->iPage-1 ){",
          "8845:       n = pCur->apPage[iCellDepth+1]->pgno;",
          "8846:     }else{",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8901:     if( pLeaf->nFree<0 ){",
          "8902:       rc = btreeComputeFreeSpace(pLeaf);",
          "8903:       if( rc ) return rc;",
          "8904:     }",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "9732:                    \"btreeInitPage() returns error code %d\", rc);",
          "9733:     goto end_of_check;",
          "9734:   }",
          "9735:   data = pPage->aData;",
          "9736:   hdr = pPage->hdrOffset;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9796:   if( (rc = btreeComputeFreeSpace(pPage))!=0 ){",
          "9797:     assert( rc==SQLITE_CORRUPT );",
          "9798:     checkAppendMsg(pCheck, \"free space corruption\", rc);",
          "9799:     goto end_of_check;",
          "9800:   }",
          "",
          "---------------"
        ],
        "src/btreeInt.h||src/btreeInt.h": [
          "File: src/btreeInt.h -> src/btreeInt.h"
        ],
        "test/corrupt2.test||test/corrupt2.test": [
          "File: test/corrupt2.test -> test/corrupt2.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "95:   close $f",
          "97:   sqlite3 db2 corrupt.db",
          "104: do_test corrupt2-1.5 {",
          "105:   db2 close",
          "",
          "[Removed Lines]",
          "98:   catchsql \"",
          "99:     $::presql",
          "100:     SELECT * FROM sqlite_master;",
          "101:   \" db2",
          "102: } {1 {database disk image is malformed}}",
          "",
          "[Added Lines]",
          "98:   # Note: This test is no longer meaningful due to the deferred computation",
          "99:   # of MemPage.nFree",
          "100:   catchsql {PRAGMA quick_check} db2",
          "101: } {0 {{*** in database main ***",
          "102: Page 1: free space corruption}}}",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "118:   close $f",
          "120:   sqlite3 db2 corrupt.db",
          "126: db2 close",
          "128: # Corrupt a database by having 2 indices of the same name:",
          "",
          "[Removed Lines]",
          "121:   catchsql \"",
          "122:     $::presql",
          "123:     SELECT * FROM sqlite_master;",
          "124:   \" db2",
          "125: } {1 {database disk image is malformed}}",
          "",
          "[Added Lines]",
          "121:   catchsql {PRAGMA quick_check} db2",
          "122: } {0 {{*** in database main ***",
          "123: Page 1: free space corruption}}}",
          "",
          "---------------"
        ],
        "test/corruptD.test||test/corruptD.test": [
          "File: test/corruptD.test -> test/corruptD.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "111: do_test corruptD-1.1.1 {",
          "112:   incr_change_counter",
          "113:   hexio_write test.db [expr 1024+1] FFFF",
          "116: do_test corruptD-1.1.2 {",
          "117:   incr_change_counter",
          "118:   hexio_write test.db [expr 1024+1] [hexio_render_int32 1021]",
          "",
          "[Removed Lines]",
          "114:   catchsql { SELECT * FROM t1 ORDER BY rowid }",
          "115: } {1 {database disk image is malformed}}",
          "",
          "[Added Lines]",
          "114:   catchsql { PRAGMA quick_check }",
          "115: } {0 {{*** in database main ***",
          "116: Page 2: free space corruption}}}",
          "",
          "---------------"
        ],
        "test/corruptK.test||test/corruptK.test": [
          "File: test/corruptK.test -> test/corruptK.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "68: do_execsql_test 1.3 {",
          "69:   INSERT INTO t1 VALUES(randomblob(20));",
          "70: }",
          "71: do_catchsql_test 1.4 {",
          "72:   INSERT INTO t1 VALUES(randomblob(90));",
          "73: } {1 {database disk image is malformed}}",
          "75: #-------------------------------------------------------------------------",
          "76: reset_db",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "72: # This test no longer functions due to the deferred computation of",
          "73: # MemPage.nFree.",
          "74: #",
          "75: if 0 {",
          "79: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b7fc7c8556e5745dca30d561ec46776a7d293e93",
      "candidate_info": {
        "commit_hash": "b7fc7c8556e5745dca30d561ec46776a7d293e93",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/b7fc7c8556e5745dca30d561ec46776a7d293e93",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/test_hexio.c"
        ],
        "message": "Fix a harmless unused variable warning in the test logic.\n\nFossilOrigin-Name: d7673a445f4cde8f71153ce81efdc34fbed8b8625714d54afae1a83d548671ff",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/test_hexio.c||src/test_hexio.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 8ea1dc727d391b15d0c4fa858ff68d5b8a63dde46408f24027dac8d28f044cbd",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/test_hexio.c||src/test_hexio.c": [
          "File: src/test_hexio.c -> src/test_hexio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "393:   int nOut = 0;",
          "394:   int nAlloc = 0;",
          "395:   int i;",
          "398:   if( objc!=2 ){",
          "399:     Tcl_WrongNumArgs(interp, 1, objv, \"LIST\");",
          "",
          "[Removed Lines]",
          "396:   int rc = TCL_OK;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "035f6d909fcdd2b36320b07aec608a6c75187593",
      "candidate_info": {
        "commit_hash": "035f6d909fcdd2b36320b07aec608a6c75187593",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/035f6d909fcdd2b36320b07aec608a6c75187593",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/alter.c"
        ],
        "message": "Do not allow ALTER TABLE ADD COLUMN for a STORED column.\n\nFossilOrigin-Name: 42fc08bc1528a34a603c2c085b515766a8d33ae7ea0350a52b0ca24b94ebcbc5",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/alter.c||src/alter.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 30065716878d4058e75eb510b0b27b68e5193d04625eb173210de8061f20f499",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/alter.c||src/alter.c": [
          "File: src/alter.c -> src/alter.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "349:       }",
          "350:       sqlite3ValueFree(pVal);",
          "351:     }",
          "352:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "352:   }else if( pCol->colFlags & COLFLAG_STORED ){",
          "353:     sqlite3ErrorMsg(pParse, \"cannot add a STORED column\");",
          "354:     return;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
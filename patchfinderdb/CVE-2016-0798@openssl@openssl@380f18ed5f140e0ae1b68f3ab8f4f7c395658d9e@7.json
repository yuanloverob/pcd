{
  "cve_id": "CVE-2016-0798",
  "cve_desc": "Memory leak in the SRP_VBASE_get_by_user implementation in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory consumption) by providing an invalid username in a connection attempt, related to apps/s_server.c and crypto/srp/srp_vfy.c.",
  "repo": "openssl/openssl",
  "patch_hash": "380f18ed5f140e0ae1b68f3ab8f4f7c395658d9e",
  "patch_info": {
    "commit_hash": "380f18ed5f140e0ae1b68f3ab8f4f7c395658d9e",
    "repo": "openssl/openssl",
    "commit_url": "https://github.com/openssl/openssl/commit/380f18ed5f140e0ae1b68f3ab8f4f7c395658d9e",
    "files": [
      "CHANGES",
      "apps/s_server.c",
      "crypto/srp/srp_vfy.c",
      "include/openssl/srp.h",
      "util/libeay.num"
    ],
    "message": "CVE-2016-0798: avoid memory leak in SRP\n\nThe SRP user database lookup method SRP_VBASE_get_by_user had confusing\nmemory management semantics; the returned pointer was sometimes newly\nallocated, and sometimes owned by the callee. The calling code has no\nway of distinguishing these two cases.\n\nSpecifically, SRP servers that configure a secret seed to hide valid\nlogin information are vulnerable to a memory leak: an attacker\nconnecting with an invalid username can cause a memory leak of around\n300 bytes per connection.\n\nServers that do not configure SRP, or configure SRP but do not configure\na seed are not vulnerable.\n\nIn Apache, the seed directive is known as SSLSRPUnknownUserSeed.\n\nTo mitigate the memory leak, the seed handling in SRP_VBASE_get_by_user\nis now disabled even if the user has configured a seed.\n\nApplications are advised to migrate to SRP_VBASE_get1_by_user. However,\nnote that OpenSSL makes no strong guarantees about the\nindistinguishability of valid and invalid logins. In particular,\ncomputations are currently not carried out in constant time.\n\nReviewed-by: Rich Salz <rsalz@openssl.org>",
    "before_after_code_files": [
      "apps/s_server.c||apps/s_server.c",
      "crypto/srp/srp_vfy.c||crypto/srp/srp_vfy.c",
      "include/openssl/srp.h||include/openssl/srp.h",
      "util/libeay.num||util/libeay.num"
    ]
  },
  "patch_diff": {
    "apps/s_server.c||apps/s_server.c": [
      "File: apps/s_server.c -> apps/s_server.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "352: static int ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)",
      "353: {",
      "354:     srpsrvparm *p = (srpsrvparm *) arg;",
      "355:     if (p->login == NULL && p->user == NULL) {",
      "356:         p->login = SSL_get_srp_username(s);",
      "357:         BIO_printf(bio_err, \"SRP username = \\\"%s\\\"\\n\", p->login);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "355:     int ret = SSL3_AL_FATAL;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "361:     if (p->user == NULL) {",
      "362:         BIO_printf(bio_err, \"User %s doesn't exist\\n\", p->login);",
      "364:     }",
      "365:     if (SSL_set_srp_server_param",
      "366:         (s, p->user->N, p->user->g, p->user->s, p->user->v,",
      "367:          p->user->info) < 0) {",
      "370:     }",
      "371:     BIO_printf(bio_err,",
      "372:                \"SRP parameters set: username = \\\"%s\\\" info=\\\"%s\\\" \\n\",",
      "373:                p->login, p->user->info);",
      "375:     p->user = NULL;",
      "376:     p->login = NULL;",
      "378: }",
      "380: #endif",
      "",
      "[Removed Lines]",
      "363:         return SSL3_AL_FATAL;",
      "369:         return SSL3_AL_FATAL;",
      "377:     return SSL_ERROR_NONE;",
      "",
      "[Added Lines]",
      "365:         goto err;",
      "372:         goto err;",
      "377:     ret = SSL_ERROR_NONE;",
      "379: err:",
      "380:     SRP_user_pwd_free(p->user);",
      "383:     return ret;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2325: #ifndef OPENSSL_NO_SRP",
      "2326:                 while (SSL_get_error(con, k) == SSL_ERROR_WANT_X509_LOOKUP) {",
      "2327:                     BIO_printf(bio_s_out, \"LOOKUP renego during write\\n\");",
      "2328:                     srp_callback_parm.user =",
      "2331:                     if (srp_callback_parm.user)",
      "2332:                         BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",",
      "2333:                                    srp_callback_parm.user->info);",
      "",
      "[Removed Lines]",
      "2329:                         SRP_VBASE_get_by_user(srp_callback_parm.vb,",
      "2330:                                               srp_callback_parm.login);",
      "",
      "[Added Lines]",
      "2334:                     SRP_user_pwd_free(srp_callback_parm.user);",
      "2336:                         SRP_VBASE_get1_by_user(srp_callback_parm.vb,",
      "2337:                                                srp_callback_parm.login);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2393: #ifndef OPENSSL_NO_SRP",
      "2394:                 while (SSL_get_error(con, i) == SSL_ERROR_WANT_X509_LOOKUP) {",
      "2395:                     BIO_printf(bio_s_out, \"LOOKUP renego during read\\n\");",
      "2396:                     srp_callback_parm.user =",
      "2399:                     if (srp_callback_parm.user)",
      "2400:                         BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",",
      "2401:                                    srp_callback_parm.user->info);",
      "",
      "[Removed Lines]",
      "2397:                         SRP_VBASE_get_by_user(srp_callback_parm.vb,",
      "2398:                                               srp_callback_parm.login);",
      "",
      "[Added Lines]",
      "2403:                     SRP_user_pwd_free(srp_callback_parm.user);",
      "2405:                         SRP_VBASE_get1_by_user(srp_callback_parm.vb,",
      "2406:                                                srp_callback_parm.login);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2520:         while (i <= 0 && SSL_get_error(con, i) == SSL_ERROR_WANT_X509_LOOKUP) {",
      "2521:             BIO_printf(bio_s_out, \"LOOKUP during accept %s\\n\",",
      "2522:                        srp_callback_parm.login);",
      "2523:             srp_callback_parm.user =",
      "2526:             if (srp_callback_parm.user)",
      "2527:                 BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",",
      "2528:                            srp_callback_parm.user->info);",
      "",
      "[Removed Lines]",
      "2524:                 SRP_VBASE_get_by_user(srp_callback_parm.vb,",
      "2525:                                       srp_callback_parm.login);",
      "",
      "[Added Lines]",
      "2531:             SRP_user_pwd_free(srp_callback_parm.user);",
      "2533:                 SRP_VBASE_get1_by_user(srp_callback_parm.vb,",
      "2534:                                        srp_callback_parm.login);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2732:                 if (BIO_should_io_special(io)",
      "2733:                     && BIO_get_retry_reason(io) == BIO_RR_SSL_X509_LOOKUP) {",
      "2734:                     BIO_printf(bio_s_out, \"LOOKUP renego during read\\n\");",
      "2735:                     srp_callback_parm.user =",
      "2738:                     if (srp_callback_parm.user)",
      "2739:                         BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",",
      "2740:                                    srp_callback_parm.user->info);",
      "",
      "[Removed Lines]",
      "2736:                         SRP_VBASE_get_by_user(srp_callback_parm.vb,",
      "2737:                                               srp_callback_parm.login);",
      "",
      "[Added Lines]",
      "2744:                     SRP_user_pwd_free(srp_callback_parm.user);",
      "2746:                         SRP_VBASE_get1_by_user(srp_callback_parm.vb,",
      "2747:                                                srp_callback_parm.login);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "3093:         if (BIO_should_io_special(io)",
      "3094:             && BIO_get_retry_reason(io) == BIO_RR_SSL_X509_LOOKUP) {",
      "3095:             BIO_printf(bio_s_out, \"LOOKUP renego during accept\\n\");",
      "3096:             srp_callback_parm.user =",
      "3099:             if (srp_callback_parm.user)",
      "3100:                 BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",",
      "3101:                            srp_callback_parm.user->info);",
      "",
      "[Removed Lines]",
      "3097:                 SRP_VBASE_get_by_user(srp_callback_parm.vb,",
      "3098:                                       srp_callback_parm.login);",
      "",
      "[Added Lines]",
      "3106:             SRP_user_pwd_free(srp_callback_parm.user);",
      "3108:                 SRP_VBASE_get1_by_user(srp_callback_parm.vb,",
      "3109:                                        srp_callback_parm.login);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "3121:                 if (BIO_should_io_special(io)",
      "3122:                     && BIO_get_retry_reason(io) == BIO_RR_SSL_X509_LOOKUP) {",
      "3123:                     BIO_printf(bio_s_out, \"LOOKUP renego during read\\n\");",
      "3124:                     srp_callback_parm.user =",
      "3127:                     if (srp_callback_parm.user)",
      "3128:                         BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",",
      "3129:                                    srp_callback_parm.user->info);",
      "",
      "[Removed Lines]",
      "3125:                         SRP_VBASE_get_by_user(srp_callback_parm.vb,",
      "3126:                                               srp_callback_parm.login);",
      "",
      "[Added Lines]",
      "3135:                     SRP_user_pwd_free(srp_callback_parm.user);",
      "3137:                         SRP_VBASE_get1_by_user(srp_callback_parm.vb,",
      "3138:                                                srp_callback_parm.login);",
      "",
      "---------------"
    ],
    "crypto/srp/srp_vfy.c||crypto/srp/srp_vfy.c": [
      "File: crypto/srp/srp_vfy.c -> crypto/srp/srp_vfy.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "184:     return olddst;",
      "185: }",
      "188: {",
      "189:     if (user_pwd == NULL)",
      "190:         return;",
      "",
      "[Removed Lines]",
      "187: static void SRP_user_pwd_free(SRP_user_pwd *user_pwd)",
      "",
      "[Added Lines]",
      "187: void SRP_user_pwd_free(SRP_user_pwd *user_pwd)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "246:     return (vinfo->s != NULL && vinfo->v != NULL);",
      "247: }",
      "249: SRP_VBASE *SRP_VBASE_new(char *seed_key)",
      "250: {",
      "251:     SRP_VBASE *vb = OPENSSL_malloc(sizeof(*vb));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "249: static SRP_user_pwd *srp_user_pwd_dup(SRP_user_pwd *src)",
      "250: {",
      "251:     SRP_user_pwd *ret;",
      "253:     if (src == NULL)",
      "254:         return NULL;",
      "255:     if ((ret = SRP_user_pwd_new()) == NULL)",
      "256:         return NULL;",
      "258:     SRP_user_pwd_set_gN(ret, src->g, src->N);",
      "259:     if (!SRP_user_pwd_set_ids(ret, src->id, src->info)",
      "260:         || !SRP_user_pwd_set_sv_BN(ret, BN_dup(src->s), BN_dup(src->v))) {",
      "261:             SRP_user_pwd_free(ret);",
      "262:             return NULL;",
      "263:     }",
      "264:     return ret;",
      "265: }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "468: }",
      "471: {",
      "472:     int i;",
      "473:     SRP_user_pwd *user;",
      "478:     if (vb == NULL)",
      "479:         return NULL;",
      "480:     for (i = 0; i < sk_SRP_user_pwd_num(vb->users_pwd); i++) {",
      "481:         user = sk_SRP_user_pwd_value(vb->users_pwd, i);",
      "482:         if (strcmp(user->id, username) == 0)",
      "483:             return user;",
      "484:     }",
      "485:     if ((vb->seed_key == NULL) ||",
      "486:         (vb->default_g == NULL) || (vb->default_N == NULL))",
      "487:         return NULL;",
      "",
      "[Removed Lines]",
      "470: SRP_user_pwd *SRP_VBASE_get_by_user(SRP_VBASE *vb, char *username)",
      "474:     unsigned char digv[SHA_DIGEST_LENGTH];",
      "475:     unsigned char digs[SHA_DIGEST_LENGTH];",
      "476:     EVP_MD_CTX *ctxt = NULL;",
      "",
      "[Added Lines]",
      "488: static SRP_user_pwd *find_user(SRP_VBASE *vb, char *username)",
      "502:     return NULL;",
      "503: }",
      "511: SRP_user_pwd *SRP_VBASE_get_by_user(SRP_VBASE *vb, char *username)",
      "512: {",
      "513:     return find_user(vb, username);",
      "514: }",
      "520: SRP_user_pwd *SRP_VBASE_get1_by_user(SRP_VBASE *vb, char *username)",
      "521: {",
      "522:     SRP_user_pwd *user;",
      "523:     unsigned char digv[SHA_DIGEST_LENGTH];",
      "524:     unsigned char digs[SHA_DIGEST_LENGTH];",
      "525:     EVP_MD_CTX *ctxt = NULL;",
      "527:     if (vb == NULL)",
      "528:         return NULL;",
      "530:     if ((user = find_user(vb, username)) != NULL)",
      "531:         return srp_user_pwd_dup(user);",
      "",
      "---------------"
    ],
    "include/openssl/srp.h||include/openssl/srp.h": [
      "File: include/openssl/srp.h -> include/openssl/srp.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "85: DEFINE_STACK_OF(SRP_gN_cache)",
      "87: typedef struct SRP_user_pwd_st {",
      "88:     char *id;",
      "89:     BIGNUM *s;",
      "90:     BIGNUM *v;",
      "91:     const BIGNUM *g;",
      "92:     const BIGNUM *N;",
      "93:     char *info;",
      "94: } SRP_user_pwd;",
      "96: DEFINE_STACK_OF(SRP_user_pwd)",
      "98: typedef struct SRP_VBASE_st {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "99: void SRP_user_pwd_free(SRP_user_pwd *user_pwd);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "118: SRP_VBASE *SRP_VBASE_new(char *seed_key);",
      "119: void SRP_VBASE_free(SRP_VBASE *vb);",
      "120: int SRP_VBASE_init(SRP_VBASE *vb, char *verifier_file);",
      "122: char *SRP_create_verifier(const char *user, const char *pass, char **salt,",
      "123:                           char **verifier, const char *N, const char *g);",
      "124: int SRP_create_verifier_BN(const char *user, const char *pass, BIGNUM **salt,",
      "",
      "[Removed Lines]",
      "121: SRP_user_pwd *SRP_VBASE_get_by_user(SRP_VBASE *vb, char *username);",
      "",
      "[Added Lines]",
      "128: DEPRECATEDIN_1_1_0(SRP_user_pwd *SRP_VBASE_get_by_user(SRP_VBASE *vb, char *username))",
      "130: SRP_user_pwd *SRP_VBASE_get1_by_user(SRP_VBASE *vb, char *username);",
      "",
      "---------------"
    ],
    "util/libeay.num||util/libeay.num": [
      "File: util/libeay.num -> util/libeay.num",
      "--- Hunk 1 ---",
      "[Context before]",
      "4073: OPENSSL_strncasecmp                     4566 1_1_0 EXIST::FUNCTION:",
      "4074: OPENSSL_gmtime                          4567 1_1_0 EXIST::FUNCTION:",
      "4075: OPENSSL_gmtime_adj                      4568 1_1_0 EXIST::FUNCTION:",
      "4077: SRP_Calc_server_key                     4570 1_1_0 EXIST::FUNCTION:SRP",
      "4078: SRP_create_verifier                     4571 1_1_0 EXIST::FUNCTION:SRP",
      "4079: SRP_create_verifier_BN                  4572 1_1_0 EXIST::FUNCTION:SRP",
      "",
      "[Removed Lines]",
      "4076: SRP_VBASE_get_by_user                   4569 1_1_0 EXIST::FUNCTION:SRP",
      "",
      "[Added Lines]",
      "4076: SRP_VBASE_get_by_user                   4569 1_1_0 EXIST::FUNCTION:DEPRECATEDIN_1_1_0,SRP",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "4711: OPENSSL_INIT_new                        5215 1_1_0 EXIST::FUNCTION:",
      "4712: OPENSSL_INIT_free                       5216 1_1_0 EXIST::FUNCTION:",
      "4713: OPENSSL_INIT_set_config_filename        5217 1_1_0 EXIST::FUNCTION:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4714: SRP_user_pwd_free                       5218 1_1_0 EXIST::FUNCTION:SRP",
      "4715: SRP_VBASE_get1_by_user                  5219 1_1_0 EXIST::FUNCTION:SRP",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "df04754be7a73cbe813cb58f2f7b42d8e3402c56",
      "candidate_info": {
        "commit_hash": "df04754be7a73cbe813cb58f2f7b42d8e3402c56",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/df04754be7a73cbe813cb58f2f7b42d8e3402c56",
        "files": [
          "util/libeay.num"
        ],
        "message": "make update\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
        "before_after_code_files": [
          "util/libeay.num||util/libeay.num"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "util/libeay.num||util/libeay.num"
          ],
          "candidate": [
            "util/libeay.num||util/libeay.num"
          ]
        }
      },
      "candidate_diff": {
        "util/libeay.num||util/libeay.num": [
          "File: util/libeay.num -> util/libeay.num",
          "--- Hunk 1 ---",
          "[Context before]",
          "302: EVP_des_ofb                             310 EXIST::FUNCTION:DES",
          "303: EVP_desx_cbc                            311 EXIST::FUNCTION:DES",
          "304: EVP_dss                                 312 NOEXIST::FUNCTION:",
          "306: EVP_enc_null                            314 EXIST::FUNCTION:",
          "307: EVP_get_cipherbyname                    315 EXIST::FUNCTION:",
          "308: EVP_get_digestbyname                    316 EXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "305: EVP_dss1                                313 EXIST::FUNCTION:DSA",
          "",
          "[Added Lines]",
          "305: EVP_dss1                                313 NOEXIST::FUNCTION:",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3320: EVP_PKEY_get_attr_by_NID                3721 EXIST::FUNCTION:",
          "3321: STORE_set_ex_data                       3722 NOEXIST::FUNCTION:",
          "3322: ENGINE_get_ECDSA                        3723 EXIST::FUNCTION:ENGINE",
          "3324: BN_BLINDING_get_flags                   3725 EXIST::FUNCTION:",
          "3325: PKCS12_add_cert                         3726 EXIST::FUNCTION:",
          "3326: STORE_OBJECT_new                        3727 NOEXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "3323: EVP_ecdsa                               3724 EXIST::FUNCTION:",
          "",
          "[Added Lines]",
          "3323: EVP_ecdsa                               3724 NOEXIST::FUNCTION:",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "501083049590455b1862edd7573fd51bb37bb037",
      "candidate_info": {
        "commit_hash": "501083049590455b1862edd7573fd51bb37bb037",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/501083049590455b1862edd7573fd51bb37bb037",
        "files": [
          "crypto/async/Makefile",
          "crypto/async/arch/async_posix.c",
          "crypto/async/arch/async_posix.h",
          "crypto/async/arch/async_win.c",
          "crypto/async/arch/async_win.h",
          "crypto/async/async.c",
          "crypto/async/async_locl.h",
          "include/openssl/async.h",
          "util/indent.pro",
          "util/libeay.num"
        ],
        "message": "Async port to windows\n\nReviewed-by: Rich Salz <rsalz@openssl.org>",
        "before_after_code_files": [
          "crypto/async/arch/async_posix.c||crypto/async/arch/async_posix.c",
          "crypto/async/arch/async_posix.h||crypto/async/arch/async_posix.h",
          "crypto/async/arch/async_win.c||crypto/async/arch/async_win.c",
          "crypto/async/arch/async_win.h||crypto/async/arch/async_win.h",
          "crypto/async/async.c||crypto/async/async.c",
          "crypto/async/async_locl.h||crypto/async/async_locl.h",
          "include/openssl/async.h||include/openssl/async.h",
          "util/indent.pro||util/indent.pro",
          "util/libeay.num||util/libeay.num"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "util/libeay.num||util/libeay.num"
          ],
          "candidate": [
            "util/libeay.num||util/libeay.num"
          ]
        }
      },
      "candidate_diff": {
        "crypto/async/arch/async_posix.c||crypto/async/arch/async_posix.c": [
          "File: crypto/async/arch/async_posix.c -> crypto/async/arch/async_posix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "54: #include \"../async_locl.h\"",
          "55: #include <openssl/async.h>",
          "57: #ifdef ASYNC_SYSV",
          "58: # include <stddef.h>",
          "59: # include <ucontext.h>",
          "60: # include <openssl/crypto.h>",
          "61: # include <openssl/async.h>",
          "63: __thread ASYNC_CTX *sysvctx;",
          "65: int ASYNC_FIBRE_init(ASYNC_FIBRE *fibre)",
          "66: {",
          "67:     void *stack = NULL;",
          "69:     if (!(stack = OPENSSL_malloc(SIGSTKSZ))) {",
          "70:         return 0;",
          "71:     }",
          "73:     fibre->fibre.uc_stack.ss_sp = stack;",
          "74:     fibre->fibre.uc_stack.ss_size = SIGSTKSZ;",
          "75:     fibre->fibre.uc_link = NULL;",
          "77:     return 1;",
          "78: }",
          "80: void ASYNC_FIBRE_free(ASYNC_FIBRE *fibre)",
          "81: {",
          "82:     if (fibre->fibre.uc_stack.ss_sp)",
          "83:         OPENSSL_free(fibre->fibre.uc_stack.ss_sp);",
          "84: }",
          "85: #endif",
          "",
          "---------------"
        ],
        "crypto/async/arch/async_posix.h||crypto/async/arch/async_posix.h": [
          "File: crypto/async/arch/async_posix.h -> crypto/async/arch/async_posix.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "53: #include <openssl/e_os2.h>",
          "55: #ifdef OPENSSL_SYS_UNIX",
          "57: # include <unistd.h>",
          "59: # if _POSIX_VERSION >= 200112L",
          "61: #  define ASYNC_SYSV",
          "62: #  define ASYNC_ARCH",
          "64: #  include <ucontext.h>",
          "66: extern __thread ASYNC_CTX *sysvctx;",
          "68: typedef struct async_fibre_st {",
          "69:     ucontext_t fibre;",
          "70: } ASYNC_FIBRE;",
          "72: #  define ASYNC_set_ctx(nctx)             (sysvctx = (nctx))",
          "73: #  define ASYNC_get_ctx()                 (sysvctx)",
          "74: #  define ASYNC_FIBRE_swapcontext(o,n,r) \\",
          "75:             ((r)? \\",
          "76:                 !swapcontext(&(o)->fibre, &(n)->fibre) \\",
          "77:             : \\",
          "78:                 !setcontext(&(n)->fibre))",
          "79: #  define ASYNC_FIBRE_makecontext(c) \\",
          "80:             (ASYNC_FIBRE_init(c) \\",
          "81:             && !getcontext(&(c)->fibre) \\",
          "82:             && (makecontext(&(c)->fibre, ASYNC_start_func, 0), 1))",
          "83: #  define ASYNC_FIBRE_init_dispatcher(d)",
          "85: int ASYNC_FIBRE_init(ASYNC_FIBRE *fibre);",
          "86: void ASYNC_FIBRE_free(ASYNC_FIBRE *fibre);",
          "88: # endif",
          "89: #endif",
          "",
          "---------------"
        ],
        "crypto/async/arch/async_win.c||crypto/async/arch/async_win.c": [
          "File: crypto/async/arch/async_win.c -> crypto/async/arch/async_win.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "54: #include \"async_win.h\"",
          "56: #ifdef ASYNC_WIN",
          "58: # include <windows.h>",
          "59: # include \"cryptlib.h\"",
          "61: void ASYNC_start_func(void);",
          "63: int ASYNC_FIBRE_init_dispatcher(ASYNC_FIBRE *fibre)",
          "64: {",
          "65:     LPVOID dispatcher;",
          "67:     dispatcher =",
          "68:         (LPVOID) CRYPTO_get_thread_local(CRYPTO_THREAD_LOCAL_ASYNC_DISPATCH);",
          "69:     if (!dispatcher) {",
          "70:         fibre->fibre = ConvertThreadToFiber(NULL);",
          "71:         CRYPTO_set_thread_local(CRYPTO_THREAD_LOCAL_ASYNC_DISPATCH,",
          "72:                                 (void *)fibre->fibre);",
          "73:     } else {",
          "74:         fibre->fibre = dispatcher;",
          "75:     }",
          "76:     return 1;",
          "77: }",
          "79: VOID CALLBACK ASYNC_start_func_win(PVOID unused)",
          "80: {",
          "81:     ASYNC_start_func();",
          "82: }",
          "84: #endif",
          "",
          "---------------"
        ],
        "crypto/async/arch/async_win.h||crypto/async/arch/async_win.h": [
          "File: crypto/async/arch/async_win.h -> crypto/async/arch/async_win.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "54: #include <openssl/async.h>",
          "60: #if defined(_WIN32) || defined(__CYGWIN__)",
          "61: # define ASYNC_WIN",
          "62: # define ASYNC_ARCH",
          "64: # include <windows.h>",
          "65: # include \"cryptlib.h\"",
          "67: typedef struct async_fibre_st {",
          "68:     LPVOID fibre;",
          "69: } ASYNC_FIBRE;",
          "71: # define ASYNC_set_ctx(nctx) \\",
          "72:         (CRYPTO_set_thread_local(CRYPTO_THREAD_LOCAL_ASYNC_CTX, (void *)(nctx)))",
          "73: # define ASYNC_get_ctx() \\",
          "74:         ((ASYNC_CTX *)CRYPTO_get_thread_local(CRYPTO_THREAD_LOCAL_ASYNC_CTX))",
          "75: # define ASYNC_FIBRE_swapcontext(o,n,r) \\",
          "76:         (SwitchToFiber((n)->fibre), 1)",
          "77: # define ASYNC_FIBRE_makecontext(c) \\",
          "78:         ((c)->fibre = CreateFiber(0, ASYNC_start_func_win, 0))",
          "79: # define ASYNC_FIBRE_free(f)             (DeleteFiber((f)->fibre))",
          "81: int ASYNC_FIBRE_init_dispatcher(ASYNC_FIBRE *fibre);",
          "82: VOID CALLBACK ASYNC_start_func_win(PVOID unused);",
          "84: #endif",
          "",
          "---------------"
        ],
        "crypto/async/async.c||crypto/async/async.c": [
          "File: crypto/async/async.c -> crypto/async/async.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "54: #include <openssl/crypto.h>",
          "55: #include <openssl/async.h>",
          "57: #include <string.h>",
          "59: #define ASYNC_JOB_RUNNING   0",
          "60: #define ASYNC_JOB_PAUSING   1",
          "",
          "[Removed Lines]",
          "56: #include <ucontext.h>",
          "",
          "[Added Lines]",
          "57: #include \"async_locl.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "62: #define ASYNC_JOB_STOPPING  3",
          "81: static ASYNC_CTX *ASYNC_CTX_new(void)",
          "82: {",
          "83:     ASYNC_CTX *nctx = NULL;",
          "",
          "[Removed Lines]",
          "65: typedef struct async_ctx_st {",
          "66:     ucontext_t dispatcher;",
          "67:     ASYNC_JOB *currjob;",
          "68: } ASYNC_CTX;",
          "70: __thread ASYNC_CTX *ctx;",
          "72: struct async_job_st {",
          "73:     ucontext_t fibrectx;",
          "74:     int (*func)(void *);",
          "75:     void *funcargs;",
          "76:     int ret;",
          "77:     int status;",
          "78: };",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "87:         goto err;",
          "88:     }",
          "90:     nctx->currjob = NULL;",
          "93:     return nctx;",
          "94: err:",
          "",
          "[Removed Lines]",
          "91:     ctx = nctx;",
          "",
          "[Added Lines]",
          "74:     ASYNC_FIBRE_init_dispatcher(&nctx->dispatcher);",
          "76:     ASYNC_set_ctx(nctx);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "102: static int ASYNC_CTX_free(void)",
          "103: {",
          "106:     }",
          "110:     return 1;",
          "111: }",
          "",
          "[Removed Lines]",
          "104:     if(ctx) {",
          "105:         OPENSSL_free(ctx);",
          "108:     ctx = NULL;",
          "",
          "[Added Lines]",
          "89:     if(ASYNC_get_ctx()) {",
          "90:         OPENSSL_free(ASYNC_get_ctx());",
          "93:     ASYNC_set_ctx(NULL);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "113: static ASYNC_JOB *ASYNC_JOB_new(void)",
          "114: {",
          "115:     ASYNC_JOB *job = NULL;",
          "118:     if(!(job = OPENSSL_malloc(sizeof (ASYNC_JOB)))) {",
          "120:     }",
          "130:     job->status = ASYNC_JOB_RUNNING;",
          "131:     job->funcargs = NULL;",
          "133:     return job;",
          "141: }",
          "143: static void ASYNC_JOB_free(ASYNC_JOB *job)",
          "",
          "[Removed Lines]",
          "116:     void *stack = NULL;",
          "119:         goto err;",
          "122:     if(!(stack = OPENSSL_malloc(SIGSTKSZ))) {",
          "123:         goto err;",
          "124:     }",
          "125:     if(getcontext(&job->fibrectx))",
          "126:         goto err;",
          "127:     job->fibrectx.uc_stack.ss_sp = stack;",
          "128:     job->fibrectx.uc_stack.ss_size = SIGSTKSZ;",
          "129:     job->fibrectx.uc_link = NULL;",
          "134: err:",
          "135:     if(job) {",
          "136:         if(stack)",
          "137:             OPENSSL_free(stack);",
          "138:         OPENSSL_free(job);",
          "139:     }",
          "140:     return NULL;",
          "",
          "[Added Lines]",
          "103:         return NULL;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "145:     if(job) {",
          "146:         if(job->funcargs)",
          "147:             OPENSSL_free(job->funcargs);",
          "150:         OPENSSL_free(job);",
          "151:     }",
          "152: }",
          "155: {",
          "156:     ASYNC_JOB *job;",
          "160:     job->ret = job->func(job->funcargs);",
          "163:     job->status = ASYNC_JOB_STOPPING;",
          "170: }",
          "172: int ASYNC_start_job(ASYNC_JOB **job, int *ret, int (*func)(void *),",
          "173:                          void *args, size_t size)",
          "174: {",
          "176:         return ASYNC_ERR;",
          "177:     }",
          "179:     if(*job) {",
          "181:     }",
          "190:             ASYNC_CTX_free();",
          "192:         }",
          "197:             ASYNC_CTX_free();",
          "199:         }",
          "206:         }",
          "232:     }",
          "241:     ASYNC_CTX_free();",
          "242:     return ASYNC_ERR;",
          "243: }",
          "",
          "[Removed Lines]",
          "148:         if(job->fibrectx.uc_stack.ss_sp)",
          "149:             OPENSSL_free(job->fibrectx.uc_stack.ss_sp);",
          "154: static void ASYNC_start_func(void)",
          "159:     job = ctx->currjob;",
          "164:     setcontext(&ctx->dispatcher);",
          "175:     if(ctx || !ASYNC_CTX_new()) {",
          "180:         ctx->currjob = *job;",
          "183:     getcontext(&ctx->dispatcher);",
          "185:     if(ctx->currjob) {",
          "186:         if(ctx->currjob->status == ASYNC_JOB_STOPPING) {",
          "188:             ASYNC_JOB_free(ctx->currjob);",
          "189:             ctx->currjob = NULL;",
          "191:             return ASYNC_FINISH;",
          "194:         if(ctx->currjob->status == ASYNC_JOB_PAUSING) {",
          "196:             ctx->currjob->status = ASYNC_JOB_PAUSED;",
          "198:             return ASYNC_PAUSE;",
          "201:         if(ctx->currjob->status == ASYNC_JOB_PAUSED) {",
          "202:             ctx->currjob = *job;",
          "204:             setcontext(&ctx->currjob->fibrectx);",
          "209:         ASYNC_JOB_free(ctx->currjob);",
          "210:         ctx->currjob = NULL;",
          "211:         ASYNC_CTX_free();",
          "212:         return ASYNC_ERR;",
          "213:     }",
          "216:     if(!(ctx->currjob = ASYNC_JOB_new())) {",
          "217:         ASYNC_CTX_free();",
          "218:         return ASYNC_ERR;",
          "219:     }",
          "221:     if(args != NULL) {",
          "222:         ctx->currjob->funcargs = OPENSSL_malloc(size);",
          "223:         if(!ctx->currjob->funcargs) {",
          "224:             ASYNC_JOB_free(ctx->currjob);",
          "225:             ctx->currjob = NULL;",
          "226:             ASYNC_CTX_free();",
          "227:             return ASYNC_ERR;",
          "228:         }",
          "229:         memcpy(ctx->currjob->funcargs, args, size);",
          "230:     } else {",
          "231:         ctx->currjob->funcargs = NULL;",
          "234:     ctx->currjob->func = func;",
          "235:     makecontext(&ctx->currjob->fibrectx, ASYNC_start_func, 0);",
          "236:     setcontext(&ctx->currjob->fibrectx);",
          "239:     ASYNC_JOB_free(ctx->currjob);",
          "240:     ctx->currjob = NULL;",
          "",
          "[Added Lines]",
          "117:         ASYNC_FIBRE_free(&job->fibrectx);",
          "122: void ASYNC_start_func(void)",
          "127:     job = ASYNC_get_ctx()->currjob;",
          "132:     if(!ASYNC_FIBRE_swapcontext(&job->fibrectx,",
          "133:                                 &ASYNC_get_ctx()->dispatcher, 0)) {",
          "138:     }",
          "144:     if(ASYNC_get_ctx() || !ASYNC_CTX_new()) {",
          "149:         ASYNC_get_ctx()->currjob = *job;",
          "152:     for (;;) {",
          "153:         if(ASYNC_get_ctx()->currjob) {",
          "154:             if(ASYNC_get_ctx()->currjob->status == ASYNC_JOB_STOPPING) {",
          "156:                 ASYNC_JOB_free(ASYNC_get_ctx()->currjob);",
          "157:                 ASYNC_get_ctx()->currjob = NULL;",
          "158:                 ASYNC_CTX_free();",
          "159:                 return ASYNC_FINISH;",
          "160:             }",
          "162:             if(ASYNC_get_ctx()->currjob->status == ASYNC_JOB_PAUSING) {",
          "164:                 ASYNC_get_ctx()->currjob->status = ASYNC_JOB_PAUSED;",
          "165:                 ASYNC_CTX_free();",
          "166:                 return ASYNC_PAUSE;",
          "167:             }",
          "169:             if(ASYNC_get_ctx()->currjob->status == ASYNC_JOB_PAUSED) {",
          "170:                 ASYNC_get_ctx()->currjob = *job;",
          "172:                 if(!ASYNC_FIBRE_swapcontext(&ASYNC_get_ctx()->dispatcher,",
          "173:                     &ASYNC_get_ctx()->currjob->fibrectx, 1))",
          "174:                     goto err;",
          "175:                 continue;",
          "176:             }",
          "179:             ASYNC_JOB_free(ASYNC_get_ctx()->currjob);",
          "180:             ASYNC_get_ctx()->currjob = NULL;",
          "182:             return ASYNC_ERR;",
          "186:         if(!(ASYNC_get_ctx()->currjob = ASYNC_JOB_new())) {",
          "188:             return ASYNC_ERR;",
          "191:         if(args != NULL) {",
          "192:             ASYNC_get_ctx()->currjob->funcargs = OPENSSL_malloc(size);",
          "193:             if(!ASYNC_get_ctx()->currjob->funcargs) {",
          "194:                 ASYNC_JOB_free(ASYNC_get_ctx()->currjob);",
          "195:                 ASYNC_get_ctx()->currjob = NULL;",
          "196:                 ASYNC_CTX_free();",
          "197:                 return ASYNC_ERR;",
          "198:             }",
          "199:             memcpy(ASYNC_get_ctx()->currjob->funcargs, args, size);",
          "200:         } else {",
          "201:             ASYNC_get_ctx()->currjob->funcargs = NULL;",
          "204:         ASYNC_get_ctx()->currjob->func = func;",
          "205:         ASYNC_FIBRE_makecontext(&ASYNC_get_ctx()->currjob->fibrectx);",
          "206:         if(!ASYNC_FIBRE_swapcontext(&ASYNC_get_ctx()->dispatcher,",
          "207:             &ASYNC_get_ctx()->currjob->fibrectx, 1))",
          "208:             goto err;",
          "211: err:",
          "212:     ASYNC_JOB_free(ASYNC_get_ctx()->currjob);",
          "213:     ASYNC_get_ctx()->currjob = NULL;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "247: {",
          "248:     ASYNC_JOB *job;",
          "251:         return 0;",
          "254:     job->status = ASYNC_JOB_PAUSING;",
          "258:         return 0;",
          "259:     }",
          "",
          "[Removed Lines]",
          "250:     if(!ctx || !ctx->currjob)",
          "253:     job = ctx->currjob;",
          "256:     if(swapcontext(&job->fibrectx, &ctx->dispatcher)) {",
          "",
          "[Added Lines]",
          "223:     if(!ASYNC_get_ctx() || !ASYNC_get_ctx()->currjob)",
          "226:     job = ASYNC_get_ctx()->currjob;",
          "229:     if(!ASYNC_FIBRE_swapcontext(&job->fibrectx,",
          "230:                                &ASYNC_get_ctx()->dispatcher, 1)) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "264: int ASYNC_in_job(void)",
          "265: {",
          "267:         return 1;",
          "269:     return 0;",
          "",
          "[Removed Lines]",
          "266:     if(ctx)",
          "",
          "[Added Lines]",
          "240:     if(ASYNC_get_ctx())",
          "",
          "---------------"
        ],
        "crypto/async/async_locl.h||crypto/async/async_locl.h": [
          "File: crypto/async/async_locl.h -> crypto/async/async_locl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "54: #include <openssl/async.h>",
          "56: typedef struct async_ctx_st ASYNC_CTX;",
          "58: #include \"arch/async_win.h\"",
          "59: #include \"arch/async_posix.h\"",
          "61: #ifndef ASYNC_ARCH",
          "62: # error Failed to detect async arch",
          "63: #endif",
          "65: struct async_ctx_st {",
          "66:     ASYNC_FIBRE dispatcher;",
          "67:     ASYNC_JOB *currjob;",
          "68: };",
          "70: struct async_job_st {",
          "71:     ASYNC_FIBRE fibrectx;",
          "72:     int (*func) (void *);",
          "73:     void *funcargs;",
          "74:     int ret;",
          "75:     int status;",
          "76: };",
          "78: void ASYNC_start_func(void);",
          "",
          "---------------"
        ],
        "include/openssl/async.h||include/openssl/async.h": [
          "File: include/openssl/async.h -> include/openssl/async.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "54: #ifndef HEADER_ASYNC_H",
          "55: # define HEADER_ASYNC_H",
          "57: # ifdef  __cplusplus",
          "58: extern \"C\" {",
          "59: # endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "57: #include <stdlib.h>",
          "",
          "---------------"
        ],
        "util/indent.pro||util/indent.pro": [
          "File: util/indent.pro -> util/indent.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "731: -T SH_LIST",
          "732: -T PACKET",
          "733: -T RECORD_LAYER",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "734: -T ASYNC_FIBRE",
          "735: -T ASYNC_CTX",
          "736: -T ASYNC_JOB",
          "",
          "---------------"
        ],
        "util/libeay.num||util/libeay.num": [
          "File: util/libeay.num -> util/libeay.num",
          "--- Hunk 1 ---",
          "[Context before]",
          "4650: TS_RESP_CTX_set_signer_digest           5010 EXIST::FUNCTION:",
          "4651: TS_CONF_set_signer_digest               5011 EXIST::FUNCTION:",
          "4652: ENGINE_load_dasync                      5012 EXIST::FUNCTION:ENGINE,STATIC_ENGINE",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4653: ASYNC_pause_job                         5013 EXIST::FUNCTION:",
          "4654: ASYNC_job_is_waiting                    5014 EXIST::FUNCTION:",
          "4655: ASYNC_in_job                            5015 EXIST::FUNCTION:",
          "4656: ASYNC_start_job                         5016 EXIST::FUNCTION:",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b1f3442857c1fd76e91941141bf671d19e90a79d",
      "candidate_info": {
        "commit_hash": "b1f3442857c1fd76e91941141bf671d19e90a79d",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/b1f3442857c1fd76e91941141bf671d19e90a79d",
        "files": [
          "crypto/asn1/x_pkey.c",
          "crypto/x509/x509.h",
          "util/libeay.num"
        ],
        "message": "Remove d2i_X509_PKEY and i2d_X509_PKEY\n\nRemove partially implemented d2i_X509_PKEY and i2d_X509_PKEY: nothing\nuses them and they don't work properly. Update ordinals.\n\nReviewed-by: Kurt Roeckx <kurt@openssl.org>",
        "before_after_code_files": [
          "crypto/asn1/x_pkey.c||crypto/asn1/x_pkey.c",
          "crypto/x509/x509.h||crypto/x509/x509.h",
          "util/libeay.num||util/libeay.num"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "util/libeay.num||util/libeay.num"
          ],
          "candidate": [
            "util/libeay.num||util/libeay.num"
          ]
        }
      },
      "candidate_diff": {
        "crypto/asn1/x_pkey.c||crypto/asn1/x_pkey.c": [
          "File: crypto/asn1/x_pkey.c -> crypto/asn1/x_pkey.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "63: #include <openssl/asn1_mac.h>",
          "64: #include <openssl/x509.h>",
          "104: X509_PKEY *X509_PKEY_new(void)",
          "105: {",
          "106:     X509_PKEY *ret = NULL;",
          "",
          "[Removed Lines]",
          "67: int i2d_X509_PKEY(X509_PKEY *a, unsigned char **pp)",
          "68: {",
          "69:     return (0);",
          "70: }",
          "72: X509_PKEY *d2i_X509_PKEY(X509_PKEY **a, const unsigned char **pp, long length)",
          "73: {",
          "74:     int i;",
          "75:     M_ASN1_D2I_vars(a, X509_PKEY *, X509_PKEY_new);",
          "77:     M_ASN1_D2I_Init();",
          "78:     M_ASN1_D2I_start_sequence();",
          "79:     M_ASN1_D2I_get_x(X509_ALGOR, ret->enc_algor, d2i_X509_ALGOR);",
          "80:     M_ASN1_D2I_get_x(ASN1_OCTET_STRING, ret->enc_pkey, d2i_ASN1_OCTET_STRING);",
          "82:     ret->cipher.cipher =",
          "83:         EVP_get_cipherbyname(OBJ_nid2ln",
          "84:                              (OBJ_obj2nid(ret->enc_algor->algorithm)));",
          "85:     if (ret->cipher.cipher == NULL) {",
          "86:         c.error = ASN1_R_UNSUPPORTED_CIPHER;",
          "87:         c.line = __LINE__;",
          "88:         goto err;",
          "89:     }",
          "90:     if (ret->enc_algor->parameter->type == V_ASN1_OCTET_STRING) {",
          "91:         i = ret->enc_algor->parameter->value.octet_string->length;",
          "92:         if (i > EVP_MAX_IV_LENGTH) {",
          "93:             c.error = ASN1_R_IV_TOO_LARGE;",
          "94:             c.line = __LINE__;",
          "95:             goto err;",
          "96:         }",
          "97:         memcpy(ret->cipher.iv,",
          "98:                ret->enc_algor->parameter->value.octet_string->data, i);",
          "99:     } else",
          "100:         memset(ret->cipher.iv, 0, EVP_MAX_IV_LENGTH);",
          "101:     M_ASN1_D2I_Finish(a, X509_PKEY_free, ASN1_F_D2I_X509_PKEY);",
          "102: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "crypto/x509/x509.h||crypto/x509/x509.h": [
          "File: crypto/x509/x509.h -> crypto/x509/x509.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "783: X509_PKEY *X509_PKEY_new(void);",
          "784: void X509_PKEY_free(X509_PKEY *a);",
          "789: DECLARE_ASN1_FUNCTIONS(NETSCAPE_SPKI)",
          "790: DECLARE_ASN1_FUNCTIONS(NETSCAPE_SPKAC)",
          "",
          "[Removed Lines]",
          "785: int i2d_X509_PKEY(X509_PKEY *a, unsigned char **pp);",
          "786: X509_PKEY *d2i_X509_PKEY(X509_PKEY **a, const unsigned char **pp,",
          "787:                          long length);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "util/libeay.num||util/libeay.num": [
          "File: util/libeay.num -> util/libeay.num",
          "--- Hunk 1 ---",
          "[Context before]",
          "755: d2i_X509_EXTENSION                      762 EXIST::FUNCTION:",
          "756: d2i_X509_NAME                           763 EXIST::FUNCTION:",
          "757: d2i_X509_NAME_ENTRY                     764 EXIST::FUNCTION:",
          "759: d2i_X509_PUBKEY                         766 EXIST::FUNCTION:",
          "760: d2i_X509_REQ                            767 EXIST::FUNCTION:",
          "761: d2i_X509_REQ_INFO                       768 EXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "758: d2i_X509_PKEY                           765 EXIST::FUNCTION:",
          "",
          "[Added Lines]",
          "758: d2i_X509_PKEY                           765 NOEXIST::FUNCTION:",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "857: i2d_X509_EXTENSION                      865 EXIST::FUNCTION:",
          "858: i2d_X509_NAME                           866 EXIST::FUNCTION:",
          "859: i2d_X509_NAME_ENTRY                     867 EXIST::FUNCTION:",
          "861: i2d_X509_PUBKEY                         869 EXIST::FUNCTION:",
          "862: i2d_X509_REQ                            870 EXIST::FUNCTION:",
          "863: i2d_X509_REQ_INFO                       871 EXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "860: i2d_X509_PKEY                           868 EXIST::FUNCTION:",
          "",
          "[Added Lines]",
          "860: i2d_X509_PKEY                           868 NOEXIST::FUNCTION:",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7e5363abe3c00d9db037f464f3c121e194bb5bb6",
      "candidate_info": {
        "commit_hash": "7e5363abe3c00d9db037f464f3c121e194bb5bb6",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/7e5363abe3c00d9db037f464f3c121e194bb5bb6",
        "files": [
          "crypto/cpt_err.c",
          "crypto/engine/eng_dyn.c",
          "crypto/ex_data.c",
          "include/openssl/crypto.h",
          "include/openssl/engine.h",
          "include/openssl/safestack.h",
          "include/openssl/symhacks.h",
          "util/libeay.num"
        ],
        "message": "Rewrite crypto/ex_data\n\nRemoved ability to set ex_data impl at runtime.  This removed these\nthree functions:\n    const CRYPTO_EX_DATA_IMPL *CRYPTO_get_ex_data_implementation(void);\n    int CRYPTO_set_ex_data_implementation(const CRYPTO_EX_DATA_IMPL *i);\n    int CRYPTO_ex_data_new_class(void);\nIt is no longer possible to change the ex_data implementation at\nruntime.  (Luckily those functions were never documented :)\n\nAlso removed the ability to add new exdata \"classes.\"  We don't believe\nthis received much (if any) use, since you can't add it to OpenSSL objects,\nand there are probably better (native) methods for developers to add\ntheir own extensible data, if they really need that.\n\nReplaced the internal hash table (of per-\"class\" stacks) with a simple\nindexed array.  Reserved an index for \"app\" application.\n\nEach API used to take the lock twice; now it only locks once.\n\nUse local stack storage for function pointers, rather than malloc,\nif possible (i.e., number of ex_data items is under a dozen).\n\nMake CRYPTO_EX_DATA_FUNCS opaque/internal.\n\nAlso fixes RT3710; index zero is reserved.\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
        "before_after_code_files": [
          "crypto/cpt_err.c||crypto/cpt_err.c",
          "crypto/engine/eng_dyn.c||crypto/engine/eng_dyn.c",
          "crypto/ex_data.c||crypto/ex_data.c",
          "include/openssl/crypto.h||include/openssl/crypto.h",
          "include/openssl/engine.h||include/openssl/engine.h",
          "include/openssl/safestack.h||include/openssl/safestack.h",
          "include/openssl/symhacks.h||include/openssl/symhacks.h",
          "util/libeay.num||util/libeay.num"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "util/libeay.num||util/libeay.num"
          ],
          "candidate": [
            "util/libeay.num||util/libeay.num"
          ]
        }
      },
      "candidate_diff": {
        "crypto/cpt_err.c||crypto/cpt_err.c": [
          "File: crypto/cpt_err.c -> crypto/cpt_err.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "70: # define ERR_REASON(reason) ERR_PACK(ERR_LIB_CRYPTO,0,reason)",
          "72: static ERR_STRING_DATA CRYPTO_str_functs[] = {",
          "73:     {ERR_FUNC(CRYPTO_F_CRYPTO_GET_EX_NEW_INDEX), \"CRYPTO_get_ex_new_index\"},",
          "74:     {ERR_FUNC(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID), \"CRYPTO_get_new_dynlockid\"},",
          "75:     {ERR_FUNC(CRYPTO_F_CRYPTO_GET_NEW_LOCKID), \"CRYPTO_get_new_lockid\"},",
          "76:     {ERR_FUNC(CRYPTO_F_CRYPTO_SET_EX_DATA), \"CRYPTO_set_ex_data\"},",
          "77:     {ERR_FUNC(CRYPTO_F_DEF_ADD_INDEX), \"DEF_ADD_INDEX\"},",
          "78:     {ERR_FUNC(CRYPTO_F_DEF_GET_CLASS), \"DEF_GET_CLASS\"},",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "73:     {ERR_FUNC(CRYPTO_F_CRYPTO_DUP_EX_DATA), \"CRYPTO_dup_ex_data\"},",
          "74:     {ERR_FUNC(CRYPTO_F_CRYPTO_FREE_EX_DATA), \"CRYPTO_free_ex_data\"},",
          "78:     {ERR_FUNC(CRYPTO_F_CRYPTO_NEW_EX_DATA), \"CRYPTO_new_ex_data\"},",
          "",
          "---------------"
        ],
        "crypto/engine/eng_dyn.c||crypto/engine/eng_dyn.c": [
          "File: crypto/engine/eng_dyn.c -> crypto/engine/eng_dyn.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "514:     fns.static_state = ENGINE_get_static_state();",
          "516:     CRYPTO_get_mem_functions(&fns.mem_fns.malloc_cb,",
          "517:                              &fns.mem_fns.realloc_cb, &fns.mem_fns.free_cb);",
          "518:     fns.lock_fns.lock_locking_cb = CRYPTO_get_locking_callback();",
          "",
          "[Removed Lines]",
          "515:     fns.ex_data_fns = CRYPTO_get_ex_data_implementation();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "crypto/ex_data.c||crypto/ex_data.c": [
          "File: crypto/ex_data.c -> crypto/ex_data.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "141: #include \"internal/cryptlib.h\"",
          "142: #include <openssl/lhash.h>",
          "245:     STACK_OF(CRYPTO_EX_DATA_FUNCS) *meth;",
          "247: } EX_CLASS_ITEM;",
          "276: {",
          "278:     CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);",
          "283: }",
          "293: {",
          "294:     OPENSSL_free(funcs);",
          "295: }",
          "303: {",
          "337:     }",
          "342: }",
          "351: {",
          "352:     int toret = -1;",
          "356:         return -1;",
          "357:     }",
          "358:     a->argl = argl;",
          "359:     a->argp = argp;",
          "360:     a->new_func = new_func;",
          "361:     a->dup_func = dup_func;",
          "362:     a->free_func = free_func;",
          "386:     CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);",
          "387:     return toret;",
          "388: }",
          "416: {",
          "417:     int mx, i;",
          "418:     void *ptr;",
          "419:     CRYPTO_EX_DATA_FUNCS **storage = NULL;",
          "423:         return 0;",
          "424:     ad->sk = NULL;",
          "427:     if (mx > 0) {",
          "433:     }",
          "438:         return 0;",
          "439:     }",
          "440:     for (i = 0; i < mx; i++) {",
          "",
          "[Removed Lines]",
          "145: struct st_CRYPTO_EX_DATA_IMPL {",
          "149:     int (*cb_new_class) (void);",
          "151:     void (*cb_cleanup) (void);",
          "155:     int (*cb_get_new_index) (int class_index, long argl, void *argp,",
          "156:                              CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,",
          "157:                              CRYPTO_EX_free *free_func);",
          "159:     int (*cb_new_ex_data) (int class_index, void *obj, CRYPTO_EX_DATA *ad);",
          "161:     int (*cb_dup_ex_data) (int class_index, CRYPTO_EX_DATA *to,",
          "162:                            CRYPTO_EX_DATA *from);",
          "164:     void (*cb_free_ex_data) (int class_index, void *obj, CRYPTO_EX_DATA *ad);",
          "165: };",
          "168: static const CRYPTO_EX_DATA_IMPL *impl = NULL;",
          "174: #define EX_IMPL(a) impl->cb_##a",
          "177: static int int_new_class(void);",
          "178: static void int_cleanup(void);",
          "179: static int int_get_new_index(int class_index, long argl, void *argp,",
          "180:                              CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,",
          "181:                              CRYPTO_EX_free *free_func);",
          "182: static int int_new_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad);",
          "183: static int int_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,",
          "184:                            CRYPTO_EX_DATA *from);",
          "185: static void int_free_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad);",
          "186: static CRYPTO_EX_DATA_IMPL impl_default = {",
          "187:     int_new_class,",
          "188:     int_cleanup,",
          "189:     int_get_new_index,",
          "190:     int_new_ex_data,",
          "191:     int_dup_ex_data,",
          "192:     int_free_ex_data",
          "193: };",
          "199: static void impl_check(void)",
          "200: {",
          "201:     CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);",
          "202:     if (!impl)",
          "203:         impl = &impl_default;",
          "204:     CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);",
          "205: }",
          "211: #define IMPL_CHECK if(!impl) impl_check();",
          "214: const CRYPTO_EX_DATA_IMPL *CRYPTO_get_ex_data_implementation(void)",
          "215: {",
          "216:     IMPL_CHECK return impl;",
          "217: }",
          "219: int CRYPTO_set_ex_data_implementation(const CRYPTO_EX_DATA_IMPL *i)",
          "220: {",
          "221:     int toret = 0;",
          "222:     CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);",
          "223:     if (!impl) {",
          "224:         impl = i;",
          "225:         toret = 1;",
          "226:     }",
          "227:     CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);",
          "228:     return toret;",
          "229: }",
          "243: typedef struct st_ex_class_item {",
          "244:     int class_index;",
          "246:     int meth_num;",
          "250: static int ex_class = CRYPTO_EX_INDEX_USER;",
          "253: DECLARE_LHASH_OF(EX_CLASS_ITEM);",
          "254: static LHASH_OF(EX_CLASS_ITEM) *ex_data = NULL;",
          "257: static unsigned long ex_class_item_hash(const EX_CLASS_ITEM *a)",
          "258: {",
          "259:     return a->class_index;",
          "260: }",
          "262: static IMPLEMENT_LHASH_HASH_FN(ex_class_item, EX_CLASS_ITEM)",
          "264: static int ex_class_item_cmp(const EX_CLASS_ITEM *a, const EX_CLASS_ITEM *b)",
          "265: {",
          "266:     return a->class_index - b->class_index;",
          "267: }",
          "269: static IMPLEMENT_LHASH_COMP_FN(ex_class_item, EX_CLASS_ITEM)",
          "275: static int ex_data_check(void)",
          "277:     int toret = 1;",
          "279:     if (!ex_data && (ex_data = lh_EX_CLASS_ITEM_new()) == NULL)",
          "280:         toret = 0;",
          "281:     CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);",
          "282:     return toret;",
          "289: #define EX_DATA_CHECK(iffail) if(!ex_data && !ex_data_check()) {iffail}",
          "292: static void def_cleanup_util_cb(CRYPTO_EX_DATA_FUNCS *funcs)",
          "302: static void def_cleanup_cb(void *a_void)",
          "304:     EX_CLASS_ITEM *item = (EX_CLASS_ITEM *)a_void;",
          "305:     sk_CRYPTO_EX_DATA_FUNCS_pop_free(item->meth, def_cleanup_util_cb);",
          "306:     OPENSSL_free(item);",
          "307: }",
          "313: static EX_CLASS_ITEM *def_get_class(int class_index)",
          "314: {",
          "315:     EX_CLASS_ITEM d, *p, *gen;",
          "316:     EX_DATA_CHECK(return NULL;)",
          "317:         d.class_index = class_index;",
          "318:     CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);",
          "319:     p = lh_EX_CLASS_ITEM_retrieve(ex_data, &d);",
          "320:     if (!p) {",
          "321:         gen = OPENSSL_malloc(sizeof(*gen));",
          "322:         if (gen) {",
          "323:             gen->class_index = class_index;",
          "324:             gen->meth_num = 0;",
          "325:             gen->meth = sk_CRYPTO_EX_DATA_FUNCS_new_null();",
          "326:             if (!gen->meth)",
          "327:                 OPENSSL_free(gen);",
          "328:             else {",
          "333:                 (void)lh_EX_CLASS_ITEM_insert(ex_data, gen);",
          "334:                 p = gen;",
          "335:             }",
          "336:         }",
          "338:     CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);",
          "339:     if (!p)",
          "340:         CRYPTOerr(CRYPTO_F_DEF_GET_CLASS, ERR_R_MALLOC_FAILURE);",
          "341:     return p;",
          "348: static int def_add_index(EX_CLASS_ITEM *item, long argl, void *argp,",
          "349:                          CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,",
          "350:                          CRYPTO_EX_free *free_func)",
          "353:     CRYPTO_EX_DATA_FUNCS *a = OPENSSL_malloc(sizeof(*a));",
          "354:     if (!a) {",
          "355:         CRYPTOerr(CRYPTO_F_DEF_ADD_INDEX, ERR_R_MALLOC_FAILURE);",
          "363:     CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);",
          "364:     while (sk_CRYPTO_EX_DATA_FUNCS_num(item->meth) <= item->meth_num) {",
          "365:         if (!sk_CRYPTO_EX_DATA_FUNCS_push(item->meth, NULL)) {",
          "366:             CRYPTOerr(CRYPTO_F_DEF_ADD_INDEX, ERR_R_MALLOC_FAILURE);",
          "367:             OPENSSL_free(a);",
          "368:             goto err;",
          "369:         }",
          "370:     }",
          "371:     toret = item->meth_num++;",
          "372:     (void)sk_CRYPTO_EX_DATA_FUNCS_set(item->meth, toret, a);",
          "373:  err:",
          "374:     CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);",
          "375:     return toret;",
          "376: }",
          "381: static int int_new_class(void)",
          "382: {",
          "383:     int toret;",
          "384:     CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);",
          "385:     toret = ex_class++;",
          "390: static void int_cleanup(void)",
          "391: {",
          "392:     EX_DATA_CHECK(return;)",
          "393:         lh_EX_CLASS_ITEM_doall(ex_data, def_cleanup_cb);",
          "394:     lh_EX_CLASS_ITEM_free(ex_data);",
          "395:     ex_data = NULL;",
          "396:     impl = NULL;",
          "397: }",
          "399: static int int_get_new_index(int class_index, long argl, void *argp,",
          "400:                              CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,",
          "401:                              CRYPTO_EX_free *free_func)",
          "402: {",
          "403:     EX_CLASS_ITEM *item = def_get_class(class_index);",
          "404:     if (!item)",
          "405:         return -1;",
          "406:     return def_add_index(item, argl, argp, new_func, dup_func, free_func);",
          "407: }",
          "415: static int int_new_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)",
          "420:     EX_CLASS_ITEM *item = def_get_class(class_index);",
          "421:     if (!item)",
          "425:     CRYPTO_r_lock(CRYPTO_LOCK_EX_DATA);",
          "426:     mx = sk_CRYPTO_EX_DATA_FUNCS_num(item->meth);",
          "428:         storage = OPENSSL_malloc(mx * sizeof(CRYPTO_EX_DATA_FUNCS *));",
          "429:         if (!storage)",
          "430:             goto skip;",
          "431:         for (i = 0; i < mx; i++)",
          "432:             storage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth, i);",
          "434:  skip:",
          "435:     CRYPTO_r_unlock(CRYPTO_LOCK_EX_DATA);",
          "436:     if ((mx > 0) && !storage) {",
          "437:         CRYPTOerr(CRYPTO_F_INT_NEW_EX_DATA, ERR_R_MALLOC_FAILURE);",
          "",
          "[Added Lines]",
          "115: typedef struct {",
          "118:     CRYPTO_EX_new *new_func;",
          "119:     CRYPTO_EX_free *free_func;",
          "120:     CRYPTO_EX_dup *dup_func;",
          "121: } CRYPTO_EX_DATA_FUNCS;",
          "123: DECLARE_STACK_OF(CRYPTO_EX_DATA_FUNCS)",
          "129: typedef struct {",
          "133: static EX_CLASS_ITEM ex_data[CRYPTO_EX_INDEX__COUNT];",
          "139: static EX_CLASS_ITEM *def_get_class(int class_index)",
          "141:     EX_CLASS_ITEM *ip;",
          "143:     if (class_index < 0 || class_index >= CRYPTO_EX_INDEX__COUNT) {",
          "144:         CRYPTOerr(CRYPTO_F_DEF_GET_CLASS, ERR_R_MALLOC_FAILURE);",
          "145:         return NULL;",
          "146:     }",
          "148:     ip = &ex_data[class_index];",
          "150:     if (ip->meth == NULL) {",
          "151:         ip->meth = sk_CRYPTO_EX_DATA_FUNCS_new_null();",
          "154:         if (ip->meth == NULL",
          "155:             || !sk_CRYPTO_EX_DATA_FUNCS_push(ip->meth, NULL)) {",
          "156:             CRYPTOerr(CRYPTO_F_DEF_GET_CLASS, ERR_R_MALLOC_FAILURE);",
          "157:             CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);",
          "158:             return NULL;",
          "159:         }",
          "160:     }",
          "161:     return ip;",
          "164: static void cleanup_cb(CRYPTO_EX_DATA_FUNCS *funcs)",
          "175: void CRYPTO_cleanup_all_ex_data(void)",
          "177:     int i;",
          "179:     for (i = 0; i < CRYPTO_EX_INDEX__COUNT; ++i) {",
          "180:         EX_CLASS_ITEM *ip = &ex_data[i];",
          "182:         sk_CRYPTO_EX_DATA_FUNCS_pop_free(ip->meth, cleanup_cb);",
          "183:         ip->meth = NULL;",
          "190: int CRYPTO_get_ex_new_index(int class_index, long argl, void *argp,",
          "191:                             CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,",
          "192:                             CRYPTO_EX_free *free_func)",
          "195:     CRYPTO_EX_DATA_FUNCS *a;",
          "196:     EX_CLASS_ITEM *ip = def_get_class(class_index);",
          "198:     if (!ip)",
          "200:     a = (CRYPTO_EX_DATA_FUNCS *)OPENSSL_malloc(sizeof(*a));",
          "201:     if (!a) {",
          "202:         CRYPTOerr(CRYPTO_F_CRYPTO_GET_EX_NEW_INDEX, ERR_R_MALLOC_FAILURE);",
          "203:         goto err;",
          "211:     if (!sk_CRYPTO_EX_DATA_FUNCS_push(ip->meth, NULL)) {",
          "212:         CRYPTOerr(CRYPTO_F_CRYPTO_GET_EX_NEW_INDEX, ERR_R_MALLOC_FAILURE);",
          "213:         OPENSSL_free(a);",
          "214:         goto err;",
          "215:     }",
          "216:     toret = sk_CRYPTO_EX_DATA_FUNCS_num(ip->meth) - 1;",
          "217:     (void)sk_CRYPTO_EX_DATA_FUNCS_set(ip->meth, toret, a);",
          "219:  err:",
          "231: int CRYPTO_new_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)",
          "236:     CRYPTO_EX_DATA_FUNCS *stack[10];",
          "237:     EX_CLASS_ITEM *ip = def_get_class(class_index);",
          "239:     if (!ip)",
          "244:     mx = sk_CRYPTO_EX_DATA_FUNCS_num(ip->meth);",
          "246:         if (mx < (int)OSSL_NELEM(stack))",
          "247:             storage = stack;",
          "248:         else",
          "249:             storage = OPENSSL_malloc(sizeof(*storage) * mx);",
          "250:         if (storage)",
          "251:             for (i = 0; i < mx; i++)",
          "252:                 storage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(ip->meth, i);",
          "254:     CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);",
          "256:     if (mx > 0 && storage == NULL) {",
          "257:         CRYPTOerr(CRYPTO_F_CRYPTO_NEW_EX_DATA, ERR_R_MALLOC_FAILURE);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "444:                                  storage[i]->argl, storage[i]->argp);",
          "445:         }",
          "446:     }",
          "448:     return 1;",
          "449: }",
          "454: {",
          "455:     int mx, j, i;",
          "456:     char *ptr;",
          "457:     CRYPTO_EX_DATA_FUNCS **storage = NULL;",
          "461:         return 1;",
          "463:         return 0;",
          "466:     j = sk_void_num(from->sk);",
          "467:     if (j < mx)",
          "468:         mx = j;",
          "469:     if (mx > 0) {",
          "475:     }",
          "480:         return 0;",
          "481:     }",
          "482:     for (i = 0; i < mx; i++) {",
          "483:         ptr = CRYPTO_get_ex_data(from, i);",
          "484:         if (storage[i] && storage[i]->dup_func)",
          "",
          "[Removed Lines]",
          "447:     OPENSSL_free(storage);",
          "452: static int int_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,",
          "453:                            CRYPTO_EX_DATA *from)",
          "458:     EX_CLASS_ITEM *item;",
          "459:     if (!from->sk)",
          "462:     if ((item = def_get_class(class_index)) == NULL)",
          "464:     CRYPTO_r_lock(CRYPTO_LOCK_EX_DATA);",
          "465:     mx = sk_CRYPTO_EX_DATA_FUNCS_num(item->meth);",
          "470:         storage = OPENSSL_malloc(mx * sizeof(CRYPTO_EX_DATA_FUNCS *));",
          "471:         if (!storage)",
          "472:             goto skip;",
          "473:         for (i = 0; i < mx; i++)",
          "474:             storage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth, i);",
          "476:  skip:",
          "477:     CRYPTO_r_unlock(CRYPTO_LOCK_EX_DATA);",
          "478:     if ((mx > 0) && !storage) {",
          "479:         CRYPTOerr(CRYPTO_F_INT_DUP_EX_DATA, ERR_R_MALLOC_FAILURE);",
          "",
          "[Added Lines]",
          "267:     if (storage != stack)",
          "268:         OPENSSL_free(storage);",
          "276: int CRYPTO_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,",
          "277:                        CRYPTO_EX_DATA *from)",
          "281:     CRYPTO_EX_DATA_FUNCS *stack[10];",
          "283:     EX_CLASS_ITEM *ip;",
          "285:     if (from->sk == NULL)",
          "288:     if ((ip = def_get_class(class_index)) == NULL)",
          "291:     mx = sk_CRYPTO_EX_DATA_FUNCS_num(ip->meth);",
          "296:         if (mx < (int)OSSL_NELEM(stack))",
          "297:             storage = stack;",
          "298:         else",
          "299:             storage = OPENSSL_malloc(sizeof(*storage) * mx);",
          "300:         if (storage)",
          "301:             for (i = 0; i < mx; i++)",
          "302:                 storage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(ip->meth, i);",
          "304:     CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);",
          "306:     if (mx > 0 && storage == NULL) {",
          "307:         CRYPTOerr(CRYPTO_F_CRYPTO_DUP_EX_DATA, ERR_R_MALLOC_FAILURE);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "486:                                  storage[i]->argl, storage[i]->argp);",
          "487:         CRYPTO_set_ex_data(to, i, ptr);",
          "488:     }",
          "490:     return 1;",
          "491: }",
          "495: {",
          "496:     int mx, i;",
          "498:     void *ptr;",
          "499:     CRYPTO_EX_DATA_FUNCS **storage = NULL;",
          "503:         return;",
          "506:     if (mx > 0) {",
          "512:     }",
          "517:         return;",
          "518:     }",
          "519:     for (i = 0; i < mx; i++) {",
          "",
          "[Removed Lines]",
          "489:     OPENSSL_free(storage);",
          "494: static void int_free_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)",
          "497:     EX_CLASS_ITEM *item;",
          "500:     if (ex_data == NULL)",
          "501:         return;",
          "502:     if ((item = def_get_class(class_index)) == NULL)",
          "504:     CRYPTO_r_lock(CRYPTO_LOCK_EX_DATA);",
          "505:     mx = sk_CRYPTO_EX_DATA_FUNCS_num(item->meth);",
          "507:         storage = OPENSSL_malloc(mx * sizeof(CRYPTO_EX_DATA_FUNCS *));",
          "508:         if (!storage)",
          "509:             goto skip;",
          "510:         for (i = 0; i < mx; i++)",
          "511:             storage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth, i);",
          "513:  skip:",
          "514:     CRYPTO_r_unlock(CRYPTO_LOCK_EX_DATA);",
          "515:     if ((mx > 0) && !storage) {",
          "516:         CRYPTOerr(CRYPTO_F_INT_FREE_EX_DATA, ERR_R_MALLOC_FAILURE);",
          "",
          "[Added Lines]",
          "318:     if (storage != stack)",
          "319:         OPENSSL_free(storage);",
          "328: void CRYPTO_free_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)",
          "331:     EX_CLASS_ITEM *ip;",
          "333:     CRYPTO_EX_DATA_FUNCS *stack[10];",
          "336:     if ((ip = def_get_class(class_index)) == NULL)",
          "339:     mx = sk_CRYPTO_EX_DATA_FUNCS_num(ip->meth);",
          "341:         if (mx < (int)OSSL_NELEM(stack))",
          "342:             storage = stack;",
          "343:         else",
          "344:             storage = OPENSSL_malloc(sizeof(*storage) * mx);",
          "345:         if (storage)",
          "346:             for (i = 0; i < mx; i++)",
          "347:                 storage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(ip->meth, i);",
          "349:     CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);",
          "351:     if (mx > 0 && storage == NULL) {",
          "352:         CRYPTOerr(CRYPTO_F_CRYPTO_FREE_EX_DATA, ERR_R_MALLOC_FAILURE);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "523:                                   storage[i]->argl, storage[i]->argp);",
          "524:         }",
          "525:     }",
          "527:     sk_void_free(ad->sk);",
          "528:     ad->sk = NULL;",
          "529: }",
          "",
          "[Removed Lines]",
          "526:     OPENSSL_free(storage);",
          "541: int CRYPTO_ex_data_new_class(void)",
          "542: {",
          "543:     IMPL_CHECK return EX_IMPL(new_class) ();",
          "544: }",
          "552: void CRYPTO_cleanup_all_ex_data(void)",
          "553: {",
          "554:     IMPL_CHECK EX_IMPL(cleanup) ();",
          "555: }",
          "558: int CRYPTO_get_ex_new_index(int class_index, long argl, void *argp,",
          "559:                             CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,",
          "560:                             CRYPTO_EX_free *free_func)",
          "561: {",
          "562:     int ret = -1;",
          "564:     IMPL_CHECK",
          "565:         ret = EX_IMPL(get_new_index) (class_index,",
          "566:                                       argl, argp, new_func, dup_func,",
          "567:                                       free_func);",
          "568:     return ret;",
          "569: }",
          "575: int CRYPTO_new_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)",
          "576: {",
          "577:     IMPL_CHECK return EX_IMPL(new_ex_data) (class_index, obj, ad);",
          "578: }",
          "584: int CRYPTO_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,",
          "585:                        CRYPTO_EX_DATA *from)",
          "586: {",
          "587:     IMPL_CHECK return EX_IMPL(dup_ex_data) (class_index, to, from);",
          "588: }",
          "594: void CRYPTO_free_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)",
          "595: {",
          "596:     IMPL_CHECK EX_IMPL(free_ex_data) (class_index, obj, ad);",
          "597: }",
          "",
          "[Added Lines]",
          "363:     if (storage != stack)",
          "364:         OPENSSL_free(storage);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "607:     if (ad->sk == NULL) {",
          "608:         if ((ad->sk = sk_void_new_null()) == NULL) {",
          "609:             CRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA, ERR_R_MALLOC_FAILURE);",
          "611:         }",
          "612:     }",
          "616:         if (!sk_void_push(ad->sk, NULL)) {",
          "617:             CRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA, ERR_R_MALLOC_FAILURE);",
          "619:         }",
          "621:     }",
          "622:     sk_void_set(ad->sk, idx, val);",
          "624: }",
          "",
          "[Removed Lines]",
          "610:             return (0);",
          "613:     i = sk_void_num(ad->sk);",
          "615:     while (i <= idx) {",
          "618:             return (0);",
          "620:         i++;",
          "623:     return (1);",
          "",
          "[Added Lines]",
          "380:             return 0;",
          "384:     for (i = sk_void_num(ad->sk); i <= idx; ++i) {",
          "387:             return 0;",
          "391:     return 1;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "630: void *CRYPTO_get_ex_data(const CRYPTO_EX_DATA *ad, int idx)",
          "631: {",
          "638: }",
          "",
          "[Removed Lines]",
          "632:     if (ad->sk == NULL)",
          "633:         return (0);",
          "634:     else if (idx >= sk_void_num(ad->sk))",
          "635:         return (0);",
          "636:     else",
          "637:         return (sk_void_value(ad->sk, idx));",
          "",
          "[Added Lines]",
          "400:     if (ad->sk == NULL || idx >= sk_void_num(ad->sk))",
          "401:         return NULL;",
          "402:     return sk_void_value(ad->sk, idx);",
          "",
          "---------------"
        ],
        "include/openssl/crypto.h||include/openssl/crypto.h": [
          "File: include/openssl/crypto.h -> include/openssl/crypto.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "283: };",
          "284: DECLARE_STACK_OF(void)",
          "306: # define CRYPTO_EX_INDEX_BIO             0",
          "307: # define CRYPTO_EX_INDEX_SSL             1",
          "308: # define CRYPTO_EX_INDEX_SSL_CTX         2",
          "",
          "[Removed Lines]",
          "291: typedef struct crypto_ex_data_func_st {",
          "294:     CRYPTO_EX_new *new_func;",
          "295:     CRYPTO_EX_free *free_func;",
          "296:     CRYPTO_EX_dup *dup_func;",
          "297: } CRYPTO_EX_DATA_FUNCS;",
          "299: DECLARE_STACK_OF(CRYPTO_EX_DATA_FUNCS)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "319: # define CRYPTO_EX_INDEX_ECDH            13",
          "320: # define CRYPTO_EX_INDEX_COMP            14",
          "321: # define CRYPTO_EX_INDEX_STORE           15",
          "",
          "[Removed Lines]",
          "327: # define CRYPTO_EX_INDEX_USER            100",
          "",
          "[Added Lines]",
          "306: # define CRYPTO_EX_INDEX_APP             16",
          "307: # define CRYPTO_EX_INDEX__COUNT          17",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "387: int OPENSSL_issetugid(void);",
          "398: int CRYPTO_get_ex_new_index(int class_index, long argl, void *argp,",
          "399:                             CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,",
          "",
          "[Removed Lines]",
          "390: typedef struct st_CRYPTO_EX_DATA_IMPL CRYPTO_EX_DATA_IMPL;",
          "392: const CRYPTO_EX_DATA_IMPL *CRYPTO_get_ex_data_implementation(void);",
          "394: int CRYPTO_set_ex_data_implementation(const CRYPTO_EX_DATA_IMPL *i);",
          "396: int CRYPTO_ex_data_new_class(void);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "612: void OPENSSL_init(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "586: struct tm *OPENSSL_gmtime(const time_t *timer, struct tm *result);",
          "587: int OPENSSL_gmtime_adj(struct tm *tm, int offset_day, long offset_sec);",
          "588: int OPENSSL_gmtime_diff(int *pday, int *psec,",
          "589:                         const struct tm *from, const struct tm *to);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "628: void ERR_load_CRYPTO_strings(void);",
          "638: # define CRYPTO_F_CRYPTO_GET_EX_NEW_INDEX                 100",
          "639: # define CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID                103",
          "640: # define CRYPTO_F_CRYPTO_GET_NEW_LOCKID                   101",
          "641: # define CRYPTO_F_CRYPTO_SET_EX_DATA                      102",
          "642: # define CRYPTO_F_DEF_ADD_INDEX                           104",
          "643: # define CRYPTO_F_DEF_GET_CLASS                           105",
          "",
          "[Removed Lines]",
          "630: struct tm *OPENSSL_gmtime(const time_t *timer, struct tm *result);",
          "631: int OPENSSL_gmtime_adj(struct tm *tm, int offset_day, long offset_sec);",
          "632: int OPENSSL_gmtime_diff(int *pday, int *psec,",
          "633:                         const struct tm *from, const struct tm *to);",
          "",
          "[Added Lines]",
          "610: # define CRYPTO_F_CRYPTO_DUP_EX_DATA                      110",
          "611: # define CRYPTO_F_CRYPTO_FREE_EX_DATA                     111",
          "615: # define CRYPTO_F_CRYPTO_NEW_EX_DATA                      112",
          "",
          "---------------"
        ],
        "include/openssl/engine.h||include/openssl/engine.h": [
          "File: include/openssl/engine.h -> include/openssl/engine.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "777: typedef struct st_dynamic_fns {",
          "778:     void *static_state;",
          "780:     dynamic_MEM_fns mem_fns;",
          "781:     dynamic_LOCK_fns lock_fns;",
          "782: } dynamic_fns;",
          "",
          "[Removed Lines]",
          "779:     const CRYPTO_EX_DATA_IMPL *ex_data_fns;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "834:                 CRYPTO_set_dynlock_create_callback(fns->lock_fns.dynlock_create_cb); \\",
          "835:                 CRYPTO_set_dynlock_lock_callback(fns->lock_fns.dynlock_lock_cb); \\",
          "836:                 CRYPTO_set_dynlock_destroy_callback(fns->lock_fns.dynlock_destroy_cb); \\",
          "839:         skip_cbs: \\",
          "840:                 if(!fn(e,id)) return 0; \\",
          "841:                 return 1; }",
          "",
          "[Removed Lines]",
          "837:                 if(!CRYPTO_set_ex_data_implementation(fns->ex_data_fns)) \\",
          "838:                         return 0; \\",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "include/openssl/safestack.h||include/openssl/safestack.h": [
          "File: include/openssl/safestack.h -> include/openssl/safestack.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2251:   LHM_lh_stats_bio(ERR_STRING_DATA,lh,out)",
          "2252: # define lh_ERR_STRING_DATA_free(lh) LHM_lh_free(ERR_STRING_DATA,lh)",
          "2272: # define lh_FUNCTION_new() LHM_lh_new(FUNCTION,function)",
          "2273: # define lh_FUNCTION_insert(lh,inst) LHM_lh_insert(FUNCTION,lh,inst)",
          "2274: # define lh_FUNCTION_retrieve(lh,inst) LHM_lh_retrieve(FUNCTION,lh,inst)",
          "",
          "[Removed Lines]",
          "2254: # define lh_EX_CLASS_ITEM_new() LHM_lh_new(EX_CLASS_ITEM,ex_class_item)",
          "2255: # define lh_EX_CLASS_ITEM_insert(lh,inst) LHM_lh_insert(EX_CLASS_ITEM,lh,inst)",
          "2256: # define lh_EX_CLASS_ITEM_retrieve(lh,inst) LHM_lh_retrieve(EX_CLASS_ITEM,lh,inst)",
          "2257: # define lh_EX_CLASS_ITEM_delete(lh,inst) LHM_lh_delete(EX_CLASS_ITEM,lh,inst)",
          "2258: # define lh_EX_CLASS_ITEM_doall(lh,fn) LHM_lh_doall(EX_CLASS_ITEM,lh,fn)",
          "2259: # define lh_EX_CLASS_ITEM_doall_arg(lh,fn,arg_type,arg) \\",
          "2260:   LHM_lh_doall_arg(EX_CLASS_ITEM,lh,fn,arg_type,arg)",
          "2261: # define lh_EX_CLASS_ITEM_error(lh) LHM_lh_error(EX_CLASS_ITEM,lh)",
          "2262: # define lh_EX_CLASS_ITEM_num_items(lh) LHM_lh_num_items(EX_CLASS_ITEM,lh)",
          "2263: # define lh_EX_CLASS_ITEM_down_load(lh) LHM_lh_down_load(EX_CLASS_ITEM,lh)",
          "2264: # define lh_EX_CLASS_ITEM_node_stats_bio(lh,out) \\",
          "2265:   LHM_lh_node_stats_bio(EX_CLASS_ITEM,lh,out)",
          "2266: # define lh_EX_CLASS_ITEM_node_usage_stats_bio(lh,out) \\",
          "2267:   LHM_lh_node_usage_stats_bio(EX_CLASS_ITEM,lh,out)",
          "2268: # define lh_EX_CLASS_ITEM_stats_bio(lh,out) \\",
          "2269:   LHM_lh_stats_bio(EX_CLASS_ITEM,lh,out)",
          "2270: # define lh_EX_CLASS_ITEM_free(lh) LHM_lh_free(EX_CLASS_ITEM,lh)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "include/openssl/symhacks.h||include/openssl/symhacks.h": [
          "File: include/openssl/symhacks.h -> include/openssl/symhacks.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "72: # ifdef OPENSSL_SYS_VMS",
          "81: #  undef ASN1_STRING_set_default_mask_asc",
          "82: #  define ASN1_STRING_set_default_mask_asc        ASN1_STRING_set_def_mask_asc",
          "",
          "[Removed Lines]",
          "75: #  undef CRYPTO_get_ex_data_implementation",
          "76: #  define CRYPTO_get_ex_data_implementation       CRYPTO_get_ex_data_impl",
          "77: #  undef CRYPTO_set_ex_data_implementation",
          "78: #  define CRYPTO_set_ex_data_implementation       CRYPTO_set_ex_data_impl",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "util/libeay.num||util/libeay.num": [
          "File: util/libeay.num -> util/libeay.num",
          "--- Hunk 1 ---",
          "[Context before]",
          "2328: OCSP_BASICRESP_free                     2838 EXIST::FUNCTION:",
          "2329: OCSP_BASICRESP_add1_ext_i2d             2839 EXIST::FUNCTION:",
          "2330: d2i_KRB5_AUTHENTBODY                    2840 NOEXIST::FUNCTION:",
          "2333: KRB5_ENCDATA_new                        2842 NOEXIST::FUNCTION:",
          "2334: DSO_up_ref                              2843 EXIST::FUNCTION:",
          "2335: OCSP_crl_reason_str                     2844 EXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "2331: CRYPTO_set_ex_data_implementation       2841 EXIST:!VMS:FUNCTION:",
          "2332: CRYPTO_set_ex_data_impl                 2841 EXIST:VMS:FUNCTION:",
          "",
          "[Added Lines]",
          "2331: CRYPTO_set_ex_data_impl                 2841 NOEXIST::FUNCTION:",
          "2332: CRYPTO_set_ex_data_implementation       2841 NOEXIST::FUNCTION:",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2559: OCSP_REQUEST_new                        3034 EXIST::FUNCTION:",
          "2560: ASN1_ANY_it                             3035 EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:",
          "2561: ASN1_ANY_it                             3035 EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:",
          "2563: _ossl_old_des_ncbc_encrypt              3037 NOEXIST::FUNCTION:",
          "2564: i2d_KRB5_TKTBODY                        3038 NOEXIST::FUNCTION:",
          "2565: EC_POINT_clear_free                     3039 EXIST::FUNCTION:EC",
          "",
          "[Removed Lines]",
          "2562: CRYPTO_ex_data_new_class                3036 EXIST::FUNCTION:",
          "",
          "[Added Lines]",
          "2562: CRYPTO_ex_data_new_class                3036 NOEXIST::FUNCTION:",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2676: USERNOTICE_it                           3132 EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:",
          "2677: OCSP_REQINFO_new                        3133 EXIST::FUNCTION:",
          "2678: OCSP_BASICRESP_get_ext                  3134 EXIST::FUNCTION:",
          "2681: ASN1_item_pack                          3136 EXIST::FUNCTION:",
          "2682: i2d_KRB5_ENCDATA                        3137 NOEXIST::FUNCTION:",
          "2683: X509_PURPOSE_set                        3138 EXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "2679: CRYPTO_get_ex_data_implementation       3135 EXIST:!VMS:FUNCTION:",
          "2680: CRYPTO_get_ex_data_impl                 3135 EXIST:VMS:FUNCTION:",
          "",
          "[Added Lines]",
          "2679: CRYPTO_get_ex_data_impl                 3135 NOEXIST::FUNCTION:",
          "2680: CRYPTO_get_ex_data_implementation       3135 NOEXIST::FUNCTION:",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f4511d4897f56a18a2a681e2ade8063658ff2cbb",
      "candidate_info": {
        "commit_hash": "f4511d4897f56a18a2a681e2ade8063658ff2cbb",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/f4511d4897f56a18a2a681e2ade8063658ff2cbb",
        "files": [
          "util/libeay.num"
        ],
        "message": "Remove ASYNC NOEXIST functions from libeay.num\n\nDuring development some functions got added and then later taken away.\nSince these will never appear in a production version there is no reason\nfor them to appear in libeay.num flagged as \"NOEXIST\".\n\nReviewed-by: Rich Salz <rsalz@openssl.org>",
        "before_after_code_files": [
          "util/libeay.num||util/libeay.num"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "util/libeay.num||util/libeay.num"
          ],
          "candidate": [
            "util/libeay.num||util/libeay.num"
          ]
        }
      },
      "candidate_diff": {
        "util/libeay.num||util/libeay.num": [
          "File: util/libeay.num -> util/libeay.num",
          "--- Hunk 1 ---",
          "[Context before]",
          "4651: TS_CONF_set_signer_digest               5011 EXIST::FUNCTION:",
          "4652: ENGINE_load_dasync                      5012 EXIST::FUNCTION:ENGINE,STATIC_ENGINE",
          "4653: ASYNC_pause_job                         5013 EXIST::FUNCTION:",
          "",
          "[Removed Lines]",
          "4654: ASYNC_job_is_waiting                    5014 NOEXIST::FUNCTION:",
          "4655: ASYNC_in_job                            5015 EXIST::FUNCTION:",
          "4656: ASYNC_start_job                         5016 EXIST::FUNCTION:",
          "4657: ASYNC_init_pool                         5017 EXIST::FUNCTION:",
          "4658: ASYNC_free_pool                         5018 EXIST::FUNCTION:",
          "4659: ASYNC_wake                              5019 EXIST::FUNCTION:",
          "4660: ASYNC_clear_wake                        5020 EXIST::FUNCTION:",
          "4661: ASYNC_get_current_job                   5021 EXIST::FUNCTION:",
          "4662: ASYNC_get_wait_fd                       5022 EXIST::FUNCTION:",
          "4663: ERR_load_ASYNC_strings                  5023 EXIST::FUNCTION:",
          "",
          "[Added Lines]",
          "4654: ASYNC_start_job                         5014 EXIST::FUNCTION:",
          "4655: ASYNC_init_pool                         5015 EXIST::FUNCTION:",
          "4656: ASYNC_free_pool                         5016 EXIST::FUNCTION:",
          "4657: ASYNC_wake                              5017 EXIST::FUNCTION:",
          "4658: ASYNC_clear_wake                        5018 EXIST::FUNCTION:",
          "4659: ASYNC_get_current_job                   5019 EXIST::FUNCTION:",
          "4660: ASYNC_get_wait_fd                       5020 EXIST::FUNCTION:",
          "4661: ERR_load_ASYNC_strings                  5021 EXIST::FUNCTION:",
          "",
          "---------------"
        ]
      }
    }
  ]
}
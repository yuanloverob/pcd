{
  "cve_id": "CVE-2012-2330",
  "cve_desc": "The Update method in src/node_http_parser.cc in Node.js before 0.6.17 and 0.7 before 0.7.8 does not properly check the length of a string, which allows remote attackers to obtain sensitive information (request header contents) and possibly spoof HTTP headers via a zero length string.",
  "repo": "joyent/node",
  "patch_hash": "c9a231db0e59658be419d926b1dfa17b939ba158",
  "patch_info": {
    "commit_hash": "c9a231db0e59658be419d926b1dfa17b939ba158",
    "repo": "joyent/node",
    "commit_url": "https://github.com/joyent/node/commit/c9a231d",
    "files": [
      "src/node_http_parser.cc"
    ],
    "message": "typo in node_http_parser",
    "before_after_code_files": [
      "src/node_http_parser.cc||src/node_http_parser.cc"
    ]
  },
  "patch_diff": {
    "src/node_http_parser.cc||src/node_http_parser.cc": [
      "File: src/node_http_parser.cc -> src/node_http_parser.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "191:   void Update(const char* str, size_t size) {",
      "192:     if (str_ == NULL)",
      "193:       str_ = str;",
      "197:       char* s = new char[size_ + size];",
      "",
      "[Removed Lines]",
      "194:     else if (on_heap_ || str_ + size != str) {",
      "",
      "[Added Lines]",
      "194:     else if (on_heap_ || str_ + size_ != str) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5403a8ce4cce83a13569b09ee5b2ba3d1ad8c176",
      "candidate_info": {
        "commit_hash": "5403a8ce4cce83a13569b09ee5b2ba3d1ad8c176",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/5403a8ce4cce83a13569b09ee5b2ba3d1ad8c176",
        "files": [
          "lib/http.js",
          "lib/os.js",
          "lib/path.js",
          "lib/util.js",
          "src/node.js"
        ],
        "message": "core: add `NativeModule.prototype.deprecate`\n\nFormalize and cleanup handling of deprecated core methods.",
        "before_after_code_files": [
          "lib/http.js||lihttp.js",
          "lib/os.js||lios.js",
          "lib/path.js||lipath.js",
          "lib/util.js||liutil.js",
          "src/node.js||src/node.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/http.js||lihttp.js": [
          "File: lib/http.js -> lihttp.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "1608: function Client(port, host) {",
          "1612:   host = host || 'localhost';",
          "1613:   port = port || 80;",
          "1614:   this.host = host;",
          "",
          "[Removed Lines]",
          "1610:   util._deprecationWarning('http', 'http.Client is a legacy interface' +",
          "1611:                 ' and will be removed in the near future. Do not use it.');",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1646: };",
          "1648: exports.Client = Client;",
          "1649: exports.createClient = function(port, host) {",
          "1650:   return new Client(port, host);",
          "1651: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "lib/os.js||lios.js": [
          "File: lib/os.js -> lios.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: };",
          "40: exports.getNetworkInterfaces = function() {",
          "43:   return exports.networkInterfaces();",
          "44: };",
          "",
          "[Removed Lines]",
          "41:   require('util')._deprecationWarning('os',",
          "42:     'os.getNetworkInterfaces() is deprecated - use os.networkInterfaces()');",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "lib/path.js||lipath.js": [
          "File: lib/path.js -> lipath.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "405: exports.exists = function(path, callback) {",
          "407:   require('fs').exists(path, callback);",
          "408: };",
          "411: exports.existsSync = function(path) {",
          "413:   return require('fs').existsSync(path);",
          "414: };",
          "418:   function(path) {",
          "419:     var resolvedPath = exports.resolve(path);",
          "",
          "[Removed Lines]",
          "406:   _deprecationWarning('path', '`path.exists` is now called `fs.exists`');",
          "412:   _deprecationWarning('path', '`path.exists` is now called `fs.exists`');",
          "417: exports._makeLong = isWindows ?",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "lib/util.js||liutil.js": [
          "File: lib/util.js -> liutil.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "407: }",
          "412: exports.p = function() {",
          "418:   for (var i = 0, len = arguments.length; i < len; ++i) {",
          "419:     error(exports.inspect(arguments[i]));",
          "420:   }",
          "421: };",
          "424: function pad(n) {",
          "",
          "[Removed Lines]",
          "410: var pWarning;",
          "413:   if (!pWarning) {",
          "414:     pWarning = 'util.p will be removed in future versions of Node. ' +",
          "415:                'Use util.puts(util.inspect()) instead.\\n';",
          "416:     exports.error(pWarning);",
          "417:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "444: };",
          "448: exports.exec = function() {",
          "454:   return require('child_process').exec.apply(this, arguments);",
          "455: };",
          "458: exports.pump = function(readStream, writeStream, callback) {",
          "",
          "[Removed Lines]",
          "447: var execWarning;",
          "449:   if (!execWarning) {",
          "450:     execWarning = 'util.exec has moved to the \"child_process\" module.' +",
          "451:                   ' Please update your source code.';",
          "452:     error(execWarning);",
          "453:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "517:     }",
          "518:   });",
          "519: };",
          "",
          "[Removed Lines]",
          "521: var deprecationWarnings;",
          "523: exports._deprecationWarning = function(moduleId, message) {",
          "524:   if (!deprecationWarnings)",
          "525:     deprecationWarnings = {};",
          "526:   else if (message in deprecationWarnings)",
          "527:     return;",
          "529:   deprecationWarnings[message] = true;",
          "531:   if ((new RegExp('\\\\b' + moduleId + '\\\\b')).test(process.env.NODE_DEBUG))",
          "532:     console.trace(message);",
          "533:   else",
          "534:     console.error(message);",
          "535: };",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/node.js||src/node.js": [
          "File: src/node.js -> src/node.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "569:     NativeModule._cache[this.id] = this;",
          "570:   };",
          "572:   startup();",
          "573: });",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "572:   NativeModule.prototype.deprecate = function(method, message) {",
          "573:     var original = this.exports[method];",
          "574:     var self = this;",
          "576:     Object.defineProperty(this.exports, method, {",
          "577:       enumerable: false,",
          "578:       value: function() {",
          "579:         message = self.id + '.' + method + ' is deprecated. ' + (message || '');",
          "581:         if ((new RegExp('\\\\b' + self.id + '\\\\b')).test(process.env.NODE_DEBUG))",
          "582:           console.trace(message);",
          "583:         else",
          "584:           console.error(message);",
          "586:         self.exports[method] = original;",
          "587:         return original.apply(this, arguments);",
          "588:       }",
          "589:     });",
          "590:   };",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "150053b3fa6eb4f176323ee13ced924ab6e38bff",
      "candidate_info": {
        "commit_hash": "150053b3fa6eb4f176323ee13ced924ab6e38bff",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/150053b3fa6eb4f176323ee13ced924ab6e38bff",
        "files": [
          "benchmark/http_server_lag.js"
        ],
        "message": "Typo in http_server_lag.js script\n\nThanks, @mscdex",
        "before_after_code_files": [
          "benchmark/http_server_lag.js||benchmark/http_server_lag.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "benchmark/http_server_lag.js||benchmark/http_server_lag.js": [
          "File: benchmark/http_server_lag.js -> benchmark/http_server_lag.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: http.createServer(function(req, res) {",
          "6:   res.writeHead(200, { 'content-type': 'text/plain',",
          "9:   var lag = parseInt(req.url.split(\"/\").pop(), 10) || defaultLag;",
          "10:   setTimeout(function() {",
          "",
          "[Removed Lines]",
          "7:                        'content-lengt': '2' });",
          "",
          "[Added Lines]",
          "7:                        'content-length': '2' });",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "37f0eb8df310fb43f29ff4ffff5e23fba660dbaa",
      "candidate_info": {
        "commit_hash": "37f0eb8df310fb43f29ff4ffff5e23fba660dbaa",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/37f0eb8df310fb43f29ff4ffff5e23fba660dbaa",
        "files": [
          "lib/buffer.js",
          "test/simple/test-writedouble.js",
          "test/simple/test-writefloat.js"
        ],
        "message": "Revert \"buffer: added support for writing NaN and Infinity\"\n\nThis reverts commit 6b9425fe3783193cf95cb04cbcbcbb97f5a77d31.",
        "before_after_code_files": [
          "lib/buffer.js||libuffer.js",
          "test/simple/test-writedouble.js||test/simple/test-writedouble.js",
          "test/simple/test-writefloat.js||test/simple/test-writefloat.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/buffer.js||libuffer.js": [
          "File: lib/buffer.js -> libuffer.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "1002:   assert.ok(Math.floor(value) === value, 'value has a fractional component');",
          "1003: }",
          "1006:   assert.ok(typeof (value) == 'number',",
          "1007:       'cannot write a non-number as a number');",
          "1013:   assert.ok(value <= max, 'value larger than maximum allowed value');",
          "1015:   assert.ok(value >= min, 'value smaller than minimum allowed value');",
          "",
          "[Removed Lines]",
          "1005: function verifyIEEE754(value, max, min) {",
          "1009:   if (isNaN(value) || value === Infinity || value === -Infinity) {",
          "1010:     return;",
          "1011:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1116:     assert.ok(offset + 3 < buffer.length,",
          "1117:         'Trying to write beyond buffer length');",
          "1120:   }",
          "1122:   require('buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,",
          "",
          "[Removed Lines]",
          "1119:     verifyIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1145:     assert.ok(offset + 7 < buffer.length,",
          "1146:         'Trying to write beyond buffer length');",
          "1149:   }",
          "1151:   require('buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,",
          "",
          "[Removed Lines]",
          "1148:     verifyIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/simple/test-writedouble.js||test/simple/test-writedouble.js": [
          "File: test/simple/test-writedouble.js -> test/simple/test-writedouble.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "123:   ASSERT.equal(0x00, buffer[13]);",
          "124:   ASSERT.equal(0x00, buffer[14]);",
          "125:   ASSERT.equal(0x80, buffer[15]);",
          "189: }",
          "",
          "[Removed Lines]",
          "127:   buffer.writeDoubleBE(Infinity, 0);",
          "128:   buffer.writeDoubleLE(Infinity, 8);",
          "129:   ASSERT.equal(0x7F, buffer[0]);",
          "130:   ASSERT.equal(0xF0, buffer[1]);",
          "131:   ASSERT.equal(0x00, buffer[2]);",
          "132:   ASSERT.equal(0x00, buffer[3]);",
          "133:   ASSERT.equal(0x00, buffer[4]);",
          "134:   ASSERT.equal(0x00, buffer[5]);",
          "135:   ASSERT.equal(0x00, buffer[6]);",
          "136:   ASSERT.equal(0x00, buffer[7]);",
          "137:   ASSERT.equal(0x00, buffer[8]);",
          "138:   ASSERT.equal(0x00, buffer[9]);",
          "139:   ASSERT.equal(0x00, buffer[10]);",
          "140:   ASSERT.equal(0x00, buffer[11]);",
          "141:   ASSERT.equal(0x00, buffer[12]);",
          "142:   ASSERT.equal(0x00, buffer[13]);",
          "143:   ASSERT.equal(0xF0, buffer[14]);",
          "144:   ASSERT.equal(0x7F, buffer[15]);",
          "145:   ASSERT.equal(Infinity, buffer.readDoubleBE(0));",
          "146:   ASSERT.equal(Infinity, buffer.readDoubleLE(8));",
          "148:   buffer.writeDoubleBE(-Infinity, 0);",
          "149:   buffer.writeDoubleLE(-Infinity, 8);",
          "150:   ASSERT.equal(0xFF, buffer[0]);",
          "151:   ASSERT.equal(0xF0, buffer[1]);",
          "152:   ASSERT.equal(0x00, buffer[2]);",
          "153:   ASSERT.equal(0x00, buffer[3]);",
          "154:   ASSERT.equal(0x00, buffer[4]);",
          "155:   ASSERT.equal(0x00, buffer[5]);",
          "156:   ASSERT.equal(0x00, buffer[6]);",
          "157:   ASSERT.equal(0x00, buffer[7]);",
          "158:   ASSERT.equal(0x00, buffer[8]);",
          "159:   ASSERT.equal(0x00, buffer[9]);",
          "160:   ASSERT.equal(0x00, buffer[10]);",
          "161:   ASSERT.equal(0x00, buffer[11]);",
          "162:   ASSERT.equal(0x00, buffer[12]);",
          "163:   ASSERT.equal(0x00, buffer[13]);",
          "164:   ASSERT.equal(0xF0, buffer[14]);",
          "165:   ASSERT.equal(0xFF, buffer[15]);",
          "166:   ASSERT.equal(-Infinity, buffer.readDoubleBE(0));",
          "167:   ASSERT.equal(-Infinity, buffer.readDoubleLE(8));",
          "169:   buffer.writeDoubleBE(NaN, 0);",
          "170:   buffer.writeDoubleLE(NaN, 8);",
          "171:   ASSERT.equal(0x7F, buffer[0]);",
          "172:   ASSERT.equal(0xF0, buffer[1]);",
          "173:   ASSERT.equal(0x00, buffer[2]);",
          "174:   ASSERT.equal(0x00, buffer[3]);",
          "175:   ASSERT.equal(0x00, buffer[4]);",
          "176:   ASSERT.equal(0x00, buffer[5]);",
          "177:   ASSERT.equal(0x00, buffer[6]);",
          "178:   ASSERT.equal(0x01, buffer[7]);",
          "179:   ASSERT.equal(0x01, buffer[8]);",
          "180:   ASSERT.equal(0x00, buffer[9]);",
          "181:   ASSERT.equal(0x00, buffer[10]);",
          "182:   ASSERT.equal(0x00, buffer[11]);",
          "183:   ASSERT.equal(0x00, buffer[12]);",
          "184:   ASSERT.equal(0x00, buffer[13]);",
          "185:   ASSERT.equal(0xF0, buffer[14]);",
          "186:   ASSERT.equal(0x7F, buffer[15]);",
          "187:   ASSERT.ok(isNaN(buffer.readDoubleBE(0)));",
          "188:   ASSERT.ok(isNaN(buffer.readDoubleLE(8)));",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/simple/test-writefloat.js||test/simple/test-writefloat.js": [
          "File: test/simple/test-writefloat.js -> test/simple/test-writefloat.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "83:   ASSERT.equal(0x00, buffer[5]);",
          "84:   ASSERT.equal(0x00, buffer[6]);",
          "85:   ASSERT.equal(0x80, buffer[7]);",
          "125: }",
          "",
          "[Removed Lines]",
          "87:   buffer.writeFloatBE(Infinity, 0);",
          "88:   buffer.writeFloatLE(Infinity, 4);",
          "89:   ASSERT.equal(0x7F, buffer[0]);",
          "90:   ASSERT.equal(0x80, buffer[1]);",
          "91:   ASSERT.equal(0x00, buffer[2]);",
          "92:   ASSERT.equal(0x00, buffer[3]);",
          "93:   ASSERT.equal(0x00, buffer[4]);",
          "94:   ASSERT.equal(0x00, buffer[5]);",
          "95:   ASSERT.equal(0x80, buffer[6]);",
          "96:   ASSERT.equal(0x7F, buffer[7]);",
          "97:   ASSERT.equal(Infinity, buffer.readFloatBE(0));",
          "98:   ASSERT.equal(Infinity, buffer.readFloatLE(4));",
          "100:   buffer.writeFloatBE(-Infinity, 0);",
          "101:   buffer.writeFloatLE(-Infinity, 4);",
          "102:   ASSERT.equal(0xFF, buffer[0]);",
          "103:   ASSERT.equal(0x80, buffer[1]);",
          "104:   ASSERT.equal(0x00, buffer[2]);",
          "105:   ASSERT.equal(0x00, buffer[3]);",
          "106:   ASSERT.equal(0x00, buffer[4]);",
          "107:   ASSERT.equal(0x00, buffer[5]);",
          "108:   ASSERT.equal(0x80, buffer[6]);",
          "109:   ASSERT.equal(0xFF, buffer[7]);",
          "110:   ASSERT.equal(-Infinity, buffer.readFloatBE(0));",
          "111:   ASSERT.equal(-Infinity, buffer.readFloatLE(4));",
          "113:   buffer.writeFloatBE(NaN, 0);",
          "114:   buffer.writeFloatLE(NaN, 4);",
          "115:   ASSERT.equal(0x7F, buffer[0]);",
          "116:   ASSERT.equal(0x80, buffer[1]);",
          "117:   ASSERT.equal(0x00, buffer[2]);",
          "118:   ASSERT.equal(0x01, buffer[3]);",
          "119:   ASSERT.equal(0x01, buffer[4]);",
          "120:   ASSERT.equal(0x00, buffer[5]);",
          "121:   ASSERT.equal(0x80, buffer[6]);",
          "122:   ASSERT.equal(0x7F, buffer[7]);",
          "123:   ASSERT.ok(isNaN(buffer.readFloatBE(0)));",
          "124:   ASSERT.ok(isNaN(buffer.readFloatLE(4)));",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "84d0b1bcc5154f67d9f200f3c852bb8c5b64c6ef",
      "candidate_info": {
        "commit_hash": "84d0b1bcc5154f67d9f200f3c852bb8c5b64c6ef",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/84d0b1bcc5154f67d9f200f3c852bb8c5b64c6ef",
        "files": [
          "lib/http.js",
          "src/node_http_parser.cc",
          "test/simple/test-http-parser.js"
        ],
        "message": "http: improve http parser bindings\n\nSpeeds up HTTP benchmarks by 10% on average.",
        "before_after_code_files": [
          "lib/http.js||lib/http.js",
          "src/node_http_parser.cc||src/node_http_parser.cc",
          "test/simple/test-http-parser.js||test/simple/test-http-parser.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/node_http_parser.cc||src/node_http_parser.cc"
          ],
          "candidate": [
            "src/node_http_parser.cc||src/node_http_parser.cc"
          ]
        }
      },
      "candidate_diff": {
        "lib/http.js||lib/http.js": [
          "File: lib/http.js -> lib/http.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: var parsers = new FreeList('parsers', 1000, function() {",
          "57:   };",
          "79:     }",
          "87:     }",
          "89:     parser.incoming.httpVersionMajor = info.versionMajor;",
          "90:     parser.incoming.httpVersionMinor = info.versionMinor;",
          "91:     parser.incoming.httpVersion = info.versionMajor + '.' + info.versionMinor;",
          "93:     if (info.method) {",
          "",
          "[Removed Lines]",
          "40:   var parser = new HTTPParser('request');",
          "42:   parser.onMessageBegin = function() {",
          "43:     parser.incoming = new IncomingMessage(parser.socket);",
          "44:     parser.field = null;",
          "45:     parser.value = null;",
          "46:   };",
          "49:   parser.onURL = function(b, start, len) {",
          "50:     var slice = b.toString('ascii', start, start + len);",
          "51:     if (parser.incoming.url) {",
          "52:       parser.incoming.url += slice;",
          "53:     } else {",
          "55:       parser.incoming.url = slice;",
          "56:     }",
          "59:   parser.onHeaderField = function(b, start, len) {",
          "60:     var slice = b.toString('ascii', start, start + len).toLowerCase();",
          "61:     if (parser.value != undefined) {",
          "62:       parser.incoming._addHeaderLine(parser.field, parser.value);",
          "63:       parser.field = null;",
          "64:       parser.value = null;",
          "65:     }",
          "66:     if (parser.field) {",
          "67:       parser.field += slice;",
          "68:     } else {",
          "69:       parser.field = slice;",
          "70:     }",
          "71:   };",
          "73:   parser.onHeaderValue = function(b, start, len) {",
          "74:     var slice = b.toString('ascii', start, start + len);",
          "75:     if (parser.value) {",
          "76:       parser.value += slice;",
          "77:     } else {",
          "78:       parser.value = slice;",
          "80:   };",
          "82:   parser.onHeadersComplete = function(info) {",
          "83:     if (parser.field && (parser.value != undefined)) {",
          "84:       parser.incoming._addHeaderLine(parser.field, parser.value);",
          "85:       parser.field = null;",
          "86:       parser.value = null;",
          "",
          "[Added Lines]",
          "40:   var parser = new HTTPParser(HTTPParser.REQUEST);",
          "42:   parser._headers = [];",
          "43:   parser._url = '';",
          "50:   parser.onHeaders = function(headers, url) {",
          "51:     parser._headers = parser._headers.concat(headers);",
          "52:     parser._url += url;",
          "60:   parser.onHeadersComplete = function(info) {",
          "61:     var headers = info.headers;",
          "62:     var url = info.url;",
          "64:     if (!headers) {",
          "65:       headers = parser._headers;",
          "66:       parser._headers = [];",
          "69:     if (!url) {",
          "70:       url = parser._url;",
          "71:       parser._url = '';",
          "74:     parser.incoming = new IncomingMessage(parser.socket);",
          "78:     parser.incoming.url = url;",
          "80:     for (var i = 0, n = headers.length; i < n; i += 2) {",
          "81:       var k = headers[i];",
          "82:       var v = headers[i + 1];",
          "83:       parser.incoming._addHeaderLine(k.toLowerCase(), v);",
          "84:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "123:   };",
          "125:   parser.onMessageComplete = function() {",
          "129:     }",
          "130:     if (!parser.incoming.upgrade) {",
          "132:       parser.incoming.readable = false;",
          "",
          "[Removed Lines]",
          "126:     this.incoming.complete = true;",
          "127:     if (parser.field && (parser.value != undefined)) {",
          "128:       parser.incoming._addHeaderLine(parser.field, parser.value);",
          "",
          "[Added Lines]",
          "120:     parser.incoming.complete = true;",
          "123:     var headers = parser._headers;",
          "124:     if (headers) {",
          "125:       for (var i = 0, n = headers.length; i < n; i += 2) {",
          "126:         var k = headers[i];",
          "127:         var v = headers[i + 1];",
          "128:         parser.incoming._addHeaderLine(k.toLowerCase(), v);",
          "129:       }",
          "130:       parser._headers = [];",
          "131:       parser._url = '';",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1088:     var parser = parsers.alloc();",
          "1089:     req.socket = socket;",
          "1090:     req.connection = socket;",
          "1092:     parser.socket = socket;",
          "1093:     parser.incoming = null;",
          "1094:     req.parser = parser;",
          "",
          "[Removed Lines]",
          "1091:     parser.reinitialize('response');",
          "",
          "[Added Lines]",
          "1095:     parser.reinitialize(HTTPParser.RESPONSE);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1346:   });",
          "1348:   var parser = parsers.alloc();",
          "1350:   parser.socket = socket;",
          "1351:   parser.incoming = null;",
          "",
          "[Removed Lines]",
          "1349:   parser.reinitialize('request');",
          "",
          "[Added Lines]",
          "1353:   parser.reinitialize(HTTPParser.REQUEST);",
          "",
          "---------------"
        ],
        "src/node_http_parser.cc||src/node_http_parser.cc": [
          "File: src/node_http_parser.cc -> src/node_http_parser.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "52: using namespace v8;",
          "58: static Persistent<String> on_headers_complete_sym;",
          "59: static Persistent<String> on_body_sym;",
          "60: static Persistent<String> on_message_complete_sym;",
          "",
          "[Removed Lines]",
          "54: static Persistent<String> on_message_begin_sym;",
          "55: static Persistent<String> on_url_sym;",
          "56: static Persistent<String> on_header_field_sym;",
          "57: static Persistent<String> on_header_value_sym;",
          "",
          "[Added Lines]",
          "54: static Persistent<String> on_headers_sym;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "92: static Persistent<String> version_minor_sym;",
          "93: static Persistent<String> should_keep_alive_sym;",
          "94: static Persistent<String> upgrade_sym;",
          "96: static struct http_parser_settings settings;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "92: static Persistent<String> headers_sym;",
          "93: static Persistent<String> url_sym;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "104: static size_t current_buffer_len;",
          "146: static inline Persistent<String>",
          "",
          "[Removed Lines]",
          "108: #define DEFINE_HTTP_CB(name)                                             \\",
          "109:   static int name(http_parser *p) {                                      \\",
          "110:     Parser *parser = static_cast<Parser*>(p->data);                      \\",
          "111:     Local<Value> cb_value = parser->handle_->Get(name##_sym);            \\",
          "112:     if (!cb_value->IsFunction()) return 0;                               \\",
          "113:     Local<Function> cb = Local<Function>::Cast(cb_value);                \\",
          "114:     Local<Value> ret = cb->Call(parser->handle_, 0, NULL);               \\",
          "115:     if (ret.IsEmpty()) {                                                 \\",
          "116:       parser->got_exception_ = true;                                     \\",
          "117:       return -1;                                                         \\",
          "118:     } else {                                                             \\",
          "119:       return 0;                                                          \\",
          "120:     }                                                                    \\",
          "121:   }",
          "124: #define DEFINE_HTTP_DATA_CB(name)                                        \\",
          "125:   static int name(http_parser *p, const char *at, size_t length) {       \\",
          "126:     Parser *parser = static_cast<Parser*>(p->data);                      \\",
          "127:     assert(current_buffer);                                              \\",
          "128:     Local<Value> cb_value = parser->handle_->Get(name##_sym);            \\",
          "129:     if (!cb_value->IsFunction()) return 0;                               \\",
          "130:     Local<Function> cb = Local<Function>::Cast(cb_value);                \\",
          "131:     Local<Value> argv[3] = { *current_buffer                             \\",
          "132:                            , Integer::New(at - current_buffer_data)      \\",
          "133:                            , Integer::New(length)                        \\",
          "134:                            };                                            \\",
          "135:     Local<Value> ret = cb->Call(parser->handle_, 3, argv);               \\",
          "136:     assert(current_buffer);                                              \\",
          "137:     if (ret.IsEmpty()) {                                                 \\",
          "138:       parser->got_exception_ = true;                                     \\",
          "139:       return -1;                                                         \\",
          "140:     } else {                                                             \\",
          "141:       return 0;                                                          \\",
          "142:     }                                                                    \\",
          "143:   }",
          "",
          "[Added Lines]",
          "106: #if defined(__GNUC__)",
          "107: #define always_inline __attribute__((always_inline))",
          "108: #elif defined(_MSC_VER)",
          "109: #define always_inline __forceinline",
          "110: #else",
          "111: #define always_inline",
          "112: #endif",
          "115: #define HTTP_CB(name)                                               \\",
          "116:    static int name(http_parser* p_) {                              \\",
          "117:      Parser* self = container_of(p_, Parser, parser_);             \\",
          "118:      return self->name##_();                                       \\",
          "119:    }                                                               \\",
          "120:    int always_inline name##_()",
          "123: #define HTTP_DATA_CB(name)                                          \\",
          "124:   static int name(http_parser* p_, const char* at, size_t length) { \\",
          "125:     Parser* self = container_of(p_, Parser, parser_);               \\",
          "126:     return self->name##_(at, length);                               \\",
          "127:   }                                                                 \\",
          "128:   int always_inline name##_(const char* at, size_t length)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "175: }",
          "178: class Parser : public ObjectWrap {",
          "180:   Parser(enum http_parser_type type) : ObjectWrap() {",
          "181:     Init(type);",
          "182:   }",
          "184:   ~Parser() {",
          "185:   }",
          "203:     Local<Object> message_info = Object::New();",
          "208:     }",
          "213:     }",
          "219:     message_info->Set(should_keep_alive_sym,",
          "224:     Local<Value> argv[1] = { message_info };",
          "228:     if (head_response.IsEmpty()) {",
          "230:       return -1;",
          "233:     }",
          "234:   }",
          "237:     HandleScope scope;",
          "250:     }",
          "252:     parser->Wrap(args.This());",
          "254:     return args.This();",
          "255:   }",
          "258:   static Handle<Value> Execute(const Arguments& args) {",
          "259:     HandleScope scope;",
          "263:     assert(!current_buffer);",
          "264:     assert(!current_buffer_data);",
          "",
          "[Removed Lines]",
          "179:  public:",
          "187:   DEFINE_HTTP_CB(on_message_begin)",
          "188:   DEFINE_HTTP_CB(on_message_complete)",
          "190:   DEFINE_HTTP_DATA_CB(on_url)",
          "191:   DEFINE_HTTP_DATA_CB(on_header_field)",
          "192:   DEFINE_HTTP_DATA_CB(on_header_value)",
          "193:   DEFINE_HTTP_DATA_CB(on_body)",
          "195:   static int on_headers_complete(http_parser *p) {",
          "196:     Parser *parser = static_cast<Parser*>(p->data);",
          "198:     Local<Value> cb_value = parser->handle_->Get(on_headers_complete_sym);",
          "199:     if (!cb_value->IsFunction()) return 0;",
          "200:     Local<Function> cb = Local<Function>::Cast(cb_value);",
          "206:     if (p->type == HTTP_REQUEST) {",
          "207:       message_info->Set(method_sym, method_to_str(p->method));",
          "211:     if (p->type == HTTP_RESPONSE) {",
          "212:       message_info->Set(status_code_sym, Integer::New(p->status_code));",
          "216:     message_info->Set(version_major_sym, Integer::New(p->http_major));",
          "217:     message_info->Set(version_minor_sym, Integer::New(p->http_minor));",
          "220:         http_should_keep_alive(p) ? True() : False());",
          "222:     message_info->Set(upgrade_sym, p->upgrade ? True() : False());",
          "226:     Local<Value> head_response = cb->Call(parser->handle_, 1, argv);",
          "229:       parser->got_exception_ = true;",
          "231:     } else {",
          "232:       return head_response->IsTrue() ? 1 : 0;",
          "236:   static Handle<Value> New(const Arguments& args) {",
          "239:     String::Utf8Value type(args[0]->ToString());",
          "241:     Parser *parser;",
          "243:     if (0 == strcasecmp(*type, \"request\")) {",
          "244:       parser = new Parser(HTTP_REQUEST);",
          "245:     } else if (0 == strcasecmp(*type, \"response\")) {",
          "246:       parser = new Parser(HTTP_RESPONSE);",
          "247:     } else {",
          "248:       return ThrowException(Exception::Error(",
          "249:             String::New(\"Constructor argument be 'request' or 'response'\")));",
          "261:     Parser *parser = ObjectWrap::Unwrap<Parser>(args.This());",
          "",
          "[Added Lines]",
          "164: struct StringPtr {",
          "165:   StringPtr() {",
          "166:     on_heap_ = false;",
          "167:     Reset();",
          "168:   }",
          "171:   ~StringPtr() {",
          "172:     Reset();",
          "173:   }",
          "176:   void Reset() {",
          "177:     if (on_heap_) {",
          "178:       delete[] str_;",
          "179:       on_heap_ = false;",
          "180:     }",
          "182:     str_ = NULL;",
          "183:     size_ = 0;",
          "184:   }",
          "187:   void Update(const char* str, size_t size) {",
          "188:     if (str_ == NULL)",
          "189:       str_ = str;",
          "190:     else if (on_heap_ || str_ + size != str) {",
          "193:       char* s = new char[size_ + size];",
          "194:       memcpy(s, str_, size_);",
          "195:       memcpy(s + size_, str, size);",
          "197:       if (on_heap_)",
          "198:         delete[] str_;",
          "199:       else",
          "200:         on_heap_ = true;",
          "202:       str_ = s;",
          "203:     }",
          "204:     size_ += size;",
          "205:   }",
          "208:   Handle<String> ToString() const {",
          "209:     if (str_)",
          "210:       return String::New(str_, size_);",
          "211:     else",
          "212:       return String::Empty();",
          "213:   }",
          "216:   const char* str_;",
          "217:   bool on_heap_;",
          "218:   size_t size_;",
          "219: };",
          "223: public:",
          "233:   HTTP_CB(on_message_begin) {",
          "234:     num_fields_ = num_values_ = -1;",
          "235:     url_.Reset();",
          "236:     return 0;",
          "237:   }",
          "240:   HTTP_DATA_CB(on_url) {",
          "241:     url_.Update(at, length);",
          "242:     return 0;",
          "243:   }",
          "246:   HTTP_DATA_CB(on_header_field) {",
          "247:     if (num_fields_ == num_values_) {",
          "249:       if (++num_fields_ == ARRAY_SIZE(fields_)) {",
          "250:         Flush();",
          "251:         num_fields_ = 0;",
          "252:         num_values_ = -1;",
          "253:       }",
          "254:       fields_[num_fields_].Reset();",
          "255:     }",
          "257:     assert(num_fields_ < (int)ARRAY_SIZE(fields_));",
          "258:     assert(num_fields_ == num_values_ + 1);",
          "260:     fields_[num_fields_].Update(at, length);",
          "262:     return 0;",
          "263:   }",
          "266:   HTTP_DATA_CB(on_header_value) {",
          "267:     if (num_values_ != num_fields_) {",
          "269:       values_[++num_values_].Reset();",
          "270:     }",
          "272:     assert(num_values_ < (int)ARRAY_SIZE(values_));",
          "273:     assert(num_values_ == num_fields_);",
          "275:     values_[num_values_].Update(at, length);",
          "277:     return 0;",
          "278:   }",
          "281:   HTTP_CB(on_headers_complete) {",
          "282:     Local<Value> cb = handle_->Get(on_headers_complete_sym);",
          "284:     if (!cb->IsFunction())",
          "285:       return 0;",
          "289:     if (have_flushed_) {",
          "291:       Flush();",
          "292:     }",
          "293:     else {",
          "295:       message_info->Set(headers_sym, CreateHeaders());",
          "296:       if (parser_.type == HTTP_REQUEST)",
          "297:         message_info->Set(url_sym, url_.ToString());",
          "298:     }",
          "299:     num_fields_ = num_values_ = -1;",
          "302:     if (parser_.type == HTTP_REQUEST) {",
          "303:       message_info->Set(method_sym, method_to_str(parser_.method));",
          "307:     if (parser_.type == HTTP_RESPONSE) {",
          "308:       message_info->Set(status_code_sym, Integer::New(parser_.status_code));",
          "312:     message_info->Set(version_major_sym, Integer::New(parser_.http_major));",
          "313:     message_info->Set(version_minor_sym, Integer::New(parser_.http_minor));",
          "316:         http_should_keep_alive(&parser_) ? True() : False());",
          "318:     message_info->Set(upgrade_sym, parser_.upgrade ? True() : False());",
          "322:     Local<Value> head_response =",
          "323:         Local<Function>::Cast(cb)->Call(handle_, 1, argv);",
          "326:       got_exception_ = true;",
          "327:       return -1;",
          "328:     }",
          "330:     return head_response->IsTrue() ? 1 : 0;",
          "331:   }",
          "334:   HTTP_DATA_CB(on_body) {",
          "335:     HandleScope scope;",
          "337:     Local<Value> cb = handle_->Get(on_body_sym);",
          "338:     if (!cb->IsFunction())",
          "339:       return 0;",
          "341:     Handle<Value> argv[3] = {",
          "343:       Integer::New(at - current_buffer_data),",
          "344:       Integer::New(length)",
          "345:     };",
          "347:     Local<Value> r = Local<Function>::Cast(cb)->Call(handle_, 3, argv);",
          "349:     if (r.IsEmpty()) {",
          "350:       got_exception_ = true;",
          "354:     return 0;",
          "358:   HTTP_CB(on_message_complete) {",
          "361:     if (num_fields_ != -1)",
          "362:       Flush(); // Flush trailing HTTP headers.",
          "364:     Local<Value> cb = handle_->Get(on_message_complete_sym);",
          "366:     if (!cb->IsFunction())",
          "367:       return 0;",
          "369:     Local<Value> r = Local<Function>::Cast(cb)->Call(handle_, 0, NULL);",
          "371:     if (r.IsEmpty()) {",
          "372:       got_exception_ = true;",
          "373:       return -1;",
          "374:     }",
          "376:     return 0;",
          "377:   }",
          "380:   static Handle<Value> New(const Arguments& args) {",
          "381:     HandleScope scope;",
          "383:     http_parser_type type =",
          "384:         static_cast<http_parser_type>(args[0]->Int32Value());",
          "386:     if (type != HTTP_REQUEST && type != HTTP_RESPONSE) {",
          "387:       return ThrowException(Exception::Error(String::New(",
          "388:           \"Argument must be HTTPParser.REQUEST or HTTPParser.RESPONSE\")));",
          "391:     Parser* parser = new Parser(type);",
          "402:     Parser* parser = ObjectWrap::Unwrap<Parser>(args.This());",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "321:     }",
          "322:   }",
          "324:   static Handle<Value> Finish(const Arguments& args) {",
          "325:     HandleScope scope;",
          "329:     assert(!current_buffer);",
          "330:     parser->got_exception_ = false;",
          "",
          "[Removed Lines]",
          "327:     Parser *parser = ObjectWrap::Unwrap<Parser>(args.This());",
          "",
          "[Added Lines]",
          "469:     Parser* parser = ObjectWrap::Unwrap<Parser>(args.This());",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "343:     return Undefined();",
          "344:   }",
          "346:   static Handle<Value> Reinitialize(const Arguments& args) {",
          "347:     HandleScope scope;",
          "359:     }",
          "360:     return Undefined();",
          "361:   }",
          "367:     http_parser_init(&parser_, type);",
          "369:   }",
          "372:   http_parser parser_;",
          "373: };",
          "",
          "[Removed Lines]",
          "348:     Parser *parser = ObjectWrap::Unwrap<Parser>(args.This());",
          "350:     String::Utf8Value type(args[0]->ToString());",
          "352:     if (0 == strcasecmp(*type, \"request\")) {",
          "353:       parser->Init(HTTP_REQUEST);",
          "354:     } else if (0 == strcasecmp(*type, \"response\")) {",
          "355:       parser->Init(HTTP_RESPONSE);",
          "356:     } else {",
          "357:       return ThrowException(Exception::Error(",
          "358:             String::New(\"Argument be 'request' or 'response'\")));",
          "364:  private:",
          "366:   void Init (enum http_parser_type type) {",
          "368:     parser_.data = this;",
          "371:   bool got_exception_;",
          "",
          "[Added Lines]",
          "492:     http_parser_type type =",
          "493:         static_cast<http_parser_type>(args[0]->Int32Value());",
          "495:     if (type != HTTP_REQUEST && type != HTTP_RESPONSE) {",
          "496:       return ThrowException(Exception::Error(String::New(",
          "497:           \"Argument must be HTTPParser.REQUEST or HTTPParser.RESPONSE\")));",
          "500:     Parser* parser = ObjectWrap::Unwrap<Parser>(args.This());",
          "501:     parser->Init(type);",
          "507: private:",
          "509:   Local<Array> CreateHeaders() {",
          "512:     Local<Array> headers = Array::New(2 * (num_values_ + 1));",
          "514:     for (int i = 0; i < num_values_ + 1; ++i) {",
          "515:       headers->Set(2 * i, fields_[i].ToString());",
          "516:       headers->Set(2 * i + 1, values_[i].ToString());",
          "517:     }",
          "519:     return headers;",
          "520:   }",
          "524:   void Flush() {",
          "525:     HandleScope scope;",
          "527:     Local<Value> cb = handle_->Get(on_headers_sym);",
          "529:     if (!cb->IsFunction())",
          "530:       return;",
          "532:     Handle<Value> argv[2] = {",
          "533:       CreateHeaders(),",
          "534:       url_.ToString()",
          "535:     };",
          "537:     Local<Value> r = Local<Function>::Cast(cb)->Call(handle_, 2, argv);",
          "539:     if (r.IsEmpty())",
          "540:       got_exception_ = true;",
          "542:     url_.Reset();",
          "543:     have_flushed_ = true;",
          "544:   }",
          "547:   void Init(enum http_parser_type type) {",
          "549:     url_.Reset();",
          "550:     num_fields_ = -1;",
          "551:     num_values_ = -1;",
          "552:     have_flushed_ = false;",
          "553:     got_exception_ = false;",
          "558:   StringPtr fields_[32];  // header fields",
          "559:   StringPtr values_[32];  // header values",
          "560:   StringPtr url_;",
          "561:   int num_fields_;",
          "562:   int num_values_;",
          "563:   bool have_flushed_;",
          "564:   bool got_exception_;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "380:   t->InstanceTemplate()->SetInternalFieldCount(1);",
          "381:   t->SetClassName(String::NewSymbol(\"HTTPParser\"));",
          "383:   NODE_SET_PROTOTYPE_METHOD(t, \"execute\", Parser::Execute);",
          "384:   NODE_SET_PROTOTYPE_METHOD(t, \"finish\", Parser::Finish);",
          "385:   NODE_SET_PROTOTYPE_METHOD(t, \"reinitialize\", Parser::Reinitialize);",
          "387:   target->Set(String::NewSymbol(\"HTTPParser\"), t->GetFunction());",
          "393:   on_headers_complete_sym = NODE_PSYMBOL(\"onHeadersComplete\");",
          "394:   on_body_sym             = NODE_PSYMBOL(\"onBody\");",
          "395:   on_message_complete_sym = NODE_PSYMBOL(\"onMessageComplete\");",
          "",
          "[Removed Lines]",
          "389:   on_message_begin_sym    = NODE_PSYMBOL(\"onMessageBegin\");",
          "390:   on_url_sym              = NODE_PSYMBOL(\"onURL\");",
          "391:   on_header_field_sym     = NODE_PSYMBOL(\"onHeaderField\");",
          "392:   on_header_value_sym     = NODE_PSYMBOL(\"onHeaderValue\");",
          "",
          "[Added Lines]",
          "575:   PropertyAttribute attrib = (PropertyAttribute) (ReadOnly | DontDelete);",
          "576:   t->Set(String::NewSymbol(\"REQUEST\"), Integer::New(HTTP_REQUEST), attrib);",
          "577:   t->Set(String::NewSymbol(\"RESPONSE\"), Integer::New(HTTP_RESPONSE), attrib);",
          "585:   on_headers_sym          = NODE_PSYMBOL(\"onHeaders\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "427:   version_minor_sym = NODE_PSYMBOL(\"versionMinor\");",
          "428:   should_keep_alive_sym = NODE_PSYMBOL(\"shouldKeepAlive\");",
          "429:   upgrade_sym = NODE_PSYMBOL(\"upgrade\");",
          "431:   settings.on_message_begin    = Parser::on_message_begin;",
          "432:   settings.on_url              = Parser::on_url;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "623:   headers_sym = NODE_PSYMBOL(\"headers\");",
          "624:   url_sym = NODE_PSYMBOL(\"url\");",
          "",
          "---------------"
        ],
        "test/simple/test-http-parser.js||test/simple/test-http-parser.js": [
          "File: test/simple/test-http-parser.js -> test/simple/test-http-parser.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: var common = require('../common');",
          "23: var assert = require('assert');",
          "",
          "[Removed Lines]",
          "30: var HTTPParser = process.binding('http_parser').HTTPParser;",
          "32: var parser = new HTTPParser('request');",
          "34: var Buffer = require('buffer').Buffer;",
          "35: var buffer = new Buffer(1024);",
          "37: var request = 'GET /hello HTTP/1.1\\r\\n\\r\\n';",
          "39: buffer.write(request, 0, 'ascii');",
          "41: var callbacks = 0;",
          "43: parser.onMessageBegin = function() {",
          "44:   console.log('message begin');",
          "45:   callbacks++;",
          "46: };",
          "48: parser.onHeadersComplete = function(info) {",
          "49:   console.log('headers complete: ' + JSON.stringify(info));",
          "50:   assert.equal('GET', info.method);",
          "51:   assert.equal(1, info.versionMajor);",
          "52:   assert.equal(1, info.versionMinor);",
          "53:   callbacks++;",
          "54: };",
          "56: parser.onURL = function(b, off, len) {",
          "58:   callbacks++;",
          "59: };",
          "61: parser.execute(buffer, 0, request.length);",
          "62: assert.equal(3, callbacks);",
          "69: parser.onURL = function(b, off, len) {",
          "70:   throw new Error('hello world');",
          "71: };",
          "73: assert.throws(function() {",
          "74:   parser.execute(buffer, 0, request.length);",
          "75: }, Error, 'hello world');",
          "",
          "[Added Lines]",
          "25: var HTTPParser = process.binding('http_parser').HTTPParser;",
          "27: var CRLF = \"\\r\\n\";",
          "28: var REQUEST = HTTPParser.REQUEST;",
          "29: var RESPONSE = HTTPParser.RESPONSE;",
          "37: function newParser(type) {",
          "38:   var parser = new HTTPParser(type);",
          "40:   parser.headers = [];",
          "41:   parser.url = '';",
          "43:   parser.onHeaders = function(headers, url) {",
          "44:     parser.headers = parser.headers.concat(headers);",
          "45:     parser.url += url;",
          "46:   };",
          "48:   parser.onHeadersComplete = function(info) {",
          "49:   };",
          "51:   parser.onBody = function(b, start, len) {",
          "52:     assert.ok(false, 'Function should not be called.');",
          "53:   };",
          "55:   parser.onMessageComplete = function() {",
          "56:   };",
          "58:   return parser;",
          "59: }",
          "62: function mustCall(f, times) {",
          "63:   var actual = 0;",
          "65:   process.setMaxListeners(256);",
          "66:   process.on('exit', function() {",
          "67:     assert.equal(actual, times || 1);",
          "68:   });",
          "70:   return function() {",
          "71:     actual++;",
          "72:     return f.apply(this, Array.prototype.slice.call(arguments));",
          "73:   };",
          "74: }",
          "77: function expectBody(expected) {",
          "78:   return mustCall(function(buf, start, len) {",
          "79:     var body = '' + buf.slice(start, start + len);",
          "80:     assert.equal(body, expected);",
          "81:   });",
          "82: }",
          "88: (function() {",
          "89:   var request = Buffer(",
          "90:     'GET /hello HTTP/1.1' + CRLF +",
          "91:     CRLF",
          "92:   );",
          "94:   var parser = newParser(REQUEST);",
          "96:   parser.onHeadersComplete = mustCall(function(info) {",
          "97:     assert.equal(info.method, 'GET');",
          "98:     assert.equal(info.url || parser.url, '/hello');",
          "99:     assert.equal(info.versionMajor, 1);",
          "100:     assert.equal(info.versionMinor, 1);",
          "101:   });",
          "103:   parser.execute(request, 0, request.length);",
          "110:   parser.onHeadersComplete = function(info) {",
          "111:     throw new Error('hello world');",
          "112:   };",
          "114:   parser.reinitialize(HTTPParser.REQUEST);",
          "116:   assert.throws(function() {",
          "117:     parser.execute(request, 0, request.length);",
          "118:   }, Error, 'hello world');",
          "119: })();",
          "125: (function() {",
          "126:   var request = Buffer(",
          "127:     'HTTP/1.1 200 OK' + CRLF +",
          "128:     'Content-Type: text/plain' + CRLF +",
          "129:     'Content-Length: 4' + CRLF +",
          "130:     CRLF +",
          "131:     'pong'",
          "132:   );",
          "134:   var parser = newParser(RESPONSE);",
          "136:   parser.onHeadersComplete = mustCall(function(info) {",
          "137:     assert.equal(info.method, undefined);",
          "138:     assert.equal(info.versionMajor, 1);",
          "139:     assert.equal(info.versionMinor, 1);",
          "140:     assert.equal(info.statusCode, 200);",
          "141:   });",
          "143:   parser.onBody = mustCall(function(buf, start, len) {",
          "144:     var body = '' + buf.slice(start, start + len);",
          "145:     assert.equal(body, 'pong');",
          "146:   });",
          "148:   parser.execute(request, 0, request.length);",
          "149: })();",
          "155: (function() {",
          "156:   var request = Buffer(",
          "157:     'POST /it HTTP/1.1' + CRLF +",
          "158:     'Transfer-Encoding: chunked' + CRLF +",
          "159:     CRLF +",
          "160:     '4' + CRLF +",
          "161:     'ping' + CRLF +",
          "162:     '0' + CRLF +",
          "163:     'Vary: *' + CRLF +",
          "164:     'Content-Type: text/plain' + CRLF +",
          "165:     CRLF",
          "166:   );",
          "168:   var seen_body = false;",
          "170:   function onHeaders(headers, url) {",
          "171:     assert.ok(seen_body); // trailers should come after the body",
          "172:     assert.deepEqual(headers,",
          "173:       ['Vary', '*', 'Content-Type', 'text/plain']);",
          "174:   }",
          "176:   var parser = newParser(REQUEST);",
          "178:   parser.onHeadersComplete = mustCall(function(info) {",
          "179:     assert.equal(info.method, 'POST');",
          "180:     assert.equal(info.url || parser.url, '/it');",
          "181:     assert.equal(info.versionMajor, 1);",
          "182:     assert.equal(info.versionMinor, 1);",
          "184:     parser.onHeaders = mustCall(onHeaders);",
          "185:   });",
          "187:   parser.onBody = mustCall(function(buf, start, len) {",
          "188:     var body = '' + buf.slice(start, start + len);",
          "189:     assert.equal(body, 'ping');",
          "190:     seen_body = true;",
          "191:   });",
          "193:   parser.execute(request, 0, request.length);",
          "194: })();",
          "200: (function() {",
          "201:   var request = Buffer(",
          "202:     'GET / HTTP/1.0' + CRLF +",
          "203:     'X-Filler: 1337' + CRLF +",
          "204:     'X-Filler:   42' + CRLF +",
          "205:     'X-Filler2:  42' + CRLF +",
          "206:     CRLF",
          "207:   );",
          "209:   var parser = newParser(REQUEST);",
          "211:   parser.onHeadersComplete = mustCall(function(info) {",
          "212:     assert.equal(info.method, 'GET');",
          "213:     assert.equal(info.versionMajor, 1);",
          "214:     assert.equal(info.versionMinor, 0);",
          "215:     assert.deepEqual(info.headers || parser.headers,",
          "216:       ['X-Filler', '1337',",
          "217:        'X-Filler', '42',",
          "218:        'X-Filler2', '42']);",
          "219:   });",
          "221:   parser.execute(request, 0, request.length);",
          "222: })();",
          "228: (function() {",
          "230:   var lots_of_headers = 'X-Filler: 42' + CRLF;",
          "231:   for (var i = 0; i < 8; ++i) lots_of_headers += lots_of_headers;",
          "233:   var request = Buffer(",
          "234:     'GET /foo/bar/baz?quux=42#1337 HTTP/1.0' + CRLF +",
          "235:     lots_of_headers +",
          "236:     CRLF",
          "237:   );",
          "239:   var parser = newParser(REQUEST);",
          "241:   parser.onHeadersComplete = mustCall(function(info) {",
          "242:     assert.equal(info.method, 'GET');",
          "243:     assert.equal(info.url || parser.url, '/foo/bar/baz?quux=42#1337');",
          "244:     assert.equal(info.versionMajor, 1);",
          "245:     assert.equal(info.versionMinor, 0);",
          "247:     var headers = info.headers || parser.headers;",
          "249:     assert.equal(headers.length, 2 * 256); // 256 key/value pairs",
          "250:     for (var i = 0; i < headers.length; i += 2) {",
          "251:       assert.equal(headers[i], 'X-Filler');",
          "252:       assert.equal(headers[i + 1], '42');",
          "253:     }",
          "254:   });",
          "256:   parser.execute(request, 0, request.length);",
          "257: })();",
          "263: (function() {",
          "264:   var request = Buffer(",
          "265:     'POST /it HTTP/1.1' + CRLF +",
          "266:     'Content-Type: application/x-www-form-urlencoded' + CRLF +",
          "267:     'Content-Length: 15' + CRLF +",
          "268:     CRLF +",
          "269:     'foo=42&bar=1337'",
          "270:   );",
          "272:   var parser = newParser(REQUEST);",
          "274:   parser.onHeadersComplete = mustCall(function(info) {",
          "275:     assert.equal(info.method, 'POST');",
          "276:     assert.equal(info.url || parser.url, '/it');",
          "277:     assert.equal(info.versionMajor, 1);",
          "278:     assert.equal(info.versionMinor, 1);",
          "279:   });",
          "281:   parser.onBody = mustCall(function(buf, start, len) {",
          "282:     var body = '' + buf.slice(start, start + len);",
          "283:     assert.equal(body, 'foo=42&bar=1337');",
          "284:   });",
          "286:   parser.execute(request, 0, request.length);",
          "287: })();",
          "293: (function() {",
          "294:   var request = Buffer(",
          "295:     'POST /it HTTP/1.1' + CRLF +",
          "296:     'Content-Type: text/plain' + CRLF +",
          "297:     'Transfer-Encoding: chunked' + CRLF +",
          "298:     CRLF +",
          "299:     '3' + CRLF +",
          "300:     '123' + CRLF +",
          "301:     '6' + CRLF +",
          "302:     '123456' + CRLF +",
          "303:     'A' + CRLF +",
          "304:     '1234567890' + CRLF +",
          "305:     '0' + CRLF",
          "306:   );",
          "308:   var parser = newParser(REQUEST);",
          "310:   parser.onHeadersComplete = mustCall(function(info) {",
          "311:     assert.equal(info.method, 'POST');",
          "312:     assert.equal(info.url || parser.url, '/it');",
          "313:     assert.equal(info.versionMajor, 1);",
          "314:     assert.equal(info.versionMinor, 1);",
          "315:   });",
          "317:   var body_part = 0, body_parts = ['123', '123456', '1234567890'];",
          "319:   function onBody(buf, start, len) {",
          "320:     var body = '' + buf.slice(start, start + len);",
          "321:     assert.equal(body, body_parts[body_part++]);",
          "322:   }",
          "324:   parser.onBody = mustCall(onBody, body_parts.length);",
          "325:   parser.execute(request, 0, request.length);",
          "326: })();",
          "332: (function() {",
          "333:   var request = Buffer(",
          "334:     'POST /it HTTP/1.1' + CRLF +",
          "335:     'Content-Type: text/plain' + CRLF +",
          "336:     'Transfer-Encoding: chunked' + CRLF +",
          "337:     CRLF +",
          "338:     '3' + CRLF +",
          "339:     '123' + CRLF +",
          "340:     '6' + CRLF +",
          "341:     '123456' + CRLF",
          "342:   );",
          "344:   var parser = newParser(REQUEST);",
          "346:   parser.onHeadersComplete = mustCall(function(info) {",
          "347:     assert.equal(info.method, 'POST');",
          "348:     assert.equal(info.url || parser.url, '/it');",
          "349:     assert.equal(info.versionMajor, 1);",
          "350:     assert.equal(info.versionMinor, 1);",
          "351:   });",
          "353:   var body_part = 0, body_parts = [",
          "354:     '123', '123456', '123456789',",
          "355:     '123456789ABC', '123456789ABCDEF' ];",
          "357:   function onBody(buf, start, len) {",
          "358:     var body = '' + buf.slice(start, start + len);",
          "359:     assert.equal(body, body_parts[body_part++]);",
          "360:   }",
          "362:   parser.onBody = mustCall(onBody, body_parts.length);",
          "363:   parser.execute(request, 0, request.length);",
          "365:   request = Buffer(",
          "366:     '9' + CRLF +",
          "367:     '123456789' + CRLF +",
          "368:     'C' + CRLF +",
          "369:     '123456789ABC' + CRLF +",
          "370:     'F' + CRLF +",
          "371:     '123456789ABCDEF' + CRLF +",
          "372:     '0' + CRLF",
          "373:   );",
          "375:   parser.execute(request, 0, request.length);",
          "376: })();",
          "382: (function() {",
          "383:   var request = Buffer(",
          "384:     'POST /it HTTP/1.1' + CRLF +",
          "385:     'Content-Type: text/plain' + CRLF +",
          "386:     'Transfer-Encoding: chunked' + CRLF +",
          "387:     CRLF +",
          "388:     '3' + CRLF +",
          "389:     '123' + CRLF +",
          "390:     '6' + CRLF +",
          "391:     '123456' + CRLF +",
          "392:     '9' + CRLF +",
          "393:     '123456789' + CRLF +",
          "394:     'C' + CRLF +",
          "395:     '123456789ABC' + CRLF +",
          "396:     'F' + CRLF +",
          "397:     '123456789ABCDEF' + CRLF +",
          "398:     '0' + CRLF",
          "399:   );",
          "401:   function test(a, b) {",
          "402:     var parser = newParser(REQUEST);",
          "404:     parser.onHeadersComplete = mustCall(function(info) {",
          "405:       assert.equal(info.method, 'POST');",
          "406:       assert.equal(info.url || parser.url, '/it');",
          "407:       assert.equal(info.versionMajor, 1);",
          "408:       assert.equal(info.versionMinor, 1);",
          "409:     });",
          "411:     var expected_body = '123123456123456789123456789ABC123456789ABCDEF';",
          "413:     parser.onBody = function(buf, start, len) {",
          "414:       var chunk = '' + buf.slice(start, start + len);",
          "415:       assert.equal(expected_body.indexOf(chunk), 0);",
          "416:       expected_body = expected_body.slice(chunk.length);",
          "417:     };",
          "419:     parser.execute(a, 0, a.length);",
          "420:     parser.execute(b, 0, b.length);",
          "422:     assert.equal(expected_body, '');",
          "423:   }",
          "425:   for (var i = 1; i < request.length - 1; ++i) {",
          "426:     var a = request.slice(0, i);",
          "427:     var b = request.slice(i);",
          "428:     test(a, b);",
          "429:   }",
          "430: })();",
          "436: (function() {",
          "437:   var request = Buffer(",
          "438:     'POST /it HTTP/1.1' + CRLF +",
          "439:     'Content-Type: text/plain' + CRLF +",
          "440:     'Transfer-Encoding: chunked' + CRLF +",
          "441:     CRLF +",
          "442:     '3' + CRLF +",
          "443:     '123' + CRLF +",
          "444:     '6' + CRLF +",
          "445:     '123456' + CRLF +",
          "446:     '9' + CRLF +",
          "447:     '123456789' + CRLF +",
          "448:     'C' + CRLF +",
          "449:     '123456789ABC' + CRLF +",
          "450:     'F' + CRLF +",
          "451:     '123456789ABCDEF' + CRLF +",
          "452:     '0' + CRLF",
          "453:   );",
          "455:   var parser = newParser(REQUEST);",
          "457:   parser.onHeadersComplete = mustCall(function(info) {",
          "458:     assert.equal(info.method, 'POST');",
          "459:     assert.equal(info.url || parser.url, '/it');",
          "460:     assert.equal(info.versionMajor, 1);",
          "461:     assert.equal(info.versionMinor, 1);",
          "462:     assert.deepEqual(info.headers || parser.headers,",
          "463:       ['Content-Type', 'text/plain',",
          "464:        'Transfer-Encoding','chunked']);",
          "465:   });",
          "467:   var expected_body = '123123456123456789123456789ABC123456789ABCDEF';",
          "469:   parser.onBody = function(buf, start, len) {",
          "470:     var chunk = '' + buf.slice(start, start + len);",
          "471:     assert.equal(expected_body.indexOf(chunk), 0);",
          "472:     expected_body = expected_body.slice(chunk.length);",
          "473:   };",
          "475:   for (var i = 0; i < request.length; ++i) {",
          "476:     parser.execute(request, i, 1);",
          "477:   }",
          "479:   assert.equal(expected_body, '');",
          "480: })();",
          "486: (function() {",
          "487:   var req1 = Buffer(",
          "488:     'PUT /this HTTP/1.1' + CRLF +",
          "489:     'Content-Type: text/plain' + CRLF +",
          "490:     'Transfer-Encoding: chunked' + CRLF +",
          "491:     CRLF +",
          "492:     '4' + CRLF +",
          "493:     'ping' + CRLF +",
          "494:     '0' + CRLF",
          "495:   );",
          "497:   var req2 = Buffer(",
          "498:     'POST /that HTTP/1.0' + CRLF +",
          "499:     'Content-Type: text/plain' + CRLF +",
          "500:     'Content-Length: 4' + CRLF +",
          "501:     CRLF +",
          "502:     'pong'",
          "503:   );",
          "505:   function onHeadersComplete1(info) {",
          "506:     assert.equal(info.method, 'PUT');",
          "507:     assert.equal(info.url, '/this');",
          "508:     assert.equal(info.versionMajor, 1);",
          "509:     assert.equal(info.versionMinor, 1);",
          "510:     assert.deepEqual(info.headers,",
          "511:       ['Content-Type', 'text/plain',",
          "512:        'Transfer-Encoding', 'chunked']);",
          "513:   };",
          "515:   function onHeadersComplete2(info) {",
          "516:     assert.equal(info.method, 'POST');",
          "517:     assert.equal(info.url, '/that');",
          "518:     assert.equal(info.versionMajor, 1);",
          "519:     assert.equal(info.versionMinor, 0);",
          "520:     assert.deepEqual(info.headers,",
          "521:       ['Content-Type', 'text/plain',",
          "522:        'Content-Length', '4']);",
          "523:   };",
          "525:   var parser = newParser(REQUEST);",
          "526:   parser.onHeadersComplete = onHeadersComplete1;",
          "527:   parser.onBody = expectBody('ping');",
          "528:   parser.execute(req1, 0, req1.length);",
          "530:   parser.reinitialize(REQUEST);",
          "531:   parser.onBody = expectBody('pong');",
          "532:   parser.onHeadersComplete = onHeadersComplete2;",
          "533:   parser.execute(req2, 0, req2.length);",
          "534: })();",
          "",
          "---------------"
        ]
      }
    }
  ]
}
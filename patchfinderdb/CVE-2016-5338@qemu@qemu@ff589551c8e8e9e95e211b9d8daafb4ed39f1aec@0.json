{
  "cve_id": "CVE-2016-5338",
  "cve_desc": "The (1) esp_reg_read and (2) esp_reg_write functions in hw/scsi/esp.c in QEMU allow local guest OS administrators to cause a denial of service (QEMU process crash) or execute arbitrary code on the QEMU host via vectors related to the information transfer buffer.",
  "repo": "qemu/qemu",
  "patch_hash": "ff589551c8e8e9e95e211b9d8daafb4ed39f1aec",
  "patch_info": {
    "commit_hash": "ff589551c8e8e9e95e211b9d8daafb4ed39f1aec",
    "repo": "qemu/qemu",
    "commit_url": "https://github.com/qemu/qemu/commit/ff589551c8e8e9e95e211b9d8daafb4ed39f1aec",
    "files": [
      "hw/scsi/esp.c"
    ],
    "message": "scsi: esp: check TI buffer index before read/write\n\nThe 53C9X Fast SCSI Controller(FSC) comes with internal 16-byte\nFIFO buffers. One is used to handle commands and other is for\ninformation transfer. Three control variables 'ti_rptr',\n'ti_wptr' and 'ti_size' are used to control r/w access to the\ninformation transfer buffer ti_buf[TI_BUFSZ=16]. In that,\n\n'ti_rptr' is used as read index, where read occurs.\n'ti_wptr' is a write index, where write would occur.\n'ti_size' indicates total bytes to be read from the buffer.\n\nWhile reading/writing to this buffer, index could exceed its\nsize. Add check to avoid OOB r/w access.\n\nReported-by: Huawei PSIRT <psirt@huawei.com>\nReported-by: Li Qiang <liqiang6-s@360.cn>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nMessage-Id: <1465230883-22303-1-git-send-email-ppandit@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
    "before_after_code_files": [
      "hw/scsi/esp.c||hw/scsi/esp.c"
    ]
  },
  "patch_diff": {
    "hw/scsi/esp.c||hw/scsi/esp.c": [
      "File: hw/scsi/esp.c -> hw/scsi/esp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "400:     trace_esp_mem_readb(saddr, s->rregs[saddr]);",
      "401:     switch (saddr) {",
      "402:     case ESP_FIFO:",
      "404:             s->ti_size--;",
      "413:             esp_raise_irq(s);",
      "414:         }",
      "416:             s->ti_rptr = 0;",
      "417:             s->ti_wptr = 0;",
      "418:         }",
      "",
      "[Removed Lines]",
      "403:         if (s->ti_size > 0) {",
      "405:             if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {",
      "407:                 qemu_log_mask(LOG_UNIMP,",
      "408:                               \"esp: PIO data read not implemented\\n\");",
      "409:                 s->rregs[ESP_FIFO] = 0;",
      "410:             } else {",
      "411:                 s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];",
      "412:             }",
      "415:         if (s->ti_size == 0) {",
      "",
      "[Added Lines]",
      "403:         if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {",
      "405:             qemu_log_mask(LOG_UNIMP, \"esp: PIO data read not implemented\\n\");",
      "406:             s->rregs[ESP_FIFO] = 0;",
      "407:             esp_raise_irq(s);",
      "408:         } else if (s->ti_rptr < s->ti_wptr) {",
      "410:             s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];",
      "413:         if (s->ti_rptr == s->ti_wptr) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "456:             } else {",
      "457:                 trace_esp_error_fifo_overrun();",
      "458:             }",
      "460:             trace_esp_error_fifo_overrun();",
      "461:         } else {",
      "462:             s->ti_size++;",
      "",
      "[Removed Lines]",
      "459:         } else if (s->ti_size == TI_BUFSZ - 1) {",
      "",
      "[Added Lines]",
      "457:         } else if (s->ti_wptr == TI_BUFSZ - 1) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "236039b89da8cf0a82fe32e605c1d647a13820f0",
      "candidate_info": {
        "commit_hash": "236039b89da8cf0a82fe32e605c1d647a13820f0",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/236039b89da8cf0a82fe32e605c1d647a13820f0",
        "files": [
          "hw/scsi/esp.c"
        ],
        "message": "scsi: esp: check TI buffer index before read/write\n\nThe 53C9X Fast SCSI Controller(FSC) comes with internal 16-byte\nFIFO buffers. One is used to handle commands and other is for\ninformation transfer. Three control variables 'ti_rptr',\n'ti_wptr' and 'ti_size' are used to control r/w access to the\ninformation transfer buffer ti_buf[TI_BUFSZ=16]. In that,\n\n'ti_rptr' is used as read index, where read occurs.\n'ti_wptr' is a write index, where write would occur.\n'ti_size' indicates total bytes to be read from the buffer.\n\nWhile reading/writing to this buffer, index could exceed its\nsize. Add check to avoid OOB r/w access.\n\nReported-by: Huawei PSIRT <psirt@huawei.com>\nReported-by: Li Qiang <liqiang6-s@360.cn>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nMessage-Id: <1465230883-22303-1-git-send-email-ppandit@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n(cherry picked from commit ff589551c8e8e9e95e211b9d8daafb4ed39f1aec)\nSigned-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>",
        "before_after_code_files": [
          "hw/scsi/esp.c||hw/scsi/esp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "hw/scsi/esp.c||hw/scsi/esp.c"
          ],
          "candidate": [
            "hw/scsi/esp.c||hw/scsi/esp.c"
          ]
        }
      },
      "candidate_diff": {
        "hw/scsi/esp.c||hw/scsi/esp.c": [
          "File: hw/scsi/esp.c -> hw/scsi/esp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "402:     trace_esp_mem_readb(saddr, s->rregs[saddr]);",
          "403:     switch (saddr) {",
          "404:     case ESP_FIFO:",
          "406:             s->ti_size--;",
          "415:             esp_raise_irq(s);",
          "416:         }",
          "418:             s->ti_rptr = 0;",
          "419:             s->ti_wptr = 0;",
          "420:         }",
          "",
          "[Removed Lines]",
          "405:         if (s->ti_size > 0) {",
          "407:             if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {",
          "409:                 qemu_log_mask(LOG_UNIMP,",
          "410:                               \"esp: PIO data read not implemented\\n\");",
          "411:                 s->rregs[ESP_FIFO] = 0;",
          "412:             } else {",
          "413:                 s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];",
          "414:             }",
          "417:         if (s->ti_size == 0) {",
          "",
          "[Added Lines]",
          "405:         if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {",
          "407:             qemu_log_mask(LOG_UNIMP, \"esp: PIO data read not implemented\\n\");",
          "408:             s->rregs[ESP_FIFO] = 0;",
          "409:             esp_raise_irq(s);",
          "410:         } else if (s->ti_rptr < s->ti_wptr) {",
          "412:             s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];",
          "415:         if (s->ti_rptr == s->ti_wptr) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "458:             } else {",
          "459:                 trace_esp_error_fifo_overrun();",
          "460:             }",
          "462:             trace_esp_error_fifo_overrun();",
          "463:         } else {",
          "464:             s->ti_size++;",
          "",
          "[Removed Lines]",
          "461:         } else if (s->ti_size == TI_BUFSZ - 1) {",
          "",
          "[Added Lines]",
          "459:         } else if (s->ti_wptr == TI_BUFSZ - 1) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
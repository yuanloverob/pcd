{
  "cve_id": "CVE-2018-11232",
  "cve_desc": "The etm_setup_aux function in drivers/hwtracing/coresight/coresight-etm-perf.c in the Linux kernel before 4.10.2 allows attackers to cause a denial of service (panic) because a parameter is incorrectly used as a local variable.",
  "repo": "torvalds/linux",
  "patch_hash": "f09444639099584bc4784dfcd85ada67c6f33e0f",
  "patch_info": {
    "commit_hash": "f09444639099584bc4784dfcd85ada67c6f33e0f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/f09444639099584bc4784dfcd85ada67c6f33e0f",
    "files": [
      "drivers/hwtracing/coresight/coresight-etm-perf.c"
    ],
    "message": "coresight: fix kernel panic caused by invalid CPU\n\nCommit d52c9750f150 (\"coresight: reset \"enable_sink\" flag when need be\")\ncaused a kernel panic because of the using of an invalid value: after\n'for_each_cpu(cpu, mask)', value of local variable 'cpu' become invalid,\ncauses following 'cpu_to_node' access invalid memory area.\n\nThis patch brings the deleted 'cpu = cpumask_first(mask)' back.\n\nPanic log:\n\n $ perf record -e cs_etm// ls\n\n Unable to handle kernel paging request at virtual address fffe801804af4f10\n pgd = ffff8017ce031600\n [fffe801804af4f10] *pgd=0000000000000000, *pud=0000000000000000\n Internal error: Oops: 96000004 [#1] SMP\n Modules linked in:\n CPU: 33 PID: 1619 Comm: perf Not tainted 4.7.1+ #16\n Hardware name: Huawei Taishan 2280 /CH05TEVBA, BIOS 1.10 11/24/2016\n task: ffff8017cb0c8400 ti: ffff8017cb154000 task.ti: ffff8017cb154000\n PC is at tmc_alloc_etf_buffer+0x60/0xd4\n LR is at tmc_alloc_etf_buffer+0x44/0xd4\n pc : [<ffff000008633df8>] lr : [<ffff000008633ddc>] pstate: 60000145\n sp : ffff8017cb157b40\n x29: ffff8017cb157b40 x28: 0000000000000000\n ...skip...\n 7a60: ffff000008c64dc8 0000000000000006 0000000000000253 ffffffffffffffff\n 7a80: 0000000000000000 0000000000000000 ffff0000080872cc 0000000000000001\n [<ffff000008633df8>] tmc_alloc_etf_buffer+0x60/0xd4\n [<ffff000008632b9c>] etm_setup_aux+0x1dc/0x1e8\n [<ffff00000816eed4>] rb_alloc_aux+0x2b0/0x338\n [<ffff00000816a5e4>] perf_mmap+0x414/0x568\n [<ffff0000081ab694>] mmap_region+0x324/0x544\n [<ffff0000081abbe8>] do_mmap+0x334/0x3e0\n [<ffff000008191150>] vm_mmap_pgoff+0xa4/0xc8\n [<ffff0000081a9a30>] SyS_mmap_pgoff+0xb0/0x22c\n [<ffff0000080872e4>] sys_mmap+0x18/0x28\n [<ffff0000080843f0>] el0_svc_naked+0x24/0x28\n Code: 912040a5 d0001c00 f873d821 911c6000 (b8656822)\n ---[ end trace 98933da8f92b0c9a ]---\n\nSigned-off-by: Wang Nan <wangnan0@huawei.com>\nCc: Xia Kaixu <xiakaixu@huawei.com>\nCc: Li Zefan <lizefan@huawei.com>\nCc: Mathieu Poirier <mathieu.poirier@linaro.org>\nCc: linux-arm-kernel@lists.infradead.org\nCc: linux-kernel@vger.kernel.org\nFixes: d52c9750f150 (\"coresight: reset \"enable_sink\" flag when need be\")\nSigned-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>\nCc: stable <stable@vger.kernel.org> # 4.10\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
    "before_after_code_files": [
      "drivers/hwtracing/coresight/coresight-etm-perf.c||drivers/hwtracing/coresight/coresight-etm-perf.c"
    ]
  },
  "patch_diff": {
    "drivers/hwtracing/coresight/coresight-etm-perf.c||drivers/hwtracing/coresight/coresight-etm-perf.c": [
      "File: drivers/hwtracing/coresight/coresight-etm-perf.c -> drivers/hwtracing/coresight/coresight-etm-perf.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "242:  if (!sink_ops(sink)->alloc_buffer)",
      "243:   goto err;",
      "246:  event_data->snk_config =",
      "247:    sink_ops(sink)->alloc_buffer(sink, cpu, pages,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "245:  cpu = cpumask_first(mask);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "bd00fdf198e2da475a2f4265a83686ab42d998a8",
      "candidate_info": {
        "commit_hash": "bd00fdf198e2da475a2f4265a83686ab42d998a8",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/bd00fdf198e2da475a2f4265a83686ab42d998a8",
        "files": [
          "drivers/vfio/vfio_iommu_spapr_tce.c"
        ],
        "message": "vfio/spapr: fail tce_iommu_attach_group() when iommu_data is null\n\nThe recently added mediated VFIO driver doesn't know about powerpc iommu.\nIt thus doesn't register a struct iommu_table_group in the iommu group\nupon device creation. The iommu_data pointer hence remains null.\n\nThis causes a kernel oops when userspace tries to set the iommu type of a\ncontainer associated with a mediated device to VFIO_SPAPR_TCE_v2_IOMMU.\n\n[   82.585440] mtty mtty: MDEV: Registered\n[   87.655522] iommu: Adding device 83b8f4f2-509f-382f-3c1e-e6bfe0fa1001 to group 10\n[   87.655527] vfio_mdev 83b8f4f2-509f-382f-3c1e-e6bfe0fa1001: MDEV: group_id = 10\n[  116.297184] Unable to handle kernel paging request for data at address 0x00000030\n[  116.297389] Faulting instruction address: 0xd000000007870524\n[  116.297465] Oops: Kernel access of bad area, sig: 11 [#1]\n[  116.297611] SMP NR_CPUS=2048\n[  116.297611] NUMA\n[  116.297627] PowerNV\n...\n[  116.297954] CPU: 33 PID: 7067 Comm: qemu-system-ppc Not tainted 4.10.0-rc5-mdev-test #8\n[  116.297993] task: c000000e7718b680 task.stack: c000000e77214000\n[  116.298025] NIP: d000000007870524 LR: d000000007870518 CTR: 0000000000000000\n[  116.298064] REGS: c000000e77217990 TRAP: 0300   Not tainted  (4.10.0-rc5-mdev-test)\n[  116.298103] MSR: 9000000000009033 <SF,HV,EE,ME,IR,DR,RI,LE>\n[  116.298107]   CR: 84004444  XER: 00000000\n[  116.298154] CFAR: c00000000000888c DAR: 0000000000000030 DSISR: 40000000 SOFTE: 1\n               GPR00: d000000007870518 c000000e77217c10 d00000000787b0ed c000000eed2103c0\n               GPR04: 0000000000000000 0000000000000000 c000000eed2103e0 0000000f24320000\n               GPR08: 0000000000000104 0000000000000001 0000000000000000 d0000000078729b0\n               GPR12: c00000000025b7e0 c00000000fe08400 0000000000000001 000001002d31d100\n               GPR16: 000001002c22c850 00003ffff315c750 0000000043145680 0000000043141bc0\n               GPR20: ffffffffffffffed fffffffffffff000 0000000020003b65 d000000007706018\n               GPR24: c000000f16cf0d98 d000000007706000 c000000003f42980 c000000003f42980\n               GPR28: c000000f1575ac00 c000000003f429c8 0000000000000000 c000000eed2103c0\n[  116.298504] NIP [d000000007870524] tce_iommu_attach_group+0x10c/0x360 [vfio_iommu_spapr_tce]\n[  116.298555] LR [d000000007870518] tce_iommu_attach_group+0x100/0x360 [vfio_iommu_spapr_tce]\n[  116.298601] Call Trace:\n[  116.298610] [c000000e77217c10] [d000000007870518] tce_iommu_attach_group+0x100/0x360 [vfio_iommu_spapr_tce] (unreliable)\n[  116.298671] [c000000e77217cb0] [d0000000077033a0] vfio_fops_unl_ioctl+0x278/0x3e0 [vfio]\n[  116.298713] [c000000e77217d40] [c0000000002a3ebc] do_vfs_ioctl+0xcc/0x8b0\n[  116.298745] [c000000e77217de0] [c0000000002a4700] SyS_ioctl+0x60/0xc0\n[  116.298782] [c000000e77217e30] [c00000000000b220] system_call+0x38/0xfc\n[  116.298812] Instruction dump:\n[  116.298828] 7d3f4b78 409effc8 3d220000 e9298020 3c800140 38a00018 608480c0 e8690028\n[  116.298869] 4800249d e8410018 7c7f1b79 41820230 <e93e0030> 2fa90000 419e0114 e9090020\n[  116.298914] ---[ end trace 1e10b0ced08b9120 ]---\n\nThis patch fixes the oops.\n\nReported-by: Vaibhav Jain <vaibhav@linux.vnet.ibm.com>\nSigned-off-by: Greg Kurz <groug@kaod.org>\nSigned-off-by: Alex Williamson <alex.williamson@redhat.com>",
        "before_after_code_files": [
          "drivers/vfio/vfio_iommu_spapr_tce.c||drivers/vfio/vfio_iommu_spapr_tce.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/vfio/vfio_iommu_spapr_tce.c||drivers/vfio/vfio_iommu_spapr_tce.c": [
          "File: drivers/vfio/vfio_iommu_spapr_tce.c -> drivers/vfio/vfio_iommu_spapr_tce.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1272:  table_group = iommu_group_get_iommudata(iommu_group);",
          "1274:  if (tce_groups_attached(container) && (!table_group->ops ||",
          "1275:    !table_group->ops->take_ownership ||",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1273:  if (!table_group) {",
          "1274:   ret = -ENODEV;",
          "1275:   goto unlock_exit;",
          "1276:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "362f4562466c3b9490e733e06999025638310d4a",
      "candidate_info": {
        "commit_hash": "362f4562466c3b9490e733e06999025638310d4a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/362f4562466c3b9490e733e06999025638310d4a",
        "files": [
          "drivers/dma/cppi41.c"
        ],
        "message": "dmaengine: cppi41: Fix oops in cppi41_runtime_resume\n\nCommit fdea2d09b997 (\"dmaengine: cppi41: Add basic PM runtime support\")\ntogether with recent MUSB changes allowed USB and DMA on BeagleBone to idle\nwhen no cable is connected. But looks like few corner case issues still\nremain.\n\nLooks like just by re-plugging USB cable about ten or so times on BeagleBone\nwhen configured in USB peripheral mode we can get warnings and eventually\ntrigger an oops in cppi41 DMA:\n\nWARNING: CPU: 0 PID: 14 at drivers/dma/cppi41.c:1154 cppi41_runtime_suspend+\nx28/0x38 [cppi41]\n...\n\nWARNING: CPU: 0 PID: 14 at drivers/dma/cppi41.c:452\npush_desc_queue+0x94/0x9c [cppi41]\n...\n\nUnable to handle kernel NULL pointer dereference at virtual\naddress 00000104\npgd = c0004000\n[00000104] *pgd=00000000\nInternal error: Oops: 805 [#1] SMP ARM\n...\n[<bf0d92cc>] (cppi41_runtime_resume [cppi41]) from [<c0589838>]\n(__rpm_callback+0xc0/0x214)\n[<c0589838>] (__rpm_callback) from [<c05899ac>] (rpm_callback+0x20/0x80)\n[<c05899ac>] (rpm_callback) from [<c0589460>] (rpm_resume+0x504/0x78c)\n[<c0589460>] (rpm_resume) from [<c058a1a0>] (pm_runtime_work+0x60/0xa8)\n[<c058a1a0>] (pm_runtime_work) from [<c0156120>] (process_one_work+0x2b4/0x808)\n\nThis is because of a race with runtime PM and cppi41_dma_issue_pending()\nas reported by Alexandre Bailon <abailon@baylibre.com> in earlier\nset of patches. Based on mailing list discussions we however came to the\nconclusion that a different fix from Alexandre's fix is needed in order\nto guarantee that DMA is really active when we try to use it.\n\nTo fix the issue, we need to add a driver specific flag as we otherwise\ncan have -EINPROGRESS state set by runtime PM and can't rely on\npm_runtime_active() to tell us when we can use the DMA.\n\nAnd we need to make sure the DMA transfers get triggered in the queued\norder. So let's always queue the transfers, then flush the queue\nfrom both cppi41_dma_issue_pending() and cppi41_runtime_resume()\nas suggested by Grygorii Strashko <grygorii.strashko@ti.com> in an\nearlier example patch.\n\nFor reference, this is also documented in Documentation/power/runtime_pm.txt\nin the example at the end of the file as pointed out by Grygorii Strashko\n<grygorii.strashko@ti.com>.\n\nBased on earlier patches from Alexandre Bailon <abailon@baylibre.com>\nand Grygorii Strashko <grygorii.strashko@ti.com> modified based on\ntesting and what was discussed on the mailing lists.\n\nFixes: fdea2d09b997 (\"dmaengine: cppi41: Add basic PM runtime support\")\nCc: Andy Shevchenko <andy.shevchenko@gmail.com>\nCc: Bin Liu <b-liu@ti.com>\nCc: Grygorii Strashko <grygorii.strashko@ti.com>\nCc: Kevin Hilman <khilman@baylibre.com>\nCc: Patrick Titiano <ptitiano@baylibre.com>\nCc: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>\nReported-by: Alexandre Bailon <abailon@baylibre.com>\nSigned-off-by: Tony Lindgren <tony@atomide.com>\nTested-by: Bin Liu <b-liu@ti.com>\nSigned-off-by: Vinod Koul <vinod.koul@intel.com>",
        "before_after_code_files": [
          "drivers/dmcppi41.c||drivers/dma/cppi41.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/dmcppi41.c||drivers/dma/cppi41.c": [
          "File: drivers/dmcppi41.c -> drivers/dma/cppi41.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "157:  bool is_suspended;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "480: static void cppi41_run_queue(struct cppi41_dd *cdd)",
          "482:  struct cppi41_channel *c, *_c;",
          "484:  list_for_each_entry_safe(c, _c, &cdd->pending, node) {",
          "485:   push_desc_queue(c);",
          "486:   list_del(&c->node);",
          "487:  }",
          "494:  unsigned long flags;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "506:  spin_lock_irqsave(&cdd->lock, flags);",
          "507:  list_add_tail(&c->node, &cdd->pending);",
          "508:  if (!cdd->is_suspended)",
          "509:   cppi41_run_queue(cdd);",
          "510:  spin_unlock_irqrestore(&cdd->lock, flags);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1178:  unsigned long flags;",
          "1180:  spin_lock_irqsave(&cdd->lock, flags);",
          "1181:  cdd->is_suspended = true;",
          "1183:  spin_unlock_irqrestore(&cdd->lock, flags);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1194:  cdd->is_suspended = false;",
          "1195:  cppi41_run_queue(cdd);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "47b03ca903fb07a69ba88d2e1629fe145771f116",
      "candidate_info": {
        "commit_hash": "47b03ca903fb07a69ba88d2e1629fe145771f116",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/47b03ca903fb07a69ba88d2e1629fe145771f116",
        "files": [
          "drivers/pinctrl/qcom/pinctrl-msm.c"
        ],
        "message": "pinctrl: qcom: Use raw spinlock variants\n\nThe MSM pinctrl driver currently implements an irq_chip for handling\nGPIO interrupts; due to how irq_chip handling is done, it's necessary\nfor the irq_chip methods to be invoked from hardirq context, even on a\na real-time kernel.  Because the spinlock_t type becomes a \"sleeping\"\nspinlock w/ RT kernels, it is not suitable to be used with irq_chips.\n\nA quick audit of the operations under the lock reveal that they do only\nminimal, bounded work, and are therefore safe to do under a raw\nspinlock.\n\nOn real-time kernels, this fixes an OOPs which looks like the following,\nas reported by Brian Wrenn:\n\n    kernel BUG at kernel/locking/rtmutex.c:1014!\n    Internal error: Oops - BUG: 0 [#1] PREEMPT SMP\n    Modules linked in: spidev_irq(O) smsc75xx wcn36xx [last unloaded: spidev]\n    CPU: 0 PID: 1163 Comm: irq/144-mmc0 Tainted: G        W  O    4.4.9-linaro-lt-qcom #1\n    PC is at rt_spin_lock_slowlock+0x80/0x2d8\n    LR is at rt_spin_lock_slowlock+0x68/0x2d8\n    [..]\n  Call trace:\n    rt_spin_lock_slowlock\n    rt_spin_lock\n    msm_gpio_irq_ack\n    handle_edge_irq\n    generic_handle_irq\n    msm_gpio_irq_handler\n    generic_handle_irq\n    __handle_domain_irq\n    gic_handle_irq\n\nReported-by: Brian Wrenn <dcbrianw@gmail.com>\nTested-by: Brian Wrenn <dcbrianw@gmail.com>\nSigned-off-by: Julia Cartwright <julia@ni.com>\nAcked-by: Bjorn Andersson <bjorn.andersson@linaro.org>\nSigned-off-by: Linus Walleij <linus.walleij@linaro.org>",
        "before_after_code_files": [
          "drivers/pinctrl/qcom/pinctrl-msm.c||drivers/pinctrl/qcom/pinctrl-msm.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/pinctrl/qcom/pinctrl-msm.c||drivers/pinctrl/qcom/pinctrl-msm.c": [
          "File: drivers/pinctrl/qcom/pinctrl-msm.c -> drivers/pinctrl/qcom/pinctrl-msm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "61:  struct notifier_block restart_nb;",
          "62:  int irq;",
          "66:  DECLARE_BITMAP(dual_edge_irqs, MAX_NR_GPIO);",
          "67:  DECLARE_BITMAP(enabled_irqs, MAX_NR_GPIO);",
          "",
          "[Removed Lines]",
          "64:  spinlock_t lock;",
          "",
          "[Added Lines]",
          "64:  raw_spinlock_t lock;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "153:  if (WARN_ON(i == g->nfuncs))",
          "154:   return -EINVAL;",
          "158:  val = readl(pctrl->regs + g->ctl_reg);",
          "159:  val &= ~mask;",
          "160:  val |= i << g->mux_bit;",
          "161:  writel(val, pctrl->regs + g->ctl_reg);",
          "165:  return 0;",
          "166: }",
          "",
          "[Removed Lines]",
          "156:  spin_lock_irqsave(&pctrl->lock, flags);",
          "163:  spin_unlock_irqrestore(&pctrl->lock, flags);",
          "",
          "[Added Lines]",
          "156:  raw_spin_lock_irqsave(&pctrl->lock, flags);",
          "163:  raw_spin_unlock_irqrestore(&pctrl->lock, flags);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "323:    break;",
          "324:   case PIN_CONFIG_OUTPUT:",
          "327:    val = readl(pctrl->regs + g->io_reg);",
          "328:    if (arg)",
          "329:     val |= BIT(g->out_bit);",
          "330:    else",
          "331:     val &= ~BIT(g->out_bit);",
          "332:    writel(val, pctrl->regs + g->io_reg);",
          "336:    arg = 1;",
          "",
          "[Removed Lines]",
          "326:    spin_lock_irqsave(&pctrl->lock, flags);",
          "333:    spin_unlock_irqrestore(&pctrl->lock, flags);",
          "",
          "[Added Lines]",
          "326:    raw_spin_lock_irqsave(&pctrl->lock, flags);",
          "333:    raw_spin_unlock_irqrestore(&pctrl->lock, flags);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "351:    return -EINVAL;",
          "352:   }",
          "355:   val = readl(pctrl->regs + g->ctl_reg);",
          "356:   val &= ~(mask << bit);",
          "357:   val |= arg << bit;",
          "358:   writel(val, pctrl->regs + g->ctl_reg);",
          "360:  }",
          "362:  return 0;",
          "",
          "[Removed Lines]",
          "354:   spin_lock_irqsave(&pctrl->lock, flags);",
          "359:   spin_unlock_irqrestore(&pctrl->lock, flags);",
          "",
          "[Added Lines]",
          "354:   raw_spin_lock_irqsave(&pctrl->lock, flags);",
          "359:   raw_spin_unlock_irqrestore(&pctrl->lock, flags);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "385:  g = &pctrl->soc->groups[offset];",
          "389:  val = readl(pctrl->regs + g->ctl_reg);",
          "390:  val &= ~BIT(g->oe_bit);",
          "391:  writel(val, pctrl->regs + g->ctl_reg);",
          "395:  return 0;",
          "396: }",
          "",
          "[Removed Lines]",
          "387:  spin_lock_irqsave(&pctrl->lock, flags);",
          "393:  spin_unlock_irqrestore(&pctrl->lock, flags);",
          "",
          "[Added Lines]",
          "387:  raw_spin_lock_irqsave(&pctrl->lock, flags);",
          "393:  raw_spin_unlock_irqrestore(&pctrl->lock, flags);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "405:  g = &pctrl->soc->groups[offset];",
          "409:  val = readl(pctrl->regs + g->io_reg);",
          "410:  if (value)",
          "",
          "[Removed Lines]",
          "407:  spin_lock_irqsave(&pctrl->lock, flags);",
          "",
          "[Added Lines]",
          "407:  raw_spin_lock_irqsave(&pctrl->lock, flags);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "417:  val |= BIT(g->oe_bit);",
          "418:  writel(val, pctrl->regs + g->ctl_reg);",
          "422:  return 0;",
          "423: }",
          "",
          "[Removed Lines]",
          "420:  spin_unlock_irqrestore(&pctrl->lock, flags);",
          "",
          "[Added Lines]",
          "420:  raw_spin_unlock_irqrestore(&pctrl->lock, flags);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "444:  g = &pctrl->soc->groups[offset];",
          "448:  val = readl(pctrl->regs + g->io_reg);",
          "449:  if (value)",
          "",
          "[Removed Lines]",
          "446:  spin_lock_irqsave(&pctrl->lock, flags);",
          "",
          "[Added Lines]",
          "446:  raw_spin_lock_irqsave(&pctrl->lock, flags);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "452:   val &= ~BIT(g->out_bit);",
          "453:  writel(val, pctrl->regs + g->io_reg);",
          "456: }",
          "458: #ifdef CONFIG_DEBUG_FS",
          "",
          "[Removed Lines]",
          "455:  spin_unlock_irqrestore(&pctrl->lock, flags);",
          "",
          "[Added Lines]",
          "455:  raw_spin_unlock_irqrestore(&pctrl->lock, flags);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "572:  g = &pctrl->soc->groups[d->hwirq];",
          "576:  val = readl(pctrl->regs + g->intr_cfg_reg);",
          "577:  val &= ~BIT(g->intr_enable_bit);",
          "",
          "[Removed Lines]",
          "574:  spin_lock_irqsave(&pctrl->lock, flags);",
          "",
          "[Added Lines]",
          "574:  raw_spin_lock_irqsave(&pctrl->lock, flags);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "580:  clear_bit(d->hwirq, pctrl->enabled_irqs);",
          "583: }",
          "585: static void msm_gpio_irq_unmask(struct irq_data *d)",
          "",
          "[Removed Lines]",
          "582:  spin_unlock_irqrestore(&pctrl->lock, flags);",
          "",
          "[Added Lines]",
          "582:  raw_spin_unlock_irqrestore(&pctrl->lock, flags);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "593:  g = &pctrl->soc->groups[d->hwirq];",
          "597:  val = readl(pctrl->regs + g->intr_status_reg);",
          "598:  val &= ~BIT(g->intr_status_bit);",
          "",
          "[Removed Lines]",
          "595:  spin_lock_irqsave(&pctrl->lock, flags);",
          "",
          "[Added Lines]",
          "595:  raw_spin_lock_irqsave(&pctrl->lock, flags);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "605:  set_bit(d->hwirq, pctrl->enabled_irqs);",
          "608: }",
          "610: static void msm_gpio_irq_ack(struct irq_data *d)",
          "",
          "[Removed Lines]",
          "607:  spin_unlock_irqrestore(&pctrl->lock, flags);",
          "",
          "[Added Lines]",
          "607:  raw_spin_unlock_irqrestore(&pctrl->lock, flags);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "618:  g = &pctrl->soc->groups[d->hwirq];",
          "622:  val = readl(pctrl->regs + g->intr_status_reg);",
          "623:  if (g->intr_ack_high)",
          "",
          "[Removed Lines]",
          "620:  spin_lock_irqsave(&pctrl->lock, flags);",
          "",
          "[Added Lines]",
          "620:  raw_spin_lock_irqsave(&pctrl->lock, flags);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "629:  if (test_bit(d->hwirq, pctrl->dual_edge_irqs))",
          "630:   msm_gpio_update_dual_edge_pos(pctrl, g, d);",
          "633: }",
          "635: static int msm_gpio_irq_set_type(struct irq_data *d, unsigned int type)",
          "",
          "[Removed Lines]",
          "632:  spin_unlock_irqrestore(&pctrl->lock, flags);",
          "",
          "[Added Lines]",
          "632:  raw_spin_unlock_irqrestore(&pctrl->lock, flags);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "643:  g = &pctrl->soc->groups[d->hwirq];",
          "",
          "[Removed Lines]",
          "645:  spin_lock_irqsave(&pctrl->lock, flags);",
          "",
          "[Added Lines]",
          "645:  raw_spin_lock_irqsave(&pctrl->lock, flags);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "716:  if (test_bit(d->hwirq, pctrl->dual_edge_irqs))",
          "717:   msm_gpio_update_dual_edge_pos(pctrl, g, d);",
          "721:  if (type & (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH))",
          "722:   irq_set_handler_locked(d, handle_level_irq);",
          "",
          "[Removed Lines]",
          "719:  spin_unlock_irqrestore(&pctrl->lock, flags);",
          "",
          "[Added Lines]",
          "719:  raw_spin_unlock_irqrestore(&pctrl->lock, flags);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "732:  struct msm_pinctrl *pctrl = gpiochip_get_data(gc);",
          "733:  unsigned long flags;",
          "737:  irq_set_irq_wake(pctrl->irq, on);",
          "741:  return 0;",
          "742: }",
          "",
          "[Removed Lines]",
          "735:  spin_lock_irqsave(&pctrl->lock, flags);",
          "739:  spin_unlock_irqrestore(&pctrl->lock, flags);",
          "",
          "[Added Lines]",
          "735:  raw_spin_lock_irqsave(&pctrl->lock, flags);",
          "739:  raw_spin_unlock_irqrestore(&pctrl->lock, flags);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "882:  pctrl->soc = soc_data;",
          "883:  pctrl->chip = msm_gpio_template;",
          "887:  res = platform_get_resource(pdev, IORESOURCE_MEM, 0);",
          "888:  pctrl->regs = devm_ioremap_resource(&pdev->dev, res);",
          "",
          "[Removed Lines]",
          "885:  spin_lock_init(&pctrl->lock);",
          "",
          "[Added Lines]",
          "885:  raw_spin_lock_init(&pctrl->lock);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "191e885a2e130e639bb0c8ee350d7047294f2ce6",
      "candidate_info": {
        "commit_hash": "191e885a2e130e639bb0c8ee350d7047294f2ce6",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/191e885a2e130e639bb0c8ee350d7047294f2ce6",
        "files": [
          "drivers/base/firmware_class.c"
        ],
        "message": "firmware: fix NULL pointer dereference in __fw_load_abort()\n\nSince commit 5d47ec02c37ea6 (\"firmware: Correct handling of\nfw_state_wait() return value\") fw_load_abort() could be called twice and\nlead us to a kernel crash. This happens only when the firmware fallback\nmechanism (regular or custom) is used. The fallback mechanism exposes a\nsysfs interface for userspace to upload a file and notify the kernel\nwhen the file is loaded and ready, or to cancel an upload by echo'ing -1\ninto on the loading file:\n\necho -n \"-1\" > /sys/$DEVPATH/loading\n\nThis will call fw_load_abort(). Some distributions actually have a udev\nrule in place to *always* immediately cancel all firmware fallback\nmechanism requests (Debian), they have:\n\n  $ cat /lib/udev/rules.d/50-firmware.rules\n  # stub for immediately telling the kernel that userspace firmware loading\n  # failed; necessary to avoid long timeouts with CONFIG_FW_LOADER_USER_HELPER=y\n  SUBSYSTEM==\"firmware\", ACTION==\"add\", ATTR{loading}=\"-1\n\nDistributions with this udev rule would run into this crash only if the\nfallback mechanism is used. Since most distributions disable by default\nusing the fallback mechanism (CONFIG_FW_LOADER_USER_HELPER_FALLBACK),\nthis would typicaly mean only 2 drivers which *require* the fallback\nmechanism could typically incur a crash: drivers/firmware/dell_rbu.c and\nthe drivers/leds/leds-lp55xx-common.c driver. Distributions enabling\nCONFIG_FW_LOADER_USER_HELPER_FALLBACK by default are obviously more\nexposed to this crash.\n\nThe crash happens because after commit 5b029624948d (\"firmware: do not\nuse fw_lock for fw_state protection\") and subsequent fix commit\n5d47ec02c37ea6 (\"firmware: Correct handling of fw_state_wait() return\nvalue\") a race can happen between this cancelation and the firmware\nfw_state_wait_timeout() being woken up after a state change with which\nfw_load_abort() as that calls swake_up(). Upon error\nfw_state_wait_timeout() will also again call fw_load_abort() and trigger\na null reference.\n\nAt first glance we could just fix this with a !buf check on\nfw_load_abort() before accessing buf->fw_st, however there is a logical\nissue in having a state machine used for the fallback mechanism and\npreventing access from it once we abort as its inside the buf\n(buf->fw_st).\n\nThe firmware_class.c code is setting the buf to NULL to annotate an\nabort has occurred. Replace this mechanism by simply using the state\ncheck instead. All the other code in place already uses similar checks\nfor aborting as well so no further changes are needed.\n\nAn oops can be reproduced with the new fw_fallback.sh fallback mechanism\ncancellation test. Either cancelling the fallback mechanism or the\ncustom fallback mechanism triggers a crash.\n\nmcgrof@piggy ~/linux-next/tools/testing/selftests/firmware\n(git::20170111-fw-fixes)$ sudo ./fw_fallback.sh\n\n./fw_fallback.sh: timeout works\n./fw_fallback.sh: firmware comparison works\n./fw_fallback.sh: fallback mechanism works\n\n[ this then sits here when it is trying the cancellation test ]\n\nKernel log:\n\ntest_firmware: loading 'nope-test-firmware.bin'\nmisc test_firmware: Direct firmware load for nope-test-firmware.bin failed with error -2\nmisc test_firmware: Falling back to user helper\nBUG: unable to handle kernel NULL pointer dereference at 0000000000000038\nIP: _request_firmware+0xa27/0xad0\nPGD 0\n\nOops: 0000 [#1] SMP\nModules linked in: test_firmware(E) ... etc ...\nCPU: 1 PID: 1396 Comm: fw_fallback.sh Tainted: G        W E   4.10.0-rc3-next-20170111+ #30\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.10.1-0-g8891697-prebuilt.qemu-project.org 04/01/2014\ntask: ffff9740b27f4340 task.stack: ffffbb15c0bc8000\nRIP: 0010:_request_firmware+0xa27/0xad0\nRSP: 0018:ffffbb15c0bcbd10 EFLAGS: 00010246\nRAX: 00000000fffffffe RBX: ffff9740afe5aa80 RCX: 0000000000000000\nRDX: ffff9740b27f4340 RSI: 0000000000000283 RDI: 0000000000000000\nRBP: ffffbb15c0bcbd90 R08: ffffbb15c0bcbcd8 R09: 0000000000000000\nR10: 0000000894a0d4b1 R11: 000000000000008c R12: ffffffffc0312480\nR13: 0000000000000005 R14: ffff9740b1c32400 R15: 00000000000003e8\nFS:  00007f8604422700(0000) GS:ffff9740bfc80000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000000038 CR3: 000000012164c000 CR4: 00000000000006e0\nCall Trace:\n request_firmware+0x37/0x50\n trigger_request_store+0x79/0xd0 [test_firmware]\n dev_attr_store+0x18/0x30\n sysfs_kf_write+0x37/0x40\n kernfs_fop_write+0x110/0x1a0\n __vfs_write+0x37/0x160\n ? _cond_resched+0x1a/0x50\n vfs_write+0xb5/0x1a0\n SyS_write+0x55/0xc0\n ? trace_do_page_fault+0x37/0xd0\n entry_SYSCALL_64_fastpath+0x1e/0xad\nRIP: 0033:0x7f8603f49620\nRSP: 002b:00007fff6287b788 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\nRAX: ffffffffffffffda RBX: 000055c307b110a0 RCX: 00007f8603f49620\nRDX: 0000000000000016 RSI: 000055c3084d8a90 RDI: 0000000000000001\nRBP: 0000000000000016 R08: 000000000000c0ff R09: 000055c3084d6336\nR10: 000055c307b108b0 R11: 0000000000000246 R12: 000055c307b13c80\nR13: 000055c3084d6320 R14: 0000000000000000 R15: 00007fff6287b950\nCode: 9f 64 84 e8 9c 61 fe ff b8 f4 ff ff ff e9 6b f9 ff\nff 48 c7 c7 40 6b 8d 84 89 45 a8 e8 43 84 18 00 49 8b be 00 03 00 00 8b\n45 a8 <83> 7f 38 02 74 08 e8 6e ec ff ff 8b 45 a8 49 c7 86 00 03 00 00\nRIP: _request_firmware+0xa27/0xad0 RSP: ffffbb15c0bcbd10\nCR2: 0000000000000038\n---[ end trace 6d94ac339c133e6f ]---\n\nFixes: 5d47ec02c37e (\"firmware: Correct handling of fw_state_wait() return value\")\nReported-and-Tested-by: Jakub Kicinski <jakub.kicinski@netronome.com>\nReported-and-Tested-by: Patrick Bruenn <p.bruenn@beckhoff.com>\nReported-by: Chris Wilson <chris@chris-wilson.co.uk>\nCC: <stable@vger.kernel.org>    [3.10+]\nSigned-off-by: Luis R. Rodriguez <mcgrof@kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "before_after_code_files": [
          "drivers/base/firmware_class.c||drivers/base/firmware_class.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/base/firmware_class.c||drivers/base/firmware_class.c": [
          "File: drivers/base/firmware_class.c -> drivers/base/firmware_class.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "558:  struct firmware_buf *buf = fw_priv->buf;",
          "560:  __fw_load_abort(buf);",
          "564: }",
          "566: static LIST_HEAD(pending_fw_head);",
          "",
          "[Removed Lines]",
          "563:  fw_priv->buf = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "714:  mutex_lock(&fw_lock);",
          "715:  fw_buf = fw_priv->buf;",
          "717:   goto out;",
          "719:  switch (loading) {",
          "",
          "[Removed Lines]",
          "716:  if (!fw_buf)",
          "",
          "[Added Lines]",
          "713:  if (fw_state_is_aborted(&fw_buf->fw_st))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1f17e2f2c8a8be3430813119fa7b633398f6185b",
      "candidate_info": {
        "commit_hash": "1f17e2f2c8a8be3430813119fa7b633398f6185b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1f17e2f2c8a8be3430813119fa7b633398f6185b",
        "files": [
          "net/ipv6/route.c"
        ],
        "message": "net: ipv6: ignore null_entry on route dumps\n\nlkp-robot reported a BUG:\n[   10.151226] BUG: unable to handle kernel NULL pointer dereference at 00000198\n[   10.152525] IP: rt6_fill_node+0x164/0x4b8\n[   10.153307] *pdpt = 0000000012ee5001 *pde = 0000000000000000\n[   10.153309]\n[   10.154492] Oops: 0000 [#1]\n[   10.154987] CPU: 0 PID: 909 Comm: netifd Not tainted 4.10.0-rc4-00722-g41e8c70ee162-dirty #10\n[   10.156482] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.7.5-20140531_083030-gandalf 04/01/2014\n[   10.158254] task: d0deb000 task.stack: d0e0c000\n[   10.159059] EIP: rt6_fill_node+0x164/0x4b8\n[   10.159780] EFLAGS: 00010296 CPU: 0\n[   10.160404] EAX: 00000000 EBX: d10c2358 ECX: c1f7c6cc EDX: c1f6ff44\n[   10.161469] ESI: 00000000 EDI: c2059900 EBP: d0e0dc4c ESP: d0e0dbe4\n[   10.162534]  DS: 007b ES: 007b FS: 0000 GS: 0033 SS: 0068\n[   10.163482] CR0: 80050033 CR2: 00000198 CR3: 10d94660 CR4: 000006b0\n[   10.164535] Call Trace:\n[   10.164993]  ? paravirt_sched_clock+0x9/0xd\n[   10.165727]  ? sched_clock+0x9/0xc\n[   10.166329]  ? sched_clock_cpu+0x19/0xe9\n[   10.166991]  ? lock_release+0x13e/0x36c\n[   10.167652]  rt6_dump_route+0x4c/0x56\n[   10.168276]  fib6_dump_node+0x1d/0x3d\n[   10.168913]  fib6_walk_continue+0xab/0x167\n[   10.169611]  fib6_walk+0x2a/0x40\n[   10.170182]  inet6_dump_fib+0xfb/0x1e0\n[   10.170855]  netlink_dump+0xcd/0x21f\n\nThis happens when the loopback device is set down and a ipv6 fib route\ndump is requested.\n\nip6_null_entry is the root of all ipv6 fib tables making it integrated\ninto the table and hence passed to the ipv6 route dump code. The\nnull_entry route uses the loopback device for dst.dev but may not have\nrt6i_idev set because of the order in which initializations are done --\nip6_route_net_init is run before addrconf_init has initialized the\nloopback device. Fixing the initialization order is a much bigger problem\nwith no obvious solution thus far.\n\nThe BUG is triggered when the loopback is set down and the netif_running\ncheck added by a1a22c1206 fails. The fill_node descends to checking\nrt->rt6i_idev for ignore_routes_with_linkdown and since rt6i_idev is\nNULL it faults.\n\nThe null_entry route should not be processed in a dump request. Catch\nand ignore. This check is done in rt6_dump_route as it is the highest\nplace in the callchain with knowledge of both the route and the network\nnamespace.\n\nFixes: a1a22c1206(\"net: ipv6: Keep nexthop of multipath route on admin down\")\nSigned-off-by: David Ahern <dsa@cumulusnetworks.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv6/route.c||net/ipv6/route.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/ipv6/route.c||net/ipv6/route.c": [
          "File: net/ipv6/route.c -> net/ipv6/route.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3320: int rt6_dump_route(struct rt6_info *rt, void *p_arg)",
          "3321: {",
          "3322:  struct rt6_rtnl_dump_arg *arg = (struct rt6_rtnl_dump_arg *) p_arg;",
          "3324:  if (nlmsg_len(arg->cb->nlh) >= sizeof(struct rtmsg)) {",
          "3325:   struct rtmsg *rtm = nlmsg_data(arg->cb->nlh);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3323:  struct net *net = arg->net;",
          "3325:  if (rt == net->ipv6.ip6_null_entry)",
          "3326:   return 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3332:   }",
          "3333:  }",
          "3336:        arg->skb, rt, NULL, NULL, 0, RTM_NEWROUTE,",
          "3337:        NETLINK_CB(arg->cb->skb).portid, arg->cb->nlh->nlmsg_seq,",
          "3338:        NLM_F_MULTI);",
          "",
          "[Removed Lines]",
          "3335:  return rt6_fill_node(arg->net,",
          "",
          "[Added Lines]",
          "3339:  return rt6_fill_node(net,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
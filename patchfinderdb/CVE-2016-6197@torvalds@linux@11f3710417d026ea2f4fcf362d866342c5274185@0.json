{
  "cve_id": "CVE-2016-6197",
  "cve_desc": "fs/overlayfs/dir.c in the OverlayFS filesystem implementation in the Linux kernel before 4.6 does not properly verify the upper dentry before proceeding with unlink and rename system-call processing, which allows local users to cause a denial of service (system crash) via a rename system call that specifies a self-hardlink.",
  "repo": "torvalds/linux",
  "patch_hash": "11f3710417d026ea2f4fcf362d866342c5274185",
  "patch_info": {
    "commit_hash": "11f3710417d026ea2f4fcf362d866342c5274185",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/11f3710417d026ea2f4fcf362d866342c5274185",
    "files": [
      "fs/overlayfs/dir.c"
    ],
    "message": "ovl: verify upper dentry before unlink and rename\n\nUnlink and rename in overlayfs checked the upper dentry for staleness by\nverifying upper->d_parent against upperdir.  However the dentry can go\nstale also by being unhashed, for example.\n\nExpand the verification to actually look up the name again (under parent\nlock) and check if it matches the upper dentry.  This matches what the VFS\ndoes before passing the dentry to filesytem's unlink/rename methods, which\nexcludes any inconsistency caused by overlayfs.\n\nSigned-off-by: Miklos Szeredi <mszeredi@redhat.com>",
    "before_after_code_files": [
      "fs/overlayfs/dir.c||fs/overlayfs/dir.c"
    ]
  },
  "patch_diff": {
    "fs/overlayfs/dir.c||fs/overlayfs/dir.c": [
      "File: fs/overlayfs/dir.c -> fs/overlayfs/dir.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "596: {",
      "597:  struct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);",
      "598:  struct inode *dir = upperdir->d_inode;",
      "600:  int err;",
      "602:  inode_lock_nested(dir, I_MUTEX_PARENT);",
      "603:  err = -ESTALE;",
      "607:   if (is_dir)",
      "608:    err = vfs_rmdir(dir, upper);",
      "609:   else",
      "610:    err = vfs_unlink(dir, upper, NULL);",
      "612:   ovl_dentry_version_inc(dentry->d_parent);",
      "613:  }",
      "",
      "[Removed Lines]",
      "599:  struct dentry *upper = ovl_dentry_upper(dentry);",
      "604:  if (upper->d_parent == upperdir) {",
      "606:   dget(upper);",
      "611:   dput(upper);",
      "",
      "[Added Lines]",
      "599:  struct dentry *upper;",
      "603:  upper = lookup_one_len(dentry->d_name.name, upperdir,",
      "604:           dentry->d_name.len);",
      "605:  err = PTR_ERR(upper);",
      "606:  if (IS_ERR(upper))",
      "607:   goto out_unlock;",
      "610:  if (upper == ovl_dentry_upper(dentry)) {",
      "617:  dput(upper);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "621:  if (!err)",
      "622:   d_drop(dentry);",
      "623:  inode_unlock(dir);",
      "625:  return err;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "627: out_unlock:",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "841:  trap = lock_rename(new_upperdir, old_upperdir);",
      "846:   if (opaquedir) {",
      "849:   } else {",
      "851:   }",
      "852:  } else {",
      "853:   new_create = true;",
      "859:  }",
      "866:  if (olddentry == trap)",
      "867:   goto out_dput;",
      "868:  if (newdentry == trap)",
      "",
      "[Removed Lines]",
      "843:  olddentry = ovl_dentry_upper(old);",
      "844:  newdentry = ovl_dentry_upper(new);",
      "845:  if (newdentry) {",
      "847:    newdentry = opaquedir;",
      "848:    opaquedir = NULL;",
      "850:    dget(newdentry);",
      "854:   newdentry = lookup_one_len(new->d_name.name, new_upperdir,",
      "855:         new->d_name.len);",
      "856:   err = PTR_ERR(newdentry);",
      "857:   if (IS_ERR(newdentry))",
      "858:    goto out_unlock;",
      "861:  err = -ESTALE;",
      "862:  if (olddentry->d_parent != old_upperdir)",
      "863:   goto out_dput;",
      "864:  if (newdentry->d_parent != new_upperdir)",
      "865:   goto out_dput;",
      "",
      "[Added Lines]",
      "849:  olddentry = lookup_one_len(old->d_name.name, old_upperdir,",
      "850:        old->d_name.len);",
      "851:  err = PTR_ERR(olddentry);",
      "852:  if (IS_ERR(olddentry))",
      "853:   goto out_unlock;",
      "855:  err = -ESTALE;",
      "856:  if (olddentry != ovl_dentry_upper(old))",
      "857:   goto out_dput_old;",
      "859:  newdentry = lookup_one_len(new->d_name.name, new_upperdir,",
      "860:        new->d_name.len);",
      "861:  err = PTR_ERR(newdentry);",
      "862:  if (IS_ERR(newdentry))",
      "863:   goto out_dput_old;",
      "865:  err = -ESTALE;",
      "866:  if (ovl_dentry_upper(new)) {",
      "868:    if (newdentry != opaquedir)",
      "869:     goto out_dput;",
      "871:    if (newdentry != ovl_dentry_upper(new))",
      "872:     goto out_dput;",
      "876:   if (!d_is_negative(newdentry) &&",
      "877:       (!new_opaque || !ovl_is_whiteout(newdentry)))",
      "878:    goto out_dput;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "926: out_dput:",
      "927:  dput(newdentry);",
      "928: out_unlock:",
      "929:  unlock_rename(new_upperdir, old_upperdir);",
      "930: out_revert_creds:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "943: out_dput_old:",
      "944:  dput(olddentry);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d15951198eaccb92c6b49e62cb72f5ff62da2236",
      "candidate_info": {
        "commit_hash": "d15951198eaccb92c6b49e62cb72f5ff62da2236",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d15951198eaccb92c6b49e62cb72f5ff62da2236",
        "files": [
          "fs/overlayfs/dir.c"
        ],
        "message": "ovl: check for emptiness of redirect dir\n\nBefore introducing redirect_dir feature, the condition\n!ovl_lower_positive(dentry) for a directory, implied that it is a pure\nupper directory, which may be removed if empty.\n\nNow that directory can be redirect, it is possible that upper does not\ncover any lower (i.e. !ovl_lower_positive(dentry)), but the directory is a\nmerge (with redirected path) and maybe non empty.\n\nCheck for this case in ovl_remove_upper().\n\nThis change fixes the following test case from rename-pop-dir.py\nof unionmount-testsuite:\n\n    \"\"\"Remove dir and rename old name\"\"\"\n    d = ctx.non_empty_dir()\n    d2 = ctx.no_dir()\n\n    ctx.rmdir(d, err=ENOTEMPTY)\n    ctx.rename(d, d2)\n    ctx.rmdir(d, err=ENOENT)\n    ctx.rmdir(d2, err=ENOTEMPTY)\n\n./run --ov rename-pop-dir\n/mnt/a/no_dir103: Expected error (Directory not empty) was not produced\n\nSigned-off-by: Amir Goldstein <amir73il@gmail.com>\nSigned-off-by: Miklos Szeredi <mszeredi@redhat.com>",
        "before_after_code_files": [
          "fs/overlayfs/dir.c||fs/overlayfs/dir.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/overlayfs/dir.c||fs/overlayfs/dir.c"
          ],
          "candidate": [
            "fs/overlayfs/dir.c||fs/overlayfs/dir.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/overlayfs/dir.c||fs/overlayfs/dir.c": [
          "File: fs/overlayfs/dir.c -> fs/overlayfs/dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "674:  struct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);",
          "675:  struct inode *dir = upperdir->d_inode;",
          "676:  struct dentry *upper;",
          "677:  int err;",
          "679:  inode_lock_nested(dir, I_MUTEX_PARENT);",
          "680:  upper = lookup_one_len(dentry->d_name.name, upperdir,",
          "681:           dentry->d_name.len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "677:  struct dentry *opaquedir = NULL;",
          "681:  if (is_dir && ovl_dentry_get_redirect(dentry)) {",
          "682:   opaquedir = ovl_check_empty_and_clear(dentry);",
          "683:   err = PTR_ERR(opaquedir);",
          "684:   if (IS_ERR(opaquedir))",
          "685:    goto out;",
          "686:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "684:   goto out_unlock;",
          "686:  err = -ESTALE;",
          "",
          "[Removed Lines]",
          "687:  if (upper == ovl_dentry_upper(dentry)) {",
          "688:   if (is_dir)",
          "689:    err = vfs_rmdir(dir, upper);",
          "690:   else",
          "691:    err = vfs_unlink(dir, upper, NULL);",
          "692:   ovl_dentry_version_inc(dentry->d_parent);",
          "693:  }",
          "694:  dput(upper);",
          "",
          "[Added Lines]",
          "696:  if ((opaquedir && upper != opaquedir) ||",
          "697:      (!opaquedir && upper != ovl_dentry_upper(dentry)))",
          "698:   goto out_dput_upper;",
          "700:  if (is_dir)",
          "701:   err = vfs_rmdir(dir, upper);",
          "702:  else",
          "703:   err = vfs_unlink(dir, upper, NULL);",
          "704:  ovl_dentry_version_inc(dentry->d_parent);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "702:  if (!err)",
          "703:   d_drop(dentry);",
          "704: out_unlock:",
          "705:  inode_unlock(dir);",
          "707:  return err;",
          "708: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "714: out_dput_upper:",
          "715:  dput(upper);",
          "718:  dput(opaquedir);",
          "719: out:",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-3906",
  "cve_desc": "The logcat_dump_text function in wiretap/logcat.c in the Android Logcat file parser in Wireshark 1.12.x before 1.12.5 does not properly handle a lack of \\0 termination, which allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted message in a packet, a different vulnerability than CVE-2015-3815.",
  "repo": "wireshark/wireshark",
  "patch_hash": "b3b1f7c3aa2233a147294bad833b748d38fba84d",
  "patch_info": {
    "commit_hash": "b3b1f7c3aa2233a147294bad833b748d38fba84d",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/b3b1f7c3aa2233a147294bad833b748d38fba84d",
    "files": [
      "wiretap/logcat.c"
    ],
    "message": "logcat: improve (crash) robustness, improve names\n\nThe logcat version detector would crash with ASAN enabled because it did\nnot validate the payload length and hence a payload length of 0 would\ntrigger out-of-bounds access. (This happened on non-logcat data.)\n\nThis patch tries to get rid of all magic numbers by using a structure,\nimproves the version detector to validate the payload length and\nprevents crashes due to missing nul-terminators in the input. Older\nAndroid kernels would create entries with __pad with random contents, so\nthat cannot be used to determine version for v1. Instead, use heuristics\non the priority, tag and maybe the msg field.\n\nFurthermore, Android is mostly (if not, always?) Little-Endian, so add\nconversions where necessary (just in case WS supports BE arches).\n\n\"microseconds\" has been renamed to \"milliseconds\" because that is what\nthey are, actually. A duplicate logcat_log loop has been refactored\nsuch that one loop is sufficient, instead of separate buffers for each\nlog part, a single one is now used. get_priority does not really need\na pointer, just make it accept a character.\n\nThe output has been validated against v1 and v2 logcat binary formats\nwith __pad (hdr_size) equal to 0, and on attachment 9906.\n\nChange-Id: I46c8813e76fe705b293ffdee85b4c1bfff7d8362\nReviewed-on: https://code.wireshark.org/review/2803\nReviewed-by: Michal Labedzki <michal.labedzki@tieto.com>\nTested-by: Michal Labedzki <michal.labedzki@tieto.com>",
    "before_after_code_files": [
      "wiretap/logcat.c||wiretap/logcat.c"
    ]
  },
  "patch_diff": {
    "wiretap/logcat.c||wiretap/logcat.c": [
      "File: wiretap/logcat.c -> wiretap/logcat.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "43:     enum dump_type_t type;",
      "44: };",
      "47:     static gchar priorities[] = \"??VDIWEFS\";",
      "50:         return '?';",
      "53: }",
      "55: static gchar *logcat_log(const struct dumper_t *dumper, guint32 seconds,",
      "57:         const gchar *log)",
      "58: {",
      "59:     gchar  time_buffer[15];",
      "",
      "[Removed Lines]",
      "46: static gchar get_priority(const guint8 *priority) {",
      "49:     if (*priority >= (guint8) sizeof(priorities))",
      "52:     return priorities[(int) *priority];",
      "56:         gint microseconds, gint pid, gint tid, gchar priority, const gchar *tag,",
      "",
      "[Added Lines]",
      "51: #define LOGGER_ENTRY_MAX_PAYLOAD 4076",
      "53: struct logger_entry {",
      "61: };",
      "63: struct logger_entry_v2 {",
      "70:     union {",
      "74:     };",
      "76: };",
      "79: static gchar get_priority(const guint8 priority) {",
      "82:     if (priority >= (guint8) sizeof(priorities))",
      "85:     return priorities[priority];",
      "89:         gint milliseconds, gint pid, gint tid, gchar priority, const gchar *tag,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "80:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
      "81:                     gmtime(&datetime));",
      "82:             return g_strdup_printf(\"%s.%03i %c/%-8s(%5i): %s\\n\",",
      "84:         case DUMP_THREADTIME:",
      "85:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
      "86:                     gmtime(&datetime));",
      "87:             return g_strdup_printf(\"%s.%03i %5i %5i %c %-8s: %s\\n\",",
      "89:         case DUMP_LONG:",
      "90:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
      "91:                     gmtime(&datetime));",
      "92:             return g_strdup_printf(\"[ %s.%03i %5i:0x%02x %c/%s ]\\n%s\\n\\n\",",
      "94:         default:",
      "95:             return NULL;",
      "96:     }",
      "",
      "[Removed Lines]",
      "83:                     time_buffer, microseconds, priority, tag, pid, log);",
      "88:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
      "93:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
      "",
      "[Added Lines]",
      "116:                     time_buffer, milliseconds, priority, tag, pid, log);",
      "121:                     time_buffer, milliseconds, pid, tid, priority, tag, log);",
      "126:                     time_buffer, milliseconds, pid, tid, priority, tag, log);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "100: static gint detect_version(wtap *wth, int *err, gchar **err_info)",
      "101: {",
      "113:     bytes_read = file_read(&tmp, 2, wth->fh);",
      "114:     if (bytes_read != 2) {",
      "",
      "[Removed Lines]",
      "102:     gint     bytes_read;",
      "103:     guint16  payload_length;",
      "104:     guint16  try_header_size;",
      "105:     guint8  *buffer;",
      "106:     gint64   file_offset;",
      "107:     guint32  log_length;",
      "108:     guint32  tag_length;",
      "109:     guint16  tmp;",
      "111:     file_offset = file_tell(wth->fh);",
      "",
      "[Added Lines]",
      "135:     gint                     bytes_read;",
      "136:     guint16                  payload_length;",
      "137:     guint16                  hdr_size;",
      "138:     guint16                  read_sofar;",
      "139:     guint16                  entry_len;",
      "140:     gint                     version;",
      "141:     struct logger_entry     *log_entry;",
      "142:     struct logger_entry_v2  *log_entry_v2;",
      "143:     guint8                  *buffer;",
      "144:     guint16                  tmp;",
      "145:     guint8                  *msg_payload, *msg_part, *msg_end;",
      "146:     guint16                  msg_len;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "127:         return -1;",
      "128:     }",
      "136:             if (*err == 0 && bytes_read != 0)",
      "140:         }",
      "159:         g_free(buffer);",
      "161:     }",
      "163:     g_free(buffer);",
      "165: }",
      "167: static gboolean logcat_read_packet(struct logcat_phdr *logcat, FILE_T fh,",
      "",
      "[Removed Lines]",
      "129:     try_header_size = pletoh16(&tmp);",
      "131:     buffer = (guint8 *) g_malloc(5 * 4 + payload_length);",
      "132:     bytes_read = file_read(buffer, 5 * 4 + payload_length, wth->fh);",
      "133:     if (bytes_read != 5 * 4 + payload_length) {",
      "134:         if (bytes_read != 4 * 4 + payload_length) {",
      "138:             g_free(buffer);",
      "139:             return -1;",
      "141:     }",
      "143:     if (try_header_size == 24) {",
      "144:         tag_length = (guint32)strlen(buffer + 5 * 4 + 1) + 1;",
      "145:         log_length = (guint32)strlen(buffer + 5 * 4 + 1 + tag_length) + 1;",
      "146:         if (payload_length == 1 + tag_length + log_length) {",
      "147:             g_free(buffer);",
      "148:             return 2;",
      "149:         }",
      "150:     }",
      "152:     tag_length = (guint32)strlen(buffer + 4 * 4 + 1) + 1;",
      "153:     log_length = (guint32)strlen(buffer + 4 * 4 + 1 + tag_length) + 1;",
      "154:     if (payload_length == 1 + tag_length + log_length) {",
      "155:         if (file_seek(wth->fh, file_offset + 4 * 4 + 1 + tag_length + log_length, SEEK_SET, err) == -1) {",
      "156:             g_free(buffer);",
      "157:             return -1;",
      "158:         }",
      "160:         return 1;",
      "164:     return 0;",
      "",
      "[Added Lines]",
      "166:     hdr_size = pletoh16(&tmp);",
      "167:     read_sofar = 4;",
      "170:     if (payload_length < 3)",
      "171:         return -1;",
      "173:     if (payload_length > LOGGER_ENTRY_MAX_PAYLOAD)",
      "174:         return -1;",
      "177:     buffer = (guint8 *) g_malloc(sizeof(*log_entry_v2) + payload_length);",
      "178:     log_entry_v2 = (struct logger_entry_v2 *) buffer;",
      "179:     log_entry = (struct logger_entry *) buffer;",
      "183:     for (version = 1; version <= 2; ++version) {",
      "184:         if (version == 1) {",
      "185:             msg_payload = log_entry->msg;",
      "186:             entry_len = sizeof(*log_entry) + payload_length;",
      "187:         } else if (version == 2) {",
      "189:             msg_payload = log_entry_v2->msg;",
      "190:             entry_len = sizeof(*log_entry_v2) + payload_length;",
      "191:             if (hdr_size != sizeof(*log_entry_v2))",
      "192:                 continue;",
      "193:         }",
      "195:         bytes_read = file_read(buffer + read_sofar, entry_len - read_sofar,",
      "196:                 wth->fh);",
      "197:         if (bytes_read != entry_len - read_sofar) {",
      "202:             version = -1;",
      "203:             break;",
      "205:         read_sofar += bytes_read;",
      "208:         if (get_priority(msg_payload[0]) == '?')",
      "209:             continue;",
      "212:         msg_part = (guint8 *) memchr(msg_payload, '\\0', payload_length - 1);",
      "213:         if (msg_part == NULL)",
      "214:             continue;",
      "217:         ++msg_part;",
      "218:         msg_len = payload_length - (msg_part - msg_payload);",
      "219:         msg_end = (guint8 *) memchr(msg_part, '\\0', msg_len);",
      "221:         if (msg_end && (msg_payload + payload_length - 1 != msg_end))",
      "222:             continue;",
      "225:         return version;",
      "229:     return -1;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "172:     guint16              payload_length;",
      "173:     guint                tmp[2];",
      "174:     guint8              *pd;",
      "176:     bytes_read = file_read(&tmp, 2, fh);",
      "177:     if (bytes_read != 2) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "240:     struct logger_entry *log_entry;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "183:     payload_length = pletoh16(tmp);",
      "185:     if (logcat->version == 1) {",
      "187:     } else if (logcat->version == 2) {",
      "189:     } else {",
      "190:         return FALSE;",
      "191:     }",
      "193:     buffer_assure_space(buf, packet_size);",
      "194:     pd = buffer_start_ptr(buf);",
      "197:     memcpy(pd, tmp, 2);",
      "",
      "[Removed Lines]",
      "186:         packet_size = 5 * 4 + payload_length;",
      "188:         packet_size = 6 * 4 + payload_length;",
      "",
      "[Added Lines]",
      "252:         packet_size = sizeof(struct logger_entry) + payload_length;",
      "254:         packet_size = sizeof(struct logger_entry_v2) + payload_length;",
      "261:     log_entry = (struct logger_entry *) pd;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "208:     phdr->rec_type = REC_TYPE_PACKET;",
      "209:     phdr->presence_flags = WTAP_HAS_TS;",
      "212:     phdr->caplen = packet_size;",
      "213:     phdr->len = packet_size;",
      "",
      "[Removed Lines]",
      "210:     phdr->ts.secs = (time_t) pletoh32(pd + 12);",
      "211:     phdr->ts.nsecs = (int) pletoh32(pd + 16);",
      "",
      "[Added Lines]",
      "277:     phdr->ts.secs = (time_t) GINT32_FROM_LE(log_entry->sec);",
      "278:     phdr->ts.nsecs = GINT32_FROM_LE(log_entry->nsec);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "340:     gchar                          *buf;",
      "341:     gint                            length;",
      "342:     gchar                           priority;",
      "343:     const gchar                    *tag;",
      "347:     gchar                          *log_part;",
      "352:     const union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
      "353:     const struct dumper_t          *dumper        = (const struct dumper_t *) wdh->priv;",
      "",
      "[Removed Lines]",
      "344:     const gint                     *pid;",
      "345:     const gint                     *tid;",
      "346:     const gchar                    *log;",
      "348:     const gchar                    *str_begin;",
      "349:     const gchar                    *str_end;",
      "350:     const guint32                  *datetime;",
      "351:     const guint32                  *nanoseconds;",
      "",
      "[Added Lines]",
      "410:     const struct logger_entry      *log_entry = (struct logger_entry *) pd;",
      "411:     const struct logger_entry_v2   *log_entry_v2 = (struct logger_entry_v2 *) pd;",
      "412:     gint                            payload_length;",
      "414:     gint32                          pid;",
      "415:     gint32                          tid;",
      "416:     gint32                          seconds;",
      "417:     gint32                          milliseconds;",
      "418:     const gchar                    *msg_begin;",
      "419:     gint                            msg_pre_skip;",
      "420:     gchar                          *log;",
      "422:     gchar                          *log_next;",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "358:         return FALSE;",
      "359:     }",
      "361:     if (pseudo_header->logcat.version == 1) {",
      "369:     } else if (pseudo_header->logcat.version == 2) {",
      "377:     } else {",
      "379:         return FALSE;",
      "380:     }",
      "401:         }",
      "413:                 priority, tag, log_part);",
      "414:         if (!buf) {",
      "416:             return FALSE;",
      "417:         }",
      "419:         length = (guint32)strlen(buf);",
      "421:         if (!wtap_dump_file_write(wdh, buf, length, err)) {",
      "423:             return FALSE;",
      "424:         }",
      "426:         wdh->bytes_dumped += length;",
      "430:     return TRUE;",
      "431: }",
      "",
      "[Removed Lines]",
      "362:         pid = (const gint *) (pd + 4);",
      "363:         tid = (const gint *) (pd + 2 * 4);",
      "364:         datetime = (const guint32 *) (pd + 3 * 4);",
      "365:         nanoseconds = (const guint32 *) (pd + 4 * 4);",
      "366:         priority = get_priority((const guint8 *) (pd + 5 * 4));",
      "367:         tag = (const gchar *) (pd + 5 * 4 + 1);",
      "368:         log = tag + strlen(tag) + 1;",
      "370:         pid = (const gint *) (pd + 4);",
      "371:         tid = (const gint *) (pd + 2 * 4);",
      "372:         datetime = (const guint32 *) (pd + 3 * 4);",
      "373:         nanoseconds = (const guint32 *) (pd + 4 * 4);",
      "374:         priority = get_priority((const guint8 *) (pd + 6 * 4));",
      "375:         tag = (const char *) (pd + 6 * 4 + 1);",
      "376:         log = tag + strlen(tag) + 1;",
      "382:     str_begin = str_end = log;",
      "383:     while (dumper->type != DUMP_LONG && (str_end = strchr(str_begin, '\\n'))) {",
      "384:         log_part = (gchar *) g_malloc(str_end - str_begin + 1);",
      "385:         g_strlcpy(log_part, str_begin, str_end - str_begin + 1);",
      "387:         str_begin = str_end + 1;",
      "389:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
      "390:                 priority, tag, log_part);",
      "391:         if (!buf) {",
      "392:             g_free(log_part);",
      "393:             return FALSE;",
      "394:         }",
      "395:         g_free(log_part);",
      "396:         length = (guint32)strlen(buf);",
      "398:         if (!wtap_dump_file_write(wdh, buf, length, err)) {",
      "399:             g_free(buf);",
      "400:             return FALSE;",
      "403:         wdh->bytes_dumped += length;",
      "405:         g_free(buf);",
      "406:     }",
      "408:     if (*str_begin != '\\0') {",
      "409:         log_part = (gchar *) g_malloc(strlen(str_begin) + 1);",
      "410:         g_strlcpy(log_part, str_begin, strlen(str_begin) + 1);",
      "412:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
      "415:             g_free(log_part);",
      "418:         g_free(log_part);",
      "422:             g_free(buf);",
      "427:         g_free(buf);",
      "428:     }",
      "",
      "[Added Lines]",
      "432:     payload_length = GINT32_FROM_LE(log_entry->len);",
      "433:     pid = GINT32_FROM_LE(log_entry->pid);",
      "434:     tid = GINT32_FROM_LE(log_entry->tid);",
      "435:     seconds = GINT32_FROM_LE(log_entry->sec);",
      "436:     milliseconds = GINT32_FROM_LE(log_entry->nsec) / 1000000;",
      "440:         priority = get_priority(log_entry->msg[0]);",
      "441:         tag = log_entry->msg + 1;",
      "442:         msg_pre_skip = 1 + strlen(tag) + 1;",
      "443:         msg_begin = log_entry->msg + msg_pre_skip;",
      "445:         priority = get_priority(log_entry_v2->msg[0]);",
      "446:         tag = log_entry_v2->msg + 1;",
      "447:         msg_pre_skip = 1 + strlen(tag) + 1;",
      "448:         msg_begin = log_entry_v2->msg + msg_pre_skip;",
      "455:     log = g_strndup(msg_begin, payload_length - msg_pre_skip);",
      "459:     log_next = log;",
      "460:     do {",
      "461:         log_part = log_next;",
      "462:         if (dumper->type == DUMP_LONG) {",
      "464:             log_next = NULL;",
      "465:         } else {",
      "467:             log_next = strchr(log_part, '\\n');",
      "468:             if (log_next != NULL) {",
      "470:                 ++log_next;",
      "472:                 if (*log_next == '\\0') {",
      "473:                     log_next = NULL;",
      "474:                 }",
      "475:             }",
      "478:         buf = logcat_log(dumper, seconds, milliseconds, pid, tid,",
      "481:             g_free(log);",
      "487:             g_free(log);",
      "492:     } while (log_next != NULL);",
      "494:     g_free(log);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "099bc9342f825a8d970bb888f16a5c0e271686ae",
      "candidate_info": {
        "commit_hash": "099bc9342f825a8d970bb888f16a5c0e271686ae",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/099bc9342f825a8d970bb888f16a5c0e271686ae",
        "files": [
          "wiretap/logcat.c"
        ],
        "message": "Logcat: Remove commented code\n\n\"g_strlcpy\" guarante that \"dest\" to be null-terminated.\n\nAlso cosmetic change from file_subtype to encap.\n\nChange-Id: If188a08cf34dd9def4203404962571c273740636\nReviewed-on: https://code.wireshark.org/review/2718\nReviewed-by: Michal Labedzki <michal.labedzki@tieto.com>",
        "before_after_code_files": [
          "wiretap/logcat.c||wiretap/logcat.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ],
          "candidate": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/logcat.c||wiretap/logcat.c": [
          "File: wiretap/logcat.c -> wiretap/logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "320:     wdh->subtype_write = logcat_binary_dump;",
          "321:     wdh->subtype_close = NULL;",
          "325:             wdh->tsprecision = WTAP_FILE_TSPREC_USEC;",
          "326:             break;",
          "",
          "[Removed Lines]",
          "323:     switch (wdh->file_type_subtype) {",
          "324:         case WTAP_FILE_TYPE_SUBTYPE_LOGCAT:",
          "",
          "[Added Lines]",
          "323:     switch (wdh->encap) {",
          "324:         case WTAP_ENCAP_LOGCAT:",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "383:     while (dumper->type != DUMP_LONG && (str_end = strchr(str_begin, '\\n'))) {",
          "384:         log_part = (gchar *) g_malloc(str_end - str_begin + 1);",
          "385:         g_strlcpy(log_part, str_begin, str_end - str_begin + 1);",
          "389:         str_begin = str_end + 1;",
          "391:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
          "",
          "[Removed Lines]",
          "386: #if 0",
          "387:         log_part[str_end - str_begin] = '\\0';",
          "388: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "410:     if (*str_begin != '\\0') {",
          "411:         log_part = (gchar *) g_malloc(strlen(str_begin) + 1);",
          "412:         g_strlcpy(log_part, str_begin, strlen(str_begin) + 1);",
          "417:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
          "418:                 priority, tag, log_part);",
          "",
          "[Removed Lines]",
          "413: #if 0",
          "414:         log_part[strlen(str_begin)] = '\\0';",
          "415: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e2038e03007faaa29f9ed1cb3619e84bd6e03247",
      "candidate_info": {
        "commit_hash": "e2038e03007faaa29f9ed1cb3619e84bd6e03247",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/e2038e03007faaa29f9ed1cb3619e84bd6e03247",
        "files": [
          "wiretap/logcat.c"
        ],
        "message": "Add strlen casts.\n\nChange-Id: Icaf80f060c476dd7259c04c4cce4123025ef1dab\nReviewed-on: https://code.wireshark.org/review/3012\nReviewed-by: Gerald Combs <gerald@wireshark.org>",
        "before_after_code_files": [
          "wiretap/logcat.c||wiretap/logcat.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ],
          "candidate": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/logcat.c||wiretap/logcat.c": [
          "File: wiretap/logcat.c -> wiretap/logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "439:     if (pseudo_header->logcat.version == 1) {",
          "440:         priority = get_priority(log_entry->msg[0]);",
          "441:         tag = log_entry->msg + 1;",
          "443:         msg_begin = log_entry->msg + msg_pre_skip;",
          "444:     } else if (pseudo_header->logcat.version == 2) {",
          "445:         priority = get_priority(log_entry_v2->msg[0]);",
          "446:         tag = log_entry_v2->msg + 1;",
          "448:         msg_begin = log_entry_v2->msg + msg_pre_skip;",
          "449:     } else {",
          "",
          "[Removed Lines]",
          "442:         msg_pre_skip = 1 + strlen(tag) + 1;",
          "447:         msg_pre_skip = 1 + strlen(tag) + 1;",
          "",
          "[Added Lines]",
          "442:         msg_pre_skip = 1 + (gint) strlen(tag) + 1;",
          "447:         msg_pre_skip = 1 + (gint) strlen(tag) + 1;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ffd48cefa6c468d4cdadd5e562f0d3c63eb4a2d6",
      "candidate_info": {
        "commit_hash": "ffd48cefa6c468d4cdadd5e562f0d3c63eb4a2d6",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/ffd48cefa6c468d4cdadd5e562f0d3c63eb4a2d6",
        "files": [
          "wiretap/ascend_scanner.l",
          "wiretap/commview.c",
          "wiretap/cosine.c",
          "wiretap/dbs-etherwatch.c",
          "wiretap/erf.c",
          "wiretap/i4b_trace.h",
          "wiretap/k12.c",
          "wiretap/logcat.c",
          "wiretap/netscaler.c",
          "wiretap/netscreen.h",
          "wiretap/nettl.c",
          "wiretap/netxray.c",
          "wiretap/pcap-common.c",
          "wiretap/pcapng.c",
          "wiretap/pppdump.c",
          "wiretap/toshiba.c",
          "wiretap/vms.c",
          "wiretap/wtap.c"
        ],
        "message": "Whitespace cleanups.\n\nChange-Id: I92f983b2e04defab30eb31c14c484b9f0f582413\nReviewed-on: https://code.wireshark.org/review/4513\nReviewed-by: Guy Harris <guy@alum.mit.edu>",
        "before_after_code_files": [
          "wiretap/ascend_scanner.l||wiretap/ascend_scanner.l",
          "wiretap/commview.c||wiretap/commview.c",
          "wiretap/cosine.c||wiretap/cosine.c",
          "wiretap/dbs-etherwatch.c||wiretap/dbs-etherwatch.c",
          "wiretap/erf.c||wiretap/erf.c",
          "wiretap/i4b_trace.h||wiretap/i4b_trace.h",
          "wiretap/k12.c||wiretap/k12.c",
          "wiretap/logcat.c||wiretap/logcat.c",
          "wiretap/netscaler.c||wiretap/netscaler.c",
          "wiretap/netscreen.h||wiretap/netscreen.h",
          "wiretap/nettl.c||wiretap/nettl.c",
          "wiretap/netxray.c||wiretap/netxray.c",
          "wiretap/pcap-common.c||wiretap/pcap-common.c",
          "wiretap/pcapng.c||wiretap/pcapng.c",
          "wiretap/pppdump.c||wiretap/pppdump.c",
          "wiretap/toshiba.c||wiretap/toshiba.c",
          "wiretap/vms.c||wiretap/vms.c",
          "wiretap/wtap.c||wiretap/wtap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ],
          "candidate": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/ascend_scanner.l||wiretap/ascend_scanner.l": [
          "File: wiretap/ascend_scanner.l -> wiretap/ascend_scanner.l"
        ],
        "wiretap/commview.c||wiretap/commview.c": [
          "File: wiretap/commview.c -> wiretap/commview.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "48:  guint8  version;",
          "49:  guint16  year;",
          "50:  guint8  month;",
          "52:  guint8  hours;",
          "53:  guint8  minutes;",
          "54:  guint8  seconds;",
          "",
          "[Removed Lines]",
          "51:  guint8   day;",
          "",
          "[Added Lines]",
          "51:  guint8  day;",
          "",
          "---------------"
        ],
        "wiretap/cosine.c||wiretap/cosine.c": [
          "File: wiretap/cosine.c -> wiretap/cosine.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "158: #define COSINE_REC_MAGIC_STR2 COSINE_HDR_MAGIC_STR2",
          "160: #define COSINE_HEADER_LINES_TO_CHECK 200",
          "163: #define COSINE_MAX_PACKET_LEN 65536",
          "",
          "[Removed Lines]",
          "161: #define COSINE_LINE_LENGTH         240",
          "",
          "[Added Lines]",
          "161: #define COSINE_LINE_LENGTH  240",
          "",
          "---------------"
        ],
        "wiretap/dbs-etherwatch.c||wiretap/dbs-etherwatch.c": [
          "File: wiretap/dbs-etherwatch.c -> wiretap/dbs-etherwatch.c"
        ],
        "wiretap/erf.c||wiretap/erf.c": [
          "File: wiretap/erf.c -> wiretap/erf.c"
        ],
        "wiretap/i4b_trace.h||wiretap/i4b_trace.h": [
          "File: wiretap/i4b_trace.h -> wiretap/i4b_trace.h"
        ],
        "wiretap/k12.c||wiretap/k12.c": [
          "File: wiretap/k12.c -> wiretap/k12.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "522:     while (left > buffer_len) {",
          "524:         if (is_random) {",
          "525:             file_data->rand_read_buff = buffer;",
          "526:             file_data->rand_read_buff_len = buffer_len;",
          "",
          "[Removed Lines]",
          "523:      buffer = (guint8*)g_realloc(buffer,buffer_len*=2);",
          "",
          "[Added Lines]",
          "523:         buffer = (guint8*)g_realloc(buffer,buffer_len*=2);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1012:                ascii_strdown_inplace() call below) to be null-terminated;",
          "1013:                is that guaranteed (even with a corrupt file)?",
          "1017:             if (rec_len < K12_SRCDESC_EXTRATYPE + extra_len + name_len + stack_len) {",
          "",
          "[Removed Lines]",
          "1014:         Obviously not, as a corrupt file could contain anything",
          "1015:         here; the Tektronix document says the strings \"must end",
          "",
          "[Added Lines]",
          "1014:                Obviously not, as a corrupt file could contain anything",
          "1015:                here; the Tektronix document says the strings \"must end",
          "",
          "---------------"
        ],
        "wiretap/logcat.c||wiretap/logcat.c": [
          "File: wiretap/logcat.c -> wiretap/logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "66:     if (!wtap_read_bytes_or_eof(fh, &tmp, 2, err, err_info)) {",
          "73:         if (*err == WTAP_ERR_SHORT_READ) {",
          "",
          "[Removed Lines]",
          "67:      if (*err == 0) {",
          "71:          return -2;",
          "72:      }",
          "",
          "[Added Lines]",
          "67:         if (*err == 0) {",
          "71:             return -2;",
          "72:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "119:                 continue;",
          "120:         }",
          "123:             g_free(buffer);",
          "124:             if (*err == WTAP_ERR_SHORT_READ) {",
          "",
          "[Removed Lines]",
          "122:  if (!wtap_read_bytes(fh, buffer + read_sofar, entry_len - read_sofar, err, err_info)) {",
          "",
          "[Added Lines]",
          "122:         if (!wtap_read_bytes(fh, buffer + read_sofar, entry_len - read_sofar, err, err_info)) {",
          "",
          "---------------"
        ],
        "wiretap/netscaler.c||wiretap/netscaler.c": [
          "File: wiretap/netscaler.c -> wiretap/netscaler.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1353:     if (!wtap_read_bytes(wth->random_fh, (void *)&hdr, sizeof hdr,",
          "1355:         return FALSE;",
          "",
          "[Removed Lines]",
          "1354:                               err, err_info))",
          "",
          "[Added Lines]",
          "1354:                          err, err_info))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1366:     pd = ws_buffer_start_ptr(buf);",
          "1367:     memcpy(pd, (void *)&hdr, sizeof hdr);",
          "1368:     if (record_length > sizeof hdr) {",
          "1372:             return FALSE;",
          "1373:     }",
          "",
          "[Removed Lines]",
          "1369:      bytes_to_read = (unsigned int)(record_length - sizeof hdr);",
          "1370:      if (!wtap_read_bytes(wth->random_fh, pd + sizeof hdr, bytes_to_read,",
          "1371:                                err, err_info))",
          "",
          "[Added Lines]",
          "1369:         bytes_to_read = (unsigned int)(record_length - sizeof hdr);",
          "1370:         if (!wtap_read_bytes(wth->random_fh, pd + sizeof hdr, bytes_to_read,",
          "1371:                              err, err_info))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1441:     if (hdr.phd_RecordSizeLow & NSPR_V20RECORDSIZE_2BYTES) {",
          "1442:         if (!wtap_read_bytes(wth->random_fh, (void *)&hdr.phd_RecordSizeHigh, 1,",
          "1444:             return FALSE;",
          "1445:         hdrlen = 3;",
          "1446:     }",
          "",
          "[Removed Lines]",
          "1443:                                   err, err_info))",
          "",
          "[Added Lines]",
          "1443:                              err, err_info))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1457:     pd = ws_buffer_start_ptr(buf);",
          "1458:     memcpy(pd, (void *)&hdr, hdrlen);",
          "1459:     if (record_length > hdrlen) {",
          "1463:             return FALSE;",
          "1464:     }",
          "",
          "[Removed Lines]",
          "1460:      bytes_to_read = (unsigned int)(record_length - hdrlen);",
          "1461:      if (!wtap_read_bytes(wth->random_fh, pd + hdrlen, bytes_to_read,",
          "1462:                            err, err_info))",
          "",
          "[Added Lines]",
          "1460:         bytes_to_read = (unsigned int)(record_length - hdrlen);",
          "1461:         if (!wtap_read_bytes(wth->random_fh, pd + hdrlen, bytes_to_read,",
          "1462:                              err, err_info))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1542:     if (hdr.phd_RecordSizeLow & NSPR_V20RECORDSIZE_2BYTES) {",
          "1545:             return FALSE;",
          "1546:         hdrlen = 3;",
          "1547:     }",
          "",
          "[Removed Lines]",
          "1543:      if (!wtap_read_bytes(wth->random_fh, (void *)&hdr.phd_RecordSizeHigh, 1,",
          "1544:                                err, err_info))",
          "",
          "[Added Lines]",
          "1543:         if (!wtap_read_bytes(wth->random_fh, (void *)&hdr.phd_RecordSizeHigh, 1,",
          "1544:                              err, err_info))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1560:     if (record_length > hdrlen) {",
          "1561:         bytes_to_read = (unsigned int)(record_length - hdrlen);",
          "1562:         if (!wtap_read_bytes(wth->random_fh, pd + hdrlen, bytes_to_read,",
          "1564:             return FALSE;",
          "1565:     }",
          "",
          "[Removed Lines]",
          "1563:                                   err, err_info))",
          "",
          "[Added Lines]",
          "1563:                              err, err_info))",
          "",
          "---------------"
        ],
        "wiretap/netscreen.h||wiretap/netscreen.h": [
          "File: wiretap/netscreen.h -> wiretap/netscreen.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: #define NETSCREEN_REC_MAGIC_STR1 NETSCREEN_HDR_MAGIC_STR1",
          "38: #define NETSCREEN_REC_MAGIC_STR2 NETSCREEN_HDR_MAGIC_STR2",
          "41: #define NETSCREEN_HEADER_LINES_TO_CHECK 32",
          "42: #define NETSCREEN_MAX_INFOLINES  8",
          "43: #define NETSCREEN_SPACES_ON_INFO_LINE 14",
          "",
          "[Removed Lines]",
          "40: #define NETSCREEN_LINE_LENGTH         128",
          "",
          "[Added Lines]",
          "40: #define NETSCREEN_LINE_LENGTH  128",
          "",
          "---------------"
        ],
        "wiretap/nettl.c||wiretap/nettl.c": [
          "File: wiretap/nettl.c -> wiretap/nettl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "239:         case NETTL_SUBSYS_EISA_FDDI :",
          "240:         case NETTL_SUBSYS_PCI_FDDI :",
          "241:         case NETTL_SUBSYS_HSC_FDDI :",
          "244:         case NETTL_SUBSYS_TOKEN :",
          "245:         case NETTL_SUBSYS_PCI_TR :",
          "248:         case NETTL_SUBSYS_NS_LS_IP :",
          "249:         case NETTL_SUBSYS_NS_LS_LOOPBACK :",
          "250:         case NETTL_SUBSYS_NS_LS_TCP :",
          "251:         case NETTL_SUBSYS_NS_LS_UDP :",
          "252:         case NETTL_SUBSYS_NS_LS_IPV6 :",
          "255:         case NETTL_SUBSYS_NS_LS_ICMP :",
          "258:         case NETTL_SUBSYS_NS_LS_ICMPV6 :",
          "261:         case NETTL_SUBSYS_NS_LS_TELNET :",
          "267:     }",
          "269:     if (file_seek(wth->fh, FILE_HDR_SIZE, SEEK_SET, err) == -1) {",
          "271:     }",
          "272:     wth->file_tsprec = WTAP_TSPREC_USEC;",
          "",
          "[Removed Lines]",
          "242:   wth->file_encap = WTAP_ENCAP_NETTL_FDDI;",
          "243:   break;",
          "246:   wth->file_encap = WTAP_ENCAP_NETTL_TOKEN_RING;",
          "247:   break;",
          "253:   wth->file_encap = WTAP_ENCAP_NETTL_RAW_IP;",
          "254:   break;",
          "256:   wth->file_encap = WTAP_ENCAP_NETTL_RAW_ICMP;",
          "257:   break;",
          "259:   wth->file_encap = WTAP_ENCAP_NETTL_RAW_ICMPV6;",
          "260:   break;",
          "262:   wth->file_encap = WTAP_ENCAP_NETTL_RAW_TELNET;",
          "263:   break;",
          "264:  default:",
          "266:   wth->file_encap = WTAP_ENCAP_NETTL_ETHERNET;",
          "270:  return -1;",
          "",
          "[Added Lines]",
          "242:                 wth->file_encap = WTAP_ENCAP_NETTL_FDDI;",
          "243:                 break;",
          "246:                 wth->file_encap = WTAP_ENCAP_NETTL_TOKEN_RING;",
          "247:                 break;",
          "253:                 wth->file_encap = WTAP_ENCAP_NETTL_RAW_IP;",
          "254:                 break;",
          "256:                 wth->file_encap = WTAP_ENCAP_NETTL_RAW_ICMP;",
          "257:                 break;",
          "259:                 wth->file_encap = WTAP_ENCAP_NETTL_RAW_ICMPV6;",
          "260:                 break;",
          "262:                 wth->file_encap = WTAP_ENCAP_NETTL_RAW_TELNET;",
          "263:                 break;",
          "264:         default:",
          "266:                 wth->file_encap = WTAP_ENCAP_NETTL_ETHERNET;",
          "270:         return -1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "283:     if (!nettl_read_rec(wth, wth->fh, &wth->phdr, wth->frame_buffer,",
          "284:         err, err_info)) {",
          "287:     }",
          "",
          "[Removed Lines]",
          "286:  return FALSE;",
          "",
          "[Added Lines]",
          "286:         return FALSE;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "297:     if (wth->file_encap == WTAP_ENCAP_UNKNOWN)",
          "299:     else {",
          "302:     }",
          "304:     return TRUE;",
          "",
          "[Removed Lines]",
          "298:  wth->file_encap = wth->phdr.pkt_encap;",
          "300:  if (wth->file_encap != wth->phdr.pkt_encap)",
          "301:      wth->file_encap = WTAP_ENCAP_PER_PACKET;",
          "",
          "[Added Lines]",
          "298:         wth->file_encap = wth->phdr.pkt_encap;",
          "300:         if (wth->file_encap != wth->phdr.pkt_encap)",
          "301:             wth->file_encap = WTAP_ENCAP_PER_PACKET;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "307: static gboolean",
          "308: nettl_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,",
          "310: {",
          "311:     if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)",
          "315:     if (!nettl_read_rec(wth, wth->random_fh, phdr, buf, err, err_info)) {",
          "322:     }",
          "323:     return TRUE;",
          "324: }",
          "326: static gboolean",
          "327: nettl_read_rec(wtap *wth, FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,",
          "329: {",
          "330:     union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
          "331:     nettl_t *nettl = (nettl_t *)wth->priv;",
          "",
          "[Removed Lines]",
          "309:   Buffer *buf, int *err, gchar **err_info)",
          "312:  return FALSE;",
          "317:  if (*err == 0) {",
          "320:  }",
          "321:  return FALSE;",
          "328:   int *err, gchar **err_info)",
          "",
          "[Added Lines]",
          "309:                 Buffer *buf, int *err, gchar **err_info)",
          "312:         return FALSE;",
          "317:         if (*err == 0) {",
          "320:         }",
          "321:         return FALSE;",
          "328:                 int *err, gchar **err_info)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "344:     errno = WTAP_ERR_CANT_READ;",
          "345:     if (!wtap_read_bytes_or_eof(fh, &rec_hdr.hdr_len, sizeof rec_hdr.hdr_len,",
          "346:                           err, err_info))",
          "348:     hdr_len = g_ntohs(rec_hdr.hdr_len);",
          "349:     if (hdr_len < NETTL_REC_HDR_LEN) {",
          "354:     }",
          "355:     if (!wtap_read_bytes(fh, &rec_hdr.subsys, NETTL_REC_HDR_LEN - 2,",
          "356:                               err, err_info))",
          "358:     subsys = g_ntohs(rec_hdr.subsys);",
          "359:     hdr_len -= NETTL_REC_HDR_LEN;",
          "360:     if (file_seek(fh, hdr_len, SEEK_CUR, err) == -1)",
          "363:     if ( (pntoh32(&rec_hdr.kind) & NETTL_HDR_PDU_MASK) == 0 ) {",
          "",
          "[Removed Lines]",
          "347:  return FALSE;",
          "352:      hdr_len);",
          "353:  return FALSE;",
          "357:  return FALSE;",
          "361:  return FALSE;",
          "",
          "[Added Lines]",
          "347:         return FALSE;",
          "352:             hdr_len);",
          "353:         return FALSE;",
          "357:         return FALSE;",
          "361:         return FALSE;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "367:         caplen = pntoh32(&rec_hdr.caplen);",
          "368:         padlen = 0;",
          "369:     } else switch (subsys) {",
          "391:         case NETTL_SUBSYS_PCI_FDDI :",
          "392:         case NETTL_SUBSYS_HSC_FDDI :",
          "393:         case NETTL_SUBSYS_TOKEN :",
          "394:         case NETTL_SUBSYS_PCI_TR :",
          "436:                 if (pntoh32(&rec_hdr.kind) == NETTL_HDR_PDUIN) {",
          "438:                        there are an extra 3 bytes after the DSAP and SSAP",
          "",
          "[Removed Lines]",
          "370:  case NETTL_SUBSYS_LAN100 :",
          "371:  case NETTL_SUBSYS_EISA100BT :",
          "372:  case NETTL_SUBSYS_BASE100 :",
          "373:  case NETTL_SUBSYS_GSC100BT :",
          "374:  case NETTL_SUBSYS_PCI100BT :",
          "375:  case NETTL_SUBSYS_SPP100BT :",
          "376:  case NETTL_SUBSYS_100VG :",
          "377:  case NETTL_SUBSYS_GELAN :",
          "378:  case NETTL_SUBSYS_BTLAN :",
          "379:  case NETTL_SUBSYS_INTL100 :",
          "380:  case NETTL_SUBSYS_IGELAN :",
          "381:  case NETTL_SUBSYS_IETHER :",
          "382:  case NETTL_SUBSYS_IXGBE :",
          "383:  case NETTL_SUBSYS_HSSN :",
          "384:  case NETTL_SUBSYS_IGSSN :",
          "385:  case NETTL_SUBSYS_ICXGBE :",
          "386:  case NETTL_SUBSYS_IEXGBE :",
          "387:  case NETTL_SUBSYS_IOCXGBE :",
          "388:  case NETTL_SUBSYS_IQXGBE :",
          "389:  case NETTL_SUBSYS_HPPB_FDDI :",
          "390:  case NETTL_SUBSYS_EISA_FDDI :",
          "395:  case NETTL_SUBSYS_NS_LS_IP :",
          "396:  case NETTL_SUBSYS_NS_LS_LOOPBACK :",
          "397:  case NETTL_SUBSYS_NS_LS_TCP :",
          "398:  case NETTL_SUBSYS_NS_LS_UDP :",
          "399:  case NETTL_SUBSYS_HP_APAPORT :",
          "400:  case NETTL_SUBSYS_HP_APALACP :",
          "401:  case NETTL_SUBSYS_NS_LS_IPV6 :",
          "402:  case NETTL_SUBSYS_NS_LS_ICMPV6 :",
          "403:  case NETTL_SUBSYS_NS_LS_ICMP :",
          "404:  case NETTL_SUBSYS_NS_LS_TELNET :",
          "405:  case NETTL_SUBSYS_NS_LS_SCTP :",
          "406:      if( (subsys == NETTL_SUBSYS_NS_LS_IP)",
          "407:       || (subsys == NETTL_SUBSYS_NS_LS_LOOPBACK)",
          "408:       || (subsys == NETTL_SUBSYS_NS_LS_UDP)",
          "409:       || (subsys == NETTL_SUBSYS_NS_LS_TCP)",
          "410:       || (subsys == NETTL_SUBSYS_NS_LS_SCTP)",
          "411:       || (subsys == NETTL_SUBSYS_NS_LS_IPV6)) {",
          "412:   phdr->pkt_encap = WTAP_ENCAP_NETTL_RAW_IP;",
          "413:      } else if (subsys == NETTL_SUBSYS_NS_LS_ICMP) {",
          "414:   phdr->pkt_encap = WTAP_ENCAP_NETTL_RAW_ICMP;",
          "415:      } else if (subsys == NETTL_SUBSYS_NS_LS_ICMPV6) {",
          "416:   phdr->pkt_encap = WTAP_ENCAP_NETTL_RAW_ICMPV6;",
          "417:      } else if (subsys == NETTL_SUBSYS_NS_LS_TELNET) {",
          "418:   phdr->pkt_encap = WTAP_ENCAP_NETTL_RAW_TELNET;",
          "419:      } else if( (subsys == NETTL_SUBSYS_HPPB_FDDI)",
          "420:       || (subsys == NETTL_SUBSYS_EISA_FDDI)",
          "421:       || (subsys == NETTL_SUBSYS_PCI_FDDI)",
          "422:       || (subsys == NETTL_SUBSYS_HSC_FDDI) ) {",
          "423:   phdr->pkt_encap = WTAP_ENCAP_NETTL_FDDI;",
          "424:      } else if( (subsys == NETTL_SUBSYS_PCI_TR)",
          "425:       || (subsys == NETTL_SUBSYS_TOKEN) ) {",
          "426:   phdr->pkt_encap = WTAP_ENCAP_NETTL_TOKEN_RING;",
          "427:      } else {",
          "428:   phdr->pkt_encap = WTAP_ENCAP_NETTL_ETHERNET;",
          "429:      }",
          "431:      length = pntoh32(&rec_hdr.length);",
          "432:      caplen = pntoh32(&rec_hdr.caplen);",
          "435:      if (subsys == NETTL_SUBSYS_HPPB_FDDI) {",
          "",
          "[Added Lines]",
          "370:         case NETTL_SUBSYS_LAN100 :",
          "371:         case NETTL_SUBSYS_EISA100BT :",
          "372:         case NETTL_SUBSYS_BASE100 :",
          "373:         case NETTL_SUBSYS_GSC100BT :",
          "374:         case NETTL_SUBSYS_PCI100BT :",
          "375:         case NETTL_SUBSYS_SPP100BT :",
          "376:         case NETTL_SUBSYS_100VG :",
          "377:         case NETTL_SUBSYS_GELAN :",
          "378:         case NETTL_SUBSYS_BTLAN :",
          "379:         case NETTL_SUBSYS_INTL100 :",
          "380:         case NETTL_SUBSYS_IGELAN :",
          "381:         case NETTL_SUBSYS_IETHER :",
          "382:         case NETTL_SUBSYS_IXGBE :",
          "383:         case NETTL_SUBSYS_HSSN :",
          "384:         case NETTL_SUBSYS_IGSSN :",
          "385:         case NETTL_SUBSYS_ICXGBE :",
          "386:         case NETTL_SUBSYS_IEXGBE :",
          "387:         case NETTL_SUBSYS_IOCXGBE :",
          "388:         case NETTL_SUBSYS_IQXGBE :",
          "389:         case NETTL_SUBSYS_HPPB_FDDI :",
          "390:         case NETTL_SUBSYS_EISA_FDDI :",
          "395:         case NETTL_SUBSYS_NS_LS_IP :",
          "396:         case NETTL_SUBSYS_NS_LS_LOOPBACK :",
          "397:         case NETTL_SUBSYS_NS_LS_TCP :",
          "398:         case NETTL_SUBSYS_NS_LS_UDP :",
          "399:         case NETTL_SUBSYS_HP_APAPORT :",
          "400:         case NETTL_SUBSYS_HP_APALACP :",
          "401:         case NETTL_SUBSYS_NS_LS_IPV6 :",
          "402:         case NETTL_SUBSYS_NS_LS_ICMPV6 :",
          "403:         case NETTL_SUBSYS_NS_LS_ICMP :",
          "404:         case NETTL_SUBSYS_NS_LS_TELNET :",
          "405:         case NETTL_SUBSYS_NS_LS_SCTP :",
          "406:             if( (subsys == NETTL_SUBSYS_NS_LS_IP)",
          "407:              || (subsys == NETTL_SUBSYS_NS_LS_LOOPBACK)",
          "408:              || (subsys == NETTL_SUBSYS_NS_LS_UDP)",
          "409:              || (subsys == NETTL_SUBSYS_NS_LS_TCP)",
          "410:              || (subsys == NETTL_SUBSYS_NS_LS_SCTP)",
          "411:              || (subsys == NETTL_SUBSYS_NS_LS_IPV6)) {",
          "412:                 phdr->pkt_encap = WTAP_ENCAP_NETTL_RAW_IP;",
          "413:             } else if (subsys == NETTL_SUBSYS_NS_LS_ICMP) {",
          "414:                 phdr->pkt_encap = WTAP_ENCAP_NETTL_RAW_ICMP;",
          "415:             } else if (subsys == NETTL_SUBSYS_NS_LS_ICMPV6) {",
          "416:                 phdr->pkt_encap = WTAP_ENCAP_NETTL_RAW_ICMPV6;",
          "417:             } else if (subsys == NETTL_SUBSYS_NS_LS_TELNET) {",
          "418:                 phdr->pkt_encap = WTAP_ENCAP_NETTL_RAW_TELNET;",
          "419:             } else if( (subsys == NETTL_SUBSYS_HPPB_FDDI)",
          "420:                     || (subsys == NETTL_SUBSYS_EISA_FDDI)",
          "421:                     || (subsys == NETTL_SUBSYS_PCI_FDDI)",
          "422:                     || (subsys == NETTL_SUBSYS_HSC_FDDI) ) {",
          "423:                 phdr->pkt_encap = WTAP_ENCAP_NETTL_FDDI;",
          "424:             } else if( (subsys == NETTL_SUBSYS_PCI_TR)",
          "425:                     || (subsys == NETTL_SUBSYS_TOKEN) ) {",
          "426:                 phdr->pkt_encap = WTAP_ENCAP_NETTL_TOKEN_RING;",
          "427:             } else {",
          "428:                 phdr->pkt_encap = WTAP_ENCAP_NETTL_ETHERNET;",
          "429:             }",
          "431:             length = pntoh32(&rec_hdr.length);",
          "432:             caplen = pntoh32(&rec_hdr.caplen);",
          "435:             if (subsys == NETTL_SUBSYS_HPPB_FDDI) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "441:                     fddihack=TRUE;",
          "442:                     padlen = 0;",
          "443:                 } else {",
          "457:                 if (file_seek(fh, 3, SEEK_CUR, err) == -1)",
          "458:                     return FALSE;",
          "459:                 padlen = 3;",
          "462:                 if (file_seek(fh, 26, SEEK_CUR, err) == -1)",
          "463:                     return FALSE;",
          "464:                 padlen = 26;",
          "",
          "[Removed Lines]",
          "445:              if (!wtap_read_bytes(fh, dummyc, 9, err, err_info))",
          "446:    return FALSE;",
          "448:       padlen = (int)dummyc[8];",
          "449:       if (file_seek(fh, padlen, SEEK_CUR, err) == -1)",
          "450:    return FALSE;",
          "451:       padlen += 9;",
          "452:   }",
          "453:      } else if ( (subsys == NETTL_SUBSYS_PCI_FDDI)",
          "454:               || (subsys == NETTL_SUBSYS_EISA_FDDI)",
          "455:               || (subsys == NETTL_SUBSYS_HSC_FDDI) ) {",
          "460:      } else if (subsys == NETTL_SUBSYS_NS_LS_LOOPBACK) {",
          "",
          "[Added Lines]",
          "445:                     if (!wtap_read_bytes(fh, dummyc, 9, err, err_info))",
          "446:                         return FALSE;",
          "448:                     padlen = (int)dummyc[8];",
          "449:                     if (file_seek(fh, padlen, SEEK_CUR, err) == -1)",
          "450:                         return FALSE;",
          "451:                     padlen += 9;",
          "452:                 }",
          "453:             } else if ( (subsys == NETTL_SUBSYS_PCI_FDDI)",
          "454:                      || (subsys == NETTL_SUBSYS_EISA_FDDI)",
          "455:                      || (subsys == NETTL_SUBSYS_HSC_FDDI) ) {",
          "460:             } else if (subsys == NETTL_SUBSYS_NS_LS_LOOPBACK) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "476:                 if (file_seek(fh, 8, SEEK_CUR, err) == -1)",
          "477:                     return FALSE;",
          "478:                 padlen = 8;",
          "502:             if (nettl->is_hpux_11) {",
          "503:                 if (file_seek(fh, 2, SEEK_CUR, err) == -1) return FALSE;",
          "504:             }",
          "541:             length = pntoh32(&rec_hdr.length);",
          "542:             caplen = pntoh32(&rec_hdr.caplen);",
          "543:             padlen = 0;",
          "",
          "[Removed Lines]",
          "479:      } else {",
          "480:       padlen = 0;",
          "481:      }",
          "482:      break;",
          "484:  case NETTL_SUBSYS_NS_LS_DRIVER :",
          "488:      phdr->pkt_encap = WTAP_ENCAP_NETTL_ETHERNET;",
          "489:      if (!wtap_read_bytes(fh, &drv_eth_hdr, NS_LS_DRV_ETH_HDR_LEN,",
          "490:                                err, err_info))",
          "491:   return FALSE;",
          "493:      length = pntoh16(&drv_eth_hdr.length);",
          "494:      caplen = pntoh16(&drv_eth_hdr.caplen);",
          "505:      padlen = 0;",
          "506:      break;",
          "508:  case NETTL_SUBSYS_SX25L2:",
          "509:  case NETTL_SUBSYS_SX25L3:",
          "528:      phdr->pkt_encap = WTAP_ENCAP_NETTL_X25;",
          "529:      length = pntoh32(&rec_hdr.length);",
          "530:      caplen = pntoh32(&rec_hdr.caplen);",
          "532:      if (file_seek(fh, padlen, SEEK_CUR, err) == -1)",
          "533:   return FALSE;",
          "534:      break;",
          "536:  default:",
          "539:      wth->file_encap = WTAP_ENCAP_PER_PACKET;",
          "540:      phdr->pkt_encap = WTAP_ENCAP_NETTL_ETHERNET;",
          "",
          "[Added Lines]",
          "479:             } else {",
          "480:                 padlen = 0;",
          "481:             }",
          "482:             break;",
          "484:         case NETTL_SUBSYS_NS_LS_DRIVER :",
          "488:             phdr->pkt_encap = WTAP_ENCAP_NETTL_ETHERNET;",
          "489:             if (!wtap_read_bytes(fh, &drv_eth_hdr, NS_LS_DRV_ETH_HDR_LEN,",
          "490:                                       err, err_info))",
          "491:                 return FALSE;",
          "493:             length = pntoh16(&drv_eth_hdr.length);",
          "494:             caplen = pntoh16(&drv_eth_hdr.caplen);",
          "505:             padlen = 0;",
          "506:             break;",
          "508:         case NETTL_SUBSYS_SX25L2:",
          "509:         case NETTL_SUBSYS_SX25L3:",
          "528:             phdr->pkt_encap = WTAP_ENCAP_NETTL_X25;",
          "529:             length = pntoh32(&rec_hdr.length);",
          "530:             caplen = pntoh32(&rec_hdr.caplen);",
          "532:             if (file_seek(fh, padlen, SEEK_CUR, err) == -1)",
          "533:                 return FALSE;",
          "534:             break;",
          "536:         default:",
          "539:             wth->file_encap = WTAP_ENCAP_PER_PACKET;",
          "540:             phdr->pkt_encap = WTAP_ENCAP_NETTL_ETHERNET;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "545:     }",
          "547:     if (length < padlen) {",
          "552:     }",
          "553:     phdr->rec_type = REC_TYPE_PACKET;",
          "554:     phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;",
          "555:     phdr->len = length - padlen;",
          "556:     if (caplen < padlen) {",
          "561:     }",
          "562:     datalen = caplen - padlen;",
          "563:     phdr->caplen = datalen;",
          "",
          "[Removed Lines]",
          "550:      length, padlen);",
          "551:  return FALSE;",
          "559:      caplen, padlen);",
          "560:  return FALSE;",
          "",
          "[Added Lines]",
          "550:             length, padlen);",
          "551:         return FALSE;",
          "559:             caplen, padlen);",
          "560:         return FALSE;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "571:     pseudo_header->nettl.uid      = pntoh16(&rec_hdr.uid);",
          "573:     if (phdr->caplen > WTAP_MAX_PACKET_SIZE) {",
          "582:     }",
          "",
          "[Removed Lines]",
          "580:      phdr->caplen, WTAP_MAX_PACKET_SIZE);",
          "581:  return FALSE;",
          "",
          "[Added Lines]",
          "580:             phdr->caplen, WTAP_MAX_PACKET_SIZE);",
          "581:         return FALSE;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "609:             datalen -= bytes_to_read;",
          "610:             if (datalen == 0) {",
          "614:         }",
          "615:         if (!wtap_read_bytes(fh, pd + 15, datalen, err, err_info))",
          "616:             return FALSE;",
          "617:     } else {",
          "620:     }",
          "622:     return TRUE;",
          "",
          "[Removed Lines]",
          "612:   return TRUE;",
          "613:      }",
          "618:      if (!wtap_read_bytes(fh, pd, datalen, err, err_info))",
          "619:          return FALSE;",
          "",
          "[Added Lines]",
          "612:                 return TRUE;",
          "613:             }",
          "618:         if (!wtap_read_bytes(fh, pd, datalen, err, err_info))",
          "619:             return FALSE;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "630: int nettl_dump_can_write_encap(int encap)",
          "631: {",
          "654: }",
          "",
          "[Removed Lines]",
          "633:  switch (encap) {",
          "634:   case WTAP_ENCAP_ETHERNET:",
          "635:   case WTAP_ENCAP_FDDI_BITSWAPPED:",
          "636:   case WTAP_ENCAP_TOKEN_RING:",
          "637:   case WTAP_ENCAP_NETTL_ETHERNET:",
          "638:   case WTAP_ENCAP_NETTL_FDDI:",
          "639:   case WTAP_ENCAP_NETTL_TOKEN_RING:",
          "640:   case WTAP_ENCAP_NETTL_RAW_IP:",
          "641:   case WTAP_ENCAP_NETTL_RAW_ICMP:",
          "642:   case WTAP_ENCAP_NETTL_RAW_ICMPV6:",
          "643:   case WTAP_ENCAP_NETTL_RAW_TELNET:",
          "645:   case WTAP_ENCAP_NETTL_X25:",
          "647:   case WTAP_ENCAP_PER_PACKET:",
          "648:   case WTAP_ENCAP_UNKNOWN:",
          "649:   case WTAP_ENCAP_NETTL_UNKNOWN:",
          "650:    return 0;",
          "651:   default:",
          "652:    return WTAP_ERR_UNSUPPORTED_ENCAP;",
          "653:  }",
          "",
          "[Added Lines]",
          "633:         switch (encap) {",
          "634:                 case WTAP_ENCAP_ETHERNET:",
          "635:                 case WTAP_ENCAP_FDDI_BITSWAPPED:",
          "636:                 case WTAP_ENCAP_TOKEN_RING:",
          "637:                 case WTAP_ENCAP_NETTL_ETHERNET:",
          "638:                 case WTAP_ENCAP_NETTL_FDDI:",
          "639:                 case WTAP_ENCAP_NETTL_TOKEN_RING:",
          "640:                 case WTAP_ENCAP_NETTL_RAW_IP:",
          "641:                 case WTAP_ENCAP_NETTL_RAW_ICMP:",
          "642:                 case WTAP_ENCAP_NETTL_RAW_ICMPV6:",
          "643:                 case WTAP_ENCAP_NETTL_RAW_TELNET:",
          "645:                 case WTAP_ENCAP_NETTL_X25:",
          "647:                 case WTAP_ENCAP_PER_PACKET:",
          "648:                 case WTAP_ENCAP_UNKNOWN:",
          "649:                 case WTAP_ENCAP_NETTL_UNKNOWN:",
          "650:                         return 0;",
          "651:                 default:",
          "652:                         return WTAP_ERR_UNSUPPORTED_ENCAP;",
          "653:         }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "659: gboolean nettl_dump_open(wtap_dumper *wdh, int *err)",
          "660: {",
          "682: }",
          "686: static gboolean nettl_dump(wtap_dumper *wdh,",
          "689: {",
          "757: #if 0",
          "767: #endif",
          "805:         wdh->bytes_dumped += phdr->caplen;",
          "808: }",
          "",
          "[Removed Lines]",
          "661:  struct nettl_file_hdr file_hdr;",
          "664:  wdh->subtype_write = nettl_dump;",
          "665:  wdh->subtype_close = NULL;",
          "668:  memset(&file_hdr,0,sizeof(file_hdr));",
          "669:  memcpy(file_hdr.magic,nettl_magic_hpux10,sizeof(file_hdr.magic));",
          "670:  g_strlcpy(file_hdr.file_name,\"/tmp/wireshark.TRC000\",NETTL_FILENAME_SIZE);",
          "671:  g_strlcpy(file_hdr.tz,\"UTC\",20);",
          "672:  g_strlcpy(file_hdr.host_name,\"\",9);",
          "673:  g_strlcpy(file_hdr.os_vers,\"B.11.11\",9);",
          "674:  file_hdr.os_v=0x55;",
          "675:  g_strlcpy(file_hdr.model,\"9000/800\",11);",
          "676:  file_hdr.unknown=g_htons(0x406);",
          "677:  if (!wtap_dump_file_write(wdh, &file_hdr, sizeof file_hdr, err))",
          "678:   return FALSE;",
          "679:  wdh->bytes_dumped += sizeof(file_hdr);",
          "681:  return TRUE;",
          "687:  const struct wtap_pkthdr *phdr,",
          "688:  const guint8 *pd, int *err)",
          "690:  const union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
          "691:  struct nettlrec_hdr rec_hdr;",
          "692:  guint8 dummyc[24];",
          "695:  if (phdr->rec_type != REC_TYPE_PACKET) {",
          "697:   return FALSE;",
          "698:  }",
          "701:  if (phdr->caplen > WTAP_MAX_PACKET_SIZE) {",
          "703:   return FALSE;",
          "704:  }",
          "706:  memset(&rec_hdr,0,sizeof(rec_hdr));",
          "708:  rec_hdr.hdr_len = g_htons(sizeof(rec_hdr) + 4);",
          "709:  rec_hdr.kind = g_htonl(NETTL_HDR_PDUIN);",
          "710:  rec_hdr.sec = g_htonl(phdr->ts.secs);",
          "711:  rec_hdr.usec = g_htonl(phdr->ts.nsecs/1000);",
          "712:  rec_hdr.caplen = g_htonl(phdr->caplen);",
          "713:  rec_hdr.length = g_htonl(phdr->len);",
          "714:  rec_hdr.devid = -1;",
          "715:  rec_hdr.pid = -1;",
          "716:  rec_hdr.uid = -1;",
          "718:  switch (phdr->pkt_encap) {",
          "720:   case WTAP_ENCAP_NETTL_FDDI:",
          "722:    rec_hdr.caplen = g_htonl(phdr->caplen + 3);",
          "723:    rec_hdr.length = g_htonl(phdr->len + 3);",
          "725:   case WTAP_ENCAP_NETTL_ETHERNET:",
          "726:   case WTAP_ENCAP_NETTL_TOKEN_RING:",
          "727:   case WTAP_ENCAP_NETTL_RAW_IP:",
          "728:   case WTAP_ENCAP_NETTL_RAW_ICMP:",
          "729:   case WTAP_ENCAP_NETTL_RAW_ICMPV6:",
          "730:   case WTAP_ENCAP_NETTL_RAW_TELNET:",
          "731:   case WTAP_ENCAP_NETTL_UNKNOWN:",
          "732:    rec_hdr.subsys = g_htons(pseudo_header->nettl.subsys);",
          "733:    rec_hdr.devid = g_htonl(pseudo_header->nettl.devid);",
          "734:    rec_hdr.kind = g_htonl(pseudo_header->nettl.kind);",
          "735:    rec_hdr.pid = g_htonl(pseudo_header->nettl.pid);",
          "736:    rec_hdr.uid = g_htons(pseudo_header->nettl.uid);",
          "737:    break;",
          "739:   case WTAP_ENCAP_RAW_IP:",
          "740:    rec_hdr.subsys = g_htons(NETTL_SUBSYS_NS_LS_IP);",
          "741:    break;",
          "743:   case WTAP_ENCAP_ETHERNET:",
          "744:    rec_hdr.subsys = g_htons(NETTL_SUBSYS_BTLAN);",
          "745:    break;",
          "747:   case WTAP_ENCAP_FDDI_BITSWAPPED:",
          "748:    rec_hdr.subsys = g_htons(NETTL_SUBSYS_PCI_FDDI);",
          "750:    rec_hdr.caplen = g_htonl(phdr->caplen + 3);",
          "751:    rec_hdr.length = g_htonl(phdr->len + 3);",
          "752:    break;",
          "754:   case WTAP_ENCAP_TOKEN_RING:",
          "755:    rec_hdr.subsys = g_htons(NETTL_SUBSYS_PCI_TR);",
          "756:    break;",
          "758:   case WTAP_ENCAP_NETTL_X25:",
          "759:    rec_hdr.caplen = g_htonl(phdr->caplen + 24);",
          "760:    rec_hdr.length = g_htonl(phdr->len + 24);",
          "761:    rec_hdr.subsys = g_htons(pseudo_header->nettl.subsys);",
          "762:    rec_hdr.devid = g_htonl(pseudo_header->nettl.devid);",
          "763:    rec_hdr.kind = g_htonl(pseudo_header->nettl.kind);",
          "764:    rec_hdr.pid = g_htonl(pseudo_header->nettl.pid);",
          "765:    rec_hdr.uid = g_htons(pseudo_header->nettl.uid);",
          "766:    break;",
          "768:   default:",
          "771:    return FALSE;",
          "772:  }",
          "774:  if (!wtap_dump_file_write(wdh, &rec_hdr, sizeof(rec_hdr), err))",
          "775:   return FALSE;",
          "776:  wdh->bytes_dumped += sizeof(rec_hdr);",
          "781:  memset(dummyc, 0, sizeof dummyc);",
          "782:  if (!wtap_dump_file_write(wdh, dummyc, 4, err))",
          "783:   return FALSE;",
          "784:  wdh->bytes_dumped += 4;",
          "786:  if ((phdr->pkt_encap == WTAP_ENCAP_FDDI_BITSWAPPED) ||",
          "787:      (phdr->pkt_encap == WTAP_ENCAP_NETTL_FDDI)) {",
          "789:   if (!wtap_dump_file_write(wdh, dummyc, 3, err))",
          "790:    return FALSE;",
          "791:          wdh->bytes_dumped += 3;",
          "792:  }",
          "794:  } else if (phdr->pkt_encap == WTAP_ENCAP_NETTL_X25) {",
          "795:   if (!wtap_dump_file_write(wdh, dummyc, 24, err))",
          "796:    return FALSE;",
          "797:   wdh->bytes_dumped += 24;",
          "798:  }",
          "803:  if (!wtap_dump_file_write(wdh, pd, phdr->caplen, err))",
          "804:   return FALSE;",
          "807:  return TRUE;",
          "",
          "[Added Lines]",
          "661:         struct nettl_file_hdr file_hdr;",
          "664:         wdh->subtype_write = nettl_dump;",
          "665:         wdh->subtype_close = NULL;",
          "668:         memset(&file_hdr,0,sizeof(file_hdr));",
          "669:         memcpy(file_hdr.magic,nettl_magic_hpux10,sizeof(file_hdr.magic));",
          "670:         g_strlcpy(file_hdr.file_name,\"/tmp/wireshark.TRC000\",NETTL_FILENAME_SIZE);",
          "671:         g_strlcpy(file_hdr.tz,\"UTC\",20);",
          "672:         g_strlcpy(file_hdr.host_name,\"\",9);",
          "673:         g_strlcpy(file_hdr.os_vers,\"B.11.11\",9);",
          "674:         file_hdr.os_v=0x55;",
          "675:         g_strlcpy(file_hdr.model,\"9000/800\",11);",
          "676:         file_hdr.unknown=g_htons(0x406);",
          "677:         if (!wtap_dump_file_write(wdh, &file_hdr, sizeof file_hdr, err))",
          "678:                 return FALSE;",
          "679:         wdh->bytes_dumped += sizeof(file_hdr);",
          "681:         return TRUE;",
          "687:         const struct wtap_pkthdr *phdr,",
          "688:         const guint8 *pd, int *err)",
          "690:         const union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
          "691:         struct nettlrec_hdr rec_hdr;",
          "692:         guint8 dummyc[24];",
          "695:         if (phdr->rec_type != REC_TYPE_PACKET) {",
          "697:                 return FALSE;",
          "698:         }",
          "701:         if (phdr->caplen > WTAP_MAX_PACKET_SIZE) {",
          "703:                 return FALSE;",
          "704:         }",
          "706:         memset(&rec_hdr,0,sizeof(rec_hdr));",
          "708:         rec_hdr.hdr_len = g_htons(sizeof(rec_hdr) + 4);",
          "709:         rec_hdr.kind = g_htonl(NETTL_HDR_PDUIN);",
          "710:         rec_hdr.sec = g_htonl(phdr->ts.secs);",
          "711:         rec_hdr.usec = g_htonl(phdr->ts.nsecs/1000);",
          "712:         rec_hdr.caplen = g_htonl(phdr->caplen);",
          "713:         rec_hdr.length = g_htonl(phdr->len);",
          "714:         rec_hdr.devid = -1;",
          "715:         rec_hdr.pid = -1;",
          "716:         rec_hdr.uid = -1;",
          "718:         switch (phdr->pkt_encap) {",
          "720:                 case WTAP_ENCAP_NETTL_FDDI:",
          "722:                         rec_hdr.caplen = g_htonl(phdr->caplen + 3);",
          "723:                         rec_hdr.length = g_htonl(phdr->len + 3);",
          "725:                 case WTAP_ENCAP_NETTL_ETHERNET:",
          "726:                 case WTAP_ENCAP_NETTL_TOKEN_RING:",
          "727:                 case WTAP_ENCAP_NETTL_RAW_IP:",
          "728:                 case WTAP_ENCAP_NETTL_RAW_ICMP:",
          "729:                 case WTAP_ENCAP_NETTL_RAW_ICMPV6:",
          "730:                 case WTAP_ENCAP_NETTL_RAW_TELNET:",
          "731:                 case WTAP_ENCAP_NETTL_UNKNOWN:",
          "732:                         rec_hdr.subsys = g_htons(pseudo_header->nettl.subsys);",
          "733:                         rec_hdr.devid = g_htonl(pseudo_header->nettl.devid);",
          "734:                         rec_hdr.kind = g_htonl(pseudo_header->nettl.kind);",
          "735:                         rec_hdr.pid = g_htonl(pseudo_header->nettl.pid);",
          "736:                         rec_hdr.uid = g_htons(pseudo_header->nettl.uid);",
          "737:                         break;",
          "739:                 case WTAP_ENCAP_RAW_IP:",
          "740:                         rec_hdr.subsys = g_htons(NETTL_SUBSYS_NS_LS_IP);",
          "741:                         break;",
          "743:                 case WTAP_ENCAP_ETHERNET:",
          "744:                         rec_hdr.subsys = g_htons(NETTL_SUBSYS_BTLAN);",
          "745:                         break;",
          "747:                 case WTAP_ENCAP_FDDI_BITSWAPPED:",
          "748:                         rec_hdr.subsys = g_htons(NETTL_SUBSYS_PCI_FDDI);",
          "750:                         rec_hdr.caplen = g_htonl(phdr->caplen + 3);",
          "751:                         rec_hdr.length = g_htonl(phdr->len + 3);",
          "752:                         break;",
          "754:                 case WTAP_ENCAP_TOKEN_RING:",
          "755:                         rec_hdr.subsys = g_htons(NETTL_SUBSYS_PCI_TR);",
          "756:                         break;",
          "758:                 case WTAP_ENCAP_NETTL_X25:",
          "759:                         rec_hdr.caplen = g_htonl(phdr->caplen + 24);",
          "760:                         rec_hdr.length = g_htonl(phdr->len + 24);",
          "761:                         rec_hdr.subsys = g_htons(pseudo_header->nettl.subsys);",
          "762:                         rec_hdr.devid = g_htonl(pseudo_header->nettl.devid);",
          "763:                         rec_hdr.kind = g_htonl(pseudo_header->nettl.kind);",
          "764:                         rec_hdr.pid = g_htonl(pseudo_header->nettl.pid);",
          "765:                         rec_hdr.uid = g_htons(pseudo_header->nettl.uid);",
          "766:                         break;",
          "768:                 default:",
          "771:                         return FALSE;",
          "772:         }",
          "774:         if (!wtap_dump_file_write(wdh, &rec_hdr, sizeof(rec_hdr), err))",
          "775:                 return FALSE;",
          "776:         wdh->bytes_dumped += sizeof(rec_hdr);",
          "781:         memset(dummyc, 0, sizeof dummyc);",
          "782:         if (!wtap_dump_file_write(wdh, dummyc, 4, err))",
          "783:                 return FALSE;",
          "784:         wdh->bytes_dumped += 4;",
          "786:         if ((phdr->pkt_encap == WTAP_ENCAP_FDDI_BITSWAPPED) ||",
          "787:             (phdr->pkt_encap == WTAP_ENCAP_NETTL_FDDI)) {",
          "789:                 if (!wtap_dump_file_write(wdh, dummyc, 3, err))",
          "790:                         return FALSE;",
          "791:                 wdh->bytes_dumped += 3;",
          "792:         }",
          "794:         } else if (phdr->pkt_encap == WTAP_ENCAP_NETTL_X25) {",
          "795:                 if (!wtap_dump_file_write(wdh, dummyc, 24, err))",
          "796:                         return FALSE;",
          "797:                 wdh->bytes_dumped += 24;",
          "798:         }",
          "803:         if (!wtap_dump_file_write(wdh, pd, phdr->caplen, err))",
          "804:                 return FALSE;",
          "807:         return TRUE;",
          "",
          "---------------"
        ],
        "wiretap/netxray.c||wiretap/netxray.c": [
          "File: wiretap/netxray.c -> wiretap/netxray.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1202:         if (netxray->fcs_valid) {",
          "",
          "[Added Lines]",
          "1202:     if (netxray->fcs_valid) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1243:         if (netxray->fcs_valid) {",
          "",
          "[Added Lines]",
          "1243:     if (netxray->fcs_valid) {",
          "",
          "---------------"
        ],
        "wiretap/pcap-common.c||wiretap/pcap-common.c": [
          "File: wiretap/pcap-common.c -> wiretap/pcap-common.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "329:  { 183,  WTAP_ENCAP_JUNIPER_VP },",
          "335:  { 188,  WTAP_ENCAP_IEEE802_16_MAC_CPS },",
          "341:  { 192,  WTAP_ENCAP_PPI },",
          "",
          "[Removed Lines]",
          "331:  { 186,   WTAP_ENCAP_USB },",
          "333:  { 187,   WTAP_ENCAP_BLUETOOTH_H4 },",
          "337:  { 189,   WTAP_ENCAP_USB_LINUX },",
          "339:  { 190,   WTAP_ENCAP_CAN20B },",
          "",
          "[Added Lines]",
          "331:  { 186,  WTAP_ENCAP_USB },",
          "333:  { 187,  WTAP_ENCAP_BLUETOOTH_H4 },",
          "337:  { 189,  WTAP_ENCAP_USB_LINUX },",
          "339:  { 190,  WTAP_ENCAP_CAN20B },",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "349:  { 199,  WTAP_ENCAP_IPMB },",
          "353:  { 202,  WTAP_ENCAP_AX25_KISS },",
          "357:  { 204,  WTAP_ENCAP_PPP_WITH_PHDR },",
          "359:  { 209,  WTAP_ENCAP_I2C },",
          "371:  { 215,  WTAP_ENCAP_IEEE802_15_4_NONASK_PHY },",
          "375:  { 224,  WTAP_ENCAP_FIBRE_CHANNEL_FC2 },",
          "",
          "[Removed Lines]",
          "351:  { 201,   WTAP_ENCAP_BLUETOOTH_H4_WITH_PHDR },",
          "355:  { 203,   WTAP_ENCAP_LAPD },",
          "361:  { 210,   WTAP_ENCAP_FLEXRAY },",
          "363:  { 211,   WTAP_ENCAP_MOST },",
          "365:  { 212,   WTAP_ENCAP_LIN },",
          "367:  { 213,   WTAP_ENCAP_X2E_SERIAL },",
          "369:  { 214,   WTAP_ENCAP_X2E_XORAYA },",
          "373:  { 220,   WTAP_ENCAP_USB_LINUX_MMAPPED },",
          "",
          "[Added Lines]",
          "351:  { 201,  WTAP_ENCAP_BLUETOOTH_H4_WITH_PHDR },",
          "355:  { 203,  WTAP_ENCAP_LAPD },",
          "361:  { 210,  WTAP_ENCAP_FLEXRAY },",
          "363:  { 211,  WTAP_ENCAP_MOST },",
          "365:  { 212,  WTAP_ENCAP_LIN },",
          "367:  { 213,  WTAP_ENCAP_X2E_SERIAL },",
          "369:  { 214,  WTAP_ENCAP_X2E_XORAYA },",
          "373:  { 220,  WTAP_ENCAP_USB_LINUX_MMAPPED },",
          "",
          "---------------"
        ],
        "wiretap/pcapng.c||wiretap/pcapng.c": [
          "File: wiretap/pcapng.c -> wiretap/pcapng.c"
        ],
        "wiretap/pppdump.c||wiretap/pppdump.c": [
          "File: wiretap/pppdump.c -> wiretap/pppdump.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "355:  if (!collate(state, wth->fh, err, err_info, buf, &num_bytes, &direction,",
          "356:      pid, 0)) {",
          "358:    g_free(pid);",
          "359:   return FALSE;",
          "360:  }",
          "",
          "[Removed Lines]",
          "357:       if (pid != NULL)",
          "",
          "[Added Lines]",
          "357:   if (pid != NULL)",
          "",
          "---------------"
        ],
        "wiretap/toshiba.c||wiretap/toshiba.c": [
          "File: wiretap/toshiba.c -> wiretap/toshiba.c"
        ],
        "wiretap/vms.c||wiretap/vms.c": [
          "File: wiretap/vms.c -> wiretap/vms.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "360:      num_items_scanned = sscanf(p,",
          "363:            &tm.tm_year, &tm.tm_hour,",
          "364:            &tm.tm_min, &tm.tm_sec, &csec);",
          "366:      if (num_items_scanned != 8) {",
          "367:        num_items_scanned = sscanf(p,",
          "372:      }",
          "375:      if (num_items_scanned != 8) {",
          "378:   return FALSE;",
          "379:      }",
          "380:  }",
          "393:      break;",
          "395:     } while (! isdumpline(line));",
          "397:     p = strstr(months, mon);",
          "398:     if (p)",
          "400:     tm.tm_year -= 1900;",
          "401:     tm.tm_isdst = -1;",
          "",
          "[Removed Lines]",
          "361:              \"packet %9d at %2d-%3s-%4d %2d:%2d:%2d.%9d\",",
          "362:              &pktnum, &tm.tm_mday, mon,",
          "368:                \"packet seq # = %9d at %2d-%3s-%4d %2d:%2d:%2d.%9d\",",
          "369:                &pktnum, &tm.tm_mday, mon,",
          "370:              &tm.tm_year, &tm.tm_hour,",
          "371:              &tm.tm_min, &tm.tm_sec, &csec);",
          "381:         if ( (! pkt_len) && (p = strstr(line, \"Length\"))) {",
          "382:             p += sizeof(\"Length \");",
          "383:             while (*p && ! isdigit((guchar)*p))",
          "384:                 p++;",
          "386:             if ( !*p ) {",
          "389:                 return FALSE;",
          "390:             }",
          "392:             pkt_len = atoi(p);",
          "394:         }",
          "399:         tm.tm_mon = (int) (p - months) / 3;",
          "",
          "[Added Lines]",
          "361:            \"packet %9d at %2d-%3s-%4d %2d:%2d:%2d.%9d\",",
          "362:            &pktnum, &tm.tm_mday, mon,",
          "368:       \"packet seq # = %9d at %2d-%3s-%4d %2d:%2d:%2d.%9d\",",
          "369:       &pktnum, &tm.tm_mday, mon,",
          "370:       &tm.tm_year, &tm.tm_hour,",
          "371:       &tm.tm_min, &tm.tm_sec, &csec);",
          "381:  if ( (! pkt_len) && (p = strstr(line, \"Length\"))) {",
          "382:      p += sizeof(\"Length \");",
          "383:      while (*p && ! isdigit((guchar)*p))",
          "384:   p++;",
          "386:      if ( !*p ) {",
          "389:   return FALSE;",
          "390:      }",
          "392:      pkt_len = atoi(p);",
          "394:  }",
          "399:  tm.tm_mon = (int) (p - months) / 3;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "415:     for (i = 0; i < pkt_len; i += 16) {",
          "423:  line[VMS_LINE_LENGTH] = '\\0';",
          "428:       if (*err == 0) {",
          "430:       }",
          "431:       return FALSE;",
          "432:   }",
          "433:   line[VMS_LINE_LENGTH] = '\\0';",
          "434:      }",
          "437:  }",
          "438:  if (!parse_single_hex_dump_line(line, pd, i,",
          "439:      offset, pkt_len - i)) {",
          "444:     }",
          "",
          "[Removed Lines]",
          "416:         if (file_gets(line, VMS_LINE_LENGTH, fh) == NULL) {",
          "418:             if (*err == 0) {",
          "420:             }",
          "421:             return FALSE;",
          "422:         }",
          "424:         if (i == 0) {",
          "426:          if (file_gets(line, VMS_LINE_LENGTH, fh) == NULL) {",
          "435:             while (line[offset] && !isxdigit((guchar)line[offset]))",
          "436:                 offset++;",
          "442:             return FALSE;",
          "443:         }",
          "",
          "[Added Lines]",
          "416:  if (file_gets(line, VMS_LINE_LENGTH, fh) == NULL) {",
          "418:      if (*err == 0) {",
          "420:      }",
          "421:      return FALSE;",
          "422:  }",
          "424:  if (i == 0) {",
          "426:   if (file_gets(line, VMS_LINE_LENGTH, fh) == NULL) {",
          "435:      while (line[offset] && !isxdigit((guchar)line[offset]))",
          "436:   offset++;",
          "442:      return FALSE;",
          "443:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "451:     if (!file_gets(line, VMS_LINE_LENGTH, fh)) {",
          "459:     }",
          "460:     return TRUE;",
          "461: }",
          "",
          "[Removed Lines]",
          "453:         if (*err == 0) {",
          "456:             return TRUE;",
          "457:         }",
          "458:         return FALSE;",
          "",
          "[Added Lines]",
          "453:  if (*err == 0) {",
          "456:      return TRUE;",
          "457:  }",
          "458:  return FALSE;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "495:     if (value != byte_offset) {",
          "497:     }",
          "499:     if (remaining > 16)",
          "",
          "[Removed Lines]",
          "496:         return FALSE;",
          "",
          "[Added Lines]",
          "496:  return FALSE;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "506:     for (i = 0; i < remaining; i++) {",
          "511:     }",
          "513:     return TRUE;",
          "",
          "[Removed Lines]",
          "507:         lbuf[0] = rec[offsets[i] + in_off];",
          "508:         lbuf[1] = rec[offsets[i] + 1 + in_off];",
          "510:         buf[byte_offset + i] = (guint8) strtoul(lbuf, NULL, 16);",
          "",
          "[Added Lines]",
          "507:  lbuf[0] = rec[offsets[i] + in_off];",
          "508:  lbuf[1] = rec[offsets[i] + 1 + in_off];",
          "510:  buf[byte_offset + i] = (guint8) strtoul(lbuf, NULL, 16);",
          "",
          "---------------"
        ],
        "wiretap/wtap.c||wiretap/wtap.c": [
          "File: wiretap/wtap.c -> wiretap/wtap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "646:  { \"BACnet MS/TP with Directional Info\", \"bacnet-ms-tp-with-direction\" },",
          "652:  { \"IEEE 802.11 plus AiroPeek radio header\", \"ieee-802-11-airopeek\" },",
          "",
          "[Removed Lines]",
          "649:   { \"IxVeriWave header and stats block\", \"ixveriwave\" },",
          "",
          "[Added Lines]",
          "649:  { \"IxVeriWave header and stats block\", \"ixveriwave\" },",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ccbf373e49ece2044a0837878c3e4a14aab400a5",
      "candidate_info": {
        "commit_hash": "ccbf373e49ece2044a0837878c3e4a14aab400a5",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/ccbf373e49ece2044a0837878c3e4a14aab400a5",
        "files": [
          "wiretap/logcat.c"
        ],
        "message": "Logcat: Add support for conversion from Exported PDU\n\nExported PDU may contains (Binary) Logcat, so it is possible to\n\"export\" logcat binary from it.\n\nChange-Id: Ic6607126e739ea3972b46c2bf19f064597d4e970\nReviewed-on: https://code.wireshark.org/review/3001\nPetri-Dish: Michal Labedzki <michal.labedzki@tieto.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michal Labedzki <michal.labedzki@tieto.com>\nTested-by: Michal Labedzki <michal.labedzki@tieto.com>",
        "before_after_code_files": [
          "wiretap/logcat.c||wiretap/logcat.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ],
          "candidate": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/logcat.c||wiretap/logcat.c": [
          "File: wiretap/logcat.c -> wiretap/logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "228:     return -1;",
          "229: }",
          "231: static gboolean logcat_read_packet(struct logcat_phdr *logcat, FILE_T fh,",
          "232:     struct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)",
          "233: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "231: static gint buffered_detect_version(const guint8 *pd)",
          "232: {",
          "233:     struct logger_entry     *log_entry;",
          "234:     struct logger_entry_v2  *log_entry_v2;",
          "235:     gint                     version;",
          "236:     guint8                  *msg_payload;",
          "237:     guint8                  *msg_part;",
          "238:     guint8                  *msg_end;",
          "239:     guint16                  msg_len;",
          "241:     log_entry_v2 = (struct logger_entry_v2 *) pd;",
          "242:     log_entry = (struct logger_entry *) pd;",
          "245:     if (log_entry->len < 3)",
          "246:         return -1;",
          "249:     if (log_entry->len > LOGGER_ENTRY_MAX_PAYLOAD)",
          "250:         return -1;",
          "254:     for (version = 1; version <= 2; ++version) {",
          "255:         if (version == 1) {",
          "256:             msg_payload = log_entry->msg;",
          "257:         } else if (version == 2) {",
          "259:             msg_payload = log_entry_v2->msg;",
          "260:             if (log_entry_v2->hdr_size != sizeof(*log_entry_v2))",
          "261:                 continue;",
          "262:         }",
          "265:         if (get_priority(msg_payload[0]) == '?')",
          "266:             continue;",
          "269:         msg_part = (guint8 *) memchr(msg_payload, '\\0', log_entry->len - 1);",
          "270:         if (msg_part == NULL)",
          "271:             continue;",
          "274:         ++msg_part;",
          "275:         msg_len = log_entry->len - (msg_part - msg_payload);",
          "276:         msg_end = (guint8 *) memchr(msg_part, '\\0', msg_len);",
          "278:         if (msg_end && (msg_payload + log_entry->len - 1 != msg_end))",
          "279:             continue;",
          "281:         return version;",
          "282:     }",
          "284:     return -1;",
          "285: }",
          "287: static gint exported_pdu_length(const guint8 *pd) {",
          "288:     guint16 *tag;",
          "289:     guint16 *tag_length;",
          "290:     gint     length = 0;",
          "292:     tag = (guint16 *) pd;",
          "294:     while(GINT16_FROM_BE(*tag)) {",
          "295:         tag_length = (guint16 *) (pd + 2);",
          "296:         length += 2 + 2 + GINT16_FROM_BE(*tag_length);",
          "298:         pd += 2 + 2 + GINT16_FROM_BE(*tag_length);",
          "299:         tag = (guint16 *) pd;",
          "300:     }",
          "302:     length += 2 + 2;",
          "304:     return length;",
          "305: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "357:     if (encap == WTAP_ENCAP_PER_PACKET)",
          "358:         return WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED;",
          "361:         return WTAP_ERR_UNSUPPORTED_ENCAP;",
          "363:     return 0;",
          "",
          "[Removed Lines]",
          "360:     if (encap != WTAP_ENCAP_LOGCAT)",
          "",
          "[Added Lines]",
          "436:     if (encap != WTAP_ENCAP_LOGCAT && encap != WTAP_ENCAP_WIRESHARK_UPPER_PDU)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "367:     const struct wtap_pkthdr *phdr,",
          "368:     const guint8 *pd, int *err)",
          "369: {",
          "371:     if (phdr->rec_type != REC_TYPE_PACKET) {",
          "373:         return FALSE;",
          "374:     }",
          "377:         return FALSE;",
          "381:     return TRUE;",
          "382: }",
          "",
          "[Removed Lines]",
          "376:     if (!wtap_dump_file_write(wdh, pd, phdr->caplen, err))",
          "379:     wdh->bytes_dumped += phdr->caplen;",
          "",
          "[Added Lines]",
          "446:     int caplen;",
          "454:     caplen = phdr->caplen;",
          "457:     if (wdh->encap == WTAP_ENCAP_WIRESHARK_UPPER_PDU) {",
          "458:         gint skipped_length;",
          "460:         skipped_length = exported_pdu_length(pd);",
          "461:         pd += skipped_length;",
          "462:         caplen -= skipped_length;",
          "463:     }",
          "465:     if (!wtap_dump_file_write(wdh, pd, caplen, err))",
          "468:     wdh->bytes_dumped += caplen;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "389:     switch (wdh->encap) {",
          "390:         case WTAP_ENCAP_LOGCAT:",
          "391:             wdh->tsprecision = WTAP_FILE_TSPREC_USEC;",
          "392:             break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "480:         case WTAP_ENCAP_WIRESHARK_UPPER_PDU:",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "406:     gchar                          *buf;",
          "407:     gint                            length;",
          "408:     gchar                           priority;",
          "411:     gint                            payload_length;",
          "412:     const gchar                    *tag;",
          "413:     gint32                          pid;",
          "",
          "[Removed Lines]",
          "409:     const struct logger_entry      *log_entry = (struct logger_entry *) pd;",
          "410:     const struct logger_entry_v2   *log_entry_v2 = (struct logger_entry_v2 *) pd;",
          "",
          "[Added Lines]",
          "499:     const struct logger_entry      *log_entry;",
          "500:     const struct logger_entry_v2   *log_entry_v2;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "419:     gchar                          *log;",
          "420:     gchar                          *log_part;",
          "421:     gchar                          *log_next;",
          "423:     const struct dumper_t          *dumper        = (const struct dumper_t *) wdh->priv;",
          "",
          "[Removed Lines]",
          "422:     const union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
          "",
          "[Added Lines]",
          "512:     gint                            logcat_version;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "428:         return FALSE;",
          "429:     }",
          "431:     payload_length = GINT32_FROM_LE(log_entry->len);",
          "432:     pid = GINT32_FROM_LE(log_entry->pid);",
          "433:     tid = GINT32_FROM_LE(log_entry->tid);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "522:     if (wdh->encap == WTAP_ENCAP_WIRESHARK_UPPER_PDU) {",
          "523:         gint skipped_length;",
          "525:         skipped_length = exported_pdu_length(pd);",
          "526:         pd += skipped_length;",
          "528:         logcat_version = buffered_detect_version(pd);",
          "529:     } else {",
          "530:         const union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
          "532:         logcat_version = pseudo_header->logcat.version;",
          "533:     }",
          "535:     log_entry = (struct logger_entry *) pd;",
          "536:     log_entry_v2 = (struct logger_entry_v2 *) pd;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "435:     milliseconds = GINT32_FROM_LE(log_entry->nsec) / 1000000;",
          "439:         priority = get_priority(log_entry->msg[0]);",
          "440:         tag = log_entry->msg + 1;",
          "441:         msg_pre_skip = 1 + (gint) strlen(tag) + 1;",
          "442:         msg_begin = log_entry->msg + msg_pre_skip;",
          "444:         priority = get_priority(log_entry_v2->msg[0]);",
          "445:         tag = log_entry_v2->msg + 1;",
          "446:         msg_pre_skip = 1 + (gint) strlen(tag) + 1;",
          "",
          "[Removed Lines]",
          "438:     if (pseudo_header->logcat.version == 1) {",
          "443:     } else if (pseudo_header->logcat.version == 2) {",
          "",
          "[Added Lines]",
          "545:     if (logcat_version == 1) {",
          "550:     } else if (logcat_version == 2) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-11487",
  "cve_desc": "The Linux kernel before 5.1-rc5 allows page->_refcount reference count overflow, with resultant use-after-free issues, if about 140 GiB of RAM exists. This is related to fs/fuse/dev.c, fs/pipe.c, fs/splice.c, include/linux/mm.h, include/linux/pipe_fs_i.h, kernel/trace/trace.c, mm/gup.c, and mm/hugetlb.c. It can occur with FUSE requests.",
  "repo": "torvalds/linux",
  "patch_hash": "8fde12ca79aff9b5ba951fce1a2641901b8d8e64",
  "patch_info": {
    "commit_hash": "8fde12ca79aff9b5ba951fce1a2641901b8d8e64",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/8fde12ca79aff9b5ba951fce1a2641901b8d8e64",
    "files": [
      "mm/gup.c",
      "mm/hugetlb.c"
    ],
    "message": "mm: prevent get_user_pages() from overflowing page refcount\n\nIf the page refcount wraps around past zero, it will be freed while\nthere are still four billion references to it.  One of the possible\navenues for an attacker to try to make this happen is by doing direct IO\non a page multiple times.  This patch makes get_user_pages() refuse to\ntake a new page reference if there are already more than two billion\nreferences to the page.\n\nReported-by: Jann Horn <jannh@google.com>\nAcked-by: Matthew Wilcox <willy@infradead.org>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "mm/gup.c||mm/gup.c",
      "mm/hugetlb.c||mm/hugetlb.c"
    ]
  },
  "patch_diff": {
    "mm/gup.c||mm/gup.c": [
      "File: mm/gup.c -> mm/gup.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "157:   goto retry;",
      "158:  }",
      "162:  if (flags & FOLL_TOUCH) {",
      "163:   if ((flags & FOLL_WRITE) &&",
      "164:       !pte_dirty(pte) && !PageDirty(page))",
      "",
      "[Removed Lines]",
      "160:  if (flags & FOLL_GET)",
      "161:   get_page(page);",
      "",
      "[Added Lines]",
      "160:  if (flags & FOLL_GET) {",
      "161:   if (unlikely(!try_get_page(page))) {",
      "162:    page = ERR_PTR(-ENOMEM);",
      "163:    goto out;",
      "164:   }",
      "165:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "295:    if (pmd_trans_unstable(pmd))",
      "296:     ret = -EBUSY;",
      "297:   } else {",
      "299:    spin_unlock(ptl);",
      "300:    lock_page(page);",
      "301:    ret = split_huge_page(page);",
      "",
      "[Removed Lines]",
      "298:    get_page(page);",
      "",
      "[Added Lines]",
      "302:    if (unlikely(!try_get_page(page))) {",
      "303:     spin_unlock(ptl);",
      "304:     return ERR_PTR(-ENOMEM);",
      "305:    }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "497:   if (is_device_public_page(*page))",
      "498:    goto unmap;",
      "499:  }",
      "501: out:",
      "502:  ret = 0;",
      "503: unmap:",
      "",
      "[Removed Lines]",
      "500:  get_page(*page);",
      "",
      "[Added Lines]",
      "507:  if (unlikely(!try_get_page(*page))) {",
      "508:   ret = -ENOMEM;",
      "509:   goto unmap;",
      "510:  }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1393:  }",
      "1394: }",
      "1396: #ifdef CONFIG_ARCH_HAS_PTE_SPECIAL",
      "1397: static int gup_pte_range(pmd_t pmd, unsigned long addr, unsigned long end,",
      "1398:     int write, struct page **pages, int *nr)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1410: static inline struct page *try_get_compound_head(struct page *page, int refs)",
      "1411: {",
      "1412:  struct page *head = compound_head(page);",
      "1413:  if (WARN_ON_ONCE(page_ref_count(head) < 0))",
      "1414:   return NULL;",
      "1415:  if (unlikely(!page_cache_add_speculative(head, refs)))",
      "1416:   return NULL;",
      "1417:  return head;",
      "1418: }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1428:   VM_BUG_ON(!pfn_valid(pte_pfn(pte)));",
      "1429:   page = pte_page(pte);",
      "1433:    goto pte_unmap;",
      "1435:   if (unlikely(pte_val(pte) != pte_val(*ptep))) {",
      "",
      "[Removed Lines]",
      "1430:   head = compound_head(page);",
      "1432:   if (!page_cache_get_speculative(head))",
      "",
      "[Added Lines]",
      "1455:   head = try_get_compound_head(page, 1);",
      "1456:   if (!head)",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1568:   refs++;",
      "1569:  } while (addr += PAGE_SIZE, addr != end);",
      "1574:   return 0;",
      "1575:  }",
      "",
      "[Removed Lines]",
      "1571:  head = compound_head(pmd_page(orig));",
      "1572:  if (!page_cache_add_speculative(head, refs)) {",
      "",
      "[Added Lines]",
      "1595:  head = try_get_compound_head(pmd_page(orig), refs);",
      "1596:  if (!head) {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1606:   refs++;",
      "1607:  } while (addr += PAGE_SIZE, addr != end);",
      "1612:   return 0;",
      "1613:  }",
      "",
      "[Removed Lines]",
      "1609:  head = compound_head(pud_page(orig));",
      "1610:  if (!page_cache_add_speculative(head, refs)) {",
      "",
      "[Added Lines]",
      "1633:  head = try_get_compound_head(pud_page(orig), refs);",
      "1634:  if (!head) {",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "1643:   refs++;",
      "1644:  } while (addr += PAGE_SIZE, addr != end);",
      "1649:   return 0;",
      "1650:  }",
      "",
      "[Removed Lines]",
      "1646:  head = compound_head(pgd_page(orig));",
      "1647:  if (!page_cache_add_speculative(head, refs)) {",
      "",
      "[Added Lines]",
      "1670:  head = try_get_compound_head(pgd_page(orig), refs);",
      "1671:  if (!head) {",
      "",
      "---------------"
    ],
    "mm/hugetlb.c||mm/hugetlb.c": [
      "File: mm/hugetlb.c -> mm/hugetlb.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4299:   pfn_offset = (vaddr & ~huge_page_mask(h)) >> PAGE_SHIFT;",
      "4300:   page = pte_page(huge_ptep_get(pte));",
      "4301: same_page:",
      "4302:   if (pages) {",
      "4303:    pages[i] = mem_map_offset(page, pfn_offset);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4306:   if (unlikely(page_count(page) <= 0)) {",
      "4307:    if (pages) {",
      "4308:     spin_unlock(ptl);",
      "4309:     remainder = 0;",
      "4310:     err = -ENOMEM;",
      "4311:     break;",
      "4312:    }",
      "4313:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a43e982082c24c2f5c0b139daac9657ac352eed3",
      "candidate_info": {
        "commit_hash": "a43e982082c24c2f5c0b139daac9657ac352eed3",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/a43e982082c24c2f5c0b139daac9657ac352eed3",
        "files": [
          "mm/gup.c"
        ],
        "message": "mm/gup: factor out duplicate code from four routines\n\nPatch series \"mm/gup: prereqs to track dma-pinned pages: FOLL_PIN\", v12.\n\nOverview:\n\nThis is a prerequisite to solving the problem of proper interactions\nbetween file-backed pages, and [R]DMA activities, as discussed in [1],\n[2], [3], and in a remarkable number of email threads since about\n2017.  :)\n\nA new internal gup flag, FOLL_PIN is introduced, and thoroughly\ndocumented in the last patch's Documentation/vm/pin_user_pages.rst.\n\nI believe that this will provide a good starting point for doing the\nlayout lease work that Ira Weiny has been working on.  That's because\nthese new wrapper functions provide a clean, constrained, systematically\nnamed set of functionality that, again, is required in order to even\nknow if a page is \"dma-pinned\".\n\nIn contrast to earlier approaches, the page tracking can be\nincrementally applied to the kernel call sites that, until now, have\nbeen simply calling get_user_pages() (\"gup\").  In other words, opt-in by\nchanging from this:\n\n    get_user_pages() (sets FOLL_GET)\n    put_page()\n\nto this:\n    pin_user_pages() (sets FOLL_PIN)\n    unpin_user_page()\n\nTesting:\n\n* I've done some overall kernel testing (LTP, and a few other goodies),\n  and some directed testing to exercise some of the changes. And as you\n  can see, gup_benchmark is enhanced to exercise this. Basically, I've\n  been able to runtime test the core get_user_pages() and\n  pin_user_pages() and related routines, but not so much on several of\n  the call sites--but those are generally just a couple of lines\n  changed, each.\n\n  Not much of the kernel is actually using this, which on one hand\n  reduces risk quite a lot. But on the other hand, testing coverage\n  is low. So I'd love it if, in particular, the Infiniband and PowerPC\n  folks could do a smoke test of this series for me.\n\n  Runtime testing for the call sites so far is pretty light:\n\n    * io_uring: Some directed tests from liburing exercise this, and\n                they pass.\n    * process_vm_access.c: A small directed test passes.\n    * gup_benchmark: the enhanced version hits the new gup.c code, and\n                     passes.\n    * infiniband: Ran rdma-core tests: rdma-core/build/bin/run_tests.py\n    * VFIO: compiles (I'm vowing to set up a run time test soon, but it's\n                      not ready just yet)\n    * powerpc: it compiles...\n    * drm/via: compiles...\n    * goldfish: compiles...\n    * net/xdp: compiles...\n    * media/v4l2: compiles...\n\n[1] Some slow progress on get_user_pages() (Apr 2, 2019): https://lwn.net/Articles/784574/\n[2] DMA and get_user_pages() (LPC: Dec 12, 2018): https://lwn.net/Articles/774411/\n[3] The trouble with get_user_pages() (Apr 30, 2018): https://lwn.net/Articles/753027/\n\nThis patch (of 22):\n\nThere are four locations in gup.c that have a fair amount of code\nduplication.  This means that changing one requires making the same\nchanges in four places, not to mention reading the same code four times,\nand wondering if there are subtle differences.\n\nFactor out the common code into static functions, thus reducing the\noverall line count and the code's complexity.\n\nAlso, take the opportunity to slightly improve the efficiency of the\nerror cases, by doing a mass subtraction of the refcount, surrounded by\nget_page()/put_page().\n\nAlso, further simplify (slightly), by waiting until the the successful\nend of each routine, to increment *nr.\n\nLink: http://lkml.kernel.org/r/20200107224558.2362728-2-jhubbard@nvidia.com\nSigned-off-by: John Hubbard <jhubbard@nvidia.com>\nReviewed-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: J\u00e9r\u00f4me Glisse <jglisse@redhat.com>\nReviewed-by: Jan Kara <jack@suse.cz>\nCc: Kirill A. Shutemov <kirill@shutemov.name>\nCc: Ira Weiny <ira.weiny@intel.com>\nCc: Christoph Hellwig <hch@lst.de>\nCc: Aneesh Kumar K.V <aneesh.kumar@linux.ibm.com>\nCc: Alex Williamson <alex.williamson@redhat.com>\nCc: Bj\u00f6rn T\u00f6pel <bjorn.topel@intel.com>\nCc: Daniel Vetter <daniel.vetter@ffwll.ch>\nCc: Dan Williams <dan.j.williams@intel.com>\nCc: Hans Verkuil <hverkuil-cisco@xs4all.nl>\nCc: Jason Gunthorpe <jgg@mellanox.com>\nCc: Jason Gunthorpe <jgg@ziepe.ca>\nCc: Jens Axboe <axboe@kernel.dk>\nCc: Jonathan Corbet <corbet@lwn.net>\nCc: Leon Romanovsky <leonro@mellanox.com>\nCc: Mauro Carvalho Chehab <mchehab@kernel.org>\nCc: Mike Rapoport <rppt@linux.ibm.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/gup.c||mm/gup.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/gup.c||mm/gup.c"
          ],
          "candidate": [
            "mm/gup.c||mm/gup.c"
          ]
        }
      },
      "candidate_diff": {
        "mm/gup.c||mm/gup.c": [
          "File: mm/gup.c -> mm/gup.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1978: }",
          "1979: #endif",
          "1981: #ifdef CONFIG_ARCH_HAS_HUGEPD",
          "1982: static unsigned long hugepte_addr_end(unsigned long addr, unsigned long end,",
          "1983:           unsigned long sz)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1981: static int record_subpages(struct page *page, unsigned long addr,",
          "1982:       unsigned long end, struct page **pages)",
          "1983: {",
          "1984:  int nr;",
          "1986:  for (nr = 0; addr != end; addr += PAGE_SIZE)",
          "1987:   pages[nr++] = page++;",
          "1989:  return nr;",
          "1990: }",
          "1992: static void put_compound_head(struct page *page, int refs)",
          "1993: {",
          "1994:  VM_BUG_ON_PAGE(page_ref_count(page) < refs, page);",
          "1999:  if (refs > 1)",
          "2000:   page_ref_sub(page, refs - 1);",
          "2001:  put_page(page);",
          "2002: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2008:  VM_BUG_ON(!pfn_valid(pte_pfn(pte)));",
          "2011:  head = pte_page(pte);",
          "2013:  page = head + ((addr & (sz-1)) >> PAGE_SHIFT);",
          "2022:  head = try_get_compound_head(head, refs);",
          "2025:   return 0;",
          "2028:  if (unlikely(pte_val(pte) != pte_val(*ptep))) {",
          "2033:   return 0;",
          "2034:  }",
          "2036:  SetPageReferenced(head);",
          "2037:  return 1;",
          "2038: }",
          "",
          "[Removed Lines]",
          "2010:  refs = 0;",
          "2014:  do {",
          "2015:   VM_BUG_ON(compound_head(page) != head);",
          "2016:   pages[*nr] = page;",
          "2017:   (*nr)++;",
          "2018:   page++;",
          "2019:   refs++;",
          "2020:  } while (addr += PAGE_SIZE, addr != end);",
          "2023:  if (!head) {",
          "2026:  }",
          "2031:   while (refs--)",
          "2032:    put_page(head);",
          "",
          "[Added Lines]",
          "2035:  refs = record_subpages(page, addr, end, pages + *nr);",
          "2038:  if (!head)",
          "2042:   put_compound_head(head, refs);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2079:   return __gup_device_huge_pmd(orig, pmdp, addr, end, pages, nr);",
          "2080:  }",
          "2083:  page = pmd_page(orig) + ((addr & ~PMD_MASK) >> PAGE_SHIFT);",
          "2091:  head = try_get_compound_head(pmd_page(orig), refs);",
          "2094:   return 0;",
          "2097:  if (unlikely(pmd_val(orig) != pmd_val(*pmdp))) {",
          "2101:   return 0;",
          "2102:  }",
          "2104:  SetPageReferenced(head);",
          "2105:  return 1;",
          "2106: }",
          "",
          "[Removed Lines]",
          "2082:  refs = 0;",
          "2084:  do {",
          "2085:   pages[*nr] = page;",
          "2086:   (*nr)++;",
          "2087:   page++;",
          "2088:   refs++;",
          "2089:  } while (addr += PAGE_SIZE, addr != end);",
          "2092:  if (!head) {",
          "2095:  }",
          "2099:   while (refs--)",
          "2100:    put_page(head);",
          "",
          "[Added Lines]",
          "2094:  refs = record_subpages(page, addr, end, pages + *nr);",
          "2097:  if (!head)",
          "2101:   put_compound_head(head, refs);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2120:   return __gup_device_huge_pud(orig, pudp, addr, end, pages, nr);",
          "2121:  }",
          "2124:  page = pud_page(orig) + ((addr & ~PUD_MASK) >> PAGE_SHIFT);",
          "2132:  head = try_get_compound_head(pud_page(orig), refs);",
          "2135:   return 0;",
          "2138:  if (unlikely(pud_val(orig) != pud_val(*pudp))) {",
          "2142:   return 0;",
          "2143:  }",
          "2145:  SetPageReferenced(head);",
          "2146:  return 1;",
          "2147: }",
          "",
          "[Removed Lines]",
          "2123:  refs = 0;",
          "2125:  do {",
          "2126:   pages[*nr] = page;",
          "2127:   (*nr)++;",
          "2128:   page++;",
          "2129:   refs++;",
          "2130:  } while (addr += PAGE_SIZE, addr != end);",
          "2133:  if (!head) {",
          "2136:  }",
          "2140:   while (refs--)",
          "2141:    put_page(head);",
          "",
          "[Added Lines]",
          "2126:  refs = record_subpages(page, addr, end, pages + *nr);",
          "2129:  if (!head)",
          "2133:   put_compound_head(head, refs);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2157:   return 0;",
          "2159:  BUILD_BUG_ON(pgd_devmap(orig));",
          "2161:  page = pgd_page(orig) + ((addr & ~PGDIR_MASK) >> PAGE_SHIFT);",
          "2169:  head = try_get_compound_head(pgd_page(orig), refs);",
          "2172:   return 0;",
          "2175:  if (unlikely(pgd_val(orig) != pgd_val(*pgdp))) {",
          "2179:   return 0;",
          "2180:  }",
          "2182:  SetPageReferenced(head);",
          "2183:  return 1;",
          "2184: }",
          "",
          "[Removed Lines]",
          "2160:  refs = 0;",
          "2162:  do {",
          "2163:   pages[*nr] = page;",
          "2164:   (*nr)++;",
          "2165:   page++;",
          "2166:   refs++;",
          "2167:  } while (addr += PAGE_SIZE, addr != end);",
          "2170:  if (!head) {",
          "2173:  }",
          "2177:   while (refs--)",
          "2178:    put_page(head);",
          "",
          "[Added Lines]",
          "2155:  refs = record_subpages(page, addr, end, pages + *nr);",
          "2158:  if (!head)",
          "2162:   put_compound_head(head, refs);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3faa52c03f440d1b9ddef18c4f189f4790d52d7e",
      "candidate_info": {
        "commit_hash": "3faa52c03f440d1b9ddef18c4f189f4790d52d7e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3faa52c03f440d1b9ddef18c4f189f4790d52d7e",
        "files": [
          "Documentation/core-api/pin_user_pages.rst",
          "include/linux/mm.h",
          "mm/gup.c",
          "mm/huge_memory.c",
          "mm/hugetlb.c"
        ],
        "message": "mm/gup: track FOLL_PIN pages\n\nAdd tracking of pages that were pinned via FOLL_PIN.  This tracking is\nimplemented via overloading of page->_refcount: pins are added by adding\nGUP_PIN_COUNTING_BIAS (1024) to the refcount.  This provides a fuzzy\nindication of pinning, and it can have false positives (and that's OK).\nPlease see the pre-existing Documentation/core-api/pin_user_pages.rst for\ndetails.\n\nAs mentioned in pin_user_pages.rst, callers who effectively set FOLL_PIN\n(typically via pin_user_pages*()) are required to ultimately free such\npages via unpin_user_page().\n\nPlease also note the limitation, discussed in pin_user_pages.rst under the\n\"TODO: for 1GB and larger huge pages\" section.  (That limitation will be\nremoved in a following patch.)\n\nThe effect of a FOLL_PIN flag is similar to that of FOLL_GET, and may be\nthought of as \"FOLL_GET for DIO and/or RDMA use\".\n\nPages that have been pinned via FOLL_PIN are identifiable via a new\nfunction call:\n\n   bool page_maybe_dma_pinned(struct page *page);\n\nWhat to do in response to encountering such a page, is left to later\npatchsets. There is discussion about this in [1], [2], [3], and [4].\n\nThis also changes a BUG_ON(), to a WARN_ON(), in follow_page_mask().\n\n[1] Some slow progress on get_user_pages() (Apr 2, 2019):\n    https://lwn.net/Articles/784574/\n[2] DMA and get_user_pages() (LPC: Dec 12, 2018):\n    https://lwn.net/Articles/774411/\n[3] The trouble with get_user_pages() (Apr 30, 2018):\n    https://lwn.net/Articles/753027/\n[4] LWN kernel index: get_user_pages():\n    https://lwn.net/Kernel/Index/#Memory_management-get_user_pages\n\n[jhubbard@nvidia.com: add kerneldoc]\n  Link: http://lkml.kernel.org/r/20200307021157.235726-1-jhubbard@nvidia.com\n[imbrenda@linux.ibm.com: if pin fails, we need to unpin, a simple put_page will not be enough]\n  Link: http://lkml.kernel.org/r/20200306132537.783769-2-imbrenda@linux.ibm.com\n[akpm@linux-foundation.org: fix put_compound_head defined but not used]\nSuggested-by: Jan Kara <jack@suse.cz>\nSuggested-by: J\u00e9r\u00f4me Glisse <jglisse@redhat.com>\nSigned-off-by: John Hubbard <jhubbard@nvidia.com>\nSigned-off-by: Claudio Imbrenda <imbrenda@linux.ibm.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nReviewed-by: Jan Kara <jack@suse.cz>\nAcked-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>\nCc: Ira Weiny <ira.weiny@intel.com>\nCc: \"Matthew Wilcox (Oracle)\" <willy@infradead.org>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Christoph Hellwig <hch@infradead.org>\nCc: Dan Williams <dan.j.williams@intel.com>\nCc: Dave Chinner <david@fromorbit.com>\nCc: Jason Gunthorpe <jgg@ziepe.ca>\nCc: Jonathan Corbet <corbet@lwn.net>\nCc: Michal Hocko <mhocko@suse.com>\nCc: Mike Kravetz <mike.kravetz@oracle.com>\nCc: Shuah Khan <shuah@kernel.org>\nCc: Vlastimil Babka <vbabka@suse.cz>\nLink: http://lkml.kernel.org/r/20200211001536.1027652-7-jhubbard@nvidia.com\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "include/linux/mm.h||include/linux/mm.h",
          "mm/gup.c||mm/gup.c",
          "mm/huge_memory.c||mm/huge_memory.c",
          "mm/hugetlb.c||mm/hugetlb.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/gup.c||mm/gup.c",
            "mm/hugetlb.c||mm/hugetlb.c"
          ],
          "candidate": [
            "mm/gup.c||mm/gup.c",
            "mm/hugetlb.c||mm/hugetlb.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/mm.h||include/linux/mm.h": [
          "File: include/linux/mm.h -> include/linux/mm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1001:  page_ref_inc(page);",
          "1002: }",
          "1004: static inline __must_check bool try_get_page(struct page *page)",
          "1005: {",
          "1006:  page = compound_head(page);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1004: bool __must_check try_grab_page(struct page *page, unsigned int flags);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1029:   __put_page(page);",
          "1030: }",
          "1050: void unpin_user_pages_dirty_lock(struct page **pages, unsigned long npages,",
          "1051:      bool make_dirty);",
          "1053: void unpin_user_pages(struct page **pages, unsigned long npages);",
          "1055: #if defined(CONFIG_SPARSEMEM) && !defined(CONFIG_SPARSEMEM_VMEMMAP)",
          "1056: #define SECTION_IN_PAGE_FLAGS",
          "1057: #endif",
          "",
          "[Removed Lines]",
          "1045: static inline void unpin_user_page(struct page *page)",
          "1046: {",
          "1047:  put_page(page);",
          "1048: }",
          "",
          "[Added Lines]",
          "1065: #define GUP_PIN_COUNTING_BIAS (1U << 10)",
          "1067: void unpin_user_page(struct page *page);",
          "1093: static inline bool page_maybe_dma_pinned(struct page *page)",
          "1094: {",
          "1103:  return ((unsigned int)page_ref_count(compound_head(page))) >=",
          "1104:   GUP_PIN_COUNTING_BIAS;",
          "1105: }",
          "",
          "---------------"
        ],
        "mm/gup.c||mm/gup.c": [
          "File: mm/gup.c -> mm/gup.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "44:  return head;",
          "45: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66: static __maybe_unused struct page *try_grab_compound_head(struct page *page,",
          "67:          int refs,",
          "68:          unsigned int flags)",
          "69: {",
          "70:  if (flags & FOLL_GET)",
          "71:   return try_get_compound_head(page, refs);",
          "72:  else if (flags & FOLL_PIN) {",
          "73:   refs *= GUP_PIN_COUNTING_BIAS;",
          "74:   return try_get_compound_head(page, refs);",
          "75:  }",
          "77:  WARN_ON_ONCE(1);",
          "78:  return NULL;",
          "79: }",
          "102: bool __must_check try_grab_page(struct page *page, unsigned int flags)",
          "103: {",
          "104:  WARN_ON_ONCE((flags & (FOLL_GET | FOLL_PIN)) == (FOLL_GET | FOLL_PIN));",
          "106:  if (flags & FOLL_GET)",
          "107:   return try_get_page(page);",
          "108:  else if (flags & FOLL_PIN) {",
          "109:   page = compound_head(page);",
          "111:   if (WARN_ON_ONCE(page_ref_count(page) <= 0))",
          "112:    return false;",
          "114:   page_ref_add(page, GUP_PIN_COUNTING_BIAS);",
          "115:  }",
          "117:  return true;",
          "118: }",
          "120: #ifdef CONFIG_DEV_PAGEMAP_OPS",
          "121: static bool __unpin_devmap_managed_user_page(struct page *page)",
          "122: {",
          "123:  int count;",
          "125:  if (!page_is_devmap_managed(page))",
          "126:   return false;",
          "128:  count = page_ref_sub_return(page, GUP_PIN_COUNTING_BIAS);",
          "135:  if (count == 1)",
          "136:   free_devmap_managed_page(page);",
          "137:  else if (!count)",
          "138:   __put_page(page);",
          "140:  return true;",
          "141: }",
          "142: #else",
          "143: static bool __unpin_devmap_managed_user_page(struct page *page)",
          "144: {",
          "145:  return false;",
          "146: }",
          "158: void unpin_user_page(struct page *page)",
          "159: {",
          "160:  page = compound_head(page);",
          "168:  if (__unpin_devmap_managed_user_page(page))",
          "169:   return;",
          "171:  if (page_ref_sub_and_test(page, GUP_PIN_COUNTING_BIAS))",
          "172:   __put_page(page);",
          "173: }",
          "174: EXPORT_SYMBOL(unpin_user_page);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "230:  }",
          "232:  page = vm_normal_page(vma, address, pte);",
          "239:   if (*pgmap)",
          "",
          "[Removed Lines]",
          "233:  if (!page && pte_devmap(pte) && (flags & FOLL_GET)) {",
          "",
          "[Added Lines]",
          "362:  if (!page && pte_devmap(pte) && (flags & (FOLL_GET | FOLL_PIN))) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "271:   goto retry;",
          "272:  }",
          "279:  }",
          "280:  if (flags & FOLL_TOUCH) {",
          "281:   if ((flags & FOLL_WRITE) &&",
          "",
          "[Removed Lines]",
          "274:  if (flags & FOLL_GET) {",
          "275:   if (unlikely(!try_get_page(page))) {",
          "276:    page = ERR_PTR(-ENOMEM);",
          "277:    goto out;",
          "278:   }",
          "",
          "[Added Lines]",
          "405:  if (unlikely(!try_grab_page(page, flags))) {",
          "406:   page = ERR_PTR(-ENOMEM);",
          "407:   goto out;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "538:  page = follow_huge_addr(mm, address, flags & FOLL_WRITE);",
          "539:  if (!IS_ERR(page)) {",
          "541:   return page;",
          "542:  }",
          "",
          "[Removed Lines]",
          "540:   BUG_ON(flags & FOLL_GET);",
          "",
          "[Added Lines]",
          "669:   WARN_ON_ONCE(flags & (FOLL_GET | FOLL_PIN));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1675: {",
          "1676:  return 0;",
          "1677: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1808: static long __get_user_pages_remote(struct task_struct *tsk,",
          "1809:         struct mm_struct *mm,",
          "1810:         unsigned long start, unsigned long nr_pages,",
          "1811:         unsigned int gup_flags, struct page **pages,",
          "1812:         struct vm_area_struct **vmas, int *locked)",
          "1813: {",
          "1814:  return 0;",
          "1815: }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1816: #ifdef CONFIG_HAVE_FAST_GUP",
          "1817: #ifdef CONFIG_GUP_GET_PTE_LOW_HIGH",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1956: static void put_compound_head(struct page *page, int refs, unsigned int flags)",
          "1957: {",
          "1958:  if (flags & FOLL_PIN)",
          "1959:   refs *= GUP_PIN_COUNTING_BIAS;",
          "1961:  VM_BUG_ON_PAGE(page_ref_count(page) < refs, page);",
          "1966:  if (refs > 1)",
          "1967:   page_ref_sub(page, refs - 1);",
          "1968:  put_page(page);",
          "1969: }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1877:   struct page *page = pages[--(*nr)];",
          "1879:   ClearPageReferenced(page);",
          "1881:  }",
          "1882: }",
          "",
          "[Removed Lines]",
          "1880:   put_page(page);",
          "",
          "[Added Lines]",
          "2035:   if (flags & FOLL_PIN)",
          "2036:    unpin_user_page(page);",
          "2037:   else",
          "2038:    put_page(page);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1919:   VM_BUG_ON(!pfn_valid(pte_pfn(pte)));",
          "1920:   page = pte_page(pte);",
          "1923:   if (!head)",
          "1924:    goto pte_unmap;",
          "1926:   if (unlikely(pte_val(pte) != pte_val(*ptep))) {",
          "1928:    goto pte_unmap;",
          "1929:   }",
          "",
          "[Removed Lines]",
          "1922:   head = try_get_compound_head(page, 1);",
          "1927:    put_page(head);",
          "",
          "[Added Lines]",
          "2080:   head = try_grab_compound_head(page, 1, flags);",
          "2085:    put_compound_head(head, 1, flags);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1980:   }",
          "1981:   SetPageReferenced(page);",
          "1982:   pages[*nr] = page;",
          "1984:   (*nr)++;",
          "1985:   pfn++;",
          "1986:  } while (addr += PAGE_SIZE, addr != end);",
          "",
          "[Removed Lines]",
          "1983:   get_page(page);",
          "",
          "[Added Lines]",
          "2141:   if (unlikely(!try_grab_page(page, flags))) {",
          "2142:    undo_dev_pagemap(nr, nr_start, flags, pages);",
          "2143:    return 0;",
          "2144:   }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2054:  return nr;",
          "2055: }",
          "2069: #ifdef CONFIG_ARCH_HAS_HUGEPD",
          "2070: static unsigned long hugepte_addr_end(unsigned long addr, unsigned long end,",
          "2071:           unsigned long sz)",
          "",
          "[Removed Lines]",
          "2057: static void put_compound_head(struct page *page, int refs, unsigned int flags)",
          "2058: {",
          "2059:  VM_BUG_ON_PAGE(page_ref_count(page) < refs, page);",
          "2064:  if (refs > 1)",
          "2065:   page_ref_sub(page, refs - 1);",
          "2066:  put_page(page);",
          "2067: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2099:  page = head + ((addr & (sz-1)) >> PAGE_SHIFT);",
          "2100:  refs = record_subpages(page, addr, end, pages + *nr);",
          "2103:  if (!head)",
          "2104:   return 0;",
          "",
          "[Removed Lines]",
          "2102:  head = try_get_compound_head(head, refs);",
          "",
          "[Added Lines]",
          "2251:  head = try_grab_compound_head(head, refs, flags);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2159:  page = pmd_page(orig) + ((addr & ~PMD_MASK) >> PAGE_SHIFT);",
          "2160:  refs = record_subpages(page, addr, end, pages + *nr);",
          "2163:  if (!head)",
          "2164:   return 0;",
          "",
          "[Removed Lines]",
          "2162:  head = try_get_compound_head(pmd_page(orig), refs);",
          "",
          "[Added Lines]",
          "2311:  head = try_grab_compound_head(pmd_page(orig), refs, flags);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2193:  page = pud_page(orig) + ((addr & ~PUD_MASK) >> PAGE_SHIFT);",
          "2194:  refs = record_subpages(page, addr, end, pages + *nr);",
          "2197:  if (!head)",
          "2198:   return 0;",
          "",
          "[Removed Lines]",
          "2196:  head = try_get_compound_head(pud_page(orig), refs);",
          "",
          "[Added Lines]",
          "2345:  head = try_grab_compound_head(pud_page(orig), refs, flags);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2222:  page = pgd_page(orig) + ((addr & ~PGDIR_MASK) >> PAGE_SHIFT);",
          "2223:  refs = record_subpages(page, addr, end, pages + *nr);",
          "2226:  if (!head)",
          "2227:   return 0;",
          "",
          "[Removed Lines]",
          "2225:  head = try_get_compound_head(pgd_page(orig), refs);",
          "",
          "[Added Lines]",
          "2374:  head = try_grab_compound_head(pgd_page(orig), refs, flags);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2553: int pin_user_pages_fast(unsigned long start, int nr_pages,",
          "2554:    unsigned int gup_flags, struct page **pages)",
          "2555: {",
          "2562: }",
          "2563: EXPORT_SYMBOL_GPL(pin_user_pages_fast);",
          "",
          "[Removed Lines]",
          "2561:  return get_user_pages_fast(start, nr_pages, gup_flags, pages);",
          "",
          "[Added Lines]",
          "2715:  if (WARN_ON_ONCE(gup_flags & FOLL_GET))",
          "2716:   return -EINVAL;",
          "2718:  gup_flags |= FOLL_PIN;",
          "2719:  return internal_get_user_pages_fast(start, nr_pages, gup_flags, pages);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2577:       unsigned int gup_flags, struct page **pages,",
          "2578:       struct vm_area_struct **vmas, int *locked)",
          "2579: {",
          "2587: }",
          "2588: EXPORT_SYMBOL(pin_user_pages_remote);",
          "",
          "[Removed Lines]",
          "2585:  return get_user_pages_remote(tsk, mm, start, nr_pages, gup_flags, pages,",
          "2586:          vmas, locked);",
          "",
          "[Added Lines]",
          "2757:  if (WARN_ON_ONCE(gup_flags & FOLL_GET))",
          "2758:   return -EINVAL;",
          "2760:  gup_flags |= FOLL_PIN;",
          "2761:  return __get_user_pages_remote(tsk, mm, start, nr_pages, gup_flags,",
          "2762:            pages, vmas, locked);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2601:       unsigned int gup_flags, struct page **pages,",
          "2602:       struct vm_area_struct **vmas)",
          "2603: {",
          "2610: }",
          "2611: EXPORT_SYMBOL(pin_user_pages);",
          "",
          "[Removed Lines]",
          "2609:  return get_user_pages(start, nr_pages, gup_flags, pages, vmas);",
          "",
          "[Added Lines]",
          "2792:  if (WARN_ON_ONCE(gup_flags & FOLL_GET))",
          "2793:   return -EINVAL;",
          "2795:  gup_flags |= FOLL_PIN;",
          "2796:  return __gup_longterm_locked(current, current->mm, start, nr_pages,",
          "2797:          pages, vmas, gup_flags);",
          "",
          "---------------"
        ],
        "mm/huge_memory.c||mm/huge_memory.c": [
          "File: mm/huge_memory.c -> mm/huge_memory.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "959:  WARN_ONCE(flags & FOLL_COW, \"mm: In follow_devmap_pmd with FOLL_COW set\");",
          "961:  if (flags & FOLL_WRITE && !pmd_write(*pmd))",
          "962:   return NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "962:  if (WARN_ON_ONCE((flags & (FOLL_PIN | FOLL_GET)) ==",
          "963:     (FOLL_PIN | FOLL_GET)))",
          "964:   return NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "977:   return ERR_PTR(-EEXIST);",
          "979:  pfn += (addr & ~PMD_MASK) >> PAGE_SHIFT;",
          "",
          "[Removed Lines]",
          "976:  if (!(flags & FOLL_GET))",
          "",
          "[Added Lines]",
          "981:  if (!(flags & (FOLL_GET | FOLL_PIN)))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "981:  if (!*pgmap)",
          "982:   return ERR_PTR(-EFAULT);",
          "983:  page = pfn_to_page(pfn);",
          "986:  return page;",
          "987: }",
          "",
          "[Removed Lines]",
          "984:  get_page(page);",
          "",
          "[Added Lines]",
          "989:  if (!try_grab_page(page, flags))",
          "990:   page = ERR_PTR(-ENOMEM);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1101:  if (flags & FOLL_WRITE && !pud_write(*pud))",
          "1102:   return NULL;",
          "1104:  if (pud_present(*pud) && pud_devmap(*pud))",
          "1106:  else",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1111:  if (WARN_ON_ONCE((flags & (FOLL_PIN | FOLL_GET)) ==",
          "1112:     (FOLL_PIN | FOLL_GET)))",
          "1113:   return NULL;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1117:   return ERR_PTR(-EEXIST);",
          "1119:  pfn += (addr & ~PUD_MASK) >> PAGE_SHIFT;",
          "",
          "[Removed Lines]",
          "1116:  if (!(flags & FOLL_GET))",
          "",
          "[Added Lines]",
          "1129:  if (!(flags & (FOLL_GET | FOLL_PIN)))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1121:  if (!*pgmap)",
          "1122:   return ERR_PTR(-EFAULT);",
          "1123:  page = pfn_to_page(pfn);",
          "1126:  return page;",
          "1127: }",
          "",
          "[Removed Lines]",
          "1124:  get_page(page);",
          "",
          "[Added Lines]",
          "1137:  if (!try_grab_page(page, flags))",
          "1138:   page = ERR_PTR(-ENOMEM);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1498:  page = pmd_page(*pmd);",
          "1499:  VM_BUG_ON_PAGE(!PageHead(page) && !is_zone_device_page(page), page);",
          "1500:  if (flags & FOLL_TOUCH)",
          "1501:   touch_pmd(vma, addr, pmd, flags);",
          "1502:  if ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1515:  if (!try_grab_page(page, flags))",
          "1516:   return ERR_PTR(-ENOMEM);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1535: skip_mlock:",
          "1536:  page += (addr & ~HPAGE_PMD_MASK) >> PAGE_SHIFT;",
          "1537:  VM_BUG_ON_PAGE(!PageCompound(page) && !is_zone_device_page(page), page);",
          "1541: out:",
          "1542:  return page;",
          "",
          "[Removed Lines]",
          "1538:  if (flags & FOLL_GET)",
          "1539:   get_page(page);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "mm/hugetlb.c||mm/hugetlb.c": [
          "File: mm/hugetlb.c -> mm/hugetlb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4375:   pfn_offset = (vaddr & ~huge_page_mask(h)) >> PAGE_SHIFT;",
          "4376:   page = pte_page(huge_ptep_get(pte));",
          "",
          "[Removed Lines]",
          "4382:   if (unlikely(page_count(page) <= 0)) {",
          "4383:    if (pages) {",
          "4384:     spin_unlock(ptl);",
          "4385:     remainder = 0;",
          "4386:     err = -ENOMEM;",
          "4387:     break;",
          "4388:    }",
          "4389:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4405: same_page:",
          "4406:   if (pages) {",
          "4407:    pages[i] = mem_map_offset(page, pfn_offset);",
          "4409:   }",
          "4411:   if (vmas)",
          "",
          "[Removed Lines]",
          "4408:    get_page(pages[i]);",
          "",
          "[Added Lines]",
          "4405:    if (WARN_ON_ONCE(!try_grab_page(pages[i], flags))) {",
          "4406:     spin_unlock(ptl);",
          "4407:     remainder = 0;",
          "4408:     err = -ENOMEM;",
          "4409:     break;",
          "4410:    }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4965:  struct page *page = NULL;",
          "4966:  spinlock_t *ptl;",
          "4967:  pte_t pte;",
          "4968: retry:",
          "4969:  ptl = pmd_lockptr(mm, pmd);",
          "4970:  spin_lock(ptl);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4972:  if (WARN_ON_ONCE((flags & (FOLL_PIN | FOLL_GET)) ==",
          "4973:     (FOLL_PIN | FOLL_GET)))",
          "4974:   return NULL;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4977:  pte = huge_ptep_get((pte_t *)pmd);",
          "4978:  if (pte_present(pte)) {",
          "4979:   page = pmd_page(*pmd) + ((address & ~PMD_MASK) >> PAGE_SHIFT);",
          "4982:  } else {",
          "4983:   if (is_hugetlb_entry_migration(pte)) {",
          "4984:    spin_unlock(ptl);",
          "",
          "[Removed Lines]",
          "4980:   if (flags & FOLL_GET)",
          "4981:    get_page(page);",
          "",
          "[Added Lines]",
          "4996:   if (WARN_ON_ONCE(!try_grab_page(page, flags))) {",
          "4997:    page = NULL;",
          "4998:    goto out;",
          "4999:   }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4999: follow_huge_pud(struct mm_struct *mm, unsigned long address,",
          "5000:   pud_t *pud, int flags)",
          "5001: {",
          "5003:   return NULL;",
          "5005:  return pte_page(*(pte_t *)pud) + ((address & ~PUD_MASK) >> PAGE_SHIFT);",
          "",
          "[Removed Lines]",
          "5002:  if (flags & FOLL_GET)",
          "",
          "[Added Lines]",
          "5020:  if (flags & (FOLL_GET | FOLL_PIN))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "5008: struct page * __weak",
          "5009: follow_huge_pgd(struct mm_struct *mm, unsigned long address, pgd_t *pgd, int flags)",
          "5010: {",
          "5012:   return NULL;",
          "5014:  return pte_page(*(pte_t *)pgd) + ((address & ~PGDIR_MASK) >> PAGE_SHIFT);",
          "",
          "[Removed Lines]",
          "5011:  if (flags & FOLL_GET)",
          "",
          "[Added Lines]",
          "5029:  if (flags & (FOLL_GET | FOLL_PIN))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "df06b37ffe5a442503b7095b77b0a970df515459",
      "candidate_info": {
        "commit_hash": "df06b37ffe5a442503b7095b77b0a970df515459",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/df06b37ffe5a442503b7095b77b0a970df515459",
        "files": [
          "include/linux/huge_mm.h",
          "include/linux/mm.h",
          "mm/gup.c",
          "mm/huge_memory.c",
          "mm/nommu.c"
        ],
        "message": "mm/gup: cache dev_pagemap while pinning pages\n\nGetting pages from ZONE_DEVICE memory needs to check the backing device's\nlive-ness, which is tracked in the device's dev_pagemap metadata.  This\nmetadata is stored in a radix tree and looking it up adds measurable\nsoftware overhead.\n\nThis patch avoids repeating this relatively costly operation when\ndev_pagemap is used by caching the last dev_pagemap while getting user\npages.  The gup_benchmark kernel self test reports this reduces time to\nget user pages to as low as 1/3 of the previous time.\n\nLink: http://lkml.kernel.org/r/20181012173040.15669-1-keith.busch@intel.com\nSigned-off-by: Keith Busch <keith.busch@intel.com>\nReviewed-by: Dan Williams <dan.j.williams@intel.com>\nAcked-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>\nCc: Dave Hansen <dave.hansen@intel.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "include/linux/huge_mm.h||include/linux/huge_mm.h",
          "include/linux/mm.h||include/linux/mm.h",
          "mm/gup.c||mm/gup.c",
          "mm/huge_memory.c||mm/huge_memory.c",
          "mm/nommu.c||mm/nommu.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/gup.c||mm/gup.c"
          ],
          "candidate": [
            "mm/gup.c||mm/gup.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/huge_mm.h||include/linux/huge_mm.h": [
          "File: include/linux/huge_mm.h -> include/linux/huge_mm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "213: }",
          "215: struct page *follow_devmap_pmd(struct vm_area_struct *vma, unsigned long addr,",
          "217: struct page *follow_devmap_pud(struct vm_area_struct *vma, unsigned long addr,",
          "220: extern vm_fault_t do_huge_pmd_numa_page(struct vm_fault *vmf, pmd_t orig_pmd);",
          "",
          "[Removed Lines]",
          "216:   pmd_t *pmd, int flags);",
          "218:   pud_t *pud, int flags);",
          "",
          "[Added Lines]",
          "216:   pmd_t *pmd, int flags, struct dev_pagemap **pgmap);",
          "218:   pud_t *pud, int flags, struct dev_pagemap **pgmap);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "344: }",
          "346: static inline struct page *follow_devmap_pmd(struct vm_area_struct *vma,",
          "348: {",
          "349:  return NULL;",
          "350: }",
          "352: static inline struct page *follow_devmap_pud(struct vm_area_struct *vma,",
          "354: {",
          "355:  return NULL;",
          "356: }",
          "",
          "[Removed Lines]",
          "347:   unsigned long addr, pmd_t *pmd, int flags)",
          "353:   unsigned long addr, pud_t *pud, int flags)",
          "",
          "[Added Lines]",
          "347:  unsigned long addr, pmd_t *pmd, int flags, struct dev_pagemap **pgmap)",
          "353:  unsigned long addr, pud_t *pud, int flags, struct dev_pagemap **pgmap)",
          "",
          "---------------"
        ],
        "include/linux/mm.h||include/linux/mm.h": [
          "File: include/linux/mm.h -> include/linux/mm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2536:  return VM_FAULT_SIGBUS;",
          "2537: }",
          "",
          "[Removed Lines]",
          "2539: struct page *follow_page_mask(struct vm_area_struct *vma,",
          "2540:          unsigned long address, unsigned int foll_flags,",
          "2541:          unsigned int *page_mask);",
          "2543: static inline struct page *follow_page(struct vm_area_struct *vma,",
          "2544:   unsigned long address, unsigned int foll_flags)",
          "2545: {",
          "2546:  unsigned int unused_page_mask;",
          "2547:  return follow_page_mask(vma, address, foll_flags, &unused_page_mask);",
          "2548: }",
          "",
          "[Added Lines]",
          "2539: struct page *follow_page(struct vm_area_struct *vma, unsigned long address,",
          "2540:     unsigned int foll_flags);",
          "",
          "---------------"
        ],
        "mm/gup.c||mm/gup.c": [
          "File: mm/gup.c -> mm/gup.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: #include \"internal.h\"",
          "23: static struct page *no_page_table(struct vm_area_struct *vma,",
          "24:   unsigned int flags)",
          "25: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: struct follow_page_context {",
          "24:  struct dev_pagemap *pgmap;",
          "25:  unsigned int page_mask;",
          "26: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "71: }",
          "73: static struct page *follow_page_pte(struct vm_area_struct *vma,",
          "75: {",
          "76:  struct mm_struct *mm = vma->vm_mm;",
          "78:  struct page *page;",
          "79:  spinlock_t *ptl;",
          "80:  pte_t *ptep, pte;",
          "",
          "[Removed Lines]",
          "74:   unsigned long address, pmd_t *pmd, unsigned int flags)",
          "77:  struct dev_pagemap *pgmap = NULL;",
          "",
          "[Added Lines]",
          "79:   unsigned long address, pmd_t *pmd, unsigned int flags,",
          "80:   struct dev_pagemap **pgmap)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "121:    page = pte_page(pte);",
          "122:   else",
          "123:    goto no_page;",
          "",
          "[Removed Lines]",
          "119:   pgmap = get_dev_pagemap(pte_pfn(pte), NULL);",
          "120:   if (pgmap)",
          "",
          "[Added Lines]",
          "125:   if (*pgmap)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "152:   goto retry;",
          "153:  }",
          "156:   get_page(page);",
          "164:  if (flags & FOLL_TOUCH) {",
          "165:   if ((flags & FOLL_WRITE) &&",
          "166:       !pte_dirty(pte) && !PageDirty(page))",
          "",
          "[Removed Lines]",
          "155:  if (flags & FOLL_GET) {",
          "159:   if (pgmap) {",
          "160:    put_dev_pagemap(pgmap);",
          "161:    pgmap = NULL;",
          "162:   }",
          "163:  }",
          "",
          "[Added Lines]",
          "160:  if (flags & FOLL_GET)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "211: static struct page *follow_pmd_mask(struct vm_area_struct *vma,",
          "212:         unsigned long address, pud_t *pudp,",
          "214: {",
          "215:  pmd_t *pmd, pmdval;",
          "216:  spinlock_t *ptl;",
          "",
          "[Removed Lines]",
          "213:         unsigned int flags, unsigned int *page_mask)",
          "",
          "[Added Lines]",
          "211:         unsigned int flags,",
          "212:         struct follow_page_context *ctx)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "258:  }",
          "259:  if (pmd_devmap(pmdval)) {",
          "260:   ptl = pmd_lock(mm, pmd);",
          "262:   spin_unlock(ptl);",
          "263:   if (page)",
          "264:    return page;",
          "265:  }",
          "266:  if (likely(!pmd_trans_huge(pmdval)))",
          "269:  if ((flags & FOLL_NUMA) && pmd_protnone(pmdval))",
          "270:   return no_page_table(vma, flags);",
          "",
          "[Removed Lines]",
          "261:   page = follow_devmap_pmd(vma, address, pmd, flags);",
          "267:   return follow_page_pte(vma, address, pmd, flags);",
          "",
          "[Added Lines]",
          "260:   page = follow_devmap_pmd(vma, address, pmd, flags, &ctx->pgmap);",
          "266:   return follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "284:  }",
          "285:  if (unlikely(!pmd_trans_huge(*pmd))) {",
          "286:   spin_unlock(ptl);",
          "288:  }",
          "289:  if (flags & FOLL_SPLIT) {",
          "290:   int ret;",
          "",
          "[Removed Lines]",
          "287:   return follow_page_pte(vma, address, pmd, flags);",
          "",
          "[Added Lines]",
          "286:   return follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "307:   }",
          "309:   return ret ? ERR_PTR(ret) :",
          "311:  }",
          "312:  page = follow_trans_huge_pmd(vma, address, pmd, flags);",
          "313:  spin_unlock(ptl);",
          "315:  return page;",
          "316: }",
          "319: static struct page *follow_pud_mask(struct vm_area_struct *vma,",
          "320:         unsigned long address, p4d_t *p4dp,",
          "322: {",
          "323:  pud_t *pud;",
          "324:  spinlock_t *ptl;",
          "",
          "[Removed Lines]",
          "310:    follow_page_pte(vma, address, pmd, flags);",
          "321:         unsigned int flags, unsigned int *page_mask)",
          "",
          "[Added Lines]",
          "309:    follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);",
          "313:  ctx->page_mask = HPAGE_PMD_NR - 1;",
          "319:         unsigned int flags,",
          "320:         struct follow_page_context *ctx)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "344:  }",
          "345:  if (pud_devmap(*pud)) {",
          "346:   ptl = pud_lock(mm, pud);",
          "348:   spin_unlock(ptl);",
          "349:   if (page)",
          "350:    return page;",
          "",
          "[Removed Lines]",
          "347:   page = follow_devmap_pud(vma, address, pud, flags);",
          "",
          "[Added Lines]",
          "346:   page = follow_devmap_pud(vma, address, pud, flags, &ctx->pgmap);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "352:  if (unlikely(pud_bad(*pud)))",
          "353:   return no_page_table(vma, flags);",
          "356: }",
          "359: static struct page *follow_p4d_mask(struct vm_area_struct *vma,",
          "360:         unsigned long address, pgd_t *pgdp,",
          "362: {",
          "363:  p4d_t *p4d;",
          "364:  struct page *page;",
          "",
          "[Removed Lines]",
          "355:  return follow_pmd_mask(vma, address, pud, flags, page_mask);",
          "361:         unsigned int flags, unsigned int *page_mask)",
          "",
          "[Added Lines]",
          "354:  return follow_pmd_mask(vma, address, pud, flags, ctx);",
          "359:         unsigned int flags,",
          "360:         struct follow_page_context *ctx)",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "378:    return page;",
          "379:   return no_page_table(vma, flags);",
          "380:  }",
          "382: }",
          "",
          "[Removed Lines]",
          "381:  return follow_pud_mask(vma, address, p4d, flags, page_mask);",
          "",
          "[Added Lines]",
          "380:  return follow_pud_mask(vma, address, p4d, flags, ctx);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "397: struct page *follow_page_mask(struct vm_area_struct *vma,",
          "398:          unsigned long address, unsigned int flags,",
          "400: {",
          "401:  pgd_t *pgd;",
          "402:  struct page *page;",
          "403:  struct mm_struct *mm = vma->vm_mm;",
          "408:  page = follow_huge_addr(mm, address, flags & FOLL_WRITE);",
          "",
          "[Removed Lines]",
          "399:          unsigned int *page_mask)",
          "",
          "[Added Lines]",
          "398:          struct follow_page_context *ctx)",
          "404:  ctx->page_mask = 0;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "431:   return no_page_table(vma, flags);",
          "432:  }",
          "435: }",
          "437: static int get_gate_page(struct mm_struct *mm, unsigned long address,",
          "",
          "[Removed Lines]",
          "434:  return follow_p4d_mask(vma, address, pgd, flags, page_mask);",
          "",
          "[Added Lines]",
          "433:  return follow_p4d_mask(vma, address, pgd, flags, ctx);",
          "434: }",
          "436: struct page *follow_page(struct vm_area_struct *vma, unsigned long address,",
          "437:     unsigned int foll_flags)",
          "438: {",
          "439:  struct follow_page_context ctx = { NULL };",
          "440:  struct page *page;",
          "442:  page = follow_page_mask(vma, address, foll_flags, &ctx);",
          "443:  if (ctx.pgmap)",
          "444:   put_dev_pagemap(ctx.pgmap);",
          "445:  return page;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "659:   unsigned int gup_flags, struct page **pages,",
          "660:   struct vm_area_struct **vmas, int *nonblocking)",
          "661: {",
          "664:  struct vm_area_struct *vma = NULL;",
          "666:  if (!nr_pages)",
          "667:   return 0;",
          "",
          "[Removed Lines]",
          "662:  long i = 0;",
          "663:  unsigned int page_mask;",
          "",
          "[Added Lines]",
          "673:  long ret = 0, i = 0;",
          "675:  struct follow_page_context ctx = { NULL };",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "691:       pages ? &pages[i] : NULL);",
          "692:     if (ret)",
          "693:      return i ? : ret;",
          "695:     goto next_page;",
          "696:    }",
          "700:    if (is_vm_hugetlb_page(vma)) {",
          "701:     i = follow_hugetlb_page(mm, vma, pages, vmas,",
          "702:       &start, &nr_pages, i,",
          "",
          "[Removed Lines]",
          "694:     page_mask = 0;",
          "698:    if (!vma || check_vma_flags(vma, gup_flags))",
          "699:     return i ? : -EFAULT;",
          "",
          "[Added Lines]",
          "705:     ctx.page_mask = 0;",
          "709:    if (!vma || check_vma_flags(vma, gup_flags)) {",
          "710:     ret = -EFAULT;",
          "711:     goto out;",
          "712:    }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "714:   cond_resched();",
          "716:   if (!page) {",
          "718:    ret = faultin_page(tsk, vma, start, &foll_flags,",
          "719:      nonblocking);",
          "720:    switch (ret) {",
          "721:    case 0:",
          "722:     goto retry;",
          "723:    case -EFAULT:",
          "724:    case -ENOMEM:",
          "725:    case -EHWPOISON:",
          "729:    case -ENOENT:",
          "730:     goto next_page;",
          "731:    }",
          "",
          "[Removed Lines]",
          "712:   if (unlikely(fatal_signal_pending(current)))",
          "713:    return i ? i : -ERESTARTSYS;",
          "715:   page = follow_page_mask(vma, start, foll_flags, &page_mask);",
          "717:    int ret;",
          "726:     return i ? i : ret;",
          "727:    case -EBUSY:",
          "728:     return i;",
          "",
          "[Added Lines]",
          "725:   if (unlikely(fatal_signal_pending(current))) {",
          "726:    ret = -ERESTARTSYS;",
          "727:    goto out;",
          "728:   }",
          "731:   page = follow_page_mask(vma, start, foll_flags, &ctx);",
          "738:    case -EBUSY:",
          "739:     ret = 0;",
          "744:     goto out;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "738:    goto next_page;",
          "739:   } else if (IS_ERR(page)) {",
          "741:   }",
          "742:   if (pages) {",
          "743:    pages[i] = page;",
          "744:    flush_anon_page(vma, page, start);",
          "745:    flush_dcache_page(page);",
          "747:   }",
          "748: next_page:",
          "749:   if (vmas) {",
          "750:    vmas[i] = vma;",
          "752:   }",
          "754:   if (page_increm > nr_pages)",
          "755:    page_increm = nr_pages;",
          "756:   i += page_increm;",
          "757:   start += page_increm * PAGE_SIZE;",
          "758:   nr_pages -= page_increm;",
          "759:  } while (nr_pages);",
          "761: }",
          "763: static bool vma_permits_fault(struct vm_area_struct *vma,",
          "",
          "[Removed Lines]",
          "740:    return i ? i : PTR_ERR(page);",
          "746:    page_mask = 0;",
          "751:    page_mask = 0;",
          "753:   page_increm = 1 + (~(start >> PAGE_SHIFT) & page_mask);",
          "760:  return i;",
          "",
          "[Added Lines]",
          "756:    ret = PTR_ERR(page);",
          "757:    goto out;",
          "763:    ctx.page_mask = 0;",
          "768:    ctx.page_mask = 0;",
          "770:   page_increm = 1 + (~(start >> PAGE_SHIFT) & ctx.page_mask);",
          "777: out:",
          "778:  if (ctx.pgmap)",
          "779:   put_dev_pagemap(ctx.pgmap);",
          "780:  return i ? i : ret;",
          "",
          "---------------"
        ],
        "mm/huge_memory.c||mm/huge_memory.c": [
          "File: mm/huge_memory.c -> mm/huge_memory.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "852: }",
          "854: struct page *follow_devmap_pmd(struct vm_area_struct *vma, unsigned long addr,",
          "856: {",
          "857:  unsigned long pfn = pmd_pfn(*pmd);",
          "858:  struct mm_struct *mm = vma->vm_mm;",
          "860:  struct page *page;",
          "862:  assert_spin_locked(pmd_lockptr(mm, pmd));",
          "",
          "[Removed Lines]",
          "855:   pmd_t *pmd, int flags)",
          "859:  struct dev_pagemap *pgmap;",
          "",
          "[Added Lines]",
          "855:   pmd_t *pmd, int flags, struct dev_pagemap **pgmap)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "886:   return ERR_PTR(-EEXIST);",
          "888:  pfn += (addr & ~PMD_MASK) >> PAGE_SHIFT;",
          "891:   return ERR_PTR(-EFAULT);",
          "892:  page = pfn_to_page(pfn);",
          "893:  get_page(page);",
          "896:  return page;",
          "897: }",
          "",
          "[Removed Lines]",
          "889:  pgmap = get_dev_pagemap(pfn, NULL);",
          "890:  if (!pgmap)",
          "894:  put_dev_pagemap(pgmap);",
          "",
          "[Added Lines]",
          "889:  if (!*pgmap)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1000: }",
          "1002: struct page *follow_devmap_pud(struct vm_area_struct *vma, unsigned long addr,",
          "1004: {",
          "1005:  unsigned long pfn = pud_pfn(*pud);",
          "1006:  struct mm_struct *mm = vma->vm_mm;",
          "1008:  struct page *page;",
          "1010:  assert_spin_locked(pud_lockptr(mm, pud));",
          "",
          "[Removed Lines]",
          "1003:   pud_t *pud, int flags)",
          "1007:  struct dev_pagemap *pgmap;",
          "",
          "[Added Lines]",
          "1001:   pud_t *pud, int flags, struct dev_pagemap **pgmap)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1028:   return ERR_PTR(-EEXIST);",
          "1030:  pfn += (addr & ~PUD_MASK) >> PAGE_SHIFT;",
          "1033:   return ERR_PTR(-EFAULT);",
          "1034:  page = pfn_to_page(pfn);",
          "1035:  get_page(page);",
          "1038:  return page;",
          "1039: }",
          "",
          "[Removed Lines]",
          "1031:  pgmap = get_dev_pagemap(pfn, NULL);",
          "1032:  if (!pgmap)",
          "1036:  put_dev_pagemap(pgmap);",
          "",
          "[Added Lines]",
          "1029:  if (!*pgmap)",
          "",
          "---------------"
        ],
        "mm/nommu.c||mm/nommu.c": [
          "File: mm/nommu.c -> mm/nommu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1709:  return ret;",
          "1710: }",
          "1715: {",
          "1717:  return NULL;",
          "1718: }",
          "",
          "[Removed Lines]",
          "1712: struct page *follow_page_mask(struct vm_area_struct *vma,",
          "1713:          unsigned long address, unsigned int flags,",
          "1714:          unsigned int *page_mask)",
          "",
          "[Added Lines]",
          "1712: struct page *follow_page(struct vm_area_struct *vma, unsigned long address,",
          "1713:     unsigned int foll_flags)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-10129",
  "cve_desc": "The Git Smart Protocol support in libgit2 before 0.24.6 and 0.25.x before 0.25.1 allows remote attackers to cause a denial of service (NULL pointer dereference) via an empty packet line.",
  "repo": "libgit2/libgit2",
  "patch_hash": "84d30d569ada986f3eef527cbdb932643c2dd037",
  "patch_info": {
    "commit_hash": "84d30d569ada986f3eef527cbdb932643c2dd037",
    "repo": "libgit2/libgit2",
    "commit_url": "https://github.com/libgit2/libgit2/commit/84d30d569ada986f3eef527cbdb932643c2dd037",
    "files": [
      "src/transports/smart_pkt.c",
      "src/transports/smart_protocol.c"
    ],
    "message": "smart_pkt: treat empty packet lines as error\n\nThe Git protocol does not specify what should happen in the case\nof an empty packet line (that is a packet line \"0004\"). We\ncurrently indicate success, but do not return a packet in the\ncase where we hit an empty line. The smart protocol was not\nprepared to handle such packets in all cases, though, resulting\nin a `NULL` pointer dereference.\n\nFix the issue by returning an error instead. As such kind of\npackets is not even specified by upstream, this is the right\nthing to do.",
    "before_after_code_files": [
      "src/transports/smart_pkt.c||src/transports/smart_pkt.c",
      "src/transports/smart_protocol.c||src/transports/smart_protocol.c"
    ]
  },
  "patch_diff": {
    "src/transports/smart_pkt.c||src/transports/smart_pkt.c": [
      "File: src/transports/smart_pkt.c -> src/transports/smart_pkt.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "438:  line += PKT_LEN_SIZE;",
      "443:  if (len == PKT_LEN_SIZE) {",
      "447:  }",
      "",
      "[Removed Lines]",
      "446:   return 0;",
      "",
      "[Added Lines]",
      "445:   giterr_set_str(GITERR_NET, \"Invalid empty packet\");",
      "446:   return GIT_ERROR;",
      "",
      "---------------"
    ],
    "src/transports/smart_protocol.c||src/transports/smart_protocol.c": [
      "File: src/transports/smart_protocol.c -> src/transports/smart_protocol.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "759:   line_len -= (line_end - line);",
      "760:   line = line_end;",
      "770:   error = add_push_report_pkt(push, pkt);",
      "772:   git_pkt_free(pkt);",
      "",
      "[Removed Lines]",
      "767:   if (pkt == NULL)",
      "768:    continue;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "822:   error = 0;",
      "827:   switch (pkt->type) {",
      "828:    case GIT_PKT_DATA:",
      "",
      "[Removed Lines]",
      "824:   if (pkt == NULL)",
      "825:    continue;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4ac39c76c0153d1ee6889a0984c39e97731684b2",
      "candidate_info": {
        "commit_hash": "4ac39c76c0153d1ee6889a0984c39e97731684b2",
        "repo": "libgit2/libgit2",
        "commit_url": "https://github.com/libgit2/libgit2/commit/4ac39c76c0153d1ee6889a0984c39e97731684b2",
        "files": [
          "src/transports/smart_pkt.c"
        ],
        "message": "smart_pkt: verify packet length exceeds PKT_LEN_SIZE\n\nEach packet line in the Git protocol is prefixed by a four-byte\nlength of how much data will follow, which we parse in\n`git_pkt_parse_line`. The transmitted length can either be equal\nto zero in case of a flush packet or has to be at least of length\nfour, as it also includes the encoded length itself. Not\nchecking this may result in a buffer overflow as we directly pass\nthe length to functions which accept a `size_t` length as\nparameter.\n\nFix the issue by verifying that non-flush packets have at least a\nlength of `PKT_LEN_SIZE`.",
        "before_after_code_files": [
          "src/transports/smart_pkt.c||src/transports/smart_pkt.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libgit2/libgit2/pull/4075"
        ],
        "olp_code_files": {
          "patch": [
            "src/transports/smart_pkt.c||src/transports/smart_pkt.c"
          ],
          "candidate": [
            "src/transports/smart_pkt.c||src/transports/smart_pkt.c"
          ]
        }
      },
      "candidate_diff": {
        "src/transports/smart_pkt.c||src/transports/smart_pkt.c": [
          "File: src/transports/smart_pkt.c -> src/transports/smart_pkt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "427:  if (bufflen > 0 && bufflen < (size_t)len)",
          "428:   return GIT_EBUFS;",
          "430:  line += PKT_LEN_SIZE;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "435:  if (len != 0 && len < PKT_LEN_SIZE)",
          "436:   return GIT_ERROR;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1a7096043645da9f44dad15a51a8034f3e716b5b",
      "candidate_info": {
        "commit_hash": "1a7096043645da9f44dad15a51a8034f3e716b5b",
        "repo": "libgit2/libgit2",
        "commit_url": "https://github.com/libgit2/libgit2/commit/1a7096043645da9f44dad15a51a8034f3e716b5b",
        "files": [
          "src/transports/smart_pkt.c",
          "src/transports/smart_protocol.c"
        ],
        "message": "transports: smart: fix potential invalid memory dereferences\n\nWhen we receive a packet of exactly four bytes encoding its\nlength as those four bytes it can be treated as an empty line.\nWhile it is not really specified how those empty lines should be\ntreated, we currently ignore them and do not return an error when\ntrying to parse it but simply advance the data pointer.\n\nCallers invoking `git_pkt_parse_line` are currently not prepared\nto handle this case as they do not explicitly check this case.\nWhile they could always reset the passed out-pointer to `NULL`\nbefore calling `git_pkt_parse_line` and determine if the pointer\nhas been set afterwards, it makes more sense to update\n`git_pkt_parse_line` to set the out-pointer to `NULL` itself when\nit encounters such an empty packet. Like this it is guaranteed\nthat there will be no invalid memory references to free'd\npointers.\n\nAs such, the issue has been fixed such that `git_pkt_parse_line`\nalways sets the packet out pointer to `NULL` when an empty packet\nhas been received and callers check for this condition, skipping\nsuch packets.",
        "before_after_code_files": [
          "src/transports/smart_pkt.c||src/transports/smart_pkt.c",
          "src/transports/smart_protocol.c||src/transports/smart_protocol.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/transports/smart_pkt.c||src/transports/smart_pkt.c",
            "src/transports/smart_protocol.c||src/transports/smart_protocol.c"
          ],
          "candidate": [
            "src/transports/smart_pkt.c||src/transports/smart_pkt.c",
            "src/transports/smart_protocol.c||src/transports/smart_protocol.c"
          ]
        }
      },
      "candidate_diff": {
        "src/transports/smart_pkt.c||src/transports/smart_pkt.c": [
          "File: src/transports/smart_pkt.c -> src/transports/smart_pkt.c"
        ],
        "src/transports/smart_protocol.c||src/transports/smart_protocol.c": [
          "File: src/transports/smart_protocol.c -> src/transports/smart_protocol.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "759:   line_len -= (line_end - line);",
          "760:   line = line_end;",
          "762:   error = add_push_report_pkt(push, pkt);",
          "764:   git_pkt_free(pkt);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "767:   if (pkt == NULL)",
          "768:    continue;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "814:   error = 0;",
          "816:   switch (pkt->type) {",
          "817:    case GIT_PKT_DATA:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "824:   if (pkt == NULL)",
          "825:    continue;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9ee498e8006b02975c48d850a138ddb50af43717",
      "candidate_info": {
        "commit_hash": "9ee498e8006b02975c48d850a138ddb50af43717",
        "repo": "libgit2/libgit2",
        "commit_url": "https://github.com/libgit2/libgit2/commit/9ee498e8006b02975c48d850a138ddb50af43717",
        "files": [
          "src/transports/smart_protocol.c"
        ],
        "message": "Only buffer if necessary.",
        "before_after_code_files": [
          "src/transports/smart_protocol.c||src/transports/smart_protocol.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/transports/smart_protocol.c||src/transports/smart_protocol.c"
          ],
          "candidate": [
            "src/transports/smart_protocol.c||src/transports/smart_protocol.c"
          ]
        }
      },
      "candidate_diff": {
        "src/transports/smart_protocol.c||src/transports/smart_protocol.c": [
          "File: src/transports/smart_protocol.c -> src/transports/smart_protocol.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "721:  return 0;",
          "722: }",
          "725: {",
          "726:  git_pkt *pkt;",
          "728:  int error;",
          "739:   error = add_push_report_pkt(push, pkt);",
          "741:   git_pkt_free(pkt);",
          "743:   if (error < 0 && error != GIT_ITEROVER)",
          "745:  }",
          "748: }",
          "750: static int parse_report(transport_smart *transport, git_push *push)",
          "",
          "[Removed Lines]",
          "724: static int add_push_report_sideband_pkt(git_push *push, git_buf *data_pkt_buf)",
          "727:  const char *line_end;",
          "730:  while (data_pkt_buf->size > 0) {",
          "731:   error = git_pkt_parse_line(&pkt, data_pkt_buf->ptr, &line_end, data_pkt_buf->size);",
          "733:   if (error < 0)",
          "734:    return error;",
          "737:   git_buf_consume(data_pkt_buf, line_end);",
          "744:    return error;",
          "747:  return 0;",
          "",
          "[Added Lines]",
          "724: static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)",
          "727:  const char *line, *line_end;",
          "728:  size_t line_len;",
          "730:  int reading_from_buf = data_pkt_buf->size > 0;",
          "732:  if (reading_from_buf) {",
          "735:   git_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);",
          "736:   line = data_pkt_buf->ptr;",
          "737:   line_len = data_pkt_buf->size;",
          "738:  }",
          "739:  else {",
          "740:   line = data_pkt->data;",
          "741:   line_len = data_pkt->len;",
          "742:  }",
          "744:  while (line_len > 0) {",
          "745:   error = git_pkt_parse_line(&pkt, line, &line_end, line_len);",
          "747:   if (error == GIT_EBUFS) {",
          "750:    if (!reading_from_buf)",
          "751:     git_buf_put(data_pkt_buf, line, line_len);",
          "752:    error = 0;",
          "753:    goto done;",
          "754:   }",
          "755:   else if (error < 0)",
          "756:    goto done;",
          "759:   line_len -= (line_end - line);",
          "760:   line = line_end;",
          "767:    goto done;",
          "770:  error = 0;",
          "772: done:",
          "773:  if (reading_from_buf)",
          "774:   git_buf_consume(data_pkt_buf, line_end);",
          "775:  return error;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "754:  gitno_buffer *buf = &transport->buffer;",
          "755:  int error, recvd;",
          "756:  git_buf data_pkt_buf = GIT_BUF_INIT;",
          "759:  for (;;) {",
          "760:   if (buf->offset > 0)",
          "",
          "[Removed Lines]",
          "757:  git_pkt_data *data_pkt;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "789:   switch (pkt->type) {",
          "790:    case GIT_PKT_DATA:",
          "799:     break;",
          "800:    case GIT_PKT_ERR:",
          "801:     giterr_set(GITERR_NET, \"report-status: Error reported: %s\",",
          "",
          "[Removed Lines]",
          "794:     data_pkt = (git_pkt_data *)pkt;",
          "795:     git_buf_put(&data_pkt_buf, data_pkt->data, data_pkt->len);",
          "796:     error = add_push_report_sideband_pkt(push, &data_pkt_buf);",
          "797:     if (error == GIT_EBUFS)",
          "798:      error = 0;",
          "",
          "[Added Lines]",
          "819:     error = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2fdef641fd0dd2828bd948234ae86de75221a11a",
      "candidate_info": {
        "commit_hash": "2fdef641fd0dd2828bd948234ae86de75221a11a",
        "repo": "libgit2/libgit2",
        "commit_url": "https://github.com/libgit2/libgit2/commit/2fdef641fd0dd2828bd948234ae86de75221a11a",
        "files": [
          "src/transports/smart_pkt.c",
          "src/transports/smart_protocol.c"
        ],
        "message": "smart_pkt: treat empty packet lines as error\n\nThe Git protocol does not specify what should happen in the case\nof an empty packet line (that is a packet line \"0004\"). We\ncurrently indicate success, but do not return a packet in the\ncase where we hit an empty line. The smart protocol was not\nprepared to handle such packets in all cases, though, resulting\nin a `NULL` pointer dereference.\n\nFix the issue by returning an error instead. As such kind of\npackets is not even specified by upstream, this is the right\nthing to do.",
        "before_after_code_files": [
          "src/transports/smart_pkt.c||src/transports/smart_pkt.c",
          "src/transports/smart_protocol.c||src/transports/smart_protocol.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/transports/smart_pkt.c||src/transports/smart_pkt.c",
            "src/transports/smart_protocol.c||src/transports/smart_protocol.c"
          ],
          "candidate": [
            "src/transports/smart_pkt.c||src/transports/smart_pkt.c",
            "src/transports/smart_protocol.c||src/transports/smart_protocol.c"
          ]
        }
      },
      "candidate_diff": {
        "src/transports/smart_pkt.c||src/transports/smart_pkt.c": [
          "File: src/transports/smart_pkt.c -> src/transports/smart_pkt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "438:  line += PKT_LEN_SIZE;",
          "443:  if (len == PKT_LEN_SIZE) {",
          "447:  }",
          "",
          "[Removed Lines]",
          "446:   return 0;",
          "",
          "[Added Lines]",
          "445:   giterr_set_str(GITERR_NET, \"Invalid empty packet\");",
          "446:   return GIT_ERROR;",
          "",
          "---------------"
        ],
        "src/transports/smart_protocol.c||src/transports/smart_protocol.c": [
          "File: src/transports/smart_protocol.c -> src/transports/smart_protocol.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "763:   line_len -= (line_end - line);",
          "764:   line = line_end;",
          "774:   error = add_push_report_pkt(push, pkt);",
          "776:   git_pkt_free(pkt);",
          "",
          "[Removed Lines]",
          "771:   if (pkt == NULL)",
          "772:    continue;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "826:   error = 0;",
          "831:   switch (pkt->type) {",
          "832:    case GIT_PKT_DATA:",
          "",
          "[Removed Lines]",
          "828:   if (pkt == NULL)",
          "829:    continue;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "921e3a68e26ad23d9c5b389fdc61c9591bdc4cff",
      "candidate_info": {
        "commit_hash": "921e3a68e26ad23d9c5b389fdc61c9591bdc4cff",
        "repo": "libgit2/libgit2",
        "commit_url": "https://github.com/libgit2/libgit2/commit/921e3a68e26ad23d9c5b389fdc61c9591bdc4cff",
        "files": [
          "src/transports/smart_pkt.c"
        ],
        "message": "smart_pkt: treat empty packet lines as error\n\nThe Git protocol does not specify what should happen in the case\nof an empty packet line (that is a packet line \"0004\"). We\ncurrently indicate success, but do not return a packet in the\ncase where we hit an empty line. The smart protocol was not\nprepared to handle such packets in all cases, though, resulting\nin a `NULL` pointer dereference.\n\nFix the issue by returning an error instead. As such kind of\npackets is not even specified by upstream, this is the right\nthing to do.",
        "before_after_code_files": [
          "src/transports/smart_pkt.c||src/transports/smart_pkt.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/transports/smart_pkt.c||src/transports/smart_pkt.c"
          ],
          "candidate": [
            "src/transports/smart_pkt.c||src/transports/smart_pkt.c"
          ]
        }
      },
      "candidate_diff": {
        "src/transports/smart_pkt.c||src/transports/smart_pkt.c": [
          "File: src/transports/smart_pkt.c -> src/transports/smart_pkt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "438:  line += PKT_LEN_SIZE;",
          "443:  if (len == PKT_LEN_SIZE) {",
          "446:  }",
          "",
          "[Removed Lines]",
          "445:   return 0;",
          "",
          "[Added Lines]",
          "445:   giterr_set_str(GITERR_NET, \"Invalid empty packet\");",
          "446:   return GIT_ERROR;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
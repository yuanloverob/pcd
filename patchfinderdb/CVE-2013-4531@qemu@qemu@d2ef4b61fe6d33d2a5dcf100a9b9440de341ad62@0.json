{
  "cve_id": "CVE-2013-4531",
  "cve_desc": "Buffer overflow in target-arm/machine.c in QEMU before 1.7.2 allows remote attackers to cause a denial of service and possibly execute arbitrary code via a negative value in cpreg_vmstate_array_len in a savevm image.",
  "repo": "qemu/qemu",
  "patch_hash": "d2ef4b61fe6d33d2a5dcf100a9b9440de341ad62",
  "patch_info": {
    "commit_hash": "d2ef4b61fe6d33d2a5dcf100a9b9440de341ad62",
    "repo": "qemu/qemu",
    "commit_url": "https://github.com/qemu/qemu/commit/d2ef4b61fe6d33d2a5dcf100a9b9440de341ad62",
    "files": [
      "vmstate.c"
    ],
    "message": "vmstate: fix buffer overflow in target-arm/machine.c\n\nCVE-2013-4531\n\ncpreg_vmstate_indexes is a VARRAY_INT32. A negative value for\ncpreg_vmstate_array_len will cause a buffer overflow.\n\nVMSTATE_INT32_LE was supposed to protect against this\nbut doesn't because it doesn't validate that input is\nnon-negative.\n\nFix this macro to valide the value appropriately.\n\nThe only other user of VMSTATE_INT32_LE doesn't\never use negative numbers so it doesn't care.\n\nReported-by: Anthony Liguori <anthony@codemonkey.ws>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Juan Quintela <quintela@redhat.com>",
    "before_after_code_files": [
      "vmstate.c||vmstate.c"
    ]
  },
  "patch_diff": {
    "vmstate.c||vmstate.c": [
      "File: vmstate.c -> vmstate.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "346:     int32_t loaded;",
      "347:     qemu_get_sbe32s(f, &loaded);",
      "351:         return 0;",
      "352:     }",
      "",
      "[Removed Lines]",
      "349:     if (loaded <= *cur) {",
      "",
      "[Added Lines]",
      "350:     if (loaded >= 0 && loaded <= *cur) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9c01a91c7b201bcb7de04603450c3c64a2475f69",
      "candidate_info": {
        "commit_hash": "9c01a91c7b201bcb7de04603450c3c64a2475f69",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/9c01a91c7b201bcb7de04603450c3c64a2475f69",
        "files": [
          "vmstate.c"
        ],
        "message": "vmstate: fix buffer overflow in target-arm/machine.c\n\nCVE-2013-4531\n\ncpreg_vmstate_indexes is a VARRAY_INT32. A negative value for\ncpreg_vmstate_array_len will cause a buffer overflow.\n\nVMSTATE_INT32_LE was supposed to protect against this\nbut doesn't because it doesn't validate that input is\nnon-negative.\n\nFix this macro to valide the value appropriately.\n\nThe only other user of VMSTATE_INT32_LE doesn't\never use negative numbers so it doesn't care.\n\nReported-by: Anthony Liguori <anthony@codemonkey.ws>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Juan Quintela <quintela@redhat.com>\n(cherry picked from commit d2ef4b61fe6d33d2a5dcf100a9b9440de341ad62)\nSigned-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>",
        "before_after_code_files": [
          "vmstate.c||vmstate.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "vmstate.c||vmstate.c"
          ],
          "candidate": [
            "vmstate.c||vmstate.c"
          ]
        }
      },
      "candidate_diff": {
        "vmstate.c||vmstate.c": [
          "File: vmstate.c -> vmstate.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "346:     int32_t loaded;",
          "347:     qemu_get_sbe32s(f, &loaded);",
          "351:         return 0;",
          "352:     }",
          "",
          "[Removed Lines]",
          "349:     if (loaded <= *cur) {",
          "",
          "[Added Lines]",
          "350:     if (loaded >= 0 && loaded <= *cur) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "630ebeffb4a08f85db748b6908339a60fc213cae",
      "candidate_info": {
        "commit_hash": "630ebeffb4a08f85db748b6908339a60fc213cae",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/630ebeffb4a08f85db748b6908339a60fc213cae",
        "files": [
          "savevm.c"
        ],
        "message": "vmstate: fix buffer overflow in target-arm/machine.c\n\nCVE-2013-4531\n\ncpreg_vmstate_indexes is a VARRAY_INT32. A negative value for\ncpreg_vmstate_array_len will cause a buffer overflow.\n\nVMSTATE_INT32_LE was supposed to protect against this\nbut doesn't because it doesn't validate that input is\nnon-negative.\n\nFix this macro to valide the value appropriately.\n\nThe only other user of VMSTATE_INT32_LE doesn't\never use negative numbers so it doesn't care.\n\nReported-by: Anthony Liguori <anthony@codemonkey.ws>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Juan Quintela <quintela@redhat.com>\n(cherry picked from commit d2ef4b61fe6d33d2a5dcf100a9b9440de341ad62)\n\nConflicts:\n\tvmstate.c\n\n*removed dependency on b6fcfa59 (Move VMState code to vmstate.c)\n\nSigned-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>",
        "before_after_code_files": [
          "savevm.c||savevm.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "savevm.c||savevm.c": [
          "File: savevm.c -> savevm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1120:     int32_t loaded;",
          "1121:     qemu_get_sbe32s(f, &loaded);",
          "1125:         return 0;",
          "1126:     }",
          "",
          "[Removed Lines]",
          "1123:     if (loaded <= *cur) {",
          "",
          "[Added Lines]",
          "1124:     if (loaded >= 0 && loaded <= *cur) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b6fcfa59fa6ad6d61603e701e006d4ec8f4c9d11",
      "candidate_info": {
        "commit_hash": "b6fcfa59fa6ad6d61603e701e006d4ec8f4c9d11",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/b6fcfa59fa6ad6d61603e701e006d4ec8f4c9d11",
        "files": [
          "Makefile.objs",
          "savevm.c",
          "vmstate.c"
        ],
        "message": "vmstate: Move VMState code to vmstate.c\n\nThis will allow unit tests to be written for VMState code without\npulling dependencies from the savevm code.\n\nSigned-off-by: Eduardo Habkost <ehabkost@redhat.com>\nReviewed-by: Orit Wasserman <owasserm@redhat.com>\nSigned-off-by: Juan Quintela <quintela@redhat.com>",
        "before_after_code_files": [
          "Makefile.objs||Makefile.objs",
          "savevm.c||savevm.c",
          "vmstate.c||vmstate.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "vmstate.c||vmstate.c"
          ],
          "candidate": [
            "vmstate.c||vmstate.c"
          ]
        }
      },
      "candidate_diff": {
        "Makefile.objs||Makefile.objs": [
          "File: Makefile.objs -> Makefile.objs",
          "--- Hunk 1 ---",
          "[Context before]",
          "51: common-obj-$(CONFIG_LINUX) += fsdev/",
          "53: common-obj-y += migration.o migration-tcp.o",
          "54: common-obj-$(CONFIG_RDMA) += migration-rdma.o",
          "55: common-obj-y += qemu-char.o #aio.o",
          "56: common-obj-y += block-migration.o",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "54: common-obj-y += vmstate.o",
          "",
          "---------------"
        ],
        "savevm.c||savevm.c": [
          "File: savevm.c -> savevm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: #include \"exec/memory.h\"",
          "39: #include \"qmp-commands.h\"",
          "40: #include \"trace.h\"",
          "42: #include \"qemu/iov.h\"",
          "43: #include \"block/snapshot.h\"",
          "44: #include \"block/qapi.h\"",
          "",
          "[Removed Lines]",
          "41: #include \"qemu/bitops.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1010: }",
          "1353: static int get_timer(QEMUFile *f, void *pv, size_t size)",
          "",
          "[Removed Lines]",
          "1015: static int get_bool(QEMUFile *f, void *pv, size_t size)",
          "1016: {",
          "1017:     bool *v = pv;",
          "1019:     return 0;",
          "1020: }",
          "1022: static void put_bool(QEMUFile *f, void *pv, size_t size)",
          "1023: {",
          "1024:     bool *v = pv;",
          "1025:     qemu_put_byte(f, *v);",
          "1026: }",
          "1028: const VMStateInfo vmstate_info_bool = {",
          "1029:     .name = \"bool\",",
          "1030:     .get  = get_bool,",
          "1031:     .put  = put_bool,",
          "1032: };",
          "1036: static int get_int8(QEMUFile *f, void *pv, size_t size)",
          "1037: {",
          "1038:     int8_t *v = pv;",
          "1039:     qemu_get_s8s(f, v);",
          "1040:     return 0;",
          "1041: }",
          "1043: static void put_int8(QEMUFile *f, void *pv, size_t size)",
          "1044: {",
          "1045:     int8_t *v = pv;",
          "1046:     qemu_put_s8s(f, v);",
          "1047: }",
          "1049: const VMStateInfo vmstate_info_int8 = {",
          "1050:     .name = \"int8\",",
          "1051:     .get  = get_int8,",
          "1052:     .put  = put_int8,",
          "1053: };",
          "1057: static int get_int16(QEMUFile *f, void *pv, size_t size)",
          "1058: {",
          "1059:     int16_t *v = pv;",
          "1060:     qemu_get_sbe16s(f, v);",
          "1061:     return 0;",
          "1062: }",
          "1064: static void put_int16(QEMUFile *f, void *pv, size_t size)",
          "1065: {",
          "1066:     int16_t *v = pv;",
          "1067:     qemu_put_sbe16s(f, v);",
          "1068: }",
          "1070: const VMStateInfo vmstate_info_int16 = {",
          "1071:     .name = \"int16\",",
          "1072:     .get  = get_int16,",
          "1073:     .put  = put_int16,",
          "1074: };",
          "1078: static int get_int32(QEMUFile *f, void *pv, size_t size)",
          "1079: {",
          "1080:     int32_t *v = pv;",
          "1081:     qemu_get_sbe32s(f, v);",
          "1082:     return 0;",
          "1083: }",
          "1085: static void put_int32(QEMUFile *f, void *pv, size_t size)",
          "1086: {",
          "1087:     int32_t *v = pv;",
          "1088:     qemu_put_sbe32s(f, v);",
          "1089: }",
          "1091: const VMStateInfo vmstate_info_int32 = {",
          "1092:     .name = \"int32\",",
          "1093:     .get  = get_int32,",
          "1094:     .put  = put_int32,",
          "1095: };",
          "1100: static int get_int32_equal(QEMUFile *f, void *pv, size_t size)",
          "1101: {",
          "1102:     int32_t *v = pv;",
          "1103:     int32_t v2;",
          "1104:     qemu_get_sbe32s(f, &v2);",
          "1106:     if (*v == v2) {",
          "1107:         return 0;",
          "1108:     }",
          "1109:     return -EINVAL;",
          "1110: }",
          "1112: const VMStateInfo vmstate_info_int32_equal = {",
          "1113:     .name = \"int32 equal\",",
          "1114:     .get  = get_int32_equal,",
          "1115:     .put  = put_int32,",
          "1116: };",
          "1121: static int get_int32_le(QEMUFile *f, void *pv, size_t size)",
          "1122: {",
          "1123:     int32_t *old = pv;",
          "1124:     int32_t new;",
          "1125:     qemu_get_sbe32s(f, &new);",
          "1127:     if (*old <= new) {",
          "1128:         return 0;",
          "1129:     }",
          "1130:     return -EINVAL;",
          "1131: }",
          "1133: const VMStateInfo vmstate_info_int32_le = {",
          "1134:     .name = \"int32 equal\",",
          "1135:     .get  = get_int32_le,",
          "1136:     .put  = put_int32,",
          "1137: };",
          "1141: static int get_int64(QEMUFile *f, void *pv, size_t size)",
          "1142: {",
          "1143:     int64_t *v = pv;",
          "1144:     qemu_get_sbe64s(f, v);",
          "1145:     return 0;",
          "1146: }",
          "1148: static void put_int64(QEMUFile *f, void *pv, size_t size)",
          "1149: {",
          "1150:     int64_t *v = pv;",
          "1151:     qemu_put_sbe64s(f, v);",
          "1152: }",
          "1154: const VMStateInfo vmstate_info_int64 = {",
          "1155:     .name = \"int64\",",
          "1156:     .get  = get_int64,",
          "1157:     .put  = put_int64,",
          "1158: };",
          "1162: static int get_uint8(QEMUFile *f, void *pv, size_t size)",
          "1163: {",
          "1164:     uint8_t *v = pv;",
          "1165:     qemu_get_8s(f, v);",
          "1166:     return 0;",
          "1167: }",
          "1169: static void put_uint8(QEMUFile *f, void *pv, size_t size)",
          "1170: {",
          "1171:     uint8_t *v = pv;",
          "1172:     qemu_put_8s(f, v);",
          "1173: }",
          "1175: const VMStateInfo vmstate_info_uint8 = {",
          "1176:     .name = \"uint8\",",
          "1177:     .get  = get_uint8,",
          "1178:     .put  = put_uint8,",
          "1179: };",
          "1183: static int get_uint16(QEMUFile *f, void *pv, size_t size)",
          "1184: {",
          "1185:     uint16_t *v = pv;",
          "1186:     qemu_get_be16s(f, v);",
          "1187:     return 0;",
          "1188: }",
          "1190: static void put_uint16(QEMUFile *f, void *pv, size_t size)",
          "1191: {",
          "1192:     uint16_t *v = pv;",
          "1193:     qemu_put_be16s(f, v);",
          "1194: }",
          "1196: const VMStateInfo vmstate_info_uint16 = {",
          "1197:     .name = \"uint16\",",
          "1198:     .get  = get_uint16,",
          "1199:     .put  = put_uint16,",
          "1200: };",
          "1204: static int get_uint32(QEMUFile *f, void *pv, size_t size)",
          "1205: {",
          "1206:     uint32_t *v = pv;",
          "1207:     qemu_get_be32s(f, v);",
          "1208:     return 0;",
          "1209: }",
          "1211: static void put_uint32(QEMUFile *f, void *pv, size_t size)",
          "1212: {",
          "1213:     uint32_t *v = pv;",
          "1214:     qemu_put_be32s(f, v);",
          "1215: }",
          "1217: const VMStateInfo vmstate_info_uint32 = {",
          "1218:     .name = \"uint32\",",
          "1219:     .get  = get_uint32,",
          "1220:     .put  = put_uint32,",
          "1221: };",
          "1226: static int get_uint32_equal(QEMUFile *f, void *pv, size_t size)",
          "1227: {",
          "1228:     uint32_t *v = pv;",
          "1229:     uint32_t v2;",
          "1230:     qemu_get_be32s(f, &v2);",
          "1232:     if (*v == v2) {",
          "1233:         return 0;",
          "1234:     }",
          "1235:     return -EINVAL;",
          "1236: }",
          "1238: const VMStateInfo vmstate_info_uint32_equal = {",
          "1239:     .name = \"uint32 equal\",",
          "1240:     .get  = get_uint32_equal,",
          "1241:     .put  = put_uint32,",
          "1242: };",
          "1246: static int get_uint64(QEMUFile *f, void *pv, size_t size)",
          "1247: {",
          "1248:     uint64_t *v = pv;",
          "1249:     qemu_get_be64s(f, v);",
          "1250:     return 0;",
          "1251: }",
          "1253: static void put_uint64(QEMUFile *f, void *pv, size_t size)",
          "1254: {",
          "1255:     uint64_t *v = pv;",
          "1256:     qemu_put_be64s(f, v);",
          "1257: }",
          "1259: const VMStateInfo vmstate_info_uint64 = {",
          "1260:     .name = \"uint64\",",
          "1261:     .get  = get_uint64,",
          "1262:     .put  = put_uint64,",
          "1263: };",
          "1268: static int get_uint64_equal(QEMUFile *f, void *pv, size_t size)",
          "1269: {",
          "1270:     uint64_t *v = pv;",
          "1271:     uint64_t v2;",
          "1272:     qemu_get_be64s(f, &v2);",
          "1274:     if (*v == v2) {",
          "1275:         return 0;",
          "1276:     }",
          "1277:     return -EINVAL;",
          "1278: }",
          "1280: const VMStateInfo vmstate_info_uint64_equal = {",
          "1281:     .name = \"int64 equal\",",
          "1282:     .get  = get_uint64_equal,",
          "1283:     .put  = put_uint64,",
          "1284: };",
          "1289: static int get_uint8_equal(QEMUFile *f, void *pv, size_t size)",
          "1290: {",
          "1291:     uint8_t *v = pv;",
          "1292:     uint8_t v2;",
          "1293:     qemu_get_8s(f, &v2);",
          "1295:     if (*v == v2) {",
          "1296:         return 0;",
          "1297:     }",
          "1298:     return -EINVAL;",
          "1299: }",
          "1301: const VMStateInfo vmstate_info_uint8_equal = {",
          "1302:     .name = \"uint8 equal\",",
          "1303:     .get  = get_uint8_equal,",
          "1304:     .put  = put_uint8,",
          "1305: };",
          "1310: static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)",
          "1311: {",
          "1312:     uint16_t *v = pv;",
          "1313:     uint16_t v2;",
          "1314:     qemu_get_be16s(f, &v2);",
          "1316:     if (*v == v2) {",
          "1317:         return 0;",
          "1318:     }",
          "1319:     return -EINVAL;",
          "1320: }",
          "1322: const VMStateInfo vmstate_info_uint16_equal = {",
          "1323:     .name = \"uint16 equal\",",
          "1324:     .get  = get_uint16_equal,",
          "1325:     .put  = put_uint16,",
          "1326: };",
          "1330: static int get_float64(QEMUFile *f, void *pv, size_t size)",
          "1331: {",
          "1332:     float64 *v = pv;",
          "1335:     return 0;",
          "1336: }",
          "1338: static void put_float64(QEMUFile *f, void *pv, size_t size)",
          "1339: {",
          "1340:     uint64_t *v = pv;",
          "1342:     qemu_put_be64(f, float64_val(*v));",
          "1343: }",
          "1345: const VMStateInfo vmstate_info_float64 = {",
          "1346:     .name = \"float64\",",
          "1347:     .get  = get_float64,",
          "1348:     .put  = put_float64,",
          "1349: };",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1369:     .put  = put_timer,",
          "1370: };",
          "1467: typedef struct CompatEntry {",
          "1468:     char idstr[256];",
          "",
          "[Removed Lines]",
          "1374: static int get_buffer(QEMUFile *f, void *pv, size_t size)",
          "1375: {",
          "1376:     uint8_t *v = pv;",
          "1377:     qemu_get_buffer(f, v, size);",
          "1378:     return 0;",
          "1379: }",
          "1381: static void put_buffer(QEMUFile *f, void *pv, size_t size)",
          "1382: {",
          "1383:     uint8_t *v = pv;",
          "1384:     qemu_put_buffer(f, v, size);",
          "1385: }",
          "1387: const VMStateInfo vmstate_info_buffer = {",
          "1388:     .name = \"buffer\",",
          "1389:     .get  = get_buffer,",
          "1390:     .put  = put_buffer,",
          "1391: };",
          "1396: static int get_unused_buffer(QEMUFile *f, void *pv, size_t size)",
          "1397: {",
          "1398:     uint8_t buf[1024];",
          "1399:     int block_len;",
          "1401:     while (size > 0) {",
          "1402:         block_len = MIN(sizeof(buf), size);",
          "1403:         size -= block_len;",
          "1404:         qemu_get_buffer(f, buf, block_len);",
          "1405:     }",
          "1406:    return 0;",
          "1407: }",
          "1409: static void put_unused_buffer(QEMUFile *f, void *pv, size_t size)",
          "1410: {",
          "1411:     static const uint8_t buf[1024];",
          "1412:     int block_len;",
          "1414:     while (size > 0) {",
          "1415:         block_len = MIN(sizeof(buf), size);",
          "1416:         size -= block_len;",
          "1417:         qemu_put_buffer(f, buf, block_len);",
          "1418:     }",
          "1419: }",
          "1421: const VMStateInfo vmstate_info_unused_buffer = {",
          "1422:     .name = \"unused_buffer\",",
          "1423:     .get  = get_unused_buffer,",
          "1424:     .put  = put_unused_buffer,",
          "1425: };",
          "1433: #define BITS_TO_U64S(nr) DIV_ROUND_UP(nr, 64)",
          "1434: static int get_bitmap(QEMUFile *f, void *pv, size_t size)",
          "1435: {",
          "1436:     unsigned long *bmp = pv;",
          "1437:     int i, idx = 0;",
          "1438:     for (i = 0; i < BITS_TO_U64S(size); i++) {",
          "1439:         uint64_t w = qemu_get_be64(f);",
          "1440:         bmp[idx++] = w;",
          "1441:         if (sizeof(unsigned long) == 4 && idx < BITS_TO_LONGS(size)) {",
          "1442:             bmp[idx++] = w >> 32;",
          "1443:         }",
          "1444:     }",
          "1445:     return 0;",
          "1446: }",
          "1448: static void put_bitmap(QEMUFile *f, void *pv, size_t size)",
          "1449: {",
          "1450:     unsigned long *bmp = pv;",
          "1451:     int i, idx = 0;",
          "1452:     for (i = 0; i < BITS_TO_U64S(size); i++) {",
          "1453:         uint64_t w = bmp[idx++];",
          "1454:         if (sizeof(unsigned long) == 4 && idx < BITS_TO_LONGS(size)) {",
          "1455:             w |= ((uint64_t)bmp[idx++]) << 32;",
          "1456:         }",
          "1457:         qemu_put_be64(f, w);",
          "1458:     }",
          "1459: }",
          "1461: const VMStateInfo vmstate_info_bitmap = {",
          "1462:     .name = \"bitmap\",",
          "1463:     .get = get_bitmap,",
          "1464:     .put = put_bitmap,",
          "1465: };",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1676:     }",
          "1677: }",
          "1817: static int vmstate_load(QEMUFile *f, SaveStateEntry *se, int version_id)",
          "1818: {",
          "",
          "[Removed Lines]",
          "1679: static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd,",
          "1680:                                     void *opaque);",
          "1681: static int vmstate_subsection_load(QEMUFile *f, const VMStateDescription *vmsd,",
          "1682:                                    void *opaque);",
          "1684: int vmstate_load_state(QEMUFile *f, const VMStateDescription *vmsd,",
          "1685:                        void *opaque, int version_id)",
          "1686: {",
          "1687:     VMStateField *field = vmsd->fields;",
          "1688:     int ret;",
          "1690:     if (version_id > vmsd->version_id) {",
          "1691:         return -EINVAL;",
          "1692:     }",
          "1693:     if (version_id < vmsd->minimum_version_id_old) {",
          "1694:         return -EINVAL;",
          "1695:     }",
          "1696:     if  (version_id < vmsd->minimum_version_id) {",
          "1697:         return vmsd->load_state_old(f, opaque, version_id);",
          "1698:     }",
          "1699:     if (vmsd->pre_load) {",
          "1700:         int ret = vmsd->pre_load(opaque);",
          "1701:         if (ret) {",
          "1702:             return ret;",
          "1703:         }",
          "1704:     }",
          "1705:     while (field->name) {",
          "1706:         if ((field->field_exists &&",
          "1707:              field->field_exists(opaque, version_id)) ||",
          "1708:             (!field->field_exists &&",
          "1709:              field->version_id <= version_id)) {",
          "1710:             void *base_addr = opaque + field->offset;",
          "1711:             int i, n_elems = 1;",
          "1712:             int size = field->size;",
          "1714:             if (field->flags & VMS_VBUFFER) {",
          "1715:                 size = *(int32_t *)(opaque+field->size_offset);",
          "1716:                 if (field->flags & VMS_MULTIPLY) {",
          "1717:                     size *= field->size;",
          "1718:                 }",
          "1719:             }",
          "1720:             if (field->flags & VMS_ARRAY) {",
          "1721:                 n_elems = field->num;",
          "1722:             } else if (field->flags & VMS_VARRAY_INT32) {",
          "1723:                 n_elems = *(int32_t *)(opaque+field->num_offset);",
          "1724:             } else if (field->flags & VMS_VARRAY_UINT32) {",
          "1725:                 n_elems = *(uint32_t *)(opaque+field->num_offset);",
          "1726:             } else if (field->flags & VMS_VARRAY_UINT16) {",
          "1727:                 n_elems = *(uint16_t *)(opaque+field->num_offset);",
          "1728:             } else if (field->flags & VMS_VARRAY_UINT8) {",
          "1729:                 n_elems = *(uint8_t *)(opaque+field->num_offset);",
          "1730:             }",
          "1731:             if (field->flags & VMS_POINTER) {",
          "1732:                 base_addr = *(void **)base_addr + field->start;",
          "1733:             }",
          "1734:             for (i = 0; i < n_elems; i++) {",
          "1735:                 void *addr = base_addr + size * i;",
          "1737:                 if (field->flags & VMS_ARRAY_OF_POINTER) {",
          "1738:                     addr = *(void **)addr;",
          "1739:                 }",
          "1740:                 if (field->flags & VMS_STRUCT) {",
          "1741:                     ret = vmstate_load_state(f, field->vmsd, addr,",
          "1742:                                              field->vmsd->version_id);",
          "1743:                 } else {",
          "1744:                     ret = field->info->get(f, addr, size);",
          "1746:                 }",
          "1747:                 if (ret < 0) {",
          "1748:                     return ret;",
          "1749:                 }",
          "1750:             }",
          "1751:         }",
          "1752:         field++;",
          "1753:     }",
          "1754:     ret = vmstate_subsection_load(f, vmsd, opaque);",
          "1755:     if (ret != 0) {",
          "1756:         return ret;",
          "1757:     }",
          "1758:     if (vmsd->post_load) {",
          "1759:         return vmsd->post_load(opaque, version_id);",
          "1760:     }",
          "1761:     return 0;",
          "1762: }",
          "1764: void vmstate_save_state(QEMUFile *f, const VMStateDescription *vmsd,",
          "1765:                         void *opaque)",
          "1766: {",
          "1767:     VMStateField *field = vmsd->fields;",
          "1769:     if (vmsd->pre_save) {",
          "1770:         vmsd->pre_save(opaque);",
          "1771:     }",
          "1772:     while (field->name) {",
          "1773:         if (!field->field_exists ||",
          "1774:             field->field_exists(opaque, vmsd->version_id)) {",
          "1775:             void *base_addr = opaque + field->offset;",
          "1776:             int i, n_elems = 1;",
          "1777:             int size = field->size;",
          "1779:             if (field->flags & VMS_VBUFFER) {",
          "1780:                 size = *(int32_t *)(opaque+field->size_offset);",
          "1781:                 if (field->flags & VMS_MULTIPLY) {",
          "1782:                     size *= field->size;",
          "1783:                 }",
          "1784:             }",
          "1785:             if (field->flags & VMS_ARRAY) {",
          "1786:                 n_elems = field->num;",
          "1787:             } else if (field->flags & VMS_VARRAY_INT32) {",
          "1788:                 n_elems = *(int32_t *)(opaque+field->num_offset);",
          "1789:             } else if (field->flags & VMS_VARRAY_UINT32) {",
          "1790:                 n_elems = *(uint32_t *)(opaque+field->num_offset);",
          "1791:             } else if (field->flags & VMS_VARRAY_UINT16) {",
          "1792:                 n_elems = *(uint16_t *)(opaque+field->num_offset);",
          "1793:             } else if (field->flags & VMS_VARRAY_UINT8) {",
          "1794:                 n_elems = *(uint8_t *)(opaque+field->num_offset);",
          "1795:             }",
          "1796:             if (field->flags & VMS_POINTER) {",
          "1797:                 base_addr = *(void **)base_addr + field->start;",
          "1798:             }",
          "1799:             for (i = 0; i < n_elems; i++) {",
          "1800:                 void *addr = base_addr + size * i;",
          "1802:                 if (field->flags & VMS_ARRAY_OF_POINTER) {",
          "1803:                     addr = *(void **)addr;",
          "1804:                 }",
          "1805:                 if (field->flags & VMS_STRUCT) {",
          "1806:                     vmstate_save_state(f, field->vmsd, addr);",
          "1807:                 } else {",
          "1808:                     field->info->put(f, addr, size);",
          "1809:                 }",
          "1810:             }",
          "1811:         }",
          "1812:         field++;",
          "1813:     }",
          "1814:     vmstate_subsection_save(f, vmsd, opaque);",
          "1815: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2114:     return NULL;",
          "2115: }",
          "2191: typedef struct LoadStateEntry {",
          "2192:     QLIST_ENTRY(LoadStateEntry) entry;",
          "2193:     SaveStateEntry *se;",
          "",
          "[Removed Lines]",
          "2117: static const VMStateDescription *",
          "2118:     vmstate_get_subsection(const VMStateSubsection *sub, char *idstr)",
          "2119: {",
          "2120:     while (sub && sub->needed) {",
          "2121:         if (strcmp(idstr, sub->vmsd->name) == 0) {",
          "2122:             return sub->vmsd;",
          "2123:         }",
          "2124:         sub++;",
          "2125:     }",
          "2126:     return NULL;",
          "2127: }",
          "2129: static int vmstate_subsection_load(QEMUFile *f, const VMStateDescription *vmsd,",
          "2130:                                    void *opaque)",
          "2131: {",
          "2132:     while (qemu_peek_byte(f, 0) == QEMU_VM_SUBSECTION) {",
          "2133:         char idstr[256];",
          "2134:         int ret;",
          "2135:         uint8_t version_id, len, size;",
          "2136:         const VMStateDescription *sub_vmsd;",
          "2138:         len = qemu_peek_byte(f, 1);",
          "2139:         if (len < strlen(vmsd->name) + 1) {",
          "2141:             return 0;",
          "2142:         }",
          "2143:         size = qemu_peek_buffer(f, (uint8_t *)idstr, len, 2);",
          "2144:         if (size != len) {",
          "2145:             return 0;",
          "2146:         }",
          "2147:         idstr[size] = 0;",
          "2149:         if (strncmp(vmsd->name, idstr, strlen(vmsd->name)) != 0) {",
          "2151:             return 0;",
          "2152:         }",
          "2153:         sub_vmsd = vmstate_get_subsection(vmsd->subsections, idstr);",
          "2154:         if (sub_vmsd == NULL) {",
          "2155:             return -ENOENT;",
          "2156:         }",
          "2160:         version_id = qemu_get_be32(f);",
          "2162:         ret = vmstate_load_state(f, sub_vmsd, opaque, version_id);",
          "2163:         if (ret) {",
          "2164:             return ret;",
          "2165:         }",
          "2166:     }",
          "2167:     return 0;",
          "2168: }",
          "2170: static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd,",
          "2171:                                     void *opaque)",
          "2172: {",
          "2173:     const VMStateSubsection *sub = vmsd->subsections;",
          "2175:     while (sub && sub->needed) {",
          "2176:         if (sub->needed(opaque)) {",
          "2177:             const VMStateDescription *vmsd = sub->vmsd;",
          "2178:             uint8_t len;",
          "2180:             qemu_put_byte(f, QEMU_VM_SUBSECTION);",
          "2181:             len = strlen(vmsd->name);",
          "2182:             qemu_put_byte(f, len);",
          "2183:             qemu_put_buffer(f, (uint8_t *)vmsd->name, len);",
          "2184:             qemu_put_be32(f, vmsd->version_id);",
          "2185:             vmstate_save_state(f, vmsd, opaque);",
          "2186:         }",
          "2187:         sub++;",
          "2188:     }",
          "2189: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "vmstate.c||vmstate.c": [
          "File: vmstate.c -> vmstate.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include \"qemu-common.h\"",
          "2: #include \"migration/migration.h\"",
          "3: #include \"migration/qemu-file.h\"",
          "4: #include \"migration/vmstate.h\"",
          "5: #include \"qemu/bitops.h\"",
          "7: static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd,",
          "8:                                     void *opaque);",
          "9: static int vmstate_subsection_load(QEMUFile *f, const VMStateDescription *vmsd,",
          "10:                                    void *opaque);",
          "12: int vmstate_load_state(QEMUFile *f, const VMStateDescription *vmsd,",
          "13:                        void *opaque, int version_id)",
          "14: {",
          "15:     VMStateField *field = vmsd->fields;",
          "16:     int ret;",
          "18:     if (version_id > vmsd->version_id) {",
          "19:         return -EINVAL;",
          "20:     }",
          "21:     if (version_id < vmsd->minimum_version_id_old) {",
          "22:         return -EINVAL;",
          "23:     }",
          "24:     if  (version_id < vmsd->minimum_version_id) {",
          "25:         return vmsd->load_state_old(f, opaque, version_id);",
          "26:     }",
          "27:     if (vmsd->pre_load) {",
          "28:         int ret = vmsd->pre_load(opaque);",
          "29:         if (ret) {",
          "30:             return ret;",
          "31:         }",
          "32:     }",
          "33:     while (field->name) {",
          "34:         if ((field->field_exists &&",
          "35:              field->field_exists(opaque, version_id)) ||",
          "36:             (!field->field_exists &&",
          "37:              field->version_id <= version_id)) {",
          "38:             void *base_addr = opaque + field->offset;",
          "39:             int i, n_elems = 1;",
          "40:             int size = field->size;",
          "42:             if (field->flags & VMS_VBUFFER) {",
          "43:                 size = *(int32_t *)(opaque+field->size_offset);",
          "44:                 if (field->flags & VMS_MULTIPLY) {",
          "45:                     size *= field->size;",
          "46:                 }",
          "47:             }",
          "48:             if (field->flags & VMS_ARRAY) {",
          "49:                 n_elems = field->num;",
          "50:             } else if (field->flags & VMS_VARRAY_INT32) {",
          "51:                 n_elems = *(int32_t *)(opaque+field->num_offset);",
          "52:             } else if (field->flags & VMS_VARRAY_UINT32) {",
          "53:                 n_elems = *(uint32_t *)(opaque+field->num_offset);",
          "54:             } else if (field->flags & VMS_VARRAY_UINT16) {",
          "55:                 n_elems = *(uint16_t *)(opaque+field->num_offset);",
          "56:             } else if (field->flags & VMS_VARRAY_UINT8) {",
          "57:                 n_elems = *(uint8_t *)(opaque+field->num_offset);",
          "58:             }",
          "59:             if (field->flags & VMS_POINTER) {",
          "60:                 base_addr = *(void **)base_addr + field->start;",
          "61:             }",
          "62:             for (i = 0; i < n_elems; i++) {",
          "63:                 void *addr = base_addr + size * i;",
          "65:                 if (field->flags & VMS_ARRAY_OF_POINTER) {",
          "66:                     addr = *(void **)addr;",
          "67:                 }",
          "68:                 if (field->flags & VMS_STRUCT) {",
          "69:                     ret = vmstate_load_state(f, field->vmsd, addr,",
          "70:                                              field->vmsd->version_id);",
          "71:                 } else {",
          "72:                     ret = field->info->get(f, addr, size);",
          "74:                 }",
          "75:                 if (ret < 0) {",
          "76:                     return ret;",
          "77:                 }",
          "78:             }",
          "79:         }",
          "80:         field++;",
          "81:     }",
          "82:     ret = vmstate_subsection_load(f, vmsd, opaque);",
          "83:     if (ret != 0) {",
          "84:         return ret;",
          "85:     }",
          "86:     if (vmsd->post_load) {",
          "87:         return vmsd->post_load(opaque, version_id);",
          "88:     }",
          "89:     return 0;",
          "90: }",
          "92: void vmstate_save_state(QEMUFile *f, const VMStateDescription *vmsd,",
          "93:                         void *opaque)",
          "94: {",
          "95:     VMStateField *field = vmsd->fields;",
          "97:     if (vmsd->pre_save) {",
          "98:         vmsd->pre_save(opaque);",
          "99:     }",
          "100:     while (field->name) {",
          "101:         if (!field->field_exists ||",
          "102:             field->field_exists(opaque, vmsd->version_id)) {",
          "103:             void *base_addr = opaque + field->offset;",
          "104:             int i, n_elems = 1;",
          "105:             int size = field->size;",
          "107:             if (field->flags & VMS_VBUFFER) {",
          "108:                 size = *(int32_t *)(opaque+field->size_offset);",
          "109:                 if (field->flags & VMS_MULTIPLY) {",
          "110:                     size *= field->size;",
          "111:                 }",
          "112:             }",
          "113:             if (field->flags & VMS_ARRAY) {",
          "114:                 n_elems = field->num;",
          "115:             } else if (field->flags & VMS_VARRAY_INT32) {",
          "116:                 n_elems = *(int32_t *)(opaque+field->num_offset);",
          "117:             } else if (field->flags & VMS_VARRAY_UINT32) {",
          "118:                 n_elems = *(uint32_t *)(opaque+field->num_offset);",
          "119:             } else if (field->flags & VMS_VARRAY_UINT16) {",
          "120:                 n_elems = *(uint16_t *)(opaque+field->num_offset);",
          "121:             } else if (field->flags & VMS_VARRAY_UINT8) {",
          "122:                 n_elems = *(uint8_t *)(opaque+field->num_offset);",
          "123:             }",
          "124:             if (field->flags & VMS_POINTER) {",
          "125:                 base_addr = *(void **)base_addr + field->start;",
          "126:             }",
          "127:             for (i = 0; i < n_elems; i++) {",
          "128:                 void *addr = base_addr + size * i;",
          "130:                 if (field->flags & VMS_ARRAY_OF_POINTER) {",
          "131:                     addr = *(void **)addr;",
          "132:                 }",
          "133:                 if (field->flags & VMS_STRUCT) {",
          "134:                     vmstate_save_state(f, field->vmsd, addr);",
          "135:                 } else {",
          "136:                     field->info->put(f, addr, size);",
          "137:                 }",
          "138:             }",
          "139:         }",
          "140:         field++;",
          "141:     }",
          "142:     vmstate_subsection_save(f, vmsd, opaque);",
          "143: }",
          "145: static const VMStateDescription *",
          "146:     vmstate_get_subsection(const VMStateSubsection *sub, char *idstr)",
          "147: {",
          "148:     while (sub && sub->needed) {",
          "149:         if (strcmp(idstr, sub->vmsd->name) == 0) {",
          "150:             return sub->vmsd;",
          "151:         }",
          "152:         sub++;",
          "153:     }",
          "154:     return NULL;",
          "155: }",
          "157: static int vmstate_subsection_load(QEMUFile *f, const VMStateDescription *vmsd,",
          "158:                                    void *opaque)",
          "159: {",
          "160:     while (qemu_peek_byte(f, 0) == QEMU_VM_SUBSECTION) {",
          "161:         char idstr[256];",
          "162:         int ret;",
          "163:         uint8_t version_id, len, size;",
          "164:         const VMStateDescription *sub_vmsd;",
          "166:         len = qemu_peek_byte(f, 1);",
          "167:         if (len < strlen(vmsd->name) + 1) {",
          "169:             return 0;",
          "170:         }",
          "171:         size = qemu_peek_buffer(f, (uint8_t *)idstr, len, 2);",
          "172:         if (size != len) {",
          "173:             return 0;",
          "174:         }",
          "175:         idstr[size] = 0;",
          "177:         if (strncmp(vmsd->name, idstr, strlen(vmsd->name)) != 0) {",
          "179:             return 0;",
          "180:         }",
          "181:         sub_vmsd = vmstate_get_subsection(vmsd->subsections, idstr);",
          "182:         if (sub_vmsd == NULL) {",
          "183:             return -ENOENT;",
          "184:         }",
          "188:         version_id = qemu_get_be32(f);",
          "190:         ret = vmstate_load_state(f, sub_vmsd, opaque, version_id);",
          "191:         if (ret) {",
          "192:             return ret;",
          "193:         }",
          "194:     }",
          "195:     return 0;",
          "196: }",
          "198: static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd,",
          "199:                                     void *opaque)",
          "200: {",
          "201:     const VMStateSubsection *sub = vmsd->subsections;",
          "203:     while (sub && sub->needed) {",
          "204:         if (sub->needed(opaque)) {",
          "205:             const VMStateDescription *vmsd = sub->vmsd;",
          "206:             uint8_t len;",
          "208:             qemu_put_byte(f, QEMU_VM_SUBSECTION);",
          "209:             len = strlen(vmsd->name);",
          "210:             qemu_put_byte(f, len);",
          "211:             qemu_put_buffer(f, (uint8_t *)vmsd->name, len);",
          "212:             qemu_put_be32(f, vmsd->version_id);",
          "213:             vmstate_save_state(f, vmsd, opaque);",
          "214:         }",
          "215:         sub++;",
          "216:     }",
          "217: }",
          "221: static int get_bool(QEMUFile *f, void *pv, size_t size)",
          "222: {",
          "223:     bool *v = pv;",
          "225:     return 0;",
          "226: }",
          "228: static void put_bool(QEMUFile *f, void *pv, size_t size)",
          "229: {",
          "230:     bool *v = pv;",
          "231:     qemu_put_byte(f, *v);",
          "232: }",
          "234: const VMStateInfo vmstate_info_bool = {",
          "235:     .name = \"bool\",",
          "236:     .get  = get_bool,",
          "237:     .put  = put_bool,",
          "238: };",
          "242: static int get_int8(QEMUFile *f, void *pv, size_t size)",
          "243: {",
          "244:     int8_t *v = pv;",
          "245:     qemu_get_s8s(f, v);",
          "246:     return 0;",
          "247: }",
          "249: static void put_int8(QEMUFile *f, void *pv, size_t size)",
          "250: {",
          "251:     int8_t *v = pv;",
          "252:     qemu_put_s8s(f, v);",
          "253: }",
          "255: const VMStateInfo vmstate_info_int8 = {",
          "256:     .name = \"int8\",",
          "257:     .get  = get_int8,",
          "258:     .put  = put_int8,",
          "259: };",
          "263: static int get_int16(QEMUFile *f, void *pv, size_t size)",
          "264: {",
          "265:     int16_t *v = pv;",
          "266:     qemu_get_sbe16s(f, v);",
          "267:     return 0;",
          "268: }",
          "270: static void put_int16(QEMUFile *f, void *pv, size_t size)",
          "271: {",
          "272:     int16_t *v = pv;",
          "273:     qemu_put_sbe16s(f, v);",
          "274: }",
          "276: const VMStateInfo vmstate_info_int16 = {",
          "277:     .name = \"int16\",",
          "278:     .get  = get_int16,",
          "279:     .put  = put_int16,",
          "280: };",
          "284: static int get_int32(QEMUFile *f, void *pv, size_t size)",
          "285: {",
          "286:     int32_t *v = pv;",
          "287:     qemu_get_sbe32s(f, v);",
          "288:     return 0;",
          "289: }",
          "291: static void put_int32(QEMUFile *f, void *pv, size_t size)",
          "292: {",
          "293:     int32_t *v = pv;",
          "294:     qemu_put_sbe32s(f, v);",
          "295: }",
          "297: const VMStateInfo vmstate_info_int32 = {",
          "298:     .name = \"int32\",",
          "299:     .get  = get_int32,",
          "300:     .put  = put_int32,",
          "301: };",
          "306: static int get_int32_equal(QEMUFile *f, void *pv, size_t size)",
          "307: {",
          "308:     int32_t *v = pv;",
          "309:     int32_t v2;",
          "310:     qemu_get_sbe32s(f, &v2);",
          "312:     if (*v == v2) {",
          "313:         return 0;",
          "314:     }",
          "315:     return -EINVAL;",
          "316: }",
          "318: const VMStateInfo vmstate_info_int32_equal = {",
          "319:     .name = \"int32 equal\",",
          "320:     .get  = get_int32_equal,",
          "321:     .put  = put_int32,",
          "322: };",
          "327: static int get_int32_le(QEMUFile *f, void *pv, size_t size)",
          "328: {",
          "329:     int32_t *old = pv;",
          "330:     int32_t new;",
          "331:     qemu_get_sbe32s(f, &new);",
          "333:     if (*old <= new) {",
          "334:         return 0;",
          "335:     }",
          "336:     return -EINVAL;",
          "337: }",
          "339: const VMStateInfo vmstate_info_int32_le = {",
          "340:     .name = \"int32 equal\",",
          "341:     .get  = get_int32_le,",
          "342:     .put  = put_int32,",
          "343: };",
          "347: static int get_int64(QEMUFile *f, void *pv, size_t size)",
          "348: {",
          "349:     int64_t *v = pv;",
          "350:     qemu_get_sbe64s(f, v);",
          "351:     return 0;",
          "352: }",
          "354: static void put_int64(QEMUFile *f, void *pv, size_t size)",
          "355: {",
          "356:     int64_t *v = pv;",
          "357:     qemu_put_sbe64s(f, v);",
          "358: }",
          "360: const VMStateInfo vmstate_info_int64 = {",
          "361:     .name = \"int64\",",
          "362:     .get  = get_int64,",
          "363:     .put  = put_int64,",
          "364: };",
          "368: static int get_uint8(QEMUFile *f, void *pv, size_t size)",
          "369: {",
          "370:     uint8_t *v = pv;",
          "371:     qemu_get_8s(f, v);",
          "372:     return 0;",
          "373: }",
          "375: static void put_uint8(QEMUFile *f, void *pv, size_t size)",
          "376: {",
          "377:     uint8_t *v = pv;",
          "378:     qemu_put_8s(f, v);",
          "379: }",
          "381: const VMStateInfo vmstate_info_uint8 = {",
          "382:     .name = \"uint8\",",
          "383:     .get  = get_uint8,",
          "384:     .put  = put_uint8,",
          "385: };",
          "389: static int get_uint16(QEMUFile *f, void *pv, size_t size)",
          "390: {",
          "391:     uint16_t *v = pv;",
          "392:     qemu_get_be16s(f, v);",
          "393:     return 0;",
          "394: }",
          "396: static void put_uint16(QEMUFile *f, void *pv, size_t size)",
          "397: {",
          "398:     uint16_t *v = pv;",
          "399:     qemu_put_be16s(f, v);",
          "400: }",
          "402: const VMStateInfo vmstate_info_uint16 = {",
          "403:     .name = \"uint16\",",
          "404:     .get  = get_uint16,",
          "405:     .put  = put_uint16,",
          "406: };",
          "410: static int get_uint32(QEMUFile *f, void *pv, size_t size)",
          "411: {",
          "412:     uint32_t *v = pv;",
          "413:     qemu_get_be32s(f, v);",
          "414:     return 0;",
          "415: }",
          "417: static void put_uint32(QEMUFile *f, void *pv, size_t size)",
          "418: {",
          "419:     uint32_t *v = pv;",
          "420:     qemu_put_be32s(f, v);",
          "421: }",
          "423: const VMStateInfo vmstate_info_uint32 = {",
          "424:     .name = \"uint32\",",
          "425:     .get  = get_uint32,",
          "426:     .put  = put_uint32,",
          "427: };",
          "432: static int get_uint32_equal(QEMUFile *f, void *pv, size_t size)",
          "433: {",
          "434:     uint32_t *v = pv;",
          "435:     uint32_t v2;",
          "436:     qemu_get_be32s(f, &v2);",
          "438:     if (*v == v2) {",
          "439:         return 0;",
          "440:     }",
          "441:     return -EINVAL;",
          "442: }",
          "444: const VMStateInfo vmstate_info_uint32_equal = {",
          "445:     .name = \"uint32 equal\",",
          "446:     .get  = get_uint32_equal,",
          "447:     .put  = put_uint32,",
          "448: };",
          "452: static int get_uint64(QEMUFile *f, void *pv, size_t size)",
          "453: {",
          "454:     uint64_t *v = pv;",
          "455:     qemu_get_be64s(f, v);",
          "456:     return 0;",
          "457: }",
          "459: static void put_uint64(QEMUFile *f, void *pv, size_t size)",
          "460: {",
          "461:     uint64_t *v = pv;",
          "462:     qemu_put_be64s(f, v);",
          "463: }",
          "465: const VMStateInfo vmstate_info_uint64 = {",
          "466:     .name = \"uint64\",",
          "467:     .get  = get_uint64,",
          "468:     .put  = put_uint64,",
          "469: };",
          "474: static int get_uint64_equal(QEMUFile *f, void *pv, size_t size)",
          "475: {",
          "476:     uint64_t *v = pv;",
          "477:     uint64_t v2;",
          "478:     qemu_get_be64s(f, &v2);",
          "480:     if (*v == v2) {",
          "481:         return 0;",
          "482:     }",
          "483:     return -EINVAL;",
          "484: }",
          "486: const VMStateInfo vmstate_info_uint64_equal = {",
          "487:     .name = \"int64 equal\",",
          "488:     .get  = get_uint64_equal,",
          "489:     .put  = put_uint64,",
          "490: };",
          "495: static int get_uint8_equal(QEMUFile *f, void *pv, size_t size)",
          "496: {",
          "497:     uint8_t *v = pv;",
          "498:     uint8_t v2;",
          "499:     qemu_get_8s(f, &v2);",
          "501:     if (*v == v2) {",
          "502:         return 0;",
          "503:     }",
          "504:     return -EINVAL;",
          "505: }",
          "507: const VMStateInfo vmstate_info_uint8_equal = {",
          "508:     .name = \"uint8 equal\",",
          "509:     .get  = get_uint8_equal,",
          "510:     .put  = put_uint8,",
          "511: };",
          "516: static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)",
          "517: {",
          "518:     uint16_t *v = pv;",
          "519:     uint16_t v2;",
          "520:     qemu_get_be16s(f, &v2);",
          "522:     if (*v == v2) {",
          "523:         return 0;",
          "524:     }",
          "525:     return -EINVAL;",
          "526: }",
          "528: const VMStateInfo vmstate_info_uint16_equal = {",
          "529:     .name = \"uint16 equal\",",
          "530:     .get  = get_uint16_equal,",
          "531:     .put  = put_uint16,",
          "532: };",
          "536: static int get_float64(QEMUFile *f, void *pv, size_t size)",
          "537: {",
          "538:     float64 *v = pv;",
          "541:     return 0;",
          "542: }",
          "544: static void put_float64(QEMUFile *f, void *pv, size_t size)",
          "545: {",
          "546:     uint64_t *v = pv;",
          "548:     qemu_put_be64(f, float64_val(*v));",
          "549: }",
          "551: const VMStateInfo vmstate_info_float64 = {",
          "552:     .name = \"float64\",",
          "553:     .get  = get_float64,",
          "554:     .put  = put_float64,",
          "555: };",
          "559: static int get_buffer(QEMUFile *f, void *pv, size_t size)",
          "560: {",
          "561:     uint8_t *v = pv;",
          "562:     qemu_get_buffer(f, v, size);",
          "563:     return 0;",
          "564: }",
          "566: static void put_buffer(QEMUFile *f, void *pv, size_t size)",
          "567: {",
          "568:     uint8_t *v = pv;",
          "569:     qemu_put_buffer(f, v, size);",
          "570: }",
          "572: const VMStateInfo vmstate_info_buffer = {",
          "573:     .name = \"buffer\",",
          "574:     .get  = get_buffer,",
          "575:     .put  = put_buffer,",
          "576: };",
          "581: static int get_unused_buffer(QEMUFile *f, void *pv, size_t size)",
          "582: {",
          "583:     uint8_t buf[1024];",
          "584:     int block_len;",
          "586:     while (size > 0) {",
          "587:         block_len = MIN(sizeof(buf), size);",
          "588:         size -= block_len;",
          "589:         qemu_get_buffer(f, buf, block_len);",
          "590:     }",
          "591:    return 0;",
          "592: }",
          "594: static void put_unused_buffer(QEMUFile *f, void *pv, size_t size)",
          "595: {",
          "596:     static const uint8_t buf[1024];",
          "597:     int block_len;",
          "599:     while (size > 0) {",
          "600:         block_len = MIN(sizeof(buf), size);",
          "601:         size -= block_len;",
          "602:         qemu_put_buffer(f, buf, block_len);",
          "603:     }",
          "604: }",
          "606: const VMStateInfo vmstate_info_unused_buffer = {",
          "607:     .name = \"unused_buffer\",",
          "608:     .get  = get_unused_buffer,",
          "609:     .put  = put_unused_buffer,",
          "610: };",
          "618: #define BITS_TO_U64S(nr) DIV_ROUND_UP(nr, 64)",
          "619: static int get_bitmap(QEMUFile *f, void *pv, size_t size)",
          "620: {",
          "621:     unsigned long *bmp = pv;",
          "622:     int i, idx = 0;",
          "623:     for (i = 0; i < BITS_TO_U64S(size); i++) {",
          "624:         uint64_t w = qemu_get_be64(f);",
          "625:         bmp[idx++] = w;",
          "626:         if (sizeof(unsigned long) == 4 && idx < BITS_TO_LONGS(size)) {",
          "627:             bmp[idx++] = w >> 32;",
          "628:         }",
          "629:     }",
          "630:     return 0;",
          "631: }",
          "633: static void put_bitmap(QEMUFile *f, void *pv, size_t size)",
          "634: {",
          "635:     unsigned long *bmp = pv;",
          "636:     int i, idx = 0;",
          "637:     for (i = 0; i < BITS_TO_U64S(size); i++) {",
          "638:         uint64_t w = bmp[idx++];",
          "639:         if (sizeof(unsigned long) == 4 && idx < BITS_TO_LONGS(size)) {",
          "640:             w |= ((uint64_t)bmp[idx++]) << 32;",
          "641:         }",
          "642:         qemu_put_be64(f, w);",
          "643:     }",
          "644: }",
          "646: const VMStateInfo vmstate_info_bitmap = {",
          "647:     .name = \"bitmap\",",
          "648:     .get = get_bitmap,",
          "649:     .put = put_bitmap,",
          "650: };",
          "",
          "---------------"
        ]
      }
    }
  ]
}
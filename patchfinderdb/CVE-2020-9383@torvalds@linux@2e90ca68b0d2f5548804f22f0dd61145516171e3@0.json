{
  "cve_id": "CVE-2020-9383",
  "cve_desc": "An issue was discovered in the Linux kernel 3.16 through 5.5.6. set_fdc in drivers/block/floppy.c leads to a wait_til_ready out-of-bounds read because the FDC index is not checked for errors before assigning it, aka CID-2e90ca68b0d2.",
  "repo": "torvalds/linux",
  "patch_hash": "2e90ca68b0d2f5548804f22f0dd61145516171e3",
  "patch_info": {
    "commit_hash": "2e90ca68b0d2f5548804f22f0dd61145516171e3",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/2e90ca68b0d2f5548804f22f0dd61145516171e3",
    "files": [
      "drivers/block/floppy.c"
    ],
    "message": "floppy: check FDC index for errors before assigning it\n\nJordy Zomer reported a KASAN out-of-bounds read in the floppy driver in\nwait_til_ready().\n\nWhich on the face of it can't happen, since as Willy Tarreau points out,\nthe function does no particular memory access.  Except through the FDCS\nmacro, which just indexes a static allocation through teh current fdc,\nwhich is always checked against N_FDC.\n\nExcept the checking happens after we've already assigned the value.\n\nThe floppy driver is a disgrace (a lot of it going back to my original\nhorrd \"design\"), and has no real maintainer.  Nobody has the hardware,\nand nobody really cares.  But it still gets used in virtual environment\nbecause it's one of those things that everybody supports.\n\nThe whole thing should be re-written, or at least parts of it should be\nseriously cleaned up.  The 'current fdc' index, which is used by the\nFDCS macro, and which is often shadowed by a local 'fdc' variable, is a\nprime example of how not to write code.\n\nBut because nobody has the hardware or the motivation, let's just fix up\nthe immediate problem with a nasty band-aid: test the fdc index before\nactually assigning it to the static 'fdc' variable.\n\nReported-by: Jordy Zomer <jordy@simplyhacker.com>\nCc: Willy Tarreau <w@1wt.eu>\nCc: Dan Carpenter <dan.carpenter@oracle.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "drivers/block/floppy.c||drivers/block/floppy.c"
    ]
  },
  "patch_diff": {
    "drivers/block/floppy.c||drivers/block/floppy.c": [
      "File: drivers/block/floppy.c -> drivers/block/floppy.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "854: static void set_fdc(int drive)",
      "855: {",
      "856:  if (drive >= 0 && drive < N_DRIVE) {",
      "858:   current_drive = drive;",
      "859:  }",
      "861:   pr_info(\"bad fdc value\\n\");",
      "862:   return;",
      "863:  }",
      "864:  set_dor(fdc, ~0, 8);",
      "865: #if N_FDC > 1",
      "866:  set_dor(1 - fdc, ~8, 0);",
      "",
      "[Removed Lines]",
      "857:   fdc = FDC(drive);",
      "860:  if (fdc != 1 && fdc != 0) {",
      "",
      "[Added Lines]",
      "856:  unsigned int new_fdc = fdc;",
      "859:   new_fdc = FDC(drive);",
      "862:  if (new_fdc >= N_FDC) {",
      "866:  fdc = new_fdc;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ca1b409a3b8a190c13bb30ed3ad91585d434d8e2",
      "candidate_info": {
        "commit_hash": "ca1b409a3b8a190c13bb30ed3ad91585d434d8e2",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ca1b409a3b8a190c13bb30ed3ad91585d434d8e2",
        "files": [
          "drivers/block/floppy.c"
        ],
        "message": "floppy: cleanup: make set_fdc() always set current_drive and current_fd\n\nWhen called with a negative drive value, set_fdc() would stick to the\ncurrent fdc (which was assumed to reflect the current_drive's FDC). We\ndo not need this anymore as the last call place with a negative value\nwas just addressed. Let's make this function always set both current_fdc\nand current_drive so that there's no more ambiguity. A few comments\nstating this were added to a few non-obvious places.\n\nLink: https://lore.kernel.org/r/20200410101904.14652-3-w@1wt.eu\nSigned-off-by: Willy Tarreau <w@1wt.eu>\nSigned-off-by: Denis Efremov <efremov@linux.com>",
        "before_after_code_files": [
          "drivers/block/floppy.c||drivers/block/floppy.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/block/floppy.c||drivers/block/floppy.c"
          ],
          "candidate": [
            "drivers/block/floppy.c||drivers/block/floppy.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/block/floppy.c||drivers/block/floppy.c": [
          "File: drivers/block/floppy.c -> drivers/block/floppy.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "851:    drive_state[drive].track = NEED_2_RECAL;",
          "852: }",
          "855: static void set_fdc(int drive)",
          "856: {",
          "862:  }",
          "864:   pr_info(\"bad fdc value\\n\");",
          "865:   return;",
          "866:  }",
          "869: #if N_FDC > 1",
          "871: #endif",
          "876: }",
          "879: static int lock_fdc(int drive)",
          "880: {",
          "881:  if (WARN(atomic_read(&usage_count) == 0,",
          "",
          "[Removed Lines]",
          "857:  unsigned int new_fdc = current_fdc;",
          "859:  if (drive >= 0 && drive < N_DRIVE) {",
          "860:   new_fdc = FDC(drive);",
          "861:   current_drive = drive;",
          "863:  if (new_fdc >= N_FDC) {",
          "867:  current_fdc = new_fdc;",
          "868:  set_dor(current_fdc, ~0, 8);",
          "870:  set_dor(1 - current_fdc, ~8, 0);",
          "872:  if (fdc_state[current_fdc].rawcmd == 2)",
          "873:   reset_fdc_info(current_fdc, 1);",
          "874:  if (fdc_inb(current_fdc, FD_STATUS) != STATUS_READY)",
          "875:   fdc_state[current_fdc].reset = 1;",
          "",
          "[Added Lines]",
          "860:  unsigned int fdc;",
          "862:  if (drive < 0 || drive >= N_DRIVE) {",
          "863:   pr_info(\"bad drive value %d\\n\", drive);",
          "864:   return;",
          "867:  fdc = FDC(drive);",
          "868:  if (fdc >= N_FDC) {",
          "873:  set_dor(fdc, ~0, 8);",
          "875:  set_dor(1 - fdc, ~8, 0);",
          "877:  if (fdc_state[fdc].rawcmd == 2)",
          "878:   reset_fdc_info(fdc, 1);",
          "879:  if (fdc_inb(fdc, FD_STATUS) != STATUS_READY)",
          "880:   fdc_state[fdc].reset = 1;",
          "882:  current_drive = drive;",
          "883:  current_fdc = fdc;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e83995c9f84161900b80d337d6df358a7803870a",
      "candidate_info": {
        "commit_hash": "e83995c9f84161900b80d337d6df358a7803870a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e83995c9f84161900b80d337d6df358a7803870a",
        "files": [
          "drivers/block/floppy.c"
        ],
        "message": "floppy: rename the global \"fdc\" variable to \"current_fdc\"\n\nThis is done in order to remove the confusion that arises at some places\nin the code where local variables or arguments shadow the global variable.\nIt is already visible that some places are a bit awkward and iterate over\nthe global variable, for the sole reason that they used to rely on it being\nnamed \"fdc\" in order to get the correct address when using FD_DOR. These\nones are easy to spot by searching for \"for (current_fdc...\".\n\nSome more cleanup is definitely possible. For example\n\"fdc_state[current_fdc].somefield\" is used all over the code and would\nprobably be better with \"fdc_state->somefield\" with fdc_state being set\nwhen current_fdc is assigned. This would require to pass the pointer to\nthe current state instead of the current_fdc to the I/O functions.\n\nLink: https://lore.kernel.org/r/20200301195555.11154-7-w@1wt.eu\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Willy Tarreau <w@1wt.eu>\nSigned-off-by: Denis Efremov <efremov@linux.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "drivers/block/floppy.c||drivers/block/floppy.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/block/floppy.c||drivers/block/floppy.c"
          ],
          "candidate": [
            "drivers/block/floppy.c||drivers/block/floppy.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/block/floppy.c||drivers/block/floppy.c": [
          "File: drivers/block/floppy.c -> drivers/block/floppy.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "831: {",
          "832:  if (drive_params[current_drive].select_delay)",
          "833:   return;",
          "836:  drive_state[current_drive].select_date = jiffies;",
          "837: }",
          "",
          "[Removed Lines]",
          "834:  fdc_outb(fdc_state[fdc].dor & ~(0x10 << UNIT(current_drive)), fdc, FD_DOR);",
          "835:  fdc_outb(fdc_state[fdc].dor, fdc, FD_DOR);",
          "",
          "[Added Lines]",
          "834:  fdc_outb(fdc_state[current_fdc].dor & ~(0x10 << UNIT(current_drive)),",
          "835:    current_fdc, FD_DOR);",
          "836:  fdc_outb(fdc_state[current_fdc].dor, current_fdc, FD_DOR);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "844: {",
          "845:  int drive;",
          "851:  for (drive = 0; drive < N_DRIVE; drive++)",
          "853:    drive_state[drive].track = NEED_2_RECAL;",
          "854: }",
          "857: static void set_fdc(int drive)",
          "858: {",
          "861:  if (drive >= 0 && drive < N_DRIVE) {",
          "862:   new_fdc = FDC(drive);",
          "",
          "[Removed Lines]",
          "847:  fdc_state[fdc].spec1 = fdc_state[fdc].spec2 = -1;",
          "848:  fdc_state[fdc].need_configure = 1;",
          "849:  fdc_state[fdc].perp_mode = 1;",
          "850:  fdc_state[fdc].rawcmd = 0;",
          "852:   if (FDC(drive) == fdc && (mode || drive_state[drive].track != NEED_1_RECAL))",
          "859:  unsigned int new_fdc = fdc;",
          "",
          "[Added Lines]",
          "848:  fdc_state[current_fdc].spec1 = fdc_state[current_fdc].spec2 = -1;",
          "849:  fdc_state[current_fdc].need_configure = 1;",
          "850:  fdc_state[current_fdc].perp_mode = 1;",
          "851:  fdc_state[current_fdc].rawcmd = 0;",
          "853:   if (FDC(drive) == current_fdc &&",
          "854:       (mode || drive_state[drive].track != NEED_1_RECAL))",
          "861:  unsigned int new_fdc = current_fdc;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "866:   pr_info(\"bad fdc value\\n\");",
          "867:   return;",
          "868:  }",
          "871: #if N_FDC > 1",
          "873: #endif",
          "875:   reset_fdc_info(1);",
          "878: }",
          "",
          "[Removed Lines]",
          "869:  fdc = new_fdc;",
          "870:  set_dor(fdc, ~0, 8);",
          "872:  set_dor(1 - fdc, ~8, 0);",
          "874:  if (fdc_state[fdc].rawcmd == 2)",
          "876:  if (fdc_inb(fdc, FD_STATUS) != STATUS_READY)",
          "877:   fdc_state[fdc].reset = 1;",
          "",
          "[Added Lines]",
          "871:  current_fdc = new_fdc;",
          "872:  set_dor(current_fdc, ~0, 8);",
          "874:  set_dor(1 - current_fdc, ~8, 0);",
          "876:  if (fdc_state[current_fdc].rawcmd == 2)",
          "878:  if (fdc_inb(current_fdc, FD_STATUS) != STATUS_READY)",
          "879:   fdc_state[current_fdc].reset = 1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "964:   if (drive_state[drive].fd_ref == 0 || drive_params[drive].select_delay != 0)",
          "966:   set_fdc(drive);",
          "968:         (0x10 << UNIT(drive))))",
          "972:  }",
          "973:  set_fdc(saved_drive);",
          "974: }",
          "",
          "[Removed Lines]",
          "967:   if (!(set_dor(fdc, ~3, UNIT(drive) | (0x10 << UNIT(drive))) &",
          "971:    set_dor(fdc, ~(0x10 << UNIT(drive)), 0);",
          "",
          "[Added Lines]",
          "969:   if (!(set_dor(current_fdc, ~3, UNIT(drive) | (0x10 << UNIT(drive))) &",
          "973:    set_dor(current_fdc, ~(0x10 << UNIT(drive)), 0);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1039: static int fd_wait_for_completion(unsigned long expires,",
          "1040:       void (*function)(void))",
          "1041: {",
          "1043:   reset_fdc(); /* do the reset during sleep to win time",
          "",
          "[Removed Lines]",
          "1042:  if (fdc_state[fdc].reset) {",
          "",
          "[Added Lines]",
          "1044:  if (fdc_state[current_fdc].reset) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1067:    pr_cont(\"%x,\", raw_cmd->cmd[i]);",
          "1068:   pr_cont(\"\\n\");",
          "1069:   cont->done(0);",
          "1071:   return;",
          "1072:  }",
          "1073:  if (((unsigned long)raw_cmd->kernel_data) % 512) {",
          "1074:   pr_info(\"non aligned address: %p\\n\", raw_cmd->kernel_data);",
          "1075:   cont->done(0);",
          "1077:   return;",
          "1078:  }",
          "1079:  f = claim_dma_lock();",
          "",
          "[Removed Lines]",
          "1070:   fdc_state[fdc].reset = 1;",
          "1076:   fdc_state[fdc].reset = 1;",
          "",
          "[Added Lines]",
          "1072:   fdc_state[current_fdc].reset = 1;",
          "1078:   fdc_state[current_fdc].reset = 1;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1081: #ifdef fd_dma_setup",
          "1082:  if (fd_dma_setup(raw_cmd->kernel_data, raw_cmd->length,",
          "1083:     (raw_cmd->flags & FD_RAW_READ) ?",
          "1085:   release_dma_lock(f);",
          "1086:   cont->done(0);",
          "1088:   return;",
          "1089:  }",
          "1090:  release_dma_lock(f);",
          "",
          "[Removed Lines]",
          "1084:     DMA_MODE_READ : DMA_MODE_WRITE, fdc_state[fdc].address) < 0) {",
          "1087:   fdc_state[fdc].reset = 1;",
          "",
          "[Added Lines]",
          "1086:     DMA_MODE_READ : DMA_MODE_WRITE,",
          "1087:     fdc_state[current_fdc].address) < 0) {",
          "1090:   fdc_state[current_fdc].reset = 1;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1095:    DMA_MODE_READ : DMA_MODE_WRITE);",
          "1096:  fd_set_dma_addr(raw_cmd->kernel_data);",
          "1097:  fd_set_dma_count(raw_cmd->length);",
          "1099:  fd_enable_dma();",
          "1100:  release_dma_lock(f);",
          "1101: #endif",
          "",
          "[Removed Lines]",
          "1098:  virtual_dma_port = fdc_state[fdc].address;",
          "",
          "[Added Lines]",
          "1101:  virtual_dma_port = fdc_state[current_fdc].address;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1109:  int status;",
          "1110:  int counter;",
          "1113:   return -1;",
          "1114:  for (counter = 0; counter < 10000; counter++) {",
          "1116:   if (status & STATUS_READY)",
          "1117:    return status;",
          "1118:  }",
          "1119:  if (initialized) {",
          "1121:   show_floppy();",
          "1122:  }",
          "1124:  return -1;",
          "1125: }",
          "",
          "[Removed Lines]",
          "1112:  if (fdc_state[fdc].reset)",
          "1115:   status = fdc_inb(fdc, FD_STATUS);",
          "1120:   DPRINT(\"Getstatus times out (%x) on fdc %d\\n\", status, fdc);",
          "1123:  fdc_state[fdc].reset = 1;",
          "",
          "[Added Lines]",
          "1115:  if (fdc_state[current_fdc].reset)",
          "1118:   status = fdc_inb(current_fdc, FD_STATUS);",
          "1123:   DPRINT(\"Getstatus times out (%x) on fdc %d\\n\", status, current_fdc);",
          "1126:  fdc_state[current_fdc].reset = 1;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1133:   return -1;",
          "1135:  if (is_ready_state(status)) {",
          "1137:   output_log[output_log_pos].data = byte;",
          "1138:   output_log[output_log_pos].status = status;",
          "1139:   output_log[output_log_pos].jiffies = jiffies;",
          "1140:   output_log_pos = (output_log_pos + 1) % OLOGSIZE;",
          "1141:   return 0;",
          "1142:  }",
          "1144:  if (initialized) {",
          "1145:   DPRINT(\"Unable to send byte %x to FDC. Fdc=%x Status=%x\\n\",",
          "1147:   show_floppy();",
          "1148:  }",
          "1149:  return -1;",
          "",
          "[Removed Lines]",
          "1136:   fdc_outb(byte, fdc, FD_DATA);",
          "1143:  fdc_state[fdc].reset = 1;",
          "1146:          byte, fdc, status);",
          "",
          "[Added Lines]",
          "1139:   fdc_outb(byte, current_fdc, FD_DATA);",
          "1146:  fdc_state[current_fdc].reset = 1;",
          "1149:          byte, current_fdc, status);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1166:    return i;",
          "1167:   }",
          "1168:   if (status == (STATUS_DIR | STATUS_READY | STATUS_BUSY))",
          "1170:   else",
          "1171:    break;",
          "1172:  }",
          "1173:  if (initialized) {",
          "1174:   DPRINT(\"get result error. Fdc=%d Last status=%x Read bytes=%d\\n\",",
          "1176:   show_floppy();",
          "1177:  }",
          "1179:  return -1;",
          "1180: }",
          "",
          "[Removed Lines]",
          "1169:    reply_buffer[i] = fdc_inb(fdc, FD_DATA);",
          "1175:          fdc, status, i);",
          "1178:  fdc_state[fdc].reset = 1;",
          "",
          "[Added Lines]",
          "1172:    reply_buffer[i] = fdc_inb(current_fdc, FD_DATA);",
          "1178:          current_fdc, status, i);",
          "1181:  fdc_state[current_fdc].reset = 1;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1212:   default:",
          "1213:    DPRINT(\"Invalid data rate for perpendicular mode!\\n\");",
          "1214:    cont->done(0);",
          "",
          "[Removed Lines]",
          "1215:    fdc_state[fdc].reset = 1;",
          "",
          "[Added Lines]",
          "1218:    fdc_state[current_fdc].reset = 1;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1223:  } else",
          "1224:   perp_mode = 0;",
          "1227:   return;",
          "1229:   output_byte(FD_PERPENDICULAR);",
          "1230:   output_byte(perp_mode);",
          "1232:  } else if (perp_mode) {",
          "1233:   DPRINT(\"perpendicular mode not supported by this FDC.\\n\");",
          "1234:  }",
          "",
          "[Removed Lines]",
          "1226:  if (fdc_state[fdc].perp_mode == perp_mode)",
          "1228:  if (fdc_state[fdc].version >= FDC_82077_ORIG) {",
          "1231:   fdc_state[fdc].perp_mode = perp_mode;",
          "",
          "[Added Lines]",
          "1229:  if (fdc_state[current_fdc].perp_mode == perp_mode)",
          "1231:  if (fdc_state[current_fdc].version >= FDC_82077_ORIG) {",
          "1234:   fdc_state[current_fdc].perp_mode = perp_mode;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1283:  int hlt_max_code = 0x7f;",
          "1284:  int hut_max_code = 0xf;",
          "1287:   fdc_configure();",
          "1289:  }",
          "1291:  switch (raw_cmd->rate & 0x03) {",
          "",
          "[Removed Lines]",
          "1286:  if (fdc_state[fdc].need_configure && fdc_state[fdc].version >= FDC_82072A) {",
          "1288:   fdc_state[fdc].need_configure = 0;",
          "",
          "[Added Lines]",
          "1289:  if (fdc_state[current_fdc].need_configure &&",
          "1290:      fdc_state[current_fdc].version >= FDC_82072A) {",
          "1292:   fdc_state[current_fdc].need_configure = 0;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1294:   break;",
          "1295:  case 1:",
          "1296:   dtr = 300;",
          "1300:    output_byte(FD_DRIVESPEC);",
          "",
          "[Removed Lines]",
          "1297:   if (fdc_state[fdc].version >= FDC_82078) {",
          "",
          "[Added Lines]",
          "1301:   if (fdc_state[current_fdc].version >= FDC_82078) {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1309:   break;",
          "1310:  }",
          "1313:   scale_dtr = dtr;",
          "",
          "[Removed Lines]",
          "1312:  if (fdc_state[fdc].version >= FDC_82072) {",
          "",
          "[Added Lines]",
          "1316:  if (fdc_state[current_fdc].version >= FDC_82072) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1342:  spec2 = (hlt << 1) | (use_virtual_dma & 1);",
          "1347:   output_byte(FD_SPECIFY);",
          "1350:  }",
          "",
          "[Removed Lines]",
          "1345:  if (fdc_state[fdc].spec1 != spec1 || fdc_state[fdc].spec2 != spec2) {",
          "1348:   output_byte(fdc_state[fdc].spec1 = spec1);",
          "1349:   output_byte(fdc_state[fdc].spec2 = spec2);",
          "",
          "[Added Lines]",
          "1349:  if (fdc_state[current_fdc].spec1 != spec1 ||",
          "1350:      fdc_state[current_fdc].spec2 != spec2) {",
          "1353:   output_byte(fdc_state[current_fdc].spec1 = spec1);",
          "1354:   output_byte(fdc_state[current_fdc].spec2 = spec2);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1357: static int fdc_dtr(void)",
          "1358: {",
          "1361:   return 0;",
          "1372:  return fd_wait_for_completion(jiffies + 2UL * HZ / 100, floppy_ready);",
          "",
          "[Removed Lines]",
          "1360:  if ((raw_cmd->rate & 3) == fdc_state[fdc].dtr)",
          "1364:  fdc_outb(raw_cmd->rate & 3, fdc, FD_DCR);",
          "1371:  fdc_state[fdc].dtr = raw_cmd->rate & 3;",
          "",
          "[Added Lines]",
          "1365:  if ((raw_cmd->rate & 3) == fdc_state[current_fdc].dtr)",
          "1369:  fdc_outb(raw_cmd->rate & 3, current_fdc, FD_DCR);",
          "1376:  fdc_state[current_fdc].dtr = raw_cmd->rate & 3;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1425:  if (inr != 7) {",
          "1426:   DPRINT(\"-- FDC reply error\\n\");",
          "1428:   return 1;",
          "1429:  }",
          "",
          "[Removed Lines]",
          "1427:   fdc_state[fdc].reset = 1;",
          "",
          "[Added Lines]",
          "1432:   fdc_state[current_fdc].reset = 1;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1564:   output_byte(FD_GETSTATUS);",
          "1565:   output_byte(UNIT(current_drive));",
          "1566:   if (result() != 1) {",
          "1568:    return;",
          "1569:   }",
          "1570:   clear_bit(FD_VERIFY_BIT, &drive_state[current_drive].flags);",
          "",
          "[Removed Lines]",
          "1567:    fdc_state[fdc].reset = 1;",
          "",
          "[Added Lines]",
          "1572:    fdc_state[current_fdc].reset = 1;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1616:    track = raw_cmd->track - 1;",
          "1617:   else {",
          "1618:    if (drive_params[current_drive].flags & FD_SILENT_DCL_CLEAR) {",
          "1620:     blind_seek = 1;",
          "1621:     raw_cmd->flags |= FD_RAW_NEED_SEEK;",
          "1622:    }",
          "",
          "[Removed Lines]",
          "1619:     set_dor(fdc, ~(0x10 << UNIT(current_drive)), 0);",
          "",
          "[Added Lines]",
          "1624:     set_dor(current_fdc, ~(0x10 << UNIT(current_drive)), 0);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1647: {",
          "1648:  debugt(__func__, \"\");",
          "1649:  if (inr != 2)",
          "1651:  else if (reply_buffer[ST0] & ST0_ECE) {",
          "1652:   switch (drive_state[current_drive].track) {",
          "1653:   case NEED_1_RECAL:",
          "",
          "[Removed Lines]",
          "1650:   fdc_state[fdc].reset = 1;",
          "",
          "[Added Lines]",
          "1655:   fdc_state[current_fdc].reset = 1;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1716:  release_dma_lock(f);",
          "1718:  do_floppy = NULL;",
          "1721:   pr_info(\"DOR0=%x\\n\", fdc_state[0].dor);",
          "1723:   pr_info(\"handler=%ps\\n\", handler);",
          "1724:   is_alive(__func__, \"bizarre fdc\");",
          "1725:   return IRQ_NONE;",
          "1726:  }",
          "",
          "[Removed Lines]",
          "1719:  if (fdc >= N_FDC || fdc_state[fdc].address == -1) {",
          "1722:   pr_info(\"floppy interrupt on bizarre fdc %d\\n\", fdc);",
          "1728:  fdc_state[fdc].reset = 0;",
          "",
          "[Added Lines]",
          "1724:  if (current_fdc >= N_FDC || fdc_state[current_fdc].address == -1) {",
          "1727:   pr_info(\"floppy interrupt on bizarre fdc %d\\n\", current_fdc);",
          "1733:  fdc_state[current_fdc].reset = 0;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1752:     inr == 2 && max_sensei);",
          "1753:  }",
          "1754:  if (!handler) {",
          "1756:   return IRQ_NONE;",
          "1757:  }",
          "1758:  schedule_bh(handler);",
          "",
          "[Removed Lines]",
          "1755:   fdc_state[fdc].reset = 1;",
          "",
          "[Added Lines]",
          "1760:   fdc_state[current_fdc].reset = 1;",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1778: {",
          "1779:  debugt(__func__, \"\");",
          "1782:   pr_info(\"reset set in interrupt, calling %ps\\n\", cont->error);",
          "1784:  }",
          "",
          "[Removed Lines]",
          "1781:  if (fdc_state[fdc].reset) {",
          "",
          "[Added Lines]",
          "1786:  if (fdc_state[current_fdc].reset) {",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1794:  unsigned long flags;",
          "1796:  do_floppy = reset_interrupt;",
          "1798:  reset_fdc_info(0);",
          "",
          "[Removed Lines]",
          "1797:  fdc_state[fdc].reset = 0;",
          "",
          "[Added Lines]",
          "1802:  fdc_state[current_fdc].reset = 0;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1804:  fd_disable_dma();",
          "1805:  release_dma_lock(flags);",
          "1809:  else {",
          "1811:   udelay(FD_RESET_DELAY);",
          "1813:  }",
          "1814: }",
          "",
          "[Removed Lines]",
          "1807:  if (fdc_state[fdc].version >= FDC_82072A)",
          "1808:   fdc_outb(0x80 | (fdc_state[fdc].dtr & 3), fdc, FD_STATUS);",
          "1810:   fdc_outb(fdc_state[fdc].dor & ~0x04, fdc, FD_DOR);",
          "1812:   fdc_outb(fdc_state[fdc].dor, fdc, FD_DOR);",
          "",
          "[Added Lines]",
          "1812:  if (fdc_state[current_fdc].version >= FDC_82072A)",
          "1813:   fdc_outb(0x80 | (fdc_state[current_fdc].dtr & 3),",
          "1814:     current_fdc, FD_STATUS);",
          "1816:   fdc_outb(fdc_state[current_fdc].dor & ~0x04, current_fdc, FD_DOR);",
          "1818:   fdc_outb(fdc_state[current_fdc].dor, current_fdc, FD_DOR);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1836:  print_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_NONE, 16, 1,",
          "1837:          reply_buffer, resultsize, true);",
          "1840:  pr_info(\"fdc_busy=%lu\\n\", fdc_busy);",
          "1841:  if (do_floppy)",
          "1842:   pr_info(\"do_floppy=%ps\\n\", do_floppy);",
          "",
          "[Removed Lines]",
          "1839:  pr_info(\"status=%x\\n\", fdc_inb(fdc, FD_STATUS));",
          "",
          "[Added Lines]",
          "1845:  pr_info(\"status=%x\\n\", fdc_inb(current_fdc, FD_STATUS));",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1874:  if (initialized)",
          "1875:   DPRINT(\"floppy timeout called\\n\");",
          "1877:  if (cont) {",
          "1878:   cont->done(0);",
          "",
          "[Removed Lines]",
          "1876:  fdc_state[fdc].reset = 1;",
          "",
          "[Added Lines]",
          "1882:  fdc_state[current_fdc].reset = 1;",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1893:  mask = 0xfc;",
          "1894:  data = UNIT(current_drive);",
          "1895:  if (!(raw_cmd->flags & FD_RAW_NO_MOTOR)) {",
          "1897:    set_debugt();",
          "1899:    drive_state[current_drive].first_read_date = 0;",
          "",
          "[Removed Lines]",
          "1896:   if (!(fdc_state[fdc].dor & (0x10 << UNIT(current_drive)))) {",
          "",
          "[Added Lines]",
          "1902:   if (!(fdc_state[current_fdc].dor & (0x10 << UNIT(current_drive)))) {",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1901:    drive_state[current_drive].spinup_date = jiffies;",
          "1902:    data |= (0x10 << UNIT(current_drive));",
          "1903:   }",
          "1905:   mask &= ~(0x10 << UNIT(current_drive));",
          "1908:  del_timer(motor_off_timer + current_drive);",
          "1912:  return fd_wait_for_completion(drive_state[current_drive].select_date + drive_params[current_drive].select_delay,",
          "",
          "[Removed Lines]",
          "1904:  } else if (fdc_state[fdc].dor & (0x10 << UNIT(current_drive)))",
          "1909:  set_dor(fdc, mask, data);",
          "",
          "[Added Lines]",
          "1910:  } else if (fdc_state[current_fdc].dor & (0x10 << UNIT(current_drive)))",
          "1915:  set_dor(current_fdc, mask, data);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1916: static void floppy_ready(void)",
          "1917: {",
          "1919:   reset_fdc();",
          "1920:   return;",
          "1921:  }",
          "",
          "[Removed Lines]",
          "1918:  if (fdc_state[fdc].reset) {",
          "",
          "[Added Lines]",
          "1924:  if (fdc_state[current_fdc].reset) {",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "2016:   return -EINTR;",
          "2017:  }",
          "2020:   command_status = FD_COMMAND_ERROR;",
          "2021:  if (command_status == FD_COMMAND_OKAY)",
          "2022:   ret = 0;",
          "",
          "[Removed Lines]",
          "2019:  if (fdc_state[fdc].reset)",
          "",
          "[Added Lines]",
          "2025:  if (fdc_state[current_fdc].reset)",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "2085:  if (err_count > drive_params[current_drive].max_errors.abort)",
          "2086:   cont->done(0);",
          "2087:  if (err_count > drive_params[current_drive].max_errors.reset)",
          "2089:  else if (err_count > drive_params[current_drive].max_errors.recal)",
          "2090:   drive_state[current_drive].track = NEED_2_RECAL;",
          "2091: }",
          "",
          "[Removed Lines]",
          "2088:   fdc_state[fdc].reset = 1;",
          "",
          "[Added Lines]",
          "2094:   fdc_state[current_fdc].reset = 1;",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "2998:   return -EINTR;",
          "3000:  if (arg == FD_RESET_ALWAYS)",
          "3003:   cont = &reset_cont;",
          "3004:   ret = wait_til_done(reset_fdc, interruptible);",
          "3005:   if (ret == -EINTR)",
          "",
          "[Removed Lines]",
          "3001:   fdc_state[fdc].reset = 1;",
          "3002:  if (fdc_state[fdc].reset) {",
          "",
          "[Added Lines]",
          "3007:   fdc_state[current_fdc].reset = 1;",
          "3008:  if (fdc_state[current_fdc].reset) {",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "3210:  int ret2;",
          "3211:  int ret;",
          "3215:  for (drive = 0; drive < N_DRIVE; drive++) {",
          "3217:    continue;",
          "3218:   if (drive == current_drive) {",
          "3219:    if (drive_state[drive].fd_ref > 1) {",
          "3221:     break;",
          "3222:    }",
          "3223:   } else if (drive_state[drive].fd_ref) {",
          "3225:    break;",
          "3226:   }",
          "3227:  }",
          "3230:   return -EIO;",
          "3232:  ret = raw_cmd_copyin(cmd, param, &my_raw_cmd);",
          "",
          "[Removed Lines]",
          "3213:  if (fdc_state[fdc].rawcmd <= 1)",
          "3214:   fdc_state[fdc].rawcmd = 1;",
          "3216:   if (FDC(drive) != fdc)",
          "3220:     fdc_state[fdc].rawcmd = 2;",
          "3224:    fdc_state[fdc].rawcmd = 2;",
          "3229:  if (fdc_state[fdc].reset)",
          "",
          "[Added Lines]",
          "3219:  if (fdc_state[current_fdc].rawcmd <= 1)",
          "3220:   fdc_state[current_fdc].rawcmd = 1;",
          "3222:   if (FDC(drive) != current_fdc)",
          "3226:     fdc_state[current_fdc].rawcmd = 2;",
          "3230:    fdc_state[current_fdc].rawcmd = 2;",
          "3235:  if (fdc_state[current_fdc].reset)",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "3241:  debug_dcl(drive_params[current_drive].flags,",
          "3242:     \"calling disk change from raw_cmd ioctl\\n\");",
          "3245:   ret = -EIO;",
          "3247:  drive_state[current_drive].track = NO_TRACK;",
          "",
          "[Removed Lines]",
          "3244:  if (ret != -EINTR && fdc_state[fdc].reset)",
          "",
          "[Added Lines]",
          "3250:  if (ret != -EINTR && fdc_state[current_fdc].reset)",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "4297:  int r;",
          "4301:   return FDC_NONE;",
          "4302:  r = result();",
          "4303:  if (r <= 0x00)",
          "4305:  if ((r == 1) && (reply_buffer[0] == 0x80)) {",
          "4308:  }",
          "4309:  if (r != 10) {",
          "4310:   pr_info(\"FDC %d init: DUMPREGS: unexpected return of %d bytes.\\n\",",
          "4312:   return FDC_UNKNOWN;",
          "4313:  }",
          "4315:  if (!fdc_configure()) {",
          "4318:  }",
          "",
          "[Removed Lines]",
          "4300:  if (fdc_state[fdc].reset)",
          "4306:   pr_info(\"FDC %d is an 8272A\\n\", fdc);",
          "4311:    fdc, r);",
          "4316:   pr_info(\"FDC %d is an 82072\\n\", fdc);",
          "",
          "[Added Lines]",
          "4306:  if (fdc_state[current_fdc].reset)",
          "4312:   pr_info(\"FDC %d is an 8272A\\n\", current_fdc);",
          "4317:    current_fdc, r);",
          "4322:   pr_info(\"FDC %d is an 82072\\n\", current_fdc);",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "4321:  if (need_more_output() == MORE_OUTPUT) {",
          "4322:   output_byte(0);",
          "4323:  } else {",
          "4326:  }",
          "4328:  output_byte(FD_UNLOCK);",
          "4329:  r = result();",
          "4330:  if ((r == 1) && (reply_buffer[0] == 0x80)) {",
          "4332:   return FDC_82077_ORIG; /* Pre-1991 82077, doesn't know",
          "4334:  }",
          "4335:  if ((r != 1) || (reply_buffer[0] != 0x00)) {",
          "4336:   pr_info(\"FDC %d init: UNLOCK: unexpected return of %d bytes.\\n\",",
          "4338:   return FDC_UNKNOWN;",
          "4339:  }",
          "4340:  output_byte(FD_PARTID);",
          "4341:  r = result();",
          "4342:  if (r != 1) {",
          "4343:   pr_info(\"FDC %d init: PARTID: unexpected return of %d bytes.\\n\",",
          "4345:   return FDC_UNKNOWN;",
          "4346:  }",
          "4347:  if (reply_buffer[0] == 0x80) {",
          "4350:  }",
          "4351:  switch (reply_buffer[0] >> 5) {",
          "4352:  case 0x0:",
          "4355:   return FDC_82078;",
          "4356:  case 0x1:",
          "4358:   return FDC_82078;",
          "4359:  case 0x2:",
          "4361:   return FDC_S82078B;",
          "4362:  case 0x3:",
          "4364:   return FDC_87306;",
          "4365:  default:",
          "4366:   pr_info(\"FDC %d init: 82078 variant with unknown PARTID=%d.\\n\",",
          "4368:   return FDC_82078_UNKN;",
          "4369:  }",
          "",
          "[Removed Lines]",
          "4324:   pr_info(\"FDC %d is an 82072A\\n\", fdc);",
          "4331:   pr_info(\"FDC %d is a pre-1991 82077\\n\", fdc);",
          "4337:    fdc, r);",
          "4344:    fdc, r);",
          "4348:   pr_info(\"FDC %d is a post-1991 82077\\n\", fdc);",
          "4354:   pr_info(\"FDC %d is an 82078.\\n\", fdc);",
          "4357:   pr_info(\"FDC %d is a 44pin 82078\\n\", fdc);",
          "4360:   pr_info(\"FDC %d is a S82078B\\n\", fdc);",
          "4363:   pr_info(\"FDC %d is a National Semiconductor PC87306\\n\", fdc);",
          "4367:    fdc, reply_buffer[0] >> 5);",
          "",
          "[Added Lines]",
          "4330:   pr_info(\"FDC %d is an 82072A\\n\", current_fdc);",
          "4337:   pr_info(\"FDC %d is a pre-1991 82077\\n\", current_fdc);",
          "4343:    current_fdc, r);",
          "4350:    current_fdc, r);",
          "4354:   pr_info(\"FDC %d is a post-1991 82077\\n\", current_fdc);",
          "4360:   pr_info(\"FDC %d is an 82078.\\n\", current_fdc);",
          "4363:   pr_info(\"FDC %d is a 44pin 82078\\n\", current_fdc);",
          "4366:   pr_info(\"FDC %d is a S82078B\\n\", current_fdc);",
          "4369:   pr_info(\"FDC %d is a National Semiconductor PC87306\\n\", current_fdc);",
          "4373:    current_fdc, reply_buffer[0] >> 5);",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "4640:  config_types();",
          "4642:  for (i = 0; i < N_FDC; i++) {",
          "4647: #if defined(__sparc__) || defined(__mc68000__)",
          "4649: #ifdef __mc68000__",
          "4650:   if (MACH_IS_SUN3X)",
          "4651: #endif",
          "4653: #endif",
          "4654:  }",
          "",
          "[Removed Lines]",
          "4643:   fdc = i;",
          "4644:   memset(&fdc_state[fdc], 0, sizeof(*fdc_state));",
          "4645:   fdc_state[fdc].dtr = -1;",
          "4646:   fdc_state[fdc].dor = 0x4;",
          "4652:    fdc_state[fdc].version = FDC_82072A;",
          "",
          "[Added Lines]",
          "4649:   current_fdc = i;",
          "4650:   memset(&fdc_state[current_fdc], 0, sizeof(*fdc_state));",
          "4651:   fdc_state[current_fdc].dtr = -1;",
          "4652:   fdc_state[current_fdc].dor = 0x4;",
          "4658:    fdc_state[current_fdc].version = FDC_82072A;",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "4691:  msleep(10);",
          "4693:  for (i = 0; i < N_FDC; i++) {",
          "4696:   for (unit = 0; unit < 4; unit++)",
          "4699:    continue;",
          "4701:   if (user_reset_fdc(-1, FD_RESET_ALWAYS, false)) {",
          "4706:    continue;",
          "4707:   }",
          "4714:    continue;",
          "4715:   }",
          "4717:    can_use_virtual_dma = 0;",
          "4719:   have_no_fdc = 0;",
          "",
          "[Removed Lines]",
          "4694:   fdc = i;",
          "4695:   fdc_state[fdc].driver_version = FD_DRIVER_VERSION;",
          "4697:    fdc_state[fdc].track[unit] = 0;",
          "4698:   if (fdc_state[fdc].address == -1)",
          "4700:   fdc_state[fdc].rawcmd = 2;",
          "4703:    floppy_release_regions(fdc);",
          "4704:    fdc_state[fdc].address = -1;",
          "4705:    fdc_state[fdc].version = FDC_NONE;",
          "4709:   fdc_state[fdc].version = get_fdc_version();",
          "4710:   if (fdc_state[fdc].version == FDC_NONE) {",
          "4712:    floppy_release_regions(fdc);",
          "4713:    fdc_state[fdc].address = -1;",
          "4716:   if (can_use_virtual_dma == 2 && fdc_state[fdc].version < FDC_82072A)",
          "",
          "[Added Lines]",
          "4700:   current_fdc = i;",
          "4701:   fdc_state[current_fdc].driver_version = FD_DRIVER_VERSION;",
          "4703:    fdc_state[current_fdc].track[unit] = 0;",
          "4704:   if (fdc_state[current_fdc].address == -1)",
          "4706:   fdc_state[current_fdc].rawcmd = 2;",
          "4709:    floppy_release_regions(current_fdc);",
          "4710:    fdc_state[current_fdc].address = -1;",
          "4711:    fdc_state[current_fdc].version = FDC_NONE;",
          "4715:   fdc_state[current_fdc].version = get_fdc_version();",
          "4716:   if (fdc_state[current_fdc].version == FDC_NONE) {",
          "4718:    floppy_release_regions(current_fdc);",
          "4719:    fdc_state[current_fdc].address = -1;",
          "4722:   if (can_use_virtual_dma == 2 &&",
          "4723:       fdc_state[current_fdc].version < FDC_82072A)",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "4724:   user_reset_fdc(-1, FD_RESET_ALWAYS, false);",
          "4725:  }",
          "4727:  cancel_delayed_work(&fd_timeout);",
          "4728:  current_drive = 0;",
          "4729:  initialized = true;",
          "",
          "[Removed Lines]",
          "4726:  fdc = 0;",
          "",
          "[Added Lines]",
          "4733:  current_fdc = 0;",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "4875:   }",
          "4876:  }",
          "4881:     goto cleanup;",
          "4882:   }",
          "4883:  }",
          "4886:    reset_fdc_info(1);",
          "4888:   }",
          "4889:  }",
          "4901:  irqdma_allocated = 1;",
          "4902:  return 0;",
          "4903: cleanup:",
          "4904:  fd_free_irq();",
          "4905:  fd_free_dma();",
          "4908:  atomic_dec(&usage_count);",
          "4909:  return -1;",
          "4910: }",
          "",
          "[Removed Lines]",
          "4878:  for (fdc = 0; fdc < N_FDC; fdc++) {",
          "4879:   if (fdc_state[fdc].address != -1) {",
          "4880:    if (floppy_request_regions(fdc))",
          "4884:  for (fdc = 0; fdc < N_FDC; fdc++) {",
          "4885:   if (fdc_state[fdc].address != -1) {",
          "4887:    fdc_outb(fdc_state[fdc].dor, fdc, FD_DOR);",
          "4890:  fdc = 0;",
          "4893:  for (fdc = 0; fdc < N_FDC; fdc++)",
          "4894:   if (fdc_state[fdc].address != -1)",
          "4895:    fdc_outb(fdc_state[fdc].dor, fdc, FD_DOR);",
          "4900:  fdc = 0;",
          "4906:  while (--fdc >= 0)",
          "4907:   floppy_release_regions(fdc);",
          "",
          "[Added Lines]",
          "4885:  for (current_fdc = 0; current_fdc < N_FDC; current_fdc++) {",
          "4886:   if (fdc_state[current_fdc].address != -1) {",
          "4887:    if (floppy_request_regions(current_fdc))",
          "4891:  for (current_fdc = 0; current_fdc < N_FDC; current_fdc++) {",
          "4892:   if (fdc_state[current_fdc].address != -1) {",
          "4894:    fdc_outb(fdc_state[current_fdc].dor, current_fdc, FD_DOR);",
          "4897:  current_fdc = 0;",
          "4900:  for (current_fdc = 0; current_fdc < N_FDC; current_fdc++)",
          "4901:   if (fdc_state[current_fdc].address != -1)",
          "4902:    fdc_outb(fdc_state[current_fdc].dor, current_fdc, FD_DOR);",
          "4907:  current_fdc = 0;",
          "4913:  while (--current_fdc >= 0)",
          "4914:   floppy_release_regions(current_fdc);",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "4952:   pr_info(\"auxiliary floppy timer still active\\n\");",
          "4953:  if (work_pending(&floppy_work))",
          "4954:   pr_info(\"work still pending\\n\");",
          "4960: }",
          "4962: #ifdef MODULE",
          "",
          "[Removed Lines]",
          "4955:  old_fdc = fdc;",
          "4956:  for (fdc = 0; fdc < N_FDC; fdc++)",
          "4957:   if (fdc_state[fdc].address != -1)",
          "4958:    floppy_release_regions(fdc);",
          "4959:  fdc = old_fdc;",
          "",
          "[Added Lines]",
          "4962:  old_fdc = current_fdc;",
          "4963:  for (current_fdc = 0; current_fdc < N_FDC; current_fdc++)",
          "4964:   if (fdc_state[current_fdc].address != -1)",
          "4965:    floppy_release_regions(current_fdc);",
          "4966:  current_fdc = old_fdc;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
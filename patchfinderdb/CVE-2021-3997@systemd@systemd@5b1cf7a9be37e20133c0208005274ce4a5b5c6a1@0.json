{
  "cve_id": "CVE-2021-3997",
  "cve_desc": "A flaw was found in systemd. An uncontrolled recursion in systemd-tmpfiles may lead to a denial of service at boot time when too many nested directories are created in /tmp.",
  "repo": "systemd/systemd",
  "patch_hash": "5b1cf7a9be37e20133c0208005274ce4a5b5c6a1",
  "patch_info": {
    "commit_hash": "5b1cf7a9be37e20133c0208005274ce4a5b5c6a1",
    "repo": "systemd/systemd",
    "commit_url": "https://github.com/systemd/systemd/commit/5b1cf7a9be37e20133c0208005274ce4a5b5c6a1",
    "files": [
      "src/shared/rm-rf.c"
    ],
    "message": "shared/rm-rf: loop over nested directories instead of instead of recursing\n\nTo remove directory structures, we need to remove the innermost items first,\nand then recursively remove higher-level directories. We would recursively\ndescend into directories and invoke rm_rf_children and rm_rm_children_inner.\nThis is problematic when too many directories are nested.\n\nInstead, let's create a \"TODO\" queue. In the the queue, for each level we\nhold the DIR* object we were working on, and the name of the directory. This\nallows us to leave a partially-processed directory, and restart the removal\nloop one level down. When done with the inner directory, we use the name to\nunlinkat() it from the parent, and proceed with the removal of other items.\n\nBecause the nesting is increased by one level, it is best to view this patch\nwith -b/--ignore-space-change.\n\nThis fixes CVE-2021-3997, https://bugzilla.redhat.com/show_bug.cgi?id=2024639.\nThe issue was reported and patches reviewed by Qualys Team.\nMauro Matteo Cascella and Riccardo Schirone from Red Hat handled the disclosure.",
    "before_after_code_files": [
      "src/shared/rm-rf.c||src/shared/rm-rf.c"
    ]
  },
  "patch_diff": {
    "src/shared/rm-rf.c||src/shared/rm-rf.c": [
      "File: src/shared/rm-rf.c -> src/shared/rm-rf.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "116:         return 0;",
      "117: }",
      "120:                 int fd,",
      "121:                 const char *fname,",
      "122:                 int is_dir,",
      "123:                 RemoveFlags flags,",
      "126:         struct stat st;",
      "127:         int r, q = 0;",
      "",
      "[Removed Lines]",
      "119: static int rm_rf_children_inner(",
      "124:                 const struct stat *root_dev) {",
      "",
      "[Added Lines]",
      "118: static int rm_rf_inner_child(",
      "123:                 const struct stat *root_dev,",
      "124:                 bool allow_recursion) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "141:         }",
      "143:         if (is_dir) {",
      "147:                 if (root_dev && st.st_dev != root_dev->st_dev)",
      "148:                         return 0;",
      "",
      "[Removed Lines]",
      "144:                 _cleanup_close_ int subdir_fd = -1;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "169:                                 return 1;",
      "170:                 }",
      "173:                 if (subdir_fd < 0)",
      "174:                         return -errno;",
      "180:         } else if (flags & REMOVE_ONLY_DIRECTORIES)",
      "181:                 return 0;",
      "",
      "[Removed Lines]",
      "172:                 subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);",
      "178:                 q = rm_rf_children(TAKE_FD(subdir_fd), flags | REMOVE_PHYSICAL, root_dev);",
      "",
      "[Added Lines]",
      "169:                 if (!allow_recursion)",
      "170:                         return -EISDIR;",
      "172:                 int subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);",
      "178:                 q = rm_rf_children(subdir_fd, flags | REMOVE_PHYSICAL, root_dev);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "188:         return 1;",
      "189: }",
      "191: int rm_rf_children(",
      "192:                 int fd,",
      "193:                 RemoveFlags flags,",
      "194:                 const struct stat *root_dev) {",
      "197:         int ret = 0, r;",
      "248:         return ret;",
      "249: }",
      "",
      "[Removed Lines]",
      "196:         _cleanup_closedir_ DIR *d = NULL;",
      "199:         assert(fd >= 0);",
      "204:         d = fdopendir(fd);",
      "205:         if (!d) {",
      "206:                 safe_close(fd);",
      "207:                 return -errno;",
      "208:         }",
      "210:         if (!(flags & REMOVE_PHYSICAL)) {",
      "211:                 struct statfs sfs;",
      "213:                 if (fstatfs(dirfd(d), &sfs) < 0)",
      "214:                         return -errno;",
      "216:                 if (is_physical_fs(&sfs)) {",
      "221:                         _cleanup_free_ char *path = NULL;",
      "223:                         (void) fd_get_path(fd, &path);",
      "224:                         return log_error_errno(SYNTHETIC_ERRNO(EPERM),",
      "225:                                                \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",",
      "226:                                                strna(path));",
      "227:                 }",
      "228:         }",
      "230:         FOREACH_DIRENT_ALL(de, d, return -errno) {",
      "231:                 int is_dir;",
      "233:                 if (dot_or_dot_dot(de->d_name))",
      "234:                         continue;",
      "236:                 is_dir =",
      "237:                         de->d_type == DT_UNKNOWN ? -1 :",
      "238:                         de->d_type == DT_DIR;",
      "240:                 r = rm_rf_children_inner(dirfd(d), de->d_name, is_dir, flags, root_dev);",
      "241:                 if (r < 0 && r != -ENOENT && ret == 0)",
      "242:                         ret = r;",
      "243:         }",
      "245:         if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(dirfd(d)) < 0 && ret >= 0)",
      "246:                 ret = -errno;",
      "",
      "[Added Lines]",
      "191: typedef struct TodoEntry {",
      "194: } TodoEntry;",
      "196: static void free_todo_entries(TodoEntry **todos) {",
      "197:         for (TodoEntry *x = *todos; x && x->dir; x++) {",
      "198:                 closedir(x->dir);",
      "199:                 free(x->dirname);",
      "200:         }",
      "202:         freep(todos);",
      "203: }",
      "210:         _cleanup_(free_todo_entries) TodoEntry *todos = NULL;",
      "211:         size_t n_todo = 0;",
      "219:                 _cleanup_closedir_ DIR *d = NULL;",
      "221:                 if (n_todo > 0) {",
      "224:                         assert(dirname);",
      "225:                         r = unlinkat_harder(dirfd(todos[n_todo-1].dir), dirname, AT_REMOVEDIR, flags);",
      "226:                         if (r < 0 && r != -ENOENT && ret == 0)",
      "227:                                 ret = r;",
      "228:                         dirname = mfree(dirname);",
      "231:                         n_todo --;",
      "232:                         d = TAKE_PTR(todos[n_todo].dir);",
      "233:                         dirname = TAKE_PTR(todos[n_todo].dirname);",
      "235:                         assert(d);",
      "237:                         assert(fd >= 0);",
      "238:                 } else {",
      "239:         next_fd:",
      "240:                         assert(fd >= 0);",
      "241:                         d = fdopendir(fd);",
      "242:                         if (!d) {",
      "243:                                 safe_close(fd);",
      "244:                                 return -errno;",
      "245:                         }",
      "246:                         fd = dirfd(d); /* We donated the fd to fdopendir(). Let's make sure we sure we have",
      "250:                         if (!(flags & REMOVE_PHYSICAL)) {",
      "251:                                 struct statfs sfs;",
      "253:                                 if (fstatfs(fd, &sfs) < 0)",
      "254:                                         return -errno;",
      "256:                                 if (is_physical_fs(&sfs)) {",
      "261:                                         _cleanup_free_ char *path = NULL;",
      "263:                                         (void) fd_get_path(fd, &path);",
      "264:                                         return log_error_errno(SYNTHETIC_ERRNO(EPERM),",
      "265:                                                                \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",",
      "266:                                                                strna(path));",
      "267:                                 }",
      "268:                         }",
      "269:                 }",
      "271:                 FOREACH_DIRENT_ALL(de, d, return -errno) {",
      "272:                         int is_dir;",
      "274:                         if (dot_or_dot_dot(de->d_name))",
      "275:                                 continue;",
      "277:                         is_dir = de->d_type == DT_UNKNOWN ? -1 : de->d_type == DT_DIR;",
      "279:                         r = rm_rf_inner_child(fd, de->d_name, is_dir, flags, root_dev, false);",
      "280:                         if (r == -EISDIR) {",
      "283:                                  if (!GREEDY_REALLOC0(todos, n_todo + 2))",
      "284:                                          return log_oom();",
      "286:                                  _cleanup_free_ char *newdirname = strdup(de->d_name);",
      "287:                                  if (!newdirname)",
      "288:                                          return log_oom();",
      "290:                                  int newfd = openat(fd, de->d_name,",
      "291:                                                     O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);",
      "292:                                  if (newfd >= 0) {",
      "293:                                          todos[n_todo++] = (TodoEntry) { TAKE_PTR(d), TAKE_PTR(dirname) };",
      "294:                                          fd = newfd;",
      "295:                                          dirname = TAKE_PTR(newdirname);",
      "297:                                          goto next_fd;",
      "299:                                  } else if (errno != -ENOENT && ret == 0)",
      "300:                                          ret = -errno;",
      "302:                         } else if (r < 0 && r != -ENOENT && ret == 0)",
      "303:                                 ret = r;",
      "304:                 }",
      "306:                 if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(fd) < 0 && ret >= 0)",
      "307:                         ret = -errno;",
      "309:                 if (n_todo == 0)",
      "310:                         break;",
      "311:         }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "335:         if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))",
      "336:                 return -EINVAL;",
      "339: }",
      "",
      "[Removed Lines]",
      "338:         return rm_rf_children_inner(fd, name, -1, flags, NULL);",
      "",
      "[Added Lines]",
      "403:         return rm_rf_inner_child(fd, name, -1, flags, NULL, true);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6a28f8b55904c818b25e4db2e1511faac79fd471",
      "candidate_info": {
        "commit_hash": "6a28f8b55904c818b25e4db2e1511faac79fd471",
        "repo": "systemd/systemd",
        "commit_url": "https://github.com/systemd/systemd/commit/6a28f8b55904c818b25e4db2e1511faac79fd471",
        "files": [
          "src/shared/rm-rf.c"
        ],
        "message": "shared/rm-rf: loop over nested directories instead of instead of recursing\n\nTo remove directory structures, we need to remove the innermost items first,\nand then recursively remove higher-level directories. We would recursively\ndescend into directories and invoke rm_rf_children and rm_rm_children_inner.\nThis is problematic when too many directories are nested.\n\nInstead, let's create a \"TODO\" queue. In the the queue, for each level we\nhold the DIR* object we were working on, and the name of the directory. This\nallows us to leave a partially-processed directory, and restart the removal\nloop one level down. When done with the inner directory, we use the name to\nunlinkat() it from the parent, and proceed with the removal of other items.\n\nBecause the nesting is increased by one level, it is best to view this patch\nwith -b/--ignore-space-change.\n\nThis fixes CVE-2021-3997, https://bugzilla.redhat.com/show_bug.cgi?id=2024639.\nThe issue was reported and patches reviewed by Qualys Team.\nMauro Matteo Cascella and Riccardo Schirone from Red Hat handled the disclosure.\n\n(cherry picked from commit 5b1cf7a9be37e20133c0208005274ce4a5b5c6a1)\n(cherry picked from commit 911516e1614e435755814ada5fc6064fa107a105)",
        "before_after_code_files": [
          "src/shared/rm-rf.c||src/shared/rm-rf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/shared/rm-rf.c||src/shared/rm-rf.c"
          ],
          "candidate": [
            "src/shared/rm-rf.c||src/shared/rm-rf.c"
          ]
        }
      },
      "candidate_diff": {
        "src/shared/rm-rf.c||src/shared/rm-rf.c": [
          "File: src/shared/rm-rf.c -> src/shared/rm-rf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "116:         return 0;",
          "117: }",
          "120:                 int fd,",
          "121:                 const char *fname,",
          "122:                 int is_dir,",
          "123:                 RemoveFlags flags,",
          "126:         struct stat st;",
          "127:         int r, q = 0;",
          "",
          "[Removed Lines]",
          "119: static int rm_rf_children_inner(",
          "124:                 const struct stat *root_dev) {",
          "",
          "[Added Lines]",
          "118: static int rm_rf_inner_child(",
          "123:                 const struct stat *root_dev,",
          "124:                 bool allow_recursion) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "141:         }",
          "143:         if (is_dir) {",
          "147:                 if (root_dev && st.st_dev != root_dev->st_dev)",
          "148:                         return 0;",
          "",
          "[Removed Lines]",
          "144:                 _cleanup_close_ int subdir_fd = -1;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "169:                                 return 1;",
          "170:                 }",
          "173:                 if (subdir_fd < 0)",
          "174:                         return -errno;",
          "180:         } else if (flags & REMOVE_ONLY_DIRECTORIES)",
          "181:                 return 0;",
          "",
          "[Removed Lines]",
          "172:                 subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);",
          "178:                 q = rm_rf_children(TAKE_FD(subdir_fd), flags | REMOVE_PHYSICAL, root_dev);",
          "",
          "[Added Lines]",
          "169:                 if (!allow_recursion)",
          "170:                         return -EISDIR;",
          "172:                 int subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);",
          "178:                 q = rm_rf_children(subdir_fd, flags | REMOVE_PHYSICAL, root_dev);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "188:         return 1;",
          "189: }",
          "191: int rm_rf_children(",
          "192:                 int fd,",
          "193:                 RemoveFlags flags,",
          "194:                 const struct stat *root_dev) {",
          "198:         int ret = 0, r;",
          "249:         return ret;",
          "250: }",
          "",
          "[Removed Lines]",
          "196:         _cleanup_closedir_ DIR *d = NULL;",
          "197:         struct dirent *de;",
          "200:         assert(fd >= 0);",
          "205:         d = fdopendir(fd);",
          "206:         if (!d) {",
          "207:                 safe_close(fd);",
          "208:                 return -errno;",
          "209:         }",
          "211:         if (!(flags & REMOVE_PHYSICAL)) {",
          "212:                 struct statfs sfs;",
          "214:                 if (fstatfs(dirfd(d), &sfs) < 0)",
          "215:                         return -errno;",
          "217:                 if (is_physical_fs(&sfs)) {",
          "222:                         _cleanup_free_ char *path = NULL;",
          "224:                         (void) fd_get_path(fd, &path);",
          "225:                         return log_error_errno(SYNTHETIC_ERRNO(EPERM),",
          "226:                                                \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",",
          "227:                                                strna(path));",
          "228:                 }",
          "229:         }",
          "231:         FOREACH_DIRENT_ALL(de, d, return -errno) {",
          "232:                 int is_dir;",
          "234:                 if (dot_or_dot_dot(de->d_name))",
          "235:                         continue;",
          "237:                 is_dir =",
          "238:                         de->d_type == DT_UNKNOWN ? -1 :",
          "239:                         de->d_type == DT_DIR;",
          "241:                 r = rm_rf_children_inner(dirfd(d), de->d_name, is_dir, flags, root_dev);",
          "242:                 if (r < 0 && r != -ENOENT && ret == 0)",
          "243:                         ret = r;",
          "244:         }",
          "246:         if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(dirfd(d)) < 0 && ret >= 0)",
          "247:                 ret = -errno;",
          "",
          "[Added Lines]",
          "191: typedef struct TodoEntry {",
          "194: } TodoEntry;",
          "196: static void free_todo_entries(TodoEntry **todos) {",
          "197:         for (TodoEntry *x = *todos; x && x->dir; x++) {",
          "198:                 closedir(x->dir);",
          "199:                 free(x->dirname);",
          "200:         }",
          "202:         freep(todos);",
          "203: }",
          "210:         _cleanup_(free_todo_entries) TodoEntry *todos = NULL;",
          "211:         size_t n_todo = 0;",
          "219:                 _cleanup_closedir_ DIR *d = NULL;",
          "221:                 if (n_todo > 0) {",
          "224:                         assert(dirname);",
          "225:                         r = unlinkat_harder(dirfd(todos[n_todo-1].dir), dirname, AT_REMOVEDIR, flags);",
          "226:                         if (r < 0 && r != -ENOENT && ret == 0)",
          "227:                                 ret = r;",
          "228:                         dirname = mfree(dirname);",
          "231:                         n_todo --;",
          "232:                         d = TAKE_PTR(todos[n_todo].dir);",
          "233:                         dirname = TAKE_PTR(todos[n_todo].dirname);",
          "235:                         assert(d);",
          "237:                         assert(fd >= 0);",
          "238:                 } else {",
          "239:         next_fd:",
          "240:                         assert(fd >= 0);",
          "241:                         d = fdopendir(fd);",
          "242:                         if (!d) {",
          "243:                                 safe_close(fd);",
          "244:                                 return -errno;",
          "245:                         }",
          "246:                         fd = dirfd(d); /* We donated the fd to fdopendir(). Let's make sure we sure we have",
          "250:                         if (!(flags & REMOVE_PHYSICAL)) {",
          "251:                                 struct statfs sfs;",
          "253:                                 if (fstatfs(fd, &sfs) < 0)",
          "254:                                         return -errno;",
          "256:                                 if (is_physical_fs(&sfs)) {",
          "261:                                         _cleanup_free_ char *path = NULL;",
          "263:                                         (void) fd_get_path(fd, &path);",
          "264:                                         return log_error_errno(SYNTHETIC_ERRNO(EPERM),",
          "265:                                                                \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",",
          "266:                                                                strna(path));",
          "267:                                 }",
          "268:                         }",
          "269:                 }",
          "271:                 struct dirent *de;",
          "272:                 FOREACH_DIRENT_ALL(de, d, return -errno) {",
          "273:                         int is_dir;",
          "275:                         if (dot_or_dot_dot(de->d_name))",
          "276:                                 continue;",
          "278:                         is_dir = de->d_type == DT_UNKNOWN ? -1 : de->d_type == DT_DIR;",
          "280:                         r = rm_rf_inner_child(fd, de->d_name, is_dir, flags, root_dev, false);",
          "281:                         if (r == -EISDIR) {",
          "284:                                  if (!GREEDY_REALLOC0(todos, n_todo + 2))",
          "285:                                          return log_oom();",
          "287:                                  _cleanup_free_ char *newdirname = strdup(de->d_name);",
          "288:                                  if (!newdirname)",
          "289:                                          return log_oom();",
          "291:                                  int newfd = openat(fd, de->d_name,",
          "292:                                                     O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);",
          "293:                                  if (newfd >= 0) {",
          "294:                                          todos[n_todo++] = (TodoEntry) { TAKE_PTR(d), TAKE_PTR(dirname) };",
          "295:                                          fd = newfd;",
          "296:                                          dirname = TAKE_PTR(newdirname);",
          "298:                                          goto next_fd;",
          "300:                                  } else if (errno != -ENOENT && ret == 0)",
          "301:                                          ret = -errno;",
          "303:                         } else if (r < 0 && r != -ENOENT && ret == 0)",
          "304:                                 ret = r;",
          "305:                 }",
          "307:                 if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(fd) < 0 && ret >= 0)",
          "308:                         ret = -errno;",
          "310:                 if (n_todo == 0)",
          "311:                         break;",
          "312:         }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "337:         if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))",
          "338:                 return -EINVAL;",
          "341: }",
          "",
          "[Removed Lines]",
          "340:         return rm_rf_children_inner(fd, name, -1, flags, NULL);",
          "",
          "[Added Lines]",
          "405:         return rm_rf_inner_child(fd, name, -1, flags, NULL, true);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c752f27b7647c99b4a17477c99d84fd8c950ddf0",
      "candidate_info": {
        "commit_hash": "c752f27b7647c99b4a17477c99d84fd8c950ddf0",
        "repo": "systemd/systemd",
        "commit_url": "https://github.com/systemd/systemd/commit/c752f27b7647c99b4a17477c99d84fd8c950ddf0",
        "files": [
          "src/basic/rm-rf.c"
        ],
        "message": "shared/rm-rf: loop over nested directories instead of instead of recursing\n\nTo remove directory structures, we need to remove the innermost items first,\nand then recursively remove higher-level directories. We would recursively\ndescend into directories and invoke rm_rf_children and rm_rm_children_inner.\nThis is problematic when too many directories are nested.\n\nInstead, let's create a \"TODO\" queue. In the the queue, for each level we\nhold the DIR* object we were working on, and the name of the directory. This\nallows us to leave a partially-processed directory, and restart the removal\nloop one level down. When done with the inner directory, we use the name to\nunlinkat() it from the parent, and proceed with the removal of other items.\n\nBecause the nesting is increased by one level, it is best to view this patch\nwith -b/--ignore-space-change.\n\nThis fixes CVE-2021-3997, https://bugzilla.redhat.com/show_bug.cgi?id=2024639.\nThe issue was reported and patches reviewed by Qualys Team.\nMauro Matteo Cascella and Riccardo Schirone from Red Hat handled the disclosure.\n\n(cherry picked from commit 5b1cf7a9be37e20133c0208005274ce4a5b5c6a1)\n(cherry picked from commit 911516e1614e435755814ada5fc6064fa107a105)\n(cherry picked from commit 6a28f8b55904c818b25e4db2e1511faac79fd471)",
        "before_after_code_files": [
          "src/basic/rm-rf.c||src/basic/rm-rf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/basic/rm-rf.c||src/basic/rm-rf.c": [
          "File: src/basic/rm-rf.c -> src/basic/rm-rf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "115:         return 0;",
          "116: }",
          "119:                 int fd,",
          "120:                 const char *fname,",
          "121:                 int is_dir,",
          "122:                 RemoveFlags flags,",
          "125:         struct stat st;",
          "126:         int r, q = 0;",
          "",
          "[Removed Lines]",
          "118: static int rm_rf_children_inner(",
          "123:                 const struct stat *root_dev) {",
          "",
          "[Added Lines]",
          "118: static int rm_rf_inner_child(",
          "123:                 const struct stat *root_dev,",
          "124:                 bool allow_recursion) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "140:         }",
          "142:         if (is_dir) {",
          "146:                 if (root_dev && st.st_dev != root_dev->st_dev)",
          "147:                         return 0;",
          "",
          "[Removed Lines]",
          "143:                 _cleanup_close_ int subdir_fd = -1;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "168:                                 return 1;",
          "169:                 }",
          "172:                 if (subdir_fd < 0)",
          "173:                         return -errno;",
          "179:         } else if (flags & REMOVE_ONLY_DIRECTORIES)",
          "180:                 return 0;",
          "",
          "[Removed Lines]",
          "171:                 subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);",
          "177:                 q = rm_rf_children(TAKE_FD(subdir_fd), flags | REMOVE_PHYSICAL, root_dev);",
          "",
          "[Added Lines]",
          "169:                 if (!allow_recursion)",
          "170:                         return -EISDIR;",
          "172:                 int subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);",
          "178:                 q = rm_rf_children(subdir_fd, flags | REMOVE_PHYSICAL, root_dev);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "187:         return 1;",
          "188: }",
          "190: int rm_rf_children(",
          "191:                 int fd,",
          "192:                 RemoveFlags flags,",
          "193:                 const struct stat *root_dev) {",
          "197:         int ret = 0, r;",
          "248:         return ret;",
          "249: }",
          "",
          "[Removed Lines]",
          "195:         _cleanup_closedir_ DIR *d = NULL;",
          "196:         struct dirent *de;",
          "199:         assert(fd >= 0);",
          "204:         d = fdopendir(fd);",
          "205:         if (!d) {",
          "206:                 safe_close(fd);",
          "207:                 return -errno;",
          "208:         }",
          "210:         if (!(flags & REMOVE_PHYSICAL)) {",
          "211:                 struct statfs sfs;",
          "213:                 if (fstatfs(dirfd(d), &sfs) < 0)",
          "214:                         return -errno;",
          "216:                 if (is_physical_fs(&sfs)) {",
          "221:                         _cleanup_free_ char *path = NULL;",
          "223:                         (void) fd_get_path(fd, &path);",
          "224:                         return log_error_errno(SYNTHETIC_ERRNO(EPERM),",
          "225:                                                \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",",
          "226:                                                strna(path));",
          "227:                 }",
          "228:         }",
          "230:         FOREACH_DIRENT_ALL(de, d, return -errno) {",
          "231:                 int is_dir;",
          "233:                 if (dot_or_dot_dot(de->d_name))",
          "234:                         continue;",
          "236:                 is_dir =",
          "237:                         de->d_type == DT_UNKNOWN ? -1 :",
          "238:                         de->d_type == DT_DIR;",
          "240:                 r = rm_rf_children_inner(dirfd(d), de->d_name, is_dir, flags, root_dev);",
          "241:                 if (r < 0 && r != -ENOENT && ret == 0)",
          "242:                         ret = r;",
          "243:         }",
          "245:         if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(dirfd(d)) < 0 && ret >= 0)",
          "246:                 ret = -errno;",
          "",
          "[Added Lines]",
          "191: typedef struct TodoEntry {",
          "194: } TodoEntry;",
          "196: static void free_todo_entries(TodoEntry **todos) {",
          "197:         for (TodoEntry *x = *todos; x && x->dir; x++) {",
          "198:                 closedir(x->dir);",
          "199:                 free(x->dirname);",
          "200:         }",
          "202:         freep(todos);",
          "203: }",
          "210:         _cleanup_(free_todo_entries) TodoEntry *todos = NULL;",
          "211:         size_t n_todo = 0, n_todo_alloc = 0;",
          "219:                 _cleanup_closedir_ DIR *d = NULL;",
          "221:                 if (n_todo > 0) {",
          "224:                         assert(dirname);",
          "225:                         r = unlinkat_harder(dirfd(todos[n_todo-1].dir), dirname, AT_REMOVEDIR, flags);",
          "226:                         if (r < 0 && r != -ENOENT && ret == 0)",
          "227:                                 ret = r;",
          "228:                         dirname = mfree(dirname);",
          "231:                         n_todo --;",
          "232:                         d = TAKE_PTR(todos[n_todo].dir);",
          "233:                         dirname = TAKE_PTR(todos[n_todo].dirname);",
          "235:                         assert(d);",
          "237:                         assert(fd >= 0);",
          "238:                 } else {",
          "239:         next_fd:",
          "240:                         assert(fd >= 0);",
          "241:                         d = fdopendir(fd);",
          "242:                         if (!d) {",
          "243:                                 safe_close(fd);",
          "244:                                 return -errno;",
          "245:                         }",
          "246:                         fd = dirfd(d); /* We donated the fd to fdopendir(). Let's make sure we sure we have",
          "250:                         if (!(flags & REMOVE_PHYSICAL)) {",
          "251:                                 struct statfs sfs;",
          "253:                                 if (fstatfs(fd, &sfs) < 0)",
          "254:                                         return -errno;",
          "256:                                 if (is_physical_fs(&sfs)) {",
          "261:                                         _cleanup_free_ char *path = NULL;",
          "263:                                         (void) fd_get_path(fd, &path);",
          "264:                                         return log_error_errno(SYNTHETIC_ERRNO(EPERM),",
          "265:                                                                \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",",
          "266:                                                                strna(path));",
          "267:                                 }",
          "268:                         }",
          "269:                 }",
          "271:                 struct dirent *de;",
          "272:                 FOREACH_DIRENT_ALL(de, d, return -errno) {",
          "273:                         int is_dir;",
          "275:                         if (dot_or_dot_dot(de->d_name))",
          "276:                                 continue;",
          "278:                         is_dir = de->d_type == DT_UNKNOWN ? -1 : de->d_type == DT_DIR;",
          "280:                         r = rm_rf_inner_child(fd, de->d_name, is_dir, flags, root_dev, false);",
          "281:                         if (r == -EISDIR) {",
          "284:                                  if (!GREEDY_REALLOC0(todos, n_todo_alloc, n_todo + 2))",
          "285:                                          return log_oom();",
          "287:                                  _cleanup_free_ char *newdirname = strdup(de->d_name);",
          "288:                                  if (!newdirname)",
          "289:                                          return log_oom();",
          "291:                                  int newfd = openat(fd, de->d_name,",
          "292:                                                     O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);",
          "293:                                  if (newfd >= 0) {",
          "294:                                          todos[n_todo++] = (TodoEntry) { TAKE_PTR(d), TAKE_PTR(dirname) };",
          "295:                                          fd = newfd;",
          "296:                                          dirname = TAKE_PTR(newdirname);",
          "298:                                          goto next_fd;",
          "300:                                  } else if (errno != -ENOENT && ret == 0)",
          "301:                                          ret = -errno;",
          "303:                         } else if (r < 0 && r != -ENOENT && ret == 0)",
          "304:                                 ret = r;",
          "305:                 }",
          "307:                 if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(fd) < 0 && ret >= 0)",
          "308:                         ret = -errno;",
          "310:                 if (n_todo == 0)",
          "311:                         break;",
          "312:         }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "336:         if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))",
          "337:                 return -EINVAL;",
          "340: }",
          "",
          "[Removed Lines]",
          "339:         return rm_rf_children_inner(fd, name, -1, flags, NULL);",
          "",
          "[Added Lines]",
          "405:         return rm_rf_inner_child(fd, name, -1, flags, NULL, true);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "921810ea23357988ce67f49190f43abef1788a9c",
      "candidate_info": {
        "commit_hash": "921810ea23357988ce67f49190f43abef1788a9c",
        "repo": "systemd/systemd",
        "commit_url": "https://github.com/systemd/systemd/commit/921810ea23357988ce67f49190f43abef1788a9c",
        "files": [
          "src/basic/rm-rf.c"
        ],
        "message": "shared/rm-rf: loop over nested directories instead of instead of recursing\n\nTo remove directory structures, we need to remove the innermost items first,\nand then recursively remove higher-level directories. We would recursively\ndescend into directories and invoke rm_rf_children and rm_rm_children_inner.\nThis is problematic when too many directories are nested.\n\nInstead, let's create a \"TODO\" queue. In the the queue, for each level we\nhold the DIR* object we were working on, and the name of the directory. This\nallows us to leave a partially-processed directory, and restart the removal\nloop one level down. When done with the inner directory, we use the name to\nunlinkat() it from the parent, and proceed with the removal of other items.\n\nBecause the nesting is increased by one level, it is best to view this patch\nwith -b/--ignore-space-change.\n\nThis fixes CVE-2021-3997, https://bugzilla.redhat.com/show_bug.cgi?id=2024639.\nThe issue was reported and patches reviewed by Qualys Team.\nMauro Matteo Cascella and Riccardo Schirone from Red Hat handled the disclosure.\n\n(cherry picked from commit 5b1cf7a9be37e20133c0208005274ce4a5b5c6a1)\n(cherry picked from commit 911516e1614e435755814ada5fc6064fa107a105)\n(cherry picked from commit 6a28f8b55904c818b25e4db2e1511faac79fd471)\n(cherry picked from commit c752f27b7647c99b4a17477c99d84fd8c950ddf0)",
        "before_after_code_files": [
          "src/basic/rm-rf.c||src/basic/rm-rf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/basic/rm-rf.c||src/basic/rm-rf.c": [
          "File: src/basic/rm-rf.c -> src/basic/rm-rf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "115:         return 0;",
          "116: }",
          "119:                 int fd,",
          "120:                 const char *fname,",
          "121:                 int is_dir,",
          "122:                 RemoveFlags flags,",
          "125:         struct stat st;",
          "126:         int r, q = 0;",
          "",
          "[Removed Lines]",
          "118: static int rm_rf_children_inner(",
          "123:                 const struct stat *root_dev) {",
          "",
          "[Added Lines]",
          "118: static int rm_rf_inner_child(",
          "123:                 const struct stat *root_dev,",
          "124:                 bool allow_recursion) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "140:         }",
          "142:         if (is_dir) {",
          "146:                 if (root_dev && st.st_dev != root_dev->st_dev)",
          "147:                         return 0;",
          "",
          "[Removed Lines]",
          "143:                 _cleanup_close_ int subdir_fd = -1;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "168:                                 return 1;",
          "169:                 }",
          "172:                 if (subdir_fd < 0)",
          "173:                         return -errno;",
          "179:         } else if (flags & REMOVE_ONLY_DIRECTORIES)",
          "180:                 return 0;",
          "",
          "[Removed Lines]",
          "171:                 subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);",
          "177:                 q = rm_rf_children(TAKE_FD(subdir_fd), flags | REMOVE_PHYSICAL, root_dev);",
          "",
          "[Added Lines]",
          "169:                 if (!allow_recursion)",
          "170:                         return -EISDIR;",
          "172:                 int subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);",
          "178:                 q = rm_rf_children(subdir_fd, flags | REMOVE_PHYSICAL, root_dev);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "187:         return 1;",
          "188: }",
          "190: int rm_rf_children(",
          "191:                 int fd,",
          "192:                 RemoveFlags flags,",
          "193:                 const struct stat *root_dev) {",
          "197:         int ret = 0, r;",
          "248:         return ret;",
          "249: }",
          "",
          "[Removed Lines]",
          "195:         _cleanup_closedir_ DIR *d = NULL;",
          "196:         struct dirent *de;",
          "199:         assert(fd >= 0);",
          "204:         d = fdopendir(fd);",
          "205:         if (!d) {",
          "206:                 safe_close(fd);",
          "207:                 return -errno;",
          "208:         }",
          "210:         if (!(flags & REMOVE_PHYSICAL)) {",
          "211:                 struct statfs sfs;",
          "213:                 if (fstatfs(dirfd(d), &sfs) < 0)",
          "214:                         return -errno;",
          "216:                 if (is_physical_fs(&sfs)) {",
          "221:                         _cleanup_free_ char *path = NULL;",
          "223:                         (void) fd_get_path(fd, &path);",
          "224:                         return log_error_errno(SYNTHETIC_ERRNO(EPERM),",
          "225:                                                \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",",
          "226:                                                strna(path));",
          "227:                 }",
          "228:         }",
          "230:         FOREACH_DIRENT_ALL(de, d, return -errno) {",
          "231:                 int is_dir;",
          "233:                 if (dot_or_dot_dot(de->d_name))",
          "234:                         continue;",
          "236:                 is_dir =",
          "237:                         de->d_type == DT_UNKNOWN ? -1 :",
          "238:                         de->d_type == DT_DIR;",
          "240:                 r = rm_rf_children_inner(dirfd(d), de->d_name, is_dir, flags, root_dev);",
          "241:                 if (r < 0 && r != -ENOENT && ret == 0)",
          "242:                         ret = r;",
          "243:         }",
          "245:         if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(dirfd(d)) < 0 && ret >= 0)",
          "246:                 ret = -errno;",
          "",
          "[Added Lines]",
          "191: typedef struct TodoEntry {",
          "194: } TodoEntry;",
          "196: static void free_todo_entries(TodoEntry **todos) {",
          "197:         for (TodoEntry *x = *todos; x && x->dir; x++) {",
          "198:                 closedir(x->dir);",
          "199:                 free(x->dirname);",
          "200:         }",
          "202:         freep(todos);",
          "203: }",
          "210:         _cleanup_(free_todo_entries) TodoEntry *todos = NULL;",
          "211:         size_t n_todo = 0, n_todo_alloc = 0;",
          "219:                 _cleanup_closedir_ DIR *d = NULL;",
          "221:                 if (n_todo > 0) {",
          "224:                         assert(dirname);",
          "225:                         r = unlinkat_harder(dirfd(todos[n_todo-1].dir), dirname, AT_REMOVEDIR, flags);",
          "226:                         if (r < 0 && r != -ENOENT && ret == 0)",
          "227:                                 ret = r;",
          "228:                         dirname = mfree(dirname);",
          "231:                         n_todo --;",
          "232:                         d = TAKE_PTR(todos[n_todo].dir);",
          "233:                         dirname = TAKE_PTR(todos[n_todo].dirname);",
          "235:                         assert(d);",
          "237:                         assert(fd >= 0);",
          "238:                 } else {",
          "239:         next_fd:",
          "240:                         assert(fd >= 0);",
          "241:                         d = fdopendir(fd);",
          "242:                         if (!d) {",
          "243:                                 safe_close(fd);",
          "244:                                 return -errno;",
          "245:                         }",
          "246:                         fd = dirfd(d); /* We donated the fd to fdopendir(). Let's make sure we sure we have",
          "250:                         if (!(flags & REMOVE_PHYSICAL)) {",
          "251:                                 struct statfs sfs;",
          "253:                                 if (fstatfs(fd, &sfs) < 0)",
          "254:                                         return -errno;",
          "256:                                 if (is_physical_fs(&sfs)) {",
          "261:                                         _cleanup_free_ char *path = NULL;",
          "263:                                         (void) fd_get_path(fd, &path);",
          "264:                                         return log_error_errno(SYNTHETIC_ERRNO(EPERM),",
          "265:                                                                \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",",
          "266:                                                                strna(path));",
          "267:                                 }",
          "268:                         }",
          "269:                 }",
          "271:                 struct dirent *de;",
          "272:                 FOREACH_DIRENT_ALL(de, d, return -errno) {",
          "273:                         int is_dir;",
          "275:                         if (dot_or_dot_dot(de->d_name))",
          "276:                                 continue;",
          "278:                         is_dir = de->d_type == DT_UNKNOWN ? -1 : de->d_type == DT_DIR;",
          "280:                         r = rm_rf_inner_child(fd, de->d_name, is_dir, flags, root_dev, false);",
          "281:                         if (r == -EISDIR) {",
          "284:                                  if (!GREEDY_REALLOC0(todos, n_todo_alloc, n_todo + 2))",
          "285:                                          return log_oom();",
          "287:                                  _cleanup_free_ char *newdirname = strdup(de->d_name);",
          "288:                                  if (!newdirname)",
          "289:                                          return log_oom();",
          "291:                                  int newfd = openat(fd, de->d_name,",
          "292:                                                     O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);",
          "293:                                  if (newfd >= 0) {",
          "294:                                          todos[n_todo++] = (TodoEntry) { TAKE_PTR(d), TAKE_PTR(dirname) };",
          "295:                                          fd = newfd;",
          "296:                                          dirname = TAKE_PTR(newdirname);",
          "298:                                          goto next_fd;",
          "300:                                  } else if (errno != -ENOENT && ret == 0)",
          "301:                                          ret = -errno;",
          "303:                         } else if (r < 0 && r != -ENOENT && ret == 0)",
          "304:                                 ret = r;",
          "305:                 }",
          "307:                 if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(fd) < 0 && ret >= 0)",
          "308:                         ret = -errno;",
          "310:                 if (n_todo == 0)",
          "311:                         break;",
          "312:         }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "336:         if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))",
          "337:                 return -EINVAL;",
          "340: }",
          "",
          "[Removed Lines]",
          "339:         return rm_rf_children_inner(fd, name, -1, flags, NULL);",
          "",
          "[Added Lines]",
          "405:         return rm_rf_inner_child(fd, name, -1, flags, NULL, true);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "911516e1614e435755814ada5fc6064fa107a105",
      "candidate_info": {
        "commit_hash": "911516e1614e435755814ada5fc6064fa107a105",
        "repo": "systemd/systemd",
        "commit_url": "https://github.com/systemd/systemd/commit/911516e1614e435755814ada5fc6064fa107a105",
        "files": [
          "src/shared/rm-rf.c"
        ],
        "message": "shared/rm-rf: loop over nested directories instead of instead of recursing\n\nTo remove directory structures, we need to remove the innermost items first,\nand then recursively remove higher-level directories. We would recursively\ndescend into directories and invoke rm_rf_children and rm_rm_children_inner.\nThis is problematic when too many directories are nested.\n\nInstead, let's create a \"TODO\" queue. In the the queue, for each level we\nhold the DIR* object we were working on, and the name of the directory. This\nallows us to leave a partially-processed directory, and restart the removal\nloop one level down. When done with the inner directory, we use the name to\nunlinkat() it from the parent, and proceed with the removal of other items.\n\nBecause the nesting is increased by one level, it is best to view this patch\nwith -b/--ignore-space-change.\n\nThis fixes CVE-2021-3997, https://bugzilla.redhat.com/show_bug.cgi?id=2024639.\nThe issue was reported and patches reviewed by Qualys Team.\nMauro Matteo Cascella and Riccardo Schirone from Red Hat handled the disclosure.\n\n(cherry picked from commit 5b1cf7a9be37e20133c0208005274ce4a5b5c6a1)",
        "before_after_code_files": [
          "src/shared/rm-rf.c||src/shared/rm-rf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/shared/rm-rf.c||src/shared/rm-rf.c"
          ],
          "candidate": [
            "src/shared/rm-rf.c||src/shared/rm-rf.c"
          ]
        }
      },
      "candidate_diff": {
        "src/shared/rm-rf.c||src/shared/rm-rf.c": [
          "File: src/shared/rm-rf.c -> src/shared/rm-rf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "116:         return 0;",
          "117: }",
          "120:                 int fd,",
          "121:                 const char *fname,",
          "122:                 int is_dir,",
          "123:                 RemoveFlags flags,",
          "126:         struct stat st;",
          "127:         int r, q = 0;",
          "",
          "[Removed Lines]",
          "119: static int rm_rf_children_inner(",
          "124:                 const struct stat *root_dev) {",
          "",
          "[Added Lines]",
          "118: static int rm_rf_inner_child(",
          "123:                 const struct stat *root_dev,",
          "124:                 bool allow_recursion) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "141:         }",
          "143:         if (is_dir) {",
          "147:                 if (root_dev && st.st_dev != root_dev->st_dev)",
          "148:                         return 0;",
          "",
          "[Removed Lines]",
          "144:                 _cleanup_close_ int subdir_fd = -1;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "169:                                 return 1;",
          "170:                 }",
          "173:                 if (subdir_fd < 0)",
          "174:                         return -errno;",
          "180:         } else if (flags & REMOVE_ONLY_DIRECTORIES)",
          "181:                 return 0;",
          "",
          "[Removed Lines]",
          "172:                 subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);",
          "178:                 q = rm_rf_children(TAKE_FD(subdir_fd), flags | REMOVE_PHYSICAL, root_dev);",
          "",
          "[Added Lines]",
          "169:                 if (!allow_recursion)",
          "170:                         return -EISDIR;",
          "172:                 int subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);",
          "178:                 q = rm_rf_children(subdir_fd, flags | REMOVE_PHYSICAL, root_dev);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "188:         return 1;",
          "189: }",
          "191: int rm_rf_children(",
          "192:                 int fd,",
          "193:                 RemoveFlags flags,",
          "194:                 const struct stat *root_dev) {",
          "197:         int ret = 0, r;",
          "248:         return ret;",
          "249: }",
          "",
          "[Removed Lines]",
          "196:         _cleanup_closedir_ DIR *d = NULL;",
          "199:         assert(fd >= 0);",
          "204:         d = fdopendir(fd);",
          "205:         if (!d) {",
          "206:                 safe_close(fd);",
          "207:                 return -errno;",
          "208:         }",
          "210:         if (!(flags & REMOVE_PHYSICAL)) {",
          "211:                 struct statfs sfs;",
          "213:                 if (fstatfs(dirfd(d), &sfs) < 0)",
          "214:                         return -errno;",
          "216:                 if (is_physical_fs(&sfs)) {",
          "221:                         _cleanup_free_ char *path = NULL;",
          "223:                         (void) fd_get_path(fd, &path);",
          "224:                         return log_error_errno(SYNTHETIC_ERRNO(EPERM),",
          "225:                                                \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",",
          "226:                                                strna(path));",
          "227:                 }",
          "228:         }",
          "230:         FOREACH_DIRENT_ALL(de, d, return -errno) {",
          "231:                 int is_dir;",
          "233:                 if (dot_or_dot_dot(de->d_name))",
          "234:                         continue;",
          "236:                 is_dir =",
          "237:                         de->d_type == DT_UNKNOWN ? -1 :",
          "238:                         de->d_type == DT_DIR;",
          "240:                 r = rm_rf_children_inner(dirfd(d), de->d_name, is_dir, flags, root_dev);",
          "241:                 if (r < 0 && r != -ENOENT && ret == 0)",
          "242:                         ret = r;",
          "243:         }",
          "245:         if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(dirfd(d)) < 0 && ret >= 0)",
          "246:                 ret = -errno;",
          "",
          "[Added Lines]",
          "191: typedef struct TodoEntry {",
          "194: } TodoEntry;",
          "196: static void free_todo_entries(TodoEntry **todos) {",
          "197:         for (TodoEntry *x = *todos; x && x->dir; x++) {",
          "198:                 closedir(x->dir);",
          "199:                 free(x->dirname);",
          "200:         }",
          "202:         freep(todos);",
          "203: }",
          "210:         _cleanup_(free_todo_entries) TodoEntry *todos = NULL;",
          "211:         size_t n_todo = 0;",
          "219:                 _cleanup_closedir_ DIR *d = NULL;",
          "221:                 if (n_todo > 0) {",
          "224:                         assert(dirname);",
          "225:                         r = unlinkat_harder(dirfd(todos[n_todo-1].dir), dirname, AT_REMOVEDIR, flags);",
          "226:                         if (r < 0 && r != -ENOENT && ret == 0)",
          "227:                                 ret = r;",
          "228:                         dirname = mfree(dirname);",
          "231:                         n_todo --;",
          "232:                         d = TAKE_PTR(todos[n_todo].dir);",
          "233:                         dirname = TAKE_PTR(todos[n_todo].dirname);",
          "235:                         assert(d);",
          "237:                         assert(fd >= 0);",
          "238:                 } else {",
          "239:         next_fd:",
          "240:                         assert(fd >= 0);",
          "241:                         d = fdopendir(fd);",
          "242:                         if (!d) {",
          "243:                                 safe_close(fd);",
          "244:                                 return -errno;",
          "245:                         }",
          "246:                         fd = dirfd(d); /* We donated the fd to fdopendir(). Let's make sure we sure we have",
          "250:                         if (!(flags & REMOVE_PHYSICAL)) {",
          "251:                                 struct statfs sfs;",
          "253:                                 if (fstatfs(fd, &sfs) < 0)",
          "254:                                         return -errno;",
          "256:                                 if (is_physical_fs(&sfs)) {",
          "261:                                         _cleanup_free_ char *path = NULL;",
          "263:                                         (void) fd_get_path(fd, &path);",
          "264:                                         return log_error_errno(SYNTHETIC_ERRNO(EPERM),",
          "265:                                                                \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",",
          "266:                                                                strna(path));",
          "267:                                 }",
          "268:                         }",
          "269:                 }",
          "271:                 FOREACH_DIRENT_ALL(de, d, return -errno) {",
          "272:                         int is_dir;",
          "274:                         if (dot_or_dot_dot(de->d_name))",
          "275:                                 continue;",
          "277:                         is_dir = de->d_type == DT_UNKNOWN ? -1 : de->d_type == DT_DIR;",
          "279:                         r = rm_rf_inner_child(fd, de->d_name, is_dir, flags, root_dev, false);",
          "280:                         if (r == -EISDIR) {",
          "283:                                  if (!GREEDY_REALLOC0(todos, n_todo + 2))",
          "284:                                          return log_oom();",
          "286:                                  _cleanup_free_ char *newdirname = strdup(de->d_name);",
          "287:                                  if (!newdirname)",
          "288:                                          return log_oom();",
          "290:                                  int newfd = openat(fd, de->d_name,",
          "291:                                                     O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);",
          "292:                                  if (newfd >= 0) {",
          "293:                                          todos[n_todo++] = (TodoEntry) { TAKE_PTR(d), TAKE_PTR(dirname) };",
          "294:                                          fd = newfd;",
          "295:                                          dirname = TAKE_PTR(newdirname);",
          "297:                                          goto next_fd;",
          "299:                                  } else if (errno != -ENOENT && ret == 0)",
          "300:                                          ret = -errno;",
          "302:                         } else if (r < 0 && r != -ENOENT && ret == 0)",
          "303:                                 ret = r;",
          "304:                 }",
          "306:                 if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(fd) < 0 && ret >= 0)",
          "307:                         ret = -errno;",
          "309:                 if (n_todo == 0)",
          "310:                         break;",
          "311:         }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "335:         if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))",
          "336:                 return -EINVAL;",
          "339: }",
          "",
          "[Removed Lines]",
          "338:         return rm_rf_children_inner(fd, name, -1, flags, NULL);",
          "",
          "[Added Lines]",
          "403:         return rm_rf_inner_child(fd, name, -1, flags, NULL, true);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "84ced330020c0bae57bd4628f1f44eec91304e69",
      "candidate_info": {
        "commit_hash": "84ced330020c0bae57bd4628f1f44eec91304e69",
        "repo": "systemd/systemd",
        "commit_url": "https://github.com/systemd/systemd/commit/84ced330020c0bae57bd4628f1f44eec91304e69",
        "files": [
          "src/shared/rm-rf.c"
        ],
        "message": "shared/rm_rf: refactor rm_rf() to shorten code a bit",
        "before_after_code_files": [
          "src/shared/rm-rf.c||src/shared/rm-rf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/systemd/systemd/pull/22070"
        ],
        "olp_code_files": {
          "patch": [
            "src/shared/rm-rf.c||src/shared/rm-rf.c"
          ],
          "candidate": [
            "src/shared/rm-rf.c||src/shared/rm-rf.c"
          ]
        }
      },
      "candidate_diff": {
        "src/shared/rm-rf.c||src/shared/rm-rf.c": [
          "File: src/shared/rm-rf.c -> src/shared/rm-rf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "249: }",
          "251: int rm_rf(const char *path, RemoveFlags flags) {",
          "254:         assert(path);",
          "",
          "[Removed Lines]",
          "252:         int fd, r;",
          "",
          "[Added Lines]",
          "252:         int fd, r, q = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "281:         }",
          "283:         fd = open(path, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);",
          "285:                 if (FLAGS_SET(flags, REMOVE_MISSING_OK) && errno == ENOENT)",
          "286:                         return 0;",
          "288:                 if (!IN_SET(errno, ENOTDIR, ELOOP))",
          "289:                         return -errno;",
          "292:                         return 0;",
          "311:                                 return -errno;",
          "313:                 }",
          "316:         }",
          "327: }",
          "329: int rm_rf_child(int fd, const char *name, RemoveFlags flags) {",
          "",
          "[Removed Lines]",
          "284:         if (fd < 0) {",
          "291:                 if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES))",
          "294:                 if (FLAGS_SET(flags, REMOVE_ROOT)) {",
          "296:                         if (!FLAGS_SET(flags, REMOVE_PHYSICAL)) {",
          "297:                                 struct statfs s;",
          "299:                                 if (statfs(path, &s) < 0)",
          "300:                                         return -errno;",
          "301:                                 if (is_physical_fs(&s))",
          "302:                                         return log_error_errno(SYNTHETIC_ERRNO(EPERM),",
          "303:                                                                \"Attempted to remove files from a disk file system under \\\"%s\\\", refusing.\",",
          "304:                                                                path);",
          "305:                         }",
          "307:                         if (unlink(path) < 0) {",
          "308:                                 if (FLAGS_SET(flags, REMOVE_MISSING_OK) && errno == ENOENT)",
          "309:                                         return 0;",
          "312:                         }",
          "315:                 return 0;",
          "318:         r = rm_rf_children(fd, flags, NULL);",
          "320:         if (FLAGS_SET(flags, REMOVE_ROOT) &&",
          "321:             rmdir(path) < 0 &&",
          "322:             r >= 0 &&",
          "323:             (!FLAGS_SET(flags, REMOVE_MISSING_OK) || errno != ENOENT))",
          "324:                 r = -errno;",
          "326:         return r;",
          "",
          "[Added Lines]",
          "284:         if (fd >= 0) {",
          "286:                 r = rm_rf_children(fd, flags, NULL);",
          "288:                 if (FLAGS_SET(flags, REMOVE_ROOT))",
          "289:                         q = RET_NERRNO(rmdir(path));",
          "290:         } else {",
          "297:                 if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES) || !FLAGS_SET(flags, REMOVE_ROOT))",
          "300:                 if (!FLAGS_SET(flags, REMOVE_PHYSICAL)) {",
          "301:                         struct statfs s;",
          "303:                         if (statfs(path, &s) < 0)",
          "305:                         if (is_physical_fs(&s))",
          "306:                                 return log_error_errno(SYNTHETIC_ERRNO(EPERM),",
          "307:                                                        \"Attempted to remove files from a disk file system under \\\"%s\\\", refusing.\",",
          "308:                                                        path);",
          "311:                 r = 0;",
          "312:                 q = RET_NERRNO(unlink(path));",
          "315:         if (r < 0)",
          "316:                 return r;",
          "317:         if (q < 0 && (q != -ENOENT || !FLAGS_SET(flags, REMOVE_MISSING_OK)))",
          "318:                 return q;",
          "319:         return 0;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
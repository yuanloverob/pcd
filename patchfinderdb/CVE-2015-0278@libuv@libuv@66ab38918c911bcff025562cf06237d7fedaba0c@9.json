{
  "cve_id": "CVE-2015-0278",
  "cve_desc": "libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.",
  "repo": "libuv/libuv",
  "patch_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
  "patch_info": {
    "commit_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
    "repo": "libuv/libuv",
    "commit_url": "https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c",
    "files": [
      "src/unix/process.c"
    ],
    "message": "unix: call setgoups before calling setuid/setgid\n\nPartial fix for #1093",
    "before_after_code_files": [
      "src/unix/process.c||src/unix/process.c"
    ]
  },
  "patch_diff": {
    "src/unix/process.c||src/unix/process.c": [
      "File: src/unix/process.c -> src/unix/process.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "330:     _exit(127);",
      "331:   }",
      "333:   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {",
      "334:     uv__write_int(error_fd, -errno);",
      "335:     perror(\"setgid()\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "333:   if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {",
      "341:     SAVE_ERRNO(setgroups(0, NULL));",
      "342:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "8692bbc254b89ef4ccd1a9bf7be9a1bc8bc6eb5f",
      "candidate_info": {
        "commit_hash": "8692bbc254b89ef4ccd1a9bf7be9a1bc8bc6eb5f",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/8692bbc254b89ef4ccd1a9bf7be9a1bc8bc6eb5f",
        "files": [
          "src/win/core.c"
        ],
        "message": "windows: fix building on MinGW\n\nThe crtdbg.h header was added in c0716b3d, but MinGW does not have this\nheader present on the system. This commit takes the same approach of\n2684f876a and just ignores this header and functionality on MinGW",
        "before_after_code_files": [
          "src/win/core.c||src/win/core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/win/core.c||src/win/core.c": [
          "File: src/win/core.c -> src/win/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #include <stdio.h>",
          "27: #include <stdlib.h>",
          "28: #include <string.h>",
          "29: #include <crtdbg.h>",
          "31: #include \"uv.h\"",
          "32: #include \"internal.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #if !defined(__MINGW32__)",
          "31: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "42: static uv_once_t uv_default_loop_init_guard_ = UV_ONCE_INIT;",
          "",
          "[Removed Lines]",
          "45: #ifdef _DEBUG",
          "",
          "[Added Lines]",
          "47: #if defined(_DEBUG) && !defined(__MINGW32__)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "93:   _CrtSetReportHook(uv__crt_dbg_report_handler);",
          "94: #endif",
          "",
          "[Removed Lines]",
          "92: #ifdef _DEBUG",
          "",
          "[Added Lines]",
          "94: #if defined(_DEBUG) && !defined(__MINGW32__)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "115281a1058c4034d5c5ccedacb667fe3f6327ea",
      "candidate_info": {
        "commit_hash": "115281a1058c4034d5c5ccedacb667fe3f6327ea",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/115281a1058c4034d5c5ccedacb667fe3f6327ea",
        "files": [
          ".mailmap",
          "AUTHORS",
          "ChangeLog",
          "include/uv-version.h"
        ],
        "message": "2014.06.28, Version 0.11.26 (Unstable)\n\nChanges since version 0.11.25:\n\n* windows: add VT100 codes ?25l and ?25h (JD Ballard)\n\n* windows: add invert ANSI (7 / 27) emulation (JD Ballard)\n\n* unix: fix handling error on UDP socket creation (Sa\u00fal Ibarra Corretg\u00e9)\n\n* unix, windows: getnameinfo implementation (Rasmus Pedersen)\n\n* heap: fix `heap_remove()` (Fedor Indutny)\n\n* unix, windows: fix parsing scoped IPv6 addresses (Sa\u00fal Ibarra\n  Corretg\u00e9)\n\n* windows: fix handling closed socket while poll handle is closing (Sa\u00fal\n  Ibarra Corretg\u00e9)\n\n* thread: barrier functions (Ben Noordhuis)\n\n* windows: fix PYTHON environment variable usage (Jay Satiro)\n\n* unix, windows: return system error on EAI_SYSTEM (Sa\u00fal Ibarra\n  Corretg\u00e9)\n\n* windows: fix handling closed socket while poll handle is closing (Sa\u00fal\n  Ibarra Corretg\u00e9)\n\n* unix: don't run i/o callbacks after prepare callbacks (Sa\u00fal Ibarra\n  Corretg\u00e9)\n\n* windows: add tty unicode support for input (Peter Atashian)\n\n* header: introduce `uv_loop_size()` (Andrius Bentkus)\n\n* darwin: invoke `mach_timebase_info` only once (Fedor Indutny)",
        "before_after_code_files": [
          "include/uv-version.h||include/uv-version.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/uv-version.h||include/uv-version.h": [
          "File: include/uv-version.h -> include/uv-version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: #define UV_VERSION_MAJOR 0",
          "34: #define UV_VERSION_MINOR 11",
          "35: #define UV_VERSION_PATCH 26",
          "",
          "[Removed Lines]",
          "36: #define UV_VERSION_IS_RELEASE 0",
          "",
          "[Added Lines]",
          "36: #define UV_VERSION_IS_RELEASE 1",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6d3a051eb4d13db39812fe68563451dfb48533bb",
      "candidate_info": {
        "commit_hash": "6d3a051eb4d13db39812fe68563451dfb48533bb",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/6d3a051eb4d13db39812fe68563451dfb48533bb",
        "files": [
          "include/uv-win.h",
          "src/win/internal.h",
          "src/win/pipe.c",
          "src/win/tcp.c",
          "test/run-tests.c",
          "test/test-ipc.c",
          "test/test-list.h"
        ],
        "message": "windows: relay TCP bind errors via ipc\n\nThis is the libuv side of the fix for Node's cluster module on Windows.\nhttps://github.com/joyent/node/issues/7691\n\nWindows and Unix return certain socket errors (i.e. EADDRINUSE) at\ndifferent times: bind on Windows, and listen on Unix.\nIn an effort to hide this difference, libuv on Windows stores such\nerrors in the bind_error field of uv_tcp_t, to defer raising it at\nlisten time.\nThis worked fine except for the case in which a socket is shared in\na Node cluster and a bind error occurs.\n\nA previous attempt to fix this (\nhttps://github.com/joyent/libuv/commit/d1e6be1460f555a1f8a4063d7642696aa7238769\nhttps://github.com/joyent/node/commit/3da36fe00e5d85414031ae812e473f16629d8645\n) was flawed becaused in an attempt to relay the error at the JS level\nit caused the master to start accepting connections.\n\nWith this new approach, libuv itself is relaying the bind errors,\nproviding for a uniform behavior of uv_tcp_listen.",
        "before_after_code_files": [
          "include/uv-win.h||include/uv-win.h",
          "src/win/internal.h||src/win/internal.h",
          "src/win/pipe.c||src/win/pipe.c",
          "src/win/tcp.c||src/win/tcp.c",
          "test/run-tests.c||test/run-tests.c",
          "test/test-ipc.c||test/test-ipc.c",
          "test/test-list.h||test/test-list.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/uv-win.h||include/uv-win.h": [
          "File: include/uv-win.h -> include/uv-win.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "410: #define UV_TCP_PRIVATE_FIELDS                                                 \\",
          "411:   SOCKET socket;                                                              \\",
          "413:   union {                                                                     \\",
          "414:     struct { uv_tcp_server_fields };                                          \\",
          "415:     struct { uv_tcp_connection_fields };                                      \\",
          "",
          "[Removed Lines]",
          "412:   int bind_error;                                                             \\",
          "",
          "[Added Lines]",
          "412:   int delayed_error;                                                          \\",
          "",
          "---------------"
        ],
        "src/win/internal.h||src/win/internal.h": [
          "File: src/win/internal.h -> src/win/internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "76: #define UV_HANDLE_READING                       0x00000100",
          "77: #define UV_HANDLE_BOUND                         0x00000200",
          "79: #define UV_HANDLE_LISTENING                     0x00000800",
          "80: #define UV_HANDLE_CONNECTION                    0x00001000",
          "81: #define UV_HANDLE_CONNECTED                     0x00002000",
          "",
          "[Removed Lines]",
          "78: #define UV_HANDLE_BIND_ERROR                    0x00000400",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "128: int uv_tcp_listen(uv_tcp_t* handle, int backlog, uv_connection_cb cb);",
          "129: int uv_tcp_accept(uv_tcp_t* server, uv_tcp_t* client);",
          "130: int uv_tcp_read_start(uv_tcp_t* handle, uv_alloc_cb alloc_cb,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "128: typedef struct {",
          "129:   WSAPROTOCOL_INFOW socket_info;",
          "130:   int delayed_error;",
          "131: } uv__ipc_socket_info_ex;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "143: void uv_tcp_close(uv_loop_t* loop, uv_tcp_t* tcp);",
          "144: void uv_tcp_endgame(uv_loop_t* loop, uv_tcp_t* handle);",
          "147:     int tcp_connection);",
          "149: int uv_tcp_duplicate_socket(uv_tcp_t* handle, int pid,",
          "",
          "[Removed Lines]",
          "146: int uv_tcp_import(uv_tcp_t* tcp, WSAPROTOCOL_INFOW* socket_protocol_info,",
          "",
          "[Added Lines]",
          "151: int uv_tcp_import(uv_tcp_t* tcp, uv__ipc_socket_info_ex* socket_info_ex,",
          "",
          "---------------"
        ],
        "src/win/pipe.c||src/win/pipe.c": [
          "File: src/win/pipe.c -> src/win/pipe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: struct uv__ipc_queue_item_s {",
          "42:   QUEUE member;",
          "43:   int tcp_connection;",
          "44: };",
          "",
          "[Removed Lines]",
          "41:   WSAPROTOCOL_INFOW socket_info;",
          "",
          "[Added Lines]",
          "41:   uv__ipc_socket_info_ex socket_info_ex;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "74: typedef struct {",
          "75:   uv_ipc_frame_header_t header;",
          "77: } uv_ipc_frame_uv_stream;",
          "79: static void eof_timer_init(uv_pipe_t* pipe);",
          "",
          "[Removed Lines]",
          "76:   WSAPROTOCOL_INFOW socket_info;",
          "",
          "[Added Lines]",
          "76:   uv__ipc_socket_info_ex socket_info_ex;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "408:         socket = WSASocketW(FROM_PROTOCOL_INFO,",
          "409:                             FROM_PROTOCOL_INFO,",
          "410:                             FROM_PROTOCOL_INFO,",
          "412:                             0,",
          "413:                             WSA_FLAG_OVERLAPPED);",
          "414:         free(item);",
          "",
          "[Removed Lines]",
          "411:                             &item->socket_info,",
          "",
          "[Added Lines]",
          "411:                             &item->socket_info_ex.socket_info,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "787:     item = QUEUE_DATA(q, uv__ipc_queue_item_t, member);",
          "789:     err = uv_tcp_import((uv_tcp_t*)client,",
          "791:                         item->tcp_connection);",
          "792:     if (err != 0)",
          "793:       return err;",
          "",
          "[Removed Lines]",
          "790:                         &item->socket_info,",
          "",
          "[Added Lines]",
          "790:                         &item->socket_info_ex,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1132:       tcp_send_handle = (uv_tcp_t*)send_handle;",
          "1134:       err = uv_tcp_duplicate_socket(tcp_send_handle, handle->ipc_pid,",
          "1136:       if (err) {",
          "1137:         return err;",
          "1138:       }",
          "1139:       ipc_frame.header.flags |= UV_IPC_TCP_SERVER;",
          "1141:       if (tcp_send_handle->flags & UV_HANDLE_CONNECTION) {",
          "",
          "[Removed Lines]",
          "1135:           &ipc_frame.socket_info);",
          "",
          "[Added Lines]",
          "1135:           &ipc_frame.socket_info_ex.socket_info);",
          "1140:       ipc_frame.socket_info_ex.delayed_error = tcp_send_handle->delayed_error;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1397: void uv__pipe_insert_pending_socket(uv_pipe_t* handle,",
          "1399:                                     int tcp_connection) {",
          "1400:   uv__ipc_queue_item_t* item;",
          "",
          "[Removed Lines]",
          "1398:                                     WSAPROTOCOL_INFOW* info,",
          "",
          "[Added Lines]",
          "1401:                                     uv__ipc_socket_info_ex* info,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1403:   if (item == NULL)",
          "1404:     uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");",
          "1407:   item->tcp_connection = tcp_connection;",
          "1408:   QUEUE_INSERT_TAIL(&handle->pending_ipc_info.queue, &item->member);",
          "1409:   handle->pending_ipc_info.queue_len++;",
          "",
          "[Removed Lines]",
          "1406:   memcpy(&item->socket_info, info, sizeof(item->socket_info));",
          "",
          "[Added Lines]",
          "1409:   memcpy(&item->socket_info_ex, info, sizeof(item->socket_info_ex));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1470:           if (ipc_frame.header.flags & UV_IPC_TCP_SERVER) {",
          "1471:             assert(avail - sizeof(ipc_frame.header) >=",
          "1475:             if (!ReadFile(handle->handle,",
          "1477:                           sizeof(ipc_frame) - sizeof(ipc_frame.header),",
          "1478:                           &bytes,",
          "1479:                           NULL)) {",
          "",
          "[Removed Lines]",
          "1472:               sizeof(ipc_frame.socket_info));",
          "1476:                           &ipc_frame.socket_info,",
          "",
          "[Added Lines]",
          "1475:               sizeof(ipc_frame.socket_info_ex));",
          "1479:                           &ipc_frame.socket_info_ex,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1488:             uv__pipe_insert_pending_socket(",
          "1489:                 handle,",
          "1491:                 ipc_frame.header.flags & UV_IPC_TCP_CONNECTION);",
          "1492:           }",
          "",
          "[Removed Lines]",
          "1490:                 &ipc_frame.socket_info,",
          "",
          "[Added Lines]",
          "1493:                 &ipc_frame.socket_info_ex,",
          "",
          "---------------"
        ],
        "src/win/tcp.c||src/win/tcp.c": [
          "File: src/win/tcp.c -> src/win/tcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "156:   handle->func_acceptex = NULL;",
          "157:   handle->func_connectex = NULL;",
          "158:   handle->processed_accepts = 0;",
          "160:   return 0;",
          "161: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "159:   handle->delayed_error = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "302:     err = WSAGetLastError();",
          "303:     if (err == WSAEADDRINUSE) {",
          "307:     } else {",
          "308:       return err;",
          "309:     }",
          "",
          "[Removed Lines]",
          "305:       handle->bind_error = err;",
          "306:       handle->flags |= UV_HANDLE_BIND_ERROR;",
          "",
          "[Added Lines]",
          "306:       handle->delayed_error = err;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "528:     return WSAEISCONN;",
          "529:   }",
          "533:   }",
          "535:   if (!(handle->flags & UV_HANDLE_BOUND)) {",
          "",
          "[Removed Lines]",
          "531:   if (handle->flags & UV_HANDLE_BIND_ERROR) {",
          "532:     return handle->bind_error;",
          "",
          "[Added Lines]",
          "531:   if (handle->delayed_error) {",
          "532:     return handle->delayed_error;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "539:                           0);",
          "540:     if (err)",
          "541:       return err;",
          "544:   }",
          "546:   if (!handle->func_acceptex) {",
          "",
          "[Removed Lines]",
          "542:     if (handle->flags & UV_HANDLE_BIND_ERROR)",
          "543:       return handle->bind_error;",
          "",
          "[Added Lines]",
          "542:     if (handle->delayed_error)",
          "543:       return handle->delayed_error;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "712:   DWORD bytes;",
          "713:   int err;",
          "717:   }",
          "719:   if (!(handle->flags & UV_HANDLE_BOUND)) {",
          "",
          "[Removed Lines]",
          "715:   if (handle->flags & UV_HANDLE_BIND_ERROR) {",
          "716:     return handle->bind_error;",
          "",
          "[Added Lines]",
          "715:   if (handle->delayed_error) {",
          "716:     return handle->delayed_error;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "727:     err = uv_tcp_try_bind(handle, bind_addr, addrlen, 0);",
          "728:     if (err)",
          "729:       return err;",
          "732:   }",
          "734:   if (!handle->func_connectex) {",
          "",
          "[Removed Lines]",
          "730:     if (handle->flags & UV_HANDLE_BIND_ERROR)",
          "731:       return handle->bind_error;",
          "",
          "[Added Lines]",
          "730:     if (handle->delayed_error)",
          "731:       return handle->delayed_error;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "777:     return UV_EINVAL;",
          "778:   }",
          "782:   }",
          "784:   result = getsockname(handle->socket, name, namelen);",
          "",
          "[Removed Lines]",
          "780:   if (handle->flags & UV_HANDLE_BIND_ERROR) {",
          "781:     return uv_translate_sys_error(handle->bind_error);",
          "",
          "[Added Lines]",
          "780:   if (handle->delayed_error) {",
          "781:     return uv_translate_sys_error(handle->delayed_error);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "799:     return UV_EINVAL;",
          "800:   }",
          "804:   }",
          "806:   result = getpeername(handle->socket, name, namelen);",
          "",
          "[Removed Lines]",
          "802:   if (handle->flags & UV_HANDLE_BIND_ERROR) {",
          "803:     return uv_translate_sys_error(handle->bind_error);",
          "",
          "[Added Lines]",
          "802:   if (handle->delayed_error) {",
          "803:     return uv_translate_sys_error(handle->delayed_error);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1117: }",
          "1121:     int tcp_connection) {",
          "1122:   int err;",
          "1124:   SOCKET socket = WSASocketW(FROM_PROTOCOL_INFO,",
          "1125:                              FROM_PROTOCOL_INFO,",
          "1126:                              FROM_PROTOCOL_INFO,",
          "1128:                              0,",
          "1129:                              WSA_FLAG_OVERLAPPED);",
          "",
          "[Removed Lines]",
          "1120: int uv_tcp_import(uv_tcp_t* tcp, WSAPROTOCOL_INFOW* socket_protocol_info,",
          "1127:                              socket_protocol_info,",
          "",
          "[Added Lines]",
          "1120: int uv_tcp_import(uv_tcp_t* tcp, uv__ipc_socket_info_ex* socket_info_ex,",
          "1126:                              &socket_info_ex->socket_info,",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1141:   err = uv_tcp_set_socket(tcp->loop,",
          "1142:                           tcp,",
          "1143:                           socket,",
          "1145:                           1);",
          "1146:   if (err) {",
          "1147:     closesocket(socket);",
          "",
          "[Removed Lines]",
          "1144:                           socket_protocol_info->iAddressFamily,",
          "",
          "[Added Lines]",
          "1143:                           socket_info_ex->socket_info.iAddressFamily,",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1156:   tcp->flags |= UV_HANDLE_BOUND;",
          "1157:   tcp->flags |= UV_HANDLE_SHARED_TCP_SOCKET;",
          "1159:   tcp->loop->active_tcp_streams++;",
          "1160:   return 0;",
          "1161: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1158:   tcp->delayed_error = socket_info_ex->delayed_error;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1216:         return ERROR_INVALID_PARAMETER;",
          "1217:       }",
          "1226:       }",
          "1227:     }",
          "1228:   }",
          "",
          "[Removed Lines]",
          "1220:       if (handle->flags & UV_HANDLE_BIND_ERROR) {",
          "1221:         return handle->bind_error;",
          "1222:       }",
          "1224:       if (listen(handle->socket, SOMAXCONN) == SOCKET_ERROR) {",
          "1225:         return WSAGetLastError();",
          "",
          "[Added Lines]",
          "1220:       if (!(handle->delayed_error)) {",
          "1221:         if (listen(handle->socket, SOMAXCONN) == SOCKET_ERROR) {",
          "1222:           handle->delayed_error = WSAGetLastError();",
          "1223:         }",
          "",
          "---------------"
        ],
        "test/run-tests.c||test/run-tests.c": [
          "File: test/run-tests.c -> test/run-tests.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: int ipc_helper(int listen_after_write);",
          "40: int ipc_helper_tcp_connection(void);",
          "41: int ipc_send_recv_helper(void);",
          "42: int stdio_over_pipes_helper(void);",
          "44: static int maybe_run_test(int argc, char **argv);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "42: int ipc_helper_bind_twice(void);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "82:     return ipc_helper_tcp_connection();",
          "83:   }",
          "85:   if (strcmp(argv[1], \"stdio_over_pipes_helper\") == 0) {",
          "86:     return stdio_over_pipes_helper();",
          "87:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "86:   if (strcmp(argv[1], \"ipc_helper_bind_twice\") == 0) {",
          "87:     return ipc_helper_bind_twice();",
          "88:   }",
          "",
          "---------------"
        ],
        "test/test-ipc.c||test/test-ipc.c": [
          "File: test/test-ipc.c -> test/test-ipc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: static uv_pipe_t channel;",
          "29: static uv_tcp_t tcp_server;",
          "30: static uv_tcp_t tcp_connection;",
          "32: static int exit_cb_called;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: static uv_tcp_t tcp_server2;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "38: static int remote_conn_accepted;",
          "39: static int tcp_server_listening;",
          "40: static uv_write_t write_req;",
          "43: static uv_write_t conn_notify_req;",
          "44: static int close_cb_called;",
          "45: static int connection_accepted;",
          "",
          "[Removed Lines]",
          "41: static uv_pipe_t channel;",
          "42: static uv_tcp_t tcp_server;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "205:   free(buf->base);",
          "206: }",
          "209: void spawn_helper(uv_pipe_t* channel,",
          "210:                   uv_process_t* process,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "207: #ifdef _WIN32",
          "208: static void on_read_listen_after_bound_twice(uv_stream_t* handle,",
          "209:                                              ssize_t nread,",
          "210:                                              const uv_buf_t* buf) {",
          "211:   int r;",
          "212:   uv_pipe_t* pipe;",
          "213:   uv_handle_type pending;",
          "215:   pipe = (uv_pipe_t*) handle;",
          "217:   if (nread == 0) {",
          "219:     free(buf->base);",
          "220:     return;",
          "221:   }",
          "223:   if (nread < 0) {",
          "224:     if (nread == UV_EOF) {",
          "225:       free(buf->base);",
          "226:       return;",
          "227:     }",
          "229:     printf(\"error recving on channel: %s\\n\", uv_strerror(nread));",
          "230:     abort();",
          "231:   }",
          "233:   fprintf(stderr, \"got %d bytes\\n\", (int)nread);",
          "235:   ASSERT(uv_pipe_pending_count(pipe) > 0);",
          "236:   pending = uv_pipe_pending_type(pipe);",
          "237:   ASSERT(nread > 0 && buf->base && pending != UV_UNKNOWN_HANDLE);",
          "238:   read_cb_called++;",
          "240:   if (read_cb_called == 1) {",
          "242:     ASSERT(pending == UV_TCP);",
          "243:     r = uv_tcp_init(uv_default_loop(), &tcp_server);",
          "244:     ASSERT(r == 0);",
          "246:     r = uv_accept((uv_stream_t*)pipe, (uv_stream_t*)&tcp_server);",
          "247:     ASSERT(r == 0);",
          "249:     r = uv_listen((uv_stream_t*)&tcp_server, 12, on_connection);",
          "250:     ASSERT(r == 0);",
          "251:   } else if (read_cb_called == 2) {",
          "253:     ASSERT(pending == UV_TCP);",
          "254:     r = uv_tcp_init(uv_default_loop(), &tcp_server2);",
          "255:     ASSERT(r == 0);",
          "257:     r = uv_accept((uv_stream_t*)pipe, (uv_stream_t*)&tcp_server2);",
          "258:     ASSERT(r == 0);",
          "260:     r = uv_listen((uv_stream_t*)&tcp_server2, 12, on_connection);",
          "261:     ASSERT(r == UV_EADDRINUSE);",
          "263:     uv_close((uv_handle_t*)&tcp_server, NULL);",
          "264:     uv_close((uv_handle_t*)&tcp_server2, NULL);",
          "265:     ASSERT(0 == uv_pipe_pending_count(pipe));",
          "266:     uv_close((uv_handle_t*)&channel, NULL);",
          "267:   }",
          "269:   free(buf->base);",
          "270: }",
          "271: #endif",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "424:   MAKE_VALGRIND_HAPPY();",
          "425:   return 0;",
          "426: }",
          "427: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "492: TEST_IMPL(ipc_listen_after_bind_twice) {",
          "493:   int r = run_ipc_test(\"ipc_helper_bind_twice\", on_read_listen_after_bound_twice);",
          "494:   ASSERT(read_cb_called == 2);",
          "495:   ASSERT(exit_cb_called == 1);",
          "496:   return r;",
          "497: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "657:   MAKE_VALGRIND_HAPPY();",
          "658:   return 0;",
          "659: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "732: int ipc_helper_bind_twice(void) {",
          "737:   struct sockaddr_in addr;",
          "738:   uv_write_t write_req;",
          "739:   uv_write_t write_req2;",
          "740:   int r;",
          "741:   uv_buf_t buf;",
          "743:   ASSERT(0 == uv_ip4_addr(\"0.0.0.0\", TEST_PORT, &addr));",
          "745:   r = uv_pipe_init(uv_default_loop(), &channel, 1);",
          "746:   ASSERT(r == 0);",
          "748:   uv_pipe_open(&channel, 0);",
          "750:   ASSERT(1 == uv_is_readable((uv_stream_t*) &channel));",
          "751:   ASSERT(1 == uv_is_writable((uv_stream_t*) &channel));",
          "752:   ASSERT(0 == uv_is_closing((uv_handle_t*) &channel));",
          "754:   buf = uv_buf_init(\"hello\\n\", 6);",
          "756:   r = uv_tcp_init(uv_default_loop(), &tcp_server);",
          "757:   ASSERT(r == 0);",
          "758:   r = uv_tcp_init(uv_default_loop(), &tcp_server2);",
          "759:   ASSERT(r == 0);",
          "761:   r = uv_tcp_bind(&tcp_server, (const struct sockaddr*) &addr, 0);",
          "762:   ASSERT(r == 0);",
          "763:   r = uv_tcp_bind(&tcp_server2, (const struct sockaddr*) &addr, 0);",
          "764:   ASSERT(r == 0);",
          "766:   r = uv_write2(&write_req, (uv_stream_t*)&channel, &buf, 1,",
          "767:                 (uv_stream_t*)&tcp_server, NULL);",
          "768:   ASSERT(r == 0);",
          "769:   r = uv_write2(&write_req2, (uv_stream_t*)&channel, &buf, 1,",
          "770:                 (uv_stream_t*)&tcp_server2, NULL);",
          "771:   ASSERT(r == 0);",
          "773:   r = uv_run(uv_default_loop(), UV_RUN_DEFAULT);",
          "774:   ASSERT(r == 0);",
          "776:   MAKE_VALGRIND_HAPPY();",
          "777:   return 0;",
          "778: }",
          "",
          "---------------"
        ],
        "test/test-list.h||test/test-list.h": [
          "File: test/test-list.h -> test/test-list.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "258: TEST_DECLARE   (listen_no_simultaneous_accepts)",
          "259: TEST_DECLARE   (fs_stat_root)",
          "260: TEST_DECLARE   (spawn_with_an_odd_path)",
          "261: #else",
          "262: TEST_DECLARE   (emfile)",
          "263: TEST_DECLARE   (close_fd)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "261: TEST_DECLARE   (ipc_listen_after_bind_twice)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "526:   TEST_ENTRY  (listen_no_simultaneous_accepts)",
          "527:   TEST_ENTRY  (fs_stat_root)",
          "528:   TEST_ENTRY  (spawn_with_an_odd_path)",
          "529: #else",
          "530:   TEST_ENTRY  (emfile)",
          "531:   TEST_ENTRY  (close_fd)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "530:   TEST_ENTRY  (ipc_listen_after_bind_twice)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "315d7001e8e0a86f30dda68b237d0b25dce48d73",
      "candidate_info": {
        "commit_hash": "315d7001e8e0a86f30dda68b237d0b25dce48d73",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/315d7001e8e0a86f30dda68b237d0b25dce48d73",
        "files": [
          "src/win/winapi.c",
          "src/win/winapi.h"
        ],
        "message": "windows: make it possible to use NtQueryVolumeInformationFile\n\nThis commit adds bootstrap code, function signatures, struct definitions\netc. to make it possible for libuv to use NtQueryVolumeInformationFile.\n\nMost of this comes from the NT DDK, which libuv mirrors so that people\ndon't need the DDK to compile it.",
        "before_after_code_files": [
          "src/win/winapi.c||src/win/winapi.c",
          "src/win/winapi.h||src/win/winapi.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/win/winapi.c||src/win/winapi.c": [
          "File: src/win/winapi.c -> src/win/winapi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: sNtDeviceIoControlFile pNtDeviceIoControlFile;",
          "31: sNtQueryInformationFile pNtQueryInformationFile;",
          "32: sNtSetInformationFile pNtSetInformationFile;",
          "33: sNtQuerySystemInformation pNtQuerySystemInformation;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "33: sNtQueryVolumeInformationFile pNtQueryVolumeInformationFile;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "68:     uv_fatal_error(GetLastError(), \"GetProcAddress\");",
          "69:   }",
          "72:       ntdll_module,",
          "75:     uv_fatal_error(GetLastError(), \"GetProcAddress\");",
          "76:   }",
          "79:       ntdll_module,",
          "82:     uv_fatal_error(GetLastError(), \"GetProcAddress\");",
          "83:   }",
          "",
          "[Removed Lines]",
          "71:   pNtQueryInformationFile = (sNtQueryInformationFile) GetProcAddress(",
          "73:       \"NtQueryInformationFile\");",
          "74:   if (pNtQueryInformationFile == NULL) {",
          "78:   pNtDeviceIoControlFile = (sNtDeviceIoControlFile) GetProcAddress(",
          "80:       \"NtDeviceIoControlFile\");",
          "81:   if (pNtDeviceIoControlFile == NULL) {",
          "",
          "[Added Lines]",
          "72:   pNtDeviceIoControlFile = (sNtDeviceIoControlFile) GetProcAddress(",
          "74:       \"NtDeviceIoControlFile\");",
          "75:   if (pNtDeviceIoControlFile == NULL) {",
          "79:   pNtQueryInformationFile = (sNtQueryInformationFile) GetProcAddress(",
          "81:       \"NtQueryInformationFile\");",
          "82:   if (pNtQueryInformationFile == NULL) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "89:     uv_fatal_error(GetLastError(), \"GetProcAddress\");",
          "90:   }",
          "92:   pNtQuerySystemInformation = (sNtQuerySystemInformation) GetProcAddress(",
          "93:       ntdll_module,",
          "94:       \"NtQuerySystemInformation\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "93:   pNtQueryVolumeInformationFile = (sNtQueryVolumeInformationFile)",
          "94:       GetProcAddress(ntdll_module, \"NtQueryVolumeInformationFile\");",
          "95:   if (pNtQueryVolumeInformationFile == NULL) {",
          "96:     uv_fatal_error(GetLastError(), \"GetProcAddress\");",
          "97:   }",
          "",
          "---------------"
        ],
        "src/win/winapi.h||src/win/winapi.h": [
          "File: src/win/winapi.h -> src/win/winapi.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "4282: #define FILE_SYNCHRONOUS_IO_ALERT               0x00000010",
          "4283: #define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020",
          "4285: typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION {",
          "4286:     LARGE_INTEGER IdleTime;",
          "4287:     LARGE_INTEGER KernelTime;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4285: typedef enum _FS_INFORMATION_CLASS {",
          "4286:   FileFsVolumeInformation       = 1,",
          "4287:   FileFsLabelInformation        = 2,",
          "4288:   FileFsSizeInformation         = 3,",
          "4289:   FileFsDeviceInformation       = 4,",
          "4290:   FileFsAttributeInformation    = 5,",
          "4291:   FileFsControlInformation      = 6,",
          "4292:   FileFsFullSizeInformation     = 7,",
          "4293:   FileFsObjectIdInformation     = 8,",
          "4294:   FileFsDriverPathInformation   = 9,",
          "4295:   FileFsVolumeFlagsInformation  = 10,",
          "4296:   FileFsSectorSizeInformation   = 11",
          "4297: } FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;",
          "4299: typedef struct _FILE_FS_VOLUME_INFORMATION {",
          "4300:   LARGE_INTEGER VolumeCreationTime;",
          "4301:   ULONG         VolumeSerialNumber;",
          "4302:   ULONG         VolumeLabelLength;",
          "4303:   BOOLEAN       SupportsObjects;",
          "4304:   WCHAR         VolumeLabel[1];",
          "4305: } FILE_FS_VOLUME_INFORMATION, *PFILE_FS_VOLUME_INFORMATION;",
          "4307: typedef struct _FILE_FS_LABEL_INFORMATION {",
          "4308:   ULONG VolumeLabelLength;",
          "4309:   WCHAR VolumeLabel[1];",
          "4310: } FILE_FS_LABEL_INFORMATION, *PFILE_FS_LABEL_INFORMATION;",
          "4312: typedef struct _FILE_FS_SIZE_INFORMATION {",
          "4313:   LARGE_INTEGER TotalAllocationUnits;",
          "4314:   LARGE_INTEGER AvailableAllocationUnits;",
          "4315:   ULONG         SectorsPerAllocationUnit;",
          "4316:   ULONG         BytesPerSector;",
          "4317: } FILE_FS_SIZE_INFORMATION, *PFILE_FS_SIZE_INFORMATION;",
          "4319: typedef struct _FILE_FS_DEVICE_INFORMATION {",
          "4320:   DEVICE_TYPE DeviceType;",
          "4321:   ULONG       Characteristics;",
          "4322: } FILE_FS_DEVICE_INFORMATION, *PFILE_FS_DEVICE_INFORMATION;",
          "4324: typedef struct _FILE_FS_ATTRIBUTE_INFORMATION {",
          "4325:   ULONG FileSystemAttributes;",
          "4326:   LONG  MaximumComponentNameLength;",
          "4327:   ULONG FileSystemNameLength;",
          "4328:   WCHAR FileSystemName[1];",
          "4329: } FILE_FS_ATTRIBUTE_INFORMATION, *PFILE_FS_ATTRIBUTE_INFORMATION;",
          "4331: typedef struct _FILE_FS_CONTROL_INFORMATION {",
          "4332:   LARGE_INTEGER FreeSpaceStartFiltering;",
          "4333:   LARGE_INTEGER FreeSpaceThreshold;",
          "4334:   LARGE_INTEGER FreeSpaceStopFiltering;",
          "4335:   LARGE_INTEGER DefaultQuotaThreshold;",
          "4336:   LARGE_INTEGER DefaultQuotaLimit;",
          "4337:   ULONG         FileSystemControlFlags;",
          "4338: } FILE_FS_CONTROL_INFORMATION, *PFILE_FS_CONTROL_INFORMATION;",
          "4340: typedef struct _FILE_FS_FULL_SIZE_INFORMATION {",
          "4341:   LARGE_INTEGER TotalAllocationUnits;",
          "4342:   LARGE_INTEGER CallerAvailableAllocationUnits;",
          "4343:   LARGE_INTEGER ActualAvailableAllocationUnits;",
          "4344:   ULONG         SectorsPerAllocationUnit;",
          "4345:   ULONG         BytesPerSector;",
          "4346: } FILE_FS_FULL_SIZE_INFORMATION, *PFILE_FS_FULL_SIZE_INFORMATION;",
          "4348: typedef struct _FILE_FS_OBJECTID_INFORMATION {",
          "4349:   UCHAR ObjectId[16];",
          "4350:   UCHAR ExtendedInfo[48];",
          "4351: } FILE_FS_OBJECTID_INFORMATION, *PFILE_FS_OBJECTID_INFORMATION;",
          "4353: typedef struct _FILE_FS_DRIVER_PATH_INFORMATION {",
          "4354:   BOOLEAN DriverInPath;",
          "4355:   ULONG   DriverNameLength;",
          "4356:   WCHAR   DriverName[1];",
          "4357: } FILE_FS_DRIVER_PATH_INFORMATION, *PFILE_FS_DRIVER_PATH_INFORMATION;",
          "4359: typedef struct _FILE_FS_VOLUME_FLAGS_INFORMATION {",
          "4360:   ULONG Flags;",
          "4361: } FILE_FS_VOLUME_FLAGS_INFORMATION, *PFILE_FS_VOLUME_FLAGS_INFORMATION;",
          "4363: typedef struct _FILE_FS_SECTOR_SIZE_INFORMATION {",
          "4364:   ULONG LogicalBytesPerSector;",
          "4365:   ULONG PhysicalBytesPerSectorForAtomicity;",
          "4366:   ULONG PhysicalBytesPerSectorForPerformance;",
          "4367:   ULONG FileSystemEffectivePhysicalBytesPerSectorForAtomicity;",
          "4368:   ULONG Flags;",
          "4369:   ULONG ByteOffsetForSectorAlignment;",
          "4370:   ULONG ByteOffsetForPartitionAlignment;",
          "4371: } FILE_FS_SECTOR_SIZE_INFORMATION, *PFILE_FS_SECTOR_SIZE_INFORMATION;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4411:                   ULONG Length,",
          "4412:                   FILE_INFORMATION_CLASS FileInformationClass);",
          "4414: typedef NTSTATUS (NTAPI *sNtQuerySystemInformation)",
          "4415:                  (UINT SystemInformationClass,",
          "4416:                   PVOID SystemInformation,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4502: typedef NTSTATUS (NTAPI *sNtQueryVolumeInformationFile)",
          "4503:                  (HANDLE FileHandle,",
          "4504:                   PIO_STATUS_BLOCK IoStatusBlock,",
          "4505:                   PVOID FsInformation,",
          "4506:                   ULONG Length,",
          "4507:                   FS_INFORMATION_CLASS FsInformationClass);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4528: extern sNtDeviceIoControlFile pNtDeviceIoControlFile;",
          "4529: extern sNtQueryInformationFile pNtQueryInformationFile;",
          "4530: extern sNtSetInformationFile pNtSetInformationFile;",
          "4531: extern sNtQuerySystemInformation pNtQuerySystemInformation;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4626: extern sNtQueryVolumeInformationFile pNtQueryVolumeInformationFile;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "394d2188ba725f47d5e28e8dc090489cb6c1cc7f",
      "candidate_info": {
        "commit_hash": "394d2188ba725f47d5e28e8dc090489cb6c1cc7f",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/394d2188ba725f47d5e28e8dc090489cb6c1cc7f",
        "files": [
          "uv.gyp"
        ],
        "message": "build: remove unneeded define in uv.gyp\n\nIt's a leftover from the days libuv bundled c-ares.",
        "before_after_code_files": [
          "uv.gyp||uv.gyp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "uv.gyp||uv.gyp": [
          "File: uv.gyp -> uv.gyp",
          "--- Hunk 1 ---",
          "[Context before]",
          "53:           }],",
          "54:         ],",
          "55:       },",
          "59:       'sources': [",
          "60:         'common.gypi',",
          "61:         'include/uv.h',",
          "",
          "[Removed Lines]",
          "56:       'defines': [",
          "57:         'HAVE_CONFIG_H'",
          "58:       ],",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
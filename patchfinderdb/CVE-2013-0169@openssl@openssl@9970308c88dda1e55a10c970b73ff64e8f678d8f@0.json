{
  "cve_id": "CVE-2013-0169",
  "cve_desc": "The TLS protocol 1.1 and 1.2 and the DTLS protocol 1.0 and 1.2, as used in OpenSSL, OpenJDK, PolarSSL, and other products, do not properly consider timing side-channel attacks on a MAC check requirement during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, aka the \"Lucky Thirteen\" issue.",
  "repo": "openssl/openssl",
  "patch_hash": "9970308c88dda1e55a10c970b73ff64e8f678d8f",
  "patch_info": {
    "commit_hash": "9970308c88dda1e55a10c970b73ff64e8f678d8f",
    "repo": "openssl/openssl",
    "commit_url": "https://github.com/openssl/openssl/commit/9970308c88dda1e55a10c970b73ff64e8f678d8f",
    "files": [
      "crypto/evp/c_allc.c",
      "crypto/evp/e_aes_cbc_hmac_sha1.c",
      "ssl/s3_cbc.c",
      "ssl/ssl_algs.c"
    ],
    "message": "e_aes_cbc_hmac_sha1.c: address the CBC decrypt timing issues.\n\nAddress CBC decrypt timing issues and reenable the AESNI+SHA1 stitch.\n(cherry picked from commit 125093b59f3c2a2d33785b5563d929d0472f1721)",
    "before_after_code_files": [
      "crypto/evp/c_allc.c||crypto/evp/c_allc.c",
      "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c",
      "ssl/s3_cbc.c||ssl/s3_cbc.c",
      "ssl/ssl_algs.c||ssl/ssl_algs.c"
    ]
  },
  "patch_diff": {
    "crypto/evp/c_allc.c||crypto/evp/c_allc.c": [
      "File: crypto/evp/c_allc.c -> crypto/evp/c_allc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "195:  EVP_add_cipher(EVP_aes_256_xts());",
      "196:  EVP_add_cipher_alias(SN_aes_256_cbc,\"AES256\");",
      "197:  EVP_add_cipher_alias(SN_aes_256_cbc,\"aes256\");",
      "199: #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)",
      "200:  EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());",
      "201:  EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());",
      "202: #endif",
      "203: #endif",
      "206: #ifndef OPENSSL_NO_CAMELLIA",
      "207:  EVP_add_cipher(EVP_camellia_128_ecb());",
      "",
      "[Removed Lines]",
      "204: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c": [
      "File: crypto/evp/e_aes_cbc_hmac_sha1.c -> crypto/evp/e_aes_cbc_hmac_sha1.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "89:  defined(_M_AMD64) || defined(_M_X64) || \\",
      "90:  defined(__INTEL__) )",
      "92: extern unsigned int OPENSSL_ia32cap_P[2];",
      "93: #define AESNI_CAPABLE   (1<<(57-32))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "92: #if defined(__GNUC__) && __GNUC__>=2 && !defined(PEDANTIC)",
      "93: # define BSWAP(x) ({ unsigned int r=(x); asm (\"bswapl %0\":\"=r\"(r):\"0\"(r)); r; })",
      "94: #endif",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "166:   SHA1_Update(c,ptr,res);",
      "167: }",
      "169: #define SHA1_Update sha1_update",
      "171: static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "173: #ifdef SHA1_Update",
      "174: #undef SHA1_Update",
      "175: #endif",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "183:  sha_off = SHA_CBLOCK-key->md.num;",
      "184: #endif",
      "186:  if (len%AES_BLOCK_SIZE) return 0;",
      "188:  if (ctx->encrypt) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "193:  key->payload_length = NO_PAYLOAD_LENGTH;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "233:      &key->ks,ctx->iv,1);",
      "234:   }",
      "235:  } else {",
      "239:   aesni_cbc_encrypt(in,out,len,",
      "240:     &key->ks,ctx->iv,0);",
      "249:    if ((key->aux.tls_aad[plen-4]<<8|key->aux.tls_aad[plen-3])",
      "252:     iv = AES_BLOCK_SIZE;",
      "259:    key->md = key->head;",
      "260:    SHA1_Update(&key->md,key->aux.tls_aad,plen);",
      "264:    key->md = key->tail;",
      "270:   } else {",
      "271:    SHA1_Update(&key->md,out,len);",
      "272:   }",
      "273:  }",
      "277:  return 1;",
      "278:  }",
      "",
      "[Removed Lines]",
      "236:   unsigned char mac[SHA_DIGEST_LENGTH];",
      "244:    if (len<(size_t)(out[len-1]+1+SHA_DIGEST_LENGTH))",
      "245:     return 0;",
      "247:    len -= (out[len-1]+1+SHA_DIGEST_LENGTH);",
      "250:        >= TLS1_1_VERSION) {",
      "251:     len -= AES_BLOCK_SIZE;",
      "253:    }",
      "255:    key->aux.tls_aad[plen-2] = len>>8;",
      "256:    key->aux.tls_aad[plen-1] = len;",
      "261:    SHA1_Update(&key->md,out+iv,len);",
      "262:    SHA1_Final(mac,&key->md);",
      "265:    SHA1_Update(&key->md,mac,SHA_DIGEST_LENGTH);",
      "266:    SHA1_Final(mac,&key->md);",
      "268:    if (memcmp(out+iv+len,mac,SHA_DIGEST_LENGTH))",
      "269:     return 0;",
      "275:  key->payload_length = NO_PAYLOAD_LENGTH;",
      "",
      "[Added Lines]",
      "245:   union { unsigned int  u[SHA_DIGEST_LENGTH/sizeof(unsigned int)];",
      "246:    unsigned char c[SHA_DIGEST_LENGTH]; } mac;",
      "253:    size_t inp_len, mask, j, i;",
      "254:    unsigned int res, maxpad, pad, bitlen;",
      "255:    int ret = 1;",
      "256:    union { unsigned int  u[SHA_LBLOCK];",
      "257:     unsigned char c[SHA_CBLOCK]; }",
      "261:        >= TLS1_1_VERSION)",
      "264:    if (len<(iv+SHA_DIGEST_LENGTH+1))",
      "265:     return 0;",
      "268:    out += iv;",
      "269:    len -= iv;",
      "272:    pad = out[len-1];",
      "273:    maxpad = len-(SHA_DIGEST_LENGTH+1);",
      "274:    maxpad |= (255-maxpad)>>(sizeof(maxpad)*8-8);",
      "275:    maxpad &= 255;",
      "277:    inp_len = len - (SHA_DIGEST_LENGTH+pad+1);",
      "278:    mask = (0-((inp_len-len)>>(sizeof(inp_len)*8-1)));",
      "279:    inp_len &= mask;",
      "280:    ret &= (int)mask;",
      "282:    key->aux.tls_aad[plen-2] = inp_len>>8;",
      "283:    key->aux.tls_aad[plen-1] = inp_len;",
      "289: #if 1",
      "291:    if (len>=(256+SHA_CBLOCK)) {",
      "292:     j = (len-(256+SHA_CBLOCK))&(0-SHA_CBLOCK);",
      "293:     j += SHA_CBLOCK-key->md.num;",
      "294:     SHA1_Update(&key->md,out,j);",
      "295:     out += j;",
      "296:     len -= j;",
      "297:     inp_len -= j;",
      "298:    }",
      "302:    mac.c[0] = 0;",
      "303:    mac.c[1] = (unsigned char)(bitlen>>16);",
      "304:    mac.c[2] = (unsigned char)(bitlen>>8);",
      "305:    mac.c[3] = (unsigned char)bitlen;",
      "306:    bitlen = mac.u[0];",
      "308:    mac.u[0]=0;",
      "309:    mac.u[1]=0;",
      "310:    mac.u[2]=0;",
      "311:    mac.u[3]=0;",
      "312:    mac.u[4]=0;",
      "314:    for (res=key->md.num, j=0;j<len;j++) {",
      "315:     size_t c = out[j];",
      "316:     mask = (j-inp_len)>>(sizeof(j)*8-8);",
      "317:     c &= mask;",
      "318:     c |= 0x80&~mask&~((inp_len-j)>>(sizeof(j)*8-8));",
      "319:     data->c[res++]=(unsigned char)c;",
      "321:     if (res!=SHA_CBLOCK) continue;",
      "323:     mask = 0-((inp_len+8-j)>>(sizeof(j)*8-1));",
      "324:     data->u[SHA_LBLOCK-1] |= bitlen&mask;",
      "325:     sha1_block_data_order(&key->md,data,1);",
      "326:     mask &= 0-((j-inp_len-73)>>(sizeof(j)*8-1));",
      "327:     mac.u[0] |= key->md.h0 & mask;",
      "328:     mac.u[1] |= key->md.h1 & mask;",
      "329:     mac.u[2] |= key->md.h2 & mask;",
      "330:     mac.u[3] |= key->md.h3 & mask;",
      "331:     mac.u[4] |= key->md.h4 & mask;",
      "332:     res=0;",
      "333:    }",
      "335:    for(i=res;i<SHA_CBLOCK;i++,j++) data->c[i]=0;",
      "337:    if (res>SHA_CBLOCK-8) {",
      "338:     mask = 0-((inp_len+8-j)>>(sizeof(j)*8-1));",
      "339:     data->u[SHA_LBLOCK-1] |= bitlen&mask;",
      "340:     sha1_block_data_order(&key->md,data,1);",
      "341:     mask &= 0-((j-inp_len-73)>>(sizeof(j)*8-1));",
      "342:     mac.u[0] |= key->md.h0 & mask;",
      "343:     mac.u[1] |= key->md.h1 & mask;",
      "344:     mac.u[2] |= key->md.h2 & mask;",
      "345:     mac.u[3] |= key->md.h3 & mask;",
      "346:     mac.u[4] |= key->md.h4 & mask;",
      "348:     memset(data,0,SHA_CBLOCK);",
      "349:     j+=64;",
      "350:    }",
      "351:    data->u[SHA_LBLOCK-1] = bitlen;",
      "352:    sha1_block_data_order(&key->md,data,1);",
      "353:    mask = 0-((j-inp_len-73)>>(sizeof(j)*8-1));",
      "354:    mac.u[0] |= key->md.h0 & mask;",
      "355:    mac.u[1] |= key->md.h1 & mask;",
      "356:    mac.u[2] |= key->md.h2 & mask;",
      "357:    mac.u[3] |= key->md.h3 & mask;",
      "358:    mac.u[4] |= key->md.h4 & mask;",
      "360: #ifdef BSWAP",
      "361:    mac.u[0] = BSWAP(mac.u[0]);",
      "362:    mac.u[1] = BSWAP(mac.u[1]);",
      "363:    mac.u[2] = BSWAP(mac.u[2]);",
      "364:    mac.u[3] = BSWAP(mac.u[3]);",
      "365:    mac.u[4] = BSWAP(mac.u[4]);",
      "366: #else",
      "367:    for (i=0;i<5;i++) {",
      "368:     res = mac.u[i];",
      "369:     mac.c[4*i+0]=(unsigned char)(res>>24);",
      "370:     mac.c[4*i+1]=(unsigned char)(res>>16);",
      "371:     mac.c[4*i+2]=(unsigned char)(res>>8);",
      "372:     mac.c[4*i+3]=(unsigned char)res;",
      "373:    }",
      "374: #endif",
      "375:    len += SHA_DIGEST_LENGTH;",
      "376: #else",
      "377:    SHA1_Update(&key->md,out,inp_len);",
      "378:    res = key->md.num;",
      "379:    SHA1_Final(mac.c,&key->md);",
      "381:    {",
      "382:    unsigned int inp_blocks, pad_blocks;",
      "385:    inp_blocks = 1+((SHA_CBLOCK-9-res)>>(sizeof(res)*8-1));",
      "386:    res += (unsigned int)(len-inp_len);",
      "387:    pad_blocks = res / SHA_CBLOCK;",
      "388:    res %= SHA_CBLOCK;",
      "389:    pad_blocks += 1+((SHA_CBLOCK-9-res)>>(sizeof(res)*8-1));",
      "390:    for (;inp_blocks<pad_blocks;inp_blocks++)",
      "391:     sha1_block_data_order(&key->md,data,1);",
      "392:    }",
      "393: #endif",
      "395:    SHA1_Update(&key->md,mac.c,SHA_DIGEST_LENGTH);",
      "396:    SHA1_Final(mac.c,&key->md);",
      "399:    out += inp_len;",
      "400:    len -= inp_len;",
      "401: #if 1",
      "402:    {",
      "403:    unsigned char *p = out+len-1-maxpad-SHA_DIGEST_LENGTH;",
      "404:    size_t off = out-p;",
      "405:    unsigned int c, cmask;",
      "407:    maxpad += SHA_DIGEST_LENGTH;",
      "408:    for (res=0,i=0,j=0;j<maxpad;j++) {",
      "409:     c = p[j];",
      "410:     cmask = ((int)(j-off-SHA_DIGEST_LENGTH))>>(sizeof(int)*8-1);",
      "412:     cmask &= ((int)(off-1-j))>>(sizeof(int)*8-1);",
      "413:     res |= (c^mac.c[i])&cmask;",
      "414:     i += 1&cmask;",
      "415:    }",
      "416:    maxpad -= SHA_DIGEST_LENGTH;",
      "418:    res = 0-((0-res)>>(sizeof(res)*8-1));",
      "419:    ret &= (int)~res;",
      "420:    }",
      "421: #else",
      "422:    for (res=0,i=0;i<SHA_DIGEST_LENGTH;i++)",
      "423:     res |= out[i]^mac.c[i];",
      "424:    res = 0-((0-res)>>(sizeof(res)*8-1));",
      "425:    ret &= (int)~res;",
      "428:    pad = (pad&~res) | (maxpad&res);",
      "429:    out = out+len-1-pad;",
      "430:    for (res=0,i=0;i<pad;i++)",
      "431:     res |= out[i]^pad;",
      "433:    res = (0-res)>>(sizeof(res)*8-1);",
      "434:    ret &= (int)~res;",
      "435: #endif",
      "436:    return ret;",
      "",
      "---------------"
    ],
    "ssl/s3_cbc.c||ssl/s3_cbc.c": [
      "File: ssl/s3_cbc.c -> ssl/s3_cbc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "150:  if (overhead > rec->length)",
      "151:   return 0;",
      "153:  padding_length = rec->data[rec->length-1];",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "161:  if (has_explicit_iv)",
      "162:   {",
      "163:   rec->data += block_size;",
      "164:   rec->input += block_size;",
      "165:   rec->length -= block_size;",
      "166:   }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "172:    }",
      "173:   }",
      "175:  good = constant_time_ge(rec->length, overhead+padding_length);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "190:  if (EVP_CIPHER_flags(s->enc_read_ctx->cipher)&EVP_CIPH_FLAG_AEAD_CIPHER)",
      "191:   {",
      "193:   rec->length -= padding_length;",
      "194:   return 1;",
      "195:   }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "209:  rec->length -= padding_length;",
      "227:  return (int)((good & 1) | (~good & -1));",
      "228:  }",
      "",
      "[Removed Lines]",
      "220:  if (has_explicit_iv)",
      "221:   {",
      "222:   rec->data += block_size;",
      "223:   rec->input += block_size;",
      "224:   rec->length -= block_size;",
      "225:   }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "ssl/ssl_algs.c||ssl/ssl_algs.c": [
      "File: ssl/ssl_algs.c -> ssl/ssl_algs.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "90:  EVP_add_cipher(EVP_aes_256_cbc());",
      "91:  EVP_add_cipher(EVP_aes_128_gcm());",
      "92:  EVP_add_cipher(EVP_aes_256_gcm());",
      "94: #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)",
      "95:  EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());",
      "96:  EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());",
      "97: #endif",
      "100: #endif",
      "101: #ifndef OPENSSL_NO_CAMELLIA",
      "",
      "[Removed Lines]",
      "98: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "125093b59f3c2a2d33785b5563d929d0472f1721",
      "candidate_info": {
        "commit_hash": "125093b59f3c2a2d33785b5563d929d0472f1721",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/125093b59f3c2a2d33785b5563d929d0472f1721",
        "files": [
          "crypto/evp/c_allc.c",
          "crypto/evp/e_aes_cbc_hmac_sha1.c",
          "ssl/s3_cbc.c",
          "ssl/ssl_algs.c"
        ],
        "message": "e_aes_cbc_hmac_sha1.c: address the CBC decrypt timing issues.\n\nAddress CBC decrypt timing issues and reenable the AESNI+SHA1 stitch.",
        "before_after_code_files": [
          "crypto/evp/c_allc.c||crypto/evp/c_allc.c",
          "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c",
          "ssl/s3_cbc.c||ssl/s3_cbc.c",
          "ssl/ssl_algs.c||ssl/ssl_algs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "crypto/evp/c_allc.c||crypto/evp/c_allc.c",
            "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c",
            "ssl/s3_cbc.c||ssl/s3_cbc.c",
            "ssl/ssl_algs.c||ssl/ssl_algs.c"
          ],
          "candidate": [
            "crypto/evp/c_allc.c||crypto/evp/c_allc.c",
            "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c",
            "ssl/s3_cbc.c||ssl/s3_cbc.c",
            "ssl/ssl_algs.c||ssl/ssl_algs.c"
          ]
        }
      },
      "candidate_diff": {
        "crypto/evp/c_allc.c||crypto/evp/c_allc.c": [
          "File: crypto/evp/c_allc.c -> crypto/evp/c_allc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "195:  EVP_add_cipher(EVP_aes_256_xts());",
          "196:  EVP_add_cipher_alias(SN_aes_256_cbc,\"AES256\");",
          "197:  EVP_add_cipher_alias(SN_aes_256_cbc,\"aes256\");",
          "199: #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)",
          "200:  EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());",
          "201:  EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());",
          "202: #endif",
          "203: #endif",
          "206: #ifndef OPENSSL_NO_CAMELLIA",
          "207:  EVP_add_cipher(EVP_camellia_128_ecb());",
          "",
          "[Removed Lines]",
          "204: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c": [
          "File: crypto/evp/e_aes_cbc_hmac_sha1.c -> crypto/evp/e_aes_cbc_hmac_sha1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "90:  defined(_M_AMD64) || defined(_M_X64) || \\",
          "91:  defined(__INTEL__) )",
          "93: extern unsigned int OPENSSL_ia32cap_P[2];",
          "94: #define AESNI_CAPABLE   (1<<(57-32))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "93: #if defined(__GNUC__) && __GNUC__>=2 && !defined(PEDANTIC)",
          "94: # define BSWAP(x) ({ unsigned int r=(x); asm (\"bswapl %0\":\"=r\"(r):\"0\"(r)); r; })",
          "95: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "167:   SHA1_Update(c,ptr,res);",
          "168: }",
          "170: #define SHA1_Update sha1_update",
          "172: static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "174: #ifdef SHA1_Update",
          "175: #undef SHA1_Update",
          "176: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "184:  sha_off = SHA_CBLOCK-key->md.num;",
          "185: #endif",
          "187:  if (len%AES_BLOCK_SIZE) return 0;",
          "189:  if (ctx->encrypt) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "194:  key->payload_length = NO_PAYLOAD_LENGTH;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "234:      &key->ks,ctx->iv,1);",
          "235:   }",
          "236:  } else {",
          "240:   aesni_cbc_encrypt(in,out,len,",
          "241:     &key->ks,ctx->iv,0);",
          "250:    if ((key->aux.tls_aad[plen-4]<<8|key->aux.tls_aad[plen-3])",
          "253:     iv = AES_BLOCK_SIZE;",
          "260:    key->md = key->head;",
          "261:    SHA1_Update(&key->md,key->aux.tls_aad,plen);",
          "265:    key->md = key->tail;",
          "271:   } else {",
          "272:    SHA1_Update(&key->md,out,len);",
          "273:   }",
          "274:  }",
          "278:  return 1;",
          "279:  }",
          "",
          "[Removed Lines]",
          "237:   unsigned char mac[SHA_DIGEST_LENGTH];",
          "245:    if (len<(size_t)(out[len-1]+1+SHA_DIGEST_LENGTH))",
          "246:     return 0;",
          "248:    len -= (out[len-1]+1+SHA_DIGEST_LENGTH);",
          "251:        >= TLS1_1_VERSION) {",
          "252:     len -= AES_BLOCK_SIZE;",
          "254:    }",
          "256:    key->aux.tls_aad[plen-2] = len>>8;",
          "257:    key->aux.tls_aad[plen-1] = len;",
          "262:    SHA1_Update(&key->md,out+iv,len);",
          "263:    SHA1_Final(mac,&key->md);",
          "266:    SHA1_Update(&key->md,mac,SHA_DIGEST_LENGTH);",
          "267:    SHA1_Final(mac,&key->md);",
          "269:    if (memcmp(out+iv+len,mac,SHA_DIGEST_LENGTH))",
          "270:     return 0;",
          "276:  key->payload_length = NO_PAYLOAD_LENGTH;",
          "",
          "[Added Lines]",
          "246:   union { unsigned int  u[SHA_DIGEST_LENGTH/sizeof(unsigned int)];",
          "247:    unsigned char c[SHA_DIGEST_LENGTH]; } mac;",
          "254:    size_t inp_len, mask, j, i;",
          "255:    unsigned int res, maxpad, pad, bitlen;",
          "256:    int ret = 1;",
          "257:    union { unsigned int  u[SHA_LBLOCK];",
          "258:     unsigned char c[SHA_CBLOCK]; }",
          "262:        >= TLS1_1_VERSION)",
          "265:    if (len<(iv+SHA_DIGEST_LENGTH+1))",
          "266:     return 0;",
          "269:    out += iv;",
          "270:    len -= iv;",
          "273:    pad = out[len-1];",
          "274:    maxpad = len-(SHA_DIGEST_LENGTH+1);",
          "275:    maxpad |= (255-maxpad)>>(sizeof(maxpad)*8-8);",
          "276:    maxpad &= 255;",
          "278:    inp_len = len - (SHA_DIGEST_LENGTH+pad+1);",
          "279:    mask = (0-((inp_len-len)>>(sizeof(inp_len)*8-1)));",
          "280:    inp_len &= mask;",
          "281:    ret &= (int)mask;",
          "283:    key->aux.tls_aad[plen-2] = inp_len>>8;",
          "284:    key->aux.tls_aad[plen-1] = inp_len;",
          "290: #if 1",
          "292:    if (len>=(256+SHA_CBLOCK)) {",
          "293:     j = (len-(256+SHA_CBLOCK))&(0-SHA_CBLOCK);",
          "294:     j += SHA_CBLOCK-key->md.num;",
          "295:     SHA1_Update(&key->md,out,j);",
          "296:     out += j;",
          "297:     len -= j;",
          "298:     inp_len -= j;",
          "299:    }",
          "303:    mac.c[0] = 0;",
          "304:    mac.c[1] = (unsigned char)(bitlen>>16);",
          "305:    mac.c[2] = (unsigned char)(bitlen>>8);",
          "306:    mac.c[3] = (unsigned char)bitlen;",
          "307:    bitlen = mac.u[0];",
          "309:    mac.u[0]=0;",
          "310:    mac.u[1]=0;",
          "311:    mac.u[2]=0;",
          "312:    mac.u[3]=0;",
          "313:    mac.u[4]=0;",
          "315:    for (res=key->md.num, j=0;j<len;j++) {",
          "316:     size_t c = out[j];",
          "317:     mask = (j-inp_len)>>(sizeof(j)*8-8);",
          "318:     c &= mask;",
          "319:     c |= 0x80&~mask&~((inp_len-j)>>(sizeof(j)*8-8));",
          "320:     data->c[res++]=(unsigned char)c;",
          "322:     if (res!=SHA_CBLOCK) continue;",
          "324:     mask = 0-((inp_len+8-j)>>(sizeof(j)*8-1));",
          "325:     data->u[SHA_LBLOCK-1] |= bitlen&mask;",
          "326:     sha1_block_data_order(&key->md,data,1);",
          "327:     mask &= 0-((j-inp_len-73)>>(sizeof(j)*8-1));",
          "328:     mac.u[0] |= key->md.h0 & mask;",
          "329:     mac.u[1] |= key->md.h1 & mask;",
          "330:     mac.u[2] |= key->md.h2 & mask;",
          "331:     mac.u[3] |= key->md.h3 & mask;",
          "332:     mac.u[4] |= key->md.h4 & mask;",
          "333:     res=0;",
          "334:    }",
          "336:    for(i=res;i<SHA_CBLOCK;i++,j++) data->c[i]=0;",
          "338:    if (res>SHA_CBLOCK-8) {",
          "339:     mask = 0-((inp_len+8-j)>>(sizeof(j)*8-1));",
          "340:     data->u[SHA_LBLOCK-1] |= bitlen&mask;",
          "341:     sha1_block_data_order(&key->md,data,1);",
          "342:     mask &= 0-((j-inp_len-73)>>(sizeof(j)*8-1));",
          "343:     mac.u[0] |= key->md.h0 & mask;",
          "344:     mac.u[1] |= key->md.h1 & mask;",
          "345:     mac.u[2] |= key->md.h2 & mask;",
          "346:     mac.u[3] |= key->md.h3 & mask;",
          "347:     mac.u[4] |= key->md.h4 & mask;",
          "349:     memset(data,0,SHA_CBLOCK);",
          "350:     j+=64;",
          "351:    }",
          "352:    data->u[SHA_LBLOCK-1] = bitlen;",
          "353:    sha1_block_data_order(&key->md,data,1);",
          "354:    mask = 0-((j-inp_len-73)>>(sizeof(j)*8-1));",
          "355:    mac.u[0] |= key->md.h0 & mask;",
          "356:    mac.u[1] |= key->md.h1 & mask;",
          "357:    mac.u[2] |= key->md.h2 & mask;",
          "358:    mac.u[3] |= key->md.h3 & mask;",
          "359:    mac.u[4] |= key->md.h4 & mask;",
          "361: #ifdef BSWAP",
          "362:    mac.u[0] = BSWAP(mac.u[0]);",
          "363:    mac.u[1] = BSWAP(mac.u[1]);",
          "364:    mac.u[2] = BSWAP(mac.u[2]);",
          "365:    mac.u[3] = BSWAP(mac.u[3]);",
          "366:    mac.u[4] = BSWAP(mac.u[4]);",
          "367: #else",
          "368:    for (i=0;i<5;i++) {",
          "369:     res = mac.u[i];",
          "370:     mac.c[4*i+0]=(unsigned char)(res>>24);",
          "371:     mac.c[4*i+1]=(unsigned char)(res>>16);",
          "372:     mac.c[4*i+2]=(unsigned char)(res>>8);",
          "373:     mac.c[4*i+3]=(unsigned char)res;",
          "374:    }",
          "375: #endif",
          "376:    len += SHA_DIGEST_LENGTH;",
          "377: #else",
          "378:    SHA1_Update(&key->md,out,inp_len);",
          "379:    res = key->md.num;",
          "380:    SHA1_Final(mac.c,&key->md);",
          "382:    {",
          "383:    unsigned int inp_blocks, pad_blocks;",
          "386:    inp_blocks = 1+((SHA_CBLOCK-9-res)>>(sizeof(res)*8-1));",
          "387:    res += (unsigned int)(len-inp_len);",
          "388:    pad_blocks = res / SHA_CBLOCK;",
          "389:    res %= SHA_CBLOCK;",
          "390:    pad_blocks += 1+((SHA_CBLOCK-9-res)>>(sizeof(res)*8-1));",
          "391:    for (;inp_blocks<pad_blocks;inp_blocks++)",
          "392:     sha1_block_data_order(&key->md,data,1);",
          "393:    }",
          "394: #endif",
          "396:    SHA1_Update(&key->md,mac.c,SHA_DIGEST_LENGTH);",
          "397:    SHA1_Final(mac.c,&key->md);",
          "400:    out += inp_len;",
          "401:    len -= inp_len;",
          "402: #if 1",
          "403:    {",
          "404:    unsigned char *p = out+len-1-maxpad-SHA_DIGEST_LENGTH;",
          "405:    size_t off = out-p;",
          "406:    unsigned int c, cmask;",
          "408:    maxpad += SHA_DIGEST_LENGTH;",
          "409:    for (res=0,i=0,j=0;j<maxpad;j++) {",
          "410:     c = p[j];",
          "411:     cmask = ((int)(j-off-SHA_DIGEST_LENGTH))>>(sizeof(int)*8-1);",
          "413:     cmask &= ((int)(off-1-j))>>(sizeof(int)*8-1);",
          "414:     res |= (c^mac.c[i])&cmask;",
          "415:     i += 1&cmask;",
          "416:    }",
          "417:    maxpad -= SHA_DIGEST_LENGTH;",
          "419:    res = 0-((0-res)>>(sizeof(res)*8-1));",
          "420:    ret &= (int)~res;",
          "421:    }",
          "422: #else",
          "423:    for (res=0,i=0;i<SHA_DIGEST_LENGTH;i++)",
          "424:     res |= out[i]^mac.c[i];",
          "425:    res = 0-((0-res)>>(sizeof(res)*8-1));",
          "426:    ret &= (int)~res;",
          "429:    pad = (pad&~res) | (maxpad&res);",
          "430:    out = out+len-1-pad;",
          "431:    for (res=0,i=0;i<pad;i++)",
          "432:     res |= out[i]^pad;",
          "434:    res = (0-res)>>(sizeof(res)*8-1);",
          "435:    ret &= (int)~res;",
          "436: #endif",
          "437:    return ret;",
          "",
          "---------------"
        ],
        "ssl/s3_cbc.c||ssl/s3_cbc.c": [
          "File: ssl/s3_cbc.c -> ssl/s3_cbc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "150:  if (overhead > rec->length)",
          "151:   return 0;",
          "153:  padding_length = rec->data[rec->length-1];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "161:  if (has_explicit_iv)",
          "162:   {",
          "163:   rec->data += block_size;",
          "164:   rec->input += block_size;",
          "165:   rec->length -= block_size;",
          "166:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "172:    }",
          "173:   }",
          "175:  good = constant_time_ge(rec->length, overhead+padding_length);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "190:  if (EVP_CIPHER_flags(s->enc_read_ctx->cipher)&EVP_CIPH_FLAG_AEAD_CIPHER)",
          "191:   {",
          "193:   rec->length -= padding_length;",
          "194:   return 1;",
          "195:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "209:  rec->length -= padding_length;",
          "227:  return (int)((good & 1) | (~good & -1));",
          "228:  }",
          "",
          "[Removed Lines]",
          "220:  if (has_explicit_iv)",
          "221:   {",
          "222:   rec->data += block_size;",
          "223:   rec->input += block_size;",
          "224:   rec->length -= block_size;",
          "225:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "ssl/ssl_algs.c||ssl/ssl_algs.c": [
          "File: ssl/ssl_algs.c -> ssl/ssl_algs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "90:  EVP_add_cipher(EVP_aes_256_cbc());",
          "91:  EVP_add_cipher(EVP_aes_128_gcm());",
          "92:  EVP_add_cipher(EVP_aes_256_gcm());",
          "94: #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)",
          "95:  EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());",
          "96:  EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());",
          "97: #endif",
          "100: #endif",
          "101: #ifndef OPENSSL_NO_CAMELLIA",
          "",
          "[Removed Lines]",
          "98: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5966f4d973fc87dbf6bc7f86c5b95cf4e63cec84",
      "candidate_info": {
        "commit_hash": "5966f4d973fc87dbf6bc7f86c5b95cf4e63cec84",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/5966f4d973fc87dbf6bc7f86c5b95cf4e63cec84",
        "files": [
          "crypto/evp/c_allc.c",
          "crypto/evp/e_aes_cbc_hmac_sha1.c",
          "ssl/s3_cbc.c",
          "ssl/ssl_algs.c"
        ],
        "message": "e_aes_cbc_hmac_sha1.c: address the CBC decrypt timing issues.\n\nAddress CBC decrypt timing issues and reenable the AESNI+SHA1 stitch.\n(cherry picked from commit 125093b59f3c2a2d33785b5563d929d0472f1721)",
        "before_after_code_files": [
          "crypto/evp/c_allc.c||crypto/evp/c_allc.c",
          "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c",
          "ssl/s3_cbc.c||ssl/s3_cbc.c",
          "ssl/ssl_algs.c||ssl/ssl_algs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "crypto/evp/c_allc.c||crypto/evp/c_allc.c",
            "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c",
            "ssl/s3_cbc.c||ssl/s3_cbc.c",
            "ssl/ssl_algs.c||ssl/ssl_algs.c"
          ],
          "candidate": [
            "crypto/evp/c_allc.c||crypto/evp/c_allc.c",
            "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c",
            "ssl/s3_cbc.c||ssl/s3_cbc.c",
            "ssl/ssl_algs.c||ssl/ssl_algs.c"
          ]
        }
      },
      "candidate_diff": {
        "crypto/evp/c_allc.c||crypto/evp/c_allc.c": [
          "File: crypto/evp/c_allc.c -> crypto/evp/c_allc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "195:  EVP_add_cipher(EVP_aes_256_xts());",
          "196:  EVP_add_cipher_alias(SN_aes_256_cbc,\"AES256\");",
          "197:  EVP_add_cipher_alias(SN_aes_256_cbc,\"aes256\");",
          "199: #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)",
          "200:  EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());",
          "201:  EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());",
          "202: #endif",
          "203: #endif",
          "206: #ifndef OPENSSL_NO_CAMELLIA",
          "207:  EVP_add_cipher(EVP_camellia_128_ecb());",
          "",
          "[Removed Lines]",
          "204: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c": [
          "File: crypto/evp/e_aes_cbc_hmac_sha1.c -> crypto/evp/e_aes_cbc_hmac_sha1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "90:  defined(_M_AMD64) || defined(_M_X64) || \\",
          "91:  defined(__INTEL__) )",
          "93: extern unsigned int OPENSSL_ia32cap_P[2];",
          "94: #define AESNI_CAPABLE   (1<<(57-32))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "93: #if defined(__GNUC__) && __GNUC__>=2 && !defined(PEDANTIC)",
          "94: # define BSWAP(x) ({ unsigned int r=(x); asm (\"bswapl %0\":\"=r\"(r):\"0\"(r)); r; })",
          "95: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "167:   SHA1_Update(c,ptr,res);",
          "168: }",
          "170: #define SHA1_Update sha1_update",
          "172: static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "174: #ifdef SHA1_Update",
          "175: #undef SHA1_Update",
          "176: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "184:  sha_off = SHA_CBLOCK-key->md.num;",
          "185: #endif",
          "187:  if (len%AES_BLOCK_SIZE) return 0;",
          "189:  if (ctx->encrypt) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "194:  key->payload_length = NO_PAYLOAD_LENGTH;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "234:      &key->ks,ctx->iv,1);",
          "235:   }",
          "236:  } else {",
          "240:   aesni_cbc_encrypt(in,out,len,",
          "241:     &key->ks,ctx->iv,0);",
          "250:    if ((key->aux.tls_aad[plen-4]<<8|key->aux.tls_aad[plen-3])",
          "253:     iv = AES_BLOCK_SIZE;",
          "260:    key->md = key->head;",
          "261:    SHA1_Update(&key->md,key->aux.tls_aad,plen);",
          "265:    key->md = key->tail;",
          "271:   } else {",
          "272:    SHA1_Update(&key->md,out,len);",
          "273:   }",
          "274:  }",
          "278:  return 1;",
          "279:  }",
          "",
          "[Removed Lines]",
          "237:   unsigned char mac[SHA_DIGEST_LENGTH];",
          "245:    if (len<(size_t)(out[len-1]+1+SHA_DIGEST_LENGTH))",
          "246:     return 0;",
          "248:    len -= (out[len-1]+1+SHA_DIGEST_LENGTH);",
          "251:        >= TLS1_1_VERSION) {",
          "252:     len -= AES_BLOCK_SIZE;",
          "254:    }",
          "256:    key->aux.tls_aad[plen-2] = len>>8;",
          "257:    key->aux.tls_aad[plen-1] = len;",
          "262:    SHA1_Update(&key->md,out+iv,len);",
          "263:    SHA1_Final(mac,&key->md);",
          "266:    SHA1_Update(&key->md,mac,SHA_DIGEST_LENGTH);",
          "267:    SHA1_Final(mac,&key->md);",
          "269:    if (memcmp(out+iv+len,mac,SHA_DIGEST_LENGTH))",
          "270:     return 0;",
          "276:  key->payload_length = NO_PAYLOAD_LENGTH;",
          "",
          "[Added Lines]",
          "246:   union { unsigned int  u[SHA_DIGEST_LENGTH/sizeof(unsigned int)];",
          "247:    unsigned char c[SHA_DIGEST_LENGTH]; } mac;",
          "254:    size_t inp_len, mask, j, i;",
          "255:    unsigned int res, maxpad, pad, bitlen;",
          "256:    int ret = 1;",
          "257:    union { unsigned int  u[SHA_LBLOCK];",
          "258:     unsigned char c[SHA_CBLOCK]; }",
          "262:        >= TLS1_1_VERSION)",
          "265:    if (len<(iv+SHA_DIGEST_LENGTH+1))",
          "266:     return 0;",
          "269:    out += iv;",
          "270:    len -= iv;",
          "273:    pad = out[len-1];",
          "274:    maxpad = len-(SHA_DIGEST_LENGTH+1);",
          "275:    maxpad |= (255-maxpad)>>(sizeof(maxpad)*8-8);",
          "276:    maxpad &= 255;",
          "278:    inp_len = len - (SHA_DIGEST_LENGTH+pad+1);",
          "279:    mask = (0-((inp_len-len)>>(sizeof(inp_len)*8-1)));",
          "280:    inp_len &= mask;",
          "281:    ret &= (int)mask;",
          "283:    key->aux.tls_aad[plen-2] = inp_len>>8;",
          "284:    key->aux.tls_aad[plen-1] = inp_len;",
          "290: #if 1",
          "292:    if (len>=(256+SHA_CBLOCK)) {",
          "293:     j = (len-(256+SHA_CBLOCK))&(0-SHA_CBLOCK);",
          "294:     j += SHA_CBLOCK-key->md.num;",
          "295:     SHA1_Update(&key->md,out,j);",
          "296:     out += j;",
          "297:     len -= j;",
          "298:     inp_len -= j;",
          "299:    }",
          "303:    mac.c[0] = 0;",
          "304:    mac.c[1] = (unsigned char)(bitlen>>16);",
          "305:    mac.c[2] = (unsigned char)(bitlen>>8);",
          "306:    mac.c[3] = (unsigned char)bitlen;",
          "307:    bitlen = mac.u[0];",
          "309:    mac.u[0]=0;",
          "310:    mac.u[1]=0;",
          "311:    mac.u[2]=0;",
          "312:    mac.u[3]=0;",
          "313:    mac.u[4]=0;",
          "315:    for (res=key->md.num, j=0;j<len;j++) {",
          "316:     size_t c = out[j];",
          "317:     mask = (j-inp_len)>>(sizeof(j)*8-8);",
          "318:     c &= mask;",
          "319:     c |= 0x80&~mask&~((inp_len-j)>>(sizeof(j)*8-8));",
          "320:     data->c[res++]=(unsigned char)c;",
          "322:     if (res!=SHA_CBLOCK) continue;",
          "324:     mask = 0-((inp_len+8-j)>>(sizeof(j)*8-1));",
          "325:     data->u[SHA_LBLOCK-1] |= bitlen&mask;",
          "326:     sha1_block_data_order(&key->md,data,1);",
          "327:     mask &= 0-((j-inp_len-73)>>(sizeof(j)*8-1));",
          "328:     mac.u[0] |= key->md.h0 & mask;",
          "329:     mac.u[1] |= key->md.h1 & mask;",
          "330:     mac.u[2] |= key->md.h2 & mask;",
          "331:     mac.u[3] |= key->md.h3 & mask;",
          "332:     mac.u[4] |= key->md.h4 & mask;",
          "333:     res=0;",
          "334:    }",
          "336:    for(i=res;i<SHA_CBLOCK;i++,j++) data->c[i]=0;",
          "338:    if (res>SHA_CBLOCK-8) {",
          "339:     mask = 0-((inp_len+8-j)>>(sizeof(j)*8-1));",
          "340:     data->u[SHA_LBLOCK-1] |= bitlen&mask;",
          "341:     sha1_block_data_order(&key->md,data,1);",
          "342:     mask &= 0-((j-inp_len-73)>>(sizeof(j)*8-1));",
          "343:     mac.u[0] |= key->md.h0 & mask;",
          "344:     mac.u[1] |= key->md.h1 & mask;",
          "345:     mac.u[2] |= key->md.h2 & mask;",
          "346:     mac.u[3] |= key->md.h3 & mask;",
          "347:     mac.u[4] |= key->md.h4 & mask;",
          "349:     memset(data,0,SHA_CBLOCK);",
          "350:     j+=64;",
          "351:    }",
          "352:    data->u[SHA_LBLOCK-1] = bitlen;",
          "353:    sha1_block_data_order(&key->md,data,1);",
          "354:    mask = 0-((j-inp_len-73)>>(sizeof(j)*8-1));",
          "355:    mac.u[0] |= key->md.h0 & mask;",
          "356:    mac.u[1] |= key->md.h1 & mask;",
          "357:    mac.u[2] |= key->md.h2 & mask;",
          "358:    mac.u[3] |= key->md.h3 & mask;",
          "359:    mac.u[4] |= key->md.h4 & mask;",
          "361: #ifdef BSWAP",
          "362:    mac.u[0] = BSWAP(mac.u[0]);",
          "363:    mac.u[1] = BSWAP(mac.u[1]);",
          "364:    mac.u[2] = BSWAP(mac.u[2]);",
          "365:    mac.u[3] = BSWAP(mac.u[3]);",
          "366:    mac.u[4] = BSWAP(mac.u[4]);",
          "367: #else",
          "368:    for (i=0;i<5;i++) {",
          "369:     res = mac.u[i];",
          "370:     mac.c[4*i+0]=(unsigned char)(res>>24);",
          "371:     mac.c[4*i+1]=(unsigned char)(res>>16);",
          "372:     mac.c[4*i+2]=(unsigned char)(res>>8);",
          "373:     mac.c[4*i+3]=(unsigned char)res;",
          "374:    }",
          "375: #endif",
          "376:    len += SHA_DIGEST_LENGTH;",
          "377: #else",
          "378:    SHA1_Update(&key->md,out,inp_len);",
          "379:    res = key->md.num;",
          "380:    SHA1_Final(mac.c,&key->md);",
          "382:    {",
          "383:    unsigned int inp_blocks, pad_blocks;",
          "386:    inp_blocks = 1+((SHA_CBLOCK-9-res)>>(sizeof(res)*8-1));",
          "387:    res += (unsigned int)(len-inp_len);",
          "388:    pad_blocks = res / SHA_CBLOCK;",
          "389:    res %= SHA_CBLOCK;",
          "390:    pad_blocks += 1+((SHA_CBLOCK-9-res)>>(sizeof(res)*8-1));",
          "391:    for (;inp_blocks<pad_blocks;inp_blocks++)",
          "392:     sha1_block_data_order(&key->md,data,1);",
          "393:    }",
          "394: #endif",
          "396:    SHA1_Update(&key->md,mac.c,SHA_DIGEST_LENGTH);",
          "397:    SHA1_Final(mac.c,&key->md);",
          "400:    out += inp_len;",
          "401:    len -= inp_len;",
          "402: #if 1",
          "403:    {",
          "404:    unsigned char *p = out+len-1-maxpad-SHA_DIGEST_LENGTH;",
          "405:    size_t off = out-p;",
          "406:    unsigned int c, cmask;",
          "408:    maxpad += SHA_DIGEST_LENGTH;",
          "409:    for (res=0,i=0,j=0;j<maxpad;j++) {",
          "410:     c = p[j];",
          "411:     cmask = ((int)(j-off-SHA_DIGEST_LENGTH))>>(sizeof(int)*8-1);",
          "413:     cmask &= ((int)(off-1-j))>>(sizeof(int)*8-1);",
          "414:     res |= (c^mac.c[i])&cmask;",
          "415:     i += 1&cmask;",
          "416:    }",
          "417:    maxpad -= SHA_DIGEST_LENGTH;",
          "419:    res = 0-((0-res)>>(sizeof(res)*8-1));",
          "420:    ret &= (int)~res;",
          "421:    }",
          "422: #else",
          "423:    for (res=0,i=0;i<SHA_DIGEST_LENGTH;i++)",
          "424:     res |= out[i]^mac.c[i];",
          "425:    res = 0-((0-res)>>(sizeof(res)*8-1));",
          "426:    ret &= (int)~res;",
          "429:    pad = (pad&~res) | (maxpad&res);",
          "430:    out = out+len-1-pad;",
          "431:    for (res=0,i=0;i<pad;i++)",
          "432:     res |= out[i]^pad;",
          "434:    res = (0-res)>>(sizeof(res)*8-1);",
          "435:    ret &= (int)~res;",
          "436: #endif",
          "437:    return ret;",
          "",
          "---------------"
        ],
        "ssl/s3_cbc.c||ssl/s3_cbc.c": [
          "File: ssl/s3_cbc.c -> ssl/s3_cbc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "150:  if (overhead > rec->length)",
          "151:   return 0;",
          "153:  padding_length = rec->data[rec->length-1];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "161:  if (has_explicit_iv)",
          "162:   {",
          "163:   rec->data += block_size;",
          "164:   rec->input += block_size;",
          "165:   rec->length -= block_size;",
          "166:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "172:    }",
          "173:   }",
          "175:  good = constant_time_ge(rec->length, overhead+padding_length);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "190:  if (EVP_CIPHER_flags(s->enc_read_ctx->cipher)&EVP_CIPH_FLAG_AEAD_CIPHER)",
          "191:   {",
          "193:   rec->length -= padding_length;",
          "194:   return 1;",
          "195:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "209:  rec->length -= padding_length;",
          "227:  return (int)((good & 1) | (~good & -1));",
          "228:  }",
          "",
          "[Removed Lines]",
          "220:  if (has_explicit_iv)",
          "221:   {",
          "222:   rec->data += block_size;",
          "223:   rec->input += block_size;",
          "224:   rec->length -= block_size;",
          "225:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "ssl/ssl_algs.c||ssl/ssl_algs.c": [
          "File: ssl/ssl_algs.c -> ssl/ssl_algs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "90:  EVP_add_cipher(EVP_aes_256_cbc());",
          "91:  EVP_add_cipher(EVP_aes_128_gcm());",
          "92:  EVP_add_cipher(EVP_aes_256_gcm());",
          "94: #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)",
          "95:  EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());",
          "96:  EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());",
          "97: #endif",
          "100: #endif",
          "101: #ifndef OPENSSL_NO_CAMELLIA",
          "",
          "[Removed Lines]",
          "98: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7f893258f6e9298a24fbfced5331e4867df4fd6c",
      "candidate_info": {
        "commit_hash": "7f893258f6e9298a24fbfced5331e4867df4fd6c",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/7f893258f6e9298a24fbfced5331e4867df4fd6c",
        "files": [
          "crypto/evp/e_aes_cbc_hmac_sha1.c",
          "crypto/evp/e_aes_cbc_hmac_sha256.c"
        ],
        "message": "evp/e_aes_cbc_hmac_sha*.c: multi-block glue code.",
        "before_after_code_files": [
          "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c",
          "crypto/evp/e_aes_cbc_hmac_sha256.c||crypto/evp/e_aes_cbc_hmac_sha256.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c"
          ],
          "candidate": [
            "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c"
          ]
        }
      },
      "candidate_diff": {
        "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c": [
          "File: crypto/evp/e_aes_cbc_hmac_sha1.c -> crypto/evp/e_aes_cbc_hmac_sha1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "58: #include <openssl/objects.h>",
          "59: #include <openssl/aes.h>",
          "60: #include <openssl/sha.h>",
          "62: #ifndef EVP_CIPH_FLAG_AEAD_CIPHER",
          "63: #define EVP_CIPH_FLAG_AEAD_CIPHER 0x200000",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "61: #include <openssl/rand.h>",
          "62: #include \"modes_lcl.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "69: #define EVP_CIPH_FLAG_DEFAULT_ASN1 0",
          "70: #endif",
          "72: #define TLS1_1_VERSION 0x0302",
          "74: typedef struct",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "74: #if !defined(EVP_CIPH_FLAG_TLS11_MULTI_BLOCK)",
          "75: #define EVP_CIPH_FLAG_TLS11_MULTI_BLOCK 0",
          "76: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "89:  defined(_M_AMD64) || defined(_M_X64) || \\",
          "90:  defined(__INTEL__) )",
          "96: extern unsigned int OPENSSL_ia32cap_P[2];",
          "97: #define AESNI_CAPABLE   (1<<(57-32))",
          "",
          "[Removed Lines]",
          "92: #if defined(__GNUC__) && __GNUC__>=2 && !defined(PEDANTIC)",
          "93: # define BSWAP(x) ({ unsigned int r=(x); asm (\"bswapl %0\":\"=r\"(r):\"0\"(r)); r; })",
          "94: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "175: #endif",
          "176: #define SHA1_Update sha1_update",
          "178: static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,",
          "179:         const unsigned char *in, size_t len)",
          "180:  {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "180: #if EVP_CIPH_FLAG_TLS11_MULTI_BLOCK",
          "182: typedef struct { unsigned int A[8],B[8],C[8],D[8],E[8]; } SHA1_MB_CTX;",
          "183: typedef struct { const unsigned char *ptr; int blocks;  } HASH_DESC;",
          "185: void sha1_multi_block(SHA1_MB_CTX *,const HASH_DESC *,int);",
          "187: typedef struct { const unsigned char *inp; unsigned char *out;",
          "188:    int blocks; double iv[2]; } CIPH_DESC;",
          "190: void aesni_multi_cbc_encrypt(CIPH_DESC *,void *,int);",
          "192: static size_t tls11_multi_block_encrypt(EVP_AES_HMAC_SHA1 *key,",
          "193:  unsigned char *out, const unsigned char *inp, size_t inp_len,",
          "195: {",
          "196:  HASH_DESC hash_d[8], edges[8];",
          "197:  CIPH_DESC ciph_d[8];",
          "198:  unsigned char storage[sizeof(SHA1_MB_CTX)+32];",
          "199:  union { u64 q[16];",
          "200:   u32 d[32];",
          "201:   u8 c[128]; } blocks[8];",
          "202:  SHA1_MB_CTX *ctx;",
          "203:  unsigned int frag, last, packlen, i, x4=4*n4x;",
          "204:  size_t  ret = 0;",
          "208:  frag = (unsigned int)inp_len>>(1+n4x);",
          "209:  last = (unsigned int)inp_len+frag-(frag<<(1+n4x));",
          "210:  if (last>frag && ((last+13+9)%64)<(x4-1)) {",
          "211:   frag++;",
          "212:   last -= x4-1;",
          "213:  }",
          "215:  hash_d[0].ptr = inp;",
          "216:  for (i=1;i<x4;i++) hash_d[i].ptr = hash_d[i-1].ptr+frag;",
          "218:  for (i=0;i<x4;i++) {",
          "219:   unsigned int len = (i==(x4-1)?last:frag);",
          "221:   ctx->A[i] = key->md.h0;",
          "222:   ctx->B[i] = key->md.h1;",
          "223:   ctx->C[i] = key->md.h2;",
          "224:   ctx->D[i] = key->md.h3;",
          "225:   ctx->E[i] = key->md.h4;",
          "228: #if defined(BSWAP8)",
          "229:   blocks[i].q[0] = BSWAP8(BSWAP8(*(u64*)key->md.data)+i);",
          "230: #else",
          "231:   blocks[i].c[7] += key->md.data[7]+i;",
          "232:   if (blocks[i].c[7] < i) {",
          "233:    int j;",
          "235:    for (j=6;j>=0;j--) {",
          "236:     if (blocks[i].c[j]=key->md.data[j]+1) break;",
          "237:    }",
          "238:   }",
          "239: #endif",
          "240:   blocks[i].c[8] = key->md.data[8];",
          "241:   blocks[i].c[9] = key->md.data[9];",
          "242:   blocks[i].c[10] = key->md.data[10];",
          "244:   blocks[i].c[11] = (unsigned char)(len>>8);",
          "245:   blocks[i].c[12] = (unsigned char)(len);",
          "247:   memcpy(blocks[i].c+13,hash_d[i].ptr,64-13);",
          "248:   hash_d[i].ptr += 64-13;",
          "249:   hash_d[i].blocks = (len-(64-13))/64;",
          "251:   edges[i].ptr = blocks[i].c;",
          "252:   edges[i].blocks = 1;",
          "253:  }",
          "255:  sha1_multi_block(ctx,edges,n4x);",
          "256:  sha1_multi_block(ctx,hash_d,n4x);",
          "258:  memset(blocks,0,sizeof(blocks));",
          "259:  for (i=0;i<x4;i++) {",
          "260:   unsigned int  len = (i==(x4-1)?last:frag),",
          "261:      off = hash_d[i].blocks*64;",
          "262:   const unsigned char    *ptr = hash_d[i].ptr+off;",
          "265:   memcpy(blocks[i].c,ptr,off);",
          "266:   blocks[i].c[off]=0x80;",
          "269:   if (off<(64-8)) {",
          "270:    blocks[i].d[15] = BSWAP4(len);",
          "271:    edges[i].blocks = 1;",
          "272:   } else {",
          "273:    blocks[i].d[31] = BSWAP4(len);",
          "274:    edges[i].blocks = 2;",
          "275:   }",
          "276:   edges[i].ptr = blocks[i].c;",
          "277:  }",
          "279:  sha1_multi_block(ctx,edges,n4x);",
          "281:  memset(blocks,0,sizeof(blocks));",
          "282:  for (i=0;i<x4;i++) {",
          "283:   blocks[i].d[0] = BSWAP4(ctx->A[i]); ctx->A[i] = key->tail.h0;",
          "284:   blocks[i].d[1] = BSWAP4(ctx->B[i]); ctx->B[i] = key->tail.h1;",
          "285:   blocks[i].d[2] = BSWAP4(ctx->C[i]); ctx->C[i] = key->tail.h2;",
          "286:   blocks[i].d[3] = BSWAP4(ctx->D[i]); ctx->D[i] = key->tail.h3;",
          "287:   blocks[i].d[4] = BSWAP4(ctx->E[i]); ctx->E[i] = key->tail.h4;",
          "288:   blocks[i].c[20] = 0x80;",
          "289:   blocks[i].d[15] = BSWAP4((64+20)*8);",
          "290:   edges[i].ptr = blocks[i].c;",
          "291:   edges[i].blocks = 1;",
          "292:  }",
          "294:  sha1_multi_block(ctx,edges,n4x);",
          "296:  packlen = 5+16+((frag+20+16)&-16);",
          "298:  out += (packlen<<(1+n4x))-packlen;",
          "299:  inp += (frag<<(1+n4x))-frag;",
          "301:  for (i=x4-1;;i--) {",
          "302:   unsigned int len = (i==(x4-1)?last:frag), pad, j;",
          "303:   unsigned char *out0 = out;",
          "306:   ciph_d[i].inp = out;",
          "307:   ciph_d[i].out = out;",
          "309:   memmove(out,inp,len);",
          "310:   out += len;",
          "311:   inp -= frag;",
          "313:   ((u32 *)out)[0] = BSWAP4(ctx->A[i]);",
          "314:   ((u32 *)out)[1] = BSWAP4(ctx->B[i]);",
          "315:   ((u32 *)out)[2] = BSWAP4(ctx->C[i]);",
          "316:   ((u32 *)out)[3] = BSWAP4(ctx->D[i]);",
          "317:   ((u32 *)out)[4] = BSWAP4(ctx->E[i]);",
          "318:   out += 20;",
          "319:   len += 20+16;",
          "321:   pad = 15-len%16;",
          "322:   for (j=0;j<=pad;j++) *(out++) = pad;",
          "323:   len += pad+1;",
          "325:   ciph_d[i].blocks = len/16;",
          "328:   out0[0] = key->md.data[8];",
          "329:   out0[1] = key->md.data[9];",
          "330:   out0[2] = key->md.data[10];",
          "331:   out0[3] = (unsigned char)(len>>8);",
          "332:   out0[4] = (unsigned char)(len);",
          "335:   RAND_bytes((u8 *)ciph_d[i].iv, 16);",
          "336:   memcpy(&out[5], ciph_d[i].iv, 16);",
          "338:   ret += len+5;",
          "340:   if (i==0) break;",
          "342:   out = out0-packlen;",
          "343:  }",
          "345:  aesni_multi_cbc_encrypt(ciph_d,&key->ks,n4x);",
          "347:  return ret;",
          "348: }",
          "349: #endif",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "307: #else",
          "308:    mac.c[0] = 0;",
          "309:    mac.c[1] = (unsigned char)(bitlen>>16);",
          "",
          "[Removed Lines]",
          "305: #ifdef BSWAP",
          "306:    bitlen = BSWAP(bitlen);",
          "",
          "[Added Lines]",
          "478: #ifdef BSWAP4",
          "479:    bitlen = BSWAP4(bitlen);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "365:    pmac->u[3] |= key->md.h3 & mask;",
          "366:    pmac->u[4] |= key->md.h4 & mask;",
          "374: #else",
          "375:    for (i=0;i<5;i++) {",
          "376:     res = pmac->u[i];",
          "",
          "[Removed Lines]",
          "368: #ifdef BSWAP",
          "369:    pmac->u[0] = BSWAP(pmac->u[0]);",
          "370:    pmac->u[1] = BSWAP(pmac->u[1]);",
          "371:    pmac->u[2] = BSWAP(pmac->u[2]);",
          "372:    pmac->u[3] = BSWAP(pmac->u[3]);",
          "373:    pmac->u[4] = BSWAP(pmac->u[4]);",
          "",
          "[Added Lines]",
          "541: #ifdef BSWAP4",
          "542:    pmac->u[0] = BSWAP4(pmac->u[0]);",
          "543:    pmac->u[1] = BSWAP4(pmac->u[1]);",
          "544:    pmac->u[2] = BSWAP4(pmac->u[2]);",
          "545:    pmac->u[3] = BSWAP4(pmac->u[3]);",
          "546:    pmac->u[4] = BSWAP4(pmac->u[4]);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "513:    return SHA_DIGEST_LENGTH;",
          "514:    }",
          "515:   }",
          "516:  default:",
          "517:   return -1;",
          "518:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "689: #if EVP_EVP_CIPH_FLAG_TLS11_MULTI_BLOCK",
          "690:  case EVP_CTRL_TLS11_MULTI_BLOCK_AAD:",
          "691:   {",
          "692:   EVP_CTRL_TLS11_MULTI_BLOCK_PARAM *param =",
          "693:    (EVP_CTRL_TLS11_MULTI_BLOCK_PARAM *)ptr;",
          "694:   unsigned int n4x=1, x4;",
          "695:   unsigned int frag, last, packlen, inp_len;",
          "697:   if (arg<sizeof(EVP_CTRL_TLS11_MULTI_BLOCK_PARAM)) return -1;",
          "699:   inp_len = param->inp[11]<<8|param->inp[12];",
          "701:   if (ctx->encrypt)",
          "702:    {",
          "703:    if ((param->inp[9]<<8|param->inp[10]) < TLS1_1_VERSION)",
          "704:     return -1;",
          "708:    if (inp_len>=6144) n4x=2;",
          "710:    key->md = key->head;",
          "711:    SHA1_Update(&key->md,param->inp,13);",
          "713:    x4 = 4*n4x; n4x += 1;",
          "715:    frag = inp_len>>n4x;",
          "716:    last = inp_len+frag-(frag<<n4x);",
          "717:    if (last>frag && ((last+13+9)%64<(x4-1))) {",
          "718:     frag++;",
          "719:     last -= x4-1;",
          "720:    }",
          "722:    packlen = 5+16+((frag+20+16)&-16);",
          "723:    packlen = (packlen<<(1+n4x))-packlen;",
          "724:    packlen += 5+16+((last+20+16)&-16);",
          "726:    param->interleave = x4;",
          "728:    return (int)packlen;",
          "729:    }",
          "730:   else",
          "732:   }",
          "733:  case EVP_CTRL_TLS11_MULTI_BLOCK_ENCRYPT:",
          "734:   {",
          "735:   EVP_CTRL_TLS11_MULTI_BLOCK_PARAM *param =",
          "736:    (EVP_CTRL_TLS11_MULTI_BLOCK_PARAM *)ptr;",
          "738:   return tls11_multi_block_encrypt(key,param->out,param->inp,",
          "739:       param->len,param->interleave/4);",
          "740:   }",
          "741:  case EVP_CTRL_TLS11_MULTI_BLOCK_DECRYPT:",
          "742: #endif",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "526:  NID_undef,",
          "527: #endif",
          "528:  16,16,16,",
          "530:  aesni_cbc_hmac_sha1_init_key,",
          "531:  aesni_cbc_hmac_sha1_cipher,",
          "532:  NULL,",
          "",
          "[Removed Lines]",
          "529:  EVP_CIPH_CBC_MODE|EVP_CIPH_FLAG_DEFAULT_ASN1|EVP_CIPH_FLAG_AEAD_CIPHER,",
          "",
          "[Added Lines]",
          "756:  EVP_CIPH_CBC_MODE|EVP_CIPH_FLAG_DEFAULT_ASN1|",
          "757:  EVP_CIPH_FLAG_AEAD_CIPHER|EVP_CIPH_FLAG_TLS11_MULTI_BLOCK,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "545:  NID_undef,",
          "546: #endif",
          "547:  16,32,16,",
          "549:  aesni_cbc_hmac_sha1_init_key,",
          "550:  aesni_cbc_hmac_sha1_cipher,",
          "551:  NULL,",
          "",
          "[Removed Lines]",
          "548:  EVP_CIPH_CBC_MODE|EVP_CIPH_FLAG_DEFAULT_ASN1|EVP_CIPH_FLAG_AEAD_CIPHER,",
          "",
          "[Added Lines]",
          "776:  EVP_CIPH_CBC_MODE|EVP_CIPH_FLAG_DEFAULT_ASN1|",
          "777:  EVP_CIPH_FLAG_AEAD_CIPHER|EVP_CIPH_FLAG_TLS11_MULTI_BLOCK,",
          "",
          "---------------"
        ],
        "crypto/evp/e_aes_cbc_hmac_sha256.c||crypto/evp/e_aes_cbc_hmac_sha256.c": [
          "File: crypto/evp/e_aes_cbc_hmac_sha256.c -> crypto/evp/e_aes_cbc_hmac_sha256.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "58: #include <openssl/objects.h>",
          "59: #include <openssl/aes.h>",
          "60: #include <openssl/sha.h>",
          "62: #ifndef EVP_CIPH_FLAG_AEAD_CIPHER",
          "63: #define EVP_CIPH_FLAG_AEAD_CIPHER 0x200000",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "61: #include <openssl/rand.h>",
          "62: #include \"modes_lcl.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "69: #define EVP_CIPH_FLAG_DEFAULT_ASN1 0",
          "70: #endif",
          "72: #define TLS1_1_VERSION 0x0302",
          "74: typedef struct",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "74: #if !defined(EVP_CIPH_FLAG_TLS11_MULTI_BLOCK)",
          "75: #define EVP_CIPH_FLAG_TLS11_MULTI_BLOCK 0",
          "76: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "89:  defined(_M_AMD64) || defined(_M_X64) || \\",
          "90:  defined(__INTEL__) )",
          "96: extern unsigned int OPENSSL_ia32cap_P[3];",
          "97: #define AESNI_CAPABLE   (1<<(57-32))",
          "",
          "[Removed Lines]",
          "92: #if defined(__GNUC__) && __GNUC__>=2 && !defined(PEDANTIC)",
          "93: # define BSWAP(x) ({ unsigned int r=(x); asm (\"bswapl %0\":\"=r\"(r):\"0\"(r)); r; })",
          "94: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "176: #endif",
          "177: #define SHA256_Update sha256_update",
          "179: static int aesni_cbc_hmac_sha256_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,",
          "180:         const unsigned char *in, size_t len)",
          "181:  {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "181: #if EVP_CIPH_FLAG_TLS11_MULTI_BLOCK",
          "183: typedef struct { unsigned int A[8],B[8],C[8],D[8],E[8],F[8],G[8],H[8]; } SHA256_MB_CTX;",
          "184: typedef struct { const unsigned char *ptr; int blocks;  } HASH_DESC;",
          "186: void sha256_multi_block(SHA256_MB_CTX *,const HASH_DESC *,int);",
          "188: typedef struct { const unsigned char *inp; unsigned char *out;",
          "189:    int blocks; double iv[2]; } CIPH_DESC;",
          "191: void aesni_multi_cbc_encrypt(CIPH_DESC *,void *,int);",
          "193: static size_t tls11_multi_block_encrypt(EVP_AES_HMAC_SHA256 *key,",
          "194:  unsigned char *out, const unsigned char *inp, size_t inp_len,",
          "196: {",
          "197:  HASH_DESC hash_d[8], edges[8];",
          "198:  CIPH_DESC ciph_d[8];",
          "199:  unsigned char storage[sizeof(SHA256_MB_CTX)+32];",
          "200:  union { u64 q[16];",
          "201:   u32 d[32];",
          "202:   u8 c[128]; } blocks[8];",
          "203:  SHA256_MB_CTX *ctx;",
          "204:  unsigned int frag, last, packlen, i, x4=4*n4x;",
          "205:  size_t  ret = 0;",
          "209:  frag = (unsigned int)inp_len>>(1+n4x);",
          "210:  last = (unsigned int)inp_len+frag-(frag<<(1+n4x));",
          "211:  if (last>frag && ((last+13+9)%64)<(x4-1)) {",
          "212:   frag++;",
          "213:   last -= x4-1;",
          "214:  }",
          "216:  hash_d[0].ptr = inp;",
          "217:  for (i=1;i<x4;i++) hash_d[i].ptr = hash_d[i-1].ptr+frag;",
          "219:  for (i=0;i<x4;i++) {",
          "220:   unsigned int len = (i==(x4-1)?last:frag);",
          "222:   ctx->A[i] = key->md.h[0];",
          "223:   ctx->B[i] = key->md.h[1];",
          "224:   ctx->C[i] = key->md.h[2];",
          "225:   ctx->D[i] = key->md.h[3];",
          "226:   ctx->E[i] = key->md.h[4];",
          "227:   ctx->F[i] = key->md.h[5];",
          "228:   ctx->G[i] = key->md.h[6];",
          "229:   ctx->H[i] = key->md.h[7];",
          "232: #if defined(BSWAP8)",
          "233:   blocks[i].q[0] = BSWAP8(BSWAP8(*(u64*)key->md.data)+i);",
          "234: #else",
          "235:   blocks[i].c[7] += key->md.data[7]+i;",
          "236:   if (blocks[i].c[7] < i) {",
          "237:    int j;",
          "239:    for (j=6;j>=0;j--) {",
          "240:     if (blocks[i].c[j]=key->md.data[j]+1) break;",
          "241:    }",
          "242:   }",
          "243: #endif",
          "244:   blocks[i].c[8] = key->md.data[8];",
          "245:   blocks[i].c[9] = key->md.data[9];",
          "246:   blocks[i].c[10] = key->md.data[10];",
          "248:   blocks[i].c[11] = (unsigned char)(len>>8);",
          "249:   blocks[i].c[12] = (unsigned char)(len);",
          "251:   memcpy(blocks[i].c+13,hash_d[i].ptr,64-13);",
          "252:   hash_d[i].ptr += 64-13;",
          "253:   hash_d[i].blocks = (len-(64-13))/64;",
          "255:   edges[i].ptr = blocks[i].c;",
          "256:   edges[i].blocks = 1;",
          "257:  }",
          "259:  sha256_multi_block(ctx,edges,n4x);",
          "260:  sha256_multi_block(ctx,hash_d,n4x);",
          "262:  memset(blocks,0,sizeof(blocks));",
          "263:  for (i=0;i<x4;i++) {",
          "264:   unsigned int  len = (i==(x4-1)?last:frag),",
          "265:      off = hash_d[i].blocks*64;",
          "266:   const unsigned char    *ptr = hash_d[i].ptr+off;",
          "269:   memcpy(blocks[i].c,ptr,off);",
          "270:   blocks[i].c[off]=0x80;",
          "273:   if (off<(64-8)) {",
          "274:    blocks[i].d[15] = BSWAP4(len);",
          "275:    edges[i].blocks = 1;",
          "276:   } else {",
          "277:    blocks[i].d[31] = BSWAP4(len);",
          "278:    edges[i].blocks = 2;",
          "279:   }",
          "280:   edges[i].ptr = blocks[i].c;",
          "281:  }",
          "283:  sha256_multi_block(ctx,edges,n4x);",
          "285:  memset(blocks,0,sizeof(blocks));",
          "286:  for (i=0;i<x4;i++) {",
          "287:   blocks[i].d[0] = BSWAP4(ctx->A[i]); ctx->A[i] = key->tail.h[0];",
          "288:   blocks[i].d[1] = BSWAP4(ctx->B[i]); ctx->B[i] = key->tail.h[1];",
          "289:   blocks[i].d[2] = BSWAP4(ctx->C[i]); ctx->C[i] = key->tail.h[2];",
          "290:   blocks[i].d[3] = BSWAP4(ctx->D[i]); ctx->D[i] = key->tail.h[3];",
          "291:   blocks[i].d[4] = BSWAP4(ctx->E[i]); ctx->E[i] = key->tail.h[4];",
          "292:   blocks[i].d[5] = BSWAP4(ctx->F[i]); ctx->F[i] = key->tail.h[5];",
          "293:   blocks[i].d[6] = BSWAP4(ctx->G[i]); ctx->G[i] = key->tail.h[6];",
          "294:   blocks[i].d[7] = BSWAP4(ctx->H[i]); ctx->H[i] = key->tail.h[7];",
          "295:   blocks[i].c[32] = 0x80;",
          "296:   blocks[i].d[15] = BSWAP4((64+32)*8);",
          "297:   edges[i].ptr = blocks[i].c;",
          "298:   edges[i].blocks = 1;",
          "299:  }",
          "301:  sha256_multi_block(ctx,edges,n4x);",
          "303:  packlen = 5+16+((frag+32+16)&-16);",
          "305:  out += (packlen<<(1+n4x))-packlen;",
          "306:  inp += (frag<<(1+n4x))-frag;",
          "308:  for (i=x4-1;;i--) {",
          "309:   unsigned int len = (i==(x4-1)?last:frag), pad, j;",
          "310:   unsigned char *out0 = out;",
          "313:   ciph_d[i].inp = out;",
          "314:   ciph_d[i].out = out;",
          "316:   memmove(out,inp,len);",
          "317:   out += len;",
          "318:   inp -= frag;",
          "320:   ((u32 *)out)[0] = BSWAP4(ctx->A[i]);",
          "321:   ((u32 *)out)[1] = BSWAP4(ctx->B[i]);",
          "322:   ((u32 *)out)[2] = BSWAP4(ctx->C[i]);",
          "323:   ((u32 *)out)[3] = BSWAP4(ctx->D[i]);",
          "324:   ((u32 *)out)[4] = BSWAP4(ctx->E[i]);",
          "325:   ((u32 *)out)[5] = BSWAP4(ctx->F[i]);",
          "326:   ((u32 *)out)[6] = BSWAP4(ctx->G[i]);",
          "327:   ((u32 *)out)[7] = BSWAP4(ctx->H[i]);",
          "328:   out += 32;",
          "329:   len += 32+16;",
          "331:   pad = 15-len%16;",
          "332:   for (j=0;j<=pad;j++) *(out++) = pad;",
          "333:   len += pad+1;",
          "335:   ciph_d[i].blocks = len/16;",
          "338:   out0[0] = key->md.data[8];",
          "339:   out0[1] = key->md.data[9];",
          "340:   out0[2] = key->md.data[10];",
          "341:   out0[3] = (unsigned char)(len>>8);",
          "342:   out0[4] = (unsigned char)(len);",
          "345:   RAND_bytes((u8 *)ciph_d[i].iv, 16);",
          "346:   memcpy(&out[5], ciph_d[i].iv, 16);",
          "348:   ret += len+5;",
          "350:   if (i==0) break;",
          "352:   out = out0-packlen;",
          "353:  }",
          "355:  aesni_multi_cbc_encrypt(ciph_d,&key->ks,n4x);",
          "357:  return ret;",
          "358: }",
          "359: #endif",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "310: #else",
          "311:    mac.c[0] = 0;",
          "312:    mac.c[1] = (unsigned char)(bitlen>>16);",
          "",
          "[Removed Lines]",
          "308: #ifdef BSWAP",
          "309:    bitlen = BSWAP(bitlen);",
          "",
          "[Added Lines]",
          "490: #ifdef BSWAP4",
          "491:    bitlen = BSWAP4(bitlen);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "380:    pmac->u[6] |= key->md.h[6] & mask;",
          "381:    pmac->u[7] |= key->md.h[7] & mask;",
          "392: #else",
          "393:    for (i=0;i<8;i++) {",
          "394:     res = pmac->u[i];",
          "",
          "[Removed Lines]",
          "383: #ifdef BSWAP",
          "384:    pmac->u[0] = BSWAP(pmac->u[0]);",
          "385:    pmac->u[1] = BSWAP(pmac->u[1]);",
          "386:    pmac->u[2] = BSWAP(pmac->u[2]);",
          "387:    pmac->u[3] = BSWAP(pmac->u[3]);",
          "388:    pmac->u[4] = BSWAP(pmac->u[4]);",
          "389:    pmac->u[5] = BSWAP(pmac->u[5]);",
          "390:    pmac->u[6] = BSWAP(pmac->u[6]);",
          "391:    pmac->u[7] = BSWAP(pmac->u[7]);",
          "",
          "[Added Lines]",
          "565: #ifdef BSWAP4",
          "566:    pmac->u[0] = BSWAP4(pmac->u[0]);",
          "567:    pmac->u[1] = BSWAP4(pmac->u[1]);",
          "568:    pmac->u[2] = BSWAP4(pmac->u[2]);",
          "569:    pmac->u[3] = BSWAP4(pmac->u[3]);",
          "570:    pmac->u[4] = BSWAP4(pmac->u[4]);",
          "571:    pmac->u[5] = BSWAP4(pmac->u[5]);",
          "572:    pmac->u[6] = BSWAP4(pmac->u[6]);",
          "573:    pmac->u[7] = BSWAP4(pmac->u[7]);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "531:    return SHA256_DIGEST_LENGTH;",
          "532:    }",
          "533:   }",
          "534:  default:",
          "535:   return -1;",
          "536:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "716: #if EVP_EVP_CIPH_FLAG_TLS11_MULTI_BLOCK",
          "717:  case EVP_CTRL_TLS11_MULTI_BLOCK_AAD:",
          "718:   {",
          "719:   EVP_CTRL_TLS11_MULTI_BLOCK_PARAM *param =",
          "720:    (EVP_CTRL_TLS11_MULTI_BLOCK_PARAM *)ptr;",
          "721:   unsigned int n4x=1, x4;",
          "722:   unsigned int frag, last, packlen, inp_len;",
          "724:   if (arg<sizeof(EVP_CTRL_TLS11_MULTI_BLOCK_PARAM)) return -1;",
          "726:   inp_len = param->inp[11]<<8|param->inp[12];",
          "728:   if (ctx->encrypt)",
          "729:    {",
          "730:    if ((param->inp[9]<<8|param->inp[10]) < TLS1_1_VERSION)",
          "731:     return -1;",
          "735:    if (inp_len>=6144) n4x=2;",
          "737:    key->md = key->head;",
          "738:    SHA256_Update(&key->md,param->inp,13);",
          "740:    x4 = 4*n4x; n4x += 1;",
          "742:    frag = inp_len>>n4x;",
          "743:    last = inp_len+frag-(frag<<n4x);",
          "744:    if (last>frag && ((last+13+9)%64<(x4-1))) {",
          "745:     frag++;",
          "746:     last -= x4-1;",
          "747:    }",
          "749:    packlen = 5+16+((frag+32+16)&-16);",
          "750:    packlen = (packlen<<(1+n4x))-packlen;",
          "751:    packlen += 5+16+((last+32+16)&-16);",
          "753:    param->interleave = x4;",
          "755:    return (int)packlen;",
          "756:    }",
          "757:   else",
          "759:   }",
          "760:  case EVP_CTRL_TLS11_MULTI_BLOCK_ENCRYPT:",
          "761:   {",
          "762:   EVP_CTRL_TLS11_MULTI_BLOCK_PARAM *param =",
          "763:    (EVP_CTRL_TLS11_MULTI_BLOCK_PARAM *)ptr;",
          "765:   return tls11_multi_block_encrypt(key,param->out,param->inp,",
          "766:       param->len,param->interleave/4);",
          "767:   }",
          "768:  case EVP_CTRL_TLS11_MULTI_BLOCK_DECRYPT:",
          "769: #endif",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "544:  NID_undef,",
          "545: #endif",
          "546:  16,16,16,",
          "548:  aesni_cbc_hmac_sha256_init_key,",
          "549:  aesni_cbc_hmac_sha256_cipher,",
          "550:  NULL,",
          "",
          "[Removed Lines]",
          "547:  EVP_CIPH_CBC_MODE|EVP_CIPH_FLAG_DEFAULT_ASN1|EVP_CIPH_FLAG_AEAD_CIPHER,",
          "",
          "[Added Lines]",
          "783:  EVP_CIPH_CBC_MODE|EVP_CIPH_FLAG_DEFAULT_ASN1|",
          "784:  EVP_CIPH_FLAG_AEAD_CIPHER|EVP_CIPH_FLAG_TLS11_MULTI_BLOCK,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "563:  NID_undef,",
          "564: #endif",
          "565:  16,32,16,",
          "567:  aesni_cbc_hmac_sha256_init_key,",
          "568:  aesni_cbc_hmac_sha256_cipher,",
          "569:  NULL,",
          "",
          "[Removed Lines]",
          "566:  EVP_CIPH_CBC_MODE|EVP_CIPH_FLAG_DEFAULT_ASN1|EVP_CIPH_FLAG_AEAD_CIPHER,",
          "",
          "[Added Lines]",
          "803:  EVP_CIPH_CBC_MODE|EVP_CIPH_FLAG_DEFAULT_ASN1|",
          "804:  EVP_CIPH_FLAG_AEAD_CIPHER|EVP_CIPH_FLAG_TLS11_MULTI_BLOCK,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dd7e60bd70730da4c9f8f542a6bd8951746ac2ca",
      "candidate_info": {
        "commit_hash": "dd7e60bd70730da4c9f8f542a6bd8951746ac2ca",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/dd7e60bd70730da4c9f8f542a6bd8951746ac2ca",
        "files": [
          "ssl/d1_pkt.c",
          "ssl/s3_cbc.c",
          "ssl/s3_enc.c",
          "ssl/s3_pkt.c",
          "ssl/ssl3.h",
          "ssl/ssl_locl.h",
          "ssl/t1_enc.c"
        ],
        "message": "ssl/*: revert \"remove SSL_RECORD->orig_len\" and merge \"fix IV\".\n\nRevert is appropriate because binary compatibility is not an issue\nin 1.1.",
        "before_after_code_files": [
          "ssl/d1_pkt.c||ssl/d1_pkt.c",
          "ssl/s3_cbc.c||ssl/s3_cbc.c",
          "ssl/s3_enc.c||ssl/s3_enc.c",
          "ssl/s3_pkt.c||ssl/s3_pkt.c",
          "ssl/ssl3.h||ssl/ssl3.h",
          "ssl/ssl_locl.h||ssl/ssl_locl.h",
          "ssl/t1_enc.c||ssl/t1_enc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ssl/s3_cbc.c||ssl/s3_cbc.c"
          ],
          "candidate": [
            "ssl/s3_cbc.c||ssl/s3_cbc.c"
          ]
        }
      },
      "candidate_diff": {
        "ssl/d1_pkt.c||ssl/d1_pkt.c": [
          "File: ssl/d1_pkt.c -> ssl/d1_pkt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "379:  int enc_err;",
          "380:  SSL_SESSION *sess;",
          "381:  SSL3_RECORD *rr;",
          "383:  unsigned char md[EVP_MAX_MD_SIZE];",
          "385:  rr= &(s->s3->rrec);",
          "",
          "[Removed Lines]",
          "382:  unsigned int mac_size, orig_len;",
          "",
          "[Added Lines]",
          "382:  unsigned int mac_size;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "412:  rr->data=rr->input;",
          "415:  enc_err = s->method->ssl3_enc->enc(s,0);",
          "",
          "[Removed Lines]",
          "413:  orig_len=rr->length;",
          "",
          "[Added Lines]",
          "413:  rr->orig_len=rr->length;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "452:       (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&",
          "454:    {",
          "455:    al=SSL_AD_DECODE_ERROR;",
          "456:    SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_LENGTH_TOO_SHORT);",
          "",
          "[Removed Lines]",
          "450:   if (orig_len < mac_size ||",
          "453:        orig_len < mac_size+1))",
          "",
          "[Added Lines]",
          "450:   if (rr->orig_len < mac_size ||",
          "453:        rr->orig_len < mac_size+1))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "467:    mac = mac_tmp;",
          "469:    rr->length -= mac_size;",
          "470:    }",
          "471:   else",
          "472:    {",
          "476:    rr->length -= mac_size;",
          "",
          "[Removed Lines]",
          "468:    ssl3_cbc_copy_mac(mac_tmp, rr, mac_size, orig_len);",
          "",
          "[Added Lines]",
          "468:    ssl3_cbc_copy_mac(mac_tmp, rr, mac_size);",
          "",
          "---------------"
        ],
        "ssl/s3_cbc.c||ssl/s3_cbc.c": [
          "File: ssl/s3_cbc.c -> ssl/s3_cbc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "116:  good = constant_time_ge(rec->length, padding_length+overhead);",
          "118:  good &= constant_time_ge(block_size, padding_length+1);",
          "122:  return (int)((good & 1) | (~good & -1));",
          "123: }",
          "",
          "[Removed Lines]",
          "119:  padding_length = good & (padding_length+1);",
          "120:  rec->length -= padding_length;",
          "",
          "[Added Lines]",
          "119:  rec->length -= good & (padding_length+1);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "139:        unsigned mac_size)",
          "140:  {",
          "141:  unsigned padding_length, good, to_check, i;",
          "162:   {",
          "163:   rec->data += block_size;",
          "164:   rec->input += block_size;",
          "165:   rec->length -= block_size;",
          "166:   }",
          "168:  padding_length = rec->data[rec->length-1];",
          "",
          "[Removed Lines]",
          "142:  const char has_explicit_iv =",
          "143:   s->version >= TLS1_1_VERSION || s->version == DTLS1_VERSION;",
          "144:  const unsigned overhead = 1 /* padding length byte */ +",
          "145:       mac_size +",
          "146:       (has_explicit_iv ? block_size : 0);",
          "150:  if (overhead > rec->length)",
          "151:   return 0;",
          "161:  if (has_explicit_iv)",
          "",
          "[Added Lines]",
          "140:  const unsigned overhead = 1 /* padding length byte */ + mac_size;",
          "142:  if (s->version >= TLS1_1_VERSION || s->version == DTLS1_VERSION)",
          "147:   if (overhead + block_size > rec->length)",
          "148:    return 0;",
          "153:   rec->orig_len -= block_size;",
          "155:  else if (overhead > rec->length)",
          "156:   return 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "190:  if (EVP_CIPHER_flags(s->enc_read_ctx->cipher)&EVP_CIPH_FLAG_AEAD_CIPHER)",
          "191:   {",
          "194:   return 1;",
          "195:   }",
          "",
          "[Removed Lines]",
          "193:   rec->length -= padding_length;",
          "",
          "[Added Lines]",
          "183:   rec->length -= padding_length + 1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "227:  good <<= sizeof(good)*8-1;",
          "228:  good = DUPLICATE_MSB_TO_ALL(good);",
          "234:  return (int)((good & 1) | (~good & -1));",
          "235:  }",
          "",
          "[Removed Lines]",
          "230:  padding_length = good & (padding_length+1);",
          "231:  rec->length -= padding_length;",
          "",
          "[Added Lines]",
          "220:  rec->length -= good & (padding_length+1);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "257: void ssl3_cbc_copy_mac(unsigned char* out,",
          "258:          const SSL3_RECORD *rec,",
          "260:  {",
          "261: #if defined(CBC_MAC_ROTATE_IN_PLACE)",
          "262:  unsigned char rotated_mac_buf[EVP_MAX_MD_SIZE*2];",
          "",
          "[Removed Lines]",
          "259:          unsigned md_size,unsigned orig_len)",
          "",
          "[Added Lines]",
          "247:          unsigned md_size)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "275:  unsigned div_spoiler;",
          "276:  unsigned rotate_offset;",
          "279:  OPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);",
          "281: #if defined(CBC_MAC_ROTATE_IN_PLACE)",
          "",
          "[Removed Lines]",
          "278:  OPENSSL_assert(orig_len >= md_size);",
          "",
          "[Added Lines]",
          "266:  OPENSSL_assert(rec->orig_len >= md_size);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "283: #endif",
          "",
          "[Removed Lines]",
          "286:  if (orig_len > md_size + 255 + 1)",
          "287:   scan_start = orig_len - (md_size + 255 + 1);",
          "",
          "[Added Lines]",
          "274:  if (rec->orig_len > md_size + 255 + 1)",
          "275:   scan_start = rec->orig_len - (md_size + 255 + 1);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "297:  rotate_offset = (div_spoiler + mac_start - scan_start) % md_size;",
          "299:  memset(rotated_mac, 0, md_size);",
          "301:   {",
          "303:    {",
          "304:    unsigned char mac_started = constant_time_ge(i, mac_start);",
          "305:    unsigned char mac_ended = constant_time_ge(i, mac_end);",
          "",
          "[Removed Lines]",
          "300:  for (i = scan_start; i < orig_len;)",
          "302:   for (j = 0; j < md_size && i < orig_len; i++, j++)",
          "",
          "[Added Lines]",
          "288:  for (i = scan_start; i < rec->orig_len;)",
          "290:   for (j = 0; j < md_size && i < rec->orig_len; i++, j++)",
          "",
          "---------------"
        ],
        "ssl/s3_enc.c||ssl/s3_enc.c": [
          "File: ssl/s3_enc.c -> ssl/s3_enc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "730:  EVP_MD_CTX md_ctx;",
          "731:  const EVP_MD_CTX *hash;",
          "732:  unsigned char *p,rec_char;",
          "734:  int npad;",
          "735:  int t;",
          "",
          "[Removed Lines]",
          "733:  size_t md_size, orig_len;",
          "",
          "[Added Lines]",
          "733:  size_t md_size;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "755:  md_size=t;",
          "756:  npad=(48/md_size)*md_size;",
          "762:  if (!send &&",
          "763:      EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&",
          "764:      ssl3_cbc_record_digest_supported(hash))",
          "",
          "[Removed Lines]",
          "759:  orig_len = rec->length+md_size+((unsigned int)rec->type>>8);",
          "760:  rec->type &= 0xff;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "790:    hash,",
          "791:    md, &md_size,",
          "792:    header, rec->input,",
          "794:    mac_sec, md_size,",
          "795:    1 /* is SSLv3 */);",
          "796:   }",
          "",
          "[Removed Lines]",
          "793:    rec->length + md_size, orig_len,",
          "",
          "[Added Lines]",
          "789:    rec->length + md_size, rec->orig_len,",
          "",
          "---------------"
        ],
        "ssl/s3_pkt.c||ssl/s3_pkt.c": [
          "File: ssl/s3_pkt.c -> ssl/s3_pkt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "290:  unsigned char *p;",
          "291:  unsigned char md[EVP_MAX_MD_SIZE];",
          "292:  short version;",
          "294:  size_t extra;",
          "296:  rr= &(s->s3->rrec);",
          "",
          "[Removed Lines]",
          "293:  unsigned mac_size, orig_len;",
          "",
          "[Added Lines]",
          "293:  unsigned mac_size;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "402:  rr->data=rr->input;",
          "405:  enc_err = s->method->ssl3_enc->enc(s,0);",
          "",
          "[Removed Lines]",
          "403:  orig_len=rr->length;",
          "",
          "[Added Lines]",
          "403:  rr->orig_len=rr->length;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "441:       (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&",
          "443:    {",
          "444:    al=SSL_AD_DECODE_ERROR;",
          "445:    SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_LENGTH_TOO_SHORT);",
          "",
          "[Removed Lines]",
          "439:   if (orig_len < mac_size ||",
          "442:        orig_len < mac_size+1))",
          "",
          "[Added Lines]",
          "439:   if (rr->orig_len < mac_size ||",
          "442:        rr->orig_len < mac_size+1))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "456:    mac = mac_tmp;",
          "458:    rr->length -= mac_size;",
          "459:    }",
          "460:   else",
          "461:    {",
          "465:    rr->length -= mac_size;",
          "",
          "[Removed Lines]",
          "457:    ssl3_cbc_copy_mac(mac_tmp, rr, mac_size, orig_len);",
          "",
          "[Added Lines]",
          "457:    ssl3_cbc_copy_mac(mac_tmp, rr, mac_size);",
          "",
          "---------------"
        ],
        "ssl/ssl3.h||ssl/ssl3.h": [
          "File: ssl/ssl3.h -> ssl/ssl3.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "366:  {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "370:        was removed? This is used to implement the",
          "371:        MAC check in constant time for CBC records.",
          "",
          "---------------"
        ],
        "ssl/ssl_locl.h||ssl/ssl_locl.h": [
          "File: ssl/ssl_locl.h -> ssl/ssl_locl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1276: void ssl3_cbc_copy_mac(unsigned char* out,",
          "1277:          const SSL3_RECORD *rec,",
          "1279: int ssl3_cbc_remove_padding(const SSL* s,",
          "1280:        SSL3_RECORD *rec,",
          "1281:        unsigned block_size,",
          "",
          "[Removed Lines]",
          "1278:          unsigned md_size,unsigned orig_len);",
          "",
          "[Added Lines]",
          "1278:          unsigned md_size);",
          "",
          "---------------"
        ],
        "ssl/t1_enc.c||ssl/t1_enc.c": [
          "File: ssl/t1_enc.c -> ssl/t1_enc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "973:  SSL3_RECORD *rec;",
          "974:  unsigned char *seq;",
          "975:  EVP_MD_CTX *hash;",
          "977:  int i;",
          "978:  EVP_MD_CTX hmac, *mac_ctx;",
          "979:  unsigned char header[13];",
          "",
          "[Removed Lines]",
          "976:  size_t md_size, orig_len;",
          "",
          "[Added Lines]",
          "976:  size_t md_size;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1020:  else",
          "1021:   memcpy(header, seq, 8);",
          "1027:  header[8]=rec->type;",
          "1028:  header[9]=(unsigned char)(ssl->version>>8);",
          "1029:  header[10]=(unsigned char)(ssl->version);",
          "",
          "[Removed Lines]",
          "1024:  orig_len = rec->length+md_size+((unsigned int)rec->type>>8);",
          "1025:  rec->type &= 0xff;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1042:    mac_ctx,",
          "1043:    md, &md_size,",
          "1044:    header, rec->input,",
          "1046:    ssl->s3->read_mac_secret,",
          "1047:    ssl->s3->read_mac_secret_size,",
          "1048:    0 /* not SSLv3 */);",
          "",
          "[Removed Lines]",
          "1045:    rec->length + md_size, orig_len,",
          "",
          "[Added Lines]",
          "1041:    rec->length + md_size, rec->orig_len,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1058:    tls_fips_digest_extra(",
          "1059:          ssl->enc_read_ctx,",
          "1060:      mac_ctx, rec->input,",
          "1062: #endif",
          "1063:   }",
          "",
          "[Removed Lines]",
          "1061:      rec->length, orig_len);",
          "",
          "[Added Lines]",
          "1057:      rec->length, rec->orig_len);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2acc020b770920657a169bf6be4ff12b254255e6",
      "candidate_info": {
        "commit_hash": "2acc020b770920657a169bf6be4ff12b254255e6",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/2acc020b770920657a169bf6be4ff12b254255e6",
        "files": [
          "crypto/evp/c_allc.c",
          "ssl/Makefile",
          "ssl/d1_enc.c",
          "ssl/s3_enc.c",
          "ssl/s3_pkt.c",
          "ssl/ssl3.h",
          "ssl/ssl_algs.c",
          "ssl/ssl_locl.h",
          "ssl/t1_enc.c"
        ],
        "message": "Make CBC decoding constant time.\n\nThis patch makes the decoding of SSLv3 and TLS CBC records constant\ntime. Without this, a timing side-channel can be used to build a padding\noracle and mount Vaudenay's attack.\n\nThis patch also disables the stitched AESNI+SHA mode pending a similar\nfix to that code.\n\nIn order to be easy to backport, this change is implemented in ssl/,\nrather than as a generic AEAD mode. In the future this should be changed\naround so that HMAC isn't in ssl/, but crypto/ as FIPS expects.\n(cherry picked from commit e130841bccfc0bb9da254dc84e23bc6a1c78a64e)",
        "before_after_code_files": [
          "crypto/evp/c_allc.c||crypto/evp/c_allc.c",
          "ssl/d1_enc.c||ssl/d1_enc.c",
          "ssl/s3_enc.c||ssl/s3_enc.c",
          "ssl/s3_pkt.c||ssl/s3_pkt.c",
          "ssl/ssl3.h||ssl/ssl3.h",
          "ssl/ssl_algs.c||ssl/ssl_algs.c",
          "ssl/ssl_locl.h||ssl/ssl_locl.h",
          "ssl/t1_enc.c||ssl/t1_enc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crypto/evp/c_allc.c||crypto/evp/c_allc.c",
            "ssl/ssl_algs.c||ssl/ssl_algs.c"
          ],
          "candidate": [
            "crypto/evp/c_allc.c||crypto/evp/c_allc.c",
            "ssl/ssl_algs.c||ssl/ssl_algs.c"
          ]
        }
      },
      "candidate_diff": {
        "crypto/evp/c_allc.c||crypto/evp/c_allc.c": [
          "File: crypto/evp/c_allc.c -> crypto/evp/c_allc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "195:  EVP_add_cipher(EVP_aes_256_xts());",
          "196:  EVP_add_cipher_alias(SN_aes_256_cbc,\"AES256\");",
          "197:  EVP_add_cipher_alias(SN_aes_256_cbc,\"aes256\");",
          "198: #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)",
          "199:  EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());",
          "200:  EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());",
          "201: #endif",
          "202: #endif",
          "204: #ifndef OPENSSL_NO_CAMELLIA",
          "205:  EVP_add_cipher(EVP_camellia_128_ecb());",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "204: #endif",
          "",
          "---------------"
        ],
        "ssl/d1_enc.c||ssl/d1_enc.c": [
          "File: ssl/d1_enc.c -> ssl/d1_enc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "131:  SSL3_RECORD *rec;",
          "132:  EVP_CIPHER_CTX *ds;",
          "133:  unsigned long l;",
          "135:  const EVP_CIPHER *enc;",
          "137:  if (send)",
          "138:   {",
          "139:   if (EVP_MD_CTX_md(s->write_hash))",
          "140:    {",
          "143:     return -1;",
          "144:    }",
          "145:   ds=s->enc_write_ctx;",
          "",
          "[Removed Lines]",
          "134:  int bs,i,ii,j,k,n=0;",
          "141:    n=EVP_MD_CTX_size(s->write_hash);",
          "142:    if (n < 0)",
          "",
          "[Added Lines]",
          "134:  int bs,i,j,k,mac_size=0;",
          "141:    mac_size=EVP_MD_CTX_size(s->write_hash);",
          "142:    if (mac_size < 0)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "164:   {",
          "165:   if (EVP_MD_CTX_md(s->read_hash))",
          "166:    {",
          "169:     return -1;",
          "170:    }",
          "171:   ds=s->enc_read_ctx;",
          "",
          "[Removed Lines]",
          "167:    n=EVP_MD_CTX_size(s->read_hash);",
          "168:    if (n < 0)",
          "",
          "[Added Lines]",
          "167:    mac_size=EVP_MD_CTX_size(s->read_hash);",
          "168:    if (mac_size < 0)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "245:                 }",
          "248:   if ((bs != 1) && !send)",
          "286:   }",
          "287:  return(1);",
          "288:  }",
          "",
          "[Removed Lines]",
          "249:    {",
          "251:    i++;",
          "252:    if (s->options&SSL_OP_TLS_BLOCK_PADDING_BUG)",
          "253:     {",
          "255:     if ((memcmp(s->s3->read_sequence,",
          "256:      \"\\0\\0\\0\\0\\0\\0\\0\\0\",8) == 0) && !(ii & 1))",
          "257:      s->s3->flags|=TLS1_FLAGS_TLS_PADDING_BUG;",
          "258:     if (s->s3->flags & TLS1_FLAGS_TLS_PADDING_BUG)",
          "259:      i--;",
          "260:     }",
          "263:    if (i + bs > (int)rec->length)",
          "264:     {",
          "270:     return -1;",
          "271:     }",
          "272:    for (j=(int)(l-i); j<(int)l; j++)",
          "273:     {",
          "274:     if (rec->data[j] != ii)",
          "275:      {",
          "277:      return -1;",
          "278:      }",
          "279:     }",
          "280:    rec->length-=i;",
          "283:    rec->input += bs;",
          "284:    rec->length -= bs;",
          "285:    }",
          "",
          "[Added Lines]",
          "248:   rec->orig_len = rec->length;",
          "250:    return tls1_cbc_remove_padding(s, rec, bs, mac_size);",
          "",
          "---------------"
        ],
        "ssl/s3_enc.c||ssl/s3_enc.c": [
          "File: ssl/s3_enc.c -> ssl/s3_enc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "492:  SSL3_RECORD *rec;",
          "493:  EVP_CIPHER_CTX *ds;",
          "494:  unsigned long l;",
          "496:  const EVP_CIPHER *enc;",
          "498:  if (send)",
          "",
          "[Removed Lines]",
          "495:  int bs,i;",
          "",
          "[Added Lines]",
          "495:  int bs,i,mac_size=0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "554:   EVP_Cipher(ds,rec->data,rec->input,l);",
          "556:   if ((bs != 1) && !send)",
          "572:   }",
          "573:  return(1);",
          "574:  }",
          "",
          "[Removed Lines]",
          "557:    {",
          "558:    i=rec->data[l-1]+1;",
          "561:    if (i > bs)",
          "562:     {",
          "567:     return -1;",
          "568:     }",
          "570:    rec->length-=i;",
          "571:    }",
          "",
          "[Added Lines]",
          "556:   rec->orig_len = rec->length;",
          "558:   if (EVP_MD_CTX_md(s->read_hash) != NULL)",
          "559:    mac_size = EVP_MD_CTX_size(s->read_hash);",
          "561:    return ssl3_cbc_remove_padding(s, rec, bs, mac_size);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "737:  EVP_MD_CTX md_ctx;",
          "738:  const EVP_MD_CTX *hash;",
          "739:  unsigned char *p,rec_char;",
          "741:  int npad;",
          "742:  int t;",
          "",
          "[Removed Lines]",
          "740:  unsigned int md_size;",
          "",
          "[Added Lines]",
          "730:  size_t md_size;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "762:  md_size=t;",
          "763:  npad=(48/md_size)*md_size;",
          "788:  ssl3_record_sequence_update(seq);",
          "789:  return(md_size);",
          "",
          "[Removed Lines]",
          "766:  EVP_MD_CTX_init(&md_ctx);",
          "768:  EVP_MD_CTX_copy_ex( &md_ctx,hash);",
          "769:  EVP_DigestUpdate(&md_ctx,mac_sec,md_size);",
          "770:  EVP_DigestUpdate(&md_ctx,ssl3_pad_1,npad);",
          "771:  EVP_DigestUpdate(&md_ctx,seq,8);",
          "772:  rec_char=rec->type;",
          "773:  EVP_DigestUpdate(&md_ctx,&rec_char,1);",
          "774:  p=md;",
          "775:  s2n(rec->length,p);",
          "776:  EVP_DigestUpdate(&md_ctx,md,2);",
          "777:  EVP_DigestUpdate(&md_ctx,rec->input,rec->length);",
          "778:  EVP_DigestFinal_ex( &md_ctx,md,NULL);",
          "780:  EVP_MD_CTX_copy_ex( &md_ctx,hash);",
          "781:  EVP_DigestUpdate(&md_ctx,mac_sec,md_size);",
          "782:  EVP_DigestUpdate(&md_ctx,ssl3_pad_2,npad);",
          "783:  EVP_DigestUpdate(&md_ctx,md,md_size);",
          "784:  EVP_DigestFinal_ex( &md_ctx,md,&md_size);",
          "786:  EVP_MD_CTX_cleanup(&md_ctx);",
          "",
          "[Added Lines]",
          "755:  if (!send &&",
          "756:      EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&",
          "757:      ssl3_cbc_record_digest_supported(hash))",
          "758:   {",
          "770:   unsigned char header[75];",
          "771:   unsigned j = 0;",
          "772:   memcpy(header+j, mac_sec, md_size);",
          "773:   j += md_size;",
          "774:   memcpy(header+j, ssl3_pad_1, npad);",
          "775:   j += npad;",
          "776:   memcpy(header+j, seq, 8);",
          "777:   j += 8;",
          "778:   header[j++] = rec->type;",
          "779:   header[j++] = rec->length >> 8;",
          "780:   header[j++] = rec->length & 0xff;",
          "782:   ssl3_cbc_digest_record(",
          "783:    hash,",
          "784:    md, &md_size,",
          "785:    header, rec->input,",
          "786:    rec->length + md_size, rec->orig_len,",
          "787:    mac_sec, md_size,",
          "788:    1 /* is SSLv3 */);",
          "789:   }",
          "790:  else",
          "791:   {",
          "792:   unsigned int md_size_u;",
          "794:   EVP_MD_CTX_init(&md_ctx);",
          "796:   EVP_MD_CTX_copy_ex( &md_ctx,hash);",
          "797:   EVP_DigestUpdate(&md_ctx,mac_sec,md_size);",
          "798:   EVP_DigestUpdate(&md_ctx,ssl3_pad_1,npad);",
          "799:   EVP_DigestUpdate(&md_ctx,seq,8);",
          "800:   rec_char=rec->type;",
          "801:   EVP_DigestUpdate(&md_ctx,&rec_char,1);",
          "802:   p=md;",
          "803:   s2n(rec->length,p);",
          "804:   EVP_DigestUpdate(&md_ctx,md,2);",
          "805:   EVP_DigestUpdate(&md_ctx,rec->input,rec->length);",
          "806:   EVP_DigestFinal_ex( &md_ctx,md,NULL);",
          "808:   EVP_MD_CTX_copy_ex( &md_ctx,hash);",
          "809:   EVP_DigestUpdate(&md_ctx,mac_sec,md_size);",
          "810:   EVP_DigestUpdate(&md_ctx,ssl3_pad_2,npad);",
          "811:   EVP_DigestUpdate(&md_ctx,md,md_size);",
          "812:   EVP_DigestFinal_ex( &md_ctx,md,&md_size_u);",
          "813:   md_size = md_size_u;",
          "815:   EVP_MD_CTX_cleanup(&md_ctx);",
          "816:  }",
          "",
          "---------------"
        ],
        "ssl/s3_pkt.c||ssl/s3_pkt.c": [
          "File: ssl/s3_pkt.c -> ssl/s3_pkt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "290:  unsigned char *p;",
          "291:  unsigned char md[EVP_MAX_MD_SIZE];",
          "292:  short version;",
          "294:  int clear=0;",
          "295:  size_t extra;",
          "299:  rr= &(s->s3->rrec);",
          "300:  sess=s->session;",
          "",
          "[Removed Lines]",
          "293:  int mac_size;",
          "296:  int decryption_failed_or_bad_record_mac = 0;",
          "297:  unsigned char *mac = NULL;",
          "",
          "[Added Lines]",
          "293:  unsigned mac_size;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "405:  rr->data=rr->input;",
          "407:  enc_err = s->method->ssl3_enc->enc(s,0);",
          "409:   {",
          "419:   }",
          "421: #ifdef TLS_DEBUG",
          "",
          "[Removed Lines]",
          "408:  if (enc_err <= 0)",
          "410:   if (enc_err == 0)",
          "412:    goto err;",
          "418:   decryption_failed_or_bad_record_mac = 1;",
          "",
          "[Added Lines]",
          "406:  if (enc_err == 0)",
          "409:   goto err;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "433:  if (!clear)",
          "434:   {",
          "436:   mac_size=EVP_MD_CTX_size(s->read_hash);",
          "440:    {",
          "444:    goto f_err;",
          "448:    }",
          "451:    {",
          "452:    rr->length -= mac_size;",
          "454:    }",
          "455:   else",
          "456:    {",
          "466:    }",
          "468:   if (i < 0 || mac == NULL || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)",
          "472:   }",
          "475:   {",
          "",
          "[Removed Lines]",
          "437:   OPENSSL_assert(mac_size >= 0);",
          "439:   if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH+extra+mac_size)",
          "442:    al=SSL_AD_RECORD_OVERFLOW;",
          "443:    SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_PRE_MAC_LENGTH_TOO_LONG);",
          "445: #else",
          "446:    decryption_failed_or_bad_record_mac = 1;",
          "447: #endif",
          "450:   if (rr->length >= (unsigned int)mac_size)",
          "453:    mac = &rr->data[rr->length];",
          "459:    al=SSL_AD_DECODE_ERROR;",
          "460:    SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_LENGTH_TOO_SHORT);",
          "461:    goto f_err;",
          "462: #else",
          "463:    decryption_failed_or_bad_record_mac = 1;",
          "464:    rr->length = 0;",
          "465: #endif",
          "467:   i=s->method->ssl3_enc->mac(s,md,0);",
          "469:    {",
          "470:    decryption_failed_or_bad_record_mac = 1;",
          "471:    }",
          "474:  if (decryption_failed_or_bad_record_mac)",
          "",
          "[Added Lines]",
          "427:   unsigned char *mac = NULL;",
          "428:   unsigned char mac_tmp[EVP_MAX_MD_SIZE];",
          "430:   OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);",
          "437:   if (rr->orig_len < mac_size ||",
          "439:       (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&",
          "440:        rr->orig_len < mac_size+1))",
          "442:    al=SSL_AD_DECODE_ERROR;",
          "443:    SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_LENGTH_TOO_SHORT);",
          "447:   if (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE)",
          "454:    mac = mac_tmp;",
          "455:    ssl3_cbc_copy_mac(mac_tmp, rr, mac_size);",
          "463:    rr->length -= mac_size;",
          "464:    mac = &rr->data[rr->length];",
          "467:   i=s->method->ssl3_enc->mac(s,md,0 /* not send */);",
          "469:    enc_err = -1;",
          "470:   if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH+extra+mac_size)",
          "471:    enc_err = -1;",
          "474:  if (enc_err < 0)",
          "",
          "---------------"
        ],
        "ssl/ssl3.h||ssl/ssl3.h": [
          "File: ssl/ssl3.h -> ssl/ssl3.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "375:  } SSL3_RECORD;",
          "377: typedef struct ssl3_buffer_st",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "376:        was removed? This is used to implement the",
          "377:        MAC check in constant time for CBC records.",
          "",
          "---------------"
        ],
        "ssl/ssl_algs.c||ssl/ssl_algs.c": [
          "File: ssl/ssl_algs.c -> ssl/ssl_algs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "90:  EVP_add_cipher(EVP_aes_256_cbc());",
          "91:  EVP_add_cipher(EVP_aes_128_gcm());",
          "92:  EVP_add_cipher(EVP_aes_256_gcm());",
          "93: #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)",
          "94:  EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());",
          "95:  EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());",
          "96: #endif",
          "97: #endif",
          "98: #ifndef OPENSSL_NO_CAMELLIA",
          "99:  EVP_add_cipher(EVP_camellia_128_cbc());",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "98: #endif",
          "",
          "---------------"
        ],
        "ssl/ssl_locl.h||ssl/ssl_locl.h": [
          "File: ssl/ssl_locl.h -> ssl/ssl_locl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "218: #define n2l6(c,l) (l =((BN_ULLONG)(*((c)++)))<<40, \\",
          "219:     l|=((BN_ULLONG)(*((c)++)))<<32, \\",
          "220:     l|=((BN_ULLONG)(*((c)++)))<<24, \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "218: #define l2n8(l,c) (*((c)++)=(unsigned char)(((l)>>56)&0xff), \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1263: int ssl_add_serverhello_use_srtp_ext(SSL *s, unsigned char *p, int *len, int maxlen);",
          "1264: int ssl_parse_serverhello_use_srtp_ext(SSL *s, unsigned char *d, int len,int *al);",
          "1266: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1276: void ssl3_cbc_copy_mac(unsigned char* out,",
          "1277:          const SSL3_RECORD *rec,",
          "1278:          unsigned md_size);",
          "1279: int ssl3_cbc_remove_padding(const SSL* s,",
          "1280:        SSL3_RECORD *rec,",
          "1281:        unsigned block_size,",
          "1282:        unsigned mac_size);",
          "1283: int tls1_cbc_remove_padding(const SSL* s,",
          "1284:        SSL3_RECORD *rec,",
          "1285:        unsigned block_size,",
          "1286:        unsigned mac_size);",
          "1287: char ssl3_cbc_record_digest_supported(const EVP_MD_CTX *ctx);",
          "1288: void ssl3_cbc_digest_record(",
          "1289:  const EVP_MD_CTX *ctx,",
          "1290:  unsigned char* md_out,",
          "1291:  size_t* md_out_size,",
          "1292:  const unsigned char header[13],",
          "1293:  const unsigned char *data,",
          "1294:  size_t data_plus_mac_size,",
          "1295:  size_t data_plus_mac_plus_padding_size,",
          "1296:  const unsigned char *mac_secret,",
          "1297:  unsigned mac_secret_length,",
          "1298:  char is_sslv3);",
          "",
          "---------------"
        ],
        "ssl/t1_enc.c||ssl/t1_enc.c": [
          "File: ssl/t1_enc.c -> ssl/t1_enc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "696:  SSL3_RECORD *rec;",
          "697:  EVP_CIPHER_CTX *ds;",
          "698:  unsigned long l;",
          "700:  const EVP_CIPHER *enc;",
          "702:  if (send)",
          "",
          "[Removed Lines]",
          "699:  int bs,i,ii,j,k,pad=0;",
          "",
          "[Added Lines]",
          "699:  int bs,i,j,k,pad=0,ret,mac_size=0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "753:  printf(\"tls1_enc(%d)\\n\", send);",
          "758:   {",
          "759:   memmove(rec->data,rec->input,rec->length);",
          "760:   rec->input=rec->data;",
          "761:   }",
          "762:  else",
          "763:   {",
          "",
          "[Removed Lines]",
          "756:  if ((s->session == NULL) || (ds == NULL) ||",
          "757:   (enc == NULL))",
          "",
          "[Added Lines]",
          "756:  if ((s->session == NULL) || (ds == NULL) || (enc == NULL))",
          "760:   ret = 1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "822: #ifdef KSSL_DEBUG",
          "823:   {",
          "825:   printf(\"EVP_Cipher(ds=%p,rec->data=%p,rec->input=%p,l=%ld) ==>\\n\",",
          "827:   printf(\"\\tEVP_CIPHER_CTX: %d buf_len, %d key_len [%d %d], %d iv_len\\n\",",
          "831:   printf(\"\\t\\tIV: \");",
          "832:   for (i=0; i<ds->cipher->iv_len; i++) printf(\"%02X\", ds->iv[i]);",
          "833:   printf(\"\\n\");",
          "",
          "[Removed Lines]",
          "824:                 unsigned long ui;",
          "826:                         ds,rec->data,rec->input,l);",
          "828:                         ds->buf_len, ds->cipher->key_len,",
          "829:                         DES_KEY_SZ, DES_SCHEDULE_SZ,",
          "830:                         ds->cipher->iv_len);",
          "",
          "[Added Lines]",
          "824:   unsigned long ui;",
          "826:    ds,rec->data,rec->input,l);",
          "828:    ds->buf_len, ds->cipher->key_len,",
          "829:    DES_KEY_SZ, DES_SCHEDULE_SZ,",
          "830:    ds->cipher->iv_len);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "864: #ifdef KSSL_DEBUG",
          "865:   {",
          "868:   for (i=0; i<l; i++)",
          "873:   if ((bs != 1) && !send)",
          "923:   if (pad && !send)",
          "924:    rec->length -= pad;",
          "925:   }",
          "927:  }",
          "928: int tls1_cert_verify_mac(SSL *s, int md_nid, unsigned char *out)",
          "929:  {",
          "930:  unsigned int ret;",
          "",
          "[Removed Lines]",
          "866:                 unsigned long i;",
          "867:                 printf(\"\\trec->data=\");",
          "869:                         printf(\" %02x\", rec->data[i]);  printf(\"\\n\");",
          "870:                 }",
          "874:    {",
          "876:    i++;",
          "884:    if ( (s->options&SSL_OP_TLS_BLOCK_PADDING_BUG)",
          "885:     && !s->expand)",
          "886:     {",
          "888:     if ((memcmp(s->s3->read_sequence,",
          "889:      \"\\0\\0\\0\\0\\0\\0\\0\\0\",8) == 0) && !(ii & 1))",
          "890:      s->s3->flags|=TLS1_FLAGS_TLS_PADDING_BUG;",
          "891:     if (s->s3->flags & TLS1_FLAGS_TLS_PADDING_BUG)",
          "892:      i--;",
          "893:     }",
          "896:    if (i > (int)rec->length)",
          "897:     {",
          "902:     return -1;",
          "903:     }",
          "904:    for (j=(int)(l-i); j<(int)l; j++)",
          "905:     {",
          "906:     if (rec->data[j] != ii)",
          "907:      {",
          "909:      return -1;",
          "910:      }",
          "911:     }",
          "912:    rec->length -=i;",
          "913:    if (s->version >= TLS1_1_VERSION",
          "914:     && EVP_CIPHER_CTX_mode(ds) == EVP_CIPH_CBC_MODE)",
          "915:     {",
          "916:     if (bs > (int)rec->length)",
          "917:      return -1;",
          "919:     rec->input += bs;",
          "920:     rec->length -= bs;",
          "921:     }",
          "922:    }",
          "926:  return(1);",
          "",
          "[Added Lines]",
          "866:   unsigned long i;",
          "867:   printf(\"\\trec->data=\");",
          "869:    printf(\" %02x\", rec->data[i]);  printf(\"\\n\");",
          "870:   }",
          "873:   rec->orig_len = rec->length;",
          "875:   ret = 1;",
          "876:   if (EVP_MD_CTX_md(s->read_hash) != NULL)",
          "877:    mac_size = EVP_MD_CTX_size(s->read_hash);",
          "879:    ret = tls1_cbc_remove_padding(s, rec, bs, mac_size);",
          "883:  return ret;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1017:  size_t md_size;",
          "1018:  int i;",
          "1019:  EVP_MD_CTX hmac, *mac_ctx;",
          "1021:  int stream_mac = (send?(ssl->mac_flags & SSL_MAC_FLAG_WRITE_MAC_STREAM):(ssl->mac_flags&SSL_MAC_FLAG_READ_MAC_STREAM));",
          "1022:  int t;",
          "",
          "[Removed Lines]",
          "1020:  unsigned char buf[5];",
          "",
          "[Added Lines]",
          "978:  unsigned char header[13];",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1038:  OPENSSL_assert(t >= 0);",
          "1039:  md_size=t;",
          "1048:  if (stream_mac)",
          "1049:   {",
          "",
          "[Removed Lines]",
          "1041:  buf[0]=rec->type;",
          "1042:  buf[1]=(unsigned char)(ssl->version>>8);",
          "1043:  buf[2]=(unsigned char)(ssl->version);",
          "1044:  buf[3]=rec->length>>8;",
          "1045:  buf[4]=rec->length&0xff;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1062:   s2n(send?ssl->d1->w_epoch:ssl->d1->r_epoch, p);",
          "1063:   memcpy (p,&seq[2],6);",
          "1066:   }",
          "1067:  else",
          "1076: #ifdef TLS_DEBUG",
          "1077: printf(\"sec=\");",
          "1078: {unsigned int z; for (z=0; z<md_size; z++) printf(\"%02X \",mac_sec[z]); printf(\"\\n\"); }",
          "",
          "[Removed Lines]",
          "1065:   EVP_DigestSignUpdate(mac_ctx,dtlsseq,8);",
          "1068:   EVP_DigestSignUpdate(mac_ctx,seq,8);",
          "1070:  EVP_DigestSignUpdate(mac_ctx,buf,5);",
          "1071:  EVP_DigestSignUpdate(mac_ctx,rec->input,rec->length);",
          "1072:  t=EVP_DigestSignFinal(mac_ctx,md,&md_size);",
          "1073:  OPENSSL_assert(t > 0);",
          "1075:  if (!stream_mac) EVP_MD_CTX_cleanup(&hmac);",
          "",
          "[Added Lines]",
          "1017:   memcpy(header, dtlsseq, 8);",
          "1020:   memcpy(header, seq, 8);",
          "1022:  header[8]=rec->type;",
          "1023:  header[9]=(unsigned char)(ssl->version>>8);",
          "1024:  header[10]=(unsigned char)(ssl->version);",
          "1025:  header[11]=(rec->length)>>8;",
          "1026:  header[12]=(rec->length)&0xff;",
          "1028:  if (!send &&",
          "1029:      EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&",
          "1030:      ssl3_cbc_record_digest_supported(mac_ctx))",
          "1031:   {",
          "1036:   ssl3_cbc_digest_record(",
          "1037:    mac_ctx,",
          "1038:    md, &md_size,",
          "1039:    header, rec->input,",
          "1040:    rec->length + md_size, rec->orig_len,",
          "1041:    ssl->s3->read_mac_secret,",
          "1042:    ssl->s3->read_mac_secret_size,",
          "1043:    0 /* not SSLv3 */);",
          "1044:   }",
          "1045:  else",
          "1046:   {",
          "1047:   EVP_DigestSignUpdate(mac_ctx,header,sizeof(header));",
          "1048:   EVP_DigestSignUpdate(mac_ctx,rec->input,rec->length);",
          "1049:   t=EVP_DigestSignFinal(mac_ctx,md,&md_size);",
          "1050:   OPENSSL_assert(t > 0);",
          "1051:   }",
          "1053:  if (!stream_mac)",
          "1054:   EVP_MD_CTX_cleanup(&hmac);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
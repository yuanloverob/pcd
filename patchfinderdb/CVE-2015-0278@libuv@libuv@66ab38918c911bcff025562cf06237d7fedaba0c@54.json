{
  "cve_id": "CVE-2015-0278",
  "cve_desc": "libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.",
  "repo": "libuv/libuv",
  "patch_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
  "patch_info": {
    "commit_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
    "repo": "libuv/libuv",
    "commit_url": "https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c",
    "files": [
      "src/unix/process.c"
    ],
    "message": "unix: call setgoups before calling setuid/setgid\n\nPartial fix for #1093",
    "before_after_code_files": [
      "src/unix/process.c||src/unix/process.c"
    ]
  },
  "patch_diff": {
    "src/unix/process.c||src/unix/process.c": [
      "File: src/unix/process.c -> src/unix/process.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "330:     _exit(127);",
      "331:   }",
      "333:   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {",
      "334:     uv__write_int(error_fd, -errno);",
      "335:     perror(\"setgid()\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "333:   if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {",
      "341:     SAVE_ERRNO(setgroups(0, NULL));",
      "342:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7ff52b836db74379d306447ccf66b3c069d3f1a4",
      "candidate_info": {
        "commit_hash": "7ff52b836db74379d306447ccf66b3c069d3f1a4",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/7ff52b836db74379d306447ccf66b3c069d3f1a4",
        "files": [
          "src/unix/timer.c",
          "src/win/timer.c",
          "test/test-list.h",
          "test/test-timer.c"
        ],
        "message": "unix, windows: don't allow a NULL callback on timers",
        "before_after_code_files": [
          "src/unix/timer.c||src/unix/timer.c",
          "src/win/timer.c||src/win/timer.c",
          "test/test-list.h||test/test-list.h",
          "test/test-timer.c||test/test-timer.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/unix/timer.c||src/unix/timer.c": [
          "File: src/unix/timer.c -> src/unix/timer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "65:                    uint64_t repeat) {",
          "66:   uint64_t clamped_timeout;",
          "68:   if (uv__is_active(handle))",
          "69:     uv_timer_stop(handle);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68:   if (cb == NULL)",
          "69:     return -EINVAL;",
          "",
          "---------------"
        ],
        "src/win/timer.c||src/win/timer.c": [
          "File: src/win/timer.c -> src/win/timer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "119:   uv_loop_t* loop = handle->loop;",
          "120:   uv_timer_t* old;",
          "122:   if (handle->flags & UV_HANDLE_ACTIVE) {",
          "123:     RB_REMOVE(uv_timer_tree_s, &loop->timers, handle);",
          "124:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "122:   if (timer_cb == NULL)",
          "123:     return UV_EINVAL;",
          "",
          "---------------"
        ],
        "test/test-list.h||test/test-list.h": [
          "File: test/test-list.h -> test/test-list.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "133: TEST_DECLARE   (timer_huge_repeat)",
          "134: TEST_DECLARE   (timer_run_once)",
          "135: TEST_DECLARE   (timer_from_check)",
          "136: TEST_DECLARE   (idle_starvation)",
          "137: TEST_DECLARE   (loop_handles)",
          "138: TEST_DECLARE   (get_loadavg)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "136: TEST_DECLARE   (timer_null_callback)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "451:   TEST_ENTRY  (timer_huge_repeat)",
          "452:   TEST_ENTRY  (timer_run_once)",
          "453:   TEST_ENTRY  (timer_from_check)",
          "455:   TEST_ENTRY  (idle_starvation)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "455:   TEST_ENTRY  (timer_null_callback)",
          "",
          "---------------"
        ],
        "test/test-timer.c||test/test-timer.c": [
          "File: test/test-timer.c -> test/test-timer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "290:   MAKE_VALGRIND_HAPPY();",
          "291:   return 0;",
          "292: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "295: TEST_IMPL(timer_null_callback) {",
          "296:   uv_timer_t handle;",
          "298:   ASSERT(0 == uv_timer_init(uv_default_loop(), &handle));",
          "299:   ASSERT(UV_EINVAL == uv_timer_start(&handle, NULL, 100, 100));",
          "301:   MAKE_VALGRIND_HAPPY();",
          "302:   return 0;",
          "303: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b597d157791d83ad49130bfec3718231da2e0aef",
      "candidate_info": {
        "commit_hash": "b597d157791d83ad49130bfec3718231da2e0aef",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/b597d157791d83ad49130bfec3718231da2e0aef",
        "files": [
          "src/unix/stream.c",
          "src/win/pipe.c"
        ],
        "message": "stream: do not leak `alloc_cb` buffers on error\n\nAlways pass previously allocated (if any) buffer, when calling\n`read_cb()` on error.",
        "before_after_code_files": [
          "src/unix/stream.c||src/unix/stream.c",
          "src/win/pipe.c||src/win/pipe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/unix/stream.c||src/unix/stream.c": [
          "File: src/unix/stream.c -> src/unix/stream.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1127:       if (is_ipc) {",
          "1128:         err = uv__stream_recv_cmsg(stream, &msg);",
          "1129:         if (err != 0) {",
          "1131:           return;",
          "1132:         }",
          "1133:       }",
          "",
          "[Removed Lines]",
          "1130:           stream->read_cb(stream, err, NULL);",
          "",
          "[Added Lines]",
          "1130:           stream->read_cb(stream, err, &buf);",
          "",
          "---------------"
        ],
        "src/win/pipe.c||src/win/pipe.c": [
          "File: src/win/pipe.c -> src/win/pipe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1347:   handle->flags &= ~UV_HANDLE_READABLE;",
          "1348:   uv_read_stop((uv_stream_t*) handle);",
          "1351: }",
          "",
          "[Removed Lines]",
          "1350:   handle->read_cb((uv_stream_t*) handle, UV_EOF, &uv_null_buf_);",
          "",
          "[Added Lines]",
          "1350:   handle->read_cb((uv_stream_t*) handle, UV_EOF, &buf);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1505:           break;",
          "1506:         }",
          "1507:       } else {",
          "1509:         break;",
          "1510:       }",
          "1511:     }",
          "",
          "[Removed Lines]",
          "1508:         uv_pipe_read_error_or_eof(loop, handle, GetLastError(), uv_null_buf_);",
          "",
          "[Added Lines]",
          "1508:         uv_pipe_read_error_or_eof(loop, handle, GetLastError(), buf);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5af98d3843eee0f16c6b0ecc1d8f3be73bbaa1e7",
      "candidate_info": {
        "commit_hash": "5af98d3843eee0f16c6b0ecc1d8f3be73bbaa1e7",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/5af98d3843eee0f16c6b0ecc1d8f3be73bbaa1e7",
        "files": [
          "test/runner-unix.c"
        ],
        "message": "test: replace strcpy() with strncpy()",
        "before_after_code_files": [
          "test/runner-unix.c||test/runner-unix.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "test/runner-unix.c||test/runner-unix.c": [
          "File: test/runner-unix.c -> test/runner-unix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "50:   setvbuf(stdout, NULL, _IONBF, 0);",
          "51:   setvbuf(stderr, NULL, _IONBF, 0);",
          "53:   signal(SIGPIPE, SIG_IGN);",
          "54: }",
          "",
          "[Removed Lines]",
          "52:   strcpy(executable_path, argv[0]);",
          "",
          "[Added Lines]",
          "52:   strncpy(executable_path, argv[0], sizeof(executable_path) - 1);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5879c613941194db43eeadf87c6ad30e6f08132b",
      "candidate_info": {
        "commit_hash": "5879c613941194db43eeadf87c6ad30e6f08132b",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/5879c613941194db43eeadf87c6ad30e6f08132b",
        "files": [
          "src/unix/pipe.c",
          "src/unix/stream.c",
          "src/unix/tcp.c",
          "src/unix/udp.c"
        ],
        "message": "unix: remove errno preserving code\n\nRemove the errno preserving code. Libuv only implemented it in a\nhaphazard way and there seems to be a general consensus that no one\nreally cares anyway. Therefore, remove it.",
        "before_after_code_files": [
          "src/unix/pipe.c||src/unix/pipe.c",
          "src/unix/stream.c||src/unix/stream.c",
          "src/unix/tcp.c||src/unix/tcp.c",
          "src/unix/udp.c||src/unix/udp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/unix/pipe.c||src/unix/pipe.c": [
          "File: src/unix/pipe.c -> src/unix/pipe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "45: int uv_pipe_bind(uv_pipe_t* handle, const char* name) {",
          "46:   struct sockaddr_un saddr;",
          "47:   const char* pipe_fname;",
          "49:   int sockfd;",
          "50:   int status;",
          "51:   int bound;",
          "54:   pipe_fname = NULL;",
          "55:   sockfd = -1;",
          "56:   status = -1;",
          "",
          "[Removed Lines]",
          "48:   int saved_errno;",
          "53:   saved_errno = errno;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "105:     free((void*)pipe_fname);",
          "106:   }",
          "109:   return status;",
          "110: }",
          "113: int uv_pipe_listen(uv_pipe_t* handle, int backlog, uv_connection_cb cb) {",
          "124:   assert(uv__stream_fd(handle) >= 0);",
          "137: }",
          "",
          "[Removed Lines]",
          "108:   errno = saved_errno;",
          "114:   int saved_errno;",
          "115:   int status;",
          "117:   saved_errno = errno;",
          "118:   status = -1;",
          "120:   if (uv__stream_fd(handle) == -1) {",
          "121:     uv__set_artificial_error(handle->loop, UV_EINVAL);",
          "122:     goto out;",
          "123:   }",
          "126:   if ((status = listen(uv__stream_fd(handle), backlog)) == -1) {",
          "127:     uv__set_sys_error(handle->loop, errno);",
          "128:   } else {",
          "129:     handle->connection_cb = cb;",
          "130:     handle->io_watcher.cb = uv__pipe_accept;",
          "131:     uv__io_start(handle->loop, &handle->io_watcher, UV__POLLIN);",
          "132:   }",
          "134: out:",
          "135:   errno = saved_errno;",
          "136:   return status;",
          "",
          "[Added Lines]",
          "111:   if (uv__stream_fd(handle) == -1)",
          "112:     return uv__set_artificial_error(handle->loop, UV_EINVAL);",
          "115:   if (listen(uv__stream_fd(handle), backlog))",
          "116:     return uv__set_sys_error(handle->loop, errno);",
          "118:   handle->connection_cb = cb;",
          "119:   handle->io_watcher.cb = uv__pipe_accept;",
          "120:   uv__io_start(handle->loop, &handle->io_watcher, UV__POLLIN);",
          "121:   return 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "171:                     const char* name,",
          "172:                     uv_connect_cb cb) {",
          "173:   struct sockaddr_un saddr;",
          "175:   int new_sock;",
          "176:   int err;",
          "177:   int r;",
          "180:   new_sock = (uv__stream_fd(handle) == -1);",
          "181:   err = -1;",
          "",
          "[Removed Lines]",
          "174:   int saved_errno;",
          "179:   saved_errno = errno;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "227: }",
          "231: static void uv__pipe_accept(uv_loop_t* loop, uv__io_t* w, unsigned int events) {",
          "232:   uv_pipe_t* pipe;",
          "234:   int sockfd;",
          "237:   pipe = container_of(w, uv_pipe_t, io_watcher);",
          "239:   assert(pipe->type == UV_NAMED_PIPE);",
          "241:   sockfd = uv__accept(uv__stream_fd(pipe));",
          "",
          "[Removed Lines]",
          "226:   errno = saved_errno;",
          "233:   int saved_errno;",
          "236:   saved_errno = errno;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "252:       uv__io_stop(pipe->loop, &pipe->io_watcher, UV__POLLIN);",
          "253:     }",
          "254:   }",
          "257: }",
          "",
          "[Removed Lines]",
          "256:   errno = saved_errno;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/unix/stream.c||src/unix/stream.c": [
          "File: src/unix/stream.c -> src/unix/stream.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "538: int uv_accept(uv_stream_t* server, uv_stream_t* client) {",
          "543:   assert(server->loop == client->loop);",
          "553:   switch (client->type) {",
          "554:     case UV_NAMED_PIPE:",
          "",
          "[Removed Lines]",
          "539:   int saved_errno;",
          "540:   int status;",
          "545:   saved_errno = errno;",
          "546:   status = -1;",
          "548:   if (server->accepted_fd < 0) {",
          "549:     uv__set_sys_error(server->loop, EAGAIN);",
          "550:     goto out;",
          "551:   }",
          "",
          "[Added Lines]",
          "542:   if (server->accepted_fd == -1)",
          "543:     return uv__set_sys_error(server->loop, EAGAIN);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "560:         close(server->accepted_fd);",
          "561:         server->accepted_fd = -1;",
          "563:       }",
          "564:       break;",
          "",
          "[Removed Lines]",
          "562:         goto out;",
          "",
          "[Added Lines]",
          "554:         return -1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "567:       if (uv_udp_open((uv_udp_t*) client, server->accepted_fd)) {",
          "568:         close(server->accepted_fd);",
          "569:         server->accepted_fd = -1;",
          "571:       }",
          "572:       break;",
          "",
          "[Removed Lines]",
          "570:         goto out;",
          "",
          "[Added Lines]",
          "562:         return -1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "578:   uv__io_start(server->loop, &server->io_watcher, UV__POLLIN);",
          "579:   server->accepted_fd = -1;",
          "585: }",
          "",
          "[Removed Lines]",
          "580:   status = 0;",
          "582: out:",
          "583:   errno = saved_errno;",
          "584:   return status;",
          "",
          "[Added Lines]",
          "572:   return 0;",
          "",
          "---------------"
        ],
        "src/unix/tcp.c||src/unix/tcp.c": [
          "File: src/unix/tcp.c -> src/unix/tcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "151: }",
          "156:   socklen_t socklen;",
          "188: }",
          "193:   socklen_t socklen;",
          "225: }",
          "",
          "[Removed Lines]",
          "154: int uv_tcp_getsockname(uv_tcp_t* handle, struct sockaddr* name,",
          "155:     int* namelen) {",
          "157:   int saved_errno;",
          "158:   int rv = 0;",
          "161:   saved_errno = errno;",
          "163:   if (handle->delayed_error) {",
          "164:     uv__set_sys_error(handle->loop, handle->delayed_error);",
          "165:     rv = -1;",
          "166:     goto out;",
          "167:   }",
          "169:   if (uv__stream_fd(handle) < 0) {",
          "170:     uv__set_sys_error(handle->loop, EINVAL);",
          "171:     rv = -1;",
          "172:     goto out;",
          "173:   }",
          "176:   socklen = (socklen_t)*namelen;",
          "178:   if (getsockname(uv__stream_fd(handle), name, &socklen) == -1) {",
          "179:     uv__set_sys_error(handle->loop, errno);",
          "180:     rv = -1;",
          "181:   } else {",
          "183:   }",
          "185: out:",
          "186:   errno = saved_errno;",
          "187:   return rv;",
          "191: int uv_tcp_getpeername(uv_tcp_t* handle, struct sockaddr* name,",
          "192:     int* namelen) {",
          "194:   int saved_errno;",
          "195:   int rv = 0;",
          "198:   saved_errno = errno;",
          "200:   if (handle->delayed_error) {",
          "201:     uv__set_sys_error(handle->loop, handle->delayed_error);",
          "202:     rv = -1;",
          "203:     goto out;",
          "204:   }",
          "206:   if (uv__stream_fd(handle) < 0) {",
          "207:     uv__set_sys_error(handle->loop, EINVAL);",
          "208:     rv = -1;",
          "209:     goto out;",
          "210:   }",
          "213:   socklen = (socklen_t)*namelen;",
          "215:   if (getpeername(uv__stream_fd(handle), name, &socklen) == -1) {",
          "216:     uv__set_sys_error(handle->loop, errno);",
          "217:     rv = -1;",
          "218:   } else {",
          "220:   }",
          "222: out:",
          "223:   errno = saved_errno;",
          "224:   return rv;",
          "",
          "[Added Lines]",
          "154: int uv_tcp_getsockname(uv_tcp_t* handle,",
          "155:                        struct sockaddr* name,",
          "156:                        int* namelen) {",
          "159:   if (handle->delayed_error)",
          "160:     return uv__set_sys_error(handle->loop, handle->delayed_error);",
          "162:   if (uv__stream_fd(handle) < 0)",
          "163:     return uv__set_sys_error(handle->loop, EINVAL);",
          "166:   socklen = (socklen_t) *namelen;",
          "168:   if (getsockname(uv__stream_fd(handle), name, &socklen) == -1)",
          "169:     return uv__set_sys_error(handle->loop, errno);",
          "172:   return 0;",
          "176: int uv_tcp_getpeername(uv_tcp_t* handle,",
          "177:                        struct sockaddr* name,",
          "178:                        int* namelen) {",
          "181:   if (handle->delayed_error)",
          "182:     return uv__set_sys_error(handle->loop, handle->delayed_error);",
          "184:   if (uv__stream_fd(handle) < 0)",
          "185:     return uv__set_sys_error(handle->loop, EINVAL);",
          "188:   socklen = (socklen_t) *namelen;",
          "190:   if (getpeername(uv__stream_fd(handle), name, &socklen) == -1)",
          "191:     return uv__set_sys_error(handle->loop, errno);",
          "194:   return 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "259:                     uv_tcp_t* handle,",
          "260:                     struct sockaddr_in addr,",
          "261:                     uv_connect_cb cb) {",
          "270: }",
          "",
          "[Removed Lines]",
          "262:   int saved_errno;",
          "263:   int status;",
          "265:   saved_errno = errno;",
          "266:   status = uv__connect(req, handle, (struct sockaddr*)&addr, sizeof addr, cb);",
          "267:   errno = saved_errno;",
          "269:   return status;",
          "",
          "[Added Lines]",
          "232:   return uv__connect(req, handle, (struct sockaddr*) &addr, sizeof addr, cb);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "274:                      uv_tcp_t* handle,",
          "275:                      struct sockaddr_in6 addr,",
          "276:                      uv_connect_cb cb) {",
          "285: }",
          "",
          "[Removed Lines]",
          "277:   int saved_errno;",
          "278:   int status;",
          "280:   saved_errno = errno;",
          "281:   status = uv__connect(req, handle, (struct sockaddr*)&addr, sizeof addr, cb);",
          "282:   errno = saved_errno;",
          "284:   return status;",
          "",
          "[Added Lines]",
          "240:   return uv__connect(req, handle, (struct sockaddr*) &addr, sizeof addr, cb);",
          "",
          "---------------"
        ],
        "src/unix/udp.c||src/unix/udp.c": [
          "File: src/unix/udp.c -> src/unix/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "291:                     struct sockaddr* addr,",
          "292:                     socklen_t len,",
          "293:                     unsigned flags) {",
          "296:   int yes;",
          "297:   int fd;",
          "301:   fd = -1;",
          "320:     handle->io_watcher.fd = fd;",
          "321:   }",
          "324:   yes = 1;",
          "325:   if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof yes) == -1) {",
          "326:     uv__set_sys_error(handle->loop, errno);",
          "",
          "[Removed Lines]",
          "294:   int saved_errno;",
          "295:   int status;",
          "299:   saved_errno = errno;",
          "300:   status = -1;",
          "304:   if (flags & ~UV_UDP_IPV6ONLY) {",
          "305:     uv__set_sys_error(handle->loop, EINVAL);",
          "306:     goto out;",
          "307:   }",
          "310:   if ((flags & UV_UDP_IPV6ONLY) && domain != AF_INET6) {",
          "311:     uv__set_sys_error(handle->loop, EINVAL);",
          "312:     goto out;",
          "313:   }",
          "315:   if (handle->io_watcher.fd == -1) {",
          "316:     if ((fd = uv__socket(domain, SOCK_DGRAM, 0)) == -1) {",
          "317:       uv__set_sys_error(handle->loop, errno);",
          "318:       goto out;",
          "319:     }",
          "323:   fd = handle->io_watcher.fd;",
          "",
          "[Added Lines]",
          "300:   if (flags & ~UV_UDP_IPV6ONLY)",
          "301:     return uv__set_sys_error(handle->loop, EINVAL);",
          "304:   if ((flags & UV_UDP_IPV6ONLY) && domain != AF_INET6)",
          "305:     return uv__set_sys_error(handle->loop, EINVAL);",
          "307:   fd = handle->io_watcher.fd;",
          "308:   if (fd == -1) {",
          "309:     fd = uv__socket(domain, SOCK_DGRAM, 0);",
          "310:     if (fd == -1)",
          "311:       return uv__set_sys_error(handle->loop, errno);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "361:     goto out;",
          "362:   }",
          "367: out:",
          "375: }",
          "",
          "[Removed Lines]",
          "364:   handle->io_watcher.fd = fd;",
          "365:   status = 0;",
          "368:   if (status) {",
          "369:     close(handle->io_watcher.fd);",
          "370:     handle->io_watcher.fd = -1;",
          "371:   }",
          "373:   errno = saved_errno;",
          "374:   return status;",
          "",
          "[Added Lines]",
          "355:   return 0;",
          "358:   close(handle->io_watcher.fd);",
          "359:   handle->io_watcher.fd = -1;",
          "360:   return -1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "481: int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock) {",
          "484:   int yes;",
          "495:   yes = 1;",
          "",
          "[Removed Lines]",
          "482:   int saved_errno;",
          "483:   int status;",
          "486:   saved_errno = errno;",
          "487:   status = -1;",
          "490:   if (handle->io_watcher.fd != -1) {",
          "491:     uv__set_artificial_error(handle->loop, UV_EALREADY);",
          "492:     goto out;",
          "493:   }",
          "496:   if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof yes) == -1) {",
          "497:     uv__set_sys_error(handle->loop, errno);",
          "498:     goto out;",
          "499:   }",
          "",
          "[Added Lines]",
          "471:   if (handle->io_watcher.fd != -1)",
          "472:     return uv__set_artificial_error(handle->loop, UV_EALREADY);",
          "475:   if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof yes) == -1)",
          "476:     return uv__set_sys_error(handle->loop, errno);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "509: #ifdef SO_REUSEPORT",
          "510:   yes = 1;",
          "515: #endif",
          "517:   handle->io_watcher.fd = sock;",
          "523: }",
          "",
          "[Removed Lines]",
          "511:   if (setsockopt(sock, SOL_SOCKET, SO_REUSEPORT, &yes, sizeof yes) == -1) {",
          "512:     uv__set_sys_error(handle->loop, errno);",
          "513:     goto out;",
          "514:   }",
          "518:   status = 0;",
          "520: out:",
          "521:   errno = saved_errno;",
          "522:   return status;",
          "",
          "[Added Lines]",
          "488:   if (setsockopt(sock, SOL_SOCKET, SO_REUSEPORT, &yes, sizeof yes) == -1)",
          "489:     return uv__set_sys_error(handle->loop, errno);",
          "493:   return 0;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "617: int uv_udp_getsockname(uv_udp_t* handle, struct sockaddr* name, int* namelen) {",
          "618:   socklen_t socklen;",
          "644: }",
          "",
          "[Removed Lines]",
          "619:   int saved_errno;",
          "620:   int rv = 0;",
          "623:   saved_errno = errno;",
          "625:   if (handle->io_watcher.fd == -1) {",
          "626:     uv__set_sys_error(handle->loop, EINVAL);",
          "627:     rv = -1;",
          "628:     goto out;",
          "629:   }",
          "632:   socklen = (socklen_t)*namelen;",
          "634:   if (getsockname(handle->io_watcher.fd, name, &socklen) == -1) {",
          "635:     uv__set_sys_error(handle->loop, errno);",
          "636:     rv = -1;",
          "637:   } else {",
          "639:   }",
          "641: out:",
          "642:   errno = saved_errno;",
          "643:   return rv;",
          "",
          "[Added Lines]",
          "591:   if (handle->io_watcher.fd == -1)",
          "592:     return uv__set_sys_error(handle->loop, EINVAL);",
          "595:   socklen = (socklen_t) *namelen;",
          "597:   if (getsockname(handle->io_watcher.fd, name, &socklen) == -1)",
          "598:     return uv__set_sys_error(handle->loop, errno);",
          "601:   return 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ffe2ef06eba7c65deea57c5c27c085c51b989dd4",
      "candidate_info": {
        "commit_hash": "ffe2ef06eba7c65deea57c5c27c085c51b989dd4",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/ffe2ef06eba7c65deea57c5c27c085c51b989dd4",
        "files": [
          "include/uv-private/uv-win.h",
          "src/win/core.c",
          "src/win/internal.h",
          "src/win/timer.c"
        ],
        "message": "windows: deal with the fact that GetTickCount might lag\n\nWe use GetQueuedCompletionStatus(Ex) to sleep the thread until the next\ntimer expires (provided that no other events happen before that).\nHowever after waking up from a sleep the GetTickCount() return value may\nnot immediately reflect that some time has passed. This happens because\ngqcs can sometimes sleep for periods shorter than the GetTickCount clock\nresulution. This patch changes time tracking so the amount of time\nwaited by gqcs is taken into account.\n\nThis has the following advantages:\n\n* Excessive loop iterations are avoided.\n* Small timeouts are fired more precisely.\n* The `loop-stop` test that used to be flaky on Windows now passes\n  consistently.",
        "before_after_code_files": [
          "include/uv-private/uv-win.h||include/uv-private/uv-win.h",
          "src/win/core.c||src/win/core.c",
          "src/win/internal.h||src/win/internal.h",
          "src/win/timer.c||src/win/timer.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/uv-private/uv-win.h||include/uv-private/uv-win.h": [
          "File: include/uv-private/uv-win.h -> include/uv-private/uv-win.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "275:   HANDLE iocp;                                                                \\",
          "277:   uint64_t time;                                                              \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "279:   DWORD last_tick_count;                                                      \\",
          "",
          "---------------"
        ],
        "src/win/core.c||src/win/core.c": [
          "File: src/win/core.c -> src/win/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "92:   loop->time = 0;",
          "93:   uv_update_time(loop);",
          "95:   QUEUE_INIT(&loop->handle_queue);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "93:   loop->last_tick_count = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "209:   } else if (GetLastError() != WAIT_TIMEOUT) {",
          "211:     uv_fatal_error(GetLastError(), \"GetQueuedCompletionStatus\");",
          "212:   }",
          "213: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "213:   } else {",
          "217:     uv__time_forward(loop, timeout);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "243:   } else if (GetLastError() != WAIT_TIMEOUT) {",
          "245:     uv_fatal_error(GetLastError(), \"GetQueuedCompletionStatusEx\");",
          "246:   }",
          "247: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "252:   } else if (timeout > 0) {",
          "256:     uv__time_forward(loop, timeout);",
          "",
          "---------------"
        ],
        "src/win/internal.h||src/win/internal.h": [
          "File: src/win/internal.h -> src/win/internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "206: void uv_timer_endgame(uv_loop_t* loop, uv_timer_t* handle);",
          "208: DWORD uv_get_poll_timeout(uv_loop_t* loop);",
          "209: void uv_process_timers(uv_loop_t* loop);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "209: void uv__time_forward(uv_loop_t* loop, uint64_t msecs);",
          "",
          "---------------"
        ],
        "src/win/timer.c||src/win/timer.c": [
          "File: src/win/timer.c -> src/win/timer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: void uv_update_time(uv_loop_t* loop) {",
          "45: }",
          "",
          "[Removed Lines]",
          "32:   DWORD ticks = GetTickCount();",
          "36:   LARGE_INTEGER* time = (LARGE_INTEGER*) &loop->time;",
          "41:   if (ticks < time->LowPart) {",
          "42:     time->HighPart += 1;",
          "43:   }",
          "44:   time->LowPart = ticks;",
          "",
          "[Added Lines]",
          "32:   DWORD ticks;",
          "33:   ULARGE_INTEGER time;",
          "35:   ticks = GetTickCount();",
          "37:   time.QuadPart = loop->time;",
          "43:   time.LowPart = ticks;",
          "44:   if (ticks < loop->last_tick_count)",
          "45:     time.HighPart++;",
          "48:   loop->last_tick_count = ticks;",
          "57:   if (loop->time < time.QuadPart)",
          "58:     loop->time = time.QuadPart;",
          "59: }",
          "62: void uv__time_forward(uv_loop_t* loop, uint64_t msecs) {",
          "63:   loop->time += msecs;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
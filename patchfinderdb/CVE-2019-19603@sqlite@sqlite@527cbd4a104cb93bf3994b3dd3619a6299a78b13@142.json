{
  "cve_id": "CVE-2019-19603",
  "cve_desc": "SQLite 3.30.1 mishandles certain SELECT statements with a nonexistent VIEW, leading to an application crash.",
  "repo": "sqlite/sqlite",
  "patch_hash": "527cbd4a104cb93bf3994b3dd3619a6299a78b13",
  "patch_info": {
    "commit_hash": "527cbd4a104cb93bf3994b3dd3619a6299a78b13",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/527cbd4a104cb93bf3994b3dd3619a6299a78b13",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/build.c",
      "src/sqliteInt.h",
      "test/altertab.test"
    ],
    "message": "Do not allow CREATE TABLE or CREATE VIEW of an object with a name that looks like a shadow table name.\n\nFossilOrigin-Name: 6aef58b629d89955f85f65191ba2be67b2adfac4f0327fe9a7141cb2705dbc00",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/build.c||src/build.c",
      "src/sqliteInt.h||src/sqliteInt.h",
      "test/altertab.test||test/altertab.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 8ad34d36a141fa8f5d9bd784dfeb892c983897a6dc6b867607cc668508acf944",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/build.c||src/build.c": [
      "File: src/build.c -> src/build.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "856:       }",
      "857:     }",
      "858:   }else{",
      "861:     ){",
      "862:       sqlite3ErrorMsg(pParse, \"object name reserved for internal use: %s\",",
      "863:                       zName);",
      "864:       return SQLITE_ERROR;",
      "865:     }",
      "866:   }",
      "867:   return SQLITE_OK;",
      "868: }",
      "",
      "[Removed Lines]",
      "859:     if( pParse->nested==0",
      "860:      && 0==sqlite3StrNICmp(zName, \"sqlite_\", 7)",
      "",
      "[Added Lines]",
      "859:     if( (pParse->nested==0 && 0==sqlite3StrNICmp(zName, \"sqlite_\", 7))",
      "860:      || (sqlite3ReadOnlyShadowTables(db) && sqlite3ShadowTableName(db, zName))",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "2132: static int isShadowTableName(sqlite3 *db, char *zName){",
      "",
      "[Added Lines]",
      "2133: int sqlite3ShadowTableName(sqlite3 *db, const char *zName){",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2147:   if( pMod->pModule->xShadowName==0 ) return 0;",
      "2148:   return pMod->pModule->xShadowName(zTail+1);",
      "2149: }",
      "",
      "[Removed Lines]",
      "2150: #else",
      "2151: # define isShadowTableName(x,y) 0",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2190:   p = pParse->pNewTable;",
      "2191:   if( p==0 ) return;",
      "2194:     p->tabFlags |= TF_Shadow;",
      "2195:   }",
      "",
      "[Removed Lines]",
      "2193:   if( pSelect==0 && isShadowTableName(db, p->zName) ){",
      "",
      "[Added Lines]",
      "2192:   if( pSelect==0 && sqlite3ShadowTableName(db, p->zName) ){",
      "",
      "---------------"
    ],
    "src/sqliteInt.h||src/sqliteInt.h": [
      "File: src/sqliteInt.h -> src/sqliteInt.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "4548: #  define sqlite3VtabInSync(db) ((db)->nVTrans>0 && (db)->aVTrans==0)",
      "4549: #endif",
      "4550: int sqlite3ReadOnlyShadowTables(sqlite3 *db);",
      "4551: int sqlite3VtabEponymousTableInit(Parse*,Module*);",
      "4552: void sqlite3VtabEponymousTableClear(sqlite3*,Module*);",
      "4553: void sqlite3VtabMakeWritable(Parse*,Table*);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4551: #ifndef SQLITE_OMIT_VIRTUALTABLE",
      "4552:   int sqlite3ShadowTableName(sqlite3 *db, const char *zName);",
      "4553: #else",
      "4554: # define sqlite3ShadowTableName(A,B) 0",
      "4555: #endif",
      "",
      "---------------"
    ],
    "test/altertab.test||test/altertab.test": [
      "File: test/altertab.test -> test/altertab.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "547:   } {1 {table y1_segments may not be modified}}",
      "549:   do_catchsql_test 16.20 {",
      "554:     DROP TABLE y1_segments;",
      "555:   } {1 {table y1_segments may not be dropped}}",
      "557:   do_execsql_test 16.30 {",
      "558:     ALTER TABLE y1 RENAME TO z1;",
      "559:   }",
      "",
      "[Removed Lines]",
      "550:     ALTER TABLE y1_segments RENAME TO abc;",
      "551:   } {1 {table y1_segments may not be altered}}",
      "553:   do_catchsql_test 16.21 {",
      "",
      "[Added Lines]",
      "553:   do_catchsql_test 16.20 {",
      "554:     ALTER TABLE y1_segments RENAME TO abc;",
      "555:   } {1 {table y1_segments may not be altered}}",
      "556:   sqlite3_db_config db DEFENSIVE 0",
      "557:   do_catchsql_test 16.22 {",
      "558:     ALTER TABLE y1_segments RENAME TO abc;",
      "559:   } {0 {}}",
      "560:   sqlite3_db_config db DEFENSIVE 1",
      "561:   do_catchsql_test 16.23 {",
      "562:     CREATE TABLE y1_segments AS SELECT * FROM abc;",
      "563:   } {1 {object name reserved for internal use: y1_segments}}",
      "564:   do_catchsql_test 16.24 {",
      "565:     CREATE VIEW y1_segments AS SELECT * FROM abc;",
      "566:   } {1 {object name reserved for internal use: y1_segments}}",
      "567:   sqlite3_db_config db DEFENSIVE 0",
      "568:   do_catchsql_test 16.25 {",
      "569:     ALTER TABLE abc RENAME TO y1_segments;",
      "570:   } {0 {}}",
      "571:   sqlite3_db_config db DEFENSIVE 1",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1efcc9dd965c5b48a1a9e27ce760b38f9d892cb4",
      "candidate_info": {
        "commit_hash": "1efcc9dd965c5b48a1a9e27ce760b38f9d892cb4",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/1efcc9dd965c5b48a1a9e27ce760b38f9d892cb4",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/prepare.c",
          "test/window2.tcl",
          "test/window2.test"
        ],
        "message": "Another very small performance improvement.\n\nFossilOrigin-Name: 7a1e30a17f57ca006dd84b6f97b0c7811bf4c6da4b02903452ffc4bc363cab9b",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/prepare.c||src/prepare.c",
          "test/window2.tcl||test/window2.tcl",
          "test/window2.test||test/window2.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 81eed055de856068109a7e332cca0c3ff1120ebe2bfa5ed6383b165c726e0a7c",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/prepare.c||src/prepare.c": [
          "File: src/prepare.c -> src/prepare.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "635:   rc = sParse.rc;",
          "637: #ifndef SQLITE_OMIT_EXPLAIN",
          "639:     static const char * const azColName[] = {",
          "640:        \"addr\", \"opcode\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"comment\",",
          "641:        \"id\", \"parent\", \"notused\", \"detail\"",
          "",
          "[Removed Lines]",
          "638:   if( rc==SQLITE_OK && sParse.pVdbe && sParse.explain ){",
          "",
          "[Added Lines]",
          "638:   if( sParse.explain && rc==SQLITE_OK && sParse.pVdbe ){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "660:   if( db->init.busy==0 ){",
          "661:     sqlite3VdbeSetSql(sParse.pVdbe, zSql, (int)(sParse.zTail-zSql), prepFlags);",
          "662:   }",
          "665:     assert(!(*ppStmt));",
          "666:   }else{",
          "",
          "[Removed Lines]",
          "663:   if( sParse.pVdbe && (rc!=SQLITE_OK || db->mallocFailed) ){",
          "664:     sqlite3VdbeFinalize(sParse.pVdbe);",
          "",
          "[Added Lines]",
          "663:   if( rc!=SQLITE_OK || db->mallocFailed ){",
          "664:     if( sParse.pVdbe ) sqlite3VdbeFinalize(sParse.pVdbe);",
          "",
          "---------------"
        ],
        "test/window2.tcl||test/window2.tcl": [
          "File: test/window2.tcl -> test/window2.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "428:   SELECT count(*) OVER (ORDER BY b) FROM t1",
          "429: }",
          "433: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "431: execsql_test 4.11 {",
          "432:   SELECT count(distinct a) FILTER (WHERE b='odd') FROM t1",
          "433: }",
          "",
          "---------------"
        ],
        "test/window2.test||test/window2.test": [
          "File: test/window2.test -> test/window2.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "897:   SELECT count(*) OVER (ORDER BY b) FROM t1",
          "898: } {3   3   3   6   6   6}",
          "900: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "900: do_execsql_test 4.11 {",
          "901:   SELECT count(distinct a) FILTER (WHERE b='odd') FROM t1",
          "902: } {3}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ee751fab4c078ca21fe4821a433060efd585e5ce",
      "candidate_info": {
        "commit_hash": "ee751fab4c078ca21fe4821a433060efd585e5ce",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/ee751fab4c078ca21fe4821a433060efd585e5ce",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/resolve.c",
          "src/sqliteInt.h",
          "src/vacuum.c",
          "test/vacuum-into.test"
        ],
        "message": "Raise an error if the argument to VACUUM INTO is an identifier.\n\nFossilOrigin-Name: 6c6fb1c6ea452c70b56fd4ac796affebee21512adba0455ae81c291b715f544f",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/resolve.c||src/resolve.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/vacuum.c||src/vacuum.c",
          "test/vacuum-into.test||test/vacuum-into.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid",
            "src/sqliteInt.h||src/sqliteInt.h"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid",
            "src/sqliteInt.h||src/sqliteInt.h"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 911342f7512145a8a189bb0ec59e70e4c9ddc9f20f3e84816ab25139ead5dc45",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/resolve.c||src/resolve.c": [
          "File: src/resolve.c -> src/resolve.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1662: }",
          "1681: ){",
          "1686:   memset(&sNC, 0, sizeof(sNC));",
          "1687:   memset(&sSrc, 0, sizeof(sSrc));",
          "1692:   sNC.pParse = pParse;",
          "1693:   sNC.pSrcList = &sSrc;",
          "1694:   sNC.ncFlags = type;",
          "1697: }",
          "",
          "[Removed Lines]",
          "1675: void sqlite3ResolveSelfReference(",
          "1685:   assert( type==NC_IsCheck || type==NC_PartIdx || type==NC_IdxExpr );",
          "1688:   sSrc.nSrc = 1;",
          "1689:   sSrc.a[0].zName = pTab->zName;",
          "1690:   sSrc.a[0].pTab = pTab;",
          "1691:   sSrc.a[0].iCursor = -1;",
          "1695:   if( sqlite3ResolveExprNames(&sNC, pExpr) ) return;",
          "1696:   if( pList ) sqlite3ResolveExprListNames(&sNC, pList);",
          "",
          "[Added Lines]",
          "1679: int sqlite3ResolveSelfReference(",
          "1688:   int rc;",
          "1690:   assert( type==0 || pTab!=0 );",
          "1691:   assert( type==NC_IsCheck || type==NC_PartIdx || type==NC_IdxExpr || pTab==0 );",
          "1694:   if( pTab ){",
          "1695:     sSrc.nSrc = 1;",
          "1696:     sSrc.a[0].zName = pTab->zName;",
          "1697:     sSrc.a[0].pTab = pTab;",
          "1698:     sSrc.a[0].iCursor = -1;",
          "1699:   }",
          "1703:   if( (rc = sqlite3ResolveExprNames(&sNC, pExpr))!=SQLITE_OK ) return rc;",
          "1704:   if( pList ) rc = sqlite3ResolveExprListNames(&sNC, pList);",
          "1705:   return rc;",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "4271: int sqlite3ResolveExprNames(NameContext*, Expr*);",
          "4272: int sqlite3ResolveExprListNames(NameContext*, ExprList*);",
          "4273: void sqlite3ResolveSelectNames(Parse*, Select*, NameContext*);",
          "4275: int sqlite3ResolveOrderGroupBy(Parse*, Select*, ExprList*, const char*);",
          "4276: void sqlite3ColumnDefault(Vdbe *, Table *, int, int);",
          "4277: void sqlite3AlterFinishAddColumn(Parse *, Token *);",
          "",
          "[Removed Lines]",
          "4274: void sqlite3ResolveSelfReference(Parse*,Table*,int,Expr*,ExprList*);",
          "",
          "[Added Lines]",
          "4274: int sqlite3ResolveSelfReference(Parse*,Table*,int,Expr*,ExprList*);",
          "",
          "---------------"
        ],
        "src/vacuum.c||src/vacuum.c": [
          "File: src/vacuum.c -> src/vacuum.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "124:   }",
          "125:   if( iDb!=1 ){",
          "126:     int iIntoReg = 0;",
          "128:       iIntoReg = ++pParse->nMem;",
          "129:       sqlite3ExprCode(pParse, pInto, iIntoReg);",
          "130:     }",
          "",
          "[Removed Lines]",
          "127:     if( pInto ){",
          "",
          "[Added Lines]",
          "127:     if( pInto && sqlite3ResolveSelfReference(pParse,0,0,pInto,0)==0 ){",
          "",
          "---------------"
        ],
        "test/vacuum-into.test||test/vacuum-into.test": [
          "File: test/vacuum-into.test -> test/vacuum-into.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "65: do_catchsql_test vacuum-into-310 {",
          "66:   VACUUM INTO null;",
          "67: } {1 {non-text filename}}",
          "69: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68: do_catchsql_test vacuum-into-320 {",
          "69:   VACUUM INTO x;",
          "70: } {1 {no such column: x}}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "934d4f7bac2b43c7888dab130bdcf45ee302c535",
      "candidate_info": {
        "commit_hash": "934d4f7bac2b43c7888dab130bdcf45ee302c535",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/934d4f7bac2b43c7888dab130bdcf45ee302c535",
        "files": [
          "ext/fts5/fts5_index.c",
          "ext/fts5/test/fts5corrupt3.test",
          "manifest",
          "manifest.uuid"
        ],
        "message": "Fix another corruption related crash in fts5.\n\nFossilOrigin-Name: 4538d9afe4e6360e20c7b474e77314e5ad293453e1edbe356bf6ea84c05857ee",
        "before_after_code_files": [
          "ext/fts5/fts5_index.c||ext/fts5/fts5_index.c",
          "ext/fts5/test/fts5corrupt3.test||ext/fts5/test/fts5corrupt3.test",
          "manifest.uuid||manifest.uuid"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/fts5/fts5_index.c||ext/fts5/fts5_index.c": [
          "File: ext/fts5/fts5_index.c -> ext/fts5/fts5_index.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1654:   iOff += fts5GetVarint32(&a[iOff], nNew);",
          "1656:     p->rc = FTS5_CORRUPT;",
          "1657:     return;",
          "1658:   }",
          "",
          "[Removed Lines]",
          "1655:   if( iOff+nNew>pIter->pLeaf->nn || nKeep>pIter->term.n ){",
          "",
          "[Added Lines]",
          "1655:   if( iOff+nNew>pIter->pLeaf->szLeaf || nKeep>pIter->term.n ){",
          "",
          "---------------"
        ],
        "ext/fts5/test/fts5corrupt3.test||ext/fts5/test/fts5corrupt3.test": [
          "File: ext/fts5/test/fts5corrupt3.test -> ext/fts5/test/fts5corrupt3.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "4269:   SELECT * FROM t1 WHERE t1 MATCH 'e*';",
          "4270: } {1 {database disk image is malformed}}",
          "4272: sqlite3_fts5_may_be_corrupt 0",
          "4273: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4272: #-------------------------------------------------------------------------",
          "4273: reset_db",
          "4274: do_test 36.0 {",
          "4275:   sqlite3 db {}",
          "4276:   db deserialize [decode_hexdb {",
          "4277: | size 24576 pagesize 4096 filename crash-a6651222df1bd1.db",
          "4278: | page 1 offset 0",
          "4279: |      0: 53 51 4c 69 74 65 20 66 6f 72 6d 61 74 20 33 00   SQLite format 3.",
          "4280: |     16: 10 00 01 01 00 40 20 20 00 00 00 00 00 00 00 06   .....@  ........",
          "4281: |     32: 00 00 00 00 00 00 00 00 00 00 00 06 00 00 00 04   ................",
          "4282: |     48: 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 00   ................",
          "4283: |     96: 00 00 00 00 0d 00 00 00 06 0e 0f 00 0f aa 0f 53   ...............S",
          "4284: |    112: 0e e8 0e 8b 0e 33 0e 0f 00 00 00 00 00 00 00 00   .....3..........",
          "4285: |   3584: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 22   ................",
          "4286: |   3600: 06 06 17 11 11 01 31 74 61 62 6c 65 62 62 62 62   ......1tablebbbb",
          "4287: |   3616: 06 43 52 45 41 54 45 20 54 41 42 4c 45 20 62 62   .CREATE TABLE bb",
          "4288: |   3632: 28 61 29 56 05 06 17 1f 1f 01 7d 74 61 62 6c 65   (a)V.......table",
          "4289: |   3648: 74 31 5f 63 6f 6e 66 69 67 74 31 5f 63 6f 6e 66   t1_configt1_conf",
          "4290: |   3664: 69 67 05 43 52 45 41 54 45 20 54 41 42 4c 45 20   ig.CREATE TABLE",
          "4291: |   3680: 27 74 31 5f 63 6f 6e 66 69 67 27 28 6b 20 50 52   't1_config'(k PR",
          "4292: |   3696: 49 4d 41 52 59 20 4b 45 59 2c 20 76 29 20 57 49   IMARY KEY, v) WI",
          "4293: |   3712: 54 48 4f 55 54 20 52 4f 57 49 44 5b 04 07 17 21   THOUT ROWID[...!",
          "4294: |   3728: 21 01 81 01 74 61 62 6c 65 74 31 5f 64 6f 63 73   !...tablet1_docs",
          "4295: |   3744: 69 7a 65 74 31 5f 64 6f 63 73 69 7a 65 04 43 52   izet1_docsize.CR",
          "4296: |   3760: 45 41 54 45 20 54 41 42 4c 45 20 27 74 31 5f 64   EATE TABLE 't1_d",
          "4297: |   3776: 6f 63 73 69 7a 65 27 28 69 64 20 49 4e 54 45 47   ocsize'(id INTEG",
          "4298: |   3792: 45 52 20 50 52 49 4d 41 52 59 20 4b 45 59 2c 20   ER PRIMARY KEY,",
          "4299: |   3808: 73 7a 20 42 4c 4f 42 29 69 03 07 17 19 19 01 81   sz BLOB)i.......",
          "4300: |   3824: 2d 74 61 62 6c 65 74 31 5f 69 64 78 74 31 5f 69   -tablet1_idxt1_i",
          "4301: |   3840: 64 78 03 43 52 45 41 54 45 20 54 41 42 4c 45 20   dx.CREATE TABLE",
          "4302: |   3856: 27 74 31 5f 69 64 78 27 28 73 65 67 69 64 2c 20   't1_idx'(segid,",
          "4303: |   3872: 74 65 72 6d 2c 20 70 67 6e 6f 2c 20 50 52 49 4d   term, pgno, PRIM",
          "4304: |   3888: 41 52 59 20 4b 45 59 28 73 65 67 69 64 2c 20 74   ARY KEY(segid, t",
          "4305: |   3904: 65 72 6d 29 29 20 57 49 54 48 4f 55 54 20 52 4f   erm)) WITHOUT RO",
          "4306: |   3920: 57 49 44 55 02 07 17 1b 1b 01 81 01 74 61 62 6c   WIDU........tabl",
          "4307: |   3936: 65 74 31 5f 64 61 74 61 74 31 5f 64 61 74 61 02   et1_datat1_data.",
          "4308: |   3952: 43 52 45 41 54 45 20 54 41 42 4c 45 20 27 74 31   CREATE TABLE 't1",
          "4309: |   3968: 5f 64 61 74 61 27 28 69 64 20 49 4e 54 45 47 45   _data'(id INTEGE",
          "4310: |   3984: 52 20 50 52 49 4d 41 52 59 20 4b 45 59 2c 20 62   R PRIMARY KEY, b",
          "4311: |   4000: 6c 6f 63 6b 20 42 4c 4f 42 29 54 01 07 17 11 11   lock BLOB)T.....",
          "4312: |   4016: 08 81 15 74 61 62 6c 65 74 31 74 31 43 52 45 41   ...tablet1t1CREA",
          "4313: |   4032: 54 45 20 56 49 52 54 55 41 4c 20 54 41 42 4c 45   TE VIRTUAL TABLE",
          "4314: |   4048: 20 74 31 20 55 53 49 4e 47 20 66 74 73 35 28 61    t1 USING fts5(a",
          "4315: |   4064: 2c 62 2c 70 72 65 66 69 78 3d 22 31 2c 32 2c 33   ,b,prefix=.1,2,3",
          "4316: |   4080: 2c 34 22 2c 20 63 6f 6e 74 65 6e 74 3d 22 22 29   ,4., content=..)",
          "4317: | page 2 offset 4096",
          "4318: |      0: 0d 0b 6a 00 37 09 4c 02 0f e7 09 4c 0f c6 0f a4   ..j.7.L....L....",
          "4319: |     16: 0f 88 0f 6d 0f 4b 0f 2c 0f 0e 0e ec 0e cd 0e ad   ...m.K.,........",
          "4320: |     32: 0e 8e 0e 6c 0e 4b 0e 29 0e 08 0d e6 0d c4 0d b5   ...l.K.)........",
          "4321: |     48: 0d 97 0d 76 0d 54 0d 31 0d 15 0c f3 0c d3 0c b5   ...v.T.1........",
          "4322: |     64: 0c 95 0c 73 0c 54 0c 32 0c 10 0b ee 0b cc 0b b0   ...s.T.2........",
          "4323: |     80: 0b 8d 0b 7e 0b 48 0b 2e 0b 0b 0a ef 0a cc 0a ad   ...~.H..........",
          "4324: |     96: 0a 8c 0a 6d 0a 4d 0a 2b 0a 0c 09 ec 09 ca 09 a8   ...m.M.+........",
          "4325: |    112: 09 86 09 63 0f f1 00 00 00 00 00 00 00 00 00 00   ...c............",
          "4326: |   2368: 00 00 00 00 00 00 00 00 00 00 00 00 15 0a 03 00   ................",
          "4327: |   2384: 30 00 00 00 01 01 03 35 00 03 01 11 12 02 01 12   0......5........",
          "4328: |   2400: 03 01 11 1c 8c 80 80 80 80 10 03 00 3e 00 00 00   ............>...",
          "4329: |   2416: 17 01 05 05 34 74 61 62 6c 03 02 03 01 04 77 68   ....4tabl.....wh",
          "4330: |   2432: 65 72 03 02 06 09 1b 8c 80 80 80 80 0f 03 00 3c   er.............<",
          "4331: |   2448: 00 00 00 16 05 34 66 74 73 34 03 02 02 01 04 6e   .....4fts4.....n",
          "4332: |   2464: 75 6d 62 03 06 01 04 09 1b 8c 80 80 80 80 0e 03   umb.............",
          "4333: |   2480: 00 3c 00 00 00 16 04 33 74 68 65 03 06 01 01 04   .<.....3the.....",
          "4334: |   2496: 01 03 77 68 65 03 02 04 04 0a 1b 8c 80 80 80 80   ..whe...........",
          "4335: |   2512: 0d 03 00 3c 00 00 00 16 04 33 6e 75 6d 03 06 01   ...<.....3num...",
          "4336: |   2528: 01 05 01 03 74 61 62 03 02 03 04 0a 19 8c 80 80   ....tab.........",
          "4337: |   2544: 80 80 0c 03 00 38 00 00 00 14 03 32 77 68 03 02   .....8.....2wh..",
          "4338: |   2560: 04 00 04 33 66 74 73 03 02 02 04 07 18 8c 80 80   ...3fts.........",
          "4339: |   2576: 80 80 0b 03 00 36 00 00 00 13 03 32 74 61 03 02   .....6.....2ta..",
          "4340: |   2592: 03 02 01 68 03 06 01 01 04 04 07 1b 8c 80 80 80   ...h............",
          "4341: |   2608: 80 0a 03 00 3c 00 00 00 16 03 32 6e 75 03 06 01   ....<.....2nu...",
          "4342: |   2624: 01 05 01 02 6f 66 03 06 01 01 06 04 09 19 8c 80   ....of..........",
          "4343: |   2640: 80 80 80 09 03 00 38 00 00 00 14 03 32 66 74 03   ......8.....2ft.",
          "4344: |   2656: 02 02 01 02 69 73 03 06 01 01 03 04 07 18 8c 80   ....is..........",
          "4345: |   2672: 80 80 80 08 03 00 36 00 00 00 13 02 31 74 03 08   ......6.....1t..",
          "4346: |   2688: 03 01 01 04 01 01 77 03 02 04 04 09 1a 8c 80 80   ......w.........",
          "4347: |   2704: 80 80 07 03 00 3a 00 00 00 15 02 31 6e 03 08 01   .....:.....1n...",
          "4348: |   2720: 01 02 05 01 00 6f 03 06 01 01 06 04 09 18 8c 80   .....o..........",
          "4349: |   2736: 80 80 80 06 03 00 36 00 00 00 13 04 02 31 66 03   ......6......1f.",
          "4350: |   2752: 02 02 01 01 69 03 06 01 01 03 05 06 1c 8c 80 80   ....i...........",
          "4351: |   2768: 80 80 05 03 00 3e 00 00 00 17 04 30 74 68 65 03   .....>.....0the.",
          "4352: |   2784: 06 01 01 04 01 05 77 68 65 72 65 03 02 04 0a 15   ......where.....",
          "4353: |   2800: 8c 80 80 80 80 04 03 00 30 00 00 00 11 01 01 06   ........0.......",
          "4354: |   2816: 06 30 74 61 62 6c 65 03 02 03 07 1c 8c 80 80 80   .0table.........",
          "4355: |   2832: 80 03 03 00 3e 00 00 00 17 07 30 6e 75 6d 62 65   ....>.....0numbe",
          "4356: |   2848: 72 03 06 01 01 05 01 02 6f 66 03 06 04 0d 13 8c   r.......of......",
          "4357: |   2864: 80 80 80 80 02 03 00 2c 00 00 00 0f 01 01 03 02   .......,........",
          "4358: |   2880: 30 6e 03 06 01 01 02 07 1b 8c 80 80 80 80 01 03   0n..............",
          "4359: |   2896: 00 3c 00 00 00 16 08 30 66 74 73 34 61 75 78 03   .<.....0fts4aux.",
          "4360: |   2912: 02 02 01 02 69 73 03 06 04 0c 00 00 00 14 2a 00   ....is........*.",
          "4361: |   2928: 00 00 01 01 02 24 00 02 01 01 12 02 01 12 08 88   .....$..........",
          "4362: |   2944: 80 80 80 80 12 03 00 16 00 00 00 05 02 1c 88 80   ................",
          "4363: |   2960: 80 80 80 11 03 00 3e 00 00 00 17 05 34 72 6f 77   ......>.....4row",
          "4364: |   2976: 73 02 06 01 01 05 01 04 74 68 65 72 02 02 04 0b   s.......ther....",
          "4365: |   2992: 15 88 80 80 80 80 10 03 00 30 00 00 00 11 02 01   .........0......",
          "4366: |   3008: 01 07 05 34 62 65 74 77 02 02 04 08 1b 88 80 80   ...4betw........",
          "4367: |   3024: 80 80 0f 03 00 3c 00 00 00 16 04 04 33 72 6f 77   .....<......3row",
          "4368: |   3040: 02 06 01 01 05 01 03 74 68 65 02 08 05 0a 1b 88   .......the......",
          "4369: |   3056: 80 80 80 80 0e 03 00 3c 00 00 00 16 01 01 02 04   .......<........",
          "4370: |   3072: 33 61 72 65 02 02 03 01 03 62 65 74 02 02 07 08   3are.....bet....",
          "4371: |   3088: 1b 88 80 80 80 80 0d 03 00 3c 00 00 00 16 13 32   .........<.....2",
          "4372: |   3104: 74 68 02 08 02 01 01 07 00 04 33 61 6e 64 02 06   th........3and..",
          "4373: |   3120: 04 0a 1b 88 80 80 80 80 0c 03 00 3c 00 00 00 16   ...........<....",
          "4374: |   3136: 03 32 69 6e 02 06 01 01 06 01 02 72 6f 02 06 01   .2in.......ro...",
          "4375: |   3152: 01 05 04 09 18 88 80 80 80 80 0b 03 00 36 00 00   .............6..",
          "4376: |   3168: 00 13 02 03 32 61 72 02 02 03 01 02 62 65 02 02   ....2ar.....be..",
          "4377: |   3184: 04 05 07 1b 88 80 80 80 80 0a 03 00 3c 00 00 00   ............<...",
          "4378: |   3200: 16 02 31 74 02 08 02 01 01 07 00 03 32 61 6e 02   ..1t........2an.",
          "4379: |   3216: 06 01 01 04 09 19 88 80 80 80 80 09 03 00 38 00   ..............8.",
          "4380: |   3232: 00 00 14 02 31 6e 02 06 01 01 03 01 01 72 02 06   ....1n.......r..",
          "4381: |   3248: 01 01 05 04 08 17 88 80 80 80 80 08 03 00 34 00   ..............4.",
          "4382: |   3264: 00 00 12 02 31 62 02 02 04 01 01 69 02 06 01 01   ....1b.....i....",
          "4383: |   3280: 06 04 06 19 88 80 80 80 80 07 03 00 38 00 00 00   ............8...",
          "4384: |   3296: 14 04 02 31 32 02 02 05 01 01 61 02 08 03 01 01   ...12.....a.....",
          "4385: |   3312: 02 05 06 1b 88 80 80 80 80 06 03 00 3c 00 00 00   ............<...",
          "4386: |   3328: 16 06 30 74 68 65 72 65 02 02 02 00 02 31 31 02   ..0there.....11.",
          "4387: |   3344: 06 01 01 04 0a 15 88 80 80 80 80 05 03 00 30 00   ..............0.",
          "4388: |   3360: 00 00 11 01 01 05 04 30 74 68 65 02 06 01 01 07   .......0the.....",
          "4389: |   3376: 07 1c 88 80 80 80 80 04 03 00 3e 00 00 00 17 01   ..........>.....",
          "4390: |   3392: 01 06 02 30 6e 02 06 01 01 03 01 04 72 6f 77 73   ...0n.......rows",
          "4391: |   3408: 02 06 07 08 1b 88 80 80 80 80 03 03 00 3c 00 00   .............<..",
          "4392: |   3424: 00 16 08 30 62 65 74 77 65 65 6e 02 02 04 01 02   ...0between.....",
          "4393: |   3440: 69 6e 02 06 04 0c 1a 88 80 80 80 80 02 03 00 3a   in.............:",
          "4394: |   3456: 00 00 00 15 04 30 61 6e 64 02 06 01 01 02 02 02   .....0and.......",
          "4395: |   3472: 72 65 02 02 03 04 0a 17 88 80 80 80 80 01 03 00   re..............",
          "4396: |   3488: 34 00 00 00 12 02 30 31 02 06 01 01 04 01 01 32   4.....01.......2",
          "4397: |   3504: 02 02 05 04 08 08 84 80 80 80 80 12 03 00 16 00   ................",
          "4398: |   3520: 00 00 05 04 1b 84 80 80 80 80 11 03 00 3c 00 00   .............<..",
          "4399: |   3536: 00 16 05 34 74 61 62 6c 01 06 01 01 05 02 03 65   ...4tabl.......e",
          "4400: |   3552: 72 6d 01 02 04 0b 1b 84 80 80 80 80 10 03 00 3c   rm.............<",
          "4401: |   3568: 00 00 00 16 05 34 65 61 63 68 01 02 03 01 04 70   .....4each.....p",
          "4402: |   3584: 72 65 73 01 02 05 04 09 1a 84 80 80 80 80 0f 03   res.............",
          "4403: |   3600: 00 3a 00 00 00 15 04 33 74 65 72 01 02 04 02 02   .:.....3ter.....",
          "4404: |   3616: 68 65 01 06 01 01 03 04 08 1b 84 80 80 80 80 0e   he..............",
          "4405: |   3632: 03 00 3c 00 00 00 16 04 33 70 72 65 01 02 05 01   ..<.....3pre....",
          "4406: |   3648: 03 74 61 62 01 06 01 01 05 04 08 1a 84 80 80 80   .tab............",
          "4407: |   3664: 80 0d 03 00 3a 00 00 00 15 04 33 66 6f 72 01 02   ....:.....3for..",
          "4408: |   3680: 02 02 02 74 73 01 06 01 01 04 04 08 1b 84 80 80   ...ts...........",
          "4409: |   3696: 80 80 0c 03 00 3c 00 00 00 16 03 32 74 68 01 06   .....<.....2th..",
          "4410: |   3712: 01 01 03 00 04 33 65 61 63 01 02 03 04 09 18 84   .....3eac.......",
          "4411: |   3728: 80 80 80 80 0b 03 00 36 00 00 00 13 03 32 74 61   .......6.....2ta",
          "4412: |   3744: 01 06 01 01 05 02 01 65 01 02 04 04 09 19 84 80   .......e........",
          "4413: |   3760: 80 80 80 0a 03 00 38 00 00 00 14 03 32 69 6e 01   ......8.....2in.",
          "4414: |   3776: 06 01 01 02 01 02 70 72 01 02 05 04 09 18 84 80   ......pr........",
          "4415: |   3792: 80 80 80 09 03 00 36 00 00 00 13 03 32 66 6f 01   ......6.....2fo.",
          "4416: |   3808: 02 02 02 01 74 01 06 01 01 04 04 07 1b 84 80 80   ....t...........",
          "4417: |   3824: 80 80 08 03 00 3c 00 00 00 16 02 31 74 01 0a 04   .....<.....1t...",
          "4418: |   3840: 01 01 03 04 00 03 32 65 61 01 02 03 04 0a 17 84   ......2ea.......",
          "4419: |   3856: 80 80 80 80 07 03 00 34 00 00 00 12 02 31 69 01   .......4.....1i.",
          "4420: |   3872: 06 01 01 02 01 01 70 01 02 05 04 08 18 84 80 80   ......p.........",
          "4421: |   3888: 80 80 06 03 00 36 00 00 00 13 02 31 65 01 02 03   .....6.....1e...",
          "4422: |   3904: 01 01 66 01 08 02 01 01 04 04 06 1b 84 80 80 80   ..f.............",
          "4423: |   3920: 80 05 03 00 3c 00 00 00 16 05 30 74 65 72 6d 01   ....<.....0term.",
          "4424: |   3936: 02 04 02 02 68 65 01 06 01 01 03 04 09 14 84 80   ....he..........",
          "4425: |   3952: 80 80 80 04 03 00 2e 00 00 00 10 06 30 64 61 62   ............0dab",
          "4426: |   3968: 6c 65 01 06 01 01 05 04 15 84 80 80 80 80 03 03   le..............",
          "4427: |   3984: 00 30 00 00 00 11 02 08 30 70 72 65 73 65 6e 74   .0......0present",
          "4428: |   4000: 01 02 05 05 1b 84 80 80 80 80 02 03 00 3c 00 00   .............<..",
          "4429: |   4016: 00 16 04 30 66 74 73 01 06 01 01 04 01 02 69 6e   ...0fts.......in",
          "4430: |   4032: 01 06 01 01 04 0a 1a 84 80 80 80 80 01 03 00 3a   ...............:",
          "4431: |   4048: 00 00 00 15 05 30 65 61 63 68 01 02 03 01 03 66   .....0each.....f",
          "4432: |   4064: 6f 72 01 02 02 04 09 06 01 03 00 12 03 0b 0f 00   or..............",
          "4433: |   4080: 00 08 8c 80 80 80 80 11 03 00 16 00 00 00 05 04   ................",
          "4434: | page 3 offset 8192",
          "4435: |      0: 0a 00 00 00 32 0e 4f 00 0f fa 0f f1 0f e9 0f e1   ....2.O.........",
          "4436: |     16: 0f d8 0f d1 0f c9 0f c1 0f b9 0f b1 0f a9 0f a0   ................",
          "4437: |     32: 0f 98 0f 90 0f 87 0f 80 0f 78 0f 71 0f 68 0f 5f   .........x.q.h._",
          "4438: |     48: 0f 56 0f 4d 0f 41 0f 38 0f 2f 0f 26 0f 1d 0f 13   .V.M.A.8./.&....",
          "4439: |     64: 0f 0a 0f 01 0e f7 0e ee 0e e6 0e dd 0e d6 0e cd   ................",
          "4440: |     80: 0e c3 0e ba 0e b0 0e a8 0e 9f 0e 96 0e 8e 0e 85   ................",
          "4441: |     96: 0e 7c 0e 73 0e 6a 0e 60 0e 58 0e 4f 00 00 00 00   .|.s.j.`.X.O....",
          "4442: |   3648: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 08   ................",
          "4443: |   3664: 04 01 10 01 03 34 74 20 07 04 01 0e 01 03 34 1e   .....4t ......4.",
          "4444: |   3680: 09 04 01 12 01 03 33 74 68 1c 08 04 01 10 01 03   ......3th.......",
          "4445: |   3696: 33 6e 1a 08 04 01 10 01 03 32 77 18 08 04 01 10   3n.......2w.....",
          "4446: |   3712: 01 03 32 74 16 08 04 01 10 01 03 32 6e 14 07 04   ..2t.......2n...",
          "4447: |   3728: 01 0e 01 03 32 12 08 04 01 10 01 03 31 74 10 08   ....2.......1t..",
          "4448: |   3744: 04 01 10 01 03 31 6e 0e 07 04 01 0e 01 03 31 0c   .....1n.......1.",
          "4449: |   3760: 09 04 01 12 01 03 30 74 68 0a 08 04 01 10 01 03   ......0th.......",
          "4450: |   3776: 30 74 08 09 04 01 12 01 03 30 6e 75 06 08 04 01   0t.......0nu....",
          "4451: |   3792: 10 01 03 30 6e 04 06 04 01 0c 01 03 02 08 04 01   ...0n...........",
          "4452: |   3808: 10 01 02 34 72 22 07 04 01 0e 01 02 34 20 08 04   ...4r.......4 ..",
          "4453: |   3824: 01 10 01 02 33 72 1e 09 04 01 12 01 02 33 61 72   ....3r.......3ar",
          "4454: |   3840: 1c 08 04 01 10 01 02 32 74 1a 08 04 01 10 01 02   .......2t.......",
          "4455: |   3856: 32 69 18 09 04 01 12 01 02 32 61 72 16 08 04 01   2i.......2ar....",
          "4456: |   3872: 10 01 02 31 74 14 08 04 01 10 01 02 31 6e 12 08   ...1t.......1n..",
          "4457: |   3888: 04 01 10 01 02 31 62 10 08 04 01 10 01 02 31 32   .....1b.......12",
          "4458: |   3904: 0e 0b 04 01 16 01 02 30 74 68 65 72 0c 08 04 01   .......0ther....",
          "4459: |   3920: 10 01 02 30 74 0a 08 04 01 10 01 02 30 6e 08 08   ...0t.......0n..",
          "4460: |   3936: 14 01 10 01 02 30 62 06 08 04 01 10 01 02 30 61   .....0b.......0a",
          "4461: |   3952: 04 06 04 01 0c 01 02 02 07 04 09 10 01 34 74 22   .............4t.",
          "4462: |   3968: 06 04 09 0e 01 34 20 08 04 09 12 01 33 74 65 1e   .....4 .....3te.",
          "4463: |   3984: 07 04 09 10 01 33 70 1c 07 04 09 10 01 33 66 1a   .....3p......3f.",
          "4464: |   4000: 08 04 09 12 01 32 74 68 18 07 04 09 10 01 32 74   .....2th......2t",
          "4465: |   4016: 16 07 04 09 10 01 32 69 14 07 04 09 10 01 32 66   ......2i......2f",
          "4466: |   4032: 12 07 04 09 10 01 31 74 10 07 04 09 10 01 31 69   ......1t......1i",
          "4467: |   4048: 0e 06 04 09 0e 01 31 0c 08 04 09 12 01 30 74 65   ......1......0te",
          "4468: |   4064: 0a 07 04 09 10 01 30 74 08 07 04 09 10 01 30 70   ......0t......0p",
          "4469: |   4080: 06 08 04 09 12 01 30 66 74 04 05 04 09 0c 01 02   ......0ft.......",
          "4470: | page 4 offset 12288",
          "4471: |      0: 0d 00 00 00 03 0f eb 00 0f f9 0f f2 0f eb 00 00   ................",
          "4472: |   4064: 00 00 00 00 00 00 00 00 00 00 00 05 03 03 00 10   ................",
          "4473: |   4080: 03 05 05 02 03 00 10 04 06 05 01 03 00 10 04 04   ................",
          "4474: | page 5 offset 16384",
          "4475: |      0: 0a 00 00 00 02 0f eb 00 0f eb 0f f4 00 00 00 00   ................",
          "4476: |   4064: 00 00 00 00 00 00 00 00 00 00 00 08 03 15 01 70   ...............p",
          "4477: |   4080: 67 73 7a 18 0b 03 1b 01 76 65 72 73 69 6f 6e 04   gsz.....version.",
          "4478: | page 6 offset 20480",
          "4479: |      0: 0d 00 00 00 03 0f f2 00 0f fc 0f f7 0f f2 00 00   ................",
          "4480: |   4080: 00 00 03 03 02 01 03 03 02 02 01 02 02 01 0c e9   ................",
          "4481: | end crash-a6651222df1bd1.db",
          "4482: }]} {}",
          "4484: do_catchsql_test 36.1 {",
          "4485:   INSERT INTO t1(b) VALUES(",
          "4486:       x'78de3fa24af3733ca8769291a0fee3669f9fddefc5cba913e4225d4b6ce2b04f26b87fad3ee6f9b7d90a1ea62a169bf41e5d32707a6ca5c3d05e4bde05c9d89eaaa8c50e74333d2e9fcd7dfe95528a3a016aac1102d825c5cd70cf99d8a88e0ea7f798d4334386518b7ad359beb168b93aba059a2a3bd93112d65b44c12b9904ea786b204d80531cdf0504bf9b203dbe927061974caf7b9f30cbc3397b61f802e732012a6663d41c3607d6f1c0dbcfd489adac05ca500c0b04439d894cd93a840159225ef73b627e178b9f84b3ffe66cf22a963a8368813ff7961fc47f573211ccec95e0220dcbb3bf429f4a50ba54d7a53784ac51bfef346e6a');",
          "4487: } {1 {database disk image is malformed}}",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 7def6c8edd85f19ee09038e01541f75b1f71ca39b9fb782b8f0fcac89207c353",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d0fb7960cea5d26a40a0a7ca00c4274545e96efe",
      "candidate_info": {
        "commit_hash": "d0fb7960cea5d26a40a0a7ca00c4274545e96efe",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/d0fb7960cea5d26a40a0a7ca00c4274545e96efe",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/vdbe.c"
        ],
        "message": "Small changes to the OP_OpenEphemeral opcode to improve testability.\n\nFossilOrigin-Name: f856676c8438dbf52d299e78f6dd6148d929755dc05cdcabafd17d9a86439435",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/vdbe.c||src/vdbe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 4678cb1044f0b4dc813e48f3bd0f85240a66e2ecf8763280d66726cc031c93a7",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3669:     rc = sqlite3BtreeClearTable(pCx->pBtx, pCx->pgnoRoot, 0);",
          "3698:       }",
          "3705:     }",
          "3706:   }",
          "3707:   if( rc ) goto abort_due_to_error;",
          "3709:   break;",
          "3710: }",
          "",
          "[Removed Lines]",
          "3670:     if( rc ) goto abort_due_to_error;",
          "3671:     break;",
          "3672:   }",
          "3673:   pCx = allocateCursor(p, pOp->p1, pOp->p2, -1, CURTYPE_BTREE);",
          "3674:   if( pCx==0 ) goto no_mem;",
          "3675:   pCx->nullRow = 1;",
          "3676:   pCx->isEphemeral = 1;",
          "3677:   rc = sqlite3BtreeOpen(db->pVfs, 0, db, &pCx->pBtx,",
          "3678:                         BTREE_OMIT_JOURNAL | BTREE_SINGLE | pOp->p5, vfsFlags);",
          "3679:   if( rc==SQLITE_OK ){",
          "3680:     rc = sqlite3BtreeBeginTrans(pCx->pBtx, 1, 0);",
          "3681:   }",
          "3682:   if( rc==SQLITE_OK ){",
          "3688:     if( (pCx->pKeyInfo = pKeyInfo = pOp->p4.pKeyInfo)!=0 ){",
          "3689:       assert( pOp->p4type==P4_KEYINFO );",
          "3690:       rc = sqlite3BtreeCreateTable(pCx->pBtx, (int*)&pCx->pgnoRoot,",
          "3691:                                    BTREE_BLOBKEY | pOp->p5);",
          "3692:       if( rc==SQLITE_OK ){",
          "3693:         assert( pCx->pgnoRoot==MASTER_ROOT+1 );",
          "3694:         assert( pKeyInfo->db==db );",
          "3695:         assert( pKeyInfo->enc==ENC(db) );",
          "3696:         rc = sqlite3BtreeCursor(pCx->pBtx, pCx->pgnoRoot, BTREE_WRCSR,",
          "3697:                                 pKeyInfo, pCx->uc.pCursor);",
          "3699:       pCx->isTable = 0;",
          "3700:     }else{",
          "3701:       pCx->pgnoRoot = MASTER_ROOT;",
          "3702:       rc = sqlite3BtreeCursor(pCx->pBtx, MASTER_ROOT, BTREE_WRCSR,",
          "3703:                               0, pCx->uc.pCursor);",
          "3704:       pCx->isTable = 1;",
          "3708:   pCx->isOrdered = (pOp->p5!=BTREE_UNORDERED);",
          "",
          "[Added Lines]",
          "3670:   }else{",
          "3671:     pCx = allocateCursor(p, pOp->p1, pOp->p2, -1, CURTYPE_BTREE);",
          "3672:     if( pCx==0 ) goto no_mem;",
          "3673:     pCx->nullRow = 1;",
          "3674:     pCx->isEphemeral = 1;",
          "3675:     rc = sqlite3BtreeOpen(db->pVfs, 0, db, &pCx->pBtx,",
          "3676:                           BTREE_OMIT_JOURNAL | BTREE_SINGLE | pOp->p5,",
          "3677:                           vfsFlags);",
          "3678:     if( rc==SQLITE_OK ){",
          "3679:       rc = sqlite3BtreeBeginTrans(pCx->pBtx, 1, 0);",
          "3680:     }",
          "3681:     if( rc==SQLITE_OK ){",
          "3687:       if( (pCx->pKeyInfo = pKeyInfo = pOp->p4.pKeyInfo)!=0 ){",
          "3688:         assert( pOp->p4type==P4_KEYINFO );",
          "3689:         rc = sqlite3BtreeCreateTable(pCx->pBtx, (int*)&pCx->pgnoRoot,",
          "3690:                                      BTREE_BLOBKEY | pOp->p5);",
          "3691:         if( rc==SQLITE_OK ){",
          "3692:           assert( pCx->pgnoRoot==MASTER_ROOT+1 );",
          "3693:           assert( pKeyInfo->db==db );",
          "3694:           assert( pKeyInfo->enc==ENC(db) );",
          "3695:           rc = sqlite3BtreeCursor(pCx->pBtx, pCx->pgnoRoot, BTREE_WRCSR,",
          "3696:                                   pKeyInfo, pCx->uc.pCursor);",
          "3697:         }",
          "3698:         pCx->isTable = 0;",
          "3699:       }else{",
          "3700:         pCx->pgnoRoot = MASTER_ROOT;",
          "3701:         rc = sqlite3BtreeCursor(pCx->pBtx, MASTER_ROOT, BTREE_WRCSR,",
          "3702:                                 0, pCx->uc.pCursor);",
          "3703:         pCx->isTable = 1;",
          "3706:     pCx->isOrdered = (pOp->p5!=BTREE_UNORDERED);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "73c0d272a9bdb8e43394d62d14f0c7c8843fadfa",
      "candidate_info": {
        "commit_hash": "73c0d272a9bdb8e43394d62d14f0c7c8843fadfa",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/73c0d272a9bdb8e43394d62d14f0c7c8843fadfa",
        "files": [
          "ext/misc/dbdata.c",
          "main.mk",
          "manifest",
          "manifest.uuid",
          "src/shell.c.in",
          "test/dbdata.test",
          "test/recover.test",
          "tool/mkshellc.tcl"
        ],
        "message": "Add the \".recover\" command to the shell tool. For recovering as much data as possible from corrupt databases.\n\nFossilOrigin-Name: 50fe48458942fa7a6bcc76316c6321f95b23dc34f2f8e0a483826483b2fb16f6",
        "before_after_code_files": [
          "ext/misc/dbdata.c||ext/misc/dbdata.c",
          "main.mk||main.mk",
          "manifest.uuid||manifest.uuid",
          "src/shell.c.in||src/shell.c.in",
          "test/dbdata.test||test/dbdata.test",
          "test/recover.test||test/recover.test",
          "tool/mkshellc.tcl||tool/mkshellc.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/misc/dbdata.c||ext/misc/dbdata.c": [
          "File: ext/misc/dbdata.c -> ext/misc/dbdata.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "74: #if !defined(SQLITEINT_H)",
          "75: #include \"sqlite3ext.h\"",
          "77: typedef unsigned char u8;",
          "79: #endif",
          "80: SQLITE_EXTENSION_INIT1",
          "81: #include <string.h>",
          "82: #include <assert.h>",
          "84: typedef struct DbdataTable DbdataTable;",
          "85: typedef struct DbdataCursor DbdataCursor;",
          "88: struct DbdataCursor {",
          "98:   int szDb;",
          "99:   sqlite3_int64 iRowid;",
          "106:   u8 *pHdrPtr;",
          "107:   u8 *pPtr;",
          "110: };",
          "113: struct DbdataTable {",
          "118: };",
          "121: #define DBDATA_COLUMN_PGNO        0",
          "122: #define DBDATA_COLUMN_CELL        1",
          "123: #define DBDATA_COLUMN_FIELD       2",
          "124: #define DBDATA_COLUMN_VALUE       3",
          "125: #define DBDATA_COLUMN_SCHEMA      4",
          "126: #define DBDATA_SCHEMA             \\",
          "127:       \"CREATE TABLE x(\"           \\",
          "128:       \"  pgno INTEGER,\"           \\",
          "129:       \"  cell INTEGER,\"           \\",
          "130:       \"  field INTEGER,\"          \\",
          "131:       \"  value ANY,\"              \\",
          "132:       \"  schema TEXT HIDDEN\"      \\",
          "133:       \")\"",
          "136: #define DBPTR_COLUMN_PGNO         0",
          "137: #define DBPTR_COLUMN_CHILD        1",
          "138: #define DBPTR_COLUMN_SCHEMA       2",
          "139: #define DBPTR_SCHEMA              \\",
          "140:       \"CREATE TABLE x(\"           \\",
          "141:       \"  pgno INTEGER,\"           \\",
          "142:       \"  child INTEGER,\"          \\",
          "143:       \"  schema TEXT HIDDEN\"      \\",
          "144:       \")\"",
          "150: static int dbdataConnect(",
          "151:   sqlite3 *db,",
          "152:   void *pAux,",
          "153:   int argc, const char *const*argv,",
          "154:   sqlite3_vtab **ppVtab,",
          "155:   char **pzErr",
          "156: ){",
          "157:   DbdataTable *pTab = 0;",
          "158:   int rc = sqlite3_declare_vtab(db, pAux ? DBPTR_SCHEMA : DBDATA_SCHEMA);",
          "160:   if( rc==SQLITE_OK ){",
          "161:     pTab = (DbdataTable*)sqlite3_malloc64(sizeof(DbdataTable));",
          "162:     if( pTab==0 ){",
          "163:       rc = SQLITE_NOMEM;",
          "164:     }else{",
          "165:       memset(pTab, 0, sizeof(DbdataTable));",
          "166:       pTab->db = db;",
          "167:       pTab->bPtr = (pAux!=0);",
          "168:     }",
          "169:   }",
          "172:   return rc;",
          "173: }",
          "178: static int dbdataDisconnect(sqlite3_vtab *pVtab){",
          "179:   DbdataTable *pTab = (DbdataTable*)pVtab;",
          "180:   if( pTab ){",
          "181:     sqlite3_finalize(pTab->pStmt);",
          "182:     sqlite3_free(pVtab);",
          "183:   }",
          "184:   return SQLITE_OK;",
          "185: }",
          "200: static int dbdataBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdx){",
          "201:   DbdataTable *pTab = (DbdataTable*)tab;",
          "202:   int i;",
          "203:   int iSchema = -1;",
          "204:   int iPgno = -1;",
          "205:   int colSchema = (pTab->bPtr ? DBPTR_COLUMN_SCHEMA : DBDATA_COLUMN_SCHEMA);",
          "207:   for(i=0; i<pIdx->nConstraint; i++){",
          "208:     struct sqlite3_index_constraint *p = &pIdx->aConstraint[i];",
          "209:     if( p->op==SQLITE_INDEX_CONSTRAINT_EQ ){",
          "210:       if( p->iColumn==colSchema ){",
          "211:         if( p->usable==0 ) return SQLITE_CONSTRAINT;",
          "212:         iSchema = i;",
          "213:       }",
          "214:       if( p->iColumn==DBDATA_COLUMN_PGNO && p->usable ){",
          "215:         iPgno = i;",
          "216:       }",
          "217:     }",
          "218:   }",
          "220:   if( iSchema>=0 ){",
          "221:     pIdx->aConstraintUsage[iSchema].argvIndex = 1;",
          "222:     pIdx->aConstraintUsage[iSchema].omit = 1;",
          "223:   }",
          "224:   if( iPgno>=0 ){",
          "225:     pIdx->aConstraintUsage[iPgno].argvIndex = 1 + (iSchema>=0);",
          "226:     pIdx->aConstraintUsage[iPgno].omit = 1;",
          "227:     pIdx->estimatedCost = 100;",
          "228:     pIdx->estimatedRows =  50;",
          "230:     if( pTab->bPtr==0 && pIdx->nOrderBy && pIdx->aOrderBy[0].desc==0 ){",
          "231:       int iCol = pIdx->aOrderBy[0].iColumn;",
          "232:       if( pIdx->nOrderBy==1 ){",
          "233:         pIdx->orderByConsumed = (iCol==0 || iCol==1);",
          "234:       }else if( pIdx->nOrderBy==2 && pIdx->aOrderBy[1].desc==0 && iCol==0 ){",
          "235:         pIdx->orderByConsumed = (pIdx->aOrderBy[1].iColumn==1);",
          "236:       }",
          "237:     }",
          "239:   }else{",
          "240:     pIdx->estimatedCost = 100000000;",
          "241:     pIdx->estimatedRows = 1000000000;",
          "242:   }",
          "243:   pIdx->idxNum = (iSchema>=0 ? 0x01 : 0x00) | (iPgno>=0 ? 0x02 : 0x00);",
          "244:   return SQLITE_OK;",
          "245: }",
          "250: static int dbdataOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){",
          "251:   DbdataCursor *pCsr;",
          "253:   pCsr = (DbdataCursor*)sqlite3_malloc64(sizeof(DbdataCursor));",
          "254:   if( pCsr==0 ){",
          "255:     return SQLITE_NOMEM;",
          "256:   }else{",
          "257:     memset(pCsr, 0, sizeof(DbdataCursor));",
          "258:     pCsr->base.pVtab = pVTab;",
          "259:   }",
          "262:   return SQLITE_OK;",
          "263: }",
          "269: static void dbdataResetCursor(DbdataCursor *pCsr){",
          "270:   DbdataTable *pTab = (DbdataTable*)(pCsr->base.pVtab);",
          "271:   if( pTab->pStmt==0 ){",
          "272:     pTab->pStmt = pCsr->pStmt;",
          "273:   }else{",
          "274:     sqlite3_finalize(pCsr->pStmt);",
          "275:   }",
          "276:   pCsr->pStmt = 0;",
          "277:   pCsr->iPgno = 1;",
          "278:   pCsr->iCell = 0;",
          "279:   pCsr->iField = 0;",
          "280:   pCsr->bOnePage = 0;",
          "281: }",
          "286: static int dbdataClose(sqlite3_vtab_cursor *pCursor){",
          "287:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;",
          "288:   dbdataResetCursor(pCsr);",
          "289:   sqlite3_free(pCsr);",
          "290:   return SQLITE_OK;",
          "291: }",
          "296: static unsigned int get_uint16(unsigned char *a){",
          "297:   return (a[0]<<8)|a[1];",
          "298: }",
          "299: static unsigned int get_uint32(unsigned char *a){",
          "300:   return (a[0]<<24)|(a[1]<<16)|(a[2]<<8)|a[3];",
          "301: }",
          "313: static int dbdataLoadPage(",
          "318: ){",
          "319:   int rc2;",
          "320:   int rc = SQLITE_OK;",
          "321:   sqlite3_stmt *pStmt = pCsr->pStmt;",
          "325:   sqlite3_bind_int64(pStmt, 2, pgno);",
          "326:   if( SQLITE_ROW==sqlite3_step(pStmt) ){",
          "327:     int nCopy = sqlite3_column_bytes(pStmt, 0);",
          "328:     if( nCopy>0 ){",
          "329:       u8 *pPage;",
          "330:       pPage = (u8*)sqlite3_malloc64(nCopy);",
          "331:       if( pPage==0 ){",
          "332:         rc = SQLITE_NOMEM;",
          "333:       }else{",
          "334:         const u8 *pCopy = sqlite3_column_blob(pStmt, 0);",
          "335:         memcpy(pPage, pCopy, nCopy);",
          "336:       }",
          "339:     }",
          "340:   }",
          "341:   rc2 = sqlite3_reset(pStmt);",
          "342:   if( rc==SQLITE_OK ) rc = rc2;",
          "344:   return rc;",
          "345: }",
          "350: static int dbdataGetVarint(const u8 *z, sqlite3_int64 *pVal){",
          "351:   sqlite3_int64 v = 0;",
          "352:   int i;",
          "353:   for(i=0; i<8; i++){",
          "354:     v = (v<<7) + (z[i]&0x7f);",
          "355:     if( (z[i]&0x80)==0 ){ *pVal = v; return i+1; }",
          "356:   }",
          "357:   v = (v<<8) + (z[i]&0xff);",
          "359:   return 9;",
          "360: }",
          "366: static int dbdataValueBytes(int eType){",
          "367:   switch( eType ){",
          "368:     case 0: case 8: case 9:",
          "369:     case 10: case 11:",
          "370:       return 0;",
          "371:     case 1:",
          "372:       return 1;",
          "373:     case 2:",
          "374:       return 2;",
          "375:     case 3:",
          "376:       return 3;",
          "377:     case 4:",
          "378:       return 4;",
          "379:     case 5:",
          "380:       return 6;",
          "381:     case 6:",
          "382:     case 7:",
          "383:       return 8;",
          "384:     default:",
          "385:       return ((eType-12) / 2);",
          "386:   }",
          "387: }",
          "393: static void dbdataValue(sqlite3_context *pCtx, int eType, u8 *pData){",
          "394:   switch( eType ){",
          "395:     case 0:",
          "396:     case 10:",
          "397:     case 11:",
          "398:       sqlite3_result_null(pCtx);",
          "399:       break;",
          "401:     case 8:",
          "402:       sqlite3_result_int(pCtx, 0);",
          "403:       break;",
          "404:     case 9:",
          "405:       sqlite3_result_int(pCtx, 1);",
          "406:       break;",
          "408:     case 1: case 2: case 3: case 4: case 5: case 6: case 7: {",
          "409:       sqlite3_uint64 v = (signed char)pData[0];",
          "410:       pData++;",
          "411:       switch( eType ){",
          "412:         case 7:",
          "413:         case 6:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;",
          "414:         case 5:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;",
          "415:         case 4:  v = (v<<8) + pData[0];  pData++;",
          "416:         case 3:  v = (v<<8) + pData[0];  pData++;",
          "417:         case 2:  v = (v<<8) + pData[0];  pData++;",
          "418:       }",
          "420:       if( eType==7 ){",
          "421:         double r;",
          "422:         memcpy(&r, &v, sizeof(r));",
          "423:         sqlite3_result_double(pCtx, r);",
          "424:       }else{",
          "425:         sqlite3_result_int64(pCtx, (sqlite3_int64)v);",
          "426:       }",
          "427:       break;",
          "428:     }",
          "430:     default: {",
          "431:       int n = ((eType-12) / 2);",
          "432:       if( eType % 2 ){",
          "433:         sqlite3_result_text(pCtx, (const char*)pData, n, SQLITE_TRANSIENT);",
          "434:       }else{",
          "435:         sqlite3_result_blob(pCtx, pData, n, SQLITE_TRANSIENT);",
          "436:       }",
          "437:     }",
          "438:   }",
          "439: }",
          "445: static int dbdataNext(sqlite3_vtab_cursor *pCursor){",
          "446:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;",
          "447:   DbdataTable *pTab = (DbdataTable*)pCursor->pVtab;",
          "449:   pCsr->iRowid++;",
          "450:   while( 1 ){",
          "451:     int rc;",
          "452:     int iOff = (pCsr->iPgno==1 ? 100 : 0);",
          "454:     if( pCsr->aPage==0 ){",
          "455:       while( 1 ){",
          "456:         if( pCsr->bOnePage==0 && pCsr->iPgno>pCsr->szDb ) return SQLITE_OK;",
          "457:         rc = dbdataLoadPage(pCsr, pCsr->iPgno, &pCsr->aPage, &pCsr->nPage);",
          "458:         if( rc!=SQLITE_OK ) return rc;",
          "459:         if( pCsr->aPage ) break;",
          "460:         pCsr->iPgno++;",
          "461:       }",
          "462:       pCsr->iCell = pTab->bPtr ? -2 : 0;",
          "463:       pCsr->nCell = get_uint16(&pCsr->aPage[iOff+3]);",
          "464:     }",
          "466:     if( pTab->bPtr ){",
          "467:       if( pCsr->aPage[iOff]!=0x02 && pCsr->aPage[iOff]!=0x05 ){",
          "468:         pCsr->iCell = pCsr->nCell;",
          "469:       }",
          "470:       pCsr->iCell++;",
          "471:       if( pCsr->iCell>=pCsr->nCell ){",
          "472:         sqlite3_free(pCsr->aPage);",
          "473:         pCsr->aPage = 0;",
          "474:         if( pCsr->bOnePage ) return SQLITE_OK;",
          "475:         pCsr->iPgno++;",
          "476:       }else{",
          "477:         return SQLITE_OK;",
          "478:       }",
          "479:     }else{",
          "481:       if( pCsr->pRec==0 ){",
          "482:         int bHasRowid = 0;",
          "483:         int nPointer = 0;",
          "484:         sqlite3_int64 nPayload = 0;",
          "485:         sqlite3_int64 nHdr = 0;",
          "486:         int iHdr;",
          "487:         int U, X;",
          "488:         int nLocal;",
          "490:         switch( pCsr->aPage[iOff] ){",
          "491:           case 0x02:",
          "492:             nPointer = 4;",
          "493:             break;",
          "494:           case 0x0a:",
          "495:             break;",
          "496:           case 0x0d:",
          "497:             bHasRowid = 1;",
          "498:             break;",
          "499:           default:",
          "501:             pCsr->iCell = pCsr->nCell;",
          "502:             break;",
          "503:         }",
          "505:         if( pCsr->iCell>=pCsr->nCell ){",
          "506:           sqlite3_free(pCsr->aPage);",
          "507:           pCsr->aPage = 0;",
          "508:           if( pCsr->bOnePage ) return SQLITE_OK;",
          "509:           pCsr->iPgno++;",
          "510:           continue;",
          "511:         }",
          "513:         iOff += 8 + nPointer + pCsr->iCell*2;",
          "514:         iOff = get_uint16(&pCsr->aPage[iOff]);",
          "517:         iOff += nPointer;",
          "520:         iOff += dbdataGetVarint(&pCsr->aPage[iOff], &nPayload);",
          "523:         if( bHasRowid ){",
          "524:           iOff += dbdataGetVarint(&pCsr->aPage[iOff], &pCsr->iIntkey);",
          "525:         }",
          "528:         pCsr->pRec = (u8*)sqlite3_malloc64(nPayload);",
          "529:         if( pCsr->pRec==0 ) return SQLITE_NOMEM;",
          "530:         pCsr->nRec = nPayload;",
          "532:         U = pCsr->nPage;",
          "533:         if( bHasRowid ){",
          "534:           X = U-35;",
          "535:         }else{",
          "536:           X = ((U-12)*64/255)-23;",
          "537:         }",
          "538:         if( nPayload<=X ){",
          "539:           nLocal = nPayload;",
          "540:         }else{",
          "541:           int M, K;",
          "542:           M = ((U-12)*32/255)-23;",
          "543:           K = M+((nPayload-M)%(U-4));",
          "544:           if( K<=X ){",
          "545:             nLocal = K;",
          "546:           }else{",
          "547:             nLocal = M;",
          "548:           }",
          "549:         }",
          "552:         memcpy(pCsr->pRec, &pCsr->aPage[iOff], nLocal);",
          "553:         iOff += nLocal;",
          "556:         if( nPayload>nLocal ){",
          "557:           sqlite3_int64 nRem = nPayload - nLocal;",
          "558:           unsigned int pgnoOvfl = get_uint32(&pCsr->aPage[iOff]);",
          "559:           while( nRem>0 ){",
          "560:             u8 *aOvfl = 0;",
          "561:             int nOvfl = 0;",
          "562:             int nCopy;",
          "563:             rc = dbdataLoadPage(pCsr, pgnoOvfl, &aOvfl, &nOvfl);",
          "564:             assert( rc!=SQLITE_OK || nOvfl==pCsr->nPage );",
          "565:             if( rc!=SQLITE_OK ) return rc;",
          "567:             nCopy = U-4;",
          "568:             if( nCopy>nRem ) nCopy = nRem;",
          "569:             memcpy(&pCsr->pRec[nPayload-nRem], &aOvfl[4], nCopy);",
          "570:             nRem -= nCopy;",
          "572:             pgnoOvfl = get_uint32(aOvfl);",
          "573:             sqlite3_free(aOvfl);",
          "574:           }",
          "575:         }",
          "577:         iHdr = dbdataGetVarint(pCsr->pRec, &nHdr);",
          "578:         pCsr->nHdr = nHdr;",
          "579:         pCsr->pHdrPtr = &pCsr->pRec[iHdr];",
          "580:         pCsr->pPtr = &pCsr->pRec[pCsr->nHdr];",
          "581:         pCsr->iField = (bHasRowid ? -1 : 0);",
          "582:       }else{",
          "583:         pCsr->iField++;",
          "584:         if( pCsr->iField>0 ){",
          "585:           sqlite3_int64 iType;",
          "586:           pCsr->pHdrPtr += dbdataGetVarint(pCsr->pHdrPtr, &iType);",
          "587:           pCsr->pPtr += dbdataValueBytes(iType);",
          "588:         }",
          "589:       }",
          "591:       if( pCsr->iField<0 || pCsr->pHdrPtr<&pCsr->pRec[pCsr->nHdr] ){",
          "592:         return SQLITE_OK;",
          "593:       }",
          "597:       sqlite3_free(pCsr->pRec);",
          "598:       pCsr->pRec = 0;",
          "599:       pCsr->iCell++;",
          "600:     }",
          "601:   }",
          "603:   assert( !\"can't get here\" );",
          "604:   return SQLITE_OK;",
          "605: }",
          "610: static int dbdataEof(sqlite3_vtab_cursor *pCursor){",
          "611:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;",
          "612:   return pCsr->aPage==0;",
          "613: }",
          "621: static int dbdataDbsize(DbdataCursor *pCsr, const char *zSchema){",
          "622:   DbdataTable *pTab = (DbdataTable*)pCsr->base.pVtab;",
          "623:   char *zSql = 0;",
          "624:   int rc, rc2;",
          "625:   sqlite3_stmt *pStmt = 0;",
          "627:   zSql = sqlite3_mprintf(\"PRAGMA %Q.page_count\", zSchema);",
          "628:   if( zSql==0 ) return SQLITE_NOMEM;",
          "629:   rc = sqlite3_prepare_v2(pTab->db, zSql, -1, &pStmt, 0);",
          "630:   sqlite3_free(zSql);",
          "631:   if( rc==SQLITE_OK && sqlite3_step(pStmt)==SQLITE_ROW ){",
          "632:     pCsr->szDb = sqlite3_column_int(pStmt, 0);",
          "633:   }",
          "634:   rc2 = sqlite3_finalize(pStmt);",
          "635:   if( rc==SQLITE_OK ) rc = rc2;",
          "636:   return rc;",
          "637: }",
          "642: static int dbdataFilter(",
          "643:   sqlite3_vtab_cursor *pCursor,",
          "644:   int idxNum, const char *idxStr,",
          "645:   int argc, sqlite3_value **argv",
          "646: ){",
          "647:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;",
          "648:   DbdataTable *pTab = (DbdataTable*)pCursor->pVtab;",
          "649:   int rc = SQLITE_OK;",
          "650:   const char *zSchema = \"main\";",
          "652:   dbdataResetCursor(pCsr);",
          "653:   assert( pCsr->iPgno==1 );",
          "654:   if( idxNum & 0x01 ){",
          "655:     zSchema = (const char*)sqlite3_value_text(argv[0]);",
          "656:   }",
          "657:   if( idxNum & 0x02 ){",
          "658:     pCsr->iPgno = sqlite3_value_int(argv[(idxNum & 0x01)]);",
          "659:     pCsr->bOnePage = 1;",
          "660:   }else{",
          "661:     pCsr->nPage = dbdataDbsize(pCsr, zSchema);",
          "662:     rc = dbdataDbsize(pCsr, zSchema);",
          "663:   }",
          "665:   if( rc==SQLITE_OK ){",
          "666:     if( pTab->pStmt ){",
          "667:       pCsr->pStmt = pTab->pStmt;",
          "668:       pTab->pStmt = 0;",
          "669:     }else{",
          "670:       rc = sqlite3_prepare_v2(pTab->db,",
          "671:           \"SELECT data FROM sqlite_dbpage(?) WHERE pgno=?\", -1,",
          "672:           &pCsr->pStmt, 0",
          "673:       );",
          "674:     }",
          "675:   }",
          "676:   if( rc==SQLITE_OK ){",
          "677:     rc = sqlite3_bind_text(pCsr->pStmt, 1, zSchema, -1, SQLITE_TRANSIENT);",
          "678:   }else{",
          "679:     pTab->base.zErrMsg = sqlite3_mprintf(\"%s\", sqlite3_errmsg(pTab->db));",
          "680:   }",
          "681:   if( rc==SQLITE_OK ){",
          "682:     rc = dbdataNext(pCursor);",
          "683:   }",
          "684:   return rc;",
          "685: }",
          "690: static int dbdataColumn(",
          "691:   sqlite3_vtab_cursor *pCursor,",
          "692:   sqlite3_context *ctx,",
          "693:   int i",
          "694: ){",
          "695:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;",
          "696:   DbdataTable *pTab = (DbdataTable*)pCursor->pVtab;",
          "697:   if( pTab->bPtr ){",
          "698:     switch( i ){",
          "699:       case DBPTR_COLUMN_PGNO:",
          "700:         sqlite3_result_int64(ctx, pCsr->iPgno);",
          "701:         break;",
          "702:       case DBPTR_COLUMN_CHILD: {",
          "703:         int iOff = pCsr->iPgno==1 ? 100 : 0;",
          "704:         if( pCsr->iCell<0 ){",
          "705:           iOff += 8;",
          "706:         }else{",
          "707:           iOff += 12 + pCsr->iCell*2;",
          "708:           iOff = get_uint16(&pCsr->aPage[iOff]);",
          "709:         }",
          "710:         sqlite3_result_int64(ctx, get_uint32(&pCsr->aPage[iOff]));",
          "711:         break;",
          "712:       }",
          "713:     }",
          "714:   }else{",
          "715:     switch( i ){",
          "716:       case DBDATA_COLUMN_PGNO:",
          "717:         sqlite3_result_int64(ctx, pCsr->iPgno);",
          "718:         break;",
          "719:       case DBDATA_COLUMN_CELL:",
          "720:         sqlite3_result_int(ctx, pCsr->iCell);",
          "721:         break;",
          "722:       case DBDATA_COLUMN_FIELD:",
          "723:         sqlite3_result_int(ctx, pCsr->iField);",
          "724:         break;",
          "725:       case DBDATA_COLUMN_VALUE: {",
          "726:         if( pCsr->iField<0 ){",
          "727:           sqlite3_result_int64(ctx, pCsr->iIntkey);",
          "728:         }else{",
          "729:           sqlite3_int64 iType;",
          "730:           dbdataGetVarint(pCsr->pHdrPtr, &iType);",
          "731:           dbdataValue(ctx, iType, pCsr->pPtr);",
          "732:         }",
          "733:         break;",
          "734:       }",
          "735:     }",
          "736:   }",
          "737:   return SQLITE_OK;",
          "738: }",
          "743: static int dbdataRowid(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){",
          "744:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;",
          "746:   return SQLITE_OK;",
          "747: }",
          "753: static int sqlite3DbdataRegister(sqlite3 *db){",
          "754:   static sqlite3_module dbdata_module = {",
          "779:   };",
          "781:   int rc = sqlite3_create_module(db, \"sqlite_dbdata\", &dbdata_module, 0);",
          "782:   if( rc==SQLITE_OK ){",
          "783:     rc = sqlite3_create_module(db, \"sqlite_dbptr\", &dbdata_module, (void*)1);",
          "784:   }",
          "785:   return rc;",
          "786: }",
          "788: #ifdef _WIN32",
          "789: __declspec(dllexport)",
          "790: #endif",
          "791: int sqlite3_dbdata_init(",
          "792:   sqlite3 *db,",
          "793:   char **pzErrMsg,",
          "794:   const sqlite3_api_routines *pApi",
          "795: ){",
          "796:   SQLITE_EXTENSION_INIT2(pApi);",
          "797:   return sqlite3DbdataRegister(db);",
          "798: }",
          "",
          "---------------"
        ],
        "main.mk||main.mk": [
          "File: main.mk -> main.mk",
          "--- Hunk 1 ---",
          "[Context before]",
          "738:  $(TOP)/ext/expert/sqlite3expert.h \\",
          "739:  $(TOP)/ext/misc/zipfile.c \\",
          "740:  $(TOP)/ext/misc/memtrace.c \\",
          "741:         $(TOP)/src/test_windirent.c",
          "743: shell.c: $(SHELL_SRC) $(TOP)/tool/mkshellc.tcl",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "741:  $(TOP)/ext/misc/dbdata.c \\",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 95209072176ff21a91e96d5bd014b35ef100da2b0b93958baf6df4294a8daa85",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/shell.c.in||src/shell.c.in": [
          "File: src/shell.c.in -> src/shell.c.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "948: INCLUDE ../ext/expert/sqlite3expert.h",
          "949: INCLUDE ../ext/expert/sqlite3expert.c",
          "951: #if defined(SQLITE_ENABLE_SESSION)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "951: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB)",
          "952: INCLUDE ../ext/misc/dbdata.c",
          "953: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3574:   \".prompt MAIN CONTINUE    Replace the standard prompts\",",
          "3575:   \".quit                    Exit this program\",",
          "3576:   \".read FILE               Read input from FILE\",",
          "3577:   \".restore ?DB? FILE       Restore content of DB (default \\\"main\\\") from FILE\",",
          "3578:   \".save FILE               Write in-memory database into FILE\",",
          "3579:   \".scanstats on|off        Turn sqlite3_stmt_scanstatus() metrics on or off\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3581: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB)",
          "3582:   \".recover                 Recover as much data as possible from corrupt db.\",",
          "3583: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3931: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3947: static void shellInt32(",
          "3948:   sqlite3_context *context,",
          "3949:   int argc,",
          "3950:   sqlite3_value **argv",
          "3951: ){",
          "3952:   const unsigned char *pBlob;",
          "3953:   int nBlob;",
          "3954:   int iInt;",
          "3956:   nBlob = sqlite3_value_bytes(argv[0]);",
          "3957:   pBlob = (const unsigned char*)sqlite3_value_blob(argv[0]);",
          "3958:   iInt = sqlite3_value_int(argv[1]);",
          "3960:   if( iInt>=0 && (iInt+1)*4<=nBlob ){",
          "3961:     const unsigned char *a = &pBlob[iInt*4];",
          "3962:     sqlite3_int64 iVal = ((sqlite3_int64)a[0]<<24)",
          "3963:                        + ((sqlite3_int64)a[1]<<16)",
          "3964:                        + ((sqlite3_int64)a[2]<< 8)",
          "3965:                        + ((sqlite3_int64)a[3]<< 0);",
          "3966:     sqlite3_result_int64(context, iVal);",
          "3967:   }",
          "3968: }",
          "3983: static void shellEscapeCrnl(",
          "3984:   sqlite3_context *context,",
          "3985:   int argc,",
          "3986:   sqlite3_value **argv",
          "3987: ){",
          "3988:   const char *zText = (const char*)sqlite3_value_text(argv[0]);",
          "3989:   if( zText[0]=='\\'' ){",
          "3990:     int nText = sqlite3_value_bytes(argv[0]);",
          "3991:     int i;",
          "3992:     char zBuf1[20];",
          "3993:     char zBuf2[20];",
          "3994:     const char *zNL = 0;",
          "3995:     const char *zCR = 0;",
          "3996:     int nCR = 0;",
          "3997:     int nNL = 0;",
          "3999:     for(i=0; zText[i]; i++){",
          "4000:       if( zNL==0 && zText[i]=='\\n' ){",
          "4001:         zNL = unused_string(zText, \"\\\\n\", \"\\\\012\", zBuf1);",
          "4002:         nNL = (int)strlen(zNL);",
          "4003:       }",
          "4004:       if( zCR==0 && zText[i]=='\\r' ){",
          "4005:         zCR = unused_string(zText, \"\\\\r\", \"\\\\015\", zBuf2);",
          "4006:         nCR = (int)strlen(zCR);",
          "4007:       }",
          "4008:     }",
          "4010:     if( zNL || zCR ){",
          "4011:       int iOut = 0;",
          "4012:       i64 nMax = (nNL > nCR) ? nNL : nCR;",
          "4013:       i64 nAlloc = nMax * nText + (nMax+12)*2;",
          "4014:       char *zOut = (char*)sqlite3_malloc64(nAlloc);",
          "4015:       if( zOut==0 ){",
          "4016:         sqlite3_result_error_nomem(context);",
          "4017:         return;",
          "4018:       }",
          "4020:       if( zNL && zCR ){",
          "4021:         memcpy(&zOut[iOut], \"replace(replace(\", 16);",
          "4022:         iOut += 16;",
          "4023:       }else{",
          "4024:         memcpy(&zOut[iOut], \"replace(\", 8);",
          "4025:         iOut += 8;",
          "4026:       }",
          "4027:       for(i=0; zText[i]; i++){",
          "4028:         if( zText[i]=='\\n' ){",
          "4029:           memcpy(&zOut[iOut], zNL, nNL);",
          "4030:           iOut += nNL;",
          "4031:         }else if( zText[i]=='\\r' ){",
          "4032:           memcpy(&zOut[iOut], zCR, nCR);",
          "4033:           iOut += nCR;",
          "4034:         }else{",
          "4035:           zOut[iOut] = zText[i];",
          "4036:           iOut++;",
          "4037:         }",
          "4038:       }",
          "4040:       if( zNL ){",
          "4041:         memcpy(&zOut[iOut], \",'\", 2); iOut += 2;",
          "4042:         memcpy(&zOut[iOut], zNL, nNL); iOut += nNL;",
          "4043:         memcpy(&zOut[iOut], \"', char(10))\", 12); iOut += 12;",
          "4044:       }",
          "4045:       if( zCR ){",
          "4046:         memcpy(&zOut[iOut], \",'\", 2); iOut += 2;",
          "4047:         memcpy(&zOut[iOut], zCR, nCR); iOut += nCR;",
          "4048:         memcpy(&zOut[iOut], \"', char(13))\", 12); iOut += 12;",
          "4049:       }",
          "4051:       sqlite3_result_text(context, zOut, iOut, SQLITE_TRANSIENT);",
          "4052:       sqlite3_free(zOut);",
          "4053:       return;",
          "4054:     }",
          "4055:   }",
          "4057:   sqlite3_result_value(context, argv[0]);",
          "4058: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3999:     sqlite3_fileio_init(p->db, 0, 0);",
          "4000:     sqlite3_shathree_init(p->db, 0, 0);",
          "4001:     sqlite3_completion_init(p->db, 0, 0);",
          "4002: #ifdef SQLITE_HAVE_ZLIB",
          "4003:     sqlite3_zipfile_init(p->db, 0, 0);",
          "4004:     sqlite3_sqlar_init(p->db, 0, 0);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4128: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB)",
          "4129:     sqlite3_dbdata_init(p->db, 0, 0);",
          "4130: #endif",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4009:                             shellModuleSchema, 0, 0);",
          "4010:     sqlite3_create_function(p->db, \"shell_putsnl\", 1, SQLITE_UTF8, p,",
          "4011:                             shellPutsFunc, 0, 0);",
          "4012: #ifndef SQLITE_NOHAVE_SYSTEM",
          "4013:     sqlite3_create_function(p->db, \"edit\", 1, SQLITE_UTF8, 0,",
          "4014:                             editFunc, 0, 0);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4141:     sqlite3_create_function(p->db, \"shell_escape_crnl\", 1, SQLITE_UTF8, 0,",
          "4142:                             shellEscapeCrnl, 0, 0);",
          "4143:     sqlite3_create_function(p->db, \"shell_int32\", 2, SQLITE_UTF8, 0,",
          "4144:                             shellInt32, 0, 0);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "5263:   return SQLITE_ERROR;",
          "5264: }",
          "5270: static void shellPrepare(",
          "5271:   sqlite3 *db,",
          "5272:   int *pRc,",
          "",
          "[Removed Lines]",
          "5266: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB)",
          "",
          "[Added Lines]",
          "5399: #if !defined SQLITE_OMIT_VIRTUALTABLE",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "5338:   }",
          "5339: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5472: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6165: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB)",
          "6172: static void shellExec(sqlite3 *db, int *pRc, const char *zSql){",
          "6173:   int rc = *pRc;",
          "6174:   if( rc==SQLITE_OK ){",
          "6175:     char *zErr = 0;",
          "6176:     rc = sqlite3_exec(db, zSql, 0, 0, &zErr);",
          "6177:     if( rc!=SQLITE_OK ){",
          "6178:       raw_printf(stderr, \"SQL error: %s\\n\", zErr);",
          "6179:     }",
          "6181:   }",
          "6182: }",
          "6187: static void shellExecPrintf(sqlite3 *db, int *pRc, const char *zFmt, ...){",
          "6188:   char *z = 0;",
          "6189:   if( *pRc==SQLITE_OK ){",
          "6190:     va_list ap;",
          "6191:     va_start(ap, zFmt);",
          "6192:     z = sqlite3_vmprintf(zFmt, ap);",
          "6193:     va_end(ap);",
          "6194:     if( z==0 ){",
          "6196:     }else{",
          "6197:       shellExec(db, pRc, z);",
          "6198:     }",
          "6199:     sqlite3_free(z);",
          "6200:   }",
          "6201: }",
          "6209: static void *shellMalloc(int *pRc, sqlite3_int64 nByte){",
          "6210:   void *pRet = 0;",
          "6211:   if( *pRc==SQLITE_OK ){",
          "6212:     pRet = sqlite3_malloc64(nByte);",
          "6213:     if( pRet==0 ){",
          "6215:     }else{",
          "6216:       memset(pRet, 0, nByte);",
          "6217:     }",
          "6218:   }",
          "6219:   return pRet;",
          "6220: }",
          "6233: static char *shellMPrintf(int *pRc, const char *zFmt, ...){",
          "6234:   char *z = 0;",
          "6235:   if( *pRc==SQLITE_OK ){",
          "6236:     va_list ap;",
          "6237:     va_start(ap, zFmt);",
          "6238:     z = sqlite3_vmprintf(zFmt, ap);",
          "6239:     va_end(ap);",
          "6240:     if( z==0 ){",
          "6242:     }",
          "6243:   }",
          "6244:   return z;",
          "6245: }",
          "6252: typedef struct RecoverTable RecoverTable;",
          "6253: struct RecoverTable {",
          "6258: };",
          "6264: static void recoverFreeTable(RecoverTable *pTab){",
          "6265:   if( pTab ){",
          "6266:     sqlite3_free(pTab->zQuoted);",
          "6267:     if( pTab->azlCol ){",
          "6268:       int i;",
          "6269:       for(i=0; i<=pTab->nCol; i++){",
          "6270:         sqlite3_free(pTab->azlCol[i]);",
          "6271:       }",
          "6272:       sqlite3_free(pTab->azlCol);",
          "6273:     }",
          "6274:     sqlite3_free(pTab);",
          "6275:   }",
          "6276: }",
          "6285: static RecoverTable *recoverNewTable(",
          "6289:   int bIntkey,",
          "6290:   int nCol",
          "6291: ){",
          "6293:   int rc = *pRc;",
          "6294:   RecoverTable *pTab = 0;",
          "6296:   pTab = (RecoverTable*)shellMalloc(&rc, sizeof(RecoverTable));",
          "6297:   if( rc==SQLITE_OK ){",
          "6298:     int nSqlCol = 0;",
          "6299:     int bSqlIntkey = 0;",
          "6300:     sqlite3_stmt *pStmt = 0;",
          "6302:     rc = sqlite3_open(\"\", &dbtmp);",
          "6303:     if( rc==SQLITE_OK ){",
          "6304:       rc = sqlite3_exec(dbtmp, \"PRAGMA writable_schema = on\", 0, 0, 0);",
          "6305:     }",
          "6306:     if( rc==SQLITE_OK ){",
          "6307:       rc = sqlite3_exec(dbtmp, zSql, 0, 0, 0);",
          "6308:       if( rc==SQLITE_ERROR ){",
          "6309:         rc = SQLITE_OK;",
          "6310:         goto finished;",
          "6311:       }",
          "6312:     }",
          "6313:     shellPreparePrintf(dbtmp, &rc, &pStmt,",
          "6314:         \"SELECT count(*) FROM pragma_table_info(%Q)\", zName",
          "6315:     );",
          "6316:     if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6317:       nSqlCol = sqlite3_column_int(pStmt, 0);",
          "6318:     }",
          "6319:     shellFinalize(&rc, pStmt);",
          "6321:     if( rc!=SQLITE_OK || nSqlCol<nCol ){",
          "6322:       goto finished;",
          "6323:     }",
          "6325:     shellPreparePrintf(dbtmp, &rc, &pStmt,",
          "6326:       \"SELECT (\"",
          "6327:       \"  SELECT substr(data,1,1)==X'0D' FROM sqlite_dbpage WHERE pgno=rootpage\"",
          "6328:       \") FROM sqlite_master WHERE name = %Q\", zName",
          "6329:     );",
          "6330:     if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6331:       bSqlIntkey = sqlite3_column_int(pStmt, 0);",
          "6332:     }",
          "6333:     shellFinalize(&rc, pStmt);",
          "6335:     if( bIntkey==bSqlIntkey ){",
          "6336:       int i;",
          "6337:       const char *zPk = \"_rowid_\";",
          "6338:       sqlite3_stmt *pPkFinder = 0;",
          "6345:       pTab->iPk = -2;",
          "6346:       if( bIntkey ){",
          "6347:         shellPreparePrintf(dbtmp, &rc, &pPkFinder,",
          "6348:           \"SELECT cid, name FROM pragma_table_info(%Q) \"",
          "6349:           \"  WHERE pk=1 AND type='integer' COLLATE nocase\"",
          "6350:           \"  AND NOT EXISTS (SELECT cid FROM pragma_table_info(%Q) WHERE pk=2)\"",
          "6351:           , zName, zName",
          "6352:         );",
          "6353:         if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pPkFinder) ){",
          "6354:           pTab->iPk = sqlite3_column_int(pPkFinder, 0);",
          "6355:           zPk = (const char*)sqlite3_column_text(pPkFinder, 1);",
          "6356:         }",
          "6357:       }",
          "6359:       pTab->zQuoted = shellMPrintf(&rc, \"%Q\", zName);",
          "6360:       pTab->azlCol = (char**)shellMalloc(&rc, sizeof(char*) * (nSqlCol+1));",
          "6361:       pTab->nCol = nSqlCol;",
          "6363:       if( bIntkey ){",
          "6364:         pTab->azlCol[0] = shellMPrintf(&rc, \"%Q\", zPk);",
          "6365:       }else{",
          "6366:         pTab->azlCol[0] = shellMPrintf(&rc, \"\");",
          "6367:       }",
          "6368:       i = 1;",
          "6369:       shellPreparePrintf(dbtmp, &rc, &pStmt,",
          "6370:           \"SELECT %Q || group_concat(name, ', ') \"",
          "6371:           \"  FILTER (WHERE cid!=%d) OVER (ORDER BY %s cid) \"",
          "6372:           \"FROM pragma_table_info(%Q)\",",
          "6373:           bIntkey ? \", \" : \"\", pTab->iPk,",
          "6374:           bIntkey ? \"\" : \"(CASE WHEN pk=0 THEN 1000000 ELSE pk END), \",",
          "6375:           zName",
          "6376:       );",
          "6377:       while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6378:         const char *zText = (const char*)sqlite3_column_text(pStmt, 0);",
          "6379:         pTab->azlCol[i] = shellMPrintf(&rc, \"%s%s\", pTab->azlCol[0], zText);",
          "6380:         i++;",
          "6381:       }",
          "6382:       shellFinalize(&rc, pStmt);",
          "6384:       shellFinalize(&rc, pPkFinder);",
          "6385:     }",
          "6386:   }",
          "6388:  finished:",
          "6389:   sqlite3_close(dbtmp);",
          "6391:   if( rc!=SQLITE_OK ){",
          "6392:     recoverFreeTable(pTab);",
          "6393:     pTab = 0;",
          "6394:   }",
          "6395:   return pTab;",
          "6396: }",
          "6413: static RecoverTable *recoverFindTable(",
          "6420: ){",
          "6421:   sqlite3_stmt *pStmt = 0;",
          "6422:   RecoverTable *pRet = 0;",
          "6423:   int bNoop = 0;",
          "6424:   const char *zSql = 0;",
          "6425:   const char *zName = 0;",
          "6428:   shellPreparePrintf(pState->db, pRc, &pStmt,",
          "6429:       \"SELECT type, name, sql FROM recovery.schema WHERE rootpage=%d\", iRoot",
          "6430:   );",
          "6431:   while( *pRc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6432:     const char *zType = (const char*)sqlite3_column_text(pStmt, 0);",
          "6433:     if( bIntkey==0 && sqlite3_stricmp(zType, \"index\")==0 ){",
          "6434:       bNoop = 1;",
          "6435:       break;",
          "6436:     }",
          "6437:     if( sqlite3_stricmp(zType, \"table\")==0 ){",
          "6438:       zName = (const char*)sqlite3_column_text(pStmt, 1);",
          "6439:       zSql = (const char*)sqlite3_column_text(pStmt, 2);",
          "6440:       pRet = recoverNewTable(pRc, zName, zSql, bIntkey, nCol);",
          "6441:       break;",
          "6442:     }",
          "6443:   }",
          "6445:   shellFinalize(pRc, pStmt);",
          "6447:   return pRet;",
          "6448: }",
          "6453: static RecoverTable *recoverOrphanTable(",
          "6458: ){",
          "6459:   RecoverTable *pTab = 0;",
          "6460:   if( nCol>=0 && *pRc==SQLITE_OK ){",
          "6461:     int i;",
          "6467:     int iTab = 0;",
          "6468:     char *zTab = shellMPrintf(pRc, \"%s\", zLostAndFound);",
          "6469:     sqlite3_stmt *pTest = 0;",
          "6470:     shellPrepare(pState->db, pRc,",
          "6471:         \"SELECT 1 FROM recovery.schema WHERE name=?\", &pTest",
          "6472:     );",
          "6473:     if( pTest ) sqlite3_bind_text(pTest, 1, zTab, -1, SQLITE_TRANSIENT);",
          "6474:     while( *pRc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pTest) ){",
          "6475:       shellReset(pRc, pTest);",
          "6476:       sqlite3_free(zTab);",
          "6477:       zTab = shellMPrintf(pRc, \"%s_%d\", zLostAndFound, iTab++);",
          "6478:       sqlite3_bind_text(pTest, 1, zTab, -1, SQLITE_TRANSIENT);",
          "6479:     }",
          "6480:     shellFinalize(pRc, pTest);",
          "6482:     pTab = (RecoverTable*)shellMalloc(pRc, sizeof(RecoverTable));",
          "6483:     if( pTab ){",
          "6484:       pTab->zQuoted = shellMPrintf(pRc, \"%Q\", zTab);",
          "6485:       pTab->nCol = nCol;",
          "6486:       pTab->iPk = -2;",
          "6487:       if( nCol>0 ){",
          "6488:         pTab->azlCol = (char**)shellMalloc(pRc, sizeof(char*) * (nCol+1));",
          "6489:         if( pTab->azlCol ){",
          "6490:           pTab->azlCol[nCol] = shellMPrintf(pRc, \"\");",
          "6491:           for(i=nCol-1; i>=0; i--){",
          "6492:             pTab->azlCol[i] = shellMPrintf(pRc, \"%s, NULL\", pTab->azlCol[i+1]);",
          "6493:           }",
          "6494:         }",
          "6495:       }",
          "6497:       if( *pRc!=SQLITE_OK ){",
          "6498:         recoverFreeTable(pTab);",
          "6499:         pTab = 0;",
          "6500:       }else{",
          "6501:         raw_printf(pState->out,",
          "6502:             \"CREATE TABLE %s(rootpgno INTEGER, \"",
          "6503:             \"pgno INTEGER, nfield INTEGER, id INTEGER\", pTab->zQuoted",
          "6504:         );",
          "6505:         for(i=0; i<nCol; i++){",
          "6506:           raw_printf(pState->out, \", c%d\", i);",
          "6507:         }",
          "6508:         raw_printf(pState->out, \");\\n\");",
          "6509:       }",
          "6510:     }",
          "6511:     sqlite3_free(zTab);",
          "6512:   }",
          "6513:   return pTab;",
          "6514: }",
          "6521: static int recoverDatabaseCmd(ShellState *pState, int nArg, char **azArg){",
          "6522:   int rc = SQLITE_OK;",
          "6527:   const char *zLostAndFound = \"lost_and_found\";",
          "6528:   int i;",
          "6529:   int nOrphan = -1;",
          "6530:   RecoverTable *pOrphan = 0;",
          "6533:   for(i=1; i<nArg; i++){",
          "6534:     char *z = azArg[i];",
          "6535:     int n;",
          "6536:     if( z[0]=='-' && z[1]=='-' ) z++;",
          "6537:     n = strlen(z);",
          "6538:     if( n<=17 && memcmp(\"-freelist-corrupt\", z, n)==0 ){",
          "6539:       bFreelist = 0;",
          "6540:     }else",
          "6541:     if( n<=12 && memcmp(\"-recovery-db\", z, n)==0 && i<(nArg-1) ){",
          "6542:       i++;",
          "6543:       zRecoveryDb = azArg[i];",
          "6544:     }else",
          "6545:     if( n<=15 && memcmp(\"-lost-and-found\", z, n)==0 && i<(nArg-1) ){",
          "6546:       i++;",
          "6547:       zLostAndFound = azArg[i];",
          "6548:     }",
          "6549:     else{",
          "6550:       raw_printf(stderr, \"unexpected option: %s\\n\", azArg[i]);",
          "6551:       raw_printf(stderr, \"options are:\\n\");",
          "6552:       raw_printf(stderr, \"    --freelist-corrupt\\n\");",
          "6553:       raw_printf(stderr, \"    --recovery-db DATABASE\\n\");",
          "6554:       raw_printf(stderr, \"    --lost-and-found TABLE-NAME\\n\");",
          "6555:       return 1;",
          "6556:     }",
          "6557:   }",
          "6559:   shellExecPrintf(pState->db, &rc,",
          "6562:     \"ATTACH %Q AS recovery;\"",
          "6563:     \"DROP TABLE IF EXISTS recovery.dbptr;\"",
          "6564:     \"DROP TABLE IF EXISTS recovery.freelist;\"",
          "6565:     \"DROP TABLE IF EXISTS recovery.map;\"",
          "6566:     \"DROP TABLE IF EXISTS recovery.schema;\"",
          "6567:     \"CREATE TABLE recovery.freelist(pgno INTEGER PRIMARY KEY);\", zRecoveryDb",
          "6568:   );",
          "6570:   if( bFreelist ){",
          "6571:     shellExec(pState->db, &rc,",
          "6572:       \"WITH trunk(pgno) AS (\"",
          "6573:       \"  SELECT shell_int32(\"",
          "6574:       \"      (SELECT data FROM sqlite_dbpage WHERE pgno=1), 8) AS x \"",
          "6575:       \"      WHERE x>0\"",
          "6576:       \"    UNION\"",
          "6577:       \"  SELECT shell_int32(\"",
          "6578:       \"      (SELECT data FROM sqlite_dbpage WHERE pgno=trunk.pgno), 0) AS x \"",
          "6579:       \"      FROM trunk WHERE x>0\"",
          "6580:       \"),\"",
          "6581:       \"freelist(data, n, freepgno) AS (\"",
          "6582:       \"  SELECT data, shell_int32(data, 1)-1, t.pgno \"",
          "6583:       \"      FROM trunk t, sqlite_dbpage s WHERE s.pgno=t.pgno\"",
          "6584:       \"    UNION ALL\"",
          "6585:       \"  SELECT data, n-1, shell_int32(data, 2+n) \"",
          "6586:       \"      FROM freelist WHERE n>=0\"",
          "6587:       \")\"",
          "6588:       \"REPLACE INTO recovery.freelist SELECT freepgno FROM freelist;\"",
          "6589:     );",
          "6590:   }",
          "6592:   shellExec(pState->db, &rc,",
          "6593:     \"CREATE TABLE recovery.dbptr(\"",
          "6594:     \"      pgno, child, PRIMARY KEY(child, pgno)\"",
          "6595:     \") WITHOUT ROWID;\"",
          "6596:     \"INSERT OR IGNORE INTO recovery.dbptr(pgno, child) \"",
          "6597:     \"    SELECT * FROM sqlite_dbptr\"",
          "6598:     \"      WHERE pgno NOT IN freelist AND child NOT IN freelist;\"",
          "6602:     \"DELETE FROM recovery.dbptr WHERE child = 1;\"",
          "6607:     \"DELETE FROM recovery.dbptr WHERE child IN (\"",
          "6608:     \"  SELECT child FROM recovery.dbptr GROUP BY child HAVING count(*)>1\"",
          "6609:     \");\"",
          "6614:     \"CREATE TABLE recovery.map(\"",
          "6615:       \"pgno INTEGER PRIMARY KEY, maxlen INT, intkey, root INT\"",
          "6616:     \");\"",
          "6621:     \"WITH pages(i, maxlen) AS (\"",
          "6622:     \"  SELECT page_count, (\"",
          "6623:     \"    SELECT max(field+1) FROM sqlite_dbdata WHERE pgno=page_count\"",
          "6624:     \"  ) FROM pragma_page_count\"",
          "6625:     \"    UNION ALL\"",
          "6626:     \"  SELECT i-1, (\"",
          "6627:     \"    SELECT max(field+1) FROM sqlite_dbdata WHERE pgno=i-1\"",
          "6628:     \"  ) FROM pages WHERE i>=2\"",
          "6629:     \")\"",
          "6630:     \"INSERT INTO recovery.map(pgno, maxlen, intkey, root) \"",
          "6631:     \"  SELECT i, maxlen, NULL, (\"",
          "6632:     \"    WITH p(orig, pgno, parent) AS (\"",
          "6633:     \"      SELECT 0, i, (SELECT pgno FROM recovery.dbptr WHERE child=i)\"",
          "6634:     \"        UNION ALL\"",
          "6635:     \"      SELECT i, p.parent, \"",
          "6636:     \"        (SELECT pgno FROM recovery.dbptr WHERE child=p.parent) FROM p\"",
          "6637:     \"    )\"",
          "6638:     \"    SELECT pgno FROM p WHERE (parent IS NULL OR pgno = orig)\"",
          "6639:     \") \"",
          "6640:     \"FROM pages WHERE maxlen > 0 AND i NOT IN freelist;\"",
          "6641:     \"UPDATE recovery.map AS o SET intkey = (\"",
          "6642:     \"  SELECT substr(data, 1, 1)==X'0D' FROM sqlite_dbpage WHERE pgno=o.pgno\"",
          "6643:     \");\"",
          "6647:     \"CREATE TABLE recovery.schema(type, name, tbl_name, rootpage, sql);\"",
          "6648:     \"INSERT INTO recovery.schema SELECT \"",
          "6649:     \"  max(CASE WHEN field=0 THEN value ELSE NULL END),\"",
          "6650:     \"  max(CASE WHEN field=1 THEN value ELSE NULL END),\"",
          "6651:     \"  max(CASE WHEN field=2 THEN value ELSE NULL END),\"",
          "6652:     \"  max(CASE WHEN field=3 THEN value ELSE NULL END),\"",
          "6653:     \"  max(CASE WHEN field=4 THEN value ELSE NULL END)\"",
          "6654:     \"FROM sqlite_dbdata WHERE pgno IN (\"",
          "6655:     \"  SELECT pgno FROM recovery.map WHERE root=1\"",
          "6656:     \")\"",
          "6657:     \"GROUP BY pgno, cell;\"",
          "6658:     \"CREATE INDEX recovery.schema_rootpage ON schema(rootpage);\"",
          "6659:   );",
          "6663:   if( rc==SQLITE_OK ){",
          "6664:     sqlite3_stmt *pStmt = 0;",
          "6665:     raw_printf(pState->out, \"BEGIN;\\n\");",
          "6666:     raw_printf(pState->out, \"PRAGMA writable_schema = on;\\n\");",
          "6667:     shellPrepare(pState->db, &rc,",
          "6668:         \"SELECT sql FROM recovery.schema \"",
          "6669:         \"WHERE type='table' AND sql LIKE 'create table%'\", &pStmt",
          "6670:     );",
          "6671:     while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6672:       const char *zCreateTable = (const char*)sqlite3_column_text(pStmt, 0);",
          "6673:       raw_printf(pState->out, \"CREATE TABLE IF NOT EXISTS %s;\\n\",",
          "6674:           &zCreateTable[12]",
          "6675:       );",
          "6676:     }",
          "6677:     shellFinalize(&rc, pStmt);",
          "6678:   }",
          "6682:   shellPrepare(pState->db, &rc,",
          "6683:       \"SELECT coalesce(max(maxlen), -2) FROM recovery.map\"",
          "6684:       \"  WHERE root>1 AND root NOT IN (SELECT rootpage FROM recovery.schema)\"",
          "6685:       , &pLoop",
          "6686:   );",
          "6687:   if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pLoop) ){",
          "6688:     nOrphan = sqlite3_column_int(pLoop, 0);",
          "6689:   }",
          "6690:   shellFinalize(&rc, pLoop);",
          "6691:   pLoop = 0;",
          "6692:   pOrphan = recoverOrphanTable(pState, &rc, zLostAndFound, nOrphan);",
          "6694:   shellPrepare(pState->db, &rc,",
          "6695:       \"SELECT pgno FROM recovery.map WHERE root=?\", &pPages",
          "6696:   );",
          "6697:   shellPrepare(pState->db, &rc,",
          "6698:       \"SELECT max(field), group_concat(shell_escape_crnl(quote(value)), ', ')\"",
          "6699:       \"FROM sqlite_dbdata WHERE pgno = ? AND field != ?\"",
          "6700:       \"GROUP BY cell\", &pCells",
          "6701:   );",
          "6704:   shellPrepare(pState->db, &rc,",
          "6705:       \"SELECT root, intkey, max(maxlen) FROM recovery.map\"",
          "6706:       \" WHERE root>1 GROUP BY root, intkey ORDER BY root=(\"",
          "6707:       \"  SELECT rootpage FROM recovery.schema WHERE name='sqlite_sequence'\"",
          "6708:       \")\", &pLoop",
          "6709:   );",
          "6710:   while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pLoop) ){",
          "6711:     int iRoot = sqlite3_column_int(pLoop, 0);",
          "6712:     int bIntkey = sqlite3_column_int(pLoop, 1);",
          "6713:     int nCol = sqlite3_column_int(pLoop, 2);",
          "6714:     int bNoop = 0;",
          "6715:     RecoverTable *pTab;",
          "6717:     pTab = recoverFindTable(pState, &rc, iRoot, bIntkey, nCol, &bNoop);",
          "6718:     if( bNoop || rc ) continue;",
          "6719:     if( pTab==0 ) pTab = pOrphan;",
          "6721:     if( 0==sqlite3_stricmp(pTab->zQuoted, \"'sqlite_sequence'\") ){",
          "6722:       raw_printf(pState->out, \"DELETE FROM sqlite_sequence;\\n\");",
          "6723:     }",
          "6724:     sqlite3_bind_int(pPages, 1, iRoot);",
          "6725:     sqlite3_bind_int(pCells, 2, pTab->iPk);",
          "6727:     while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pPages) ){",
          "6728:       int iPgno = sqlite3_column_int(pPages, 0);",
          "6729:       sqlite3_bind_int(pCells, 1, iPgno);",
          "6730:       while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pCells) ){",
          "6731:         int nField = sqlite3_column_int(pCells, 0);",
          "6732:         const char *zVal = (const char*)sqlite3_column_text(pCells, 1);",
          "6734:         nField = nField+1;",
          "6735:         if( pTab==pOrphan ){",
          "6736:           raw_printf(pState->out,",
          "6737:               \"INSERT INTO %s VALUES(%d, %d, %d, %s%s%s);\\n\",",
          "6738:               pTab->zQuoted, iRoot, iPgno, nField,",
          "6739:               bIntkey ? \"\" : \"NULL, \", zVal, pTab->azlCol[nField]",
          "6740:           );",
          "6741:         }else{",
          "6742:           raw_printf(pState->out, \"INSERT INTO %s(%s) VALUES( %s );\\n\",",
          "6743:               pTab->zQuoted, pTab->azlCol[nField], zVal",
          "6744:           );",
          "6745:         }",
          "6746:       }",
          "6747:       shellReset(&rc, pCells);",
          "6748:     }",
          "6749:     shellReset(&rc, pPages);",
          "6750:     if( pTab!=pOrphan ) recoverFreeTable(pTab);",
          "6751:   }",
          "6752:   shellFinalize(&rc, pLoop);",
          "6753:   shellFinalize(&rc, pPages);",
          "6754:   shellFinalize(&rc, pCells);",
          "6755:   recoverFreeTable(pOrphan);",
          "6758:   if( rc==SQLITE_OK ){",
          "6759:     sqlite3_stmt *pStmt = 0;",
          "6760:     shellPrepare(pState->db, &rc,",
          "6761:         \"SELECT sql, name FROM recovery.schema \"",
          "6762:         \"WHERE sql NOT LIKE 'create table%'\", &pStmt",
          "6763:     );",
          "6764:     while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6765:       const char *zSql = (const char*)sqlite3_column_text(pStmt, 0);",
          "6766:       if( sqlite3_strnicmp(zSql, \"create virt\", 11)==0 ){",
          "6767:         const char *zName = (const char*)sqlite3_column_text(pStmt, 1);",
          "6768:         char *zPrint = shellMPrintf(&rc,",
          "6769:           \"INSERT INTO sqlite_master VALUES('table', %Q, %Q, 0, %Q)\",",
          "6770:           zName, zName, zSql",
          "6771:         );",
          "6772:         raw_printf(pState->out, \"%s;\\n\", zPrint);",
          "6773:         sqlite3_free(zPrint);",
          "6774:       }else{",
          "6775:         raw_printf(pState->out, \"%s;\\n\", zSql);",
          "6776:       }",
          "6777:     }",
          "6778:     shellFinalize(&rc, pStmt);",
          "6779:   }",
          "6781:   if( rc==SQLITE_OK ){",
          "6782:     raw_printf(pState->out, \"PRAGMA writable_schema = off;\\n\");",
          "6783:     raw_printf(pState->out, \"COMMIT;\\n\");",
          "6784:   }",
          "6785:   sqlite3_exec(pState->db, \"DETACH recovery\", 0, 0, 0);",
          "6786:   return rc;",
          "6787: }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "6313:     rc = shell_dbinfo_command(p, nArg, azArg);",
          "6314:   }else",
          "6316:   if( c=='d' && strncmp(azArg[0], \"dump\", n)==0 ){",
          "6317:     const char *zLike = 0;",
          "6318:     int i;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7077: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB)",
          "7078:   if( c=='r' && strncmp(azArg[0], \"recover\", n)==0 ){",
          "7079:     open_db(p, 0);",
          "7080:     rc = recoverDatabaseCmd(p, nArg, azArg);",
          "7081:   }else",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "6398:     }",
          "6399:     sqlite3_exec(p->db, \"PRAGMA writable_schema=OFF;\", 0, 0, 0);",
          "6400:     sqlite3_exec(p->db, \"RELEASE dump;\", 0, 0, 0);",
          "6402:     p->showHeader = savedShowHeader;",
          "6403:     p->shellFlgs = savedShellFlags;",
          "6404:   }else",
          "",
          "[Removed Lines]",
          "6401:     raw_printf(p->out, p->nErr ? \"ROLLBACK; -- due to errors\\n\" : \"COMMIT;\\n\");",
          "",
          "[Added Lines]",
          "7171:     raw_printf(p->out, p->nErr?\"ROLLBACK; -- due to errors\\n\":\"COMMIT;\\n\");",
          "",
          "---------------"
        ],
        "test/dbdata.test||test/dbdata.test": [
          "File: test/dbdata.test -> test/dbdata.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2019-04-11",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: # This file implements regression tests for SQLite library.  The",
          "12: # focus of this file is testing the sqlite_dbpage virtual table.",
          "13: #",
          "15: set testdir [file dirname $argv0]",
          "16: source $testdir/tester.tcl",
          "17: set testprefix dbdata",
          "19: ifcapable !vtab||!compound {",
          "20:   finish_test",
          "21:   return",
          "22: }",
          "23: db enable_load_extension 1",
          "24: if { [catch { db eval { SELECT load_extension('../dbdata') } }] } {",
          "25:   finish_test",
          "26:   return",
          "27: }",
          "29: do_execsql_test 1.0 {",
          "30:   CREATE TABLE T1(a, b);",
          "31:   INSERT INTO t1(rowid, a ,b) VALUES(5, 'v', 'five');",
          "32:   INSERT INTO t1(rowid, a, b) VALUES(10, 'x', 'ten');",
          "33: }",
          "35: do_execsql_test 1.1 {",
          "36:   SELECT pgno, cell, field, quote(value) FROM sqlite_dbdata WHERE pgno=2;",
          "37: } {",
          "38:   2 0 -1 5",
          "39:   2 0  0 'v'",
          "40:   2 0  1 'five'",
          "41:   2 1 -1 10",
          "42:   2 1  0 'x'",
          "43:   2 1  1 'ten'",
          "44: }",
          "46: breakpoint",
          "47: do_execsql_test 1.2 {",
          "48:   SELECT pgno, cell, field, quote(value) FROM sqlite_dbdata;",
          "49: } {",
          "50:   1 0 -1 1",
          "51:   1 0 0 'table'",
          "52:   1 0 1 'T1'",
          "53:   1 0 2 'T1'",
          "54:   1 0 3 2",
          "55:   1 0 4 {'CREATE TABLE T1(a, b)'}",
          "56:   2 0 -1 5",
          "57:   2 0  0 'v'",
          "58:   2 0  1 'five'",
          "59:   2 1 -1 10",
          "60:   2 1  0 'x'",
          "61:   2 1  1 'ten'",
          "62: }",
          "64: set big [string repeat big 2000]",
          "65: do_execsql_test 1.3 {",
          "66:   INSERT INTO t1 VALUES(NULL, $big);",
          "67:   SELECT value FROM sqlite_dbdata WHERE pgno=2 AND cell=2 AND field=1;",
          "68: } $big",
          "70: do_execsql_test 1.4 {",
          "71:   DELETE FROM t1;",
          "72:   INSERT INTO t1 VALUES(NULL, randomblob(5050));",
          "73: }",
          "74: do_test 1.5 {",
          "75:   execsql {",
          "76:     SELECT quote(value) FROM sqlite_dbdata WHERE pgno=2 AND cell=0 AND field=1;",
          "77:   }",
          "78: } [db one {SELECT quote(b) FROM t1}]",
          "80: #-------------------------------------------------------------------------",
          "81: reset_db",
          "82: db enable_load_extension 1",
          "83: db eval { SELECT load_extension('../dbdata') }",
          "85: do_execsql_test 2.0 {",
          "86:   CREATE TABLE t1(a);",
          "87:   CREATE INDEX i1 ON t1(a);",
          "88:   WITH s(i) AS (",
          "89:     SELECT 1 UNION ALL SELECT i+1 FROM s WHERE i<10",
          "90:   )",
          "91:   INSERT INTO t1 SELECT randomblob(900) FROM s;",
          "92: }",
          "94: do_execsql_test 2.1 {",
          "95:   SELECT * FROM sqlite_dbptr WHERE pgno=2;",
          "96: } {",
          "97:   2 25   2 6   2 7   2 9   2 11   2 13   2 15   2 17   2 19   2 21",
          "98: }",
          "100: do_execsql_test 2.2 {",
          "101:   SELECT * FROM sqlite_dbptr WHERE pgno=3;",
          "102: } {",
          "103:   3 24   3 23",
          "104: }",
          "106: do_execsql_test 2.3 {",
          "107:   SELECT * FROM sqlite_dbptr",
          "108: } {",
          "109:   2 25   2 6   2 7   2 9   2 11   2 13   2 15   2 17   2 19   2 21",
          "110:   3 24   3 23",
          "111: }",
          "114: finish_test",
          "",
          "---------------"
        ],
        "test/recover.test||test/recover.test": [
          "File: test/recover.test -> test/recover.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2019 April 23",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: #",
          "12: # Test the shell tool \".ar\" command.",
          "13: #",
          "15: set testdir [file dirname $argv0]",
          "16: source $testdir/tester.tcl",
          "17: set testprefix recover",
          "19: ifcapable !vtab {",
          "20:   finish_test; return",
          "21: }",
          "22: set CLI [test_find_cli]",
          "24: proc compare_result {db1 db2 sql} {",
          "25:   set r1 [$db1 eval $sql]",
          "26:   set r2 [$db2 eval $sql]",
          "27:   if {$r1 != $r2} {",
          "28:   puts \"r1: $r1\"",
          "29:   puts \"r2: $r2\"",
          "30:     error \"mismatch for $sql\"",
          "31:   }",
          "32:   return \"\"",
          "33: }",
          "35: proc compare_dbs {db1 db2} {",
          "36:   compare_result $db1 $db2 \"SELECT sql FROM sqlite_master ORDER BY 1\"",
          "37:   foreach tbl [$db1 eval {SELECT name FROM sqlite_master WHERE type='table'}] {",
          "38:     compare_result $db1 $db2 \"SELECT * FROM $tbl\"",
          "39:   }",
          "40: }",
          "42: proc do_recover_test {tn {tsql {}} {res {}}} {",
          "43:   set fd [open \"|$::CLI test.db .recover\"]",
          "44:   fconfigure $fd -encoding binary",
          "45:   fconfigure $fd -translation binary",
          "46:   set sql [read $fd]",
          "47:   close $fd",
          "49:   forcedelete test.db2",
          "50:   sqlite3 db2 test.db2",
          "51:   execsql $sql db2",
          "52:   if {$tsql==\"\"} {",
          "53:     uplevel [list do_test $tn [list compare_dbs db db2] {}]",
          "54:   } else {",
          "55:     uplevel [list do_execsql_test -db db2 $tn $tsql $res]",
          "56:   }",
          "57:   db2 close",
          "58: }",
          "60: set doc {",
          "61:   hello",
          "62:   world",
          "63: }",
          "64: do_execsql_test 1.1.1 {",
          "65:   CREATE TABLE t1(a INTEGER PRIMARY KEY, b, c);",
          "66:   INSERT INTO t1 VALUES(1, 4, X'1234567800');",
          "67:   INSERT INTO t1 VALUES(2, 'test', 8.1);",
          "68:   INSERT INTO t1 VALUES(3, $doc, 8.4);",
          "69: }",
          "70: do_recover_test 1.1.2",
          "72: do_execsql_test 1.2.1 \"",
          "73:   DELETE FROM t1;",
          "74:   INSERT INTO t1 VALUES(13, 'hello\\r\\nworld', 13);",
          "75: \"",
          "76: do_recover_test 1.2.2",
          "78: do_execsql_test 1.3.1 \"",
          "79:   CREATE TABLE t2(i INTEGER PRIMARY KEY AUTOINCREMENT, b, c);",
          "80:   INSERT INTO t2 VALUES(NULL, 1, 2);",
          "81:   INSERT INTO t2 VALUES(NULL, 3, 4);",
          "82:   INSERT INTO t2 VALUES(NULL, 5, 6);",
          "83:   CREATE TABLE t3(i INTEGER PRIMARY KEY AUTOINCREMENT, b, c);",
          "84:   INSERT INTO t3 VALUES(NULL, 1, 2);",
          "85:   INSERT INTO t3 VALUES(NULL, 3, 4);",
          "86:   INSERT INTO t3 VALUES(NULL, 5, 6);",
          "87:   DELETE FROM t2;",
          "88: \"",
          "89: do_recover_test 1.3.2",
          "91: #-------------------------------------------------------------------------",
          "92: reset_db",
          "93: do_execsql_test 2.1.0 {",
          "94:   CREATE TABLE t1(a, b, c, PRIMARY KEY(b, c)) WITHOUT ROWID;",
          "95:   INSERT INTO t1 VALUES(1, 2, 3);",
          "96:   INSERT INTO t1 VALUES(4, 5, 6);",
          "97:   INSERT INTO t1 VALUES(7, 8, 9);",
          "98: }",
          "100: do_recover_test 2.1.1",
          "102: do_execsql_test 2.2.0 {",
          "103:   PRAGMA writable_schema = 1;",
          "104:   DELETE FROM sqlite_master WHERE name='t1';",
          "105: }",
          "106: do_recover_test 2.2.1 {",
          "107:   SELECT name FROM sqlite_master",
          "108: } {lost_and_found}",
          "110: do_execsql_test 2.3.0 {",
          "111:   CREATE TABLE lost_and_found(a, b, c);",
          "112: }",
          "113: do_recover_test 2.3.1 {",
          "114:   SELECT name FROM sqlite_master",
          "115: } {lost_and_found lost_and_found_0}",
          "117: do_execsql_test 2.4.0 {",
          "118:   CREATE TABLE lost_and_found_0(a, b, c);",
          "119: }",
          "120: do_recover_test 2.4.1 {",
          "121:   SELECT name FROM sqlite_master;",
          "122:   SELECT * FROM lost_and_found_1;",
          "123: } {lost_and_found lost_and_found_0 lost_and_found_1",
          "124:   2 2 3 {} 2 3 1",
          "125:   2 2 3 {} 5 6 4",
          "126:   2 2 3 {} 8 9 7",
          "127: }",
          "129: finish_test",
          "",
          "---------------"
        ],
        "tool/mkshellc.tcl||tool/mkshellc.tcl": [
          "File: tool/mkshellc.tcl -> tool/mkshellc.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "40:   }",
          "41:   return $line",
          "42: }",
          "43: while {1} {",
          "44:   set lx [omit_redundant_typedefs [gets $in]]",
          "45:   if {[eof $in]} break;",
          "46:   if {[regexp {^INCLUDE } $lx]} {",
          "47:     set cfile [lindex $lx 1]",
          "48:     puts $out \"/************************* Begin $cfile ******************/\"",
          "49:     set in2 [open $topdir/src/$cfile rb]",
          "50:     while {![eof $in2]} {",
          "51:       set lx [omit_redundant_typedefs [gets $in2]]",
          "53:       if {[regexp {^# *include \"test_windirent.h\"} $lx]} {",
          "54:         set lx \"/* $lx */\"",
          "55:       }",
          "",
          "[Removed Lines]",
          "52:       if {[regexp {^#include \"sqlite} $lx]} continue",
          "",
          "[Added Lines]",
          "43: set iLine 0",
          "47:   incr iLine",
          "51: #   puts $out \"#line 1 \\\"$cfile\\\"\"",
          "55:       if {[regexp {^#include \"sqlite} $lx]} {",
          "56:         set lx \"/* $lx */\"",
          "57:       }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "58:     }",
          "59:     close $in2",
          "60:     puts $out \"/************************* End $cfile ********************/\"",
          "61:     continue",
          "62:   }",
          "63:   puts $out $lx",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66: #   puts $out \"#line [expr $iLine+1] \\\"shell.c.in\\\"\"",
          "",
          "---------------"
        ]
      }
    }
  ]
}
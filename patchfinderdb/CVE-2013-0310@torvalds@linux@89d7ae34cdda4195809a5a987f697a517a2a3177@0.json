{
  "cve_id": "CVE-2013-0310",
  "cve_desc": "The cipso_v4_validate function in net/ipv4/cipso_ipv4.c in the Linux kernel before 3.4.8 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via an IPOPT_CIPSO IP_OPTIONS setsockopt system call.",
  "repo": "torvalds/linux",
  "patch_hash": "89d7ae34cdda4195809a5a987f697a517a2a3177",
  "patch_info": {
    "commit_hash": "89d7ae34cdda4195809a5a987f697a517a2a3177",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/89d7ae34cdda4195809a5a987f697a517a2a3177",
    "files": [
      "net/ipv4/cipso_ipv4.c"
    ],
    "message": "cipso: don't follow a NULL pointer when setsockopt() is called\n\nAs reported by Alan Cox, and verified by Lin Ming, when a user\nattempts to add a CIPSO option to a socket using the CIPSO_V4_TAG_LOCAL\ntag the kernel dies a terrible death when it attempts to follow a NULL\npointer (the skb argument to cipso_v4_validate() is NULL when called via\nthe setsockopt() syscall).\n\nThis patch fixes this by first checking to ensure that the skb is\nnon-NULL before using it to find the incoming network interface.  In\nthe unlikely case where the skb is NULL and the user attempts to add\na CIPSO option with the _TAG_LOCAL tag we return an error as this is\nnot something we want to allow.\n\nA simple reproducer, kindly supplied by Lin Ming, although you must\nhave the CIPSO DOI #3 configure on the system first or you will be\ncaught early in cipso_v4_validate():\n\n\t#include <sys/types.h>\n\t#include <sys/socket.h>\n\t#include <linux/ip.h>\n\t#include <linux/in.h>\n\t#include <string.h>\n\n\tstruct local_tag {\n\t\tchar type;\n\t\tchar length;\n\t\tchar info[4];\n\t};\n\n\tstruct cipso {\n\t\tchar type;\n\t\tchar length;\n\t\tchar doi[4];\n\t\tstruct local_tag local;\n\t};\n\n\tint main(int argc, char **argv)\n\t{\n\t\tint sockfd;\n\t\tstruct cipso cipso = {\n\t\t\t.type = IPOPT_CIPSO,\n\t\t\t.length = sizeof(struct cipso),\n\t\t\t.local = {\n\t\t\t\t.type = 128,\n\t\t\t\t.length = sizeof(struct local_tag),\n\t\t\t},\n\t\t};\n\n\t\tmemset(cipso.doi, 0, 4);\n\t\tcipso.doi[3] = 3;\n\n\t\tsockfd = socket(AF_INET, SOCK_DGRAM, 0);\n\t\t#define SOL_IP 0\n\t\tsetsockopt(sockfd, SOL_IP, IP_OPTIONS,\n\t\t\t&cipso, sizeof(struct cipso));\n\n\t\treturn 0;\n\t}\n\nCC: Lin Ming <mlin@ss.pku.edu.cn>\nReported-by: Alan Cox <alan@lxorguk.ukuu.org.uk>\nSigned-off-by: Paul Moore <pmoore@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/ipv4/cipso_ipv4.c||net/ipv4/cipso_ipv4.c"
    ]
  },
  "patch_diff": {
    "net/ipv4/cipso_ipv4.c||net/ipv4/cipso_ipv4.c": [
      "File: net/ipv4/cipso_ipv4.c -> net/ipv4/cipso_ipv4.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1725:   case CIPSO_V4_TAG_LOCAL:",
      "1730:     err_offset = opt_iter;",
      "1731:     goto validate_return_locked;",
      "1732:    }",
      "",
      "[Removed Lines]",
      "1729:    if (!(skb->dev->flags & IFF_LOOPBACK)) {",
      "",
      "[Added Lines]",
      "1731:    if (skb == NULL || !(skb->dev->flags & IFF_LOOPBACK)) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7c319d328505b7781b65238ae9f53293b5ee0ca8",
      "candidate_info": {
        "commit_hash": "7c319d328505b7781b65238ae9f53293b5ee0ca8",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7c319d328505b7781b65238ae9f53293b5ee0ca8",
        "files": [
          "fs/ext4/ext4.h",
          "fs/ext4/ext4_jbd2.h",
          "fs/ext4/super.c"
        ],
        "message": "ext4: make quota as first class supported feature\n\nThis patch adds support for quotas as a first class feature in ext4;\nwhich is to say, the quota files are stored in hidden inodes as file\nsystem metadata, instead of as separate files visible in the file system\ndirectory hierarchy.\n\nIt is based on the proposal at:                                                                                                           \nhttps://ext4.wiki.kernel.org/index.php/Design_For_1st_Class_Quota_in_Ext4\n\nThis patch introduces a new feature - EXT4_FEATURE_RO_COMPAT_QUOTA\nwhich, when turned on, enables quota accounting at mount time\niteself. Also, the quota inodes are stored in two additional superblock\nfields.  Some changes introduced by this patch that should be pointed\nout are:\n\n1) Two new ext4-superblock fields - s_usr_quota_inum and\n   s_grp_quota_inum for storing the quota inodes in use.\n2) Default quota inodes are: inode#3 for tracking userquota and inode#4\n   for tracking group quota. The superblock fields can be set to use\n   other inodes as well.\n3) If the QUOTA feature and corresponding quota inodes are set in\n   superblock, the quota usage tracking is turned on at mount time. On\n   'quotaon' ioctl, the quota limits enforcement is turned\n   on. 'quotaoff' ioctl turns off only the limits enforcement in this\n   case.\n4) When QUOTA feature is in use, the quota mount options 'quota',\n   'usrquota', 'grpquota' are ignored by the kernel.\n5) mke2fs or tune2fs can be used to set the QUOTA feature and initialize\n   quota inodes. The default reserved inodes will not be visible to user\n   as regular files.\n6) The quota-tools will need to be modified to support hidden quota\n   files on ext4. E2fsprogs will also include support for creating and\n   fixing quota files.\n7) Support is only for the new V2 quota file format.\n\nTested-by: Jan Kara <jack@suse.cz>\nReviewed-by: Jan Kara <jack@suse.cz>\nReviewed-by: Johann Lombardi <johann@whamcloud.com>\nSigned-off-by: Aditya Kali <adityakali@google.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/ext4/ext4.h||fs/ext4/ext4.h",
          "fs/ext4/ext4_jbd2.h||fs/ext4/ext4_jbd2.h",
          "fs/ext4/super.c||fs/ext4/super.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/ext4/ext4.h||fs/ext4/ext4.h": [
          "File: fs/ext4/ext4.h -> fs/ext4/ext4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1315: static inline int ext4_valid_inum(struct super_block *sb, unsigned long ino)",
          "1316: {",
          "1317:  return ino == EXT4_ROOT_INO ||",
          "1318:   ino == EXT4_JOURNAL_INO ||",
          "1319:   ino == EXT4_RESIZE_INO ||",
          "1320:   (ino >= EXT4_FIRST_INO(sb) &&",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1318:   ino == EXT4_USR_QUOTA_INO ||",
          "1319:   ino == EXT4_GRP_QUOTA_INO ||",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1497:       EXT4_FEATURE_RO_COMPAT_BTREE_DIR |\\",
          "1498:       EXT4_FEATURE_RO_COMPAT_HUGE_FILE |\\",
          "1499:       EXT4_FEATURE_RO_COMPAT_BIGALLOC |\\",
          "",
          "[Removed Lines]",
          "1500:       EXT4_FEATURE_RO_COMPAT_METADATA_CSUM)",
          "",
          "[Added Lines]",
          "1502:       EXT4_FEATURE_RO_COMPAT_METADATA_CSUM|\\",
          "1503:       EXT4_FEATURE_RO_COMPAT_QUOTA)",
          "",
          "---------------"
        ],
        "fs/ext4/ext4_jbd2.h||fs/ext4/ext4_jbd2.h": [
          "File: fs/ext4/ext4_jbd2.h -> fs/ext4/ext4_jbd2.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "87: #ifdef CONFIG_QUOTA",
          "98: #else",
          "99: #define EXT4_QUOTA_TRANS_BLOCKS(sb) 0",
          "100: #define EXT4_QUOTA_INIT_BLOCKS(sb) 0",
          "",
          "[Removed Lines]",
          "90: #define EXT4_QUOTA_TRANS_BLOCKS(sb) (test_opt(sb, QUOTA) ? 1 : 0)",
          "93: #define EXT4_QUOTA_INIT_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_INIT_ALLOC*\\",
          "94:   (EXT4_SINGLEDATA_TRANS_BLOCKS(sb)-3)+3+DQUOT_INIT_REWRITE) : 0)",
          "96: #define EXT4_QUOTA_DEL_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_DEL_ALLOC*\\",
          "97:   (EXT4_SINGLEDATA_TRANS_BLOCKS(sb)-3)+3+DQUOT_DEL_REWRITE) : 0)",
          "",
          "[Added Lines]",
          "90: #define EXT4_QUOTA_TRANS_BLOCKS(sb) ((test_opt(sb, QUOTA) ||\\",
          "91:   EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA)) ?\\",
          "92:   1 : 0)",
          "95: #define EXT4_QUOTA_INIT_BLOCKS(sb) ((test_opt(sb, QUOTA) ||\\",
          "96:   EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA)) ?\\",
          "97:   (DQUOT_INIT_ALLOC*(EXT4_SINGLEDATA_TRANS_BLOCKS(sb)-3)\\",
          "98:    +3+DQUOT_INIT_REWRITE) : 0)",
          "100: #define EXT4_QUOTA_DEL_BLOCKS(sb) ((test_opt(sb, QUOTA) ||\\",
          "101:   EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA)) ?\\",
          "102:   (DQUOT_DEL_ALLOC*(EXT4_SINGLEDATA_TRANS_BLOCKS(sb)-3)\\",
          "103:    +3+DQUOT_DEL_REWRITE) : 0)",
          "",
          "---------------"
        ],
        "fs/ext4/super.c||fs/ext4/super.c": [
          "File: fs/ext4/super.c -> fs/ext4/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1137: static int ext4_write_info(struct super_block *sb, int type);",
          "1138: static int ext4_quota_on(struct super_block *sb, int type, int format_id,",
          "1139:     struct path *path);",
          "1140: static int ext4_quota_off(struct super_block *sb, int type);",
          "1141: static int ext4_quota_on_mount(struct super_block *sb, int type);",
          "1142: static ssize_t ext4_quota_read(struct super_block *sb, int type, char *data,",
          "1143:           size_t len, loff_t off);",
          "1144: static ssize_t ext4_quota_write(struct super_block *sb, int type,",
          "1145:     const char *data, size_t len, loff_t off);",
          "1147: static const struct dquot_operations ext4_quota_operations = {",
          "1148:  .get_reserved_space = ext4_get_reserved_space,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1140: static int ext4_quota_on_sysfile(struct super_block *sb, int type,",
          "1141:      int format_id);",
          "1143: static int ext4_quota_off_sysfile(struct super_block *sb, int type);",
          "1149: static int ext4_quota_enable(struct super_block *sb, int type, int format_id,",
          "1150:         unsigned int flags);",
          "1151: static int ext4_enable_quotas(struct super_block *sb);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1164:  .get_dqblk = dquot_get_dqblk,",
          "1165:  .set_dqblk = dquot_set_dqblk",
          "1166: };",
          "1167: #endif",
          "1169: static const struct super_operations ext4_sops = {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1174: static const struct quotactl_ops ext4_qctl_sysfile_operations = {",
          "1175:  .quota_on_meta = ext4_quota_on_sysfile,",
          "1176:  .quota_off = ext4_quota_off_sysfile,",
          "1177:  .quota_sync = dquot_quota_sync,",
          "1178:  .get_info = dquot_get_dqinfo,",
          "1179:  .set_info = dquot_set_dqinfo,",
          "1180:  .get_dqblk = dquot_get_dqblk,",
          "1181:  .set_dqblk = dquot_set_dqblk",
          "1182: };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2661:     \"extents feature\\n\");",
          "2662:   return 0;",
          "2663:  }",
          "2664:  return 1;",
          "2665: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2681: #ifndef CONFIG_QUOTA",
          "2682:  if (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA) &&",
          "2683:      !readonly) {",
          "2684:   ext4_msg(sb, KERN_ERR,",
          "2685:     \"Filesystem with quota feature cannot be mounted RDWR \"",
          "2686:     \"without CONFIG_QUOTA\");",
          "2687:   return 0;",
          "2688:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3748: #ifdef CONFIG_QUOTA",
          "3749:  sb->s_qcop = &ext4_qctl_operations;",
          "3750:  sb->dq_op = &ext4_quota_operations;",
          "3751: #endif",
          "3752:  memcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3778:  if (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA)) {",
          "3780:   sb->s_qcop = &ext4_qctl_sysfile_operations;",
          "3781:  }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3960:  } else",
          "3961:   descr = \"out journal\";",
          "3963:  ext4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"",
          "3964:    \"Opts: %s%s%s\", descr, sbi->s_es->s_mount_opts,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3994: #ifdef CONFIG_QUOTA",
          "3996:  if (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA) &&",
          "3997:      !(sb->s_flags & MS_RDONLY)) {",
          "3998:   ret = ext4_enable_quotas(sb);",
          "3999:   if (ret)",
          "4000:    goto failed_mount7;",
          "4001:  }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4682:  if (sbi->s_journal == NULL)",
          "4683:   ext4_commit_super(sb, 1);",
          "4685: #ifdef CONFIG_QUOTA",
          "4687:  for (i = 0; i < MAXQUOTAS; i++)",
          "4688:   if (old_opts.s_qf_names[i] &&",
          "4689:       old_opts.s_qf_names[i] != sbi->s_qf_names[i])",
          "4690:    kfree(old_opts.s_qf_names[i]);",
          "4691: #endif",
          "4696:  ext4_msg(sb, KERN_INFO, \"re-mounted. Opts: %s\", orig_data);",
          "4697:  kfree(orig_data);",
          "",
          "[Removed Lines]",
          "4692:  unlock_super(sb);",
          "4693:  if (enable_quota)",
          "4694:   dquot_resume(sb, -1);",
          "",
          "[Added Lines]",
          "4726:  unlock_super(sb);",
          "4733:  if (enable_quota) {",
          "4734:   if (sb_any_quota_suspended(sb))",
          "4735:    dquot_resume(sb, -1);",
          "4736:   else if (EXT4_HAS_RO_COMPAT_FEATURE(sb,",
          "4737:      EXT4_FEATURE_RO_COMPAT_QUOTA)) {",
          "4738:    err = ext4_enable_quotas(sb);",
          "4739:    if (err) {",
          "4740:     lock_super(sb);",
          "4741:     goto restore_opts;",
          "4742:    }",
          "4743:   }",
          "4744:  }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4904:  return dquot_quota_on(sb, type, format_id, path);",
          "4905: }",
          "4907: static int ext4_quota_off(struct super_block *sb, int type)",
          "4908: {",
          "4909:  struct inode *inode = sb_dqopt(sb)->files[type];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4958: static int ext4_quota_enable(struct super_block *sb, int type, int format_id,",
          "4959:         unsigned int flags)",
          "4960: {",
          "4961:  int err;",
          "4962:  struct inode *qf_inode;",
          "4963:  unsigned long qf_inums[MAXQUOTAS] = {",
          "4964:   le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),",
          "4965:   le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum)",
          "4966:  };",
          "4968:  BUG_ON(!EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA));",
          "4970:  if (!qf_inums[type])",
          "4971:   return -EPERM;",
          "4973:  qf_inode = ext4_iget(sb, qf_inums[type]);",
          "4974:  if (IS_ERR(qf_inode)) {",
          "4975:   ext4_error(sb, \"Bad quota inode # %lu\", qf_inums[type]);",
          "4976:   return PTR_ERR(qf_inode);",
          "4977:  }",
          "4979:  err = dquot_enable(qf_inode, type, format_id, flags);",
          "4980:  iput(qf_inode);",
          "4982:  return err;",
          "4983: }",
          "4986: static int ext4_enable_quotas(struct super_block *sb)",
          "4987: {",
          "4988:  int type, err = 0;",
          "4989:  unsigned long qf_inums[MAXQUOTAS] = {",
          "4990:   le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),",
          "4991:   le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum)",
          "4992:  };",
          "4994:  sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE;",
          "4995:  for (type = 0; type < MAXQUOTAS; type++) {",
          "4996:   if (qf_inums[type]) {",
          "4997:    err = ext4_quota_enable(sb, type, QFMT_VFS_V1,",
          "4998:       DQUOT_USAGE_ENABLED);",
          "4999:    if (err) {",
          "5000:     ext4_warning(sb,",
          "5001:      \"Failed to enable quota (type=%d) \"",
          "5002:      \"tracking. Please run e2fsck to fix.\",",
          "5003:      type);",
          "5004:     return err;",
          "5005:    }",
          "5006:   }",
          "5007:  }",
          "5008:  return 0;",
          "5009: }",
          "5014: static int ext4_quota_on_sysfile(struct super_block *sb, int type,",
          "5015:      int format_id)",
          "5016: {",
          "5017:  if (!EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA))",
          "5018:   return -EINVAL;",
          "5023:  return ext4_quota_enable(sb, type, format_id, DQUOT_LIMITS_ENABLED);",
          "5024: }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4930:  return dquot_quota_off(sb, type);",
          "4931: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5055: static int ext4_quota_off_sysfile(struct super_block *sb, int type)",
          "5056: {",
          "5057:  if (!EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_QUOTA))",
          "5058:   return -EINVAL;",
          "5061:  return dquot_disable(sb, type, DQUOT_LIMITS_ENABLED);",
          "5062: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3cf003c08be785af4bee9ac05891a15bcbff856a",
      "candidate_info": {
        "commit_hash": "3cf003c08be785af4bee9ac05891a15bcbff856a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3cf003c08be785af4bee9ac05891a15bcbff856a",
        "files": [
          "fs/cifs/cifssmb.c"
        ],
        "message": "cifs: when CONFIG_HIGHMEM is set, serialize the read/write kmaps\n\nJian found that when he ran fsx on a 32 bit arch with a large wsize the\nprocess and one of the bdi writeback kthreads would sometimes deadlock\nwith a stack trace like this:\n\ncrash> bt\nPID: 2789   TASK: f02edaa0  CPU: 3   COMMAND: \"fsx\"\n #0 [eed63cbc] schedule at c083c5b3\n #1 [eed63d80] kmap_high at c0500ec8\n #2 [eed63db0] cifs_async_writev at f7fabcd7 [cifs]\n #3 [eed63df0] cifs_writepages at f7fb7f5c [cifs]\n #4 [eed63e50] do_writepages at c04f3e32\n #5 [eed63e54] __filemap_fdatawrite_range at c04e152a\n #6 [eed63ea4] filemap_fdatawrite at c04e1b3e\n #7 [eed63eb4] cifs_file_aio_write at f7fa111a [cifs]\n #8 [eed63ecc] do_sync_write at c052d202\n #9 [eed63f74] vfs_write at c052d4ee\n#10 [eed63f94] sys_write at c052df4c\n#11 [eed63fb0] ia32_sysenter_target at c0409a98\n    EAX: 00000004  EBX: 00000003  ECX: abd73b73  EDX: 012a65c6\n    DS:  007b      ESI: 012a65c6  ES:  007b      EDI: 00000000\n    SS:  007b      ESP: bf8db178  EBP: bf8db1f8  GS:  0033\n    CS:  0073      EIP: 40000424  ERR: 00000004  EFLAGS: 00000246\n\nEach task would kmap part of its address array before getting stuck, but\nnot enough to actually issue the write.\n\nThis patch fixes this by serializing the marshal_iov operations for\nasync reads and writes. The idea here is to ensure that cifs\naggressively tries to populate a request before attempting to fulfill\nanother one. As soon as all of the pages are kmapped for a request, then\nwe can unlock and allow another one to proceed.\n\nThere's no need to do this serialization on non-CONFIG_HIGHMEM arches\nhowever, so optimize all of this out when CONFIG_HIGHMEM isn't set.\n\nCc: <stable@vger.kernel.org>\nReported-by: Jian Li <jiali@redhat.com>\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <smfrench@gmail.com>",
        "before_after_code_files": [
          "fs/cifs/cifssmb.c||fs/cifs/cifssmb.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/cifs/cifssmb.c||fs/cifs/cifssmb.c": [
          "File: fs/cifs/cifssmb.c -> fs/cifs/cifssmb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "89: #ifdef CONFIG_HIGHMEM",
          "97: static DEFINE_MUTEX(cifs_kmap_mutex);",
          "99: static inline void",
          "100: cifs_kmap_lock(void)",
          "101: {",
          "102:  mutex_lock(&cifs_kmap_mutex);",
          "103: }",
          "105: static inline void",
          "106: cifs_kmap_unlock(void)",
          "107: {",
          "108:  mutex_unlock(&cifs_kmap_mutex);",
          "109: }",
          "111: #define cifs_kmap_lock() do { ; } while(0)",
          "112: #define cifs_kmap_unlock() do { ; } while(0)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1503:  }",
          "1506:  len = rdata->marshal_iov(rdata, data_len);",
          "1507:  data_len -= len;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1530:  cifs_kmap_lock();",
          "1532:  cifs_kmap_unlock();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2072:  wdata->marshal_iov(iov, wdata);",
          "2074:  cFYI(1, \"async write at %llu %u bytes\", wdata->offset, wdata->bytes);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2098:  cifs_kmap_lock();",
          "2100:  cifs_kmap_unlock();",
          "",
          "---------------"
        ]
      }
    }
  ]
}
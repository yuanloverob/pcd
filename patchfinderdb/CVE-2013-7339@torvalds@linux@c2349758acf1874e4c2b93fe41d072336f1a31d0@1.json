{
  "cve_id": "CVE-2013-7339",
  "cve_desc": "The rds_ib_laddr_check function in net/rds/ib.c in the Linux kernel before 3.12.8 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via a bind system call for an RDS socket on a system that lacks RDS transports.",
  "repo": "torvalds/linux",
  "patch_hash": "c2349758acf1874e4c2b93fe41d072336f1a31d0",
  "patch_info": {
    "commit_hash": "c2349758acf1874e4c2b93fe41d072336f1a31d0",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/c2349758acf1874e4c2b93fe41d072336f1a31d0",
    "files": [
      "net/rds/ib.c"
    ],
    "message": "rds: prevent dereference of a NULL device\n\nBinding might result in a NULL device, which is dereferenced\ncausing this BUG:\n\n[ 1317.260548] BUG: unable to handle kernel NULL pointer dereference at 000000000000097\n4\n[ 1317.261847] IP: [<ffffffff84225f52>] rds_ib_laddr_check+0x82/0x110\n[ 1317.263315] PGD 418bcb067 PUD 3ceb21067 PMD 0\n[ 1317.263502] Oops: 0000 [#1] PREEMPT SMP DEBUG_PAGEALLOC\n[ 1317.264179] Dumping ftrace buffer:\n[ 1317.264774]    (ftrace buffer empty)\n[ 1317.265220] Modules linked in:\n[ 1317.265824] CPU: 4 PID: 836 Comm: trinity-child46 Tainted: G        W    3.13.0-rc4-\nnext-20131218-sasha-00013-g2cebb9b-dirty #4159\n[ 1317.267415] task: ffff8803ddf33000 ti: ffff8803cd31a000 task.ti: ffff8803cd31a000\n[ 1317.268399] RIP: 0010:[<ffffffff84225f52>]  [<ffffffff84225f52>] rds_ib_laddr_check+\n0x82/0x110\n[ 1317.269670] RSP: 0000:ffff8803cd31bdf8  EFLAGS: 00010246\n[ 1317.270230] RAX: 0000000000000000 RBX: ffff88020b0dd388 RCX: 0000000000000000\n[ 1317.270230] RDX: ffffffff8439822e RSI: 00000000000c000a RDI: 0000000000000286\n[ 1317.270230] RBP: ffff8803cd31be38 R08: 0000000000000000 R09: 0000000000000000\n[ 1317.270230] R10: 0000000000000000 R11: 0000000000000001 R12: 0000000000000000\n[ 1317.270230] R13: 0000000054086700 R14: 0000000000a25de0 R15: 0000000000000031\n[ 1317.270230] FS:  00007ff40251d700(0000) GS:ffff88022e200000(0000) knlGS:000000000000\n0000\n[ 1317.270230] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\n[ 1317.270230] CR2: 0000000000000974 CR3: 00000003cd478000 CR4: 00000000000006e0\n[ 1317.270230] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[ 1317.270230] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000090602\n[ 1317.270230] Stack:\n[ 1317.270230]  0000000054086700 5408670000a25de0 5408670000000002 0000000000000000\n[ 1317.270230]  ffffffff84223542 00000000ea54c767 0000000000000000 ffffffff86d26160\n[ 1317.270230]  ffff8803cd31be68 ffffffff84223556 ffff8803cd31beb8 ffff8800c6765280\n[ 1317.270230] Call Trace:\n[ 1317.270230]  [<ffffffff84223542>] ? rds_trans_get_preferred+0x42/0xa0\n[ 1317.270230]  [<ffffffff84223556>] rds_trans_get_preferred+0x56/0xa0\n[ 1317.270230]  [<ffffffff8421c9c3>] rds_bind+0x73/0xf0\n[ 1317.270230]  [<ffffffff83e4ce62>] SYSC_bind+0x92/0xf0\n[ 1317.270230]  [<ffffffff812493f8>] ? context_tracking_user_exit+0xb8/0x1d0\n[ 1317.270230]  [<ffffffff8119313d>] ? trace_hardirqs_on+0xd/0x10\n[ 1317.270230]  [<ffffffff8107a852>] ? syscall_trace_enter+0x32/0x290\n[ 1317.270230]  [<ffffffff83e4cece>] SyS_bind+0xe/0x10\n[ 1317.270230]  [<ffffffff843a6ad0>] tracesys+0xdd/0xe2\n[ 1317.270230] Code: 00 8b 45 cc 48 8d 75 d0 48 c7 45 d8 00 00 00 00 66 c7 45 d0 02 00\n89 45 d4 48 89 df e8 78 49 76 ff 41 89 c4 85 c0 75 0c 48 8b 03 <80> b8 74 09 00 00 01 7\n4 06 41 bc 9d ff ff ff f6 05 2a b6 c2 02\n[ 1317.270230] RIP  [<ffffffff84225f52>] rds_ib_laddr_check+0x82/0x110\n[ 1317.270230]  RSP <ffff8803cd31bdf8>\n[ 1317.270230] CR2: 0000000000000974\n\nSigned-off-by: Sasha Levin <sasha.levin@oracle.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/rds/ib.c||net/rds/ib.c"
    ]
  },
  "patch_diff": {
    "net/rds/ib.c||net/rds/ib.c": [
      "File: net/rds/ib.c -> net/rds/ib.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "338:  ret = rdma_bind_addr(cm_id, (struct sockaddr *)&sin);",
      "342:   ret = -EADDRNOTAVAIL;",
      "344:  rdsdebug(\"addr %pI4 ret %d node type %d\\n\",",
      "",
      "[Removed Lines]",
      "341:  if (ret || cm_id->device->node_type != RDMA_NODE_IB_CA)",
      "",
      "[Added Lines]",
      "341:  if (ret || !cm_id->device ||",
      "342:      cm_id->device->node_type != RDMA_NODE_IB_CA)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a3e0f9e47d5ef7858a26cc12d90ad5146e802d47",
      "candidate_info": {
        "commit_hash": "a3e0f9e47d5ef7858a26cc12d90ad5146e802d47",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/a3e0f9e47d5ef7858a26cc12d90ad5146e802d47",
        "files": [
          "mm/memory-failure.c"
        ],
        "message": "mm/memory-failure.c: transfer page count from head page to tail page after split thp\n\nMemory failures on thp tail pages cause kernel panic like below:\n\n   mce: [Hardware Error]: Machine check events logged\n   MCE exception done on CPU 7\n   BUG: unable to handle kernel NULL pointer dereference at 0000000000000058\n   IP: [<ffffffff811b7cd1>] dequeue_hwpoisoned_huge_page+0x131/0x1e0\n   PGD bae42067 PUD ba47d067 PMD 0\n   Oops: 0000 [#1] SMP\n  ...\n   CPU: 7 PID: 128 Comm: kworker/7:2 Tainted: G   M       O 3.13.0-rc4-131217-1558-00003-g83b7df08e462 #25\n  ...\n   Call Trace:\n     me_huge_page+0x3e/0x50\n     memory_failure+0x4bb/0xc20\n     mce_process_work+0x3e/0x70\n     process_one_work+0x171/0x420\n     worker_thread+0x11b/0x3a0\n     ? manage_workers.isra.25+0x2b0/0x2b0\n     kthread+0xe4/0x100\n     ? kthread_create_on_node+0x190/0x190\n     ret_from_fork+0x7c/0xb0\n     ? kthread_create_on_node+0x190/0x190\n  ...\n   RIP   dequeue_hwpoisoned_huge_page+0x131/0x1e0\n   CR2: 0000000000000058\n\nThe reasoning of this problem is shown below:\n - when we have a memory error on a thp tail page, the memory error\n   handler grabs a refcount of the head page to keep the thp under us.\n - Before unmapping the error page from processes, we split the thp,\n   where page refcounts of both of head/tail pages don't change.\n - Then we call try_to_unmap() over the error page (which was a tail\n   page before). We didn't pin the error page to handle the memory error,\n   this error page is freed and removed from LRU list.\n - We never have the error page on LRU list, so the first page state\n   check returns \"unknown page,\" then we move to the second check\n   with the saved page flag.\n - The saved page flag have PG_tail set, so the second page state check\n   returns \"hugepage.\"\n - We call me_huge_page() for freed error page, then we hit the above panic.\n\nThe root cause is that we didn't move refcount from the head page to the\ntail page after split thp.  So this patch suggests to do this.\n\nThis panic was introduced by commit 524fca1e73 (\"HWPOISON: fix\nmisjudgement of page_action() for errors on mlocked pages\").  Note that we\ndid have the same refcount problem before this commit, but it was just\nignored because we had only first page state check which returned \"unknown\npage.\" The commit changed the refcount problem from \"doesn't work\" to\n\"kernel panic.\"\n\nSigned-off-by: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>\nReviewed-by: Wanpeng Li <liwanp@linux.vnet.ibm.com>\nCc: Andi Kleen <andi@firstfloor.org>\nCc: <stable@vger.kernel.org>\t[3.9+]\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/memory-failure.c||mm/memory-failure.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "mm/memory-failure.c||mm/memory-failure.c": [
          "File: mm/memory-failure.c -> mm/memory-failure.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "938:     BUG_ON(!PageHWPoison(p));",
          "939:     return SWAP_FAIL;",
          "940:    }",
          "942:    ppage = p;",
          "943:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "947:    if (hpage != p) {",
          "948:     put_page(hpage);",
          "949:     get_page(p);",
          "950:    }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "98a947abdd54e5de909bebadfced1696ccad30cf",
      "candidate_info": {
        "commit_hash": "98a947abdd54e5de909bebadfced1696ccad30cf",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/98a947abdd54e5de909bebadfced1696ccad30cf",
        "files": [
          "drivers/cpufreq/intel_pstate.c"
        ],
        "message": "intel_pstate: Fail initialization if P-state information is missing\n\nIf pstate.current_pstate is 0 after the initial\nintel_pstate_get_cpu_pstates(), this means that we were unable to\nobtain any useful P-state information and there is no reason to\ncontinue, so free memory and return an error in that case.\n\nThis fixes the following divide error occuring in a nested KVM\nguest:\n\nIntel P-state driver initializing.\nIntel pstate controlling: cpu 0\ncpufreq: __cpufreq_add_dev: ->get() failed\ndivide error: 0000 [#1] SMP\nModules linked in:\nCPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.13.0-0.rc4.git5.1.fc21.x86_64 #1\nHardware name: Bochs Bochs, BIOS Bochs 01/01/2011\ntask: ffff88001ea20000 ti: ffff88001e9bc000 task.ti: ffff88001e9bc000\nRIP: 0010:[<ffffffff815c551d>]  [<ffffffff815c551d>] intel_pstate_timer_func+0x11d/0x2b0\nRSP: 0000:ffff88001ee03e18  EFLAGS: 00010246\nRAX: 0000000000000000 RBX: ffff88001a454348 RCX: 0000000000006100\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000\nRBP: ffff88001ee03e38 R08: 0000000000000000 R09: 0000000000000000\nR10: ffff88001ea20000 R11: 0000000000000000 R12: 00000c0a1ea20000\nR13: 1ea200001ea20000 R14: ffffffff815c5400 R15: ffff88001a454348\nFS:  0000000000000000(0000) GS:ffff88001ee00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\nCR2: 0000000000000000 CR3: 0000000001c0c000 CR4: 00000000000006f0\nStack:\n fffffffb1a454390 ffffffff821a4500 ffff88001a454390 0000000000000100\n ffff88001ee03ea8 ffffffff81083e9a ffffffff81083e15 ffffffff82d5ed40\n ffffffff8258cc60 0000000000000000 ffffffff81ac39de 0000000000000000\nCall Trace:\n <IRQ>\n [<ffffffff81083e9a>] call_timer_fn+0x8a/0x310\n [<ffffffff81083e15>] ? call_timer_fn+0x5/0x310\n [<ffffffff815c5400>] ? pid_param_set+0x130/0x130\n [<ffffffff81084354>] run_timer_softirq+0x234/0x380\n [<ffffffff8107aee4>] __do_softirq+0x104/0x430\n [<ffffffff8107b5fd>] irq_exit+0xcd/0xe0\n [<ffffffff81770645>] smp_apic_timer_interrupt+0x45/0x60\n [<ffffffff8176efb2>] apic_timer_interrupt+0x72/0x80\n <EOI>\n [<ffffffff810e15cd>] ? vprintk_emit+0x1dd/0x5e0\n [<ffffffff81757719>] printk+0x67/0x69\n [<ffffffff815c1493>] __cpufreq_add_dev.isra.13+0x883/0x8d0\n [<ffffffff815c14f0>] cpufreq_add_dev+0x10/0x20\n [<ffffffff814a14d1>] subsys_interface_register+0xb1/0xf0\n [<ffffffff815bf5cf>] cpufreq_register_driver+0x9f/0x210\n [<ffffffff81fb19af>] intel_pstate_init+0x27d/0x3be\n [<ffffffff81761e3e>] ? mutex_unlock+0xe/0x10\n [<ffffffff81fb1732>] ? cpufreq_gov_dbs_init+0x12/0x12\n [<ffffffff8100214a>] do_one_initcall+0xfa/0x1b0\n [<ffffffff8109dbf5>] ? parse_args+0x225/0x3f0\n [<ffffffff81f64193>] kernel_init_freeable+0x1fc/0x287\n [<ffffffff81f638d0>] ? do_early_param+0x88/0x88\n [<ffffffff8174b530>] ? rest_init+0x150/0x150\n [<ffffffff8174b53e>] kernel_init+0xe/0x130\n [<ffffffff8176e27c>] ret_from_fork+0x7c/0xb0\n [<ffffffff8174b530>] ? rest_init+0x150/0x150\nCode: c1 e0 05 48 63 bc 03 10 01 00 00 48 63 83 d0 00 00 00 48 63 d6 48 c1 e2 08 c1 e1 08 4c 63 c2 48 c1 e0 08 48 98 48 c1 e0 08 48 99 <49> f7 f8 48 98 48 0f af f8 48 c1 ff 08 29 f9 89 ca c1 fa 1f 89\nRIP  [<ffffffff815c551d>] intel_pstate_timer_func+0x11d/0x2b0\n RSP <ffff88001ee03e18>\n---[ end trace f166110ed22cc37a ]---\nKernel panic - not syncing: Fatal exception in interrupt\n\nReported-and-tested-by: Kashyap Chamarthy <kchamart@redhat.com>\nCc: Josh Boyer <jwboyer@fedoraproject.org>\nSigned-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>\nCc: All applicable <stable@vger.kernel.org>",
        "before_after_code_files": [
          "drivers/cpufreq/intel_pstate.c||drivers/cpufreq/intel_pstate.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/cpufreq/intel_pstate.c||drivers/cpufreq/intel_pstate.c": [
          "File: drivers/cpufreq/intel_pstate.c -> drivers/cpufreq/intel_pstate.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "614:  cpu = all_cpu_data[cpunum];",
          "616:  intel_pstate_get_cpu_pstates(cpu);",
          "618:  cpu->cpu = cpunum;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "617:  if (!cpu->pstate.current_pstate) {",
          "618:   all_cpu_data[cpunum] = NULL;",
          "619:   kfree(cpu);",
          "620:   return -ENODATA;",
          "621:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d2012975619251bdfeb7a5159faa7727ea9cddd3",
      "candidate_info": {
        "commit_hash": "d2012975619251bdfeb7a5159faa7727ea9cddd3",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d2012975619251bdfeb7a5159faa7727ea9cddd3",
        "files": [
          "net/netfilter/nf_tables_api.c"
        ],
        "message": "netfilter: nf_tables: fix oops when updating table with user chains\n\nThis patch fixes a crash while trying to deactivate a table that\ncontains user chains. You can reproduce it via:\n\n% nft add table table1\n% nft add chain table1 chain1\n% nft-table-upd ip table1 dormant\n\n[  253.021026] BUG: unable to handle kernel NULL pointer dereference at 0000000000000030\n[  253.021114] IP: [<ffffffff8134cebd>] nf_register_hook+0x35/0x6f\n[  253.021167] PGD 30fa5067 PUD 30fa2067 PMD 0\n[  253.021208] Oops: 0000 [#1] SMP\n[...]\n[  253.023305] Call Trace:\n[  253.023331]  [<ffffffffa0885020>] nf_tables_newtable+0x11c/0x258 [nf_tables]\n[  253.023385]  [<ffffffffa0878592>] nfnetlink_rcv_msg+0x1f4/0x226 [nfnetlink]\n[  253.023438]  [<ffffffffa0878418>] ? nfnetlink_rcv_msg+0x7a/0x226 [nfnetlink]\n[  253.023491]  [<ffffffffa087839e>] ? nfnetlink_bind+0x45/0x45 [nfnetlink]\n[  253.023542]  [<ffffffff8134b47e>] netlink_rcv_skb+0x3c/0x88\n[  253.023586]  [<ffffffffa0878973>] nfnetlink_rcv+0x3af/0x3e4 [nfnetlink]\n[  253.023638]  [<ffffffff813fb0d4>] ? _raw_read_unlock+0x22/0x34\n[  253.023683]  [<ffffffff8134af17>] netlink_unicast+0xe2/0x161\n[  253.023727]  [<ffffffff8134b29a>] netlink_sendmsg+0x304/0x332\n[  253.023773]  [<ffffffff8130d250>] __sock_sendmsg_nosec+0x25/0x27\n[  253.023820]  [<ffffffff8130fb93>] sock_sendmsg+0x5a/0x7b\n[  253.023861]  [<ffffffff8130d5d5>] ? copy_from_user+0x2a/0x2c\n[  253.023905]  [<ffffffff8131066f>] ? move_addr_to_kernel+0x35/0x60\n[  253.023952]  [<ffffffff813107b3>] SYSC_sendto+0x119/0x15c\n[  253.023995]  [<ffffffff81401107>] ? sysret_check+0x1b/0x56\n[  253.024039]  [<ffffffff8108dc30>] ? trace_hardirqs_on_caller+0x140/0x1db\n[  253.024090]  [<ffffffff8120164e>] ? trace_hardirqs_on_thunk+0x3a/0x3f\n[  253.024141]  [<ffffffff81310caf>] SyS_sendto+0x9/0xb\n[  253.026219]  [<ffffffff814010e2>] system_call_fastpath+0x16/0x1b\n\nReported-by: Alex Wei <alex.kern.mentor@gmail.com>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",
        "before_after_code_files": [
          "net/netfilter/nf_tables_api.c||net/netfilter/nf_tables_api.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/netfilter/nf_tables_api.c||net/netfilter/nf_tables_api.c": [
          "File: net/netfilter/nf_tables_api.c -> net/netfilter/nf_tables_api.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "312:  int err, i = 0;",
          "314:  list_for_each_entry(chain, &table->chains, list) {",
          "315:   err = nf_register_hook(&nft_base_chain(chain)->ops);",
          "316:   if (err < 0)",
          "317:    goto err;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "315:   if (!(chain->flags & NFT_BASE_CHAIN))",
          "316:    continue;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "321:  return 0;",
          "322: err:",
          "323:  list_for_each_entry(chain, &table->chains, list) {",
          "324:   if (i-- <= 0)",
          "325:    break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "327:   if (!(chain->flags & NFT_BASE_CHAIN))",
          "328:    continue;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "333: {",
          "334:  struct nft_chain *chain;",
          "339:  return 0;",
          "340: }",
          "",
          "[Removed Lines]",
          "336:  list_for_each_entry(chain, &table->chains, list)",
          "337:   nf_unregister_hook(&nft_base_chain(chain)->ops);",
          "",
          "[Added Lines]",
          "342:  list_for_each_entry(chain, &table->chains, list) {",
          "343:   if (chain->flags & NFT_BASE_CHAIN)",
          "344:    nf_unregister_hook(&nft_base_chain(chain)->ops);",
          "345:  }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
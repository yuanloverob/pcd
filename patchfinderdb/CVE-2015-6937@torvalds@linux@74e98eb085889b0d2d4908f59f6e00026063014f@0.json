{
  "cve_id": "CVE-2015-6937",
  "cve_desc": "The __rds_conn_create function in net/rds/connection.c in the Linux kernel through 4.2.3 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by using a socket that was not properly bound.",
  "repo": "torvalds/linux",
  "patch_hash": "74e98eb085889b0d2d4908f59f6e00026063014f",
  "patch_info": {
    "commit_hash": "74e98eb085889b0d2d4908f59f6e00026063014f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/74e98eb085889b0d2d4908f59f6e00026063014f",
    "files": [
      "net/rds/connection.c"
    ],
    "message": "RDS: verify the underlying transport exists before creating a connection\n\nThere was no verification that an underlying transport exists when creating\na connection, this would cause dereferencing a NULL ptr.\n\nIt might happen on sockets that weren't properly bound before attempting to\nsend a message, which will cause a NULL ptr deref:\n\n[135546.047719] kasan: GPF could be caused by NULL-ptr deref or user memory accessgeneral protection fault: 0000 [#1] PREEMPT SMP DEBUG_PAGEALLOC KASAN\n[135546.051270] Modules linked in:\n[135546.051781] CPU: 4 PID: 15650 Comm: trinity-c4 Not tainted 4.2.0-next-20150902-sasha-00041-gbaa1222-dirty #2527\n[135546.053217] task: ffff8800835bc000 ti: ffff8800bc708000 task.ti: ffff8800bc708000\n[135546.054291] RIP: __rds_conn_create (net/rds/connection.c:194)\n[135546.055666] RSP: 0018:ffff8800bc70fab0  EFLAGS: 00010202\n[135546.056457] RAX: dffffc0000000000 RBX: 0000000000000f2c RCX: ffff8800835bc000\n[135546.057494] RDX: 0000000000000007 RSI: ffff8800835bccd8 RDI: 0000000000000038\n[135546.058530] RBP: ffff8800bc70fb18 R08: 0000000000000001 R09: 0000000000000000\n[135546.059556] R10: ffffed014d7a3a23 R11: ffffed014d7a3a21 R12: 0000000000000000\n[135546.060614] R13: 0000000000000001 R14: ffff8801ec3d0000 R15: 0000000000000000\n[135546.061668] FS:  00007faad4ffb700(0000) GS:ffff880252000000(0000) knlGS:0000000000000000\n[135546.062836] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\n[135546.063682] CR2: 000000000000846a CR3: 000000009d137000 CR4: 00000000000006a0\n[135546.064723] Stack:\n[135546.065048]  ffffffffafe2055c ffffffffafe23fc1 ffffed00493097bf ffff8801ec3d0008\n[135546.066247]  0000000000000000 00000000000000d0 0000000000000000 ac194a24c0586342\n[135546.067438]  1ffff100178e1f78 ffff880320581b00 ffff8800bc70fdd0 ffff880320581b00\n[135546.068629] Call Trace:\n[135546.069028] ? __rds_conn_create (include/linux/rcupdate.h:856 net/rds/connection.c:134)\n[135546.069989] ? rds_message_copy_from_user (net/rds/message.c:298)\n[135546.071021] rds_conn_create_outgoing (net/rds/connection.c:278)\n[135546.071981] rds_sendmsg (net/rds/send.c:1058)\n[135546.072858] ? perf_trace_lock (include/trace/events/lock.h:38)\n[135546.073744] ? lockdep_init (kernel/locking/lockdep.c:3298)\n[135546.074577] ? rds_send_drop_to (net/rds/send.c:976)\n[135546.075508] ? __might_fault (./arch/x86/include/asm/current.h:14 mm/memory.c:3795)\n[135546.076349] ? __might_fault (mm/memory.c:3795)\n[135546.077179] ? rds_send_drop_to (net/rds/send.c:976)\n[135546.078114] sock_sendmsg (net/socket.c:611 net/socket.c:620)\n[135546.078856] SYSC_sendto (net/socket.c:1657)\n[135546.079596] ? SYSC_connect (net/socket.c:1628)\n[135546.080510] ? trace_dump_stack (kernel/trace/trace.c:1926)\n[135546.081397] ? ring_buffer_unlock_commit (kernel/trace/ring_buffer.c:2479 kernel/trace/ring_buffer.c:2558 kernel/trace/ring_buffer.c:2674)\n[135546.082390] ? trace_buffer_unlock_commit (kernel/trace/trace.c:1749)\n[135546.083410] ? trace_event_raw_event_sys_enter (include/trace/events/syscalls.h:16)\n[135546.084481] ? do_audit_syscall_entry (include/trace/events/syscalls.h:16)\n[135546.085438] ? trace_buffer_unlock_commit (kernel/trace/trace.c:1749)\n[135546.085515] rds_ib_laddr_check(): addr 36.74.25.172 ret -99 node type -1\n\nAcked-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>\nSigned-off-by: Sasha Levin <sasha.levin@oracle.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/rds/connection.c||net/rds/connection.c"
    ]
  },
  "patch_diff": {
    "net/rds/connection.c||net/rds/connection.c": [
      "File: net/rds/connection.c -> net/rds/connection.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "190:   }",
      "191:  }",
      "193:  conn->c_trans = trans;",
      "195:  ret = trans->conn_alloc(conn, gfp);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "193:  if (trans == NULL) {",
      "194:   kmem_cache_free(rds_conn_slab, conn);",
      "195:   conn = ERR_PTR(-ENODEV);",
      "196:   goto out;",
      "197:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a4a5a7379e4ca03c192b732d61e446994eb67bbc",
      "candidate_info": {
        "commit_hash": "a4a5a7379e4ca03c192b732d61e446994eb67bbc",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/a4a5a7379e4ca03c192b732d61e446994eb67bbc",
        "files": [
          "arch/arm/include/asm/bug.h"
        ],
        "message": "ARM: 8431/1: fix alignement of __bug_table section entries\n\nOn old ARM chips, unaligned accesses to memory are not trapped and\nfixed.  On module load, symbols are relocated, and the relocation of\n__bug_table symbols is done on a u32 basis. Yet the section is not\naligned to a multiple of 4 address, but to a multiple of 2.\n\nThis triggers an Oops on pxa architecture, where address 0xbf0021ea\nis the first relocation in the __bug_table section :\n  apply_relocate(): pxa3xx_nand: section 13 reloc 0 sym ''\n  Unable to handle kernel paging request at virtual address bf0021ea\n  pgd = e1cd0000\n  [bf0021ea] *pgd=c1cce851, *pte=c1cde04f, *ppte=c1cde01f\n  Internal error: Oops: 23 [#1] ARM\n  Modules linked in:\n  CPU: 0 PID: 606 Comm: insmod Not tainted 4.2.0-rc8-next-20150828-cm-x300+ #887\n  Hardware name: CM-X300 module\n  task: e1c68700 ti: e1c3e000 task.ti: e1c3e000\n  PC is at apply_relocate+0x2f4/0x3d4\n  LR is at 0xbf0021ea\n  pc : [<c000e7c8>]    lr : [<bf0021ea>]    psr: 80000013\n  sp : e1c3fe30  ip : 60000013  fp : e49e8c60\n  r10: e49e8fa8  r9 : 00000000  r8 : e49e7c58\n  r7 : e49e8c38  r6 : e49e8a58  r5 : e49e8920  r4 : e49e8918\n  r3 : bf0021ea  r2 : bf007034  r1 : 00000000  r0 : bf000000\n  Flags: Nzcv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none\n  Control: 0000397f  Table: c1cd0018  DAC: 00000051\n  Process insmod (pid: 606, stack limit = 0xe1c3e198)\n  [<c000e7c8>] (apply_relocate) from [<c005ce5c>] (load_module+0x1248/0x1f5c)\n  [<c005ce5c>] (load_module) from [<c005dc54>] (SyS_init_module+0xe4/0x170)\n  [<c005dc54>] (SyS_init_module) from [<c000a420>] (ret_fast_syscall+0x0/0x38)\n\nFix this by ensuring entries in __bug_table are all aligned to at least\nof multiple of 4. This transforms a module section  __bug_table as :\n-   [12] __bug_table       PROGBITS        00000000 002232 000018 00   A  0   0  1\n+   [12] __bug_table       PROGBITS        00000000 002232 000018 00   A  0   0  4\n\nSigned-off-by: Robert Jarzmik <robert.jarzmik@free.fr>\nReviewed-by: Dave Martin <Dave.Martin@arm.com>\nSigned-off-by: Russell King <rmk+kernel@arm.linux.org.uk>",
        "before_after_code_files": [
          "arch/arm/include/asm/bug.h||arch/arm/include/asm/bug.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/arm/include/asm/bug.h||arch/arm/include/asm/bug.h": [
          "File: arch/arm/include/asm/bug.h -> arch/arm/include/asm/bug.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "40:   \"2:\\t.asciz \" #__file \"\\n\"    \\",
          "41:   \".popsection\\n\"     \\",
          "42:   \".pushsection __bug_table,\\\"a\\\"\\n\"  \\",
          "43:   \"3:\\t.word 1b, 2b\\n\"    \\",
          "44:   \"\\t.hword \" #__line \", 0\\n\"   \\",
          "45:   \".popsection\");     \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "43:   \".align 2\\n\"     \\",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3d46a44a0c01b15d385ccaae24b56f619613c256",
      "candidate_info": {
        "commit_hash": "3d46a44a0c01b15d385ccaae24b56f619613c256",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3d46a44a0c01b15d385ccaae24b56f619613c256",
        "files": [
          "fs/ocfs2/file.c"
        ],
        "message": "ocfs2: fix BUG_ON() in ocfs2_ci_checkpointed()\n\nPID: 614    TASK: ffff882a739da580  CPU: 3   COMMAND: \"ocfs2dc\"\n  #0 [ffff882ecc3759b0] machine_kexec at ffffffff8103b35d\n  #1 [ffff882ecc375a20] crash_kexec at ffffffff810b95b5\n  #2 [ffff882ecc375af0] oops_end at ffffffff815091d8\n  #3 [ffff882ecc375b20] die at ffffffff8101868b\n  #4 [ffff882ecc375b50] do_trap at ffffffff81508bb0\n  #5 [ffff882ecc375ba0] do_invalid_op at ffffffff810165e5\n  #6 [ffff882ecc375c40] invalid_op at ffffffff815116fb\n     [exception RIP: ocfs2_ci_checkpointed+208]\n     RIP: ffffffffa0a7e940  RSP: ffff882ecc375cf0  RFLAGS: 00010002\n     RAX: 0000000000000001  RBX: 000000000000654b  RCX: ffff8812dc83f1f8\n     RDX: 00000000000017d9  RSI: ffff8812dc83f1f8  RDI: ffffffffa0b2c318\n     RBP: ffff882ecc375d20   R8: ffff882ef6ecfa60   R9: ffff88301f272200\n     R10: 0000000000000000  R11: 0000000000000000  R12: ffffffffffffffff\n     R13: ffff8812dc83f4f0  R14: 0000000000000000  R15: ffff8812dc83f1f8\n     ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018\n  #7 [ffff882ecc375d28] ocfs2_check_meta_downconvert at ffffffffa0a7edbd [ocfs2]\n  #8 [ffff882ecc375d38] ocfs2_unblock_lock at ffffffffa0a84af8 [ocfs2]\n  #9 [ffff882ecc375dc8] ocfs2_process_blocked_lock at ffffffffa0a85285 [ocfs2]\n#10 [ffff882ecc375e18] ocfs2_downconvert_thread_do_work at ffffffffa0a85445 [ocfs2]\n#11 [ffff882ecc375e68] ocfs2_downconvert_thread at ffffffffa0a854de [ocfs2]\n#12 [ffff882ecc375ee8] kthread at ffffffff81090da7\n#13 [ffff882ecc375f48] kernel_thread_helper at ffffffff81511884\nassert is tripped because the tran is not checkpointed and the lock level is PR.\n\nSome time ago, chmod command had been executed. As result, the following call\nchain left the inode cluster lock in PR state, latter on causing the assert.\nsystem_call_fastpath\n  -> my_chmod\n   -> sys_chmod\n    -> sys_fchmodat\n     -> notify_change\n      -> ocfs2_setattr\n       -> posix_acl_chmod\n        -> ocfs2_iop_set_acl\n         -> ocfs2_set_acl\n          -> ocfs2_acl_set_mode\nHere is how.\n1119 int ocfs2_setattr(struct dentry *dentry, struct iattr *attr)\n1120 {\n1247         ocfs2_inode_unlock(inode, 1); <<< WRONG thing to do.\n..\n1258         if (!status && attr->ia_valid & ATTR_MODE) {\n1259                 status =  posix_acl_chmod(inode, inode->i_mode);\n\n519 posix_acl_chmod(struct inode *inode, umode_t mode)\n520 {\n..\n539         ret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\n287 int ocfs2_iop_set_acl(struct inode *inode, struct posix_acl *acl, ...\n288 {\n289         return ocfs2_set_acl(NULL, inode, NULL, type, acl, NULL, NULL);\n\n224 int ocfs2_set_acl(handle_t *handle,\n225                          struct inode *inode, ...\n231 {\n..\n252                                 ret = ocfs2_acl_set_mode(inode, di_bh,\n253                                                          handle, mode);\n\n168 static int ocfs2_acl_set_mode(struct inode *inode, struct buffer_head ...\n170 {\n183         if (handle == NULL) {\n                    >>> BUG: inode lock not held in ex at this point <<<\n184                 handle = ocfs2_start_trans(OCFS2_SB(inode->i_sb),\n185                                            OCFS2_INODE_UPDATE_CREDITS);\n\nocfs2_setattr.#1247 we unlock and at #1259 call posix_acl_chmod. When we reach\nocfs2_acl_set_mode.#181 and do trans, the inode cluster lock is not held in EX\nmode (it should be). How this could have happended?\n\nWe are the lock master, were holding lock EX and have released it in\nocfs2_setattr.#1247.  Note that there are no holders of this lock at\nthis point.  Another node needs the lock in PR, and we downconvert from\nEX to PR.  So the inode lock is PR when do the trans in\nocfs2_acl_set_mode.#184.  The trans stays in core (not flushed to disc).\nNow another node want the lock in EX, downconvert thread gets kicked\n(the one that tripped assert abovt), finds an unflushed trans but the\nlock is not EX (it is PR).  If the lock was at EX, it would have flushed\nthe trans ocfs2_ci_checkpointed -> ocfs2_start_checkpoint before\ndownconverting (to NULL) for the request.\n\nocfs2_setattr must not drop inode lock ex in this code path.  If it\ndoes, takes it again before the trans, say in ocfs2_set_acl, another\ncluster node can get in between, execute another setattr, overwriting\nthe one in progress on this node, resulting in a mode acl size combo\nthat is a mix of the two.\n\nOrabug: 20189959\nSigned-off-by: Tariq Saeed <tariq.x.saeed@oracle.com>\nReviewed-by: Mark Fasheh <mfasheh@suse.de>\nCc: Joel Becker <jlbec@evilplan.org>\nCc: Joseph Qi <joseph.qi@huawei.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/ocfs2/file.c||fs/ocfs2/file.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/ocfs2/file.c||fs/ocfs2/file.c": [
          "File: fs/ocfs2/file.c -> fs/ocfs2/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1130: int ocfs2_setattr(struct dentry *dentry, struct iattr *attr)",
          "1131: {",
          "1132:  int status = 0, size_change;",
          "1133:  struct inode *inode = d_inode(dentry);",
          "1134:  struct super_block *sb = inode->i_sb;",
          "1135:  struct ocfs2_super *osb = OCFS2_SB(sb);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1133:  int inode_locked = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1178:    mlog_errno(status);",
          "1179:   goto bail_unlock_rw;",
          "1180:  }",
          "1182:  if (size_change) {",
          "1183:   status = inode_newsize_ok(inode, attr->ia_size);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1182:  inode_locked = 1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1258: bail_commit:",
          "1259:  ocfs2_commit_trans(osb, handle);",
          "1260: bail_unlock:",
          "1262: bail_unlock_rw:",
          "1263:  if (size_change)",
          "1264:   ocfs2_rw_unlock(inode, 1);",
          "",
          "[Removed Lines]",
          "1261:  ocfs2_inode_unlock(inode, 1);",
          "",
          "[Added Lines]",
          "1263:  if (status) {",
          "1264:   ocfs2_inode_unlock(inode, 1);",
          "1265:   inode_locked = 0;",
          "1266:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1274:   if (status < 0)",
          "1275:    mlog_errno(status);",
          "1276:  }",
          "1278:  return status;",
          "1279: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1282:  if (inode_locked)",
          "1283:   ocfs2_inode_unlock(inode, 1);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7fbc67df2cd6d0b72fd5d6d3acaa79ab6f5b0224",
      "candidate_info": {
        "commit_hash": "7fbc67df2cd6d0b72fd5d6d3acaa79ab6f5b0224",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7fbc67df2cd6d0b72fd5d6d3acaa79ab6f5b0224",
        "files": [
          "drivers/infiniband/ulp/srp/ib_srp.c"
        ],
        "message": "IB/srp: Fix possible protection fault\n\nsrp_destroy_qp is designed to indicate we are safe to continue with\nfreeing the channel resources by modifying the qp error state,\nposting a dummy wr on the queue-pair and waiting for it to flush.\nThis also holds for the channel registration pool as we are unmapping\nthe memory region when handling a scsi response. Destroying the\nchannel registration pool before we make sure we processed all the\ninflight IO might introduce a use-after-free of the registration pool.\n\nThis use-after-free is demonstrated in the stack trace below where\nsrp is trying to unmap a used FMR after the fmr_pool was already destroyed.\n\ngeneral protection fault: 0000 [#1] SMP\nRIP: 0010:[<ffffffff8151121b>]  [<ffffffff8151121b>] _raw_spin_lock_irqsave+0x1b/0x50\nCall Trace:\n [<ffffffffa055d88a>] ib_fmr_pool_unmap+0x1a/0xb0 [ib_core]\n [<ffffffffa06c00ed>] srp_unmap_data.isra.28+0x17d/0x250 [ib_srp]\n [<ffffffffa06c01eb>] srp_free_req+0x2b/0x60 [ib_srp]\n [<ffffffffa06c0c94>] srp_recv_completion+0x174/0x580 [ib_srp]\n [<ffffffffa04580fe>] mlx4_eq_int+0x4de/0xe50 [mlx4_core]\n [<ffffffffa0458b00>] mlx4_msi_x_interrupt+0x10/0x20 [mlx4_core]\n [<ffffffff810abc45>] handle_irq_event_percpu+0x35/0x1b0\n [<ffffffff810abdf2>] handle_irq_event+0x32/0x50\n [<ffffffff810ae5cf>] handle_edge_irq+0x6f/0x120\n [<ffffffff8100455a>] handle_irq+0x1a/0x30\n [<ffffffff8151b475>] do_IRQ+0x45/0xb0\n [<ffffffff8151162d>] common_interrupt+0x6d/0x6d\n [<ffffffff813e4d2f>] cpuidle_enter_state+0x4f/0xc0\n [<ffffffff813e4e6c>] cpuidle_idle_call+0xcc/0x210\n [<ffffffff8100b9ea>] arch_cpu_idle+0xa/0x30\n [<ffffffff810ab1e1>] cpu_startup_entry+0xe1/0x270\n [<ffffffff81030b3a>] start_secondary+0x21a/0x2c0\n\nReported-by: Eliott Kespi <eliottk@mellanox.com>\nSigned-off-by: Sagi Grimberg <sagig@mellanox.com>\nSigned-off-by: Bart Van Assche <bart.vanassche@sandisk.com>\nSigned-off-by: Doug Ledford <dledford@redhat.com>",
        "before_after_code_files": [
          "drivers/infiniband/ulp/srp/ib_srp.c||drivers/infiniband/ulp/srp/ib_srp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/infiniband/ulp/srp/ib_srp.c||drivers/infiniband/ulp/srp/ib_srp.c": [
          "File: drivers/infiniband/ulp/srp/ib_srp.c -> drivers/infiniband/ulp/srp/ib_srp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "554:          \"FR pool allocation failed (%d)\\n\", ret);",
          "555:    goto err_qp;",
          "556:   }",
          "560:  } else if (dev->use_fmr) {",
          "561:   fmr_pool = srp_alloc_fmr_pool(target);",
          "562:   if (IS_ERR(fmr_pool)) {",
          "",
          "[Removed Lines]",
          "557:   if (ch->fr_pool)",
          "558:    srp_destroy_fr_pool(ch->fr_pool);",
          "559:   ch->fr_pool = fr_pool;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "565:          \"FMR pool allocation failed (%d)\\n\", ret);",
          "566:    goto err_qp;",
          "567:   }",
          "571:  }",
          "573:  if (ch->qp)",
          "",
          "[Removed Lines]",
          "568:   if (ch->fmr_pool)",
          "569:    ib_destroy_fmr_pool(ch->fmr_pool);",
          "570:   ch->fmr_pool = fmr_pool;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "581:  ch->recv_cq = recv_cq;",
          "582:  ch->send_cq = send_cq;",
          "584:  kfree(init_attr);",
          "585:  return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "578:  if (dev->use_fast_reg) {",
          "579:   if (ch->fr_pool)",
          "580:    srp_destroy_fr_pool(ch->fr_pool);",
          "581:   ch->fr_pool = fr_pool;",
          "582:  } else if (dev->use_fmr) {",
          "583:   if (ch->fmr_pool)",
          "584:    ib_destroy_fmr_pool(ch->fmr_pool);",
          "585:   ch->fmr_pool = fmr_pool;",
          "586:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "04697858d89e4bf2650364f8d6956e2554e8ef88",
      "candidate_info": {
        "commit_hash": "04697858d89e4bf2650364f8d6956e2554e8ef88",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/04697858d89e4bf2650364f8d6956e2554e8ef88",
        "files": [
          "drivers/base/node.c"
        ],
        "message": "mm: check if section present during memory block registering\n\nTony Luck found on his setup, if memory block size 512M will cause crash\nduring booting.\n\n  BUG: unable to handle kernel paging request at ffffea0074000020\n  IP: get_nid_for_pfn+0x17/0x40\n  PGD 128ffcb067 PUD 128ffc9067 PMD 0\n  Oops: 0000 [#1] SMP\n  Modules linked in:\n  CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.2.0-rc8 #1\n  ...\n  Call Trace:\n     ? register_mem_sect_under_node+0x66/0xe0\n     register_one_node+0x17b/0x240\n     ? pci_iommu_alloc+0x6e/0x6e\n     topology_init+0x3c/0x95\n     do_one_initcall+0xcd/0x1f0\n\nThe system has non continuous RAM address:\n BIOS-e820: [mem 0x0000001300000000-0x0000001cffffffff] usable\n BIOS-e820: [mem 0x0000001d70000000-0x0000001ec7ffefff] usable\n BIOS-e820: [mem 0x0000001f00000000-0x0000002bffffffff] usable\n BIOS-e820: [mem 0x0000002c18000000-0x0000002d6fffefff] usable\n BIOS-e820: [mem 0x0000002e00000000-0x00000039ffffffff] usable\n\nSo there are start sections in memory block not present.  For example:\n\n    memory block : [0x2c18000000, 0x2c20000000) 512M\n\nfirst three sections are not present.\n\nThe current register_mem_sect_under_node() assume first section is\npresent, but memory block section number range [start_section_nr,\nend_section_nr] would include not present section.\n\nFor arch that support vmemmap, we don't setup memmap for struct page\narea within not present sections area.\n\nSo skip the pfn range that belong to absent section.\n\n[akpm@linux-foundation.org: simplification]\n[rientjes@google.com: more simplification]\nFixes: bdee237c0343 (\"x86: mm: Use 2GB memory block size on large memory x86-64 systems\")\nFixes: 982792c782ef (\"x86, mm: probe memory block size for generic x86 64bit\")\nSigned-off-by: Yinghai Lu <yinghai@kernel.org>\nSigned-off-by: David Rientjes <rientjes@google.com>\nReported-by: Tony Luck <tony.luck@intel.com>\nTested-by: Tony Luck <tony.luck@intel.com>\nCc: Greg KH <greg@kroah.com>\nCc: Ingo Molnar <mingo@elte.hu>\nTested-by: David Rientjes <rientjes@google.com>\nCc: <stable@vger.kernel.org>\t[3.15+]\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "drivers/base/node.c||drivers/base/node.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/base/node.c||drivers/base/node.c": [
          "File: drivers/base/node.c -> drivers/base/node.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "392:  for (pfn = sect_start_pfn; pfn <= sect_end_pfn; pfn++) {",
          "393:   int page_nid;",
          "395:   page_nid = get_nid_for_pfn(pfn);",
          "396:   if (page_nid < 0)",
          "397:    continue;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "399:   if (!pfn_present(pfn)) {",
          "400:    pfn = round_down(pfn + PAGES_PER_SECTION,",
          "401:       PAGES_PER_SECTION) - 1;",
          "402:    continue;",
          "403:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2ff46e6fea6254ac8fa97aeb9c14e51436ab95f6",
      "candidate_info": {
        "commit_hash": "2ff46e6fea6254ac8fa97aeb9c14e51436ab95f6",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2ff46e6fea6254ac8fa97aeb9c14e51436ab95f6",
        "files": [
          "drivers/mtd/spi-nor/spi-nor.c"
        ],
        "message": "mtd: spi-nor: fix NULL dereference when no match found in spi_nor_ids[]\n\nCommit 06bb6f5a69df (\"mtd: spi-nor: stop (ab)using struct\nspi_device_id\") converted an array into a pointer, which means that\nwe should be checking if the pointer goes anywhere, not whether the C\nstring is empty. To do the latter means we dereference a NULL pointer\nwhen we reach the terminating entry, for which 'name' is now NULL\ninstead of an array { 0, 0, ... }.\n\nSample crash:\n\n[    1.101371] Unable to handle kernel NULL pointer dereference at virtual address 00000000\n[    1.109457] pgd = c0004000\n[    1.112157] [00000000] *pgd=00000000\n[    1.115736] Internal error: Oops: 5 [#1] SMP ARM\n[    1.120345] Modules linked in:\n[    1.123405] CPU: 3 PID: 1 Comm: swapper/0 Not tainted 4.2.0-next-20150902+ #61\n[    1.130611] Hardware name: Rockchip (Device Tree)\n[    1.135306] task: ee0b8d40 ti: ee0ba000 task.ti: ee0ba000\n[    1.140697] PC is at spi_nor_scan+0x90/0x8c4\n[    1.144958] LR is at spi_nor_scan+0xa4/0x8c4\n...\n[    1.504112] [<c03cc2e0>] (spi_nor_scan) from [<c03cb188>] (m25p_probe+0xc8/0x11c)\n[    1.511583] [<c03cb188>] (m25p_probe) from [<c03cd9d8>] (spi_drv_probe+0x60/0x7c)\n[    1.519055] [<c03cd9d8>] (spi_drv_probe) from [<c037faa0>] (driver_probe_device+0x1a0/0x444)\n[    1.527478] [<c037faa0>] (driver_probe_device) from [<c037fec8>] (__device_attach_driver+0x94/0xa0)\n[    1.536507] [<c037fec8>] (__device_attach_driver) from [<c037db3c>] (bus_for_each_drv+0x94/0xa4)\n[    1.545277] [<c037db3c>] (bus_for_each_drv) from [<c037f7e4>] (__device_attach+0xa4/0x144)\n[    1.553526] [<c037f7e4>] (__device_attach) from [<c0380058>] (device_initial_probe+0x1c/0x20)\n[    1.562035] [<c0380058>] (device_initial_probe) from [<c037ec88>] (bus_probe_device+0x38/0x94)\n[    1.570631] [<c037ec88>] (bus_probe_device) from [<c037ccf4>] (device_add+0x430/0x558)\n[    1.578534] [<c037ccf4>] (device_add) from [<c03d0240>] (spi_add_device+0xe4/0x174)\n[    1.586178] [<c03d0240>] (spi_add_device) from [<c03d0a24>] (spi_register_master+0x698/0x7d4)\n[    1.594688] [<c03d0a24>] (spi_register_master) from [<c03d0ba0>] (devm_spi_register_master+0x40/0x7c)\n[    1.603892] [<c03d0ba0>] (devm_spi_register_master) from [<c03d2fb4>] (rockchip_spi_probe+0x360/0x3f4)\n[    1.613182] [<c03d2fb4>] (rockchip_spi_probe) from [<c0381e34>] (platform_drv_probe+0x58/0xa8)\n[    1.621779] [<c0381e34>] (platform_drv_probe) from [<c037faa0>] (driver_probe_device+0x1a0/0x444)\n[    1.630635] [<c037faa0>] (driver_probe_device) from [<c037fdc4>] (__driver_attach+0x80/0xa4)\n[    1.639058] [<c037fdc4>] (__driver_attach) from [<c037e850>] (bus_for_each_dev+0x98/0xac)\n[    1.647221] [<c037e850>] (bus_for_each_dev) from [<c037f448>] (driver_attach+0x28/0x30)\n[    1.655210] [<c037f448>] (driver_attach) from [<c037ef74>] (bus_add_driver+0x128/0x250)\n[    1.663200] [<c037ef74>] (bus_add_driver) from [<c0380c40>] (driver_register+0xac/0xf0)\n[    1.671191] [<c0380c40>] (driver_register) from [<c0381d50>] (__platform_driver_register+0x58/0x6c)\n[    1.680221] [<c0381d50>] (__platform_driver_register) from [<c0a467c8>] (rockchip_spi_driver_init+0x18/0x20)\n[    1.690033] [<c0a467c8>] (rockchip_spi_driver_init) from [<c00098a4>] (do_one_initcall+0x124/0x1dc)\n[    1.699063] [<c00098a4>] (do_one_initcall) from [<c0a19f84>] (kernel_init_freeable+0x218/0x2ec)\n[    1.707748] [<c0a19f84>] (kernel_init_freeable) from [<c0719ed8>] (kernel_init+0x1c/0xf4)\n[    1.715912] [<c0719ed8>] (kernel_init) from [<c000fe50>] (ret_from_fork+0x14/0x24)\n[    1.723460] Code: e3510000 159f67c0 0a00000c e5961000 (e5d13000)\n[    1.729564] ---[ end trace 95baa6b3b861ce25 ]---\n\nFixes: 06bb6f5a69df (\"mtd: spi-nor: stop (ab)using struct spi_device_id\")\nSigned-off-by: Brian Norris <computersforpeace@gmail.com>\nCc: Rafa\u0142 Mi\u0142ecki <zajec5@gmail.com>",
        "before_after_code_files": [
          "drivers/mtd/spi-nor/spi-nor.c||drivers/mtd/spi-nor/spi-nor.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/mtd/spi-nor/spi-nor.c||drivers/mtd/spi-nor/spi-nor.c": [
          "File: drivers/mtd/spi-nor/spi-nor.c -> drivers/mtd/spi-nor/spi-nor.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1218: {",
          "1219:  const struct flash_info *id = spi_nor_ids;",
          "1222:   if (!strcmp(name, id->name))",
          "1223:    return id;",
          "1224:   id++;",
          "",
          "[Removed Lines]",
          "1221:  while (id->name[0]) {",
          "",
          "[Added Lines]",
          "1221:  while (id->name) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-7423",
  "cve_desc": "The mptsas_process_scsi_io_request function in QEMU (aka Quick Emulator), when built with LSI SAS1068 Host Bus emulation support, allows local guest OS administrators to cause a denial of service (out-of-bounds write and QEMU process crash) via vectors involving MPTSASRequest objects.",
  "repo": "qemu/qemu",
  "patch_hash": "670e56d3ed2918b3861d9216f2c0540d9e9ae0d5",
  "patch_info": {
    "commit_hash": "670e56d3ed2918b3861d9216f2c0540d9e9ae0d5",
    "repo": "qemu/qemu",
    "commit_url": "https://github.com/qemu/qemu/commit/670e56d3ed2918b3861d9216f2c0540d9e9ae0d5",
    "files": [
      "hw/scsi/mptsas.c"
    ],
    "message": "scsi: mptsas: use g_new0 to allocate MPTSASRequest object\n\nWhen processing IO request in mptsas, it uses g_new to allocate\na 'req' object. If an error occurs before 'req->sreq' is\nallocated, It could lead to an OOB write in mptsas_free_request\nfunction. Use g_new0 to avoid it.\n\nReported-by: Li Qiang <liqiang6-s@360.cn>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nMessage-Id: <1473684251-17476-1-git-send-email-ppandit@redhat.com>\nCc: qemu-stable@nongnu.org\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
    "before_after_code_files": [
      "hw/scsi/mptsas.c||hw/scsi/mptsas.c"
    ]
  },
  "patch_diff": {
    "hw/scsi/mptsas.c||hw/scsi/mptsas.c": [
      "File: hw/scsi/mptsas.c -> hw/scsi/mptsas.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "304:         goto bad;",
      "305:     }",
      "308:     QTAILQ_INSERT_TAIL(&s->pending, req, next);",
      "309:     req->scsi_io = *scsi_io;",
      "310:     req->dev = s;",
      "",
      "[Removed Lines]",
      "307:     req = g_new(MPTSASRequest, 1);",
      "",
      "[Added Lines]",
      "307:     req = g_new0(MPTSASRequest, 1);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c6a7b922f8ab4af286da90124b1669e9b553e957",
      "candidate_info": {
        "commit_hash": "c6a7b922f8ab4af286da90124b1669e9b553e957",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/c6a7b922f8ab4af286da90124b1669e9b553e957",
        "files": [
          "hw/scsi/mptsas.c"
        ],
        "message": "scsi: mptsas: use g_new0 to allocate MPTSASRequest object\n\nWhen processing IO request in mptsas, it uses g_new to allocate\na 'req' object. If an error occurs before 'req->sreq' is\nallocated, It could lead to an OOB write in mptsas_free_request\nfunction. Use g_new0 to avoid it.\n\nReported-by: Li Qiang <liqiang6-s@360.cn>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nMessage-Id: <1473684251-17476-1-git-send-email-ppandit@redhat.com>\nCc: qemu-stable@nongnu.org\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n(cherry picked from commit 670e56d3ed2918b3861d9216f2c0540d9e9ae0d5)\nSigned-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>",
        "before_after_code_files": [
          "hw/scsi/mptsas.c||hw/scsi/mptsas.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "hw/scsi/mptsas.c||hw/scsi/mptsas.c"
          ],
          "candidate": [
            "hw/scsi/mptsas.c||hw/scsi/mptsas.c"
          ]
        }
      },
      "candidate_diff": {
        "hw/scsi/mptsas.c||hw/scsi/mptsas.c": [
          "File: hw/scsi/mptsas.c -> hw/scsi/mptsas.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "304:         goto bad;",
          "305:     }",
          "308:     QTAILQ_INSERT_TAIL(&s->pending, req, next);",
          "309:     req->scsi_io = *scsi_io;",
          "310:     req->dev = s;",
          "",
          "[Removed Lines]",
          "307:     req = g_new(MPTSASRequest, 1);",
          "",
          "[Added Lines]",
          "307:     req = g_new0(MPTSASRequest, 1);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "12be5cfe1cfe22829e06270d70a15c477f0d1712",
      "candidate_info": {
        "commit_hash": "12be5cfe1cfe22829e06270d70a15c477f0d1712",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/12be5cfe1cfe22829e06270d70a15c477f0d1712",
        "files": [
          "hw/scsi/mptsas.c"
        ],
        "message": "scsi: mptsas: use g_new0 to allocate MPTSASRequest object\n\nWhen processing IO request in mptsas, it uses g_new to allocate\na 'req' object. If an error occurs before 'req->sreq' is\nallocated, It could lead to an OOB write in mptsas_free_request\nfunction. Use g_new0 to avoid it.\n\nReported-by: Li Qiang <liqiang6-s@360.cn>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nMessage-Id: <1473684251-17476-1-git-send-email-ppandit@redhat.com>\nCc: qemu-stable@nongnu.org\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n(cherry picked from commit 670e56d3ed2918b3861d9216f2c0540d9e9ae0d5)\nSigned-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>",
        "before_after_code_files": [
          "hw/scsi/mptsas.c||hw/scsi/mptsas.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "hw/scsi/mptsas.c||hw/scsi/mptsas.c"
          ],
          "candidate": [
            "hw/scsi/mptsas.c||hw/scsi/mptsas.c"
          ]
        }
      },
      "candidate_diff": {
        "hw/scsi/mptsas.c||hw/scsi/mptsas.c": [
          "File: hw/scsi/mptsas.c -> hw/scsi/mptsas.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "304:         goto bad;",
          "305:     }",
          "308:     QTAILQ_INSERT_TAIL(&s->pending, req, next);",
          "309:     req->scsi_io = *scsi_io;",
          "310:     req->dev = s;",
          "",
          "[Removed Lines]",
          "307:     req = g_new(MPTSASRequest, 1);",
          "",
          "[Added Lines]",
          "307:     req = g_new0(MPTSASRequest, 1);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e351b82611293683c4cabe4b69b7552bde5d4e2a",
      "candidate_info": {
        "commit_hash": "e351b82611293683c4cabe4b69b7552bde5d4e2a",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/e351b82611293683c4cabe4b69b7552bde5d4e2a",
        "files": [
          "default-configs/pci.mak",
          "hw/scsi/Makefile.objs",
          "hw/scsi/mpi.h",
          "hw/scsi/mptconfig.c",
          "hw/scsi/mptendian.c",
          "hw/scsi/mptsas.c",
          "hw/scsi/mptsas.h",
          "include/hw/pci/pci_ids.h",
          "trace-events"
        ],
        "message": "hw: Add support for LSI SAS1068 (mptsas) device\n\nThis adds the SAS1068 device, a SAS disk controller used in VMware that\nis oldish but widely supported and has decent performance.  Unlike\nmegasas, it presents itself as a SAS controller and not as a RAID\ncontroller.  The device corresponds to the mptsas kernel driver in\nLinux.\n\nA few small things in the device setup are based on Don Slutz's old\npatch, but the device emulation was written from scratch based on Don's\nSeaBIOS patch and on the FreeBSD and Linux drivers.  It is 2400 lines\nshorter than Don's patch (and roughly the same size as MegaSAS---also\nbecause it doesn't support the similar SPI controller), implements SCSI\ntask management functions (with asynchronous cancellation), supports\nbig-endian hosts, has complete support for migration and follows the\nQEMU coding standards much more closely.\n\nTo write the driver, I first split Don's patch in two parts, with\nthe configuration bits in one file and the rest in a separate file.\nI first left mptconfig.c in place and rewrote the rest, then deleted\nmptconfig.c as well.  The configuration pages are still based mostly on\nVirtualBox's, though not exactly the same.  However, the implementation\nis completely different.  The contents of the pages themselves should\nnot be copyrightable.\n\nSigned-off-by: Don Slutz <Don@CloudSwitch.com>\nMessage-Id: <1347382813-5662-1-git-send-email-Don@CloudSwitch.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
        "before_after_code_files": [
          "default-configs/pci.mak||default-configs/pci.mak",
          "hw/scsi/Makefile.objs||hw/scsi/Makefile.objs",
          "hw/scsi/mpi.h||hw/scsi/mpi.h",
          "hw/scsi/mptconfig.c||hw/scsi/mptconfig.c",
          "hw/scsi/mptendian.c||hw/scsi/mptendian.c",
          "hw/scsi/mptsas.c||hw/scsi/mptsas.c",
          "hw/scsi/mptsas.h||hw/scsi/mptsas.h",
          "include/hw/pci/pci_ids.h||include/hw/pci/pci_ids.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "hw/scsi/mptsas.c||hw/scsi/mptsas.c"
          ],
          "candidate": [
            "hw/scsi/mptsas.c||hw/scsi/mptsas.c"
          ]
        }
      },
      "candidate_diff": {
        "default-configs/pci.mak||default-configs/pci.mak": [
          "File: default-configs/pci.mak -> default-configs/pci.mak",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: CONFIG_LSI_SCSI_PCI=y",
          "16: CONFIG_VMW_PVSCSI_SCSI_PCI=y",
          "17: CONFIG_MEGASAS_SCSI_PCI=y",
          "18: CONFIG_RTL8139_PCI=y",
          "19: CONFIG_E1000_PCI=y",
          "20: CONFIG_VMXNET3_PCI=y",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18: CONFIG_MPTSAS_SCSI_PCI=y",
          "",
          "---------------"
        ],
        "hw/scsi/Makefile.objs||hw/scsi/Makefile.objs": [
          "File: hw/scsi/Makefile.objs -> hw/scsi/Makefile.objs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: common-obj-y += scsi-disk.o",
          "2: common-obj-y += scsi-generic.o scsi-bus.o",
          "3: common-obj-$(CONFIG_LSI_SCSI_PCI) += lsi53c895a.o",
          "4: common-obj-$(CONFIG_MEGASAS_SCSI_PCI) += megasas.o",
          "5: common-obj-$(CONFIG_VMW_PVSCSI_SCSI_PCI) += vmw_pvscsi.o",
          "6: common-obj-$(CONFIG_ESP) += esp.o",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: common-obj-$(CONFIG_MPTSAS_SCSI_PCI) += mptsas.o mptconfig.o mptendian.o",
          "",
          "---------------"
        ],
        "hw/scsi/mpi.h||hw/scsi/mpi.h": [
          "File: hw/scsi/mpi.h -> hw/scsi/mpi.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "33: #ifndef MPI_H",
          "34: #define MPI_H",
          "36: enum {",
          "37:     MPI_FUNCTION_SCSI_IO_REQUEST                = 0x00,",
          "38:     MPI_FUNCTION_SCSI_TASK_MGMT                 = 0x01,",
          "39:     MPI_FUNCTION_IOC_INIT                       = 0x02,",
          "40:     MPI_FUNCTION_IOC_FACTS                      = 0x03,",
          "41:     MPI_FUNCTION_CONFIG                         = 0x04,",
          "42:     MPI_FUNCTION_PORT_FACTS                     = 0x05,",
          "43:     MPI_FUNCTION_PORT_ENABLE                    = 0x06,",
          "44:     MPI_FUNCTION_EVENT_NOTIFICATION             = 0x07,",
          "45:     MPI_FUNCTION_EVENT_ACK                      = 0x08,",
          "46:     MPI_FUNCTION_FW_DOWNLOAD                    = 0x09,",
          "47:     MPI_FUNCTION_TARGET_CMD_BUFFER_POST         = 0x0A,",
          "48:     MPI_FUNCTION_TARGET_ASSIST                  = 0x0B,",
          "49:     MPI_FUNCTION_TARGET_STATUS_SEND             = 0x0C,",
          "50:     MPI_FUNCTION_TARGET_MODE_ABORT              = 0x0D,",
          "51:     MPI_FUNCTION_FC_LINK_SRVC_BUF_POST          = 0x0E,",
          "52:     MPI_FUNCTION_FC_LINK_SRVC_RSP               = 0x0F,",
          "53:     MPI_FUNCTION_FC_EX_LINK_SRVC_SEND           = 0x10,",
          "54:     MPI_FUNCTION_FC_ABORT                       = 0x11,",
          "55:     MPI_FUNCTION_FW_UPLOAD                      = 0x12,",
          "56:     MPI_FUNCTION_FC_COMMON_TRANSPORT_SEND       = 0x13,",
          "57:     MPI_FUNCTION_FC_PRIMITIVE_SEND              = 0x14,",
          "59:     MPI_FUNCTION_RAID_ACTION                    = 0x15,",
          "60:     MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH       = 0x16,",
          "62:     MPI_FUNCTION_TOOLBOX                        = 0x17,",
          "64:     MPI_FUNCTION_SCSI_ENCLOSURE_PROCESSOR       = 0x18,",
          "66:     MPI_FUNCTION_MAILBOX                        = 0x19,",
          "68:     MPI_FUNCTION_SMP_PASSTHROUGH                = 0x1A,",
          "69:     MPI_FUNCTION_SAS_IO_UNIT_CONTROL            = 0x1B,",
          "70:     MPI_FUNCTION_SATA_PASSTHROUGH               = 0x1C,",
          "72:     MPI_FUNCTION_DIAG_BUFFER_POST               = 0x1D,",
          "73:     MPI_FUNCTION_DIAG_RELEASE                   = 0x1E,",
          "75:     MPI_FUNCTION_SCSI_IO_32                     = 0x1F,",
          "77:     MPI_FUNCTION_LAN_SEND                       = 0x20,",
          "78:     MPI_FUNCTION_LAN_RECEIVE                    = 0x21,",
          "79:     MPI_FUNCTION_LAN_RESET                      = 0x22,",
          "81:     MPI_FUNCTION_TARGET_ASSIST_EXTENDED         = 0x23,",
          "82:     MPI_FUNCTION_TARGET_CMD_BUF_BASE_POST       = 0x24,",
          "83:     MPI_FUNCTION_TARGET_CMD_BUF_LIST_POST       = 0x25,",
          "85:     MPI_FUNCTION_INBAND_BUFFER_POST             = 0x28,",
          "86:     MPI_FUNCTION_INBAND_SEND                    = 0x29,",
          "87:     MPI_FUNCTION_INBAND_RSP                     = 0x2A,",
          "88:     MPI_FUNCTION_INBAND_ABORT                   = 0x2B,",
          "90:     MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET         = 0x40,",
          "91:     MPI_FUNCTION_IO_UNIT_RESET                  = 0x41,",
          "92:     MPI_FUNCTION_HANDSHAKE                      = 0x42,",
          "93:     MPI_FUNCTION_REPLY_FRAME_REMOVAL            = 0x43,",
          "94:     MPI_FUNCTION_HOST_PAGEBUF_ACCESS_CONTROL    = 0x44,",
          "95: };",
          "101: enum {",
          "102:     MPI_IOC_STATE_RESET                 = 0x00000000,",
          "103:     MPI_IOC_STATE_READY                 = 0x10000000,",
          "104:     MPI_IOC_STATE_OPERATIONAL           = 0x20000000,",
          "105:     MPI_IOC_STATE_FAULT                 = 0x40000000,",
          "107:     MPI_DOORBELL_OFFSET                 = 0x00000000,",
          "109:     MPI_DOORBELL_WHO_INIT_MASK          = 0x07000000,",
          "110:     MPI_DOORBELL_WHO_INIT_SHIFT         = 24,",
          "111:     MPI_DOORBELL_FUNCTION_MASK          = 0xFF000000,",
          "112:     MPI_DOORBELL_FUNCTION_SHIFT         = 24,",
          "113:     MPI_DOORBELL_ADD_DWORDS_MASK        = 0x00FF0000,",
          "114:     MPI_DOORBELL_ADD_DWORDS_SHIFT       = 16,",
          "115:     MPI_DOORBELL_DATA_MASK              = 0x0000FFFF,",
          "116:     MPI_DOORBELL_FUNCTION_SPECIFIC_MASK = 0x0000FFFF,",
          "118:     MPI_DB_HPBAC_VALUE_MASK             = 0x0000F000,",
          "119:     MPI_DB_HPBAC_ENABLE_ACCESS          = 0x01,",
          "120:     MPI_DB_HPBAC_DISABLE_ACCESS         = 0x02,",
          "121:     MPI_DB_HPBAC_FREE_BUFFER            = 0x03,",
          "123:     MPI_WRITE_SEQUENCE_OFFSET           = 0x00000004,",
          "124:     MPI_WRSEQ_KEY_VALUE_MASK            = 0x0000000F,",
          "125:     MPI_WRSEQ_1ST_KEY_VALUE             = 0x04,",
          "126:     MPI_WRSEQ_2ND_KEY_VALUE             = 0x0B,",
          "127:     MPI_WRSEQ_3RD_KEY_VALUE             = 0x02,",
          "128:     MPI_WRSEQ_4TH_KEY_VALUE             = 0x07,",
          "129:     MPI_WRSEQ_5TH_KEY_VALUE             = 0x0D,",
          "131:     MPI_DIAGNOSTIC_OFFSET               = 0x00000008,",
          "132:     MPI_DIAG_CLEAR_FLASH_BAD_SIG        = 0x00000400,",
          "133:     MPI_DIAG_PREVENT_IOC_BOOT           = 0x00000200,",
          "134:     MPI_DIAG_DRWE                       = 0x00000080,",
          "135:     MPI_DIAG_FLASH_BAD_SIG              = 0x00000040,",
          "136:     MPI_DIAG_RESET_HISTORY              = 0x00000020,",
          "137:     MPI_DIAG_RW_ENABLE                  = 0x00000010,",
          "138:     MPI_DIAG_RESET_ADAPTER              = 0x00000004,",
          "139:     MPI_DIAG_DISABLE_ARM                = 0x00000002,",
          "140:     MPI_DIAG_MEM_ENABLE                 = 0x00000001,",
          "142:     MPI_TEST_BASE_ADDRESS_OFFSET        = 0x0000000C,",
          "144:     MPI_DIAG_RW_DATA_OFFSET             = 0x00000010,",
          "146:     MPI_DIAG_RW_ADDRESS_OFFSET          = 0x00000014,",
          "148:     MPI_HOST_INTERRUPT_STATUS_OFFSET    = 0x00000030,",
          "149:     MPI_HIS_IOP_DOORBELL_STATUS         = 0x80000000,",
          "150:     MPI_HIS_REPLY_MESSAGE_INTERRUPT     = 0x00000008,",
          "151:     MPI_HIS_DOORBELL_INTERRUPT          = 0x00000001,",
          "153:     MPI_HOST_INTERRUPT_MASK_OFFSET      = 0x00000034,",
          "154:     MPI_HIM_RIM                         = 0x00000008,",
          "155:     MPI_HIM_DIM                         = 0x00000001,",
          "157:     MPI_REQUEST_QUEUE_OFFSET            = 0x00000040,",
          "158:     MPI_REQUEST_POST_FIFO_OFFSET        = 0x00000040,",
          "160:     MPI_REPLY_QUEUE_OFFSET              = 0x00000044,",
          "161:     MPI_REPLY_POST_FIFO_OFFSET          = 0x00000044,",
          "162:     MPI_REPLY_FREE_FIFO_OFFSET          = 0x00000044,",
          "164:     MPI_HI_PRI_REQUEST_QUEUE_OFFSET     = 0x00000048,",
          "165: };",
          "167: #define MPI_ADDRESS_REPLY_A_BIT          0x80000000",
          "173: typedef struct MPISGEntry {",
          "174:     uint32_t                FlagsLength;",
          "175:     union",
          "176:     {",
          "177:         uint32_t            Address32;",
          "178:         uint64_t            Address64;",
          "179:     } u;",
          "180: } QEMU_PACKED MPISGEntry;",
          "184: enum {",
          "185:     MPI_SGE_FLAGS_LAST_ELEMENT              = 0x80000000,",
          "186:     MPI_SGE_FLAGS_END_OF_BUFFER             = 0x40000000,",
          "187:     MPI_SGE_FLAGS_ELEMENT_TYPE_MASK         = 0x30000000,",
          "188:     MPI_SGE_FLAGS_LOCAL_ADDRESS             = 0x08000000,",
          "189:     MPI_SGE_FLAGS_DIRECTION                 = 0x04000000,",
          "190:     MPI_SGE_FLAGS_64_BIT_ADDRESSING         = 0x02000000,",
          "191:     MPI_SGE_FLAGS_END_OF_LIST               = 0x01000000,",
          "193:     MPI_SGE_LENGTH_MASK                     = 0x00FFFFFF,",
          "194:     MPI_SGE_CHAIN_LENGTH_MASK               = 0x0000FFFF,",
          "196:     MPI_SGE_FLAGS_TRANSACTION_ELEMENT       = 0x00000000,",
          "197:     MPI_SGE_FLAGS_SIMPLE_ELEMENT            = 0x10000000,",
          "198:     MPI_SGE_FLAGS_CHAIN_ELEMENT             = 0x30000000,",
          "202:     MPI_SGE_FLAGS_IOC_TO_HOST               = 0x00000000,",
          "203:     MPI_SGE_FLAGS_HOST_TO_IOC               = 0x04000000,",
          "205:     MPI_SGE_CHAIN_OFFSET_MASK               = 0x00FF0000,",
          "206: };",
          "208: #define MPI_SGE_CHAIN_OFFSET_SHIFT 16",
          "214: typedef struct MPIRequestHeader {",
          "216:     uint8_t                 ChainOffset;",
          "217:     uint8_t                 Function;",
          "219:     uint8_t                 MsgFlags;",
          "220:     uint32_t                MsgContext;",
          "221: } QEMU_PACKED MPIRequestHeader;",
          "224: typedef struct MPIDefaultReply {",
          "226:     uint8_t                 MsgLength;",
          "227:     uint8_t                 Function;",
          "229:     uint8_t                 MsgFlags;",
          "230:     uint32_t                MsgContext;",
          "232:     uint16_t                IOCStatus;",
          "233:     uint32_t                IOCLogInfo;",
          "234: } QEMU_PACKED MPIDefaultReply;",
          "238: #define MPI_MSGFLAGS_CONTINUATION_REPLY         (0x80)",
          "240: enum {",
          "246:     MPI_IOCSTATUS_SUCCESS                   = 0x0000,",
          "247:     MPI_IOCSTATUS_INVALID_FUNCTION          = 0x0001,",
          "248:     MPI_IOCSTATUS_BUSY                      = 0x0002,",
          "249:     MPI_IOCSTATUS_INVALID_SGL               = 0x0003,",
          "250:     MPI_IOCSTATUS_INTERNAL_ERROR            = 0x0004,",
          "251:     MPI_IOCSTATUS_RESERVED                  = 0x0005,",
          "252:     MPI_IOCSTATUS_INSUFFICIENT_RESOURCES    = 0x0006,",
          "253:     MPI_IOCSTATUS_INVALID_FIELD             = 0x0007,",
          "254:     MPI_IOCSTATUS_INVALID_STATE             = 0x0008,",
          "255:     MPI_IOCSTATUS_OP_STATE_NOT_SUPPORTED    = 0x0009,",
          "261:     MPI_IOCSTATUS_CONFIG_INVALID_ACTION     = 0x0020,",
          "262:     MPI_IOCSTATUS_CONFIG_INVALID_TYPE       = 0x0021,",
          "263:     MPI_IOCSTATUS_CONFIG_INVALID_PAGE       = 0x0022,",
          "264:     MPI_IOCSTATUS_CONFIG_INVALID_DATA       = 0x0023,",
          "265:     MPI_IOCSTATUS_CONFIG_NO_DEFAULTS        = 0x0024,",
          "266:     MPI_IOCSTATUS_CONFIG_CANT_COMMIT        = 0x0025,",
          "272:     MPI_IOCSTATUS_SCSI_RECOVERED_ERROR      = 0x0040,",
          "273:     MPI_IOCSTATUS_SCSI_INVALID_BUS          = 0x0041,",
          "274:     MPI_IOCSTATUS_SCSI_INVALID_TARGETID     = 0x0042,",
          "275:     MPI_IOCSTATUS_SCSI_DEVICE_NOT_THERE     = 0x0043,",
          "276:     MPI_IOCSTATUS_SCSI_DATA_OVERRUN         = 0x0044,",
          "277:     MPI_IOCSTATUS_SCSI_DATA_UNDERRUN        = 0x0045,",
          "278:     MPI_IOCSTATUS_SCSI_IO_DATA_ERROR        = 0x0046,",
          "279:     MPI_IOCSTATUS_SCSI_PROTOCOL_ERROR       = 0x0047,",
          "280:     MPI_IOCSTATUS_SCSI_TASK_TERMINATED      = 0x0048,",
          "281:     MPI_IOCSTATUS_SCSI_RESIDUAL_MISMATCH    = 0x0049,",
          "282:     MPI_IOCSTATUS_SCSI_TASK_MGMT_FAILED     = 0x004A,",
          "283:     MPI_IOCSTATUS_SCSI_IOC_TERMINATED       = 0x004B,",
          "284:     MPI_IOCSTATUS_SCSI_EXT_TERMINATED       = 0x004C,",
          "290:     MPI_IOCSTATUS_EEDP_GUARD_ERROR          = 0x004D,",
          "291:     MPI_IOCSTATUS_EEDP_REF_TAG_ERROR        = 0x004E,",
          "292:     MPI_IOCSTATUS_EEDP_APP_TAG_ERROR        = 0x004F,",
          "298:     MPI_IOCSTATUS_TARGET_PRIORITY_IO         = 0x0060,",
          "299:     MPI_IOCSTATUS_TARGET_INVALID_PORT        = 0x0061,",
          "300:     MPI_IOCSTATUS_TARGET_INVALID_IO_INDEX    = 0x0062,",
          "301:     MPI_IOCSTATUS_TARGET_ABORTED             = 0x0063,",
          "302:     MPI_IOCSTATUS_TARGET_NO_CONN_RETRYABLE   = 0x0064,",
          "303:     MPI_IOCSTATUS_TARGET_NO_CONNECTION       = 0x0065,",
          "304:     MPI_IOCSTATUS_TARGET_XFER_COUNT_MISMATCH = 0x006A,",
          "305:     MPI_IOCSTATUS_TARGET_STS_DATA_NOT_SENT   = 0x006B,",
          "306:     MPI_IOCSTATUS_TARGET_DATA_OFFSET_ERROR   = 0x006D,",
          "307:     MPI_IOCSTATUS_TARGET_TOO_MUCH_WRITE_DATA = 0x006E,",
          "308:     MPI_IOCSTATUS_TARGET_IU_TOO_SHORT        = 0x006F,",
          "309:     MPI_IOCSTATUS_TARGET_ACK_NAK_TIMEOUT     = 0x0070,",
          "310:     MPI_IOCSTATUS_TARGET_NAK_RECEIVED        = 0x0071,",
          "316:     MPI_IOCSTATUS_FC_ABORTED                = 0x0066,",
          "317:     MPI_IOCSTATUS_FC_RX_ID_INVALID          = 0x0067,",
          "318:     MPI_IOCSTATUS_FC_DID_INVALID            = 0x0068,",
          "319:     MPI_IOCSTATUS_FC_NODE_LOGGED_OUT        = 0x0069,",
          "320:     MPI_IOCSTATUS_FC_EXCHANGE_CANCELED      = 0x006C,",
          "326:     MPI_IOCSTATUS_LAN_DEVICE_NOT_FOUND      = 0x0080,",
          "327:     MPI_IOCSTATUS_LAN_DEVICE_FAILURE        = 0x0081,",
          "328:     MPI_IOCSTATUS_LAN_TRANSMIT_ERROR        = 0x0082,",
          "329:     MPI_IOCSTATUS_LAN_TRANSMIT_ABORTED      = 0x0083,",
          "330:     MPI_IOCSTATUS_LAN_RECEIVE_ERROR         = 0x0084,",
          "331:     MPI_IOCSTATUS_LAN_RECEIVE_ABORTED       = 0x0085,",
          "332:     MPI_IOCSTATUS_LAN_PARTIAL_PACKET        = 0x0086,",
          "333:     MPI_IOCSTATUS_LAN_CANCELED              = 0x0087,",
          "339:     MPI_IOCSTATUS_SAS_SMP_REQUEST_FAILED    = 0x0090,",
          "340:     MPI_IOCSTATUS_SAS_SMP_DATA_OVERRUN      = 0x0091,",
          "346:     MPI_IOCSTATUS_INBAND_ABORTED            = 0x0098,",
          "347:     MPI_IOCSTATUS_INBAND_NO_CONNECTION      = 0x0099,",
          "353:     MPI_IOCSTATUS_DIAGNOSTIC_RELEASED       = 0x00A0,",
          "359:     MPI_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE   = 0x8000,",
          "360:     MPI_IOCSTATUS_MASK                      = 0x7FFF,",
          "366:     MPI_IOCLOGINFO_TYPE_MASK                = 0xF0000000,",
          "367:     MPI_IOCLOGINFO_TYPE_SHIFT               = 28,",
          "368:     MPI_IOCLOGINFO_TYPE_NONE                = 0x0,",
          "369:     MPI_IOCLOGINFO_TYPE_SCSI                = 0x1,",
          "370:     MPI_IOCLOGINFO_TYPE_FC                  = 0x2,",
          "371:     MPI_IOCLOGINFO_TYPE_SAS                 = 0x3,",
          "372:     MPI_IOCLOGINFO_TYPE_ISCSI               = 0x4,",
          "373:     MPI_IOCLOGINFO_LOG_DATA_MASK            = 0x0FFFFFFF,",
          "374: };",
          "380: typedef struct MPIMsgSCSIIORequest {",
          "395: } QEMU_PACKED MPIMsgSCSIIORequest;",
          "399: #define MPI_SCSIIO_MSGFLGS_SENSE_WIDTH              (0x01)",
          "400: #define MPI_SCSIIO_MSGFLGS_SENSE_WIDTH_32           (0x00)",
          "401: #define MPI_SCSIIO_MSGFLGS_SENSE_WIDTH_64           (0x01)",
          "403: #define MPI_SCSIIO_MSGFLGS_SENSE_LOCATION           (0x02)",
          "404: #define MPI_SCSIIO_MSGFLGS_SENSE_LOC_HOST           (0x00)",
          "405: #define MPI_SCSIIO_MSGFLGS_SENSE_LOC_IOC            (0x02)",
          "407: #define MPI_SCSIIO_MSGFLGS_CMD_DETERMINES_DATA_DIR  (0x04)",
          "411: #define MPI_SCSIIO_LUN_FIRST_LEVEL_ADDRESSING   (0x0000FFFF)",
          "412: #define MPI_SCSIIO_LUN_SECOND_LEVEL_ADDRESSING  (0xFFFF0000)",
          "413: #define MPI_SCSIIO_LUN_THIRD_LEVEL_ADDRESSING   (0x0000FFFF)",
          "414: #define MPI_SCSIIO_LUN_FOURTH_LEVEL_ADDRESSING  (0xFFFF0000)",
          "415: #define MPI_SCSIIO_LUN_LEVEL_1_WORD             (0xFF00)",
          "416: #define MPI_SCSIIO_LUN_LEVEL_1_DWORD            (0x0000FF00)",
          "420: #define MPI_SCSIIO_CONTROL_DATADIRECTION_MASK   (0x03000000)",
          "421: #define MPI_SCSIIO_CONTROL_NODATATRANSFER       (0x00000000)",
          "422: #define MPI_SCSIIO_CONTROL_WRITE                (0x01000000)",
          "423: #define MPI_SCSIIO_CONTROL_READ                 (0x02000000)",
          "425: #define MPI_SCSIIO_CONTROL_ADDCDBLEN_MASK       (0x3C000000)",
          "426: #define MPI_SCSIIO_CONTROL_ADDCDBLEN_SHIFT      (26)",
          "428: #define MPI_SCSIIO_CONTROL_TASKATTRIBUTE_MASK   (0x00000700)",
          "429: #define MPI_SCSIIO_CONTROL_SIMPLEQ              (0x00000000)",
          "430: #define MPI_SCSIIO_CONTROL_HEADOFQ              (0x00000100)",
          "431: #define MPI_SCSIIO_CONTROL_ORDEREDQ             (0x00000200)",
          "432: #define MPI_SCSIIO_CONTROL_ACAQ                 (0x00000400)",
          "433: #define MPI_SCSIIO_CONTROL_UNTAGGED             (0x00000500)",
          "434: #define MPI_SCSIIO_CONTROL_NO_DISCONNECT        (0x00000700)",
          "436: #define MPI_SCSIIO_CONTROL_TASKMANAGE_MASK      (0x00FF0000)",
          "437: #define MPI_SCSIIO_CONTROL_OBSOLETE             (0x00800000)",
          "438: #define MPI_SCSIIO_CONTROL_CLEAR_ACA_RSV        (0x00400000)",
          "439: #define MPI_SCSIIO_CONTROL_TARGET_RESET         (0x00200000)",
          "440: #define MPI_SCSIIO_CONTROL_LUN_RESET_RSV        (0x00100000)",
          "441: #define MPI_SCSIIO_CONTROL_RESERVED             (0x00080000)",
          "442: #define MPI_SCSIIO_CONTROL_CLR_TASK_SET_RSV     (0x00040000)",
          "443: #define MPI_SCSIIO_CONTROL_ABORT_TASK_SET       (0x00020000)",
          "444: #define MPI_SCSIIO_CONTROL_RESERVED2            (0x00010000)",
          "447: typedef struct MPIMsgSCSIIOReply",
          "448: {",
          "467: } QEMU_PACKED MPIMsgSCSIIOReply;",
          "471: #define MPI_SCSI_STATUS_SUCCESS                 (0x00)",
          "472: #define MPI_SCSI_STATUS_CHECK_CONDITION         (0x02)",
          "473: #define MPI_SCSI_STATUS_CONDITION_MET           (0x04)",
          "474: #define MPI_SCSI_STATUS_BUSY                    (0x08)",
          "475: #define MPI_SCSI_STATUS_INTERMEDIATE            (0x10)",
          "476: #define MPI_SCSI_STATUS_INTERMEDIATE_CONDMET    (0x14)",
          "477: #define MPI_SCSI_STATUS_RESERVATION_CONFLICT    (0x18)",
          "478: #define MPI_SCSI_STATUS_COMMAND_TERMINATED      (0x22)",
          "479: #define MPI_SCSI_STATUS_TASK_SET_FULL           (0x28)",
          "480: #define MPI_SCSI_STATUS_ACA_ACTIVE              (0x30)",
          "482: #define MPI_SCSI_STATUS_FCPEXT_DEVICE_LOGGED_OUT    (0x80)",
          "483: #define MPI_SCSI_STATUS_FCPEXT_NO_LINK              (0x81)",
          "484: #define MPI_SCSI_STATUS_FCPEXT_UNASSIGNED           (0x82)",
          "489: #define MPI_SCSI_STATE_AUTOSENSE_VALID          (0x01)",
          "490: #define MPI_SCSI_STATE_AUTOSENSE_FAILED         (0x02)",
          "491: #define MPI_SCSI_STATE_NO_SCSI_STATUS           (0x04)",
          "492: #define MPI_SCSI_STATE_TERMINATED               (0x08)",
          "493: #define MPI_SCSI_STATE_RESPONSE_INFO_VALID      (0x10)",
          "494: #define MPI_SCSI_STATE_QUEUE_TAG_REJECTED       (0x20)",
          "499: #define MPI_SCSI_RSP_INFO_FUNCTION_COMPLETE     (0x00000000)",
          "500: #define MPI_SCSI_RSP_INFO_FCP_BURST_LEN_ERROR   (0x01000000)",
          "501: #define MPI_SCSI_RSP_INFO_CMND_FIELDS_INVALID   (0x02000000)",
          "502: #define MPI_SCSI_RSP_INFO_FCP_DATA_RO_ERROR     (0x03000000)",
          "503: #define MPI_SCSI_RSP_INFO_TASK_MGMT_UNSUPPORTED (0x04000000)",
          "504: #define MPI_SCSI_RSP_INFO_TASK_MGMT_FAILED      (0x05000000)",
          "505: #define MPI_SCSI_RSP_INFO_SPI_LQ_INVALID_TYPE   (0x06000000)",
          "507: #define MPI_SCSI_TASKTAG_UNKNOWN                (0xFFFF)",
          "514: typedef struct MPIMsgSCSITaskMgmt {",
          "527: } QEMU_PACKED MPIMsgSCSITaskMgmt;",
          "529: enum {",
          "532:     MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK            = 0x01,",
          "533:     MPI_SCSITASKMGMT_TASKTYPE_ABRT_TASK_SET         = 0x02,",
          "534:     MPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET          = 0x03,",
          "535:     MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS             = 0x04,",
          "536:     MPI_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET    = 0x05,",
          "537:     MPI_SCSITASKMGMT_TASKTYPE_CLEAR_TASK_SET        = 0x06,",
          "538:     MPI_SCSITASKMGMT_TASKTYPE_QUERY_TASK            = 0x07,",
          "539:     MPI_SCSITASKMGMT_TASKTYPE_CLR_ACA               = 0x08,",
          "543:     MPI_SCSITASKMGMT_MSGFLAGS_DO_NOT_SEND_TASK_IU   = 0x01,",
          "545:     MPI_SCSITASKMGMT_MSGFLAGS_TARGET_RESET_OPTION   = 0x00,",
          "546:     MPI_SCSITASKMGMT_MSGFLAGS_LIP_RESET_OPTION      = 0x02,",
          "547:     MPI_SCSITASKMGMT_MSGFLAGS_LIPRESET_RESET_OPTION = 0x04,",
          "549:     MPI_SCSITASKMGMT_MSGFLAGS_SOFT_RESET_OPTION     = 0x08,",
          "550: };",
          "553: typedef struct MPIMsgSCSITaskMgmtReply {",
          "567: } QEMU_PACKED MPIMsgSCSITaskMgmtReply;",
          "570: enum {",
          "571:     MPI_SCSITASKMGMT_RSP_TM_COMPLETE                = 0x00,",
          "572:     MPI_SCSITASKMGMT_RSP_INVALID_FRAME              = 0x02,",
          "573:     MPI_SCSITASKMGMT_RSP_TM_NOT_SUPPORTED           = 0x04,",
          "574:     MPI_SCSITASKMGMT_RSP_TM_FAILED                  = 0x05,",
          "575:     MPI_SCSITASKMGMT_RSP_TM_SUCCEEDED               = 0x08,",
          "576:     MPI_SCSITASKMGMT_RSP_TM_INVALID_LUN             = 0x09,",
          "577:     MPI_SCSITASKMGMT_RSP_IO_QUEUED_ON_IOC           = 0x80,",
          "578: };",
          "584: typedef struct MPIMsgIOCInit {",
          "602: } QEMU_PACKED MPIMsgIOCInit;",
          "604: enum {",
          "607:     MPI_WHOINIT_NO_ONE                              = 0x00,",
          "608:     MPI_WHOINIT_SYSTEM_BIOS                         = 0x01,",
          "609:     MPI_WHOINIT_ROM_BIOS                            = 0x02,",
          "610:     MPI_WHOINIT_PCI_PEER                            = 0x03,",
          "611:     MPI_WHOINIT_HOST_DRIVER                         = 0x04,",
          "612:     MPI_WHOINIT_MANUFACTURER                        = 0x05,",
          "616:     MPI_IOCINIT_FLAGS_HOST_PAGE_BUFFER_PERSISTENT   = 0x04,",
          "617:     MPI_IOCINIT_FLAGS_REPLY_FIFO_HOST_SIGNAL        = 0x02,",
          "618:     MPI_IOCINIT_FLAGS_DISCARD_FW_IMAGE              = 0x01,",
          "622:     MPI_IOCINIT_MSGVERSION_MAJOR_MASK               = 0xFF00,",
          "623:     MPI_IOCINIT_MSGVERSION_MAJOR_SHIFT              = 8,",
          "624:     MPI_IOCINIT_MSGVERSION_MINOR_MASK               = 0x00FF,",
          "625:     MPI_IOCINIT_MSGVERSION_MINOR_SHIFT              = 0,",
          "629:     MPI_IOCINIT_HEADERVERSION_UNIT_MASK             = 0xFF00,",
          "630:     MPI_IOCINIT_HEADERVERSION_UNIT_SHIFT            = 8,",
          "631:     MPI_IOCINIT_HEADERVERSION_DEV_MASK              = 0x00FF,",
          "632:     MPI_IOCINIT_HEADERVERSION_DEV_SHIFT             = 0,",
          "633: };",
          "635: typedef struct MPIMsgIOCInitReply {",
          "648: } QEMU_PACKED MPIMsgIOCInitReply;",
          "656: typedef struct MPIMsgIOCFacts {",
          "663: } QEMU_PACKED MPIMsgIOCFacts;",
          "666: typedef struct MPIMsgIOCFactsReply {",
          "703: } QEMU_PACKED MPIMsgIOCFactsReply;",
          "705: enum {",
          "706:     MPI_IOCFACTS_MSGVERSION_MAJOR_MASK              = 0xFF00,",
          "707:     MPI_IOCFACTS_MSGVERSION_MAJOR_SHIFT             = 8,",
          "708:     MPI_IOCFACTS_MSGVERSION_MINOR_MASK              = 0x00FF,",
          "709:     MPI_IOCFACTS_MSGVERSION_MINOR_SHIFT             = 0,",
          "711:     MPI_IOCFACTS_HDRVERSION_UNIT_MASK               = 0xFF00,",
          "712:     MPI_IOCFACTS_HDRVERSION_UNIT_SHIFT              = 8,",
          "713:     MPI_IOCFACTS_HDRVERSION_DEV_MASK                = 0x00FF,",
          "714:     MPI_IOCFACTS_HDRVERSION_DEV_SHIFT               = 0,",
          "716:     MPI_IOCFACTS_EXCEPT_CONFIG_CHECKSUM_FAIL        = 0x0001,",
          "717:     MPI_IOCFACTS_EXCEPT_RAID_CONFIG_INVALID         = 0x0002,",
          "718:     MPI_IOCFACTS_EXCEPT_FW_CHECKSUM_FAIL            = 0x0004,",
          "719:     MPI_IOCFACTS_EXCEPT_PERSISTENT_TABLE_FULL       = 0x0008,",
          "720:     MPI_IOCFACTS_EXCEPT_METADATA_UNSUPPORTED        = 0x0010,",
          "722:     MPI_IOCFACTS_FLAGS_FW_DOWNLOAD_BOOT             = 0x01,",
          "723:     MPI_IOCFACTS_FLAGS_REPLY_FIFO_HOST_SIGNAL       = 0x02,",
          "724:     MPI_IOCFACTS_FLAGS_HOST_PAGE_BUFFER_PERSISTENT  = 0x04,",
          "726:     MPI_IOCFACTS_EVENTSTATE_DISABLED                = 0x00,",
          "727:     MPI_IOCFACTS_EVENTSTATE_ENABLED                 = 0x01,",
          "729:     MPI_IOCFACTS_CAPABILITY_HIGH_PRI_Q              = 0x00000001,",
          "730:     MPI_IOCFACTS_CAPABILITY_REPLY_HOST_SIGNAL       = 0x00000002,",
          "731:     MPI_IOCFACTS_CAPABILITY_QUEUE_FULL_HANDLING     = 0x00000004,",
          "732:     MPI_IOCFACTS_CAPABILITY_DIAG_TRACE_BUFFER       = 0x00000008,",
          "733:     MPI_IOCFACTS_CAPABILITY_SNAPSHOT_BUFFER         = 0x00000010,",
          "734:     MPI_IOCFACTS_CAPABILITY_EXTENDED_BUFFER         = 0x00000020,",
          "735:     MPI_IOCFACTS_CAPABILITY_EEDP                    = 0x00000040,",
          "736:     MPI_IOCFACTS_CAPABILITY_BIDIRECTIONAL           = 0x00000080,",
          "737:     MPI_IOCFACTS_CAPABILITY_MULTICAST               = 0x00000100,",
          "738:     MPI_IOCFACTS_CAPABILITY_SCSIIO32                = 0x00000200,",
          "739:     MPI_IOCFACTS_CAPABILITY_NO_SCSIIO16             = 0x00000400,",
          "740:     MPI_IOCFACTS_CAPABILITY_TLR                     = 0x00000800,",
          "741: };",
          "747: typedef struct MPIMsgPortFacts {",
          "755: } QEMU_PACKED MPIMsgPortFacts;",
          "757: typedef struct MPIMsgPortFactsReply {",
          "779: } QEMU_PACKED MPIMsgPortFactsReply;",
          "782: enum {",
          "784:     MPI_PORTFACTS_PORTTYPE_INACTIVE         = 0x00,",
          "785:     MPI_PORTFACTS_PORTTYPE_SCSI             = 0x01,",
          "786:     MPI_PORTFACTS_PORTTYPE_FC               = 0x10,",
          "787:     MPI_PORTFACTS_PORTTYPE_ISCSI            = 0x20,",
          "788:     MPI_PORTFACTS_PORTTYPE_SAS              = 0x30,",
          "791:     MPI_PORTFACTS_PROTOCOL_LOGBUSADDR       = 0x01,",
          "792:     MPI_PORTFACTS_PROTOCOL_LAN              = 0x02,",
          "793:     MPI_PORTFACTS_PROTOCOL_TARGET           = 0x04,",
          "794:     MPI_PORTFACTS_PROTOCOL_INITIATOR        = 0x08,",
          "795: };",
          "802: typedef struct MPIMsgPortEnable {",
          "810: } QEMU_PACKED MPIMsgPortEnable;",
          "812: typedef struct MPIMsgPortEnableReply {",
          "823: } QEMU_PACKED MPIMsgPortEnableReply;",
          "829: typedef struct MPIMsgEventNotify {",
          "837: } QEMU_PACKED MPIMsgEventNotify;",
          "841: typedef struct MPIMsgEventNotifyReply {",
          "855: } QEMU_PACKED MPIMsgEventNotifyReply;",
          "859: typedef struct MPIMsgEventAck {",
          "868: } QEMU_PACKED MPIMsgEventAck;",
          "870: typedef struct MPIMsgEventAckReply {",
          "880: } QEMU_PACKED MPIMsgEventAckReply;",
          "882: enum {",
          "885:     MPI_EVENT_NOTIFICATION_SWITCH_OFF   = 0x00,",
          "886:     MPI_EVENT_NOTIFICATION_SWITCH_ON    = 0x01,",
          "890:     MPI_EVENT_NONE                          = 0x00000000,",
          "891:     MPI_EVENT_LOG_DATA                      = 0x00000001,",
          "892:     MPI_EVENT_STATE_CHANGE                  = 0x00000002,",
          "893:     MPI_EVENT_UNIT_ATTENTION                = 0x00000003,",
          "894:     MPI_EVENT_IOC_BUS_RESET                 = 0x00000004,",
          "895:     MPI_EVENT_EXT_BUS_RESET                 = 0x00000005,",
          "896:     MPI_EVENT_RESCAN                        = 0x00000006,",
          "897:     MPI_EVENT_LINK_STATUS_CHANGE            = 0x00000007,",
          "898:     MPI_EVENT_LOOP_STATE_CHANGE             = 0x00000008,",
          "899:     MPI_EVENT_LOGOUT                        = 0x00000009,",
          "900:     MPI_EVENT_EVENT_CHANGE                  = 0x0000000A,",
          "901:     MPI_EVENT_INTEGRATED_RAID               = 0x0000000B,",
          "902:     MPI_EVENT_SCSI_DEVICE_STATUS_CHANGE     = 0x0000000C,",
          "903:     MPI_EVENT_ON_BUS_TIMER_EXPIRED          = 0x0000000D,",
          "904:     MPI_EVENT_QUEUE_FULL                    = 0x0000000E,",
          "905:     MPI_EVENT_SAS_DEVICE_STATUS_CHANGE      = 0x0000000F,",
          "906:     MPI_EVENT_SAS_SES                       = 0x00000010,",
          "907:     MPI_EVENT_PERSISTENT_TABLE_FULL         = 0x00000011,",
          "908:     MPI_EVENT_SAS_PHY_LINK_STATUS           = 0x00000012,",
          "909:     MPI_EVENT_SAS_DISCOVERY_ERROR           = 0x00000013,",
          "910:     MPI_EVENT_IR_RESYNC_UPDATE              = 0x00000014,",
          "911:     MPI_EVENT_IR2                           = 0x00000015,",
          "912:     MPI_EVENT_SAS_DISCOVERY                 = 0x00000016,",
          "913:     MPI_EVENT_SAS_BROADCAST_PRIMITIVE       = 0x00000017,",
          "914:     MPI_EVENT_SAS_INIT_DEVICE_STATUS_CHANGE = 0x00000018,",
          "915:     MPI_EVENT_SAS_INIT_TABLE_OVERFLOW       = 0x00000019,",
          "916:     MPI_EVENT_SAS_SMP_ERROR                 = 0x0000001A,",
          "917:     MPI_EVENT_SAS_EXPANDER_STATUS_CHANGE    = 0x0000001B,",
          "918:     MPI_EVENT_LOG_ENTRY_ADDED               = 0x00000021,",
          "922:     MPI_EVENT_NOTIFICATION_ACK_NOT_REQUIRED = 0x00,",
          "923:     MPI_EVENT_NOTIFICATION_ACK_REQUIRED     = 0x01,",
          "924: };",
          "930: typedef struct MPIMsgConfig {",
          "946: } QEMU_PACKED MPIMsgConfig;",
          "950: enum {",
          "951:     MPI_CONFIG_ACTION_PAGE_HEADER               = 0x00,",
          "952:     MPI_CONFIG_ACTION_PAGE_READ_CURRENT         = 0x01,",
          "953:     MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT        = 0x02,",
          "954:     MPI_CONFIG_ACTION_PAGE_DEFAULT              = 0x03,",
          "955:     MPI_CONFIG_ACTION_PAGE_WRITE_NVRAM          = 0x04,",
          "956:     MPI_CONFIG_ACTION_PAGE_READ_DEFAULT         = 0x05,",
          "957:     MPI_CONFIG_ACTION_PAGE_READ_NVRAM           = 0x06,",
          "958: };",
          "962: typedef struct MPIMsgConfigReply {",
          "978: } QEMU_PACKED MPIMsgConfigReply;",
          "980: enum {",
          "982:     MPI_CONFIG_PAGEATTR_READ_ONLY               = 0x00,",
          "983:     MPI_CONFIG_PAGEATTR_CHANGEABLE              = 0x10,",
          "984:     MPI_CONFIG_PAGEATTR_PERSISTENT              = 0x20,",
          "985:     MPI_CONFIG_PAGEATTR_RO_PERSISTENT           = 0x30,",
          "986:     MPI_CONFIG_PAGEATTR_MASK                    = 0xF0,",
          "988:     MPI_CONFIG_PAGETYPE_IO_UNIT                 = 0x00,",
          "989:     MPI_CONFIG_PAGETYPE_IOC                     = 0x01,",
          "990:     MPI_CONFIG_PAGETYPE_BIOS                    = 0x02,",
          "991:     MPI_CONFIG_PAGETYPE_SCSI_PORT               = 0x03,",
          "992:     MPI_CONFIG_PAGETYPE_SCSI_DEVICE             = 0x04,",
          "993:     MPI_CONFIG_PAGETYPE_FC_PORT                 = 0x05,",
          "994:     MPI_CONFIG_PAGETYPE_FC_DEVICE               = 0x06,",
          "995:     MPI_CONFIG_PAGETYPE_LAN                     = 0x07,",
          "996:     MPI_CONFIG_PAGETYPE_RAID_VOLUME             = 0x08,",
          "997:     MPI_CONFIG_PAGETYPE_MANUFACTURING           = 0x09,",
          "998:     MPI_CONFIG_PAGETYPE_RAID_PHYSDISK           = 0x0A,",
          "999:     MPI_CONFIG_PAGETYPE_INBAND                  = 0x0B,",
          "1000:     MPI_CONFIG_PAGETYPE_EXTENDED                = 0x0F,",
          "1001:     MPI_CONFIG_PAGETYPE_MASK                    = 0x0F,",
          "1003:     MPI_CONFIG_EXTPAGETYPE_SAS_IO_UNIT          = 0x10,",
          "1004:     MPI_CONFIG_EXTPAGETYPE_SAS_EXPANDER         = 0x11,",
          "1005:     MPI_CONFIG_EXTPAGETYPE_SAS_DEVICE           = 0x12,",
          "1006:     MPI_CONFIG_EXTPAGETYPE_SAS_PHY              = 0x13,",
          "1007:     MPI_CONFIG_EXTPAGETYPE_LOG                  = 0x14,",
          "1008:     MPI_CONFIG_EXTPAGETYPE_ENCLOSURE            = 0x15,",
          "1010:     MPI_SCSI_PORT_PGAD_PORT_MASK                = 0x000000FF,",
          "1012:     MPI_SCSI_DEVICE_FORM_MASK                   = 0xF0000000,",
          "1013:     MPI_SCSI_DEVICE_FORM_BUS_TID                = 0x00000000,",
          "1014:     MPI_SCSI_DEVICE_TARGET_ID_MASK              = 0x000000FF,",
          "1015:     MPI_SCSI_DEVICE_TARGET_ID_SHIFT             = 0,",
          "1016:     MPI_SCSI_DEVICE_BUS_MASK                    = 0x0000FF00,",
          "1017:     MPI_SCSI_DEVICE_BUS_SHIFT                   = 8,",
          "1018:     MPI_SCSI_DEVICE_FORM_TARGET_MODE            = 0x10000000,",
          "1019:     MPI_SCSI_DEVICE_TM_RESPOND_ID_MASK          = 0x000000FF,",
          "1020:     MPI_SCSI_DEVICE_TM_RESPOND_ID_SHIFT         = 0,",
          "1021:     MPI_SCSI_DEVICE_TM_BUS_MASK                 = 0x0000FF00,",
          "1022:     MPI_SCSI_DEVICE_TM_BUS_SHIFT                = 8,",
          "1023:     MPI_SCSI_DEVICE_TM_INIT_ID_MASK             = 0x00FF0000,",
          "1024:     MPI_SCSI_DEVICE_TM_INIT_ID_SHIFT            = 16,",
          "1026:     MPI_FC_PORT_PGAD_PORT_MASK                  = 0xF0000000,",
          "1027:     MPI_FC_PORT_PGAD_PORT_SHIFT                 = 28,",
          "1028:     MPI_FC_PORT_PGAD_FORM_MASK                  = 0x0F000000,",
          "1029:     MPI_FC_PORT_PGAD_FORM_INDEX                 = 0x01000000,",
          "1030:     MPI_FC_PORT_PGAD_INDEX_MASK                 = 0x0000FFFF,",
          "1031:     MPI_FC_PORT_PGAD_INDEX_SHIFT                = 0,",
          "1033:     MPI_FC_DEVICE_PGAD_PORT_MASK                = 0xF0000000,",
          "1034:     MPI_FC_DEVICE_PGAD_PORT_SHIFT               = 28,",
          "1035:     MPI_FC_DEVICE_PGAD_FORM_MASK                = 0x0F000000,",
          "1036:     MPI_FC_DEVICE_PGAD_FORM_NEXT_DID            = 0x00000000,",
          "1037:     MPI_FC_DEVICE_PGAD_ND_PORT_MASK             = 0xF0000000,",
          "1038:     MPI_FC_DEVICE_PGAD_ND_PORT_SHIFT            = 28,",
          "1039:     MPI_FC_DEVICE_PGAD_ND_DID_MASK              = 0x00FFFFFF,",
          "1040:     MPI_FC_DEVICE_PGAD_ND_DID_SHIFT             = 0,",
          "1041:     MPI_FC_DEVICE_PGAD_FORM_BUS_TID             = 0x01000000,",
          "1042:     MPI_FC_DEVICE_PGAD_BT_BUS_MASK              = 0x0000FF00,",
          "1043:     MPI_FC_DEVICE_PGAD_BT_BUS_SHIFT             = 8,",
          "1044:     MPI_FC_DEVICE_PGAD_BT_TID_MASK              = 0x000000FF,",
          "1045:     MPI_FC_DEVICE_PGAD_BT_TID_SHIFT             = 0,",
          "1047:     MPI_PHYSDISK_PGAD_PHYSDISKNUM_MASK          = 0x000000FF,",
          "1048:     MPI_PHYSDISK_PGAD_PHYSDISKNUM_SHIFT         = 0,",
          "1050:     MPI_SAS_EXPAND_PGAD_FORM_MASK             = 0xF0000000,",
          "1051:     MPI_SAS_EXPAND_PGAD_FORM_SHIFT            = 28,",
          "1052:     MPI_SAS_EXPAND_PGAD_FORM_GET_NEXT_HANDLE  = 0x00000000,",
          "1053:     MPI_SAS_EXPAND_PGAD_FORM_HANDLE_PHY_NUM   = 0x00000001,",
          "1054:     MPI_SAS_EXPAND_PGAD_FORM_HANDLE           = 0x00000002,",
          "1055:     MPI_SAS_EXPAND_PGAD_GNH_MASK_HANDLE       = 0x0000FFFF,",
          "1056:     MPI_SAS_EXPAND_PGAD_GNH_SHIFT_HANDLE      = 0,",
          "1057:     MPI_SAS_EXPAND_PGAD_HPN_MASK_PHY          = 0x00FF0000,",
          "1058:     MPI_SAS_EXPAND_PGAD_HPN_SHIFT_PHY         = 16,",
          "1059:     MPI_SAS_EXPAND_PGAD_HPN_MASK_HANDLE       = 0x0000FFFF,",
          "1060:     MPI_SAS_EXPAND_PGAD_HPN_SHIFT_HANDLE      = 0,",
          "1061:     MPI_SAS_EXPAND_PGAD_H_MASK_HANDLE         = 0x0000FFFF,",
          "1062:     MPI_SAS_EXPAND_PGAD_H_SHIFT_HANDLE        = 0,",
          "1064:     MPI_SAS_DEVICE_PGAD_FORM_MASK               = 0xF0000000,",
          "1065:     MPI_SAS_DEVICE_PGAD_FORM_SHIFT              = 28,",
          "1066:     MPI_SAS_DEVICE_PGAD_FORM_GET_NEXT_HANDLE    = 0x00000000,",
          "1067:     MPI_SAS_DEVICE_PGAD_FORM_BUS_TARGET_ID      = 0x00000001,",
          "1068:     MPI_SAS_DEVICE_PGAD_FORM_HANDLE             = 0x00000002,",
          "1069:     MPI_SAS_DEVICE_PGAD_GNH_HANDLE_MASK         = 0x0000FFFF,",
          "1070:     MPI_SAS_DEVICE_PGAD_GNH_HANDLE_SHIFT        = 0,",
          "1071:     MPI_SAS_DEVICE_PGAD_BT_BUS_MASK             = 0x0000FF00,",
          "1072:     MPI_SAS_DEVICE_PGAD_BT_BUS_SHIFT            = 8,",
          "1073:     MPI_SAS_DEVICE_PGAD_BT_TID_MASK             = 0x000000FF,",
          "1074:     MPI_SAS_DEVICE_PGAD_BT_TID_SHIFT            = 0,",
          "1075:     MPI_SAS_DEVICE_PGAD_H_HANDLE_MASK           = 0x0000FFFF,",
          "1076:     MPI_SAS_DEVICE_PGAD_H_HANDLE_SHIFT          = 0,",
          "1078:     MPI_SAS_PHY_PGAD_FORM_MASK                  = 0xF0000000,",
          "1079:     MPI_SAS_PHY_PGAD_FORM_SHIFT                 = 28,",
          "1080:     MPI_SAS_PHY_PGAD_FORM_PHY_NUMBER            = 0x0,",
          "1081:     MPI_SAS_PHY_PGAD_FORM_PHY_TBL_INDEX         = 0x1,",
          "1082:     MPI_SAS_PHY_PGAD_PHY_NUMBER_MASK            = 0x000000FF,",
          "1083:     MPI_SAS_PHY_PGAD_PHY_NUMBER_SHIFT           = 0,",
          "1084:     MPI_SAS_PHY_PGAD_PHY_TBL_INDEX_MASK         = 0x0000FFFF,",
          "1085:     MPI_SAS_PHY_PGAD_PHY_TBL_INDEX_SHIFT        = 0,",
          "1087:     MPI_SAS_ENCLOS_PGAD_FORM_MASK               = 0xF0000000,",
          "1088:     MPI_SAS_ENCLOS_PGAD_FORM_SHIFT              = 28,",
          "1089:     MPI_SAS_ENCLOS_PGAD_FORM_GET_NEXT_HANDLE    = 0x00000000,",
          "1090:     MPI_SAS_ENCLOS_PGAD_FORM_HANDLE             = 0x00000001,",
          "1091:     MPI_SAS_ENCLOS_PGAD_GNH_HANDLE_MASK         = 0x0000FFFF,",
          "1092:     MPI_SAS_ENCLOS_PGAD_GNH_HANDLE_SHIFT        = 0,",
          "1093:     MPI_SAS_ENCLOS_PGAD_H_HANDLE_MASK           = 0x0000FFFF,",
          "1094:     MPI_SAS_ENCLOS_PGAD_H_HANDLE_SHIFT          = 0,",
          "1095: };",
          "1105: enum {",
          "1107:     MPI_FW_HEADER_PID_TYPE_MASK                     = 0xF000,",
          "1108:     MPI_FW_HEADER_PID_TYPE_SCSI                     = 0x0000,",
          "1109:     MPI_FW_HEADER_PID_TYPE_FC                       = 0x1000,",
          "1110:     MPI_FW_HEADER_PID_TYPE_SAS                      = 0x2000,",
          "1112:     MPI_FW_HEADER_PID_PROD_MASK                     = 0x0F00,",
          "1113:     MPI_FW_HEADER_PID_PROD_INITIATOR_SCSI           = 0x0100,",
          "1114:     MPI_FW_HEADER_PID_PROD_TARGET_INITIATOR_SCSI    = 0x0200,",
          "1115:     MPI_FW_HEADER_PID_PROD_TARGET_SCSI              = 0x0300,",
          "1116:     MPI_FW_HEADER_PID_PROD_IM_SCSI                  = 0x0400,",
          "1117:     MPI_FW_HEADER_PID_PROD_IS_SCSI                  = 0x0500,",
          "1118:     MPI_FW_HEADER_PID_PROD_CTX_SCSI                 = 0x0600,",
          "1119:     MPI_FW_HEADER_PID_PROD_IR_SCSI                  = 0x0700,",
          "1121:     MPI_FW_HEADER_PID_FAMILY_MASK                   = 0x00FF,",
          "1124:     MPI_FW_HEADER_PID_FAMILY_1030A0_SCSI            = 0x0001,",
          "1125:     MPI_FW_HEADER_PID_FAMILY_1030B0_SCSI            = 0x0002,",
          "1126:     MPI_FW_HEADER_PID_FAMILY_1030B1_SCSI            = 0x0003,",
          "1127:     MPI_FW_HEADER_PID_FAMILY_1030C0_SCSI            = 0x0004,",
          "1128:     MPI_FW_HEADER_PID_FAMILY_1020A0_SCSI            = 0x0005,",
          "1129:     MPI_FW_HEADER_PID_FAMILY_1020B0_SCSI            = 0x0006,",
          "1130:     MPI_FW_HEADER_PID_FAMILY_1020B1_SCSI            = 0x0007,",
          "1131:     MPI_FW_HEADER_PID_FAMILY_1020C0_SCSI            = 0x0008,",
          "1132:     MPI_FW_HEADER_PID_FAMILY_1035A0_SCSI            = 0x0009,",
          "1133:     MPI_FW_HEADER_PID_FAMILY_1035B0_SCSI            = 0x000A,",
          "1134:     MPI_FW_HEADER_PID_FAMILY_1030TA0_SCSI           = 0x000B,",
          "1135:     MPI_FW_HEADER_PID_FAMILY_1020TA0_SCSI           = 0x000C,",
          "1138:     MPI_FW_HEADER_PID_FAMILY_909_FC                 = 0x0000,",
          "1143:     MPI_FW_HEADER_PID_FAMILY_959_FC                 = 0x0005,",
          "1144:     MPI_FW_HEADER_PID_FAMILY_949E_FC                = 0x0006,",
          "1147:     MPI_FW_HEADER_PID_FAMILY_1064_SAS               = 0x0001,",
          "1148:     MPI_FW_HEADER_PID_FAMILY_1068_SAS               = 0x0002,",
          "1149:     MPI_FW_HEADER_PID_FAMILY_1078_SAS               = 0x0003,",
          "1151: };",
          "1153: #endif",
          "",
          "---------------"
        ],
        "hw/scsi/mptconfig.c||hw/scsi/mptconfig.c": [
          "File: hw/scsi/mptconfig.c -> hw/scsi/mptconfig.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18: #include \"qemu/osdep.h\"",
          "19: #include \"hw/hw.h\"",
          "20: #include \"hw/pci/pci.h\"",
          "21: #include \"hw/scsi/scsi.h\"",
          "23: #include \"mptsas.h\"",
          "24: #include \"mpi.h\"",
          "25: #include \"trace.h\"",
          "29: #define repl1(x) x",
          "30: #define repl2(x) x x",
          "31: #define repl3(x) x x x",
          "32: #define repl4(x) x x x x",
          "33: #define repl5(x) x x x x x",
          "34: #define repl6(x) x x x x x x",
          "35: #define repl7(x) x x x x x x x",
          "36: #define repl8(x) x x x x x x x x",
          "38: #define repl(n, x) glue(repl, n)(x)",
          "40: typedef union PackValue {",
          "41:     uint64_t ll;",
          "42:     char *str;",
          "43: } PackValue;",
          "45: static size_t vfill(uint8_t *data, size_t size, const char *fmt, va_list ap)",
          "46: {",
          "47:     size_t ofs;",
          "48:     PackValue val;",
          "49:     const char *p;",
          "51:     ofs = 0;",
          "52:     p = fmt;",
          "53:     while (*p) {",
          "54:         memset(&val, 0, sizeof(val));",
          "55:         switch (*p) {",
          "56:         case '*':",
          "57:             p++;",
          "58:             break;",
          "59:         case 'b':",
          "60:         case 'w':",
          "61:         case 'l':",
          "62:             val.ll = va_arg(ap, int);",
          "63:             break;",
          "64:         case 'q':",
          "65:             val.ll = va_arg(ap, int64_t);",
          "66:             break;",
          "67:         case 's':",
          "68:             val.str = va_arg(ap, void *);",
          "69:             break;",
          "70:         }",
          "71:         switch (*p++) {",
          "72:         case 'b':",
          "73:             if (data) {",
          "74:                 stb_p(data + ofs, val.ll);",
          "75:             }",
          "76:             ofs++;",
          "77:             break;",
          "78:         case 'w':",
          "79:             if (data) {",
          "80:                 stw_le_p(data + ofs, val.ll);",
          "81:             }",
          "82:             ofs += 2;",
          "83:             break;",
          "84:         case 'l':",
          "85:             if (data) {",
          "86:                 stl_le_p(data + ofs, val.ll);",
          "87:             }",
          "88:             ofs += 4;",
          "89:             break;",
          "90:         case 'q':",
          "91:             if (data) {",
          "92:                 stq_le_p(data + ofs, val.ll);",
          "93:             }",
          "94:             ofs += 8;",
          "95:             break;",
          "96:         case 's':",
          "97:             {",
          "98:                 int cnt = atoi(p);",
          "99:                 if (data) {",
          "100:                     if (val.str) {",
          "101:                         strncpy((void *)data + ofs, val.str, cnt);",
          "102:                     } else {",
          "103:                         memset((void *)data + ofs, 0, cnt);",
          "104:                     }",
          "105:                 }",
          "106:                 ofs += cnt;",
          "107:                 break;",
          "108:             }",
          "109:         }",
          "110:     }",
          "112:     return ofs;",
          "113: }",
          "115: static size_t vpack(uint8_t **p_data, const char *fmt, va_list ap1)",
          "116: {",
          "117:     size_t size = 0;",
          "118:     uint8_t *data = NULL;",
          "120:     if (p_data) {",
          "121:         va_list ap2;",
          "123:         va_copy(ap2, ap1);",
          "124:         size = vfill(NULL, 0, fmt, ap2);",
          "126:     }",
          "127:     return vfill(data, size, fmt, ap1);",
          "128: }",
          "130: static size_t fill(uint8_t *data, size_t size, const char *fmt, ...)",
          "131: {",
          "132:     va_list ap;",
          "133:     size_t ret;",
          "135:     va_start(ap, fmt);",
          "136:     ret = vfill(data, size, fmt, ap);",
          "137:     va_end(ap);",
          "139:     return ret;",
          "140: }",
          "146: #define MPTSAS_CONFIG_PACK(number, type, version, fmt, ...)                  \\",
          "147:     mptsas_config_pack(data, \"b*bbb\" fmt, version, number, type,             \\",
          "148:                        ## __VA_ARGS__)",
          "150: static size_t mptsas_config_pack(uint8_t **data, const char *fmt, ...)",
          "151: {",
          "152:     va_list ap;",
          "153:     size_t ret;",
          "155:     va_start(ap, fmt);",
          "156:     ret = vpack(data, fmt, ap);",
          "157:     va_end(ap);",
          "159:     if (data) {",
          "160:         assert(ret < 256 && (ret % 4) == 0);",
          "161:         stb_p(*data + 1, ret / 4);",
          "162:     }",
          "163:     return ret;",
          "164: }",
          "166: #define MPTSAS_CONFIG_PACK_EXT(number, type, version, fmt, ...)              \\",
          "167:     mptsas_config_pack_ext(data, \"b*bbb*wb*b\" fmt, version, number,          \\",
          "168:                            MPI_CONFIG_PAGETYPE_EXTENDED, type, ## __VA_ARGS__)",
          "170: static size_t mptsas_config_pack_ext(uint8_t **data, const char *fmt, ...)",
          "171: {",
          "172:     va_list ap;",
          "173:     size_t ret;",
          "175:     va_start(ap, fmt);",
          "176:     ret = vpack(data, fmt, ap);",
          "177:     va_end(ap);",
          "179:     if (data) {",
          "180:         assert(ret < 65536 && (ret % 4) == 0);",
          "181:         stw_le_p(*data + 4, ret / 4);",
          "182:     }",
          "183:     return ret;",
          "184: }",
          "188: static",
          "189: size_t mptsas_config_manufacturing_0(MPTSASState *s, uint8_t **data, int address)",
          "190: {",
          "191:     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,",
          "192:                               \"s16s8s16s16s16\",",
          "193:                               \"QEMU MPT Fusion\",",
          "194:                               \"2.5\",",
          "195:                               \"QEMU MPT Fusion\",",
          "196:                               \"QEMU\",",
          "197:                               \"0000111122223333\");",
          "198: }",
          "200: static",
          "201: size_t mptsas_config_manufacturing_1(MPTSASState *s, uint8_t **data, int address)",
          "202: {",
          "204:     return MPTSAS_CONFIG_PACK(1, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,",
          "205:                               \"s256\");",
          "206: }",
          "208: static",
          "209: size_t mptsas_config_manufacturing_2(MPTSASState *s, uint8_t **data, int address)",
          "210: {",
          "211:     PCIDeviceClass *pcic = PCI_DEVICE_GET_CLASS(s);",
          "212:     return MPTSAS_CONFIG_PACK(2, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,",
          "213:                               \"wb*b*l\",",
          "214:                               pcic->device_id, pcic->revision);",
          "215: }",
          "217: static",
          "218: size_t mptsas_config_manufacturing_3(MPTSASState *s, uint8_t **data, int address)",
          "219: {",
          "220:     PCIDeviceClass *pcic = PCI_DEVICE_GET_CLASS(s);",
          "221:     return MPTSAS_CONFIG_PACK(3, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,",
          "222:                               \"wb*b*l\",",
          "223:                               pcic->device_id, pcic->revision);",
          "224: }",
          "226: static",
          "227: size_t mptsas_config_manufacturing_4(MPTSASState *s, uint8_t **data, int address)",
          "228: {",
          "230:     return MPTSAS_CONFIG_PACK(4, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x05,",
          "231:                               \"*l*b*b*b*b*b*b*w*s56*l*l*l*l*l*l\"",
          "232:                               \"*b*b*w*b*b*w*l*l\");",
          "233: }",
          "235: static",
          "236: size_t mptsas_config_manufacturing_5(MPTSASState *s, uint8_t **data, int address)",
          "237: {",
          "238:     return MPTSAS_CONFIG_PACK(5, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x02,",
          "239:                               \"q*b*b*w*l*l\", s->sas_addr);",
          "240: }",
          "242: static",
          "243: size_t mptsas_config_manufacturing_6(MPTSASState *s, uint8_t **data, int address)",
          "244: {",
          "245:     return MPTSAS_CONFIG_PACK(6, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,",
          "246:                               \"*l\");",
          "247: }",
          "249: static",
          "250: size_t mptsas_config_manufacturing_7(MPTSASState *s, uint8_t **data, int address)",
          "251: {",
          "252:     return MPTSAS_CONFIG_PACK(7, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,",
          "253:                               \"*l*l*l*s16*b*b*w\", MPTSAS_NUM_PORTS);",
          "254: }",
          "256: static",
          "257: size_t mptsas_config_manufacturing_8(MPTSASState *s, uint8_t **data, int address)",
          "258: {",
          "259:     return MPTSAS_CONFIG_PACK(8, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,",
          "260:                               \"*l\");",
          "261: }",
          "263: static",
          "264: size_t mptsas_config_manufacturing_9(MPTSASState *s, uint8_t **data, int address)",
          "265: {",
          "266:     return MPTSAS_CONFIG_PACK(9, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,",
          "267:                               \"*l\");",
          "268: }",
          "270: static",
          "271: size_t mptsas_config_manufacturing_10(MPTSASState *s, uint8_t **data, int address)",
          "272: {",
          "273:     return MPTSAS_CONFIG_PACK(10, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,",
          "274:                               \"*l\");",
          "275: }",
          "279: static",
          "280: size_t mptsas_config_io_unit_0(MPTSASState *s, uint8_t **data, int address)",
          "281: {",
          "282:     PCIDevice *pci = PCI_DEVICE(s);",
          "285:     unique_value |= (uint64_t)pci->devfn << 56;",
          "286:     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_IO_UNIT, 0x00,",
          "287:                               \"q\", unique_value);",
          "288: }",
          "290: static",
          "291: size_t mptsas_config_io_unit_1(MPTSASState *s, uint8_t **data, int address)",
          "292: {",
          "293:     return MPTSAS_CONFIG_PACK(1, MPI_CONFIG_PAGETYPE_IO_UNIT, 0x02, \"l\",",
          "294:                               0x41 /* single function, RAID disabled */ );",
          "295: }",
          "297: static",
          "298: size_t mptsas_config_io_unit_2(MPTSASState *s, uint8_t **data, int address)",
          "299: {",
          "300:     PCIDevice *pci = PCI_DEVICE(s);",
          "301:     uint8_t devfn = pci->devfn;",
          "302:     return MPTSAS_CONFIG_PACK(2, MPI_CONFIG_PAGETYPE_IO_UNIT, 0x02,",
          "303:                               \"llbbw*b*b*w*b*b*w*b*b*w*l\",",
          "304:                               0, 0x100, 0 /* pci bus? */, devfn, 0);",
          "305: }",
          "307: static",
          "308: size_t mptsas_config_io_unit_3(MPTSASState *s, uint8_t **data, int address)",
          "309: {",
          "310:     return MPTSAS_CONFIG_PACK(3, MPI_CONFIG_PAGETYPE_IO_UNIT, 0x01,",
          "311:                               \"*b*b*w*l\");",
          "312: }",
          "314: static",
          "315: size_t mptsas_config_io_unit_4(MPTSASState *s, uint8_t **data, int address)",
          "316: {",
          "317:     return MPTSAS_CONFIG_PACK(4, MPI_CONFIG_PAGETYPE_IO_UNIT, 0x00, \"*l*l*q\");",
          "318: }",
          "322: static",
          "323: size_t mptsas_config_ioc_0(MPTSASState *s, uint8_t **data, int address)",
          "324: {",
          "325:     PCIDeviceClass *pcic = PCI_DEVICE_GET_CLASS(s);",
          "327:     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_IOC, 0x01,",
          "328:                               \"*l*lwwb*b*b*blww\",",
          "329:                               pcic->vendor_id, pcic->device_id, pcic->revision,",
          "330:                               pcic->subsystem_vendor_id,",
          "331:                               pcic->subsystem_id);",
          "332: }",
          "334: static",
          "335: size_t mptsas_config_ioc_1(MPTSASState *s, uint8_t **data, int address)",
          "336: {",
          "337:     return MPTSAS_CONFIG_PACK(1, MPI_CONFIG_PAGETYPE_IOC, 0x03,",
          "338:                               \"*l*l*b*b*b*b\");",
          "339: }",
          "341: static",
          "342: size_t mptsas_config_ioc_2(MPTSASState *s, uint8_t **data, int address)",
          "343: {",
          "344:     return MPTSAS_CONFIG_PACK(2, MPI_CONFIG_PAGETYPE_IOC, 0x04,",
          "345:                               \"*l*b*b*b*b\");",
          "346: }",
          "348: static",
          "349: size_t mptsas_config_ioc_3(MPTSASState *s, uint8_t **data, int address)",
          "350: {",
          "351:     return MPTSAS_CONFIG_PACK(3, MPI_CONFIG_PAGETYPE_IOC, 0x00,",
          "352:                               \"*b*b*w\");",
          "353: }",
          "355: static",
          "356: size_t mptsas_config_ioc_4(MPTSASState *s, uint8_t **data, int address)",
          "357: {",
          "358:     return MPTSAS_CONFIG_PACK(4, MPI_CONFIG_PAGETYPE_IOC, 0x00,",
          "359:                               \"*b*b*w\");",
          "360: }",
          "362: static",
          "363: size_t mptsas_config_ioc_5(MPTSASState *s, uint8_t **data, int address)",
          "364: {",
          "365:     return MPTSAS_CONFIG_PACK(5, MPI_CONFIG_PAGETYPE_IOC, 0x00,",
          "366:                               \"*l*b*b*w\");",
          "367: }",
          "369: static",
          "370: size_t mptsas_config_ioc_6(MPTSASState *s, uint8_t **data, int address)",
          "371: {",
          "372:     return MPTSAS_CONFIG_PACK(6, MPI_CONFIG_PAGETYPE_IOC, 0x01,",
          "373:                               \"*l*b*b*b*b*b*b*b*b*b*b*w*l*l*l*l*b*b*w\"",
          "374:                               \"*w*w*w*w*l*l*l\");",
          "375: }",
          "379: #define MPTSAS_CONFIG_SAS_IO_UNIT_0_SIZE 16",
          "381: #define MPI_SAS_IOUNIT0_RATE_FAILED_SPEED_NEGOTIATION 0x02",
          "382: #define MPI_SAS_IOUNIT0_RATE_1_5                      0x08",
          "383: #define MPI_SAS_IOUNIT0_RATE_3_0                      0x09",
          "385: #define MPI_SAS_DEVICE_INFO_NO_DEVICE                 0x00000000",
          "386: #define MPI_SAS_DEVICE_INFO_END_DEVICE                0x00000001",
          "387: #define MPI_SAS_DEVICE_INFO_SSP_TARGET                0x00000400",
          "389: #define MPI_SAS_DEVICE0_ASTATUS_NO_ERRORS             0x00",
          "391: #define MPI_SAS_DEVICE0_FLAGS_DEVICE_PRESENT          0x0001",
          "392: #define MPI_SAS_DEVICE0_FLAGS_DEVICE_MAPPED           0x0002",
          "393: #define MPI_SAS_DEVICE0_FLAGS_MAPPING_PERSISTENT      0x0004",
          "397: static SCSIDevice *mptsas_phy_get_device(MPTSASState *s, int i,",
          "398:                                          int *phy_handle, int *dev_handle)",
          "399: {",
          "400:     SCSIDevice *d = scsi_device_find(&s->bus, 0, i, 0);",
          "402:     if (phy_handle) {",
          "404:     }",
          "405:     if (dev_handle) {",
          "407:     }",
          "408:     return d;",
          "409: }",
          "411: static",
          "412: size_t mptsas_config_sas_io_unit_0(MPTSASState *s, uint8_t **data, int address)",
          "413: {",
          "414:     size_t size = MPTSAS_CONFIG_PACK_EXT(0, MPI_CONFIG_EXTPAGETYPE_SAS_IO_UNIT, 0x04,",
          "415:                                          \"*w*wb*b*w\"",
          "416:                                          repl(MPTSAS_NUM_PORTS, \"*s16\"),",
          "417:                                          MPTSAS_NUM_PORTS);",
          "419:     if (data) {",
          "420:         size_t ofs = size - MPTSAS_NUM_PORTS * MPTSAS_CONFIG_SAS_IO_UNIT_0_SIZE;",
          "421:         int i;",
          "423:         for (i = 0; i < MPTSAS_NUM_PORTS; i++) {",
          "424:             int phy_handle, dev_handle;",
          "425:             SCSIDevice *dev = mptsas_phy_get_device(s, i, &phy_handle, &dev_handle);",
          "427:             fill(*data + ofs, MPTSAS_CONFIG_SAS_IO_UNIT_0_SIZE,",
          "428:                  \"bbbblwwl\", i, 0, 0,",
          "429:                  (dev",
          "430:                   ? MPI_SAS_IOUNIT0_RATE_3_0",
          "431:                   : MPI_SAS_IOUNIT0_RATE_FAILED_SPEED_NEGOTIATION),",
          "432:                  (dev",
          "433:                   ? MPI_SAS_DEVICE_INFO_END_DEVICE | MPI_SAS_DEVICE_INFO_SSP_TARGET",
          "434:                   : MPI_SAS_DEVICE_INFO_NO_DEVICE),",
          "435:                  dev_handle,",
          "436:                  dev_handle,",
          "437:                  0);",
          "438:             ofs += MPTSAS_CONFIG_SAS_IO_UNIT_0_SIZE;",
          "439:         }",
          "440:         assert(ofs == size);",
          "441:     }",
          "442:     return size;",
          "443: }",
          "445: #define MPTSAS_CONFIG_SAS_IO_UNIT_1_SIZE 12",
          "447: static",
          "448: size_t mptsas_config_sas_io_unit_1(MPTSASState *s, uint8_t **data, int address)",
          "449: {",
          "450:     size_t size = MPTSAS_CONFIG_PACK_EXT(1, MPI_CONFIG_EXTPAGETYPE_SAS_IO_UNIT, 0x07,",
          "451:                                          \"*w*w*w*wb*b*b*b\"",
          "452:                                          repl(MPTSAS_NUM_PORTS, \"*s12\"),",
          "453:                                          MPTSAS_NUM_PORTS);",
          "455:     if (data) {",
          "456:         size_t ofs = size - MPTSAS_NUM_PORTS * MPTSAS_CONFIG_SAS_IO_UNIT_1_SIZE;",
          "457:         int i;",
          "459:         for (i = 0; i < MPTSAS_NUM_PORTS; i++) {",
          "460:             SCSIDevice *dev = mptsas_phy_get_device(s, i, NULL, NULL);",
          "461:             fill(*data + ofs, MPTSAS_CONFIG_SAS_IO_UNIT_1_SIZE,",
          "462:                  \"bbbblww\", i, 0, 0,",
          "463:                  (MPI_SAS_IOUNIT0_RATE_3_0 << 4) | MPI_SAS_IOUNIT0_RATE_1_5,",
          "464:                  (dev",
          "465:                   ? MPI_SAS_DEVICE_INFO_END_DEVICE | MPI_SAS_DEVICE_INFO_SSP_TARGET",
          "466:                   : MPI_SAS_DEVICE_INFO_NO_DEVICE),",
          "467:                  0, 0);",
          "468:             ofs += MPTSAS_CONFIG_SAS_IO_UNIT_1_SIZE;",
          "469:         }",
          "470:         assert(ofs == size);",
          "471:     }",
          "472:     return size;",
          "473: }",
          "475: static",
          "476: size_t mptsas_config_sas_io_unit_2(MPTSASState *s, uint8_t **data, int address)",
          "477: {",
          "478:     return MPTSAS_CONFIG_PACK_EXT(2, MPI_CONFIG_EXTPAGETYPE_SAS_IO_UNIT, 0x06,",
          "479:                                   \"*b*b*w*w*w*b*b*w\");",
          "480: }",
          "482: static",
          "483: size_t mptsas_config_sas_io_unit_3(MPTSASState *s, uint8_t **data, int address)",
          "484: {",
          "485:     return MPTSAS_CONFIG_PACK_EXT(3, MPI_CONFIG_EXTPAGETYPE_SAS_IO_UNIT, 0x06,",
          "486:                                   \"*l*l*l*l*l*l*l*l*l\");",
          "487: }",
          "491: static int mptsas_phy_addr_get(MPTSASState *s, int address)",
          "492: {",
          "493:     int i;",
          "494:     if ((address >> MPI_SAS_PHY_PGAD_FORM_SHIFT) == 0) {",
          "495:         i = address & 255;",
          "496:     } else if ((address >> MPI_SAS_PHY_PGAD_FORM_SHIFT) == 1) {",
          "497:         i = address & 65535;",
          "498:     } else {",
          "499:         return -EINVAL;",
          "500:     }",
          "502:     if (i >= MPTSAS_NUM_PORTS) {",
          "503:         return -EINVAL;",
          "504:     }",
          "506:     return i;",
          "507: }",
          "509: static",
          "510: size_t mptsas_config_phy_0(MPTSASState *s, uint8_t **data, int address)",
          "511: {",
          "512:     int phy_handle = -1;",
          "513:     int dev_handle = -1;",
          "514:     int i = mptsas_phy_addr_get(s, address);",
          "515:     SCSIDevice *dev;",
          "517:     if (i < 0) {",
          "518:         trace_mptsas_config_sas_phy(s, address, i, phy_handle, dev_handle, 0);",
          "519:         return i;",
          "520:     }",
          "522:     dev = mptsas_phy_get_device(s, i, &phy_handle, &dev_handle);",
          "523:     trace_mptsas_config_sas_phy(s, address, i, phy_handle, dev_handle, 0);",
          "525:     return MPTSAS_CONFIG_PACK_EXT(0, MPI_CONFIG_EXTPAGETYPE_SAS_PHY, 0x01,",
          "526:                                   \"w*wqwb*blbb*b*b*l\",",
          "527:                                   dev_handle, s->sas_addr, dev_handle, i,",
          "528:                                   (dev",
          "530:                                    : MPI_SAS_DEVICE_INFO_NO_DEVICE),",
          "531:                                   (MPI_SAS_IOUNIT0_RATE_3_0 << 4) | MPI_SAS_IOUNIT0_RATE_1_5,",
          "532:                                   (MPI_SAS_IOUNIT0_RATE_3_0 << 4) | MPI_SAS_IOUNIT0_RATE_1_5);",
          "533: }",
          "535: static",
          "536: size_t mptsas_config_phy_1(MPTSASState *s, uint8_t **data, int address)",
          "537: {",
          "538:     int phy_handle = -1;",
          "539:     int dev_handle = -1;",
          "540:     int i = mptsas_phy_addr_get(s, address);",
          "542:     if (i < 0) {",
          "543:         trace_mptsas_config_sas_phy(s, address, i, phy_handle, dev_handle, 1);",
          "544:         return i;",
          "545:     }",
          "547:     (void) mptsas_phy_get_device(s, i, &phy_handle, &dev_handle);",
          "548:     trace_mptsas_config_sas_phy(s, address, i, phy_handle, dev_handle, 1);",
          "550:     return MPTSAS_CONFIG_PACK_EXT(1, MPI_CONFIG_EXTPAGETYPE_SAS_PHY, 0x01,",
          "551:                                   \"*l*l*l*l*l\");",
          "552: }",
          "556: static int mptsas_device_addr_get(MPTSASState *s, int address)",
          "557: {",
          "558:     uint32_t handle, i;",
          "559:     uint32_t form = address >> MPI_SAS_PHY_PGAD_FORM_SHIFT;",
          "560:     if (form == MPI_SAS_DEVICE_PGAD_FORM_GET_NEXT_HANDLE) {",
          "561:         handle = address & MPI_SAS_DEVICE_PGAD_GNH_HANDLE_MASK;",
          "562:         do {",
          "563:             if (handle == 65535) {",
          "564:                 handle = MPTSAS_NUM_PORTS + 1;",
          "565:             } else {",
          "566:                 ++handle;",
          "567:             }",
          "568:             i = handle - 1 - MPTSAS_NUM_PORTS;",
          "569:         } while (i < MPTSAS_NUM_PORTS && !scsi_device_find(&s->bus, 0, i, 0));",
          "571:     } else if (form == MPI_SAS_DEVICE_PGAD_FORM_BUS_TARGET_ID) {",
          "572:         if (address & MPI_SAS_DEVICE_PGAD_BT_BUS_MASK) {",
          "573:             return -EINVAL;",
          "574:         }",
          "575:         i = address & MPI_SAS_DEVICE_PGAD_BT_TID_MASK;",
          "577:     } else if (form == MPI_SAS_DEVICE_PGAD_FORM_HANDLE) {",
          "578:         handle = address & MPI_SAS_DEVICE_PGAD_H_HANDLE_MASK;",
          "579:         i = handle - 1 - MPTSAS_NUM_PORTS;",
          "581:     } else {",
          "582:         return -EINVAL;",
          "583:     }",
          "585:     if (i >= MPTSAS_NUM_PORTS) {",
          "586:         return -EINVAL;",
          "587:     }",
          "589:     return i;",
          "590: }",
          "592: static",
          "593: size_t mptsas_config_sas_device_0(MPTSASState *s, uint8_t **data, int address)",
          "594: {",
          "595:     int phy_handle = -1;",
          "596:     int dev_handle = -1;",
          "597:     int i = mptsas_device_addr_get(s, address);",
          "598:     SCSIDevice *dev = mptsas_phy_get_device(s, i, &phy_handle, &dev_handle);",
          "600:     trace_mptsas_config_sas_device(s, address, i, phy_handle, dev_handle, 0);",
          "601:     if (!dev) {",
          "602:         return -ENOENT;",
          "603:     }",
          "605:     return MPTSAS_CONFIG_PACK_EXT(0, MPI_CONFIG_EXTPAGETYPE_SAS_DEVICE, 0x05,",
          "606:                                   \"*w*wqwbbwbblwb*b\",",
          "607:                                   dev->wwn, phy_handle, i,",
          "608:                                   MPI_SAS_DEVICE0_ASTATUS_NO_ERRORS,",
          "609:                                   dev_handle, i, 0,",
          "610:                                   MPI_SAS_DEVICE_INFO_END_DEVICE | MPI_SAS_DEVICE_INFO_SSP_TARGET,",
          "611:                                   (MPI_SAS_DEVICE0_FLAGS_DEVICE_PRESENT |",
          "612:                                    MPI_SAS_DEVICE0_FLAGS_DEVICE_MAPPED |",
          "613:                                    MPI_SAS_DEVICE0_FLAGS_MAPPING_PERSISTENT), i);",
          "614: }",
          "616: static",
          "617: size_t mptsas_config_sas_device_1(MPTSASState *s, uint8_t **data, int address)",
          "618: {",
          "619:     int phy_handle = -1;",
          "620:     int dev_handle = -1;",
          "621:     int i = mptsas_device_addr_get(s, address);",
          "622:     SCSIDevice *dev = mptsas_phy_get_device(s, i, &phy_handle, &dev_handle);",
          "624:     trace_mptsas_config_sas_device(s, address, i, phy_handle, dev_handle, 1);",
          "625:     if (!dev) {",
          "626:         return -ENOENT;",
          "627:     }",
          "629:     return MPTSAS_CONFIG_PACK_EXT(1, MPI_CONFIG_EXTPAGETYPE_SAS_DEVICE, 0x00,",
          "630:                                   \"*lq*lwbb*s20\",",
          "631:                                   dev->wwn, dev_handle, i, 0);",
          "632: }",
          "634: static",
          "635: size_t mptsas_config_sas_device_2(MPTSASState *s, uint8_t **data, int address)",
          "636: {",
          "637:     int phy_handle = -1;",
          "638:     int dev_handle = -1;",
          "639:     int i = mptsas_device_addr_get(s, address);",
          "640:     SCSIDevice *dev = mptsas_phy_get_device(s, i, &phy_handle, &dev_handle);",
          "642:     trace_mptsas_config_sas_device(s, address, i, phy_handle, dev_handle, 2);",
          "643:     if (!dev) {",
          "644:         return -ENOENT;",
          "645:     }",
          "647:     return MPTSAS_CONFIG_PACK_EXT(2, MPI_CONFIG_EXTPAGETYPE_SAS_DEVICE, 0x01,",
          "648:                                   \"ql\", dev->wwn, 0);",
          "649: }",
          "651: typedef struct MPTSASConfigPage {",
          "652:     uint8_t number;",
          "653:     uint8_t type;",
          "654:     size_t (*mpt_config_build)(MPTSASState *s, uint8_t **data, int address);",
          "655: } MPTSASConfigPage;",
          "657: static const MPTSASConfigPage mptsas_config_pages[] = {",
          "658:     {",
          "659:         0, MPI_CONFIG_PAGETYPE_MANUFACTURING,",
          "660:         mptsas_config_manufacturing_0,",
          "661:     }, {",
          "662:         1, MPI_CONFIG_PAGETYPE_MANUFACTURING,",
          "663:         mptsas_config_manufacturing_1,",
          "664:     }, {",
          "665:         2, MPI_CONFIG_PAGETYPE_MANUFACTURING,",
          "666:         mptsas_config_manufacturing_2,",
          "667:     }, {",
          "668:         3, MPI_CONFIG_PAGETYPE_MANUFACTURING,",
          "669:         mptsas_config_manufacturing_3,",
          "670:     }, {",
          "671:         4, MPI_CONFIG_PAGETYPE_MANUFACTURING,",
          "672:         mptsas_config_manufacturing_4,",
          "673:     }, {",
          "674:         5, MPI_CONFIG_PAGETYPE_MANUFACTURING,",
          "675:         mptsas_config_manufacturing_5,",
          "676:     }, {",
          "677:         6, MPI_CONFIG_PAGETYPE_MANUFACTURING,",
          "678:         mptsas_config_manufacturing_6,",
          "679:     }, {",
          "680:         7, MPI_CONFIG_PAGETYPE_MANUFACTURING,",
          "681:         mptsas_config_manufacturing_7,",
          "682:     }, {",
          "683:         8, MPI_CONFIG_PAGETYPE_MANUFACTURING,",
          "684:         mptsas_config_manufacturing_8,",
          "685:     }, {",
          "686:         9, MPI_CONFIG_PAGETYPE_MANUFACTURING,",
          "687:         mptsas_config_manufacturing_9,",
          "688:     }, {",
          "689:         10, MPI_CONFIG_PAGETYPE_MANUFACTURING,",
          "690:         mptsas_config_manufacturing_10,",
          "691:     }, {",
          "692:         0, MPI_CONFIG_PAGETYPE_IO_UNIT,",
          "693:         mptsas_config_io_unit_0,",
          "694:     }, {",
          "695:         1, MPI_CONFIG_PAGETYPE_IO_UNIT,",
          "696:         mptsas_config_io_unit_1,",
          "697:     }, {",
          "698:         2, MPI_CONFIG_PAGETYPE_IO_UNIT,",
          "699:         mptsas_config_io_unit_2,",
          "700:     }, {",
          "701:         3, MPI_CONFIG_PAGETYPE_IO_UNIT,",
          "702:         mptsas_config_io_unit_3,",
          "703:     }, {",
          "704:         4, MPI_CONFIG_PAGETYPE_IO_UNIT,",
          "705:         mptsas_config_io_unit_4,",
          "706:     }, {",
          "707:         0, MPI_CONFIG_PAGETYPE_IOC,",
          "708:         mptsas_config_ioc_0,",
          "709:     }, {",
          "710:         1, MPI_CONFIG_PAGETYPE_IOC,",
          "711:         mptsas_config_ioc_1,",
          "712:     }, {",
          "713:         2, MPI_CONFIG_PAGETYPE_IOC,",
          "714:         mptsas_config_ioc_2,",
          "715:     }, {",
          "716:         3, MPI_CONFIG_PAGETYPE_IOC,",
          "717:         mptsas_config_ioc_3,",
          "718:     }, {",
          "719:         4, MPI_CONFIG_PAGETYPE_IOC,",
          "720:         mptsas_config_ioc_4,",
          "721:     }, {",
          "722:         5, MPI_CONFIG_PAGETYPE_IOC,",
          "723:         mptsas_config_ioc_5,",
          "724:     }, {",
          "725:         6, MPI_CONFIG_PAGETYPE_IOC,",
          "726:         mptsas_config_ioc_6,",
          "727:     }, {",
          "728:         0, MPI_CONFIG_EXTPAGETYPE_SAS_IO_UNIT,",
          "729:         mptsas_config_sas_io_unit_0,",
          "730:     }, {",
          "731:         1, MPI_CONFIG_EXTPAGETYPE_SAS_IO_UNIT,",
          "732:         mptsas_config_sas_io_unit_1,",
          "733:     }, {",
          "734:         2, MPI_CONFIG_EXTPAGETYPE_SAS_IO_UNIT,",
          "735:         mptsas_config_sas_io_unit_2,",
          "736:     }, {",
          "737:         3, MPI_CONFIG_EXTPAGETYPE_SAS_IO_UNIT,",
          "738:         mptsas_config_sas_io_unit_3,",
          "739:     }, {",
          "740:         0, MPI_CONFIG_EXTPAGETYPE_SAS_PHY,",
          "741:         mptsas_config_phy_0,",
          "742:     }, {",
          "743:         1, MPI_CONFIG_EXTPAGETYPE_SAS_PHY,",
          "744:         mptsas_config_phy_1,",
          "745:     }, {",
          "746:         0, MPI_CONFIG_EXTPAGETYPE_SAS_DEVICE,",
          "747:         mptsas_config_sas_device_0,",
          "748:     }, {",
          "749:         1, MPI_CONFIG_EXTPAGETYPE_SAS_DEVICE,",
          "750:         mptsas_config_sas_device_1,",
          "751:     }, {",
          "752:        2,  MPI_CONFIG_EXTPAGETYPE_SAS_DEVICE,",
          "753:         mptsas_config_sas_device_2,",
          "754:     }",
          "755: };",
          "757: static const MPTSASConfigPage *mptsas_find_config_page(int type, int number)",
          "758: {",
          "759:     const MPTSASConfigPage *page;",
          "760:     int i;",
          "762:     for (i = 0; i < ARRAY_SIZE(mptsas_config_pages); i++) {",
          "763:         page = &mptsas_config_pages[i];",
          "764:         if (page->type == type && page->number == number) {",
          "765:             return page;",
          "766:         }",
          "767:     }",
          "769:     return NULL;",
          "770: }",
          "772: void mptsas_process_config(MPTSASState *s, MPIMsgConfig *req)",
          "773: {",
          "774:     PCIDevice *pci = PCI_DEVICE(s);",
          "776:     MPIMsgConfigReply reply;",
          "777:     const MPTSASConfigPage *page;",
          "778:     size_t length;",
          "779:     uint8_t type;",
          "780:     uint8_t *data = NULL;",
          "781:     uint32_t flags_and_length;",
          "782:     uint32_t dmalen;",
          "783:     uint64_t pa;",
          "785:     mptsas_fix_config_endianness(req);",
          "787:     QEMU_BUILD_BUG_ON(sizeof(s->doorbell_msg) < sizeof(*req));",
          "788:     QEMU_BUILD_BUG_ON(sizeof(s->doorbell_reply) < sizeof(reply));",
          "791:     memset(&reply, 0, sizeof(reply));",
          "792:     reply.Action      = req->Action;",
          "793:     reply.Function    = req->Function;",
          "794:     reply.MsgContext  = req->MsgContext;",
          "795:     reply.MsgLength   = sizeof(reply) / 4;",
          "796:     reply.PageType    = req->PageType;",
          "797:     reply.PageNumber  = req->PageNumber;",
          "798:     reply.PageLength  = req->PageLength;",
          "799:     reply.PageVersion = req->PageVersion;",
          "801:     type = req->PageType & MPI_CONFIG_PAGETYPE_MASK;",
          "802:     if (type == MPI_CONFIG_PAGETYPE_EXTENDED) {",
          "803:         type = req->ExtPageType;",
          "804:         if (type <= MPI_CONFIG_PAGETYPE_MASK) {",
          "805:             reply.IOCStatus = MPI_IOCSTATUS_CONFIG_INVALID_TYPE;",
          "806:             goto out;",
          "807:         }",
          "809:         reply.ExtPageType = req->ExtPageType;",
          "810:     }",
          "812:     page = mptsas_find_config_page(type, req->PageNumber);",
          "814:     switch(req->Action) {",
          "815:     case MPI_CONFIG_ACTION_PAGE_DEFAULT:",
          "816:     case MPI_CONFIG_ACTION_PAGE_HEADER:",
          "817:     case MPI_CONFIG_ACTION_PAGE_READ_NVRAM:",
          "818:     case MPI_CONFIG_ACTION_PAGE_READ_CURRENT:",
          "819:     case MPI_CONFIG_ACTION_PAGE_READ_DEFAULT:",
          "820:     case MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT:",
          "821:     case MPI_CONFIG_ACTION_PAGE_WRITE_NVRAM:",
          "822:         break;",
          "824:     default:",
          "825:         reply.IOCStatus = MPI_IOCSTATUS_CONFIG_INVALID_ACTION;",
          "826:         goto out;",
          "827:     }",
          "829:     if (!page) {",
          "830:         page = mptsas_find_config_page(type, 1);",
          "831:         if (page) {",
          "832:             reply.IOCStatus = MPI_IOCSTATUS_CONFIG_INVALID_PAGE;",
          "833:         } else {",
          "834:             reply.IOCStatus = MPI_IOCSTATUS_CONFIG_INVALID_TYPE;",
          "835:         }",
          "836:         goto out;",
          "837:     }",
          "839:     if (req->Action == MPI_CONFIG_ACTION_PAGE_DEFAULT ||",
          "840:         req->Action == MPI_CONFIG_ACTION_PAGE_HEADER) {",
          "841:         length = page->mpt_config_build(s, NULL, req->PageAddress);",
          "842:         if ((ssize_t)length < 0) {",
          "843:             reply.IOCStatus = MPI_IOCSTATUS_CONFIG_INVALID_PAGE;",
          "844:             goto out;",
          "845:         } else {",
          "846:             goto done;",
          "847:         }",
          "848:     }",
          "850:     if (req->Action == MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT ||",
          "851:         req->Action == MPI_CONFIG_ACTION_PAGE_WRITE_NVRAM) {",
          "852:         length = page->mpt_config_build(s, NULL, req->PageAddress);",
          "853:         if ((ssize_t)length < 0) {",
          "854:             reply.IOCStatus = MPI_IOCSTATUS_CONFIG_INVALID_PAGE;",
          "855:         } else {",
          "856:             reply.IOCStatus = MPI_IOCSTATUS_CONFIG_CANT_COMMIT;",
          "857:         }",
          "858:         goto out;",
          "859:     }",
          "861:     flags_and_length = req->PageBufferSGE.FlagsLength;",
          "862:     dmalen = flags_and_length & MPI_SGE_LENGTH_MASK;",
          "863:     if (dmalen == 0) {",
          "864:         length = page->mpt_config_build(s, NULL, req->PageAddress);",
          "865:         if ((ssize_t)length < 0) {",
          "866:             reply.IOCStatus = MPI_IOCSTATUS_CONFIG_INVALID_PAGE;",
          "867:             goto out;",
          "868:         } else {",
          "869:             goto done;",
          "870:         }",
          "871:     }",
          "873:     if (flags_and_length & MPI_SGE_FLAGS_64_BIT_ADDRESSING) {",
          "874:         pa = req->PageBufferSGE.u.Address64;",
          "875:     } else {",
          "876:         pa = req->PageBufferSGE.u.Address32;",
          "877:     }",
          "880:     length = page->mpt_config_build(s, &data, req->PageAddress);",
          "881:     if ((ssize_t)length < 0) {",
          "882:         reply.IOCStatus = MPI_IOCSTATUS_CONFIG_INVALID_PAGE;",
          "883:         goto out;",
          "884:     } else {",
          "885:         assert(data[2] == page->number);",
          "886:         pci_dma_write(pci, pa, data, MIN(length, dmalen));",
          "887:         goto done;",
          "888:     }",
          "890:     abort();",
          "892: done:",
          "893:     if (type > MPI_CONFIG_PAGETYPE_MASK) {",
          "894:         reply.ExtPageLength = length / 4;",
          "895:         reply.ExtPageType   = req->ExtPageType;",
          "896:     } else {",
          "897:         reply.PageLength    = length / 4;",
          "898:     }",
          "900: out:",
          "901:     mptsas_fix_config_reply_endianness(&reply);",
          "902:     mptsas_reply(s, (MPIDefaultReply *)&reply);",
          "903:     g_free(data);",
          "904: }",
          "",
          "---------------"
        ],
        "hw/scsi/mptendian.c||hw/scsi/mptendian.c": [
          "File: hw/scsi/mptendian.c -> hw/scsi/mptendian.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: #include \"qemu/osdep.h\"",
          "24: #include \"hw/hw.h\"",
          "25: #include \"hw/pci/pci.h\"",
          "26: #include \"sysemu/dma.h\"",
          "27: #include \"sysemu/block-backend.h\"",
          "28: #include \"hw/pci/msi.h\"",
          "29: #include \"qemu/iov.h\"",
          "30: #include \"hw/scsi/scsi.h\"",
          "31: #include \"block/scsi.h\"",
          "32: #include \"trace.h\"",
          "34: #include \"mptsas.h\"",
          "35: #include \"mpi.h\"",
          "37: static void mptsas_fix_sgentry_endianness(MPISGEntry *sge)",
          "38: {",
          "39:     le32_to_cpus(&sge->FlagsLength);",
          "40:     if (sge->FlagsLength & MPI_SGE_FLAGS_64_BIT_ADDRESSING) {",
          "41:        le64_to_cpus(&sge->u.Address64);",
          "42:     } else {",
          "43:        le32_to_cpus(&sge->u.Address32);",
          "44:     }",
          "45: }",
          "47: static void mptsas_fix_sgentry_endianness_reply(MPISGEntry *sge)",
          "48: {",
          "49:     if (sge->FlagsLength & MPI_SGE_FLAGS_64_BIT_ADDRESSING) {",
          "50:        cpu_to_le64s(&sge->u.Address64);",
          "51:     } else {",
          "52:        cpu_to_le32s(&sge->u.Address32);",
          "53:     }",
          "54:     cpu_to_le32s(&sge->FlagsLength);",
          "55: }",
          "57: void mptsas_fix_scsi_io_endianness(MPIMsgSCSIIORequest *req)",
          "58: {",
          "59:     le32_to_cpus(&req->MsgContext);",
          "60:     le32_to_cpus(&req->Control);",
          "61:     le32_to_cpus(&req->DataLength);",
          "62:     le32_to_cpus(&req->SenseBufferLowAddr);",
          "63: }",
          "65: void mptsas_fix_scsi_io_reply_endianness(MPIMsgSCSIIOReply *reply)",
          "66: {",
          "67:     cpu_to_le32s(&reply->MsgContext);",
          "68:     cpu_to_le16s(&reply->IOCStatus);",
          "69:     cpu_to_le32s(&reply->IOCLogInfo);",
          "70:     cpu_to_le32s(&reply->TransferCount);",
          "71:     cpu_to_le32s(&reply->SenseCount);",
          "72:     cpu_to_le32s(&reply->ResponseInfo);",
          "73:     cpu_to_le16s(&reply->TaskTag);",
          "74: }",
          "76: void mptsas_fix_scsi_task_mgmt_endianness(MPIMsgSCSITaskMgmt *req)",
          "77: {",
          "78:     le32_to_cpus(&req->MsgContext);",
          "79:     le32_to_cpus(&req->TaskMsgContext);",
          "80: }",
          "82: void mptsas_fix_scsi_task_mgmt_reply_endianness(MPIMsgSCSITaskMgmtReply *reply)",
          "83: {",
          "84:     cpu_to_le32s(&reply->MsgContext);",
          "85:     cpu_to_le16s(&reply->IOCStatus);",
          "86:     cpu_to_le32s(&reply->IOCLogInfo);",
          "87:     cpu_to_le32s(&reply->TerminationCount);",
          "88: }",
          "90: void mptsas_fix_ioc_init_endianness(MPIMsgIOCInit *req)",
          "91: {",
          "92:     le32_to_cpus(&req->MsgContext);",
          "93:     le16_to_cpus(&req->ReplyFrameSize);",
          "94:     le32_to_cpus(&req->HostMfaHighAddr);",
          "95:     le32_to_cpus(&req->SenseBufferHighAddr);",
          "96:     le32_to_cpus(&req->ReplyFifoHostSignalingAddr);",
          "97:     mptsas_fix_sgentry_endianness(&req->HostPageBufferSGE);",
          "98:     le16_to_cpus(&req->MsgVersion);",
          "99:     le16_to_cpus(&req->HeaderVersion);",
          "100: }",
          "102: void mptsas_fix_ioc_init_reply_endianness(MPIMsgIOCInitReply *reply)",
          "103: {",
          "104:     cpu_to_le32s(&reply->MsgContext);",
          "105:     cpu_to_le16s(&reply->IOCStatus);",
          "106:     cpu_to_le32s(&reply->IOCLogInfo);",
          "107: }",
          "109: void mptsas_fix_ioc_facts_endianness(MPIMsgIOCFacts *req)",
          "110: {",
          "111:     le32_to_cpus(&req->MsgContext);",
          "112: }",
          "114: void mptsas_fix_ioc_facts_reply_endianness(MPIMsgIOCFactsReply *reply)",
          "115: {",
          "116:     cpu_to_le16s(&reply->MsgVersion);",
          "117:     cpu_to_le16s(&reply->HeaderVersion);",
          "118:     cpu_to_le32s(&reply->MsgContext);",
          "119:     cpu_to_le16s(&reply->IOCExceptions);",
          "120:     cpu_to_le16s(&reply->IOCStatus);",
          "121:     cpu_to_le32s(&reply->IOCLogInfo);",
          "122:     cpu_to_le16s(&reply->ReplyQueueDepth);",
          "123:     cpu_to_le16s(&reply->RequestFrameSize);",
          "124:     cpu_to_le16s(&reply->ProductID);",
          "125:     cpu_to_le32s(&reply->CurrentHostMfaHighAddr);",
          "126:     cpu_to_le16s(&reply->GlobalCredits);",
          "127:     cpu_to_le32s(&reply->CurrentSenseBufferHighAddr);",
          "128:     cpu_to_le16s(&reply->CurReplyFrameSize);",
          "129:     cpu_to_le32s(&reply->FWImageSize);",
          "130:     cpu_to_le32s(&reply->IOCCapabilities);",
          "131:     cpu_to_le16s(&reply->HighPriorityQueueDepth);",
          "132:     mptsas_fix_sgentry_endianness_reply(&reply->HostPageBufferSGE);",
          "133:     cpu_to_le32s(&reply->ReplyFifoHostSignalingAddr);",
          "134: }",
          "136: void mptsas_fix_config_endianness(MPIMsgConfig *req)",
          "137: {",
          "138:     le16_to_cpus(&req->ExtPageLength);",
          "139:     le32_to_cpus(&req->MsgContext);",
          "140:     le32_to_cpus(&req->PageAddress);",
          "141:     mptsas_fix_sgentry_endianness(&req->PageBufferSGE);",
          "142: }",
          "144: void mptsas_fix_config_reply_endianness(MPIMsgConfigReply *reply)",
          "145: {",
          "146:     cpu_to_le16s(&reply->ExtPageLength);",
          "147:     cpu_to_le32s(&reply->MsgContext);",
          "148:     cpu_to_le16s(&reply->IOCStatus);",
          "149:     cpu_to_le32s(&reply->IOCLogInfo);",
          "150: }",
          "152: void mptsas_fix_port_facts_endianness(MPIMsgPortFacts *req)",
          "153: {",
          "154:     le32_to_cpus(&req->MsgContext);",
          "155: }",
          "157: void mptsas_fix_port_facts_reply_endianness(MPIMsgPortFactsReply *reply)",
          "158: {",
          "159:     cpu_to_le32s(&reply->MsgContext);",
          "160:     cpu_to_le16s(&reply->IOCStatus);",
          "161:     cpu_to_le32s(&reply->IOCLogInfo);",
          "162:     cpu_to_le16s(&reply->MaxDevices);",
          "163:     cpu_to_le16s(&reply->PortSCSIID);",
          "164:     cpu_to_le16s(&reply->ProtocolFlags);",
          "165:     cpu_to_le16s(&reply->MaxPostedCmdBuffers);",
          "166:     cpu_to_le16s(&reply->MaxPersistentIDs);",
          "167:     cpu_to_le16s(&reply->MaxLanBuckets);",
          "168: }",
          "170: void mptsas_fix_port_enable_endianness(MPIMsgPortEnable *req)",
          "171: {",
          "172:     le32_to_cpus(&req->MsgContext);",
          "173: }",
          "175: void mptsas_fix_port_enable_reply_endianness(MPIMsgPortEnableReply *reply)",
          "176: {",
          "177:     cpu_to_le32s(&reply->MsgContext);",
          "178:     cpu_to_le16s(&reply->IOCStatus);",
          "179:     cpu_to_le32s(&reply->IOCLogInfo);",
          "180: }",
          "182: void mptsas_fix_event_notification_endianness(MPIMsgEventNotify *req)",
          "183: {",
          "184:     le32_to_cpus(&req->MsgContext);",
          "185: }",
          "187: void mptsas_fix_event_notification_reply_endianness(MPIMsgEventNotifyReply *reply)",
          "188: {",
          "189:     int length = reply->EventDataLength;",
          "190:     int i;",
          "192:     cpu_to_le16s(&reply->EventDataLength);",
          "193:     cpu_to_le32s(&reply->MsgContext);",
          "194:     cpu_to_le16s(&reply->IOCStatus);",
          "195:     cpu_to_le32s(&reply->IOCLogInfo);",
          "196:     cpu_to_le32s(&reply->Event);",
          "197:     cpu_to_le32s(&reply->EventContext);",
          "200:     for (i = 0; i < length; i++) {",
          "201:         cpu_to_le32s(&reply->Data[i]);",
          "202:     }",
          "203: }",
          "",
          "---------------"
        ],
        "hw/scsi/mptsas.c||hw/scsi/mptsas.c": [
          "File: hw/scsi/mptsas.c -> hw/scsi/mptsas.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #include \"qemu/osdep.h\"",
          "26: #include \"hw/hw.h\"",
          "27: #include \"hw/pci/pci.h\"",
          "28: #include \"sysemu/dma.h\"",
          "29: #include \"sysemu/block-backend.h\"",
          "30: #include \"hw/pci/msi.h\"",
          "31: #include \"qemu/iov.h\"",
          "32: #include \"hw/scsi/scsi.h\"",
          "33: #include \"block/scsi.h\"",
          "34: #include \"trace.h\"",
          "36: #include \"mptsas.h\"",
          "37: #include \"mpi.h\"",
          "39: #define NAA_LOCALLY_ASSIGNED_ID 0x3ULL",
          "40: #define IEEE_COMPANY_LOCALLY_ASSIGNED 0x525400",
          "42: #define TYPE_MPTSAS1068 \"mptsas1068\"",
          "44: #define MPT_SAS(obj) \\",
          "45:     OBJECT_CHECK(MPTSASState, (obj), TYPE_MPTSAS1068)",
          "47: #define MPTSAS1068_PRODUCT_ID                  \\",
          "48:     (MPI_FW_HEADER_PID_FAMILY_1068_SAS |       \\",
          "49:      MPI_FW_HEADER_PID_PROD_INITIATOR_SCSI |   \\",
          "50:      MPI_FW_HEADER_PID_TYPE_SAS)",
          "52: struct MPTSASRequest {",
          "53:     MPIMsgSCSIIORequest scsi_io;",
          "54:     SCSIRequest *sreq;",
          "55:     QEMUSGList qsg;",
          "56:     MPTSASState *dev;",
          "58:     QTAILQ_ENTRY(MPTSASRequest) next;",
          "59: };",
          "61: static void mptsas_update_interrupt(MPTSASState *s)",
          "62: {",
          "63:     PCIDevice *pci = (PCIDevice *) s;",
          "64:     uint32_t state = s->intr_status & ~(s->intr_mask | MPI_HIS_IOP_DOORBELL_STATUS);",
          "66:     if (s->msi_in_use && msi_enabled(pci)) {",
          "67:         if (state) {",
          "68:             trace_mptsas_irq_msi(s);",
          "69:             msi_notify(pci, 0);",
          "70:         }",
          "71:     }",
          "73:     trace_mptsas_irq_intx(s, !!state);",
          "74:     pci_set_irq(pci, !!state);",
          "75: }",
          "77: static void mptsas_set_fault(MPTSASState *s, uint32_t code)",
          "78: {",
          "79:     if ((s->state & MPI_IOC_STATE_FAULT) == 0) {",
          "80:         s->state = MPI_IOC_STATE_FAULT | code;",
          "81:     }",
          "82: }",
          "84: #define MPTSAS_FIFO_INVALID(s, name)                     \\",
          "85:     ((s)->name##_head > ARRAY_SIZE((s)->name) ||         \\",
          "86:      (s)->name##_tail > ARRAY_SIZE((s)->name))",
          "88: #define MPTSAS_FIFO_EMPTY(s, name)                       \\",
          "89:     ((s)->name##_head == (s)->name##_tail)",
          "91: #define MPTSAS_FIFO_FULL(s, name)                        \\",
          "92:     ((s)->name##_head == ((s)->name##_tail + 1) % ARRAY_SIZE((s)->name))",
          "94: #define MPTSAS_FIFO_GET(s, name) ({                      \\",
          "95:     uint32_t _val = (s)->name[(s)->name##_head++];       \\",
          "96:     (s)->name##_head %= ARRAY_SIZE((s)->name);           \\",
          "97:     _val;                                                \\",
          "98: })",
          "100: #define MPTSAS_FIFO_PUT(s, name, val) do {       \\",
          "101:     (s)->name[(s)->name##_tail++] = (val);       \\",
          "102:     (s)->name##_tail %= ARRAY_SIZE((s)->name);   \\",
          "103: } while(0)",
          "105: static void mptsas_post_reply(MPTSASState *s, MPIDefaultReply *reply)",
          "106: {",
          "107:     PCIDevice *pci = (PCIDevice *) s;",
          "108:     uint32_t addr_lo;",
          "110:     if (MPTSAS_FIFO_EMPTY(s, reply_free) || MPTSAS_FIFO_FULL(s, reply_post)) {",
          "111:         mptsas_set_fault(s, MPI_IOCSTATUS_INSUFFICIENT_RESOURCES);",
          "112:         return;",
          "113:     }",
          "115:     addr_lo = MPTSAS_FIFO_GET(s, reply_free);",
          "117:     pci_dma_write(pci, addr_lo | s->host_mfa_high_addr, reply,",
          "118:                   MIN(s->reply_frame_size, 4 * reply->MsgLength));",
          "120:     MPTSAS_FIFO_PUT(s, reply_post, MPI_ADDRESS_REPLY_A_BIT | (addr_lo >> 1));",
          "122:     s->intr_status |= MPI_HIS_REPLY_MESSAGE_INTERRUPT;",
          "123:     if (s->doorbell_state == DOORBELL_WRITE) {",
          "124:         s->doorbell_state = DOORBELL_NONE;",
          "125:         s->intr_status |= MPI_HIS_DOORBELL_INTERRUPT;",
          "126:     }",
          "127:     mptsas_update_interrupt(s);",
          "128: }",
          "130: void mptsas_reply(MPTSASState *s, MPIDefaultReply *reply)",
          "131: {",
          "132:     if (s->doorbell_state == DOORBELL_WRITE) {",
          "136:         s->doorbell_state = DOORBELL_READ;",
          "137:         s->doorbell_reply_idx = 0;",
          "138:         s->doorbell_reply_size = reply->MsgLength * 2;",
          "139:         memcpy(s->doorbell_reply, reply, s->doorbell_reply_size * 2);",
          "140:         s->intr_status |= MPI_HIS_DOORBELL_INTERRUPT;",
          "141:         mptsas_update_interrupt(s);",
          "142:     } else {",
          "143:         mptsas_post_reply(s, reply);",
          "144:     }",
          "145: }",
          "147: static void mptsas_turbo_reply(MPTSASState *s, uint32_t msgctx)",
          "148: {",
          "149:     if (MPTSAS_FIFO_FULL(s, reply_post)) {",
          "150:         mptsas_set_fault(s, MPI_IOCSTATUS_INSUFFICIENT_RESOURCES);",
          "151:         return;",
          "152:     }",
          "155:     MPTSAS_FIFO_PUT(s, reply_post, msgctx);",
          "157:     s->intr_status |= MPI_HIS_REPLY_MESSAGE_INTERRUPT;",
          "158:     mptsas_update_interrupt(s);",
          "159: }",
          "161: #define MPTSAS_MAX_REQUEST_SIZE 52",
          "163: static const int mpi_request_sizes[] = {",
          "164:     [MPI_FUNCTION_SCSI_IO_REQUEST]    = sizeof(MPIMsgSCSIIORequest),",
          "165:     [MPI_FUNCTION_SCSI_TASK_MGMT]     = sizeof(MPIMsgSCSITaskMgmt),",
          "166:     [MPI_FUNCTION_IOC_INIT]           = sizeof(MPIMsgIOCInit),",
          "167:     [MPI_FUNCTION_IOC_FACTS]          = sizeof(MPIMsgIOCFacts),",
          "168:     [MPI_FUNCTION_CONFIG]             = sizeof(MPIMsgConfig),",
          "169:     [MPI_FUNCTION_PORT_FACTS]         = sizeof(MPIMsgPortFacts),",
          "170:     [MPI_FUNCTION_PORT_ENABLE]        = sizeof(MPIMsgPortEnable),",
          "171:     [MPI_FUNCTION_EVENT_NOTIFICATION] = sizeof(MPIMsgEventNotify),",
          "172: };",
          "174: static dma_addr_t mptsas_ld_sg_base(MPTSASState *s, uint32_t flags_and_length,",
          "175:                                     dma_addr_t *sgaddr)",
          "176: {",
          "177:     PCIDevice *pci = (PCIDevice *) s;",
          "178:     dma_addr_t addr;",
          "180:     if (flags_and_length & MPI_SGE_FLAGS_64_BIT_ADDRESSING) {",
          "181:         addr = ldq_le_pci_dma(pci, *sgaddr + 4);",
          "183:     } else {",
          "184:         addr = ldl_le_pci_dma(pci, *sgaddr + 4);",
          "186:     }",
          "187:     return addr;",
          "188: }",
          "190: static int mptsas_build_sgl(MPTSASState *s, MPTSASRequest *req, hwaddr addr)",
          "191: {",
          "192:     PCIDevice *pci = (PCIDevice *) s;",
          "193:     hwaddr next_chain_addr;",
          "194:     uint32_t left;",
          "195:     hwaddr sgaddr;",
          "196:     uint32_t chain_offset;",
          "198:     chain_offset = req->scsi_io.ChainOffset;",
          "199:     next_chain_addr = addr + chain_offset * sizeof(uint32_t);",
          "200:     sgaddr = addr + sizeof(MPIMsgSCSIIORequest);",
          "201:     pci_dma_sglist_init(&req->qsg, pci, 4);",
          "202:     left = req->scsi_io.DataLength;",
          "204:     for(;;) {",
          "205:         dma_addr_t addr, len;",
          "206:         uint32_t flags_and_length;",
          "208:         flags_and_length = ldl_le_pci_dma(pci, sgaddr);",
          "209:         len = flags_and_length & MPI_SGE_LENGTH_MASK;",
          "210:         if ((flags_and_length & MPI_SGE_FLAGS_ELEMENT_TYPE_MASK)",
          "211:             != MPI_SGE_FLAGS_SIMPLE_ELEMENT ||",
          "212:             (!len &&",
          "213:              !(flags_and_length & MPI_SGE_FLAGS_END_OF_LIST) &&",
          "214:              !(flags_and_length & MPI_SGE_FLAGS_END_OF_BUFFER))) {",
          "215:             return MPI_IOCSTATUS_INVALID_SGL;",
          "216:         }",
          "218:         len = MIN(len, left);",
          "219:         if (!len) {",
          "223:             break;",
          "224:         }",
          "226:         addr = mptsas_ld_sg_base(s, flags_and_length, &sgaddr);",
          "227:         qemu_sglist_add(&req->qsg, addr, len);",
          "228:         left -= len;",
          "230:         if (flags_and_length & MPI_SGE_FLAGS_END_OF_LIST) {",
          "231:             break;",
          "232:         }",
          "234:         if (flags_and_length & MPI_SGE_FLAGS_LAST_ELEMENT) {",
          "235:             if (!chain_offset) {",
          "236:                 break;",
          "237:             }",
          "239:             flags_and_length = ldl_le_pci_dma(pci, next_chain_addr);",
          "240:             if ((flags_and_length & MPI_SGE_FLAGS_ELEMENT_TYPE_MASK)",
          "241:                 != MPI_SGE_FLAGS_CHAIN_ELEMENT) {",
          "242:                 return MPI_IOCSTATUS_INVALID_SGL;",
          "243:             }",
          "245:             sgaddr = mptsas_ld_sg_base(s, flags_and_length, &next_chain_addr);",
          "246:             chain_offset =",
          "247:                 (flags_and_length & MPI_SGE_CHAIN_OFFSET_MASK) >> MPI_SGE_CHAIN_OFFSET_SHIFT;",
          "248:             next_chain_addr = sgaddr + chain_offset * sizeof(uint32_t);",
          "249:         }",
          "250:     }",
          "251:     return 0;",
          "252: }",
          "254: static void mptsas_free_request(MPTSASRequest *req)",
          "255: {",
          "256:     MPTSASState *s = req->dev;",
          "258:     if (req->sreq != NULL) {",
          "259:         req->sreq->hba_private = NULL;",
          "260:         scsi_req_unref(req->sreq);",
          "261:         req->sreq = NULL;",
          "262:         QTAILQ_REMOVE(&s->pending, req, next);",
          "263:     }",
          "264:     qemu_sglist_destroy(&req->qsg);",
          "265:     g_free(req);",
          "266: }",
          "268: static int mptsas_scsi_device_find(MPTSASState *s, int bus, int target,",
          "269:                                    uint8_t *lun, SCSIDevice **sdev)",
          "270: {",
          "271:     if (bus != 0) {",
          "272:         return MPI_IOCSTATUS_SCSI_INVALID_BUS;",
          "273:     }",
          "275:     if (target >= s->max_devices) {",
          "276:         return MPI_IOCSTATUS_SCSI_INVALID_TARGETID;",
          "277:     }",
          "280:     if (!*sdev) {",
          "281:         return MPI_IOCSTATUS_SCSI_DEVICE_NOT_THERE;",
          "282:     }",
          "284:     return 0;",
          "285: }",
          "287: static int mptsas_process_scsi_io_request(MPTSASState *s,",
          "288:                                           MPIMsgSCSIIORequest *scsi_io,",
          "289:                                           hwaddr addr)",
          "290: {",
          "291:     MPTSASRequest *req;",
          "292:     MPIMsgSCSIIOReply reply;",
          "293:     SCSIDevice *sdev;",
          "294:     int status;",
          "296:     mptsas_fix_scsi_io_endianness(scsi_io);",
          "298:     trace_mptsas_process_scsi_io_request(s, scsi_io->Bus, scsi_io->TargetID,",
          "299:                                          scsi_io->LUN[1], scsi_io->DataLength);",
          "301:     status = mptsas_scsi_device_find(s, scsi_io->Bus, scsi_io->TargetID,",
          "302:                                      scsi_io->LUN, &sdev);",
          "303:     if (status) {",
          "304:         goto bad;",
          "305:     }",
          "307:     req = g_new(MPTSASRequest, 1);",
          "308:     QTAILQ_INSERT_TAIL(&s->pending, req, next);",
          "309:     req->scsi_io = *scsi_io;",
          "310:     req->dev = s;",
          "312:     status = mptsas_build_sgl(s, req, addr);",
          "313:     if (status) {",
          "314:         goto free_bad;",
          "315:     }",
          "317:     if (req->qsg.size < scsi_io->DataLength) {",
          "318:         trace_mptsas_sgl_overflow(s, scsi_io->MsgContext, scsi_io->DataLength,",
          "319:                                   req->qsg.size);",
          "320:         status = MPI_IOCSTATUS_INVALID_SGL;",
          "321:         goto free_bad;",
          "322:     }",
          "324:     req->sreq = scsi_req_new(sdev, scsi_io->MsgContext,",
          "325:                             scsi_io->LUN[1], scsi_io->CDB, req);",
          "327:     if (req->sreq->cmd.xfer > scsi_io->DataLength) {",
          "328:         goto overrun;",
          "329:     }",
          "330:     switch (scsi_io->Control & MPI_SCSIIO_CONTROL_DATADIRECTION_MASK) {",
          "331:     case MPI_SCSIIO_CONTROL_NODATATRANSFER:",
          "332:         if (req->sreq->cmd.mode != SCSI_XFER_NONE) {",
          "333:             goto overrun;",
          "334:         }",
          "335:         break;",
          "337:     case MPI_SCSIIO_CONTROL_WRITE:",
          "338:         if (req->sreq->cmd.mode != SCSI_XFER_TO_DEV) {",
          "339:             goto overrun;",
          "340:         }",
          "341:         break;",
          "343:     case MPI_SCSIIO_CONTROL_READ:",
          "344:         if (req->sreq->cmd.mode != SCSI_XFER_FROM_DEV) {",
          "345:             goto overrun;",
          "346:         }",
          "347:         break;",
          "348:     }",
          "350:     if (scsi_req_enqueue(req->sreq)) {",
          "351:         scsi_req_continue(req->sreq);",
          "352:     }",
          "353:     return 0;",
          "355: overrun:",
          "356:     trace_mptsas_scsi_overflow(s, scsi_io->MsgContext, req->sreq->cmd.xfer,",
          "357:                                scsi_io->DataLength);",
          "358:     status = MPI_IOCSTATUS_SCSI_DATA_OVERRUN;",
          "359: free_bad:",
          "360:     mptsas_free_request(req);",
          "361: bad:",
          "362:     memset(&reply, 0, sizeof(reply));",
          "363:     reply.TargetID          = scsi_io->TargetID;",
          "364:     reply.Bus               = scsi_io->Bus;",
          "365:     reply.MsgLength         = sizeof(reply) / 4;",
          "366:     reply.Function          = scsi_io->Function;",
          "367:     reply.CDBLength         = scsi_io->CDBLength;",
          "368:     reply.SenseBufferLength = scsi_io->SenseBufferLength;",
          "369:     reply.MsgContext        = scsi_io->MsgContext;",
          "370:     reply.SCSIState         = MPI_SCSI_STATE_NO_SCSI_STATUS;",
          "371:     reply.IOCStatus         = status;",
          "373:     mptsas_fix_scsi_io_reply_endianness(&reply);",
          "374:     mptsas_reply(s, (MPIDefaultReply *)&reply);",
          "376:     return 0;",
          "377: }",
          "379: typedef struct {",
          "380:     Notifier                notifier;",
          "381:     MPTSASState             *s;",
          "382:     MPIMsgSCSITaskMgmtReply *reply;",
          "383: } MPTSASCancelNotifier;",
          "385: static void mptsas_cancel_notify(Notifier *notifier, void *data)",
          "386: {",
          "387:     MPTSASCancelNotifier *n = container_of(notifier,",
          "388:                                            MPTSASCancelNotifier,",
          "389:                                            notifier);",
          "392:     if (++n->reply->TerminationCount == n->reply->IOCLogInfo) {",
          "393:         n->reply->IOCLogInfo = 0;",
          "394:         mptsas_fix_scsi_task_mgmt_reply_endianness(n->reply);",
          "395:         mptsas_post_reply(n->s, (MPIDefaultReply *)n->reply);",
          "396:         g_free(n->reply);",
          "397:     }",
          "398:     g_free(n);",
          "399: }",
          "401: static void mptsas_process_scsi_task_mgmt(MPTSASState *s, MPIMsgSCSITaskMgmt *req)",
          "402: {",
          "403:     MPIMsgSCSITaskMgmtReply reply;",
          "404:     MPIMsgSCSITaskMgmtReply *reply_async;",
          "405:     int status, count;",
          "406:     SCSIDevice *sdev;",
          "407:     SCSIRequest *r, *next;",
          "408:     BusChild *kid;",
          "410:     mptsas_fix_scsi_task_mgmt_endianness(req);",
          "412:     QEMU_BUILD_BUG_ON(MPTSAS_MAX_REQUEST_SIZE < sizeof(*req));",
          "413:     QEMU_BUILD_BUG_ON(sizeof(s->doorbell_msg) < sizeof(*req));",
          "414:     QEMU_BUILD_BUG_ON(sizeof(s->doorbell_reply) < sizeof(reply));",
          "416:     memset(&reply, 0, sizeof(reply));",
          "417:     reply.TargetID   = req->TargetID;",
          "418:     reply.Bus        = req->Bus;",
          "419:     reply.MsgLength  = sizeof(reply) / 4;",
          "420:     reply.Function   = req->Function;",
          "421:     reply.TaskType   = req->TaskType;",
          "422:     reply.MsgContext = req->MsgContext;",
          "424:     switch (req->TaskType) {",
          "425:     case MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK:",
          "426:     case MPI_SCSITASKMGMT_TASKTYPE_QUERY_TASK:",
          "427:         status = mptsas_scsi_device_find(s, req->Bus, req->TargetID,",
          "428:                                          req->LUN, &sdev);",
          "429:         if (status) {",
          "430:             reply.IOCStatus = status;",
          "431:             goto out;",
          "432:         }",
          "433:         if (sdev->lun != req->LUN[1]) {",
          "434:             reply.ResponseCode = MPI_SCSITASKMGMT_RSP_TM_INVALID_LUN;",
          "435:             goto out;",
          "436:         }",
          "438:         QTAILQ_FOREACH_SAFE(r, &sdev->requests, next, next) {",
          "439:             MPTSASRequest *cmd_req = r->hba_private;",
          "440:             if (cmd_req && cmd_req->scsi_io.MsgContext == req->TaskMsgContext) {",
          "441:                 break;",
          "442:             }",
          "443:         }",
          "444:         if (r) {",
          "449:             assert(r->hba_private);",
          "450:             if (req->TaskType == MPI_SCSITASKMGMT_TASKTYPE_QUERY_TASK) {",
          "454:                 reply.ResponseCode = MPI_SCSITASKMGMT_RSP_TM_SUCCEEDED;",
          "455:             } else {",
          "456:                 MPTSASCancelNotifier *notifier;",
          "458:                 reply_async = g_memdup(&reply, sizeof(MPIMsgSCSITaskMgmtReply));",
          "459:                 reply_async->IOCLogInfo = INT_MAX;",
          "461:                 count = 1;",
          "462:                 notifier = g_new(MPTSASCancelNotifier, 1);",
          "463:                 notifier->s = s;",
          "464:                 notifier->reply = reply_async;",
          "465:                 notifier->notifier.notify = mptsas_cancel_notify;",
          "466:                 scsi_req_cancel_async(r, &notifier->notifier);",
          "467:                 goto reply_maybe_async;",
          "468:             }",
          "469:         }",
          "470:         break;",
          "472:     case MPI_SCSITASKMGMT_TASKTYPE_ABRT_TASK_SET:",
          "473:     case MPI_SCSITASKMGMT_TASKTYPE_CLEAR_TASK_SET:",
          "474:         status = mptsas_scsi_device_find(s, req->Bus, req->TargetID,",
          "475:                                          req->LUN, &sdev);",
          "476:         if (status) {",
          "477:             reply.IOCStatus = status;",
          "478:             goto out;",
          "479:         }",
          "480:         if (sdev->lun != req->LUN[1]) {",
          "481:             reply.ResponseCode = MPI_SCSITASKMGMT_RSP_TM_INVALID_LUN;",
          "482:             goto out;",
          "483:         }",
          "485:         reply_async = g_memdup(&reply, sizeof(MPIMsgSCSITaskMgmtReply));",
          "486:         reply_async->IOCLogInfo = INT_MAX;",
          "488:         count = 0;",
          "489:         QTAILQ_FOREACH_SAFE(r, &sdev->requests, next, next) {",
          "490:             if (r->hba_private) {",
          "491:                 MPTSASCancelNotifier *notifier;",
          "493:                 count++;",
          "494:                 notifier = g_new(MPTSASCancelNotifier, 1);",
          "495:                 notifier->s = s;",
          "496:                 notifier->reply = reply_async;",
          "497:                 notifier->notifier.notify = mptsas_cancel_notify;",
          "498:                 scsi_req_cancel_async(r, &notifier->notifier);",
          "499:             }",
          "500:         }",
          "502: reply_maybe_async:",
          "503:         if (reply_async->TerminationCount < count) {",
          "504:             reply_async->IOCLogInfo = count;",
          "505:             return;",
          "506:         }",
          "507:         reply.TerminationCount = count;",
          "508:         break;",
          "510:     case MPI_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET:",
          "511:         status = mptsas_scsi_device_find(s, req->Bus, req->TargetID,",
          "512:                                          req->LUN, &sdev);",
          "513:         if (status) {",
          "514:             reply.IOCStatus = status;",
          "515:             goto out;",
          "516:         }",
          "517:         if (sdev->lun != req->LUN[1]) {",
          "518:             reply.ResponseCode = MPI_SCSITASKMGMT_RSP_TM_INVALID_LUN;",
          "519:             goto out;",
          "520:         }",
          "521:         qdev_reset_all(&sdev->qdev);",
          "522:         break;",
          "524:     case MPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET:",
          "525:         if (req->Bus != 0) {",
          "526:             reply.IOCStatus = MPI_IOCSTATUS_SCSI_INVALID_BUS;",
          "527:             goto out;",
          "528:         }",
          "529:         if (req->TargetID > s->max_devices) {",
          "530:             reply.IOCStatus = MPI_IOCSTATUS_SCSI_INVALID_TARGETID;",
          "531:             goto out;",
          "532:         }",
          "534:         QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {",
          "535:             sdev = SCSI_DEVICE(kid->child);",
          "536:             if (sdev->channel == 0 && sdev->id == req->TargetID) {",
          "537:                 qdev_reset_all(kid->child);",
          "538:             }",
          "539:         }",
          "540:         break;",
          "542:     case MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS:",
          "543:         qbus_reset_all(&s->bus.qbus);",
          "544:         break;",
          "546:     default:",
          "547:         reply.ResponseCode = MPI_SCSITASKMGMT_RSP_TM_NOT_SUPPORTED;",
          "548:         break;",
          "549:     }",
          "551: out:",
          "552:     mptsas_fix_scsi_task_mgmt_reply_endianness(&reply);",
          "553:     mptsas_post_reply(s, (MPIDefaultReply *)&reply);",
          "554: }",
          "556: static void mptsas_process_ioc_init(MPTSASState *s, MPIMsgIOCInit *req)",
          "557: {",
          "558:     MPIMsgIOCInitReply reply;",
          "560:     mptsas_fix_ioc_init_endianness(req);",
          "562:     QEMU_BUILD_BUG_ON(MPTSAS_MAX_REQUEST_SIZE < sizeof(*req));",
          "563:     QEMU_BUILD_BUG_ON(sizeof(s->doorbell_msg) < sizeof(*req));",
          "564:     QEMU_BUILD_BUG_ON(sizeof(s->doorbell_reply) < sizeof(reply));",
          "566:     s->who_init               = req->WhoInit;",
          "567:     s->reply_frame_size       = req->ReplyFrameSize;",
          "568:     s->max_buses              = req->MaxBuses;",
          "569:     s->max_devices            = req->MaxDevices ? req->MaxDevices : 256;",
          "570:     s->host_mfa_high_addr     = (hwaddr)req->HostMfaHighAddr << 32;",
          "571:     s->sense_buffer_high_addr = (hwaddr)req->SenseBufferHighAddr << 32;",
          "573:     if (s->state == MPI_IOC_STATE_READY) {",
          "574:         s->state = MPI_IOC_STATE_OPERATIONAL;",
          "575:     }",
          "577:     memset(&reply, 0, sizeof(reply));",
          "578:     reply.WhoInit    = s->who_init;",
          "579:     reply.MsgLength  = sizeof(reply) / 4;",
          "580:     reply.Function   = req->Function;",
          "581:     reply.MaxDevices = s->max_devices;",
          "582:     reply.MaxBuses   = s->max_buses;",
          "583:     reply.MsgContext = req->MsgContext;",
          "585:     mptsas_fix_ioc_init_reply_endianness(&reply);",
          "586:     mptsas_reply(s, (MPIDefaultReply *)&reply);",
          "587: }",
          "589: static void mptsas_process_ioc_facts(MPTSASState *s,",
          "590:                                      MPIMsgIOCFacts *req)",
          "591: {",
          "592:     MPIMsgIOCFactsReply reply;",
          "594:     mptsas_fix_ioc_facts_endianness(req);",
          "596:     QEMU_BUILD_BUG_ON(MPTSAS_MAX_REQUEST_SIZE < sizeof(*req));",
          "597:     QEMU_BUILD_BUG_ON(sizeof(s->doorbell_msg) < sizeof(*req));",
          "598:     QEMU_BUILD_BUG_ON(sizeof(s->doorbell_reply) < sizeof(reply));",
          "600:     memset(&reply, 0, sizeof(reply));",
          "601:     reply.MsgVersion                 = 0x0105;",
          "602:     reply.MsgLength                  = sizeof(reply) / 4;",
          "603:     reply.Function                   = req->Function;",
          "604:     reply.MsgContext                 = req->MsgContext;",
          "605:     reply.MaxChainDepth              = MPTSAS_MAXIMUM_CHAIN_DEPTH;",
          "606:     reply.WhoInit                    = s->who_init;",
          "607:     reply.BlockSize                  = MPTSAS_MAX_REQUEST_SIZE / sizeof(uint32_t);",
          "608:     reply.ReplyQueueDepth            = ARRAY_SIZE(s->reply_post) - 1;",
          "609:     QEMU_BUILD_BUG_ON(ARRAY_SIZE(s->reply_post) != ARRAY_SIZE(s->reply_free));",
          "611:     reply.RequestFrameSize           = 128;",
          "612:     reply.ProductID                  = MPTSAS1068_PRODUCT_ID;",
          "613:     reply.CurrentHostMfaHighAddr     = s->host_mfa_high_addr >> 32;",
          "614:     reply.GlobalCredits              = ARRAY_SIZE(s->request_post) - 1;",
          "615:     reply.NumberOfPorts              = MPTSAS_NUM_PORTS;",
          "616:     reply.CurrentSenseBufferHighAddr = s->sense_buffer_high_addr >> 32;",
          "617:     reply.CurReplyFrameSize          = s->reply_frame_size;",
          "618:     reply.MaxDevices                 = s->max_devices;",
          "619:     reply.MaxBuses                   = s->max_buses;",
          "620:     reply.FWVersionDev               = 0;",
          "621:     reply.FWVersionUnit              = 0x92;",
          "622:     reply.FWVersionMinor             = 0x32;",
          "623:     reply.FWVersionMajor             = 0x1;",
          "625:     mptsas_fix_ioc_facts_reply_endianness(&reply);",
          "626:     mptsas_reply(s, (MPIDefaultReply *)&reply);",
          "627: }",
          "629: static void mptsas_process_port_facts(MPTSASState *s,",
          "630:                                      MPIMsgPortFacts *req)",
          "631: {",
          "632:     MPIMsgPortFactsReply reply;",
          "634:     mptsas_fix_port_facts_endianness(req);",
          "636:     QEMU_BUILD_BUG_ON(MPTSAS_MAX_REQUEST_SIZE < sizeof(*req));",
          "637:     QEMU_BUILD_BUG_ON(sizeof(s->doorbell_msg) < sizeof(*req));",
          "638:     QEMU_BUILD_BUG_ON(sizeof(s->doorbell_reply) < sizeof(reply));",
          "640:     memset(&reply, 0, sizeof(reply));",
          "641:     reply.MsgLength  = sizeof(reply) / 4;",
          "642:     reply.Function   = req->Function;",
          "643:     reply.PortNumber = req->PortNumber;",
          "644:     reply.MsgContext = req->MsgContext;",
          "646:     if (req->PortNumber < MPTSAS_NUM_PORTS) {",
          "647:         reply.PortType      = MPI_PORTFACTS_PORTTYPE_SAS;",
          "648:         reply.MaxDevices    = MPTSAS_NUM_PORTS;",
          "649:         reply.PortSCSIID    = MPTSAS_NUM_PORTS;",
          "650:         reply.ProtocolFlags = MPI_PORTFACTS_PROTOCOL_LOGBUSADDR | MPI_PORTFACTS_PROTOCOL_INITIATOR;",
          "651:     }",
          "653:     mptsas_fix_port_facts_reply_endianness(&reply);",
          "654:     mptsas_reply(s, (MPIDefaultReply *)&reply);",
          "655: }",
          "657: static void mptsas_process_port_enable(MPTSASState *s,",
          "658:                                        MPIMsgPortEnable *req)",
          "659: {",
          "660:     MPIMsgPortEnableReply reply;",
          "662:     mptsas_fix_port_enable_endianness(req);",
          "664:     QEMU_BUILD_BUG_ON(MPTSAS_MAX_REQUEST_SIZE < sizeof(*req));",
          "665:     QEMU_BUILD_BUG_ON(sizeof(s->doorbell_msg) < sizeof(*req));",
          "666:     QEMU_BUILD_BUG_ON(sizeof(s->doorbell_reply) < sizeof(reply));",
          "668:     memset(&reply, 0, sizeof(reply));",
          "669:     reply.MsgLength  = sizeof(reply) / 4;",
          "670:     reply.PortNumber = req->PortNumber;",
          "671:     reply.Function   = req->Function;",
          "672:     reply.MsgContext = req->MsgContext;",
          "674:     mptsas_fix_port_enable_reply_endianness(&reply);",
          "675:     mptsas_reply(s, (MPIDefaultReply *)&reply);",
          "676: }",
          "678: static void mptsas_process_event_notification(MPTSASState *s,",
          "679:                                               MPIMsgEventNotify *req)",
          "680: {",
          "681:     MPIMsgEventNotifyReply reply;",
          "683:     mptsas_fix_event_notification_endianness(req);",
          "685:     QEMU_BUILD_BUG_ON(MPTSAS_MAX_REQUEST_SIZE < sizeof(*req));",
          "686:     QEMU_BUILD_BUG_ON(sizeof(s->doorbell_msg) < sizeof(*req));",
          "687:     QEMU_BUILD_BUG_ON(sizeof(s->doorbell_reply) < sizeof(reply));",
          "693:     memset(&reply, 0, sizeof(reply));",
          "694:     reply.EventDataLength = sizeof(reply.Data) / 4;",
          "695:     reply.MsgLength       = sizeof(reply) / 4;",
          "696:     reply.Function        = req->Function;",
          "699:     reply.MsgFlags        = MPI_MSGFLAGS_CONTINUATION_REPLY;",
          "701:     reply.MsgContext      = req->MsgContext;",
          "702:     reply.Event           = MPI_EVENT_EVENT_CHANGE;",
          "703:     reply.Data[0]         = !!req->Switch;",
          "705:     mptsas_fix_event_notification_reply_endianness(&reply);",
          "706:     mptsas_reply(s, (MPIDefaultReply *)&reply);",
          "707: }",
          "709: static void mptsas_process_message(MPTSASState *s, MPIRequestHeader *req)",
          "710: {",
          "711:     trace_mptsas_process_message(s, req->Function, req->MsgContext);",
          "712:     switch (req->Function) {",
          "713:     case MPI_FUNCTION_SCSI_TASK_MGMT:",
          "714:         mptsas_process_scsi_task_mgmt(s, (MPIMsgSCSITaskMgmt *)req);",
          "715:         break;",
          "717:     case MPI_FUNCTION_IOC_INIT:",
          "718:         mptsas_process_ioc_init(s, (MPIMsgIOCInit *)req);",
          "719:         break;",
          "721:     case MPI_FUNCTION_IOC_FACTS:",
          "722:         mptsas_process_ioc_facts(s, (MPIMsgIOCFacts *)req);",
          "723:         break;",
          "725:     case MPI_FUNCTION_PORT_FACTS:",
          "726:         mptsas_process_port_facts(s, (MPIMsgPortFacts *)req);",
          "727:         break;",
          "729:     case MPI_FUNCTION_PORT_ENABLE:",
          "730:         mptsas_process_port_enable(s, (MPIMsgPortEnable *)req);",
          "731:         break;",
          "733:     case MPI_FUNCTION_EVENT_NOTIFICATION:",
          "734:         mptsas_process_event_notification(s, (MPIMsgEventNotify *)req);",
          "735:         break;",
          "737:     case MPI_FUNCTION_CONFIG:",
          "738:         mptsas_process_config(s, (MPIMsgConfig *)req);",
          "739:         break;",
          "741:     default:",
          "742:         trace_mptsas_unhandled_cmd(s, req->Function, 0);",
          "743:         mptsas_set_fault(s, MPI_IOCSTATUS_INVALID_FUNCTION);",
          "744:         break;",
          "745:     }",
          "746: }",
          "748: static void mptsas_fetch_request(MPTSASState *s)",
          "749: {",
          "750:     PCIDevice *pci = (PCIDevice *) s;",
          "751:     char req[MPTSAS_MAX_REQUEST_SIZE];",
          "752:     MPIRequestHeader *hdr = (MPIRequestHeader *)req;",
          "753:     hwaddr addr;",
          "754:     int size;",
          "756:     if (s->state != MPI_IOC_STATE_OPERATIONAL) {",
          "757:         mptsas_set_fault(s, MPI_IOCSTATUS_INVALID_STATE);",
          "758:         return;",
          "759:     }",
          "762:     addr = s->host_mfa_high_addr | MPTSAS_FIFO_GET(s, request_post);",
          "763:     pci_dma_read(pci, addr, req, sizeof(hdr));",
          "765:     if (hdr->Function < ARRAY_SIZE(mpi_request_sizes) &&",
          "766:         mpi_request_sizes[hdr->Function]) {",
          "771:         size = mpi_request_sizes[hdr->Function];",
          "772:         assert(size <= MPTSAS_MAX_REQUEST_SIZE);",
          "773:         pci_dma_read(pci, addr + sizeof(hdr), &req[sizeof(hdr)],",
          "774:                      size - sizeof(hdr));",
          "775:     }",
          "777:     if (hdr->Function == MPI_FUNCTION_SCSI_IO_REQUEST) {",
          "781:         mptsas_process_scsi_io_request(s, (MPIMsgSCSIIORequest *)req, addr);",
          "782:     } else {",
          "783:         mptsas_process_message(s, (MPIRequestHeader *)req);",
          "784:     }",
          "785: }",
          "787: static void mptsas_fetch_requests(void *opaque)",
          "788: {",
          "789:     MPTSASState *s = opaque;",
          "791:     while (!MPTSAS_FIFO_EMPTY(s, request_post)) {",
          "792:         mptsas_fetch_request(s);",
          "793:     }",
          "794: }",
          "796: static void mptsas_soft_reset(MPTSASState *s)",
          "797: {",
          "798:     uint32_t save_mask;",
          "800:     trace_mptsas_reset(s);",
          "803:     save_mask = s->intr_mask;",
          "804:     s->intr_mask = MPI_HIM_DIM | MPI_HIM_RIM;",
          "805:     mptsas_update_interrupt(s);",
          "807:     qbus_reset_all(&s->bus.qbus);",
          "808:     s->intr_status = 0;",
          "809:     s->intr_mask = save_mask;",
          "811:     s->reply_free_tail = 0;",
          "812:     s->reply_free_head = 0;",
          "813:     s->reply_post_tail = 0;",
          "814:     s->reply_post_head = 0;",
          "815:     s->request_post_tail = 0;",
          "816:     s->request_post_head = 0;",
          "817:     qemu_bh_cancel(s->request_bh);",
          "819:     s->state = MPI_IOC_STATE_READY;",
          "820: }",
          "822: static uint32_t mptsas_doorbell_read(MPTSASState *s)",
          "823: {",
          "824:     uint32_t ret;",
          "826:     ret = (s->who_init << MPI_DOORBELL_WHO_INIT_SHIFT) & MPI_DOORBELL_WHO_INIT_SHIFT;",
          "827:     ret |= s->state;",
          "828:     switch (s->doorbell_state) {",
          "829:     case DOORBELL_NONE:",
          "830:         break;",
          "832:     case DOORBELL_WRITE:",
          "833:         ret |= MPI_DOORBELL_ACTIVE;",
          "834:         break;",
          "836:     case DOORBELL_READ:",
          "838:         ret &= ~MPI_DOORBELL_DATA_MASK;",
          "840:         assert(s->intr_status & MPI_HIS_DOORBELL_INTERRUPT);",
          "841:         assert(s->doorbell_reply_idx <= s->doorbell_reply_size);",
          "843:         ret |= MPI_DOORBELL_ACTIVE;",
          "844:         if (s->doorbell_reply_idx < s->doorbell_reply_size) {",
          "849:             ret |= le16_to_cpu(s->doorbell_reply[s->doorbell_reply_idx++]);",
          "850:         }",
          "851:         break;",
          "853:     default:",
          "854:         abort();",
          "855:     }",
          "857:     return ret;",
          "858: }",
          "860: static void mptsas_doorbell_write(MPTSASState *s, uint32_t val)",
          "861: {",
          "862:     if (s->doorbell_state == DOORBELL_WRITE) {",
          "863:         if (s->doorbell_idx < s->doorbell_cnt) {",
          "868:             s->doorbell_msg[s->doorbell_idx++] = cpu_to_le32(val);",
          "869:             if (s->doorbell_idx == s->doorbell_cnt) {",
          "870:                 mptsas_process_message(s, (MPIRequestHeader *)s->doorbell_msg);",
          "871:             }",
          "872:         }",
          "873:         return;",
          "874:     }",
          "876:     switch ((val & MPI_DOORBELL_FUNCTION_MASK) >> MPI_DOORBELL_FUNCTION_SHIFT) {",
          "877:     case MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET:",
          "878:         mptsas_soft_reset(s);",
          "879:         break;",
          "880:     case MPI_FUNCTION_IO_UNIT_RESET:",
          "881:         break;",
          "882:     case MPI_FUNCTION_HANDSHAKE:",
          "883:         s->doorbell_state = DOORBELL_WRITE;",
          "884:         s->doorbell_idx = 0;",
          "885:         s->doorbell_cnt = (val & MPI_DOORBELL_ADD_DWORDS_MASK)",
          "886:             >> MPI_DOORBELL_ADD_DWORDS_SHIFT;",
          "887:         s->intr_status |= MPI_HIS_DOORBELL_INTERRUPT;",
          "888:         mptsas_update_interrupt(s);",
          "889:         break;",
          "890:     default:",
          "891:         trace_mptsas_unhandled_doorbell_cmd(s, val);",
          "892:         break;",
          "893:     }",
          "894: }",
          "896: static void mptsas_write_sequence_write(MPTSASState *s, uint32_t val)",
          "897: {",
          "902:     if (s->diagnostic & MPI_DIAG_DRWE) {",
          "903:         goto disable;",
          "904:     }",
          "906:     switch (s->diagnostic_idx) {",
          "907:     case 0:",
          "908:         if ((val & MPI_WRSEQ_KEY_VALUE_MASK) != MPI_WRSEQ_1ST_KEY_VALUE) {",
          "909:             goto disable;",
          "910:         }",
          "911:         break;",
          "912:     case 1:",
          "913:         if ((val & MPI_WRSEQ_KEY_VALUE_MASK) != MPI_WRSEQ_2ND_KEY_VALUE) {",
          "914:             goto disable;",
          "915:         }",
          "916:         break;",
          "917:     case 2:",
          "918:         if ((val & MPI_WRSEQ_KEY_VALUE_MASK) != MPI_WRSEQ_3RD_KEY_VALUE) {",
          "919:             goto disable;",
          "920:         }",
          "921:         break;",
          "922:     case 3:",
          "923:         if ((val & MPI_WRSEQ_KEY_VALUE_MASK) != MPI_WRSEQ_4TH_KEY_VALUE) {",
          "924:             goto disable;",
          "925:         }",
          "926:         break;",
          "927:     case 4:",
          "928:         if ((val & MPI_WRSEQ_KEY_VALUE_MASK) != MPI_WRSEQ_5TH_KEY_VALUE) {",
          "929:             goto disable;",
          "930:         }",
          "934:         s->diagnostic |= MPI_DIAG_DRWE;",
          "935:         break;",
          "936:     }",
          "937:     s->diagnostic_idx++;",
          "938:     return;",
          "940: disable:",
          "941:     s->diagnostic &= ~MPI_DIAG_DRWE;",
          "942:     s->diagnostic_idx = 0;",
          "943: }",
          "945: static int mptsas_hard_reset(MPTSASState *s)",
          "946: {",
          "947:     mptsas_soft_reset(s);",
          "949:     s->intr_mask = MPI_HIM_DIM | MPI_HIM_RIM;",
          "951:     s->host_mfa_high_addr = 0;",
          "952:     s->sense_buffer_high_addr = 0;",
          "953:     s->reply_frame_size = 0;",
          "954:     s->max_devices = MPTSAS_NUM_PORTS;",
          "955:     s->max_buses = 1;",
          "957:     return 0;",
          "958: }",
          "960: static void mptsas_interrupt_status_write(MPTSASState *s)",
          "961: {",
          "962:     switch (s->doorbell_state) {",
          "963:     case DOORBELL_NONE:",
          "964:     case DOORBELL_WRITE:",
          "965:         s->intr_status &= ~MPI_HIS_DOORBELL_INTERRUPT;",
          "966:         break;",
          "968:     case DOORBELL_READ:",
          "970:         assert(s->intr_status & MPI_HIS_DOORBELL_INTERRUPT);",
          "971:         if (s->doorbell_reply_idx == s->doorbell_reply_size) {",
          "972:             s->doorbell_state = DOORBELL_NONE;",
          "973:         }",
          "974:         break;",
          "976:     default:",
          "977:         abort();",
          "978:     }",
          "979:     mptsas_update_interrupt(s);",
          "980: }",
          "982: static uint32_t mptsas_reply_post_read(MPTSASState *s)",
          "983: {",
          "984:     uint32_t ret;",
          "986:     if (!MPTSAS_FIFO_EMPTY(s, reply_post)) {",
          "987:         ret = MPTSAS_FIFO_GET(s, reply_post);",
          "988:     } else {",
          "989:         ret = -1;",
          "990:         s->intr_status &= ~MPI_HIS_REPLY_MESSAGE_INTERRUPT;",
          "991:         mptsas_update_interrupt(s);",
          "992:     }",
          "994:     return ret;",
          "995: }",
          "997: static uint64_t mptsas_mmio_read(void *opaque, hwaddr addr,",
          "998:                                   unsigned size)",
          "999: {",
          "1000:     MPTSASState *s = opaque;",
          "1001:     uint32_t ret = 0;",
          "1003:     switch (addr & ~3) {",
          "1004:     case MPI_DOORBELL_OFFSET:",
          "1005:         ret = mptsas_doorbell_read(s);",
          "1006:         break;",
          "1008:     case MPI_DIAGNOSTIC_OFFSET:",
          "1009:         ret = s->diagnostic;",
          "1010:         break;",
          "1012:     case MPI_HOST_INTERRUPT_STATUS_OFFSET:",
          "1013:         ret = s->intr_status;",
          "1014:         break;",
          "1016:     case MPI_HOST_INTERRUPT_MASK_OFFSET:",
          "1017:         ret = s->intr_mask;",
          "1018:         break;",
          "1020:     case MPI_REPLY_POST_FIFO_OFFSET:",
          "1021:         ret = mptsas_reply_post_read(s);",
          "1022:         break;",
          "1024:     default:",
          "1025:         trace_mptsas_mmio_unhandled_read(s, addr);",
          "1026:         break;",
          "1027:     }",
          "1028:     trace_mptsas_mmio_read(s, addr, ret);",
          "1029:     return ret;",
          "1030: }",
          "1032: static void mptsas_mmio_write(void *opaque, hwaddr addr,",
          "1033:                                uint64_t val, unsigned size)",
          "1034: {",
          "1035:     MPTSASState *s = opaque;",
          "1037:     trace_mptsas_mmio_write(s, addr, val);",
          "1038:     switch (addr) {",
          "1039:     case MPI_DOORBELL_OFFSET:",
          "1040:         mptsas_doorbell_write(s, val);",
          "1041:         break;",
          "1043:     case MPI_WRITE_SEQUENCE_OFFSET:",
          "1044:         mptsas_write_sequence_write(s, val);",
          "1045:         break;",
          "1047:     case MPI_DIAGNOSTIC_OFFSET:",
          "1048:         if (val & MPI_DIAG_RESET_ADAPTER) {",
          "1049:             mptsas_hard_reset(s);",
          "1050:         }",
          "1051:         break;",
          "1053:     case MPI_HOST_INTERRUPT_STATUS_OFFSET:",
          "1054:         mptsas_interrupt_status_write(s);",
          "1055:         break;",
          "1057:     case MPI_HOST_INTERRUPT_MASK_OFFSET:",
          "1058:         s->intr_mask = val & (MPI_HIM_RIM | MPI_HIM_DIM);",
          "1059:         mptsas_update_interrupt(s);",
          "1060:         break;",
          "1062:     case MPI_REQUEST_POST_FIFO_OFFSET:",
          "1063:         if (MPTSAS_FIFO_FULL(s, request_post)) {",
          "1064:             mptsas_set_fault(s, MPI_IOCSTATUS_INSUFFICIENT_RESOURCES);",
          "1065:         } else {",
          "1066:             MPTSAS_FIFO_PUT(s, request_post, val & ~0x03);",
          "1067:             qemu_bh_schedule(s->request_bh);",
          "1068:         }",
          "1069:         break;",
          "1071:     case MPI_REPLY_FREE_FIFO_OFFSET:",
          "1072:         if (MPTSAS_FIFO_FULL(s, reply_free)) {",
          "1073:             mptsas_set_fault(s, MPI_IOCSTATUS_INSUFFICIENT_RESOURCES);",
          "1074:         } else {",
          "1075:             MPTSAS_FIFO_PUT(s, reply_free, val);",
          "1076:         }",
          "1077:         break;",
          "1079:     default:",
          "1080:         trace_mptsas_mmio_unhandled_write(s, addr, val);",
          "1081:         break;",
          "1082:     }",
          "1083: }",
          "1085: static const MemoryRegionOps mptsas_mmio_ops = {",
          "1086:     .read = mptsas_mmio_read,",
          "1087:     .write = mptsas_mmio_write,",
          "1088:     .endianness = DEVICE_LITTLE_ENDIAN,",
          "1089:     .impl = {",
          "1090:         .min_access_size = 4,",
          "1091:         .max_access_size = 4,",
          "1092:     }",
          "1093: };",
          "1095: static const MemoryRegionOps mptsas_port_ops = {",
          "1096:     .read = mptsas_mmio_read,",
          "1097:     .write = mptsas_mmio_write,",
          "1098:     .endianness = DEVICE_LITTLE_ENDIAN,",
          "1099:     .impl = {",
          "1100:         .min_access_size = 4,",
          "1101:         .max_access_size = 4,",
          "1102:     }",
          "1103: };",
          "1105: static uint64_t mptsas_diag_read(void *opaque, hwaddr addr,",
          "1106:                                    unsigned size)",
          "1107: {",
          "1108:     MPTSASState *s = opaque;",
          "1109:     trace_mptsas_diag_read(s, addr, 0);",
          "1110:     return 0;",
          "1111: }",
          "1113: static void mptsas_diag_write(void *opaque, hwaddr addr,",
          "1114:                                uint64_t val, unsigned size)",
          "1115: {",
          "1116:     MPTSASState *s = opaque;",
          "1117:     trace_mptsas_diag_write(s, addr, val);",
          "1118: }",
          "1120: static const MemoryRegionOps mptsas_diag_ops = {",
          "1121:     .read = mptsas_diag_read,",
          "1122:     .write = mptsas_diag_write,",
          "1123:     .endianness = DEVICE_LITTLE_ENDIAN,",
          "1124:     .impl = {",
          "1125:         .min_access_size = 4,",
          "1126:         .max_access_size = 4,",
          "1127:     }",
          "1128: };",
          "1130: static QEMUSGList *mptsas_get_sg_list(SCSIRequest *sreq)",
          "1131: {",
          "1132:     MPTSASRequest *req = sreq->hba_private;",
          "1134:     return &req->qsg;",
          "1135: }",
          "1137: static void mptsas_command_complete(SCSIRequest *sreq,",
          "1138:         uint32_t status, size_t resid)",
          "1139: {",
          "1140:     MPTSASRequest *req = sreq->hba_private;",
          "1141:     MPTSASState *s = req->dev;",
          "1142:     uint8_t sense_buf[SCSI_SENSE_BUF_SIZE];",
          "1143:     uint8_t sense_len;",
          "1145:     hwaddr sense_buffer_addr = req->dev->sense_buffer_high_addr |",
          "1146:             req->scsi_io.SenseBufferLowAddr;",
          "1148:     trace_mptsas_command_complete(s, req->scsi_io.MsgContext, status, resid);",
          "1150:     sense_len = scsi_req_get_sense(sreq, sense_buf, SCSI_SENSE_BUF_SIZE);",
          "1151:     if (sense_len > 0) {",
          "1152:         pci_dma_write(PCI_DEVICE(s), sense_buffer_addr, sense_buf,",
          "1153:                       MIN(req->scsi_io.SenseBufferLength, sense_len));",
          "1154:     }",
          "1156:     if (sreq->status != GOOD || resid ||",
          "1157:         req->dev->doorbell_state == DOORBELL_WRITE) {",
          "1158:         MPIMsgSCSIIOReply reply;",
          "1160:         memset(&reply, 0, sizeof(reply));",
          "1161:         reply.TargetID          = req->scsi_io.TargetID;",
          "1162:         reply.Bus               = req->scsi_io.Bus;",
          "1163:         reply.MsgLength         = sizeof(reply) / 4;",
          "1164:         reply.Function          = req->scsi_io.Function;",
          "1165:         reply.CDBLength         = req->scsi_io.CDBLength;",
          "1166:         reply.SenseBufferLength = req->scsi_io.SenseBufferLength;",
          "1167:         reply.MsgFlags          = req->scsi_io.MsgFlags;",
          "1168:         reply.MsgContext        = req->scsi_io.MsgContext;",
          "1169:         reply.SCSIStatus        = sreq->status;",
          "1170:         if (sreq->status == GOOD) {",
          "1171:             reply.TransferCount = req->scsi_io.DataLength - resid;",
          "1172:             if (resid) {",
          "1173:                 reply.IOCStatus     = MPI_IOCSTATUS_SCSI_DATA_UNDERRUN;",
          "1174:             }",
          "1175:         } else {",
          "1176:             reply.SCSIState     = MPI_SCSI_STATE_AUTOSENSE_VALID;",
          "1177:             reply.SenseCount    = sense_len;",
          "1178:             reply.IOCStatus     = MPI_IOCSTATUS_SCSI_DATA_UNDERRUN;",
          "1179:         }",
          "1181:         mptsas_fix_scsi_io_reply_endianness(&reply);",
          "1182:         mptsas_post_reply(req->dev, (MPIDefaultReply *)&reply);",
          "1183:     } else {",
          "1184:         mptsas_turbo_reply(req->dev, req->scsi_io.MsgContext);",
          "1185:     }",
          "1187:     mptsas_free_request(req);",
          "1188: }",
          "1190: static void mptsas_request_cancelled(SCSIRequest *sreq)",
          "1191: {",
          "1192:     MPTSASRequest *req = sreq->hba_private;",
          "1193:     MPIMsgSCSIIOReply reply;",
          "1195:     memset(&reply, 0, sizeof(reply));",
          "1196:     reply.TargetID          = req->scsi_io.TargetID;",
          "1197:     reply.Bus               = req->scsi_io.Bus;",
          "1198:     reply.MsgLength         = sizeof(reply) / 4;",
          "1199:     reply.Function          = req->scsi_io.Function;",
          "1200:     reply.CDBLength         = req->scsi_io.CDBLength;",
          "1201:     reply.SenseBufferLength = req->scsi_io.SenseBufferLength;",
          "1202:     reply.MsgFlags          = req->scsi_io.MsgFlags;",
          "1203:     reply.MsgContext        = req->scsi_io.MsgContext;",
          "1204:     reply.SCSIState         = MPI_SCSI_STATE_NO_SCSI_STATUS;",
          "1205:     reply.IOCStatus         = MPI_IOCSTATUS_SCSI_TASK_TERMINATED;",
          "1207:     mptsas_fix_scsi_io_reply_endianness(&reply);",
          "1208:     mptsas_post_reply(req->dev, (MPIDefaultReply *)&reply);",
          "1209:     mptsas_free_request(req);",
          "1210: }",
          "1212: static void mptsas_save_request(QEMUFile *f, SCSIRequest *sreq)",
          "1213: {",
          "1214:     MPTSASRequest *req = sreq->hba_private;",
          "1215:     int i;",
          "1217:     qemu_put_buffer(f, (unsigned char *)&req->scsi_io, sizeof(req->scsi_io));",
          "1218:     qemu_put_be32(f, req->qsg.nsg);",
          "1219:     for (i = 0; i < req->qsg.nsg; i++) {",
          "1220:         qemu_put_be64(f, req->qsg.sg[i].base);",
          "1221:         qemu_put_be64(f, req->qsg.sg[i].len);",
          "1222:     }",
          "1223: }",
          "1225: static void *mptsas_load_request(QEMUFile *f, SCSIRequest *sreq)",
          "1226: {",
          "1227:     SCSIBus *bus = sreq->bus;",
          "1228:     MPTSASState *s = container_of(bus, MPTSASState, bus);",
          "1229:     PCIDevice *pci = PCI_DEVICE(s);",
          "1230:     MPTSASRequest *req;",
          "1231:     int i, n;",
          "1233:     req = g_new(MPTSASRequest, 1);",
          "1234:     qemu_get_buffer(f, (unsigned char *)&req->scsi_io, sizeof(req->scsi_io));",
          "1236:     n = qemu_get_be32(f);",
          "1241: #ifdef NDEBUG",
          "1242: #error building with NDEBUG is not supported",
          "1243: #endif",
          "1244:     assert(n >= 0);",
          "1246:     pci_dma_sglist_init(&req->qsg, pci, n);",
          "1247:     for (i = 0; i < n; i++) {",
          "1248:         uint64_t base = qemu_get_be64(f);",
          "1249:         uint64_t len = qemu_get_be64(f);",
          "1250:         qemu_sglist_add(&req->qsg, base, len);",
          "1251:     }",
          "1253:     scsi_req_ref(sreq);",
          "1254:     req->sreq = sreq;",
          "1255:     req->dev = s;",
          "1257:     return req;",
          "1258: }",
          "1260: static const struct SCSIBusInfo mptsas_scsi_info = {",
          "1261:     .tcq = true,",
          "1262:     .max_target = MPTSAS_NUM_PORTS,",
          "1263:     .max_lun = 1,",
          "1265:     .get_sg_list = mptsas_get_sg_list,",
          "1266:     .complete = mptsas_command_complete,",
          "1267:     .cancel = mptsas_request_cancelled,",
          "1268:     .save_request = mptsas_save_request,",
          "1269:     .load_request = mptsas_load_request,",
          "1270: };",
          "1272: static void mptsas_scsi_init(PCIDevice *dev, Error **errp)",
          "1273: {",
          "1274:     DeviceState *d = DEVICE(dev);",
          "1275:     MPTSASState *s = MPT_SAS(dev);",
          "1277:     dev->config[PCI_LATENCY_TIMER] = 0;",
          "1278:     dev->config[PCI_INTERRUPT_PIN] = 0x01;",
          "1280:     memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s,",
          "1281:                           \"mptsas-mmio\", 0x4000);",
          "1282:     memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s,",
          "1283:                           \"mptsas-io\", 256);",
          "1284:     memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s,",
          "1285:                           \"mptsas-diag\", 0x10000);",
          "1287:     if (s->msi_available &&",
          "1288:         msi_init(dev, 0, 1, true, false) >= 0) {",
          "1289:         s->msi_in_use = true;",
          "1290:     }",
          "1292:     pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io);",
          "1293:     pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY |",
          "1294:                                  PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io);",
          "1295:     pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY |",
          "1296:                                  PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io);",
          "1298:     if (!s->sas_addr) {",
          "1299:         s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) |",
          "1300:                        IEEE_COMPANY_LOCALLY_ASSIGNED) << 36;",
          "1301:         s->sas_addr |= (pci_bus_num(dev->bus) << 16);",
          "1302:         s->sas_addr |= (PCI_SLOT(dev->devfn) << 8);",
          "1303:         s->sas_addr |= PCI_FUNC(dev->devfn);",
          "1304:     }",
          "1305:     s->max_devices = MPTSAS_NUM_PORTS;",
          "1307:     s->request_bh = qemu_bh_new(mptsas_fetch_requests, s);",
          "1309:     QTAILQ_INIT(&s->pending);",
          "1311:     scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL);",
          "1312:     if (!d->hotplugged) {",
          "1313:         scsi_bus_legacy_handle_cmdline(&s->bus, errp);",
          "1314:     }",
          "1315: }",
          "1317: static void mptsas_scsi_uninit(PCIDevice *dev)",
          "1318: {",
          "1319:     MPTSASState *s = MPT_SAS(dev);",
          "1321:     qemu_bh_delete(s->request_bh);",
          "1322:     if (s->msi_in_use) {",
          "1323:         msi_uninit(dev);",
          "1324:     }",
          "1325: }",
          "1327: static void mptsas_reset(DeviceState *dev)",
          "1328: {",
          "1329:     MPTSASState *s = MPT_SAS(dev);",
          "1331:     mptsas_hard_reset(s);",
          "1332: }",
          "1334: static int mptsas_post_load(void *opaque, int version_id)",
          "1335: {",
          "1336:     MPTSASState *s = opaque;",
          "1338:     if (s->doorbell_idx > s->doorbell_cnt ||",
          "1339:         s->doorbell_cnt > ARRAY_SIZE(s->doorbell_msg) ||",
          "1340:         s->doorbell_reply_idx > s->doorbell_reply_size ||",
          "1341:         s->doorbell_reply_size > ARRAY_SIZE(s->doorbell_reply) ||",
          "1342:         MPTSAS_FIFO_INVALID(s, request_post) ||",
          "1343:         MPTSAS_FIFO_INVALID(s, reply_post) ||",
          "1344:         MPTSAS_FIFO_INVALID(s, reply_free) ||",
          "1345:         s->diagnostic_idx > 4) {",
          "1346:         return -EINVAL;",
          "1347:     }",
          "1349:     return 0;",
          "1350: }",
          "1352: static const VMStateDescription vmstate_mptsas = {",
          "1353:     .name = \"mptsas\",",
          "1354:     .version_id = 0,",
          "1355:     .minimum_version_id = 0,",
          "1356:     .minimum_version_id_old = 0,",
          "1357:     .post_load = mptsas_post_load,",
          "1358:     .fields      = (VMStateField[]) {",
          "1359:         VMSTATE_PCI_DEVICE(dev, MPTSASState),",
          "1360:         VMSTATE_BOOL(msi_in_use, MPTSASState),",
          "1362:         VMSTATE_UINT32(state, MPTSASState),",
          "1363:         VMSTATE_UINT8(who_init, MPTSASState),",
          "1364:         VMSTATE_UINT8(doorbell_state, MPTSASState),",
          "1365:         VMSTATE_UINT32_ARRAY(doorbell_msg, MPTSASState, 256),",
          "1366:         VMSTATE_INT32(doorbell_idx, MPTSASState),",
          "1367:         VMSTATE_INT32(doorbell_cnt, MPTSASState),",
          "1369:         VMSTATE_UINT16_ARRAY(doorbell_reply, MPTSASState, 256),",
          "1370:         VMSTATE_INT32(doorbell_reply_idx, MPTSASState),",
          "1371:         VMSTATE_INT32(doorbell_reply_size, MPTSASState),",
          "1373:         VMSTATE_UINT32(diagnostic, MPTSASState),",
          "1374:         VMSTATE_UINT8(diagnostic_idx, MPTSASState),",
          "1376:         VMSTATE_UINT32(intr_status, MPTSASState),",
          "1377:         VMSTATE_UINT32(intr_mask, MPTSASState),",
          "1379:         VMSTATE_UINT32_ARRAY(request_post, MPTSASState,",
          "1380:                              MPTSAS_REQUEST_QUEUE_DEPTH + 1),",
          "1381:         VMSTATE_UINT16(request_post_head, MPTSASState),",
          "1382:         VMSTATE_UINT16(request_post_tail, MPTSASState),",
          "1384:         VMSTATE_UINT32_ARRAY(reply_post, MPTSASState,",
          "1385:                              MPTSAS_REPLY_QUEUE_DEPTH + 1),",
          "1386:         VMSTATE_UINT16(reply_post_head, MPTSASState),",
          "1387:         VMSTATE_UINT16(reply_post_tail, MPTSASState),",
          "1389:         VMSTATE_UINT32_ARRAY(reply_free, MPTSASState,",
          "1390:                              MPTSAS_REPLY_QUEUE_DEPTH + 1),",
          "1391:         VMSTATE_UINT16(reply_free_head, MPTSASState),",
          "1392:         VMSTATE_UINT16(reply_free_tail, MPTSASState),",
          "1394:         VMSTATE_UINT16(max_buses, MPTSASState),",
          "1395:         VMSTATE_UINT16(max_devices, MPTSASState),",
          "1396:         VMSTATE_UINT16(reply_frame_size, MPTSASState),",
          "1397:         VMSTATE_UINT64(host_mfa_high_addr, MPTSASState),",
          "1398:         VMSTATE_UINT64(sense_buffer_high_addr, MPTSASState),",
          "1399:         VMSTATE_END_OF_LIST()",
          "1400:     }",
          "1401: };",
          "1403: static Property mptsas_properties[] = {",
          "1404:     DEFINE_PROP_UINT64(\"sas_address\", MPTSASState, sas_addr, 0),",
          "1406:     DEFINE_PROP_BIT(\"msi\", MPTSASState, msi_available, 0, true),",
          "1407:     DEFINE_PROP_END_OF_LIST(),",
          "1408: };",
          "1410: static void mptsas1068_class_init(ObjectClass *oc, void *data)",
          "1411: {",
          "1412:     DeviceClass *dc = DEVICE_CLASS(oc);",
          "1413:     PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);",
          "1415:     pc->realize = mptsas_scsi_init;",
          "1416:     pc->exit = mptsas_scsi_uninit;",
          "1417:     pc->romfile = 0;",
          "1418:     pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;",
          "1419:     pc->device_id = PCI_DEVICE_ID_LSI_SAS1068;",
          "1420:     pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;",
          "1421:     pc->subsystem_id = 0x8000;",
          "1422:     pc->class_id = PCI_CLASS_STORAGE_SCSI;",
          "1423:     dc->props = mptsas_properties;",
          "1424:     dc->reset = mptsas_reset;",
          "1425:     dc->vmsd = &vmstate_mptsas;",
          "1426:     dc->desc = \"LSI SAS 1068\";",
          "1427: }",
          "1429: static const TypeInfo mptsas_info = {",
          "1430:     .name = TYPE_MPTSAS1068,",
          "1431:     .parent = TYPE_PCI_DEVICE,",
          "1432:     .instance_size = sizeof(MPTSASState),",
          "1433:     .class_init = mptsas1068_class_init,",
          "1434: };",
          "1436: static void mptsas_register_types(void)",
          "1437: {",
          "1438:     type_register(&mptsas_info);",
          "1439: }",
          "1441: type_init(mptsas_register_types)",
          "",
          "---------------"
        ],
        "hw/scsi/mptsas.h||hw/scsi/mptsas.h": [
          "File: hw/scsi/mptsas.h -> hw/scsi/mptsas.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #ifndef MPTSAS_H",
          "2: #define MPTSAS_H",
          "4: #include \"mpi.h\"",
          "6: #define MPTSAS_NUM_PORTS 8",
          "9: #define MPTSAS_REQUEST_QUEUE_DEPTH 128",
          "10: #define MPTSAS_REPLY_QUEUE_DEPTH   128",
          "12: #define MPTSAS_MAXIMUM_CHAIN_DEPTH 0x22",
          "14: typedef struct MPTSASState MPTSASState;",
          "15: typedef struct MPTSASRequest MPTSASRequest;",
          "17: enum {",
          "18:     DOORBELL_NONE,",
          "19:     DOORBELL_WRITE,",
          "20:     DOORBELL_READ",
          "21: };",
          "23: struct MPTSASState {",
          "24:     PCIDevice dev;",
          "25:     MemoryRegion mmio_io;",
          "26:     MemoryRegion port_io;",
          "27:     MemoryRegion diag_io;",
          "28:     QEMUBH *request_bh;",
          "30:     uint32_t msi_available;",
          "31:     uint64_t sas_addr;",
          "33:     bool msi_in_use;",
          "36:     uint32_t state;",
          "37:     uint8_t who_init;",
          "38:     uint8_t doorbell_state;",
          "41:     uint32_t doorbell_msg[256];",
          "42:     int doorbell_idx;",
          "43:     int doorbell_cnt;",
          "45:     uint16_t doorbell_reply[256];",
          "46:     int doorbell_reply_idx;",
          "47:     int doorbell_reply_size;",
          "50:     uint8_t diagnostic_idx;",
          "51:     uint32_t diagnostic;",
          "52:     uint32_t intr_mask;",
          "53:     uint32_t intr_status;",
          "56:     uint32_t request_post[MPTSAS_REQUEST_QUEUE_DEPTH + 1];",
          "57:     uint16_t request_post_head;",
          "58:     uint16_t request_post_tail;",
          "60:     uint32_t reply_post[MPTSAS_REPLY_QUEUE_DEPTH + 1];",
          "61:     uint16_t reply_post_head;",
          "62:     uint16_t reply_post_tail;",
          "64:     uint32_t reply_free[MPTSAS_REPLY_QUEUE_DEPTH + 1];",
          "65:     uint16_t reply_free_head;",
          "66:     uint16_t reply_free_tail;",
          "69:     hwaddr host_mfa_high_addr;",
          "70:     hwaddr sense_buffer_high_addr;",
          "71:     uint16_t max_devices;",
          "72:     uint16_t max_buses;",
          "73:     uint16_t reply_frame_size;",
          "75:     SCSIBus bus;",
          "76:     QTAILQ_HEAD(, MPTSASRequest) pending;",
          "77: };",
          "79: void mptsas_fix_scsi_io_endianness(MPIMsgSCSIIORequest *req);",
          "80: void mptsas_fix_scsi_io_reply_endianness(MPIMsgSCSIIOReply *reply);",
          "81: void mptsas_fix_scsi_task_mgmt_endianness(MPIMsgSCSITaskMgmt *req);",
          "82: void mptsas_fix_scsi_task_mgmt_reply_endianness(MPIMsgSCSITaskMgmtReply *reply);",
          "83: void mptsas_fix_ioc_init_endianness(MPIMsgIOCInit *req);",
          "84: void mptsas_fix_ioc_init_reply_endianness(MPIMsgIOCInitReply *reply);",
          "85: void mptsas_fix_ioc_facts_endianness(MPIMsgIOCFacts *req);",
          "86: void mptsas_fix_ioc_facts_reply_endianness(MPIMsgIOCFactsReply *reply);",
          "87: void mptsas_fix_config_endianness(MPIMsgConfig *req);",
          "88: void mptsas_fix_config_reply_endianness(MPIMsgConfigReply *reply);",
          "89: void mptsas_fix_port_facts_endianness(MPIMsgPortFacts *req);",
          "90: void mptsas_fix_port_facts_reply_endianness(MPIMsgPortFactsReply *reply);",
          "91: void mptsas_fix_port_enable_endianness(MPIMsgPortEnable *req);",
          "92: void mptsas_fix_port_enable_reply_endianness(MPIMsgPortEnableReply *reply);",
          "93: void mptsas_fix_event_notification_endianness(MPIMsgEventNotify *req);",
          "94: void mptsas_fix_event_notification_reply_endianness(MPIMsgEventNotifyReply *reply);",
          "96: void mptsas_reply(MPTSASState *s, MPIDefaultReply *reply);",
          "98: void mptsas_process_config(MPTSASState *s, MPIMsgConfig *req);",
          "",
          "---------------"
        ],
        "include/hw/pci/pci_ids.h||include/hw/pci/pci_ids.h": [
          "File: include/hw/pci/pci_ids.h -> include/hw/pci/pci_ids.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "64: #define PCI_VENDOR_ID_LSI_LOGIC          0x1000",
          "65: #define PCI_DEVICE_ID_LSI_53C810         0x0001",
          "66: #define PCI_DEVICE_ID_LSI_53C895A        0x0012",
          "67: #define PCI_DEVICE_ID_LSI_SAS1078        0x0060",
          "68: #define PCI_DEVICE_ID_LSI_SAS0079        0x0079",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "67: #define PCI_DEVICE_ID_LSI_SAS1068        0x0054",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-8787",
  "cve_desc": "The nf_nat_redirect_ipv4 function in net/netfilter/nf_nat_redirect.c in the Linux kernel before 4.4 allows remote attackers to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by sending certain IPv4 packets to an incompletely configured interface, a related issue to CVE-2003-1604.",
  "repo": "torvalds/linux",
  "patch_hash": "94f9cd81436c85d8c3a318ba92e236ede73752fc",
  "patch_info": {
    "commit_hash": "94f9cd81436c85d8c3a318ba92e236ede73752fc",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/94f9cd81436c85d8c3a318ba92e236ede73752fc",
    "files": [
      "net/netfilter/nf_nat_redirect.c"
    ],
    "message": "netfilter: nf_nat_redirect: add missing NULL pointer check\n\nCommit 8b13eddfdf04cbfa561725cfc42d6868fe896f56 (\"netfilter: refactor NAT\nredirect IPv4 to use it from nf_tables\") has introduced a trivial logic\nchange which can result in the following crash.\n\nBUG: unable to handle kernel NULL pointer dereference at 0000000000000030\nIP: [<ffffffffa033002d>] nf_nat_redirect_ipv4+0x2d/0xa0 [nf_nat_redirect]\nPGD 3ba662067 PUD 3ba661067 PMD 0\nOops: 0000 [#1] SMP\nModules linked in: ipv6(E) xt_REDIRECT(E) nf_nat_redirect(E) xt_tcpudp(E) iptable_nat(E) nf_conntrack_ipv4(E) nf_defrag_ipv4(E) nf_nat_ipv4(E) nf_nat(E) nf_conntrack(E) ip_tables(E) x_tables(E) binfmt_misc(E) xfs(E) libcrc32c(E) evbug(E) evdev(E) psmouse(E) i2c_piix4(E) i2c_core(E) acpi_cpufreq(E) button(E) ext4(E) crc16(E) jbd2(E) mbcache(E) dm_mirror(E) dm_region_hash(E) dm_log(E) dm_mod(E)\nCPU: 0 PID: 2536 Comm: ip Tainted: G            E   4.1.7-15.23.amzn1.x86_64 #1\nHardware name: Xen HVM domU, BIOS 4.2.amazon 05/06/2015\ntask: ffff8800eb438000 ti: ffff8803ba664000 task.ti: ffff8803ba664000\n[...]\nCall Trace:\n <IRQ>\n [<ffffffffa0334065>] redirect_tg4+0x15/0x20 [xt_REDIRECT]\n [<ffffffffa02e2e99>] ipt_do_table+0x2b9/0x5e1 [ip_tables]\n [<ffffffffa0328045>] iptable_nat_do_chain+0x25/0x30 [iptable_nat]\n [<ffffffffa031777d>] nf_nat_ipv4_fn+0x13d/0x1f0 [nf_nat_ipv4]\n [<ffffffffa0328020>] ? iptable_nat_ipv4_fn+0x20/0x20 [iptable_nat]\n [<ffffffffa031785e>] nf_nat_ipv4_in+0x2e/0x90 [nf_nat_ipv4]\n [<ffffffffa03280a5>] iptable_nat_ipv4_in+0x15/0x20 [iptable_nat]\n [<ffffffff81449137>] nf_iterate+0x57/0x80\n [<ffffffff814491f7>] nf_hook_slow+0x97/0x100\n [<ffffffff814504d4>] ip_rcv+0x314/0x400\n\nunsigned int\nnf_nat_redirect_ipv4(struct sk_buff *skb,\n...\n{\n...\n\t\trcu_read_lock();\n\t\tindev = __in_dev_get_rcu(skb->dev);\n\t\tif (indev != NULL) {\n\t\t\tifa = indev->ifa_list;\n\t\t\tnewdst = ifa->ifa_local; <---\n\t\t}\n\t\trcu_read_unlock();\n...\n}\n\nBefore the commit, 'ifa' had been always checked before access. After the\ncommit, however, it could be accessed even if it's NULL. Interestingly,\nthis was once fixed in 2003.\n\nhttp://marc.info/?l=netfilter-devel&m=106668497403047&w=2\n\nIn addition to the original one, we have seen the crash when packets that\nneed to be redirected somehow arrive on an interface which hasn't been\nyet fully configured.\n\nThis change just reverts the logic to the old behavior to avoid the crash.\n\nFixes: 8b13eddfdf04 (\"netfilter: refactor NAT redirect IPv4 to use it from nf_tables\")\nSigned-off-by: Munehisa Kamata <kamatam@amazon.com>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",
    "before_after_code_files": [
      "net/netfilter/nf_nat_redirect.c||net/netfilter/nf_nat_redirect.c"
    ]
  },
  "patch_diff": {
    "net/netfilter/nf_nat_redirect.c||net/netfilter/nf_nat_redirect.c": [
      "File: net/netfilter/nf_nat_redirect.c -> net/netfilter/nf_nat_redirect.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "56:   rcu_read_lock();",
      "57:   indev = __in_dev_get_rcu(skb->dev);",
      "59:    ifa = indev->ifa_list;",
      "60:    newdst = ifa->ifa_local;",
      "61:   }",
      "",
      "[Removed Lines]",
      "58:   if (indev != NULL) {",
      "",
      "[Added Lines]",
      "58:   if (indev && indev->ifa_list) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f3c63795e90f0c6238306883b6c72f14d5355721",
      "candidate_info": {
        "commit_hash": "f3c63795e90f0c6238306883b6c72f14d5355721",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f3c63795e90f0c6238306883b6c72f14d5355721",
        "files": [
          "drivers/mtd/mtd_blkdevs.c"
        ],
        "message": "mtd: blkdevs: fix potential deadlock + lockdep warnings\n\nCommit 073db4a51ee4 (\"mtd: fix: avoid race condition when accessing\nmtd->usecount\") fixed a race condition but due to poor ordering of the\nmutex acquisition, introduced a potential deadlock.\n\nThe deadlock can occur, for example, when rmmod'ing the m25p80 module, which\nwill delete one or more MTDs, along with any corresponding mtdblock\ndevices. This could potentially race with an acquisition of the block\ndevice as follows.\n\n -> blktrans_open()\n    ->  mutex_lock(&dev->lock);\n    ->  mutex_lock(&mtd_table_mutex);\n\n -> del_mtd_device()\n    ->  mutex_lock(&mtd_table_mutex);\n    ->  blktrans_notify_remove() -> del_mtd_blktrans_dev()\n       ->  mutex_lock(&dev->lock);\n\nThis is a classic (potential) ABBA deadlock, which can be fixed by\nmaking the A->B ordering consistent everywhere. There was no real\npurpose to the ordering in the original patch, AFAIR, so this shouldn't\nbe a problem. This ordering was actually already present in\ndel_mtd_blktrans_dev(), for one, where the function tried to ensure that\nits caller already held mtd_table_mutex before it acquired &dev->lock:\n\n        if (mutex_trylock(&mtd_table_mutex)) {\n                mutex_unlock(&mtd_table_mutex);\n                BUG();\n        }\n\nSo, reverse the ordering of acquisition of &dev->lock and &mtd_table_mutex so\nwe always acquire mtd_table_mutex first.\n\nSnippets of the lockdep output follow:\n\n  # modprobe -r m25p80\n  [   53.419251]\n  [   53.420838] ======================================================\n  [   53.427300] [ INFO: possible circular locking dependency detected ]\n  [   53.433865] 4.3.0-rc6 #96 Not tainted\n  [   53.437686] -------------------------------------------------------\n  [   53.444220] modprobe/372 is trying to acquire lock:\n  [   53.449320]  (&new->lock){+.+...}, at: [<c043fe4c>] del_mtd_blktrans_dev+0x80/0xdc\n  [   53.457271]\n  [   53.457271] but task is already holding lock:\n  [   53.463372]  (mtd_table_mutex){+.+.+.}, at: [<c0439994>] del_mtd_device+0x18/0x100\n  [   53.471321]\n  [   53.471321] which lock already depends on the new lock.\n  [   53.471321]\n  [   53.479856]\n  [   53.479856] the existing dependency chain (in reverse order) is:\n  [   53.487660]\n  -> #1 (mtd_table_mutex){+.+.+.}:\n  [   53.492331]        [<c043fc5c>] blktrans_open+0x34/0x1a4\n  [   53.497879]        [<c01afce0>] __blkdev_get+0xc4/0x3b0\n  [   53.503364]        [<c01b0bb8>] blkdev_get+0x108/0x320\n  [   53.508743]        [<c01713c0>] do_dentry_open+0x218/0x314\n  [   53.514496]        [<c0180454>] path_openat+0x4c0/0xf9c\n  [   53.519959]        [<c0182044>] do_filp_open+0x5c/0xc0\n  [   53.525336]        [<c0172758>] do_sys_open+0xfc/0x1cc\n  [   53.530716]        [<c000f740>] ret_fast_syscall+0x0/0x1c\n  [   53.536375]\n  -> #0 (&new->lock){+.+...}:\n  [   53.540587]        [<c063f124>] mutex_lock_nested+0x38/0x3cc\n  [   53.546504]        [<c043fe4c>] del_mtd_blktrans_dev+0x80/0xdc\n  [   53.552606]        [<c043f164>] blktrans_notify_remove+0x7c/0x84\n  [   53.558891]        [<c04399f0>] del_mtd_device+0x74/0x100\n  [   53.564544]        [<c043c670>] del_mtd_partitions+0x80/0xc8\n  [   53.570451]        [<c0439aa0>] mtd_device_unregister+0x24/0x48\n  [   53.576637]        [<c046ce6c>] spi_drv_remove+0x1c/0x34\n  [   53.582207]        [<c03de0f0>] __device_release_driver+0x88/0x114\n  [   53.588663]        [<c03de19c>] device_release_driver+0x20/0x2c\n  [   53.594843]        [<c03dd9e8>] bus_remove_device+0xd8/0x108\n  [   53.600748]        [<c03dacc0>] device_del+0x10c/0x210\n  [   53.606127]        [<c03dadd0>] device_unregister+0xc/0x20\n  [   53.611849]        [<c046d878>] __unregister+0x10/0x20\n  [   53.617211]        [<c03da868>] device_for_each_child+0x50/0x7c\n  [   53.623387]        [<c046eae8>] spi_unregister_master+0x58/0x8c\n  [   53.629578]        [<c03e12f0>] release_nodes+0x15c/0x1c8\n  [   53.635223]        [<c03de0f8>] __device_release_driver+0x90/0x114\n  [   53.641689]        [<c03de900>] driver_detach+0xb4/0xb8\n  [   53.647147]        [<c03ddc78>] bus_remove_driver+0x4c/0xa0\n  [   53.652970]        [<c00cab50>] SyS_delete_module+0x11c/0x1e4\n  [   53.658976]        [<c000f740>] ret_fast_syscall+0x0/0x1c\n  [   53.664621]\n  [   53.664621] other info that might help us debug this:\n  [   53.664621]\n  [   53.672979]  Possible unsafe locking scenario:\n  [   53.672979]\n  [   53.679169]        CPU0                    CPU1\n  [   53.683900]        ----                    ----\n  [   53.688633]   lock(mtd_table_mutex);\n  [   53.692383]                                lock(&new->lock);\n  [   53.698306]                                lock(mtd_table_mutex);\n  [   53.704658]   lock(&new->lock);\n  [   53.707946]\n  [   53.707946]  *** DEADLOCK ***\n\nFixes: 073db4a51ee4 (\"mtd: fix: avoid race condition when accessing mtd->usecount\")\nReported-by: Felipe Balbi <balbi@ti.com>\nTested-by: Felipe Balbi <balbi@ti.com>\nSigned-off-by: Brian Norris <computersforpeace@gmail.com>\nCc: <stable@vger.kernel.org>",
        "before_after_code_files": [
          "drivers/mtd/mtd_blkdevs.c||drivers/mtd/mtd_blkdevs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/mtd/mtd_blkdevs.c||drivers/mtd/mtd_blkdevs.c": [
          "File: drivers/mtd/mtd_blkdevs.c -> drivers/mtd/mtd_blkdevs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "192:  if (!dev)",
          "196:  mutex_lock(&mtd_table_mutex);",
          "198:  if (dev->open)",
          "199:   goto unlock;",
          "",
          "[Removed Lines]",
          "195:  mutex_lock(&dev->lock);",
          "",
          "[Added Lines]",
          "196:  mutex_lock(&dev->lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "218: unlock:",
          "219:  dev->open++;",
          "221:  mutex_unlock(&dev->lock);",
          "222:  blktrans_dev_put(dev);",
          "223:  return ret;",
          "",
          "[Removed Lines]",
          "220:  mutex_unlock(&mtd_table_mutex);",
          "",
          "[Added Lines]",
          "221:  mutex_unlock(&mtd_table_mutex);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "228: error_put:",
          "229:  module_put(dev->tr->owner);",
          "230:  kref_put(&dev->ref, blktrans_dev_release);",
          "232:  mutex_unlock(&dev->lock);",
          "233:  blktrans_dev_put(dev);",
          "234:  return ret;",
          "235: }",
          "",
          "[Removed Lines]",
          "231:  mutex_unlock(&mtd_table_mutex);",
          "",
          "[Added Lines]",
          "232:  mutex_unlock(&mtd_table_mutex);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "241:  if (!dev)",
          "242:   return;",
          "245:  mutex_lock(&mtd_table_mutex);",
          "247:  if (--dev->open)",
          "248:   goto unlock;",
          "",
          "[Removed Lines]",
          "244:  mutex_lock(&dev->lock);",
          "",
          "[Added Lines]",
          "245:  mutex_lock(&dev->lock);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "256:   __put_mtd_device(dev->mtd);",
          "257:  }",
          "258: unlock:",
          "260:  mutex_unlock(&dev->lock);",
          "261:  blktrans_dev_put(dev);",
          "262: }",
          "",
          "[Removed Lines]",
          "259:  mutex_unlock(&mtd_table_mutex);",
          "",
          "[Added Lines]",
          "260:  mutex_unlock(&mtd_table_mutex);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d57456753787ab158f906f1f8eb58d54a2ccd9f4",
      "candidate_info": {
        "commit_hash": "d57456753787ab158f906f1f8eb58d54a2ccd9f4",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d57456753787ab158f906f1f8eb58d54a2ccd9f4",
        "files": [
          "kernel/cgroup.c"
        ],
        "message": "cgroup: fix race condition around termination check in css_task_iter_next()\n\ncss_task_iter_next() checked @it->cur_task before grabbing\ncss_set_lock and assumed that the result won't change afterwards;\nhowever, tasks could leave the cgroup being iterated terminating the\niterator before css_task_lock is acquired.  If this happens,\ncss_task_iter_next() tries to calculate the current task from NULL\ncg_list pointer leading to the following oops.\n\n BUG: unable to handle kernel paging request at fffffffffffff7d0\n IP: [<ffffffff810d5f22>] css_task_iter_next+0x42/0x80\n ...\n CPU: 4 PID: 6391 Comm: JobQDisp2 Not tainted 4.0.9-22_fbk4_rc3_81616_ge8d9cb6 #1\n Hardware name: Quanta Freedom/Winterfell, BIOS F03_3B08 03/04/2014\n task: ffff880868e46400 ti: ffff88083404c000 task.ti: ffff88083404c000\n RIP: 0010:[<ffffffff810d5f22>]  [<ffffffff810d5f22>] css_task_iter_next+0x42/0x80\n RSP: 0018:ffff88083404fd28  EFLAGS: 00010246\n RAX: 0000000000000000 RBX: ffff88083404fd68 RCX: ffff8804697fb8b0\n RDX: fffffffffffff7c0 RSI: ffff8803b7dff800 RDI: ffffffff822c0278\n RBP: ffff88083404fd38 R08: 0000000000017160 R09: ffff88046f4070c0\n R10: ffffffff810d61f7 R11: 0000000000000293 R12: ffff880863bf8400\n R13: ffff88046b87fd80 R14: 0000000000000000 R15: ffff88083404fe58\n FS:  00007fa0567e2700(0000) GS:ffff88046f900000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: fffffffffffff7d0 CR3: 0000000469568000 CR4: 00000000001406e0\n Stack:\n  0000000000000246 0000000000000000 ffff88083404fde8 ffffffff810d6248\n  ffff88083404fd68 0000000000000000 ffff8803b7dff800 000001ef000001ee\n  0000000000000000 0000000000000000 ffff880863bf8568 0000000000000000\n Call Trace:\n  [<ffffffff810d6248>] cgroup_pidlist_start+0x258/0x550\n  [<ffffffff810cf66d>] cgroup_seqfile_start+0x1d/0x20\n  [<ffffffff8121f8ef>] kernfs_seq_start+0x5f/0xa0\n  [<ffffffff811cab76>] seq_read+0x166/0x380\n  [<ffffffff812200fd>] kernfs_fop_read+0x11d/0x180\n  [<ffffffff811a7398>] __vfs_read+0x18/0x50\n  [<ffffffff811a745d>] vfs_read+0x8d/0x150\n  [<ffffffff811a756f>] SyS_read+0x4f/0xb0\n  [<ffffffff818d4772>] system_call_fastpath+0x12/0x17\n\nFix it by moving the termination condition check inside css_set_lock.\n@it->cur_task is now cleared after being put and @it->task_pos is\ntested for termination instead of @it->cset_pos as they indicate the\nsame condition and @it->task_pos is what's being dereferenced.\n\nSigned-off-by: Tejun Heo <tj@kernel.org>\nReported-by: Calvin Owens <calvinowens@fb.com>\nFixes: ed27b9f7a17d (\"cgroup: don't hold css_set_rwsem across css task iteration\")\nAcked-by: Zefan Li <lizefan@huawei.com>",
        "before_after_code_files": [
          "kernel/cgroup.c||kernel/cgroup.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "kernel/cgroup.c||kernel/cgroup.c": [
          "File: kernel/cgroup.c -> kernel/cgroup.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3931: struct task_struct *css_task_iter_next(struct css_task_iter *it)",
          "3932: {",
          "3937:   put_task_struct(it->cur_task);",
          "3939:  spin_lock_bh(&css_set_lock);",
          "3946:  spin_unlock_bh(&css_set_lock);",
          "",
          "[Removed Lines]",
          "3933:  if (!it->cset_pos)",
          "3934:   return NULL;",
          "3936:  if (it->cur_task)",
          "3941:  it->cur_task = list_entry(it->task_pos, struct task_struct, cg_list);",
          "3942:  get_task_struct(it->cur_task);",
          "3944:  css_task_iter_advance(it);",
          "",
          "[Added Lines]",
          "3933:  if (it->cur_task) {",
          "3935:   it->cur_task = NULL;",
          "3936:  }",
          "3940:  if (it->task_pos) {",
          "3941:   it->cur_task = list_entry(it->task_pos, struct task_struct,",
          "3942:        cg_list);",
          "3943:   get_task_struct(it->cur_task);",
          "3944:   css_task_iter_advance(it);",
          "3945:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "75e34f5cf69bd731d3b7375a786d4a15494fb8c6",
      "candidate_info": {
        "commit_hash": "75e34f5cf69bd731d3b7375a786d4a15494fb8c6",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/75e34f5cf69bd731d3b7375a786d4a15494fb8c6",
        "files": [
          "net/bluetooth/sco.c"
        ],
        "message": "Bluetooth: Fix crash on SCO disconnect\n\nWhen disconnecting audio from the phone's side, it may happen, that\na thread handling HCI message 'disconnection complete' will get preempted\nin 'sco_conn_del' before calling 'sco_sock_kill', still holding a pointer\nto struct sock sk. Interrupting thread started in 'sco_sock_shutdown' will\ncarry on releasing resources and will eventually release struct sock.\nWhen execution goes back to first thread it will call sco_sock_kill using\nnow invalid pointer to already destroyed socket.\n\nFix is to grab a reference to the socket a release it after calling\n'sco_sock_kill'.\n\n[  166.358213] BUG: unable to handle kernel paging request at 7541203a\n[  166.365228] IP: [<fb6e8bfb>] bt_sock_unlink+0x1a/0x38 [bluetooth]\n[  166.372068] *pdpt = 0000000024b19001 *pde = 0000000000000000\n[  166.378483] Oops: 0002 [#1] PREEMPT SMP\n[  166.382871] Modules linked in: evdev ecb rfcomm(O) libcomposite usb2380 udc_core bnep(O) btusb(O) btbcm(O) btintel(O) cdc_acm bluetooth(O) arc4 uinput hid_multitouch iwlmvm(O) usbhid hide\n[  166.424233] Pid: 338, comm: kworker/u:2H Tainted: G           O 3.8.0-115.1-plk-adaptation-byt-ivi-brd #1\n[  166.435112] EIP: 0060:[<fb6e8bfb>] EFLAGS: 00010206 CPU: 0\n[  166.441259] EIP is at bt_sock_unlink+0x1a/0x38 [bluetooth]\n[  166.447382] EAX: 632e6563 EBX: e4bfc600 ECX: e466d4d3 EDX: 7541203a\n[  166.454369] ESI: fb7278ac EDI: e4d52000 EBP: e4669e20 ESP: e4669e0c\n[  166.461366]  DS: 007b ES: 007b FS: 00d8 GS: 0000 SS: 0068\n[  166.467391] CR0: 8005003b CR2: 7541203a CR3: 24aba000 CR4: 001007f0\n[  166.474387] DR0: 00000000 DR1: 00000000 DR2: 00000000 DR3: 00000000\n[  166.481375] DR6: ffff0ff0 DR7: 00000400\n[  166.485654] Process kworker/u:2H (pid: 338, ti=e4668000 task=e466e030 task.ti=e4668000)\n[  166.494591] Stack:\n[  166.496830]  e4bfc600 e4bfc600 fb715c28 e4717ee0 e4d52000 e4669e3c fb715cf3 e4bfc634\n[  166.505518]  00000068 e4d52000 e4c32000 fb7277c0 e4669e6c fb6f2019 0000004a 00000216\n[  166.514205]  e4660101 e4c32008 02000001 00000013 e4d52000 e4c32000 e3dc9240 00000005\n[  166.522891] Call Trace:\n[  166.525654]  [<fb715c28>] ? sco_sock_kill+0x73/0x9a [bluetooth]\n[  166.532295]  [<fb715cf3>] ? sco_conn_del+0xa4/0xbf [bluetooth]\n[  166.538836]  [<fb6f2019>] ? hci_disconn_complete_evt.clone.55+0x1bd/0x205 [bluetooth]\n[  166.547609]  [<fb6f73d3>] ? hci_event_packet+0x297/0x223c [bluetooth]\n[  166.554805]  [<c10416da>] ? dequeue_task+0xaf/0xb7\n[  166.560154]  [<c1041095>] ? finish_task_switch+0x50/0x89\n[  166.566086]  [<c1349a2e>] ? __schedule+0x638/0x6b8\n[  166.571460]  [<fb6eb906>] ? hci_rx_work+0xb9/0x2b8 [bluetooth]\n[  166.577975]  [<c1035df9>] ? process_one_work+0x157/0x21b\n[  166.583933]  [<fb6eb84d>] ? hci_cmd_work+0xef/0xef [bluetooth]\n[  166.590448]  [<c1036217>] ? worker_thread+0x16e/0x20a\n[  166.596088]  [<c10360a9>] ? manage_workers+0x1cf/0x1cf\n[  166.601826]  [<c103a0ef>] ? kthread+0x8d/0x92\n[  166.606691]  [<c134adf7>] ? ret_from_kernel_thread+0x1b/0x28\n[  166.613010]  [<c103a062>] ? __init_kthread_worker+0x24/0x24\n[  166.619230] Code: 85 63 ff ff ff 31 db 8d 65 f4 89 d8 5b 5e 5f 5d c3 56 8d 70 04 53 89 f0 89 d3 e8 7e 17 c6 c5 8b 53 28 85 d2 74 1a 8b 43 24 85 c0 <89> 02 74 03 89 50 04 c7 43 28 00 00 00\n[  166.640501] EIP: [<fb6e8bfb>] bt_sock_unlink+0x1a/0x38 [bluetooth] SS:ESP 0068:e4669e0c\n[  166.649474] CR2: 000000007541203a\n[  166.653420] ---[ end trace 0181ff2c9e42d51e ]---\n[  166.658609] note: kworker/u:2H[338] exited with preempt_count 1\n\nSigned-off-by: Kuba Pawlak <kubax.t.pawlak@intel.com>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>",
        "before_after_code_files": [
          "net/bluetooth/sco.c||net/bluetooth/sco.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/bluetooth/sco.c||net/bluetooth/sco.c": [
          "File: net/bluetooth/sco.c -> net/bluetooth/sco.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "170:  sco_conn_unlock(conn);",
          "172:  if (sk) {",
          "173:   bh_lock_sock(sk);",
          "174:   sco_sock_clear_timer(sk);",
          "175:   sco_chan_del(sk, err);",
          "176:   bh_unlock_sock(sk);",
          "177:   sco_sock_kill(sk);",
          "178:  }",
          "180:  hcon->sco_data = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "173:   sock_hold(sk);",
          "179:   sock_put(sk);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2c501cdd6823a644cf35ac594c635310bf077125",
      "candidate_info": {
        "commit_hash": "2c501cdd6823a644cf35ac594c635310bf077125",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2c501cdd6823a644cf35ac594c635310bf077125",
        "files": [
          "net/bluetooth/sco.c"
        ],
        "message": "Bluetooth: Fix crash on fast disconnect of SCO\n\nFix a crash that may happen when a connection is closed before it was fully\nestablished. Mapping conn->hcon was released by shutdown function, but it\nis still referenced in (not yet finished) connection established handling\nfunction.\n\n[ 4635.254073] BUG: unable to handle kernel NULL pointer dereference at 00000013\n[ 4635.262058] IP: [<c11659f0>] memcmp+0xe/0x25\n[ 4635.266835] *pdpt = 0000000024190001 *pde = 0000000000000000\n[ 4635.273261] Oops: 0000 [#1] PREEMPT SMP\n[ 4635.277652] Modules linked in: evdev ecb vfat fat libcomposite usb2380 isofs zlib_inflate rfcomm(O) udc_core bnep(O) btusb(O) btbcm(O) btintel(O) bluetooth(O) cdc_acm arc4 uinput hid_mule\n[ 4635.321761] Pid: 363, comm: kworker/u:2H Tainted: G           O 3.8.0-119.1-plk-adaptation-byt-ivi-brd #1\n[ 4635.332642] EIP: 0060:[<c11659f0>] EFLAGS: 00010206 CPU: 0\n[ 4635.338767] EIP is at memcmp+0xe/0x25\n[ 4635.342852] EAX: e4720678 EBX: 00000000 ECX: 00000006 EDX: 00000013\n[ 4635.349849] ESI: 00000000 EDI: fb85366c EBP: e40c7dc0 ESP: e40c7db4\n[ 4635.356846]  DS: 007b ES: 007b FS: 00d8 GS: 0000 SS: 0068\n[ 4635.362873] CR0: 8005003b CR2: 00000013 CR3: 24191000 CR4: 001007f0\n[ 4635.369869] DR0: 00000000 DR1: 00000000 DR2: 00000000 DR3: 00000000\n[ 4635.376865] DR6: ffff0ff0 DR7: 00000400\n[ 4635.381143] Process kworker/u:2H (pid: 363, ti=e40c6000 task=e40c5510 task.ti=e40c6000)\n[ 4635.390080] Stack:\n[ 4635.392319]  e4720400 00000000 fb85366c e40c7df4 fb842285 e40c7de2 fb853200 00000013\n[ 4635.401003]  e3f101c4 e4720678 e3f101c0 e403be0a e40c7dfc e416a000 e403be0a fb85366c\n[ 4635.409692]  e40c7e1c fb820186 020f6c00 e47c49ac e47c4008 00000000 e416a000 e47c402c\n[ 4635.418380] Call Trace:\n[ 4635.421153]  [<fb842285>] sco_connect_cfm+0xff/0x236 [bluetooth]\n[ 4635.427893]  [<fb820186>] hci_sync_conn_complete_evt.clone.101+0x227/0x268 [bluetooth]\n[ 4635.436758]  [<fb82370f>] hci_event_packet+0x1caa/0x21d3 [bluetooth]\n[ 4635.443859]  [<c106231f>] ? trace_hardirqs_on+0xb/0xd\n[ 4635.449502]  [<c1375b8a>] ? _raw_spin_unlock_irqrestore+0x42/0x59\n[ 4635.456340]  [<fb814b67>] hci_rx_work+0xb9/0x350 [bluetooth]\n[ 4635.462663]  [<c1039f1e>] ? process_one_work+0x17b/0x2e6\n[ 4635.468596]  [<c1039f77>] process_one_work+0x1d4/0x2e6\n[ 4635.474333]  [<c1039f1e>] ? process_one_work+0x17b/0x2e6\n[ 4635.480294]  [<fb814aae>] ? hci_cmd_work+0xda/0xda [bluetooth]\n[ 4635.486810]  [<c103a3fa>] worker_thread+0x171/0x20f\n[ 4635.492257]  [<c10456c5>] ? complete+0x34/0x3e\n[ 4635.497219]  [<c103ea06>] kthread+0x90/0x95\n[ 4635.501888]  [<c103a289>] ? manage_workers+0x1df/0x1df\n[ 4635.507628]  [<c1376537>] ret_from_kernel_thread+0x1b/0x28\n[ 4635.513755]  [<c103e976>] ? __init_kthread_worker+0x42/0x42\n[ 4635.519975] Code: 74 0d 3c 79 74 04 3c 59 75 0c c6 02 01 eb 03 c6 02 00 31 c0 eb 05 b8 ea ff ff ff 5d c3 55 89 e5 57 56 53 31 db eb 0e 0f b6 34 18 <0f> b6 3c 1a 43 29 fe 75 07 49 85 c9 7f\n[ 4635.541264] EIP: [<c11659f0>] memcmp+0xe/0x25 SS:ESP 0068:e40c7db4\n[ 4635.548166] CR2: 0000000000000013\n[ 4635.552177] ---[ end trace e05ce9b8ce6182f6 ]---\n\nSigned-off-by: Kuba Pawlak <kubax.t.pawlak@intel.com>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>",
        "before_after_code_files": [
          "net/bluetooth/sco.c||net/bluetooth/sco.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/bluetooth/sco.c||net/bluetooth/sco.c": [
          "File: net/bluetooth/sco.c -> net/bluetooth/sco.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1033:  } else {",
          "1034:   sco_conn_lock(conn);",
          "1036:   parent = sco_get_sock_listen(&conn->hcon->src);",
          "1037:   if (!parent) {",
          "1038:    sco_conn_unlock(conn);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1036:   if (!conn->hcon) {",
          "1037:    sco_conn_unlock(conn);",
          "1038:    return;",
          "1039:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "435c513369768f5840cd57101e398bc450fd26de",
      "candidate_info": {
        "commit_hash": "435c513369768f5840cd57101e398bc450fd26de",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/435c513369768f5840cd57101e398bc450fd26de",
        "files": [
          "net/bluetooth/sco.c"
        ],
        "message": "Bluetooth: Fix locking issue on SCO disconnection\n\nThread handling SCO disconnection may get preempted in '__sco_sock_close'\nafter dropping a reference to hci_conn but before marking this as NULL\nin associated struct sco_conn. When execution returs to this thread,\nthis connection will possibly be released, resulting in kernel crash\n\nLock connection before this point.\n\nBUG: unable to handle kernel NULL pointer dereference at   (null)\nIP: [<fb770ab9>] __sco_sock_close+0x194/0x1ff [bluetooth]\n*pdpt = 0000000023da6001 *pde = 0000000000000000\nOops: 0002 [#1] PREEMPT SMP\nModules linked in: evdev ecb rfcomm(O) libcomposite usb2380 udc_core bnep(O) btusb(O) btbcm(O) cdc_acm btintel(O) bluetooth(O) arc4 uinput hid_multitouch usbhid iwlmvm(O) hide\nPid: 984, comm: bluetooth Tainted: G           O 3.8.0-115.1-plk-adaptation-byt-ivi-brd #1\nEIP: 0060:[<fb770ab9>] EFLAGS: 00010282 CPU: 2\nEIP is at __sco_sock_close+0x194/0x1ff [bluetooth]\nEAX: 00000000 EBX: e49d7600 ECX: ef1ec3c2 EDX: 000000c3\nESI: e4c12000 EDI: 00000000 EBP: ef1edf5c ESP: ef1edf4c\n DS: 007b ES: 007b FS: 00d8 GS: 0033 SS: 0068\nCR0: 80050033 CR2: 00000000 CR3: 23da7000 CR4: 001007f0\nDR0: 00000000 DR1: 00000000 DR2: 00000000 DR3: 00000000\nDR6: ffff0ff0 DR7: 00000400\nProcess bluetooth (pid: 984, ti=ef1ec000 task=e47f2550 task.ti=ef1ec000)\nStack:\n e4c120d0 e49d7600 00000000 08421a40 ef1edf70 fb770b7a 00000002 e8a4cc80\n 08421a40 ef1ec000 c12966b1 00000001 00000000 0000000b 084954c8 c1296b6c\n 0000001b 00000002 0000001b 00000002 00000000 00000002 b2524880 00000046\nCall Trace:\n [<fb770b7a>] ? sco_sock_shutdown+0x56/0x95 [bluetooth]\n [<c12966b1>] ? sys_shutdown+0x37/0x53\n [<c1296b6c>] ? sys_socketcall+0x12e/0x1be\n [<c134ae7e>] ? sysenter_do_call+0x12/0x26\n [<c1340000>] ? ip_vs_control_net_cleanup+0x46/0xb1\nCode: e8 90 6b 8c c5 f6 05 72 5d 78 fb 04 74 17 8b 46 08 50 56 68 0a fd 77 fb 68 60 5d 78 fb e8 68 95 9e c5 83 c4 10 8b 83 fc 01 00 00 <c7> 00 00 00 00 00 eb 32 ba 68 00 00 0b\nEIP: [<fb770ab9>] __sco_sock_close+0x194/0x1ff [bluetooth] SS:ESP 0068:ef1edf4c\nCR2: 0000000000000000\n---[ end trace 47fa2f55a9544e69 ]---\n\nSigned-off-by: Kuba Pawlak <kubax.t.pawlak@intel.com>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>",
        "before_after_code_files": [
          "net/bluetooth/sco.c||net/bluetooth/sco.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/bluetooth/sco.c||net/bluetooth/sco.c": [
          "File: net/bluetooth/sco.c -> net/bluetooth/sco.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "416:   if (sco_pi(sk)->conn->hcon) {",
          "417:    sk->sk_state = BT_DISCONN;",
          "418:    sco_sock_set_timer(sk, SCO_DISCONN_TIMEOUT);",
          "419:    hci_conn_drop(sco_pi(sk)->conn->hcon);",
          "420:    sco_pi(sk)->conn->hcon = NULL;",
          "421:   } else",
          "422:    sco_chan_del(sk, ECONNRESET);",
          "423:   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "419:    sco_conn_lock(sco_pi(sk)->conn);",
          "422:    sco_conn_unlock(sco_pi(sk)->conn);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
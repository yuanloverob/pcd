{
  "cve_id": "CVE-2018-12904",
  "cve_desc": "In arch/x86/kvm/vmx.c in the Linux kernel before 4.17.2, when nested virtualization is used, local attackers could cause L1 KVM guests to VMEXIT, potentially allowing privilege escalations and denial of service attacks due to lack of checking of CPL.",
  "repo": "torvalds/linux",
  "patch_hash": "727ba748e110b4de50d142edca9d6a9b7e6111d8",
  "patch_info": {
    "commit_hash": "727ba748e110b4de50d142edca9d6a9b7e6111d8",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/727ba748e110b4de50d142edca9d6a9b7e6111d8",
    "files": [
      "arch/x86/kvm/vmx.c"
    ],
    "message": "kvm: nVMX: Enforce cpl=0 for VMX instructions\n\nVMX instructions executed inside a L1 VM will always trigger a VM exit\neven when executed with cpl 3. This means we must perform the\nprivilege check in software.\n\nFixes: 70f3aac964ae(\"kvm: nVMX: Remove superfluous VMX instruction fault checks\")\nCc: stable@vger.kernel.org\nSigned-off-by: Felix Wilhelm <fwilhelm@google.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
    "before_after_code_files": [
      "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
    ]
  },
  "patch_diff": {
    "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c": [
      "File: arch/x86/kvm/vmx.c -> arch/x86/kvm/vmx.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "7905:   return 1;",
      "7906:  }",
      "7908:  if (vmx->nested.vmxon) {",
      "7909:   nested_vmx_failValid(vcpu, VMXERR_VMXON_IN_VMX_ROOT_OPERATION);",
      "7910:   return kvm_skip_emulated_instruction(vcpu);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "7909:  if (vmx_get_cpl(vcpu)) {",
      "7910:   kvm_queue_exception(vcpu, UD_VECTOR);",
      "7911:   return 1;",
      "7912:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "7965: static int nested_vmx_check_permission(struct kvm_vcpu *vcpu)",
      "7966: {",
      "7967:  if (!to_vmx(vcpu)->nested.vmxon) {",
      "7968:   kvm_queue_exception(vcpu, UD_VECTOR);",
      "7969:   return 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "7973:  if (vmx_get_cpl(vcpu)) {",
      "7974:   kvm_queue_exception(vcpu, UD_VECTOR);",
      "7975:   return 0;",
      "7976:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "36090bf43a6b835a42f515cb515ff6fa293a25fe",
      "candidate_info": {
        "commit_hash": "36090bf43a6b835a42f515cb515ff6fa293a25fe",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/36090bf43a6b835a42f515cb515ff6fa293a25fe",
        "files": [
          "arch/x86/kvm/vmx.c"
        ],
        "message": "kvm: nVMX: Fix fault vector for VMX operation at CPL > 0\n\nThe fault that should be raised for a privilege level violation is #GP\nrather than #UD.\n\nFixes: 727ba748e110b4 (\"kvm: nVMX: Enforce cpl=0 for VMX instructions\")\nSigned-off-by: Jim Mattson <jmattson@google.com>\nReviewed-by: David Hildenbrand <david@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
          ],
          "candidate": [
            "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c": [
          "File: arch/x86/kvm/vmx.c -> arch/x86/kvm/vmx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8098:  if (vmx_get_cpl(vcpu)) {",
          "8100:   return 1;",
          "8101:  }",
          "",
          "[Removed Lines]",
          "8099:   kvm_queue_exception(vcpu, UD_VECTOR);",
          "",
          "[Added Lines]",
          "8099:   kvm_inject_gp(vcpu, 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "8160: static int nested_vmx_check_permission(struct kvm_vcpu *vcpu)",
          "8161: {",
          "8162:  if (vmx_get_cpl(vcpu)) {",
          "8164:   return 0;",
          "8165:  }",
          "",
          "[Removed Lines]",
          "8163:   kvm_queue_exception(vcpu, UD_VECTOR);",
          "",
          "[Added Lines]",
          "8163:   kvm_inject_gp(vcpu, 0);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e49fcb8b9ef26dfb2d02b173d790e1ef41177121",
      "candidate_info": {
        "commit_hash": "e49fcb8b9ef26dfb2d02b173d790e1ef41177121",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e49fcb8b9ef26dfb2d02b173d790e1ef41177121",
        "files": [
          "arch/x86/kvm/vmx.c"
        ],
        "message": "kvm: nVMX: Fix fault priority for VMX operations\n\nWhen checking emulated VMX instructions for faults, the #UD for \"IF\n(not in VMX operation)\" should take precedence over the #GP for \"ELSIF\nCPL > 0.\"\n\nSuggested-by: Eric Northup <digitaleric@google.com>\nSigned-off-by: Jim Mattson <jmattson@google.com>\nReviewed-by: David Hildenbrand <david@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
          ],
          "candidate": [
            "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c": [
          "File: arch/x86/kvm/vmx.c -> arch/x86/kvm/vmx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8160: static int nested_vmx_check_permission(struct kvm_vcpu *vcpu)",
          "8161: {",
          "8164:   return 0;",
          "8165:  }",
          "8169:   return 0;",
          "8170:  }",
          "8171:  return 1;",
          "8172: }",
          "",
          "[Removed Lines]",
          "8162:  if (vmx_get_cpl(vcpu)) {",
          "8163:   kvm_inject_gp(vcpu, 0);",
          "8167:  if (!to_vmx(vcpu)->nested.vmxon) {",
          "8168:   kvm_queue_exception(vcpu, UD_VECTOR);",
          "",
          "[Added Lines]",
          "8162:  if (!to_vmx(vcpu)->nested.vmxon) {",
          "8163:   kvm_queue_exception(vcpu, UD_VECTOR);",
          "8167:  if (vmx_get_cpl(vcpu)) {",
          "8168:   kvm_inject_gp(vcpu, 0);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
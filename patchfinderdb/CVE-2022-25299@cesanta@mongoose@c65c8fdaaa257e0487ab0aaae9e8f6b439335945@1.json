{
  "cve_id": "CVE-2022-25299",
  "cve_desc": "This affects the package cesanta/mongoose before 7.6. The unsafe handling of file names during upload using mg_http_upload() method may enable attackers to write files to arbitrary locations outside the designated target folder.",
  "repo": "cesanta/mongoose",
  "patch_hash": "c65c8fdaaa257e0487ab0aaae9e8f6b439335945",
  "patch_info": {
    "commit_hash": "c65c8fdaaa257e0487ab0aaae9e8f6b439335945",
    "repo": "cesanta/mongoose",
    "commit_url": "https://github.com/cesanta/mongoose/commit/c65c8fdaaa257e0487ab0aaae9e8f6b439335945",
    "files": [
      "Makefile",
      "mongoose.c",
      "src/http.c",
      "test/unit_test.c"
    ],
    "message": "Protect against the directory traversal in mg_upload()",
    "before_after_code_files": [
      "mongoose.c||mongoose.c",
      "src/http.c||src/http.c",
      "test/unit_test.c||test/unit_test.c"
    ]
  },
  "patch_diff": {
    "mongoose.c||mongoose.c": [
      "File: mongoose.c -> mongoose.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1142:   return buf;",
      "1143: }",
      "1173: static void static_cb(struct mg_connection *c, int ev, void *ev_data,",
      "1174:                       void *fn_data) {",
      "1175:   if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {",
      "",
      "[Removed Lines]",
      "1145: #if MG_ENABLE_FILE",
      "1146: int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
      "1147:                    const char *dir) {",
      "1148:   char offset[40] = \"\", name[200] = \"\", path[256];",
      "1149:   mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));",
      "1150:   mg_http_get_var(&hm->query, \"name\", name, sizeof(name));",
      "1151:   if (name[0] == '\\0') {",
      "1152:     mg_http_reply(c, 400, \"\", \"%s\", \"name required\");",
      "1153:     return -1;",
      "1154:   } else {",
      "1155:     FILE *fp;",
      "1156:     size_t oft = strtoul(offset, NULL, 0);",
      "1157:     snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
      "1158:     LOG(LL_DEBUG,",
      "1159:         (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));",
      "1160:     if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {",
      "1161:       mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);",
      "1162:       return -2;",
      "1163:     } else {",
      "1164:       fwrite(hm->body.ptr, 1, hm->body.len, fp);",
      "1165:       fclose(fp);",
      "1166:       mg_http_reply(c, 200, \"\", \"\");",
      "1167:       return (int) hm->body.len;",
      "1168:     }",
      "1169:   }",
      "1170: }",
      "1171: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1680:   c->recv.len -= ch.len;",
      "1681: }",
      "1683: static void http_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {",
      "1684:   if (ev == MG_EV_READ || ev == MG_EV_CLOSE) {",
      "1685:     struct mg_http_message hm;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1655: #if MG_ENABLE_FILE",
      "1656: int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
      "1657:                    const char *dir) {",
      "1658:   char offset[40] = \"\", name[200] = \"\", path[256];",
      "1659:   mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));",
      "1660:   mg_http_get_var(&hm->query, \"name\", name, sizeof(name));",
      "1661:   if (name[0] == '\\0') {",
      "1662:     mg_http_reply(c, 400, \"\", \"%s\", \"name required\");",
      "1663:     return -1;",
      "1664:   } else {",
      "1665:     FILE *fp;",
      "1666:     long oft = strtol(offset, NULL, 0);",
      "1667:     snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
      "1668:     remove_double_dots(path);",
      "1669:     LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));",
      "1670:     if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {",
      "1671:       mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", path, errno);",
      "1672:       return -2;",
      "1673:     } else {",
      "1674:       fwrite(hm->body.ptr, 1, hm->body.len, fp);",
      "1675:       fclose(fp);",
      "1676:       mg_http_reply(c, 200, \"\", \"\");",
      "1677:       return (int) hm->body.len;",
      "1678:     }",
      "1679:   }",
      "1680: }",
      "1681: #endif",
      "",
      "---------------"
    ],
    "src/http.c||src/http.c": [
      "File: src/http.c -> src/http.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "378:   return buf;",
      "379: }",
      "409: static void static_cb(struct mg_connection *c, int ev, void *ev_data,",
      "410:                       void *fn_data) {",
      "411:   if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {",
      "",
      "[Removed Lines]",
      "381: #if MG_ENABLE_FILE",
      "382: int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
      "383:                    const char *dir) {",
      "384:   char offset[40] = \"\", name[200] = \"\", path[256];",
      "385:   mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));",
      "386:   mg_http_get_var(&hm->query, \"name\", name, sizeof(name));",
      "387:   if (name[0] == '\\0') {",
      "388:     mg_http_reply(c, 400, \"\", \"%s\", \"name required\");",
      "389:     return -1;",
      "390:   } else {",
      "391:     FILE *fp;",
      "392:     size_t oft = strtoul(offset, NULL, 0);",
      "393:     snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
      "394:     LOG(LL_DEBUG,",
      "395:         (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));",
      "396:     if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {",
      "397:       mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);",
      "398:       return -2;",
      "399:     } else {",
      "400:       fwrite(hm->body.ptr, 1, hm->body.len, fp);",
      "401:       fclose(fp);",
      "402:       mg_http_reply(c, 200, \"\", \"\");",
      "403:       return (int) hm->body.len;",
      "404:     }",
      "405:   }",
      "406: }",
      "407: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "916:   c->recv.len -= ch.len;",
      "917: }",
      "919: static void http_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {",
      "920:   if (ev == MG_EV_READ || ev == MG_EV_CLOSE) {",
      "921:     struct mg_http_message hm;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "891: #if MG_ENABLE_FILE",
      "892: int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
      "893:                    const char *dir) {",
      "894:   char offset[40] = \"\", name[200] = \"\", path[256];",
      "895:   mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));",
      "896:   mg_http_get_var(&hm->query, \"name\", name, sizeof(name));",
      "897:   if (name[0] == '\\0') {",
      "898:     mg_http_reply(c, 400, \"\", \"%s\", \"name required\");",
      "899:     return -1;",
      "900:   } else {",
      "901:     FILE *fp;",
      "902:     long oft = strtol(offset, NULL, 0);",
      "903:     snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
      "904:     remove_double_dots(path);",
      "905:     LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));",
      "906:     if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {",
      "907:       mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", path, errno);",
      "908:       return -2;",
      "909:     } else {",
      "910:       fwrite(hm->body.ptr, 1, hm->body.len, fp);",
      "911:       fclose(fp);",
      "912:       mg_http_reply(c, 200, \"\", \"\");",
      "913:       return (int) hm->body.len;",
      "914:     }",
      "915:   }",
      "916: }",
      "917: #endif",
      "",
      "---------------"
    ],
    "test/unit_test.c||test/unit_test.c": [
      "File: test/unit_test.c -> test/unit_test.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "698:     remove(\"uploaded.txt\");",
      "699:   }",
      "702:   ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);",
      "703:   ASSERT(fetch(&mgr, buf, url, \"HEAD /a.txt HTTP/1.0\\n\\n\") == 200);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "700:   {",
      "702:     char *p;",
      "703:     remove(\"uploaded.txt\");",
      "704:     ASSERT((p = mg_file_read(\"uploaded.txt\", NULL)) == NULL);",
      "705:     ASSERT(fetch(&mgr, buf, url,",
      "706:                  \"POST /upload?name=../uploaded.txt HTTP/1.0\\r\\n\"",
      "707:                  \"Content-Length: 5\\r\\n\"",
      "708:                  \"\\r\\nhello\") == 200);",
      "709:     ASSERT((p = mg_file_read(\"uploaded.txt\", NULL)) != NULL);",
      "710:     ASSERT(strcmp(p, \"hello\") == 0);",
      "711:     free(p);",
      "712:     remove(\"uploaded.txt\");",
      "713:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "30d6a44b0d738a5bf3a7402a9b4409505385b227",
      "candidate_info": {
        "commit_hash": "30d6a44b0d738a5bf3a7402a9b4409505385b227",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/30d6a44b0d738a5bf3a7402a9b4409505385b227",
        "files": [
          "docs/README.md",
          "mongoose.c",
          "src/http.c"
        ],
        "message": "Fix mg_http_upload()",
        "before_after_code_files": [
          "mongoose.c||mongoose.c",
          "src/http.c||src/http.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1859:   if (name[0] == '\\0') {",
          "1860:     mg_http_reply(c, 400, \"\", \"%s\", \"name required\");",
          "1861:     res = -1;",
          "1863:     struct mg_fd *fd;",
          "1864:     long oft = strtol(offset, NULL, 0);",
          "1865:     mg_snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
          "",
          "[Removed Lines]",
          "1862:   } else if (hm->body.len > 0) {",
          "",
          "[Added Lines]",
          "1862:   } else if (hm->body.len == 0) {",
          "1863:     mg_http_reply(c, 200, \"\", \"%d\", res);  // Nothing to write",
          "1864:   } else {",
          "",
          "---------------"
        ],
        "src/http.c||src/http.c": [
          "File: src/http.c -> src/http.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "865:   if (name[0] == '\\0') {",
          "866:     mg_http_reply(c, 400, \"\", \"%s\", \"name required\");",
          "867:     res = -1;",
          "869:     struct mg_fd *fd;",
          "870:     long oft = strtol(offset, NULL, 0);",
          "871:     mg_snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
          "",
          "[Removed Lines]",
          "868:   } else if (hm->body.len > 0) {",
          "",
          "[Added Lines]",
          "868:   } else if (hm->body.len == 0) {",
          "869:     mg_http_reply(c, 200, \"\", \"%d\", res);  // Nothing to write",
          "870:   } else {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fd8db5c53ac1568fea50fb7d2f0353dfbad6097f",
      "candidate_info": {
        "commit_hash": "fd8db5c53ac1568fea50fb7d2f0353dfbad6097f",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/fd8db5c53ac1568fea50fb7d2f0353dfbad6097f",
        "files": [
          "mongoose.c",
          "mongoose.h",
          "src/http.c",
          "src/ssi.c",
          "src/util.c",
          "src/util.h"
        ],
        "message": "Better unicode handling on win32",
        "before_after_code_files": [
          "mongoose.c||mongoose.c",
          "mongoose.h||mongoose.h",
          "src/http.c||src/http.c",
          "src/ssi.c||src/ssi.c",
          "src/util.c||src/util.c",
          "src/util.h||src/util.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "691:     snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
          "692:     LOG(LL_DEBUG,",
          "693:         (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));",
          "695:       mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);",
          "696:       return -2;",
          "697:     } else {",
          "",
          "[Removed Lines]",
          "694:     if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {",
          "",
          "[Added Lines]",
          "694:     if ((fp = mg_fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "729:     size_t ext_len;",
          "730:     const char *type;",
          "731:   } * t, types[] = {",
          "735:              MIME_ENTRY(\"css\", \"text/css\"),",
          "736:              MIME_ENTRY(\"js\", \"text/javascript\"),",
          "737:              MIME_ENTRY(\"mjs\", \"text/javascript\"),",
          "",
          "[Removed Lines]",
          "732:              MIME_ENTRY(\"html\", \"text/html\"),",
          "733:              MIME_ENTRY(\"htm\", \"text/html\"),",
          "734:              MIME_ENTRY(\"shtml\", \"text/html\"),",
          "",
          "[Added Lines]",
          "732:              MIME_ENTRY(\"html\", \"text/html; charset=utf-8\"),",
          "733:              MIME_ENTRY(\"htm\", \"text/html; charset=utf-8\"),",
          "734:              MIME_ENTRY(\"shtml\", \"text/html; charset=utf-8\"),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "742:              MIME_ENTRY(\"jpeg\", \"image/jpeg\"),",
          "743:              MIME_ENTRY(\"png\", \"image/png\"),",
          "744:              MIME_ENTRY(\"svg\", \"image/svg+xml\"),",
          "746:              MIME_ENTRY(\"wav\", \"audio/wav\"),",
          "747:              MIME_ENTRY(\"mp3\", \"audio/mpeg\"),",
          "748:              MIME_ENTRY(\"mid\", \"audio/mid\"),",
          "",
          "[Removed Lines]",
          "745:              MIME_ENTRY(\"txt\", \"text/plain\"),",
          "",
          "[Added Lines]",
          "745:              MIME_ENTRY(\"txt\", \"text/plain; charset=utf-8\"),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "779:     if (mg_ncasecmp(t->ext, &filename[n - t->ext_len], t->ext_len)) continue;",
          "780:     return t->type;",
          "781:   }",
          "783: }",
          "785: void mg_http_serve_file(struct mg_connection *c, struct mg_http_message *hm,",
          "786:                         const char *path, const char *mime, const char *hdrs) {",
          "787:   struct mg_str *inm = mg_http_get_header(hm, \"If-None-Match\");",
          "788:   mg_stat_t st;",
          "790:   char etag[64];",
          "791:   if (fp == NULL || mg_stat(path, &st) != 0 ||",
          "792:       mg_http_etag(etag, sizeof(etag), &st) != etag) {",
          "793:     mg_http_reply(c, 404, \"\", \"%s\", \"Not found\\n\");",
          "794:   } else if (inm != NULL && mg_vcasecmp(inm, etag) == 0) {",
          "795:     fclose(fp);",
          "796:     mg_printf(c, \"HTTP/1.1 304 Not Modified\\r\\nContent-Length: 0\\r\\n\\r\\n\");",
          "",
          "[Removed Lines]",
          "782:   return \"text/plain\";",
          "789:   FILE *fp = fopen(path, \"rb\");",
          "",
          "[Added Lines]",
          "782:   return \"text/plain; charset=utf-8\";",
          "790:   FILE *fp = mg_fopen(path, \"rb\");",
          "793:     LOG(LL_DEBUG,",
          "794:         (\"404 [%.*s] [%s] %p\", (int) hm->uri.len, hm->uri.ptr, path, fp));",
          "796:     if (fp != NULL) fclose(fp);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "950: }",
          "951: #endif",
          "956:   int is_dir = S_ISDIR(stp->st_mode);",
          "957:   const char *slash = is_dir ? \"/\" : \"\";",
          "960:   if (is_dir) {",
          "961:     snprintf(size, sizeof(size), \"%s\", \"[DIR]\");",
          "",
          "[Removed Lines]",
          "953: static void printdirentry(struct mg_connection *c, struct mg_http_message *hm,",
          "954:                           const char *name, mg_stat_t *stp) {",
          "955:   char size[64], mod[64];",
          "958:   const char *es = hm->uri.ptr[hm->uri.len - 1] != '/' ? \"/\" : \"\";",
          "",
          "[Added Lines]",
          "956: static bool mg_is_safe(int c) {",
          "957:   return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') ||",
          "958:          (c >= 'A' && c <= 'Z') || strchr(\"._-$,;~()/\", c) != NULL;",
          "959: }",
          "961: static int mg_url_encode(const char *s, char *buf, size_t len) {",
          "962:   int i, n = 0;",
          "963:   for (i = 0; s[i] != '\\0'; i++) {",
          "964:     int c = *((const unsigned char *) (s + i));",
          "965:     if ((size_t) n + 4 >= len) return 0;",
          "966:     if (mg_is_safe(c)) {",
          "967:       buf[n++] = s[i];",
          "968:     } else {",
          "969:       buf[n++] = '%';",
          "970:       mg_hex(&s[i], 1, &buf[n]);",
          "971:       n += 2;",
          "972:     }",
          "973:   }",
          "974:   return n;",
          "975: }",
          "977: static void printdirentry(struct mg_connection *c, const char *name,",
          "978:                           mg_stat_t *stp) {",
          "979:   char size[64], mod[64], path[MG_PATH_MAX];",
          "983:   int n = 0;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "971:     }",
          "972:   }",
          "973:   strftime(mod, sizeof(mod), \"%d-%b-%Y %H:%M\", localtime(&stp->st_mtime));",
          "974:   mg_printf(c,",
          "976:             \"<td>%s</td><td>%s</td></tr>\\n\",",
          "979: }",
          "981: static void listdir(struct mg_connection *c, struct mg_http_message *hm,",
          "",
          "[Removed Lines]",
          "975:             \"  <tr><td><a href=\\\"%.*s%s%s%s\\\">%s%s</a></td>\"",
          "977:             (int) hm->uri.len, hm->uri.ptr, es, name, slash, name, slash, mod,",
          "978:             size);",
          "",
          "[Added Lines]",
          "999:   n = mg_url_encode(name, path, sizeof(path));",
          "1001:             \"  <tr><td><a href=\\\"%.*s%s\\\">%s%s</a></td>\"",
          "1003:             n, path, slash, name, slash, mod, size);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "983:   char path[MG_PATH_MAX], *p = &dir[strlen(dir) - 1], tmp[10];",
          "984:   struct dirent *dp;",
          "985:   DIR *dirp;",
          "987:   while (p > dir && *p != '/') *p-- = '\\0';",
          "988:   if ((dirp = (opendir(dir))) != NULL) {",
          "989:     size_t off, n;",
          "991:     off = c->send.len;  // Start of body",
          "992:     mg_printf(c,",
          "994:               \"<style>th,td {text-align: left; padding-right: 1em; \"",
          "995:               \"font-family: monospace; }</style></head>\"",
          "996:               \"<body><h1>Index of %.*s</h1><table cellpadding=\\\"0\\\"><thead>\"",
          "1000:     while ((dp = readdir(dirp)) != NULL) {",
          "1001:       mg_stat_t st;",
          "1002:       const char *sep = dp->d_name[0] == MG_DIRSEP ? \"/\" : \"\";",
          "",
          "[Removed Lines]",
          "990:     mg_printf(c, \"%s\\r\\n\", \"HTTP/1.1 200 OK\\r\\nContent-Length:         \\r\\n\");",
          "993:               \"<!DOCTYPE html><html><head><title>Index of %.*s</title>\"",
          "997:               \"<tr><th>Name</th><th>Modified</th><th>Size</th></tr>\"",
          "998:               \"<tr><td colspan=\\\"3\\\"><hr></td></tr></thead><tbody>\\n\",",
          "999:               (int) hm->uri.len, hm->uri.ptr, (int) hm->uri.len, hm->uri.ptr);",
          "",
          "[Added Lines]",
          "1011:   static const char *sort_js_code =",
          "1012:       \"<script>function srt(tb, sc, so, d) {\"",
          "1013:       \"var tr = Array.prototype.slice.call(tb.rows, 0),\"",
          "1014:       \"tr = tr.sort(function (a, b) { var c1 = a.cells[sc], c2 = b.cells[sc],\"",
          "1015:       \"n1 = c1.getAttribute('name'), n2 = c2.getAttribute('name'), \"",
          "1016:       \"t1 = a.cells[2].getAttribute('name'), \"",
          "1017:       \"t2 = b.cells[2].getAttribute('name'); \"",
          "1018:       \"return so * (t1 < 0 && t2 >= 0 ? -1 : t2 < 0 && t1 >= 0 ? 1 : \"",
          "1019:       \"n1 ? parseInt(n2) - parseInt(n1) : \"",
          "1020:       \"c1.textContent.trim().localeCompare(c2.textContent.trim())); });\";",
          "1021:   static const char *sort_js_code2 =",
          "1022:       \"for (var i = 0; i < tr.length; i++) tb.appendChild(tr[i]); \"",
          "1023:       \"if (!d) window.location.hash = ('sc=' + sc + '&so=' + so); \"",
          "1024:       \"};\"",
          "1025:       \"window.onload = function() {\"",
          "1026:       \"var tb = document.getElementById('tb');\"",
          "1027:       \"var m = /sc=([012]).so=(1|-1)/.exec(window.location.hash) || [0, 2, 1];\"",
          "1028:       \"var sc = m[1], so = m[2]; document.onclick = function(ev) { \"",
          "1029:       \"var c = ev.target.rel; if (c) {if (c == sc) so *= -1; srt(tb, c, so); \"",
          "1030:       \"sc = c; ev.preventDefault();}};\"",
          "1031:       \"srt(tb, sc, so, true);\"",
          "1032:       \"}\"",
          "1033:       \"</script>\";",
          "1038:     mg_printf(c, \"%s\\r\\n\",",
          "1039:               \"HTTP/1.1 200 OK\\r\\n\"",
          "1040:               \"Content-Type: text/html; charset=utf-8\\r\\n\"",
          "1041:               \"Content-Length:         \\r\\n\");",
          "1044:               \"<!DOCTYPE html><html><head><title>Index of %.*s</title>%s%s\"",
          "1048:               \"<tr><th><a href=\\\"#\\\" rel=\\\"0\\\">Name</a></th><th>\"",
          "1049:               \"<a href=\\\"#\\\" rel=\\\"1\\\">Modified</a></th>\"",
          "1050:               \"<th><a href=\\\"#\\\" rel=\\\"2\\\">Size</a></th></tr>\"",
          "1051:               \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\"",
          "1052:               \"</thead>\"",
          "1053:               \"<tbody id=\\\"tb\\\">\\n\",",
          "1054:               (int) hm->uri.len, hm->uri.ptr, sort_js_code, sort_js_code2,",
          "1055:               (int) hm->uri.len, hm->uri.ptr);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1008:       } else if (mg_stat(path, &st) != 0) {",
          "1009:         LOG(LL_ERROR, (\"%lu stat(%s): %d\", c->id, path, errno));",
          "1010:       } else {",
          "1012:       }",
          "1013:     }",
          "1014:     closedir(dirp);",
          "",
          "[Removed Lines]",
          "1011:         printdirentry(c, hm, dp->d_name, &st);",
          "",
          "[Added Lines]",
          "1068:         printdirentry(c, dp->d_name, &st);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1042:     size_t n1 = strlen(t1), n2;",
          "1044:     mg_url_decode(hm->uri.ptr, hm->uri.len, t1 + n1, sizeof(t1) - n1, 0);",
          "1045:     t1[sizeof(t1) - 1] = '\\0';",
          "1046:     n2 = strlen(t1);",
          "1047:     while (n2 > 0 && t1[n2 - 1] == '/') t1[--n2] = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1102:     LOG(LL_DEBUG, (\"SERVE: [%s]\", t1 + n1));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1058:     if (strlen(t2) < n1 || memcmp(t1, t2, n1) != 0) {",
          "1061:     } else {",
          "1063: #if MG_ENABLE_SSI",
          "1064:       if (is_index && fp == NULL) {",
          "1065:         char *p = t2 + strlen(t2);",
          "1066:         while (p > t2 && p[-1] != '/') p--;",
          "1067:         strncpy(p, \"index.shtml\", &t2[sizeof(t2)] - p - 2);",
          "1068:         t2[sizeof(t2) - 1] = '\\0';",
          "1070:       }",
          "1071: #endif",
          "1072: #if MG_ENABLE_HTTP_DEBUG_ENDPOINT",
          "",
          "[Removed Lines]",
          "1060:       mg_http_reply(c, 404, \"\", \"Not found %.*s\\n\", hm->uri.len, hm->uri.ptr);",
          "1062:       FILE *fp = fopen(t2, \"r\");",
          "1069:         fp = fopen(t2, \"r\");",
          "",
          "[Added Lines]",
          "1118:       mg_http_reply(c, 404, \"\", \"Not found %.*s\\n\", (int) hm->uri.len,",
          "1119:                     hm->uri.ptr);",
          "1121:       FILE *fp = mg_fopen(t2, \"r\");",
          "1128:         fp = mg_fopen(t2, \"r\");",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "3061: #if MG_ENABLE_SSI",
          "3062: static char *mg_ssi(const char *path, const char *root, int depth) {",
          "3063:   struct mg_iobuf b = {NULL, 0, 0};",
          "3065:   if (fp != NULL) {",
          "3066:     char buf[BUFSIZ], arg[sizeof(buf)];",
          "3067:     int ch, intag = 0;",
          "",
          "[Removed Lines]",
          "3064:   FILE *fp = fopen(path, \"rb\");",
          "",
          "[Added Lines]",
          "3124:   FILE *fp = mg_fopen(path, \"rb\");",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "3737: #if MG_ENABLE_FS",
          "3739: #if MG_ARCH == MG_ARCH_FREERTOS",
          "3740:   struct FF_STAT st;",
          "3741:   return ff_stat(path, &st) == 0 ? st.st_size : 0;",
          "3742: #else",
          "3745: #endif",
          "3746: }",
          "3748: char *mg_file_read(const char *path) {",
          "3749:   FILE *fp;",
          "3750:   char *data = NULL;",
          "3753:     data = (char *) malloc(size + 1);",
          "3754:     if (data != NULL) {",
          "3755:       if (fread(data, 1, size, fp) != size) {",
          "",
          "[Removed Lines]",
          "3738: size_t mg_file_size(const char *path) {",
          "3743:   struct stat st;",
          "3744:   return stat(path, &st) == 0 ? st.st_size : 0;",
          "3751:   size_t size = mg_file_size(path);",
          "3752:   if ((fp = fopen(path, \"rb\")) != NULL) {",
          "",
          "[Added Lines]",
          "3798: int mg_stat(const char *path, mg_stat_t *st) {",
          "3799: #ifdef _WIN32",
          "3800:   wchar_t tmp[MG_PATH_MAX];",
          "3801:   MultiByteToWideChar(CP_UTF8, 0, path, -1, tmp, sizeof(tmp) / sizeof(tmp[0]));",
          "3802:   return _wstati64(tmp, st);",
          "3803: #else",
          "3804:   return stat(path, st);",
          "3805: #endif",
          "3806: }",
          "3808: FILE *mg_fopen(const char *path, const char *mode) {",
          "3809: #ifdef _WIN32",
          "3810:   wchar_t b1[MG_PATH_MAX], b2[10];",
          "3811:   MultiByteToWideChar(CP_UTF8, 0, path, -1, b1, sizeof(b1) / sizeof(b1[0]));",
          "3812:   MultiByteToWideChar(CP_UTF8, 0, mode, -1, b2, sizeof(b2) / sizeof(b2[0]));",
          "3813:   return _wfopen(b1, b2);",
          "3814: #else",
          "3815:   return fopen(path, mode);",
          "3816: #endif",
          "3817: }",
          "3819: int64_t mg_file_size(const char *path) {",
          "3824:   mg_stat_t st;",
          "3825:   return mg_stat(path, &st) == 0 ? st.st_size : 0;",
          "3832:   size_t size = (size_t) mg_file_size(path);",
          "3833:   if ((fp = mg_fopen(path, \"rb\")) != NULL) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "3769:   FILE *fp;",
          "3770:   char tmp[MG_PATH_MAX];",
          "3771:   snprintf(tmp, sizeof(tmp), \"%s.%d\", path, rand());",
          "3773:   if (fp != NULL) {",
          "3774:     result = fwrite(buf, 1, len, fp) == len;",
          "3775:     fclose(fp);",
          "",
          "[Removed Lines]",
          "3772:   fp = fopen(tmp, \"wb\");",
          "",
          "[Added Lines]",
          "3853:   fp = mg_fopen(tmp, \"wb\");",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "3797: }",
          "3799: void mg_random(void *buf, size_t len) {",
          "3801:   size_t i, n = 0;",
          "3802:   if (fp != NULL) n = fread(buf, 1, len, fp);",
          "3803:   if (fp == NULL || n <= 0) {",
          "",
          "[Removed Lines]",
          "3800:   FILE *fp = fopen(\"/dev/urandom\", \"rb\");",
          "",
          "[Added Lines]",
          "3881:   FILE *fp = mg_fopen(\"/dev/urandom\", \"rb\");",
          "",
          "---------------"
        ],
        "mongoose.h||mongoose.h": [
          "File: mongoose.h -> mongoose.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "430: char *mg_file_read(const char *path);",
          "432: bool mg_file_write(const char *path, const void *buf, size_t len);",
          "433: bool mg_file_printf(const char *path, const char *fmt, ...);",
          "434: void mg_random(void *buf, size_t len);",
          "",
          "[Removed Lines]",
          "431: size_t mg_file_size(const char *path);",
          "",
          "[Added Lines]",
          "431: int64_t mg_file_size(const char *path);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "450: #if MG_ENABLE_FS",
          "451: #ifdef _WIN32",
          "452: typedef struct _stati64 mg_stat_t;",
          "454: #else",
          "455: typedef struct stat mg_stat_t;",
          "457: #endif",
          "458: #endif",
          "460: #define mg_htons(x) mg_ntohs(x)",
          "",
          "[Removed Lines]",
          "453: #define mg_stat(a, b) _stati64((a), (b))",
          "456: #define mg_stat(a, b) stat((a), (b))",
          "",
          "[Added Lines]",
          "456: int mg_stat(const char *path, mg_stat_t *);",
          "457: FILE *mg_fopen(const char *fp, const char *mode);",
          "",
          "---------------"
        ],
        "src/http.c||src/http.c": [
          "File: src/http.c -> src/http.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "271:     snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
          "272:     LOG(LL_DEBUG,",
          "273:         (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));",
          "275:       mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);",
          "276:       return -2;",
          "277:     } else {",
          "",
          "[Removed Lines]",
          "274:     if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {",
          "",
          "[Added Lines]",
          "274:     if ((fp = mg_fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "309:     size_t ext_len;",
          "310:     const char *type;",
          "311:   } * t, types[] = {",
          "315:              MIME_ENTRY(\"css\", \"text/css\"),",
          "316:              MIME_ENTRY(\"js\", \"text/javascript\"),",
          "317:              MIME_ENTRY(\"mjs\", \"text/javascript\"),",
          "",
          "[Removed Lines]",
          "312:              MIME_ENTRY(\"html\", \"text/html\"),",
          "313:              MIME_ENTRY(\"htm\", \"text/html\"),",
          "314:              MIME_ENTRY(\"shtml\", \"text/html\"),",
          "",
          "[Added Lines]",
          "312:              MIME_ENTRY(\"html\", \"text/html; charset=utf-8\"),",
          "313:              MIME_ENTRY(\"htm\", \"text/html; charset=utf-8\"),",
          "314:              MIME_ENTRY(\"shtml\", \"text/html; charset=utf-8\"),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "322:              MIME_ENTRY(\"jpeg\", \"image/jpeg\"),",
          "323:              MIME_ENTRY(\"png\", \"image/png\"),",
          "324:              MIME_ENTRY(\"svg\", \"image/svg+xml\"),",
          "326:              MIME_ENTRY(\"wav\", \"audio/wav\"),",
          "327:              MIME_ENTRY(\"mp3\", \"audio/mpeg\"),",
          "328:              MIME_ENTRY(\"mid\", \"audio/mid\"),",
          "",
          "[Removed Lines]",
          "325:              MIME_ENTRY(\"txt\", \"text/plain\"),",
          "",
          "[Added Lines]",
          "325:              MIME_ENTRY(\"txt\", \"text/plain; charset=utf-8\"),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "359:     if (mg_ncasecmp(t->ext, &filename[n - t->ext_len], t->ext_len)) continue;",
          "360:     return t->type;",
          "361:   }",
          "363: }",
          "365: void mg_http_serve_file(struct mg_connection *c, struct mg_http_message *hm,",
          "366:                         const char *path, const char *mime, const char *hdrs) {",
          "367:   struct mg_str *inm = mg_http_get_header(hm, \"If-None-Match\");",
          "368:   mg_stat_t st;",
          "370:   char etag[64];",
          "371:   if (fp == NULL || mg_stat(path, &st) != 0 ||",
          "372:       mg_http_etag(etag, sizeof(etag), &st) != etag) {",
          "373:     mg_http_reply(c, 404, \"\", \"%s\", \"Not found\\n\");",
          "374:   } else if (inm != NULL && mg_vcasecmp(inm, etag) == 0) {",
          "375:     fclose(fp);",
          "376:     mg_printf(c, \"HTTP/1.1 304 Not Modified\\r\\nContent-Length: 0\\r\\n\\r\\n\");",
          "",
          "[Removed Lines]",
          "362:   return \"text/plain\";",
          "369:   FILE *fp = fopen(path, \"rb\");",
          "",
          "[Added Lines]",
          "362:   return \"text/plain; charset=utf-8\";",
          "370:   FILE *fp = mg_fopen(path, \"rb\");",
          "373:     LOG(LL_DEBUG,",
          "374:         (\"404 [%.*s] [%s] %p\", (int) hm->uri.len, hm->uri.ptr, path, fp));",
          "376:     if (fp != NULL) fclose(fp);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "530: }",
          "531: #endif",
          "536:   int is_dir = S_ISDIR(stp->st_mode);",
          "537:   const char *slash = is_dir ? \"/\" : \"\";",
          "540:   if (is_dir) {",
          "541:     snprintf(size, sizeof(size), \"%s\", \"[DIR]\");",
          "",
          "[Removed Lines]",
          "533: static void printdirentry(struct mg_connection *c, struct mg_http_message *hm,",
          "534:                           const char *name, mg_stat_t *stp) {",
          "535:   char size[64], mod[64];",
          "538:   const char *es = hm->uri.ptr[hm->uri.len - 1] != '/' ? \"/\" : \"\";",
          "",
          "[Added Lines]",
          "536: static bool mg_is_safe(int c) {",
          "537:   return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') ||",
          "538:          (c >= 'A' && c <= 'Z') || strchr(\"._-$,;~()/\", c) != NULL;",
          "539: }",
          "541: static int mg_url_encode(const char *s, char *buf, size_t len) {",
          "542:   int i, n = 0;",
          "543:   for (i = 0; s[i] != '\\0'; i++) {",
          "544:     int c = *((const unsigned char *) (s + i));",
          "545:     if ((size_t) n + 4 >= len) return 0;",
          "546:     if (mg_is_safe(c)) {",
          "547:       buf[n++] = s[i];",
          "548:     } else {",
          "549:       buf[n++] = '%';",
          "550:       mg_hex(&s[i], 1, &buf[n]);",
          "551:       n += 2;",
          "552:     }",
          "553:   }",
          "554:   return n;",
          "555: }",
          "557: static void printdirentry(struct mg_connection *c, const char *name,",
          "558:                           mg_stat_t *stp) {",
          "559:   char size[64], mod[64], path[MG_PATH_MAX];",
          "563:   int n = 0;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "551:     }",
          "552:   }",
          "553:   strftime(mod, sizeof(mod), \"%d-%b-%Y %H:%M\", localtime(&stp->st_mtime));",
          "554:   mg_printf(c,",
          "556:             \"<td>%s</td><td>%s</td></tr>\\n\",",
          "559: }",
          "561: static void listdir(struct mg_connection *c, struct mg_http_message *hm,",
          "",
          "[Removed Lines]",
          "555:             \"  <tr><td><a href=\\\"%.*s%s%s%s\\\">%s%s</a></td>\"",
          "557:             (int) hm->uri.len, hm->uri.ptr, es, name, slash, name, slash, mod,",
          "558:             size);",
          "",
          "[Added Lines]",
          "579:   n = mg_url_encode(name, path, sizeof(path));",
          "581:             \"  <tr><td><a href=\\\"%.*s%s\\\">%s%s</a></td>\"",
          "583:             n, path, slash, name, slash, mod, size);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "563:   char path[MG_PATH_MAX], *p = &dir[strlen(dir) - 1], tmp[10];",
          "564:   struct dirent *dp;",
          "565:   DIR *dirp;",
          "567:   while (p > dir && *p != '/') *p-- = '\\0';",
          "568:   if ((dirp = (opendir(dir))) != NULL) {",
          "569:     size_t off, n;",
          "571:     off = c->send.len;  // Start of body",
          "572:     mg_printf(c,",
          "574:               \"<style>th,td {text-align: left; padding-right: 1em; \"",
          "575:               \"font-family: monospace; }</style></head>\"",
          "576:               \"<body><h1>Index of %.*s</h1><table cellpadding=\\\"0\\\"><thead>\"",
          "580:     while ((dp = readdir(dirp)) != NULL) {",
          "581:       mg_stat_t st;",
          "582:       const char *sep = dp->d_name[0] == MG_DIRSEP ? \"/\" : \"\";",
          "",
          "[Removed Lines]",
          "570:     mg_printf(c, \"%s\\r\\n\", \"HTTP/1.1 200 OK\\r\\nContent-Length:         \\r\\n\");",
          "573:               \"<!DOCTYPE html><html><head><title>Index of %.*s</title>\"",
          "577:               \"<tr><th>Name</th><th>Modified</th><th>Size</th></tr>\"",
          "578:               \"<tr><td colspan=\\\"3\\\"><hr></td></tr></thead><tbody>\\n\",",
          "579:               (int) hm->uri.len, hm->uri.ptr, (int) hm->uri.len, hm->uri.ptr);",
          "",
          "[Added Lines]",
          "591:   static const char *sort_js_code =",
          "592:       \"<script>function srt(tb, sc, so, d) {\"",
          "593:       \"var tr = Array.prototype.slice.call(tb.rows, 0),\"",
          "594:       \"tr = tr.sort(function (a, b) { var c1 = a.cells[sc], c2 = b.cells[sc],\"",
          "595:       \"n1 = c1.getAttribute('name'), n2 = c2.getAttribute('name'), \"",
          "596:       \"t1 = a.cells[2].getAttribute('name'), \"",
          "597:       \"t2 = b.cells[2].getAttribute('name'); \"",
          "598:       \"return so * (t1 < 0 && t2 >= 0 ? -1 : t2 < 0 && t1 >= 0 ? 1 : \"",
          "599:       \"n1 ? parseInt(n2) - parseInt(n1) : \"",
          "600:       \"c1.textContent.trim().localeCompare(c2.textContent.trim())); });\";",
          "601:   static const char *sort_js_code2 =",
          "602:       \"for (var i = 0; i < tr.length; i++) tb.appendChild(tr[i]); \"",
          "603:       \"if (!d) window.location.hash = ('sc=' + sc + '&so=' + so); \"",
          "604:       \"};\"",
          "605:       \"window.onload = function() {\"",
          "606:       \"var tb = document.getElementById('tb');\"",
          "607:       \"var m = /sc=([012]).so=(1|-1)/.exec(window.location.hash) || [0, 2, 1];\"",
          "608:       \"var sc = m[1], so = m[2]; document.onclick = function(ev) { \"",
          "609:       \"var c = ev.target.rel; if (c) {if (c == sc) so *= -1; srt(tb, c, so); \"",
          "610:       \"sc = c; ev.preventDefault();}};\"",
          "611:       \"srt(tb, sc, so, true);\"",
          "612:       \"}\"",
          "613:       \"</script>\";",
          "618:     mg_printf(c, \"%s\\r\\n\",",
          "619:               \"HTTP/1.1 200 OK\\r\\n\"",
          "620:               \"Content-Type: text/html; charset=utf-8\\r\\n\"",
          "621:               \"Content-Length:         \\r\\n\");",
          "624:               \"<!DOCTYPE html><html><head><title>Index of %.*s</title>%s%s\"",
          "628:               \"<tr><th><a href=\\\"#\\\" rel=\\\"0\\\">Name</a></th><th>\"",
          "629:               \"<a href=\\\"#\\\" rel=\\\"1\\\">Modified</a></th>\"",
          "630:               \"<th><a href=\\\"#\\\" rel=\\\"2\\\">Size</a></th></tr>\"",
          "631:               \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\"",
          "632:               \"</thead>\"",
          "633:               \"<tbody id=\\\"tb\\\">\\n\",",
          "634:               (int) hm->uri.len, hm->uri.ptr, sort_js_code, sort_js_code2,",
          "635:               (int) hm->uri.len, hm->uri.ptr);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "588:       } else if (mg_stat(path, &st) != 0) {",
          "589:         LOG(LL_ERROR, (\"%lu stat(%s): %d\", c->id, path, errno));",
          "590:       } else {",
          "592:       }",
          "593:     }",
          "594:     closedir(dirp);",
          "",
          "[Removed Lines]",
          "591:         printdirentry(c, hm, dp->d_name, &st);",
          "",
          "[Added Lines]",
          "648:         printdirentry(c, dp->d_name, &st);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "622:     size_t n1 = strlen(t1), n2;",
          "624:     mg_url_decode(hm->uri.ptr, hm->uri.len, t1 + n1, sizeof(t1) - n1, 0);",
          "625:     t1[sizeof(t1) - 1] = '\\0';",
          "626:     n2 = strlen(t1);",
          "627:     while (n2 > 0 && t1[n2 - 1] == '/') t1[--n2] = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "682:     LOG(LL_DEBUG, (\"SERVE: [%s]\", t1 + n1));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "638:     if (strlen(t2) < n1 || memcmp(t1, t2, n1) != 0) {",
          "641:     } else {",
          "643: #if MG_ENABLE_SSI",
          "644:       if (is_index && fp == NULL) {",
          "645:         char *p = t2 + strlen(t2);",
          "646:         while (p > t2 && p[-1] != '/') p--;",
          "647:         strncpy(p, \"index.shtml\", &t2[sizeof(t2)] - p - 2);",
          "648:         t2[sizeof(t2) - 1] = '\\0';",
          "650:       }",
          "651: #endif",
          "652: #if MG_ENABLE_HTTP_DEBUG_ENDPOINT",
          "",
          "[Removed Lines]",
          "640:       mg_http_reply(c, 404, \"\", \"Not found %.*s\\n\", hm->uri.len, hm->uri.ptr);",
          "642:       FILE *fp = fopen(t2, \"r\");",
          "649:         fp = fopen(t2, \"r\");",
          "",
          "[Added Lines]",
          "698:       mg_http_reply(c, 404, \"\", \"Not found %.*s\\n\", (int) hm->uri.len,",
          "699:                     hm->uri.ptr);",
          "701:       FILE *fp = mg_fopen(t2, \"r\");",
          "708:         fp = mg_fopen(t2, \"r\");",
          "",
          "---------------"
        ],
        "src/ssi.c||src/ssi.c": [
          "File: src/ssi.c -> src/ssi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: #include \"ssi.h\"",
          "4: #ifndef MG_MAX_SSI_DEPTH",
          "5: #define MG_MAX_SSI_DEPTH 5",
          "",
          "[Removed Lines]",
          "1: #include \"log.h\"",
          "",
          "[Added Lines]",
          "2: #include \"log.h\"",
          "3: #include \"util.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "8: #if MG_ENABLE_SSI",
          "9: static char *mg_ssi(const char *path, const char *root, int depth) {",
          "10:   struct mg_iobuf b = {NULL, 0, 0};",
          "12:   if (fp != NULL) {",
          "13:     char buf[BUFSIZ], arg[sizeof(buf)];",
          "14:     int ch, intag = 0;",
          "",
          "[Removed Lines]",
          "11:   FILE *fp = fopen(path, \"rb\");",
          "",
          "[Added Lines]",
          "12:   FILE *fp = mg_fopen(path, \"rb\");",
          "",
          "---------------"
        ],
        "src/util.c||src/util.c": [
          "File: src/util.c -> src/util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: #include \"util.h\"",
          "4: #if MG_ENABLE_FS",
          "6: #if MG_ARCH == MG_ARCH_FREERTOS",
          "7:   struct FF_STAT st;",
          "8:   return ff_stat(path, &st) == 0 ? st.st_size : 0;",
          "9: #else",
          "12: #endif",
          "13: }",
          "15: char *mg_file_read(const char *path) {",
          "16:   FILE *fp;",
          "17:   char *data = NULL;",
          "20:     data = (char *) malloc(size + 1);",
          "21:     if (data != NULL) {",
          "22:       if (fread(data, 1, size, fp) != size) {",
          "",
          "[Removed Lines]",
          "5: size_t mg_file_size(const char *path) {",
          "10:   struct stat st;",
          "11:   return stat(path, &st) == 0 ? st.st_size : 0;",
          "18:   size_t size = mg_file_size(path);",
          "19:   if ((fp = fopen(path, \"rb\")) != NULL) {",
          "",
          "[Added Lines]",
          "5: int mg_stat(const char *path, mg_stat_t *st) {",
          "6: #ifdef _WIN32",
          "7:   wchar_t tmp[MG_PATH_MAX];",
          "8:   MultiByteToWideChar(CP_UTF8, 0, path, -1, tmp, sizeof(tmp) / sizeof(tmp[0]));",
          "9:   return _wstati64(tmp, st);",
          "10: #else",
          "11:   return stat(path, st);",
          "12: #endif",
          "13: }",
          "15: FILE *mg_fopen(const char *path, const char *mode) {",
          "16: #ifdef _WIN32",
          "17:   wchar_t b1[MG_PATH_MAX], b2[10];",
          "18:   MultiByteToWideChar(CP_UTF8, 0, path, -1, b1, sizeof(b1) / sizeof(b1[0]));",
          "19:   MultiByteToWideChar(CP_UTF8, 0, mode, -1, b2, sizeof(b2) / sizeof(b2[0]));",
          "20:   return _wfopen(b1, b2);",
          "21: #else",
          "22:   return fopen(path, mode);",
          "23: #endif",
          "24: }",
          "26: int64_t mg_file_size(const char *path) {",
          "31:   mg_stat_t st;",
          "32:   return mg_stat(path, &st) == 0 ? st.st_size : 0;",
          "39:   size_t size = (size_t) mg_file_size(path);",
          "40:   if ((fp = mg_fopen(path, \"rb\")) != NULL) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "36:   FILE *fp;",
          "37:   char tmp[MG_PATH_MAX];",
          "38:   snprintf(tmp, sizeof(tmp), \"%s.%d\", path, rand());",
          "40:   if (fp != NULL) {",
          "41:     result = fwrite(buf, 1, len, fp) == len;",
          "42:     fclose(fp);",
          "",
          "[Removed Lines]",
          "39:   fp = fopen(tmp, \"wb\");",
          "",
          "[Added Lines]",
          "60:   fp = mg_fopen(tmp, \"wb\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "64: }",
          "66: void mg_random(void *buf, size_t len) {",
          "68:   size_t i, n = 0;",
          "69:   if (fp != NULL) n = fread(buf, 1, len, fp);",
          "70:   if (fp == NULL || n <= 0) {",
          "",
          "[Removed Lines]",
          "67:   FILE *fp = fopen(\"/dev/urandom\", \"rb\");",
          "",
          "[Added Lines]",
          "88:   FILE *fp = mg_fopen(\"/dev/urandom\", \"rb\");",
          "",
          "---------------"
        ],
        "src/util.h||src/util.h": [
          "File: src/util.h -> src/util.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: #include \"str.h\"",
          "6: char *mg_file_read(const char *path);",
          "8: bool mg_file_write(const char *path, const void *buf, size_t len);",
          "9: bool mg_file_printf(const char *path, const char *fmt, ...);",
          "10: void mg_random(void *buf, size_t len);",
          "",
          "[Removed Lines]",
          "7: size_t mg_file_size(const char *path);",
          "",
          "[Added Lines]",
          "7: int64_t mg_file_size(const char *path);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "26: #if MG_ENABLE_FS",
          "27: #ifdef _WIN32",
          "28: typedef struct _stati64 mg_stat_t;",
          "30: #else",
          "31: typedef struct stat mg_stat_t;",
          "33: #endif",
          "34: #endif",
          "36: #define mg_htons(x) mg_ntohs(x)",
          "",
          "[Removed Lines]",
          "29: #define mg_stat(a, b) _stati64((a), (b))",
          "32: #define mg_stat(a, b) stat((a), (b))",
          "",
          "[Added Lines]",
          "32: int mg_stat(const char *path, mg_stat_t *);",
          "33: FILE *mg_fopen(const char *fp, const char *mode);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "99f0688377814b76847ff4fc621bb0aa28863075",
      "candidate_info": {
        "commit_hash": "99f0688377814b76847ff4fc621bb0aa28863075",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/99f0688377814b76847ff4fc621bb0aa28863075",
        "files": [
          "docs/README.md",
          "examples/file-upload-multiple-posts/main.c",
          "examples/file-upload-multiple-posts/web_root/app.js",
          "examples/file-upload-multiple-posts/web_root/index.html",
          "mongoose.c",
          "mongoose.h",
          "src/http.c",
          "src/http.h",
          "src/str.c",
          "test/unit_test.c"
        ],
        "message": "Change mg_http_upload API",
        "before_after_code_files": [
          "examples/file-upload-multiple-posts/main.c||examples/file-upload-multiple-posts/main.c",
          "examples/file-upload-multiple-posts/web_root/app.js||examples/file-upload-multiple-posts/web_root/app.js",
          "examples/file-upload-multiple-posts/web_root/index.html||examples/file-upload-multiple-posts/web_root/index.html",
          "mongoose.c||mongoose.c",
          "mongoose.h||mongoose.h",
          "src/http.c||src/http.c",
          "src/http.h||src/http.h",
          "src/str.c||src/str.c",
          "test/unit_test.c||test/unit_test.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c",
            "test/unit_test.c||test/unit_test.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c",
            "test/unit_test.c||test/unit_test.c"
          ]
        }
      },
      "candidate_diff": {
        "examples/file-upload-multiple-posts/main.c||examples/file-upload-multiple-posts/main.c": [
          "File: examples/file-upload-multiple-posts/main.c -> examples/file-upload-multiple-posts/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "10:   if (ev == MG_EV_HTTP_MSG) {",
          "11:     struct mg_http_message *hm = (struct mg_http_message *) ev_data;",
          "12:     if (mg_http_match_uri(hm, \"/upload\")) {",
          "14:     } else {",
          "15:       struct mg_http_serve_opts opts = {.root_dir = \"web_root\"};",
          "16:       mg_http_serve_dir(c, ev_data, &opts);",
          "",
          "[Removed Lines]",
          "13:       mg_http_upload(c, hm, &mg_fs_posix, \"/tmp\");",
          "",
          "[Added Lines]",
          "13:       char path[80], name[64];",
          "14:       mg_http_get_var(&hm->query, \"name\", name, sizeof(name));",
          "15:       if (name[0] == '\\0') {",
          "16:         mg_http_reply(c, 400, \"\", \"%s\", \"name required\");",
          "17:       } else {",
          "18:         mg_snprintf(path, sizeof(path), \"/tmp/%s\", name);",
          "19:         mg_http_upload(c, hm, &mg_fs_posix, mg_remove_double_dots(path), 99999);",
          "20:       }",
          "",
          "---------------"
        ],
        "examples/file-upload-multiple-posts/web_root/app.js||examples/file-upload-multiple-posts/web_root/app.js": [
          "File: examples/file-upload-multiple-posts/web_root/app.js -> examples/file-upload-multiple-posts/web_root/app.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "18:     var chunk = data.subarray(offset, offset + chunkSize) || '';",
          "19:     var opts = {method: 'POST', body: chunk};",
          "20:     var url = '/upload?offset=' + offset + '&name=' + encodeURIComponent(name);",
          "21:     setStatus(",
          "27:   };",
          "28:   sendChunk(0);",
          "29: };",
          "",
          "[Removed Lines]",
          "22:         'sending bytes ' + offset + '..' + (offset + chunk.length) + ' of ' +",
          "23:         data.length);",
          "24:     fetch(url, opts).then(function(res) {",
          "25:       if (chunk.length > 0) sendChunk(offset + chunk.length);",
          "26:     });",
          "",
          "[Added Lines]",
          "21:     var ok;",
          "23:         'Upoading ' + name + ', bytes ' + offset + '..' +",
          "24:         (offset + chunk.length) + ' of ' + data.length);",
          "25:     fetch(url, opts)",
          "26:         .then(function(res) {",
          "27:           if (res.ok && chunk.length > 0) sendChunk(offset + chunk.length);",
          "28:           ok = res.ok;",
          "29:           return res.text();",
          "30:         })",
          "31:         .then(function(text) {",
          "32:           if (!ok) setStatus('Error: ' + text);",
          "33:         });",
          "",
          "---------------"
        ],
        "examples/file-upload-multiple-posts/web_root/index.html||examples/file-upload-multiple-posts/web_root/index.html": [
          "File: examples/file-upload-multiple-posts/web_root/index.html -> examples/file-upload-multiple-posts/web_root/index.html",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:         in small chunks.",
          "22:         <br/><br/>",
          "23:         In this example, the JavaScript code on this page sends the chosen",
          "25:         The uploaded file is stored in the <code>/tmp</code> directory by",
          "26:         the helper API function <code>mg_http_upload()</code>",
          "27:       </div>",
          "",
          "[Removed Lines]",
          "24:         file in 4K chunks using the <code>/upload</code> endpoint.",
          "",
          "[Added Lines]",
          "24:         file in 2Kb chunks using the <code>/upload</code> endpoint.",
          "",
          "---------------"
        ],
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2253:   if (c->pfn_data != NULL) c->pfn_data = (char *) c->pfn_data - ch.len;",
          "2254: }",
          "2267:   } else {",
          "2268:     struct mg_fd *fd;",
          "2276:       res = -2;",
          "2277:     } else {",
          "2279:       mg_fs_close(fd);",
          "2281:     }",
          "2282:   }",
          "2283:   return res;",
          "",
          "[Removed Lines]",
          "2256: int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
          "2257:                    struct mg_fs *fs, const char *dir) {",
          "2258:   char offset[40] = \"\", name[200] = \"\", path[256];",
          "2259:   int res = 0;",
          "2260:   mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));",
          "2261:   mg_http_get_var(&hm->query, \"name\", name, sizeof(name));",
          "2262:   if (name[0] == '\\0') {",
          "2263:     mg_http_reply(c, 400, \"\", \"%s\", \"name required\");",
          "2264:     res = -1;",
          "2265:   } else if (hm->body.len == 0) {",
          "2266:     mg_http_reply(c, 200, \"\", \"%d\", res);  // Nothing to write",
          "2269:     long oft = strtol(offset, NULL, 0);",
          "2270:     mg_snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
          "2271:     mg_remove_double_dots(path);",
          "2272:     MG_DEBUG((\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));",
          "2273:     if (oft == 0) fs->rm(path);",
          "2274:     if ((fd = mg_fs_open(fs, path, MG_FS_WRITE)) == NULL) {",
          "2275:       mg_http_reply(c, 400, \"\", \"open(%s): %d\", path, errno);",
          "2278:       res = (int) fs->wr(fd->fd, hm->body.ptr, hm->body.len);",
          "2280:       mg_http_reply(c, 200, \"\", \"%d\", res);",
          "",
          "[Added Lines]",
          "2256: long mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
          "2257:                     struct mg_fs *fs, const char *path, size_t max_size) {",
          "2258:   char buf[20] = \"\";",
          "2259:   long res = 0, offset;",
          "2260:   mg_http_get_var(&hm->query, \"offset\", buf, sizeof(buf));",
          "2261:   offset = strtol(buf, NULL, 0);",
          "2262:   if (hm->body.len == 0) {",
          "2263:     mg_http_reply(c, 200, \"\", \"%ld\", res);  // Nothing to write",
          "2266:     size_t current_size = 0;",
          "2267:     MG_DEBUG((\"%s -> %d bytes @ %ld\", path, (int) hm->body.len, offset));",
          "2268:     if (offset == 0) fs->rm(path);  // If offset if 0, truncate file",
          "2269:     fs->st(path, &current_size, NULL);",
          "2270:     if (offset < 0) {",
          "2271:       mg_http_reply(c, 400, \"\", \"offset required\");",
          "2272:       res = -1;",
          "2273:     } else if (offset > 0 && current_size != (size_t) offset) {",
          "2274:       mg_http_reply(c, 400, \"\", \"%s: offset mismatch\", path);",
          "2276:     } else if ((size_t) offset + hm->body.len > max_size) {",
          "2277:       mg_http_reply(c, 400, \"\", \"%s: over max size of %lu\", path,",
          "2278:                     (unsigned long) max_size);",
          "2279:       res = -3;",
          "2280:     } else if ((fd = mg_fs_open(fs, path, MG_FS_WRITE)) == NULL) {",
          "2281:       mg_http_reply(c, 400, \"\", \"open(%s): %d\", path, errno);",
          "2282:       res = -4;",
          "2284:       res = offset + (long) fs->wr(fd->fd, hm->body.ptr, hm->body.len);",
          "2286:       mg_http_reply(c, 200, \"\", \"%ld\", res);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4795: }",
          "4797: char *mg_remove_double_dots(char *s) {",
          "4799:   while (*s != '\\0') {",
          "4801:     if (s[-1] == '/' || s[-1] == '\\\\') {",
          "",
          "[Removed Lines]",
          "4798:   char *p = s;",
          "",
          "[Added Lines]",
          "4804:   char *saved = s, *p = s;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4812:     }",
          "4813:   }",
          "4816: }",
          "4818: #ifdef MG_ENABLE_LINES",
          "",
          "[Removed Lines]",
          "4815:   return s;",
          "",
          "[Added Lines]",
          "4821:   return saved;",
          "",
          "---------------"
        ],
        "mongoose.h||mongoose.h": [
          "File: mongoose.h -> mongoose.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1107: size_t mg_url_encode(const char *s, size_t n, char *buf, size_t len);",
          "1108: void mg_http_creds(struct mg_http_message *, char *, size_t, char *, size_t);",
          "1109: bool mg_http_match_uri(const struct mg_http_message *, const char *glob);",
          "1112: void mg_http_bauth(struct mg_connection *, const char *user, const char *pass);",
          "1113: struct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v);",
          "1114: size_t mg_http_next_multipart(struct mg_str, size_t, struct mg_http_part *);",
          "",
          "[Removed Lines]",
          "1110: int mg_http_upload(struct mg_connection *, struct mg_http_message *hm,",
          "1111:                    struct mg_fs *fs, const char *dir);",
          "",
          "[Added Lines]",
          "1110: long mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
          "1111:                     struct mg_fs *fs, const char *path, size_t max_size);",
          "",
          "---------------"
        ],
        "src/http.c||src/http.c": [
          "File: src/http.c -> src/http.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "838:   if (c->pfn_data != NULL) c->pfn_data = (char *) c->pfn_data - ch.len;",
          "839: }",
          "852:   } else {",
          "853:     struct mg_fd *fd;",
          "861:       res = -2;",
          "862:     } else {",
          "864:       mg_fs_close(fd);",
          "866:     }",
          "867:   }",
          "868:   return res;",
          "",
          "[Removed Lines]",
          "841: int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
          "842:                    struct mg_fs *fs, const char *dir) {",
          "843:   char offset[40] = \"\", name[200] = \"\", path[256];",
          "844:   int res = 0;",
          "845:   mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));",
          "846:   mg_http_get_var(&hm->query, \"name\", name, sizeof(name));",
          "847:   if (name[0] == '\\0') {",
          "848:     mg_http_reply(c, 400, \"\", \"%s\", \"name required\");",
          "849:     res = -1;",
          "850:   } else if (hm->body.len == 0) {",
          "851:     mg_http_reply(c, 200, \"\", \"%d\", res);  // Nothing to write",
          "854:     long oft = strtol(offset, NULL, 0);",
          "855:     mg_snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
          "856:     mg_remove_double_dots(path);",
          "857:     MG_DEBUG((\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));",
          "858:     if (oft == 0) fs->rm(path);",
          "859:     if ((fd = mg_fs_open(fs, path, MG_FS_WRITE)) == NULL) {",
          "860:       mg_http_reply(c, 400, \"\", \"open(%s): %d\", path, errno);",
          "863:       res = (int) fs->wr(fd->fd, hm->body.ptr, hm->body.len);",
          "865:       mg_http_reply(c, 200, \"\", \"%d\", res);",
          "",
          "[Added Lines]",
          "841: long mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
          "842:                     struct mg_fs *fs, const char *path, size_t max_size) {",
          "843:   char buf[20] = \"\";",
          "844:   long res = 0, offset;",
          "845:   mg_http_get_var(&hm->query, \"offset\", buf, sizeof(buf));",
          "846:   offset = strtol(buf, NULL, 0);",
          "847:   if (hm->body.len == 0) {",
          "848:     mg_http_reply(c, 200, \"\", \"%ld\", res);  // Nothing to write",
          "851:     size_t current_size = 0;",
          "852:     MG_DEBUG((\"%s -> %d bytes @ %ld\", path, (int) hm->body.len, offset));",
          "853:     if (offset == 0) fs->rm(path);  // If offset if 0, truncate file",
          "854:     fs->st(path, &current_size, NULL);",
          "855:     if (offset < 0) {",
          "856:       mg_http_reply(c, 400, \"\", \"offset required\");",
          "857:       res = -1;",
          "858:     } else if (offset > 0 && current_size != (size_t) offset) {",
          "859:       mg_http_reply(c, 400, \"\", \"%s: offset mismatch\", path);",
          "861:     } else if ((size_t) offset + hm->body.len > max_size) {",
          "862:       mg_http_reply(c, 400, \"\", \"%s: over max size of %lu\", path,",
          "863:                     (unsigned long) max_size);",
          "864:       res = -3;",
          "865:     } else if ((fd = mg_fs_open(fs, path, MG_FS_WRITE)) == NULL) {",
          "866:       mg_http_reply(c, 400, \"\", \"open(%s): %d\", path, errno);",
          "867:       res = -4;",
          "869:       res = offset + (long) fs->wr(fd->fd, hm->body.ptr, hm->body.len);",
          "871:       mg_http_reply(c, 200, \"\", \"%ld\", res);",
          "",
          "---------------"
        ],
        "src/http.h||src/http.h": [
          "File: src/http.h -> src/http.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "59: size_t mg_url_encode(const char *s, size_t n, char *buf, size_t len);",
          "60: void mg_http_creds(struct mg_http_message *, char *, size_t, char *, size_t);",
          "61: bool mg_http_match_uri(const struct mg_http_message *, const char *glob);",
          "64: void mg_http_bauth(struct mg_connection *, const char *user, const char *pass);",
          "65: struct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v);",
          "66: size_t mg_http_next_multipart(struct mg_str, size_t, struct mg_http_part *);",
          "",
          "[Removed Lines]",
          "62: int mg_http_upload(struct mg_connection *, struct mg_http_message *hm,",
          "63:                    struct mg_fs *fs, const char *dir);",
          "",
          "[Added Lines]",
          "62: long mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
          "63:                     struct mg_fs *fs, const char *path, size_t max_size);",
          "",
          "---------------"
        ],
        "src/str.c||src/str.c": [
          "File: src/str.c -> src/str.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "223: }",
          "225: char *mg_remove_double_dots(char *s) {",
          "227:   while (*s != '\\0') {",
          "229:     if (s[-1] == '/' || s[-1] == '\\\\') {",
          "",
          "[Removed Lines]",
          "226:   char *p = s;",
          "",
          "[Added Lines]",
          "226:   char *saved = s, *p = s;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "240:     }",
          "241:   }",
          "244: }",
          "",
          "[Removed Lines]",
          "243:   return s;",
          "",
          "[Added Lines]",
          "243:   return saved;",
          "",
          "---------------"
        ],
        "test/unit_test.c||test/unit_test.c": [
          "File: test/unit_test.c -> test/unit_test.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "465:       mg_http_creds(hm, user, sizeof(user), pass, sizeof(pass));",
          "466:       mg_http_reply(c, 200, \"\", \"[%s]:[%s]\", user, pass);",
          "467:     } else if (mg_http_match_uri(hm, \"/upload\")) {",
          "469:     } else if (mg_http_match_uri(hm, \"/test/\")) {",
          "470:       struct mg_http_serve_opts sopts;",
          "471:       memset(&sopts, 0, sizeof(sopts));",
          "",
          "[Removed Lines]",
          "468:       mg_http_upload(c, hm, &mg_fs_posix, \".\");",
          "",
          "[Added Lines]",
          "468:       char path[80], name[64];",
          "469:       mg_http_get_var(&hm->query, \"name\", name, sizeof(name));",
          "470:       if (name[0] == '\\0') {",
          "471:         mg_http_reply(c, 400, \"\", \"%s\", \"name required\");",
          "472:       } else {",
          "473:         mg_snprintf(path, sizeof(path), \"./%s\", name);",
          "474:         mg_http_upload(c, hm, &mg_fs_posix, mg_remove_double_dots(path), 99999);",
          "475:         c->is_hexdumping = 1;",
          "476:       }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "02cabcc0ecf09f47971e4c62c90afb0cf155cbef",
      "candidate_info": {
        "commit_hash": "02cabcc0ecf09f47971e4c62c90afb0cf155cbef",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/02cabcc0ecf09f47971e4c62c90afb0cf155cbef",
        "files": [
          "mongoose.c",
          "src/fs_fat.c",
          "src/http.c",
          "src/sock.c",
          "src/tls_mbed.c"
        ],
        "message": "Fix busy loop in TLS case",
        "before_after_code_files": [
          "mongoose.c||mongoose.c",
          "src/fs_fat.c||src/fs_fat.c",
          "src/http.c||src/http.c",
          "src/sock.c||src/sock.c",
          "src/tls_mbed.c||src/tls_mbed.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "499:   return era * 146097 + doe - 719468;",
          "500: }",
          "503:   int year = t->tm_year + 1900;",
          "504:   int month = t->tm_mon;  // 0-11",
          "505:   if (month > 11) {",
          "",
          "[Removed Lines]",
          "502: static time_t mg_timegm(struct tm const *t) {",
          "",
          "[Added Lines]",
          "502: static time_t mg_timegm(const struct tm *t) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "557: static void *ff_open(const char *path, int flags) {",
          "558:   FIL f;",
          "559:   unsigned char mode = FA_READ;",
          "561:   if (f_open(&f, path, mode) == 0) {",
          "562:     FIL *fp = calloc(1, sizeof(*fp));",
          "",
          "[Removed Lines]",
          "560:   if (flags & MG_FS_WRITE) mode |= FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_APPEND;",
          "",
          "[Added Lines]",
          "560:   if (flags & MG_FS_WRITE) mode |= FA_WRITE | FA_OPEN_ALWAYS | FA_OPEN_APPEND;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "587: }",
          "589: static size_t ff_write(void *fp, const void *buf, size_t len) {",
          "598: }",
          "600: static size_t ff_seek(void *fp, size_t offset) {",
          "",
          "[Removed Lines]",
          "590:   unsigned n, sum = 0, bs = MG_FATFS_BSIZE;",
          "591:   while ((size_t) sum < len &&",
          "592:          f_write((FIL *) fp, (char *) buf + sum,",
          "593:                  sum + bs > len ? len - sum : bs, &n) == FR_OK &&",
          "594:          n > 0) {",
          "595:     sum += n;",
          "596:   }",
          "597:   return sum;",
          "",
          "[Added Lines]",
          "590:   unsigned n = 0;",
          "591:   return f_write((FIL *) fp, (char *) buf, len, &n) == FR_OK ? n : 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1882: int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
          "1883:                    struct mg_fs *fs, const char *dir) {",
          "1884:   char offset[40] = \"\", name[200] = \"\", path[256];",
          "1885:   mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));",
          "1886:   mg_http_get_var(&hm->query, \"name\", name, sizeof(name));",
          "1887:   if (name[0] == '\\0') {",
          "1888:     mg_http_reply(c, 400, \"\", \"%s\", \"name required\");",
          "1891:     struct mg_fd *fd;",
          "1892:     long oft = strtol(offset, NULL, 0);",
          "1893:     mg_snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
          "",
          "[Removed Lines]",
          "1889:     return -1;",
          "1890:   } else {",
          "",
          "[Added Lines]",
          "1878:   int res = 0;",
          "1883:     res = -1;",
          "1884:   } else if (hm->body.len > 0) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1896:     if (oft == 0) fs->rm(path);",
          "1897:     if ((fd = mg_fs_open(fs, path, MG_FS_WRITE)) == NULL) {",
          "1898:       mg_http_reply(c, 400, \"\", \"open(%s): %d\", path, errno);",
          "1900:     } else {",
          "1902:       mg_fs_close(fd);",
          "1905:     }",
          "1906:   }",
          "1907: }",
          "1909: int mg_http_status(const struct mg_http_message *hm) {",
          "",
          "[Removed Lines]",
          "1899:       return -2;",
          "1901:       int written = (int) fs->wr(fd->fd, hm->body.ptr, hm->body.len);",
          "1903:       mg_http_reply(c, 200, \"\", \"%d\", written);",
          "1904:       return (int) hm->body.len;",
          "",
          "[Added Lines]",
          "1893:       res = -2;",
          "1895:       res = (int) fs->wr(fd->fd, hm->body.ptr, hm->body.len);",
          "1897:       mg_http_reply(c, 200, \"\", \"%d\", res);",
          "1900:   return res;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3727:     } else {",
          "3728:       if (c->is_readable) read_conn(c);",
          "3729:       if (c->is_writable) write_conn(c);",
          "3731:     }",
          "3733:     if (c->is_draining && c->send.len == 0) c->is_closing = 1;",
          "",
          "[Removed Lines]",
          "3730:       while (c->is_tls && read_conn(c) > 0) (void) 0;  // Read buffered TLS data",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4321: static int mg_net_send(void *ctx, const unsigned char *buf, size_t len) {",
          "4322:   int fd = *(int *) ctx;",
          "4323:   int n = (int) send(fd, buf, len, 0);",
          "4324:   if (n > 0) return n;",
          "4325:   if (mg_wouldblock(n)) return MBEDTLS_ERR_SSL_WANT_WRITE;",
          "4327:   return MBEDTLS_ERR_NET_SEND_FAILED;",
          "4328: }",
          "4330: static int mg_net_recv(void *ctx, unsigned char *buf, size_t len) {",
          "4331:   int fd = *(int *) ctx;",
          "4332:   int n = (int) recv(fd, buf, len, 0);",
          "4333:   if (n > 0) return n;",
          "4334:   if (mg_wouldblock(n)) return MBEDTLS_ERR_SSL_WANT_READ;",
          "4336:   return MBEDTLS_ERR_NET_RECV_FAILED;",
          "4337: }",
          "",
          "[Removed Lines]",
          "4326:   MG_DEBUG((\"n=%d, errno=%d\", n, errno));",
          "4335:   MG_DEBUG((\"n=%d, errno=%d\", n, errno));",
          "",
          "[Added Lines]",
          "4319:   MG_VERBOSE((\"n=%d, errno=%d\", n, errno));",
          "4328:   MG_VERBOSE((\"n=%d, errno=%d\", n, errno));",
          "",
          "---------------"
        ],
        "src/fs_fat.c||src/fs_fat.c": [
          "File: src/fs_fat.c -> src/fs_fat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "12:   return era * 146097 + doe - 719468;",
          "13: }",
          "16:   int year = t->tm_year + 1900;",
          "17:   int month = t->tm_mon;  // 0-11",
          "18:   if (month > 11) {",
          "",
          "[Removed Lines]",
          "15: static time_t mg_timegm(struct tm const *t) {",
          "",
          "[Added Lines]",
          "15: static time_t mg_timegm(const struct tm *t) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "70: static void *ff_open(const char *path, int flags) {",
          "71:   FIL f;",
          "72:   unsigned char mode = FA_READ;",
          "74:   if (f_open(&f, path, mode) == 0) {",
          "75:     FIL *fp = calloc(1, sizeof(*fp));",
          "",
          "[Removed Lines]",
          "73:   if (flags & MG_FS_WRITE) mode |= FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_APPEND;",
          "",
          "[Added Lines]",
          "73:   if (flags & MG_FS_WRITE) mode |= FA_WRITE | FA_OPEN_ALWAYS | FA_OPEN_APPEND;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "100: }",
          "102: static size_t ff_write(void *fp, const void *buf, size_t len) {",
          "111: }",
          "113: static size_t ff_seek(void *fp, size_t offset) {",
          "",
          "[Removed Lines]",
          "103:   unsigned n, sum = 0, bs = MG_FATFS_BSIZE;",
          "104:   while ((size_t) sum < len &&",
          "105:          f_write((FIL *) fp, (char *) buf + sum,",
          "106:                  sum + bs > len ? len - sum : bs, &n) == FR_OK &&",
          "107:          n > 0) {",
          "108:     sum += n;",
          "109:   }",
          "110:   return sum;",
          "",
          "[Added Lines]",
          "103:   unsigned n = 0;",
          "104:   return f_write((FIL *) fp, (char *) buf, len, &n) == FR_OK ? n : 0;",
          "",
          "---------------"
        ],
        "src/http.c||src/http.c": [
          "File: src/http.c -> src/http.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "885: int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
          "886:                    struct mg_fs *fs, const char *dir) {",
          "887:   char offset[40] = \"\", name[200] = \"\", path[256];",
          "888:   mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));",
          "889:   mg_http_get_var(&hm->query, \"name\", name, sizeof(name));",
          "890:   if (name[0] == '\\0') {",
          "891:     mg_http_reply(c, 400, \"\", \"%s\", \"name required\");",
          "894:     struct mg_fd *fd;",
          "895:     long oft = strtol(offset, NULL, 0);",
          "896:     mg_snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
          "",
          "[Removed Lines]",
          "892:     return -1;",
          "893:   } else {",
          "",
          "[Added Lines]",
          "888:   int res = 0;",
          "893:     res = -1;",
          "894:   } else if (hm->body.len > 0) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "899:     if (oft == 0) fs->rm(path);",
          "900:     if ((fd = mg_fs_open(fs, path, MG_FS_WRITE)) == NULL) {",
          "901:       mg_http_reply(c, 400, \"\", \"open(%s): %d\", path, errno);",
          "903:     } else {",
          "905:       mg_fs_close(fd);",
          "908:     }",
          "909:   }",
          "910: }",
          "912: int mg_http_status(const struct mg_http_message *hm) {",
          "",
          "[Removed Lines]",
          "902:       return -2;",
          "904:       int written = (int) fs->wr(fd->fd, hm->body.ptr, hm->body.len);",
          "906:       mg_http_reply(c, 200, \"\", \"%d\", written);",
          "907:       return (int) hm->body.len;",
          "",
          "[Added Lines]",
          "903:       res = -2;",
          "905:       res = (int) fs->wr(fd->fd, hm->body.ptr, hm->body.len);",
          "907:       mg_http_reply(c, 200, \"\", \"%d\", res);",
          "910:   return res;",
          "",
          "---------------"
        ],
        "src/sock.c||src/sock.c": [
          "File: src/sock.c -> src/sock.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "559:     } else {",
          "560:       if (c->is_readable) read_conn(c);",
          "561:       if (c->is_writable) write_conn(c);",
          "563:     }",
          "565:     if (c->is_draining && c->send.len == 0) c->is_closing = 1;",
          "",
          "[Removed Lines]",
          "562:       while (c->is_tls && read_conn(c) > 0) (void) 0;  // Read buffered TLS data",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/tls_mbed.c||src/tls_mbed.c": [
          "File: src/tls_mbed.c -> src/tls_mbed.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: static int mg_net_send(void *ctx, const unsigned char *buf, size_t len) {",
          "33:   int fd = *(int *) ctx;",
          "34:   int n = (int) send(fd, buf, len, 0);",
          "35:   if (n > 0) return n;",
          "36:   if (mg_wouldblock(n)) return MBEDTLS_ERR_SSL_WANT_WRITE;",
          "38:   return MBEDTLS_ERR_NET_SEND_FAILED;",
          "39: }",
          "41: static int mg_net_recv(void *ctx, unsigned char *buf, size_t len) {",
          "42:   int fd = *(int *) ctx;",
          "43:   int n = (int) recv(fd, buf, len, 0);",
          "44:   if (n > 0) return n;",
          "45:   if (mg_wouldblock(n)) return MBEDTLS_ERR_SSL_WANT_READ;",
          "47:   return MBEDTLS_ERR_NET_RECV_FAILED;",
          "48: }",
          "",
          "[Removed Lines]",
          "37:   MG_DEBUG((\"n=%d, errno=%d\", n, errno));",
          "46:   MG_DEBUG((\"n=%d, errno=%d\", n, errno));",
          "",
          "[Added Lines]",
          "35:   MG_VERBOSE((\"n=%d, errno=%d\", n, errno));",
          "44:   MG_VERBOSE((\"n=%d, errno=%d\", n, errno));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "366426e8bb3e0b7d1653eb62314d2b2b3964d0c3",
      "candidate_info": {
        "commit_hash": "366426e8bb3e0b7d1653eb62314d2b2b3964d0c3",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/366426e8bb3e0b7d1653eb62314d2b2b3964d0c3",
        "files": [
          "mongoose.c",
          "mongoose.h",
          "src/http.c",
          "src/http.h"
        ],
        "message": "Avoid extra allocation for static HTTP handling",
        "before_after_code_files": [
          "mongoose.c||mongoose.c",
          "mongoose.h||mongoose.h",
          "src/http.c||src/http.c",
          "src/http.h||src/http.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "432: struct http_data {",
          "433:   void *old_pfn_data;  // Previous pfn_data",
          "434:   FILE *fp;            // For static file serving",
          "435: };",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "573:   hm->message.ptr = hm->head.ptr = s;",
          "574:   hm->body.ptr = end;",
          "575:   hm->head.len = req_len;",
          "576:   hm->message.len = hm->body.len = (size_t) ~0;  // Set body length to infinite",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "571:   hm->chunk.ptr = end;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "667: #if MG_ENABLE_FS",
          "668: static void http_cb(struct mg_connection *, int, void *, void *);",
          "669: static void restore_http_cb(struct mg_connection *c) {",
          "673:   c->pfn = http_cb;",
          "675: }",
          "677: char *mg_http_etag(char *buf, size_t len, mg_stat_t *st) {",
          "",
          "[Removed Lines]",
          "670:   struct http_data *d = (struct http_data *) c->pfn_data;",
          "671:   if (d->fp != NULL) fclose(d->fp);",
          "672:   c->pfn_data = d->old_pfn_data;",
          "674:   free(d);",
          "",
          "[Added Lines]",
          "666:   if (c->pfn_data != NULL) fclose((FILE *) c->pfn_data);",
          "667:   c->pfn_data = NULL;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "709: static void static_cb(struct mg_connection *c, int ev, void *ev_data,",
          "710:                       void *fn_data) {",
          "711:   if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {",
          "714:     size_t n, max = 2 * MG_IO_SIZE;",
          "715:     if (c->send.size < max) mg_iobuf_resize(&c->send, max);",
          "716:     if (c->send.len >= c->send.size) return;  // Rate limit",
          "718:     if (n > 0) c->send.len += n;",
          "719:     if (c->send.len < c->send.size) restore_http_cb(c);",
          "720:   } else if (ev == MG_EV_CLOSE) {",
          "",
          "[Removed Lines]",
          "712:     struct http_data *d = (struct http_data *) fn_data;",
          "717:     n = fread(c->send.buf + c->send.len, 1, c->send.size - c->send.len, d->fp);",
          "",
          "[Added Lines]",
          "706:     FILE *fp = (FILE *) fn_data;",
          "711:     n = fread(c->send.buf + c->send.len, 1, c->send.size - c->send.len, fp);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "808:     if (mg_vcasecmp(&hm->method, \"HEAD\") == 0) {",
          "809:       fclose(fp);",
          "810:     } else {",
          "820:     }",
          "821:   }",
          "822: }",
          "",
          "[Removed Lines]",
          "811:       struct http_data *d = (struct http_data *) calloc(1, sizeof(*d));",
          "812:       if (d == NULL) {",
          "813:         mg_error(c, \"static HTTP OOM\");",
          "814:       } else {",
          "815:         d->fp = fp;",
          "816:         d->old_pfn_data = c->pfn_data;",
          "817:         c->pfn = static_cb;",
          "818:         c->pfn_data = d;",
          "819:       }",
          "",
          "[Added Lines]",
          "805:       c->pfn = static_cb;",
          "806:       c->pfn_data = fp;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1244: struct mg_connection *mg_http_connect(struct mg_mgr *mgr, const char *url,",
          "1245:                                       mg_event_handler_t fn, void *fn_data) {",
          "1246:   struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);",
          "1248: #if MG_ENABLE_HTTP_DEBUG_ENDPOINT",
          "1249:   snprintf(c->label, sizeof(c->label) - 1, \"->%s\", url);",
          "1250: #endif",
          "",
          "[Removed Lines]",
          "1247:   if (c != NULL) c->pfn = http_cb, c->pfn_data = mgr;",
          "",
          "[Added Lines]",
          "1234:   if (c != NULL) c->pfn = http_cb;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1254: struct mg_connection *mg_http_listen(struct mg_mgr *mgr, const char *url,",
          "1255:                                      mg_event_handler_t fn, void *fn_data) {",
          "1256:   struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);",
          "1258: #if MG_ENABLE_HTTP_DEBUG_ENDPOINT",
          "1259:   if (c != NULL) snprintf(c->label, sizeof(c->label) - 1, \"<-LSN\");",
          "1260: #endif",
          "",
          "[Removed Lines]",
          "1257:   if (c != NULL) c->pfn = http_cb, c->pfn_data = mgr;",
          "",
          "[Added Lines]",
          "1244:   if (c != NULL) c->pfn = http_cb;",
          "",
          "---------------"
        ],
        "mongoose.h||mongoose.h": [
          "File: mongoose.h -> mongoose.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "685:   struct mg_http_header headers[MG_MAX_HTTP_HEADERS];  // Headers",
          "686:   struct mg_str body;                                  // Body",
          "687:   struct mg_str head;                                  // Request + headers",
          "688:   struct mg_str message;  // Request + headers + body",
          "689: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "688:   struct mg_str chunk;    // Chunk for chunked encoding,  or partial body",
          "",
          "---------------"
        ],
        "src/http.c||src/http.c": [
          "File: src/http.c -> src/http.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: #include \"version.h\"",
          "10: #include \"ws.h\"",
          "",
          "[Removed Lines]",
          "12: struct http_data {",
          "13:   void *old_pfn_data;  // Previous pfn_data",
          "14:   FILE *fp;            // For static file serving",
          "15: };",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "153:   hm->message.ptr = hm->head.ptr = s;",
          "154:   hm->body.ptr = end;",
          "155:   hm->head.len = req_len;",
          "156:   hm->message.len = hm->body.len = (size_t) ~0;  // Set body length to infinite",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "151:   hm->chunk.ptr = end;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "247: #if MG_ENABLE_FS",
          "248: static void http_cb(struct mg_connection *, int, void *, void *);",
          "249: static void restore_http_cb(struct mg_connection *c) {",
          "253:   c->pfn = http_cb;",
          "255: }",
          "257: char *mg_http_etag(char *buf, size_t len, mg_stat_t *st) {",
          "",
          "[Removed Lines]",
          "250:   struct http_data *d = (struct http_data *) c->pfn_data;",
          "251:   if (d->fp != NULL) fclose(d->fp);",
          "252:   c->pfn_data = d->old_pfn_data;",
          "254:   free(d);",
          "",
          "[Added Lines]",
          "246:   if (c->pfn_data != NULL) fclose((FILE *) c->pfn_data);",
          "247:   c->pfn_data = NULL;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "289: static void static_cb(struct mg_connection *c, int ev, void *ev_data,",
          "290:                       void *fn_data) {",
          "291:   if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {",
          "294:     size_t n, max = 2 * MG_IO_SIZE;",
          "295:     if (c->send.size < max) mg_iobuf_resize(&c->send, max);",
          "296:     if (c->send.len >= c->send.size) return;  // Rate limit",
          "298:     if (n > 0) c->send.len += n;",
          "299:     if (c->send.len < c->send.size) restore_http_cb(c);",
          "300:   } else if (ev == MG_EV_CLOSE) {",
          "",
          "[Removed Lines]",
          "292:     struct http_data *d = (struct http_data *) fn_data;",
          "297:     n = fread(c->send.buf + c->send.len, 1, c->send.size - c->send.len, d->fp);",
          "",
          "[Added Lines]",
          "286:     FILE *fp = (FILE *) fn_data;",
          "291:     n = fread(c->send.buf + c->send.len, 1, c->send.size - c->send.len, fp);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "388:     if (mg_vcasecmp(&hm->method, \"HEAD\") == 0) {",
          "389:       fclose(fp);",
          "390:     } else {",
          "400:     }",
          "401:   }",
          "402: }",
          "",
          "[Removed Lines]",
          "391:       struct http_data *d = (struct http_data *) calloc(1, sizeof(*d));",
          "392:       if (d == NULL) {",
          "393:         mg_error(c, \"static HTTP OOM\");",
          "394:       } else {",
          "395:         d->fp = fp;",
          "396:         d->old_pfn_data = c->pfn_data;",
          "397:         c->pfn = static_cb;",
          "398:         c->pfn_data = d;",
          "399:       }",
          "",
          "[Added Lines]",
          "385:       c->pfn = static_cb;",
          "386:       c->pfn_data = fp;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "824: struct mg_connection *mg_http_connect(struct mg_mgr *mgr, const char *url,",
          "825:                                       mg_event_handler_t fn, void *fn_data) {",
          "826:   struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);",
          "828: #if MG_ENABLE_HTTP_DEBUG_ENDPOINT",
          "829:   snprintf(c->label, sizeof(c->label) - 1, \"->%s\", url);",
          "830: #endif",
          "",
          "[Removed Lines]",
          "827:   if (c != NULL) c->pfn = http_cb, c->pfn_data = mgr;",
          "",
          "[Added Lines]",
          "814:   if (c != NULL) c->pfn = http_cb;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "834: struct mg_connection *mg_http_listen(struct mg_mgr *mgr, const char *url,",
          "835:                                      mg_event_handler_t fn, void *fn_data) {",
          "836:   struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);",
          "838: #if MG_ENABLE_HTTP_DEBUG_ENDPOINT",
          "839:   if (c != NULL) snprintf(c->label, sizeof(c->label) - 1, \"<-LSN\");",
          "840: #endif",
          "",
          "[Removed Lines]",
          "837:   if (c != NULL) c->pfn = http_cb, c->pfn_data = mgr;",
          "",
          "[Added Lines]",
          "824:   if (c != NULL) c->pfn = http_cb;",
          "",
          "---------------"
        ],
        "src/http.h||src/http.h": [
          "File: src/http.h -> src/http.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "17:   struct mg_http_header headers[MG_MAX_HTTP_HEADERS];  // Headers",
          "18:   struct mg_str body;                                  // Body",
          "19:   struct mg_str head;                                  // Request + headers",
          "20:   struct mg_str message;  // Request + headers + body",
          "21: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20:   struct mg_str chunk;    // Chunk for chunked encoding,  or partial body",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2018-11376",
  "cve_desc": "The r_read_le32() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted ELF file.",
  "repo": "radare/radare2",
  "patch_hash": "1f37c04f2a762500222dda2459e6a04646feeedf",
  "patch_info": {
    "commit_hash": "1f37c04f2a762500222dda2459e6a04646feeedf",
    "repo": "radare/radare2",
    "commit_url": "https://github.com/radare/radare2/commit/1f37c04f2a762500222dda2459e6a04646feeedf",
    "files": [
      "libr/bin/p/bin_elf.c",
      "libr/core/cbin.c"
    ],
    "message": "Fix #9904 - crash in r2_hoobr_r_read_le32 (over 9000 entrypoints) and read_le oobread (#9923)",
    "before_after_code_files": [
      "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c",
      "libr/core/cbin.c||libr/core/cbin.c"
    ]
  },
  "patch_diff": {
    "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c": [
      "File: libr/bin/p/bin_elf.c -> libr/bin/p/bin_elf.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "348:    }",
      "349:    (void)r_buf_read_at (bf->buf, sec->paddr, buf, sec->size);",
      "350:    if (bits == 32) {",
      "352:      ut32 addr32 = r_read_le32 (buf + i);",
      "353:      if (addr32) {",
      "354:       RBinAddr *ba = newEntry (sec->paddr + i, (ut64)addr32, type, bits);",
      "",
      "[Removed Lines]",
      "351:     for (i = 0; i < sec->size; i += 4) {",
      "",
      "[Added Lines]",
      "351:     for (i = 0; (i + 3) < sec->size; i += 4) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "356:      }",
      "357:     }",
      "358:    } else {",
      "360:      ut64 addr64 = r_read_le64 (buf + i);",
      "361:      if (addr64) {",
      "362:       RBinAddr *ba = newEntry (sec->paddr + i, addr64, type, bits);",
      "",
      "[Removed Lines]",
      "359:     for (i = 0; i < sec->size; i += 8) {",
      "",
      "[Added Lines]",
      "359:     for (i = 0; (i + 7) < sec->size; i += 8) {",
      "",
      "---------------"
    ],
    "libr/core/cbin.c||libr/core/cbin.c": [
      "File: libr/core/cbin.c -> libr/core/cbin.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1044:    r_cons_printf (\"[Entrypoints]\\n\");",
      "1045:   }",
      "1046:  }",
      "1048:  r_list_foreach (entries, iter, entry) {",
      "1049:   ut64 paddr = entry->paddr;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1047:  if (r_list_length (entries) > 1024) {",
      "1048:   eprintf (\"Too many entrypoints (%d)\\n\", r_list_length (entries));",
      "1049:   return false;",
      "1050:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "672b2a38509a96cd4c63517782d5e21603cdc001",
      "candidate_info": {
        "commit_hash": "672b2a38509a96cd4c63517782d5e21603cdc001",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/672b2a38509a96cd4c63517782d5e21603cdc001",
        "files": [
          "libr/bin/format/mdmp/mdmp_pe.c",
          "libr/bin/p/bin_elf.c",
          "libr/bin/p/bin_mach0.c",
          "libr/bin/p/bin_ningb.c",
          "libr/bin/p/bin_pe.c",
          "libr/core/cbin.c",
          "libr/include/r_bin.h",
          "shlr/java/class.c"
        ],
        "message": "Add hvaddr to iee(j) output; haddr -> hpaddr (#10899)\n\n* iee(j): add hvaddr\n\n* haddr -> hpaddr\n\n* Minor realignment",
        "before_after_code_files": [
          "libr/bin/format/mdmp/mdmp_pe.c||libr/bin/format/mdmp/mdmp_pe.c",
          "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c",
          "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c",
          "libr/bin/p/bin_ningb.c||libr/bin/p/bin_ningb.c",
          "libr/bin/p/bin_pe.c||libr/bin/p/bin_pe.c",
          "libr/core/cbin.c||libr/core/cbin.c",
          "libr/include/r_bin.h||libr/include/r_bin.h",
          "shlr/javclass.c||shlr/java/class.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c",
            "libr/core/cbin.c||libr/core/cbin.c"
          ],
          "candidate": [
            "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c",
            "libr/core/cbin.c||libr/core/cbin.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/format/mdmp/mdmp_pe.c||libr/bin/format/mdmp/mdmp_pe.c": [
          "File: libr/bin/format/mdmp/mdmp_pe.c -> libr/bin/format/mdmp/mdmp_pe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "30:    break;",
          "31:   }",
          "32:   if ((ptr = R_NEW0 (RBinAddr))) {",
          "37:    r_list_append (list, ptr);",
          "38:   }",
          "39:   count++;",
          "",
          "[Removed Lines]",
          "33:    ptr->paddr = paddr;",
          "34:    ptr->vaddr = vaddr;",
          "35:    ptr->haddr = haddr;",
          "36:    ptr->type  = R_BIN_ENTRY_TYPE_TLS;",
          "",
          "[Added Lines]",
          "33:    ptr->paddr  = paddr;",
          "34:    ptr->vaddr  = vaddr;",
          "35:    ptr->hpaddr = haddr;",
          "36:    ptr->type   = R_BIN_ENTRY_TYPE_TLS;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "58:   if (offset > pe_bin->vaddr) {",
          "59:    offset -= pe_bin->vaddr;",
          "60:   }",
          "66:   r_list_append (ret, ptr);",
          "67:  }",
          "",
          "[Removed Lines]",
          "61:   ptr->paddr = offset + pe_bin->paddr;",
          "62:   ptr->vaddr = offset + pe_bin->vaddr;",
          "63:   ptr->haddr = pe_bin->paddr + entry->haddr;",
          "64:   ptr->type  = R_BIN_ENTRY_TYPE_PROGRAM;",
          "",
          "[Added Lines]",
          "61:   ptr->paddr  = offset + pe_bin->paddr;",
          "62:   ptr->vaddr  = offset + pe_bin->vaddr;",
          "63:   ptr->hpaddr = pe_bin->paddr + entry->haddr;",
          "64:   ptr->type   = R_BIN_ENTRY_TYPE_PROGRAM;",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c": [
          "File: libr/bin/p/bin_elf.c -> libr/bin/p/bin_elf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "308:  return ret;",
          "309: }",
          "312:  RBinAddr *ptr = R_NEW0 (RBinAddr);",
          "313:  if (ptr) {",
          "314:   ptr->paddr = paddr;",
          "315:   ptr->vaddr = paddr;",
          "317:   ptr->hvaddr = hvaddr;",
          "318:   ptr->bits = bits;",
          "319:   ptr->type = type;",
          "",
          "[Removed Lines]",
          "311: static RBinAddr* newEntry(ut64 haddr, ut64 hvaddr, ut64 paddr, int type, int bits) {",
          "316:   ptr->haddr = haddr;",
          "",
          "[Added Lines]",
          "311: static RBinAddr* newEntry(ut64 hpaddr, ut64 hvaddr, ut64 paddr, int type, int bits) {",
          "316:   ptr->hpaddr = hpaddr;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "390:  }",
          "391:  ptr->paddr = Elf_(r_bin_elf_get_entry_offset) (obj);",
          "392:  ptr->vaddr = Elf_(r_bin_elf_p2v) (obj, ptr->paddr);",
          "395:  if (obj->ehdr.e_machine == EM_ARM) {",
          "396:   int bin_bits = Elf_(r_bin_elf_get_bits) (obj);",
          "",
          "[Removed Lines]",
          "393:  ptr->haddr = 0x18;",
          "",
          "[Added Lines]",
          "393:  ptr->hpaddr = 0x18;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "421:     }",
          "422:     ptr->paddr = symbol[i].offset;",
          "423:     ptr->vaddr = Elf_(r_bin_elf_p2v) (obj, ptr->paddr);",
          "425:     ptr->type = R_BIN_ENTRY_TYPE_INIT;",
          "426:     r_list_append (ret, ptr);",
          "427:     break;",
          "",
          "[Removed Lines]",
          "424:     ptr->haddr = UT64_MAX;",
          "",
          "[Added Lines]",
          "424:     ptr->hpaddr = UT64_MAX;",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c": [
          "File: libr/bin/p/bin_mach0.c -> libr/bin/p/bin_mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "158:  return ret;",
          "159: }",
          "162:  RBinAddr *ptr = R_NEW0 (RBinAddr);",
          "163:  if (ptr) {",
          "164:   ptr->paddr = paddr;",
          "165:   ptr->vaddr = paddr;",
          "167:   ptr->bits = bits;",
          "168:   ptr->type = type;",
          "",
          "[Removed Lines]",
          "161: static RBinAddr* newEntry(ut64 haddr, ut64 paddr, int type, int bits) {",
          "166:   ptr->haddr = haddr;",
          "",
          "[Added Lines]",
          "161: static RBinAddr* newEntry(ut64 hpaddr, ut64 paddr, int type, int bits) {",
          "166:   ptr->hpaddr = hpaddr;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "229:  if ((ptr = R_NEW0 (RBinAddr))) {",
          "230:   ptr->paddr = entry->offset + obj->boffset;",
          "231:   ptr->vaddr = entry->addr;",
          "233:   ptr->bits = bits;",
          "235:   if (bits == 16) {",
          "",
          "[Removed Lines]",
          "232:   ptr->haddr = entry->haddr;",
          "",
          "[Added Lines]",
          "232:   ptr->hpaddr = entry->haddr;",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_ningb.c||libr/bin/p/bin_ningb.c": [
          "File: libr/bin/p/bin_ningb.c -> libr/bin/p/bin_ningb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "66:   ret->free = free;",
          "67:   if (!(ptr = R_NEW0 (RBinAddr)))",
          "68:    return ret;",
          "70:   r_list_append (ret, ptr);",
          "71:  }",
          "72:  return ret;",
          "",
          "[Removed Lines]",
          "69:   ptr->paddr = ptr->vaddr = ptr->haddr = 0x100;",
          "",
          "[Added Lines]",
          "69:   ptr->paddr = ptr->vaddr = ptr->hpaddr = 0x100;",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_pe.c||libr/bin/p/bin_pe.c": [
          "File: libr/bin/p/bin_pe.c -> libr/bin/p/bin_pe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "112:    break;",
          "113:   }",
          "114:   if ((ptr = R_NEW0 (RBinAddr))) {",
          "119:    r_list_append (list, ptr);",
          "120:   }",
          "121:   count++;",
          "",
          "[Removed Lines]",
          "115:    ptr->paddr = paddr;",
          "116:    ptr->vaddr = vaddr;",
          "117:    ptr->haddr = haddr;",
          "118:    ptr->type  = R_BIN_ENTRY_TYPE_TLS;",
          "",
          "[Added Lines]",
          "115:    ptr->paddr  = paddr;",
          "116:    ptr->vaddr  = vaddr;",
          "117:    ptr->hpaddr = haddr;",
          "118:    ptr->type   = R_BIN_ENTRY_TYPE_TLS;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "134:   return ret;",
          "135:  }",
          "136:  if ((ptr = R_NEW0 (RBinAddr))) {",
          "141:   r_list_append (ret, ptr);",
          "142:  }",
          "143:  free (entry);",
          "",
          "[Removed Lines]",
          "137:   ptr->paddr = entry->paddr;",
          "138:   ptr->vaddr = entry->vaddr;",
          "139:   ptr->haddr = entry->haddr;",
          "140:   ptr->type  = R_BIN_ENTRY_TYPE_PROGRAM;",
          "",
          "[Added Lines]",
          "137:   ptr->paddr  = entry->paddr;",
          "138:   ptr->vaddr  = entry->vaddr;",
          "139:   ptr->hpaddr = entry->haddr;",
          "140:   ptr->type   = R_BIN_ENTRY_TYPE_PROGRAM;",
          "",
          "---------------"
        ],
        "libr/core/cbin.c||libr/core/cbin.c": [
          "File: libr/core/cbin.c -> libr/core/cbin.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1082:  return true;",
          "1083: }",
          "1085: static int bin_entry(RCore *r, int mode, ut64 laddr, int va, bool inifin) {",
          "1086:  char str[R_FLAG_NAME_SIZE];",
          "1087:  RList *entries = r_bin_get_entries (r->bin);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1085: static inline bool is_initfini(RBinAddr *entry) {",
          "1086:  switch (entry->type) {",
          "1087:  case R_BIN_ENTRY_TYPE_INIT:",
          "1088:  case R_BIN_ENTRY_TYPE_FINI:",
          "1089:  case R_BIN_ENTRY_TYPE_PREINIT:",
          "1090:   return true;",
          "1091:  default:",
          "1092:   return false;",
          "1093:  }",
          "1094: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1110:  r_list_foreach (entries, iter, entry) {",
          "1111:   ut64 paddr = entry->paddr;",
          "1113:   ut64 hvaddr = UT64_MAX;",
          "1114:   if (mode != R_CORE_BIN_SET) {",
          "1115:    if (inifin) {",
          "",
          "[Removed Lines]",
          "1112:   ut64 haddr = UT64_MAX;",
          "",
          "[Added Lines]",
          "1123:   ut64 hpaddr = UT64_MAX;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1122:     }",
          "1123:    }",
          "1124:   }",
          "1134:    }",
          "1135:   }",
          "1138:   }",
          "1139:   if (entry->hvaddr) {",
          "1140:    hvaddr = entry->hvaddr;",
          "",
          "[Removed Lines]",
          "1125:   switch (entry->type) {",
          "1126:   case R_BIN_ENTRY_TYPE_INIT:",
          "1127:   case R_BIN_ENTRY_TYPE_FINI:",
          "1128:   case R_BIN_ENTRY_TYPE_PREINIT:",
          "1129:    if (r->io->va && entry->paddr == entry->vaddr) {",
          "1130:     RIOMap *map = r_io_map_get (r->io, entry->vaddr);",
          "1131:     if (map) {",
          "1132:      paddr = entry->vaddr - map->itv.addr + map->delta;",
          "1133:     }",
          "1136:   if (entry->haddr) {",
          "1137:    haddr = entry->haddr;",
          "",
          "[Added Lines]",
          "1136:   if (is_initfini (entry) && r->io->va && entry->paddr == entry->vaddr) {",
          "1137:    RIOMap *map = r_io_map_get (r->io, entry->vaddr);",
          "1138:    if (map) {",
          "1139:     paddr = entry->vaddr - map->itv.addr + map->delta;",
          "1142:   if (entry->hpaddr) {",
          "1143:    hpaddr = entry->hpaddr;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1156:     snprintf (str, R_FLAG_NAME_SIZE, \"entry%i\", i);",
          "1157:    }",
          "1158:    r_flag_set (r->flags, str, at, 1);",
          "1168:    }",
          "1169:   } else if (IS_MODE_SIMPLE (mode)) {",
          "1170:    r_cons_printf (\"0x%08\"PFMT64x\"\\n\", at);",
          "",
          "[Removed Lines]",
          "1159:    switch (entry->type) {",
          "1160:    case R_BIN_ENTRY_TYPE_INIT:",
          "1161:    case R_BIN_ENTRY_TYPE_FINI:",
          "1162:    case R_BIN_ENTRY_TYPE_PREINIT:",
          "1163:     if (haddr != UT64_MAX && hvaddr != UT64_MAX) {",
          "1164:      ut64 elem_addr = rva (r->bin, haddr, hvaddr, va);",
          "1165:      r_meta_add (r->anal, R_META_TYPE_DATA, elem_addr,",
          "1166:                  elem_addr + entry->bits / 8, NULL);",
          "1167:     }",
          "",
          "[Added Lines]",
          "1165:    if (is_initfini (entry) && hpaddr != UT64_MAX && hvaddr != UT64_MAX) {",
          "1166:     ut64 elem_addr = rva (r->bin, hpaddr, hvaddr, va);",
          "1167:     r_meta_add (r->anal, R_META_TYPE_DATA, elem_addr,",
          "1168:                 elem_addr + entry->bits / 8, NULL);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1172:    r_cons_printf (\"%s{\\\"vaddr\\\":%\" PFMT64u \",\"",
          "1173:     \"\\\"paddr\\\":%\" PFMT64u \",\"",
          "1174:     \"\\\"baddr\\\":%\" PFMT64u \",\"",
          "1177:     \"\\\"type\\\":\\\"%s\\\"}\",",
          "1179:   } else if (IS_MODE_RAD (mode)) {",
          "1180:    char *name = NULL;",
          "1181:    if (entry->type == R_BIN_ENTRY_TYPE_INIT) {",
          "",
          "[Removed Lines]",
          "1175:     \"\\\"laddr\\\":%\" PFMT64u \",\"",
          "1176:     \"\\\"haddr\\\":%\" PFMT64u \",\"",
          "1178:     last_processed ? \",\" : \"\", at, paddr, baddr, laddr, haddr, type);",
          "",
          "[Added Lines]",
          "1176:     \"\\\"laddr\\\":%\" PFMT64u \",\",",
          "1177:     last_processed ? \",\" : \"\", at, paddr, baddr, laddr);",
          "1178:    if (is_initfini (entry) && hvaddr != UT64_MAX) {",
          "1179:     r_cons_printf (\"\\\"hvaddr\\\":%\" PFMT64u \",\", hvaddr);",
          "1180:    }",
          "1181:    r_cons_printf (\"\\\"hpaddr\\\":%\" PFMT64u \",\"",
          "1183:     hpaddr, type);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1188:     name = r_str_newf (\"entry%i\", i);",
          "1189:    }",
          "1190:    r_cons_printf (\"f %s 1 @ 0x%08\"PFMT64x\"\\n\", name, at);",
          "1192:    r_cons_printf (\"s %s\\n\", name);",
          "1193:    free (name);",
          "1194:   } else {",
          "",
          "[Removed Lines]",
          "1191:    r_cons_printf (\"f %s_haddr 1 @ 0x%08\"PFMT64x\"\\n\", name, haddr);",
          "",
          "[Added Lines]",
          "1196:    r_cons_printf (\"f %s_hpaddr 1 @ 0x%08\"PFMT64x\"\\n\", name, hpaddr);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1198:     \" baddr=0x%08\"PFMT64x",
          "1199:     \" laddr=0x%08\"PFMT64x,",
          "1200:     at, paddr, baddr, laddr);",
          "1203:    } else {",
          "1205:    }",
          "1206:    r_cons_printf (\" type=%s\\n\", type);",
          "1207:   }",
          "",
          "[Removed Lines]",
          "1201:    if (haddr == UT64_MAX) {",
          "1202:     r_cons_printf (\" haddr=%\"PFMT64d, haddr);",
          "1204:     r_cons_printf (\" haddr=0x%08\"PFMT64x, haddr);",
          "",
          "[Added Lines]",
          "1206:    if (is_initfini (entry) && hvaddr != UT64_MAX) {",
          "1207:     r_cons_printf (\" hvaddr=0x%08\"PFMT64x, hvaddr);",
          "1208:    }",
          "1209:    if (hpaddr == UT64_MAX) {",
          "1210:     r_cons_printf (\" hpaddr=%\"PFMT64d, hpaddr);",
          "1212:     r_cons_printf (\" hpaddr=0x%08\"PFMT64x, hpaddr);",
          "",
          "---------------"
        ],
        "libr/include/r_bin.h||libr/include/r_bin.h": [
          "File: libr/include/r_bin.h -> libr/include/r_bin.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "169: typedef struct r_bin_addr_t {",
          "170:  ut64 vaddr;",
          "171:  ut64 paddr;",
          "173:  ut64 hvaddr;",
          "174:  int type;",
          "175:  int bits;",
          "176: } RBinAddr;",
          "",
          "[Removed Lines]",
          "172:  ut64 haddr;",
          "",
          "[Added Lines]",
          "173:  ut64 hpaddr;",
          "",
          "---------------"
        ],
        "shlr/javclass.c||shlr/java/class.c": [
          "File: shlr/javclass.c -> shlr/java/class.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2408:     addr->hpaddr = fm_type->file_offset;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b40958266a465b758931c5f4a68ef25402727971",
      "candidate_info": {
        "commit_hash": "b40958266a465b758931c5f4a68ef25402727971",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/b40958266a465b758931c5f4a68ef25402727971",
        "files": [
          "libr/bin/format/mach0/mach0.c",
          "libr/bin/p/bin_elf.c"
        ],
        "message": "Fix ihj ELF (#10081)",
        "before_after_code_files": [
          "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c",
          "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c"
          ],
          "candidate": [
            "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c": [
          "File: libr/bin/format/mach0/mach0.c -> libr/bin/format/mach0/mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2482: #define ROW(nam,siz,val,fmt) \\",
          "2483:  r_list_append (ret, r_bin_field_new (addr, addr, siz, nam, sdb_fmt (\"0x%08x\", val), fmt)); \\",
          "2484:  addr += 4;",
          "2491:  free (mh);",
          "2492:  return ret;",
          "2493: }",
          "",
          "[Removed Lines]",
          "2485:  ROW(\"hdr.magic\", 4, mh->magic, \"x\");",
          "2486:  ROW(\"hdr.cputype\", 4, mh->cputype, NULL);",
          "2487:  ROW(\"hdr.cpusubtype\", 4, mh->cpusubtype, NULL);",
          "2488:  ROW(\"hdr.filetype\", 4, mh->filetype, NULL);",
          "2489:  ROW(\"hdr.ncmds\", 4, mh->ncmds, NULL);",
          "2490:  ROW(\"hdr.sizeofcmds\", 4, mh->sizeofcmds, NULL);",
          "",
          "[Added Lines]",
          "2485:  ROW (\"hdr.magic\", 4, mh->magic, \"x\");",
          "2486:  ROW (\"hdr.cputype\", 4, mh->cputype, \"x\");",
          "2487:  ROW (\"hdr.cpusubtype\", 4, mh->cpusubtype, \"x\");",
          "2488:  ROW (\"hdr.filetype\", 4, mh->filetype, \"x\");",
          "2489:  ROW (\"hdr.nbcmds\", 4, mh->ncmds, \"x\");",
          "2490:  ROW (\"hdr.sizeofcmds\", 4, mh->sizeofcmds, \"x\");",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c": [
          "File: libr/bin/p/bin_elf.c -> libr/bin/p/bin_elf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1101: static RList* fields(RBinFile *bf) {",
          "1102:  RList *ret = NULL;",
          "1107:  if (!(ret = r_list_new ())) {",
          "1108:   return NULL;",
          "1109:  }",
          "1110:  ret->free = free;",
          "1112:   return ret;",
          "1117:   }",
          "1123:  }",
          "1125:  return ret;",
          "1126: }",
          "",
          "[Removed Lines]",
          "1103:  RBinField *ptr = NULL;",
          "1104:  struct r_bin_elf_field_t *field = NULL;",
          "1105:  int i;",
          "1111:  if (!(field = Elf_(r_bin_elf_get_fields) (bf->o->bin_obj))) {",
          "1113:  }",
          "1114:  for (i = 0; !field[i].last; i++) {",
          "1115:   if (!(ptr = R_NEW0 (RBinField))) {",
          "1116:    break;",
          "1118:   ptr->name = strdup (field[i].name);",
          "1119:   ptr->comment = NULL;",
          "1120:   ptr->vaddr = field[i].offset;",
          "1121:   ptr->paddr = field[i].offset;",
          "1122:   r_list_append (ret, ptr);",
          "1124:  free (field);",
          "",
          "[Added Lines]",
          "1103:  const ut8 *buf = NULL;",
          "1110:  if (!(buf = r_buf_get_at (bf->buf, 0, NULL))) {",
          "1111:   RBinField *ptr = NULL;",
          "1112:   struct r_bin_elf_field_t *field = NULL;",
          "1113:   int i;",
          "1115:   if (!(field = Elf_(r_bin_elf_get_fields) (bf->o->bin_obj))) {",
          "1118:   for (i = 0; !field[i].last; i++) {",
          "1119:    if (!(ptr = R_NEW0 (RBinField))) {",
          "1120:     break;",
          "1121:    }",
          "1122:    ptr->name = strdup (field[i].name);",
          "1123:    ptr->comment = NULL;",
          "1124:    ptr->vaddr = field[i].offset;",
          "1125:    ptr->paddr = field[i].offset;",
          "1126:    r_list_append (ret, ptr);",
          "1127:   }",
          "1128:   free (field);",
          "1130:  } else {",
          "1131:   #define ROW(nam,siz,val,fmt) \\",
          "1132:   r_list_append (ret, r_bin_field_new (addr, addr, siz, nam, sdb_fmt (\"0x%08x\", val), fmt));",
          "1133:   ut64 addr = 0;",
          "1134:   const ut8 *buf = r_buf_get_at (bf->buf, 0, NULL);",
          "1135:   ROW (\"ELF\", 4, r_read_le32 (buf), \"x\"); addr+=0x10;",
          "1136:   ROW (\"Type\", 2, r_read_le16 (buf + addr), \"x\"); addr+=0x2;",
          "1137:   ROW (\"Machine\", 2, r_read_le16 (buf + addr), \"x\"); addr+=0x2;",
          "1138:   ROW (\"Version\", 4, r_read_le32 (buf + addr), \"x\"); addr+=0x4;",
          "1140:   if (r_read_le8(buf + 0x04) == 1) {",
          "1141:    ROW (\"Entry point\", 4, r_read_le32 (buf + addr), \"x\"); addr+=0x4;",
          "1142:    ROW (\"PhOff\", 4, r_read_le32 (buf + addr), \"x\"); addr+=0x4;",
          "1143:    ROW (\"ShOff\", 4, r_read_le32 (buf + addr), \"x\");",
          "1144:   } else {",
          "1145:    ROW (\"Entry point\", 8, r_read_le64 (buf + addr), \"x\"); addr+=0x8;",
          "1146:    ROW (\"PhOff\", 8, r_read_le64 (buf + addr), \"x\"); addr+=0x8;",
          "1147:    ROW (\"ShOff\", 8, r_read_le64 (buf + addr), \"x\");",
          "1148:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1148: #define p bf->rbin->cb_printf",
          "1149:  const ut8 *buf = r_buf_get_at (bf->buf, 0, NULL);",
          "1150:  p (\"0x00000000  ELF MAGIC   0x%08x\\n\", r_read_le32 (buf));",
          "1157: }",
          "1159: static bool check_bytes(const ut8 *buf, ut64 length) {",
          "",
          "[Removed Lines]",
          "1151:  p (\"0x00000004  Type        0x%04x\\n\", r_read_le16 (buf + 4));",
          "1152:  p (\"0x00000006  Machine     0x%04x\\n\", r_read_le16 (buf + 6));",
          "1153:  p (\"0x00000008  Version     0x%08x\\n\", r_read_le32 (buf + 8));",
          "1154:  p (\"0x0000000c  Entrypoint  0x%08x\\n\", r_read_le32 (buf + 12));",
          "1155:  p (\"0x00000010  PhOff       0x%08x\\n\", r_read_le32 (buf + 16));",
          "1156:  p (\"0x00000014  ShOff       0x%08x\\n\", r_read_le32 (buf + 20));",
          "",
          "[Added Lines]",
          "1177:  p (\"0x00000010  Type        0x%04x\\n\", r_read_le16 (buf + 0x10));",
          "1178:  p (\"0x00000012  Machine     0x%04x\\n\", r_read_le16 (buf + 0x12));",
          "1179:  p (\"0x00000014  Version     0x%08x\\n\", r_read_le32 (buf + 0x14));",
          "1180:  p (\"0x00000018  Entrypoint  0x%08x\\n\", r_read_le32 (buf + 0x18));",
          "1181:  p (\"0x0000001c  PhOff       0x%08x\\n\", r_read_le32 (buf + 0x1c));",
          "1182:  p (\"0x00000020  ShOff       0x%08x\\n\", r_read_le32 (buf + 0x20));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7677ef924668a7e7742eb77c9086a4149696e577",
      "candidate_info": {
        "commit_hash": "7677ef924668a7e7742eb77c9086a4149696e577",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/7677ef924668a7e7742eb77c9086a4149696e577",
        "files": [
          "libr/anal/fcn.c",
          "libr/core/canal.c",
          "libr/core/cbin.c",
          "libr/core/cmd_help.c",
          "libr/core/cmd_print.c",
          "libr/core/core.c",
          "libr/egg/egg.c",
          "libr/include/r_print.h",
          "libr/util/list.c",
          "libr/util/print.c",
          "libr/util/strbuf.c"
        ],
        "message": "Memleaks (fix #11389) (#11674)\n\n* util/strbuf: r_return ification!\n* r_core_anal_hasrefs returns malloced string, free it after use\n* util/list: r_return ification\n* anal/fcn: prevent memleaks of RListIter objects in fcn->fcn_locs\nThe fcn_locs list was not freed because we don't need to free functions\nfrom fcn_locs but we free them in core->anal. However, the list->free\nmethod was set, even if never used, so I removed it.\nMoreover, we should free the fcn_locs list anyway (but not the elements\ninside) because the RListIter elements have been allocated on the heap.\n* egg: remove *uck message\n* core/cbin: check returned list before using it\n* core/cbin: check list before using it\n* util/strbuf: fix r_return condition in strbuf_append\n* libr/core: fix some possible NULL deref and avoid function ptr casts\n* only fcn->fcn_locs doesn't need the free function, the others do",
        "before_after_code_files": [
          "libr/anal/fcn.c||libr/anal/fcn.c",
          "libr/core/canal.c||libr/core/canal.c",
          "libr/core/cbin.c||libr/core/cbin.c",
          "libr/core/cmd_help.c||libr/core/cmd_help.c",
          "libr/core/cmd_print.c||libr/core/cmd_print.c",
          "libr/core/core.c||libr/core/core.c",
          "libr/egg/egg.c||libr/egg/egg.c",
          "libr/include/r_print.h||libr/include/r_print.h",
          "libr/util/list.c||libr/util/list.c",
          "libr/util/print.c||libr/util/print.c",
          "libr/util/strbuf.c||libr/util/strbuf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/core/cbin.c||libr/core/cbin.c"
          ],
          "candidate": [
            "libr/core/cbin.c||libr/core/cbin.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/anal/fcn.c||libr/anal/fcn.c": [
          "File: libr/anal/fcn.c -> libr/anal/fcn.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "302: }",
          "304: R_API RList *r_anal_fcn_list_new() {",
          "311: }",
          "313: R_API void r_anal_fcn_free(void *_fcn) {",
          "",
          "[Removed Lines]",
          "305:  RList *list = r_list_new ();",
          "306:  if (!list) {",
          "307:   return NULL;",
          "308:  }",
          "309:  list->free = &r_anal_fcn_free;",
          "310:  return list;",
          "",
          "[Added Lines]",
          "305:  return r_list_newf (r_anal_fcn_free);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "319:  free (fcn->name);",
          "320:  free (fcn->attr);",
          "321:  r_tinyrange_fini (&fcn->bbr);",
          "324:  if (fcn->bbs) {",
          "326:   r_list_free (fcn->bbs);",
          "327:   fcn->bbs = NULL;",
          "328:  }",
          "329:  free (fcn->fingerprint);",
          "330:  r_anal_diff_free (fcn->diff);",
          "332:  free (fcn->args);",
          "333:  free (fcn);",
          "334: }",
          "",
          "[Removed Lines]",
          "323:  fcn->fcn_locs = NULL;",
          "325:   fcn->bbs->free = (RListFree) r_anal_bb_free;",
          "331:  r_list_free (fcn->fcn_locs);",
          "",
          "[Added Lines]",
          "317:  r_list_free (fcn->fcn_locs);",
          "319:   fcn->bbs->free = (RListFree)r_anal_bb_free;",
          "",
          "---------------"
        ],
        "libr/core/canal.c||libr/core/canal.c": [
          "File: libr/core/canal.c -> libr/core/canal.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "780:      RAnalFunction *f = r_anal_get_fcn_in (core->anal, from, -1);",
          "781:      if (f) {",
          "782:       if (!f->fcn_locs) {",
          "784:       }",
          "785:       r_list_append (f->fcn_locs, fcn);",
          "786:       r_list_sort (f->fcn_locs, &cmpfcn);",
          "",
          "[Removed Lines]",
          "783:        f->fcn_locs = r_anal_fcn_list_new ();",
          "",
          "[Added Lines]",
          "783:        f->fcn_locs = r_list_new ();",
          "",
          "---------------"
        ],
        "libr/core/cbin.c||libr/core/cbin.c": [
          "File: libr/core/cbin.c -> libr/core/cbin.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1125:    r_cons_printf (\"[Entrypoints]\\n\");",
          "1126:   }",
          "1127:  }",
          "1129:   eprintf (\"Too many entrypoints (%d)\\n\", r_list_length (entries));",
          "1130:   return false;",
          "1131:  }",
          "",
          "[Removed Lines]",
          "1128:  if (r_list_length (entries) > 1024) {",
          "",
          "[Added Lines]",
          "1128:  if (entries && r_list_length (entries) > 1024) {",
          "",
          "---------------"
        ],
        "libr/core/cmd_help.c||libr/core/cmd_help.c": [
          "File: libr/core/cmd_help.c -> libr/core/cmd_help.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "967:   break;",
          "968:  case 'w': { // \"?w\"",
          "969:   ut64 addr = r_num_math (core->num, input + 1);",
          "971:   r_cons_println (rstr);",
          "972:   break;",
          "973:  }",
          "974:  case 't': { // \"?t\"",
          "",
          "[Removed Lines]",
          "970:   const char *rstr = core->print->hasrefs (core->print->user, addr, true);",
          "",
          "[Added Lines]",
          "970:   char *rstr = core->print->hasrefs (core->print->user, addr, true);",
          "971:   if (!rstr) {",
          "972:    eprintf (\"Cannot get refs\\n\");",
          "973:    break;",
          "974:   }",
          "976:   free (rstr);",
          "",
          "---------------"
        ],
        "libr/core/cmd_print.c||libr/core/cmd_print.c": [
          "File: libr/core/cmd_print.c -> libr/core/cmd_print.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5367:       withref = 0;",
          "5368:       if (core->print->hasrefs) {",
          "5370:        if (rstr && *rstr) {",
          "5374:         free (ns);",
          "5375:         withref = 1;",
          "5376:        }",
          "5377:       }",
          "5378:       if (!withref) {",
          "5379:        r_cons_printf (\"}\");",
          "",
          "[Removed Lines]",
          "5369:        const char *rstr = core->print->hasrefs (core->print->user, val, true);",
          "5371:         char *ns; // r_str_ansi_trim (ns, -1, 0);",
          "5372:         ns = r_str_escape (rstr);",
          "5373:         r_cons_printf (\",\\\"ref\\\":\\\"%s\\\"}\", *ns == ' '? ns + 1: ns);",
          "",
          "[Added Lines]",
          "5369:        char *rstr = core->print->hasrefs (core->print->user, val, true);",
          "5371:         char *ns = r_str_escape (rstr);",
          "5372:         r_cons_printf (\",\\\"ref\\\":\\\"%s\\\"}\", *ns == ' ' ? ns + 1 : ns);",
          "5376:        free (rstr);",
          "",
          "---------------"
        ],
        "libr/core/core.c||libr/core/core.c": [
          "File: libr/core/core.c -> libr/core/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2170:  }",
          "2171: }",
          "2173: R_API bool r_core_init(RCore *core) {",
          "2174:  core->blocksize = R_CORE_BLOCKSIZE;",
          "2176:  if (!core->block) {",
          "2177:   eprintf (\"Cannot allocate %d byte(s)\\n\", R_CORE_BLOCKSIZE);",
          "",
          "[Removed Lines]",
          "2175:  core->block = (ut8*)calloc (R_CORE_BLOCKSIZE + 1, 1);",
          "",
          "[Added Lines]",
          "2173: static const char *colorfor_cb(void *user, ut64 addr, bool verbose) {",
          "2174:  return r_core_anal_optype_colorfor ((RCore *)user, addr, verbose);",
          "2175: }",
          "2177: static char *hasrefs_cb(void *user, ut64 addr, bool verbose) {",
          "2178:  return r_core_anal_hasrefs ((RCore *)user, addr, verbose);",
          "2179: }",
          "2181: static char *get_comments_cb(void *user, ut64 addr) {",
          "2182:  return r_core_anal_get_comments ((RCore *)user, addr);",
          "2183: }",
          "2187:  core->block = (ut8 *)calloc (R_CORE_BLOCKSIZE + 1, 1);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2200:  core->print->write = mywrite;",
          "2201:  core->print->exists_var = exists_var;",
          "2202:  core->print->disasm = __disasm;",
          "2206:  core->print->use_comments = false;",
          "2207:  core->rtr_n = 0;",
          "2208:  core->blocksize_max = R_CORE_BLOCKSIZE_MAX;",
          "",
          "[Removed Lines]",
          "2203:  core->print->colorfor = (RPrintColorFor)r_core_anal_optype_colorfor;",
          "2204:  core->print->hasrefs = (RPrintColorFor)r_core_anal_hasrefs;",
          "2205:  core->print->get_comments = (RPrintCommentCallback) r_core_anal_get_comments;",
          "",
          "[Added Lines]",
          "2215:  core->print->colorfor = colorfor_cb;",
          "2216:  core->print->hasrefs = hasrefs_cb;",
          "2217:  core->print->get_comments = get_comments_cb;",
          "",
          "---------------"
        ],
        "libr/egg/egg.c||libr/egg/egg.c": [
          "File: libr/egg/egg.c -> libr/egg/egg.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "519:    r_egg_append_bytes (egg, b->buf, b->length);",
          "520:   } else {",
          "524:     return;",
          "525:    }",
          "526:    memcpy (egg->bin->buf + b->cur, b->buf, b->length);",
          "",
          "[Removed Lines]",
          "522:    if (b->length+b->cur > egg->bin->length) {",
          "523:     eprintf (\"Fuck this shit. Cannot patch outside\\n\");",
          "",
          "[Added Lines]",
          "522:    if (b->length + b->cur > egg->bin->length) {",
          "523:     eprintf (\"Cannot patch outside\\n\");",
          "",
          "---------------"
        ],
        "libr/include/r_print.h||libr/include/r_print.h": [
          "File: libr/include/r_print.h -> libr/include/r_print.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: typedef const char *(*RPrintNameCallback)(void *user, ut64 addr);",
          "32: typedef char *(*RPrintCommentCallback)(void *user, ut64 addr);",
          "33: typedef const char *(*RPrintColorFor)(void *user, ut64 addr, bool verbose);",
          "35: typedef struct r_print_zoom_t {",
          "36:  ut8 *buf;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "34: typedef char *(*RPrintHasRefs)(void *user, ut64 addr, bool verbose);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "75:  RPrintZoom *zoom;",
          "76:  RPrintNameCallback offname;",
          "77:  RPrintColorFor colorfor;",
          "79:  RPrintCommentCallback get_comments;",
          "80:  Sdb *formats;",
          "81:  Sdb *sdb_types;",
          "",
          "[Removed Lines]",
          "78:  RPrintColorFor hasrefs;",
          "",
          "[Added Lines]",
          "79:  RPrintHasRefs hasrefs;",
          "",
          "---------------"
        ],
        "libr/util/list.c||libr/util/list.c": [
          "File: libr/util/list.c -> libr/util/list.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "10:  return calloc (1, sizeof (RListIter));",
          "11: }",
          "15: }",
          "19: }",
          "23: }",
          "27: }",
          "30:  return r_list_append (list, item);",
          "31: }",
          "35: }",
          "42: }",
          "44: R_API void r_list_init(RList *list) {",
          "",
          "[Removed Lines]",
          "13: void r_list_iter_free(RListIter *list) {",
          "17: RListIter *r_list_iter_get_next(RListIter *list) {",
          "18:  return list ? list->n : NULL;",
          "21: void *r_list_iter_get_data(RListIter *list) {",
          "22:  return list? list->data : NULL;",
          "25: RListIter *r_list_iterator(const RList *list) {",
          "26:  return list? list->head: NULL;",
          "29: RListIter *r_list_push(RList *list, void *item) {",
          "33: RListIter *r_list_get_next(RListIter *list) {",
          "34:  return list ? list->n : NULL;",
          "37: R_API void* r_list_first(const RList *list) {",
          "38:  if (list && list->head) {",
          "39:   return list->head->data;",
          "40:  }",
          "41:  return NULL;",
          "",
          "[Added Lines]",
          "13: R_API void r_list_iter_free(RListIter *list) {",
          "17: R_API RListIter *r_list_iter_get_next(RListIter *list) {",
          "18:  r_return_val_if_fail (list, NULL);",
          "19:  return list->n;",
          "22: R_API void *r_list_iter_get_data(RListIter *list) {",
          "23:  r_return_val_if_fail (list, NULL);",
          "24:  return list->data;",
          "27: R_API RListIter *r_list_iterator(const RList *list) {",
          "28:  r_return_val_if_fail (list, NULL);",
          "29:  return list->head;",
          "32: R_API RListIter *r_list_push(RList *list, void *item) {",
          "36: R_API RListIter *r_list_get_next(RListIter *list) {",
          "37:  r_return_val_if_fail (list, NULL);",
          "38:  return list->n;",
          "41: R_API void *r_list_first(const RList *list) {",
          "42:  r_return_val_if_fail (list, NULL);",
          "43:  return list->head ? list->head->data : NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "50: }",
          "52: R_API int r_list_length(const RList *list) {",
          "54: }",
          "57: R_API void r_list_purge(RList *list) {",
          "66:  }",
          "67: }",
          "",
          "[Removed Lines]",
          "53:  return list? list->length : 0;",
          "58:  if (list) {",
          "59:   RListIter *it = list->head;",
          "60:   while (it) {",
          "61:    RListIter *next = it->n;",
          "62:    r_list_delete (list, it);",
          "63:    it = next;",
          "64:   }",
          "65:   list->head = list->tail = NULL;",
          "",
          "[Added Lines]",
          "55:  r_return_val_if_fail (list, 0);",
          "56:  return list->length;",
          "61:  RListIter *it;",
          "63:  r_return_if_fail (list);",
          "65:  it = list->head;",
          "66:  while (it) {",
          "67:   RListIter *next = it->n;",
          "68:   r_list_delete (list, it);",
          "69:   it = next;",
          "71:  list->head = list->tail = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "77: R_API bool r_list_delete_data(RList *list, void *ptr) {",
          "78:  void *p;",
          "79:  RListIter *iter;",
          "80:  r_list_foreach (list, iter, p) {",
          "81:   if (ptr == p) {",
          "82:    r_list_delete (list, iter);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "86:  r_return_val_if_fail (list, false);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "87: }",
          "89: R_API void r_list_delete(RList *list, RListIter *iter) {",
          "97:  }",
          "98: }",
          "100: R_API void r_list_split(RList *list, void *ptr) {",
          "111:   }",
          "112:  }",
          "113: }",
          "115: R_API void r_list_split_iter(RList *list, RListIter *iter) {",
          "116:  if (list->head == iter) {",
          "117:   list->head = iter->n;",
          "118:  }",
          "",
          "[Removed Lines]",
          "90:  if (list && iter) {",
          "91:   r_list_split_iter (list, iter);",
          "92:   if (list->free && iter->data) {",
          "93:    list->free (iter->data);",
          "94:   }",
          "95:   iter->data = NULL;",
          "96:   R_FREE (iter);",
          "101:  if (list) {",
          "102:   RListIter *iter = r_list_iterator (list);",
          "103:   while (iter) {",
          "104:    void *item = iter->data;",
          "105:    if (ptr == item) {",
          "106:     r_list_split_iter (list, iter);",
          "107:     free (iter);",
          "108:     break;",
          "109:    }",
          "110:    iter = iter->n;",
          "",
          "[Added Lines]",
          "98:  r_return_if_fail (list && iter);",
          "99:  r_list_split_iter (list, iter);",
          "100:  if (list->free && iter->data) {",
          "101:   list->free (iter->data);",
          "103:  iter->data = NULL;",
          "104:  R_FREE (iter);",
          "108:  RListIter *iter;",
          "110:  r_return_if_fail (list);",
          "112:  iter = r_list_iterator (list);",
          "113:  while (iter) {",
          "114:   void *item = iter->data;",
          "115:   if (ptr == item) {",
          "116:    r_list_split_iter (list, iter);",
          "117:    free (iter);",
          "118:    break;",
          "120:   iter = iter->n;",
          "125:  r_return_if_fail (list);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "132: R_API int r_list_join(RList *list1, RList *list2) {",
          "136:  if (!(list2->length)) {",
          "137:   return 0;",
          "138:  }",
          "",
          "[Removed Lines]",
          "133:  if (!list1 || !list2) {",
          "134:   return 0;",
          "135:  }",
          "",
          "[Added Lines]",
          "144:  r_return_val_if_fail (list1 && list2, 0);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "180: R_API RListIter *r_list_append(RList *list, void *data) {",
          "181:  RListIter *item = NULL;",
          "199:  }",
          "200:  return item;",
          "201: }",
          "203: R_API RListIter *r_list_prepend(RList *list, void *data) {",
          "222:  }",
          "224: }",
          "226: R_API RListIter *r_list_insert(RList *list, int n, void *data) {",
          "227:  RListIter *it, *item;",
          "228:  int i;",
          "249:    }",
          "250:   }",
          "251:  }",
          "252:  return r_list_append (list, data);",
          "",
          "[Removed Lines]",
          "182:  if (list && data) {",
          "183:   item = R_NEW (RListIter);",
          "184:   if (!item) {",
          "185:    return item;",
          "186:   }",
          "187:   if (list->tail) {",
          "188:    list->tail->n = item;",
          "189:   }",
          "190:   item->data = data;",
          "191:   item->p = list->tail;",
          "192:   item->n = NULL;",
          "193:   list->tail = item;",
          "194:   if (!list->head) {",
          "195:    list->head = item;",
          "196:   }",
          "197:   list->length++;",
          "198:   list->sorted = false;",
          "204:  if (list) {",
          "205:   RListIter *item = R_NEW0 (RListIter);",
          "206:   if (!item) {",
          "207:    return NULL;",
          "208:   }",
          "209:   if (list->head) {",
          "210:    list->head->p = item;",
          "211:   }",
          "212:   item->data = data;",
          "213:   item->n = list->head;",
          "214:   item->p = NULL;",
          "215:   list->head = item;",
          "216:   if (!list->tail) {",
          "217:    list->tail = item;",
          "218:   }",
          "219:   list->length++;",
          "220:   list->sorted = true;",
          "221:   return item;",
          "223:  return NULL;",
          "229:  if (list) {",
          "230:   if (!list->head || !n) {",
          "231:    return r_list_prepend (list, data);",
          "232:   }",
          "233:   for (it = list->head, i = 0; it && it->data; it = it->n, i++) {",
          "234:    if (i == n) {",
          "235:     item = R_NEW (RListIter);",
          "236:     if (!item) {",
          "237:      return NULL;",
          "238:     }",
          "239:     item->data = data;",
          "240:     item->n = it;",
          "241:     item->p = it->p;",
          "242:     if (it->p) {",
          "243:      it->p->n = item;",
          "244:     }",
          "245:     it->p = item;",
          "246:     list->length++;",
          "247:     list->sorted = true;",
          "248:     return item;",
          "",
          "[Added Lines]",
          "193:  r_return_val_if_fail (list && data, NULL);",
          "195:  item = R_NEW (RListIter);",
          "196:  if (!item) {",
          "197:   return item;",
          "198:  }",
          "199:  if (list->tail) {",
          "200:   list->tail->n = item;",
          "201:  }",
          "202:  item->data = data;",
          "203:  item->p = list->tail;",
          "204:  item->n = NULL;",
          "205:  list->tail = item;",
          "206:  if (!list->head) {",
          "207:   list->head = item;",
          "209:  list->length++;",
          "210:  list->sorted = false;",
          "215:  RListIter *item;",
          "217:  r_return_val_if_fail (list, NULL);",
          "219:  item = R_NEW0 (RListIter);",
          "220:  if (!item) {",
          "221:   return NULL;",
          "223:  if (list->head) {",
          "224:   list->head->p = item;",
          "225:  }",
          "226:  item->data = data;",
          "227:  item->n = list->head;",
          "228:  item->p = NULL;",
          "229:  list->head = item;",
          "230:  if (!list->tail) {",
          "231:   list->tail = item;",
          "232:  }",
          "233:  list->length++;",
          "234:  list->sorted = true;",
          "235:  return item;",
          "242:  r_return_val_if_fail (list, NULL);",
          "244:  if (!list->head || !n) {",
          "245:   return r_list_prepend (list, data);",
          "246:  }",
          "247:  for (it = list->head, i = 0; it && it->data; it = it->n, i++) {",
          "248:   if (i == n) {",
          "249:    item = R_NEW (RListIter);",
          "250:    if (!item) {",
          "251:     return NULL;",
          "253:    item->data = data;",
          "254:    item->n = it;",
          "255:    item->p = it->p;",
          "256:    if (it->p) {",
          "257:     it->p->n = item;",
          "258:    }",
          "259:    it->p = item;",
          "260:    list->length++;",
          "261:    list->sorted = true;",
          "262:    return item;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "255: R_API void *r_list_pop(RList *list) {",
          "256:  void *data = NULL;",
          "257:  RListIter *iter;",
          "269:   }",
          "272:  }",
          "274: }",
          "276: R_API void *r_list_pop_head(RList *list) {",
          "277:  void *data = NULL;",
          "278:  RListIter *iter;",
          "290:   }",
          "293:  }",
          "295: }",
          "297: R_API int r_list_del_n(RList *list, int n) {",
          "298:  RListIter *it;",
          "299:  int i;",
          "303:  for (it = list->head, i = 0; it && it->data; it = it->n, i++) {",
          "304:   if (i == n) {",
          "305:    if (!it->p && !it->n) {",
          "",
          "[Removed Lines]",
          "258:  if (list) {",
          "259:   if (list->tail) {",
          "260:    iter = list->tail;",
          "261:    if (list->head == list->tail) {",
          "262:     list->head = list->tail = NULL;",
          "263:    } else {",
          "264:     list->tail = iter->p;",
          "265:     list->tail->n = NULL;",
          "266:    }",
          "267:    data = iter->data;",
          "268:    free (iter);",
          "270:   list->length--;",
          "271:   return data;",
          "273:  return NULL;",
          "279:  if (list) {",
          "280:   if (list->head) {",
          "281:    iter = list->head;",
          "282:    if (list->head == list->tail) {",
          "283:     list->head = list->tail = NULL;",
          "284:    } else {",
          "285:     list->head = iter->n;",
          "286:     list->head->p = NULL;",
          "287:    }",
          "288:    data = iter->data;",
          "289:    free (iter);",
          "291:   list->length--;",
          "292:   return data;",
          "294:  return NULL;",
          "300:  if (!list) {",
          "301:   return false;",
          "302:  }",
          "",
          "[Added Lines]",
          "272:  r_return_val_if_fail (list, NULL);",
          "274:  if (list->tail) {",
          "275:   iter = list->tail;",
          "276:   if (list->head == list->tail) {",
          "277:    list->head = list->tail = NULL;",
          "278:   } else {",
          "279:    list->tail = iter->p;",
          "280:    list->tail->n = NULL;",
          "282:   data = iter->data;",
          "283:   free (iter);",
          "285:  list->length--;",
          "286:  return data;",
          "293:  r_return_val_if_fail (list, NULL);",
          "295:  if (list->head) {",
          "296:   iter = list->head;",
          "297:   if (list->head == list->tail) {",
          "298:    list->head = list->tail = NULL;",
          "299:   } else {",
          "300:    list->head = iter->n;",
          "301:    list->head->p = NULL;",
          "303:   data = iter->data;",
          "304:   free (iter);",
          "306:  list->length--;",
          "307:  return data;",
          "314:  r_return_val_if_fail (list, false);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "323: }",
          "325: R_API void *r_list_get_top(const RList *list) {",
          "330: }",
          "332: R_API void *r_list_get_bottom(const RList *list) {",
          "337: }",
          "339: R_API void r_list_reverse(RList *list) {",
          "340:  RListIter *it, *tmp;",
          "350:  }",
          "351: }",
          "353: R_API RList *r_list_clone(RList *list) {",
          "",
          "[Removed Lines]",
          "326:  if (list && list->tail) {",
          "327:   return list->tail->data;",
          "328:  }",
          "329:  return NULL;",
          "333:  if (list && list->head) {",
          "334:   return list->head->data;",
          "335:  }",
          "336:  return NULL;",
          "341:  if (list) {",
          "342:   for (it = list->head; it && it->data; it = it->p) {",
          "343:    tmp = it->p;",
          "344:    it->p = it->n;",
          "345:    it->n = tmp;",
          "346:   }",
          "347:   tmp = list->head;",
          "348:   list->head = list->tail;",
          "349:   list->tail = tmp;",
          "",
          "[Added Lines]",
          "339:  r_return_val_if_fail (list, NULL);",
          "341:  return list->tail ? list->tail->data : NULL;",
          "345:  r_return_val_if_fail (list, NULL);",
          "347:  return list->head ? list->head->data : NULL;",
          "353:  r_return_if_fail (list);",
          "355:  for (it = list->head; it && it->data; it = it->p) {",
          "356:   tmp = it->p;",
          "357:   it->p = it->n;",
          "358:   it->n = tmp;",
          "360:  tmp = list->head;",
          "361:  list->head = list->tail;",
          "362:  list->tail = tmp;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "355:  RListIter *iter;",
          "356:  void *data;",
          "368:  }",
          "369:  return l;",
          "370: }",
          "372: R_API RListIter *r_list_add_sorted(RList *list, void *data, RListComparator cmp) {",
          "373:  RListIter *it, *item = NULL;",
          "377:   }",
          "393:   } else {",
          "395:   }",
          "398:  }",
          "400: }",
          "402: R_API int r_list_set_n(RList *list, int n, void *p) {",
          "403:  RListIter *it;",
          "404:  int i;",
          "414:    }",
          "415:   }",
          "416:  }",
          "417:  return false;",
          "",
          "[Removed Lines]",
          "358:  if (list) {",
          "359:   l = r_list_new ();",
          "360:   if (!l) {",
          "361:    return NULL;",
          "362:   }",
          "363:   l->free = NULL;",
          "364:   r_list_foreach (list, iter, data) {",
          "365:    r_list_append (l, data);",
          "366:   }",
          "367:   l->sorted = list->sorted;",
          "374:  if (list && data && cmp) {",
          "375:   for (it = list->head; it && it->data && cmp (data, it->data) > 0; it = it->n) {",
          "376:    ;",
          "378:   if (it) {",
          "379:    item = R_NEW0 (RListIter);",
          "380:    if (!item) {",
          "381:     return NULL;",
          "382:    }",
          "383:    item->n = it;",
          "384:    item->p = it->p;",
          "385:    item->data = data;",
          "386:    item->n->p = item;",
          "387:    if (!item->p) {",
          "388:     list->head = item;",
          "389:    } else {",
          "390:     item->p->n = item;",
          "391:    }",
          "392:    list->length++;",
          "394:    r_list_append (list, data);",
          "396:   list->sorted = true;",
          "397:   return item;",
          "399:  return NULL;",
          "405:  if (list) {",
          "406:   for (it = list->head, i = 0; it && it->data; it = it->n, i++) {",
          "407:    if (i == n) {",
          "408:     if (list->free) {",
          "409:      list->free (it->data);",
          "410:     }",
          "411:     it->data = p;",
          "412:     list->sorted = false;",
          "413:     return true;",
          "",
          "[Added Lines]",
          "370:  r_return_val_if_fail (list, NULL);",
          "372:  l = r_list_new ();",
          "373:  if (!l) {",
          "374:   return NULL;",
          "375:  }",
          "376:  l->free = NULL;",
          "377:  r_list_foreach (list, iter, data) {",
          "378:   r_list_append (l, data);",
          "380:  l->sorted = list->sorted;",
          "387:  r_return_val_if_fail (list && data && cmp, NULL);",
          "389:  for (it = list->head; it && it->data && cmp (data, it->data) > 0; it = it->n) {",
          "390:   ;",
          "391:  }",
          "392:  if (it) {",
          "393:   item = R_NEW0 (RListIter);",
          "394:   if (!item) {",
          "395:    return NULL;",
          "397:   item->n = it;",
          "398:   item->p = it->p;",
          "399:   item->data = data;",
          "400:   item->n->p = item;",
          "401:   if (!item->p) {",
          "402:    list->head = item;",
          "404:    item->p->n = item;",
          "406:   list->length++;",
          "407:  } else {",
          "408:   r_list_append (list, data);",
          "410:  list->sorted = true;",
          "411:  return item;",
          "418:  r_return_val_if_fail (list, false);",
          "419:  for (it = list->head, i = 0; it && it->data; it = it->n, i++) {",
          "420:   if (i == n) {",
          "421:    if (list->free) {",
          "422:     list->free (it->data);",
          "424:    it->data = p;",
          "425:    list->sorted = false;",
          "426:    return true;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "420: R_API void *r_list_get_n(const RList *list, int n) {",
          "421:  RListIter *it;",
          "422:  int i;",
          "428:   }",
          "429:  }",
          "430:  return NULL;",
          "",
          "[Removed Lines]",
          "423:  if (list) {",
          "424:   for (it = list->head, i = 0; it && it->data; it = it->n, i++) {",
          "425:    if (i == n) {",
          "426:     return it->data;",
          "427:    }",
          "",
          "[Added Lines]",
          "436:  r_return_val_if_fail (list, NULL);",
          "438:  for (it = list->head, i = 0; it && it->data; it = it->n, i++) {",
          "439:   if (i == n) {",
          "440:    return it->data;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "433: R_API RListIter *r_list_contains(const RList *list, const void *p) {",
          "434:  void *q;",
          "435:  RListIter *iter;",
          "436:  r_list_foreach (list, iter, q) {",
          "437:   if (p == q) {",
          "438:    return iter;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "450:  r_return_val_if_fail (list, NULL);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "444: R_API RListIter *r_list_find(const RList *list, const void *p, RListComparator cmp) {",
          "445:  void *q;",
          "446:  RListIter *iter;",
          "447:  r_list_foreach (list, iter, q) {",
          "448:   if (!cmp (p, q)) {",
          "449:    return iter;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "464:  r_return_val_if_fail (list, NULL);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "513: }",
          "515: R_API void r_list_merge_sort(RList *list, RListComparator cmp) {",
          "519:  if (!list->sorted && list->head && cmp) {",
          "520:   RListIter *iter;",
          "521:   list->head = _merge_sort (list->head, cmp);",
          "",
          "[Removed Lines]",
          "516:  if (!list) {",
          "517:   return;",
          "518:  }",
          "",
          "[Added Lines]",
          "535:  r_return_if_fail (list);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "530: }",
          "532: R_API void r_list_insertion_sort(RList *list, RListComparator cmp) {",
          "534:   RListIter *it;",
          "535:   RListIter *it2;",
          "536:   if (cmp) {",
          "",
          "[Removed Lines]",
          "533:  if (list && !list->sorted) {",
          "",
          "[Added Lines]",
          "551:  r_return_if_fail (list);",
          "553:  if (!list->sorted) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "552: R_API void r_list_sort(RList *list, RListComparator cmp) {",
          "559:  }",
          "560: }",
          "562: R_API RList *r_list_uniq(const RList *list, RListComparator cmp) {",
          "563:  RListIter *iter, *iter2;",
          "564:  void *item, *item2;",
          "568:  RList *nl = r_list_newf (NULL);",
          "569:  if (!nl) {",
          "570:   return NULL;",
          "",
          "[Removed Lines]",
          "553:  if (list) {",
          "554:   if (list->length > 43) {",
          "555:    r_list_merge_sort (list, cmp);",
          "556:   } else {",
          "557:    r_list_insertion_sort (list, cmp);",
          "558:   }",
          "565:  if (!list || !cmp) {",
          "566:   return NULL;",
          "567:  }",
          "",
          "[Added Lines]",
          "573:  r_return_if_fail (list);",
          "574:  if (list->length > 43) {",
          "575:   r_list_merge_sort (list, cmp);",
          "576:  } else {",
          "577:   r_list_insertion_sort (list, cmp);",
          "585:  r_return_val_if_fail (list && cmp, NULL);",
          "",
          "---------------"
        ],
        "libr/util/print.c||libr/util/print.c": [
          "File: libr/util/print.c -> libr/util/print.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1043:     off &= UT32_MAX;",
          "1044:    }",
          "1045:    if (p->hasrefs) {",
          "1047:     if (rstr && *rstr) {",
          "1048:      printfmt (\" @%s\", rstr);",
          "1049:     }",
          "1050:     rstr = p->hasrefs (p->user, off, true);",
          "1051:     if (rstr && *rstr) {",
          "1052:      printfmt (\"%s\", rstr);",
          "1053:     }",
          "1054:    }",
          "1055:   }",
          "1056:   if (p && p->use_comments) {",
          "",
          "[Removed Lines]",
          "1046:     const char *rstr = p->hasrefs (p->user, addr + i, false);",
          "",
          "[Added Lines]",
          "1046:     char *rstr = p->hasrefs (p->user, addr + i, false);",
          "1050:     free (rstr);",
          "1055:     free (rstr);",
          "",
          "---------------"
        ],
        "libr/util/strbuf.c||libr/util/strbuf.c": [
          "File: libr/util/strbuf.c -> libr/util/strbuf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: }",
          "22: R_API int r_strbuf_length(RStrBuf *sb) {",
          "24: }",
          "26: R_API void r_strbuf_init(RStrBuf *sb) {",
          "27:  memset (sb, 0, sizeof (RStrBuf));",
          "28: }",
          "30: R_API bool r_strbuf_setbin(RStrBuf *sb, const ut8 *s, int l) {",
          "31:  if (l >= sizeof (sb->buf)) {",
          "32:   char *ptr = sb->ptr;",
          "33:   if (!ptr || l + 1 > sb->ptrlen) {",
          "",
          "[Removed Lines]",
          "23:  return sb? sb->len: 0;",
          "",
          "[Added Lines]",
          "23:  r_return_val_if_fail (sb, 0);",
          "24:  return sb->len;",
          "28:  r_return_if_fail (sb);",
          "33:  r_return_val_if_fail (sb && s, false);",
          "34:  r_return_val_if_fail (l >= 0, false);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "53: }",
          "55: R_API bool r_strbuf_set(RStrBuf *sb, const char *s) {",
          "59:  if (!s) {",
          "60:   r_strbuf_init (sb);",
          "61:   return true;",
          "",
          "[Removed Lines]",
          "56:  if (!sb) {",
          "57:   return false;",
          "58:  }",
          "",
          "[Added Lines]",
          "61:  r_return_val_if_fail (sb, false);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "67:  bool ret;",
          "68:  va_list ap;",
          "73:  va_start (ap, fmt);",
          "74:  ret = r_strbuf_vsetf (sb, fmt, ap);",
          "75:  va_end (ap);",
          "",
          "[Removed Lines]",
          "70:  if (!sb || !fmt) {",
          "71:   return false;",
          "72:  }",
          "",
          "[Added Lines]",
          "74:  r_return_val_if_fail (sb && fmt, false);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "82:  va_list ap2;",
          "83:  char string[1024];",
          "85:  va_copy (ap2, ap);",
          "86:  rc = vsnprintf (string, sizeof (string), fmt, ap);",
          "87:  if (rc >= sizeof (string)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "88:  r_return_val_if_fail (sb && fmt, false);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "104: }",
          "106: R_API int r_strbuf_append(RStrBuf *sb, const char *s) {",
          "107:  int l = strlen (s);",
          "108:  return r_strbuf_append_n (sb, s, l);",
          "109: }",
          "111: R_API int r_strbuf_append_n(RStrBuf *sb, const char *s, int l) {",
          "114:  }",
          "115:  if ((sb->len + l + 1) <= sizeof (sb->buf)) {",
          "116:   memcpy (sb->buf + sb->len, s, l);",
          "117:   sb->buf[sb->len + l] = 0;",
          "",
          "[Removed Lines]",
          "112:  if (l < 1) {",
          "113:   return false;",
          "",
          "[Added Lines]",
          "112:  r_return_val_if_fail (sb && s, false);",
          "119:  r_return_val_if_fail (sb, false);",
          "120:  r_return_val_if_fail (s && l >= 0, false);",
          "123:  if (l == 0) {",
          "124:   return true;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "148:  int ret;",
          "149:  va_list ap;",
          "151:  va_start (ap, fmt);",
          "152:  ret = r_strbuf_vappendf (sb, fmt, ap);",
          "153:  va_end (ap);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "163:  r_return_val_if_fail (sb && fmt, -1);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "159:  va_list ap2;",
          "160:  char string[1024];",
          "162:  va_copy (ap2, ap);",
          "163:  ret = vsnprintf (string, sizeof (string), fmt, ap);",
          "164:  if (ret >= sizeof (string)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "176:  r_return_val_if_fail (sb && fmt, -1);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "181: }",
          "183: R_API char *r_strbuf_get(RStrBuf *sb) {",
          "185: }",
          "187: R_API ut8 *r_strbuf_getbin(RStrBuf *sb, int *len) {",
          "193:  }",
          "195: }",
          "197: R_API char *r_strbuf_drain(RStrBuf *sb) {",
          "203:  return ret;",
          "204: }",
          "",
          "[Removed Lines]",
          "184:  return sb? (sb->ptr? sb->ptr: sb->buf) : NULL;",
          "188:  if (sb) {",
          "189:   if (len) {",
          "191:   }",
          "192:   return (ut8*)(sb->ptr? sb->ptr: sb->buf);",
          "194:  return NULL;",
          "198:  char *ret = NULL;",
          "199:  if (sb) {",
          "200:   ret = sb->ptr? sb->ptr: strdup (sb->buf);",
          "201:   free (sb);",
          "202:  }",
          "",
          "[Added Lines]",
          "200:  r_return_val_if_fail (sb, NULL);",
          "201:  return sb->ptr ? sb->ptr : sb->buf;",
          "205:  r_return_val_if_fail (sb, NULL);",
          "206:  if (len) {",
          "209:  return (ut8 *)(sb->ptr ? sb->ptr : sb->buf);",
          "213:  r_return_val_if_fail (sb, NULL);",
          "215:  char *ret = sb->ptr ? sb->ptr : strdup (sb->buf);",
          "216:  free (sb);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cc30a38cc0b81e9e4f4f73c46957f998f7bdf601",
      "candidate_info": {
        "commit_hash": "cc30a38cc0b81e9e4f4f73c46957f998f7bdf601",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/cc30a38cc0b81e9e4f4f73c46957f998f7bdf601",
        "files": [
          "libr/bin/p/bin_any.c",
          "libr/bin/p/bin_elf.c",
          "libr/bin/p/bin_mz.c",
          "libr/core/cbin.c",
          "libr/include/r_bin.h"
        ],
        "message": "Detects OpenBSD cookie protection for functions which is added with .openbsd.randomdata elf section. (#10967)",
        "before_after_code_files": [
          "libr/bin/p/bin_any.c||libr/bin/p/bin_any.c",
          "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c",
          "libr/bin/p/bin_mz.c||libr/bin/p/bin_mz.c",
          "libr/core/cbin.c||libr/core/cbin.c",
          "libr/include/r_bin.h||libr/include/r_bin.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c",
            "libr/core/cbin.c||libr/core/cbin.c"
          ],
          "candidate": [
            "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c",
            "libr/core/cbin.c||libr/core/cbin.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/p/bin_any.c||libr/bin/p/bin_any.c": [
          "File: libr/bin/p/bin_any.c -> libr/bin/p/bin_any.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "42:  ret->type = get_filetype (bf);",
          "43:  ret->has_pi = 0;",
          "44:  ret->has_canary = 0;",
          "45:  if (R_SYS_BITS & R_SYS_BITS_64) {",
          "46:   ret->bits = 64;",
          "47:  } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "45:  ret->has_retguard = -1;",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c": [
          "File: libr/bin/p/bin_elf.c -> libr/bin/p/bin_elf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1034:  return ret;",
          "1035: }",
          "1037: static RBinInfo* info(RBinFile *bf) {",
          "1038:  RBinInfo *ret = NULL;",
          "1039:  char *str;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1037: static int has_retguard(RBinFile *bf) {",
          "1038:  int ret = -1;",
          "1039:  RList* sections_list = sections (bf);",
          "1040:  RListIter *iter;",
          "1041:  RBinSection *section;",
          "1042:  r_list_foreach (sections_list, iter, section) {",
          "1043:   # define R_BIN_RANDOMDATA_RETGUARD_SZ 48",
          "1044:   if (!strcmp (section->name, \".openbsd.randomdata\")) {",
          "1046:    ret = (section->size >= R_BIN_RANDOMDATA_RETGUARD_SZ);",
          "1047:    break;",
          "1048:   }",
          "1049:  }",
          "1050:  r_list_free (sections_list);",
          "1051:  return ret;",
          "1052: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1060:  ret->has_pi = (strstr (str, \"DYN\"))? 1: 0;",
          "1061:  ret->has_lit = true;",
          "1062:  ret->has_canary = has_canary (bf);",
          "1063:  if (!(str = Elf_(r_bin_elf_get_elf_class) (obj))) {",
          "1064:   free (ret);",
          "1065:   return NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1080:  ret->has_retguard = has_retguard (bf);",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_mz.c||libr/bin/p/bin_mz.c": [
          "File: libr/bin/p/bin_mz.c -> libr/bin/p/bin_mz.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "194:  ret->big_endian = false;",
          "195:  ret->has_crypto = false;",
          "196:  ret->has_canary = false;",
          "197:  ret->has_nx = false;",
          "198:  ret->has_pi = false;",
          "199:  ret->has_va = false;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "197:  ret->has_retguard = -1;",
          "",
          "---------------"
        ],
        "libr/core/cbin.c||libr/core/cbin.c": [
          "File: libr/core/cbin.c -> libr/core/cbin.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "713:   pair_str (\"bintype\", info->rclass, mode, false);",
          "714:   pair_int (\"bits\", info->bits, mode, false);",
          "715:   pair_bool (\"canary\", info->has_canary, mode, false);",
          "716:   pair_str (\"class\", info->bclass, mode, false);",
          "717:   if (info->actual_checksum) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "716:   if (info->has_retguard != -1) {",
          "717:    pair_bool (\"retguard\", info->has_retguard, mode, false);",
          "718:   }",
          "",
          "---------------"
        ],
        "libr/include/r_bin.h||libr/include/r_bin.h": [
          "File: libr/include/r_bin.h -> libr/include/r_bin.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "203:  int has_va;",
          "204:  int has_pi; // pic/pie",
          "205:  int has_canary;",
          "206:  int has_crypto;",
          "207:  int has_nx;",
          "208:  int big_endian;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "206:  int has_retguard;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e7de8b082f715766f8b3769ad8f3e4f824f7fc88",
      "candidate_info": {
        "commit_hash": "e7de8b082f715766f8b3769ad8f3e4f824f7fc88",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/e7de8b082f715766f8b3769ad8f3e4f824f7fc88",
        "files": [
          "libr/bin/p/bin_cgc.c",
          "libr/bin/p/bin_elf.c",
          "libr/bin/p/bin_elf.inc",
          "libr/bin/p/bin_elf64.c"
        ],
        "message": "Extract bin_elf.c common parts to bin_elf.inc and #include bin_elf.inc instead of bin_elf.c",
        "before_after_code_files": [
          "libr/bin/p/bin_cgc.c||libr/bin/p/bin_cgc.c",
          "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c",
          "libr/bin/p/bin_elf.inc||libr/bin/p/bin_elf.inc",
          "libr/bin/p/bin_elf64.c||libr/bin/p/bin_elf64.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c"
          ],
          "candidate": [
            "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/p/bin_cgc.c||libr/bin/p/bin_cgc.c": [
          "File: libr/bin/p/bin_cgc.c -> libr/bin/p/bin_cgc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: #define R_BIN_CGC 1",
          "12: extern struct r_bin_dbginfo_t r_bin_dbginfo_elf;",
          "13: extern struct r_bin_write_t r_bin_write_elf;",
          "",
          "[Removed Lines]",
          "3: #include <stdio.h>",
          "4: #include <r_types.h>",
          "5: #include <r_util.h>",
          "6: #include <r_lib.h>",
          "7: #include <r_bin.h>",
          "10: #include \"bin_elf.c\"",
          "",
          "[Added Lines]",
          "4: #include \"bin_elf.inc\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "104:  .get_sdb = &get_sdb,",
          "105:  .load = &load,",
          "106:  .load_bytes = &load_bytes,",
          "107:  .destroy = &destroy,",
          "108:  .check_bytes = &check_bytes,",
          "109:  .baddr = &baddr,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "101:  .load_buffer= load_buffer,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "123:  .create = &create,",
          "124:  .patch_relocs = &patch_relocs,",
          "125:  .write = &r_bin_write_elf,",
          "126: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "121:  .file_type = get_file_type,",
          "122:  .regstate = regstate,",
          "123:  .maps = maps,",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c": [
          "File: libr/bin/p/bin_elf.c -> libr/bin/p/bin_elf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1217: static void headers32(RBinFile *bf) {",
          "1218: #define p bf->rbin->cb_printf",
          "",
          "[Removed Lines]",
          "3: #include <stdio.h>",
          "4: #include <r_types.h>",
          "5: #include <r_util.h>",
          "6: #include <r_lib.h>",
          "7: #include <r_bin.h>",
          "8: #include <r_io.h>",
          "9: #include <r_cons.h>",
          "10: #include \"elf/elf.h\"",
          "12: static RBinInfo* info(RBinFile *bf);",
          "16: static int get_file_type(RBinFile *bf) {",
          "17:  struct Elf_(r_bin_elf_obj_t) *obj = bf->o->bin_obj;",
          "18:  char *type = Elf_(r_bin_elf_get_file_type (obj));",
          "19:  int res = type? ((!strncmp (type, \"CORE\", 4)) ? R_BIN_TYPE_CORE : R_BIN_TYPE_DEFAULT) : -1;",
          "20:  free (type);",
          "21:  return res;",
          "22: }",
          "24: static RList *maps(RBinFile *bf) {",
          "25:  if (bf && bf->o) {",
          "26:   return Elf_(r_bin_elf_get_maps)(bf->o->bin_obj);",
          "27:  }",
          "28:  return NULL;",
          "29: }",
          "31: static char* regstate(RBinFile *bf) {",
          "32:  struct Elf_(r_bin_elf_obj_t) *obj = bf->o->bin_obj;",
          "33:  if (obj->ehdr.e_machine != EM_AARCH64 &&",
          "34:   obj->ehdr.e_machine != EM_ARM &&",
          "35:   obj->ehdr.e_machine != EM_386 &&",
          "36:   obj->ehdr.e_machine != EM_X86_64) {",
          "37:   eprintf (\"Cannot retrieve regstate on: %s (not yet supported)\\n\",",
          "38:      Elf_(r_bin_elf_get_machine_name)(obj));",
          "39:   return NULL;",
          "40:  }",
          "42:  int len = 0;",
          "43:  ut8 *regs = Elf_(r_bin_elf_grab_regstate) (obj, &len);",
          "44:  char *hexregs = (regs && len > 0) ? r_hex_bin2strdup (regs, len) : NULL;",
          "46:  free (regs);",
          "47:  return hexregs;",
          "48: }",
          "50: static void setsymord(ELFOBJ* eobj, ut32 ord, RBinSymbol *ptr) {",
          "51:  if (!eobj->symbols_by_ord || ord >= eobj->symbols_by_ord_size) {",
          "52:   return;",
          "53:  }",
          "54:  r_bin_symbol_free (eobj->symbols_by_ord[ord]);",
          "55:  eobj->symbols_by_ord[ord] = r_bin_symbol_clone (ptr);",
          "56: }",
          "58: static void setimpord(ELFOBJ* eobj, ut32 ord, RBinImport *ptr) {",
          "59:  if (!eobj->imports_by_ord || ord >= eobj->imports_by_ord_size) {",
          "60:   return;",
          "61:  }",
          "62:  r_bin_import_free (eobj->imports_by_ord[ord]);",
          "63:  eobj->imports_by_ord[ord] = r_bin_import_clone (ptr);",
          "64: }",
          "66: static Sdb* get_sdb(RBinFile *bf) {",
          "67:  RBinObject *o = bf->o;",
          "68:  if (o && o->bin_obj) {",
          "69:   struct Elf_(r_bin_elf_obj_t) *bin = (struct Elf_(r_bin_elf_obj_t) *) o->bin_obj;",
          "70:   return bin->kv;",
          "71:  }",
          "72:  return NULL;",
          "73: }",
          "75: static void * load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {",
          "76:  struct Elf_(r_bin_elf_obj_t) *res;",
          "77:  if (!buf) {",
          "78:   return NULL;",
          "79:  }",
          "80:  res = Elf_(r_bin_elf_new_buf) (buf, bf->rbin->verbose);",
          "81:  if (res) {",
          "82:   sdb_ns_set (sdb, \"info\", res->kv);",
          "83:  }",
          "84:  return res;",
          "85: }",
          "87: static void * load_bytes(RBinFile *bf, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb) {",
          "88:  struct Elf_(r_bin_elf_obj_t) *res;",
          "89:  if (!buf || !sz || sz == UT64_MAX) {",
          "90:   return NULL;",
          "91:  }",
          "92:  RBuffer *tbuf = r_buf_new ();",
          "94:  r_buf_set_bytes (tbuf, buf, sz);",
          "95:  res = Elf_(r_bin_elf_new_buf) (tbuf, bf->rbin->verbose);",
          "96:  if (res) {",
          "97:   sdb_ns_set (sdb, \"info\", res->kv);",
          "98:  }",
          "99:  r_buf_free (tbuf);",
          "100:  return res;",
          "101: }",
          "103: static bool load(RBinFile *bf) {",
          "104:  const ut8 *bytes = bf ? r_buf_buffer (bf->buf) : NULL;",
          "105:  ut64 sz = bf ? r_buf_size (bf->buf): 0;",
          "106:  if (!bf || !bf->o) {",
          "107:   return false;",
          "108:  }",
          "109:  bf->o->bin_obj = load_bytes (bf, bytes, sz, bf->o->loadaddr, bf->sdb);",
          "110:  return bf->o->bin_obj != NULL;",
          "111: }",
          "113: static int destroy(RBinFile *bf) {",
          "114:  int i;",
          "115:  ELFOBJ* eobj = bf->o->bin_obj;",
          "116:  if (eobj && eobj->imports_by_ord) {",
          "117:   for (i = 0; i < eobj->imports_by_ord_size; i++) {",
          "118:    RBinImport *imp = eobj->imports_by_ord[i];",
          "119:    if (imp) {",
          "120:     free (imp->name);",
          "121:     free (imp);",
          "122:     eobj->imports_by_ord[i] = NULL;",
          "123:    }",
          "124:   }",
          "125:   R_FREE (eobj->imports_by_ord);",
          "126:  }",
          "127:  Elf_(r_bin_elf_free) ((struct Elf_(r_bin_elf_obj_t)*)bf->o->bin_obj);",
          "128:  return true;",
          "129: }",
          "131: static ut64 baddr(RBinFile *bf) {",
          "132:  return Elf_(r_bin_elf_get_baddr) (bf->o->bin_obj);",
          "133: }",
          "135: static ut64 boffset(RBinFile *bf) {",
          "136:  return Elf_(r_bin_elf_get_boffset) (bf->o->bin_obj);",
          "137: }",
          "139: static RBinAddr* binsym(RBinFile *bf, int sym) {",
          "140:  struct Elf_(r_bin_elf_obj_t)* obj = bf->o->bin_obj;",
          "141:  RBinAddr *ret = NULL;",
          "142:  ut64 addr = 0LL;",
          "144:  switch (sym) {",
          "145:  case R_BIN_SYM_ENTRY:",
          "146:   addr = Elf_(r_bin_elf_get_entry_offset) (bf->o->bin_obj);",
          "147:   break;",
          "148:  case R_BIN_SYM_MAIN:",
          "149:   addr = Elf_(r_bin_elf_get_main_offset) (bf->o->bin_obj);",
          "150:   break;",
          "151:  case R_BIN_SYM_INIT:",
          "152:   addr = Elf_(r_bin_elf_get_init_offset) (bf->o->bin_obj);",
          "153:   break;",
          "154:  case R_BIN_SYM_FINI:",
          "155:   addr = Elf_(r_bin_elf_get_fini_offset) (bf->o->bin_obj);",
          "156:   break;",
          "157:  }",
          "158:  if (addr && addr != UT64_MAX && (ret = R_NEW0 (RBinAddr))) {",
          "159:   struct Elf_(r_bin_elf_obj_t) *bin = bf->o->bin_obj;",
          "160:   bool is_arm = bin->ehdr.e_machine == EM_ARM;",
          "161:   ret->paddr = addr;",
          "162:   ret->vaddr = Elf_(r_bin_elf_p2v) (obj, addr);",
          "163:   if (is_arm && addr & 1) {",
          "164:    ret->bits = 16;",
          "165:    ret->vaddr--;",
          "166:    ret->paddr--;",
          "167:   }",
          "168:  }",
          "169:  return ret;",
          "170: }",
          "172: static RList* sections(RBinFile *bf) {",
          "173:  struct Elf_(r_bin_elf_obj_t)* obj = (bf && bf->o)? bf->o->bin_obj : NULL;",
          "174:  struct r_bin_elf_section_t *section = NULL;",
          "175:  int i, num, found_load = 0;",
          "176:  Elf_(Phdr)* phdr = NULL;",
          "177:  RBinSection *ptr = NULL;",
          "178:  RList *ret = NULL;",
          "180:  if (!obj || !(ret = r_list_newf (free))) {",
          "181:   return NULL;",
          "182:  }",
          "185:  if ((section = Elf_(r_bin_elf_get_sections) (obj))) {",
          "186:   for (i = 0; !section[i].last; i++) {",
          "187:    if (!(ptr = R_NEW0 (RBinSection))) {",
          "188:     break;",
          "189:    }",
          "190:    strncpy (ptr->name, (char*)section[i].name, R_BIN_SIZEOF_STRINGS);",
          "191:    if (strstr (ptr->name, \"data\") && !strstr (ptr->name, \"rel\")) {",
          "192:     ptr->is_data = true;",
          "193:    }",
          "194:    ptr->size = section[i].type != SHT_NOBITS ? section[i].size : 0;",
          "195:    ptr->vsize = section[i].size;",
          "196:    ptr->paddr = section[i].offset;",
          "197:    ptr->vaddr = section[i].rva;",
          "198:    ptr->add = !obj->phdr; // Load sections if there is no PHDR",
          "199:    ptr->srwx = 0;",
          "200:    if (R_BIN_ELF_SCN_IS_EXECUTABLE (section[i].flags)) {",
          "201:     ptr->srwx |= R_BIN_SCN_EXECUTABLE;",
          "202:    }",
          "203:    if (R_BIN_ELF_SCN_IS_WRITABLE (section[i].flags)) {",
          "204:     ptr->srwx |= R_BIN_SCN_WRITABLE;",
          "205:    }",
          "206:    if (R_BIN_ELF_SCN_IS_READABLE (section[i].flags)) {",
          "207:     ptr->srwx |= R_BIN_SCN_READABLE;",
          "208:    }",
          "209:    r_list_append (ret, ptr);",
          "210:   }",
          "211:  }",
          "214:  num = obj->ehdr.e_phnum;",
          "215:  phdr = obj->phdr;",
          "216:  if (phdr) {",
          "217:   int n = 0;",
          "218:   for (i = 0; i < num; i++) {",
          "219:    if (!(ptr = R_NEW0 (RBinSection))) {",
          "220:     return ret;",
          "221:    }",
          "222:    ptr->add = false;",
          "223:    ptr->size = phdr[i].p_filesz;",
          "224:    ptr->vsize = phdr[i].p_memsz;",
          "225:    ptr->paddr = phdr[i].p_offset;",
          "226:    ptr->vaddr = phdr[i].p_vaddr;",
          "227:    ptr->srwx = phdr[i].p_flags;",
          "228:    ptr->is_segment = true;",
          "229:    switch (phdr[i].p_type) {",
          "230:    case PT_DYNAMIC:",
          "231:     strncpy (ptr->name, \"DYNAMIC\", R_BIN_SIZEOF_STRINGS);",
          "232:     break;",
          "233:    case PT_LOAD:",
          "234:     snprintf (ptr->name, R_BIN_SIZEOF_STRINGS, \"LOAD%d\", n++);",
          "235:     found_load = 1;",
          "236:     ptr->add = true;",
          "237:     break;",
          "238:    case PT_INTERP:",
          "239:     strncpy (ptr->name, \"INTERP\", R_BIN_SIZEOF_STRINGS);",
          "240:     break;",
          "241:    case PT_GNU_STACK:",
          "242:     strncpy (ptr->name, \"GNU_STACK\", R_BIN_SIZEOF_STRINGS);",
          "243:     break;",
          "244:    case PT_GNU_RELRO:",
          "245:     strncpy (ptr->name, \"GNU_RELRO\", R_BIN_SIZEOF_STRINGS);",
          "246:     break;",
          "247:    case PT_GNU_EH_FRAME:",
          "248:     strncpy (ptr->name, \"GNU_EH_FRAME\", R_BIN_SIZEOF_STRINGS);",
          "249:     break;",
          "250:    case PT_PHDR:",
          "251:     strncpy (ptr->name, \"PHDR\", R_BIN_SIZEOF_STRINGS);",
          "252:     break;",
          "253:    case PT_TLS:",
          "254:     strncpy (ptr->name, \"TLS\", R_BIN_SIZEOF_STRINGS);",
          "255:     break;",
          "256:    case PT_NOTE:",
          "257:     strncpy (ptr->name, \"NOTE\", R_BIN_SIZEOF_STRINGS);",
          "258:     break;",
          "259:    default:",
          "260:     strncpy (ptr->name, \"UNKNOWN\", R_BIN_SIZEOF_STRINGS);",
          "261:     break;",
          "262:    }",
          "263:    ptr->name[R_BIN_SIZEOF_STRINGS - 1] = '\\0';",
          "264:    r_list_append (ret, ptr);",
          "265:   }",
          "266:  }",
          "268:  if (r_list_empty (ret)) {",
          "269:   if (!bf->size) {",
          "270:    struct Elf_(r_bin_elf_obj_t) *bin = bf->o->bin_obj;",
          "271:    bf->size = bin? bin->size: 0x9999;",
          "272:   }",
          "273:   if (found_load == 0) {",
          "274:    if (!(ptr = R_NEW0 (RBinSection))) {",
          "275:     return ret;",
          "276:    }",
          "277:    sprintf (ptr->name, \"uphdr\");",
          "278:    ptr->size = bf->size;",
          "279:    ptr->vsize = bf->size;",
          "280:    ptr->paddr = 0;",
          "281:    ptr->vaddr = 0x10000;",
          "282:    ptr->add = true;",
          "283:    ptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_WRITABLE |",
          "284:     R_BIN_SCN_EXECUTABLE;",
          "285:    r_list_append (ret, ptr);",
          "286:   }",
          "287:  }",
          "289:  ptr = R_NEW0 (RBinSection);",
          "290:  if (ptr) {",
          "291:   ut64 ehdr_size = sizeof (obj->ehdr);",
          "292:   if (bf->size < ehdr_size) {",
          "293:    ehdr_size = bf->size;",
          "294:   }",
          "295:   sprintf (ptr->name, \"ehdr\");",
          "296:   ptr->paddr = 0;",
          "297:   ptr->vaddr = obj->baddr;",
          "298:   ptr->size = ehdr_size;",
          "299:   ptr->vsize = ehdr_size;",
          "300:   ptr->add = false;",
          "301:   if (obj->ehdr.e_type == ET_REL) {",
          "302:    ptr->add = true;",
          "303:   }",
          "304:   ptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_WRITABLE;",
          "305:   ptr->is_segment = true;",
          "306:   r_list_append (ret, ptr);",
          "307:  }",
          "308:  return ret;",
          "309: }",
          "311: static RBinAddr* newEntry(RBinFile *bf, ut64 hpaddr, ut64 hvaddr, ut64 vaddr, int type, int bits) {",
          "312:  struct Elf_(r_bin_elf_obj_t)* obj;",
          "313:  RBinAddr *ptr;",
          "315:  if (!bf || !bf->o || !bf->o->bin_obj) {",
          "316:   return NULL;",
          "317:  }",
          "318:  obj = bf->o->bin_obj;",
          "319:  ptr = R_NEW0 (RBinAddr);",
          "320:  if (ptr) {",
          "321:   ptr->paddr = Elf_(r_bin_elf_v2p) (obj, vaddr);",
          "322:   ptr->vaddr = vaddr;",
          "323:   ptr->hpaddr = hpaddr;",
          "324:   ptr->hvaddr = hvaddr;",
          "325:   ptr->bits = bits;",
          "326:   ptr->type = type;",
          "328:   if (bits == 16 && ptr->vaddr & 1) {",
          "329:    ptr->paddr--;",
          "330:    ptr->vaddr--;",
          "331:   }",
          "332:  }",
          "333:  return ptr;",
          "334: }",
          "336: static void process_constructors (RBinFile *bf, RList *ret, int bits) {",
          "337:  RList *secs = sections (bf);",
          "338:  RListIter *iter;",
          "339:  RBinSection *sec;",
          "340:  int i, type;",
          "341:  r_list_foreach (secs, iter, sec) {",
          "342:   type = -1;",
          "343:   if (!strcmp (sec->name, \".fini_array\")) {",
          "344:    type = R_BIN_ENTRY_TYPE_FINI;",
          "345:   } else if (!strcmp (sec->name, \".init_array\")) {",
          "346:    type = R_BIN_ENTRY_TYPE_INIT;",
          "347:   } else if (!strcmp (sec->name, \".preinit_array\")) {",
          "348:    type = R_BIN_ENTRY_TYPE_PREINIT;",
          "349:   }",
          "350:   if (type != -1) {",
          "351:    ut8 *buf = calloc (sec->size, 1);",
          "352:    if (!buf) {",
          "353:     continue;",
          "354:    }",
          "355:    (void)r_buf_read_at (bf->buf, sec->paddr, buf, sec->size);",
          "356:    if (bits == 32) {",
          "357:     for (i = 0; (i + 3) < sec->size; i += 4) {",
          "358:      ut32 addr32 = r_read_le32 (buf + i);",
          "359:      if (addr32) {",
          "360:       RBinAddr *ba = newEntry (bf, sec->paddr + i, sec->vaddr + i,",
          "361:                                (ut64)addr32, type, bits);",
          "362:       r_list_append (ret, ba);",
          "363:      }",
          "364:     }",
          "365:    } else {",
          "366:     for (i = 0; (i + 7) < sec->size; i += 8) {",
          "367:      ut64 addr64 = r_read_le64 (buf + i);",
          "368:      if (addr64) {",
          "369:       RBinAddr *ba = newEntry (bf, sec->paddr + i, sec->vaddr + i,",
          "370:                                addr64, type, bits);",
          "371:       r_list_append (ret, ba);",
          "372:      }",
          "373:     }",
          "374:    }",
          "375:    free (buf);",
          "376:   }",
          "377:  }",
          "378:  r_list_free (secs);",
          "379: }",
          "381: static RList* entries(RBinFile *bf) {",
          "382:  struct Elf_(r_bin_elf_obj_t)* obj;",
          "383:  RBinAddr *ptr = NULL;",
          "384:  struct r_bin_elf_symbol_t *symbol;",
          "385:  RList *ret;",
          "386:  int i;",
          "388:  if (!bf || !bf->o || !bf->o->bin_obj) {",
          "389:   return NULL;",
          "390:  }",
          "391:  obj = bf->o->bin_obj;",
          "392:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "393:   return NULL;",
          "394:  }",
          "395:  if (!(ptr = R_NEW0 (RBinAddr))) {",
          "396:   return ret;",
          "397:  }",
          "398:  ptr->paddr = Elf_(r_bin_elf_get_entry_offset) (obj);",
          "399:  ptr->vaddr = Elf_(r_bin_elf_p2v) (obj, ptr->paddr);",
          "400:  ptr->hpaddr = 0x18;  // e_entry offset in ELF header",
          "402:  if (obj->ehdr.e_machine == EM_ARM) {",
          "403:   int bin_bits = Elf_(r_bin_elf_get_bits) (obj);",
          "404:   if (bin_bits != 64) {",
          "405:    ptr->bits = 32;",
          "406:    if (ptr->vaddr & 1) {",
          "407:     ptr->vaddr--;",
          "408:     ptr->bits = 16;",
          "409:    }",
          "410:    if (ptr->paddr & 1) {",
          "411:     ptr->paddr--;",
          "412:     ptr->bits = 16;",
          "413:    }",
          "414:   }",
          "415:  }",
          "416:  r_list_append (ret, ptr);",
          "420:  if (!(symbol = Elf_(r_bin_elf_get_symbols) (obj))) {",
          "421:   return ret;",
          "422:  }",
          "423:  for (i = 0; !symbol[i].last; i++) {",
          "424:   if (!strncmp (symbol[i].name, \"Java\", 4)) {",
          "425:    if (r_str_endswith (symbol[i].name, \"_init\")) {",
          "426:     if (!(ptr = R_NEW0 (RBinAddr))) {",
          "427:      return ret;",
          "428:     }",
          "429:     ptr->paddr = symbol[i].offset;",
          "430:     ptr->vaddr = Elf_(r_bin_elf_p2v) (obj, ptr->paddr);",
          "431:     ptr->hpaddr = UT64_MAX;",
          "432:     ptr->type = R_BIN_ENTRY_TYPE_INIT;",
          "433:     r_list_append (ret, ptr);",
          "434:     break;",
          "435:    }",
          "436:   }",
          "437:  }",
          "438:  int bin_bits = Elf_(r_bin_elf_get_bits) (bf->o->bin_obj);",
          "439:  process_constructors (bf, ret, bin_bits < 32 ? 32: bin_bits);",
          "440:  return ret;",
          "441: }",
          "443: static void _set_arm_thumb_bits(struct Elf_(r_bin_elf_obj_t) *bin, RBinSymbol **sym) {",
          "444:  int bin_bits = Elf_(r_bin_elf_get_bits) (bin);",
          "445:  RBinSymbol *ptr = *sym;",
          "446:  int len = strlen (ptr->name);",
          "447:  if (ptr->name[0] == '$' && (len >= 2 && !ptr->name[2])) {",
          "448:   switch (ptr->name[1]) {",
          "449:   case 'a' : //arm",
          "450:    ptr->bits = 32;",
          "451:    break;",
          "452:   case 't': //thumb",
          "453:    ptr->bits = 16;",
          "454:    if (ptr->vaddr & 1) {",
          "455:     ptr->vaddr--;",
          "456:    }",
          "457:    if (ptr->paddr & 1) {",
          "458:     ptr->paddr--;",
          "459:    }",
          "460:    break;",
          "461:   case 'd': //data",
          "462:    break;",
          "463:   default:",
          "464:    goto arm_symbol;",
          "465:   }",
          "466:  } else {",
          "467: arm_symbol:",
          "468:   ptr->bits = bin_bits;",
          "469:   if (bin_bits != 64) {",
          "470:    ptr->bits = 32;",
          "471:    if (ptr->vaddr & 1) {",
          "472:     ptr->vaddr--;",
          "473:     ptr->bits = 16;",
          "474:    }",
          "475:    if (ptr->paddr & 1) {",
          "476:     ptr->paddr--;",
          "477:     ptr->bits = 16;",
          "478:    }",
          "479:   }",
          "480:  }",
          "481: }",
          "483: static RBinSymbol *convert_symbol(struct Elf_(r_bin_elf_obj_t) *bin,",
          "484:       struct r_bin_elf_symbol_t *symbol,",
          "485:       const char *namefmt) {",
          "486:  ut64 paddr = symbol->offset;",
          "487:  ut64 vaddr = Elf_(r_bin_elf_p2v) (bin, paddr);",
          "488:  RBinSymbol *ptr = NULL;",
          "490:  if (!(ptr = R_NEW0 (RBinSymbol))) {",
          "491:   return NULL;",
          "492:  }",
          "493:  ptr->name = symbol->name[0] ? r_str_newf (namefmt, &symbol->name[0]) : strdup (\"\");",
          "494:  ptr->forwarder = r_str_const (\"NONE\");",
          "495:  ptr->bind = r_str_const (symbol->bind);",
          "496:  ptr->type = r_str_const (symbol->type);",
          "497:  ptr->paddr = paddr;",
          "498:  ptr->vaddr = vaddr;",
          "499:  ptr->size = symbol->size;",
          "500:  ptr->ordinal = symbol->ordinal;",
          "502:  if (bin->ehdr.e_machine == EM_ARM && *ptr->name) {",
          "503:   _set_arm_thumb_bits (bin, &ptr);",
          "504:  }",
          "506:  return ptr;",
          "507: }",
          "509: static void insert_symbol(struct Elf_(r_bin_elf_obj_t) *bin,",
          "510:      RBinSymbol *ptr,",
          "511:      bool is_sht_null,",
          "512:      RList *ret) {",
          "514:  setsymord (bin, ptr->ordinal, ptr);",
          "516:  if (is_sht_null) {",
          "517:   r_bin_symbol_free (ptr);",
          "518:  } else {",
          "519:   r_list_append (ret, ptr);",
          "520:  }",
          "521: }",
          "523: static RList* symbols(RBinFile *bf) {",
          "524:  struct Elf_(r_bin_elf_obj_t) *bin;",
          "525:  struct r_bin_elf_symbol_t *symbol = NULL;",
          "526:  RBinSymbol *ptr = NULL;",
          "527:  RList *ret = NULL;",
          "528:  int i;",
          "530:  if (!bf|| !bf->o || !bf->o->bin_obj) {",
          "531:   return NULL;",
          "532:  }",
          "534:  bin = bf->o->bin_obj;",
          "535:  ret = r_list_newf (free);",
          "536:  if (!ret) {",
          "537:   return NULL;",
          "538:  }",
          "541:  if (!(symbol = Elf_(r_bin_elf_get_symbols) (bin))) {",
          "542:   return ret;",
          "543:  }",
          "544:  for (i = 0; !symbol[i].last; i++) {",
          "545:   ptr = convert_symbol (bin, &symbol[i], \"%s\");",
          "546:   if (!ptr) {",
          "547:    break;",
          "548:   }",
          "549:   insert_symbol (bin, ptr, symbol[i].is_sht_null, ret);",
          "550:  }",
          "553:  if (!(symbol = Elf_(r_bin_elf_get_imports) (bin))) {",
          "554:   return ret;",
          "555:  }",
          "556:  for (i = 0; !symbol[i].last; i++) {",
          "557:   if (!symbol[i].size) {",
          "558:    continue;",
          "559:   }",
          "560:   ptr = convert_symbol (bin, &symbol[i], \"imp.%s\");",
          "561:   if (!ptr) {",
          "562:    break;",
          "563:   }",
          "565:   if (ptr->vaddr == UT32_MAX) {",
          "566:    ptr->paddr = 0;",
          "567:    ptr->vaddr = 0;",
          "568:   }",
          "569:   insert_symbol (bin, ptr, symbol[i].is_sht_null, ret);",
          "570:  }",
          "571:  return ret;",
          "572: }",
          "574: static RList* imports(RBinFile *bf) {",
          "575:  struct Elf_(r_bin_elf_obj_t) *bin = NULL;",
          "576:  RBinElfSymbol *import = NULL;",
          "577:  RBinImport *ptr = NULL;",
          "578:  RList *ret = NULL;",
          "579:  int i;",
          "581:  if (!bf || !bf->o || !bf->o->bin_obj) {",
          "582:   return NULL;",
          "583:  }",
          "584:  bin = bf->o->bin_obj;",
          "585:  if (!(ret = r_list_newf (r_bin_import_free))) {",
          "586:   return NULL;",
          "587:  }",
          "588:  if (!(import = Elf_(r_bin_elf_get_imports) (bin))) {",
          "589:   r_list_free (ret);",
          "590:   return NULL;",
          "591:  }",
          "592:  for (i = 0; !import[i].last; i++) {",
          "593:   if (!(ptr = R_NEW0 (RBinImport))) {",
          "594:    break;",
          "595:   }",
          "596:   ptr->name = strdup (import[i].name);",
          "597:   ptr->bind = r_str_const (import[i].bind);",
          "598:   ptr->type = r_str_const (import[i].type);",
          "599:   ptr->ordinal = import[i].ordinal;",
          "600:   setimpord (bin, ptr->ordinal, ptr);",
          "601:   r_list_append (ret, ptr);",
          "602:  }",
          "603:  return ret;",
          "604: }",
          "606: static RList* libs(RBinFile *bf) {",
          "607:  struct r_bin_elf_lib_t *libs = NULL;",
          "608:  RList *ret = NULL;",
          "609:  char *ptr = NULL;",
          "610:  int i;",
          "612:  if (!bf || !bf->o || !bf->o->bin_obj) {",
          "613:   return NULL;",
          "614:  }",
          "615:  if (!(ret = r_list_newf (free))) {",
          "616:   return NULL;",
          "617:  }",
          "618:  if (!(libs = Elf_(r_bin_elf_get_libs) (bf->o->bin_obj))) {",
          "619:   return ret;",
          "620:  }",
          "621:  for (i = 0; !libs[i].last; i++) {",
          "622:   ptr = strdup (libs[i].name);",
          "623:   r_list_append (ret, ptr);",
          "624:  }",
          "625:  free (libs);",
          "626:  return ret;",
          "627: }",
          "629: static RBinReloc *reloc_convert(struct Elf_(r_bin_elf_obj_t) *bin, RBinElfReloc *rel, ut64 GOT) {",
          "630:  RBinReloc *r = NULL;",
          "631:  ut64 B, P;",
          "633:  if (!bin || !rel) {",
          "634:   return NULL;",
          "635:  }",
          "636:  B = bin->baddr;",
          "637:  P = rel->rva; // rva has taken baddr into account",
          "638:  if (!(r = R_NEW0 (RBinReloc))) {",
          "639:   return r;",
          "640:  }",
          "641:  r->import = NULL;",
          "642:  r->symbol = NULL;",
          "643:  r->is_ifunc = false;",
          "644:  r->addend = rel->addend;",
          "645:  if (rel->sym) {",
          "646:   if (rel->sym < bin->imports_by_ord_size && bin->imports_by_ord[rel->sym]) {",
          "647:    r->import = bin->imports_by_ord[rel->sym];",
          "648:   } else if (rel->sym < bin->symbols_by_ord_size && bin->symbols_by_ord[rel->sym]) {",
          "649:    r->symbol = bin->symbols_by_ord[rel->sym];",
          "650:   }",
          "651:  }",
          "652:  r->vaddr = rel->rva;",
          "653:  r->paddr = rel->offset;",
          "655:  #define SET(T) r->type = R_BIN_RELOC_ ## T; r->additive = 0; return r",
          "656:  #define ADD(T, A) r->type = R_BIN_RELOC_ ## T; r->addend += A; r->additive = !rel->is_rela; return r",
          "658:  switch (bin->ehdr.e_machine) {",
          "659:  case EM_386: switch (rel->type) {",
          "660:   case R_386_NONE:     break; // malloc then free. meh. then again, there's no real world use for _NONE.",
          "661:   case R_386_32:       ADD(32, 0);",
          "662:   case R_386_PC32:     ADD(32,-P);",
          "663:   case R_386_GLOB_DAT: SET(32);",
          "664:   case R_386_JMP_SLOT: SET(32);",
          "665:   case R_386_RELATIVE: ADD(32, B);",
          "666:   case R_386_GOTOFF:   ADD(32,-GOT);",
          "667:   case R_386_GOTPC:    ADD(32, GOT-P);",
          "668:   case R_386_16:       ADD(16, 0);",
          "669:   case R_386_PC16:     ADD(16,-P);",
          "670:   case R_386_8:        ADD(8,  0);",
          "671:   case R_386_PC8:      ADD(8, -P);",
          "672:   case R_386_COPY:     ADD(64, 0); // XXX: copy symbol at runtime",
          "673:   case R_386_IRELATIVE: r->is_ifunc = true; SET(32);",
          "674:   default: break; //eprintf(\"TODO(eddyb): uninmplemented ELF/x86 reloc type %i\\n\", rel->type);",
          "675:   }",
          "676:   break;",
          "677:  case EM_X86_64: switch (rel->type) {",
          "678:   case R_X86_64_NONE: break; // malloc then free. meh. then again, there's no real world use for _NONE.",
          "679:   case R_X86_64_64: ADD(64, 0);",
          "680:   case R_X86_64_PLT32: ADD(32,-P /* +L */);",
          "681:   case R_X86_64_GOT32: ADD(32, GOT);",
          "682:   case R_X86_64_PC32: ADD(32,-P);",
          "683:   case R_X86_64_GLOB_DAT: r->vaddr -= rel->sto; SET(64);",
          "684:   case R_X86_64_JUMP_SLOT: r->vaddr -= rel->sto; SET(64);",
          "685:   case R_X86_64_RELATIVE: ADD(64, B);",
          "686:   case R_X86_64_32: ADD(32, 0);",
          "687:   case R_X86_64_32S: ADD(32, 0);",
          "688:   case R_X86_64_16: ADD(16, 0);",
          "689:   case R_X86_64_PC16: ADD(16,-P);",
          "690:   case R_X86_64_8: ADD(8,  0);",
          "691:   case R_X86_64_PC8: ADD(8, -P);",
          "692:   case R_X86_64_GOTPCREL: ADD(64, GOT-P);",
          "693:   case R_X86_64_COPY: ADD(64, 0); // XXX: copy symbol at runtime",
          "694:   case R_X86_64_IRELATIVE: r->is_ifunc = true; SET(64);",
          "695:   default: break; ////eprintf(\"TODO(eddyb): uninmplemented ELF/x64 reloc type %i\\n\", rel->type);",
          "696:   }",
          "697:   break;",
          "698:  case EM_ARM: switch (rel->type) {",
          "699:   case R_ARM_NONE: break; // malloc then free. meh. then again, there's no real world use for _NONE.",
          "700:   case R_ARM_ABS32: ADD(32, 0);",
          "701:   case R_ARM_REL32: ADD(32,-P);",
          "702:   case R_ARM_ABS16: ADD(16, 0);",
          "703:   case R_ARM_ABS8: ADD(8,  0);",
          "704:   case R_ARM_SBREL32: ADD(32, -B);",
          "705:   case R_ARM_GLOB_DAT: ADD(32, 0);",
          "706:   case R_ARM_JUMP_SLOT: ADD(32, 0);",
          "707:   case R_ARM_RELATIVE: ADD(32, B);",
          "708:   case R_ARM_GOTOFF: ADD(32,-GOT);",
          "709:   default: ADD(32,GOT); break; // reg relocations",
          "711:   }",
          "712:   break;",
          "713:  default: break;",
          "714:  }",
          "716:  #undef SET",
          "717:  #undef ADD",
          "719:  free(r);",
          "720:  return 0;",
          "721: }",
          "723: static RList* relocs(RBinFile *bf) {",
          "724:  RList *ret = NULL;",
          "725:  RBinReloc *ptr = NULL;",
          "726:  RBinElfReloc *relocs = NULL;",
          "727:  struct Elf_(r_bin_elf_obj_t) *bin = NULL;",
          "728:  ut64 got_addr;",
          "729:  int i;",
          "730:  if (!bf || !bf->o || !bf->o->bin_obj) {",
          "731:   return NULL;",
          "732:  }",
          "733:  bin = bf->o->bin_obj;",
          "734:  if (!(ret = r_list_newf (free))) {",
          "735:   return NULL;",
          "736:  }",
          "739:  r_list_free (imports (bf));",
          "740:  if ((got_addr = Elf_(r_bin_elf_get_section_addr) (bin, \".got\")) == -1) {",
          "741:   got_addr = Elf_(r_bin_elf_get_section_addr) (bin, \".got.plt\");",
          "742:   if (got_addr == -1) {",
          "743:    got_addr = 0;",
          "744:   }",
          "745:  }",
          "746:  if (got_addr < 1 && bin->ehdr.e_type == ET_REL) {",
          "747:   got_addr = Elf_(r_bin_elf_get_section_addr) (bin, \".got.r2\");",
          "748:   if (got_addr == -1) {",
          "749:    got_addr = 0;",
          "750:   }",
          "751:  }",
          "752:  if (bf->o) {",
          "753:   if (!(relocs = Elf_(r_bin_elf_get_relocs) (bin))) {",
          "754:    return ret;",
          "755:   }",
          "756:   for (i = 0; !relocs[i].last; i++) {",
          "757:    if (!(ptr = reloc_convert (bin, &relocs[i], got_addr))) {",
          "758:     continue;",
          "759:    }",
          "760:    r_list_append (ret, ptr);",
          "761:   }",
          "762:   free (relocs);",
          "763:  }",
          "764:  return ret;",
          "765: }",
          "767: static void _patch_reloc (ut16 e_machine, RIOBind *iob, RBinElfReloc *rel, ut64 S, ut64 B, ut64 L) {",
          "768:  ut64 val;",
          "769:  ut64 A = rel->addend, P = rel->rva;",
          "770:  ut8 buf[8];",
          "771:  switch (e_machine) {",
          "772:  case EM_PPC64: {",
          "773:   int low = 0, word = 0;",
          "774:   switch (rel->type) {",
          "775:   case R_PPC64_REL16_HA:",
          "776:    word = 2;",
          "777:    val = (S + A - P + 0x8000) >> 16;",
          "778:    break;",
          "779:   case R_PPC64_REL16_LO:",
          "780:    word = 2;",
          "781:    val = (S + A - P) & 0xffff;",
          "782:    break;",
          "783:   case R_PPC64_REL14:",
          "784:    low = 14;",
          "785:    val = (st64)(S + A - P) >> 2;",
          "786:    break;",
          "787:   case R_PPC64_REL24:",
          "788:    low = 24;",
          "789:    val = (st64)(S + A - P) >> 2;",
          "790:    break;",
          "791:   case R_PPC64_REL32:",
          "792:    word = 4;",
          "793:    val = S + A - P;",
          "794:    break;",
          "795:   default:",
          "796:    break;",
          "797:   }",
          "798:   if (low) {",
          "800:    switch (low) {",
          "801:    case 14:",
          "802:     val &= (1 << 14) - 1;",
          "803:     iob->read_at (iob->io, rel->rva, buf, 2);",
          "804:     r_write_le32 (buf, (r_read_le32 (buf) & ~((1<<16) - (1<<2))) | val << 2);",
          "805:     iob->write_at (iob->io, rel->rva, buf, 2);",
          "806:     break;",
          "807:    case 24:",
          "808:     val &= (1 << 24) - 1;",
          "809:     iob->read_at (iob->io, rel->rva, buf, 4);",
          "810:     r_write_le32 (buf, (r_read_le32 (buf) & ~((1<<26) - (1<<2))) | val << 2);",
          "811:     iob->write_at (iob->io, rel->rva, buf, 4);",
          "812:     break;",
          "813:    }",
          "814:   } else if (word) {",
          "816:    switch (word) {",
          "817:    case 2:",
          "818:     r_write_le16 (buf, val);",
          "819:     iob->write_at (iob->io, rel->rva, buf, 2);",
          "820:     break;",
          "821:    case 4:",
          "822:     r_write_le32 (buf, val);",
          "823:     iob->write_at (iob->io, rel->rva, buf, 4);",
          "824:     break;",
          "825:    }",
          "826:   }",
          "827:   break;",
          "828:  }",
          "829:  case EM_X86_64: {",
          "830:   int word = 0;",
          "831:   switch (rel->type) {",
          "832:   case R_X86_64_8:",
          "833:    word = 1;",
          "834:    val = S + A;",
          "835:    break;",
          "836:   case R_X86_64_16:",
          "837:    word = 2;",
          "838:    val = S + A;",
          "839:    break;",
          "840:   case R_X86_64_32:",
          "841:   case R_X86_64_32S:",
          "842:    word = 4;",
          "843:    val = S + A;",
          "844:    break;",
          "845:   case R_X86_64_64:",
          "846:    word = 8;",
          "847:    val = S + A;",
          "848:    break;",
          "849:   case R_X86_64_GLOB_DAT:",
          "850:   case R_X86_64_JUMP_SLOT:",
          "851:    word = 4;",
          "852:    val = S;",
          "853:    break;",
          "854:   case R_X86_64_PC8:",
          "855:    word = 1;",
          "856:    val = S + A - P;",
          "857:    break;",
          "858:   case R_X86_64_PC16:",
          "859:    word = 2;",
          "860:    val = S + A - P;",
          "861:    break;",
          "862:   case R_X86_64_PC32:",
          "863:    word = 4;",
          "864:    val = S + A - P;",
          "865:    break;",
          "866:   case R_X86_64_PC64:",
          "867:    word = 8;",
          "868:    val = S + A - P;",
          "869:    break;",
          "870:   case R_X86_64_PLT32:",
          "871:    word = 4;",
          "872:    val = L + A - P;",
          "873:    break;",
          "874:   case R_X86_64_RELATIVE:",
          "875:    word = 8;",
          "876:    val = B + A;",
          "877:    break;",
          "878:   default:",
          "880:    break;",
          "881:   }",
          "882:   switch (word) {",
          "883:   case 0:",
          "884:    break;",
          "885:   case 1:",
          "886:    buf[0] = val;",
          "887:    iob->write_at (iob->io, rel->rva, buf, 1);",
          "888:    break;",
          "889:   case 2:",
          "890:    r_write_le16 (buf, val);",
          "891:    iob->write_at (iob->io, rel->rva, buf, 2);",
          "892:    break;",
          "893:   case 4:",
          "894:    r_write_le32 (buf, val);",
          "895:    iob->write_at (iob->io, rel->rva, buf, 4);",
          "896:    break;",
          "897:   case 8:",
          "898:    r_write_le64 (buf, val);",
          "899:    iob->write_at (iob->io, rel->rva, buf, 8);",
          "900:    break;",
          "901:   }",
          "902:   break;",
          "903:  }",
          "904:  }",
          "905: }",
          "907: static bool ht_insert_intu64(SdbHash* ht, int key, ut64 value) {",
          "908:  ut64 *mvalue = malloc (sizeof (ut64));",
          "909:  if (!mvalue) {",
          "910:   return false;",
          "911:  }",
          "913:  return ht_insert (ht, sdb_fmt (\"%d\", key), (void *)mvalue);",
          "914: }",
          "916: static ut64 ht_find_intu64(SdbHash* ht, int key, bool* found) {",
          "917:  ut64 *mvalue = (ut64 *)ht_find (ht, sdb_fmt (\"%d\", key), found);",
          "918:  return *found ? *mvalue : 0;",
          "919: }",
          "921: static void relocs_by_sym_free(HtKv *kv) {",
          "922:  free (kv->key);",
          "923:  free (kv->value);",
          "924: }",
          "926: static RList* patch_relocs(RBin *b) {",
          "927:  RList *ret = NULL;",
          "928:  RBinReloc *ptr = NULL;",
          "929:  RIO *io = NULL;",
          "930:  RBinObject *obj = NULL;",
          "931:  struct Elf_(r_bin_elf_obj_t) *bin = NULL;",
          "932:  RIOSection *g = NULL, *s = NULL;",
          "933:  SdbHash *relocs_by_sym;",
          "934:  SdbListIter *iter;",
          "935:  RBinElfReloc *relcs = NULL;",
          "936:  RBinInfo *info;",
          "937:  int cdsz;",
          "938:  int i;",
          "939:  ut64 n_off, n_vaddr, vaddr, size, offset = 0;",
          "941:  if (!b)",
          "942:   return NULL;",
          "943:  io = b->iob.io;",
          "944:  if (!io || !io->desc)",
          "945:   return NULL;",
          "946:  obj = r_bin_cur_object (b);",
          "947:  if (!obj) {",
          "948:      return NULL;",
          "949:  }",
          "950:  bin = obj->bin_obj;",
          "951:  if (bin->ehdr.e_type != ET_REL) {",
          "952:   return NULL;",
          "953:  }",
          "954:  if (!io->cached) {",
          "955:      eprintf (\"Warning: run r2 with -e io.cache=true to fix relocations in disassembly\\n\");",
          "956:   return relocs (r_bin_cur (b));",
          "957:  }",
          "959:  info = obj ? obj->info: NULL;",
          "960:  cdsz = info? (info->bits == 64? 8: info->bits == 32? 4: info->bits == 16 ? 4: 0): 0;",
          "962:  ls_foreach (io->sections, iter, s) {",
          "963:   if (s->paddr > offset) {",
          "964:    offset = s->paddr;",
          "965:    g = s;",
          "966:   }",
          "967:  }",
          "968:  if (!g) {",
          "969:   return NULL;",
          "970:  }",
          "971:  n_off = g->paddr + g->size;",
          "972:  n_vaddr = g->vaddr + g->vsize;",
          "974:  size = bin->reloc_num * 4;",
          "975:  if (!b->iob.section_add (io, n_off, n_vaddr, size, size, R_BIN_SCN_READABLE, \".got.r2\", 0, io->desc->fd)) {",
          "976:   return NULL;",
          "977:  }",
          "978:  if (!(relcs = Elf_(r_bin_elf_get_relocs) (bin))) {",
          "979:   return NULL;",
          "980:  }",
          "981:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "982:   free (relcs);",
          "983:   return NULL;",
          "984:  }",
          "985:  if (!(relocs_by_sym = ht_new (NULL, relocs_by_sym_free, NULL))) {",
          "986:   r_list_free (ret);",
          "987:   free (relcs);",
          "988:   return NULL;",
          "989:  }",
          "990:  vaddr = n_vaddr;",
          "991:  for (i = 0; !relcs[i].last; i++) {",
          "992:   ut64 sym_addr = 0;",
          "994:   if (relcs[i].sym) {",
          "995:    if (relcs[i].sym < bin->imports_by_ord_size && bin->imports_by_ord[relcs[i].sym]) {",
          "996:     bool found;",
          "998:     sym_addr = ht_find_intu64 (relocs_by_sym, relcs[i].sym, &found);",
          "999:    } else if (relcs[i].sym < bin->symbols_by_ord_size && bin->symbols_by_ord[relcs[i].sym]) {",
          "1000:     sym_addr = bin->symbols_by_ord[relcs[i].sym]->vaddr;",
          "1001:    }",
          "1002:   }",
          "1004:   _patch_reloc (bin->ehdr.e_machine, &b->iob, &relcs[i], sym_addr ? sym_addr : vaddr, 0, n_vaddr + size);",
          "1005:   if (!(ptr = reloc_convert (bin, &relcs[i], n_vaddr))) {",
          "1006:    continue;",
          "1007:   }",
          "1009:   if (sym_addr) {",
          "1010:    ptr->vaddr = sym_addr;",
          "1011:   } else {",
          "1012:    ptr->vaddr = vaddr;",
          "1013:    ht_insert_intu64 (relocs_by_sym, relcs[i].sym, vaddr);",
          "1014:    vaddr += cdsz;",
          "1015:   }",
          "1016:   r_list_append (ret, ptr);",
          "1017:  }",
          "1018:  ht_free (relocs_by_sym);",
          "1019:  free (relcs);",
          "1020:  return ret;",
          "1021: }",
          "1023: static bool has_canary(RBinFile *bf) {",
          "1024:  bool ret = false;",
          "1025:  RList* imports_list = imports (bf);",
          "1026:  RListIter *iter;",
          "1027:  RBinImport *import;",
          "1028:  if (imports_list) {",
          "1029:   r_list_foreach (imports_list, iter, import) {",
          "1030:    if (!strcmp (import->name, \"__stack_chk_fail\") || !strcmp (import->name, \"__stack_smash_handler\")) {",
          "1031:     ret = true;",
          "1032:     break;",
          "1033:    }",
          "1034:   }",
          "1035:   imports_list->free = r_bin_import_free;",
          "1036:   r_list_free (imports_list);",
          "1037:  }",
          "1038:  return ret;",
          "1039: }",
          "1041: static int has_retguard(RBinFile *bf) {",
          "1042:  int ret = -1;",
          "1043:  RList* sections_list = sections (bf);",
          "1044:  RListIter *iter;",
          "1045:  RBinSection *section;",
          "1046:  r_list_foreach (sections_list, iter, section) {",
          "1047:   # define R_BIN_RANDOMDATA_RETGUARD_SZ 48",
          "1048:   if (!strcmp (section->name, \".openbsd.randomdata\")) {",
          "1050:    ret = (section->size >= R_BIN_RANDOMDATA_RETGUARD_SZ);",
          "1051:    break;",
          "1052:   }",
          "1053:  }",
          "1054:  r_list_free (sections_list);",
          "1055:  return ret;",
          "1056: }",
          "1058: static RBinInfo* info(RBinFile *bf) {",
          "1059:  RBinInfo *ret = NULL;",
          "1060:  char *str;",
          "1062:  if (!(ret = R_NEW0 (RBinInfo))) {",
          "1063:   return NULL;",
          "1064:  }",
          "1065:  ret->lang = \"c\";",
          "1066:  ret->file = bf->file",
          "1067:   ? strdup (bf->file)",
          "1068:   : NULL;",
          "1069:  void *obj = bf->o->bin_obj;",
          "1070:  if ((str = Elf_(r_bin_elf_get_rpath)(obj))) {",
          "1071:   ret->rpath = strdup (str);",
          "1072:   free (str);",
          "1073:  } else {",
          "1074:   ret->rpath = strdup (\"NONE\");",
          "1075:  }",
          "1076:  if (!(str = Elf_(r_bin_elf_get_file_type) (obj))) {",
          "1077:   free (ret);",
          "1078:   return NULL;",
          "1079:  }",
          "1080:  ret->type = str;",
          "1081:  ret->has_pi = (strstr (str, \"DYN\"))? 1: 0;",
          "1082:  ret->has_lit = true;",
          "1083:  ret->has_canary = has_canary (bf);",
          "1084:  ret->has_retguard = has_retguard (bf);",
          "1085:  if (!(str = Elf_(r_bin_elf_get_elf_class) (obj))) {",
          "1086:   free (ret);",
          "1087:   return NULL;",
          "1088:  }",
          "1089:  ret->bclass = str;",
          "1090:  if (!(str = Elf_(r_bin_elf_get_osabi_name) (obj))) {",
          "1091:   free (ret);",
          "1092:   return NULL;",
          "1093:  }",
          "1094:  ret->os = str;",
          "1095:  if (!(str = Elf_(r_bin_elf_get_osabi_name) (obj))) {",
          "1096:   free (ret);",
          "1097:   return NULL;",
          "1098:  }",
          "1099:  ret->subsystem = str;",
          "1100:  if (!(str = Elf_(r_bin_elf_get_machine_name) (obj))) {",
          "1101:   free (ret);",
          "1102:   return NULL;",
          "1103:  }",
          "1104:  ret->machine = str;",
          "1105:  if (!(str = Elf_(r_bin_elf_get_arch) (obj))) {",
          "1106:   free (ret);",
          "1107:   return NULL;",
          "1108:  }",
          "1109:  ret->arch = str;",
          "1110:  ret->rclass = strdup (\"elf\");",
          "1111:  ret->bits = Elf_(r_bin_elf_get_bits) (obj);",
          "1112:  if (!strcmp (ret->arch, \"avr\")) {",
          "1113:   ret->bits = 16;",
          "1114:  }",
          "1115:  ret->big_endian = Elf_(r_bin_elf_is_big_endian) (obj);",
          "1116:  ret->has_va = Elf_(r_bin_elf_has_va) (obj);",
          "1117:  ret->has_nx = Elf_(r_bin_elf_has_nx) (obj);",
          "1118:  ret->intrp = Elf_(r_bin_elf_intrp) (obj);",
          "1119:  ret->dbg_info = 0;",
          "1120:  if (!Elf_(r_bin_elf_get_stripped) (obj)) {",
          "1121:   ret->dbg_info |= R_BIN_DBG_LINENUMS | R_BIN_DBG_SYMS | R_BIN_DBG_RELOCS;",
          "1122:  } else {",
          "1123:   ret->dbg_info |= R_BIN_DBG_STRIPPED;",
          "1124:  }",
          "1125:  if (Elf_(r_bin_elf_get_static) (obj)) {",
          "1126:   ret->dbg_info |= R_BIN_DBG_STATIC;",
          "1127:  }",
          "1128:  RBinElfSymbol *symbol;",
          "1129:  if (!(symbol = Elf_(r_bin_elf_get_symbols) (obj))) {",
          "1130:   return ret;",
          "1131:  }",
          "1132:  int i;",
          "1133:  for (i = 0; !symbol[i].last; i++) {",
          "1134:   if (!strncmp (symbol[i].name, \"type.\", 5)) {",
          "1135:    ret->lang = \"go\";",
          "1136:    break;",
          "1137:   }",
          "1138:  }",
          "1139:  return ret;",
          "1140: }",
          "1142: static RList* fields(RBinFile *bf) {",
          "1143:  int left = 0;",
          "1144:  RList *ret = NULL;",
          "1145:  const ut8 *buf = NULL;",
          "1147:  if (!(ret = r_list_new ())) {",
          "1148:   return NULL;",
          "1149:  }",
          "1150:  ret->free = free;",
          "1152:  if (!(buf = r_buf_get_at (bf->buf, 0, &left))) {",
          "1153:   RBinField *ptr = NULL;",
          "1154:   struct r_bin_elf_field_t *field = NULL;",
          "1155:   int i;",
          "1157:   if (!(field = Elf_(r_bin_elf_get_fields) (bf->o->bin_obj))) {",
          "1158:   return ret;",
          "1159:   }",
          "1160:   for (i = 0; !field[i].last; i++) {",
          "1161:    if (!(ptr = R_NEW0 (RBinField))) {",
          "1162:     break;",
          "1163:    }",
          "1164:    ptr->name = strdup (field[i].name);",
          "1165:    ptr->comment = NULL;",
          "1166:    ptr->vaddr = field[i].offset;",
          "1167:    ptr->paddr = field[i].offset;",
          "1168:    r_list_append (ret, ptr);",
          "1169:   }",
          "1170:   free (field);",
          "1172:  } else {",
          "1173:   #define ROW(nam,siz,val,fmt) \\",
          "1174:    r_list_append (ret, r_bin_field_new (addr, addr, siz, nam, sdb_fmt (\"0x%08x\", val), fmt));",
          "1175:   if (left < sizeof (Elf_(Ehdr))) {",
          "1176:    return ret;",
          "1177:   }",
          "1178:   ut64 addr = 0;",
          "1179:   ROW (\"ELF\", 4, r_read_le32 (buf), \"x\"); addr+=0x10;",
          "1180:   ROW (\"Type\", 2, r_read_le16 (buf + addr), \"x\"); addr+=0x2;",
          "1181:   ROW (\"Machine\", 2, r_read_le16 (buf + addr), \"x\"); addr+=0x2;",
          "1182:   ROW (\"Version\", 4, r_read_le32 (buf + addr), \"x\"); addr+=0x4;",
          "1184:   if (r_read_le8 (buf + 0x04) == 1) {",
          "1185:    ROW (\"Entry point\", 4, r_read_le32 (buf + addr), \"x\"); addr+=0x4;",
          "1186:    ROW (\"PhOff\", 4, r_read_le32 (buf + addr), \"x\"); addr+=0x4;",
          "1187:    ROW (\"ShOff\", 4, r_read_le32 (buf + addr), \"x\");",
          "1188:   } else {",
          "1189:    ROW (\"Entry point\", 8, r_read_le64 (buf + addr), \"x\"); addr+=0x8;",
          "1190:    ROW (\"PhOff\", 8, r_read_le64 (buf + addr), \"x\"); addr+=0x8;",
          "1191:    ROW (\"ShOff\", 8, r_read_le64 (buf + addr), \"x\");",
          "1192:   }",
          "1193:  }",
          "1195:  return ret;",
          "1196: }",
          "1198: static ut64 size(RBinFile *bf) {",
          "1199:  ut64 off = 0;",
          "1200:  ut64 len = 0;",
          "1201:  if (!bf->o->sections) {",
          "1202:   RListIter *iter;",
          "1203:   RBinSection *section;",
          "1204:   bf->o->sections = sections (bf);",
          "1205:   r_list_foreach (bf->o->sections, iter, section) {",
          "1206:    if (section->paddr > off) {",
          "1207:     off = section->paddr;",
          "1208:     len = section->size;",
          "1209:    }",
          "1210:   }",
          "1211:  }",
          "1212:  return off + len;",
          "1213: }",
          "1215: #if !R_BIN_ELF64 && !R_BIN_CGC",
          "",
          "[Added Lines]",
          "1: #include \"bin_elf.inc\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1369:  .version = R2_VERSION",
          "1370: };",
          "1371: #endif",
          "",
          "[Removed Lines]",
          "1372: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_elf.inc||libr/bin/p/bin_elf.inc": [
          "File: libr/bin/p/bin_elf.inc -> libr/bin/p/bin_elf.inc",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: #include <stdio.h>",
          "4: #include <r_types.h>",
          "5: #include <r_util.h>",
          "6: #include <r_lib.h>",
          "7: #include <r_bin.h>",
          "8: #include <r_io.h>",
          "9: #include <r_cons.h>",
          "10: #include \"elf/elf.h\"",
          "12: static RBinInfo* info(RBinFile *bf);",
          "16: static int get_file_type(RBinFile *bf) {",
          "17:  struct Elf_(r_bin_elf_obj_t) *obj = bf->o->bin_obj;",
          "18:  char *type = Elf_(r_bin_elf_get_file_type (obj));",
          "19:  int res = type? ((!strncmp (type, \"CORE\", 4)) ? R_BIN_TYPE_CORE : R_BIN_TYPE_DEFAULT) : -1;",
          "20:  free (type);",
          "21:  return res;",
          "22: }",
          "24: static RList *maps(RBinFile *bf) {",
          "25:  if (bf && bf->o) {",
          "26:   return Elf_(r_bin_elf_get_maps)(bf->o->bin_obj);",
          "27:  }",
          "28:  return NULL;",
          "29: }",
          "31: static char* regstate(RBinFile *bf) {",
          "32:  struct Elf_(r_bin_elf_obj_t) *obj = bf->o->bin_obj;",
          "33:  if (obj->ehdr.e_machine != EM_AARCH64 &&",
          "34:   obj->ehdr.e_machine != EM_ARM &&",
          "35:   obj->ehdr.e_machine != EM_386 &&",
          "36:   obj->ehdr.e_machine != EM_X86_64) {",
          "37:   eprintf (\"Cannot retrieve regstate on: %s (not yet supported)\\n\",",
          "38:      Elf_(r_bin_elf_get_machine_name)(obj));",
          "39:   return NULL;",
          "40:  }",
          "42:  int len = 0;",
          "43:  ut8 *regs = Elf_(r_bin_elf_grab_regstate) (obj, &len);",
          "44:  char *hexregs = (regs && len > 0) ? r_hex_bin2strdup (regs, len) : NULL;",
          "46:  free (regs);",
          "47:  return hexregs;",
          "48: }",
          "50: static void setsymord(ELFOBJ* eobj, ut32 ord, RBinSymbol *ptr) {",
          "51:  if (!eobj->symbols_by_ord || ord >= eobj->symbols_by_ord_size) {",
          "52:   return;",
          "53:  }",
          "54:  r_bin_symbol_free (eobj->symbols_by_ord[ord]);",
          "55:  eobj->symbols_by_ord[ord] = r_bin_symbol_clone (ptr);",
          "56: }",
          "58: static void setimpord(ELFOBJ* eobj, ut32 ord, RBinImport *ptr) {",
          "59:  if (!eobj->imports_by_ord || ord >= eobj->imports_by_ord_size) {",
          "60:   return;",
          "61:  }",
          "62:  r_bin_import_free (eobj->imports_by_ord[ord]);",
          "63:  eobj->imports_by_ord[ord] = r_bin_import_clone (ptr);",
          "64: }",
          "66: static Sdb* get_sdb(RBinFile *bf) {",
          "67:  RBinObject *o = bf->o;",
          "68:  if (o && o->bin_obj) {",
          "69:   struct Elf_(r_bin_elf_obj_t) *bin = (struct Elf_(r_bin_elf_obj_t) *) o->bin_obj;",
          "70:   return bin->kv;",
          "71:  }",
          "72:  return NULL;",
          "73: }",
          "75: static void * load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {",
          "76:  struct Elf_(r_bin_elf_obj_t) *res;",
          "77:  if (!buf) {",
          "78:   return NULL;",
          "79:  }",
          "80:  res = Elf_(r_bin_elf_new_buf) (buf, bf->rbin->verbose);",
          "81:  if (res) {",
          "82:   sdb_ns_set (sdb, \"info\", res->kv);",
          "83:  }",
          "84:  return res;",
          "85: }",
          "87: static void * load_bytes(RBinFile *bf, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb) {",
          "88:  struct Elf_(r_bin_elf_obj_t) *res;",
          "89:  if (!buf || !sz || sz == UT64_MAX) {",
          "90:   return NULL;",
          "91:  }",
          "92:  RBuffer *tbuf = r_buf_new ();",
          "94:  r_buf_set_bytes (tbuf, buf, sz);",
          "95:  res = Elf_(r_bin_elf_new_buf) (tbuf, bf->rbin->verbose);",
          "96:  if (res) {",
          "97:   sdb_ns_set (sdb, \"info\", res->kv);",
          "98:  }",
          "99:  r_buf_free (tbuf);",
          "100:  return res;",
          "101: }",
          "103: static bool load(RBinFile *bf) {",
          "104:  const ut8 *bytes = bf ? r_buf_buffer (bf->buf) : NULL;",
          "105:  ut64 sz = bf ? r_buf_size (bf->buf): 0;",
          "106:  if (!bf || !bf->o) {",
          "107:   return false;",
          "108:  }",
          "109:  bf->o->bin_obj = load_bytes (bf, bytes, sz, bf->o->loadaddr, bf->sdb);",
          "110:  return bf->o->bin_obj != NULL;",
          "111: }",
          "113: static int destroy(RBinFile *bf) {",
          "114:  int i;",
          "115:  ELFOBJ* eobj = bf->o->bin_obj;",
          "116:  if (eobj && eobj->imports_by_ord) {",
          "117:   for (i = 0; i < eobj->imports_by_ord_size; i++) {",
          "118:    RBinImport *imp = eobj->imports_by_ord[i];",
          "119:    if (imp) {",
          "120:     free (imp->name);",
          "121:     free (imp);",
          "122:     eobj->imports_by_ord[i] = NULL;",
          "123:    }",
          "124:   }",
          "125:   R_FREE (eobj->imports_by_ord);",
          "126:  }",
          "127:  Elf_(r_bin_elf_free) ((struct Elf_(r_bin_elf_obj_t)*)bf->o->bin_obj);",
          "128:  return true;",
          "129: }",
          "131: static ut64 baddr(RBinFile *bf) {",
          "132:  return Elf_(r_bin_elf_get_baddr) (bf->o->bin_obj);",
          "133: }",
          "135: static ut64 boffset(RBinFile *bf) {",
          "136:  return Elf_(r_bin_elf_get_boffset) (bf->o->bin_obj);",
          "137: }",
          "139: static RBinAddr* binsym(RBinFile *bf, int sym) {",
          "140:  struct Elf_(r_bin_elf_obj_t)* obj = bf->o->bin_obj;",
          "141:  RBinAddr *ret = NULL;",
          "142:  ut64 addr = 0LL;",
          "144:  switch (sym) {",
          "145:  case R_BIN_SYM_ENTRY:",
          "146:   addr = Elf_(r_bin_elf_get_entry_offset) (bf->o->bin_obj);",
          "147:   break;",
          "148:  case R_BIN_SYM_MAIN:",
          "149:   addr = Elf_(r_bin_elf_get_main_offset) (bf->o->bin_obj);",
          "150:   break;",
          "151:  case R_BIN_SYM_INIT:",
          "152:   addr = Elf_(r_bin_elf_get_init_offset) (bf->o->bin_obj);",
          "153:   break;",
          "154:  case R_BIN_SYM_FINI:",
          "155:   addr = Elf_(r_bin_elf_get_fini_offset) (bf->o->bin_obj);",
          "156:   break;",
          "157:  }",
          "158:  if (addr && addr != UT64_MAX && (ret = R_NEW0 (RBinAddr))) {",
          "159:   struct Elf_(r_bin_elf_obj_t) *bin = bf->o->bin_obj;",
          "160:   bool is_arm = bin->ehdr.e_machine == EM_ARM;",
          "161:   ret->paddr = addr;",
          "162:   ret->vaddr = Elf_(r_bin_elf_p2v) (obj, addr);",
          "163:   if (is_arm && addr & 1) {",
          "164:    ret->bits = 16;",
          "165:    ret->vaddr--;",
          "166:    ret->paddr--;",
          "167:   }",
          "168:  }",
          "169:  return ret;",
          "170: }",
          "172: static RList* sections(RBinFile *bf) {",
          "173:  struct Elf_(r_bin_elf_obj_t)* obj = (bf && bf->o)? bf->o->bin_obj : NULL;",
          "174:  struct r_bin_elf_section_t *section = NULL;",
          "175:  int i, num, found_load = 0;",
          "176:  Elf_(Phdr)* phdr = NULL;",
          "177:  RBinSection *ptr = NULL;",
          "178:  RList *ret = NULL;",
          "180:  if (!obj || !(ret = r_list_newf (free))) {",
          "181:   return NULL;",
          "182:  }",
          "185:  if ((section = Elf_(r_bin_elf_get_sections) (obj))) {",
          "186:   for (i = 0; !section[i].last; i++) {",
          "187:    if (!(ptr = R_NEW0 (RBinSection))) {",
          "188:     break;",
          "189:    }",
          "190:    strncpy (ptr->name, (char*)section[i].name, R_BIN_SIZEOF_STRINGS);",
          "191:    if (strstr (ptr->name, \"data\") && !strstr (ptr->name, \"rel\")) {",
          "192:     ptr->is_data = true;",
          "193:    }",
          "194:    ptr->size = section[i].type != SHT_NOBITS ? section[i].size : 0;",
          "195:    ptr->vsize = section[i].size;",
          "196:    ptr->paddr = section[i].offset;",
          "197:    ptr->vaddr = section[i].rva;",
          "198:    ptr->add = !obj->phdr; // Load sections if there is no PHDR",
          "199:    ptr->srwx = 0;",
          "200:    if (R_BIN_ELF_SCN_IS_EXECUTABLE (section[i].flags)) {",
          "201:     ptr->srwx |= R_BIN_SCN_EXECUTABLE;",
          "202:    }",
          "203:    if (R_BIN_ELF_SCN_IS_WRITABLE (section[i].flags)) {",
          "204:     ptr->srwx |= R_BIN_SCN_WRITABLE;",
          "205:    }",
          "206:    if (R_BIN_ELF_SCN_IS_READABLE (section[i].flags)) {",
          "207:     ptr->srwx |= R_BIN_SCN_READABLE;",
          "208:    }",
          "209:    r_list_append (ret, ptr);",
          "210:   }",
          "211:  }",
          "214:  num = obj->ehdr.e_phnum;",
          "215:  phdr = obj->phdr;",
          "216:  if (phdr) {",
          "217:   int n = 0;",
          "218:   for (i = 0; i < num; i++) {",
          "219:    if (!(ptr = R_NEW0 (RBinSection))) {",
          "220:     return ret;",
          "221:    }",
          "222:    ptr->add = false;",
          "223:    ptr->size = phdr[i].p_filesz;",
          "224:    ptr->vsize = phdr[i].p_memsz;",
          "225:    ptr->paddr = phdr[i].p_offset;",
          "226:    ptr->vaddr = phdr[i].p_vaddr;",
          "227:    ptr->srwx = phdr[i].p_flags;",
          "228:    ptr->is_segment = true;",
          "229:    switch (phdr[i].p_type) {",
          "230:    case PT_DYNAMIC:",
          "231:     strncpy (ptr->name, \"DYNAMIC\", R_BIN_SIZEOF_STRINGS);",
          "232:     break;",
          "233:    case PT_LOAD:",
          "234:     snprintf (ptr->name, R_BIN_SIZEOF_STRINGS, \"LOAD%d\", n++);",
          "235:     found_load = 1;",
          "236:     ptr->add = true;",
          "237:     break;",
          "238:    case PT_INTERP:",
          "239:     strncpy (ptr->name, \"INTERP\", R_BIN_SIZEOF_STRINGS);",
          "240:     break;",
          "241:    case PT_GNU_STACK:",
          "242:     strncpy (ptr->name, \"GNU_STACK\", R_BIN_SIZEOF_STRINGS);",
          "243:     break;",
          "244:    case PT_GNU_RELRO:",
          "245:     strncpy (ptr->name, \"GNU_RELRO\", R_BIN_SIZEOF_STRINGS);",
          "246:     break;",
          "247:    case PT_GNU_EH_FRAME:",
          "248:     strncpy (ptr->name, \"GNU_EH_FRAME\", R_BIN_SIZEOF_STRINGS);",
          "249:     break;",
          "250:    case PT_PHDR:",
          "251:     strncpy (ptr->name, \"PHDR\", R_BIN_SIZEOF_STRINGS);",
          "252:     break;",
          "253:    case PT_TLS:",
          "254:     strncpy (ptr->name, \"TLS\", R_BIN_SIZEOF_STRINGS);",
          "255:     break;",
          "256:    case PT_NOTE:",
          "257:     strncpy (ptr->name, \"NOTE\", R_BIN_SIZEOF_STRINGS);",
          "258:     break;",
          "259:    default:",
          "260:     strncpy (ptr->name, \"UNKNOWN\", R_BIN_SIZEOF_STRINGS);",
          "261:     break;",
          "262:    }",
          "263:    ptr->name[R_BIN_SIZEOF_STRINGS - 1] = '\\0';",
          "264:    r_list_append (ret, ptr);",
          "265:   }",
          "266:  }",
          "268:  if (r_list_empty (ret)) {",
          "269:   if (!bf->size) {",
          "270:    struct Elf_(r_bin_elf_obj_t) *bin = bf->o->bin_obj;",
          "271:    bf->size = bin? bin->size: 0x9999;",
          "272:   }",
          "273:   if (found_load == 0) {",
          "274:    if (!(ptr = R_NEW0 (RBinSection))) {",
          "275:     return ret;",
          "276:    }",
          "277:    sprintf (ptr->name, \"uphdr\");",
          "278:    ptr->size = bf->size;",
          "279:    ptr->vsize = bf->size;",
          "280:    ptr->paddr = 0;",
          "281:    ptr->vaddr = 0x10000;",
          "282:    ptr->add = true;",
          "283:    ptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_WRITABLE |",
          "284:     R_BIN_SCN_EXECUTABLE;",
          "285:    r_list_append (ret, ptr);",
          "286:   }",
          "287:  }",
          "289:  ptr = R_NEW0 (RBinSection);",
          "290:  if (ptr) {",
          "291:   ut64 ehdr_size = sizeof (obj->ehdr);",
          "292:   if (bf->size < ehdr_size) {",
          "293:    ehdr_size = bf->size;",
          "294:   }",
          "295:   sprintf (ptr->name, \"ehdr\");",
          "296:   ptr->paddr = 0;",
          "297:   ptr->vaddr = obj->baddr;",
          "298:   ptr->size = ehdr_size;",
          "299:   ptr->vsize = ehdr_size;",
          "300:   ptr->add = false;",
          "301:   if (obj->ehdr.e_type == ET_REL) {",
          "302:    ptr->add = true;",
          "303:   }",
          "304:   ptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_WRITABLE;",
          "305:   ptr->is_segment = true;",
          "306:   r_list_append (ret, ptr);",
          "307:  }",
          "308:  return ret;",
          "309: }",
          "311: static RBinAddr* newEntry(ut64 hpaddr, ut64 hvaddr, ut64 paddr, int type, int bits) {",
          "312:  RBinAddr *ptr = R_NEW0 (RBinAddr);",
          "313:  if (ptr) {",
          "314:   ptr->paddr = paddr;",
          "315:   ptr->vaddr = paddr;",
          "316:   ptr->hpaddr = hpaddr;",
          "317:   ptr->hvaddr = hvaddr;",
          "318:   ptr->bits = bits;",
          "319:   ptr->type = type;",
          "321:   if (bits == 16 && ptr->vaddr & 1) {",
          "322:    ptr->paddr--;",
          "323:    ptr->vaddr--;",
          "324:   }",
          "325:  }",
          "326:  return ptr;",
          "327: }",
          "329: static void process_constructors (RBinFile *bf, RList *ret, int bits) {",
          "330:  RList *secs = sections (bf);",
          "331:  RListIter *iter;",
          "332:  RBinSection *sec;",
          "333:  int i, type;",
          "334:  r_list_foreach (secs, iter, sec) {",
          "335:   type = -1;",
          "336:   if (!strcmp (sec->name, \".fini_array\")) {",
          "337:    type = R_BIN_ENTRY_TYPE_FINI;",
          "338:   } else if (!strcmp (sec->name, \".init_array\")) {",
          "339:    type = R_BIN_ENTRY_TYPE_INIT;",
          "340:   } else if (!strcmp (sec->name, \".preinit_array\")) {",
          "341:    type = R_BIN_ENTRY_TYPE_PREINIT;",
          "342:   }",
          "343:   if (type != -1) {",
          "344:    ut8 *buf = calloc (sec->size, 1);",
          "345:    if (!buf) {",
          "346:     continue;",
          "347:    }",
          "348:    (void)r_buf_read_at (bf->buf, sec->paddr, buf, sec->size);",
          "349:    if (bits == 32) {",
          "350:     for (i = 0; (i + 3) < sec->size; i += 4) {",
          "351:      ut32 addr32 = r_read_le32 (buf + i);",
          "352:      if (addr32) {",
          "353:       RBinAddr *ba = newEntry (sec->paddr + i, sec->vaddr + i,",
          "354:                                (ut64)addr32, type, bits);",
          "355:       r_list_append (ret, ba);",
          "356:      }",
          "357:     }",
          "358:    } else {",
          "359:     for (i = 0; (i + 7) < sec->size; i += 8) {",
          "360:      ut64 addr64 = r_read_le64 (buf + i);",
          "361:      if (addr64) {",
          "362:       RBinAddr *ba = newEntry (sec->paddr + i, sec->vaddr + i,",
          "363:                                addr64, type, bits);",
          "364:       r_list_append (ret, ba);",
          "365:      }",
          "366:     }",
          "367:    }",
          "368:    free (buf);",
          "369:   }",
          "370:  }",
          "371:  r_list_free (secs);",
          "372: }",
          "374: static RList* entries(RBinFile *bf) {",
          "375:  struct Elf_(r_bin_elf_obj_t)* obj;",
          "376:  RBinAddr *ptr = NULL;",
          "377:  struct r_bin_elf_symbol_t *symbol;",
          "378:  RList *ret;",
          "379:  int i;",
          "381:  if (!bf || !bf->o || !bf->o->bin_obj) {",
          "382:   return NULL;",
          "383:  }",
          "384:  obj = bf->o->bin_obj;",
          "385:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "386:   return NULL;",
          "387:  }",
          "388:  if (!(ptr = R_NEW0 (RBinAddr))) {",
          "389:   return ret;",
          "390:  }",
          "391:  ptr->paddr = Elf_(r_bin_elf_get_entry_offset) (obj);",
          "392:  ptr->vaddr = Elf_(r_bin_elf_p2v) (obj, ptr->paddr);",
          "393:  ptr->hpaddr = 0x18;  // e_entry offset in ELF header",
          "395:  if (obj->ehdr.e_machine == EM_ARM) {",
          "396:   int bin_bits = Elf_(r_bin_elf_get_bits) (obj);",
          "397:   if (bin_bits != 64) {",
          "398:    ptr->bits = 32;",
          "399:    if (ptr->vaddr & 1) {",
          "400:     ptr->vaddr--;",
          "401:     ptr->bits = 16;",
          "402:    }",
          "403:    if (ptr->paddr & 1) {",
          "404:     ptr->paddr--;",
          "405:     ptr->bits = 16;",
          "406:    }",
          "407:   }",
          "408:  }",
          "409:  r_list_append (ret, ptr);",
          "413:  if (!(symbol = Elf_(r_bin_elf_get_symbols) (obj))) {",
          "414:   return ret;",
          "415:  }",
          "416:  for (i = 0; !symbol[i].last; i++) {",
          "417:   if (!strncmp (symbol[i].name, \"Java\", 4)) {",
          "418:    if (r_str_endswith (symbol[i].name, \"_init\")) {",
          "419:     if (!(ptr = R_NEW0 (RBinAddr))) {",
          "420:      return ret;",
          "421:     }",
          "422:     ptr->paddr = symbol[i].offset;",
          "423:     ptr->vaddr = Elf_(r_bin_elf_p2v) (obj, ptr->paddr);",
          "424:     ptr->hpaddr = UT64_MAX;",
          "425:     ptr->type = R_BIN_ENTRY_TYPE_INIT;",
          "426:     r_list_append (ret, ptr);",
          "427:     break;",
          "428:    }",
          "429:   }",
          "430:  }",
          "431:  int bin_bits = Elf_(r_bin_elf_get_bits) (bf->o->bin_obj);",
          "432:  process_constructors (bf, ret, bin_bits < 32 ? 32: bin_bits);",
          "433:  return ret;",
          "434: }",
          "436: static void _set_arm_thumb_bits(struct Elf_(r_bin_elf_obj_t) *bin, RBinSymbol **sym) {",
          "437:  int bin_bits = Elf_(r_bin_elf_get_bits) (bin);",
          "438:  RBinSymbol *ptr = *sym;",
          "439:  int len = strlen (ptr->name);",
          "440:  if (ptr->name[0] == '$' && (len >= 2 && !ptr->name[2])) {",
          "441:   switch (ptr->name[1]) {",
          "442:   case 'a' : //arm",
          "443:    ptr->bits = 32;",
          "444:    break;",
          "445:   case 't': //thumb",
          "446:    ptr->bits = 16;",
          "447:    if (ptr->vaddr & 1) {",
          "448:     ptr->vaddr--;",
          "449:    }",
          "450:    if (ptr->paddr & 1) {",
          "451:     ptr->paddr--;",
          "452:    }",
          "453:    break;",
          "454:   case 'd': //data",
          "455:    break;",
          "456:   default:",
          "457:    goto arm_symbol;",
          "458:   }",
          "459:  } else {",
          "460: arm_symbol:",
          "461:   ptr->bits = bin_bits;",
          "462:   if (bin_bits != 64) {",
          "463:    ptr->bits = 32;",
          "464:    if (ptr->vaddr & 1) {",
          "465:     ptr->vaddr--;",
          "466:     ptr->bits = 16;",
          "467:    }",
          "468:    if (ptr->paddr & 1) {",
          "469:     ptr->paddr--;",
          "470:     ptr->bits = 16;",
          "471:    }",
          "472:   }",
          "473:  }",
          "474: }",
          "476: static RBinSymbol *convert_symbol(struct Elf_(r_bin_elf_obj_t) *bin,",
          "477:       struct r_bin_elf_symbol_t *symbol,",
          "478:       const char *namefmt) {",
          "479:  ut64 paddr = symbol->offset;",
          "480:  ut64 vaddr = Elf_(r_bin_elf_p2v) (bin, paddr);",
          "481:  RBinSymbol *ptr = NULL;",
          "483:  if (!(ptr = R_NEW0 (RBinSymbol))) {",
          "484:   return NULL;",
          "485:  }",
          "486:  ptr->name = symbol->name[0] ? r_str_newf (namefmt, &symbol->name[0]) : strdup(\"\");",
          "487:  ptr->forwarder = r_str_const (\"NONE\");",
          "488:  ptr->bind = r_str_const (symbol->bind);",
          "489:  ptr->type = r_str_const (symbol->type);",
          "490:  ptr->paddr = paddr;",
          "491:  ptr->vaddr = vaddr;",
          "492:  ptr->size = symbol->size;",
          "493:  ptr->ordinal = symbol->ordinal;",
          "495:  if (bin->ehdr.e_machine == EM_ARM && *ptr->name) {",
          "496:   _set_arm_thumb_bits (bin, &ptr);",
          "497:  }",
          "499:  return ptr;",
          "500: }",
          "502: static void insert_symbol(struct Elf_(r_bin_elf_obj_t) *bin,",
          "503:      RBinSymbol *ptr,",
          "504:      bool is_sht_null,",
          "505:      RList *ret) {",
          "507:  setsymord (bin, ptr->ordinal, ptr);",
          "509:  if (is_sht_null) {",
          "510:   r_bin_symbol_free (ptr);",
          "511:  } else {",
          "512:   r_list_append (ret, ptr);",
          "513:  }",
          "514: }",
          "516: static RList* symbols(RBinFile *bf) {",
          "517:  struct Elf_(r_bin_elf_obj_t) *bin;",
          "518:  struct r_bin_elf_symbol_t *symbol = NULL;",
          "519:  RBinSymbol *ptr = NULL;",
          "520:  RList *ret = NULL;",
          "521:  int i;",
          "523:  if (!bf|| !bf->o || !bf->o->bin_obj) {",
          "524:   return NULL;",
          "525:  }",
          "527:  bin = bf->o->bin_obj;",
          "528:  ret = r_list_newf (free);",
          "529:  if (!ret) {",
          "530:   return NULL;",
          "531:  }",
          "534:  if (!(symbol = Elf_(r_bin_elf_get_symbols) (bin))) {",
          "535:   return ret;",
          "536:  }",
          "537:  for (i = 0; !symbol[i].last; i++) {",
          "538:   ptr = convert_symbol (bin, &symbol[i], \"%s\");",
          "539:   if (!ptr) {",
          "540:    break;",
          "541:   }",
          "542:   insert_symbol (bin, ptr, symbol[i].is_sht_null, ret);",
          "543:  }",
          "546:  if (!(symbol = Elf_(r_bin_elf_get_imports) (bin))) {",
          "547:   return ret;",
          "548:  }",
          "549:  for (i = 0; !symbol[i].last; i++) {",
          "550:   if (!symbol[i].size) {",
          "551:    continue;",
          "552:   }",
          "554:   ptr = convert_symbol (bin, &symbol[i], \"imp.%s\");",
          "555:   if (!ptr) {",
          "556:    break;",
          "557:   }",
          "560:   if (ptr->vaddr == UT32_MAX) {",
          "561:    ptr->paddr = 0;",
          "562:    ptr->vaddr = 0;",
          "563:   }",
          "565:   insert_symbol (bin, ptr, symbol[i].is_sht_null, ret);",
          "566:  }",
          "567:  return ret;",
          "568: }",
          "570: static RList* imports(RBinFile *bf) {",
          "571:  struct Elf_(r_bin_elf_obj_t) *bin = NULL;",
          "572:  RBinElfSymbol *import = NULL;",
          "573:  RBinImport *ptr = NULL;",
          "574:  RList *ret = NULL;",
          "575:  int i;",
          "577:  if (!bf || !bf->o || !bf->o->bin_obj) {",
          "578:   return NULL;",
          "579:  }",
          "580:  bin = bf->o->bin_obj;",
          "581:  if (!(ret = r_list_newf (r_bin_import_free))) {",
          "582:   return NULL;",
          "583:  }",
          "584:  if (!(import = Elf_(r_bin_elf_get_imports) (bin))) {",
          "585:   r_list_free (ret);",
          "586:   return NULL;",
          "587:  }",
          "588:  for (i = 0; !import[i].last; i++) {",
          "589:   if (!(ptr = R_NEW0 (RBinImport))) {",
          "590:    break;",
          "591:   }",
          "592:   ptr->name = strdup (import[i].name);",
          "593:   ptr->bind = r_str_const (import[i].bind);",
          "594:   ptr->type = r_str_const (import[i].type);",
          "595:   ptr->ordinal = import[i].ordinal;",
          "596:   setimpord (bin, ptr->ordinal, ptr);",
          "597:   r_list_append (ret, ptr);",
          "598:  }",
          "599:  return ret;",
          "600: }",
          "602: static RList* libs(RBinFile *bf) {",
          "603:  struct r_bin_elf_lib_t *libs = NULL;",
          "604:  RList *ret = NULL;",
          "605:  char *ptr = NULL;",
          "606:  int i;",
          "608:  if (!bf || !bf->o || !bf->o->bin_obj) {",
          "609:   return NULL;",
          "610:  }",
          "611:  if (!(ret = r_list_newf (free))) {",
          "612:   return NULL;",
          "613:  }",
          "614:  if (!(libs = Elf_(r_bin_elf_get_libs) (bf->o->bin_obj))) {",
          "615:   return ret;",
          "616:  }",
          "617:  for (i = 0; !libs[i].last; i++) {",
          "618:   ptr = strdup (libs[i].name);",
          "619:   r_list_append (ret, ptr);",
          "620:  }",
          "621:  free (libs);",
          "622:  return ret;",
          "623: }",
          "625: static RBinReloc *reloc_convert(struct Elf_(r_bin_elf_obj_t) *bin, RBinElfReloc *rel, ut64 GOT) {",
          "626:  RBinReloc *r = NULL;",
          "627:  ut64 B, P;",
          "629:  if (!bin || !rel) {",
          "630:   return NULL;",
          "631:  }",
          "632:  B = bin->baddr;",
          "633:  P = rel->rva; // rva has taken baddr into account",
          "634:  if (!(r = R_NEW0 (RBinReloc))) {",
          "635:   return r;",
          "636:  }",
          "637:  r->import = NULL;",
          "638:  r->symbol = NULL;",
          "639:  r->is_ifunc = false;",
          "640:  r->addend = rel->addend;",
          "641:  if (rel->sym) {",
          "642:   if (rel->sym < bin->imports_by_ord_size && bin->imports_by_ord[rel->sym]) {",
          "643:    r->import = bin->imports_by_ord[rel->sym];",
          "644:   } else if (rel->sym < bin->symbols_by_ord_size && bin->symbols_by_ord[rel->sym]) {",
          "645:    r->symbol = bin->symbols_by_ord[rel->sym];",
          "646:   }",
          "647:  }",
          "648:  r->vaddr = rel->rva;",
          "649:  r->paddr = rel->offset;",
          "651:  #define SET(T) r->type = R_BIN_RELOC_ ## T; r->additive = 0; return r",
          "652:  #define ADD(T, A) r->type = R_BIN_RELOC_ ## T; r->addend += A; r->additive = !rel->is_rela; return r",
          "654:  switch (bin->ehdr.e_machine) {",
          "655:  case EM_386: switch (rel->type) {",
          "656:   case R_386_NONE:     break; // malloc then free. meh. then again, there's no real world use for _NONE.",
          "657:   case R_386_32:       ADD(32, 0);",
          "658:   case R_386_PC32:     ADD(32,-P);",
          "659:   case R_386_GLOB_DAT: SET(32);",
          "660:   case R_386_JMP_SLOT: SET(32);",
          "661:   case R_386_RELATIVE: ADD(32, B);",
          "662:   case R_386_GOTOFF:   ADD(32,-GOT);",
          "663:   case R_386_GOTPC:    ADD(32, GOT-P);",
          "664:   case R_386_16:       ADD(16, 0);",
          "665:   case R_386_PC16:     ADD(16,-P);",
          "666:   case R_386_8:        ADD(8,  0);",
          "667:   case R_386_PC8:      ADD(8, -P);",
          "668:   case R_386_COPY:     ADD(64, 0); // XXX: copy symbol at runtime",
          "669:   case R_386_IRELATIVE: r->is_ifunc = true; SET(32);",
          "670:   default: break; //eprintf(\"TODO(eddyb): uninmplemented ELF/x86 reloc type %i\\n\", rel->type);",
          "671:   }",
          "672:   break;",
          "673:  case EM_X86_64: switch (rel->type) {",
          "674:   case R_X86_64_NONE: break; // malloc then free. meh. then again, there's no real world use for _NONE.",
          "675:   case R_X86_64_64: ADD(64, 0);",
          "676:   case R_X86_64_PLT32: ADD(32,-P /* +L */);",
          "677:   case R_X86_64_GOT32: ADD(32, GOT);",
          "678:   case R_X86_64_PC32: ADD(32,-P);",
          "679:   case R_X86_64_GLOB_DAT: r->vaddr -= rel->sto; SET(64);",
          "680:   case R_X86_64_JUMP_SLOT: r->vaddr -= rel->sto; SET(64);",
          "681:   case R_X86_64_RELATIVE: ADD(64, B);",
          "682:   case R_X86_64_32: ADD(32, 0);",
          "683:   case R_X86_64_32S: ADD(32, 0);",
          "684:   case R_X86_64_16: ADD(16, 0);",
          "685:   case R_X86_64_PC16: ADD(16,-P);",
          "686:   case R_X86_64_8: ADD(8,  0);",
          "687:   case R_X86_64_PC8: ADD(8, -P);",
          "688:   case R_X86_64_GOTPCREL: ADD(64, GOT-P);",
          "689:   case R_X86_64_COPY: ADD(64, 0); // XXX: copy symbol at runtime",
          "690:   case R_X86_64_IRELATIVE: r->is_ifunc = true; SET(64);",
          "691:   default: break; ////eprintf(\"TODO(eddyb): uninmplemented ELF/x64 reloc type %i\\n\", rel->type);",
          "692:   }",
          "693:   break;",
          "694:  case EM_ARM: switch (rel->type) {",
          "695:   case R_ARM_NONE: break; // malloc then free. meh. then again, there's no real world use for _NONE.",
          "696:   case R_ARM_ABS32: ADD(32, 0);",
          "697:   case R_ARM_REL32: ADD(32,-P);",
          "698:   case R_ARM_ABS16: ADD(16, 0);",
          "699:   case R_ARM_ABS8: ADD(8,  0);",
          "700:   case R_ARM_SBREL32: ADD(32, -B);",
          "701:   case R_ARM_GLOB_DAT: ADD(32, 0);",
          "702:   case R_ARM_JUMP_SLOT: ADD(32, 0);",
          "703:   case R_ARM_RELATIVE: ADD(32, B);",
          "704:   case R_ARM_GOTOFF: ADD(32,-GOT);",
          "705:   default: ADD(32,GOT); break; // reg relocations",
          "707:   }",
          "708:   break;",
          "709:  default: break;",
          "710:  }",
          "712:  #undef SET",
          "713:  #undef ADD",
          "715:  free(r);",
          "716:  return 0;",
          "717: }",
          "719: static RList* relocs(RBinFile *bf) {",
          "720:  RList *ret = NULL;",
          "721:  RBinReloc *ptr = NULL;",
          "722:  RBinElfReloc *relocs = NULL;",
          "723:  struct Elf_(r_bin_elf_obj_t) *bin = NULL;",
          "724:  ut64 got_addr;",
          "725:  int i;",
          "726:  if (!bf || !bf->o || !bf->o->bin_obj) {",
          "727:   return NULL;",
          "728:  }",
          "729:  bin = bf->o->bin_obj;",
          "730:  if (!(ret = r_list_newf (free))) {",
          "731:   return NULL;",
          "732:  }",
          "735:  r_list_free (imports (bf));",
          "736:  if ((got_addr = Elf_(r_bin_elf_get_section_addr) (bin, \".got\")) == -1) {",
          "737:   got_addr = Elf_(r_bin_elf_get_section_addr) (bin, \".got.plt\");",
          "738:   if (got_addr == -1) {",
          "739:    got_addr = 0;",
          "740:   }",
          "741:  }",
          "742:  if (got_addr < 1 && bin->ehdr.e_type == ET_REL) {",
          "743:   got_addr = Elf_(r_bin_elf_get_section_addr) (bin, \".got.r2\");",
          "744:   if (got_addr == -1) {",
          "745:    got_addr = 0;",
          "746:   }",
          "747:  }",
          "748:  if (bf->o) {",
          "749:   if (!(relocs = Elf_(r_bin_elf_get_relocs) (bin))) {",
          "750:    return ret;",
          "751:   }",
          "752:   for (i = 0; !relocs[i].last; i++) {",
          "753:    if (!(ptr = reloc_convert (bin, &relocs[i], got_addr))) {",
          "754:     continue;",
          "755:    }",
          "756:    r_list_append (ret, ptr);",
          "757:   }",
          "758:   free (relocs);",
          "759:  }",
          "760:  return ret;",
          "761: }",
          "763: static void _patch_reloc (ut16 e_machine, RIOBind *iob, RBinElfReloc *rel, ut64 S, ut64 B, ut64 L) {",
          "764:  ut64 val;",
          "765:  ut64 A = rel->addend, P = rel->rva;",
          "766:  ut8 buf[8];",
          "767:  switch (e_machine) {",
          "768:  case EM_PPC64: {",
          "769:   int low = 0, word = 0;",
          "770:   switch (rel->type) {",
          "771:   case R_PPC64_REL16_HA:",
          "772:    word = 2;",
          "773:    val = (S + A - P + 0x8000) >> 16;",
          "774:    break;",
          "775:   case R_PPC64_REL16_LO:",
          "776:    word = 2;",
          "777:    val = (S + A - P) & 0xffff;",
          "778:    break;",
          "779:   case R_PPC64_REL14:",
          "780:    low = 14;",
          "781:    val = (st64)(S + A - P) >> 2;",
          "782:    break;",
          "783:   case R_PPC64_REL24:",
          "784:    low = 24;",
          "785:    val = (st64)(S + A - P) >> 2;",
          "786:    break;",
          "787:   case R_PPC64_REL32:",
          "788:    word = 4;",
          "789:    val = S + A - P;",
          "790:    break;",
          "791:   default:",
          "792:    break;",
          "793:   }",
          "794:   if (low) {",
          "796:    switch (low) {",
          "797:    case 14:",
          "798:     val &= (1 << 14) - 1;",
          "799:     iob->read_at (iob->io, rel->rva, buf, 2);",
          "800:     r_write_le32 (buf, (r_read_le32 (buf) & ~((1<<16) - (1<<2))) | val << 2);",
          "801:     iob->write_at (iob->io, rel->rva, buf, 2);",
          "802:     break;",
          "803:    case 24:",
          "804:     val &= (1 << 24) - 1;",
          "805:     iob->read_at (iob->io, rel->rva, buf, 4);",
          "806:     r_write_le32 (buf, (r_read_le32 (buf) & ~((1<<26) - (1<<2))) | val << 2);",
          "807:     iob->write_at (iob->io, rel->rva, buf, 4);",
          "808:     break;",
          "809:    }",
          "810:   } else if (word) {",
          "812:    switch (word) {",
          "813:    case 2:",
          "814:     r_write_le16 (buf, val);",
          "815:     iob->write_at (iob->io, rel->rva, buf, 2);",
          "816:     break;",
          "817:    case 4:",
          "818:     r_write_le32 (buf, val);",
          "819:     iob->write_at (iob->io, rel->rva, buf, 4);",
          "820:     break;",
          "821:    }",
          "822:   }",
          "823:   break;",
          "824:  }",
          "825:  case EM_X86_64: {",
          "826:   int word = 0;",
          "827:   switch (rel->type) {",
          "828:   case R_X86_64_8:",
          "829:    word = 1;",
          "830:    val = S + A;",
          "831:    break;",
          "832:   case R_X86_64_16:",
          "833:    word = 2;",
          "834:    val = S + A;",
          "835:    break;",
          "836:   case R_X86_64_32:",
          "837:   case R_X86_64_32S:",
          "838:    word = 4;",
          "839:    val = S + A;",
          "840:    break;",
          "841:   case R_X86_64_64:",
          "842:    word = 8;",
          "843:    val = S + A;",
          "844:    break;",
          "845:   case R_X86_64_GLOB_DAT:",
          "846:   case R_X86_64_JUMP_SLOT:",
          "847:    word = 4;",
          "848:    val = S;",
          "849:    break;",
          "850:   case R_X86_64_PC8:",
          "851:    word = 1;",
          "852:    val = S + A - P;",
          "853:    break;",
          "854:   case R_X86_64_PC16:",
          "855:    word = 2;",
          "856:    val = S + A - P;",
          "857:    break;",
          "858:   case R_X86_64_PC32:",
          "859:    word = 4;",
          "860:    val = S + A - P;",
          "861:    break;",
          "862:   case R_X86_64_PC64:",
          "863:    word = 8;",
          "864:    val = S + A - P;",
          "865:    break;",
          "866:   case R_X86_64_PLT32:",
          "867:    word = 4;",
          "868:    val = L + A - P;",
          "869:    break;",
          "870:   case R_X86_64_RELATIVE:",
          "871:    word = 8;",
          "872:    val = B + A;",
          "873:    break;",
          "874:   default:",
          "876:    break;",
          "877:   }",
          "878:   switch (word) {",
          "879:   case 0:",
          "880:    break;",
          "881:   case 1:",
          "882:    buf[0] = val;",
          "883:    iob->write_at (iob->io, rel->rva, buf, 1);",
          "884:    break;",
          "885:   case 2:",
          "886:    r_write_le16 (buf, val);",
          "887:    iob->write_at (iob->io, rel->rva, buf, 2);",
          "888:    break;",
          "889:   case 4:",
          "890:    r_write_le32 (buf, val);",
          "891:    iob->write_at (iob->io, rel->rva, buf, 4);",
          "892:    break;",
          "893:   case 8:",
          "894:    r_write_le64 (buf, val);",
          "895:    iob->write_at (iob->io, rel->rva, buf, 8);",
          "896:    break;",
          "897:   }",
          "898:   break;",
          "899:  }",
          "900:  }",
          "901: }",
          "903: static bool ht_insert_intu64(SdbHash* ht, int key, ut64 value) {",
          "904:  ut64 *mvalue = malloc (sizeof (ut64));",
          "905:  if (!mvalue) {",
          "906:   return false;",
          "907:  }",
          "909:  return ht_insert (ht, sdb_fmt (\"%d\", key), (void *)mvalue);",
          "910: }",
          "912: static ut64 ht_find_intu64(SdbHash* ht, int key, bool* found) {",
          "913:  ut64 *mvalue = (ut64 *)ht_find (ht, sdb_fmt (\"%d\", key), found);",
          "914:  return *found ? *mvalue : 0;",
          "915: }",
          "917: static void relocs_by_sym_free(HtKv *kv) {",
          "918:  free (kv->key);",
          "919:  free (kv->value);",
          "920: }",
          "922: static RList* patch_relocs(RBin *b) {",
          "923:  RList *ret = NULL;",
          "924:  RBinReloc *ptr = NULL;",
          "925:  RIO *io = NULL;",
          "926:  RBinObject *obj = NULL;",
          "927:  struct Elf_(r_bin_elf_obj_t) *bin = NULL;",
          "928:  RIOSection *g = NULL, *s = NULL;",
          "929:  SdbHash *relocs_by_sym;",
          "930:  SdbListIter *iter;",
          "931:  RBinElfReloc *relcs = NULL;",
          "932:  RBinInfo *info;",
          "933:  int cdsz;",
          "934:  int i;",
          "935:  ut64 n_off, n_vaddr, vaddr, size, offset = 0;",
          "937:  if (!b)",
          "938:   return NULL;",
          "939:  io = b->iob.io;",
          "940:  if (!io || !io->desc)",
          "941:   return NULL;",
          "942:  obj = r_bin_cur_object (b);",
          "943:  if (!obj) {",
          "944:      return NULL;",
          "945:  }",
          "946:  bin = obj->bin_obj;",
          "947:  if (bin->ehdr.e_type != ET_REL) {",
          "948:   return NULL;",
          "949:  }",
          "950:  if (!io->cached) {",
          "951:      eprintf (\"Warning: run r2 with -e io.cache=true to fix relocations in disassembly\\n\");",
          "952:   return relocs (r_bin_cur (b));",
          "953:  }",
          "955:  info = obj ? obj->info: NULL;",
          "956:  cdsz = info? (info->bits == 64? 8: info->bits == 32? 4: info->bits == 16 ? 4: 0): 0;",
          "958:  ls_foreach (io->sections, iter, s) {",
          "959:   if (s->paddr > offset) {",
          "960:    offset = s->paddr;",
          "961:    g = s;",
          "962:   }",
          "963:  }",
          "964:  if (!g) {",
          "965:   return NULL;",
          "966:  }",
          "967:  n_off = g->paddr + g->size;",
          "968:  n_vaddr = g->vaddr + g->vsize;",
          "970:  size = bin->reloc_num * 4;",
          "971:  if (!b->iob.section_add (io, n_off, n_vaddr, size, size, R_BIN_SCN_READABLE, \".got.r2\", 0, io->desc->fd)) {",
          "972:   return NULL;",
          "973:  }",
          "974:  if (!(relcs = Elf_(r_bin_elf_get_relocs) (bin))) {",
          "975:   return NULL;",
          "976:  }",
          "977:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "978:   free (relcs);",
          "979:   return NULL;",
          "980:  }",
          "981:  if (!(relocs_by_sym = ht_new (NULL, relocs_by_sym_free, NULL))) {",
          "982:   r_list_free (ret);",
          "983:   free (relcs);",
          "984:   return NULL;",
          "985:  }",
          "986:  vaddr = n_vaddr;",
          "987:  for (i = 0; !relcs[i].last; i++) {",
          "988:   ut64 sym_addr = 0;",
          "990:   if (relcs[i].sym) {",
          "991:    if (relcs[i].sym < bin->imports_by_ord_size && bin->imports_by_ord[relcs[i].sym]) {",
          "992:     bool found;",
          "994:     sym_addr = ht_find_intu64 (relocs_by_sym, relcs[i].sym, &found);",
          "995:    } else if (relcs[i].sym < bin->symbols_by_ord_size && bin->symbols_by_ord[relcs[i].sym]) {",
          "996:     sym_addr = bin->symbols_by_ord[relcs[i].sym]->vaddr;",
          "997:    }",
          "998:   }",
          "1000:   _patch_reloc (bin->ehdr.e_machine, &b->iob, &relcs[i], sym_addr ? sym_addr : vaddr, 0, n_vaddr + size);",
          "1001:   if (!(ptr = reloc_convert (bin, &relcs[i], n_vaddr))) {",
          "1002:    continue;",
          "1003:   }",
          "1005:   if (sym_addr) {",
          "1006:    ptr->vaddr = sym_addr;",
          "1007:   } else {",
          "1008:    ptr->vaddr = vaddr;",
          "1009:    ht_insert_intu64 (relocs_by_sym, relcs[i].sym, vaddr);",
          "1010:    vaddr += cdsz;",
          "1011:   }",
          "1012:   r_list_append (ret, ptr);",
          "1013:  }",
          "1014:  ht_free (relocs_by_sym);",
          "1015:  free (relcs);",
          "1016:  return ret;",
          "1017: }",
          "1019: static bool has_canary(RBinFile *bf) {",
          "1020:  bool ret = false;",
          "1021:  RList* imports_list = imports (bf);",
          "1022:  RListIter *iter;",
          "1023:  RBinImport *import;",
          "1024:  if (imports_list) {",
          "1025:   r_list_foreach (imports_list, iter, import) {",
          "1026:    if (!strcmp (import->name, \"__stack_chk_fail\") || !strcmp (import->name, \"__stack_smash_handler\")) {",
          "1027:     ret = true;",
          "1028:     break;",
          "1029:    }",
          "1030:   }",
          "1031:   imports_list->free = r_bin_import_free;",
          "1032:   r_list_free (imports_list);",
          "1033:  }",
          "1034:  return ret;",
          "1035: }",
          "1037: static int has_retguard(RBinFile *bf) {",
          "1038:  int ret = -1;",
          "1039:  RList* sections_list = sections (bf);",
          "1040:  RListIter *iter;",
          "1041:  RBinSection *section;",
          "1042:  r_list_foreach (sections_list, iter, section) {",
          "1043:   # define R_BIN_RANDOMDATA_RETGUARD_SZ 48",
          "1044:   if (!strcmp (section->name, \".openbsd.randomdata\")) {",
          "1046:    ret = (section->size >= R_BIN_RANDOMDATA_RETGUARD_SZ);",
          "1047:    break;",
          "1048:   }",
          "1049:  }",
          "1050:  r_list_free (sections_list);",
          "1051:  return ret;",
          "1052: }",
          "1054: static RBinInfo* info(RBinFile *bf) {",
          "1055:  RBinInfo *ret = NULL;",
          "1056:  char *str;",
          "1058:  if (!(ret = R_NEW0 (RBinInfo))) {",
          "1059:   return NULL;",
          "1060:  }",
          "1061:  ret->lang = \"c\";",
          "1062:  ret->file = bf->file",
          "1063:   ? strdup (bf->file)",
          "1064:   : NULL;",
          "1065:  void *obj = bf->o->bin_obj;",
          "1066:  if ((str = Elf_(r_bin_elf_get_rpath)(obj))) {",
          "1067:   ret->rpath = strdup (str);",
          "1068:   free (str);",
          "1069:  } else {",
          "1070:   ret->rpath = strdup (\"NONE\");",
          "1071:  }",
          "1072:  if (!(str = Elf_(r_bin_elf_get_file_type) (obj))) {",
          "1073:   free (ret);",
          "1074:   return NULL;",
          "1075:  }",
          "1076:  ret->type = str;",
          "1077:  ret->has_pi = (strstr (str, \"DYN\"))? 1: 0;",
          "1078:  ret->has_lit = true;",
          "1079:  ret->has_canary = has_canary (bf);",
          "1080:  ret->has_retguard = has_retguard (bf);",
          "1081:  if (!(str = Elf_(r_bin_elf_get_elf_class) (obj))) {",
          "1082:   free (ret);",
          "1083:   return NULL;",
          "1084:  }",
          "1085:  ret->bclass = str;",
          "1086:  if (!(str = Elf_(r_bin_elf_get_osabi_name) (obj))) {",
          "1087:   free (ret);",
          "1088:   return NULL;",
          "1089:  }",
          "1090:  ret->os = str;",
          "1091:  if (!(str = Elf_(r_bin_elf_get_osabi_name) (obj))) {",
          "1092:   free (ret);",
          "1093:   return NULL;",
          "1094:  }",
          "1095:  ret->subsystem = str;",
          "1096:  if (!(str = Elf_(r_bin_elf_get_machine_name) (obj))) {",
          "1097:   free (ret);",
          "1098:   return NULL;",
          "1099:  }",
          "1100:  ret->machine = str;",
          "1101:  if (!(str = Elf_(r_bin_elf_get_arch) (obj))) {",
          "1102:   free (ret);",
          "1103:   return NULL;",
          "1104:  }",
          "1105:  ret->arch = str;",
          "1106:  ret->rclass = strdup (\"elf\");",
          "1107:  ret->bits = Elf_(r_bin_elf_get_bits) (obj);",
          "1108:  if (!strcmp (ret->arch, \"avr\")) {",
          "1109:   ret->bits = 16;",
          "1110:  }",
          "1111:  ret->big_endian = Elf_(r_bin_elf_is_big_endian) (obj);",
          "1112:  ret->has_va = Elf_(r_bin_elf_has_va) (obj);",
          "1113:  ret->has_nx = Elf_(r_bin_elf_has_nx) (obj);",
          "1114:  ret->intrp = Elf_(r_bin_elf_intrp) (obj);",
          "1115:  ret->dbg_info = 0;",
          "1116:  if (!Elf_(r_bin_elf_get_stripped) (obj)) {",
          "1117:   ret->dbg_info |= R_BIN_DBG_LINENUMS | R_BIN_DBG_SYMS | R_BIN_DBG_RELOCS;",
          "1118:  } else {",
          "1119:   ret->dbg_info |= R_BIN_DBG_STRIPPED;",
          "1120:  }",
          "1121:  if (Elf_(r_bin_elf_get_static) (obj)) {",
          "1122:   ret->dbg_info |= R_BIN_DBG_STATIC;",
          "1123:  }",
          "1124:  RBinElfSymbol *symbol;",
          "1125:  if (!(symbol = Elf_(r_bin_elf_get_symbols) (obj))) {",
          "1126:   return ret;",
          "1127:  }",
          "1128:  int i;",
          "1129:  for (i = 0; !symbol[i].last; i++) {",
          "1130:   if (!strncmp (symbol[i].name, \"type.\", 5)) {",
          "1131:    ret->lang = \"go\";",
          "1132:    break;",
          "1133:   }",
          "1134:  }",
          "1135:  return ret;",
          "1136: }",
          "1138: static RList* fields(RBinFile *bf) {",
          "1139:  int left = 0;",
          "1140:  RList *ret = NULL;",
          "1141:  const ut8 *buf = NULL;",
          "1143:  if (!(ret = r_list_new ())) {",
          "1144:   return NULL;",
          "1145:  }",
          "1146:  ret->free = free;",
          "1148:  if (!(buf = r_buf_get_at (bf->buf, 0, &left))) {",
          "1149:   RBinField *ptr = NULL;",
          "1150:   struct r_bin_elf_field_t *field = NULL;",
          "1151:   int i;",
          "1153:   if (!(field = Elf_(r_bin_elf_get_fields) (bf->o->bin_obj))) {",
          "1154:   return ret;",
          "1155:   }",
          "1156:   for (i = 0; !field[i].last; i++) {",
          "1157:    if (!(ptr = R_NEW0 (RBinField))) {",
          "1158:     break;",
          "1159:    }",
          "1160:    ptr->name = strdup (field[i].name);",
          "1161:    ptr->comment = NULL;",
          "1162:    ptr->vaddr = field[i].offset;",
          "1163:    ptr->paddr = field[i].offset;",
          "1164:    r_list_append (ret, ptr);",
          "1165:   }",
          "1166:   free (field);",
          "1168:  } else {",
          "1169:   #define ROW(nam,siz,val,fmt) \\",
          "1170:    r_list_append (ret, r_bin_field_new (addr, addr, siz, nam, sdb_fmt (\"0x%08x\", val), fmt));",
          "1171:   if (left < sizeof (Elf_(Ehdr))) {",
          "1172:    return ret;",
          "1173:   }",
          "1174:   ut64 addr = 0;",
          "1175:   ROW (\"ELF\", 4, r_read_le32 (buf), \"x\"); addr+=0x10;",
          "1176:   ROW (\"Type\", 2, r_read_le16 (buf + addr), \"x\"); addr+=0x2;",
          "1177:   ROW (\"Machine\", 2, r_read_le16 (buf + addr), \"x\"); addr+=0x2;",
          "1178:   ROW (\"Version\", 4, r_read_le32 (buf + addr), \"x\"); addr+=0x4;",
          "1180:   if (r_read_le8 (buf + 0x04) == 1) {",
          "1181:    ROW (\"Entry point\", 4, r_read_le32 (buf + addr), \"x\"); addr+=0x4;",
          "1182:    ROW (\"PhOff\", 4, r_read_le32 (buf + addr), \"x\"); addr+=0x4;",
          "1183:    ROW (\"ShOff\", 4, r_read_le32 (buf + addr), \"x\");",
          "1184:   } else {",
          "1185:    ROW (\"Entry point\", 8, r_read_le64 (buf + addr), \"x\"); addr+=0x8;",
          "1186:    ROW (\"PhOff\", 8, r_read_le64 (buf + addr), \"x\"); addr+=0x8;",
          "1187:    ROW (\"ShOff\", 8, r_read_le64 (buf + addr), \"x\");",
          "1188:   }",
          "1189:  }",
          "1191:  return ret;",
          "1192: }",
          "1194: static ut64 size(RBinFile *bf) {",
          "1195:  ut64 off = 0;",
          "1196:  ut64 len = 0;",
          "1197:  if (!bf->o->sections) {",
          "1198:   RListIter *iter;",
          "1199:   RBinSection *section;",
          "1200:   bf->o->sections = sections (bf);",
          "1201:   r_list_foreach (bf->o->sections, iter, section) {",
          "1202:    if (section->paddr > off) {",
          "1203:     off = section->paddr;",
          "1204:     len = section->size;",
          "1205:    }",
          "1206:   }",
          "1207:  }",
          "1208:  return off + len;",
          "1209: }",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_elf64.c||libr/bin/p/bin_elf64.c": [
          "File: libr/bin/p/bin_elf64.c -> libr/bin/p/bin_elf64.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: #define R_BIN_ELF64 1",
          "6: static bool check_bytes(const ut8 *buf, ut64 length) {",
          "7:  if (buf && length >= 5) {",
          "",
          "[Removed Lines]",
          "4: #include \"bin_elf.c\"",
          "",
          "[Added Lines]",
          "4: #include \"bin_elf.inc\"",
          "",
          "---------------"
        ]
      }
    }
  ]
}